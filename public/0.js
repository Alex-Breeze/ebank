webpackJsonp([0],{

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/index/welcome.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");
// 引入柱状图
__webpack_require__("./node_modules/echarts/lib/chart/bar.js");
__webpack_require__("./node_modules/echarts/lib/chart/line.js");
// 引入提示框和标题组件
__webpack_require__("./node_modules/echarts/lib/component/tooltip.js");
__webpack_require__("./node_modules/echarts/lib/component/title.js");
__webpack_require__("./node_modules/echarts/lib/component/legendScroll.js");
__webpack_require__("./node_modules/echarts/lib/component/dataZoom.js");
__webpack_require__("./node_modules/echarts/lib/component/markPoint.js");
__webpack_require__("./node_modules/echarts/lib/component/markLine.js");
__webpack_require__("./node_modules/echarts/lib/component/toolbox.js");

/* harmony default export */ __webpack_exports__["default"] = ({
	data: function data() {
		return {
			order_into: ''
		};
	},
	mounted: function mounted() {
		var t = this;
		t.$emit('init');

		t.order_into = echarts.init(document.getElementById('order_into'));
		var order_options = {
			title: {
				left: 'center',
				text: '近期15天每日订单交易入账金额统计',
				subtext: '按日划分，金额单位：分'
			},
			tooltip: {
				trigger: 'axis'
			},
			legend: {
				top: '60px',
				data: []
			},
			toolbox: {
				show: true,
				feature: {
					magicType: { show: true, type: ['line', 'bar'] },
					saveAsImage: { show: true }
				}
			},
			grid: {
				top: '160px',
				containLabel: true
			},
			calculable: true,
			dataZoom: [{
				show: true,
				realtime: true,
				start: 80,
				end: 100
			}, {
				type: 'inside',
				realtime: true,
				start: 60,
				end: 100
			}],
			xAxis: [{
				type: 'category',
				data: []
			}],
			yAxis: [{
				type: 'value'
			}],
			series: []
		};
		get('/welcome', {}, function (data) {
			var payments = data.payments;
			var into = data.into;
			for (var date in into.date) {
				order_options.xAxis[0].data.push(into.date[date]);
			}
			// 基本信息变量
			var series_template = function series_template() {
				return {
					name: '',
					type: 'bar',
					data: [],
					markPoint: {
						data: [{ type: 'max', name: '最大值' }, { type: 'min', name: '最小值' }]
					},
					markLine: {
						data: [{ type: 'average', name: '平均值' }]
					},
					label: {
						normal: {
							show: true,
							position: 'top'
						}
					}
				};
			};

			for (var payment in into.amount) {
				var series = series_template();
				series.name = payments[payment] || payment;
				order_options.legend.data.push(series.name);
				for (var _date in into.amount[payment]) {
					series.data.push(into.amount[payment][_date]);
				}
				order_options.series.push(series);
			}

			t.order_into.setOption(order_options);
		});

		window.onresize = function () {
			setTimeout(function () {
				t.order_into.resize();
			}, 200);
		};
	}
});

/***/ }),

/***/ "./node_modules/echarts/lib/CoordinateSystem.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var coordinateSystemCreators = {};

function CoordinateSystemManager() {
  this._coordinateSystems = [];
}

CoordinateSystemManager.prototype = {
  constructor: CoordinateSystemManager,
  create: function (ecModel, api) {
    var coordinateSystems = [];
    zrUtil.each(coordinateSystemCreators, function (creater, type) {
      var list = creater.create(ecModel, api);
      coordinateSystems = coordinateSystems.concat(list || []);
    });
    this._coordinateSystems = coordinateSystems;
  },
  update: function (ecModel, api) {
    zrUtil.each(this._coordinateSystems, function (coordSys) {
      // FIXME MUST have
      coordSys.update && coordSys.update(ecModel, api);
    });
  },
  getCoordinateSystems: function () {
    return this._coordinateSystems.slice();
  }
};

CoordinateSystemManager.register = function (type, coordinateSystemCreator) {
  coordinateSystemCreators[type] = coordinateSystemCreator;
};

CoordinateSystemManager.get = function (type) {
  return coordinateSystemCreators[type];
};

var _default = CoordinateSystemManager;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/ExtensionAPI.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var echartsAPIList = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel']; // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js

function ExtensionAPI(chartInstance) {
  zrUtil.each(echartsAPIList, function (name) {
    this[name] = zrUtil.bind(chartInstance[name], chartInstance);
  }, this);
}

var _default = ExtensionAPI;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var barLayoutGrid = __webpack_require__("./node_modules/echarts/lib/layout/barGrid.js");

__webpack_require__("./node_modules/echarts/lib/coord/cartesian/Grid.js");

__webpack_require__("./node_modules/echarts/lib/chart/bar/BarSeries.js");

__webpack_require__("./node_modules/echarts/lib/chart/bar/BarView.js");

__webpack_require__("./node_modules/echarts/lib/component/gridSimple.js");

// In case developer forget to include grid component
echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar')); // Visual coding for legend

echarts.registerVisual(function (ecModel) {
  ecModel.eachSeriesByType('bar', function (seriesModel) {
    var data = seriesModel.getData();
    data.setVisual('legendSymbol', 'roundRect');
  });
});

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/BarSeries.js":
/***/ (function(module, exports, __webpack_require__) {

var BaseBarSeries = __webpack_require__("./node_modules/echarts/lib/chart/bar/BaseBarSeries.js");

var _default = BaseBarSeries.extend({
  type: 'series.bar',
  dependencies: ['grid', 'polar'],
  brushSelector: 'rect'
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/BarView.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _helper = __webpack_require__("./node_modules/echarts/lib/chart/bar/helper.js");

var setLabel = _helper.setLabel;

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var barItemStyle = __webpack_require__("./node_modules/echarts/lib/chart/bar/barItemStyle.js");

var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth']; // FIXME
// Just for compatible with ec2.

zrUtil.extend(Model.prototype, barItemStyle);

var _default = echarts.extendChartView({
  type: 'bar',
  render: function (seriesModel, ecModel, api) {
    var coordinateSystemType = seriesModel.get('coordinateSystem');

    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
      this._render(seriesModel, ecModel, api);
    } else {}

    return this.group;
  },
  dispose: zrUtil.noop,
  _render: function (seriesModel, ecModel, api) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coord = seriesModel.coordinateSystem;
    var baseAxis = coord.getBaseAxis();
    var isHorizontalOrRadial;

    if (coord.type === 'cartesian2d') {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === 'polar') {
      isHorizontalOrRadial = baseAxis.dim === 'angle';
    }

    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    data.diff(oldData).add(function (dataIndex) {
      if (!data.hasValue(dataIndex)) {
        return;
      }

      var itemModel = data.getItemModel(dataIndex);
      var layout = getLayout[coord.type](data, dataIndex, itemModel);
      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);
      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
    }).update(function (newIndex, oldIndex) {
      var el = oldData.getItemGraphicEl(oldIndex);

      if (!data.hasValue(newIndex)) {
        group.remove(el);
        return;
      }

      var itemModel = data.getItemModel(newIndex);
      var layout = getLayout[coord.type](data, newIndex, itemModel);

      if (el) {
        graphic.updateProps(el, {
          shape: layout
        }, animationModel, newIndex);
      } else {
        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);
      }

      data.setItemGraphicEl(newIndex, el); // Add back

      group.add(el);
      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
    }).remove(function (dataIndex) {
      var el = oldData.getItemGraphicEl(dataIndex);

      if (coord.type === 'cartesian2d') {
        el && removeRect(dataIndex, animationModel, el);
      } else {
        el && removeSector(dataIndex, animationModel, el);
      }
    }).execute();
    this._data = data;
  },
  remove: function (ecModel, api) {
    var group = this.group;
    var data = this._data;

    if (ecModel.get('animation')) {
      if (data) {
        data.eachItemGraphicEl(function (el) {
          if (el.type === 'sector') {
            removeSector(el.dataIndex, ecModel, el);
          } else {
            removeRect(el.dataIndex, ecModel, el);
          }
        });
      }
    } else {
      group.removeAll();
    }
  }
});

var elementCreator = {
  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {
    var rect = new graphic.Rect({
      shape: zrUtil.extend({}, layout)
    }); // Animation

    if (animationModel) {
      var rectShape = rect.shape;
      var animateProperty = isHorizontal ? 'height' : 'width';
      var animateTarget = {};
      rectShape[animateProperty] = 0;
      animateTarget[animateProperty] = layout[animateProperty];
      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {
        shape: animateTarget
      }, animationModel, dataIndex);
    }

    return rect;
  },
  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {
    var sector = new graphic.Sector({
      shape: zrUtil.extend({}, layout)
    }); // Animation

    if (animationModel) {
      var sectorShape = sector.shape;
      var animateProperty = isRadial ? 'r' : 'endAngle';
      var animateTarget = {};
      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
      animateTarget[animateProperty] = layout[animateProperty];
      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {
        shape: animateTarget
      }, animationModel, dataIndex);
    }

    return sector;
  }
};

function removeRect(dataIndex, animationModel, el) {
  // Not show text when animating
  el.style.text = null;
  graphic.updateProps(el, {
    shape: {
      width: 0
    }
  }, animationModel, dataIndex, function () {
    el.parent && el.parent.remove(el);
  });
}

function removeSector(dataIndex, animationModel, el) {
  // Not show text when animating
  el.style.text = null;
  graphic.updateProps(el, {
    shape: {
      r: el.shape.r0
    }
  }, animationModel, dataIndex, function () {
    el.parent && el.parent.remove(el);
  });
}

var getLayout = {
  cartesian2d: function (data, dataIndex, itemModel) {
    var layout = data.getItemLayout(dataIndex);
    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth

    var signX = layout.width > 0 ? 1 : -1;
    var signY = layout.height > 0 ? 1 : -1;
    return {
      x: layout.x + signX * fixedLineWidth / 2,
      y: layout.y + signY * fixedLineWidth / 2,
      width: layout.width - signX * fixedLineWidth,
      height: layout.height - signY * fixedLineWidth
    };
  },
  polar: function (data, dataIndex, itemModel) {
    var layout = data.getItemLayout(dataIndex);
    return {
      cx: layout.cx,
      cy: layout.cy,
      r0: layout.r0,
      r: layout.r,
      startAngle: layout.startAngle,
      endAngle: layout.endAngle
    };
  }
};

function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
  var color = data.getItemVisual(dataIndex, 'color');
  var opacity = data.getItemVisual(dataIndex, 'opacity');
  var itemStyleModel = itemModel.getModel('itemStyle.normal');
  var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();

  if (!isPolar) {
    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);
  }

  el.useStyle(zrUtil.defaults({
    fill: color,
    opacity: opacity
  }, itemStyleModel.getBarItemStyle()));
  var cursorStyle = itemModel.getShallow('cursor');
  cursorStyle && el.attr('cursor', cursorStyle);
  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';

  if (!isPolar) {
    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);
  }

  graphic.setHoverStyle(el, hoverStyle);
} // In case width or height are too small.


function getLineWidth(itemModel, rawLayout) {
  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/BaseBarSeries.js":
/***/ (function(module, exports, __webpack_require__) {

var SeriesModel = __webpack_require__("./node_modules/echarts/lib/model/Series.js");

var createListFromArray = __webpack_require__("./node_modules/echarts/lib/chart/helper/createListFromArray.js");

var _default = SeriesModel.extend({
  type: 'series.__base_bar__',
  getInitialData: function (option, ecModel) {
    return createListFromArray(option.data, this, ecModel);
  },
  getMarkerPosition: function (value) {
    var coordSys = this.coordinateSystem;

    if (coordSys) {
      // PENDING if clamp ?
      var pt = coordSys.dataToPoint(value, true);
      var data = this.getData();
      var offset = data.getLayout('offset');
      var size = data.getLayout('size');
      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
      pt[offsetIndex] += offset + size / 2;
      return pt;
    }

    return [NaN, NaN];
  },
  defaultOption: {
    zlevel: 0,
    // 一级层叠
    z: 2,
    // 二级层叠
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    // stack: null
    // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // 最小高度改为0
    barMinHeight: 0,
    // 最小角度为0，仅对极坐标系下的柱状图有效
    barMinAngle: 0,
    // cursor: null,
    // barMaxWidth: null,
    // 默认自适应
    // barWidth: null,
    // 柱间距离，默认为柱形宽度的30%，可设固定值
    // barGap: '30%',
    // 类目间柱形距离，默认为类目间距的20%，可设固定值
    // barCategoryGap: '20%',
    // label: {
    //     normal: {
    //         show: false
    //     }
    // },
    itemStyle: {// normal: {
      // color: '各异'
      // },
      // emphasis: {}
    }
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/barItemStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__("./node_modules/echarts/lib/model/mixin/makeStyleMapper.js");

var getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2
['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
var _default = {
  getBarItemStyle: function (excludes) {
    var style = getBarItemStyle(this, excludes);

    if (this.getBorderLineDash) {
      var lineDash = this.getBorderLineDash();
      lineDash && (style.lineDash = lineDash);
    }

    return style;
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/helper.js":
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

function setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {
  var labelModel = itemModel.getModel('label.normal');
  var hoverLabelModel = itemModel.getModel('label.emphasis');
  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: seriesModel.getRawValue(dataIndex),
    isRectText: true,
    autoColor: color
  });
  fixPosition(normalStyle);
  fixPosition(hoverStyle);
}

function fixPosition(style, labelPositionOutside) {
  if (style.textPosition === 'outside') {
    style.textPosition = labelPositionOutside;
  }
}

exports.setLabel = setLabel;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/Line.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var symbolUtil = __webpack_require__("./node_modules/echarts/lib/util/symbol.js");

var LinePath = __webpack_require__("./node_modules/echarts/lib/chart/helper/LinePath.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var round = _number.round;

/**
 * @module echarts/chart/helper/Line
 */
var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];

function makeSymbolTypeKey(symbolCategory) {
  return '_' + symbolCategory + 'Type';
}
/**
 * @inner
 */


function createSymbol(name, lineData, idx) {
  var color = lineData.getItemVisual(idx, 'color');
  var symbolType = lineData.getItemVisual(idx, name);
  var symbolSize = lineData.getItemVisual(idx, name + 'Size');

  if (!symbolType || symbolType === 'none') {
    return;
  }

  if (!zrUtil.isArray(symbolSize)) {
    symbolSize = [symbolSize, symbolSize];
  }

  var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);
  symbolPath.name = name;
  return symbolPath;
}

function createLine(points) {
  var line = new LinePath({
    name: 'line'
  });
  setLinePoints(line.shape, points);
  return line;
}

function setLinePoints(targetShape, points) {
  var p1 = points[0];
  var p2 = points[1];
  var cp1 = points[2];
  targetShape.x1 = p1[0];
  targetShape.y1 = p1[1];
  targetShape.x2 = p2[0];
  targetShape.y2 = p2[1];
  targetShape.percent = 1;

  if (cp1) {
    targetShape.cpx1 = cp1[0];
    targetShape.cpy1 = cp1[1];
  } else {
    targetShape.cpx1 = NaN;
    targetShape.cpy1 = NaN;
  }
}

function updateSymbolAndLabelBeforeLineUpdate() {
  var lineGroup = this;
  var symbolFrom = lineGroup.childOfName('fromSymbol');
  var symbolTo = lineGroup.childOfName('toSymbol');
  var label = lineGroup.childOfName('label'); // Quick reject

  if (!symbolFrom && !symbolTo && label.ignore) {
    return;
  }

  var invScale = 1;
  var parentNode = this.parent;

  while (parentNode) {
    if (parentNode.scale) {
      invScale /= parentNode.scale[0];
    }

    parentNode = parentNode.parent;
  }

  var line = lineGroup.childOfName('line'); // If line not changed
  // FIXME Parent scale changed

  if (!this.__dirty && !line.__dirty) {
    return;
  }

  var percent = line.shape.percent;
  var fromPos = line.pointAt(0);
  var toPos = line.pointAt(percent);
  var d = vector.sub([], toPos, fromPos);
  vector.normalize(d, d);

  if (symbolFrom) {
    symbolFrom.attr('position', fromPos);
    var tangent = line.tangentAt(0);
    symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
    symbolFrom.attr('scale', [invScale * percent, invScale * percent]);
  }

  if (symbolTo) {
    symbolTo.attr('position', toPos);
    var tangent = line.tangentAt(1);
    symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
    symbolTo.attr('scale', [invScale * percent, invScale * percent]);
  }

  if (!label.ignore) {
    label.attr('position', toPos);
    var textPosition;
    var textAlign;
    var textVerticalAlign;
    var distance = 5 * invScale; // End

    if (label.__position === 'end') {
      textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];
      textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';
      textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';
    } // Middle
    else if (label.__position === 'middle') {
        var halfPercent = percent / 2;
        var tangent = line.tangentAt(halfPercent);
        var n = [tangent[1], -tangent[0]];
        var cp = line.pointAt(halfPercent);

        if (n[1] > 0) {
          n[0] = -n[0];
          n[1] = -n[1];
        }

        textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];
        textAlign = 'center';
        textVerticalAlign = 'bottom';
        var rotation = -Math.atan2(tangent[1], tangent[0]);

        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }

        label.attr('rotation', rotation);
      } // Start
      else {
          textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];
          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';
          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';
        }

    label.attr({
      style: {
        // Use the user specified text align and baseline first
        textVerticalAlign: label.__verticalAlign || textVerticalAlign,
        textAlign: label.__textAlign || textAlign
      },
      position: textPosition,
      scale: [invScale, invScale]
    });
  }
}
/**
 * @constructor
 * @extends {module:zrender/graphic/Group}
 * @alias {module:echarts/chart/helper/Line}
 */


function Line(lineData, idx, seriesScope) {
  graphic.Group.call(this);

  this._createLine(lineData, idx, seriesScope);
}

var lineProto = Line.prototype; // Update symbol position and rotation

lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;

lineProto._createLine = function (lineData, idx, seriesScope) {
  var seriesModel = lineData.hostModel;
  var linePoints = lineData.getItemLayout(idx);
  var line = createLine(linePoints);
  line.shape.percent = 0;
  graphic.initProps(line, {
    shape: {
      percent: 1
    }
  }, seriesModel, idx);
  this.add(line);
  var label = new graphic.Text({
    name: 'label'
  });
  this.add(label);
  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
    var symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure
    // it will be updated after line#update.
    // Or symbol position and rotation update in line#beforeUpdate will be one frame slow

    this.add(symbol);
    this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
  }, this);

  this._updateCommonStl(lineData, idx, seriesScope);
};

lineProto.updateData = function (lineData, idx, seriesScope) {
  var seriesModel = lineData.hostModel;
  var line = this.childOfName('line');
  var linePoints = lineData.getItemLayout(idx);
  var target = {
    shape: {}
  };
  setLinePoints(target.shape, linePoints);
  graphic.updateProps(line, target, seriesModel, idx);
  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
    var symbolType = lineData.getItemVisual(idx, symbolCategory);
    var key = makeSymbolTypeKey(symbolCategory); // Symbol changed

    if (this[key] !== symbolType) {
      this.remove(this.childOfName(symbolCategory));
      var symbol = createSymbol(symbolCategory, lineData, idx);
      this.add(symbol);
    }

    this[key] = symbolType;
  }, this);

  this._updateCommonStl(lineData, idx, seriesScope);
};

lineProto._updateCommonStl = function (lineData, idx, seriesScope) {
  var seriesModel = lineData.hostModel;
  var line = this.childOfName('line');
  var lineStyle = seriesScope && seriesScope.lineStyle;
  var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
  var labelModel = seriesScope && seriesScope.labelModel;
  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset

  if (!seriesScope || lineData.hasItemOption) {
    var itemModel = lineData.getItemModel(idx);
    lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();
    hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();
    labelModel = itemModel.getModel('label.normal');
    hoverLabelModel = itemModel.getModel('label.emphasis');
  }

  var visualColor = lineData.getItemVisual(idx, 'color');
  var visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1);
  line.useStyle(zrUtil.defaults({
    strokeNoScale: true,
    fill: 'none',
    stroke: visualColor,
    opacity: visualOpacity
  }, lineStyle));
  line.hoverStyle = hoverLineStyle; // Update symbol

  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
    var symbol = this.childOfName(symbolCategory);

    if (symbol) {
      symbol.setColor(visualColor);
      symbol.setStyle({
        opacity: visualOpacity
      });
    }
  }, this);
  var showLabel = labelModel.getShallow('show');
  var hoverShowLabel = hoverLabelModel.getShallow('show');
  var label = this.childOfName('label');
  var defaultLabelColor;
  var defaultText;
  var normalText;
  var emphasisText;

  if (showLabel || hoverShowLabel) {
    var rawVal = seriesModel.getRawValue(idx);
    defaultText = rawVal == null ? defaultText = lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;
    defaultLabelColor = visualColor || '#000';
    normalText = zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType), defaultText);
    emphasisText = zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), normalText);
  } // label.afterUpdate = lineAfterUpdate;


  if (showLabel) {
    var labelStyle = graphic.setTextStyle(label.style, labelModel, {
      text: normalText
    }, {
      autoColor: defaultLabelColor
    });
    label.__textAlign = labelStyle.textAlign;
    label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end'

    label.__position = labelModel.get('position') || 'middle';
  } else {
    label.setStyle('text', null);
  }

  if (hoverShowLabel) {
    // Only these properties supported in this emphasis style here.
    label.hoverStyle = {
      text: emphasisText,
      textFill: hoverLabelModel.getTextColor(true),
      // For merging hover style to normal style, do not use
      // `hoverLabelModel.getFont()` here.
      fontStyle: hoverLabelModel.getShallow('fontStyle'),
      fontWeight: hoverLabelModel.getShallow('fontWeight'),
      fontSize: hoverLabelModel.getShallow('fontSize'),
      fontFamily: hoverLabelModel.getShallow('fontFamily')
    };
  } else {
    label.hoverStyle = {
      text: null
    };
  }

  label.ignore = !showLabel && !hoverShowLabel;
  graphic.setHoverStyle(this);
};

lineProto.highlight = function () {
  this.trigger('emphasis');
};

lineProto.downplay = function () {
  this.trigger('normal');
};

lineProto.updateLayout = function (lineData, idx) {
  this.setLinePoints(lineData.getItemLayout(idx));
};

lineProto.setLinePoints = function (points) {
  var linePath = this.childOfName('line');
  setLinePoints(linePath.shape, points);
  linePath.dirty();
};

zrUtil.inherits(Line, graphic.Group);
var _default = Line;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/LineDraw.js":
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var LineGroup = __webpack_require__("./node_modules/echarts/lib/chart/helper/Line.js");

/**
 * @module echarts/chart/helper/LineDraw
 */
function isPointNaN(pt) {
  return isNaN(pt[0]) || isNaN(pt[1]);
}

function lineNeedsDraw(pts) {
  return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
}
/**
 * @alias module:echarts/component/marker/LineDraw
 * @constructor
 */


function LineDraw(ctor) {
  this._ctor = ctor || LineGroup;
  this.group = new graphic.Group();
}

var lineDrawProto = LineDraw.prototype;
/**
 * @param {module:echarts/data/List} lineData
 */

lineDrawProto.updateData = function (lineData) {
  var oldLineData = this._lineData;
  var group = this.group;
  var LineCtor = this._ctor;
  var hostModel = lineData.hostModel;
  var seriesScope = {
    lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),
    hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),
    labelModel: hostModel.getModel('label.normal'),
    hoverLabelModel: hostModel.getModel('label.emphasis')
  };
  lineData.diff(oldLineData).add(function (idx) {
    if (!lineNeedsDraw(lineData.getItemLayout(idx))) {
      return;
    }

    var lineGroup = new LineCtor(lineData, idx, seriesScope);
    lineData.setItemGraphicEl(idx, lineGroup);
    group.add(lineGroup);
  }).update(function (newIdx, oldIdx) {
    var lineGroup = oldLineData.getItemGraphicEl(oldIdx);

    if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {
      group.remove(lineGroup);
      return;
    }

    if (!lineGroup) {
      lineGroup = new LineCtor(lineData, newIdx, seriesScope);
    } else {
      lineGroup.updateData(lineData, newIdx, seriesScope);
    }

    lineData.setItemGraphicEl(newIdx, lineGroup);
    group.add(lineGroup);
  }).remove(function (idx) {
    group.remove(oldLineData.getItemGraphicEl(idx));
  }).execute();
  this._lineData = lineData;
};

lineDrawProto.updateLayout = function () {
  var lineData = this._lineData;
  lineData.eachItemGraphicEl(function (el, idx) {
    el.updateLayout(lineData, idx);
  }, this);
};

lineDrawProto.remove = function () {
  this.group.removeAll();
};

var _default = LineDraw;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/LinePath.js":
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

/**
 * Line path for bezier and straight line draw
 */
var straightLineProto = graphic.Line.prototype;
var bezierCurveProto = graphic.BezierCurve.prototype;

function isLine(shape) {
  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
}

var _default = graphic.extendShape({
  type: 'ec-line',
  style: {
    stroke: '#000',
    fill: null
  },
  shape: {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    percent: 1,
    cpx1: null,
    cpy1: null
  },
  buildPath: function (ctx, shape) {
    (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);
  },
  pointAt: function (t) {
    return isLine(this.shape) ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t);
  },
  tangentAt: function (t) {
    var shape = this.shape;
    var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
    return vec2.normalize(p, p);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/Symbol.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _symbol = __webpack_require__("./node_modules/echarts/lib/util/symbol.js");

var createSymbol = _symbol.createSymbol;

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var parsePercent = _number.parsePercent;

var _labelHelper = __webpack_require__("./node_modules/echarts/lib/chart/helper/labelHelper.js");

var findLabelValueDim = _labelHelper.findLabelValueDim;

/**
 * @module echarts/chart/helper/Symbol
 */
function getSymbolSize(data, idx) {
  var symbolSize = data.getItemVisual(idx, 'symbolSize');
  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
}

function getScale(symbolSize) {
  return [symbolSize[0] / 2, symbolSize[1] / 2];
}
/**
 * @constructor
 * @alias {module:echarts/chart/helper/Symbol}
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @extends {module:zrender/graphic/Group}
 */


function SymbolClz(data, idx, seriesScope) {
  graphic.Group.call(this);
  this.updateData(data, idx, seriesScope);
}

var symbolProto = SymbolClz.prototype;

function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}

symbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {
  // Remove paths created before
  this.removeAll();
  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(
  //     symbolType, -0.5, -0.5, 1, 1, color
  // );
  // If width/height are set too small (e.g., set to 1) on ios10
  // and macOS Sierra, a circle stroke become a rect, no matter what
  // the scale is set. So we set width/height as 2. See #4150.

  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);
  symbolPath.attr({
    z2: 100,
    culling: true,
    scale: getScale(symbolSize)
  }); // Rewrite drift method

  symbolPath.drift = driftSymbol;
  this._symbolType = symbolType;
  this.add(symbolPath);
};
/**
 * Stop animation
 * @param {boolean} toLastFrame
 */


symbolProto.stopSymbolAnimation = function (toLastFrame) {
  this.childAt(0).stopAnimation(toLastFrame);
};
/**
 * FIXME:
 * Caution: This method breaks the encapsulation of this module,
 * but it indeed brings convenience. So do not use the method
 * unless you detailedly know all the implements of `Symbol`,
 * especially animation.
 *
 * Get symbol path element.
 */


symbolProto.getSymbolPath = function () {
  return this.childAt(0);
};
/**
 * Get scale(aka, current symbol size).
 * Including the change caused by animation
 */


symbolProto.getScale = function () {
  return this.childAt(0).scale;
};
/**
 * Highlight symbol
 */


symbolProto.highlight = function () {
  this.childAt(0).trigger('emphasis');
};
/**
 * Downplay symbol
 */


symbolProto.downplay = function () {
  this.childAt(0).trigger('normal');
};
/**
 * @param {number} zlevel
 * @param {number} z
 */


symbolProto.setZ = function (zlevel, z) {
  var symbolPath = this.childAt(0);
  symbolPath.zlevel = zlevel;
  symbolPath.z = z;
};

symbolProto.setDraggable = function (draggable) {
  var symbolPath = this.childAt(0);
  symbolPath.draggable = draggable;
  symbolPath.cursor = draggable ? 'move' : 'pointer';
};
/**
 * Update symbol properties
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Object} [seriesScope]
 * @param {Object} [seriesScope.itemStyle]
 * @param {Object} [seriesScope.hoverItemStyle]
 * @param {Object} [seriesScope.symbolRotate]
 * @param {Object} [seriesScope.symbolOffset]
 * @param {module:echarts/model/Model} [seriesScope.labelModel]
 * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]
 * @param {boolean} [seriesScope.hoverAnimation]
 * @param {Object} [seriesScope.cursorStyle]
 * @param {module:echarts/model/Model} [seriesScope.itemModel]
 * @param {string} [seriesScope.symbolInnerColor]
 * @param {Object} [seriesScope.fadeIn=false]
 */


symbolProto.updateData = function (data, idx, seriesScope) {
  this.silent = false;
  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
  var seriesModel = data.hostModel;
  var symbolSize = getSymbolSize(data, idx);
  var isInit = symbolType !== this._symbolType;

  if (isInit) {
    this._createSymbol(symbolType, data, idx, symbolSize);
  } else {
    var symbolPath = this.childAt(0);
    symbolPath.silent = false;
    graphic.updateProps(symbolPath, {
      scale: getScale(symbolSize)
    }, seriesModel, idx);
  }

  this._updateCommon(data, idx, symbolSize, seriesScope);

  if (isInit) {
    var symbolPath = this.childAt(0);
    var fadeIn = seriesScope && seriesScope.fadeIn;
    var target = {
      scale: symbolPath.scale.slice()
    };
    fadeIn && (target.style = {
      opacity: symbolPath.style.opacity
    });
    symbolPath.scale = [0, 0];
    fadeIn && (symbolPath.style.opacity = 0);
    graphic.initProps(symbolPath, target, seriesModel, idx);
  }

  this._seriesModel = seriesModel;
}; // Update common properties


var normalStyleAccessPath = ['itemStyle', 'normal'];
var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];
var normalLabelAccessPath = ['label', 'normal'];
var emphasisLabelAccessPath = ['label', 'emphasis'];
/**
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Array.<number>} symbolSize
 * @param {Object} [seriesScope]
 */

symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {
  var symbolPath = this.childAt(0);
  var seriesModel = data.hostModel;
  var color = data.getItemVisual(idx, 'color'); // Reset style

  if (symbolPath.type !== 'image') {
    symbolPath.useStyle({
      strokeNoScale: true
    });
  }

  var itemStyle = seriesScope && seriesScope.itemStyle;
  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
  var symbolRotate = seriesScope && seriesScope.symbolRotate;
  var symbolOffset = seriesScope && seriesScope.symbolOffset;
  var labelModel = seriesScope && seriesScope.labelModel;
  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
  var cursorStyle = seriesScope && seriesScope.cursorStyle;

  if (!seriesScope || data.hasItemOption) {
    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.
    // Because symbol provide setColor individually to set fill and stroke

    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);
    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
    symbolRotate = itemModel.getShallow('symbolRotate');
    symbolOffset = itemModel.getShallow('symbolOffset');
    labelModel = itemModel.getModel(normalLabelAccessPath);
    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
    hoverAnimation = itemModel.getShallow('hoverAnimation');
    cursorStyle = itemModel.getShallow('cursor');
  } else {
    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);
  }

  var elStyle = symbolPath.style;
  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);

  if (symbolOffset) {
    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);
  }

  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!

  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);
  symbolPath.setStyle(itemStyle);
  var opacity = data.getItemVisual(idx, 'opacity');

  if (opacity != null) {
    elStyle.opacity = opacity;
  }

  var useNameLabel = seriesScope && seriesScope.useNameLabel;
  var valueDim = !useNameLabel && findLabelValueDim(data);

  if (useNameLabel || valueDim != null) {
    graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: useNameLabel ? data.getName(idx) : data.get(valueDim, idx),
      isRectText: true,
      autoColor: color
    });
  }

  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');
  symbolPath.hoverStyle = hoverItemStyle; // FIXME
  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.

  graphic.setHoverStyle(symbolPath);
  var scale = getScale(symbolSize);

  if (hoverAnimation && seriesModel.isAnimationEnabled()) {
    var onEmphasis = function () {
      var ratio = scale[1] / scale[0];
      this.animateTo({
        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]
      }, 400, 'elasticOut');
    };

    var onNormal = function () {
      this.animateTo({
        scale: scale
      }, 400, 'elasticOut');
    };

    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
  }
};
/**
 * @param {Function} cb
 * @param {Object} [opt]
 * @param {Object} [opt.keepLabel=true]
 */


symbolProto.fadeOut = function (cb, opt) {
  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out

  this.silent = symbolPath.silent = true; // Not show text when animating

  !(opt && opt.keepLabel) && (symbolPath.style.text = null);
  graphic.updateProps(symbolPath, {
    style: {
      opacity: 0
    },
    scale: [0, 0]
  }, this._seriesModel, this.dataIndex, cb);
};

zrUtil.inherits(SymbolClz, graphic.Group);
var _default = SymbolClz;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/SymbolDraw.js":
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var SymbolClz = __webpack_require__("./node_modules/echarts/lib/chart/helper/Symbol.js");

/**
 * @module echarts/chart/helper/SymbolDraw
 */

/**
 * @constructor
 * @alias module:echarts/chart/helper/SymbolDraw
 * @param {module:zrender/graphic/Group} [symbolCtor]
 */
function SymbolDraw(symbolCtor) {
  this.group = new graphic.Group();
  this._symbolCtor = symbolCtor || SymbolClz;
}

var symbolDrawProto = SymbolDraw.prototype;

function symbolNeedsDraw(data, idx, isIgnore) {
  var point = data.getItemLayout(idx); // Is an object
  // if (point && point.hasOwnProperty('point')) {
  //     point = point.point;
  // }

  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx)) && data.getItemVisual(idx, 'symbol') !== 'none';
}
/**
 * Update symbols draw by new data
 * @param {module:echarts/data/List} data
 * @param {Array.<boolean>} [isIgnore]
 */


symbolDrawProto.updateData = function (data, isIgnore) {
  var group = this.group;
  var seriesModel = data.hostModel;
  var oldData = this._data;
  var SymbolCtor = this._symbolCtor;
  var seriesScope = {
    itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),
    hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),
    symbolRotate: seriesModel.get('symbolRotate'),
    symbolOffset: seriesModel.get('symbolOffset'),
    hoverAnimation: seriesModel.get('hoverAnimation'),
    labelModel: seriesModel.getModel('label.normal'),
    hoverLabelModel: seriesModel.getModel('label.emphasis'),
    cursorStyle: seriesModel.get('cursor')
  };
  data.diff(oldData).add(function (newIdx) {
    var point = data.getItemLayout(newIdx);

    if (symbolNeedsDraw(data, newIdx, isIgnore)) {
      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
      symbolEl.attr('position', point);
      data.setItemGraphicEl(newIdx, symbolEl);
      group.add(symbolEl);
    }
  }).update(function (newIdx, oldIdx) {
    var symbolEl = oldData.getItemGraphicEl(oldIdx);
    var point = data.getItemLayout(newIdx);

    if (!symbolNeedsDraw(data, newIdx, isIgnore)) {
      group.remove(symbolEl);
      return;
    }

    if (!symbolEl) {
      symbolEl = new SymbolCtor(data, newIdx);
      symbolEl.attr('position', point);
    } else {
      symbolEl.updateData(data, newIdx, seriesScope);
      graphic.updateProps(symbolEl, {
        position: point
      }, seriesModel);
    } // Add back


    group.add(symbolEl);
    data.setItemGraphicEl(newIdx, symbolEl);
  }).remove(function (oldIdx) {
    var el = oldData.getItemGraphicEl(oldIdx);
    el && el.fadeOut(function () {
      group.remove(el);
    });
  }).execute();
  this._data = data;
};

symbolDrawProto.updateLayout = function () {
  var data = this._data;

  if (data) {
    // Not use animation
    data.eachItemGraphicEl(function (el, idx) {
      var point = data.getItemLayout(idx);
      el.attr('position', point);
    });
  }
};

symbolDrawProto.remove = function (enableAnimation) {
  var group = this.group;
  var data = this._data;

  if (data) {
    if (enableAnimation) {
      data.eachItemGraphicEl(function (el) {
        el.fadeOut(function () {
          group.remove(el);
        });
      });
    } else {
      group.removeAll();
    }
  }
};

var _default = SymbolDraw;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/createListFromArray.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var List = __webpack_require__("./node_modules/echarts/lib/data/List.js");

var completeDimensions = __webpack_require__("./node_modules/echarts/lib/data/helper/completeDimensions.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var getDataItemValue = _model.getDataItemValue;
var converDataValue = _model.converDataValue;
var isDataItemOption = _model.isDataItemOption;

var CoordinateSystem = __webpack_require__("./node_modules/echarts/lib/CoordinateSystem.js");

function firstDataNotNull(data) {
  var i = 0;

  while (i < data.length && data[i] == null) {
    i++;
  }

  return data[i];
}

function ifNeedCompleteOrdinalData(data) {
  var sampleItem = firstDataNotNull(data);
  return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));
}
/**
 * Helper function to create a list from option data
 */


function createListFromArray(data, seriesModel, ecModel) {
  // If data is undefined
  data = data || [];
  var coordSysName = seriesModel.get('coordinateSystem');
  var creator = creators[coordSysName];
  var registeredCoordSys = CoordinateSystem.get(coordSysName);
  var completeDimOpt = {
    encodeDef: seriesModel.get('encode'),
    dimsDef: seriesModel.get('dimensions')
  }; // FIXME

  var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);
  var dimensions = axesInfo && axesInfo.dimensions;

  if (!dimensions) {
    // Get dimensions from registered coordinate system
    dimensions = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];
    dimensions = completeDimensions(dimensions, data, completeDimOpt);
  }

  var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;
  var list = new List(dimensions, seriesModel);
  var nameList = createNameList(axesInfo, data);
  var categories = {};
  var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {
    // If any dataItem is like { value: 10 }
    if (isDataItemOption(itemOpt)) {
      list.hasItemOption = true;
    } // Use dataIndex as ordinal value in categoryAxis


    return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);
  } : function (itemOpt, dimName, dataIndex, dimIndex) {
    var value = getDataItemValue(itemOpt);
    var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]); // If any dataItem is like { value: 10 }

    if (isDataItemOption(itemOpt)) {
      list.hasItemOption = true;
    }

    var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;

    if (categoryAxesModels && categoryAxesModels[dimName]) {
      // If given value is a category string
      if (typeof val === 'string') {
        // Lazy get categories
        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();
        val = zrUtil.indexOf(categories[dimName], val);

        if (val < 0 && !isNaN(val)) {
          // In case some one write '1', '2' istead of 1, 2
          val = +val;
        }
      }
    }

    return val;
  };
  list.hasItemOption = false;
  list.initData(data, nameList, dimValueGetter);
  return list;
}

function isStackable(axisType) {
  return axisType !== 'category' && axisType !== 'time';
}

function getDimTypeByAxis(axisType) {
  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';
}
/**
 * Creaters for each coord system.
 */


var creators = {
  cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {
    var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {
      return ecModel.queryComponents({
        mainType: name,
        index: seriesModel.get(name + 'Index'),
        id: seriesModel.get(name + 'Id')
      })[0];
    });
    var xAxisModel = axesModels[0];
    var yAxisModel = axesModels[1];
    var xAxisType = xAxisModel.get('type');
    var yAxisType = yAxisModel.get('type');
    var dimensions = [{
      name: 'x',
      type: getDimTypeByAxis(xAxisType),
      stackable: isStackable(xAxisType)
    }, {
      name: 'y',
      // If two category axes
      type: getDimTypeByAxis(yAxisType),
      stackable: isStackable(yAxisType)
    }];
    var isXAxisCateogry = xAxisType === 'category';
    var isYAxisCategory = yAxisType === 'category';
    dimensions = completeDimensions(dimensions, data, completeDimOpt);
    var categoryAxesModels = {};

    if (isXAxisCateogry) {
      categoryAxesModels.x = xAxisModel;
    }

    if (isYAxisCategory) {
      categoryAxesModels.y = yAxisModel;
    }

    return {
      dimensions: dimensions,
      categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,
      categoryAxesModels: categoryAxesModels
    };
  },
  singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {
    var singleAxisModel = ecModel.queryComponents({
      mainType: 'singleAxis',
      index: seriesModel.get('singleAxisIndex'),
      id: seriesModel.get('singleAxisId')
    })[0];
    var singleAxisType = singleAxisModel.get('type');
    var isCategory = singleAxisType === 'category';
    var dimensions = [{
      name: 'single',
      type: getDimTypeByAxis(singleAxisType),
      stackable: isStackable(singleAxisType)
    }];
    dimensions = completeDimensions(dimensions, data, completeDimOpt);
    var categoryAxesModels = {};

    if (isCategory) {
      categoryAxesModels.single = singleAxisModel;
    }

    return {
      dimensions: dimensions,
      categoryIndex: isCategory ? 0 : -1,
      categoryAxesModels: categoryAxesModels
    };
  },
  polar: function (data, seriesModel, ecModel, completeDimOpt) {
    var polarModel = ecModel.queryComponents({
      mainType: 'polar',
      index: seriesModel.get('polarIndex'),
      id: seriesModel.get('polarId')
    })[0];
    var angleAxisModel = polarModel.findAxisModel('angleAxis');
    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
    var radiusAxisType = radiusAxisModel.get('type');
    var angleAxisType = angleAxisModel.get('type');
    var dimensions = [{
      name: 'radius',
      type: getDimTypeByAxis(radiusAxisType),
      stackable: isStackable(radiusAxisType)
    }, {
      name: 'angle',
      type: getDimTypeByAxis(angleAxisType),
      stackable: isStackable(angleAxisType)
    }];
    var isAngleAxisCateogry = angleAxisType === 'category';
    var isRadiusAxisCateogry = radiusAxisType === 'category';
    dimensions = completeDimensions(dimensions, data, completeDimOpt);
    var categoryAxesModels = {};

    if (isRadiusAxisCateogry) {
      categoryAxesModels.radius = radiusAxisModel;
    }

    if (isAngleAxisCateogry) {
      categoryAxesModels.angle = angleAxisModel;
    }

    return {
      dimensions: dimensions,
      categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,
      categoryAxesModels: categoryAxesModels
    };
  },
  geo: function (data, seriesModel, ecModel, completeDimOpt) {
    // TODO Region
    // 多个散点图系列在同一个地区的时候
    return {
      dimensions: completeDimensions([{
        name: 'lng'
      }, {
        name: 'lat'
      }], data, completeDimOpt)
    };
  }
};

function createNameList(result, data) {
  var nameList = [];
  var categoryDim = result && result.dimensions[result.categoryIndex];
  var categoryAxisModel;

  if (categoryDim) {
    categoryAxisModel = result.categoryAxesModels[categoryDim.name];
  }

  if (categoryAxisModel) {
    // FIXME Two category axis
    var categories = categoryAxisModel.getCategories();

    if (categories) {
      var dataLen = data.length; // Ordered data is given explicitly like
      // [[3, 0.2], [1, 0.3], [2, 0.15]]
      // or given scatter data,
      // pick the category

      if (zrUtil.isArray(data[0]) && data[0].length > 1) {
        nameList = [];

        for (var i = 0; i < dataLen; i++) {
          nameList[i] = categories[data[i][result.categoryIndex || 0]];
        }
      } else {
        nameList = categories.slice(0);
      }
    }
  }

  return nameList;
}

var _default = createListFromArray;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/labelHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var otherDimToDataDim = _model.otherDimToDataDim;

/**
 * @module echarts/chart/helper/Symbol
 */
function findLabelValueDim(data) {
  var valueDim;
  var labelDims = otherDimToDataDim(data, 'label');

  if (labelDims.length) {
    valueDim = labelDims[0];
  } else {
    // Get last value dim
    var dimensions = data.dimensions.slice();
    var dataType;

    while (dimensions.length && (valueDim = dimensions.pop(), dataType = data.getDimensionInfo(valueDim).type, dataType === 'ordinal' || dataType === 'time')) {} // jshint ignore:line

  }

  return valueDim;
}

exports.findLabelValueDim = findLabelValueDim;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

__webpack_require__("./node_modules/echarts/lib/chart/line/LineSeries.js");

__webpack_require__("./node_modules/echarts/lib/chart/line/LineView.js");

var visualSymbol = __webpack_require__("./node_modules/echarts/lib/visual/symbol.js");

var layoutPoints = __webpack_require__("./node_modules/echarts/lib/layout/points.js");

var dataSample = __webpack_require__("./node_modules/echarts/lib/processor/dataSample.js");

__webpack_require__("./node_modules/echarts/lib/component/gridSimple.js");

// In case developer forget to include grid component
echarts.registerVisual(zrUtil.curry(visualSymbol, 'line', 'circle', 'line'));
echarts.registerLayout(zrUtil.curry(layoutPoints, 'line')); // Down sample after filter

echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(dataSample, 'line'));

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/LineSeries.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var createListFromArray = __webpack_require__("./node_modules/echarts/lib/chart/helper/createListFromArray.js");

var SeriesModel = __webpack_require__("./node_modules/echarts/lib/model/Series.js");

var _default = SeriesModel.extend({
  type: 'series.line',
  dependencies: ['grid', 'polar'],
  getInitialData: function (option, ecModel) {
    return createListFromArray(option.data, this, ecModel);
  },
  defaultOption: {
    zlevel: 0,
    // 一级层叠
    z: 2,
    // 二级层叠
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    hoverAnimation: true,
    // stack: null
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // polarIndex: 0,
    // If clip the overflow value
    clipOverflow: true,
    // cursor: null,
    label: {
      normal: {
        position: 'top'
      }
    },
    // itemStyle: {
    //     normal: {},
    //     emphasis: {}
    // },
    lineStyle: {
      normal: {
        width: 2,
        type: 'solid'
      }
    },
    // areaStyle: {},
    // false, 'start', 'end', 'middle'
    step: false,
    // Disabled if step is true
    smooth: false,
    smoothMonotone: null,
    // 拐点图形类型
    symbol: 'emptyCircle',
    // 拐点图形大小
    symbolSize: 4,
    // 拐点图形旋转控制
    symbolRotate: null,
    // 是否显示 symbol, 只有在 tooltip hover 的时候显示
    showSymbol: true,
    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）
    showAllSymbol: false,
    // 是否连接断点
    connectNulls: false,
    // 数据过滤，'average', 'max', 'min', 'sum'
    sampling: 'none',
    animationEasing: 'linear',
    // Disable progressive
    progressive: 0,
    hoverLayerThreshold: Infinity
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/LineView.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var SymbolDraw = __webpack_require__("./node_modules/echarts/lib/chart/helper/SymbolDraw.js");

var SymbolClz = __webpack_require__("./node_modules/echarts/lib/chart/helper/Symbol.js");

var lineAnimationDiff = __webpack_require__("./node_modules/echarts/lib/chart/line/lineAnimationDiff.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var _poly = __webpack_require__("./node_modules/echarts/lib/chart/line/poly.js");

var Polyline = _poly.Polyline;
var Polygon = _poly.Polygon;

var ChartView = __webpack_require__("./node_modules/echarts/lib/view/Chart.js");

// FIXME step not support polar
function isPointsSame(points1, points2) {
  if (points1.length !== points2.length) {
    return;
  }

  for (var i = 0; i < points1.length; i++) {
    var p1 = points1[i];
    var p2 = points2[i];

    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
      return;
    }
  }

  return true;
}

function getSmooth(smooth) {
  return typeof smooth === 'number' ? smooth : smooth ? 0.3 : 0;
}

function getAxisExtentWithGap(axis) {
  var extent = axis.getGlobalExtent();

  if (axis.onBand) {
    // Remove extra 1px to avoid line miter in clipped edge
    var halfBandWidth = axis.getBandWidth() / 2 - 1;
    var dir = extent[1] > extent[0] ? 1 : -1;
    extent[0] += dir * halfBandWidth;
    extent[1] -= dir * halfBandWidth;
  }

  return extent;
}

function sign(val) {
  return val >= 0 ? 1 : -1;
}
/**
 * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys
 * @param {module:echarts/data/List} data
 * @param {Array.<Array.<number>>} points
 * @private
 */


function getStackedOnPoints(coordSys, data) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis = coordSys.getOtherAxis(baseAxis);
  var valueStart = 0;

  if (!baseAxis.onZero) {
    var extent = valueAxis.scale.getExtent();

    if (extent[0] > 0) {
      // Both positive
      valueStart = extent[0];
    } else if (extent[1] < 0) {
      // Both negative
      valueStart = extent[1];
    } // If is one positive, and one negative, onZero shall be true

  }

  var valueDim = valueAxis.dim;
  var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;
  return data.mapArray([valueDim], function (val, idx) {
    var stackedOnSameSign;
    var stackedOn = data.stackedOn; // Find first stacked value with same sign

    while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {
      stackedOnSameSign = stackedOn;
      break;
    }

    var stackedData = [];
    stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
    stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;
    return coordSys.dataToPoint(stackedData);
  }, true);
}

function createGridClipShape(cartesian, hasAnimation, seriesModel) {
  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));
  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));
  var isHorizontal = cartesian.getBaseAxis().isHorizontal();
  var x = Math.min(xExtent[0], xExtent[1]);
  var y = Math.min(yExtent[0], yExtent[1]);
  var width = Math.max(xExtent[0], xExtent[1]) - x;
  var height = Math.max(yExtent[0], yExtent[1]) - y;
  var lineWidth = seriesModel.get('lineStyle.normal.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis

  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);

  if (isHorizontal) {
    y -= expandSize;
    height += expandSize * 2;
  } else {
    x -= expandSize;
    width += expandSize * 2;
  }

  var clipPath = new graphic.Rect({
    shape: {
      x: x,
      y: y,
      width: width,
      height: height
    }
  });

  if (hasAnimation) {
    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;
    graphic.initProps(clipPath, {
      shape: {
        width: width,
        height: height
      }
    }, seriesModel);
  }

  return clipPath;
}

function createPolarClipShape(polar, hasAnimation, seriesModel) {
  var angleAxis = polar.getAngleAxis();
  var radiusAxis = polar.getRadiusAxis();
  var radiusExtent = radiusAxis.getExtent();
  var angleExtent = angleAxis.getExtent();
  var RADIAN = Math.PI / 180;
  var clipPath = new graphic.Sector({
    shape: {
      cx: polar.cx,
      cy: polar.cy,
      r0: radiusExtent[0],
      r: radiusExtent[1],
      startAngle: -angleExtent[0] * RADIAN,
      endAngle: -angleExtent[1] * RADIAN,
      clockwise: angleAxis.inverse
    }
  });

  if (hasAnimation) {
    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;
    graphic.initProps(clipPath, {
      shape: {
        endAngle: -angleExtent[1] * RADIAN
      }
    }, seriesModel);
  }

  return clipPath;
}

function createClipShape(coordSys, hasAnimation, seriesModel) {
  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);
}

function turnPointsIntoStep(points, coordSys, stepTurnAt) {
  var baseAxis = coordSys.getBaseAxis();
  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
  var stepPoints = [];

  for (var i = 0; i < points.length - 1; i++) {
    var nextPt = points[i + 1];
    var pt = points[i];
    stepPoints.push(pt);
    var stepPt = [];

    switch (stepTurnAt) {
      case 'end':
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start

        stepPoints.push(stepPt);
        break;

      case 'middle':
        // default is start
        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        var stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt);
        stepPoints.push(stepPt2);
        break;

      default:
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start

        stepPoints.push(stepPt);
    }
  } // Last points


  points[i] && stepPoints.push(points[i]);
  return stepPoints;
}

function getVisualGradient(data, coordSys) {
  var visualMetaList = data.getVisual('visualMeta');

  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    // When data.count() is 0, gradient range can not be calculated.
    return;
  }

  var visualMeta;

  for (var i = visualMetaList.length - 1; i >= 0; i--) {
    // Can only be x or y
    if (visualMetaList[i].dimension < 2) {
      visualMeta = visualMetaList[i];
      break;
    }
  }

  if (!visualMeta || coordSys.type !== 'cartesian2d') {
    return;
  } // If the area to be rendered is bigger than area defined by LinearGradient,
  // the canvas spec prescribes that the color of the first stop and the last
  // stop should be used. But if two stops are added at offset 0, in effect
  // browsers use the color of the second stop to render area outside
  // LinearGradient. So we can only infinitesimally extend area defined in
  // LinearGradient to render `outerColors`.


  var dimension = visualMeta.dimension;
  var dimName = data.dimensions[dimension];
  var axis = coordSys.getAxis(dimName); // dataToCoor mapping may not be linear, but must be monotonic.

  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
      color: stop.color
    };
  });
  var stopLen = colorStops.length;
  var outerColors = visualMeta.outerColors.slice();

  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }

  var tinyExtent = 10; // Arbitrary value: 10px

  var minCoord = colorStops[0].coord - tinyExtent;
  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
  var coordSpan = maxCoord - minCoord;

  if (coordSpan < 1e-3) {
    return 'transparent';
  }

  zrUtil.each(colorStops, function (stop) {
    stop.offset = (stop.coord - minCoord) / coordSpan;
  });
  colorStops.push({
    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
    color: outerColors[1] || 'transparent'
  });
  colorStops.unshift({
    // notice colorStops.length have been changed.
    offset: stopLen ? colorStops[0].offset : 0.5,
    color: outerColors[0] || 'transparent'
  }); // zrUtil.each(colorStops, function (colorStop) {
  //     // Make sure each offset has rounded px to avoid not sharp edge
  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);
  // });

  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
  gradient[dimName] = minCoord;
  gradient[dimName + '2'] = maxCoord;
  return gradient;
}

var _default = ChartView.extend({
  type: 'line',
  init: function () {
    var lineGroup = new graphic.Group();
    var symbolDraw = new SymbolDraw();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
  },
  render: function (seriesModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var lineStyleModel = seriesModel.getModel('lineStyle.normal');
    var areaStyleModel = seriesModel.getModel('areaStyle.normal');
    var points = data.mapArray(data.getItemLayout, true);
    var isCoordSysPolar = coordSys.type === 'polar';
    var prevCoordSys = this._coordSys;
    var symbolDraw = this._symbolDraw;
    var polyline = this._polyline;
    var polygon = this._polygon;
    var lineGroup = this._lineGroup;
    var hasAnimation = seriesModel.get('animation');
    var isAreaChart = !areaStyleModel.isEmpty();
    var stackedOnPoints = getStackedOnPoints(coordSys, data);
    var showSymbol = seriesModel.get('showSymbol');

    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols


    var oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function (el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    }); // Remove previous created symbols if showSymbol changed to false

    if (!showSymbol) {
      symbolDraw.remove();
    }

    group.add(lineGroup); // FIXME step not support polar

    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed

    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, isSymbolIgnore);

      if (step) {
        // TODO If stacked series is not step
        points = turnPointsIntoStep(points, coordSys, step);
        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
      }

      polyline = this._newPolyline(points, coordSys, hasAnimation);

      if (isAreaChart) {
        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
      }

      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        // If areaStyle is added
        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
      } else if (polygon && !isAreaChart) {
        // If areaStyle is removed
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      } // Update clipPath


      lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel)); // Always update, or it is wrong in the case turning on legend
      // because points are not changed

      showSymbol && symbolDraw.updateData(data, isSymbolIgnore); // Stop symbol animation and sync with line points
      // FIXME performance?

      data.eachItemGraphicEl(function (el) {
        el.stopAnimation(true);
      }); // In the case data zoom triggerred refreshing frequently
      // Data may not change if line has a category axis. So it should animate nothing

      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
        if (hasAnimation) {
          this._updateAnimation(data, stackedOnPoints, coordSys, api, step);
        } else {
          // Not do it in update with animation
          if (step) {
            // TODO If stacked series is not step
            points = turnPointsIntoStep(points, coordSys, step);
            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
          }

          polyline.setShape({
            points: points
          });
          polygon && polygon.setShape({
            points: points,
            stackedOnPoints: stackedOnPoints
          });
        }
      }
    }

    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');
    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first
    lineStyleModel.getLineStyle(), {
      fill: 'none',
      stroke: visualColor,
      lineJoin: 'bevel'
    }));
    var smooth = seriesModel.get('smooth');
    smooth = getSmooth(seriesModel.get('smooth'));
    polyline.setShape({
      smooth: smooth,
      smoothMonotone: seriesModel.get('smoothMonotone'),
      connectNulls: seriesModel.get('connectNulls')
    });

    if (polygon) {
      var stackedOn = data.stackedOn;
      var stackedOnSmooth = 0;
      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: 'bevel'
      }));

      if (stackedOn) {
        var stackedOnSeries = stackedOn.hostModel;
        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
      }

      polygon.setShape({
        smooth: smooth,
        stackedOnSmooth: stackedOnSmooth,
        smoothMonotone: seriesModel.get('smoothMonotone'),
        connectNulls: seriesModel.get('connectNulls')
      });
    }

    this._data = data; // Save the coordinate system for transition animation when data changed

    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points;
    this._step = step;
  },
  dispose: function () {},
  highlight: function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = modelUtil.queryDataIndex(data, payload);

    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);

      if (!symbol) {
        // Create a temporary symbol if it is not exists
        var pt = data.getItemLayout(dataIndex);

        if (!pt) {
          // Null data
          return;
        }

        symbol = new SymbolClz(data, dataIndex);
        symbol.position = pt;
        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation

        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }

      symbol.highlight();
    } else {
      // Highlight whole series
      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
    }
  },
  downplay: function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = modelUtil.queryDataIndex(data, payload);

    if (dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);

      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      // FIXME
      // can not downplay completely.
      // Downplay whole series
      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
    }
  },

  /**
   * @param {module:zrender/container/Group} group
   * @param {Array.<Array.<number>>} points
   * @private
   */
  _newPolyline: function (points) {
    var polyline = this._polyline; // Remove previous created polyline

    if (polyline) {
      this._lineGroup.remove(polyline);
    }

    polyline = new Polyline({
      shape: {
        points: points
      },
      silent: true,
      z2: 10
    });

    this._lineGroup.add(polyline);

    this._polyline = polyline;
    return polyline;
  },

  /**
   * @param {module:zrender/container/Group} group
   * @param {Array.<Array.<number>>} stackedOnPoints
   * @param {Array.<Array.<number>>} points
   * @private
   */
  _newPolygon: function (points, stackedOnPoints) {
    var polygon = this._polygon; // Remove previous created polygon

    if (polygon) {
      this._lineGroup.remove(polygon);
    }

    polygon = new Polygon({
      shape: {
        points: points,
        stackedOnPoints: stackedOnPoints
      },
      silent: true
    });

    this._lineGroup.add(polygon);

    this._polygon = polygon;
    return polygon;
  },

  /**
   * @private
   */
  _getSymbolIgnoreFunc: function (data, coordSys) {
    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis

    if (categoryAxis && categoryAxis.isLabelIgnored) {
      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);
    }
  },

  /**
   * @private
   */
  // FIXME Two value axis
  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {
    var polyline = this._polyline;
    var polygon = this._polygon;
    var seriesModel = data.hostModel;
    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys);
    var current = diff.current;
    var stackedOnCurrent = diff.stackedOnCurrent;
    var next = diff.next;
    var stackedOnNext = diff.stackedOnNext;

    if (step) {
      // TODO If stacked series is not step
      current = turnPointsIntoStep(diff.current, coordSys, step);
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
      next = turnPointsIntoStep(diff.next, coordSys, step);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
    } // `diff.current` is subset of `current` (which should be ensured by
    // turnPointsIntoStep), so points in `__points` can be updated when
    // points in `current` are update during animation.


    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    graphic.updateProps(polyline, {
      shape: {
        points: next
      }
    }, seriesModel);

    if (polygon) {
      polygon.setShape({
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      graphic.updateProps(polygon, {
        shape: {
          points: next,
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel);
    }

    var updatedDataInfo = [];
    var diffStatus = diff.status;

    for (var i = 0; i < diffStatus.length; i++) {
      var cmd = diffStatus[i].cmd;

      if (cmd === '=') {
        var el = data.getItemGraphicEl(diffStatus[i].idx1);

        if (el) {
          updatedDataInfo.push({
            el: el,
            ptIdx: i // Index of points

          });
        }
      }
    }

    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function () {
        for (var i = 0; i < updatedDataInfo.length; i++) {
          var el = updatedDataInfo[i].el;
          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);
        }
      });
    }
  },
  remove: function (ecModel) {
    var group = this.group;
    var oldData = this._data;

    this._lineGroup.removeAll();

    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting


    oldData && oldData.eachItemGraphicEl(function (el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/lineAnimationDiff.js":
/***/ (function(module, exports) {

// var arrayDiff = require('zrender/src/core/arrayDiff');
// 'zrender/src/core/arrayDiff' has been used before, but it did
// not do well in performance when roam with fixed dataZoom window.
function sign(val) {
  return val >= 0 ? 1 : -1;
}

function getStackedOnPoint(coordSys, data, idx) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis = coordSys.getOtherAxis(baseAxis);
  var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];
  var valueDim = valueAxis.dim;
  var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;
  var stackedOnSameSign;
  var stackedOn = data.stackedOn;
  var val = data.get(valueDim, idx); // Find first stacked value with same sign

  while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {
    stackedOnSameSign = stackedOn;
    break;
  }

  var stackedData = [];
  stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
  stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;
  return coordSys.dataToPoint(stackedData);
} // function convertToIntId(newIdList, oldIdList) {
//     // Generate int id instead of string id.
//     // Compare string maybe slow in score function of arrDiff
//     // Assume id in idList are all unique
//     var idIndicesMap = {};
//     var idx = 0;
//     for (var i = 0; i < newIdList.length; i++) {
//         idIndicesMap[newIdList[i]] = idx;
//         newIdList[i] = idx++;
//     }
//     for (var i = 0; i < oldIdList.length; i++) {
//         var oldId = oldIdList[i];
//         // Same with newIdList
//         if (idIndicesMap[oldId]) {
//             oldIdList[i] = idIndicesMap[oldId];
//         }
//         else {
//             oldIdList[i] = idx++;
//         }
//     }
// }


function diffData(oldData, newData) {
  var diffResult = [];
  newData.diff(oldData).add(function (idx) {
    diffResult.push({
      cmd: '+',
      idx: idx
    });
  }).update(function (newIdx, oldIdx) {
    diffResult.push({
      cmd: '=',
      idx: oldIdx,
      idx1: newIdx
    });
  }).remove(function (idx) {
    diffResult.push({
      cmd: '-',
      idx: idx
    });
  }).execute();
  return diffResult;
}

function _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys) {
  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);
  // var oldIdList = oldData.mapArray(oldData.getId);
  // convertToIntId(newIdList, oldIdList);
  // // FIXME One data ?
  // diff = arrayDiff(oldIdList, newIdList);

  var currPoints = [];
  var nextPoints = []; // Points for stacking base line

  var currStackedPoints = [];
  var nextStackedPoints = [];
  var status = [];
  var sortedIndices = [];
  var rawIndices = [];
  var dims = newCoordSys.dimensions;

  for (var i = 0; i < diff.length; i++) {
    var diffItem = diff[i];
    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast
    // Which is in case remvoing or add more than one data in the tail or head

    switch (diffItem.cmd) {
      case '=':
        var currentPt = oldData.getItemLayout(diffItem.idx);
        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly

        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
          currentPt = nextPt.slice();
        }

        currPoints.push(currentPt);
        nextPoints.push(nextPt);
        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;

      case '+':
        var idx = diffItem.idx;
        currPoints.push(oldCoordSys.dataToPoint([newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)]));
        nextPoints.push(newData.getItemLayout(idx).slice());
        currStackedPoints.push(getStackedOnPoint(oldCoordSys, newData, idx));
        nextStackedPoints.push(newStackedOnPoints[idx]);
        rawIndices.push(newData.getRawIndex(idx));
        break;

      case '-':
        var idx = diffItem.idx;
        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue
        // FIXME FIXME FIXME

        if (rawIndex !== idx) {
          currPoints.push(oldData.getItemLayout(idx));
          nextPoints.push(newCoordSys.dataToPoint([oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)]));
          currStackedPoints.push(oldStackedOnPoints[idx]);
          nextStackedPoints.push(getStackedOnPoint(newCoordSys, oldData, idx));
          rawIndices.push(rawIndex);
        } else {
          pointAdded = false;
        }

    } // Original indices


    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  } // Diff result may be crossed if all items are changed
  // Sort by data index


  sortedIndices.sort(function (a, b) {
    return rawIndices[a] - rawIndices[b];
  });
  var sortedCurrPoints = [];
  var sortedNextPoints = [];
  var sortedCurrStackedPoints = [];
  var sortedNextStackedPoints = [];
  var sortedStatus = [];

  for (var i = 0; i < sortedIndices.length; i++) {
    var idx = sortedIndices[i];
    sortedCurrPoints[i] = currPoints[idx];
    sortedNextPoints[i] = nextPoints[idx];
    sortedCurrStackedPoints[i] = currStackedPoints[idx];
    sortedNextStackedPoints[i] = nextStackedPoints[idx];
    sortedStatus[i] = status[idx];
  }

  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/poly.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var fixClipWithShadow = __webpack_require__("./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js");

// Poly path support NaN point
var vec2Min = vec2.min;
var vec2Max = vec2.max;
var scaleAndAdd = vec2.scaleAndAdd;
var v2Copy = vec2.copy; // Temporary variable

var v = [];
var cp0 = [];
var cp1 = [];

function isPointNull(p) {
  return isNaN(p[0]) || isNaN(p[1]);
}

function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
  var prevIdx = 0;
  var idx = start;

  for (var k = 0; k < segLen; k++) {
    var p = points[idx];

    if (idx >= allLen || idx < 0) {
      break;
    }

    if (isPointNull(p)) {
      if (connectNulls) {
        idx += dir;
        continue;
      }

      break;
    }

    if (idx === start) {
      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
      v2Copy(cp0, p);
    } else {
      if (smooth > 0) {
        var nextIdx = idx + dir;
        var nextP = points[nextIdx];

        if (connectNulls) {
          // Find next point not null
          while (nextP && isPointNull(points[nextIdx])) {
            nextIdx += dir;
            nextP = points[nextIdx];
          }
        }

        var ratioNextSeg = 0.5;
        var prevP = points[prevIdx];
        var nextP = points[nextIdx]; // Last point

        if (!nextP || isPointNull(nextP)) {
          v2Copy(cp1, p);
        } else {
          // If next data is null in not connect case
          if (isPointNull(nextP) && !connectNulls) {
            nextP = p;
          }

          vec2.sub(v, nextP, prevP);
          var lenPrevSeg;
          var lenNextSeg;

          if (smoothMonotone === 'x' || smoothMonotone === 'y') {
            var dim = smoothMonotone === 'x' ? 0 : 1;
            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
            lenNextSeg = Math.abs(p[dim] - nextP[dim]);
          } else {
            lenPrevSeg = vec2.dist(p, prevP);
            lenNextSeg = vec2.dist(p, nextP);
          } // Use ratio of seg length


          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));
        } // Smooth constraint


        vec2Min(cp0, cp0, smoothMax);
        vec2Max(cp0, cp0, smoothMin);
        vec2Min(cp1, cp1, smoothMax);
        vec2Max(cp1, cp1, smoothMin);
        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment

        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);
      } else {
        ctx.lineTo(p[0], p[1]);
      }
    }

    prevIdx = idx;
    idx += dir;
  }

  return k;
}

function getBoundingBox(points, smoothConstraint) {
  var ptMin = [Infinity, Infinity];
  var ptMax = [-Infinity, -Infinity];

  if (smoothConstraint) {
    for (var i = 0; i < points.length; i++) {
      var pt = points[i];

      if (pt[0] < ptMin[0]) {
        ptMin[0] = pt[0];
      }

      if (pt[1] < ptMin[1]) {
        ptMin[1] = pt[1];
      }

      if (pt[0] > ptMax[0]) {
        ptMax[0] = pt[0];
      }

      if (pt[1] > ptMax[1]) {
        ptMax[1] = pt[1];
      }
    }
  }

  return {
    min: smoothConstraint ? ptMin : ptMax,
    max: smoothConstraint ? ptMax : ptMin
  };
}

var Polyline = Path.extend({
  type: 'ec-polyline',
  shape: {
    points: [],
    smooth: 0,
    smoothConstraint: true,
    smoothMonotone: null,
    connectNulls: false
  },
  style: {
    fill: null,
    stroke: '#000'
  },
  brush: fixClipWithShadow(Path.prototype.brush),
  buildPath: function (ctx, shape) {
    var points = shape.points;
    var i = 0;
    var len = points.length;
    var result = getBoundingBox(points, shape.smoothConstraint);

    if (shape.connectNulls) {
      // Must remove first and last null values avoid draw error in polygon
      for (; len > 0; len--) {
        if (!isPointNull(points[len - 1])) {
          break;
        }
      }

      for (; i < len; i++) {
        if (!isPointNull(points[i])) {
          break;
        }
      }
    }

    while (i < len) {
      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  }
});
var Polygon = Path.extend({
  type: 'ec-polygon',
  shape: {
    points: [],
    // Offset between stacked base points and points
    stackedOnPoints: [],
    smooth: 0,
    stackedOnSmooth: 0,
    smoothConstraint: true,
    smoothMonotone: null,
    connectNulls: false
  },
  brush: fixClipWithShadow(Path.prototype.brush),
  buildPath: function (ctx, shape) {
    var points = shape.points;
    var stackedOnPoints = shape.stackedOnPoints;
    var i = 0;
    var len = points.length;
    var smoothMonotone = shape.smoothMonotone;
    var bbox = getBoundingBox(points, shape.smoothConstraint);
    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);

    if (shape.connectNulls) {
      // Must remove first and last null values avoid draw error in polygon
      for (; len > 0; len--) {
        if (!isPointNull(points[len - 1])) {
          break;
        }
      }

      for (; i < len; i++) {
        if (!isPointNull(points[i])) {
          break;
        }
      }
    }

    while (i < len) {
      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i += k + 1;
      ctx.closePath();
    }
  }
});
exports.Polyline = Polyline;
exports.Polygon = Polygon;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/coord/cartesian/AxisModel.js");

__webpack_require__("./node_modules/echarts/lib/component/axis/CartesianAxisView.js");

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/AxisBuilder.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var retrieve = _util.retrieve;
var defaults = _util.defaults;
var extend = _util.extend;
var each = _util.each;

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var isRadianAroundZero = _number.isRadianAroundZero;
var remRadian = _number.remRadian;

var _symbol = __webpack_require__("./node_modules/echarts/lib/util/symbol.js");

var createSymbol = _symbol.createSymbol;

var matrixUtil = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

var _vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var v2ApplyTransform = _vector.applyTransform;
var PI = Math.PI;

function makeAxisEventDataBase(axisModel) {
  var eventData = {
    componentType: axisModel.mainType
  };
  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
  return eventData;
}
/**
 * A final axis is translated and rotated from a "standard axis".
 * So opt.position and opt.rotation is required.
 *
 * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
 * for example: (0, 0) ------------> (0, 50)
 *
 * nameDirection or tickDirection or labelDirection is 1 means tick
 * or label is below the standard axis, whereas is -1 means above
 * the standard axis. labelOffset means offset between label and axis,
 * which is useful when 'onZero', where axisLabel is in the grid and
 * label in outside grid.
 *
 * Tips: like always,
 * positive rotation represents anticlockwise, and negative rotation
 * represents clockwise.
 * The direction of position coordinate is the same as the direction
 * of screen coordinate.
 *
 * Do not need to consider axis 'inverse', which is auto processed by
 * axis extent.
 *
 * @param {module:zrender/container/Group} group
 * @param {Object} axisModel
 * @param {Object} opt Standard axis parameters.
 * @param {Array.<number>} opt.position [x, y]
 * @param {number} opt.rotation by radian
 * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.
 * @param {number} [opt.tickDirection=1] 1 or -1
 * @param {number} [opt.labelDirection=1] 1 or -1
 * @param {number} [opt.labelOffset=0] Usefull when onZero.
 * @param {string} [opt.axisLabelShow] default get from axisModel.
 * @param {string} [opt.axisName] default get from axisModel.
 * @param {number} [opt.axisNameAvailableWidth]
 * @param {number} [opt.labelRotate] by degree, default get from axisModel.
 * @param {number} [opt.labelInterval] Default label interval when label
 *                                     interval from model is null or 'auto'.
 * @param {number} [opt.strokeContainThreshold] Default label interval when label
 * @param {number} [opt.nameTruncateMaxWidth]
 */


var AxisBuilder = function (axisModel, opt) {
  /**
   * @readOnly
   */
  this.opt = opt;
  /**
   * @readOnly
   */

  this.axisModel = axisModel; // Default value

  defaults(opt, {
    labelOffset: 0,
    nameDirection: 1,
    tickDirection: 1,
    labelDirection: 1,
    silent: true
  });
  /**
   * @readOnly
   */

  this.group = new graphic.Group(); // FIXME Not use a seperate text group?

  var dumbGroup = new graphic.Group({
    position: opt.position.slice(),
    rotation: opt.rotation
  }); // this.group.add(dumbGroup);
  // this._dumbGroup = dumbGroup;

  dumbGroup.updateTransform();
  this._transform = dumbGroup.transform;
  this._dumbGroup = dumbGroup;
};

AxisBuilder.prototype = {
  constructor: AxisBuilder,
  hasBuilder: function (name) {
    return !!builders[name];
  },
  add: function (name) {
    builders[name].call(this);
  },
  getGroup: function () {
    return this.group;
  }
};
var builders = {
  /**
   * @private
   */
  axisLine: function () {
    var opt = this.opt;
    var axisModel = this.axisModel;

    if (!axisModel.get('axisLine.show')) {
      return;
    }

    var extent = this.axisModel.axis.getExtent();
    var matrix = this._transform;
    var pt1 = [extent[0], 0];
    var pt2 = [extent[1], 0];

    if (matrix) {
      v2ApplyTransform(pt1, pt1, matrix);
      v2ApplyTransform(pt2, pt2, matrix);
    }

    var lineStyle = extend({
      lineCap: 'round'
    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());
    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({
      // Id for animation
      anid: 'line',
      shape: {
        x1: pt1[0],
        y1: pt1[1],
        x2: pt2[0],
        y2: pt2[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    })));
    var arrows = axisModel.get('axisLine.symbol');
    var arrowSize = axisModel.get('axisLine.symbolSize');

    if (arrows != null) {
      if (typeof arrows === 'string') {
        // Use the same arrow for start and end point
        arrows = [arrows, arrows];
      }

      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {
        // Use the same size for width and height
        arrowSize = [arrowSize, arrowSize];
      }

      var symbolWidth = arrowSize[0];
      var symbolHeight = arrowSize[1];
      each([[opt.rotation + Math.PI / 2, pt1], [opt.rotation - Math.PI / 2, pt2]], function (item, index) {
        if (arrows[index] !== 'none' && arrows[index] != null) {
          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);
          symbol.attr({
            rotation: item[0],
            position: item[1],
            silent: true
          });
          this.group.add(symbol);
        }
      }, this);
    }
  },

  /**
   * @private
   */
  axisTickLabel: function () {
    var axisModel = this.axisModel;
    var opt = this.opt;
    var tickEls = buildAxisTick(this, axisModel, opt);
    var labelEls = buildAxisLabel(this, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, tickEls);
  },

  /**
   * @private
   */
  axisName: function () {
    var opt = this.opt;
    var axisModel = this.axisModel;
    var name = retrieve(opt.axisName, axisModel.get('name'));

    if (!name) {
      return;
    }

    var nameLocation = axisModel.get('nameLocation');
    var nameDirection = opt.nameDirection;
    var textStyleModel = axisModel.getModel('nameTextStyle');
    var gap = axisModel.get('nameGap') || 0;
    var extent = this.axisModel.axis.getExtent();
    var gapSignal = extent[0] > extent[1] ? -1 : 1;
    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'
    // Reuse labelOffset.
    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];
    var labelLayout;
    var nameRotation = axisModel.get('nameRotate');

    if (nameRotation != null) {
      nameRotation = nameRotation * PI / 180; // To radian.
    }

    var axisNameAvailableWidth;

    if (isNameLocationCenter(nameLocation)) {
      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
      nameDirection);
    } else {
      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;

      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }

    var textFont = textStyleModel.getFont();
    var truncateOpt = axisModel.get('nameTruncate', true) || {};
    var ellipsis = truncateOpt.ellipsis;
    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME
    // truncate rich text? (consider performance)

    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {
      minChar: 2,
      placeholder: truncateOpt.placeholder
    }) : name;
    var tooltipOpt = axisModel.get('tooltip', true);
    var mainType = axisModel.mainType;
    var formatterParams = {
      componentType: mainType,
      name: name,
      $vars: ['name']
    };
    formatterParams[mainType + 'Index'] = axisModel.componentIndex;
    var textEl = new graphic.Text({
      // Id for animation
      anid: 'name',
      __fullText: name,
      __truncatedText: truncatedText,
      position: pos,
      rotation: labelLayout.rotation,
      silent: isSilent(axisModel),
      z2: 1,
      tooltip: tooltipOpt && tooltipOpt.show ? extend({
        content: name,
        formatter: function () {
          return name;
        },
        formatterParams: formatterParams
      }, tooltipOpt) : null
    });
    graphic.setTextStyle(textEl.style, textStyleModel, {
      text: truncatedText,
      textFont: textFont,
      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),
      textAlign: labelLayout.textAlign,
      textVerticalAlign: labelLayout.textVerticalAlign
    });

    if (axisModel.get('triggerEvent')) {
      textEl.eventData = makeAxisEventDataBase(axisModel);
      textEl.eventData.targetType = 'axisName';
      textEl.eventData.name = name;
    } // FIXME


    this._dumbGroup.add(textEl);

    textEl.updateTransform();
    this.group.add(textEl);
    textEl.decomposeTransform();
  }
};
/**
 * @public
 * @static
 * @param {Object} opt
 * @param {number} axisRotation in radian
 * @param {number} textRotation in radian
 * @param {number} direction
 * @return {Object} {
 *  rotation, // according to axis
 *  textAlign,
 *  textVerticalAlign
 * }
 */

var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
  var rotationDiff = remRadian(textRotation - axisRotation);
  var textAlign;
  var textVerticalAlign;

  if (isRadianAroundZero(rotationDiff)) {
    // Label is parallel with axis line.
    textVerticalAlign = direction > 0 ? 'top' : 'bottom';
    textAlign = 'center';
  } else if (isRadianAroundZero(rotationDiff - PI)) {
    // Label is inverse parallel with axis line.
    textVerticalAlign = direction > 0 ? 'bottom' : 'top';
    textAlign = 'center';
  } else {
    textVerticalAlign = 'middle';

    if (rotationDiff > 0 && rotationDiff < PI) {
      textAlign = direction > 0 ? 'right' : 'left';
    } else {
      textAlign = direction > 0 ? 'left' : 'right';
    }
  }

  return {
    rotation: rotationDiff,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
};

function endTextLayout(opt, textPosition, textRotate, extent) {
  var rotationDiff = remRadian(textRotate - opt.rotation);
  var textAlign;
  var textVerticalAlign;
  var inverse = extent[0] > extent[1];
  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;

  if (isRadianAroundZero(rotationDiff - PI / 2)) {
    textVerticalAlign = onLeft ? 'bottom' : 'top';
    textAlign = 'center';
  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
    textVerticalAlign = onLeft ? 'top' : 'bottom';
    textAlign = 'center';
  } else {
    textVerticalAlign = 'middle';

    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
      textAlign = onLeft ? 'left' : 'right';
    } else {
      textAlign = onLeft ? 'right' : 'left';
    }
  }

  return {
    rotation: rotationDiff,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}

function isSilent(axisModel) {
  var tooltipOpt = axisModel.get('tooltip');
  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.
  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);
}

function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  // If min or max are user set, we need to check
  // If the tick on min(max) are overlap on their neighbour tick
  // If they are overlapped, we need to hide the min(max) tick label
  var showMinLabel = axisModel.get('axisLabel.showMinLabel');
  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME
  // Have not consider onBand yet, where tick els is more than label els.

  labelEls = labelEls || [];
  tickEls = tickEls || [];
  var firstLabel = labelEls[0];
  var nextLabel = labelEls[1];
  var lastLabel = labelEls[labelEls.length - 1];
  var prevLabel = labelEls[labelEls.length - 2];
  var firstTick = tickEls[0];
  var nextTick = tickEls[1];
  var lastTick = tickEls[tickEls.length - 1];
  var prevTick = tickEls[tickEls.length - 2];

  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }

  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}

function ignoreEl(el) {
  el && (el.ignore = true);
}

function isTwoLabelOverlapped(current, next, labelLayout) {
  // current and next has the same rotation.
  var firstRect = current && current.getBoundingRect().clone();
  var nextRect = next && next.getBoundingRect().clone();

  if (!firstRect || !nextRect) {
    return;
  } // When checking intersect of two rotated labels, we use mRotationBack
  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.


  var mRotationBack = matrixUtil.identity([]);
  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));
  return firstRect.intersect(nextRect);
}

function isNameLocationCenter(nameLocation) {
  return nameLocation === 'middle' || nameLocation === 'center';
}
/**
 * @static
 */


var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval, ticksCnt, showMinLabel, showMaxLabel) {
  if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {
    return false;
  } // FIXME
  // Have not consider label overlap (if label is too long) yet.


  var rawTick;
  var scale = axis.scale;
  return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));
};
/**
 * @static
 */


var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {
  var interval = model.get('interval');

  if (interval == null || interval == 'auto') {
    interval = labelInterval;
  }

  return interval;
};

function buildAxisTick(axisBuilder, axisModel, opt) {
  var axis = axisModel.axis;

  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {
    return;
  }

  var tickModel = axisModel.getModel('axisTick');
  var lineStyleModel = tickModel.getModel('lineStyle');
  var tickLen = tickModel.get('length');
  var tickInterval = getInterval(tickModel, opt.labelInterval);
  var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel')); // FIXME
  // Corresponds to ticksCoords ?

  var ticks = axis.scale.getTicks();
  var showMinLabel = axisModel.get('axisLabel.showMinLabel');
  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');
  var pt1 = [];
  var pt2 = [];
  var matrix = axisBuilder._transform;
  var tickEls = [];
  var ticksCnt = ticksCoords.length;

  for (var i = 0; i < ticksCnt; i++) {
    // Only ordinal scale support tick interval
    if (ifIgnoreOnTick(axis, i, tickInterval, ticksCnt, showMinLabel, showMaxLabel)) {
      continue;
    }

    var tickCoord = ticksCoords[i];
    pt1[0] = tickCoord;
    pt1[1] = 0;
    pt2[0] = tickCoord;
    pt2[1] = opt.tickDirection * tickLen;

    if (matrix) {
      v2ApplyTransform(pt1, pt1, matrix);
      v2ApplyTransform(pt2, pt2, matrix);
    } // Tick line, Not use group transform to have better line draw


    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({
      // Id for animation
      anid: 'tick_' + ticks[i],
      shape: {
        x1: pt1[0],
        y1: pt1[1],
        x2: pt2[0],
        y2: pt2[1]
      },
      style: defaults(lineStyleModel.getLineStyle(), {
        stroke: axisModel.get('axisLine.lineStyle.color')
      }),
      z2: 2,
      silent: true
    }));
    axisBuilder.group.add(tickEl);
    tickEls.push(tickEl);
  }

  return tickEls;
}

function buildAxisLabel(axisBuilder, axisModel, opt) {
  var axis = axisModel.axis;
  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));

  if (!show || axis.scale.isBlank()) {
    return;
  }

  var labelModel = axisModel.getModel('axisLabel');
  var labelMargin = labelModel.get('margin');
  var ticks = axis.scale.getTicks();
  var labels = axisModel.getFormattedLabels(); // Special label rotate.

  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;
  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  var categoryData = axisModel.get('data');
  var labelEls = [];
  var silent = isSilent(axisModel);
  var triggerEvent = axisModel.get('triggerEvent');
  var showMinLabel = axisModel.get('axisLabel.showMinLabel');
  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');
  each(ticks, function (tickVal, index) {
    if (ifIgnoreOnTick(axis, index, opt.labelInterval, ticks.length, showMinLabel, showMaxLabel)) {
      return;
    }

    var itemLabelModel = labelModel;

    if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {
      itemLabelModel = new Model(categoryData[tickVal].textStyle, labelModel, axisModel.ecModel);
    }

    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');
    var tickCoord = axis.dataToCoord(tickVal);
    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
    var labelStr = axis.scale.getLabel(tickVal);
    var textEl = new graphic.Text({
      // Id for animation
      anid: 'label_' + tickVal,
      position: pos,
      rotation: labelLayout.rotation,
      silent: silent,
      z2: 10
    });
    graphic.setTextStyle(textEl.style, itemLabelModel, {
      text: labels[index],
      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original
      // index of axis.data. So tick should not be exposed to user
      // in category axis.
      // (2) Compatible with previous version, which always returns labelStr.
      // But in interval scale labelStr is like '223,445', which maked
      // user repalce ','. So we modify it to return original val but remain
      // it as 'string' to avoid error in replacing.
      axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal, index) : textColor
    }); // Pack data for mouse event

    if (triggerEvent) {
      textEl.eventData = makeAxisEventDataBase(axisModel);
      textEl.eventData.targetType = 'axisLabel';
      textEl.eventData.value = labelStr;
    } // FIXME


    axisBuilder._dumbGroup.add(textEl);

    textEl.updateTransform();
    labelEls.push(textEl);
    axisBuilder.group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}

var _default = AxisBuilder;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/AxisView.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var axisPointerModelHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/modelHelper.js");

/**
 * Base class of AxisView.
 */
var AxisView = echarts.extendComponentView({
  type: 'axis',

  /**
   * @private
   */
  _axisPointer: null,

  /**
   * @protected
   * @type {string}
   */
  axisPointerClass: null,

  /**
   * @override
   */
  render: function (axisModel, ecModel, api, payload) {
    // FIXME
    // This process should proformed after coordinate systems updated
    // (axis scale updated), and should be performed each time update.
    // So put it here temporarily, although it is not appropriate to
    // put a model-writing procedure in `view`.
    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);
    AxisView.superApply(this, 'render', arguments);
    updateAxisPointer(this, axisModel, ecModel, api, payload, true);
  },

  /**
   * Action handler.
   * @public
   * @param {module:echarts/coord/cartesian/AxisModel} axisModel
   * @param {module:echarts/model/Global} ecModel
   * @param {module:echarts/ExtensionAPI} api
   * @param {Object} payload
   */
  updateAxisPointer: function (axisModel, ecModel, api, payload, force) {
    updateAxisPointer(this, axisModel, ecModel, api, payload, false);
  },

  /**
   * @override
   */
  remove: function (ecModel, api) {
    var axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api);
    AxisView.superApply(this, 'remove', arguments);
  },

  /**
   * @override
   */
  dispose: function (ecModel, api) {
    disposeAxisPointer(this, api);
    AxisView.superApply(this, 'dispose', arguments);
  }
});

function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
  var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);

  if (!Clazz) {
    return;
  }

  var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);
  axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
}

function disposeAxisPointer(axisView, ecModel, api) {
  var axisPointer = axisView._axisPointer;
  axisPointer && axisPointer.dispose(ecModel, api);
  axisView._axisPointer = null;
}

var axisPointerClazz = [];

AxisView.registerAxisPointerClass = function (type, clazz) {
  axisPointerClazz[type] = clazz;
};

AxisView.getAxisPointerClass = function (type) {
  return type && axisPointerClazz[type];
};

var _default = AxisView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/CartesianAxisView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var AxisBuilder = __webpack_require__("./node_modules/echarts/lib/component/axis/AxisBuilder.js");

var AxisView = __webpack_require__("./node_modules/echarts/lib/component/axis/AxisView.js");

var cartesianAxisHelper = __webpack_require__("./node_modules/echarts/lib/component/axis/cartesianAxisHelper.js");

var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;
var getInterval = AxisBuilder.getInterval;
var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
var selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {
//     var alignWithLabel = model.get('alignWithLabel');
//     if (alignWithLabel === 'auto') {
//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');
//     }
//     return alignWithLabel;
// }

var CartesianAxisView = AxisView.extend({
  type: 'cartesianAxis',
  axisPointerClass: 'CartesianAxisPointer',

  /**
   * @override
   */
  render: function (axisModel, ecModel, api, payload) {
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new graphic.Group();
    this.group.add(this._axisGroup);

    if (!axisModel.get('show')) {
      return;
    }

    var gridModel = axisModel.getCoordSysModel();
    var layout = cartesianAxisHelper.layout(gridModel, axisModel);
    var axisBuilder = new AxisBuilder(axisModel, layout);
    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);

    this._axisGroup.add(axisBuilder.getGroup());

    zrUtil.each(selfBuilderAttrs, function (name) {
      if (axisModel.get(name + '.show')) {
        this['_' + name](axisModel, gridModel, layout.labelInterval);
      }
    }, this);
    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);
  },

  /**
   * @param {module:echarts/coord/cartesian/AxisModel} axisModel
   * @param {module:echarts/coord/cartesian/GridModel} gridModel
   * @param {number|Function} labelInterval
   * @private
   */
  _splitLine: function (axisModel, gridModel, labelInterval) {
    var axis = axisModel.axis;

    if (axis.scale.isBlank()) {
      return;
    }

    var splitLineModel = axisModel.getModel('splitLine');
    var lineStyleModel = splitLineModel.getModel('lineStyle');
    var lineColors = lineStyleModel.get('color');
    var lineInterval = getInterval(splitLineModel, labelInterval);
    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords();
    var ticks = axis.scale.getTicks();
    var showMinLabel = axisModel.get('axisLabel.showMinLabel');
    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');
    var p1 = [];
    var p2 = []; // Simple optimization
    // Batching the lines if color are the same

    var lineStyle = lineStyleModel.getLineStyle();

    for (var i = 0; i < ticksCoords.length; i++) {
      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {
        continue;
      }

      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);

      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }

      var colorIndex = lineCount++ % lineColors.length;

      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({
        anid: 'line_' + ticks[i],
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        style: zrUtil.defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      })));
    }
  },

  /**
   * @param {module:echarts/coord/cartesian/AxisModel} axisModel
   * @param {module:echarts/coord/cartesian/GridModel} gridModel
   * @param {number|Function} labelInterval
   * @private
   */
  _splitArea: function (axisModel, gridModel, labelInterval) {
    var axis = axisModel.axis;

    if (axis.scale.isBlank()) {
      return;
    }

    var splitAreaModel = axisModel.getModel('splitArea');
    var areaStyleModel = splitAreaModel.getModel('areaStyle');
    var areaColors = areaStyleModel.get('color');
    var gridRect = gridModel.coordinateSystem.getRect();
    var ticksCoords = axis.getTicksCoords();
    var ticks = axis.scale.getTicks();
    var prevX = axis.toGlobalCoord(ticksCoords[0]);
    var prevY = axis.toGlobalCoord(ticksCoords[0]);
    var count = 0;
    var areaInterval = getInterval(splitAreaModel, labelInterval);
    var areaStyle = areaStyleModel.getAreaStyle();
    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];
    var showMinLabel = axisModel.get('axisLabel.showMinLabel');
    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');

    for (var i = 1; i < ticksCoords.length; i++) {
      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {
        continue;
      }

      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);
      var x;
      var y;
      var width;
      var height;

      if (axis.isHorizontal()) {
        x = prevX;
        y = gridRect.y;
        width = tickCoord - x;
        height = gridRect.height;
      } else {
        x = gridRect.x;
        y = prevY;
        width = gridRect.width;
        height = tickCoord - y;
      }

      var colorIndex = count++ % areaColors.length;

      this._axisGroup.add(new graphic.Rect({
        anid: 'area_' + ticks[i],
        shape: {
          x: x,
          y: y,
          width: width,
          height: height
        },
        style: zrUtil.defaults({
          fill: areaColors[colorIndex]
        }, areaStyle),
        silent: true
      }));

      prevX = x + width;
      prevY = y + height;
    }
  }
});
CartesianAxisView.extend({
  type: 'xAxis'
});
CartesianAxisView.extend({
  type: 'yAxis'
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/cartesianAxisHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/**
 * @param {Object} opt {labelInside}
 * @return {Object} {
 *  position, rotation, labelDirection, labelOffset,
 *  tickDirection, labelRotate, labelInterval, z2
 * }
 */
function layout(gridModel, axisModel, opt) {
  opt = opt || {};
  var grid = gridModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout = {};
  var rawAxisPosition = axis.position;
  var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;
  var axisDim = axis.dim;
  var rect = grid.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var idx = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  };
  var axisOffset = axisModel.get('offset') || 0;
  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];

  if (axis.onZero) {
    var otherAxis = grid.getAxis(axisDim === 'x' ? 'y' : 'x', axis.onZeroAxisIndex);
    var onZeroCoord = otherAxis.toGlobalCoord(otherAxis.dataToCoord(0));
    posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  } // Axis position


  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation

  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim

  var dirMap = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
  layout.labelOffset = axis.onZero ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;

  if (axisModel.get('axisTick.inside')) {
    layout.tickDirection = -layout.tickDirection;
  }

  if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {
    layout.labelDirection = -layout.labelDirection;
  } // Special label rotation


  var labelRotate = axisModel.get('axisLabel.rotate');
  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // label interval when auto mode.

  layout.labelInterval = axis.getLabelInterval(); // Over splitLine and splitArea

  layout.z2 = 1;
  return layout;
}

exports.layout = layout;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var axisPointerModelHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/modelHelper.js");

var axisTrigger = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/axisTrigger.js");

__webpack_require__("./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js");

__webpack_require__("./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js");

__webpack_require__("./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js");

// CartesianAxisPointer is not supposed to be required here. But consider
// echarts.simple.js and online build tooltip, which only require gridSimple,
// CartesianAxisPointer should be able to required somewhere.
echarts.registerPreprocessor(function (option) {
  // Always has a global axisPointerModel for default setting.
  if (option) {
    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
    var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link
    // is not set, remain null/undefined, otherwise it will
    // override existent link setting.

    if (link && !zrUtil.isArray(link)) {
      option.axisPointer.link = [link];
    }
  }
}); // This process should proformed after coordinate systems created
// and series data processed. So put it on statistic processing stage.

echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
  // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
  // allAxesInfo should be updated when setOption performed.
  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);
}); // Broadcast to all views.

echarts.registerAction({
  type: 'updateAxisPointer',
  event: 'updateAxisPointer',
  update: ':updateAxisPointer'
}, axisTrigger);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var AxisPointerModel = echarts.extendComponentModel({
  type: 'axisPointer',
  coordSysAxesInfo: null,
  defaultOption: {
    // 'auto' means that show when triggered by tooltip or handle.
    show: 'auto',
    // 'click' | 'mousemove' | 'none'
    triggerOn: null,
    // set default in AxisPonterView.js
    zlevel: 0,
    z: 50,
    type: 'line',
    // axispointer triggered by tootip determine snap automatically,
    // see `modelHelper`.
    snap: false,
    triggerTooltip: true,
    value: null,
    status: null,
    // Init value depends on whether handle is used.
    // [group0, group1, ...]
    // Each group can be: {
    //      mapper: function () {},
    //      singleTooltip: 'multiple',  // 'multiple' or 'single'
    //      xAxisId: ...,
    //      yAxisName: ...,
    //      angleAxisIndex: ...
    // }
    // mapper: can be ignored.
    //      input: {axisInfo, value}
    //      output: {axisInfo, value}
    link: [],
    // Do not set 'auto' here, otherwise global animation: false
    // will not effect at this axispointer.
    animation: null,
    animationDurationUpdate: 200,
    lineStyle: {
      color: '#aaa',
      width: 1,
      type: 'solid'
    },
    shadowStyle: {
      color: 'rgba(150,150,150,0.3)'
    },
    label: {
      show: true,
      formatter: null,
      // string | Function
      precision: 'auto',
      // Or a number like 0, 1, 2 ...
      margin: 3,
      color: '#fff',
      padding: [5, 7, 5, 7],
      backgroundColor: 'auto',
      // default: axis line color
      borderColor: null,
      borderWidth: 0,
      shadowBlur: 3,
      shadowColor: '#aaa' // Considering applicability, common style should
      // better not have shadowOffset.
      // shadowOffsetX: 0,
      // shadowOffsetY: 2

    },
    handle: {
      show: false,
      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
      // jshint ignore:line
      size: 45,
      // handle margin is from symbol center to axis, which is stable when circular move.
      margin: 50,
      // color: '#1b8bbd'
      // color: '#2f4554'
      color: '#333',
      shadowBlur: 3,
      shadowColor: '#aaa',
      shadowOffsetX: 0,
      shadowOffsetY: 2,
      // For mobile performance
      throttle: 40
    }
  }
});
var _default = AxisPointerModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var globalListener = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/globalListener.js");

var AxisPointerView = echarts.extendComponentView({
  type: 'axisPointer',
  render: function (globalAxisPointerModel, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent('tooltip');
    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable
    // AxisPointerView to be independent to Tooltip.

    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {
      // If 'none', it is not controlled by mouse totally.
      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction({
          type: 'updateAxisPointer',
          currTrigger: currTrigger,
          x: e && e.offsetX,
          y: e && e.offsetY
        });
      }
    });
  },

  /**
   * @override
   */
  remove: function (ecModel, api) {
    globalListener.unregister(api.getZr(), 'axisPointer');
    AxisPointerView.superApply(this._model, 'remove', arguments);
  },

  /**
   * @override
   */
  dispose: function (ecModel, api) {
    globalListener.unregister('axisPointer', api);
    AxisPointerView.superApply(this._model, 'dispose', arguments);
  }
});
var _default = AxisPointerView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var clazzUtil = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var axisPointerModelHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/modelHelper.js");

var eventTool = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var throttleUtil = __webpack_require__("./node_modules/echarts/lib/util/throttle.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var get = modelUtil.makeGetter();
var clone = zrUtil.clone;
var bind = zrUtil.bind;
/**
 * Base axis pointer class in 2D.
 * Implemenents {module:echarts/component/axis/IAxisPointer}.
 */

function BaseAxisPointer() {}

BaseAxisPointer.prototype = {
  /**
   * @private
   */
  _group: null,

  /**
   * @private
   */
  _lastGraphicKey: null,

  /**
   * @private
   */
  _handle: null,

  /**
   * @private
   */
  _dragging: false,

  /**
   * @private
   */
  _lastValue: null,

  /**
   * @private
   */
  _lastStatus: null,

  /**
   * @private
   */
  _payloadInfo: null,

  /**
   * In px, arbitrary value. Do not set too small,
   * no animation is ok for most cases.
   * @protected
   */
  animationThreshold: 15,

  /**
   * @implement
   */
  render: function (axisModel, axisPointerModel, api, forceRender) {
    var value = axisPointerModel.get('value');
    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not
    // be replaced when user calling setOption in not merge mode.

    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api; // Optimize: `render` will be called repeatly during mouse move.
    // So it is power consuming if performing `render` each time,
    // especially on mobile device.

    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }

    this._lastValue = value;
    this._lastStatus = status;
    var group = this._group;
    var handle = this._handle;

    if (!status || status === 'hide') {
      // Do not clear here, for animation better.
      group && group.hide();
      handle && handle.hide();
      return;
    }

    group && group.show();
    handle && handle.show(); // Otherwise status is 'show'

    var elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.

    var graphicKey = elOption.graphicKey;

    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api);
    }

    this._lastGraphicKey = graphicKey;
    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);

    if (!group) {
      group = this._group = new graphic.Group();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api.getZr().add(group);
    } else {
      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }

    updateMandatoryProps(group, axisPointerModel, true);

    this._renderHandle(value);
  },

  /**
   * @implement
   */
  remove: function (api) {
    this.clear(api);
  },

  /**
   * @implement
   */
  dispose: function (api) {
    this.clear(api);
  },

  /**
   * @protected
   */
  determineAnimation: function (axisModel, axisPointerModel) {
    var animation = axisPointerModel.get('animation');
    var axis = axisModel.axis;
    var isCategoryAxis = axis.type === 'category';
    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.

    if (!useSnap && !isCategoryAxis) {
      return false;
    }

    if (animation === 'auto' || animation == null) {
      var animationThreshold = this.animationThreshold;

      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      } // It is important to auto animation when snap used. Consider if there is
      // a dataZoom, animation will be disabled when too many points exist, while
      // it will be enabled for better visual effect when little points exist.


      if (useSnap) {
        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;
        var axisExtent = axis.getExtent(); // Approximate band width

        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }

      return false;
    }

    return animation === true;
  },

  /**
   * add {pointer, label, graphicKey} to elOption
   * @protected
   */
  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.
  },

  /**
   * @protected
   */
  createPointerEl: function (group, elOption, axisModel, axisPointerModel) {
    var pointerOption = elOption.pointer;

    if (pointerOption) {
      var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));
      group.add(pointerEl);
    }
  },

  /**
   * @protected
   */
  createLabelEl: function (group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      var labelEl = get(group).labelEl = new graphic.Rect(clone(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  },

  /**
   * @protected
   */
  updatePointerEl: function (group, elOption, updateProps) {
    var pointerEl = get(group).pointerEl;

    if (pointerEl) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps(pointerEl, {
        shape: elOption.pointer.shape
      });
    }
  },

  /**
   * @protected
   */
  updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {
    var labelEl = get(group).labelEl;

    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps(labelEl, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        shape: elOption.label.shape,
        position: elOption.label.position
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  },

  /**
   * @private
   */
  _renderHandle: function (value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }

    var axisPointerModel = this._axisPointerModel;

    var zr = this._api.getZr();

    var handle = this._handle;
    var handleModel = axisPointerModel.getModel('handle');
    var status = axisPointerModel.get('status');

    if (!handleModel.get('show') || !status || status === 'hide') {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }

    var isInit;

    if (!this._handle) {
      isInit = true;
      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {
        cursor: 'move',
        draggable: true,
        onmousemove: function (e) {
          // Fot mobile devicem, prevent screen slider on the button.
          eventTool.stop(e.event);
        },
        onmousedown: bind(this._onHandleDragMove, this, 0, 0),
        drift: bind(this._onHandleDragMove, this),
        ondragend: bind(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }

    updateMandatoryProps(handle, axisPointerModel, false); // update style

    var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];
    handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position

    var handleSize = handleModel.get('size');

    if (!zrUtil.isArray(handleSize)) {
      handleSize = [handleSize, handleSize];
    }

    handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);
    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');

    this._moveHandleToValue(value, isInit);
  },

  /**
   * @private
   */
  _moveHandleToValue: function (value, isInit) {
    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  },

  /**
   * @private
   */
  _onHandleDragMove: function (dx, dy) {
    var handle = this._handle;

    if (!handle) {
      return;
    }

    this._dragging = true; // Persistent for throttle.

    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    get(handle).lastProp = null;

    this._doDispatchAxisPointer();
  },

  /**
   * Throttled method.
   * @private
   */
  _doDispatchAxisPointer: function () {
    var handle = this._handle;

    if (!handle) {
      return;
    }

    var payloadInfo = this._payloadInfo;
    var axisModel = this._axisModel;

    this._api.dispatchAction({
      type: 'updateAxisPointer',
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  },

  /**
   * @private
   */
  _onHandleDragEnd: function (moveAnimation) {
    this._dragging = false;
    var handle = this._handle;

    if (!handle) {
      return;
    }

    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with
    // axisPointer. So move handle to align the exact value position when
    // drag ended.


    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle
    // button, and will be hidden after finger left handle button.


    this._api.dispatchAction({
      type: 'hideTip'
    });
  },

  /**
   * Should be implemenented by sub-class if support `handle`.
   * @protected
   * @param {number} value
   * @param {module:echarts/model/Model} axisModel
   * @param {module:echarts/model/Model} axisPointerModel
   * @return {Object} {position: [x, y], rotation: 0}
   */
  getHandleTransform: null,

  /**
   * * Should be implemenented by sub-class if support `handle`.
   * @protected
   * @param {Object} transform {position, rotation}
   * @param {Array.<number>} delta [dx, dy]
   * @param {module:echarts/model/Model} axisModel
   * @param {module:echarts/model/Model} axisPointerModel
   * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}
   */
  updateHandleTransform: null,

  /**
   * @private
   */
  clear: function (api) {
    this._lastValue = null;
    this._lastStatus = null;
    var zr = api.getZr();
    var group = this._group;
    var handle = this._handle;

    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
  },

  /**
   * @protected
   */
  doClear: function () {// Implemented by sub-class if necessary.
  },

  /**
   * @protected
   * @param {Array.<number>} xy
   * @param {Array.<number>} wh
   * @param {number} [xDimIndex=0] or 1
   */
  buildLabel: function (xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  }
};
BaseAxisPointer.prototype.constructor = BaseAxisPointer;

function updateProps(animationModel, moveAnimation, el, props) {
  // Animation optimize.
  if (!propsEqual(get(el).lastProp, props)) {
    get(el).lastProp = props;
    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
  }
}

function propsEqual(lastProps, newProps) {
  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {
    var equals = true;
    zrUtil.each(newProps, function (item, key) {
      equals = equals && propsEqual(lastProps[key], item);
    });
    return !!equals;
  } else {
    return lastProps === newProps;
  }
}

function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();
}

function getHandleTransProps(trans) {
  return {
    position: trans.position.slice(),
    rotation: trans.rotation || 0
  };
}

function updateMandatoryProps(group, axisPointerModel, silent) {
  var z = axisPointerModel.get('z');
  var zlevel = axisPointerModel.get('zlevel');
  group && group.traverse(function (el) {
    if (el.type !== 'group') {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}

clazzUtil.enableClassExtend(BaseAxisPointer);
var _default = BaseAxisPointer;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js":
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var BaseAxisPointer = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js");

var viewHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/viewHelper.js");

var cartesianAxisHelper = __webpack_require__("./node_modules/echarts/lib/component/axis/cartesianAxisHelper.js");

var AxisView = __webpack_require__("./node_modules/echarts/lib/component/axis/AxisView.js");

var CartesianAxisPointer = BaseAxisPointer.extend({
  /**
   * @override
   */
  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisPointerType = axisPointerModel.get('type');
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));

    if (axisPointerType && axisPointerType !== 'none') {
      var elStyle = viewHelper.buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }

    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);
    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
  },

  /**
   * @override
   */
  getHandleTransform: function (value, axisModel, axisPointerModel) {
    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get('handle.margin');
    return {
      position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  },

  /**
   * @override
   */
  updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisExtent = axis.getGlobalExtent(true);
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var dimIndex = axis.dim === 'x' ? 0 : 1;
    var currPosition = transform.position;
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.

    var tooltipOptions = [{
      verticalAlign: 'middle'
    }, {
      align: 'center'
    }];
    return {
      position: currPosition,
      rotation: transform.rotation,
      cursorPoint: cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  }
});

function getCartesian(grid, axis) {
  var opt = {};
  opt[axis.dim + 'AxisIndex'] = axis.index;
  return grid.getCartesian(opt);
}

var pointerShapeBuilder = {
  line: function (axis, pixelValue, otherExtent, elStyle) {
    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    graphic.subPixelOptimizeLine({
      shape: targetShape,
      style: elStyle
    });
    return {
      type: 'Line',
      shape: targetShape
    };
  },
  shadow: function (axis, pixelValue, otherExtent, elStyle) {
    var bandWidth = axis.getBandWidth();
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: 'Rect',
      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};

function getAxisDimIndex(axis) {
  return axis.dim === 'x' ? 0 : 1;
}

AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);
var _default = CartesianAxisPointer;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/axisTrigger.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var modelHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/modelHelper.js");

var findPointFromSeries = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js");

var each = zrUtil.each;
var curry = zrUtil.curry;
var get = modelUtil.makeGetter();
/**
 * Basic logic: check all axis, if they do not demand show/highlight,
 * then hide/downplay them.
 *
 * @param {Object} coordSysAxesInfo
 * @param {Object} payload
 * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'
 * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to
 *              trigger axisPointer and tooltip.
 * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to
 *              trigger axisPointer and tooltip.
 * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.
 * @param {Object} [payload.dataIndex] finder, restrict target axes.
 * @param {Object} [payload.axesInfo] finder, restrict target axes.
 *        [{
 *          axisDim: 'x'|'y'|'angle'|...,
 *          axisIndex: ...,
 *          value: ...
 *        }, ...]
 * @param {Function} [payload.dispatchAction]
 * @param {Object} [payload.tooltipOption]
 * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,
 *        which can be specified in dispatchAction
 * @param {module:echarts/model/Global} ecModel
 * @param {module:echarts/ExtensionAPI} api
 * @return {Object} content of event obj for echarts.connect.
 */

function _default(payload, ecModel, api) {
  var currTrigger = payload.currTrigger;
  var point = [payload.x, payload.y];
  var finder = payload;
  var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending
  // See #6121. But we are not able to reproduce it yet.

  if (!coordSysAxesInfo) {
    return;
  }

  if (illegalPoint(point)) {
    // Used in the default behavior of `connection`: use the sample seriesIndex
    // and dataIndex. And also used in the tooltipView trigger.
    point = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }

  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
  // Notice: In this case, it is difficult to get the `point` (which is necessary to show
  // tooltip, so if point is not given, we just use the point found by sample seriesIndex
  // and dataIndex.

  var inputAxesInfo = finder.axesInfo;
  var axesInfo = coordSysAxesInfo.axesInfo;
  var shouldHide = currTrigger === 'leave' || illegalPoint(point);
  var outputFinder = {};
  var showValueMap = {};
  var dataByCoordSys = {
    list: [],
    map: {}
  };
  var updaters = {
    showPointer: curry(showPointer, showValueMap),
    showTooltip: curry(showTooltip, dataByCoordSys)
  }; // Process for triggered axes.

  each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
    // If a point given, it must be contained by the coordinate system.
    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
      var axis = axisInfo.axis;
      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.

      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        var val = inputAxisInfo && inputAxisInfo.value;

        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point);
        }

        val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);
      }
    });
  }); // Process for linked axes.

  var linkTriggers = {};
  each(axesInfo, function (tarAxisInfo, tarKey) {
    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.

    if (linkGroup && !showValueMap[tarKey]) {
      each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.

        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          var val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  each(linkTriggers, function (val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);
  });
  updateModelActually(showValueMap, axesInfo, outputFinder);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
  dispatchHighDownActually(axesInfo, dispatchAction, api);
  return outputFinder;
}

function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
  var axis = axisInfo.axis;

  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }

  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  } // Heavy calculation. So put it after axis.containData checking.


  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  var payloadBatch = payloadInfo.payloadBatch;
  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.
  // By defualt use the first involved series data as a sample to connect.

  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    zrUtil.extend(outputFinder, payloadBatch[0]);
  } // If no linkSource input, this process is for collecting link
  // target, where snap should not be accepted.


  if (!dontSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }

  updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be
  // incorrect "axis value ~ series value" mapping displayed in tooltip.

  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}

function buildPayloadsBySeries(value, axisInfo) {
  var axis = axisInfo.axis;
  var dim = axis.dim;
  var snapToValue = value;
  var payloadBatch = [];
  var minDist = Number.MAX_VALUE;
  var minDiff = -1;
  each(axisInfo.seriesModels, function (series, idx) {
    var dataDim = series.coordDimToDataDim(dim);
    var seriesNestestValue;
    var dataIndices;

    if (series.getAxisTooltipData) {
      var result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex
      // when data length is not same.
      false, axis.type === 'category' ? 0.5 : null);

      if (!dataIndices.length) {
        return;
      }

      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }

    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }

    var diff = value - seriesNestestValue;
    var dist = Math.abs(diff); // Consider category case

    if (dist <= minDist) {
      if (dist < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }

      each(dataIndices, function (dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch: payloadBatch,
    snapToValue: snapToValue
  };
}

function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value: value,
    payloadBatch: payloadBatch
  };
}

function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  var payloadBatch = payloadInfo.payloadBatch;
  var axis = axisInfo.axis;
  var axisModel = axis.model;
  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,
  // whose length will be used to judge whether dispatch action.

  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }

  var coordSysModel = axisInfo.coordSys.model;
  var coordSysKey = modelHelper.makeKey(coordSysModel);
  var coordSysItem = dataByCoordSys.map[coordSysKey];

  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }

  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value: value,
    // Caustion: viewHelper.getValueLabel is actually on "view stage", which
    // depends that all models have been updated. So it should not be performed
    // here. Considering axisPointerModel used here is volatile, which is hard
    // to be retrieve in TooltipView, we prepare parameters here.
    valueLabelOpt: {
      precision: axisPointerModel.get('label.precision'),
      formatter: axisPointerModel.get('label.formatter')
    },
    seriesDataIndices: payloadBatch.slice()
  });
}

function updateModelActually(showValueMap, axesInfo, outputFinder) {
  var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.

  each(axesInfo, function (axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    var valItem = showValueMap[key];

    if (valItem) {
      !axisInfo.useHandle && (option.status = 'show');
      option.value = valItem.value; // For label formatter param and highlight.

      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } // When always show (e.g., handle used), remain
    // original value and status.
    else {
        // If hide, value still need to be set, consider
        // click legend to toggle axis blank.
        !axisInfo.useHandle && (option.status = 'hide');
      } // If status is 'hide', should be no info in payload.


    option.status === 'show' && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}

function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
  // Basic logic: If no showTip required, hideTip will be dispatched.
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction({
      type: 'hideTip'
    });
    return;
  } // In most case only one axis (or event one series is used). It is
  // convinient to fetch payload.seriesIndex and payload.dataIndex
  // dirtectly. So put the first seriesIndex and dataIndex of the first
  // axis on the payload.


  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction({
    type: 'showTip',
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}

function dispatchHighDownActually(axesInfo, dispatchAction, api) {
  // FIXME
  // highlight status modification shoule be a stage of main process?
  // (Consider confilct (e.g., legend and axisPointer) and setOption)
  var zr = api.getZr();
  var highDownKey = 'axisPointerLastHighlights';
  var lastHighlights = get(zr)[highDownKey] || {};
  var newHighlights = get(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.
  // Build hash map and remove duplicate incidentally.

  each(axesInfo, function (axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {
      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;
      newHighlights[key] = batchItem;
    });
  }); // Diff.

  var toHighlight = [];
  var toDownplay = [];
  zrUtil.each(lastHighlights, function (batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  zrUtil.each(newHighlights, function (batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api.dispatchAction({
    type: 'downplay',
    escapeConnect: true,
    batch: toDownplay
  });
  toHighlight.length && api.dispatchAction({
    type: 'highlight',
    escapeConnect: true,
    batch: toHighlight
  });
}

function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (var i = 0; i < (inputAxesInfo || []).length; i++) {
    var inputAxisInfo = inputAxesInfo[i];

    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}

function makeMapperParam(axisInfo) {
  var axisModel = axisInfo.axis.model;
  var item = {};
  var dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;
  item.axisName = item[dim + 'AxisName'] = axisModel.name;
  item.axisId = item[dim + 'AxisId'] = axisModel.id;
  return item;
}

function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

/**
 * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}
 * @param {module:echarts/model/Global} ecModel
 * @return {Object} {point: [x, y], el: ...} point Will not be null.
 */
function _default(finder, ecModel) {
  var point = [];
  var seriesIndex = finder.seriesIndex;
  var seriesModel;

  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }

  var data = seriesModel.getData();
  var dataIndex = modelUtil.queryDataIndex(data, finder);

  if (dataIndex == null || zrUtil.isArray(dataIndex)) {
    return {
      point: []
    };
  }

  var el = data.getItemGraphicEl(dataIndex);
  var coordSys = seriesModel.coordinateSystem;

  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {
      return seriesModel.coordDimToDataDim(dim)[0];
    }), dataIndex, true)) || [];
  } else if (el) {
    // Use graphic bounding rect
    var rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }

  return {
    point: point,
    el: el
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/globalListener.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var get = modelUtil.makeGetter();
var each = zrUtil.each;
/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 * @param {Function} handler
 *      param: {string} currTrigger
 *      param: {Array.<number>} point
 */

function register(key, api, handler) {
  if (env.node) {
    return;
  }

  var zr = api.getZr();
  get(zr).records || (get(zr).records = {});
  initGlobalListeners(zr, api);
  var record = get(zr).records[key] || (get(zr).records[key] = {});
  record.handler = handler;
}

function initGlobalListeners(zr, api) {
  if (get(zr).initialized) {
    return;
  }

  get(zr).initialized = true;
  useHandler('click', zrUtil.curry(doEnter, 'click'));
  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);

  useHandler('globalout', onLeave);

  function useHandler(eventType, cb) {
    zr.on(eventType, function (e) {
      var dis = makeDispatchAction(api);
      each(get(zr).records, function (record) {
        record && cb(record, e, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api);
    });
  }
}

function dispatchTooltipFinally(pendings, api) {
  var showLen = pendings.showTip.length;
  var hideLen = pendings.hideTip.length;
  var actuallyPayload;

  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }

  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api.dispatchAction(actuallyPayload);
  }
}

function onLeave(record, e, dispatchAction) {
  record.handler('leave', null, dispatchAction);
}

function doEnter(currTrigger, record, e, dispatchAction) {
  record.handler(currTrigger, e, dispatchAction);
}

function makeDispatchAction(api) {
  var pendings = {
    showTip: [],
    hideTip: []
  }; // FIXME
  // better approach?
  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
  // So we have to add "final stage" to merge those dispatched actions.

  var dispatchAction = function (payload) {
    var pendingList = pendings[payload.type];

    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction;
      api.dispatchAction(payload);
    }
  };

  return {
    dispatchAction: dispatchAction,
    pendings: pendings
  };
}
/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 */


function unregister(key, api) {
  if (env.node) {
    return;
  }

  var zr = api.getZr();
  var record = (get(zr).records || {})[key];

  if (record) {
    get(zr).records[key] = null;
  }
}

exports.register = register;
exports.unregister = unregister;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/modelHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var each = zrUtil.each;
var curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
// allAxesInfo should be updated when setOption performed.

function collect(ecModel, api) {
  var result = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: false,

    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.

  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}

function collectAxesInfo(result, ecModel, api) {
  var globalTooltipModel = ecModel.getComponent('tooltip');
  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.

  var linksOption = globalAxisPointerModel.get('link', true) || [];
  var linkGroups = []; // Collect axes info.

  each(api.getCoordinateSystems(), function (coordSys) {
    // Some coordinate system do not support axes, like geo.
    if (!coordSys.axisPointerEnabled) {
      return;
    }

    var coordSysKey = makeKey(coordSys.model);
    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer
    // for user. So we enable seting tooltip on coordSys model.

    var coordSysModel = coordSys.model;
    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);
    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.
    // Notice this case: coordSys is `grid` but not `cartesian2D` here.

    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not
    // show but axisPointer will show as normal.
    && baseTooltipModel.get('show')) {
      // Compatible with previous logic. But series.tooltip.trigger: 'axis'
      // or series.data[n].tooltip.trigger: 'axis' are not support any more.
      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';
      var cross = baseTooltipModel.get('axisPointer.type') === 'cross';
      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));

      if (triggerAxis || cross) {
        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));
      }

      if (cross) {
        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));
      }
    } // fromTooltip: true | false | 'cross'
    // triggerTooltip: true | false | null


    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);
      var axisPointerShow = axisPointerModel.get('show');

      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }

      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get('triggerTooltip');
      }

      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      var snap = axisPointerModel.get('snap');
      var key = makeKey(axis.model);
      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).

      var axisInfo = result.axesInfo[key] = {
        key: key,
        axis: axis,
        coordSys: coordSys,
        axisPointerModel: axisPointerModel,
        triggerTooltip: triggerTooltip,
        involveSeries: involveSeries,
        snap: snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: []
      };
      axesInfoInCoordSys[key] = axisInfo;
      result.seriesInvolved |= involveSeries;
      var groupIndex = getLinkGroupIndex(linksOption, axis);

      if (groupIndex != null) {
        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
          axesInfo: {}
        });
        linkGroup.axesInfo[key] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}

function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');
  var volatileOption = {};
  each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {
    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));
  }); // category axis do not auto snap, otherwise some tick that do not
  // has value can not be hovered. value/time/log axis default snap if
  // triggered from tooltip and trigger tooltip.

  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.
  // Only these properties can be overrided from tooltip to axisPointer.

  if (tooltipAxisPointerModel.get('type') === 'cross') {
    volatileOption.type = 'line';
  }

  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.

  labelOption.show == null && (labelOption.show = false);

  if (fromTooltip === 'cross') {
    // When 'cross', both axes show labels.
    labelOption.show = true; // If triggerTooltip, this is a base axis, which should better not use cross style
    // (cross style is dashed by default)

    if (!triggerTooltip) {
      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');
      crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);
    }
  }

  return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));
}

function collectSeriesInfo(result, ecModel) {
  // Prepare data for axis trigger
  ecModel.eachSeries(function (seriesModel) {
    // Notice this case: this coordSys is `cartesian2D` but not `grid`.
    var coordSys = seriesModel.coordinateSystem;
    var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);
    var seriesTooltipShow = seriesModel.get('tooltip.show', true);

    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {
      return;
    }

    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
      var axis = axisInfo.axis;

      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  }, this);
}
/**
 * For example:
 * {
 *     axisPointer: {
 *         links: [{
 *             xAxisIndex: [2, 4],
 *             yAxisIndex: 'all'
 *         }, {
 *             xAxisId: ['a5', 'a7'],
 *             xAxisName: 'xxx'
 *         }]
 *     }
 * }
 */


function getLinkGroupIndex(linksOption, axis) {
  var axisModel = axis.model;
  var dim = axis.dim;

  for (var i = 0; i < linksOption.length; i++) {
    var linkOption = linksOption[i] || {};

    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
      return i;
    }
  }
}

function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}

function fixValue(axisModel) {
  var axisInfo = getAxisInfo(axisModel);

  if (!axisInfo) {
    return;
  }

  var axisPointerModel = axisInfo.axisPointerModel;
  var scale = axisInfo.axis.scale;
  var option = axisPointerModel.option;
  var status = axisPointerModel.get('status');
  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.

  if (value != null) {
    value = scale.parse(value);
  }

  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value
  // and status should be initialized.

  if (status == null) {
    option.status = useHandle ? 'show' : 'hide';
  }

  var extent = scale.getExtent().slice();
  extent[0] > extent[1] && extent.reverse();

  if ( // Pick a value on axis when initializing.
  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,
  // where we should re-pick a value to keep `handle` displaying normally.
  || value > extent[1]) {
    // Make handle displayed on the end of the axis when init, which looks better.
    value = extent[1];
  }

  if (value < extent[0]) {
    value = extent[0];
  }

  option.value = value;

  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';
  }
}

function getAxisInfo(axisModel) {
  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}

function getAxisPointerModel(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}

function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get('handle.show');
}
/**
 * @param {module:echarts/model/Model} model
 * @return {string} unique key
 */


function makeKey(model) {
  return model.type + '||' + model.id;
}

exports.collect = collect;
exports.fixValue = fixValue;
exports.getAxisInfo = getAxisInfo;
exports.getAxisPointerModel = getAxisPointerModel;
exports.makeKey = makeKey;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/viewHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var matrix = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

var axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

var AxisBuilder = __webpack_require__("./node_modules/echarts/lib/component/axis/AxisBuilder.js");

/**
 * @param {module:echarts/model/Model} axisPointerModel
 */
function buildElStyle(axisPointerModel) {
  var axisPointerType = axisPointerModel.get('type');
  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');
  var style;

  if (axisPointerType === 'line') {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === 'shadow') {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }

  return style;
}
/**
 * @param {Function} labelPos {align, verticalAlign, position}
 */


function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
  var value = axisPointerModel.get('value');
  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
    precision: axisPointerModel.get('label.precision'),
    formatter: axisPointerModel.get('label.formatter')
  });
  var labelModel = axisPointerModel.getModel('label');
  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);
  var font = labelModel.getFont();
  var textRect = textContain.getBoundingRect(text, font);
  var position = labelPos.position;
  var width = textRect.width + paddings[1] + paddings[3];
  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.

  var align = labelPos.align;
  align === 'right' && (position[0] -= width);
  align === 'center' && (position[0] -= width / 2);
  var verticalAlign = labelPos.verticalAlign;
  verticalAlign === 'bottom' && (position[1] -= height);
  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container

  confineInContainer(position, width, height, api);
  var bgColor = labelModel.get('backgroundColor');

  if (!bgColor || bgColor === 'auto') {
    bgColor = axisModel.get('axisLine.lineStyle.color');
  }

  elOption.label = {
    shape: {
      x: 0,
      y: 0,
      width: width,
      height: height,
      r: labelModel.get('borderRadius')
    },
    position: position.slice(),
    // TODO: rich
    style: {
      text: text,
      textFont: font,
      textFill: labelModel.getTextColor(),
      textPosition: 'inside',
      fill: bgColor,
      stroke: labelModel.get('borderColor') || 'transparent',
      lineWidth: labelModel.get('borderWidth') || 0,
      shadowBlur: labelModel.get('shadowBlur'),
      shadowColor: labelModel.get('shadowColor'),
      shadowOffsetX: labelModel.get('shadowOffsetX'),
      shadowOffsetY: labelModel.get('shadowOffsetY')
    },
    // Lable should be over axisPointer.
    z2: 10
  };
} // Do not overflow ec container


function confineInContainer(position, width, height, api) {
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  position[0] = Math.min(position[0] + width, viewWidth) - width;
  position[1] = Math.min(position[1] + height, viewHeight) - height;
  position[0] = Math.max(position[0], 0);
  position[1] = Math.max(position[1], 0);
}
/**
 * @param {number} value
 * @param {module:echarts/coord/Axis} axis
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} opt
 * @param {Array.<Object>} seriesDataIndices
 * @param {number|string} opt.precision 'auto' or a number
 * @param {string|Function} opt.formatter label formatter
 */


function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which
  // helps to debounce when when moving label.
  value, {
    precision: opt.precision
  });
  var formatter = opt.formatter;

  if (formatter) {
    var params = {
      value: axisHelper.getAxisRawValue(axis, value),
      seriesData: []
    };
    zrUtil.each(seriesDataIndices, function (idxItem) {
      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      var dataIndex = idxItem.dataIndexInside;
      var dataParams = series && series.getDataParams(dataIndex);
      dataParams && params.seriesData.push(dataParams);
    });

    if (zrUtil.isString(formatter)) {
      text = formatter.replace('{value}', text);
    } else if (zrUtil.isFunction(formatter)) {
      text = formatter(params);
    }
  }

  return text;
}
/**
 * @param {module:echarts/coord/Axis} axis
 * @param {number} value
 * @param {Object} layoutInfo {
 *  rotation, position, labelOffset, labelDirection, labelMargin
 * }
 */


function getTransformedPosition(axis, value, layoutInfo) {
  var transform = matrix.create();
  matrix.rotate(transform, transform, layoutInfo.rotation);
  matrix.translate(transform, transform, layoutInfo.position);
  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
}

function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get('label.margin');
  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
/**
 * @param {Array.<number>} p1
 * @param {Array.<number>} p2
 * @param {number} [xDimIndex=0] or 1
 */


function makeLineShape(p1, p2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p2[xDimIndex],
    y2: p2[1 - xDimIndex]
  };
}
/**
 * @param {Array.<number>} xy
 * @param {Array.<number>} wh
 * @param {number} [xDimIndex=0] or 1
 */


function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}

function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
  return {
    cx: cx,
    cy: cy,
    r0: r0,
    r: r,
    startAngle: startAngle,
    endAngle: endAngle,
    clockwise: true
  };
}

exports.buildElStyle = buildElStyle;
exports.buildLabelElOption = buildLabelElOption;
exports.getValueLabel = getValueLabel;
exports.getTransformedPosition = getTransformedPosition;
exports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;
exports.makeLineShape = makeLineShape;
exports.makeRectShape = makeRectShape;
exports.makeSectorShape = makeSectorShape;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/AxisProxy.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var helper = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/helper.js");

var each = zrUtil.each;
var asc = numberUtil.asc;
/**
 * Operate single axis.
 * One axis can only operated by one axis operator.
 * Different dataZoomModels may be defined to operate the same axis.
 * (i.e. 'inside' data zoom and 'slider' data zoom components)
 * So dataZoomModels share one axisProxy in that case.
 *
 * @class
 */

var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {
  /**
   * @private
   * @type {string}
   */
  this._dimName = dimName;
  /**
   * @private
   */

  this._axisIndex = axisIndex;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._valueWindow;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._percentWindow;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._dataExtent;
  /**
   * {minSpan, maxSpan, minValueSpan, maxValueSpan}
   * @private
   * @type {Object}
   */

  this._minMaxSpan;
  /**
   * @readOnly
   * @type {module: echarts/model/Global}
   */

  this.ecModel = ecModel;
  /**
   * @private
   * @type {module: echarts/component/dataZoom/DataZoomModel}
   */

  this._dataZoomModel = dataZoomModel;
};

AxisProxy.prototype = {
  constructor: AxisProxy,

  /**
   * Whether the axisProxy is hosted by dataZoomModel.
   *
   * @public
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   * @return {boolean}
   */
  hostedBy: function (dataZoomModel) {
    return this._dataZoomModel === dataZoomModel;
  },

  /**
   * @return {Array.<number>} Value can only be NaN or finite value.
   */
  getDataValueWindow: function () {
    return this._valueWindow.slice();
  },

  /**
   * @return {Array.<number>}
   */
  getDataPercentWindow: function () {
    return this._percentWindow.slice();
  },

  /**
   * @public
   * @param {number} axisIndex
   * @return {Array} seriesModels
   */
  getTargetSeriesModels: function () {
    var seriesModels = [];
    var ecModel = this.ecModel;
    ecModel.eachSeries(function (seriesModel) {
      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {
        var dimName = this._dimName;
        var axisModel = ecModel.queryComponents({
          mainType: dimName + 'Axis',
          index: seriesModel.get(dimName + 'AxisIndex'),
          id: seriesModel.get(dimName + 'AxisId')
        })[0];

        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {
          seriesModels.push(seriesModel);
        }
      }
    }, this);
    return seriesModels;
  },
  getAxisModel: function () {
    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);
  },
  getOtherAxisModel: function () {
    var axisDim = this._dimName;
    var ecModel = this.ecModel;
    var axisModel = this.getAxisModel();
    var isCartesian = axisDim === 'x' || axisDim === 'y';
    var otherAxisDim;
    var coordSysIndexName;

    if (isCartesian) {
      coordSysIndexName = 'gridIndex';
      otherAxisDim = axisDim === 'x' ? 'y' : 'x';
    } else {
      coordSysIndexName = 'polarIndex';
      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';
    }

    var foundOtherAxisModel;
    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {
      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {
        foundOtherAxisModel = otherAxisModel;
      }
    });
    return foundOtherAxisModel;
  },
  getMinMaxSpan: function () {
    return zrUtil.clone(this._minMaxSpan);
  },

  /**
   * Only calculate by given range and this._dataExtent, do not change anything.
   *
   * @param {Object} opt
   * @param {number} [opt.start]
   * @param {number} [opt.end]
   * @param {number} [opt.startValue]
   * @param {number} [opt.endValue]
   */
  calculateDataWindow: function (opt) {
    var dataExtent = this._dataExtent;
    var axisModel = this.getAxisModel();
    var scale = axisModel.axis.scale;

    var rangePropMode = this._dataZoomModel.getRangePropMode();

    var percentExtent = [0, 100];
    var percentWindow = [opt.start, opt.end];
    var valueWindow = [];
    each(['startValue', 'endValue'], function (prop) {
      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);
    }); // Normalize bound.

    each([0, 1], function (idx) {
      var boundValue = valueWindow[idx];
      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or
      // on `valueProp` ('startValue', 'endValue'). The former one is suitable
      // for cases that a dataZoom component controls multiple axes with different
      // unit or extent, and the latter one is suitable for accurate zoom by pixel
      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,
      // but it is awkward that `percentProp` can not be obtained from `valueProp`
      // accurately (because all of values that are overflow the `dataExtent` will
      // be calculated to percent '100%'). So we have to use
      // `dataZoom.getRangePropMode()` to mark which prop is used.
      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise
      // it remains its original value.

      if (rangePropMode[idx] === 'percent') {
        if (boundPercent == null) {
          boundPercent = percentExtent[idx];
        } // Use scale.parse to math round for category or time axis.


        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));
      } else {
        // Calculating `percent` from `value` may be not accurate, because
        // This calculation can not be inversed, because all of values that
        // are overflow the `dataExtent` will be calculated to percent '100%'
        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);
      } // valueWindow[idx] = round(boundValue);
      // percentWindow[idx] = round(boundPercent);


      valueWindow[idx] = boundValue;
      percentWindow[idx] = boundPercent;
    });
    return {
      valueWindow: asc(valueWindow),
      percentWindow: asc(percentWindow)
    };
  },

  /**
   * Notice: reset should not be called before series.restoreData() called,
   * so it is recommanded to be called in "process stage" but not "model init
   * stage".
   *
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   */
  reset: function (dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    } // Culculate data window and data extent, and record them.


    this._dataExtent = calculateDataExtent(this, this._dimName, this.getTargetSeriesModels());
    var dataWindow = this.calculateDataWindow(dataZoomModel.option);
    this._valueWindow = dataWindow.valueWindow;
    this._percentWindow = dataWindow.percentWindow;
    setMinMaxSpan(this); // Update axis setting then.

    setAxisModel(this);
  },

  /**
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   */
  restore: function (dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }

    this._valueWindow = this._percentWindow = null;
    setAxisModel(this, true);
  },

  /**
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   */
  filterData: function (dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }

    var axisDim = this._dimName;
    var seriesModels = this.getTargetSeriesModels();
    var filterMode = dataZoomModel.get('filterMode');
    var valueWindow = this._valueWindow;

    if (filterMode === 'none') {
      return;
    } // FIXME
    // Toolbox may has dataZoom injected. And if there are stacked bar chart
    // with NaN data, NaN will be filtered and stack will be wrong.
    // So we need to force the mode to be set empty.
    // In fect, it is not a big deal that do not support filterMode-'filter'
    // when using toolbox#dataZoom, utill tooltip#dataZoom support "single axis
    // selection" some day, which might need "adapt to data extent on the
    // otherAxis", which is disabled by filterMode-'empty'.


    var otherAxisModel = this.getOtherAxisModel();

    if (dataZoomModel.get('$fromToolbox') && otherAxisModel && otherAxisModel.get('type') === 'category') {
      filterMode = 'empty';
    } // Process series data


    each(seriesModels, function (seriesModel) {
      var seriesData = seriesModel.getData();
      var dataDims = seriesModel.coordDimToDataDim(axisDim);

      if (filterMode === 'weakFilter') {
        seriesData && seriesData.filterSelf(function (dataIndex) {
          var leftOut;
          var rightOut;
          var hasValue;

          for (var i = 0; i < dataDims.length; i++) {
            var value = seriesData.get(dataDims[i], dataIndex);
            var thisHasValue = !isNaN(value);
            var thisLeftOut = value < valueWindow[0];
            var thisRightOut = value > valueWindow[1];

            if (thisHasValue && !thisLeftOut && !thisRightOut) {
              return true;
            }

            thisHasValue && (hasValue = true);
            thisLeftOut && (leftOut = true);
            thisRightOut && (rightOut = true);
          } // If both left out and right out, do not filter.


          return hasValue && leftOut && rightOut;
        });
      } else {
        seriesData && each(dataDims, function (dim) {
          if (filterMode === 'empty') {
            seriesModel.setData(seriesData.map(dim, function (value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            seriesData.filterSelf(dim, isInWindow);
          }
        });
      }
    });

    function isInWindow(value) {
      return value >= valueWindow[0] && value <= valueWindow[1];
    }
  }
};

function calculateDataExtent(axisProxy, axisDim, seriesModels) {
  var dataExtent = [Infinity, -Infinity];
  each(seriesModels, function (seriesModel) {
    var seriesData = seriesModel.getData();

    if (seriesData) {
      each(seriesModel.coordDimToDataDim(axisDim), function (dim) {
        var seriesExtent = seriesData.getDataExtent(dim);
        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
      });
    }
  });

  if (dataExtent[1] < dataExtent[0]) {
    dataExtent = [NaN, NaN];
  } // It is important to get "consistent" extent when more then one axes is
  // controlled by a `dataZoom`, otherwise those axes will not be synchronized
  // when zooming. But it is difficult to know what is "consistent", considering
  // axes have different type or even different meanings (For example, two
  // time axes are used to compare data of the same date in different years).
  // So basically dataZoom just obtains extent by series.data (in category axis
  // extent can be obtained from axis.data).
  // Nevertheless, user can set min/max/scale on axes to make extent of axes
  // consistent.


  fixExtentByAxis(axisProxy, dataExtent);
  return dataExtent;
}

function fixExtentByAxis(axisProxy, dataExtent) {
  var axisModel = axisProxy.getAxisModel();
  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined
  // by axis.data by default.

  var isCategoryAxis = axisModel.get('type') === 'category';
  var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;

  if (min != null && min !== 'dataMin' && typeof min !== 'function') {
    dataExtent[0] = min;
  } else if (isCategoryAxis) {
    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;
  }

  var max = axisModel.getMax(true);

  if (max != null && max !== 'dataMax' && typeof max !== 'function') {
    dataExtent[1] = max;
  } else if (isCategoryAxis) {
    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;
  }

  if (!axisModel.get('scale', true)) {
    dataExtent[0] > 0 && (dataExtent[0] = 0);
    dataExtent[1] < 0 && (dataExtent[1] = 0);
  } // For value axis, if min/max/scale are not set, we just use the extent obtained
  // by series data, which may be a little different from the extent calculated by
  // `axisHelper.getScaleExtent`. But the different just affects the experience a
  // little when zooming. So it will not be fixed until some users require it strongly.


  return dataExtent;
}

function setAxisModel(axisProxy, isRestore) {
  var axisModel = axisProxy.getAxisModel();
  var percentWindow = axisProxy._percentWindow;
  var valueWindow = axisProxy._valueWindow;

  if (!percentWindow) {
    return;
  } // [0, 500]: arbitrary value, guess axis extent.


  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);
  precision = Math.min(precision, 20); // isRestore or isFull

  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;
  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
}

function setMinMaxSpan(axisProxy) {
  var minMaxSpan = axisProxy._minMaxSpan = {};
  var dataZoomModel = axisProxy._dataZoomModel;
  each(['min', 'max'], function (minMax) {
    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan

    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');

    if (valueSpan != null) {
      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;
      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);

      if (valueSpan != null) {
        var dataExtent = axisProxy._dataExtent;
        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      }
    }
  });
}

var _default = AxisProxy;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var helper = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/helper.js");

var AxisProxy = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/AxisProxy.js");

var each = zrUtil.each;
var eachAxisDim = helper.eachAxisDim;
var DataZoomModel = echarts.extendComponentModel({
  type: 'dataZoom',
  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],

  /**
   * @protected
   */
  defaultOption: {
    zlevel: 0,
    z: 4,
    // Higher than normal component (z: 2).
    orient: null,
    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.
    xAxisIndex: null,
    // Default the first horizontal category axis.
    yAxisIndex: null,
    // Default the first vertical category axis.
    filterMode: 'filter',
    // Possible values: 'filter' or 'empty' or 'weakFilter'.
    // 'filter': data items which are out of window will be removed. This option is
    //          applicable when filtering outliers. For each data item, it will be
    //          filtered if one of the relevant dimensions is out of the window.
    // 'weakFilter': data items which are out of window will be removed. This option
    //          is applicable when filtering outliers. For each data item, it will be
    //          filtered only if all  of the relevant dimensions are out of the same
    //          side of the window.
    // 'empty': data items which are out of window will be set to empty.
    //          This option is applicable when user should not neglect
    //          that there are some data items out of window.
    // 'none': Do not filter.
    // Taking line chart as an example, line will be broken in
    // the filtered points when filterModel is set to 'empty', but
    // be connected when set to 'filter'.
    throttle: null,
    // Dispatch action by the fixed rate, avoid frequency.
    // default 100. Do not throttle when use null/undefined.
    // If animation === true and animationDurationUpdate > 0,
    // default value is 100, otherwise 20.
    start: 0,
    // Start percent. 0 ~ 100
    end: 100,
    // End percent. 0 ~ 100
    startValue: null,
    // Start value. If startValue specified, start is ignored.
    endValue: null,
    // End value. If endValue specified, end is ignored.
    minSpan: null,
    // 0 ~ 100
    maxSpan: null,
    // 0 ~ 100
    minValueSpan: null,
    // The range of dataZoom can not be smaller than that.
    maxValueSpan: null,
    // The range of dataZoom can not be larger than that.
    rangeMode: null // Array, can be 'value' or 'percent'.

  },

  /**
   * @override
   */
  init: function (option, parentModel, ecModel) {
    /**
     * key like x_0, y_1
     * @private
     * @type {Object}
     */
    this._dataIntervalByAxis = {};
    /**
     * @private
     */

    this._dataInfo = {};
    /**
     * key like x_0, y_1
     * @private
     */

    this._axisProxies = {};
    /**
     * @readOnly
     */

    this.textStyleModel;
    /**
     * @private
     */

    this._autoThrottle = true;
    /**
     * 'percent' or 'value'
     * @private
     */

    this._rangePropMode = ['percent', 'percent'];
    var rawOption = retrieveRaw(option);
    this.mergeDefaultAndTheme(option, ecModel);
    this.doInit(rawOption);
  },

  /**
   * @override
   */
  mergeOption: function (newOption) {
    var rawOption = retrieveRaw(newOption); //FIX #2591

    zrUtil.merge(this.option, newOption, true);
    this.doInit(rawOption);
  },

  /**
   * @protected
   */
  doInit: function (rawOption) {
    var thisOption = this.option; // Disable realtime view update if canvas is not supported.

    if (!env.canvasSupported) {
      thisOption.realtime = false;
    }

    this._setDefaultThrottle(rawOption);

    updateRangeUse(this, rawOption);
    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
      // start/end has higher priority over startValue/endValue if they
      // both set, but we should make chart.setOption({endValue: 1000})
      // effective, rather than chart.setOption({endValue: 1000, end: null}).
      if (this._rangePropMode[index] === 'value') {
        thisOption[names[0]] = null;
      } // Otherwise do nothing and use the merge result.

    }, this);
    this.textStyleModel = this.getModel('textStyle');

    this._resetTarget();

    this._giveAxisProxies();
  },

  /**
   * @private
   */
  _giveAxisProxies: function () {
    var axisProxies = this._axisProxies;
    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {
      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.

      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.
      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME
      // dispose __dzAxisProxy

      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;
    }, this);
  },

  /**
   * @private
   */
  _resetTarget: function () {
    var thisOption = this.option;

    var autoMode = this._judgeAutoMode();

    eachAxisDim(function (dimNames) {
      var axisIndexName = dimNames.axisIndex;
      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);
    }, this);

    if (autoMode === 'axisIndex') {
      this._autoSetAxisIndex();
    } else if (autoMode === 'orient') {
      this._autoSetOrient();
    }
  },

  /**
   * @private
   */
  _judgeAutoMode: function () {
    // Auto set only works for setOption at the first time.
    // The following is user's reponsibility. So using merged
    // option is OK.
    var thisOption = this.option;
    var hasIndexSpecified = false;
    eachAxisDim(function (dimNames) {
      // When user set axisIndex as a empty array, we think that user specify axisIndex
      // but do not want use auto mode. Because empty array may be encountered when
      // some error occured.
      if (thisOption[dimNames.axisIndex] != null) {
        hasIndexSpecified = true;
      }
    }, this);
    var orient = thisOption.orient;

    if (orient == null && hasIndexSpecified) {
      return 'orient';
    } else if (!hasIndexSpecified) {
      if (orient == null) {
        thisOption.orient = 'horizontal';
      }

      return 'axisIndex';
    }
  },

  /**
   * @private
   */
  _autoSetAxisIndex: function () {
    var autoAxisIndex = true;
    var orient = this.get('orient', true);
    var thisOption = this.option;
    var dependentModels = this.dependentModels;

    if (autoAxisIndex) {
      // Find axis that parallel to dataZoom as default.
      var dimName = orient === 'vertical' ? 'y' : 'x';

      if (dependentModels[dimName + 'Axis'].length) {
        thisOption[dimName + 'AxisIndex'] = [0];
        autoAxisIndex = false;
      } else {
        each(dependentModels.singleAxis, function (singleAxisModel) {
          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {
            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];
            autoAxisIndex = false;
          }
        });
      }
    }

    if (autoAxisIndex) {
      // Find the first category axis as default. (consider polar)
      eachAxisDim(function (dimNames) {
        if (!autoAxisIndex) {
          return;
        }

        var axisIndices = [];
        var axisModels = this.dependentModels[dimNames.axis];

        if (axisModels.length && !axisIndices.length) {
          for (var i = 0, len = axisModels.length; i < len; i++) {
            if (axisModels[i].get('type') === 'category') {
              axisIndices.push(i);
            }
          }
        }

        thisOption[dimNames.axisIndex] = axisIndices;

        if (axisIndices.length) {
          autoAxisIndex = false;
        }
      }, this);
    }

    if (autoAxisIndex) {
      // FIXME
      // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），
      // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？
      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,
      // dataZoom component auto adopts series that reference to
      // both xAxis and yAxis which type is 'value'.
      this.ecModel.eachSeries(function (seriesModel) {
        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {
          eachAxisDim(function (dimNames) {
            var axisIndices = thisOption[dimNames.axisIndex];
            var axisIndex = seriesModel.get(dimNames.axisIndex);
            var axisId = seriesModel.get(dimNames.axisId);
            var axisModel = seriesModel.ecModel.queryComponents({
              mainType: dimNames.axis,
              index: axisIndex,
              id: axisId
            })[0];
            axisIndex = axisModel.componentIndex;

            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {
              axisIndices.push(axisIndex);
            }
          });
        }
      }, this);
    }
  },

  /**
   * @private
   */
  _autoSetOrient: function () {
    var dim; // Find the first axis

    this.eachTargetAxis(function (dimNames) {
      !dim && (dim = dimNames.name);
    }, this);
    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';
  },

  /**
   * @private
   */
  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {
    // FIXME
    // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。
    // 例如series.type === scatter时。
    var is = true;
    eachAxisDim(function (dimNames) {
      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);
      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];

      if (!axisModel || axisModel.get('type') !== axisType) {
        is = false;
      }
    }, this);
    return is;
  },

  /**
   * @private
   */
  _setDefaultThrottle: function (rawOption) {
    // When first time user set throttle, auto throttle ends.
    if (rawOption.hasOwnProperty('throttle')) {
      this._autoThrottle = false;
    }

    if (this._autoThrottle) {
      var globalOption = this.ecModel.option;
      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
    }
  },

  /**
   * @public
   */
  getFirstTargetAxisModel: function () {
    var firstAxisModel;
    eachAxisDim(function (dimNames) {
      if (firstAxisModel == null) {
        var indices = this.get(dimNames.axisIndex);

        if (indices.length) {
          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];
        }
      }
    }, this);
    return firstAxisModel;
  },

  /**
   * @public
   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
   */
  eachTargetAxis: function (callback, context) {
    var ecModel = this.ecModel;
    eachAxisDim(function (dimNames) {
      each(this.get(dimNames.axisIndex), function (axisIndex) {
        callback.call(context, dimNames, axisIndex, this, ecModel);
      }, this);
    }, this);
  },

  /**
   * @param {string} dimName
   * @param {number} axisIndex
   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.
   */
  getAxisProxy: function (dimName, axisIndex) {
    return this._axisProxies[dimName + '_' + axisIndex];
  },

  /**
   * @param {string} dimName
   * @param {number} axisIndex
   * @return {module:echarts/model/Model} If not found, return null/undefined.
   */
  getAxisModel: function (dimName, axisIndex) {
    var axisProxy = this.getAxisProxy(dimName, axisIndex);
    return axisProxy && axisProxy.getAxisModel();
  },

  /**
   * If not specified, set to undefined.
   *
   * @public
   * @param {Object} opt
   * @param {number} [opt.start]
   * @param {number} [opt.end]
   * @param {number} [opt.startValue]
   * @param {number} [opt.endValue]
   * @param {boolean} [ignoreUpdateRangeUsg=false]
   */
  setRawRange: function (opt, ignoreUpdateRangeUsg) {
    var option = this.option;
    each([['start', 'startValue'], ['end', 'endValue']], function (names) {
      // If only one of 'start' and 'startValue' is not null/undefined, the other
      // should be cleared, which enable clear the option.
      // If both of them are not set, keep option with the original value, which
      // enable use only set start but not set end when calling `dispatchAction`.
      // The same as 'end' and 'endValue'.
      if (opt[names[0]] != null || opt[names[1]] != null) {
        option[names[0]] = opt[names[0]];
        option[names[1]] = opt[names[1]];
      }
    }, this);
    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);
  },

  /**
   * @public
   * @return {Array.<number>} [startPercent, endPercent]
   */
  getPercentRange: function () {
    var axisProxy = this.findRepresentativeAxisProxy();

    if (axisProxy) {
      return axisProxy.getDataPercentWindow();
    }
  },

  /**
   * @public
   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
   *
   * @param {string} [axisDimName]
   * @param {number} [axisIndex]
   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.
   */
  getValueRange: function (axisDimName, axisIndex) {
    if (axisDimName == null && axisIndex == null) {
      var axisProxy = this.findRepresentativeAxisProxy();

      if (axisProxy) {
        return axisProxy.getDataValueWindow();
      }
    } else {
      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
    }
  },

  /**
   * @public
   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy
   *      corresponding to the axisModel
   * @return {module:echarts/component/dataZoom/AxisProxy}
   */
  findRepresentativeAxisProxy: function (axisModel) {
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    } // Find the first hosted axisProxy


    var axisProxies = this._axisProxies;

    for (var key in axisProxies) {
      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {
        return axisProxies[key];
      }
    } // If no hosted axis find not hosted axisProxy.
    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,
    // and the option.start or option.end settings are different. The percentRange
    // should follow axisProxy.
    // (We encounter this problem in toolbox data zoom.)


    for (var key in axisProxies) {
      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {
        return axisProxies[key];
      }
    }
  },

  /**
   * @return {Array.<string>}
   */
  getRangePropMode: function () {
    return this._rangePropMode.slice();
  }
});

function retrieveRaw(option) {
  var ret = {};
  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {
    option.hasOwnProperty(name) && (ret[name] = option[name]);
  });
  return ret;
}

function updateRangeUse(dataZoomModel, rawOption) {
  var rangePropMode = dataZoomModel._rangePropMode;
  var rangeModeInOption = dataZoomModel.get('rangeMode');
  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
    var percentSpecified = rawOption[names[0]] != null;
    var valueSpecified = rawOption[names[1]] != null;

    if (percentSpecified && !valueSpecified) {
      rangePropMode[index] = 'percent';
    } else if (!percentSpecified && valueSpecified) {
      rangePropMode[index] = 'value';
    } else if (rangeModeInOption) {
      rangePropMode[index] = rangeModeInOption[index];
    } else if (percentSpecified) {
      // percentSpecified && valueSpecified
      rangePropMode[index] = 'percent';
    } // else remain its original setting.

  });
}

var _default = DataZoomModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/DataZoomView.js":
/***/ (function(module, exports, __webpack_require__) {

var ComponentView = __webpack_require__("./node_modules/echarts/lib/view/Component.js");

var _default = ComponentView.extend({
  type: 'dataZoom',
  render: function (dataZoomModel, ecModel, api, payload) {
    this.dataZoomModel = dataZoomModel;
    this.ecModel = ecModel;
    this.api = api;
  },

  /**
   * Find the first target coordinate system.
   *
   * @protected
   * @return {Object} {
   *                   grid: [
   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
   *                       ...
   *                   ],  // cartesians must not be null/undefined.
   *                   polar: [
   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},
   *                       ...
   *                   ],  // polars must not be null/undefined.
   *                   singleAxis: [
   *                       {model: coord0, axisModels: [], coordIndex: 0}
   *                   ]
   */
  getTargetCoordInfo: function () {
    var dataZoomModel = this.dataZoomModel;
    var ecModel = this.ecModel;
    var coordSysLists = {};
    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);

      if (axisModel) {
        var coordModel = axisModel.getCoordSysModel();
        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);
      }
    }, this);

    function save(coordModel, axisModel, store, coordIndex) {
      var item;

      for (var i = 0; i < store.length; i++) {
        if (store[i].model === coordModel) {
          item = store[i];
          break;
        }
      }

      if (!item) {
        store.push(item = {
          model: coordModel,
          axisModels: [],
          coordIndex: coordIndex
        });
      }

      item.axisModels.push(axisModel);
    }

    return coordSysLists;
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js":
/***/ (function(module, exports, __webpack_require__) {

var DataZoomModel = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

var _default = DataZoomModel.extend({
  type: 'dataZoom.inside',

  /**
   * @protected
   */
  defaultOption: {
    disabled: false,
    // Whether disable this inside zoom.
    zoomLock: false,
    // Whether disable zoom but only pan.
    zoomOnMouseWheel: true,
    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
    moveOnMouseMove: true,
    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
    preventDefaultMouseMove: true
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var DataZoomView = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

var sliderMove = __webpack_require__("./node_modules/echarts/lib/component/helper/sliderMove.js");

var roams = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/roams.js");

var bind = zrUtil.bind;
var InsideZoomView = DataZoomView.extend({
  type: 'dataZoom.inside',

  /**
   * @override
   */
  init: function (ecModel, api) {
    /**
     * 'throttle' is used in this.dispatchAction, so we save range
     * to avoid missing some 'pan' info.
     * @private
     * @type {Array.<number>}
     */
    this._range;
  },

  /**
   * @override
   */
  render: function (dataZoomModel, ecModel, api, payload) {
    InsideZoomView.superApply(this, 'render', arguments); // Notice: origin this._range should be maintained, and should not be re-fetched
    // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'
    // info will be missed because of 'throttle' of this.dispatchAction.

    if (roams.shouldRecordRange(payload, dataZoomModel.id)) {
      this._range = dataZoomModel.getPercentRange();
    } // Reset controllers.


    zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {
      var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {
        return roams.generateCoordId(coordInfo.model);
      });
      zrUtil.each(coordInfoList, function (coordInfo) {
        var coordModel = coordInfo.model;
        var dataZoomOption = dataZoomModel.option;
        roams.register(api, {
          coordId: roams.generateCoordId(coordModel),
          allCoordIds: allCoordIds,
          containsPoint: function (e, x, y) {
            return coordModel.coordinateSystem.containPoint([x, y]);
          },
          dataZoomId: dataZoomModel.id,
          throttleRate: dataZoomModel.get('throttle', true),
          panGetRange: bind(this._onPan, this, coordInfo, coordSysName),
          zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName),
          zoomLock: dataZoomOption.zoomLock,
          disabled: dataZoomOption.disabled,
          roamControllerOpt: {
            zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel,
            moveOnMouseMove: dataZoomOption.moveOnMouseMove,
            preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove
          }
        });
      }, this);
    }, this);
  },

  /**
   * @override
   */
  dispose: function () {
    roams.unregister(this.api, this.dataZoomModel.id);
    InsideZoomView.superApply(this, 'dispose', arguments);
    this._range = null;
  },

  /**
   * @private
   */
  _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {
    var range = this._range.slice(); // Calculate transform by the first axis.


    var axisModel = coordInfo.axisModels[0];

    if (!axisModel) {
      return;
    }

    var directionInfo = getDirectionInfo[coordSysName]([oldX, oldY], [newX, newY], axisModel, controller, coordInfo);
    var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
    sliderMove(percentDelta, range, [0, 100], 'all');
    return this._range = range;
  },

  /**
   * @private
   */
  _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {
    var range = this._range.slice(); // Calculate transform by the first axis.


    var axisModel = coordInfo.axisModels[0];

    if (!axisModel) {
      return;
    }

    var directionInfo = getDirectionInfo[coordSysName](null, [mouseX, mouseY], axisModel, controller, coordInfo);
    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
    scale = Math.max(1 / scale, 0);
    range[0] = (range[0] - percentPoint) * scale + percentPoint;
    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.

    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
    return this._range = range;
  }
});
var getDirectionInfo = {
  grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var rect = coordInfo.model.coordinateSystem.getRect();
    oldPoint = oldPoint || [0, 0];

    if (axis.dim === 'x') {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // axis.dim === 'y'
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  },
  polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var polar = coordInfo.model.coordinateSystem;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var angleExtent = polar.getAngleAxis().getExtent();
    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
    newPoint = polar.pointToCoord(newPoint);

    if (axisModel.mainType === 'radiusAxis') {
      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);
      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);

      ret.pixelLength = radiusExtent[1] - radiusExtent[0];
      ret.pixelStart = radiusExtent[0];
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // 'angleAxis'
      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);
      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);

      ret.pixelLength = angleExtent[1] - angleExtent[0];
      ret.pixelStart = angleExtent[0];
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  },
  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {
    var axis = axisModel.axis;
    var rect = coordInfo.model.coordinateSystem.getRect();
    var ret = {};
    oldPoint = oldPoint || [0, 0];

    if (axis.orient === 'horizontal') {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // 'vertical'
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  }
};
var _default = InsideZoomView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js":
/***/ (function(module, exports, __webpack_require__) {

var DataZoomModel = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

var _default = DataZoomModel.extend({
  type: 'dataZoom.select'
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js":
/***/ (function(module, exports, __webpack_require__) {

var DataZoomView = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

var _default = DataZoomView.extend({
  type: 'dataZoom.select'
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js":
/***/ (function(module, exports, __webpack_require__) {

var DataZoomModel = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

var SliderZoomModel = DataZoomModel.extend({
  type: 'dataZoom.slider',
  layoutMode: 'box',

  /**
   * @protected
   */
  defaultOption: {
    show: true,
    // ph => placeholder. Using placehoder here because
    // deault value can only be drived in view stage.
    right: 'ph',
    // Default align to grid rect.
    top: 'ph',
    // Default align to grid rect.
    width: 'ph',
    // Default align to grid rect.
    height: 'ph',
    // Default align to grid rect.
    left: null,
    // Default align to grid rect.
    bottom: null,
    // Default align to grid rect.
    backgroundColor: 'rgba(47,69,84,0)',
    // Background of slider zoom component.
    // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,
    // highest priority, remain for compatibility of
    // previous version, but not recommended any more.
    dataBackground: {
      lineStyle: {
        color: '#2f4554',
        width: 0.5,
        opacity: 0.3
      },
      areaStyle: {
        color: 'rgba(47,69,84,0.3)',
        opacity: 0.3
      }
    },
    borderColor: '#ddd',
    // border color of the box. For compatibility,
    // if dataBackgroundColor is set, borderColor
    // is ignored.
    fillerColor: 'rgba(167,183,204,0.4)',
    // Color of selected area.
    // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.
    // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',
    handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',
    // Percent of the slider height
    handleSize: '100%',
    handleStyle: {
      color: '#a7b7cc'
    },
    labelPrecision: null,
    labelFormatter: null,
    showDetail: true,
    showDataShadow: 'auto',
    // Default auto decision.
    realtime: true,
    zoomLock: false,
    // Whether disable zoom.
    textStyle: {
      color: '#333'
    }
  }
});
var _default = SliderZoomModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var eventTool = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var throttle = __webpack_require__("./node_modules/echarts/lib/util/throttle.js");

var DataZoomView = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var sliderMove = __webpack_require__("./node_modules/echarts/lib/component/helper/sliderMove.js");

var Rect = graphic.Rect;
var linearMap = numberUtil.linearMap;
var asc = numberUtil.asc;
var bind = zrUtil.bind;
var each = zrUtil.each; // Constants

var DEFAULT_LOCATION_EDGE_GAP = 7;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var HORIZONTAL = 'horizontal';
var VERTICAL = 'vertical';
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];
var SliderZoomView = DataZoomView.extend({
  type: 'dataZoom.slider',
  init: function (ecModel, api) {
    /**
     * @private
     * @type {Object}
     */
    this._displayables = {};
    /**
     * @private
     * @type {string}
     */

    this._orient;
    /**
     * [0, 100]
     * @private
     */

    this._range;
    /**
     * [coord of the first handle, coord of the second handle]
     * @private
     */

    this._handleEnds;
    /**
     * [length, thick]
     * @private
     * @type {Array.<number>}
     */

    this._size;
    /**
     * @private
     * @type {number}
     */

    this._handleWidth;
    /**
     * @private
     * @type {number}
     */

    this._handleHeight;
    /**
     * @private
     */

    this._location;
    /**
     * @private
     */

    this._dragging;
    /**
     * @private
     */

    this._dataShadowInfo;
    this.api = api;
  },

  /**
   * @override
   */
  render: function (dataZoomModel, ecModel, api, payload) {
    SliderZoomView.superApply(this, 'render', arguments);
    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');
    this._orient = dataZoomModel.get('orient');

    if (this.dataZoomModel.get('show') === false) {
      this.group.removeAll();
      return;
    } // Notice: this._resetInterval() should not be executed when payload.type
    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'
    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,


    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {
      this._buildView();
    }

    this._updateView();
  },

  /**
   * @override
   */
  remove: function () {
    SliderZoomView.superApply(this, 'remove', arguments);
    throttle.clear(this, '_dispatchZoomAction');
  },

  /**
   * @override
   */
  dispose: function () {
    SliderZoomView.superApply(this, 'dispose', arguments);
    throttle.clear(this, '_dispatchZoomAction');
  },
  _buildView: function () {
    var thisGroup = this.group;
    thisGroup.removeAll();

    this._resetLocation();

    this._resetInterval();

    var barGroup = this._displayables.barGroup = new graphic.Group();

    this._renderBackground();

    this._renderHandle();

    this._renderDataShadow();

    thisGroup.add(barGroup);

    this._positionGroup();
  },

  /**
   * @private
   */
  _resetLocation: function () {
    var dataZoomModel = this.dataZoomModel;
    var api = this.api; // If some of x/y/width/height are not specified,
    // auto-adapt according to target grid.

    var coordRect = this._findCoordRect();

    var ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    }; // Default align by coordinate system rect.

    var positionInfo = this._orient === HORIZONTAL ? {
      // Why using 'right', because right should be used in vertical,
      // and it is better to be consistent for dealing with position param merge.
      right: ecSize.width - coordRect.x - coordRect.width,
      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,
      width: coordRect.width,
      height: DEFAULT_FILLER_SIZE
    } : {
      // vertical
      right: DEFAULT_LOCATION_EDGE_GAP,
      top: coordRect.y,
      width: DEFAULT_FILLER_SIZE,
      height: coordRect.height
    }; // Do not write back to option and replace value 'ph', because
    // the 'ph' value should be recalculated when resize.

    var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.

    zrUtil.each(['right', 'top', 'width', 'height'], function (name) {
      if (layoutParams[name] === 'ph') {
        layoutParams[name] = positionInfo[name];
      }
    });
    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);
    this._location = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    this._size = [layoutRect.width, layoutRect.height];
    this._orient === VERTICAL && this._size.reverse();
  },

  /**
   * @private
   */
  _positionGroup: function () {
    var thisGroup = this.group;
    var location = this._location;
    var orient = this._orient; // Just use the first axis to determine mapping.

    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
    var inverse = targetAxisModel && targetAxisModel.get('inverse');
    var barGroup = this._displayables.barGroup;
    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.

    barGroup.attr(orient === HORIZONTAL && !inverse ? {
      scale: otherAxisInverse ? [1, 1] : [1, -1]
    } : orient === HORIZONTAL && inverse ? {
      scale: otherAxisInverse ? [-1, 1] : [-1, -1]
    } : orient === VERTICAL && !inverse ? {
      scale: otherAxisInverse ? [1, -1] : [1, 1],
      rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.

    } : {
      scale: otherAxisInverse ? [-1, -1] : [-1, 1],
      rotation: Math.PI / 2
    }); // Position barGroup

    var rect = thisGroup.getBoundingRect([barGroup]);
    thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);
  },

  /**
   * @private
   */
  _getViewExtent: function () {
    return [0, this._size[0]];
  },
  _renderBackground: function () {
    var dataZoomModel = this.dataZoomModel;
    var size = this._size;
    var barGroup = this._displayables.barGroup;
    barGroup.add(new Rect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: dataZoomModel.get('backgroundColor')
      },
      z2: -40
    })); // Click panel, over shadow, below handles.

    barGroup.add(new Rect({
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: 'transparent'
      },
      z2: 0,
      onclick: zrUtil.bind(this._onClickPanelClick, this)
    }));
  },
  _renderDataShadow: function () {
    var info = this._dataShadowInfo = this._prepareDataShadowInfo();

    if (!info) {
      return;
    }

    var size = this._size;
    var seriesModel = info.series;
    var data = seriesModel.getRawData();
    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick
    : info.otherDim;

    if (otherDim == null) {
      return;
    }

    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.

    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];
    var otherShadowExtent = [0, size[1]];
    var thisShadowExtent = [0, size[0]];
    var areaPoints = [[size[0], 0], [0, 0]];
    var linePoints = [];
    var step = thisShadowExtent[1] / (data.count() - 1);
    var thisCoord = 0; // Optimize for large data shadow

    var stride = Math.round(data.count() / size[0]);
    var lastIsEmpty;
    data.each([otherDim], function (value, index) {
      if (stride > 0 && index % stride) {
        thisCoord += step;
        return;
      } // FIXME
      // Should consider axis.min/axis.max when drawing dataShadow.
      // FIXME
      // 应该使用统一的空判断？还是在list里进行空判断？


      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.

      var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.

      if (isEmpty && !lastIsEmpty && index) {
        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
        linePoints.push([linePoints[linePoints.length - 1][0], 0]);
      } else if (!isEmpty && lastIsEmpty) {
        areaPoints.push([thisCoord, 0]);
        linePoints.push([thisCoord, 0]);
      }

      areaPoints.push([thisCoord, otherCoord]);
      linePoints.push([thisCoord, otherCoord]);
      thisCoord += step;
      lastIsEmpty = isEmpty;
    });
    var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');

    this._displayables.barGroup.add(new graphic.Polygon({
      shape: {
        points: areaPoints
      },
      style: zrUtil.defaults({
        fill: dataZoomModel.get('dataBackgroundColor')
      }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),
      silent: true,
      z2: -20
    }));

    this._displayables.barGroup.add(new graphic.Polyline({
      shape: {
        points: linePoints
      },
      style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),
      silent: true,
      z2: -19
    }));
  },
  _prepareDataShadowInfo: function () {
    var dataZoomModel = this.dataZoomModel;
    var showDataShadow = dataZoomModel.get('showDataShadow');

    if (showDataShadow === false) {
      return;
    } // Find a representative series.


    var result;
    var ecModel = this.ecModel;
    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
      var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();
      zrUtil.each(seriesModels, function (seriesModel) {
        if (result) {
          return;
        }

        if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {
          return;
        }

        var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;
        var otherDim = getOtherDim(dimNames.name);
        var otherAxisInverse;
        var coordSys = seriesModel.coordinateSystem;

        if (otherDim != null && coordSys.getOtherAxis) {
          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
        }

        result = {
          thisAxis: thisAxis,
          series: seriesModel,
          thisDim: dimNames.name,
          otherDim: otherDim,
          otherAxisInverse: otherAxisInverse
        };
      }, this);
    }, this);
    return result;
  },
  _renderHandle: function () {
    var displaybles = this._displayables;
    var handles = displaybles.handles = [];
    var handleLabels = displaybles.handleLabels = [];
    var barGroup = this._displayables.barGroup;
    var size = this._size;
    var dataZoomModel = this.dataZoomModel;
    barGroup.add(displaybles.filler = new Rect({
      draggable: true,
      cursor: getCursor(this._orient),
      drift: bind(this._onDragMove, this, 'all'),
      onmousemove: function (e) {
        // Fot mobile devicem, prevent screen slider on the button.
        eventTool.stop(e.event);
      },
      ondragstart: bind(this._showDataInfo, this, true),
      ondragend: bind(this._onDragEnd, this),
      onmouseover: bind(this._showDataInfo, this, true),
      onmouseout: bind(this._showDataInfo, this, false),
      style: {
        fill: dataZoomModel.get('fillerColor'),
        textPosition: 'inside'
      }
    })); // Frame border.

    barGroup.add(new Rect(graphic.subPixelOptimizeRect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),
        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
        fill: 'rgba(0,0,0,0)'
      }
    })));
    each([0, 1], function (handleIndex) {
      var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {
        cursor: getCursor(this._orient),
        draggable: true,
        drift: bind(this._onDragMove, this, handleIndex),
        onmousemove: function (e) {
          // Fot mobile devicem, prevent screen slider on the button.
          eventTool.stop(e.event);
        },
        ondragend: bind(this._onDragEnd, this),
        onmouseover: bind(this._showDataInfo, this, true),
        onmouseout: bind(this._showDataInfo, this, false)
      }, {
        x: -1,
        y: 0,
        width: 2,
        height: 2
      });
      var bRect = path.getBoundingRect();
      this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);
      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());
      var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version

      if (handleColor != null) {
        path.style.fill = handleColor;
      }

      barGroup.add(handles[handleIndex] = path);
      var textStyleModel = dataZoomModel.textStyleModel;
      this.group.add(handleLabels[handleIndex] = new graphic.Text({
        silent: true,
        invisible: true,
        style: {
          x: 0,
          y: 0,
          text: '',
          textVerticalAlign: 'middle',
          textAlign: 'center',
          textFill: textStyleModel.getTextColor(),
          textFont: textStyleModel.getFont()
        },
        z2: 10
      }));
    }, this);
  },

  /**
   * @private
   */
  _resetInterval: function () {
    var range = this._range = this.dataZoomModel.getPercentRange();

    var viewExtent = this._getViewExtent();

    this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];
  },

  /**
   * @private
   * @param {(number|string)} handleIndex 0 or 1 or 'all'
   * @param {number} delta
   */
  _updateInterval: function (handleIndex, delta) {
    var dataZoomModel = this.dataZoomModel;
    var handleEnds = this._handleEnds;

    var viewExtend = this._getViewExtent();

    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    var percentExtent = [0, 100];
    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
  },

  /**
   * @private
   */
  _updateView: function (nonRealtime) {
    var displaybles = this._displayables;
    var handleEnds = this._handleEnds;
    var handleInterval = asc(handleEnds.slice());
    var size = this._size;
    each([0, 1], function (handleIndex) {
      // Handles
      var handle = displaybles.handles[handleIndex];
      var handleHeight = this._handleHeight;
      handle.attr({
        scale: [handleHeight / 2, handleHeight / 2],
        position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]
      });
    }, this); // Filler

    displaybles.filler.setShape({
      x: handleInterval[0],
      y: 0,
      width: handleInterval[1] - handleInterval[0],
      height: size[1]
    });

    this._updateDataInfo(nonRealtime);
  },

  /**
   * @private
   */
  _updateDataInfo: function (nonRealtime) {
    var dataZoomModel = this.dataZoomModel;
    var displaybles = this._displayables;
    var handleLabels = displaybles.handleLabels;
    var orient = this._orient;
    var labelTexts = ['', '']; // FIXME
    // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）

    if (dataZoomModel.get('showDetail')) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();

      if (axisProxy) {
        var axis = axisProxy.getAxisModel().axis;
        var range = this._range;
        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.
        ? axisProxy.calculateDataWindow({
          start: range[0],
          end: range[1]
        }).valueWindow : axisProxy.getDataValueWindow();
        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
      }
    }

    var orderedHandleEnds = asc(this._handleEnds.slice());
    setLabel.call(this, 0);
    setLabel.call(this, 1);

    function setLabel(handleIndex) {
      // Label
      // Text should not transform by barGroup.
      // Ignore handlers transform
      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);
      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);
      var offset = this._handleWidth / 2 + LABEL_GAP;
      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,
        textAlign: orient === HORIZONTAL ? direction : 'center',
        text: labelTexts[handleIndex]
      });
    }
  },

  /**
   * @private
   */
  _formatLabel: function (value, axis) {
    var dataZoomModel = this.dataZoomModel;
    var labelFormatter = dataZoomModel.get('labelFormatter');
    var labelPrecision = dataZoomModel.get('labelPrecision');

    if (labelPrecision == null || labelPrecision === 'auto') {
      labelPrecision = axis.getPixelPrecision();
    }

    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code
    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.
    : value.toFixed(Math.min(labelPrecision, 20));
    return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;
  },

  /**
   * @private
   * @param {boolean} showOrHide true: show, false: hide
   */
  _showDataInfo: function (showOrHide) {
    // Always show when drgging.
    showOrHide = this._dragging || showOrHide;
    var handleLabels = this._displayables.handleLabels;
    handleLabels[0].attr('invisible', !showOrHide);
    handleLabels[1].attr('invisible', !showOrHide);
  },
  _onDragMove: function (handleIndex, dx, dy) {
    this._dragging = true; // Transform dx, dy to bar coordination.

    var barTransform = this._displayables.barGroup.getLocalTransform();

    var vertex = graphic.applyTransform([dx, dy], barTransform, true);

    this._updateInterval(handleIndex, vertex[0]);

    var realtime = this.dataZoomModel.get('realtime');

    this._updateView(!realtime);

    if (realtime) {
      realtime && this._dispatchZoomAction();
    }
  },
  _onDragEnd: function () {
    this._dragging = false;

    this._showDataInfo(false);

    this._dispatchZoomAction();
  },
  _onClickPanelClick: function (e) {
    var size = this._size;

    var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);

    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
      return;
    }

    var handleEnds = this._handleEnds;
    var center = (handleEnds[0] + handleEnds[1]) / 2;

    this._updateInterval('all', localPoint[0] - center);

    this._updateView();

    this._dispatchZoomAction();
  },

  /**
   * This action will be throttled.
   * @private
   */
  _dispatchZoomAction: function () {
    var range = this._range;
    this.api.dispatchAction({
      type: 'dataZoom',
      from: this.uid,
      dataZoomId: this.dataZoomModel.id,
      start: range[0],
      end: range[1]
    });
  },

  /**
   * @private
   */
  _findCoordRect: function () {
    // Find the grid coresponding to the first axis referred by dataZoom.
    var rect;
    each(this.getTargetCoordInfo(), function (coordInfoList) {
      if (!rect && coordInfoList.length) {
        var coordSys = coordInfoList[0].model.coordinateSystem;
        rect = coordSys.getRect && coordSys.getRect();
      }
    });

    if (!rect) {
      var width = this.api.getWidth();
      var height = this.api.getHeight();
      rect = {
        x: width * 0.2,
        y: height * 0.2,
        width: width * 0.6,
        height: height * 0.6
      };
    }

    return rect;
  }
});

function getOtherDim(thisDim) {
  // FIXME
  // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好
  var map = {
    x: 'y',
    y: 'x',
    radius: 'angle',
    angle: 'radius'
  };
  return map[thisDim];
}

function getCursor(orient) {
  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';
}

var _default = SliderZoomView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var helper = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/helper.js");

echarts.registerAction('dataZoom', function (payload, ecModel) {
  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {
    return model.get(dimNames.axisIndex);
  });
  var effectedModels = [];
  ecModel.eachComponent({
    mainType: 'dataZoom',
    query: payload
  }, function (model, index) {
    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);
  });
  zrUtil.each(effectedModels, function (dataZoomModel, index) {
    dataZoomModel.setRawRange({
      start: payload.start,
      end: payload.end,
      startValue: payload.startValue,
      endValue: payload.endValue
    });
  });
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

echarts.registerProcessor(function (ecModel, api) {
  ecModel.eachComponent('dataZoom', function (dataZoomModel) {
    // We calculate window and reset axis here but not in model
    // init stage and not after action dispatch handler, because
    // reset should be called after seriesData.restoreData.
    dataZoomModel.eachTargetAxis(resetSingleAxis); // Caution: data zoom filtering is order sensitive when using
    // percent range and no min/max/scale set on axis.
    // For example, we have dataZoom definition:
    // [
    //      {xAxisIndex: 0, start: 30, end: 70},
    //      {yAxisIndex: 0, start: 20, end: 80}
    // ]
    // In this case, [20, 80] of y-dataZoom should be based on data
    // that have filtered by x-dataZoom using range of [30, 70],
    // but should not be based on full raw data. Thus sliding
    // x-dataZoom will change both ranges of xAxis and yAxis,
    // while sliding y-dataZoom will only change the range of yAxis.
    // So we should filter x-axis after reset x-axis immediately,
    // and then reset y-axis and filter y-axis.

    dataZoomModel.eachTargetAxis(filterSingleAxis);
  });
  ecModel.eachComponent('dataZoom', function (dataZoomModel) {
    // Fullfill all of the range props so that user
    // is able to get them from chart.getOption().
    var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
    var percentRange = axisProxy.getDataPercentWindow();
    var valueRange = axisProxy.getDataValueWindow();
    dataZoomModel.setRawRange({
      start: percentRange[0],
      end: percentRange[1],
      startValue: valueRange[0],
      endValue: valueRange[1]
    }, true);
  });
});

function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {
  dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);
}

function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {
  dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/helper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.

var COORDS = ['cartesian2d', 'polar', 'singleAxis'];
/**
 * @param {string} coordType
 * @return {boolean}
 */

function isCoordSupported(coordType) {
  return zrUtil.indexOf(COORDS, coordType) >= 0;
}
/**
 * Create "each" method to iterate names.
 *
 * @pubilc
 * @param  {Array.<string>} names
 * @param  {Array.<string>=} attrs
 * @return {Function}
 */


function createNameEach(names, attrs) {
  names = names.slice();
  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);
  attrs = (attrs || []).slice();
  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);
  return function (callback, context) {
    zrUtil.each(names, function (name, index) {
      var nameObj = {
        name: name,
        capital: capitalNames[index]
      };

      for (var j = 0; j < attrs.length; j++) {
        nameObj[attrs[j]] = name + capitalAttrs[j];
      }

      callback.call(context, nameObj);
    });
  };
}
/**
 * Iterate each dimension name.
 *
 * @public
 * @param {Function} callback The parameter is like:
 *                            {
 *                                name: 'angle',
 *                                capital: 'Angle',
 *                                axis: 'angleAxis',
 *                                axisIndex: 'angleAixs',
 *                                index: 'angleIndex'
 *                            }
 * @param {Object} context
 */


var eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);
/**
 * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.
 * dataZoomModels and 'links' make up one or more graphics.
 * This function finds the graphic where the source dataZoomModel is in.
 *
 * @public
 * @param {Function} forEachNode Node iterator.
 * @param {Function} forEachEdgeType edgeType iterator
 * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.
 * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}
 */

function createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {
  return function (sourceNode) {
    var result = {
      nodes: [],
      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).

    };
    forEachEdgeType(function (edgeType) {
      result.records[edgeType.name] = {};
    });

    if (!sourceNode) {
      return result;
    }

    absorb(sourceNode, result);
    var existsLink;

    do {
      existsLink = false;
      forEachNode(processSingleNode);
    } while (existsLink);

    function processSingleNode(node) {
      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {
        absorb(node, result);
        existsLink = true;
      }
    }

    return result;
  };

  function isNodeAbsorded(node, result) {
    return zrUtil.indexOf(result.nodes, node) >= 0;
  }

  function isLinked(node, result) {
    var hasLink = false;
    forEachEdgeType(function (edgeType) {
      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {
        result.records[edgeType.name][edgeId] && (hasLink = true);
      });
    });
    return hasLink;
  }

  function absorb(node, result) {
    result.nodes.push(node);
    forEachEdgeType(function (edgeType) {
      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {
        result.records[edgeType.name][edgeId] = true;
      });
    });
  }
}

exports.isCoordSupported = isCoordSupported;
exports.createNameEach = createNameEach;
exports.eachAxisDim = eachAxisDim;
exports.createLinkedNodesFinder = createLinkedNodesFinder;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/history.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var each = zrUtil.each;
var ATTR = '\0_ec_hist_store';
/**
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}
 */

function push(ecModel, newSnapshot) {
  var store = giveStore(ecModel); // If previous dataZoom can not be found,
  // complete an range with current range.

  each(newSnapshot, function (batchItem, dataZoomId) {
    var i = store.length - 1;

    for (; i >= 0; i--) {
      var snapshot = store[i];

      if (snapshot[dataZoomId]) {
        break;
      }
    }

    if (i < 0) {
      // No origin range set, create one by current range.
      var dataZoomModel = ecModel.queryComponents({
        mainType: 'dataZoom',
        subType: 'select',
        id: dataZoomId
      })[0];

      if (dataZoomModel) {
        var percentRange = dataZoomModel.getPercentRange();
        store[0][dataZoomId] = {
          dataZoomId: dataZoomId,
          start: percentRange[0],
          end: percentRange[1]
        };
      }
    }
  });
  store.push(newSnapshot);
}
/**
 * @param {module:echarts/model/Global} ecModel
 * @return {Object} snapshot
 */


function pop(ecModel) {
  var store = giveStore(ecModel);
  var head = store[store.length - 1];
  store.length > 1 && store.pop(); // Find top for all dataZoom.

  var snapshot = {};
  each(head, function (batchItem, dataZoomId) {
    for (var i = store.length - 1; i >= 0; i--) {
      var batchItem = store[i][dataZoomId];

      if (batchItem) {
        snapshot[dataZoomId] = batchItem;
        break;
      }
    }
  });
  return snapshot;
}
/**
 * @param {module:echarts/model/Global} ecModel
 */


function clear(ecModel) {
  ecModel[ATTR] = null;
}
/**
 * @param {module:echarts/model/Global} ecModel
 * @return {number} records. always >= 1.
 */


function count(ecModel) {
  return giveStore(ecModel).length;
}
/**
 * [{key: dataZoomId, value: {dataZoomId, range}}, ...]
 * History length of each dataZoom may be different.
 * this._history[0] is used to store origin range.
 * @type {Array.<Object>}
 */


function giveStore(ecModel) {
  var store = ecModel[ATTR];

  if (!store) {
    store = ecModel[ATTR] = [{}];
  }

  return store;
}

exports.push = push;
exports.pop = pop;
exports.clear = clear;
exports.count = count;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/roams.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var RoamController = __webpack_require__("./node_modules/echarts/lib/component/helper/RoamController.js");

var throttleUtil = __webpack_require__("./node_modules/echarts/lib/util/throttle.js");

// Only create one roam controller for each coordinate system.
// one roam controller might be refered by two inside data zoom
// components (for example, one for x and one for y). When user
// pan or zoom, only dispatch one action for those data zoom
// components.
var curry = zrUtil.curry;
var ATTR = '\0_ec_dataZoom_roams';
/**
 * @public
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} dataZoomInfo
 * @param {string} dataZoomInfo.coordId
 * @param {Function} dataZoomInfo.containsPoint
 * @param {Array.<string>} dataZoomInfo.allCoordIds
 * @param {string} dataZoomInfo.dataZoomId
 * @param {number} dataZoomInfo.throttleRate
 * @param {Function} dataZoomInfo.panGetRange
 * @param {Function} dataZoomInfo.zoomGetRange
 * @param {boolean} [dataZoomInfo.zoomLock]
 * @param {boolean} [dataZoomInfo.disabled]
 */

function register(api, dataZoomInfo) {
  var store = giveStore(api);
  var theDataZoomId = dataZoomInfo.dataZoomId;
  var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.
  // Avoid memory leak, dispose all not-used-registered.

  zrUtil.each(store, function (record, coordId) {
    var dataZoomInfos = record.dataZoomInfos;

    if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {
      delete dataZoomInfos[theDataZoomId];
      record.count--;
    }
  });
  cleanStore(store);
  var record = store[theCoordId]; // Create if needed.

  if (!record) {
    record = store[theCoordId] = {
      coordId: theCoordId,
      dataZoomInfos: {},
      count: 0
    };
    record.controller = createController(api, record);
    record.dispatchAction = zrUtil.curry(dispatchAction, api);
  } // Update reference of dataZoom.


  !record.dataZoomInfos[theDataZoomId] && record.count++;
  record.dataZoomInfos[theDataZoomId] = dataZoomInfo;
  var controllerParams = mergeControllerParams(record.dataZoomInfos);
  record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.

  record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.

  throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');
}
/**
 * @public
 * @param {module:echarts/ExtensionAPI} api
 * @param {string} dataZoomId
 */


function unregister(api, dataZoomId) {
  var store = giveStore(api);
  zrUtil.each(store, function (record) {
    record.controller.dispose();
    var dataZoomInfos = record.dataZoomInfos;

    if (dataZoomInfos[dataZoomId]) {
      delete dataZoomInfos[dataZoomId];
      record.count--;
    }
  });
  cleanStore(store);
}
/**
 * @public
 */


function shouldRecordRange(payload, dataZoomId) {
  if (payload && payload.type === 'dataZoom' && payload.batch) {
    for (var i = 0, len = payload.batch.length; i < len; i++) {
      if (payload.batch[i].dataZoomId === dataZoomId) {
        return false;
      }
    }
  }

  return true;
}
/**
 * @public
 */


function generateCoordId(coordModel) {
  return coordModel.type + '\0_' + coordModel.id;
}
/**
 * Key: coordId, value: {dataZoomInfos: [], count, controller}
 * @type {Array.<Object>}
 */


function giveStore(api) {
  // Mount store on zrender instance, so that we do not
  // need to worry about dispose.
  var zr = api.getZr();
  return zr[ATTR] || (zr[ATTR] = {});
}

function createController(api, newRecord) {
  var controller = new RoamController(api.getZr());
  controller.on('pan', curry(onPan, newRecord));
  controller.on('zoom', curry(onZoom, newRecord));
  return controller;
}

function cleanStore(store) {
  zrUtil.each(store, function (record, coordId) {
    if (!record.count) {
      record.controller.dispose();
      delete store[coordId];
    }
  });
}

function onPan(record, dx, dy, oldX, oldY, newX, newY) {
  wrapAndDispatch(record, function (info) {
    return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);
  });
}

function onZoom(record, scale, mouseX, mouseY) {
  wrapAndDispatch(record, function (info) {
    return info.zoomGetRange(record.controller, scale, mouseX, mouseY);
  });
}

function wrapAndDispatch(record, getRange) {
  var batch = [];
  zrUtil.each(record.dataZoomInfos, function (info) {
    var range = getRange(info);
    !info.disabled && range && batch.push({
      dataZoomId: info.dataZoomId,
      start: range[0],
      end: range[1]
    });
  });
  record.dispatchAction(batch);
}
/**
 * This action will be throttled.
 */


function dispatchAction(api, batch) {
  api.dispatchAction({
    type: 'dataZoom',
    batch: batch
  });
}
/**
 * Merge roamController settings when multiple dataZooms share one roamController.
 */


function mergeControllerParams(dataZoomInfos) {
  var controlType;
  var opt = {};
  var typePriority = {
    'true': 2,
    'move': 1,
    'false': 0,
    'undefined': -1
  };
  zrUtil.each(dataZoomInfos, function (dataZoomInfo) {
    var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true;
    typePriority[oneType] > typePriority[controlType] && (controlType = oneType); // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.

    zrUtil.extend(opt, dataZoomInfo.roamControllerOpt);
  });
  return {
    controlType: controlType,
    opt: opt
  };
}

exports.register = register;
exports.unregister = unregister;
exports.shouldRecordRange = shouldRecordRange;
exports.generateCoordId = generateCoordId;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js":
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

Component.registerSubTypeDefaulter('dataZoom', function () {
  // Default 'slider' when no type specified.
  return 'slider';
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoomSelect.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js");

/***/ }),

/***/ "./node_modules/echarts/lib/component/gridSimple.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

__webpack_require__("./node_modules/echarts/lib/coord/cartesian/Grid.js");

__webpack_require__("./node_modules/echarts/lib/component/axis.js");

// Grid view
echarts.extendComponentView({
  type: 'grid',
  render: function (gridModel, ecModel) {
    this.group.removeAll();

    if (gridModel.get('show')) {
      this.group.add(new graphic.Rect({
        shape: gridModel.coordinateSystem.getRect(),
        style: zrUtil.defaults({
          fill: gridModel.get('backgroundColor')
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  }
});
echarts.registerPreprocessor(function (option) {
  // Only create grid when need
  if (option.xAxis && option.yAxis && !option.grid) {
    option.grid = {};
  }
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/BrushController.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var interactionMutex = __webpack_require__("./node_modules/echarts/lib/component/helper/interactionMutex.js");

var DataDiffer = __webpack_require__("./node_modules/echarts/lib/data/DataDiffer.js");

var curry = zrUtil.curry;
var each = zrUtil.each;
var map = zrUtil.map;
var mathMin = Math.min;
var mathMax = Math.max;
var mathPow = Math.pow;
var COVER_Z = 10000;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = 'globalPan';
var DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
};
var CURSOR_MAP = {
  w: 'ew',
  e: 'ew',
  n: 'ns',
  s: 'ns',
  ne: 'nesw',
  sw: 'nesw',
  nw: 'nwse',
  se: 'nwse'
};
var DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: 'rgba(0,0,0,0.3)',
    fill: 'rgba(0,0,0,0.1)'
  },
  transformable: true,
  brushMode: 'single',
  removeOnClick: false
};
var baseUID = 0;
/**
 * @alias module:echarts/component/helper/BrushController
 * @constructor
 * @mixin {module:zrender/mixin/Eventful}
 * @event module:echarts/component/helper/BrushController#brush
 *        params:
 *            areas: Array.<Array>, coord relates to container group,
 *                                    If no container specified, to global.
 *            opt {
 *                isEnd: boolean,
 *                removeOnClick: boolean
 *            }
 *
 * @param {module:zrender/zrender~ZRender} zr
 */

function BrushController(zr) {
  Eventful.call(this);
  /**
   * @type {module:zrender/zrender~ZRender}
   * @private
   */

  this._zr = zr;
  /**
   * @type {module:zrender/container/Group}
   * @readOnly
   */

  this.group = new graphic.Group();
  /**
   * Only for drawing (after enabledBrush).
   *     'line', 'rect', 'polygon' or false
   *     If passing false/null/undefined, disable brush.
   *     If passing 'auto', determined by panel.defaultBrushType
   * @private
   * @type {string}
   */

  this._brushType;
  /**
   * Only for drawing (after enabledBrush).
   *
   * @private
   * @type {Object}
   */

  this._brushOption;
  /**
   * @private
   * @type {Object}
   */

  this._panels;
  /**
   * @private
   * @type {Array.<nubmer>}
   */

  this._track = [];
  /**
   * @private
   * @type {boolean}
   */

  this._dragging;
  /**
   * @private
   * @type {Array}
   */

  this._covers = [];
  /**
   * @private
   * @type {moudule:zrender/container/Group}
   */

  this._creatingCover;
  /**
   * `true` means global panel
   * @private
   * @type {module:zrender/container/Group|boolean}
   */

  this._creatingPanel;
  /**
   * @private
   * @type {boolean}
   */

  this._enableGlobalPan;
  /**
   * @private
   * @type {boolean}
   */

  /**
   * @private
   * @type {string}
   */
  this._uid = 'brushController_' + baseUID++;
  /**
   * @private
   * @type {Object}
   */

  this._handlers = {};
  each(mouseHandlers, function (handler, eventName) {
    this._handlers[eventName] = zrUtil.bind(handler, this);
  }, this);
}

BrushController.prototype = {
  constructor: BrushController,

  /**
   * If set to null/undefined/false, select disabled.
   * @param {Object} brushOption
   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false
   *                          If passing false/null/undefined, disable brush.
   *                          If passing 'auto', determined by panel.defaultBrushType.
   *                              ('auto' can not be used in global panel)
   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'
   * @param {boolean} [brushOption.transformable=true]
   * @param {boolean} [brushOption.removeOnClick=false]
   * @param {Object} [brushOption.brushStyle]
   * @param {number} [brushOption.brushStyle.width]
   * @param {number} [brushOption.brushStyle.lineWidth]
   * @param {string} [brushOption.brushStyle.stroke]
   * @param {string} [brushOption.brushStyle.fill]
   * @param {number} [brushOption.z]
   */
  enableBrush: function (brushOption) {
    this._brushType && doDisableBrush(this);
    brushOption.brushType && doEnableBrush(this, brushOption);
    return this;
  },

  /**
   * @param {Array.<Object>} panelOpts If not pass, it is global brush.
   *        Each items: {
   *            panelId, // mandatory.
   *            clipPath, // mandatory. function.
   *            isTargetByCursor, // mandatory. function.
   *            defaultBrushType, // optional, only used when brushType is 'auto'.
   *            getLinearBrushOtherExtent, // optional. function.
   *        }
   */
  setPanels: function (panelOpts) {
    if (panelOpts && panelOpts.length) {
      var panels = this._panels = {};
      zrUtil.each(panelOpts, function (panelOpts) {
        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);
      });
    } else {
      this._panels = null;
    }

    return this;
  },

  /**
   * @param {Object} [opt]
   * @return {boolean} [opt.enableGlobalPan=false]
   */
  mount: function (opt) {
    opt = opt || {};
    this._enableGlobalPan = opt.enableGlobalPan;
    var thisGroup = this.group;

    this._zr.add(thisGroup);

    thisGroup.attr({
      position: opt.position || [0, 0],
      rotation: opt.rotation || 0,
      scale: opt.scale || [1, 1]
    });
    this._transform = thisGroup.getLocalTransform();
    return this;
  },
  eachCover: function (cb, context) {
    each(this._covers, cb, context);
  },

  /**
   * Update covers.
   * @param {Array.<Object>} brushOptionList Like:
   *        [
   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},
   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},
   *            ...
   *        ]
   *        `brushType` is required in each cover info. (can not be 'auto')
   *        `id` is not mandatory.
   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.
   *        If brushOptionList is null/undefined, all covers removed.
   */
  updateCovers: function (brushOptionList) {
    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {
      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
    });
    var tmpIdPrefix = '\0-brush-index-';
    var oldCovers = this._covers;
    var newCovers = this._covers = [];
    var controller = this;
    var creatingCover = this._creatingCover;
    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
    return this;

    function getKey(brushOption, index) {
      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;
    }

    function oldGetKey(cover, index) {
      return getKey(cover.__brushOption, index);
    }

    function addOrUpdate(newIndex, oldIndex) {
      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,
      // where updating cover when creating should be forbiden.

      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
        newCovers[newIndex] = oldCovers[oldIndex];
      } else {
        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));
        updateCoverAfterCreation(controller, cover);
      }
    }

    function remove(oldIndex) {
      if (oldCovers[oldIndex] !== creatingCover) {
        controller.group.remove(oldCovers[oldIndex]);
      }
    }
  },
  unmount: function () {
    this.enableBrush(false); // container may 'removeAll' outside.

    clearCovers(this);

    this._zr.remove(this.group);

    return this;
  },
  dispose: function () {
    this.unmount();
    this.off();
  }
};
zrUtil.mixin(BrushController, Eventful);

function doEnableBrush(controller, brushOption) {
  var zr = controller._zr; // Consider roam, which takes globalPan too.

  if (!controller._enableGlobalPan) {
    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);
  }

  each(controller._handlers, function (handler, eventName) {
    zr.on(eventName, handler);
  });
  controller._brushType = brushOption.brushType;
  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
}

function doDisableBrush(controller) {
  var zr = controller._zr;
  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);
  each(controller._handlers, function (handler, eventName) {
    zr.off(eventName, handler);
  });
  controller._brushType = controller._brushOption = null;
}

function createCover(controller, brushOption) {
  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
  cover.__brushOption = brushOption;
  updateZ(cover, brushOption);
  controller.group.add(cover);
  return cover;
}

function endCreating(controller, creatingCover) {
  var coverRenderer = getCoverRenderer(creatingCover);

  if (coverRenderer.endCreating) {
    coverRenderer.endCreating(controller, creatingCover);
    updateZ(creatingCover, creatingCover.__brushOption);
  }

  return creatingCover;
}

function updateCoverShape(controller, cover) {
  var brushOption = cover.__brushOption;
  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}

function updateZ(cover, brushOption) {
  var z = brushOption.z;
  z == null && (z = COVER_Z);
  cover.traverse(function (el) {
    el.z = z;
    el.z2 = z; // Consider in given container.
  });
}

function updateCoverAfterCreation(controller, cover) {
  getCoverRenderer(cover).updateCommon(controller, cover);
  updateCoverShape(controller, cover);
}

function getCoverRenderer(cover) {
  return coverRenderers[cover.__brushOption.brushType];
} // return target panel or `true` (means global panel)


function getPanelByPoint(controller, e, localCursorPoint) {
  var panels = controller._panels;

  if (!panels) {
    return true; // Global panel
  }

  var panel;
  var transform = controller._transform;
  each(panels, function (pn) {
    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);
  });
  return panel;
} // Return a panel or true


function getPanelByCover(controller, cover) {
  var panels = controller._panels;

  if (!panels) {
    return true; // Global panel
  }

  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,
  // which is then treated as global panel.

  return panelId != null ? panels[panelId] : true;
}

function clearCovers(controller) {
  var covers = controller._covers;
  var originalLength = covers.length;
  each(covers, function (cover) {
    controller.group.remove(cover);
  }, controller);
  covers.length = 0;
  return !!originalLength;
}

function trigger(controller, opt) {
  var areas = map(controller._covers, function (cover) {
    var brushOption = cover.__brushOption;
    var range = zrUtil.clone(brushOption.range);
    return {
      brushType: brushOption.brushType,
      panelId: brushOption.panelId,
      range: range
    };
  });
  controller.trigger('brush', areas, {
    isEnd: !!opt.isEnd,
    removeOnClick: !!opt.removeOnClick
  });
}

function shouldShowCover(controller) {
  var track = controller._track;

  if (!track.length) {
    return false;
  }

  var p2 = track[track.length - 1];
  var p1 = track[0];
  var dx = p2[0] - p1[0];
  var dy = p2[1] - p1[1];
  var dist = mathPow(dx * dx + dy * dy, 0.5);
  return dist > UNSELECT_THRESHOLD;
}

function getTrackEnds(track) {
  var tail = track.length - 1;
  tail < 0 && (tail = 0);
  return [track[0], track[tail]];
}

function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {
  var cover = new graphic.Group();
  cover.add(new graphic.Rect({
    name: 'main',
    style: makeStyle(brushOption),
    silent: true,
    draggable: true,
    cursor: 'move',
    drift: curry(doDrift, controller, cover, 'nswe'),
    ondragend: curry(trigger, controller, {
      isEnd: true
    })
  }));
  each(edgeNames, function (name) {
    cover.add(new graphic.Rect({
      name: name,
      style: {
        opacity: 0
      },
      draggable: true,
      silent: true,
      invisible: true,
      drift: curry(doDrift, controller, cover, name),
      ondragend: curry(trigger, controller, {
        isEnd: true
      })
    }));
  });
  return cover;
}

function updateBaseRect(controller, cover, localRange, brushOption) {
  var lineWidth = brushOption.brushStyle.lineWidth || 0;
  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);
  var x = localRange[0][0];
  var y = localRange[1][0];
  var xa = x - lineWidth / 2;
  var ya = y - lineWidth / 2;
  var x2 = localRange[0][1];
  var y2 = localRange[1][1];
  var x2a = x2 - handleSize + lineWidth / 2;
  var y2a = y2 - handleSize + lineWidth / 2;
  var width = x2 - x;
  var height = y2 - y;
  var widtha = width + lineWidth;
  var heighta = height + lineWidth;
  updateRectShape(controller, cover, 'main', x, y, width, height);

  if (brushOption.transformable) {
    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);
    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);
    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);
    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);
    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);
    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);
    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);
    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);
  }
}

function updateCommon(controller, cover) {
  var brushOption = cover.__brushOption;
  var transformable = brushOption.transformable;
  var mainEl = cover.childAt(0);
  mainEl.useStyle(makeStyle(brushOption));
  mainEl.attr({
    silent: !transformable,
    cursor: transformable ? 'move' : 'default'
  });
  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {
    var el = cover.childOfName(name);
    var globalDir = getGlobalDirection(controller, name);
    el && el.attr({
      silent: !transformable,
      invisible: !transformable,
      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null
    });
  });
}

function updateRectShape(controller, cover, name, x, y, w, h) {
  var el = cover.childOfName(name);
  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
}

function makeStyle(brushOption) {
  return zrUtil.defaults({
    strokeNoScale: true
  }, brushOption.brushStyle);
}

function formatRectRange(x, y, x2, y2) {
  var min = [mathMin(x, x2), mathMin(y, y2)];
  var max = [mathMax(x, x2), mathMax(y, y2)];
  return [[min[0], max[0]], // x range
  [min[1], max[1]] // y range
  ];
}

function getTransform(controller) {
  return graphic.getTransform(controller.group);
}

function getGlobalDirection(controller, localDirection) {
  if (localDirection.length > 1) {
    localDirection = localDirection.split('');
    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];
    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();
    return globalDir.join('');
  } else {
    var map = {
      w: 'left',
      e: 'right',
      n: 'top',
      s: 'bottom'
    };
    var inverseMap = {
      left: 'w',
      right: 'e',
      top: 'n',
      bottom: 's'
    };
    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));
    return inverseMap[globalDir];
  }
}

function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {
  var brushOption = cover.__brushOption;
  var rectRange = toRectRange(brushOption.range);
  var localDelta = toLocalDelta(controller, dx, dy);
  each(name.split(''), function (namePart) {
    var ind = DIRECTION_MAP[namePart];
    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
  });
  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}

function driftPolygon(controller, cover, dx, dy, e) {
  var range = cover.__brushOption.range;
  var localDelta = toLocalDelta(controller, dx, dy);
  each(range, function (point) {
    point[0] += localDelta[0];
    point[1] += localDelta[1];
  });
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}

function toLocalDelta(controller, dx, dy) {
  var thisGroup = controller.group;
  var localD = thisGroup.transformCoordToLocal(dx, dy);
  var localZero = thisGroup.transformCoordToLocal(0, 0);
  return [localD[0] - localZero[0], localD[1] - localZero[1]];
}

function clipByPanel(controller, cover, data) {
  var panel = getPanelByCover(controller, cover);
  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);
}

function pointsToRect(points) {
  var xmin = mathMin(points[0][0], points[1][0]);
  var ymin = mathMin(points[0][1], points[1][1]);
  var xmax = mathMax(points[0][0], points[1][0]);
  var ymax = mathMax(points[0][1], points[1][1]);
  return {
    x: xmin,
    y: ymin,
    width: xmax - xmin,
    height: ymax - ymin
  };
}

function resetCursor(controller, e, localCursorPoint) {
  // Check active
  if (!controller._brushType) {
    return;
  }

  var zr = controller._zr;
  var covers = controller._covers;
  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.

  if (!controller._dragging) {
    for (var i = 0; i < covers.length; i++) {
      var brushOption = covers[i].__brushOption;

      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
        // Use cursor style set on cover.
        return;
      }
    }
  }

  currPanel && zr.setCursorStyle('crosshair');
}

function preventDefault(e) {
  var rawE = e.event;
  rawE.preventDefault && rawE.preventDefault();
}

function mainShapeContain(cover, x, y) {
  return cover.childOfName('main').contain(x, y);
}

function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {
  var creatingCover = controller._creatingCover;
  var panel = controller._creatingPanel;
  var thisBrushOption = controller._brushOption;
  var eventParams;

  controller._track.push(localCursorPoint.slice());

  if (shouldShowCover(controller) || creatingCover) {
    if (panel && !creatingCover) {
      thisBrushOption.brushMode === 'single' && clearCovers(controller);
      var brushOption = zrUtil.clone(thisBrushOption);
      brushOption.brushType = determineBrushType(brushOption.brushType, panel);
      brushOption.panelId = panel === true ? null : panel.panelId;
      creatingCover = controller._creatingCover = createCover(controller, brushOption);

      controller._covers.push(creatingCover);
    }

    if (creatingCover) {
      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
      var coverBrushOption = creatingCover.__brushOption;
      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));

      if (isEnd) {
        endCreating(controller, creatingCover);
        coverRenderer.updateCommon(controller, creatingCover);
      }

      updateCoverShape(controller, creatingCover);
      eventParams = {
        isEnd: isEnd
      };
    }
  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {
    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.
    // But a single click do not clear covers, because user may have casual
    // clicks (for example, click on other component and do not expect covers
    // disappear).
    // Only some cover removed, trigger action, but not every click trigger action.
    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {
      eventParams = {
        isEnd: isEnd,
        removeOnClick: true
      };
    }
  }

  return eventParams;
}

function determineBrushType(brushType, panel) {
  if (brushType === 'auto') {
    return panel.defaultBrushType;
  }

  return brushType;
}

var mouseHandlers = {
  mousedown: function (e) {
    if (this._dragging) {
      // In case some browser do not support globalOut,
      // and release mose out side the browser.
      handleDragEnd.call(this, e);
    } else if (!e.target || !e.target.draggable) {
      preventDefault(e);
      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
      this._creatingCover = null;
      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);

      if (panel) {
        this._dragging = true;
        this._track = [localCursorPoint.slice()];
      }
    }
  },
  mousemove: function (e) {
    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
    resetCursor(this, e, localCursorPoint);

    if (this._dragging) {
      preventDefault(e);
      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);
      eventParams && trigger(this, eventParams);
    }
  },
  mouseup: handleDragEnd //,
  // FIXME
  // in tooltip, globalout should not be triggered.
  // globalout: handleDragEnd

};

function handleDragEnd(e) {
  if (this._dragging) {
    preventDefault(e);
    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
    var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);
    this._dragging = false;
    this._track = [];
    this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.

    eventParams && trigger(this, eventParams);
  }
}
/**
 * key: brushType
 * @type {Object}
 */


var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function (controller, brushOption) {
      return createBaseRectCover(curry(driftRect, function (range) {
        return range;
      }, function (range) {
        return range;
      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);
    },
    getCreatingRange: function (localTrack) {
      var ends = getTrackEnds(localTrack);
      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      updateBaseRect(controller, cover, localRange, brushOption);
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function (controller, brushOption) {
      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the
      // border of the shape when drawing, which is a better experience for user.

      cover.add(new graphic.Polyline({
        name: 'main',
        style: makeStyle(brushOption),
        silent: true
      }));
      return cover;
    },
    getCreatingRange: function (localTrack) {
      return localTrack;
    },
    endCreating: function (controller, cover) {
      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.

      cover.add(new graphic.Polygon({
        name: 'main',
        draggable: true,
        drift: curry(driftPolygon, controller, cover),
        ondragend: curry(trigger, controller, {
          isEnd: true
        })
      }));
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      cover.childAt(0).setShape({
        points: clipByPanel(controller, cover, localRange)
      });
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  }
};

function getLineRenderer(xyIndex) {
  return {
    createCover: function (controller, brushOption) {
      return createBaseRectCover(curry(driftRect, function (range) {
        var rectRange = [range, [0, 100]];
        xyIndex && rectRange.reverse();
        return rectRange;
      }, function (rectRange) {
        return rectRange[xyIndex];
      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);
    },
    getCreatingRange: function (localTrack) {
      var ends = getTrackEnds(localTrack);
      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);
      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);
      return [min, max];
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      var otherExtent; // If brushWidth not specified, fit the panel.

      var panel = getPanelByCover(controller, cover);

      if (panel !== true && panel.getLinearBrushOtherExtent) {
        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);
      } else {
        var zr = controller._zr;
        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
      }

      var rectRange = [localRange, otherExtent];
      xyIndex && rectRange.reverse();
      updateBaseRect(controller, cover, rectRange, brushOption);
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  };
}

var _default = BrushController;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/BrushTargetManager.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var brushHelper = __webpack_require__("./node_modules/echarts/lib/component/helper/brushHelper.js");

var each = zrUtil.each;
var indexOf = zrUtil.indexOf;
var curry = zrUtil.curry;
var COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME
// how to genarialize to more coordinate systems.

var INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];
/**
 * [option in constructor]:
 * {
 *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
 * }
 *
 *
 * [targetInfo]:
 *
 * There can be multiple axes in a single targetInfo. Consider the case
 * of `grid` component, a targetInfo represents a grid which contains one or more
 * cartesian and one or more axes. And consider the case of parallel system,
 * which has multiple axes in a coordinate system.
 * Can be {
 *     panelId: ...,
 *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,
 *     coordSyses: all cartesians.
 *     gridModel: <grid component>
 *     xAxes: correspond to coordSyses on index
 *     yAxes: correspond to coordSyses on index
 * }
 * or {
 *     panelId: ...,
 *     coordSys: <geo coord sys>
 *     coordSyses: [<geo coord sys>]
 *     geoModel: <geo component>
 * }
 *
 *
 * [panelOpt]:
 *
 * Make from targetInfo. Input to BrushController.
 * {
 *     panelId: ...,
 *     rect: ...
 * }
 *
 *
 * [area]:
 *
 * Generated by BrushController or user input.
 * {
 *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.
 *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').
 *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
 *     range: pixel range.
 *     coordRange: representitive coord range (the first one of coordRanges).
 *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.
 * }
 */

/**
 * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid
 *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} [opt]
 * @param {Array.<string>} [opt.include] include coordinate system types.
 */

function BrushTargetManager(option, ecModel, opt) {
  /**
   * @private
   * @type {Array.<Object>}
   */
  var targetInfoList = this._targetInfoList = [];
  var info = {};
  var foundCpts = parseFinder(ecModel, option);
  each(targetInfoBuilders, function (builder, type) {
    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
      builder(foundCpts, targetInfoList, info);
    }
  });
}

var proto = BrushTargetManager.prototype;

proto.setOutputRanges = function (areas, ecModel) {
  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges

    if (!area.coordRange) {
      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not
      // rebuild range by coordRange accrately, which may bring trouble when
      // brushing only one item. So we use __rangeOffset to rebuilding range
      // by coordRange. And this it only used in brush component so it is no
      // need to be adapted to coordRanges.

      var result = coordConvert[area.brushType](0, coordSys, coordRange);
      area.__rangeOffset = {
        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
        xyMinMax: result.xyMinMax
      };
    }
  });
};

proto.matchOutputRanges = function (areas, ecModel, cb) {
  each(areas, function (area) {
    var targetInfo = this.findTargetInfo(area, ecModel);

    if (targetInfo && targetInfo !== true) {
      zrUtil.each(targetInfo.coordSyses, function (coordSys) {
        var result = coordConvert[area.brushType](1, coordSys, area.range);
        cb(area, result.values, coordSys, ecModel);
      });
    }
  }, this);
};

proto.setInputRanges = function (areas, ecModel) {
  each(areas, function (area) {
    var targetInfo = this.findTargetInfo(area, ecModel);
    area.range = area.range || []; // convert coordRange to global range and set panelId.

    if (targetInfo && targetInfo !== true) {
      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does
      // not keep its original value, for the sake of the dataZoom scenario,
      // where area.coordRange remains unchanged but area.range may be changed.
      // (2) Only support converting one coordRange to pixel range in brush
      // component. So do not consider `coordRanges`.
      // (3) About __rangeOffset, see comment above.

      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
      var rangeOffset = area.__rangeOffset;
      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
    }
  }, this);
};

proto.makePanelOpts = function (api, getDefaultBrushType) {
  return zrUtil.map(this._targetInfoList, function (targetInfo) {
    var rect = targetInfo.getPanelRect();
    return {
      panelId: targetInfo.panelId,
      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),
      clipPath: brushHelper.makeRectPanelClipPath(rect),
      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)
    };
  });
};

proto.controlSeries = function (area, seriesModel, ecModel) {
  // Check whether area is bound in coord, and series do not belong to that coord.
  // If do not do this check, some brush (like lineX) will controll all axes.
  var targetInfo = this.findTargetInfo(area, ecModel);
  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
};
/**
 * If return Object, a coord found.
 * If reutrn true, global found.
 * Otherwise nothing found.
 *
 * @param {Object} area
 * @param {Array} targetInfoList
 * @return {Object|boolean}
 */


proto.findTargetInfo = function (area, ecModel) {
  var targetInfoList = this._targetInfoList;
  var foundCpts = parseFinder(ecModel, area);

  for (var i = 0; i < targetInfoList.length; i++) {
    var targetInfo = targetInfoList[i];
    var areaPanelId = area.panelId;

    if (areaPanelId) {
      if (targetInfo.panelId === areaPanelId) {
        return targetInfo;
      }
    } else {
      for (var i = 0; i < targetInfoMatchers.length; i++) {
        if (targetInfoMatchers[i](foundCpts, targetInfo)) {
          return targetInfo;
        }
      }
    }
  }

  return true;
};

function formatMinMax(minMax) {
  minMax[0] > minMax[1] && minMax.reverse();
  return minMax;
}

function parseFinder(ecModel, option) {
  return modelUtil.parseFinder(ecModel, option, {
    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
  });
}

var targetInfoBuilders = {
  grid: function (foundCpts, targetInfoList) {
    var xAxisModels = foundCpts.xAxisModels;
    var yAxisModels = foundCpts.yAxisModels;
    var gridModels = foundCpts.gridModels; // Remove duplicated.

    var gridModelMap = zrUtil.createHashMap();
    var xAxesHas = {};
    var yAxesHas = {};

    if (!xAxisModels && !yAxisModels && !gridModels) {
      return;
    }

    each(xAxisModels, function (axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
    });
    each(yAxisModels, function (axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      yAxesHas[gridModel.id] = true;
    });
    each(gridModels, function (gridModel) {
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
      yAxesHas[gridModel.id] = true;
    });
    gridModelMap.each(function (gridModel) {
      var grid = gridModel.coordinateSystem;
      var cartesians = [];
      each(grid.getCartesians(), function (cartesian, index) {
        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {
          cartesians.push(cartesian);
        }
      });
      targetInfoList.push({
        panelId: 'grid--' + gridModel.id,
        gridModel: gridModel,
        coordSysModel: gridModel,
        // Use the first one as the representitive coordSys.
        coordSys: cartesians[0],
        coordSyses: cartesians,
        getPanelRect: panelRectBuilder.grid,
        xAxisDeclared: xAxesHas[gridModel.id],
        yAxisDeclared: yAxesHas[gridModel.id]
      });
    });
  },
  geo: function (foundCpts, targetInfoList) {
    each(foundCpts.geoModels, function (geoModel) {
      var coordSys = geoModel.coordinateSystem;
      targetInfoList.push({
        panelId: 'geo--' + geoModel.id,
        geoModel: geoModel,
        coordSysModel: geoModel,
        coordSys: coordSys,
        coordSyses: [coordSys],
        getPanelRect: panelRectBuilder.geo
      });
    });
  }
};
var targetInfoMatchers = [// grid
function (foundCpts, targetInfo) {
  var xAxisModel = foundCpts.xAxisModel;
  var yAxisModel = foundCpts.yAxisModel;
  var gridModel = foundCpts.gridModel;
  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
  return gridModel && gridModel === targetInfo.gridModel;
}, // geo
function (foundCpts, targetInfo) {
  var geoModel = foundCpts.geoModel;
  return geoModel && geoModel === targetInfo.geoModel;
}];
var panelRectBuilder = {
  grid: function () {
    // grid is not Transformable.
    return this.coordSys.grid.getRect().clone();
  },
  geo: function () {
    var coordSys = this.coordSys;
    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform

    rect.applyTransform(graphic.getTransform(coordSys));
    return rect;
  }
};
var coordConvert = {
  lineX: curry(axisConvert, 0),
  lineY: curry(axisConvert, 1),
  rect: function (to, coordSys, rangeOrCoordRange) {
    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);
    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);
    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
    return {
      values: values,
      xyMinMax: values
    };
  },
  polygon: function (to, coordSys, rangeOrCoordRange) {
    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
    var values = zrUtil.map(rangeOrCoordRange, function (item) {
      var p = coordSys[COORD_CONVERTS[to]](item);
      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
      return p;
    });
    return {
      values: values,
      xyMinMax: xyMinMax
    };
  }
};

function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);
  var values = formatMinMax(zrUtil.map([0, 1], function (i) {
    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
  }));
  var xyMinMax = [];
  xyMinMax[axisNameIndex] = values;
  xyMinMax[1 - axisNameIndex] = [NaN, NaN];
  return {
    values: values,
    xyMinMax: xyMinMax
  };
}

var diffProcessor = {
  lineX: curry(axisDiffProcessor, 0),
  lineY: curry(axisDiffProcessor, 1),
  rect: function (values, refer, scales) {
    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
  },
  polygon: function (values, refer, scales) {
    return zrUtil.map(values, function (item, idx) {
      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
    });
  }
};

function axisDiffProcessor(axisNameIndex, values, refer, scales) {
  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
} // We have to process scale caused by dataZoom manually,
// although it might be not accurate.


function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
  var sizeCurr = getSize(xyMinMaxCurr);
  var sizeOrigin = getSize(xyMinMaxOrigin);
  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
  isNaN(scales[0]) && (scales[0] = 1);
  isNaN(scales[1]) && (scales[1] = 1);
  return scales;
}

function getSize(xyMinMax) {
  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}

var _default = BrushTargetManager;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/RoamController.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var eventTool = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var interactionMutex = __webpack_require__("./node_modules/echarts/lib/component/helper/interactionMutex.js");

/**
 * @alias module:echarts/component/helper/RoamController
 * @constructor
 * @mixin {module:zrender/mixin/Eventful}
 *
 * @param {module:zrender/zrender~ZRender} zr
 */
function RoamController(zr) {
  /**
   * @type {Function}
   */
  this.pointerChecker;
  /**
   * @type {module:zrender}
   */

  this._zr = zr;
  /**
   * @type {Object}
   */

  this._opt = {}; // Avoid two roamController bind the same handler

  var bind = zrUtil.bind;
  var mousedownHandler = bind(mousedown, this);
  var mousemoveHandler = bind(mousemove, this);
  var mouseupHandler = bind(mouseup, this);
  var mousewheelHandler = bind(mousewheel, this);
  var pinchHandler = bind(pinch, this);
  Eventful.call(this);
  /**
   * @param {Function} pointerChecker
   *                   input: x, y
   *                   output: boolean
   */

  this.setPointerChecker = function (pointerChecker) {
    this.pointerChecker = pointerChecker;
  };
  /**
   * Notice: only enable needed types. For example, if 'zoom'
   * is not needed, 'zoom' should not be enabled, otherwise
   * default mousewheel behaviour (scroll page) will be disabled.
   *
   * @param  {boolean|string} [controlType=true] Specify the control type,
   *                          which can be null/undefined or true/false
   *                          or 'pan/move' or 'zoom'/'scale'
   * @param {Object} [opt]
   * @param {Object} [opt.zoomOnMouseWheel=true]
   * @param {Object} [opt.moveOnMouseMove=true]
   * @param {Object} [opt.preventDefaultMouseMove=true] When pan.
   */


  this.enable = function (controlType, opt) {
    // Disable previous first
    this.disable();
    this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      preventDefaultMouseMove: true
    });

    if (controlType == null) {
      controlType = true;
    }

    if (controlType === true || controlType === 'move' || controlType === 'pan') {
      zr.on('mousedown', mousedownHandler);
      zr.on('mousemove', mousemoveHandler);
      zr.on('mouseup', mouseupHandler);
    }

    if (controlType === true || controlType === 'scale' || controlType === 'zoom') {
      zr.on('mousewheel', mousewheelHandler);
      zr.on('pinch', pinchHandler);
    }
  };

  this.disable = function () {
    zr.off('mousedown', mousedownHandler);
    zr.off('mousemove', mousemoveHandler);
    zr.off('mouseup', mouseupHandler);
    zr.off('mousewheel', mousewheelHandler);
    zr.off('pinch', pinchHandler);
  };

  this.dispose = this.disable;

  this.isDragging = function () {
    return this._dragging;
  };

  this.isPinching = function () {
    return this._pinching;
  };
}

zrUtil.mixin(RoamController, Eventful);

function mousedown(e) {
  if (eventTool.notLeftMouse(e) || e.target && e.target.draggable) {
    return;
  }

  var x = e.offsetX;
  var y = e.offsetY; // Only check on mosedown, but not mousemove.
  // Mouse can be out of target when mouse moving.

  if (this.pointerChecker && this.pointerChecker(e, x, y)) {
    this._x = x;
    this._y = y;
    this._dragging = true;
  }
}

function mousemove(e) {
  if (eventTool.notLeftMouse(e) || !checkKeyBinding(this, 'moveOnMouseMove', e) || !this._dragging || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {
    return;
  }

  var x = e.offsetX;
  var y = e.offsetY;
  var oldX = this._x;
  var oldY = this._y;
  var dx = x - oldX;
  var dy = y - oldY;
  this._x = x;
  this._y = y;
  this._opt.preventDefaultMouseMove && eventTool.stop(e.event);
  this.trigger('pan', dx, dy, oldX, oldY, x, y);
}

function mouseup(e) {
  if (!eventTool.notLeftMouse(e)) {
    this._dragging = false;
  }
}

function mousewheel(e) {
  // wheelDelta maybe -0 in chrome mac.
  if (!checkKeyBinding(this, 'zoomOnMouseWheel', e) || e.wheelDelta === 0) {
    return;
  } // Convenience:
  // Mac and VM Windows on Mac: scroll up: zoom out.
  // Windows: scroll up: zoom in.


  var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;
  zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);
}

function pinch(e) {
  if (interactionMutex.isTaken(this._zr, 'globalPan')) {
    return;
  }

  var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
  zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);
}

function zoom(e, zoomDelta, zoomX, zoomY) {
  if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) {
    // When mouse is out of roamController rect,
    // default befavoius should not be be disabled, otherwise
    // page sliding is disabled, contrary to expectation.
    eventTool.stop(e.event);
    this.trigger('zoom', zoomDelta, zoomX, zoomY);
  }
}

function checkKeyBinding(roamController, prop, e) {
  var setting = roamController._opt[prop];
  return setting && (!zrUtil.isString(setting) || e.event[setting + 'Key']);
}

var _default = RoamController;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/brushHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var _cursorHelper = __webpack_require__("./node_modules/echarts/lib/component/helper/cursorHelper.js");

var onIrrelevantElement = _cursorHelper.onIrrelevantElement;

var graphicUtil = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

function makeRectPanelClipPath(rect) {
  rect = normalizeRect(rect);
  return function (localPoints, transform) {
    return graphicUtil.clipPointsByRect(localPoints, rect);
  };
}

function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
  rect = normalizeRect(rect);
  return function (xyIndex) {
    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
    var brushWidth = idx ? rect.width : rect.height;
    var base = idx ? rect.x : rect.y;
    return [base, base + (brushWidth || 0)];
  };
}

function makeRectIsTargetByCursor(rect, api, targetModel) {
  rect = normalizeRect(rect);
  return function (e, localCursorPoint, transform) {
    return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);
  };
} // Consider width/height is negative.


function normalizeRect(rect) {
  return BoundingRect.create(rect);
}

exports.makeRectPanelClipPath = makeRectPanelClipPath;
exports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;
exports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/cursorHelper.js":
/***/ (function(module, exports) {

var IRRELEVANT_EXCLUDES = {
  'axisPointer': 1,
  'tooltip': 1,
  'brush': 1
};
/**
 * Avoid that: mouse click on a elements that is over geo or graph,
 * but roam is triggered.
 */

function onIrrelevantElement(e, api, targetCoordSysModel) {
  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.

  var coordSys = model && model.coordinateSystem;
  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;
}

exports.onIrrelevantElement = onIrrelevantElement;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/interactionMutex.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var ATTR = '\0_ec_interaction_mutex';

function take(zr, resourceKey, userKey) {
  var store = getStore(zr);
  store[resourceKey] = userKey;
}

function release(zr, resourceKey, userKey) {
  var store = getStore(zr);
  var uKey = store[resourceKey];

  if (uKey === userKey) {
    store[resourceKey] = null;
  }
}

function isTaken(zr, resourceKey) {
  return !!getStore(zr)[resourceKey];
}

function getStore(zr) {
  return zr[ATTR] || (zr[ATTR] = {});
}
/**
 * payload: {
 *     type: 'takeGlobalCursor',
 *     key: 'dataZoomSelect', or 'brush', or ...,
 *         If no userKey, release global cursor.
 * }
 */


echarts.registerAction({
  type: 'takeGlobalCursor',
  event: 'globalCursorTaken',
  update: 'update'
}, function () {});
exports.take = take;
exports.release = release;
exports.isTaken = isTaken;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/listComponent.js":
/***/ (function(module, exports, __webpack_require__) {

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutRect = _layout.getLayoutRect;
var layoutBox = _layout.box;
var positionElement = _layout.positionElement;

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

/**
 * Layout list like component.
 * It will box layout each items in group of component and then position the whole group in the viewport
 * @param {module:zrender/group/Group} group
 * @param {module:echarts/model/Component} componentModel
 * @param {module:echarts/ExtensionAPI}
 */
function layout(group, componentModel, api) {
  var boxLayoutParams = componentModel.getBoxLayoutParams();
  var padding = componentModel.get('padding');
  var viewportSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);
  positionElement(group, boxLayoutParams, viewportSize, padding);
}

function makeBackground(rect, componentModel) {
  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));
  var style = componentModel.getItemStyle(['color', 'opacity']);
  style.fill = componentModel.get('backgroundColor');
  var rect = new graphic.Rect({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get('borderRadius')
    },
    style: style,
    silent: true,
    z2: -1
  }); // FIXME
  // `subPixelOptimizeRect` may bring some gap between edge of viewpart
  // and background rect when setting like `left: 0`, `top: 0`.
  // graphic.subPixelOptimizeRect(rect);

  return rect;
}

exports.layout = layout;
exports.makeBackground = makeBackground;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/sliderMove.js":
/***/ (function(module, exports) {

/**
 * Calculate slider move result.
 * Usage:
 * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as
 * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.
 * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.
 *
 * @param {number} delta Move length.
 * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].
 *              handleEnds will be modified in this method.
 * @param {Array.<number>} extent handleEnds is restricted by extent.
 *              extent[0] should less or equals than extent[1].
 * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,
 *              where the input minSpan and maxSpan will not work.
 * @param {number} [minSpan] The range of dataZoom can not be smaller than that.
 *              If not set, handle0 and cross handle1. If set as a non-negative
 *              number (including `0`), handles will push each other when reaching
 *              the minSpan.
 * @param {number} [maxSpan] The range of dataZoom can not be larger than that.
 * @return {Array.<number>} The input handleEnds.
 */
function _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
  // Normalize firstly.
  handleEnds[0] = restrict(handleEnds[0], extent);
  handleEnds[1] = restrict(handleEnds[1], extent);
  delta = delta || 0;
  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.

  if (minSpan != null) {
    minSpan = restrict(minSpan, [0, extentSpan]);
  }

  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }

  if (handleIndex === 'all') {
    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleIndex = 0;
  }

  var originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta; // Restrict in extent.

  var extentMinSpan = minSpan || 0;
  var realExtent = extent.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.

  var currDistSign = getSpanSign(handleEnds, handleIndex);

  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    // If minSpan exists, 'cross' is forbinden.
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  } // Shrink span.


  var currDistSign = getSpanSign(handleEnds, handleIndex);

  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }

  return handleEnds;
}

function getSpanSign(handleEnds, handleIndex) {
  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]
  // is at left of handleEnds[1] for non-cross case.

  return {
    span: Math.abs(dist),
    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
  };
}

function restrict(value, extend) {
  return Math.min(extend[1], Math.max(extend[0], value));
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/LegendModel.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/legendAction.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/LegendView.js");

var legendFilter = __webpack_require__("./node_modules/echarts/lib/component/legend/legendFilter.js");

var Component = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

// Do not contain scrollable legend, for sake of file size.
// Series Filter
echarts.registerProcessor(legendFilter);
Component.registerSubTypeDefaulter('legend', function () {
  // Default 'plain' when no type specified.
  return 'plain';
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/LegendModel.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var LegendModel = echarts.extendComponentModel({
  type: 'legend.plain',
  dependencies: ['series'],
  layoutMode: {
    type: 'box',
    // legend.width/height are maxWidth/maxHeight actually,
    // whereas realy width/height is calculated by its content.
    // (Setting {left: 10, right: 10} does not make sense).
    // So consider the case:
    // `setOption({legend: {left: 10});`
    // then `setOption({legend: {right: 10});`
    // The previous `left` should be cleared by setting `ignoreSize`.
    ignoreSize: true
  },
  init: function (option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};
  },
  mergeOption: function (option) {
    LegendModel.superCall(this, 'mergeOption', option);
  },
  optionUpdated: function () {
    this._updateData(this.ecModel);

    var legendData = this._data; // If selectedMode is single, try to select one

    if (legendData[0] && this.get('selectedMode') === 'single') {
      var hasSelected = false; // If has any selected in option.selected

      for (var i = 0; i < legendData.length; i++) {
        var name = legendData[i].get('name');

        if (this.isSelected(name)) {
          // Force to unselect others
          this.select(name);
          hasSelected = true;
          break;
        }
      } // Try select the first if selectedMode is single


      !hasSelected && this.select(legendData[0].get('name'));
    }
  },
  _updateData: function (ecModel) {
    var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {
      // Can be string or number
      if (typeof dataItem === 'string' || typeof dataItem === 'number') {
        dataItem = {
          name: dataItem
        };
      }

      return new Model(dataItem, this, this.ecModel);
    }, this);
    this._data = legendData;
    var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {
      return series.name;
    });
    ecModel.eachSeries(function (seriesModel) {
      if (seriesModel.legendDataProvider) {
        var data = seriesModel.legendDataProvider();
        availableNames = availableNames.concat(data.mapArray(data.getName));
      }
    });
    /**
     * @type {Array.<string>}
     * @private
     */

    this._availableNames = availableNames;
  },

  /**
   * @return {Array.<module:echarts/model/Model>}
   */
  getData: function () {
    return this._data;
  },

  /**
   * @param {string} name
   */
  select: function (name) {
    var selected = this.option.selected;
    var selectedMode = this.get('selectedMode');

    if (selectedMode === 'single') {
      var data = this._data;
      zrUtil.each(data, function (dataItem) {
        selected[dataItem.get('name')] = false;
      });
    }

    selected[name] = true;
  },

  /**
   * @param {string} name
   */
  unSelect: function (name) {
    if (this.get('selectedMode') !== 'single') {
      this.option.selected[name] = false;
    }
  },

  /**
   * @param {string} name
   */
  toggleSelected: function (name) {
    var selected = this.option.selected; // Default is true

    if (!selected.hasOwnProperty(name)) {
      selected[name] = true;
    }

    this[selected[name] ? 'unSelect' : 'select'](name);
  },

  /**
   * @param {string} name
   */
  isSelected: function (name) {
    var selected = this.option.selected;
    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;
  },
  defaultOption: {
    // 一级层叠
    zlevel: 0,
    // 二级层叠
    z: 4,
    show: true,
    // 布局方式，默认为水平布局，可选为：
    // 'horizontal' | 'vertical'
    orient: 'horizontal',
    left: 'center',
    // right: 'center',
    top: 0,
    // bottom: null,
    // 水平对齐
    // 'auto' | 'left' | 'right'
    // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐
    align: 'auto',
    backgroundColor: 'rgba(0,0,0,0)',
    // 图例边框颜色
    borderColor: '#ccc',
    borderRadius: 0,
    // 图例边框线宽，单位px，默认为0（无边框）
    borderWidth: 0,
    // 图例内边距，单位px，默认各方向内边距为5，
    // 接受数组分别设定上右下左边距，同css
    padding: 5,
    // 各个item之间的间隔，单位px，默认为10，
    // 横向布局时为水平间隔，纵向布局时为纵向间隔
    itemGap: 10,
    // 图例图形宽度
    itemWidth: 25,
    // 图例图形高度
    itemHeight: 14,
    // 图例关闭时候的颜色
    inactiveColor: '#ccc',
    textStyle: {
      // 图例文字颜色
      color: '#333'
    },
    // formatter: '',
    // 选择模式，默认开启图例开关
    selectedMode: true,
    // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入
    // selected: null,
    // 图例内容（详见legend.data，数组中每一项代表一个item
    // data: [],
    // Tooltip 相关配置
    tooltip: {
      show: false
    }
  }
});
var _default = LegendModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/LegendView.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _symbol = __webpack_require__("./node_modules/echarts/lib/util/symbol.js");

var createSymbol = _symbol.createSymbol;

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _listComponent = __webpack_require__("./node_modules/echarts/lib/component/helper/listComponent.js");

var makeBackground = _listComponent.makeBackground;

var layoutUtil = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var curry = zrUtil.curry;
var each = zrUtil.each;
var Group = graphic.Group;

var _default = echarts.extendComponentView({
  type: 'legend.plain',
  newlineDisabled: false,

  /**
   * @override
   */
  init: function () {
    /**
     * @private
     * @type {module:zrender/container/Group}
     */
    this.group.add(this._contentGroup = new Group());
    /**
     * @private
     * @type {module:zrender/Element}
     */

    this._backgroundEl;
  },

  /**
   * @protected
   */
  getContentGroup: function () {
    return this._contentGroup;
  },

  /**
   * @override
   */
  render: function (legendModel, ecModel, api) {
    this.resetInner();

    if (!legendModel.get('show', true)) {
      return;
    }

    var itemAlign = legendModel.get('align');

    if (!itemAlign || itemAlign === 'auto') {
      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';
    }

    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.

    var positionInfo = legendModel.getBoxLayoutParams();
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var padding = legendModel.get('padding');
    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);
    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.

    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.

    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  },

  /**
   * @protected
   */
  resetInner: function () {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
  },

  /**
   * @protected
   */
  renderInner: function (itemAlign, legendModel, ecModel, api) {
    var contentGroup = this.getContentGroup();
    var legendDrawnMap = zrUtil.createHashMap();
    var selectMode = legendModel.get('selectedMode');
    each(legendModel.getData(), function (itemModel, dataIndex) {
      var name = itemModel.get('name'); // Use empty string or \n as a newline string

      if (!this.newlineDisabled && (name === '' || name === '\n')) {
        contentGroup.add(new Group({
          newline: true
        }));
        return;
      }

      var seriesModel = ecModel.getSeriesByName(name)[0];

      if (legendDrawnMap.get(name)) {
        // Have been drawed
        return;
      } // Series legend


      if (seriesModel) {
        var data = seriesModel.getData();
        var color = data.getVisual('color'); // If color is a callback function

        if (typeof color === 'function') {
          // Use the first data
          color = color(seriesModel.getDataParams(0));
        } // Using rect symbol defaultly


        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';
        var symbolType = data.getVisual('symbol');

        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);

        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));
        legendDrawnMap.set(name, true);
      } else {
        // Data legend of pie, funnel
        ecModel.eachRawSeries(function (seriesModel) {
          // In case multiple series has same data name
          if (legendDrawnMap.get(name)) {
            return;
          }

          if (seriesModel.legendDataProvider) {
            var data = seriesModel.legendDataProvider();
            var idx = data.indexOfName(name);

            if (idx < 0) {
              return;
            }

            var color = data.getItemVisual(idx, 'color');
            var legendSymbolType = 'roundRect';

            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);

            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name
            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));
            legendDrawnMap.set(name, true);
          }
        }, this);
      }
    }, this);
  },
  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {
    var itemWidth = legendModel.get('itemWidth');
    var itemHeight = legendModel.get('itemHeight');
    var inactiveColor = legendModel.get('inactiveColor');
    var isSelected = legendModel.isSelected(name);
    var itemGroup = new Group();
    var textStyleModel = itemModel.getModel('textStyle');
    var itemIcon = itemModel.get('icon');
    var tooltipModel = itemModel.getModel('tooltip');
    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first

    legendSymbolType = itemIcon || legendSymbolType;
    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols
    // PENDING

    if (!itemIcon && symbolType // At least show one symbol, can't be all none
    && (symbolType !== legendSymbolType || symbolType == 'none')) {
      var size = itemHeight * 0.8;

      if (symbolType === 'none') {
        symbolType = 'circle';
      } // Put symbol in the center


      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));
    }

    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
    var textAlign = itemAlign;
    var formatter = legendModel.get('formatter');
    var content = name;

    if (typeof formatter === 'string' && formatter) {
      content = formatter.replace('{name}', name != null ? name : '');
    } else if (typeof formatter === 'function') {
      content = formatter(name);
    }

    itemGroup.add(new graphic.Text({
      style: graphic.setTextStyle({}, textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
        textAlign: textAlign,
        textVerticalAlign: 'middle'
      })
    })); // Add a invisible rect to increase the area of mouse hover

    var hitRect = new graphic.Rect({
      shape: itemGroup.getBoundingRect(),
      invisible: true,
      tooltip: tooltipModel.get('show') ? zrUtil.extend({
        content: name,
        // Defaul formatter
        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {
          return name;
        },
        formatterParams: {
          componentType: 'legend',
          legendIndex: legendModel.componentIndex,
          name: name,
          $vars: ['name']
        }
      }, tooltipModel.option) : null
    });
    itemGroup.add(hitRect);
    itemGroup.eachChild(function (child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    graphic.setHoverStyle(itemGroup);
    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  },

  /**
   * @protected
   */
  layoutInner: function (legendModel, itemAlign, maxSize) {
    var contentGroup = this.getContentGroup(); // Place items in contentGroup.

    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);
    var contentRect = contentGroup.getBoundingRect();
    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);
    return this.group.getBoundingRect();
  }
});

function dispatchSelectAction(name, api) {
  api.dispatchAction({
    type: 'legendToggleSelect',
    name: name
  });
}

function dispatchHighlightAction(seriesModel, dataName, api) {
  // If element hover will move to a hoverLayer.
  var el = api.getZr().storage.getDisplayList()[0];

  if (!(el && el.useHoverLayer)) {
    seriesModel.get('legendHoverLink') && api.dispatchAction({
      type: 'highlight',
      seriesName: seriesModel.name,
      name: dataName
    });
  }
}

function dispatchDownplayAction(seriesModel, dataName, api) {
  // If element hover will move to a hoverLayer.
  var el = api.getZr().storage.getDisplayList()[0];

  if (!(el && el.useHoverLayer)) {
    seriesModel.get('legendHoverLink') && api.dispatchAction({
      type: 'downplay',
      seriesName: seriesModel.name,
      name: dataName
    });
  }
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js":
/***/ (function(module, exports, __webpack_require__) {

var LegendModel = __webpack_require__("./node_modules/echarts/lib/component/legend/LegendModel.js");

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var mergeLayoutParam = _layout.mergeLayoutParam;
var getLayoutParams = _layout.getLayoutParams;
var ScrollableLegendModel = LegendModel.extend({
  type: 'legend.scroll',

  /**
   * @param {number} scrollDataIndex
   */
  setScrollDataIndex: function (scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  },
  defaultOption: {
    scrollDataIndex: 0,
    pageButtonItemGap: 5,
    pageButtonGap: null,
    pageButtonPosition: 'end',
    // 'start' or 'end'
    pageFormatter: '{current}/{total}',
    // If null/undefined, do not show page.
    pageIcons: {
      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']
    },
    pageIconColor: '#2f4554',
    pageIconInactiveColor: '#aaa',
    pageIconSize: 15,
    // Can be [10, 3], which represents [width, height]
    pageTextStyle: {
      color: '#333'
    },
    animationDurationUpdate: 800
  },

  /**
   * @override
   */
  init: function (option, parentModel, ecModel, extraOpt) {
    var inputPositionParams = getLayoutParams(option);
    ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);
    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
  },

  /**
   * @override
   */
  mergeOption: function (option, extraOpt) {
    ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);
    mergeAndNormalizeLayoutParams(this, this.option, option);
  },
  getOrient: function () {
    return this.get('orient') === 'vertical' ? {
      index: 1,
      name: 'vertical'
    } : {
      index: 0,
      name: 'horizontal'
    };
  }
}); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.

function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
  var orient = legendModel.getOrient();
  var ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  mergeLayoutParam(target, raw, {
    type: 'box',
    ignoreSize: ignoreSize
  });
}

var _default = ScrollableLegendModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/ScrollableLegendView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var layoutUtil = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var LegendView = __webpack_require__("./node_modules/echarts/lib/component/legend/LegendView.js");

/**
 * Separate legend and scrollable legend to reduce package size.
 */
var Group = graphic.Group;
var WH = ['width', 'height'];
var XY = ['x', 'y'];
var ScrollableLegendView = LegendView.extend({
  type: 'legend.scroll',
  newlineDisabled: true,
  init: function () {
    ScrollableLegendView.superCall(this, 'init');
    /**
     * @private
     * @type {number} For `scroll`.
     */

    this._currentIndex = 0;
    /**
     * @private
     * @type {module:zrender/container/Group}
     */

    this.group.add(this._containerGroup = new Group());

    this._containerGroup.add(this.getContentGroup());
    /**
     * @private
     * @type {module:zrender/container/Group}
     */


    this.group.add(this._controllerGroup = new Group());
    /**
     *
     * @private
     */

    this._showController;
  },

  /**
   * @override
   */
  resetInner: function () {
    ScrollableLegendView.superCall(this, 'resetInner');

    this._controllerGroup.removeAll();

    this._containerGroup.removeClipPath();

    this._containerGroup.__rectSize = null;
  },

  /**
   * @override
   */
  renderInner: function (itemAlign, legendModel, ecModel, api) {
    var me = this; // Render content items.

    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);
    var controllerGroup = this._controllerGroup;
    var pageIconSize = legendModel.get('pageIconSize', true);

    if (!zrUtil.isArray(pageIconSize)) {
      pageIconSize = [pageIconSize, pageIconSize];
    }

    createPageButton('pagePrev', 0);
    var pageTextStyleModel = legendModel.getModel('pageTextStyle');
    controllerGroup.add(new graphic.Text({
      name: 'pageText',
      style: {
        textFill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        textVerticalAlign: 'middle',
        textAlign: 'center'
      },
      silent: true
    }));
    createPageButton('pageNext', 1);

    function createPageButton(name, iconIdx) {
      var pageDataIndexName = name + 'DataIndex';
      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {
        // Buttons will be created in each render, so we do not need
        // to worry about avoiding using legendModel kept in scope.
        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)
      }, {
        x: -pageIconSize[0] / 2,
        y: -pageIconSize[1] / 2,
        width: pageIconSize[0],
        height: pageIconSize[1]
      });
      icon.name = name;
      controllerGroup.add(icon);
    }
  },

  /**
   * @override
   */
  layoutInner: function (legendModel, itemAlign, maxSize) {
    var contentGroup = this.getContentGroup();
    var containerGroup = this._containerGroup;
    var controllerGroup = this._controllerGroup;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var hw = WH[1 - orientIdx];
    var yx = XY[1 - orientIdx]; // Place items in contentGroup.

    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    layoutUtil.box( // Buttons in controller are layout always horizontally.
    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));
    var contentRect = contentGroup.getBoundingRect();
    var controllerRect = controllerGroup.getBoundingRect();
    var showController = this._showController = contentRect[wh] > maxSize[wh];
    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.

    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.

    var containerPos = [0, 0];
    var controllerPos = [-controllerRect.x, -controllerRect.y];
    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.

    if (showController) {
      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.

      if (pageButtonPosition === 'end') {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } // controller is on the left / top.
      else {
          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
        }
    } // Always align controller to content as 'middle'.


    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.attr('position', contentPos);
    containerGroup.attr('position', containerPos);
    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.
    // mainRect should not be calculated by `this.group.getBoundingRect()`
    // for sake of the overflow.

    var mainRect = this.group.getBoundingRect();
    var mainRect = {
      x: 0,
      y: 0
    }; // Consider content may be overflow (should be clipped).

    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.

    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];

    if (showController) {
      var clipShape = {
        x: 0,
        y: 0
      };
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new graphic.Rect({
        shape: clipShape
      })); // Consider content may be larger than container, container rect
      // can not be obtained from `containerGroup.getBoundingRect()`.

      containerGroup.__rectSize = clipShape[wh];
    } else {
      // Do not remove or ignore controller. Keep them set as place holders.
      controllerGroup.eachChild(function (child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    } // Content translate animation.


    var pageInfo = this._getPageInfo(legendModel);

    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {
      position: pageInfo.contentPosition
    }, // When switch from "show controller" to "not show controller", view should be
    // updated immediately without animation, otherwise causes weird efffect.
    showController ? legendModel : false);

    this._updatePageInfoView(legendModel, pageInfo);

    return mainRect;
  },
  _pageGo: function (to, legendModel, api) {
    var scrollDataIndex = this._getPageInfo(legendModel)[to];

    scrollDataIndex != null && api.dispatchAction({
      type: 'legendScroll',
      scrollDataIndex: scrollDataIndex,
      legendId: legendModel.id
    });
  },
  _updatePageInfoView: function (legendModel, pageInfo) {
    var controllerGroup = this._controllerGroup;
    zrUtil.each(['pagePrev', 'pageNext'], function (name) {
      var canJump = pageInfo[name + 'DataIndex'] != null;
      var icon = controllerGroup.childOfName(name);

      if (icon) {
        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));
        icon.cursor = canJump ? 'pointer' : 'default';
      }
    });
    var pageText = controllerGroup.childOfName('pageText');
    var pageFormatter = legendModel.get('pageFormatter');
    var pageIndex = pageInfo.pageIndex;
    var current = pageIndex != null ? pageIndex + 1 : 0;
    var total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({
      current: current,
      total: total
    }));
  },

  /**
   * @param {module:echarts/model/Model} legendModel
   * @return {Object} {
   *  contentPosition: Array.<number>, null when data item not found.
   *  pageIndex: number, null when data item not found.
   *  pageCount: number, always be a number, can be 0.
   *  pagePrevDataIndex: number, null when no next page.
   *  pageNextDataIndex: number, null when no previous page.
   * }
   */
  _getPageInfo: function (legendModel) {
    // Align left or top by the current dataIndex.
    var currDataIndex = legendModel.get('scrollDataIndex', true);
    var contentGroup = this.getContentGroup();
    var contentRect = contentGroup.getBoundingRect();
    var containerRectSize = this._containerGroup.__rectSize;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var hw = WH[1 - orientIdx];
    var xy = XY[orientIdx];
    var contentPos = contentGroup.position.slice();
    var pageIndex;
    var pagePrevDataIndex;
    var pageNextDataIndex;
    var targetItemGroup;

    if (this._showController) {
      contentGroup.eachChild(function (child) {
        if (child.__legendDataIndex === currDataIndex) {
          targetItemGroup = child;
        }
      });
    } else {
      targetItemGroup = contentGroup.childAt(0);
    }

    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;

    if (targetItemGroup) {
      var itemRect = targetItemGroup.getBoundingRect();
      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];
      contentPos[orientIdx] = -itemLoc - contentRect[xy];
      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);
      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;
      var winRect = {
        x: 0,
        y: 0
      };
      winRect[wh] = containerRectSize;
      winRect[hw] = contentRect[hw];
      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];
      var startIdx;
      var children = contentGroup.children();
      contentGroup.eachChild(function (child, index) {
        var itemRect = getItemRect(child);

        if (itemRect.intersect(winRect)) {
          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the
          // current window is shown at the begining of next window.

          pageNextDataIndex = child.__legendDataIndex;
        } // If the last item is shown entirely, no next page.


        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {
          pageNextDataIndex = null;
        }
      }); // Always align based on the left/top most item, so the left/top most
      // item in the previous window is needed to be found here.

      if (startIdx != null) {
        var startItem = children[startIdx];
        var startRect = getItemRect(startItem);
        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.

        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {
          pagePrevDataIndex = null;
        } else {
          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {
            startIdx--;
          }

          pagePrevDataIndex = children[startIdx].__legendDataIndex;
        }
      }
    }

    return {
      contentPosition: contentPos,
      pageIndex: pageIndex,
      pageCount: pageCount,
      pagePrevDataIndex: pagePrevDataIndex,
      pageNextDataIndex: pageNextDataIndex
    };

    function getItemRect(el) {
      var itemRect = el.getBoundingRect().clone();
      itemRect[xy] += el.position[orientIdx];
      return itemRect;
    }
  }
});
var _default = ScrollableLegendView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/legendAction.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

function legendSelectActionHandler(methodName, payload, ecModel) {
  var selectedMap = {};
  var isToggleSelect = methodName === 'toggleSelected';
  var isSelected; // Update all legend components

  ecModel.eachComponent('legend', function (legendModel) {
    if (isToggleSelect && isSelected != null) {
      // Force other legend has same selected status
      // Or the first is toggled to true and other are toggled to false
      // In the case one legend has some item unSelected in option. And if other legend
      // doesn't has the item, they will assume it is selected.
      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
    } else {
      legendModel[methodName](payload.name);
      isSelected = legendModel.isSelected(payload.name);
    }

    var legendData = legendModel.getData();
    zrUtil.each(legendData, function (model) {
      var name = model.get('name'); // Wrap element

      if (name === '\n' || name === '') {
        return;
      }

      var isItemSelected = legendModel.isSelected(name);

      if (selectedMap.hasOwnProperty(name)) {
        // Unselected if any legend is unselected
        selectedMap[name] = selectedMap[name] && isItemSelected;
      } else {
        selectedMap[name] = isItemSelected;
      }
    });
  }); // Return the event explicitly

  return {
    name: payload.name,
    selected: selectedMap
  };
}
/**
 * @event legendToggleSelect
 * @type {Object}
 * @property {string} type 'legendToggleSelect'
 * @property {string} [from]
 * @property {string} name Series name or data item name
 */


echarts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));
/**
 * @event legendSelect
 * @type {Object}
 * @property {string} type 'legendSelect'
 * @property {string} name Series name or data item name
 */

echarts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));
/**
 * @event legendUnSelect
 * @type {Object}
 * @property {string} type 'legendUnSelect'
 * @property {string} name Series name or data item name
 */

echarts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/legendFilter.js":
/***/ (function(module, exports) {

function _default(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: 'legend'
  });

  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function (series) {
      // If in any legend component the status is not selected.
      // Because in legend series is assumed selected when it is not in the legend data.
      for (var i = 0; i < legendModels.length; i++) {
        if (!legendModels[i].isSelected(series.name)) {
          return false;
        }
      }

      return true;
    });
  }
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/scrollableLegendAction.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

/**
 * @event legendScroll
 * @type {Object}
 * @property {string} type 'legendScroll'
 * @property {string} scrollDataIndex
 */
echarts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {
  var scrollDataIndex = payload.scrollDataIndex;
  scrollDataIndex != null && ecModel.eachComponent({
    mainType: 'legend',
    subType: 'scroll',
    query: payload
  }, function (legendModel) {
    legendModel.setScrollDataIndex(scrollDataIndex);
  });
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/legendScroll.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/component/legend.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/ScrollableLegendView.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/scrollableLegendAction.js");

/***/ }),

/***/ "./node_modules/echarts/lib/component/markLine.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

__webpack_require__("./node_modules/echarts/lib/component/marker/MarkLineModel.js");

__webpack_require__("./node_modules/echarts/lib/component/marker/MarkLineView.js");

echarts.registerPreprocessor(function (opt) {
  // Make sure markLine component is enabled
  opt.markLine = opt.markLine || {};
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/markPoint.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

__webpack_require__("./node_modules/echarts/lib/component/marker/MarkPointModel.js");

__webpack_require__("./node_modules/echarts/lib/component/marker/MarkPointView.js");

// HINT Markpoint can't be used too much
echarts.registerPreprocessor(function (opt) {
  // Make sure markPoint component is enabled
  opt.markPoint = opt.markPoint || {};
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkLineModel.js":
/***/ (function(module, exports, __webpack_require__) {

var MarkerModel = __webpack_require__("./node_modules/echarts/lib/component/marker/MarkerModel.js");

var _default = MarkerModel.extend({
  type: 'markLine',
  defaultOption: {
    zlevel: 0,
    z: 5,
    symbol: ['circle', 'arrow'],
    symbolSize: [8, 16],
    //symbolRotate: 0,
    precision: 2,
    tooltip: {
      trigger: 'item'
    },
    label: {
      normal: {
        show: true,
        position: 'end'
      },
      emphasis: {
        show: true
      }
    },
    lineStyle: {
      normal: {
        type: 'dashed'
      },
      emphasis: {
        width: 3
      }
    },
    animationEasing: 'linear'
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkLineView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var List = __webpack_require__("./node_modules/echarts/lib/data/List.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var markerHelper = __webpack_require__("./node_modules/echarts/lib/component/marker/markerHelper.js");

var LineDraw = __webpack_require__("./node_modules/echarts/lib/chart/helper/LineDraw.js");

var MarkerView = __webpack_require__("./node_modules/echarts/lib/component/marker/MarkerView.js");

var markLineTransform = function (seriesModel, coordSys, mlModel, item) {
  var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average'

  var mlType = item.type;

  if (!zrUtil.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' // In case
  // data: [{
  //   yAxis: 10
  // }]
  || item.xAxis != null || item.yAxis != null)) {
    var valueAxis;
    var valueDataDim;
    var value;

    if (item.yAxis != null || item.xAxis != null) {
      valueDataDim = item.yAxis != null ? 'y' : 'x';
      valueAxis = coordSys.getAxis(valueDataDim);
      value = zrUtil.retrieve(item.yAxis, item.xAxis);
    } else {
      var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
      valueDataDim = axisInfo.valueDataDim;
      valueAxis = axisInfo.valueAxis;
      value = markerHelper.numCalculate(data, valueDataDim, mlType);
    }

    var valueIndex = valueDataDim === 'x' ? 0 : 1;
    var baseIndex = 1 - valueIndex;
    var mlFrom = zrUtil.clone(item);
    var mlTo = {};
    mlFrom.type = null;
    mlFrom.coord = [];
    mlTo.coord = [];
    mlFrom.coord[baseIndex] = -Infinity;
    mlTo.coord[baseIndex] = Infinity;
    var precision = mlModel.get('precision');

    if (precision >= 0 && typeof value === 'number') {
      value = +value.toFixed(Math.min(precision, 20));
    }

    mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
    item = [mlFrom, mlTo, {
      // Extra option for tooltip and label
      type: mlType,
      valueIndex: item.valueIndex,
      // Force to use the value of calculated value.
      value: value
    }];
  }

  item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])]; // Avoid line data type is extended by from(to) data type

  item[2].type = item[2].type || ''; // Merge from option and to option into line option

  zrUtil.merge(item[2], item[0]);
  zrUtil.merge(item[2], item[1]);
  return item;
};

function isInifinity(val) {
  return !isNaN(val) && !isFinite(val);
} // If a markLine has one dim


function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  var otherDimIndex = 1 - dimIndex;
  var dimName = coordSys.dimensions[dimIndex];
  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
}

function markLineFilter(coordSys, item) {
  if (coordSys.type === 'cartesian2d') {
    var fromCoord = item[0].coord;
    var toCoord = item[1].coord; // In case
    // {
    //  markLine: {
    //    data: [{ yAxis: 2 }]
    //  }
    // }

    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
  }

  return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
}

function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  var itemModel = data.getItemModel(idx);
  var point;
  var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
  var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());

  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    // Chart like bar may have there own marker positioning logic
    if (seriesModel.getMarkerPosition) {
      // Use the getMarkerPoisition
      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
    } else {
      var dims = coordSys.dimensions;
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);
      point = coordSys.dataToPoint([x, y]);
    } // Expand line to the edge of grid if value on one axis is Inifnity
    // In case
    //  markLine: {
    //    data: [{
    //      yAxis: 2
    //      // or
    //      type: 'average'
    //    }]
    //  }


    if (coordSys.type === 'cartesian2d') {
      var xAxis = coordSys.getAxis('x');
      var yAxis = coordSys.getAxis('y');
      var dims = coordSys.dimensions;

      if (isInifinity(data.get(dims[0], idx))) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
      } else if (isInifinity(data.get(dims[1], idx))) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
      }
    } // Use x, y if has any


    if (!isNaN(xPx)) {
      point[0] = xPx;
    }

    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }

  data.setItemLayout(idx, point);
}

var _default = MarkerView.extend({
  type: 'markLine',
  updateLayout: function (markLineModel, ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      var mlModel = seriesModel.markLineModel;

      if (mlModel) {
        var mlData = mlModel.getData();
        var fromData = mlModel.__from;
        var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol

        fromData.each(function (idx) {
          updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
          updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
        }); // Update layout of line

        mlData.each(function (idx) {
          mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
        });
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  },
  renderSeries: function (seriesModel, mlModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var lineDrawMap = this.markerGroupMap;
    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());
    this.group.add(lineDraw.group);
    var mlData = createList(coordSys, seriesModel, mlModel);
    var fromData = mlData.from;
    var toData = mlData.to;
    var lineData = mlData.line;
    mlModel.__from = fromData;
    mlModel.__to = toData; // Line data for tooltip and formatter

    mlModel.setData(lineData);
    var symbolType = mlModel.get('symbol');
    var symbolSize = mlModel.get('symbolSize');

    if (!zrUtil.isArray(symbolType)) {
      symbolType = [symbolType, symbolType];
    }

    if (typeof symbolSize === 'number') {
      symbolSize = [symbolSize, symbolSize];
    } // Update visual and layout of from symbol and to symbol


    mlData.from.each(function (idx) {
      updateDataVisualAndLayout(fromData, idx, true);
      updateDataVisualAndLayout(toData, idx, false);
    }); // Update visual and layout of line

    lineData.each(function (idx) {
      var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');
      lineData.setItemVisual(idx, {
        color: lineColor || fromData.getItemVisual(idx, 'color')
      });
      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
      lineData.setItemVisual(idx, {
        'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),
        'fromSymbol': fromData.getItemVisual(idx, 'symbol'),
        'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),
        'toSymbol': toData.getItemVisual(idx, 'symbol')
      });
    });
    lineDraw.updateData(lineData); // Set host model for tooltip
    // FIXME

    mlData.line.eachItemGraphicEl(function (el, idx) {
      el.traverse(function (child) {
        child.dataModel = mlModel;
      });
    });

    function updateDataVisualAndLayout(data, idx, isFrom) {
      var itemModel = data.getItemModel(idx);
      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
      data.setItemVisual(idx, {
        symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],
        symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],
        color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')
      });
    }

    lineDraw.__keep = true;
    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');
  }
});
/**
 * @inner
 * @param {module:echarts/coord/*} coordSys
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */


function createList(coordSys, seriesModel, mlModel) {
  var coordDimsInfos;

  if (coordSys) {
    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

      info.name = coordDim;
      return info;
    });
  } else {
    coordDimsInfos = [{
      name: 'value',
      type: 'float'
    }];
  }

  var fromData = new List(coordDimsInfos, mlModel);
  var toData = new List(coordDimsInfos, mlModel); // No dimensions

  var lineData = new List([], mlModel);
  var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));

  if (coordSys) {
    optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));
  }

  var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {
    return item.value;
  };
  fromData.initData(zrUtil.map(optData, function (item) {
    return item[0];
  }), null, dimValueGetter);
  toData.initData(zrUtil.map(optData, function (item) {
    return item[1];
  }), null, dimValueGetter);
  lineData.initData(zrUtil.map(optData, function (item) {
    return item[2];
  }));
  lineData.hasItemOption = true;
  return {
    from: fromData,
    to: toData,
    line: lineData
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkPointModel.js":
/***/ (function(module, exports, __webpack_require__) {

var MarkerModel = __webpack_require__("./node_modules/echarts/lib/component/marker/MarkerModel.js");

var _default = MarkerModel.extend({
  type: 'markPoint',
  defaultOption: {
    zlevel: 0,
    z: 5,
    symbol: 'pin',
    symbolSize: 50,
    //symbolRotate: 0,
    //symbolOffset: [0, 0]
    tooltip: {
      trigger: 'item'
    },
    label: {
      normal: {
        show: true,
        position: 'inside'
      },
      emphasis: {
        show: true
      }
    },
    itemStyle: {
      normal: {
        borderWidth: 2
      }
    }
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkPointView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var SymbolDraw = __webpack_require__("./node_modules/echarts/lib/chart/helper/SymbolDraw.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var List = __webpack_require__("./node_modules/echarts/lib/data/List.js");

var markerHelper = __webpack_require__("./node_modules/echarts/lib/component/marker/markerHelper.js");

var MarkerView = __webpack_require__("./node_modules/echarts/lib/component/marker/MarkerView.js");

function updateMarkerLayout(mpData, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  mpData.each(function (idx) {
    var itemModel = mpData.getItemModel(idx);
    var point;
    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());

    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } // Chart like bar may have there own marker positioning logic
    else if (seriesModel.getMarkerPosition) {
        // Use the getMarkerPoisition
        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
      } else if (coordSys) {
        var x = mpData.get(coordSys.dimensions[0], idx);
        var y = mpData.get(coordSys.dimensions[1], idx);
        point = coordSys.dataToPoint([x, y]);
      } // Use x, y if has any


    if (!isNaN(xPx)) {
      point[0] = xPx;
    }

    if (!isNaN(yPx)) {
      point[1] = yPx;
    }

    mpData.setItemLayout(idx, point);
  });
}

var _default = MarkerView.extend({
  type: 'markPoint',
  updateLayout: function (markPointModel, ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      var mpModel = seriesModel.markPointModel;

      if (mpModel) {
        updateMarkerLayout(mpModel.getData(), seriesModel, api);
        this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
      }
    }, this);
  },
  renderSeries: function (seriesModel, mpModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var symbolDrawMap = this.markerGroupMap;
    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());
    var mpData = createList(coordSys, seriesModel, mpModel); // FIXME

    mpModel.setData(mpData);
    updateMarkerLayout(mpModel.getData(), seriesModel, api);
    mpData.each(function (idx) {
      var itemModel = mpData.getItemModel(idx);
      var symbolSize = itemModel.getShallow('symbolSize');

      if (typeof symbolSize === 'function') {
        // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？
        symbolSize = symbolSize(mpModel.getRawValue(idx), mpModel.getDataParams(idx));
      }

      mpData.setItemVisual(idx, {
        symbolSize: symbolSize,
        color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color'),
        symbol: itemModel.getShallow('symbol')
      });
    }); // TODO Text are wrong

    symbolDraw.updateData(mpData);
    this.group.add(symbolDraw.group); // Set host model for tooltip
    // FIXME

    mpData.eachItemGraphicEl(function (el) {
      el.traverse(function (child) {
        child.dataModel = mpModel;
      });
    });
    symbolDraw.__keep = true;
    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');
  }
});
/**
 * @inner
 * @param {module:echarts/coord/*} [coordSys]
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */


function createList(coordSys, seriesModel, mpModel) {
  var coordDimsInfos;

  if (coordSys) {
    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

      info.name = coordDim;
      return info;
    });
  } else {
    coordDimsInfos = [{
      name: 'value',
      type: 'float'
    }];
  }

  var mpData = new List(coordDimsInfos, mpModel);
  var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));

  if (coordSys) {
    dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));
  }

  mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {
    return item.value;
  });
  return mpData;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkerModel.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var addCommas = formatUtil.addCommas;
var encodeHTML = formatUtil.encodeHTML;

function fillLabel(opt) {
  modelUtil.defaultEmphasis(opt.label, ['show']);
}

var MarkerModel = echarts.extendComponentModel({
  type: 'marker',
  dependencies: ['series', 'grid', 'polar', 'geo'],

  /**
   * @overrite
   */
  init: function (option, parentModel, ecModel, extraOpt) {
    this.mergeDefaultAndTheme(option, ecModel);
    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);
  },

  /**
   * @return {boolean}
   */
  isAnimationEnabled: function () {
    if (env.node) {
      return false;
    }

    var hostSeries = this.__hostSeries;
    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();
  },
  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {
    var MarkerModel = this.constructor;
    var modelPropName = this.mainType + 'Model';

    if (!createdBySelf) {
      ecModel.eachSeries(function (seriesModel) {
        var markerOpt = seriesModel.get(this.mainType);
        var markerModel = seriesModel[modelPropName];

        if (!markerOpt || !markerOpt.data) {
          seriesModel[modelPropName] = null;
          return;
        }

        if (!markerModel) {
          if (isInit) {
            // Default label emphasis `position` and `show`
            fillLabel(markerOpt);
          }

          zrUtil.each(markerOpt.data, function (item) {
            // FIXME Overwrite fillLabel method ?
            if (item instanceof Array) {
              fillLabel(item[0]);
              fillLabel(item[1]);
            } else {
              fillLabel(item);
            }
          });
          markerModel = new MarkerModel(markerOpt, this, ecModel);
          zrUtil.extend(markerModel, {
            mainType: this.mainType,
            // Use the same series index and name
            seriesIndex: seriesModel.seriesIndex,
            name: seriesModel.name,
            createdBySelf: true
          });
          markerModel.__hostSeries = seriesModel;
        } else {
          markerModel.mergeOption(markerOpt, ecModel, true);
        }

        seriesModel[modelPropName] = markerModel;
      }, this);
    }
  },
  formatTooltip: function (dataIndex) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);
    var name = data.getName(dataIndex);
    var html = encodeHTML(this.name);

    if (value != null || name) {
      html += '<br />';
    }

    if (name) {
      html += encodeHTML(name);

      if (value != null) {
        html += ' : ';
      }
    }

    if (value != null) {
      html += encodeHTML(formattedValue);
    }

    return html;
  },
  getData: function () {
    return this._data;
  },
  setData: function (data) {
    this._data = data;
  }
});
zrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin);
var _default = MarkerModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkerView.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _default = echarts.extendComponentView({
  type: 'marker',
  init: function () {
    /**
     * Markline grouped by series
     * @private
     * @type {module:zrender/core/util.HashMap}
     */
    this.markerGroupMap = zrUtil.createHashMap();
  },
  render: function (markerModel, ecModel, api) {
    var markerGroupMap = this.markerGroupMap;
    markerGroupMap.each(function (item) {
      item.__keep = false;
    });
    var markerModelKey = this.type + 'Model';
    ecModel.eachSeries(function (seriesModel) {
      var markerModel = seriesModel[markerModelKey];
      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);
    }, this);
    markerGroupMap.each(function (item) {
      !item.__keep && this.group.remove(item.group);
    }, this);
  },
  renderSeries: function () {}
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/markerHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var indexOf = zrUtil.indexOf;

function hasXOrY(item) {
  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
}

function hasXAndY(item) {
  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
}

function getPrecision(data, valueAxisDim, dataIndex) {
  var precision = -1;

  do {
    precision = Math.max(numberUtil.getPrecision(data.get(valueAxisDim, dataIndex)), precision);
    data = data.stackedOn;
  } while (data);

  return precision;
}

function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
  var coordArr = [];
  var value = numCalculate(data, targetDataDim, mlType);
  var dataIndex = data.indicesOfNearest(targetDataDim, value, true)[0];
  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);
  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);
  var precision = getPrecision(data, targetDataDim, dataIndex);
  precision = Math.min(precision, 20);

  if (precision >= 0) {
    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
  }

  return coordArr;
}

var curry = zrUtil.curry; // TODO Specified percent

var markerTypeCalculator = {
  /**
   * @method
   * @param {module:echarts/data/List} data
   * @param {string} baseAxisDim
   * @param {string} valueAxisDim
   */
  min: curry(markerTypeCalculatorWithExtent, 'min'),

  /**
   * @method
   * @param {module:echarts/data/List} data
   * @param {string} baseAxisDim
   * @param {string} valueAxisDim
   */
  max: curry(markerTypeCalculatorWithExtent, 'max'),

  /**
   * @method
   * @param {module:echarts/data/List} data
   * @param {string} baseAxisDim
   * @param {string} valueAxisDim
   */
  average: curry(markerTypeCalculatorWithExtent, 'average')
};
/**
 * Transform markPoint data item to format used in List by do the following
 * 1. Calculate statistic like `max`, `min`, `average`
 * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
 * @param  {module:echarts/model/Series} seriesModel
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {Object}
 */

function dataTransform(seriesModel, item) {
  var data = seriesModel.getData();
  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly
  // 2. If `coord` is not a data array. Which uses `xAxis`,
  // `yAxis` to specify the coord on each dimension
  // parseFloat first because item.x and item.y can be percent string like '20%'

  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {
    var dims = coordSys.dimensions;
    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option
    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value

    item = zrUtil.clone(item);

    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.

      item.value = item.coord[targetCoordIndex];
    } else {
      // FIXME Only has one of xAxis and yAxis.
      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average

      for (var i = 0; i < 2; i++) {
        if (markerTypeCalculator[coord[i]]) {
          var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];
          coord[i] = numCalculate(data, dataDim, coord[i]);
        }
      }

      item.coord = coord;
    }
  }

  return item;
}

function getAxisInfo(item, data, coordSys, seriesModel) {
  var ret = {};

  if (item.valueIndex != null || item.valueDim != null) {
    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
    ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));
    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];
  } else {
    ret.baseAxis = seriesModel.getBaseAxis();
    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];
    ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];
  }

  return ret;
}
/**
 * Filter data which is out of coordinateSystem range
 * [dataFilter description]
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {boolean}
 */


function dataFilter(coordSys, item) {
  // Alwalys return true if there is no coordSys
  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
}

function dimValueGetter(item, dimName, dataIndex, dimIndex) {
  // x, y, radius, angle
  if (dimIndex < 2) {
    return item.coord && item.coord[dimIndex];
  }

  return item.value;
}

function numCalculate(data, valueDataDim, type) {
  if (type === 'average') {
    var sum = 0;
    var count = 0;
    data.each(valueDataDim, function (val, idx) {
      if (!isNaN(val)) {
        sum += val;
        count++;
      }
    }, true);
    return sum / count;
  } else {
    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];
  }
}

exports.dataTransform = dataTransform;
exports.getAxisInfo = getAxisInfo;
exports.dataFilter = dataFilter;
exports.dimValueGetter = dimValueGetter;
exports.numCalculate = numCalculate;

/***/ }),

/***/ "./node_modules/echarts/lib/component/title.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutRect = _layout.getLayoutRect;
// Model
echarts.extendComponentModel({
  type: 'title',
  layoutMode: {
    type: 'box',
    ignoreSize: true
  },
  defaultOption: {
    // 一级层叠
    zlevel: 0,
    // 二级层叠
    z: 6,
    show: true,
    text: '',
    // 超链接跳转
    // link: null,
    // 仅支持self | blank
    target: 'blank',
    subtext: '',
    // 超链接跳转
    // sublink: null,
    // 仅支持self | blank
    subtarget: 'blank',
    // 'center' ¦ 'left' ¦ 'right'
    // ¦ {number}（x坐标，单位px）
    left: 0,
    // 'top' ¦ 'bottom' ¦ 'center'
    // ¦ {number}（y坐标，单位px）
    top: 0,
    // 水平对齐
    // 'auto' | 'left' | 'right' | 'center'
    // 默认根据 left 的位置判断是左对齐还是右对齐
    // textAlign: null
    //
    // 垂直对齐
    // 'auto' | 'top' | 'bottom' | 'middle'
    // 默认根据 top 位置判断是上对齐还是下对齐
    // textBaseline: null
    backgroundColor: 'rgba(0,0,0,0)',
    // 标题边框颜色
    borderColor: '#ccc',
    // 标题边框线宽，单位px，默认为0（无边框）
    borderWidth: 0,
    // 标题内边距，单位px，默认各方向内边距为5，
    // 接受数组分别设定上右下左边距，同css
    padding: 5,
    // 主副标题纵向间隔，单位px，默认为10，
    itemGap: 10,
    textStyle: {
      fontSize: 18,
      fontWeight: 'bolder',
      color: '#333'
    },
    subtextStyle: {
      color: '#aaa'
    }
  }
}); // View

echarts.extendComponentView({
  type: 'title',
  render: function (titleModel, ecModel, api) {
    this.group.removeAll();

    if (!titleModel.get('show')) {
      return;
    }

    var group = this.group;
    var textStyleModel = titleModel.getModel('textStyle');
    var subtextStyleModel = titleModel.getModel('subtextStyle');
    var textAlign = titleModel.get('textAlign');
    var textBaseline = titleModel.get('textBaseline');
    var textEl = new graphic.Text({
      style: graphic.setTextStyle({}, textStyleModel, {
        text: titleModel.get('text'),
        textFill: textStyleModel.getTextColor()
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var textRect = textEl.getBoundingRect();
    var subText = titleModel.get('subtext');
    var subTextEl = new graphic.Text({
      style: graphic.setTextStyle({}, subtextStyleModel, {
        text: subText,
        textFill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get('itemGap'),
        textVerticalAlign: 'top'
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var link = titleModel.get('link');
    var sublink = titleModel.get('sublink');
    textEl.silent = !link;
    subTextEl.silent = !sublink;

    if (link) {
      textEl.on('click', function () {
        window.open(link, '_' + titleModel.get('target'));
      });
    }

    if (sublink) {
      subTextEl.on('click', function () {
        window.open(sublink, '_' + titleModel.get('subtarget'));
      });
    }

    group.add(textEl);
    subText && group.add(subTextEl); // If no subText, but add subTextEl, there will be an empty line.

    var groupRect = group.getBoundingRect();
    var layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    var layoutRect = getLayoutRect(layoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    }, titleModel.get('padding')); // Adjust text align based on position

    if (!textAlign) {
      // Align left if title is on the left. center and right is same
      textAlign = titleModel.get('left') || titleModel.get('right');

      if (textAlign === 'middle') {
        textAlign = 'center';
      } // Adjust layout by text align


      if (textAlign === 'right') {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === 'center') {
        layoutRect.x += layoutRect.width / 2;
      }
    }

    if (!textBaseline) {
      textBaseline = titleModel.get('top') || titleModel.get('bottom');

      if (textBaseline === 'center') {
        textBaseline = 'middle';
      }

      if (textBaseline === 'bottom') {
        layoutRect.y += layoutRect.height;
      } else if (textBaseline === 'middle') {
        layoutRect.y += layoutRect.height / 2;
      }

      textBaseline = textBaseline || 'top';
    }

    group.attr('position', [layoutRect.x, layoutRect.y]);
    var alignStyle = {
      textAlign: textAlign,
      textVerticalAlign: textBaseline
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle); // Render background
    // Get groupRect again because textAlign has been changed

    groupRect = group.getBoundingRect();
    var padding = layoutRect.margin;
    var style = titleModel.getItemStyle(['color', 'opacity']);
    style.fill = titleModel.get('backgroundColor');
    var rect = new graphic.Rect({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get('borderRadius')
      },
      style: style,
      silent: true
    });
    graphic.subPixelOptimizeRect(rect);
    group.add(rect);
  }
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/component/toolbox/ToolboxModel.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/ToolboxView.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/feature/MagicType.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/feature/DataView.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/feature/Restore.js");

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/ToolboxModel.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

var ToolboxModel = echarts.extendComponentModel({
  type: 'toolbox',
  layoutMode: {
    type: 'box',
    ignoreSize: true
  },
  mergeDefaultAndTheme: function (option) {
    ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);
    zrUtil.each(this.option.feature, function (featureOpt, featureName) {
      var Feature = featureManager.get(featureName);
      Feature && zrUtil.merge(featureOpt, Feature.defaultOption);
    });
  },
  defaultOption: {
    show: true,
    z: 6,
    zlevel: 0,
    orient: 'horizontal',
    left: 'right',
    top: 'top',
    // right
    // bottom
    backgroundColor: 'transparent',
    borderColor: '#ccc',
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemSize: 15,
    itemGap: 8,
    showTitle: true,
    iconStyle: {
      normal: {
        borderColor: '#666',
        color: 'none'
      },
      emphasis: {
        borderColor: '#3E98C5'
      } // textStyle: {},
      // feature

    }
  }
});
var _default = ToolboxModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/ToolboxView.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var DataDiffer = __webpack_require__("./node_modules/echarts/lib/data/DataDiffer.js");

var listComponentHelper = __webpack_require__("./node_modules/echarts/lib/component/helper/listComponent.js");

var _default = echarts.extendComponentView({
  type: 'toolbox',
  render: function (toolboxModel, ecModel, api, payload) {
    var group = this.group;
    group.removeAll();

    if (!toolboxModel.get('show')) {
      return;
    }

    var itemSize = +toolboxModel.get('itemSize');
    var featureOpts = toolboxModel.get('feature') || {};
    var features = this._features || (this._features = {});
    var featureNames = [];
    zrUtil.each(featureOpts, function (opt, name) {
      featureNames.push(name);
    });
    new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute(); // Keep for diff.

    this._featureNames = featureNames;

    function processFeature(newIndex, oldIndex) {
      var featureName = featureNames[newIndex];
      var oldName = featureNames[oldIndex];
      var featureOpt = featureOpts[featureName];
      var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);
      var feature;

      if (featureName && !oldName) {
        // Create
        if (isUserFeatureName(featureName)) {
          feature = {
            model: featureModel,
            onclick: featureModel.option.onclick,
            featureName: featureName
          };
        } else {
          var Feature = featureManager.get(featureName);

          if (!Feature) {
            return;
          }

          feature = new Feature(featureModel, ecModel, api);
        }

        features[featureName] = feature;
      } else {
        feature = features[oldName]; // If feature does not exsit.

        if (!feature) {
          return;
        }

        feature.model = featureModel;
        feature.ecModel = ecModel;
        feature.api = api;
      }

      if (!featureName && oldName) {
        feature.dispose && feature.dispose(ecModel, api);
        return;
      }

      if (!featureModel.get('show') || feature.unusable) {
        feature.remove && feature.remove(ecModel, api);
        return;
      }

      createIconPaths(featureModel, feature, featureName);

      featureModel.setIconStatus = function (iconName, status) {
        var option = this.option;
        var iconPaths = this.iconPaths;
        option.iconStatus = option.iconStatus || {};
        option.iconStatus[iconName] = status; // FIXME

        iconPaths[iconName] && iconPaths[iconName].trigger(status);
      };

      if (feature.render) {
        feature.render(featureModel, ecModel, api, payload);
      }
    }

    function createIconPaths(featureModel, feature, featureName) {
      var iconStyleModel = featureModel.getModel('iconStyle'); // If one feature has mutiple icon. they are orginaized as
      // {
      //     icon: {
      //         foo: '',
      //         bar: ''
      //     },
      //     title: {
      //         foo: '',
      //         bar: ''
      //     }
      // }

      var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');
      var titles = featureModel.get('title') || {};

      if (typeof icons === 'string') {
        var icon = icons;
        var title = titles;
        icons = {};
        titles = {};
        icons[featureName] = icon;
        titles[featureName] = title;
      }

      var iconPaths = featureModel.iconPaths = {};
      zrUtil.each(icons, function (iconStr, iconName) {
        var path = graphic.createIcon(iconStr, {}, {
          x: -itemSize / 2,
          y: -itemSize / 2,
          width: itemSize,
          height: itemSize
        });
        path.setStyle(iconStyleModel.getModel('normal').getItemStyle());
        path.hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();
        graphic.setHoverStyle(path);

        if (toolboxModel.get('showTitle')) {
          path.__title = titles[iconName];
          path.on('mouseover', function () {
            // Should not reuse above hoverStyle, which might be modified.
            var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();
            path.setStyle({
              text: titles[iconName],
              textPosition: hoverStyle.textPosition || 'bottom',
              textFill: hoverStyle.fill || hoverStyle.stroke || '#000',
              textAlign: hoverStyle.textAlign || 'center'
            });
          }).on('mouseout', function () {
            path.setStyle({
              textFill: null
            });
          });
        }

        path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');
        group.add(path);
        path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));
        iconPaths[iconName] = path;
      });
    }

    listComponentHelper.layout(group, toolboxModel, api); // Render background after group is layout
    // FIXME

    group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen

    group.eachChild(function (icon) {
      var titleText = icon.__title;
      var hoverStyle = icon.hoverStyle; // May be background element

      if (hoverStyle && titleText) {
        var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));
        var offsetX = icon.position[0] + group.position[0];
        var offsetY = icon.position[1] + group.position[1] + itemSize;
        var needPutOnTop = false;

        if (offsetY + rect.height > api.getHeight()) {
          hoverStyle.textPosition = 'top';
          needPutOnTop = true;
        }

        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;

        if (offsetX + rect.width / 2 > api.getWidth()) {
          hoverStyle.textPosition = ['100%', topOffset];
          hoverStyle.textAlign = 'right';
        } else if (offsetX - rect.width / 2 < 0) {
          hoverStyle.textPosition = [0, topOffset];
          hoverStyle.textAlign = 'left';
        }
      }
    });
  },
  updateView: function (toolboxModel, ecModel, api, payload) {
    zrUtil.each(this._features, function (feature) {
      feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
    });
  },
  updateLayout: function (toolboxModel, ecModel, api, payload) {
    zrUtil.each(this._features, function (feature) {
      feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
    });
  },
  remove: function (ecModel, api) {
    zrUtil.each(this._features, function (feature) {
      feature.remove && feature.remove(ecModel, api);
    });
    this.group.removeAll();
  },
  dispose: function (ecModel, api) {
    zrUtil.each(this._features, function (feature) {
      feature.dispose && feature.dispose(ecModel, api);
    });
  }
});

function isUserFeatureName(featureName) {
  return featureName.indexOf('my') === 0;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/DataView.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var eventTool = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

var dataViewLang = lang.toolbox.dataView;
var BLOCK_SPLITER = new Array(60).join('-');
var ITEM_SPLITER = '\t';
/**
 * Group series into two types
 *  1. on category axis, like line, bar
 *  2. others, like scatter, pie
 * @param {module:echarts/model/Global} ecModel
 * @return {Object}
 * @inner
 */

function groupSeries(ecModel) {
  var seriesGroupByCategoryAxis = {};
  var otherSeries = [];
  var meta = [];
  ecModel.eachRawSeries(function (seriesModel) {
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {
      var baseAxis = coordSys.getBaseAxis();

      if (baseAxis.type === 'category') {
        var key = baseAxis.dim + '_' + baseAxis.index;

        if (!seriesGroupByCategoryAxis[key]) {
          seriesGroupByCategoryAxis[key] = {
            categoryAxis: baseAxis,
            valueAxis: coordSys.getOtherAxis(baseAxis),
            series: []
          };
          meta.push({
            axisDim: baseAxis.dim,
            axisIndex: baseAxis.index
          });
        }

        seriesGroupByCategoryAxis[key].series.push(seriesModel);
      } else {
        otherSeries.push(seriesModel);
      }
    } else {
      otherSeries.push(seriesModel);
    }
  });
  return {
    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,
    other: otherSeries,
    meta: meta
  };
}
/**
 * Assemble content of series on cateogory axis
 * @param {Array.<module:echarts/model/Series>} series
 * @return {string}
 * @inner
 */


function assembleSeriesWithCategoryAxis(series) {
  var tables = [];
  zrUtil.each(series, function (group, key) {
    var categoryAxis = group.categoryAxis;
    var valueAxis = group.valueAxis;
    var valueAxisDim = valueAxis.dim;
    var headers = [' '].concat(zrUtil.map(group.series, function (series) {
      return series.name;
    }));
    var columns = [categoryAxis.model.getCategories()];
    zrUtil.each(group.series, function (series) {
      columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {
        return val;
      }));
    }); // Assemble table content

    var lines = [headers.join(ITEM_SPLITER)];

    for (var i = 0; i < columns[0].length; i++) {
      var items = [];

      for (var j = 0; j < columns.length; j++) {
        items.push(columns[j][i]);
      }

      lines.push(items.join(ITEM_SPLITER));
    }

    tables.push(lines.join('\n'));
  });
  return tables.join('\n\n' + BLOCK_SPLITER + '\n\n');
}
/**
 * Assemble content of other series
 * @param {Array.<module:echarts/model/Series>} series
 * @return {string}
 * @inner
 */


function assembleOtherSeries(series) {
  return zrUtil.map(series, function (series) {
    var data = series.getRawData();
    var lines = [series.name];
    var vals = [];
    data.each(data.dimensions, function () {
      var argLen = arguments.length;
      var dataIndex = arguments[argLen - 1];
      var name = data.getName(dataIndex);

      for (var i = 0; i < argLen - 1; i++) {
        vals[i] = arguments[i];
      }

      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));
    });
    return lines.join('\n');
  }).join('\n\n' + BLOCK_SPLITER + '\n\n');
}
/**
 * @param {module:echarts/model/Global}
 * @return {Object}
 * @inner
 */


function getContentFromModel(ecModel) {
  var result = groupSeries(ecModel);
  return {
    value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {
      return str.replace(/[\n\t\s]/g, '');
    }).join('\n\n' + BLOCK_SPLITER + '\n\n'),
    meta: result.meta
  };
}

function trim(str) {
  return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}
/**
 * If a block is tsv format
 */


function isTSVFormat(block) {
  // Simple method to find out if a block is tsv format
  var firstLine = block.slice(0, block.indexOf('\n'));

  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
    return true;
  }
}

var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');
/**
 * @param {string} tsv
 * @return {Object}
 */

function parseTSVContents(tsv) {
  var tsvLines = tsv.split(/\n+/g);
  var headers = trim(tsvLines.shift()).split(itemSplitRegex);
  var categories = [];
  var series = zrUtil.map(headers, function (header) {
    return {
      name: header,
      data: []
    };
  });

  for (var i = 0; i < tsvLines.length; i++) {
    var items = trim(tsvLines[i]).split(itemSplitRegex);
    categories.push(items.shift());

    for (var j = 0; j < items.length; j++) {
      series[j] && (series[j].data[i] = items[j]);
    }
  }

  return {
    series: series,
    categories: categories
  };
}
/**
 * @param {string} str
 * @return {Array.<Object>}
 * @inner
 */


function parseListContents(str) {
  var lines = str.split(/\n+/g);
  var seriesName = trim(lines.shift());
  var data = [];

  for (var i = 0; i < lines.length; i++) {
    var items = trim(lines[i]).split(itemSplitRegex);
    var name = '';
    var value;
    var hasName = false;

    if (isNaN(items[0])) {
      // First item is name
      hasName = true;
      name = items[0];
      items = items.slice(1);
      data[i] = {
        name: name,
        value: []
      };
      value = data[i].value;
    } else {
      value = data[i] = [];
    }

    for (var j = 0; j < items.length; j++) {
      value.push(+items[j]);
    }

    if (value.length === 1) {
      hasName ? data[i].value = value[0] : data[i] = value[0];
    }
  }

  return {
    name: seriesName,
    data: data
  };
}
/**
 * @param {string} str
 * @param {Array.<Object>} blockMetaList
 * @return {Object}
 * @inner
 */


function parseContents(str, blockMetaList) {
  var blocks = str.split(new RegExp('\n*' + BLOCK_SPLITER + '\n*', 'g'));
  var newOption = {
    series: []
  };
  zrUtil.each(blocks, function (block, idx) {
    if (isTSVFormat(block)) {
      var result = parseTSVContents(block);
      var blockMeta = blockMetaList[idx];
      var axisKey = blockMeta.axisDim + 'Axis';

      if (blockMeta) {
        newOption[axisKey] = newOption[axisKey] || [];
        newOption[axisKey][blockMeta.axisIndex] = {
          data: result.categories
        };
        newOption.series = newOption.series.concat(result.series);
      }
    } else {
      var result = parseListContents(block);
      newOption.series.push(result);
    }
  });
  return newOption;
}
/**
 * @alias {module:echarts/component/toolbox/feature/DataView}
 * @constructor
 * @param {module:echarts/model/Model} model
 */


function DataView(model) {
  this._dom = null;
  this.model = model;
}

DataView.defaultOption = {
  show: true,
  readOnly: false,
  optionToContent: null,
  contentToOption: null,
  icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
  title: zrUtil.clone(dataViewLang.title),
  lang: zrUtil.clone(dataViewLang.lang),
  backgroundColor: '#fff',
  textColor: '#000',
  textareaColor: '#fff',
  textareaBorderColor: '#333',
  buttonColor: '#c23531',
  buttonTextColor: '#fff'
};

DataView.prototype.onclick = function (ecModel, api) {
  var container = api.getDom();
  var model = this.model;

  if (this._dom) {
    container.removeChild(this._dom);
  }

  var root = document.createElement('div');
  root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';
  root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements

  var header = document.createElement('h4');
  var lang = model.get('lang') || [];
  header.innerHTML = lang[0] || model.get('title');
  header.style.cssText = 'margin: 10px 20px;';
  header.style.color = model.get('textColor');
  var viewMain = document.createElement('div');
  var textarea = document.createElement('textarea');
  viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';
  var optionToContent = model.get('optionToContent');
  var contentToOption = model.get('contentToOption');
  var result = getContentFromModel(ecModel);

  if (typeof optionToContent === 'function') {
    var htmlOrDom = optionToContent(api.getOption());

    if (typeof htmlOrDom === 'string') {
      viewMain.innerHTML = htmlOrDom;
    } else if (zrUtil.isDom(htmlOrDom)) {
      viewMain.appendChild(htmlOrDom);
    }
  } else {
    // Use default textarea
    viewMain.appendChild(textarea);
    textarea.readOnly = model.get('readOnly');
    textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';
    textarea.style.color = model.get('textColor');
    textarea.style.borderColor = model.get('textareaBorderColor');
    textarea.style.backgroundColor = model.get('textareaColor');
    textarea.value = result.value;
  }

  var blockMetaList = result.meta;
  var buttonContainer = document.createElement('div');
  buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';
  var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';
  var closeButton = document.createElement('div');
  var refreshButton = document.createElement('div');
  buttonStyle += ';background-color:' + model.get('buttonColor');
  buttonStyle += ';color:' + model.get('buttonTextColor');
  var self = this;

  function close() {
    container.removeChild(root);
    self._dom = null;
  }

  eventTool.addEventListener(closeButton, 'click', close);
  eventTool.addEventListener(refreshButton, 'click', function () {
    var newOption;

    try {
      if (typeof contentToOption === 'function') {
        newOption = contentToOption(viewMain, api.getOption());
      } else {
        newOption = parseContents(textarea.value, blockMetaList);
      }
    } catch (e) {
      close();
      throw new Error('Data view format error ' + e);
    }

    if (newOption) {
      api.dispatchAction({
        type: 'changeDataView',
        newOption: newOption
      });
    }

    close();
  });
  closeButton.innerHTML = lang[1];
  refreshButton.innerHTML = lang[2];
  refreshButton.style.cssText = buttonStyle;
  closeButton.style.cssText = buttonStyle;
  !model.get('readOnly') && buttonContainer.appendChild(refreshButton);
  buttonContainer.appendChild(closeButton); // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea

  eventTool.addEventListener(textarea, 'keydown', function (e) {
    if ((e.keyCode || e.which) === 9) {
      // get caret position/selection
      var val = this.value;
      var start = this.selectionStart;
      var end = this.selectionEnd; // set textarea value to: text before caret + tab + text after caret

      this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end); // put caret at right position again

      this.selectionStart = this.selectionEnd = start + 1; // prevent the focus lose

      eventTool.stop(e);
    }
  });
  root.appendChild(header);
  root.appendChild(viewMain);
  root.appendChild(buttonContainer);
  viewMain.style.height = container.clientHeight - 80 + 'px';
  container.appendChild(root);
  this._dom = root;
};

DataView.prototype.remove = function (ecModel, api) {
  this._dom && api.getDom().removeChild(this._dom);
};

DataView.prototype.dispose = function (ecModel, api) {
  this.remove(ecModel, api);
};
/**
 * @inner
 */


function tryMergeDataOption(newData, originalData) {
  return zrUtil.map(newData, function (newVal, idx) {
    var original = originalData && originalData[idx];

    if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {
      if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {
        newVal = newVal.value;
      } // Original data has option


      return zrUtil.defaults({
        value: newVal
      }, original);
    } else {
      return newVal;
    }
  });
}

featureManager.register('dataView', DataView);
echarts.registerAction({
  type: 'changeDataView',
  event: 'dataViewChanged',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  var newSeriesOptList = [];
  zrUtil.each(payload.newOption.series, function (seriesOpt) {
    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];

    if (!seriesModel) {
      // New created series
      // Geuss the series type
      newSeriesOptList.push(zrUtil.extend({
        // Default is scatter
        type: 'scatter'
      }, seriesOpt));
    } else {
      var originalData = seriesModel.get('data');
      newSeriesOptList.push({
        name: seriesOpt.name,
        data: tryMergeDataOption(seriesOpt.data, originalData)
      });
    }
  });
  ecModel.mergeOption(zrUtil.defaults({
    series: newSeriesOptList
  }, payload.newOption));
});
var _default = DataView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var BrushController = __webpack_require__("./node_modules/echarts/lib/component/helper/BrushController.js");

var BrushTargetManager = __webpack_require__("./node_modules/echarts/lib/component/helper/BrushTargetManager.js");

var history = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/history.js");

var sliderMove = __webpack_require__("./node_modules/echarts/lib/component/helper/sliderMove.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoomSelect.js");

// Use dataZoomSelect
var dataZoomLang = lang.toolbox.dataZoom;
var each = zrUtil.each; // Spectial component id start with \0ec\0, see echarts/model/Global.js~hasInnerId

var DATA_ZOOM_ID_BASE = '\0_ec_\0toolbox-dataZoom_';

function DataZoom(model, ecModel, api) {
  /**
   * @private
   * @type {module:echarts/component/helper/BrushController}
   */
  (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();
  /**
   * @private
   * @type {boolean}
   */

  this._isZoomActive;
}

DataZoom.defaultOption = {
  show: true,
  // Icon group
  icon: {
    zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
    back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'
  },
  // `zoom`, `back`
  title: zrUtil.clone(dataZoomLang.title)
};
var proto = DataZoom.prototype;

proto.render = function (featureModel, ecModel, api, payload) {
  this.model = featureModel;
  this.ecModel = ecModel;
  this.api = api;
  updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
  updateBackBtnStatus(featureModel, ecModel);
};

proto.onclick = function (ecModel, api, type) {
  handlers[type].call(this);
};

proto.remove = function (ecModel, api) {
  this._brushController.unmount();
};

proto.dispose = function (ecModel, api) {
  this._brushController.dispose();
};
/**
 * @private
 */


var handlers = {
  zoom: function () {
    var nextActive = !this._isZoomActive;
    this.api.dispatchAction({
      type: 'takeGlobalCursor',
      key: 'dataZoomSelect',
      dataZoomSelectActive: nextActive
    });
  },
  back: function () {
    this._dispatchZoomAction(history.pop(this.ecModel));
  }
};
/**
 * @private
 */

proto._onBrush = function (areas, opt) {
  if (!opt.isEnd || !areas.length) {
    return;
  }

  var snapshot = {};
  var ecModel = this.ecModel;

  this._brushController.updateCovers([]); // remove cover


  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {
    include: ['grid']
  });
  brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
    if (coordSys.type !== 'cartesian2d') {
      return;
    }

    var brushType = area.brushType;

    if (brushType === 'rect') {
      setBatch('x', coordSys, coordRange[0]);
      setBatch('y', coordSys, coordRange[1]);
    } else {
      setBatch({
        lineX: 'x',
        lineY: 'y'
      }[brushType], coordSys, coordRange);
    }
  });
  history.push(ecModel, snapshot);

  this._dispatchZoomAction(snapshot);

  function setBatch(dimName, coordSys, minMax) {
    var axis = coordSys.getAxis(dimName);
    var axisModel = axis.model;
    var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.

    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();

    if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
      minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
    }

    dataZoomModel && (snapshot[dataZoomModel.id] = {
      dataZoomId: dataZoomModel.id,
      startValue: minMax[0],
      endValue: minMax[1]
    });
  }

  function findDataZoom(dimName, axisModel, ecModel) {
    var found;
    ecModel.eachComponent({
      mainType: 'dataZoom',
      subType: 'select'
    }, function (dzModel) {
      var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);
      has && (found = dzModel);
    });
    return found;
  }
};
/**
 * @private
 */


proto._dispatchZoomAction = function (snapshot) {
  var batch = []; // Convert from hash map to array.

  each(snapshot, function (batchItem, dataZoomId) {
    batch.push(zrUtil.clone(batchItem));
  });
  batch.length && this.api.dispatchAction({
    type: 'dataZoom',
    from: this.uid,
    batch: batch
  });
};

function retrieveAxisSetting(option) {
  var setting = {}; // Compatible with previous setting: null => all axis, false => no axis.

  zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {
    setting[name] = option[name];
    setting[name] == null && (setting[name] = 'all');
    (setting[name] === false || setting[name] === 'none') && (setting[name] = []);
  });
  return setting;
}

function updateBackBtnStatus(featureModel, ecModel) {
  featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');
}

function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
  var zoomActive = view._isZoomActive;

  if (payload && payload.type === 'takeGlobalCursor') {
    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;
  }

  view._isZoomActive = zoomActive;
  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');
  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {
    include: ['grid']
  });

  view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {
    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';
  })).enableBrush(zoomActive ? {
    brushType: 'auto',
    brushStyle: {
      // FIXME user customized?
      lineWidth: 0,
      fill: 'rgba(0,0,0,0.2)'
    }
  } : false);
}

featureManager.register('dataZoom', DataZoom); // Create special dataZoom option for select

echarts.registerPreprocessor(function (option) {
  if (!option) {
    return;
  }

  var dataZoomOpts = option.dataZoom || (option.dataZoom = []);

  if (!zrUtil.isArray(dataZoomOpts)) {
    option.dataZoom = dataZoomOpts = [dataZoomOpts];
  }

  var toolboxOpt = option.toolbox;

  if (toolboxOpt) {
    // Assume there is only one toolbox
    if (zrUtil.isArray(toolboxOpt)) {
      toolboxOpt = toolboxOpt[0];
    }

    if (toolboxOpt && toolboxOpt.feature) {
      var dataZoomOpt = toolboxOpt.feature.dataZoom;
      addForAxis('xAxis', dataZoomOpt);
      addForAxis('yAxis', dataZoomOpt);
    }
  }

  function addForAxis(axisName, dataZoomOpt) {
    if (!dataZoomOpt) {
      return;
    } // Try not to modify model, because it is not merged yet.


    var axisIndicesName = axisName + 'Index';
    var givenAxisIndices = dataZoomOpt[axisIndicesName];

    if (givenAxisIndices != null && givenAxisIndices != 'all' && !zrUtil.isArray(givenAxisIndices)) {
      givenAxisIndices = givenAxisIndices === false || givenAxisIndices === 'none' ? [] : [givenAxisIndices];
    }

    forEachComponent(axisName, function (axisOpt, axisIndex) {
      if (givenAxisIndices != null && givenAxisIndices != 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {
        return;
      }

      var newOpt = {
        type: 'select',
        $fromToolbox: true,
        // Id for merge mapping.
        id: DATA_ZOOM_ID_BASE + axisName + axisIndex
      }; // FIXME
      // Only support one axis now.

      newOpt[axisIndicesName] = axisIndex;
      dataZoomOpts.push(newOpt);
    });
  }

  function forEachComponent(mainType, cb) {
    var opts = option[mainType];

    if (!zrUtil.isArray(opts)) {
      opts = opts ? [opts] : [];
    }

    each(opts, cb);
  }
});
var _default = DataZoom;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/MagicType.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

var magicTypeLang = lang.toolbox.magicType;

function MagicType(model) {
  this.model = model;
}

MagicType.defaultOption = {
  show: true,
  type: [],
  // Icon group
  icon: {
    line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
    bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
    stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',
    // jshint ignore:line
    tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'
  },
  // `line`, `bar`, `stack`, `tiled`
  title: zrUtil.clone(magicTypeLang.title),
  option: {},
  seriesIndex: {}
};
var proto = MagicType.prototype;

proto.getIcons = function () {
  var model = this.model;
  var availableIcons = model.get('icon');
  var icons = {};
  zrUtil.each(model.get('type'), function (type) {
    if (availableIcons[type]) {
      icons[type] = availableIcons[type];
    }
  });
  return icons;
};

var seriesOptGenreator = {
  'line': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'bar') {
      return zrUtil.merge({
        id: seriesId,
        type: 'line',
        // Preserve data related option
        data: seriesModel.get('data'),
        stack: seriesModel.get('stack'),
        markPoint: seriesModel.get('markPoint'),
        markLine: seriesModel.get('markLine')
      }, model.get('option.line') || {}, true);
    }
  },
  'bar': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'line') {
      return zrUtil.merge({
        id: seriesId,
        type: 'bar',
        // Preserve data related option
        data: seriesModel.get('data'),
        stack: seriesModel.get('stack'),
        markPoint: seriesModel.get('markPoint'),
        markLine: seriesModel.get('markLine')
      }, model.get('option.bar') || {}, true);
    }
  },
  'stack': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'line' || seriesType === 'bar') {
      return zrUtil.merge({
        id: seriesId,
        stack: '__ec_magicType_stack__'
      }, model.get('option.stack') || {}, true);
    }
  },
  'tiled': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'line' || seriesType === 'bar') {
      return zrUtil.merge({
        id: seriesId,
        stack: ''
      }, model.get('option.tiled') || {}, true);
    }
  }
};
var radioTypes = [['line', 'bar'], ['stack', 'tiled']];

proto.onclick = function (ecModel, api, type) {
  var model = this.model;
  var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType

  if (!seriesOptGenreator[type]) {
    return;
  }

  var newOption = {
    series: []
  };

  var generateNewSeriesTypes = function (seriesModel) {
    var seriesType = seriesModel.subType;
    var seriesId = seriesModel.id;
    var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);

    if (newSeriesOpt) {
      // PENDING If merge original option?
      zrUtil.defaults(newSeriesOpt, seriesModel.option);
      newOption.series.push(newSeriesOpt);
    } // Modify boundaryGap


    var coordSys = seriesModel.coordinateSystem;

    if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {
      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

      if (categoryAxis) {
        var axisDim = categoryAxis.dim;
        var axisType = axisDim + 'Axis';
        var axisModel = ecModel.queryComponents({
          mainType: axisType,
          index: seriesModel.get(name + 'Index'),
          id: seriesModel.get(name + 'Id')
        })[0];
        var axisIndex = axisModel.componentIndex;
        newOption[axisType] = newOption[axisType] || [];

        for (var i = 0; i <= axisIndex; i++) {
          newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
        }

        newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;
      }
    }
  };

  zrUtil.each(radioTypes, function (radio) {
    if (zrUtil.indexOf(radio, type) >= 0) {
      zrUtil.each(radio, function (item) {
        model.setIconStatus(item, 'normal');
      });
    }
  });
  model.setIconStatus(type, 'emphasis');
  ecModel.eachComponent({
    mainType: 'series',
    query: seriesIndex == null ? null : {
      seriesIndex: seriesIndex
    }
  }, generateNewSeriesTypes);
  api.dispatchAction({
    type: 'changeMagicType',
    currentType: type,
    newOption: newOption
  });
};

echarts.registerAction({
  type: 'changeMagicType',
  event: 'magicTypeChanged',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  ecModel.mergeOption(payload.newOption);
});
featureManager.register('magicType', MagicType);
var _default = MagicType;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/Restore.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var history = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/history.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

var restoreLang = lang.toolbox.restore;

function Restore(model) {
  this.model = model;
}

Restore.defaultOption = {
  show: true,
  icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
  title: restoreLang.title
};
var proto = Restore.prototype;

proto.onclick = function (ecModel, api, type) {
  history.clear(ecModel);
  api.dispatchAction({
    type: 'restore',
    from: this.uid
  });
};

featureManager.register('restore', Restore);
echarts.registerAction({
  type: 'restore',
  event: 'restore',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  ecModel.resetOption('recreate');
});
var _default = Restore;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js":
/***/ (function(module, exports, __webpack_require__) {

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

var saveAsImageLang = lang.toolbox.saveAsImage;

function SaveAsImage(model) {
  this.model = model;
}

SaveAsImage.defaultOption = {
  show: true,
  icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
  title: saveAsImageLang.title,
  type: 'png',
  // Default use option.backgroundColor
  // backgroundColor: '#fff',
  name: '',
  excludeComponents: ['toolbox'],
  pixelRatio: 1,
  lang: saveAsImageLang.lang.slice()
};
SaveAsImage.prototype.unusable = !env.canvasSupported;
var proto = SaveAsImage.prototype;

proto.onclick = function (ecModel, api) {
  var model = this.model;
  var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';
  var $a = document.createElement('a');
  var type = model.get('type', true) || 'png';
  $a.download = title + '.' + type;
  $a.target = '_blank';
  var url = api.getConnectedDataURL({
    type: type,
    backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',
    excludeComponents: model.get('excludeComponents'),
    pixelRatio: model.get('pixelRatio')
  });
  $a.href = url; // Chrome and Firefox

  if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {
    var evt = new MouseEvent('click', {
      view: window,
      bubbles: true,
      cancelable: false
    });
    $a.dispatchEvent(evt);
  } // IE
  else {
      if (window.navigator.msSaveOrOpenBlob) {
        var bstr = atob(url.split(',')[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);

        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }

        var blob = new Blob([u8arr]);
        window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);
      } else {
        var lang = model.get('lang');
        var html = '' + '<body style="margin:0;">' + '<img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || '') + '" />' + '</body>';
        var tab = window.open();
        tab.document.write(html);
      }
    }
};

featureManager.register('saveAsImage', SaveAsImage);
var _default = SaveAsImage;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/featureManager.js":
/***/ (function(module, exports) {

var features = {};

function register(name, ctor) {
  features[name] = ctor;
}

function get(name) {
  return features[name];
}

exports.register = register;
exports.get = get;

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

__webpack_require__("./node_modules/echarts/lib/component/axisPointer.js");

__webpack_require__("./node_modules/echarts/lib/component/tooltip/TooltipModel.js");

__webpack_require__("./node_modules/echarts/lib/component/tooltip/TooltipView.js");

// FIXME Better way to pack data in graphic element

/**
 * @action
 * @property {string} type
 * @property {number} seriesIndex
 * @property {number} dataIndex
 * @property {number} [x]
 * @property {number} [y]
 */
echarts.registerAction({
  type: 'showTip',
  event: 'showTip',
  update: 'tooltip:manuallyShowTip'
}, // noop
function () {});
echarts.registerAction({
  type: 'hideTip',
  event: 'hideTip',
  update: 'tooltip:manuallyHideTip'
}, // noop
function () {});

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/TooltipContent.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var zrColor = __webpack_require__("./node_modules/zrender/lib/tool/color.js");

var eventUtil = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var each = zrUtil.each;
var toCamelCase = formatUtil.toCamelCase;
var vendors = ['', '-webkit-', '-moz-', '-o-'];
var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';
/**
 * @param {number} duration
 * @return {string}
 * @inner
 */

function assembleTransition(duration) {
  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
  var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;
  return zrUtil.map(vendors, function (vendorPrefix) {
    return vendorPrefix + 'transition:' + transitionText;
  }).join(';');
}
/**
 * @param {Object} textStyle
 * @return {string}
 * @inner
 */


function assembleFont(textStyleModel) {
  var cssText = [];
  var fontSize = textStyleModel.get('fontSize');
  var color = textStyleModel.getTextColor();
  color && cssText.push('color:' + color);
  cssText.push('font:' + textStyleModel.getFont());
  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
  each(['decoration', 'align'], function (name) {
    var val = textStyleModel.get(name);
    val && cssText.push('text-' + name + ':' + val);
  });
  return cssText.join(';');
}
/**
 * @param {Object} tooltipModel
 * @return {string}
 * @inner
 */


function assembleCssText(tooltipModel) {
  var cssText = [];
  var transitionDuration = tooltipModel.get('transitionDuration');
  var backgroundColor = tooltipModel.get('backgroundColor');
  var textStyleModel = tooltipModel.getModel('textStyle');
  var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.

  transitionDuration && cssText.push(assembleTransition(transitionDuration));

  if (backgroundColor) {
    if (env.canvasSupported) {
      cssText.push('background-Color:' + backgroundColor);
    } else {
      // for ie
      cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));
      cssText.push('filter:alpha(opacity=70)');
    }
  } // Border style


  each(['width', 'color', 'radius'], function (name) {
    var borderName = 'border-' + name;
    var camelCase = toCamelCase(borderName);
    var val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
  }); // Text style

  cssText.push(assembleFont(textStyleModel)); // Padding

  if (padding != null) {
    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');
  }

  return cssText.join(';') + ';';
}
/**
 * @alias module:echarts/component/tooltip/TooltipContent
 * @constructor
 */


function TooltipContent(container, api) {
  var el = document.createElement('div');
  var zr = this._zr = api.getZr();
  this.el = el;
  this._x = api.getWidth() / 2;
  this._y = api.getHeight() / 2;
  container.appendChild(el);
  this._container = container;
  this._show = false;
  /**
   * @private
   */

  this._hideTimeout;
  var self = this;

  el.onmouseenter = function () {
    // clear the timeout in hideLater and keep showing tooltip
    if (self._enterable) {
      clearTimeout(self._hideTimeout);
      self._show = true;
    }

    self._inContent = true;
  };

  el.onmousemove = function (e) {
    e = e || window.event;

    if (!self._enterable) {
      // Try trigger zrender event to avoid mouse
      // in and out shape too frequently
      var handler = zr.handler;
      eventUtil.normalizeEvent(container, e, true);
      handler.dispatch('mousemove', e);
    }
  };

  el.onmouseleave = function () {
    if (self._enterable) {
      if (self._show) {
        self.hideLater(self._hideDelay);
      }
    }

    self._inContent = false;
  };
}

TooltipContent.prototype = {
  constructor: TooltipContent,

  /**
   * @private
   * @type {boolean}
   */
  _enterable: true,

  /**
   * Update when tooltip is rendered
   */
  update: function () {
    // FIXME
    // Move this logic to ec main?
    var container = this._container;
    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
    var domStyle = container.style;

    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
      domStyle.position = 'relative';
    } // Hide the tooltip
    // PENDING
    // this.hide();

  },
  show: function (tooltipModel) {
    clearTimeout(this._hideTimeout);
    var el = this.el;
    el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
    + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');
    el.style.display = el.innerHTML ? 'block' : 'none';
    this._show = true;
  },
  setContent: function (content) {
    this.el.innerHTML = content == null ? '' : content;
  },
  setEnterable: function (enterable) {
    this._enterable = enterable;
  },
  getSize: function () {
    var el = this.el;
    return [el.clientWidth, el.clientHeight];
  },
  moveTo: function (x, y) {
    // xy should be based on canvas root. But tooltipContent is
    // the sibling of canvas root. So padding of ec container
    // should be considered here.
    var zr = this._zr;
    var viewportRootOffset;

    if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {
      x += viewportRootOffset.offsetLeft;
      y += viewportRootOffset.offsetTop;
    }

    var style = this.el.style;
    style.left = x + 'px';
    style.top = y + 'px';
    this._x = x;
    this._y = y;
  },
  hide: function () {
    this.el.style.display = 'none';
    this._show = false;
  },
  hideLater: function (time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times

        this._show = false;
        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  },
  isShow: function () {
    return this._show;
  }
};
var _default = TooltipContent;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/TooltipModel.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var _default = echarts.extendComponentModel({
  type: 'tooltip',
  dependencies: ['axisPointer'],
  defaultOption: {
    zlevel: 0,
    z: 8,
    show: true,
    // tooltip主体内容
    showContent: true,
    // 'trigger' only works on coordinate system.
    // 'item' | 'axis' | 'none'
    trigger: 'item',
    // 'click' | 'mousemove' | 'none'
    triggerOn: 'mousemove|click',
    alwaysShowContent: false,
    displayMode: 'single',
    // 'single' | 'multipleByCoordSys'
    // 位置 {Array} | {Function}
    // position: null
    // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
    // align: null,
    // verticalAlign: null,
    // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。
    confine: false,
    // 内容格式器：{string}（Template） ¦ {Function}
    // formatter: null
    showDelay: 0,
    // 隐藏延迟，单位ms
    hideDelay: 100,
    // 动画变换时间，单位s
    transitionDuration: 0.4,
    enterable: false,
    // 提示背景颜色，默认为透明度为0.7的黑色
    backgroundColor: 'rgba(50,50,50,0.7)',
    // 提示边框颜色
    borderColor: '#333',
    // 提示边框圆角，单位px，默认为4
    borderRadius: 4,
    // 提示边框线宽，单位px，默认为0（无边框）
    borderWidth: 0,
    // 提示内边距，单位px，默认各方向内边距为5，
    // 接受数组分别设定上右下左边距，同css
    padding: 5,
    // Extra css text
    extraCssText: '',
    // 坐标轴指示器，坐标轴触发有效
    axisPointer: {
      // 默认为直线
      // 可选为：'line' | 'shadow' | 'cross'
      type: 'line',
      // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选
      // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'
      // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴
      // 极坐标系会默认选择 angle 轴
      axis: 'auto',
      animation: 'auto',
      animationDurationUpdate: 200,
      animationEasingUpdate: 'exponentialOut',
      crossStyle: {
        color: '#999',
        width: 1,
        type: 'dashed',
        // TODO formatter
        textStyle: {} // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.

      }
    },
    textStyle: {
      color: '#fff',
      fontSize: 14
    }
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/TooltipView.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var TooltipContent = __webpack_require__("./node_modules/echarts/lib/component/tooltip/TooltipContent.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var findPointFromSeries = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js");

var layoutUtil = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var globalListener = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/globalListener.js");

var axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

var axisPointerViewHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/viewHelper.js");

var bind = zrUtil.bind;
var each = zrUtil.each;
var parsePercent = numberUtil.parsePercent;
var proxyRect = new graphic.Rect({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
});

var _default = echarts.extendComponentView({
  type: 'tooltip',
  init: function (ecModel, api) {
    if (env.node) {
      return;
    }

    var tooltipContent = new TooltipContent(api.getDom(), api);
    this._tooltipContent = tooltipContent;
  },
  render: function (tooltipModel, ecModel, api) {
    if (env.node) {
      return;
    } // Reset


    this.group.removeAll();
    /**
     * @private
     * @type {module:echarts/component/tooltip/TooltipModel}
     */

    this._tooltipModel = tooltipModel;
    /**
     * @private
     * @type {module:echarts/model/Global}
     */

    this._ecModel = ecModel;
    /**
     * @private
     * @type {module:echarts/ExtensionAPI}
     */

    this._api = api;
    /**
     * Should be cleaned when render.
     * @private
     * @type {Array.<Array.<Object>>}
     */

    this._lastDataByCoordSys = null;
    /**
     * @private
     * @type {boolean}
     */

    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
    var tooltipContent = this._tooltipContent;
    tooltipContent.update();
    tooltipContent.setEnterable(tooltipModel.get('enterable'));

    this._initGlobalListener();

    this._keepShow();
  },
  _initGlobalListener: function () {
    var tooltipModel = this._tooltipModel;
    var triggerOn = tooltipModel.get('triggerOn');
    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {
      // If 'none', it is not controlled by mouse totally.
      if (triggerOn !== 'none') {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e, dispatchAction);
        } else if (currTrigger === 'leave') {
          this._hide(dispatchAction);
        }
      }
    }, this));
  },
  _keepShow: function () {
    var tooltipModel = this._tooltipModel;
    var ecModel = this._ecModel;
    var api = this._api; // Try to keep the tooltip show when refreshing

    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,
    // self.manuallyShowTip({x, y}) might cause tooltip hide,
    // which is not expected.
    && tooltipModel.get('triggerOn') !== 'none') {
      var self = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function () {
        // Show tip next tick after other charts are rendered
        // In case highlight action has wrong result
        // FIXME
        self.manuallyShowTip(tooltipModel, ecModel, api, {
          x: self._lastX,
          y: self._lastY
        });
      });
    }
  },

  /**
   * Show tip manually by
   * dispatchAction({
   *     type: 'showTip',
   *     x: 10,
   *     y: 10
   * });
   * Or
   * dispatchAction({
   *      type: 'showTip',
   *      seriesIndex: 0,
   *      dataIndex or dataIndexInside or name
   * });
   *
   *  TODO Batch
   */
  manuallyShowTip: function (tooltipModel, ecModel, api, payload) {
    if (payload.from === this.uid || env.node) {
      return;
    }

    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket

    this._ticket = ''; // When triggered from axisPointer.

    var dataByCoordSys = payload.dataByCoordSys;

    if (payload.tooltip && payload.x != null && payload.y != null) {
      var el = proxyRect;
      el.position = [payload.x, payload.y];
      el.update();
      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.

      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        event: {},
        dataByCoordSys: payload.dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
        return;
      }

      var pointInfo = findPointFromSeries(payload, ecModel);
      var cx = pointInfo.point[0];
      var cy = pointInfo.point[1];

      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          position: payload.position,
          target: pointInfo.el,
          event: {}
        }, dispatchAction);
      }
    } else if (payload.x != null && payload.y != null) {
      // FIXME
      // should wrap dispatchAction like `axisPointer/globalListener` ?
      api.dispatchAction({
        type: 'updateAxisPointer',
        x: payload.x,
        y: payload.y
      });

      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api.getZr().findHover(payload.x, payload.y).target,
        event: {}
      }, dispatchAction);
    }
  },
  manuallyHideTip: function (tooltipModel, ecModel, api, payload) {
    var tooltipContent = this._tooltipContent;

    if (!this._alwaysShowContent) {
      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
    }

    this._lastX = this._lastY = null;

    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction(payload, api));
    }
  },
  // Be compatible with previous design, that is, when tooltip.type is 'axis' and
  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
  // and tooltip.
  _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {
    var seriesIndex = payload.seriesIndex;
    var dataIndex = payload.dataIndex;
    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;

    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }

    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);

    if (!seriesModel) {
      return;
    }

    var data = seriesModel.getData();
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);

    if (tooltipModel.get('trigger') !== 'axis') {
      return;
    }

    api.dispatchAction({
      type: 'updateAxisPointer',
      seriesIndex: seriesIndex,
      dataIndex: dataIndex,
      position: payload.position
    });
    return true;
  },
  _tryShow: function (e, dispatchAction) {
    var el = e.target;
    var tooltipModel = this._tooltipModel;

    if (!tooltipModel) {
      return;
    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed


    this._lastX = e.offsetX;
    this._lastY = e.offsetY;
    var dataByCoordSys = e.dataByCoordSys;

    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e);
    } // Always show item tooltip if mouse is on the element with dataIndex
    else if (el && el.dataIndex != null) {
        this._lastDataByCoordSys = null;

        this._showSeriesItemTooltip(e, el, dispatchAction);
      } // Tooltip provided directly. Like legend.
      else if (el && el.tooltip) {
          this._lastDataByCoordSys = null;

          this._showComponentItemTooltip(e, el, dispatchAction);
        } else {
          this._lastDataByCoordSys = null;

          this._hide(dispatchAction);
        }
  },
  _showOrMove: function (tooltipModel, cb) {
    // showDelay is used in this case: tooltip.enterable is set
    // as true. User intent to move mouse into tooltip and click
    // something. `showDelay` makes it easyer to enter the content
    // but tooltip do not move immediately.
    var delay = tooltipModel.get('showDelay');
    cb = zrUtil.bind(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  },
  _showAxisTooltip: function (dataByCoordSys, e) {
    var ecModel = this._ecModel;
    var globalTooltipModel = this._tooltipModel;
    var point = [e.offsetX, e.offsetY];
    var singleDefaultHTML = [];
    var singleParamsList = [];
    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);
    each(dataByCoordSys, function (itemCoordSys) {
      // var coordParamList = [];
      // var coordDefaultHTML = [];
      // var coordTooltipModel = buildTooltipModel([
      //     e.tooltipOption,
      //     itemCoordSys.tooltipOption,
      //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),
      //     globalTooltipModel
      // ]);
      // var displayMode = coordTooltipModel.get('displayMode');
      // var paramsList = displayMode === 'single' ? singleParamsList : [];
      each(itemCoordSys.dataByAxis, function (item) {
        var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);
        var axisValue = item.value;
        var seriesDefaultHTML = [];

        if (!axisModel || axisValue == null) {
          return;
        }

        var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);
        zrUtil.each(item.seriesDataIndices, function (idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var dataParams = series && series.getDataParams(dataIndex);
          dataParams.axisDim = item.axisDim;
          dataParams.axisIndex = item.axisIndex;
          dataParams.axisType = item.axisType;
          dataParams.axisId = item.axisId;
          dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);
          dataParams.axisValueLabel = valueLabel;

          if (dataParams) {
            singleParamsList.push(dataParams);
            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));
          }
        }); // Default tooltip content
        // FIXME
        // (1) shold be the first data which has name?
        // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.

        var firstLine = valueLabel;
        singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));
      });
    }, this); // In most case, the second axis is shown upper than the first one.

    singleDefaultHTML.reverse();
    singleDefaultHTML = singleDefaultHTML.join('<br /><br />');
    var positionExpr = e.position;

    this._showOrMove(singleTooltipModel, function () {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);
      }
    }); // Do not trigger events here, because this branch only be entered
    // from dispatchAction.

  },
  _showSeriesItemTooltip: function (e, el, dispatchAction) {
    var ecModel = this._ecModel; // Use dataModel in element if possible
    // Used when mouseover on a element like markPoint or edge
    // In which case, the data is not main data in series.

    var seriesIndex = el.seriesIndex;
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.

    var dataModel = el.dataModel || seriesModel;
    var dataIndex = el.dataIndex;
    var dataType = el.dataType;
    var data = dataModel.getData();
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
    var tooltipTrigger = tooltipModel.get('trigger');

    if (tooltipTrigger != null && tooltipTrigger !== 'item') {
      return;
    }

    var params = dataModel.getDataParams(dataIndex, dataType);
    var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);
    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;

    this._showOrMove(tooltipModel, function () {
      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);
    }); // FIXME
    // duplicated showtip if manuallyShowTip is called from dispatchAction.


    dispatchAction({
      type: 'showTip',
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex: seriesIndex,
      from: this.uid
    });
  },
  _showComponentItemTooltip: function (e, el, dispatchAction) {
    var tooltipOpt = el.tooltip;

    if (typeof tooltipOpt === 'string') {
      var content = tooltipOpt;
      tooltipOpt = {
        content: content,
        // Fixed formatter
        formatter: content
      };
    }

    var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);
    var defaultHtml = subTooltipModel.get('content');
    var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`
    // only works on cooridinate system. In fact, we have not found case
    // that requires setting `trigger` nothing on component yet.

    this._showOrMove(subTooltipModel, function () {
      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);
    }); // If not dispatch showTip, tip may be hide triggered by axis.


    dispatchAction({
      type: 'showTip',
      from: this.uid
    });
  },
  _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {
    // Reset ticket
    this._ticket = '';

    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
      return;
    }

    var tooltipContent = this._tooltipContent;
    var formatter = tooltipModel.get('formatter');
    positionExpr = positionExpr || tooltipModel.get('position');
    var html = defaultHtml;

    if (formatter && typeof formatter === 'string') {
      html = formatUtil.formatTpl(formatter, params, true);
    } else if (typeof formatter === 'function') {
      var callback = bind(function (cbTicket, html) {
        if (cbTicket === this._ticket) {
          tooltipContent.setContent(html);

          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
        }
      }, this);
      this._ticket = asyncTicket;
      html = formatter(params, asyncTicket, callback);
    }

    tooltipContent.setContent(html);
    tooltipContent.show(tooltipModel);

    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
  },

  /**
   * @param  {string|Function|Array.<number>|Object} positionExpr
   * @param  {number} x Mouse x
   * @param  {number} y Mouse y
   * @param  {boolean} confine Whether confine tooltip content in view rect.
   * @param  {Object|<Array.<Object>} params
   * @param  {module:zrender/Element} el target element
   * @param  {module:echarts/ExtensionAPI} api
   * @return {Array.<number>}
   */
  _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {
    var viewWidth = this._api.getWidth();

    var viewHeight = this._api.getHeight();

    positionExpr = positionExpr || tooltipModel.get('position');
    var contentSize = content.getSize();
    var align = tooltipModel.get('align');
    var vAlign = tooltipModel.get('verticalAlign');
    var rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);

    if (typeof positionExpr === 'function') {
      // Callback of position can be an array or a string specify the position
      positionExpr = positionExpr([x, y], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }

    if (zrUtil.isArray(positionExpr)) {
      x = parsePercent(positionExpr[0], viewWidth);
      y = parsePercent(positionExpr[1], viewHeight);
    } else if (zrUtil.isObject(positionExpr)) {
      positionExpr.width = contentSize[0];
      positionExpr.height = contentSize[1];
      var layoutRect = layoutUtil.getLayoutRect(positionExpr, {
        width: viewWidth,
        height: viewHeight
      });
      x = layoutRect.x;
      y = layoutRect.y;
      align = null; // When positionExpr is left/top/right/bottom,
      // align and verticalAlign will not work.

      vAlign = null;
    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
    else if (typeof positionExpr === 'string' && el) {
        var pos = calcTooltipPosition(positionExpr, rect, contentSize);
        x = pos[0];
        y = pos[1];
      } else {
        var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
        x = pos[0];
        y = pos[1];
      }

    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);

    if (tooltipModel.get('confine')) {
      var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);
      x = pos[0];
      y = pos[1];
    }

    content.moveTo(x, y);
  },
  // FIXME
  // Should we remove this but leave this to user?
  _updateContentNotChangedOnAxis: function (dataByCoordSys) {
    var lastCoordSys = this._lastDataByCoordSys;
    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
      var lastDataByAxis = lastItemCoordSys.dataByAxis || {};
      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {
        var thisItem = thisDataByAxis[indexAxis] || {};
        var lastIndices = lastItem.seriesDataIndices || [];
        var newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {
          var newIdxItem = newIndices[j];
          contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    return !!contentNotChanged;
  },
  _hide: function (dispatchAction) {
    // Do not directly hideLater here, because this behavior may be prevented
    // in dispatchAction when showTip is dispatched.
    // FIXME
    // duplicated hideTip if manuallyHideTip is called from dispatchAction.
    this._lastDataByCoordSys = null;
    dispatchAction({
      type: 'hideTip',
      from: this.uid
    });
  },
  dispose: function (ecModel, api) {
    if (env.node) {
      return;
    }

    this._tooltipContent.hide();

    globalListener.unregister('itemTooltip', api);
  }
});
/**
 * @param {Array.<Object|module:echarts/model/Model>} modelCascade
 * From top to bottom. (the last one should be globalTooltipModel);
 */


function buildTooltipModel(modelCascade) {
  var resultModel = modelCascade.pop();

  while (modelCascade.length) {
    var tooltipOpt = modelCascade.pop();

    if (tooltipOpt) {
      if (tooltipOpt instanceof Model) {
        tooltipOpt = tooltipOpt.get('tooltip', true);
      } // In each data item tooltip can be simply write:
      // {
      //  value: 10,
      //  tooltip: 'Something you need to know'
      // }


      if (typeof tooltipOpt === 'string') {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }

      resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);
    }
  }

  return resultModel;
}

function makeDispatchAction(payload, api) {
  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
}

function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {
  var size = getOuterSize(el);
  var width = size.width;
  var height = size.height;

  if (gapH != null) {
    if (x + width + gapH > viewWidth) {
      x -= width + gapH;
    } else {
      x += gapH;
    }
  }

  if (gapV != null) {
    if (y + height + gapV > viewHeight) {
      y -= height + gapV;
    } else {
      y += gapV;
    }
  }

  return [x, y];
}

function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {
  var size = getOuterSize(el);
  var width = size.width;
  var height = size.height;
  x = Math.min(x + width, viewWidth) - width;
  y = Math.min(y + height, viewHeight) - height;
  x = Math.max(x, 0);
  y = Math.max(y, 0);
  return [x, y];
}

function getOuterSize(el) {
  var width = el.clientWidth;
  var height = el.clientHeight; // Consider browser compatibility.
  // IE8 does not support getComputedStyle.

  if (document.defaultView && document.defaultView.getComputedStyle) {
    var stl = document.defaultView.getComputedStyle(el);

    if (stl) {
      width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
      height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
    }
  }

  return {
    width: width,
    height: height
  };
}

function calcTooltipPosition(position, rect, contentSize) {
  var domWidth = contentSize[0];
  var domHeight = contentSize[1];
  var gap = 5;
  var x = 0;
  var y = 0;
  var rectWidth = rect.width;
  var rectHeight = rect.height;

  switch (position) {
    case 'inside':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;

    case 'top':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y - domHeight - gap;
      break;

    case 'bottom':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight + gap;
      break;

    case 'left':
      x = rect.x - domWidth - gap;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;

    case 'right':
      x = rect.x + rectWidth + gap;
      y = rect.y + rectHeight / 2 - domHeight / 2;
  }

  return [x, y];
}

function isCenterAlign(align) {
  return align === 'center' || align === 'middle';
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/config.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// (1) The code `if (__DEV__) ...` can be removed by build tool.
// (2) If intend to use `__DEV__`, this module should be imported. Use a global
// variable `__DEV__` may cause that miss the declaration (see #6535), or the
// declaration is behind of the using position (for example in `Model.extent`,
// And tools like rollup can not analysis the dependency if not import).
var dev; // In browser

if (typeof window !== 'undefined') {
  dev = window.__DEV__;
} // In node
else if (typeof global !== 'undefined') {
    dev = global.__DEV__;
  }

if (typeof dev === 'undefined') {
  dev = true;
}

var __DEV__ = dev;
exports.__DEV__ = __DEV__;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/echarts/lib/coord/Axis.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

var linearMap = numberUtil.linearMap;

function fixExtentWithBands(extent, nTick) {
  var size = extent[1] - extent[0];
  var len = nTick;
  var margin = size / len / 2;
  extent[0] += margin;
  extent[1] -= margin;
}

var normalizedExtent = [0, 1];
/**
 * @name module:echarts/coord/CartesianAxis
 * @constructor
 */

var Axis = function (dim, scale, extent) {
  /**
   * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'
   * @type {string}
   */
  this.dim = dim;
  /**
   * Axis scale
   * @type {module:echarts/coord/scale/*}
   */

  this.scale = scale;
  /**
   * @type {Array.<number>}
   * @private
   */

  this._extent = extent || [0, 0];
  /**
   * @type {boolean}
   */

  this.inverse = false;
  /**
   * Usually true when axis has a ordinal scale
   * @type {boolean}
   */

  this.onBand = false;
  /**
   * @private
   * @type {number}
   */

  this._labelInterval;
};

Axis.prototype = {
  constructor: Axis,

  /**
   * If axis extent contain given coord
   * @param {number} coord
   * @return {boolean}
   */
  contain: function (coord) {
    var extent = this._extent;
    var min = Math.min(extent[0], extent[1]);
    var max = Math.max(extent[0], extent[1]);
    return coord >= min && coord <= max;
  },

  /**
   * If axis extent contain given data
   * @param {number} data
   * @return {boolean}
   */
  containData: function (data) {
    return this.contain(this.dataToCoord(data));
  },

  /**
   * Get coord extent.
   * @return {Array.<number>}
   */
  getExtent: function () {
    return this._extent.slice();
  },

  /**
   * Get precision used for formatting
   * @param {Array.<number>} [dataExtent]
   * @return {number}
   */
  getPixelPrecision: function (dataExtent) {
    return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  },

  /**
   * Set coord extent
   * @param {number} start
   * @param {number} end
   */
  setExtent: function (start, end) {
    var extent = this._extent;
    extent[0] = start;
    extent[1] = end;
  },

  /**
   * Convert data to coord. Data is the rank if it has a ordinal scale
   * @param {number} data
   * @param  {boolean} clamp
   * @return {number}
   */
  dataToCoord: function (data, clamp) {
    var extent = this._extent;
    var scale = this.scale;
    data = scale.normalize(data);

    if (this.onBand && scale.type === 'ordinal') {
      extent = extent.slice();
      fixExtentWithBands(extent, scale.count());
    }

    return linearMap(data, normalizedExtent, extent, clamp);
  },

  /**
   * Convert coord to data. Data is the rank if it has a ordinal scale
   * @param {number} coord
   * @param  {boolean} clamp
   * @return {number}
   */
  coordToData: function (coord, clamp) {
    var extent = this._extent;
    var scale = this.scale;

    if (this.onBand && scale.type === 'ordinal') {
      extent = extent.slice();
      fixExtentWithBands(extent, scale.count());
    }

    var t = linearMap(coord, extent, normalizedExtent, clamp);
    return this.scale.scale(t);
  },

  /**
   * Convert pixel point to data in axis
   * @param {Array.<number>} point
   * @param  {boolean} clamp
   * @return {number} data
   */
  pointToData: function (point, clamp) {// Should be implemented in derived class if necessary.
  },

  /**
   * @return {Array.<number>}
   */
  getTicksCoords: function (alignWithLabel) {
    if (this.onBand && !alignWithLabel) {
      var bands = this.getBands();
      var coords = [];

      for (var i = 0; i < bands.length; i++) {
        coords.push(bands[i][0]);
      }

      if (bands[i - 1]) {
        coords.push(bands[i - 1][1]);
      }

      return coords;
    } else {
      return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
    }
  },

  /**
   * Coords of labels are on the ticks or on the middle of bands
   * @return {Array.<number>}
   */
  getLabelsCoords: function () {
    return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
  },

  /**
   * Get bands.
   *
   * If axis has labels [1, 2, 3, 4]. Bands on the axis are
   * |---1---|---2---|---3---|---4---|.
   *
   * @return {Array}
   */
  // FIXME Situation when labels is on ticks
  getBands: function () {
    var extent = this.getExtent();
    var bands = [];
    var len = this.scale.count();
    var start = extent[0];
    var end = extent[1];
    var span = end - start;

    for (var i = 0; i < len; i++) {
      bands.push([span * i / len + start, span * (i + 1) / len + start]);
    }

    return bands;
  },

  /**
   * Get width of band
   * @return {number}
   */
  getBandWidth: function () {
    var axisExtent = this._extent;
    var dataExtent = this.scale.getExtent();
    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.

    len === 0 && (len = 1);
    var size = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size) / len;
  },

  /**
   * @abstract
   * @return {boolean} Is horizontal
   */
  isHorizontal: null,

  /**
   * @abstract
   * @return {number} Get axis rotate, by degree.
   */
  getRotate: null,

  /**
   * Get interval of the axis label.
   * To get precise result, at least one of `getRotate` and `isHorizontal`
   * should be implemented.
   * @return {number}
   */
  getLabelInterval: function () {
    var labelInterval = this._labelInterval;

    if (!labelInterval) {
      var axisModel = this.model;
      var labelModel = axisModel.getModel('axisLabel');
      labelInterval = labelModel.get('interval');

      if (this.type === 'category' && (labelInterval == null || labelInterval === 'auto')) {
        labelInterval = axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisModel.getFormattedLabels(), labelModel.getFont(), this.getRotate ? this.getRotate() : this.isHorizontal && !this.isHorizontal() ? 90 : 0, labelModel.get('rotate'));
      }

      this._labelInterval = labelInterval;
    }

    return labelInterval;
  }
};
var _default = Axis;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisDefault.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var defaultOption = {
  show: true,
  zlevel: 0,
  // 一级层叠
  z: 0,
  // 二级层叠
  // 反向坐标轴
  inverse: false,
  // 坐标轴名字，默认为空
  name: '',
  // 坐标轴名字位置，支持'start' | 'middle' | 'end'
  nameLocation: 'end',
  // 坐标轴名字旋转，degree。
  nameRotate: null,
  // Adapt to axis rotate, when nameLocation is 'middle'.
  nameTruncate: {
    maxWidth: null,
    ellipsis: '...',
    placeholder: '.'
  },
  // 坐标轴文字样式，默认取全局样式
  nameTextStyle: {},
  // 文字与轴线距离
  nameGap: 15,
  silent: false,
  // Default false to support tooltip.
  triggerEvent: false,
  // Default false to avoid legacy user event listener fail.
  tooltip: {
    show: false
  },
  axisPointer: {},
  // 坐标轴线
  axisLine: {
    // 默认显示，属性show控制显示与否
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    // 属性lineStyle控制线条样式
    lineStyle: {
      color: '#333',
      width: 1,
      type: 'solid'
    },
    // 坐标轴两端的箭头
    symbol: ['none', 'none'],
    symbolSize: [10, 15]
  },
  // 坐标轴小标记
  axisTick: {
    // 属性show控制显示与否，默认显示
    show: true,
    // 控制小标记是否在grid里
    inside: false,
    // 属性length控制线长
    length: 5,
    // 属性lineStyle控制线条样式
    lineStyle: {
      width: 1
    }
  },
  // 坐标轴文本标签，详见axis.axisLabel
  axisLabel: {
    show: true,
    // 控制文本标签是否在grid里
    inside: false,
    rotate: 0,
    showMinLabel: null,
    // true | false | null (auto)
    showMaxLabel: null,
    // true | false | null (auto)
    margin: 8,
    // formatter: null,
    // 其余属性默认使用全局文本样式，详见TEXTSTYLE
    fontSize: 12
  },
  // 分隔线
  splitLine: {
    // 默认显示，属性show控制显示与否
    show: true,
    // 属性lineStyle（详见lineStyle）控制线条样式
    lineStyle: {
      color: ['#ccc'],
      width: 1,
      type: 'solid'
    }
  },
  // 分隔区域
  splitArea: {
    // 默认不显示，属性show控制显示与否
    show: false,
    // 属性areaStyle（详见areaStyle）控制区域样式
    areaStyle: {
      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']
    }
  }
};
var axisDefault = {};
axisDefault.categoryAxis = zrUtil.merge({
  // 类目起始和结束两端空白策略
  boundaryGap: true,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: false
  },
  // 坐标轴小标记
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: false,
    interval: 'auto'
  },
  // 坐标轴文本标签，详见axis.axisLabel
  axisLabel: {
    interval: 'auto'
  }
}, defaultOption);
axisDefault.valueAxis = zrUtil.merge({
  // 数值起始和结束两端空白策略
  boundaryGap: [0, 0],
  // 最小值, 设置成 'dataMin' 则从数据中计算最小值
  // min: null,
  // 最大值，设置成 'dataMax' 则从数据中计算最大值
  // max: null,
  // Readonly prop, specifies start value of the range when using data zoom.
  // rangeStart: null
  // Readonly prop, specifies end value of the range when using data zoom.
  // rangeEnd: null
  // 脱离0值比例，放大聚焦到最终_min，_max区间
  // scale: false,
  // 分割段数，默认为5
  splitNumber: 5 // Minimum interval
  // minInterval: null
  // maxInterval: null

}, defaultOption); // FIXME

axisDefault.timeAxis = zrUtil.defaults({
  scale: true,
  min: 'dataMin',
  max: 'dataMax'
}, axisDefault.valueAxis);
axisDefault.logAxis = zrUtil.defaults({
  scale: true,
  logBase: 10
}, axisDefault.valueAxis);
var _default = axisDefault;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var OrdinalScale = __webpack_require__("./node_modules/echarts/lib/scale/Ordinal.js");

var IntervalScale = __webpack_require__("./node_modules/echarts/lib/scale/Interval.js");

var Scale = __webpack_require__("./node_modules/echarts/lib/scale/Scale.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

__webpack_require__("./node_modules/echarts/lib/scale/Time.js");

__webpack_require__("./node_modules/echarts/lib/scale/Log.js");

/**
 * Get axis scale extent before niced.
 * Item of returned array can only be number (including Infinity and NaN).
 */
function getScaleExtent(scale, model) {
  var scaleType = scale.type;
  var min = model.getMin();
  var max = model.getMax();
  var fixMin = min != null;
  var fixMax = max != null;
  var originalExtent = scale.getExtent();
  var axisDataLen;
  var boundaryGap;
  var span;

  if (scaleType === 'ordinal') {
    axisDataLen = (model.get('data') || []).length;
  } else {
    boundaryGap = model.get('boundaryGap');

    if (!zrUtil.isArray(boundaryGap)) {
      boundaryGap = [boundaryGap || 0, boundaryGap || 0];
    }

    if (typeof boundaryGap[0] === 'boolean') {
      boundaryGap = [0, 0];
    }

    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);
    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);
    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);
  } // Notice: When min/max is not set (that is, when there are null/undefined,
  // which is the most common case), these cases should be ensured:
  // (1) For 'ordinal', show all axis.data.
  // (2) For others:
  //      + `boundaryGap` is applied (if min/max set, boundaryGap is
  //      disabled).
  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should
  //      be the result that originalExtent enlarged by boundaryGap.
  // (3) If no data, it should be ensured that `scale.setBlank` is set.
  // FIXME
  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?
  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured
  // that the results processed by boundaryGap are positive/negative?


  if (min == null) {
    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;
  }

  if (max == null) {
    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;
  }

  if (min === 'dataMin') {
    min = originalExtent[0];
  } else if (typeof min === 'function') {
    min = min({
      min: originalExtent[0],
      max: originalExtent[1]
    });
  }

  if (max === 'dataMax') {
    max = originalExtent[1];
  } else if (typeof max === 'function') {
    max = max({
      min: originalExtent[0],
      max: originalExtent[1]
    });
  }

  (min == null || !isFinite(min)) && (min = NaN);
  (max == null || !isFinite(max)) && (max = NaN);
  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max)); // Evaluate if axis needs cross zero

  if (model.getNeedCrossZero()) {
    // Axis is over zero and min is not set
    if (min > 0 && max > 0 && !fixMin) {
      min = 0;
    } // Axis is under zero and max is not set


    if (min < 0 && max < 0 && !fixMax) {
      max = 0;
    }
  }

  return [min, max];
}

function niceScaleExtent(scale, model) {
  var extent = getScaleExtent(scale, model);
  var fixMin = model.getMin() != null;
  var fixMax = model.getMax() != null;
  var splitNumber = model.get('splitNumber');

  if (scale.type === 'log') {
    scale.base = model.get('logBase');
  }

  var scaleType = scale.type;
  scale.setExtent(extent[0], extent[1]);
  scale.niceExtent({
    splitNumber: splitNumber,
    fixMin: fixMin,
    fixMax: fixMax,
    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,
    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null
  }); // If some one specified the min, max. And the default calculated interval
  // is not good enough. He can specify the interval. It is often appeared
  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
  // to be 60.
  // FIXME

  var interval = model.get('interval');

  if (interval != null) {
    scale.setInterval && scale.setInterval(interval);
  }
}
/**
 * @param {module:echarts/model/Model} model
 * @param {string} [axisType] Default retrieve from model.type
 * @return {module:echarts/scale/*}
 */


function createScaleByModel(model, axisType) {
  axisType = axisType || model.get('type');

  if (axisType) {
    switch (axisType) {
      // Buildin scale
      case 'category':
        return new OrdinalScale(model.getCategories(), [Infinity, -Infinity]);

      case 'value':
        return new IntervalScale();
      // Extended scale, like time and log

      default:
        return (Scale.getClass(axisType) || IntervalScale).create(model);
    }
  }
}
/**
 * Check if the axis corss 0
 */


function ifAxisCrossZero(axis) {
  var dataExtent = axis.scale.getExtent();
  var min = dataExtent[0];
  var max = dataExtent[1];
  return !(min > 0 && max > 0 || min < 0 && max < 0);
}
/**
 * @param {Array.<number>} tickCoords In axis self coordinate.
 * @param {Array.<string>} labels
 * @param {string} font
 * @param {number} axisRotate 0: towards right horizontally, clock-wise is negative.
 * @param {number} [labelRotate=0] 0: towards right horizontally, clock-wise is negative.
 * @return {number}
 */


function getAxisLabelInterval(tickCoords, labels, font, axisRotate, labelRotate) {
  var textSpaceTakenRect;
  var autoLabelInterval = 0;
  var accumulatedLabelInterval = 0;
  var rotation = (axisRotate - labelRotate) / 180 * Math.PI;
  var step = 1;

  if (labels.length > 40) {
    // Simple optimization for large amount of labels
    step = Math.floor(labels.length / 40);
  }

  for (var i = 0; i < tickCoords.length; i += step) {
    var tickCoord = tickCoords[i]; // Not precise, do not consider align and vertical align
    // and each distance from axis line yet.

    var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');
    rect.x += tickCoord * Math.cos(rotation);
    rect.y += tickCoord * Math.sin(rotation); // Magic number

    rect.width *= 1.3;
    rect.height *= 1.3;

    if (!textSpaceTakenRect) {
      textSpaceTakenRect = rect.clone();
    } // There is no space for current label;
    else if (textSpaceTakenRect.intersect(rect)) {
        accumulatedLabelInterval++;
        autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);
      } else {
        textSpaceTakenRect.union(rect); // Reset

        accumulatedLabelInterval = 0;
      }
  }

  if (autoLabelInterval === 0 && step > 1) {
    return step;
  }

  return (autoLabelInterval + 1) * step - 1;
}
/**
 * @param {Object} axis
 * @param {Function} labelFormatter
 * @return {Array.<string>}
 */


function getFormattedLabels(axis, labelFormatter) {
  var scale = axis.scale;
  var labels = scale.getTicksLabels();
  var ticks = scale.getTicks();

  if (typeof labelFormatter === 'string') {
    labelFormatter = function (tpl) {
      return function (val) {
        return tpl.replace('{value}', val != null ? val : '');
      };
    }(labelFormatter); // Consider empty array


    return zrUtil.map(labels, labelFormatter);
  } else if (typeof labelFormatter === 'function') {
    return zrUtil.map(ticks, function (tick, idx) {
      return labelFormatter(getAxisRawValue(axis, tick), idx);
    }, this);
  } else {
    return labels;
  }
}

function getAxisRawValue(axis, value) {
  // In category axis with data zoom, tick is not the original
  // index of axis.data. So tick should not be exposed to user
  // in category axis.
  return axis.type === 'category' ? axis.scale.getLabel(value) : value;
}

exports.getScaleExtent = getScaleExtent;
exports.niceScaleExtent = niceScaleExtent;
exports.createScaleByModel = createScaleByModel;
exports.ifAxisCrossZero = ifAxisCrossZero;
exports.getAxisLabelInterval = getAxisLabelInterval;
exports.getFormattedLabels = getFormattedLabels;
exports.getAxisRawValue = getAxisRawValue;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisModelCommonMixin.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

function getName(obj) {
  if (zrUtil.isObject(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + '';
  }
}

var _default = {
  /**
   * Format labels
   * @return {Array.<string>}
   */
  getFormattedLabels: function () {
    return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));
  },

  /**
   * Get categories
   */
  getCategories: function () {
    return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);
  },

  /**
   * @param {boolean} origin
   * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN
   */
  getMin: function (origin) {
    var option = this.option;
    var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;

    if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !zrUtil.eqNaN(min)) {
      min = this.axis.scale.parse(min);
    }

    return min;
  },

  /**
   * @param {boolean} origin
   * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN
   */
  getMax: function (origin) {
    var option = this.option;
    var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;

    if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !zrUtil.eqNaN(max)) {
      max = this.axis.scale.parse(max);
    }

    return max;
  },

  /**
   * @return {boolean}
   */
  getNeedCrossZero: function () {
    var option = this.option;
    return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;
  },

  /**
   * Should be implemented by each axis model if necessary.
   * @return {module:echarts/model/Component} coordinate system model
   */
  getCoordSysModel: zrUtil.noop,

  /**
   * @param {number} rangeStart Can only be finite number or null/undefined or NaN.
   * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.
   */
  setRange: function (rangeStart, rangeEnd) {
    this.option.rangeStart = rangeStart;
    this.option.rangeEnd = rangeEnd;
  },

  /**
   * Reset range
   */
  resetRange: function () {
    // rangeStart and rangeEnd is readonly.
    this.option.rangeStart = this.option.rangeEnd = null;
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisModelCreator.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var axisDefault = __webpack_require__("./node_modules/echarts/lib/coord/axisDefault.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutParams = _layout.getLayoutParams;
var mergeLayoutParam = _layout.mergeLayoutParam;
// FIXME axisType is fixed ?
var AXIS_TYPES = ['value', 'category', 'time', 'log'];
/**
 * Generate sub axis model class
 * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
 * @param {module:echarts/model/Component} BaseAxisModelClass
 * @param {Function} axisTypeDefaulter
 * @param {Object} [extraDefaultOption]
 */

function _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
  zrUtil.each(AXIS_TYPES, function (axisType) {
    BaseAxisModelClass.extend({
      type: axisName + 'Axis.' + axisType,
      mergeDefaultAndTheme: function (option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));
        zrUtil.merge(option, this.getDefaultOption());
        option.type = axisTypeDefaulter(axisName, option);

        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      },
      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)
    });
  });
  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Axis2D.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Axis = __webpack_require__("./node_modules/echarts/lib/coord/Axis.js");

/**
 * Extend axis 2d
 * @constructor module:echarts/coord/cartesian/Axis2D
 * @extends {module:echarts/coord/cartesian/Axis}
 * @param {string} dim
 * @param {*} scale
 * @param {Array.<number>} coordExtent
 * @param {string} axisType
 * @param {string} position
 */
var Axis2D = function (dim, scale, coordExtent, axisType, position) {
  Axis.call(this, dim, scale, coordExtent);
  /**
   * Axis type
   *  - 'category'
   *  - 'value'
   *  - 'time'
   *  - 'log'
   * @type {string}
   */

  this.type = axisType || 'value';
  /**
   * Axis position
   *  - 'top'
   *  - 'bottom'
   *  - 'left'
   *  - 'right'
   */

  this.position = position || 'bottom';
};

Axis2D.prototype = {
  constructor: Axis2D,

  /**
   * Index of axis, can be used as key
   */
  index: 0,

  /**
   * If axis is on the zero position of the other axis
   * @type {boolean}
   */
  onZero: false,

  /**
   * Axis model
   * @param {module:echarts/coord/cartesian/AxisModel}
   */
  model: null,
  isHorizontal: function () {
    var position = this.position;
    return position === 'top' || position === 'bottom';
  },

  /**
   * Each item cooresponds to this.getExtent(), which
   * means globalExtent[0] may greater than globalExtent[1],
   * unless `asc` is input.
   *
   * @param {boolean} [asc]
   * @return {Array.<number>}
   */
  getGlobalExtent: function (asc) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc && ret[0] > ret[1] && ret.reverse();
    return ret;
  },
  getOtherAxis: function () {
    this.grid.getOtherAxis();
  },

  /**
   * If label is ignored.
   * Automatically used when axis is category and label can not be all shown
   * @param  {number}  idx
   * @return {boolean}
   */
  isLabelIgnored: function (idx) {
    if (this.type === 'category') {
      var labelInterval = this.getLabelInterval();
      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);
    }
  },

  /**
   * @override
   */
  pointToData: function (point, clamp) {
    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);
  },

  /**
   * Transform global coord to local coord,
   * i.e. var localCoord = axis.toLocalCoord(80);
   * designate by module:echarts/coord/cartesian/Grid.
   * @type {Function}
   */
  toLocalCoord: null,

  /**
   * Transform global coord to local coord,
   * i.e. var globalCoord = axis.toLocalCoord(40);
   * designate by module:echarts/coord/cartesian/Grid.
   * @type {Function}
   */
  toGlobalCoord: null
};
zrUtil.inherits(Axis2D, Axis);
var _default = Axis2D;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/AxisModel.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var axisModelCreator = __webpack_require__("./node_modules/echarts/lib/coord/axisModelCreator.js");

var axisModelCommonMixin = __webpack_require__("./node_modules/echarts/lib/coord/axisModelCommonMixin.js");

var AxisModel = ComponentModel.extend({
  type: 'cartesian2dAxis',

  /**
   * @type {module:echarts/coord/cartesian/Axis2D}
   */
  axis: null,

  /**
   * @override
   */
  init: function () {
    AxisModel.superApply(this, 'init', arguments);
    this.resetRange();
  },

  /**
   * @override
   */
  mergeOption: function () {
    AxisModel.superApply(this, 'mergeOption', arguments);
    this.resetRange();
  },

  /**
   * @override
   */
  restoreData: function () {
    AxisModel.superApply(this, 'restoreData', arguments);
    this.resetRange();
  },

  /**
   * @override
   * @return {module:echarts/model/Component}
   */
  getCoordSysModel: function () {
    return this.ecModel.queryComponents({
      mainType: 'grid',
      index: this.option.gridIndex,
      id: this.option.gridId
    })[0];
  }
});

function getAxisType(axisDim, option) {
  // Default axis with data is category axis
  return option.type || (option.data ? 'category' : 'value');
}

zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
var extraOption = {
  // gridIndex: 0,
  // gridId: '',
  // Offset is for multiple axis on the same position
  offset: 0
};
axisModelCreator('x', AxisModel, getAxisType, extraOption);
axisModelCreator('y', AxisModel, getAxisType, extraOption);
var _default = AxisModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Cartesian.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/**
 * Cartesian coordinate system
 * @module  echarts/coord/Cartesian
 *
 */
function dimAxisMapper(dim) {
  return this._axes[dim];
}
/**
 * @alias module:echarts/coord/Cartesian
 * @constructor
 */


var Cartesian = function (name) {
  this._axes = {};
  this._dimList = [];
  /**
   * @type {string}
   */

  this.name = name || '';
};

Cartesian.prototype = {
  constructor: Cartesian,
  type: 'cartesian',

  /**
   * Get axis
   * @param  {number|string} dim
   * @return {module:echarts/coord/Cartesian~Axis}
   */
  getAxis: function (dim) {
    return this._axes[dim];
  },

  /**
   * Get axes list
   * @return {Array.<module:echarts/coord/Cartesian~Axis>}
   */
  getAxes: function () {
    return zrUtil.map(this._dimList, dimAxisMapper, this);
  },

  /**
   * Get axes list by given scale type
   */
  getAxesByScale: function (scaleType) {
    scaleType = scaleType.toLowerCase();
    return zrUtil.filter(this.getAxes(), function (axis) {
      return axis.scale.type === scaleType;
    });
  },

  /**
   * Add axis
   * @param {module:echarts/coord/Cartesian.Axis}
   */
  addAxis: function (axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;

    this._dimList.push(dim);
  },

  /**
   * Convert data to coord in nd space
   * @param {Array.<number>|Object.<string, number>} val
   * @return {Array.<number>|Object.<string, number>}
   */
  dataToCoord: function (val) {
    return this._dataCoordConvert(val, 'dataToCoord');
  },

  /**
   * Convert coord in nd space to data
   * @param  {Array.<number>|Object.<string, number>} val
   * @return {Array.<number>|Object.<string, number>}
   */
  coordToData: function (val) {
    return this._dataCoordConvert(val, 'coordToData');
  },
  _dataCoordConvert: function (input, method) {
    var dimList = this._dimList;
    var output = input instanceof Array ? [] : {};

    for (var i = 0; i < dimList.length; i++) {
      var dim = dimList[i];
      var axis = this._axes[dim];
      output[dim] = axis[method](input[dim]);
    }

    return output;
  }
};
var _default = Cartesian;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Cartesian = __webpack_require__("./node_modules/echarts/lib/coord/cartesian/Cartesian.js");

function Cartesian2D(name) {
  Cartesian.call(this, name);
}

Cartesian2D.prototype = {
  constructor: Cartesian2D,
  type: 'cartesian2d',

  /**
   * @type {Array.<string>}
   * @readOnly
   */
  dimensions: ['x', 'y'],

  /**
   * Base axis will be used on stacking.
   *
   * @return {module:echarts/coord/cartesian/Axis2D}
   */
  getBaseAxis: function () {
    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
  },

  /**
   * If contain point
   * @param {Array.<number>} point
   * @return {boolean}
   */
  containPoint: function (point) {
    var axisX = this.getAxis('x');
    var axisY = this.getAxis('y');
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  },

  /**
   * If contain data
   * @param {Array.<number>} data
   * @return {boolean}
   */
  containData: function (data) {
    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
  },

  /**
   * @param {Array.<number>} data
   * @param {boolean} [clamp=false]
   * @return {Array.<number>}
   */
  dataToPoint: function (data, clamp) {
    var xAxis = this.getAxis('x');
    var yAxis = this.getAxis('y');
    return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];
  },

  /**
   * @param {Array.<number>} point
   * @param {boolean} [clamp=false]
   * @return {Array.<number>}
   */
  pointToData: function (point, clamp) {
    var xAxis = this.getAxis('x');
    var yAxis = this.getAxis('y');
    return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];
  },

  /**
   * Get other axis
   * @param {module:echarts/coord/cartesian/Axis2D} axis
   */
  getOtherAxis: function (axis) {
    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
  }
};
zrUtil.inherits(Cartesian2D, Cartesian);
var _default = Cartesian2D;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Grid.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutRect = _layout.getLayoutRect;

var axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

var Cartesian2D = __webpack_require__("./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js");

var Axis2D = __webpack_require__("./node_modules/echarts/lib/coord/cartesian/Axis2D.js");

var CoordinateSystem = __webpack_require__("./node_modules/echarts/lib/CoordinateSystem.js");

__webpack_require__("./node_modules/echarts/lib/coord/cartesian/GridModel.js");

/**
 * Grid is a region which contains at most 4 cartesian systems
 *
 * TODO Default cartesian
 */
// Depends on GridModel, AxisModel, which performs preprocess.
var each = zrUtil.each;
var ifAxisCrossZero = axisHelper.ifAxisCrossZero;
var niceScaleExtent = axisHelper.niceScaleExtent;
/**
 * Check if the axis is used in the specified grid
 * @inner
 */

function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
  return axisModel.getCoordSysModel() === gridModel;
}

function rotateTextRect(textRect, rotate) {
  var rotateRadians = rotate * Math.PI / 180;
  var boundingBox = textRect.plain();
  var beforeWidth = boundingBox.width;
  var beforeHeight = boundingBox.height;
  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);
  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);
  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);
  return rotatedRect;
}

function getLabelUnionRect(axis) {
  var axisModel = axis.model;
  var labels = axisModel.getFormattedLabels();
  var axisLabelModel = axisModel.getModel('axisLabel');
  var rect;
  var step = 1;
  var labelCount = labels.length;

  if (labelCount > 40) {
    // Simple optimization for large amount of labels
    step = Math.ceil(labelCount / 40);
  }

  for (var i = 0; i < labelCount; i += step) {
    if (!axis.isLabelIgnored(i)) {
      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);
      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);
      rect ? rect.union(singleRect) : rect = singleRect;
    }
  }

  return rect;
}

function Grid(gridModel, ecModel, api) {
  /**
   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
   * @private
   */
  this._coordsMap = {};
  /**
   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
   * @private
   */

  this._coordsList = [];
  /**
   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}
   * @private
   */

  this._axesMap = {};
  /**
   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
   * @private
   */

  this._axesList = [];

  this._initCartesian(gridModel, ecModel, api);

  this.model = gridModel;
}

var gridProto = Grid.prototype;
gridProto.type = 'grid';
gridProto.axisPointerEnabled = true;

gridProto.getRect = function () {
  return this._rect;
};

gridProto.update = function (ecModel, api) {
  var axesMap = this._axesMap;

  this._updateScale(ecModel, this.model);

  each(axesMap.x, function (xAxis) {
    niceScaleExtent(xAxis.scale, xAxis.model);
  });
  each(axesMap.y, function (yAxis) {
    niceScaleExtent(yAxis.scale, yAxis.model);
  });
  each(axesMap.x, function (xAxis) {
    fixAxisOnZero(axesMap, 'y', xAxis);
  });
  each(axesMap.y, function (yAxis) {
    fixAxisOnZero(axesMap, 'x', yAxis);
  }); // Resize again if containLabel is enabled
  // FIXME It may cause getting wrong grid size in data processing stage

  this.resize(this.model, api);
};

function fixAxisOnZero(axesMap, otherAxisDim, axis) {
  // onZero can not be enabled in these two situations:
  // 1. When any other axis is a category axis.
  // 2. When no axis is cross 0 point.
  var axes = axesMap[otherAxisDim];

  if (!axis.onZero) {
    return;
  }

  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.

  if (onZeroAxisIndex != null) {
    var otherAxis = axes[onZeroAxisIndex];

    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {
      axis.onZero = false;
    }

    return;
  }

  for (var idx in axes) {
    if (axes.hasOwnProperty(idx)) {
      var otherAxis = axes[idx];

      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {
        onZeroAxisIndex = +idx;
        break;
      }
    }
  }

  if (onZeroAxisIndex == null) {
    axis.onZero = false;
  }

  axis.onZeroAxisIndex = onZeroAxisIndex;
}

function canNotOnZeroToAxis(axis) {
  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);
}
/**
 * Resize the grid
 * @param {module:echarts/coord/cartesian/GridModel} gridModel
 * @param {module:echarts/ExtensionAPI} api
 */


gridProto.resize = function (gridModel, api, ignoreContainLabel) {
  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
  this._rect = gridRect;
  var axesList = this._axesList;
  adjustAxes(); // Minus label size

  if (!ignoreContainLabel && gridModel.get('containLabel')) {
    each(axesList, function (axis) {
      if (!axis.model.get('axisLabel.inside')) {
        var labelUnionRect = getLabelUnionRect(axis);

        if (labelUnionRect) {
          var dim = axis.isHorizontal() ? 'height' : 'width';
          var margin = axis.model.get('axisLabel.margin');
          gridRect[dim] -= labelUnionRect[dim] + margin;

          if (axis.position === 'top') {
            gridRect.y += labelUnionRect.height + margin;
          } else if (axis.position === 'left') {
            gridRect.x += labelUnionRect.width + margin;
          }
        }
      }
    });
    adjustAxes();
  }

  function adjustAxes() {
    each(axesList, function (axis) {
      var isHorizontal = axis.isHorizontal();
      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
      var idx = axis.inverse ? 1 : 0;
      axis.setExtent(extent[idx], extent[1 - idx]);
      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);
    });
  }
};
/**
 * @param {string} axisType
 * @param {number} [axisIndex]
 */


gridProto.getAxis = function (axisType, axisIndex) {
  var axesMapOnDim = this._axesMap[axisType];

  if (axesMapOnDim != null) {
    if (axisIndex == null) {
      // Find first axis
      for (var name in axesMapOnDim) {
        if (axesMapOnDim.hasOwnProperty(name)) {
          return axesMapOnDim[name];
        }
      }
    }

    return axesMapOnDim[axisIndex];
  }
};
/**
 * @return {Array.<module:echarts/coord/Axis>}
 */


gridProto.getAxes = function () {
  return this._axesList.slice();
};
/**
 * Usage:
 *      grid.getCartesian(xAxisIndex, yAxisIndex);
 *      grid.getCartesian(xAxisIndex);
 *      grid.getCartesian(null, yAxisIndex);
 *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});
 *
 * @param {number|Object} [xAxisIndex]
 * @param {number} [yAxisIndex]
 */


gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {
  if (xAxisIndex != null && yAxisIndex != null) {
    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
    return this._coordsMap[key];
  }

  if (zrUtil.isObject(xAxisIndex)) {
    yAxisIndex = xAxisIndex.yAxisIndex;
    xAxisIndex = xAxisIndex.xAxisIndex;
  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.


  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
      return coordList[i];
    }
  }
};

gridProto.getCartesians = function () {
  return this._coordsList.slice();
};
/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */


gridProto.convertToPixel = function (ecModel, finder, value) {
  var target = this._findConvertTarget(ecModel, finder);

  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
};
/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */


gridProto.convertFromPixel = function (ecModel, finder, value) {
  var target = this._findConvertTarget(ecModel, finder);

  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
};
/**
 * @inner
 */


gridProto._findConvertTarget = function (ecModel, finder) {
  var seriesModel = finder.seriesModel;
  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];
  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];
  var gridModel = finder.gridModel;
  var coordsList = this._coordsList;
  var cartesian;
  var axis;

  if (seriesModel) {
    cartesian = seriesModel.coordinateSystem;
    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);
  } else if (xAxisModel && yAxisModel) {
    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
  } else if (xAxisModel) {
    axis = this.getAxis('x', xAxisModel.componentIndex);
  } else if (yAxisModel) {
    axis = this.getAxis('y', yAxisModel.componentIndex);
  } // Lowest priority.
  else if (gridModel) {
      var grid = gridModel.coordinateSystem;

      if (grid === this) {
        cartesian = this._coordsList[0];
      }
    }

  return {
    cartesian: cartesian,
    axis: axis
  };
};
/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */


gridProto.containPoint = function (point) {
  var coord = this._coordsList[0];

  if (coord) {
    return coord.containPoint(point);
  }
};
/**
 * Initialize cartesian coordinate systems
 * @private
 */


gridProto._initCartesian = function (gridModel, ecModel, api) {
  var axisPositionUsed = {
    left: false,
    right: false,
    top: false,
    bottom: false
  };
  var axesMap = {
    x: {},
    y: {}
  };
  var axesCount = {
    x: 0,
    y: 0
  }; /// Create axis

  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);

  if (!axesCount.x || !axesCount.y) {
    // Roll back when there no either x or y axis
    this._axesMap = {};
    this._axesList = [];
    return;
  }

  this._axesMap = axesMap; /// Create cartesian2d

  each(axesMap.x, function (xAxis, xAxisIndex) {
    each(axesMap.y, function (yAxis, yAxisIndex) {
      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
      var cartesian = new Cartesian2D(key);
      cartesian.grid = this;
      cartesian.model = gridModel;
      this._coordsMap[key] = cartesian;

      this._coordsList.push(cartesian);

      cartesian.addAxis(xAxis);
      cartesian.addAxis(yAxis);
    }, this);
  }, this);

  function createAxisCreator(axisType) {
    return function (axisModel, idx) {
      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
        return;
      }

      var axisPosition = axisModel.get('position');

      if (axisType === 'x') {
        // Fix position
        if (axisPosition !== 'top' && axisPosition !== 'bottom') {
          // Default bottom of X
          axisPosition = 'bottom';

          if (axisPositionUsed[axisPosition]) {
            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';
          }
        }
      } else {
        // Fix position
        if (axisPosition !== 'left' && axisPosition !== 'right') {
          // Default left of Y
          axisPosition = 'left';

          if (axisPositionUsed[axisPosition]) {
            axisPosition = axisPosition === 'left' ? 'right' : 'left';
          }
        }
      }

      axisPositionUsed[axisPosition] = true;
      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);
      var isCategory = axis.type === 'category';
      axis.onBand = isCategory && axisModel.get('boundaryGap');
      axis.inverse = axisModel.get('inverse');
      axis.onZero = axisModel.get('axisLine.onZero');
      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel

      axisModel.axis = axis; // Inject axisModel into axis

      axis.model = axisModel; // Inject grid info axis

      axis.grid = this; // Index of axis, can be used as key

      axis.index = idx;

      this._axesList.push(axis);

      axesMap[axisType][idx] = axis;
      axesCount[axisType]++;
    };
  }
};
/**
 * Update cartesian properties from series
 * @param  {module:echarts/model/Option} option
 * @private
 */


gridProto._updateScale = function (ecModel, gridModel) {
  // Reset scale
  zrUtil.each(this._axesList, function (axis) {
    axis.scale.setExtent(Infinity, -Infinity);
  });
  ecModel.eachSeries(function (seriesModel) {
    if (isCartesian2D(seriesModel)) {
      var axesModels = findAxesModels(seriesModel, ecModel);
      var xAxisModel = axesModels[0];
      var yAxisModel = axesModels[1];

      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {
        return;
      }

      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      var data = seriesModel.getData();
      var xAxis = cartesian.getAxis('x');
      var yAxis = cartesian.getAxis('y');

      if (data.type === 'list') {
        unionExtent(data, xAxis, seriesModel);
        unionExtent(data, yAxis, seriesModel);
      }
    }
  }, this);

  function unionExtent(data, axis, seriesModel) {
    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {
      axis.scale.unionExtentFromData(data, dim);
    });
  }
};
/**
 * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined
 * @return {Object} {baseAxes: [], otherAxes: []}
 */


gridProto.getTooltipAxes = function (dim) {
  var baseAxes = [];
  var otherAxes = [];
  each(this.getCartesians(), function (cartesian) {
    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
    var otherAxis = cartesian.getOtherAxis(baseAxis);
    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
  });
  return {
    baseAxes: baseAxes,
    otherAxes: otherAxes
  };
};
/**
 * @inner
 */


function updateAxisTransfrom(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform

  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
    return coord + coordBase;
  } : function (coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
    return coord - coordBase;
  } : function (coord) {
    return axisExtentSum - coord + coordBase;
  };
}

var axesTypes = ['xAxis', 'yAxis'];
/**
 * @inner
 */

function findAxesModels(seriesModel, ecModel) {
  return zrUtil.map(axesTypes, function (axisType) {
    var axisModel = seriesModel.getReferringComponents(axisType)[0];
    return axisModel;
  });
}
/**
 * @inner
 */


function isCartesian2D(seriesModel) {
  return seriesModel.get('coordinateSystem') === 'cartesian2d';
}

Grid.create = function (ecModel, api) {
  var grids = [];
  ecModel.eachComponent('grid', function (gridModel, idx) {
    var grid = new Grid(gridModel, ecModel, api);
    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize
    // should be performed in create stage.

    grid.resize(gridModel, api, true);
    gridModel.coordinateSystem = grid;
    grids.push(grid);
  }); // Inject the coordinateSystems into seriesModel

  ecModel.eachSeries(function (seriesModel) {
    if (!isCartesian2D(seriesModel)) {
      return;
    }

    var axesModels = findAxesModels(seriesModel, ecModel);
    var xAxisModel = axesModels[0];
    var yAxisModel = axesModels[1];
    var gridModel = xAxisModel.getCoordSysModel();
    var grid = gridModel.coordinateSystem;
    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
  });
  return grids;
}; // For deciding which dimensions to use when creating list data


Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;
CoordinateSystem.register('cartesian2d', Grid);
var _default = Grid;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/GridModel.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/coord/cartesian/AxisModel.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

// Grid 是在有直角坐标系的时候必须要存在的
// 所以这里也要被 Cartesian2D 依赖
var _default = ComponentModel.extend({
  type: 'grid',
  dependencies: ['xAxis', 'yAxis'],
  layoutMode: 'box',

  /**
   * @type {module:echarts/coord/cartesian/Grid}
   */
  coordinateSystem: null,
  defaultOption: {
    show: false,
    zlevel: 0,
    z: 0,
    left: '10%',
    top: 60,
    right: '10%',
    bottom: 60,
    // If grid size contain label
    containLabel: false,
    // width: {totalWidth} - left - right,
    // height: {totalHeight} - top - bottom,
    backgroundColor: 'rgba(0,0,0,0)',
    borderWidth: 1,
    borderColor: '#ccc'
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/Region.js":
/***/ (function(module, exports, __webpack_require__) {

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var bbox = __webpack_require__("./node_modules/zrender/lib/core/bbox.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var polygonContain = __webpack_require__("./node_modules/zrender/lib/contain/polygon.js");

/**
 * @module echarts/coord/geo/Region
 */

/**
 * @param {string} name
 * @param {Array} geometries
 * @param {Array.<number>} cp
 */
function Region(name, geometries, cp) {
  /**
   * @type {string}
   * @readOnly
   */
  this.name = name;
  /**
   * @type {Array.<Array>}
   * @readOnly
   */

  this.geometries = geometries;

  if (!cp) {
    var rect = this.getBoundingRect();
    cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  } else {
    cp = [cp[0], cp[1]];
  }
  /**
   * @type {Array.<number>}
   */


  this.center = cp;
}

Region.prototype = {
  constructor: Region,
  properties: null,

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function () {
    var rect = this._rect;

    if (rect) {
      return rect;
    }

    var MAX_NUMBER = Number.MAX_VALUE;
    var min = [MAX_NUMBER, MAX_NUMBER];
    var max = [-MAX_NUMBER, -MAX_NUMBER];
    var min2 = [];
    var max2 = [];
    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      // Only support polygon
      if (geometries[i].type !== 'polygon') {
        continue;
      } // Doesn't consider hole


      var exterior = geometries[i].exterior;
      bbox.fromPoints(exterior, min2, max2);
      vec2.min(min, min, min2);
      vec2.max(max, max, max2);
    } // No data


    if (i === 0) {
      min[0] = min[1] = max[0] = max[1] = 0;
    }

    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
  },

  /**
   * @param {<Array.<number>} coord
   * @return {boolean}
   */
  contain: function (coord) {
    var rect = this.getBoundingRect();
    var geometries = this.geometries;

    if (!rect.contain(coord[0], coord[1])) {
      return false;
    }

    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {
      // Only support polygon.
      if (geometries[i].type !== 'polygon') {
        continue;
      }

      var exterior = geometries[i].exterior;
      var interiors = geometries[i].interiors;

      if (polygonContain.contain(exterior, coord[0], coord[1])) {
        // Not in the region if point is in the hole.
        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
          if (polygonContain.contain(interiors[k])) {
            continue loopGeo;
          }
        }

        return true;
      }
    }

    return false;
  },
  transformTo: function (x, y, width, height) {
    var rect = this.getBoundingRect();
    var aspect = rect.width / rect.height;

    if (!width) {
      width = aspect * height;
    } else if (!height) {
      height = width / aspect;
    }

    var target = new BoundingRect(x, y, width, height);
    var transform = rect.calculateTransform(target);
    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      // Only support polygon.
      if (geometries[i].type !== 'polygon') {
        continue;
      }

      var exterior = geometries[i].exterior;
      var interiors = geometries[i].interiors;

      for (var p = 0; p < exterior.length; p++) {
        vec2.applyTransform(exterior[p], exterior[p], transform);
      }

      for (var h = 0; h < (interiors ? interiors.length : 0); h++) {
        for (var p = 0; p < interiors[h].length; p++) {
          vec2.applyTransform(interiors[h][p], interiors[h][p], transform);
        }
      }
    }

    rect = this._rect;
    rect.copy(target); // Update center

    this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }
};
var _default = Region;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/parseGeoJson.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Region = __webpack_require__("./node_modules/echarts/lib/coord/geo/Region.js");

/**
 * Parse and decode geo json
 * @module echarts/coord/geo/parseGeoJson
 */
function decode(json) {
  if (!json.UTF8Encoding) {
    return json;
  }

  var encodeScale = json.UTF8Scale;

  if (encodeScale == null) {
    encodeScale = 1024;
  }

  var features = json.features;

  for (var f = 0; f < features.length; f++) {
    var feature = features[f];
    var geometry = feature.geometry;
    var coordinates = geometry.coordinates;
    var encodeOffsets = geometry.encodeOffsets;

    for (var c = 0; c < coordinates.length; c++) {
      var coordinate = coordinates[c];

      if (geometry.type === 'Polygon') {
        coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);
      } else if (geometry.type === 'MultiPolygon') {
        for (var c2 = 0; c2 < coordinate.length; c2++) {
          var polygon = coordinate[c2];
          coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);
        }
      }
    }
  } // Has been decoded


  json.UTF8Encoding = false;
  return json;
}

function decodePolygon(coordinate, encodeOffsets, encodeScale) {
  var result = [];
  var prevX = encodeOffsets[0];
  var prevY = encodeOffsets[1];

  for (var i = 0; i < coordinate.length; i += 2) {
    var x = coordinate.charCodeAt(i) - 64;
    var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding

    x = x >> 1 ^ -(x & 1);
    y = y >> 1 ^ -(y & 1); // Delta deocding

    x += prevX;
    y += prevY;
    prevX = x;
    prevY = y; // Dequantize

    result.push([x / encodeScale, y / encodeScale]);
  }

  return result;
}
/**
 * @alias module:echarts/coord/geo/parseGeoJson
 * @param {Object} geoJson
 * @return {module:zrender/container/Group}
 */


function _default(geoJson) {
  decode(geoJson);
  return zrUtil.map(zrUtil.filter(geoJson.features, function (featureObj) {
    // Output of mapshaper may have geometry null
    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
  }), function (featureObj) {
    var properties = featureObj.properties;
    var geo = featureObj.geometry;
    var coordinates = geo.coordinates;
    var geometries = [];

    if (geo.type === 'Polygon') {
      geometries.push({
        type: 'polygon',
        // According to the GeoJSON specification.
        // First must be exterior, and the rest are all interior(holes).
        exterior: coordinates[0],
        interiors: coordinates.slice(1)
      });
    }

    if (geo.type === 'MultiPolygon') {
      zrUtil.each(coordinates, function (item) {
        if (item[0]) {
          geometries.push({
            type: 'polygon',
            exterior: item[0],
            interiors: item.slice(1)
          });
        }
      });
    }

    var region = new Region(properties.name, geometries, properties.cp);
    region.properties = properties;
    return region;
  });
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/data/DataDiffer.js":
/***/ (function(module, exports) {

function defaultKeyGetter(item) {
  return item;
}
/**
 * @param {Array} oldArr
 * @param {Array} newArr
 * @param {Function} oldKeyGetter
 * @param {Function} newKeyGetter
 * @param {Object} [context] Can be visited by this.context in callback.
 */


function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {
  this._old = oldArr;
  this._new = newArr;
  this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
  this._newKeyGetter = newKeyGetter || defaultKeyGetter;
  this.context = context;
}

DataDiffer.prototype = {
  constructor: DataDiffer,

  /**
   * Callback function when add a data
   */
  add: function (func) {
    this._add = func;
    return this;
  },

  /**
   * Callback function when update a data
   */
  update: function (func) {
    this._update = func;
    return this;
  },

  /**
   * Callback function when remove a data
   */
  remove: function (func) {
    this._remove = func;
    return this;
  },
  execute: function () {
    var oldArr = this._old;
    var newArr = this._new;
    var oldDataIndexMap = {};
    var newDataIndexMap = {};
    var oldDataKeyArr = [];
    var newDataKeyArr = [];
    var i;
    initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);
    initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this); // Travel by inverted order to make sure order consistency
    // when duplicate keys exists (consider newDataIndex.pop() below).
    // For performance consideration, these code below do not look neat.

    for (i = 0; i < oldArr.length; i++) {
      var key = oldDataKeyArr[i];
      var idx = newDataIndexMap[key]; // idx can never be empty array here. see 'set null' logic below.

      if (idx != null) {
        // Consider there is duplicate key (for example, use dataItem.name as key).
        // We should make sure every item in newArr and oldArr can be visited.
        var len = idx.length;

        if (len) {
          len === 1 && (newDataIndexMap[key] = null);
          idx = idx.unshift();
        } else {
          newDataIndexMap[key] = null;
        }

        this._update && this._update(idx, i);
      } else {
        this._remove && this._remove(i);
      }
    }

    for (var i = 0; i < newDataKeyArr.length; i++) {
      var key = newDataKeyArr[i];

      if (newDataIndexMap.hasOwnProperty(key)) {
        var idx = newDataIndexMap[key];

        if (idx == null) {
          continue;
        } // idx can never be empty array here. see 'set null' logic above.


        if (!idx.length) {
          this._add && this._add(idx);
        } else {
          for (var j = 0, len = idx.length; j < len; j++) {
            this._add && this._add(idx[j]);
          }
        }
      }
    }
  }
};

function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {
  for (var i = 0; i < arr.length; i++) {
    // Add prefix to avoid conflict with Object.prototype.
    var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);
    var existence = map[key];

    if (existence == null) {
      keyArr.push(key);
      map[key] = i;
    } else {
      if (!existence.length) {
        map[key] = existence = [existence];
      }

      existence.push(i);
    }
  }
}

var _default = DataDiffer;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/data/List.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var DataDiffer = __webpack_require__("./node_modules/echarts/lib/data/DataDiffer.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

/**
 * List for data storage
 * @module echarts/data/List
 */
var isObject = zrUtil.isObject;
var UNDEFINED = 'undefined';
var globalObj = typeof window === UNDEFINED ? global : window;
var dataCtors = {
  'float': typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array,
  'int': typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array,
  // Ordinal data type can be string or int
  'ordinal': Array,
  'number': Array,
  'time': Array
};
var TRANSFERABLE_PROPERTIES = ['stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'];

function transferProperties(a, b) {
  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {
    if (b.hasOwnProperty(propName)) {
      a[propName] = b[propName];
    }
  });
  a.__wrappedMethods = b.__wrappedMethods;
}

function DefaultDataProvider(dataArray) {
  this._array = dataArray || [];
}

DefaultDataProvider.prototype.pure = false;

DefaultDataProvider.prototype.count = function () {
  return this._array.length;
};

DefaultDataProvider.prototype.getItem = function (idx) {
  return this._array[idx];
};
/**
 * @constructor
 * @alias module:echarts/data/List
 *
 * @param {Array.<string|Object>} dimensions
 *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
 *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
 * @param {module:echarts/model/Model} hostModel
 */


var List = function (dimensions, hostModel) {
  dimensions = dimensions || ['x', 'y'];
  var dimensionInfos = {};
  var dimensionNames = [];

  for (var i = 0; i < dimensions.length; i++) {
    var dimensionName;
    var dimensionInfo = {};

    if (typeof dimensions[i] === 'string') {
      dimensionName = dimensions[i];
      dimensionInfo = {
        name: dimensionName,
        coordDim: dimensionName,
        coordDimIndex: 0,
        stackable: false,
        // Type can be 'float', 'int', 'number'
        // Default is number, Precision of float may not enough
        type: 'number'
      };
    } else {
      dimensionInfo = dimensions[i];
      dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || 'number';

      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }
    }

    dimensionInfo.otherDims = dimensionInfo.otherDims || {};
    dimensionNames.push(dimensionName);
    dimensionInfos[dimensionName] = dimensionInfo;
  }
  /**
   * @readOnly
   * @type {Array.<string>}
   */


  this.dimensions = dimensionNames;
  /**
   * Infomation of each data dimension, like data type.
   * @type {Object}
   */

  this._dimensionInfos = dimensionInfos;
  /**
   * @type {module:echarts/model/Model}
   */

  this.hostModel = hostModel;
  /**
   * @type {module:echarts/model/Model}
   */

  this.dataType;
  /**
   * Indices stores the indices of data subset after filtered.
   * This data subset will be used in chart.
   * @type {Array.<number>}
   * @readOnly
   */

  this.indices = [];
  /**
   * Data storage
   * @type {Object.<key, TypedArray|Array>}
   * @private
   */

  this._storage = {};
  /**
   * @type {Array.<string>}
   */

  this._nameList = [];
  /**
   * @type {Array.<string>}
   */

  this._idList = [];
  /**
   * Models of data option is stored sparse for optimizing memory cost
   * @type {Array.<module:echarts/model/Model>}
   * @private
   */

  this._optionModels = [];
  /**
   * @param {module:echarts/data/List}
   */

  this.stackedOn = null;
  /**
   * Global visual properties after visual coding
   * @type {Object}
   * @private
   */

  this._visual = {};
  /**
   * Globel layout properties.
   * @type {Object}
   * @private
   */

  this._layout = {};
  /**
   * Item visual properties after visual coding
   * @type {Array.<Object>}
   * @private
   */

  this._itemVisuals = [];
  /**
   * Item layout properties after layout
   * @type {Array.<Object>}
   * @private
   */

  this._itemLayouts = [];
  /**
   * Graphic elemnents
   * @type {Array.<module:zrender/Element>}
   * @private
   */

  this._graphicEls = [];
  /**
   * @type {Array.<Array|Object>}
   * @private
   */

  this._rawData;
  /**
   * @type {Object}
   * @private
   */

  this._extent;
};

var listProto = List.prototype;
listProto.type = 'list';
/**
 * If each data item has it's own option
 * @type {boolean}
 */

listProto.hasItemOption = true;
/**
 * Get dimension name
 * @param {string|number} dim
 *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
 *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
 * @return {string} Concrete dim name.
 */

listProto.getDimension = function (dim) {
  if (!isNaN(dim)) {
    dim = this.dimensions[dim] || dim;
  }

  return dim;
};
/**
 * Get type and stackable info of particular dimension
 * @param {string|number} dim
 *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
 *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
 */


listProto.getDimensionInfo = function (dim) {
  return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);
};
/**
 * Initialize from data
 * @param {Array.<Object|number|Array>} data
 * @param {Array.<string>} [nameList]
 * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number
 */


listProto.initData = function (data, nameList, dimValueGetter) {
  data = data || [];
  var isDataArray = zrUtil.isArray(data);

  if (isDataArray) {
    data = new DefaultDataProvider(data);
  }

  this._rawData = data; // Clear

  var storage = this._storage = {};
  var indices = this.indices = [];
  var dimensions = this.dimensions;
  var dimensionInfoMap = this._dimensionInfos;
  var size = data.count();
  var idList = [];
  var nameRepeatCount = {};
  var nameDimIdx;
  nameList = nameList || []; // Init storage

  for (var i = 0; i < dimensions.length; i++) {
    var dimInfo = dimensionInfoMap[dimensions[i]];
    dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);
    var DataCtor = dataCtors[dimInfo.type];
    storage[dimensions[i]] = new DataCtor(size);
  }

  var self = this;

  if (!dimValueGetter) {
    self.hasItemOption = false;
  } // Default dim value getter


  dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {
    var value = modelUtil.getDataItemValue(dataItem); // If any dataItem is like { value: 10 }

    if (modelUtil.isDataItemOption(dataItem)) {
      self.hasItemOption = true;
    }

    return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.
    : value, dimensionInfoMap[dimName]);
  };

  for (var i = 0; i < size; i++) {
    // NOTICE: Try not to write things into dataItem
    var dataItem = data.getItem(i); // Each data item is value
    // [1, 2]
    // 2
    // Bar chart, line chart which uses category axis
    // only gives the 'y' value. 'x' value is the indices of cateogry
    // Use a tempValue to normalize the value to be a (x, y) value
    // Store the data by dimensions

    for (var k = 0; k < dimensions.length; k++) {
      var dim = dimensions[k];
      var dimStorage = storage[dim]; // PENDING NULL is empty or zero

      dimStorage[i] = dimValueGetter(dataItem, dim, i, k);
    }

    indices.push(i);
  } // Use the name in option and create id


  for (var i = 0; i < size; i++) {
    var dataItem = data.getItem(i);

    if (!nameList[i] && dataItem) {
      if (dataItem.name != null) {
        nameList[i] = dataItem.name;
      } else if (nameDimIdx != null) {
        nameList[i] = storage[dimensions[nameDimIdx]][i];
      }
    }

    var name = nameList[i] || ''; // Try using the id in option

    var id = dataItem && dataItem.id;

    if (!id && name) {
      // Use name as id and add counter to avoid same name
      nameRepeatCount[name] = nameRepeatCount[name] || 0;
      id = name;

      if (nameRepeatCount[name] > 0) {
        id += '__ec__' + nameRepeatCount[name];
      }

      nameRepeatCount[name]++;
    }

    id && (idList[i] = id);
  }

  this._nameList = nameList;
  this._idList = idList;
};
/**
 * @return {number}
 */


listProto.count = function () {
  return this.indices.length;
};
/**
 * Get value. Return NaN if idx is out of range.
 * @param {string} dim Dim must be concrete name.
 * @param {number} idx
 * @param {boolean} stack
 * @return {number}
 */


listProto.get = function (dim, idx, stack) {
  var storage = this._storage;
  var dataIndex = this.indices[idx]; // If value not exists

  if (dataIndex == null || !storage[dim]) {
    return NaN;
  }

  var value = storage[dim][dataIndex]; // FIXME ordinal data type is not stackable

  if (stack) {
    var dimensionInfo = this._dimensionInfos[dim];

    if (dimensionInfo && dimensionInfo.stackable) {
      var stackedOn = this.stackedOn;

      while (stackedOn) {
        // Get no stacked data of stacked on
        var stackedValue = stackedOn.get(dim, idx); // Considering positive stack, negative stack and empty data

        if (value >= 0 && stackedValue > 0 || // Positive stack
        value <= 0 && stackedValue < 0 // Negative stack
        ) {
            value += stackedValue;
          }

        stackedOn = stackedOn.stackedOn;
      }
    }
  }

  return value;
};
/**
 * Get value for multi dimensions.
 * @param {Array.<string>} [dimensions] If ignored, using all dimensions.
 * @param {number} idx
 * @param {boolean} stack
 * @return {number}
 */


listProto.getValues = function (dimensions, idx, stack) {
  var values = [];

  if (!zrUtil.isArray(dimensions)) {
    stack = idx;
    idx = dimensions;
    dimensions = this.dimensions;
  }

  for (var i = 0, len = dimensions.length; i < len; i++) {
    values.push(this.get(dimensions[i], idx, stack));
  }

  return values;
};
/**
 * If value is NaN. Inlcuding '-'
 * @param {string} dim
 * @param {number} idx
 * @return {number}
 */


listProto.hasValue = function (idx) {
  var dimensions = this.dimensions;
  var dimensionInfos = this._dimensionInfos;

  for (var i = 0, len = dimensions.length; i < len; i++) {
    if ( // Ordinal type can be string or number
    dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {
      return false;
    }
  }

  return true;
};
/**
 * Get extent of data in one dimension
 * @param {string} dim
 * @param {boolean} stack
 * @param {Function} filter
 */


listProto.getDataExtent = function (dim, stack, filter) {
  dim = this.getDimension(dim);
  var dimData = this._storage[dim];
  var dimInfo = this.getDimensionInfo(dim);
  stack = dimInfo && dimInfo.stackable && stack;
  var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];
  var value;

  if (dimExtent) {
    return dimExtent;
  } // var dimInfo = this._dimensionInfos[dim];


  if (dimData) {
    var min = Infinity;
    var max = -Infinity; // var isOrdinal = dimInfo.type === 'ordinal';

    for (var i = 0, len = this.count(); i < len; i++) {
      value = this.get(dim, i, stack); // FIXME
      // if (isOrdinal && typeof value === 'string') {
      //     value = zrUtil.indexOf(dimData, value);
      // }

      if (!filter || filter(value, dim, i)) {
        value < min && (min = value);
        value > max && (max = value);
      }
    }

    return this._extent[dim + !!stack] = [min, max];
  } else {
    return [Infinity, -Infinity];
  }
};
/**
 * Get sum of data in one dimension
 * @param {string} dim
 * @param {boolean} stack
 */


listProto.getSum = function (dim, stack) {
  var dimData = this._storage[dim];
  var sum = 0;

  if (dimData) {
    for (var i = 0, len = this.count(); i < len; i++) {
      var value = this.get(dim, i, stack);

      if (!isNaN(value)) {
        sum += value;
      }
    }
  }

  return sum;
};
/**
 * Retreive the index with given value
 * @param {number} idx
 * @param {number} value
 * @return {number}
 */
// FIXME Precision of float value


listProto.indexOf = function (dim, value) {
  var storage = this._storage;
  var dimData = storage[dim];
  var indices = this.indices;

  if (dimData) {
    for (var i = 0, len = indices.length; i < len; i++) {
      var rawIndex = indices[i];

      if (dimData[rawIndex] === value) {
        return i;
      }
    }
  }

  return -1;
};
/**
 * Retreive the index with given name
 * @param {number} idx
 * @param {number} name
 * @return {number}
 */


listProto.indexOfName = function (name) {
  var indices = this.indices;
  var nameList = this._nameList;

  for (var i = 0, len = indices.length; i < len; i++) {
    var rawIndex = indices[i];

    if (nameList[rawIndex] === name) {
      return i;
    }
  }

  return -1;
};
/**
 * Retreive the index with given raw data index
 * @param {number} idx
 * @param {number} name
 * @return {number}
 */


listProto.indexOfRawIndex = function (rawIndex) {
  // Indices are ascending
  var indices = this.indices; // If rawIndex === dataIndex

  var rawDataIndex = indices[rawIndex];

  if (rawDataIndex != null && rawDataIndex === rawIndex) {
    return rawIndex;
  }

  var left = 0;
  var right = indices.length - 1;

  while (left <= right) {
    var mid = (left + right) / 2 | 0;

    if (indices[mid] < rawIndex) {
      left = mid + 1;
    } else if (indices[mid] > rawIndex) {
      right = mid - 1;
    } else {
      return mid;
    }
  }

  return -1;
};
/**
 * Retreive the index of nearest value
 * @param {string} dim
 * @param {number} value
 * @param {boolean} stack If given value is after stacked
 * @param {number} [maxDistance=Infinity]
 * @return {Array.<number>} Considere multiple points has the same value.
 */


listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {
  var storage = this._storage;
  var dimData = storage[dim];
  var nearestIndices = [];

  if (!dimData) {
    return nearestIndices;
  }

  if (maxDistance == null) {
    maxDistance = Infinity;
  }

  var minDist = Number.MAX_VALUE;
  var minDiff = -1;

  for (var i = 0, len = this.count(); i < len; i++) {
    var diff = value - this.get(dim, i, stack);
    var dist = Math.abs(diff);

    if (diff <= maxDistance && dist <= minDist) {
      // For the case of two data are same on xAxis, which has sequence data.
      // Show the nearest index
      // https://github.com/ecomfe/echarts/issues/2869
      if (dist < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist;
        minDiff = diff;
        nearestIndices.length = 0;
      }

      nearestIndices.push(i);
    }
  }

  return nearestIndices;
};
/**
 * Get raw data index
 * @param {number} idx
 * @return {number}
 */


listProto.getRawIndex = function (idx) {
  var rawIdx = this.indices[idx];
  return rawIdx == null ? -1 : rawIdx;
};
/**
 * Get raw data item
 * @param {number} idx
 * @return {number}
 */


listProto.getRawDataItem = function (idx) {
  return this._rawData.getItem(this.getRawIndex(idx));
};
/**
 * @param {number} idx
 * @param {boolean} [notDefaultIdx=false]
 * @return {string}
 */


listProto.getName = function (idx) {
  return this._nameList[this.indices[idx]] || '';
};
/**
 * @param {number} idx
 * @param {boolean} [notDefaultIdx=false]
 * @return {string}
 */


listProto.getId = function (idx) {
  return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';
};

function normalizeDimensions(dimensions) {
  if (!zrUtil.isArray(dimensions)) {
    dimensions = [dimensions];
  }

  return dimensions;
}
/**
 * Data iteration
 * @param {string|Array.<string>}
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 *
 * @example
 *  list.each('x', function (x, idx) {});
 *  list.each(['x', 'y'], function (x, y, idx) {});
 *  list.each(function (idx) {})
 */


listProto.each = function (dims, cb, stack, context) {
  if (typeof dims === 'function') {
    context = stack;
    stack = cb;
    cb = dims;
    dims = [];
  }

  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);
  var value = [];
  var dimSize = dims.length;
  var indices = this.indices;
  context = context || this;

  for (var i = 0; i < indices.length; i++) {
    // Simple optimization
    switch (dimSize) {
      case 0:
        cb.call(context, i);
        break;

      case 1:
        cb.call(context, this.get(dims[0], i, stack), i);
        break;

      case 2:
        cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);
        break;

      default:
        for (var k = 0; k < dimSize; k++) {
          value[k] = this.get(dims[k], i, stack);
        } // Index


        value[k] = i;
        cb.apply(context, value);
    }
  }
};
/**
 * Data filter
 * @param {string|Array.<string>}
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 */


listProto.filterSelf = function (dimensions, cb, stack, context) {
  if (typeof dimensions === 'function') {
    context = stack;
    stack = cb;
    cb = dimensions;
    dimensions = [];
  }

  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
  var newIndices = [];
  var value = [];
  var dimSize = dimensions.length;
  var indices = this.indices;
  context = context || this;

  for (var i = 0; i < indices.length; i++) {
    var keep; // Simple optimization

    if (!dimSize) {
      keep = cb.call(context, i);
    } else if (dimSize === 1) {
      keep = cb.call(context, this.get(dimensions[0], i, stack), i);
    } else {
      for (var k = 0; k < dimSize; k++) {
        value[k] = this.get(dimensions[k], i, stack);
      }

      value[k] = i;
      keep = cb.apply(context, value);
    }

    if (keep) {
      newIndices.push(indices[i]);
    }
  }

  this.indices = newIndices; // Reset data extent

  this._extent = {};
  return this;
};
/**
 * Data mapping to a plain array
 * @param {string|Array.<string>} [dimensions]
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 * @return {Array}
 */


listProto.mapArray = function (dimensions, cb, stack, context) {
  if (typeof dimensions === 'function') {
    context = stack;
    stack = cb;
    cb = dimensions;
    dimensions = [];
  }

  var result = [];
  this.each(dimensions, function () {
    result.push(cb && cb.apply(this, arguments));
  }, stack, context);
  return result;
};

function cloneListForMapAndSample(original, excludeDimensions) {
  var allDimensions = original.dimensions;
  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked

  transferProperties(list, original);
  var storage = list._storage = {};
  var originalStorage = original._storage; // Init storage

  for (var i = 0; i < allDimensions.length; i++) {
    var dim = allDimensions[i];
    var dimStore = originalStorage[dim];

    if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {
      storage[dim] = new dimStore.constructor(originalStorage[dim].length);
    } else {
      // Direct reference for other dimensions
      storage[dim] = originalStorage[dim];
    }
  }

  return list;
}
/**
 * Data mapping to a new List with given dimensions
 * @param {string|Array.<string>} dimensions
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 * @return {Array}
 */


listProto.map = function (dimensions, cb, stack, context) {
  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.
  // So we can reference to the same value

  var indices = list.indices = this.indices;
  var storage = list._storage;
  var tmpRetValue = [];
  this.each(dimensions, function () {
    var idx = arguments[arguments.length - 1];
    var retValue = cb && cb.apply(this, arguments);

    if (retValue != null) {
      // a number
      if (typeof retValue === 'number') {
        tmpRetValue[0] = retValue;
        retValue = tmpRetValue;
      }

      for (var i = 0; i < retValue.length; i++) {
        var dim = dimensions[i];
        var dimStore = storage[dim];
        var rawIdx = indices[idx];

        if (dimStore) {
          dimStore[rawIdx] = retValue[i];
        }
      }
    }
  }, stack, context);
  return list;
};
/**
 * Large data down sampling on given dimension
 * @param {string} dimension
 * @param {number} rate
 * @param {Function} sampleValue
 * @param {Function} sampleIndex Sample index for name and id
 */


listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {
  var list = cloneListForMapAndSample(this, [dimension]);
  var storage = this._storage;
  var targetStorage = list._storage;
  var originalIndices = this.indices;
  var indices = list.indices = [];
  var frameValues = [];
  var frameIndices = [];
  var frameSize = Math.floor(1 / rate);
  var dimStore = targetStorage[dimension];
  var len = this.count(); // Copy data from original data

  for (var i = 0; i < storage[dimension].length; i++) {
    targetStorage[dimension][i] = storage[dimension][i];
  }

  for (var i = 0; i < len; i += frameSize) {
    // Last frame
    if (frameSize > len - i) {
      frameSize = len - i;
      frameValues.length = frameSize;
    }

    for (var k = 0; k < frameSize; k++) {
      var idx = originalIndices[i + k];
      frameValues[k] = dimStore[idx];
      frameIndices[k] = idx;
    }

    var value = sampleValue(frameValues);
    var idx = frameIndices[sampleIndex(frameValues, value) || 0]; // Only write value on the filtered data

    dimStore[idx] = value;
    indices.push(idx);
  }

  return list;
};
/**
 * Get model of one data item.
 *
 * @param {number} idx
 */
// FIXME Model proxy ?


listProto.getItemModel = function (idx) {
  var hostModel = this.hostModel;
  idx = this.indices[idx];
  return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);
};
/**
 * Create a data differ
 * @param {module:echarts/data/List} otherList
 * @return {module:echarts/data/DataDiffer}
 */


listProto.diff = function (otherList) {
  var idList = this._idList;
  var otherIdList = otherList && otherList._idList;
  var val; // Use prefix to avoid index to be the same as otherIdList[idx],
  // which will cause weird udpate animation.

  var prefix = 'e\0\0';
  return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {
    return (val = otherIdList[idx]) != null ? val : prefix + idx;
  }, function (idx) {
    return (val = idList[idx]) != null ? val : prefix + idx;
  });
};
/**
 * Get visual property.
 * @param {string} key
 */


listProto.getVisual = function (key) {
  var visual = this._visual;
  return visual && visual[key];
};
/**
 * Set visual property
 * @param {string|Object} key
 * @param {*} [value]
 *
 * @example
 *  setVisual('color', color);
 *  setVisual({
 *      'color': color
 *  });
 */


listProto.setVisual = function (key, val) {
  if (isObject(key)) {
    for (var name in key) {
      if (key.hasOwnProperty(name)) {
        this.setVisual(name, key[name]);
      }
    }

    return;
  }

  this._visual = this._visual || {};
  this._visual[key] = val;
};
/**
 * Set layout property.
 * @param {string|Object} key
 * @param {*} [val]
 */


listProto.setLayout = function (key, val) {
  if (isObject(key)) {
    for (var name in key) {
      if (key.hasOwnProperty(name)) {
        this.setLayout(name, key[name]);
      }
    }

    return;
  }

  this._layout[key] = val;
};
/**
 * Get layout property.
 * @param  {string} key.
 * @return {*}
 */


listProto.getLayout = function (key) {
  return this._layout[key];
};
/**
 * Get layout of single data item
 * @param {number} idx
 */


listProto.getItemLayout = function (idx) {
  return this._itemLayouts[idx];
};
/**
 * Set layout of single data item
 * @param {number} idx
 * @param {Object} layout
 * @param {boolean=} [merge=false]
 */


listProto.setItemLayout = function (idx, layout, merge) {
  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;
};
/**
 * Clear all layout of single data item
 */


listProto.clearItemLayouts = function () {
  this._itemLayouts.length = 0;
};
/**
 * Get visual property of single data item
 * @param {number} idx
 * @param {string} key
 * @param {boolean} [ignoreParent=false]
 */


listProto.getItemVisual = function (idx, key, ignoreParent) {
  var itemVisual = this._itemVisuals[idx];
  var val = itemVisual && itemVisual[key];

  if (val == null && !ignoreParent) {
    // Use global visual property
    return this.getVisual(key);
  }

  return val;
};
/**
 * Set visual property of single data item
 *
 * @param {number} idx
 * @param {string|Object} key
 * @param {*} [value]
 *
 * @example
 *  setItemVisual(0, 'color', color);
 *  setItemVisual(0, {
 *      'color': color
 *  });
 */


listProto.setItemVisual = function (idx, key, value) {
  var itemVisual = this._itemVisuals[idx] || {};
  this._itemVisuals[idx] = itemVisual;

  if (isObject(key)) {
    for (var name in key) {
      if (key.hasOwnProperty(name)) {
        itemVisual[name] = key[name];
      }
    }

    return;
  }

  itemVisual[key] = value;
};
/**
 * Clear itemVisuals and list visual.
 */


listProto.clearAllVisual = function () {
  this._visual = {};
  this._itemVisuals = [];
};

var setItemDataAndSeriesIndex = function (child) {
  child.seriesIndex = this.seriesIndex;
  child.dataIndex = this.dataIndex;
  child.dataType = this.dataType;
};
/**
 * Set graphic element relative to data. It can be set as null
 * @param {number} idx
 * @param {module:zrender/Element} [el]
 */


listProto.setItemGraphicEl = function (idx, el) {
  var hostModel = this.hostModel;

  if (el) {
    // Add data index and series index for indexing the data by element
    // Useful in tooltip
    el.dataIndex = idx;
    el.dataType = this.dataType;
    el.seriesIndex = hostModel && hostModel.seriesIndex;

    if (el.type === 'group') {
      el.traverse(setItemDataAndSeriesIndex, el);
    }
  }

  this._graphicEls[idx] = el;
};
/**
 * @param {number} idx
 * @return {module:zrender/Element}
 */


listProto.getItemGraphicEl = function (idx) {
  return this._graphicEls[idx];
};
/**
 * @param {Function} cb
 * @param {*} context
 */


listProto.eachItemGraphicEl = function (cb, context) {
  zrUtil.each(this._graphicEls, function (el, idx) {
    if (el) {
      cb && cb.call(context, el, idx);
    }
  });
};
/**
 * Shallow clone a new list except visual and layout properties, and graph elements.
 * New list only change the indices.
 */


listProto.cloneShallow = function () {
  var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);
  var list = new List(dimensionInfoList, this.hostModel); // FIXME

  list._storage = this._storage;
  transferProperties(list, this); // Clone will not change the data extent and indices

  list.indices = this.indices.slice();

  if (this._extent) {
    list._extent = zrUtil.extend({}, this._extent);
  }

  return list;
};
/**
 * Wrap some method to add more feature
 * @param {string} methodName
 * @param {Function} injectFunction
 */


listProto.wrapMethod = function (methodName, injectFunction) {
  var originalMethod = this[methodName];

  if (typeof originalMethod !== 'function') {
    return;
  }

  this.__wrappedMethods = this.__wrappedMethods || [];

  this.__wrappedMethods.push(methodName);

  this[methodName] = function () {
    var res = originalMethod.apply(this, arguments);
    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));
  };
}; // Methods that create a new list based on this list should be listed here.
// Notice that those method should `RETURN` the new list.


listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.

listProto.CHANGABLE_METHODS = ['filterSelf'];
var _default = List;
module.exports = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/echarts/lib/data/helper/completeDimensions.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var normalizeToArray = _model.normalizeToArray;

/**
 * Complete dimensions by data (guess dimension).
 */
var each = zrUtil.each;
var isString = zrUtil.isString;
var defaults = zrUtil.defaults;
var OTHER_DIMS = {
  tooltip: 1,
  label: 1,
  itemName: 1
};
/**
 * Complete the dimensions array, by user defined `dimension` and `encode`,
 * and guessing from the data structure.
 * If no 'value' dimension specified, the first no-named dimension will be
 * named as 'value'.
 *
 * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which
 *      provides not only dim template, but also default order.
 *      `name` of each item provides default coord name.
 *      [{dimsDef: []}, ...] can be specified to give names.
 * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].
 * @param {Object} [opt]
 * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions
 *      For example: ['asdf', {name, type}, ...].
 * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}
 * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.
 * @param {string} [opt.extraFromZero] If specified, extra dim names will be:
 *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...
 *                      If not specified, extra dim names will be:
 *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...
 * @param {number} [opt.dimCount] If not specified, guess by the first data item.
 * @return {Array.<Object>} [{
 *      name: string mandatory,
 *      coordDim: string mandatory,
 *      coordDimIndex: number mandatory,
 *      type: string optional,
 *      tooltipName: string optional,
 *      otherDims: {
 *          tooltip: number optional,
 *          label: number optional
 *      },
 *      isExtraCoord: boolean true or undefined.
 *      other props ...
 * }]
 */

function completeDimensions(sysDims, data, opt) {
  data = data || [];
  opt = opt || {};
  sysDims = (sysDims || []).slice();
  var dimsDef = (opt.dimsDef || []).slice();
  var encodeDef = zrUtil.createHashMap(opt.encodeDef);
  var dataDimNameMap = zrUtil.createHashMap();
  var coordDimNameMap = zrUtil.createHashMap(); // var valueCandidate;

  var result = [];
  var dimCount = opt.dimCount;

  if (dimCount == null) {
    var value0 = retrieveValue(data[0]);
    dimCount = Math.max(zrUtil.isArray(value0) && value0.length || 1, sysDims.length, dimsDef.length);
    each(sysDims, function (sysDimItem) {
      var sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));
    });
  } // Apply user defined dims (`name` and `type`) and init result.


  for (var i = 0; i < dimCount; i++) {
    var dimDefItem = isString(dimsDef[i]) ? {
      name: dimsDef[i]
    } : dimsDef[i] || {};
    var userDimName = dimDefItem.name;
    var resultItem = result[i] = {
      otherDims: {}
    }; // Name will be applied later for avoiding duplication.

    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      // Only if `series.dimensions` is defined in option, tooltipName
      // will be set, and dimension will be diplayed vertically in
      // tooltip by default.
      resultItem.name = resultItem.tooltipName = userDimName;
      dataDimNameMap.set(userDimName, i);
    }

    dimDefItem.type != null && (resultItem.type = dimDefItem.type);
  } // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.


  encodeDef.each(function (dataDims, coordDim) {
    dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());
    each(dataDims, function (resultDimIdx, coordDimIndex) {
      // The input resultDimIdx can be dim name or index.
      isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));

      if (resultDimIdx != null && resultDimIdx < dimCount) {
        dataDims[coordDimIndex] = resultDimIdx;
        applyDim(result[resultDimIdx], coordDim, coordDimIndex);
      }
    });
  }); // Apply templetes and default order from `sysDims`.

  var availDimIdx = 0;
  each(sysDims, function (sysDimItem, sysDimIndex) {
    var coordDim;
    var sysDimItem;
    var sysDimItemDimsDef;
    var sysDimItemOtherDims;

    if (isString(sysDimItem)) {
      coordDim = sysDimItem;
      sysDimItem = {};
    } else {
      coordDim = sysDimItem.name;
      sysDimItem = zrUtil.clone(sysDimItem); // `coordDimIndex` should not be set directly.

      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }

    var dataDims = normalizeToArray(encodeDef.get(coordDim)); // dimensions provides default dim sequences.

    if (!dataDims.length) {
      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {
          availDimIdx++;
        }

        availDimIdx < result.length && dataDims.push(availDimIdx++);
      }
    } // Apply templates.


    each(dataDims, function (resultDimIdx, coordDimIndex) {
      var resultItem = result[resultDimIdx];
      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);

      if (resultItem.name == null && sysDimItemDimsDef) {
        resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];
      }

      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);
    });
  }); // Make sure the first extra dim is 'value'.

  var extra = opt.extraPrefix || 'value'; // Set dim `name` and other `coordDim` and other props.

  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
    var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};
    var coordDim = resultItem.coordDim;
    coordDim == null && (resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero), resultItem.coordDimIndex = 0, resultItem.isExtraCoord = true);
    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));
    resultItem.type == null && guessOrdinal(data, resultDimIdx) && (resultItem.type = 'ordinal');
  }

  return result;

  function applyDim(resultItem, coordDim, coordDimIndex) {
    if (OTHER_DIMS[coordDim]) {
      resultItem.otherDims[coordDim] = coordDimIndex;
    } else {
      resultItem.coordDim = coordDim;
      resultItem.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim, true);
    }
  }

  function genName(name, map, fromZero) {
    if (fromZero || map.get(name) != null) {
      var i = 0;

      while (map.get(name + i) != null) {
        i++;
      }

      name += i;
    }

    map.set(name, true);
    return name;
  }
} // The rule should not be complex, otherwise user might not
// be able to known where the data is wrong.


var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {
  for (var i = 0, len = data.length; i < len; i++) {
    var value = retrieveValue(data[i]);

    if (!zrUtil.isArray(value)) {
      return false;
    }

    var value = value[dimIndex]; // Consider usage convenience, '1', '2' will be treated as "number".
    // `isFinit('')` get `true`.

    if (value != null && isFinite(value) && value !== '') {
      return false;
    } else if (isString(value) && value !== '-') {
      return true;
    }
  }

  return false;
};

function retrieveValue(o) {
  return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;
}

var _default = completeDimensions;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/echarts.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrender = __webpack_require__("./node_modules/zrender/lib/zrender.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var colorTool = __webpack_require__("./node_modules/zrender/lib/tool/color.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var timsort = __webpack_require__("./node_modules/zrender/lib/core/timsort.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var GlobalModel = __webpack_require__("./node_modules/echarts/lib/model/Global.js");

var ExtensionAPI = __webpack_require__("./node_modules/echarts/lib/ExtensionAPI.js");

var CoordinateSystemManager = __webpack_require__("./node_modules/echarts/lib/CoordinateSystem.js");

var OptionManager = __webpack_require__("./node_modules/echarts/lib/model/OptionManager.js");

var backwardCompat = __webpack_require__("./node_modules/echarts/lib/preprocessor/backwardCompat.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var SeriesModel = __webpack_require__("./node_modules/echarts/lib/model/Series.js");

var ComponentView = __webpack_require__("./node_modules/echarts/lib/view/Component.js");

var ChartView = __webpack_require__("./node_modules/echarts/lib/view/Chart.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var _throttle = __webpack_require__("./node_modules/echarts/lib/util/throttle.js");

var throttle = _throttle.throttle;

var seriesColor = __webpack_require__("./node_modules/echarts/lib/visual/seriesColor.js");

var loadingDefault = __webpack_require__("./node_modules/echarts/lib/loading/default.js");

/*!
 * ECharts, a javascript interactive chart library.
 *
 * Copyright (c) 2015, Baidu Inc.
 * All rights reserved.
 *
 * LICENSE
 * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
 */
var each = zrUtil.each;
var parseClassType = ComponentModel.parseClassType;
var version = '3.8.5';
var dependencies = {
  zrender: '3.7.4'
};
var PRIORITY_PROCESSOR_FILTER = 1000;
var PRIORITY_PROCESSOR_STATISTIC = 5000;
var PRIORITY_VISUAL_LAYOUT = 1000;
var PRIORITY_VISUAL_GLOBAL = 2000;
var PRIORITY_VISUAL_CHART = 3000;
var PRIORITY_VISUAL_COMPONENT = 4000; // FIXME
// necessary?

var PRIORITY_VISUAL_BRUSH = 5000;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH
  }
}; // Main process have three entries: `setOption`, `dispatchAction` and `resize`,
// where they must not be invoked nestedly, except the only case: invoke
// dispatchAction with updateMethod "none" in main process.
// This flag is used to carry out this rule.
// All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).

var IN_MAIN_PROCESS = '__flagInMainProcess';
var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';
var OPTION_UPDATED = '__optionUpdated';
var ACTION_REG = /^[a-zA-Z0-9_]+$/;

function createRegisterEventWithLowercaseName(method) {
  return function (eventName, handler, context) {
    // Event name is all lowercase
    eventName = eventName && eventName.toLowerCase();
    Eventful.prototype[method].call(this, eventName, handler, context);
  };
}
/**
 * @module echarts~MessageCenter
 */


function MessageCenter() {
  Eventful.call(this);
}

MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');
MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');
MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');
zrUtil.mixin(MessageCenter, Eventful);
/**
 * @module echarts~ECharts
 */

function ECharts(dom, theme, opts) {
  opts = opts || {}; // Get theme by name

  if (typeof theme === 'string') {
    theme = themeStorage[theme];
  }
  /**
   * @type {string}
   */


  this.id;
  /**
   * Group id
   * @type {string}
   */

  this.group;
  /**
   * @type {HTMLElement}
   * @private
   */

  this._dom = dom;
  var defaultRenderer = 'canvas';

  /**
   * @type {module:zrender/ZRender}
   * @private
   */
  var zr = this._zr = zrender.init(dom, {
    renderer: opts.renderer || defaultRenderer,
    devicePixelRatio: opts.devicePixelRatio,
    width: opts.width,
    height: opts.height
  });
  /**
   * Expect 60 pfs.
   * @type {Function}
   * @private
   */

  this._throttledZrFlush = throttle(zrUtil.bind(zr.flush, zr), 17);
  var theme = zrUtil.clone(theme);
  theme && backwardCompat(theme, true);
  /**
   * @type {Object}
   * @private
   */

  this._theme = theme;
  /**
   * @type {Array.<module:echarts/view/Chart>}
   * @private
   */

  this._chartsViews = [];
  /**
   * @type {Object.<string, module:echarts/view/Chart>}
   * @private
   */

  this._chartsMap = {};
  /**
   * @type {Array.<module:echarts/view/Component>}
   * @private
   */

  this._componentsViews = [];
  /**
   * @type {Object.<string, module:echarts/view/Component>}
   * @private
   */

  this._componentsMap = {};
  /**
   * @type {module:echarts/CoordinateSystem}
   * @private
   */

  this._coordSysMgr = new CoordinateSystemManager();
  /**
   * @type {module:echarts/ExtensionAPI}
   * @private
   */

  this._api = createExtensionAPI(this);
  Eventful.call(this);
  /**
   * @type {module:echarts~MessageCenter}
   * @private
   */

  this._messageCenter = new MessageCenter(); // Init mouse events

  this._initEvents(); // In case some people write `window.onresize = chart.resize`


  this.resize = zrUtil.bind(this.resize, this); // Can't dispatch action during rendering procedure

  this._pendingActions = []; // Sort on demand

  function prioritySortFunc(a, b) {
    return a.prio - b.prio;
  }

  timsort(visualFuncs, prioritySortFunc);
  timsort(dataProcessorFuncs, prioritySortFunc);
  zr.animation.on('frame', this._onframe, this); // ECharts instance can be used as value.

  zrUtil.setAsPrimitive(this);
}

var echartsProto = ECharts.prototype;

echartsProto._onframe = function () {
  // Lazy update
  if (this[OPTION_UPDATED]) {
    var silent = this[OPTION_UPDATED].silent;
    this[IN_MAIN_PROCESS] = true;
    updateMethods.prepareAndUpdate.call(this);
    this[IN_MAIN_PROCESS] = false;
    this[OPTION_UPDATED] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  }
};
/**
 * @return {HTMLElement}
 */


echartsProto.getDom = function () {
  return this._dom;
};
/**
 * @return {module:zrender~ZRender}
 */


echartsProto.getZr = function () {
  return this._zr;
};
/**
 * Usage:
 * chart.setOption(option, notMerge, lazyUpdate);
 * chart.setOption(option, {
 *     notMerge: ...,
 *     lazyUpdate: ...,
 *     silent: ...
 * });
 *
 * @param {Object} option
 * @param {Object|boolean} [opts] opts or notMerge.
 * @param {boolean} [opts.notMerge=false]
 * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.
 */


echartsProto.setOption = function (option, notMerge, lazyUpdate) {
  var silent;

  if (zrUtil.isObject(notMerge)) {
    lazyUpdate = notMerge.lazyUpdate;
    silent = notMerge.silent;
    notMerge = notMerge.notMerge;
  }

  this[IN_MAIN_PROCESS] = true;

  if (!this._model || notMerge) {
    var optionManager = new OptionManager(this._api);
    var theme = this._theme;
    var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);
    ecModel.init(null, null, theme, optionManager);
  }

  this._model.setOption(option, optionPreprocessorFuncs);

  if (lazyUpdate) {
    this[OPTION_UPDATED] = {
      silent: silent
    };
    this[IN_MAIN_PROCESS] = false;
  } else {
    updateMethods.prepareAndUpdate.call(this); // Ensure zr refresh sychronously, and then pixel in canvas can be
    // fetched after `setOption`.

    this._zr.flush();

    this[OPTION_UPDATED] = false;
    this[IN_MAIN_PROCESS] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  }
};
/**
 * @DEPRECATED
 */


echartsProto.setTheme = function () {
  console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
};
/**
 * @return {module:echarts/model/Global}
 */


echartsProto.getModel = function () {
  return this._model;
};
/**
 * @return {Object}
 */


echartsProto.getOption = function () {
  return this._model && this._model.getOption();
};
/**
 * @return {number}
 */


echartsProto.getWidth = function () {
  return this._zr.getWidth();
};
/**
 * @return {number}
 */


echartsProto.getHeight = function () {
  return this._zr.getHeight();
};
/**
 * @return {number}
 */


echartsProto.getDevicePixelRatio = function () {
  return this._zr.painter.dpr || window.devicePixelRatio || 1;
};
/**
 * Get canvas which has all thing rendered
 * @param {Object} opts
 * @param {string} [opts.backgroundColor]
 * @return {string}
 */


echartsProto.getRenderedCanvas = function (opts) {
  if (!env.canvasSupported) {
    return;
  }

  opts = opts || {};
  opts.pixelRatio = opts.pixelRatio || 1;
  opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');
  var zr = this._zr;
  var list = zr.storage.getDisplayList(); // Stop animations

  zrUtil.each(list, function (el) {
    el.stopAnimation(true);
  });
  return zr.painter.getRenderedCanvas(opts);
};
/**
 * Get svg data url
 * @return {string}
 */


echartsProto.getSvgDataUrl = function () {
  if (!env.svgSupported) {
    return;
  }

  var zr = this._zr;
  var list = zr.storage.getDisplayList(); // Stop animations

  zrUtil.each(list, function (el) {
    el.stopAnimation(true);
  });
  return zr.painter.pathToSvg();
};
/**
 * @return {string}
 * @param {Object} opts
 * @param {string} [opts.type='png']
 * @param {string} [opts.pixelRatio=1]
 * @param {string} [opts.backgroundColor]
 * @param {string} [opts.excludeComponents]
 */


echartsProto.getDataURL = function (opts) {
  opts = opts || {};
  var excludeComponents = opts.excludeComponents;
  var ecModel = this._model;
  var excludesComponentViews = [];
  var self = this;
  each(excludeComponents, function (componentType) {
    ecModel.eachComponent({
      mainType: componentType
    }, function (component) {
      var view = self._componentsMap[component.__viewId];

      if (!view.group.ignore) {
        excludesComponentViews.push(view);
        view.group.ignore = true;
      }
    });
  });
  var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataUrl() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));
  each(excludesComponentViews, function (view) {
    view.group.ignore = false;
  });
  return url;
};
/**
 * @return {string}
 * @param {Object} opts
 * @param {string} [opts.type='png']
 * @param {string} [opts.pixelRatio=1]
 * @param {string} [opts.backgroundColor]
 */


echartsProto.getConnectedDataURL = function (opts) {
  if (!env.canvasSupported) {
    return;
  }

  var groupId = this.group;
  var mathMin = Math.min;
  var mathMax = Math.max;
  var MAX_NUMBER = Infinity;

  if (connectedGroups[groupId]) {
    var left = MAX_NUMBER;
    var top = MAX_NUMBER;
    var right = -MAX_NUMBER;
    var bottom = -MAX_NUMBER;
    var canvasList = [];
    var dpr = opts && opts.pixelRatio || 1;
    zrUtil.each(instances, function (chart, id) {
      if (chart.group === groupId) {
        var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));
        var boundingRect = chart.getDom().getBoundingClientRect();
        left = mathMin(boundingRect.left, left);
        top = mathMin(boundingRect.top, top);
        right = mathMax(boundingRect.right, right);
        bottom = mathMax(boundingRect.bottom, bottom);
        canvasList.push({
          dom: canvas,
          left: boundingRect.left,
          top: boundingRect.top
        });
      }
    });
    left *= dpr;
    top *= dpr;
    right *= dpr;
    bottom *= dpr;
    var width = right - left;
    var height = bottom - top;
    var targetCanvas = zrUtil.createCanvas();
    targetCanvas.width = width;
    targetCanvas.height = height;
    var zr = zrender.init(targetCanvas);
    each(canvasList, function (item) {
      var img = new graphic.Image({
        style: {
          x: item.left * dpr - left,
          y: item.top * dpr - top,
          image: item.dom
        }
      });
      zr.add(img);
    });
    zr.refreshImmediately();
    return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
  } else {
    return this.getDataURL(opts);
  }
};
/**
 * Convert from logical coordinate system to pixel coordinate system.
 * See CoordinateSystem#convertToPixel.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId, geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName,
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {Array|number} result
 */


echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');
/**
 * Convert from pixel coordinate system to logical coordinate system.
 * See CoordinateSystem#convertFromPixel.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId / geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {Array|number} result
 */

echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');

function doConvertPixel(methodName, finder, value) {
  var ecModel = this._model;

  var coordSysList = this._coordSysMgr.getCoordinateSystems();

  var result;
  finder = modelUtil.parseFinder(ecModel, finder);

  for (var i = 0; i < coordSysList.length; i++) {
    var coordSys = coordSysList[i];

    if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {
      return result;
    }
  }
}
/**
 * Is the specified coordinate systems or components contain the given pixel point.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId / geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName,
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {boolean} result
 */


echartsProto.containPixel = function (finder, value) {
  var ecModel = this._model;
  var result;
  finder = modelUtil.parseFinder(ecModel, finder);
  zrUtil.each(finder, function (models, key) {
    key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {
      var coordSys = model.coordinateSystem;

      if (coordSys && coordSys.containPoint) {
        result |= !!coordSys.containPoint(value);
      } else if (key === 'seriesModels') {
        var view = this._chartsMap[model.__viewId];

        if (view && view.containPoint) {
          result |= view.containPoint(value, model);
        } else {}
      } else {}
    }, this);
  }, this);
  return !!result;
};
/**
 * Get visual from series or data.
 * @param {string|Object} finder
 *        If string, e.g., 'series', means {seriesIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            dataIndex / dataIndexInside
 *        }
 *        If dataIndex is not specified, series visual will be fetched,
 *        but not data item visual.
 *        If all of seriesIndex, seriesId, seriesName are not specified,
 *        visual will be fetched from first series.
 * @param {string} visualType 'color', 'symbol', 'symbolSize'
 */


echartsProto.getVisual = function (finder, visualType) {
  var ecModel = this._model;
  finder = modelUtil.parseFinder(ecModel, finder, {
    defaultMainType: 'series'
  });
  var seriesModel = finder.seriesModel;
  var data = seriesModel.getData();
  var dataIndexInside = finder.hasOwnProperty('dataIndexInside') ? finder.dataIndexInside : finder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(finder.dataIndex) : null;
  return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);
};
/**
 * Get view of corresponding component model
 * @param  {module:echarts/model/Component} componentModel
 * @return {module:echarts/view/Component}
 */


echartsProto.getViewOfComponentModel = function (componentModel) {
  return this._componentsMap[componentModel.__viewId];
};
/**
 * Get view of corresponding series model
 * @param  {module:echarts/model/Series} seriesModel
 * @return {module:echarts/view/Chart}
 */


echartsProto.getViewOfSeriesModel = function (seriesModel) {
  return this._chartsMap[seriesModel.__viewId];
};

var updateMethods = {
  /**
   * @param {Object} payload
   * @private
   */
  update: function (payload) {
    // console.profile && console.profile('update');
    var ecModel = this._model;
    var api = this._api;
    var coordSysMgr = this._coordSysMgr;
    var zr = this._zr; // update before setOption

    if (!ecModel) {
      return;
    } // Fixme First time update ?


    ecModel.restoreData(); // TODO
    // Save total ecModel here for undo/redo (after restoring data and before processing data).
    // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
    // Create new coordinate system each update
    // In LineView may save the old coordinate system and use it to get the orignal point

    coordSysMgr.create(this._model, this._api);
    processData.call(this, ecModel, api);
    stackSeriesData.call(this, ecModel);
    coordSysMgr.update(ecModel, api);
    doVisualEncoding.call(this, ecModel, payload);
    doRender.call(this, ecModel, payload); // Set background

    var backgroundColor = ecModel.get('backgroundColor') || 'transparent';
    var painter = zr.painter; // TODO all use clearColor ?

    if (painter.isSingleCanvas && painter.isSingleCanvas()) {
      zr.configLayer(0, {
        clearColor: backgroundColor
      });
    } else {
      // In IE8
      if (!env.canvasSupported) {
        var colorArr = colorTool.parse(backgroundColor);
        backgroundColor = colorTool.stringify(colorArr, 'rgb');

        if (colorArr[3] === 0) {
          backgroundColor = 'transparent';
        }
      }

      if (backgroundColor.colorStops || backgroundColor.image) {
        // Gradient background
        // FIXME Fixed layer？
        zr.configLayer(0, {
          clearColor: backgroundColor
        });
        this[HAS_GRADIENT_OR_PATTERN_BG] = true;
        this._dom.style.background = 'transparent';
      } else {
        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {
          zr.configLayer(0, {
            clearColor: null
          });
        }

        this[HAS_GRADIENT_OR_PATTERN_BG] = false;
        this._dom.style.background = backgroundColor;
      }
    }

    each(postUpdateFuncs, function (func) {
      func(ecModel, api);
    }); // console.profile && console.profileEnd('update');
  },

  /**
   * @param {Object} payload
   * @private
   */
  updateView: function (payload) {
    var ecModel = this._model; // update before setOption

    if (!ecModel) {
      return;
    }

    ecModel.eachSeries(function (seriesModel) {
      seriesModel.getData().clearAllVisual();
    });
    doVisualEncoding.call(this, ecModel, payload);
    invokeUpdateMethod.call(this, 'updateView', ecModel, payload);
  },

  /**
   * @param {Object} payload
   * @private
   */
  updateVisual: function (payload) {
    var ecModel = this._model; // update before setOption

    if (!ecModel) {
      return;
    }

    ecModel.eachSeries(function (seriesModel) {
      seriesModel.getData().clearAllVisual();
    });
    doVisualEncoding.call(this, ecModel, payload, true);
    invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);
  },

  /**
   * @param {Object} payload
   * @private
   */
  updateLayout: function (payload) {
    var ecModel = this._model; // update before setOption

    if (!ecModel) {
      return;
    }

    doLayout.call(this, ecModel, payload);
    invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);
  },

  /**
   * @param {Object} payload
   * @private
   */
  prepareAndUpdate: function (payload) {
    var ecModel = this._model;
    prepareView.call(this, 'component', ecModel);
    prepareView.call(this, 'chart', ecModel);
    updateMethods.update.call(this, payload);
  }
};
/**
 * @private
 */

function updateDirectly(ecIns, method, payload, mainType, subType) {
  var ecModel = ecIns._model; // broadcast

  if (!mainType) {
    each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);
    return;
  }

  var query = {};
  query[mainType + 'Id'] = payload[mainType + 'Id'];
  query[mainType + 'Index'] = payload[mainType + 'Index'];
  query[mainType + 'Name'] = payload[mainType + 'Name'];
  var condition = {
    mainType: mainType,
    query: query
  };
  subType && (condition.subType = subType); // subType may be '' by parseClassType;
  // If dispatchAction before setOption, do nothing.

  ecModel && ecModel.eachComponent(condition, function (model, index) {
    callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);
  }, ecIns);

  function callView(view) {
    view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
  }
}
/**
 * Resize the chart
 * @param {Object} opts
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 * @param {boolean} [opts.silent=false]
 */


echartsProto.resize = function (opts) {
  this[IN_MAIN_PROCESS] = true;

  this._zr.resize(opts);

  var optionChanged = this._model && this._model.resetOption('media');

  var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';
  updateMethods[updateMethod].call(this); // Resize loading effect

  this._loadingFX && this._loadingFX.resize();
  this[IN_MAIN_PROCESS] = false;
  var silent = opts && opts.silent;
  flushPendingActions.call(this, silent);
  triggerUpdatedEvent.call(this, silent);
};
/**
 * Show loading effect
 * @param  {string} [name='default']
 * @param  {Object} [cfg]
 */


echartsProto.showLoading = function (name, cfg) {
  if (zrUtil.isObject(name)) {
    cfg = name;
    name = '';
  }

  name = name || 'default';
  this.hideLoading();

  if (!loadingEffects[name]) {
    return;
  }

  var el = loadingEffects[name](this._api, cfg);
  var zr = this._zr;
  this._loadingFX = el;
  zr.add(el);
};
/**
 * Hide loading effect
 */


echartsProto.hideLoading = function () {
  this._loadingFX && this._zr.remove(this._loadingFX);
  this._loadingFX = null;
};
/**
 * @param {Object} eventObj
 * @return {Object}
 */


echartsProto.makeActionFromEvent = function (eventObj) {
  var payload = zrUtil.extend({}, eventObj);
  payload.type = eventActionMap[eventObj.type];
  return payload;
};
/**
 * @pubilc
 * @param {Object} payload
 * @param {string} [payload.type] Action type
 * @param {Object|boolean} [opt] If pass boolean, means opt.silent
 * @param {boolean} [opt.silent=false] Whether trigger events.
 * @param {boolean} [opt.flush=undefined]
 *                  true: Flush immediately, and then pixel in canvas can be fetched
 *                      immediately. Caution: it might affect performance.
 *                  false: Not not flush.
 *                  undefined: Auto decide whether perform flush.
 */


echartsProto.dispatchAction = function (payload, opt) {
  if (!zrUtil.isObject(opt)) {
    opt = {
      silent: !!opt
    };
  }

  if (!actions[payload.type]) {
    return;
  } // Avoid dispatch action before setOption. Especially in `connect`.


  if (!this._model) {
    return;
  } // May dispatchAction in rendering procedure


  if (this[IN_MAIN_PROCESS]) {
    this._pendingActions.push(payload);

    return;
  }

  doDispatchAction.call(this, payload, opt.silent);

  if (opt.flush) {
    this._zr.flush(true);
  } else if (opt.flush !== false && env.browser.weChat) {
    // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`
    // hang when sliding page (on touch event), which cause that zr does not
    // refresh util user interaction finished, which is not expected.
    // But `dispatchAction` may be called too frequently when pan on touch
    // screen, which impacts performance if do not throttle them.
    this._throttledZrFlush();
  }

  flushPendingActions.call(this, opt.silent);
  triggerUpdatedEvent.call(this, opt.silent);
};

function doDispatchAction(payload, silent) {
  var payloadType = payload.type;
  var escapeConnect = payload.escapeConnect;
  var actionWrap = actions[payloadType];
  var actionInfo = actionWrap.actionInfo;
  var cptType = (actionInfo.update || 'update').split(':');
  var updateMethod = cptType.pop();
  cptType = cptType[0] != null && parseClassType(cptType[0]);
  this[IN_MAIN_PROCESS] = true;
  var payloads = [payload];
  var batched = false; // Batch action

  if (payload.batch) {
    batched = true;
    payloads = zrUtil.map(payload.batch, function (item) {
      item = zrUtil.defaults(zrUtil.extend({}, item), payload);
      item.batch = null;
      return item;
    });
  }

  var eventObjBatch = [];
  var eventObj;
  var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';
  each(payloads, function (batchItem) {
    // Action can specify the event by return it.
    eventObj = actionWrap.action(batchItem, this._model, this._api); // Emit event outside

    eventObj = eventObj || zrUtil.extend({}, batchItem); // Convert type to eventType

    eventObj.type = actionInfo.event || eventObj.type;
    eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual.

    if (isHighDown) {
      // method, payload, mainType, subType
      updateDirectly(this, updateMethod, batchItem, 'series');
    } else if (cptType) {
      updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
    }
  }, this);

  if (updateMethod !== 'none' && !isHighDown && !cptType) {
    // Still dirty
    if (this[OPTION_UPDATED]) {
      // FIXME Pass payload ?
      updateMethods.prepareAndUpdate.call(this, payload);
      this[OPTION_UPDATED] = false;
    } else {
      updateMethods[updateMethod].call(this, payload);
    }
  } // Follow the rule of action batch


  if (batched) {
    eventObj = {
      type: actionInfo.event || payloadType,
      escapeConnect: escapeConnect,
      batch: eventObjBatch
    };
  } else {
    eventObj = eventObjBatch[0];
  }

  this[IN_MAIN_PROCESS] = false;
  !silent && this._messageCenter.trigger(eventObj.type, eventObj);
}

function flushPendingActions(silent) {
  var pendingActions = this._pendingActions;

  while (pendingActions.length) {
    var payload = pendingActions.shift();
    doDispatchAction.call(this, payload, silent);
  }
}

function triggerUpdatedEvent(silent) {
  !silent && this.trigger('updated');
}
/**
 * Register event
 * @method
 */


echartsProto.on = createRegisterEventWithLowercaseName('on');
echartsProto.off = createRegisterEventWithLowercaseName('off');
echartsProto.one = createRegisterEventWithLowercaseName('one');
/**
 * @param {string} methodName
 * @private
 */

function invokeUpdateMethod(methodName, ecModel, payload) {
  var api = this._api; // Update all components

  each(this._componentsViews, function (component) {
    var componentModel = component.__model;
    component[methodName](componentModel, ecModel, api, payload);
    updateZ(componentModel, component);
  }, this); // Upate all charts

  ecModel.eachSeries(function (seriesModel, idx) {
    var chart = this._chartsMap[seriesModel.__viewId];
    chart[methodName](seriesModel, ecModel, api, payload);
    updateZ(seriesModel, chart);
    updateProgressiveAndBlend(seriesModel, chart);
  }, this); // If use hover layer

  updateHoverLayerStatus(this._zr, ecModel); // Post render

  each(postUpdateFuncs, function (func) {
    func(ecModel, api);
  });
}
/**
 * Prepare view instances of charts and components
 * @param  {module:echarts/model/Global} ecModel
 * @private
 */


function prepareView(type, ecModel) {
  var isComponent = type === 'component';
  var viewList = isComponent ? this._componentsViews : this._chartsViews;
  var viewMap = isComponent ? this._componentsMap : this._chartsMap;
  var zr = this._zr;

  for (var i = 0; i < viewList.length; i++) {
    viewList[i].__alive = false;
  }

  ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {
    if (isComponent) {
      if (componentType === 'series') {
        return;
      }
    } else {
      model = componentType;
    } // Consider: id same and type changed.


    var viewId = '_ec_' + model.id + '_' + model.type;
    var view = viewMap[viewId];

    if (!view) {
      var classType = parseClassType(model.type);
      var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);

      if (Clazz) {
        view = new Clazz();
        view.init(ecModel, this._api);
        viewMap[viewId] = view;
        viewList.push(view);
        zr.add(view.group);
      } else {
        // Error
        return;
      }
    }

    model.__viewId = view.__id = viewId;
    view.__alive = true;
    view.__model = model;
    view.group.__ecComponentInfo = {
      mainType: model.mainType,
      index: model.componentIndex
    };
  }, this);

  for (var i = 0; i < viewList.length;) {
    var view = viewList[i];

    if (!view.__alive) {
      zr.remove(view.group);
      view.dispose(ecModel, this._api);
      viewList.splice(i, 1);
      delete viewMap[view.__id];
      view.__id = view.group.__ecComponentInfo = null;
    } else {
      i++;
    }
  }
}
/**
 * Processor data in each series
 *
 * @param {module:echarts/model/Global} ecModel
 * @private
 */


function processData(ecModel, api) {
  each(dataProcessorFuncs, function (process) {
    process.func(ecModel, api);
  });
}
/**
 * @private
 */


function stackSeriesData(ecModel) {
  var stackedDataMap = {};
  ecModel.eachSeries(function (series) {
    var stack = series.get('stack');
    var data = series.getData();

    if (stack && data.type === 'list') {
      var previousStack = stackedDataMap[stack]; // Avoid conflict with Object.prototype

      if (stackedDataMap.hasOwnProperty(stack) && previousStack) {
        data.stackedOn = previousStack;
      }

      stackedDataMap[stack] = data;
    }
  });
}
/**
 * Layout before each chart render there series, special visual encoding stage
 *
 * @param {module:echarts/model/Global} ecModel
 * @private
 */


function doLayout(ecModel, payload) {
  var api = this._api;
  each(visualFuncs, function (visual) {
    if (visual.isLayout) {
      visual.func(ecModel, api, payload);
    }
  });
}
/**
 * Encode visual infomation from data after data processing
 *
 * @param {module:echarts/model/Global} ecModel
 * @param {object} layout
 * @param {boolean} [excludesLayout]
 * @private
 */


function doVisualEncoding(ecModel, payload, excludesLayout) {
  var api = this._api;
  ecModel.clearColorPalette();
  ecModel.eachSeries(function (seriesModel) {
    seriesModel.clearColorPalette();
  });
  each(visualFuncs, function (visual) {
    (!excludesLayout || !visual.isLayout) && visual.func(ecModel, api, payload);
  });
}
/**
 * Render each chart and component
 * @private
 */


function doRender(ecModel, payload) {
  var api = this._api; // Render all components

  each(this._componentsViews, function (componentView) {
    var componentModel = componentView.__model;
    componentView.render(componentModel, ecModel, api, payload);
    updateZ(componentModel, componentView);
  }, this);
  each(this._chartsViews, function (chart) {
    chart.__alive = false;
  }, this); // Render all charts

  ecModel.eachSeries(function (seriesModel, idx) {
    var chartView = this._chartsMap[seriesModel.__viewId];
    chartView.__alive = true;
    chartView.render(seriesModel, ecModel, api, payload);
    chartView.group.silent = !!seriesModel.get('silent');
    updateZ(seriesModel, chartView);
    updateProgressiveAndBlend(seriesModel, chartView);
  }, this); // If use hover layer

  updateHoverLayerStatus(this._zr, ecModel); // Remove groups of unrendered charts

  each(this._chartsViews, function (chart) {
    if (!chart.__alive) {
      chart.remove(ecModel, api);
    }
  }, this);
}

var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];
/**
 * @private
 */

echartsProto._initEvents = function () {
  each(MOUSE_EVENT_NAMES, function (eveName) {
    this._zr.on(eveName, function (e) {
      var ecModel = this.getModel();
      var el = e.target;
      var params; // no e.target when 'globalout'.

      if (eveName === 'globalout') {
        params = {};
      } else if (el && el.dataIndex != null) {
        var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
        params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};
      } // If element has custom eventData of components
      else if (el && el.eventData) {
          params = zrUtil.extend({}, el.eventData);
        }

      if (params) {
        params.event = e;
        params.type = eveName;
        this.trigger(eveName, params);
      }
    }, this);
  }, this);
  each(eventActionMap, function (actionType, eventType) {
    this._messageCenter.on(eventType, function (event) {
      this.trigger(eventType, event);
    }, this);
  }, this);
};
/**
 * @return {boolean}
 */


echartsProto.isDisposed = function () {
  return this._disposed;
};
/**
 * Clear
 */


echartsProto.clear = function () {
  this.setOption({
    series: []
  }, true);
};
/**
 * Dispose instance
 */


echartsProto.dispose = function () {
  if (this._disposed) {
    return;
  }

  this._disposed = true;
  var api = this._api;
  var ecModel = this._model;
  each(this._componentsViews, function (component) {
    component.dispose(ecModel, api);
  });
  each(this._chartsViews, function (chart) {
    chart.dispose(ecModel, api);
  }); // Dispose after all views disposed

  this._zr.dispose();

  delete instances[this.id];
};

zrUtil.mixin(ECharts, Eventful);

function updateHoverLayerStatus(zr, ecModel) {
  var storage = zr.storage;
  var elCount = 0;
  storage.traverse(function (el) {
    if (!el.isGroup) {
      elCount++;
    }
  });

  if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {
    storage.traverse(function (el) {
      if (!el.isGroup) {
        el.useHoverLayer = true;
      }
    });
  }
}
/**
 * Update chart progressive and blend.
 * @param {module:echarts/model/Series|module:echarts/model/Component} model
 * @param {module:echarts/view/Component|module:echarts/view/Chart} view
 */


function updateProgressiveAndBlend(seriesModel, chartView) {
  // Progressive configuration
  var elCount = 0;
  chartView.group.traverse(function (el) {
    if (el.type !== 'group' && !el.ignore) {
      elCount++;
    }
  });
  var frameDrawNum = +seriesModel.get('progressive');
  var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;

  if (needProgressive) {
    chartView.group.traverse(function (el) {
      // FIXME marker and other components
      if (!el.isGroup) {
        el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;

        if (needProgressive) {
          el.stopAnimation(true);
        }
      }
    });
  } // Blend configration


  var blendMode = seriesModel.get('blendMode') || null;
  chartView.group.traverse(function (el) {
    // FIXME marker and other components
    if (!el.isGroup) {
      el.setStyle('blend', blendMode);
    }
  });
}
/**
 * @param {module:echarts/model/Series|module:echarts/model/Component} model
 * @param {module:echarts/view/Component|module:echarts/view/Chart} view
 */


function updateZ(model, view) {
  var z = model.get('z');
  var zlevel = model.get('zlevel'); // Set z and zlevel

  view.group.traverse(function (el) {
    if (el.type !== 'group') {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
    }
  });
}

function createExtensionAPI(ecInstance) {
  var coordSysMgr = ecInstance._coordSysMgr;
  return zrUtil.extend(new ExtensionAPI(ecInstance), {
    // Inject methods
    getCoordinateSystems: zrUtil.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),
    getComponentByElement: function (el) {
      while (el) {
        var modelInfo = el.__ecComponentInfo;

        if (modelInfo != null) {
          return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);
        }

        el = el.parent;
      }
    }
  });
}
/**
 * @type {Object} key: actionType.
 * @inner
 */


var actions = {};
/**
 * Map eventType to actionType
 * @type {Object}
 */

var eventActionMap = {};
/**
 * Data processor functions of each stage
 * @type {Array.<Object.<string, Function>>}
 * @inner
 */

var dataProcessorFuncs = [];
/**
 * @type {Array.<Function>}
 * @inner
 */

var optionPreprocessorFuncs = [];
/**
 * @type {Array.<Function>}
 * @inner
 */

var postUpdateFuncs = [];
/**
 * Visual encoding functions of each stage
 * @type {Array.<Object.<string, Function>>}
 * @inner
 */

var visualFuncs = [];
/**
 * Theme storage
 * @type {Object.<key, Object>}
 */

var themeStorage = {};
/**
 * Loading effects
 */

var loadingEffects = {};
var instances = {};
var connectedGroups = {};
var idBase = new Date() - 0;
var groupIdBase = new Date() - 0;
var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
var mapDataStores = {};

function enableConnect(chart) {
  var STATUS_PENDING = 0;
  var STATUS_UPDATING = 1;
  var STATUS_UPDATED = 2;
  var STATUS_KEY = '__connectUpdateStatus';

  function updateConnectedChartsStatus(charts, status) {
    for (var i = 0; i < charts.length; i++) {
      var otherChart = charts[i];
      otherChart[STATUS_KEY] = status;
    }
  }

  zrUtil.each(eventActionMap, function (actionType, eventType) {
    chart._messageCenter.on(eventType, function (event) {
      if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
        if (event && event.escapeConnect) {
          return;
        }

        var action = chart.makeActionFromEvent(event);
        var otherCharts = [];
        zrUtil.each(instances, function (otherChart) {
          if (otherChart !== chart && otherChart.group === chart.group) {
            otherCharts.push(otherChart);
          }
        });
        updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
        each(otherCharts, function (otherChart) {
          if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
            otherChart.dispatchAction(action);
          }
        });
        updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
      }
    });
  });
}
/**
 * @param {HTMLElement} dom
 * @param {Object} [theme]
 * @param {Object} opts
 * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default
 * @param {string} [opts.renderer] Currently only 'canvas' is supported.
 * @param {number} [opts.width] Use clientWidth of the input `dom` by default.
 *                              Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Use clientHeight of the input `dom` by default.
 *                               Can be 'auto' (the same as null/undefined)
 */


function init(dom, theme, opts) {
  var existInstance = getInstanceByDom(dom);

  if (existInstance) {
    return existInstance;
  }

  var chart = new ECharts(dom, theme, opts);
  chart.id = 'ec_' + idBase++;
  instances[chart.id] = chart;

  if (dom.setAttribute) {
    dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);
  } else {
    dom[DOM_ATTRIBUTE_KEY] = chart.id;
  }

  enableConnect(chart);
  return chart;
}
/**
 * @return {string|Array.<module:echarts~ECharts>} groupId
 */


function connect(groupId) {
  // Is array of charts
  if (zrUtil.isArray(groupId)) {
    var charts = groupId;
    groupId = null; // If any chart has group

    zrUtil.each(charts, function (chart) {
      if (chart.group != null) {
        groupId = chart.group;
      }
    });
    groupId = groupId || 'g_' + groupIdBase++;
    zrUtil.each(charts, function (chart) {
      chart.group = groupId;
    });
  }

  connectedGroups[groupId] = true;
  return groupId;
}
/**
 * @DEPRECATED
 * @return {string} groupId
 */


function disConnect(groupId) {
  connectedGroups[groupId] = false;
}
/**
 * @return {string} groupId
 */


var disconnect = disConnect;
/**
 * Dispose a chart instance
 * @param  {module:echarts~ECharts|HTMLDomElement|string} chart
 */

function dispose(chart) {
  if (typeof chart === 'string') {
    chart = instances[chart];
  } else if (!(chart instanceof ECharts)) {
    // Try to treat as dom
    chart = getInstanceByDom(chart);
  }

  if (chart instanceof ECharts && !chart.isDisposed()) {
    chart.dispose();
  }
}
/**
 * @param  {HTMLElement} dom
 * @return {echarts~ECharts}
 */


function getInstanceByDom(dom) {
  var key;

  if (dom.getAttribute) {
    key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
  } else {
    key = dom[DOM_ATTRIBUTE_KEY];
  }

  return instances[key];
}
/**
 * @param {string} key
 * @return {echarts~ECharts}
 */


function getInstanceById(key) {
  return instances[key];
}
/**
 * Register theme
 */


function registerTheme(name, theme) {
  themeStorage[name] = theme;
}
/**
 * Register option preprocessor
 * @param {Function} preprocessorFunc
 */


function registerPreprocessor(preprocessorFunc) {
  optionPreprocessorFuncs.push(preprocessorFunc);
}
/**
 * @param {number} [priority=1000]
 * @param {Function} processorFunc
 */


function registerProcessor(priority, processorFunc) {
  if (typeof priority === 'function') {
    processorFunc = priority;
    priority = PRIORITY_PROCESSOR_FILTER;
  }

  dataProcessorFuncs.push({
    prio: priority,
    func: processorFunc
  });
}
/**
 * Register postUpdater
 * @param {Function} postUpdateFunc
 */


function registerPostUpdate(postUpdateFunc) {
  postUpdateFuncs.push(postUpdateFunc);
}
/**
 * Usage:
 * registerAction('someAction', 'someEvent', function () { ... });
 * registerAction('someAction', function () { ... });
 * registerAction(
 *     {type: 'someAction', event: 'someEvent', update: 'updateView'},
 *     function () { ... }
 * );
 *
 * @param {(string|Object)} actionInfo
 * @param {string} actionInfo.type
 * @param {string} [actionInfo.event]
 * @param {string} [actionInfo.update]
 * @param {string} [eventName]
 * @param {Function} action
 */


function registerAction(actionInfo, eventName, action) {
  if (typeof eventName === 'function') {
    action = eventName;
    eventName = '';
  }

  var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
    event: eventName
  }][0]; // Event name is all lowercase

  actionInfo.event = (actionInfo.event || actionType).toLowerCase();
  eventName = actionInfo.event; // Validate action type and event name.

  zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));

  if (!actions[actionType]) {
    actions[actionType] = {
      action: action,
      actionInfo: actionInfo
    };
  }

  eventActionMap[eventName] = actionType;
}
/**
 * @param {string} type
 * @param {*} CoordinateSystem
 */


function registerCoordinateSystem(type, CoordinateSystem) {
  CoordinateSystemManager.register(type, CoordinateSystem);
}
/**
 * Get dimensions of specified coordinate system.
 * @param {string} type
 * @return {Array.<string|Object>}
 */


function getCoordinateSystemDimensions(type) {
  var coordSysCreator = CoordinateSystemManager.get(type);

  if (coordSysCreator) {
    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
  }
}
/**
 * Layout is a special stage of visual encoding
 * Most visual encoding like color are common for different chart
 * But each chart has it's own layout algorithm
 *
 * @param {number} [priority=1000]
 * @param {Function} layoutFunc
 */


function registerLayout(priority, layoutFunc) {
  if (typeof priority === 'function') {
    layoutFunc = priority;
    priority = PRIORITY_VISUAL_LAYOUT;
  }

  visualFuncs.push({
    prio: priority,
    func: layoutFunc,
    isLayout: true
  });
}
/**
 * @param {number} [priority=3000]
 * @param {Function} visualFunc
 */


function registerVisual(priority, visualFunc) {
  if (typeof priority === 'function') {
    visualFunc = priority;
    priority = PRIORITY_VISUAL_CHART;
  }

  visualFuncs.push({
    prio: priority,
    func: visualFunc
  });
}
/**
 * @param {string} name
 */


function registerLoading(name, loadingFx) {
  loadingEffects[name] = loadingFx;
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendComponentModel(opts
/*, superClass*/
) {
  // var Clazz = ComponentModel;
  // if (superClass) {
  //     var classType = parseClassType(superClass);
  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
  // }
  return ComponentModel.extend(opts);
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendComponentView(opts
/*, superClass*/
) {
  // var Clazz = ComponentView;
  // if (superClass) {
  //     var classType = parseClassType(superClass);
  //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);
  // }
  return ComponentView.extend(opts);
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendSeriesModel(opts
/*, superClass*/
) {
  // var Clazz = SeriesModel;
  // if (superClass) {
  //     superClass = 'series.' + superClass.replace('series.', '');
  //     var classType = parseClassType(superClass);
  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
  // }
  return SeriesModel.extend(opts);
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendChartView(opts
/*, superClass*/
) {
  // var Clazz = ChartView;
  // if (superClass) {
  //     superClass = superClass.replace('series.', '');
  //     var classType = parseClassType(superClass);
  //     Clazz = ChartView.getClass(classType.main, true);
  // }
  return ChartView.extend(opts);
}
/**
 * ZRender need a canvas context to do measureText.
 * But in node environment canvas may be created by node-canvas.
 * So we need to specify how to create a canvas instead of using document.createElement('canvas')
 *
 * Be careful of using it in the browser.
 *
 * @param {Function} creator
 * @example
 *     var Canvas = require('canvas');
 *     var echarts = require('echarts');
 *     echarts.setCanvasCreator(function () {
 *         // Small size is enough.
 *         return new Canvas(32, 32);
 *     });
 */


function setCanvasCreator(creator) {
  zrUtil.$override('createCanvas', creator);
}
/**
 * @param {string} mapName
 * @param {Object|string} geoJson
 * @param {Object} [specialAreas]
 *
 * @example
 *     $.get('USA.json', function (geoJson) {
 *         echarts.registerMap('USA', geoJson);
 *         // Or
 *         echarts.registerMap('USA', {
 *             geoJson: geoJson,
 *             specialAreas: {}
 *         })
 *     });
 */


function registerMap(mapName, geoJson, specialAreas) {
  if (geoJson.geoJson && !geoJson.features) {
    specialAreas = geoJson.specialAreas;
    geoJson = geoJson.geoJson;
  }

  if (typeof geoJson === 'string') {
    geoJson = typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(geoJson) : new Function('return (' + geoJson + ');')();
  }

  mapDataStores[mapName] = {
    geoJson: geoJson,
    specialAreas: specialAreas
  };
}
/**
 * @param {string} mapName
 * @return {Object}
 */


function getMap(mapName) {
  return mapDataStores[mapName];
}

registerVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);
registerPreprocessor(backwardCompat);
registerLoading('default', loadingDefault); // Default actions

registerAction({
  type: 'highlight',
  event: 'highlight',
  update: 'highlight'
}, zrUtil.noop);
registerAction({
  type: 'downplay',
  event: 'downplay',
  update: 'downplay'
}, zrUtil.noop); // For backward compatibility, where the namespace `dataTool` will
// be mounted on `echarts` is the extension `dataTool` is imported.

var dataTool = {};
exports.version = version;
exports.dependencies = dependencies;
exports.PRIORITY = PRIORITY;
exports.init = init;
exports.connect = connect;
exports.disConnect = disConnect;
exports.disconnect = disconnect;
exports.dispose = dispose;
exports.getInstanceByDom = getInstanceByDom;
exports.getInstanceById = getInstanceById;
exports.registerTheme = registerTheme;
exports.registerPreprocessor = registerPreprocessor;
exports.registerProcessor = registerProcessor;
exports.registerPostUpdate = registerPostUpdate;
exports.registerAction = registerAction;
exports.registerCoordinateSystem = registerCoordinateSystem;
exports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;
exports.registerLayout = registerLayout;
exports.registerVisual = registerVisual;
exports.registerLoading = registerLoading;
exports.extendComponentModel = extendComponentModel;
exports.extendComponentView = extendComponentView;
exports.extendSeriesModel = extendSeriesModel;
exports.extendChartView = extendChartView;
exports.setCanvasCreator = setCanvasCreator;
exports.registerMap = registerMap;
exports.getMap = getMap;
exports.dataTool = dataTool;
var ___ec_export = __webpack_require__("./node_modules/echarts/lib/export.js");
(function () {
    for (var key in ___ec_export) {
        if (___ec_export.hasOwnProperty(key)) {
            exports[key] = ___ec_export[key];
        }
    }
})();

/***/ }),

/***/ "./node_modules/echarts/lib/export.js":
/***/ (function(module, exports, __webpack_require__) {

var zrender = __webpack_require__("./node_modules/zrender/lib/zrender.js");

exports.zrender = zrender;

var matrix = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

exports.matrix = matrix;

var vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

exports.vector = vector;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var colorTool = __webpack_require__("./node_modules/zrender/lib/tool/color.js");

exports.color = colorTool;

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

exports.graphic = graphic;

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

exports.number = numberUtil;

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

exports.format = formatUtil;

var _throttle = __webpack_require__("./node_modules/echarts/lib/util/throttle.js");

var throttle = _throttle.throttle;
exports.throttle = _throttle.throttle;

var ecHelper = __webpack_require__("./node_modules/echarts/lib/helper.js");

exports.helper = ecHelper;

var _List = __webpack_require__("./node_modules/echarts/lib/data/List.js");

exports.List = _List;

var _Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

exports.Model = _Model;

var _Axis = __webpack_require__("./node_modules/echarts/lib/coord/Axis.js");

exports.Axis = _Axis;

var _env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

exports.env = _env;

var _parseGeoJson = __webpack_require__("./node_modules/echarts/lib/coord/geo/parseGeoJson.js");

exports.parseGeoJson = _parseGeoJson;

/**
 * Do not mount those modules on 'src/echarts' for better tree shaking.
 */
var ecUtil = {};
zrUtil.each(['map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults', 'clone', 'merge'], function (name) {
  ecUtil[name] = zrUtil[name];
});
exports.util = ecUtil;

/***/ }),

/***/ "./node_modules/echarts/lib/helper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var createListFromArray = __webpack_require__("./node_modules/echarts/lib/chart/helper/createListFromArray.js");

var axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

var axisModelCommonMixin = __webpack_require__("./node_modules/echarts/lib/coord/axisModelCommonMixin.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var _completeDimensions = __webpack_require__("./node_modules/echarts/lib/data/helper/completeDimensions.js");

exports.completeDimensions = _completeDimensions;

var _symbol = __webpack_require__("./node_modules/echarts/lib/util/symbol.js");

exports.createSymbol = _symbol.createSymbol;

/**
 * Create a muti dimension List structure from seriesModel.
 * @param  {module:echarts/model/Model} seriesModel
 * @return {module:echarts/data/List} list
 */
function createList(seriesModel) {
  var data = seriesModel.get('data');
  return createListFromArray(data, seriesModel, seriesModel.ecModel);
}
/**
 * @see {module:echarts/data/helper/completeDimensions}
 */


/**
 * Create scale
 * @param {Array.<number>} dataExtent
 * @param {Object|module:echarts/Model} option
 */
function createScale(dataExtent, option) {
  var axisModel = option;

  if (!(option instanceof Model)) {
    axisModel = new Model(option);
    zrUtil.mixin(axisModel, axisModelCommonMixin);
  }

  var scale = axisHelper.createScaleByModel(axisModel);
  scale.setExtent(dataExtent[0], dataExtent[1]);
  axisHelper.niceScaleExtent(scale, axisModel);
  return scale;
}
/**
 * Mixin common methods to axis model,
 *
 * Inlcude methods
 * `getFormattedLabels() => Array.<string>`
 * `getCategories() => Array.<string>`
 * `getMin(origin: boolean) => number`
 * `getMax(origin: boolean) => number`
 * `getNeedCrossZero() => boolean`
 * `setRange(start: number, end: number)`
 * `resetRange()`
 */


function mixinAxisModelCommonMethods(Model) {
  zrUtil.mixin(Model, axisModelCommonMixin);
}

exports.createList = createList;
exports.createScale = createScale;
exports.mixinAxisModelCommonMethods = mixinAxisModelCommonMethods;

/***/ }),

/***/ "./node_modules/echarts/lib/lang.js":
/***/ (function(module, exports) {

var _default = {
  toolbox: {
    brush: {
      title: {
        rect: '矩形选择',
        polygon: '圈选',
        lineX: '横向选择',
        lineY: '纵向选择',
        keep: '保持选择',
        clear: '清除选择'
      }
    },
    dataView: {
      title: '数据视图',
      lang: ['数据视图', '关闭', '刷新']
    },
    dataZoom: {
      title: {
        zoom: '区域缩放',
        back: '区域缩放还原'
      }
    },
    magicType: {
      title: {
        line: '切换为折线图',
        bar: '切换为柱状图',
        stack: '切换为堆叠',
        tiled: '切换为平铺'
      }
    },
    restore: {
      title: '还原'
    },
    saveAsImage: {
      title: '保存为图片',
      lang: ['右键另存为图片']
    }
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/layout/barGrid.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var parsePercent = _number.parsePercent;
var STACK_PREFIX = '__ec_stack_';

function getSeriesStackId(seriesModel) {
  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;
}

function getAxisKey(axis) {
  return axis.dim + axis.index;
}
/**
 * @param {Object} opt
 * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.
 * @param {number} opt.count Positive interger.
 * @param {number} [opt.barWidth]
 * @param {number} [opt.barMaxWidth]
 * @param {number} [opt.barGap]
 * @param {number} [opt.barCategoryGap]
 * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
 */


function getLayoutOnAxis(opt, api) {
  var params = [];
  var baseAxis = opt.axis;
  var axisKey = 'axis0';

  if (baseAxis.type !== 'category') {
    return;
  }

  var bandWidth = baseAxis.getBandWidth();

  for (var i = 0; i < opt.count || 0; i++) {
    params.push(zrUtil.defaults({
      bandWidth: bandWidth,
      axisKey: axisKey,
      stackId: STACK_PREFIX + i
    }, opt));
  }

  var widthAndOffsets = doCalBarWidthAndOffset(params, api);
  var result = [];

  for (var i = 0; i < opt.count; i++) {
    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
    item.offsetCenter = item.offset + item.width / 2;
    result.push(item);
  }

  return result;
}

function calBarWidthAndOffset(barSeries, api) {
  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {
    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var axisExtent = baseAxis.getExtent();
    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);
    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);
    var barGap = seriesModel.get('barGap');
    var barCategoryGap = seriesModel.get('barCategoryGap');
    return {
      bandWidth: bandWidth,
      barWidth: barWidth,
      barMaxWidth: barMaxWidth,
      barGap: barGap,
      barCategoryGap: barCategoryGap,
      axisKey: getAxisKey(baseAxis),
      stackId: getSeriesStackId(seriesModel)
    };
  });
  return doCalBarWidthAndOffset(seriesInfoList, api);
}

function doCalBarWidthAndOffset(seriesInfoList, api) {
  // Columns info on each category axis. Key is cartesian name
  var columnsMap = {};
  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {
    var axisKey = seriesInfo.axisKey;
    var bandWidth = seriesInfo.bandWidth;
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth: bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: '20%',
      gap: '30%',
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = seriesInfo.stackId;

    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }

    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    }; // Caution: In a single coordinate system, these barGrid attributes
    // will be shared by series. Consider that they have default values,
    // only the attributes set on the last series will work.
    // Do not change this fact unless there will be a break change.
    // TODO

    var barWidth = seriesInfo.barWidth;

    if (barWidth && !stacks[stackId].width) {
      // See #6312, do not restrict width.
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }

    var barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    var barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    var barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth

    zrUtil.each(stacks, function (column, stack) {
      var maxWidth = column.maxWidth;

      if (maxWidth && maxWidth < autoWidth) {
        maxWidth = Math.min(maxWidth, remainedWidth);

        if (column.width) {
          maxWidth = Math.min(maxWidth, column.width);
        }

        remainedWidth -= maxWidth;
        column.width = maxWidth;
        autoWidthCount--;
      }
    }); // Recalculate width again

    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    zrUtil.each(stacks, function (column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }

      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });

    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }

    var offset = -widthSum / 2;
    zrUtil.each(stacks, function (column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        offset: offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
/**
 * @param {string} seriesType
 * @param {module:echarts/model/Global} ecModel
 * @param {module:echarts/ExtensionAPI} api
 */


function barLayoutGrid(seriesType, ecModel, api) {
  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {
    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';
  }));
  var lastStackCoords = {};
  var lastStackCoordsOrigin = {};
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    // Check series coordinate, do layout for cartesian2d only
    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {
      return;
    }

    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var stackId = getSeriesStackId(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    var valueAxis = cartesian.getOtherAxis(baseAxis);
    var barMinHeight = seriesModel.get('barMinHeight') || 0;
    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];
    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];
    var coords = data.mapArray(coordDims, function (x, y) {
      return cartesian.dataToPoint([x, y]);
    }, true);
    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243

    data.setLayout({
      offset: columnOffset,
      size: columnWidth
    });
    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {
      if (isNaN(value)) {
        return;
      }

      if (!lastStackCoords[stackId][idx]) {
        lastStackCoords[stackId][idx] = {
          p: valueAxisStart,
          // Positive stack
          n: valueAxisStart // Negative stack

        };
        lastStackCoordsOrigin[stackId][idx] = {
          p: valueAxisStart,
          // Positive stack
          n: valueAxisStart // Negative stack

        };
      }

      var sign = value >= 0 ? 'p' : 'n';
      var coord = coords[idx];
      var lastCoord = lastStackCoords[stackId][idx][sign];
      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];
      var x;
      var y;
      var width;
      var height;

      if (valueAxis.isHorizontal()) {
        x = lastCoord;
        y = coord[1] + columnOffset;
        width = coord[0] - lastCoordOrigin;
        height = columnWidth;
        lastStackCoordsOrigin[stackId][idx][sign] += width;

        if (Math.abs(width) < barMinHeight) {
          width = (width < 0 ? -1 : 1) * barMinHeight;
        }

        lastStackCoords[stackId][idx][sign] += width;
      } else {
        x = coord[0] + columnOffset;
        y = lastCoord;
        width = columnWidth;
        height = coord[1] - lastCoordOrigin;
        lastStackCoordsOrigin[stackId][idx][sign] += height;

        if (Math.abs(height) < barMinHeight) {
          // Include zero to has a positive bar
          height = (height <= 0 ? -1 : 1) * barMinHeight;
        }

        lastStackCoords[stackId][idx][sign] += height;
      }

      data.setItemLayout(idx, {
        x: x,
        y: y,
        width: width,
        height: height
      });
    }, true);
  }, this);
}

barLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;
var _default = barLayoutGrid;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/layout/points.js":
/***/ (function(module, exports) {

function _default(seriesType, ecModel) {
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;

    if (!coordSys) {
      return;
    }

    var dims = [];
    var coordDims = coordSys.dimensions;

    for (var i = 0; i < coordDims.length; i++) {
      dims.push(seriesModel.coordDimToDataDim(coordSys.dimensions[i])[0]);
    }

    if (dims.length === 1) {
      data.each(dims[0], function (x, idx) {
        // Also {Array.<number>}, not undefined to avoid if...else... statement
        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));
      });
    } else if (dims.length === 2) {
      data.each(dims, function (x, y, idx) {
        // Also {Array.<number>}, not undefined to avoid if...else... statement
        data.setItemLayout(idx, isNaN(x) || isNaN(y) ? [NaN, NaN] : coordSys.dataToPoint([x, y]));
      }, true);
    }
  });
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/loading/default.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var PI = Math.PI;
/**
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} [opts]
 * @param {string} [opts.text]
 * @param {string} [opts.color]
 * @param {string} [opts.textColor]
 * @return {module:zrender/Element}
 */

function _default(api, opts) {
  opts = opts || {};
  zrUtil.defaults(opts, {
    text: 'loading',
    color: '#c23531',
    textColor: '#000',
    maskColor: 'rgba(255, 255, 255, 0.8)',
    zlevel: 0
  });
  var mask = new graphic.Rect({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 10000
  });
  var arc = new graphic.Arc({
    shape: {
      startAngle: -PI / 2,
      endAngle: -PI / 2 + 0.1,
      r: 10
    },
    style: {
      stroke: opts.color,
      lineCap: 'round',
      lineWidth: 5
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  var labelRect = new graphic.Rect({
    style: {
      fill: 'none',
      text: opts.text,
      textPosition: 'right',
      textDistance: 10,
      textFill: opts.textColor
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  arc.animateShape(true).when(1000, {
    endAngle: PI * 3 / 2
  }).start('circularInOut');
  arc.animateShape(true).when(1000, {
    startAngle: PI * 3 / 2
  }).delay(300).start('circularInOut');
  var group = new graphic.Group();
  group.add(arc);
  group.add(labelRect);
  group.add(mask); // Inject resize

  group.resize = function () {
    var cx = api.getWidth() / 2;
    var cy = api.getHeight() / 2;
    arc.setShape({
      cx: cx,
      cy: cy
    });
    var r = arc.shape.r;
    labelRect.setShape({
      x: cx - r,
      y: cy - r,
      width: r * 2,
      height: r * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api.getWidth(),
      height: api.getHeight()
    });
  };

  group.resize();
  return group;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/Component.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var componentUtil = __webpack_require__("./node_modules/echarts/lib/util/component.js");

var clazzUtil = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var boxLayoutMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/boxLayout.js");

/**
 * Component model
 *
 * @module echarts/model/Component
 */
var arrayPush = Array.prototype.push;
/**
 * @alias module:echarts/model/Component
 * @constructor
 * @param {Object} option
 * @param {module:echarts/model/Model} parentModel
 * @param {module:echarts/model/Model} ecModel
 */

var ComponentModel = Model.extend({
  type: 'component',

  /**
   * @readOnly
   * @type {string}
   */
  id: '',

  /**
   * @readOnly
   */
  name: '',

  /**
   * @readOnly
   * @type {string}
   */
  mainType: '',

  /**
   * @readOnly
   * @type {string}
   */
  subType: '',

  /**
   * @readOnly
   * @type {number}
   */
  componentIndex: 0,

  /**
   * @type {Object}
   * @protected
   */
  defaultOption: null,

  /**
   * @type {module:echarts/model/Global}
   * @readOnly
   */
  ecModel: null,

  /**
   * key: componentType
   * value:  Component model list, can not be null.
   * @type {Object.<string, Array.<module:echarts/model/Model>>}
   * @readOnly
   */
  dependentModels: [],

  /**
   * @type {string}
   * @readOnly
   */
  uid: null,

  /**
   * Support merge layout params.
   * Only support 'box' now (left/right/top/bottom/width/height).
   * @type {string|Object} Object can be {ignoreSize: true}
   * @readOnly
   */
  layoutMode: null,
  $constructor: function (option, parentModel, ecModel, extraOpt) {
    Model.call(this, option, parentModel, ecModel, extraOpt);
    this.uid = componentUtil.getUID('componentModel');
  },
  init: function (option, parentModel, ecModel, extraOpt) {
    this.mergeDefaultAndTheme(option, ecModel);
  },
  mergeDefaultAndTheme: function (option, ecModel) {
    var layoutMode = this.layoutMode;
    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
    var themeModel = ecModel.getTheme();
    zrUtil.merge(option, themeModel.get(this.mainType));
    zrUtil.merge(option, this.getDefaultOption());

    if (layoutMode) {
      layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  },
  mergeOption: function (option, extraOpt) {
    zrUtil.merge(this.option, option, true);
    var layoutMode = this.layoutMode;

    if (layoutMode) {
      layout.mergeLayoutParam(this.option, option, layoutMode);
    }
  },
  // Hooker after init or mergeOption
  optionUpdated: function (newCptOption, isInit) {},
  getDefaultOption: function () {
    if (!clazzUtil.hasOwn(this, '__defaultOption')) {
      var optList = [];
      var Class = this.constructor;

      while (Class) {
        var opt = Class.prototype.defaultOption;
        opt && optList.push(opt);
        Class = Class.superClass;
      }

      var defaultOption = {};

      for (var i = optList.length - 1; i >= 0; i--) {
        defaultOption = zrUtil.merge(defaultOption, optList[i], true);
      }

      clazzUtil.set(this, '__defaultOption', defaultOption);
    }

    return clazzUtil.get(this, '__defaultOption');
  },
  getReferringComponents: function (mainType) {
    return this.ecModel.queryComponents({
      mainType: mainType,
      index: this.get(mainType + 'Index', true),
      id: this.get(mainType + 'Id', true)
    });
  }
}); // Reset ComponentModel.extend, add preConstruct.
// clazzUtil.enableClassExtend(
//     ComponentModel,
//     function (option, parentModel, ecModel, extraOpt) {
//         // Set dependentModels, componentIndex, name, id, mainType, subType.
//         zrUtil.extend(this, extraOpt);
//         this.uid = componentUtil.getUID('componentModel');
//         // this.setReadOnly([
//         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',
//         //     'dependentModels', 'componentIndex'
//         // ]);
//     }
// );
// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

clazzUtil.enableClassManagement(ComponentModel, {
  registerWhenExtend: true
});
componentUtil.enableSubTypeDefaulter(ComponentModel); // Add capability of ComponentModel.topologicalTravel.

componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);

function getDependencies(componentType) {
  var deps = [];
  zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {
    arrayPush.apply(deps, Clazz.prototype.dependencies || []);
  }); // Ensure main type

  return zrUtil.map(deps, function (type) {
    return clazzUtil.parseClassType(type).main;
  });
}

zrUtil.mixin(ComponentModel, boxLayoutMixin);
var _default = ComponentModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/Global.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var globalDefault = __webpack_require__("./node_modules/echarts/lib/model/globalDefault.js");

var colorPaletteMinin = __webpack_require__("./node_modules/echarts/lib/model/mixin/colorPalette.js");

/**
 * ECharts global model
 *
 * @module {echarts/model/Global}
 */

/**
 * Caution: If the mechanism should be changed some day, these cases
 * should be considered:
 *
 * (1) In `merge option` mode, if using the same option to call `setOption`
 * many times, the result should be the same (try our best to ensure that).
 * (2) In `merge option` mode, if a component has no id/name specified, it
 * will be merged by index, and the result sequence of the components is
 * consistent to the original sequence.
 * (3) `reset` feature (in toolbox). Find detailed info in comments about
 * `mergeOption` in module:echarts/model/OptionManager.
 */
var each = zrUtil.each;
var filter = zrUtil.filter;
var map = zrUtil.map;
var isArray = zrUtil.isArray;
var indexOf = zrUtil.indexOf;
var isObject = zrUtil.isObject;
var OPTION_INNER_KEY = '\0_ec_inner';
/**
 * @alias module:echarts/model/Global
 *
 * @param {Object} option
 * @param {module:echarts/model/Model} parentModel
 * @param {Object} theme
 */

var GlobalModel = Model.extend({
  constructor: GlobalModel,
  init: function (option, parentModel, theme, optionManager) {
    theme = theme || {};
    this.option = null; // Mark as not initialized.

    /**
     * @type {module:echarts/model/Model}
     * @private
     */

    this._theme = new Model(theme);
    /**
     * @type {module:echarts/model/OptionManager}
     */

    this._optionManager = optionManager;
  },
  setOption: function (option, optionPreprocessorFuncs) {
    zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');

    this._optionManager.setOption(option, optionPreprocessorFuncs);

    this.resetOption(null);
  },

  /**
   * @param {string} type null/undefined: reset all.
   *                      'recreate': force recreate all.
   *                      'timeline': only reset timeline option
   *                      'media': only reset media query option
   * @return {boolean} Whether option changed.
   */
  resetOption: function (type) {
    var optionChanged = false;
    var optionManager = this._optionManager;

    if (!type || type === 'recreate') {
      var baseOption = optionManager.mountOption(type === 'recreate');

      if (!this.option || type === 'recreate') {
        initBase.call(this, baseOption);
      } else {
        this.restoreData();
        this.mergeOption(baseOption);
      }

      optionChanged = true;
    }

    if (type === 'timeline' || type === 'media') {
      this.restoreData();
    }

    if (!type || type === 'recreate' || type === 'timeline') {
      var timelineOption = optionManager.getTimelineOption(this);
      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
    }

    if (!type || type === 'recreate' || type === 'media') {
      var mediaOptions = optionManager.getMediaOption(this, this._api);

      if (mediaOptions.length) {
        each(mediaOptions, function (mediaOption) {
          this.mergeOption(mediaOption, optionChanged = true);
        }, this);
      }
    }

    return optionChanged;
  },

  /**
   * @protected
   */
  mergeOption: function (newOption) {
    var option = this.option;
    var componentsMap = this._componentsMap;
    var newCptTypes = []; // 如果不存在对应的 component model 则直接 merge

    each(newOption, function (componentOption, mainType) {
      if (componentOption == null) {
        return;
      }

      if (!ComponentModel.hasClass(mainType)) {
        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);
      } else {
        newCptTypes.push(mainType);
      }
    }); // FIXME OPTION 同步是否要改回原来的

    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);
    this._seriesIndices = this._seriesIndices || [];

    function visitComponent(mainType, dependencies) {
      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);
      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);
      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.

      each(mapResult, function (item, index) {
        var opt = item.option;

        if (isObject(opt)) {
          item.keyInfo.mainType = mainType;
          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);
        }
      });
      var dependentModels = getComponentsByTypes(componentsMap, dependencies);
      option[mainType] = [];
      componentsMap.set(mainType, []);
      each(mapResult, function (resultItem, index) {
        var componentModel = resultItem.exist;
        var newCptOption = resultItem.option;
        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},
        // see removeEdgeAndAdd in topologicalTravel and
        // ComponentModel.getAllClassMainTypes.

        if (!newCptOption) {
          componentModel.mergeOption({}, this);
          componentModel.optionUpdated({}, false);
        } else {
          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);

          if (componentModel && componentModel instanceof ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name;
            componentModel.mergeOption(newCptOption, this);
            componentModel.optionUpdated(newCptOption, false);
          } else {
            // PENDING Global as parent ?
            var extraOpt = zrUtil.extend({
              dependentModels: dependentModels,
              componentIndex: index
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);
            zrUtil.extend(componentModel, extraOpt);
            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.
            // newCptOption has been used as componentModel.option
            // and may be merged with theme and default, so pass null
            // to avoid confusion.

            componentModel.optionUpdated(null, true);
          }
        }

        componentsMap.get(mainType)[index] = componentModel;
        option[mainType][index] = componentModel.option;
      }, this); // Backup series for filtering.

      if (mainType === 'series') {
        this._seriesIndices = createSeriesIndices(componentsMap.get('series'));
      }
    }
  },

  /**
   * Get option for output (cloned option and inner info removed)
   * @public
   * @return {Object}
   */
  getOption: function () {
    var option = zrUtil.clone(this.option);
    each(option, function (opts, mainType) {
      if (ComponentModel.hasClass(mainType)) {
        var opts = modelUtil.normalizeToArray(opts);

        for (var i = opts.length - 1; i >= 0; i--) {
          // Remove options with inner id.
          if (modelUtil.isIdInner(opts[i])) {
            opts.splice(i, 1);
          }
        }

        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  },

  /**
   * @return {module:echarts/model/Model}
   */
  getTheme: function () {
    return this._theme;
  },

  /**
   * @param {string} mainType
   * @param {number} [idx=0]
   * @return {module:echarts/model/Component}
   */
  getComponent: function (mainType, idx) {
    var list = this._componentsMap.get(mainType);

    if (list) {
      return list[idx || 0];
    }
  },

  /**
   * If none of index and id and name used, return all components with mainType.
   * @param {Object} condition
   * @param {string} condition.mainType
   * @param {string} [condition.subType] If ignore, only query by mainType
   * @param {number|Array.<number>} [condition.index] Either input index or id or name.
   * @param {string|Array.<string>} [condition.id] Either input index or id or name.
   * @param {string|Array.<string>} [condition.name] Either input index or id or name.
   * @return {Array.<module:echarts/model/Component>}
   */
  queryComponents: function (condition) {
    var mainType = condition.mainType;

    if (!mainType) {
      return [];
    }

    var index = condition.index;
    var id = condition.id;
    var name = condition.name;

    var cpts = this._componentsMap.get(mainType);

    if (!cpts || !cpts.length) {
      return [];
    }

    var result;

    if (index != null) {
      if (!isArray(index)) {
        index = [index];
      }

      result = filter(map(index, function (idx) {
        return cpts[idx];
      }), function (val) {
        return !!val;
      });
    } else if (id != null) {
      var isIdArray = isArray(id);
      result = filter(cpts, function (cpt) {
        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
      });
    } else if (name != null) {
      var isNameArray = isArray(name);
      result = filter(cpts, function (cpt) {
        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;
      });
    } else {
      // Return all components with mainType
      result = cpts.slice();
    }

    return filterBySubType(result, condition);
  },

  /**
   * The interface is different from queryComponents,
   * which is convenient for inner usage.
   *
   * @usage
   * var result = findComponents(
   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
   * );
   * var result = findComponents(
   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
   * );
   * var result = findComponents(
   *     {mainType: 'series'},
   *     function (model, index) {...}
   * );
   * // result like [component0, componnet1, ...]
   *
   * @param {Object} condition
   * @param {string} condition.mainType Mandatory.
   * @param {string} [condition.subType] Optional.
   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
   *        where xxx is mainType.
   *        If query attribute is null/undefined or has no index/id/name,
   *        do not filtering by query conditions, which is convenient for
   *        no-payload situations or when target of action is global.
   * @param {Function} [condition.filter] parameter: component, return boolean.
   * @return {Array.<module:echarts/model/Component>}
   */
  findComponents: function (condition) {
    var query = condition.query;
    var mainType = condition.mainType;
    var queryCond = getQueryCond(query);
    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);
    return doFilter(filterBySubType(result, condition));

    function getQueryCond(q) {
      var indexAttr = mainType + 'Index';
      var idAttr = mainType + 'Id';
      var nameAttr = mainType + 'Name';
      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
        mainType: mainType,
        // subType will be filtered finally.
        index: q[indexAttr],
        id: q[idAttr],
        name: q[nameAttr]
      } : null;
    }

    function doFilter(res) {
      return condition.filter ? filter(res, condition.filter) : res;
    }
  },

  /**
   * @usage
   * eachComponent('legend', function (legendModel, index) {
   *     ...
   * });
   * eachComponent(function (componentType, model, index) {
   *     // componentType does not include subType
   *     // (componentType is 'xxx' but not 'xxx.aa')
   * });
   * eachComponent(
   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
   *     function (model, index) {...}
   * );
   * eachComponent(
   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
   *     function (model, index) {...}
   * );
   *
   * @param {string|Object=} mainType When mainType is object, the definition
   *                                  is the same as the method 'findComponents'.
   * @param {Function} cb
   * @param {*} context
   */
  eachComponent: function (mainType, cb, context) {
    var componentsMap = this._componentsMap;

    if (typeof mainType === 'function') {
      context = cb;
      cb = mainType;
      componentsMap.each(function (components, componentType) {
        each(components, function (component, index) {
          cb.call(context, componentType, component, index);
        });
      });
    } else if (zrUtil.isString(mainType)) {
      each(componentsMap.get(mainType), cb, context);
    } else if (isObject(mainType)) {
      var queryResult = this.findComponents(mainType);
      each(queryResult, cb, context);
    }
  },

  /**
   * @param {string} name
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeriesByName: function (name) {
    var series = this._componentsMap.get('series');

    return filter(series, function (oneSeries) {
      return oneSeries.name === name;
    });
  },

  /**
   * @param {number} seriesIndex
   * @return {module:echarts/model/Series}
   */
  getSeriesByIndex: function (seriesIndex) {
    return this._componentsMap.get('series')[seriesIndex];
  },

  /**
   * @param {string} subType
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeriesByType: function (subType) {
    var series = this._componentsMap.get('series');

    return filter(series, function (oneSeries) {
      return oneSeries.subType === subType;
    });
  },

  /**
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeries: function () {
    return this._componentsMap.get('series').slice();
  },

  /**
   * After filtering, series may be different
   * frome raw series.
   *
   * @param {Function} cb
   * @param {*} context
   */
  eachSeries: function (cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function (rawSeriesIndex) {
      var series = this._componentsMap.get('series')[rawSeriesIndex];

      cb.call(context, series, rawSeriesIndex);
    }, this);
  },

  /**
   * Iterate raw series before filtered.
   *
   * @param {Function} cb
   * @param {*} context
   */
  eachRawSeries: function (cb, context) {
    each(this._componentsMap.get('series'), cb, context);
  },

  /**
   * After filtering, series may be different.
   * frome raw series.
   *
   * @parma {string} subType
   * @param {Function} cb
   * @param {*} context
   */
  eachSeriesByType: function (subType, cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function (rawSeriesIndex) {
      var series = this._componentsMap.get('series')[rawSeriesIndex];

      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  },

  /**
   * Iterate raw series before filtered of given type.
   *
   * @parma {string} subType
   * @param {Function} cb
   * @param {*} context
   */
  eachRawSeriesByType: function (subType, cb, context) {
    return each(this.getSeriesByType(subType), cb, context);
  },

  /**
   * @param {module:echarts/model/Series} seriesModel
   */
  isSeriesFiltered: function (seriesModel) {
    assertSeriesInitialized(this);
    return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;
  },

  /**
   * @return {Array.<number>}
   */
  getCurrentSeriesIndices: function () {
    return (this._seriesIndices || []).slice();
  },

  /**
   * @param {Function} cb
   * @param {*} context
   */
  filterSeries: function (cb, context) {
    assertSeriesInitialized(this);
    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);
    this._seriesIndices = createSeriesIndices(filteredSeries);
  },
  restoreData: function () {
    var componentsMap = this._componentsMap;
    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));
    var componentTypes = [];
    componentsMap.each(function (components, componentType) {
      componentTypes.push(componentType);
    });
    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {
      each(componentsMap.get(componentType), function (component) {
        component.restoreData();
      });
    });
  }
});
/**
 * @inner
 */

function mergeTheme(option, theme) {
  zrUtil.each(theme, function (themeItem, name) {
    // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理
    if (!ComponentModel.hasClass(name)) {
      if (typeof themeItem === 'object') {
        option[name] = !option[name] ? zrUtil.clone(themeItem) : zrUtil.merge(option[name], themeItem, false);
      } else {
        if (option[name] == null) {
          option[name] = themeItem;
        }
      }
    }
  });
}

function initBase(baseOption) {
  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,
  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.

  this.option = {};
  this.option[OPTION_INNER_KEY] = 1;
  /**
   * Init with series: [], in case of calling findSeries method
   * before series initialized.
   * @type {Object.<string, Array.<module:echarts/model/Model>>}
   * @private
   */

  this._componentsMap = zrUtil.createHashMap({
    series: []
  });
  /**
   * Mapping between filtered series list and raw series list.
   * key: filtered series indices, value: raw series indices.
   * @type {Array.<nubmer>}
   * @private
   */

  this._seriesIndices = null;
  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property

  zrUtil.merge(baseOption, globalDefault, false);
  this.mergeOption(baseOption);
}
/**
 * @inner
 * @param {Array.<string>|string} types model types
 * @return {Object} key: {string} type, value: {Array.<Object>} models
 */


function getComponentsByTypes(componentsMap, types) {
  if (!zrUtil.isArray(types)) {
    types = types ? [types] : [];
  }

  var ret = {};
  each(types, function (type) {
    ret[type] = (componentsMap.get(type) || []).slice();
  });
  return ret;
}
/**
 * @inner
 */


function determineSubType(mainType, newCptOption, existComponent) {
  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.
  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType

  return subType;
}
/**
 * @inner
 */


function createSeriesIndices(seriesModels) {
  return map(seriesModels, function (series) {
    return series.componentIndex;
  }) || [];
}
/**
 * @inner
 */


function filterBySubType(components, condition) {
  // Using hasOwnProperty for restrict. Consider
  // subType is undefined in user payload.
  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {
    return cpt.subType === condition.subType;
  }) : components;
}
/**
 * @inner
 */


function assertSeriesInitialized(ecModel) {}

zrUtil.mixin(GlobalModel, colorPaletteMinin);
var _default = GlobalModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/Model.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var clazzUtil = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var lineStyleMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/lineStyle.js");

var areaStyleMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/areaStyle.js");

var textStyleMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/textStyle.js");

var itemStyleMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/itemStyle.js");

/**
 * @module echarts/model/Model
 */
var mixin = zrUtil.mixin;
/**
 * @alias module:echarts/model/Model
 * @constructor
 * @param {Object} option
 * @param {module:echarts/model/Model} [parentModel]
 * @param {module:echarts/model/Global} [ecModel]
 */

function Model(option, parentModel, ecModel) {
  /**
   * @type {module:echarts/model/Model}
   * @readOnly
   */
  this.parentModel = parentModel;
  /**
   * @type {module:echarts/model/Global}
   * @readOnly
   */

  this.ecModel = ecModel;
  /**
   * @type {Object}
   * @protected
   */

  this.option = option; // Simple optimization
  // if (this.init) {
  //     if (arguments.length <= 4) {
  //         this.init(option, parentModel, ecModel, extraOpt);
  //     }
  //     else {
  //         this.init.apply(this, arguments);
  //     }
  // }
}

Model.prototype = {
  constructor: Model,

  /**
   * Model 的初始化函数
   * @param {Object} option
   */
  init: null,

  /**
   * 从新的 Option merge
   */
  mergeOption: function (option) {
    zrUtil.merge(this.option, option, true);
  },

  /**
   * @param {string|Array.<string>} path
   * @param {boolean} [ignoreParent=false]
   * @return {*}
   */
  get: function (path, ignoreParent) {
    if (path == null) {
      return this.option;
    }

    return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));
  },

  /**
   * @param {string} key
   * @param {boolean} [ignoreParent=false]
   * @return {*}
   */
  getShallow: function (key, ignoreParent) {
    var option = this.option;
    var val = option == null ? option : option[key];
    var parentModel = !ignoreParent && getParent(this, key);

    if (val == null && parentModel) {
      val = parentModel.getShallow(key);
    }

    return val;
  },

  /**
   * @param {string|Array.<string>} [path]
   * @param {module:echarts/model/Model} [parentModel]
   * @return {module:echarts/model/Model}
   */
  getModel: function (path, parentModel) {
    var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));
    var thisParentModel;
    parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);
    return new Model(obj, parentModel, this.ecModel);
  },

  /**
   * If model has option
   */
  isEmpty: function () {
    return this.option == null;
  },
  restoreData: function () {},
  // Pending
  clone: function () {
    var Ctor = this.constructor;
    return new Ctor(zrUtil.clone(this.option));
  },
  setReadOnly: function (properties) {
    clazzUtil.setReadOnly(this, properties);
  },
  // If path is null/undefined, return null/undefined.
  parsePath: function (path) {
    if (typeof path === 'string') {
      path = path.split('.');
    }

    return path;
  },

  /**
   * @param {Function} getParentMethod
   *        param {Array.<string>|string} path
   *        return {module:echarts/model/Model}
   */
  customizeGetParent: function (getParentMethod) {
    clazzUtil.set(this, 'getParent', getParentMethod);
  },
  isAnimationEnabled: function () {
    if (!env.node) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  }
};

function doGet(obj, pathArr, parentModel) {
  for (var i = 0; i < pathArr.length; i++) {
    // Ignore empty
    if (!pathArr[i]) {
      continue;
    } // obj could be number/string/... (like 0)


    obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;

    if (obj == null) {
      break;
    }
  }

  if (obj == null && parentModel) {
    obj = parentModel.get(pathArr);
  }

  return obj;
} // `path` can be null/undefined


function getParent(model, path) {
  var getParentMethod = clazzUtil.get(model, 'getParent');
  return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;
} // Enable Model.extend.


clazzUtil.enableClassExtend(Model);
mixin(Model, lineStyleMixin);
mixin(Model, areaStyleMixin);
mixin(Model, textStyleMixin);
mixin(Model, itemStyleMixin);
var _default = Model;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/OptionManager.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

/**
 * ECharts option manager
 *
 * @module {echarts/model/OptionManager}
 */
var each = zrUtil.each;
var clone = zrUtil.clone;
var map = zrUtil.map;
var merge = zrUtil.merge;
var QUERY_REG = /^(min|max)?(.+)$/;
/**
 * TERM EXPLANATIONS:
 *
 * [option]:
 *
 *     An object that contains definitions of components. For example:
 *     var option = {
 *         title: {...},
 *         legend: {...},
 *         visualMap: {...},
 *         series: [
 *             {data: [...]},
 *             {data: [...]},
 *             ...
 *         ]
 *     };
 *
 * [rawOption]:
 *
 *     An object input to echarts.setOption. 'rawOption' may be an
 *     'option', or may be an object contains multi-options. For example:
 *     var option = {
 *         baseOption: {
 *             title: {...},
 *             legend: {...},
 *             series: [
 *                 {data: [...]},
 *                 {data: [...]},
 *                 ...
 *             ]
 *         },
 *         timeline: {...},
 *         options: [
 *             {title: {...}, series: {data: [...]}},
 *             {title: {...}, series: {data: [...]}},
 *             ...
 *         ],
 *         media: [
 *             {
 *                 query: {maxWidth: 320},
 *                 option: {series: {x: 20}, visualMap: {show: false}}
 *             },
 *             {
 *                 query: {minWidth: 320, maxWidth: 720},
 *                 option: {series: {x: 500}, visualMap: {show: true}}
 *             },
 *             {
 *                 option: {series: {x: 1200}, visualMap: {show: true}}
 *             }
 *         ]
 *     };
 *
 * @alias module:echarts/model/OptionManager
 * @param {module:echarts/ExtensionAPI} api
 */

function OptionManager(api) {
  /**
   * @private
   * @type {module:echarts/ExtensionAPI}
   */
  this._api = api;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._timelineOptions = [];
  /**
   * @private
   * @type {Array.<Object>}
   */

  this._mediaList = [];
  /**
   * @private
   * @type {Object}
   */

  this._mediaDefault;
  /**
   * -1, means default.
   * empty means no media.
   * @private
   * @type {Array.<number>}
   */

  this._currentMediaIndices = [];
  /**
   * @private
   * @type {Object}
   */

  this._optionBackup;
  /**
   * @private
   * @type {Object}
   */

  this._newBaseOption;
} // timeline.notMerge is not supported in ec3. Firstly there is rearly
// case that notMerge is needed. Secondly supporting 'notMerge' requires
// rawOption cloned and backuped when timeline changed, which does no
// good to performance. What's more, that both timeline and setOption
// method supply 'notMerge' brings complex and some problems.
// Consider this case:
// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);


OptionManager.prototype = {
  constructor: OptionManager,

  /**
   * @public
   * @param {Object} rawOption Raw option.
   * @param {module:echarts/model/Global} ecModel
   * @param {Array.<Function>} optionPreprocessorFuncs
   * @return {Object} Init option
   */
  setOption: function (rawOption, optionPreprocessorFuncs) {
    rawOption = clone(rawOption, true); // FIXME
    // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。

    var oldOptionBackup = this._optionBackup;
    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);

    if (oldOptionBackup) {
      // Only baseOption can be merged.
      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,
      // that is, if you `setOption` twice and both has timeline options, the latter
      // timeline opitons will not be merged to the formers, but just substitude them.

      if (newParsedOption.timelineOptions.length) {
        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
      }

      if (newParsedOption.mediaList.length) {
        oldOptionBackup.mediaList = newParsedOption.mediaList;
      }

      if (newParsedOption.mediaDefault) {
        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  },

  /**
   * @param {boolean} isRecreate
   * @return {Object}
   */
  mountOption: function (isRecreate) {
    var optionBackup = this._optionBackup; // TODO
    // 如果没有reset功能则不clone。

    this._timelineOptions = map(optionBackup.timelineOptions, clone);
    this._mediaList = map(optionBackup.mediaList, clone);
    this._mediaDefault = clone(optionBackup.mediaDefault);
    this._currentMediaIndices = [];
    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`
    // called, and is merged into every new option by inner method `mergeOption`
    // each time `setOption` called, can be only used in `isRecreate`, because
    // its reliability is under suspicion. In other cases option merge is
    // performed by `model.mergeOption`.
    ? optionBackup.baseOption : this._newBaseOption);
  },

  /**
   * @param {module:echarts/model/Global} ecModel
   * @return {Object}
   */
  getTimelineOption: function (ecModel) {
    var option;
    var timelineOptions = this._timelineOptions;

    if (timelineOptions.length) {
      // getTimelineOption can only be called after ecModel inited,
      // so we can get currentIndex from timelineModel.
      var timelineModel = ecModel.getComponent('timeline');

      if (timelineModel) {
        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);
      }
    }

    return option;
  },

  /**
   * @param {module:echarts/model/Global} ecModel
   * @return {Array.<Object>}
   */
  getMediaOption: function (ecModel) {
    var ecWidth = this._api.getWidth();

    var ecHeight = this._api.getHeight();

    var mediaList = this._mediaList;
    var mediaDefault = this._mediaDefault;
    var indices = [];
    var result = []; // No media defined.

    if (!mediaList.length && !mediaDefault) {
      return result;
    } // Multi media may be applied, the latter defined media has higher priority.


    for (var i = 0, len = mediaList.length; i < len; i++) {
      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
        indices.push(i);
      }
    } // FIXME
    // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。


    if (!indices.length && mediaDefault) {
      indices = [-1];
    }

    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map(indices, function (index) {
        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
      });
    } // Otherwise return nothing.


    this._currentMediaIndices = indices;
    return result;
  }
};

function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
  var timelineOptions = [];
  var mediaList = [];
  var mediaDefault;
  var baseOption; // Compatible with ec2.

  var timelineOpt = rawOption.timeline;

  if (rawOption.baseOption) {
    baseOption = rawOption.baseOption;
  } // For timeline


  if (timelineOpt || rawOption.options) {
    baseOption = baseOption || {};
    timelineOptions = (rawOption.options || []).slice();
  } // For media query


  if (rawOption.media) {
    baseOption = baseOption || {};
    var media = rawOption.media;
    each(media, function (singleMedia) {
      if (singleMedia && singleMedia.option) {
        if (singleMedia.query) {
          mediaList.push(singleMedia);
        } else if (!mediaDefault) {
          // Use the first media default.
          mediaDefault = singleMedia;
        }
      }
    });
  } // For normal option


  if (!baseOption) {
    baseOption = rawOption;
  } // Set timelineOpt to baseOption in ec3,
  // which is convenient for merge option.


  if (!baseOption.timeline) {
    baseOption.timeline = timelineOpt;
  } // Preprocess.


  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {
    return media.option;
  })), function (option) {
    each(optionPreprocessorFuncs, function (preProcess) {
      preProcess(option, isNew);
    });
  });
  return {
    baseOption: baseOption,
    timelineOptions: timelineOptions,
    mediaDefault: mediaDefault,
    mediaList: mediaList
  };
}
/**
 * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
 * Support: width, height, aspectRatio
 * Can use max or min as prefix.
 */


function applyMediaQuery(query, ecWidth, ecHeight) {
  var realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight // lowser case for convenientce.

  };
  var applicatable = true;
  zrUtil.each(query, function (value, attr) {
    var matched = attr.match(QUERY_REG);

    if (!matched || !matched[1] || !matched[2]) {
      return;
    }

    var operator = matched[1];
    var realAttr = matched[2].toLowerCase();

    if (!compare(realMap[realAttr], value, operator)) {
      applicatable = false;
    }
  });
  return applicatable;
}

function compare(real, expect, operator) {
  if (operator === 'min') {
    return real >= expect;
  } else if (operator === 'max') {
    return real <= expect;
  } else {
    // Equals
    return real === expect;
  }
}

function indicesEquals(indices1, indices2) {
  // indices is always order by asc and has only finite number.
  return indices1.join(',') === indices2.join(',');
}
/**
 * Consider case:
 * `chart.setOption(opt1);`
 * Then user do some interaction like dataZoom, dataView changing.
 * `chart.setOption(opt2);`
 * Then user press 'reset button' in toolbox.
 *
 * After doing that all of the interaction effects should be reset, the
 * chart should be the same as the result of invoke
 * `chart.setOption(opt1); chart.setOption(opt2);`.
 *
 * Although it is not able ensure that
 * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
 * `chart.setOption(merge(opt1, opt2));` exactly,
 * this might be the only simple way to implement that feature.
 *
 * MEMO: We've considered some other approaches:
 * 1. Each model handle its self restoration but not uniform treatment.
 *     (Too complex in logic and error-prone)
 * 2. Use a shadow ecModel. (Performace expensive)
 */


function mergeOption(oldOption, newOption) {
  newOption = newOption || {};
  each(newOption, function (newCptOpt, mainType) {
    if (newCptOpt == null) {
      return;
    }

    var oldCptOpt = oldOption[mainType];

    if (!ComponentModel.hasClass(mainType)) {
      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);
    } else {
      newCptOpt = modelUtil.normalizeToArray(newCptOpt);
      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);
      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);
      oldOption[mainType] = map(mapResult, function (item) {
        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;
      });
    }
  });
}

var _default = OptionManager;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/Series.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var _format = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var formatTime = _format.formatTime;
var encodeHTML = _format.encodeHTML;
var addCommas = _format.addCommas;
var getTooltipMarker = _format.getTooltipMarker;

var _clazz = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var set = _clazz.set;
var get = _clazz.get;

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var colorPaletteMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/colorPalette.js");

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutParams = _layout.getLayoutParams;
var mergeLayoutParam = _layout.mergeLayoutParam;
var SeriesModel = ComponentModel.extend({
  type: 'series.__base__',

  /**
   * @readOnly
   */
  seriesIndex: 0,
  // coodinateSystem will be injected in the echarts/CoordinateSystem
  coordinateSystem: null,

  /**
   * @type {Object}
   * @protected
   */
  defaultOption: null,

  /**
   * Data provided for legend
   * @type {Function}
   */
  // PENDING
  legendDataProvider: null,

  /**
   * Access path of color for visual
   */
  visualColorAccessPath: 'itemStyle.normal.color',

  /**
   * Support merge layout params.
   * Only support 'box' now (left/right/top/bottom/width/height).
   * @type {string|Object} Object can be {ignoreSize: true}
   * @readOnly
   */
  layoutMode: null,
  init: function (option, parentModel, ecModel, extraOpt) {
    /**
     * @type {number}
     * @readOnly
     */
    this.seriesIndex = this.componentIndex;
    this.mergeDefaultAndTheme(option, ecModel);
    var data = this.getInitialData(option, ecModel);

    /**
     * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}
     * @private
     */
    set(this, 'dataBeforeProcessed', data); // If we reverse the order (make data firstly, and then make
    // dataBeforeProcessed by cloneShallow), cloneShallow will
    // cause data.graph.data !== data when using
    // module:echarts/data/Graph or module:echarts/data/Tree.
    // See module:echarts/data/helper/linkList

    this.restoreData();
  },

  /**
   * Util for merge default and theme to option
   * @param  {Object} option
   * @param  {module:echarts/model/Global} ecModel
   */
  mergeDefaultAndTheme: function (option, ecModel) {
    var layoutMode = this.layoutMode;
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {}; // Backward compat: using subType on theme.
    // But if name duplicate between series subType
    // (for example: parallel) add component mainType,
    // add suffix 'Series'.

    var themeSubType = this.subType;

    if (ComponentModel.hasClass(themeSubType)) {
      themeSubType += 'Series';
    }

    zrUtil.merge(option, ecModel.getTheme().get(this.subType));
    zrUtil.merge(option, this.getDefaultOption()); // Default label emphasis `show`

    modelUtil.defaultEmphasis(option.label, ['show']);
    this.fillDataTextStyle(option.data);

    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  },
  mergeOption: function (newSeriesOption, ecModel) {
    newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    var layoutMode = this.layoutMode;

    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }

    var data = this.getInitialData(newSeriesOption, ecModel); // TODO Merge data?

    if (data) {
      set(this, 'data', data);
      set(this, 'dataBeforeProcessed', data.cloneShallow());
    }
  },
  fillDataTextStyle: function (data) {
    // Default data label emphasis `show`
    // FIXME Tree structure data ?
    // FIXME Performance ?
    if (data) {
      var props = ['show'];

      for (var i = 0; i < data.length; i++) {
        if (data[i] && data[i].label) {
          modelUtil.defaultEmphasis(data[i].label, props);
        }
      }
    }
  },

  /**
   * Init a data structure from data related option in series
   * Must be overwritten
   */
  getInitialData: function () {},

  /**
   * @param {string} [dataType]
   * @return {module:echarts/data/List}
   */
  getData: function (dataType) {
    var data = get(this, 'data');
    return dataType == null ? data : data.getLinkedData(dataType);
  },

  /**
   * @param {module:echarts/data/List} data
   */
  setData: function (data) {
    set(this, 'data', data);
  },

  /**
   * Get data before processed
   * @return {module:echarts/data/List}
   */
  getRawData: function () {
    return get(this, 'dataBeforeProcessed');
  },

  /**
   * Coord dimension to data dimension.
   *
   * By default the result is the same as dimensions of series data.
   * But in some series data dimensions are different from coord dimensions (i.e.
   * candlestick and boxplot). Override this method to handle those cases.
   *
   * Coord dimension to data dimension can be one-to-many
   *
   * @param {string} coordDim
   * @return {Array.<string>} dimensions on the axis.
   */
  coordDimToDataDim: function (coordDim) {
    return modelUtil.coordDimToDataDim(this.getData(), coordDim);
  },

  /**
   * Convert data dimension to coord dimension.
   *
   * @param {string|number} dataDim
   * @return {string}
   */
  dataDimToCoordDim: function (dataDim) {
    return modelUtil.dataDimToCoordDim(this.getData(), dataDim);
  },

  /**
   * Get base axis if has coordinate system and has axis.
   * By default use coordSys.getBaseAxis();
   * Can be overrided for some chart.
   * @return {type} description
   */
  getBaseAxis: function () {
    var coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  },
  // FIXME

  /**
   * Default tooltip formatter
   *
   * @param {number} dataIndex
   * @param {boolean} [multipleSeries=false]
   * @param {number} [dataType]
   */
  formatTooltip: function (dataIndex, multipleSeries, dataType) {
    function formatArrayValue(value) {
      var vertially = zrUtil.reduce(value, function (vertially, val, idx) {
        var dimItem = data.getDimensionInfo(idx);
        return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;
      }, 0);
      var result = [];
      var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');
      tooltipDims.length ? zrUtil.each(tooltipDims, function (dimIdx) {
        setEachItem(data.get(dimIdx, dataIndex), dimIdx);
      }) // By default, all dims is used on tooltip.
      : zrUtil.each(value, setEachItem);

      function setEachItem(val, dimIdx) {
        var dimInfo = data.getDimensionInfo(dimIdx); // If `dimInfo.tooltip` is not set, show tooltip.

        if (!dimInfo || dimInfo.otherDims.tooltip === false) {
          return;
        }

        var dimType = dimInfo.type;
        var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '') + (dimType === 'ordinal' ? val + '' : dimType === 'time' ? multipleSeries ? '' : formatTime('yyyy/MM/dd hh:mm:ss', val) : addCommas(val));
        valStr && result.push(encodeHTML(valStr));
      }

      return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');
    }

    var data = get(this, 'data');
    var value = this.getRawValue(dataIndex);
    var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : encodeHTML(addCommas(value));
    var name = data.getName(dataIndex);
    var color = data.getItemVisual(dataIndex, 'color');

    if (zrUtil.isObject(color) && color.colorStops) {
      color = (color.colorStops[0] || {}).color;
    }

    color = color || 'transparent';
    var colorEl = getTooltipMarker(color);
    var seriesName = this.name; // FIXME

    if (seriesName === '\0-') {
      // Not show '-'
      seriesName = '';
    }

    seriesName = seriesName ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ') : '';
    return !multipleSeries ? seriesName + colorEl + (name ? encodeHTML(name) + ': ' + formattedValue : formattedValue) : colorEl + seriesName + formattedValue;
  },

  /**
   * @return {boolean}
   */
  isAnimationEnabled: function () {
    if (env.node) {
      return false;
    }

    var animationEnabled = this.getShallow('animation');

    if (animationEnabled) {
      if (this.getData().count() > this.getShallow('animationThreshold')) {
        animationEnabled = false;
      }
    }

    return animationEnabled;
  },
  restoreData: function () {
    set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());
  },
  getColorFromPalette: function (name, scope) {
    var ecModel = this.ecModel; // PENDING

    var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);

    if (!color) {
      color = ecModel.getColorFromPalette(name, scope);
    }

    return color;
  },

  /**
   * Get data indices for show tooltip content. See tooltip.
   * @abstract
   * @param {Array.<string>|string} dim
   * @param {Array.<number>} value
   * @param {module:echarts/coord/single/SingleAxis} baseAxis
   * @return {Object} {dataIndices, nestestValue}.
   */
  getAxisTooltipData: null,

  /**
   * See tooltip.
   * @abstract
   * @param {number} dataIndex
   * @return {Array.<number>} Point of tooltip. null/undefined can be returned.
   */
  getTooltipPosition: null
});
zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);
zrUtil.mixin(SeriesModel, colorPaletteMixin);
var _default = SeriesModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/globalDefault.js":
/***/ (function(module, exports) {

var platform = ''; // Navigator not exists in node

if (typeof navigator !== 'undefined') {
  platform = navigator.platform || '';
}

var _default = {
  // 全图默认背景
  // backgroundColor: 'rgba(0,0,0,0)',
  // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
  // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
  // 浅色
  // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
  // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
  // 深色
  color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'],
  // 默认需要 Grid 配置项
  // grid: {},
  // 主题，主题
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: 'normal',
    fontWeight: 'normal'
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  animation: 'auto',
  animationDuration: 1000,
  animationDurationUpdate: 300,
  animationEasing: 'exponentialOut',
  animationEasingUpdate: 'cubicOut',
  animationThreshold: 2000,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3000,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3000,
  // See: module:echarts/scale/Time
  useUTC: false
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/areaStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__("./node_modules/echarts/lib/model/mixin/makeStyleMapper.js");

var getAreaStyle = makeStyleMapper([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]);
var _default = {
  getAreaStyle: function (excludes, includes) {
    return getAreaStyle(this, excludes, includes);
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/boxLayout.js":
/***/ (function(module, exports) {

var _default = {
  getBoxLayoutParams: function () {
    return {
      left: this.get('left'),
      top: this.get('top'),
      right: this.get('right'),
      bottom: this.get('bottom'),
      width: this.get('width'),
      height: this.get('height')
    };
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/colorPalette.js":
/***/ (function(module, exports, __webpack_require__) {

var _clazz = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var set = _clazz.set;
var get = _clazz.get;
var _default = {
  clearColorPalette: function () {
    set(this, 'colorIdx', 0);
    set(this, 'colorNameMap', {});
  },
  getColorFromPalette: function (name, scope) {
    scope = scope || this;
    var colorIdx = get(scope, 'colorIdx') || 0;
    var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {}); // Use `hasOwnProperty` to avoid conflict with Object.prototype.

    if (colorNameMap.hasOwnProperty(name)) {
      return colorNameMap[name];
    }

    var colorPalette = this.get('color', true) || [];

    if (!colorPalette.length) {
      return;
    }

    var color = colorPalette[colorIdx];

    if (name) {
      colorNameMap[name] = color;
    }

    set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);
    return color;
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/itemStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__("./node_modules/echarts/lib/model/mixin/makeStyleMapper.js");

var getItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]);
var _default = {
  getItemStyle: function (excludes, includes) {
    var style = getItemStyle(this, excludes, includes);
    var lineDash = this.getBorderLineDash();
    lineDash && (style.lineDash = lineDash);
    return style;
  },
  getBorderLineDash: function () {
    var lineType = this.get('borderType');
    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [5, 5] : [1, 1];
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/lineStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__("./node_modules/echarts/lib/model/mixin/makeStyleMapper.js");

var getLineStyle = makeStyleMapper([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
var _default = {
  getLineStyle: function (excludes) {
    var style = getLineStyle(this, excludes);
    var lineDash = this.getLineDash(style.lineWidth);
    lineDash && (style.lineDash = lineDash);
    return style;
  },
  getLineDash: function (lineWidth) {
    if (lineWidth == null) {
      lineWidth = 1;
    }

    var lineType = this.get('type');
    var dotSize = Math.max(lineWidth, 2);
    var dashSize = lineWidth * 4;
    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize];
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/makeStyleMapper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

// TODO Parse shadow style
// TODO Only shallow path support
function _default(properties) {
  // Normalize
  for (var i = 0; i < properties.length; i++) {
    if (!properties[i][1]) {
      properties[i][1] = properties[i][0];
    }
  }

  return function (model, excludes, includes) {
    var style = {};

    for (var i = 0; i < properties.length; i++) {
      var propName = properties[i][1];

      if (excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0) {
        continue;
      }

      var val = model.getShallow(propName);

      if (val != null) {
        style[properties[i][0]] = val;
      }
    }

    return style;
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/textStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var graphicUtil = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var PATH_COLOR = ['textStyle', 'color'];
var _default = {
  /**
   * Get color property or get color from option.textStyle.color
   * @param {boolean} [isEmphasis]
   * @return {string}
   */
  getTextColor: function (isEmphasis) {
    var ecModel = this.ecModel;
    return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  },

  /**
   * Create font string from fontStyle, fontWeight, fontSize, fontFamily
   * @return {string}
   */
  getFont: function () {
    return graphicUtil.getFont({
      fontStyle: this.getShallow('fontStyle'),
      fontWeight: this.getShallow('fontWeight'),
      fontSize: this.getShallow('fontSize'),
      fontFamily: this.getShallow('fontFamily')
    }, this.ecModel);
  },
  getTextRect: function (text) {
    return textContain.getBoundingRect(text, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('rich'), this.getShallow('truncateText'));
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/preprocessor/backwardCompat.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var each = _util.each;
var isArray = _util.isArray;
var isObject = _util.isObject;

var compatStyle = __webpack_require__("./node_modules/echarts/lib/preprocessor/helper/compatStyle.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var normalizeToArray = _model.normalizeToArray;

// Compatitable with 2.0
function get(opt, path) {
  path = path.split(',');
  var obj = opt;

  for (var i = 0; i < path.length; i++) {
    obj = obj && obj[path[i]];

    if (obj == null) {
      break;
    }
  }

  return obj;
}

function set(opt, path, val, overwrite) {
  path = path.split(',');
  var obj = opt;
  var key;

  for (var i = 0; i < path.length - 1; i++) {
    key = path[i];

    if (obj[key] == null) {
      obj[key] = {};
    }

    obj = obj[key];
  }

  if (overwrite || obj[path[i]] == null) {
    obj[path[i]] = val;
  }
}

function compatLayoutProperties(option) {
  each(LAYOUT_PROPERTIES, function (prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}

var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];
var COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];
var COMPATITABLE_SERIES = ['bar', 'boxplot', 'candlestick', 'chord', 'effectScatter', 'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel', 'pie', 'radar', 'sankey', 'scatter', 'treemap'];

function _default(option, isTheme) {
  compatStyle(option, isTheme); // Make sure series array for model initialization.

  option.series = normalizeToArray(option.series);
  each(option.series, function (seriesOpt) {
    if (!isObject(seriesOpt)) {
      return;
    }

    var seriesType = seriesOpt.type;

    if (seriesType === 'pie' || seriesType === 'gauge') {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
      }
    }

    if (seriesType === 'gauge') {
      var pointerColor = get(seriesOpt, 'pointer.color');
      pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);
    }

    for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {
      if (COMPATITABLE_SERIES[i] === seriesOpt.type) {
        compatLayoutProperties(seriesOpt);
        break;
      }
    }
  }); // dataRange has changed to visualMap

  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }

  each(COMPATITABLE_COMPONENTS, function (componentName) {
    var options = option[componentName];

    if (options) {
      if (!isArray(options)) {
        options = [options];
      }

      each(options, function (option) {
        compatLayoutProperties(option);
      });
    }
  });
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/preprocessor/helper/compatStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var each = zrUtil.each;
var isObject = zrUtil.isObject;
var POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];

function compatItemStyle(opt) {
  var itemStyleOpt = opt && opt.itemStyle;

  if (!itemStyleOpt) {
    return;
  }

  for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
    var styleName = POSSIBLE_STYLES[i];
    var normalItemStyleOpt = itemStyleOpt.normal;
    var emphasisItemStyleOpt = itemStyleOpt.emphasis;

    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};

      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }

      normalItemStyleOpt[styleName] = null;
    }

    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};

      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }

      emphasisItemStyleOpt[styleName] = null;
    }
  }
}

function compatTextStyle(opt, propName) {
  var labelOptSingle = isObject(opt) && opt[propName];
  var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;

  if (textStyle) {
    for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {
      var propName = modelUtil.TEXT_STYLE_OPTIONS[i];

      if (textStyle.hasOwnProperty(propName)) {
        labelOptSingle[propName] = textStyle[propName];
      }
    }
  }
}

function compatLabelTextStyle(labelOpt) {
  if (isObject(labelOpt)) {
    compatTextStyle(labelOpt, 'normal');
    compatTextStyle(labelOpt, 'emphasis');
  }
}

function processSeries(seriesOpt) {
  if (!isObject(seriesOpt)) {
    return;
  }

  compatItemStyle(seriesOpt);
  compatLabelTextStyle(seriesOpt.label); // treemap

  compatLabelTextStyle(seriesOpt.upperLabel); // graph

  compatLabelTextStyle(seriesOpt.edgeLabel);
  var markPoint = seriesOpt.markPoint;
  compatItemStyle(markPoint);
  compatLabelTextStyle(markPoint && markPoint.label);
  var markLine = seriesOpt.markLine;
  compatItemStyle(seriesOpt.markLine);
  compatLabelTextStyle(markLine && markLine.label);
  var markArea = seriesOpt.markArea;
  compatLabelTextStyle(markArea && markArea.label); // For gauge

  compatTextStyle(seriesOpt, 'axisLabel');
  compatTextStyle(seriesOpt, 'title');
  compatTextStyle(seriesOpt, 'detail');
  var data = seriesOpt.data;

  if (data) {
    for (var i = 0; i < data.length; i++) {
      compatItemStyle(data[i]);
      compatLabelTextStyle(data[i] && data[i].label);
    }
  } // mark point data


  var markPoint = seriesOpt.markPoint;

  if (markPoint && markPoint.data) {
    var mpData = markPoint.data;

    for (var i = 0; i < mpData.length; i++) {
      compatItemStyle(mpData[i]);
      compatLabelTextStyle(mpData[i] && mpData[i].label);
    }
  } // mark line data


  var markLine = seriesOpt.markLine;

  if (markLine && markLine.data) {
    var mlData = markLine.data;

    for (var i = 0; i < mlData.length; i++) {
      if (zrUtil.isArray(mlData[i])) {
        compatItemStyle(mlData[i][0]);
        compatLabelTextStyle(mlData[i][0] && mlData[i][0].label);
        compatItemStyle(mlData[i][1]);
        compatLabelTextStyle(mlData[i][1] && mlData[i][1].label);
      } else {
        compatItemStyle(mlData[i]);
        compatLabelTextStyle(mlData[i] && mlData[i].label);
      }
    }
  }
}

function toArr(o) {
  return zrUtil.isArray(o) ? o : o ? [o] : [];
}

function toObj(o) {
  return (zrUtil.isArray(o) ? o[0] : o) || {};
}

function _default(option, isTheme) {
  each(toArr(option.series), function (seriesOpt) {
    isObject(seriesOpt) && processSeries(seriesOpt);
  });
  var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];
  isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');
  each(axes, function (axisName) {
    each(toArr(option[axisName]), function (axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, 'axisLabel');
        compatTextStyle(axisOpt.axisPointer, 'label');
      }
    });
  });
  each(toArr(option.parallel), function (parallelOpt) {
    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, 'axisLabel');
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');
  });
  each(toArr(option.calendar), function (calendarOpt) {
    compatTextStyle(calendarOpt, 'dayLabel');
    compatTextStyle(calendarOpt, 'monthLabel');
    compatTextStyle(calendarOpt, 'yearLabel');
  }); // radar.name.textStyle

  each(toArr(option.radar), function (radarOpt) {
    compatTextStyle(radarOpt, 'name');
  });
  each(toArr(option.geo), function (geoOpt) {
    if (isObject(geoOpt)) {
      compatLabelTextStyle(geoOpt.label);
      each(toArr(geoOpt.regions), function (regionObj) {
        compatLabelTextStyle(regionObj.label);
      });
    }
  });
  compatLabelTextStyle(toObj(option.timeline).label);
  compatTextStyle(toObj(option.axisPointer), 'label');
  compatTextStyle(toObj(option.tooltip).axisPointer, 'label');
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/processor/dataSample.js":
/***/ (function(module, exports) {

var samplers = {
  average: function (frame) {
    var sum = 0;
    var count = 0;

    for (var i = 0; i < frame.length; i++) {
      if (!isNaN(frame[i])) {
        sum += frame[i];
        count++;
      }
    } // Return NaN if count is 0


    return count === 0 ? NaN : sum / count;
  },
  sum: function (frame) {
    var sum = 0;

    for (var i = 0; i < frame.length; i++) {
      // Ignore NaN
      sum += frame[i] || 0;
    }

    return sum;
  },
  max: function (frame) {
    var max = -Infinity;

    for (var i = 0; i < frame.length; i++) {
      frame[i] > max && (max = frame[i]);
    }

    return max;
  },
  min: function (frame) {
    var min = Infinity;

    for (var i = 0; i < frame.length; i++) {
      frame[i] < min && (min = frame[i]);
    }

    return min;
  },
  // TODO
  // Median
  nearest: function (frame) {
    return frame[0];
  }
};

var indexSampler = function (frame, value) {
  return Math.round(frame.length / 2);
};

function _default(seriesType, ecModel, api) {
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    var data = seriesModel.getData();
    var sampling = seriesModel.get('sampling');
    var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling

    if (coordSys.type === 'cartesian2d' && sampling) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis = coordSys.getOtherAxis(baseAxis);
      var extent = baseAxis.getExtent(); // Coordinste system has been resized

      var size = extent[1] - extent[0];
      var rate = Math.round(data.count() / size);

      if (rate > 1) {
        var sampler;

        if (typeof sampling === 'string') {
          sampler = samplers[sampling];
        } else if (typeof sampling === 'function') {
          sampler = sampling;
        }

        if (sampler) {
          data = data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler);
          seriesModel.setData(data);
        }
      }
    }
  }, this);
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/Interval.js":
/***/ (function(module, exports, __webpack_require__) {

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var Scale = __webpack_require__("./node_modules/echarts/lib/scale/Scale.js");

var helper = __webpack_require__("./node_modules/echarts/lib/scale/helper.js");

/**
 * Interval scale
 * @module echarts/scale/Interval
 */
var roundNumber = numberUtil.round;
/**
 * @alias module:echarts/coord/scale/Interval
 * @constructor
 */

var IntervalScale = Scale.extend({
  type: 'interval',
  _interval: 0,
  _intervalPrecision: 2,
  setExtent: function (start, end) {
    var thisExtent = this._extent; //start,end may be a Number like '25',so...

    if (!isNaN(start)) {
      thisExtent[0] = parseFloat(start);
    }

    if (!isNaN(end)) {
      thisExtent[1] = parseFloat(end);
    }
  },
  unionExtent: function (other) {
    var extent = this._extent;
    other[0] < extent[0] && (extent[0] = other[0]);
    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes

    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
  },

  /**
   * Get interval
   */
  getInterval: function () {
    return this._interval;
  },

  /**
   * Set interval
   */
  setInterval: function (interval) {
    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent
    // We assume user wan't to set both interval, min, max to get a better result

    this._niceExtent = this._extent.slice();
    this._intervalPrecision = helper.getIntervalPrecision(interval);
  },

  /**
   * @return {Array.<number>}
   */
  getTicks: function () {
    return helper.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);
  },

  /**
   * @return {Array.<string>}
   */
  getTicksLabels: function () {
    var labels = [];
    var ticks = this.getTicks();

    for (var i = 0; i < ticks.length; i++) {
      labels.push(this.getLabel(ticks[i]));
    }

    return labels;
  },

  /**
   * @param {number} data
   * @param {Object} [opt]
   * @param {number|string} [opt.precision] If 'auto', use nice presision.
   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.
   * @return {string}
   */
  getLabel: function (data, opt) {
    if (data == null) {
      return '';
    }

    var precision = opt && opt.precision;

    if (precision == null) {
      precision = numberUtil.getPrecisionSafe(data) || 0;
    } else if (precision === 'auto') {
      // Should be more precise then tick.
      precision = this._intervalPrecision;
    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.
    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.


    data = roundNumber(data, precision, true);
    return formatUtil.addCommas(data);
  },

  /**
   * Update interval and extent of intervals for nice ticks
   *
   * @param {number} [splitNumber = 5] Desired number of ticks
   * @param {number} [minInterval]
   * @param {number} [maxInterval]
   */
  niceTicks: function (splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    var extent = this._extent;
    var span = extent[1] - extent[0];

    if (!isFinite(span)) {
      return;
    } // User may set axis min 0 and data are all negative
    // FIXME If it needs to reverse ?


    if (span < 0) {
      span = -span;
      extent.reverse();
    }

    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  },

  /**
   * Nice extent.
   * @param {Object} opt
   * @param {number} [opt.splitNumber = 5] Given approx tick number
   * @param {boolean} [opt.fixMin=false]
   * @param {boolean} [opt.fixMax=false]
   * @param {boolean} [opt.minInterval]
   * @param {boolean} [opt.maxInterval]
   */
  niceExtent: function (opt) {
    var extent = this._extent; // If extent start and end are same, expand them

    if (extent[0] === extent[1]) {
      if (extent[0] !== 0) {
        // Expand extent
        var expandSize = extent[0]; // In the fowllowing case
        //      Axis has been fixed max 100
        //      Plus data are all 100 and axis extent are [100, 100].
        // Extend to the both side will cause expanded max is larger than fixed max.
        // So only expand to the smaller side.

        if (!opt.fixMax) {
          extent[1] += expandSize / 2;
          extent[0] -= expandSize / 2;
        } else {
          extent[0] -= expandSize / 2;
        }
      } else {
        extent[1] = 1;
      }
    }

    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]

    if (!isFinite(span)) {
      extent[0] = 0;
      extent[1] = 1;
    }

    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;

    var interval = this._interval;

    if (!opt.fixMin) {
      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);
    }

    if (!opt.fixMax) {
      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);
    }
  }
});
/**
 * @return {module:echarts/scale/Time}
 */

IntervalScale.create = function () {
  return new IntervalScale();
};

var _default = IntervalScale;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/Log.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Scale = __webpack_require__("./node_modules/echarts/lib/scale/Scale.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var IntervalScale = __webpack_require__("./node_modules/echarts/lib/scale/Interval.js");

/**
 * Log scale
 * @module echarts/scale/Log
 */
// Use some method of IntervalScale
var scaleProto = Scale.prototype;
var intervalScaleProto = IntervalScale.prototype;
var getPrecisionSafe = numberUtil.getPrecisionSafe;
var roundingErrorFix = numberUtil.round;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var mathPow = Math.pow;
var mathLog = Math.log;
var LogScale = Scale.extend({
  type: 'log',
  base: 10,
  $constructor: function () {
    Scale.apply(this, arguments);
    this._originalScale = new IntervalScale();
  },

  /**
   * @return {Array.<number>}
   */
  getTicks: function () {
    var originalScale = this._originalScale;
    var extent = this._extent;
    var originalExtent = originalScale.getExtent();
    return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {
      var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158

      powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
      powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
      return powVal;
    }, this);
  },

  /**
   * @param {number} val
   * @return {string}
   */
  getLabel: intervalScaleProto.getLabel,

  /**
   * @param  {number} val
   * @return {number}
   */
  scale: function (val) {
    val = scaleProto.scale.call(this, val);
    return mathPow(this.base, val);
  },

  /**
   * @param {number} start
   * @param {number} end
   */
  setExtent: function (start, end) {
    var base = this.base;
    start = mathLog(start) / mathLog(base);
    end = mathLog(end) / mathLog(base);
    intervalScaleProto.setExtent.call(this, start, end);
  },

  /**
   * @return {number} end
   */
  getExtent: function () {
    var base = this.base;
    var extent = scaleProto.getExtent.call(this);
    extent[0] = mathPow(base, extent[0]);
    extent[1] = mathPow(base, extent[1]); // Fix #4158

    var originalScale = this._originalScale;
    var originalExtent = originalScale.getExtent();
    originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
    originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
    return extent;
  },

  /**
   * @param  {Array.<number>} extent
   */
  unionExtent: function (extent) {
    this._originalScale.unionExtent(extent);

    var base = this.base;
    extent[0] = mathLog(extent[0]) / mathLog(base);
    extent[1] = mathLog(extent[1]) / mathLog(base);
    scaleProto.unionExtent.call(this, extent);
  },

  /**
   * @override
   */
  unionExtentFromData: function (data, dim) {
    this.unionExtent(data.getDataExtent(dim, true, function (val) {
      return val > 0;
    }));
  },

  /**
   * Update interval and extent of intervals for nice ticks
   * @param  {number} [approxTickNum = 10] Given approx tick number
   */
  niceTicks: function (approxTickNum) {
    approxTickNum = approxTickNum || 10;
    var extent = this._extent;
    var span = extent[1] - extent[0];

    if (span === Infinity || span <= 0) {
      return;
    }

    var interval = numberUtil.quantity(span);
    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.

    if (err <= 0.5) {
      interval *= 10;
    } // Interval should be integer


    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }

    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];
    this._interval = interval;
    this._niceExtent = niceExtent;
  },

  /**
   * Nice extent.
   * @override
   */
  niceExtent: function (opt) {
    intervalScaleProto.niceExtent.call(this, opt);
    var originalScale = this._originalScale;
    originalScale.__fixMin = opt.fixMin;
    originalScale.__fixMax = opt.fixMax;
  }
});
zrUtil.each(['contain', 'normalize'], function (methodName) {
  LogScale.prototype[methodName] = function (val) {
    val = mathLog(val) / mathLog(this.base);
    return scaleProto[methodName].call(this, val);
  };
});

LogScale.create = function () {
  return new LogScale();
};

function fixRoundingError(val, originalVal) {
  return roundingErrorFix(val, getPrecisionSafe(originalVal));
}

var _default = LogScale;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/Ordinal.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Scale = __webpack_require__("./node_modules/echarts/lib/scale/Scale.js");

/**
 * Linear continuous scale
 * @module echarts/coord/scale/Ordinal
 *
 * http://en.wikipedia.org/wiki/Level_of_measurement
 */
// FIXME only one data
var scaleProto = Scale.prototype;
var OrdinalScale = Scale.extend({
  type: 'ordinal',
  init: function (data, extent) {
    this._data = data;
    this._extent = extent || [0, data.length - 1];
  },
  parse: function (val) {
    return typeof val === 'string' ? zrUtil.indexOf(this._data, val) // val might be float.
    : Math.round(val);
  },
  contain: function (rank) {
    rank = this.parse(rank);
    return scaleProto.contain.call(this, rank) && this._data[rank] != null;
  },

  /**
   * Normalize given rank or name to linear [0, 1]
   * @param {number|string} [val]
   * @return {number}
   */
  normalize: function (val) {
    return scaleProto.normalize.call(this, this.parse(val));
  },
  scale: function (val) {
    return Math.round(scaleProto.scale.call(this, val));
  },

  /**
   * @return {Array}
   */
  getTicks: function () {
    var ticks = [];
    var extent = this._extent;
    var rank = extent[0];

    while (rank <= extent[1]) {
      ticks.push(rank);
      rank++;
    }

    return ticks;
  },

  /**
   * Get item on rank n
   * @param {number} n
   * @return {string}
   */
  getLabel: function (n) {
    return this._data[n];
  },

  /**
   * @return {number}
   */
  count: function () {
    return this._extent[1] - this._extent[0] + 1;
  },

  /**
   * @override
   */
  unionExtentFromData: function (data, dim) {
    this.unionExtent(data.getDataExtent(dim, false));
  },
  niceTicks: zrUtil.noop,
  niceExtent: zrUtil.noop
});
/**
 * @return {module:echarts/scale/Time}
 */

OrdinalScale.create = function () {
  return new OrdinalScale();
};

var _default = OrdinalScale;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/Scale.js":
/***/ (function(module, exports, __webpack_require__) {

var clazzUtil = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

/**
 * // Scale class management
 * @module echarts/scale/Scale
 */

/**
 * @param {Object} [setting]
 */
function Scale(setting) {
  this._setting = setting || {};
  /**
   * Extent
   * @type {Array.<number>}
   * @protected
   */

  this._extent = [Infinity, -Infinity];
  /**
   * Step is calculated in adjustExtent
   * @type {Array.<number>}
   * @protected
   */

  this._interval = 0;
  this.init && this.init.apply(this, arguments);
}
/**
 * Parse input val to valid inner number.
 * @param {*} val
 * @return {number}
 */


Scale.prototype.parse = function (val) {
  // Notice: This would be a trap here, If the implementation
  // of this method depends on extent, and this method is used
  // before extent set (like in dataZoom), it would be wrong.
  // Nevertheless, parse does not depend on extent generally.
  return val;
};

Scale.prototype.getSetting = function (name) {
  return this._setting[name];
};

Scale.prototype.contain = function (val) {
  var extent = this._extent;
  return val >= extent[0] && val <= extent[1];
};
/**
 * Normalize value to linear [0, 1], return 0.5 if extent span is 0
 * @param {number} val
 * @return {number}
 */


Scale.prototype.normalize = function (val) {
  var extent = this._extent;

  if (extent[1] === extent[0]) {
    return 0.5;
  }

  return (val - extent[0]) / (extent[1] - extent[0]);
};
/**
 * Scale normalized value
 * @param {number} val
 * @return {number}
 */


Scale.prototype.scale = function (val) {
  var extent = this._extent;
  return val * (extent[1] - extent[0]) + extent[0];
};
/**
 * Set extent from data
 * @param {Array.<number>} other
 */


Scale.prototype.unionExtent = function (other) {
  var extent = this._extent;
  other[0] < extent[0] && (extent[0] = other[0]);
  other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power
  // this.setExtent(extent[0], extent[1]);
};
/**
 * Set extent from data
 * @param {module:echarts/data/List} data
 * @param {string} dim
 */


Scale.prototype.unionExtentFromData = function (data, dim) {
  this.unionExtent(data.getDataExtent(dim, true));
};
/**
 * Get extent
 * @return {Array.<number>}
 */


Scale.prototype.getExtent = function () {
  return this._extent.slice();
};
/**
 * Set extent
 * @param {number} start
 * @param {number} end
 */


Scale.prototype.setExtent = function (start, end) {
  var thisExtent = this._extent;

  if (!isNaN(start)) {
    thisExtent[0] = start;
  }

  if (!isNaN(end)) {
    thisExtent[1] = end;
  }
};
/**
 * @return {Array.<string>}
 */


Scale.prototype.getTicksLabels = function () {
  var labels = [];
  var ticks = this.getTicks();

  for (var i = 0; i < ticks.length; i++) {
    labels.push(this.getLabel(ticks[i]));
  }

  return labels;
};
/**
 * When axis extent depends on data and no data exists,
 * axis ticks should not be drawn, which is named 'blank'.
 */


Scale.prototype.isBlank = function () {
  return this._isBlank;
},
/**
 * When axis extent depends on data and no data exists,
 * axis ticks should not be drawn, which is named 'blank'.
 */
Scale.prototype.setBlank = function (isBlank) {
  this._isBlank = isBlank;
};
clazzUtil.enableClassExtend(Scale);
clazzUtil.enableClassManagement(Scale, {
  registerWhenExtend: true
});
var _default = Scale;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/Time.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var scaleHelper = __webpack_require__("./node_modules/echarts/lib/scale/helper.js");

var IntervalScale = __webpack_require__("./node_modules/echarts/lib/scale/Interval.js");

// [About UTC and local time zone]:
// In most cases, `number.parseDate` will treat input data string as local time
// (except time zone is specified in time string). And `format.formateTime` returns
// local time by default. option.useUTC is false by default. This design have
// concidered these common case:
// (1) Time that is persistent in server is in UTC, but it is needed to be diplayed
// in local time by default.
// (2) By default, the input data string (e.g., '2011-01-02') should be displayed
// as its original time, without any time difference.
var intervalScaleProto = IntervalScale.prototype;
var mathCeil = Math.ceil;
var mathFloor = Math.floor;
var ONE_SECOND = 1000;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24; // FIXME 公用？

var bisect = function (a, x, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;

    if (a[mid][1] < x) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }

  return lo;
};
/**
 * @alias module:echarts/coord/scale/Time
 * @constructor
 */


var TimeScale = IntervalScale.extend({
  type: 'time',

  /**
   * @override
   */
  getLabel: function (val) {
    var stepLvl = this._stepLvl;
    var date = new Date(val);
    return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));
  },

  /**
   * @override
   */
  niceExtent: function (opt) {
    var extent = this._extent; // If extent start and end are same, expand them

    if (extent[0] === extent[1]) {
      // Expand extent
      extent[0] -= ONE_DAY;
      extent[1] += ONE_DAY;
    } // If there are no data and extent are [Infinity, -Infinity]


    if (extent[1] === -Infinity && extent[0] === Infinity) {
      var d = new Date();
      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
      extent[0] = extent[1] - ONE_DAY;
    }

    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;

    var interval = this._interval;

    if (!opt.fixMin) {
      extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
    }

    if (!opt.fixMax) {
      extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
    }
  },

  /**
   * @override
   */
  niceTicks: function (approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    var extent = this._extent;
    var span = extent[1] - extent[0];
    var approxInterval = span / approxTickNum;

    if (minInterval != null && approxInterval < minInterval) {
      approxInterval = minInterval;
    }

    if (maxInterval != null && approxInterval > maxInterval) {
      approxInterval = maxInterval;
    }

    var scaleLevelsLen = scaleLevels.length;
    var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
    var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
    var interval = level[1]; // Same with interval scale if span is much larger than 1 year

    if (level[0] === 'year') {
      var yearSpan = span / interval; // From "Nice Numbers for Graph Labels" of Graphic Gems
      // var niceYearSpan = numberUtil.nice(yearSpan, false);

      var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);
      interval *= yearStep;
    }

    var timezoneOffset = this.getSetting('useUTC') ? 0 : new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 60 * 1000;
    var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];
    scaleHelper.fixExtent(niceExtent, extent);
    this._stepLvl = level; // Interval will be used in getTicks

    this._interval = interval;
    this._niceExtent = niceExtent;
  },
  parse: function (val) {
    // val might be float.
    return +numberUtil.parseDate(val);
  }
});
zrUtil.each(['contain', 'normalize'], function (methodName) {
  TimeScale.prototype[methodName] = function (val) {
    return intervalScaleProto[methodName].call(this, this.parse(val));
  };
}); // Steps from d3

var scaleLevels = [// Format              interval
['hh:mm:ss', ONE_SECOND], // 1s
['hh:mm:ss', ONE_SECOND * 5], // 5s
['hh:mm:ss', ONE_SECOND * 10], // 10s
['hh:mm:ss', ONE_SECOND * 15], // 15s
['hh:mm:ss', ONE_SECOND * 30], // 30s
['hh:mm\nMM-dd', ONE_MINUTE], // 1m
['hh:mm\nMM-dd', ONE_MINUTE * 5], // 5m
['hh:mm\nMM-dd', ONE_MINUTE * 10], // 10m
['hh:mm\nMM-dd', ONE_MINUTE * 15], // 15m
['hh:mm\nMM-dd', ONE_MINUTE * 30], // 30m
['hh:mm\nMM-dd', ONE_HOUR], // 1h
['hh:mm\nMM-dd', ONE_HOUR * 2], // 2h
['hh:mm\nMM-dd', ONE_HOUR * 6], // 6h
['hh:mm\nMM-dd', ONE_HOUR * 12], // 12h
['MM-dd\nyyyy', ONE_DAY], // 1d
['MM-dd\nyyyy', ONE_DAY * 2], // 2d
['MM-dd\nyyyy', ONE_DAY * 3], // 3d
['MM-dd\nyyyy', ONE_DAY * 4], // 4d
['MM-dd\nyyyy', ONE_DAY * 5], // 5d
['MM-dd\nyyyy', ONE_DAY * 6], // 6d
['week', ONE_DAY * 7], // 7d
['MM-dd\nyyyy', ONE_DAY * 10], // 10d
['week', ONE_DAY * 14], // 2w
['week', ONE_DAY * 21], // 3w
['month', ONE_DAY * 31], // 1M
['week', ONE_DAY * 42], // 6w
['month', ONE_DAY * 62], // 2M
['week', ONE_DAY * 42], // 10w
['quarter', ONE_DAY * 380 / 4], // 3M
['month', ONE_DAY * 31 * 4], // 4M
['month', ONE_DAY * 31 * 5], // 5M
['half-year', ONE_DAY * 380 / 2], // 6M
['month', ONE_DAY * 31 * 8], // 8M
['month', ONE_DAY * 31 * 10], // 10M
['year', ONE_DAY * 380] // 1Y
];
/**
 * @param {module:echarts/model/Model}
 * @return {module:echarts/scale/Time}
 */

TimeScale.create = function (model) {
  return new TimeScale({
    useUTC: model.ecModel.get('useUTC')
  });
};

var _default = TimeScale;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/helper.js":
/***/ (function(module, exports, __webpack_require__) {

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

/**
 * For testable.
 */
var roundNumber = numberUtil.round;
/**
 * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.
 *                                Should be extent[0] < extent[1].
 * @param {number} splitNumber splitNumber should be >= 1.
 * @param {number} [minInterval]
 * @param {number} [maxInterval]
 * @return {Object} {interval, intervalPrecision, niceTickExtent}
 */

function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
  var result = {};
  var span = extent[1] - extent[0];
  var interval = result.interval = numberUtil.nice(span / splitNumber, true);

  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }

  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  } // Tow more digital for tick.


  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent

  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];
  fixExtent(niceTickExtent, extent);
  return result;
}
/**
 * @param {number} interval
 * @return {number} interval precision
 */


function getIntervalPrecision(interval) {
  // Tow more digital for tick.
  return numberUtil.getPrecisionSafe(interval) + 2;
}

function clamp(niceTickExtent, idx, extent) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.


function fixExtent(niceTickExtent, extent) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
  clamp(niceTickExtent, 0, extent);
  clamp(niceTickExtent, 1, extent);

  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}

function intervalScaleGetTicks(interval, extent, niceTickExtent, intervalPrecision) {
  var ticks = []; // If interval is 0, return [];

  if (!interval) {
    return ticks;
  } // Consider this case: using dataZoom toolbox, zoom and zoom.


  var safeLimit = 10000;

  if (extent[0] < niceTickExtent[0]) {
    ticks.push(extent[0]);
  }

  var tick = niceTickExtent[0];

  while (tick <= niceTickExtent[1]) {
    ticks.push(tick); // Avoid rounding error

    tick = roundNumber(tick + interval, intervalPrecision);

    if (tick === ticks[ticks.length - 1]) {
      // Consider out of safe float point, e.g.,
      // -3711126.9907707 + 2e-10 === -3711126.9907707
      break;
    }

    if (ticks.length > safeLimit) {
      return [];
    }
  } // Consider this case: the last item of ticks is smaller
  // than niceTickExtent[1] and niceTickExtent[1] === extent[1].


  if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {
    ticks.push(extent[1]);
  }

  return ticks;
}

exports.intervalScaleNiceTicks = intervalScaleNiceTicks;
exports.getIntervalPrecision = getIntervalPrecision;
exports.fixExtent = fixExtent;
exports.intervalScaleGetTicks = intervalScaleGetTicks;

/***/ }),

/***/ "./node_modules/echarts/lib/util/clazz.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var TYPE_DELIMITER = '.';
var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
var MEMBER_PRIFIX = '\0ec_\0';
/**
 * Hide private class member.
 * The same behavior as `host[name] = value;` (can be right-value)
 * @public
 */

function set(host, name, value) {
  return host[MEMBER_PRIFIX + name] = value;
}
/**
 * Hide private class member.
 * The same behavior as `host[name];`
 * @public
 */


function get(host, name) {
  return host[MEMBER_PRIFIX + name];
}
/**
 * For hidden private class member.
 * The same behavior as `host.hasOwnProperty(name);`
 * @public
 */


function hasOwn(host, name) {
  return host.hasOwnProperty(MEMBER_PRIFIX + name);
}
/**
 * Notice, parseClassType('') should returns {main: '', sub: ''}
 * @public
 */


function parseClassType(componentType) {
  var ret = {
    main: '',
    sub: ''
  };

  if (componentType) {
    componentType = componentType.split(TYPE_DELIMITER);
    ret.main = componentType[0] || '';
    ret.sub = componentType[1] || '';
  }

  return ret;
}
/**
 * @public
 */


function checkClassType(componentType) {
  zrUtil.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
/**
 * @public
 */


function enableClassExtend(RootClass, mandatoryMethods) {
  RootClass.$constructor = RootClass;

  RootClass.extend = function (proto) {
    var superClass = this;

    var ExtendedClass = function () {
      if (!proto.$constructor) {
        superClass.apply(this, arguments);
      } else {
        proto.$constructor.apply(this, arguments);
      }
    };

    zrUtil.extend(ExtendedClass.prototype, proto);
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    zrUtil.inherits(ExtendedClass, this);
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
} // superCall should have class info, which can not be fetch from 'this'.
// Consider this case:
// class A has method f,
// class B inherits class A, overrides method f, f call superApply('f'),
// class C inherits class B, do not overrides method f,
// then when method of class C is called, dead loop occured.


function superCall(context, methodName) {
  var args = zrUtil.slice(arguments, 2);
  return this.superClass.prototype[methodName].apply(context, args);
}

function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
/**
 * @param {Object} entity
 * @param {Object} options
 * @param {boolean} [options.registerWhenExtend]
 * @public
 */


function enableClassManagement(entity, options) {
  options = options || {};
  /**
   * Component model classes
   * key: componentType,
   * value:
   *     componentClass, when componentType is 'xxx'
   *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
   * @type {Object}
   */

  var storage = {};

  entity.registerClass = function (Clazz, componentType) {
    if (componentType) {
      checkClassType(componentType);
      componentType = parseClassType(componentType);

      if (!componentType.sub) {
        storage[componentType.main] = Clazz;
      } else if (componentType.sub !== IS_CONTAINER) {
        var container = makeContainer(componentType);
        container[componentType.sub] = Clazz;
      }
    }

    return Clazz;
  };

  entity.getClass = function (componentMainType, subType, throwWhenNotFound) {
    var Clazz = storage[componentMainType];

    if (Clazz && Clazz[IS_CONTAINER]) {
      Clazz = subType ? Clazz[subType] : null;
    }

    if (throwWhenNotFound && !Clazz) {
      throw new Error(!subType ? componentMainType + '.' + 'type should be specified.' : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.');
    }

    return Clazz;
  };

  entity.getClassesByMainType = function (componentType) {
    componentType = parseClassType(componentType);
    var result = [];
    var obj = storage[componentType.main];

    if (obj && obj[IS_CONTAINER]) {
      zrUtil.each(obj, function (o, type) {
        type !== IS_CONTAINER && result.push(o);
      });
    } else {
      result.push(obj);
    }

    return result;
  };

  entity.hasClass = function (componentType) {
    // Just consider componentType.main.
    componentType = parseClassType(componentType);
    return !!storage[componentType.main];
  };
  /**
   * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
   */


  entity.getAllClassMainTypes = function () {
    var types = [];
    zrUtil.each(storage, function (obj, type) {
      types.push(type);
    });
    return types;
  };
  /**
   * If a main type is container and has sub types
   * @param  {string}  mainType
   * @return {boolean}
   */


  entity.hasSubTypes = function (componentType) {
    componentType = parseClassType(componentType);
    var obj = storage[componentType.main];
    return obj && obj[IS_CONTAINER];
  };

  entity.parseClassType = parseClassType;

  function makeContainer(componentType) {
    var container = storage[componentType.main];

    if (!container || !container[IS_CONTAINER]) {
      container = storage[componentType.main] = {};
      container[IS_CONTAINER] = true;
    }

    return container;
  }

  if (options.registerWhenExtend) {
    var originalExtend = entity.extend;

    if (originalExtend) {
      entity.extend = function (proto) {
        var ExtendedClass = originalExtend.call(this, proto);
        return entity.registerClass(ExtendedClass, proto.type);
      };
    }
  }

  return entity;
}
/**
 * @param {string|Array.<string>} properties
 */


function setReadOnly(obj, properties) {// FIXME It seems broken in IE8 simulation of IE11
  // if (!zrUtil.isArray(properties)) {
  //     properties = properties != null ? [properties] : [];
  // }
  // zrUtil.each(properties, function (prop) {
  //     var value = obj[prop];
  //     Object.defineProperty
  //         && Object.defineProperty(obj, prop, {
  //             value: value, writable: false
  //         });
  //     zrUtil.isArray(obj[prop])
  //         && Object.freeze
  //         && Object.freeze(obj[prop]);
  // });
}

exports.set = set;
exports.get = get;
exports.hasOwn = hasOwn;
exports.parseClassType = parseClassType;
exports.enableClassExtend = enableClassExtend;
exports.enableClassManagement = enableClassManagement;
exports.setReadOnly = setReadOnly;

/***/ }),

/***/ "./node_modules/echarts/lib/util/component.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _clazz = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var parseClassType = _clazz.parseClassType;
var base = 0;
var DELIMITER = '_';
/**
 * @public
 * @param {string} type
 * @return {string}
 */

function getUID(type) {
  // Considering the case of crossing js context,
  // use Math.random to make id as unique as possible.
  return [type || '', base++, Math.random()].join(DELIMITER);
}
/**
 * @inner
 */


function enableSubTypeDefaulter(entity) {
  var subTypeDefaulters = {};

  entity.registerSubTypeDefaulter = function (componentType, defaulter) {
    componentType = parseClassType(componentType);
    subTypeDefaulters[componentType.main] = defaulter;
  };

  entity.determineSubType = function (componentType, option) {
    var type = option.type;

    if (!type) {
      var componentTypeMain = parseClassType(componentType).main;

      if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }

    return type;
  };

  return entity;
}
/**
 * Topological travel on Activity Network (Activity On Vertices).
 * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
 *
 * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
 *
 * If there is circle dependencey, Error will be thrown.
 *
 */


function enableTopologicalTravel(entity, dependencyGetter) {
  /**
   * @public
   * @param {Array.<string>} targetNameList Target Component type list.
   *                                           Can be ['aa', 'bb', 'aa.xx']
   * @param {Array.<string>} fullNameList By which we can build dependency graph.
   * @param {Function} callback Params: componentType, dependencies.
   * @param {Object} context Scope of callback.
   */
  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }

    var result = makeDepndencyGraph(fullNameList);
    var graph = result.graph;
    var stack = result.noEntryList;
    var targetNameSet = {};
    zrUtil.each(targetNameList, function (name) {
      targetNameSet[name] = true;
    });

    while (stack.length) {
      var currComponentType = stack.pop();
      var currVertex = graph[currComponentType];
      var isInTargetNameSet = !!targetNameSet[currComponentType];

      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }

      zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }

    zrUtil.each(targetNameSet, function () {
      throw new Error('Circle dependency may exists');
    });

    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;

      if (graph[succComponentType].entryCount === 0) {
        stack.push(succComponentType);
      }
    } // Consider this case: legend depends on series, and we call
    // chart.setOption({series: [...]}), where only series is in option.
    // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
    // not be called, but only sereis.mergeOption is called. Thus legend
    // have no chance to update its local record about series (like which
    // name of series is available in legend).


    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  /**
   * DepndencyGraph: {Object}
   * key: conponentType,
   * value: {
   *     successor: [conponentTypes...],
   *     originalDeps: [conponentTypes...],
   *     entryCount: {number}
   * }
   */


  function makeDepndencyGraph(fullNameList) {
    var graph = {};
    var noEntryList = [];
    zrUtil.each(fullNameList, function (name) {
      var thisItem = createDependencyGraphItem(graph, name);
      var originalDeps = thisItem.originalDeps = dependencyGetter(name);
      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;

      if (thisItem.entryCount === 0) {
        noEntryList.push(name);
      }

      zrUtil.each(availableDeps, function (dependentName) {
        if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }

        var thatItem = createDependencyGraphItem(graph, dependentName);

        if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name);
        }
      });
    });
    return {
      graph: graph,
      noEntryList: noEntryList
    };
  }

  function createDependencyGraphItem(graph, name) {
    if (!graph[name]) {
      graph[name] = {
        predecessor: [],
        successor: []
      };
    }

    return graph[name];
  }

  function getAvailableDependencies(originalDeps, fullNameList) {
    var availableDeps = [];
    zrUtil.each(originalDeps, function (dep) {
      zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}

exports.getUID = getUID;
exports.enableSubTypeDefaulter = enableSubTypeDefaulter;
exports.enableTopologicalTravel = enableTopologicalTravel;

/***/ }),

/***/ "./node_modules/echarts/lib/util/format.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

/**
 * 每三位默认加,格式化
 * @param {string|number} x
 * @return {string}
 */
function addCommas(x) {
  if (isNaN(x)) {
    return '-';
  }

  x = (x + '').split('.');
  return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');
}
/**
 * @param {string} str
 * @param {boolean} [upperCaseFirst=false]
 * @return {string} str
 */


function toCamelCase(str, upperCaseFirst) {
  str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
    return group1.toUpperCase();
  });

  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }

  return str;
}

var normalizeCssArray = zrUtil.normalizeCssArray;

function encodeHTML(source) {
  return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

var wrapVar = function (varName, seriesIdx) {
  return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
};
/**
 * Template formatter
 * @param {string} tpl
 * @param {Array.<Object>|Object} paramsList
 * @param {boolean} [encode=false]
 * @return {string}
 */


function formatTpl(tpl, paramsList, encode) {
  if (!zrUtil.isArray(paramsList)) {
    paramsList = [paramsList];
  }

  var seriesLen = paramsList.length;

  if (!seriesLen) {
    return '';
  }

  var $vars = paramsList[0].$vars || [];

  for (var i = 0; i < $vars.length; i++) {
    var alias = TPL_VAR_ALIAS[i];
    var val = wrapVar(alias, 0);
    tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);
  }

  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
    for (var k = 0; k < $vars.length; k++) {
      var val = paramsList[seriesIdx][$vars[k]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
    }
  }

  return tpl;
}
/**
 * simple Template formatter
 *
 * @param {string} tpl
 * @param {Object} param
 * @param {boolean} [encode=false]
 * @return {string}
 */


function formatTplSimple(tpl, param, encode) {
  zrUtil.each(param, function (value, key) {
    tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);
  });
  return tpl;
}
/**
 * @param {string} color
 * @param {string} [extraCssText]
 * @return {string}
 */


function getTooltipMarker(color, extraCssText) {
  return color ? '<span style="display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>' : '';
}
/**
 * @param {string} str
 * @return {string}
 * @inner
 */


var s2d = function (str) {
  return str < 10 ? '0' + str : str;
};
/**
 * ISO Date format
 * @param {string} tpl
 * @param {number} value
 * @param {boolean} [isUTC=false] Default in local time.
 *           see `module:echarts/scale/Time`
 *           and `module:echarts/util/number#parseDate`.
 * @inner
 */


function formatTime(tpl, value, isUTC) {
  if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
    tpl = 'MM-dd\nyyyy';
  }

  var date = numberUtil.parseDate(value);
  var utc = isUTC ? 'UTC' : '';
  var y = date['get' + utc + 'FullYear']();
  var M = date['get' + utc + 'Month']() + 1;
  var d = date['get' + utc + 'Date']();
  var h = date['get' + utc + 'Hours']();
  var m = date['get' + utc + 'Minutes']();
  var s = date['get' + utc + 'Seconds']();
  tpl = tpl.replace('MM', s2d(M)).replace('M', M).replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);
  return tpl;
}
/**
 * Capital first
 * @param {string} str
 * @return {string}
 */


function capitalFirst(str) {
  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}

var truncateText = textContain.truncateText;
var getTextRect = textContain.getBoundingRect;
exports.addCommas = addCommas;
exports.toCamelCase = toCamelCase;
exports.normalizeCssArray = normalizeCssArray;
exports.encodeHTML = encodeHTML;
exports.formatTpl = formatTpl;
exports.formatTplSimple = formatTplSimple;
exports.getTooltipMarker = getTooltipMarker;
exports.formatTime = formatTime;
exports.capitalFirst = capitalFirst;
exports.truncateText = truncateText;
exports.getTextRect = getTextRect;

/***/ }),

/***/ "./node_modules/echarts/lib/util/graphic.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var pathTool = __webpack_require__("./node_modules/zrender/lib/tool/path.js");

var colorTool = __webpack_require__("./node_modules/zrender/lib/tool/color.js");

var matrix = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

var vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var Transformable = __webpack_require__("./node_modules/zrender/lib/mixin/Transformable.js");

var Image = __webpack_require__("./node_modules/zrender/lib/graphic/Image.js");

exports.Image = Image;

var Group = __webpack_require__("./node_modules/zrender/lib/container/Group.js");

exports.Group = Group;

var Text = __webpack_require__("./node_modules/zrender/lib/graphic/Text.js");

exports.Text = Text;

var Circle = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Circle.js");

exports.Circle = Circle;

var Sector = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Sector.js");

exports.Sector = Sector;

var Ring = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Ring.js");

exports.Ring = Ring;

var Polygon = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Polygon.js");

exports.Polygon = Polygon;

var Polyline = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Polyline.js");

exports.Polyline = Polyline;

var Rect = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Rect.js");

exports.Rect = Rect;

var Line = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Line.js");

exports.Line = Line;

var BezierCurve = __webpack_require__("./node_modules/zrender/lib/graphic/shape/BezierCurve.js");

exports.BezierCurve = BezierCurve;

var Arc = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Arc.js");

exports.Arc = Arc;

var CompoundPath = __webpack_require__("./node_modules/zrender/lib/graphic/CompoundPath.js");

exports.CompoundPath = CompoundPath;

var LinearGradient = __webpack_require__("./node_modules/zrender/lib/graphic/LinearGradient.js");

exports.LinearGradient = LinearGradient;

var RadialGradient = __webpack_require__("./node_modules/zrender/lib/graphic/RadialGradient.js");

exports.RadialGradient = RadialGradient;

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

exports.BoundingRect = BoundingRect;
var round = Math.round;
var mathMax = Math.max;
var mathMin = Math.min;
var EMPTY_OBJ = {};
/**
 * Extend shape with parameters
 */

function extendShape(opts) {
  return Path.extend(opts);
}
/**
 * Extend path
 */


function extendPath(pathData, opts) {
  return pathTool.extendFromString(pathData, opts);
}
/**
 * Create a path element from path data string
 * @param {string} pathData
 * @param {Object} opts
 * @param {module:zrender/core/BoundingRect} rect
 * @param {string} [layout=cover] 'center' or 'cover'
 */


function makePath(pathData, opts, rect, layout) {
  var path = pathTool.createFromString(pathData, opts);
  var boundingRect = path.getBoundingRect();

  if (rect) {
    if (layout === 'center') {
      rect = centerGraphic(rect, boundingRect);
    }

    resizePath(path, rect);
  }

  return path;
}
/**
 * Create a image element from image url
 * @param {string} imageUrl image url
 * @param {Object} opts options
 * @param {module:zrender/core/BoundingRect} rect constrain rect
 * @param {string} [layout=cover] 'center' or 'cover'
 */


function makeImage(imageUrl, rect, layout) {
  var path = new Image({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload: function (img) {
      if (layout === 'center') {
        var boundingRect = {
          width: img.width,
          height: img.height
        };
        path.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return path;
}
/**
 * Get position of centered element in bounding box.
 *
 * @param  {Object} rect         element local bounding box
 * @param  {Object} boundingRect constraint bounding box
 * @return {Object} element position containing x, y, width, and height
 */


function centerGraphic(rect, boundingRect) {
  // Set rect to center, keep width / height ratio.
  var aspect = boundingRect.width / boundingRect.height;
  var width = rect.height * aspect;
  var height;

  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }

  var cx = rect.x + rect.width / 2;
  var cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width: width,
    height: height
  };
}

var mergePath = pathTool.mergePath;
/**
 * Resize a path to fit the rect
 * @param {module:zrender/graphic/Path} path
 * @param {Object} rect
 */

function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }

  var pathRect = path.getBoundingRect();
  var m = pathRect.calculateTransform(rect);
  path.applyTransform(m);
}
/**
 * Sub pixel optimize line for canvas
 *
 * @param {Object} param
 * @param {Object} [param.shape]
 * @param {number} [param.shape.x1]
 * @param {number} [param.shape.y1]
 * @param {number} [param.shape.x2]
 * @param {number} [param.shape.y2]
 * @param {Object} [param.style]
 * @param {number} [param.style.lineWidth]
 * @return {Object} Modified param
 */


function subPixelOptimizeLine(param) {
  var shape = param.shape;
  var lineWidth = param.style.lineWidth;

  if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
    shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
  }

  if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
    shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
  }

  return param;
}
/**
 * Sub pixel optimize rect for canvas
 *
 * @param {Object} param
 * @param {Object} [param.shape]
 * @param {number} [param.shape.x]
 * @param {number} [param.shape.y]
 * @param {number} [param.shape.width]
 * @param {number} [param.shape.height]
 * @param {Object} [param.style]
 * @param {number} [param.style.lineWidth]
 * @return {Object} Modified param
 */


function subPixelOptimizeRect(param) {
  var shape = param.shape;
  var lineWidth = param.style.lineWidth;
  var originX = shape.x;
  var originY = shape.y;
  var originWidth = shape.width;
  var originHeight = shape.height;
  shape.x = subPixelOptimize(shape.x, lineWidth, true);
  shape.y = subPixelOptimize(shape.y, lineWidth, true);
  shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);
  shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);
  return param;
}
/**
 * Sub pixel optimize for canvas
 *
 * @param {number} position Coordinate, such as x, y
 * @param {number} lineWidth Should be nonnegative integer.
 * @param {boolean=} positiveOrNegative Default false (negative).
 * @return {number} Optimized position.
 */


function subPixelOptimize(position, lineWidth, positiveOrNegative) {
  // Assure that (position + lineWidth / 2) is near integer edge,
  // otherwise line will be fuzzy in canvas.
  var doubledPosition = round(position * 2);
  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}

function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke != 'none';
}

function liftColor(color) {
  return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;
}
/**
 * @private
 */


function cacheElementStl(el) {
  if (el.__hoverStlDirty) {
    var stroke = el.style.stroke;
    var fill = el.style.fill; // Create hoverStyle on mouseover

    var hoverStyle = el.__hoverStl;
    hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);
    hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);
    var normalStyle = {};

    for (var name in hoverStyle) {
      // See comment in `doSingleEnterHover`.
      if (hoverStyle[name] != null) {
        normalStyle[name] = el.style[name];
      }
    }

    el.__normalStl = normalStyle;
    el.__hoverStlDirty = false;
  }
}
/**
 * @private
 */


function doSingleEnterHover(el) {
  if (el.__isHover) {
    return;
  }

  cacheElementStl(el);

  if (el.useHoverLayer) {
    el.__zr && el.__zr.addHover(el, el.__hoverStl);
  } else {
    var style = el.style;
    var insideRollbackOpt = style.insideRollbackOpt; // Consider case: only `position: 'top'` is set on emphasis, then text
    // color should be returned to `autoColor`, rather than remain '#fff'.
    // So we should rollback then apply again after style merging.

    insideRollbackOpt && rollbackInsideStyle(style); // styles can be:
    // {
    //     label: {
    //         normal: {
    //             show: false,
    //             position: 'outside',
    //             fontSize: 18
    //         },
    //         emphasis: {
    //             show: true
    //         }
    //     }
    // },
    // where properties of `emphasis` may not appear in `normal`. We previously use
    // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.
    // But consider rich text and setOption in merge mode, it is impossible to cover
    // all properties in merge. So we use merge mode when setting style here, where
    // only properties that is not `null/undefined` can be set. The disadventage:
    // null/undefined can not be used to remove style any more in `emphasis`.

    style.extendFrom(el.__hoverStl); // Do not save `insideRollback`.

    if (insideRollbackOpt) {
      applyInsideStyle(style, style.insideOriginalTextPosition, insideRollbackOpt); // textFill may be rollbacked to null.

      if (style.textFill == null) {
        style.textFill = insideRollbackOpt.autoColor;
      }
    }

    el.dirty(false);
    el.z2 += 1;
  }

  el.__isHover = true;
}
/**
 * @inner
 */


function doSingleLeaveHover(el) {
  if (!el.__isHover) {
    return;
  }

  var normalStl = el.__normalStl;

  if (el.useHoverLayer) {
    el.__zr && el.__zr.removeHover(el);
  } else {
    // Consider null/undefined value, should use
    // `setStyle` but not `extendFrom(stl, true)`.
    normalStl && el.setStyle(normalStl);
    el.z2 -= 1;
  }

  el.__isHover = false;
}
/**
 * @inner
 */


function doEnterHover(el) {
  el.type === 'group' ? el.traverse(function (child) {
    if (child.type !== 'group') {
      doSingleEnterHover(child);
    }
  }) : doSingleEnterHover(el);
}

function doLeaveHover(el) {
  el.type === 'group' ? el.traverse(function (child) {
    if (child.type !== 'group') {
      doSingleLeaveHover(child);
    }
  }) : doSingleLeaveHover(el);
}
/**
 * @inner
 */


function setElementHoverStl(el, hoverStl) {
  // If element has sepcified hoverStyle, then use it instead of given hoverStyle
  // Often used when item group has a label element and it's hoverStyle is different
  el.__hoverStl = el.hoverStyle || hoverStl || {};
  el.__hoverStlDirty = true;

  if (el.__isHover) {
    cacheElementStl(el);
  }
}
/**
 * @inner
 */


function onElementMouseOver(e) {
  if (this.__hoverSilentOnTouch && e.zrByTouch) {
    return;
  } // Only if element is not in emphasis status


  !this.__isEmphasis && doEnterHover(this);
}
/**
 * @inner
 */


function onElementMouseOut(e) {
  if (this.__hoverSilentOnTouch && e.zrByTouch) {
    return;
  } // Only if element is not in emphasis status


  !this.__isEmphasis && doLeaveHover(this);
}
/**
 * @inner
 */


function enterEmphasis() {
  this.__isEmphasis = true;
  doEnterHover(this);
}
/**
 * @inner
 */


function leaveEmphasis() {
  this.__isEmphasis = false;
  doLeaveHover(this);
}
/**
 * Set hover style of element.
 * This method can be called repeatly without side-effects.
 * @param {module:zrender/Element} el
 * @param {Object} [hoverStyle]
 * @param {Object} [opt]
 * @param {boolean} [opt.hoverSilentOnTouch=false]
 *        In touch device, mouseover event will be trigger on touchstart event
 *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
 *        conviniently use hoverStyle when tap on touch screen without additional
 *        code for compatibility.
 *        But if the chart/component has select feature, which usually also use
 *        hoverStyle, there might be conflict between 'select-highlight' and
 *        'hover-highlight' especially when roam is enabled (see geo for example).
 *        In this case, hoverSilentOnTouch should be used to disable hover-highlight
 *        on touch device.
 */


function setHoverStyle(el, hoverStyle, opt) {
  el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;
  el.type === 'group' ? el.traverse(function (child) {
    if (child.type !== 'group') {
      setElementHoverStl(child, hoverStyle);
    }
  }) : setElementHoverStl(el, hoverStyle); // Duplicated function will be auto-ignored, see Eventful.js.

  el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut); // Emphasis, normal can be triggered manually

  el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);
}
/**
 * @param {Object|module:zrender/graphic/Style} normalStyle
 * @param {Object} emphasisStyle
 * @param {module:echarts/model/Model} normalModel
 * @param {module:echarts/model/Model} emphasisModel
 * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.
 * @param {Object} [opt.defaultText]
 * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by
 *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by
 *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by
 *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {Object} [normalSpecified]
 * @param {Object} [emphasisSpecified]
 */


function setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {
  opt = opt || EMPTY_OBJ;
  var labelFetcher = opt.labelFetcher;
  var labelDataIndex = opt.labelDataIndex;
  var labelDimIndex = opt.labelDimIndex; // This scenario, `label.normal.show = true; label.emphasis.show = false`,
  // is not supported util someone requests.

  var showNormal = normalModel.getShallow('show');
  var showEmphasis = emphasisModel.getShallow('show'); // Consider performance, only fetch label when necessary.
  // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,
  // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.

  var baseText = showNormal || showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex) : null, opt.defaultText) : null;
  var normalStyleText = showNormal ? baseText : null;
  var emphasisStyleText = showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex) : null, baseText) : null; // Optimize: If style.text is null, text will not be drawn.

  if (normalStyleText != null || emphasisStyleText != null) {
    // Always set `textStyle` even if `normalStyle.text` is null, because default
    // values have to be set on `normalStyle`.
    // If we set default values on `emphasisStyle`, consider case:
    // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`
    // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`
    // Then the 'red' will not work on emphasis.
    setTextStyle(normalStyle, normalModel, normalSpecified, opt);
    setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);
  }

  normalStyle.text = normalStyleText;
  emphasisStyle.text = emphasisStyleText;
}
/**
 * Set basic textStyle properties.
 * @param {Object|module:zrender/graphic/Style} textStyle
 * @param {module:echarts/model/Model} model
 * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.
 * @param {Object} [opt] See `opt` of `setTextStyleCommon`.
 * @param {boolean} [isEmphasis]
 */


function setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {
  setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);
  specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle);
  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);
  return textStyle;
}
/**
 * Set text option in the style.
 * @deprecated
 * @param {Object} textStyle
 * @param {module:echarts/model/Model} labelModel
 * @param {string|boolean} defaultColor Default text color.
 *        If set as false, it will be processed as a emphasis style.
 */


function setText(textStyle, labelModel, defaultColor) {
  var opt = {
    isRectText: true
  };
  var isEmphasis;

  if (defaultColor === false) {
    isEmphasis = true;
  } else {
    // Support setting color as 'auto' to get visual color.
    opt.autoColor = defaultColor;
  }

  setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);
  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);
}
/**
 * {
 *      disableBox: boolean, Whether diable drawing box of block (outer most).
 *      isRectText: boolean,
 *      autoColor: string, specify a color when color is 'auto',
 *              for textFill, textStroke, textBackgroundColor, and textBorderColor.
 *              If autoColor specified, it is used as default textFill.
 *      useInsideStyle:
 *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)
 *                  if `textFill` is not specified.
 *              `false`: Do not use inside style.
 *              `null/undefined`: use inside style if `isRectText` is true and
 *                  `textFill` is not specified and textPosition contains `'inside'`.
 *      forceRich: boolean
 * }
 */


function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {
  // Consider there will be abnormal when merge hover style to normal style if given default value.
  opt = opt || EMPTY_OBJ;

  if (opt.isRectText) {
    var textPosition = textStyleModel.getShallow('position') || (isEmphasis ? null : 'inside'); // 'outside' is not a valid zr textPostion value, but used
    // in bar series, and magric type should be considered.

    textPosition === 'outside' && (textPosition = 'top');
    textStyle.textPosition = textPosition;
    textStyle.textOffset = textStyleModel.getShallow('offset');
    var labelRotate = textStyleModel.getShallow('rotate');
    labelRotate != null && (labelRotate *= Math.PI / 180);
    textStyle.textRotation = labelRotate;
    textStyle.textDistance = zrUtil.retrieve2(textStyleModel.getShallow('distance'), isEmphasis ? null : 5);
  }

  var ecModel = textStyleModel.ecModel;
  var globalTextStyle = ecModel && ecModel.option.textStyle; // Consider case:
  // {
  //     data: [{
  //         value: 12,
  //         label: {
  //             normal: {
  //                 rich: {
  //                     // no 'a' here but using parent 'a'.
  //                 }
  //             }
  //         }
  //     }],
  //     rich: {
  //         a: { ... }
  //     }
  // }

  var richItemNames = getRichItemNames(textStyleModel);
  var richResult;

  if (richItemNames) {
    richResult = {};

    for (var name in richItemNames) {
      if (richItemNames.hasOwnProperty(name)) {
        // Cascade is supported in rich.
        var richTextStyle = textStyleModel.getModel(['rich', name]); // In rich, never `disableBox`.

        setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);
      }
    }
  }

  textStyle.rich = richResult;
  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);

  if (opt.forceRich && !opt.textStyle) {
    opt.textStyle = {};
  }

  return textStyle;
} // Consider case:
// {
//     data: [{
//         value: 12,
//         label: {
//             normal: {
//                 rich: {
//                     // no 'a' here but using parent 'a'.
//                 }
//             }
//         }
//     }],
//     rich: {
//         a: { ... }
//     }
// }


function getRichItemNames(textStyleModel) {
  // Use object to remove duplicated names.
  var richItemNameMap;

  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    var rich = (textStyleModel.option || EMPTY_OBJ).rich;

    if (rich) {
      richItemNameMap = richItemNameMap || {};

      for (var name in rich) {
        if (rich.hasOwnProperty(name)) {
          richItemNameMap[name] = 1;
        }
      }
    }

    textStyleModel = textStyleModel.parentModel;
  }

  return richItemNameMap;
}

function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {
  // In merge mode, default value should not be given.
  globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;
  textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt) || globalTextStyle.color;
  textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt) || globalTextStyle.textBorderColor;
  textStyle.textStrokeWidth = zrUtil.retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);

  if (!isEmphasis) {
    if (isBlock) {
      // Always set `insideRollback`, for clearing previous.
      var originalTextPosition = textStyle.textPosition;
      textStyle.insideRollback = applyInsideStyle(textStyle, originalTextPosition, opt); // Save original textPosition, because style.textPosition will be repalced by
      // real location (like [10, 30]) in zrender.

      textStyle.insideOriginalTextPosition = originalTextPosition;
      textStyle.insideRollbackOpt = opt;
    } // Set default finally.


    if (textStyle.textFill == null) {
      textStyle.textFill = opt.autoColor;
    }
  } // Do not use `getFont` here, because merge should be supported, where
  // part of these properties may be changed in emphasis style, and the
  // others should remain their original value got from normal style.


  textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;
  textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;
  textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;
  textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;
  textStyle.textAlign = textStyleModel.getShallow('align');
  textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign') || textStyleModel.getShallow('baseline');
  textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');
  textStyle.textWidth = textStyleModel.getShallow('width');
  textStyle.textHeight = textStyleModel.getShallow('height');
  textStyle.textTag = textStyleModel.getShallow('tag');

  if (!isBlock || !opt.disableBox) {
    textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);
    textStyle.textPadding = textStyleModel.getShallow('padding');
    textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);
    textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');
    textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');
    textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');
    textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');
    textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');
    textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');
  }

  textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor') || globalTextStyle.textShadowColor;
  textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur') || globalTextStyle.textShadowBlur;
  textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX') || globalTextStyle.textShadowOffsetX;
  textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY') || globalTextStyle.textShadowOffsetY;
}

function getAutoColor(color, opt) {
  return color !== 'auto' ? color : opt && opt.autoColor ? opt.autoColor : null;
}

function applyInsideStyle(textStyle, textPosition, opt) {
  var useInsideStyle = opt.useInsideStyle;
  var insideRollback;

  if (textStyle.textFill == null && useInsideStyle !== false && (useInsideStyle === true || opt.isRectText && textPosition // textPosition can be [10, 30]
  && typeof textPosition === 'string' && textPosition.indexOf('inside') >= 0)) {
    insideRollback = {
      textFill: null,
      textStroke: textStyle.textStroke,
      textStrokeWidth: textStyle.textStrokeWidth
    };
    textStyle.textFill = '#fff'; // Consider text with #fff overflow its container.

    if (textStyle.textStroke == null) {
      textStyle.textStroke = opt.autoColor;
      textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);
    }
  }

  return insideRollback;
}

function rollbackInsideStyle(style) {
  var insideRollback = style.insideRollback;

  if (insideRollback) {
    style.textFill = insideRollback.textFill;
    style.textStroke = insideRollback.textStroke;
    style.textStrokeWidth = insideRollback.textStrokeWidth;
  }
}

function getFont(opt, ecModel) {
  // ecModel or default text style model.
  var gTextStyleModel = ecModel || ecModel.getModel('textStyle');
  return [// FIXME in node-canvas fontWeight is before fontStyle
  opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' ');
}

function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
  if (typeof dataIndex === 'function') {
    cb = dataIndex;
    dataIndex = null;
  } // Do not check 'animation' property directly here. Consider this case:
  // animation model is an `itemModel`, whose does not have `isAnimationEnabled`
  // but its parent model (`seriesModel`) does.


  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();

  if (animationEnabled) {
    var postfix = isUpdate ? 'Update' : '';
    var duration = animatableModel.getShallow('animationDuration' + postfix);
    var animationEasing = animatableModel.getShallow('animationEasing' + postfix);
    var animationDelay = animatableModel.getShallow('animationDelay' + postfix);

    if (typeof animationDelay === 'function') {
      animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
    }

    if (typeof duration === 'function') {
      duration = duration(dataIndex);
    }

    duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());
  } else {
    el.stopAnimation();
    el.attr(props);
    cb && cb();
  }
}
/**
 * Update graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So if do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 *
 * @param {module:zrender/Element} el
 * @param {Object} props
 * @param {module:echarts/model/Model} [animatableModel]
 * @param {number} [dataIndex]
 * @param {Function} [cb]
 * @example
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
 *     // Or
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, function () { console.log('Animation done!'); });
 */


function updateProps(el, props, animatableModel, dataIndex, cb) {
  animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
}
/**
 * Init graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So if do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 *
 * @param {module:zrender/Element} el
 * @param {Object} props
 * @param {module:echarts/model/Model} [animatableModel]
 * @param {number} [dataIndex]
 * @param {Function} cb
 */


function initProps(el, props, animatableModel, dataIndex, cb) {
  animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
}
/**
 * Get transform matrix of target (param target),
 * in coordinate of its ancestor (param ancestor)
 *
 * @param {module:zrender/mixin/Transformable} target
 * @param {module:zrender/mixin/Transformable} [ancestor]
 */


function getTransform(target, ancestor) {
  var mat = matrix.identity([]);

  while (target && target !== ancestor) {
    matrix.mul(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }

  return mat;
}
/**
 * Apply transform to an vertex.
 * @param {Array.<number>} target [x, y]
 * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:
 *      + Transform matrix: like [1, 0, 0, 1, 0, 0]
 *      + {position, rotation, scale}, the same as `zrender/Transformable`.
 * @param {boolean=} invert Whether use invert matrix.
 * @return {Array.<number>} [x, y]
 */


function applyTransform(target, transform, invert) {
  if (transform && !zrUtil.isArrayLike(transform)) {
    transform = Transformable.getLocalTransform(transform);
  }

  if (invert) {
    transform = matrix.invert([], transform);
  }

  return vector.applyTransform([], target, transform);
}
/**
 * @param {string} direction 'left' 'right' 'top' 'bottom'
 * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
 * @param {boolean=} invert Whether use invert matrix.
 * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
 */


function transformDirection(direction, transform, invert) {
  // Pick a base, ensure that transform result will not be (0, 0).
  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];
  vertex = applyTransform(vertex, transform, invert);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';
}
/**
 * Apply group transition animation from g1 to g2.
 * If no animatableModel, no animation.
 */


function groupTransition(g1, g2, animatableModel, cb) {
  if (!g1 || !g2) {
    return;
  }

  function getElMap(g) {
    var elMap = {};
    g.traverse(function (el) {
      if (!el.isGroup && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }

  function getAnimatableProps(el) {
    var obj = {
      position: vector.clone(el.position),
      rotation: el.rotation
    };

    if (el.shape) {
      obj.shape = zrUtil.extend({}, el.shape);
    }

    return obj;
  }

  var elMap1 = getElMap(g1);
  g2.traverse(function (el) {
    if (!el.isGroup && el.anid) {
      var oldEl = elMap1[el.anid];

      if (oldEl) {
        var newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps(el, newProp, animatableModel, el.dataIndex);
      } // else {
      //     if (el.previousProps) {
      //         graphic.updateProps
      //     }
      // }

    }
  });
}
/**
 * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]
 * @param {Object} rect {x, y, width, height}
 * @return {Array.<Array.<number>>} A new clipped points.
 */


function clipPointsByRect(points, rect) {
  return zrUtil.map(points, function (point) {
    var x = point[0];
    x = mathMax(x, rect.x);
    x = mathMin(x, rect.x + rect.width);
    var y = point[1];
    y = mathMax(y, rect.y);
    y = mathMin(y, rect.y + rect.height);
    return [x, y];
  });
}
/**
 * @param {Object} targetRect {x, y, width, height}
 * @param {Object} rect {x, y, width, height}
 * @return {Object} A new clipped rect. If rect size are negative, return undefined.
 */


function clipRectByRect(targetRect, rect) {
  var x = mathMax(targetRect.x, rect.x);
  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);
  var y = mathMax(targetRect.y, rect.y);
  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);

  if (x2 >= x && y2 >= y) {
    return {
      x: x,
      y: y,
      width: x2 - x,
      height: y2 - y
    };
  }
}
/**
 * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.
 * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.
 * @param {Object} [rect] {x, y, width, height}
 * @return {module:zrender/Element} Icon path or image element.
 */


function createIcon(iconStr, opt, rect) {
  opt = zrUtil.extend({
    rectHover: true
  }, opt);
  var style = opt.style = {
    strokeNoScale: true
  };
  rect = rect || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  };

  if (iconStr) {
    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), zrUtil.defaults(style, rect), new Image(opt)) : makePath(iconStr.replace('path://', ''), opt, rect, 'center');
  }
}

exports.extendShape = extendShape;
exports.extendPath = extendPath;
exports.makePath = makePath;
exports.makeImage = makeImage;
exports.mergePath = mergePath;
exports.resizePath = resizePath;
exports.subPixelOptimizeLine = subPixelOptimizeLine;
exports.subPixelOptimizeRect = subPixelOptimizeRect;
exports.subPixelOptimize = subPixelOptimize;
exports.setHoverStyle = setHoverStyle;
exports.setLabelStyle = setLabelStyle;
exports.setTextStyle = setTextStyle;
exports.setText = setText;
exports.getFont = getFont;
exports.updateProps = updateProps;
exports.initProps = initProps;
exports.getTransform = getTransform;
exports.applyTransform = applyTransform;
exports.transformDirection = transformDirection;
exports.groupTransition = groupTransition;
exports.clipPointsByRect = clipPointsByRect;
exports.clipRectByRect = clipRectByRect;
exports.createIcon = createIcon;

/***/ }),

/***/ "./node_modules/echarts/lib/util/layout.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var parsePercent = _number.parsePercent;

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

// Layout helpers for each component positioning
var each = zrUtil.each;
/**
 * @public
 */

var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];
/**
 * @public
 */

var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];

function boxLayout(orient, group, gap, maxWidth, maxHeight) {
  var x = 0;
  var y = 0;

  if (maxWidth == null) {
    maxWidth = Infinity;
  }

  if (maxHeight == null) {
    maxHeight = Infinity;
  }

  var currentLineMaxSize = 0;
  group.eachChild(function (child, idx) {
    var position = child.position;
    var rect = child.getBoundingRect();
    var nextChild = group.childAt(idx + 1);
    var nextChildRect = nextChild && nextChild.getBoundingRect();
    var nextX;
    var nextY;

    if (orient === 'horizontal') {
      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group
      // FIXME compare before adding gap?

      if (nextX > maxWidth || child.newline) {
        x = 0;
        nextX = moveX;
        y += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        // FIXME: consider rect.y is not `0`?
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group

      if (nextY > maxHeight || child.newline) {
        x += currentLineMaxSize + gap;
        y = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }

    if (child.newline) {
      return;
    }

    position[0] = x;
    position[1] = y;
    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;
  });
}
/**
 * VBox or HBox layouting
 * @param {string} orient
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */


var box = boxLayout;
/**
 * VBox layouting
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */

var vbox = zrUtil.curry(boxLayout, 'vertical');
/**
 * HBox layouting
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */

var hbox = zrUtil.curry(boxLayout, 'horizontal');
/**
 * If x or x2 is not specified or 'center' 'left' 'right',
 * the width would be as long as possible.
 * If y or y2 is not specified or 'middle' 'top' 'bottom',
 * the height would be as long as possible.
 *
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.x]
 * @param {number|string} [positionInfo.y]
 * @param {number|string} [positionInfo.x2]
 * @param {number|string} [positionInfo.y2]
 * @param {Object} containerRect {width, height}
 * @param {string|number} margin
 * @return {Object} {width, height}
 */

function getAvailableSize(positionInfo, containerRect, margin) {
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var x = parsePercent(positionInfo.x, containerWidth);
  var y = parsePercent(positionInfo.y, containerHeight);
  var x2 = parsePercent(positionInfo.x2, containerWidth);
  var y2 = parsePercent(positionInfo.y2, containerHeight);
  (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
  (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
  (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
  (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
  margin = formatUtil.normalizeCssArray(margin || 0);
  return {
    width: Math.max(x2 - x - margin[1] - margin[3], 0),
    height: Math.max(y2 - y - margin[0] - margin[2], 0)
  };
}
/**
 * Parse position info.
 *
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.left]
 * @param {number|string} [positionInfo.top]
 * @param {number|string} [positionInfo.right]
 * @param {number|string} [positionInfo.bottom]
 * @param {number|string} [positionInfo.width]
 * @param {number|string} [positionInfo.height]
 * @param {number|string} [positionInfo.aspect] Aspect is width / height
 * @param {Object} containerRect
 * @param {string|number} [margin]
 *
 * @return {module:zrender/core/BoundingRect}
 */


function getLayoutRect(positionInfo, containerRect, margin) {
  margin = formatUtil.normalizeCssArray(margin || 0);
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var left = parsePercent(positionInfo.left, containerWidth);
  var top = parsePercent(positionInfo.top, containerHeight);
  var right = parsePercent(positionInfo.right, containerWidth);
  var bottom = parsePercent(positionInfo.bottom, containerHeight);
  var width = parsePercent(positionInfo.width, containerWidth);
  var height = parsePercent(positionInfo.height, containerHeight);
  var verticalMargin = margin[2] + margin[0];
  var horizontalMargin = margin[1] + margin[3];
  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right

  if (isNaN(width)) {
    width = containerWidth - right - horizontalMargin - left;
  }

  if (isNaN(height)) {
    height = containerHeight - bottom - verticalMargin - top;
  }

  if (aspect != null) {
    // If width and height are not given
    // 1. Graph should not exceeds the container
    // 2. Aspect must be keeped
    // 3. Graph should take the space as more as possible
    // FIXME
    // Margin is not considered, because there is no case that both
    // using margin and aspect so far.
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    } // Calculate width or height with given aspect


    if (isNaN(width)) {
      width = aspect * height;
    }

    if (isNaN(height)) {
      height = width / aspect;
    }
  } // If left is not specified, calculate left from right and width


  if (isNaN(left)) {
    left = containerWidth - right - width - horizontalMargin;
  }

  if (isNaN(top)) {
    top = containerHeight - bottom - height - verticalMargin;
  } // Align left and top


  switch (positionInfo.left || positionInfo.right) {
    case 'center':
      left = containerWidth / 2 - width / 2 - margin[3];
      break;

    case 'right':
      left = containerWidth - width - horizontalMargin;
      break;
  }

  switch (positionInfo.top || positionInfo.bottom) {
    case 'middle':
    case 'center':
      top = containerHeight / 2 - height / 2 - margin[0];
      break;

    case 'bottom':
      top = containerHeight - height - verticalMargin;
      break;
  } // If something is wrong and left, top, width, height are calculated as NaN


  left = left || 0;
  top = top || 0;

  if (isNaN(width)) {
    // Width may be NaN if only one value is given except width
    width = containerWidth - horizontalMargin - left - (right || 0);
  }

  if (isNaN(height)) {
    // Height may be NaN if only one value is given except height
    height = containerHeight - verticalMargin - top - (bottom || 0);
  }

  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
/**
 * Position a zr element in viewport
 *  Group position is specified by either
 *  {left, top}, {right, bottom}
 *  If all properties exists, right and bottom will be igonred.
 *
 * Logic:
 *     1. Scale (against origin point in parent coord)
 *     2. Rotate (against origin point in parent coord)
 *     3. Traslate (with el.position by this method)
 * So this method only fixes the last step 'Traslate', which does not affect
 * scaling and rotating.
 *
 * If be called repeatly with the same input el, the same result will be gotten.
 *
 * @param {module:zrender/Element} el Should have `getBoundingRect` method.
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.left]
 * @param {number|string} [positionInfo.top]
 * @param {number|string} [positionInfo.right]
 * @param {number|string} [positionInfo.bottom]
 * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'
 * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'
 * @param {Object} containerRect
 * @param {string|number} margin
 * @param {Object} [opt]
 * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.
 * @param {Array.<number>} [opt.boundingMode='all']
 *        Specify how to calculate boundingRect when locating.
 *        'all': Position the boundingRect that is transformed and uioned
 *               both itself and its descendants.
 *               This mode simplies confine the elements in the bounding
 *               of their container (e.g., using 'right: 0').
 *        'raw': Position the boundingRect that is not transformed and only itself.
 *               This mode is useful when you want a element can overflow its
 *               container. (Consider a rotated circle needs to be located in a corner.)
 *               In this mode positionInfo.width/height can only be number.
 */


function positionElement(el, positionInfo, containerRect, margin, opt) {
  var h = !opt || !opt.hv || opt.hv[0];
  var v = !opt || !opt.hv || opt.hv[1];
  var boundingMode = opt && opt.boundingMode || 'all';

  if (!h && !v) {
    return;
  }

  var rect;

  if (boundingMode === 'raw') {
    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
  } else {
    rect = el.getBoundingRect();

    if (el.needLocalTransform()) {
      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,
      // which should not be modified.

      rect = rect.clone();
      rect.applyTransform(transform);
    }
  } // The real width and height can not be specified but calculated by the given el.


  positionInfo = getLayoutRect(zrUtil.defaults({
    width: rect.width,
    height: rect.height
  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform
  // (see zrender/core/Transformable#getLocalTransfrom),
  // we can just only modify el.position to get final result.

  var elPos = el.position;
  var dx = h ? positionInfo.x - rect.x : 0;
  var dy = v ? positionInfo.y - rect.y : 0;
  el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
}
/**
 * @param {Object} option Contains some of the properties in HV_NAMES.
 * @param {number} hvIdx 0: horizontal; 1: vertical.
 */


function sizeCalculable(option, hvIdx) {
  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
/**
 * Consider Case:
 * When defulat option has {left: 0, width: 100}, and we set {right: 0}
 * through setOption or media query, using normal zrUtil.merge will cause
 * {right: 0} does not take effect.
 *
 * @example
 * ComponentModel.extend({
 *     init: function () {
 *         ...
 *         var inputPositionParams = layout.getLayoutParams(option);
 *         this.mergeOption(inputPositionParams);
 *     },
 *     mergeOption: function (newOption) {
 *         newOption && zrUtil.merge(thisOption, newOption, true);
 *         layout.mergeLayoutParam(thisOption, newOption);
 *     }
 * });
 *
 * @param {Object} targetOption
 * @param {Object} newOption
 * @param {Object|string} [opt]
 * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components
 *  that width (or height) should not be calculated by left and right (or top and bottom).
 */


function mergeLayoutParam(targetOption, newOption, opt) {
  !zrUtil.isObject(opt) && (opt = {});
  var ignoreSize = opt.ignoreSize;
  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  var hResult = merge(HV_NAMES[0], 0);
  var vResult = merge(HV_NAMES[1], 1);
  copy(HV_NAMES[0], targetOption, hResult);
  copy(HV_NAMES[1], targetOption, vResult);

  function merge(names, hvIdx) {
    var newParams = {};
    var newValueCount = 0;
    var merged = {};
    var mergedValueCount = 0;
    var enoughParamNumber = 2;
    each(names, function (name) {
      merged[name] = targetOption[name];
    });
    each(names, function (name) {
      // Consider case: newOption.width is null, which is
      // set by user for removing width setting.
      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
      hasValue(newParams, name) && newValueCount++;
      hasValue(merged, name) && mergedValueCount++;
    });

    if (ignoreSize[hvIdx]) {
      // Only one of left/right is premitted to exist.
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }

      return merged;
    } // Case: newOption: {width: ..., right: ...},
    // or targetOption: {right: ...} and newOption: {width: ...},
    // There is no conflict when merged only has params count
    // little than enoughParamNumber.


    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } // Case: newOption: {width: ..., right: ...},
    // Than we can make sure user only want those two, and ignore
    // all origin params in targetOption.
    else if (newValueCount >= enoughParamNumber) {
        return newParams;
      } else {
        // Chose another param from targetOption by priority.
        for (var i = 0; i < names.length; i++) {
          var name = names[i];

          if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
            newParams[name] = targetOption[name];
            break;
          }
        }

        return newParams;
      }
  }

  function hasProp(obj, name) {
    return obj.hasOwnProperty(name);
  }

  function hasValue(obj, name) {
    return obj[name] != null && obj[name] !== 'auto';
  }

  function copy(names, target, source) {
    each(names, function (name) {
      target[name] = source[name];
    });
  }
}
/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 * @param {Object} source
 * @return {Object} Result contains those props.
 */


function getLayoutParams(source) {
  return copyLayoutParams({}, source);
}
/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 * @param {Object} source
 * @return {Object} Result contains those props.
 */


function copyLayoutParams(target, source) {
  source && target && each(LOCATION_PARAMS, function (name) {
    source.hasOwnProperty(name) && (target[name] = source[name]);
  });
  return target;
}

exports.LOCATION_PARAMS = LOCATION_PARAMS;
exports.HV_NAMES = HV_NAMES;
exports.box = box;
exports.vbox = vbox;
exports.hbox = hbox;
exports.getAvailableSize = getAvailableSize;
exports.getLayoutRect = getLayoutRect;
exports.positionElement = positionElement;
exports.sizeCalculable = sizeCalculable;
exports.mergeLayoutParam = mergeLayoutParam;
exports.getLayoutParams = getLayoutParams;
exports.copyLayoutParams = copyLayoutParams;

/***/ }),

/***/ "./node_modules/echarts/lib/util/model.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var nubmerUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var each = zrUtil.each;
var isObject = zrUtil.isObject;
/**
 * If value is not array, then translate it to array.
 * @param  {*} value
 * @return {Array} [value] or value
 */

function normalizeToArray(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
/**
 * Sync default option between normal and emphasis like `position` and `show`
 * In case some one will write code like
 *     label: {
 *         normal: {
 *             show: false,
 *             position: 'outside',
 *             fontSize: 18
 *         },
 *         emphasis: {
 *             show: true
 *         }
 *     }
 * @param {Object} opt
 * @param {Array.<string>} subOpts
 */


function defaultEmphasis(opt, subOpts) {
  if (opt) {
    var emphasisOpt = opt.emphasis = opt.emphasis || {};
    var normalOpt = opt.normal = opt.normal || {}; // Default emphasis option from normal

    for (var i = 0, len = subOpts.length; i < len; i++) {
      var subOptName = subOpts[i];

      if (!emphasisOpt.hasOwnProperty(subOptName) && normalOpt.hasOwnProperty(subOptName)) {
        emphasisOpt[subOptName] = normalOpt[subOptName];
      }
    }
  }
}

var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([
//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',
//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',
//     // FIXME: deprecated, check and remove it.
//     'textStyle'
// ]);

/**
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method retieves value from data.
 * @param {string|number|Date|Array|Object} dataItem
 * @return {number|string|Date|Array.<number|string|Date>}
 */

function getDataItemValue(dataItem) {
  // Performance sensitive.
  return dataItem && (dataItem.value == null ? dataItem : dataItem.value);
}
/**
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method determine if dataItem has extra option besides value
 * @param {string|number|Date|Array|Object} dataItem
 */


function isDataItemOption(dataItem) {
  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array
  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
}
/**
 * This helper method convert value in data.
 * @param {string|number|Date} value
 * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.
 */


function converDataValue(value, dimInfo) {
  // Performance sensitive.
  var dimType = dimInfo && dimInfo.type;

  if (dimType === 'ordinal') {
    return value;
  }

  if (dimType === 'time' // spead up when using timestamp
  && typeof value !== 'number' && value != null && value !== '-') {
    value = +nubmerUtil.parseDate(value);
  } // dimType defaults 'number'.
  // If dimType is not ordinal and value is null or undefined or NaN or '-',
  // parse to NaN.


  return value == null || value === '' ? NaN : +value; // If string (like '-'), using '+' parse to NaN
}
/**
 * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.
 * @param {module:echarts/data/List} data
 * @param {Object} opt
 * @param {string} [opt.seriesIndex]
 * @param {Object} [opt.name]
 * @param {Object} [opt.mainType]
 * @param {Object} [opt.subType]
 */


function createDataFormatModel(data, opt) {
  var model = new Model();
  zrUtil.mixin(model, dataFormatMixin);
  model.seriesIndex = opt.seriesIndex;
  model.name = opt.name || '';
  model.mainType = opt.mainType;
  model.subType = opt.subType;

  model.getData = function () {
    return data;
  };

  return model;
} // PENDING A little ugly


var dataFormatMixin = {
  /**
   * Get params for formatter
   * @param {number} dataIndex
   * @param {string} [dataType]
   * @return {Object}
   */
  getDataParams: function (dataIndex, dataType) {
    var data = this.getData(dataType);
    var rawValue = this.getRawValue(dataIndex, dataType);
    var rawDataIndex = data.getRawIndex(dataIndex);
    var name = data.getName(dataIndex, true);
    var itemOpt = data.getRawDataItem(dataIndex);
    var color = data.getItemVisual(dataIndex, 'color');
    return {
      componentType: this.mainType,
      componentSubType: this.subType,
      seriesType: this.mainType === 'series' ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: this.id,
      seriesName: this.name,
      name: name,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType: dataType,
      value: rawValue,
      color: color,
      marker: formatUtil.getTooltipMarker(color),
      // Param name list for mapping `a`, `b`, `c`, `d`, `e`
      $vars: ['seriesName', 'name', 'value']
    };
  },

  /**
   * Format label
   * @param {number} dataIndex
   * @param {string} [status='normal'] 'normal' or 'emphasis'
   * @param {string} [dataType]
   * @param {number} [dimIndex]
   * @param {string} [labelProp='label']
   * @return {string}
   */
  getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {
    status = status || 'normal';
    var data = this.getData(dataType);
    var itemModel = data.getItemModel(dataIndex);
    var params = this.getDataParams(dataIndex, dataType);

    if (dimIndex != null && params.value instanceof Array) {
      params.value = params.value[dimIndex];
    }

    var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);

    if (typeof formatter === 'function') {
      params.status = status;
      return formatter(params);
    } else if (typeof formatter === 'string') {
      return formatUtil.formatTpl(formatter, params);
    }
  },

  /**
   * Get raw value in option
   * @param {number} idx
   * @param {string} [dataType]
   * @return {Object}
   */
  getRawValue: function (idx, dataType) {
    var data = this.getData(dataType);
    var dataItem = data.getRawDataItem(idx);

    if (dataItem != null) {
      return isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;
    }
  },

  /**
   * Should be implemented.
   * @param {number} dataIndex
   * @param {boolean} [multipleSeries=false]
   * @param {number} [dataType]
   * @return {string} tooltip string
   */
  formatTooltip: zrUtil.noop
};
/**
 * Mapping to exists for merge.
 *
 * @public
 * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists
 * @param {Object|Array.<Object>} newCptOptions
 * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
 *                          index of which is the same as exists.
 */

function mappingToExists(exists, newCptOptions) {
  // Mapping by the order by original option (but not order of
  // new option) in merge mode. Because we should ensure
  // some specified index (like xAxisIndex) is consistent with
  // original option, which is easy to understand, espatially in
  // media query. And in most case, merge option is used to
  // update partial option but not be expected to change order.
  newCptOptions = (newCptOptions || []).slice();
  var result = zrUtil.map(exists || [], function (obj, index) {
    return {
      exist: obj
    };
  }); // Mapping by id or name if specified.

  each(newCptOptions, function (cptOption, index) {
    if (!isObject(cptOption)) {
      return;
    } // id has highest priority.


    for (var i = 0; i < result.length; i++) {
      if (!result[i].option // Consider name: two map to one.
      && cptOption.id != null && result[i].exist.id === cptOption.id + '') {
        result[i].option = cptOption;
        newCptOptions[index] = null;
        return;
      }
    }

    for (var i = 0; i < result.length; i++) {
      var exist = result[i].exist;

      if (!result[i].option // Consider name: two map to one.
      // Can not match when both ids exist but different.
      && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {
        result[i].option = cptOption;
        newCptOptions[index] = null;
        return;
      }
    }
  }); // Otherwise mapping by index.

  each(newCptOptions, function (cptOption, index) {
    if (!isObject(cptOption)) {
      return;
    }

    var i = 0;

    for (; i < result.length; i++) {
      var exist = result[i].exist;

      if (!result[i].option // Existing model that already has id should be able to
      // mapped to (because after mapping performed model may
      // be assigned with a id, whish should not affect next
      // mapping), except those has inner id.
      && !isIdInner(exist) // Caution:
      // Do not overwrite id. But name can be overwritten,
      // because axis use name as 'show label text'.
      // 'exist' always has id and name and we dont
      // need to check it.
      && cptOption.id == null) {
        result[i].option = cptOption;
        break;
      }
    }

    if (i >= result.length) {
      result.push({
        option: cptOption
      });
    }
  });
  return result;
}
/**
 * Make id and name for mapping result (result of mappingToExists)
 * into `keyInfo` field.
 *
 * @public
 * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
 *                          which order is the same as exists.
 * @return {Array.<Object>} The input.
 */


function makeIdAndName(mapResult) {
  // We use this id to hash component models and view instances
  // in echarts. id can be specified by user, or auto generated.
  // The id generation rule ensures new view instance are able
  // to mapped to old instance when setOption are called in
  // no-merge mode. So we generate model id by name and plus
  // type in view id.
  // name can be duplicated among components, which is convenient
  // to specify multi components (like series) by one name.
  // Ensure that each id is distinct.
  var idMap = zrUtil.createHashMap();
  each(mapResult, function (item, index) {
    var existCpt = item.exist;
    existCpt && idMap.set(existCpt.id, item);
  });
  each(mapResult, function (item, index) {
    var opt = item.option;
    zrUtil.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  }); // Make name and id.

  each(mapResult, function (item, index) {
    var existCpt = item.exist;
    var opt = item.option;
    var keyInfo = item.keyInfo;

    if (!isObject(opt)) {
      return;
    } // name can be overwitten. Consider case: axis.name = '20km'.
    // But id generated by name will not be changed, which affect
    // only in that case: setOption with 'not merge mode' and view
    // instance will be recreated, which can be accepted.


    keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\0-'; // name may be displayed on screen, so use '-'.

    if (existCpt) {
      keyInfo.id = existCpt.id;
    } else if (opt.id != null) {
      keyInfo.id = opt.id + '';
    } else {
      // Consider this situatoin:
      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]
      //  optionB [{..}, {name: 'a'}, {name: 'a'}]
      // Series with the same name between optionA and optionB
      // should be mapped.
      var idNum = 0;

      do {
        keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
      } while (idMap.get(keyInfo.id));
    }

    idMap.set(keyInfo.id, item);
  });
}
/**
 * @public
 * @param {Object} cptOption
 * @return {boolean}
 */


function isIdInner(cptOption) {
  return isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\0_ec_\0') === 0;
}
/**
 * A helper for removing duplicate items between batchA and batchB,
 * and in themselves, and categorize by series.
 *
 * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]
 */


function compressBatches(batchA, batchB) {
  var mapA = {};
  var mapB = {};
  makeMap(batchA || [], mapA);
  makeMap(batchB || [], mapB, mapA);
  return [mapToArray(mapA), mapToArray(mapB)];

  function makeMap(sourceBatch, map, otherMap) {
    for (var i = 0, len = sourceBatch.length; i < len; i++) {
      var seriesId = sourceBatch[i].seriesId;
      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
      var otherDataIndices = otherMap && otherMap[seriesId];

      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
        var dataIndex = dataIndices[j];

        if (otherDataIndices && otherDataIndices[dataIndex]) {
          otherDataIndices[dataIndex] = null;
        } else {
          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
        }
      }
    }
  }

  function mapToArray(map, isData) {
    var result = [];

    for (var i in map) {
      if (map.hasOwnProperty(i) && map[i] != null) {
        if (isData) {
          result.push(+i);
        } else {
          var dataIndices = mapToArray(map[i], true);
          dataIndices.length && result.push({
            seriesId: i,
            dataIndex: dataIndices
          });
        }
      }
    }

    return result;
  }
}
/**
 * @param {module:echarts/data/List} data
 * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name
 *                         each of which can be Array or primary type.
 * @return {number|Array.<number>} dataIndex If not found, return undefined/null.
 */


function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function (value) {
      return data.indexOfRawIndex(value);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function (value) {
      return data.indexOfName(value);
    }) : data.indexOfName(payload.name);
  }
}
/**
 * Enable property storage to any host object.
 * Notice: Serialization is not supported.
 *
 * For example:
 * var get = modelUitl.makeGetter();
 *
 * function some(hostObj) {
 *      get(hostObj)._someProperty = 1212;
 *      ...
 * }
 *
 * @return {Function}
 */


var makeGetter = function () {
  var index = 0;
  return function () {
    var key = '\0__ec_prop_getter_' + index++;
    return function (hostObj) {
      return hostObj[key] || (hostObj[key] = {});
    };
  };
}();
/**
 * @param {module:echarts/model/Global} ecModel
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex, seriesId, seriesName,
 *            geoIndex, geoId, geoName,
 *            bmapIndex, bmapId, bmapName,
 *            xAxisIndex, xAxisId, xAxisName,
 *            yAxisIndex, yAxisId, yAxisName,
 *            gridIndex, gridId, gridName,
 *            ... (can be extended)
 *        }
 *        Each properties can be number|string|Array.<number>|Array.<string>
 *        For example, a finder could be
 *        {
 *            seriesIndex: 3,
 *            geoId: ['aa', 'cc'],
 *            gridName: ['xx', 'rr']
 *        }
 *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)
 *        If nothing or null/undefined specified, return nothing.
 * @param {Object} [opt]
 * @param {string} [opt.defaultMainType]
 * @param {Array.<string>} [opt.includeMainTypes]
 * @return {Object} result like:
 *        {
 *            seriesModels: [seriesModel1, seriesModel2],
 *            seriesModel: seriesModel1, // The first model
 *            geoModels: [geoModel1, geoModel2],
 *            geoModel: geoModel1, // The first model
 *            ...
 *        }
 */


function parseFinder(ecModel, finder, opt) {
  if (zrUtil.isString(finder)) {
    var obj = {};
    obj[finder + 'Index'] = 0;
    finder = obj;
  }

  var defaultMainType = opt && opt.defaultMainType;

  if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name')) {
    finder[defaultMainType + 'Index'] = 0;
  }

  var result = {};
  each(finder, function (value, key) {
    var value = finder[key]; // Exclude 'dataIndex' and other illgal keys.

    if (key === 'dataIndex' || key === 'dataIndexInside') {
      result[key] = value;
      return;
    }

    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    var mainType = parsedKey[1];
    var queryType = (parsedKey[2] || '').toLowerCase();

    if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) {
      return;
    }

    var queryParam = {
      mainType: mainType
    };

    if (queryType !== 'index' || value !== 'all') {
      queryParam[queryType] = value;
    }

    var models = ecModel.queryComponents(queryParam);
    result[mainType + 'Models'] = models;
    result[mainType + 'Model'] = models[0];
  });
  return result;
}
/**
 * @see {module:echarts/data/helper/completeDimensions}
 * @param {module:echarts/data/List} data
 * @param {string|number} dataDim
 * @return {string}
 */


function dataDimToCoordDim(data, dataDim) {
  var dimensions = data.dimensions;
  dataDim = data.getDimension(dataDim);

  for (var i = 0; i < dimensions.length; i++) {
    var dimItem = data.getDimensionInfo(dimensions[i]);

    if (dimItem.name === dataDim) {
      return dimItem.coordDim;
    }
  }
}
/**
 * @see {module:echarts/data/helper/completeDimensions}
 * @param {module:echarts/data/List} data
 * @param {string} coordDim
 * @return {Array.<string>} data dimensions on the coordDim.
 */


function coordDimToDataDim(data, coordDim) {
  var dataDim = [];
  each(data.dimensions, function (dimName) {
    var dimItem = data.getDimensionInfo(dimName);

    if (dimItem.coordDim === coordDim) {
      dataDim[dimItem.coordDimIndex] = dimItem.name;
    }
  });
  return dataDim;
}
/**
 * @see {module:echarts/data/helper/completeDimensions}
 * @param {module:echarts/data/List} data
 * @param {string} otherDim Can be `otherDims`
 *                        like 'label' or 'tooltip'.
 * @return {Array.<string>} data dimensions on the otherDim.
 */


function otherDimToDataDim(data, otherDim) {
  var dataDim = [];
  each(data.dimensions, function (dimName) {
    var dimItem = data.getDimensionInfo(dimName);
    var otherDims = dimItem.otherDims;
    var dimIndex = otherDims[otherDim];

    if (dimIndex != null && dimIndex !== false) {
      dataDim[dimIndex] = dimItem.name;
    }
  });
  return dataDim;
}

function has(obj, prop) {
  return obj && obj.hasOwnProperty(prop);
}

exports.normalizeToArray = normalizeToArray;
exports.defaultEmphasis = defaultEmphasis;
exports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;
exports.getDataItemValue = getDataItemValue;
exports.isDataItemOption = isDataItemOption;
exports.converDataValue = converDataValue;
exports.createDataFormatModel = createDataFormatModel;
exports.dataFormatMixin = dataFormatMixin;
exports.mappingToExists = mappingToExists;
exports.makeIdAndName = makeIdAndName;
exports.isIdInner = isIdInner;
exports.compressBatches = compressBatches;
exports.queryDataIndex = queryDataIndex;
exports.makeGetter = makeGetter;
exports.parseFinder = parseFinder;
exports.dataDimToCoordDim = dataDimToCoordDim;
exports.coordDimToDataDim = coordDimToDataDim;
exports.otherDimToDataDim = otherDimToDataDim;

/***/ }),

/***/ "./node_modules/echarts/lib/util/number.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var RADIAN_EPSILON = 1e-4;

function _trim(str) {
  return str.replace(/^\s+/, '').replace(/\s+$/, '');
}
/**
 * Linear mapping a value from domain to range
 * @memberOf module:echarts/util/number
 * @param  {(number|Array.<number>)} val
 * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]
 * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]
 * @param  {boolean} clamp
 * @return {(number|Array.<number>}
 */


function linearMap(val, domain, range, clamp) {
  var subDomain = domain[1] - domain[0];
  var subRange = range[1] - range[0];

  if (subDomain === 0) {
    return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
  } // Avoid accuracy problem in edge, such as
  // 146.39 - 62.83 === 83.55999999999999.
  // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
  // It is a little verbose for efficiency considering this method
  // is a hotspot.


  if (clamp) {
    if (subDomain > 0) {
      if (val <= domain[0]) {
        return range[0];
      } else if (val >= domain[1]) {
        return range[1];
      }
    } else {
      if (val >= domain[0]) {
        return range[0];
      } else if (val <= domain[1]) {
        return range[1];
      }
    }
  } else {
    if (val === domain[0]) {
      return range[0];
    }

    if (val === domain[1]) {
      return range[1];
    }
  }

  return (val - domain[0]) / subDomain * subRange + range[0];
}
/**
 * Convert a percent string to absolute number.
 * Returns NaN if percent is not a valid string or number
 * @memberOf module:echarts/util/number
 * @param {string|number} percent
 * @param {number} all
 * @return {number}
 */


function parsePercent(percent, all) {
  switch (percent) {
    case 'center':
    case 'middle':
      percent = '50%';
      break;

    case 'left':
    case 'top':
      percent = '0%';
      break;

    case 'right':
    case 'bottom':
      percent = '100%';
      break;
  }

  if (typeof percent === 'string') {
    if (_trim(percent).match(/%$/)) {
      return parseFloat(percent) / 100 * all;
    }

    return parseFloat(percent);
  }

  return percent == null ? NaN : +percent;
}
/**
 * (1) Fix rounding error of float numbers.
 * (2) Support return string to avoid scientific notation like '3.5e-7'.
 *
 * @param {number} x
 * @param {number} [precision]
 * @param {boolean} [returnStr]
 * @return {number|string}
 */


function round(x, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  } // Avoid range error


  precision = Math.min(Math.max(0, precision), 20);
  x = (+x).toFixed(precision);
  return returnStr ? x : +x;
}

function asc(arr) {
  arr.sort(function (a, b) {
    return a - b;
  });
  return arr;
}
/**
 * Get precision
 * @param {number} val
 */


function getPrecision(val) {
  val = +val;

  if (isNaN(val)) {
    return 0;
  } // It is much faster than methods converting number to string as follows
  //      var tmp = val.toString();
  //      return tmp.length - 1 - tmp.indexOf('.');
  // especially when precision is low


  var e = 1;
  var count = 0;

  while (Math.round(val * e) / e !== val) {
    e *= 10;
    count++;
  }

  return count;
}
/**
 * @param {string|number} val
 * @return {number}
 */


function getPrecisionSafe(val) {
  var str = val.toString(); // Consider scientific notation: '3.4e-12' '3.4e+12'

  var eIndex = str.indexOf('e');

  if (eIndex > 0) {
    var precision = +str.slice(eIndex + 1);
    return precision < 0 ? -precision : 0;
  } else {
    var dotIndex = str.indexOf('.');
    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
  }
}
/**
 * Minimal dicernible data precisioin according to a single pixel.
 *
 * @param {Array.<number>} dataExtent
 * @param {Array.<number>} pixelExtent
 * @return {number} precision
 */


function getPixelPrecision(dataExtent, pixelExtent) {
  var log = Math.log;
  var LN10 = Math.LN10;
  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20.

  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
/**
 * Get a data of given precision, assuring the sum of percentages
 * in valueList is 1.
 * The largest remainer method is used.
 * https://en.wikipedia.org/wiki/Largest_remainder_method
 *
 * @param {Array.<number>} valueList a list of all data
 * @param {number} idx index of the data to be processed in valueList
 * @param {number} precision integer number showing digits of precision
 * @return {number} percent ranging from 0 to 100
 */


function getPercentWithPrecision(valueList, idx, precision) {
  if (!valueList[idx]) {
    return 0;
  }

  var sum = zrUtil.reduce(valueList, function (acc, val) {
    return acc + (isNaN(val) ? 0 : val);
  }, 0);

  if (sum === 0) {
    return 0;
  }

  var digits = Math.pow(10, precision);
  var votesPerQuota = zrUtil.map(valueList, function (val) {
    return (isNaN(val) ? 0 : val) / sum * digits * 100;
  });
  var targetSeats = digits * 100;
  var seats = zrUtil.map(votesPerQuota, function (votes) {
    // Assign automatic seats.
    return Math.floor(votes);
  });
  var currentSum = zrUtil.reduce(seats, function (acc, val) {
    return acc + val;
  }, 0);
  var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {
    return votes - seats[idx];
  }); // Has remainding votes.

  while (currentSum < targetSeats) {
    // Find next largest remainder.
    var max = Number.NEGATIVE_INFINITY;
    var maxId = null;

    for (var i = 0, len = remainder.length; i < len; ++i) {
      if (remainder[i] > max) {
        max = remainder[i];
        maxId = i;
      }
    } // Add a vote to max remainder.


    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }

  return seats[idx] / digits;
} // Number.MAX_SAFE_INTEGER, ie do not support.


var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * To 0 - 2 * PI, considering negative radian.
 * @param {number} radian
 * @return {number}
 */

function remRadian(radian) {
  var pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
/**
 * @param {type} radian
 * @return {boolean}
 */


function isRadianAroundZero(val) {
  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}

var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; // jshint ignore:line

/**
 * @param {string|Date|number} value These values can be accepted:
 *   + An instance of Date, represent a time in its own time zone.
 *   + Or string in a subset of ISO 8601, only including:
 *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
 *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
 *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
 *     all of which will be treated as local time if time zone is not specified
 *     (see <https://momentjs.com/>).
 *   + Or other string format, including (all of which will be treated as loacal time):
 *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
 *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
 *   + a timestamp, which represent a time in UTC.
 * @return {Date} date
 */

function parseDate(value) {
  if (value instanceof Date) {
    return value;
  } else if (typeof value === 'string') {
    // Different browsers parse date in different way, so we parse it manually.
    // Some other issues:
    // new Date('1970-01-01') is UTC,
    // new Date('1970/01/01') and new Date('1970-1-01') is local.
    // See issue #3623
    var match = TIME_REG.exec(value);

    if (!match) {
      // return Invalid Date.
      return new Date(NaN);
    } // Use local time when no timezone offset specifed.


    if (!match[8]) {
      // match[n] can only be string or undefined.
      // But take care of '12' + 1 => '121'.
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
    } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,
    // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).
    // For example, system timezone is set as "Time Zone: America/Toronto",
    // then these code will get different result:
    // `new Date(1478411999999).getTimezoneOffset();  // get 240`
    // `new Date(1478412000000).getTimezoneOffset();  // get 300`
    // So we should not use `new Date`, but use `Date.UTC`.
    else {
        var hour = +match[4] || 0;

        if (match[8].toUpperCase() !== 'Z') {
          hour -= match[8].slice(0, 3);
        }

        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
      }
  } else if (value == null) {
    return new Date(NaN);
  }

  return new Date(Math.round(value));
}
/**
 * Quantity of a number. e.g. 0.1, 1, 10, 100
 *
 * @param  {number} val
 * @return {number}
 */


function quantity(val) {
  return Math.pow(10, quantityExponent(val));
}

function quantityExponent(val) {
  return Math.floor(Math.log(val) / Math.LN10);
}
/**
 * find a “nice” number approximately equal to x. Round the number if round = true,
 * take ceiling if round = false. The primary observation is that the “nicest”
 * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
 *
 * See "Nice Numbers for Graph Labels" of Graphic Gems.
 *
 * @param  {number} val Non-negative value.
 * @param  {boolean} round
 * @return {number}
 */


function nice(val, round) {
  var exponent = quantityExponent(val);
  var exp10 = Math.pow(10, exponent);
  var f = val / exp10; // 1 <= f < 10

  var nf;

  if (round) {
    if (f < 1.5) {
      nf = 1;
    } else if (f < 2.5) {
      nf = 2;
    } else if (f < 4) {
      nf = 3;
    } else if (f < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f < 1) {
      nf = 1;
    } else if (f < 2) {
      nf = 2;
    } else if (f < 3) {
      nf = 3;
    } else if (f < 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }

  val = nf * exp10; // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).
  // 20 is the uppper bound of toFixed.

  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
/**
 * Order intervals asc, and split them when overlap.
 * expect(numberUtil.reformIntervals([
 *     {interval: [18, 62], close: [1, 1]},
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [1, 1]},
 *     {interval: [62, 150], close: [1, 1]},
 *     {interval: [106, 150], close: [1, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ])).toEqual([
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [0, 1]},
 *     {interval: [18, 62], close: [0, 1]},
 *     {interval: [62, 150], close: [0, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ]);
 * @param {Array.<Object>} list, where `close` mean open or close
 *        of the interval, and Infinity can be used.
 * @return {Array.<Object>} The origin list, which has been reformed.
 */


function reformIntervals(list) {
  list.sort(function (a, b) {
    return littleThan(a, b, 0) ? -1 : 1;
  });
  var curr = -Infinity;
  var currClose = 1;

  for (var i = 0; i < list.length;) {
    var interval = list[i].interval;
    var close = list[i].close;

    for (var lg = 0; lg < 2; lg++) {
      if (interval[lg] <= curr) {
        interval[lg] = curr;
        close[lg] = !lg ? 1 - currClose : 1;
      }

      curr = interval[lg];
      currClose = close[lg];
    }

    if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
      list.splice(i, 1);
    } else {
      i++;
    }
  }

  return list;

  function littleThan(a, b, lg) {
    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));
  }
}
/**
 * parseFloat NaNs numeric-cast false positives (null|true|false|"")
 * ...but misinterprets leading-number strings, particularly hex literals ("0x...")
 * subtraction forces infinities to NaN
 *
 * @param {*} v
 * @return {boolean}
 */


function isNumeric(v) {
  return v - parseFloat(v) >= 0;
}

exports.linearMap = linearMap;
exports.parsePercent = parsePercent;
exports.round = round;
exports.asc = asc;
exports.getPrecision = getPrecision;
exports.getPrecisionSafe = getPrecisionSafe;
exports.getPixelPrecision = getPixelPrecision;
exports.getPercentWithPrecision = getPercentWithPrecision;
exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
exports.remRadian = remRadian;
exports.isRadianAroundZero = isRadianAroundZero;
exports.parseDate = parseDate;
exports.quantity = quantity;
exports.nice = nice;
exports.reformIntervals = reformIntervals;
exports.isNumeric = isNumeric;

/***/ }),

/***/ "./node_modules/echarts/lib/util/symbol.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

// Symbol factory

/**
 * Triangle shape
 * @inner
 */
var Triangle = graphic.extendShape({
  type: 'triangle',
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy + height);
    path.lineTo(cx - width, cy + height);
    path.closePath();
  }
});
/**
 * Diamond shape
 * @inner
 */

var Diamond = graphic.extendShape({
  type: 'diamond',
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy);
    path.lineTo(cx, cy + height);
    path.lineTo(cx - width, cy);
    path.closePath();
  }
});
/**
 * Pin shape
 * @inner
 */

var Pin = graphic.extendShape({
  type: 'pin',
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var x = shape.x;
    var y = shape.y;
    var w = shape.width / 5 * 3; // Height must be larger than width

    var h = Math.max(w, shape.height);
    var r = w / 2; // Dist on y with tangent point and circle center

    var dy = r * r / (h - r);
    var cy = y - h + r + dy;
    var angle = Math.asin(dy / r); // Dist on x with tangent point and circle center

    var dx = Math.cos(angle) * r;
    var tanX = Math.sin(angle);
    var tanY = Math.cos(angle);
    var cpLen = r * 0.6;
    var cpLen2 = r * 0.7;
    path.moveTo(x - dx, cy + dy);
    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
    path.closePath();
  }
});
/**
 * Arrow shape
 * @inner
 */

var Arrow = graphic.extendShape({
  type: 'arrow',
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (ctx, shape) {
    var height = shape.height;
    var width = shape.width;
    var x = shape.x;
    var y = shape.y;
    var dx = width / 3 * 2;
    ctx.moveTo(x, y);
    ctx.lineTo(x + dx, y + height);
    ctx.lineTo(x, y + height / 4 * 3);
    ctx.lineTo(x - dx, y + height);
    ctx.lineTo(x, y);
    ctx.closePath();
  }
});
/**
 * Map of path contructors
 * @type {Object.<string, module:zrender/graphic/Path>}
 */

var symbolCtors = {
  line: graphic.Line,
  rect: graphic.Rect,
  roundRect: graphic.Rect,
  square: graphic.Rect,
  circle: graphic.Circle,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
};
var symbolShapeMakers = {
  line: function (x, y, w, h, shape) {
    // FIXME
    shape.x1 = x;
    shape.y1 = y + h / 2;
    shape.x2 = x + w;
    shape.y2 = y + h / 2;
  },
  rect: function (x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
  },
  roundRect: function (x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
    shape.r = Math.min(w, h) / 4;
  },
  square: function (x, y, w, h, shape) {
    var size = Math.min(w, h);
    shape.x = x;
    shape.y = y;
    shape.width = size;
    shape.height = size;
  },
  circle: function (x, y, w, h, shape) {
    // Put circle in the center of square
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.r = Math.min(w, h) / 2;
  },
  diamond: function (x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  pin: function (x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  arrow: function (x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  triangle: function (x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  }
};
var symbolBuildProxies = {};
zrUtil.each(symbolCtors, function (Ctor, name) {
  symbolBuildProxies[name] = new Ctor();
});
var SymbolClz = graphic.extendShape({
  type: 'symbol',
  shape: {
    symbolType: '',
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  beforeBrush: function () {
    var style = this.style;
    var shape = this.shape; // FIXME

    if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
      style.textPosition = ['50%', '40%'];
      style.textAlign = 'center';
      style.textVerticalAlign = 'middle';
    }
  },
  buildPath: function (ctx, shape, inBundle) {
    var symbolType = shape.symbolType;
    var proxySymbol = symbolBuildProxies[symbolType];

    if (shape.symbolType !== 'none') {
      if (!proxySymbol) {
        // Default rect
        symbolType = 'rect';
        proxySymbol = symbolBuildProxies[symbolType];
      }

      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
}); // Provide setColor helper method to avoid determine if set the fill or stroke outside

function symbolPathSetColor(color, innerColor) {
  if (this.type !== 'image') {
    var symbolStyle = this.style;
    var symbolShape = this.shape;

    if (symbolShape && symbolShape.symbolType === 'line') {
      symbolStyle.stroke = color;
    } else if (this.__isEmptyBrush) {
      symbolStyle.stroke = color;
      symbolStyle.fill = innerColor || '#fff';
    } else {
      // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
      symbolStyle.fill && (symbolStyle.fill = color);
      symbolStyle.stroke && (symbolStyle.stroke = color);
    }

    this.dirty(false);
  }
}
/**
 * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
 * @param {string} symbolType
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {string} color
 * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,
 *                            for path and image only.
 */


function createSymbol(symbolType, x, y, w, h, color, keepAspect) {
  // TODO Support image object, DynamicImage.
  var isEmpty = symbolType.indexOf('empty') === 0;

  if (isEmpty) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }

  var symbolPath;

  if (symbolType.indexOf('image://') === 0) {
    symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');
  } else if (symbolType.indexOf('path://') === 0) {
    symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');
  } else {
    symbolPath = new SymbolClz({
      shape: {
        symbolType: symbolType,
        x: x,
        y: y,
        width: w,
        height: h
      }
    });
  }

  symbolPath.__isEmptyBrush = isEmpty;
  symbolPath.setColor = symbolPathSetColor;
  symbolPath.setColor(color);
  return symbolPath;
}

exports.createSymbol = createSymbol;

/***/ }),

/***/ "./node_modules/echarts/lib/util/throttle.js":
/***/ (function(module, exports) {

var ORIGIN_METHOD = '\0__throttleOriginMethod';
var RATE = '\0__throttleRate';
var THROTTLE_TYPE = '\0__throttleType';
/**
 * @public
 * @param {(Function)} fn
 * @param {number} [delay=0] Unit: ms.
 * @param {boolean} [debounce=false]
 *        true: If call interval less than `delay`, only the last call works.
 *        false: If call interval less than `delay, call works on fixed rate.
 * @return {(Function)} throttled fn.
 */

function throttle(fn, delay, debounce) {
  var currCall;
  var lastCall = 0;
  var lastExec = 0;
  var timer = null;
  var diff;
  var scope;
  var args;
  var debounceNextCall;
  delay = delay || 0;

  function exec() {
    lastExec = new Date().getTime();
    timer = null;
    fn.apply(scope, args || []);
  }

  var cb = function () {
    currCall = new Date().getTime();
    scope = this;
    args = arguments;
    var thisDelay = debounceNextCall || delay;
    var thisDebounce = debounceNextCall || debounce;
    debounceNextCall = null;
    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer);

    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff);
      }
    }

    lastCall = currCall;
  };
  /**
   * Clear throttle.
   * @public
   */


  cb.clear = function () {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  /**
   * Enable debounce once.
   */


  cb.debounceNextCall = function (debounceDelay) {
    debounceNextCall = debounceDelay;
  };

  return cb;
}
/**
 * Create throttle method or update throttle rate.
 *
 * @example
 * ComponentView.prototype.render = function () {
 *     ...
 *     throttle.createOrUpdate(
 *         this,
 *         '_dispatchAction',
 *         this.model.get('throttle'),
 *         'fixRate'
 *     );
 * };
 * ComponentView.prototype.remove = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 * ComponentView.prototype.dispose = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 *
 * @public
 * @param {Object} obj
 * @param {string} fnAttr
 * @param {number} [rate]
 * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'
 * @return {Function} throttled function.
 */


function createOrUpdate(obj, fnAttr, rate, throttleType) {
  var fn = obj[fnAttr];

  if (!fn) {
    return;
  }

  var originFn = fn[ORIGIN_METHOD] || fn;
  var lastThrottleType = fn[THROTTLE_TYPE];
  var lastRate = fn[RATE];

  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }

    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');
    fn[ORIGIN_METHOD] = originFn;
    fn[THROTTLE_TYPE] = throttleType;
    fn[RATE] = rate;
  }

  return fn;
}
/**
 * Clear throttle. Example see throttle.createOrUpdate.
 *
 * @public
 * @param {Object} obj
 * @param {string} fnAttr
 */


function clear(obj, fnAttr) {
  var fn = obj[fnAttr];

  if (fn && fn[ORIGIN_METHOD]) {
    obj[fnAttr] = fn[ORIGIN_METHOD];
  }
}

exports.throttle = throttle;
exports.createOrUpdate = createOrUpdate;
exports.clear = clear;

/***/ }),

/***/ "./node_modules/echarts/lib/view/Chart.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Group = __webpack_require__("./node_modules/zrender/lib/container/Group.js");

var componentUtil = __webpack_require__("./node_modules/echarts/lib/util/component.js");

var clazzUtil = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

function Chart() {
  /**
   * @type {module:zrender/container/Group}
   * @readOnly
   */
  this.group = new Group();
  /**
   * @type {string}
   * @readOnly
   */

  this.uid = componentUtil.getUID('viewChart');
}

Chart.prototype = {
  type: 'chart',

  /**
   * Init the chart
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  init: function (ecModel, api) {},

  /**
   * Render the chart
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  render: function (seriesModel, ecModel, api, payload) {},

  /**
   * Highlight series or specified data item
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  highlight: function (seriesModel, ecModel, api, payload) {
    toggleHighlight(seriesModel.getData(), payload, 'emphasis');
  },

  /**
   * Downplay series or specified data item
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  downplay: function (seriesModel, ecModel, api, payload) {
    toggleHighlight(seriesModel.getData(), payload, 'normal');
  },

  /**
   * Remove self
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  remove: function (ecModel, api) {
    this.group.removeAll();
  },

  /**
   * Dispose self
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  dispose: function () {}
  /**
   * The view contains the given point.
   * @interface
   * @param {Array.<number>} point
   * @return {boolean}
   */
  // containPoint: function () {}

};
var chartProto = Chart.prototype;

chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {
  this.render(seriesModel, ecModel, api, payload);
};
/**
 * Set state of single element
 * @param  {module:zrender/Element} el
 * @param  {string} state
 */


function elSetState(el, state) {
  if (el) {
    el.trigger(state);

    if (el.type === 'group') {
      for (var i = 0; i < el.childCount(); i++) {
        elSetState(el.childAt(i), state);
      }
    }
  }
}
/**
 * @param  {module:echarts/data/List} data
 * @param  {Object} payload
 * @param  {string} state 'normal'|'emphasis'
 * @inner
 */


function toggleHighlight(data, payload, state) {
  var dataIndex = modelUtil.queryDataIndex(data, payload);

  if (dataIndex != null) {
    zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state);
    });
  } else {
    data.eachItemGraphicEl(function (el) {
      elSetState(el, state);
    });
  }
} // Enable Chart.extend.


clazzUtil.enableClassExtend(Chart, ['dispose']); // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

clazzUtil.enableClassManagement(Chart, {
  registerWhenExtend: true
});
var _default = Chart;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/view/Component.js":
/***/ (function(module, exports, __webpack_require__) {

var Group = __webpack_require__("./node_modules/zrender/lib/container/Group.js");

var componentUtil = __webpack_require__("./node_modules/echarts/lib/util/component.js");

var clazzUtil = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var Component = function () {
  /**
   * @type {module:zrender/container/Group}
   * @readOnly
   */
  this.group = new Group();
  /**
   * @type {string}
   * @readOnly
   */

  this.uid = componentUtil.getUID('viewComponent');
};

Component.prototype = {
  constructor: Component,
  init: function (ecModel, api) {},
  render: function (componentModel, ecModel, api, payload) {},
  dispose: function () {}
};
var componentProto = Component.prototype;

componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {// Do nothing;
}; // Enable Component.extend.


clazzUtil.enableClassExtend(Component); // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

clazzUtil.enableClassManagement(Component, {
  registerWhenExtend: true
});
var _default = Component;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/visual/seriesColor.js":
/***/ (function(module, exports, __webpack_require__) {

var Gradient = __webpack_require__("./node_modules/zrender/lib/graphic/Gradient.js");

function _default(ecModel) {
  function encodeColor(seriesModel) {
    var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');
    var data = seriesModel.getData();
    var color = seriesModel.get(colorAccessPath) // Set in itemStyle
    || seriesModel.getColorFromPalette(seriesModel.get('name')); // Default color
    // FIXME Set color function or use the platte color

    data.setVisual('color', color); // Only visible series has each data be visual encoded

    if (!ecModel.isSeriesFiltered(seriesModel)) {
      if (typeof color === 'function' && !(color instanceof Gradient)) {
        data.each(function (idx) {
          data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));
        });
      } // itemStyle in each data item


      data.each(function (idx) {
        var itemModel = data.getItemModel(idx);
        var color = itemModel.get(colorAccessPath, true);

        if (color != null) {
          data.setItemVisual(idx, 'color', color);
        }
      });
    }
  }

  ecModel.eachRawSeries(encodeColor);
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/visual/symbol.js":
/***/ (function(module, exports) {

function _default(seriesType, defaultSymbolType, legendSymbol, ecModel, api) {
  // Encoding visual for all series include which is filtered for legend drawing
  ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {
    var data = seriesModel.getData();
    var symbolType = seriesModel.get('symbol') || defaultSymbolType;
    var symbolSize = seriesModel.get('symbolSize');
    data.setVisual({
      legendSymbol: legendSymbol || symbolType,
      symbol: symbolType,
      symbolSize: symbolSize
    }); // Only visible series has each data be visual encoded

    if (!ecModel.isSeriesFiltered(seriesModel)) {
      if (typeof symbolSize === 'function') {
        data.each(function (idx) {
          var rawValue = seriesModel.getRawValue(idx); // FIXME

          var params = seriesModel.getDataParams(idx);
          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
        });
      }

      data.each(function (idx) {
        var itemModel = data.getItemModel(idx);
        var itemSymbolType = itemModel.getShallow('symbol', true);
        var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol

        if (itemSymbolType != null) {
          data.setItemVisual(idx, 'symbol', itemSymbolType);
        }

        if (itemSymbolSize != null) {
          // PENDING Transform symbolSize ?
          data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
        }
      });
    }
  });
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-a0facede\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/index/welcome.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "welcome" }, [
      _c("div", {
        staticStyle: { width: "100%", height: "500px" },
        attrs: { id: "order_into" }
      })
    ])
  }
]
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-a0facede", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/zrender/lib/Element.js":
/***/ (function(module, exports, __webpack_require__) {

var guid = __webpack_require__("./node_modules/zrender/lib/core/guid.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var Transformable = __webpack_require__("./node_modules/zrender/lib/mixin/Transformable.js");

var Animatable = __webpack_require__("./node_modules/zrender/lib/mixin/Animatable.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/**
 * @alias module:zrender/Element
 * @constructor
 * @extends {module:zrender/mixin/Animatable}
 * @extends {module:zrender/mixin/Transformable}
 * @extends {module:zrender/mixin/Eventful}
 */
var Element = function (opts) {
  // jshint ignore:line
  Transformable.call(this, opts);
  Eventful.call(this, opts);
  Animatable.call(this, opts);
  /**
   * 画布元素ID
   * @type {string}
   */

  this.id = opts.id || guid();
};

Element.prototype = {
  /**
   * 元素类型
   * Element type
   * @type {string}
   */
  type: 'element',

  /**
   * 元素名字
   * Element name
   * @type {string}
   */
  name: '',

  /**
   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
   * ZRender instance will be assigned when element is associated with zrender
   * @name module:/zrender/Element#__zr
   * @type {module:zrender/ZRender}
   */
  __zr: null,

  /**
   * 图形是否忽略，为true时忽略图形的绘制以及事件触发
   * If ignore drawing and events of the element object
   * @name module:/zrender/Element#ignore
   * @type {boolean}
   * @default false
   */
  ignore: false,

  /**
   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
   * 该路径会继承被裁减对象的变换
   * @type {module:zrender/graphic/Path}
   * @see http://www.w3.org/TR/2dcontext/#clipping-region
   * @readOnly
   */
  clipPath: null,

  /**
   * Drift element
   * @param  {number} dx dx on the global space
   * @param  {number} dy dy on the global space
   */
  drift: function (dx, dy) {
    switch (this.draggable) {
      case 'horizontal':
        dy = 0;
        break;

      case 'vertical':
        dx = 0;
        break;
    }

    var m = this.transform;

    if (!m) {
      m = this.transform = [1, 0, 0, 1, 0, 0];
    }

    m[4] += dx;
    m[5] += dy;
    this.decomposeTransform();
    this.dirty(false);
  },

  /**
   * Hook before update
   */
  beforeUpdate: function () {},

  /**
   * Hook after update
   */
  afterUpdate: function () {},

  /**
   * Update each frame
   */
  update: function () {
    this.updateTransform();
  },

  /**
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {},

  /**
   * @protected
   */
  attrKV: function (key, value) {
    if (key === 'position' || key === 'scale' || key === 'origin') {
      // Copy the array
      if (value) {
        var target = this[key];

        if (!target) {
          target = this[key] = [];
        }

        target[0] = value[0];
        target[1] = value[1];
      }
    } else {
      this[key] = value;
    }
  },

  /**
   * Hide the element
   */
  hide: function () {
    this.ignore = true;
    this.__zr && this.__zr.refresh();
  },

  /**
   * Show the element
   */
  show: function () {
    this.ignore = false;
    this.__zr && this.__zr.refresh();
  },

  /**
   * @param {string|Object} key
   * @param {*} value
   */
  attr: function (key, value) {
    if (typeof key === 'string') {
      this.attrKV(key, value);
    } else if (zrUtil.isObject(key)) {
      for (var name in key) {
        if (key.hasOwnProperty(name)) {
          this.attrKV(name, key[name]);
        }
      }
    }

    this.dirty(false);
    return this;
  },

  /**
   * @param {module:zrender/graphic/Path} clipPath
   */
  setClipPath: function (clipPath) {
    var zr = this.__zr;

    if (zr) {
      clipPath.addSelfToZr(zr);
    } // Remove previous clip path


    if (this.clipPath && this.clipPath !== clipPath) {
      this.removeClipPath();
    }

    this.clipPath = clipPath;
    clipPath.__zr = zr;
    clipPath.__clipTarget = this;
    this.dirty(false);
  },

  /**
   */
  removeClipPath: function () {
    var clipPath = this.clipPath;

    if (clipPath) {
      if (clipPath.__zr) {
        clipPath.removeSelfFromZr(clipPath.__zr);
      }

      clipPath.__zr = null;
      clipPath.__clipTarget = null;
      this.clipPath = null;
      this.dirty(false);
    }
  },

  /**
   * Add self from zrender instance.
   * Not recursively because it will be invoked when element added to storage.
   * @param {module:zrender/ZRender} zr
   */
  addSelfToZr: function (zr) {
    this.__zr = zr; // 添加动画

    var animators = this.animators;

    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.addAnimator(animators[i]);
      }
    }

    if (this.clipPath) {
      this.clipPath.addSelfToZr(zr);
    }
  },

  /**
   * Remove self from zrender instance.
   * Not recursively because it will be invoked when element added to storage.
   * @param {module:zrender/ZRender} zr
   */
  removeSelfFromZr: function (zr) {
    this.__zr = null; // 移除动画

    var animators = this.animators;

    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.removeAnimator(animators[i]);
      }
    }

    if (this.clipPath) {
      this.clipPath.removeSelfFromZr(zr);
    }
  }
};
zrUtil.mixin(Element, Animatable);
zrUtil.mixin(Element, Transformable);
zrUtil.mixin(Element, Eventful);
var _default = Element;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/Handler.js":
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var Draggable = __webpack_require__("./node_modules/zrender/lib/mixin/Draggable.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

/**
 * Handler
 * @module zrender/Handler
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 *         pissang (shenyi.914@gmail.com)
 */
var SILENT = 'silent';

function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event: event,
    // target can only be an element that is not silent.
    target: targetInfo.target,
    // topTarget can be a silent element.
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which
  };
}

function EmptyProxy() {}

EmptyProxy.prototype.dispose = function () {};

var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
/**
 * @alias module:zrender/Handler
 * @constructor
 * @extends module:zrender/mixin/Eventful
 * @param {module:zrender/Storage} storage Storage instance.
 * @param {module:zrender/Painter} painter Painter instance.
 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
 */

var Handler = function (storage, painter, proxy, painterRoot) {
  Eventful.call(this);
  this.storage = storage;
  this.painter = painter;
  this.painterRoot = painterRoot;
  proxy = proxy || new EmptyProxy();
  /**
   * Proxy of event. can be Dom, WebGLSurface, etc.
   */

  this.proxy = proxy; // Attach handler

  proxy.handler = this;
  /**
   * {target, topTarget, x, y}
   * @private
   * @type {Object}
   */

  this._hovered = {};
  /**
   * @private
   * @type {Date}
   */

  this._lastTouchMoment;
  /**
   * @private
   * @type {number}
   */

  this._lastX;
  /**
   * @private
   * @type {number}
   */

  this._lastY;
  Draggable.call(this);
  util.each(handlerNames, function (name) {
    proxy.on && proxy.on(name, this[name], this);
  }, this);
};

Handler.prototype = {
  constructor: Handler,
  mousemove: function (event) {
    var x = event.zrX;
    var y = event.zrY;
    var lastHovered = this._hovered;
    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
    // (like 'setOption' or 'dispatchAction') in event handlers, we should find
    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
    // See #6198.

    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }

    var hovered = this._hovered = this.findHover(x, y);
    var hoveredTarget = hovered.target;
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element

    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, 'mouseout', event);
    } // Mouse moving on one element


    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element

    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, 'mouseover', event);
    }
  },
  mouseout: function (event) {
    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application
    // at the same level of painter.getViewportRoot() (e.g., tooltip
    // dom created by echarts), where 'globalout' event should not
    // be triggered when mouse enters these doms. (But 'mouseout'
    // should be triggered at the original hovered element as usual).

    var element = event.toElement || event.relatedTarget;
    var innerDom;

    do {
      element = element && element.parentNode;
    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));

    !innerDom && this.trigger('globalout', {
      event: event
    });
  },

  /**
   * Resize
   */
  resize: function (event) {
    this._hovered = {};
  },

  /**
   * Dispatch event
   * @param {string} eventName
   * @param {event=} eventArgs
   */
  dispatch: function (eventName, eventArgs) {
    var handler = this[eventName];
    handler && handler.call(this, eventArgs);
  },

  /**
   * Dispose
   */
  dispose: function () {
    this.proxy.dispose();
    this.storage = this.proxy = this.painter = null;
  },

  /**
   * 设置默认的cursor style
   * @param {string} [cursorStyle='default'] 例如 crosshair
   */
  setCursorStyle: function (cursorStyle) {
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  },

  /**
   * 事件分发代理
   *
   * @private
   * @param {Object} targetInfo {target, topTarget} 目标图形元素
   * @param {string} eventName 事件名称
   * @param {Object} event 事件对象
   */
  dispatchToElement: function (targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    var el = targetInfo.target;

    if (el && el.silent) {
      return;
    }

    var eventHandler = 'on' + eventName;
    var eventPacket = makeEventPacket(eventName, targetInfo, event);

    while (el) {
      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.parent;

      if (eventPacket.cancelBubble) {
        break;
      }
    }

    if (!eventPacket.cancelBubble) {
      // 冒泡到顶级 zrender 对象
      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在

      this.painter && this.painter.eachOtherLayer(function (layer) {
        if (typeof layer[eventHandler] == 'function') {
          layer[eventHandler].call(layer, eventPacket);
        }

        if (layer.trigger) {
          layer.trigger(eventName, eventPacket);
        }
      });
    }
  },

  /**
   * @private
   * @param {number} x
   * @param {number} y
   * @param {module:zrender/graphic/Displayable} exclude
   * @return {model:zrender/Element}
   * @method
   */
  findHover: function (x, y, exclude) {
    var list = this.storage.getDisplayList();
    var out = {
      x: x,
      y: y
    };

    for (var i = list.length - 1; i >= 0; i--) {
      var hoverCheckResult;

      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
        !out.topTarget && (out.topTarget = list[i]);

        if (hoverCheckResult !== SILENT) {
          out.target = list[i];
          break;
        }
      }
    }

    return out;
  }
}; // Common handlers

util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
  Handler.prototype[name] = function (event) {
    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
    var hovered = this.findHover(event.zrX, event.zrY);
    var hoveredTarget = hovered.target;

    if (name === 'mousedown') {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup

      this._upEl = hoveredTarget;
    } else if (name === 'mosueup') {
      this._upEl = hoveredTarget;
    } else if (name === 'click') {
      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
      // including the case that `mousedown` - `mousemove` - `mouseup`,
      // which should be filtered, otherwise it will bring trouble to
      // pan and zoom.
      || !this._downPoint // Arbitrary value
      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }

      this._downPoint = null;
    }

    this.dispatchToElement(hovered, name, event);
  };
});

function isHover(displayable, x, y) {
  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
    var el = displayable;
    var isSilent;

    while (el) {
      // If clipped by ancestor.
      // FIXME: If clipPath has neither stroke nor fill,
      // el.clipPath.contain(x, y) will always return false.
      if (el.clipPath && !el.clipPath.contain(x, y)) {
        return false;
      }

      if (el.silent) {
        isSilent = true;
      }

      el = el.parent;
    }

    return isSilent ? SILENT : true;
  }

  return false;
}

util.mixin(Handler, Eventful);
util.mixin(Handler, Draggable);
var _default = Handler;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/Layer.js":
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _config = __webpack_require__("./node_modules/zrender/lib/config.js");

var devicePixelRatio = _config.devicePixelRatio;

var Style = __webpack_require__("./node_modules/zrender/lib/graphic/Style.js");

var Pattern = __webpack_require__("./node_modules/zrender/lib/graphic/Pattern.js");

/**
 * @module zrender/Layer
 * @author pissang(https://www.github.com/pissang)
 */
function returnFalse() {
  return false;
}
/**
 * 创建dom
 *
 * @inner
 * @param {string} id dom id 待用
 * @param {Painter} painter painter instance
 * @param {number} number
 */


function createDom(id, painter, dpr) {
  var newDom = util.createCanvas();
  var width = painter.getWidth();
  var height = painter.getHeight();
  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~

  newDomStyle.position = 'absolute';
  newDomStyle.left = 0;
  newDomStyle.top = 0;
  newDomStyle.width = width + 'px';
  newDomStyle.height = height + 'px';
  newDom.width = width * dpr;
  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性

  newDom.setAttribute('data-zr-dom-id', id);
  return newDom;
}
/**
 * @alias module:zrender/Layer
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @param {string} id
 * @param {module:zrender/Painter} painter
 * @param {number} [dpr]
 */


var Layer = function (id, painter, dpr) {
  var dom;
  dpr = dpr || devicePixelRatio;

  if (typeof id === 'string') {
    dom = createDom(id, painter, dpr);
  } // Not using isDom because in node it will return false
  else if (util.isObject(id)) {
      dom = id;
      id = dom.id;
    }

  this.id = id;
  this.dom = dom;
  var domStyle = dom.style;

  if (domStyle) {
    // Not in node
    dom.onselectstart = returnFalse; // 避免页面选中的尴尬

    domStyle['-webkit-user-select'] = 'none';
    domStyle['user-select'] = 'none';
    domStyle['-webkit-touch-callout'] = 'none';
    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
    domStyle['padding'] = 0;
    domStyle['margin'] = 0;
    domStyle['border-width'] = 0;
  }

  this.domBack = null;
  this.ctxBack = null;
  this.painter = painter;
  this.config = null; // Configs

  /**
   * 每次清空画布的颜色
   * @type {string}
   * @default 0
   */

  this.clearColor = 0;
  /**
   * 是否开启动态模糊
   * @type {boolean}
   * @default false
   */

  this.motionBlur = false;
  /**
   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
   * @type {number}
   * @default 0.7
   */

  this.lastFrameAlpha = 0.7;
  /**
   * Layer dpr
   * @type {number}
   */

  this.dpr = dpr;
};

Layer.prototype = {
  constructor: Layer,
  elCount: 0,
  __dirty: true,
  initContext: function () {
    this.ctx = this.dom.getContext('2d');
    this.ctx.__currentValues = {};
    this.ctx.dpr = this.dpr;
  },
  createBackBuffer: function () {
    var dpr = this.dpr;
    this.domBack = createDom('back-' + this.id, this.painter, dpr);
    this.ctxBack = this.domBack.getContext('2d');
    this.ctxBack.__currentValues = {};

    if (dpr != 1) {
      this.ctxBack.scale(dpr, dpr);
    }
  },

  /**
   * @param  {number} width
   * @param  {number} height
   */
  resize: function (width, height) {
    var dpr = this.dpr;
    var dom = this.dom;
    var domStyle = dom.style;
    var domBack = this.domBack;
    domStyle.width = width + 'px';
    domStyle.height = height + 'px';
    dom.width = width * dpr;
    dom.height = height * dpr;

    if (domBack) {
      domBack.width = width * dpr;
      domBack.height = height * dpr;

      if (dpr != 1) {
        this.ctxBack.scale(dpr, dpr);
      }
    }
  },

  /**
   * 清空该层画布
   * @param {boolean} clearAll Clear all with out motion blur
   */
  clear: function (clearAll) {
    var dom = this.dom;
    var ctx = this.ctx;
    var width = dom.width;
    var height = dom.height;
    var clearColor = this.clearColor;
    var haveMotionBLur = this.motionBlur && !clearAll;
    var lastFrameAlpha = this.lastFrameAlpha;
    var dpr = this.dpr;

    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }

      this.ctxBack.globalCompositeOperation = 'copy';
      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
    }

    ctx.clearRect(0, 0, width, height);

    if (clearColor) {
      var clearColorGradientOrPattern; // Gradient

      if (clearColor.colorStops) {
        // Cache canvas gradient
        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
          x: 0,
          y: 0,
          width: width,
          height: height
        });
        clearColor.__canvasGradient = clearColorGradientOrPattern;
      } // Pattern
      else if (clearColor.image) {
          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
        }

      ctx.save();
      ctx.fillStyle = clearColorGradientOrPattern || clearColor;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    }

    if (haveMotionBLur) {
      var domBack = this.domBack;
      ctx.save();
      ctx.globalAlpha = lastFrameAlpha;
      ctx.drawImage(domBack, 0, 0, width, height);
      ctx.restore();
    }
  }
};
var _default = Layer;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/Painter.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/zrender/lib/config.js");

var devicePixelRatio = _config.devicePixelRatio;

var util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var log = __webpack_require__("./node_modules/zrender/lib/core/log.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var timsort = __webpack_require__("./node_modules/zrender/lib/core/timsort.js");

var Layer = __webpack_require__("./node_modules/zrender/lib/Layer.js");

var requestAnimationFrame = __webpack_require__("./node_modules/zrender/lib/animation/requestAnimationFrame.js");

var Image = __webpack_require__("./node_modules/zrender/lib/graphic/Image.js");

/**
 * Default canvas painter
 * @module zrender/Painter
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */
// PENDIGN
// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
//
// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
var MAX_PROGRESSIVE_LAYER_NUMBER = 5;

function parseInt10(val) {
  return parseInt(val, 10);
}

function isLayerValid(layer) {
  if (!layer) {
    return false;
  }

  if (layer.__builtin__) {
    return true;
  }

  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
    return false;
  }

  return true;
}

function preProcessLayer(layer) {
  layer.__unusedCount++;
}

function postProcessLayer(layer) {
  if (layer.__unusedCount == 1) {
    layer.clear();
  }
}

var tmpRect = new BoundingRect(0, 0, 0, 0);
var viewRect = new BoundingRect(0, 0, 0, 0);

function isDisplayableCulled(el, width, height) {
  tmpRect.copy(el.getBoundingRect());

  if (el.transform) {
    tmpRect.applyTransform(el.transform);
  }

  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect.intersect(viewRect);
}

function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths == prevClipPaths) {
    // Can both be null or undefined
    return false;
  }

  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }

  for (var i = 0; i < clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }
}

function doClip(clipPaths, ctx) {
  for (var i = 0; i < clipPaths.length; i++) {
    var clipPath = clipPaths[i];
    clipPath.setTransform(ctx);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip(); // Transform back

    clipPath.restoreTransform(ctx);
  }
}

function createRoot(width, height) {
  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬

  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
  return domRoot;
}
/**
 * @alias module:zrender/Painter
 * @constructor
 * @param {HTMLElement} root 绘图容器
 * @param {module:zrender/Storage} storage
 * @param {Object} opts
 */


var Painter = function (root, storage, opts) {
  this.type = 'canvas'; // In node environment using node-canvas

  var singleCanvas = !root.nodeName // In node ?
  || root.nodeName.toUpperCase() === 'CANVAS';
  this._opts = opts = util.extend({}, opts || {});
  /**
   * @type {number}
   */

  this.dpr = opts.devicePixelRatio || devicePixelRatio;
  /**
   * @type {boolean}
   * @private
   */

  this._singleCanvas = singleCanvas;
  /**
   * 绘图容器
   * @type {HTMLElement}
   */

  this.root = root;
  var rootStyle = root.style;

  if (rootStyle) {
    rootStyle['-webkit-tap-highlight-color'] = 'transparent';
    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
    root.innerHTML = '';
  }
  /**
   * @type {module:zrender/Storage}
   */


  this.storage = storage;
  /**
   * @type {Array.<number>}
   * @private
   */

  var zlevelList = this._zlevelList = [];
  /**
   * @type {Object.<string, module:zrender/Layer>}
   * @private
   */

  var layers = this._layers = {};
  /**
   * @type {Object.<string, Object>}
   * @type {private}
   */

  this._layerConfig = {};

  if (!singleCanvas) {
    this._width = this._getSize(0);
    this._height = this._getSize(1);
    var domRoot = this._domRoot = createRoot(this._width, this._height);
    root.appendChild(domRoot);
  } else {
    if (opts.width != null) {
      root.width = opts.width;
    }

    if (opts.height != null) {
      root.height = opts.height;
    } // Use canvas width and height directly


    var width = root.width;
    var height = root.height;
    this._width = width;
    this._height = height; // Create layer if only one given canvas
    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height

    var mainLayer = new Layer(root, this, 1);
    mainLayer.initContext(); // FIXME Use canvas width and height
    // mainLayer.resize(width, height);

    layers[0] = mainLayer;
    zlevelList.push(0);
    this._domRoot = root;
  } // Layers for progressive rendering


  this._progressiveLayers = [];
  /**
   * @type {module:zrender/Layer}
   * @private
   */

  this._hoverlayer;
  this._hoverElements = [];
};

Painter.prototype = {
  constructor: Painter,
  getType: function () {
    return 'canvas';
  },

  /**
   * If painter use a single canvas
   * @return {boolean}
   */
  isSingleCanvas: function () {
    return this._singleCanvas;
  },

  /**
   * @return {HTMLDivElement}
   */
  getViewportRoot: function () {
    return this._domRoot;
  },
  getViewportRootOffset: function () {
    var viewportRoot = this.getViewportRoot();

    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  },

  /**
   * 刷新
   * @param {boolean} [paintAll=false] 强制绘制所有displayable
   */
  refresh: function (paintAll) {
    var list = this.storage.getDisplayList(true);
    var zlevelList = this._zlevelList;

    this._paintList(list, paintAll); // Paint custum layers


    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];

      if (!layer.__builtin__ && layer.refresh) {
        layer.refresh();
      }
    }

    this.refreshHover();

    if (this._progressiveLayers.length) {
      this._startProgessive();
    }

    return this;
  },
  addHover: function (el, hoverStyle) {
    if (el.__hoverMir) {
      return;
    }

    var elMirror = new el.constructor({
      style: el.style,
      shape: el.shape
    });
    elMirror.__from = el;
    el.__hoverMir = elMirror;
    elMirror.setStyle(hoverStyle);

    this._hoverElements.push(elMirror);
  },
  removeHover: function (el) {
    var elMirror = el.__hoverMir;
    var hoverElements = this._hoverElements;
    var idx = util.indexOf(hoverElements, elMirror);

    if (idx >= 0) {
      hoverElements.splice(idx, 1);
    }

    el.__hoverMir = null;
  },
  clearHover: function (el) {
    var hoverElements = this._hoverElements;

    for (var i = 0; i < hoverElements.length; i++) {
      var from = hoverElements[i].__from;

      if (from) {
        from.__hoverMir = null;
      }
    }

    hoverElements.length = 0;
  },
  refreshHover: function () {
    var hoverElements = this._hoverElements;
    var len = hoverElements.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();

    if (!len) {
      return;
    }

    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
    // FIXME?

    if (!hoverLayer) {
      hoverLayer = this._hoverlayer = this.getLayer(1e5);
    }

    var scope = {};
    hoverLayer.ctx.save();

    for (var i = 0; i < len;) {
      var el = hoverElements[i];
      var originalEl = el.__from; // Original el is removed
      // PENDING

      if (!(originalEl && originalEl.__zr)) {
        hoverElements.splice(i, 1);
        originalEl.__hoverMir = null;
        len--;
        continue;
      }

      i++; // Use transform
      // FIXME style and shape ?

      if (!originalEl.invisible) {
        el.transform = originalEl.transform;
        el.invTransform = originalEl.invTransform;
        el.__clipPaths = originalEl.__clipPaths; // el.

        this._doPaintEl(el, hoverLayer, true, scope);
      }
    }

    hoverLayer.ctx.restore();
  },
  _startProgessive: function () {
    var self = this;

    if (!self._furtherProgressive) {
      return;
    } // Use a token to stop progress steps triggered by
    // previous zr.refresh calling.


    var token = self._progressiveToken = +new Date();
    self._progress++;
    requestAnimationFrame(step);

    function step() {
      // In case refreshed or disposed
      if (token === self._progressiveToken && self.storage) {
        self._doPaintList(self.storage.getDisplayList());

        if (self._furtherProgressive) {
          self._progress++;
          requestAnimationFrame(step);
        } else {
          self._progressiveToken = -1;
        }
      }
    }
  },
  _clearProgressive: function () {
    this._progressiveToken = -1;
    this._progress = 0;
    util.each(this._progressiveLayers, function (layer) {
      layer.__dirty && layer.clear();
    });
  },
  _paintList: function (list, paintAll) {
    if (paintAll == null) {
      paintAll = false;
    }

    this._updateLayerStatus(list);

    this._clearProgressive();

    this.eachBuiltinLayer(preProcessLayer);

    this._doPaintList(list, paintAll);

    this.eachBuiltinLayer(postProcessLayer);
  },
  _doPaintList: function (list, paintAll) {
    var currentLayer;
    var currentZLevel;
    var ctx; // var invTransform = [];

    var scope;
    var progressiveLayerIdx = 0;
    var currentProgressiveLayer;
    var width = this._width;
    var height = this._height;
    var layerProgress;
    var frame = this._progress;

    function flushProgressiveLayer(layer) {
      var dpr = ctx.dpr || 1;
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame

      currentLayer.__dirty = true;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
      ctx.restore();
    }

    for (var i = 0, l = list.length; i < l; i++) {
      var el = list[i];
      var elZLevel = this._singleCanvas ? 0 : el.zlevel;
      var elFrame = el.__frame; // Flush at current context
      // PENDING

      if (elFrame < 0 && currentProgressiveLayer) {
        flushProgressiveLayer(currentProgressiveLayer);
        currentProgressiveLayer = null;
      } // Change draw layer


      if (currentZLevel !== elZLevel) {
        if (ctx) {
          ctx.restore();
        } // Reset scope


        scope = {}; // Only 0 zlevel if only has one canvas

        currentZLevel = elZLevel;
        currentLayer = this.getLayer(currentZLevel);

        if (!currentLayer.__builtin__) {
          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
        }

        ctx = currentLayer.ctx;
        ctx.save(); // Reset the count

        currentLayer.__unusedCount = 0;

        if (currentLayer.__dirty || paintAll) {
          currentLayer.clear();
        }
      }

      if (!(currentLayer.__dirty || paintAll)) {
        continue;
      }

      if (elFrame >= 0) {
        // Progressive layer changed
        if (!currentProgressiveLayer) {
          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];
          currentProgressiveLayer.ctx.save();
          currentProgressiveLayer.renderScope = {};

          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {
            // flushProgressiveLayer(currentProgressiveLayer);
            // Quick jump all progressive elements
            // All progressive element are not dirty, jump over and flush directly
            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;

            continue;
          }

          layerProgress = currentProgressiveLayer.__progress;

          if (!currentProgressiveLayer.__dirty) {
            // Keep rendering
            frame = layerProgress;
          }

          currentProgressiveLayer.__progress = frame + 1;
        }

        if (elFrame === frame) {
          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
        }
      } else {
        this._doPaintEl(el, currentLayer, paintAll, scope);
      }

      el.__dirty = false;
    }

    if (currentProgressiveLayer) {
      flushProgressiveLayer(currentProgressiveLayer);
    } // Restore the lastLayer ctx


    ctx && ctx.restore(); // If still has clipping state
    // if (scope.prevElClipPaths) {
    //     ctx.restore();
    // }

    this._furtherProgressive = false;
    util.each(this._progressiveLayers, function (layer) {
      if (layer.__maxProgress >= layer.__progress) {
        this._furtherProgressive = true;
      }
    }, this);
  },
  _doPaintEl: function (el, currentLayer, forcePaint, scope) {
    var ctx = currentLayer.ctx;
    var m = el.transform;

    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
    !el.invisible // Ignore transparent element
    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
    // Draw a scale 0 element can cause all following draw wrong
    // And setTransform with scale 0 will cause set back transform failed.
    && !(m && !m[0] && !m[3]) // Ignore culled element
    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements

      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
        // If has previous clipping state, restore from it
        if (scope.prevElClipPaths) {
          scope.prevClipLayer.ctx.restore();
          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored

          scope.prevEl = null;
        } // New clipping state


        if (clipPaths) {
          ctx.save();
          doClip(clipPaths, ctx);
          scope.prevClipLayer = currentLayer;
          scope.prevElClipPaths = clipPaths;
        }
      }

      el.beforeBrush && el.beforeBrush(ctx);
      el.brush(ctx, scope.prevEl || null);
      scope.prevEl = el;
      el.afterBrush && el.afterBrush(ctx);
    }
  },

  /**
   * 获取 zlevel 所在层，如果不存在则会创建一个新的层
   * @param {number} zlevel
   * @return {module:zrender/Layer}
   */
  getLayer: function (zlevel) {
    if (this._singleCanvas) {
      return this._layers[0];
    }

    var layer = this._layers[zlevel];

    if (!layer) {
      // Create a new layer
      layer = new Layer('zr_' + zlevel, this, this.dpr);
      layer.__builtin__ = true;

      if (this._layerConfig[zlevel]) {
        util.merge(layer, this._layerConfig[zlevel], true);
      }

      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
      // Or excanvas will get 0px clientWidth and clientHeight

      layer.initContext();
    }

    return layer;
  },
  insertLayer: function (zlevel, layer) {
    var layersMap = this._layers;
    var zlevelList = this._zlevelList;
    var len = zlevelList.length;
    var prevLayer = null;
    var i = -1;
    var domRoot = this._domRoot;

    if (layersMap[zlevel]) {
      log('ZLevel ' + zlevel + ' has been used already');
      return;
    } // Check if is a valid layer


    if (!isLayerValid(layer)) {
      log('Layer of zlevel ' + zlevel + ' is not valid');
      return;
    }

    if (len > 0 && zlevel > zlevelList[0]) {
      for (i = 0; i < len - 1; i++) {
        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
          break;
        }
      }

      prevLayer = layersMap[zlevelList[i]];
    }

    zlevelList.splice(i + 1, 0, zlevel);
    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
    // (It can be a WebGL layer and assigned to a ZImage element)
    // But it still under management of zrender.

    if (!layer.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;

        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
  },
  // Iterate each layer
  eachLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  },
  // Iterate each buildin layer
  eachBuiltinLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var layer;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      layer = this._layers[z];

      if (layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },
  // Iterate each other layer except buildin layer
  eachOtherLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var layer;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      layer = this._layers[z];

      if (!layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },

  /**
   * 获取所有已创建的层
   * @param {Array.<module:zrender/Layer>} [prevLayer]
   */
  getLayers: function () {
    return this._layers;
  },
  _updateLayerStatus: function (list) {
    var layers = this._layers;
    var progressiveLayers = this._progressiveLayers;
    var elCountsLastFrame = {};
    var progressiveElCountsLastFrame = {};
    this.eachBuiltinLayer(function (layer, z) {
      elCountsLastFrame[z] = layer.elCount;
      layer.elCount = 0;
      layer.__dirty = false;
    });
    util.each(progressiveLayers, function (layer, idx) {
      progressiveElCountsLastFrame[idx] = layer.elCount;
      layer.elCount = 0;
      layer.__dirty = false;
    });
    var progressiveLayerCount = 0;
    var currentProgressiveLayer;
    var lastProgressiveKey;
    var frameCount = 0;

    for (var i = 0, l = list.length; i < l; i++) {
      var el = list[i];
      var zlevel = this._singleCanvas ? 0 : el.zlevel;
      var layer = layers[zlevel];
      var elProgress = el.progressive;

      if (layer) {
        layer.elCount++;
        layer.__dirty = layer.__dirty || el.__dirty;
      } /////// Update progressive


      if (elProgress >= 0) {
        // Fix wrong progressive sequence problem.
        if (lastProgressiveKey !== elProgress) {
          lastProgressiveKey = elProgress;
          frameCount++;
        }

        var elFrame = el.__frame = frameCount - 1;

        if (!currentProgressiveLayer) {
          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
          currentProgressiveLayer = progressiveLayers[idx];

          if (!currentProgressiveLayer) {
            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);
            currentProgressiveLayer.initContext();
          }

          currentProgressiveLayer.__maxProgress = 0;
        }

        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
        currentProgressiveLayer.elCount++;
        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);

        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
          // Should keep rendering this  layer because progressive rendering is not finished yet
          layer.__dirty = true;
        }
      } else {
        el.__frame = -1;

        if (currentProgressiveLayer) {
          currentProgressiveLayer.__nextIdxNotProg = i;
          progressiveLayerCount++;
          currentProgressiveLayer = null;
        }
      }
    }

    if (currentProgressiveLayer) {
      progressiveLayerCount++;
      currentProgressiveLayer.__nextIdxNotProg = i;
    } // 层中的元素数量有发生变化


    this.eachBuiltinLayer(function (layer, z) {
      if (elCountsLastFrame[z] !== layer.elCount) {
        layer.__dirty = true;
      }
    });
    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
    util.each(progressiveLayers, function (layer, idx) {
      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
        el.__dirty = true;
      }

      if (layer.__dirty) {
        layer.__progress = 0;
      }
    });
  },

  /**
   * 清除hover层外所有内容
   */
  clear: function () {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  },
  _clearLayer: function (layer) {
    layer.clear();
  },

  /**
   * 修改指定zlevel的绘制参数
   *
   * @param {string} zlevel
   * @param {Object} config 配置对象
   * @param {string} [config.clearColor=0] 每次清空画布的颜色
   * @param {string} [config.motionBlur=false] 是否开启动态模糊
   * @param {number} [config.lastFrameAlpha=0.7]
   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
   */
  configLayer: function (zlevel, config) {
    if (config) {
      var layerConfig = this._layerConfig;

      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config;
      } else {
        util.merge(layerConfig[zlevel], config, true);
      }

      var layer = this._layers[zlevel];

      if (layer) {
        util.merge(layer, layerConfig[zlevel], true);
      }
    }
  },

  /**
   * 删除指定层
   * @param {number} zlevel 层所在的zlevel
   */
  delLayer: function (zlevel) {
    var layers = this._layers;
    var zlevelList = this._zlevelList;
    var layer = layers[zlevel];

    if (!layer) {
      return;
    }

    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
  },

  /**
   * 区域大小变化后重绘
   */
  resize: function (width, height) {
    var domRoot = this._domRoot; // FIXME Why ?

    domRoot.style.display = 'none'; // Save input w/h

    var opts = this._opts;
    width != null && (opts.width = width);
    height != null && (opts.height = height);
    width = this._getSize(0);
    height = this._getSize(1);
    domRoot.style.display = ''; // 优化没有实际改变的resize

    if (this._width != width || height != this._height) {
      domRoot.style.width = width + 'px';
      domRoot.style.height = height + 'px';

      for (var id in this._layers) {
        if (this._layers.hasOwnProperty(id)) {
          this._layers[id].resize(width, height);
        }
      }

      util.each(this._progressiveLayers, function (layer) {
        layer.resize(width, height);
      });
      this.refresh(true);
    }

    this._width = width;
    this._height = height;
    return this;
  },

  /**
   * 清除单独的一个层
   * @param {number} zlevel
   */
  clearLayer: function (zlevel) {
    var layer = this._layers[zlevel];

    if (layer) {
      layer.clear();
    }
  },

  /**
   * 释放
   */
  dispose: function () {
    this.root.innerHTML = '';
    this.root = this.storage = this._domRoot = this._layers = null;
  },

  /**
   * Get canvas which has all thing rendered
   * @param {Object} opts
   * @param {string} [opts.backgroundColor]
   * @param {number} [opts.pixelRatio]
   */
  getRenderedCanvas: function (opts) {
    opts = opts || {};

    if (this._singleCanvas) {
      return this._layers[0].dom;
    }

    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clearColor = opts.backgroundColor;
    imageLayer.clear();
    var displayList = this.storage.getDisplayList(true);
    var scope = {};
    var zlevel;
    var self = this;

    function findAndDrawOtherLayer(smaller, larger) {
      var zlevelList = self._zlevelList;

      if (smaller == null) {
        smaller = -Infinity;
      }

      var intermediateLayer;

      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        var layer = self._layers[z];

        if (!layer.__builtin__ && z > smaller && z < larger) {
          intermediateLayer = layer;
          break;
        }
      }

      if (intermediateLayer && intermediateLayer.renderToCanvas) {
        imageLayer.ctx.save();
        intermediateLayer.renderToCanvas(imageLayer.ctx);
        imageLayer.ctx.restore();
      }
    }

    for (var i = 0; i < displayList.length; i++) {
      var el = displayList[i];

      if (el.zlevel !== zlevel) {
        findAndDrawOtherLayer(zlevel, el.zlevel);
        zlevel = el.zlevel;
      }

      this._doPaintEl(el, imageLayer, true, scope);
    }

    findAndDrawOtherLayer(zlevel, Infinity);
    return imageLayer.dom;
  },

  /**
   * 获取绘图区域宽度
   */
  getWidth: function () {
    return this._width;
  },

  /**
   * 获取绘图区域高度
   */
  getHeight: function () {
    return this._height;
  },
  _getSize: function (whIdx) {
    var opts = this._opts;
    var wh = ['width', 'height'][whIdx];
    var cwh = ['clientWidth', 'clientHeight'][whIdx];
    var plt = ['paddingLeft', 'paddingTop'][whIdx];
    var prb = ['paddingRight', 'paddingBottom'][whIdx];

    if (opts[wh] != null && opts[wh] !== 'auto') {
      return parseFloat(opts[wh]);
    }

    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.

    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
  },
  pathToImage: function (path, dpr) {
    dpr = dpr || this.dpr;
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var rect = path.getBoundingRect();
    var style = path.style;
    var shadowBlurSize = style.shadowBlur;
    var shadowOffsetX = style.shadowOffsetX;
    var shadowOffsetY = style.shadowOffsetY;
    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
    var width = rect.width + leftMargin + rightMargin;
    var height = rect.height + topMargin + bottomMargin;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, width, height);
    ctx.dpr = dpr;
    var pathTransform = {
      position: path.position,
      rotation: path.rotation,
      scale: path.scale
    };
    path.position = [leftMargin - rect.x, topMargin - rect.y];
    path.rotation = 0;
    path.scale = [1, 1];
    path.updateTransform();

    if (path) {
      path.brush(ctx);
    }

    var ImageShape = Image;
    var imgShape = new ImageShape({
      style: {
        x: 0,
        y: 0,
        image: canvas
      }
    });

    if (pathTransform.position != null) {
      imgShape.position = path.position = pathTransform.position;
    }

    if (pathTransform.rotation != null) {
      imgShape.rotation = path.rotation = pathTransform.rotation;
    }

    if (pathTransform.scale != null) {
      imgShape.scale = path.scale = pathTransform.scale;
    }

    return imgShape;
  }
};
var _default = Painter;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/Storage.js":
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var Group = __webpack_require__("./node_modules/zrender/lib/container/Group.js");

var timsort = __webpack_require__("./node_modules/zrender/lib/core/timsort.js");

/**
 * Storage内容仓库模块
 * @module zrender/Storage
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 * @author errorrik (errorrik@gmail.com)
 * @author pissang (https://github.com/pissang/)
 */
// Use timsort because in most case elements are partially sorted
// https://jsfiddle.net/pissang/jr4x7mdm/8/
function shapeCompareFunc(a, b) {
  if (a.zlevel === b.zlevel) {
    if (a.z === b.z) {
      // if (a.z2 === b.z2) {
      //     // FIXME Slow has renderidx compare
      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
      //     return a.__renderidx - b.__renderidx;
      // }
      return a.z2 - b.z2;
    }

    return a.z - b.z;
  }

  return a.zlevel - b.zlevel;
}
/**
 * 内容仓库 (M)
 * @alias module:zrender/Storage
 * @constructor
 */


var Storage = function () {
  // jshint ignore:line
  this._roots = [];
  this._displayList = [];
  this._displayListLen = 0;
};

Storage.prototype = {
  constructor: Storage,

  /**
   * @param  {Function} cb
   *
   */
  traverse: function (cb, context) {
    for (var i = 0; i < this._roots.length; i++) {
      this._roots[i].traverse(cb, context);
    }
  },

  /**
   * 返回所有图形的绘制队列
   * @param {boolean} [update=false] 是否在返回前更新该数组
   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
   *
   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
   * @return {Array.<module:zrender/graphic/Displayable>}
   */
  getDisplayList: function (update, includeIgnore) {
    includeIgnore = includeIgnore || false;

    if (update) {
      this.updateDisplayList(includeIgnore);
    }

    return this._displayList;
  },

  /**
   * 更新图形的绘制队列。
   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
   */
  updateDisplayList: function (includeIgnore) {
    this._displayListLen = 0;
    var roots = this._roots;
    var displayList = this._displayList;

    for (var i = 0, len = roots.length; i < len; i++) {
      this._updateAndAddDisplayable(roots[i], null, includeIgnore);
    }

    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {
    //     displayList[i].__renderidx = i;
    // }
    // displayList.sort(shapeCompareFunc);

    env.canvasSupported && timsort(displayList, shapeCompareFunc);
  },
  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }

    el.beforeUpdate();

    if (el.__dirty) {
      el.update();
    }

    el.afterUpdate();
    var userSetClipPath = el.clipPath;

    if (userSetClipPath) {
      // FIXME 效率影响
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }

      var currentClipPath = userSetClipPath;
      var parentClipPath = el; // Recursively add clip path

      while (currentClipPath) {
        // clipPath 的变换是基于使用这个 clipPath 的元素
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.clipPath;
      }
    }

    if (el.isGroup) {
      var children = el._children;

      for (var i = 0; i < children.length; i++) {
        var child = children[i]; // Force to mark as dirty if group is dirty
        // FIXME __dirtyPath ?

        if (el.__dirty) {
          child.__dirty = true;
        }

        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      } // Mark group clean here


      el.__dirty = false;
    } else {
      el.__clipPaths = clipPaths;
      this._displayList[this._displayListLen++] = el;
    }
  },

  /**
   * 添加图形(Shape)或者组(Group)到根节点
   * @param {module:zrender/Element} el
   */
  addRoot: function (el) {
    if (el.__storage === this) {
      return;
    }

    if (el instanceof Group) {
      el.addChildrenToStorage(this);
    }

    this.addToStorage(el);

    this._roots.push(el);
  },

  /**
   * 删除指定的图形(Shape)或者组(Group)
   * @param {string|Array.<string>} [el] 如果为空清空整个Storage
   */
  delRoot: function (el) {
    if (el == null) {
      // 不指定el清空
      for (var i = 0; i < this._roots.length; i++) {
        var root = this._roots[i];

        if (root instanceof Group) {
          root.delChildrenFromStorage(this);
        }
      }

      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      return;
    }

    if (el instanceof Array) {
      for (var i = 0, l = el.length; i < l; i++) {
        this.delRoot(el[i]);
      }

      return;
    }

    var idx = util.indexOf(this._roots, el);

    if (idx >= 0) {
      this.delFromStorage(el);

      this._roots.splice(idx, 1);

      if (el instanceof Group) {
        el.delChildrenFromStorage(this);
      }
    }
  },
  addToStorage: function (el) {
    el.__storage = this;
    el.dirty(false);
    return this;
  },
  delFromStorage: function (el) {
    if (el) {
      el.__storage = null;
    }

    return this;
  },

  /**
   * 清空并且释放Storage
   */
  dispose: function () {
    this._renderList = this._roots = null;
  },
  displayableSortFunc: shapeCompareFunc
};
var _default = Storage;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/animation/Animation.js":
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _event = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var Dispatcher = _event.Dispatcher;

var requestAnimationFrame = __webpack_require__("./node_modules/zrender/lib/animation/requestAnimationFrame.js");

var Animator = __webpack_require__("./node_modules/zrender/lib/animation/Animator.js");

/**
 * 动画主类, 调度和管理所有动画控制器
 *
 * @module zrender/animation/Animation
 * @author pissang(https://github.com/pissang)
 */
// TODO Additive animation
// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
// https://developer.apple.com/videos/wwdc2014/#236

/**
 * @typedef {Object} IZRenderStage
 * @property {Function} update
 */

/**
 * @alias module:zrender/animation/Animation
 * @constructor
 * @param {Object} [options]
 * @param {Function} [options.onframe]
 * @param {IZRenderStage} [options.stage]
 * @example
 *     var animation = new Animation();
 *     var obj = {
 *         x: 100,
 *         y: 100
 *     };
 *     animation.animate(node.position)
 *         .when(1000, {
 *             x: 500,
 *             y: 500
 *         })
 *         .when(2000, {
 *             x: 100,
 *             y: 100
 *         })
 *         .start('spline');
 */
var Animation = function (options) {
  options = options || {};
  this.stage = options.stage || {};

  this.onframe = options.onframe || function () {}; // private properties


  this._clips = [];
  this._running = false;
  this._time;
  this._pausedTime;
  this._pauseStart;
  this._paused = false;
  Dispatcher.call(this);
};

Animation.prototype = {
  constructor: Animation,

  /**
   * 添加 clip
   * @param {module:zrender/animation/Clip} clip
   */
  addClip: function (clip) {
    this._clips.push(clip);
  },

  /**
   * 添加 animator
   * @param {module:zrender/animation/Animator} animator
   */
  addAnimator: function (animator) {
    animator.animation = this;
    var clips = animator.getClips();

    for (var i = 0; i < clips.length; i++) {
      this.addClip(clips[i]);
    }
  },

  /**
   * 删除动画片段
   * @param {module:zrender/animation/Clip} clip
   */
  removeClip: function (clip) {
    var idx = util.indexOf(this._clips, clip);

    if (idx >= 0) {
      this._clips.splice(idx, 1);
    }
  },

  /**
   * 删除动画片段
   * @param {module:zrender/animation/Animator} animator
   */
  removeAnimator: function (animator) {
    var clips = animator.getClips();

    for (var i = 0; i < clips.length; i++) {
      this.removeClip(clips[i]);
    }

    animator.animation = null;
  },
  _update: function () {
    var time = new Date().getTime() - this._pausedTime;

    var delta = time - this._time;
    var clips = this._clips;
    var len = clips.length;
    var deferredEvents = [];
    var deferredClips = [];

    for (var i = 0; i < len; i++) {
      var clip = clips[i];
      var e = clip.step(time, delta); // Throw out the events need to be called after
      // stage.update, like destroy

      if (e) {
        deferredEvents.push(e);
        deferredClips.push(clip);
      }
    } // Remove the finished clip


    for (var i = 0; i < len;) {
      if (clips[i]._needsRemove) {
        clips[i] = clips[len - 1];
        clips.pop();
        len--;
      } else {
        i++;
      }
    }

    len = deferredEvents.length;

    for (var i = 0; i < len; i++) {
      deferredClips[i].fire(deferredEvents[i]);
    }

    this._time = time;
    this.onframe(delta);
    this.trigger('frame', delta);

    if (this.stage.update) {
      this.stage.update();
    }
  },
  _startLoop: function () {
    var self = this;
    this._running = true;

    function step() {
      if (self._running) {
        requestAnimationFrame(step);
        !self._paused && self._update();
      }
    }

    requestAnimationFrame(step);
  },

  /**
   * 开始运行动画
   */
  start: function () {
    this._time = new Date().getTime();
    this._pausedTime = 0;

    this._startLoop();
  },

  /**
   * 停止运行动画
   */
  stop: function () {
    this._running = false;
  },

  /**
   * Pause
   */
  pause: function () {
    if (!this._paused) {
      this._pauseStart = new Date().getTime();
      this._paused = true;
    }
  },

  /**
   * Resume
   */
  resume: function () {
    if (this._paused) {
      this._pausedTime += new Date().getTime() - this._pauseStart;
      this._paused = false;
    }
  },

  /**
   * 清除所有动画片段
   */
  clear: function () {
    this._clips = [];
  },

  /**
   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
   * @param  {Object} target
   * @param  {Object} options
   * @param  {boolean} [options.loop=false] 是否循环播放动画
   * @param  {Function} [options.getter=null]
   *         如果指定getter函数，会通过getter函数取属性值
   * @param  {Function} [options.setter=null]
   *         如果指定setter函数，会通过setter函数设置属性值
   * @return {module:zrender/animation/Animation~Animator}
   */
  // TODO Gap
  animate: function (target, options) {
    options = options || {};
    var animator = new Animator(target, options.loop, options.getter, options.setter);
    this.addAnimator(animator);
    return animator;
  }
};
util.mixin(Animation, Dispatcher);
var _default = Animation;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/animation/Animator.js":
/***/ (function(module, exports, __webpack_require__) {

var Clip = __webpack_require__("./node_modules/zrender/lib/animation/Clip.js");

var color = __webpack_require__("./node_modules/zrender/lib/tool/color.js");

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var isArrayLike = _util.isArrayLike;

/**
 * @module echarts/animation/Animator
 */
var arraySlice = Array.prototype.slice;

function defaultGetter(target, key) {
  return target[key];
}

function defaultSetter(target, key, value) {
  target[key] = value;
}
/**
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} percent
 * @return {number}
 */


function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
/**
 * @param  {string} p0
 * @param  {string} p1
 * @param  {number} percent
 * @return {string}
 */


function interpolateString(p0, p1, percent) {
  return percent > 0.5 ? p1 : p0;
}
/**
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {number} percent
 * @param  {Array} out
 * @param  {number} arrDim
 */


function interpolateArray(p0, p1, percent, out, arrDim) {
  var len = p0.length;

  if (arrDim == 1) {
    for (var i = 0; i < len; i++) {
      out[i] = interpolateNumber(p0[i], p1[i], percent);
    }
  } else {
    var len2 = len && p0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
      }
    }
  }
} // arr0 is source array, arr1 is target array.
// Do some preprocess to avoid error happened when interpolating from arr0 to arr1


function fillArr(arr0, arr1, arrDim) {
  var arr0Len = arr0.length;
  var arr1Len = arr1.length;

  if (arr0Len !== arr1Len) {
    // FIXME Not work for TypedArray
    var isPreviousLarger = arr0Len > arr1Len;

    if (isPreviousLarger) {
      // Cut the previous
      arr0.length = arr1Len;
    } else {
      // Fill the previous
      for (var i = arr0Len; i < arr1Len; i++) {
        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
      }
    }
  } // Handling NaN value


  var len2 = arr0[0] && arr0[0].length;

  for (var i = 0; i < arr0.length; i++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i])) {
        arr0[i] = arr1[i];
      }
    } else {
      for (var j = 0; j < len2; j++) {
        if (isNaN(arr0[i][j])) {
          arr0[i][j] = arr1[i][j];
        }
      }
    }
  }
}
/**
 * @param  {Array} arr0
 * @param  {Array} arr1
 * @param  {number} arrDim
 * @return {boolean}
 */


function isArraySame(arr0, arr1, arrDim) {
  if (arr0 === arr1) {
    return true;
  }

  var len = arr0.length;

  if (len !== arr1.length) {
    return false;
  }

  if (arrDim === 1) {
    for (var i = 0; i < len; i++) {
      if (arr0[i] !== arr1[i]) {
        return false;
      }
    }
  } else {
    var len2 = arr0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        if (arr0[i][j] !== arr1[i][j]) {
          return false;
        }
      }
    }
  }

  return true;
}
/**
 * Catmull Rom interpolate array
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @param  {Array} out
 * @param  {number} arrDim
 */


function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
  var len = p0.length;

  if (arrDim == 1) {
    for (var i = 0; i < len; i++) {
      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
    }
  } else {
    var len2 = p0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
      }
    }
  }
}
/**
 * Catmull Rom interpolate number
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @return {number}
 */


function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}

function cloneValue(value) {
  if (isArrayLike(value)) {
    var len = value.length;

    if (isArrayLike(value[0])) {
      var ret = [];

      for (var i = 0; i < len; i++) {
        ret.push(arraySlice.call(value[i]));
      }

      return ret;
    }

    return arraySlice.call(value);
  }

  return value;
}

function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]);
  rgba[1] = Math.floor(rgba[1]);
  rgba[2] = Math.floor(rgba[2]);
  return 'rgba(' + rgba.join(',') + ')';
}

function getArrayDim(keyframes) {
  var lastValue = keyframes[keyframes.length - 1].value;
  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
}

function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
  var getter = animator._getter;
  var setter = animator._setter;
  var useSpline = easing === 'spline';
  var trackLen = keyframes.length;

  if (!trackLen) {
    return;
  } // Guess data type


  var firstVal = keyframes[0].value;
  var isValueArray = isArrayLike(firstVal);
  var isValueColor = false;
  var isValueString = false; // For vertices morphing

  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
  var trackMaxTime; // Sort keyframe as ascending

  keyframes.sort(function (a, b) {
    return a.time - b.time;
  });
  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe

  var kfPercents = []; // Value of each keyframe

  var kfValues = [];
  var prevValue = keyframes[0].value;
  var isAllValueEqual = true;

  for (var i = 0; i < trackLen; i++) {
    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string

    var value = keyframes[i].value; // Check if value is equal, deep check if value is array

    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
      isAllValueEqual = false;
    }

    prevValue = value; // Try converting a string to a color array

    if (typeof value == 'string') {
      var colorArray = color.parse(value);

      if (colorArray) {
        value = colorArray;
        isValueColor = true;
      } else {
        isValueString = true;
      }
    }

    kfValues.push(value);
  }

  if (!forceAnimate && isAllValueEqual) {
    return;
  }

  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value

  for (var i = 0; i < trackLen - 1; i++) {
    if (isValueArray) {
      fillArr(kfValues[i], lastValue, arrDim);
    } else {
      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
        kfValues[i] = lastValue;
      }
    }
  }

  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
  // animation playback is sequency

  var lastFrame = 0;
  var lastFramePercent = 0;
  var start;
  var w;
  var p0;
  var p1;
  var p2;
  var p3;

  if (isValueColor) {
    var rgba = [0, 0, 0, 0];
  }

  var onframe = function (target, percent) {
    // Find the range keyframes
    // kf1-----kf2---------current--------kf3
    // find kf2 and kf3 and do interpolation
    var frame; // In the easing function like elasticOut, percent may less than 0

    if (percent < 0) {
      frame = 0;
    } else if (percent < lastFramePercent) {
      // Start from next key
      // PENDING start from lastFrame ?
      start = Math.min(lastFrame + 1, trackLen - 1);

      for (frame = start; frame >= 0; frame--) {
        if (kfPercents[frame] <= percent) {
          break;
        }
      } // PENDING really need to do this ?


      frame = Math.min(frame, trackLen - 2);
    } else {
      for (frame = lastFrame; frame < trackLen; frame++) {
        if (kfPercents[frame] > percent) {
          break;
        }
      }

      frame = Math.min(frame - 1, trackLen - 2);
    }

    lastFrame = frame;
    lastFramePercent = percent;
    var range = kfPercents[frame + 1] - kfPercents[frame];

    if (range === 0) {
      return;
    } else {
      w = (percent - kfPercents[frame]) / range;
    }

    if (useSpline) {
      p1 = kfValues[frame];
      p0 = kfValues[frame === 0 ? frame : frame - 1];
      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];

      if (isValueArray) {
        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
      } else {
        var value;

        if (isValueColor) {
          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
          value = rgba2String(rgba);
        } else if (isValueString) {
          // String is step(0.5)
          return interpolateString(p1, p2, w);
        } else {
          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
        }

        setter(target, propName, value);
      }
    } else {
      if (isValueArray) {
        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
      } else {
        var value;

        if (isValueColor) {
          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
          value = rgba2String(rgba);
        } else if (isValueString) {
          // String is step(0.5)
          return interpolateString(kfValues[frame], kfValues[frame + 1], w);
        } else {
          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
        }

        setter(target, propName, value);
      }
    }
  };

  var clip = new Clip({
    target: animator._target,
    life: trackMaxTime,
    loop: animator._loop,
    delay: animator._delay,
    onframe: onframe,
    ondestroy: oneTrackDone
  });

  if (easing && easing !== 'spline') {
    clip.easing = easing;
  }

  return clip;
}
/**
 * @alias module:zrender/animation/Animator
 * @constructor
 * @param {Object} target
 * @param {boolean} loop
 * @param {Function} getter
 * @param {Function} setter
 */


var Animator = function (target, loop, getter, setter) {
  this._tracks = {};
  this._target = target;
  this._loop = loop || false;
  this._getter = getter || defaultGetter;
  this._setter = setter || defaultSetter;
  this._clipCount = 0;
  this._delay = 0;
  this._doneList = [];
  this._onframeList = [];
  this._clipList = [];
};

Animator.prototype = {
  /**
   * 设置动画关键帧
   * @param  {number} time 关键帧时间，单位是ms
   * @param  {Object} props 关键帧的属性值，key-value表示
   * @return {module:zrender/animation/Animator}
   */
  when: function (time
  /* ms */
  , props) {
    var tracks = this._tracks;

    for (var propName in props) {
      if (!props.hasOwnProperty(propName)) {
        continue;
      }

      if (!tracks[propName]) {
        tracks[propName] = []; // Invalid value

        var value = this._getter(this._target, propName);

        if (value == null) {
          // zrLog('Invalid property ' + propName);
          continue;
        } // If time is 0
        //  Then props is given initialize value
        // Else
        //  Initialize value from current prop value


        if (time !== 0) {
          tracks[propName].push({
            time: 0,
            value: cloneValue(value)
          });
        }
      }

      tracks[propName].push({
        time: time,
        value: props[propName]
      });
    }

    return this;
  },

  /**
   * 添加动画每一帧的回调函数
   * @param  {Function} callback
   * @return {module:zrender/animation/Animator}
   */
  during: function (callback) {
    this._onframeList.push(callback);

    return this;
  },
  pause: function () {
    for (var i = 0; i < this._clipList.length; i++) {
      this._clipList[i].pause();
    }

    this._paused = true;
  },
  resume: function () {
    for (var i = 0; i < this._clipList.length; i++) {
      this._clipList[i].resume();
    }

    this._paused = false;
  },
  isPaused: function () {
    return !!this._paused;
  },
  _doneCallback: function () {
    // Clear all tracks
    this._tracks = {}; // Clear all clips

    this._clipList.length = 0;
    var doneList = this._doneList;
    var len = doneList.length;

    for (var i = 0; i < len; i++) {
      doneList[i].call(this);
    }
  },

  /**
   * 开始执行动画
   * @param  {string|Function} [easing]
   *         动画缓动函数，详见{@link module:zrender/animation/easing}
   * @param  {boolean} forceAnimate
   * @return {module:zrender/animation/Animator}
   */
  start: function (easing, forceAnimate) {
    var self = this;
    var clipCount = 0;

    var oneTrackDone = function () {
      clipCount--;

      if (!clipCount) {
        self._doneCallback();
      }
    };

    var lastClip;

    for (var propName in this._tracks) {
      if (!this._tracks.hasOwnProperty(propName)) {
        continue;
      }

      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);

      if (clip) {
        this._clipList.push(clip);

        clipCount++; // If start after added to animation

        if (this.animation) {
          this.animation.addClip(clip);
        }

        lastClip = clip;
      }
    } // Add during callback on the last clip


    if (lastClip) {
      var oldOnFrame = lastClip.onframe;

      lastClip.onframe = function (target, percent) {
        oldOnFrame(target, percent);

        for (var i = 0; i < self._onframeList.length; i++) {
          self._onframeList[i](target, percent);
        }
      };
    } // This optimization will help the case that in the upper application
    // the view may be refreshed frequently, where animation will be
    // called repeatly but nothing changed.


    if (!clipCount) {
      this._doneCallback();
    }

    return this;
  },

  /**
   * 停止动画
   * @param {boolean} forwardToLast If move to last frame before stop
   */
  stop: function (forwardToLast) {
    var clipList = this._clipList;
    var animation = this.animation;

    for (var i = 0; i < clipList.length; i++) {
      var clip = clipList[i];

      if (forwardToLast) {
        // Move to last frame before stop
        clip.onframe(this._target, 1);
      }

      animation && animation.removeClip(clip);
    }

    clipList.length = 0;
  },

  /**
   * 设置动画延迟开始的时间
   * @param  {number} time 单位ms
   * @return {module:zrender/animation/Animator}
   */
  delay: function (time) {
    this._delay = time;
    return this;
  },

  /**
   * 添加动画结束的回调
   * @param  {Function} cb
   * @return {module:zrender/animation/Animator}
   */
  done: function (cb) {
    if (cb) {
      this._doneList.push(cb);
    }

    return this;
  },

  /**
   * @return {Array.<module:zrender/animation/Clip>}
   */
  getClips: function () {
    return this._clipList;
  }
};
var _default = Animator;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/animation/Clip.js":
/***/ (function(module, exports, __webpack_require__) {

var easingFuncs = __webpack_require__("./node_modules/zrender/lib/animation/easing.js");

/**
 * 动画主控制器
 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
 * @config life(1000) 动画时长
 * @config delay(0) 动画延迟时间
 * @config loop(true)
 * @config gap(0) 循环的间隔时间
 * @config onframe
 * @config easing(optional)
 * @config ondestroy(optional)
 * @config onrestart(optional)
 *
 * TODO pause
 */
function Clip(options) {
  this._target = options.target; // 生命周期

  this._life = options.life || 1000; // 延时

  this._delay = options.delay || 0; // 开始时间
  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒

  this._initialized = false; // 是否循环

  this.loop = options.loop == null ? false : options.loop;
  this.gap = options.gap || 0;
  this.easing = options.easing || 'Linear';
  this.onframe = options.onframe;
  this.ondestroy = options.ondestroy;
  this.onrestart = options.onrestart;
  this._pausedTime = 0;
  this._paused = false;
}

Clip.prototype = {
  constructor: Clip,
  step: function (globalTime, deltaTime) {
    // Set startTime on first step, or _startTime may has milleseconds different between clips
    // PENDING
    if (!this._initialized) {
      this._startTime = globalTime + this._delay;
      this._initialized = true;
    }

    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }

    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始

    if (percent < 0) {
      return;
    }

    percent = Math.min(percent, 1);
    var easing = this.easing;
    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
    this.fire('frame', schedule); // 结束

    if (percent == 1) {
      if (this.loop) {
        this.restart(globalTime); // 重新开始周期
        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件

        return 'restart';
      } // 动画完成将这个控制器标识为待删除
      // 在Animation.update中进行批量删除


      this._needsRemove = true;
      return 'destroy';
    }

    return null;
  },
  restart: function (globalTime) {
    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
    this._startTime = globalTime - remainder + this.gap;
    this._pausedTime = 0;
    this._needsRemove = false;
  },
  fire: function (eventType, arg) {
    eventType = 'on' + eventType;

    if (this[eventType]) {
      this[eventType](this._target, arg);
    }
  },
  pause: function () {
    this._paused = true;
  },
  resume: function () {
    this._paused = false;
  }
};
var _default = Clip;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/animation/easing.js":
/***/ (function(module, exports) {

/**
 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
 * @see http://sole.github.io/tween.js/examples/03_graphs.html
 * @exports zrender/animation/easing
 */
var easing = {
  /**
  * @param {number} k
  * @return {number}
  */
  linear: function (k) {
    return k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticIn: function (k) {
    return k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticOut: function (k) {
    return k * (2 - k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }

    return -0.5 * (--k * (k - 2) - 1);
  },
  // 三次方的缓动（t^3）

  /**
  * @param {number} k
  * @return {number}
  */
  cubicIn: function (k) {
    return k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  cubicOut: function (k) {
    return --k * k * k + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  cubicInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k;
    }

    return 0.5 * ((k -= 2) * k * k + 2);
  },
  // 四次方的缓动（t^4）

  /**
  * @param {number} k
  * @return {number}
  */
  quarticIn: function (k) {
    return k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quarticOut: function (k) {
    return 1 - --k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quarticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k;
    }

    return -0.5 * ((k -= 2) * k * k * k - 2);
  },
  // 五次方的缓动（t^5）

  /**
  * @param {number} k
  * @return {number}
  */
  quinticIn: function (k) {
    return k * k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quinticOut: function (k) {
    return --k * k * k * k * k + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quinticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k * k;
    }

    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  },
  // 正弦曲线的缓动（sin(t)）

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalIn: function (k) {
    return 1 - Math.cos(k * Math.PI / 2);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalOut: function (k) {
    return Math.sin(k * Math.PI / 2);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalInOut: function (k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  },
  // 指数曲线的缓动（2^t）

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialIn: function (k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialOut: function (k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialInOut: function (k) {
    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if ((k *= 2) < 1) {
      return 0.5 * Math.pow(1024, k - 1);
    }

    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  },
  // 圆形曲线的缓动（sqrt(1-t^2)）

  /**
  * @param {number} k
  * @return {number}
  */
  circularIn: function (k) {
    return 1 - Math.sqrt(1 - k * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  circularOut: function (k) {
    return Math.sqrt(1 - --k * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  circularInOut: function (k) {
    if ((k *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k * k) - 1);
    }

    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  },
  // 创建类似于弹簧在停止前来回振荡的动画

  /**
  * @param {number} k
  * @return {number}
  */
  elasticIn: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
  },

  /**
  * @param {number} k
  * @return {number}
  */
  elasticOut: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  elasticInOut: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    if ((k *= 2) < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    }

    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
  },
  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动

  /**
  * @param {number} k
  * @return {number}
  */
  backIn: function (k) {
    var s = 1.70158;
    return k * k * ((s + 1) * k - s);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  backOut: function (k) {
    var s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  backInOut: function (k) {
    var s = 1.70158 * 1.525;

    if ((k *= 2) < 1) {
      return 0.5 * (k * k * ((s + 1) * k - s));
    }

    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
  },
  // 创建弹跳效果

  /**
  * @param {number} k
  * @return {number}
  */
  bounceIn: function (k) {
    return 1 - easing.bounceOut(1 - k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  bounceOut: function (k) {
    if (k < 1 / 2.75) {
      return 7.5625 * k * k;
    } else if (k < 2 / 2.75) {
      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
    } else if (k < 2.5 / 2.75) {
      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
    }
  },

  /**
  * @param {number} k
  * @return {number}
  */
  bounceInOut: function (k) {
    if (k < 0.5) {
      return easing.bounceIn(k * 2) * 0.5;
    }

    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }
};
var _default = easing;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/animation/requestAnimationFrame.js":
/***/ (function(module, exports) {

var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
  setTimeout(func, 16);
};

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/config.js":
/***/ (function(module, exports) {

var dpr = 1; // If in browser environment

if (typeof window !== 'undefined') {
  dpr = Math.max(window.devicePixelRatio || 1, 1);
}
/**
 * config默认配置项
 * @exports zrender/config
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */

/**
 * debug日志选项：catchBrushException为true下有效
 * 0 : 不生成debug数据，发布用
 * 1 : 异常抛出，调试用
 * 2 : 控制台输出，调试用
 */


var debugMode = 0; // retina 屏幕优化

var devicePixelRatio = dpr;
exports.debugMode = debugMode;
exports.devicePixelRatio = devicePixelRatio;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/arc.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/contain/util.js");

var normalizeRadian = _util.normalizeRadian;
var PI2 = Math.PI * 2;
/**
 * 圆弧描边包含判断
 * @param  {number}  cx
 * @param  {number}  cy
 * @param  {number}  r
 * @param  {number}  startAngle
 * @param  {number}  endAngle
 * @param  {boolean}  anticlockwise
 * @param  {number} lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {Boolean}
 */

function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth;
  x -= cx;
  y -= cy;
  var d = Math.sqrt(x * x + y * y);

  if (d - _l > r || d + _l < r) {
    return false;
  }

  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
    // Is a circle
    return true;
  }

  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }

  if (startAngle > endAngle) {
    endAngle += PI2;
  }

  var angle = Math.atan2(y, x);

  if (angle < 0) {
    angle += PI2;
  }

  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/cubic.js":
/***/ (function(module, exports, __webpack_require__) {

var curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

/**
 * 三次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  x3
 * @param  {number}  y3
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth; // Quick reject

  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
    return false;
  }

  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
  return d <= _l / 2;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/line.js":
/***/ (function(module, exports) {

/**
 * 线段包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth;
  var _a = 0;
  var _b = x0; // Quick reject

  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
    return false;
  }

  if (x0 !== x1) {
    _a = (y0 - y1) / (x0 - x1);
    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x - x0) <= _l / 2;
  }

  var tmp = _a * x - y + _b;

  var _s = tmp * tmp / (_a * _a + 1);

  return _s <= _l / 2 * _l / 2;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/path.js":
/***/ (function(module, exports, __webpack_require__) {

var PathProxy = __webpack_require__("./node_modules/zrender/lib/core/PathProxy.js");

var line = __webpack_require__("./node_modules/zrender/lib/contain/line.js");

var cubic = __webpack_require__("./node_modules/zrender/lib/contain/cubic.js");

var quadratic = __webpack_require__("./node_modules/zrender/lib/contain/quadratic.js");

var arc = __webpack_require__("./node_modules/zrender/lib/contain/arc.js");

var _util = __webpack_require__("./node_modules/zrender/lib/contain/util.js");

var normalizeRadian = _util.normalizeRadian;

var curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

var windingLine = __webpack_require__("./node_modules/zrender/lib/contain/windingLine.js");

var CMD = PathProxy.CMD;
var PI2 = Math.PI * 2;
var EPSILON = 1e-4;

function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
} // 临时数组


var roots = [-1, -1, -1];
var extrema = [-1, -1];

function swapExtrema() {
  var tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}

function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  // Quick reject
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
    return 0;
  }

  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);

  if (nRoots === 0) {
    return 0;
  } else {
    var w = 0;
    var nExtrema = -1;
    var y0_, y1_;

    for (var i = 0; i < nRoots; i++) {
      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon

      var unit = t === 0 || t === 1 ? 0.5 : 1;
      var x_ = curve.cubicAt(x0, x1, x2, x3, t);

      if (x_ < x) {
        // Quick reject
        continue;
      }

      if (nExtrema < 0) {
        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);

        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }

        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);

        if (nExtrema > 1) {
          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
        }
      }

      if (nExtrema == 2) {
        // 分成三段单调函数
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else if (t < extrema[1]) {
          w += y1_ < y0_ ? unit : -unit;
        } else {
          w += y3 < y1_ ? unit : -unit;
        }
      } else {
        // 分成两段单调函数
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else {
          w += y3 < y0_ ? unit : -unit;
        }
      }
    }

    return w;
  }
}

function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  // Quick reject
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
    return 0;
  }

  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);

  if (nRoots === 0) {
    return 0;
  } else {
    var t = curve.quadraticExtremum(y0, y1, y2);

    if (t >= 0 && t <= 1) {
      var w = 0;
      var y_ = curve.quadraticAt(y0, y1, y2, t);

      for (var i = 0; i < nRoots; i++) {
        // Remove one endpoint.
        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);

        if (x_ < x) {
          // Quick reject
          continue;
        }

        if (roots[i] < t) {
          w += y_ < y0 ? unit : -unit;
        } else {
          w += y2 < y_ ? unit : -unit;
        }
      }

      return w;
    } else {
      // Remove one endpoint.
      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);

      if (x_ < x) {
        // Quick reject
        return 0;
      }

      return y2 < y0 ? unit : -unit;
    }
  }
} // TODO
// Arc 旋转


function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  y -= cy;

  if (y > r || y < -r) {
    return 0;
  }

  var tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp;
  roots[1] = tmp;
  var diff = Math.abs(startAngle - endAngle);

  if (diff < 1e-4) {
    return 0;
  }

  if (diff % PI2 < 1e-4) {
    // Is a circle
    startAngle = 0;
    endAngle = PI2;
    var dir = anticlockwise ? 1 : -1;

    if (x >= roots[0] + cx && x <= roots[1] + cx) {
      return dir;
    } else {
      return 0;
    }
  }

  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }

  if (startAngle > endAngle) {
    endAngle += PI2;
  }

  var w = 0;

  for (var i = 0; i < 2; i++) {
    var x_ = roots[i];

    if (x_ + cx > x) {
      var angle = Math.atan2(y, x_);
      var dir = anticlockwise ? 1 : -1;

      if (angle < 0) {
        angle = PI2 + angle;
      }

      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir = -dir;
        }

        w += dir;
      }
    }
  }

  return w;
}

function containPath(data, lineWidth, isStroke, x, y) {
  var w = 0;
  var xi = 0;
  var yi = 0;
  var x0 = 0;
  var y0 = 0;

  for (var i = 0; i < data.length;) {
    var cmd = data[i++]; // Begin a new subpath

    if (cmd === CMD.M && i > 1) {
      // Close previous subpath
      if (!isStroke) {
        w += windingLine(xi, yi, x0, y0, x, y);
      } // 如果被任何一个 subpath 包含
      // if (w !== 0) {
      //     return true;
      // }

    }

    if (i == 1) {
      // 如果第一个命令是 L, C, Q
      // 则 previous point 同绘制命令的第一个 point
      //
      // 第一个命令为 Arc 的情况下会在后面特殊处理
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }

    switch (cmd) {
      case CMD.M:
        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
        // 在 closePath 的时候使用
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;

      case CMD.L:
        if (isStroke) {
          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.C:
        if (isStroke) {
          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.Q:
        if (isStroke) {
          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.A:
        // TODO Arc 判断的开销比较大
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++]; // TODO Arc 旋转

        var psi = data[i++];
        var anticlockwise = 1 - data[i++];
        var x1 = Math.cos(theta) * rx + cx;
        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令

        if (i > 1) {
          w += windingLine(xi, yi, x1, y1, x, y);
        } else {
          // 第一个命令起点还未定义
          x0 = x1;
          y0 = y1;
        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放


        var _x = (x - cx) * ry / rx + cx;

        if (isStroke) {
          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
            return true;
          }
        } else {
          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
        }

        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;

      case CMD.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        var width = data[i++];
        var height = data[i++];
        var x1 = x0 + width;
        var y1 = y0 + height;

        if (isStroke) {
          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          // FIXME Clockwise ?
          w += windingLine(x1, y0, x1, y1, x, y);
          w += windingLine(x0, y1, x0, y0, x, y);
        }

        break;

      case CMD.Z:
        if (isStroke) {
          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          // Close a subpath
          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
          // FIXME subpaths may overlap
          // if (w !== 0) {
          //     return true;
          // }
        }

        xi = x0;
        yi = y0;
        break;
    }
  }

  if (!isStroke && !isAroundEqual(yi, y0)) {
    w += windingLine(xi, yi, x0, y0, x, y) || 0;
  }

  return w !== 0;
}

function contain(pathData, x, y) {
  return containPath(pathData, 0, false, x, y);
}

function containStroke(pathData, lineWidth, x, y) {
  return containPath(pathData, lineWidth, true, x, y);
}

exports.contain = contain;
exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/polygon.js":
/***/ (function(module, exports, __webpack_require__) {

var windingLine = __webpack_require__("./node_modules/zrender/lib/contain/windingLine.js");

var EPSILON = 1e-8;

function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}

function contain(points, x, y) {
  var w = 0;
  var p = points[0];

  if (!p) {
    return false;
  }

  for (var i = 1; i < points.length; i++) {
    var p2 = points[i];
    w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
    p = p2;
  } // Close polygon


  var p0 = points[0];

  if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {
    w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
  }

  return w !== 0;
}

exports.contain = contain;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/quadratic.js":
/***/ (function(module, exports, __webpack_require__) {

var _curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

var quadraticProjectPoint = _curve.quadraticProjectPoint;

/**
 * 二次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth; // Quick reject

  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
    return false;
  }

  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
  return d <= _l / 2;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/text.js":
/***/ (function(module, exports, __webpack_require__) {

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var imageHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/image.js");

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var getContext = _util.getContext;
var extend = _util.extend;
var retrieve2 = _util.retrieve2;
var retrieve3 = _util.retrieve3;
var textWidthCache = {};
var textWidthCacheCounter = 0;
var TEXT_CACHE_MAX = 5000;
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.

var methods = {};

function $override(name, fn) {
  methods[name] = fn;
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {number} width
 */


function getWidth(text, font) {
  font = font || DEFAULT_FONT;
  var key = text + ':' + font;

  if (textWidthCache[key]) {
    return textWidthCache[key];
  }

  var textLines = (text + '').split('\n');
  var width = 0;

  for (var i = 0, l = textLines.length; i < l; i++) {
    // textContain.measureText may be overrided in SVG or VML
    width = Math.max(measureText(textLines[i], font).width, width);
  }

  if (textWidthCacheCounter > TEXT_CACHE_MAX) {
    textWidthCacheCounter = 0;
    textWidthCache = {};
  }

  textWidthCacheCounter++;
  textWidthCache[key] = width;
  return width;
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {string} [textAlign='left']
 * @param {string} [textVerticalAlign='top']
 * @param {Array.<number>} [textPadding]
 * @param {Object} [rich]
 * @param {Object} [truncate]
 * @return {Object} {x, y, width, height, lineHeight}
 */


function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
}

function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
  var contentBlock = parsePlainText(text, font, textPadding, truncate);
  var outerWidth = getWidth(text, font);

  if (textPadding) {
    outerWidth += textPadding[1] + textPadding[3];
  }

  var outerHeight = contentBlock.outerHeight;
  var x = adjustTextX(0, outerWidth, textAlign);
  var y = adjustTextY(0, outerHeight, textVerticalAlign);
  var rect = new BoundingRect(x, y, outerWidth, outerHeight);
  rect.lineHeight = contentBlock.lineHeight;
  return rect;
}

function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
  var contentBlock = parseRichText(text, {
    rich: rich,
    truncate: truncate,
    font: font,
    textAlign: textAlign,
    textPadding: textPadding
  });
  var outerWidth = contentBlock.outerWidth;
  var outerHeight = contentBlock.outerHeight;
  var x = adjustTextX(0, outerWidth, textAlign);
  var y = adjustTextY(0, outerHeight, textVerticalAlign);
  return new BoundingRect(x, y, outerWidth, outerHeight);
}
/**
 * @public
 * @param {number} x
 * @param {number} width
 * @param {string} [textAlign='left']
 * @return {number} Adjusted x.
 */


function adjustTextX(x, width, textAlign) {
  // FIXME Right to left language
  if (textAlign === 'right') {
    x -= width;
  } else if (textAlign === 'center') {
    x -= width / 2;
  }

  return x;
}
/**
 * @public
 * @param {number} y
 * @param {number} height
 * @param {string} [textVerticalAlign='top']
 * @return {number} Adjusted y.
 */


function adjustTextY(y, height, textVerticalAlign) {
  if (textVerticalAlign === 'middle') {
    y -= height / 2;
  } else if (textVerticalAlign === 'bottom') {
    y -= height;
  }

  return y;
}
/**
 * @public
 * @param {stirng} textPosition
 * @param {Object} rect {x, y, width, height}
 * @param {number} distance
 * @return {Object} {x, y, textAlign, textVerticalAlign}
 */


function adjustTextPositionOnRect(textPosition, rect, distance) {
  var x = rect.x;
  var y = rect.y;
  var height = rect.height;
  var width = rect.width;
  var halfHeight = height / 2;
  var textAlign = 'left';
  var textVerticalAlign = 'top';

  switch (textPosition) {
    case 'left':
      x -= distance;
      y += halfHeight;
      textAlign = 'right';
      textVerticalAlign = 'middle';
      break;

    case 'right':
      x += distance + width;
      y += halfHeight;
      textVerticalAlign = 'middle';
      break;

    case 'top':
      x += width / 2;
      y -= distance;
      textAlign = 'center';
      textVerticalAlign = 'bottom';
      break;

    case 'bottom':
      x += width / 2;
      y += height + distance;
      textAlign = 'center';
      break;

    case 'inside':
      x += width / 2;
      y += halfHeight;
      textAlign = 'center';
      textVerticalAlign = 'middle';
      break;

    case 'insideLeft':
      x += distance;
      y += halfHeight;
      textVerticalAlign = 'middle';
      break;

    case 'insideRight':
      x += width - distance;
      y += halfHeight;
      textAlign = 'right';
      textVerticalAlign = 'middle';
      break;

    case 'insideTop':
      x += width / 2;
      y += distance;
      textAlign = 'center';
      break;

    case 'insideBottom':
      x += width / 2;
      y += height - distance;
      textAlign = 'center';
      textVerticalAlign = 'bottom';
      break;

    case 'insideTopLeft':
      x += distance;
      y += distance;
      break;

    case 'insideTopRight':
      x += width - distance;
      y += distance;
      textAlign = 'right';
      break;

    case 'insideBottomLeft':
      x += distance;
      y += height - distance;
      textVerticalAlign = 'bottom';
      break;

    case 'insideBottomRight':
      x += width - distance;
      y += height - distance;
      textAlign = 'right';
      textVerticalAlign = 'bottom';
      break;
  }

  return {
    x: x,
    y: y,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}
/**
 * Show ellipsis if overflow.
 *
 * @public
 * @param  {string} text
 * @param  {string} containerWidth
 * @param  {string} font
 * @param  {number} [ellipsis='...']
 * @param  {Object} [options]
 * @param  {number} [options.maxIterations=3]
 * @param  {number} [options.minChar=0] If truncate result are less
 *                  then minChar, ellipsis will not show, which is
 *                  better for user hint in some cases.
 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
 * @return {string}
 */


function truncateText(text, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    return '';
  }

  var textLines = (text + '').split('\n');
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
  // It is not appropriate that every line has '...' when truncate multiple lines.

  for (var i = 0, len = textLines.length; i < len; i++) {
    textLines[i] = truncateSingleLine(textLines[i], options);
  }

  return textLines.join('\n');
}

function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = extend({}, options);
  options.font = font;
  var ellipsis = retrieve2(ellipsis, '...');
  options.maxIterations = retrieve2(options.maxIterations, 2);
  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME
  // Other languages?

  options.cnCharWidth = getWidth('国', font); // FIXME
  // Consider proportional font?

  var ascCharWidth = options.ascCharWidth = getWidth('a', font);
  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.

  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.

  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
    contentWidth -= ascCharWidth;
  }

  var ellipsisWidth = getWidth(ellipsis);

  if (ellipsisWidth > contentWidth) {
    ellipsis = '';
    ellipsisWidth = 0;
  }

  contentWidth = containerWidth - ellipsisWidth;
  options.ellipsis = ellipsis;
  options.ellipsisWidth = ellipsisWidth;
  options.contentWidth = contentWidth;
  options.containerWidth = containerWidth;
  return options;
}

function truncateSingleLine(textLine, options) {
  var containerWidth = options.containerWidth;
  var font = options.font;
  var contentWidth = options.contentWidth;

  if (!containerWidth) {
    return '';
  }

  var lineWidth = getWidth(textLine, font);

  if (lineWidth <= containerWidth) {
    return textLine;
  }

  for (var j = 0;; j++) {
    if (lineWidth <= contentWidth || j >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }

    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth(textLine, font);
  }

  if (textLine === '') {
    textLine = options.placeholder;
  }

  return textLine;
}

function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
  var width = 0;
  var i = 0;

  for (var len = text.length; i < len && width < contentWidth; i++) {
    var charCode = text.charCodeAt(i);
    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }

  return i;
}
/**
 * @public
 * @param {string} font
 * @return {number} line height
 */


function getLineHeight(font) {
  // FIXME A rough approach.
  return getWidth('国', font);
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {Object} width
 */


function measureText(text, font) {
  return methods.measureText(text, font);
} // Avoid assign to an exported variable, for transforming to cjs.


methods.measureText = function (text, font) {
  var ctx = getContext();
  ctx.font = font || DEFAULT_FONT;
  return ctx.measureText(text);
};
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {Object} [truncate]
 * @return {Object} block: {lineHeight, lines, height, outerHeight}
 *  Notice: for performance, do not calculate outerWidth util needed.
 */


function parsePlainText(text, font, padding, truncate) {
  text != null && (text += '');
  var lineHeight = getLineHeight(font);
  var lines = text ? text.split('\n') : [];
  var height = lines.length * lineHeight;
  var outerHeight = height;

  if (padding) {
    outerHeight += padding[0] + padding[2];
  }

  if (text && truncate) {
    var truncOuterHeight = truncate.outerHeight;
    var truncOuterWidth = truncate.outerWidth;

    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
      text = '';
      lines = [];
    } else if (truncOuterWidth != null) {
      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
        minChar: truncate.minChar,
        placeholder: truncate.placeholder
      }); // FIXME
      // It is not appropriate that every line has '...' when truncate multiple lines.

      for (var i = 0, len = lines.length; i < len; i++) {
        lines[i] = truncateSingleLine(lines[i], options);
      }
    }
  }

  return {
    lines: lines,
    height: height,
    outerHeight: outerHeight,
    lineHeight: lineHeight
  };
}
/**
 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
 *
 * @public
 * @param {string} text
 * @param {Object} style
 * @return {Object} block
 * {
 *      width,
 *      height,
 *      lines: [{
 *          lineHeight,
 *          width,
 *          tokens: [[{
 *              styleName,
 *              text,
 *              width,      // include textPadding
 *              height,     // include textPadding
 *              textWidth, // pure text width
 *              textHeight, // pure text height
 *              lineHeihgt,
 *              font,
 *              textAlign,
 *              textVerticalAlign
 *          }], [...], ...]
 *      }, ...]
 * }
 * If styleName is undefined, it is plain text.
 */


function parseRichText(text, style) {
  var contentBlock = {
    lines: [],
    width: 0,
    height: 0
  };
  text != null && (text += '');

  if (!text) {
    return contentBlock;
  }

  var lastIndex = STYLE_REG.lastIndex = 0;
  var result;

  while ((result = STYLE_REG.exec(text)) != null) {
    var matchedIndex = result.index;

    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
    }

    pushTokens(contentBlock, result[2], result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }

  if (lastIndex < text.length) {
    pushTokens(contentBlock, text.substring(lastIndex, text.length));
  }

  var lines = contentBlock.lines;
  var contentHeight = 0;
  var contentWidth = 0; // For `textWidth: 100%`

  var pendingList = [];
  var stlPadding = style.textPadding;
  var truncate = style.truncate;
  var truncateWidth = truncate && truncate.outerWidth;
  var truncateHeight = truncate && truncate.outerHeight;

  if (stlPadding) {
    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
  } // Calculate layout info of tokens.


  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var lineHeight = 0;
    var lineWidth = 0;

    for (var j = 0; j < line.tokens.length; j++) {
      var token = line.tokens[j];
      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.

      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.

      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.

      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified
      // as box height of the block.
      tokenStyle.textHeight, getLineHeight(font));
      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
      token.height = tokenHeight;
      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';

      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
        return {
          lines: [],
          width: 0,
          height: 0
        };
      }

      token.textWidth = getWidth(token.text, font);
      var tokenWidth = tokenStyle.textWidth;
      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
      // line when box width is needed to be auto.

      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
        token.percentWidth = tokenWidth;
        pendingList.push(token);
        tokenWidth = 0; // Do not truncate in this case, because there is no user case
        // and it is too complicated.
      } else {
        if (tokenWidthNotSpecified) {
          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
          // `getBoundingRect()` will not get correct result.

          var textBackgroundColor = tokenStyle.textBackgroundColor;
          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
          // (1) If image is not loaded, it will be loaded at render phase and call
          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
          // image, and then the right size will be calculated here at the next tick.
          // See `graphic/helper/text.js`.
          // (2) If image loaded, and `textBackgroundColor.image` is image src string,
          // use `imageHelper.findExistImage` to find cached image.
          // `imageHelper.findExistImage` will always be called here before
          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
          // which ensures that image will not be rendered before correct size calcualted.

          if (bgImg) {
            bgImg = imageHelper.findExistImage(bgImg);

            if (imageHelper.isImageReady(bgImg)) {
              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
            }
          }
        }

        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
        tokenWidth += paddingW;
        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;

        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
            token.text = '';
            token.textWidth = tokenWidth = 0;
          } else {
            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
              minChar: truncate.minChar
            });
            token.textWidth = getWidth(token.text, font);
            tokenWidth = token.textWidth + paddingW;
          }
        }
      }

      lineWidth += token.width = tokenWidth;
      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
    }

    line.width = lineWidth;
    line.lineHeight = lineHeight;
    contentHeight += lineHeight;
    contentWidth = Math.max(contentWidth, lineWidth);
  }

  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);

  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }

  for (var i = 0; i < pendingList.length; i++) {
    var token = pendingList[i];
    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.

    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
  }

  return contentBlock;
}

function pushTokens(block, str, styleName) {
  var isEmptyStr = str === '';
  var strs = str.split('\n');
  var lines = block.lines;

  for (var i = 0; i < strs.length; i++) {
    var text = strs[i];
    var token = {
      styleName: styleName,
      text: text,
      isLineHolder: !text && !isEmptyStr
    }; // The first token should be appended to the last line.

    if (!i) {
      var tokens = (lines[lines.length - 1] || (lines[0] = {
        tokens: []
      })).tokens; // Consider cases:
      // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
      // (which is a placeholder) should be replaced by new token.
      // (2) A image backage, where token likes {a|}.
      // (3) A redundant '' will affect textAlign in line.
      // (4) tokens with the same tplName should not be merged, because
      // they should be displayed in different box (with border and padding).

      var tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
      // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
      (text || !tokensLen || isEmptyStr) && tokens.push(token);
    } // Other tokens always start a new line.
    else {
        // If there is '', insert it as a placeholder.
        lines.push({
          tokens: [token]
        });
      }
  }
}

function makeFont(style) {
  // FIXME in node-canvas fontWeight is before fontStyle
  // Use `fontSize` `fontFamily` to check whether font properties are defined.
  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;
}

exports.DEFAULT_FONT = DEFAULT_FONT;
exports.$override = $override;
exports.getWidth = getWidth;
exports.getBoundingRect = getBoundingRect;
exports.adjustTextX = adjustTextX;
exports.adjustTextY = adjustTextY;
exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
exports.truncateText = truncateText;
exports.getLineHeight = getLineHeight;
exports.measureText = measureText;
exports.parsePlainText = parsePlainText;
exports.parseRichText = parseRichText;
exports.makeFont = makeFont;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/util.js":
/***/ (function(module, exports) {

var PI2 = Math.PI * 2;

function normalizeRadian(angle) {
  angle %= PI2;

  if (angle < 0) {
    angle += PI2;
  }

  return angle;
}

exports.normalizeRadian = normalizeRadian;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/windingLine.js":
/***/ (function(module, exports) {

function windingLine(x0, y0, x1, y1, x, y) {
  if (y > y0 && y > y1 || y < y0 && y < y1) {
    return 0;
  } // Ignore horizontal line


  if (y1 === y0) {
    return 0;
  }

  var dir = y1 < y0 ? 1 : -1;
  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon

  if (t === 1 || t === 0) {
    dir = y1 < y0 ? 0.5 : -0.5;
  }

  var x_ = t * (x1 - x0) + x0;
  return x_ > x ? dir : 0;
}

module.exports = windingLine;

/***/ }),

/***/ "./node_modules/zrender/lib/container/Group.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Element = __webpack_require__("./node_modules/zrender/lib/Element.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

/**
 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
 * @module zrender/graphic/Group
 * @example
 *     var Group = require('zrender/container/Group');
 *     var Circle = require('zrender/graphic/shape/Circle');
 *     var g = new Group();
 *     g.position[0] = 100;
 *     g.position[1] = 100;
 *     g.add(new Circle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 20,
 *         }
 *     }));
 *     zr.add(g);
 */

/**
 * @alias module:zrender/graphic/Group
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @extends module:zrender/mixin/Eventful
 */
var Group = function (opts) {
  opts = opts || {};
  Element.call(this, opts);

  for (var key in opts) {
    if (opts.hasOwnProperty(key)) {
      this[key] = opts[key];
    }
  }

  this._children = [];
  this.__storage = null;
  this.__dirty = true;
};

Group.prototype = {
  constructor: Group,
  isGroup: true,

  /**
   * @type {string}
   */
  type: 'group',

  /**
   * 所有子孙元素是否响应鼠标事件
   * @name module:/zrender/container/Group#silent
   * @type {boolean}
   * @default false
   */
  silent: false,

  /**
   * @return {Array.<module:zrender/Element>}
   */
  children: function () {
    return this._children.slice();
  },

  /**
   * 获取指定 index 的儿子节点
   * @param  {number} idx
   * @return {module:zrender/Element}
   */
  childAt: function (idx) {
    return this._children[idx];
  },

  /**
   * 获取指定名字的儿子节点
   * @param  {string} name
   * @return {module:zrender/Element}
   */
  childOfName: function (name) {
    var children = this._children;

    for (var i = 0; i < children.length; i++) {
      if (children[i].name === name) {
        return children[i];
      }
    }
  },

  /**
   * @return {number}
   */
  childCount: function () {
    return this._children.length;
  },

  /**
   * 添加子节点到最后
   * @param {module:zrender/Element} child
   */
  add: function (child) {
    if (child && child !== this && child.parent !== this) {
      this._children.push(child);

      this._doAdd(child);
    }

    return this;
  },

  /**
   * 添加子节点在 nextSibling 之前
   * @param {module:zrender/Element} child
   * @param {module:zrender/Element} nextSibling
   */
  addBefore: function (child, nextSibling) {
    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
      var children = this._children;
      var idx = children.indexOf(nextSibling);

      if (idx >= 0) {
        children.splice(idx, 0, child);

        this._doAdd(child);
      }
    }

    return this;
  },
  _doAdd: function (child) {
    if (child.parent) {
      child.parent.remove(child);
    }

    child.parent = this;
    var storage = this.__storage;
    var zr = this.__zr;

    if (storage && storage !== child.__storage) {
      storage.addToStorage(child);

      if (child instanceof Group) {
        child.addChildrenToStorage(storage);
      }
    }

    zr && zr.refresh();
  },

  /**
   * 移除子节点
   * @param {module:zrender/Element} child
   */
  remove: function (child) {
    var zr = this.__zr;
    var storage = this.__storage;
    var children = this._children;
    var idx = zrUtil.indexOf(children, child);

    if (idx < 0) {
      return this;
    }

    children.splice(idx, 1);
    child.parent = null;

    if (storage) {
      storage.delFromStorage(child);

      if (child instanceof Group) {
        child.delChildrenFromStorage(storage);
      }
    }

    zr && zr.refresh();
    return this;
  },

  /**
   * 移除所有子节点
   */
  removeAll: function () {
    var children = this._children;
    var storage = this.__storage;
    var child;
    var i;

    for (i = 0; i < children.length; i++) {
      child = children[i];

      if (storage) {
        storage.delFromStorage(child);

        if (child instanceof Group) {
          child.delChildrenFromStorage(storage);
        }
      }

      child.parent = null;
    }

    children.length = 0;
    return this;
  },

  /**
   * 遍历所有子节点
   * @param  {Function} cb
   * @param  {}   context
   */
  eachChild: function (cb, context) {
    var children = this._children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      cb.call(context, child, i);
    }

    return this;
  },

  /**
   * 深度优先遍历所有子孙节点
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      cb.call(context, child);

      if (child.type === 'group') {
        child.traverse(cb, context);
      }
    }

    return this;
  },
  addChildrenToStorage: function (storage) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      storage.addToStorage(child);

      if (child instanceof Group) {
        child.addChildrenToStorage(storage);
      }
    }
  },
  delChildrenFromStorage: function (storage) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      storage.delFromStorage(child);

      if (child instanceof Group) {
        child.delChildrenFromStorage(storage);
      }
    }
  },
  dirty: function () {
    this.__dirty = true;
    this.__zr && this.__zr.refresh();
    return this;
  },

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function (includeChildren) {
    // TODO Caching
    var rect = null;
    var tmpRect = new BoundingRect(0, 0, 0, 0);
    var children = includeChildren || this._children;
    var tmpMat = [];

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (child.ignore || child.invisible) {
        continue;
      }

      var childRect = child.getBoundingRect();
      var transform = child.getLocalTransform(tmpMat); // TODO
      // The boundingRect cacluated by transforming original
      // rect may be bigger than the actual bundingRect when rotation
      // is used. (Consider a circle rotated aginst its center, where
      // the actual boundingRect should be the same as that not be
      // rotated.) But we can not find better approach to calculate
      // actual boundingRect yet, considering performance.

      if (transform) {
        tmpRect.copy(childRect);
        tmpRect.applyTransform(transform);
        rect = rect || tmpRect.clone();
        rect.union(tmpRect);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }

    return rect || tmpRect;
  }
};
zrUtil.inherits(Group, Element);
var _default = Group;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/BoundingRect.js":
/***/ (function(module, exports, __webpack_require__) {

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var matrix = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

/**
 * @module echarts/core/BoundingRect
 */
var v2ApplyTransform = vec2.applyTransform;
var mathMin = Math.min;
var mathMax = Math.max;
/**
 * @alias module:echarts/core/BoundingRect
 */

function BoundingRect(x, y, width, height) {
  if (width < 0) {
    x = x + width;
    width = -width;
  }

  if (height < 0) {
    y = y + height;
    height = -height;
  }
  /**
   * @type {number}
   */


  this.x = x;
  /**
   * @type {number}
   */

  this.y = y;
  /**
   * @type {number}
   */

  this.width = width;
  /**
   * @type {number}
   */

  this.height = height;
}

BoundingRect.prototype = {
  constructor: BoundingRect,

  /**
   * @param {module:echarts/core/BoundingRect} other
   */
  union: function (other) {
    var x = mathMin(other.x, this.x);
    var y = mathMin(other.y, this.y);
    this.width = mathMax(other.x + other.width, this.x + this.width) - x;
    this.height = mathMax(other.y + other.height, this.y + this.height) - y;
    this.x = x;
    this.y = y;
  },

  /**
   * @param {Array.<number>} m
   * @methods
   */
  applyTransform: function () {
    var lt = [];
    var rb = [];
    var lb = [];
    var rt = [];
    return function (m) {
      // In case usage like this
      // el.getBoundingRect().applyTransform(el.transform)
      // And element has no transform
      if (!m) {
        return;
      }

      lt[0] = lb[0] = this.x;
      lt[1] = rt[1] = this.y;
      rb[0] = rt[0] = this.x + this.width;
      rb[1] = lb[1] = this.y + this.height;
      v2ApplyTransform(lt, lt, m);
      v2ApplyTransform(rb, rb, m);
      v2ApplyTransform(lb, lb, m);
      v2ApplyTransform(rt, rt, m);
      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
      this.width = maxX - this.x;
      this.height = maxY - this.y;
    };
  }(),

  /**
   * Calculate matrix of transforming from self to target rect
   * @param  {module:zrender/core/BoundingRect} b
   * @return {Array.<number>}
   */
  calculateTransform: function (b) {
    var a = this;
    var sx = b.width / a.width;
    var sy = b.height / a.height;
    var m = matrix.create(); // 矩阵右乘

    matrix.translate(m, m, [-a.x, -a.y]);
    matrix.scale(m, m, [sx, sy]);
    matrix.translate(m, m, [b.x, b.y]);
    return m;
  },

  /**
   * @param {(module:echarts/core/BoundingRect|Object)} b
   * @return {boolean}
   */
  intersect: function (b) {
    if (!b) {
      return false;
    }

    if (!(b instanceof BoundingRect)) {
      // Normalize negative width/height.
      b = BoundingRect.create(b);
    }

    var a = this;
    var ax0 = a.x;
    var ax1 = a.x + a.width;
    var ay0 = a.y;
    var ay1 = a.y + a.height;
    var bx0 = b.x;
    var bx1 = b.x + b.width;
    var by0 = b.y;
    var by1 = b.y + b.height;
    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
  },
  contain: function (x, y) {
    var rect = this;
    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
  },

  /**
   * @return {module:echarts/core/BoundingRect}
   */
  clone: function () {
    return new BoundingRect(this.x, this.y, this.width, this.height);
  },

  /**
   * Copy from another rect
   */
  copy: function (other) {
    this.x = other.x;
    this.y = other.y;
    this.width = other.width;
    this.height = other.height;
  },
  plain: function () {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }
};
/**
 * @param {Object|module:zrender/core/BoundingRect} rect
 * @param {number} rect.x
 * @param {number} rect.y
 * @param {number} rect.width
 * @param {number} rect.height
 * @return {module:zrender/core/BoundingRect}
 */

BoundingRect.create = function (rect) {
  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
};

var _default = BoundingRect;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/GestureMgr.js":
/***/ (function(module, exports, __webpack_require__) {

var eventUtil = __webpack_require__("./node_modules/zrender/lib/core/event.js");

/**
 * Only implements needed gestures for mobile.
 */
var GestureMgr = function () {
  /**
   * @private
   * @type {Array.<Object>}
   */
  this._track = [];
};

GestureMgr.prototype = {
  constructor: GestureMgr,
  recognize: function (event, target, root) {
    this._doTrack(event, target, root);

    return this._recognize(event);
  },
  clear: function () {
    this._track.length = 0;
    return this;
  },
  _doTrack: function (event, target, root) {
    var touches = event.touches;

    if (!touches) {
      return;
    }

    var trackItem = {
      points: [],
      touches: [],
      target: target,
      event: event
    };

    for (var i = 0, len = touches.length; i < len; i++) {
      var touch = touches[i];
      var pos = eventUtil.clientToLocal(root, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }

    this._track.push(trackItem);
  },
  _recognize: function (event) {
    for (var eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        var gestureInfo = recognizers[eventName](this._track, event);

        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  }
};

function dist(pointPair) {
  var dx = pointPair[1][0] - pointPair[0][0];
  var dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}

function center(pointPair) {
  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
}

var recognizers = {
  pinch: function (track, event) {
    var trackLen = track.length;

    if (!trackLen) {
      return;
    }

    var pinchEnd = (track[trackLen - 1] || {}).points;
    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;

    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      var pinchScale = dist(pinchEnd) / dist(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      var pinchCenter = center(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: 'pinch',
        target: track[0].target,
        event: event
      };
    }
  } // Only pinch currently.

};
var _default = GestureMgr;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/LRU.js":
/***/ (function(module, exports) {

// Simple LRU cache use doubly linked list
// @module zrender/core/LRU

/**
 * Simple double linked list. Compared with array, it has O(1) remove operation.
 * @constructor
 */
var LinkedList = function () {
  /**
   * @type {module:zrender/core/LRU~Entry}
   */
  this.head = null;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.tail = null;
  this._len = 0;
};

var linkedListProto = LinkedList.prototype;
/**
 * Insert a new value at the tail
 * @param  {} val
 * @return {module:zrender/core/LRU~Entry}
 */

linkedListProto.insert = function (val) {
  var entry = new Entry(val);
  this.insertEntry(entry);
  return entry;
};
/**
 * Insert an entry at the tail
 * @param  {module:zrender/core/LRU~Entry} entry
 */


linkedListProto.insertEntry = function (entry) {
  if (!this.head) {
    this.head = this.tail = entry;
  } else {
    this.tail.next = entry;
    entry.prev = this.tail;
    entry.next = null;
    this.tail = entry;
  }

  this._len++;
};
/**
 * Remove entry.
 * @param  {module:zrender/core/LRU~Entry} entry
 */


linkedListProto.remove = function (entry) {
  var prev = entry.prev;
  var next = entry.next;

  if (prev) {
    prev.next = next;
  } else {
    // Is head
    this.head = next;
  }

  if (next) {
    next.prev = prev;
  } else {
    // Is tail
    this.tail = prev;
  }

  entry.next = entry.prev = null;
  this._len--;
};
/**
 * @return {number}
 */


linkedListProto.len = function () {
  return this._len;
};
/**
 * Clear list
 */


linkedListProto.clear = function () {
  this.head = this.tail = null;
  this._len = 0;
};
/**
 * @constructor
 * @param {} val
 */


var Entry = function (val) {
  /**
   * @type {}
   */
  this.value = val;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.next;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.prev;
};
/**
 * LRU Cache
 * @constructor
 * @alias module:zrender/core/LRU
 */


var LRU = function (maxSize) {
  this._list = new LinkedList();
  this._map = {};
  this._maxSize = maxSize || 10;
  this._lastRemovedEntry = null;
};

var LRUProto = LRU.prototype;
/**
 * @param  {string} key
 * @param  {} value
 * @return {} Removed value
 */

LRUProto.put = function (key, value) {
  var list = this._list;
  var map = this._map;
  var removed = null;

  if (map[key] == null) {
    var len = list.len(); // Reuse last removed entry

    var entry = this._lastRemovedEntry;

    if (len >= this._maxSize && len > 0) {
      // Remove the least recently used
      var leastUsedEntry = list.head;
      list.remove(leastUsedEntry);
      delete map[leastUsedEntry.key];
      removed = leastUsedEntry.value;
      this._lastRemovedEntry = leastUsedEntry;
    }

    if (entry) {
      entry.value = value;
    } else {
      entry = new Entry(value);
    }

    entry.key = key;
    list.insertEntry(entry);
    map[key] = entry;
  }

  return removed;
};
/**
 * @param  {string} key
 * @return {}
 */


LRUProto.get = function (key) {
  var entry = this._map[key];
  var list = this._list;

  if (entry != null) {
    // Put the latest used entry in the tail
    if (entry !== list.tail) {
      list.remove(entry);
      list.insertEntry(entry);
    }

    return entry.value;
  }
};
/**
 * Clear the cache
 */


LRUProto.clear = function () {
  this._list.clear();

  this._map = {};
};

var _default = LRU;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/PathProxy.js":
/***/ (function(module, exports, __webpack_require__) {

var curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var bbox = __webpack_require__("./node_modules/zrender/lib/core/bbox.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var _config = __webpack_require__("./node_modules/zrender/lib/config.js");

var dpr = _config.devicePixelRatio;

/**
 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
 * 可以用于 isInsidePath 判断以及获取boundingRect
 *
 * @module zrender/core/PathProxy
 * @author Yi Shen (http://www.github.com/pissang)
 */
// TODO getTotalLength, getPointAtLength
var CMD = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  // Rect
  R: 7
}; // var CMD_MEM_SIZE = {
//     M: 3,
//     L: 3,
//     C: 7,
//     Q: 5,
//     A: 9,
//     R: 5,
//     Z: 1
// };

var min = [];
var max = [];
var min2 = [];
var max2 = [];
var mathMin = Math.min;
var mathMax = Math.max;
var mathCos = Math.cos;
var mathSin = Math.sin;
var mathSqrt = Math.sqrt;
var mathAbs = Math.abs;
var hasTypedArray = typeof Float32Array != 'undefined';
/**
 * @alias module:zrender/core/PathProxy
 * @constructor
 */

var PathProxy = function (notSaveData) {
  this._saveData = !(notSaveData || false);

  if (this._saveData) {
    /**
     * Path data. Stored as flat array
     * @type {Array.<Object>}
     */
    this.data = [];
  }

  this._ctx = null;
};
/**
 * 快速计算Path包围盒（并不是最小包围盒）
 * @return {Object}
 */


PathProxy.prototype = {
  constructor: PathProxy,
  _xi: 0,
  _yi: 0,
  _x0: 0,
  _y0: 0,
  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
  _ux: 0,
  _uy: 0,
  _len: 0,
  _lineDash: null,
  _dashOffset: 0,
  _dashIdx: 0,
  _dashSum: 0,

  /**
   * @readOnly
   */
  setScale: function (sx, sy) {
    this._ux = mathAbs(1 / dpr / sx) || 0;
    this._uy = mathAbs(1 / dpr / sy) || 0;
  },
  getContext: function () {
    return this._ctx;
  },

  /**
   * @param  {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  beginPath: function (ctx) {
    this._ctx = ctx;
    ctx && ctx.beginPath();
    ctx && (this.dpr = ctx.dpr); // Reset

    if (this._saveData) {
      this._len = 0;
    }

    if (this._lineDash) {
      this._lineDash = null;
      this._dashOffset = 0;
    }

    return this;
  },

  /**
   * @param  {number} x
   * @param  {number} y
   * @return {module:zrender/core/PathProxy}
   */
  moveTo: function (x, y) {
    this.addData(CMD.M, x, y);
    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持

    this._x0 = x;
    this._y0 = y;
    this._xi = x;
    this._yi = y;
    return this;
  },

  /**
   * @param  {number} x
   * @param  {number} y
   * @return {module:zrender/core/PathProxy}
   */
  lineTo: function (x, y) {
    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
    || this._len < 5;
    this.addData(CMD.L, x, y);

    if (this._ctx && exceedUnit) {
      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
    }

    if (exceedUnit) {
      this._xi = x;
      this._yi = y;
    }

    return this;
  },

  /**
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @param  {number} x3
   * @param  {number} y3
   * @return {module:zrender/core/PathProxy}
   */
  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);

    if (this._ctx) {
      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
    }

    this._xi = x3;
    this._yi = y3;
    return this;
  },

  /**
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @return {module:zrender/core/PathProxy}
   */
  quadraticCurveTo: function (x1, y1, x2, y2) {
    this.addData(CMD.Q, x1, y1, x2, y2);

    if (this._ctx) {
      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
    }

    this._xi = x2;
    this._yi = y2;
    return this;
  },

  /**
   * @param  {number} cx
   * @param  {number} cy
   * @param  {number} r
   * @param  {number} startAngle
   * @param  {number} endAngle
   * @param  {boolean} anticlockwise
   * @return {module:zrender/core/PathProxy}
   */
  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
    this._xi = mathCos(endAngle) * r + cx;
    this._yi = mathSin(endAngle) * r + cx;
    return this;
  },
  // TODO
  arcTo: function (x1, y1, x2, y2, radius) {
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x2, y2, radius);
    }

    return this;
  },
  // TODO
  rect: function (x, y, w, h) {
    this._ctx && this._ctx.rect(x, y, w, h);
    this.addData(CMD.R, x, y, w, h);
    return this;
  },

  /**
   * @return {module:zrender/core/PathProxy}
   */
  closePath: function () {
    this.addData(CMD.Z);
    var ctx = this._ctx;
    var x0 = this._x0;
    var y0 = this._y0;

    if (ctx) {
      this._needsDash() && this._dashedLineTo(x0, y0);
      ctx.closePath();
    }

    this._xi = x0;
    this._yi = y0;
    return this;
  },

  /**
   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
   * stroke 同样
   * @param {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  fill: function (ctx) {
    ctx && ctx.fill();
    this.toStatic();
  },

  /**
   * @param {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  stroke: function (ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  },

  /**
   * 必须在其它绘制命令前调用
   * Must be invoked before all other path drawing methods
   * @return {module:zrender/core/PathProxy}
   */
  setLineDash: function (lineDash) {
    if (lineDash instanceof Array) {
      this._lineDash = lineDash;
      this._dashIdx = 0;
      var lineDashSum = 0;

      for (var i = 0; i < lineDash.length; i++) {
        lineDashSum += lineDash[i];
      }

      this._dashSum = lineDashSum;
    }

    return this;
  },

  /**
   * 必须在其它绘制命令前调用
   * Must be invoked before all other path drawing methods
   * @return {module:zrender/core/PathProxy}
   */
  setLineDashOffset: function (offset) {
    this._dashOffset = offset;
    return this;
  },

  /**
   *
   * @return {boolean}
   */
  len: function () {
    return this._len;
  },

  /**
   * 直接设置 Path 数据
   */
  setData: function (data) {
    var len = data.length;

    if (!(this.data && this.data.length == len) && hasTypedArray) {
      this.data = new Float32Array(len);
    }

    for (var i = 0; i < len; i++) {
      this.data[i] = data[i];
    }

    this._len = len;
  },

  /**
   * 添加子路径
   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
   */
  appendPath: function (path) {
    if (!(path instanceof Array)) {
      path = [path];
    }

    var len = path.length;
    var appendSize = 0;
    var offset = this._len;

    for (var i = 0; i < len; i++) {
      appendSize += path[i].len();
    }

    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset + appendSize);
    }

    for (var i = 0; i < len; i++) {
      var appendPathData = path[i].data;

      for (var k = 0; k < appendPathData.length; k++) {
        this.data[offset++] = appendPathData[k];
      }
    }

    this._len = offset;
  },

  /**
   * 填充 Path 数据。
   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
   */
  addData: function (cmd) {
    if (!this._saveData) {
      return;
    }

    var data = this.data;

    if (this._len + arguments.length > data.length) {
      // 因为之前的数组已经转换成静态的 Float32Array
      // 所以不够用时需要扩展一个新的动态数组
      this._expandData();

      data = this.data;
    }

    for (var i = 0; i < arguments.length; i++) {
      data[this._len++] = arguments[i];
    }

    this._prevCmd = cmd;
  },
  _expandData: function () {
    // Only if data is Float32Array
    if (!(this.data instanceof Array)) {
      var newData = [];

      for (var i = 0; i < this._len; i++) {
        newData[i] = this.data[i];
      }

      this.data = newData;
    }
  },

  /**
   * If needs js implemented dashed line
   * @return {boolean}
   * @private
   */
  _needsDash: function () {
    return this._lineDash;
  },
  _dashedLineTo: function (x1, y1) {
    var dashSum = this._dashSum;
    var offset = this._dashOffset;
    var lineDash = this._lineDash;
    var ctx = this._ctx;
    var x0 = this._xi;
    var y0 = this._yi;
    var dx = x1 - x0;
    var dy = y1 - y0;
    var dist = mathSqrt(dx * dx + dy * dy);
    var x = x0;
    var y = y0;
    var dash;
    var nDash = lineDash.length;
    var idx;
    dx /= dist;
    dy /= dist;

    if (offset < 0) {
      // Convert to positive offset
      offset = dashSum + offset;
    }

    offset %= dashSum;
    x -= offset * dx;
    y -= offset * dy;

    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
      idx = this._dashIdx;
      dash = lineDash[idx];
      x += dx * dash;
      y += dy * dash;
      this._dashIdx = (idx + 1) % nDash; // Skip positive offset

      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
        continue;
      }

      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
    } // Offset for next lineTo


    dx = x - x1;
    dy = y - y1;
    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
  },
  // Not accurate dashed line to
  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
    var dashSum = this._dashSum;
    var offset = this._dashOffset;
    var lineDash = this._lineDash;
    var ctx = this._ctx;
    var x0 = this._xi;
    var y0 = this._yi;
    var t;
    var dx;
    var dy;
    var cubicAt = curve.cubicAt;
    var bezierLen = 0;
    var idx = this._dashIdx;
    var nDash = lineDash.length;
    var x;
    var y;
    var tmpLen = 0;

    if (offset < 0) {
      // Convert to positive offset
      offset = dashSum + offset;
    }

    offset %= dashSum; // Bezier approx length

    for (t = 0; t < 1; t += 0.1) {
      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
      bezierLen += mathSqrt(dx * dx + dy * dy);
    } // Find idx after add offset


    for (; idx < nDash; idx++) {
      tmpLen += lineDash[idx];

      if (tmpLen > offset) {
        break;
      }
    }

    t = (tmpLen - offset) / bezierLen;

    while (t <= 1) {
      x = cubicAt(x0, x1, x2, x3, t);
      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
      // Bad result if dash is long

      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      t += lineDash[idx] / bezierLen;
      idx = (idx + 1) % nDash;
    } // Finish the last segment and calculate the new offset


    idx % 2 !== 0 && ctx.lineTo(x3, y3);
    dx = x3 - x;
    dy = y3 - y;
    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
  },
  _dashedQuadraticTo: function (x1, y1, x2, y2) {
    // Convert quadratic to cubic using degree elevation
    var x3 = x2;
    var y3 = y2;
    x2 = (x2 + 2 * x1) / 3;
    y2 = (y2 + 2 * y1) / 3;
    x1 = (this._xi + 2 * x1) / 3;
    y1 = (this._yi + 2 * y1) / 3;

    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
  },

  /**
   * 转成静态的 Float32Array 减少堆内存占用
   * Convert dynamic array to static Float32Array
   */
  toStatic: function () {
    var data = this.data;

    if (data instanceof Array) {
      data.length = this._len;

      if (hasTypedArray) {
        this.data = new Float32Array(data);
      }
    }
  },

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function () {
    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
    var data = this.data;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;

    for (var i = 0; i < data.length;) {
      var cmd = data[i++];

      if (i == 1) {
        // 如果第一个命令是 L, C, Q
        // 则 previous point 同绘制命令的第一个 point
        //
        // 第一个命令为 Arc 的情况下会在后面特殊处理
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }

      switch (cmd) {
        case CMD.M:
          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
          // 在 closePath 的时候使用
          x0 = data[i++];
          y0 = data[i++];
          xi = x0;
          yi = y0;
          min2[0] = x0;
          min2[1] = y0;
          max2[0] = x0;
          max2[1] = y0;
          break;

        case CMD.L:
          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.C:
          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.Q:
          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.A:
          // TODO Arc 判断的开销比较大
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var endAngle = data[i++] + startAngle; // TODO Arc 旋转

          var psi = data[i++];
          var anticlockwise = 1 - data[i++];

          if (i == 1) {
            // 直接使用 arc 命令
            // 第一个命令起点还未定义
            x0 = mathCos(startAngle) * rx + cx;
            y0 = mathSin(startAngle) * ry + cy;
          }

          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
          xi = mathCos(endAngle) * rx + cx;
          yi = mathSin(endAngle) * ry + cy;
          break;

        case CMD.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++]; // Use fromLine

          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
          break;

        case CMD.Z:
          xi = x0;
          yi = y0;
          break;
      } // Union


      vec2.min(min, min, min2);
      vec2.max(max, max, max2);
    } // No data


    if (i === 0) {
      min[0] = min[1] = max[0] = max[1] = 0;
    }

    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
  },

  /**
   * Rebuild path from current data
   * Rebuild path will not consider javascript implemented line dash.
   * @param {CanvasRenderingContext2D} ctx
   */
  rebuildPath: function (ctx) {
    var d = this.data;
    var x0, y0;
    var xi, yi;
    var x, y;
    var ux = this._ux;
    var uy = this._uy;
    var len = this._len;

    for (var i = 0; i < len;) {
      var cmd = d[i++];

      if (i == 1) {
        // 如果第一个命令是 L, C, Q
        // 则 previous point 同绘制命令的第一个 point
        //
        // 第一个命令为 Arc 的情况下会在后面特殊处理
        xi = d[i];
        yi = d[i + 1];
        x0 = xi;
        y0 = yi;
      }

      switch (cmd) {
        case CMD.M:
          x0 = xi = d[i++];
          y0 = yi = d[i++];
          ctx.moveTo(xi, yi);
          break;

        case CMD.L:
          x = d[i++];
          y = d[i++]; // Not draw too small seg between

          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
            ctx.lineTo(x, y);
            xi = x;
            yi = y;
          }

          break;

        case CMD.C:
          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
          xi = d[i - 2];
          yi = d[i - 1];
          break;

        case CMD.Q:
          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
          xi = d[i - 2];
          yi = d[i - 1];
          break;

        case CMD.A:
          var cx = d[i++];
          var cy = d[i++];
          var rx = d[i++];
          var ry = d[i++];
          var theta = d[i++];
          var dTheta = d[i++];
          var psi = d[i++];
          var fs = d[i++];
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          var isEllipse = Math.abs(rx - ry) > 1e-3;
          var endAngle = theta + dTheta;

          if (isEllipse) {
            ctx.translate(cx, cy);
            ctx.rotate(psi);
            ctx.scale(scaleX, scaleY);
            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
            ctx.scale(1 / scaleX, 1 / scaleY);
            ctx.rotate(-psi);
            ctx.translate(-cx, -cy);
          } else {
            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
          }

          if (i == 1) {
            // 直接使用 arc 命令
            // 第一个命令起点还未定义
            x0 = mathCos(theta) * rx + cx;
            y0 = mathSin(theta) * ry + cy;
          }

          xi = mathCos(endAngle) * rx + cx;
          yi = mathSin(endAngle) * ry + cy;
          break;

        case CMD.R:
          x0 = xi = d[i];
          y0 = yi = d[i + 1];
          ctx.rect(d[i++], d[i++], d[i++], d[i++]);
          break;

        case CMD.Z:
          ctx.closePath();
          xi = x0;
          yi = y0;
      }
    }
  }
};
PathProxy.CMD = CMD;
var _default = PathProxy;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/bbox.js":
/***/ (function(module, exports, __webpack_require__) {

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

/**
 * @author Yi Shen(https://github.com/pissang)
 */
var mathMin = Math.min;
var mathMax = Math.max;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI2 = Math.PI * 2;
var start = vec2.create();
var end = vec2.create();
var extremity = vec2.create();
/**
 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
 * @module zrender/core/bbox
 * @param {Array<Object>} points 顶点数组
 * @param {number} min
 * @param {number} max
 */

function fromPoints(points, min, max) {
  if (points.length === 0) {
    return;
  }

  var p = points[0];
  var left = p[0];
  var right = p[0];
  var top = p[1];
  var bottom = p[1];
  var i;

  for (i = 1; i < points.length; i++) {
    p = points[i];
    left = mathMin(left, p[0]);
    right = mathMax(right, p[0]);
    top = mathMin(top, p[1]);
    bottom = mathMax(bottom, p[1]);
  }

  min[0] = left;
  min[1] = top;
  max[0] = right;
  max[1] = bottom;
}
/**
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromLine(x0, y0, x1, y1, min, max) {
  min[0] = mathMin(x0, x1);
  min[1] = mathMin(y0, y1);
  max[0] = mathMax(x0, x1);
  max[1] = mathMax(y0, y1);
}

var xDim = [];
var yDim = [];
/**
 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */

function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
  var cubicExtrema = curve.cubicExtrema;
  var cubicAt = curve.cubicAt;
  var i;
  var n = cubicExtrema(x0, x1, x2, x3, xDim);
  min[0] = Infinity;
  min[1] = Infinity;
  max[0] = -Infinity;
  max[1] = -Infinity;

  for (i = 0; i < n; i++) {
    var x = cubicAt(x0, x1, x2, x3, xDim[i]);
    min[0] = mathMin(x, min[0]);
    max[0] = mathMax(x, max[0]);
  }

  n = cubicExtrema(y0, y1, y2, y3, yDim);

  for (i = 0; i < n; i++) {
    var y = cubicAt(y0, y1, y2, y3, yDim[i]);
    min[1] = mathMin(y, min[1]);
    max[1] = mathMax(y, max[1]);
  }

  min[0] = mathMin(x0, min[0]);
  max[0] = mathMax(x0, max[0]);
  min[0] = mathMin(x3, min[0]);
  max[0] = mathMax(x3, max[0]);
  min[1] = mathMin(y0, min[1]);
  max[1] = mathMax(y0, max[1]);
  min[1] = mathMin(y3, min[1]);
  max[1] = mathMax(y3, max[1]);
}
/**
 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
  var quadraticExtremum = curve.quadraticExtremum;
  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero

  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
  var x = quadraticAt(x0, x1, x2, tx);
  var y = quadraticAt(y0, y1, y2, ty);
  min[0] = mathMin(x0, x2, x);
  min[1] = mathMin(y0, y2, y);
  max[0] = mathMax(x0, x2, x);
  max[1] = mathMax(y0, y2, y);
}
/**
 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
 * @method
 * @memberOf module:zrender/core/bbox
 * @param {number} x
 * @param {number} y
 * @param {number} rx
 * @param {number} ry
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} anticlockwise
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
  var vec2Min = vec2.min;
  var vec2Max = vec2.max;
  var diff = Math.abs(startAngle - endAngle);

  if (diff % PI2 < 1e-4 && diff > 1e-4) {
    // Is a circle
    min[0] = x - rx;
    min[1] = y - ry;
    max[0] = x + rx;
    max[1] = y + ry;
    return;
  }

  start[0] = mathCos(startAngle) * rx + x;
  start[1] = mathSin(startAngle) * ry + y;
  end[0] = mathCos(endAngle) * rx + x;
  end[1] = mathSin(endAngle) * ry + y;
  vec2Min(min, start, end);
  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]

  startAngle = startAngle % PI2;

  if (startAngle < 0) {
    startAngle = startAngle + PI2;
  }

  endAngle = endAngle % PI2;

  if (endAngle < 0) {
    endAngle = endAngle + PI2;
  }

  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2;
  }

  if (anticlockwise) {
    var tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  } // var number = 0;
  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;


  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
    if (angle > startAngle) {
      extremity[0] = mathCos(angle) * rx + x;
      extremity[1] = mathSin(angle) * ry + y;
      vec2Min(min, extremity, min);
      vec2Max(max, extremity, max);
    }
  }
}

exports.fromPoints = fromPoints;
exports.fromLine = fromLine;
exports.fromCubic = fromCubic;
exports.fromQuadratic = fromQuadratic;
exports.fromArc = fromArc;

/***/ }),

/***/ "./node_modules/zrender/lib/core/curve.js":
/***/ (function(module, exports, __webpack_require__) {

var _vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var v2Create = _vector.create;
var v2DistSquare = _vector.distSquare;

/**
 * 曲线辅助模块
 * @module zrender/core/curve
 * @author pissang(https://www.github.com/pissang)
 */
var mathPow = Math.pow;
var mathSqrt = Math.sqrt;
var EPSILON = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt(3);
var ONE_THIRD = 1 / 3; // 临时变量

var _v0 = v2Create();

var _v1 = v2Create();

var _v2 = v2Create();

function isAroundZero(val) {
  return val > -EPSILON && val < EPSILON;
}

function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
/**
 * 计算三次贝塞尔值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */


function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
/**
 * 计算三次贝塞尔导数值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */


function cubicDerivativeAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}
/**
 * 计算三次贝塞尔方程根，使用盛金公式
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} val
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */


function cubicRootAt(p0, p1, p2, p3, val, roots) {
  // Evaluate roots of cubic functions
  var a = p3 + 3 * (p1 - p2) - p0;
  var b = 3 * (p2 - p1 * 2 + p0);
  var c = 3 * (p1 - p0);
  var d = p0 - val;
  var A = b * b - 3 * a * c;
  var B = b * c - 9 * a * d;
  var C = c * c - 3 * b * d;
  var n = 0;

  if (isAroundZero(A) && isAroundZero(B)) {
    if (isAroundZero(b)) {
      roots[0] = 0;
    } else {
      var t1 = -c / b; //t1, t2, t3, b is not zero

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    }
  } else {
    var disc = B * B - 4 * A * C;

    if (isAroundZero(disc)) {
      var K = B / A;
      var t1 = -b / a + K; // t1, a is not zero

      var t2 = -K / 2; // t2, t3

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
      var Y2 = A * b + 1.5 * a * (-B - discSqrt);

      if (Y1 < 0) {
        Y1 = -mathPow(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow(Y1, ONE_THIRD);
      }

      if (Y2 < 0) {
        Y2 = -mathPow(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow(Y2, ONE_THIRD);
      }

      var t1 = (-b - (Y1 + Y2)) / (3 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    } else {
      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
      var theta = Math.acos(T) / 3;
      var ASqrt = mathSqrt(A);
      var tmp = Math.cos(theta);
      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }

      if (t3 >= 0 && t3 <= 1) {
        roots[n++] = t3;
      }
    }
  }

  return n;
}
/**
 * 计算三次贝塞尔方程极限值的位置
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {Array.<number>} extrema
 * @return {number} 有效数目
 */


function cubicExtrema(p0, p1, p2, p3, extrema) {
  var b = 6 * p2 - 12 * p1 + 6 * p0;
  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
  var c = 3 * p1 - 3 * p0;
  var n = 0;

  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      var t1 = -c / b;

      if (t1 >= 0 && t1 <= 1) {
        extrema[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;

    if (isAroundZero(disc)) {
      extrema[0] = -b / (2 * a);
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        extrema[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        extrema[n++] = t2;
      }
    }
  }

  return n;
}
/**
 * 细分三次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {Array.<number>} out
 */


function cubicSubdivide(p0, p1, p2, p3, t, out) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p23 = (p3 - p2) * t + p2;
  var p012 = (p12 - p01) * t + p01;
  var p123 = (p23 - p12) * t + p12;
  var p0123 = (p123 - p012) * t + p012; // Seg0

  out[0] = p0;
  out[1] = p01;
  out[2] = p012;
  out[3] = p0123; // Seg1

  out[4] = p0123;
  out[5] = p123;
  out[6] = p23;
  out[7] = p3;
}
/**
 * 投射点到三次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} [out] 投射点
 * @return {number}
 */


function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
  // http://pomax.github.io/bezierinfo/#projections
  var t;
  var interval = 0.005;
  var d = Infinity;
  var prev;
  var next;
  var d1;
  var d2;
  _v0[0] = x;
  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
  // PENDING

  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
    d1 = v2DistSquare(_v0, _v1);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }

  d = Infinity; // At most 32 iteration

  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }

    prev = t - interval;
    next = t + interval; // t - interval

    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
    d1 = v2DistSquare(_v1, _v0);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      // t + interval
      _v2[0] = cubicAt(x0, x1, x2, x3, next);
      _v2[1] = cubicAt(y0, y1, y2, y3, next);
      d2 = v2DistSquare(_v2, _v0);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  } // t


  if (out) {
    out[0] = cubicAt(x0, x1, x2, x3, t);
    out[1] = cubicAt(y0, y1, y2, y3, t);
  } // console.log(interval, i);


  return mathSqrt(d);
}
/**
 * 计算二次方贝塞尔值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */


function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
/**
 * 计算二次方贝塞尔导数值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */


function quadraticDerivativeAt(p0, p1, p2, t) {
  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}
/**
 * 计算二次方贝塞尔方程根
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */


function quadraticRootAt(p0, p1, p2, val, roots) {
  var a = p0 - 2 * p1 + p2;
  var b = 2 * (p1 - p0);
  var c = p0 - val;
  var n = 0;

  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      var t1 = -c / b;

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;

    if (isAroundZero(disc)) {
      var t1 = -b / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }
    }
  }

  return n;
}
/**
 * 计算二次贝塞尔方程极限值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @return {number}
 */


function quadraticExtremum(p0, p1, p2) {
  var divider = p0 + p2 - 2 * p1;

  if (divider === 0) {
    // p1 is center of p0 and p2
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
/**
 * 细分二次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} out
 */


function quadraticSubdivide(p0, p1, p2, t, out) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p012 = (p12 - p01) * t + p01; // Seg0

  out[0] = p0;
  out[1] = p01;
  out[2] = p012; // Seg1

  out[3] = p012;
  out[4] = p12;
  out[5] = p2;
}
/**
 * 投射点到二次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} out 投射点
 * @return {number}
 */


function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
  // http://pomax.github.io/bezierinfo/#projections
  var t;
  var interval = 0.005;
  var d = Infinity;
  _v0[0] = x;
  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
  // PENDING

  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t);
    _v1[1] = quadraticAt(y0, y1, y2, _t);
    var d1 = v2DistSquare(_v0, _v1);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }

  d = Infinity; // At most 32 iteration

  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }

    var prev = t - interval;
    var next = t + interval; // t - interval

    _v1[0] = quadraticAt(x0, x1, x2, prev);
    _v1[1] = quadraticAt(y0, y1, y2, prev);
    var d1 = v2DistSquare(_v1, _v0);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      // t + interval
      _v2[0] = quadraticAt(x0, x1, x2, next);
      _v2[1] = quadraticAt(y0, y1, y2, next);
      var d2 = v2DistSquare(_v2, _v0);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  } // t


  if (out) {
    out[0] = quadraticAt(x0, x1, x2, t);
    out[1] = quadraticAt(y0, y1, y2, t);
  } // console.log(interval, i);


  return mathSqrt(d);
}

exports.cubicAt = cubicAt;
exports.cubicDerivativeAt = cubicDerivativeAt;
exports.cubicRootAt = cubicRootAt;
exports.cubicExtrema = cubicExtrema;
exports.cubicSubdivide = cubicSubdivide;
exports.cubicProjectPoint = cubicProjectPoint;
exports.quadraticAt = quadraticAt;
exports.quadraticDerivativeAt = quadraticDerivativeAt;
exports.quadraticRootAt = quadraticRootAt;
exports.quadraticExtremum = quadraticExtremum;
exports.quadraticSubdivide = quadraticSubdivide;
exports.quadraticProjectPoint = quadraticProjectPoint;

/***/ }),

/***/ "./node_modules/zrender/lib/core/env.js":
/***/ (function(module, exports) {

/**
 * echarts设备环境识别
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author firede[firede@firede.us]
 * @desc thanks zepto.
 */
var env = {};

if (typeof navigator === 'undefined') {
  // In node
  env = {
    browser: {},
    os: {},
    node: true,
    // Assume canvas is supported
    canvasSupported: true,
    svgSupported: true
  };
} else {
  env = detect(navigator.userAgent);
}

var _default = env; // Zepto.js
// (c) 2010-2013 Thomas Fuchs
// Zepto.js may be freely distributed under the MIT license.

function detect(ua) {
  var os = {};
  var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
  // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
  // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
  // var touchpad = webos && ua.match(/TouchPad/);
  // var kindle = ua.match(/Kindle\/([\d.]+)/);
  // var silk = ua.match(/Silk\/([\d._]+)/);
  // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
  // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
  // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
  // var playbook = ua.match(/PlayBook/);
  // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);

  var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;

  var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
  || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+

  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
  // - discern (more) between multiple browsers on android
  // - decide if kindle fire in silk mode is android or not
  // - Firefox on Android doesn't specify the Android version
  // - possibly devide in os, device and browser hashes
  // if (browser.webkit = !!webkit) browser.version = webkit[1];
  // if (android) os.android = true, os.version = android[2];
  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
  // if (webos) os.webos = true, os.version = webos[2];
  // if (touchpad) os.touchpad = true;
  // if (blackberry) os.blackberry = true, os.version = blackberry[2];
  // if (bb10) os.bb10 = true, os.version = bb10[2];
  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
  // if (playbook) browser.playbook = true;
  // if (kindle) os.kindle = true, os.version = kindle[1];
  // if (silk) browser.silk = true, browser.version = silk[1];
  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
  // if (chrome) browser.chrome = true, browser.version = chrome[1];

  if (firefox) {
    browser.firefox = true;
    browser.version = firefox[1];
  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
  // if (webview) browser.webview = true;


  if (ie) {
    browser.ie = true;
    browser.version = ie[1];
  }

  if (edge) {
    browser.edge = true;
    browser.version = edge[1];
  } // It is difficult to detect WeChat in Win Phone precisely, because ua can
  // not be set on win phone. So we do not consider Win Phone.


  if (weChat) {
    browser.weChat = true;
  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));


  return {
    browser: browser,
    os: os,
    node: false,
    // 原生canvas支持，改极端点了
    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
    canvasSupported: !!document.createElement('canvas').getContext,
    svgSupported: typeof SVGRect !== 'undefined',
    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
    // works on most browsers
    // IE10/11 does not support touch event, and MS Edge supports them but not by
    // default, so we dont check navigator.maxTouchPoints for them here.
    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
    // <http://caniuse.com/#search=pointer%20event>.
    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
    // events currently. So we dont use that on other browsers unless tested sufficiently.
    // Although IE 10 supports pointer event, it use old style and is different from the
    // standard. So we exclude that. (IE 10 is hardly used on touch device)
    && (browser.edge || browser.ie && browser.version >= 11)
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/event.js":
/***/ (function(module, exports, __webpack_require__) {

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

exports.Dispatcher = Eventful;

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

/**
 * 事件辅助类
 * @module zrender/core/event
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */
var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;

function getBoundingClientRect(el) {
  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
  return el.getBoundingClientRect ? el.getBoundingClientRect() : {
    left: 0,
    top: 0
  };
} // `calculate` is optional, default false


function clientToLocal(el, e, out, calculate) {
  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
  // to the padding edge of the target element. The only browser using this convention
  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
  // not support the properties.
  // (see http://www.jacklmoore.com/notes/mouse-position/)
  // In zr painter.dom, padding edge equals to border edge.
  // FIXME
  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
  // is too complex. So css-transfrom dont support in this case temporarily.

  if (calculate || !env.canvasSupported) {
    defaultGetZrXY(el, e, out);
  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
  // ancestor element, so we should make sure el is positioned (e.g., not position:static).
  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
  // zoom-factor, overflow / opacity layers, transforms ...)
  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
  // <https://bugs.jquery.com/ticket/8523#comment:14>
  // BTW3, In ff, offsetX/offsetY is always 0.
  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
      out.zrX = e.layerX;
      out.zrY = e.layerY;
    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
    else if (e.offsetX != null) {
        out.zrX = e.offsetX;
        out.zrY = e.offsetY;
      } // For some other device, e.g., IOS safari.
      else {
          defaultGetZrXY(el, e, out);
        }

  return out;
}

function defaultGetZrXY(el, e, out) {
  // This well-known method below does not support css transform.
  var box = getBoundingClientRect(el);
  out.zrX = e.clientX - box.left;
  out.zrY = e.clientY - box.top;
}
/**
 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
 * `calculate` is optional, default false.
 */


function normalizeEvent(el, e, calculate) {
  e = e || window.event;

  if (e.zrX != null) {
    return e;
  }

  var eventType = e.type;
  var isTouch = eventType && eventType.indexOf('touch') >= 0;

  if (!isTouch) {
    clientToLocal(el, e, e, calculate);
    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
  } else {
    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
    touch && clientToLocal(el, touch, e, calculate);
  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
  // If e.which has been defined, if may be readonly,
  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which


  var button = e.button;

  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }

  return e;
}

function addEventListener(el, name, handler) {
  if (isDomLevel2) {
    el.addEventListener(name, handler);
  } else {
    el.attachEvent('on' + name, handler);
  }
}

function removeEventListener(el, name, handler) {
  if (isDomLevel2) {
    el.removeEventListener(name, handler);
  } else {
    el.detachEvent('on' + name, handler);
  }
}
/**
 * preventDefault and stopPropagation.
 * Notice: do not do that in zrender. Upper application
 * do that if necessary.
 *
 * @memberOf module:zrender/core/event
 * @method
 * @param {Event} e : event对象
 */


var stop = isDomLevel2 ? function (e) {
  e.preventDefault();
  e.stopPropagation();
  e.cancelBubble = true;
} : function (e) {
  e.returnValue = false;
  e.cancelBubble = true;
};

function notLeftMouse(e) {
  // If e.which is undefined, considered as left mouse event.
  return e.which > 1;
} // 做向上兼容


exports.clientToLocal = clientToLocal;
exports.normalizeEvent = normalizeEvent;
exports.addEventListener = addEventListener;
exports.removeEventListener = removeEventListener;
exports.stop = stop;
exports.notLeftMouse = notLeftMouse;

/***/ }),

/***/ "./node_modules/zrender/lib/core/guid.js":
/***/ (function(module, exports) {

/**
 * zrender: 生成唯一id
 *
 * @author errorrik (errorrik@gmail.com)
 */
var idStart = 0x0907;

function _default() {
  return idStart++;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/log.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/zrender/lib/config.js");

var debugMode = _config.debugMode;

var log = function () {};

if (debugMode === 1) {
  log = function () {
    for (var k in arguments) {
      throw new Error(arguments[k]);
    }
  };
} else if (debugMode > 1) {
  log = function () {
    for (var k in arguments) {
      console.log(arguments[k]);
    }
  };
}

var _default = log;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/matrix.js":
/***/ (function(module, exports) {

/**
 * 3x2矩阵操作类
 * @exports zrender/tool/matrix
 */
var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
/**
 * 创建一个单位矩阵
 * @return {Float32Array|Array.<number>}
 */

function create() {
  var out = new ArrayCtor(6);
  identity(out);
  return out;
}
/**
 * 设置矩阵为单位矩阵
 * @param {Float32Array|Array.<number>} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * 复制矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m
 */


function copy(out, m) {
  out[0] = m[0];
  out[1] = m[1];
  out[2] = m[2];
  out[3] = m[3];
  out[4] = m[4];
  out[5] = m[5];
  return out;
}
/**
 * 矩阵相乘
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m1
 * @param {Float32Array|Array.<number>} m2
 */


function mul(out, m1, m2) {
  // Consider matrix.mul(m, m2, m);
  // where out is the same as m2.
  // So use temp variable to escape error.
  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
  var out2 = m1[0] * m2[2] + m1[2] * m2[3];
  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = out3;
  out[4] = out4;
  out[5] = out5;
  return out;
}
/**
 * 平移变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */


function translate(out, a, v) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4] + v[0];
  out[5] = a[5] + v[1];
  return out;
}
/**
 * 旋转变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {number} rad
 */


function rotate(out, a, rad) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var st = Math.sin(rad);
  var ct = Math.cos(rad);
  out[0] = aa * ct + ab * st;
  out[1] = -aa * st + ab * ct;
  out[2] = ac * ct + ad * st;
  out[3] = -ac * st + ct * ad;
  out[4] = ct * atx + st * aty;
  out[5] = ct * aty - st * atx;
  return out;
}
/**
 * 缩放变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */


function scale(out, a, v) {
  var vx = v[0];
  var vy = v[1];
  out[0] = a[0] * vx;
  out[1] = a[1] * vy;
  out[2] = a[2] * vx;
  out[3] = a[3] * vy;
  out[4] = a[4] * vx;
  out[5] = a[5] * vy;
  return out;
}
/**
 * 求逆矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 */


function invert(out, a) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

exports.create = create;
exports.identity = identity;
exports.copy = copy;
exports.mul = mul;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.invert = invert;

/***/ }),

/***/ "./node_modules/zrender/lib/core/timsort.js":
/***/ (function(module, exports) {

// https://github.com/mziccard/node-timsort
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
var DEFAULT_TMP_STORAGE_LENGTH = 256;

function minRunLength(n) {
  var r = 0;

  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }

  return n + r;
}

function makeAscendingRun(array, lo, hi, compare) {
  var runHi = lo + 1;

  if (runHi === hi) {
    return 1;
  }

  if (compare(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }

    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }

  return runHi - lo;
}

function reverseRun(array, lo, hi) {
  hi--;

  while (lo < hi) {
    var t = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t;
  }
}

function binaryInsertionSort(array, lo, hi, start, compare) {
  if (start === lo) {
    start++;
  }

  for (; start < hi; start++) {
    var pivot = array[start];
    var left = lo;
    var right = start;
    var mid;

    while (left < right) {
      mid = left + right >>> 1;

      if (compare(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }

    var n = start - left;

    switch (n) {
      case 3:
        array[left + 3] = array[left + 2];

      case 2:
        array[left + 2] = array[left + 1];

      case 1:
        array[left + 1] = array[left];
        break;

      default:
        while (n > 0) {
          array[left + n] = array[left + n - 1];
          n--;
        }

    }

    array[left] = pivot;
  }
}

function gallopLeft(value, array, start, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;

  if (compare(value, array[start + hint]) > 0) {
    maxOffset = length - hint;

    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;

    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }

  lastOffset++;

  while (lastOffset < offset) {
    var m = lastOffset + (offset - lastOffset >>> 1);

    if (compare(value, array[start + m]) > 0) {
      lastOffset = m + 1;
    } else {
      offset = m;
    }
  }

  return offset;
}

function gallopRight(value, array, start, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;

  if (compare(value, array[start + hint]) < 0) {
    maxOffset = hint + 1;

    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length - hint;

    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    lastOffset += hint;
    offset += hint;
  }

  lastOffset++;

  while (lastOffset < offset) {
    var m = lastOffset + (offset - lastOffset >>> 1);

    if (compare(value, array[start + m]) < 0) {
      offset = m;
    } else {
      lastOffset = m + 1;
    }
  }

  return offset;
}

function TimSort(array, compare) {
  var minGallop = DEFAULT_MIN_GALLOPING;
  var length = 0;
  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
  var stackLength = 0;
  var runStart;
  var runLength;
  var stackSize = 0;
  length = array.length;

  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
    tmpStorageLength = length >>> 1;
  }

  var tmp = [];
  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
  runStart = [];
  runLength = [];

  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }

  function mergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;

      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
        if (runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
      } else if (runLength[n] > runLength[n + 1]) {
        break;
      }

      mergeAt(n);
    }
  }

  function forceMergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;

      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
        n--;
      }

      mergeAt(n);
    }
  }

  function mergeAt(i) {
    var start1 = runStart[i];
    var length1 = runLength[i];
    var start2 = runStart[i + 1];
    var length2 = runLength[i + 1];
    runLength[i] = length1 + length2;

    if (i === stackSize - 3) {
      runStart[i + 1] = runStart[i + 2];
      runLength[i + 1] = runLength[i + 2];
    }

    stackSize--;
    var k = gallopRight(array[start2], array, start1, length1, 0, compare);
    start1 += k;
    length1 -= k;

    if (length1 === 0) {
      return;
    }

    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

    if (length2 === 0) {
      return;
    }

    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }

  function mergeLow(start1, length1, start2, length2) {
    var i = 0;

    for (i = 0; i < length1; i++) {
      tmp[i] = array[start1 + i];
    }

    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];

    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }

      return;
    }

    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }

      array[dest + length2] = tmp[cursor1];
      return;
    }

    var _minGallop = minGallop;
    var count1, count2, exit;

    while (1) {
      count1 = 0;
      count2 = 0;
      exit = false;

      do {
        if (compare(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count2++;
          count1 = 0;

          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;

          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);

      if (exit) {
        break;
      }

      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }

          dest += count1;
          cursor1 += count1;
          length1 -= count1;

          if (length1 <= 1) {
            exit = true;
            break;
          }
        }

        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
          exit = true;
          break;
        }

        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          dest += count2;
          cursor2 += count2;
          length2 -= count2;

          if (length2 === 0) {
            exit = true;
            break;
          }
        }

        array[dest++] = tmp[cursor1++];

        if (--length1 === 1) {
          exit = true;
          break;
        }

        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

      if (exit) {
        break;
      }

      if (_minGallop < 0) {
        _minGallop = 0;
      }

      _minGallop += 2;
    }

    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);

    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }

      array[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error(); // throw new Error('mergeLow preconditions were not respected');
    } else {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
    }
  }

  function mergeHigh(start1, length1, start2, length2) {
    var i = 0;

    for (i = 0; i < length2; i++) {
      tmp[i] = array[start2 + i];
    }

    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];

    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);

      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }

      return;
    }

    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;

      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }

      array[dest] = tmp[cursor2];
      return;
    }

    var _minGallop = minGallop;

    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;

      do {
        if (compare(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count2 = 0;

          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;

          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);

      if (exit) {
        break;
      }

      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = count1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          if (length1 === 0) {
            exit = true;
            break;
          }
        }

        array[dest--] = tmp[cursor2--];

        if (--length2 === 1) {
          exit = true;
          break;
        }

        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;

          for (i = 0; i < count2; i++) {
            array[customDest + i] = tmp[customCursor + i];
          }

          if (length2 <= 1) {
            exit = true;
            break;
          }
        }

        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
          exit = true;
          break;
        }

        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

      if (exit) {
        break;
      }

      if (_minGallop < 0) {
        _minGallop = 0;
      }

      _minGallop += 2;
    }

    minGallop = _minGallop;

    if (minGallop < 1) {
      minGallop = 1;
    }

    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;

      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }

      array[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
    } else {
      customCursor = dest - (length2 - 1);

      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
    }
  }

  this.mergeRuns = mergeRuns;
  this.forceMergeRuns = forceMergeRuns;
  this.pushRun = pushRun;
}

function sort(array, compare, lo, hi) {
  if (!lo) {
    lo = 0;
  }

  if (!hi) {
    hi = array.length;
  }

  var remaining = hi - lo;

  if (remaining < 2) {
    return;
  }

  var runLength = 0;

  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
    return;
  }

  var ts = new TimSort(array, compare);
  var minRun = minRunLength(remaining);

  do {
    runLength = makeAscendingRun(array, lo, hi, compare);

    if (runLength < minRun) {
      var force = remaining;

      if (force > minRun) {
        force = minRun;
      }

      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
      runLength = force;
    }

    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);

  ts.forceMergeRuns();
}

module.exports = sort;

/***/ }),

/***/ "./node_modules/zrender/lib/core/util.js":
/***/ (function(module, exports) {

/**
 * @module zrender/core/util
 */
// 用于处理merge时无法遍历Date等对象的问题
var BUILTIN_OBJECT = {
  '[object Function]': 1,
  '[object RegExp]': 1,
  '[object Date]': 1,
  '[object Error]': 1,
  '[object CanvasGradient]': 1,
  '[object CanvasPattern]': 1,
  // For node-canvas
  '[object Image]': 1,
  '[object Canvas]': 1
};
var TYPED_ARRAY = {
  '[object Int8Array]': 1,
  '[object Uint8Array]': 1,
  '[object Uint8ClampedArray]': 1,
  '[object Int16Array]': 1,
  '[object Uint16Array]': 1,
  '[object Int32Array]': 1,
  '[object Uint32Array]': 1,
  '[object Float32Array]': 1,
  '[object Float64Array]': 1
};
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.

var methods = {};

function $override(name, fn) {
  methods[name] = fn;
}
/**
 * Those data types can be cloned:
 *     Plain object, Array, TypedArray, number, string, null, undefined.
 * Those data types will be assgined using the orginal data:
 *     BUILTIN_OBJECT
 * Instance of user defined class will be cloned to a plain object, without
 * properties in prototype.
 * Other data types is not supported (not sure what will happen).
 *
 * Caution: do not support clone Date, for performance consideration.
 * (There might be a large number of date in `series.data`).
 * So date should not be modified in and out of echarts.
 *
 * @param {*} source
 * @return {*} new
 */


function clone(source) {
  if (source == null || typeof source != 'object') {
    return source;
  }

  var result = source;
  var typeStr = objToString.call(source);

  if (typeStr === '[object Array]') {
    result = [];

    for (var i = 0, len = source.length; i < len; i++) {
      result[i] = clone(source[i]);
    }
  } else if (TYPED_ARRAY[typeStr]) {
    var Ctor = source.constructor;

    if (source.constructor.from) {
      result = Ctor.from(source);
    } else {
      result = new Ctor(source.length);

      for (var i = 0, len = source.length; i < len; i++) {
        result[i] = clone(source[i]);
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};

    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        result[key] = clone(source[key]);
      }
    }
  }

  return result;
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overwrite=false]
 */


function merge(target, source, overwrite) {
  // We should escapse that source is string
  // and enter for ... in ...
  if (!isObject(source) || !isObject(target)) {
    return overwrite ? clone(source) : target;
  }

  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      var targetProp = target[key];
      var sourceProp = source[key];

      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        // 如果需要递归覆盖，就递归调用merge
        merge(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
        // NOTE，在 target[key] 不存在的时候也是直接覆盖
        target[key] = clone(source[key], true);
      }
    }
  }

  return target;
}
/**
 * @param {Array} targetAndSources The first item is target, and the rests are source.
 * @param {boolean} [overwrite=false]
 * @return {*} target
 */


function mergeAll(targetAndSources, overwrite) {
  var result = targetAndSources[0];

  for (var i = 1, len = targetAndSources.length; i < len; i++) {
    result = merge(result, targetAndSources[i], overwrite);
  }

  return result;
}
/**
 * @param {*} target
 * @param {*} source
 * @memberOf module:zrender/core/util
 */


function extend(target, source) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }

  return target;
}
/**
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overlay=false]
 * @memberOf module:zrender/core/util
 */


function defaults(target, source, overlay) {
  for (var key in source) {
    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
      target[key] = source[key];
    }
  }

  return target;
}

var createCanvas = function () {
  return methods.createCanvas();
};

methods.createCanvas = function () {
  return document.createElement('canvas');
}; // FIXME


var _ctx;

function getContext() {
  if (!_ctx) {
    // Use util.createCanvas instead of createCanvas
    // because createCanvas may be overwritten in different environment
    _ctx = createCanvas().getContext('2d');
  }

  return _ctx;
}
/**
 * 查询数组中元素的index
 * @memberOf module:zrender/core/util
 */


function indexOf(array, value) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value);
    }

    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
  }

  return -1;
}
/**
 * 构造类继承关系
 *
 * @memberOf module:zrender/core/util
 * @param {Function} clazz 源类
 * @param {Function} baseClazz 基类
 */


function inherits(clazz, baseClazz) {
  var clazzPrototype = clazz.prototype;

  function F() {}

  F.prototype = baseClazz.prototype;
  clazz.prototype = new F();

  for (var prop in clazzPrototype) {
    clazz.prototype[prop] = clazzPrototype[prop];
  }

  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
/**
 * @memberOf module:zrender/core/util
 * @param {Object|Function} target
 * @param {Object|Function} sorce
 * @param {boolean} overlay
 */


function mixin(target, source, overlay) {
  target = 'prototype' in target ? target.prototype : target;
  source = 'prototype' in source ? source.prototype : source;
  defaults(target, source, overlay);
}
/**
 * Consider typed array.
 * @param {Array|TypedArray} data
 */


function isArrayLike(data) {
  if (!data) {
    return;
  }

  if (typeof data == 'string') {
    return false;
  }

  return typeof data.length == 'number';
}
/**
 * 数组或对象遍历
 * @memberOf module:zrender/core/util
 * @param {Object|Array} obj
 * @param {Function} cb
 * @param {*} [context]
 */


function each(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.forEach && obj.forEach === nativeForEach) {
    obj.forEach(cb, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, len = obj.length; i < len; i++) {
      cb.call(context, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        cb.call(context, obj[key], key, obj);
      }
    }
  }
}
/**
 * 数组映射
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */


function map(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.map && obj.map === nativeMap) {
    return obj.map(cb, context);
  } else {
    var result = [];

    for (var i = 0, len = obj.length; i < len; i++) {
      result.push(cb.call(context, obj[i], i, obj));
    }

    return result;
  }
}
/**
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {Object} [memo]
 * @param {*} [context]
 * @return {Array}
 */


function reduce(obj, cb, memo, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.reduce && obj.reduce === nativeReduce) {
    return obj.reduce(cb, memo, context);
  } else {
    for (var i = 0, len = obj.length; i < len; i++) {
      memo = cb.call(context, memo, obj[i], i, obj);
    }

    return memo;
  }
}
/**
 * 数组过滤
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */


function filter(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.filter && obj.filter === nativeFilter) {
    return obj.filter(cb, context);
  } else {
    var result = [];

    for (var i = 0, len = obj.length; i < len; i++) {
      if (cb.call(context, obj[i], i, obj)) {
        result.push(obj[i]);
      }
    }

    return result;
  }
}
/**
 * 数组项查找
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {*}
 */


function find(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  for (var i = 0, len = obj.length; i < len; i++) {
    if (cb.call(context, obj[i], i, obj)) {
      return obj[i];
    }
  }
}
/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @param {*} context
 * @return {Function}
 */


function bind(func, context) {
  var args = nativeSlice.call(arguments, 2);
  return function () {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @return {Function}
 */


function curry(func) {
  var args = nativeSlice.call(arguments, 1);
  return function () {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isArray(value) {
  return objToString.call(value) === '[object Array]';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isFunction(value) {
  return typeof value === 'function';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isString(value) {
  return objToString.call(value) === '[object String]';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type === 'function' || !!value && type == 'object';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isDom(value) {
  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
}
/**
 * Whether is exactly NaN. Notice isNaN('a') returns true.
 * @param {*} value
 * @return {boolean}
 */


function eqNaN(value) {
  return value !== value;
}
/**
 * If value1 is not null, then return value1, otherwise judget rest of values.
 * Low performance.
 * @memberOf module:zrender/core/util
 * @return {*} Final value
 */


function retrieve(values) {
  for (var i = 0, len = arguments.length; i < len; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }
}

function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}

function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
/**
 * @memberOf module:zrender/core/util
 * @param {Array} arr
 * @param {number} startIndex
 * @param {number} endIndex
 * @return {Array}
 */


function slice() {
  return Function.call.apply(nativeSlice, arguments);
}
/**
 * Normalize css liked array configuration
 * e.g.
 *  3 => [3, 3, 3, 3]
 *  [4, 2] => [4, 2, 4, 2]
 *  [4, 3, 2] => [4, 3, 2, 3]
 * @param {number|Array.<number>} val
 * @return {Array.<number>}
 */


function normalizeCssArray(val) {
  if (typeof val === 'number') {
    return [val, val, val, val];
  }

  var len = val.length;

  if (len === 2) {
    // vertical | horizontal
    return [val[0], val[1], val[0], val[1]];
  } else if (len === 3) {
    // top | horizontal | bottom
    return [val[0], val[1], val[2], val[1]];
  }

  return val;
}
/**
 * @memberOf module:zrender/core/util
 * @param {boolean} condition
 * @param {string} message
 */


function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

var primitiveKey = '__ec_primitive__';
/**
 * Set an object as primitive to be ignored traversing children in clone or merge
 */

function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}

function isPrimitive(obj) {
  return obj[primitiveKey];
}
/**
 * @constructor
 * @param {Object} obj Only apply `ownProperty`.
 */


function HashMap(obj) {
  obj && each(obj, function (value, key) {
    this.set(key, value);
  }, this);
} // Add prefix to avoid conflict with Object.prototype.


var HASH_MAP_PREFIX = '_ec_';
var HASH_MAP_PREFIX_LENGTH = 4;
HashMap.prototype = {
  constructor: HashMap,
  // Do not provide `has` method to avoid defining what is `has`.
  // (We usually treat `null` and `undefined` as the same, different
  // from ES6 Map).
  get: function (key) {
    return this[HASH_MAP_PREFIX + key];
  },
  set: function (key, value) {
    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly
    // used in this case: `var someVal = map.set('a', genVal());`

    return value;
  },
  // Although util.each can be performed on this hashMap directly, user
  // should not use the exposed keys, who are prefixed.
  each: function (cb, context) {
    context !== void 0 && (cb = bind(cb, context));

    for (var prefixedKey in this) {
      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));
    }
  },
  // Do not use this method if performance sensitive.
  removeKey: function (key) {
    delete this[HASH_MAP_PREFIX + key];
  }
};

function createHashMap(obj) {
  return new HashMap(obj);
}

function noop() {}

exports.$override = $override;
exports.clone = clone;
exports.merge = merge;
exports.mergeAll = mergeAll;
exports.extend = extend;
exports.defaults = defaults;
exports.createCanvas = createCanvas;
exports.getContext = getContext;
exports.indexOf = indexOf;
exports.inherits = inherits;
exports.mixin = mixin;
exports.isArrayLike = isArrayLike;
exports.each = each;
exports.map = map;
exports.reduce = reduce;
exports.filter = filter;
exports.find = find;
exports.bind = bind;
exports.curry = curry;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isString = isString;
exports.isObject = isObject;
exports.isBuiltInObject = isBuiltInObject;
exports.isDom = isDom;
exports.eqNaN = eqNaN;
exports.retrieve = retrieve;
exports.retrieve2 = retrieve2;
exports.retrieve3 = retrieve3;
exports.slice = slice;
exports.normalizeCssArray = normalizeCssArray;
exports.assert = assert;
exports.setAsPrimitive = setAsPrimitive;
exports.isPrimitive = isPrimitive;
exports.createHashMap = createHashMap;
exports.noop = noop;

/***/ }),

/***/ "./node_modules/zrender/lib/core/vector.js":
/***/ (function(module, exports) {

var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
/**
 * 创建一个向量
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @return {Vector2}
 */

function create(x, y) {
  var out = new ArrayCtor(2);

  if (x == null) {
    x = 0;
  }

  if (y == null) {
    y = 0;
  }

  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * 复制向量数据
 * @param {Vector2} out
 * @param {Vector2} v
 * @return {Vector2}
 */


function copy(out, v) {
  out[0] = v[0];
  out[1] = v[1];
  return out;
}
/**
 * 克隆一个向量
 * @param {Vector2} v
 * @return {Vector2}
 */


function clone(v) {
  var out = new ArrayCtor(2);
  out[0] = v[0];
  out[1] = v[1];
  return out;
}
/**
 * 设置向量的两个项
 * @param {Vector2} out
 * @param {number} a
 * @param {number} b
 * @return {Vector2} 结果
 */


function set(out, a, b) {
  out[0] = a;
  out[1] = b;
  return out;
}
/**
 * 向量相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function add(out, v1, v2) {
  out[0] = v1[0] + v2[0];
  out[1] = v1[1] + v2[1];
  return out;
}
/**
 * 向量缩放后相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} a
 */


function scaleAndAdd(out, v1, v2, a) {
  out[0] = v1[0] + v2[0] * a;
  out[1] = v1[1] + v2[1] * a;
  return out;
}
/**
 * 向量相减
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function sub(out, v1, v2) {
  out[0] = v1[0] - v2[0];
  out[1] = v1[1] - v2[1];
  return out;
}
/**
 * 向量长度
 * @param {Vector2} v
 * @return {number}
 */


function len(v) {
  return Math.sqrt(lenSquare(v));
}

var length = len; // jshint ignore:line

/**
 * 向量长度平方
 * @param {Vector2} v
 * @return {number}
 */

function lenSquare(v) {
  return v[0] * v[0] + v[1] * v[1];
}

var lengthSquare = lenSquare;
/**
 * 向量乘法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */

function mul(out, v1, v2) {
  out[0] = v1[0] * v2[0];
  out[1] = v1[1] * v2[1];
  return out;
}
/**
 * 向量除法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function div(out, v1, v2) {
  out[0] = v1[0] / v2[0];
  out[1] = v1[1] / v2[1];
  return out;
}
/**
 * 向量点乘
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */


function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
/**
 * 向量缩放
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {number} s
 */


function scale(out, v, s) {
  out[0] = v[0] * s;
  out[1] = v[1] * s;
  return out;
}
/**
 * 向量归一化
 * @param {Vector2} out
 * @param {Vector2} v
 */


function normalize(out, v) {
  var d = len(v);

  if (d === 0) {
    out[0] = 0;
    out[1] = 0;
  } else {
    out[0] = v[0] / d;
    out[1] = v[1] / d;
  }

  return out;
}
/**
 * 计算向量间距离
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */


function distance(v1, v2) {
  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
}

var dist = distance;
/**
 * 向量距离平方
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */

function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}

var distSquare = distanceSquare;
/**
 * 求负向量
 * @param {Vector2} out
 * @param {Vector2} v
 */

function negate(out, v) {
  out[0] = -v[0];
  out[1] = -v[1];
  return out;
}
/**
 * 插值两个点
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} t
 */


function lerp(out, v1, v2, t) {
  out[0] = v1[0] + t * (v2[0] - v1[0]);
  out[1] = v1[1] + t * (v2[1] - v1[1]);
  return out;
}
/**
 * 矩阵左乘向量
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {Vector2} m
 */


function applyTransform(out, v, m) {
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * 求两个向量最小值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */


function min(out, v1, v2) {
  out[0] = Math.min(v1[0], v2[0]);
  out[1] = Math.min(v1[1], v2[1]);
  return out;
}
/**
 * 求两个向量最大值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */


function max(out, v1, v2) {
  out[0] = Math.max(v1[0], v2[0]);
  out[1] = Math.max(v1[1], v2[1]);
  return out;
}

exports.create = create;
exports.copy = copy;
exports.clone = clone;
exports.set = set;
exports.add = add;
exports.scaleAndAdd = scaleAndAdd;
exports.sub = sub;
exports.len = len;
exports.length = length;
exports.lenSquare = lenSquare;
exports.lengthSquare = lengthSquare;
exports.mul = mul;
exports.div = div;
exports.dot = dot;
exports.scale = scale;
exports.normalize = normalize;
exports.distance = distance;
exports.dist = dist;
exports.distanceSquare = distanceSquare;
exports.distSquare = distSquare;
exports.negate = negate;
exports.lerp = lerp;
exports.applyTransform = applyTransform;
exports.min = min;
exports.max = max;

/***/ }),

/***/ "./node_modules/zrender/lib/dom/HandlerProxy.js":
/***/ (function(module, exports, __webpack_require__) {

var _event = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var addEventListener = _event.addEventListener;
var removeEventListener = _event.removeEventListener;
var normalizeEvent = _event.normalizeEvent;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var GestureMgr = __webpack_require__("./node_modules/zrender/lib/core/GestureMgr.js");

var TOUCH_CLICK_DELAY = 300;
var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
var pointerEventNames = {
  pointerdown: 1,
  pointerup: 1,
  pointermove: 1,
  pointerout: 1
};
var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
  var nm = name.replace('mouse', 'pointer');
  return pointerEventNames[nm] ? nm : name;
});

function eventNameFix(name) {
  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;
}

function processGesture(proxy, event, stage) {
  var gestureMgr = proxy._gestureMgr;
  stage === 'start' && gestureMgr.clear();
  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);
  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.

  if (gestureInfo) {
    var type = gestureInfo.type;
    event.gestureEvent = type;
    proxy.handler.dispatchToElement({
      target: gestureInfo.target
    }, type, gestureInfo.event);
  }
} // function onMSGestureChange(proxy, event) {
//     if (event.translationX || event.translationY) {
//         // mousemove is carried by MSGesture to reduce the sensitivity.
//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
//     }
//     if (event.scale !== 1) {
//         event.pinchX = event.offsetX;
//         event.pinchY = event.offsetY;
//         event.pinchScale = event.scale;
//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
//     }
// }

/**
 * Prevent mouse event from being dispatched after Touch Events action
 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
 * Result: Blocking Mouse Events for 700ms.
 */


function setTouchTimer(instance) {
  instance._touching = true;
  clearTimeout(instance._touchTimer);
  instance._touchTimer = setTimeout(function () {
    instance._touching = false;
  }, 700);
}

var domHandlers = {
  /**
   * Mouse move handler
   * @inner
   * @param {Event} event
   */
  mousemove: function (event) {
    event = normalizeEvent(this.dom, event);
    this.trigger('mousemove', event);
  },

  /**
   * Mouse out handler
   * @inner
   * @param {Event} event
   */
  mouseout: function (event) {
    event = normalizeEvent(this.dom, event);
    var element = event.toElement || event.relatedTarget;

    if (element != this.dom) {
      while (element && element.nodeType != 9) {
        // 忽略包含在root中的dom引起的mouseOut
        if (element === this.dom) {
          return;
        }

        element = element.parentNode;
      }
    }

    this.trigger('mouseout', event);
  },

  /**
   * Touch开始响应函数
   * @inner
   * @param {Event} event
   */
  touchstart: function (event) {
    // Default mouse behaviour should not be disabled here.
    // For example, page may needs to be slided.
    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
    // mouse event in upper applicatoin.

    event.zrByTouch = true;
    this._lastTouchMoment = new Date();
    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should
    // be triggered, and must before `mousedown` triggered.

    domHandlers.mousemove.call(this, event);
    domHandlers.mousedown.call(this, event);
    setTouchTimer(this);
  },

  /**
   * Touch移动响应函数
   * @inner
   * @param {Event} event
   */
  touchmove: function (event) {
    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
    // mouse event in upper applicatoin.

    event.zrByTouch = true;
    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether
    // there is gestrue event, because mouse move and pinch may
    // be used at the same time.

    domHandlers.mousemove.call(this, event);
    setTouchTimer(this);
  },

  /**
   * Touch结束响应函数
   * @inner
   * @param {Event} event
   */
  touchend: function (event) {
    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
    // mouse event in upper applicatoin.

    event.zrByTouch = true;
    processGesture(this, event, 'end');
    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
    // we can conveniently implement "hover style" in both PC and touch device just
    // by listening to `mouseover` to add "hover style" and listening to `mouseout`
    // to remove "hover style" on an element, without any additional code for
    // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
    // style" will remain for user view)
    // click event should always be triggered no matter whether
    // there is gestrue event. System click can not be prevented.

    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
      domHandlers.click.call(this, event);
    }

    setTouchTimer(this);
  },
  pointerdown: function (event) {
    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
    //     this._msGesture.addPointer(event.pointerId);
    // }
  },
  pointermove: function (event) {
    // FIXME
    // pointermove is so sensitive that it always triggered when
    // tap(click) on touch screen, which affect some judgement in
    // upper application. So, we dont support mousemove on MS touch
    // device yet.
    if (!isPointerFromTouch(event)) {
      domHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function (event) {
    domHandlers.mouseup.call(this, event);
  },
  pointerout: function (event) {
    // pointerout will be triggered when tap on touch screen
    // (IE11+/Edge on MS Surface) after click event triggered,
    // which is inconsistent with the mousout behavior we defined
    // in touchend. So we unify them.
    // (check domHandlers.touchend for detailed explanation)
    if (!isPointerFromTouch(event)) {
      domHandlers.mouseout.call(this, event);
    }
  }
};

function isPointerFromTouch(event) {
  var pointerType = event.pointerType;
  return pointerType === 'pen' || pointerType === 'touch';
} // function useMSGuesture(handlerProxy, event) {
//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
// }
// Common handlers


zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
  domHandlers[name] = function (event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name, event);
  };
});
/**
 * 为控制类实例初始化dom 事件处理函数
 *
 * @inner
 * @param {module:zrender/Handler} instance 控制类实例
 */

function initDomHandler(instance) {
  zrUtil.each(touchHandlerNames, function (name) {
    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
  });
  zrUtil.each(pointerHandlerNames, function (name) {
    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
  });
  zrUtil.each(mouseHandlerNames, function (name) {
    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
  });

  function makeMouseHandler(fn, instance) {
    return function () {
      if (instance._touching) {
        return;
      }

      return fn.apply(instance, arguments);
    };
  }
}

function HandlerDomProxy(dom) {
  Eventful.call(this);
  this.dom = dom;
  /**
   * @private
   * @type {boolean}
   */

  this._touching = false;
  /**
   * @private
   * @type {number}
   */

  this._touchTimer;
  /**
   * @private
   * @type {module:zrender/core/GestureMgr}
   */

  this._gestureMgr = new GestureMgr();
  this._handlers = {};
  initDomHandler(this);

  if (env.pointerEventsSupported) {
    // Only IE11+/Edge
    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
    // at the same time.
    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
    // screen, which do not occurs in pointer event.
    // So we use pointer event to both detect touch gesture and mouse behavior.
    mountHandlers(pointerHandlerNames, this); // FIXME
    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
    // which does not prevent defuault behavior occasionally (which may cause view port
    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
    // So we have to not to use MSGesture and not to support touchmove and pinch on MS
    // touch screen. And we only support click behavior on MS touch screen now.
    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
    // We dont support touch on IE on win7.
    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
    // if (typeof MSGesture === 'function') {
    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
    //     dom.addEventListener('MSGestureChange', onMSGestureChange);
    // }
  } else {
    if (env.touchEventsSupported) {
      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
      // addEventListener(root, 'mouseout', this._mouseoutHandler);
    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
    // mouse event can not be handle in those devices.
    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
    // mouseevent after touch event triggered, see `setTouchTimer`.


    mountHandlers(mouseHandlerNames, this);
  }

  function mountHandlers(handlerNames, instance) {
    zrUtil.each(handlerNames, function (name) {
      addEventListener(dom, eventNameFix(name), instance._handlers[name]);
    }, instance);
  }
}

var handlerDomProxyProto = HandlerDomProxy.prototype;

handlerDomProxyProto.dispose = function () {
  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);

  for (var i = 0; i < handlerNames.length; i++) {
    var name = handlerNames[i];
    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
  }
};

handlerDomProxyProto.setCursor = function (cursorStyle) {
  this.dom.style.cursor = cursorStyle || 'default';
};

zrUtil.mixin(HandlerDomProxy, Eventful);
var _default = HandlerDomProxy;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/CompoundPath.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

// CompoundPath to improve performance
var _default = Path.extend({
  type: 'compound',
  shape: {
    paths: null
  },
  _updatePathDirty: function () {
    var dirtyPath = this.__dirtyPath;
    var paths = this.shape.paths;

    for (var i = 0; i < paths.length; i++) {
      // Mark as dirty if any subpath is dirty
      dirtyPath = dirtyPath || paths[i].__dirtyPath;
    }

    this.__dirtyPath = dirtyPath;
    this.__dirty = this.__dirty || dirtyPath;
  },
  beforeBrush: function () {
    this._updatePathDirty();

    var paths = this.shape.paths || [];
    var scale = this.getGlobalScale(); // Update path scale

    for (var i = 0; i < paths.length; i++) {
      if (!paths[i].path) {
        paths[i].createPathProxy();
      }

      paths[i].path.setScale(scale[0], scale[1]);
    }
  },
  buildPath: function (ctx, shape) {
    var paths = shape.paths || [];

    for (var i = 0; i < paths.length; i++) {
      paths[i].buildPath(ctx, paths[i].shape, true);
    }
  },
  afterBrush: function () {
    var paths = this.shape.paths || [];

    for (var i = 0; i < paths.length; i++) {
      paths[i].__dirtyPath = false;
    }
  },
  getBoundingRect: function () {
    this._updatePathDirty();

    return Path.prototype.getBoundingRect.call(this);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Displayable.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Style = __webpack_require__("./node_modules/zrender/lib/graphic/Style.js");

var Element = __webpack_require__("./node_modules/zrender/lib/Element.js");

var RectText = __webpack_require__("./node_modules/zrender/lib/graphic/mixin/RectText.js");

/**
 * 可绘制的图形基类
 * Base class of all displayable graphic objects
 * @module zrender/graphic/Displayable
 */

/**
 * @alias module:zrender/graphic/Displayable
 * @extends module:zrender/Element
 * @extends module:zrender/graphic/mixin/RectText
 */
function Displayable(opts) {
  opts = opts || {};
  Element.call(this, opts); // Extend properties

  for (var name in opts) {
    if (opts.hasOwnProperty(name) && name !== 'style') {
      this[name] = opts[name];
    }
  }
  /**
   * @type {module:zrender/graphic/Style}
   */


  this.style = new Style(opts.style, this);
  this._rect = null; // Shapes for cascade clipping.

  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted
  // Stateful.call(this, opts);
}

Displayable.prototype = {
  constructor: Displayable,
  type: 'displayable',

  /**
   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
   * Dirty flag. From which painter will determine if this displayable object needs brush
   * @name module:zrender/graphic/Displayable#__dirty
   * @type {boolean}
   */
  __dirty: true,

  /**
   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
   * If ignore drawing of the displayable object. Mouse event will still be triggered
   * @name module:/zrender/graphic/Displayable#invisible
   * @type {boolean}
   * @default false
   */
  invisible: false,

  /**
   * @name module:/zrender/graphic/Displayable#z
   * @type {number}
   * @default 0
   */
  z: 0,

  /**
   * @name module:/zrender/graphic/Displayable#z
   * @type {number}
   * @default 0
   */
  z2: 0,

  /**
   * z层level，决定绘画在哪层canvas中
   * @name module:/zrender/graphic/Displayable#zlevel
   * @type {number}
   * @default 0
   */
  zlevel: 0,

  /**
   * 是否可拖拽
   * @name module:/zrender/graphic/Displayable#draggable
   * @type {boolean}
   * @default false
   */
  draggable: false,

  /**
   * 是否正在拖拽
   * @name module:/zrender/graphic/Displayable#draggable
   * @type {boolean}
   * @default false
   */
  dragging: false,

  /**
   * 是否相应鼠标事件
   * @name module:/zrender/graphic/Displayable#silent
   * @type {boolean}
   * @default false
   */
  silent: false,

  /**
   * If enable culling
   * @type {boolean}
   * @default false
   */
  culling: false,

  /**
   * Mouse cursor when hovered
   * @name module:/zrender/graphic/Displayable#cursor
   * @type {string}
   */
  cursor: 'pointer',

  /**
   * If hover area is bounding rect
   * @name module:/zrender/graphic/Displayable#rectHover
   * @type {string}
   */
  rectHover: false,

  /**
   * Render the element progressively when the value >= 0,
   * usefull for large data.
   * @type {number}
   */
  progressive: -1,
  beforeBrush: function (ctx) {},
  afterBrush: function (ctx) {},

  /**
   * 图形绘制方法
   * @param {CanvasRenderingContext2D} ctx
   */
  // Interface
  brush: function (ctx, prevEl) {},

  /**
   * 获取最小包围盒
   * @return {module:zrender/core/BoundingRect}
   */
  // Interface
  getBoundingRect: function () {},

  /**
   * 判断坐标 x, y 是否在图形上
   * If displayable element contain coord x, y
   * @param  {number} x
   * @param  {number} y
   * @return {boolean}
   */
  contain: function (x, y) {
    return this.rectContain(x, y);
  },

  /**
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {
    cb.call(context, this);
  },

  /**
   * 判断坐标 x, y 是否在图形的包围盒上
   * If bounding rect of element contain coord x, y
   * @param  {number} x
   * @param  {number} y
   * @return {boolean}
   */
  rectContain: function (x, y) {
    var coord = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  },

  /**
   * 标记图形元素为脏，并且在下一帧重绘
   * Mark displayable element dirty and refresh next frame
   */
  dirty: function () {
    this.__dirty = true;
    this._rect = null;
    this.__zr && this.__zr.refresh();
  },

  /**
   * 图形是否会触发事件
   * If displayable object binded any event
   * @return {boolean}
   */
  // TODO, 通过 bind 绑定的事件
  // isSilent: function () {
  //     return !(
  //         this.hoverable || this.draggable
  //         || this.onmousemove || this.onmouseover || this.onmouseout
  //         || this.onmousedown || this.onmouseup || this.onclick
  //         || this.ondragenter || this.ondragover || this.ondragleave
  //         || this.ondrop
  //     );
  // },

  /**
   * Alias for animate('style')
   * @param {boolean} loop
   */
  animateStyle: function (loop) {
    return this.animate('style', loop);
  },
  attrKV: function (key, value) {
    if (key !== 'style') {
      Element.prototype.attrKV.call(this, key, value);
    } else {
      this.style.set(value);
    }
  },

  /**
   * @param {Object|string} key
   * @param {*} value
   */
  setStyle: function (key, value) {
    this.style.set(key, value);
    this.dirty(false);
    return this;
  },

  /**
   * Use given style object
   * @param  {Object} obj
   */
  useStyle: function (obj) {
    this.style = new Style(obj, this);
    this.dirty(false);
    return this;
  }
};
zrUtil.inherits(Displayable, Element);
zrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);

var _default = Displayable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Gradient.js":
/***/ (function(module, exports) {

/**
 * @param {Array.<Object>} colorStops
 */
var Gradient = function (colorStops) {
  this.colorStops = colorStops || [];
};

Gradient.prototype = {
  constructor: Gradient,
  addColorStop: function (offset, color) {
    this.colorStops.push({
      offset: offset,
      color: color
    });
  }
};
var _default = Gradient;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Image.js":
/***/ (function(module, exports, __webpack_require__) {

var Displayable = __webpack_require__("./node_modules/zrender/lib/graphic/Displayable.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var imageHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/image.js");

/**
 * @alias zrender/graphic/Image
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
function ZImage(opts) {
  Displayable.call(this, opts);
}

ZImage.prototype = {
  constructor: ZImage,
  type: 'image',
  brush: function (ctx, prevEl) {
    var style = this.style;
    var src = style.image; // Must bind each time

    style.bind(ctx, this, prevEl);
    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);

    if (!image || !imageHelper.isImageReady(image)) {
      return;
    } // 图片已经加载完成
    // if (image.nodeName.toUpperCase() == 'IMG') {
    //     if (!image.complete) {
    //         return;
    //     }
    // }
    // Else is canvas


    var x = style.x || 0;
    var y = style.y || 0;
    var width = style.width;
    var height = style.height;
    var aspect = image.width / image.height;

    if (width == null && height != null) {
      // Keep image/height ratio
      width = height * aspect;
    } else if (height == null && width != null) {
      height = width / aspect;
    } else if (width == null && height == null) {
      width = image.width;
      height = image.height;
    } // 设置transform


    this.setTransform(ctx);

    if (style.sWidth && style.sHeight) {
      var sx = style.sx || 0;
      var sy = style.sy || 0;
      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
    } else if (style.sx && style.sy) {
      var sx = style.sx;
      var sy = style.sy;
      var sWidth = width - sx;
      var sHeight = height - sy;
      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
    } else {
      ctx.drawImage(image, x, y, width, height);
    }

    this.restoreTransform(ctx); // Draw rect text

    if (style.text != null) {
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },
  getBoundingRect: function () {
    var style = this.style;

    if (!this._rect) {
      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
    }

    return this._rect;
  }
};
zrUtil.inherits(ZImage, Displayable);
var _default = ZImage;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/LinearGradient.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Gradient = __webpack_require__("./node_modules/zrender/lib/graphic/Gradient.js");

/**
 * x, y, x2, y2 are all percent from 0 to 1
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @param {number} [x2=1]
 * @param {number} [y2=0]
 * @param {Array.<Object>} colorStops
 * @param {boolean} [globalCoord=false]
 */
var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {type: 'linear', colorStops: ...}`, where
  // this constructor will not be called.
  this.x = x == null ? 0 : x;
  this.y = y == null ? 0 : y;
  this.x2 = x2 == null ? 1 : x2;
  this.y2 = y2 == null ? 0 : y2; // Can be cloned

  this.type = 'linear'; // If use global coord

  this.global = globalCoord || false;
  Gradient.call(this, colorStops);
};

LinearGradient.prototype = {
  constructor: LinearGradient
};
zrUtil.inherits(LinearGradient, Gradient);
var _default = LinearGradient;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Path.js":
/***/ (function(module, exports, __webpack_require__) {

var Displayable = __webpack_require__("./node_modules/zrender/lib/graphic/Displayable.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var PathProxy = __webpack_require__("./node_modules/zrender/lib/core/PathProxy.js");

var pathContain = __webpack_require__("./node_modules/zrender/lib/contain/path.js");

var Pattern = __webpack_require__("./node_modules/zrender/lib/graphic/Pattern.js");

var getCanvasPattern = Pattern.prototype.getCanvasPattern;
var abs = Math.abs;
var pathProxyForDraw = new PathProxy(true);
/**
 * @alias module:zrender/graphic/Path
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */

function Path(opts) {
  Displayable.call(this, opts);
  /**
   * @type {module:zrender/core/PathProxy}
   * @readOnly
   */

  this.path = null;
}

Path.prototype = {
  constructor: Path,
  type: 'path',
  __dirtyPath: true,
  strokeContainThreshold: 5,
  brush: function (ctx, prevEl) {
    var style = this.style;
    var path = this.path || pathProxyForDraw;
    var hasStroke = style.hasStroke();
    var hasFill = style.hasFill();
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill && !!fill.colorStops;
    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
    var hasFillPattern = hasFill && !!fill.image;
    var hasStrokePattern = hasStroke && !!stroke.image;
    style.bind(ctx, this, prevEl);
    this.setTransform(ctx);

    if (this.__dirty) {
      var rect; // Update gradient because bounding rect may changed

      if (hasFillGradient) {
        rect = rect || this.getBoundingRect();
        this._fillGradient = style.getGradient(ctx, fill, rect);
      }

      if (hasStrokeGradient) {
        rect = rect || this.getBoundingRect();
        this._strokeGradient = style.getGradient(ctx, stroke, rect);
      }
    } // Use the gradient or pattern


    if (hasFillGradient) {
      // PENDING If may have affect the state
      ctx.fillStyle = this._fillGradient;
    } else if (hasFillPattern) {
      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
    }

    if (hasStrokeGradient) {
      ctx.strokeStyle = this._strokeGradient;
    } else if (hasStrokePattern) {
      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
    }

    var lineDash = style.lineDash;
    var lineDashOffset = style.lineDashOffset;
    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy

    var scale = this.getGlobalScale();
    path.setScale(scale[0], scale[1]); // Proxy context
    // Rebuild path in following 2 cases
    // 1. Path is dirty
    // 2. Path needs javascript implemented lineDash stroking.
    //    In this case, lineDash information will not be saved in PathProxy

    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
      path.beginPath(ctx); // Setting line dash before build path

      if (lineDash && !ctxLineDash) {
        path.setLineDash(lineDash);
        path.setLineDashOffset(lineDashOffset);
      }

      this.buildPath(path, this.shape, false); // Clear path dirty flag

      if (this.path) {
        this.__dirtyPath = false;
      }
    } else {
      // Replay path building
      ctx.beginPath();
      this.path.rebuildPath(ctx);
    }

    hasFill && path.fill(ctx);

    if (lineDash && ctxLineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }

    hasStroke && path.stroke(ctx);

    if (lineDash && ctxLineDash) {
      // PENDING
      // Remove lineDash
      ctx.setLineDash([]);
    }

    this.restoreTransform(ctx); // Draw rect text

    if (style.text != null) {
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },
  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
  // Like in circle
  buildPath: function (ctx, shapeCfg, inBundle) {},
  createPathProxy: function () {
    this.path = new PathProxy();
  },
  getBoundingRect: function () {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;

    if (needsUpdateRect) {
      var path = this.path;

      if (!path) {
        // Create path on demand.
        path = this.path = new PathProxy();
      }

      if (this.__dirtyPath) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
      }

      rect = path.getBoundingRect();
    }

    this._rect = rect;

    if (style.hasStroke()) {
      // Needs update rect with stroke lineWidth when
      // 1. Element changes scale or lineWidth
      // 2. Shape is changed
      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());

      if (this.__dirty || needsUpdateRect) {
        rectWithStroke.copy(rect); // FIXME Must after updateTransform

        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical

        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill

        if (!style.hasFill()) {
          w = Math.max(w, this.strokeContainThreshold || 4);
        } // Consider line width
        // Line scale can't be 0;


        if (lineScale > 1e-10) {
          rectWithStroke.width += w / lineScale;
          rectWithStroke.height += w / lineScale;
          rectWithStroke.x -= w / lineScale / 2;
          rectWithStroke.y -= w / lineScale / 2;
        }
      } // Return rect with stroke


      return rectWithStroke;
    }

    return rect;
  },
  contain: function (x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    var style = this.style;
    x = localPos[0];
    y = localPos[1];

    if (rect.contain(x, y)) {
      var pathData = this.path.data;

      if (style.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;

        if (lineScale > 1e-10) {
          // Only add extra hover lineWidth when there are no fill
          if (!style.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }

          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
            return true;
          }
        }
      }

      if (style.hasFill()) {
        return pathContain.contain(pathData, x, y);
      }
    }

    return false;
  },

  /**
   * @param  {boolean} dirtyPath
   */
  dirty: function (dirtyPath) {
    if (dirtyPath == null) {
      dirtyPath = true;
    } // Only mark dirty, not mark clean


    if (dirtyPath) {
      this.__dirtyPath = dirtyPath;
      this._rect = null;
    }

    this.__dirty = true;
    this.__zr && this.__zr.refresh(); // Used as a clipping path

    if (this.__clipTarget) {
      this.__clipTarget.dirty();
    }
  },

  /**
   * Alias for animate('shape')
   * @param {boolean} loop
   */
  animateShape: function (loop) {
    return this.animate('shape', loop);
  },
  // Overwrite attrKV
  attrKV: function (key, value) {
    // FIXME
    if (key === 'shape') {
      this.setShape(value);
      this.__dirtyPath = true;
      this._rect = null;
    } else {
      Displayable.prototype.attrKV.call(this, key, value);
    }
  },

  /**
   * @param {Object|string} key
   * @param {*} value
   */
  setShape: function (key, value) {
    var shape = this.shape; // Path from string may not have shape

    if (shape) {
      if (zrUtil.isObject(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            shape[name] = key[name];
          }
        }
      } else {
        shape[key] = value;
      }

      this.dirty(true);
    }

    return this;
  },
  getLineScale: function () {
    var m = this.transform; // Get the line scale.
    // Determinant of `m` means how much the area is enlarged by the
    // transformation. So its square root can be used as a scale factor
    // for width.

    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
  }
};
/**
 * 扩展一个 Path element, 比如星形，圆等。
 * Extend a path element
 * @param {Object} props
 * @param {string} props.type Path type
 * @param {Function} props.init Initialize
 * @param {Function} props.buildPath Overwrite buildPath method
 * @param {Object} [props.style] Extended default style config
 * @param {Object} [props.shape] Extended default shape config
 */

Path.extend = function (defaults) {
  var Sub = function (opts) {
    Path.call(this, opts);

    if (defaults.style) {
      // Extend default style
      this.style.extendFrom(defaults.style, false);
    } // Extend default shape


    var defaultShape = defaults.shape;

    if (defaultShape) {
      this.shape = this.shape || {};
      var thisShape = this.shape;

      for (var name in defaultShape) {
        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
          thisShape[name] = defaultShape[name];
        }
      }
    }

    defaults.init && defaults.init.call(this, opts);
  };

  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象

  for (var name in defaults) {
    // Extending prototype values and methods
    if (name !== 'style' && name !== 'shape') {
      Sub.prototype[name] = defaults[name];
    }
  }

  return Sub;
};

zrUtil.inherits(Path, Displayable);
var _default = Path;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Pattern.js":
/***/ (function(module, exports) {

var Pattern = function (image, repeat) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {image: ...}`, where this constructor will not be called.
  this.image = image;
  this.repeat = repeat; // Can be cloned

  this.type = 'pattern';
};

Pattern.prototype.getCanvasPattern = function (ctx) {
  return ctx.createPattern(this.image, this.repeat || 'repeat');
};

var _default = Pattern;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/RadialGradient.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Gradient = __webpack_require__("./node_modules/zrender/lib/graphic/Gradient.js");

/**
 * x, y, r are all percent from 0 to 1
 * @param {number} [x=0.5]
 * @param {number} [y=0.5]
 * @param {number} [r=0.5]
 * @param {Array.<Object>} [colorStops]
 * @param {boolean} [globalCoord=false]
 */
var RadialGradient = function (x, y, r, colorStops, globalCoord) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {type: 'radial', colorStops: ...}`, where
  // this constructor will not be called.
  this.x = x == null ? 0.5 : x;
  this.y = y == null ? 0.5 : y;
  this.r = r == null ? 0.5 : r; // Can be cloned

  this.type = 'radial'; // If use global coord

  this.global = globalCoord || false;
  Gradient.call(this, colorStops);
};

RadialGradient.prototype = {
  constructor: RadialGradient
};
zrUtil.inherits(RadialGradient, Gradient);
var _default = RadialGradient;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Style.js":
/***/ (function(module, exports) {

var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);

var Style = function (opts, host) {
  this.extendFrom(opts, false);
  this.host = host;
};

function createLinearGradient(ctx, obj, rect) {
  var x = obj.x == null ? 0 : obj.x;
  var x2 = obj.x2 == null ? 1 : obj.x2;
  var y = obj.y == null ? 0 : obj.y;
  var y2 = obj.y2 == null ? 0 : obj.y2;

  if (!obj.global) {
    x = x * rect.width + rect.x;
    x2 = x2 * rect.width + rect.x;
    y = y * rect.height + rect.y;
    y2 = y2 * rect.height + rect.y;
  }

  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
  return canvasGradient;
}

function createRadialGradient(ctx, obj, rect) {
  var width = rect.width;
  var height = rect.height;
  var min = Math.min(width, height);
  var x = obj.x == null ? 0.5 : obj.x;
  var y = obj.y == null ? 0.5 : obj.y;
  var r = obj.r == null ? 0.5 : obj.r;

  if (!obj.global) {
    x = x * width + rect.x;
    y = y * height + rect.y;
    r = r * min;
  }

  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
  return canvasGradient;
}

Style.prototype = {
  constructor: Style,

  /**
   * @type {module:zrender/graphic/Displayable}
   */
  host: null,

  /**
   * @type {string}
   */
  fill: '#000',

  /**
   * @type {string}
   */
  stroke: null,

  /**
   * @type {number}
   */
  opacity: 1,

  /**
   * @type {Array.<number>}
   */
  lineDash: null,

  /**
   * @type {number}
   */
  lineDashOffset: 0,

  /**
   * @type {number}
   */
  shadowBlur: 0,

  /**
   * @type {number}
   */
  shadowOffsetX: 0,

  /**
   * @type {number}
   */
  shadowOffsetY: 0,

  /**
   * @type {number}
   */
  lineWidth: 1,

  /**
   * If stroke ignore scale
   * @type {Boolean}
   */
  strokeNoScale: false,
  // Bounding rect text configuration
  // Not affected by element transform

  /**
   * @type {string}
   */
  text: null,

  /**
   * If `fontSize` or `fontFamily` exists, `font` will be reset by
   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
   * So do not visit it directly in upper application (like echarts),
   * but use `contain/text#makeFont` instead.
   * @type {string}
   */
  font: null,

  /**
   * The same as font. Use font please.
   * @deprecated
   * @type {string}
   */
  textFont: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontStyle: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontWeight: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * Should be 12 but not '12px'.
   * @type {number}
   */
  fontSize: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontFamily: null,

  /**
   * Reserved for special functinality, like 'hr'.
   * @type {string}
   */
  textTag: null,

  /**
   * @type {string}
   */
  textFill: '#000',

  /**
   * @type {string}
   */
  textStroke: null,

  /**
   * @type {number}
   */
  textWidth: null,

  /**
   * Only for textBackground.
   * @type {number}
   */
  textHeight: null,

  /**
   * textStroke may be set as some color as a default
   * value in upper applicaion, where the default value
   * of textStrokeWidth should be 0 to make sure that
   * user can choose to do not use text stroke.
   * @type {number}
   */
  textStrokeWidth: 0,

  /**
   * @type {number}
   */
  textLineHeight: null,

  /**
   * 'inside', 'left', 'right', 'top', 'bottom'
   * [x, y]
   * Based on x, y of rect.
   * @type {string|Array.<number>}
   * @default 'inside'
   */
  textPosition: 'inside',

  /**
   * If not specified, use the boundingRect of a `displayable`.
   * @type {Object}
   */
  textRect: null,

  /**
   * [x, y]
   * @type {Array.<number>}
   */
  textOffset: null,

  /**
   * @type {string}
   */
  textAlign: null,

  /**
   * @type {string}
   */
  textVerticalAlign: null,

  /**
   * @type {number}
   */
  textDistance: 5,

  /**
   * @type {string}
   */
  textShadowColor: 'transparent',

  /**
   * @type {number}
   */
  textShadowBlur: 0,

  /**
   * @type {number}
   */
  textShadowOffsetX: 0,

  /**
   * @type {number}
   */
  textShadowOffsetY: 0,

  /**
   * @type {string}
   */
  textBoxShadowColor: 'transparent',

  /**
   * @type {number}
   */
  textBoxShadowBlur: 0,

  /**
   * @type {number}
   */
  textBoxShadowOffsetX: 0,

  /**
   * @type {number}
   */
  textBoxShadowOffsetY: 0,

  /**
   * Whether transform text.
   * Only useful in Path and Image element
   * @type {boolean}
   */
  transformText: false,

  /**
   * Text rotate around position of Path or Image
   * Only useful in Path and Image element and transformText is false.
   */
  textRotation: 0,

  /**
   * Text origin of text rotation, like [10, 40].
   * Based on x, y of rect.
   * Useful in label rotation of circular symbol.
   * By default, this origin is textPosition.
   * Can be 'center'.
   * @type {string|Array.<number>}
   */
  textOrigin: null,

  /**
   * @type {string}
   */
  textBackgroundColor: null,

  /**
   * @type {string}
   */
  textBorderColor: null,

  /**
   * @type {number}
   */
  textBorderWidth: 0,

  /**
   * @type {number}
   */
  textBorderRadius: 0,

  /**
   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
   * @type {number|Array.<number>}
   */
  textPadding: null,

  /**
   * Text styles for rich text.
   * @type {Object}
   */
  rich: null,

  /**
   * {outerWidth, outerHeight, ellipsis, placeholder}
   * @type {Object}
   */
  truncate: null,

  /**
   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
   * @type {string}
   */
  blend: null,

  /**
   * @param {CanvasRenderingContext2D} ctx
   */
  bind: function (ctx, el, prevEl) {
    var style = this;
    var prevStyle = prevEl && prevEl.style;
    var firstDraw = !prevStyle;

    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
      var prop = STYLE_COMMON_PROPS[i];
      var styleName = prop[0];

      if (firstDraw || style[styleName] !== prevStyle[styleName]) {
        // FIXME Invalid property value will cause style leak from previous element.
        ctx[styleName] = style[styleName] || prop[1];
      }
    }

    if (firstDraw || style.fill !== prevStyle.fill) {
      ctx.fillStyle = style.fill;
    }

    if (firstDraw || style.stroke !== prevStyle.stroke) {
      ctx.strokeStyle = style.stroke;
    }

    if (firstDraw || style.opacity !== prevStyle.opacity) {
      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
    }

    if (firstDraw || style.blend !== prevStyle.blend) {
      ctx.globalCompositeOperation = style.blend || 'source-over';
    }

    if (this.hasStroke()) {
      var lineWidth = style.lineWidth;
      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
    }
  },
  hasFill: function () {
    var fill = this.fill;
    return fill != null && fill !== 'none';
  },
  hasStroke: function () {
    var stroke = this.stroke;
    return stroke != null && stroke !== 'none' && this.lineWidth > 0;
  },

  /**
   * Extend from other style
   * @param {zrender/graphic/Style} otherStyle
   * @param {boolean} overwrite true: overwrirte any way.
   *                            false: overwrite only when !target.hasOwnProperty
   *                            others: overwrite when property is not null/undefined.
   */
  extendFrom: function (otherStyle, overwrite) {
    if (otherStyle) {
      for (var name in otherStyle) {
        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
          this[name] = otherStyle[name];
        }
      }
    }
  },

  /**
   * Batch setting style with a given object
   * @param {Object|string} obj
   * @param {*} [obj]
   */
  set: function (obj, value) {
    if (typeof obj === 'string') {
      this[obj] = value;
    } else {
      this.extendFrom(obj, true);
    }
  },

  /**
   * Clone
   * @return {zrender/graphic/Style} [description]
   */
  clone: function () {
    var newStyle = new this.constructor();
    newStyle.extendFrom(this, true);
    return newStyle;
  },
  getGradient: function (ctx, obj, rect) {
    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
    var canvasGradient = method(ctx, obj, rect);
    var colorStops = obj.colorStops;

    for (var i = 0; i < colorStops.length; i++) {
      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
    }

    return canvasGradient;
  }
};
var styleProto = Style.prototype;

for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
  var prop = STYLE_COMMON_PROPS[i];

  if (!(prop[0] in styleProto)) {
    styleProto[prop[0]] = prop[1];
  }
} // Provide for others


Style.getGradient = styleProto.getGradient;
var _default = Style;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Text.js":
/***/ (function(module, exports, __webpack_require__) {

var Displayable = __webpack_require__("./node_modules/zrender/lib/graphic/Displayable.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var textHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/text.js");

/**
 * @alias zrender/graphic/Text
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
var Text = function (opts) {
  // jshint ignore:line
  Displayable.call(this, opts);
};

Text.prototype = {
  constructor: Text,
  type: 'text',
  brush: function (ctx, prevEl) {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.

    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
    var text = style.text; // Convert to string

    text != null && (text += ''); // Always bind style

    style.bind(ctx, this, prevEl);

    if (!textHelper.needDrawText(text, style)) {
      return;
    }

    this.setTransform(ctx);
    textHelper.renderText(this, ctx, text, style);
    this.restoreTransform(ctx);
  },
  getBoundingRect: function () {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true);

    if (!this._rect) {
      var text = style.text;
      text != null ? text += '' : text = '';
      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);
      rect.x += style.x || 0;
      rect.y += style.y || 0;

      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
        var w = style.textStrokeWidth;
        rect.x -= w / 2;
        rect.y -= w / 2;
        rect.width += w;
        rect.height += w;
      }

      this._rect = rect;
    }

    return this._rect;
  }
};
zrUtil.inherits(Text, Displayable);
var _default = Text;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js":
/***/ (function(module, exports, __webpack_require__) {

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

// Fix weird bug in some version of IE11 (like 11.0.9600.178**),
// where exception "unexpected call to method or property access"
// might be thrown when calling ctx.fill or ctx.stroke after a path
// whose area size is zero is drawn and ctx.clip() is called and
// shadowBlur is set. See #4572, #3112, #5777.
// (e.g.,
//  ctx.moveTo(10, 10);
//  ctx.lineTo(20, 10);
//  ctx.closePath();
//  ctx.clip();
//  ctx.shadowBlur = 10;
//  ...
//  ctx.fill();
// )
var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];

function _default(orignalBrush) {
  // version string can be: '11.0'
  return env.browser.ie && env.browser.version >= 11 ? function () {
    var clipPaths = this.__clipPaths;
    var style = this.style;
    var modified;

    if (clipPaths) {
      for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];
        var shape = clipPath && clipPath.shape;
        var type = clipPath && clipPath.type;

        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
          for (var j = 0; j < shadowTemp.length; j++) {
            // It is save to put shadowTemp static, because shadowTemp
            // will be all modified each item brush called.
            shadowTemp[j][2] = style[shadowTemp[j][0]];
            style[shadowTemp[j][0]] = shadowTemp[j][1];
          }

          modified = true;
          break;
        }
      }
    }

    orignalBrush.apply(this, arguments);

    if (modified) {
      for (var j = 0; j < shadowTemp.length; j++) {
        style[shadowTemp[j][0]] = shadowTemp[j][2];
      }
    }
  } : orignalBrush;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/image.js":
/***/ (function(module, exports, __webpack_require__) {

var LRU = __webpack_require__("./node_modules/zrender/lib/core/LRU.js");

var globalImageCache = new LRU(50);
/**
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */

function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === 'string') {
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
/**
 * Caution: User should cache loaded images, but not just count on LRU.
 * Consider if required images more than LRU size, will dead loop occur?
 *
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
 * @param {Function} [cb] params: (image, cbPayload)
 * @param {Object} [cbPayload] Payload on cb calling.
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */


function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === 'string') {
    // Image should not be loaded repeatly.
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    } // Only when there is no existent image or existent image src
    // is different, this method is responsible for load.


    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    var pendingWrap = {
      hostEl: hostEl,
      cb: cb,
      cbPayload: cbPayload
    };

    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      !image && (image = new Image());
      image.onload = imageOnLoad;
      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
        image: image,
        pending: [pendingWrap]
      });
      image.src = image.__zrImageSrc = newImageOrSrc;
    }

    return image;
  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
  else {
      return newImageOrSrc;
    }
}

function imageOnLoad() {
  var cachedImgObj = this.__cachedImgObj;
  this.onload = this.__cachedImgObj = null;

  for (var i = 0; i < cachedImgObj.pending.length; i++) {
    var pendingWrap = cachedImgObj.pending[i];
    var cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }

  cachedImgObj.pending.length = 0;
}

function isImageReady(image) {
  return image && image.width && image.height;
}

exports.findExistImage = findExistImage;
exports.createOrUpdateImage = createOrUpdateImage;
exports.isImageReady = isImageReady;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/poly.js":
/***/ (function(module, exports, __webpack_require__) {

var smoothSpline = __webpack_require__("./node_modules/zrender/lib/graphic/helper/smoothSpline.js");

var smoothBezier = __webpack_require__("./node_modules/zrender/lib/graphic/helper/smoothBezier.js");

function buildPath(ctx, shape, closePath) {
  var points = shape.points;
  var smooth = shape.smooth;

  if (points && points.length >= 2) {
    if (smooth && smooth !== 'spline') {
      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points[0][0], points[0][1]);
      var len = points.length;

      for (var i = 0; i < (closePath ? len : len - 1); i++) {
        var cp1 = controlPoints[i * 2];
        var cp2 = controlPoints[i * 2 + 1];
        var p = points[(i + 1) % len];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
      }
    } else {
      if (smooth === 'spline') {
        points = smoothSpline(points, closePath);
      }

      ctx.moveTo(points[0][0], points[0][1]);

      for (var i = 1, l = points.length; i < l; i++) {
        ctx.lineTo(points[i][0], points[i][1]);
      }
    }

    closePath && ctx.closePath();
  }
}

exports.buildPath = buildPath;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/roundRect.js":
/***/ (function(module, exports) {

function buildPath(ctx, shape) {
  var x = shape.x;
  var y = shape.y;
  var width = shape.width;
  var height = shape.height;
  var r = shape.r;
  var r1;
  var r2;
  var r3;
  var r4; // Convert width and height to positive for better borderRadius

  if (width < 0) {
    x = x + width;
    width = -width;
  }

  if (height < 0) {
    y = y + height;
    height = -height;
  }

  if (typeof r === 'number') {
    r1 = r2 = r3 = r4 = r;
  } else if (r instanceof Array) {
    if (r.length === 1) {
      r1 = r2 = r3 = r4 = r[0];
    } else if (r.length === 2) {
      r1 = r3 = r[0];
      r2 = r4 = r[1];
    } else if (r.length === 3) {
      r1 = r[0];
      r2 = r4 = r[1];
      r3 = r[2];
    } else {
      r1 = r[0];
      r2 = r[1];
      r3 = r[2];
      r4 = r[3];
    }
  } else {
    r1 = r2 = r3 = r4 = 0;
  }

  var total;

  if (r1 + r2 > width) {
    total = r1 + r2;
    r1 *= width / total;
    r2 *= width / total;
  }

  if (r3 + r4 > width) {
    total = r3 + r4;
    r3 *= width / total;
    r4 *= width / total;
  }

  if (r2 + r3 > height) {
    total = r2 + r3;
    r2 *= height / total;
    r3 *= height / total;
  }

  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }

  ctx.moveTo(x + r1, y);
  ctx.lineTo(x + width - r2, y);
  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
  ctx.lineTo(x + width, y + height - r3);
  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
  ctx.lineTo(x + r4, y + height);
  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
  ctx.lineTo(x, y + r1);
  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
}

exports.buildPath = buildPath;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/smoothBezier.js":
/***/ (function(module, exports, __webpack_require__) {

var _vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var v2Min = _vector.min;
var v2Max = _vector.max;
var v2Scale = _vector.scale;
var v2Distance = _vector.distance;
var v2Add = _vector.add;
var v2Clone = _vector.clone;
var v2Sub = _vector.sub;

/**
 * 贝塞尔平滑曲线
 * @module zrender/shape/util/smoothBezier
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 */

/**
 * 贝塞尔平滑曲线
 * @alias module:zrender/shape/util/smoothBezier
 * @param {Array} points 线段顶点数组
 * @param {number} smooth 平滑等级, 0-1
 * @param {boolean} isLoop
 * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
 *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
 *                           整个折线的包围盒做一个并集用来约束控制点。
 * @param {Array} 计算出来的控制点数组
 */
function _default(points, smooth, isLoop, constraint) {
  var cps = [];
  var v = [];
  var v1 = [];
  var v2 = [];
  var prevPoint;
  var nextPoint;
  var min, max;

  if (constraint) {
    min = [Infinity, Infinity];
    max = [-Infinity, -Infinity];

    for (var i = 0, len = points.length; i < len; i++) {
      v2Min(min, min, points[i]);
      v2Max(max, max, points[i]);
    } // 与指定的包围盒做并集


    v2Min(min, min, constraint[0]);
    v2Max(max, max, constraint[1]);
  }

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (isLoop) {
      prevPoint = points[i ? i - 1 : len - 1];
      nextPoint = points[(i + 1) % len];
    } else {
      if (i === 0 || i === len - 1) {
        cps.push(v2Clone(points[i]));
        continue;
      } else {
        prevPoint = points[i - 1];
        nextPoint = points[i + 1];
      }
    }

    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length

    v2Scale(v, v, smooth);
    var d0 = v2Distance(point, prevPoint);
    var d1 = v2Distance(point, nextPoint);
    var sum = d0 + d1;

    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }

    v2Scale(v1, v, -d0);
    v2Scale(v2, v, d1);
    var cp0 = v2Add([], point, v1);
    var cp1 = v2Add([], point, v2);

    if (constraint) {
      v2Max(cp0, cp0, min);
      v2Min(cp0, cp0, max);
      v2Max(cp1, cp1, min);
      v2Min(cp1, cp1, max);
    }

    cps.push(cp0);
    cps.push(cp1);
  }

  if (isLoop) {
    cps.push(cps.shift());
  }

  return cps;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/smoothSpline.js":
/***/ (function(module, exports, __webpack_require__) {

var _vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var v2Distance = _vector.distance;

/**
 * Catmull-Rom spline 插值折线
 * @module zrender/shape/util/smoothSpline
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 */

/**
 * @inner
 */
function interpolate(p0, p1, p2, p3, t, t2, t3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}
/**
 * @alias module:zrender/shape/util/smoothSpline
 * @param {Array} points 线段顶点数组
 * @param {boolean} isLoop
 * @return {Array}
 */


function _default(points, isLoop) {
  var len = points.length;
  var ret = [];
  var distance = 0;

  for (var i = 1; i < len; i++) {
    distance += v2Distance(points[i - 1], points[i]);
  }

  var segs = distance / 2;
  segs = segs < len ? len : segs;

  for (var i = 0; i < segs; i++) {
    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
    var idx = Math.floor(pos);
    var w = pos - idx;
    var p0;
    var p1 = points[idx % len];
    var p2;
    var p3;

    if (!isLoop) {
      p0 = points[idx === 0 ? idx : idx - 1];
      p2 = points[idx > len - 2 ? len - 1 : idx + 1];
      p3 = points[idx > len - 3 ? len - 1 : idx + 2];
    } else {
      p0 = points[(idx - 1 + len) % len];
      p2 = points[(idx + 1) % len];
      p3 = points[(idx + 2) % len];
    }

    var w2 = w * w;
    var w3 = w * w2;
    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
  }

  return ret;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/text.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var retrieve2 = _util.retrieve2;
var retrieve3 = _util.retrieve3;
var each = _util.each;
var normalizeCssArray = _util.normalizeCssArray;
var isString = _util.isString;
var isObject = _util.isObject;

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var roundRectHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/roundRect.js");

var imageHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/image.js");

// TODO: Have not support 'start', 'end' yet.
var VALID_TEXT_ALIGN = {
  left: 1,
  right: 1,
  center: 1
};
var VALID_TEXT_VERTICAL_ALIGN = {
  top: 1,
  bottom: 1,
  middle: 1
};
/**
 * @param {module:zrender/graphic/Style} style
 * @return {module:zrender/graphic/Style} The input style.
 */

function normalizeTextStyle(style) {
  normalizeStyle(style);
  each(style.rich, normalizeStyle);
  return style;
}

function normalizeStyle(style) {
  if (style) {
    style.font = textContain.makeFont(style);
    var textAlign = style.textAlign;
    textAlign === 'middle' && (textAlign = 'center');
    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.

    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
    var textPadding = style.textPadding;

    if (textPadding) {
      style.textPadding = normalizeCssArray(style.textPadding);
    }
  }
}
/**
 * @param {CanvasRenderingContext2D} ctx
 * @param {string} text
 * @param {module:zrender/graphic/Style} style
 * @param {Object|boolean} [rect] {x, y, width, height}
 *                  If set false, rect text is not used.
 */


function renderText(hostEl, ctx, text, style, rect) {
  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);
}

function renderPlainText(hostEl, ctx, text, style, rect) {
  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);
  var textPadding = style.textPadding;
  var contentBlock = hostEl.__textCotentBlock;

  if (!contentBlock || hostEl.__dirty) {
    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);
  }

  var outerHeight = contentBlock.outerHeight;
  var textLines = contentBlock.lines;
  var lineHeight = contentBlock.lineHeight;
  var boxPos = getBoxPosition(outerHeight, style, rect);
  var baseX = boxPos.baseX;
  var baseY = boxPos.baseY;
  var textAlign = boxPos.textAlign;
  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

  applyTextRotation(ctx, style, rect, baseX, baseY);
  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var textX = baseX;
  var textY = boxY;
  var needDrawBg = needDrawBackground(style);

  if (needDrawBg || textPadding) {
    // Consider performance, do not call getTextWidth util necessary.
    var textWidth = textContain.getWidth(text, font);
    var outerWidth = textWidth;
    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      textY += textPadding[0];
    }
  }

  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be "middle". Otherwise, if using "top", the
  // text will offset downward a little bit in font "Microsoft YaHei".

  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.

  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.

  textY += lineHeight / 2;
  var textStrokeWidth = style.textStrokeWidth;
  var textStroke = getStroke(style.textStroke, textStrokeWidth);
  var textFill = getFill(style.textFill);

  if (textStroke) {
    setCtx(ctx, 'lineWidth', textStrokeWidth);
    setCtx(ctx, 'strokeStyle', textStroke);
  }

  if (textFill) {
    setCtx(ctx, 'fillStyle', textFill);
  }

  for (var i = 0; i < textLines.length; i++) {
    // Fill after stroke so the outline will not cover the main part.
    textStroke && ctx.strokeText(textLines[i], textX, textY);
    textFill && ctx.fillText(textLines[i], textX, textY);
    textY += lineHeight;
  }
}

function renderRichText(hostEl, ctx, text, style, rect) {
  var contentBlock = hostEl.__textCotentBlock;

  if (!contentBlock || hostEl.__dirty) {
    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
  }

  drawRichText(hostEl, ctx, contentBlock, style, rect);
}

function drawRichText(hostEl, ctx, contentBlock, style, rect) {
  var contentWidth = contentBlock.width;
  var outerWidth = contentBlock.outerWidth;
  var outerHeight = contentBlock.outerHeight;
  var textPadding = style.textPadding;
  var boxPos = getBoxPosition(outerHeight, style, rect);
  var baseX = boxPos.baseX;
  var baseY = boxPos.baseY;
  var textAlign = boxPos.textAlign;
  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

  applyTextRotation(ctx, style, rect, baseX, baseY);
  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var xLeft = boxX;
  var lineTop = boxY;

  if (textPadding) {
    xLeft += textPadding[3];
    lineTop += textPadding[0];
  }

  var xRight = xLeft + contentWidth;
  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

  for (var i = 0; i < contentBlock.lines.length; i++) {
    var line = contentBlock.lines[i];
    var tokens = line.tokens;
    var tokenCount = tokens.length;
    var lineHeight = line.lineHeight;
    var usedWidth = line.width;
    var leftIndex = 0;
    var lineXLeft = xLeft;
    var lineXRight = xRight;
    var rightIndex = tokenCount - 1;
    var token;

    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
      usedWidth -= token.width;
      lineXLeft += token.width;
      leftIndex++;
    }

    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
      usedWidth -= token.width;
      lineXRight -= token.width;
      rightIndex--;
    } // The other tokens are placed as textAlign 'center' if there is enough space.


    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;

    while (leftIndex <= rightIndex) {
      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.

      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
      lineXLeft += token.width;
      leftIndex++;
    }

    lineTop += lineHeight;
  }
}

function applyTextRotation(ctx, style, rect, x, y) {
  // textRotation only apply in RectText.
  if (rect && style.textRotation) {
    var origin = style.textOrigin;

    if (origin === 'center') {
      x = rect.width / 2 + rect.x;
      y = rect.height / 2 + rect.y;
    } else if (origin) {
      x = origin[0] + rect.x;
      y = origin[1] + rect.y;
    }

    ctx.translate(x, y); // Positive: anticlockwise

    ctx.rotate(-style.textRotation);
    ctx.translate(-x, -y);
  }
}

function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of
  // the bias of "Microsoft YaHei".

  var textVerticalAlign = token.textVerticalAlign;
  var y = lineTop + lineHeight / 2;

  if (textVerticalAlign === 'top') {
    y = lineTop + token.height / 2;
  } else if (textVerticalAlign === 'bottom') {
    y = lineTop + lineHeight - token.height / 2;
  }

  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
  var textPadding = token.textPadding;

  if (textPadding) {
    x = getTextXForPadding(x, textAlign, textPadding);
    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
  }

  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
  // text will offset downward a little bit in font "Microsoft YaHei".

  setCtx(ctx, 'textBaseline', 'middle');
  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);
  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
  var textFill = getFill(tokenStyle.textFill || style.textFill);
  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.

  if (textStroke) {
    setCtx(ctx, 'lineWidth', textStrokeWidth);
    setCtx(ctx, 'strokeStyle', textStroke);
    ctx.strokeText(token.text, x, y);
  }

  if (textFill) {
    setCtx(ctx, 'fillStyle', textFill);
    ctx.fillText(token.text, x, y);
  }
}

function needDrawBackground(style) {
  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;
} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
// shape: {x, y, width, height}


function drawBackground(hostEl, ctx, style, x, y, width, height) {
  var textBackgroundColor = style.textBackgroundColor;
  var textBorderWidth = style.textBorderWidth;
  var textBorderColor = style.textBorderColor;
  var isPlainBg = isString(textBackgroundColor);
  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);

  if (isPlainBg || textBorderWidth && textBorderColor) {
    ctx.beginPath();
    var textBorderRadius = style.textBorderRadius;

    if (!textBorderRadius) {
      ctx.rect(x, y, width, height);
    } else {
      roundRectHelper.buildPath(ctx, {
        x: x,
        y: y,
        width: width,
        height: height,
        r: textBorderRadius
      });
    }

    ctx.closePath();
  }

  if (isPlainBg) {
    setCtx(ctx, 'fillStyle', textBackgroundColor);
    ctx.fill();
  } else if (isObject(textBackgroundColor)) {
    var image = textBackgroundColor.image;
    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);

    if (image && imageHelper.isImageReady(image)) {
      ctx.drawImage(image, x, y, width, height);
    }
  }

  if (textBorderWidth && textBorderColor) {
    setCtx(ctx, 'lineWidth', textBorderWidth);
    setCtx(ctx, 'strokeStyle', textBorderColor);
    ctx.stroke();
  }
}

function onBgImageLoaded(image, textBackgroundColor) {
  // Replace image, so that `contain/text.js#parseRichText`
  // will get correct result in next tick.
  textBackgroundColor.image = image;
}

function getBoxPosition(blockHeiht, style, rect) {
  var baseX = style.x || 0;
  var baseY = style.y || 0;
  var textAlign = style.textAlign;
  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord

  if (rect) {
    var textPosition = style.textPosition;

    if (textPosition instanceof Array) {
      // Percent
      baseX = rect.x + parsePercent(textPosition[0], rect.width);
      baseY = rect.y + parsePercent(textPosition[1], rect.height);
    } else {
      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);
      baseX = res.x;
      baseY = res.y; // Default align and baseline when has textPosition

      textAlign = textAlign || res.textAlign;
      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
    } // textOffset is only support in RectText, otherwise
    // we have to adjust boundingRect for textOffset.


    var textOffset = style.textOffset;

    if (textOffset) {
      baseX += textOffset[0];
      baseY += textOffset[1];
    }
  }

  return {
    baseX: baseX,
    baseY: baseY,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}

function setCtx(ctx, prop, value) {
  // FIXME ??? performance try
  // if (ctx.__currentValues[prop] !== value) {
  // ctx[prop] = ctx.__currentValues[prop] = value;
  ctx[prop] = value; // }

  return ctx[prop];
}
/**
 * @param {string} [stroke] If specified, do not check style.textStroke.
 * @param {string} [lineWidth] If specified, do not check style.textStroke.
 * @param {number} style
 */


function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
  : stroke.image || stroke.colorStops ? '#000' : stroke;
}

function getFill(fill) {
  return fill == null || fill === 'none' ? null // TODO pattern and gradient?
  : fill.image || fill.colorStops ? '#000' : fill;
}

function parsePercent(value, maxValue) {
  if (typeof value === 'string') {
    if (value.lastIndexOf('%') >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }

    return parseFloat(value);
  }

  return value;
}

function getTextXForPadding(x, textAlign, textPadding) {
  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}
/**
 * @param {string} text
 * @param {module:zrender/Style} style
 * @return {boolean}
 */


function needDrawText(text, style) {
  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
}

exports.normalizeTextStyle = normalizeTextStyle;
exports.renderText = renderText;
exports.getStroke = getStroke;
exports.getFill = getFill;
exports.needDrawText = needDrawText;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/mixin/RectText.js":
/***/ (function(module, exports, __webpack_require__) {

var textHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/text.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

/**
 * Mixin for drawing text in a element bounding rect
 * @module zrender/mixin/RectText
 */
var tmpRect = new BoundingRect();

var RectText = function () {};

RectText.prototype = {
  constructor: RectText,

  /**
   * Draw text in a rect with specified position.
   * @param  {CanvasRenderingContext2D} ctx
   * @param  {Object} rect Displayable rect
   */
  drawRectText: function (ctx, rect) {
    var style = this.style;
    rect = style.textRect || rect; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true);
    var text = style.text; // Convert to string

    text != null && (text += '');

    if (!textHelper.needDrawText(text, style)) {
      return;
    } // FIXME


    ctx.save(); // Transform rect to view space

    var transform = this.transform;

    if (!style.transformText) {
      if (transform) {
        tmpRect.copy(rect);
        tmpRect.applyTransform(transform);
        rect = tmpRect;
      }
    } else {
      this.setTransform(ctx);
    } // transformText and textRotation can not be used at the same time.


    textHelper.renderText(this, ctx, text, style, rect);
    ctx.restore();
  }
};
var _default = RectText;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Arc.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

/**
 * 圆弧
 * @module zrender/graphic/shape/Arc
 */
var _default = Path.extend({
  type: 'arc',
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    startAngle: 0,
    endAngle: Math.PI * 2,
    clockwise: true
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/BezierCurve.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var _curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

var quadraticSubdivide = _curve.quadraticSubdivide;
var cubicSubdivide = _curve.cubicSubdivide;
var quadraticAt = _curve.quadraticAt;
var cubicAt = _curve.cubicAt;
var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
var cubicDerivativeAt = _curve.cubicDerivativeAt;

/**
 * 贝塞尔曲线
 * @module zrender/shape/BezierCurve
 */
var out = [];

function someVectorAt(shape, t, isTangent) {
  var cpx2 = shape.cpx2;
  var cpy2 = shape.cpy2;

  if (cpx2 === null || cpy2 === null) {
    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
  } else {
    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
  }
}

var _default = Path.extend({
  type: 'bezier-curve',
  shape: {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    cpx1: 0,
    cpy1: 0,
    // cpx2: 0,
    // cpy2: 0
    // Curve show percent, for animating
    percent: 1
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var cpx1 = shape.cpx1;
    var cpy1 = shape.cpy1;
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    var percent = shape.percent;

    if (percent === 0) {
      return;
    }

    ctx.moveTo(x1, y1);

    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y1, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }

      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }

      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  },

  /**
   * Get point at percent
   * @param  {number} t
   * @return {Array.<number>}
   */
  pointAt: function (t) {
    return someVectorAt(this.shape, t, false);
  },

  /**
   * Get tangent at percent
   * @param  {number} t
   * @return {Array.<number>}
   */
  tangentAt: function (t) {
    var p = someVectorAt(this.shape, t, true);
    return vec2.normalize(p, p);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Circle.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

/**
 * 圆形
 * @module zrender/shape/Circle
 */
var _default = Path.extend({
  type: 'circle',
  shape: {
    cx: 0,
    cy: 0,
    r: 0
  },
  buildPath: function (ctx, shape, inBundle) {
    // Better stroking in ShapeBundle
    // Always do it may have performence issue ( fill may be 2x more cost)
    if (inBundle) {
      ctx.moveTo(shape.cx + shape.r, shape.cy);
    } // else {
    //     if (ctx.allocate && !ctx.data.length) {
    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
    //     }
    // }
    // Better stroking in ShapeBundle
    // ctx.moveTo(shape.cx + shape.r, shape.cy);


    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Line.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

/**
 * 直线
 * @module zrender/graphic/shape/Line
 */
var _default = Path.extend({
  type: 'line',
  shape: {
    // Start point
    x1: 0,
    y1: 0,
    // End point
    x2: 0,
    y2: 0,
    percent: 1
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var percent = shape.percent;

    if (percent === 0) {
      return;
    }

    ctx.moveTo(x1, y1);

    if (percent < 1) {
      x2 = x1 * (1 - percent) + x2 * percent;
      y2 = y1 * (1 - percent) + y2 * percent;
    }

    ctx.lineTo(x2, y2);
  },

  /**
   * Get point at percent
   * @param  {number} percent
   * @return {Array.<number>}
   */
  pointAt: function (p) {
    var shape = this.shape;
    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Polygon.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var polyHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/poly.js");

/**
 * 多边形
 * @module zrender/shape/Polygon
 */
var _default = Path.extend({
  type: 'polygon',
  shape: {
    points: null,
    smooth: false,
    smoothConstraint: null
  },
  buildPath: function (ctx, shape) {
    polyHelper.buildPath(ctx, shape, true);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Polyline.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var polyHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/poly.js");

/**
 * @module zrender/graphic/shape/Polyline
 */
var _default = Path.extend({
  type: 'polyline',
  shape: {
    points: null,
    smooth: false,
    smoothConstraint: null
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    polyHelper.buildPath(ctx, shape, false);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Rect.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var roundRectHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/roundRect.js");

/**
 * 矩形
 * @module zrender/graphic/shape/Rect
 */
var _default = Path.extend({
  type: 'rect',
  shape: {
    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
    // r缩写为1         相当于 [1, 1, 1, 1]
    // r缩写为[1]       相当于 [1, 1, 1, 1]
    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
    r: 0,
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (ctx, shape) {
    var x = shape.x;
    var y = shape.y;
    var width = shape.width;
    var height = shape.height;

    if (!shape.r) {
      ctx.rect(x, y, width, height);
    } else {
      roundRectHelper.buildPath(ctx, shape);
    }

    ctx.closePath();
    return;
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Ring.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

/**
 * 圆环
 * @module zrender/graphic/shape/Ring
 */
var _default = Path.extend({
  type: 'ring',
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    r0: 0
  },
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var PI2 = Math.PI * 2;
    ctx.moveTo(x + shape.r, y);
    ctx.arc(x, y, shape.r, 0, PI2, false);
    ctx.moveTo(x + shape.r0, y);
    ctx.arc(x, y, shape.r0, 0, PI2, true);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Sector.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var fixClipWithShadow = __webpack_require__("./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js");

/**
 * 扇形
 * @module zrender/graphic/shape/Sector
 */
var _default = Path.extend({
  type: 'sector',
  shape: {
    cx: 0,
    cy: 0,
    r0: 0,
    r: 0,
    startAngle: 0,
    endAngle: Math.PI * 2,
    clockwise: true
  },
  brush: fixClipWithShadow(Path.prototype.brush),
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
    ctx.lineTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);

    if (r0 !== 0) {
      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
    }

    ctx.closePath();
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Animatable.js":
/***/ (function(module, exports, __webpack_require__) {

var Animator = __webpack_require__("./node_modules/zrender/lib/animation/Animator.js");

var log = __webpack_require__("./node_modules/zrender/lib/core/log.js");

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var isString = _util.isString;
var isFunction = _util.isFunction;
var isObject = _util.isObject;
var isArrayLike = _util.isArrayLike;
var indexOf = _util.indexOf;

/**
 * @alias modue:zrender/mixin/Animatable
 * @constructor
 */
var Animatable = function () {
  /**
   * @type {Array.<module:zrender/animation/Animator>}
   * @readOnly
   */
  this.animators = [];
};

Animatable.prototype = {
  constructor: Animatable,

  /**
   * 动画
   *
   * @param {string} path The path to fetch value from object, like 'a.b.c'.
   * @param {boolean} [loop] Whether to loop animation.
   * @return {module:zrender/animation/Animator}
   * @example:
   *     el.animate('style', false)
   *         .when(1000, {x: 10} )
   *         .done(function(){ // Animation done })
   *         .start()
   */
  animate: function (path, loop) {
    var target;
    var animatingShape = false;
    var el = this;
    var zr = this.__zr;

    if (path) {
      var pathSplitted = path.split('.');
      var prop = el; // If animating shape

      animatingShape = pathSplitted[0] === 'shape';

      for (var i = 0, l = pathSplitted.length; i < l; i++) {
        if (!prop) {
          continue;
        }

        prop = prop[pathSplitted[i]];
      }

      if (prop) {
        target = prop;
      }
    } else {
      target = el;
    }

    if (!target) {
      log('Property "' + path + '" is not existed in element ' + el.id);
      return;
    }

    var animators = el.animators;
    var animator = new Animator(target, loop);
    animator.during(function (target) {
      el.dirty(animatingShape);
    }).done(function () {
      // FIXME Animator will not be removed if use `Animator#stop` to stop animation
      animators.splice(indexOf(animators, animator), 1);
    });
    animators.push(animator); // If animate after added to the zrender

    if (zr) {
      zr.animation.addAnimator(animator);
    }

    return animator;
  },

  /**
   * 停止动画
   * @param {boolean} forwardToLast If move to last frame before stop
   */
  stopAnimation: function (forwardToLast) {
    var animators = this.animators;
    var len = animators.length;

    for (var i = 0; i < len; i++) {
      animators[i].stop(forwardToLast);
    }

    animators.length = 0;
    return this;
  },

  /**
   * Caution: this method will stop previous animation.
   * So do not use this method to one element twice before
   * animation starts, unless you know what you are doing.
   * @param {Object} target
   * @param {number} [time=500] Time in ms
   * @param {string} [easing='linear']
   * @param {number} [delay=0]
   * @param {Function} [callback]
   * @param {Function} [forceAnimate] Prevent stop animation and callback
   *        immediently when target values are the same as current values.
   *
   * @example
   *  // Animate position
   *  el.animateTo({
   *      position: [10, 10]
   *  }, function () { // done })
   *
   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
   *  el.animateTo({
   *      shape: {
   *          width: 500
   *      },
   *      style: {
   *          fill: 'red'
   *      }
   *      position: [10, 10]
   *  }, 100, 100, 'cubicOut', function () { // done })
   */
  // TODO Return animation key
  animateTo: function (target, time, delay, easing, callback, forceAnimate) {
    // animateTo(target, time, easing, callback);
    if (isString(delay)) {
      callback = easing;
      easing = delay;
      delay = 0;
    } // animateTo(target, time, delay, callback);
    else if (isFunction(easing)) {
        callback = easing;
        easing = 'linear';
        delay = 0;
      } // animateTo(target, time, callback);
      else if (isFunction(delay)) {
          callback = delay;
          delay = 0;
        } // animateTo(target, callback)
        else if (isFunction(time)) {
            callback = time;
            time = 500;
          } // animateTo(target)
          else if (!time) {
              time = 500;
            } // Stop all previous animations


    this.stopAnimation();

    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start
    // if there is nothing to animate


    var animators = this.animators.slice();
    var count = animators.length;

    function done() {
      count--;

      if (!count) {
        callback && callback();
      }
    } // No animators. This should be checked before animators[i].start(),
    // because 'done' may be executed immediately if no need to animate.


    if (!count) {
      callback && callback();
    } // Start after all animators created
    // Incase any animator is done immediately when all animation properties are not changed


    for (var i = 0; i < animators.length; i++) {
      animators[i].done(done).start(easing, forceAnimate);
    }
  },

  /**
   * @private
   * @param {string} path=''
   * @param {Object} source=this
   * @param {Object} target
   * @param {number} [time=500]
   * @param {number} [delay=0]
   *
   * @example
   *  // Animate position
   *  el._animateToShallow({
   *      position: [10, 10]
   *  })
   *
   *  // Animate shape, style and position in 100ms, delayed 100ms
   *  el._animateToShallow({
   *      shape: {
   *          width: 500
   *      },
   *      style: {
   *          fill: 'red'
   *      }
   *      position: [10, 10]
   *  }, 100, 100)
   */
  _animateToShallow: function (path, source, target, time, delay) {
    var objShallow = {};
    var propertyCount = 0;

    for (var name in target) {
      if (!target.hasOwnProperty(name)) {
        continue;
      }

      if (source[name] != null) {
        if (isObject(target[name]) && !isArrayLike(target[name])) {
          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
        } else {
          objShallow[name] = target[name];
          propertyCount++;
        }
      } else if (target[name] != null) {
        // Attr directly if not has property
        // FIXME, if some property not needed for element ?
        if (!path) {
          this.attr(name, target[name]);
        } else {
          // Shape or style
          var props = {};
          props[path] = {};
          props[path][name] = target[name];
          this.attr(props);
        }
      }
    }

    if (propertyCount > 0) {
      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
    }

    return this;
  }
};
var _default = Animatable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Draggable.js":
/***/ (function(module, exports) {

// TODO Draggable for group
// FIXME Draggable on element which has parent rotation or scale
function Draggable() {
  this.on('mousedown', this._dragStart, this);
  this.on('mousemove', this._drag, this);
  this.on('mouseup', this._dragEnd, this);
  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;
  // this._draggingTarget = null;
  // this._x = 0;
  // this._y = 0;
}

Draggable.prototype = {
  constructor: Draggable,
  _dragStart: function (e) {
    var draggingTarget = e.target;

    if (draggingTarget && draggingTarget.draggable) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e.offsetX;
      this._y = e.offsetY;
      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
    }
  },
  _drag: function (e) {
    var draggingTarget = this._draggingTarget;

    if (draggingTarget) {
      var x = e.offsetX;
      var y = e.offsetY;
      var dx = x - this._x;
      var dy = y - this._y;
      this._x = x;
      this._y = y;
      draggingTarget.drift(dx, dy, e);
      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
      var dropTarget = this.findHover(x, y, draggingTarget).target;
      var lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;

      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
        }

        if (dropTarget && dropTarget !== lastDropTarget) {
          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
        }
      }
    }
  },
  _dragEnd: function (e) {
    var draggingTarget = this._draggingTarget;

    if (draggingTarget) {
      draggingTarget.dragging = false;
    }

    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);

    if (this._dropTarget) {
      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
    }

    this._draggingTarget = null;
    this._dropTarget = null;
  }
};

function param(target, e) {
  return {
    target: target,
    topTarget: e && e.topTarget
  };
}

var _default = Draggable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Eventful.js":
/***/ (function(module, exports) {

/**
 * 事件扩展
 * @module zrender/mixin/Eventful
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */
var arrySlice = Array.prototype.slice;
/**
 * 事件分发器
 * @alias module:zrender/mixin/Eventful
 * @constructor
 */

var Eventful = function () {
  this._$handlers = {};
};

Eventful.prototype = {
  constructor: Eventful,

  /**
   * 单次触发绑定，trigger后销毁
   *
   * @param {string} event 事件名
   * @param {Function} handler 响应函数
   * @param {Object} context
   */
  one: function (event, handler, context) {
    var _h = this._$handlers;

    if (!handler || !event) {
      return this;
    }

    if (!_h[event]) {
      _h[event] = [];
    }

    for (var i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }

    _h[event].push({
      h: handler,
      one: true,
      ctx: context || this
    });

    return this;
  },

  /**
   * 绑定事件
   * @param {string} event 事件名
   * @param {Function} handler 事件处理函数
   * @param {Object} [context]
   */
  on: function (event, handler, context) {
    var _h = this._$handlers;

    if (!handler || !event) {
      return this;
    }

    if (!_h[event]) {
      _h[event] = [];
    }

    for (var i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }

    _h[event].push({
      h: handler,
      one: false,
      ctx: context || this
    });

    return this;
  },

  /**
   * 是否绑定了事件
   * @param  {string}  event
   * @return {boolean}
   */
  isSilent: function (event) {
    var _h = this._$handlers;
    return _h[event] && _h[event].length;
  },

  /**
   * 解绑事件
   * @param {string} event 事件名
   * @param {Function} [handler] 事件处理函数
   */
  off: function (event, handler) {
    var _h = this._$handlers;

    if (!event) {
      this._$handlers = {};
      return this;
    }

    if (handler) {
      if (_h[event]) {
        var newList = [];

        for (var i = 0, l = _h[event].length; i < l; i++) {
          if (_h[event][i]['h'] != handler) {
            newList.push(_h[event][i]);
          }
        }

        _h[event] = newList;
      }

      if (_h[event] && _h[event].length === 0) {
        delete _h[event];
      }
    } else {
      delete _h[event];
    }

    return this;
  },

  /**
   * 事件分发
   *
   * @param {string} type 事件类型
   */
  trigger: function (type) {
    if (this._$handlers[type]) {
      var args = arguments;
      var argLen = args.length;

      if (argLen > 3) {
        args = arrySlice.call(args, 1);
      }

      var _h = this._$handlers[type];
      var len = _h.length;

      for (var i = 0; i < len;) {
        // Optimize advise from backbone
        switch (argLen) {
          case 1:
            _h[i]['h'].call(_h[i]['ctx']);

            break;

          case 2:
            _h[i]['h'].call(_h[i]['ctx'], args[1]);

            break;

          case 3:
            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);

            break;

          default:
            // have more than 2 given arguments
            _h[i]['h'].apply(_h[i]['ctx'], args);

            break;
        }

        if (_h[i]['one']) {
          _h.splice(i, 1);

          len--;
        } else {
          i++;
        }
      }
    }

    return this;
  },

  /**
   * 带有context的事件分发, 最后一个参数是事件回调的context
   * @param {string} type 事件类型
   */
  triggerWithContext: function (type) {
    if (this._$handlers[type]) {
      var args = arguments;
      var argLen = args.length;

      if (argLen > 4) {
        args = arrySlice.call(args, 1, args.length - 1);
      }

      var ctx = args[args.length - 1];
      var _h = this._$handlers[type];
      var len = _h.length;

      for (var i = 0; i < len;) {
        // Optimize advise from backbone
        switch (argLen) {
          case 1:
            _h[i]['h'].call(ctx);

            break;

          case 2:
            _h[i]['h'].call(ctx, args[1]);

            break;

          case 3:
            _h[i]['h'].call(ctx, args[1], args[2]);

            break;

          default:
            // have more than 2 given arguments
            _h[i]['h'].apply(ctx, args);

            break;
        }

        if (_h[i]['one']) {
          _h.splice(i, 1);

          len--;
        } else {
          i++;
        }
      }
    }

    return this;
  }
}; // 对象可以通过 onxxxx 绑定事件

/**
 * @event module:zrender/mixin/Eventful#onclick
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseover
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseout
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousemove
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousewheel
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousedown
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseup
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondrag
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragstart
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragend
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragenter
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragleave
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragover
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondrop
 * @type {Function}
 * @default null
 */

var _default = Eventful;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Transformable.js":
/***/ (function(module, exports, __webpack_require__) {

var matrix = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

var vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

/**
 * 提供变换扩展
 * @module zrender/mixin/Transformable
 * @author pissang (https://www.github.com/pissang)
 */
var mIdentity = matrix.identity;
var EPSILON = 5e-5;

function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
/**
 * @alias module:zrender/mixin/Transformable
 * @constructor
 */


var Transformable = function (opts) {
  opts = opts || {}; // If there are no given position, rotation, scale

  if (!opts.position) {
    /**
     * 平移
     * @type {Array.<number>}
     * @default [0, 0]
     */
    this.position = [0, 0];
  }

  if (opts.rotation == null) {
    /**
     * 旋转
     * @type {Array.<number>}
     * @default 0
     */
    this.rotation = 0;
  }

  if (!opts.scale) {
    /**
     * 缩放
     * @type {Array.<number>}
     * @default [1, 1]
     */
    this.scale = [1, 1];
  }
  /**
   * 旋转和缩放的原点
   * @type {Array.<number>}
   * @default null
   */


  this.origin = this.origin || null;
};

var transformableProto = Transformable.prototype;
transformableProto.transform = null;
/**
 * 判断是否需要有坐标变换
 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
 */

transformableProto.needLocalTransform = function () {
  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
};

transformableProto.updateTransform = function () {
  var parent = this.parent;
  var parentHasTransform = parent && parent.transform;
  var needLocalTransform = this.needLocalTransform();
  var m = this.transform;

  if (!(needLocalTransform || parentHasTransform)) {
    m && mIdentity(m);
    return;
  }

  m = m || matrix.create();

  if (needLocalTransform) {
    this.getLocalTransform(m);
  } else {
    mIdentity(m);
  } // 应用父节点变换


  if (parentHasTransform) {
    if (needLocalTransform) {
      matrix.mul(m, parent.transform, m);
    } else {
      matrix.copy(m, parent.transform);
    }
  } // 保存这个变换矩阵


  this.transform = m;
  this.invTransform = this.invTransform || matrix.create();
  matrix.invert(this.invTransform, m);
};

transformableProto.getLocalTransform = function (m) {
  return Transformable.getLocalTransform(this, m);
};
/**
 * 将自己的transform应用到context上
 * @param {CanvasRenderingContext2D} ctx
 */


transformableProto.setTransform = function (ctx) {
  var m = this.transform;
  var dpr = ctx.dpr || 1;

  if (m) {
    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
  } else {
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
};

transformableProto.restoreTransform = function (ctx) {
  var dpr = ctx.dpr || 1;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
};

var tmpTransform = [];
/**
 * 分解`transform`矩阵到`position`, `rotation`, `scale`
 */

transformableProto.decomposeTransform = function () {
  if (!this.transform) {
    return;
  }

  var parent = this.parent;
  var m = this.transform;

  if (parent && parent.transform) {
    // Get local transform and decompose them to position, scale, rotation
    matrix.mul(tmpTransform, parent.invTransform, m);
    m = tmpTransform;
  }

  var sx = m[0] * m[0] + m[1] * m[1];
  var sy = m[2] * m[2] + m[3] * m[3];
  var position = this.position;
  var scale = this.scale;

  if (isNotAroundZero(sx - 1)) {
    sx = Math.sqrt(sx);
  }

  if (isNotAroundZero(sy - 1)) {
    sy = Math.sqrt(sy);
  }

  if (m[0] < 0) {
    sx = -sx;
  }

  if (m[3] < 0) {
    sy = -sy;
  }

  position[0] = m[4];
  position[1] = m[5];
  scale[0] = sx;
  scale[1] = sy;
  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
};
/**
 * Get global scale
 * @return {Array.<number>}
 */


transformableProto.getGlobalScale = function () {
  var m = this.transform;

  if (!m) {
    return [1, 1];
  }

  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);

  if (m[0] < 0) {
    sx = -sx;
  }

  if (m[3] < 0) {
    sy = -sy;
  }

  return [sx, sy];
};
/**
 * 变换坐标位置到 shape 的局部坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */


transformableProto.transformCoordToLocal = function (x, y) {
  var v2 = [x, y];
  var invTransform = this.invTransform;

  if (invTransform) {
    vector.applyTransform(v2, v2, invTransform);
  }

  return v2;
};
/**
 * 变换局部坐标位置到全局坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */


transformableProto.transformCoordToGlobal = function (x, y) {
  var v2 = [x, y];
  var transform = this.transform;

  if (transform) {
    vector.applyTransform(v2, v2, transform);
  }

  return v2;
};
/**
 * @static
 * @param {Object} target
 * @param {Array.<number>} target.origin
 * @param {number} target.rotation
 * @param {Array.<number>} target.position
 * @param {Array.<number>} [m]
 */


Transformable.getLocalTransform = function (target, m) {
  m = m || [];
  mIdentity(m);
  var origin = target.origin;
  var scale = target.scale || [1, 1];
  var rotation = target.rotation || 0;
  var position = target.position || [0, 0];

  if (origin) {
    // Translate to origin
    m[4] -= origin[0];
    m[5] -= origin[1];
  }

  matrix.scale(m, m, scale);

  if (rotation) {
    matrix.rotate(m, m, rotation);
  }

  if (origin) {
    // Translate back from origin
    m[4] += origin[0];
    m[5] += origin[1];
  }

  m[4] += position[0];
  m[5] += position[1];
  return m;
};

var _default = Transformable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/tool/color.js":
/***/ (function(module, exports, __webpack_require__) {

var LRU = __webpack_require__("./node_modules/zrender/lib/core/LRU.js");

var kCSSColorTable = {
  'transparent': [0, 0, 0, 0],
  'aliceblue': [240, 248, 255, 1],
  'antiquewhite': [250, 235, 215, 1],
  'aqua': [0, 255, 255, 1],
  'aquamarine': [127, 255, 212, 1],
  'azure': [240, 255, 255, 1],
  'beige': [245, 245, 220, 1],
  'bisque': [255, 228, 196, 1],
  'black': [0, 0, 0, 1],
  'blanchedalmond': [255, 235, 205, 1],
  'blue': [0, 0, 255, 1],
  'blueviolet': [138, 43, 226, 1],
  'brown': [165, 42, 42, 1],
  'burlywood': [222, 184, 135, 1],
  'cadetblue': [95, 158, 160, 1],
  'chartreuse': [127, 255, 0, 1],
  'chocolate': [210, 105, 30, 1],
  'coral': [255, 127, 80, 1],
  'cornflowerblue': [100, 149, 237, 1],
  'cornsilk': [255, 248, 220, 1],
  'crimson': [220, 20, 60, 1],
  'cyan': [0, 255, 255, 1],
  'darkblue': [0, 0, 139, 1],
  'darkcyan': [0, 139, 139, 1],
  'darkgoldenrod': [184, 134, 11, 1],
  'darkgray': [169, 169, 169, 1],
  'darkgreen': [0, 100, 0, 1],
  'darkgrey': [169, 169, 169, 1],
  'darkkhaki': [189, 183, 107, 1],
  'darkmagenta': [139, 0, 139, 1],
  'darkolivegreen': [85, 107, 47, 1],
  'darkorange': [255, 140, 0, 1],
  'darkorchid': [153, 50, 204, 1],
  'darkred': [139, 0, 0, 1],
  'darksalmon': [233, 150, 122, 1],
  'darkseagreen': [143, 188, 143, 1],
  'darkslateblue': [72, 61, 139, 1],
  'darkslategray': [47, 79, 79, 1],
  'darkslategrey': [47, 79, 79, 1],
  'darkturquoise': [0, 206, 209, 1],
  'darkviolet': [148, 0, 211, 1],
  'deeppink': [255, 20, 147, 1],
  'deepskyblue': [0, 191, 255, 1],
  'dimgray': [105, 105, 105, 1],
  'dimgrey': [105, 105, 105, 1],
  'dodgerblue': [30, 144, 255, 1],
  'firebrick': [178, 34, 34, 1],
  'floralwhite': [255, 250, 240, 1],
  'forestgreen': [34, 139, 34, 1],
  'fuchsia': [255, 0, 255, 1],
  'gainsboro': [220, 220, 220, 1],
  'ghostwhite': [248, 248, 255, 1],
  'gold': [255, 215, 0, 1],
  'goldenrod': [218, 165, 32, 1],
  'gray': [128, 128, 128, 1],
  'green': [0, 128, 0, 1],
  'greenyellow': [173, 255, 47, 1],
  'grey': [128, 128, 128, 1],
  'honeydew': [240, 255, 240, 1],
  'hotpink': [255, 105, 180, 1],
  'indianred': [205, 92, 92, 1],
  'indigo': [75, 0, 130, 1],
  'ivory': [255, 255, 240, 1],
  'khaki': [240, 230, 140, 1],
  'lavender': [230, 230, 250, 1],
  'lavenderblush': [255, 240, 245, 1],
  'lawngreen': [124, 252, 0, 1],
  'lemonchiffon': [255, 250, 205, 1],
  'lightblue': [173, 216, 230, 1],
  'lightcoral': [240, 128, 128, 1],
  'lightcyan': [224, 255, 255, 1],
  'lightgoldenrodyellow': [250, 250, 210, 1],
  'lightgray': [211, 211, 211, 1],
  'lightgreen': [144, 238, 144, 1],
  'lightgrey': [211, 211, 211, 1],
  'lightpink': [255, 182, 193, 1],
  'lightsalmon': [255, 160, 122, 1],
  'lightseagreen': [32, 178, 170, 1],
  'lightskyblue': [135, 206, 250, 1],
  'lightslategray': [119, 136, 153, 1],
  'lightslategrey': [119, 136, 153, 1],
  'lightsteelblue': [176, 196, 222, 1],
  'lightyellow': [255, 255, 224, 1],
  'lime': [0, 255, 0, 1],
  'limegreen': [50, 205, 50, 1],
  'linen': [250, 240, 230, 1],
  'magenta': [255, 0, 255, 1],
  'maroon': [128, 0, 0, 1],
  'mediumaquamarine': [102, 205, 170, 1],
  'mediumblue': [0, 0, 205, 1],
  'mediumorchid': [186, 85, 211, 1],
  'mediumpurple': [147, 112, 219, 1],
  'mediumseagreen': [60, 179, 113, 1],
  'mediumslateblue': [123, 104, 238, 1],
  'mediumspringgreen': [0, 250, 154, 1],
  'mediumturquoise': [72, 209, 204, 1],
  'mediumvioletred': [199, 21, 133, 1],
  'midnightblue': [25, 25, 112, 1],
  'mintcream': [245, 255, 250, 1],
  'mistyrose': [255, 228, 225, 1],
  'moccasin': [255, 228, 181, 1],
  'navajowhite': [255, 222, 173, 1],
  'navy': [0, 0, 128, 1],
  'oldlace': [253, 245, 230, 1],
  'olive': [128, 128, 0, 1],
  'olivedrab': [107, 142, 35, 1],
  'orange': [255, 165, 0, 1],
  'orangered': [255, 69, 0, 1],
  'orchid': [218, 112, 214, 1],
  'palegoldenrod': [238, 232, 170, 1],
  'palegreen': [152, 251, 152, 1],
  'paleturquoise': [175, 238, 238, 1],
  'palevioletred': [219, 112, 147, 1],
  'papayawhip': [255, 239, 213, 1],
  'peachpuff': [255, 218, 185, 1],
  'peru': [205, 133, 63, 1],
  'pink': [255, 192, 203, 1],
  'plum': [221, 160, 221, 1],
  'powderblue': [176, 224, 230, 1],
  'purple': [128, 0, 128, 1],
  'red': [255, 0, 0, 1],
  'rosybrown': [188, 143, 143, 1],
  'royalblue': [65, 105, 225, 1],
  'saddlebrown': [139, 69, 19, 1],
  'salmon': [250, 128, 114, 1],
  'sandybrown': [244, 164, 96, 1],
  'seagreen': [46, 139, 87, 1],
  'seashell': [255, 245, 238, 1],
  'sienna': [160, 82, 45, 1],
  'silver': [192, 192, 192, 1],
  'skyblue': [135, 206, 235, 1],
  'slateblue': [106, 90, 205, 1],
  'slategray': [112, 128, 144, 1],
  'slategrey': [112, 128, 144, 1],
  'snow': [255, 250, 250, 1],
  'springgreen': [0, 255, 127, 1],
  'steelblue': [70, 130, 180, 1],
  'tan': [210, 180, 140, 1],
  'teal': [0, 128, 128, 1],
  'thistle': [216, 191, 216, 1],
  'tomato': [255, 99, 71, 1],
  'turquoise': [64, 224, 208, 1],
  'violet': [238, 130, 238, 1],
  'wheat': [245, 222, 179, 1],
  'white': [255, 255, 255, 1],
  'whitesmoke': [245, 245, 245, 1],
  'yellow': [255, 255, 0, 1],
  'yellowgreen': [154, 205, 50, 1]
};

function clampCssByte(i) {
  // Clamp to integer 0 .. 255.
  i = Math.round(i); // Seems to be what Chrome does (vs truncation).

  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clampCssAngle(i) {
  // Clamp to integer 0 .. 360.
  i = Math.round(i); // Seems to be what Chrome does (vs truncation).

  return i < 0 ? 0 : i > 360 ? 360 : i;
}

function clampCssFloat(f) {
  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parseCssInt(str) {
  // int or percentage.
  if (str.length && str.charAt(str.length - 1) === '%') {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }

  return clampCssByte(parseInt(str, 10));
}

function parseCssFloat(str) {
  // float or percentage.
  if (str.length && str.charAt(str.length - 1) === '%') {
    return clampCssFloat(parseFloat(str) / 100);
  }

  return clampCssFloat(parseFloat(str));
}

function cssHueToRgb(m1, m2, h) {
  if (h < 0) {
    h += 1;
  } else if (h > 1) {
    h -= 1;
  }

  if (h * 6 < 1) {
    return m1 + (m2 - m1) * h * 6;
  }

  if (h * 2 < 1) {
    return m2;
  }

  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }

  return m1;
}

function lerpNumber(a, b, p) {
  return a + (b - a) * p;
}

function setRgba(out, r, g, b, a) {
  out[0] = r;
  out[1] = g;
  out[2] = b;
  out[3] = a;
  return out;
}

function copyRgba(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

var colorCache = new LRU(20);
var lastRemovedArr = null;

function putToCache(colorStr, rgbaArr) {
  // Reuse removed array
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }

  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
/**
 * @param {string} colorStr
 * @param {Array.<number>} out
 * @return {Array.<number>}
 * @memberOf module:zrender/util/color
 */


function parse(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }

  rgbaArr = rgbaArr || [];
  var cached = colorCache.get(colorStr);

  if (cached) {
    return copyRgba(rgbaArr, cached);
  } // colorStr may be not string


  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.

  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  } // #abc and #abc123 syntax.


  if (str.charAt(0) === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

      if (!(iv >= 0 && iv <= 0xfff)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return; // Covers NaN.
      }

      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

      if (!(iv >= 0 && iv <= 0xffffff)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return; // Covers NaN.
      }

      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }

    return;
  }

  var op = str.indexOf('('),
      ep = str.indexOf(')');

  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op + 1, ep - (op + 1)).split(',');
    var alpha = 1; // To allow case fallthrough.

    switch (fname) {
      case 'rgba':
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        alpha = parseCssFloat(params.pop());
      // jshint ignore:line
      // Fall through.

      case 'rgb':
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      case 'hsla':
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      case 'hsl':
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      default:
        return;
    }
  }

  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
/**
 * @param {Array.<number>} hsla
 * @param {Array.<number>} rgba
 * @return {Array.<number>} rgba
 */


function hsla2rgba(hsla, rgba) {
  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
  // NOTE(deanm): According to the CSS spec s/l should only be
  // percentages, but we don't bother and let float or percentage.

  var s = parseCssFloat(hsla[1]);
  var l = parseCssFloat(hsla[2]);
  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  var m1 = l * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);

  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }

  return rgba;
}
/**
 * @param {Array.<number>} rgba
 * @return {Array.<number>} hsla
 */


function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  } // RGB from 0 to 255


  var R = rgba[0] / 255;
  var G = rgba[1] / 255;
  var B = rgba[2] / 255;
  var vMin = Math.min(R, G, B); // Min. value of RGB

  var vMax = Math.max(R, G, B); // Max. value of RGB

  var delta = vMax - vMin; // Delta RGB value

  var L = (vMax + vMin) / 2;
  var H;
  var S; // HSL results from 0 to 1

  if (delta === 0) {
    H = 0;
    S = 0;
  } else {
    if (L < 0.5) {
      S = delta / (vMax + vMin);
    } else {
      S = delta / (2 - vMax - vMin);
    }

    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;

    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }

    if (H < 0) {
      H += 1;
    }

    if (H > 1) {
      H -= 1;
    }
  }

  var hsla = [H * 360, S, L];

  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }

  return hsla;
}
/**
 * @param {string} color
 * @param {number} level
 * @return {string}
 * @memberOf module:zrender/util/color
 */


function lift(color, level) {
  var colorArr = parse(color);

  if (colorArr) {
    for (var i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }
    }

    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
  }
}
/**
 * @param {string} color
 * @return {string}
 * @memberOf module:zrender/util/color
 */


function toHex(color) {
  var colorArr = parse(color);

  if (colorArr) {
    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
  }
}
/**
 * Map value to color. Faster than lerp methods because color is represented by rgba array.
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<Array.<number>>} colors List of rgba color array
 * @param {Array.<number>} [out] Mapped gba color array
 * @return {Array.<number>} will be null/undefined if input illegal.
 */


function fastLerp(normalizedValue, colors, out) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }

  out = out || [];
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colors[leftIndex];
  var rightColor = colors[rightIndex];
  var dv = value - leftIndex;
  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out;
}
/**
 * @deprecated
 */


var fastMapToColor = fastLerp;
/**
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<string>} colors Color list.
 * @param {boolean=} fullOutput Default false.
 * @return {(string|Object)} Result color. If fullOutput,
 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
 * @memberOf module:zrender/util/color
 */

function lerp(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }

  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = parse(colors[leftIndex]);
  var rightColor = parse(colors[rightIndex]);
  var dv = value - leftIndex;
  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
  return fullOutput ? {
    color: color,
    leftIndex: leftIndex,
    rightIndex: rightIndex,
    value: value
  } : color;
}
/**
 * @deprecated
 */


var mapToColor = lerp;
/**
 * @param {string} color
 * @param {number=} h 0 ~ 360, ignore when null.
 * @param {number=} s 0 ~ 1, ignore when null.
 * @param {number=} l 0 ~ 1, ignore when null.
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */

function modifyHSL(color, h, s, l) {
  color = parse(color);

  if (color) {
    color = rgba2hsla(color);
    h != null && (color[0] = clampCssAngle(h));
    s != null && (color[1] = parseCssFloat(s));
    l != null && (color[2] = parseCssFloat(l));
    return stringify(hsla2rgba(color), 'rgba');
  }
}
/**
 * @param {string} color
 * @param {number=} alpha 0 ~ 1
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */


function modifyAlpha(color, alpha) {
  color = parse(color);

  if (color && alpha != null) {
    color[3] = clampCssFloat(alpha);
    return stringify(color, 'rgba');
  }
}
/**
 * @param {Array.<number>} arrColor like [12,33,44,0.4]
 * @param {string} type 'rgba', 'hsva', ...
 * @return {string} Result color. (If input illegal, return undefined).
 */


function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }

  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];

  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
    colorStr += ',' + arrColor[3];
  }

  return type + '(' + colorStr + ')';
}

exports.parse = parse;
exports.lift = lift;
exports.toHex = toHex;
exports.fastLerp = fastLerp;
exports.fastMapToColor = fastMapToColor;
exports.lerp = lerp;
exports.mapToColor = mapToColor;
exports.modifyHSL = modifyHSL;
exports.modifyAlpha = modifyAlpha;
exports.stringify = stringify;

/***/ }),

/***/ "./node_modules/zrender/lib/tool/path.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var PathProxy = __webpack_require__("./node_modules/zrender/lib/core/PathProxy.js");

var transformPath = __webpack_require__("./node_modules/zrender/lib/tool/transformPath.js");

// command chars
var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
var mathSqrt = Math.sqrt;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI = Math.PI;

var vMag = function (v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
};

var vRatio = function (u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
};

var vAngle = function (u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
};

function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
  var psi = psiDeg * (PI / 180.0);
  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

  if (lambda > 1) {
    rx *= mathSqrt(lambda);
    ry *= mathSqrt(lambda);
  }

  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  var cxp = f * rx * yp / ry;
  var cyp = f * -ry * xp / rx;
  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;
  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var dTheta = vAngle(u, v);

  if (vRatio(u, v) <= -1) {
    dTheta = PI;
  }

  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }

  if (fs === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * PI;
  }

  if (fs === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * PI;
  }

  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}

function createPathProxyFromString(data) {
  if (!data) {
    return [];
  } // command string


  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');
  var n; // create pipes so that we can split the data

  for (n = 0; n < cc.length; n++) {
    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
  } // create array


  var arr = cs.split('|'); // init context point

  var cpx = 0;
  var cpy = 0;
  var path = new PathProxy();
  var CMD = PathProxy.CMD;
  var prevCmd;

  for (n = 1; n < arr.length; n++) {
    var str = arr[n];
    var c = str.charAt(0);
    var off = 0;
    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
    var cmd;

    if (p.length > 0 && p[0] === '') {
      p.shift();
    }

    for (var i = 0; i < p.length; i++) {
      p[i] = parseFloat(p[i]);
    }

    while (off < p.length && !isNaN(p[off])) {
      if (isNaN(p[0])) {
        break;
      }

      var ctlPtx;
      var ctlPty;
      var rx;
      var ry;
      var psi;
      var fa;
      var fs;
      var x1 = cpx;
      var y1 = cpy; // convert l, H, h, V, and v to L

      switch (c) {
        case 'l':
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'L':
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'm':
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.M;
          path.addData(cmd, cpx, cpy);
          c = 'l';
          break;

        case 'M':
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.M;
          path.addData(cmd, cpx, cpy);
          c = 'L';
          break;

        case 'h':
          cpx += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'H':
          cpx = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'v':
          cpy += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'V':
          cpy = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'C':
          cmd = CMD.C;
          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
          cpx = p[off - 2];
          cpy = p[off - 1];
          break;

        case 'c':
          cmd = CMD.C;
          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
          cpx += p[off - 2];
          cpy += p[off - 1];
          break;

        case 'S':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.C) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cmd = CMD.C;
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;

        case 's':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.C) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cmd = CMD.C;
          x1 = cpx + p[off++];
          y1 = cpy + p[off++];
          cpx += p[off++];
          cpy += p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;

        case 'Q':
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;

        case 'q':
          x1 = p[off++] + cpx;
          y1 = p[off++] + cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;

        case 'T':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.Q) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;

        case 't':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.Q) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;

        case 'A':
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;

        case 'a':
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
      }
    }

    if (c === 'z' || c === 'Z') {
      cmd = CMD.Z;
      path.addData(cmd);
    }

    prevCmd = cmd;
  }

  path.toStatic();
  return path;
} // TODO Optimize double memory cost problem


function createPathOptions(str, opts) {
  var pathProxy = createPathProxyFromString(str);
  opts = opts || {};

  opts.buildPath = function (path) {
    if (path.setData) {
      path.setData(pathProxy.data); // Svg and vml renderer don't have context

      var ctx = path.getContext();

      if (ctx) {
        path.rebuildPath(ctx);
      }
    } else {
      var ctx = path;
      pathProxy.rebuildPath(ctx);
    }
  };

  opts.applyTransform = function (m) {
    transformPath(pathProxy, m);
    this.dirty(true);
  };

  return opts;
}
/**
 * Create a Path object from path string data
 * http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {Object} opts Other options
 */


function createFromString(str, opts) {
  return new Path(createPathOptions(str, opts));
}
/**
 * Create a Path class from path string data
 * @param  {string} str
 * @param  {Object} opts Other options
 */


function extendFromString(str, opts) {
  return Path.extend(createPathOptions(str, opts));
}
/**
 * Merge multiple paths
 */
// TODO Apply transform
// TODO stroke dash
// TODO Optimize double memory cost problem


function mergePath(pathEls, opts) {
  var pathList = [];
  var len = pathEls.length;

  for (var i = 0; i < len; i++) {
    var pathEl = pathEls[i];

    if (!pathEl.path) {
      pathEl.createPathProxy();
    }

    if (pathEl.__dirtyPath) {
      pathEl.buildPath(pathEl.path, pathEl.shape, true);
    }

    pathList.push(pathEl.path);
  }

  var pathBundle = new Path(opts); // Need path proxy.

  pathBundle.createPathProxy();

  pathBundle.buildPath = function (path) {
    path.appendPath(pathList); // Svg and vml renderer don't have context

    var ctx = path.getContext();

    if (ctx) {
      path.rebuildPath(ctx);
    }
  };

  return pathBundle;
}

exports.createFromString = createFromString;
exports.extendFromString = extendFromString;
exports.mergePath = mergePath;

/***/ }),

/***/ "./node_modules/zrender/lib/tool/transformPath.js":
/***/ (function(module, exports, __webpack_require__) {

var PathProxy = __webpack_require__("./node_modules/zrender/lib/core/PathProxy.js");

var _vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var v2ApplyTransform = _vector.applyTransform;
var CMD = PathProxy.CMD;
var points = [[], [], []];
var mathSqrt = Math.sqrt;
var mathAtan2 = Math.atan2;

function _default(path, m) {
  var data = path.data;
  var cmd;
  var nPoint;
  var i;
  var j;
  var k;
  var p;
  var M = CMD.M;
  var C = CMD.C;
  var L = CMD.L;
  var R = CMD.R;
  var A = CMD.A;
  var Q = CMD.Q;

  for (i = 0, j = 0; i < data.length;) {
    cmd = data[i++];
    j = i;
    nPoint = 0;

    switch (cmd) {
      case M:
        nPoint = 1;
        break;

      case L:
        nPoint = 1;
        break;

      case C:
        nPoint = 3;
        break;

      case Q:
        nPoint = 2;
        break;

      case A:
        var x = m[4];
        var y = m[5];
        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx

        data[i] *= sx;
        data[i++] += x; // cy

        data[i] *= sy;
        data[i++] += y; // Scale rx and ry
        // FIXME Assume psi is 0 here

        data[i++] *= sx;
        data[i++] *= sy; // Start angle

        data[i++] += angle; // end angle

        data[i++] += angle; // FIXME psi

        i += 2;
        j = i;
        break;

      case R:
        // x0, y0
        p[0] = data[i++];
        p[1] = data[i++];
        v2ApplyTransform(p, p, m);
        data[j++] = p[0];
        data[j++] = p[1]; // x1, y1

        p[0] += data[i++];
        p[1] += data[i++];
        v2ApplyTransform(p, p, m);
        data[j++] = p[0];
        data[j++] = p[1];
    }

    for (k = 0; k < nPoint; k++) {
      var p = points[k];
      p[0] = data[i++];
      p[1] = data[i++];
      v2ApplyTransform(p, p, m); // Write back

      data[j++] = p[0];
      data[j++] = p[1];
    }
  }
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/zrender.js":
/***/ (function(module, exports, __webpack_require__) {

var guid = __webpack_require__("./node_modules/zrender/lib/core/guid.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Handler = __webpack_require__("./node_modules/zrender/lib/Handler.js");

var Storage = __webpack_require__("./node_modules/zrender/lib/Storage.js");

var Painter = __webpack_require__("./node_modules/zrender/lib/Painter.js");

var Animation = __webpack_require__("./node_modules/zrender/lib/animation/Animation.js");

var HandlerProxy = __webpack_require__("./node_modules/zrender/lib/dom/HandlerProxy.js");

/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var useVML = !env.canvasSupported;
var painterCtors = {
  canvas: Painter
};
var instances = {}; // ZRender实例map索引

/**
 * @type {string}
 */

var version = '3.7.4';
/**
 * Initializing a zrender instance
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
 * @return {module:zrender/ZRender}
 */

function init(dom, opts) {
  var zr = new ZRender(guid(), dom, opts);
  instances[zr.id] = zr;
  return zr;
}
/**
 * Dispose zrender instance
 * @param {module:zrender/ZRender} zr
 */


function dispose(zr) {
  if (zr) {
    zr.dispose();
  } else {
    for (var key in instances) {
      if (instances.hasOwnProperty(key)) {
        instances[key].dispose();
      }
    }

    instances = {};
  }

  return this;
}
/**
 * Get zrender instance by id
 * @param {string} id zrender instance id
 * @return {module:zrender/ZRender}
 */


function getInstance(id) {
  return instances[id];
}

function registerPainter(name, Ctor) {
  painterCtors[name] = Ctor;
}

function delInstance(id) {
  delete instances[id];
}
/**
 * @module zrender/ZRender
 */

/**
 * @constructor
 * @alias module:zrender/ZRender
 * @param {string} id
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 */


var ZRender = function (id, dom, opts) {
  opts = opts || {};
  /**
   * @type {HTMLDomElement}
   */

  this.dom = dom;
  /**
   * @type {string}
   */

  this.id = id;
  var self = this;
  var storage = new Storage();
  var rendererType = opts.renderer; // TODO WebGL

  if (useVML) {
    if (!painterCtors.vml) {
      throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
    }

    rendererType = 'vml';
  } else if (!rendererType || !painterCtors[rendererType]) {
    rendererType = 'canvas';
  }

  var painter = new painterCtors[rendererType](dom, storage, opts);
  this.storage = storage;
  this.painter = painter;
  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
  this.handler = new Handler(storage, painter, handerProxy, painter.root);
  /**
   * @type {module:zrender/animation/Animation}
   */

  this.animation = new Animation({
    stage: {
      update: zrUtil.bind(this.flush, this)
    }
  });
  this.animation.start();
  /**
   * @type {boolean}
   * @private
   */

  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
  // FIXME 有点ugly

  var oldDelFromStorage = storage.delFromStorage;
  var oldAddToStorage = storage.addToStorage;

  storage.delFromStorage = function (el) {
    oldDelFromStorage.call(storage, el);
    el && el.removeSelfFromZr(self);
  };

  storage.addToStorage = function (el) {
    oldAddToStorage.call(storage, el);
    el.addSelfToZr(self);
  };
};

ZRender.prototype = {
  constructor: ZRender,

  /**
   * 获取实例唯一标识
   * @return {string}
   */
  getId: function () {
    return this.id;
  },

  /**
   * 添加元素
   * @param  {module:zrender/Element} el
   */
  add: function (el) {
    this.storage.addRoot(el);
    this._needsRefresh = true;
  },

  /**
   * 删除元素
   * @param  {module:zrender/Element} el
   */
  remove: function (el) {
    this.storage.delRoot(el);
    this._needsRefresh = true;
  },

  /**
   * Change configuration of layer
   * @param {string} zLevel
   * @param {Object} config
   * @param {string} [config.clearColor=0] Clear color
   * @param {string} [config.motionBlur=false] If enable motion blur
   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
  */
  configLayer: function (zLevel, config) {
    this.painter.configLayer(zLevel, config);
    this._needsRefresh = true;
  },

  /**
   * Repaint the canvas immediately
   */
  refreshImmediately: function () {
    // var start = new Date();
    // Clear needsRefresh ahead to avoid something wrong happens in refresh
    // Or it will cause zrender refreshes again and again.
    this._needsRefresh = false;
    this.painter.refresh();
    /**
     * Avoid trigger zr.refresh in Element#beforeUpdate hook
     */

    this._needsRefresh = false; // var end = new Date();
    // var log = document.getElementById('log');
    // if (log) {
    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
    // }
  },

  /**
   * Mark and repaint the canvas in the next frame of browser
   */
  refresh: function () {
    this._needsRefresh = true;
  },

  /**
   * Perform all refresh
   */
  flush: function () {
    if (this._needsRefresh) {
      this.refreshImmediately();
    }

    if (this._needsRefreshHover) {
      this.refreshHoverImmediately();
    }
  },

  /**
   * Add element to hover layer
   * @param  {module:zrender/Element} el
   * @param {Object} style
   */
  addHover: function (el, style) {
    if (this.painter.addHover) {
      this.painter.addHover(el, style);
      this.refreshHover();
    }
  },

  /**
   * Add element from hover layer
   * @param  {module:zrender/Element} el
   */
  removeHover: function (el) {
    if (this.painter.removeHover) {
      this.painter.removeHover(el);
      this.refreshHover();
    }
  },

  /**
   * Clear all hover elements in hover layer
   * @param  {module:zrender/Element} el
   */
  clearHover: function () {
    if (this.painter.clearHover) {
      this.painter.clearHover();
      this.refreshHover();
    }
  },

  /**
   * Refresh hover in next frame
   */
  refreshHover: function () {
    this._needsRefreshHover = true;
  },

  /**
   * Refresh hover immediately
   */
  refreshHoverImmediately: function () {
    this._needsRefreshHover = false;
    this.painter.refreshHover && this.painter.refreshHover();
  },

  /**
   * Resize the canvas.
   * Should be invoked when container size is changed
   * @param {Object} [opts]
   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
   */
  resize: function (opts) {
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  },

  /**
   * Stop and clear all animation immediately
   */
  clearAnimation: function () {
    this.animation.clear();
  },

  /**
   * Get container width
   */
  getWidth: function () {
    return this.painter.getWidth();
  },

  /**
   * Get container height
   */
  getHeight: function () {
    return this.painter.getHeight();
  },

  /**
   * Export the canvas as Base64 URL
   * @param {string} type
   * @param {string} [backgroundColor='#fff']
   * @return {string} Base64 URL
   */
  // toDataURL: function(type, backgroundColor) {
  //     return this.painter.getRenderedCanvas({
  //         backgroundColor: backgroundColor
  //     }).toDataURL(type);
  // },

  /**
   * Converting a path to image.
   * It has much better performance of drawing image rather than drawing a vector path.
   * @param {module:zrender/graphic/Path} e
   * @param {number} width
   * @param {number} height
   */
  pathToImage: function (e, dpr) {
    return this.painter.pathToImage(e, dpr);
  },

  /**
   * Set default cursor
   * @param {string} [cursorStyle='default'] 例如 crosshair
   */
  setCursorStyle: function (cursorStyle) {
    this.handler.setCursorStyle(cursorStyle);
  },

  /**
   * Find hovered element
   * @param {number} x
   * @param {number} y
   * @return {Object} {target, topTarget}
   */
  findHover: function (x, y) {
    return this.handler.findHover(x, y);
  },

  /**
   * Bind event
   *
   * @param {string} eventName Event name
   * @param {Function} eventHandler Handler function
   * @param {Object} [context] Context object
   */
  on: function (eventName, eventHandler, context) {
    this.handler.on(eventName, eventHandler, context);
  },

  /**
   * Unbind event
   * @param {string} eventName Event name
   * @param {Function} [eventHandler] Handler function
   */
  off: function (eventName, eventHandler) {
    this.handler.off(eventName, eventHandler);
  },

  /**
   * Trigger event manually
   *
   * @param {string} eventName Event name
   * @param {event=} event Event object
   */
  trigger: function (eventName, event) {
    this.handler.trigger(eventName, event);
  },

  /**
   * Clear all objects and the canvas.
   */
  clear: function () {
    this.storage.delRoot();
    this.painter.clear();
  },

  /**
   * Dispose self.
   */
  dispose: function () {
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    delInstance(this.id);
  }
};
exports.version = version;
exports.init = init;
exports.dispose = dispose;
exports.getInstance = getInstance;
exports.registerPainter = registerPainter;

/***/ }),

/***/ "./resources/assets/js/components/index/welcome.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/index/welcome.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-a0facede\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/index/welcome.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources\\assets\\js\\components\\index\\welcome.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-a0facede", Component.options)
  } else {
    hotAPI.reload("data-v-a0facede", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL2luZGV4L3dlbGNvbWUudnVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9Db29yZGluYXRlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9FeHRlbnNpb25BUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclNlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXNlQmFyU2VyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvYmFySXRlbVN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvaGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xpbmVEcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2xhYmVsSGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL0xpbmVTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvbGluZUFuaW1hdGlvbkRpZmYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvcG9seS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0F4aXNCdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9BeGlzVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQ2FydGVzaWFuQXhpc1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL2NhcnRlc2lhbkF4aXNIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9CYXNlQXhpc1BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2F4aXNUcmlnZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZmluZFBvaW50RnJvbVNlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvbW9kZWxIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci92aWV3SGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21WaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vSW5zaWRlWm9vbU1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vSW5zaWRlWm9vbVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NsaWRlclpvb21Nb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NsaWRlclpvb21WaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vZGF0YVpvb21BY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9yb2Ftcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL3R5cGVEZWZhdWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbVNlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyaWRTaW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL0JydXNoVGFyZ2V0TWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9icnVzaEhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9jdXJzb3JIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvaW50ZXJhY3Rpb25NdXRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9saXN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL3NsaWRlck1vdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9zY3JvbGxhYmxlTGVnZW5kQWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kU2Nyb2xsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya0xpbmVNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrTGluZVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50TW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50Vmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL21hcmtlckhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpdGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveE1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9Ub29sYm94Vmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9NYWdpY1R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvUmVzdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9TYXZlQXNJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9BeGlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc0hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9SZWdpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9wYXJzZUdlb0pzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvRGF0YURpZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9MaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2VjaGFydHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvaGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYXlvdXQvYmFyR3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L3BvaW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbG9hZGluZy9kZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL0dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL09wdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL1Nlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvZ2xvYmFsRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vYXJlYVN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9ib3hMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2NvbG9yUGFsZXR0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vaXRlbVN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9saW5lU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vdGV4dFN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9oZWxwZXIvY29tcGF0U3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9JbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvTG9nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9PcmRpbmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9TY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvaGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2NsYXp6LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbnVtYmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC90aHJvdHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlldy9DaGFydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlldy9Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Zpc3VhbC9zZXJpZXNDb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlzdWFsL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvaW5kZXgvd2VsY29tZS52dWU/M2UxMyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL1BhaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL1N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9hcmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0xSVS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvYmJveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9jdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvQ29tcG91bmRQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC9wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3pyZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL2luZGV4L3dlbGNvbWUudnVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQURBLGtCQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0EsRUFMQTtBQU1BLFFBTkEscUJBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQURBO0FBRUEsNkJBRkE7QUFHQTtBQUhBLElBREE7QUFNQTtBQUNBO0FBREEsSUFOQTtBQVNBO0FBQ0EsZUFEQTtBQUVBO0FBRkEsSUFUQTtBQWFBO0FBQ0EsY0FEQTtBQUVBO0FBQ0EscURBREE7QUFFQTtBQUZBO0FBRkEsSUFiQTtBQW9CQTtBQUNBLGdCQURBO0FBRUE7QUFGQSxJQXBCQTtBQXdCQSxtQkF4QkE7QUF5QkEsY0FDQTtBQUNBLGNBREE7QUFFQSxrQkFGQTtBQUdBLGFBSEE7QUFJQTtBQUpBLElBREEsRUFPQTtBQUNBLGtCQURBO0FBRUEsa0JBRkE7QUFHQSxhQUhBO0FBSUE7QUFKQSxJQVBBLENBekJBO0FBdUNBLFdBQ0E7QUFDQSxvQkFEQTtBQUVBO0FBRkEsSUFEQSxDQXZDQTtBQTZDQSxXQUNBO0FBQ0E7QUFEQSxJQURBLENBN0NBO0FBa0RBO0FBbERBO0FBb0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBREE7QUFFQSxnQkFGQTtBQUdBLGFBSEE7QUFJQTtBQUNBLGFBQ0EsNEJBREEsRUFFQSw0QkFGQTtBQURBLE1BSkE7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Q0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCOzs7Ozs7O0FDNU9BOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdCQUFnQjtBQUNoQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDBCOzs7Ozs7O0FDN0RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEI7Ozs7Ozs7QUNoQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCOzs7Ozs7O0FDdEJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FB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Q0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4RUFBOEUsNkJBQTZCOztBQUUzRztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCOzs7Ozs7O0FDMVFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxpS0FBaUs7O0FBRWpLOztBQUVBO0FBQ0E7O0FBRUEsOEM7Ozs7Ozs7QUN6QkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Qsa0c7Ozs7Ozs7QUNwQkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDBCOzs7Ozs7O0FDdkVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0RUFBNEU7QUFDdkYsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FB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QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0EsOEVBQThFO0FBQzlFLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMERBQTBEOztBQUUxRDtBQUNBLG1FQUFtRTs7QUFFbkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsMEI7Ozs7Ozs7QUM3YUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOzs7QUFHcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCOzs7Ozs7O0FDaE1BOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDBCOzs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsMEI7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQjs7Ozs7OztBQ3JFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQjs7QUFFdEI7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEI7Ozs7Ozs7QUNsMkJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FB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Ozs7O0FDekxBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdGQUF3Rjs7QUFFeEY7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQSx5SEFBeUg7QUFDekg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQjs7Ozs7OztBQzdTQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDBCOzs7Ozs7O0FDL0JBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssRUFBRTs7QUFFUDtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVywyQkFBMkI7QUFDdEM7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBHQUEwRzs7QUFFMUc7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSwwQjs7Ozs7OztBQ3RJQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMEI7Ozs7Ozs7QUM1SEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELDBCOzs7Ozs7O0FDL0JBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7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QUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwwQjs7Ozs7OztBQ3pLQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLDBCOzs7Ozs7O0FDdENBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtDQUErQyxvREFBb0Q7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEI7Ozs7Ozs7QUN6RUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCOzs7Ozs7O0FDWEE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYyxFOzs7Ozs7O0FDN0JkOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLG1CQUFtQixtQkFBbUIsZ0JBQWdCO0FBQ3RHO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVM7QUFDWjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTCw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQXVCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCOzs7Ozs7O0FDbk9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU0sSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU8sY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FDM05BOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7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STs7Ozs7OztBQ2g2REQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0I7Ozs7Ozs7QUNsRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLDRCQUE0QjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRTs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEI7Ozs7Ozs7QUN2Q0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxX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QSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQjs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdB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LGNBQWM7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0M7Ozs7Ozs7QUN0Q0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsWUFBWTtBQUMvQix1QkFBdUI7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FB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QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPLEVBQUU7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTyxPQUFPO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU8sRUFBRTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyxPQUFPO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qjs7Ozs7OztBQzFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLCtCQUErQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSwrQkFBK0I7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLDBCOzs7Ozs7O0FDOWJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCLCtEQUErRDs7QUFFL0Q7QUFDQSwwQkFBMEI7O0FBRTFCLGlDQUFpQzs7QUFFakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCOzs7Ozs7O0FDdEVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsMEI7Ozs7Ozs7QUN2REE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaURBQWlEO0FBQzVELFlBQVksMENBQTBDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpREFBaUQ7QUFDNUQsV0FBVywwQ0FBMEM7QUFDckQsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixZQUFZLDBDQUEwQztBQUN0RDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0M7Ozs7Ozs7QUN2RkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCOzs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCOzs7Ozs7O0FDaEZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsU0FBUztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQjs7Ozs7OztBQ3ZHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQjs7Ozs7OztBQ25FQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEMsWUFBWSw2QkFBNkI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGOztBQUU1RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxXQUFXLE9BQU87QUFDbEIsV0FBVyw2QkFBNkI7QUFDeEMsV0FBVyxlQUFlLFNBQVM7QUFDbkM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDs7QUFFQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxZQUFZO0FBQ2IsV0FBVzs7O0FBR1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLHFCQUFxQjtBQUNoQyxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DOzs7Ozs7O0FDbGJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCxlQUFlOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQjs7Ozs7OztBQ3REQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwwQjs7Ozs7OztBQ2xDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwwQjs7Ozs7OztBQ2hIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsMEI7Ozs7Ozs7QUMvQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsMEI7Ozs7Ozs7QUNyREE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwwQjs7Ozs7OztBQ3BCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsMEI7Ozs7Ozs7QUN2QkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDBCOzs7Ozs7O0FDdkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwwQjs7Ozs7OztBQ3pCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsMEI7Ozs7Ozs7QUMzQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEMsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjs7QUFFQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGVBQWUsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxQ0FBcUMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7OztBQUdiOztBQUVBLDBEQUEwRDtBQUMxRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCOzs7Ozs7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQjs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSwwQjs7Ozs7OztBQ3ZVQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCOzs7Ozs7O0FDMVJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0EsUUFBUTs7QUFFUixhQUFhLGVBQWU7QUFDNUI7QUFDQSxHQUFHOzs7QUFHSCwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEI7Ozs7Ozs7QUN4WkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBLHdCQUF3Qjs7QUFFeEIsMkJBQTJCOztBQUUzQiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCOzs7Ozs7O0FDbkdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsY0FBYztBQUMzQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU8sRUFBRTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEM7Ozs7Ozs7QUNoYkE7QUFDQTtBQUNBO0FBQ0EsOGFBQXNSO0FBQ3RSO0FBQ0EsdVNBQW1MO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuXHQ8ZGl2IGNsYXNzPVwid2VsY29tZVwiPlxuXHRcdDxkaXYgaWQ9XCJvcmRlcl9pbnRvXCIgc3R5bGU9XCJ3aWR0aDoxMDAlO2hlaWdodDo1MDBweFwiPjwvZGl2PlxuXHQ8L2Rpdj5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuXHRsZXQgZWNoYXJ0cyA9IHJlcXVpcmUoJ2VjaGFydHMvbGliL2VjaGFydHMnKTtcblx0Ly8g5byV5YWl5p+x54q25Zu+XG5cdHJlcXVpcmUoJ2VjaGFydHMvbGliL2NoYXJ0L2JhcicpO1xuXHRyZXF1aXJlKCdlY2hhcnRzL2xpYi9jaGFydC9saW5lJyk7XG5cdC8vIOW8leWFpeaPkOekuuahhuWSjOagh+mimOe7hOS7tlxuXHRyZXF1aXJlKCdlY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcCcpO1xuXHRyZXF1aXJlKCdlY2hhcnRzL2xpYi9jb21wb25lbnQvdGl0bGUnKTtcblx0cmVxdWlyZShcImVjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmRTY3JvbGxcIik7XG5cdHJlcXVpcmUoXCJlY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb21cIik7XG5cdHJlcXVpcmUoXCJlY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya1BvaW50XCIpO1xuXHRyZXF1aXJlKFwiZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtMaW5lXCIpO1xuXHRyZXF1aXJlKFwiZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3hcIik7XG5cdFxuXHRleHBvcnQgZGVmYXVsdCB7XG5cdFx0ZGF0YSgpe1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0b3JkZXJfaW50byA6ICcnLFxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdG1vdW50ZWQoKXtcblx0XHRcdGxldCB0ID0gdGhpcztcblx0XHRcdHQuJGVtaXQoJ2luaXQnKTtcblx0XHRcdFxuXHRcdFx0dC5vcmRlcl9pbnRvID0gZWNoYXJ0cy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvcmRlcl9pbnRvJykpO1xuXHRcdFx0bGV0IG9yZGVyX29wdGlvbnMgPSB7XG5cdFx0XHRcdHRpdGxlIDoge1xuXHRcdFx0XHRcdGxlZnQ6ICdjZW50ZXInLFxuXHRcdFx0XHRcdHRleHQ6ICfov5HmnJ8xNeWkqeavj+aXpeiuouWNleS6pOaYk+WFpei0pumHkeminee7n+iuoScsXG5cdFx0XHRcdFx0c3VidGV4dDogJ+aMieaXpeWIkuWIhu+8jOmHkemineWNleS9je+8muWIhidcblx0XHRcdFx0fSxcblx0XHRcdFx0dG9vbHRpcCA6IHtcblx0XHRcdFx0XHR0cmlnZ2VyOiAnYXhpcydcblx0XHRcdFx0fSxcblx0XHRcdFx0bGVnZW5kOiB7XG5cdFx0XHRcdFx0dG9wIDogJzYwcHgnLFxuXHRcdFx0XHRcdGRhdGE6IFtdXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRvb2xib3g6IHtcblx0XHRcdFx0XHRzaG93IDogdHJ1ZSxcblx0XHRcdFx0XHRmZWF0dXJlIDoge1xuXHRcdFx0XHRcdFx0bWFnaWNUeXBlIDoge3Nob3c6IHRydWUsIHR5cGU6IFsnbGluZScsICdiYXInXX0sXG5cdFx0XHRcdFx0XHRzYXZlQXNJbWFnZSA6IHtzaG93OiB0cnVlfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0Z3JpZCA6IHtcblx0XHRcdFx0XHR0b3AgOiAnMTYwcHgnLFxuXHRcdFx0XHRcdGNvbnRhaW5MYWJlbDogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjYWxjdWxhYmxlIDogdHJ1ZSxcblx0XHRcdFx0ZGF0YVpvb206IFtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzaG93OiB0cnVlLFxuXHRcdFx0XHRcdFx0cmVhbHRpbWU6IHRydWUsXG5cdFx0XHRcdFx0XHRzdGFydDogODAsXG5cdFx0XHRcdFx0XHRlbmQ6IDEwMFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dHlwZTogJ2luc2lkZScsXG5cdFx0XHRcdFx0XHRyZWFsdGltZTogdHJ1ZSxcblx0XHRcdFx0XHRcdHN0YXJ0OiA2MCxcblx0XHRcdFx0XHRcdGVuZDogMTAwXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRdLFxuXHRcdFx0XHR4QXhpcyA6IFtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0eXBlIDogJ2NhdGVnb3J5Jyxcblx0XHRcdFx0XHRcdGRhdGEgOiBbXVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XSxcblx0XHRcdFx0eUF4aXMgOiBbXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dHlwZSA6ICd2YWx1ZSdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdF0sXG5cdFx0XHRcdHNlcmllcyA6IFtdXG5cdFx0XHR9O1xuXHRcdFx0Z2V0KCcvd2VsY29tZScse30sZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdGxldCBwYXltZW50cyA9IGRhdGEucGF5bWVudHM7XG5cdFx0XHRcdGxldCBpbnRvID0gZGF0YS5pbnRvO1xuXHRcdFx0XHRmb3IobGV0IGRhdGUgaW4gaW50by5kYXRlKXtcblx0XHRcdFx0XHRvcmRlcl9vcHRpb25zLnhBeGlzWzBdLmRhdGEucHVzaChpbnRvLmRhdGVbZGF0ZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIOWfuuacrOS/oeaBr+WPmOmHj1xuXHRcdFx0XHRsZXQgc2VyaWVzX3RlbXBsYXRlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0bmFtZTonJyxcblx0XHRcdFx0XHRcdHR5cGU6J2JhcicsXG5cdFx0XHRcdFx0XHRkYXRhOltdLFxuXHRcdFx0XHRcdFx0bWFya1BvaW50IDoge1xuXHRcdFx0XHRcdFx0XHRkYXRhIDogW1xuXHRcdFx0XHRcdFx0XHRcdHt0eXBlIDogJ21heCcsIG5hbWU6ICfmnIDlpKflgLwnfSxcblx0XHRcdFx0XHRcdFx0XHR7dHlwZSA6ICdtaW4nLCBuYW1lOiAn5pyA5bCP5YC8J31cblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG1hcmtMaW5lIDoge1xuXHRcdFx0XHRcdFx0XHRkYXRhIDogW1xuXHRcdFx0XHRcdFx0XHRcdHt0eXBlIDogJ2F2ZXJhZ2UnLCBuYW1lOiAn5bmz5Z2H5YC8J31cblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGxhYmVsOiB7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbDoge1xuXHRcdFx0XHRcdFx0XHRcdHNob3c6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb246ICd0b3AnXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yKGxldCBwYXltZW50IGluIGludG8uYW1vdW50KXtcblx0XHRcdFx0XHRsZXQgc2VyaWVzID0gc2VyaWVzX3RlbXBsYXRlKCk7XG5cdFx0XHRcdFx0c2VyaWVzLm5hbWUgPSBwYXltZW50c1twYXltZW50XSB8fCBwYXltZW50O1xuXHRcdFx0XHRcdG9yZGVyX29wdGlvbnMubGVnZW5kLmRhdGEucHVzaChzZXJpZXMubmFtZSk7XG5cdFx0XHRcdFx0Zm9yKGxldCBkYXRlIGluIGludG8uYW1vdW50W3BheW1lbnRdKXtcblx0XHRcdFx0XHRcdHNlcmllcy5kYXRhLnB1c2goaW50by5hbW91bnRbcGF5bWVudF1bZGF0ZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvcmRlcl9vcHRpb25zLnNlcmllcy5wdXNoKHNlcmllcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHQub3JkZXJfaW50by5zZXRPcHRpb24ob3JkZXJfb3B0aW9ucyk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0d2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHQub3JkZXJfaW50by5yZXNpemUoKTtcblx0XHRcdFx0fSwyMDApO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvaW5kZXgvd2VsY29tZS52dWUiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9ycyA9IHt9O1xuXG5mdW5jdGlvbiBDb29yZGluYXRlU3lzdGVtTWFuYWdlcigpIHtcbiAgdGhpcy5fY29vcmRpbmF0ZVN5c3RlbXMgPSBbXTtcbn1cblxuQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIsXG4gIGNyZWF0ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb29yZGluYXRlU3lzdGVtcyA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9ycywgZnVuY3Rpb24gKGNyZWF0ZXIsIHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ID0gY3JlYXRlci5jcmVhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICAgIGNvb3JkaW5hdGVTeXN0ZW1zID0gY29vcmRpbmF0ZVN5c3RlbXMuY29uY2F0KGxpc3QgfHwgW10pO1xuICAgIH0pO1xuICAgIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zID0gY29vcmRpbmF0ZVN5c3RlbXM7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zLCBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgIC8vIEZJWE1FIE1VU1QgaGF2ZVxuICAgICAgY29vcmRTeXMudXBkYXRlICYmIGNvb3JkU3lzLnVwZGF0ZShlY01vZGVsLCBhcGkpO1xuICAgIH0pO1xuICB9LFxuICBnZXRDb29yZGluYXRlU3lzdGVtczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlU3lzdGVtcy5zbGljZSgpO1xuICB9XG59O1xuXG5Db29yZGluYXRlU3lzdGVtTWFuYWdlci5yZWdpc3RlciA9IGZ1bmN0aW9uICh0eXBlLCBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcikge1xuICBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnNbdHlwZV0gPSBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcjtcbn07XG5cbkNvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLmdldCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnNbdHlwZV07XG59O1xuXG52YXIgX2RlZmF1bHQgPSBDb29yZGluYXRlU3lzdGVtTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvQ29vcmRpbmF0ZVN5c3RlbS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvQ29vcmRpbmF0ZVN5c3RlbS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZWNoYXJ0c0FQSUxpc3QgPSBbJ2dldERvbScsICdnZXRacicsICdnZXRXaWR0aCcsICdnZXRIZWlnaHQnLCAnZ2V0RGV2aWNlUGl4ZWxSYXRpbycsICdkaXNwYXRjaEFjdGlvbicsICdpc0Rpc3Bvc2VkJywgJ29uJywgJ29mZicsICdnZXREYXRhVVJMJywgJ2dldENvbm5lY3RlZERhdGFVUkwnLCAnZ2V0TW9kZWwnLCAnZ2V0T3B0aW9uJywgJ2dldFZpZXdPZkNvbXBvbmVudE1vZGVsJywgJ2dldFZpZXdPZlNlcmllc01vZGVsJ107IC8vIEFuZCBgZ2V0Q29vcmRpbmF0ZVN5c3RlbXNgIGFuZCBgZ2V0Q29tcG9uZW50QnlFbGVtZW50YCB3aWxsIGJlIGluamVjdGVkIGluIGVjaGFydHMuanNcblxuZnVuY3Rpb24gRXh0ZW5zaW9uQVBJKGNoYXJ0SW5zdGFuY2UpIHtcbiAgenJVdGlsLmVhY2goZWNoYXJ0c0FQSUxpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhpc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGNoYXJ0SW5zdGFuY2VbbmFtZV0sIGNoYXJ0SW5zdGFuY2UpO1xuICB9LCB0aGlzKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gRXh0ZW5zaW9uQVBJO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9FeHRlbnNpb25BUEkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL0V4dGVuc2lvbkFQSS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgYmFyTGF5b3V0R3JpZCA9IHJlcXVpcmUoXCIuLi9sYXlvdXQvYmFyR3JpZFwiKTtcblxucmVxdWlyZShcIi4uL2Nvb3JkL2NhcnRlc2lhbi9HcmlkXCIpO1xuXG5yZXF1aXJlKFwiLi9iYXIvQmFyU2VyaWVzXCIpO1xuXG5yZXF1aXJlKFwiLi9iYXIvQmFyVmlld1wiKTtcblxucmVxdWlyZShcIi4uL2NvbXBvbmVudC9ncmlkU2ltcGxlXCIpO1xuXG4vLyBJbiBjYXNlIGRldmVsb3BlciBmb3JnZXQgdG8gaW5jbHVkZSBncmlkIGNvbXBvbmVudFxuZWNoYXJ0cy5yZWdpc3RlckxheW91dCh6clV0aWwuY3VycnkoYmFyTGF5b3V0R3JpZCwgJ2JhcicpKTsgLy8gVmlzdWFsIGNvZGluZyBmb3IgbGVnZW5kXG5cbmVjaGFydHMucmVnaXN0ZXJWaXN1YWwoZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdiYXInLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICBkYXRhLnNldFZpc3VhbCgnbGVnZW5kU3ltYm9sJywgJ3JvdW5kUmVjdCcpO1xuICB9KTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEJhc2VCYXJTZXJpZXMgPSByZXF1aXJlKFwiLi9CYXNlQmFyU2VyaWVzXCIpO1xuXG52YXIgX2RlZmF1bHQgPSBCYXNlQmFyU2VyaWVzLmV4dGVuZCh7XG4gIHR5cGU6ICdzZXJpZXMuYmFyJyxcbiAgZGVwZW5kZW5jaWVzOiBbJ2dyaWQnLCAncG9sYXInXSxcbiAgYnJ1c2hTZWxlY3RvcjogJ3JlY3QnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFyU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFyU2VyaWVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIF9oZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5cbnZhciBzZXRMYWJlbCA9IF9oZWxwZXIuc2V0TGFiZWw7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIGJhckl0ZW1TdHlsZSA9IHJlcXVpcmUoXCIuL2Jhckl0ZW1TdHlsZVwiKTtcblxudmFyIEJBUl9CT1JERVJfV0lEVEhfUVVFUlkgPSBbJ2l0ZW1TdHlsZScsICdub3JtYWwnLCAnYmFyQm9yZGVyV2lkdGgnXTsgLy8gRklYTUVcbi8vIEp1c3QgZm9yIGNvbXBhdGlibGUgd2l0aCBlYzIuXG5cbnpyVXRpbC5leHRlbmQoTW9kZWwucHJvdG90eXBlLCBiYXJJdGVtU3R5bGUpO1xuXG52YXIgX2RlZmF1bHQgPSBlY2hhcnRzLmV4dGVuZENoYXJ0Vmlldyh7XG4gIHR5cGU6ICdiYXInLFxuICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVTeXN0ZW1UeXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJyk7XG5cbiAgICBpZiAoY29vcmRpbmF0ZVN5c3RlbVR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgfHwgY29vcmRpbmF0ZVN5c3RlbVR5cGUgPT09ICdwb2xhcicpIHtcbiAgICAgIHRoaXMuX3JlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICB9IGVsc2Uge31cblxuICAgIHJldHVybiB0aGlzLmdyb3VwO1xuICB9LFxuICBkaXNwb3NlOiB6clV0aWwubm9vcCxcbiAgX3JlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgY29vcmQgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkLmdldEJhc2VBeGlzKCk7XG4gICAgdmFyIGlzSG9yaXpvbnRhbE9yUmFkaWFsO1xuXG4gICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgIGlzSG9yaXpvbnRhbE9yUmFkaWFsID0gYmFzZUF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgfSBlbHNlIGlmIChjb29yZC50eXBlID09PSAncG9sYXInKSB7XG4gICAgICBpc0hvcml6b250YWxPclJhZGlhbCA9IGJhc2VBeGlzLmRpbSA9PT0gJ2FuZ2xlJztcbiAgICB9XG5cbiAgICB2YXIgYW5pbWF0aW9uTW9kZWwgPSBzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSA/IHNlcmllc01vZGVsIDogbnVsbDtcbiAgICBkYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShkYXRhSW5kZXgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgICB2YXIgbGF5b3V0ID0gZ2V0TGF5b3V0W2Nvb3JkLnR5cGVdKGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsKTtcbiAgICAgIHZhciBlbCA9IGVsZW1lbnRDcmVhdG9yW2Nvb3JkLnR5cGVdKGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBhbmltYXRpb25Nb2RlbCk7XG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4LCBlbCk7XG4gICAgICBncm91cC5hZGQoZWwpO1xuICAgICAgdXBkYXRlU3R5bGUoZWwsIGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIHNlcmllc01vZGVsLCBpc0hvcml6b250YWxPclJhZGlhbCwgY29vcmQudHlwZSA9PT0gJ3BvbGFyJyk7XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgIHZhciBlbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJbmRleCk7XG5cbiAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShuZXdJbmRleCkpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwobmV3SW5kZXgpO1xuICAgICAgdmFyIGxheW91dCA9IGdldExheW91dFtjb29yZC50eXBlXShkYXRhLCBuZXdJbmRleCwgaXRlbU1vZGVsKTtcblxuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHtcbiAgICAgICAgICBzaGFwZTogbGF5b3V0XG4gICAgICAgIH0sIGFuaW1hdGlvbk1vZGVsLCBuZXdJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGVsZW1lbnRDcmVhdG9yW2Nvb3JkLnR5cGVdKGRhdGEsIG5ld0luZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGFuaW1hdGlvbk1vZGVsLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0luZGV4LCBlbCk7IC8vIEFkZCBiYWNrXG5cbiAgICAgIGdyb3VwLmFkZChlbCk7XG4gICAgICB1cGRhdGVTdHlsZShlbCwgZGF0YSwgbmV3SW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGNvb3JkLnR5cGUgPT09ICdwb2xhcicpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcblxuICAgICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgZWwgJiYgcmVtb3ZlUmVjdChkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCAmJiByZW1vdmVTZWN0b3IoZGF0YUluZGV4LCBhbmltYXRpb25Nb2RlbCwgZWwpO1xuICAgICAgfVxuICAgIH0pLmV4ZWN1dGUoKTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICBpZiAoZWNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpKSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGlmIChlbC50eXBlID09PSAnc2VjdG9yJykge1xuICAgICAgICAgICAgcmVtb3ZlU2VjdG9yKGVsLmRhdGFJbmRleCwgZWNNb2RlbCwgZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVSZWN0KGVsLmRhdGFJbmRleCwgZWNNb2RlbCwgZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciBlbGVtZW50Q3JlYXRvciA9IHtcbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc0hvcml6b250YWwsIGFuaW1hdGlvbk1vZGVsLCBpc1VwZGF0ZSkge1xuICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBzaGFwZTogenJVdGlsLmV4dGVuZCh7fSwgbGF5b3V0KVxuICAgIH0pOyAvLyBBbmltYXRpb25cblxuICAgIGlmIChhbmltYXRpb25Nb2RlbCkge1xuICAgICAgdmFyIHJlY3RTaGFwZSA9IHJlY3Quc2hhcGU7XG4gICAgICB2YXIgYW5pbWF0ZVByb3BlcnR5ID0gaXNIb3Jpem9udGFsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgdmFyIGFuaW1hdGVUYXJnZXQgPSB7fTtcbiAgICAgIHJlY3RTaGFwZVthbmltYXRlUHJvcGVydHldID0gMDtcbiAgICAgIGFuaW1hdGVUYXJnZXRbYW5pbWF0ZVByb3BlcnR5XSA9IGxheW91dFthbmltYXRlUHJvcGVydHldO1xuICAgICAgZ3JhcGhpY1tpc1VwZGF0ZSA/ICd1cGRhdGVQcm9wcycgOiAnaW5pdFByb3BzJ10ocmVjdCwge1xuICAgICAgICBzaGFwZTogYW5pbWF0ZVRhcmdldFxuICAgICAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIHBvbGFyOiBmdW5jdGlvbiAoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNSYWRpYWwsIGFuaW1hdGlvbk1vZGVsLCBpc1VwZGF0ZSkge1xuICAgIHZhciBzZWN0b3IgPSBuZXcgZ3JhcGhpYy5TZWN0b3Ioe1xuICAgICAgc2hhcGU6IHpyVXRpbC5leHRlbmQoe30sIGxheW91dClcbiAgICB9KTsgLy8gQW5pbWF0aW9uXG5cbiAgICBpZiAoYW5pbWF0aW9uTW9kZWwpIHtcbiAgICAgIHZhciBzZWN0b3JTaGFwZSA9IHNlY3Rvci5zaGFwZTtcbiAgICAgIHZhciBhbmltYXRlUHJvcGVydHkgPSBpc1JhZGlhbCA/ICdyJyA6ICdlbmRBbmdsZSc7XG4gICAgICB2YXIgYW5pbWF0ZVRhcmdldCA9IHt9O1xuICAgICAgc2VjdG9yU2hhcGVbYW5pbWF0ZVByb3BlcnR5XSA9IGlzUmFkaWFsID8gMCA6IGxheW91dC5zdGFydEFuZ2xlO1xuICAgICAgYW5pbWF0ZVRhcmdldFthbmltYXRlUHJvcGVydHldID0gbGF5b3V0W2FuaW1hdGVQcm9wZXJ0eV07XG4gICAgICBncmFwaGljW2lzVXBkYXRlID8gJ3VwZGF0ZVByb3BzJyA6ICdpbml0UHJvcHMnXShzZWN0b3IsIHtcbiAgICAgICAgc2hhcGU6IGFuaW1hdGVUYXJnZXRcbiAgICAgIH0sIGFuaW1hdGlvbk1vZGVsLCBkYXRhSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0b3I7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlbW92ZVJlY3QoZGF0YUluZGV4LCBhbmltYXRpb25Nb2RlbCwgZWwpIHtcbiAgLy8gTm90IHNob3cgdGV4dCB3aGVuIGFuaW1hdGluZ1xuICBlbC5zdHlsZS50ZXh0ID0gbnVsbDtcbiAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgIHNoYXBlOiB7XG4gICAgICB3aWR0aDogMFxuICAgIH1cbiAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCwgZnVuY3Rpb24gKCkge1xuICAgIGVsLnBhcmVudCAmJiBlbC5wYXJlbnQucmVtb3ZlKGVsKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNlY3RvcihkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCkge1xuICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gIGVsLnN0eWxlLnRleHQgPSBudWxsO1xuICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgc2hhcGU6IHtcbiAgICAgIHI6IGVsLnNoYXBlLnIwXG4gICAgfVxuICB9LCBhbmltYXRpb25Nb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgZWwucGFyZW50ICYmIGVsLnBhcmVudC5yZW1vdmUoZWwpO1xuICB9KTtcbn1cblxudmFyIGdldExheW91dCA9IHtcbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCkge1xuICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgICB2YXIgZml4ZWRMaW5lV2lkdGggPSBnZXRMaW5lV2lkdGgoaXRlbU1vZGVsLCBsYXlvdXQpOyAvLyBmaXggbGF5b3V0IHdpdGggbGluZVdpZHRoXG5cbiAgICB2YXIgc2lnblggPSBsYXlvdXQud2lkdGggPiAwID8gMSA6IC0xO1xuICAgIHZhciBzaWduWSA9IGxheW91dC5oZWlnaHQgPiAwID8gMSA6IC0xO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBsYXlvdXQueCArIHNpZ25YICogZml4ZWRMaW5lV2lkdGggLyAyLFxuICAgICAgeTogbGF5b3V0LnkgKyBzaWduWSAqIGZpeGVkTGluZVdpZHRoIC8gMixcbiAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGggLSBzaWduWCAqIGZpeGVkTGluZVdpZHRoLFxuICAgICAgaGVpZ2h0OiBsYXlvdXQuaGVpZ2h0IC0gc2lnblkgKiBmaXhlZExpbmVXaWR0aFxuICAgIH07XG4gIH0sXG4gIHBvbGFyOiBmdW5jdGlvbiAoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwpIHtcbiAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN4OiBsYXlvdXQuY3gsXG4gICAgICBjeTogbGF5b3V0LmN5LFxuICAgICAgcjA6IGxheW91dC5yMCxcbiAgICAgIHI6IGxheW91dC5yLFxuICAgICAgc3RhcnRBbmdsZTogbGF5b3V0LnN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZTogbGF5b3V0LmVuZEFuZ2xlXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWwsIGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIHNlcmllc01vZGVsLCBpc0hvcml6b250YWwsIGlzUG9sYXIpIHtcbiAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ2NvbG9yJyk7XG4gIHZhciBvcGFjaXR5ID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ29wYWNpdHknKTtcbiAgdmFyIGl0ZW1TdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUubm9ybWFsJyk7XG4gIHZhciBob3ZlclN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUuZW1waGFzaXMnKS5nZXRCYXJJdGVtU3R5bGUoKTtcblxuICBpZiAoIWlzUG9sYXIpIHtcbiAgICBlbC5zZXRTaGFwZSgncicsIGl0ZW1TdHlsZU1vZGVsLmdldCgnYmFyQm9yZGVyUmFkaXVzJykgfHwgMCk7XG4gIH1cblxuICBlbC51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoe1xuICAgIGZpbGw6IGNvbG9yLFxuICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgfSwgaXRlbVN0eWxlTW9kZWwuZ2V0QmFySXRlbVN0eWxlKCkpKTtcbiAgdmFyIGN1cnNvclN0eWxlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2N1cnNvcicpO1xuICBjdXJzb3JTdHlsZSAmJiBlbC5hdHRyKCdjdXJzb3InLCBjdXJzb3JTdHlsZSk7XG4gIHZhciBsYWJlbFBvc2l0aW9uT3V0c2lkZSA9IGlzSG9yaXpvbnRhbCA/IGxheW91dC5oZWlnaHQgPiAwID8gJ2JvdHRvbScgOiAndG9wJyA6IGxheW91dC53aWR0aCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIGlmICghaXNQb2xhcikge1xuICAgIHNldExhYmVsKGVsLnN0eWxlLCBob3ZlclN0eWxlLCBpdGVtTW9kZWwsIGNvbG9yLCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBsYWJlbFBvc2l0aW9uT3V0c2lkZSk7XG4gIH1cblxuICBncmFwaGljLnNldEhvdmVyU3R5bGUoZWwsIGhvdmVyU3R5bGUpO1xufSAvLyBJbiBjYXNlIHdpZHRoIG9yIGhlaWdodCBhcmUgdG9vIHNtYWxsLlxuXG5cbmZ1bmN0aW9uIGdldExpbmVXaWR0aChpdGVtTW9kZWwsIHJhd0xheW91dCkge1xuICB2YXIgbGluZVdpZHRoID0gaXRlbU1vZGVsLmdldChCQVJfQk9SREVSX1dJRFRIX1FVRVJZKSB8fCAwO1xuICByZXR1cm4gTWF0aC5taW4obGluZVdpZHRoLCBNYXRoLmFicyhyYXdMYXlvdXQud2lkdGgpLCBNYXRoLmFicyhyYXdMYXlvdXQuaGVpZ2h0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXJWaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFNlcmllc01vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL1Nlcmllc1wiKTtcblxudmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKFwiLi4vaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXlcIik7XG5cbnZhciBfZGVmYXVsdCA9IFNlcmllc01vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdzZXJpZXMuX19iYXNlX2Jhcl9fJyxcbiAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheShvcHRpb24uZGF0YSwgdGhpcywgZWNNb2RlbCk7XG4gIH0sXG4gIGdldE1hcmtlclBvc2l0aW9uOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgIC8vIFBFTkRJTkcgaWYgY2xhbXAgP1xuICAgICAgdmFyIHB0ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsdWUsIHRydWUpO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmdldExheW91dCgnb2Zmc2V0Jyk7XG4gICAgICB2YXIgc2l6ZSA9IGRhdGEuZ2V0TGF5b3V0KCdzaXplJyk7XG4gICAgICB2YXIgb2Zmc2V0SW5kZXggPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpLmlzSG9yaXpvbnRhbCgpID8gMCA6IDE7XG4gICAgICBwdFtvZmZzZXRJbmRleF0gKz0gb2Zmc2V0ICsgc2l6ZSAvIDI7XG4gICAgICByZXR1cm4gcHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gIH0sXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgLy8g5LiA57qn5bGC5Y+gXG4gICAgejogMixcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICBjb29yZGluYXRlU3lzdGVtOiAnY2FydGVzaWFuMmQnLFxuICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICAvLyBzdGFjazogbnVsbFxuICAgIC8vIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICAgIC8vIHhBeGlzSW5kZXg6IDAsXG4gICAgLy8geUF4aXNJbmRleDogMCxcbiAgICAvLyDmnIDlsI/pq5jluqbmlLnkuLowXG4gICAgYmFyTWluSGVpZ2h0OiAwLFxuICAgIC8vIOacgOWwj+inkuW6puS4ujDvvIzku4Xlr7nmnoHlnZDmoIfns7vkuIvnmoTmn7Hnirblm77mnInmlYhcbiAgICBiYXJNaW5BbmdsZTogMCxcbiAgICAvLyBjdXJzb3I6IG51bGwsXG4gICAgLy8gYmFyTWF4V2lkdGg6IG51bGwsXG4gICAgLy8g6buY6K6k6Ieq6YCC5bqUXG4gICAgLy8gYmFyV2lkdGg6IG51bGwsXG4gICAgLy8g5p+x6Ze06Led56a777yM6buY6K6k5Li65p+x5b2i5a695bqm55qEMzAl77yM5Y+v6K6+5Zu65a6a5YC8XG4gICAgLy8gYmFyR2FwOiAnMzAlJyxcbiAgICAvLyDnsbvnm67pl7Tmn7HlvaLot53nprvvvIzpu5jorqTkuLrnsbvnm67pl7Tot53nmoQyMCXvvIzlj6/orr7lm7rlrprlgLxcbiAgICAvLyBiYXJDYXRlZ29yeUdhcDogJzIwJScsXG4gICAgLy8gbGFiZWw6IHtcbiAgICAvLyAgICAgbm9ybWFsOiB7XG4gICAgLy8gICAgICAgICBzaG93OiBmYWxzZVxuICAgIC8vICAgICB9XG4gICAgLy8gfSxcbiAgICBpdGVtU3R5bGU6IHsvLyBub3JtYWw6IHtcbiAgICAgIC8vIGNvbG9yOiAn5ZCE5byCJ1xuICAgICAgLy8gfSxcbiAgICAgIC8vIGVtcGhhc2lzOiB7fVxuICAgIH1cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0Jhc2VCYXJTZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXNlQmFyU2VyaWVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG1ha2VTdHlsZU1hcHBlciA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9taXhpbi9tYWtlU3R5bGVNYXBwZXJcIik7XG5cbnZhciBnZXRCYXJJdGVtU3R5bGUgPSBtYWtlU3R5bGVNYXBwZXIoW1snZmlsbCcsICdjb2xvciddLCBbJ3N0cm9rZScsICdib3JkZXJDb2xvciddLCBbJ2xpbmVXaWR0aCcsICdib3JkZXJXaWR0aCddLCAvLyBDb21wYXRpdGFibGUgd2l0aCAyXG5bJ3N0cm9rZScsICdiYXJCb3JkZXJDb2xvciddLCBbJ2xpbmVXaWR0aCcsICdiYXJCb3JkZXJXaWR0aCddLCBbJ29wYWNpdHknXSwgWydzaGFkb3dCbHVyJ10sIFsnc2hhZG93T2Zmc2V0WCddLCBbJ3NoYWRvd09mZnNldFknXSwgWydzaGFkb3dDb2xvciddXSk7XG52YXIgX2RlZmF1bHQgPSB7XG4gIGdldEJhckl0ZW1TdHlsZTogZnVuY3Rpb24gKGV4Y2x1ZGVzKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0QmFySXRlbVN0eWxlKHRoaXMsIGV4Y2x1ZGVzKTtcblxuICAgIGlmICh0aGlzLmdldEJvcmRlckxpbmVEYXNoKSB7XG4gICAgICB2YXIgbGluZURhc2ggPSB0aGlzLmdldEJvcmRlckxpbmVEYXNoKCk7XG4gICAgICBsaW5lRGFzaCAmJiAoc3R5bGUubGluZURhc2ggPSBsaW5lRGFzaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvYmFySXRlbVN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvYmFySXRlbVN0eWxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG5mdW5jdGlvbiBzZXRMYWJlbChub3JtYWxTdHlsZSwgaG92ZXJTdHlsZSwgaXRlbU1vZGVsLCBjb2xvciwgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCwgbGFiZWxQb3NpdGlvbk91dHNpZGUpIHtcbiAgdmFyIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLm5vcm1hbCcpO1xuICB2YXIgaG92ZXJMYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5lbXBoYXNpcycpO1xuICBncmFwaGljLnNldExhYmVsU3R5bGUobm9ybWFsU3R5bGUsIGhvdmVyU3R5bGUsIGxhYmVsTW9kZWwsIGhvdmVyTGFiZWxNb2RlbCwge1xuICAgIGxhYmVsRmV0Y2hlcjogc2VyaWVzTW9kZWwsXG4gICAgbGFiZWxEYXRhSW5kZXg6IGRhdGFJbmRleCxcbiAgICBkZWZhdWx0VGV4dDogc2VyaWVzTW9kZWwuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KSxcbiAgICBpc1JlY3RUZXh0OiB0cnVlLFxuICAgIGF1dG9Db2xvcjogY29sb3JcbiAgfSk7XG4gIGZpeFBvc2l0aW9uKG5vcm1hbFN0eWxlKTtcbiAgZml4UG9zaXRpb24oaG92ZXJTdHlsZSk7XG59XG5cbmZ1bmN0aW9uIGZpeFBvc2l0aW9uKHN0eWxlLCBsYWJlbFBvc2l0aW9uT3V0c2lkZSkge1xuICBpZiAoc3R5bGUudGV4dFBvc2l0aW9uID09PSAnb3V0c2lkZScpIHtcbiAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBsYWJlbFBvc2l0aW9uT3V0c2lkZTtcbiAgfVxufVxuXG5leHBvcnRzLnNldExhYmVsID0gc2V0TGFiZWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2hlbHBlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgdmVjdG9yID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3N5bWJvbFwiKTtcblxudmFyIExpbmVQYXRoID0gcmVxdWlyZShcIi4vTGluZVBhdGhcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIF9udW1iZXIgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciByb3VuZCA9IF9udW1iZXIucm91bmQ7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NoYXJ0L2hlbHBlci9MaW5lXG4gKi9cbnZhciBTWU1CT0xfQ0FURUdPUklFUyA9IFsnZnJvbVN5bWJvbCcsICd0b1N5bWJvbCddO1xuXG5mdW5jdGlvbiBtYWtlU3ltYm9sVHlwZUtleShzeW1ib2xDYXRlZ29yeSkge1xuICByZXR1cm4gJ18nICsgc3ltYm9sQ2F0ZWdvcnkgKyAnVHlwZSc7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU3ltYm9sKG5hbWUsIGxpbmVEYXRhLCBpZHgpIHtcbiAgdmFyIGNvbG9yID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuICB2YXIgc3ltYm9sVHlwZSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBuYW1lKTtcbiAgdmFyIHN5bWJvbFNpemUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgbmFtZSArICdTaXplJyk7XG5cbiAgaWYgKCFzeW1ib2xUeXBlIHx8IHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghenJVdGlsLmlzQXJyYXkoc3ltYm9sU2l6ZSkpIHtcbiAgICBzeW1ib2xTaXplID0gW3N5bWJvbFNpemUsIHN5bWJvbFNpemVdO1xuICB9XG5cbiAgdmFyIHN5bWJvbFBhdGggPSBzeW1ib2xVdGlsLmNyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCAtc3ltYm9sU2l6ZVswXSAvIDIsIC1zeW1ib2xTaXplWzFdIC8gMiwgc3ltYm9sU2l6ZVswXSwgc3ltYm9sU2l6ZVsxXSwgY29sb3IpO1xuICBzeW1ib2xQYXRoLm5hbWUgPSBuYW1lO1xuICByZXR1cm4gc3ltYm9sUGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGluZShwb2ludHMpIHtcbiAgdmFyIGxpbmUgPSBuZXcgTGluZVBhdGgoe1xuICAgIG5hbWU6ICdsaW5lJ1xuICB9KTtcbiAgc2V0TGluZVBvaW50cyhsaW5lLnNoYXBlLCBwb2ludHMpO1xuICByZXR1cm4gbGluZTtcbn1cblxuZnVuY3Rpb24gc2V0TGluZVBvaW50cyh0YXJnZXRTaGFwZSwgcG9pbnRzKSB7XG4gIHZhciBwMSA9IHBvaW50c1swXTtcbiAgdmFyIHAyID0gcG9pbnRzWzFdO1xuICB2YXIgY3AxID0gcG9pbnRzWzJdO1xuICB0YXJnZXRTaGFwZS54MSA9IHAxWzBdO1xuICB0YXJnZXRTaGFwZS55MSA9IHAxWzFdO1xuICB0YXJnZXRTaGFwZS54MiA9IHAyWzBdO1xuICB0YXJnZXRTaGFwZS55MiA9IHAyWzFdO1xuICB0YXJnZXRTaGFwZS5wZXJjZW50ID0gMTtcblxuICBpZiAoY3AxKSB7XG4gICAgdGFyZ2V0U2hhcGUuY3B4MSA9IGNwMVswXTtcbiAgICB0YXJnZXRTaGFwZS5jcHkxID0gY3AxWzFdO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFNoYXBlLmNweDEgPSBOYU47XG4gICAgdGFyZ2V0U2hhcGUuY3B5MSA9IE5hTjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVTeW1ib2xBbmRMYWJlbEJlZm9yZUxpbmVVcGRhdGUoKSB7XG4gIHZhciBsaW5lR3JvdXAgPSB0aGlzO1xuICB2YXIgc3ltYm9sRnJvbSA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgnZnJvbVN5bWJvbCcpO1xuICB2YXIgc3ltYm9sVG8gPSBsaW5lR3JvdXAuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XG4gIHZhciBsYWJlbCA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgnbGFiZWwnKTsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKCFzeW1ib2xGcm9tICYmICFzeW1ib2xUbyAmJiBsYWJlbC5pZ25vcmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW52U2NhbGUgPSAxO1xuICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuc2NhbGUpIHtcbiAgICAgIGludlNjYWxlIC89IHBhcmVudE5vZGUuc2NhbGVbMF07XG4gICAgfVxuXG4gICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50O1xuICB9XG5cbiAgdmFyIGxpbmUgPSBsaW5lR3JvdXAuY2hpbGRPZk5hbWUoJ2xpbmUnKTsgLy8gSWYgbGluZSBub3QgY2hhbmdlZFxuICAvLyBGSVhNRSBQYXJlbnQgc2NhbGUgY2hhbmdlZFxuXG4gIGlmICghdGhpcy5fX2RpcnR5ICYmICFsaW5lLl9fZGlydHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGVyY2VudCA9IGxpbmUuc2hhcGUucGVyY2VudDtcbiAgdmFyIGZyb21Qb3MgPSBsaW5lLnBvaW50QXQoMCk7XG4gIHZhciB0b1BvcyA9IGxpbmUucG9pbnRBdChwZXJjZW50KTtcbiAgdmFyIGQgPSB2ZWN0b3Iuc3ViKFtdLCB0b1BvcywgZnJvbVBvcyk7XG4gIHZlY3Rvci5ub3JtYWxpemUoZCwgZCk7XG5cbiAgaWYgKHN5bWJvbEZyb20pIHtcbiAgICBzeW1ib2xGcm9tLmF0dHIoJ3Bvc2l0aW9uJywgZnJvbVBvcyk7XG4gICAgdmFyIHRhbmdlbnQgPSBsaW5lLnRhbmdlbnRBdCgwKTtcbiAgICBzeW1ib2xGcm9tLmF0dHIoJ3JvdGF0aW9uJywgTWF0aC5QSSAvIDIgLSBNYXRoLmF0YW4yKHRhbmdlbnRbMV0sIHRhbmdlbnRbMF0pKTtcbiAgICBzeW1ib2xGcm9tLmF0dHIoJ3NjYWxlJywgW2ludlNjYWxlICogcGVyY2VudCwgaW52U2NhbGUgKiBwZXJjZW50XSk7XG4gIH1cblxuICBpZiAoc3ltYm9sVG8pIHtcbiAgICBzeW1ib2xUby5hdHRyKCdwb3NpdGlvbicsIHRvUG9zKTtcbiAgICB2YXIgdGFuZ2VudCA9IGxpbmUudGFuZ2VudEF0KDEpO1xuICAgIHN5bWJvbFRvLmF0dHIoJ3JvdGF0aW9uJywgLU1hdGguUEkgLyAyIC0gTWF0aC5hdGFuMih0YW5nZW50WzFdLCB0YW5nZW50WzBdKSk7XG4gICAgc3ltYm9sVG8uYXR0cignc2NhbGUnLCBbaW52U2NhbGUgKiBwZXJjZW50LCBpbnZTY2FsZSAqIHBlcmNlbnRdKTtcbiAgfVxuXG4gIGlmICghbGFiZWwuaWdub3JlKSB7XG4gICAgbGFiZWwuYXR0cigncG9zaXRpb24nLCB0b1Bvcyk7XG4gICAgdmFyIHRleHRQb3NpdGlvbjtcbiAgICB2YXIgdGV4dEFsaWduO1xuICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbjtcbiAgICB2YXIgZGlzdGFuY2UgPSA1ICogaW52U2NhbGU7IC8vIEVuZFxuXG4gICAgaWYgKGxhYmVsLl9fcG9zaXRpb24gPT09ICdlbmQnKSB7XG4gICAgICB0ZXh0UG9zaXRpb24gPSBbZFswXSAqIGRpc3RhbmNlICsgdG9Qb3NbMF0sIGRbMV0gKiBkaXN0YW5jZSArIHRvUG9zWzFdXTtcbiAgICAgIHRleHRBbGlnbiA9IGRbMF0gPiAwLjggPyAnbGVmdCcgOiBkWzBdIDwgLTAuOCA/ICdyaWdodCcgOiAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gZFsxXSA+IDAuOCA/ICd0b3AnIDogZFsxXSA8IC0wLjggPyAnYm90dG9tJyA6ICdtaWRkbGUnO1xuICAgIH0gLy8gTWlkZGxlXG4gICAgZWxzZSBpZiAobGFiZWwuX19wb3NpdGlvbiA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgdmFyIGhhbGZQZXJjZW50ID0gcGVyY2VudCAvIDI7XG4gICAgICAgIHZhciB0YW5nZW50ID0gbGluZS50YW5nZW50QXQoaGFsZlBlcmNlbnQpO1xuICAgICAgICB2YXIgbiA9IFt0YW5nZW50WzFdLCAtdGFuZ2VudFswXV07XG4gICAgICAgIHZhciBjcCA9IGxpbmUucG9pbnRBdChoYWxmUGVyY2VudCk7XG5cbiAgICAgICAgaWYgKG5bMV0gPiAwKSB7XG4gICAgICAgICAgblswXSA9IC1uWzBdO1xuICAgICAgICAgIG5bMV0gPSAtblsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHRQb3NpdGlvbiA9IFtjcFswXSArIG5bMF0gKiBkaXN0YW5jZSwgY3BbMV0gKyBuWzFdICogZGlzdGFuY2VdO1xuICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gLU1hdGguYXRhbjIodGFuZ2VudFsxXSwgdGFuZ2VudFswXSk7XG5cbiAgICAgICAgaWYgKHRvUG9zWzBdIDwgZnJvbVBvc1swXSkge1xuICAgICAgICAgIHJvdGF0aW9uID0gTWF0aC5QSSArIHJvdGF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuYXR0cigncm90YXRpb24nLCByb3RhdGlvbik7XG4gICAgICB9IC8vIFN0YXJ0XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB0ZXh0UG9zaXRpb24gPSBbLWRbMF0gKiBkaXN0YW5jZSArIGZyb21Qb3NbMF0sIC1kWzFdICogZGlzdGFuY2UgKyBmcm9tUG9zWzFdXTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSBkWzBdID4gMC44ID8gJ3JpZ2h0JyA6IGRbMF0gPCAtMC44ID8gJ2xlZnQnIDogJ2NlbnRlcic7XG4gICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBkWzFdID4gMC44ID8gJ2JvdHRvbScgOiBkWzFdIDwgLTAuOCA/ICd0b3AnIDogJ21pZGRsZSc7XG4gICAgICAgIH1cblxuICAgIGxhYmVsLmF0dHIoe1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLy8gVXNlIHRoZSB1c2VyIHNwZWNpZmllZCB0ZXh0IGFsaWduIGFuZCBiYXNlbGluZSBmaXJzdFxuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWwuX192ZXJ0aWNhbEFsaWduIHx8IHRleHRWZXJ0aWNhbEFsaWduLFxuICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLl9fdGV4dEFsaWduIHx8IHRleHRBbGlnblxuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uOiB0ZXh0UG9zaXRpb24sXG4gICAgICBzY2FsZTogW2ludlNjYWxlLCBpbnZTY2FsZV1cbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwfVxuICogQGFsaWFzIHttb2R1bGU6ZWNoYXJ0cy9jaGFydC9oZWxwZXIvTGluZX1cbiAqL1xuXG5cbmZ1bmN0aW9uIExpbmUobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuX2NyZWF0ZUxpbmUobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xufVxuXG52YXIgbGluZVByb3RvID0gTGluZS5wcm90b3R5cGU7IC8vIFVwZGF0ZSBzeW1ib2wgcG9zaXRpb24gYW5kIHJvdGF0aW9uXG5cbmxpbmVQcm90by5iZWZvcmVVcGRhdGUgPSB1cGRhdGVTeW1ib2xBbmRMYWJlbEJlZm9yZUxpbmVVcGRhdGU7XG5cbmxpbmVQcm90by5fY3JlYXRlTGluZSA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICB2YXIgc2VyaWVzTW9kZWwgPSBsaW5lRGF0YS5ob3N0TW9kZWw7XG4gIHZhciBsaW5lUG9pbnRzID0gbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICB2YXIgbGluZSA9IGNyZWF0ZUxpbmUobGluZVBvaW50cyk7XG4gIGxpbmUuc2hhcGUucGVyY2VudCA9IDA7XG4gIGdyYXBoaWMuaW5pdFByb3BzKGxpbmUsIHtcbiAgICBzaGFwZToge1xuICAgICAgcGVyY2VudDogMVxuICAgIH1cbiAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gIHRoaXMuYWRkKGxpbmUpO1xuICB2YXIgbGFiZWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICBuYW1lOiAnbGFiZWwnXG4gIH0pO1xuICB0aGlzLmFkZChsYWJlbCk7XG4gIHpyVXRpbC5lYWNoKFNZTUJPTF9DQVRFR09SSUVTLCBmdW5jdGlvbiAoc3ltYm9sQ2F0ZWdvcnkpIHtcbiAgICB2YXIgc3ltYm9sID0gY3JlYXRlU3ltYm9sKHN5bWJvbENhdGVnb3J5LCBsaW5lRGF0YSwgaWR4KTsgLy8gc3ltYm9scyBtdXN0IGFkZGVkIGFmdGVyIGxpbmUgdG8gbWFrZSBzdXJlXG4gICAgLy8gaXQgd2lsbCBiZSB1cGRhdGVkIGFmdGVyIGxpbmUjdXBkYXRlLlxuICAgIC8vIE9yIHN5bWJvbCBwb3NpdGlvbiBhbmQgcm90YXRpb24gdXBkYXRlIGluIGxpbmUjYmVmb3JlVXBkYXRlIHdpbGwgYmUgb25lIGZyYW1lIHNsb3dcblxuICAgIHRoaXMuYWRkKHN5bWJvbCk7XG4gICAgdGhpc1ttYWtlU3ltYm9sVHlwZUtleShzeW1ib2xDYXRlZ29yeSldID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsIHN5bWJvbENhdGVnb3J5KTtcbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5fdXBkYXRlQ29tbW9uU3RsKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbn07XG5cbmxpbmVQcm90by51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGxpbmVEYXRhLmhvc3RNb2RlbDtcbiAgdmFyIGxpbmUgPSB0aGlzLmNoaWxkT2ZOYW1lKCdsaW5lJyk7XG4gIHZhciBsaW5lUG9pbnRzID0gbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICB2YXIgdGFyZ2V0ID0ge1xuICAgIHNoYXBlOiB7fVxuICB9O1xuICBzZXRMaW5lUG9pbnRzKHRhcmdldC5zaGFwZSwgbGluZVBvaW50cyk7XG4gIGdyYXBoaWMudXBkYXRlUHJvcHMobGluZSwgdGFyZ2V0LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgenJVdGlsLmVhY2goU1lNQk9MX0NBVEVHT1JJRVMsIGZ1bmN0aW9uIChzeW1ib2xDYXRlZ29yeSkge1xuICAgIHZhciBzeW1ib2xUeXBlID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsIHN5bWJvbENhdGVnb3J5KTtcbiAgICB2YXIga2V5ID0gbWFrZVN5bWJvbFR5cGVLZXkoc3ltYm9sQ2F0ZWdvcnkpOyAvLyBTeW1ib2wgY2hhbmdlZFxuXG4gICAgaWYgKHRoaXNba2V5XSAhPT0gc3ltYm9sVHlwZSkge1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5jaGlsZE9mTmFtZShzeW1ib2xDYXRlZ29yeSkpO1xuICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZVN5bWJvbChzeW1ib2xDYXRlZ29yeSwgbGluZURhdGEsIGlkeCk7XG4gICAgICB0aGlzLmFkZChzeW1ib2wpO1xuICAgIH1cblxuICAgIHRoaXNba2V5XSA9IHN5bWJvbFR5cGU7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX3VwZGF0ZUNvbW1vblN0bChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG59O1xuXG5saW5lUHJvdG8uX3VwZGF0ZUNvbW1vblN0bCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICB2YXIgc2VyaWVzTW9kZWwgPSBsaW5lRGF0YS5ob3N0TW9kZWw7XG4gIHZhciBsaW5lID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZScpO1xuICB2YXIgbGluZVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUubGluZVN0eWxlO1xuICB2YXIgaG92ZXJMaW5lU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5ob3ZlckxpbmVTdHlsZTtcbiAgdmFyIGxhYmVsTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5sYWJlbE1vZGVsO1xuICB2YXIgaG92ZXJMYWJlbE1vZGVsID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaG92ZXJMYWJlbE1vZGVsOyAvLyBPcHRpbWl6YXRpb24gZm9yIGxhcmdlIGRhdGFzZXRcblxuICBpZiAoIXNlcmllc1Njb3BlIHx8IGxpbmVEYXRhLmhhc0l0ZW1PcHRpb24pIHtcbiAgICB2YXIgaXRlbU1vZGVsID0gbGluZURhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgbGluZVN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUubm9ybWFsJykuZ2V0TGluZVN0eWxlKCk7XG4gICAgaG92ZXJMaW5lU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5lbXBoYXNpcycpLmdldExpbmVTdHlsZSgpO1xuICAgIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLm5vcm1hbCcpO1xuICAgIGhvdmVyTGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKTtcbiAgfVxuXG4gIHZhciB2aXN1YWxDb2xvciA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTtcbiAgdmFyIHZpc3VhbE9wYWNpdHkgPSB6clV0aWwucmV0cmlldmUzKGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnb3BhY2l0eScpLCBsaW5lU3R5bGUub3BhY2l0eSwgMSk7XG4gIGxpbmUudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKHtcbiAgICBzdHJva2VOb1NjYWxlOiB0cnVlLFxuICAgIGZpbGw6ICdub25lJyxcbiAgICBzdHJva2U6IHZpc3VhbENvbG9yLFxuICAgIG9wYWNpdHk6IHZpc3VhbE9wYWNpdHlcbiAgfSwgbGluZVN0eWxlKSk7XG4gIGxpbmUuaG92ZXJTdHlsZSA9IGhvdmVyTGluZVN0eWxlOyAvLyBVcGRhdGUgc3ltYm9sXG5cbiAgenJVdGlsLmVhY2goU1lNQk9MX0NBVEVHT1JJRVMsIGZ1bmN0aW9uIChzeW1ib2xDYXRlZ29yeSkge1xuICAgIHZhciBzeW1ib2wgPSB0aGlzLmNoaWxkT2ZOYW1lKHN5bWJvbENhdGVnb3J5KTtcblxuICAgIGlmIChzeW1ib2wpIHtcbiAgICAgIHN5bWJvbC5zZXRDb2xvcih2aXN1YWxDb2xvcik7XG4gICAgICBzeW1ib2wuc2V0U3R5bGUoe1xuICAgICAgICBvcGFjaXR5OiB2aXN1YWxPcGFjaXR5XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuICB2YXIgc2hvd0xhYmVsID0gbGFiZWxNb2RlbC5nZXRTaGFsbG93KCdzaG93Jyk7XG4gIHZhciBob3ZlclNob3dMYWJlbCA9IGhvdmVyTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdzaG93Jyk7XG4gIHZhciBsYWJlbCA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xhYmVsJyk7XG4gIHZhciBkZWZhdWx0TGFiZWxDb2xvcjtcbiAgdmFyIGRlZmF1bHRUZXh0O1xuICB2YXIgbm9ybWFsVGV4dDtcbiAgdmFyIGVtcGhhc2lzVGV4dDtcblxuICBpZiAoc2hvd0xhYmVsIHx8IGhvdmVyU2hvd0xhYmVsKSB7XG4gICAgdmFyIHJhd1ZhbCA9IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGlkeCk7XG4gICAgZGVmYXVsdFRleHQgPSByYXdWYWwgPT0gbnVsbCA/IGRlZmF1bHRUZXh0ID0gbGluZURhdGEuZ2V0TmFtZShpZHgpIDogaXNGaW5pdGUocmF3VmFsKSA/IHJvdW5kKHJhd1ZhbCkgOiByYXdWYWw7XG4gICAgZGVmYXVsdExhYmVsQ29sb3IgPSB2aXN1YWxDb2xvciB8fCAnIzAwMCc7XG4gICAgbm9ybWFsVGV4dCA9IHpyVXRpbC5yZXRyaWV2ZTIoc2VyaWVzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoaWR4LCAnbm9ybWFsJywgbGluZURhdGEuZGF0YVR5cGUpLCBkZWZhdWx0VGV4dCk7XG4gICAgZW1waGFzaXNUZXh0ID0genJVdGlsLnJldHJpZXZlMihzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdlbXBoYXNpcycsIGxpbmVEYXRhLmRhdGFUeXBlKSwgbm9ybWFsVGV4dCk7XG4gIH0gLy8gbGFiZWwuYWZ0ZXJVcGRhdGUgPSBsaW5lQWZ0ZXJVcGRhdGU7XG5cblxuICBpZiAoc2hvd0xhYmVsKSB7XG4gICAgdmFyIGxhYmVsU3R5bGUgPSBncmFwaGljLnNldFRleHRTdHlsZShsYWJlbC5zdHlsZSwgbGFiZWxNb2RlbCwge1xuICAgICAgdGV4dDogbm9ybWFsVGV4dFxuICAgIH0sIHtcbiAgICAgIGF1dG9Db2xvcjogZGVmYXVsdExhYmVsQ29sb3JcbiAgICB9KTtcbiAgICBsYWJlbC5fX3RleHRBbGlnbiA9IGxhYmVsU3R5bGUudGV4dEFsaWduO1xuICAgIGxhYmVsLl9fdmVydGljYWxBbGlnbiA9IGxhYmVsU3R5bGUudGV4dFZlcnRpY2FsQWxpZ247IC8vICdzdGFydCcsICdtaWRkbGUnLCAnZW5kJ1xuXG4gICAgbGFiZWwuX19wb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpIHx8ICdtaWRkbGUnO1xuICB9IGVsc2Uge1xuICAgIGxhYmVsLnNldFN0eWxlKCd0ZXh0JywgbnVsbCk7XG4gIH1cblxuICBpZiAoaG92ZXJTaG93TGFiZWwpIHtcbiAgICAvLyBPbmx5IHRoZXNlIHByb3BlcnRpZXMgc3VwcG9ydGVkIGluIHRoaXMgZW1waGFzaXMgc3R5bGUgaGVyZS5cbiAgICBsYWJlbC5ob3ZlclN0eWxlID0ge1xuICAgICAgdGV4dDogZW1waGFzaXNUZXh0LFxuICAgICAgdGV4dEZpbGw6IGhvdmVyTGFiZWxNb2RlbC5nZXRUZXh0Q29sb3IodHJ1ZSksXG4gICAgICAvLyBGb3IgbWVyZ2luZyBob3ZlciBzdHlsZSB0byBub3JtYWwgc3R5bGUsIGRvIG5vdCB1c2VcbiAgICAgIC8vIGBob3ZlckxhYmVsTW9kZWwuZ2V0Rm9udCgpYCBoZXJlLlxuICAgICAgZm9udFN0eWxlOiBob3ZlckxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZm9udFN0eWxlJyksXG4gICAgICBmb250V2VpZ2h0OiBob3ZlckxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZm9udFdlaWdodCcpLFxuICAgICAgZm9udFNpemU6IGhvdmVyTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdmb250U2l6ZScpLFxuICAgICAgZm9udEZhbWlseTogaG92ZXJMYWJlbE1vZGVsLmdldFNoYWxsb3coJ2ZvbnRGYW1pbHknKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbGFiZWwuaG92ZXJTdHlsZSA9IHtcbiAgICAgIHRleHQ6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgbGFiZWwuaWdub3JlID0gIXNob3dMYWJlbCAmJiAhaG92ZXJTaG93TGFiZWw7XG4gIGdyYXBoaWMuc2V0SG92ZXJTdHlsZSh0aGlzKTtcbn07XG5cbmxpbmVQcm90by5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudHJpZ2dlcignZW1waGFzaXMnKTtcbn07XG5cbmxpbmVQcm90by5kb3ducGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50cmlnZ2VyKCdub3JtYWwnKTtcbn07XG5cbmxpbmVQcm90by51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCkge1xuICB0aGlzLnNldExpbmVQb2ludHMobGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpKTtcbn07XG5cbmxpbmVQcm90by5zZXRMaW5lUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50cykge1xuICB2YXIgbGluZVBhdGggPSB0aGlzLmNoaWxkT2ZOYW1lKCdsaW5lJyk7XG4gIHNldExpbmVQb2ludHMobGluZVBhdGguc2hhcGUsIHBvaW50cyk7XG4gIGxpbmVQYXRoLmRpcnR5KCk7XG59O1xuXG56clV0aWwuaW5oZXJpdHMoTGluZSwgZ3JhcGhpYy5Hcm91cCk7XG52YXIgX2RlZmF1bHQgPSBMaW5lO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xpbmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBMaW5lR3JvdXAgPSByZXF1aXJlKFwiLi9MaW5lXCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvTGluZURyYXdcbiAqL1xuZnVuY3Rpb24gaXNQb2ludE5hTihwdCkge1xuICByZXR1cm4gaXNOYU4ocHRbMF0pIHx8IGlzTmFOKHB0WzFdKTtcbn1cblxuZnVuY3Rpb24gbGluZU5lZWRzRHJhdyhwdHMpIHtcbiAgcmV0dXJuICFpc1BvaW50TmFOKHB0c1swXSkgJiYgIWlzUG9pbnROYU4ocHRzWzFdKTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9tYXJrZXIvTGluZURyYXdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxuZnVuY3Rpb24gTGluZURyYXcoY3Rvcikge1xuICB0aGlzLl9jdG9yID0gY3RvciB8fCBMaW5lR3JvdXA7XG4gIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xufVxuXG52YXIgbGluZURyYXdQcm90byA9IExpbmVEcmF3LnByb3RvdHlwZTtcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGxpbmVEYXRhXG4gKi9cblxubGluZURyYXdQcm90by51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGxpbmVEYXRhKSB7XG4gIHZhciBvbGRMaW5lRGF0YSA9IHRoaXMuX2xpbmVEYXRhO1xuICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICB2YXIgTGluZUN0b3IgPSB0aGlzLl9jdG9yO1xuICB2YXIgaG9zdE1vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICB2YXIgc2VyaWVzU2NvcGUgPSB7XG4gICAgbGluZVN0eWxlOiBob3N0TW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5ub3JtYWwnKS5nZXRMaW5lU3R5bGUoKSxcbiAgICBob3ZlckxpbmVTdHlsZTogaG9zdE1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUuZW1waGFzaXMnKS5nZXRMaW5lU3R5bGUoKSxcbiAgICBsYWJlbE1vZGVsOiBob3N0TW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLm5vcm1hbCcpLFxuICAgIGhvdmVyTGFiZWxNb2RlbDogaG9zdE1vZGVsLmdldE1vZGVsKCdsYWJlbC5lbXBoYXNpcycpXG4gIH07XG4gIGxpbmVEYXRhLmRpZmYob2xkTGluZURhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgaWYgKCFsaW5lTmVlZHNEcmF3KGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGluZUdyb3VwID0gbmV3IExpbmVDdG9yKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgICBsaW5lRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgbGluZUdyb3VwKTtcbiAgICBncm91cC5hZGQobGluZUdyb3VwKTtcbiAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgIHZhciBsaW5lR3JvdXAgPSBvbGRMaW5lRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG5cbiAgICBpZiAoIWxpbmVOZWVkc0RyYXcobGluZURhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpKSkge1xuICAgICAgZ3JvdXAucmVtb3ZlKGxpbmVHcm91cCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFsaW5lR3JvdXApIHtcbiAgICAgIGxpbmVHcm91cCA9IG5ldyBMaW5lQ3RvcihsaW5lRGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVHcm91cC51cGRhdGVEYXRhKGxpbmVEYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlKTtcbiAgICB9XG5cbiAgICBsaW5lRGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgbGluZUdyb3VwKTtcbiAgICBncm91cC5hZGQobGluZUdyb3VwKTtcbiAgfSkucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICBncm91cC5yZW1vdmUob2xkTGluZURhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpKTtcbiAgfSkuZXhlY3V0ZSgpO1xuICB0aGlzLl9saW5lRGF0YSA9IGxpbmVEYXRhO1xufTtcblxubGluZURyYXdQcm90by51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lRGF0YSA9IHRoaXMuX2xpbmVEYXRhO1xuICBsaW5lRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgIGVsLnVwZGF0ZUxheW91dChsaW5lRGF0YSwgaWR4KTtcbiAgfSwgdGhpcyk7XG59O1xuXG5saW5lRHJhd1Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IExpbmVEcmF3O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZURyYXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9MaW5lRHJhdy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS92ZWN0b3JcIik7XG5cbi8qKlxuICogTGluZSBwYXRoIGZvciBiZXppZXIgYW5kIHN0cmFpZ2h0IGxpbmUgZHJhd1xuICovXG52YXIgc3RyYWlnaHRMaW5lUHJvdG8gPSBncmFwaGljLkxpbmUucHJvdG90eXBlO1xudmFyIGJlemllckN1cnZlUHJvdG8gPSBncmFwaGljLkJlemllckN1cnZlLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gaXNMaW5lKHNoYXBlKSB7XG4gIHJldHVybiBpc05hTigrc2hhcGUuY3B4MSkgfHwgaXNOYU4oK3NoYXBlLmNweTEpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgdHlwZTogJ2VjLWxpbmUnLFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgc2hhcGU6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB4MjogMCxcbiAgICB5MjogMCxcbiAgICBwZXJjZW50OiAxLFxuICAgIGNweDE6IG51bGwsXG4gICAgY3B5MTogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgKGlzTGluZShzaGFwZSkgPyBzdHJhaWdodExpbmVQcm90byA6IGJlemllckN1cnZlUHJvdG8pLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgfSxcbiAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gaXNMaW5lKHRoaXMuc2hhcGUpID8gc3RyYWlnaHRMaW5lUHJvdG8ucG9pbnRBdC5jYWxsKHRoaXMsIHQpIDogYmV6aWVyQ3VydmVQcm90by5wb2ludEF0LmNhbGwodGhpcywgdCk7XG4gIH0sXG4gIHRhbmdlbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgIHZhciBwID0gaXNMaW5lKHNoYXBlKSA/IFtzaGFwZS54MiAtIHNoYXBlLngxLCBzaGFwZS55MiAtIHNoYXBlLnkxXSA6IGJlemllckN1cnZlUHJvdG8udGFuZ2VudEF0LmNhbGwodGhpcywgdCk7XG4gICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZVBhdGguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9MaW5lUGF0aC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3N5bWJvbFwiKTtcblxudmFyIGNyZWF0ZVN5bWJvbCA9IF9zeW1ib2wuY3JlYXRlU3ltYm9sO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBfbnVtYmVyID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgcGFyc2VQZXJjZW50ID0gX251bWJlci5wYXJzZVBlcmNlbnQ7XG5cbnZhciBfbGFiZWxIZWxwZXIgPSByZXF1aXJlKFwiLi9sYWJlbEhlbHBlclwiKTtcblxudmFyIGZpbmRMYWJlbFZhbHVlRGltID0gX2xhYmVsSGVscGVyLmZpbmRMYWJlbFZhbHVlRGltO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sXG4gKi9cbmZ1bmN0aW9uIGdldFN5bWJvbFNpemUoZGF0YSwgaWR4KSB7XG4gIHZhciBzeW1ib2xTaXplID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKTtcbiAgcmV0dXJuIHN5bWJvbFNpemUgaW5zdGFuY2VvZiBBcnJheSA/IHN5bWJvbFNpemUuc2xpY2UoKSA6IFsrc3ltYm9sU2l6ZSwgK3N5bWJvbFNpemVdO1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShzeW1ib2xTaXplKSB7XG4gIHJldHVybiBbc3ltYm9sU2l6ZVswXSAvIDIsIHN5bWJvbFNpemVbMV0gLyAyXTtcbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMge21vZHVsZTplY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2x9XG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gKi9cblxuXG5mdW5jdGlvbiBTeW1ib2xDbHooZGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICBncmFwaGljLkdyb3VwLmNhbGwodGhpcyk7XG4gIHRoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbn1cblxudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sQ2x6LnByb3RvdHlwZTtcblxuZnVuY3Rpb24gZHJpZnRTeW1ib2woZHgsIGR5KSB7XG4gIHRoaXMucGFyZW50LmRyaWZ0KGR4LCBkeSk7XG59XG5cbnN5bWJvbFByb3RvLl9jcmVhdGVTeW1ib2wgPSBmdW5jdGlvbiAoc3ltYm9sVHlwZSwgZGF0YSwgaWR4LCBzeW1ib2xTaXplKSB7XG4gIC8vIFJlbW92ZSBwYXRocyBjcmVhdGVkIGJlZm9yZVxuICB0aGlzLnJlbW92ZUFsbCgpO1xuICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTsgLy8gdmFyIHN5bWJvbFBhdGggPSBjcmVhdGVTeW1ib2woXG4gIC8vICAgICBzeW1ib2xUeXBlLCAtMC41LCAtMC41LCAxLCAxLCBjb2xvclxuICAvLyApO1xuICAvLyBJZiB3aWR0aC9oZWlnaHQgYXJlIHNldCB0b28gc21hbGwgKGUuZy4sIHNldCB0byAxKSBvbiBpb3MxMFxuICAvLyBhbmQgbWFjT1MgU2llcnJhLCBhIGNpcmNsZSBzdHJva2UgYmVjb21lIGEgcmVjdCwgbm8gbWF0dGVyIHdoYXRcbiAgLy8gdGhlIHNjYWxlIGlzIHNldC4gU28gd2Ugc2V0IHdpZHRoL2hlaWdodCBhcyAyLiBTZWUgIzQxNTAuXG5cbiAgdmFyIHN5bWJvbFBhdGggPSBjcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgLTEsIC0xLCAyLCAyLCBjb2xvcik7XG4gIHN5bWJvbFBhdGguYXR0cih7XG4gICAgejI6IDEwMCxcbiAgICBjdWxsaW5nOiB0cnVlLFxuICAgIHNjYWxlOiBnZXRTY2FsZShzeW1ib2xTaXplKVxuICB9KTsgLy8gUmV3cml0ZSBkcmlmdCBtZXRob2RcblxuICBzeW1ib2xQYXRoLmRyaWZ0ID0gZHJpZnRTeW1ib2w7XG4gIHRoaXMuX3N5bWJvbFR5cGUgPSBzeW1ib2xUeXBlO1xuICB0aGlzLmFkZChzeW1ib2xQYXRoKTtcbn07XG4vKipcbiAqIFN0b3AgYW5pbWF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRvTGFzdEZyYW1lXG4gKi9cblxuXG5zeW1ib2xQcm90by5zdG9wU3ltYm9sQW5pbWF0aW9uID0gZnVuY3Rpb24gKHRvTGFzdEZyYW1lKSB7XG4gIHRoaXMuY2hpbGRBdCgwKS5zdG9wQW5pbWF0aW9uKHRvTGFzdEZyYW1lKTtcbn07XG4vKipcbiAqIEZJWE1FOlxuICogQ2F1dGlvbjogVGhpcyBtZXRob2QgYnJlYWtzIHRoZSBlbmNhcHN1bGF0aW9uIG9mIHRoaXMgbW9kdWxlLFxuICogYnV0IGl0IGluZGVlZCBicmluZ3MgY29udmVuaWVuY2UuIFNvIGRvIG5vdCB1c2UgdGhlIG1ldGhvZFxuICogdW5sZXNzIHlvdSBkZXRhaWxlZGx5IGtub3cgYWxsIHRoZSBpbXBsZW1lbnRzIG9mIGBTeW1ib2xgLFxuICogZXNwZWNpYWxseSBhbmltYXRpb24uXG4gKlxuICogR2V0IHN5bWJvbCBwYXRoIGVsZW1lbnQuXG4gKi9cblxuXG5zeW1ib2xQcm90by5nZXRTeW1ib2xQYXRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jaGlsZEF0KDApO1xufTtcbi8qKlxuICogR2V0IHNjYWxlKGFrYSwgY3VycmVudCBzeW1ib2wgc2l6ZSkuXG4gKiBJbmNsdWRpbmcgdGhlIGNoYW5nZSBjYXVzZWQgYnkgYW5pbWF0aW9uXG4gKi9cblxuXG5zeW1ib2xQcm90by5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2hpbGRBdCgwKS5zY2FsZTtcbn07XG4vKipcbiAqIEhpZ2hsaWdodCBzeW1ib2xcbiAqL1xuXG5cbnN5bWJvbFByb3RvLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaGlsZEF0KDApLnRyaWdnZXIoJ2VtcGhhc2lzJyk7XG59O1xuLyoqXG4gKiBEb3ducGxheSBzeW1ib2xcbiAqL1xuXG5cbnN5bWJvbFByb3RvLmRvd25wbGF5ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNoaWxkQXQoMCkudHJpZ2dlcignbm9ybWFsJyk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gKiBAcGFyYW0ge251bWJlcn0gelxuICovXG5cblxuc3ltYm9sUHJvdG8uc2V0WiA9IGZ1bmN0aW9uICh6bGV2ZWwsIHopIHtcbiAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gIHN5bWJvbFBhdGguemxldmVsID0gemxldmVsO1xuICBzeW1ib2xQYXRoLnogPSB6O1xufTtcblxuc3ltYm9sUHJvdG8uc2V0RHJhZ2dhYmxlID0gZnVuY3Rpb24gKGRyYWdnYWJsZSkge1xuICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgc3ltYm9sUGF0aC5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gIHN5bWJvbFBhdGguY3Vyc29yID0gZHJhZ2dhYmxlID8gJ21vdmUnIDogJ3BvaW50ZXInO1xufTtcbi8qKlxuICogVXBkYXRlIHN5bWJvbCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtPYmplY3R9IFtzZXJpZXNTY29wZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGUuaXRlbVN0eWxlXVxuICogQHBhcmFtIHtPYmplY3R9IFtzZXJpZXNTY29wZS5ob3Zlckl0ZW1TdHlsZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGUuc3ltYm9sUm90YXRlXVxuICogQHBhcmFtIHtPYmplY3R9IFtzZXJpZXNTY29wZS5zeW1ib2xPZmZzZXRdXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbc2VyaWVzU2NvcGUubGFiZWxNb2RlbF1cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtzZXJpZXNTY29wZS5ob3ZlckxhYmVsTW9kZWxdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXJpZXNTY29wZS5ob3ZlckFuaW1hdGlvbl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGUuY3Vyc29yU3R5bGVdXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbc2VyaWVzU2NvcGUuaXRlbU1vZGVsXVxuICogQHBhcmFtIHtzdHJpbmd9IFtzZXJpZXNTY29wZS5zeW1ib2xJbm5lckNvbG9yXVxuICogQHBhcmFtIHtPYmplY3R9IFtzZXJpZXNTY29wZS5mYWRlSW49ZmFsc2VdXG4gKi9cblxuXG5zeW1ib2xQcm90by51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgdGhpcy5zaWxlbnQgPSBmYWxzZTtcbiAgdmFyIHN5bWJvbFR5cGUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJykgfHwgJ2NpcmNsZSc7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICB2YXIgc3ltYm9sU2l6ZSA9IGdldFN5bWJvbFNpemUoZGF0YSwgaWR4KTtcbiAgdmFyIGlzSW5pdCA9IHN5bWJvbFR5cGUgIT09IHRoaXMuX3N5bWJvbFR5cGU7XG5cbiAgaWYgKGlzSW5pdCkge1xuICAgIHRoaXMuX2NyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCBkYXRhLCBpZHgsIHN5bWJvbFNpemUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgIHN5bWJvbFBhdGguc2lsZW50ID0gZmFsc2U7XG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xQYXRoLCB7XG4gICAgICBzY2FsZTogZ2V0U2NhbGUoc3ltYm9sU2l6ZSlcbiAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZUNvbW1vbihkYXRhLCBpZHgsIHN5bWJvbFNpemUsIHNlcmllc1Njb3BlKTtcblxuICBpZiAoaXNJbml0KSB7XG4gICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgdmFyIGZhZGVJbiA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmZhZGVJbjtcbiAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgc2NhbGU6IHN5bWJvbFBhdGguc2NhbGUuc2xpY2UoKVxuICAgIH07XG4gICAgZmFkZUluICYmICh0YXJnZXQuc3R5bGUgPSB7XG4gICAgICBvcGFjaXR5OiBzeW1ib2xQYXRoLnN0eWxlLm9wYWNpdHlcbiAgICB9KTtcbiAgICBzeW1ib2xQYXRoLnNjYWxlID0gWzAsIDBdO1xuICAgIGZhZGVJbiAmJiAoc3ltYm9sUGF0aC5zdHlsZS5vcGFjaXR5ID0gMCk7XG4gICAgZ3JhcGhpYy5pbml0UHJvcHMoc3ltYm9sUGF0aCwgdGFyZ2V0LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgfVxuXG4gIHRoaXMuX3Nlcmllc01vZGVsID0gc2VyaWVzTW9kZWw7XG59OyAvLyBVcGRhdGUgY29tbW9uIHByb3BlcnRpZXNcblxuXG52YXIgbm9ybWFsU3R5bGVBY2Nlc3NQYXRoID0gWydpdGVtU3R5bGUnLCAnbm9ybWFsJ107XG52YXIgZW1waGFzaXNTdHlsZUFjY2Vzc1BhdGggPSBbJ2l0ZW1TdHlsZScsICdlbXBoYXNpcyddO1xudmFyIG5vcm1hbExhYmVsQWNjZXNzUGF0aCA9IFsnbGFiZWwnLCAnbm9ybWFsJ107XG52YXIgZW1waGFzaXNMYWJlbEFjY2Vzc1BhdGggPSBbJ2xhYmVsJywgJ2VtcGhhc2lzJ107XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBzeW1ib2xTaXplXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlXVxuICovXG5cbnN5bWJvbFByb3RvLl91cGRhdGVDb21tb24gPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBzZXJpZXNTY29wZSkge1xuICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpOyAvLyBSZXNldCBzdHlsZVxuXG4gIGlmIChzeW1ib2xQYXRoLnR5cGUgIT09ICdpbWFnZScpIHtcbiAgICBzeW1ib2xQYXRoLnVzZVN0eWxlKHtcbiAgICAgIHN0cm9rZU5vU2NhbGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBpdGVtU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5pdGVtU3R5bGU7XG4gIHZhciBob3Zlckl0ZW1TdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVySXRlbVN0eWxlO1xuICB2YXIgc3ltYm9sUm90YXRlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuc3ltYm9sUm90YXRlO1xuICB2YXIgc3ltYm9sT2Zmc2V0ID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuc3ltYm9sT2Zmc2V0O1xuICB2YXIgbGFiZWxNb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmxhYmVsTW9kZWw7XG4gIHZhciBob3ZlckxhYmVsTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5ob3ZlckxhYmVsTW9kZWw7XG4gIHZhciBob3ZlckFuaW1hdGlvbiA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVyQW5pbWF0aW9uO1xuICB2YXIgY3Vyc29yU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5jdXJzb3JTdHlsZTtcblxuICBpZiAoIXNlcmllc1Njb3BlIHx8IGRhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgIHZhciBpdGVtTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5pdGVtTW9kZWwgPyBzZXJpZXNTY29wZS5pdGVtTW9kZWwgOiBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpOyAvLyBDb2xvciBtdXN0IGJlIGV4Y2x1ZGVkLlxuICAgIC8vIEJlY2F1c2Ugc3ltYm9sIHByb3ZpZGUgc2V0Q29sb3IgaW5kaXZpZHVhbGx5IHRvIHNldCBmaWxsIGFuZCBzdHJva2VcblxuICAgIGl0ZW1TdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChub3JtYWxTdHlsZUFjY2Vzc1BhdGgpLmdldEl0ZW1TdHlsZShbJ2NvbG9yJ10pO1xuICAgIGhvdmVySXRlbVN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKGVtcGhhc2lzU3R5bGVBY2Nlc3NQYXRoKS5nZXRJdGVtU3R5bGUoKTtcbiAgICBzeW1ib2xSb3RhdGUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sUm90YXRlJyk7XG4gICAgc3ltYm9sT2Zmc2V0ID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbE9mZnNldCcpO1xuICAgIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwobm9ybWFsTGFiZWxBY2Nlc3NQYXRoKTtcbiAgICBob3ZlckxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoZW1waGFzaXNMYWJlbEFjY2Vzc1BhdGgpO1xuICAgIGhvdmVyQW5pbWF0aW9uID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2hvdmVyQW5pbWF0aW9uJyk7XG4gICAgY3Vyc29yU3R5bGUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnY3Vyc29yJyk7XG4gIH0gZWxzZSB7XG4gICAgaG92ZXJJdGVtU3R5bGUgPSB6clV0aWwuZXh0ZW5kKHt9LCBob3Zlckl0ZW1TdHlsZSk7XG4gIH1cblxuICB2YXIgZWxTdHlsZSA9IHN5bWJvbFBhdGguc3R5bGU7XG4gIHN5bWJvbFBhdGguYXR0cigncm90YXRpb24nLCAoc3ltYm9sUm90YXRlIHx8IDApICogTWF0aC5QSSAvIDE4MCB8fCAwKTtcblxuICBpZiAoc3ltYm9sT2Zmc2V0KSB7XG4gICAgc3ltYm9sUGF0aC5hdHRyKCdwb3NpdGlvbicsIFtwYXJzZVBlcmNlbnQoc3ltYm9sT2Zmc2V0WzBdLCBzeW1ib2xTaXplWzBdKSwgcGFyc2VQZXJjZW50KHN5bWJvbE9mZnNldFsxXSwgc3ltYm9sU2l6ZVsxXSldKTtcbiAgfVxuXG4gIGN1cnNvclN0eWxlICYmIHN5bWJvbFBhdGguYXR0cignY3Vyc29yJywgY3Vyc29yU3R5bGUpOyAvLyBQRU5ESU5HIHNldENvbG9yIGJlZm9yZSBzZXRTdHlsZSEhIVxuXG4gIHN5bWJvbFBhdGguc2V0Q29sb3IoY29sb3IsIHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLnN5bWJvbElubmVyQ29sb3IpO1xuICBzeW1ib2xQYXRoLnNldFN0eWxlKGl0ZW1TdHlsZSk7XG4gIHZhciBvcGFjaXR5ID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ29wYWNpdHknKTtcblxuICBpZiAob3BhY2l0eSAhPSBudWxsKSB7XG4gICAgZWxTdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgfVxuXG4gIHZhciB1c2VOYW1lTGFiZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS51c2VOYW1lTGFiZWw7XG4gIHZhciB2YWx1ZURpbSA9ICF1c2VOYW1lTGFiZWwgJiYgZmluZExhYmVsVmFsdWVEaW0oZGF0YSk7XG5cbiAgaWYgKHVzZU5hbWVMYWJlbCB8fCB2YWx1ZURpbSAhPSBudWxsKSB7XG4gICAgZ3JhcGhpYy5zZXRMYWJlbFN0eWxlKGVsU3R5bGUsIGhvdmVySXRlbVN0eWxlLCBsYWJlbE1vZGVsLCBob3ZlckxhYmVsTW9kZWwsIHtcbiAgICAgIGxhYmVsRmV0Y2hlcjogc2VyaWVzTW9kZWwsXG4gICAgICBsYWJlbERhdGFJbmRleDogaWR4LFxuICAgICAgZGVmYXVsdFRleHQ6IHVzZU5hbWVMYWJlbCA/IGRhdGEuZ2V0TmFtZShpZHgpIDogZGF0YS5nZXQodmFsdWVEaW0sIGlkeCksXG4gICAgICBpc1JlY3RUZXh0OiB0cnVlLFxuICAgICAgYXV0b0NvbG9yOiBjb2xvclxuICAgIH0pO1xuICB9XG5cbiAgc3ltYm9sUGF0aC5vZmYoJ21vdXNlb3ZlcicpLm9mZignbW91c2VvdXQnKS5vZmYoJ2VtcGhhc2lzJykub2ZmKCdub3JtYWwnKTtcbiAgc3ltYm9sUGF0aC5ob3ZlclN0eWxlID0gaG92ZXJJdGVtU3R5bGU7IC8vIEZJWE1FXG4gIC8vIERvIG5vdCB1c2Ugc3ltYm9sLnRyaWdnZXIoJ2VtcGhhc2lzJyksIGJ1dCB1c2Ugc3ltYm9sLmhpZ2hsaWdodCgpIGluc3RlYWQuXG5cbiAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHN5bWJvbFBhdGgpO1xuICB2YXIgc2NhbGUgPSBnZXRTY2FsZShzeW1ib2xTaXplKTtcblxuICBpZiAoaG92ZXJBbmltYXRpb24gJiYgc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCkpIHtcbiAgICB2YXIgb25FbXBoYXNpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByYXRpbyA9IHNjYWxlWzFdIC8gc2NhbGVbMF07XG4gICAgICB0aGlzLmFuaW1hdGVUbyh7XG4gICAgICAgIHNjYWxlOiBbTWF0aC5tYXgoc2NhbGVbMF0gKiAxLjEsIHNjYWxlWzBdICsgMyksIE1hdGgubWF4KHNjYWxlWzFdICogMS4xLCBzY2FsZVsxXSArIDMgKiByYXRpbyldXG4gICAgICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XG4gICAgfTtcblxuICAgIHZhciBvbk5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZVRvKHtcbiAgICAgICAgc2NhbGU6IHNjYWxlXG4gICAgICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XG4gICAgfTtcblxuICAgIHN5bWJvbFBhdGgub24oJ21vdXNlb3ZlcicsIG9uRW1waGFzaXMpLm9uKCdtb3VzZW91dCcsIG9uTm9ybWFsKS5vbignZW1waGFzaXMnLCBvbkVtcGhhc2lzKS5vbignbm9ybWFsJywgb25Ob3JtYWwpO1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdC5rZWVwTGFiZWw9dHJ1ZV1cbiAqL1xuXG5cbnN5bWJvbFByb3RvLmZhZGVPdXQgPSBmdW5jdGlvbiAoY2IsIG9wdCkge1xuICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTsgLy8gQXZvaWQgbWlzdGFrZW4gaG92ZXIgd2hlbiBmYWRpbmcgb3V0XG5cbiAgdGhpcy5zaWxlbnQgPSBzeW1ib2xQYXRoLnNpbGVudCA9IHRydWU7IC8vIE5vdCBzaG93IHRleHQgd2hlbiBhbmltYXRpbmdcblxuICAhKG9wdCAmJiBvcHQua2VlcExhYmVsKSAmJiAoc3ltYm9sUGF0aC5zdHlsZS50ZXh0ID0gbnVsbCk7XG4gIGdyYXBoaWMudXBkYXRlUHJvcHMoc3ltYm9sUGF0aCwge1xuICAgIHN0eWxlOiB7XG4gICAgICBvcGFjaXR5OiAwXG4gICAgfSxcbiAgICBzY2FsZTogWzAsIDBdXG4gIH0sIHRoaXMuX3Nlcmllc01vZGVsLCB0aGlzLmRhdGFJbmRleCwgY2IpO1xufTtcblxuenJVdGlsLmluaGVyaXRzKFN5bWJvbENseiwgZ3JhcGhpYy5Hcm91cCk7XG52YXIgX2RlZmF1bHQgPSBTeW1ib2xDbHo7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2wuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBTeW1ib2xDbHogPSByZXF1aXJlKFwiLi9TeW1ib2xcIik7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3XG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sRHJhd1xuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwfSBbc3ltYm9sQ3Rvcl1cbiAqL1xuZnVuY3Rpb24gU3ltYm9sRHJhdyhzeW1ib2xDdG9yKSB7XG4gIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICB0aGlzLl9zeW1ib2xDdG9yID0gc3ltYm9sQ3RvciB8fCBTeW1ib2xDbHo7XG59XG5cbnZhciBzeW1ib2xEcmF3UHJvdG8gPSBTeW1ib2xEcmF3LnByb3RvdHlwZTtcblxuZnVuY3Rpb24gc3ltYm9sTmVlZHNEcmF3KGRhdGEsIGlkeCwgaXNJZ25vcmUpIHtcbiAgdmFyIHBvaW50ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7IC8vIElzIGFuIG9iamVjdFxuICAvLyBpZiAocG9pbnQgJiYgcG9pbnQuaGFzT3duUHJvcGVydHkoJ3BvaW50JykpIHtcbiAgLy8gICAgIHBvaW50ID0gcG9pbnQucG9pbnQ7XG4gIC8vIH1cblxuICByZXR1cm4gcG9pbnQgJiYgIWlzTmFOKHBvaW50WzBdKSAmJiAhaXNOYU4ocG9pbnRbMV0pICYmICEoaXNJZ25vcmUgJiYgaXNJZ25vcmUoaWR4KSkgJiYgZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpICE9PSAnbm9uZSc7XG59XG4vKipcbiAqIFVwZGF0ZSBzeW1ib2xzIGRyYXcgYnkgbmV3IGRhdGFcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5Ljxib29sZWFuPn0gW2lzSWdub3JlXVxuICovXG5cblxuc3ltYm9sRHJhd1Byb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgaXNJZ25vcmUpIHtcbiAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgdmFyIFN5bWJvbEN0b3IgPSB0aGlzLl9zeW1ib2xDdG9yO1xuICB2YXIgc2VyaWVzU2NvcGUgPSB7XG4gICAgaXRlbVN0eWxlOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlLm5vcm1hbCcpLmdldEl0ZW1TdHlsZShbJ2NvbG9yJ10pLFxuICAgIGhvdmVySXRlbVN0eWxlOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlLmVtcGhhc2lzJykuZ2V0SXRlbVN0eWxlKCksXG4gICAgc3ltYm9sUm90YXRlOiBzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbFJvdGF0ZScpLFxuICAgIHN5bWJvbE9mZnNldDogc2VyaWVzTW9kZWwuZ2V0KCdzeW1ib2xPZmZzZXQnKSxcbiAgICBob3ZlckFuaW1hdGlvbjogc2VyaWVzTW9kZWwuZ2V0KCdob3ZlckFuaW1hdGlvbicpLFxuICAgIGxhYmVsTW9kZWw6IHNlcmllc01vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKSxcbiAgICBob3ZlckxhYmVsTW9kZWw6IHNlcmllc01vZGVsLmdldE1vZGVsKCdsYWJlbC5lbXBoYXNpcycpLFxuICAgIGN1cnNvclN0eWxlOiBzZXJpZXNNb2RlbC5nZXQoJ2N1cnNvcicpXG4gIH07XG4gIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKG5ld0lkeCkge1xuICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpO1xuXG4gICAgaWYgKHN5bWJvbE5lZWRzRHJhdyhkYXRhLCBuZXdJZHgsIGlzSWdub3JlKSkge1xuICAgICAgdmFyIHN5bWJvbEVsID0gbmV3IFN5bWJvbEN0b3IoZGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgICBzeW1ib2xFbC5hdHRyKCdwb3NpdGlvbicsIHBvaW50KTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHN5bWJvbEVsKTtcbiAgICAgIGdyb3VwLmFkZChzeW1ib2xFbCk7XG4gICAgfVxuICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgdmFyIHN5bWJvbEVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgdmFyIHBvaW50ID0gZGF0YS5nZXRJdGVtTGF5b3V0KG5ld0lkeCk7XG5cbiAgICBpZiAoIXN5bWJvbE5lZWRzRHJhdyhkYXRhLCBuZXdJZHgsIGlzSWdub3JlKSkge1xuICAgICAgZ3JvdXAucmVtb3ZlKHN5bWJvbEVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXN5bWJvbEVsKSB7XG4gICAgICBzeW1ib2xFbCA9IG5ldyBTeW1ib2xDdG9yKGRhdGEsIG5ld0lkeCk7XG4gICAgICBzeW1ib2xFbC5hdHRyKCdwb3NpdGlvbicsIHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ltYm9sRWwudXBkYXRlRGF0YShkYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlKTtcbiAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoc3ltYm9sRWwsIHtcbiAgICAgICAgcG9zaXRpb246IHBvaW50XG4gICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgfSAvLyBBZGQgYmFja1xuXG5cbiAgICBncm91cC5hZGQoc3ltYm9sRWwpO1xuICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHN5bWJvbEVsKTtcbiAgfSkucmVtb3ZlKGZ1bmN0aW9uIChvbGRJZHgpIHtcbiAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICBlbCAmJiBlbC5mYWRlT3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgfSk7XG4gIH0pLmV4ZWN1dGUoKTtcbiAgdGhpcy5fZGF0YSA9IGRhdGE7XG59O1xuXG5zeW1ib2xEcmF3UHJvdG8udXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgaWYgKGRhdGEpIHtcbiAgICAvLyBOb3QgdXNlIGFuaW1hdGlvblxuICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBwb2ludCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbnN5bWJvbERyYXdQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZW5hYmxlQW5pbWF0aW9uKSB7XG4gIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICBpZiAoZGF0YSkge1xuICAgIGlmIChlbmFibGVBbmltYXRpb24pIHtcbiAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmZhZGVPdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIF9kZWZhdWx0ID0gU3ltYm9sRHJhdztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL1N5bWJvbERyYXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBMaXN0ID0gcmVxdWlyZShcIi4uLy4uL2RhdGEvTGlzdFwiKTtcblxudmFyIGNvbXBsZXRlRGltZW5zaW9ucyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnNcIik7XG5cbnZhciBfbW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGdldERhdGFJdGVtVmFsdWUgPSBfbW9kZWwuZ2V0RGF0YUl0ZW1WYWx1ZTtcbnZhciBjb252ZXJEYXRhVmFsdWUgPSBfbW9kZWwuY29udmVyRGF0YVZhbHVlO1xudmFyIGlzRGF0YUl0ZW1PcHRpb24gPSBfbW9kZWwuaXNEYXRhSXRlbU9wdGlvbjtcblxudmFyIENvb3JkaW5hdGVTeXN0ZW0gPSByZXF1aXJlKFwiLi4vLi4vQ29vcmRpbmF0ZVN5c3RlbVwiKTtcblxuZnVuY3Rpb24gZmlyc3REYXRhTm90TnVsbChkYXRhKSB7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoICYmIGRhdGFbaV0gPT0gbnVsbCkge1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBkYXRhW2ldO1xufVxuXG5mdW5jdGlvbiBpZk5lZWRDb21wbGV0ZU9yZGluYWxEYXRhKGRhdGEpIHtcbiAgdmFyIHNhbXBsZUl0ZW0gPSBmaXJzdERhdGFOb3ROdWxsKGRhdGEpO1xuICByZXR1cm4gc2FtcGxlSXRlbSAhPSBudWxsICYmICF6clV0aWwuaXNBcnJheShnZXREYXRhSXRlbVZhbHVlKHNhbXBsZUl0ZW0pKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGxpc3QgZnJvbSBvcHRpb24gZGF0YVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTGlzdEZyb21BcnJheShkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAvLyBJZiBkYXRhIGlzIHVuZGVmaW5lZFxuICBkYXRhID0gZGF0YSB8fCBbXTtcbiAgdmFyIGNvb3JkU3lzTmFtZSA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuICB2YXIgY3JlYXRvciA9IGNyZWF0b3JzW2Nvb3JkU3lzTmFtZV07XG4gIHZhciByZWdpc3RlcmVkQ29vcmRTeXMgPSBDb29yZGluYXRlU3lzdGVtLmdldChjb29yZFN5c05hbWUpO1xuICB2YXIgY29tcGxldGVEaW1PcHQgPSB7XG4gICAgZW5jb2RlRGVmOiBzZXJpZXNNb2RlbC5nZXQoJ2VuY29kZScpLFxuICAgIGRpbXNEZWY6IHNlcmllc01vZGVsLmdldCgnZGltZW5zaW9ucycpXG4gIH07IC8vIEZJWE1FXG5cbiAgdmFyIGF4ZXNJbmZvID0gY3JlYXRvciAmJiBjcmVhdG9yKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsLCBjb21wbGV0ZURpbU9wdCk7XG4gIHZhciBkaW1lbnNpb25zID0gYXhlc0luZm8gJiYgYXhlc0luZm8uZGltZW5zaW9ucztcblxuICBpZiAoIWRpbWVuc2lvbnMpIHtcbiAgICAvLyBHZXQgZGltZW5zaW9ucyBmcm9tIHJlZ2lzdGVyZWQgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICBkaW1lbnNpb25zID0gcmVnaXN0ZXJlZENvb3JkU3lzICYmIChyZWdpc3RlcmVkQ29vcmRTeXMuZ2V0RGltZW5zaW9uc0luZm8gPyByZWdpc3RlcmVkQ29vcmRTeXMuZ2V0RGltZW5zaW9uc0luZm8oKSA6IHJlZ2lzdGVyZWRDb29yZFN5cy5kaW1lbnNpb25zLnNsaWNlKCkpIHx8IFsneCcsICd5J107XG4gICAgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBjb21wbGV0ZURpbU9wdCk7XG4gIH1cblxuICB2YXIgY2F0ZWdvcnlJbmRleCA9IGF4ZXNJbmZvID8gYXhlc0luZm8uY2F0ZWdvcnlJbmRleCA6IC0xO1xuICB2YXIgbGlzdCA9IG5ldyBMaXN0KGRpbWVuc2lvbnMsIHNlcmllc01vZGVsKTtcbiAgdmFyIG5hbWVMaXN0ID0gY3JlYXRlTmFtZUxpc3QoYXhlc0luZm8sIGRhdGEpO1xuICB2YXIgY2F0ZWdvcmllcyA9IHt9O1xuICB2YXIgZGltVmFsdWVHZXR0ZXIgPSBjYXRlZ29yeUluZGV4ID49IDAgJiYgaWZOZWVkQ29tcGxldGVPcmRpbmFsRGF0YShkYXRhKSA/IGZ1bmN0aW9uIChpdGVtT3B0LCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgLy8gSWYgYW55IGRhdGFJdGVtIGlzIGxpa2UgeyB2YWx1ZTogMTAgfVxuICAgIGlmIChpc0RhdGFJdGVtT3B0aW9uKGl0ZW1PcHQpKSB7XG4gICAgICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICAgIH0gLy8gVXNlIGRhdGFJbmRleCBhcyBvcmRpbmFsIHZhbHVlIGluIGNhdGVnb3J5QXhpc1xuXG5cbiAgICByZXR1cm4gZGltSW5kZXggPT09IGNhdGVnb3J5SW5kZXggPyBkYXRhSW5kZXggOiBjb252ZXJEYXRhVmFsdWUoZ2V0RGF0YUl0ZW1WYWx1ZShpdGVtT3B0KSwgZGltZW5zaW9uc1tkaW1JbmRleF0pO1xuICB9IDogZnVuY3Rpb24gKGl0ZW1PcHQsIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXREYXRhSXRlbVZhbHVlKGl0ZW1PcHQpO1xuICAgIHZhciB2YWwgPSBjb252ZXJEYXRhVmFsdWUodmFsdWUgJiYgdmFsdWVbZGltSW5kZXhdLCBkaW1lbnNpb25zW2RpbUluZGV4XSk7IC8vIElmIGFueSBkYXRhSXRlbSBpcyBsaWtlIHsgdmFsdWU6IDEwIH1cblxuICAgIGlmIChpc0RhdGFJdGVtT3B0aW9uKGl0ZW1PcHQpKSB7XG4gICAgICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjYXRlZ29yeUF4ZXNNb2RlbHMgPSBheGVzSW5mbyAmJiBheGVzSW5mby5jYXRlZ29yeUF4ZXNNb2RlbHM7XG5cbiAgICBpZiAoY2F0ZWdvcnlBeGVzTW9kZWxzICYmIGNhdGVnb3J5QXhlc01vZGVsc1tkaW1OYW1lXSkge1xuICAgICAgLy8gSWYgZ2l2ZW4gdmFsdWUgaXMgYSBjYXRlZ29yeSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBMYXp5IGdldCBjYXRlZ29yaWVzXG4gICAgICAgIGNhdGVnb3JpZXNbZGltTmFtZV0gPSBjYXRlZ29yaWVzW2RpbU5hbWVdIHx8IGNhdGVnb3J5QXhlc01vZGVsc1tkaW1OYW1lXS5nZXRDYXRlZ29yaWVzKCk7XG4gICAgICAgIHZhbCA9IHpyVXRpbC5pbmRleE9mKGNhdGVnb3JpZXNbZGltTmFtZV0sIHZhbCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IDAgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAvLyBJbiBjYXNlIHNvbWUgb25lIHdyaXRlICcxJywgJzInIGlzdGVhZCBvZiAxLCAyXG4gICAgICAgICAgdmFsID0gK3ZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH07XG4gIGxpc3QuaGFzSXRlbU9wdGlvbiA9IGZhbHNlO1xuICBsaXN0LmluaXREYXRhKGRhdGEsIG5hbWVMaXN0LCBkaW1WYWx1ZUdldHRlcik7XG4gIHJldHVybiBsaXN0O1xufVxuXG5mdW5jdGlvbiBpc1N0YWNrYWJsZShheGlzVHlwZSkge1xuICByZXR1cm4gYXhpc1R5cGUgIT09ICdjYXRlZ29yeScgJiYgYXhpc1R5cGUgIT09ICd0aW1lJztcbn1cblxuZnVuY3Rpb24gZ2V0RGltVHlwZUJ5QXhpcyhheGlzVHlwZSkge1xuICByZXR1cm4gYXhpc1R5cGUgPT09ICdjYXRlZ29yeScgPyAnb3JkaW5hbCcgOiBheGlzVHlwZSA9PT0gJ3RpbWUnID8gJ3RpbWUnIDogJ2Zsb2F0Jztcbn1cbi8qKlxuICogQ3JlYXRlcnMgZm9yIGVhY2ggY29vcmQgc3lzdGVtLlxuICovXG5cblxudmFyIGNyZWF0b3JzID0ge1xuICBjYXJ0ZXNpYW4yZDogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsLCBjb21wbGV0ZURpbU9wdCkge1xuICAgIHZhciBheGVzTW9kZWxzID0genJVdGlsLm1hcChbJ3hBeGlzJywgJ3lBeGlzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICBtYWluVHlwZTogbmFtZSxcbiAgICAgICAgaW5kZXg6IHNlcmllc01vZGVsLmdldChuYW1lICsgJ0luZGV4JyksXG4gICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQobmFtZSArICdJZCcpXG4gICAgICB9KVswXTtcbiAgICB9KTtcbiAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMF07XG4gICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuICAgIHZhciB4QXhpc1R5cGUgPSB4QXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgIHZhciB5QXhpc1R5cGUgPSB5QXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgIHZhciBkaW1lbnNpb25zID0gW3tcbiAgICAgIG5hbWU6ICd4JyxcbiAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMoeEF4aXNUeXBlKSxcbiAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoeEF4aXNUeXBlKVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd5JyxcbiAgICAgIC8vIElmIHR3byBjYXRlZ29yeSBheGVzXG4gICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHlBeGlzVHlwZSksXG4gICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHlBeGlzVHlwZSlcbiAgICB9XTtcbiAgICB2YXIgaXNYQXhpc0NhdGVvZ3J5ID0geEF4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuICAgIHZhciBpc1lBeGlzQ2F0ZWdvcnkgPSB5QXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBjb21wbGV0ZURpbU9wdCk7XG4gICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuXG4gICAgaWYgKGlzWEF4aXNDYXRlb2dyeSkge1xuICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLnggPSB4QXhpc01vZGVsO1xuICAgIH1cblxuICAgIGlmIChpc1lBeGlzQ2F0ZWdvcnkpIHtcbiAgICAgIGNhdGVnb3J5QXhlc01vZGVscy55ID0geUF4aXNNb2RlbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgIGNhdGVnb3J5SW5kZXg6IGlzWEF4aXNDYXRlb2dyeSA/IDAgOiBpc1lBeGlzQ2F0ZWdvcnkgPyAxIDogLTEsXG4gICAgICBjYXRlZ29yeUF4ZXNNb2RlbHM6IGNhdGVnb3J5QXhlc01vZGVsc1xuICAgIH07XG4gIH0sXG4gIHNpbmdsZUF4aXM6IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgY29tcGxldGVEaW1PcHQpIHtcbiAgICB2YXIgc2luZ2xlQXhpc01vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgbWFpblR5cGU6ICdzaW5nbGVBeGlzJyxcbiAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoJ3NpbmdsZUF4aXNJbmRleCcpLFxuICAgICAgaWQ6IHNlcmllc01vZGVsLmdldCgnc2luZ2xlQXhpc0lkJylcbiAgICB9KVswXTtcbiAgICB2YXIgc2luZ2xlQXhpc1R5cGUgPSBzaW5nbGVBeGlzTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgdmFyIGlzQ2F0ZWdvcnkgPSBzaW5nbGVBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICB2YXIgZGltZW5zaW9ucyA9IFt7XG4gICAgICBuYW1lOiAnc2luZ2xlJyxcbiAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMoc2luZ2xlQXhpc1R5cGUpLFxuICAgICAgc3RhY2thYmxlOiBpc1N0YWNrYWJsZShzaW5nbGVBeGlzVHlwZSlcbiAgICB9XTtcbiAgICBkaW1lbnNpb25zID0gY29tcGxldGVEaW1lbnNpb25zKGRpbWVuc2lvbnMsIGRhdGEsIGNvbXBsZXRlRGltT3B0KTtcbiAgICB2YXIgY2F0ZWdvcnlBeGVzTW9kZWxzID0ge307XG5cbiAgICBpZiAoaXNDYXRlZ29yeSkge1xuICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLnNpbmdsZSA9IHNpbmdsZUF4aXNNb2RlbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgIGNhdGVnb3J5SW5kZXg6IGlzQ2F0ZWdvcnkgPyAwIDogLTEsXG4gICAgICBjYXRlZ29yeUF4ZXNNb2RlbHM6IGNhdGVnb3J5QXhlc01vZGVsc1xuICAgIH07XG4gIH0sXG4gIHBvbGFyOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGNvbXBsZXRlRGltT3B0KSB7XG4gICAgdmFyIHBvbGFyTW9kZWwgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICBtYWluVHlwZTogJ3BvbGFyJyxcbiAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoJ3BvbGFySW5kZXgnKSxcbiAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoJ3BvbGFySWQnKVxuICAgIH0pWzBdO1xuICAgIHZhciBhbmdsZUF4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgnYW5nbGVBeGlzJyk7XG4gICAgdmFyIHJhZGl1c0F4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgncmFkaXVzQXhpcycpO1xuICAgIHZhciByYWRpdXNBeGlzVHlwZSA9IHJhZGl1c0F4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgYW5nbGVBeGlzVHlwZSA9IGFuZ2xlQXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgIHZhciBkaW1lbnNpb25zID0gW3tcbiAgICAgIG5hbWU6ICdyYWRpdXMnLFxuICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyhyYWRpdXNBeGlzVHlwZSksXG4gICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHJhZGl1c0F4aXNUeXBlKVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdhbmdsZScsXG4gICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKGFuZ2xlQXhpc1R5cGUpLFxuICAgICAgc3RhY2thYmxlOiBpc1N0YWNrYWJsZShhbmdsZUF4aXNUeXBlKVxuICAgIH1dO1xuICAgIHZhciBpc0FuZ2xlQXhpc0NhdGVvZ3J5ID0gYW5nbGVBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICB2YXIgaXNSYWRpdXNBeGlzQ2F0ZW9ncnkgPSByYWRpdXNBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICBkaW1lbnNpb25zID0gY29tcGxldGVEaW1lbnNpb25zKGRpbWVuc2lvbnMsIGRhdGEsIGNvbXBsZXRlRGltT3B0KTtcbiAgICB2YXIgY2F0ZWdvcnlBeGVzTW9kZWxzID0ge307XG5cbiAgICBpZiAoaXNSYWRpdXNBeGlzQ2F0ZW9ncnkpIHtcbiAgICAgIGNhdGVnb3J5QXhlc01vZGVscy5yYWRpdXMgPSByYWRpdXNBeGlzTW9kZWw7XG4gICAgfVxuXG4gICAgaWYgKGlzQW5nbGVBeGlzQ2F0ZW9ncnkpIHtcbiAgICAgIGNhdGVnb3J5QXhlc01vZGVscy5hbmdsZSA9IGFuZ2xlQXhpc01vZGVsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgICAgY2F0ZWdvcnlJbmRleDogaXNBbmdsZUF4aXNDYXRlb2dyeSA/IDEgOiBpc1JhZGl1c0F4aXNDYXRlb2dyeSA/IDAgOiAtMSxcbiAgICAgIGNhdGVnb3J5QXhlc01vZGVsczogY2F0ZWdvcnlBeGVzTW9kZWxzXG4gICAgfTtcbiAgfSxcbiAgZ2VvOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGNvbXBsZXRlRGltT3B0KSB7XG4gICAgLy8gVE9ETyBSZWdpb25cbiAgICAvLyDlpJrkuKrmlaPngrnlm77ns7vliJflnKjlkIzkuIDkuKrlnLDljLrnmoTml7blgJlcbiAgICByZXR1cm4ge1xuICAgICAgZGltZW5zaW9uczogY29tcGxldGVEaW1lbnNpb25zKFt7XG4gICAgICAgIG5hbWU6ICdsbmcnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdsYXQnXG4gICAgICB9XSwgZGF0YSwgY29tcGxldGVEaW1PcHQpXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlTmFtZUxpc3QocmVzdWx0LCBkYXRhKSB7XG4gIHZhciBuYW1lTGlzdCA9IFtdO1xuICB2YXIgY2F0ZWdvcnlEaW0gPSByZXN1bHQgJiYgcmVzdWx0LmRpbWVuc2lvbnNbcmVzdWx0LmNhdGVnb3J5SW5kZXhdO1xuICB2YXIgY2F0ZWdvcnlBeGlzTW9kZWw7XG5cbiAgaWYgKGNhdGVnb3J5RGltKSB7XG4gICAgY2F0ZWdvcnlBeGlzTW9kZWwgPSByZXN1bHQuY2F0ZWdvcnlBeGVzTW9kZWxzW2NhdGVnb3J5RGltLm5hbWVdO1xuICB9XG5cbiAgaWYgKGNhdGVnb3J5QXhpc01vZGVsKSB7XG4gICAgLy8gRklYTUUgVHdvIGNhdGVnb3J5IGF4aXNcbiAgICB2YXIgY2F0ZWdvcmllcyA9IGNhdGVnb3J5QXhpc01vZGVsLmdldENhdGVnb3JpZXMoKTtcblxuICAgIGlmIChjYXRlZ29yaWVzKSB7XG4gICAgICB2YXIgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyAvLyBPcmRlcmVkIGRhdGEgaXMgZ2l2ZW4gZXhwbGljaXRseSBsaWtlXG4gICAgICAvLyBbWzMsIDAuMl0sIFsxLCAwLjNdLCBbMiwgMC4xNV1dXG4gICAgICAvLyBvciBnaXZlbiBzY2F0dGVyIGRhdGEsXG4gICAgICAvLyBwaWNrIHRoZSBjYXRlZ29yeVxuXG4gICAgICBpZiAoenJVdGlsLmlzQXJyYXkoZGF0YVswXSkgJiYgZGF0YVswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgIG5hbWVMaXN0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuOyBpKyspIHtcbiAgICAgICAgICBuYW1lTGlzdFtpXSA9IGNhdGVnb3JpZXNbZGF0YVtpXVtyZXN1bHQuY2F0ZWdvcnlJbmRleCB8fCAwXV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWVMaXN0ID0gY2F0ZWdvcmllcy5zbGljZSgwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZUxpc3Q7XG59XG5cbnZhciBfZGVmYXVsdCA9IGNyZWF0ZUxpc3RGcm9tQXJyYXk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfbW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIG90aGVyRGltVG9EYXRhRGltID0gX21vZGVsLm90aGVyRGltVG9EYXRhRGltO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sXG4gKi9cbmZ1bmN0aW9uIGZpbmRMYWJlbFZhbHVlRGltKGRhdGEpIHtcbiAgdmFyIHZhbHVlRGltO1xuICB2YXIgbGFiZWxEaW1zID0gb3RoZXJEaW1Ub0RhdGFEaW0oZGF0YSwgJ2xhYmVsJyk7XG5cbiAgaWYgKGxhYmVsRGltcy5sZW5ndGgpIHtcbiAgICB2YWx1ZURpbSA9IGxhYmVsRGltc1swXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgbGFzdCB2YWx1ZSBkaW1cbiAgICB2YXIgZGltZW5zaW9ucyA9IGRhdGEuZGltZW5zaW9ucy5zbGljZSgpO1xuICAgIHZhciBkYXRhVHlwZTtcblxuICAgIHdoaWxlIChkaW1lbnNpb25zLmxlbmd0aCAmJiAodmFsdWVEaW0gPSBkaW1lbnNpb25zLnBvcCgpLCBkYXRhVHlwZSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyh2YWx1ZURpbSkudHlwZSwgZGF0YVR5cGUgPT09ICdvcmRpbmFsJyB8fCBkYXRhVHlwZSA9PT0gJ3RpbWUnKSkge30gLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgfVxuXG4gIHJldHVybiB2YWx1ZURpbTtcbn1cblxuZXhwb3J0cy5maW5kTGFiZWxWYWx1ZURpbSA9IGZpbmRMYWJlbFZhbHVlRGltO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9sYWJlbEhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2xhYmVsSGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnJlcXVpcmUoXCIuL2xpbmUvTGluZVNlcmllc1wiKTtcblxucmVxdWlyZShcIi4vbGluZS9MaW5lVmlld1wiKTtcblxudmFyIHZpc3VhbFN5bWJvbCA9IHJlcXVpcmUoXCIuLi92aXN1YWwvc3ltYm9sXCIpO1xuXG52YXIgbGF5b3V0UG9pbnRzID0gcmVxdWlyZShcIi4uL2xheW91dC9wb2ludHNcIik7XG5cbnZhciBkYXRhU2FtcGxlID0gcmVxdWlyZShcIi4uL3Byb2Nlc3Nvci9kYXRhU2FtcGxlXCIpO1xuXG5yZXF1aXJlKFwiLi4vY29tcG9uZW50L2dyaWRTaW1wbGVcIik7XG5cbi8vIEluIGNhc2UgZGV2ZWxvcGVyIGZvcmdldCB0byBpbmNsdWRlIGdyaWQgY29tcG9uZW50XG5lY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKHpyVXRpbC5jdXJyeSh2aXN1YWxTeW1ib2wsICdsaW5lJywgJ2NpcmNsZScsICdsaW5lJykpO1xuZWNoYXJ0cy5yZWdpc3RlckxheW91dCh6clV0aWwuY3VycnkobGF5b3V0UG9pbnRzLCAnbGluZScpKTsgLy8gRG93biBzYW1wbGUgYWZ0ZXIgZmlsdGVyXG5cbmVjaGFydHMucmVnaXN0ZXJQcm9jZXNzb3IoZWNoYXJ0cy5QUklPUklUWS5QUk9DRVNTT1IuU1RBVElTVElDLCB6clV0aWwuY3VycnkoZGF0YVNhbXBsZSwgJ2xpbmUnKSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciBjcmVhdGVMaXN0RnJvbUFycmF5ID0gcmVxdWlyZShcIi4uL2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5XCIpO1xuXG52YXIgU2VyaWVzTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvU2VyaWVzXCIpO1xuXG52YXIgX2RlZmF1bHQgPSBTZXJpZXNNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnc2VyaWVzLmxpbmUnLFxuICBkZXBlbmRlbmNpZXM6IFsnZ3JpZCcsICdwb2xhciddLFxuICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHJldHVybiBjcmVhdGVMaXN0RnJvbUFycmF5KG9wdGlvbi5kYXRhLCB0aGlzLCBlY01vZGVsKTtcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuIDnuqflsYLlj6BcbiAgICB6OiAyLFxuICAgIC8vIOS6jOe6p+WxguWPoFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIGhvdmVyQW5pbWF0aW9uOiB0cnVlLFxuICAgIC8vIHN0YWNrOiBudWxsXG4gICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAvLyB5QXhpc0luZGV4OiAwLFxuICAgIC8vIHBvbGFySW5kZXg6IDAsXG4gICAgLy8gSWYgY2xpcCB0aGUgb3ZlcmZsb3cgdmFsdWVcbiAgICBjbGlwT3ZlcmZsb3c6IHRydWUsXG4gICAgLy8gY3Vyc29yOiBudWxsLFxuICAgIGxhYmVsOiB7XG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3AnXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBpdGVtU3R5bGU6IHtcbiAgICAvLyAgICAgbm9ybWFsOiB7fSxcbiAgICAvLyAgICAgZW1waGFzaXM6IHt9XG4gICAgLy8gfSxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICB3aWR0aDogMixcbiAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gYXJlYVN0eWxlOiB7fSxcbiAgICAvLyBmYWxzZSwgJ3N0YXJ0JywgJ2VuZCcsICdtaWRkbGUnXG4gICAgc3RlcDogZmFsc2UsXG4gICAgLy8gRGlzYWJsZWQgaWYgc3RlcCBpcyB0cnVlXG4gICAgc21vb3RoOiBmYWxzZSxcbiAgICBzbW9vdGhNb25vdG9uZTogbnVsbCxcbiAgICAvLyDmi5Dngrnlm77lvaLnsbvlnotcbiAgICBzeW1ib2w6ICdlbXB0eUNpcmNsZScsXG4gICAgLy8g5ouQ54K55Zu+5b2i5aSn5bCPXG4gICAgc3ltYm9sU2l6ZTogNCxcbiAgICAvLyDmi5Dngrnlm77lvaLml4vovazmjqfliLZcbiAgICBzeW1ib2xSb3RhdGU6IG51bGwsXG4gICAgLy8g5piv5ZCm5pi+56S6IHN5bWJvbCwg5Y+q5pyJ5ZyoIHRvb2x0aXAgaG92ZXIg55qE5pe25YCZ5pi+56S6XG4gICAgc2hvd1N5bWJvbDogdHJ1ZSxcbiAgICAvLyDmoIflv5flm77lvaLpu5jorqTlj6rmnInkuLvovbTmmL7npLrvvIjpmo/kuLvovbTmoIfnrb7pl7TpmpTpmpDol4/nrZbnlaXvvIlcbiAgICBzaG93QWxsU3ltYm9sOiBmYWxzZSxcbiAgICAvLyDmmK/lkKbov57mjqXmlq3ngrlcbiAgICBjb25uZWN0TnVsbHM6IGZhbHNlLFxuICAgIC8vIOaVsOaNrui/h+a7pO+8jCdhdmVyYWdlJywgJ21heCcsICdtaW4nLCAnc3VtJ1xuICAgIHNhbXBsaW5nOiAnbm9uZScsXG4gICAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJyxcbiAgICAvLyBEaXNhYmxlIHByb2dyZXNzaXZlXG4gICAgcHJvZ3Jlc3NpdmU6IDAsXG4gICAgaG92ZXJMYXllclRocmVzaG9sZDogSW5maW5pdHlcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL0xpbmVTZXJpZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFN5bWJvbERyYXcgPSByZXF1aXJlKFwiLi4vaGVscGVyL1N5bWJvbERyYXdcIik7XG5cbnZhciBTeW1ib2xDbHogPSByZXF1aXJlKFwiLi4vaGVscGVyL1N5bWJvbFwiKTtcblxudmFyIGxpbmVBbmltYXRpb25EaWZmID0gcmVxdWlyZShcIi4vbGluZUFuaW1hdGlvbkRpZmZcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG52YXIgX3BvbHkgPSByZXF1aXJlKFwiLi9wb2x5XCIpO1xuXG52YXIgUG9seWxpbmUgPSBfcG9seS5Qb2x5bGluZTtcbnZhciBQb2x5Z29uID0gX3BvbHkuUG9seWdvbjtcblxudmFyIENoYXJ0VmlldyA9IHJlcXVpcmUoXCIuLi8uLi92aWV3L0NoYXJ0XCIpO1xuXG4vLyBGSVhNRSBzdGVwIG5vdCBzdXBwb3J0IHBvbGFyXG5mdW5jdGlvbiBpc1BvaW50c1NhbWUocG9pbnRzMSwgcG9pbnRzMikge1xuICBpZiAocG9pbnRzMS5sZW5ndGggIT09IHBvaW50czIubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAxID0gcG9pbnRzMVtpXTtcbiAgICB2YXIgcDIgPSBwb2ludHMyW2ldO1xuXG4gICAgaWYgKHAxWzBdICE9PSBwMlswXSB8fCBwMVsxXSAhPT0gcDJbMV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U21vb3RoKHNtb290aCkge1xuICByZXR1cm4gdHlwZW9mIHNtb290aCA9PT0gJ251bWJlcicgPyBzbW9vdGggOiBzbW9vdGggPyAwLjMgOiAwO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRXh0ZW50V2l0aEdhcChheGlzKSB7XG4gIHZhciBleHRlbnQgPSBheGlzLmdldEdsb2JhbEV4dGVudCgpO1xuXG4gIGlmIChheGlzLm9uQmFuZCkge1xuICAgIC8vIFJlbW92ZSBleHRyYSAxcHggdG8gYXZvaWQgbGluZSBtaXRlciBpbiBjbGlwcGVkIGVkZ2VcbiAgICB2YXIgaGFsZkJhbmRXaWR0aCA9IGF4aXMuZ2V0QmFuZFdpZHRoKCkgLyAyIC0gMTtcbiAgICB2YXIgZGlyID0gZXh0ZW50WzFdID4gZXh0ZW50WzBdID8gMSA6IC0xO1xuICAgIGV4dGVudFswXSArPSBkaXIgKiBoYWxmQmFuZFdpZHRoO1xuICAgIGV4dGVudFsxXSAtPSBkaXIgKiBoYWxmQmFuZFdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuZnVuY3Rpb24gc2lnbih2YWwpIHtcbiAgcmV0dXJuIHZhbCA+PSAwID8gMSA6IC0xO1xufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRHxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9wb2xhci9Qb2xhcn0gY29vcmRTeXNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBvaW50c1xuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFN0YWNrZWRPblBvaW50cyhjb29yZFN5cywgZGF0YSkge1xuICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICB2YXIgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgdmFyIHZhbHVlU3RhcnQgPSAwO1xuXG4gIGlmICghYmFzZUF4aXMub25aZXJvKSB7XG4gICAgdmFyIGV4dGVudCA9IHZhbHVlQXhpcy5zY2FsZS5nZXRFeHRlbnQoKTtcblxuICAgIGlmIChleHRlbnRbMF0gPiAwKSB7XG4gICAgICAvLyBCb3RoIHBvc2l0aXZlXG4gICAgICB2YWx1ZVN0YXJ0ID0gZXh0ZW50WzBdO1xuICAgIH0gZWxzZSBpZiAoZXh0ZW50WzFdIDwgMCkge1xuICAgICAgLy8gQm90aCBuZWdhdGl2ZVxuICAgICAgdmFsdWVTdGFydCA9IGV4dGVudFsxXTtcbiAgICB9IC8vIElmIGlzIG9uZSBwb3NpdGl2ZSwgYW5kIG9uZSBuZWdhdGl2ZSwgb25aZXJvIHNoYWxsIGJlIHRydWVcblxuICB9XG5cbiAgdmFyIHZhbHVlRGltID0gdmFsdWVBeGlzLmRpbTtcbiAgdmFyIGJhc2VEYXRhT2Zmc2V0ID0gdmFsdWVEaW0gPT09ICd4JyB8fCB2YWx1ZURpbSA9PT0gJ3JhZGl1cycgPyAxIDogMDtcbiAgcmV0dXJuIGRhdGEubWFwQXJyYXkoW3ZhbHVlRGltXSwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7XG4gICAgdmFyIHN0YWNrZWRPblNhbWVTaWduO1xuICAgIHZhciBzdGFja2VkT24gPSBkYXRhLnN0YWNrZWRPbjsgLy8gRmluZCBmaXJzdCBzdGFja2VkIHZhbHVlIHdpdGggc2FtZSBzaWduXG5cbiAgICB3aGlsZSAoc3RhY2tlZE9uICYmIHNpZ24oc3RhY2tlZE9uLmdldCh2YWx1ZURpbSwgaWR4KSkgPT09IHNpZ24odmFsKSkge1xuICAgICAgc3RhY2tlZE9uU2FtZVNpZ24gPSBzdGFja2VkT247XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgc3RhY2tlZERhdGEgPSBbXTtcbiAgICBzdGFja2VkRGF0YVtiYXNlRGF0YU9mZnNldF0gPSBkYXRhLmdldChiYXNlQXhpcy5kaW0sIGlkeCk7XG4gICAgc3RhY2tlZERhdGFbMSAtIGJhc2VEYXRhT2Zmc2V0XSA9IHN0YWNrZWRPblNhbWVTaWduID8gc3RhY2tlZE9uU2FtZVNpZ24uZ2V0KHZhbHVlRGltLCBpZHgsIHRydWUpIDogdmFsdWVTdGFydDtcbiAgICByZXR1cm4gY29vcmRTeXMuZGF0YVRvUG9pbnQoc3RhY2tlZERhdGEpO1xuICB9LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlR3JpZENsaXBTaGFwZShjYXJ0ZXNpYW4sIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIHhFeHRlbnQgPSBnZXRBeGlzRXh0ZW50V2l0aEdhcChjYXJ0ZXNpYW4uZ2V0QXhpcygneCcpKTtcbiAgdmFyIHlFeHRlbnQgPSBnZXRBeGlzRXh0ZW50V2l0aEdhcChjYXJ0ZXNpYW4uZ2V0QXhpcygneScpKTtcbiAgdmFyIGlzSG9yaXpvbnRhbCA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpLmlzSG9yaXpvbnRhbCgpO1xuICB2YXIgeCA9IE1hdGgubWluKHhFeHRlbnRbMF0sIHhFeHRlbnRbMV0pO1xuICB2YXIgeSA9IE1hdGgubWluKHlFeHRlbnRbMF0sIHlFeHRlbnRbMV0pO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heCh4RXh0ZW50WzBdLCB4RXh0ZW50WzFdKSAtIHg7XG4gIHZhciBoZWlnaHQgPSBNYXRoLm1heCh5RXh0ZW50WzBdLCB5RXh0ZW50WzFdKSAtIHk7XG4gIHZhciBsaW5lV2lkdGggPSBzZXJpZXNNb2RlbC5nZXQoJ2xpbmVTdHlsZS5ub3JtYWwud2lkdGgnKSB8fCAyOyAvLyBFeHBhbmQgY2xpcCBzaGFwZSB0byBhdm9pZCBjbGlwcGluZyB3aGVuIGxpbmUgdmFsdWUgZXhjZWVkcyBheGlzXG5cbiAgdmFyIGV4cGFuZFNpemUgPSBzZXJpZXNNb2RlbC5nZXQoJ2NsaXBPdmVyZmxvdycpID8gbGluZVdpZHRoIC8gMiA6IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuXG4gIGlmIChpc0hvcml6b250YWwpIHtcbiAgICB5IC09IGV4cGFuZFNpemU7XG4gICAgaGVpZ2h0ICs9IGV4cGFuZFNpemUgKiAyO1xuICB9IGVsc2Uge1xuICAgIHggLT0gZXhwYW5kU2l6ZTtcbiAgICB3aWR0aCArPSBleHBhbmRTaXplICogMjtcbiAgfVxuXG4gIHZhciBjbGlwUGF0aCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHNoYXBlOiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfVxuICB9KTtcblxuICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgY2xpcFBhdGguc2hhcGVbaXNIb3Jpem9udGFsID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA9IDA7XG4gICAgZ3JhcGhpYy5pbml0UHJvcHMoY2xpcFBhdGgsIHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH1cbiAgICB9LCBzZXJpZXNNb2RlbCk7XG4gIH1cblxuICByZXR1cm4gY2xpcFBhdGg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvbGFyQ2xpcFNoYXBlKHBvbGFyLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsKSB7XG4gIHZhciBhbmdsZUF4aXMgPSBwb2xhci5nZXRBbmdsZUF4aXMoKTtcbiAgdmFyIHJhZGl1c0F4aXMgPSBwb2xhci5nZXRSYWRpdXNBeGlzKCk7XG4gIHZhciByYWRpdXNFeHRlbnQgPSByYWRpdXNBeGlzLmdldEV4dGVudCgpO1xuICB2YXIgYW5nbGVFeHRlbnQgPSBhbmdsZUF4aXMuZ2V0RXh0ZW50KCk7XG4gIHZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgY2xpcFBhdGggPSBuZXcgZ3JhcGhpYy5TZWN0b3Ioe1xuICAgIHNoYXBlOiB7XG4gICAgICBjeDogcG9sYXIuY3gsXG4gICAgICBjeTogcG9sYXIuY3ksXG4gICAgICByMDogcmFkaXVzRXh0ZW50WzBdLFxuICAgICAgcjogcmFkaXVzRXh0ZW50WzFdLFxuICAgICAgc3RhcnRBbmdsZTogLWFuZ2xlRXh0ZW50WzBdICogUkFESUFOLFxuICAgICAgZW5kQW5nbGU6IC1hbmdsZUV4dGVudFsxXSAqIFJBRElBTixcbiAgICAgIGNsb2Nrd2lzZTogYW5nbGVBeGlzLmludmVyc2VcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChoYXNBbmltYXRpb24pIHtcbiAgICBjbGlwUGF0aC5zaGFwZS5lbmRBbmdsZSA9IC1hbmdsZUV4dGVudFswXSAqIFJBRElBTjtcbiAgICBncmFwaGljLmluaXRQcm9wcyhjbGlwUGF0aCwge1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgZW5kQW5nbGU6IC1hbmdsZUV4dGVudFsxXSAqIFJBRElBTlxuICAgICAgfVxuICAgIH0sIHNlcmllc01vZGVsKTtcbiAgfVxuXG4gIHJldHVybiBjbGlwUGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xpcFNoYXBlKGNvb3JkU3lzLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsKSB7XG4gIHJldHVybiBjb29yZFN5cy50eXBlID09PSAncG9sYXInID8gY3JlYXRlUG9sYXJDbGlwU2hhcGUoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpIDogY3JlYXRlR3JpZENsaXBTaGFwZShjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCk7XG59XG5cbmZ1bmN0aW9uIHR1cm5Qb2ludHNJbnRvU3RlcChwb2ludHMsIGNvb3JkU3lzLCBzdGVwVHVybkF0KSB7XG4gIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gIHZhciBiYXNlSW5kZXggPSBiYXNlQXhpcy5kaW0gPT09ICd4JyB8fCBiYXNlQXhpcy5kaW0gPT09ICdyYWRpdXMnID8gMCA6IDE7XG4gIHZhciBzdGVwUG9pbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIG5leHRQdCA9IHBvaW50c1tpICsgMV07XG4gICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgIHN0ZXBQb2ludHMucHVzaChwdCk7XG4gICAgdmFyIHN0ZXBQdCA9IFtdO1xuXG4gICAgc3dpdGNoIChzdGVwVHVybkF0KSB7XG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICBzdGVwUHRbYmFzZUluZGV4XSA9IG5leHRQdFtiYXNlSW5kZXhdO1xuICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBwdFsxIC0gYmFzZUluZGV4XTsgLy8gZGVmYXVsdCBpcyBzdGFydFxuXG4gICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgLy8gZGVmYXVsdCBpcyBzdGFydFxuICAgICAgICB2YXIgbWlkZGxlID0gKHB0W2Jhc2VJbmRleF0gKyBuZXh0UHRbYmFzZUluZGV4XSkgLyAyO1xuICAgICAgICB2YXIgc3RlcFB0MiA9IFtdO1xuICAgICAgICBzdGVwUHRbYmFzZUluZGV4XSA9IHN0ZXBQdDJbYmFzZUluZGV4XSA9IG1pZGRsZTtcbiAgICAgICAgc3RlcFB0WzEgLSBiYXNlSW5kZXhdID0gcHRbMSAtIGJhc2VJbmRleF07XG4gICAgICAgIHN0ZXBQdDJbMSAtIGJhc2VJbmRleF0gPSBuZXh0UHRbMSAtIGJhc2VJbmRleF07XG4gICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQpO1xuICAgICAgICBzdGVwUG9pbnRzLnB1c2goc3RlcFB0Mik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdGVwUHRbYmFzZUluZGV4XSA9IHB0W2Jhc2VJbmRleF07XG4gICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IG5leHRQdFsxIC0gYmFzZUluZGV4XTsgLy8gZGVmYXVsdCBpcyBzdGFydFxuXG4gICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQpO1xuICAgIH1cbiAgfSAvLyBMYXN0IHBvaW50c1xuXG5cbiAgcG9pbnRzW2ldICYmIHN0ZXBQb2ludHMucHVzaChwb2ludHNbaV0pO1xuICByZXR1cm4gc3RlcFBvaW50cztcbn1cblxuZnVuY3Rpb24gZ2V0VmlzdWFsR3JhZGllbnQoZGF0YSwgY29vcmRTeXMpIHtcbiAgdmFyIHZpc3VhbE1ldGFMaXN0ID0gZGF0YS5nZXRWaXN1YWwoJ3Zpc3VhbE1ldGEnKTtcblxuICBpZiAoIXZpc3VhbE1ldGFMaXN0IHx8ICF2aXN1YWxNZXRhTGlzdC5sZW5ndGggfHwgIWRhdGEuY291bnQoKSkge1xuICAgIC8vIFdoZW4gZGF0YS5jb3VudCgpIGlzIDAsIGdyYWRpZW50IHJhbmdlIGNhbiBub3QgYmUgY2FsY3VsYXRlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmlzdWFsTWV0YTtcblxuICBmb3IgKHZhciBpID0gdmlzdWFsTWV0YUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDYW4gb25seSBiZSB4IG9yIHlcbiAgICBpZiAodmlzdWFsTWV0YUxpc3RbaV0uZGltZW5zaW9uIDwgMikge1xuICAgICAgdmlzdWFsTWV0YSA9IHZpc3VhbE1ldGFMaXN0W2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2aXN1YWxNZXRhIHx8IGNvb3JkU3lzLnR5cGUgIT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gSWYgdGhlIGFyZWEgdG8gYmUgcmVuZGVyZWQgaXMgYmlnZ2VyIHRoYW4gYXJlYSBkZWZpbmVkIGJ5IExpbmVhckdyYWRpZW50LFxuICAvLyB0aGUgY2FudmFzIHNwZWMgcHJlc2NyaWJlcyB0aGF0IHRoZSBjb2xvciBvZiB0aGUgZmlyc3Qgc3RvcCBhbmQgdGhlIGxhc3RcbiAgLy8gc3RvcCBzaG91bGQgYmUgdXNlZC4gQnV0IGlmIHR3byBzdG9wcyBhcmUgYWRkZWQgYXQgb2Zmc2V0IDAsIGluIGVmZmVjdFxuICAvLyBicm93c2VycyB1c2UgdGhlIGNvbG9yIG9mIHRoZSBzZWNvbmQgc3RvcCB0byByZW5kZXIgYXJlYSBvdXRzaWRlXG4gIC8vIExpbmVhckdyYWRpZW50LiBTbyB3ZSBjYW4gb25seSBpbmZpbml0ZXNpbWFsbHkgZXh0ZW5kIGFyZWEgZGVmaW5lZCBpblxuICAvLyBMaW5lYXJHcmFkaWVudCB0byByZW5kZXIgYG91dGVyQ29sb3JzYC5cblxuXG4gIHZhciBkaW1lbnNpb24gPSB2aXN1YWxNZXRhLmRpbWVuc2lvbjtcbiAgdmFyIGRpbU5hbWUgPSBkYXRhLmRpbWVuc2lvbnNbZGltZW5zaW9uXTtcbiAgdmFyIGF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKGRpbU5hbWUpOyAvLyBkYXRhVG9Db29yIG1hcHBpbmcgbWF5IG5vdCBiZSBsaW5lYXIsIGJ1dCBtdXN0IGJlIG1vbm90b25pYy5cblxuICB2YXIgY29sb3JTdG9wcyA9IHpyVXRpbC5tYXAodmlzdWFsTWV0YS5zdG9wcywgZnVuY3Rpb24gKHN0b3ApIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29vcmQ6IGF4aXMudG9HbG9iYWxDb29yZChheGlzLmRhdGFUb0Nvb3JkKHN0b3AudmFsdWUpKSxcbiAgICAgIGNvbG9yOiBzdG9wLmNvbG9yXG4gICAgfTtcbiAgfSk7XG4gIHZhciBzdG9wTGVuID0gY29sb3JTdG9wcy5sZW5ndGg7XG4gIHZhciBvdXRlckNvbG9ycyA9IHZpc3VhbE1ldGEub3V0ZXJDb2xvcnMuc2xpY2UoKTtcblxuICBpZiAoc3RvcExlbiAmJiBjb2xvclN0b3BzWzBdLmNvb3JkID4gY29sb3JTdG9wc1tzdG9wTGVuIC0gMV0uY29vcmQpIHtcbiAgICBjb2xvclN0b3BzLnJldmVyc2UoKTtcbiAgICBvdXRlckNvbG9ycy5yZXZlcnNlKCk7XG4gIH1cblxuICB2YXIgdGlueUV4dGVudCA9IDEwOyAvLyBBcmJpdHJhcnkgdmFsdWU6IDEwcHhcblxuICB2YXIgbWluQ29vcmQgPSBjb2xvclN0b3BzWzBdLmNvb3JkIC0gdGlueUV4dGVudDtcbiAgdmFyIG1heENvb3JkID0gY29sb3JTdG9wc1tzdG9wTGVuIC0gMV0uY29vcmQgKyB0aW55RXh0ZW50O1xuICB2YXIgY29vcmRTcGFuID0gbWF4Q29vcmQgLSBtaW5Db29yZDtcblxuICBpZiAoY29vcmRTcGFuIDwgMWUtMykge1xuICAgIHJldHVybiAndHJhbnNwYXJlbnQnO1xuICB9XG5cbiAgenJVdGlsLmVhY2goY29sb3JTdG9wcywgZnVuY3Rpb24gKHN0b3ApIHtcbiAgICBzdG9wLm9mZnNldCA9IChzdG9wLmNvb3JkIC0gbWluQ29vcmQpIC8gY29vcmRTcGFuO1xuICB9KTtcbiAgY29sb3JTdG9wcy5wdXNoKHtcbiAgICBvZmZzZXQ6IHN0b3BMZW4gPyBjb2xvclN0b3BzW3N0b3BMZW4gLSAxXS5vZmZzZXQgOiAwLjUsXG4gICAgY29sb3I6IG91dGVyQ29sb3JzWzFdIHx8ICd0cmFuc3BhcmVudCdcbiAgfSk7XG4gIGNvbG9yU3RvcHMudW5zaGlmdCh7XG4gICAgLy8gbm90aWNlIGNvbG9yU3RvcHMubGVuZ3RoIGhhdmUgYmVlbiBjaGFuZ2VkLlxuICAgIG9mZnNldDogc3RvcExlbiA/IGNvbG9yU3RvcHNbMF0ub2Zmc2V0IDogMC41LFxuICAgIGNvbG9yOiBvdXRlckNvbG9yc1swXSB8fCAndHJhbnNwYXJlbnQnXG4gIH0pOyAvLyB6clV0aWwuZWFjaChjb2xvclN0b3BzLCBmdW5jdGlvbiAoY29sb3JTdG9wKSB7XG4gIC8vICAgICAvLyBNYWtlIHN1cmUgZWFjaCBvZmZzZXQgaGFzIHJvdW5kZWQgcHggdG8gYXZvaWQgbm90IHNoYXJwIGVkZ2VcbiAgLy8gICAgIGNvbG9yU3RvcC5vZmZzZXQgPSAoTWF0aC5yb3VuZChjb2xvclN0b3Aub2Zmc2V0ICogKGVuZCAtIHN0YXJ0KSArIHN0YXJ0KSAtIHN0YXJ0KSAvIChlbmQgLSBzdGFydCk7XG4gIC8vIH0pO1xuXG4gIHZhciBncmFkaWVudCA9IG5ldyBncmFwaGljLkxpbmVhckdyYWRpZW50KDAsIDAsIDAsIDAsIGNvbG9yU3RvcHMsIHRydWUpO1xuICBncmFkaWVudFtkaW1OYW1lXSA9IG1pbkNvb3JkO1xuICBncmFkaWVudFtkaW1OYW1lICsgJzInXSA9IG1heENvb3JkO1xuICByZXR1cm4gZ3JhZGllbnQ7XG59XG5cbnZhciBfZGVmYXVsdCA9IENoYXJ0Vmlldy5leHRlbmQoe1xuICB0eXBlOiAnbGluZScsXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGluZUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICB2YXIgc3ltYm9sRHJhdyA9IG5ldyBTeW1ib2xEcmF3KCk7XG4gICAgdGhpcy5ncm91cC5hZGQoc3ltYm9sRHJhdy5ncm91cCk7XG4gICAgdGhpcy5fc3ltYm9sRHJhdyA9IHN5bWJvbERyYXc7XG4gICAgdGhpcy5fbGluZUdyb3VwID0gbGluZUdyb3VwO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUubm9ybWFsJyk7XG4gICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZS5ub3JtYWwnKTtcbiAgICB2YXIgcG9pbnRzID0gZGF0YS5tYXBBcnJheShkYXRhLmdldEl0ZW1MYXlvdXQsIHRydWUpO1xuICAgIHZhciBpc0Nvb3JkU3lzUG9sYXIgPSBjb29yZFN5cy50eXBlID09PSAncG9sYXInO1xuICAgIHZhciBwcmV2Q29vcmRTeXMgPSB0aGlzLl9jb29yZFN5cztcbiAgICB2YXIgc3ltYm9sRHJhdyA9IHRoaXMuX3N5bWJvbERyYXc7XG4gICAgdmFyIHBvbHlsaW5lID0gdGhpcy5fcG9seWxpbmU7XG4gICAgdmFyIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uO1xuICAgIHZhciBsaW5lR3JvdXAgPSB0aGlzLl9saW5lR3JvdXA7XG4gICAgdmFyIGhhc0FuaW1hdGlvbiA9IHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uJyk7XG4gICAgdmFyIGlzQXJlYUNoYXJ0ID0gIWFyZWFTdHlsZU1vZGVsLmlzRW1wdHkoKTtcbiAgICB2YXIgc3RhY2tlZE9uUG9pbnRzID0gZ2V0U3RhY2tlZE9uUG9pbnRzKGNvb3JkU3lzLCBkYXRhKTtcbiAgICB2YXIgc2hvd1N5bWJvbCA9IHNlcmllc01vZGVsLmdldCgnc2hvd1N5bWJvbCcpO1xuXG4gICAgdmFyIGlzU3ltYm9sSWdub3JlID0gc2hvd1N5bWJvbCAmJiAhaXNDb29yZFN5c1BvbGFyICYmICFzZXJpZXNNb2RlbC5nZXQoJ3Nob3dBbGxTeW1ib2wnKSAmJiB0aGlzLl9nZXRTeW1ib2xJZ25vcmVGdW5jKGRhdGEsIGNvb3JkU3lzKTsgLy8gUmVtb3ZlIHRlbXBvcmFyeSBzeW1ib2xzXG5cblxuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICBvbGREYXRhICYmIG9sZERhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgIGlmIChlbC5fX3RlbXApIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgb2xkRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7IC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHN5bWJvbHMgaWYgc2hvd1N5bWJvbCBjaGFuZ2VkIHRvIGZhbHNlXG5cbiAgICBpZiAoIXNob3dTeW1ib2wpIHtcbiAgICAgIHN5bWJvbERyYXcucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZ3JvdXAuYWRkKGxpbmVHcm91cCk7IC8vIEZJWE1FIHN0ZXAgbm90IHN1cHBvcnQgcG9sYXJcblxuICAgIHZhciBzdGVwID0gIWlzQ29vcmRTeXNQb2xhciAmJiBzZXJpZXNNb2RlbC5nZXQoJ3N0ZXAnKTsgLy8gSW5pdGlhbGl6YXRpb24gYW5pbWF0aW9uIG9yIGNvb3JkaW5hdGUgc3lzdGVtIGNoYW5nZWRcblxuICAgIGlmICghKHBvbHlsaW5lICYmIHByZXZDb29yZFN5cy50eXBlID09PSBjb29yZFN5cy50eXBlICYmIHN0ZXAgPT09IHRoaXMuX3N0ZXApKSB7XG4gICAgICBzaG93U3ltYm9sICYmIHN5bWJvbERyYXcudXBkYXRlRGF0YShkYXRhLCBpc1N5bWJvbElnbm9yZSk7XG5cbiAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICBzdGFja2VkT25Qb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAoc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgc3RlcCk7XG4gICAgICB9XG5cbiAgICAgIHBvbHlsaW5lID0gdGhpcy5fbmV3UG9seWxpbmUocG9pbnRzLCBjb29yZFN5cywgaGFzQW5pbWF0aW9uKTtcblxuICAgICAgaWYgKGlzQXJlYUNoYXJ0KSB7XG4gICAgICAgIHBvbHlnb24gPSB0aGlzLl9uZXdQb2x5Z29uKHBvaW50cywgc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgaGFzQW5pbWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgbGluZUdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgdHJ1ZSwgc2VyaWVzTW9kZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJlYUNoYXJ0ICYmICFwb2x5Z29uKSB7XG4gICAgICAgIC8vIElmIGFyZWFTdHlsZSBpcyBhZGRlZFxuICAgICAgICBwb2x5Z29uID0gdGhpcy5fbmV3UG9seWdvbihwb2ludHMsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGhhc0FuaW1hdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKHBvbHlnb24gJiYgIWlzQXJlYUNoYXJ0KSB7XG4gICAgICAgIC8vIElmIGFyZWFTdHlsZSBpcyByZW1vdmVkXG4gICAgICAgIGxpbmVHcm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgICAgIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uID0gbnVsbDtcbiAgICAgIH0gLy8gVXBkYXRlIGNsaXBQYXRoXG5cblxuICAgICAgbGluZUdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgZmFsc2UsIHNlcmllc01vZGVsKSk7IC8vIEFsd2F5cyB1cGRhdGUsIG9yIGl0IGlzIHdyb25nIGluIHRoZSBjYXNlIHR1cm5pbmcgb24gbGVnZW5kXG4gICAgICAvLyBiZWNhdXNlIHBvaW50cyBhcmUgbm90IGNoYW5nZWRcblxuICAgICAgc2hvd1N5bWJvbCAmJiBzeW1ib2xEcmF3LnVwZGF0ZURhdGEoZGF0YSwgaXNTeW1ib2xJZ25vcmUpOyAvLyBTdG9wIHN5bWJvbCBhbmltYXRpb24gYW5kIHN5bmMgd2l0aCBsaW5lIHBvaW50c1xuICAgICAgLy8gRklYTUUgcGVyZm9ybWFuY2U/XG5cbiAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgICB9KTsgLy8gSW4gdGhlIGNhc2UgZGF0YSB6b29tIHRyaWdnZXJyZWQgcmVmcmVzaGluZyBmcmVxdWVudGx5XG4gICAgICAvLyBEYXRhIG1heSBub3QgY2hhbmdlIGlmIGxpbmUgaGFzIGEgY2F0ZWdvcnkgYXhpcy4gU28gaXQgc2hvdWxkIGFuaW1hdGUgbm90aGluZ1xuXG4gICAgICBpZiAoIWlzUG9pbnRzU2FtZSh0aGlzLl9zdGFja2VkT25Qb2ludHMsIHN0YWNrZWRPblBvaW50cykgfHwgIWlzUG9pbnRzU2FtZSh0aGlzLl9wb2ludHMsIHBvaW50cykpIHtcbiAgICAgICAgaWYgKGhhc0FuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvbihkYXRhLCBzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBhcGksIHN0ZXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vdCBkbyBpdCBpbiB1cGRhdGUgd2l0aCBhbmltYXRpb25cbiAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgLy8gVE9ETyBJZiBzdGFja2VkIHNlcmllcyBpcyBub3Qgc3RlcFxuICAgICAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvbHlsaW5lLnNldFNoYXBlKHtcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9seWdvbiAmJiBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25Qb2ludHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2aXN1YWxDb2xvciA9IGdldFZpc3VhbEdyYWRpZW50KGRhdGEsIGNvb3JkU3lzKSB8fCBkYXRhLmdldFZpc3VhbCgnY29sb3InKTtcbiAgICBwb2x5bGluZS51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoIC8vIFVzZSBjb2xvciBpbiBsaW5lU3R5bGUgZmlyc3RcbiAgICBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKSwge1xuICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgc3Ryb2tlOiB2aXN1YWxDb2xvcixcbiAgICAgIGxpbmVKb2luOiAnYmV2ZWwnXG4gICAgfSkpO1xuICAgIHZhciBzbW9vdGggPSBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aCcpO1xuICAgIHNtb290aCA9IGdldFNtb290aChzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aCcpKTtcbiAgICBwb2x5bGluZS5zZXRTaGFwZSh7XG4gICAgICBzbW9vdGg6IHNtb290aCxcbiAgICAgIHNtb290aE1vbm90b25lOiBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aE1vbm90b25lJyksXG4gICAgICBjb25uZWN0TnVsbHM6IHNlcmllc01vZGVsLmdldCgnY29ubmVjdE51bGxzJylcbiAgICB9KTtcblxuICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICB2YXIgc3RhY2tlZE9uID0gZGF0YS5zdGFja2VkT247XG4gICAgICB2YXIgc3RhY2tlZE9uU21vb3RoID0gMDtcbiAgICAgIHBvbHlnb24udXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpLCB7XG4gICAgICAgIGZpbGw6IHZpc3VhbENvbG9yLFxuICAgICAgICBvcGFjaXR5OiAwLjcsXG4gICAgICAgIGxpbmVKb2luOiAnYmV2ZWwnXG4gICAgICB9KSk7XG5cbiAgICAgIGlmIChzdGFja2VkT24pIHtcbiAgICAgICAgdmFyIHN0YWNrZWRPblNlcmllcyA9IHN0YWNrZWRPbi5ob3N0TW9kZWw7XG4gICAgICAgIHN0YWNrZWRPblNtb290aCA9IGdldFNtb290aChzdGFja2VkT25TZXJpZXMuZ2V0KCdzbW9vdGgnKSk7XG4gICAgICB9XG5cbiAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICBzbW9vdGg6IHNtb290aCxcbiAgICAgICAgc3RhY2tlZE9uU21vb3RoOiBzdGFja2VkT25TbW9vdGgsXG4gICAgICAgIHNtb290aE1vbm90b25lOiBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aE1vbm90b25lJyksXG4gICAgICAgIGNvbm5lY3ROdWxsczogc2VyaWVzTW9kZWwuZ2V0KCdjb25uZWN0TnVsbHMnKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7IC8vIFNhdmUgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGZvciB0cmFuc2l0aW9uIGFuaW1hdGlvbiB3aGVuIGRhdGEgY2hhbmdlZFxuXG4gICAgdGhpcy5fY29vcmRTeXMgPSBjb29yZFN5cztcbiAgICB0aGlzLl9zdGFja2VkT25Qb2ludHMgPSBzdGFja2VkT25Qb2ludHM7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICB9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fSxcbiAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgICBpZiAoIShkYXRhSW5kZXggaW5zdGFuY2VvZiBBcnJheSkgJiYgZGF0YUluZGV4ICE9IG51bGwgJiYgZGF0YUluZGV4ID49IDApIHtcbiAgICAgIHZhciBzeW1ib2wgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcblxuICAgICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHN5bWJvbCBpZiBpdCBpcyBub3QgZXhpc3RzXG4gICAgICAgIHZhciBwdCA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpO1xuXG4gICAgICAgIGlmICghcHQpIHtcbiAgICAgICAgICAvLyBOdWxsIGRhdGFcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzeW1ib2wgPSBuZXcgU3ltYm9sQ2x6KGRhdGEsIGRhdGFJbmRleCk7XG4gICAgICAgIHN5bWJvbC5wb3NpdGlvbiA9IHB0O1xuICAgICAgICBzeW1ib2wuc2V0WihzZXJpZXNNb2RlbC5nZXQoJ3psZXZlbCcpLCBzZXJpZXNNb2RlbC5nZXQoJ3onKSk7XG4gICAgICAgIHN5bWJvbC5pZ25vcmUgPSBpc05hTihwdFswXSkgfHwgaXNOYU4ocHRbMV0pO1xuICAgICAgICBzeW1ib2wuX190ZW1wID0gdHJ1ZTtcbiAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgc3ltYm9sKTsgLy8gU3RvcCBzY2FsZSBhbmltYXRpb25cblxuICAgICAgICBzeW1ib2wuc3RvcFN5bWJvbEFuaW1hdGlvbih0cnVlKTtcbiAgICAgICAgdGhpcy5ncm91cC5hZGQoc3ltYm9sKTtcbiAgICAgIH1cblxuICAgICAgc3ltYm9sLmhpZ2hsaWdodCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIaWdobGlnaHQgd2hvbGUgc2VyaWVzXG4gICAgICBDaGFydFZpZXcucHJvdG90eXBlLmhpZ2hsaWdodC5jYWxsKHRoaXMsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcbiAgZG93bnBsYXk6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcblxuICAgIGlmIChkYXRhSW5kZXggIT0gbnVsbCAmJiBkYXRhSW5kZXggPj0gMCkge1xuICAgICAgdmFyIHN5bWJvbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuXG4gICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgIGlmIChzeW1ib2wuX190ZW1wKSB7XG4gICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgbnVsbCk7XG4gICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmUoc3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzeW1ib2wuZG93bnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGSVhNRVxuICAgICAgLy8gY2FuIG5vdCBkb3ducGxheSBjb21wbGV0ZWx5LlxuICAgICAgLy8gRG93bnBsYXkgd2hvbGUgc2VyaWVzXG4gICAgICBDaGFydFZpZXcucHJvdG90eXBlLmRvd25wbGF5LmNhbGwodGhpcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9uZXdQb2x5bGluZTogZnVuY3Rpb24gKHBvaW50cykge1xuICAgIHZhciBwb2x5bGluZSA9IHRoaXMuX3BvbHlsaW5lOyAvLyBSZW1vdmUgcHJldmlvdXMgY3JlYXRlZCBwb2x5bGluZVxuXG4gICAgaWYgKHBvbHlsaW5lKSB7XG4gICAgICB0aGlzLl9saW5lR3JvdXAucmVtb3ZlKHBvbHlsaW5lKTtcbiAgICB9XG5cbiAgICBwb2x5bGluZSA9IG5ldyBQb2x5bGluZSh7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgfSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIHoyOiAxMFxuICAgIH0pO1xuXG4gICAgdGhpcy5fbGluZUdyb3VwLmFkZChwb2x5bGluZSk7XG5cbiAgICB0aGlzLl9wb2x5bGluZSA9IHBvbHlsaW5lO1xuICAgIHJldHVybiBwb2x5bGluZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gc3RhY2tlZE9uUG9pbnRzXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcG9pbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbmV3UG9seWdvbjogZnVuY3Rpb24gKHBvaW50cywgc3RhY2tlZE9uUG9pbnRzKSB7XG4gICAgdmFyIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uOyAvLyBSZW1vdmUgcHJldmlvdXMgY3JlYXRlZCBwb2x5Z29uXG5cbiAgICBpZiAocG9seWdvbikge1xuICAgICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZShwb2x5Z29uKTtcbiAgICB9XG5cbiAgICBwb2x5Z29uID0gbmV3IFBvbHlnb24oe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgIHN0YWNrZWRPblBvaW50czogc3RhY2tlZE9uUG9pbnRzXG4gICAgICB9LFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSk7XG5cbiAgICB0aGlzLl9saW5lR3JvdXAuYWRkKHBvbHlnb24pO1xuXG4gICAgdGhpcy5fcG9seWdvbiA9IHBvbHlnb247XG4gICAgcmV0dXJuIHBvbHlnb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0U3ltYm9sSWdub3JlRnVuYzogZnVuY3Rpb24gKGRhdGEsIGNvb3JkU3lzKSB7XG4gICAgdmFyIGNhdGVnb3J5QXhpcyA9IGNvb3JkU3lzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF07IC8vIGBnZXRMYWJlbEludGVydmFsYCBpcyBwcm92aWRlZCBieSBlY2hhcnRzL2NvbXBvbmVudC9heGlzXG5cbiAgICBpZiAoY2F0ZWdvcnlBeGlzICYmIGNhdGVnb3J5QXhpcy5pc0xhYmVsSWdub3JlZCkge1xuICAgICAgcmV0dXJuIHpyVXRpbC5iaW5kKGNhdGVnb3J5QXhpcy5pc0xhYmVsSWdub3JlZCwgY2F0ZWdvcnlBeGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvLyBGSVhNRSBUd28gdmFsdWUgYXhpc1xuICBfdXBkYXRlQW5pbWF0aW9uOiBmdW5jdGlvbiAoZGF0YSwgc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgYXBpLCBzdGVwKSB7XG4gICAgdmFyIHBvbHlsaW5lID0gdGhpcy5fcG9seWxpbmU7XG4gICAgdmFyIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uO1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBkaWZmID0gbGluZUFuaW1hdGlvbkRpZmYodGhpcy5fZGF0YSwgZGF0YSwgdGhpcy5fc3RhY2tlZE9uUG9pbnRzLCBzdGFja2VkT25Qb2ludHMsIHRoaXMuX2Nvb3JkU3lzLCBjb29yZFN5cyk7XG4gICAgdmFyIGN1cnJlbnQgPSBkaWZmLmN1cnJlbnQ7XG4gICAgdmFyIHN0YWNrZWRPbkN1cnJlbnQgPSBkaWZmLnN0YWNrZWRPbkN1cnJlbnQ7XG4gICAgdmFyIG5leHQgPSBkaWZmLm5leHQ7XG4gICAgdmFyIHN0YWNrZWRPbk5leHQgPSBkaWZmLnN0YWNrZWRPbk5leHQ7XG5cbiAgICBpZiAoc3RlcCkge1xuICAgICAgLy8gVE9ETyBJZiBzdGFja2VkIHNlcmllcyBpcyBub3Qgc3RlcFxuICAgICAgY3VycmVudCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLmN1cnJlbnQsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgIHN0YWNrZWRPbkN1cnJlbnQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5zdGFja2VkT25DdXJyZW50LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICBuZXh0ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYubmV4dCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgc3RhY2tlZE9uTmV4dCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLnN0YWNrZWRPbk5leHQsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICB9IC8vIGBkaWZmLmN1cnJlbnRgIGlzIHN1YnNldCBvZiBgY3VycmVudGAgKHdoaWNoIHNob3VsZCBiZSBlbnN1cmVkIGJ5XG4gICAgLy8gdHVyblBvaW50c0ludG9TdGVwKSwgc28gcG9pbnRzIGluIGBfX3BvaW50c2AgY2FuIGJlIHVwZGF0ZWQgd2hlblxuICAgIC8vIHBvaW50cyBpbiBgY3VycmVudGAgYXJlIHVwZGF0ZSBkdXJpbmcgYW5pbWF0aW9uLlxuXG5cbiAgICBwb2x5bGluZS5zaGFwZS5fX3BvaW50cyA9IGRpZmYuY3VycmVudDtcbiAgICBwb2x5bGluZS5zaGFwZS5wb2ludHMgPSBjdXJyZW50O1xuICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWxpbmUsIHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHBvaW50czogbmV4dFxuICAgICAgfVxuICAgIH0sIHNlcmllc01vZGVsKTtcblxuICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgcG9pbnRzOiBjdXJyZW50LFxuICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPbkN1cnJlbnRcbiAgICAgIH0pO1xuICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5Z29uLCB7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgcG9pbnRzOiBuZXh0LFxuICAgICAgICAgIHN0YWNrZWRPblBvaW50czogc3RhY2tlZE9uTmV4dFxuICAgICAgICB9XG4gICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZWREYXRhSW5mbyA9IFtdO1xuICAgIHZhciBkaWZmU3RhdHVzID0gZGlmZi5zdGF0dXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmZTdGF0dXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjbWQgPSBkaWZmU3RhdHVzW2ldLmNtZDtcblxuICAgICAgaWYgKGNtZCA9PT0gJz0nKSB7XG4gICAgICAgIHZhciBlbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkaWZmU3RhdHVzW2ldLmlkeDEpO1xuXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIHVwZGF0ZWREYXRhSW5mby5wdXNoKHtcbiAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgIHB0SWR4OiBpIC8vIEluZGV4IG9mIHBvaW50c1xuXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9seWxpbmUuYW5pbWF0b3JzICYmIHBvbHlsaW5lLmFuaW1hdG9ycy5sZW5ndGgpIHtcbiAgICAgIHBvbHlsaW5lLmFuaW1hdG9yc1swXS5kdXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZWREYXRhSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbCA9IHVwZGF0ZWREYXRhSW5mb1tpXS5lbDtcbiAgICAgICAgICBlbC5hdHRyKCdwb3NpdGlvbicsIHBvbHlsaW5lLnNoYXBlLl9fcG9pbnRzW3VwZGF0ZWREYXRhSW5mb1tpXS5wdElkeF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcblxuICAgIHRoaXMuX2xpbmVHcm91cC5yZW1vdmVBbGwoKTtcblxuICAgIHRoaXMuX3N5bWJvbERyYXcucmVtb3ZlKHRydWUpOyAvLyBSZW1vdmUgdGVtcG9yYXJ5IGNyZWF0ZWQgZWxlbWVudHMgd2hlbiBoaWdobGlnaHRpbmdcblxuXG4gICAgb2xkRGF0YSAmJiBvbGREYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBpZiAoZWwuX190ZW1wKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIG9sZERhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3BvbHlsaW5lID0gdGhpcy5fcG9seWdvbiA9IHRoaXMuX2Nvb3JkU3lzID0gdGhpcy5fcG9pbnRzID0gdGhpcy5fc3RhY2tlZE9uUG9pbnRzID0gdGhpcy5fZGF0YSA9IG51bGw7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVZpZXcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyB2YXIgYXJyYXlEaWZmID0gcmVxdWlyZSgnenJlbmRlci9zcmMvY29yZS9hcnJheURpZmYnKTtcbi8vICd6cmVuZGVyL3NyYy9jb3JlL2FycmF5RGlmZicgaGFzIGJlZW4gdXNlZCBiZWZvcmUsIGJ1dCBpdCBkaWRcbi8vIG5vdCBkbyB3ZWxsIGluIHBlcmZvcm1hbmNlIHdoZW4gcm9hbSB3aXRoIGZpeGVkIGRhdGFab29tIHdpbmRvdy5cbmZ1bmN0aW9uIHNpZ24odmFsKSB7XG4gIHJldHVybiB2YWwgPj0gMCA/IDEgOiAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tlZE9uUG9pbnQoY29vcmRTeXMsIGRhdGEsIGlkeCkge1xuICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICB2YXIgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgdmFyIHZhbHVlU3RhcnQgPSBiYXNlQXhpcy5vblplcm8gPyAwIDogdmFsdWVBeGlzLnNjYWxlLmdldEV4dGVudCgpWzBdO1xuICB2YXIgdmFsdWVEaW0gPSB2YWx1ZUF4aXMuZGltO1xuICB2YXIgYmFzZURhdGFPZmZzZXQgPSB2YWx1ZURpbSA9PT0gJ3gnIHx8IHZhbHVlRGltID09PSAncmFkaXVzJyA/IDEgOiAwO1xuICB2YXIgc3RhY2tlZE9uU2FtZVNpZ247XG4gIHZhciBzdGFja2VkT24gPSBkYXRhLnN0YWNrZWRPbjtcbiAgdmFyIHZhbCA9IGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpOyAvLyBGaW5kIGZpcnN0IHN0YWNrZWQgdmFsdWUgd2l0aCBzYW1lIHNpZ25cblxuICB3aGlsZSAoc3RhY2tlZE9uICYmIHNpZ24oc3RhY2tlZE9uLmdldCh2YWx1ZURpbSwgaWR4KSkgPT09IHNpZ24odmFsKSkge1xuICAgIHN0YWNrZWRPblNhbWVTaWduID0gc3RhY2tlZE9uO1xuICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIHN0YWNrZWREYXRhID0gW107XG4gIHN0YWNrZWREYXRhW2Jhc2VEYXRhT2Zmc2V0XSA9IGRhdGEuZ2V0KGJhc2VBeGlzLmRpbSwgaWR4KTtcbiAgc3RhY2tlZERhdGFbMSAtIGJhc2VEYXRhT2Zmc2V0XSA9IHN0YWNrZWRPblNhbWVTaWduID8gc3RhY2tlZE9uU2FtZVNpZ24uZ2V0KHZhbHVlRGltLCBpZHgsIHRydWUpIDogdmFsdWVTdGFydDtcbiAgcmV0dXJuIGNvb3JkU3lzLmRhdGFUb1BvaW50KHN0YWNrZWREYXRhKTtcbn0gLy8gZnVuY3Rpb24gY29udmVydFRvSW50SWQobmV3SWRMaXN0LCBvbGRJZExpc3QpIHtcbi8vICAgICAvLyBHZW5lcmF0ZSBpbnQgaWQgaW5zdGVhZCBvZiBzdHJpbmcgaWQuXG4vLyAgICAgLy8gQ29tcGFyZSBzdHJpbmcgbWF5YmUgc2xvdyBpbiBzY29yZSBmdW5jdGlvbiBvZiBhcnJEaWZmXG4vLyAgICAgLy8gQXNzdW1lIGlkIGluIGlkTGlzdCBhcmUgYWxsIHVuaXF1ZVxuLy8gICAgIHZhciBpZEluZGljZXNNYXAgPSB7fTtcbi8vICAgICB2YXIgaWR4ID0gMDtcbi8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0lkTGlzdC5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICBpZEluZGljZXNNYXBbbmV3SWRMaXN0W2ldXSA9IGlkeDtcbi8vICAgICAgICAgbmV3SWRMaXN0W2ldID0gaWR4Kys7XG4vLyAgICAgfVxuLy8gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkSWRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgIHZhciBvbGRJZCA9IG9sZElkTGlzdFtpXTtcbi8vICAgICAgICAgLy8gU2FtZSB3aXRoIG5ld0lkTGlzdFxuLy8gICAgICAgICBpZiAoaWRJbmRpY2VzTWFwW29sZElkXSkge1xuLy8gICAgICAgICAgICAgb2xkSWRMaXN0W2ldID0gaWRJbmRpY2VzTWFwW29sZElkXTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgIG9sZElkTGlzdFtpXSA9IGlkeCsrO1xuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gfVxuXG5cbmZ1bmN0aW9uIGRpZmZEYXRhKG9sZERhdGEsIG5ld0RhdGEpIHtcbiAgdmFyIGRpZmZSZXN1bHQgPSBbXTtcbiAgbmV3RGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgZGlmZlJlc3VsdC5wdXNoKHtcbiAgICAgIGNtZDogJysnLFxuICAgICAgaWR4OiBpZHhcbiAgICB9KTtcbiAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgIGRpZmZSZXN1bHQucHVzaCh7XG4gICAgICBjbWQ6ICc9JyxcbiAgICAgIGlkeDogb2xkSWR4LFxuICAgICAgaWR4MTogbmV3SWR4XG4gICAgfSk7XG4gIH0pLnJlbW92ZShmdW5jdGlvbiAoaWR4KSB7XG4gICAgZGlmZlJlc3VsdC5wdXNoKHtcbiAgICAgIGNtZDogJy0nLFxuICAgICAgaWR4OiBpZHhcbiAgICB9KTtcbiAgfSkuZXhlY3V0ZSgpO1xuICByZXR1cm4gZGlmZlJlc3VsdDtcbn1cblxuZnVuY3Rpb24gX2RlZmF1bHQob2xkRGF0YSwgbmV3RGF0YSwgb2xkU3RhY2tlZE9uUG9pbnRzLCBuZXdTdGFja2VkT25Qb2ludHMsIG9sZENvb3JkU3lzLCBuZXdDb29yZFN5cykge1xuICB2YXIgZGlmZiA9IGRpZmZEYXRhKG9sZERhdGEsIG5ld0RhdGEpOyAvLyB2YXIgbmV3SWRMaXN0ID0gbmV3RGF0YS5tYXBBcnJheShuZXdEYXRhLmdldElkKTtcbiAgLy8gdmFyIG9sZElkTGlzdCA9IG9sZERhdGEubWFwQXJyYXkob2xkRGF0YS5nZXRJZCk7XG4gIC8vIGNvbnZlcnRUb0ludElkKG5ld0lkTGlzdCwgb2xkSWRMaXN0KTtcbiAgLy8gLy8gRklYTUUgT25lIGRhdGEgP1xuICAvLyBkaWZmID0gYXJyYXlEaWZmKG9sZElkTGlzdCwgbmV3SWRMaXN0KTtcblxuICB2YXIgY3VyclBvaW50cyA9IFtdO1xuICB2YXIgbmV4dFBvaW50cyA9IFtdOyAvLyBQb2ludHMgZm9yIHN0YWNraW5nIGJhc2UgbGluZVxuXG4gIHZhciBjdXJyU3RhY2tlZFBvaW50cyA9IFtdO1xuICB2YXIgbmV4dFN0YWNrZWRQb2ludHMgPSBbXTtcbiAgdmFyIHN0YXR1cyA9IFtdO1xuICB2YXIgc29ydGVkSW5kaWNlcyA9IFtdO1xuICB2YXIgcmF3SW5kaWNlcyA9IFtdO1xuICB2YXIgZGltcyA9IG5ld0Nvb3JkU3lzLmRpbWVuc2lvbnM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpZmZJdGVtID0gZGlmZltpXTtcbiAgICB2YXIgcG9pbnRBZGRlZCA9IHRydWU7IC8vIEZJWE1FLCBhbmltYXRpb24gaXMgbm90IHNvIHBlcmZlY3Qgd2hlbiBkYXRhWm9vbSB3aW5kb3cgbW92ZXMgZmFzdFxuICAgIC8vIFdoaWNoIGlzIGluIGNhc2UgcmVtdm9pbmcgb3IgYWRkIG1vcmUgdGhhbiBvbmUgZGF0YSBpbiB0aGUgdGFpbCBvciBoZWFkXG5cbiAgICBzd2l0Y2ggKGRpZmZJdGVtLmNtZCkge1xuICAgICAgY2FzZSAnPSc6XG4gICAgICAgIHZhciBjdXJyZW50UHQgPSBvbGREYXRhLmdldEl0ZW1MYXlvdXQoZGlmZkl0ZW0uaWR4KTtcbiAgICAgICAgdmFyIG5leHRQdCA9IG5ld0RhdGEuZ2V0SXRlbUxheW91dChkaWZmSXRlbS5pZHgxKTsgLy8gSWYgcHJldmlvdXMgZGF0YSBpcyBOYU4sIHVzZSBuZXh0IHBvaW50IGRpcmVjdGx5XG5cbiAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRQdFswXSkgfHwgaXNOYU4oY3VycmVudFB0WzFdKSkge1xuICAgICAgICAgIGN1cnJlbnRQdCA9IG5leHRQdC5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyclBvaW50cy5wdXNoKGN1cnJlbnRQdCk7XG4gICAgICAgIG5leHRQb2ludHMucHVzaChuZXh0UHQpO1xuICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKG9sZFN0YWNrZWRPblBvaW50c1tkaWZmSXRlbS5pZHhdKTtcbiAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChuZXdTdGFja2VkT25Qb2ludHNbZGlmZkl0ZW0uaWR4MV0pO1xuICAgICAgICByYXdJbmRpY2VzLnB1c2gobmV3RGF0YS5nZXRSYXdJbmRleChkaWZmSXRlbS5pZHgxKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcrJzpcbiAgICAgICAgdmFyIGlkeCA9IGRpZmZJdGVtLmlkeDtcbiAgICAgICAgY3VyclBvaW50cy5wdXNoKG9sZENvb3JkU3lzLmRhdGFUb1BvaW50KFtuZXdEYXRhLmdldChkaW1zWzBdLCBpZHgsIHRydWUpLCBuZXdEYXRhLmdldChkaW1zWzFdLCBpZHgsIHRydWUpXSkpO1xuICAgICAgICBuZXh0UG9pbnRzLnB1c2gobmV3RGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkuc2xpY2UoKSk7XG4gICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2goZ2V0U3RhY2tlZE9uUG9pbnQob2xkQ29vcmRTeXMsIG5ld0RhdGEsIGlkeCkpO1xuICAgICAgICBuZXh0U3RhY2tlZFBvaW50cy5wdXNoKG5ld1N0YWNrZWRPblBvaW50c1tpZHhdKTtcbiAgICAgICAgcmF3SW5kaWNlcy5wdXNoKG5ld0RhdGEuZ2V0UmF3SW5kZXgoaWR4KSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICctJzpcbiAgICAgICAgdmFyIGlkeCA9IGRpZmZJdGVtLmlkeDtcbiAgICAgICAgdmFyIHJhd0luZGV4ID0gb2xkRGF0YS5nZXRSYXdJbmRleChpZHgpOyAvLyBEYXRhIGlzIHJlcGxhY2VkLiBJbiB0aGUgY2FzZSBvZiBkeW5hbWljIGRhdGEgcXVldWVcbiAgICAgICAgLy8gRklYTUUgRklYTUUgRklYTUVcblxuICAgICAgICBpZiAocmF3SW5kZXggIT09IGlkeCkge1xuICAgICAgICAgIGN1cnJQb2ludHMucHVzaChvbGREYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSk7XG4gICAgICAgICAgbmV4dFBvaW50cy5wdXNoKG5ld0Nvb3JkU3lzLmRhdGFUb1BvaW50KFtvbGREYXRhLmdldChkaW1zWzBdLCBpZHgsIHRydWUpLCBvbGREYXRhLmdldChkaW1zWzFdLCBpZHgsIHRydWUpXSkpO1xuICAgICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2gob2xkU3RhY2tlZE9uUG9pbnRzW2lkeF0pO1xuICAgICAgICAgIG5leHRTdGFja2VkUG9pbnRzLnB1c2goZ2V0U3RhY2tlZE9uUG9pbnQobmV3Q29vcmRTeXMsIG9sZERhdGEsIGlkeCkpO1xuICAgICAgICAgIHJhd0luZGljZXMucHVzaChyYXdJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRBZGRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICB9IC8vIE9yaWdpbmFsIGluZGljZXNcblxuXG4gICAgaWYgKHBvaW50QWRkZWQpIHtcbiAgICAgIHN0YXR1cy5wdXNoKGRpZmZJdGVtKTtcbiAgICAgIHNvcnRlZEluZGljZXMucHVzaChzb3J0ZWRJbmRpY2VzLmxlbmd0aCk7XG4gICAgfVxuICB9IC8vIERpZmYgcmVzdWx0IG1heSBiZSBjcm9zc2VkIGlmIGFsbCBpdGVtcyBhcmUgY2hhbmdlZFxuICAvLyBTb3J0IGJ5IGRhdGEgaW5kZXhcblxuXG4gIHNvcnRlZEluZGljZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiByYXdJbmRpY2VzW2FdIC0gcmF3SW5kaWNlc1tiXTtcbiAgfSk7XG4gIHZhciBzb3J0ZWRDdXJyUG9pbnRzID0gW107XG4gIHZhciBzb3J0ZWROZXh0UG9pbnRzID0gW107XG4gIHZhciBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50cyA9IFtdO1xuICB2YXIgc29ydGVkTmV4dFN0YWNrZWRQb2ludHMgPSBbXTtcbiAgdmFyIHNvcnRlZFN0YXR1cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc29ydGVkSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZHggPSBzb3J0ZWRJbmRpY2VzW2ldO1xuICAgIHNvcnRlZEN1cnJQb2ludHNbaV0gPSBjdXJyUG9pbnRzW2lkeF07XG4gICAgc29ydGVkTmV4dFBvaW50c1tpXSA9IG5leHRQb2ludHNbaWR4XTtcbiAgICBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50c1tpXSA9IGN1cnJTdGFja2VkUG9pbnRzW2lkeF07XG4gICAgc29ydGVkTmV4dFN0YWNrZWRQb2ludHNbaV0gPSBuZXh0U3RhY2tlZFBvaW50c1tpZHhdO1xuICAgIHNvcnRlZFN0YXR1c1tpXSA9IHN0YXR1c1tpZHhdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBzb3J0ZWRDdXJyUG9pbnRzLFxuICAgIG5leHQ6IHNvcnRlZE5leHRQb2ludHMsXG4gICAgc3RhY2tlZE9uQ3VycmVudDogc29ydGVkQ3VyclN0YWNrZWRQb2ludHMsXG4gICAgc3RhY2tlZE9uTmV4dDogc29ydGVkTmV4dFN0YWNrZWRQb2ludHMsXG4gICAgc3RhdHVzOiBzb3J0ZWRTdGF0dXNcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL2xpbmVBbmltYXRpb25EaWZmLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL2xpbmVBbmltYXRpb25EaWZmLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9QYXRoXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIGZpeENsaXBXaXRoU2hhZG93ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93XCIpO1xuXG4vLyBQb2x5IHBhdGggc3VwcG9ydCBOYU4gcG9pbnRcbnZhciB2ZWMyTWluID0gdmVjMi5taW47XG52YXIgdmVjMk1heCA9IHZlYzIubWF4O1xudmFyIHNjYWxlQW5kQWRkID0gdmVjMi5zY2FsZUFuZEFkZDtcbnZhciB2MkNvcHkgPSB2ZWMyLmNvcHk7IC8vIFRlbXBvcmFyeSB2YXJpYWJsZVxuXG52YXIgdiA9IFtdO1xudmFyIGNwMCA9IFtdO1xudmFyIGNwMSA9IFtdO1xuXG5mdW5jdGlvbiBpc1BvaW50TnVsbChwKSB7XG4gIHJldHVybiBpc05hTihwWzBdKSB8fCBpc05hTihwWzFdKTtcbn1cblxuZnVuY3Rpb24gZHJhd1NlZ21lbnQoY3R4LCBwb2ludHMsIHN0YXJ0LCBzZWdMZW4sIGFsbExlbiwgZGlyLCBzbW9vdGhNaW4sIHNtb290aE1heCwgc21vb3RoLCBzbW9vdGhNb25vdG9uZSwgY29ubmVjdE51bGxzKSB7XG4gIHZhciBwcmV2SWR4ID0gMDtcbiAgdmFyIGlkeCA9IHN0YXJ0O1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc2VnTGVuOyBrKyspIHtcbiAgICB2YXIgcCA9IHBvaW50c1tpZHhdO1xuXG4gICAgaWYgKGlkeCA+PSBhbGxMZW4gfHwgaWR4IDwgMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlzUG9pbnROdWxsKHApKSB7XG4gICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaWR4ID09PSBzdGFydCkge1xuICAgICAgY3R4W2RpciA+IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShwWzBdLCBwWzFdKTtcbiAgICAgIHYyQ29weShjcDAsIHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc21vb3RoID4gMCkge1xuICAgICAgICB2YXIgbmV4dElkeCA9IGlkeCArIGRpcjtcbiAgICAgICAgdmFyIG5leHRQID0gcG9pbnRzW25leHRJZHhdO1xuXG4gICAgICAgIGlmIChjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAvLyBGaW5kIG5leHQgcG9pbnQgbm90IG51bGxcbiAgICAgICAgICB3aGlsZSAobmV4dFAgJiYgaXNQb2ludE51bGwocG9pbnRzW25leHRJZHhdKSkge1xuICAgICAgICAgICAgbmV4dElkeCArPSBkaXI7XG4gICAgICAgICAgICBuZXh0UCA9IHBvaW50c1tuZXh0SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmF0aW9OZXh0U2VnID0gMC41O1xuICAgICAgICB2YXIgcHJldlAgPSBwb2ludHNbcHJldklkeF07XG4gICAgICAgIHZhciBuZXh0UCA9IHBvaW50c1tuZXh0SWR4XTsgLy8gTGFzdCBwb2ludFxuXG4gICAgICAgIGlmICghbmV4dFAgfHwgaXNQb2ludE51bGwobmV4dFApKSB7XG4gICAgICAgICAgdjJDb3B5KGNwMSwgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgbmV4dCBkYXRhIGlzIG51bGwgaW4gbm90IGNvbm5lY3QgY2FzZVxuICAgICAgICAgIGlmIChpc1BvaW50TnVsbChuZXh0UCkgJiYgIWNvbm5lY3ROdWxscykge1xuICAgICAgICAgICAgbmV4dFAgPSBwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZlYzIuc3ViKHYsIG5leHRQLCBwcmV2UCk7XG4gICAgICAgICAgdmFyIGxlblByZXZTZWc7XG4gICAgICAgICAgdmFyIGxlbk5leHRTZWc7XG5cbiAgICAgICAgICBpZiAoc21vb3RoTW9ub3RvbmUgPT09ICd4JyB8fCBzbW9vdGhNb25vdG9uZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICB2YXIgZGltID0gc21vb3RoTW9ub3RvbmUgPT09ICd4JyA/IDAgOiAxO1xuICAgICAgICAgICAgbGVuUHJldlNlZyA9IE1hdGguYWJzKHBbZGltXSAtIHByZXZQW2RpbV0pO1xuICAgICAgICAgICAgbGVuTmV4dFNlZyA9IE1hdGguYWJzKHBbZGltXSAtIG5leHRQW2RpbV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5QcmV2U2VnID0gdmVjMi5kaXN0KHAsIHByZXZQKTtcbiAgICAgICAgICAgIGxlbk5leHRTZWcgPSB2ZWMyLmRpc3QocCwgbmV4dFApO1xuICAgICAgICAgIH0gLy8gVXNlIHJhdGlvIG9mIHNlZyBsZW5ndGhcblxuXG4gICAgICAgICAgcmF0aW9OZXh0U2VnID0gbGVuTmV4dFNlZyAvIChsZW5OZXh0U2VnICsgbGVuUHJldlNlZyk7XG4gICAgICAgICAgc2NhbGVBbmRBZGQoY3AxLCBwLCB2LCAtc21vb3RoICogKDEgLSByYXRpb05leHRTZWcpKTtcbiAgICAgICAgfSAvLyBTbW9vdGggY29uc3RyYWludFxuXG5cbiAgICAgICAgdmVjMk1pbihjcDAsIGNwMCwgc21vb3RoTWF4KTtcbiAgICAgICAgdmVjMk1heChjcDAsIGNwMCwgc21vb3RoTWluKTtcbiAgICAgICAgdmVjMk1pbihjcDEsIGNwMSwgc21vb3RoTWF4KTtcbiAgICAgICAgdmVjMk1heChjcDEsIGNwMSwgc21vb3RoTWluKTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AwWzBdLCBjcDBbMV0sIGNwMVswXSwgY3AxWzFdLCBwWzBdLCBwWzFdKTsgLy8gY3AwIG9mIG5leHQgc2VnbWVudFxuXG4gICAgICAgIHNjYWxlQW5kQWRkKGNwMCwgcCwgdiwgc21vb3RoICogcmF0aW9OZXh0U2VnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5saW5lVG8ocFswXSwgcFsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldklkeCA9IGlkeDtcbiAgICBpZHggKz0gZGlyO1xuICB9XG5cbiAgcmV0dXJuIGs7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KHBvaW50cywgc21vb3RoQ29uc3RyYWludCkge1xuICB2YXIgcHRNaW4gPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgdmFyIHB0TWF4ID0gWy1JbmZpbml0eSwgLUluZmluaXR5XTtcblxuICBpZiAoc21vb3RoQ29uc3RyYWludCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG5cbiAgICAgIGlmIChwdFswXSA8IHB0TWluWzBdKSB7XG4gICAgICAgIHB0TWluWzBdID0gcHRbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChwdFsxXSA8IHB0TWluWzFdKSB7XG4gICAgICAgIHB0TWluWzFdID0gcHRbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChwdFswXSA+IHB0TWF4WzBdKSB7XG4gICAgICAgIHB0TWF4WzBdID0gcHRbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChwdFsxXSA+IHB0TWF4WzFdKSB7XG4gICAgICAgIHB0TWF4WzFdID0gcHRbMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW46IHNtb290aENvbnN0cmFpbnQgPyBwdE1pbiA6IHB0TWF4LFxuICAgIG1heDogc21vb3RoQ29uc3RyYWludCA/IHB0TWF4IDogcHRNaW5cbiAgfTtcbn1cblxudmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnZWMtcG9seWxpbmUnLFxuICBzaGFwZToge1xuICAgIHBvaW50czogW10sXG4gICAgc21vb3RoOiAwLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IHRydWUsXG4gICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG4gICAgY29ubmVjdE51bGxzOiBmYWxzZVxuICB9LFxuICBzdHlsZToge1xuICAgIGZpbGw6IG51bGwsXG4gICAgc3Ryb2tlOiAnIzAwMCdcbiAgfSxcbiAgYnJ1c2g6IGZpeENsaXBXaXRoU2hhZG93KFBhdGgucHJvdG90eXBlLmJydXNoKSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBnZXRCb3VuZGluZ0JveChwb2ludHMsIHNoYXBlLnNtb290aENvbnN0cmFpbnQpO1xuXG4gICAgaWYgKHNoYXBlLmNvbm5lY3ROdWxscykge1xuICAgICAgLy8gTXVzdCByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbnVsbCB2YWx1ZXMgYXZvaWQgZHJhdyBlcnJvciBpbiBwb2x5Z29uXG4gICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgaWYgKCFpc1BvaW50TnVsbChwb2ludHNbbGVuIC0gMV0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWlzUG9pbnROdWxsKHBvaW50c1tpXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpICs9IGRyYXdTZWdtZW50KGN0eCwgcG9pbnRzLCBpLCBsZW4sIGxlbiwgMSwgcmVzdWx0Lm1pbiwgcmVzdWx0Lm1heCwgc2hhcGUuc21vb3RoLCBzaGFwZS5zbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzKSArIDE7XG4gICAgfVxuICB9XG59KTtcbnZhciBQb2x5Z29uID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnZWMtcG9seWdvbicsXG4gIHNoYXBlOiB7XG4gICAgcG9pbnRzOiBbXSxcbiAgICAvLyBPZmZzZXQgYmV0d2VlbiBzdGFja2VkIGJhc2UgcG9pbnRzIGFuZCBwb2ludHNcbiAgICBzdGFja2VkT25Qb2ludHM6IFtdLFxuICAgIHNtb290aDogMCxcbiAgICBzdGFja2VkT25TbW9vdGg6IDAsXG4gICAgc21vb3RoQ29uc3RyYWludDogdHJ1ZSxcbiAgICBzbW9vdGhNb25vdG9uZTogbnVsbCxcbiAgICBjb25uZWN0TnVsbHM6IGZhbHNlXG4gIH0sXG4gIGJydXNoOiBmaXhDbGlwV2l0aFNoYWRvdyhQYXRoLnByb3RvdHlwZS5icnVzaCksXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgIHZhciBzdGFja2VkT25Qb2ludHMgPSBzaGFwZS5zdGFja2VkT25Qb2ludHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciBzbW9vdGhNb25vdG9uZSA9IHNoYXBlLnNtb290aE1vbm90b25lO1xuICAgIHZhciBiYm94ID0gZ2V0Qm91bmRpbmdCb3gocG9pbnRzLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcbiAgICB2YXIgc3RhY2tlZE9uQkJveCA9IGdldEJvdW5kaW5nQm94KHN0YWNrZWRPblBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG5cbiAgICBpZiAoc2hhcGUuY29ubmVjdE51bGxzKSB7XG4gICAgICAvLyBNdXN0IHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBudWxsIHZhbHVlcyBhdm9pZCBkcmF3IGVycm9yIGluIHBvbHlnb25cbiAgICAgIGZvciAoOyBsZW4gPiAwOyBsZW4tLSkge1xuICAgICAgICBpZiAoIWlzUG9pbnROdWxsKHBvaW50c1tsZW4gLSAxXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2ldKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHZhciBrID0gZHJhd1NlZ21lbnQoY3R4LCBwb2ludHMsIGksIGxlbiwgbGVuLCAxLCBiYm94Lm1pbiwgYmJveC5tYXgsIHNoYXBlLnNtb290aCwgc21vb3RoTW9ub3RvbmUsIHNoYXBlLmNvbm5lY3ROdWxscyk7XG4gICAgICBkcmF3U2VnbWVudChjdHgsIHN0YWNrZWRPblBvaW50cywgaSArIGsgLSAxLCBrLCBsZW4sIC0xLCBzdGFja2VkT25CQm94Lm1pbiwgc3RhY2tlZE9uQkJveC5tYXgsIHNoYXBlLnN0YWNrZWRPblNtb290aCwgc21vb3RoTW9ub3RvbmUsIHNoYXBlLmNvbm5lY3ROdWxscyk7XG4gICAgICBpICs9IGsgKyAxO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxufSk7XG5leHBvcnRzLlBvbHlsaW5lID0gUG9seWxpbmU7XG5leHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvcG9seS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9wb2x5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZShcIi4uL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL2F4aXMvQ2FydGVzaWFuQXhpc1ZpZXdcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF91dGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIHJldHJpZXZlID0gX3V0aWwucmV0cmlldmU7XG52YXIgZGVmYXVsdHMgPSBfdXRpbC5kZWZhdWx0cztcbnZhciBleHRlbmQgPSBfdXRpbC5leHRlbmQ7XG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG5cbnZhciBmb3JtYXRVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZm9ybWF0XCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIF9udW1iZXIgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBpc1JhZGlhbkFyb3VuZFplcm8gPSBfbnVtYmVyLmlzUmFkaWFuQXJvdW5kWmVybztcbnZhciByZW1SYWRpYW4gPSBfbnVtYmVyLnJlbVJhZGlhbjtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9zeW1ib2xcIik7XG5cbnZhciBjcmVhdGVTeW1ib2wgPSBfc3ltYm9sLmNyZWF0ZVN5bWJvbDtcblxudmFyIG1hdHJpeFV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9tYXRyaXhcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJBcHBseVRyYW5zZm9ybSA9IF92ZWN0b3IuYXBwbHlUcmFuc2Zvcm07XG52YXIgUEkgPSBNYXRoLlBJO1xuXG5mdW5jdGlvbiBtYWtlQXhpc0V2ZW50RGF0YUJhc2UoYXhpc01vZGVsKSB7XG4gIHZhciBldmVudERhdGEgPSB7XG4gICAgY29tcG9uZW50VHlwZTogYXhpc01vZGVsLm1haW5UeXBlXG4gIH07XG4gIGV2ZW50RGF0YVtheGlzTW9kZWwubWFpblR5cGUgKyAnSW5kZXgnXSA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcbiAgcmV0dXJuIGV2ZW50RGF0YTtcbn1cbi8qKlxuICogQSBmaW5hbCBheGlzIGlzIHRyYW5zbGF0ZWQgYW5kIHJvdGF0ZWQgZnJvbSBhIFwic3RhbmRhcmQgYXhpc1wiLlxuICogU28gb3B0LnBvc2l0aW9uIGFuZCBvcHQucm90YXRpb24gaXMgcmVxdWlyZWQuXG4gKlxuICogQSBzdGFuZGFyZCBheGlzIGlzIGFuZCBheGlzIGZyb20gWzAsIDBdIHRvIFswLCBheGlzRXh0ZW50WzFdXSxcbiAqIGZvciBleGFtcGxlOiAoMCwgMCkgLS0tLS0tLS0tLS0tPiAoMCwgNTApXG4gKlxuICogbmFtZURpcmVjdGlvbiBvciB0aWNrRGlyZWN0aW9uIG9yIGxhYmVsRGlyZWN0aW9uIGlzIDEgbWVhbnMgdGlja1xuICogb3IgbGFiZWwgaXMgYmVsb3cgdGhlIHN0YW5kYXJkIGF4aXMsIHdoZXJlYXMgaXMgLTEgbWVhbnMgYWJvdmVcbiAqIHRoZSBzdGFuZGFyZCBheGlzLiBsYWJlbE9mZnNldCBtZWFucyBvZmZzZXQgYmV0d2VlbiBsYWJlbCBhbmQgYXhpcyxcbiAqIHdoaWNoIGlzIHVzZWZ1bCB3aGVuICdvblplcm8nLCB3aGVyZSBheGlzTGFiZWwgaXMgaW4gdGhlIGdyaWQgYW5kXG4gKiBsYWJlbCBpbiBvdXRzaWRlIGdyaWQuXG4gKlxuICogVGlwczogbGlrZSBhbHdheXMsXG4gKiBwb3NpdGl2ZSByb3RhdGlvbiByZXByZXNlbnRzIGFudGljbG9ja3dpc2UsIGFuZCBuZWdhdGl2ZSByb3RhdGlvblxuICogcmVwcmVzZW50cyBjbG9ja3dpc2UuXG4gKiBUaGUgZGlyZWN0aW9uIG9mIHBvc2l0aW9uIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIGRpcmVjdGlvblxuICogb2Ygc2NyZWVuIGNvb3JkaW5hdGUuXG4gKlxuICogRG8gbm90IG5lZWQgdG8gY29uc2lkZXIgYXhpcyAnaW52ZXJzZScsIHdoaWNoIGlzIGF1dG8gcHJvY2Vzc2VkIGJ5XG4gKiBheGlzIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBheGlzTW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgU3RhbmRhcmQgYXhpcyBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3B0LnBvc2l0aW9uIFt4LCB5XVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdC5yb3RhdGlvbiBieSByYWRpYW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0Lm5hbWVEaXJlY3Rpb249MV0gMSBvciAtMSBVc2VkIHdoZW4gbmFtZUxvY2F0aW9uIGlzICdtaWRkbGUnIG9yICdjZW50ZXInLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQudGlja0RpcmVjdGlvbj0xXSAxIG9yIC0xXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbERpcmVjdGlvbj0xXSAxIG9yIC0xXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbE9mZnNldD0wXSBVc2VmdWxsIHdoZW4gb25aZXJvLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuYXhpc0xhYmVsU2hvd10gZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdC5heGlzTmFtZV0gZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5heGlzTmFtZUF2YWlsYWJsZVdpZHRoXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxSb3RhdGVdIGJ5IGRlZ3JlZSwgZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbEludGVydmFsXSBEZWZhdWx0IGxhYmVsIGludGVydmFsIHdoZW4gbGFiZWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsIGZyb20gbW9kZWwgaXMgbnVsbCBvciAnYXV0bycuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdHJva2VDb250YWluVGhyZXNob2xkXSBEZWZhdWx0IGxhYmVsIGludGVydmFsIHdoZW4gbGFiZWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0Lm5hbWVUcnVuY2F0ZU1heFdpZHRoXVxuICovXG5cblxudmFyIEF4aXNCdWlsZGVyID0gZnVuY3Rpb24gKGF4aXNNb2RlbCwgb3B0KSB7XG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHRoaXMub3B0ID0gb3B0O1xuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqL1xuXG4gIHRoaXMuYXhpc01vZGVsID0gYXhpc01vZGVsOyAvLyBEZWZhdWx0IHZhbHVlXG5cbiAgZGVmYXVsdHMob3B0LCB7XG4gICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgbmFtZURpcmVjdGlvbjogMSxcbiAgICB0aWNrRGlyZWN0aW9uOiAxLFxuICAgIGxhYmVsRGlyZWN0aW9uOiAxLFxuICAgIHNpbGVudDogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTsgLy8gRklYTUUgTm90IHVzZSBhIHNlcGVyYXRlIHRleHQgZ3JvdXA/XG5cbiAgdmFyIGR1bWJHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKHtcbiAgICBwb3NpdGlvbjogb3B0LnBvc2l0aW9uLnNsaWNlKCksXG4gICAgcm90YXRpb246IG9wdC5yb3RhdGlvblxuICB9KTsgLy8gdGhpcy5ncm91cC5hZGQoZHVtYkdyb3VwKTtcbiAgLy8gdGhpcy5fZHVtYkdyb3VwID0gZHVtYkdyb3VwO1xuXG4gIGR1bWJHcm91cC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgdGhpcy5fdHJhbnNmb3JtID0gZHVtYkdyb3VwLnRyYW5zZm9ybTtcbiAgdGhpcy5fZHVtYkdyb3VwID0gZHVtYkdyb3VwO1xufTtcblxuQXhpc0J1aWxkZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQXhpc0J1aWxkZXIsXG4gIGhhc0J1aWxkZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhYnVpbGRlcnNbbmFtZV07XG4gIH0sXG4gIGFkZDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBidWlsZGVyc1tuYW1lXS5jYWxsKHRoaXMpO1xuICB9LFxuICBnZXRHcm91cDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdyb3VwO1xuICB9XG59O1xudmFyIGJ1aWxkZXJzID0ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF4aXNMaW5lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcblxuICAgIGlmICghYXhpc01vZGVsLmdldCgnYXhpc0xpbmUuc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV4dGVudCA9IHRoaXMuYXhpc01vZGVsLmF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIG1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB2YXIgcHQxID0gW2V4dGVudFswXSwgMF07XG4gICAgdmFyIHB0MiA9IFtleHRlbnRbMV0sIDBdO1xuXG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDEsIHB0MSwgbWF0cml4KTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQyLCBwdDIsIG1hdHJpeCk7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVTdHlsZSA9IGV4dGVuZCh7XG4gICAgICBsaW5lQ2FwOiAncm91bmQnXG4gICAgfSwgYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGluZS5saW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSk7XG4gICAgdGhpcy5ncm91cC5hZGQobmV3IGdyYXBoaWMuTGluZShncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKHtcbiAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgIGFuaWQ6ICdsaW5lJyxcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHgxOiBwdDFbMF0sXG4gICAgICAgIHkxOiBwdDFbMV0sXG4gICAgICAgIHgyOiBwdDJbMF0sXG4gICAgICAgIHkyOiBwdDJbMV1cbiAgICAgIH0sXG4gICAgICBzdHlsZTogbGluZVN0eWxlLFxuICAgICAgc3Ryb2tlQ29udGFpblRocmVzaG9sZDogb3B0LnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQgfHwgNSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIHoyOiAxXG4gICAgfSkpKTtcbiAgICB2YXIgYXJyb3dzID0gYXhpc01vZGVsLmdldCgnYXhpc0xpbmUuc3ltYm9sJyk7XG4gICAgdmFyIGFycm93U2l6ZSA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLnN5bWJvbFNpemUnKTtcblxuICAgIGlmIChhcnJvd3MgIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBhcnJvd3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgc2FtZSBhcnJvdyBmb3Igc3RhcnQgYW5kIGVuZCBwb2ludFxuICAgICAgICBhcnJvd3MgPSBbYXJyb3dzLCBhcnJvd3NdO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGFycm93U2l6ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFycm93U2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBzYW1lIHNpemUgZm9yIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgYXJyb3dTaXplID0gW2Fycm93U2l6ZSwgYXJyb3dTaXplXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5bWJvbFdpZHRoID0gYXJyb3dTaXplWzBdO1xuICAgICAgdmFyIHN5bWJvbEhlaWdodCA9IGFycm93U2l6ZVsxXTtcbiAgICAgIGVhY2goW1tvcHQucm90YXRpb24gKyBNYXRoLlBJIC8gMiwgcHQxXSwgW29wdC5yb3RhdGlvbiAtIE1hdGguUEkgLyAyLCBwdDJdXSwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmIChhcnJvd3NbaW5kZXhdICE9PSAnbm9uZScgJiYgYXJyb3dzW2luZGV4XSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZVN5bWJvbChhcnJvd3NbaW5kZXhdLCAtc3ltYm9sV2lkdGggLyAyLCAtc3ltYm9sSGVpZ2h0IC8gMiwgc3ltYm9sV2lkdGgsIHN5bWJvbEhlaWdodCwgbGluZVN0eWxlLnN0cm9rZSwgdHJ1ZSk7XG4gICAgICAgICAgc3ltYm9sLmF0dHIoe1xuICAgICAgICAgICAgcm90YXRpb246IGl0ZW1bMF0sXG4gICAgICAgICAgICBwb3NpdGlvbjogaXRlbVsxXSxcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF4aXNUaWNrTGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG4gICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuICAgIHZhciB0aWNrRWxzID0gYnVpbGRBeGlzVGljayh0aGlzLCBheGlzTW9kZWwsIG9wdCk7XG4gICAgdmFyIGxhYmVsRWxzID0gYnVpbGRBeGlzTGFiZWwodGhpcywgYXhpc01vZGVsLCBvcHQpO1xuICAgIGZpeE1pbk1heExhYmVsU2hvdyhheGlzTW9kZWwsIGxhYmVsRWxzLCB0aWNrRWxzKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF4aXNOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcbiAgICB2YXIgbmFtZSA9IHJldHJpZXZlKG9wdC5heGlzTmFtZSwgYXhpc01vZGVsLmdldCgnbmFtZScpKTtcblxuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuYW1lTG9jYXRpb24gPSBheGlzTW9kZWwuZ2V0KCduYW1lTG9jYXRpb24nKTtcbiAgICB2YXIgbmFtZURpcmVjdGlvbiA9IG9wdC5uYW1lRGlyZWN0aW9uO1xuICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnbmFtZVRleHRTdHlsZScpO1xuICAgIHZhciBnYXAgPSBheGlzTW9kZWwuZ2V0KCduYW1lR2FwJykgfHwgMDtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5heGlzTW9kZWwuYXhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgZ2FwU2lnbmFsID0gZXh0ZW50WzBdID4gZXh0ZW50WzFdID8gLTEgOiAxO1xuICAgIHZhciBwb3MgPSBbbmFtZUxvY2F0aW9uID09PSAnc3RhcnQnID8gZXh0ZW50WzBdIC0gZ2FwU2lnbmFsICogZ2FwIDogbmFtZUxvY2F0aW9uID09PSAnZW5kJyA/IGV4dGVudFsxXSArIGdhcFNpZ25hbCAqIGdhcCA6IChleHRlbnRbMF0gKyBleHRlbnRbMV0pIC8gMiwgLy8gJ21pZGRsZSdcbiAgICAvLyBSZXVzZSBsYWJlbE9mZnNldC5cbiAgICBpc05hbWVMb2NhdGlvbkNlbnRlcihuYW1lTG9jYXRpb24pID8gb3B0LmxhYmVsT2Zmc2V0ICsgbmFtZURpcmVjdGlvbiAqIGdhcCA6IDBdO1xuICAgIHZhciBsYWJlbExheW91dDtcbiAgICB2YXIgbmFtZVJvdGF0aW9uID0gYXhpc01vZGVsLmdldCgnbmFtZVJvdGF0ZScpO1xuXG4gICAgaWYgKG5hbWVSb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICBuYW1lUm90YXRpb24gPSBuYW1lUm90YXRpb24gKiBQSSAvIDE4MDsgLy8gVG8gcmFkaWFuLlxuICAgIH1cblxuICAgIHZhciBheGlzTmFtZUF2YWlsYWJsZVdpZHRoO1xuXG4gICAgaWYgKGlzTmFtZUxvY2F0aW9uQ2VudGVyKG5hbWVMb2NhdGlvbikpIHtcbiAgICAgIGxhYmVsTGF5b3V0ID0gaW5uZXJUZXh0TGF5b3V0KG9wdC5yb3RhdGlvbiwgbmFtZVJvdGF0aW9uICE9IG51bGwgPyBuYW1lUm90YXRpb24gOiBvcHQucm90YXRpb24sIC8vIEFkYXB0IHRvIGF4aXMuXG4gICAgICBuYW1lRGlyZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWxMYXlvdXQgPSBlbmRUZXh0TGF5b3V0KG9wdCwgbmFtZUxvY2F0aW9uLCBuYW1lUm90YXRpb24gfHwgMCwgZXh0ZW50KTtcbiAgICAgIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggPSBvcHQuYXhpc05hbWVBdmFpbGFibGVXaWR0aDtcblxuICAgICAgaWYgKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggIT0gbnVsbCkge1xuICAgICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gTWF0aC5hYnMoYXhpc05hbWVBdmFpbGFibGVXaWR0aCAvIE1hdGguc2luKGxhYmVsTGF5b3V0LnJvdGF0aW9uKSk7XG4gICAgICAgICFpc0Zpbml0ZShheGlzTmFtZUF2YWlsYWJsZVdpZHRoKSAmJiAoYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXh0Rm9udCA9IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKTtcbiAgICB2YXIgdHJ1bmNhdGVPcHQgPSBheGlzTW9kZWwuZ2V0KCduYW1lVHJ1bmNhdGUnLCB0cnVlKSB8fCB7fTtcbiAgICB2YXIgZWxsaXBzaXMgPSB0cnVuY2F0ZU9wdC5lbGxpcHNpcztcbiAgICB2YXIgbWF4V2lkdGggPSByZXRyaWV2ZShvcHQubmFtZVRydW5jYXRlTWF4V2lkdGgsIHRydW5jYXRlT3B0Lm1heFdpZHRoLCBheGlzTmFtZUF2YWlsYWJsZVdpZHRoKTsgLy8gRklYTUVcbiAgICAvLyB0cnVuY2F0ZSByaWNoIHRleHQ/IChjb25zaWRlciBwZXJmb3JtYW5jZSlcblxuICAgIHZhciB0cnVuY2F0ZWRUZXh0ID0gZWxsaXBzaXMgIT0gbnVsbCAmJiBtYXhXaWR0aCAhPSBudWxsID8gZm9ybWF0VXRpbC50cnVuY2F0ZVRleHQobmFtZSwgbWF4V2lkdGgsIHRleHRGb250LCBlbGxpcHNpcywge1xuICAgICAgbWluQ2hhcjogMixcbiAgICAgIHBsYWNlaG9sZGVyOiB0cnVuY2F0ZU9wdC5wbGFjZWhvbGRlclxuICAgIH0pIDogbmFtZTtcbiAgICB2YXIgdG9vbHRpcE9wdCA9IGF4aXNNb2RlbC5nZXQoJ3Rvb2x0aXAnLCB0cnVlKTtcbiAgICB2YXIgbWFpblR5cGUgPSBheGlzTW9kZWwubWFpblR5cGU7XG4gICAgdmFyIGZvcm1hdHRlclBhcmFtcyA9IHtcbiAgICAgIGNvbXBvbmVudFR5cGU6IG1haW5UeXBlLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgICR2YXJzOiBbJ25hbWUnXVxuICAgIH07XG4gICAgZm9ybWF0dGVyUGFyYW1zW21haW5UeXBlICsgJ0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgICAgYW5pZDogJ25hbWUnLFxuICAgICAgX19mdWxsVGV4dDogbmFtZSxcbiAgICAgIF9fdHJ1bmNhdGVkVGV4dDogdHJ1bmNhdGVkVGV4dCxcbiAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgICBzaWxlbnQ6IGlzU2lsZW50KGF4aXNNb2RlbCksXG4gICAgICB6MjogMSxcbiAgICAgIHRvb2x0aXA6IHRvb2x0aXBPcHQgJiYgdG9vbHRpcE9wdC5zaG93ID8gZXh0ZW5kKHtcbiAgICAgICAgY29udGVudDogbmFtZSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlclBhcmFtczogZm9ybWF0dGVyUGFyYW1zXG4gICAgICB9LCB0b29sdGlwT3B0KSA6IG51bGxcbiAgICB9KTtcbiAgICBncmFwaGljLnNldFRleHRTdHlsZSh0ZXh0RWwuc3R5bGUsIHRleHRTdHlsZU1vZGVsLCB7XG4gICAgICB0ZXh0OiB0cnVuY2F0ZWRUZXh0LFxuICAgICAgdGV4dEZvbnQ6IHRleHRGb250LFxuICAgICAgdGV4dEZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpIHx8IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpLFxuICAgICAgdGV4dEFsaWduOiBsYWJlbExheW91dC50ZXh0QWxpZ24sXG4gICAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWxMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ25cbiAgICB9KTtcblxuICAgIGlmIChheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKSkge1xuICAgICAgdGV4dEVsLmV2ZW50RGF0YSA9IG1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgdGV4dEVsLmV2ZW50RGF0YS50YXJnZXRUeXBlID0gJ2F4aXNOYW1lJztcbiAgICAgIHRleHRFbC5ldmVudERhdGEubmFtZSA9IG5hbWU7XG4gICAgfSAvLyBGSVhNRVxuXG5cbiAgICB0aGlzLl9kdW1iR3JvdXAuYWRkKHRleHRFbCk7XG5cbiAgICB0ZXh0RWwudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5ncm91cC5hZGQodGV4dEVsKTtcbiAgICB0ZXh0RWwuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gIH1cbn07XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzUm90YXRpb24gaW4gcmFkaWFuXG4gKiBAcGFyYW0ge251bWJlcn0gdGV4dFJvdGF0aW9uIGluIHJhZGlhblxuICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvblxuICogQHJldHVybiB7T2JqZWN0fSB7XG4gKiAgcm90YXRpb24sIC8vIGFjY29yZGluZyB0byBheGlzXG4gKiAgdGV4dEFsaWduLFxuICogIHRleHRWZXJ0aWNhbEFsaWduXG4gKiB9XG4gKi9cblxudmFyIGlubmVyVGV4dExheW91dCA9IEF4aXNCdWlsZGVyLmlubmVyVGV4dExheW91dCA9IGZ1bmN0aW9uIChheGlzUm90YXRpb24sIHRleHRSb3RhdGlvbiwgZGlyZWN0aW9uKSB7XG4gIHZhciByb3RhdGlvbkRpZmYgPSByZW1SYWRpYW4odGV4dFJvdGF0aW9uIC0gYXhpc1JvdGF0aW9uKTtcbiAgdmFyIHRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduO1xuXG4gIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmKSkge1xuICAgIC8vIExhYmVsIGlzIHBhcmFsbGVsIHdpdGggYXhpcyBsaW5lLlxuICAgIHRleHRWZXJ0aWNhbEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJKSkge1xuICAgIC8vIExhYmVsIGlzIGludmVyc2UgcGFyYWxsZWwgd2l0aCBheGlzIGxpbmUuXG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgfSBlbHNlIHtcbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuXG4gICAgaWYgKHJvdGF0aW9uRGlmZiA+IDAgJiYgcm90YXRpb25EaWZmIDwgUEkpIHtcbiAgICAgIHRleHRBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdGF0aW9uOiByb3RhdGlvbkRpZmYsXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59O1xuXG5mdW5jdGlvbiBlbmRUZXh0TGF5b3V0KG9wdCwgdGV4dFBvc2l0aW9uLCB0ZXh0Um90YXRlLCBleHRlbnQpIHtcbiAgdmFyIHJvdGF0aW9uRGlmZiA9IHJlbVJhZGlhbih0ZXh0Um90YXRlIC0gb3B0LnJvdGF0aW9uKTtcbiAgdmFyIHRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduO1xuICB2YXIgaW52ZXJzZSA9IGV4dGVudFswXSA+IGV4dGVudFsxXTtcbiAgdmFyIG9uTGVmdCA9IHRleHRQb3NpdGlvbiA9PT0gJ3N0YXJ0JyAmJiAhaW52ZXJzZSB8fCB0ZXh0UG9zaXRpb24gIT09ICdzdGFydCcgJiYgaW52ZXJzZTtcblxuICBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJIC8gMikpIHtcbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9IG9uTGVmdCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJICogMS41KSkge1xuICAgIHRleHRWZXJ0aWNhbEFsaWduID0gb25MZWZ0ID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgfSBlbHNlIHtcbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuXG4gICAgaWYgKHJvdGF0aW9uRGlmZiA8IFBJICogMS41ICYmIHJvdGF0aW9uRGlmZiA+IFBJIC8gMikge1xuICAgICAgdGV4dEFsaWduID0gb25MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gb25MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdGF0aW9uOiByb3RhdGlvbkRpZmYsXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU2lsZW50KGF4aXNNb2RlbCkge1xuICB2YXIgdG9vbHRpcE9wdCA9IGF4aXNNb2RlbC5nZXQoJ3Rvb2x0aXAnKTtcbiAgcmV0dXJuIGF4aXNNb2RlbC5nZXQoJ3NpbGVudCcpIC8vIENvbnNpZGVyIG1vdXNlIGN1cnNvciwgYWRkIHRoZXNlIHJlc3RyaWN0aW9ucy5cbiAgfHwgIShheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKSB8fCB0b29sdGlwT3B0ICYmIHRvb2x0aXBPcHQuc2hvdyk7XG59XG5cbmZ1bmN0aW9uIGZpeE1pbk1heExhYmVsU2hvdyhheGlzTW9kZWwsIGxhYmVsRWxzLCB0aWNrRWxzKSB7XG4gIC8vIElmIG1pbiBvciBtYXggYXJlIHVzZXIgc2V0LCB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIElmIHRoZSB0aWNrIG9uIG1pbihtYXgpIGFyZSBvdmVybGFwIG9uIHRoZWlyIG5laWdoYm91ciB0aWNrXG4gIC8vIElmIHRoZXkgYXJlIG92ZXJsYXBwZWQsIHdlIG5lZWQgdG8gaGlkZSB0aGUgbWluKG1heCkgdGljayBsYWJlbFxuICB2YXIgc2hvd01pbkxhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNaW5MYWJlbCcpO1xuICB2YXIgc2hvd01heExhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNYXhMYWJlbCcpOyAvLyBGSVhNRVxuICAvLyBIYXZlIG5vdCBjb25zaWRlciBvbkJhbmQgeWV0LCB3aGVyZSB0aWNrIGVscyBpcyBtb3JlIHRoYW4gbGFiZWwgZWxzLlxuXG4gIGxhYmVsRWxzID0gbGFiZWxFbHMgfHwgW107XG4gIHRpY2tFbHMgPSB0aWNrRWxzIHx8IFtdO1xuICB2YXIgZmlyc3RMYWJlbCA9IGxhYmVsRWxzWzBdO1xuICB2YXIgbmV4dExhYmVsID0gbGFiZWxFbHNbMV07XG4gIHZhciBsYXN0TGFiZWwgPSBsYWJlbEVsc1tsYWJlbEVscy5sZW5ndGggLSAxXTtcbiAgdmFyIHByZXZMYWJlbCA9IGxhYmVsRWxzW2xhYmVsRWxzLmxlbmd0aCAtIDJdO1xuICB2YXIgZmlyc3RUaWNrID0gdGlja0Vsc1swXTtcbiAgdmFyIG5leHRUaWNrID0gdGlja0Vsc1sxXTtcbiAgdmFyIGxhc3RUaWNrID0gdGlja0Vsc1t0aWNrRWxzLmxlbmd0aCAtIDFdO1xuICB2YXIgcHJldlRpY2sgPSB0aWNrRWxzW3RpY2tFbHMubGVuZ3RoIC0gMl07XG5cbiAgaWYgKHNob3dNaW5MYWJlbCA9PT0gZmFsc2UpIHtcbiAgICBpZ25vcmVFbChmaXJzdExhYmVsKTtcbiAgICBpZ25vcmVFbChmaXJzdFRpY2spO1xuICB9IGVsc2UgaWYgKGlzVHdvTGFiZWxPdmVybGFwcGVkKGZpcnN0TGFiZWwsIG5leHRMYWJlbCkpIHtcbiAgICBpZiAoc2hvd01pbkxhYmVsKSB7XG4gICAgICBpZ25vcmVFbChuZXh0TGFiZWwpO1xuICAgICAgaWdub3JlRWwobmV4dFRpY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZ25vcmVFbChmaXJzdExhYmVsKTtcbiAgICAgIGlnbm9yZUVsKGZpcnN0VGljayk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNob3dNYXhMYWJlbCA9PT0gZmFsc2UpIHtcbiAgICBpZ25vcmVFbChsYXN0TGFiZWwpO1xuICAgIGlnbm9yZUVsKGxhc3RUaWNrKTtcbiAgfSBlbHNlIGlmIChpc1R3b0xhYmVsT3ZlcmxhcHBlZChwcmV2TGFiZWwsIGxhc3RMYWJlbCkpIHtcbiAgICBpZiAoc2hvd01heExhYmVsKSB7XG4gICAgICBpZ25vcmVFbChwcmV2TGFiZWwpO1xuICAgICAgaWdub3JlRWwocHJldlRpY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZ25vcmVFbChsYXN0TGFiZWwpO1xuICAgICAgaWdub3JlRWwobGFzdFRpY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpZ25vcmVFbChlbCkge1xuICBlbCAmJiAoZWwuaWdub3JlID0gdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGlzVHdvTGFiZWxPdmVybGFwcGVkKGN1cnJlbnQsIG5leHQsIGxhYmVsTGF5b3V0KSB7XG4gIC8vIGN1cnJlbnQgYW5kIG5leHQgaGFzIHRoZSBzYW1lIHJvdGF0aW9uLlxuICB2YXIgZmlyc3RSZWN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gIHZhciBuZXh0UmVjdCA9IG5leHQgJiYgbmV4dC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuXG4gIGlmICghZmlyc3RSZWN0IHx8ICFuZXh0UmVjdCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBXaGVuIGNoZWNraW5nIGludGVyc2VjdCBvZiB0d28gcm90YXRlZCBsYWJlbHMsIHdlIHVzZSBtUm90YXRpb25CYWNrXG4gIC8vIHRvIGF2b2lkIHRoYXQgYm91bmRpbmdSZWN0IGlzIGVubGFyZ2Ugd2hlbiB1c2luZyBgYm91bmRpbmdSZWN0LmFwcGx5VHJhbnNmb3JtYC5cblxuXG4gIHZhciBtUm90YXRpb25CYWNrID0gbWF0cml4VXRpbC5pZGVudGl0eShbXSk7XG4gIG1hdHJpeFV0aWwucm90YXRlKG1Sb3RhdGlvbkJhY2ssIG1Sb3RhdGlvbkJhY2ssIC1jdXJyZW50LnJvdGF0aW9uKTtcbiAgZmlyc3RSZWN0LmFwcGx5VHJhbnNmb3JtKG1hdHJpeFV0aWwubXVsKFtdLCBtUm90YXRpb25CYWNrLCBjdXJyZW50LmdldExvY2FsVHJhbnNmb3JtKCkpKTtcbiAgbmV4dFJlY3QuYXBwbHlUcmFuc2Zvcm0obWF0cml4VXRpbC5tdWwoW10sIG1Sb3RhdGlvbkJhY2ssIG5leHQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSkpO1xuICByZXR1cm4gZmlyc3RSZWN0LmludGVyc2VjdChuZXh0UmVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzTmFtZUxvY2F0aW9uQ2VudGVyKG5hbWVMb2NhdGlvbikge1xuICByZXR1cm4gbmFtZUxvY2F0aW9uID09PSAnbWlkZGxlJyB8fCBuYW1lTG9jYXRpb24gPT09ICdjZW50ZXInO1xufVxuLyoqXG4gKiBAc3RhdGljXG4gKi9cblxuXG52YXIgaWZJZ25vcmVPblRpY2sgPSBBeGlzQnVpbGRlci5pZklnbm9yZU9uVGljayA9IGZ1bmN0aW9uIChheGlzLCBpLCBpbnRlcnZhbCwgdGlja3NDbnQsIHNob3dNaW5MYWJlbCwgc2hvd01heExhYmVsKSB7XG4gIGlmIChpID09PSAwICYmIHNob3dNaW5MYWJlbCB8fCBpID09PSB0aWNrc0NudCAtIDEgJiYgc2hvd01heExhYmVsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEZJWE1FXG4gIC8vIEhhdmUgbm90IGNvbnNpZGVyIGxhYmVsIG92ZXJsYXAgKGlmIGxhYmVsIGlzIHRvbyBsb25nKSB5ZXQuXG5cblxuICB2YXIgcmF3VGljaztcbiAgdmFyIHNjYWxlID0gYXhpcy5zY2FsZTtcbiAgcmV0dXJuIHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJyAmJiAodHlwZW9mIGludGVydmFsID09PSAnZnVuY3Rpb24nID8gKHJhd1RpY2sgPSBzY2FsZS5nZXRUaWNrcygpW2ldLCAhaW50ZXJ2YWwocmF3VGljaywgc2NhbGUuZ2V0TGFiZWwocmF3VGljaykpKSA6IGkgJSAoaW50ZXJ2YWwgKyAxKSk7XG59O1xuLyoqXG4gKiBAc3RhdGljXG4gKi9cblxuXG52YXIgZ2V0SW50ZXJ2YWwgPSBBeGlzQnVpbGRlci5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIChtb2RlbCwgbGFiZWxJbnRlcnZhbCkge1xuICB2YXIgaW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ2ludGVydmFsJyk7XG5cbiAgaWYgKGludGVydmFsID09IG51bGwgfHwgaW50ZXJ2YWwgPT0gJ2F1dG8nKSB7XG4gICAgaW50ZXJ2YWwgPSBsYWJlbEludGVydmFsO1xuICB9XG5cbiAgcmV0dXJuIGludGVydmFsO1xufTtcblxuZnVuY3Rpb24gYnVpbGRBeGlzVGljayhheGlzQnVpbGRlciwgYXhpc01vZGVsLCBvcHQpIHtcbiAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcblxuICBpZiAoIWF4aXNNb2RlbC5nZXQoJ2F4aXNUaWNrLnNob3cnKSB8fCBheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0aWNrTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNUaWNrJyk7XG4gIHZhciBsaW5lU3R5bGVNb2RlbCA9IHRpY2tNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gIHZhciB0aWNrTGVuID0gdGlja01vZGVsLmdldCgnbGVuZ3RoJyk7XG4gIHZhciB0aWNrSW50ZXJ2YWwgPSBnZXRJbnRlcnZhbCh0aWNrTW9kZWwsIG9wdC5sYWJlbEludGVydmFsKTtcbiAgdmFyIHRpY2tzQ29vcmRzID0gYXhpcy5nZXRUaWNrc0Nvb3Jkcyh0aWNrTW9kZWwuZ2V0KCdhbGlnbldpdGhMYWJlbCcpKTsgLy8gRklYTUVcbiAgLy8gQ29ycmVzcG9uZHMgdG8gdGlja3NDb29yZHMgP1xuXG4gIHZhciB0aWNrcyA9IGF4aXMuc2NhbGUuZ2V0VGlja3MoKTtcbiAgdmFyIHNob3dNaW5MYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWluTGFiZWwnKTtcbiAgdmFyIHNob3dNYXhMYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWF4TGFiZWwnKTtcbiAgdmFyIHB0MSA9IFtdO1xuICB2YXIgcHQyID0gW107XG4gIHZhciBtYXRyaXggPSBheGlzQnVpbGRlci5fdHJhbnNmb3JtO1xuICB2YXIgdGlja0VscyA9IFtdO1xuICB2YXIgdGlja3NDbnQgPSB0aWNrc0Nvb3Jkcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0NudDsgaSsrKSB7XG4gICAgLy8gT25seSBvcmRpbmFsIHNjYWxlIHN1cHBvcnQgdGljayBpbnRlcnZhbFxuICAgIGlmIChpZklnbm9yZU9uVGljayhheGlzLCBpLCB0aWNrSW50ZXJ2YWwsIHRpY2tzQ250LCBzaG93TWluTGFiZWwsIHNob3dNYXhMYWJlbCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciB0aWNrQ29vcmQgPSB0aWNrc0Nvb3Jkc1tpXTtcbiAgICBwdDFbMF0gPSB0aWNrQ29vcmQ7XG4gICAgcHQxWzFdID0gMDtcbiAgICBwdDJbMF0gPSB0aWNrQ29vcmQ7XG4gICAgcHQyWzFdID0gb3B0LnRpY2tEaXJlY3Rpb24gKiB0aWNrTGVuO1xuXG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDEsIHB0MSwgbWF0cml4KTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQyLCBwdDIsIG1hdHJpeCk7XG4gICAgfSAvLyBUaWNrIGxpbmUsIE5vdCB1c2UgZ3JvdXAgdHJhbnNmb3JtIHRvIGhhdmUgYmV0dGVyIGxpbmUgZHJhd1xuXG5cbiAgICB2YXIgdGlja0VsID0gbmV3IGdyYXBoaWMuTGluZShncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKHtcbiAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgIGFuaWQ6ICd0aWNrXycgKyB0aWNrc1tpXSxcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHgxOiBwdDFbMF0sXG4gICAgICAgIHkxOiBwdDFbMV0sXG4gICAgICAgIHgyOiBwdDJbMF0sXG4gICAgICAgIHkyOiBwdDJbMV1cbiAgICAgIH0sXG4gICAgICBzdHlsZTogZGVmYXVsdHMobGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksIHtcbiAgICAgICAgc3Ryb2tlOiBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5saW5lU3R5bGUuY29sb3InKVxuICAgICAgfSksXG4gICAgICB6MjogMixcbiAgICAgIHNpbGVudDogdHJ1ZVxuICAgIH0pKTtcbiAgICBheGlzQnVpbGRlci5ncm91cC5hZGQodGlja0VsKTtcbiAgICB0aWNrRWxzLnB1c2godGlja0VsKTtcbiAgfVxuXG4gIHJldHVybiB0aWNrRWxzO1xufVxuXG5mdW5jdGlvbiBidWlsZEF4aXNMYWJlbChheGlzQnVpbGRlciwgYXhpc01vZGVsLCBvcHQpIHtcbiAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgdmFyIHNob3cgPSByZXRyaWV2ZShvcHQuYXhpc0xhYmVsU2hvdywgYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3cnKSk7XG5cbiAgaWYgKCFzaG93IHx8IGF4aXMuc2NhbGUuaXNCbGFuaygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhYmVsTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMYWJlbCcpO1xuICB2YXIgbGFiZWxNYXJnaW4gPSBsYWJlbE1vZGVsLmdldCgnbWFyZ2luJyk7XG4gIHZhciB0aWNrcyA9IGF4aXMuc2NhbGUuZ2V0VGlja3MoKTtcbiAgdmFyIGxhYmVscyA9IGF4aXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbHMoKTsgLy8gU3BlY2lhbCBsYWJlbCByb3RhdGUuXG5cbiAgdmFyIGxhYmVsUm90YXRpb24gPSAocmV0cmlldmUob3B0LmxhYmVsUm90YXRlLCBsYWJlbE1vZGVsLmdldCgncm90YXRlJykpIHx8IDApICogUEkgLyAxODA7XG4gIHZhciBsYWJlbExheW91dCA9IGlubmVyVGV4dExheW91dChvcHQucm90YXRpb24sIGxhYmVsUm90YXRpb24sIG9wdC5sYWJlbERpcmVjdGlvbik7XG4gIHZhciBjYXRlZ29yeURhdGEgPSBheGlzTW9kZWwuZ2V0KCdkYXRhJyk7XG4gIHZhciBsYWJlbEVscyA9IFtdO1xuICB2YXIgc2lsZW50ID0gaXNTaWxlbnQoYXhpc01vZGVsKTtcbiAgdmFyIHRyaWdnZXJFdmVudCA9IGF4aXNNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcpO1xuICB2YXIgc2hvd01pbkxhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNaW5MYWJlbCcpO1xuICB2YXIgc2hvd01heExhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNYXhMYWJlbCcpO1xuICBlYWNoKHRpY2tzLCBmdW5jdGlvbiAodGlja1ZhbCwgaW5kZXgpIHtcbiAgICBpZiAoaWZJZ25vcmVPblRpY2soYXhpcywgaW5kZXgsIG9wdC5sYWJlbEludGVydmFsLCB0aWNrcy5sZW5ndGgsIHNob3dNaW5MYWJlbCwgc2hvd01heExhYmVsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpdGVtTGFiZWxNb2RlbCA9IGxhYmVsTW9kZWw7XG5cbiAgICBpZiAoY2F0ZWdvcnlEYXRhICYmIGNhdGVnb3J5RGF0YVt0aWNrVmFsXSAmJiBjYXRlZ29yeURhdGFbdGlja1ZhbF0udGV4dFN0eWxlKSB7XG4gICAgICBpdGVtTGFiZWxNb2RlbCA9IG5ldyBNb2RlbChjYXRlZ29yeURhdGFbdGlja1ZhbF0udGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBheGlzTW9kZWwuZWNNb2RlbCk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb2xvciA9IGl0ZW1MYWJlbE1vZGVsLmdldFRleHRDb2xvcigpIHx8IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpO1xuICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKHRpY2tWYWwpO1xuICAgIHZhciBwb3MgPSBbdGlja0Nvb3JkLCBvcHQubGFiZWxPZmZzZXQgKyBvcHQubGFiZWxEaXJlY3Rpb24gKiBsYWJlbE1hcmdpbl07XG4gICAgdmFyIGxhYmVsU3RyID0gYXhpcy5zY2FsZS5nZXRMYWJlbCh0aWNrVmFsKTtcbiAgICB2YXIgdGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICBhbmlkOiAnbGFiZWxfJyArIHRpY2tWYWwsXG4gICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgcm90YXRpb246IGxhYmVsTGF5b3V0LnJvdGF0aW9uLFxuICAgICAgc2lsZW50OiBzaWxlbnQsXG4gICAgICB6MjogMTBcbiAgICB9KTtcbiAgICBncmFwaGljLnNldFRleHRTdHlsZSh0ZXh0RWwuc3R5bGUsIGl0ZW1MYWJlbE1vZGVsLCB7XG4gICAgICB0ZXh0OiBsYWJlbHNbaW5kZXhdLFxuICAgICAgdGV4dEFsaWduOiBpdGVtTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdhbGlnbicsIHRydWUpIHx8IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiBpdGVtTGFiZWxNb2RlbC5nZXRTaGFsbG93KCd2ZXJ0aWNhbEFsaWduJywgdHJ1ZSkgfHwgaXRlbUxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnYmFzZWxpbmUnLCB0cnVlKSB8fCBsYWJlbExheW91dC50ZXh0VmVydGljYWxBbGlnbixcbiAgICAgIHRleHRGaWxsOiB0eXBlb2YgdGV4dENvbG9yID09PSAnZnVuY3Rpb24nID8gdGV4dENvbG9yKCAvLyAoMSkgSW4gY2F0ZWdvcnkgYXhpcyB3aXRoIGRhdGEgem9vbSwgdGljayBpcyBub3QgdGhlIG9yaWdpbmFsXG4gICAgICAvLyBpbmRleCBvZiBheGlzLmRhdGEuIFNvIHRpY2sgc2hvdWxkIG5vdCBiZSBleHBvc2VkIHRvIHVzZXJcbiAgICAgIC8vIGluIGNhdGVnb3J5IGF4aXMuXG4gICAgICAvLyAoMikgQ29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIHZlcnNpb24sIHdoaWNoIGFsd2F5cyByZXR1cm5zIGxhYmVsU3RyLlxuICAgICAgLy8gQnV0IGluIGludGVydmFsIHNjYWxlIGxhYmVsU3RyIGlzIGxpa2UgJzIyMyw0NDUnLCB3aGljaCBtYWtlZFxuICAgICAgLy8gdXNlciByZXBhbGNlICcsJy4gU28gd2UgbW9kaWZ5IGl0IHRvIHJldHVybiBvcmlnaW5hbCB2YWwgYnV0IHJlbWFpblxuICAgICAgLy8gaXQgYXMgJ3N0cmluZycgdG8gYXZvaWQgZXJyb3IgaW4gcmVwbGFjaW5nLlxuICAgICAgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gbGFiZWxTdHIgOiBheGlzLnR5cGUgPT09ICd2YWx1ZScgPyB0aWNrVmFsICsgJycgOiB0aWNrVmFsLCBpbmRleCkgOiB0ZXh0Q29sb3JcbiAgICB9KTsgLy8gUGFjayBkYXRhIGZvciBtb3VzZSBldmVudFxuXG4gICAgaWYgKHRyaWdnZXJFdmVudCkge1xuICAgICAgdGV4dEVsLmV2ZW50RGF0YSA9IG1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgdGV4dEVsLmV2ZW50RGF0YS50YXJnZXRUeXBlID0gJ2F4aXNMYWJlbCc7XG4gICAgICB0ZXh0RWwuZXZlbnREYXRhLnZhbHVlID0gbGFiZWxTdHI7XG4gICAgfSAvLyBGSVhNRVxuXG5cbiAgICBheGlzQnVpbGRlci5fZHVtYkdyb3VwLmFkZCh0ZXh0RWwpO1xuXG4gICAgdGV4dEVsLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIGxhYmVsRWxzLnB1c2godGV4dEVsKTtcbiAgICBheGlzQnVpbGRlci5ncm91cC5hZGQodGV4dEVsKTtcbiAgICB0ZXh0RWwuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gIH0pO1xuICByZXR1cm4gbGFiZWxFbHM7XG59XG5cbnZhciBfZGVmYXVsdCA9IEF4aXNCdWlsZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9BeGlzQnVpbGRlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc0J1aWxkZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgYXhpc1BvaW50ZXJNb2RlbEhlbHBlciA9IHJlcXVpcmUoXCIuLi9heGlzUG9pbnRlci9tb2RlbEhlbHBlclwiKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIEF4aXNWaWV3LlxuICovXG52YXIgQXhpc1ZpZXcgPSBlY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuICB0eXBlOiAnYXhpcycsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXhpc1BvaW50ZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGF4aXNQb2ludGVyQ2xhc3M6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIFRoaXMgcHJvY2VzcyBzaG91bGQgcHJvZm9ybWVkIGFmdGVyIGNvb3JkaW5hdGUgc3lzdGVtcyB1cGRhdGVkXG4gICAgLy8gKGF4aXMgc2NhbGUgdXBkYXRlZCksIGFuZCBzaG91bGQgYmUgcGVyZm9ybWVkIGVhY2ggdGltZSB1cGRhdGUuXG4gICAgLy8gU28gcHV0IGl0IGhlcmUgdGVtcG9yYXJpbHksIGFsdGhvdWdoIGl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0b1xuICAgIC8vIHB1dCBhIG1vZGVsLXdyaXRpbmcgcHJvY2VkdXJlIGluIGB2aWV3YC5cbiAgICB0aGlzLmF4aXNQb2ludGVyQ2xhc3MgJiYgYXhpc1BvaW50ZXJNb2RlbEhlbHBlci5maXhWYWx1ZShheGlzTW9kZWwpO1xuICAgIEF4aXNWaWV3LnN1cGVyQXBwbHkodGhpcywgJ3JlbmRlcicsIGFyZ3VtZW50cyk7XG4gICAgdXBkYXRlQXhpc1BvaW50ZXIodGhpcywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlci5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqL1xuICB1cGRhdGVBeGlzUG9pbnRlcjogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkLCBmb3JjZSkge1xuICAgIHVwZGF0ZUF4aXNQb2ludGVyKHRoaXMsIGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGF4aXNQb2ludGVyID0gdGhpcy5fYXhpc1BvaW50ZXI7XG4gICAgYXhpc1BvaW50ZXIgJiYgYXhpc1BvaW50ZXIucmVtb3ZlKGFwaSk7XG4gICAgQXhpc1ZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVtb3ZlJywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgZGlzcG9zZUF4aXNQb2ludGVyKHRoaXMsIGFwaSk7XG4gICAgQXhpc1ZpZXcuc3VwZXJBcHBseSh0aGlzLCAnZGlzcG9zZScsIGFyZ3VtZW50cyk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVBeGlzUG9pbnRlcihheGlzVmlldywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIGZvcmNlUmVuZGVyKSB7XG4gIHZhciBDbGF6eiA9IEF4aXNWaWV3LmdldEF4aXNQb2ludGVyQ2xhc3MoYXhpc1ZpZXcuYXhpc1BvaW50ZXJDbGFzcyk7XG5cbiAgaWYgKCFDbGF6eikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbEhlbHBlci5nZXRBeGlzUG9pbnRlck1vZGVsKGF4aXNNb2RlbCk7XG4gIGF4aXNQb2ludGVyTW9kZWwgPyAoYXhpc1ZpZXcuX2F4aXNQb2ludGVyIHx8IChheGlzVmlldy5fYXhpc1BvaW50ZXIgPSBuZXcgQ2xhenooKSkpLnJlbmRlcihheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwgZm9yY2VSZW5kZXIpIDogZGlzcG9zZUF4aXNQb2ludGVyKGF4aXNWaWV3LCBhcGkpO1xufVxuXG5mdW5jdGlvbiBkaXNwb3NlQXhpc1BvaW50ZXIoYXhpc1ZpZXcsIGVjTW9kZWwsIGFwaSkge1xuICB2YXIgYXhpc1BvaW50ZXIgPSBheGlzVmlldy5fYXhpc1BvaW50ZXI7XG4gIGF4aXNQb2ludGVyICYmIGF4aXNQb2ludGVyLmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgYXhpc1ZpZXcuX2F4aXNQb2ludGVyID0gbnVsbDtcbn1cblxudmFyIGF4aXNQb2ludGVyQ2xhenogPSBbXTtcblxuQXhpc1ZpZXcucmVnaXN0ZXJBeGlzUG9pbnRlckNsYXNzID0gZnVuY3Rpb24gKHR5cGUsIGNsYXp6KSB7XG4gIGF4aXNQb2ludGVyQ2xhenpbdHlwZV0gPSBjbGF6ejtcbn07XG5cbkF4aXNWaWV3LmdldEF4aXNQb2ludGVyQ2xhc3MgPSBmdW5jdGlvbiAodHlwZSkge1xuICByZXR1cm4gdHlwZSAmJiBheGlzUG9pbnRlckNsYXp6W3R5cGVdO1xufTtcblxudmFyIF9kZWZhdWx0ID0gQXhpc1ZpZXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0F4aXNWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9BeGlzVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBBeGlzQnVpbGRlciA9IHJlcXVpcmUoXCIuL0F4aXNCdWlsZGVyXCIpO1xuXG52YXIgQXhpc1ZpZXcgPSByZXF1aXJlKFwiLi9BeGlzVmlld1wiKTtcblxudmFyIGNhcnRlc2lhbkF4aXNIZWxwZXIgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW5BeGlzSGVscGVyXCIpO1xuXG52YXIgaWZJZ25vcmVPblRpY2sgPSBBeGlzQnVpbGRlci5pZklnbm9yZU9uVGljaztcbnZhciBnZXRJbnRlcnZhbCA9IEF4aXNCdWlsZGVyLmdldEludGVydmFsO1xudmFyIGF4aXNCdWlsZGVyQXR0cnMgPSBbJ2F4aXNMaW5lJywgJ2F4aXNUaWNrTGFiZWwnLCAnYXhpc05hbWUnXTtcbnZhciBzZWxmQnVpbGRlckF0dHJzID0gWydzcGxpdEFyZWEnLCAnc3BsaXRMaW5lJ107IC8vIGZ1bmN0aW9uIGdldEFsaWduV2l0aExhYmVsKG1vZGVsLCBheGlzTW9kZWwpIHtcbi8vICAgICB2YXIgYWxpZ25XaXRoTGFiZWwgPSBtb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJyk7XG4vLyAgICAgaWYgKGFsaWduV2l0aExhYmVsID09PSAnYXV0bycpIHtcbi8vICAgICAgICAgYWxpZ25XaXRoTGFiZWwgPSBheGlzTW9kZWwuZ2V0KCdheGlzVGljay5hbGlnbldpdGhMYWJlbCcpO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gYWxpZ25XaXRoTGFiZWw7XG4vLyB9XG5cbnZhciBDYXJ0ZXNpYW5BeGlzVmlldyA9IEF4aXNWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdjYXJ0ZXNpYW5BeGlzJyxcbiAgYXhpc1BvaW50ZXJDbGFzczogJ0NhcnRlc2lhbkF4aXNQb2ludGVyJyxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdmFyIG9sZEF4aXNHcm91cCA9IHRoaXMuX2F4aXNHcm91cDtcbiAgICB0aGlzLl9heGlzR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2F4aXNHcm91cCk7XG5cbiAgICBpZiAoIWF4aXNNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpO1xuICAgIHZhciBsYXlvdXQgPSBjYXJ0ZXNpYW5BeGlzSGVscGVyLmxheW91dChncmlkTW9kZWwsIGF4aXNNb2RlbCk7XG4gICAgdmFyIGF4aXNCdWlsZGVyID0gbmV3IEF4aXNCdWlsZGVyKGF4aXNNb2RlbCwgbGF5b3V0KTtcbiAgICB6clV0aWwuZWFjaChheGlzQnVpbGRlckF0dHJzLCBheGlzQnVpbGRlci5hZGQsIGF4aXNCdWlsZGVyKTtcblxuICAgIHRoaXMuX2F4aXNHcm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG5cbiAgICB6clV0aWwuZWFjaChzZWxmQnVpbGRlckF0dHJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKGF4aXNNb2RlbC5nZXQobmFtZSArICcuc2hvdycpKSB7XG4gICAgICAgIHRoaXNbJ18nICsgbmFtZV0oYXhpc01vZGVsLCBncmlkTW9kZWwsIGxheW91dC5sYWJlbEludGVydmFsKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBncmFwaGljLmdyb3VwVHJhbnNpdGlvbihvbGRBeGlzR3JvdXAsIHRoaXMuX2F4aXNHcm91cCwgYXhpc01vZGVsKTtcbiAgICBDYXJ0ZXNpYW5BeGlzVmlldy5zdXBlckNhbGwodGhpcywgJ3JlbmRlcicsIGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsfSBheGlzTW9kZWxcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsfSBncmlkTW9kZWxcbiAgICogQHBhcmFtIHtudW1iZXJ8RnVuY3Rpb259IGxhYmVsSW50ZXJ2YWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zcGxpdExpbmU6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGdyaWRNb2RlbCwgbGFiZWxJbnRlcnZhbCkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG5cbiAgICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3BsaXRMaW5lTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0TGluZScpO1xuICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IHNwbGl0TGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICB2YXIgbGluZUNvbG9ycyA9IGxpbmVTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcbiAgICB2YXIgbGluZUludGVydmFsID0gZ2V0SW50ZXJ2YWwoc3BsaXRMaW5lTW9kZWwsIGxhYmVsSW50ZXJ2YWwpO1xuICAgIGxpbmVDb2xvcnMgPSB6clV0aWwuaXNBcnJheShsaW5lQ29sb3JzKSA/IGxpbmVDb2xvcnMgOiBbbGluZUNvbG9yc107XG4gICAgdmFyIGdyaWRSZWN0ID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoKTtcbiAgICB2YXIgdGlja3MgPSBheGlzLnNjYWxlLmdldFRpY2tzKCk7XG4gICAgdmFyIHNob3dNaW5MYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWluTGFiZWwnKTtcbiAgICB2YXIgc2hvd01heExhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNYXhMYWJlbCcpO1xuICAgIHZhciBwMSA9IFtdO1xuICAgIHZhciBwMiA9IFtdOyAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgLy8gQmF0Y2hpbmcgdGhlIGxpbmVzIGlmIGNvbG9yIGFyZSB0aGUgc2FtZVxuXG4gICAgdmFyIGxpbmVTdHlsZSA9IGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGksIGxpbmVJbnRlcnZhbCwgdGlja3NDb29yZHMubGVuZ3RoLCBzaG93TWluTGFiZWwsIHNob3dNYXhMYWJlbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbaV0pO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHAxWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMVsxXSA9IGdyaWRSZWN0Lnk7XG4gICAgICAgIHAyWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMlsxXSA9IGdyaWRSZWN0LnkgKyBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwMVswXSA9IGdyaWRSZWN0Lng7XG4gICAgICAgIHAxWzFdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMlswXSA9IGdyaWRSZWN0LnggKyBncmlkUmVjdC53aWR0aDtcbiAgICAgICAgcDJbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvckluZGV4ID0gbGluZUNvdW50KysgJSBsaW5lQ29sb3JzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fYXhpc0dyb3VwLmFkZChuZXcgZ3JhcGhpYy5MaW5lKGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUoe1xuICAgICAgICBhbmlkOiAnbGluZV8nICsgdGlja3NbaV0sXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgeDE6IHAxWzBdLFxuICAgICAgICAgIHkxOiBwMVsxXSxcbiAgICAgICAgICB4MjogcDJbMF0sXG4gICAgICAgICAgeTI6IHAyWzFdXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIHN0cm9rZTogbGluZUNvbG9yc1tjb2xvckluZGV4XVxuICAgICAgICB9LCBsaW5lU3R5bGUpLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgKiBAcGFyYW0ge251bWJlcnxGdW5jdGlvbn0gbGFiZWxJbnRlcnZhbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NwbGl0QXJlYTogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBsYWJlbEludGVydmFsKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcblxuICAgIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzcGxpdEFyZWFNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRBcmVhJyk7XG4gICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc3BsaXRBcmVhTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZScpO1xuICAgIHZhciBhcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBncmlkUmVjdCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcbiAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKCk7XG4gICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuICAgIHZhciBwcmV2WCA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1swXSk7XG4gICAgdmFyIHByZXZZID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzWzBdKTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhcmVhSW50ZXJ2YWwgPSBnZXRJbnRlcnZhbChzcGxpdEFyZWFNb2RlbCwgbGFiZWxJbnRlcnZhbCk7XG4gICAgdmFyIGFyZWFTdHlsZSA9IGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuICAgIGFyZWFDb2xvcnMgPSB6clV0aWwuaXNBcnJheShhcmVhQ29sb3JzKSA/IGFyZWFDb2xvcnMgOiBbYXJlYUNvbG9yc107XG4gICAgdmFyIHNob3dNaW5MYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWluTGFiZWwnKTtcbiAgICB2YXIgc2hvd01heExhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNYXhMYWJlbCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGksIGFyZWFJbnRlcnZhbCwgdGlja3NDb29yZHMubGVuZ3RoLCBzaG93TWluTGFiZWwsIHNob3dNYXhMYWJlbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbaV0pO1xuICAgICAgdmFyIHg7XG4gICAgICB2YXIgeTtcbiAgICAgIHZhciB3aWR0aDtcbiAgICAgIHZhciBoZWlnaHQ7XG5cbiAgICAgIGlmIChheGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHggPSBwcmV2WDtcbiAgICAgICAgeSA9IGdyaWRSZWN0Lnk7XG4gICAgICAgIHdpZHRoID0gdGlja0Nvb3JkIC0geDtcbiAgICAgICAgaGVpZ2h0ID0gZ3JpZFJlY3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGdyaWRSZWN0Lng7XG4gICAgICAgIHkgPSBwcmV2WTtcbiAgICAgICAgd2lkdGggPSBncmlkUmVjdC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGlja0Nvb3JkIC0geTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9ySW5kZXggPSBjb3VudCsrICUgYXJlYUNvbG9ycy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX2F4aXNHcm91cC5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgIGFuaWQ6ICdhcmVhXycgKyB0aWNrc1tpXSxcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIGZpbGw6IGFyZWFDb2xvcnNbY29sb3JJbmRleF1cbiAgICAgICAgfSwgYXJlYVN0eWxlKSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KSk7XG5cbiAgICAgIHByZXZYID0geCArIHdpZHRoO1xuICAgICAgcHJldlkgPSB5ICsgaGVpZ2h0O1xuICAgIH1cbiAgfVxufSk7XG5DYXJ0ZXNpYW5BeGlzVmlldy5leHRlbmQoe1xuICB0eXBlOiAneEF4aXMnXG59KTtcbkNhcnRlc2lhbkF4aXNWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICd5QXhpcydcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0NhcnRlc2lhbkF4aXNWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9DYXJ0ZXNpYW5BeGlzVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQge2xhYmVsSW5zaWRlfVxuICogQHJldHVybiB7T2JqZWN0fSB7XG4gKiAgcG9zaXRpb24sIHJvdGF0aW9uLCBsYWJlbERpcmVjdGlvbiwgbGFiZWxPZmZzZXQsXG4gKiAgdGlja0RpcmVjdGlvbiwgbGFiZWxSb3RhdGUsIGxhYmVsSW50ZXJ2YWwsIHoyXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGxheW91dChncmlkTW9kZWwsIGF4aXNNb2RlbCwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgdmFyIGxheW91dCA9IHt9O1xuICB2YXIgcmF3QXhpc1Bvc2l0aW9uID0gYXhpcy5wb3NpdGlvbjtcbiAgdmFyIGF4aXNQb3NpdGlvbiA9IGF4aXMub25aZXJvID8gJ29uWmVybycgOiByYXdBeGlzUG9zaXRpb247XG4gIHZhciBheGlzRGltID0gYXhpcy5kaW07XG4gIHZhciByZWN0ID0gZ3JpZC5nZXRSZWN0KCk7XG4gIHZhciByZWN0Qm91bmQgPSBbcmVjdC54LCByZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnksIHJlY3QueSArIHJlY3QuaGVpZ2h0XTtcbiAgdmFyIGlkeCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAxLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDEsXG4gICAgb25aZXJvOiAyXG4gIH07XG4gIHZhciBheGlzT2Zmc2V0ID0gYXhpc01vZGVsLmdldCgnb2Zmc2V0JykgfHwgMDtcbiAgdmFyIHBvc0JvdW5kID0gYXhpc0RpbSA9PT0gJ3gnID8gW3JlY3RCb3VuZFsyXSAtIGF4aXNPZmZzZXQsIHJlY3RCb3VuZFszXSArIGF4aXNPZmZzZXRdIDogW3JlY3RCb3VuZFswXSAtIGF4aXNPZmZzZXQsIHJlY3RCb3VuZFsxXSArIGF4aXNPZmZzZXRdO1xuXG4gIGlmIChheGlzLm9uWmVybykge1xuICAgIHZhciBvdGhlckF4aXMgPSBncmlkLmdldEF4aXMoYXhpc0RpbSA9PT0gJ3gnID8gJ3knIDogJ3gnLCBheGlzLm9uWmVyb0F4aXNJbmRleCk7XG4gICAgdmFyIG9uWmVyb0Nvb3JkID0gb3RoZXJBeGlzLnRvR2xvYmFsQ29vcmQob3RoZXJBeGlzLmRhdGFUb0Nvb3JkKDApKTtcbiAgICBwb3NCb3VuZFtpZHhbJ29uWmVybyddXSA9IE1hdGgubWF4KE1hdGgubWluKG9uWmVyb0Nvb3JkLCBwb3NCb3VuZFsxXSksIHBvc0JvdW5kWzBdKTtcbiAgfSAvLyBBeGlzIHBvc2l0aW9uXG5cblxuICBsYXlvdXQucG9zaXRpb24gPSBbYXhpc0RpbSA9PT0gJ3knID8gcG9zQm91bmRbaWR4W2F4aXNQb3NpdGlvbl1dIDogcmVjdEJvdW5kWzBdLCBheGlzRGltID09PSAneCcgPyBwb3NCb3VuZFtpZHhbYXhpc1Bvc2l0aW9uXV0gOiByZWN0Qm91bmRbM11dOyAvLyBBeGlzIHJvdGF0aW9uXG5cbiAgbGF5b3V0LnJvdGF0aW9uID0gTWF0aC5QSSAvIDIgKiAoYXhpc0RpbSA9PT0gJ3gnID8gMCA6IDEpOyAvLyBUaWNrIGFuZCBsYWJlbCBkaXJlY3Rpb24sIHggeSBpcyBheGlzRGltXG5cbiAgdmFyIGRpck1hcCA9IHtcbiAgICB0b3A6IC0xLFxuICAgIGJvdHRvbTogMSxcbiAgICBsZWZ0OiAtMSxcbiAgICByaWdodDogMVxuICB9O1xuICBsYXlvdXQubGFiZWxEaXJlY3Rpb24gPSBsYXlvdXQudGlja0RpcmVjdGlvbiA9IGxheW91dC5uYW1lRGlyZWN0aW9uID0gZGlyTWFwW3Jhd0F4aXNQb3NpdGlvbl07XG4gIGxheW91dC5sYWJlbE9mZnNldCA9IGF4aXMub25aZXJvID8gcG9zQm91bmRbaWR4W3Jhd0F4aXNQb3NpdGlvbl1dIC0gcG9zQm91bmRbaWR4Wydvblplcm8nXV0gOiAwO1xuXG4gIGlmIChheGlzTW9kZWwuZ2V0KCdheGlzVGljay5pbnNpZGUnKSkge1xuICAgIGxheW91dC50aWNrRGlyZWN0aW9uID0gLWxheW91dC50aWNrRGlyZWN0aW9uO1xuICB9XG5cbiAgaWYgKHpyVXRpbC5yZXRyaWV2ZShvcHQubGFiZWxJbnNpZGUsIGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5pbnNpZGUnKSkpIHtcbiAgICBsYXlvdXQubGFiZWxEaXJlY3Rpb24gPSAtbGF5b3V0LmxhYmVsRGlyZWN0aW9uO1xuICB9IC8vIFNwZWNpYWwgbGFiZWwgcm90YXRpb25cblxuXG4gIHZhciBsYWJlbFJvdGF0ZSA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5yb3RhdGUnKTtcbiAgbGF5b3V0LmxhYmVsUm90YXRlID0gYXhpc1Bvc2l0aW9uID09PSAndG9wJyA/IC1sYWJlbFJvdGF0ZSA6IGxhYmVsUm90YXRlOyAvLyBsYWJlbCBpbnRlcnZhbCB3aGVuIGF1dG8gbW9kZS5cblxuICBsYXlvdXQubGFiZWxJbnRlcnZhbCA9IGF4aXMuZ2V0TGFiZWxJbnRlcnZhbCgpOyAvLyBPdmVyIHNwbGl0TGluZSBhbmQgc3BsaXRBcmVhXG5cbiAgbGF5b3V0LnoyID0gMTtcbiAgcmV0dXJuIGxheW91dDtcbn1cblxuZXhwb3J0cy5sYXlvdXQgPSBsYXlvdXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvY2FydGVzaWFuQXhpc0hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvY2FydGVzaWFuQXhpc0hlbHBlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgYXhpc1BvaW50ZXJNb2RlbEhlbHBlciA9IHJlcXVpcmUoXCIuL2F4aXNQb2ludGVyL21vZGVsSGVscGVyXCIpO1xuXG52YXIgYXhpc1RyaWdnZXIgPSByZXF1aXJlKFwiLi9heGlzUG9pbnRlci9heGlzVHJpZ2dlclwiKTtcblxucmVxdWlyZShcIi4vYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJNb2RlbFwiKTtcblxucmVxdWlyZShcIi4vYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJWaWV3XCIpO1xuXG5yZXF1aXJlKFwiLi9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlclwiKTtcblxuLy8gQ2FydGVzaWFuQXhpc1BvaW50ZXIgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHJlcXVpcmVkIGhlcmUuIEJ1dCBjb25zaWRlclxuLy8gZWNoYXJ0cy5zaW1wbGUuanMgYW5kIG9ubGluZSBidWlsZCB0b29sdGlwLCB3aGljaCBvbmx5IHJlcXVpcmUgZ3JpZFNpbXBsZSxcbi8vIENhcnRlc2lhbkF4aXNQb2ludGVyIHNob3VsZCBiZSBhYmxlIHRvIHJlcXVpcmVkIHNvbWV3aGVyZS5cbmVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdGlvbikge1xuICAvLyBBbHdheXMgaGFzIGEgZ2xvYmFsIGF4aXNQb2ludGVyTW9kZWwgZm9yIGRlZmF1bHQgc2V0dGluZy5cbiAgaWYgKG9wdGlvbikge1xuICAgICghb3B0aW9uLmF4aXNQb2ludGVyIHx8IG9wdGlvbi5heGlzUG9pbnRlci5sZW5ndGggPT09IDApICYmIChvcHRpb24uYXhpc1BvaW50ZXIgPSB7fSk7XG4gICAgdmFyIGxpbmsgPSBvcHRpb24uYXhpc1BvaW50ZXIubGluazsgLy8gTm9ybWFsaXplIHRvIGFycmF5IHRvIGF2b2lkIG9iamVjdCBtZXJnaW4uIEJ1dCBpZiBsaW5rXG4gICAgLy8gaXMgbm90IHNldCwgcmVtYWluIG51bGwvdW5kZWZpbmVkLCBvdGhlcndpc2UgaXQgd2lsbFxuICAgIC8vIG92ZXJyaWRlIGV4aXN0ZW50IGxpbmsgc2V0dGluZy5cblxuICAgIGlmIChsaW5rICYmICF6clV0aWwuaXNBcnJheShsaW5rKSkge1xuICAgICAgb3B0aW9uLmF4aXNQb2ludGVyLmxpbmsgPSBbbGlua107XG4gICAgfVxuICB9XG59KTsgLy8gVGhpcyBwcm9jZXNzIHNob3VsZCBwcm9mb3JtZWQgYWZ0ZXIgY29vcmRpbmF0ZSBzeXN0ZW1zIGNyZWF0ZWRcbi8vIGFuZCBzZXJpZXMgZGF0YSBwcm9jZXNzZWQuIFNvIHB1dCBpdCBvbiBzdGF0aXN0aWMgcHJvY2Vzc2luZyBzdGFnZS5cblxuZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihlY2hhcnRzLlBSSU9SSVRZLlBST0NFU1NPUi5TVEFUSVNUSUMsIGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgLy8gQnVpbGQgYXhpc1BvaW50ZXJNb2RlbCwgbWVyZ2luIHRvb2x0aXAuYXhpc1BvaW50ZXIgbW9kZWwgZm9yIGVhY2ggYXhpcy5cbiAgLy8gYWxsQXhlc0luZm8gc2hvdWxkIGJlIHVwZGF0ZWQgd2hlbiBzZXRPcHRpb24gcGVyZm9ybWVkLlxuICBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvID0gYXhpc1BvaW50ZXJNb2RlbEhlbHBlci5jb2xsZWN0KGVjTW9kZWwsIGFwaSk7XG59KTsgLy8gQnJvYWRjYXN0IHRvIGFsbCB2aWV3cy5cblxuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gIGV2ZW50OiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICB1cGRhdGU6ICc6dXBkYXRlQXhpc1BvaW50ZXInXG59LCBheGlzVHJpZ2dlcik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgQXhpc1BvaW50ZXJNb2RlbCA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuICB0eXBlOiAnYXhpc1BvaW50ZXInLFxuICBjb29yZFN5c0F4ZXNJbmZvOiBudWxsLFxuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgLy8gJ2F1dG8nIG1lYW5zIHRoYXQgc2hvdyB3aGVuIHRyaWdnZXJlZCBieSB0b29sdGlwIG9yIGhhbmRsZS5cbiAgICBzaG93OiAnYXV0bycsXG4gICAgLy8gJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ25vbmUnXG4gICAgdHJpZ2dlck9uOiBudWxsLFxuICAgIC8vIHNldCBkZWZhdWx0IGluIEF4aXNQb250ZXJWaWV3LmpzXG4gICAgemxldmVsOiAwLFxuICAgIHo6IDUwLFxuICAgIHR5cGU6ICdsaW5lJyxcbiAgICAvLyBheGlzcG9pbnRlciB0cmlnZ2VyZWQgYnkgdG9vdGlwIGRldGVybWluZSBzbmFwIGF1dG9tYXRpY2FsbHksXG4gICAgLy8gc2VlIGBtb2RlbEhlbHBlcmAuXG4gICAgc25hcDogZmFsc2UsXG4gICAgdHJpZ2dlclRvb2x0aXA6IHRydWUsXG4gICAgdmFsdWU6IG51bGwsXG4gICAgc3RhdHVzOiBudWxsLFxuICAgIC8vIEluaXQgdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIGhhbmRsZSBpcyB1c2VkLlxuICAgIC8vIFtncm91cDAsIGdyb3VwMSwgLi4uXVxuICAgIC8vIEVhY2ggZ3JvdXAgY2FuIGJlOiB7XG4gICAgLy8gICAgICBtYXBwZXI6IGZ1bmN0aW9uICgpIHt9LFxuICAgIC8vICAgICAgc2luZ2xlVG9vbHRpcDogJ211bHRpcGxlJywgIC8vICdtdWx0aXBsZScgb3IgJ3NpbmdsZSdcbiAgICAvLyAgICAgIHhBeGlzSWQ6IC4uLixcbiAgICAvLyAgICAgIHlBeGlzTmFtZTogLi4uLFxuICAgIC8vICAgICAgYW5nbGVBeGlzSW5kZXg6IC4uLlxuICAgIC8vIH1cbiAgICAvLyBtYXBwZXI6IGNhbiBiZSBpZ25vcmVkLlxuICAgIC8vICAgICAgaW5wdXQ6IHtheGlzSW5mbywgdmFsdWV9XG4gICAgLy8gICAgICBvdXRwdXQ6IHtheGlzSW5mbywgdmFsdWV9XG4gICAgbGluazogW10sXG4gICAgLy8gRG8gbm90IHNldCAnYXV0bycgaGVyZSwgb3RoZXJ3aXNlIGdsb2JhbCBhbmltYXRpb246IGZhbHNlXG4gICAgLy8gd2lsbCBub3QgZWZmZWN0IGF0IHRoaXMgYXhpc3BvaW50ZXIuXG4gICAgYW5pbWF0aW9uOiBudWxsLFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAyMDAsXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNhYWEnLFxuICAgICAgd2lkdGg6IDEsXG4gICAgICB0eXBlOiAnc29saWQnXG4gICAgfSxcbiAgICBzaGFkb3dTdHlsZToge1xuICAgICAgY29sb3I6ICdyZ2JhKDE1MCwxNTAsMTUwLDAuMyknXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIGZvcm1hdHRlcjogbnVsbCxcbiAgICAgIC8vIHN0cmluZyB8IEZ1bmN0aW9uXG4gICAgICBwcmVjaXNpb246ICdhdXRvJyxcbiAgICAgIC8vIE9yIGEgbnVtYmVyIGxpa2UgMCwgMSwgMiAuLi5cbiAgICAgIG1hcmdpbjogMyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBwYWRkaW5nOiBbNSwgNywgNSwgN10sXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdhdXRvJyxcbiAgICAgIC8vIGRlZmF1bHQ6IGF4aXMgbGluZSBjb2xvclxuICAgICAgYm9yZGVyQ29sb3I6IG51bGwsXG4gICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgIHNoYWRvd0JsdXI6IDMsXG4gICAgICBzaGFkb3dDb2xvcjogJyNhYWEnIC8vIENvbnNpZGVyaW5nIGFwcGxpY2FiaWxpdHksIGNvbW1vbiBzdHlsZSBzaG91bGRcbiAgICAgIC8vIGJldHRlciBub3QgaGF2ZSBzaGFkb3dPZmZzZXQuXG4gICAgICAvLyBzaGFkb3dPZmZzZXRYOiAwLFxuICAgICAgLy8gc2hhZG93T2Zmc2V0WTogMlxuXG4gICAgfSxcbiAgICBoYW5kbGU6IHtcbiAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgaWNvbjogJ00xMC43LDExLjl2LTEuM0g5LjN2MS4zYy00LjksMC4zLTguOCw0LjQtOC44LDkuNGMwLDUsMy45LDkuMSw4LjgsOS40aDEuM2M0LjktMC4zLDguOC00LjQsOC44LTkuNEMxOS41LDE2LjMsMTUuNiwxMi4yLDEwLjcsMTEuOXogTTEzLjMsMjQuNEg2Ljd2LTEuMmg2LjZ6IE0xMy4zLDIySDYuN3YtMS4yaDYuNnogTTEzLjMsMTkuNkg2Ljd2LTEuMmg2LjZ6JyxcbiAgICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgc2l6ZTogNDUsXG4gICAgICAvLyBoYW5kbGUgbWFyZ2luIGlzIGZyb20gc3ltYm9sIGNlbnRlciB0byBheGlzLCB3aGljaCBpcyBzdGFibGUgd2hlbiBjaXJjdWxhciBtb3ZlLlxuICAgICAgbWFyZ2luOiA1MCxcbiAgICAgIC8vIGNvbG9yOiAnIzFiOGJiZCdcbiAgICAgIC8vIGNvbG9yOiAnIzJmNDU1NCdcbiAgICAgIGNvbG9yOiAnIzMzMycsXG4gICAgICBzaGFkb3dCbHVyOiAzLFxuICAgICAgc2hhZG93Q29sb3I6ICcjYWFhJyxcbiAgICAgIHNoYWRvd09mZnNldFg6IDAsXG4gICAgICBzaGFkb3dPZmZzZXRZOiAyLFxuICAgICAgLy8gRm9yIG1vYmlsZSBwZXJmb3JtYW5jZVxuICAgICAgdGhyb3R0bGU6IDQwXG4gICAgfVxuICB9XG59KTtcbnZhciBfZGVmYXVsdCA9IEF4aXNQb2ludGVyTW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlck1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJNb2RlbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciBnbG9iYWxMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2dsb2JhbExpc3RlbmVyXCIpO1xuXG52YXIgQXhpc1BvaW50ZXJWaWV3ID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ2F4aXNQb2ludGVyJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGdsb2JhbFRvb2x0aXBNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sdGlwJyk7XG4gICAgdmFyIHRyaWdnZXJPbiA9IGdsb2JhbEF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKSB8fCBnbG9iYWxUb29sdGlwTW9kZWwgJiYgZ2xvYmFsVG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlck9uJykgfHwgJ21vdXNlbW92ZXxjbGljayc7IC8vIFJlZ2lzdGVyIGdsb2JhbCBsaXN0ZW5lciBpbiBBeGlzUG9pbnRlclZpZXcgdG8gZW5hYmxlXG4gICAgLy8gQXhpc1BvaW50ZXJWaWV3IHRvIGJlIGluZGVwZW5kZW50IHRvIFRvb2x0aXAuXG5cbiAgICBnbG9iYWxMaXN0ZW5lci5yZWdpc3RlcignYXhpc1BvaW50ZXInLCBhcGksIGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgIC8vIElmICdub25lJywgaXQgaXMgbm90IGNvbnRyb2xsZWQgYnkgbW91c2UgdG90YWxseS5cbiAgICAgIGlmICh0cmlnZ2VyT24gIT09ICdub25lJyAmJiAoY3VyclRyaWdnZXIgPT09ICdsZWF2ZScgfHwgdHJpZ2dlck9uLmluZGV4T2YoY3VyclRyaWdnZXIpID49IDApKSB7XG4gICAgICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICAgIGN1cnJUcmlnZ2VyOiBjdXJyVHJpZ2dlcixcbiAgICAgICAgICB4OiBlICYmIGUub2Zmc2V0WCxcbiAgICAgICAgICB5OiBlICYmIGUub2Zmc2V0WVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBnbG9iYWxMaXN0ZW5lci51bnJlZ2lzdGVyKGFwaS5nZXRacigpLCAnYXhpc1BvaW50ZXInKTtcbiAgICBBeGlzUG9pbnRlclZpZXcuc3VwZXJBcHBseSh0aGlzLl9tb2RlbCwgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIoJ2F4aXNQb2ludGVyJywgYXBpKTtcbiAgICBBeGlzUG9pbnRlclZpZXcuc3VwZXJBcHBseSh0aGlzLl9tb2RlbCwgJ2Rpc3Bvc2UnLCBhcmd1bWVudHMpO1xuICB9XG59KTtcbnZhciBfZGVmYXVsdCA9IEF4aXNQb2ludGVyVmlldztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgY2xhenpVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIgPSByZXF1aXJlKFwiLi9tb2RlbEhlbHBlclwiKTtcblxudmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgdGhyb3R0bGVVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvdGhyb3R0bGVcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGdldCA9IG1vZGVsVXRpbC5tYWtlR2V0dGVyKCk7XG52YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG52YXIgYmluZCA9IHpyVXRpbC5iaW5kO1xuLyoqXG4gKiBCYXNlIGF4aXMgcG9pbnRlciBjbGFzcyBpbiAyRC5cbiAqIEltcGxlbWVuZW50cyB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2F4aXMvSUF4aXNQb2ludGVyfS5cbiAqL1xuXG5mdW5jdGlvbiBCYXNlQXhpc1BvaW50ZXIoKSB7fVxuXG5CYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ncm91cDogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sYXN0R3JhcGhpY0tleTogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZHJhZ2dpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2xhc3RWYWx1ZTogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sYXN0U3RhdHVzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BheWxvYWRJbmZvOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJbiBweCwgYXJiaXRyYXJ5IHZhbHVlLiBEbyBub3Qgc2V0IHRvbyBzbWFsbCxcbiAgICogbm8gYW5pbWF0aW9uIGlzIG9rIGZvciBtb3N0IGNhc2VzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBhbmltYXRpb25UaHJlc2hvbGQ6IDE1LFxuXG4gIC8qKlxuICAgKiBAaW1wbGVtZW50XG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwgZm9yY2VSZW5kZXIpIHtcbiAgICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgICB2YXIgc3RhdHVzID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3N0YXR1cycpOyAvLyBCaW5kIHRoZW0gdG8gYHRoaXNgLCBub3QgaW4gY2xvc3VyZSwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBub3RcbiAgICAvLyBiZSByZXBsYWNlZCB3aGVuIHVzZXIgY2FsbGluZyBzZXRPcHRpb24gaW4gbm90IG1lcmdlIG1vZGUuXG5cbiAgICB0aGlzLl9heGlzTW9kZWwgPSBheGlzTW9kZWw7XG4gICAgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWw7XG4gICAgdGhpcy5fYXBpID0gYXBpOyAvLyBPcHRpbWl6ZTogYHJlbmRlcmAgd2lsbCBiZSBjYWxsZWQgcmVwZWF0bHkgZHVyaW5nIG1vdXNlIG1vdmUuXG4gICAgLy8gU28gaXQgaXMgcG93ZXIgY29uc3VtaW5nIGlmIHBlcmZvcm1pbmcgYHJlbmRlcmAgZWFjaCB0aW1lLFxuICAgIC8vIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZS5cblxuICAgIGlmICghZm9yY2VSZW5kZXIgJiYgdGhpcy5fbGFzdFZhbHVlID09PSB2YWx1ZSAmJiB0aGlzLl9sYXN0U3RhdHVzID09PSBzdGF0dXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9sYXN0U3RhdHVzID0gc3RhdHVzO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3VwO1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG5cbiAgICBpZiAoIXN0YXR1cyB8fCBzdGF0dXMgPT09ICdoaWRlJykge1xuICAgICAgLy8gRG8gbm90IGNsZWFyIGhlcmUsIGZvciBhbmltYXRpb24gYmV0dGVyLlxuICAgICAgZ3JvdXAgJiYgZ3JvdXAuaGlkZSgpO1xuICAgICAgaGFuZGxlICYmIGhhbmRsZS5oaWRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ3JvdXAgJiYgZ3JvdXAuc2hvdygpO1xuICAgIGhhbmRsZSAmJiBoYW5kbGUuc2hvdygpOyAvLyBPdGhlcndpc2Ugc3RhdHVzIGlzICdzaG93J1xuXG4gICAgdmFyIGVsT3B0aW9uID0ge307XG4gICAgdGhpcy5tYWtlRWxPcHRpb24oZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSk7IC8vIEVuYWJsZSBjaGFuZ2UgYXhpcyBwb2ludGVyIHR5cGUuXG5cbiAgICB2YXIgZ3JhcGhpY0tleSA9IGVsT3B0aW9uLmdyYXBoaWNLZXk7XG5cbiAgICBpZiAoZ3JhcGhpY0tleSAhPT0gdGhpcy5fbGFzdEdyYXBoaWNLZXkpIHtcbiAgICAgIHRoaXMuY2xlYXIoYXBpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0R3JhcGhpY0tleSA9IGdyYXBoaWNLZXk7XG4gICAgdmFyIG1vdmVBbmltYXRpb24gPSB0aGlzLl9tb3ZlQW5pbWF0aW9uID0gdGhpcy5kZXRlcm1pbmVBbmltYXRpb24oYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIGdyb3VwID0gdGhpcy5fZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgdGhpcy5jcmVhdGVQb2ludGVyRWwoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgdGhpcy5jcmVhdGVMYWJlbEVsKGdyb3VwLCBlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKTtcbiAgICAgIGFwaS5nZXRacigpLmFkZChncm91cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb1VwZGF0ZVByb3BzID0genJVdGlsLmN1cnJ5KHVwZGF0ZVByb3BzLCBheGlzUG9pbnRlck1vZGVsLCBtb3ZlQW5pbWF0aW9uKTtcbiAgICAgIHRoaXMudXBkYXRlUG9pbnRlckVsKGdyb3VwLCBlbE9wdGlvbiwgZG9VcGRhdGVQcm9wcywgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsRWwoZ3JvdXAsIGVsT3B0aW9uLCBkb1VwZGF0ZVByb3BzLCBheGlzUG9pbnRlck1vZGVsKTtcbiAgICB9XG5cbiAgICB1cGRhdGVNYW5kYXRvcnlQcm9wcyhncm91cCwgYXhpc1BvaW50ZXJNb2RlbCwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9yZW5kZXJIYW5kbGUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAaW1wbGVtZW50XG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLmNsZWFyKGFwaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBpbXBsZW1lbnRcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLmNsZWFyKGFwaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRldGVybWluZUFuaW1hdGlvbjogZnVuY3Rpb24gKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBhbmltYXRpb24gPSBheGlzUG9pbnRlck1vZGVsLmdldCgnYW5pbWF0aW9uJyk7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgaXNDYXRlZ29yeUF4aXMgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgdmFyIHVzZVNuYXAgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc25hcCcpOyAvLyBWYWx1ZSBheGlzIHdpdGhvdXQgc25hcCBhbHdheXMgZG8gbm90IHNuYXAuXG5cbiAgICBpZiAoIXVzZVNuYXAgJiYgIWlzQ2F0ZWdvcnlBeGlzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGlvbiA9PT0gJ2F1dG8nIHx8IGFuaW1hdGlvbiA9PSBudWxsKSB7XG4gICAgICB2YXIgYW5pbWF0aW9uVGhyZXNob2xkID0gdGhpcy5hbmltYXRpb25UaHJlc2hvbGQ7XG5cbiAgICAgIGlmIChpc0NhdGVnb3J5QXhpcyAmJiBheGlzLmdldEJhbmRXaWR0aCgpID4gYW5pbWF0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gYXV0byBhbmltYXRpb24gd2hlbiBzbmFwIHVzZWQuIENvbnNpZGVyIGlmIHRoZXJlIGlzXG4gICAgICAvLyBhIGRhdGFab29tLCBhbmltYXRpb24gd2lsbCBiZSBkaXNhYmxlZCB3aGVuIHRvbyBtYW55IHBvaW50cyBleGlzdCwgd2hpbGVcbiAgICAgIC8vIGl0IHdpbGwgYmUgZW5hYmxlZCBmb3IgYmV0dGVyIHZpc3VhbCBlZmZlY3Qgd2hlbiBsaXR0bGUgcG9pbnRzIGV4aXN0LlxuXG5cbiAgICAgIGlmICh1c2VTbmFwKSB7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhQ291bnQgPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmdldEF4aXNJbmZvKGF4aXNNb2RlbCkuc2VyaWVzRGF0YUNvdW50O1xuICAgICAgICB2YXIgYXhpc0V4dGVudCA9IGF4aXMuZ2V0RXh0ZW50KCk7IC8vIEFwcHJveGltYXRlIGJhbmQgd2lkdGhcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXhpc0V4dGVudFswXSAtIGF4aXNFeHRlbnRbMV0pIC8gc2VyaWVzRGF0YUNvdW50ID4gYW5pbWF0aW9uVGhyZXNob2xkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbiA9PT0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYWRkIHtwb2ludGVyLCBsYWJlbCwgZ3JhcGhpY0tleX0gdG8gZWxPcHRpb25cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbWFrZUVsT3B0aW9uOiBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkgey8vIFNob3VsZSBiZSBpbXBsZW1lbmVudGVkIGJ5IHN1Yi1jbGFzcy5cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY3JlYXRlUG9pbnRlckVsOiBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgcG9pbnRlck9wdGlvbiA9IGVsT3B0aW9uLnBvaW50ZXI7XG5cbiAgICBpZiAocG9pbnRlck9wdGlvbikge1xuICAgICAgdmFyIHBvaW50ZXJFbCA9IGdldChncm91cCkucG9pbnRlckVsID0gbmV3IGdyYXBoaWNbcG9pbnRlck9wdGlvbi50eXBlXShjbG9uZShlbE9wdGlvbi5wb2ludGVyKSk7XG4gICAgICBncm91cC5hZGQocG9pbnRlckVsKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNyZWF0ZUxhYmVsRWw6IGZ1bmN0aW9uIChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIGlmIChlbE9wdGlvbi5sYWJlbCkge1xuICAgICAgdmFyIGxhYmVsRWwgPSBnZXQoZ3JvdXApLmxhYmVsRWwgPSBuZXcgZ3JhcGhpYy5SZWN0KGNsb25lKGVsT3B0aW9uLmxhYmVsKSk7XG4gICAgICBncm91cC5hZGQobGFiZWxFbCk7XG4gICAgICB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdXBkYXRlUG9pbnRlckVsOiBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCB1cGRhdGVQcm9wcykge1xuICAgIHZhciBwb2ludGVyRWwgPSBnZXQoZ3JvdXApLnBvaW50ZXJFbDtcblxuICAgIGlmIChwb2ludGVyRWwpIHtcbiAgICAgIHBvaW50ZXJFbC5zZXRTdHlsZShlbE9wdGlvbi5wb2ludGVyLnN0eWxlKTtcbiAgICAgIHVwZGF0ZVByb3BzKHBvaW50ZXJFbCwge1xuICAgICAgICBzaGFwZTogZWxPcHRpb24ucG9pbnRlci5zaGFwZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB1cGRhdGVMYWJlbEVsOiBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCB1cGRhdGVQcm9wcywgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBsYWJlbEVsID0gZ2V0KGdyb3VwKS5sYWJlbEVsO1xuXG4gICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgIGxhYmVsRWwuc2V0U3R5bGUoZWxPcHRpb24ubGFiZWwuc3R5bGUpO1xuICAgICAgdXBkYXRlUHJvcHMobGFiZWxFbCwge1xuICAgICAgICAvLyBDb25zaWRlciB0ZXh0IGxlbmd0aCBjaGFuZ2UgaW4gdmVydGljYWwgYXhpcywgYW5pbWF0aW9uIHNob3VsZFxuICAgICAgICAvLyBiZSB1c2VkIG9uIHNoYXBlLCBvdGhlcndpc2UgdGhlIGVmZmVjdCB3aWxsIGJlIHdlaXJkLlxuICAgICAgICBzaGFwZTogZWxPcHRpb24ubGFiZWwuc2hhcGUsXG4gICAgICAgIHBvc2l0aW9uOiBlbE9wdGlvbi5sYWJlbC5wb3NpdGlvblxuICAgICAgfSk7XG4gICAgICB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJIYW5kbGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9kcmFnZ2luZyB8fCAhdGhpcy51cGRhdGVIYW5kbGVUcmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IHRoaXMuX2F4aXNQb2ludGVyTW9kZWw7XG5cbiAgICB2YXIgenIgPSB0aGlzLl9hcGkuZ2V0WnIoKTtcblxuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgdmFyIGhhbmRsZU1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbC5nZXRNb2RlbCgnaGFuZGxlJyk7XG4gICAgdmFyIHN0YXR1cyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzdGF0dXMnKTtcblxuICAgIGlmICghaGFuZGxlTW9kZWwuZ2V0KCdzaG93JykgfHwgIXN0YXR1cyB8fCBzdGF0dXMgPT09ICdoaWRlJykge1xuICAgICAgaGFuZGxlICYmIHpyLnJlbW92ZShoYW5kbGUpO1xuICAgICAgdGhpcy5faGFuZGxlID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXNJbml0O1xuXG4gICAgaWYgKCF0aGlzLl9oYW5kbGUpIHtcbiAgICAgIGlzSW5pdCA9IHRydWU7XG4gICAgICBoYW5kbGUgPSB0aGlzLl9oYW5kbGUgPSBncmFwaGljLmNyZWF0ZUljb24oaGFuZGxlTW9kZWwuZ2V0KCdpY29uJyksIHtcbiAgICAgICAgY3Vyc29yOiAnbW92ZScsXG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgb25tb3VzZW1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8gRm90IG1vYmlsZSBkZXZpY2VtLCBwcmV2ZW50IHNjcmVlbiBzbGlkZXIgb24gdGhlIGJ1dHRvbi5cbiAgICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25tb3VzZWRvd246IGJpbmQodGhpcy5fb25IYW5kbGVEcmFnTW92ZSwgdGhpcywgMCwgMCksXG4gICAgICAgIGRyaWZ0OiBiaW5kKHRoaXMuX29uSGFuZGxlRHJhZ01vdmUsIHRoaXMpLFxuICAgICAgICBvbmRyYWdlbmQ6IGJpbmQodGhpcy5fb25IYW5kbGVEcmFnRW5kLCB0aGlzKVxuICAgICAgfSk7XG4gICAgICB6ci5hZGQoaGFuZGxlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVNYW5kYXRvcnlQcm9wcyhoYW5kbGUsIGF4aXNQb2ludGVyTW9kZWwsIGZhbHNlKTsgLy8gdXBkYXRlIHN0eWxlXG5cbiAgICB2YXIgaW5jbHVkZVN0eWxlcyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYm9yZGVyV2lkdGgnLCAnb3BhY2l0eScsICdzaGFkb3dDb2xvcicsICdzaGFkb3dCbHVyJywgJ3NoYWRvd09mZnNldFgnLCAnc2hhZG93T2Zmc2V0WSddO1xuICAgIGhhbmRsZS5zZXRTdHlsZShoYW5kbGVNb2RlbC5nZXRJdGVtU3R5bGUobnVsbCwgaW5jbHVkZVN0eWxlcykpOyAvLyB1cGRhdGUgcG9zaXRpb25cblxuICAgIHZhciBoYW5kbGVTaXplID0gaGFuZGxlTW9kZWwuZ2V0KCdzaXplJyk7XG5cbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGhhbmRsZVNpemUpKSB7XG4gICAgICBoYW5kbGVTaXplID0gW2hhbmRsZVNpemUsIGhhbmRsZVNpemVdO1xuICAgIH1cblxuICAgIGhhbmRsZS5hdHRyKCdzY2FsZScsIFtoYW5kbGVTaXplWzBdIC8gMiwgaGFuZGxlU2l6ZVsxXSAvIDJdKTtcbiAgICB0aHJvdHRsZVV0aWwuY3JlYXRlT3JVcGRhdGUodGhpcywgJ19kb0Rpc3BhdGNoQXhpc1BvaW50ZXInLCBoYW5kbGVNb2RlbC5nZXQoJ3Rocm90dGxlJykgfHwgMCwgJ2ZpeFJhdGUnKTtcblxuICAgIHRoaXMuX21vdmVIYW5kbGVUb1ZhbHVlKHZhbHVlLCBpc0luaXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVIYW5kbGVUb1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGlzSW5pdCkge1xuICAgIHVwZGF0ZVByb3BzKHRoaXMuX2F4aXNQb2ludGVyTW9kZWwsICFpc0luaXQgJiYgdGhpcy5fbW92ZUFuaW1hdGlvbiwgdGhpcy5faGFuZGxlLCBnZXRIYW5kbGVUcmFuc1Byb3BzKHRoaXMuZ2V0SGFuZGxlVHJhbnNmb3JtKHZhbHVlLCB0aGlzLl9heGlzTW9kZWwsIHRoaXMuX2F4aXNQb2ludGVyTW9kZWwpKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25IYW5kbGVEcmFnTW92ZTogZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG5cbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTsgLy8gUGVyc2lzdGVudCBmb3IgdGhyb3R0bGUuXG5cbiAgICB2YXIgdHJhbnMgPSB0aGlzLnVwZGF0ZUhhbmRsZVRyYW5zZm9ybShnZXRIYW5kbGVUcmFuc1Byb3BzKGhhbmRsZSksIFtkeCwgZHldLCB0aGlzLl9heGlzTW9kZWwsIHRoaXMuX2F4aXNQb2ludGVyTW9kZWwpO1xuICAgIHRoaXMuX3BheWxvYWRJbmZvID0gdHJhbnM7XG4gICAgaGFuZGxlLnN0b3BBbmltYXRpb24oKTtcbiAgICBoYW5kbGUuYXR0cihnZXRIYW5kbGVUcmFuc1Byb3BzKHRyYW5zKSk7XG4gICAgZ2V0KGhhbmRsZSkubGFzdFByb3AgPSBudWxsO1xuXG4gICAgdGhpcy5fZG9EaXNwYXRjaEF4aXNQb2ludGVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRocm90dGxlZCBtZXRob2QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9EaXNwYXRjaEF4aXNQb2ludGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcblxuICAgIGlmICghaGFuZGxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWRJbmZvID0gdGhpcy5fcGF5bG9hZEluZm87XG4gICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuX2F4aXNNb2RlbDtcblxuICAgIHRoaXMuX2FwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgeDogcGF5bG9hZEluZm8uY3Vyc29yUG9pbnRbMF0sXG4gICAgICB5OiBwYXlsb2FkSW5mby5jdXJzb3JQb2ludFsxXSxcbiAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWRJbmZvLnRvb2x0aXBPcHRpb24sXG4gICAgICBheGVzSW5mbzogW3tcbiAgICAgICAgYXhpc0RpbTogYXhpc01vZGVsLmF4aXMuZGltLFxuICAgICAgICBheGlzSW5kZXg6IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleFxuICAgICAgfV1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkhhbmRsZURyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlQW5pbWF0aW9uKSB7XG4gICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB2YXIgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuXG4gICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLl9heGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTsgLy8gQ29uc2lkZXIgc25hcCBvciBjYXRlZ3JveSBheGlzLCBoYW5kbGUgbWF5IGJlIG5vdCBjb25zaXN0ZW50IHdpdGhcbiAgICAvLyBheGlzUG9pbnRlci4gU28gbW92ZSBoYW5kbGUgdG8gYWxpZ24gdGhlIGV4YWN0IHZhbHVlIHBvc2l0aW9uIHdoZW5cbiAgICAvLyBkcmFnIGVuZGVkLlxuXG5cbiAgICB0aGlzLl9tb3ZlSGFuZGxlVG9WYWx1ZSh2YWx1ZSk7IC8vIEZvciB0aGUgZWZmZWN0OiB0b29sdGlwIHdpbGwgYmUgc2hvd24gd2hlbiBmaW5nZXIgaG9sZGluZyBvbiBoYW5kbGVcbiAgICAvLyBidXR0b24sIGFuZCB3aWxsIGJlIGhpZGRlbiBhZnRlciBmaW5nZXIgbGVmdCBoYW5kbGUgYnV0dG9uLlxuXG5cbiAgICB0aGlzLl9hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2hpZGVUaXAnXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3VsZCBiZSBpbXBsZW1lbmVudGVkIGJ5IHN1Yi1jbGFzcyBpZiBzdXBwb3J0IGBoYW5kbGVgLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzTW9kZWxcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc1BvaW50ZXJNb2RlbFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHtwb3NpdGlvbjogW3gsIHldLCByb3RhdGlvbjogMH1cbiAgICovXG4gIGdldEhhbmRsZVRyYW5zZm9ybTogbnVsbCxcblxuICAvKipcbiAgICogKiBTaG91bGQgYmUgaW1wbGVtZW5lbnRlZCBieSBzdWItY2xhc3MgaWYgc3VwcG9ydCBgaGFuZGxlYC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIHtwb3NpdGlvbiwgcm90YXRpb259XG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRlbHRhIFtkeCwgZHldXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGF4aXNNb2RlbFxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzUG9pbnRlck1vZGVsXG4gICAqIEByZXR1cm4ge09iamVjdH0ge3Bvc2l0aW9uOiBbeCwgeV0sIHJvdGF0aW9uOiAwLCBjdXJzb3JQb2ludDogW3gsIHldfVxuICAgKi9cbiAgdXBkYXRlSGFuZGxlVHJhbnNmb3JtOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLl9sYXN0VmFsdWUgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RTdGF0dXMgPSBudWxsO1xuICAgIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3VwO1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG5cbiAgICBpZiAoenIgJiYgZ3JvdXApIHtcbiAgICAgIHRoaXMuX2xhc3RHcmFwaGljS2V5ID0gbnVsbDtcbiAgICAgIGdyb3VwICYmIHpyLnJlbW92ZShncm91cCk7XG4gICAgICBoYW5kbGUgJiYgenIucmVtb3ZlKGhhbmRsZSk7XG4gICAgICB0aGlzLl9ncm91cCA9IG51bGw7XG4gICAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICAgICAgdGhpcy5fcGF5bG9hZEluZm8gPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZG9DbGVhcjogZnVuY3Rpb24gKCkgey8vIEltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzcyBpZiBuZWNlc3NhcnkuXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0geHlcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gd2hcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4RGltSW5kZXg9MF0gb3IgMVxuICAgKi9cbiAgYnVpbGRMYWJlbDogZnVuY3Rpb24gKHh5LCB3aCwgeERpbUluZGV4KSB7XG4gICAgeERpbUluZGV4ID0geERpbUluZGV4IHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHh5W3hEaW1JbmRleF0sXG4gICAgICB5OiB4eVsxIC0geERpbUluZGV4XSxcbiAgICAgIHdpZHRoOiB3aFt4RGltSW5kZXhdLFxuICAgICAgaGVpZ2h0OiB3aFsxIC0geERpbUluZGV4XVxuICAgIH07XG4gIH1cbn07XG5CYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFzZUF4aXNQb2ludGVyO1xuXG5mdW5jdGlvbiB1cGRhdGVQcm9wcyhhbmltYXRpb25Nb2RlbCwgbW92ZUFuaW1hdGlvbiwgZWwsIHByb3BzKSB7XG4gIC8vIEFuaW1hdGlvbiBvcHRpbWl6ZS5cbiAgaWYgKCFwcm9wc0VxdWFsKGdldChlbCkubGFzdFByb3AsIHByb3BzKSkge1xuICAgIGdldChlbCkubGFzdFByb3AgPSBwcm9wcztcbiAgICBtb3ZlQW5pbWF0aW9uID8gZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwgcHJvcHMsIGFuaW1hdGlvbk1vZGVsKSA6IChlbC5zdG9wQW5pbWF0aW9uKCksIGVsLmF0dHIocHJvcHMpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wc0VxdWFsKGxhc3RQcm9wcywgbmV3UHJvcHMpIHtcbiAgaWYgKHpyVXRpbC5pc09iamVjdChsYXN0UHJvcHMpICYmIHpyVXRpbC5pc09iamVjdChuZXdQcm9wcykpIHtcbiAgICB2YXIgZXF1YWxzID0gdHJ1ZTtcbiAgICB6clV0aWwuZWFjaChuZXdQcm9wcywgZnVuY3Rpb24gKGl0ZW0sIGtleSkge1xuICAgICAgZXF1YWxzID0gZXF1YWxzICYmIHByb3BzRXF1YWwobGFzdFByb3BzW2tleV0sIGl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiAhIWVxdWFscztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGFzdFByb3BzID09PSBuZXdQcm9wcztcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgbGFiZWxFbFtheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwuc2hvdycpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xufVxuXG5mdW5jdGlvbiBnZXRIYW5kbGVUcmFuc1Byb3BzKHRyYW5zKSB7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHRyYW5zLnBvc2l0aW9uLnNsaWNlKCksXG4gICAgcm90YXRpb246IHRyYW5zLnJvdGF0aW9uIHx8IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWFuZGF0b3J5UHJvcHMoZ3JvdXAsIGF4aXNQb2ludGVyTW9kZWwsIHNpbGVudCkge1xuICB2YXIgeiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd6Jyk7XG4gIHZhciB6bGV2ZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnemxldmVsJyk7XG4gIGdyb3VwICYmIGdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICB6ICE9IG51bGwgJiYgKGVsLnogPSB6KTtcbiAgICAgIHpsZXZlbCAhPSBudWxsICYmIChlbC56bGV2ZWwgPSB6bGV2ZWwpO1xuICAgICAgZWwuc2lsZW50ID0gc2lsZW50O1xuICAgIH1cbiAgfSk7XG59XG5cbmNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChCYXNlQXhpc1BvaW50ZXIpO1xudmFyIF9kZWZhdWx0ID0gQmFzZUF4aXNQb2ludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQmFzZUF4aXNQb2ludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQmFzZUF4aXNQb2ludGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgQmFzZUF4aXNQb2ludGVyID0gcmVxdWlyZShcIi4vQmFzZUF4aXNQb2ludGVyXCIpO1xuXG52YXIgdmlld0hlbHBlciA9IHJlcXVpcmUoXCIuL3ZpZXdIZWxwZXJcIik7XG5cbnZhciBjYXJ0ZXNpYW5BeGlzSGVscGVyID0gcmVxdWlyZShcIi4uL2F4aXMvY2FydGVzaWFuQXhpc0hlbHBlclwiKTtcblxudmFyIEF4aXNWaWV3ID0gcmVxdWlyZShcIi4uL2F4aXMvQXhpc1ZpZXdcIik7XG5cbnZhciBDYXJ0ZXNpYW5BeGlzUG9pbnRlciA9IEJhc2VBeGlzUG9pbnRlci5leHRlbmQoe1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBtYWtlRWxPcHRpb246IGZ1bmN0aW9uIChlbE9wdGlvbiwgdmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgZ3JpZCA9IGF4aXMuZ3JpZDtcbiAgICB2YXIgYXhpc1BvaW50ZXJUeXBlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgIHZhciBwaXhlbFZhbHVlID0gYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQodmFsdWUsIHRydWUpKTtcblxuICAgIGlmIChheGlzUG9pbnRlclR5cGUgJiYgYXhpc1BvaW50ZXJUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgIHZhciBlbFN0eWxlID0gdmlld0hlbHBlci5idWlsZEVsU3R5bGUoYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICB2YXIgcG9pbnRlck9wdGlvbiA9IHBvaW50ZXJTaGFwZUJ1aWxkZXJbYXhpc1BvaW50ZXJUeXBlXShheGlzLCBwaXhlbFZhbHVlLCBvdGhlckV4dGVudCwgZWxTdHlsZSk7XG4gICAgICBwb2ludGVyT3B0aW9uLnN0eWxlID0gZWxTdHlsZTtcbiAgICAgIGVsT3B0aW9uLmdyYXBoaWNLZXkgPSBwb2ludGVyT3B0aW9uLnR5cGU7XG4gICAgICBlbE9wdGlvbi5wb2ludGVyID0gcG9pbnRlck9wdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgbGF5b3V0SW5mbyA9IGNhcnRlc2lhbkF4aXNIZWxwZXIubGF5b3V0KGdyaWQubW9kZWwsIGF4aXNNb2RlbCk7XG4gICAgdmlld0hlbHBlci5idWlsZENhcnRlc2lhblNpbmdsZUxhYmVsRWxPcHRpb24odmFsdWUsIGVsT3B0aW9uLCBsYXlvdXRJbmZvLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0SGFuZGxlVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBsYXlvdXRJbmZvID0gY2FydGVzaWFuQXhpc0hlbHBlci5sYXlvdXQoYXhpc01vZGVsLmF4aXMuZ3JpZC5tb2RlbCwgYXhpc01vZGVsLCB7XG4gICAgICBsYWJlbEluc2lkZTogZmFsc2VcbiAgICB9KTtcbiAgICBsYXlvdXRJbmZvLmxhYmVsTWFyZ2luID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2hhbmRsZS5tYXJnaW4nKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHZpZXdIZWxwZXIuZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbihheGlzTW9kZWwuYXhpcywgdmFsdWUsIGxheW91dEluZm8pLFxuICAgICAgcm90YXRpb246IGxheW91dEluZm8ucm90YXRpb24gKyAobGF5b3V0SW5mby5sYWJlbERpcmVjdGlvbiA8IDAgPyBNYXRoLlBJIDogMClcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHVwZGF0ZUhhbmRsZVRyYW5zZm9ybTogZnVuY3Rpb24gKHRyYW5zZm9ybSwgZGVsdGEsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIGdyaWQgPSBheGlzLmdyaWQ7XG4gICAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEdsb2JhbEV4dGVudCh0cnVlKTtcbiAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgIHZhciBkaW1JbmRleCA9IGF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbiAgICB2YXIgY3VyclBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gKz0gZGVsdGFbZGltSW5kZXhdO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gPSBNYXRoLm1pbihheGlzRXh0ZW50WzFdLCBjdXJyUG9zaXRpb25bZGltSW5kZXhdKTtcbiAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5tYXgoYXhpc0V4dGVudFswXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG4gICAgdmFyIGN1cnNvck90aGVyVmFsdWUgPSAob3RoZXJFeHRlbnRbMV0gKyBvdGhlckV4dGVudFswXSkgLyAyO1xuICAgIHZhciBjdXJzb3JQb2ludCA9IFtjdXJzb3JPdGhlclZhbHVlLCBjdXJzb3JPdGhlclZhbHVlXTtcbiAgICBjdXJzb3JQb2ludFtkaW1JbmRleF0gPSBjdXJyUG9zaXRpb25bZGltSW5kZXhdOyAvLyBNYWtlIHRvb2x0aXAgZG8gbm90IG92ZXJsYXAgYXhpc1BvaW50ZXIgYW5kIGluIHRoZSBtaWRkbGUgb2YgdGhlIGdyaWQuXG5cbiAgICB2YXIgdG9vbHRpcE9wdGlvbnMgPSBbe1xuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICB9LCB7XG4gICAgICBhbGlnbjogJ2NlbnRlcidcbiAgICB9XTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IGN1cnJQb3NpdGlvbixcbiAgICAgIHJvdGF0aW9uOiB0cmFuc2Zvcm0ucm90YXRpb24sXG4gICAgICBjdXJzb3JQb2ludDogY3Vyc29yUG9pbnQsXG4gICAgICB0b29sdGlwT3B0aW9uOiB0b29sdGlwT3B0aW9uc1tkaW1JbmRleF1cbiAgICB9O1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0Q2FydGVzaWFuKGdyaWQsIGF4aXMpIHtcbiAgdmFyIG9wdCA9IHt9O1xuICBvcHRbYXhpcy5kaW0gKyAnQXhpc0luZGV4J10gPSBheGlzLmluZGV4O1xuICByZXR1cm4gZ3JpZC5nZXRDYXJ0ZXNpYW4ob3B0KTtcbn1cblxudmFyIHBvaW50ZXJTaGFwZUJ1aWxkZXIgPSB7XG4gIGxpbmU6IGZ1bmN0aW9uIChheGlzLCBwaXhlbFZhbHVlLCBvdGhlckV4dGVudCwgZWxTdHlsZSkge1xuICAgIHZhciB0YXJnZXRTaGFwZSA9IHZpZXdIZWxwZXIubWFrZUxpbmVTaGFwZShbcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnRbMF1dLCBbcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnRbMV1dLCBnZXRBeGlzRGltSW5kZXgoYXhpcykpO1xuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUoe1xuICAgICAgc2hhcGU6IHRhcmdldFNoYXBlLFxuICAgICAgc3R5bGU6IGVsU3R5bGVcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0xpbmUnLFxuICAgICAgc2hhcGU6IHRhcmdldFNoYXBlXG4gICAgfTtcbiAgfSxcbiAgc2hhZG93OiBmdW5jdGlvbiAoYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQsIGVsU3R5bGUpIHtcbiAgICB2YXIgYmFuZFdpZHRoID0gYXhpcy5nZXRCYW5kV2lkdGgoKTtcbiAgICB2YXIgc3BhbiA9IG90aGVyRXh0ZW50WzFdIC0gb3RoZXJFeHRlbnRbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdSZWN0JyxcbiAgICAgIHNoYXBlOiB2aWV3SGVscGVyLm1ha2VSZWN0U2hhcGUoW3BpeGVsVmFsdWUgLSBiYW5kV2lkdGggLyAyLCBvdGhlckV4dGVudFswXV0sIFtiYW5kV2lkdGgsIHNwYW5dLCBnZXRBeGlzRGltSW5kZXgoYXhpcykpXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0QXhpc0RpbUluZGV4KGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbn1cblxuQXhpc1ZpZXcucmVnaXN0ZXJBeGlzUG9pbnRlckNsYXNzKCdDYXJ0ZXNpYW5BeGlzUG9pbnRlcicsIENhcnRlc2lhbkF4aXNQb2ludGVyKTtcbnZhciBfZGVmYXVsdCA9IENhcnRlc2lhbkF4aXNQb2ludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQ2FydGVzaWFuQXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBtb2RlbEhlbHBlciA9IHJlcXVpcmUoXCIuL21vZGVsSGVscGVyXCIpO1xuXG52YXIgZmluZFBvaW50RnJvbVNlcmllcyA9IHJlcXVpcmUoXCIuL2ZpbmRQb2ludEZyb21TZXJpZXNcIik7XG5cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG52YXIgZ2V0ID0gbW9kZWxVdGlsLm1ha2VHZXR0ZXIoKTtcbi8qKlxuICogQmFzaWMgbG9naWM6IGNoZWNrIGFsbCBheGlzLCBpZiB0aGV5IGRvIG5vdCBkZW1hbmQgc2hvdy9oaWdobGlnaHQsXG4gKiB0aGVuIGhpZGUvZG93bnBsYXkgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29vcmRTeXNBeGVzSW5mb1xuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bG9hZC5jdXJyVHJpZ2dlcl0gJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ2xlYXZlJ1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3BheWxvYWQueF0geCBhbmQgeSwgd2hpY2ggYXJlIG1hbmRhdG9yeSwgc3BlY2lmeSBhIHBvaW50IHRvXG4gKiAgICAgICAgICAgICAgdHJpZ2dlciBheGlzUG9pbnRlciBhbmQgdG9vbHRpcC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtwYXlsb2FkLnldIHggYW5kIHksIHdoaWNoIGFyZSBtYW5kYXRvcnksIHNwZWNpZnkgYSBwb2ludCB0b1xuICogICAgICAgICAgICAgIHRyaWdnZXIgYXhpc1BvaW50ZXIgYW5kIHRvb2x0aXAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3BheWxvYWQuc2VyaWVzSW5kZXhdIGZpbmRlciwgb3B0aW9uYWwsIHJlc3RyaWN0IHRhcmdldCBheGVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXlsb2FkLmRhdGFJbmRleF0gZmluZGVyLCByZXN0cmljdCB0YXJnZXQgYXhlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGF5bG9hZC5heGVzSW5mb10gZmluZGVyLCByZXN0cmljdCB0YXJnZXQgYXhlcy5cbiAqICAgICAgICBbe1xuICogICAgICAgICAgYXhpc0RpbTogJ3gnfCd5J3wnYW5nbGUnfC4uLixcbiAqICAgICAgICAgIGF4aXNJbmRleDogLi4uLFxuICogICAgICAgICAgdmFsdWU6IC4uLlxuICogICAgICAgIH0sIC4uLl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXlsb2FkLmRpc3BhdGNoQWN0aW9uXVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXlsb2FkLnRvb2x0aXBPcHRpb25dXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheS48bnVtYmVyPnxGdW5jdGlvbn0gW3BheWxvYWQucG9zaXRpb25dIFRvb2x0aXAgcG9zaXRpb24sXG4gKiAgICAgICAgd2hpY2ggY2FuIGJlIHNwZWNpZmllZCBpbiBkaXNwYXRjaEFjdGlvblxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqIEByZXR1cm4ge09iamVjdH0gY29udGVudCBvZiBldmVudCBvYmogZm9yIGVjaGFydHMuY29ubmVjdC5cbiAqL1xuXG5mdW5jdGlvbiBfZGVmYXVsdChwYXlsb2FkLCBlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGN1cnJUcmlnZ2VyID0gcGF5bG9hZC5jdXJyVHJpZ2dlcjtcbiAgdmFyIHBvaW50ID0gW3BheWxvYWQueCwgcGF5bG9hZC55XTtcbiAgdmFyIGZpbmRlciA9IHBheWxvYWQ7XG4gIHZhciBkaXNwYXRjaEFjdGlvbiA9IHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gfHwgenJVdGlsLmJpbmQoYXBpLmRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICB2YXIgY29vcmRTeXNBeGVzSW5mbyA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpLmNvb3JkU3lzQXhlc0luZm87IC8vIFBlbmRpbmdcbiAgLy8gU2VlICM2MTIxLiBCdXQgd2UgYXJlIG5vdCBhYmxlIHRvIHJlcHJvZHVjZSBpdCB5ZXQuXG5cbiAgaWYgKCFjb29yZFN5c0F4ZXNJbmZvKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlsbGVnYWxQb2ludChwb2ludCkpIHtcbiAgICAvLyBVc2VkIGluIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGBjb25uZWN0aW9uYDogdXNlIHRoZSBzYW1wbGUgc2VyaWVzSW5kZXhcbiAgICAvLyBhbmQgZGF0YUluZGV4LiBBbmQgYWxzbyB1c2VkIGluIHRoZSB0b29sdGlwVmlldyB0cmlnZ2VyLlxuICAgIHBvaW50ID0gZmluZFBvaW50RnJvbVNlcmllcyh7XG4gICAgICBzZXJpZXNJbmRleDogZmluZGVyLnNlcmllc0luZGV4LFxuICAgICAgLy8gRG8gbm90IHVzZSBkYXRhSW5kZXhJbnNpZGUgZnJvbSBvdGhlciBlYyBpbnN0YW5jZS5cbiAgICAgIC8vIEZJWE1FOiBhdXRvIGRldGVjdCBpdD9cbiAgICAgIGRhdGFJbmRleDogZmluZGVyLmRhdGFJbmRleFxuICAgIH0sIGVjTW9kZWwpLnBvaW50O1xuICB9XG5cbiAgdmFyIGlzSWxsZWdhbFBvaW50ID0gaWxsZWdhbFBvaW50KHBvaW50KTsgLy8gQXhpcyBhbmQgdmFsdWUgY2FuIGJlIHNwZWNpZmllZCB3aGVuIGNhbGxpbmcgZGlzcGF0Y2hBY3Rpb24oe3R5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcid9KS5cbiAgLy8gTm90aWNlOiBJbiB0aGlzIGNhc2UsIGl0IGlzIGRpZmZpY3VsdCB0byBnZXQgdGhlIGBwb2ludGAgKHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBzaG93XG4gIC8vIHRvb2x0aXAsIHNvIGlmIHBvaW50IGlzIG5vdCBnaXZlbiwgd2UganVzdCB1c2UgdGhlIHBvaW50IGZvdW5kIGJ5IHNhbXBsZSBzZXJpZXNJbmRleFxuICAvLyBhbmQgZGF0YUluZGV4LlxuXG4gIHZhciBpbnB1dEF4ZXNJbmZvID0gZmluZGVyLmF4ZXNJbmZvO1xuICB2YXIgYXhlc0luZm8gPSBjb29yZFN5c0F4ZXNJbmZvLmF4ZXNJbmZvO1xuICB2YXIgc2hvdWxkSGlkZSA9IGN1cnJUcmlnZ2VyID09PSAnbGVhdmUnIHx8IGlsbGVnYWxQb2ludChwb2ludCk7XG4gIHZhciBvdXRwdXRGaW5kZXIgPSB7fTtcbiAgdmFyIHNob3dWYWx1ZU1hcCA9IHt9O1xuICB2YXIgZGF0YUJ5Q29vcmRTeXMgPSB7XG4gICAgbGlzdDogW10sXG4gICAgbWFwOiB7fVxuICB9O1xuICB2YXIgdXBkYXRlcnMgPSB7XG4gICAgc2hvd1BvaW50ZXI6IGN1cnJ5KHNob3dQb2ludGVyLCBzaG93VmFsdWVNYXApLFxuICAgIHNob3dUb29sdGlwOiBjdXJyeShzaG93VG9vbHRpcCwgZGF0YUJ5Q29vcmRTeXMpXG4gIH07IC8vIFByb2Nlc3MgZm9yIHRyaWdnZXJlZCBheGVzLlxuXG4gIGVhY2goY29vcmRTeXNBeGVzSW5mby5jb29yZFN5c01hcCwgZnVuY3Rpb24gKGNvb3JkU3lzLCBjb29yZFN5c0tleSkge1xuICAgIC8vIElmIGEgcG9pbnQgZ2l2ZW4sIGl0IG11c3QgYmUgY29udGFpbmVkIGJ5IHRoZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICB2YXIgY29vcmRTeXNDb250YWluc1BvaW50ID0gaXNJbGxlZ2FsUG9pbnQgfHwgY29vcmRTeXMuY29udGFpblBvaW50KHBvaW50KTtcbiAgICBlYWNoKGNvb3JkU3lzQXhlc0luZm8uY29vcmRTeXNBeGVzSW5mb1tjb29yZFN5c0tleV0sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgICB2YXIgYXhpcyA9IGF4aXNJbmZvLmF4aXM7XG4gICAgICB2YXIgaW5wdXRBeGlzSW5mbyA9IGZpbmRJbnB1dEF4aXNJbmZvKGlucHV0QXhlc0luZm8sIGF4aXNJbmZvKTsgLy8gSWYgbm8gaW5wdXRBeGVzSW5mbywgbm8gYXhpcyBpcyByZXN0cmljdGVkLlxuXG4gICAgICBpZiAoIXNob3VsZEhpZGUgJiYgY29vcmRTeXNDb250YWluc1BvaW50ICYmICghaW5wdXRBeGVzSW5mbyB8fCBpbnB1dEF4aXNJbmZvKSkge1xuICAgICAgICB2YXIgdmFsID0gaW5wdXRBeGlzSW5mbyAmJiBpbnB1dEF4aXNJbmZvLnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCAmJiAhaXNJbGxlZ2FsUG9pbnQpIHtcbiAgICAgICAgICB2YWwgPSBheGlzLnBvaW50VG9EYXRhKHBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbCAhPSBudWxsICYmIHByb2Nlc3NPbkF4aXMoYXhpc0luZm8sIHZhbCwgdXBkYXRlcnMsIGZhbHNlLCBvdXRwdXRGaW5kZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTsgLy8gUHJvY2VzcyBmb3IgbGlua2VkIGF4ZXMuXG5cbiAgdmFyIGxpbmtUcmlnZ2VycyA9IHt9O1xuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAodGFyQXhpc0luZm8sIHRhcktleSkge1xuICAgIHZhciBsaW5rR3JvdXAgPSB0YXJBeGlzSW5mby5saW5rR3JvdXA7IC8vIElmIGF4aXMgaGFzIGJlZW4gdHJpZ2dlcmVkIGluIHRoZSBwcmV2aW91cyBzdGFnZSwgaXQgc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgYnkgbGluay5cblxuICAgIGlmIChsaW5rR3JvdXAgJiYgIXNob3dWYWx1ZU1hcFt0YXJLZXldKSB7XG4gICAgICBlYWNoKGxpbmtHcm91cC5heGVzSW5mbywgZnVuY3Rpb24gKHNyY0F4aXNJbmZvLCBzcmNLZXkpIHtcbiAgICAgICAgdmFyIHNyY1ZhbEl0ZW0gPSBzaG93VmFsdWVNYXBbc3JjS2V5XTsgLy8gSWYgc3JjVmFsSXRlbSBleGlzdCwgc291cmNlIGF4aXMgaXMgdHJpZ2dlcmVkLCBzbyBsaW5rIHRvIHRhcmdldCBheGlzLlxuXG4gICAgICAgIGlmIChzcmNBeGlzSW5mbyAhPT0gdGFyQXhpc0luZm8gJiYgc3JjVmFsSXRlbSkge1xuICAgICAgICAgIHZhciB2YWwgPSBzcmNWYWxJdGVtLnZhbHVlO1xuICAgICAgICAgIGxpbmtHcm91cC5tYXBwZXIgJiYgKHZhbCA9IHRhckF4aXNJbmZvLmF4aXMuc2NhbGUucGFyc2UobGlua0dyb3VwLm1hcHBlcih2YWwsIG1ha2VNYXBwZXJQYXJhbShzcmNBeGlzSW5mbyksIG1ha2VNYXBwZXJQYXJhbSh0YXJBeGlzSW5mbykpKSk7XG4gICAgICAgICAgbGlua1RyaWdnZXJzW3RhckF4aXNJbmZvLmtleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGVhY2gobGlua1RyaWdnZXJzLCBmdW5jdGlvbiAodmFsLCB0YXJLZXkpIHtcbiAgICBwcm9jZXNzT25BeGlzKGF4ZXNJbmZvW3RhcktleV0sIHZhbCwgdXBkYXRlcnMsIHRydWUsIG91dHB1dEZpbmRlcik7XG4gIH0pO1xuICB1cGRhdGVNb2RlbEFjdHVhbGx5KHNob3dWYWx1ZU1hcCwgYXhlc0luZm8sIG91dHB1dEZpbmRlcik7XG4gIGRpc3BhdGNoVG9vbHRpcEFjdHVhbGx5KGRhdGFCeUNvb3JkU3lzLCBwb2ludCwgcGF5bG9hZCwgZGlzcGF0Y2hBY3Rpb24pO1xuICBkaXNwYXRjaEhpZ2hEb3duQWN0dWFsbHkoYXhlc0luZm8sIGRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICByZXR1cm4gb3V0cHV0RmluZGVyO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25BeGlzKGF4aXNJbmZvLCBuZXdWYWx1ZSwgdXBkYXRlcnMsIGRvbnRTbmFwLCBvdXRwdXRGaW5kZXIpIHtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuXG4gIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSB8fCAhYXhpcy5jb250YWluRGF0YShuZXdWYWx1ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWF4aXNJbmZvLmludm9sdmVTZXJpZXMpIHtcbiAgICB1cGRhdGVycy5zaG93UG9pbnRlcihheGlzSW5mbywgbmV3VmFsdWUpO1xuICAgIHJldHVybjtcbiAgfSAvLyBIZWF2eSBjYWxjdWxhdGlvbi4gU28gcHV0IGl0IGFmdGVyIGF4aXMuY29udGFpbkRhdGEgY2hlY2tpbmcuXG5cblxuICB2YXIgcGF5bG9hZEluZm8gPSBidWlsZFBheWxvYWRzQnlTZXJpZXMobmV3VmFsdWUsIGF4aXNJbmZvKTtcbiAgdmFyIHBheWxvYWRCYXRjaCA9IHBheWxvYWRJbmZvLnBheWxvYWRCYXRjaDtcbiAgdmFyIHNuYXBUb1ZhbHVlID0gcGF5bG9hZEluZm8uc25hcFRvVmFsdWU7IC8vIEZpbGwgY29udGVudCBvZiBldmVudCBvYmogZm9yIGVjaGFydHMuY29ubmVjdC5cbiAgLy8gQnkgZGVmdWFsdCB1c2UgdGhlIGZpcnN0IGludm9sdmVkIHNlcmllcyBkYXRhIGFzIGEgc2FtcGxlIHRvIGNvbm5lY3QuXG5cbiAgaWYgKHBheWxvYWRCYXRjaFswXSAmJiBvdXRwdXRGaW5kZXIuc2VyaWVzSW5kZXggPT0gbnVsbCkge1xuICAgIHpyVXRpbC5leHRlbmQob3V0cHV0RmluZGVyLCBwYXlsb2FkQmF0Y2hbMF0pO1xuICB9IC8vIElmIG5vIGxpbmtTb3VyY2UgaW5wdXQsIHRoaXMgcHJvY2VzcyBpcyBmb3IgY29sbGVjdGluZyBsaW5rXG4gIC8vIHRhcmdldCwgd2hlcmUgc25hcCBzaG91bGQgbm90IGJlIGFjY2VwdGVkLlxuXG5cbiAgaWYgKCFkb250U25hcCAmJiBheGlzSW5mby5zbmFwKSB7XG4gICAgaWYgKGF4aXMuY29udGFpbkRhdGEoc25hcFRvVmFsdWUpICYmIHNuYXBUb1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5ld1ZhbHVlID0gc25hcFRvVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlcnMuc2hvd1BvaW50ZXIoYXhpc0luZm8sIG5ld1ZhbHVlLCBwYXlsb2FkQmF0Y2gsIG91dHB1dEZpbmRlcik7IC8vIFRvb2x0aXAgc2hvdWxkIGFsd2F5cyBiZSBzbmFwVG9WYWx1ZSwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IFwiYXhpcyB2YWx1ZSB+IHNlcmllcyB2YWx1ZVwiIG1hcHBpbmcgZGlzcGxheWVkIGluIHRvb2x0aXAuXG5cbiAgdXBkYXRlcnMuc2hvd1Rvb2x0aXAoYXhpc0luZm8sIHBheWxvYWRJbmZvLCBzbmFwVG9WYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF5bG9hZHNCeVNlcmllcyh2YWx1ZSwgYXhpc0luZm8pIHtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICB2YXIgZGltID0gYXhpcy5kaW07XG4gIHZhciBzbmFwVG9WYWx1ZSA9IHZhbHVlO1xuICB2YXIgcGF5bG9hZEJhdGNoID0gW107XG4gIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgdmFyIG1pbkRpZmYgPSAtMTtcbiAgZWFjaChheGlzSW5mby5zZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXMsIGlkeCkge1xuICAgIHZhciBkYXRhRGltID0gc2VyaWVzLmNvb3JkRGltVG9EYXRhRGltKGRpbSk7XG4gICAgdmFyIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICB2YXIgZGF0YUluZGljZXM7XG5cbiAgICBpZiAoc2VyaWVzLmdldEF4aXNUb29sdGlwRGF0YSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHNlcmllcy5nZXRBeGlzVG9vbHRpcERhdGEoZGF0YURpbSwgdmFsdWUsIGF4aXMpO1xuICAgICAgZGF0YUluZGljZXMgPSByZXN1bHQuZGF0YUluZGljZXM7XG4gICAgICBzZXJpZXNOZXN0ZXN0VmFsdWUgPSByZXN1bHQubmVzdGVzdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhSW5kaWNlcyA9IHNlcmllcy5nZXREYXRhKCkuaW5kaWNlc09mTmVhcmVzdChkYXRhRGltWzBdLCB2YWx1ZSwgLy8gQWRkIGEgdGhyZXNob2xkIHRvIGF2b2lkIGZpbmQgdGhlIHdyb25nIGRhdGFJbmRleFxuICAgICAgLy8gd2hlbiBkYXRhIGxlbmd0aCBpcyBub3Qgc2FtZS5cbiAgICAgIGZhbHNlLCBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyAwLjUgOiBudWxsKTtcblxuICAgICAgaWYgKCFkYXRhSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXJpZXNOZXN0ZXN0VmFsdWUgPSBzZXJpZXMuZ2V0RGF0YSgpLmdldChkYXRhRGltWzBdLCBkYXRhSW5kaWNlc1swXSk7XG4gICAgfVxuXG4gICAgaWYgKHNlcmllc05lc3Rlc3RWYWx1ZSA9PSBudWxsIHx8ICFpc0Zpbml0ZShzZXJpZXNOZXN0ZXN0VmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRpZmYpOyAvLyBDb25zaWRlciBjYXRlZ29yeSBjYXNlXG5cbiAgICBpZiAoZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QgfHwgZGlmZiA+PSAwICYmIG1pbkRpZmYgPCAwKSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBtaW5EaWZmID0gZGlmZjtcbiAgICAgICAgc25hcFRvVmFsdWUgPSBzZXJpZXNOZXN0ZXN0VmFsdWU7XG4gICAgICAgIHBheWxvYWRCYXRjaC5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICBlYWNoKGRhdGFJbmRpY2VzLCBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHBheWxvYWRCYXRjaC5wdXNoKHtcbiAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzLnNlcmllc0luZGV4LFxuICAgICAgICAgIGRhdGFJbmRleEluc2lkZTogZGF0YUluZGV4LFxuICAgICAgICAgIGRhdGFJbmRleDogc2VyaWVzLmdldERhdGEoKS5nZXRSYXdJbmRleChkYXRhSW5kZXgpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwYXlsb2FkQmF0Y2g6IHBheWxvYWRCYXRjaCxcbiAgICBzbmFwVG9WYWx1ZTogc25hcFRvVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hvd1BvaW50ZXIoc2hvd1ZhbHVlTWFwLCBheGlzSW5mbywgdmFsdWUsIHBheWxvYWRCYXRjaCkge1xuICBzaG93VmFsdWVNYXBbYXhpc0luZm8ua2V5XSA9IHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcGF5bG9hZEJhdGNoOiBwYXlsb2FkQmF0Y2hcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZGF0YUJ5Q29vcmRTeXMsIGF4aXNJbmZvLCBwYXlsb2FkSW5mbywgdmFsdWUpIHtcbiAgdmFyIHBheWxvYWRCYXRjaCA9IHBheWxvYWRJbmZvLnBheWxvYWRCYXRjaDtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsOyAvLyBJZiBubyBkYXRhLCBkbyBub3QgY3JlYXRlIGFueXRoaW5nIGluIGRhdGFCeUNvb3JkU3lzLFxuICAvLyB3aG9zZSBsZW5ndGggd2lsbCBiZSB1c2VkIHRvIGp1ZGdlIHdoZXRoZXIgZGlzcGF0Y2ggYWN0aW9uLlxuXG4gIGlmICghYXhpc0luZm8udHJpZ2dlclRvb2x0aXAgfHwgIXBheWxvYWRCYXRjaC5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29vcmRTeXNNb2RlbCA9IGF4aXNJbmZvLmNvb3JkU3lzLm1vZGVsO1xuICB2YXIgY29vcmRTeXNLZXkgPSBtb2RlbEhlbHBlci5tYWtlS2V5KGNvb3JkU3lzTW9kZWwpO1xuICB2YXIgY29vcmRTeXNJdGVtID0gZGF0YUJ5Q29vcmRTeXMubWFwW2Nvb3JkU3lzS2V5XTtcblxuICBpZiAoIWNvb3JkU3lzSXRlbSkge1xuICAgIGNvb3JkU3lzSXRlbSA9IGRhdGFCeUNvb3JkU3lzLm1hcFtjb29yZFN5c0tleV0gPSB7XG4gICAgICBjb29yZFN5c0lkOiBjb29yZFN5c01vZGVsLmlkLFxuICAgICAgY29vcmRTeXNJbmRleDogY29vcmRTeXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIGNvb3JkU3lzVHlwZTogY29vcmRTeXNNb2RlbC50eXBlLFxuICAgICAgY29vcmRTeXNNYWluVHlwZTogY29vcmRTeXNNb2RlbC5tYWluVHlwZSxcbiAgICAgIGRhdGFCeUF4aXM6IFtdXG4gICAgfTtcbiAgICBkYXRhQnlDb29yZFN5cy5saXN0LnB1c2goY29vcmRTeXNJdGVtKTtcbiAgfVxuXG4gIGNvb3JkU3lzSXRlbS5kYXRhQnlBeGlzLnB1c2goe1xuICAgIGF4aXNEaW06IGF4aXMuZGltLFxuICAgIGF4aXNJbmRleDogYXhpc01vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgIGF4aXNUeXBlOiBheGlzTW9kZWwudHlwZSxcbiAgICBheGlzSWQ6IGF4aXNNb2RlbC5pZCxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgLy8gQ2F1c3Rpb246IHZpZXdIZWxwZXIuZ2V0VmFsdWVMYWJlbCBpcyBhY3R1YWxseSBvbiBcInZpZXcgc3RhZ2VcIiwgd2hpY2hcbiAgICAvLyBkZXBlbmRzIHRoYXQgYWxsIG1vZGVscyBoYXZlIGJlZW4gdXBkYXRlZC4gU28gaXQgc2hvdWxkIG5vdCBiZSBwZXJmb3JtZWRcbiAgICAvLyBoZXJlLiBDb25zaWRlcmluZyBheGlzUG9pbnRlck1vZGVsIHVzZWQgaGVyZSBpcyB2b2xhdGlsZSwgd2hpY2ggaXMgaGFyZFxuICAgIC8vIHRvIGJlIHJldHJpZXZlIGluIFRvb2x0aXBWaWV3LCB3ZSBwcmVwYXJlIHBhcmFtZXRlcnMgaGVyZS5cbiAgICB2YWx1ZUxhYmVsT3B0OiB7XG4gICAgICBwcmVjaXNpb246IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5wcmVjaXNpb24nKSxcbiAgICAgIGZvcm1hdHRlcjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLmZvcm1hdHRlcicpXG4gICAgfSxcbiAgICBzZXJpZXNEYXRhSW5kaWNlczogcGF5bG9hZEJhdGNoLnNsaWNlKClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQWN0dWFsbHkoc2hvd1ZhbHVlTWFwLCBheGVzSW5mbywgb3V0cHV0RmluZGVyKSB7XG4gIHZhciBvdXRwdXRBeGVzSW5mbyA9IG91dHB1dEZpbmRlci5heGVzSW5mbyA9IFtdOyAvLyBCYXNpYyBsb2dpYzogSWYgbm8gJ3Nob3cnIHJlcXVpcmVkLCAnaGlkZScgdGhpcyBheGlzUG9pbnRlci5cblxuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAoYXhpc0luZm8sIGtleSkge1xuICAgIHZhciBvcHRpb24gPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgICB2YXIgdmFsSXRlbSA9IHNob3dWYWx1ZU1hcFtrZXldO1xuXG4gICAgaWYgKHZhbEl0ZW0pIHtcbiAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnc2hvdycpO1xuICAgICAgb3B0aW9uLnZhbHVlID0gdmFsSXRlbS52YWx1ZTsgLy8gRm9yIGxhYmVsIGZvcm1hdHRlciBwYXJhbSBhbmQgaGlnaGxpZ2h0LlxuXG4gICAgICBvcHRpb24uc2VyaWVzRGF0YUluZGljZXMgPSAodmFsSXRlbS5wYXlsb2FkQmF0Y2ggfHwgW10pLnNsaWNlKCk7XG4gICAgfSAvLyBXaGVuIGFsd2F5cyBzaG93IChlLmcuLCBoYW5kbGUgdXNlZCksIHJlbWFpblxuICAgIC8vIG9yaWdpbmFsIHZhbHVlIGFuZCBzdGF0dXMuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIGhpZGUsIHZhbHVlIHN0aWxsIG5lZWQgdG8gYmUgc2V0LCBjb25zaWRlclxuICAgICAgICAvLyBjbGljayBsZWdlbmQgdG8gdG9nZ2xlIGF4aXMgYmxhbmsuXG4gICAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnaGlkZScpO1xuICAgICAgfSAvLyBJZiBzdGF0dXMgaXMgJ2hpZGUnLCBzaG91bGQgYmUgbm8gaW5mbyBpbiBwYXlsb2FkLlxuXG5cbiAgICBvcHRpb24uc3RhdHVzID09PSAnc2hvdycgJiYgb3V0cHV0QXhlc0luZm8ucHVzaCh7XG4gICAgICBheGlzRGltOiBheGlzSW5mby5heGlzLmRpbSxcbiAgICAgIGF4aXNJbmRleDogYXhpc0luZm8uYXhpcy5tb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIHZhbHVlOiBvcHRpb24udmFsdWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoVG9vbHRpcEFjdHVhbGx5KGRhdGFCeUNvb3JkU3lzLCBwb2ludCwgcGF5bG9hZCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgLy8gQmFzaWMgbG9naWM6IElmIG5vIHNob3dUaXAgcmVxdWlyZWQsIGhpZGVUaXAgd2lsbCBiZSBkaXNwYXRjaGVkLlxuICBpZiAoaWxsZWdhbFBvaW50KHBvaW50KSB8fCAhZGF0YUJ5Q29vcmRTeXMubGlzdC5sZW5ndGgpIHtcbiAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnaGlkZVRpcCdcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gSW4gbW9zdCBjYXNlIG9ubHkgb25lIGF4aXMgKG9yIGV2ZW50IG9uZSBzZXJpZXMgaXMgdXNlZCkuIEl0IGlzXG4gIC8vIGNvbnZpbmllbnQgdG8gZmV0Y2ggcGF5bG9hZC5zZXJpZXNJbmRleCBhbmQgcGF5bG9hZC5kYXRhSW5kZXhcbiAgLy8gZGlydGVjdGx5LiBTbyBwdXQgdGhlIGZpcnN0IHNlcmllc0luZGV4IGFuZCBkYXRhSW5kZXggb2YgdGhlIGZpcnN0XG4gIC8vIGF4aXMgb24gdGhlIHBheWxvYWQuXG5cblxuICB2YXIgc2FtcGxlSXRlbSA9ICgoZGF0YUJ5Q29vcmRTeXMubGlzdFswXS5kYXRhQnlBeGlzWzBdIHx8IHt9KS5zZXJpZXNEYXRhSW5kaWNlcyB8fCBbXSlbMF0gfHwge307XG4gIGRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgZXNjYXBlQ29ubmVjdDogdHJ1ZSxcbiAgICB4OiBwb2ludFswXSxcbiAgICB5OiBwb2ludFsxXSxcbiAgICB0b29sdGlwT3B0aW9uOiBwYXlsb2FkLnRvb2x0aXBPcHRpb24sXG4gICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgZGF0YUluZGV4SW5zaWRlOiBzYW1wbGVJdGVtLmRhdGFJbmRleEluc2lkZSxcbiAgICBkYXRhSW5kZXg6IHNhbXBsZUl0ZW0uZGF0YUluZGV4LFxuICAgIHNlcmllc0luZGV4OiBzYW1wbGVJdGVtLnNlcmllc0luZGV4LFxuICAgIGRhdGFCeUNvb3JkU3lzOiBkYXRhQnlDb29yZFN5cy5saXN0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEhpZ2hEb3duQWN0dWFsbHkoYXhlc0luZm8sIGRpc3BhdGNoQWN0aW9uLCBhcGkpIHtcbiAgLy8gRklYTUVcbiAgLy8gaGlnaGxpZ2h0IHN0YXR1cyBtb2RpZmljYXRpb24gc2hvdWxlIGJlIGEgc3RhZ2Ugb2YgbWFpbiBwcm9jZXNzP1xuICAvLyAoQ29uc2lkZXIgY29uZmlsY3QgKGUuZy4sIGxlZ2VuZCBhbmQgYXhpc1BvaW50ZXIpIGFuZCBzZXRPcHRpb24pXG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICB2YXIgaGlnaERvd25LZXkgPSAnYXhpc1BvaW50ZXJMYXN0SGlnaGxpZ2h0cyc7XG4gIHZhciBsYXN0SGlnaGxpZ2h0cyA9IGdldCh6cilbaGlnaERvd25LZXldIHx8IHt9O1xuICB2YXIgbmV3SGlnaGxpZ2h0cyA9IGdldCh6cilbaGlnaERvd25LZXldID0ge307IC8vIFVwZGF0ZSBoaWdobGlnaHQvZG93bnBsYXkgc3RhdHVzIGFjY29yZGluZyB0byBheGlzUG9pbnRlciBtb2RlbC5cbiAgLy8gQnVpbGQgaGFzaCBtYXAgYW5kIHJlbW92ZSBkdXBsaWNhdGUgaW5jaWRlbnRhbGx5LlxuXG4gIGVhY2goYXhlc0luZm8sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgdmFyIG9wdGlvbiA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWwub3B0aW9uO1xuICAgIG9wdGlvbi5zdGF0dXMgPT09ICdzaG93JyAmJiBlYWNoKG9wdGlvbi5zZXJpZXNEYXRhSW5kaWNlcywgZnVuY3Rpb24gKGJhdGNoSXRlbSkge1xuICAgICAgdmFyIGtleSA9IGJhdGNoSXRlbS5zZXJpZXNJbmRleCArICcgfCAnICsgYmF0Y2hJdGVtLmRhdGFJbmRleDtcbiAgICAgIG5ld0hpZ2hsaWdodHNba2V5XSA9IGJhdGNoSXRlbTtcbiAgICB9KTtcbiAgfSk7IC8vIERpZmYuXG5cbiAgdmFyIHRvSGlnaGxpZ2h0ID0gW107XG4gIHZhciB0b0Rvd25wbGF5ID0gW107XG4gIHpyVXRpbC5lYWNoKGxhc3RIaWdobGlnaHRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBrZXkpIHtcbiAgICAhbmV3SGlnaGxpZ2h0c1trZXldICYmIHRvRG93bnBsYXkucHVzaChiYXRjaEl0ZW0pO1xuICB9KTtcbiAgenJVdGlsLmVhY2gobmV3SGlnaGxpZ2h0cywgZnVuY3Rpb24gKGJhdGNoSXRlbSwga2V5KSB7XG4gICAgIWxhc3RIaWdobGlnaHRzW2tleV0gJiYgdG9IaWdobGlnaHQucHVzaChiYXRjaEl0ZW0pO1xuICB9KTtcbiAgdG9Eb3ducGxheS5sZW5ndGggJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnZG93bnBsYXknLFxuICAgIGVzY2FwZUNvbm5lY3Q6IHRydWUsXG4gICAgYmF0Y2g6IHRvRG93bnBsYXlcbiAgfSk7XG4gIHRvSGlnaGxpZ2h0Lmxlbmd0aCAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdoaWdobGlnaHQnLFxuICAgIGVzY2FwZUNvbm5lY3Q6IHRydWUsXG4gICAgYmF0Y2g6IHRvSGlnaGxpZ2h0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5wdXRBeGlzSW5mbyhpbnB1dEF4ZXNJbmZvLCBheGlzSW5mbykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IChpbnB1dEF4ZXNJbmZvIHx8IFtdKS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnB1dEF4aXNJbmZvID0gaW5wdXRBeGVzSW5mb1tpXTtcblxuICAgIGlmIChheGlzSW5mby5heGlzLmRpbSA9PT0gaW5wdXRBeGlzSW5mby5heGlzRGltICYmIGF4aXNJbmZvLmF4aXMubW9kZWwuY29tcG9uZW50SW5kZXggPT09IGlucHV0QXhpc0luZm8uYXhpc0luZGV4KSB7XG4gICAgICByZXR1cm4gaW5wdXRBeGlzSW5mbztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZU1hcHBlclBhcmFtKGF4aXNJbmZvKSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzSW5mby5heGlzLm1vZGVsO1xuICB2YXIgaXRlbSA9IHt9O1xuICB2YXIgZGltID0gaXRlbS5heGlzRGltID0gYXhpc0luZm8uYXhpcy5kaW07XG4gIGl0ZW0uYXhpc0luZGV4ID0gaXRlbVtkaW0gKyAnQXhpc0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gIGl0ZW0uYXhpc05hbWUgPSBpdGVtW2RpbSArICdBeGlzTmFtZSddID0gYXhpc01vZGVsLm5hbWU7XG4gIGl0ZW0uYXhpc0lkID0gaXRlbVtkaW0gKyAnQXhpc0lkJ10gPSBheGlzTW9kZWwuaWQ7XG4gIHJldHVybiBpdGVtO1xufVxuXG5mdW5jdGlvbiBpbGxlZ2FsUG9pbnQocG9pbnQpIHtcbiAgcmV0dXJuICFwb2ludCB8fCBwb2ludFswXSA9PSBudWxsIHx8IGlzTmFOKHBvaW50WzBdKSB8fCBwb2ludFsxXSA9PSBudWxsIHx8IGlzTmFOKHBvaW50WzFdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvYXhpc1RyaWdnZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9heGlzVHJpZ2dlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbmRlciBjb250YWlucyB7c2VyaWVzSW5kZXgsIGRhdGFJbmRleCwgZGF0YUluZGV4SW5zaWRlfVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEByZXR1cm4ge09iamVjdH0ge3BvaW50OiBbeCwgeV0sIGVsOiAuLi59IHBvaW50IFdpbGwgbm90IGJlIG51bGwuXG4gKi9cbmZ1bmN0aW9uIF9kZWZhdWx0KGZpbmRlciwgZWNNb2RlbCkge1xuICB2YXIgcG9pbnQgPSBbXTtcbiAgdmFyIHNlcmllc0luZGV4ID0gZmluZGVyLnNlcmllc0luZGV4O1xuICB2YXIgc2VyaWVzTW9kZWw7XG5cbiAgaWYgKHNlcmllc0luZGV4ID09IG51bGwgfHwgIShzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCkpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBbXVxuICAgIH07XG4gIH1cblxuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBmaW5kZXIpO1xuXG4gIGlmIChkYXRhSW5kZXggPT0gbnVsbCB8fCB6clV0aWwuaXNBcnJheShkYXRhSW5kZXgpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBbXVxuICAgIH07XG4gIH1cblxuICB2YXIgZWwgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcbiAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICBpZiAoc2VyaWVzTW9kZWwuZ2V0VG9vbHRpcFBvc2l0aW9uKSB7XG4gICAgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRUb29sdGlwUG9zaXRpb24oZGF0YUluZGV4KSB8fCBbXTtcbiAgfSBlbHNlIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy5kYXRhVG9Qb2ludCkge1xuICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoZGF0YS5nZXRWYWx1ZXMoenJVdGlsLm1hcChjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICByZXR1cm4gc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0oZGltKVswXTtcbiAgICB9KSwgZGF0YUluZGV4LCB0cnVlKSkgfHwgW107XG4gIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAvLyBVc2UgZ3JhcGhpYyBib3VuZGluZyByZWN0XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICAgIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgICBwb2ludCA9IFtyZWN0LnggKyByZWN0LndpZHRoIC8gMiwgcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IHBvaW50LFxuICAgIGVsOiBlbFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9maW5kUG9pbnRGcm9tU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZmluZFBvaW50RnJvbVNlcmllcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZW52XCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBnZXQgPSBtb2RlbFV0aWwubWFrZUdldHRlcigpO1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICogICAgICBwYXJhbToge3N0cmluZ30gY3VyclRyaWdnZXJcbiAqICAgICAgcGFyYW06IHtBcnJheS48bnVtYmVyPn0gcG9pbnRcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlcihrZXksIGFwaSwgaGFuZGxlcikge1xuICBpZiAoZW52Lm5vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgZ2V0KHpyKS5yZWNvcmRzIHx8IChnZXQoenIpLnJlY29yZHMgPSB7fSk7XG4gIGluaXRHbG9iYWxMaXN0ZW5lcnMoenIsIGFwaSk7XG4gIHZhciByZWNvcmQgPSBnZXQoenIpLnJlY29yZHNba2V5XSB8fCAoZ2V0KHpyKS5yZWNvcmRzW2tleV0gPSB7fSk7XG4gIHJlY29yZC5oYW5kbGVyID0gaGFuZGxlcjtcbn1cblxuZnVuY3Rpb24gaW5pdEdsb2JhbExpc3RlbmVycyh6ciwgYXBpKSB7XG4gIGlmIChnZXQoenIpLmluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0KHpyKS5pbml0aWFsaXplZCA9IHRydWU7XG4gIHVzZUhhbmRsZXIoJ2NsaWNrJywgenJVdGlsLmN1cnJ5KGRvRW50ZXIsICdjbGljaycpKTtcbiAgdXNlSGFuZGxlcignbW91c2Vtb3ZlJywgenJVdGlsLmN1cnJ5KGRvRW50ZXIsICdtb3VzZW1vdmUnKSk7IC8vIHVzZUhhbmRsZXIoJ21vdXNlb3V0Jywgb25MZWF2ZSk7XG5cbiAgdXNlSGFuZGxlcignZ2xvYmFsb3V0Jywgb25MZWF2ZSk7XG5cbiAgZnVuY3Rpb24gdXNlSGFuZGxlcihldmVudFR5cGUsIGNiKSB7XG4gICAgenIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGRpcyA9IG1ha2VEaXNwYXRjaEFjdGlvbihhcGkpO1xuICAgICAgZWFjaChnZXQoenIpLnJlY29yZHMsIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgcmVjb3JkICYmIGNiKHJlY29yZCwgZSwgZGlzLmRpc3BhdGNoQWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgZGlzcGF0Y2hUb29sdGlwRmluYWxseShkaXMucGVuZGluZ3MsIGFwaSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hUb29sdGlwRmluYWxseShwZW5kaW5ncywgYXBpKSB7XG4gIHZhciBzaG93TGVuID0gcGVuZGluZ3Muc2hvd1RpcC5sZW5ndGg7XG4gIHZhciBoaWRlTGVuID0gcGVuZGluZ3MuaGlkZVRpcC5sZW5ndGg7XG4gIHZhciBhY3R1YWxseVBheWxvYWQ7XG5cbiAgaWYgKHNob3dMZW4pIHtcbiAgICBhY3R1YWxseVBheWxvYWQgPSBwZW5kaW5ncy5zaG93VGlwW3Nob3dMZW4gLSAxXTtcbiAgfSBlbHNlIGlmIChoaWRlTGVuKSB7XG4gICAgYWN0dWFsbHlQYXlsb2FkID0gcGVuZGluZ3MuaGlkZVRpcFtoaWRlTGVuIC0gMV07XG4gIH1cblxuICBpZiAoYWN0dWFsbHlQYXlsb2FkKSB7XG4gICAgYWN0dWFsbHlQYXlsb2FkLmRpc3BhdGNoQWN0aW9uID0gbnVsbDtcbiAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oYWN0dWFsbHlQYXlsb2FkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkxlYXZlKHJlY29yZCwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgcmVjb3JkLmhhbmRsZXIoJ2xlYXZlJywgbnVsbCwgZGlzcGF0Y2hBY3Rpb24pO1xufVxuXG5mdW5jdGlvbiBkb0VudGVyKGN1cnJUcmlnZ2VyLCByZWNvcmQsIGUsIGRpc3BhdGNoQWN0aW9uKSB7XG4gIHJlY29yZC5oYW5kbGVyKGN1cnJUcmlnZ2VyLCBlLCBkaXNwYXRjaEFjdGlvbik7XG59XG5cbmZ1bmN0aW9uIG1ha2VEaXNwYXRjaEFjdGlvbihhcGkpIHtcbiAgdmFyIHBlbmRpbmdzID0ge1xuICAgIHNob3dUaXA6IFtdLFxuICAgIGhpZGVUaXA6IFtdXG4gIH07IC8vIEZJWE1FXG4gIC8vIGJldHRlciBhcHByb2FjaD9cbiAgLy8gJ3Nob3dUaXAnIGFuZCAnaGlkZVRpcCcgY2FuIGJlIHRyaWdnZXJlZCBieSBheGlzUG9pbnRlciBhbmQgdG9vbHRpcCxcbiAgLy8gd2hpY2ggbWF5IGJlIGNvbmZsaWN0LCAoYXhpc1BvaW50ZXIgY2FsbCBzaG93VGlwIGJ1dCB0b29sdGlwIGNhbGwgaGlkZVRpcCk7XG4gIC8vIFNvIHdlIGhhdmUgdG8gYWRkIFwiZmluYWwgc3RhZ2VcIiB0byBtZXJnZSB0aG9zZSBkaXNwYXRjaGVkIGFjdGlvbnMuXG5cbiAgdmFyIGRpc3BhdGNoQWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICB2YXIgcGVuZGluZ0xpc3QgPSBwZW5kaW5nc1twYXlsb2FkLnR5cGVdO1xuXG4gICAgaWYgKHBlbmRpbmdMaXN0KSB7XG4gICAgICBwZW5kaW5nTGlzdC5wdXNoKHBheWxvYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXlsb2FkLmRpc3BhdGNoQWN0aW9uID0gZGlzcGF0Y2hBY3Rpb247XG4gICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZGlzcGF0Y2hBY3Rpb246IGRpc3BhdGNoQWN0aW9uLFxuICAgIHBlbmRpbmdzOiBwZW5kaW5nc1xuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gKi9cblxuXG5mdW5jdGlvbiB1bnJlZ2lzdGVyKGtleSwgYXBpKSB7XG4gIGlmIChlbnYubm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICB2YXIgcmVjb3JkID0gKGdldCh6cikucmVjb3JkcyB8fCB7fSlba2V5XTtcblxuICBpZiAocmVjb3JkKSB7XG4gICAgZ2V0KHpyKS5yZWNvcmRzW2tleV0gPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMucmVnaXN0ZXIgPSByZWdpc3RlcjtcbmV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL01vZGVsXCIpO1xuXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5OyAvLyBCdWlsZCBheGlzUG9pbnRlck1vZGVsLCBtZXJnaW4gdG9vbHRpcC5heGlzUG9pbnRlciBtb2RlbCBmb3IgZWFjaCBheGlzLlxuLy8gYWxsQXhlc0luZm8gc2hvdWxkIGJlIHVwZGF0ZWQgd2hlbiBzZXRPcHRpb24gcGVyZm9ybWVkLlxuXG5mdW5jdGlvbiBjb2xsZWN0KGVjTW9kZWwsIGFwaSkge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIGtleTogbWFrZUtleShheGlzLm1vZGVsKVxuICAgICAqIHZhbHVlOiB7XG4gICAgICogICAgICBheGlzLFxuICAgICAqICAgICAgY29vcmRTeXMsXG4gICAgICogICAgICBheGlzUG9pbnRlck1vZGVsLFxuICAgICAqICAgICAgdHJpZ2dlclRvb2x0aXAsXG4gICAgICogICAgICBpbnZvbHZlU2VyaWVzLFxuICAgICAqICAgICAgc25hcCxcbiAgICAgKiAgICAgIHNlcmllc01vZGVscyxcbiAgICAgKiAgICAgIHNlcmllc0RhdGFDb3VudFxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGVzSW5mbzoge30sXG4gICAgc2VyaWVzSW52b2x2ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICoga2V5OiBtYWtlS2V5KGNvb3JkU3lzLm1vZGVsKVxuICAgICAqIHZhbHVlOiBPYmplY3Q6IGtleSBtYWtlS2V5KGF4aXMubW9kZWwpLCB2YWx1ZTogYXhpc0luZm9cbiAgICAgKi9cbiAgICBjb29yZFN5c0F4ZXNJbmZvOiB7fSxcbiAgICBjb29yZFN5c01hcDoge31cbiAgfTtcbiAgY29sbGVjdEF4ZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCwgYXBpKTsgLy8gQ2hlY2sgc2VyaWVzSW52b2x2ZWQgZm9yIHBlcmZvcm1hbmNlLCBpbiBjYXNlIHRvbyBtYW55IHNlcmllcyBpbiBzb21lIGNoYXJ0LlxuXG4gIHJlc3VsdC5zZXJpZXNJbnZvbHZlZCAmJiBjb2xsZWN0U2VyaWVzSW5mbyhyZXN1bHQsIGVjTW9kZWwpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0QXhlc0luZm8ocmVzdWx0LCBlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGdsb2JhbFRvb2x0aXBNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sdGlwJyk7XG4gIHZhciBnbG9iYWxBeGlzUG9pbnRlck1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ2F4aXNQb2ludGVyJyk7IC8vIGxpbmtzIGNhbiBvbmx5IGJlIHNldCBvbiBnbG9iYWwuXG5cbiAgdmFyIGxpbmtzT3B0aW9uID0gZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xpbmsnLCB0cnVlKSB8fCBbXTtcbiAgdmFyIGxpbmtHcm91cHMgPSBbXTsgLy8gQ29sbGVjdCBheGVzIGluZm8uXG5cbiAgZWFjaChhcGkuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKSwgZnVuY3Rpb24gKGNvb3JkU3lzKSB7XG4gICAgLy8gU29tZSBjb29yZGluYXRlIHN5c3RlbSBkbyBub3Qgc3VwcG9ydCBheGVzLCBsaWtlIGdlby5cbiAgICBpZiAoIWNvb3JkU3lzLmF4aXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb29yZFN5c0tleSA9IG1ha2VLZXkoY29vcmRTeXMubW9kZWwpO1xuICAgIHZhciBheGVzSW5mb0luQ29vcmRTeXMgPSByZXN1bHQuY29vcmRTeXNBeGVzSW5mb1tjb29yZFN5c0tleV0gPSB7fTtcbiAgICByZXN1bHQuY29vcmRTeXNNYXBbY29vcmRTeXNLZXldID0gY29vcmRTeXM7IC8vIFNldCB0b29sdGlwIChsaWtlICdjcm9zcycpIGlzIGEgY29udmllbmVudCB3YXkgdG8gc2hvdyBheGlzUG9pbnRlclxuICAgIC8vIGZvciB1c2VyLiBTbyB3ZSBlbmFibGUgc2V0aW5nIHRvb2x0aXAgb24gY29vcmRTeXMgbW9kZWwuXG5cbiAgICB2YXIgY29vcmRTeXNNb2RlbCA9IGNvb3JkU3lzLm1vZGVsO1xuICAgIHZhciBiYXNlVG9vbHRpcE1vZGVsID0gY29vcmRTeXNNb2RlbC5nZXRNb2RlbCgndG9vbHRpcCcsIGdsb2JhbFRvb2x0aXBNb2RlbCk7XG4gICAgZWFjaChjb29yZFN5cy5nZXRBeGVzKCksIGN1cnJ5KHNhdmVUb29sdGlwQXhpc0luZm8sIGZhbHNlLCBudWxsKSk7IC8vIElmIGF4aXMgdG9vbHRpcCB1c2VkLCBjaG9vc2UgdG9vbHRpcCBheGlzIGZvciBlYWNoIGNvb3JkU3lzLlxuICAgIC8vIE5vdGljZSB0aGlzIGNhc2U6IGNvb3JkU3lzIGlzIGBncmlkYCBidXQgbm90IGBjYXJ0ZXNpYW4yRGAgaGVyZS5cblxuICAgIGlmIChjb29yZFN5cy5nZXRUb29sdGlwQXhlcyAmJiBnbG9iYWxUb29sdGlwTW9kZWwgLy8gSWYgdG9vbHRpcC5zaG93Q29udGVudCBpcyBzZXQgYXMgZmFsc2UsIHRvb2x0aXAgd2lsbCBub3RcbiAgICAvLyBzaG93IGJ1dCBheGlzUG9pbnRlciB3aWxsIHNob3cgYXMgbm9ybWFsLlxuICAgICYmIGJhc2VUb29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBsb2dpYy4gQnV0IHNlcmllcy50b29sdGlwLnRyaWdnZXI6ICdheGlzJ1xuICAgICAgLy8gb3Igc2VyaWVzLmRhdGFbbl0udG9vbHRpcC50cmlnZ2VyOiAnYXhpcycgYXJlIG5vdCBzdXBwb3J0IGFueSBtb3JlLlxuICAgICAgdmFyIHRyaWdnZXJBeGlzID0gYmFzZVRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKSA9PT0gJ2F4aXMnO1xuICAgICAgdmFyIGNyb3NzID0gYmFzZVRvb2x0aXBNb2RlbC5nZXQoJ2F4aXNQb2ludGVyLnR5cGUnKSA9PT0gJ2Nyb3NzJztcbiAgICAgIHZhciB0b29sdGlwQXhlcyA9IGNvb3JkU3lzLmdldFRvb2x0aXBBeGVzKGJhc2VUb29sdGlwTW9kZWwuZ2V0KCdheGlzUG9pbnRlci5heGlzJykpO1xuXG4gICAgICBpZiAodHJpZ2dlckF4aXMgfHwgY3Jvc3MpIHtcbiAgICAgICAgZWFjaCh0b29sdGlwQXhlcy5iYXNlQXhlcywgY3Vycnkoc2F2ZVRvb2x0aXBBeGlzSW5mbywgY3Jvc3MgPyAnY3Jvc3MnIDogdHJ1ZSwgdHJpZ2dlckF4aXMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNyb3NzKSB7XG4gICAgICAgIGVhY2godG9vbHRpcEF4ZXMub3RoZXJBeGVzLCBjdXJyeShzYXZlVG9vbHRpcEF4aXNJbmZvLCAnY3Jvc3MnLCBmYWxzZSkpO1xuICAgICAgfVxuICAgIH0gLy8gZnJvbVRvb2x0aXA6IHRydWUgfCBmYWxzZSB8ICdjcm9zcydcbiAgICAvLyB0cmlnZ2VyVG9vbHRpcDogdHJ1ZSB8IGZhbHNlIHwgbnVsbFxuXG5cbiAgICBmdW5jdGlvbiBzYXZlVG9vbHRpcEF4aXNJbmZvKGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcCwgYXhpcykge1xuICAgICAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzLm1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicsIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgdmFyIGF4aXNQb2ludGVyU2hvdyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzaG93Jyk7XG5cbiAgICAgIGlmICghYXhpc1BvaW50ZXJTaG93IHx8IGF4aXNQb2ludGVyU2hvdyA9PT0gJ2F1dG8nICYmICFmcm9tVG9vbHRpcCAmJiAhaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyaWdnZXJUb29sdGlwID09IG51bGwpIHtcbiAgICAgICAgdHJpZ2dlclRvb2x0aXAgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndHJpZ2dlclRvb2x0aXAnKTtcbiAgICAgIH1cblxuICAgICAgYXhpc1BvaW50ZXJNb2RlbCA9IGZyb21Ub29sdGlwID8gbWFrZUF4aXNQb2ludGVyTW9kZWwoYXhpcywgYmFzZVRvb2x0aXBNb2RlbCwgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCwgZnJvbVRvb2x0aXAsIHRyaWdnZXJUb29sdGlwKSA6IGF4aXNQb2ludGVyTW9kZWw7XG4gICAgICB2YXIgc25hcCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzbmFwJyk7XG4gICAgICB2YXIga2V5ID0gbWFrZUtleShheGlzLm1vZGVsKTtcbiAgICAgIHZhciBpbnZvbHZlU2VyaWVzID0gdHJpZ2dlclRvb2x0aXAgfHwgc25hcCB8fCBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7IC8vIElmIHJlc3VsdC5heGVzSW5mb1trZXldIGV4aXN0LCBvdmVycmlkZSBpdCAodG9vbHRpcCBoYXMgaGlnaGVyIHByaW9yaXR5KS5cblxuICAgICAgdmFyIGF4aXNJbmZvID0gcmVzdWx0LmF4ZXNJbmZvW2tleV0gPSB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBheGlzOiBheGlzLFxuICAgICAgICBjb29yZFN5czogY29vcmRTeXMsXG4gICAgICAgIGF4aXNQb2ludGVyTW9kZWw6IGF4aXNQb2ludGVyTW9kZWwsXG4gICAgICAgIHRyaWdnZXJUb29sdGlwOiB0cmlnZ2VyVG9vbHRpcCxcbiAgICAgICAgaW52b2x2ZVNlcmllczogaW52b2x2ZVNlcmllcyxcbiAgICAgICAgc25hcDogc25hcCxcbiAgICAgICAgdXNlSGFuZGxlOiBpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbCksXG4gICAgICAgIHNlcmllc01vZGVsczogW11cbiAgICAgIH07XG4gICAgICBheGVzSW5mb0luQ29vcmRTeXNba2V5XSA9IGF4aXNJbmZvO1xuICAgICAgcmVzdWx0LnNlcmllc0ludm9sdmVkIHw9IGludm9sdmVTZXJpZXM7XG4gICAgICB2YXIgZ3JvdXBJbmRleCA9IGdldExpbmtHcm91cEluZGV4KGxpbmtzT3B0aW9uLCBheGlzKTtcblxuICAgICAgaWYgKGdyb3VwSW5kZXggIT0gbnVsbCkge1xuICAgICAgICB2YXIgbGlua0dyb3VwID0gbGlua0dyb3Vwc1tncm91cEluZGV4XSB8fCAobGlua0dyb3Vwc1tncm91cEluZGV4XSA9IHtcbiAgICAgICAgICBheGVzSW5mbzoge31cbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmtHcm91cC5heGVzSW5mb1trZXldID0gYXhpc0luZm87XG4gICAgICAgIGxpbmtHcm91cC5tYXBwZXIgPSBsaW5rc09wdGlvbltncm91cEluZGV4XS5tYXBwZXI7XG4gICAgICAgIGF4aXNJbmZvLmxpbmtHcm91cCA9IGxpbmtHcm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQXhpc1BvaW50ZXJNb2RlbChheGlzLCBiYXNlVG9vbHRpcE1vZGVsLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsLCBlY01vZGVsLCBmcm9tVG9vbHRpcCwgdHJpZ2dlclRvb2x0aXApIHtcbiAgdmFyIHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsID0gYmFzZVRvb2x0aXBNb2RlbC5nZXRNb2RlbCgnYXhpc1BvaW50ZXInKTtcbiAgdmFyIHZvbGF0aWxlT3B0aW9uID0ge307XG4gIGVhY2goWyd0eXBlJywgJ3NuYXAnLCAnbGluZVN0eWxlJywgJ3NoYWRvd1N0eWxlJywgJ2xhYmVsJywgJ2FuaW1hdGlvbicsICdhbmltYXRpb25EdXJhdGlvblVwZGF0ZScsICdhbmltYXRpb25FYXNpbmdVcGRhdGUnLCAneiddLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2b2xhdGlsZU9wdGlvbltmaWVsZF0gPSB6clV0aWwuY2xvbmUodG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KGZpZWxkKSk7XG4gIH0pOyAvLyBjYXRlZ29yeSBheGlzIGRvIG5vdCBhdXRvIHNuYXAsIG90aGVyd2lzZSBzb21lIHRpY2sgdGhhdCBkbyBub3RcbiAgLy8gaGFzIHZhbHVlIGNhbiBub3QgYmUgaG92ZXJlZC4gdmFsdWUvdGltZS9sb2cgYXhpcyBkZWZhdWx0IHNuYXAgaWZcbiAgLy8gdHJpZ2dlcmVkIGZyb20gdG9vbHRpcCBhbmQgdHJpZ2dlciB0b29sdGlwLlxuXG4gIHZvbGF0aWxlT3B0aW9uLnNuYXAgPSBheGlzLnR5cGUgIT09ICdjYXRlZ29yeScgJiYgISF0cmlnZ2VyVG9vbHRpcDsgLy8gQ29tcGF0aWJlbCB3aXRoIHByZXZpb3VzIGJlaGF2aW9yLCB0b29sdGlwIGF4aXMgZG8gbm90IHNob3cgbGFiZWwgYnkgZGVmYXVsdC5cbiAgLy8gT25seSB0aGVzZSBwcm9wZXJ0aWVzIGNhbiBiZSBvdmVycmlkZWQgZnJvbSB0b29sdGlwIHRvIGF4aXNQb2ludGVyLlxuXG4gIGlmICh0b29sdGlwQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2Nyb3NzJykge1xuICAgIHZvbGF0aWxlT3B0aW9uLnR5cGUgPSAnbGluZSc7XG4gIH1cblxuICB2YXIgbGFiZWxPcHRpb24gPSB2b2xhdGlsZU9wdGlvbi5sYWJlbCB8fCAodm9sYXRpbGVPcHRpb24ubGFiZWwgPSB7fSk7IC8vIEZvbGxvdyB0aGUgY29udmVudGlvbiwgZG8gbm90IHNob3cgbGFiZWwgd2hlbiB0cmlnZ2VyZWQgYnkgdG9vbHRpcCBieSBkZWZhdWx0LlxuXG4gIGxhYmVsT3B0aW9uLnNob3cgPT0gbnVsbCAmJiAobGFiZWxPcHRpb24uc2hvdyA9IGZhbHNlKTtcblxuICBpZiAoZnJvbVRvb2x0aXAgPT09ICdjcm9zcycpIHtcbiAgICAvLyBXaGVuICdjcm9zcycsIGJvdGggYXhlcyBzaG93IGxhYmVscy5cbiAgICBsYWJlbE9wdGlvbi5zaG93ID0gdHJ1ZTsgLy8gSWYgdHJpZ2dlclRvb2x0aXAsIHRoaXMgaXMgYSBiYXNlIGF4aXMsIHdoaWNoIHNob3VsZCBiZXR0ZXIgbm90IHVzZSBjcm9zcyBzdHlsZVxuICAgIC8vIChjcm9zcyBzdHlsZSBpcyBkYXNoZWQgYnkgZGVmYXVsdClcblxuICAgIGlmICghdHJpZ2dlclRvb2x0aXApIHtcbiAgICAgIHZhciBjcm9zc1N0eWxlID0gdm9sYXRpbGVPcHRpb24ubGluZVN0eWxlID0gdG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCdjcm9zc1N0eWxlJyk7XG4gICAgICBjcm9zc1N0eWxlICYmIHpyVXRpbC5kZWZhdWx0cyhsYWJlbE9wdGlvbiwgY3Jvc3NTdHlsZS50ZXh0U3R5bGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBheGlzLm1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicsIG5ldyBNb2RlbCh2b2xhdGlsZU9wdGlvbiwgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCkpO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0U2VyaWVzSW5mbyhyZXN1bHQsIGVjTW9kZWwpIHtcbiAgLy8gUHJlcGFyZSBkYXRhIGZvciBheGlzIHRyaWdnZXJcbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIC8vIE5vdGljZSB0aGlzIGNhc2U6IHRoaXMgY29vcmRTeXMgaXMgYGNhcnRlc2lhbjJEYCBidXQgbm90IGBncmlkYC5cbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBzZXJpZXNUb29sdGlwVHJpZ2dlciA9IHNlcmllc01vZGVsLmdldCgndG9vbHRpcC50cmlnZ2VyJywgdHJ1ZSk7XG4gICAgdmFyIHNlcmllc1Rvb2x0aXBTaG93ID0gc2VyaWVzTW9kZWwuZ2V0KCd0b29sdGlwLnNob3cnLCB0cnVlKTtcblxuICAgIGlmICghY29vcmRTeXMgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09ICdub25lJyB8fCBzZXJpZXNUb29sdGlwVHJpZ2dlciA9PT0gZmFsc2UgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09ICdpdGVtJyB8fCBzZXJpZXNUb29sdGlwU2hvdyA9PT0gZmFsc2UgfHwgc2VyaWVzTW9kZWwuZ2V0KCdheGlzUG9pbnRlci5zaG93JywgdHJ1ZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaChyZXN1bHQuY29vcmRTeXNBeGVzSW5mb1ttYWtlS2V5KGNvb3JkU3lzLm1vZGVsKV0sIGZ1bmN0aW9uIChheGlzSW5mbykge1xuICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuXG4gICAgICBpZiAoY29vcmRTeXMuZ2V0QXhpcyhheGlzLmRpbSkgPT09IGF4aXMpIHtcbiAgICAgICAgYXhpc0luZm8uc2VyaWVzTW9kZWxzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgICBheGlzSW5mby5zZXJpZXNEYXRhQ291bnQgPT0gbnVsbCAmJiAoYXhpc0luZm8uc2VyaWVzRGF0YUNvdW50ID0gMCk7XG4gICAgICAgIGF4aXNJbmZvLnNlcmllc0RhdGFDb3VudCArPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY291bnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgdGhpcyk7XG59XG4vKipcbiAqIEZvciBleGFtcGxlOlxuICoge1xuICogICAgIGF4aXNQb2ludGVyOiB7XG4gKiAgICAgICAgIGxpbmtzOiBbe1xuICogICAgICAgICAgICAgeEF4aXNJbmRleDogWzIsIDRdLFxuICogICAgICAgICAgICAgeUF4aXNJbmRleDogJ2FsbCdcbiAqICAgICAgICAgfSwge1xuICogICAgICAgICAgICAgeEF4aXNJZDogWydhNScsICdhNyddLFxuICogICAgICAgICAgICAgeEF4aXNOYW1lOiAneHh4J1xuICogICAgICAgICB9XVxuICogICAgIH1cbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpbmtHcm91cEluZGV4KGxpbmtzT3B0aW9uLCBheGlzKSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzLm1vZGVsO1xuICB2YXIgZGltID0gYXhpcy5kaW07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rc09wdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5rT3B0aW9uID0gbGlua3NPcHRpb25baV0gfHwge307XG5cbiAgICBpZiAoY2hlY2tQcm9wSW5MaW5rKGxpbmtPcHRpb25bZGltICsgJ0F4aXNJZCddLCBheGlzTW9kZWwuaWQpIHx8IGNoZWNrUHJvcEluTGluayhsaW5rT3B0aW9uW2RpbSArICdBeGlzSW5kZXgnXSwgYXhpc01vZGVsLmNvbXBvbmVudEluZGV4KSB8fCBjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc05hbWUnXSwgYXhpc01vZGVsLm5hbWUpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wSW5MaW5rKGxpbmtQcm9wVmFsdWUsIGF4aXNQcm9wVmFsdWUpIHtcbiAgcmV0dXJuIGxpbmtQcm9wVmFsdWUgPT09ICdhbGwnIHx8IHpyVXRpbC5pc0FycmF5KGxpbmtQcm9wVmFsdWUpICYmIHpyVXRpbC5pbmRleE9mKGxpbmtQcm9wVmFsdWUsIGF4aXNQcm9wVmFsdWUpID49IDAgfHwgbGlua1Byb3BWYWx1ZSA9PT0gYXhpc1Byb3BWYWx1ZTtcbn1cblxuZnVuY3Rpb24gZml4VmFsdWUoYXhpc01vZGVsKSB7XG4gIHZhciBheGlzSW5mbyA9IGdldEF4aXNJbmZvKGF4aXNNb2RlbCk7XG5cbiAgaWYgKCFheGlzSW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbDtcbiAgdmFyIHNjYWxlID0gYXhpc0luZm8uYXhpcy5zY2FsZTtcbiAgdmFyIG9wdGlvbiA9IGF4aXNQb2ludGVyTW9kZWwub3B0aW9uO1xuICB2YXIgc3RhdHVzID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3N0YXR1cycpO1xuICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTsgLy8gUGFyc2UgaW5pdCB2YWx1ZSBmb3IgY2F0ZWdvcnkgYW5kIHRpbWUgYXhpcy5cblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHZhbHVlID0gc2NhbGUucGFyc2UodmFsdWUpO1xuICB9XG5cbiAgdmFyIHVzZUhhbmRsZSA9IGlzSGFuZGxlVHJpZ2dlcihheGlzUG9pbnRlck1vZGVsKTsgLy8gSWYgYGhhbmRsZWAgdXNlZCwgYGF4aXNQb2ludGVyYCB3aWxsIGFsd2F5cyBiZSBkaXNwbGF5ZWQsIHNvIHZhbHVlXG4gIC8vIGFuZCBzdGF0dXMgc2hvdWxkIGJlIGluaXRpYWxpemVkLlxuXG4gIGlmIChzdGF0dXMgPT0gbnVsbCkge1xuICAgIG9wdGlvbi5zdGF0dXMgPSB1c2VIYW5kbGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gIH1cblxuICB2YXIgZXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCkuc2xpY2UoKTtcbiAgZXh0ZW50WzBdID4gZXh0ZW50WzFdICYmIGV4dGVudC5yZXZlcnNlKCk7XG5cbiAgaWYgKCAvLyBQaWNrIGEgdmFsdWUgb24gYXhpcyB3aGVuIGluaXRpYWxpemluZy5cbiAgdmFsdWUgPT0gbnVsbCAvLyBJZiBib3RoIGBoYW5kbGVgIGFuZCBgZGF0YVpvb21gIGFyZSB1c2VkLCB2YWx1ZSBtYXkgYmUgb3V0IG9mIGF4aXMgZXh0ZW50LFxuICAvLyB3aGVyZSB3ZSBzaG91bGQgcmUtcGljayBhIHZhbHVlIHRvIGtlZXAgYGhhbmRsZWAgZGlzcGxheWluZyBub3JtYWxseS5cbiAgfHwgdmFsdWUgPiBleHRlbnRbMV0pIHtcbiAgICAvLyBNYWtlIGhhbmRsZSBkaXNwbGF5ZWQgb24gdGhlIGVuZCBvZiB0aGUgYXhpcyB3aGVuIGluaXQsIHdoaWNoIGxvb2tzIGJldHRlci5cbiAgICB2YWx1ZSA9IGV4dGVudFsxXTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA8IGV4dGVudFswXSkge1xuICAgIHZhbHVlID0gZXh0ZW50WzBdO1xuICB9XG5cbiAgb3B0aW9uLnZhbHVlID0gdmFsdWU7XG5cbiAgaWYgKHVzZUhhbmRsZSkge1xuICAgIG9wdGlvbi5zdGF0dXMgPSBheGlzSW5mby5heGlzLnNjYWxlLmlzQmxhbmsoKSA/ICdoaWRlJyA6ICdzaG93JztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBeGlzSW5mbyhheGlzTW9kZWwpIHtcbiAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSAoYXhpc01vZGVsLmVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpIHx8IHt9KS5jb29yZFN5c0F4ZXNJbmZvO1xuICByZXR1cm4gY29vcmRTeXNBeGVzSW5mbyAmJiBjb29yZFN5c0F4ZXNJbmZvLmF4ZXNJbmZvW21ha2VLZXkoYXhpc01vZGVsKV07XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNQb2ludGVyTW9kZWwoYXhpc01vZGVsKSB7XG4gIHZhciBheGlzSW5mbyA9IGdldEF4aXNJbmZvKGF4aXNNb2RlbCk7XG4gIHJldHVybiBheGlzSW5mbyAmJiBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsO1xufVxuXG5mdW5jdGlvbiBpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbCkge1xuICByZXR1cm4gISFheGlzUG9pbnRlck1vZGVsLmdldCgnaGFuZGxlLnNob3cnKTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcbiAqIEByZXR1cm4ge3N0cmluZ30gdW5pcXVlIGtleVxuICovXG5cblxuZnVuY3Rpb24gbWFrZUtleShtb2RlbCkge1xuICByZXR1cm4gbW9kZWwudHlwZSArICd8fCcgKyBtb2RlbC5pZDtcbn1cblxuZXhwb3J0cy5jb2xsZWN0ID0gY29sbGVjdDtcbmV4cG9ydHMuZml4VmFsdWUgPSBmaXhWYWx1ZTtcbmV4cG9ydHMuZ2V0QXhpc0luZm8gPSBnZXRBeGlzSW5mbztcbmV4cG9ydHMuZ2V0QXhpc1BvaW50ZXJNb2RlbCA9IGdldEF4aXNQb2ludGVyTW9kZWw7XG5leHBvcnRzLm1ha2VLZXkgPSBtYWtlS2V5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9tb2RlbEhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL21vZGVsSGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBtYXRyaXggPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9tYXRyaXhcIik7XG5cbnZhciBheGlzSGVscGVyID0gcmVxdWlyZShcIi4uLy4uL2Nvb3JkL2F4aXNIZWxwZXJcIik7XG5cbnZhciBBeGlzQnVpbGRlciA9IHJlcXVpcmUoXCIuLi9heGlzL0F4aXNCdWlsZGVyXCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGF4aXNQb2ludGVyTW9kZWxcbiAqL1xuZnVuY3Rpb24gYnVpbGRFbFN0eWxlKGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG4gIHZhciBzdHlsZU1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbC5nZXRNb2RlbChheGlzUG9pbnRlclR5cGUgKyAnU3R5bGUnKTtcbiAgdmFyIHN0eWxlO1xuXG4gIGlmIChheGlzUG9pbnRlclR5cGUgPT09ICdsaW5lJykge1xuICAgIHN0eWxlID0gc3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKTtcbiAgICBzdHlsZS5maWxsID0gbnVsbDtcbiAgfSBlbHNlIGlmIChheGlzUG9pbnRlclR5cGUgPT09ICdzaGFkb3cnKSB7XG4gICAgc3R5bGUgPSBzdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuICAgIHN0eWxlLnN0cm9rZSA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxhYmVsUG9zIHthbGlnbiwgdmVydGljYWxBbGlnbiwgcG9zaXRpb259XG4gKi9cblxuXG5mdW5jdGlvbiBidWlsZExhYmVsRWxPcHRpb24oZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpLCBsYWJlbFBvcykge1xuICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgdmFyIHRleHQgPSBnZXRWYWx1ZUxhYmVsKHZhbHVlLCBheGlzTW9kZWwuYXhpcywgYXhpc01vZGVsLmVjTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzZXJpZXNEYXRhSW5kaWNlcycpLCB7XG4gICAgcHJlY2lzaW9uOiBheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwucHJlY2lzaW9uJyksXG4gICAgZm9ybWF0dGVyOiBheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwuZm9ybWF0dGVyJylcbiAgfSk7XG4gIHZhciBsYWJlbE1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgdmFyIHBhZGRpbmdzID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShsYWJlbE1vZGVsLmdldCgncGFkZGluZycpIHx8IDApO1xuICB2YXIgZm9udCA9IGxhYmVsTW9kZWwuZ2V0Rm9udCgpO1xuICB2YXIgdGV4dFJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCk7XG4gIHZhciBwb3NpdGlvbiA9IGxhYmVsUG9zLnBvc2l0aW9uO1xuICB2YXIgd2lkdGggPSB0ZXh0UmVjdC53aWR0aCArIHBhZGRpbmdzWzFdICsgcGFkZGluZ3NbM107XG4gIHZhciBoZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQgKyBwYWRkaW5nc1swXSArIHBhZGRpbmdzWzJdOyAvLyBBZGp1c3QgYnkgYWxpZ24uXG5cbiAgdmFyIGFsaWduID0gbGFiZWxQb3MuYWxpZ247XG4gIGFsaWduID09PSAncmlnaHQnICYmIChwb3NpdGlvblswXSAtPSB3aWR0aCk7XG4gIGFsaWduID09PSAnY2VudGVyJyAmJiAocG9zaXRpb25bMF0gLT0gd2lkdGggLyAyKTtcbiAgdmFyIHZlcnRpY2FsQWxpZ24gPSBsYWJlbFBvcy52ZXJ0aWNhbEFsaWduO1xuICB2ZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJyAmJiAocG9zaXRpb25bMV0gLT0gaGVpZ2h0KTtcbiAgdmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScgJiYgKHBvc2l0aW9uWzFdIC09IGhlaWdodCAvIDIpOyAvLyBOb3Qgb3ZlcmZsb3cgZWMgY29udGFpbmVyXG5cbiAgY29uZmluZUluQ29udGFpbmVyKHBvc2l0aW9uLCB3aWR0aCwgaGVpZ2h0LCBhcGkpO1xuICB2YXIgYmdDb2xvciA9IGxhYmVsTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcblxuICBpZiAoIWJnQ29sb3IgfHwgYmdDb2xvciA9PT0gJ2F1dG8nKSB7XG4gICAgYmdDb2xvciA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpO1xuICB9XG5cbiAgZWxPcHRpb24ubGFiZWwgPSB7XG4gICAgc2hhcGU6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICByOiBsYWJlbE1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJylcbiAgICB9LFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvbi5zbGljZSgpLFxuICAgIC8vIFRPRE86IHJpY2hcbiAgICBzdHlsZToge1xuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIHRleHRGb250OiBmb250LFxuICAgICAgdGV4dEZpbGw6IGxhYmVsTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICB0ZXh0UG9zaXRpb246ICdpbnNpZGUnLFxuICAgICAgZmlsbDogYmdDb2xvcixcbiAgICAgIHN0cm9rZTogbGFiZWxNb2RlbC5nZXQoJ2JvcmRlckNvbG9yJykgfHwgJ3RyYW5zcGFyZW50JyxcbiAgICAgIGxpbmVXaWR0aDogbGFiZWxNb2RlbC5nZXQoJ2JvcmRlcldpZHRoJykgfHwgMCxcbiAgICAgIHNoYWRvd0JsdXI6IGxhYmVsTW9kZWwuZ2V0KCdzaGFkb3dCbHVyJyksXG4gICAgICBzaGFkb3dDb2xvcjogbGFiZWxNb2RlbC5nZXQoJ3NoYWRvd0NvbG9yJyksXG4gICAgICBzaGFkb3dPZmZzZXRYOiBsYWJlbE1vZGVsLmdldCgnc2hhZG93T2Zmc2V0WCcpLFxuICAgICAgc2hhZG93T2Zmc2V0WTogbGFiZWxNb2RlbC5nZXQoJ3NoYWRvd09mZnNldFknKVxuICAgIH0sXG4gICAgLy8gTGFibGUgc2hvdWxkIGJlIG92ZXIgYXhpc1BvaW50ZXIuXG4gICAgejI6IDEwXG4gIH07XG59IC8vIERvIG5vdCBvdmVyZmxvdyBlYyBjb250YWluZXJcblxuXG5mdW5jdGlvbiBjb25maW5lSW5Db250YWluZXIocG9zaXRpb24sIHdpZHRoLCBoZWlnaHQsIGFwaSkge1xuICB2YXIgdmlld1dpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gIHZhciB2aWV3SGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICBwb3NpdGlvblswXSA9IE1hdGgubWluKHBvc2l0aW9uWzBdICsgd2lkdGgsIHZpZXdXaWR0aCkgLSB3aWR0aDtcbiAgcG9zaXRpb25bMV0gPSBNYXRoLm1pbihwb3NpdGlvblsxXSArIGhlaWdodCwgdmlld0hlaWdodCkgLSBoZWlnaHQ7XG4gIHBvc2l0aW9uWzBdID0gTWF0aC5tYXgocG9zaXRpb25bMF0sIDApO1xuICBwb3NpdGlvblsxXSA9IE1hdGgubWF4KHBvc2l0aW9uWzFdLCAwKTtcbn1cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0F4aXN9IGF4aXNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBzZXJpZXNEYXRhSW5kaWNlc1xuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBvcHQucHJlY2lzaW9uICdhdXRvJyBvciBhIG51bWJlclxuICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IG9wdC5mb3JtYXR0ZXIgbGFiZWwgZm9ybWF0dGVyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRWYWx1ZUxhYmVsKHZhbHVlLCBheGlzLCBlY01vZGVsLCBzZXJpZXNEYXRhSW5kaWNlcywgb3B0KSB7XG4gIHZhciB0ZXh0ID0gYXhpcy5zY2FsZS5nZXRMYWJlbCggLy8gSWYgYHByZWNpc2lvbmAgaXMgc2V0LCB3aWR0aCBjYW4gYmUgZml4ZWQgKGxpa2UgJzEyLjAwNTAwJyksIHdoaWNoXG4gIC8vIGhlbHBzIHRvIGRlYm91bmNlIHdoZW4gd2hlbiBtb3ZpbmcgbGFiZWwuXG4gIHZhbHVlLCB7XG4gICAgcHJlY2lzaW9uOiBvcHQucHJlY2lzaW9uXG4gIH0pO1xuICB2YXIgZm9ybWF0dGVyID0gb3B0LmZvcm1hdHRlcjtcblxuICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgIHZhbHVlOiBheGlzSGVscGVyLmdldEF4aXNSYXdWYWx1ZShheGlzLCB2YWx1ZSksXG4gICAgICBzZXJpZXNEYXRhOiBbXVxuICAgIH07XG4gICAgenJVdGlsLmVhY2goc2VyaWVzRGF0YUluZGljZXMsIGZ1bmN0aW9uIChpZHhJdGVtKSB7XG4gICAgICB2YXIgc2VyaWVzID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KGlkeEl0ZW0uc2VyaWVzSW5kZXgpO1xuICAgICAgdmFyIGRhdGFJbmRleCA9IGlkeEl0ZW0uZGF0YUluZGV4SW5zaWRlO1xuICAgICAgdmFyIGRhdGFQYXJhbXMgPSBzZXJpZXMgJiYgc2VyaWVzLmdldERhdGFQYXJhbXMoZGF0YUluZGV4KTtcbiAgICAgIGRhdGFQYXJhbXMgJiYgcGFyYW1zLnNlcmllc0RhdGEucHVzaChkYXRhUGFyYW1zKTtcbiAgICB9KTtcblxuICAgIGlmICh6clV0aWwuaXNTdHJpbmcoZm9ybWF0dGVyKSkge1xuICAgICAgdGV4dCA9IGZvcm1hdHRlci5yZXBsYWNlKCd7dmFsdWV9JywgdGV4dCk7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNGdW5jdGlvbihmb3JtYXR0ZXIpKSB7XG4gICAgICB0ZXh0ID0gZm9ybWF0dGVyKHBhcmFtcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRleHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvQXhpc30gYXhpc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0SW5mbyB7XG4gKiAgcm90YXRpb24sIHBvc2l0aW9uLCBsYWJlbE9mZnNldCwgbGFiZWxEaXJlY3Rpb24sIGxhYmVsTWFyZ2luXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1lZFBvc2l0aW9uKGF4aXMsIHZhbHVlLCBsYXlvdXRJbmZvKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBtYXRyaXguY3JlYXRlKCk7XG4gIG1hdHJpeC5yb3RhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIGxheW91dEluZm8ucm90YXRpb24pO1xuICBtYXRyaXgudHJhbnNsYXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBsYXlvdXRJbmZvLnBvc2l0aW9uKTtcbiAgcmV0dXJuIGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW2F4aXMuZGF0YVRvQ29vcmQodmFsdWUpLCAobGF5b3V0SW5mby5sYWJlbE9mZnNldCB8fCAwKSArIChsYXlvdXRJbmZvLmxhYmVsRGlyZWN0aW9uIHx8IDEpICogKGxheW91dEluZm8ubGFiZWxNYXJnaW4gfHwgMCldLCB0cmFuc2Zvcm0pO1xufVxuXG5mdW5jdGlvbiBidWlsZENhcnRlc2lhblNpbmdsZUxhYmVsRWxPcHRpb24odmFsdWUsIGVsT3B0aW9uLCBsYXlvdXRJbmZvLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICB2YXIgdGV4dExheW91dCA9IEF4aXNCdWlsZGVyLmlubmVyVGV4dExheW91dChsYXlvdXRJbmZvLnJvdGF0aW9uLCAwLCBsYXlvdXRJbmZvLmxhYmVsRGlyZWN0aW9uKTtcbiAgbGF5b3V0SW5mby5sYWJlbE1hcmdpbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5tYXJnaW4nKTtcbiAgYnVpbGRMYWJlbEVsT3B0aW9uKGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwge1xuICAgIHBvc2l0aW9uOiBnZXRUcmFuc2Zvcm1lZFBvc2l0aW9uKGF4aXNNb2RlbC5heGlzLCB2YWx1ZSwgbGF5b3V0SW5mbyksXG4gICAgYWxpZ246IHRleHRMYXlvdXQudGV4dEFsaWduLFxuICAgIHZlcnRpY2FsQWxpZ246IHRleHRMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ25cbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAxXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwMlxuICogQHBhcmFtIHtudW1iZXJ9IFt4RGltSW5kZXg9MF0gb3IgMVxuICovXG5cblxuZnVuY3Rpb24gbWFrZUxpbmVTaGFwZShwMSwgcDIsIHhEaW1JbmRleCkge1xuICB4RGltSW5kZXggPSB4RGltSW5kZXggfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB4MTogcDFbeERpbUluZGV4XSxcbiAgICB5MTogcDFbMSAtIHhEaW1JbmRleF0sXG4gICAgeDI6IHAyW3hEaW1JbmRleF0sXG4gICAgeTI6IHAyWzEgLSB4RGltSW5kZXhdXG4gIH07XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHh5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB3aFxuICogQHBhcmFtIHtudW1iZXJ9IFt4RGltSW5kZXg9MF0gb3IgMVxuICovXG5cblxuZnVuY3Rpb24gbWFrZVJlY3RTaGFwZSh4eSwgd2gsIHhEaW1JbmRleCkge1xuICB4RGltSW5kZXggPSB4RGltSW5kZXggfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB4OiB4eVt4RGltSW5kZXhdLFxuICAgIHk6IHh5WzEgLSB4RGltSW5kZXhdLFxuICAgIHdpZHRoOiB3aFt4RGltSW5kZXhdLFxuICAgIGhlaWdodDogd2hbMSAtIHhEaW1JbmRleF1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZVNlY3RvclNoYXBlKGN4LCBjeSwgcjAsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gIHJldHVybiB7XG4gICAgY3g6IGN4LFxuICAgIGN5OiBjeSxcbiAgICByMDogcjAsXG4gICAgcjogcixcbiAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICBjbG9ja3dpc2U6IHRydWVcbiAgfTtcbn1cblxuZXhwb3J0cy5idWlsZEVsU3R5bGUgPSBidWlsZEVsU3R5bGU7XG5leHBvcnRzLmJ1aWxkTGFiZWxFbE9wdGlvbiA9IGJ1aWxkTGFiZWxFbE9wdGlvbjtcbmV4cG9ydHMuZ2V0VmFsdWVMYWJlbCA9IGdldFZhbHVlTGFiZWw7XG5leHBvcnRzLmdldFRyYW5zZm9ybWVkUG9zaXRpb24gPSBnZXRUcmFuc2Zvcm1lZFBvc2l0aW9uO1xuZXhwb3J0cy5idWlsZENhcnRlc2lhblNpbmdsZUxhYmVsRWxPcHRpb24gPSBidWlsZENhcnRlc2lhblNpbmdsZUxhYmVsRWxPcHRpb247XG5leHBvcnRzLm1ha2VMaW5lU2hhcGUgPSBtYWtlTGluZVNoYXBlO1xuZXhwb3J0cy5tYWtlUmVjdFNoYXBlID0gbWFrZVJlY3RTaGFwZTtcbmV4cG9ydHMubWFrZVNlY3RvclNoYXBlID0gbWFrZVNlY3RvclNoYXBlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci92aWV3SGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvdmlld0hlbHBlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInJlcXVpcmUoXCIuL2RhdGFab29tL3R5cGVEZWZhdWx0ZXJcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL0RhdGFab29tTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL0RhdGFab29tVmlld1wiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vU2xpZGVyWm9vbU1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9TbGlkZXJab29tVmlld1wiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vSW5zaWRlWm9vbU1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9JbnNpZGVab29tVmlld1wiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vZGF0YVpvb21Qcm9jZXNzb3JcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL2RhdGFab29tQWN0aW9uXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgaGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGFzYyA9IG51bWJlclV0aWwuYXNjO1xuLyoqXG4gKiBPcGVyYXRlIHNpbmdsZSBheGlzLlxuICogT25lIGF4aXMgY2FuIG9ubHkgb3BlcmF0ZWQgYnkgb25lIGF4aXMgb3BlcmF0b3IuXG4gKiBEaWZmZXJlbnQgZGF0YVpvb21Nb2RlbHMgbWF5IGJlIGRlZmluZWQgdG8gb3BlcmF0ZSB0aGUgc2FtZSBheGlzLlxuICogKGkuZS4gJ2luc2lkZScgZGF0YSB6b29tIGFuZCAnc2xpZGVyJyBkYXRhIHpvb20gY29tcG9uZW50cylcbiAqIFNvIGRhdGFab29tTW9kZWxzIHNoYXJlIG9uZSBheGlzUHJveHkgaW4gdGhhdCBjYXNlLlxuICpcbiAqIEBjbGFzc1xuICovXG5cbnZhciBBeGlzUHJveHkgPSBmdW5jdGlvbiAoZGltTmFtZSwgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsLCBlY01vZGVsKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5fZGltTmFtZSA9IGRpbU5hbWU7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9heGlzSW5kZXggPSBheGlzSW5kZXg7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuXG4gIHRoaXMuX3ZhbHVlV2luZG93O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cblxuICB0aGlzLl9wZXJjZW50V2luZG93O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cblxuICB0aGlzLl9kYXRhRXh0ZW50O1xuICAvKipcbiAgICoge21pblNwYW4sIG1heFNwYW4sIG1pblZhbHVlU3BhbiwgbWF4VmFsdWVTcGFufVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9taW5NYXhTcGFuO1xuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqIEB0eXBlIHttb2R1bGU6IGVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgKi9cblxuICB0aGlzLmVjTW9kZWwgPSBlY01vZGVsO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH1cbiAgICovXG5cbiAgdGhpcy5fZGF0YVpvb21Nb2RlbCA9IGRhdGFab29tTW9kZWw7XG59O1xuXG5BeGlzUHJveHkucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQXhpc1Byb3h5LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBheGlzUHJveHkgaXMgaG9zdGVkIGJ5IGRhdGFab29tTW9kZWwuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhvc3RlZEJ5OiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhWm9vbU1vZGVsID09PSBkYXRhWm9vbU1vZGVsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVmFsdWUgY2FuIG9ubHkgYmUgTmFOIG9yIGZpbml0ZSB2YWx1ZS5cbiAgICovXG4gIGdldERhdGFWYWx1ZVdpbmRvdzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZVdpbmRvdy5zbGljZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGdldERhdGFQZXJjZW50V2luZG93OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlcmNlbnRXaW5kb3cuc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAqIEByZXR1cm4ge0FycmF5fSBzZXJpZXNNb2RlbHNcbiAgICovXG4gIGdldFRhcmdldFNlcmllc01vZGVsczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZXJpZXNNb2RlbHMgPSBbXTtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBpZiAoaGVscGVyLmlzQ29vcmRTdXBwb3J0ZWQoc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykpKSB7XG4gICAgICAgIHZhciBkaW1OYW1lID0gdGhpcy5fZGltTmFtZTtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICBtYWluVHlwZTogZGltTmFtZSArICdBeGlzJyxcbiAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KGRpbU5hbWUgKyAnQXhpc0luZGV4JyksXG4gICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldChkaW1OYW1lICsgJ0F4aXNJZCcpXG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIGlmICh0aGlzLl9heGlzSW5kZXggPT09IChheGlzTW9kZWwgJiYgYXhpc01vZGVsLmNvbXBvbmVudEluZGV4KSkge1xuICAgICAgICAgIHNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBzZXJpZXNNb2RlbHM7XG4gIH0sXG4gIGdldEF4aXNNb2RlbDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVjTW9kZWwuZ2V0Q29tcG9uZW50KHRoaXMuX2RpbU5hbWUgKyAnQXhpcycsIHRoaXMuX2F4aXNJbmRleCk7XG4gIH0sXG4gIGdldE90aGVyQXhpc01vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF4aXNEaW0gPSB0aGlzLl9kaW1OYW1lO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmdldEF4aXNNb2RlbCgpO1xuICAgIHZhciBpc0NhcnRlc2lhbiA9IGF4aXNEaW0gPT09ICd4JyB8fCBheGlzRGltID09PSAneSc7XG4gICAgdmFyIG90aGVyQXhpc0RpbTtcbiAgICB2YXIgY29vcmRTeXNJbmRleE5hbWU7XG5cbiAgICBpZiAoaXNDYXJ0ZXNpYW4pIHtcbiAgICAgIGNvb3JkU3lzSW5kZXhOYW1lID0gJ2dyaWRJbmRleCc7XG4gICAgICBvdGhlckF4aXNEaW0gPSBheGlzRGltID09PSAneCcgPyAneScgOiAneCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb3JkU3lzSW5kZXhOYW1lID0gJ3BvbGFySW5kZXgnO1xuICAgICAgb3RoZXJBeGlzRGltID0gYXhpc0RpbSA9PT0gJ2FuZ2xlJyA/ICdyYWRpdXMnIDogJ2FuZ2xlJztcbiAgICB9XG5cbiAgICB2YXIgZm91bmRPdGhlckF4aXNNb2RlbDtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQob3RoZXJBeGlzRGltICsgJ0F4aXMnLCBmdW5jdGlvbiAob3RoZXJBeGlzTW9kZWwpIHtcbiAgICAgIGlmICgob3RoZXJBeGlzTW9kZWwuZ2V0KGNvb3JkU3lzSW5kZXhOYW1lKSB8fCAwKSA9PT0gKGF4aXNNb2RlbC5nZXQoY29vcmRTeXNJbmRleE5hbWUpIHx8IDApKSB7XG4gICAgICAgIGZvdW5kT3RoZXJBeGlzTW9kZWwgPSBvdGhlckF4aXNNb2RlbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmRPdGhlckF4aXNNb2RlbDtcbiAgfSxcbiAgZ2V0TWluTWF4U3BhbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB6clV0aWwuY2xvbmUodGhpcy5fbWluTWF4U3Bhbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9ubHkgY2FsY3VsYXRlIGJ5IGdpdmVuIHJhbmdlIGFuZCB0aGlzLl9kYXRhRXh0ZW50LCBkbyBub3QgY2hhbmdlIGFueXRoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnN0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5lbmRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnN0YXJ0VmFsdWVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuZFZhbHVlXVxuICAgKi9cbiAgY2FsY3VsYXRlRGF0YVdpbmRvdzogZnVuY3Rpb24gKG9wdCkge1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdGhpcy5fZGF0YUV4dGVudDtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5nZXRBeGlzTW9kZWwoKTtcbiAgICB2YXIgc2NhbGUgPSBheGlzTW9kZWwuYXhpcy5zY2FsZTtcblxuICAgIHZhciByYW5nZVByb3BNb2RlID0gdGhpcy5fZGF0YVpvb21Nb2RlbC5nZXRSYW5nZVByb3BNb2RlKCk7XG5cbiAgICB2YXIgcGVyY2VudEV4dGVudCA9IFswLCAxMDBdO1xuICAgIHZhciBwZXJjZW50V2luZG93ID0gW29wdC5zdGFydCwgb3B0LmVuZF07XG4gICAgdmFyIHZhbHVlV2luZG93ID0gW107XG4gICAgZWFjaChbJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnXSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhbHVlV2luZG93LnB1c2gob3B0W3Byb3BdICE9IG51bGwgPyBzY2FsZS5wYXJzZShvcHRbcHJvcF0pIDogbnVsbCk7XG4gICAgfSk7IC8vIE5vcm1hbGl6ZSBib3VuZC5cblxuICAgIGVhY2goWzAsIDFdLCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgYm91bmRWYWx1ZSA9IHZhbHVlV2luZG93W2lkeF07XG4gICAgICB2YXIgYm91bmRQZXJjZW50ID0gcGVyY2VudFdpbmRvd1tpZHhdOyAvLyBOb3RpY2U6IGRhdGFab29tIGlzIGJhc2VkIGVpdGhlciBvbiBgcGVyY2VudFByb3BgICgnc3RhcnQnLCAnZW5kJykgb3JcbiAgICAgIC8vIG9uIGB2YWx1ZVByb3BgICgnc3RhcnRWYWx1ZScsICdlbmRWYWx1ZScpLiBUaGUgZm9ybWVyIG9uZSBpcyBzdWl0YWJsZVxuICAgICAgLy8gZm9yIGNhc2VzIHRoYXQgYSBkYXRhWm9vbSBjb21wb25lbnQgY29udHJvbHMgbXVsdGlwbGUgYXhlcyB3aXRoIGRpZmZlcmVudFxuICAgICAgLy8gdW5pdCBvciBleHRlbnQsIGFuZCB0aGUgbGF0dGVyIG9uZSBpcyBzdWl0YWJsZSBmb3IgYWNjdXJhdGUgem9vbSBieSBwaXhlbFxuICAgICAgLy8gKGUuZy4sIGluIGRhdGFab29tU2VsZWN0KS4gYHZhbHVlUHJvcGAgY2FuIGJlIGNhbGN1bGF0ZWQgZnJvbSBgcGVyY2VudFByb3BgLFxuICAgICAgLy8gYnV0IGl0IGlzIGF3a3dhcmQgdGhhdCBgcGVyY2VudFByb3BgIGNhbiBub3QgYmUgb2J0YWluZWQgZnJvbSBgdmFsdWVQcm9wYFxuICAgICAgLy8gYWNjdXJhdGVseSAoYmVjYXVzZSBhbGwgb2YgdmFsdWVzIHRoYXQgYXJlIG92ZXJmbG93IHRoZSBgZGF0YUV4dGVudGAgd2lsbFxuICAgICAgLy8gYmUgY2FsY3VsYXRlZCB0byBwZXJjZW50ICcxMDAlJykuIFNvIHdlIGhhdmUgdG8gdXNlXG4gICAgICAvLyBgZGF0YVpvb20uZ2V0UmFuZ2VQcm9wTW9kZSgpYCB0byBtYXJrIHdoaWNoIHByb3AgaXMgdXNlZC5cbiAgICAgIC8vIGByYW5nZVByb3BNb2RlYCBpcyB1cGRhdGVkIG9ubHkgd2hlbiBzZXRPcHRpb24gb3IgZGlzcGF0Y2hBY3Rpb24sIG90aGVyd2lzZVxuICAgICAgLy8gaXQgcmVtYWlucyBpdHMgb3JpZ2luYWwgdmFsdWUuXG5cbiAgICAgIGlmIChyYW5nZVByb3BNb2RlW2lkeF0gPT09ICdwZXJjZW50Jykge1xuICAgICAgICBpZiAoYm91bmRQZXJjZW50ID09IG51bGwpIHtcbiAgICAgICAgICBib3VuZFBlcmNlbnQgPSBwZXJjZW50RXh0ZW50W2lkeF07XG4gICAgICAgIH0gLy8gVXNlIHNjYWxlLnBhcnNlIHRvIG1hdGggcm91bmQgZm9yIGNhdGVnb3J5IG9yIHRpbWUgYXhpcy5cblxuXG4gICAgICAgIGJvdW5kVmFsdWUgPSBzY2FsZS5wYXJzZShudW1iZXJVdGlsLmxpbmVhck1hcChib3VuZFBlcmNlbnQsIHBlcmNlbnRFeHRlbnQsIGRhdGFFeHRlbnQsIHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENhbGN1bGF0aW5nIGBwZXJjZW50YCBmcm9tIGB2YWx1ZWAgbWF5IGJlIG5vdCBhY2N1cmF0ZSwgYmVjYXVzZVxuICAgICAgICAvLyBUaGlzIGNhbGN1bGF0aW9uIGNhbiBub3QgYmUgaW52ZXJzZWQsIGJlY2F1c2UgYWxsIG9mIHZhbHVlcyB0aGF0XG4gICAgICAgIC8vIGFyZSBvdmVyZmxvdyB0aGUgYGRhdGFFeHRlbnRgIHdpbGwgYmUgY2FsY3VsYXRlZCB0byBwZXJjZW50ICcxMDAlJ1xuICAgICAgICBib3VuZFBlcmNlbnQgPSBudW1iZXJVdGlsLmxpbmVhck1hcChib3VuZFZhbHVlLCBkYXRhRXh0ZW50LCBwZXJjZW50RXh0ZW50LCB0cnVlKTtcbiAgICAgIH0gLy8gdmFsdWVXaW5kb3dbaWR4XSA9IHJvdW5kKGJvdW5kVmFsdWUpO1xuICAgICAgLy8gcGVyY2VudFdpbmRvd1tpZHhdID0gcm91bmQoYm91bmRQZXJjZW50KTtcblxuXG4gICAgICB2YWx1ZVdpbmRvd1tpZHhdID0gYm91bmRWYWx1ZTtcbiAgICAgIHBlcmNlbnRXaW5kb3dbaWR4XSA9IGJvdW5kUGVyY2VudDtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVXaW5kb3c6IGFzYyh2YWx1ZVdpbmRvdyksXG4gICAgICBwZXJjZW50V2luZG93OiBhc2MocGVyY2VudFdpbmRvdylcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBOb3RpY2U6IHJlc2V0IHNob3VsZCBub3QgYmUgY2FsbGVkIGJlZm9yZSBzZXJpZXMucmVzdG9yZURhdGEoKSBjYWxsZWQsXG4gICAqIHNvIGl0IGlzIHJlY29tbWFuZGVkIHRvIGJlIGNhbGxlZCBpbiBcInByb2Nlc3Mgc3RhZ2VcIiBidXQgbm90IFwibW9kZWwgaW5pdFxuICAgKiBzdGFnZVwiLlxuICAgKlxuICAgKiBAcGFyYW0ge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH0gZGF0YVpvb21Nb2RlbFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgaWYgKGRhdGFab29tTW9kZWwgIT09IHRoaXMuX2RhdGFab29tTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEN1bGN1bGF0ZSBkYXRhIHdpbmRvdyBhbmQgZGF0YSBleHRlbnQsIGFuZCByZWNvcmQgdGhlbS5cblxuXG4gICAgdGhpcy5fZGF0YUV4dGVudCA9IGNhbGN1bGF0ZURhdGFFeHRlbnQodGhpcywgdGhpcy5fZGltTmFtZSwgdGhpcy5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKSk7XG4gICAgdmFyIGRhdGFXaW5kb3cgPSB0aGlzLmNhbGN1bGF0ZURhdGFXaW5kb3coZGF0YVpvb21Nb2RlbC5vcHRpb24pO1xuICAgIHRoaXMuX3ZhbHVlV2luZG93ID0gZGF0YVdpbmRvdy52YWx1ZVdpbmRvdztcbiAgICB0aGlzLl9wZXJjZW50V2luZG93ID0gZGF0YVdpbmRvdy5wZXJjZW50V2luZG93O1xuICAgIHNldE1pbk1heFNwYW4odGhpcyk7IC8vIFVwZGF0ZSBheGlzIHNldHRpbmcgdGhlbi5cblxuICAgIHNldEF4aXNNb2RlbCh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICovXG4gIHJlc3RvcmU6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgaWYgKGRhdGFab29tTW9kZWwgIT09IHRoaXMuX2RhdGFab29tTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZVdpbmRvdyA9IHRoaXMuX3BlcmNlbnRXaW5kb3cgPSBudWxsO1xuICAgIHNldEF4aXNNb2RlbCh0aGlzLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICovXG4gIGZpbHRlckRhdGE6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgaWYgKGRhdGFab29tTW9kZWwgIT09IHRoaXMuX2RhdGFab29tTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXhpc0RpbSA9IHRoaXMuX2RpbU5hbWU7XG4gICAgdmFyIHNlcmllc01vZGVscyA9IHRoaXMuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCk7XG4gICAgdmFyIGZpbHRlck1vZGUgPSBkYXRhWm9vbU1vZGVsLmdldCgnZmlsdGVyTW9kZScpO1xuICAgIHZhciB2YWx1ZVdpbmRvdyA9IHRoaXMuX3ZhbHVlV2luZG93O1xuXG4gICAgaWYgKGZpbHRlck1vZGUgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRklYTUVcbiAgICAvLyBUb29sYm94IG1heSBoYXMgZGF0YVpvb20gaW5qZWN0ZWQuIEFuZCBpZiB0aGVyZSBhcmUgc3RhY2tlZCBiYXIgY2hhcnRcbiAgICAvLyB3aXRoIE5hTiBkYXRhLCBOYU4gd2lsbCBiZSBmaWx0ZXJlZCBhbmQgc3RhY2sgd2lsbCBiZSB3cm9uZy5cbiAgICAvLyBTbyB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBtb2RlIHRvIGJlIHNldCBlbXB0eS5cbiAgICAvLyBJbiBmZWN0LCBpdCBpcyBub3QgYSBiaWcgZGVhbCB0aGF0IGRvIG5vdCBzdXBwb3J0IGZpbHRlck1vZGUtJ2ZpbHRlcidcbiAgICAvLyB3aGVuIHVzaW5nIHRvb2xib3gjZGF0YVpvb20sIHV0aWxsIHRvb2x0aXAjZGF0YVpvb20gc3VwcG9ydCBcInNpbmdsZSBheGlzXG4gICAgLy8gc2VsZWN0aW9uXCIgc29tZSBkYXksIHdoaWNoIG1pZ2h0IG5lZWQgXCJhZGFwdCB0byBkYXRhIGV4dGVudCBvbiB0aGVcbiAgICAvLyBvdGhlckF4aXNcIiwgd2hpY2ggaXMgZGlzYWJsZWQgYnkgZmlsdGVyTW9kZS0nZW1wdHknLlxuXG5cbiAgICB2YXIgb3RoZXJBeGlzTW9kZWwgPSB0aGlzLmdldE90aGVyQXhpc01vZGVsKCk7XG5cbiAgICBpZiAoZGF0YVpvb21Nb2RlbC5nZXQoJyRmcm9tVG9vbGJveCcpICYmIG90aGVyQXhpc01vZGVsICYmIG90aGVyQXhpc01vZGVsLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICBmaWx0ZXJNb2RlID0gJ2VtcHR5JztcbiAgICB9IC8vIFByb2Nlc3Mgc2VyaWVzIGRhdGFcblxuXG4gICAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIHNlcmllc0RhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgZGF0YURpbXMgPSBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShheGlzRGltKTtcblxuICAgICAgaWYgKGZpbHRlck1vZGUgPT09ICd3ZWFrRmlsdGVyJykge1xuICAgICAgICBzZXJpZXNEYXRhICYmIHNlcmllc0RhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgdmFyIGxlZnRPdXQ7XG4gICAgICAgICAgdmFyIHJpZ2h0T3V0O1xuICAgICAgICAgIHZhciBoYXNWYWx1ZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YURpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlcmllc0RhdGEuZ2V0KGRhdGFEaW1zW2ldLCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHRoaXNIYXNWYWx1ZSA9ICFpc05hTih2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgdGhpc0xlZnRPdXQgPSB2YWx1ZSA8IHZhbHVlV2luZG93WzBdO1xuICAgICAgICAgICAgdmFyIHRoaXNSaWdodE91dCA9IHZhbHVlID4gdmFsdWVXaW5kb3dbMV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzSGFzVmFsdWUgJiYgIXRoaXNMZWZ0T3V0ICYmICF0aGlzUmlnaHRPdXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNIYXNWYWx1ZSAmJiAoaGFzVmFsdWUgPSB0cnVlKTtcbiAgICAgICAgICAgIHRoaXNMZWZ0T3V0ICYmIChsZWZ0T3V0ID0gdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzUmlnaHRPdXQgJiYgKHJpZ2h0T3V0ID0gdHJ1ZSk7XG4gICAgICAgICAgfSAvLyBJZiBib3RoIGxlZnQgb3V0IGFuZCByaWdodCBvdXQsIGRvIG5vdCBmaWx0ZXIuXG5cblxuICAgICAgICAgIHJldHVybiBoYXNWYWx1ZSAmJiBsZWZ0T3V0ICYmIHJpZ2h0T3V0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmllc0RhdGEgJiYgZWFjaChkYXRhRGltcywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnZW1wdHknKSB7XG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5zZXREYXRhKHNlcmllc0RhdGEubWFwKGRpbSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhaXNJbldpbmRvdyh2YWx1ZSkgPyBOYU4gOiB2YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VyaWVzRGF0YS5maWx0ZXJTZWxmKGRpbSwgaXNJbldpbmRvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzSW5XaW5kb3codmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSB2YWx1ZVdpbmRvd1swXSAmJiB2YWx1ZSA8PSB2YWx1ZVdpbmRvd1sxXTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURhdGFFeHRlbnQoYXhpc1Byb3h5LCBheGlzRGltLCBzZXJpZXNNb2RlbHMpIHtcbiAgdmFyIGRhdGFFeHRlbnQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIGVhY2goc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgIGlmIChzZXJpZXNEYXRhKSB7XG4gICAgICBlYWNoKHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGF4aXNEaW0pLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHZhciBzZXJpZXNFeHRlbnQgPSBzZXJpZXNEYXRhLmdldERhdGFFeHRlbnQoZGltKTtcbiAgICAgICAgc2VyaWVzRXh0ZW50WzBdIDwgZGF0YUV4dGVudFswXSAmJiAoZGF0YUV4dGVudFswXSA9IHNlcmllc0V4dGVudFswXSk7XG4gICAgICAgIHNlcmllc0V4dGVudFsxXSA+IGRhdGFFeHRlbnRbMV0gJiYgKGRhdGFFeHRlbnRbMV0gPSBzZXJpZXNFeHRlbnRbMV0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGF0YUV4dGVudFsxXSA8IGRhdGFFeHRlbnRbMF0pIHtcbiAgICBkYXRhRXh0ZW50ID0gW05hTiwgTmFOXTtcbiAgfSAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gZ2V0IFwiY29uc2lzdGVudFwiIGV4dGVudCB3aGVuIG1vcmUgdGhlbiBvbmUgYXhlcyBpc1xuICAvLyBjb250cm9sbGVkIGJ5IGEgYGRhdGFab29tYCwgb3RoZXJ3aXNlIHRob3NlIGF4ZXMgd2lsbCBub3QgYmUgc3luY2hyb25pemVkXG4gIC8vIHdoZW4gem9vbWluZy4gQnV0IGl0IGlzIGRpZmZpY3VsdCB0byBrbm93IHdoYXQgaXMgXCJjb25zaXN0ZW50XCIsIGNvbnNpZGVyaW5nXG4gIC8vIGF4ZXMgaGF2ZSBkaWZmZXJlbnQgdHlwZSBvciBldmVuIGRpZmZlcmVudCBtZWFuaW5ncyAoRm9yIGV4YW1wbGUsIHR3b1xuICAvLyB0aW1lIGF4ZXMgYXJlIHVzZWQgdG8gY29tcGFyZSBkYXRhIG9mIHRoZSBzYW1lIGRhdGUgaW4gZGlmZmVyZW50IHllYXJzKS5cbiAgLy8gU28gYmFzaWNhbGx5IGRhdGFab29tIGp1c3Qgb2J0YWlucyBleHRlbnQgYnkgc2VyaWVzLmRhdGEgKGluIGNhdGVnb3J5IGF4aXNcbiAgLy8gZXh0ZW50IGNhbiBiZSBvYnRhaW5lZCBmcm9tIGF4aXMuZGF0YSkuXG4gIC8vIE5ldmVydGhlbGVzcywgdXNlciBjYW4gc2V0IG1pbi9tYXgvc2NhbGUgb24gYXhlcyB0byBtYWtlIGV4dGVudCBvZiBheGVzXG4gIC8vIGNvbnNpc3RlbnQuXG5cblxuICBmaXhFeHRlbnRCeUF4aXMoYXhpc1Byb3h5LCBkYXRhRXh0ZW50KTtcbiAgcmV0dXJuIGRhdGFFeHRlbnQ7XG59XG5cbmZ1bmN0aW9uIGZpeEV4dGVudEJ5QXhpcyhheGlzUHJveHksIGRhdGFFeHRlbnQpIHtcbiAgdmFyIGF4aXNNb2RlbCA9IGF4aXNQcm94eS5nZXRBeGlzTW9kZWwoKTtcbiAgdmFyIG1pbiA9IGF4aXNNb2RlbC5nZXRNaW4odHJ1ZSk7IC8vIEZvciBjYXRlZ29yeSBheGlzLCBpZiBtaW4vbWF4L3NjYWxlIGFyZSBub3Qgc2V0LCBleHRlbnQgaXMgZGV0ZXJtaW5lZFxuICAvLyBieSBheGlzLmRhdGEgYnkgZGVmYXVsdC5cblxuICB2YXIgaXNDYXRlZ29yeUF4aXMgPSBheGlzTW9kZWwuZ2V0KCd0eXBlJykgPT09ICdjYXRlZ29yeSc7XG4gIHZhciBheGlzRGF0YUxlbiA9IGlzQ2F0ZWdvcnlBeGlzICYmIChheGlzTW9kZWwuZ2V0KCdkYXRhJykgfHwgW10pLmxlbmd0aDtcblxuICBpZiAobWluICE9IG51bGwgJiYgbWluICE9PSAnZGF0YU1pbicgJiYgdHlwZW9mIG1pbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGFFeHRlbnRbMF0gPSBtaW47XG4gIH0gZWxzZSBpZiAoaXNDYXRlZ29yeUF4aXMpIHtcbiAgICBkYXRhRXh0ZW50WzBdID0gYXhpc0RhdGFMZW4gPiAwID8gMCA6IE5hTjtcbiAgfVxuXG4gIHZhciBtYXggPSBheGlzTW9kZWwuZ2V0TWF4KHRydWUpO1xuXG4gIGlmIChtYXggIT0gbnVsbCAmJiBtYXggIT09ICdkYXRhTWF4JyAmJiB0eXBlb2YgbWF4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YUV4dGVudFsxXSA9IG1heDtcbiAgfSBlbHNlIGlmIChpc0NhdGVnb3J5QXhpcykge1xuICAgIGRhdGFFeHRlbnRbMV0gPSBheGlzRGF0YUxlbiA+IDAgPyBheGlzRGF0YUxlbiAtIDEgOiBOYU47XG4gIH1cblxuICBpZiAoIWF4aXNNb2RlbC5nZXQoJ3NjYWxlJywgdHJ1ZSkpIHtcbiAgICBkYXRhRXh0ZW50WzBdID4gMCAmJiAoZGF0YUV4dGVudFswXSA9IDApO1xuICAgIGRhdGFFeHRlbnRbMV0gPCAwICYmIChkYXRhRXh0ZW50WzFdID0gMCk7XG4gIH0gLy8gRm9yIHZhbHVlIGF4aXMsIGlmIG1pbi9tYXgvc2NhbGUgYXJlIG5vdCBzZXQsIHdlIGp1c3QgdXNlIHRoZSBleHRlbnQgb2J0YWluZWRcbiAgLy8gYnkgc2VyaWVzIGRhdGEsIHdoaWNoIG1heSBiZSBhIGxpdHRsZSBkaWZmZXJlbnQgZnJvbSB0aGUgZXh0ZW50IGNhbGN1bGF0ZWQgYnlcbiAgLy8gYGF4aXNIZWxwZXIuZ2V0U2NhbGVFeHRlbnRgLiBCdXQgdGhlIGRpZmZlcmVudCBqdXN0IGFmZmVjdHMgdGhlIGV4cGVyaWVuY2UgYVxuICAvLyBsaXR0bGUgd2hlbiB6b29taW5nLiBTbyBpdCB3aWxsIG5vdCBiZSBmaXhlZCB1bnRpbCBzb21lIHVzZXJzIHJlcXVpcmUgaXQgc3Ryb25nbHkuXG5cblxuICByZXR1cm4gZGF0YUV4dGVudDtcbn1cblxuZnVuY3Rpb24gc2V0QXhpc01vZGVsKGF4aXNQcm94eSwgaXNSZXN0b3JlKSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzUHJveHkuZ2V0QXhpc01vZGVsKCk7XG4gIHZhciBwZXJjZW50V2luZG93ID0gYXhpc1Byb3h5Ll9wZXJjZW50V2luZG93O1xuICB2YXIgdmFsdWVXaW5kb3cgPSBheGlzUHJveHkuX3ZhbHVlV2luZG93O1xuXG4gIGlmICghcGVyY2VudFdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfSAvLyBbMCwgNTAwXTogYXJiaXRyYXJ5IHZhbHVlLCBndWVzcyBheGlzIGV4dGVudC5cblxuXG4gIHZhciBwcmVjaXNpb24gPSBudW1iZXJVdGlsLmdldFBpeGVsUHJlY2lzaW9uKHZhbHVlV2luZG93LCBbMCwgNTAwXSk7XG4gIHByZWNpc2lvbiA9IE1hdGgubWluKHByZWNpc2lvbiwgMjApOyAvLyBpc1Jlc3RvcmUgb3IgaXNGdWxsXG5cbiAgdmFyIHVzZU9yaWdpbiA9IGlzUmVzdG9yZSB8fCBwZXJjZW50V2luZG93WzBdID09PSAwICYmIHBlcmNlbnRXaW5kb3dbMV0gPT09IDEwMDtcbiAgYXhpc01vZGVsLnNldFJhbmdlKHVzZU9yaWdpbiA/IG51bGwgOiArdmFsdWVXaW5kb3dbMF0udG9GaXhlZChwcmVjaXNpb24pLCB1c2VPcmlnaW4gPyBudWxsIDogK3ZhbHVlV2luZG93WzFdLnRvRml4ZWQocHJlY2lzaW9uKSk7XG59XG5cbmZ1bmN0aW9uIHNldE1pbk1heFNwYW4oYXhpc1Byb3h5KSB7XG4gIHZhciBtaW5NYXhTcGFuID0gYXhpc1Byb3h5Ll9taW5NYXhTcGFuID0ge307XG4gIHZhciBkYXRhWm9vbU1vZGVsID0gYXhpc1Byb3h5Ll9kYXRhWm9vbU1vZGVsO1xuICBlYWNoKFsnbWluJywgJ21heCddLCBmdW5jdGlvbiAobWluTWF4KSB7XG4gICAgbWluTWF4U3BhblttaW5NYXggKyAnU3BhbiddID0gZGF0YVpvb21Nb2RlbC5nZXQobWluTWF4ICsgJ1NwYW4nKTsgLy8gbWluVmFsdWVTcGFuIGFuZCBtYXhWYWx1ZVNwYW4gaGFzIGhpZ2hlciBwcmlvcml0eSB0aGFuIG1pblNwYW4gYW5kIG1heFNwYW5cblxuICAgIHZhciB2YWx1ZVNwYW4gPSBkYXRhWm9vbU1vZGVsLmdldChtaW5NYXggKyAnVmFsdWVTcGFuJyk7XG5cbiAgICBpZiAodmFsdWVTcGFuICE9IG51bGwpIHtcbiAgICAgIG1pbk1heFNwYW5bbWluTWF4ICsgJ1ZhbHVlU3BhbiddID0gdmFsdWVTcGFuO1xuICAgICAgdmFsdWVTcGFuID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpLmF4aXMuc2NhbGUucGFyc2UodmFsdWVTcGFuKTtcblxuICAgICAgaWYgKHZhbHVlU3BhbiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkYXRhRXh0ZW50ID0gYXhpc1Byb3h5Ll9kYXRhRXh0ZW50O1xuICAgICAgICBtaW5NYXhTcGFuW21pbk1heCArICdTcGFuJ10gPSBudW1iZXJVdGlsLmxpbmVhck1hcChkYXRhRXh0ZW50WzBdICsgdmFsdWVTcGFuLCBkYXRhRXh0ZW50LCBbMCwgMTAwXSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gQXhpc1Byb3h5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vQXhpc1Byb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vQXhpc1Byb3h5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxudmFyIEF4aXNQcm94eSA9IHJlcXVpcmUoXCIuL0F4aXNQcm94eVwiKTtcblxudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBlYWNoQXhpc0RpbSA9IGhlbHBlci5lYWNoQXhpc0RpbTtcbnZhciBEYXRhWm9vbU1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdkYXRhWm9vbScsXG4gIGRlcGVuZGVuY2llczogWyd4QXhpcycsICd5QXhpcycsICd6QXhpcycsICdyYWRpdXNBeGlzJywgJ2FuZ2xlQXhpcycsICdzaW5nbGVBeGlzJywgJ3NlcmllcyddLFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDQsXG4gICAgLy8gSGlnaGVyIHRoYW4gbm9ybWFsIGNvbXBvbmVudCAoejogMikuXG4gICAgb3JpZW50OiBudWxsLFxuICAgIC8vIERlZmF1bHQgYXV0byBieSBheGlzSW5kZXguIFBvc3NpYmxlIHZhbHVlOiAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcuXG4gICAgeEF4aXNJbmRleDogbnVsbCxcbiAgICAvLyBEZWZhdWx0IHRoZSBmaXJzdCBob3Jpem9udGFsIGNhdGVnb3J5IGF4aXMuXG4gICAgeUF4aXNJbmRleDogbnVsbCxcbiAgICAvLyBEZWZhdWx0IHRoZSBmaXJzdCB2ZXJ0aWNhbCBjYXRlZ29yeSBheGlzLlxuICAgIGZpbHRlck1vZGU6ICdmaWx0ZXInLFxuICAgIC8vIFBvc3NpYmxlIHZhbHVlczogJ2ZpbHRlcicgb3IgJ2VtcHR5JyBvciAnd2Vha0ZpbHRlcicuXG4gICAgLy8gJ2ZpbHRlcic6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSByZW1vdmVkLiBUaGlzIG9wdGlvbiBpc1xuICAgIC8vICAgICAgICAgIGFwcGxpY2FibGUgd2hlbiBmaWx0ZXJpbmcgb3V0bGllcnMuIEZvciBlYWNoIGRhdGEgaXRlbSwgaXQgd2lsbCBiZVxuICAgIC8vICAgICAgICAgIGZpbHRlcmVkIGlmIG9uZSBvZiB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBpcyBvdXQgb2YgdGhlIHdpbmRvdy5cbiAgICAvLyAnd2Vha0ZpbHRlcic6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSByZW1vdmVkLiBUaGlzIG9wdGlvblxuICAgIC8vICAgICAgICAgIGlzIGFwcGxpY2FibGUgd2hlbiBmaWx0ZXJpbmcgb3V0bGllcnMuIEZvciBlYWNoIGRhdGEgaXRlbSwgaXQgd2lsbCBiZVxuICAgIC8vICAgICAgICAgIGZpbHRlcmVkIG9ubHkgaWYgYWxsICBvZiB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgb3V0IG9mIHRoZSBzYW1lXG4gICAgLy8gICAgICAgICAgc2lkZSBvZiB0aGUgd2luZG93LlxuICAgIC8vICdlbXB0eSc6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSBzZXQgdG8gZW1wdHkuXG4gICAgLy8gICAgICAgICAgVGhpcyBvcHRpb24gaXMgYXBwbGljYWJsZSB3aGVuIHVzZXIgc2hvdWxkIG5vdCBuZWdsZWN0XG4gICAgLy8gICAgICAgICAgdGhhdCB0aGVyZSBhcmUgc29tZSBkYXRhIGl0ZW1zIG91dCBvZiB3aW5kb3cuXG4gICAgLy8gJ25vbmUnOiBEbyBub3QgZmlsdGVyLlxuICAgIC8vIFRha2luZyBsaW5lIGNoYXJ0IGFzIGFuIGV4YW1wbGUsIGxpbmUgd2lsbCBiZSBicm9rZW4gaW5cbiAgICAvLyB0aGUgZmlsdGVyZWQgcG9pbnRzIHdoZW4gZmlsdGVyTW9kZWwgaXMgc2V0IHRvICdlbXB0eScsIGJ1dFxuICAgIC8vIGJlIGNvbm5lY3RlZCB3aGVuIHNldCB0byAnZmlsdGVyJy5cbiAgICB0aHJvdHRsZTogbnVsbCxcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gYnkgdGhlIGZpeGVkIHJhdGUsIGF2b2lkIGZyZXF1ZW5jeS5cbiAgICAvLyBkZWZhdWx0IDEwMC4gRG8gbm90IHRocm90dGxlIHdoZW4gdXNlIG51bGwvdW5kZWZpbmVkLlxuICAgIC8vIElmIGFuaW1hdGlvbiA9PT0gdHJ1ZSBhbmQgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGUgPiAwLFxuICAgIC8vIGRlZmF1bHQgdmFsdWUgaXMgMTAwLCBvdGhlcndpc2UgMjAuXG4gICAgc3RhcnQ6IDAsXG4gICAgLy8gU3RhcnQgcGVyY2VudC4gMCB+IDEwMFxuICAgIGVuZDogMTAwLFxuICAgIC8vIEVuZCBwZXJjZW50LiAwIH4gMTAwXG4gICAgc3RhcnRWYWx1ZTogbnVsbCxcbiAgICAvLyBTdGFydCB2YWx1ZS4gSWYgc3RhcnRWYWx1ZSBzcGVjaWZpZWQsIHN0YXJ0IGlzIGlnbm9yZWQuXG4gICAgZW5kVmFsdWU6IG51bGwsXG4gICAgLy8gRW5kIHZhbHVlLiBJZiBlbmRWYWx1ZSBzcGVjaWZpZWQsIGVuZCBpcyBpZ25vcmVkLlxuICAgIG1pblNwYW46IG51bGwsXG4gICAgLy8gMCB+IDEwMFxuICAgIG1heFNwYW46IG51bGwsXG4gICAgLy8gMCB+IDEwMFxuICAgIG1pblZhbHVlU3BhbjogbnVsbCxcbiAgICAvLyBUaGUgcmFuZ2Ugb2YgZGF0YVpvb20gY2FuIG5vdCBiZSBzbWFsbGVyIHRoYW4gdGhhdC5cbiAgICBtYXhWYWx1ZVNwYW46IG51bGwsXG4gICAgLy8gVGhlIHJhbmdlIG9mIGRhdGFab29tIGNhbiBub3QgYmUgbGFyZ2VyIHRoYW4gdGhhdC5cbiAgICByYW5nZU1vZGU6IG51bGwgLy8gQXJyYXksIGNhbiBiZSAndmFsdWUnIG9yICdwZXJjZW50Jy5cblxuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgLyoqXG4gICAgICoga2V5IGxpa2UgeF8wLCB5XzFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZGF0YUludGVydmFsQnlBeGlzID0ge307XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2RhdGFJbmZvID0ge307XG4gICAgLyoqXG4gICAgICoga2V5IGxpa2UgeF8wLCB5XzFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fYXhpc1Byb3hpZXMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIHRoaXMudGV4dFN0eWxlTW9kZWw7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2F1dG9UaHJvdHRsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogJ3BlcmNlbnQnIG9yICd2YWx1ZSdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fcmFuZ2VQcm9wTW9kZSA9IFsncGVyY2VudCcsICdwZXJjZW50J107XG4gICAgdmFyIHJhd09wdGlvbiA9IHJldHJpZXZlUmF3KG9wdGlvbik7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIHRoaXMuZG9Jbml0KHJhd09wdGlvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICB2YXIgcmF3T3B0aW9uID0gcmV0cmlldmVSYXcobmV3T3B0aW9uKTsgLy9GSVggIzI1OTFcblxuICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgbmV3T3B0aW9uLCB0cnVlKTtcbiAgICB0aGlzLmRvSW5pdChyYXdPcHRpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkb0luaXQ6IGZ1bmN0aW9uIChyYXdPcHRpb24pIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uOyAvLyBEaXNhYmxlIHJlYWx0aW1lIHZpZXcgdXBkYXRlIGlmIGNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkLlxuXG4gICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzT3B0aW9uLnJlYWx0aW1lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0RGVmYXVsdFRocm90dGxlKHJhd09wdGlvbik7XG5cbiAgICB1cGRhdGVSYW5nZVVzZSh0aGlzLCByYXdPcHRpb24pO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgICAgLy8gc3RhcnQvZW5kIGhhcyBoaWdoZXIgcHJpb3JpdHkgb3ZlciBzdGFydFZhbHVlL2VuZFZhbHVlIGlmIHRoZXlcbiAgICAgIC8vIGJvdGggc2V0LCBidXQgd2Ugc2hvdWxkIG1ha2UgY2hhcnQuc2V0T3B0aW9uKHtlbmRWYWx1ZTogMTAwMH0pXG4gICAgICAvLyBlZmZlY3RpdmUsIHJhdGhlciB0aGFuIGNoYXJ0LnNldE9wdGlvbih7ZW5kVmFsdWU6IDEwMDAsIGVuZDogbnVsbH0pLlxuICAgICAgaWYgKHRoaXMuX3JhbmdlUHJvcE1vZGVbaW5kZXhdID09PSAndmFsdWUnKSB7XG4gICAgICAgIHRoaXNPcHRpb25bbmFtZXNbMF1dID0gbnVsbDtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIGRvIG5vdGhpbmcgYW5kIHVzZSB0aGUgbWVyZ2UgcmVzdWx0LlxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy50ZXh0U3R5bGVNb2RlbCA9IHRoaXMuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuXG4gICAgdGhpcy5fcmVzZXRUYXJnZXQoKTtcblxuICAgIHRoaXMuX2dpdmVBeGlzUHJveGllcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dpdmVBeGlzUHJveGllczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzUHJveGllcyA9IHRoaXMuX2F4aXNQcm94aWVzO1xuICAgIHRoaXMuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGRpbU5hbWVzLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtheGlzSW5kZXhdOyAvLyBJZiBleGlzdHMsIHNoYXJlIGF4aXNQcm94eSB3aXRoIG90aGVyIGRhdGFab29tTW9kZWxzLlxuXG4gICAgICB2YXIgYXhpc1Byb3h5ID0gYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgfHwgKCAvLyBVc2UgdGhlIGZpcnN0IGRhdGFab29tTW9kZWwgYXMgdGhlIG1haW4gbW9kZWwgb2YgYXhpc1Byb3h5LlxuICAgICAgYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgPSBuZXcgQXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCwgdGhpcywgZWNNb2RlbCkpOyAvLyBGSVhNRVxuICAgICAgLy8gZGlzcG9zZSBfX2R6QXhpc1Byb3h5XG5cbiAgICAgIGF4aXNQcm94aWVzW2RpbU5hbWVzLm5hbWUgKyAnXycgKyBheGlzSW5kZXhdID0gYXhpc1Byb3h5O1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0VGFyZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcblxuICAgIHZhciBhdXRvTW9kZSA9IHRoaXMuX2p1ZGdlQXV0b01vZGUoKTtcblxuICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgdmFyIGF4aXNJbmRleE5hbWUgPSBkaW1OYW1lcy5heGlzSW5kZXg7XG4gICAgICB0aGlzT3B0aW9uW2F4aXNJbmRleE5hbWVdID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkodGhpc09wdGlvbltheGlzSW5kZXhOYW1lXSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoYXV0b01vZGUgPT09ICdheGlzSW5kZXgnKSB7XG4gICAgICB0aGlzLl9hdXRvU2V0QXhpc0luZGV4KCk7XG4gICAgfSBlbHNlIGlmIChhdXRvTW9kZSA9PT0gJ29yaWVudCcpIHtcbiAgICAgIHRoaXMuX2F1dG9TZXRPcmllbnQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfanVkZ2VBdXRvTW9kZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIEF1dG8gc2V0IG9ubHkgd29ya3MgZm9yIHNldE9wdGlvbiBhdCB0aGUgZmlyc3QgdGltZS5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIHVzZXIncyByZXBvbnNpYmlsaXR5LiBTbyB1c2luZyBtZXJnZWRcbiAgICAvLyBvcHRpb24gaXMgT0suXG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgaGFzSW5kZXhTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgIC8vIFdoZW4gdXNlciBzZXQgYXhpc0luZGV4IGFzIGEgZW1wdHkgYXJyYXksIHdlIHRoaW5rIHRoYXQgdXNlciBzcGVjaWZ5IGF4aXNJbmRleFxuICAgICAgLy8gYnV0IGRvIG5vdCB3YW50IHVzZSBhdXRvIG1vZGUuIEJlY2F1c2UgZW1wdHkgYXJyYXkgbWF5IGJlIGVuY291bnRlcmVkIHdoZW5cbiAgICAgIC8vIHNvbWUgZXJyb3Igb2NjdXJlZC5cbiAgICAgIGlmICh0aGlzT3B0aW9uW2RpbU5hbWVzLmF4aXNJbmRleF0gIT0gbnVsbCkge1xuICAgICAgICBoYXNJbmRleFNwZWNpZmllZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdmFyIG9yaWVudCA9IHRoaXNPcHRpb24ub3JpZW50O1xuXG4gICAgaWYgKG9yaWVudCA9PSBudWxsICYmIGhhc0luZGV4U3BlY2lmaWVkKSB7XG4gICAgICByZXR1cm4gJ29yaWVudCc7XG4gICAgfSBlbHNlIGlmICghaGFzSW5kZXhTcGVjaWZpZWQpIHtcbiAgICAgIGlmIChvcmllbnQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzT3B0aW9uLm9yaWVudCA9ICdob3Jpem9udGFsJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdheGlzSW5kZXgnO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hdXRvU2V0QXhpc0luZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF1dG9BeGlzSW5kZXggPSB0cnVlO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLmdldCgnb3JpZW50JywgdHJ1ZSk7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgZGVwZW5kZW50TW9kZWxzID0gdGhpcy5kZXBlbmRlbnRNb2RlbHM7XG5cbiAgICBpZiAoYXV0b0F4aXNJbmRleCkge1xuICAgICAgLy8gRmluZCBheGlzIHRoYXQgcGFyYWxsZWwgdG8gZGF0YVpvb20gYXMgZGVmYXVsdC5cbiAgICAgIHZhciBkaW1OYW1lID0gb3JpZW50ID09PSAndmVydGljYWwnID8gJ3knIDogJ3gnO1xuXG4gICAgICBpZiAoZGVwZW5kZW50TW9kZWxzW2RpbU5hbWUgKyAnQXhpcyddLmxlbmd0aCkge1xuICAgICAgICB0aGlzT3B0aW9uW2RpbU5hbWUgKyAnQXhpc0luZGV4J10gPSBbMF07XG4gICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goZGVwZW5kZW50TW9kZWxzLnNpbmdsZUF4aXMsIGZ1bmN0aW9uIChzaW5nbGVBeGlzTW9kZWwpIHtcbiAgICAgICAgICBpZiAoYXV0b0F4aXNJbmRleCAmJiBzaW5nbGVBeGlzTW9kZWwuZ2V0KCdvcmllbnQnLCB0cnVlKSA9PT0gb3JpZW50KSB7XG4gICAgICAgICAgICB0aGlzT3B0aW9uLnNpbmdsZUF4aXNJbmRleCA9IFtzaW5nbGVBeGlzTW9kZWwuY29tcG9uZW50SW5kZXhdO1xuICAgICAgICAgICAgYXV0b0F4aXNJbmRleCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGNhdGVnb3J5IGF4aXMgYXMgZGVmYXVsdC4gKGNvbnNpZGVyIHBvbGFyKVxuICAgICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICAgIGlmICghYXV0b0F4aXNJbmRleCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGlzSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgYXhpc01vZGVscyA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdO1xuXG4gICAgICAgIGlmIChheGlzTW9kZWxzLmxlbmd0aCAmJiAhYXhpc0luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF4aXNNb2RlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChheGlzTW9kZWxzW2ldLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgICAgIGF4aXNJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpc09wdGlvbltkaW1OYW1lcy5heGlzSW5kZXhdID0gYXhpc0luZGljZXM7XG5cbiAgICAgICAgaWYgKGF4aXNJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyDov5nph4zmmK/lhbzlrrllYzLnmoTlhpnms5XvvIjmsqHmjIflrpp4QXhpc0luZGV45ZKMeUF4aXNJbmRleOaXtuaKinNjYXR0ZXLlkozlj4zmlbDlgLzovbTmipjmn7HnurPlhaVkYXRhWm9vbeaOp+WItu+8ie+8jFxuICAgICAgLy8g5L2G5piv5a6e6ZmF5piv5ZCm6ZyA6KaBR3JpZC5qcyNnZXRTY2FsZUJ5T3B0aW9u5p2l5Yik5pat77yI6ICD6JmRdGltZe+8jGxvZ+etiWF4aXMgdHlwZe+8ie+8n1xuICAgICAgLy8gSWYgYm90aCBkYXRhWm9vbS54QXhpc0luZGV4IGFuZCBkYXRhWm9vbS55QXhpc0luZGV4IGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICAvLyBkYXRhWm9vbSBjb21wb25lbnQgYXV0byBhZG9wdHMgc2VyaWVzIHRoYXQgcmVmZXJlbmNlIHRvXG4gICAgICAvLyBib3RoIHhBeGlzIGFuZCB5QXhpcyB3aGljaCB0eXBlIGlzICd2YWx1ZScuXG4gICAgICB0aGlzLmVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VyaWVzSGFzQWxsQXhlc1R5cGVPZihzZXJpZXNNb2RlbCwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBheGlzSW5kaWNlcyA9IHRoaXNPcHRpb25bZGltTmFtZXMuYXhpc0luZGV4XTtcbiAgICAgICAgICAgIHZhciBheGlzSW5kZXggPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0luZGV4KTtcbiAgICAgICAgICAgIHZhciBheGlzSWQgPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0lkKTtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5lY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgIG1haW5UeXBlOiBkaW1OYW1lcy5heGlzLFxuICAgICAgICAgICAgICBpbmRleDogYXhpc0luZGV4LFxuICAgICAgICAgICAgICBpZDogYXhpc0lkXG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIGF4aXNJbmRleCA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcblxuICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKGF4aXNJbmRpY2VzLCBheGlzSW5kZXgpIDwgMCkge1xuICAgICAgICAgICAgICBheGlzSW5kaWNlcy5wdXNoKGF4aXNJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hdXRvU2V0T3JpZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRpbTsgLy8gRmluZCB0aGUgZmlyc3QgYXhpc1xuXG4gICAgdGhpcy5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICFkaW0gJiYgKGRpbSA9IGRpbU5hbWVzLm5hbWUpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMub3B0aW9uLm9yaWVudCA9IGRpbSA9PT0gJ3knID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc1Nlcmllc0hhc0FsbEF4ZXNUeXBlT2Y6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgYXhpc1R5cGUpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIOmcgOimgXNlcmllc+eahHhBeGlzSW5kZXjlkox5QXhpc0luZGV46YO96aaW5YWI6Ieq5Yqo6K6+572u5LiK44CCXG4gICAgLy8g5L6L5aaCc2VyaWVzLnR5cGUgPT09IHNjYXR0ZXLml7bjgIJcbiAgICB2YXIgaXMgPSB0cnVlO1xuICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgdmFyIHNlcmllc0F4aXNJbmRleCA9IHNlcmllc01vZGVsLmdldChkaW1OYW1lcy5heGlzSW5kZXgpO1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdW3Nlcmllc0F4aXNJbmRleF07XG5cbiAgICAgIGlmICghYXhpc01vZGVsIHx8IGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSAhPT0gYXhpc1R5cGUpIHtcbiAgICAgICAgaXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0RGVmYXVsdFRocm90dGxlOiBmdW5jdGlvbiAocmF3T3B0aW9uKSB7XG4gICAgLy8gV2hlbiBmaXJzdCB0aW1lIHVzZXIgc2V0IHRocm90dGxlLCBhdXRvIHRocm90dGxlIGVuZHMuXG4gICAgaWYgKHJhd09wdGlvbi5oYXNPd25Qcm9wZXJ0eSgndGhyb3R0bGUnKSkge1xuICAgICAgdGhpcy5fYXV0b1Rocm90dGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2F1dG9UaHJvdHRsZSkge1xuICAgICAgdmFyIGdsb2JhbE9wdGlvbiA9IHRoaXMuZWNNb2RlbC5vcHRpb247XG4gICAgICB0aGlzLm9wdGlvbi50aHJvdHRsZSA9IGdsb2JhbE9wdGlvbi5hbmltYXRpb24gJiYgZ2xvYmFsT3B0aW9uLmFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlID4gMCA/IDEwMCA6IDIwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0Rmlyc3RUYXJnZXRBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlyc3RBeGlzTW9kZWw7XG4gICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICBpZiAoZmlyc3RBeGlzTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCk7XG5cbiAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZmlyc3RBeGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtpbmRpY2VzWzBdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBmaXJzdEF4aXNNb2RlbDtcbiAgfSxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBwYXJhbTogYXhpc01vZGVsLCBkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsLCBlY01vZGVsXG4gICAqL1xuICBlYWNoVGFyZ2V0QXhpczogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICBlYWNoKHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCksIGZ1bmN0aW9uIChheGlzSW5kZXgpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBkaW1OYW1lcywgYXhpc0luZGV4LCB0aGlzLCBlY01vZGVsKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltTmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHl9IElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0QXhpc1Byb3h5OiBmdW5jdGlvbiAoZGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2F4aXNQcm94aWVzW2RpbU5hbWUgKyAnXycgKyBheGlzSW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltTmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBJZiBub3QgZm91bmQsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAgICovXG4gIGdldEF4aXNNb2RlbDogZnVuY3Rpb24gKGRpbU5hbWUsIGF4aXNJbmRleCkge1xuICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmdldEF4aXNQcm94eShkaW1OYW1lLCBheGlzSW5kZXgpO1xuICAgIHJldHVybiBheGlzUHJveHkgJiYgYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBzZXQgdG8gdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuZF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRWYWx1ZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kVmFsdWVdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVVwZGF0ZVJhbmdlVXNnPWZhbHNlXVxuICAgKi9cbiAgc2V0UmF3UmFuZ2U6IGZ1bmN0aW9uIChvcHQsIGlnbm9yZVVwZGF0ZVJhbmdlVXNnKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAvLyBJZiBvbmx5IG9uZSBvZiAnc3RhcnQnIGFuZCAnc3RhcnRWYWx1ZScgaXMgbm90IG51bGwvdW5kZWZpbmVkLCB0aGUgb3RoZXJcbiAgICAgIC8vIHNob3VsZCBiZSBjbGVhcmVkLCB3aGljaCBlbmFibGUgY2xlYXIgdGhlIG9wdGlvbi5cbiAgICAgIC8vIElmIGJvdGggb2YgdGhlbSBhcmUgbm90IHNldCwga2VlcCBvcHRpb24gd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUsIHdoaWNoXG4gICAgICAvLyBlbmFibGUgdXNlIG9ubHkgc2V0IHN0YXJ0IGJ1dCBub3Qgc2V0IGVuZCB3aGVuIGNhbGxpbmcgYGRpc3BhdGNoQWN0aW9uYC5cbiAgICAgIC8vIFRoZSBzYW1lIGFzICdlbmQnIGFuZCAnZW5kVmFsdWUnLlxuICAgICAgaWYgKG9wdFtuYW1lc1swXV0gIT0gbnVsbCB8fCBvcHRbbmFtZXNbMV1dICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9uW25hbWVzWzBdXSA9IG9wdFtuYW1lc1swXV07XG4gICAgICAgIG9wdGlvbltuYW1lc1sxXV0gPSBvcHRbbmFtZXNbMV1dO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgICFpZ25vcmVVcGRhdGVSYW5nZVVzZyAmJiB1cGRhdGVSYW5nZVVzZSh0aGlzLCBvcHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbc3RhcnRQZXJjZW50LCBlbmRQZXJjZW50XVxuICAgKi9cbiAgZ2V0UGVyY2VudFJhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF4aXNQcm94eSA9IHRoaXMuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG5cbiAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICByZXR1cm4gYXhpc1Byb3h5LmdldERhdGFQZXJjZW50V2luZG93KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEZvciBleGFtcGxlLCBjaGFydC5nZXRNb2RlbCgpLmdldENvbXBvbmVudCgnZGF0YVpvb20nKS5nZXRWYWx1ZVJhbmdlKCd5JywgMCk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXhpc0RpbU5hbWVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXhpc0luZGV4XVxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3N0YXJ0VmFsdWUsIGVuZFZhbHVlXSB2YWx1ZSBjYW4gb25seSBiZSAnLScgb3IgZmluaXRlIG51bWJlci5cbiAgICovXG4gIGdldFZhbHVlUmFuZ2U6IGZ1bmN0aW9uIChheGlzRGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgaWYgKGF4aXNEaW1OYW1lID09IG51bGwgJiYgYXhpc0luZGV4ID09IG51bGwpIHtcbiAgICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuXG4gICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF4aXNQcm94eShheGlzRGltTmFtZSwgYXhpc0luZGV4KS5nZXREYXRhVmFsdWVXaW5kb3coKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2F4aXNNb2RlbF0gSWYgYXhpc01vZGVsIGdpdmVuLCBmaW5kIGF4aXNQcm94eVxuICAgKiAgICAgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGF4aXNNb2RlbFxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vQXhpc1Byb3h5fVxuICAgKi9cbiAgZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5OiBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgaWYgKGF4aXNNb2RlbCkge1xuICAgICAgcmV0dXJuIGF4aXNNb2RlbC5fX2R6QXhpc1Byb3h5O1xuICAgIH0gLy8gRmluZCB0aGUgZmlyc3QgaG9zdGVkIGF4aXNQcm94eVxuXG5cbiAgICB2YXIgYXhpc1Byb3hpZXMgPSB0aGlzLl9heGlzUHJveGllcztcblxuICAgIGZvciAodmFyIGtleSBpbiBheGlzUHJveGllcykge1xuICAgICAgaWYgKGF4aXNQcm94aWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5vIGhvc3RlZCBheGlzIGZpbmQgbm90IGhvc3RlZCBheGlzUHJveHkuXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiBkYXRhWm9vbU1vZGVsMSBhbmQgZGF0YVpvb21Nb2RlbDIgY29udHJvbCB0aGUgc2FtZSBheGlzLFxuICAgIC8vIGFuZCB0aGUgb3B0aW9uLnN0YXJ0IG9yIG9wdGlvbi5lbmQgc2V0dGluZ3MgYXJlIGRpZmZlcmVudC4gVGhlIHBlcmNlbnRSYW5nZVxuICAgIC8vIHNob3VsZCBmb2xsb3cgYXhpc1Byb3h5LlxuICAgIC8vIChXZSBlbmNvdW50ZXIgdGhpcyBwcm9ibGVtIGluIHRvb2xib3ggZGF0YSB6b29tLilcblxuXG4gICAgZm9yICh2YXIga2V5IGluIGF4aXNQcm94aWVzKSB7XG4gICAgICBpZiAoYXhpc1Byb3hpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0UmFuZ2VQcm9wTW9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5nZVByb3BNb2RlLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiByZXRyaWV2ZVJhdyhvcHRpb24pIHtcbiAgdmFyIHJldCA9IHt9O1xuICBlYWNoKFsnc3RhcnQnLCAnZW5kJywgJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnLCAndGhyb3R0bGUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBvcHRpb24uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKHJldFtuYW1lXSA9IG9wdGlvbltuYW1lXSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSYW5nZVVzZShkYXRhWm9vbU1vZGVsLCByYXdPcHRpb24pIHtcbiAgdmFyIHJhbmdlUHJvcE1vZGUgPSBkYXRhWm9vbU1vZGVsLl9yYW5nZVByb3BNb2RlO1xuICB2YXIgcmFuZ2VNb2RlSW5PcHRpb24gPSBkYXRhWm9vbU1vZGVsLmdldCgncmFuZ2VNb2RlJyk7XG4gIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgIHZhciBwZXJjZW50U3BlY2lmaWVkID0gcmF3T3B0aW9uW25hbWVzWzBdXSAhPSBudWxsO1xuICAgIHZhciB2YWx1ZVNwZWNpZmllZCA9IHJhd09wdGlvbltuYW1lc1sxXV0gIT0gbnVsbDtcblxuICAgIGlmIChwZXJjZW50U3BlY2lmaWVkICYmICF2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAncGVyY2VudCc7XG4gICAgfSBlbHNlIGlmICghcGVyY2VudFNwZWNpZmllZCAmJiB2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAndmFsdWUnO1xuICAgIH0gZWxzZSBpZiAocmFuZ2VNb2RlSW5PcHRpb24pIHtcbiAgICAgIHJhbmdlUHJvcE1vZGVbaW5kZXhdID0gcmFuZ2VNb2RlSW5PcHRpb25baW5kZXhdO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudFNwZWNpZmllZCkge1xuICAgICAgLy8gcGVyY2VudFNwZWNpZmllZCAmJiB2YWx1ZVNwZWNpZmllZFxuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAncGVyY2VudCc7XG4gICAgfSAvLyBlbHNlIHJlbWFpbiBpdHMgb3JpZ2luYWwgc2V0dGluZy5cblxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gRGF0YVpvb21Nb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIENvbXBvbmVudFZpZXcgPSByZXF1aXJlKFwiLi4vLi4vdmlldy9Db21wb25lbnRcIik7XG5cbnZhciBfZGVmYXVsdCA9IENvbXBvbmVudFZpZXcuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFab29tJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdGhpcy5kYXRhWm9vbU1vZGVsID0gZGF0YVpvb21Nb2RlbDtcbiAgICB0aGlzLmVjTW9kZWwgPSBlY01vZGVsO1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBmaXJzdCB0YXJnZXQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSB7XG4gICAqICAgICAgICAgICAgICAgICAgIGdyaWQ6IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQwLCBheGlzTW9kZWxzOiBbYXhpczEsIGF4aXMzXSwgY29vcmRJbmRleDogMX0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB7bW9kZWw6IGNvb3JkMSwgYXhpc01vZGVsczogW2F4aXMwLCBheGlzMl0sIGNvb3JkSW5kZXg6IDB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAqICAgICAgICAgICAgICAgICAgIF0sICAvLyBjYXJ0ZXNpYW5zIG11c3Qgbm90IGJlIG51bGwvdW5kZWZpbmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICBwb2xhcjogW1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtheGlzNF0sIGNvb3JkSW5kZXg6IDB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAqICAgICAgICAgICAgICAgICAgIF0sICAvLyBwb2xhcnMgbXVzdCBub3QgYmUgbnVsbC91bmRlZmluZWQuXG4gICAqICAgICAgICAgICAgICAgICAgIHNpbmdsZUF4aXM6IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQwLCBheGlzTW9kZWxzOiBbXSwgY29vcmRJbmRleDogMH1cbiAgICogICAgICAgICAgICAgICAgICAgXVxuICAgKi9cbiAgZ2V0VGFyZ2V0Q29vcmRJbmZvOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgdmFyIGNvb3JkU3lzTGlzdHMgPSB7fTtcbiAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcywgYXhpc0luZGV4KSB7XG4gICAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoZGltTmFtZXMuYXhpcywgYXhpc0luZGV4KTtcblxuICAgICAgaWYgKGF4aXNNb2RlbCkge1xuICAgICAgICB2YXIgY29vcmRNb2RlbCA9IGF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCk7XG4gICAgICAgIGNvb3JkTW9kZWwgJiYgc2F2ZShjb29yZE1vZGVsLCBheGlzTW9kZWwsIGNvb3JkU3lzTGlzdHNbY29vcmRNb2RlbC5tYWluVHlwZV0gfHwgKGNvb3JkU3lzTGlzdHNbY29vcmRNb2RlbC5tYWluVHlwZV0gPSBbXSksIGNvb3JkTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgZnVuY3Rpb24gc2F2ZShjb29yZE1vZGVsLCBheGlzTW9kZWwsIHN0b3JlLCBjb29yZEluZGV4KSB7XG4gICAgICB2YXIgaXRlbTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RvcmVbaV0ubW9kZWwgPT09IGNvb3JkTW9kZWwpIHtcbiAgICAgICAgICBpdGVtID0gc3RvcmVbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHN0b3JlLnB1c2goaXRlbSA9IHtcbiAgICAgICAgICBtb2RlbDogY29vcmRNb2RlbCxcbiAgICAgICAgICBheGlzTW9kZWxzOiBbXSxcbiAgICAgICAgICBjb29yZEluZGV4OiBjb29yZEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpdGVtLmF4aXNNb2RlbHMucHVzaChheGlzTW9kZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBjb29yZFN5c0xpc3RzO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21WaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21WaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIERhdGFab29tTW9kZWwgPSByZXF1aXJlKFwiLi9EYXRhWm9vbU1vZGVsXCIpO1xuXG52YXIgX2RlZmF1bHQgPSBEYXRhWm9vbU1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhWm9vbS5pbnNpZGUnLFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIC8vIFdoZXRoZXIgZGlzYWJsZSB0aGlzIGluc2lkZSB6b29tLlxuICAgIHpvb21Mb2NrOiBmYWxzZSxcbiAgICAvLyBXaGV0aGVyIGRpc2FibGUgem9vbSBidXQgb25seSBwYW4uXG4gICAgem9vbU9uTW91c2VXaGVlbDogdHJ1ZSxcbiAgICAvLyBDYW4gYmU6IHRydWUgLyBmYWxzZSAvICdzaGlmdCcgLyAnY3RybCcgLyAnYWx0Jy5cbiAgICBtb3ZlT25Nb3VzZU1vdmU6IHRydWUsXG4gICAgLy8gQ2FuIGJlOiB0cnVlIC8gZmFsc2UgLyAnc2hpZnQnIC8gJ2N0cmwnIC8gJ2FsdCcuXG4gICAgcHJldmVudERlZmF1bHRNb3VzZU1vdmU6IHRydWVcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21Nb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21Nb2RlbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgRGF0YVpvb21WaWV3ID0gcmVxdWlyZShcIi4vRGF0YVpvb21WaWV3XCIpO1xuXG52YXIgc2xpZGVyTW92ZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvc2xpZGVyTW92ZVwiKTtcblxudmFyIHJvYW1zID0gcmVxdWlyZShcIi4vcm9hbXNcIik7XG5cbnZhciBiaW5kID0genJVdGlsLmJpbmQ7XG52YXIgSW5zaWRlWm9vbVZpZXcgPSBEYXRhWm9vbVZpZXcuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFab29tLmluc2lkZScsXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIC8qKlxuICAgICAqICd0aHJvdHRsZScgaXMgdXNlZCBpbiB0aGlzLmRpc3BhdGNoQWN0aW9uLCBzbyB3ZSBzYXZlIHJhbmdlXG4gICAgICogdG8gYXZvaWQgbWlzc2luZyBzb21lICdwYW4nIGluZm8uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5fcmFuZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgSW5zaWRlWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVuZGVyJywgYXJndW1lbnRzKTsgLy8gTm90aWNlOiBvcmlnaW4gdGhpcy5fcmFuZ2Ugc2hvdWxkIGJlIG1haW50YWluZWQsIGFuZCBzaG91bGQgbm90IGJlIHJlLWZldGNoZWRcbiAgICAvLyBmcm9tIGRhdGFab29tTW9kZWwgd2hlbiBwYXlsb2FkLnR5cGUgaXMgJ2RhdGFab29tJywgb3RoZXJ3aXNlICdwYW4nIG9yICd6b29tJ1xuICAgIC8vIGluZm8gd2lsbCBiZSBtaXNzZWQgYmVjYXVzZSBvZiAndGhyb3R0bGUnIG9mIHRoaXMuZGlzcGF0Y2hBY3Rpb24uXG5cbiAgICBpZiAocm9hbXMuc2hvdWxkUmVjb3JkUmFuZ2UocGF5bG9hZCwgZGF0YVpvb21Nb2RlbC5pZCkpIHtcbiAgICAgIHRoaXMuX3JhbmdlID0gZGF0YVpvb21Nb2RlbC5nZXRQZXJjZW50UmFuZ2UoKTtcbiAgICB9IC8vIFJlc2V0IGNvbnRyb2xsZXJzLlxuXG5cbiAgICB6clV0aWwuZWFjaCh0aGlzLmdldFRhcmdldENvb3JkSW5mbygpLCBmdW5jdGlvbiAoY29vcmRJbmZvTGlzdCwgY29vcmRTeXNOYW1lKSB7XG4gICAgICB2YXIgYWxsQ29vcmRJZHMgPSB6clV0aWwubWFwKGNvb3JkSW5mb0xpc3QsIGZ1bmN0aW9uIChjb29yZEluZm8pIHtcbiAgICAgICAgcmV0dXJuIHJvYW1zLmdlbmVyYXRlQ29vcmRJZChjb29yZEluZm8ubW9kZWwpO1xuICAgICAgfSk7XG4gICAgICB6clV0aWwuZWFjaChjb29yZEluZm9MaXN0LCBmdW5jdGlvbiAoY29vcmRJbmZvKSB7XG4gICAgICAgIHZhciBjb29yZE1vZGVsID0gY29vcmRJbmZvLm1vZGVsO1xuICAgICAgICB2YXIgZGF0YVpvb21PcHRpb24gPSBkYXRhWm9vbU1vZGVsLm9wdGlvbjtcbiAgICAgICAgcm9hbXMucmVnaXN0ZXIoYXBpLCB7XG4gICAgICAgICAgY29vcmRJZDogcm9hbXMuZ2VuZXJhdGVDb29yZElkKGNvb3JkTW9kZWwpLFxuICAgICAgICAgIGFsbENvb3JkSWRzOiBhbGxDb29yZElkcyxcbiAgICAgICAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoZSwgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5jb250YWluUG9pbnQoW3gsIHldKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGFab29tSWQ6IGRhdGFab29tTW9kZWwuaWQsXG4gICAgICAgICAgdGhyb3R0bGVSYXRlOiBkYXRhWm9vbU1vZGVsLmdldCgndGhyb3R0bGUnLCB0cnVlKSxcbiAgICAgICAgICBwYW5HZXRSYW5nZTogYmluZCh0aGlzLl9vblBhbiwgdGhpcywgY29vcmRJbmZvLCBjb29yZFN5c05hbWUpLFxuICAgICAgICAgIHpvb21HZXRSYW5nZTogYmluZCh0aGlzLl9vblpvb20sIHRoaXMsIGNvb3JkSW5mbywgY29vcmRTeXNOYW1lKSxcbiAgICAgICAgICB6b29tTG9jazogZGF0YVpvb21PcHRpb24uem9vbUxvY2ssXG4gICAgICAgICAgZGlzYWJsZWQ6IGRhdGFab29tT3B0aW9uLmRpc2FibGVkLFxuICAgICAgICAgIHJvYW1Db250cm9sbGVyT3B0OiB7XG4gICAgICAgICAgICB6b29tT25Nb3VzZVdoZWVsOiBkYXRhWm9vbU9wdGlvbi56b29tT25Nb3VzZVdoZWVsLFxuICAgICAgICAgICAgbW92ZU9uTW91c2VNb3ZlOiBkYXRhWm9vbU9wdGlvbi5tb3ZlT25Nb3VzZU1vdmUsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZTogZGF0YVpvb21PcHRpb24ucHJldmVudERlZmF1bHRNb3VzZU1vdmVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHJvYW1zLnVucmVnaXN0ZXIodGhpcy5hcGksIHRoaXMuZGF0YVpvb21Nb2RlbC5pZCk7XG4gICAgSW5zaWRlWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAnZGlzcG9zZScsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fcmFuZ2UgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUGFuOiBmdW5jdGlvbiAoY29vcmRJbmZvLCBjb29yZFN5c05hbWUsIGNvbnRyb2xsZXIsIGR4LCBkeSwgb2xkWCwgb2xkWSwgbmV3WCwgbmV3WSkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlLnNsaWNlKCk7IC8vIENhbGN1bGF0ZSB0cmFuc2Zvcm0gYnkgdGhlIGZpcnN0IGF4aXMuXG5cblxuICAgIHZhciBheGlzTW9kZWwgPSBjb29yZEluZm8uYXhpc01vZGVsc1swXTtcblxuICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpcmVjdGlvbkluZm8gPSBnZXREaXJlY3Rpb25JbmZvW2Nvb3JkU3lzTmFtZV0oW29sZFgsIG9sZFldLCBbbmV3WCwgbmV3WV0sIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKTtcbiAgICB2YXIgcGVyY2VudERlbHRhID0gZGlyZWN0aW9uSW5mby5zaWduYWwgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkgKiBkaXJlY3Rpb25JbmZvLnBpeGVsIC8gZGlyZWN0aW9uSW5mby5waXhlbExlbmd0aDtcbiAgICBzbGlkZXJNb3ZlKHBlcmNlbnREZWx0YSwgcmFuZ2UsIFswLCAxMDBdLCAnYWxsJyk7XG4gICAgcmV0dXJuIHRoaXMuX3JhbmdlID0gcmFuZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25ab29tOiBmdW5jdGlvbiAoY29vcmRJbmZvLCBjb29yZFN5c05hbWUsIGNvbnRyb2xsZXIsIHNjYWxlLCBtb3VzZVgsIG1vdXNlWSkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlLnNsaWNlKCk7IC8vIENhbGN1bGF0ZSB0cmFuc2Zvcm0gYnkgdGhlIGZpcnN0IGF4aXMuXG5cblxuICAgIHZhciBheGlzTW9kZWwgPSBjb29yZEluZm8uYXhpc01vZGVsc1swXTtcblxuICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpcmVjdGlvbkluZm8gPSBnZXREaXJlY3Rpb25JbmZvW2Nvb3JkU3lzTmFtZV0obnVsbCwgW21vdXNlWCwgbW91c2VZXSwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZEluZm8pO1xuICAgIHZhciBwZXJjZW50UG9pbnQgPSAoZGlyZWN0aW9uSW5mby5zaWduYWwgPiAwID8gZGlyZWN0aW9uSW5mby5waXhlbFN0YXJ0ICsgZGlyZWN0aW9uSW5mby5waXhlbExlbmd0aCAtIGRpcmVjdGlvbkluZm8ucGl4ZWwgOiBkaXJlY3Rpb25JbmZvLnBpeGVsIC0gZGlyZWN0aW9uSW5mby5waXhlbFN0YXJ0KSAvIGRpcmVjdGlvbkluZm8ucGl4ZWxMZW5ndGggKiAocmFuZ2VbMV0gLSByYW5nZVswXSkgKyByYW5nZVswXTtcbiAgICBzY2FsZSA9IE1hdGgubWF4KDEgLyBzY2FsZSwgMCk7XG4gICAgcmFuZ2VbMF0gPSAocmFuZ2VbMF0gLSBwZXJjZW50UG9pbnQpICogc2NhbGUgKyBwZXJjZW50UG9pbnQ7XG4gICAgcmFuZ2VbMV0gPSAocmFuZ2VbMV0gLSBwZXJjZW50UG9pbnQpICogc2NhbGUgKyBwZXJjZW50UG9pbnQ7IC8vIFJlc3RyaWN0IHJhbmdlLlxuXG4gICAgdmFyIG1pbk1heFNwYW4gPSB0aGlzLmRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCkuZ2V0TWluTWF4U3BhbigpO1xuICAgIHNsaWRlck1vdmUoMCwgcmFuZ2UsIFswLCAxMDBdLCAwLCBtaW5NYXhTcGFuLm1pblNwYW4sIG1pbk1heFNwYW4ubWF4U3Bhbik7XG4gICAgcmV0dXJuIHRoaXMuX3JhbmdlID0gcmFuZ2U7XG4gIH1cbn0pO1xudmFyIGdldERpcmVjdGlvbkluZm8gPSB7XG4gIGdyaWQ6IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgcmV0ID0ge307XG4gICAgdmFyIHJlY3QgPSBjb29yZEluZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgb2xkUG9pbnQgPSBvbGRQb2ludCB8fCBbMCwgMF07XG5cbiAgICBpZiAoYXhpcy5kaW0gPT09ICd4Jykge1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMF0gLSBvbGRQb2ludFswXTtcbiAgICAgIHJldC5waXhlbExlbmd0aCA9IHJlY3Qud2lkdGg7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueDtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAxIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF4aXMuZGltID09PSAneSdcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzFdIC0gb2xkUG9pbnRbMV07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LmhlaWdodDtcbiAgICAgIHJldC5waXhlbFN0YXJ0ID0gcmVjdC55O1xuICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBwb2xhcjogZnVuY3Rpb24gKG9sZFBvaW50LCBuZXdQb2ludCwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZEluZm8pIHtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciByZXQgPSB7fTtcbiAgICB2YXIgcG9sYXIgPSBjb29yZEluZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgcmFkaXVzRXh0ZW50ID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpLmdldEV4dGVudCgpO1xuICAgIHZhciBhbmdsZUV4dGVudCA9IHBvbGFyLmdldEFuZ2xlQXhpcygpLmdldEV4dGVudCgpO1xuICAgIG9sZFBvaW50ID0gb2xkUG9pbnQgPyBwb2xhci5wb2ludFRvQ29vcmQob2xkUG9pbnQpIDogWzAsIDBdO1xuICAgIG5ld1BvaW50ID0gcG9sYXIucG9pbnRUb0Nvb3JkKG5ld1BvaW50KTtcblxuICAgIGlmIChheGlzTW9kZWwubWFpblR5cGUgPT09ICdyYWRpdXNBeGlzJykge1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMF0gLSBvbGRQb2ludFswXTsgLy8gcmV0LnBpeGVsTGVuZ3RoID0gTWF0aC5hYnMocmFkaXVzRXh0ZW50WzFdIC0gcmFkaXVzRXh0ZW50WzBdKTtcbiAgICAgIC8vIHJldC5waXhlbFN0YXJ0ID0gTWF0aC5taW4ocmFkaXVzRXh0ZW50WzBdLCByYWRpdXNFeHRlbnRbMV0pO1xuXG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByYWRpdXNFeHRlbnRbMV0gLSByYWRpdXNFeHRlbnRbMF07XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJhZGl1c0V4dGVudFswXTtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAxIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICdhbmdsZUF4aXMnXG4gICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFsxXSAtIG9sZFBvaW50WzFdOyAvLyByZXQucGl4ZWxMZW5ndGggPSBNYXRoLmFicyhhbmdsZUV4dGVudFsxXSAtIGFuZ2xlRXh0ZW50WzBdKTtcbiAgICAgIC8vIHJldC5waXhlbFN0YXJ0ID0gTWF0aC5taW4oYW5nbGVFeHRlbnRbMF0sIGFuZ2xlRXh0ZW50WzFdKTtcblxuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gYW5nbGVFeHRlbnRbMV0gLSBhbmdsZUV4dGVudFswXTtcbiAgICAgIHJldC5waXhlbFN0YXJ0ID0gYW5nbGVFeHRlbnRbMF07XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gLTEgOiAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIHNpbmdsZUF4aXM6IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgcmVjdCA9IGNvb3JkSW5mby5tb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgb2xkUG9pbnQgPSBvbGRQb2ludCB8fCBbMCwgMF07XG5cbiAgICBpZiAoYXhpcy5vcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMF0gLSBvbGRQb2ludFswXTtcbiAgICAgIHJldC5waXhlbExlbmd0aCA9IHJlY3Qud2lkdGg7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueDtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAxIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICd2ZXJ0aWNhbCdcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzFdIC0gb2xkUG9pbnRbMV07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LmhlaWdodDtcbiAgICAgIHJldC5waXhlbFN0YXJ0ID0gcmVjdC55O1xuICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gSW5zaWRlWm9vbVZpZXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9JbnNpZGVab29tVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21WaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIERhdGFab29tTW9kZWwgPSByZXF1aXJlKFwiLi9EYXRhWm9vbU1vZGVsXCIpO1xuXG52YXIgX2RlZmF1bHQgPSBEYXRhWm9vbU1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhWm9vbS5zZWxlY3QnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2VsZWN0Wm9vbU1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2VsZWN0Wm9vbU1vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIERhdGFab29tVmlldyA9IHJlcXVpcmUoXCIuL0RhdGFab29tVmlld1wiKTtcblxudmFyIF9kZWZhdWx0ID0gRGF0YVpvb21WaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhWm9vbS5zZWxlY3QnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2VsZWN0Wm9vbVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBEYXRhWm9vbU1vZGVsID0gcmVxdWlyZShcIi4vRGF0YVpvb21Nb2RlbFwiKTtcblxudmFyIFNsaWRlclpvb21Nb2RlbCA9IERhdGFab29tTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFab29tLnNsaWRlcicsXG4gIGxheW91dE1vZGU6ICdib3gnLFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgc2hvdzogdHJ1ZSxcbiAgICAvLyBwaCA9PiBwbGFjZWhvbGRlci4gVXNpbmcgcGxhY2Vob2RlciBoZXJlIGJlY2F1c2VcbiAgICAvLyBkZWF1bHQgdmFsdWUgY2FuIG9ubHkgYmUgZHJpdmVkIGluIHZpZXcgc3RhZ2UuXG4gICAgcmlnaHQ6ICdwaCcsXG4gICAgLy8gRGVmYXVsdCBhbGlnbiB0byBncmlkIHJlY3QuXG4gICAgdG9wOiAncGgnLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIHdpZHRoOiAncGgnLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIGhlaWdodDogJ3BoJyxcbiAgICAvLyBEZWZhdWx0IGFsaWduIHRvIGdyaWQgcmVjdC5cbiAgICBsZWZ0OiBudWxsLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIGJvdHRvbTogbnVsbCxcbiAgICAvLyBEZWZhdWx0IGFsaWduIHRvIGdyaWQgcmVjdC5cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDQ3LDY5LDg0LDApJyxcbiAgICAvLyBCYWNrZ3JvdW5kIG9mIHNsaWRlciB6b29tIGNvbXBvbmVudC5cbiAgICAvLyBkYXRhQmFja2dyb3VuZENvbG9yOiAnI2RkZCcsICAgICAgICAgLy8gQmFja2dyb3VuZCBjb29yIG9mIGRhdGEgc2hhZG93IGFuZCBib3JkZXIgb2YgYm94LFxuICAgIC8vIGhpZ2hlc3QgcHJpb3JpdHksIHJlbWFpbiBmb3IgY29tcGF0aWJpbGl0eSBvZlxuICAgIC8vIHByZXZpb3VzIHZlcnNpb24sIGJ1dCBub3QgcmVjb21tZW5kZWQgYW55IG1vcmUuXG4gICAgZGF0YUJhY2tncm91bmQ6IHtcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogJyMyZjQ1NTQnLFxuICAgICAgICB3aWR0aDogMC41LFxuICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgIH0sXG4gICAgICBhcmVhU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICdyZ2JhKDQ3LDY5LDg0LDAuMyknLFxuICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgIH1cbiAgICB9LFxuICAgIGJvcmRlckNvbG9yOiAnI2RkZCcsXG4gICAgLy8gYm9yZGVyIGNvbG9yIG9mIHRoZSBib3guIEZvciBjb21wYXRpYmlsaXR5LFxuICAgIC8vIGlmIGRhdGFCYWNrZ3JvdW5kQ29sb3IgaXMgc2V0LCBib3JkZXJDb2xvclxuICAgIC8vIGlzIGlnbm9yZWQuXG4gICAgZmlsbGVyQ29sb3I6ICdyZ2JhKDE2NywxODMsMjA0LDAuNCknLFxuICAgIC8vIENvbG9yIG9mIHNlbGVjdGVkIGFyZWEuXG4gICAgLy8gaGFuZGxlQ29sb3I6ICdyZ2JhKDg5LDE3MCwyMTYsMC45NSknLCAgICAgLy8gQ29sb3Igb2YgaGFuZGxlLlxuICAgIC8vIGhhbmRsZUljb246ICdwYXRoOi8vTTQuOSwxNy44YzAtMS40LDQuNS0xMC41LDUuNS0xMi40YzAtMC4xLDAuNi0xLjEsMC45LTEuMWMwLjQsMCwwLjksMSwwLjksMS4xYzEuMSwyLjIsNS40LDExLDUuNCwxMi40djE3LjhjMCwxLjUtMC42LDIuMS0xLjMsMi4xSDYuMWMtMC43LDAtMS4zLTAuNi0xLjMtMi4xVjE3Ljh6JyxcbiAgICBoYW5kbGVJY29uOiAnTTguMiwxMy42VjMuOUg2LjN2OS43SDMuMXYxNC45aDMuM3Y5LjdoMS44di05LjdoMy4zVjEzLjZIOC4yeiBNOS43LDI0LjRINC44di0xLjRoNC45VjI0LjR6IE05LjcsMTkuMUg0Ljh2LTEuNGg0LjlWMTkuMXonLFxuICAgIC8vIFBlcmNlbnQgb2YgdGhlIHNsaWRlciBoZWlnaHRcbiAgICBoYW5kbGVTaXplOiAnMTAwJScsXG4gICAgaGFuZGxlU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2E3YjdjYydcbiAgICB9LFxuICAgIGxhYmVsUHJlY2lzaW9uOiBudWxsLFxuICAgIGxhYmVsRm9ybWF0dGVyOiBudWxsLFxuICAgIHNob3dEZXRhaWw6IHRydWUsXG4gICAgc2hvd0RhdGFTaGFkb3c6ICdhdXRvJyxcbiAgICAvLyBEZWZhdWx0IGF1dG8gZGVjaXNpb24uXG4gICAgcmVhbHRpbWU6IHRydWUsXG4gICAgem9vbUxvY2s6IGZhbHNlLFxuICAgIC8vIFdoZXRoZXIgZGlzYWJsZSB6b29tLlxuICAgIHRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH1cbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBTbGlkZXJab29tTW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tTW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciB0aHJvdHRsZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3Rocm90dGxlXCIpO1xuXG52YXIgRGF0YVpvb21WaWV3ID0gcmVxdWlyZShcIi4vRGF0YVpvb21WaWV3XCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIGxheW91dCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xheW91dFwiKTtcblxudmFyIHNsaWRlck1vdmUgPSByZXF1aXJlKFwiLi4vaGVscGVyL3NsaWRlck1vdmVcIik7XG5cbnZhciBSZWN0ID0gZ3JhcGhpYy5SZWN0O1xudmFyIGxpbmVhck1hcCA9IG51bWJlclV0aWwubGluZWFyTWFwO1xudmFyIGFzYyA9IG51bWJlclV0aWwuYXNjO1xudmFyIGJpbmQgPSB6clV0aWwuYmluZDtcbnZhciBlYWNoID0genJVdGlsLmVhY2g7IC8vIENvbnN0YW50c1xuXG52YXIgREVGQVVMVF9MT0NBVElPTl9FREdFX0dBUCA9IDc7XG52YXIgREVGQVVMVF9GUkFNRV9CT1JERVJfV0lEVEggPSAxO1xudmFyIERFRkFVTFRfRklMTEVSX1NJWkUgPSAzMDtcbnZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xudmFyIFZFUlRJQ0FMID0gJ3ZlcnRpY2FsJztcbnZhciBMQUJFTF9HQVAgPSA1O1xudmFyIFNIT1dfREFUQV9TSEFET1dfU0VSSUVTX1RZUEUgPSBbJ2xpbmUnLCAnYmFyJywgJ2NhbmRsZXN0aWNrJywgJ3NjYXR0ZXInXTtcbnZhciBTbGlkZXJab29tVmlldyA9IERhdGFab29tVmlldy5leHRlbmQoe1xuICB0eXBlOiAnZGF0YVpvb20uc2xpZGVyJyxcbiAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9kaXNwbGF5YWJsZXMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgICB0aGlzLl9vcmllbnQ7XG4gICAgLyoqXG4gICAgICogWzAsIDEwMF1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fcmFuZ2U7XG4gICAgLyoqXG4gICAgICogW2Nvb3JkIG9mIHRoZSBmaXJzdCBoYW5kbGUsIGNvb3JkIG9mIHRoZSBzZWNvbmQgaGFuZGxlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIC8qKlxuICAgICAqIFtsZW5ndGgsIHRoaWNrXVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuXG4gICAgdGhpcy5fc2l6ZTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLl9oYW5kbGVXaWR0aDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLl9oYW5kbGVIZWlnaHQ7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2xvY2F0aW9uO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLl9kcmFnZ2luZztcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fZGF0YVNoYWRvd0luZm87XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgU2xpZGVyWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVuZGVyJywgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsZS5jcmVhdGVPclVwZGF0ZSh0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicsIHRoaXMuZGF0YVpvb21Nb2RlbC5nZXQoJ3Rocm90dGxlJyksICdmaXhSYXRlJyk7XG4gICAgdGhpcy5fb3JpZW50ID0gZGF0YVpvb21Nb2RlbC5nZXQoJ29yaWVudCcpO1xuXG4gICAgaWYgKHRoaXMuZGF0YVpvb21Nb2RlbC5nZXQoJ3Nob3cnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBOb3RpY2U6IHRoaXMuX3Jlc2V0SW50ZXJ2YWwoKSBzaG91bGQgbm90IGJlIGV4ZWN1dGVkIHdoZW4gcGF5bG9hZC50eXBlXG4gICAgLy8gaXMgJ2RhdGFab29tJywgb3JpZ2luIHRoaXMuX3JhbmdlIHNob3VsZCBiZSBtYWludGFpbmVkLCBvdGhlcndpc2UgJ3BhbidcbiAgICAvLyBvciAnem9vbScgaW5mbyB3aWxsIGJlIG1pc3NlZCBiZWNhdXNlIG9mICd0aHJvdHRsZScgb2YgdGhpcy5kaXNwYXRjaEFjdGlvbixcblxuXG4gICAgaWYgKCFwYXlsb2FkIHx8IHBheWxvYWQudHlwZSAhPT0gJ2RhdGFab29tJyB8fCBwYXlsb2FkLmZyb20gIT09IHRoaXMudWlkKSB7XG4gICAgICB0aGlzLl9idWlsZFZpZXcoKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgU2xpZGVyWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVtb3ZlJywgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBTbGlkZXJab29tVmlldy5zdXBlckFwcGx5KHRoaXMsICdkaXNwb3NlJywgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicpO1xuICB9LFxuICBfYnVpbGRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdGhpc0dyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgdGhpcy5fcmVzZXRMb2NhdGlvbigpO1xuXG4gICAgdGhpcy5fcmVzZXRJbnRlcnZhbCgpO1xuXG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoKTtcblxuICAgIHRoaXMuX3JlbmRlckhhbmRsZSgpO1xuXG4gICAgdGhpcy5fcmVuZGVyRGF0YVNoYWRvdygpO1xuXG4gICAgdGhpc0dyb3VwLmFkZChiYXJHcm91cCk7XG5cbiAgICB0aGlzLl9wb3NpdGlvbkdyb3VwKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRMb2NhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBhcGkgPSB0aGlzLmFwaTsgLy8gSWYgc29tZSBvZiB4L3kvd2lkdGgvaGVpZ2h0IGFyZSBub3Qgc3BlY2lmaWVkLFxuICAgIC8vIGF1dG8tYWRhcHQgYWNjb3JkaW5nIHRvIHRhcmdldCBncmlkLlxuXG4gICAgdmFyIGNvb3JkUmVjdCA9IHRoaXMuX2ZpbmRDb29yZFJlY3QoKTtcblxuICAgIHZhciBlY1NpemUgPSB7XG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH07IC8vIERlZmF1bHQgYWxpZ24gYnkgY29vcmRpbmF0ZSBzeXN0ZW0gcmVjdC5cblxuICAgIHZhciBwb3NpdGlvbkluZm8gPSB0aGlzLl9vcmllbnQgPT09IEhPUklaT05UQUwgPyB7XG4gICAgICAvLyBXaHkgdXNpbmcgJ3JpZ2h0JywgYmVjYXVzZSByaWdodCBzaG91bGQgYmUgdXNlZCBpbiB2ZXJ0aWNhbCxcbiAgICAgIC8vIGFuZCBpdCBpcyBiZXR0ZXIgdG8gYmUgY29uc2lzdGVudCBmb3IgZGVhbGluZyB3aXRoIHBvc2l0aW9uIHBhcmFtIG1lcmdlLlxuICAgICAgcmlnaHQ6IGVjU2l6ZS53aWR0aCAtIGNvb3JkUmVjdC54IC0gY29vcmRSZWN0LndpZHRoLFxuICAgICAgdG9wOiBlY1NpemUuaGVpZ2h0IC0gREVGQVVMVF9GSUxMRVJfU0laRSAtIERFRkFVTFRfTE9DQVRJT05fRURHRV9HQVAsXG4gICAgICB3aWR0aDogY29vcmRSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBERUZBVUxUX0ZJTExFUl9TSVpFXG4gICAgfSA6IHtcbiAgICAgIC8vIHZlcnRpY2FsXG4gICAgICByaWdodDogREVGQVVMVF9MT0NBVElPTl9FREdFX0dBUCxcbiAgICAgIHRvcDogY29vcmRSZWN0LnksXG4gICAgICB3aWR0aDogREVGQVVMVF9GSUxMRVJfU0laRSxcbiAgICAgIGhlaWdodDogY29vcmRSZWN0LmhlaWdodFxuICAgIH07IC8vIERvIG5vdCB3cml0ZSBiYWNrIHRvIG9wdGlvbiBhbmQgcmVwbGFjZSB2YWx1ZSAncGgnLCBiZWNhdXNlXG4gICAgLy8gdGhlICdwaCcgdmFsdWUgc2hvdWxkIGJlIHJlY2FsY3VsYXRlZCB3aGVuIHJlc2l6ZS5cblxuICAgIHZhciBsYXlvdXRQYXJhbXMgPSBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKGRhdGFab29tTW9kZWwub3B0aW9uKTsgLy8gUmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG5cbiAgICB6clV0aWwuZWFjaChbJ3JpZ2h0JywgJ3RvcCcsICd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChsYXlvdXRQYXJhbXNbbmFtZV0gPT09ICdwaCcpIHtcbiAgICAgICAgbGF5b3V0UGFyYW1zW25hbWVdID0gcG9zaXRpb25JbmZvW25hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBsYXlvdXRSZWN0ID0gbGF5b3V0LmdldExheW91dFJlY3QobGF5b3V0UGFyYW1zLCBlY1NpemUsIGRhdGFab29tTW9kZWwucGFkZGluZyk7XG4gICAgdGhpcy5fbG9jYXRpb24gPSB7XG4gICAgICB4OiBsYXlvdXRSZWN0LngsXG4gICAgICB5OiBsYXlvdXRSZWN0LnlcbiAgICB9O1xuICAgIHRoaXMuX3NpemUgPSBbbGF5b3V0UmVjdC53aWR0aCwgbGF5b3V0UmVjdC5oZWlnaHRdO1xuICAgIHRoaXMuX29yaWVudCA9PT0gVkVSVElDQUwgJiYgdGhpcy5fc2l6ZS5yZXZlcnNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcG9zaXRpb25Hcm91cDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2xvY2F0aW9uO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLl9vcmllbnQ7IC8vIEp1c3QgdXNlIHRoZSBmaXJzdCBheGlzIHRvIGRldGVybWluZSBtYXBwaW5nLlxuXG4gICAgdmFyIHRhcmdldEF4aXNNb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXRGaXJzdFRhcmdldEF4aXNNb2RlbCgpO1xuICAgIHZhciBpbnZlcnNlID0gdGFyZ2V0QXhpc01vZGVsICYmIHRhcmdldEF4aXNNb2RlbC5nZXQoJ2ludmVyc2UnKTtcbiAgICB2YXIgYmFyR3JvdXAgPSB0aGlzLl9kaXNwbGF5YWJsZXMuYmFyR3JvdXA7XG4gICAgdmFyIG90aGVyQXhpc0ludmVyc2UgPSAodGhpcy5fZGF0YVNoYWRvd0luZm8gfHwge30pLm90aGVyQXhpc0ludmVyc2U7IC8vIFRyYW5zZm9ybSBiYXJHcm91cC5cblxuICAgIGJhckdyb3VwLmF0dHIob3JpZW50ID09PSBIT1JJWk9OVEFMICYmICFpbnZlcnNlID8ge1xuICAgICAgc2NhbGU6IG90aGVyQXhpc0ludmVyc2UgPyBbMSwgMV0gOiBbMSwgLTFdXG4gICAgfSA6IG9yaWVudCA9PT0gSE9SSVpPTlRBTCAmJiBpbnZlcnNlID8ge1xuICAgICAgc2NhbGU6IG90aGVyQXhpc0ludmVyc2UgPyBbLTEsIDFdIDogWy0xLCAtMV1cbiAgICB9IDogb3JpZW50ID09PSBWRVJUSUNBTCAmJiAhaW52ZXJzZSA/IHtcbiAgICAgIHNjYWxlOiBvdGhlckF4aXNJbnZlcnNlID8gWzEsIC0xXSA6IFsxLCAxXSxcbiAgICAgIHJvdGF0aW9uOiBNYXRoLlBJIC8gMiAvLyBEb250IHVzZSBNYXRoLlBJLCBjb25zaWRlcmluZyBzaGFkb3cgZGlyZWN0aW9uLlxuXG4gICAgfSA6IHtcbiAgICAgIHNjYWxlOiBvdGhlckF4aXNJbnZlcnNlID8gWy0xLCAtMV0gOiBbLTEsIDFdLFxuICAgICAgcm90YXRpb246IE1hdGguUEkgLyAyXG4gICAgfSk7IC8vIFBvc2l0aW9uIGJhckdyb3VwXG5cbiAgICB2YXIgcmVjdCA9IHRoaXNHcm91cC5nZXRCb3VuZGluZ1JlY3QoW2Jhckdyb3VwXSk7XG4gICAgdGhpc0dyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgW2xvY2F0aW9uLnggLSByZWN0LngsIGxvY2F0aW9uLnkgLSByZWN0LnldKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRWaWV3RXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFswLCB0aGlzLl9zaXplWzBdXTtcbiAgfSxcbiAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwO1xuICAgIGJhckdyb3VwLmFkZChuZXcgUmVjdCh7XG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogZGF0YVpvb21Nb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpXG4gICAgICB9LFxuICAgICAgejI6IC00MFxuICAgIH0pKTsgLy8gQ2xpY2sgcGFuZWwsIG92ZXIgc2hhZG93LCBiZWxvdyBoYW5kbGVzLlxuXG4gICAgYmFyR3JvdXAuYWRkKG5ldyBSZWN0KHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiBzaXplWzBdLFxuICAgICAgICBoZWlnaHQ6IHNpemVbMV1cbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgejI6IDAsXG4gICAgICBvbmNsaWNrOiB6clV0aWwuYmluZCh0aGlzLl9vbkNsaWNrUGFuZWxDbGljaywgdGhpcylcbiAgICB9KSk7XG4gIH0sXG4gIF9yZW5kZXJEYXRhU2hhZG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLl9kYXRhU2hhZG93SW5mbyA9IHRoaXMuX3ByZXBhcmVEYXRhU2hhZG93SW5mbygpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGluZm8uc2VyaWVzO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0UmF3RGF0YSgpO1xuICAgIHZhciBvdGhlckRpbSA9IHNlcmllc01vZGVsLmdldFNoYWRvd0RpbSA/IHNlcmllc01vZGVsLmdldFNoYWRvd0RpbSgpIC8vIEBzZWUgY2FuZGxlc3RpY2tcbiAgICA6IGluZm8ub3RoZXJEaW07XG5cbiAgICBpZiAob3RoZXJEaW0gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdGhlckRhdGFFeHRlbnQgPSBkYXRhLmdldERhdGFFeHRlbnQob3RoZXJEaW0pOyAvLyBOaWNlIGV4dGVudC5cblxuICAgIHZhciBvdGhlck9mZnNldCA9IChvdGhlckRhdGFFeHRlbnRbMV0gLSBvdGhlckRhdGFFeHRlbnRbMF0pICogMC4zO1xuICAgIG90aGVyRGF0YUV4dGVudCA9IFtvdGhlckRhdGFFeHRlbnRbMF0gLSBvdGhlck9mZnNldCwgb3RoZXJEYXRhRXh0ZW50WzFdICsgb3RoZXJPZmZzZXRdO1xuICAgIHZhciBvdGhlclNoYWRvd0V4dGVudCA9IFswLCBzaXplWzFdXTtcbiAgICB2YXIgdGhpc1NoYWRvd0V4dGVudCA9IFswLCBzaXplWzBdXTtcbiAgICB2YXIgYXJlYVBvaW50cyA9IFtbc2l6ZVswXSwgMF0sIFswLCAwXV07XG4gICAgdmFyIGxpbmVQb2ludHMgPSBbXTtcbiAgICB2YXIgc3RlcCA9IHRoaXNTaGFkb3dFeHRlbnRbMV0gLyAoZGF0YS5jb3VudCgpIC0gMSk7XG4gICAgdmFyIHRoaXNDb29yZCA9IDA7IC8vIE9wdGltaXplIGZvciBsYXJnZSBkYXRhIHNoYWRvd1xuXG4gICAgdmFyIHN0cmlkZSA9IE1hdGgucm91bmQoZGF0YS5jb3VudCgpIC8gc2l6ZVswXSk7XG4gICAgdmFyIGxhc3RJc0VtcHR5O1xuICAgIGRhdGEuZWFjaChbb3RoZXJEaW1dLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICBpZiAoc3RyaWRlID4gMCAmJiBpbmRleCAlIHN0cmlkZSkge1xuICAgICAgICB0aGlzQ29vcmQgKz0gc3RlcDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGSVhNRVxuICAgICAgLy8gU2hvdWxkIGNvbnNpZGVyIGF4aXMubWluL2F4aXMubWF4IHdoZW4gZHJhd2luZyBkYXRhU2hhZG93LlxuICAgICAgLy8gRklYTUVcbiAgICAgIC8vIOW6lOivpeS9v+eUqOe7n+S4gOeahOepuuWIpOaWre+8n+i/mOaYr+WcqGxpc3Tph4zov5vooYznqbrliKTmlq3vvJ9cblxuXG4gICAgICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSAnJzsgLy8gU2VlICM0MjM1LlxuXG4gICAgICB2YXIgb3RoZXJDb29yZCA9IGlzRW1wdHkgPyAwIDogbGluZWFyTWFwKHZhbHVlLCBvdGhlckRhdGFFeHRlbnQsIG90aGVyU2hhZG93RXh0ZW50LCB0cnVlKTsgLy8gQXR0ZW1wdCB0byBkcmF3IGRhdGEgc2hhZG93IHByZWNpc2VseSB3aGVuIHRoZXJlIGFyZSBlbXB0eSB2YWx1ZS5cblxuICAgICAgaWYgKGlzRW1wdHkgJiYgIWxhc3RJc0VtcHR5ICYmIGluZGV4KSB7XG4gICAgICAgIGFyZWFQb2ludHMucHVzaChbYXJlYVBvaW50c1thcmVhUG9pbnRzLmxlbmd0aCAtIDFdWzBdLCAwXSk7XG4gICAgICAgIGxpbmVQb2ludHMucHVzaChbbGluZVBvaW50c1tsaW5lUG9pbnRzLmxlbmd0aCAtIDFdWzBdLCAwXSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtcHR5ICYmIGxhc3RJc0VtcHR5KSB7XG4gICAgICAgIGFyZWFQb2ludHMucHVzaChbdGhpc0Nvb3JkLCAwXSk7XG4gICAgICAgIGxpbmVQb2ludHMucHVzaChbdGhpc0Nvb3JkLCAwXSk7XG4gICAgICB9XG5cbiAgICAgIGFyZWFQb2ludHMucHVzaChbdGhpc0Nvb3JkLCBvdGhlckNvb3JkXSk7XG4gICAgICBsaW5lUG9pbnRzLnB1c2goW3RoaXNDb29yZCwgb3RoZXJDb29yZF0pO1xuICAgICAgdGhpc0Nvb3JkICs9IHN0ZXA7XG4gICAgICBsYXN0SXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgfSk7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7IC8vIHZhciBkYXRhQmFja2dyb3VuZE1vZGVsID0gZGF0YVpvb21Nb2RlbC5nZXRNb2RlbCgnZGF0YUJhY2tncm91bmQnKTtcblxuICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5hZGQobmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IGFyZWFQb2ludHNcbiAgICAgIH0sXG4gICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgZmlsbDogZGF0YVpvb21Nb2RlbC5nZXQoJ2RhdGFCYWNrZ3JvdW5kQ29sb3InKVxuICAgICAgfSwgZGF0YVpvb21Nb2RlbC5nZXRNb2RlbCgnZGF0YUJhY2tncm91bmQuYXJlYVN0eWxlJykuZ2V0QXJlYVN0eWxlKCkpLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgejI6IC0yMFxuICAgIH0pKTtcblxuICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5hZGQobmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBsaW5lUG9pbnRzXG4gICAgICB9LFxuICAgICAgc3R5bGU6IGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2RhdGFCYWNrZ3JvdW5kLmxpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgejI6IC0xOVxuICAgIH0pKTtcbiAgfSxcbiAgX3ByZXBhcmVEYXRhU2hhZG93SW5mbzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBzaG93RGF0YVNoYWRvdyA9IGRhdGFab29tTW9kZWwuZ2V0KCdzaG93RGF0YVNoYWRvdycpO1xuXG4gICAgaWYgKHNob3dEYXRhU2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmluZCBhIHJlcHJlc2VudGF0aXZlIHNlcmllcy5cblxuXG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcywgYXhpc0luZGV4KSB7XG4gICAgICB2YXIgc2VyaWVzTW9kZWxzID0gZGF0YVpvb21Nb2RlbC5nZXRBeGlzUHJveHkoZGltTmFtZXMubmFtZSwgYXhpc0luZGV4KS5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKTtcbiAgICAgIHpyVXRpbC5lYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvd0RhdGFTaGFkb3cgIT09IHRydWUgJiYgenJVdGlsLmluZGV4T2YoU0hPV19EQVRBX1NIQURPV19TRVJJRVNfVFlQRSwgc2VyaWVzTW9kZWwuZ2V0KCd0eXBlJykpIDwgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGlzQXhpcyA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGRpbU5hbWVzLmF4aXMsIGF4aXNJbmRleCkuYXhpcztcbiAgICAgICAgdmFyIG90aGVyRGltID0gZ2V0T3RoZXJEaW0oZGltTmFtZXMubmFtZSk7XG4gICAgICAgIHZhciBvdGhlckF4aXNJbnZlcnNlO1xuICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICAgIGlmIChvdGhlckRpbSAhPSBudWxsICYmIGNvb3JkU3lzLmdldE90aGVyQXhpcykge1xuICAgICAgICAgIG90aGVyQXhpc0ludmVyc2UgPSBjb29yZFN5cy5nZXRPdGhlckF4aXModGhpc0F4aXMpLmludmVyc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgdGhpc0F4aXM6IHRoaXNBeGlzLFxuICAgICAgICAgIHNlcmllczogc2VyaWVzTW9kZWwsXG4gICAgICAgICAgdGhpc0RpbTogZGltTmFtZXMubmFtZSxcbiAgICAgICAgICBvdGhlckRpbTogb3RoZXJEaW0sXG4gICAgICAgICAgb3RoZXJBeGlzSW52ZXJzZTogb3RoZXJBeGlzSW52ZXJzZVxuICAgICAgICB9O1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgX3JlbmRlckhhbmRsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXNwbGF5YmxlcyA9IHRoaXMuX2Rpc3BsYXlhYmxlcztcbiAgICB2YXIgaGFuZGxlcyA9IGRpc3BsYXlibGVzLmhhbmRsZXMgPSBbXTtcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gZGlzcGxheWJsZXMuaGFuZGxlTGFiZWxzID0gW107XG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwO1xuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICBiYXJHcm91cC5hZGQoZGlzcGxheWJsZXMuZmlsbGVyID0gbmV3IFJlY3Qoe1xuICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpcy5fb3JpZW50KSxcbiAgICAgIGRyaWZ0OiBiaW5kKHRoaXMuX29uRHJhZ01vdmUsIHRoaXMsICdhbGwnKSxcbiAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBGb3QgbW9iaWxlIGRldmljZW0sIHByZXZlbnQgc2NyZWVuIHNsaWRlciBvbiB0aGUgYnV0dG9uLlxuICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBvbmRyYWdzdGFydDogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgb25kcmFnZW5kOiBiaW5kKHRoaXMuX29uRHJhZ0VuZCwgdGhpcyksXG4gICAgICBvbm1vdXNlb3ZlcjogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgb25tb3VzZW91dDogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIGZhbHNlKSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGZpbGw6IGRhdGFab29tTW9kZWwuZ2V0KCdmaWxsZXJDb2xvcicpLFxuICAgICAgICB0ZXh0UG9zaXRpb246ICdpbnNpZGUnXG4gICAgICB9XG4gICAgfSkpOyAvLyBGcmFtZSBib3JkZXIuXG5cbiAgICBiYXJHcm91cC5hZGQobmV3IFJlY3QoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdCh7XG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgc3Ryb2tlOiBkYXRhWm9vbU1vZGVsLmdldCgnZGF0YUJhY2tncm91bmRDb2xvcicpIHx8IGRhdGFab29tTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpLFxuICAgICAgICBsaW5lV2lkdGg6IERFRkFVTFRfRlJBTUVfQk9SREVSX1dJRFRILFxuICAgICAgICBmaWxsOiAncmdiYSgwLDAsMCwwKSdcbiAgICAgIH1cbiAgICB9KSkpO1xuICAgIGVhY2goWzAsIDFdLCBmdW5jdGlvbiAoaGFuZGxlSW5kZXgpIHtcbiAgICAgIHZhciBwYXRoID0gZ3JhcGhpYy5jcmVhdGVJY29uKGRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVJY29uJyksIHtcbiAgICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpcy5fb3JpZW50KSxcbiAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICBkcmlmdDogYmluZCh0aGlzLl9vbkRyYWdNb3ZlLCB0aGlzLCBoYW5kbGVJbmRleCksXG4gICAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIEZvdCBtb2JpbGUgZGV2aWNlbSwgcHJldmVudCBzY3JlZW4gc2xpZGVyIG9uIHRoZSBidXR0b24uXG4gICAgICAgICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZHJhZ2VuZDogYmluZCh0aGlzLl9vbkRyYWdFbmQsIHRoaXMpLFxuICAgICAgICBvbm1vdXNlb3ZlcjogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgICBvbm1vdXNlb3V0OiBiaW5kKHRoaXMuX3Nob3dEYXRhSW5mbywgdGhpcywgZmFsc2UpXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMixcbiAgICAgICAgaGVpZ2h0OiAyXG4gICAgICB9KTtcbiAgICAgIHZhciBiUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICB0aGlzLl9oYW5kbGVIZWlnaHQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChkYXRhWm9vbU1vZGVsLmdldCgnaGFuZGxlU2l6ZScpLCB0aGlzLl9zaXplWzFdKTtcbiAgICAgIHRoaXMuX2hhbmRsZVdpZHRoID0gYlJlY3Qud2lkdGggLyBiUmVjdC5oZWlnaHQgKiB0aGlzLl9oYW5kbGVIZWlnaHQ7XG4gICAgICBwYXRoLnNldFN0eWxlKGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2hhbmRsZVN0eWxlJykuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgdmFyIGhhbmRsZUNvbG9yID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2hhbmRsZUNvbG9yJyk7IC8vIENvbXBhdGl0YWJsZSB3aXRoIHByZXZpb3VzIHZlcnNpb25cblxuICAgICAgaWYgKGhhbmRsZUNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgcGF0aC5zdHlsZS5maWxsID0gaGFuZGxlQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGJhckdyb3VwLmFkZChoYW5kbGVzW2hhbmRsZUluZGV4XSA9IHBhdGgpO1xuICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gZGF0YVpvb21Nb2RlbC50ZXh0U3R5bGVNb2RlbDtcbiAgICAgIHRoaXMuZ3JvdXAuYWRkKGhhbmRsZUxhYmVsc1toYW5kbGVJbmRleF0gPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICBpbnZpc2libGU6IHRydWUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpXG4gICAgICAgIH0sXG4gICAgICAgIHoyOiAxMFxuICAgICAgfSkpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0SW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZSA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXRQZXJjZW50UmFuZ2UoKTtcblxuICAgIHZhciB2aWV3RXh0ZW50ID0gdGhpcy5fZ2V0Vmlld0V4dGVudCgpO1xuXG4gICAgdGhpcy5faGFuZGxlRW5kcyA9IFtsaW5lYXJNYXAocmFuZ2VbMF0sIFswLCAxMDBdLCB2aWV3RXh0ZW50LCB0cnVlKSwgbGluZWFyTWFwKHJhbmdlWzFdLCBbMCwgMTAwXSwgdmlld0V4dGVudCwgdHJ1ZSldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gaGFuZGxlSW5kZXggMCBvciAxIG9yICdhbGwnXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVxuICAgKi9cbiAgX3VwZGF0ZUludGVydmFsOiBmdW5jdGlvbiAoaGFuZGxlSW5kZXgsIGRlbHRhKSB7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuXG4gICAgdmFyIHZpZXdFeHRlbmQgPSB0aGlzLl9nZXRWaWV3RXh0ZW50KCk7XG5cbiAgICB2YXIgbWluTWF4U3BhbiA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCkuZ2V0TWluTWF4U3BhbigpO1xuICAgIHZhciBwZXJjZW50RXh0ZW50ID0gWzAsIDEwMF07XG4gICAgc2xpZGVyTW92ZShkZWx0YSwgaGFuZGxlRW5kcywgdmlld0V4dGVuZCwgZGF0YVpvb21Nb2RlbC5nZXQoJ3pvb21Mb2NrJykgPyAnYWxsJyA6IGhhbmRsZUluZGV4LCBtaW5NYXhTcGFuLm1pblNwYW4gIT0gbnVsbCA/IGxpbmVhck1hcChtaW5NYXhTcGFuLm1pblNwYW4sIHBlcmNlbnRFeHRlbnQsIHZpZXdFeHRlbmQsIHRydWUpIDogbnVsbCwgbWluTWF4U3Bhbi5tYXhTcGFuICE9IG51bGwgPyBsaW5lYXJNYXAobWluTWF4U3Bhbi5tYXhTcGFuLCBwZXJjZW50RXh0ZW50LCB2aWV3RXh0ZW5kLCB0cnVlKSA6IG51bGwpO1xuICAgIHRoaXMuX3JhbmdlID0gYXNjKFtsaW5lYXJNYXAoaGFuZGxlRW5kc1swXSwgdmlld0V4dGVuZCwgcGVyY2VudEV4dGVudCwgdHJ1ZSksIGxpbmVhck1hcChoYW5kbGVFbmRzWzFdLCB2aWV3RXh0ZW5kLCBwZXJjZW50RXh0ZW50LCB0cnVlKV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVZpZXc6IGZ1bmN0aW9uIChub25SZWFsdGltZSkge1xuICAgIHZhciBkaXNwbGF5YmxlcyA9IHRoaXMuX2Rpc3BsYXlhYmxlcztcbiAgICB2YXIgaGFuZGxlRW5kcyA9IHRoaXMuX2hhbmRsZUVuZHM7XG4gICAgdmFyIGhhbmRsZUludGVydmFsID0gYXNjKGhhbmRsZUVuZHMuc2xpY2UoKSk7XG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgIGVhY2goWzAsIDFdLCBmdW5jdGlvbiAoaGFuZGxlSW5kZXgpIHtcbiAgICAgIC8vIEhhbmRsZXNcbiAgICAgIHZhciBoYW5kbGUgPSBkaXNwbGF5Ymxlcy5oYW5kbGVzW2hhbmRsZUluZGV4XTtcbiAgICAgIHZhciBoYW5kbGVIZWlnaHQgPSB0aGlzLl9oYW5kbGVIZWlnaHQ7XG4gICAgICBoYW5kbGUuYXR0cih7XG4gICAgICAgIHNjYWxlOiBbaGFuZGxlSGVpZ2h0IC8gMiwgaGFuZGxlSGVpZ2h0IC8gMl0sXG4gICAgICAgIHBvc2l0aW9uOiBbaGFuZGxlRW5kc1toYW5kbGVJbmRleF0sIHNpemVbMV0gLyAyIC0gaGFuZGxlSGVpZ2h0IC8gMl1cbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpOyAvLyBGaWxsZXJcblxuICAgIGRpc3BsYXlibGVzLmZpbGxlci5zZXRTaGFwZSh7XG4gICAgICB4OiBoYW5kbGVJbnRlcnZhbFswXSxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogaGFuZGxlSW50ZXJ2YWxbMV0gLSBoYW5kbGVJbnRlcnZhbFswXSxcbiAgICAgIGhlaWdodDogc2l6ZVsxXVxuICAgIH0pO1xuXG4gICAgdGhpcy5fdXBkYXRlRGF0YUluZm8obm9uUmVhbHRpbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZURhdGFJbmZvOiBmdW5jdGlvbiAobm9uUmVhbHRpbWUpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgZGlzcGxheWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgdmFyIGhhbmRsZUxhYmVscyA9IGRpc3BsYXlibGVzLmhhbmRsZUxhYmVscztcbiAgICB2YXIgb3JpZW50ID0gdGhpcy5fb3JpZW50O1xuICAgIHZhciBsYWJlbFRleHRzID0gWycnLCAnJ107IC8vIEZJWE1FXG4gICAgLy8gZGF0ZeWei++8jOaUr+aMgWZvcm1hdHRlcu+8jGF1dG9mb3JtYXR0ZXLvvIhlYzIgZGF0ZS5nZXRBdXRvRm9ybWF0dGVy77yJXG5cbiAgICBpZiAoZGF0YVpvb21Nb2RlbC5nZXQoJ3Nob3dEZXRhaWwnKSkge1xuICAgICAgdmFyIGF4aXNQcm94eSA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG5cbiAgICAgIGlmIChheGlzUHJveHkpIHtcbiAgICAgICAgdmFyIGF4aXMgPSBheGlzUHJveHkuZ2V0QXhpc01vZGVsKCkuYXhpcztcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2U7XG4gICAgICAgIHZhciBkYXRhSW50ZXJ2YWwgPSBub25SZWFsdGltZSAvLyBTZWUgIzQ0MzQsIGRhdGEgYW5kIGF4aXMgYXJlIG5vdCBwcm9jZXNzZWQgYW5kIHJlc2V0IHlldCBpbiBub24tcmVhbHRpbWUgbW9kZS5cbiAgICAgICAgPyBheGlzUHJveHkuY2FsY3VsYXRlRGF0YVdpbmRvdyh7XG4gICAgICAgICAgc3RhcnQ6IHJhbmdlWzBdLFxuICAgICAgICAgIGVuZDogcmFuZ2VbMV1cbiAgICAgICAgfSkudmFsdWVXaW5kb3cgOiBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICAgIGxhYmVsVGV4dHMgPSBbdGhpcy5fZm9ybWF0TGFiZWwoZGF0YUludGVydmFsWzBdLCBheGlzKSwgdGhpcy5fZm9ybWF0TGFiZWwoZGF0YUludGVydmFsWzFdLCBheGlzKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9yZGVyZWRIYW5kbGVFbmRzID0gYXNjKHRoaXMuX2hhbmRsZUVuZHMuc2xpY2UoKSk7XG4gICAgc2V0TGFiZWwuY2FsbCh0aGlzLCAwKTtcbiAgICBzZXRMYWJlbC5jYWxsKHRoaXMsIDEpO1xuXG4gICAgZnVuY3Rpb24gc2V0TGFiZWwoaGFuZGxlSW5kZXgpIHtcbiAgICAgIC8vIExhYmVsXG4gICAgICAvLyBUZXh0IHNob3VsZCBub3QgdHJhbnNmb3JtIGJ5IGJhckdyb3VwLlxuICAgICAgLy8gSWdub3JlIGhhbmRsZXJzIHRyYW5zZm9ybVxuICAgICAgdmFyIGJhclRyYW5zZm9ybSA9IGdyYXBoaWMuZ2V0VHJhbnNmb3JtKGRpc3BsYXlibGVzLmhhbmRsZXNbaGFuZGxlSW5kZXhdLnBhcmVudCwgdGhpcy5ncm91cCk7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24oaGFuZGxlSW5kZXggPT09IDAgPyAncmlnaHQnIDogJ2xlZnQnLCBiYXJUcmFuc2Zvcm0pO1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2hhbmRsZVdpZHRoIC8gMiArIExBQkVMX0dBUDtcbiAgICAgIHZhciB0ZXh0UG9pbnQgPSBncmFwaGljLmFwcGx5VHJhbnNmb3JtKFtvcmRlcmVkSGFuZGxlRW5kc1toYW5kbGVJbmRleF0gKyAoaGFuZGxlSW5kZXggPT09IDAgPyAtb2Zmc2V0IDogb2Zmc2V0KSwgdGhpcy5fc2l6ZVsxXSAvIDJdLCBiYXJUcmFuc2Zvcm0pO1xuICAgICAgaGFuZGxlTGFiZWxzW2hhbmRsZUluZGV4XS5zZXRTdHlsZSh7XG4gICAgICAgIHg6IHRleHRQb2ludFswXSxcbiAgICAgICAgeTogdGV4dFBvaW50WzFdLFxuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogb3JpZW50ID09PSBIT1JJWk9OVEFMID8gJ21pZGRsZScgOiBkaXJlY3Rpb24sXG4gICAgICAgIHRleHRBbGlnbjogb3JpZW50ID09PSBIT1JJWk9OVEFMID8gZGlyZWN0aW9uIDogJ2NlbnRlcicsXG4gICAgICAgIHRleHQ6IGxhYmVsVGV4dHNbaGFuZGxlSW5kZXhdXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9ybWF0TGFiZWw6IGZ1bmN0aW9uICh2YWx1ZSwgYXhpcykge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBsYWJlbEZvcm1hdHRlciA9IGRhdGFab29tTW9kZWwuZ2V0KCdsYWJlbEZvcm1hdHRlcicpO1xuICAgIHZhciBsYWJlbFByZWNpc2lvbiA9IGRhdGFab29tTW9kZWwuZ2V0KCdsYWJlbFByZWNpc2lvbicpO1xuXG4gICAgaWYgKGxhYmVsUHJlY2lzaW9uID09IG51bGwgfHwgbGFiZWxQcmVjaXNpb24gPT09ICdhdXRvJykge1xuICAgICAgbGFiZWxQcmVjaXNpb24gPSBheGlzLmdldFBpeGVsUHJlY2lzaW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlU3RyID0gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgPyAnJyAvLyBGSVhNRSBHbHVlIGNvZGVcbiAgICA6IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCBheGlzLnR5cGUgPT09ICd0aW1lJyA/IGF4aXMuc2NhbGUuZ2V0TGFiZWwoTWF0aC5yb3VuZCh2YWx1ZSkpIC8vIHBhcmFtIG9mIHRvRml4ZWQgc2hvdWxkIGxlc3MgdGhlbiAyMC5cbiAgICA6IHZhbHVlLnRvRml4ZWQoTWF0aC5taW4obGFiZWxQcmVjaXNpb24sIDIwKSk7XG4gICAgcmV0dXJuIHpyVXRpbC5pc0Z1bmN0aW9uKGxhYmVsRm9ybWF0dGVyKSA/IGxhYmVsRm9ybWF0dGVyKHZhbHVlLCB2YWx1ZVN0cikgOiB6clV0aWwuaXNTdHJpbmcobGFiZWxGb3JtYXR0ZXIpID8gbGFiZWxGb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIHZhbHVlU3RyKSA6IHZhbHVlU3RyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3dPckhpZGUgdHJ1ZTogc2hvdywgZmFsc2U6IGhpZGVcbiAgICovXG4gIF9zaG93RGF0YUluZm86IGZ1bmN0aW9uIChzaG93T3JIaWRlKSB7XG4gICAgLy8gQWx3YXlzIHNob3cgd2hlbiBkcmdnaW5nLlxuICAgIHNob3dPckhpZGUgPSB0aGlzLl9kcmFnZ2luZyB8fCBzaG93T3JIaWRlO1xuICAgIHZhciBoYW5kbGVMYWJlbHMgPSB0aGlzLl9kaXNwbGF5YWJsZXMuaGFuZGxlTGFiZWxzO1xuICAgIGhhbmRsZUxhYmVsc1swXS5hdHRyKCdpbnZpc2libGUnLCAhc2hvd09ySGlkZSk7XG4gICAgaGFuZGxlTGFiZWxzWzFdLmF0dHIoJ2ludmlzaWJsZScsICFzaG93T3JIaWRlKTtcbiAgfSxcbiAgX29uRHJhZ01vdmU6IGZ1bmN0aW9uIChoYW5kbGVJbmRleCwgZHgsIGR5KSB7XG4gICAgdGhpcy5fZHJhZ2dpbmcgPSB0cnVlOyAvLyBUcmFuc2Zvcm0gZHgsIGR5IHRvIGJhciBjb29yZGluYXRpb24uXG5cbiAgICB2YXIgYmFyVHJhbnNmb3JtID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwLmdldExvY2FsVHJhbnNmb3JtKCk7XG5cbiAgICB2YXIgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybShbZHgsIGR5XSwgYmFyVHJhbnNmb3JtLCB0cnVlKTtcblxuICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKGhhbmRsZUluZGV4LCB2ZXJ0ZXhbMF0pO1xuXG4gICAgdmFyIHJlYWx0aW1lID0gdGhpcy5kYXRhWm9vbU1vZGVsLmdldCgncmVhbHRpbWUnKTtcblxuICAgIHRoaXMuX3VwZGF0ZVZpZXcoIXJlYWx0aW1lKTtcblxuICAgIGlmIChyZWFsdGltZSkge1xuICAgICAgcmVhbHRpbWUgJiYgdGhpcy5fZGlzcGF0Y2hab29tQWN0aW9uKCk7XG4gICAgfVxuICB9LFxuICBfb25EcmFnRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX3Nob3dEYXRhSW5mbyhmYWxzZSk7XG5cbiAgICB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oKTtcbiAgfSxcbiAgX29uQ2xpY2tQYW5lbENsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblxuICAgIHZhciBsb2NhbFBvaW50ID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG5cbiAgICBpZiAobG9jYWxQb2ludFswXSA8IDAgfHwgbG9jYWxQb2ludFswXSA+IHNpemVbMF0gfHwgbG9jYWxQb2ludFsxXSA8IDAgfHwgbG9jYWxQb2ludFsxXSA+IHNpemVbMV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlRW5kcyA9IHRoaXMuX2hhbmRsZUVuZHM7XG4gICAgdmFyIGNlbnRlciA9IChoYW5kbGVFbmRzWzBdICsgaGFuZGxlRW5kc1sxXSkgLyAyO1xuXG4gICAgdGhpcy5fdXBkYXRlSW50ZXJ2YWwoJ2FsbCcsIGxvY2FsUG9pbnRbMF0gLSBjZW50ZXIpO1xuXG4gICAgdGhpcy5fdXBkYXRlVmlldygpO1xuXG4gICAgdGhpcy5fZGlzcGF0Y2hab29tQWN0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgYWN0aW9uIHdpbGwgYmUgdGhyb3R0bGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rpc3BhdGNoWm9vbUFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdkYXRhWm9vbScsXG4gICAgICBmcm9tOiB0aGlzLnVpZCxcbiAgICAgIGRhdGFab29tSWQ6IHRoaXMuZGF0YVpvb21Nb2RlbC5pZCxcbiAgICAgIHN0YXJ0OiByYW5nZVswXSxcbiAgICAgIGVuZDogcmFuZ2VbMV1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9maW5kQ29vcmRSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRmluZCB0aGUgZ3JpZCBjb3Jlc3BvbmRpbmcgdG8gdGhlIGZpcnN0IGF4aXMgcmVmZXJyZWQgYnkgZGF0YVpvb20uXG4gICAgdmFyIHJlY3Q7XG4gICAgZWFjaCh0aGlzLmdldFRhcmdldENvb3JkSW5mbygpLCBmdW5jdGlvbiAoY29vcmRJbmZvTGlzdCkge1xuICAgICAgaWYgKCFyZWN0ICYmIGNvb3JkSW5mb0xpc3QubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb29yZFN5cyA9IGNvb3JkSW5mb0xpc3RbMF0ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgcmVjdCA9IGNvb3JkU3lzLmdldFJlY3QgJiYgY29vcmRTeXMuZ2V0UmVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmFwaS5nZXRXaWR0aCgpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYXBpLmdldEhlaWdodCgpO1xuICAgICAgcmVjdCA9IHtcbiAgICAgICAgeDogd2lkdGggKiAwLjIsXG4gICAgICAgIHk6IGhlaWdodCAqIDAuMixcbiAgICAgICAgd2lkdGg6IHdpZHRoICogMC42LFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIDAuNlxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldE90aGVyRGltKHRoaXNEaW0pIHtcbiAgLy8gRklYTUVcbiAgLy8g6L+Z5Liq6YC76L6R5ZKMZ2V0T3RoZXJBeGlz6YeM5LiA6Ie077yM5L2G5piv5YaZ5Zyo6L+Z6YeM5piv5ZCm5LiN5aW9XG4gIHZhciBtYXAgPSB7XG4gICAgeDogJ3knLFxuICAgIHk6ICd4JyxcbiAgICByYWRpdXM6ICdhbmdsZScsXG4gICAgYW5nbGU6ICdyYWRpdXMnXG4gIH07XG4gIHJldHVybiBtYXBbdGhpc0RpbV07XG59XG5cbmZ1bmN0aW9uIGdldEN1cnNvcihvcmllbnQpIHtcbiAgcmV0dXJuIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICducy1yZXNpemUnIDogJ2V3LXJlc2l6ZSc7XG59XG5cbnZhciBfZGVmYXVsdCA9IFNsaWRlclpvb21WaWV3O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2xpZGVyWm9vbVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgaGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKCdkYXRhWm9vbScsIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gIHZhciBsaW5rZWROb2Rlc0ZpbmRlciA9IGhlbHBlci5jcmVhdGVMaW5rZWROb2Rlc0ZpbmRlcih6clV0aWwuYmluZChlY01vZGVsLmVhY2hDb21wb25lbnQsIGVjTW9kZWwsICdkYXRhWm9vbScpLCBoZWxwZXIuZWFjaEF4aXNEaW0sIGZ1bmN0aW9uIChtb2RlbCwgZGltTmFtZXMpIHtcbiAgICByZXR1cm4gbW9kZWwuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCk7XG4gIH0pO1xuICB2YXIgZWZmZWN0ZWRNb2RlbHMgPSBbXTtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICBtYWluVHlwZTogJ2RhdGFab29tJyxcbiAgICBxdWVyeTogcGF5bG9hZFxuICB9LCBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7XG4gICAgZWZmZWN0ZWRNb2RlbHMucHVzaC5hcHBseShlZmZlY3RlZE1vZGVscywgbGlua2VkTm9kZXNGaW5kZXIobW9kZWwpLm5vZGVzKTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKGVmZmVjdGVkTW9kZWxzLCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgaW5kZXgpIHtcbiAgICBkYXRhWm9vbU1vZGVsLnNldFJhd1JhbmdlKHtcbiAgICAgIHN0YXJ0OiBwYXlsb2FkLnN0YXJ0LFxuICAgICAgZW5kOiBwYXlsb2FkLmVuZCxcbiAgICAgIHN0YXJ0VmFsdWU6IHBheWxvYWQuc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlOiBwYXlsb2FkLmVuZFZhbHVlXG4gICAgfSk7XG4gIH0pO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2RhdGFab29tQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vZGF0YVpvb21BY3Rpb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG5lY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdkYXRhWm9vbScsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgLy8gV2UgY2FsY3VsYXRlIHdpbmRvdyBhbmQgcmVzZXQgYXhpcyBoZXJlIGJ1dCBub3QgaW4gbW9kZWxcbiAgICAvLyBpbml0IHN0YWdlIGFuZCBub3QgYWZ0ZXIgYWN0aW9uIGRpc3BhdGNoIGhhbmRsZXIsIGJlY2F1c2VcbiAgICAvLyByZXNldCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHNlcmllc0RhdGEucmVzdG9yZURhdGEuXG4gICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhyZXNldFNpbmdsZUF4aXMpOyAvLyBDYXV0aW9uOiBkYXRhIHpvb20gZmlsdGVyaW5nIGlzIG9yZGVyIHNlbnNpdGl2ZSB3aGVuIHVzaW5nXG4gICAgLy8gcGVyY2VudCByYW5nZSBhbmQgbm8gbWluL21heC9zY2FsZSBzZXQgb24gYXhpcy5cbiAgICAvLyBGb3IgZXhhbXBsZSwgd2UgaGF2ZSBkYXRhWm9vbSBkZWZpbml0aW9uOlxuICAgIC8vIFtcbiAgICAvLyAgICAgIHt4QXhpc0luZGV4OiAwLCBzdGFydDogMzAsIGVuZDogNzB9LFxuICAgIC8vICAgICAge3lBeGlzSW5kZXg6IDAsIHN0YXJ0OiAyMCwgZW5kOiA4MH1cbiAgICAvLyBdXG4gICAgLy8gSW4gdGhpcyBjYXNlLCBbMjAsIDgwXSBvZiB5LWRhdGFab29tIHNob3VsZCBiZSBiYXNlZCBvbiBkYXRhXG4gICAgLy8gdGhhdCBoYXZlIGZpbHRlcmVkIGJ5IHgtZGF0YVpvb20gdXNpbmcgcmFuZ2Ugb2YgWzMwLCA3MF0sXG4gICAgLy8gYnV0IHNob3VsZCBub3QgYmUgYmFzZWQgb24gZnVsbCByYXcgZGF0YS4gVGh1cyBzbGlkaW5nXG4gICAgLy8geC1kYXRhWm9vbSB3aWxsIGNoYW5nZSBib3RoIHJhbmdlcyBvZiB4QXhpcyBhbmQgeUF4aXMsXG4gICAgLy8gd2hpbGUgc2xpZGluZyB5LWRhdGFab29tIHdpbGwgb25seSBjaGFuZ2UgdGhlIHJhbmdlIG9mIHlBeGlzLlxuICAgIC8vIFNvIHdlIHNob3VsZCBmaWx0ZXIgeC1heGlzIGFmdGVyIHJlc2V0IHgtYXhpcyBpbW1lZGlhdGVseSxcbiAgICAvLyBhbmQgdGhlbiByZXNldCB5LWF4aXMgYW5kIGZpbHRlciB5LWF4aXMuXG5cbiAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZpbHRlclNpbmdsZUF4aXMpO1xuICB9KTtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdkYXRhWm9vbScsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgLy8gRnVsbGZpbGwgYWxsIG9mIHRoZSByYW5nZSBwcm9wcyBzbyB0aGF0IHVzZXJcbiAgICAvLyBpcyBhYmxlIHRvIGdldCB0aGVtIGZyb20gY2hhcnQuZ2V0T3B0aW9uKCkuXG4gICAgdmFyIGF4aXNQcm94eSA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG4gICAgdmFyIHBlcmNlbnRSYW5nZSA9IGF4aXNQcm94eS5nZXREYXRhUGVyY2VudFdpbmRvdygpO1xuICAgIHZhciB2YWx1ZVJhbmdlID0gYXhpc1Byb3h5LmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgIGRhdGFab29tTW9kZWwuc2V0UmF3UmFuZ2Uoe1xuICAgICAgc3RhcnQ6IHBlcmNlbnRSYW5nZVswXSxcbiAgICAgIGVuZDogcGVyY2VudFJhbmdlWzFdLFxuICAgICAgc3RhcnRWYWx1ZTogdmFsdWVSYW5nZVswXSxcbiAgICAgIGVuZFZhbHVlOiB2YWx1ZVJhbmdlWzFdXG4gICAgfSwgdHJ1ZSk7XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIHJlc2V0U2luZ2xlQXhpcyhkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsKSB7XG4gIGRhdGFab29tTW9kZWwuZ2V0QXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCkucmVzZXQoZGF0YVpvb21Nb2RlbCk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclNpbmdsZUF4aXMoZGltTmFtZXMsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCkge1xuICBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShkaW1OYW1lcy5uYW1lLCBheGlzSW5kZXgpLmZpbHRlckRhdGEoZGF0YVpvb21Nb2RlbCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2RhdGFab29tUHJvY2Vzc29yLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vZGF0YVpvb21Qcm9jZXNzb3IuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBBWElTX0RJTVMgPSBbJ3gnLCAneScsICd6JywgJ3JhZGl1cycsICdhbmdsZScsICdzaW5nbGUnXTsgLy8gU3VwcG9ydGVkIGNvb3Jkcy5cblxudmFyIENPT1JEUyA9IFsnY2FydGVzaWFuMmQnLCAncG9sYXInLCAnc2luZ2xlQXhpcyddO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29vcmRUeXBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzQ29vcmRTdXBwb3J0ZWQoY29vcmRUeXBlKSB7XG4gIHJldHVybiB6clV0aWwuaW5kZXhPZihDT09SRFMsIGNvb3JkVHlwZSkgPj0gMDtcbn1cbi8qKlxuICogQ3JlYXRlIFwiZWFjaFwiIG1ldGhvZCB0byBpdGVyYXRlIG5hbWVzLlxuICpcbiAqIEBwdWJpbGNcbiAqIEBwYXJhbSAge0FycmF5LjxzdHJpbmc+fSBuYW1lc1xuICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz49fSBhdHRyc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVOYW1lRWFjaChuYW1lcywgYXR0cnMpIHtcbiAgbmFtZXMgPSBuYW1lcy5zbGljZSgpO1xuICB2YXIgY2FwaXRhbE5hbWVzID0genJVdGlsLm1hcChuYW1lcywgZm9ybWF0VXRpbC5jYXBpdGFsRmlyc3QpO1xuICBhdHRycyA9IChhdHRycyB8fCBbXSkuc2xpY2UoKTtcbiAgdmFyIGNhcGl0YWxBdHRycyA9IHpyVXRpbC5tYXAoYXR0cnMsIGZvcm1hdFV0aWwuY2FwaXRhbEZpcnN0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHpyVXRpbC5lYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBuYW1lT2JqID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBjYXBpdGFsOiBjYXBpdGFsTmFtZXNbaW5kZXhdXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGF0dHJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG5hbWVPYmpbYXR0cnNbal1dID0gbmFtZSArIGNhcGl0YWxBdHRyc1tqXTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBuYW1lT2JqKTtcbiAgICB9KTtcbiAgfTtcbn1cbi8qKlxuICogSXRlcmF0ZSBlYWNoIGRpbWVuc2lvbiBuYW1lLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBwYXJhbWV0ZXIgaXMgbGlrZTpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYW5nbGUnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcGl0YWw6ICdBbmdsZScsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpczogJ2FuZ2xlQXhpcycsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4OiAnYW5nbGVBaXhzJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogJ2FuZ2xlSW5kZXgnXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5cblxudmFyIGVhY2hBeGlzRGltID0gY3JlYXRlTmFtZUVhY2goQVhJU19ESU1TLCBbJ2F4aXNJbmRleCcsICdheGlzJywgJ2luZGV4JywgJ2lkJ10pO1xuLyoqXG4gKiBJZiB0b3cgZGF0YVpvb21Nb2RlbHMgaGFzIHRoZSBzYW1lIGF4aXMgY29udHJvbGxlZCwgd2Ugc2F5IHRoYXQgdGhleSBhcmUgJ2xpbmtlZCcuXG4gKiBkYXRhWm9vbU1vZGVscyBhbmQgJ2xpbmtzJyBtYWtlIHVwIG9uZSBvciBtb3JlIGdyYXBoaWNzLlxuICogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgZ3JhcGhpYyB3aGVyZSB0aGUgc291cmNlIGRhdGFab29tTW9kZWwgaXMgaW4uXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm9yRWFjaE5vZGUgTm9kZSBpdGVyYXRvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZvckVhY2hFZGdlVHlwZSBlZGdlVHlwZSBpdGVyYXRvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWRnZUlkR2V0dGVyIEdpdmluZyBub2RlIGFuZCBlZGdlVHlwZSwgcmV0dXJuIGFuIGFycmF5IG9mIGVkZ2UgaWQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gSW5wdXQ6IHNvdXJjZU5vZGUsIE91dHB1dDogTGlrZSB7bm9kZXM6IFtdLCBkaW1zOiB7fX1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVMaW5rZWROb2Rlc0ZpbmRlcihmb3JFYWNoTm9kZSwgZm9yRWFjaEVkZ2VUeXBlLCBlZGdlSWRHZXR0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2VOb2RlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIG5vZGVzOiBbXSxcbiAgICAgIHJlY29yZHM6IHt9IC8vIGtleTogZWRnZVR5cGUubmFtZSwgdmFsdWU6IE9iamVjdCAoa2V5OiBlZGdlIGlkLCB2YWx1ZTogYm9vbGVhbikuXG5cbiAgICB9O1xuICAgIGZvckVhY2hFZGdlVHlwZShmdW5jdGlvbiAoZWRnZVR5cGUpIHtcbiAgICAgIHJlc3VsdC5yZWNvcmRzW2VkZ2VUeXBlLm5hbWVdID0ge307XG4gICAgfSk7XG5cbiAgICBpZiAoIXNvdXJjZU5vZGUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYWJzb3JiKHNvdXJjZU5vZGUsIHJlc3VsdCk7XG4gICAgdmFyIGV4aXN0c0xpbms7XG5cbiAgICBkbyB7XG4gICAgICBleGlzdHNMaW5rID0gZmFsc2U7XG4gICAgICBmb3JFYWNoTm9kZShwcm9jZXNzU2luZ2xlTm9kZSk7XG4gICAgfSB3aGlsZSAoZXhpc3RzTGluayk7XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzU2luZ2xlTm9kZShub2RlKSB7XG4gICAgICBpZiAoIWlzTm9kZUFic29yZGVkKG5vZGUsIHJlc3VsdCkgJiYgaXNMaW5rZWQobm9kZSwgcmVzdWx0KSkge1xuICAgICAgICBhYnNvcmIobm9kZSwgcmVzdWx0KTtcbiAgICAgICAgZXhpc3RzTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBmdW5jdGlvbiBpc05vZGVBYnNvcmRlZChub2RlLCByZXN1bHQpIHtcbiAgICByZXR1cm4genJVdGlsLmluZGV4T2YocmVzdWx0Lm5vZGVzLCBub2RlKSA+PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW5rZWQobm9kZSwgcmVzdWx0KSB7XG4gICAgdmFyIGhhc0xpbmsgPSBmYWxzZTtcbiAgICBmb3JFYWNoRWRnZVR5cGUoZnVuY3Rpb24gKGVkZ2VUeXBlKSB7XG4gICAgICB6clV0aWwuZWFjaChlZGdlSWRHZXR0ZXIobm9kZSwgZWRnZVR5cGUpIHx8IFtdLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIHJlc3VsdC5yZWNvcmRzW2VkZ2VUeXBlLm5hbWVdW2VkZ2VJZF0gJiYgKGhhc0xpbmsgPSB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBoYXNMaW5rO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJzb3JiKG5vZGUsIHJlc3VsdCkge1xuICAgIHJlc3VsdC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIGZvckVhY2hFZGdlVHlwZShmdW5jdGlvbiAoZWRnZVR5cGUpIHtcbiAgICAgIHpyVXRpbC5lYWNoKGVkZ2VJZEdldHRlcihub2RlLCBlZGdlVHlwZSkgfHwgW10sIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV1bZWRnZUlkXSA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnRzLmlzQ29vcmRTdXBwb3J0ZWQgPSBpc0Nvb3JkU3VwcG9ydGVkO1xuZXhwb3J0cy5jcmVhdGVOYW1lRWFjaCA9IGNyZWF0ZU5hbWVFYWNoO1xuZXhwb3J0cy5lYWNoQXhpc0RpbSA9IGVhY2hBeGlzRGltO1xuZXhwb3J0cy5jcmVhdGVMaW5rZWROb2Rlc0ZpbmRlciA9IGNyZWF0ZUxpbmtlZE5vZGVzRmluZGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9oZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9oZWxwZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBBVFRSID0gJ1xcMF9lY19oaXN0X3N0b3JlJztcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTbmFwc2hvdCB7ZGF0YVpvb21JZCwgYmF0Y2g6IFtwYXlsb2FkSW5mbywgLi4uXX1cbiAqL1xuXG5mdW5jdGlvbiBwdXNoKGVjTW9kZWwsIG5ld1NuYXBzaG90KSB7XG4gIHZhciBzdG9yZSA9IGdpdmVTdG9yZShlY01vZGVsKTsgLy8gSWYgcHJldmlvdXMgZGF0YVpvb20gY2FuIG5vdCBiZSBmb3VuZCxcbiAgLy8gY29tcGxldGUgYW4gcmFuZ2Ugd2l0aCBjdXJyZW50IHJhbmdlLlxuXG4gIGVhY2gobmV3U25hcHNob3QsIGZ1bmN0aW9uIChiYXRjaEl0ZW0sIGRhdGFab29tSWQpIHtcbiAgICB2YXIgaSA9IHN0b3JlLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBzbmFwc2hvdCA9IHN0b3JlW2ldO1xuXG4gICAgICBpZiAoc25hcHNob3RbZGF0YVpvb21JZF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICAvLyBObyBvcmlnaW4gcmFuZ2Ugc2V0LCBjcmVhdGUgb25lIGJ5IGN1cnJlbnQgcmFuZ2UuXG4gICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgbWFpblR5cGU6ICdkYXRhWm9vbScsXG4gICAgICAgIHN1YlR5cGU6ICdzZWxlY3QnLFxuICAgICAgICBpZDogZGF0YVpvb21JZFxuICAgICAgfSlbMF07XG5cbiAgICAgIGlmIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgIHZhciBwZXJjZW50UmFuZ2UgPSBkYXRhWm9vbU1vZGVsLmdldFBlcmNlbnRSYW5nZSgpO1xuICAgICAgICBzdG9yZVswXVtkYXRhWm9vbUlkXSA9IHtcbiAgICAgICAgICBkYXRhWm9vbUlkOiBkYXRhWm9vbUlkLFxuICAgICAgICAgIHN0YXJ0OiBwZXJjZW50UmFuZ2VbMF0sXG4gICAgICAgICAgZW5kOiBwZXJjZW50UmFuZ2VbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzdG9yZS5wdXNoKG5ld1NuYXBzaG90KTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEByZXR1cm4ge09iamVjdH0gc25hcHNob3RcbiAqL1xuXG5cbmZ1bmN0aW9uIHBvcChlY01vZGVsKSB7XG4gIHZhciBzdG9yZSA9IGdpdmVTdG9yZShlY01vZGVsKTtcbiAgdmFyIGhlYWQgPSBzdG9yZVtzdG9yZS5sZW5ndGggLSAxXTtcbiAgc3RvcmUubGVuZ3RoID4gMSAmJiBzdG9yZS5wb3AoKTsgLy8gRmluZCB0b3AgZm9yIGFsbCBkYXRhWm9vbS5cblxuICB2YXIgc25hcHNob3QgPSB7fTtcbiAgZWFjaChoZWFkLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBkYXRhWm9vbUlkKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0b3JlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYmF0Y2hJdGVtID0gc3RvcmVbaV1bZGF0YVpvb21JZF07XG5cbiAgICAgIGlmIChiYXRjaEl0ZW0pIHtcbiAgICAgICAgc25hcHNob3RbZGF0YVpvb21JZF0gPSBiYXRjaEl0ZW07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzbmFwc2hvdDtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsZWFyKGVjTW9kZWwpIHtcbiAgZWNNb2RlbFtBVFRSXSA9IG51bGw7XG59XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHJlY29yZHMuIGFsd2F5cyA+PSAxLlxuICovXG5cblxuZnVuY3Rpb24gY291bnQoZWNNb2RlbCkge1xuICByZXR1cm4gZ2l2ZVN0b3JlKGVjTW9kZWwpLmxlbmd0aDtcbn1cbi8qKlxuICogW3trZXk6IGRhdGFab29tSWQsIHZhbHVlOiB7ZGF0YVpvb21JZCwgcmFuZ2V9fSwgLi4uXVxuICogSGlzdG9yeSBsZW5ndGggb2YgZWFjaCBkYXRhWm9vbSBtYXkgYmUgZGlmZmVyZW50LlxuICogdGhpcy5faGlzdG9yeVswXSBpcyB1c2VkIHRvIHN0b3JlIG9yaWdpbiByYW5nZS5cbiAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdpdmVTdG9yZShlY01vZGVsKSB7XG4gIHZhciBzdG9yZSA9IGVjTW9kZWxbQVRUUl07XG5cbiAgaWYgKCFzdG9yZSkge1xuICAgIHN0b3JlID0gZWNNb2RlbFtBVFRSXSA9IFt7fV07XG4gIH1cblxuICByZXR1cm4gc3RvcmU7XG59XG5cbmV4cG9ydHMucHVzaCA9IHB1c2g7XG5leHBvcnRzLnBvcCA9IHBvcDtcbmV4cG9ydHMuY2xlYXIgPSBjbGVhcjtcbmV4cG9ydHMuY291bnQgPSBjb3VudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2hpc3RvcnkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFJvYW1Db250cm9sbGVyID0gcmVxdWlyZShcIi4uLy4uL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXJcIik7XG5cbnZhciB0aHJvdHRsZVV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC90aHJvdHRsZVwiKTtcblxuLy8gT25seSBjcmVhdGUgb25lIHJvYW0gY29udHJvbGxlciBmb3IgZWFjaCBjb29yZGluYXRlIHN5c3RlbS5cbi8vIG9uZSByb2FtIGNvbnRyb2xsZXIgbWlnaHQgYmUgcmVmZXJlZCBieSB0d28gaW5zaWRlIGRhdGEgem9vbVxuLy8gY29tcG9uZW50cyAoZm9yIGV4YW1wbGUsIG9uZSBmb3IgeCBhbmQgb25lIGZvciB5KS4gV2hlbiB1c2VyXG4vLyBwYW4gb3Igem9vbSwgb25seSBkaXNwYXRjaCBvbmUgYWN0aW9uIGZvciB0aG9zZSBkYXRhIHpvb21cbi8vIGNvbXBvbmVudHMuXG52YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG52YXIgQVRUUiA9ICdcXDBfZWNfZGF0YVpvb21fcm9hbXMnO1xuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVpvb21JbmZvXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVpvb21JbmZvLmNvb3JkSWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRhdGFab29tSW5mby5jb250YWluc1BvaW50XG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBkYXRhWm9vbUluZm8uYWxsQ29vcmRJZHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhWm9vbUluZm8uZGF0YVpvb21JZFxuICogQHBhcmFtIHtudW1iZXJ9IGRhdGFab29tSW5mby50aHJvdHRsZVJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRhdGFab29tSW5mby5wYW5HZXRSYW5nZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YVpvb21JbmZvLnpvb21HZXRSYW5nZVxuICogQHBhcmFtIHtib29sZWFufSBbZGF0YVpvb21JbmZvLnpvb21Mb2NrXVxuICogQHBhcmFtIHtib29sZWFufSBbZGF0YVpvb21JbmZvLmRpc2FibGVkXVxuICovXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKGFwaSwgZGF0YVpvb21JbmZvKSB7XG4gIHZhciBzdG9yZSA9IGdpdmVTdG9yZShhcGkpO1xuICB2YXIgdGhlRGF0YVpvb21JZCA9IGRhdGFab29tSW5mby5kYXRhWm9vbUlkO1xuICB2YXIgdGhlQ29vcmRJZCA9IGRhdGFab29tSW5mby5jb29yZElkOyAvLyBEbyBjbGVhbiB3aGVuIGEgZGF0YVpvb20gY2hhbmdlcyBpdHMgdGFyZ2V0IGNvb3JkbmF0ZSBzeXN0ZW0uXG4gIC8vIEF2b2lkIG1lbW9yeSBsZWFrLCBkaXNwb3NlIGFsbCBub3QtdXNlZC1yZWdpc3RlcmVkLlxuXG4gIHpyVXRpbC5lYWNoKHN0b3JlLCBmdW5jdGlvbiAocmVjb3JkLCBjb29yZElkKSB7XG4gICAgdmFyIGRhdGFab29tSW5mb3MgPSByZWNvcmQuZGF0YVpvb21JbmZvcztcblxuICAgIGlmIChkYXRhWm9vbUluZm9zW3RoZURhdGFab29tSWRdICYmIHpyVXRpbC5pbmRleE9mKGRhdGFab29tSW5mby5hbGxDb29yZElkcywgdGhlQ29vcmRJZCkgPCAwKSB7XG4gICAgICBkZWxldGUgZGF0YVpvb21JbmZvc1t0aGVEYXRhWm9vbUlkXTtcbiAgICAgIHJlY29yZC5jb3VudC0tO1xuICAgIH1cbiAgfSk7XG4gIGNsZWFuU3RvcmUoc3RvcmUpO1xuICB2YXIgcmVjb3JkID0gc3RvcmVbdGhlQ29vcmRJZF07IC8vIENyZWF0ZSBpZiBuZWVkZWQuXG5cbiAgaWYgKCFyZWNvcmQpIHtcbiAgICByZWNvcmQgPSBzdG9yZVt0aGVDb29yZElkXSA9IHtcbiAgICAgIGNvb3JkSWQ6IHRoZUNvb3JkSWQsXG4gICAgICBkYXRhWm9vbUluZm9zOiB7fSxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgICByZWNvcmQuY29udHJvbGxlciA9IGNyZWF0ZUNvbnRyb2xsZXIoYXBpLCByZWNvcmQpO1xuICAgIHJlY29yZC5kaXNwYXRjaEFjdGlvbiA9IHpyVXRpbC5jdXJyeShkaXNwYXRjaEFjdGlvbiwgYXBpKTtcbiAgfSAvLyBVcGRhdGUgcmVmZXJlbmNlIG9mIGRhdGFab29tLlxuXG5cbiAgIXJlY29yZC5kYXRhWm9vbUluZm9zW3RoZURhdGFab29tSWRdICYmIHJlY29yZC5jb3VudCsrO1xuICByZWNvcmQuZGF0YVpvb21JbmZvc1t0aGVEYXRhWm9vbUlkXSA9IGRhdGFab29tSW5mbztcbiAgdmFyIGNvbnRyb2xsZXJQYXJhbXMgPSBtZXJnZUNvbnRyb2xsZXJQYXJhbXMocmVjb3JkLmRhdGFab29tSW5mb3MpO1xuICByZWNvcmQuY29udHJvbGxlci5lbmFibGUoY29udHJvbGxlclBhcmFtcy5jb250cm9sVHlwZSwgY29udHJvbGxlclBhcmFtcy5vcHQpOyAvLyBDb25zaWRlciByZXNpemUsIGFyZWEgc2hvdWxkIGJlIGFsd2F5cyB1cGRhdGVkLlxuXG4gIHJlY29yZC5jb250cm9sbGVyLnNldFBvaW50ZXJDaGVja2VyKGRhdGFab29tSW5mby5jb250YWluc1BvaW50KTsgLy8gVXBkYXRlIHRocm90dGxlLlxuXG4gIHRocm90dGxlVXRpbC5jcmVhdGVPclVwZGF0ZShyZWNvcmQsICdkaXNwYXRjaEFjdGlvbicsIGRhdGFab29tSW5mby50aHJvdHRsZVJhdGUsICdmaXhSYXRlJyk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhWm9vbUlkXG4gKi9cblxuXG5mdW5jdGlvbiB1bnJlZ2lzdGVyKGFwaSwgZGF0YVpvb21JZCkge1xuICB2YXIgc3RvcmUgPSBnaXZlU3RvcmUoYXBpKTtcbiAgenJVdGlsLmVhY2goc3RvcmUsIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICByZWNvcmQuY29udHJvbGxlci5kaXNwb3NlKCk7XG4gICAgdmFyIGRhdGFab29tSW5mb3MgPSByZWNvcmQuZGF0YVpvb21JbmZvcztcblxuICAgIGlmIChkYXRhWm9vbUluZm9zW2RhdGFab29tSWRdKSB7XG4gICAgICBkZWxldGUgZGF0YVpvb21JbmZvc1tkYXRhWm9vbUlkXTtcbiAgICAgIHJlY29yZC5jb3VudC0tO1xuICAgIH1cbiAgfSk7XG4gIGNsZWFuU3RvcmUoc3RvcmUpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBzaG91bGRSZWNvcmRSYW5nZShwYXlsb2FkLCBkYXRhWm9vbUlkKSB7XG4gIGlmIChwYXlsb2FkICYmIHBheWxvYWQudHlwZSA9PT0gJ2RhdGFab29tJyAmJiBwYXlsb2FkLmJhdGNoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBheWxvYWQuYmF0Y2gubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChwYXlsb2FkLmJhdGNoW2ldLmRhdGFab29tSWQgPT09IGRhdGFab29tSWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNvb3JkSWQoY29vcmRNb2RlbCkge1xuICByZXR1cm4gY29vcmRNb2RlbC50eXBlICsgJ1xcMF8nICsgY29vcmRNb2RlbC5pZDtcbn1cbi8qKlxuICogS2V5OiBjb29yZElkLCB2YWx1ZToge2RhdGFab29tSW5mb3M6IFtdLCBjb3VudCwgY29udHJvbGxlcn1cbiAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdpdmVTdG9yZShhcGkpIHtcbiAgLy8gTW91bnQgc3RvcmUgb24genJlbmRlciBpbnN0YW5jZSwgc28gdGhhdCB3ZSBkbyBub3RcbiAgLy8gbmVlZCB0byB3b3JyeSBhYm91dCBkaXNwb3NlLlxuICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgcmV0dXJuIHpyW0FUVFJdIHx8ICh6cltBVFRSXSA9IHt9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udHJvbGxlcihhcGksIG5ld1JlY29yZCkge1xuICB2YXIgY29udHJvbGxlciA9IG5ldyBSb2FtQ29udHJvbGxlcihhcGkuZ2V0WnIoKSk7XG4gIGNvbnRyb2xsZXIub24oJ3BhbicsIGN1cnJ5KG9uUGFuLCBuZXdSZWNvcmQpKTtcbiAgY29udHJvbGxlci5vbignem9vbScsIGN1cnJ5KG9uWm9vbSwgbmV3UmVjb3JkKSk7XG4gIHJldHVybiBjb250cm9sbGVyO1xufVxuXG5mdW5jdGlvbiBjbGVhblN0b3JlKHN0b3JlKSB7XG4gIHpyVXRpbC5lYWNoKHN0b3JlLCBmdW5jdGlvbiAocmVjb3JkLCBjb29yZElkKSB7XG4gICAgaWYgKCFyZWNvcmQuY291bnQpIHtcbiAgICAgIHJlY29yZC5jb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgICAgIGRlbGV0ZSBzdG9yZVtjb29yZElkXTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblBhbihyZWNvcmQsIGR4LCBkeSwgb2xkWCwgb2xkWSwgbmV3WCwgbmV3WSkge1xuICB3cmFwQW5kRGlzcGF0Y2gocmVjb3JkLCBmdW5jdGlvbiAoaW5mbykge1xuICAgIHJldHVybiBpbmZvLnBhbkdldFJhbmdlKHJlY29yZC5jb250cm9sbGVyLCBkeCwgZHksIG9sZFgsIG9sZFksIG5ld1gsIG5ld1kpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25ab29tKHJlY29yZCwgc2NhbGUsIG1vdXNlWCwgbW91c2VZKSB7XG4gIHdyYXBBbmREaXNwYXRjaChyZWNvcmQsIGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8uem9vbUdldFJhbmdlKHJlY29yZC5jb250cm9sbGVyLCBzY2FsZSwgbW91c2VYLCBtb3VzZVkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gd3JhcEFuZERpc3BhdGNoKHJlY29yZCwgZ2V0UmFuZ2UpIHtcbiAgdmFyIGJhdGNoID0gW107XG4gIHpyVXRpbC5lYWNoKHJlY29yZC5kYXRhWm9vbUluZm9zLCBmdW5jdGlvbiAoaW5mbykge1xuICAgIHZhciByYW5nZSA9IGdldFJhbmdlKGluZm8pO1xuICAgICFpbmZvLmRpc2FibGVkICYmIHJhbmdlICYmIGJhdGNoLnB1c2goe1xuICAgICAgZGF0YVpvb21JZDogaW5mby5kYXRhWm9vbUlkLFxuICAgICAgc3RhcnQ6IHJhbmdlWzBdLFxuICAgICAgZW5kOiByYW5nZVsxXVxuICAgIH0pO1xuICB9KTtcbiAgcmVjb3JkLmRpc3BhdGNoQWN0aW9uKGJhdGNoKTtcbn1cbi8qKlxuICogVGhpcyBhY3Rpb24gd2lsbCBiZSB0aHJvdHRsZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihhcGksIGJhdGNoKSB7XG4gIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgdHlwZTogJ2RhdGFab29tJyxcbiAgICBiYXRjaDogYmF0Y2hcbiAgfSk7XG59XG4vKipcbiAqIE1lcmdlIHJvYW1Db250cm9sbGVyIHNldHRpbmdzIHdoZW4gbXVsdGlwbGUgZGF0YVpvb21zIHNoYXJlIG9uZSByb2FtQ29udHJvbGxlci5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlQ29udHJvbGxlclBhcmFtcyhkYXRhWm9vbUluZm9zKSB7XG4gIHZhciBjb250cm9sVHlwZTtcbiAgdmFyIG9wdCA9IHt9O1xuICB2YXIgdHlwZVByaW9yaXR5ID0ge1xuICAgICd0cnVlJzogMixcbiAgICAnbW92ZSc6IDEsXG4gICAgJ2ZhbHNlJzogMCxcbiAgICAndW5kZWZpbmVkJzogLTFcbiAgfTtcbiAgenJVdGlsLmVhY2goZGF0YVpvb21JbmZvcywgZnVuY3Rpb24gKGRhdGFab29tSW5mbykge1xuICAgIHZhciBvbmVUeXBlID0gZGF0YVpvb21JbmZvLmRpc2FibGVkID8gZmFsc2UgOiBkYXRhWm9vbUluZm8uem9vbUxvY2sgPyAnbW92ZScgOiB0cnVlO1xuICAgIHR5cGVQcmlvcml0eVtvbmVUeXBlXSA+IHR5cGVQcmlvcml0eVtjb250cm9sVHlwZV0gJiYgKGNvbnRyb2xUeXBlID0gb25lVHlwZSk7IC8vIERvIG5vdCBzdXBwb3J0IHRoYXQgZGlmZmVyZW50ICdzaGlmdCcvJ2N0cmwnLydhbHQnIHNldHRpbmcgdXNlZCBpbiBvbmUgY29vcmQgc3lzLlxuXG4gICAgenJVdGlsLmV4dGVuZChvcHQsIGRhdGFab29tSW5mby5yb2FtQ29udHJvbGxlck9wdCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNvbnRyb2xUeXBlOiBjb250cm9sVHlwZSxcbiAgICBvcHQ6IG9wdFxuICB9O1xufVxuXG5leHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG5leHBvcnRzLnVucmVnaXN0ZXIgPSB1bnJlZ2lzdGVyO1xuZXhwb3J0cy5zaG91bGRSZWNvcmRSYW5nZSA9IHNob3VsZFJlY29yZFJhbmdlO1xuZXhwb3J0cy5nZW5lcmF0ZUNvb3JkSWQgPSBnZW5lcmF0ZUNvb3JkSWQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL3JvYW1zLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vcm9hbXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL0NvbXBvbmVudFwiKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcignZGF0YVpvb20nLCBmdW5jdGlvbiAoKSB7XG4gIC8vIERlZmF1bHQgJ3NsaWRlcicgd2hlbiBubyB0eXBlIHNwZWNpZmllZC5cbiAgcmV0dXJuICdzbGlkZXInO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL3R5cGVEZWZhdWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS90eXBlRGVmYXVsdGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZShcIi4vZGF0YVpvb20vdHlwZURlZmF1bHRlclwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vRGF0YVpvb21Nb2RlbFwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vRGF0YVpvb21WaWV3XCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9TZWxlY3Rab29tTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL1NlbGVjdFpvb21WaWV3XCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3NvclwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vZGF0YVpvb21BY3Rpb25cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tU2VsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb21TZWxlY3QuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vdXRpbC9ncmFwaGljXCIpO1xuXG5yZXF1aXJlKFwiLi4vY29vcmQvY2FydGVzaWFuL0dyaWRcIik7XG5cbnJlcXVpcmUoXCIuL2F4aXNcIik7XG5cbi8vIEdyaWQgdmlld1xuZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ2dyaWQnLFxuICByZW5kZXI6IGZ1bmN0aW9uIChncmlkTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKGdyaWRNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgdGhpcy5ncm91cC5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgIHNoYXBlOiBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCksXG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIGZpbGw6IGdyaWRNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpXG4gICAgICAgIH0sIGdyaWRNb2RlbC5nZXRJdGVtU3R5bGUoKSksXG4gICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgejI6IC0xXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG59KTtcbmVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdGlvbikge1xuICAvLyBPbmx5IGNyZWF0ZSBncmlkIHdoZW4gbmVlZFxuICBpZiAob3B0aW9uLnhBeGlzICYmIG9wdGlvbi55QXhpcyAmJiAhb3B0aW9uLmdyaWQpIHtcbiAgICBvcHRpb24uZ3JpZCA9IHt9O1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZ3JpZFNpbXBsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyaWRTaW1wbGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBpbnRlcmFjdGlvbk11dGV4ID0gcmVxdWlyZShcIi4vaW50ZXJhY3Rpb25NdXRleFwiKTtcblxudmFyIERhdGFEaWZmZXIgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9EYXRhRGlmZmVyXCIpO1xuXG52YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIG1hcCA9IHpyVXRpbC5tYXA7XG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbnZhciBtYXRoUG93ID0gTWF0aC5wb3c7XG52YXIgQ09WRVJfWiA9IDEwMDAwO1xudmFyIFVOU0VMRUNUX1RIUkVTSE9MRCA9IDY7XG52YXIgTUlOX1JFU0laRV9MSU5FX1dJRFRIID0gNjtcbnZhciBNVVRFWF9SRVNPVVJDRV9LRVkgPSAnZ2xvYmFsUGFuJztcbnZhciBESVJFQ1RJT05fTUFQID0ge1xuICB3OiBbMCwgMF0sXG4gIGU6IFswLCAxXSxcbiAgbjogWzEsIDBdLFxuICBzOiBbMSwgMV1cbn07XG52YXIgQ1VSU09SX01BUCA9IHtcbiAgdzogJ2V3JyxcbiAgZTogJ2V3JyxcbiAgbjogJ25zJyxcbiAgczogJ25zJyxcbiAgbmU6ICduZXN3JyxcbiAgc3c6ICduZXN3JyxcbiAgbnc6ICdud3NlJyxcbiAgc2U6ICdud3NlJ1xufTtcbnZhciBERUZBVUxUX0JSVVNIX09QVCA9IHtcbiAgYnJ1c2hTdHlsZToge1xuICAgIGxpbmVXaWR0aDogMixcbiAgICBzdHJva2U6ICdyZ2JhKDAsMCwwLDAuMyknLFxuICAgIGZpbGw6ICdyZ2JhKDAsMCwwLDAuMSknXG4gIH0sXG4gIHRyYW5zZm9ybWFibGU6IHRydWUsXG4gIGJydXNoTW9kZTogJ3NpbmdsZScsXG4gIHJlbW92ZU9uQ2xpY2s6IGZhbHNlXG59O1xudmFyIGJhc2VVSUQgPSAwO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2hlbHBlci9CcnVzaENvbnRyb2xsZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQG1peGluIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAqIEBldmVudCBtb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlciNicnVzaFxuICogICAgICAgIHBhcmFtczpcbiAqICAgICAgICAgICAgYXJlYXM6IEFycmF5LjxBcnJheT4sIGNvb3JkIHJlbGF0ZXMgdG8gY29udGFpbmVyIGdyb3VwLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBubyBjb250YWluZXIgc3BlY2lmaWVkLCB0byBnbG9iYWwuXG4gKiAgICAgICAgICAgIG9wdCB7XG4gKiAgICAgICAgICAgICAgICBpc0VuZDogYm9vbGVhbixcbiAqICAgICAgICAgICAgICAgIHJlbW92ZU9uQ2xpY2s6IGJvb2xlYW5cbiAqICAgICAgICAgICAgfVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvenJlbmRlcn5aUmVuZGVyfSB6clxuICovXG5cbmZ1bmN0aW9uIEJydXNoQ29udHJvbGxlcih6cikge1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL3pyZW5kZXJ+WlJlbmRlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fenIgPSB6cjtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgLyoqXG4gICAqIE9ubHkgZm9yIGRyYXdpbmcgKGFmdGVyIGVuYWJsZWRCcnVzaCkuXG4gICAqICAgICAnbGluZScsICdyZWN0JywgJ3BvbHlnb24nIG9yIGZhbHNlXG4gICAqICAgICBJZiBwYXNzaW5nIGZhbHNlL251bGwvdW5kZWZpbmVkLCBkaXNhYmxlIGJydXNoLlxuICAgKiAgICAgSWYgcGFzc2luZyAnYXV0bycsIGRldGVybWluZWQgYnkgcGFuZWwuZGVmYXVsdEJydXNoVHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLl9icnVzaFR5cGU7XG4gIC8qKlxuICAgKiBPbmx5IGZvciBkcmF3aW5nIChhZnRlciBlbmFibGVkQnJ1c2gpLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9icnVzaE9wdGlvbjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX3BhbmVscztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVibWVyPn1cbiAgICovXG5cbiAgdGhpcy5fdHJhY2sgPSBbXTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuICB0aGlzLl9kcmFnZ2luZztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG5cbiAgdGhpcy5fY292ZXJzID0gW107XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW91ZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICovXG5cbiAgdGhpcy5fY3JlYXRpbmdDb3ZlcjtcbiAgLyoqXG4gICAqIGB0cnVlYCBtZWFucyBnbG9iYWwgcGFuZWxcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cHxib29sZWFufVxuICAgKi9cblxuICB0aGlzLl9jcmVhdGluZ1BhbmVsO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMuX2VuYWJsZUdsb2JhbFBhbjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuX3VpZCA9ICdicnVzaENvbnRyb2xsZXJfJyArIGJhc2VVSUQrKztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGVhY2gobW91c2VIYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSB6clV0aWwuYmluZChoYW5kbGVyLCB0aGlzKTtcbiAgfSwgdGhpcyk7XG59XG5cbkJydXNoQ29udHJvbGxlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBCcnVzaENvbnRyb2xsZXIsXG5cbiAgLyoqXG4gICAqIElmIHNldCB0byBudWxsL3VuZGVmaW5lZC9mYWxzZSwgc2VsZWN0IGRpc2FibGVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYnJ1c2hPcHRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gYnJ1c2hPcHRpb24uYnJ1c2hUeXBlICdsaW5lJywgJ3JlY3QnLCAncG9seWdvbicgb3IgZmFsc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIElmIHBhc3NpbmcgZmFsc2UvbnVsbC91bmRlZmluZWQsIGRpc2FibGUgYnJ1c2guXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBwYXNzaW5nICdhdXRvJywgZGV0ZXJtaW5lZCBieSBwYW5lbC5kZWZhdWx0QnJ1c2hUeXBlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgnYXV0bycgY2FuIG5vdCBiZSB1c2VkIGluIGdsb2JhbCBwYW5lbClcbiAgICogQHBhcmFtIHtudW1iZXJ9IFticnVzaE9wdGlvbi5icnVzaE1vZGU9J3NpbmdsZSddICdzaW5nbGUnIG9yICdtdWx0aXBsZSdcbiAgICogQHBhcmFtIHtib29sZWFufSBbYnJ1c2hPcHRpb24udHJhbnNmb3JtYWJsZT10cnVlXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFticnVzaE9wdGlvbi5yZW1vdmVPbkNsaWNrPWZhbHNlXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2JydXNoT3B0aW9uLmJydXNoU3R5bGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYnJ1c2hPcHRpb24uYnJ1c2hTdHlsZS53aWR0aF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLmxpbmVXaWR0aF1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLnN0cm9rZV1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLmZpbGxdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYnJ1c2hPcHRpb24uel1cbiAgICovXG4gIGVuYWJsZUJydXNoOiBmdW5jdGlvbiAoYnJ1c2hPcHRpb24pIHtcbiAgICB0aGlzLl9icnVzaFR5cGUgJiYgZG9EaXNhYmxlQnJ1c2godGhpcyk7XG4gICAgYnJ1c2hPcHRpb24uYnJ1c2hUeXBlICYmIGRvRW5hYmxlQnJ1c2godGhpcywgYnJ1c2hPcHRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBwYW5lbE9wdHMgSWYgbm90IHBhc3MsIGl0IGlzIGdsb2JhbCBicnVzaC5cbiAgICogICAgICAgIEVhY2ggaXRlbXM6IHtcbiAgICogICAgICAgICAgICBwYW5lbElkLCAvLyBtYW5kYXRvcnkuXG4gICAqICAgICAgICAgICAgY2xpcFBhdGgsIC8vIG1hbmRhdG9yeS4gZnVuY3Rpb24uXG4gICAqICAgICAgICAgICAgaXNUYXJnZXRCeUN1cnNvciwgLy8gbWFuZGF0b3J5LiBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICBkZWZhdWx0QnJ1c2hUeXBlLCAvLyBvcHRpb25hbCwgb25seSB1c2VkIHdoZW4gYnJ1c2hUeXBlIGlzICdhdXRvJy5cbiAgICogICAgICAgICAgICBnZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50LCAvLyBvcHRpb25hbC4gZnVuY3Rpb24uXG4gICAqICAgICAgICB9XG4gICAqL1xuICBzZXRQYW5lbHM6IGZ1bmN0aW9uIChwYW5lbE9wdHMpIHtcbiAgICBpZiAocGFuZWxPcHRzICYmIHBhbmVsT3B0cy5sZW5ndGgpIHtcbiAgICAgIHZhciBwYW5lbHMgPSB0aGlzLl9wYW5lbHMgPSB7fTtcbiAgICAgIHpyVXRpbC5lYWNoKHBhbmVsT3B0cywgZnVuY3Rpb24gKHBhbmVsT3B0cykge1xuICAgICAgICBwYW5lbHNbcGFuZWxPcHRzLnBhbmVsSWRdID0genJVdGlsLmNsb25lKHBhbmVsT3B0cyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFuZWxzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFtvcHQuZW5hYmxlR2xvYmFsUGFuPWZhbHNlXVxuICAgKi9cbiAgbW91bnQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdGhpcy5fZW5hYmxlR2xvYmFsUGFuID0gb3B0LmVuYWJsZUdsb2JhbFBhbjtcbiAgICB2YXIgdGhpc0dyb3VwID0gdGhpcy5ncm91cDtcblxuICAgIHRoaXMuX3pyLmFkZCh0aGlzR3JvdXApO1xuXG4gICAgdGhpc0dyb3VwLmF0dHIoe1xuICAgICAgcG9zaXRpb246IG9wdC5wb3NpdGlvbiB8fCBbMCwgMF0sXG4gICAgICByb3RhdGlvbjogb3B0LnJvdGF0aW9uIHx8IDAsXG4gICAgICBzY2FsZTogb3B0LnNjYWxlIHx8IFsxLCAxXVxuICAgIH0pO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRoaXNHcm91cC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlYWNoQ292ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGVhY2godGhpcy5fY292ZXJzLCBjYiwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjb3ZlcnMuXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGJydXNoT3B0aW9uTGlzdCBMaWtlOlxuICAgKiAgICAgICAgW1xuICAgKiAgICAgICAgICAgIHtpZDogJ3h4JywgYnJ1c2hUeXBlOiAnbGluZScsIHJhbmdlOiBbMjMsIDQ0XSwgYnJ1c2hTdHlsZSwgdHJhbnNmb3JtYWJsZX0sXG4gICAqICAgICAgICAgICAge2lkOiAneXknLCBicnVzaFR5cGU6ICdyZWN0JywgcmFuZ2U6IFtbMjMsIDQ0XSwgWzIzLCA1NF1dfSxcbiAgICogICAgICAgICAgICAuLi5cbiAgICogICAgICAgIF1cbiAgICogICAgICAgIGBicnVzaFR5cGVgIGlzIHJlcXVpcmVkIGluIGVhY2ggY292ZXIgaW5mby4gKGNhbiBub3QgYmUgJ2F1dG8nKVxuICAgKiAgICAgICAgYGlkYCBpcyBub3QgbWFuZGF0b3J5LlxuICAgKiAgICAgICAgYGJydXNoU3R5bGVgLCBgdHJhbnNmb3JtYWJsZWAgaXMgbm90IG1hbmRhdG9yeSwgdXNlIERFRkFVTFRfQlJVU0hfT1BUIGJ5IGRlZmF1bHQuXG4gICAqICAgICAgICBJZiBicnVzaE9wdGlvbkxpc3QgaXMgbnVsbC91bmRlZmluZWQsIGFsbCBjb3ZlcnMgcmVtb3ZlZC5cbiAgICovXG4gIHVwZGF0ZUNvdmVyczogZnVuY3Rpb24gKGJydXNoT3B0aW9uTGlzdCkge1xuICAgIGJydXNoT3B0aW9uTGlzdCA9IHpyVXRpbC5tYXAoYnJ1c2hPcHRpb25MaXN0LCBmdW5jdGlvbiAoYnJ1c2hPcHRpb24pIHtcbiAgICAgIHJldHVybiB6clV0aWwubWVyZ2UoenJVdGlsLmNsb25lKERFRkFVTFRfQlJVU0hfT1BUKSwgYnJ1c2hPcHRpb24sIHRydWUpO1xuICAgIH0pO1xuICAgIHZhciB0bXBJZFByZWZpeCA9ICdcXDAtYnJ1c2gtaW5kZXgtJztcbiAgICB2YXIgb2xkQ292ZXJzID0gdGhpcy5fY292ZXJzO1xuICAgIHZhciBuZXdDb3ZlcnMgPSB0aGlzLl9jb3ZlcnMgPSBbXTtcbiAgICB2YXIgY29udHJvbGxlciA9IHRoaXM7XG4gICAgdmFyIGNyZWF0aW5nQ292ZXIgPSB0aGlzLl9jcmVhdGluZ0NvdmVyO1xuICAgIG5ldyBEYXRhRGlmZmVyKG9sZENvdmVycywgYnJ1c2hPcHRpb25MaXN0LCBvbGRHZXRLZXksIGdldEtleSkuYWRkKGFkZE9yVXBkYXRlKS51cGRhdGUoYWRkT3JVcGRhdGUpLnJlbW92ZShyZW1vdmUpLmV4ZWN1dGUoKTtcbiAgICByZXR1cm4gdGhpcztcblxuICAgIGZ1bmN0aW9uIGdldEtleShicnVzaE9wdGlvbiwgaW5kZXgpIHtcbiAgICAgIHJldHVybiAoYnJ1c2hPcHRpb24uaWQgIT0gbnVsbCA/IGJydXNoT3B0aW9uLmlkIDogdG1wSWRQcmVmaXggKyBpbmRleCkgKyAnLScgKyBicnVzaE9wdGlvbi5icnVzaFR5cGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2xkR2V0S2V5KGNvdmVyLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGdldEtleShjb3Zlci5fX2JydXNoT3B0aW9uLCBpbmRleCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkT3JVcGRhdGUobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICB2YXIgbmV3QnJ1c2hPcHRpb24gPSBicnVzaE9wdGlvbkxpc3RbbmV3SW5kZXhdOyAvLyBDb25zaWRlciBzZXRPcHRpb24gaW4gZXZlbnQgbGlzdGVuZXIgb2YgYnJ1c2hTZWxlY3QsXG4gICAgICAvLyB3aGVyZSB1cGRhdGluZyBjb3ZlciB3aGVuIGNyZWF0aW5nIHNob3VsZCBiZSBmb3JiaWRlbi5cblxuICAgICAgaWYgKG9sZEluZGV4ICE9IG51bGwgJiYgb2xkQ292ZXJzW29sZEluZGV4XSA9PT0gY3JlYXRpbmdDb3Zlcikge1xuICAgICAgICBuZXdDb3ZlcnNbbmV3SW5kZXhdID0gb2xkQ292ZXJzW29sZEluZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb3ZlciA9IG5ld0NvdmVyc1tuZXdJbmRleF0gPSBvbGRJbmRleCAhPSBudWxsID8gKG9sZENvdmVyc1tvbGRJbmRleF0uX19icnVzaE9wdGlvbiA9IG5ld0JydXNoT3B0aW9uLCBvbGRDb3ZlcnNbb2xkSW5kZXhdKSA6IGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIG5ld0JydXNoT3B0aW9uKSk7XG4gICAgICAgIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKG9sZEluZGV4KSB7XG4gICAgICBpZiAob2xkQ292ZXJzW29sZEluZGV4XSAhPT0gY3JlYXRpbmdDb3Zlcikge1xuICAgICAgICBjb250cm9sbGVyLmdyb3VwLnJlbW92ZShvbGRDb3ZlcnNbb2xkSW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuYWJsZUJydXNoKGZhbHNlKTsgLy8gY29udGFpbmVyIG1heSAncmVtb3ZlQWxsJyBvdXRzaWRlLlxuXG4gICAgY2xlYXJDb3ZlcnModGhpcyk7XG5cbiAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5ncm91cCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudW5tb3VudCgpO1xuICAgIHRoaXMub2ZmKCk7XG4gIH1cbn07XG56clV0aWwubWl4aW4oQnJ1c2hDb250cm9sbGVyLCBFdmVudGZ1bCk7XG5cbmZ1bmN0aW9uIGRvRW5hYmxlQnJ1c2goY29udHJvbGxlciwgYnJ1c2hPcHRpb24pIHtcbiAgdmFyIHpyID0gY29udHJvbGxlci5fenI7IC8vIENvbnNpZGVyIHJvYW0sIHdoaWNoIHRha2VzIGdsb2JhbFBhbiB0b28uXG5cbiAgaWYgKCFjb250cm9sbGVyLl9lbmFibGVHbG9iYWxQYW4pIHtcbiAgICBpbnRlcmFjdGlvbk11dGV4LnRha2UoenIsIE1VVEVYX1JFU09VUkNFX0tFWSwgY29udHJvbGxlci5fdWlkKTtcbiAgfVxuXG4gIGVhY2goY29udHJvbGxlci5faGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyLCBldmVudE5hbWUpIHtcbiAgICB6ci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICB9KTtcbiAgY29udHJvbGxlci5fYnJ1c2hUeXBlID0gYnJ1c2hPcHRpb24uYnJ1c2hUeXBlO1xuICBjb250cm9sbGVyLl9icnVzaE9wdGlvbiA9IHpyVXRpbC5tZXJnZSh6clV0aWwuY2xvbmUoREVGQVVMVF9CUlVTSF9PUFQpLCBicnVzaE9wdGlvbiwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGRvRGlzYWJsZUJydXNoKGNvbnRyb2xsZXIpIHtcbiAgdmFyIHpyID0gY29udHJvbGxlci5fenI7XG4gIGludGVyYWN0aW9uTXV0ZXgucmVsZWFzZSh6ciwgTVVURVhfUkVTT1VSQ0VfS0VZLCBjb250cm9sbGVyLl91aWQpO1xuICBlYWNoKGNvbnRyb2xsZXIuX2hhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlciwgZXZlbnROYW1lKSB7XG4gICAgenIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gIH0pO1xuICBjb250cm9sbGVyLl9icnVzaFR5cGUgPSBjb250cm9sbGVyLl9icnVzaE9wdGlvbiA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKSB7XG4gIHZhciBjb3ZlciA9IGNvdmVyUmVuZGVyZXJzW2JydXNoT3B0aW9uLmJydXNoVHlwZV0uY3JlYXRlQ292ZXIoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pO1xuICBjb3Zlci5fX2JydXNoT3B0aW9uID0gYnJ1c2hPcHRpb247XG4gIHVwZGF0ZVooY292ZXIsIGJydXNoT3B0aW9uKTtcbiAgY29udHJvbGxlci5ncm91cC5hZGQoY292ZXIpO1xuICByZXR1cm4gY292ZXI7XG59XG5cbmZ1bmN0aW9uIGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpIHtcbiAgdmFyIGNvdmVyUmVuZGVyZXIgPSBnZXRDb3ZlclJlbmRlcmVyKGNyZWF0aW5nQ292ZXIpO1xuXG4gIGlmIChjb3ZlclJlbmRlcmVyLmVuZENyZWF0aW5nKSB7XG4gICAgY292ZXJSZW5kZXJlci5lbmRDcmVhdGluZyhjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKTtcbiAgICB1cGRhdGVaKGNyZWF0aW5nQ292ZXIsIGNyZWF0aW5nQ292ZXIuX19icnVzaE9wdGlvbik7XG4gIH1cblxuICByZXR1cm4gY3JlYXRpbmdDb3Zlcjtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ292ZXJTaGFwZShjb250cm9sbGVyLCBjb3Zlcikge1xuICB2YXIgYnJ1c2hPcHRpb24gPSBjb3Zlci5fX2JydXNoT3B0aW9uO1xuICBnZXRDb3ZlclJlbmRlcmVyKGNvdmVyKS51cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCBicnVzaE9wdGlvbi5yYW5nZSwgYnJ1c2hPcHRpb24pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVaKGNvdmVyLCBicnVzaE9wdGlvbikge1xuICB2YXIgeiA9IGJydXNoT3B0aW9uLno7XG4gIHogPT0gbnVsbCAmJiAoeiA9IENPVkVSX1opO1xuICBjb3Zlci50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC56ID0gejtcbiAgICBlbC56MiA9IHo7IC8vIENvbnNpZGVyIGluIGdpdmVuIGNvbnRhaW5lci5cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcikge1xuICBnZXRDb3ZlclJlbmRlcmVyKGNvdmVyKS51cGRhdGVDb21tb24oY29udHJvbGxlciwgY292ZXIpO1xuICB1cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q292ZXJSZW5kZXJlcihjb3Zlcikge1xuICByZXR1cm4gY292ZXJSZW5kZXJlcnNbY292ZXIuX19icnVzaE9wdGlvbi5icnVzaFR5cGVdO1xufSAvLyByZXR1cm4gdGFyZ2V0IHBhbmVsIG9yIGB0cnVlYCAobWVhbnMgZ2xvYmFsIHBhbmVsKVxuXG5cbmZ1bmN0aW9uIGdldFBhbmVsQnlQb2ludChjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50KSB7XG4gIHZhciBwYW5lbHMgPSBjb250cm9sbGVyLl9wYW5lbHM7XG5cbiAgaWYgKCFwYW5lbHMpIHtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gR2xvYmFsIHBhbmVsXG4gIH1cblxuICB2YXIgcGFuZWw7XG4gIHZhciB0cmFuc2Zvcm0gPSBjb250cm9sbGVyLl90cmFuc2Zvcm07XG4gIGVhY2gocGFuZWxzLCBmdW5jdGlvbiAocG4pIHtcbiAgICBwbi5pc1RhcmdldEJ5Q3Vyc29yKGUsIGxvY2FsQ3Vyc29yUG9pbnQsIHRyYW5zZm9ybSkgJiYgKHBhbmVsID0gcG4pO1xuICB9KTtcbiAgcmV0dXJuIHBhbmVsO1xufSAvLyBSZXR1cm4gYSBwYW5lbCBvciB0cnVlXG5cblxuZnVuY3Rpb24gZ2V0UGFuZWxCeUNvdmVyKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gIHZhciBwYW5lbHMgPSBjb250cm9sbGVyLl9wYW5lbHM7XG5cbiAgaWYgKCFwYW5lbHMpIHtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gR2xvYmFsIHBhbmVsXG4gIH1cblxuICB2YXIgcGFuZWxJZCA9IGNvdmVyLl9fYnJ1c2hPcHRpb24ucGFuZWxJZDsgLy8gVXNlciBtYXkgZ2l2ZSBjb3ZlciB3aXRob3V0IGNvb3JkIHN5cyBpbmZvLFxuICAvLyB3aGljaCBpcyB0aGVuIHRyZWF0ZWQgYXMgZ2xvYmFsIHBhbmVsLlxuXG4gIHJldHVybiBwYW5lbElkICE9IG51bGwgPyBwYW5lbHNbcGFuZWxJZF0gOiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjbGVhckNvdmVycyhjb250cm9sbGVyKSB7XG4gIHZhciBjb3ZlcnMgPSBjb250cm9sbGVyLl9jb3ZlcnM7XG4gIHZhciBvcmlnaW5hbExlbmd0aCA9IGNvdmVycy5sZW5ndGg7XG4gIGVhY2goY292ZXJzLCBmdW5jdGlvbiAoY292ZXIpIHtcbiAgICBjb250cm9sbGVyLmdyb3VwLnJlbW92ZShjb3Zlcik7XG4gIH0sIGNvbnRyb2xsZXIpO1xuICBjb3ZlcnMubGVuZ3RoID0gMDtcbiAgcmV0dXJuICEhb3JpZ2luYWxMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIoY29udHJvbGxlciwgb3B0KSB7XG4gIHZhciBhcmVhcyA9IG1hcChjb250cm9sbGVyLl9jb3ZlcnMsIGZ1bmN0aW9uIChjb3Zlcikge1xuICAgIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gICAgdmFyIHJhbmdlID0genJVdGlsLmNsb25lKGJydXNoT3B0aW9uLnJhbmdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgYnJ1c2hUeXBlOiBicnVzaE9wdGlvbi5icnVzaFR5cGUsXG4gICAgICBwYW5lbElkOiBicnVzaE9wdGlvbi5wYW5lbElkLFxuICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgfTtcbiAgfSk7XG4gIGNvbnRyb2xsZXIudHJpZ2dlcignYnJ1c2gnLCBhcmVhcywge1xuICAgIGlzRW5kOiAhIW9wdC5pc0VuZCxcbiAgICByZW1vdmVPbkNsaWNrOiAhIW9wdC5yZW1vdmVPbkNsaWNrXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzaG91bGRTaG93Q292ZXIoY29udHJvbGxlcikge1xuICB2YXIgdHJhY2sgPSBjb250cm9sbGVyLl90cmFjaztcblxuICBpZiAoIXRyYWNrLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwMiA9IHRyYWNrW3RyYWNrLmxlbmd0aCAtIDFdO1xuICB2YXIgcDEgPSB0cmFja1swXTtcbiAgdmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcbiAgdmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcbiAgdmFyIGRpc3QgPSBtYXRoUG93KGR4ICogZHggKyBkeSAqIGR5LCAwLjUpO1xuICByZXR1cm4gZGlzdCA+IFVOU0VMRUNUX1RIUkVTSE9MRDtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2tFbmRzKHRyYWNrKSB7XG4gIHZhciB0YWlsID0gdHJhY2subGVuZ3RoIC0gMTtcbiAgdGFpbCA8IDAgJiYgKHRhaWwgPSAwKTtcbiAgcmV0dXJuIFt0cmFja1swXSwgdHJhY2tbdGFpbF1dO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCYXNlUmVjdENvdmVyKGRvRHJpZnQsIGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uLCBlZGdlTmFtZXMpIHtcbiAgdmFyIGNvdmVyID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgY292ZXIuYWRkKG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIG5hbWU6ICdtYWluJyxcbiAgICBzdHlsZTogbWFrZVN0eWxlKGJydXNoT3B0aW9uKSxcbiAgICBzaWxlbnQ6IHRydWUsXG4gICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgIGN1cnNvcjogJ21vdmUnLFxuICAgIGRyaWZ0OiBjdXJyeShkb0RyaWZ0LCBjb250cm9sbGVyLCBjb3ZlciwgJ25zd2UnKSxcbiAgICBvbmRyYWdlbmQ6IGN1cnJ5KHRyaWdnZXIsIGNvbnRyb2xsZXIsIHtcbiAgICAgIGlzRW5kOiB0cnVlXG4gICAgfSlcbiAgfSkpO1xuICBlYWNoKGVkZ2VOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSxcbiAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgIGRyaWZ0OiBjdXJyeShkb0RyaWZ0LCBjb250cm9sbGVyLCBjb3ZlciwgbmFtZSksXG4gICAgICBvbmRyYWdlbmQ6IGN1cnJ5KHRyaWdnZXIsIGNvbnRyb2xsZXIsIHtcbiAgICAgICAgaXNFbmQ6IHRydWVcbiAgICAgIH0pXG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIGNvdmVyO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVCYXNlUmVjdChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgdmFyIGxpbmVXaWR0aCA9IGJydXNoT3B0aW9uLmJydXNoU3R5bGUubGluZVdpZHRoIHx8IDA7XG4gIHZhciBoYW5kbGVTaXplID0gbWF0aE1heChsaW5lV2lkdGgsIE1JTl9SRVNJWkVfTElORV9XSURUSCk7XG4gIHZhciB4ID0gbG9jYWxSYW5nZVswXVswXTtcbiAgdmFyIHkgPSBsb2NhbFJhbmdlWzFdWzBdO1xuICB2YXIgeGEgPSB4IC0gbGluZVdpZHRoIC8gMjtcbiAgdmFyIHlhID0geSAtIGxpbmVXaWR0aCAvIDI7XG4gIHZhciB4MiA9IGxvY2FsUmFuZ2VbMF1bMV07XG4gIHZhciB5MiA9IGxvY2FsUmFuZ2VbMV1bMV07XG4gIHZhciB4MmEgPSB4MiAtIGhhbmRsZVNpemUgKyBsaW5lV2lkdGggLyAyO1xuICB2YXIgeTJhID0geTIgLSBoYW5kbGVTaXplICsgbGluZVdpZHRoIC8gMjtcbiAgdmFyIHdpZHRoID0geDIgLSB4O1xuICB2YXIgaGVpZ2h0ID0geTIgLSB5O1xuICB2YXIgd2lkdGhhID0gd2lkdGggKyBsaW5lV2lkdGg7XG4gIHZhciBoZWlnaHRhID0gaGVpZ2h0ICsgbGluZVdpZHRoO1xuICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdtYWluJywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgaWYgKGJydXNoT3B0aW9uLnRyYW5zZm9ybWFibGUpIHtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICd3JywgeGEsIHlhLCBoYW5kbGVTaXplLCBoZWlnaHRhKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdlJywgeDJhLCB5YSwgaGFuZGxlU2l6ZSwgaGVpZ2h0YSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnbicsIHhhLCB5YSwgd2lkdGhhLCBoYW5kbGVTaXplKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdzJywgeGEsIHkyYSwgd2lkdGhhLCBoYW5kbGVTaXplKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdudycsIHhhLCB5YSwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnbmUnLCB4MmEsIHlhLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdzdycsIHhhLCB5MmEsIGhhbmRsZVNpemUsIGhhbmRsZVNpemUpO1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ3NlJywgeDJhLCB5MmEsIGhhbmRsZVNpemUsIGhhbmRsZVNpemUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbW1vbihjb250cm9sbGVyLCBjb3Zlcikge1xuICB2YXIgYnJ1c2hPcHRpb24gPSBjb3Zlci5fX2JydXNoT3B0aW9uO1xuICB2YXIgdHJhbnNmb3JtYWJsZSA9IGJydXNoT3B0aW9uLnRyYW5zZm9ybWFibGU7XG4gIHZhciBtYWluRWwgPSBjb3Zlci5jaGlsZEF0KDApO1xuICBtYWluRWwudXNlU3R5bGUobWFrZVN0eWxlKGJydXNoT3B0aW9uKSk7XG4gIG1haW5FbC5hdHRyKHtcbiAgICBzaWxlbnQ6ICF0cmFuc2Zvcm1hYmxlLFxuICAgIGN1cnNvcjogdHJhbnNmb3JtYWJsZSA/ICdtb3ZlJyA6ICdkZWZhdWx0J1xuICB9KTtcbiAgZWFjaChbJ3cnLCAnZScsICduJywgJ3MnLCAnc2UnLCAnc3cnLCAnbmUnLCAnbncnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZWwgPSBjb3Zlci5jaGlsZE9mTmFtZShuYW1lKTtcbiAgICB2YXIgZ2xvYmFsRGlyID0gZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIG5hbWUpO1xuICAgIGVsICYmIGVsLmF0dHIoe1xuICAgICAgc2lsZW50OiAhdHJhbnNmb3JtYWJsZSxcbiAgICAgIGludmlzaWJsZTogIXRyYW5zZm9ybWFibGUsXG4gICAgICBjdXJzb3I6IHRyYW5zZm9ybWFibGUgPyBDVVJTT1JfTUFQW2dsb2JhbERpcl0gKyAnLXJlc2l6ZScgOiBudWxsXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsIG5hbWUsIHgsIHksIHcsIGgpIHtcbiAgdmFyIGVsID0gY292ZXIuY2hpbGRPZk5hbWUobmFtZSk7XG4gIGVsICYmIGVsLnNldFNoYXBlKHBvaW50c1RvUmVjdChjbGlwQnlQYW5lbChjb250cm9sbGVyLCBjb3ZlciwgW1t4LCB5XSwgW3ggKyB3LCB5ICsgaF1dKSkpO1xufVxuXG5mdW5jdGlvbiBtYWtlU3R5bGUoYnJ1c2hPcHRpb24pIHtcbiAgcmV0dXJuIHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICB9LCBicnVzaE9wdGlvbi5icnVzaFN0eWxlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UmVjdFJhbmdlKHgsIHksIHgyLCB5Mikge1xuICB2YXIgbWluID0gW21hdGhNaW4oeCwgeDIpLCBtYXRoTWluKHksIHkyKV07XG4gIHZhciBtYXggPSBbbWF0aE1heCh4LCB4MiksIG1hdGhNYXgoeSwgeTIpXTtcbiAgcmV0dXJuIFtbbWluWzBdLCBtYXhbMF1dLCAvLyB4IHJhbmdlXG4gIFttaW5bMV0sIG1heFsxXV0gLy8geSByYW5nZVxuICBdO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm0oY29udHJvbGxlcikge1xuICByZXR1cm4gZ3JhcGhpYy5nZXRUcmFuc2Zvcm0oY29udHJvbGxlci5ncm91cCk7XG59XG5cbmZ1bmN0aW9uIGdldEdsb2JhbERpcmVjdGlvbihjb250cm9sbGVyLCBsb2NhbERpcmVjdGlvbikge1xuICBpZiAobG9jYWxEaXJlY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgIGxvY2FsRGlyZWN0aW9uID0gbG9jYWxEaXJlY3Rpb24uc3BsaXQoJycpO1xuICAgIHZhciBnbG9iYWxEaXIgPSBbZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIGxvY2FsRGlyZWN0aW9uWzBdKSwgZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIGxvY2FsRGlyZWN0aW9uWzFdKV07XG4gICAgKGdsb2JhbERpclswXSA9PT0gJ2UnIHx8IGdsb2JhbERpclswXSA9PT0gJ3cnKSAmJiBnbG9iYWxEaXIucmV2ZXJzZSgpO1xuICAgIHJldHVybiBnbG9iYWxEaXIuam9pbignJyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHc6ICdsZWZ0JyxcbiAgICAgIGU6ICdyaWdodCcsXG4gICAgICBuOiAndG9wJyxcbiAgICAgIHM6ICdib3R0b20nXG4gICAgfTtcbiAgICB2YXIgaW52ZXJzZU1hcCA9IHtcbiAgICAgIGxlZnQ6ICd3JyxcbiAgICAgIHJpZ2h0OiAnZScsXG4gICAgICB0b3A6ICduJyxcbiAgICAgIGJvdHRvbTogJ3MnXG4gICAgfTtcbiAgICB2YXIgZ2xvYmFsRGlyID0gZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24obWFwW2xvY2FsRGlyZWN0aW9uXSwgZ2V0VHJhbnNmb3JtKGNvbnRyb2xsZXIpKTtcbiAgICByZXR1cm4gaW52ZXJzZU1hcFtnbG9iYWxEaXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyaWZ0UmVjdCh0b1JlY3RSYW5nZSwgZnJvbVJlY3RSYW5nZSwgY29udHJvbGxlciwgY292ZXIsIG5hbWUsIGR4LCBkeSwgZSkge1xuICB2YXIgYnJ1c2hPcHRpb24gPSBjb3Zlci5fX2JydXNoT3B0aW9uO1xuICB2YXIgcmVjdFJhbmdlID0gdG9SZWN0UmFuZ2UoYnJ1c2hPcHRpb24ucmFuZ2UpO1xuICB2YXIgbG9jYWxEZWx0YSA9IHRvTG9jYWxEZWx0YShjb250cm9sbGVyLCBkeCwgZHkpO1xuICBlYWNoKG5hbWUuc3BsaXQoJycpLCBmdW5jdGlvbiAobmFtZVBhcnQpIHtcbiAgICB2YXIgaW5kID0gRElSRUNUSU9OX01BUFtuYW1lUGFydF07XG4gICAgcmVjdFJhbmdlW2luZFswXV1baW5kWzFdXSArPSBsb2NhbERlbHRhW2luZFswXV07XG4gIH0pO1xuICBicnVzaE9wdGlvbi5yYW5nZSA9IGZyb21SZWN0UmFuZ2UoZm9ybWF0UmVjdFJhbmdlKHJlY3RSYW5nZVswXVswXSwgcmVjdFJhbmdlWzFdWzBdLCByZWN0UmFuZ2VbMF1bMV0sIHJlY3RSYW5nZVsxXVsxXSkpO1xuICB1cGRhdGVDb3ZlckFmdGVyQ3JlYXRpb24oY29udHJvbGxlciwgY292ZXIpO1xuICB0cmlnZ2VyKGNvbnRyb2xsZXIsIHtcbiAgICBpc0VuZDogZmFsc2VcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRyaWZ0UG9seWdvbihjb250cm9sbGVyLCBjb3ZlciwgZHgsIGR5LCBlKSB7XG4gIHZhciByYW5nZSA9IGNvdmVyLl9fYnJ1c2hPcHRpb24ucmFuZ2U7XG4gIHZhciBsb2NhbERlbHRhID0gdG9Mb2NhbERlbHRhKGNvbnRyb2xsZXIsIGR4LCBkeSk7XG4gIGVhY2gocmFuZ2UsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHBvaW50WzBdICs9IGxvY2FsRGVsdGFbMF07XG4gICAgcG9pbnRbMV0gKz0gbG9jYWxEZWx0YVsxXTtcbiAgfSk7XG4gIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcik7XG4gIHRyaWdnZXIoY29udHJvbGxlciwge1xuICAgIGlzRW5kOiBmYWxzZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdG9Mb2NhbERlbHRhKGNvbnRyb2xsZXIsIGR4LCBkeSkge1xuICB2YXIgdGhpc0dyb3VwID0gY29udHJvbGxlci5ncm91cDtcbiAgdmFyIGxvY2FsRCA9IHRoaXNHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoZHgsIGR5KTtcbiAgdmFyIGxvY2FsWmVybyA9IHRoaXNHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoMCwgMCk7XG4gIHJldHVybiBbbG9jYWxEWzBdIC0gbG9jYWxaZXJvWzBdLCBsb2NhbERbMV0gLSBsb2NhbFplcm9bMV1dO1xufVxuXG5mdW5jdGlvbiBjbGlwQnlQYW5lbChjb250cm9sbGVyLCBjb3ZlciwgZGF0YSkge1xuICB2YXIgcGFuZWwgPSBnZXRQYW5lbEJ5Q292ZXIoY29udHJvbGxlciwgY292ZXIpO1xuICByZXR1cm4gcGFuZWwgJiYgcGFuZWwgIT09IHRydWUgPyBwYW5lbC5jbGlwUGF0aChkYXRhLCBjb250cm9sbGVyLl90cmFuc2Zvcm0pIDogenJVdGlsLmNsb25lKGRhdGEpO1xufVxuXG5mdW5jdGlvbiBwb2ludHNUb1JlY3QocG9pbnRzKSB7XG4gIHZhciB4bWluID0gbWF0aE1pbihwb2ludHNbMF1bMF0sIHBvaW50c1sxXVswXSk7XG4gIHZhciB5bWluID0gbWF0aE1pbihwb2ludHNbMF1bMV0sIHBvaW50c1sxXVsxXSk7XG4gIHZhciB4bWF4ID0gbWF0aE1heChwb2ludHNbMF1bMF0sIHBvaW50c1sxXVswXSk7XG4gIHZhciB5bWF4ID0gbWF0aE1heChwb2ludHNbMF1bMV0sIHBvaW50c1sxXVsxXSk7XG4gIHJldHVybiB7XG4gICAgeDogeG1pbixcbiAgICB5OiB5bWluLFxuICAgIHdpZHRoOiB4bWF4IC0geG1pbixcbiAgICBoZWlnaHQ6IHltYXggLSB5bWluXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3Vyc29yKGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpIHtcbiAgLy8gQ2hlY2sgYWN0aXZlXG4gIGlmICghY29udHJvbGxlci5fYnJ1c2hUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHpyID0gY29udHJvbGxlci5fenI7XG4gIHZhciBjb3ZlcnMgPSBjb250cm9sbGVyLl9jb3ZlcnM7XG4gIHZhciBjdXJyUGFuZWwgPSBnZXRQYW5lbEJ5UG9pbnQoY29udHJvbGxlciwgZSwgbG9jYWxDdXJzb3JQb2ludCk7IC8vIENoZWNrIHdoZXRoZXIgaW4gY292ZXJzLlxuXG4gIGlmICghY29udHJvbGxlci5fZHJhZ2dpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJydXNoT3B0aW9uID0gY292ZXJzW2ldLl9fYnJ1c2hPcHRpb247XG5cbiAgICAgIGlmIChjdXJyUGFuZWwgJiYgKGN1cnJQYW5lbCA9PT0gdHJ1ZSB8fCBicnVzaE9wdGlvbi5wYW5lbElkID09PSBjdXJyUGFuZWwucGFuZWxJZCkgJiYgY292ZXJSZW5kZXJlcnNbYnJ1c2hPcHRpb24uYnJ1c2hUeXBlXS5jb250YWluKGNvdmVyc1tpXSwgbG9jYWxDdXJzb3JQb2ludFswXSwgbG9jYWxDdXJzb3JQb2ludFsxXSkpIHtcbiAgICAgICAgLy8gVXNlIGN1cnNvciBzdHlsZSBzZXQgb24gY292ZXIuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdXJyUGFuZWwgJiYgenIuc2V0Q3Vyc29yU3R5bGUoJ2Nyb3NzaGFpcicpO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XG4gIHZhciByYXdFID0gZS5ldmVudDtcbiAgcmF3RS5wcmV2ZW50RGVmYXVsdCAmJiByYXdFLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIG1haW5TaGFwZUNvbnRhaW4oY292ZXIsIHgsIHkpIHtcbiAgcmV0dXJuIGNvdmVyLmNoaWxkT2ZOYW1lKCdtYWluJykuY29udGFpbih4LCB5KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ292ZXJCeU1vdXNlKGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQsIGlzRW5kKSB7XG4gIHZhciBjcmVhdGluZ0NvdmVyID0gY29udHJvbGxlci5fY3JlYXRpbmdDb3ZlcjtcbiAgdmFyIHBhbmVsID0gY29udHJvbGxlci5fY3JlYXRpbmdQYW5lbDtcbiAgdmFyIHRoaXNCcnVzaE9wdGlvbiA9IGNvbnRyb2xsZXIuX2JydXNoT3B0aW9uO1xuICB2YXIgZXZlbnRQYXJhbXM7XG5cbiAgY29udHJvbGxlci5fdHJhY2sucHVzaChsb2NhbEN1cnNvclBvaW50LnNsaWNlKCkpO1xuXG4gIGlmIChzaG91bGRTaG93Q292ZXIoY29udHJvbGxlcikgfHwgY3JlYXRpbmdDb3Zlcikge1xuICAgIGlmIChwYW5lbCAmJiAhY3JlYXRpbmdDb3Zlcikge1xuICAgICAgdGhpc0JydXNoT3B0aW9uLmJydXNoTW9kZSA9PT0gJ3NpbmdsZScgJiYgY2xlYXJDb3ZlcnMoY29udHJvbGxlcik7XG4gICAgICB2YXIgYnJ1c2hPcHRpb24gPSB6clV0aWwuY2xvbmUodGhpc0JydXNoT3B0aW9uKTtcbiAgICAgIGJydXNoT3B0aW9uLmJydXNoVHlwZSA9IGRldGVybWluZUJydXNoVHlwZShicnVzaE9wdGlvbi5icnVzaFR5cGUsIHBhbmVsKTtcbiAgICAgIGJydXNoT3B0aW9uLnBhbmVsSWQgPSBwYW5lbCA9PT0gdHJ1ZSA/IG51bGwgOiBwYW5lbC5wYW5lbElkO1xuICAgICAgY3JlYXRpbmdDb3ZlciA9IGNvbnRyb2xsZXIuX2NyZWF0aW5nQ292ZXIgPSBjcmVhdGVDb3Zlcihjb250cm9sbGVyLCBicnVzaE9wdGlvbik7XG5cbiAgICAgIGNvbnRyb2xsZXIuX2NvdmVycy5wdXNoKGNyZWF0aW5nQ292ZXIpO1xuICAgIH1cblxuICAgIGlmIChjcmVhdGluZ0NvdmVyKSB7XG4gICAgICB2YXIgY292ZXJSZW5kZXJlciA9IGNvdmVyUmVuZGVyZXJzW2RldGVybWluZUJydXNoVHlwZShjb250cm9sbGVyLl9icnVzaFR5cGUsIHBhbmVsKV07XG4gICAgICB2YXIgY292ZXJCcnVzaE9wdGlvbiA9IGNyZWF0aW5nQ292ZXIuX19icnVzaE9wdGlvbjtcbiAgICAgIGNvdmVyQnJ1c2hPcHRpb24ucmFuZ2UgPSBjb3ZlclJlbmRlcmVyLmdldENyZWF0aW5nUmFuZ2UoY2xpcEJ5UGFuZWwoY29udHJvbGxlciwgY3JlYXRpbmdDb3ZlciwgY29udHJvbGxlci5fdHJhY2spKTtcblxuICAgICAgaWYgKGlzRW5kKSB7XG4gICAgICAgIGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgICAgICBjb3ZlclJlbmRlcmVyLnVwZGF0ZUNvbW1vbihjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlQ292ZXJTaGFwZShjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKTtcbiAgICAgIGV2ZW50UGFyYW1zID0ge1xuICAgICAgICBpc0VuZDogaXNFbmRcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW5kICYmIHRoaXNCcnVzaE9wdGlvbi5icnVzaE1vZGUgPT09ICdzaW5nbGUnICYmIHRoaXNCcnVzaE9wdGlvbi5yZW1vdmVPbkNsaWNrKSB7XG4gICAgLy8gSGVscCB1c2VyIHRvIHJlbW92ZSBjb3ZlcnMgZWFzaWx5LCBvbmx5IGJ5IGEgdGlueSBkcmFnLCBpbiAnc2luZ2xlJyBtb2RlLlxuICAgIC8vIEJ1dCBhIHNpbmdsZSBjbGljayBkbyBub3QgY2xlYXIgY292ZXJzLCBiZWNhdXNlIHVzZXIgbWF5IGhhdmUgY2FzdWFsXG4gICAgLy8gY2xpY2tzIChmb3IgZXhhbXBsZSwgY2xpY2sgb24gb3RoZXIgY29tcG9uZW50IGFuZCBkbyBub3QgZXhwZWN0IGNvdmVyc1xuICAgIC8vIGRpc2FwcGVhcikuXG4gICAgLy8gT25seSBzb21lIGNvdmVyIHJlbW92ZWQsIHRyaWdnZXIgYWN0aW9uLCBidXQgbm90IGV2ZXJ5IGNsaWNrIHRyaWdnZXIgYWN0aW9uLlxuICAgIGlmIChnZXRQYW5lbEJ5UG9pbnQoY29udHJvbGxlciwgZSwgbG9jYWxDdXJzb3JQb2ludCkgJiYgY2xlYXJDb3ZlcnMoY29udHJvbGxlcikpIHtcbiAgICAgIGV2ZW50UGFyYW1zID0ge1xuICAgICAgICBpc0VuZDogaXNFbmQsXG4gICAgICAgIHJlbW92ZU9uQ2xpY2s6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50UGFyYW1zO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVCcnVzaFR5cGUoYnJ1c2hUeXBlLCBwYW5lbCkge1xuICBpZiAoYnJ1c2hUeXBlID09PSAnYXV0bycpIHtcbiAgICByZXR1cm4gcGFuZWwuZGVmYXVsdEJydXNoVHlwZTtcbiAgfVxuXG4gIHJldHVybiBicnVzaFR5cGU7XG59XG5cbnZhciBtb3VzZUhhbmRsZXJzID0ge1xuICBtb3VzZWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuX2RyYWdnaW5nKSB7XG4gICAgICAvLyBJbiBjYXNlIHNvbWUgYnJvd3NlciBkbyBub3Qgc3VwcG9ydCBnbG9iYWxPdXQsXG4gICAgICAvLyBhbmQgcmVsZWFzZSBtb3NlIG91dCBzaWRlIHRoZSBicm93c2VyLlxuICAgICAgaGFuZGxlRHJhZ0VuZC5jYWxsKHRoaXMsIGUpO1xuICAgIH0gZWxzZSBpZiAoIWUudGFyZ2V0IHx8ICFlLnRhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgdmFyIGxvY2FsQ3Vyc29yUG9pbnQgPSB0aGlzLmdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgICB0aGlzLl9jcmVhdGluZ0NvdmVyID0gbnVsbDtcbiAgICAgIHZhciBwYW5lbCA9IHRoaXMuX2NyZWF0aW5nUGFuZWwgPSBnZXRQYW5lbEJ5UG9pbnQodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCk7XG5cbiAgICAgIGlmIChwYW5lbCkge1xuICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3RyYWNrID0gW2xvY2FsQ3Vyc29yUG9pbnQuc2xpY2UoKV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGxvY2FsQ3Vyc29yUG9pbnQgPSB0aGlzLmdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgcmVzZXRDdXJzb3IodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCk7XG5cbiAgICBpZiAodGhpcy5fZHJhZ2dpbmcpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgdmFyIGV2ZW50UGFyYW1zID0gdXBkYXRlQ292ZXJCeU1vdXNlKHRoaXMsIGUsIGxvY2FsQ3Vyc29yUG9pbnQsIGZhbHNlKTtcbiAgICAgIGV2ZW50UGFyYW1zICYmIHRyaWdnZXIodGhpcywgZXZlbnRQYXJhbXMpO1xuICAgIH1cbiAgfSxcbiAgbW91c2V1cDogaGFuZGxlRHJhZ0VuZCAvLyxcbiAgLy8gRklYTUVcbiAgLy8gaW4gdG9vbHRpcCwgZ2xvYmFsb3V0IHNob3VsZCBub3QgYmUgdHJpZ2dlcmVkLlxuICAvLyBnbG9iYWxvdXQ6IGhhbmRsZURyYWdFbmRcblxufTtcblxuZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZChlKSB7XG4gIGlmICh0aGlzLl9kcmFnZ2luZykge1xuICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgIHZhciBsb2NhbEN1cnNvclBvaW50ID0gdGhpcy5ncm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xuICAgIHZhciBldmVudFBhcmFtcyA9IHVwZGF0ZUNvdmVyQnlNb3VzZSh0aGlzLCBlLCBsb2NhbEN1cnNvclBvaW50LCB0cnVlKTtcbiAgICB0aGlzLl9kcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX3RyYWNrID0gW107XG4gICAgdGhpcy5fY3JlYXRpbmdDb3ZlciA9IG51bGw7IC8vIHRyaWdnZXIgZXZlbnQgc2hvdWxlIGJlIGF0IGZpbmFsLCBhZnRlciBwcm9jZWR1cmUgd2lsbCBiZSBuZXN0ZWQuXG5cbiAgICBldmVudFBhcmFtcyAmJiB0cmlnZ2VyKHRoaXMsIGV2ZW50UGFyYW1zKTtcbiAgfVxufVxuLyoqXG4gKiBrZXk6IGJydXNoVHlwZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5cbnZhciBjb3ZlclJlbmRlcmVycyA9IHtcbiAgbGluZVg6IGdldExpbmVSZW5kZXJlcigwKSxcbiAgbGluZVk6IGdldExpbmVSZW5kZXJlcigxKSxcbiAgcmVjdDoge1xuICAgIGNyZWF0ZUNvdmVyOiBmdW5jdGlvbiAoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pIHtcbiAgICAgIHJldHVybiBjcmVhdGVCYXNlUmVjdENvdmVyKGN1cnJ5KGRyaWZ0UmVjdCwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICB9KSwgY29udHJvbGxlciwgYnJ1c2hPcHRpb24sIFsndycsICdlJywgJ24nLCAncycsICdzZScsICdzdycsICduZScsICdudyddKTtcbiAgICB9LFxuICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICB2YXIgZW5kcyA9IGdldFRyYWNrRW5kcyhsb2NhbFRyYWNrKTtcbiAgICAgIHJldHVybiBmb3JtYXRSZWN0UmFuZ2UoZW5kc1sxXVswXSwgZW5kc1sxXVsxXSwgZW5kc1swXVswXSwgZW5kc1swXVsxXSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb3ZlclNoYXBlOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gICAgICB1cGRhdGVCYXNlUmVjdChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pO1xuICAgIH0sXG4gICAgdXBkYXRlQ29tbW9uOiB1cGRhdGVDb21tb24sXG4gICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICB9LFxuICBwb2x5Z29uOiB7XG4gICAgY3JlYXRlQ292ZXI6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgdmFyIGNvdmVyID0gbmV3IGdyYXBoaWMuR3JvdXAoKTsgLy8gRG8gbm90IHVzZSBncmFwaGljLlBvbHlnb24gYmVjYXVzZSBncmFwaGljLlBvbHlsaW5lIGRvIG5vdCBjbG9zZSB0aGVcbiAgICAgIC8vIGJvcmRlciBvZiB0aGUgc2hhcGUgd2hlbiBkcmF3aW5nLCB3aGljaCBpcyBhIGJldHRlciBleHBlcmllbmNlIGZvciB1c2VyLlxuXG4gICAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgIHN0eWxlOiBtYWtlU3R5bGUoYnJ1c2hPcHRpb24pLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjb3ZlcjtcbiAgICB9LFxuICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICByZXR1cm4gbG9jYWxUcmFjaztcbiAgICB9LFxuICAgIGVuZENyZWF0aW5nOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIpIHtcbiAgICAgIGNvdmVyLnJlbW92ZShjb3Zlci5jaGlsZEF0KDApKTsgLy8gVXNlIGdyYXBoaWMuUG9seWdvbiBjbG9zZSB0aGUgc2hhcGUuXG5cbiAgICAgIGNvdmVyLmFkZChuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcbiAgICAgICAgbmFtZTogJ21haW4nLFxuICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIGRyaWZ0OiBjdXJyeShkcmlmdFBvbHlnb24sIGNvbnRyb2xsZXIsIGNvdmVyKSxcbiAgICAgICAgb25kcmFnZW5kOiBjdXJyeSh0cmlnZ2VyLCBjb250cm9sbGVyLCB7XG4gICAgICAgICAgaXNFbmQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvdmVyU2hhcGU6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgICAgIGNvdmVyLmNoaWxkQXQoMCkuc2V0U2hhcGUoe1xuICAgICAgICBwb2ludHM6IGNsaXBCeVBhbmVsKGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb21tb246IHVwZGF0ZUNvbW1vbixcbiAgICBjb250YWluOiBtYWluU2hhcGVDb250YWluXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldExpbmVSZW5kZXJlcih4eUluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ292ZXI6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJhc2VSZWN0Q292ZXIoY3VycnkoZHJpZnRSZWN0LCBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIHJlY3RSYW5nZSA9IFtyYW5nZSwgWzAsIDEwMF1dO1xuICAgICAgICB4eUluZGV4ICYmIHJlY3RSYW5nZS5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiByZWN0UmFuZ2U7XG4gICAgICB9LCBmdW5jdGlvbiAocmVjdFJhbmdlKSB7XG4gICAgICAgIHJldHVybiByZWN0UmFuZ2VbeHlJbmRleF07XG4gICAgICB9KSwgY29udHJvbGxlciwgYnJ1c2hPcHRpb24sIFtbJ3cnLCAnZSddLCBbJ24nLCAncyddXVt4eUluZGV4XSk7XG4gICAgfSxcbiAgICBnZXRDcmVhdGluZ1JhbmdlOiBmdW5jdGlvbiAobG9jYWxUcmFjaykge1xuICAgICAgdmFyIGVuZHMgPSBnZXRUcmFja0VuZHMobG9jYWxUcmFjayk7XG4gICAgICB2YXIgbWluID0gbWF0aE1pbihlbmRzWzBdW3h5SW5kZXhdLCBlbmRzWzFdW3h5SW5kZXhdKTtcbiAgICAgIHZhciBtYXggPSBtYXRoTWF4KGVuZHNbMF1beHlJbmRleF0sIGVuZHNbMV1beHlJbmRleF0pO1xuICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfSxcbiAgICB1cGRhdGVDb3ZlclNoYXBlOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gICAgICB2YXIgb3RoZXJFeHRlbnQ7IC8vIElmIGJydXNoV2lkdGggbm90IHNwZWNpZmllZCwgZml0IHRoZSBwYW5lbC5cblxuICAgICAgdmFyIHBhbmVsID0gZ2V0UGFuZWxCeUNvdmVyKGNvbnRyb2xsZXIsIGNvdmVyKTtcblxuICAgICAgaWYgKHBhbmVsICE9PSB0cnVlICYmIHBhbmVsLmdldExpbmVhckJydXNoT3RoZXJFeHRlbnQpIHtcbiAgICAgICAgb3RoZXJFeHRlbnQgPSBwYW5lbC5nZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50KHh5SW5kZXgsIGNvbnRyb2xsZXIuX3RyYW5zZm9ybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgenIgPSBjb250cm9sbGVyLl96cjtcbiAgICAgICAgb3RoZXJFeHRlbnQgPSBbMCwgW3pyLmdldFdpZHRoKCksIHpyLmdldEhlaWdodCgpXVsxIC0geHlJbmRleF1dO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjdFJhbmdlID0gW2xvY2FsUmFuZ2UsIG90aGVyRXh0ZW50XTtcbiAgICAgIHh5SW5kZXggJiYgcmVjdFJhbmdlLnJldmVyc2UoKTtcbiAgICAgIHVwZGF0ZUJhc2VSZWN0KGNvbnRyb2xsZXIsIGNvdmVyLCByZWN0UmFuZ2UsIGJydXNoT3B0aW9uKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbW1vbjogdXBkYXRlQ29tbW9uLFxuICAgIGNvbnRhaW46IG1haW5TaGFwZUNvbnRhaW5cbiAgfTtcbn1cblxudmFyIF9kZWZhdWx0ID0gQnJ1c2hDb250cm9sbGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaENvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBicnVzaEhlbHBlciA9IHJlcXVpcmUoXCIuL2JydXNoSGVscGVyXCIpO1xuXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcbnZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbnZhciBDT09SRF9DT05WRVJUUyA9IFsnZGF0YVRvUG9pbnQnLCAncG9pbnRUb0RhdGEnXTsgLy8gRklYTUVcbi8vIGhvdyB0byBnZW5hcmlhbGl6ZSB0byBtb3JlIGNvb3JkaW5hdGUgc3lzdGVtcy5cblxudmFyIElOQ0xVREVfRklOREVSX01BSU5fVFlQRVMgPSBbJ2dyaWQnLCAneEF4aXMnLCAneUF4aXMnLCAnZ2VvJywgJ2dyYXBoJywgJ3BvbGFyJywgJ3JhZGl1c0F4aXMnLCAnYW5nbGVBeGlzJywgJ2JtYXAnXTtcbi8qKlxuICogW29wdGlvbiBpbiBjb25zdHJ1Y3Rvcl06XG4gKiB7XG4gKiAgICAgSW5kZXgvSWQvTmFtZSBvZiBnZW8sIHhBeGlzLCB5QXhpcywgZ3JpZDogU2VlIHV0aWwvbW9kZWwjcGFyc2VGaW5kZXIuXG4gKiB9XG4gKlxuICpcbiAqIFt0YXJnZXRJbmZvXTpcbiAqXG4gKiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgYXhlcyBpbiBhIHNpbmdsZSB0YXJnZXRJbmZvLiBDb25zaWRlciB0aGUgY2FzZVxuICogb2YgYGdyaWRgIGNvbXBvbmVudCwgYSB0YXJnZXRJbmZvIHJlcHJlc2VudHMgYSBncmlkIHdoaWNoIGNvbnRhaW5zIG9uZSBvciBtb3JlXG4gKiBjYXJ0ZXNpYW4gYW5kIG9uZSBvciBtb3JlIGF4ZXMuIEFuZCBjb25zaWRlciB0aGUgY2FzZSBvZiBwYXJhbGxlbCBzeXN0ZW0sXG4gKiB3aGljaCBoYXMgbXVsdGlwbGUgYXhlcyBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtLlxuICogQ2FuIGJlIHtcbiAqICAgICBwYW5lbElkOiAuLi4sXG4gKiAgICAgY29vcmRTeXM6IDxhIHJlcHJlc2VudGl0aXZlIGNhcnRlc2lhbiBpbiBncmlkIChmaXJzdCBjYXJ0ZXNpYW4gYnkgZGVmYXVsdCk+LFxuICogICAgIGNvb3JkU3lzZXM6IGFsbCBjYXJ0ZXNpYW5zLlxuICogICAgIGdyaWRNb2RlbDogPGdyaWQgY29tcG9uZW50PlxuICogICAgIHhBeGVzOiBjb3JyZXNwb25kIHRvIGNvb3JkU3lzZXMgb24gaW5kZXhcbiAqICAgICB5QXhlczogY29ycmVzcG9uZCB0byBjb29yZFN5c2VzIG9uIGluZGV4XG4gKiB9XG4gKiBvciB7XG4gKiAgICAgcGFuZWxJZDogLi4uLFxuICogICAgIGNvb3JkU3lzOiA8Z2VvIGNvb3JkIHN5cz5cbiAqICAgICBjb29yZFN5c2VzOiBbPGdlbyBjb29yZCBzeXM+XVxuICogICAgIGdlb01vZGVsOiA8Z2VvIGNvbXBvbmVudD5cbiAqIH1cbiAqXG4gKlxuICogW3BhbmVsT3B0XTpcbiAqXG4gKiBNYWtlIGZyb20gdGFyZ2V0SW5mby4gSW5wdXQgdG8gQnJ1c2hDb250cm9sbGVyLlxuICoge1xuICogICAgIHBhbmVsSWQ6IC4uLixcbiAqICAgICByZWN0OiAuLi5cbiAqIH1cbiAqXG4gKlxuICogW2FyZWFdOlxuICpcbiAqIEdlbmVyYXRlZCBieSBCcnVzaENvbnRyb2xsZXIgb3IgdXNlciBpbnB1dC5cbiAqIHtcbiAqICAgICBwYW5lbElkOiBVc2VkIHRvIGxvY2F0ZSBjb29yZEluZm8gZGlyZWN0bHkuIElmIHVzZXIgaW5wcHV0LCBubyBwYW5lbElkLlxuICogICAgIGJydXNoVHlwZTogZGV0ZXJtaW5lIGhvdyB0byBjb252ZXJ0IHRvL2Zyb20gY29vcmQoJ3JlY3QnIG9yICdwb2x5Z29uJyBvciAnbGluZVgvWScpLlxuICogICAgIEluZGV4L0lkL05hbWUgb2YgZ2VvLCB4QXhpcywgeUF4aXMsIGdyaWQ6IFNlZSB1dGlsL21vZGVsI3BhcnNlRmluZGVyLlxuICogICAgIHJhbmdlOiBwaXhlbCByYW5nZS5cbiAqICAgICBjb29yZFJhbmdlOiByZXByZXNlbnRpdGl2ZSBjb29yZCByYW5nZSAodGhlIGZpcnN0IG9uZSBvZiBjb29yZFJhbmdlcykuXG4gKiAgICAgY29vcmRSYW5nZXM6IDxBcnJheT4gY29vcmQgcmFuZ2VzLCB1c2VkIGluIG11bHRpcGxlIGNhcnRlc2lhbiBpbiBvbmUgZ3JpZC5cbiAqIH1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24gY29udGFpbnMgSW5kZXgvSWQvTmFtZSBvZiB4QXhpcy95QXhpcy9nZW8vZ3JpZFxuICogICAgICAgIEVhY2ggY2FuIGJlIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59LiBsaWtlOiB7eEF4aXNJbmRleDogWzMsIDRdfVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW29wdC5pbmNsdWRlXSBpbmNsdWRlIGNvb3JkaW5hdGUgc3lzdGVtIHR5cGVzLlxuICovXG5cbmZ1bmN0aW9uIEJydXNoVGFyZ2V0TWFuYWdlcihvcHRpb24sIGVjTW9kZWwsIG9wdCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgKi9cbiAgdmFyIHRhcmdldEluZm9MaXN0ID0gdGhpcy5fdGFyZ2V0SW5mb0xpc3QgPSBbXTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgdmFyIGZvdW5kQ3B0cyA9IHBhcnNlRmluZGVyKGVjTW9kZWwsIG9wdGlvbik7XG4gIGVhY2godGFyZ2V0SW5mb0J1aWxkZXJzLCBmdW5jdGlvbiAoYnVpbGRlciwgdHlwZSkge1xuICAgIGlmICghb3B0IHx8ICFvcHQuaW5jbHVkZSB8fCBpbmRleE9mKG9wdC5pbmNsdWRlLCB0eXBlKSA+PSAwKSB7XG4gICAgICBidWlsZGVyKGZvdW5kQ3B0cywgdGFyZ2V0SW5mb0xpc3QsIGluZm8pO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBwcm90byA9IEJydXNoVGFyZ2V0TWFuYWdlci5wcm90b3R5cGU7XG5cbnByb3RvLnNldE91dHB1dFJhbmdlcyA9IGZ1bmN0aW9uIChhcmVhcywgZWNNb2RlbCkge1xuICB0aGlzLm1hdGNoT3V0cHV0UmFuZ2VzKGFyZWFzLCBlY01vZGVsLCBmdW5jdGlvbiAoYXJlYSwgY29vcmRSYW5nZSwgY29vcmRTeXMpIHtcbiAgICAoYXJlYS5jb29yZFJhbmdlcyB8fCAoYXJlYS5jb29yZFJhbmdlcyA9IFtdKSkucHVzaChjb29yZFJhbmdlKTsgLy8gYXJlYS5jb29yZFJhbmdlIGlzIHRoZSBmaXJzdCBvZiBhcmVhLmNvb3JkUmFuZ2VzXG5cbiAgICBpZiAoIWFyZWEuY29vcmRSYW5nZSkge1xuICAgICAgYXJlYS5jb29yZFJhbmdlID0gY29vcmRSYW5nZTsgLy8gSW4gJ2NhdGVnb3J5JyBheGlzLCBjb29yZCB0byBwaXhlbCBpcyBub3QgcmV2ZXJzaWJsZSwgc28gd2UgY2FuIG5vdFxuICAgICAgLy8gcmVidWlsZCByYW5nZSBieSBjb29yZFJhbmdlIGFjY3JhdGVseSwgd2hpY2ggbWF5IGJyaW5nIHRyb3VibGUgd2hlblxuICAgICAgLy8gYnJ1c2hpbmcgb25seSBvbmUgaXRlbS4gU28gd2UgdXNlIF9fcmFuZ2VPZmZzZXQgdG8gcmVidWlsZGluZyByYW5nZVxuICAgICAgLy8gYnkgY29vcmRSYW5nZS4gQW5kIHRoaXMgaXQgb25seSB1c2VkIGluIGJydXNoIGNvbXBvbmVudCBzbyBpdCBpcyBub1xuICAgICAgLy8gbmVlZCB0byBiZSBhZGFwdGVkIHRvIGNvb3JkUmFuZ2VzLlxuXG4gICAgICB2YXIgcmVzdWx0ID0gY29vcmRDb252ZXJ0W2FyZWEuYnJ1c2hUeXBlXSgwLCBjb29yZFN5cywgY29vcmRSYW5nZSk7XG4gICAgICBhcmVhLl9fcmFuZ2VPZmZzZXQgPSB7XG4gICAgICAgIG9mZnNldDogZGlmZlByb2Nlc3NvclthcmVhLmJydXNoVHlwZV0ocmVzdWx0LnZhbHVlcywgYXJlYS5yYW5nZSwgWzEsIDFdKSxcbiAgICAgICAgeHlNaW5NYXg6IHJlc3VsdC54eU1pbk1heFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufTtcblxucHJvdG8ubWF0Y2hPdXRwdXRSYW5nZXMgPSBmdW5jdGlvbiAoYXJlYXMsIGVjTW9kZWwsIGNiKSB7XG4gIGVhY2goYXJlYXMsIGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuXG4gICAgaWYgKHRhcmdldEluZm8gJiYgdGFyZ2V0SW5mbyAhPT0gdHJ1ZSkge1xuICAgICAgenJVdGlsLmVhY2godGFyZ2V0SW5mby5jb29yZFN5c2VzLCBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvb3JkQ29udmVydFthcmVhLmJydXNoVHlwZV0oMSwgY29vcmRTeXMsIGFyZWEucmFuZ2UpO1xuICAgICAgICBjYihhcmVhLCByZXN1bHQudmFsdWVzLCBjb29yZFN5cywgZWNNb2RlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHRoaXMpO1xufTtcblxucHJvdG8uc2V0SW5wdXRSYW5nZXMgPSBmdW5jdGlvbiAoYXJlYXMsIGVjTW9kZWwpIHtcbiAgZWFjaChhcmVhcywgZnVuY3Rpb24gKGFyZWEpIHtcbiAgICB2YXIgdGFyZ2V0SW5mbyA9IHRoaXMuZmluZFRhcmdldEluZm8oYXJlYSwgZWNNb2RlbCk7XG4gICAgYXJlYS5yYW5nZSA9IGFyZWEucmFuZ2UgfHwgW107IC8vIGNvbnZlcnQgY29vcmRSYW5nZSB0byBnbG9iYWwgcmFuZ2UgYW5kIHNldCBwYW5lbElkLlxuXG4gICAgaWYgKHRhcmdldEluZm8gJiYgdGFyZ2V0SW5mbyAhPT0gdHJ1ZSkge1xuICAgICAgYXJlYS5wYW5lbElkID0gdGFyZ2V0SW5mby5wYW5lbElkOyAvLyAoMSkgYXJlYS5yYW5nZSBzaG91bGUgYWx3YXlzIGJlIGNhbGN1bGF0ZSBmcm9tIGNvb3JkUmFuZ2UgYnV0IGRvZXNcbiAgICAgIC8vIG5vdCBrZWVwIGl0cyBvcmlnaW5hbCB2YWx1ZSwgZm9yIHRoZSBzYWtlIG9mIHRoZSBkYXRhWm9vbSBzY2VuYXJpbyxcbiAgICAgIC8vIHdoZXJlIGFyZWEuY29vcmRSYW5nZSByZW1haW5zIHVuY2hhbmdlZCBidXQgYXJlYS5yYW5nZSBtYXkgYmUgY2hhbmdlZC5cbiAgICAgIC8vICgyKSBPbmx5IHN1cHBvcnQgY29udmVydGluZyBvbmUgY29vcmRSYW5nZSB0byBwaXhlbCByYW5nZSBpbiBicnVzaFxuICAgICAgLy8gY29tcG9uZW50LiBTbyBkbyBub3QgY29uc2lkZXIgYGNvb3JkUmFuZ2VzYC5cbiAgICAgIC8vICgzKSBBYm91dCBfX3JhbmdlT2Zmc2V0LCBzZWUgY29tbWVudCBhYm92ZS5cblxuICAgICAgdmFyIHJlc3VsdCA9IGNvb3JkQ29udmVydFthcmVhLmJydXNoVHlwZV0oMCwgdGFyZ2V0SW5mby5jb29yZFN5cywgYXJlYS5jb29yZFJhbmdlKTtcbiAgICAgIHZhciByYW5nZU9mZnNldCA9IGFyZWEuX19yYW5nZU9mZnNldDtcbiAgICAgIGFyZWEucmFuZ2UgPSByYW5nZU9mZnNldCA/IGRpZmZQcm9jZXNzb3JbYXJlYS5icnVzaFR5cGVdKHJlc3VsdC52YWx1ZXMsIHJhbmdlT2Zmc2V0Lm9mZnNldCwgZ2V0U2NhbGVzKHJlc3VsdC54eU1pbk1heCwgcmFuZ2VPZmZzZXQueHlNaW5NYXgpKSA6IHJlc3VsdC52YWx1ZXM7XG4gICAgfVxuICB9LCB0aGlzKTtcbn07XG5cbnByb3RvLm1ha2VQYW5lbE9wdHMgPSBmdW5jdGlvbiAoYXBpLCBnZXREZWZhdWx0QnJ1c2hUeXBlKSB7XG4gIHJldHVybiB6clV0aWwubWFwKHRoaXMuX3RhcmdldEluZm9MaXN0LCBmdW5jdGlvbiAodGFyZ2V0SW5mbykge1xuICAgIHZhciByZWN0ID0gdGFyZ2V0SW5mby5nZXRQYW5lbFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFuZWxJZDogdGFyZ2V0SW5mby5wYW5lbElkLFxuICAgICAgZGVmYXVsdEJydXNoVHlwZTogZ2V0RGVmYXVsdEJydXNoVHlwZSAmJiBnZXREZWZhdWx0QnJ1c2hUeXBlKHRhcmdldEluZm8pLFxuICAgICAgY2xpcFBhdGg6IGJydXNoSGVscGVyLm1ha2VSZWN0UGFuZWxDbGlwUGF0aChyZWN0KSxcbiAgICAgIGlzVGFyZ2V0QnlDdXJzb3I6IGJydXNoSGVscGVyLm1ha2VSZWN0SXNUYXJnZXRCeUN1cnNvcihyZWN0LCBhcGksIHRhcmdldEluZm8uY29vcmRTeXNNb2RlbCksXG4gICAgICBnZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50OiBicnVzaEhlbHBlci5tYWtlTGluZWFyQnJ1c2hPdGhlckV4dGVudChyZWN0KVxuICAgIH07XG4gIH0pO1xufTtcblxucHJvdG8uY29udHJvbFNlcmllcyA9IGZ1bmN0aW9uIChhcmVhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAvLyBDaGVjayB3aGV0aGVyIGFyZWEgaXMgYm91bmQgaW4gY29vcmQsIGFuZCBzZXJpZXMgZG8gbm90IGJlbG9uZyB0byB0aGF0IGNvb3JkLlxuICAvLyBJZiBkbyBub3QgZG8gdGhpcyBjaGVjaywgc29tZSBicnVzaCAobGlrZSBsaW5lWCkgd2lsbCBjb250cm9sbCBhbGwgYXhlcy5cbiAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuICByZXR1cm4gdGFyZ2V0SW5mbyA9PT0gdHJ1ZSB8fCB0YXJnZXRJbmZvICYmIGluZGV4T2YodGFyZ2V0SW5mby5jb29yZFN5c2VzLCBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtKSA+PSAwO1xufTtcbi8qKlxuICogSWYgcmV0dXJuIE9iamVjdCwgYSBjb29yZCBmb3VuZC5cbiAqIElmIHJldXRybiB0cnVlLCBnbG9iYWwgZm91bmQuXG4gKiBPdGhlcndpc2Ugbm90aGluZyBmb3VuZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJlYVxuICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SW5mb0xpc3RcbiAqIEByZXR1cm4ge09iamVjdHxib29sZWFufVxuICovXG5cblxucHJvdG8uZmluZFRhcmdldEluZm8gPSBmdW5jdGlvbiAoYXJlYSwgZWNNb2RlbCkge1xuICB2YXIgdGFyZ2V0SW5mb0xpc3QgPSB0aGlzLl90YXJnZXRJbmZvTGlzdDtcbiAgdmFyIGZvdW5kQ3B0cyA9IHBhcnNlRmluZGVyKGVjTW9kZWwsIGFyZWEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0SW5mb0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGFyZ2V0SW5mbyA9IHRhcmdldEluZm9MaXN0W2ldO1xuICAgIHZhciBhcmVhUGFuZWxJZCA9IGFyZWEucGFuZWxJZDtcblxuICAgIGlmIChhcmVhUGFuZWxJZCkge1xuICAgICAgaWYgKHRhcmdldEluZm8ucGFuZWxJZCA9PT0gYXJlYVBhbmVsSWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEluZm87XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0SW5mb01hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0YXJnZXRJbmZvTWF0Y2hlcnNbaV0oZm91bmRDcHRzLCB0YXJnZXRJbmZvKSkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRNaW5NYXgobWluTWF4KSB7XG4gIG1pbk1heFswXSA+IG1pbk1heFsxXSAmJiBtaW5NYXgucmV2ZXJzZSgpO1xuICByZXR1cm4gbWluTWF4O1xufVxuXG5mdW5jdGlvbiBwYXJzZUZpbmRlcihlY01vZGVsLCBvcHRpb24pIHtcbiAgcmV0dXJuIG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBvcHRpb24sIHtcbiAgICBpbmNsdWRlTWFpblR5cGVzOiBJTkNMVURFX0ZJTkRFUl9NQUlOX1RZUEVTXG4gIH0pO1xufVxuXG52YXIgdGFyZ2V0SW5mb0J1aWxkZXJzID0ge1xuICBncmlkOiBmdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvTGlzdCkge1xuICAgIHZhciB4QXhpc01vZGVscyA9IGZvdW5kQ3B0cy54QXhpc01vZGVscztcbiAgICB2YXIgeUF4aXNNb2RlbHMgPSBmb3VuZENwdHMueUF4aXNNb2RlbHM7XG4gICAgdmFyIGdyaWRNb2RlbHMgPSBmb3VuZENwdHMuZ3JpZE1vZGVsczsgLy8gUmVtb3ZlIGR1cGxpY2F0ZWQuXG5cbiAgICB2YXIgZ3JpZE1vZGVsTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgeEF4ZXNIYXMgPSB7fTtcbiAgICB2YXIgeUF4ZXNIYXMgPSB7fTtcblxuICAgIGlmICgheEF4aXNNb2RlbHMgJiYgIXlBeGlzTW9kZWxzICYmICFncmlkTW9kZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaCh4QXhpc01vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgdmFyIGdyaWRNb2RlbCA9IGF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWw7XG4gICAgICBncmlkTW9kZWxNYXAuc2V0KGdyaWRNb2RlbC5pZCwgZ3JpZE1vZGVsKTtcbiAgICAgIHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIGVhY2goeUF4aXNNb2RlbHMsIGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsO1xuICAgICAgZ3JpZE1vZGVsTWFwLnNldChncmlkTW9kZWwuaWQsIGdyaWRNb2RlbCk7XG4gICAgICB5QXhlc0hhc1tncmlkTW9kZWwuaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBlYWNoKGdyaWRNb2RlbHMsIGZ1bmN0aW9uIChncmlkTW9kZWwpIHtcbiAgICAgIGdyaWRNb2RlbE1hcC5zZXQoZ3JpZE1vZGVsLmlkLCBncmlkTW9kZWwpO1xuICAgICAgeEF4ZXNIYXNbZ3JpZE1vZGVsLmlkXSA9IHRydWU7XG4gICAgICB5QXhlc0hhc1tncmlkTW9kZWwuaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBncmlkTW9kZWxNYXAuZWFjaChmdW5jdGlvbiAoZ3JpZE1vZGVsKSB7XG4gICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIGNhcnRlc2lhbnMgPSBbXTtcbiAgICAgIGVhY2goZ3JpZC5nZXRDYXJ0ZXNpYW5zKCksIGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleE9mKHhBeGlzTW9kZWxzLCBjYXJ0ZXNpYW4uZ2V0QXhpcygneCcpLm1vZGVsKSA+PSAwIHx8IGluZGV4T2YoeUF4aXNNb2RlbHMsIGNhcnRlc2lhbi5nZXRBeGlzKCd5JykubW9kZWwpID49IDApIHtcbiAgICAgICAgICBjYXJ0ZXNpYW5zLnB1c2goY2FydGVzaWFuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0YXJnZXRJbmZvTGlzdC5wdXNoKHtcbiAgICAgICAgcGFuZWxJZDogJ2dyaWQtLScgKyBncmlkTW9kZWwuaWQsXG4gICAgICAgIGdyaWRNb2RlbDogZ3JpZE1vZGVsLFxuICAgICAgICBjb29yZFN5c01vZGVsOiBncmlkTW9kZWwsXG4gICAgICAgIC8vIFVzZSB0aGUgZmlyc3Qgb25lIGFzIHRoZSByZXByZXNlbnRpdGl2ZSBjb29yZFN5cy5cbiAgICAgICAgY29vcmRTeXM6IGNhcnRlc2lhbnNbMF0sXG4gICAgICAgIGNvb3JkU3lzZXM6IGNhcnRlc2lhbnMsXG4gICAgICAgIGdldFBhbmVsUmVjdDogcGFuZWxSZWN0QnVpbGRlci5ncmlkLFxuICAgICAgICB4QXhpc0RlY2xhcmVkOiB4QXhlc0hhc1tncmlkTW9kZWwuaWRdLFxuICAgICAgICB5QXhpc0RlY2xhcmVkOiB5QXhlc0hhc1tncmlkTW9kZWwuaWRdXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZ2VvOiBmdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvTGlzdCkge1xuICAgIGVhY2goZm91bmRDcHRzLmdlb01vZGVscywgZnVuY3Rpb24gKGdlb01vZGVsKSB7XG4gICAgICB2YXIgY29vcmRTeXMgPSBnZW9Nb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdGFyZ2V0SW5mb0xpc3QucHVzaCh7XG4gICAgICAgIHBhbmVsSWQ6ICdnZW8tLScgKyBnZW9Nb2RlbC5pZCxcbiAgICAgICAgZ2VvTW9kZWw6IGdlb01vZGVsLFxuICAgICAgICBjb29yZFN5c01vZGVsOiBnZW9Nb2RlbCxcbiAgICAgICAgY29vcmRTeXM6IGNvb3JkU3lzLFxuICAgICAgICBjb29yZFN5c2VzOiBbY29vcmRTeXNdLFxuICAgICAgICBnZXRQYW5lbFJlY3Q6IHBhbmVsUmVjdEJ1aWxkZXIuZ2VvXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciB0YXJnZXRJbmZvTWF0Y2hlcnMgPSBbLy8gZ3JpZFxuZnVuY3Rpb24gKGZvdW5kQ3B0cywgdGFyZ2V0SW5mbykge1xuICB2YXIgeEF4aXNNb2RlbCA9IGZvdW5kQ3B0cy54QXhpc01vZGVsO1xuICB2YXIgeUF4aXNNb2RlbCA9IGZvdW5kQ3B0cy55QXhpc01vZGVsO1xuICB2YXIgZ3JpZE1vZGVsID0gZm91bmRDcHRzLmdyaWRNb2RlbDtcbiAgIWdyaWRNb2RlbCAmJiB4QXhpc01vZGVsICYmIChncmlkTW9kZWwgPSB4QXhpc01vZGVsLmF4aXMuZ3JpZC5tb2RlbCk7XG4gICFncmlkTW9kZWwgJiYgeUF4aXNNb2RlbCAmJiAoZ3JpZE1vZGVsID0geUF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWwpO1xuICByZXR1cm4gZ3JpZE1vZGVsICYmIGdyaWRNb2RlbCA9PT0gdGFyZ2V0SW5mby5ncmlkTW9kZWw7XG59LCAvLyBnZW9cbmZ1bmN0aW9uIChmb3VuZENwdHMsIHRhcmdldEluZm8pIHtcbiAgdmFyIGdlb01vZGVsID0gZm91bmRDcHRzLmdlb01vZGVsO1xuICByZXR1cm4gZ2VvTW9kZWwgJiYgZ2VvTW9kZWwgPT09IHRhcmdldEluZm8uZ2VvTW9kZWw7XG59XTtcbnZhciBwYW5lbFJlY3RCdWlsZGVyID0ge1xuICBncmlkOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZ3JpZCBpcyBub3QgVHJhbnNmb3JtYWJsZS5cbiAgICByZXR1cm4gdGhpcy5jb29yZFN5cy5ncmlkLmdldFJlY3QoKS5jbG9uZSgpO1xuICB9LFxuICBnZW86IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkU3lzO1xuICAgIHZhciByZWN0ID0gY29vcmRTeXMuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTsgLy8gZ2VvIHJvYW0gYW5kIHpvb20gdHJhbnNmb3JtXG5cbiAgICByZWN0LmFwcGx5VHJhbnNmb3JtKGdyYXBoaWMuZ2V0VHJhbnNmb3JtKGNvb3JkU3lzKSk7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbn07XG52YXIgY29vcmRDb252ZXJ0ID0ge1xuICBsaW5lWDogY3VycnkoYXhpc0NvbnZlcnQsIDApLFxuICBsaW5lWTogY3VycnkoYXhpc0NvbnZlcnQsIDEpLFxuICByZWN0OiBmdW5jdGlvbiAodG8sIGNvb3JkU3lzLCByYW5nZU9yQ29vcmRSYW5nZSkge1xuICAgIHZhciB4bWlueW1pbiA9IGNvb3JkU3lzW0NPT1JEX0NPTlZFUlRTW3RvXV0oW3JhbmdlT3JDb29yZFJhbmdlWzBdWzBdLCByYW5nZU9yQ29vcmRSYW5nZVsxXVswXV0pO1xuICAgIHZhciB4bWF4eW1heCA9IGNvb3JkU3lzW0NPT1JEX0NPTlZFUlRTW3RvXV0oW3JhbmdlT3JDb29yZFJhbmdlWzBdWzFdLCByYW5nZU9yQ29vcmRSYW5nZVsxXVsxXV0pO1xuICAgIHZhciB2YWx1ZXMgPSBbZm9ybWF0TWluTWF4KFt4bWlueW1pblswXSwgeG1heHltYXhbMF1dKSwgZm9ybWF0TWluTWF4KFt4bWlueW1pblsxXSwgeG1heHltYXhbMV1dKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgeHlNaW5NYXg6IHZhbHVlc1xuICAgIH07XG4gIH0sXG4gIHBvbHlnb246IGZ1bmN0aW9uICh0bywgY29vcmRTeXMsIHJhbmdlT3JDb29yZFJhbmdlKSB7XG4gICAgdmFyIHh5TWluTWF4ID0gW1tJbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCAtSW5maW5pdHldXTtcbiAgICB2YXIgdmFsdWVzID0genJVdGlsLm1hcChyYW5nZU9yQ29vcmRSYW5nZSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBwID0gY29vcmRTeXNbQ09PUkRfQ09OVkVSVFNbdG9dXShpdGVtKTtcbiAgICAgIHh5TWluTWF4WzBdWzBdID0gTWF0aC5taW4oeHlNaW5NYXhbMF1bMF0sIHBbMF0pO1xuICAgICAgeHlNaW5NYXhbMV1bMF0gPSBNYXRoLm1pbih4eU1pbk1heFsxXVswXSwgcFsxXSk7XG4gICAgICB4eU1pbk1heFswXVsxXSA9IE1hdGgubWF4KHh5TWluTWF4WzBdWzFdLCBwWzBdKTtcbiAgICAgIHh5TWluTWF4WzFdWzFdID0gTWF0aC5tYXgoeHlNaW5NYXhbMV1bMV0sIHBbMV0pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgeHlNaW5NYXg6IHh5TWluTWF4XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXhpc0NvbnZlcnQoYXhpc05hbWVJbmRleCwgdG8sIGNvb3JkU3lzLCByYW5nZU9yQ29vcmRSYW5nZSkge1xuICB2YXIgYXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoWyd4JywgJ3knXVtheGlzTmFtZUluZGV4XSk7XG4gIHZhciB2YWx1ZXMgPSBmb3JtYXRNaW5NYXgoenJVdGlsLm1hcChbMCwgMV0sIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIHRvID8gYXhpcy5jb29yZFRvRGF0YShheGlzLnRvTG9jYWxDb29yZChyYW5nZU9yQ29vcmRSYW5nZVtpXSkpIDogYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQocmFuZ2VPckNvb3JkUmFuZ2VbaV0pKTtcbiAgfSkpO1xuICB2YXIgeHlNaW5NYXggPSBbXTtcbiAgeHlNaW5NYXhbYXhpc05hbWVJbmRleF0gPSB2YWx1ZXM7XG4gIHh5TWluTWF4WzEgLSBheGlzTmFtZUluZGV4XSA9IFtOYU4sIE5hTl07XG4gIHJldHVybiB7XG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgeHlNaW5NYXg6IHh5TWluTWF4XG4gIH07XG59XG5cbnZhciBkaWZmUHJvY2Vzc29yID0ge1xuICBsaW5lWDogY3VycnkoYXhpc0RpZmZQcm9jZXNzb3IsIDApLFxuICBsaW5lWTogY3VycnkoYXhpc0RpZmZQcm9jZXNzb3IsIDEpLFxuICByZWN0OiBmdW5jdGlvbiAodmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gICAgcmV0dXJuIFtbdmFsdWVzWzBdWzBdIC0gc2NhbGVzWzBdICogcmVmZXJbMF1bMF0sIHZhbHVlc1swXVsxXSAtIHNjYWxlc1swXSAqIHJlZmVyWzBdWzFdXSwgW3ZhbHVlc1sxXVswXSAtIHNjYWxlc1sxXSAqIHJlZmVyWzFdWzBdLCB2YWx1ZXNbMV1bMV0gLSBzY2FsZXNbMV0gKiByZWZlclsxXVsxXV1dO1xuICB9LFxuICBwb2x5Z29uOiBmdW5jdGlvbiAodmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbiAoaXRlbSwgaWR4KSB7XG4gICAgICByZXR1cm4gW2l0ZW1bMF0gLSBzY2FsZXNbMF0gKiByZWZlcltpZHhdWzBdLCBpdGVtWzFdIC0gc2NhbGVzWzFdICogcmVmZXJbaWR4XVsxXV07XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGF4aXNEaWZmUHJvY2Vzc29yKGF4aXNOYW1lSW5kZXgsIHZhbHVlcywgcmVmZXIsIHNjYWxlcykge1xuICByZXR1cm4gW3ZhbHVlc1swXSAtIHNjYWxlc1theGlzTmFtZUluZGV4XSAqIHJlZmVyWzBdLCB2YWx1ZXNbMV0gLSBzY2FsZXNbYXhpc05hbWVJbmRleF0gKiByZWZlclsxXV07XG59IC8vIFdlIGhhdmUgdG8gcHJvY2VzcyBzY2FsZSBjYXVzZWQgYnkgZGF0YVpvb20gbWFudWFsbHksXG4vLyBhbHRob3VnaCBpdCBtaWdodCBiZSBub3QgYWNjdXJhdGUuXG5cblxuZnVuY3Rpb24gZ2V0U2NhbGVzKHh5TWluTWF4Q3VyciwgeHlNaW5NYXhPcmlnaW4pIHtcbiAgdmFyIHNpemVDdXJyID0gZ2V0U2l6ZSh4eU1pbk1heEN1cnIpO1xuICB2YXIgc2l6ZU9yaWdpbiA9IGdldFNpemUoeHlNaW5NYXhPcmlnaW4pO1xuICB2YXIgc2NhbGVzID0gW3NpemVDdXJyWzBdIC8gc2l6ZU9yaWdpblswXSwgc2l6ZUN1cnJbMV0gLyBzaXplT3JpZ2luWzFdXTtcbiAgaXNOYU4oc2NhbGVzWzBdKSAmJiAoc2NhbGVzWzBdID0gMSk7XG4gIGlzTmFOKHNjYWxlc1sxXSkgJiYgKHNjYWxlc1sxXSA9IDEpO1xuICByZXR1cm4gc2NhbGVzO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKHh5TWluTWF4KSB7XG4gIHJldHVybiB4eU1pbk1heCA/IFt4eU1pbk1heFswXVsxXSAtIHh5TWluTWF4WzBdWzBdLCB4eU1pbk1heFsxXVsxXSAtIHh5TWluTWF4WzFdWzBdXSA6IFtOYU4sIE5hTl07XG59XG5cbnZhciBfZGVmYXVsdCA9IEJydXNoVGFyZ2V0TWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaFRhcmdldE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hUYXJnZXRNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bFwiKTtcblxudmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgaW50ZXJhY3Rpb25NdXRleCA9IHJlcXVpcmUoXCIuL2ludGVyYWN0aW9uTXV0ZXhcIik7XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQG1peGluIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL3pyZW5kZXJ+WlJlbmRlcn0genJcbiAqL1xuZnVuY3Rpb24gUm9hbUNvbnRyb2xsZXIoenIpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHRoaXMucG9pbnRlckNoZWNrZXI7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXJ9XG4gICAqL1xuXG4gIHRoaXMuX3pyID0genI7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9vcHQgPSB7fTsgLy8gQXZvaWQgdHdvIHJvYW1Db250cm9sbGVyIGJpbmQgdGhlIHNhbWUgaGFuZGxlclxuXG4gIHZhciBiaW5kID0genJVdGlsLmJpbmQ7XG4gIHZhciBtb3VzZWRvd25IYW5kbGVyID0gYmluZChtb3VzZWRvd24sIHRoaXMpO1xuICB2YXIgbW91c2Vtb3ZlSGFuZGxlciA9IGJpbmQobW91c2Vtb3ZlLCB0aGlzKTtcbiAgdmFyIG1vdXNldXBIYW5kbGVyID0gYmluZChtb3VzZXVwLCB0aGlzKTtcbiAgdmFyIG1vdXNld2hlZWxIYW5kbGVyID0gYmluZChtb3VzZXdoZWVsLCB0aGlzKTtcbiAgdmFyIHBpbmNoSGFuZGxlciA9IGJpbmQocGluY2gsIHRoaXMpO1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcG9pbnRlckNoZWNrZXJcbiAgICogICAgICAgICAgICAgICAgICAgaW5wdXQ6IHgsIHlcbiAgICogICAgICAgICAgICAgICAgICAgb3V0cHV0OiBib29sZWFuXG4gICAqL1xuXG4gIHRoaXMuc2V0UG9pbnRlckNoZWNrZXIgPSBmdW5jdGlvbiAocG9pbnRlckNoZWNrZXIpIHtcbiAgICB0aGlzLnBvaW50ZXJDaGVja2VyID0gcG9pbnRlckNoZWNrZXI7XG4gIH07XG4gIC8qKlxuICAgKiBOb3RpY2U6IG9ubHkgZW5hYmxlIG5lZWRlZCB0eXBlcy4gRm9yIGV4YW1wbGUsIGlmICd6b29tJ1xuICAgKiBpcyBub3QgbmVlZGVkLCAnem9vbScgc2hvdWxkIG5vdCBiZSBlbmFibGVkLCBvdGhlcndpc2VcbiAgICogZGVmYXVsdCBtb3VzZXdoZWVsIGJlaGF2aW91ciAoc2Nyb2xsIHBhZ2UpIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW58c3RyaW5nfSBbY29udHJvbFR5cGU9dHJ1ZV0gU3BlY2lmeSB0aGUgY29udHJvbCB0eXBlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggY2FuIGJlIG51bGwvdW5kZWZpbmVkIG9yIHRydWUvZmFsc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yICdwYW4vbW92ZScgb3IgJ3pvb20nLydzY2FsZSdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0Lnpvb21Pbk1vdXNlV2hlZWw9dHJ1ZV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHQubW92ZU9uTW91c2VNb3ZlPXRydWVdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0LnByZXZlbnREZWZhdWx0TW91c2VNb3ZlPXRydWVdIFdoZW4gcGFuLlxuICAgKi9cblxuXG4gIHRoaXMuZW5hYmxlID0gZnVuY3Rpb24gKGNvbnRyb2xUeXBlLCBvcHQpIHtcbiAgICAvLyBEaXNhYmxlIHByZXZpb3VzIGZpcnN0XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgdGhpcy5fb3B0ID0genJVdGlsLmRlZmF1bHRzKHpyVXRpbC5jbG9uZShvcHQpIHx8IHt9LCB7XG4gICAgICB6b29tT25Nb3VzZVdoZWVsOiB0cnVlLFxuICAgICAgbW92ZU9uTW91c2VNb3ZlOiB0cnVlLFxuICAgICAgcHJldmVudERlZmF1bHRNb3VzZU1vdmU6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChjb250cm9sVHlwZSA9PSBudWxsKSB7XG4gICAgICBjb250cm9sVHlwZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRyb2xUeXBlID09PSB0cnVlIHx8IGNvbnRyb2xUeXBlID09PSAnbW92ZScgfHwgY29udHJvbFR5cGUgPT09ICdwYW4nKSB7XG4gICAgICB6ci5vbignbW91c2Vkb3duJywgbW91c2Vkb3duSGFuZGxlcik7XG4gICAgICB6ci5vbignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlSGFuZGxlcik7XG4gICAgICB6ci5vbignbW91c2V1cCcsIG1vdXNldXBIYW5kbGVyKTtcbiAgICB9XG5cbiAgICBpZiAoY29udHJvbFR5cGUgPT09IHRydWUgfHwgY29udHJvbFR5cGUgPT09ICdzY2FsZScgfHwgY29udHJvbFR5cGUgPT09ICd6b29tJykge1xuICAgICAgenIub24oJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gICAgICB6ci5vbigncGluY2gnLCBwaW5jaEhhbmRsZXIpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgenIub2ZmKCdtb3VzZWRvd24nLCBtb3VzZWRvd25IYW5kbGVyKTtcbiAgICB6ci5vZmYoJ21vdXNlbW92ZScsIG1vdXNlbW92ZUhhbmRsZXIpO1xuICAgIHpyLm9mZignbW91c2V1cCcsIG1vdXNldXBIYW5kbGVyKTtcbiAgICB6ci5vZmYoJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gICAgenIub2ZmKCdwaW5jaCcsIHBpbmNoSGFuZGxlcik7XG4gIH07XG5cbiAgdGhpcy5kaXNwb3NlID0gdGhpcy5kaXNhYmxlO1xuXG4gIHRoaXMuaXNEcmFnZ2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJhZ2dpbmc7XG4gIH07XG5cbiAgdGhpcy5pc1BpbmNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9waW5jaGluZztcbiAgfTtcbn1cblxuenJVdGlsLm1peGluKFJvYW1Db250cm9sbGVyLCBFdmVudGZ1bCk7XG5cbmZ1bmN0aW9uIG1vdXNlZG93bihlKSB7XG4gIGlmIChldmVudFRvb2wubm90TGVmdE1vdXNlKGUpIHx8IGUudGFyZ2V0ICYmIGUudGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB4ID0gZS5vZmZzZXRYO1xuICB2YXIgeSA9IGUub2Zmc2V0WTsgLy8gT25seSBjaGVjayBvbiBtb3NlZG93biwgYnV0IG5vdCBtb3VzZW1vdmUuXG4gIC8vIE1vdXNlIGNhbiBiZSBvdXQgb2YgdGFyZ2V0IHdoZW4gbW91c2UgbW92aW5nLlxuXG4gIGlmICh0aGlzLnBvaW50ZXJDaGVja2VyICYmIHRoaXMucG9pbnRlckNoZWNrZXIoZSwgeCwgeSkpIHtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91c2Vtb3ZlKGUpIHtcbiAgaWYgKGV2ZW50VG9vbC5ub3RMZWZ0TW91c2UoZSkgfHwgIWNoZWNrS2V5QmluZGluZyh0aGlzLCAnbW92ZU9uTW91c2VNb3ZlJywgZSkgfHwgIXRoaXMuX2RyYWdnaW5nIHx8IGUuZ2VzdHVyZUV2ZW50ID09PSAncGluY2gnIHx8IGludGVyYWN0aW9uTXV0ZXguaXNUYWtlbih0aGlzLl96ciwgJ2dsb2JhbFBhbicpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHggPSBlLm9mZnNldFg7XG4gIHZhciB5ID0gZS5vZmZzZXRZO1xuICB2YXIgb2xkWCA9IHRoaXMuX3g7XG4gIHZhciBvbGRZID0gdGhpcy5feTtcbiAgdmFyIGR4ID0geCAtIG9sZFg7XG4gIHZhciBkeSA9IHkgLSBvbGRZO1xuICB0aGlzLl94ID0geDtcbiAgdGhpcy5feSA9IHk7XG4gIHRoaXMuX29wdC5wcmV2ZW50RGVmYXVsdE1vdXNlTW92ZSAmJiBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgdGhpcy50cmlnZ2VyKCdwYW4nLCBkeCwgZHksIG9sZFgsIG9sZFksIHgsIHkpO1xufVxuXG5mdW5jdGlvbiBtb3VzZXVwKGUpIHtcbiAgaWYgKCFldmVudFRvb2wubm90TGVmdE1vdXNlKGUpKSB7XG4gICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VzZXdoZWVsKGUpIHtcbiAgLy8gd2hlZWxEZWx0YSBtYXliZSAtMCBpbiBjaHJvbWUgbWFjLlxuICBpZiAoIWNoZWNrS2V5QmluZGluZyh0aGlzLCAnem9vbU9uTW91c2VXaGVlbCcsIGUpIHx8IGUud2hlZWxEZWx0YSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDb252ZW5pZW5jZTpcbiAgLy8gTWFjIGFuZCBWTSBXaW5kb3dzIG9uIE1hYzogc2Nyb2xsIHVwOiB6b29tIG91dC5cbiAgLy8gV2luZG93czogc2Nyb2xsIHVwOiB6b29tIGluLlxuXG5cbiAgdmFyIHpvb21EZWx0YSA9IGUud2hlZWxEZWx0YSA+IDAgPyAxLjEgOiAxIC8gMS4xO1xuICB6b29tLmNhbGwodGhpcywgZSwgem9vbURlbHRhLCBlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG59XG5cbmZ1bmN0aW9uIHBpbmNoKGUpIHtcbiAgaWYgKGludGVyYWN0aW9uTXV0ZXguaXNUYWtlbih0aGlzLl96ciwgJ2dsb2JhbFBhbicpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHpvb21EZWx0YSA9IGUucGluY2hTY2FsZSA+IDEgPyAxLjEgOiAxIC8gMS4xO1xuICB6b29tLmNhbGwodGhpcywgZSwgem9vbURlbHRhLCBlLnBpbmNoWCwgZS5waW5jaFkpO1xufVxuXG5mdW5jdGlvbiB6b29tKGUsIHpvb21EZWx0YSwgem9vbVgsIHpvb21ZKSB7XG4gIGlmICh0aGlzLnBvaW50ZXJDaGVja2VyICYmIHRoaXMucG9pbnRlckNoZWNrZXIoZSwgem9vbVgsIHpvb21ZKSkge1xuICAgIC8vIFdoZW4gbW91c2UgaXMgb3V0IG9mIHJvYW1Db250cm9sbGVyIHJlY3QsXG4gICAgLy8gZGVmYXVsdCBiZWZhdm9pdXMgc2hvdWxkIG5vdCBiZSBiZSBkaXNhYmxlZCwgb3RoZXJ3aXNlXG4gICAgLy8gcGFnZSBzbGlkaW5nIGlzIGRpc2FibGVkLCBjb250cmFyeSB0byBleHBlY3RhdGlvbi5cbiAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICB0aGlzLnRyaWdnZXIoJ3pvb20nLCB6b29tRGVsdGEsIHpvb21YLCB6b29tWSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tLZXlCaW5kaW5nKHJvYW1Db250cm9sbGVyLCBwcm9wLCBlKSB7XG4gIHZhciBzZXR0aW5nID0gcm9hbUNvbnRyb2xsZXIuX29wdFtwcm9wXTtcbiAgcmV0dXJuIHNldHRpbmcgJiYgKCF6clV0aWwuaXNTdHJpbmcoc2V0dGluZykgfHwgZS5ldmVudFtzZXR0aW5nICsgJ0tleSddKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gUm9hbUNvbnRyb2xsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgX2N1cnNvckhlbHBlciA9IHJlcXVpcmUoXCIuL2N1cnNvckhlbHBlclwiKTtcblxudmFyIG9uSXJyZWxldmFudEVsZW1lbnQgPSBfY3Vyc29ySGVscGVyLm9uSXJyZWxldmFudEVsZW1lbnQ7XG5cbnZhciBncmFwaGljVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbmZ1bmN0aW9uIG1ha2VSZWN0UGFuZWxDbGlwUGF0aChyZWN0KSB7XG4gIHJlY3QgPSBub3JtYWxpemVSZWN0KHJlY3QpO1xuICByZXR1cm4gZnVuY3Rpb24gKGxvY2FsUG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZ3JhcGhpY1V0aWwuY2xpcFBvaW50c0J5UmVjdChsb2NhbFBvaW50cywgcmVjdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VMaW5lYXJCcnVzaE90aGVyRXh0ZW50KHJlY3QsIHNwZWNpZmllZFhZSW5kZXgpIHtcbiAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gIHJldHVybiBmdW5jdGlvbiAoeHlJbmRleCkge1xuICAgIHZhciBpZHggPSBzcGVjaWZpZWRYWUluZGV4ICE9IG51bGwgPyBzcGVjaWZpZWRYWUluZGV4IDogeHlJbmRleDtcbiAgICB2YXIgYnJ1c2hXaWR0aCA9IGlkeCA/IHJlY3Qud2lkdGggOiByZWN0LmhlaWdodDtcbiAgICB2YXIgYmFzZSA9IGlkeCA/IHJlY3QueCA6IHJlY3QueTtcbiAgICByZXR1cm4gW2Jhc2UsIGJhc2UgKyAoYnJ1c2hXaWR0aCB8fCAwKV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VSZWN0SXNUYXJnZXRCeUN1cnNvcihyZWN0LCBhcGksIHRhcmdldE1vZGVsKSB7XG4gIHJlY3QgPSBub3JtYWxpemVSZWN0KHJlY3QpO1xuICByZXR1cm4gZnVuY3Rpb24gKGUsIGxvY2FsQ3Vyc29yUG9pbnQsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiByZWN0LmNvbnRhaW4obG9jYWxDdXJzb3JQb2ludFswXSwgbG9jYWxDdXJzb3JQb2ludFsxXSkgJiYgIW9uSXJyZWxldmFudEVsZW1lbnQoZSwgYXBpLCB0YXJnZXRNb2RlbCk7XG4gIH07XG59IC8vIENvbnNpZGVyIHdpZHRoL2hlaWdodCBpcyBuZWdhdGl2ZS5cblxuXG5mdW5jdGlvbiBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIEJvdW5kaW5nUmVjdC5jcmVhdGUocmVjdCk7XG59XG5cbmV4cG9ydHMubWFrZVJlY3RQYW5lbENsaXBQYXRoID0gbWFrZVJlY3RQYW5lbENsaXBQYXRoO1xuZXhwb3J0cy5tYWtlTGluZWFyQnJ1c2hPdGhlckV4dGVudCA9IG1ha2VMaW5lYXJCcnVzaE90aGVyRXh0ZW50O1xuZXhwb3J0cy5tYWtlUmVjdElzVGFyZ2V0QnlDdXJzb3IgPSBtYWtlUmVjdElzVGFyZ2V0QnlDdXJzb3I7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9icnVzaEhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9icnVzaEhlbHBlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBJUlJFTEVWQU5UX0VYQ0xVREVTID0ge1xuICAnYXhpc1BvaW50ZXInOiAxLFxuICAndG9vbHRpcCc6IDEsXG4gICdicnVzaCc6IDFcbn07XG4vKipcbiAqIEF2b2lkIHRoYXQ6IG1vdXNlIGNsaWNrIG9uIGEgZWxlbWVudHMgdGhhdCBpcyBvdmVyIGdlbyBvciBncmFwaCxcbiAqIGJ1dCByb2FtIGlzIHRyaWdnZXJlZC5cbiAqL1xuXG5mdW5jdGlvbiBvbklycmVsZXZhbnRFbGVtZW50KGUsIGFwaSwgdGFyZ2V0Q29vcmRTeXNNb2RlbCkge1xuICB2YXIgbW9kZWwgPSBhcGkuZ2V0Q29tcG9uZW50QnlFbGVtZW50KGUudG9wVGFyZ2V0KTsgLy8gSWYgbW9kZWwgaXMgYXhpc01vZGVsLCBpdCB3b3JrcyBvbmx5IGlmIGl0IGlzIGluamVjdGVkIHdpdGggY29vcmRpbmF0ZVN5c3RlbS5cblxuICB2YXIgY29vcmRTeXMgPSBtb2RlbCAmJiBtb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICByZXR1cm4gbW9kZWwgJiYgbW9kZWwgIT09IHRhcmdldENvb3JkU3lzTW9kZWwgJiYgIUlSUkVMRVZBTlRfRVhDTFVERVNbbW9kZWwubWFpblR5cGVdICYmIGNvb3JkU3lzICYmIGNvb3JkU3lzLm1vZGVsICE9PSB0YXJnZXRDb29yZFN5c01vZGVsO1xufVxuXG5leHBvcnRzLm9uSXJyZWxldmFudEVsZW1lbnQgPSBvbklycmVsZXZhbnRFbGVtZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvY3Vyc29ySGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2N1cnNvckhlbHBlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciBBVFRSID0gJ1xcMF9lY19pbnRlcmFjdGlvbl9tdXRleCc7XG5cbmZ1bmN0aW9uIHRha2UoenIsIHJlc291cmNlS2V5LCB1c2VyS2V5KSB7XG4gIHZhciBzdG9yZSA9IGdldFN0b3JlKHpyKTtcbiAgc3RvcmVbcmVzb3VyY2VLZXldID0gdXNlcktleTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZSh6ciwgcmVzb3VyY2VLZXksIHVzZXJLZXkpIHtcbiAgdmFyIHN0b3JlID0gZ2V0U3RvcmUoenIpO1xuICB2YXIgdUtleSA9IHN0b3JlW3Jlc291cmNlS2V5XTtcblxuICBpZiAodUtleSA9PT0gdXNlcktleSkge1xuICAgIHN0b3JlW3Jlc291cmNlS2V5XSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUYWtlbih6ciwgcmVzb3VyY2VLZXkpIHtcbiAgcmV0dXJuICEhZ2V0U3RvcmUoenIpW3Jlc291cmNlS2V5XTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RvcmUoenIpIHtcbiAgcmV0dXJuIHpyW0FUVFJdIHx8ICh6cltBVFRSXSA9IHt9KTtcbn1cbi8qKlxuICogcGF5bG9hZDoge1xuICogICAgIHR5cGU6ICd0YWtlR2xvYmFsQ3Vyc29yJyxcbiAqICAgICBrZXk6ICdkYXRhWm9vbVNlbGVjdCcsIG9yICdicnVzaCcsIG9yIC4uLixcbiAqICAgICAgICAgSWYgbm8gdXNlcktleSwgcmVsZWFzZSBnbG9iYWwgY3Vyc29yLlxuICogfVxuICovXG5cblxuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICd0YWtlR2xvYmFsQ3Vyc29yJyxcbiAgZXZlbnQ6ICdnbG9iYWxDdXJzb3JUYWtlbicsXG4gIHVwZGF0ZTogJ3VwZGF0ZSdcbn0sIGZ1bmN0aW9uICgpIHt9KTtcbmV4cG9ydHMudGFrZSA9IHRha2U7XG5leHBvcnRzLnJlbGVhc2UgPSByZWxlYXNlO1xuZXhwb3J0cy5pc1Rha2VuID0gaXNUYWtlbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2ludGVyYWN0aW9uTXV0ZXguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvaW50ZXJhY3Rpb25NdXRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfbGF5b3V0ID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgZ2V0TGF5b3V0UmVjdCA9IF9sYXlvdXQuZ2V0TGF5b3V0UmVjdDtcbnZhciBsYXlvdXRCb3ggPSBfbGF5b3V0LmJveDtcbnZhciBwb3NpdGlvbkVsZW1lbnQgPSBfbGF5b3V0LnBvc2l0aW9uRWxlbWVudDtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxuLyoqXG4gKiBMYXlvdXQgbGlzdCBsaWtlIGNvbXBvbmVudC5cbiAqIEl0IHdpbGwgYm94IGxheW91dCBlYWNoIGl0ZW1zIGluIGdyb3VwIG9mIGNvbXBvbmVudCBhbmQgdGhlbiBwb3NpdGlvbiB0aGUgd2hvbGUgZ3JvdXAgaW4gdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyb3VwL0dyb3VwfSBncm91cFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IGNvbXBvbmVudE1vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAqL1xuZnVuY3Rpb24gbGF5b3V0KGdyb3VwLCBjb21wb25lbnRNb2RlbCwgYXBpKSB7XG4gIHZhciBib3hMYXlvdXRQYXJhbXMgPSBjb21wb25lbnRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKTtcbiAgdmFyIHBhZGRpbmcgPSBjb21wb25lbnRNb2RlbC5nZXQoJ3BhZGRpbmcnKTtcbiAgdmFyIHZpZXdwb3J0U2l6ZSA9IHtcbiAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgfTtcbiAgdmFyIHJlY3QgPSBnZXRMYXlvdXRSZWN0KGJveExheW91dFBhcmFtcywgdmlld3BvcnRTaXplLCBwYWRkaW5nKTtcbiAgbGF5b3V0Qm94KGNvbXBvbmVudE1vZGVsLmdldCgnb3JpZW50JyksIGdyb3VwLCBjb21wb25lbnRNb2RlbC5nZXQoJ2l0ZW1HYXAnKSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICBwb3NpdGlvbkVsZW1lbnQoZ3JvdXAsIGJveExheW91dFBhcmFtcywgdmlld3BvcnRTaXplLCBwYWRkaW5nKTtcbn1cblxuZnVuY3Rpb24gbWFrZUJhY2tncm91bmQocmVjdCwgY29tcG9uZW50TW9kZWwpIHtcbiAgdmFyIHBhZGRpbmcgPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KGNvbXBvbmVudE1vZGVsLmdldCgncGFkZGluZycpKTtcbiAgdmFyIHN0eWxlID0gY29tcG9uZW50TW9kZWwuZ2V0SXRlbVN0eWxlKFsnY29sb3InLCAnb3BhY2l0eSddKTtcbiAgc3R5bGUuZmlsbCA9IGNvbXBvbmVudE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHg6IHJlY3QueCAtIHBhZGRpbmdbM10sXG4gICAgICB5OiByZWN0LnkgLSBwYWRkaW5nWzBdLFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGggKyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKyBwYWRkaW5nWzBdICsgcGFkZGluZ1syXSxcbiAgICAgIHI6IGNvbXBvbmVudE1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJylcbiAgICB9LFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBzaWxlbnQ6IHRydWUsXG4gICAgejI6IC0xXG4gIH0pOyAvLyBGSVhNRVxuICAvLyBgc3ViUGl4ZWxPcHRpbWl6ZVJlY3RgIG1heSBicmluZyBzb21lIGdhcCBiZXR3ZWVuIGVkZ2Ugb2Ygdmlld3BhcnRcbiAgLy8gYW5kIGJhY2tncm91bmQgcmVjdCB3aGVuIHNldHRpbmcgbGlrZSBgbGVmdDogMGAsIGB0b3A6IDBgLlxuICAvLyBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVSZWN0KHJlY3QpO1xuXG4gIHJldHVybiByZWN0O1xufVxuXG5leHBvcnRzLmxheW91dCA9IGxheW91dDtcbmV4cG9ydHMubWFrZUJhY2tncm91bmQgPSBtYWtlQmFja2dyb3VuZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2xpc3RDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvbGlzdENvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ2FsY3VsYXRlIHNsaWRlciBtb3ZlIHJlc3VsdC5cbiAqIFVzYWdlOlxuICogKDEpIElmIGJvdGggaGFuZGxlMCBhbmQgaGFuZGxlMSBhcmUgbmVlZGVkIHRvIGJlIG1vdmVkLCBzZXQgbWluU3BhbiB0aGUgc2FtZSBhc1xuICogbWF4U3BhbiBhbmQgdGhlIHNhbWUgYXMgYE1hdGguYWJzKGhhbmRsZUVuZFsxXSAtIGhhbmRsZUVuZHNbMF0pYC5cbiAqICgyKSBJZiBoYW5kbGUwIGlzIGZvcmJpZGRlbiB0byBjcm9zcyBoYW5kbGUxLCBzZXQgbWluU3BhbiBhcyBgMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIE1vdmUgbGVuZ3RoLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaGFuZGxlRW5kcyBoYW5kbGVFbmRzWzBdIGNhbiBiZSBiaWdnZXIgdGhlbiBoYW5kbGVFbmRzWzFdLlxuICogICAgICAgICAgICAgIGhhbmRsZUVuZHMgd2lsbCBiZSBtb2RpZmllZCBpbiB0aGlzIG1ldGhvZC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGV4dGVudCBoYW5kbGVFbmRzIGlzIHJlc3RyaWN0ZWQgYnkgZXh0ZW50LlxuICogICAgICAgICAgICAgIGV4dGVudFswXSBzaG91bGQgbGVzcyBvciBlcXVhbHMgdGhhbiBleHRlbnRbMV0uXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGhhbmRsZUluZGV4IENhbiBiZSAnYWxsJywgbWVhbnMgdGhhdCBib3RoIG1vdmUgdGhlIHR3byBoYW5kbGVFbmRzLFxuICogICAgICAgICAgICAgIHdoZXJlIHRoZSBpbnB1dCBtaW5TcGFuIGFuZCBtYXhTcGFuIHdpbGwgbm90IHdvcmsuXG4gKiBAcGFyYW0ge251bWJlcn0gW21pblNwYW5dIFRoZSByYW5nZSBvZiBkYXRhWm9vbSBjYW4gbm90IGJlIHNtYWxsZXIgdGhhbiB0aGF0LlxuICogICAgICAgICAgICAgIElmIG5vdCBzZXQsIGhhbmRsZTAgYW5kIGNyb3NzIGhhbmRsZTEuIElmIHNldCBhcyBhIG5vbi1uZWdhdGl2ZVxuICogICAgICAgICAgICAgIG51bWJlciAoaW5jbHVkaW5nIGAwYCksIGhhbmRsZXMgd2lsbCBwdXNoIGVhY2ggb3RoZXIgd2hlbiByZWFjaGluZ1xuICogICAgICAgICAgICAgIHRoZSBtaW5TcGFuLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhTcGFuXSBUaGUgcmFuZ2Ugb2YgZGF0YVpvb20gY2FuIG5vdCBiZSBsYXJnZXIgdGhhbiB0aGF0LlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFRoZSBpbnB1dCBoYW5kbGVFbmRzLlxuICovXG5mdW5jdGlvbiBfZGVmYXVsdChkZWx0YSwgaGFuZGxlRW5kcywgZXh0ZW50LCBoYW5kbGVJbmRleCwgbWluU3BhbiwgbWF4U3Bhbikge1xuICAvLyBOb3JtYWxpemUgZmlyc3RseS5cbiAgaGFuZGxlRW5kc1swXSA9IHJlc3RyaWN0KGhhbmRsZUVuZHNbMF0sIGV4dGVudCk7XG4gIGhhbmRsZUVuZHNbMV0gPSByZXN0cmljdChoYW5kbGVFbmRzWzFdLCBleHRlbnQpO1xuICBkZWx0YSA9IGRlbHRhIHx8IDA7XG4gIHZhciBleHRlbnRTcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdOyAvLyBOb3RpY2UgbWF4U3BhbiBhbmQgbWluU3BhbiBjYW4gYmUgbnVsbC91bmRlZmluZWQuXG5cbiAgaWYgKG1pblNwYW4gIT0gbnVsbCkge1xuICAgIG1pblNwYW4gPSByZXN0cmljdChtaW5TcGFuLCBbMCwgZXh0ZW50U3Bhbl0pO1xuICB9XG5cbiAgaWYgKG1heFNwYW4gIT0gbnVsbCkge1xuICAgIG1heFNwYW4gPSBNYXRoLm1heChtYXhTcGFuLCBtaW5TcGFuICE9IG51bGwgPyBtaW5TcGFuIDogMCk7XG4gIH1cblxuICBpZiAoaGFuZGxlSW5kZXggPT09ICdhbGwnKSB7XG4gICAgbWluU3BhbiA9IG1heFNwYW4gPSBNYXRoLmFicyhoYW5kbGVFbmRzWzFdIC0gaGFuZGxlRW5kc1swXSk7XG4gICAgaGFuZGxlSW5kZXggPSAwO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsRGlzdFNpZ24gPSBnZXRTcGFuU2lnbihoYW5kbGVFbmRzLCBoYW5kbGVJbmRleCk7XG4gIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICs9IGRlbHRhOyAvLyBSZXN0cmljdCBpbiBleHRlbnQuXG5cbiAgdmFyIGV4dGVudE1pblNwYW4gPSBtaW5TcGFuIHx8IDA7XG4gIHZhciByZWFsRXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gIG9yaWdpbmFsRGlzdFNpZ24uc2lnbiA8IDAgPyByZWFsRXh0ZW50WzBdICs9IGV4dGVudE1pblNwYW4gOiByZWFsRXh0ZW50WzFdIC09IGV4dGVudE1pblNwYW47XG4gIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdID0gcmVzdHJpY3QoaGFuZGxlRW5kc1toYW5kbGVJbmRleF0sIHJlYWxFeHRlbnQpOyAvLyBFeHBhbmQgc3Bhbi5cblxuICB2YXIgY3VyckRpc3RTaWduID0gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpO1xuXG4gIGlmIChtaW5TcGFuICE9IG51bGwgJiYgKGN1cnJEaXN0U2lnbi5zaWduICE9PSBvcmlnaW5hbERpc3RTaWduLnNpZ24gfHwgY3VyckRpc3RTaWduLnNwYW4gPCBtaW5TcGFuKSkge1xuICAgIC8vIElmIG1pblNwYW4gZXhpc3RzLCAnY3Jvc3MnIGlzIGZvcmJpbmRlbi5cbiAgICBoYW5kbGVFbmRzWzEgLSBoYW5kbGVJbmRleF0gPSBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSArIG9yaWdpbmFsRGlzdFNpZ24uc2lnbiAqIG1pblNwYW47XG4gIH0gLy8gU2hyaW5rIHNwYW4uXG5cblxuICB2YXIgY3VyckRpc3RTaWduID0gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpO1xuXG4gIGlmIChtYXhTcGFuICE9IG51bGwgJiYgY3VyckRpc3RTaWduLnNwYW4gPiBtYXhTcGFuKSB7XG4gICAgaGFuZGxlRW5kc1sxIC0gaGFuZGxlSW5kZXhdID0gaGFuZGxlRW5kc1toYW5kbGVJbmRleF0gKyBjdXJyRGlzdFNpZ24uc2lnbiAqIG1heFNwYW47XG4gIH1cblxuICByZXR1cm4gaGFuZGxlRW5kcztcbn1cblxuZnVuY3Rpb24gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpIHtcbiAgdmFyIGRpc3QgPSBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSAtIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XTsgLy8gSWYgYGhhbmRsZUVuZHNbMF0gPT09IGhhbmRsZUVuZHNbMV1gLCBhbHdheXMgYmVsaWV2ZSB0aGF0IGhhbmRsZUVuZFswXVxuICAvLyBpcyBhdCBsZWZ0IG9mIGhhbmRsZUVuZHNbMV0gZm9yIG5vbi1jcm9zcyBjYXNlLlxuXG4gIHJldHVybiB7XG4gICAgc3BhbjogTWF0aC5hYnMoZGlzdCksXG4gICAgc2lnbjogZGlzdCA+IDAgPyAtMSA6IGRpc3QgPCAwID8gMSA6IGhhbmRsZUluZGV4ID8gLTEgOiAxXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc3RyaWN0KHZhbHVlLCBleHRlbmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKGV4dGVuZFsxXSwgTWF0aC5tYXgoZXh0ZW5kWzBdLCB2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvc2xpZGVyTW92ZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9zbGlkZXJNb3ZlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxucmVxdWlyZShcIi4vbGVnZW5kL0xlZ2VuZE1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9sZWdlbmQvbGVnZW5kQWN0aW9uXCIpO1xuXG5yZXF1aXJlKFwiLi9sZWdlbmQvTGVnZW5kVmlld1wiKTtcblxudmFyIGxlZ2VuZEZpbHRlciA9IHJlcXVpcmUoXCIuL2xlZ2VuZC9sZWdlbmRGaWx0ZXJcIik7XG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiLi4vbW9kZWwvQ29tcG9uZW50XCIpO1xuXG4vLyBEbyBub3QgY29udGFpbiBzY3JvbGxhYmxlIGxlZ2VuZCwgZm9yIHNha2Ugb2YgZmlsZSBzaXplLlxuLy8gU2VyaWVzIEZpbHRlclxuZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihsZWdlbmRGaWx0ZXIpO1xuQ29tcG9uZW50LnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcignbGVnZW5kJywgZnVuY3Rpb24gKCkge1xuICAvLyBEZWZhdWx0ICdwbGFpbicgd2hlbiBubyB0eXBlIHNwZWNpZmllZC5cbiAgcmV0dXJuICdwbGFpbic7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIExlZ2VuZE1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdsZWdlbmQucGxhaW4nLFxuICBkZXBlbmRlbmNpZXM6IFsnc2VyaWVzJ10sXG4gIGxheW91dE1vZGU6IHtcbiAgICB0eXBlOiAnYm94JyxcbiAgICAvLyBsZWdlbmQud2lkdGgvaGVpZ2h0IGFyZSBtYXhXaWR0aC9tYXhIZWlnaHQgYWN0dWFsbHksXG4gICAgLy8gd2hlcmVhcyByZWFseSB3aWR0aC9oZWlnaHQgaXMgY2FsY3VsYXRlZCBieSBpdHMgY29udGVudC5cbiAgICAvLyAoU2V0dGluZyB7bGVmdDogMTAsIHJpZ2h0OiAxMH0gZG9lcyBub3QgbWFrZSBzZW5zZSkuXG4gICAgLy8gU28gY29uc2lkZXIgdGhlIGNhc2U6XG4gICAgLy8gYHNldE9wdGlvbih7bGVnZW5kOiB7bGVmdDogMTB9KTtgXG4gICAgLy8gdGhlbiBgc2V0T3B0aW9uKHtsZWdlbmQ6IHtyaWdodDogMTB9KTtgXG4gICAgLy8gVGhlIHByZXZpb3VzIGBsZWZ0YCBzaG91bGQgYmUgY2xlYXJlZCBieSBzZXR0aW5nIGBpZ25vcmVTaXplYC5cbiAgICBpZ25vcmVTaXplOiB0cnVlXG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvbi5zZWxlY3RlZCB8fCB7fTtcbiAgfSxcbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBMZWdlbmRNb2RlbC5zdXBlckNhbGwodGhpcywgJ21lcmdlT3B0aW9uJywgb3B0aW9uKTtcbiAgfSxcbiAgb3B0aW9uVXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZURhdGEodGhpcy5lY01vZGVsKTtcblxuICAgIHZhciBsZWdlbmREYXRhID0gdGhpcy5fZGF0YTsgLy8gSWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZSwgdHJ5IHRvIHNlbGVjdCBvbmVcblxuICAgIGlmIChsZWdlbmREYXRhWzBdICYmIHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHZhciBoYXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBJZiBoYXMgYW55IHNlbGVjdGVkIGluIG9wdGlvbi5zZWxlY3RlZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsZWdlbmREYXRhW2ldLmdldCgnbmFtZScpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQobmFtZSkpIHtcbiAgICAgICAgICAvLyBGb3JjZSB0byB1bnNlbGVjdCBvdGhlcnNcbiAgICAgICAgICB0aGlzLnNlbGVjdChuYW1lKTtcbiAgICAgICAgICBoYXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVHJ5IHNlbGVjdCB0aGUgZmlyc3QgaWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZVxuXG5cbiAgICAgICFoYXNTZWxlY3RlZCAmJiB0aGlzLnNlbGVjdChsZWdlbmREYXRhWzBdLmdldCgnbmFtZScpKTtcbiAgICB9XG4gIH0sXG4gIF91cGRhdGVEYXRhOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBsZWdlbmREYXRhID0genJVdGlsLm1hcCh0aGlzLmdldCgnZGF0YScpIHx8IFtdLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgIC8vIENhbiBiZSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICBpZiAodHlwZW9mIGRhdGFJdGVtID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0YUl0ZW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGFJdGVtID0ge1xuICAgICAgICAgIG5hbWU6IGRhdGFJdGVtXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTW9kZWwoZGF0YUl0ZW0sIHRoaXMsIHRoaXMuZWNNb2RlbCk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fZGF0YSA9IGxlZ2VuZERhdGE7XG4gICAgdmFyIGF2YWlsYWJsZU5hbWVzID0genJVdGlsLm1hcChlY01vZGVsLmdldFNlcmllcygpLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICByZXR1cm4gc2VyaWVzLm5hbWU7XG4gICAgfSk7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcigpO1xuICAgICAgICBhdmFpbGFibGVOYW1lcyA9IGF2YWlsYWJsZU5hbWVzLmNvbmNhdChkYXRhLm1hcEFycmF5KGRhdGEuZ2V0TmFtZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fYXZhaWxhYmxlTmFtZXMgPSBhdmFpbGFibGVOYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPn1cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICB2YXIgc2VsZWN0ZWRNb2RlID0gdGhpcy5nZXQoJ3NlbGVjdGVkTW9kZScpO1xuXG4gICAgaWYgKHNlbGVjdGVkTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgIHpyVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICBzZWxlY3RlZFtkYXRhSXRlbS5nZXQoJ25hbWUnKV0gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHVuU2VsZWN0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJykgIT09ICdzaW5nbGUnKSB7XG4gICAgICB0aGlzLm9wdGlvbi5zZWxlY3RlZFtuYW1lXSA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHRvZ2dsZVNlbGVjdGVkOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkOyAvLyBEZWZhdWx0IGlzIHRydWVcblxuICAgIGlmICghc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzW3NlbGVjdGVkW25hbWVdID8gJ3VuU2VsZWN0JyA6ICdzZWxlY3QnXShuYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICEoc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIXNlbGVjdGVkW25hbWVdKSAmJiB6clV0aWwuaW5kZXhPZih0aGlzLl9hdmFpbGFibGVOYW1lcywgbmFtZSkgPj0gMDtcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIC8vIOS4gOe6p+WxguWPoFxuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICB6OiA0LFxuICAgIHNob3c6IHRydWUsXG4gICAgLy8g5biD5bGA5pa55byP77yM6buY6K6k5Li65rC05bmz5biD5bGA77yM5Y+v6YCJ5Li677yaXG4gICAgLy8gJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJ1xuICAgIG9yaWVudDogJ2hvcml6b250YWwnLFxuICAgIGxlZnQ6ICdjZW50ZXInLFxuICAgIC8vIHJpZ2h0OiAnY2VudGVyJyxcbiAgICB0b3A6IDAsXG4gICAgLy8gYm90dG9tOiBudWxsLFxuICAgIC8vIOawtOW5s+Wvuem9kFxuICAgIC8vICdhdXRvJyB8ICdsZWZ0JyB8ICdyaWdodCdcbiAgICAvLyDpu5jorqTkuLogJ2F1dG8nLCDmoLnmja4geCDnmoTkvY3nva7liKTmlq3mmK/lt6blr7npvZDov5jmmK/lj7Plr7npvZBcbiAgICBhbGlnbjogJ2F1dG8nLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIC8vIOWbvuS+i+i+ueahhuminOiJslxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIC8vIOWbvuS+i+i+ueahhue6v+Wuve+8jOWNleS9jXB477yM6buY6K6k5Li6MO+8iOaXoOi+ueahhu+8iVxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIC8vIOWbvuS+i+WGhei+uei3ne+8jOWNleS9jXB477yM6buY6K6k5ZCE5pa55ZCR5YaF6L656Led5Li6Ne+8jFxuICAgIC8vIOaOpeWPl+aVsOe7hOWIhuWIq+iuvuWumuS4iuWPs+S4i+W3pui+uei3ne+8jOWQjGNzc1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLy8g5ZCE5LiqaXRlbeS5i+mXtOeahOmXtOmalO+8jOWNleS9jXB477yM6buY6K6k5Li6MTDvvIxcbiAgICAvLyDmqKrlkJHluIPlsYDml7bkuLrmsLTlubPpl7TpmpTvvIznurXlkJHluIPlsYDml7bkuLrnurXlkJHpl7TpmpRcbiAgICBpdGVtR2FwOiAxMCxcbiAgICAvLyDlm77kvovlm77lvaLlrr3luqZcbiAgICBpdGVtV2lkdGg6IDI1LFxuICAgIC8vIOWbvuS+i+WbvuW9oumrmOW6plxuICAgIGl0ZW1IZWlnaHQ6IDE0LFxuICAgIC8vIOWbvuS+i+WFs+mXreaXtuWAmeeahOminOiJslxuICAgIGluYWN0aXZlQ29sb3I6ICcjY2NjJyxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIC8vIOWbvuS+i+aWh+Wtl+minOiJslxuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgLy8gZm9ybWF0dGVyOiAnJyxcbiAgICAvLyDpgInmi6nmqKHlvI/vvIzpu5jorqTlvIDlkK/lm77kvovlvIDlhbNcbiAgICBzZWxlY3RlZE1vZGU6IHRydWUsXG4gICAgLy8g6YWN572u6buY6K6k6YCJ5Lit54q25oCB77yM5Y+v6YWN5ZCITEVHRU5ELlNFTEVDVEVE5LqL5Lu25YGa5Yqo5oCB5pWw5o2u6L295YWlXG4gICAgLy8gc2VsZWN0ZWQ6IG51bGwsXG4gICAgLy8g5Zu+5L6L5YaF5a6577yI6K+m6KeBbGVnZW5kLmRhdGHvvIzmlbDnu4TkuK3mr4/kuIDpobnku6PooajkuIDkuKppdGVtXG4gICAgLy8gZGF0YTogW10sXG4gICAgLy8gVG9vbHRpcCDnm7jlhbPphY3nva5cbiAgICB0b29sdGlwOiB7XG4gICAgICBzaG93OiBmYWxzZVxuICAgIH1cbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBMZWdlbmRNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRNb2RlbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3N5bWJvbFwiKTtcblxudmFyIGNyZWF0ZVN5bWJvbCA9IF9zeW1ib2wuY3JlYXRlU3ltYm9sO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBfbGlzdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvbGlzdENvbXBvbmVudFwiKTtcblxudmFyIG1ha2VCYWNrZ3JvdW5kID0gX2xpc3RDb21wb25lbnQubWFrZUJhY2tncm91bmQ7XG5cbnZhciBsYXlvdXRVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIEdyb3VwID0gZ3JhcGhpYy5Hcm91cDtcblxudmFyIF9kZWZhdWx0ID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ2xlZ2VuZC5wbGFpbicsXG4gIG5ld2xpbmVEaXNhYmxlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgKi9cbiAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLl9jb250ZW50R3JvdXAgPSBuZXcgR3JvdXAoKSk7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgKi9cblxuICAgIHRoaXMuX2JhY2tncm91bmRFbDtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0Q29udGVudEdyb3VwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRHcm91cDtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5yZXNldElubmVyKCk7XG5cbiAgICBpZiAoIWxlZ2VuZE1vZGVsLmdldCgnc2hvdycsIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGl0ZW1BbGlnbiA9IGxlZ2VuZE1vZGVsLmdldCgnYWxpZ24nKTtcblxuICAgIGlmICghaXRlbUFsaWduIHx8IGl0ZW1BbGlnbiA9PT0gJ2F1dG8nKSB7XG4gICAgICBpdGVtQWxpZ24gPSBsZWdlbmRNb2RlbC5nZXQoJ2xlZnQnKSA9PT0gJ3JpZ2h0JyAmJiBsZWdlbmRNb2RlbC5nZXQoJ29yaWVudCcpID09PSAndmVydGljYWwnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcklubmVyKGl0ZW1BbGlnbiwgbGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSk7IC8vIFBlcmZvcm0gbGF5b3V0LlxuXG4gICAgdmFyIHBvc2l0aW9uSW5mbyA9IGxlZ2VuZE1vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuICAgIHZhciB2aWV3cG9ydFNpemUgPSB7XG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH07XG4gICAgdmFyIHBhZGRpbmcgPSBsZWdlbmRNb2RlbC5nZXQoJ3BhZGRpbmcnKTtcbiAgICB2YXIgbWF4U2l6ZSA9IGxheW91dFV0aWwuZ2V0TGF5b3V0UmVjdChwb3NpdGlvbkluZm8sIHZpZXdwb3J0U2l6ZSwgcGFkZGluZyk7XG4gICAgdmFyIG1haW5SZWN0ID0gdGhpcy5sYXlvdXRJbm5lcihsZWdlbmRNb2RlbCwgaXRlbUFsaWduLCBtYXhTaXplKTsgLy8gUGxhY2UgbWFpbkdyb3VwLCBiYXNlZCBvbiB0aGUgY2FsY3VsYXRlZCBgbWFpblJlY3RgLlxuXG4gICAgdmFyIGxheW91dFJlY3QgPSBsYXlvdXRVdGlsLmdldExheW91dFJlY3QoenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgIHdpZHRoOiBtYWluUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogbWFpblJlY3QuaGVpZ2h0XG4gICAgfSwgcG9zaXRpb25JbmZvKSwgdmlld3BvcnRTaXplLCBwYWRkaW5nKTtcbiAgICB0aGlzLmdyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgW2xheW91dFJlY3QueCAtIG1haW5SZWN0LngsIGxheW91dFJlY3QueSAtIG1haW5SZWN0LnldKTsgLy8gUmVuZGVyIGJhY2tncm91bmQgYWZ0ZXIgZ3JvdXAgaXMgbGF5b3V0LlxuXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5fYmFja2dyb3VuZEVsID0gbWFrZUJhY2tncm91bmQobWFpblJlY3QsIGxlZ2VuZE1vZGVsKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlc2V0SW5uZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdldENvbnRlbnRHcm91cCgpLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX2JhY2tncm91bmRFbCAmJiB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLl9iYWNrZ3JvdW5kRWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICByZW5kZXJJbm5lcjogZnVuY3Rpb24gKGl0ZW1BbGlnbiwgbGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb250ZW50R3JvdXAgPSB0aGlzLmdldENvbnRlbnRHcm91cCgpO1xuICAgIHZhciBsZWdlbmREcmF3bk1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgdmFyIHNlbGVjdE1vZGUgPSBsZWdlbmRNb2RlbC5nZXQoJ3NlbGVjdGVkTW9kZScpO1xuICAgIGVhY2gobGVnZW5kTW9kZWwuZ2V0RGF0YSgpLCBmdW5jdGlvbiAoaXRlbU1vZGVsLCBkYXRhSW5kZXgpIHtcbiAgICAgIHZhciBuYW1lID0gaXRlbU1vZGVsLmdldCgnbmFtZScpOyAvLyBVc2UgZW1wdHkgc3RyaW5nIG9yIFxcbiBhcyBhIG5ld2xpbmUgc3RyaW5nXG5cbiAgICAgIGlmICghdGhpcy5uZXdsaW5lRGlzYWJsZWQgJiYgKG5hbWUgPT09ICcnIHx8IG5hbWUgPT09ICdcXG4nKSkge1xuICAgICAgICBjb250ZW50R3JvdXAuYWRkKG5ldyBHcm91cCh7XG4gICAgICAgICAgbmV3bGluZTogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeU5hbWUobmFtZSlbMF07XG5cbiAgICAgIGlmIChsZWdlbmREcmF3bk1hcC5nZXQobmFtZSkpIHtcbiAgICAgICAgLy8gSGF2ZSBiZWVuIGRyYXdlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFNlcmllcyBsZWdlbmRcblxuXG4gICAgICBpZiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0VmlzdWFsKCdjb2xvcicpOyAvLyBJZiBjb2xvciBpcyBhIGNhbGxiYWNrIGZ1bmN0aW9uXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZmlyc3QgZGF0YVxuICAgICAgICAgIGNvbG9yID0gY29sb3Ioc2VyaWVzTW9kZWwuZ2V0RGF0YVBhcmFtcygwKSk7XG4gICAgICAgIH0gLy8gVXNpbmcgcmVjdCBzeW1ib2wgZGVmYXVsdGx5XG5cblxuICAgICAgICB2YXIgbGVnZW5kU3ltYm9sVHlwZSA9IGRhdGEuZ2V0VmlzdWFsKCdsZWdlbmRTeW1ib2wnKSB8fCAncm91bmRSZWN0JztcbiAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBkYXRhLmdldFZpc3VhbCgnc3ltYm9sJyk7XG5cbiAgICAgICAgdmFyIGl0ZW1Hcm91cCA9IHRoaXMuX2NyZWF0ZUl0ZW0obmFtZSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLCBsZWdlbmRTeW1ib2xUeXBlLCBzeW1ib2xUeXBlLCBpdGVtQWxpZ24sIGNvbG9yLCBzZWxlY3RNb2RlKTtcblxuICAgICAgICBpdGVtR3JvdXAub24oJ2NsaWNrJywgY3VycnkoZGlzcGF0Y2hTZWxlY3RBY3Rpb24sIG5hbWUsIGFwaSkpLm9uKCdtb3VzZW92ZXInLCBjdXJyeShkaXNwYXRjaEhpZ2hsaWdodEFjdGlvbiwgc2VyaWVzTW9kZWwsIG51bGwsIGFwaSkpLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIHNlcmllc01vZGVsLCBudWxsLCBhcGkpKTtcbiAgICAgICAgbGVnZW5kRHJhd25NYXAuc2V0KG5hbWUsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGF0YSBsZWdlbmQgb2YgcGllLCBmdW5uZWxcbiAgICAgICAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgIC8vIEluIGNhc2UgbXVsdGlwbGUgc2VyaWVzIGhhcyBzYW1lIGRhdGEgbmFtZVxuICAgICAgICAgIGlmIChsZWdlbmREcmF3bk1hcC5nZXQobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VyaWVzTW9kZWwubGVnZW5kRGF0YVByb3ZpZGVyKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcigpO1xuICAgICAgICAgICAgdmFyIGlkeCA9IGRhdGEuaW5kZXhPZk5hbWUobmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7XG4gICAgICAgICAgICB2YXIgbGVnZW5kU3ltYm9sVHlwZSA9ICdyb3VuZFJlY3QnO1xuXG4gICAgICAgICAgICB2YXIgaXRlbUdyb3VwID0gdGhpcy5fY3JlYXRlSXRlbShuYW1lLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGVnZW5kTW9kZWwsIGxlZ2VuZFN5bWJvbFR5cGUsIG51bGwsIGl0ZW1BbGlnbiwgY29sb3IsIHNlbGVjdE1vZGUpO1xuXG4gICAgICAgICAgICBpdGVtR3JvdXAub24oJ2NsaWNrJywgY3VycnkoZGlzcGF0Y2hTZWxlY3RBY3Rpb24sIG5hbWUsIGFwaSkpIC8vIEZJWE1FIFNob3VsZCBub3Qgc3BlY2lmeSB0aGUgc2VyaWVzIG5hbWVcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgY3VycnkoZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24sIHNlcmllc01vZGVsLCBuYW1lLCBhcGkpKS5vbignbW91c2VvdXQnLCBjdXJyeShkaXNwYXRjaERvd25wbGF5QWN0aW9uLCBzZXJpZXNNb2RlbCwgbmFtZSwgYXBpKSk7XG4gICAgICAgICAgICBsZWdlbmREcmF3bk1hcC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfSxcbiAgX2NyZWF0ZUl0ZW06IGZ1bmN0aW9uIChuYW1lLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGVnZW5kTW9kZWwsIGxlZ2VuZFN5bWJvbFR5cGUsIHN5bWJvbFR5cGUsIGl0ZW1BbGlnbiwgY29sb3IsIHNlbGVjdE1vZGUpIHtcbiAgICB2YXIgaXRlbVdpZHRoID0gbGVnZW5kTW9kZWwuZ2V0KCdpdGVtV2lkdGgnKTtcbiAgICB2YXIgaXRlbUhlaWdodCA9IGxlZ2VuZE1vZGVsLmdldCgnaXRlbUhlaWdodCcpO1xuICAgIHZhciBpbmFjdGl2ZUNvbG9yID0gbGVnZW5kTW9kZWwuZ2V0KCdpbmFjdGl2ZUNvbG9yJyk7XG4gICAgdmFyIGlzU2VsZWN0ZWQgPSBsZWdlbmRNb2RlbC5pc1NlbGVjdGVkKG5hbWUpO1xuICAgIHZhciBpdGVtR3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgIHZhciBpdGVtSWNvbiA9IGl0ZW1Nb2RlbC5nZXQoJ2ljb24nKTtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCd0b29sdGlwJyk7XG4gICAgdmFyIGxlZ2VuZEdsb2JhbFRvb2x0aXBNb2RlbCA9IHRvb2x0aXBNb2RlbC5wYXJlbnRNb2RlbDsgLy8gVXNlIHVzZXIgZ2l2ZW4gaWNvbiBmaXJzdFxuXG4gICAgbGVnZW5kU3ltYm9sVHlwZSA9IGl0ZW1JY29uIHx8IGxlZ2VuZFN5bWJvbFR5cGU7XG4gICAgaXRlbUdyb3VwLmFkZChjcmVhdGVTeW1ib2wobGVnZW5kU3ltYm9sVHlwZSwgMCwgMCwgaXRlbVdpZHRoLCBpdGVtSGVpZ2h0LCBpc1NlbGVjdGVkID8gY29sb3IgOiBpbmFjdGl2ZUNvbG9yLCB0cnVlKSk7IC8vIENvbXBvc2Ugc3ltYm9sc1xuICAgIC8vIFBFTkRJTkdcblxuICAgIGlmICghaXRlbUljb24gJiYgc3ltYm9sVHlwZSAvLyBBdCBsZWFzdCBzaG93IG9uZSBzeW1ib2wsIGNhbid0IGJlIGFsbCBub25lXG4gICAgJiYgKHN5bWJvbFR5cGUgIT09IGxlZ2VuZFN5bWJvbFR5cGUgfHwgc3ltYm9sVHlwZSA9PSAnbm9uZScpKSB7XG4gICAgICB2YXIgc2l6ZSA9IGl0ZW1IZWlnaHQgKiAwLjg7XG5cbiAgICAgIGlmIChzeW1ib2xUeXBlID09PSAnbm9uZScpIHtcbiAgICAgICAgc3ltYm9sVHlwZSA9ICdjaXJjbGUnO1xuICAgICAgfSAvLyBQdXQgc3ltYm9sIGluIHRoZSBjZW50ZXJcblxuXG4gICAgICBpdGVtR3JvdXAuYWRkKGNyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCAoaXRlbVdpZHRoIC0gc2l6ZSkgLyAyLCAoaXRlbUhlaWdodCAtIHNpemUpIC8gMiwgc2l6ZSwgc2l6ZSwgaXNTZWxlY3RlZCA/IGNvbG9yIDogaW5hY3RpdmVDb2xvcikpO1xuICAgIH1cblxuICAgIHZhciB0ZXh0WCA9IGl0ZW1BbGlnbiA9PT0gJ2xlZnQnID8gaXRlbVdpZHRoICsgNSA6IC01O1xuICAgIHZhciB0ZXh0QWxpZ24gPSBpdGVtQWxpZ247XG4gICAgdmFyIGZvcm1hdHRlciA9IGxlZ2VuZE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgdmFyIGNvbnRlbnQgPSBuYW1lO1xuXG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnICYmIGZvcm1hdHRlcikge1xuICAgICAgY29udGVudCA9IGZvcm1hdHRlci5yZXBsYWNlKCd7bmFtZX0nLCBuYW1lICE9IG51bGwgPyBuYW1lIDogJycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGVudCA9IGZvcm1hdHRlcihuYW1lKTtcbiAgICB9XG5cbiAgICBpdGVtR3JvdXAuYWRkKG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgc3R5bGU6IGdyYXBoaWMuc2V0VGV4dFN0eWxlKHt9LCB0ZXh0U3R5bGVNb2RlbCwge1xuICAgICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgICB4OiB0ZXh0WCxcbiAgICAgICAgeTogaXRlbUhlaWdodCAvIDIsXG4gICAgICAgIHRleHRGaWxsOiBpc1NlbGVjdGVkID8gdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgOiBpbmFjdGl2ZUNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgICB9KVxuICAgIH0pKTsgLy8gQWRkIGEgaW52aXNpYmxlIHJlY3QgdG8gaW5jcmVhc2UgdGhlIGFyZWEgb2YgbW91c2UgaG92ZXJcblxuICAgIHZhciBoaXRSZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBzaGFwZTogaXRlbUdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLFxuICAgICAgaW52aXNpYmxlOiB0cnVlLFxuICAgICAgdG9vbHRpcDogdG9vbHRpcE1vZGVsLmdldCgnc2hvdycpID8genJVdGlsLmV4dGVuZCh7XG4gICAgICAgIGNvbnRlbnQ6IG5hbWUsXG4gICAgICAgIC8vIERlZmF1bCBmb3JtYXR0ZXJcbiAgICAgICAgZm9ybWF0dGVyOiBsZWdlbmRHbG9iYWxUb29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXInLCB0cnVlKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlclBhcmFtczoge1xuICAgICAgICAgIGNvbXBvbmVudFR5cGU6ICdsZWdlbmQnLFxuICAgICAgICAgIGxlZ2VuZEluZGV4OiBsZWdlbmRNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICR2YXJzOiBbJ25hbWUnXVxuICAgICAgICB9XG4gICAgICB9LCB0b29sdGlwTW9kZWwub3B0aW9uKSA6IG51bGxcbiAgICB9KTtcbiAgICBpdGVtR3JvdXAuYWRkKGhpdFJlY3QpO1xuICAgIGl0ZW1Hcm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBjaGlsZC5zaWxlbnQgPSB0cnVlO1xuICAgIH0pO1xuICAgIGhpdFJlY3Quc2lsZW50ID0gIXNlbGVjdE1vZGU7XG4gICAgdGhpcy5nZXRDb250ZW50R3JvdXAoKS5hZGQoaXRlbUdyb3VwKTtcbiAgICBncmFwaGljLnNldEhvdmVyU3R5bGUoaXRlbUdyb3VwKTtcbiAgICBpdGVtR3JvdXAuX19sZWdlbmREYXRhSW5kZXggPSBkYXRhSW5kZXg7XG4gICAgcmV0dXJuIGl0ZW1Hcm91cDtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbGF5b3V0SW5uZXI6IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaXRlbUFsaWduLCBtYXhTaXplKSB7XG4gICAgdmFyIGNvbnRlbnRHcm91cCA9IHRoaXMuZ2V0Q29udGVudEdyb3VwKCk7IC8vIFBsYWNlIGl0ZW1zIGluIGNvbnRlbnRHcm91cC5cblxuICAgIGxheW91dFV0aWwuYm94KGxlZ2VuZE1vZGVsLmdldCgnb3JpZW50JyksIGNvbnRlbnRHcm91cCwgbGVnZW5kTW9kZWwuZ2V0KCdpdGVtR2FwJyksIG1heFNpemUud2lkdGgsIG1heFNpemUuaGVpZ2h0KTtcbiAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50R3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgY29udGVudEdyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgWy1jb250ZW50UmVjdC54LCAtY29udGVudFJlY3QueV0pO1xuICAgIHJldHVybiB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGlzcGF0Y2hTZWxlY3RBY3Rpb24obmFtZSwgYXBpKSB7XG4gIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgdHlwZTogJ2xlZ2VuZFRvZ2dsZVNlbGVjdCcsXG4gICAgbmFtZTogbmFtZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24oc2VyaWVzTW9kZWwsIGRhdGFOYW1lLCBhcGkpIHtcbiAgLy8gSWYgZWxlbWVudCBob3ZlciB3aWxsIG1vdmUgdG8gYSBob3ZlckxheWVyLlxuICB2YXIgZWwgPSBhcGkuZ2V0WnIoKS5zdG9yYWdlLmdldERpc3BsYXlMaXN0KClbMF07XG5cbiAgaWYgKCEoZWwgJiYgZWwudXNlSG92ZXJMYXllcikpIHtcbiAgICBzZXJpZXNNb2RlbC5nZXQoJ2xlZ2VuZEhvdmVyTGluaycpICYmIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnaGlnaGxpZ2h0JyxcbiAgICAgIHNlcmllc05hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICBuYW1lOiBkYXRhTmFtZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRG93bnBsYXlBY3Rpb24oc2VyaWVzTW9kZWwsIGRhdGFOYW1lLCBhcGkpIHtcbiAgLy8gSWYgZWxlbWVudCBob3ZlciB3aWxsIG1vdmUgdG8gYSBob3ZlckxheWVyLlxuICB2YXIgZWwgPSBhcGkuZ2V0WnIoKS5zdG9yYWdlLmdldERpc3BsYXlMaXN0KClbMF07XG5cbiAgaWYgKCEoZWwgJiYgZWwudXNlSG92ZXJMYXllcikpIHtcbiAgICBzZXJpZXNNb2RlbC5nZXQoJ2xlZ2VuZEhvdmVyTGluaycpICYmIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnZG93bnBsYXknLFxuICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICAgIG5hbWU6IGRhdGFOYW1lXG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL0xlZ2VuZFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBMZWdlbmRNb2RlbCA9IHJlcXVpcmUoXCIuL0xlZ2VuZE1vZGVsXCIpO1xuXG52YXIgX2xheW91dCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xheW91dFwiKTtcblxudmFyIG1lcmdlTGF5b3V0UGFyYW0gPSBfbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW07XG52YXIgZ2V0TGF5b3V0UGFyYW1zID0gX2xheW91dC5nZXRMYXlvdXRQYXJhbXM7XG52YXIgU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsID0gTGVnZW5kTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ2xlZ2VuZC5zY3JvbGwnLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsRGF0YUluZGV4XG4gICAqL1xuICBzZXRTY3JvbGxEYXRhSW5kZXg6IGZ1bmN0aW9uIChzY3JvbGxEYXRhSW5kZXgpIHtcbiAgICB0aGlzLm9wdGlvbi5zY3JvbGxEYXRhSW5kZXggPSBzY3JvbGxEYXRhSW5kZXg7XG4gIH0sXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICBzY3JvbGxEYXRhSW5kZXg6IDAsXG4gICAgcGFnZUJ1dHRvbkl0ZW1HYXA6IDUsXG4gICAgcGFnZUJ1dHRvbkdhcDogbnVsbCxcbiAgICBwYWdlQnV0dG9uUG9zaXRpb246ICdlbmQnLFxuICAgIC8vICdzdGFydCcgb3IgJ2VuZCdcbiAgICBwYWdlRm9ybWF0dGVyOiAne2N1cnJlbnR9L3t0b3RhbH0nLFxuICAgIC8vIElmIG51bGwvdW5kZWZpbmVkLCBkbyBub3Qgc2hvdyBwYWdlLlxuICAgIHBhZ2VJY29uczoge1xuICAgICAgaG9yaXpvbnRhbDogWydNMCwwTDEyLC0xMEwxMiwxMHonLCAnTTAsMEwtMTIsLTEwTC0xMiwxMHonXSxcbiAgICAgIHZlcnRpY2FsOiBbJ00wLDBMMjAsMEwxMCwtMjB6JywgJ00wLDBMMjAsMEwxMCwyMHonXVxuICAgIH0sXG4gICAgcGFnZUljb25Db2xvcjogJyMyZjQ1NTQnLFxuICAgIHBhZ2VJY29uSW5hY3RpdmVDb2xvcjogJyNhYWEnLFxuICAgIHBhZ2VJY29uU2l6ZTogMTUsXG4gICAgLy8gQ2FuIGJlIFsxMCwgM10sIHdoaWNoIHJlcHJlc2VudHMgW3dpZHRoLCBoZWlnaHRdXG4gICAgcGFnZVRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDgwMFxuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbik7XG4gICAgU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsLnN1cGVyQ2FsbCh0aGlzLCAnaW5pdCcsIG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KTtcbiAgICBtZXJnZUFuZE5vcm1hbGl6ZUxheW91dFBhcmFtcyh0aGlzLCBvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uLCBleHRyYU9wdCkge1xuICAgIFNjcm9sbGFibGVMZWdlbmRNb2RlbC5zdXBlckNhbGwodGhpcywgJ21lcmdlT3B0aW9uJywgb3B0aW9uLCBleHRyYU9wdCk7XG4gICAgbWVyZ2VBbmROb3JtYWxpemVMYXlvdXRQYXJhbXModGhpcywgdGhpcy5vcHRpb24sIG9wdGlvbik7XG4gIH0sXG4gIGdldE9yaWVudDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnb3JpZW50JykgPT09ICd2ZXJ0aWNhbCcgPyB7XG4gICAgICBpbmRleDogMSxcbiAgICAgIG5hbWU6ICd2ZXJ0aWNhbCdcbiAgICB9IDoge1xuICAgICAgaW5kZXg6IDAsXG4gICAgICBuYW1lOiAnaG9yaXpvbnRhbCdcbiAgICB9O1xuICB9XG59KTsgLy8gRG8gbm90IGBpZ25vcmVTaXplYCB0byBlbmFibGUgc2V0dGluZyB7bGVmdDogMTAsIHJpZ2h0OiAxMH0uXG5cbmZ1bmN0aW9uIG1lcmdlQW5kTm9ybWFsaXplTGF5b3V0UGFyYW1zKGxlZ2VuZE1vZGVsLCB0YXJnZXQsIHJhdykge1xuICB2YXIgb3JpZW50ID0gbGVnZW5kTW9kZWwuZ2V0T3JpZW50KCk7XG4gIHZhciBpZ25vcmVTaXplID0gWzEsIDFdO1xuICBpZ25vcmVTaXplW29yaWVudC5pbmRleF0gPSAwO1xuICBtZXJnZUxheW91dFBhcmFtKHRhcmdldCwgcmF3LCB7XG4gICAgdHlwZTogJ2JveCcsXG4gICAgaWdub3JlU2l6ZTogaWdub3JlU2l6ZVxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL1Njcm9sbGFibGVMZWdlbmRNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kTW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgbGF5b3V0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xheW91dFwiKTtcblxudmFyIExlZ2VuZFZpZXcgPSByZXF1aXJlKFwiLi9MZWdlbmRWaWV3XCIpO1xuXG4vKipcbiAqIFNlcGFyYXRlIGxlZ2VuZCBhbmQgc2Nyb2xsYWJsZSBsZWdlbmQgdG8gcmVkdWNlIHBhY2thZ2Ugc2l6ZS5cbiAqL1xudmFyIEdyb3VwID0gZ3JhcGhpYy5Hcm91cDtcbnZhciBXSCA9IFsnd2lkdGgnLCAnaGVpZ2h0J107XG52YXIgWFkgPSBbJ3gnLCAneSddO1xudmFyIFNjcm9sbGFibGVMZWdlbmRWaWV3ID0gTGVnZW5kVmlldy5leHRlbmQoe1xuICB0eXBlOiAnbGVnZW5kLnNjcm9sbCcsXG4gIG5ld2xpbmVEaXNhYmxlZDogdHJ1ZSxcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIFNjcm9sbGFibGVMZWdlbmRWaWV3LnN1cGVyQ2FsbCh0aGlzLCAnaW5pdCcpO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn0gRm9yIGBzY3JvbGxgLlxuICAgICAqL1xuXG4gICAgdGhpcy5fY3VycmVudEluZGV4ID0gMDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAgICovXG5cbiAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLl9jb250YWluZXJHcm91cCA9IG5ldyBHcm91cCgpKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lckdyb3VwLmFkZCh0aGlzLmdldENvbnRlbnRHcm91cCgpKTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAgICovXG5cblxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2NvbnRyb2xsZXJHcm91cCA9IG5ldyBHcm91cCgpKTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLl9zaG93Q29udHJvbGxlcjtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZXNldElubmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuc3VwZXJDYWxsKHRoaXMsICdyZXNldElubmVyJyk7XG5cbiAgICB0aGlzLl9jb250cm9sbGVyR3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICB0aGlzLl9jb250YWluZXJHcm91cC5yZW1vdmVDbGlwUGF0aCgpO1xuXG4gICAgdGhpcy5fY29udGFpbmVyR3JvdXAuX19yZWN0U2l6ZSA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVySW5uZXI6IGZ1bmN0aW9uIChpdGVtQWxpZ24sIGxlZ2VuZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgbWUgPSB0aGlzOyAvLyBSZW5kZXIgY29udGVudCBpdGVtcy5cblxuICAgIFNjcm9sbGFibGVMZWdlbmRWaWV3LnN1cGVyQ2FsbCh0aGlzLCAncmVuZGVySW5uZXInLCBpdGVtQWxpZ24sIGxlZ2VuZE1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgIHZhciBjb250cm9sbGVyR3JvdXAgPSB0aGlzLl9jb250cm9sbGVyR3JvdXA7XG4gICAgdmFyIHBhZ2VJY29uU2l6ZSA9IGxlZ2VuZE1vZGVsLmdldCgncGFnZUljb25TaXplJywgdHJ1ZSk7XG5cbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHBhZ2VJY29uU2l6ZSkpIHtcbiAgICAgIHBhZ2VJY29uU2l6ZSA9IFtwYWdlSWNvblNpemUsIHBhZ2VJY29uU2l6ZV07XG4gICAgfVxuXG4gICAgY3JlYXRlUGFnZUJ1dHRvbigncGFnZVByZXYnLCAwKTtcbiAgICB2YXIgcGFnZVRleHRTdHlsZU1vZGVsID0gbGVnZW5kTW9kZWwuZ2V0TW9kZWwoJ3BhZ2VUZXh0U3R5bGUnKTtcbiAgICBjb250cm9sbGVyR3JvdXAuYWRkKG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgbmFtZTogJ3BhZ2VUZXh0JyxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHRleHRGaWxsOiBwYWdlVGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICAgIGZvbnQ6IHBhZ2VUZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJ1xuICAgICAgfSxcbiAgICAgIHNpbGVudDogdHJ1ZVxuICAgIH0pKTtcbiAgICBjcmVhdGVQYWdlQnV0dG9uKCdwYWdlTmV4dCcsIDEpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFnZUJ1dHRvbihuYW1lLCBpY29uSWR4KSB7XG4gICAgICB2YXIgcGFnZURhdGFJbmRleE5hbWUgPSBuYW1lICsgJ0RhdGFJbmRleCc7XG4gICAgICB2YXIgaWNvbiA9IGdyYXBoaWMuY3JlYXRlSWNvbihsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VJY29ucycsIHRydWUpW2xlZ2VuZE1vZGVsLmdldE9yaWVudCgpLm5hbWVdW2ljb25JZHhdLCB7XG4gICAgICAgIC8vIEJ1dHRvbnMgd2lsbCBiZSBjcmVhdGVkIGluIGVhY2ggcmVuZGVyLCBzbyB3ZSBkbyBub3QgbmVlZFxuICAgICAgICAvLyB0byB3b3JyeSBhYm91dCBhdm9pZGluZyB1c2luZyBsZWdlbmRNb2RlbCBrZXB0IGluIHNjb3BlLlxuICAgICAgICBvbmNsaWNrOiB6clV0aWwuYmluZChtZS5fcGFnZUdvLCBtZSwgcGFnZURhdGFJbmRleE5hbWUsIGxlZ2VuZE1vZGVsLCBhcGkpXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC1wYWdlSWNvblNpemVbMF0gLyAyLFxuICAgICAgICB5OiAtcGFnZUljb25TaXplWzFdIC8gMixcbiAgICAgICAgd2lkdGg6IHBhZ2VJY29uU2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBwYWdlSWNvblNpemVbMV1cbiAgICAgIH0pO1xuICAgICAgaWNvbi5uYW1lID0gbmFtZTtcbiAgICAgIGNvbnRyb2xsZXJHcm91cC5hZGQoaWNvbik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGxheW91dElubmVyOiBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGl0ZW1BbGlnbiwgbWF4U2l6ZSkge1xuICAgIHZhciBjb250ZW50R3JvdXAgPSB0aGlzLmdldENvbnRlbnRHcm91cCgpO1xuICAgIHZhciBjb250YWluZXJHcm91cCA9IHRoaXMuX2NvbnRhaW5lckdyb3VwO1xuICAgIHZhciBjb250cm9sbGVyR3JvdXAgPSB0aGlzLl9jb250cm9sbGVyR3JvdXA7XG4gICAgdmFyIG9yaWVudElkeCA9IGxlZ2VuZE1vZGVsLmdldE9yaWVudCgpLmluZGV4O1xuICAgIHZhciB3aCA9IFdIW29yaWVudElkeF07XG4gICAgdmFyIGh3ID0gV0hbMSAtIG9yaWVudElkeF07XG4gICAgdmFyIHl4ID0gWFlbMSAtIG9yaWVudElkeF07IC8vIFBsYWNlIGl0ZW1zIGluIGNvbnRlbnRHcm91cC5cblxuICAgIGxheW91dFV0aWwuYm94KGxlZ2VuZE1vZGVsLmdldCgnb3JpZW50JyksIGNvbnRlbnRHcm91cCwgbGVnZW5kTW9kZWwuZ2V0KCdpdGVtR2FwJyksICFvcmllbnRJZHggPyBudWxsIDogbWF4U2l6ZS53aWR0aCwgb3JpZW50SWR4ID8gbnVsbCA6IG1heFNpemUuaGVpZ2h0KTtcbiAgICBsYXlvdXRVdGlsLmJveCggLy8gQnV0dG9ucyBpbiBjb250cm9sbGVyIGFyZSBsYXlvdXQgYWx3YXlzIGhvcml6b250YWxseS5cbiAgICAnaG9yaXpvbnRhbCcsIGNvbnRyb2xsZXJHcm91cCwgbGVnZW5kTW9kZWwuZ2V0KCdwYWdlQnV0dG9uSXRlbUdhcCcsIHRydWUpKTtcbiAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50R3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIGNvbnRyb2xsZXJSZWN0ID0gY29udHJvbGxlckdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzaG93Q29udHJvbGxlciA9IHRoaXMuX3Nob3dDb250cm9sbGVyID0gY29udGVudFJlY3Rbd2hdID4gbWF4U2l6ZVt3aF07XG4gICAgdmFyIGNvbnRlbnRQb3MgPSBbLWNvbnRlbnRSZWN0LngsIC1jb250ZW50UmVjdC55XTsgLy8gUmVtYWluIGNvbnRlbnRQb3Mgd2hlbiBzY3JvbGwgYW5pbWF0aW9uIHBlcmZyb21pbmcuXG5cbiAgICBjb250ZW50UG9zW29yaWVudElkeF0gPSBjb250ZW50R3JvdXAucG9zaXRpb25bb3JpZW50SWR4XTsgLy8gTGF5b3V0IGNvbnRhaW5lciBncm91cCBiYXNlZCBvbiAwLlxuXG4gICAgdmFyIGNvbnRhaW5lclBvcyA9IFswLCAwXTtcbiAgICB2YXIgY29udHJvbGxlclBvcyA9IFstY29udHJvbGxlclJlY3QueCwgLWNvbnRyb2xsZXJSZWN0LnldO1xuICAgIHZhciBwYWdlQnV0dG9uR2FwID0genJVdGlsLnJldHJpZXZlMihsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VCdXR0b25HYXAnLCB0cnVlKSwgbGVnZW5kTW9kZWwuZ2V0KCdpdGVtR2FwJywgdHJ1ZSkpOyAvLyBQbGFjZSBjb250YWluZXJHcm91cCBhbmQgY29udHJvbGxlckdyb3VwIGFuZCBjb250ZW50R3JvdXAuXG5cbiAgICBpZiAoc2hvd0NvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBwYWdlQnV0dG9uUG9zaXRpb24gPSBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VCdXR0b25Qb3NpdGlvbicsIHRydWUpOyAvLyBjb250cm9sbGVyIGlzIG9uIHRoZSByaWdodCAvIGJvdHRvbS5cblxuICAgICAgaWYgKHBhZ2VCdXR0b25Qb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgY29udHJvbGxlclBvc1tvcmllbnRJZHhdICs9IG1heFNpemVbd2hdIC0gY29udHJvbGxlclJlY3Rbd2hdO1xuICAgICAgfSAvLyBjb250cm9sbGVyIGlzIG9uIHRoZSBsZWZ0IC8gdG9wLlxuICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGFpbmVyUG9zW29yaWVudElkeF0gKz0gY29udHJvbGxlclJlY3Rbd2hdICsgcGFnZUJ1dHRvbkdhcDtcbiAgICAgICAgfVxuICAgIH0gLy8gQWx3YXlzIGFsaWduIGNvbnRyb2xsZXIgdG8gY29udGVudCBhcyAnbWlkZGxlJy5cblxuXG4gICAgY29udHJvbGxlclBvc1sxIC0gb3JpZW50SWR4XSArPSBjb250ZW50UmVjdFtod10gLyAyIC0gY29udHJvbGxlclJlY3RbaHddIC8gMjtcbiAgICBjb250ZW50R3JvdXAuYXR0cigncG9zaXRpb24nLCBjb250ZW50UG9zKTtcbiAgICBjb250YWluZXJHcm91cC5hdHRyKCdwb3NpdGlvbicsIGNvbnRhaW5lclBvcyk7XG4gICAgY29udHJvbGxlckdyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgY29udHJvbGxlclBvcyk7IC8vIENhbGN1bGF0ZSBgbWFpblJlY3RgIGFuZCBzZXQgYGNsaXBQYXRoYC5cbiAgICAvLyBtYWluUmVjdCBzaG91bGQgbm90IGJlIGNhbGN1bGF0ZWQgYnkgYHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KClgXG4gICAgLy8gZm9yIHNha2Ugb2YgdGhlIG92ZXJmbG93LlxuXG4gICAgdmFyIG1haW5SZWN0ID0gdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgbWFpblJlY3QgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07IC8vIENvbnNpZGVyIGNvbnRlbnQgbWF5IGJlIG92ZXJmbG93IChzaG91bGQgYmUgY2xpcHBlZCkuXG5cbiAgICBtYWluUmVjdFt3aF0gPSBzaG93Q29udHJvbGxlciA/IG1heFNpemVbd2hdIDogY29udGVudFJlY3Rbd2hdO1xuICAgIG1haW5SZWN0W2h3XSA9IE1hdGgubWF4KGNvbnRlbnRSZWN0W2h3XSwgY29udHJvbGxlclJlY3RbaHddKTsgLy8gYGNvbnRhaW5lclJlY3RbeXhdICsgY29udGFpbmVyUG9zWzEgLSBvcmllbnRJZHhdYCBpcyAwLlxuXG4gICAgbWFpblJlY3RbeXhdID0gTWF0aC5taW4oMCwgY29udHJvbGxlclJlY3RbeXhdICsgY29udHJvbGxlclBvc1sxIC0gb3JpZW50SWR4XSk7XG4gICAgY29udGFpbmVyR3JvdXAuX19yZWN0U2l6ZSA9IG1heFNpemVbd2hdO1xuXG4gICAgaWYgKHNob3dDb250cm9sbGVyKSB7XG4gICAgICB2YXIgY2xpcFNoYXBlID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgY2xpcFNoYXBlW3doXSA9IE1hdGgubWF4KG1heFNpemVbd2hdIC0gY29udHJvbGxlclJlY3Rbd2hdIC0gcGFnZUJ1dHRvbkdhcCwgMCk7XG4gICAgICBjbGlwU2hhcGVbaHddID0gbWFpblJlY3RbaHddO1xuICAgICAgY29udGFpbmVyR3JvdXAuc2V0Q2xpcFBhdGgobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgIHNoYXBlOiBjbGlwU2hhcGVcbiAgICAgIH0pKTsgLy8gQ29uc2lkZXIgY29udGVudCBtYXkgYmUgbGFyZ2VyIHRoYW4gY29udGFpbmVyLCBjb250YWluZXIgcmVjdFxuICAgICAgLy8gY2FuIG5vdCBiZSBvYnRhaW5lZCBmcm9tIGBjb250YWluZXJHcm91cC5nZXRCb3VuZGluZ1JlY3QoKWAuXG5cbiAgICAgIGNvbnRhaW5lckdyb3VwLl9fcmVjdFNpemUgPSBjbGlwU2hhcGVbd2hdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEbyBub3QgcmVtb3ZlIG9yIGlnbm9yZSBjb250cm9sbGVyLiBLZWVwIHRoZW0gc2V0IGFzIHBsYWNlIGhvbGRlcnMuXG4gICAgICBjb250cm9sbGVyR3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5hdHRyKHtcbiAgICAgICAgICBpbnZpc2libGU6IHRydWUsXG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBDb250ZW50IHRyYW5zbGF0ZSBhbmltYXRpb24uXG5cblxuICAgIHZhciBwYWdlSW5mbyA9IHRoaXMuX2dldFBhZ2VJbmZvKGxlZ2VuZE1vZGVsKTtcblxuICAgIHBhZ2VJbmZvLnBhZ2VJbmRleCAhPSBudWxsICYmIGdyYXBoaWMudXBkYXRlUHJvcHMoY29udGVudEdyb3VwLCB7XG4gICAgICBwb3NpdGlvbjogcGFnZUluZm8uY29udGVudFBvc2l0aW9uXG4gICAgfSwgLy8gV2hlbiBzd2l0Y2ggZnJvbSBcInNob3cgY29udHJvbGxlclwiIHRvIFwibm90IHNob3cgY29udHJvbGxlclwiLCB2aWV3IHNob3VsZCBiZVxuICAgIC8vIHVwZGF0ZWQgaW1tZWRpYXRlbHkgd2l0aG91dCBhbmltYXRpb24sIG90aGVyd2lzZSBjYXVzZXMgd2VpcmQgZWZmZmVjdC5cbiAgICBzaG93Q29udHJvbGxlciA/IGxlZ2VuZE1vZGVsIDogZmFsc2UpO1xuXG4gICAgdGhpcy5fdXBkYXRlUGFnZUluZm9WaWV3KGxlZ2VuZE1vZGVsLCBwYWdlSW5mbyk7XG5cbiAgICByZXR1cm4gbWFpblJlY3Q7XG4gIH0sXG4gIF9wYWdlR286IGZ1bmN0aW9uICh0bywgbGVnZW5kTW9kZWwsIGFwaSkge1xuICAgIHZhciBzY3JvbGxEYXRhSW5kZXggPSB0aGlzLl9nZXRQYWdlSW5mbyhsZWdlbmRNb2RlbClbdG9dO1xuXG4gICAgc2Nyb2xsRGF0YUluZGV4ICE9IG51bGwgJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdsZWdlbmRTY3JvbGwnLFxuICAgICAgc2Nyb2xsRGF0YUluZGV4OiBzY3JvbGxEYXRhSW5kZXgsXG4gICAgICBsZWdlbmRJZDogbGVnZW5kTW9kZWwuaWRcbiAgICB9KTtcbiAgfSxcbiAgX3VwZGF0ZVBhZ2VJbmZvVmlldzogZnVuY3Rpb24gKGxlZ2VuZE1vZGVsLCBwYWdlSW5mbykge1xuICAgIHZhciBjb250cm9sbGVyR3JvdXAgPSB0aGlzLl9jb250cm9sbGVyR3JvdXA7XG4gICAgenJVdGlsLmVhY2goWydwYWdlUHJldicsICdwYWdlTmV4dCddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGNhbkp1bXAgPSBwYWdlSW5mb1tuYW1lICsgJ0RhdGFJbmRleCddICE9IG51bGw7XG4gICAgICB2YXIgaWNvbiA9IGNvbnRyb2xsZXJHcm91cC5jaGlsZE9mTmFtZShuYW1lKTtcblxuICAgICAgaWYgKGljb24pIHtcbiAgICAgICAgaWNvbi5zZXRTdHlsZSgnZmlsbCcsIGNhbkp1bXAgPyBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VJY29uQ29sb3InLCB0cnVlKSA6IGxlZ2VuZE1vZGVsLmdldCgncGFnZUljb25JbmFjdGl2ZUNvbG9yJywgdHJ1ZSkpO1xuICAgICAgICBpY29uLmN1cnNvciA9IGNhbkp1bXAgPyAncG9pbnRlcicgOiAnZGVmYXVsdCc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHBhZ2VUZXh0ID0gY29udHJvbGxlckdyb3VwLmNoaWxkT2ZOYW1lKCdwYWdlVGV4dCcpO1xuICAgIHZhciBwYWdlRm9ybWF0dGVyID0gbGVnZW5kTW9kZWwuZ2V0KCdwYWdlRm9ybWF0dGVyJyk7XG4gICAgdmFyIHBhZ2VJbmRleCA9IHBhZ2VJbmZvLnBhZ2VJbmRleDtcbiAgICB2YXIgY3VycmVudCA9IHBhZ2VJbmRleCAhPSBudWxsID8gcGFnZUluZGV4ICsgMSA6IDA7XG4gICAgdmFyIHRvdGFsID0gcGFnZUluZm8ucGFnZUNvdW50O1xuICAgIHBhZ2VUZXh0ICYmIHBhZ2VGb3JtYXR0ZXIgJiYgcGFnZVRleHQuc2V0U3R5bGUoJ3RleHQnLCB6clV0aWwuaXNTdHJpbmcocGFnZUZvcm1hdHRlcikgPyBwYWdlRm9ybWF0dGVyLnJlcGxhY2UoJ3tjdXJyZW50fScsIGN1cnJlbnQpLnJlcGxhY2UoJ3t0b3RhbH0nLCB0b3RhbCkgOiBwYWdlRm9ybWF0dGVyKHtcbiAgICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgICB0b3RhbDogdG90YWxcbiAgICB9KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGxlZ2VuZE1vZGVsXG4gICAqIEByZXR1cm4ge09iamVjdH0ge1xuICAgKiAgY29udGVudFBvc2l0aW9uOiBBcnJheS48bnVtYmVyPiwgbnVsbCB3aGVuIGRhdGEgaXRlbSBub3QgZm91bmQuXG4gICAqICBwYWdlSW5kZXg6IG51bWJlciwgbnVsbCB3aGVuIGRhdGEgaXRlbSBub3QgZm91bmQuXG4gICAqICBwYWdlQ291bnQ6IG51bWJlciwgYWx3YXlzIGJlIGEgbnVtYmVyLCBjYW4gYmUgMC5cbiAgICogIHBhZ2VQcmV2RGF0YUluZGV4OiBudW1iZXIsIG51bGwgd2hlbiBubyBuZXh0IHBhZ2UuXG4gICAqICBwYWdlTmV4dERhdGFJbmRleDogbnVtYmVyLCBudWxsIHdoZW4gbm8gcHJldmlvdXMgcGFnZS5cbiAgICogfVxuICAgKi9cbiAgX2dldFBhZ2VJbmZvOiBmdW5jdGlvbiAobGVnZW5kTW9kZWwpIHtcbiAgICAvLyBBbGlnbiBsZWZ0IG9yIHRvcCBieSB0aGUgY3VycmVudCBkYXRhSW5kZXguXG4gICAgdmFyIGN1cnJEYXRhSW5kZXggPSBsZWdlbmRNb2RlbC5nZXQoJ3Njcm9sbERhdGFJbmRleCcsIHRydWUpO1xuICAgIHZhciBjb250ZW50R3JvdXAgPSB0aGlzLmdldENvbnRlbnRHcm91cCgpO1xuICAgIHZhciBjb250ZW50UmVjdCA9IGNvbnRlbnRHcm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgY29udGFpbmVyUmVjdFNpemUgPSB0aGlzLl9jb250YWluZXJHcm91cC5fX3JlY3RTaXplO1xuICAgIHZhciBvcmllbnRJZHggPSBsZWdlbmRNb2RlbC5nZXRPcmllbnQoKS5pbmRleDtcbiAgICB2YXIgd2ggPSBXSFtvcmllbnRJZHhdO1xuICAgIHZhciBodyA9IFdIWzEgLSBvcmllbnRJZHhdO1xuICAgIHZhciB4eSA9IFhZW29yaWVudElkeF07XG4gICAgdmFyIGNvbnRlbnRQb3MgPSBjb250ZW50R3JvdXAucG9zaXRpb24uc2xpY2UoKTtcbiAgICB2YXIgcGFnZUluZGV4O1xuICAgIHZhciBwYWdlUHJldkRhdGFJbmRleDtcbiAgICB2YXIgcGFnZU5leHREYXRhSW5kZXg7XG4gICAgdmFyIHRhcmdldEl0ZW1Hcm91cDtcblxuICAgIGlmICh0aGlzLl9zaG93Q29udHJvbGxlcikge1xuICAgICAgY29udGVudEdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLl9fbGVnZW5kRGF0YUluZGV4ID09PSBjdXJyRGF0YUluZGV4KSB7XG4gICAgICAgICAgdGFyZ2V0SXRlbUdyb3VwID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRJdGVtR3JvdXAgPSBjb250ZW50R3JvdXAuY2hpbGRBdCgwKTtcbiAgICB9XG5cbiAgICB2YXIgcGFnZUNvdW50ID0gY29udGFpbmVyUmVjdFNpemUgPyBNYXRoLmNlaWwoY29udGVudFJlY3Rbd2hdIC8gY29udGFpbmVyUmVjdFNpemUpIDogMDtcblxuICAgIGlmICh0YXJnZXRJdGVtR3JvdXApIHtcbiAgICAgIHZhciBpdGVtUmVjdCA9IHRhcmdldEl0ZW1Hcm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgIHZhciBpdGVtTG9jID0gdGFyZ2V0SXRlbUdyb3VwLnBvc2l0aW9uW29yaWVudElkeF0gKyBpdGVtUmVjdFt4eV07XG4gICAgICBjb250ZW50UG9zW29yaWVudElkeF0gPSAtaXRlbUxvYyAtIGNvbnRlbnRSZWN0W3h5XTtcbiAgICAgIHBhZ2VJbmRleCA9IE1hdGguZmxvb3IocGFnZUNvdW50ICogKGl0ZW1Mb2MgKyBpdGVtUmVjdFt4eV0gKyBjb250YWluZXJSZWN0U2l6ZSAvIDIpIC8gY29udGVudFJlY3Rbd2hdKTtcbiAgICAgIHBhZ2VJbmRleCA9IGNvbnRlbnRSZWN0W3doXSAmJiBwYWdlQ291bnQgPyBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlQ291bnQgLSAxLCBwYWdlSW5kZXgpKSA6IC0xO1xuICAgICAgdmFyIHdpblJlY3QgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICB3aW5SZWN0W3doXSA9IGNvbnRhaW5lclJlY3RTaXplO1xuICAgICAgd2luUmVjdFtod10gPSBjb250ZW50UmVjdFtod107XG4gICAgICB3aW5SZWN0W3h5XSA9IC1jb250ZW50UG9zW29yaWVudElkeF0gLSBjb250ZW50UmVjdFt4eV07XG4gICAgICB2YXIgc3RhcnRJZHg7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjb250ZW50R3JvdXAuY2hpbGRyZW4oKTtcbiAgICAgIGNvbnRlbnRHcm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgICAgICB2YXIgaXRlbVJlY3QgPSBnZXRJdGVtUmVjdChjaGlsZCk7XG5cbiAgICAgICAgaWYgKGl0ZW1SZWN0LmludGVyc2VjdCh3aW5SZWN0KSkge1xuICAgICAgICAgIHN0YXJ0SWR4ID09IG51bGwgJiYgKHN0YXJ0SWR4ID0gaW5kZXgpOyAvLyBJdCBpcyB1c2VyLWZyaWVuZGx5IHRoYXQgdGhlIGxhc3QgaXRlbSBzaG93biBpbiB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHdpbmRvdyBpcyBzaG93biBhdCB0aGUgYmVnaW5pbmcgb2YgbmV4dCB3aW5kb3cuXG5cbiAgICAgICAgICBwYWdlTmV4dERhdGFJbmRleCA9IGNoaWxkLl9fbGVnZW5kRGF0YUluZGV4O1xuICAgICAgICB9IC8vIElmIHRoZSBsYXN0IGl0ZW0gaXMgc2hvd24gZW50aXJlbHksIG5vIG5leHQgcGFnZS5cblxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gY2hpbGRyZW4ubGVuZ3RoIC0gMSAmJiBpdGVtUmVjdFt4eV0gKyBpdGVtUmVjdFt3aF0gPD0gd2luUmVjdFt4eV0gKyB3aW5SZWN0W3doXSkge1xuICAgICAgICAgIHBhZ2VOZXh0RGF0YUluZGV4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIEFsd2F5cyBhbGlnbiBiYXNlZCBvbiB0aGUgbGVmdC90b3AgbW9zdCBpdGVtLCBzbyB0aGUgbGVmdC90b3AgbW9zdFxuICAgICAgLy8gaXRlbSBpbiB0aGUgcHJldmlvdXMgd2luZG93IGlzIG5lZWRlZCB0byBiZSBmb3VuZCBoZXJlLlxuXG4gICAgICBpZiAoc3RhcnRJZHggIT0gbnVsbCkge1xuICAgICAgICB2YXIgc3RhcnRJdGVtID0gY2hpbGRyZW5bc3RhcnRJZHhdO1xuICAgICAgICB2YXIgc3RhcnRSZWN0ID0gZ2V0SXRlbVJlY3Qoc3RhcnRJdGVtKTtcbiAgICAgICAgd2luUmVjdFt4eV0gPSBzdGFydFJlY3RbeHldICsgc3RhcnRSZWN0W3doXSAtIHdpblJlY3Rbd2hdOyAvLyBJZiB0aGUgZmlyc3QgaXRlbSBpcyBzaG93biBlbnRpcmVseSwgbm8gcHJldmlvdXMgcGFnZS5cblxuICAgICAgICBpZiAoc3RhcnRJZHggPD0gMCAmJiBzdGFydFJlY3RbeHldID49IHdpblJlY3RbeHldKSB7XG4gICAgICAgICAgcGFnZVByZXZEYXRhSW5kZXggPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoaWxlIChzdGFydElkeCA+IDAgJiYgZ2V0SXRlbVJlY3QoY2hpbGRyZW5bc3RhcnRJZHggLSAxXSkuaW50ZXJzZWN0KHdpblJlY3QpKSB7XG4gICAgICAgICAgICBzdGFydElkeC0tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhZ2VQcmV2RGF0YUluZGV4ID0gY2hpbGRyZW5bc3RhcnRJZHhdLl9fbGVnZW5kRGF0YUluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnRQb3NpdGlvbjogY29udGVudFBvcyxcbiAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgcGFnZUNvdW50OiBwYWdlQ291bnQsXG4gICAgICBwYWdlUHJldkRhdGFJbmRleDogcGFnZVByZXZEYXRhSW5kZXgsXG4gICAgICBwYWdlTmV4dERhdGFJbmRleDogcGFnZU5leHREYXRhSW5kZXhcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0SXRlbVJlY3QoZWwpIHtcbiAgICAgIHZhciBpdGVtUmVjdCA9IGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICBpdGVtUmVjdFt4eV0gKz0gZWwucG9zaXRpb25bb3JpZW50SWR4XTtcbiAgICAgIHJldHVybiBpdGVtUmVjdDtcbiAgICB9XG4gIH1cbn0pO1xudmFyIF9kZWZhdWx0ID0gU2Nyb2xsYWJsZUxlZ2VuZFZpZXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxuZnVuY3Rpb24gbGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlcihtZXRob2ROYW1lLCBwYXlsb2FkLCBlY01vZGVsKSB7XG4gIHZhciBzZWxlY3RlZE1hcCA9IHt9O1xuICB2YXIgaXNUb2dnbGVTZWxlY3QgPSBtZXRob2ROYW1lID09PSAndG9nZ2xlU2VsZWN0ZWQnO1xuICB2YXIgaXNTZWxlY3RlZDsgLy8gVXBkYXRlIGFsbCBsZWdlbmQgY29tcG9uZW50c1xuXG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnbGVnZW5kJywgZnVuY3Rpb24gKGxlZ2VuZE1vZGVsKSB7XG4gICAgaWYgKGlzVG9nZ2xlU2VsZWN0ICYmIGlzU2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgLy8gRm9yY2Ugb3RoZXIgbGVnZW5kIGhhcyBzYW1lIHNlbGVjdGVkIHN0YXR1c1xuICAgICAgLy8gT3IgdGhlIGZpcnN0IGlzIHRvZ2dsZWQgdG8gdHJ1ZSBhbmQgb3RoZXIgYXJlIHRvZ2dsZWQgdG8gZmFsc2VcbiAgICAgIC8vIEluIHRoZSBjYXNlIG9uZSBsZWdlbmQgaGFzIHNvbWUgaXRlbSB1blNlbGVjdGVkIGluIG9wdGlvbi4gQW5kIGlmIG90aGVyIGxlZ2VuZFxuICAgICAgLy8gZG9lc24ndCBoYXMgdGhlIGl0ZW0sIHRoZXkgd2lsbCBhc3N1bWUgaXQgaXMgc2VsZWN0ZWQuXG4gICAgICBsZWdlbmRNb2RlbFtpc1NlbGVjdGVkID8gJ3NlbGVjdCcgOiAndW5TZWxlY3QnXShwYXlsb2FkLm5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWdlbmRNb2RlbFttZXRob2ROYW1lXShwYXlsb2FkLm5hbWUpO1xuICAgICAgaXNTZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQocGF5bG9hZC5uYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgbGVnZW5kRGF0YSA9IGxlZ2VuZE1vZGVsLmdldERhdGEoKTtcbiAgICB6clV0aWwuZWFjaChsZWdlbmREYXRhLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgIHZhciBuYW1lID0gbW9kZWwuZ2V0KCduYW1lJyk7IC8vIFdyYXAgZWxlbWVudFxuXG4gICAgICBpZiAobmFtZSA9PT0gJ1xcbicgfHwgbmFtZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNJdGVtU2VsZWN0ZWQgPSBsZWdlbmRNb2RlbC5pc1NlbGVjdGVkKG5hbWUpO1xuXG4gICAgICBpZiAoc2VsZWN0ZWRNYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgLy8gVW5zZWxlY3RlZCBpZiBhbnkgbGVnZW5kIGlzIHVuc2VsZWN0ZWRcbiAgICAgICAgc2VsZWN0ZWRNYXBbbmFtZV0gPSBzZWxlY3RlZE1hcFtuYW1lXSAmJiBpc0l0ZW1TZWxlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkTWFwW25hbWVdID0gaXNJdGVtU2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pOyAvLyBSZXR1cm4gdGhlIGV2ZW50IGV4cGxpY2l0bHlcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IHBheWxvYWQubmFtZSxcbiAgICBzZWxlY3RlZDogc2VsZWN0ZWRNYXBcbiAgfTtcbn1cbi8qKlxuICogQGV2ZW50IGxlZ2VuZFRvZ2dsZVNlbGVjdFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRUb2dnbGVTZWxlY3QnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Zyb21dXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTZXJpZXMgbmFtZSBvciBkYXRhIGl0ZW0gbmFtZVxuICovXG5cblxuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbignbGVnZW5kVG9nZ2xlU2VsZWN0JywgJ2xlZ2VuZHNlbGVjdGNoYW5nZWQnLCB6clV0aWwuY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3RvZ2dsZVNlbGVjdGVkJykpO1xuLyoqXG4gKiBAZXZlbnQgbGVnZW5kU2VsZWN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFNlbGVjdCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFNlcmllcyBuYW1lIG9yIGRhdGEgaXRlbSBuYW1lXG4gKi9cblxuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbignbGVnZW5kU2VsZWN0JywgJ2xlZ2VuZHNlbGVjdGVkJywgenJVdGlsLmN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICdzZWxlY3QnKSk7XG4vKipcbiAqIEBldmVudCBsZWdlbmRVblNlbGVjdFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRVblNlbGVjdCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFNlcmllcyBuYW1lIG9yIGRhdGEgaXRlbSBuYW1lXG4gKi9cblxuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbignbGVnZW5kVW5TZWxlY3QnLCAnbGVnZW5kdW5zZWxlY3RlZCcsIHpyVXRpbC5jdXJyeShsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyLCAndW5TZWxlY3QnKSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9sZWdlbmRBY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZnVuY3Rpb24gX2RlZmF1bHQoZWNNb2RlbCkge1xuICB2YXIgbGVnZW5kTW9kZWxzID0gZWNNb2RlbC5maW5kQ29tcG9uZW50cyh7XG4gICAgbWFpblR5cGU6ICdsZWdlbmQnXG4gIH0pO1xuXG4gIGlmIChsZWdlbmRNb2RlbHMgJiYgbGVnZW5kTW9kZWxzLmxlbmd0aCkge1xuICAgIGVjTW9kZWwuZmlsdGVyU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgIC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuICAgICAgLy8gQmVjYXVzZSBpbiBsZWdlbmQgc2VyaWVzIGlzIGFzc3VtZWQgc2VsZWN0ZWQgd2hlbiBpdCBpcyBub3QgaW4gdGhlIGxlZ2VuZCBkYXRhLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWdlbmRNb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFsZWdlbmRNb2RlbHNbaV0uaXNTZWxlY3RlZChzZXJpZXMubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9sZWdlbmRGaWx0ZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG4vKipcbiAqIEBldmVudCBsZWdlbmRTY3JvbGxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAnbGVnZW5kU2Nyb2xsJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHNjcm9sbERhdGFJbmRleFxuICovXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRTY3JvbGwnLCAnbGVnZW5kc2Nyb2xsJywgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgdmFyIHNjcm9sbERhdGFJbmRleCA9IHBheWxvYWQuc2Nyb2xsRGF0YUluZGV4O1xuICBzY3JvbGxEYXRhSW5kZXggIT0gbnVsbCAmJiBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgIG1haW5UeXBlOiAnbGVnZW5kJyxcbiAgICBzdWJUeXBlOiAnc2Nyb2xsJyxcbiAgICBxdWVyeTogcGF5bG9hZFxuICB9LCBmdW5jdGlvbiAobGVnZW5kTW9kZWwpIHtcbiAgICBsZWdlbmRNb2RlbC5zZXRTY3JvbGxEYXRhSW5kZXgoc2Nyb2xsRGF0YUluZGV4KTtcbiAgfSk7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL3Njcm9sbGFibGVMZWdlbmRBY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvc2Nyb2xsYWJsZUxlZ2VuZEFjdGlvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInJlcXVpcmUoXCIuL2xlZ2VuZFwiKTtcblxucmVxdWlyZShcIi4vbGVnZW5kL1Njcm9sbGFibGVMZWdlbmRNb2RlbFwiKTtcblxucmVxdWlyZShcIi4vbGVnZW5kL1Njcm9sbGFibGVMZWdlbmRWaWV3XCIpO1xuXG5yZXF1aXJlKFwiLi9sZWdlbmQvc2Nyb2xsYWJsZUxlZ2VuZEFjdGlvblwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kU2Nyb2xsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kU2Nyb2xsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxucmVxdWlyZShcIi4vbWFya2VyL01hcmtMaW5lTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL21hcmtlci9NYXJrTGluZVZpZXdcIik7XG5cbmVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdCkge1xuICAvLyBNYWtlIHN1cmUgbWFya0xpbmUgY29tcG9uZW50IGlzIGVuYWJsZWRcbiAgb3B0Lm1hcmtMaW5lID0gb3B0Lm1hcmtMaW5lIHx8IHt9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtMaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya0xpbmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG5yZXF1aXJlKFwiLi9tYXJrZXIvTWFya1BvaW50TW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL21hcmtlci9NYXJrUG9pbnRWaWV3XCIpO1xuXG4vLyBISU5UIE1hcmtwb2ludCBjYW4ndCBiZSB1c2VkIHRvbyBtdWNoXG5lY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHQpIHtcbiAgLy8gTWFrZSBzdXJlIG1hcmtQb2ludCBjb21wb25lbnQgaXMgZW5hYmxlZFxuICBvcHQubWFya1BvaW50ID0gb3B0Lm1hcmtQb2ludCB8fCB7fTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrUG9pbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgTWFya2VyTW9kZWwgPSByZXF1aXJlKFwiLi9NYXJrZXJNb2RlbFwiKTtcblxudmFyIF9kZWZhdWx0ID0gTWFya2VyTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ21hcmtMaW5lJyxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIHpsZXZlbDogMCxcbiAgICB6OiA1LFxuICAgIHN5bWJvbDogWydjaXJjbGUnLCAnYXJyb3cnXSxcbiAgICBzeW1ib2xTaXplOiBbOCwgMTZdLFxuICAgIC8vc3ltYm9sUm90YXRlOiAwLFxuICAgIHByZWNpc2lvbjogMixcbiAgICB0b29sdGlwOiB7XG4gICAgICB0cmlnZ2VyOiAnaXRlbSdcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246ICdlbmQnXG4gICAgICB9LFxuICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgdHlwZTogJ2Rhc2hlZCdcbiAgICAgIH0sXG4gICAgICBlbXBoYXNpczoge1xuICAgICAgICB3aWR0aDogM1xuICAgICAgfVxuICAgIH0sXG4gICAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJ1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtMaW5lTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya0xpbmVNb2RlbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgTGlzdCA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL0xpc3RcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgbWFya2VySGVscGVyID0gcmVxdWlyZShcIi4vbWFya2VySGVscGVyXCIpO1xuXG52YXIgTGluZURyYXcgPSByZXF1aXJlKFwiLi4vLi4vY2hhcnQvaGVscGVyL0xpbmVEcmF3XCIpO1xuXG52YXIgTWFya2VyVmlldyA9IHJlcXVpcmUoXCIuL01hcmtlclZpZXdcIik7XG5cbnZhciBtYXJrTGluZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgY29vcmRTeXMsIG1sTW9kZWwsIGl0ZW0pIHtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7IC8vIFNwZWNpYWwgdHlwZSBtYXJrTGluZSBsaWtlICdtaW4nLCAnbWF4JywgJ2F2ZXJhZ2UnXG5cbiAgdmFyIG1sVHlwZSA9IGl0ZW0udHlwZTtcblxuICBpZiAoIXpyVXRpbC5pc0FycmF5KGl0ZW0pICYmIChtbFR5cGUgPT09ICdtaW4nIHx8IG1sVHlwZSA9PT0gJ21heCcgfHwgbWxUeXBlID09PSAnYXZlcmFnZScgLy8gSW4gY2FzZVxuICAvLyBkYXRhOiBbe1xuICAvLyAgIHlBeGlzOiAxMFxuICAvLyB9XVxuICB8fCBpdGVtLnhBeGlzICE9IG51bGwgfHwgaXRlbS55QXhpcyAhPSBudWxsKSkge1xuICAgIHZhciB2YWx1ZUF4aXM7XG4gICAgdmFyIHZhbHVlRGF0YURpbTtcbiAgICB2YXIgdmFsdWU7XG5cbiAgICBpZiAoaXRlbS55QXhpcyAhPSBudWxsIHx8IGl0ZW0ueEF4aXMgIT0gbnVsbCkge1xuICAgICAgdmFsdWVEYXRhRGltID0gaXRlbS55QXhpcyAhPSBudWxsID8gJ3knIDogJ3gnO1xuICAgICAgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0QXhpcyh2YWx1ZURhdGFEaW0pO1xuICAgICAgdmFsdWUgPSB6clV0aWwucmV0cmlldmUoaXRlbS55QXhpcywgaXRlbS54QXhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBheGlzSW5mbyA9IG1hcmtlckhlbHBlci5nZXRBeGlzSW5mbyhpdGVtLCBkYXRhLCBjb29yZFN5cywgc2VyaWVzTW9kZWwpO1xuICAgICAgdmFsdWVEYXRhRGltID0gYXhpc0luZm8udmFsdWVEYXRhRGltO1xuICAgICAgdmFsdWVBeGlzID0gYXhpc0luZm8udmFsdWVBeGlzO1xuICAgICAgdmFsdWUgPSBtYXJrZXJIZWxwZXIubnVtQ2FsY3VsYXRlKGRhdGEsIHZhbHVlRGF0YURpbSwgbWxUeXBlKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVJbmRleCA9IHZhbHVlRGF0YURpbSA9PT0gJ3gnID8gMCA6IDE7XG4gICAgdmFyIGJhc2VJbmRleCA9IDEgLSB2YWx1ZUluZGV4O1xuICAgIHZhciBtbEZyb20gPSB6clV0aWwuY2xvbmUoaXRlbSk7XG4gICAgdmFyIG1sVG8gPSB7fTtcbiAgICBtbEZyb20udHlwZSA9IG51bGw7XG4gICAgbWxGcm9tLmNvb3JkID0gW107XG4gICAgbWxUby5jb29yZCA9IFtdO1xuICAgIG1sRnJvbS5jb29yZFtiYXNlSW5kZXhdID0gLUluZmluaXR5O1xuICAgIG1sVG8uY29vcmRbYmFzZUluZGV4XSA9IEluZmluaXR5O1xuICAgIHZhciBwcmVjaXNpb24gPSBtbE1vZGVsLmdldCgncHJlY2lzaW9uJyk7XG5cbiAgICBpZiAocHJlY2lzaW9uID49IDAgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSArdmFsdWUudG9GaXhlZChNYXRoLm1pbihwcmVjaXNpb24sIDIwKSk7XG4gICAgfVxuXG4gICAgbWxGcm9tLmNvb3JkW3ZhbHVlSW5kZXhdID0gbWxUby5jb29yZFt2YWx1ZUluZGV4XSA9IHZhbHVlO1xuICAgIGl0ZW0gPSBbbWxGcm9tLCBtbFRvLCB7XG4gICAgICAvLyBFeHRyYSBvcHRpb24gZm9yIHRvb2x0aXAgYW5kIGxhYmVsXG4gICAgICB0eXBlOiBtbFR5cGUsXG4gICAgICB2YWx1ZUluZGV4OiBpdGVtLnZhbHVlSW5kZXgsXG4gICAgICAvLyBGb3JjZSB0byB1c2UgdGhlIHZhbHVlIG9mIGNhbGN1bGF0ZWQgdmFsdWUuXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9XTtcbiAgfVxuXG4gIGl0ZW0gPSBbbWFya2VySGVscGVyLmRhdGFUcmFuc2Zvcm0oc2VyaWVzTW9kZWwsIGl0ZW1bMF0pLCBtYXJrZXJIZWxwZXIuZGF0YVRyYW5zZm9ybShzZXJpZXNNb2RlbCwgaXRlbVsxXSksIHpyVXRpbC5leHRlbmQoe30sIGl0ZW1bMl0pXTsgLy8gQXZvaWQgbGluZSBkYXRhIHR5cGUgaXMgZXh0ZW5kZWQgYnkgZnJvbSh0bykgZGF0YSB0eXBlXG5cbiAgaXRlbVsyXS50eXBlID0gaXRlbVsyXS50eXBlIHx8ICcnOyAvLyBNZXJnZSBmcm9tIG9wdGlvbiBhbmQgdG8gb3B0aW9uIGludG8gbGluZSBvcHRpb25cblxuICB6clV0aWwubWVyZ2UoaXRlbVsyXSwgaXRlbVswXSk7XG4gIHpyVXRpbC5tZXJnZShpdGVtWzJdLCBpdGVtWzFdKTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5mdW5jdGlvbiBpc0luaWZpbml0eSh2YWwpIHtcbiAgcmV0dXJuICFpc05hTih2YWwpICYmICFpc0Zpbml0ZSh2YWwpO1xufSAvLyBJZiBhIG1hcmtMaW5lIGhhcyBvbmUgZGltXG5cblxuZnVuY3Rpb24gaWZNYXJrTGluZUhhc09ubHlEaW0oZGltSW5kZXgsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpIHtcbiAgdmFyIG90aGVyRGltSW5kZXggPSAxIC0gZGltSW5kZXg7XG4gIHZhciBkaW1OYW1lID0gY29vcmRTeXMuZGltZW5zaW9uc1tkaW1JbmRleF07XG4gIHJldHVybiBpc0luaWZpbml0eShmcm9tQ29vcmRbb3RoZXJEaW1JbmRleF0pICYmIGlzSW5pZmluaXR5KHRvQ29vcmRbb3RoZXJEaW1JbmRleF0pICYmIGZyb21Db29yZFtkaW1JbmRleF0gPT09IHRvQ29vcmRbZGltSW5kZXhdICYmIGNvb3JkU3lzLmdldEF4aXMoZGltTmFtZSkuY29udGFpbkRhdGEoZnJvbUNvb3JkW2RpbUluZGV4XSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtMaW5lRmlsdGVyKGNvb3JkU3lzLCBpdGVtKSB7XG4gIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgdmFyIGZyb21Db29yZCA9IGl0ZW1bMF0uY29vcmQ7XG4gICAgdmFyIHRvQ29vcmQgPSBpdGVtWzFdLmNvb3JkOyAvLyBJbiBjYXNlXG4gICAgLy8ge1xuICAgIC8vICBtYXJrTGluZToge1xuICAgIC8vICAgIGRhdGE6IFt7IHlBeGlzOiAyIH1dXG4gICAgLy8gIH1cbiAgICAvLyB9XG5cbiAgICBpZiAoZnJvbUNvb3JkICYmIHRvQ29vcmQgJiYgKGlmTWFya0xpbmVIYXNPbmx5RGltKDEsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpIHx8IGlmTWFya0xpbmVIYXNPbmx5RGltKDAsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hcmtlckhlbHBlci5kYXRhRmlsdGVyKGNvb3JkU3lzLCBpdGVtWzBdKSAmJiBtYXJrZXJIZWxwZXIuZGF0YUZpbHRlcihjb29yZFN5cywgaXRlbVsxXSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dChkYXRhLCBpZHgsIGlzRnJvbSwgc2VyaWVzTW9kZWwsIGFwaSkge1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgdmFyIHBvaW50O1xuICB2YXIgeFB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneCcpLCBhcGkuZ2V0V2lkdGgoKSk7XG4gIHZhciB5UHggPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChpdGVtTW9kZWwuZ2V0KCd5JyksIGFwaS5nZXRIZWlnaHQoKSk7XG5cbiAgaWYgKCFpc05hTih4UHgpICYmICFpc05hTih5UHgpKSB7XG4gICAgcG9pbnQgPSBbeFB4LCB5UHhdO1xuICB9IGVsc2Uge1xuICAgIC8vIENoYXJ0IGxpa2UgYmFyIG1heSBoYXZlIHRoZXJlIG93biBtYXJrZXIgcG9zaXRpb25pbmcgbG9naWNcbiAgICBpZiAoc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24pIHtcbiAgICAgIC8vIFVzZSB0aGUgZ2V0TWFya2VyUG9pc2l0aW9uXG4gICAgICBwb2ludCA9IHNlcmllc01vZGVsLmdldE1hcmtlclBvc2l0aW9uKGRhdGEuZ2V0VmFsdWVzKGRhdGEuZGltZW5zaW9ucywgaWR4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaW1zID0gY29vcmRTeXMuZGltZW5zaW9ucztcbiAgICAgIHZhciB4ID0gZGF0YS5nZXQoZGltc1swXSwgaWR4KTtcbiAgICAgIHZhciB5ID0gZGF0YS5nZXQoZGltc1sxXSwgaWR4KTtcbiAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoW3gsIHldKTtcbiAgICB9IC8vIEV4cGFuZCBsaW5lIHRvIHRoZSBlZGdlIG9mIGdyaWQgaWYgdmFsdWUgb24gb25lIGF4aXMgaXMgSW5pZm5pdHlcbiAgICAvLyBJbiBjYXNlXG4gICAgLy8gIG1hcmtMaW5lOiB7XG4gICAgLy8gICAgZGF0YTogW3tcbiAgICAvLyAgICAgIHlBeGlzOiAyXG4gICAgLy8gICAgICAvLyBvclxuICAgIC8vICAgICAgdHlwZTogJ2F2ZXJhZ2UnXG4gICAgLy8gICAgfV1cbiAgICAvLyAgfVxuXG5cbiAgICBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgdmFyIHhBeGlzID0gY29vcmRTeXMuZ2V0QXhpcygneCcpO1xuICAgICAgdmFyIHlBeGlzID0gY29vcmRTeXMuZ2V0QXhpcygneScpO1xuICAgICAgdmFyIGRpbXMgPSBjb29yZFN5cy5kaW1lbnNpb25zO1xuXG4gICAgICBpZiAoaXNJbmlmaW5pdHkoZGF0YS5nZXQoZGltc1swXSwgaWR4KSkpIHtcbiAgICAgICAgcG9pbnRbMF0gPSB4QXhpcy50b0dsb2JhbENvb3JkKHhBeGlzLmdldEV4dGVudCgpW2lzRnJvbSA/IDAgOiAxXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzSW5pZmluaXR5KGRhdGEuZ2V0KGRpbXNbMV0sIGlkeCkpKSB7XG4gICAgICAgIHBvaW50WzFdID0geUF4aXMudG9HbG9iYWxDb29yZCh5QXhpcy5nZXRFeHRlbnQoKVtpc0Zyb20gPyAwIDogMV0pO1xuICAgICAgfVxuICAgIH0gLy8gVXNlIHgsIHkgaWYgaGFzIGFueVxuXG5cbiAgICBpZiAoIWlzTmFOKHhQeCkpIHtcbiAgICAgIHBvaW50WzBdID0geFB4O1xuICAgIH1cblxuICAgIGlmICghaXNOYU4oeVB4KSkge1xuICAgICAgcG9pbnRbMV0gPSB5UHg7XG4gICAgfVxuICB9XG5cbiAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwgcG9pbnQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBNYXJrZXJWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdtYXJrTGluZScsXG4gIHVwZGF0ZUxheW91dDogZnVuY3Rpb24gKG1hcmtMaW5lTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBtbE1vZGVsID0gc2VyaWVzTW9kZWwubWFya0xpbmVNb2RlbDtcblxuICAgICAgaWYgKG1sTW9kZWwpIHtcbiAgICAgICAgdmFyIG1sRGF0YSA9IG1sTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgZnJvbURhdGEgPSBtbE1vZGVsLl9fZnJvbTtcbiAgICAgICAgdmFyIHRvRGF0YSA9IG1sTW9kZWwuX190bzsgLy8gVXBkYXRlIHZpc3VhbCBhbmQgbGF5b3V0IG9mIGZyb20gc3ltYm9sIGFuZCB0byBzeW1ib2xcblxuICAgICAgICBmcm9tRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQoZnJvbURhdGEsIGlkeCwgdHJ1ZSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgICAgdXBkYXRlU2luZ2xlTWFya2VyRW5kTGF5b3V0KHRvRGF0YSwgaWR4LCBmYWxzZSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgIH0pOyAvLyBVcGRhdGUgbGF5b3V0IG9mIGxpbmVcblxuICAgICAgICBtbERhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgbWxEYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBbZnJvbURhdGEuZ2V0SXRlbUxheW91dChpZHgpLCB0b0RhdGEuZ2V0SXRlbUxheW91dChpZHgpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcmtlckdyb3VwTWFwLmdldChzZXJpZXNNb2RlbC5pZCkudXBkYXRlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIHJlbmRlclNlcmllczogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBtbE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBzZXJpZXNJZCA9IHNlcmllc01vZGVsLmlkO1xuICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBsaW5lRHJhd01hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgdmFyIGxpbmVEcmF3ID0gbGluZURyYXdNYXAuZ2V0KHNlcmllc0lkKSB8fCBsaW5lRHJhd01hcC5zZXQoc2VyaWVzSWQsIG5ldyBMaW5lRHJhdygpKTtcbiAgICB0aGlzLmdyb3VwLmFkZChsaW5lRHJhdy5ncm91cCk7XG4gICAgdmFyIG1sRGF0YSA9IGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtbE1vZGVsKTtcbiAgICB2YXIgZnJvbURhdGEgPSBtbERhdGEuZnJvbTtcbiAgICB2YXIgdG9EYXRhID0gbWxEYXRhLnRvO1xuICAgIHZhciBsaW5lRGF0YSA9IG1sRGF0YS5saW5lO1xuICAgIG1sTW9kZWwuX19mcm9tID0gZnJvbURhdGE7XG4gICAgbWxNb2RlbC5fX3RvID0gdG9EYXRhOyAvLyBMaW5lIGRhdGEgZm9yIHRvb2x0aXAgYW5kIGZvcm1hdHRlclxuXG4gICAgbWxNb2RlbC5zZXREYXRhKGxpbmVEYXRhKTtcbiAgICB2YXIgc3ltYm9sVHlwZSA9IG1sTW9kZWwuZ2V0KCdzeW1ib2wnKTtcbiAgICB2YXIgc3ltYm9sU2l6ZSA9IG1sTW9kZWwuZ2V0KCdzeW1ib2xTaXplJyk7XG5cbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFR5cGUpKSB7XG4gICAgICBzeW1ib2xUeXBlID0gW3N5bWJvbFR5cGUsIHN5bWJvbFR5cGVdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3ltYm9sU2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XG4gICAgfSAvLyBVcGRhdGUgdmlzdWFsIGFuZCBsYXlvdXQgb2YgZnJvbSBzeW1ib2wgYW5kIHRvIHN5bWJvbFxuXG5cbiAgICBtbERhdGEuZnJvbS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHVwZGF0ZURhdGFWaXN1YWxBbmRMYXlvdXQoZnJvbURhdGEsIGlkeCwgdHJ1ZSk7XG4gICAgICB1cGRhdGVEYXRhVmlzdWFsQW5kTGF5b3V0KHRvRGF0YSwgaWR4LCBmYWxzZSk7XG4gICAgfSk7IC8vIFVwZGF0ZSB2aXN1YWwgYW5kIGxheW91dCBvZiBsaW5lXG5cbiAgICBsaW5lRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBsaW5lQ29sb3IgPSBsaW5lRGF0YS5nZXRJdGVtTW9kZWwoaWR4KS5nZXQoJ2xpbmVTdHlsZS5ub3JtYWwuY29sb3InKTtcbiAgICAgIGxpbmVEYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCB7XG4gICAgICAgIGNvbG9yOiBsaW5lQ29sb3IgfHwgZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpXG4gICAgICB9KTtcbiAgICAgIGxpbmVEYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBbZnJvbURhdGEuZ2V0SXRlbUxheW91dChpZHgpLCB0b0RhdGEuZ2V0SXRlbUxheW91dChpZHgpXSk7XG4gICAgICBsaW5lRGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICAnZnJvbVN5bWJvbFNpemUnOiBmcm9tRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKSxcbiAgICAgICAgJ2Zyb21TeW1ib2wnOiBmcm9tRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpLFxuICAgICAgICAndG9TeW1ib2xTaXplJzogdG9EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScpLFxuICAgICAgICAndG9TeW1ib2wnOiB0b0RhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGluZURyYXcudXBkYXRlRGF0YShsaW5lRGF0YSk7IC8vIFNldCBob3N0IG1vZGVsIGZvciB0b29sdGlwXG4gICAgLy8gRklYTUVcblxuICAgIG1sRGF0YS5saW5lLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuZGF0YU1vZGVsID0gbWxNb2RlbDtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlRGF0YVZpc3VhbEFuZExheW91dChkYXRhLCBpZHgsIGlzRnJvbSkge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQoZGF0YSwgaWR4LCBpc0Zyb20sIHNlcmllc01vZGVsLCBhcGkpO1xuICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICBzeW1ib2xTaXplOiBpdGVtTW9kZWwuZ2V0KCdzeW1ib2xTaXplJykgfHwgc3ltYm9sU2l6ZVtpc0Zyb20gPyAwIDogMV0sXG4gICAgICAgIHN5bWJvbDogaXRlbU1vZGVsLmdldCgnc3ltYm9sJywgdHJ1ZSkgfHwgc3ltYm9sVHlwZVtpc0Zyb20gPyAwIDogMV0sXG4gICAgICAgIGNvbG9yOiBpdGVtTW9kZWwuZ2V0KCdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykgfHwgc2VyaWVzRGF0YS5nZXRWaXN1YWwoJ2NvbG9yJylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxpbmVEcmF3Ll9fa2VlcCA9IHRydWU7XG4gICAgbGluZURyYXcuZ3JvdXAuc2lsZW50ID0gbWxNb2RlbC5nZXQoJ3NpbGVudCcpIHx8IHNlcmllc01vZGVsLmdldCgnc2lsZW50Jyk7XG4gIH1cbn0pO1xuLyoqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvKn0gY29vcmRTeXNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbXBNb2RlbFxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTGlzdChjb29yZFN5cywgc2VyaWVzTW9kZWwsIG1sTW9kZWwpIHtcbiAgdmFyIGNvb3JkRGltc0luZm9zO1xuXG4gIGlmIChjb29yZFN5cykge1xuICAgIGNvb3JkRGltc0luZm9zID0genJVdGlsLm1hcChjb29yZFN5cyAmJiBjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICAgIHZhciBpbmZvID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmdldERpbWVuc2lvbkluZm8oc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0oY29vcmREaW0pWzBdKSB8fCB7fTsgLy8gSW4gbWFwIHNlcmllcyBkYXRhIGRvbid0IGhhdmUgbG5nIGFuZCBsYXQgZGltZW5zaW9uLiBGYWxsYmFjayB0byBzYW1lIHdpdGggY29vcmRTeXNcblxuICAgICAgaW5mby5uYW1lID0gY29vcmREaW07XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb29yZERpbXNJbmZvcyA9IFt7XG4gICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgdHlwZTogJ2Zsb2F0J1xuICAgIH1dO1xuICB9XG5cbiAgdmFyIGZyb21EYXRhID0gbmV3IExpc3QoY29vcmREaW1zSW5mb3MsIG1sTW9kZWwpO1xuICB2YXIgdG9EYXRhID0gbmV3IExpc3QoY29vcmREaW1zSW5mb3MsIG1sTW9kZWwpOyAvLyBObyBkaW1lbnNpb25zXG5cbiAgdmFyIGxpbmVEYXRhID0gbmV3IExpc3QoW10sIG1sTW9kZWwpO1xuICB2YXIgb3B0RGF0YSA9IHpyVXRpbC5tYXAobWxNb2RlbC5nZXQoJ2RhdGEnKSwgenJVdGlsLmN1cnJ5KG1hcmtMaW5lVHJhbnNmb3JtLCBzZXJpZXNNb2RlbCwgY29vcmRTeXMsIG1sTW9kZWwpKTtcblxuICBpZiAoY29vcmRTeXMpIHtcbiAgICBvcHREYXRhID0genJVdGlsLmZpbHRlcihvcHREYXRhLCB6clV0aWwuY3VycnkobWFya0xpbmVGaWx0ZXIsIGNvb3JkU3lzKSk7XG4gIH1cblxuICB2YXIgZGltVmFsdWVHZXR0ZXIgPSBjb29yZFN5cyA/IG1hcmtlckhlbHBlci5kaW1WYWx1ZUdldHRlciA6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gIH07XG4gIGZyb21EYXRhLmluaXREYXRhKHpyVXRpbC5tYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVswXTtcbiAgfSksIG51bGwsIGRpbVZhbHVlR2V0dGVyKTtcbiAgdG9EYXRhLmluaXREYXRhKHpyVXRpbC5tYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVsxXTtcbiAgfSksIG51bGwsIGRpbVZhbHVlR2V0dGVyKTtcbiAgbGluZURhdGEuaW5pdERhdGEoenJVdGlsLm1hcChvcHREYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtWzJdO1xuICB9KSk7XG4gIGxpbmVEYXRhLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICByZXR1cm4ge1xuICAgIGZyb206IGZyb21EYXRhLFxuICAgIHRvOiB0b0RhdGEsXG4gICAgbGluZTogbGluZURhdGFcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtMaW5lVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrTGluZVZpZXcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgTWFya2VyTW9kZWwgPSByZXF1aXJlKFwiLi9NYXJrZXJNb2RlbFwiKTtcblxudmFyIF9kZWZhdWx0ID0gTWFya2VyTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ21hcmtQb2ludCcsXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogNSxcbiAgICBzeW1ib2w6ICdwaW4nLFxuICAgIHN5bWJvbFNpemU6IDUwLFxuICAgIC8vc3ltYm9sUm90YXRlOiAwLFxuICAgIC8vc3ltYm9sT2Zmc2V0OiBbMCwgMF1cbiAgICB0b29sdGlwOiB7XG4gICAgICB0cmlnZ2VyOiAnaXRlbSdcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246ICdpbnNpZGUnXG4gICAgICB9LFxuICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgYm9yZGVyV2lkdGg6IDJcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50TW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50TW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFN5bWJvbERyYXcgPSByZXF1aXJlKFwiLi4vLi4vY2hhcnQvaGVscGVyL1N5bWJvbERyYXdcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgTGlzdCA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL0xpc3RcIik7XG5cbnZhciBtYXJrZXJIZWxwZXIgPSByZXF1aXJlKFwiLi9tYXJrZXJIZWxwZXJcIik7XG5cbnZhciBNYXJrZXJWaWV3ID0gcmVxdWlyZShcIi4vTWFya2VyVmlld1wiKTtcblxuZnVuY3Rpb24gdXBkYXRlTWFya2VyTGF5b3V0KG1wRGF0YSwgc2VyaWVzTW9kZWwsIGFwaSkge1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICBtcERhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IG1wRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB2YXIgcG9pbnQ7XG4gICAgdmFyIHhQeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGl0ZW1Nb2RlbC5nZXQoJ3gnKSwgYXBpLmdldFdpZHRoKCkpO1xuICAgIHZhciB5UHggPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChpdGVtTW9kZWwuZ2V0KCd5JyksIGFwaS5nZXRIZWlnaHQoKSk7XG5cbiAgICBpZiAoIWlzTmFOKHhQeCkgJiYgIWlzTmFOKHlQeCkpIHtcbiAgICAgIHBvaW50ID0gW3hQeCwgeVB4XTtcbiAgICB9IC8vIENoYXJ0IGxpa2UgYmFyIG1heSBoYXZlIHRoZXJlIG93biBtYXJrZXIgcG9zaXRpb25pbmcgbG9naWNcbiAgICBlbHNlIGlmIChzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbikge1xuICAgICAgICAvLyBVc2UgdGhlIGdldE1hcmtlclBvaXNpdGlvblxuICAgICAgICBwb2ludCA9IHNlcmllc01vZGVsLmdldE1hcmtlclBvc2l0aW9uKG1wRGF0YS5nZXRWYWx1ZXMobXBEYXRhLmRpbWVuc2lvbnMsIGlkeCkpO1xuICAgICAgfSBlbHNlIGlmIChjb29yZFN5cykge1xuICAgICAgICB2YXIgeCA9IG1wRGF0YS5nZXQoY29vcmRTeXMuZGltZW5zaW9uc1swXSwgaWR4KTtcbiAgICAgICAgdmFyIHkgPSBtcERhdGEuZ2V0KGNvb3JkU3lzLmRpbWVuc2lvbnNbMV0sIGlkeCk7XG4gICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoW3gsIHldKTtcbiAgICAgIH0gLy8gVXNlIHgsIHkgaWYgaGFzIGFueVxuXG5cbiAgICBpZiAoIWlzTmFOKHhQeCkpIHtcbiAgICAgIHBvaW50WzBdID0geFB4O1xuICAgIH1cblxuICAgIGlmICghaXNOYU4oeVB4KSkge1xuICAgICAgcG9pbnRbMV0gPSB5UHg7XG4gICAgfVxuXG4gICAgbXBEYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBwb2ludCk7XG4gIH0pO1xufVxuXG52YXIgX2RlZmF1bHQgPSBNYXJrZXJWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdtYXJrUG9pbnQnLFxuICB1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uIChtYXJrUG9pbnRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIG1wTW9kZWwgPSBzZXJpZXNNb2RlbC5tYXJrUG9pbnRNb2RlbDtcblxuICAgICAgaWYgKG1wTW9kZWwpIHtcbiAgICAgICAgdXBkYXRlTWFya2VyTGF5b3V0KG1wTW9kZWwuZ2V0RGF0YSgpLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICAgICAgdGhpcy5tYXJrZXJHcm91cE1hcC5nZXQoc2VyaWVzTW9kZWwuaWQpLnVwZGF0ZUxheW91dChtcE1vZGVsKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfSxcbiAgcmVuZGVyU2VyaWVzOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIG1wTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIHNlcmllc0lkID0gc2VyaWVzTW9kZWwuaWQ7XG4gICAgdmFyIHNlcmllc0RhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHN5bWJvbERyYXdNYXAgPSB0aGlzLm1hcmtlckdyb3VwTWFwO1xuICAgIHZhciBzeW1ib2xEcmF3ID0gc3ltYm9sRHJhd01hcC5nZXQoc2VyaWVzSWQpIHx8IHN5bWJvbERyYXdNYXAuc2V0KHNlcmllc0lkLCBuZXcgU3ltYm9sRHJhdygpKTtcbiAgICB2YXIgbXBEYXRhID0gY3JlYXRlTGlzdChjb29yZFN5cywgc2VyaWVzTW9kZWwsIG1wTW9kZWwpOyAvLyBGSVhNRVxuXG4gICAgbXBNb2RlbC5zZXREYXRhKG1wRGF0YSk7XG4gICAgdXBkYXRlTWFya2VyTGF5b3V0KG1wTW9kZWwuZ2V0RGF0YSgpLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICBtcERhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgaXRlbU1vZGVsID0gbXBEYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIHN5bWJvbFNpemUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sU2l6ZScpO1xuXG4gICAgICBpZiAodHlwZW9mIHN5bWJvbFNpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRklYTUUg6L+Z6YeM5LiN5YW85a65IEVDaGFydHMgMi5477yMMi54IOiyjOS8vOWPguaVsOaYr+aVtOS4quaVsOaNru+8n1xuICAgICAgICBzeW1ib2xTaXplID0gc3ltYm9sU2l6ZShtcE1vZGVsLmdldFJhd1ZhbHVlKGlkeCksIG1wTW9kZWwuZ2V0RGF0YVBhcmFtcyhpZHgpKTtcbiAgICAgIH1cblxuICAgICAgbXBEYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCB7XG4gICAgICAgIHN5bWJvbFNpemU6IHN5bWJvbFNpemUsXG4gICAgICAgIGNvbG9yOiBpdGVtTW9kZWwuZ2V0KCdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykgfHwgc2VyaWVzRGF0YS5nZXRWaXN1YWwoJ2NvbG9yJyksXG4gICAgICAgIHN5bWJvbDogaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbCcpXG4gICAgICB9KTtcbiAgICB9KTsgLy8gVE9ETyBUZXh0IGFyZSB3cm9uZ1xuXG4gICAgc3ltYm9sRHJhdy51cGRhdGVEYXRhKG1wRGF0YSk7XG4gICAgdGhpcy5ncm91cC5hZGQoc3ltYm9sRHJhdy5ncm91cCk7IC8vIFNldCBob3N0IG1vZGVsIGZvciB0b29sdGlwXG4gICAgLy8gRklYTUVcblxuICAgIG1wRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5kYXRhTW9kZWwgPSBtcE1vZGVsO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc3ltYm9sRHJhdy5fX2tlZXAgPSB0cnVlO1xuICAgIHN5bWJvbERyYXcuZ3JvdXAuc2lsZW50ID0gbXBNb2RlbC5nZXQoJ3NpbGVudCcpIHx8IHNlcmllc01vZGVsLmdldCgnc2lsZW50Jyk7XG4gIH1cbn0pO1xuLyoqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvKn0gW2Nvb3JkU3lzXVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtcE1vZGVsXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVMaXN0KGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgbXBNb2RlbCkge1xuICB2YXIgY29vcmREaW1zSW5mb3M7XG5cbiAgaWYgKGNvb3JkU3lzKSB7XG4gICAgY29vcmREaW1zSW5mb3MgPSB6clV0aWwubWFwKGNvb3JkU3lzICYmIGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgICAgdmFyIGluZm8gPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuZ2V0RGltZW5zaW9uSW5mbyhzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShjb29yZERpbSlbMF0pIHx8IHt9OyAvLyBJbiBtYXAgc2VyaWVzIGRhdGEgZG9uJ3QgaGF2ZSBsbmcgYW5kIGxhdCBkaW1lbnNpb24uIEZhbGxiYWNrIHRvIHNhbWUgd2l0aCBjb29yZFN5c1xuXG4gICAgICBpbmZvLm5hbWUgPSBjb29yZERpbTtcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvb3JkRGltc0luZm9zID0gW3tcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICB0eXBlOiAnZmxvYXQnXG4gICAgfV07XG4gIH1cblxuICB2YXIgbXBEYXRhID0gbmV3IExpc3QoY29vcmREaW1zSW5mb3MsIG1wTW9kZWwpO1xuICB2YXIgZGF0YU9wdCA9IHpyVXRpbC5tYXAobXBNb2RlbC5nZXQoJ2RhdGEnKSwgenJVdGlsLmN1cnJ5KG1hcmtlckhlbHBlci5kYXRhVHJhbnNmb3JtLCBzZXJpZXNNb2RlbCkpO1xuXG4gIGlmIChjb29yZFN5cykge1xuICAgIGRhdGFPcHQgPSB6clV0aWwuZmlsdGVyKGRhdGFPcHQsIHpyVXRpbC5jdXJyeShtYXJrZXJIZWxwZXIuZGF0YUZpbHRlciwgY29vcmRTeXMpKTtcbiAgfVxuXG4gIG1wRGF0YS5pbml0RGF0YShkYXRhT3B0LCBudWxsLCBjb29yZFN5cyA/IG1hcmtlckhlbHBlci5kaW1WYWx1ZUdldHRlciA6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gIH0pO1xuICByZXR1cm4gbXBEYXRhO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50Vmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrUG9pbnRWaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBhZGRDb21tYXMgPSBmb3JtYXRVdGlsLmFkZENvbW1hcztcbnZhciBlbmNvZGVIVE1MID0gZm9ybWF0VXRpbC5lbmNvZGVIVE1MO1xuXG5mdW5jdGlvbiBmaWxsTGFiZWwob3B0KSB7XG4gIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMob3B0LmxhYmVsLCBbJ3Nob3cnXSk7XG59XG5cbnZhciBNYXJrZXJNb2RlbCA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuICB0eXBlOiAnbWFya2VyJyxcbiAgZGVwZW5kZW5jaWVzOiBbJ3NlcmllcycsICdncmlkJywgJ3BvbGFyJywgJ2dlbyddLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpdGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcbiAgICB0aGlzLm1lcmdlT3B0aW9uKG9wdGlvbiwgZWNNb2RlbCwgZXh0cmFPcHQuY3JlYXRlZEJ5U2VsZiwgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FuaW1hdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaG9zdFNlcmllcyA9IHRoaXMuX19ob3N0U2VyaWVzO1xuICAgIHJldHVybiB0aGlzLmdldFNoYWxsb3coJ2FuaW1hdGlvbicpICYmIGhvc3RTZXJpZXMgJiYgaG9zdFNlcmllcy5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgfSxcbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHQsIGVjTW9kZWwsIGNyZWF0ZWRCeVNlbGYsIGlzSW5pdCkge1xuICAgIHZhciBNYXJrZXJNb2RlbCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgdmFyIG1vZGVsUHJvcE5hbWUgPSB0aGlzLm1haW5UeXBlICsgJ01vZGVsJztcblxuICAgIGlmICghY3JlYXRlZEJ5U2VsZikge1xuICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICB2YXIgbWFya2VyT3B0ID0gc2VyaWVzTW9kZWwuZ2V0KHRoaXMubWFpblR5cGUpO1xuICAgICAgICB2YXIgbWFya2VyTW9kZWwgPSBzZXJpZXNNb2RlbFttb2RlbFByb3BOYW1lXTtcblxuICAgICAgICBpZiAoIW1hcmtlck9wdCB8fCAhbWFya2VyT3B0LmRhdGEpIHtcbiAgICAgICAgICBzZXJpZXNNb2RlbFttb2RlbFByb3BOYW1lXSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXJrZXJNb2RlbCkge1xuICAgICAgICAgIGlmIChpc0luaXQpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgbGFiZWwgZW1waGFzaXMgYHBvc2l0aW9uYCBhbmQgYHNob3dgXG4gICAgICAgICAgICBmaWxsTGFiZWwobWFya2VyT3B0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB6clV0aWwuZWFjaChtYXJrZXJPcHQuZGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIE92ZXJ3cml0ZSBmaWxsTGFiZWwgbWV0aG9kID9cbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgZmlsbExhYmVsKGl0ZW1bMF0pO1xuICAgICAgICAgICAgICBmaWxsTGFiZWwoaXRlbVsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaWxsTGFiZWwoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFya2VyTW9kZWwgPSBuZXcgTWFya2VyTW9kZWwobWFya2VyT3B0LCB0aGlzLCBlY01vZGVsKTtcbiAgICAgICAgICB6clV0aWwuZXh0ZW5kKG1hcmtlck1vZGVsLCB7XG4gICAgICAgICAgICBtYWluVHlwZTogdGhpcy5tYWluVHlwZSxcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgc2FtZSBzZXJpZXMgaW5kZXggYW5kIG5hbWVcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgIG5hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICAgICAgICBjcmVhdGVkQnlTZWxmOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFya2VyTW9kZWwuX19ob3N0U2VyaWVzID0gc2VyaWVzTW9kZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya2VyTW9kZWwubWVyZ2VPcHRpb24obWFya2VyT3B0LCBlY01vZGVsLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmllc01vZGVsW21vZGVsUHJvcE5hbWVdID0gbWFya2VyTW9kZWw7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH0sXG4gIGZvcm1hdFRvb2x0aXA6IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KTtcbiAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB6clV0aWwuaXNBcnJheSh2YWx1ZSkgPyB6clV0aWwubWFwKHZhbHVlLCBhZGRDb21tYXMpLmpvaW4oJywgJykgOiBhZGRDb21tYXModmFsdWUpO1xuICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgdmFyIGh0bWwgPSBlbmNvZGVIVE1MKHRoaXMubmFtZSk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCB8fCBuYW1lKSB7XG4gICAgICBodG1sICs9ICc8YnIgLz4nO1xuICAgIH1cblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBodG1sICs9IGVuY29kZUhUTUwobmFtZSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGh0bWwgKz0gJyA6ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGh0bWwgKz0gZW5jb2RlSFRNTChmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH0sXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfSxcbiAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxufSk7XG56clV0aWwubWl4aW4oTWFya2VyTW9kZWwsIG1vZGVsVXRpbC5kYXRhRm9ybWF0TWl4aW4pO1xudmFyIF9kZWZhdWx0ID0gTWFya2VyTW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya2VyTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya2VyTW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIF9kZWZhdWx0ID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ21hcmtlcicsXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBNYXJrbGluZSBncm91cGVkIGJ5IHNlcmllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbC5IYXNoTWFwfVxuICAgICAqL1xuICAgIHRoaXMubWFya2VyR3JvdXBNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChtYXJrZXJNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIG1hcmtlckdyb3VwTWFwID0gdGhpcy5tYXJrZXJHcm91cE1hcDtcbiAgICBtYXJrZXJHcm91cE1hcC5lYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtLl9fa2VlcCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHZhciBtYXJrZXJNb2RlbEtleSA9IHRoaXMudHlwZSArICdNb2RlbCc7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIG1hcmtlck1vZGVsID0gc2VyaWVzTW9kZWxbbWFya2VyTW9kZWxLZXldO1xuICAgICAgbWFya2VyTW9kZWwgJiYgdGhpcy5yZW5kZXJTZXJpZXMoc2VyaWVzTW9kZWwsIG1hcmtlck1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgIH0sIHRoaXMpO1xuICAgIG1hcmtlckdyb3VwTWFwLmVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICFpdGVtLl9fa2VlcCAmJiB0aGlzLmdyb3VwLnJlbW92ZShpdGVtLmdyb3VwKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcbiAgcmVuZGVyU2VyaWVzOiBmdW5jdGlvbiAoKSB7fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtlclZpZXcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBpbmRleE9mID0genJVdGlsLmluZGV4T2Y7XG5cbmZ1bmN0aW9uIGhhc1hPclkoaXRlbSkge1xuICByZXR1cm4gIShpc05hTihwYXJzZUZsb2F0KGl0ZW0ueCkpICYmIGlzTmFOKHBhcnNlRmxvYXQoaXRlbS55KSkpO1xufVxuXG5mdW5jdGlvbiBoYXNYQW5kWShpdGVtKSB7XG4gIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChpdGVtLngpKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChpdGVtLnkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKGRhdGEsIHZhbHVlQXhpc0RpbSwgZGF0YUluZGV4KSB7XG4gIHZhciBwcmVjaXNpb24gPSAtMTtcblxuICBkbyB7XG4gICAgcHJlY2lzaW9uID0gTWF0aC5tYXgobnVtYmVyVXRpbC5nZXRQcmVjaXNpb24oZGF0YS5nZXQodmFsdWVBeGlzRGltLCBkYXRhSW5kZXgpKSwgcHJlY2lzaW9uKTtcbiAgICBkYXRhID0gZGF0YS5zdGFja2VkT247XG4gIH0gd2hpbGUgKGRhdGEpO1xuXG4gIHJldHVybiBwcmVjaXNpb247XG59XG5cbmZ1bmN0aW9uIG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudChtbFR5cGUsIGRhdGEsIG90aGVyRGF0YURpbSwgdGFyZ2V0RGF0YURpbSwgb3RoZXJDb29yZEluZGV4LCB0YXJnZXRDb29yZEluZGV4KSB7XG4gIHZhciBjb29yZEFyciA9IFtdO1xuICB2YXIgdmFsdWUgPSBudW1DYWxjdWxhdGUoZGF0YSwgdGFyZ2V0RGF0YURpbSwgbWxUeXBlKTtcbiAgdmFyIGRhdGFJbmRleCA9IGRhdGEuaW5kaWNlc09mTmVhcmVzdCh0YXJnZXREYXRhRGltLCB2YWx1ZSwgdHJ1ZSlbMF07XG4gIGNvb3JkQXJyW290aGVyQ29vcmRJbmRleF0gPSBkYXRhLmdldChvdGhlckRhdGFEaW0sIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIGNvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdID0gZGF0YS5nZXQodGFyZ2V0RGF0YURpbSwgZGF0YUluZGV4LCB0cnVlKTtcbiAgdmFyIHByZWNpc2lvbiA9IGdldFByZWNpc2lvbihkYXRhLCB0YXJnZXREYXRhRGltLCBkYXRhSW5kZXgpO1xuICBwcmVjaXNpb24gPSBNYXRoLm1pbihwcmVjaXNpb24sIDIwKTtcblxuICBpZiAocHJlY2lzaW9uID49IDApIHtcbiAgICBjb29yZEFyclt0YXJnZXRDb29yZEluZGV4XSA9ICtjb29yZEFyclt0YXJnZXRDb29yZEluZGV4XS50b0ZpeGVkKHByZWNpc2lvbik7XG4gIH1cblxuICByZXR1cm4gY29vcmRBcnI7XG59XG5cbnZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTsgLy8gVE9ETyBTcGVjaWZpZWQgcGVyY2VudFxuXG52YXIgbWFya2VyVHlwZUNhbGN1bGF0b3IgPSB7XG4gIC8qKlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlQXhpc0RpbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVBeGlzRGltXG4gICAqL1xuICBtaW46IGN1cnJ5KG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudCwgJ21pbicpLFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlQXhpc0RpbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVBeGlzRGltXG4gICAqL1xuICBtYXg6IGN1cnJ5KG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudCwgJ21heCcpLFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlQXhpc0RpbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVBeGlzRGltXG4gICAqL1xuICBhdmVyYWdlOiBjdXJyeShtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQsICdhdmVyYWdlJylcbn07XG4vKipcbiAqIFRyYW5zZm9ybSBtYXJrUG9pbnQgZGF0YSBpdGVtIHRvIGZvcm1hdCB1c2VkIGluIExpc3QgYnkgZG8gdGhlIGZvbGxvd2luZ1xuICogMS4gQ2FsY3VsYXRlIHN0YXRpc3RpYyBsaWtlIGBtYXhgLCBgbWluYCwgYGF2ZXJhZ2VgXG4gKiAyLiBDb252ZXJ0IGBpdGVtLnhBeGlzYCwgYGl0ZW0ueUF4aXNgIHRvIGBpdGVtLmNvb3JkYCBhcnJheVxuICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvY29vcmQvKn0gW2Nvb3JkU3lzXVxuICogQHBhcmFtICB7T2JqZWN0fSBpdGVtXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZGF0YVRyYW5zZm9ybShzZXJpZXNNb2RlbCwgaXRlbSkge1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTsgLy8gMS4gSWYgbm90IHNwZWNpZnkgdGhlIHBvc2l0aW9uIHdpdGggcGl4ZWwgZGlyZWN0bHlcbiAgLy8gMi4gSWYgYGNvb3JkYCBpcyBub3QgYSBkYXRhIGFycmF5LiBXaGljaCB1c2VzIGB4QXhpc2AsXG4gIC8vIGB5QXhpc2AgdG8gc3BlY2lmeSB0aGUgY29vcmQgb24gZWFjaCBkaW1lbnNpb25cbiAgLy8gcGFyc2VGbG9hdCBmaXJzdCBiZWNhdXNlIGl0ZW0ueCBhbmQgaXRlbS55IGNhbiBiZSBwZXJjZW50IHN0cmluZyBsaWtlICcyMCUnXG5cbiAgaWYgKGl0ZW0gJiYgIWhhc1hBbmRZKGl0ZW0pICYmICF6clV0aWwuaXNBcnJheShpdGVtLmNvb3JkKSAmJiBjb29yZFN5cykge1xuICAgIHZhciBkaW1zID0gY29vcmRTeXMuZGltZW5zaW9ucztcbiAgICB2YXIgYXhpc0luZm8gPSBnZXRBeGlzSW5mbyhpdGVtLCBkYXRhLCBjb29yZFN5cywgc2VyaWVzTW9kZWwpOyAvLyBDbG9uZSB0aGUgb3B0aW9uXG4gICAgLy8gVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIHhBeGlzLCB5QXhpcywgcmFkaXVzQXhpcywgYW5nbGVBeGlzLCBnZW9Db29yZCB0byB2YWx1ZVxuXG4gICAgaXRlbSA9IHpyVXRpbC5jbG9uZShpdGVtKTtcblxuICAgIGlmIChpdGVtLnR5cGUgJiYgbWFya2VyVHlwZUNhbGN1bGF0b3JbaXRlbS50eXBlXSAmJiBheGlzSW5mby5iYXNlQXhpcyAmJiBheGlzSW5mby52YWx1ZUF4aXMpIHtcbiAgICAgIHZhciBvdGhlckNvb3JkSW5kZXggPSBpbmRleE9mKGRpbXMsIGF4aXNJbmZvLmJhc2VBeGlzLmRpbSk7XG4gICAgICB2YXIgdGFyZ2V0Q29vcmRJbmRleCA9IGluZGV4T2YoZGltcywgYXhpc0luZm8udmFsdWVBeGlzLmRpbSk7XG4gICAgICBpdGVtLmNvb3JkID0gbWFya2VyVHlwZUNhbGN1bGF0b3JbaXRlbS50eXBlXShkYXRhLCBheGlzSW5mby5iYXNlRGF0YURpbSwgYXhpc0luZm8udmFsdWVEYXRhRGltLCBvdGhlckNvb3JkSW5kZXgsIHRhcmdldENvb3JkSW5kZXgpOyAvLyBGb3JjZSB0byB1c2UgdGhlIHZhbHVlIG9mIGNhbGN1bGF0ZWQgdmFsdWUuXG5cbiAgICAgIGl0ZW0udmFsdWUgPSBpdGVtLmNvb3JkW3RhcmdldENvb3JkSW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGSVhNRSBPbmx5IGhhcyBvbmUgb2YgeEF4aXMgYW5kIHlBeGlzLlxuICAgICAgdmFyIGNvb3JkID0gW2l0ZW0ueEF4aXMgIT0gbnVsbCA/IGl0ZW0ueEF4aXMgOiBpdGVtLnJhZGl1c0F4aXMsIGl0ZW0ueUF4aXMgIT0gbnVsbCA/IGl0ZW0ueUF4aXMgOiBpdGVtLmFuZ2xlQXhpc107IC8vIEVhY2ggY29vcmQgc3VwcG9ydCBtYXgsIG1pbiwgYXZlcmFnZVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICBpZiAobWFya2VyVHlwZUNhbGN1bGF0b3JbY29vcmRbaV1dKSB7XG4gICAgICAgICAgdmFyIGRhdGFEaW0gPSBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShkaW1zW2ldKVswXTtcbiAgICAgICAgICBjb29yZFtpXSA9IG51bUNhbGN1bGF0ZShkYXRhLCBkYXRhRGltLCBjb29yZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlbS5jb29yZCA9IGNvb3JkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpdGVtO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzSW5mbyhpdGVtLCBkYXRhLCBjb29yZFN5cywgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIHJldCA9IHt9O1xuXG4gIGlmIChpdGVtLnZhbHVlSW5kZXggIT0gbnVsbCB8fCBpdGVtLnZhbHVlRGltICE9IG51bGwpIHtcbiAgICByZXQudmFsdWVEYXRhRGltID0gaXRlbS52YWx1ZUluZGV4ICE9IG51bGwgPyBkYXRhLmdldERpbWVuc2lvbihpdGVtLnZhbHVlSW5kZXgpIDogaXRlbS52YWx1ZURpbTtcbiAgICByZXQudmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0QXhpcyhzZXJpZXNNb2RlbC5kYXRhRGltVG9Db29yZERpbShyZXQudmFsdWVEYXRhRGltKSk7XG4gICAgcmV0LmJhc2VBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKHJldC52YWx1ZUF4aXMpO1xuICAgIHJldC5iYXNlRGF0YURpbSA9IHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKHJldC5iYXNlQXhpcy5kaW0pWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldC5iYXNlQXhpcyA9IHNlcmllc01vZGVsLmdldEJhc2VBeGlzKCk7XG4gICAgcmV0LnZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhyZXQuYmFzZUF4aXMpO1xuICAgIHJldC5iYXNlRGF0YURpbSA9IHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKHJldC5iYXNlQXhpcy5kaW0pWzBdO1xuICAgIHJldC52YWx1ZURhdGFEaW0gPSBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShyZXQudmFsdWVBeGlzLmRpbSlbMF07XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBGaWx0ZXIgZGF0YSB3aGljaCBpcyBvdXQgb2YgY29vcmRpbmF0ZVN5c3RlbSByYW5nZVxuICogW2RhdGFGaWx0ZXIgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC8qfSBbY29vcmRTeXNdXG4gKiBAcGFyYW0gIHtPYmplY3R9IGl0ZW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBkYXRhRmlsdGVyKGNvb3JkU3lzLCBpdGVtKSB7XG4gIC8vIEFsd2FseXMgcmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgbm8gY29vcmRTeXNcbiAgcmV0dXJuIGNvb3JkU3lzICYmIGNvb3JkU3lzLmNvbnRhaW5EYXRhICYmIGl0ZW0uY29vcmQgJiYgIWhhc1hPclkoaXRlbSkgPyBjb29yZFN5cy5jb250YWluRGF0YShpdGVtLmNvb3JkKSA6IHRydWU7XG59XG5cbmZ1bmN0aW9uIGRpbVZhbHVlR2V0dGVyKGl0ZW0sIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgLy8geCwgeSwgcmFkaXVzLCBhbmdsZVxuICBpZiAoZGltSW5kZXggPCAyKSB7XG4gICAgcmV0dXJuIGl0ZW0uY29vcmQgJiYgaXRlbS5jb29yZFtkaW1JbmRleF07XG4gIH1cblxuICByZXR1cm4gaXRlbS52YWx1ZTtcbn1cblxuZnVuY3Rpb24gbnVtQ2FsY3VsYXRlKGRhdGEsIHZhbHVlRGF0YURpbSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ2F2ZXJhZ2UnKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBkYXRhLmVhY2godmFsdWVEYXRhRGltLCBmdW5jdGlvbiAodmFsLCBpZHgpIHtcbiAgICAgIGlmICghaXNOYU4odmFsKSkge1xuICAgICAgICBzdW0gKz0gdmFsO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICAgIHJldHVybiBzdW0gLyBjb3VudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YS5nZXREYXRhRXh0ZW50KHZhbHVlRGF0YURpbSwgdHJ1ZSlbdHlwZSA9PT0gJ21heCcgPyAxIDogMF07XG4gIH1cbn1cblxuZXhwb3J0cy5kYXRhVHJhbnNmb3JtID0gZGF0YVRyYW5zZm9ybTtcbmV4cG9ydHMuZ2V0QXhpc0luZm8gPSBnZXRBeGlzSW5mbztcbmV4cG9ydHMuZGF0YUZpbHRlciA9IGRhdGFGaWx0ZXI7XG5leHBvcnRzLmRpbVZhbHVlR2V0dGVyID0gZGltVmFsdWVHZXR0ZXI7XG5leHBvcnRzLm51bUNhbGN1bGF0ZSA9IG51bUNhbGN1bGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL21hcmtlckhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9tYXJrZXJIZWxwZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBfbGF5b3V0ID0gcmVxdWlyZShcIi4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgZ2V0TGF5b3V0UmVjdCA9IF9sYXlvdXQuZ2V0TGF5b3V0UmVjdDtcbi8vIE1vZGVsXG5lY2hhcnRzLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcbiAgdHlwZTogJ3RpdGxlJyxcbiAgbGF5b3V0TW9kZToge1xuICAgIHR5cGU6ICdib3gnLFxuICAgIGlnbm9yZVNpemU6IHRydWVcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIC8vIOS4gOe6p+WxguWPoFxuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICB6OiA2LFxuICAgIHNob3c6IHRydWUsXG4gICAgdGV4dDogJycsXG4gICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgLy8gbGluazogbnVsbCxcbiAgICAvLyDku4XmlK/mjIFzZWxmIHwgYmxhbmtcbiAgICB0YXJnZXQ6ICdibGFuaycsXG4gICAgc3VidGV4dDogJycsXG4gICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgLy8gc3VibGluazogbnVsbCxcbiAgICAvLyDku4XmlK/mjIFzZWxmIHwgYmxhbmtcbiAgICBzdWJ0YXJnZXQ6ICdibGFuaycsXG4gICAgLy8gJ2NlbnRlcicgwqYgJ2xlZnQnIMKmICdyaWdodCdcbiAgICAvLyDCpiB7bnVtYmVyfe+8iHjlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgIGxlZnQ6IDAsXG4gICAgLy8gJ3RvcCcgwqYgJ2JvdHRvbScgwqYgJ2NlbnRlcidcbiAgICAvLyDCpiB7bnVtYmVyfe+8iHnlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgIHRvcDogMCxcbiAgICAvLyDmsLTlubPlr7npvZBcbiAgICAvLyAnYXV0bycgfCAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcidcbiAgICAvLyDpu5jorqTmoLnmja4gbGVmdCDnmoTkvY3nva7liKTmlq3mmK/lt6blr7npvZDov5jmmK/lj7Plr7npvZBcbiAgICAvLyB0ZXh0QWxpZ246IG51bGxcbiAgICAvL1xuICAgIC8vIOWeguebtOWvuem9kFxuICAgIC8vICdhdXRvJyB8ICd0b3AnIHwgJ2JvdHRvbScgfCAnbWlkZGxlJ1xuICAgIC8vIOm7mOiupOagueaNriB0b3Ag5L2N572u5Yik5pat5piv5LiK5a+56b2Q6L+Y5piv5LiL5a+56b2QXG4gICAgLy8gdGV4dEJhc2VsaW5lOiBudWxsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgLy8g5qCH6aKY6L655qGG6aKc6ImyXG4gICAgYm9yZGVyQ29sb3I6ICcjY2NjJyxcbiAgICAvLyDmoIfpopjovrnmoYbnur/lrr3vvIzljZXkvY1weO+8jOm7mOiupOS4ujDvvIjml6DovrnmoYbvvIlcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICAvLyDmoIfpopjlhoXovrnot53vvIzljZXkvY1weO+8jOm7mOiupOWQhOaWueWQkeWGhei+uei3neS4ujXvvIxcbiAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcbiAgICBwYWRkaW5nOiA1LFxuICAgIC8vIOS4u+WJr+agh+mimOe6teWQkemXtOmalO+8jOWNleS9jXB477yM6buY6K6k5Li6MTDvvIxcbiAgICBpdGVtR2FwOiAxMCxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGZvbnRTaXplOiAxOCxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkZXInLFxuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgc3VidGV4dFN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNhYWEnXG4gICAgfVxuICB9XG59KTsgLy8gVmlld1xuXG5lY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuICB0eXBlOiAndGl0bGUnLFxuICByZW5kZXI6IGZ1bmN0aW9uICh0aXRsZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKCF0aXRsZU1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICB2YXIgc3VidGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCdzdWJ0ZXh0U3R5bGUnKTtcbiAgICB2YXIgdGV4dEFsaWduID0gdGl0bGVNb2RlbC5nZXQoJ3RleHRBbGlnbicpO1xuICAgIHZhciB0ZXh0QmFzZWxpbmUgPSB0aXRsZU1vZGVsLmdldCgndGV4dEJhc2VsaW5lJyk7XG4gICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgc3R5bGU6IGdyYXBoaWMuc2V0VGV4dFN0eWxlKHt9LCB0ZXh0U3R5bGVNb2RlbCwge1xuICAgICAgICB0ZXh0OiB0aXRsZU1vZGVsLmdldCgndGV4dCcpLFxuICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKClcbiAgICAgIH0sIHtcbiAgICAgICAgZGlzYWJsZUJveDogdHJ1ZVxuICAgICAgfSksXG4gICAgICB6MjogMTBcbiAgICB9KTtcbiAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0RWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIHN1YlRleHQgPSB0aXRsZU1vZGVsLmdldCgnc3VidGV4dCcpO1xuICAgIHZhciBzdWJUZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHN0eWxlOiBncmFwaGljLnNldFRleHRTdHlsZSh7fSwgc3VidGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgdGV4dDogc3ViVGV4dCxcbiAgICAgICAgdGV4dEZpbGw6IHN1YnRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgICB5OiB0ZXh0UmVjdC5oZWlnaHQgKyB0aXRsZU1vZGVsLmdldCgnaXRlbUdhcCcpLFxuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogJ3RvcCdcbiAgICAgIH0sIHtcbiAgICAgICAgZGlzYWJsZUJveDogdHJ1ZVxuICAgICAgfSksXG4gICAgICB6MjogMTBcbiAgICB9KTtcbiAgICB2YXIgbGluayA9IHRpdGxlTW9kZWwuZ2V0KCdsaW5rJyk7XG4gICAgdmFyIHN1YmxpbmsgPSB0aXRsZU1vZGVsLmdldCgnc3VibGluaycpO1xuICAgIHRleHRFbC5zaWxlbnQgPSAhbGluaztcbiAgICBzdWJUZXh0RWwuc2lsZW50ID0gIXN1Ymxpbms7XG5cbiAgICBpZiAobGluaykge1xuICAgICAgdGV4dEVsLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Lm9wZW4obGluaywgJ18nICsgdGl0bGVNb2RlbC5nZXQoJ3RhcmdldCcpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzdWJsaW5rKSB7XG4gICAgICBzdWJUZXh0RWwub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cub3BlbihzdWJsaW5rLCAnXycgKyB0aXRsZU1vZGVsLmdldCgnc3VidGFyZ2V0JykpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgc3ViVGV4dCAmJiBncm91cC5hZGQoc3ViVGV4dEVsKTsgLy8gSWYgbm8gc3ViVGV4dCwgYnV0IGFkZCBzdWJUZXh0RWwsIHRoZXJlIHdpbGwgYmUgYW4gZW1wdHkgbGluZS5cblxuICAgIHZhciBncm91cFJlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgbGF5b3V0T3B0aW9uID0gdGl0bGVNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKTtcbiAgICBsYXlvdXRPcHRpb24ud2lkdGggPSBncm91cFJlY3Qud2lkdGg7XG4gICAgbGF5b3V0T3B0aW9uLmhlaWdodCA9IGdyb3VwUmVjdC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFJlY3QgPSBnZXRMYXlvdXRSZWN0KGxheW91dE9wdGlvbiwge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9LCB0aXRsZU1vZGVsLmdldCgncGFkZGluZycpKTsgLy8gQWRqdXN0IHRleHQgYWxpZ24gYmFzZWQgb24gcG9zaXRpb25cblxuICAgIGlmICghdGV4dEFsaWduKSB7XG4gICAgICAvLyBBbGlnbiBsZWZ0IGlmIHRpdGxlIGlzIG9uIHRoZSBsZWZ0LiBjZW50ZXIgYW5kIHJpZ2h0IGlzIHNhbWVcbiAgICAgIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCdsZWZ0JykgfHwgdGl0bGVNb2RlbC5nZXQoJ3JpZ2h0Jyk7XG5cbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfSAvLyBBZGp1c3QgbGF5b3V0IGJ5IHRleHQgYWxpZ25cblxuXG4gICAgICBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIGxheW91dFJlY3QueCArPSBsYXlvdXRSZWN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGxheW91dFJlY3QueCArPSBsYXlvdXRSZWN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRleHRCYXNlbGluZSkge1xuICAgICAgdGV4dEJhc2VsaW5lID0gdGl0bGVNb2RlbC5nZXQoJ3RvcCcpIHx8IHRpdGxlTW9kZWwuZ2V0KCdib3R0b20nKTtcblxuICAgICAgaWYgKHRleHRCYXNlbGluZSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGxheW91dFJlY3QueSArPSBsYXlvdXRSZWN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAodGV4dEJhc2VsaW5lID09PSAnbWlkZGxlJykge1xuICAgICAgICBsYXlvdXRSZWN0LnkgKz0gbGF5b3V0UmVjdC5oZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICB0ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmUgfHwgJ3RvcCc7XG4gICAgfVxuXG4gICAgZ3JvdXAuYXR0cigncG9zaXRpb24nLCBbbGF5b3V0UmVjdC54LCBsYXlvdXRSZWN0LnldKTtcbiAgICB2YXIgYWxpZ25TdHlsZSA9IHtcbiAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRCYXNlbGluZVxuICAgIH07XG4gICAgdGV4dEVsLnNldFN0eWxlKGFsaWduU3R5bGUpO1xuICAgIHN1YlRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTsgLy8gUmVuZGVyIGJhY2tncm91bmRcbiAgICAvLyBHZXQgZ3JvdXBSZWN0IGFnYWluIGJlY2F1c2UgdGV4dEFsaWduIGhhcyBiZWVuIGNoYW5nZWRcblxuICAgIGdyb3VwUmVjdCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBwYWRkaW5nID0gbGF5b3V0UmVjdC5tYXJnaW47XG4gICAgdmFyIHN0eWxlID0gdGl0bGVNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvcicsICdvcGFjaXR5J10pO1xuICAgIHN0eWxlLmZpbGwgPSB0aXRsZU1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IGdyb3VwUmVjdC54IC0gcGFkZGluZ1szXSxcbiAgICAgICAgeTogZ3JvdXBSZWN0LnkgLSBwYWRkaW5nWzBdLFxuICAgICAgICB3aWR0aDogZ3JvdXBSZWN0LndpZHRoICsgcGFkZGluZ1sxXSArIHBhZGRpbmdbM10sXG4gICAgICAgIGhlaWdodDogZ3JvdXBSZWN0LmhlaWdodCArIHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdLFxuICAgICAgICByOiB0aXRsZU1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJylcbiAgICAgIH0sXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KTtcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVSZWN0KHJlY3QpO1xuICAgIGdyb3VwLmFkZChyZWN0KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpdGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdGl0bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKFwiLi90b29sYm94L1Rvb2xib3hNb2RlbFwiKTtcblxucmVxdWlyZShcIi4vdG9vbGJveC9Ub29sYm94Vmlld1wiKTtcblxucmVxdWlyZShcIi4vdG9vbGJveC9mZWF0dXJlL1NhdmVBc0ltYWdlXCIpO1xuXG5yZXF1aXJlKFwiLi90b29sYm94L2ZlYXR1cmUvTWFnaWNUeXBlXCIpO1xuXG5yZXF1aXJlKFwiLi90b29sYm94L2ZlYXR1cmUvRGF0YVZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL3Rvb2xib3gvZmVhdHVyZS9EYXRhWm9vbVwiKTtcblxucmVxdWlyZShcIi4vdG9vbGJveC9mZWF0dXJlL1Jlc3RvcmVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3guanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBmZWF0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCIuL2ZlYXR1cmVNYW5hZ2VyXCIpO1xuXG52YXIgVG9vbGJveE1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICd0b29sYm94JyxcbiAgbGF5b3V0TW9kZToge1xuICAgIHR5cGU6ICdib3gnLFxuICAgIGlnbm9yZVNpemU6IHRydWVcbiAgfSxcbiAgbWVyZ2VEZWZhdWx0QW5kVGhlbWU6IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBUb29sYm94TW9kZWwuc3VwZXJBcHBseSh0aGlzLCAnbWVyZ2VEZWZhdWx0QW5kVGhlbWUnLCBhcmd1bWVudHMpO1xuICAgIHpyVXRpbC5lYWNoKHRoaXMub3B0aW9uLmZlYXR1cmUsIGZ1bmN0aW9uIChmZWF0dXJlT3B0LCBmZWF0dXJlTmFtZSkge1xuICAgICAgdmFyIEZlYXR1cmUgPSBmZWF0dXJlTWFuYWdlci5nZXQoZmVhdHVyZU5hbWUpO1xuICAgICAgRmVhdHVyZSAmJiB6clV0aWwubWVyZ2UoZmVhdHVyZU9wdCwgRmVhdHVyZS5kZWZhdWx0T3B0aW9uKTtcbiAgICB9KTtcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIHNob3c6IHRydWUsXG4gICAgejogNixcbiAgICB6bGV2ZWw6IDAsXG4gICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG4gICAgbGVmdDogJ3JpZ2h0JyxcbiAgICB0b3A6ICd0b3AnLFxuICAgIC8vIHJpZ2h0XG4gICAgLy8gYm90dG9tXG4gICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIHBhZGRpbmc6IDUsXG4gICAgaXRlbVNpemU6IDE1LFxuICAgIGl0ZW1HYXA6IDgsXG4gICAgc2hvd1RpdGxlOiB0cnVlLFxuICAgIGljb25TdHlsZToge1xuICAgICAgbm9ybWFsOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzY2NicsXG4gICAgICAgIGNvbG9yOiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICBlbXBoYXNpczoge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMzRTk4QzUnXG4gICAgICB9IC8vIHRleHRTdHlsZToge30sXG4gICAgICAvLyBmZWF0dXJlXG5cbiAgICB9XG4gIH1cbn0pO1xudmFyIF9kZWZhdWx0ID0gVG9vbGJveE1vZGVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9Ub29sYm94TW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hNb2RlbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbi90ZXh0XCIpO1xuXG52YXIgZmVhdHVyZU1hbmFnZXIgPSByZXF1aXJlKFwiLi9mZWF0dXJlTWFuYWdlclwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTW9kZWxcIik7XG5cbnZhciBEYXRhRGlmZmVyID0gcmVxdWlyZShcIi4uLy4uL2RhdGEvRGF0YURpZmZlclwiKTtcblxudmFyIGxpc3RDb21wb25lbnRIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL2xpc3RDb21wb25lbnRcIik7XG5cbnZhciBfZGVmYXVsdCA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG4gIHR5cGU6ICd0b29sYm94JyxcbiAgcmVuZGVyOiBmdW5jdGlvbiAodG9vbGJveE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKCF0b29sYm94TW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlbVNpemUgPSArdG9vbGJveE1vZGVsLmdldCgnaXRlbVNpemUnKTtcbiAgICB2YXIgZmVhdHVyZU9wdHMgPSB0b29sYm94TW9kZWwuZ2V0KCdmZWF0dXJlJykgfHwge307XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5fZmVhdHVyZXMgfHwgKHRoaXMuX2ZlYXR1cmVzID0ge30pO1xuICAgIHZhciBmZWF0dXJlTmFtZXMgPSBbXTtcbiAgICB6clV0aWwuZWFjaChmZWF0dXJlT3B0cywgZnVuY3Rpb24gKG9wdCwgbmFtZSkge1xuICAgICAgZmVhdHVyZU5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgbmV3IERhdGFEaWZmZXIodGhpcy5fZmVhdHVyZU5hbWVzIHx8IFtdLCBmZWF0dXJlTmFtZXMpLmFkZChwcm9jZXNzRmVhdHVyZSkudXBkYXRlKHByb2Nlc3NGZWF0dXJlKS5yZW1vdmUoenJVdGlsLmN1cnJ5KHByb2Nlc3NGZWF0dXJlLCBudWxsKSkuZXhlY3V0ZSgpOyAvLyBLZWVwIGZvciBkaWZmLlxuXG4gICAgdGhpcy5fZmVhdHVyZU5hbWVzID0gZmVhdHVyZU5hbWVzO1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0ZlYXR1cmUobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICB2YXIgZmVhdHVyZU5hbWUgPSBmZWF0dXJlTmFtZXNbbmV3SW5kZXhdO1xuICAgICAgdmFyIG9sZE5hbWUgPSBmZWF0dXJlTmFtZXNbb2xkSW5kZXhdO1xuICAgICAgdmFyIGZlYXR1cmVPcHQgPSBmZWF0dXJlT3B0c1tmZWF0dXJlTmFtZV07XG4gICAgICB2YXIgZmVhdHVyZU1vZGVsID0gbmV3IE1vZGVsKGZlYXR1cmVPcHQsIHRvb2xib3hNb2RlbCwgdG9vbGJveE1vZGVsLmVjTW9kZWwpO1xuICAgICAgdmFyIGZlYXR1cmU7XG5cbiAgICAgIGlmIChmZWF0dXJlTmFtZSAmJiAhb2xkTmFtZSkge1xuICAgICAgICAvLyBDcmVhdGVcbiAgICAgICAgaWYgKGlzVXNlckZlYXR1cmVOYW1lKGZlYXR1cmVOYW1lKSkge1xuICAgICAgICAgIGZlYXR1cmUgPSB7XG4gICAgICAgICAgICBtb2RlbDogZmVhdHVyZU1vZGVsLFxuICAgICAgICAgICAgb25jbGljazogZmVhdHVyZU1vZGVsLm9wdGlvbi5vbmNsaWNrLFxuICAgICAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgRmVhdHVyZSA9IGZlYXR1cmVNYW5hZ2VyLmdldChmZWF0dXJlTmFtZSk7XG5cbiAgICAgICAgICBpZiAoIUZlYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmZWF0dXJlID0gbmV3IEZlYXR1cmUoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmVhdHVyZXNbZmVhdHVyZU5hbWVdID0gZmVhdHVyZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZlYXR1cmUgPSBmZWF0dXJlc1tvbGROYW1lXTsgLy8gSWYgZmVhdHVyZSBkb2VzIG5vdCBleHNpdC5cblxuICAgICAgICBpZiAoIWZlYXR1cmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmZWF0dXJlLm1vZGVsID0gZmVhdHVyZU1vZGVsO1xuICAgICAgICBmZWF0dXJlLmVjTW9kZWwgPSBlY01vZGVsO1xuICAgICAgICBmZWF0dXJlLmFwaSA9IGFwaTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmZWF0dXJlTmFtZSAmJiBvbGROYW1lKSB7XG4gICAgICAgIGZlYXR1cmUuZGlzcG9zZSAmJiBmZWF0dXJlLmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZlYXR1cmVNb2RlbC5nZXQoJ3Nob3cnKSB8fCBmZWF0dXJlLnVudXNhYmxlKSB7XG4gICAgICAgIGZlYXR1cmUucmVtb3ZlICYmIGZlYXR1cmUucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3JlYXRlSWNvblBhdGhzKGZlYXR1cmVNb2RlbCwgZmVhdHVyZSwgZmVhdHVyZU5hbWUpO1xuXG4gICAgICBmZWF0dXJlTW9kZWwuc2V0SWNvblN0YXR1cyA9IGZ1bmN0aW9uIChpY29uTmFtZSwgc3RhdHVzKSB7XG4gICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgdmFyIGljb25QYXRocyA9IHRoaXMuaWNvblBhdGhzO1xuICAgICAgICBvcHRpb24uaWNvblN0YXR1cyA9IG9wdGlvbi5pY29uU3RhdHVzIHx8IHt9O1xuICAgICAgICBvcHRpb24uaWNvblN0YXR1c1tpY29uTmFtZV0gPSBzdGF0dXM7IC8vIEZJWE1FXG5cbiAgICAgICAgaWNvblBhdGhzW2ljb25OYW1lXSAmJiBpY29uUGF0aHNbaWNvbk5hbWVdLnRyaWdnZXIoc3RhdHVzKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChmZWF0dXJlLnJlbmRlcikge1xuICAgICAgICBmZWF0dXJlLnJlbmRlcihmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSWNvblBhdGhzKGZlYXR1cmVNb2RlbCwgZmVhdHVyZSwgZmVhdHVyZU5hbWUpIHtcbiAgICAgIHZhciBpY29uU3R5bGVNb2RlbCA9IGZlYXR1cmVNb2RlbC5nZXRNb2RlbCgnaWNvblN0eWxlJyk7IC8vIElmIG9uZSBmZWF0dXJlIGhhcyBtdXRpcGxlIGljb24uIHRoZXkgYXJlIG9yZ2luYWl6ZWQgYXNcbiAgICAgIC8vIHtcbiAgICAgIC8vICAgICBpY29uOiB7XG4gICAgICAvLyAgICAgICAgIGZvbzogJycsXG4gICAgICAvLyAgICAgICAgIGJhcjogJydcbiAgICAgIC8vICAgICB9LFxuICAgICAgLy8gICAgIHRpdGxlOiB7XG4gICAgICAvLyAgICAgICAgIGZvbzogJycsXG4gICAgICAvLyAgICAgICAgIGJhcjogJydcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyB9XG5cbiAgICAgIHZhciBpY29ucyA9IGZlYXR1cmUuZ2V0SWNvbnMgPyBmZWF0dXJlLmdldEljb25zKCkgOiBmZWF0dXJlTW9kZWwuZ2V0KCdpY29uJyk7XG4gICAgICB2YXIgdGl0bGVzID0gZmVhdHVyZU1vZGVsLmdldCgndGl0bGUnKSB8fCB7fTtcblxuICAgICAgaWYgKHR5cGVvZiBpY29ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGljb24gPSBpY29ucztcbiAgICAgICAgdmFyIHRpdGxlID0gdGl0bGVzO1xuICAgICAgICBpY29ucyA9IHt9O1xuICAgICAgICB0aXRsZXMgPSB7fTtcbiAgICAgICAgaWNvbnNbZmVhdHVyZU5hbWVdID0gaWNvbjtcbiAgICAgICAgdGl0bGVzW2ZlYXR1cmVOYW1lXSA9IHRpdGxlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWNvblBhdGhzID0gZmVhdHVyZU1vZGVsLmljb25QYXRocyA9IHt9O1xuICAgICAgenJVdGlsLmVhY2goaWNvbnMsIGZ1bmN0aW9uIChpY29uU3RyLCBpY29uTmFtZSkge1xuICAgICAgICB2YXIgcGF0aCA9IGdyYXBoaWMuY3JlYXRlSWNvbihpY29uU3RyLCB7fSwge1xuICAgICAgICAgIHg6IC1pdGVtU2l6ZSAvIDIsXG4gICAgICAgICAgeTogLWl0ZW1TaXplIC8gMixcbiAgICAgICAgICB3aWR0aDogaXRlbVNpemUsXG4gICAgICAgICAgaGVpZ2h0OiBpdGVtU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgcGF0aC5zZXRTdHlsZShpY29uU3R5bGVNb2RlbC5nZXRNb2RlbCgnbm9ybWFsJykuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgICBwYXRoLmhvdmVyU3R5bGUgPSBpY29uU3R5bGVNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHBhdGgpO1xuXG4gICAgICAgIGlmICh0b29sYm94TW9kZWwuZ2V0KCdzaG93VGl0bGUnKSkge1xuICAgICAgICAgIHBhdGguX190aXRsZSA9IHRpdGxlc1tpY29uTmFtZV07XG4gICAgICAgICAgcGF0aC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCByZXVzZSBhYm92ZSBob3ZlclN0eWxlLCB3aGljaCBtaWdodCBiZSBtb2RpZmllZC5cbiAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gaWNvblN0eWxlTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICAgICAgICBwYXRoLnNldFN0eWxlKHtcbiAgICAgICAgICAgICAgdGV4dDogdGl0bGVzW2ljb25OYW1lXSxcbiAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiBob3ZlclN0eWxlLnRleHRQb3NpdGlvbiB8fCAnYm90dG9tJyxcbiAgICAgICAgICAgICAgdGV4dEZpbGw6IGhvdmVyU3R5bGUuZmlsbCB8fCBob3ZlclN0eWxlLnN0cm9rZSB8fCAnIzAwMCcsXG4gICAgICAgICAgICAgIHRleHRBbGlnbjogaG92ZXJTdHlsZS50ZXh0QWxpZ24gfHwgJ2NlbnRlcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBhdGguc2V0U3R5bGUoe1xuICAgICAgICAgICAgICB0ZXh0RmlsbDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLnRyaWdnZXIoZmVhdHVyZU1vZGVsLmdldCgnaWNvblN0YXR1cy4nICsgaWNvbk5hbWUpIHx8ICdub3JtYWwnKTtcbiAgICAgICAgZ3JvdXAuYWRkKHBhdGgpO1xuICAgICAgICBwYXRoLm9uKCdjbGljaycsIHpyVXRpbC5iaW5kKGZlYXR1cmUub25jbGljaywgZmVhdHVyZSwgZWNNb2RlbCwgYXBpLCBpY29uTmFtZSkpO1xuICAgICAgICBpY29uUGF0aHNbaWNvbk5hbWVdID0gcGF0aDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxpc3RDb21wb25lbnRIZWxwZXIubGF5b3V0KGdyb3VwLCB0b29sYm94TW9kZWwsIGFwaSk7IC8vIFJlbmRlciBiYWNrZ3JvdW5kIGFmdGVyIGdyb3VwIGlzIGxheW91dFxuICAgIC8vIEZJWE1FXG5cbiAgICBncm91cC5hZGQobGlzdENvbXBvbmVudEhlbHBlci5tYWtlQmFja2dyb3VuZChncm91cC5nZXRCb3VuZGluZ1JlY3QoKSwgdG9vbGJveE1vZGVsKSk7IC8vIEFkanVzdCBpY29uIHRpdGxlIHBvc2l0aW9ucyB0byBhdm9pZCB0aGVtIG91dCBvZiBzY3JlZW5cblxuICAgIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoaWNvbikge1xuICAgICAgdmFyIHRpdGxlVGV4dCA9IGljb24uX190aXRsZTtcbiAgICAgIHZhciBob3ZlclN0eWxlID0gaWNvbi5ob3ZlclN0eWxlOyAvLyBNYXkgYmUgYmFja2dyb3VuZCBlbGVtZW50XG5cbiAgICAgIGlmIChob3ZlclN0eWxlICYmIHRpdGxlVGV4dCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0aXRsZVRleHQsIHRleHRDb250YWluLm1ha2VGb250KGhvdmVyU3R5bGUpKTtcbiAgICAgICAgdmFyIG9mZnNldFggPSBpY29uLnBvc2l0aW9uWzBdICsgZ3JvdXAucG9zaXRpb25bMF07XG4gICAgICAgIHZhciBvZmZzZXRZID0gaWNvbi5wb3NpdGlvblsxXSArIGdyb3VwLnBvc2l0aW9uWzFdICsgaXRlbVNpemU7XG4gICAgICAgIHZhciBuZWVkUHV0T25Ub3AgPSBmYWxzZTtcblxuICAgICAgICBpZiAob2Zmc2V0WSArIHJlY3QuaGVpZ2h0ID4gYXBpLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgaG92ZXJTdHlsZS50ZXh0UG9zaXRpb24gPSAndG9wJztcbiAgICAgICAgICBuZWVkUHV0T25Ub3AgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvcE9mZnNldCA9IG5lZWRQdXRPblRvcCA/IC01IC0gcmVjdC5oZWlnaHQgOiBpdGVtU2l6ZSArIDg7XG5cbiAgICAgICAgaWYgKG9mZnNldFggKyByZWN0LndpZHRoIC8gMiA+IGFwaS5nZXRXaWR0aCgpKSB7XG4gICAgICAgICAgaG92ZXJTdHlsZS50ZXh0UG9zaXRpb24gPSBbJzEwMCUnLCB0b3BPZmZzZXRdO1xuICAgICAgICAgIGhvdmVyU3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXRYIC0gcmVjdC53aWR0aCAvIDIgPCAwKSB7XG4gICAgICAgICAgaG92ZXJTdHlsZS50ZXh0UG9zaXRpb24gPSBbMCwgdG9wT2Zmc2V0XTtcbiAgICAgICAgICBob3ZlclN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICB1cGRhdGVWaWV3OiBmdW5jdGlvbiAodG9vbGJveE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB6clV0aWwuZWFjaCh0aGlzLl9mZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgIGZlYXR1cmUudXBkYXRlVmlldyAmJiBmZWF0dXJlLnVwZGF0ZVZpZXcoZmVhdHVyZS5tb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAodG9vbGJveE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB6clV0aWwuZWFjaCh0aGlzLl9mZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgIGZlYXR1cmUudXBkYXRlTGF5b3V0ICYmIGZlYXR1cmUudXBkYXRlTGF5b3V0KGZlYXR1cmUubW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgZmVhdHVyZS5yZW1vdmUgJiYgZmVhdHVyZS5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgICB9KTtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICB9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICBmZWF0dXJlLmRpc3Bvc2UgJiYgZmVhdHVyZS5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBpc1VzZXJGZWF0dXJlTmFtZShmZWF0dXJlTmFtZSkge1xuICByZXR1cm4gZmVhdHVyZU5hbWUuaW5kZXhPZignbXknKSA9PT0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9Ub29sYm94Vmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveFZpZXcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9sYW5nXCIpO1xuXG52YXIgZmVhdHVyZU1hbmFnZXIgPSByZXF1aXJlKFwiLi4vZmVhdHVyZU1hbmFnZXJcIik7XG5cbnZhciBkYXRhVmlld0xhbmcgPSBsYW5nLnRvb2xib3guZGF0YVZpZXc7XG52YXIgQkxPQ0tfU1BMSVRFUiA9IG5ldyBBcnJheSg2MCkuam9pbignLScpO1xudmFyIElURU1fU1BMSVRFUiA9ICdcXHQnO1xuLyoqXG4gKiBHcm91cCBzZXJpZXMgaW50byB0d28gdHlwZXNcbiAqICAxLiBvbiBjYXRlZ29yeSBheGlzLCBsaWtlIGxpbmUsIGJhclxuICogIDIuIG90aGVycywgbGlrZSBzY2F0dGVyLCBwaWVcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAaW5uZXJcbiAqL1xuXG5mdW5jdGlvbiBncm91cFNlcmllcyhlY01vZGVsKSB7XG4gIHZhciBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzID0ge307XG4gIHZhciBvdGhlclNlcmllcyA9IFtdO1xuICB2YXIgbWV0YSA9IFtdO1xuICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgIGlmIChjb29yZFN5cyAmJiAoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJyB8fCBjb29yZFN5cy50eXBlID09PSAncG9sYXInKSkge1xuICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcblxuICAgICAgaWYgKGJhc2VBeGlzLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgdmFyIGtleSA9IGJhc2VBeGlzLmRpbSArICdfJyArIGJhc2VBeGlzLmluZGV4O1xuXG4gICAgICAgIGlmICghc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpc1trZXldKSB7XG4gICAgICAgICAgc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpc1trZXldID0ge1xuICAgICAgICAgICAgY2F0ZWdvcnlBeGlzOiBiYXNlQXhpcyxcbiAgICAgICAgICAgIHZhbHVlQXhpczogY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKSxcbiAgICAgICAgICAgIHNlcmllczogW11cbiAgICAgICAgICB9O1xuICAgICAgICAgIG1ldGEucHVzaCh7XG4gICAgICAgICAgICBheGlzRGltOiBiYXNlQXhpcy5kaW0sXG4gICAgICAgICAgICBheGlzSW5kZXg6IGJhc2VBeGlzLmluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzW2tleV0uc2VyaWVzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3RoZXJTZXJpZXMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyU2VyaWVzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpczogc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpcyxcbiAgICBvdGhlcjogb3RoZXJTZXJpZXMsXG4gICAgbWV0YTogbWV0YVxuICB9O1xufVxuLyoqXG4gKiBBc3NlbWJsZSBjb250ZW50IG9mIHNlcmllcyBvbiBjYXRlb2dvcnkgYXhpc1xuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn0gc2VyaWVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VtYmxlU2VyaWVzV2l0aENhdGVnb3J5QXhpcyhzZXJpZXMpIHtcbiAgdmFyIHRhYmxlcyA9IFtdO1xuICB6clV0aWwuZWFjaChzZXJpZXMsIGZ1bmN0aW9uIChncm91cCwga2V5KSB7XG4gICAgdmFyIGNhdGVnb3J5QXhpcyA9IGdyb3VwLmNhdGVnb3J5QXhpcztcbiAgICB2YXIgdmFsdWVBeGlzID0gZ3JvdXAudmFsdWVBeGlzO1xuICAgIHZhciB2YWx1ZUF4aXNEaW0gPSB2YWx1ZUF4aXMuZGltO1xuICAgIHZhciBoZWFkZXJzID0gWycgJ10uY29uY2F0KHpyVXRpbC5tYXAoZ3JvdXAuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICByZXR1cm4gc2VyaWVzLm5hbWU7XG4gICAgfSkpO1xuICAgIHZhciBjb2x1bW5zID0gW2NhdGVnb3J5QXhpcy5tb2RlbC5nZXRDYXRlZ29yaWVzKCldO1xuICAgIHpyVXRpbC5lYWNoKGdyb3VwLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgY29sdW1ucy5wdXNoKHNlcmllcy5nZXRSYXdEYXRhKCkubWFwQXJyYXkodmFsdWVBeGlzRGltLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9KSk7XG4gICAgfSk7IC8vIEFzc2VtYmxlIHRhYmxlIGNvbnRlbnRcblxuICAgIHZhciBsaW5lcyA9IFtoZWFkZXJzLmpvaW4oSVRFTV9TUExJVEVSKV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnNbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaXRlbXMucHVzaChjb2x1bW5zW2pdW2ldKTtcbiAgICAgIH1cblxuICAgICAgbGluZXMucHVzaChpdGVtcy5qb2luKElURU1fU1BMSVRFUikpO1xuICAgIH1cblxuICAgIHRhYmxlcy5wdXNoKGxpbmVzLmpvaW4oJ1xcbicpKTtcbiAgfSk7XG4gIHJldHVybiB0YWJsZXMuam9pbignXFxuXFxuJyArIEJMT0NLX1NQTElURVIgKyAnXFxuXFxuJyk7XG59XG4vKipcbiAqIEFzc2VtYmxlIGNvbnRlbnQgb2Ygb3RoZXIgc2VyaWVzXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXM+fSBzZXJpZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gYXNzZW1ibGVPdGhlclNlcmllcyhzZXJpZXMpIHtcbiAgcmV0dXJuIHpyVXRpbC5tYXAoc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXMuZ2V0UmF3RGF0YSgpO1xuICAgIHZhciBsaW5lcyA9IFtzZXJpZXMubmFtZV07XG4gICAgdmFyIHZhbHMgPSBbXTtcbiAgICBkYXRhLmVhY2goZGF0YS5kaW1lbnNpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJnTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBkYXRhSW5kZXggPSBhcmd1bWVudHNbYXJnTGVuIC0gMV07XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ0xlbiAtIDE7IGkrKykge1xuICAgICAgICB2YWxzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBsaW5lcy5wdXNoKChuYW1lID8gbmFtZSArIElURU1fU1BMSVRFUiA6ICcnKSArIHZhbHMuam9pbihJVEVNX1NQTElURVIpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gIH0pLmpvaW4oJ1xcblxcbicgKyBCTE9DS19TUExJVEVSICsgJ1xcblxcbicpO1xufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29udGVudEZyb21Nb2RlbChlY01vZGVsKSB7XG4gIHZhciByZXN1bHQgPSBncm91cFNlcmllcyhlY01vZGVsKTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogenJVdGlsLmZpbHRlcihbYXNzZW1ibGVTZXJpZXNXaXRoQ2F0ZWdvcnlBeGlzKHJlc3VsdC5zZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzKSwgYXNzZW1ibGVPdGhlclNlcmllcyhyZXN1bHQub3RoZXIpXSwgZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxuXFx0XFxzXS9nLCAnJyk7XG4gICAgfSkuam9pbignXFxuXFxuJyArIEJMT0NLX1NQTElURVIgKyAnXFxuXFxuJyksXG4gICAgbWV0YTogcmVzdWx0Lm1ldGFcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbn1cbi8qKlxuICogSWYgYSBibG9jayBpcyB0c3YgZm9ybWF0XG4gKi9cblxuXG5mdW5jdGlvbiBpc1RTVkZvcm1hdChibG9jaykge1xuICAvLyBTaW1wbGUgbWV0aG9kIHRvIGZpbmQgb3V0IGlmIGEgYmxvY2sgaXMgdHN2IGZvcm1hdFxuICB2YXIgZmlyc3RMaW5lID0gYmxvY2suc2xpY2UoMCwgYmxvY2suaW5kZXhPZignXFxuJykpO1xuXG4gIGlmIChmaXJzdExpbmUuaW5kZXhPZihJVEVNX1NQTElURVIpID49IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG52YXIgaXRlbVNwbGl0UmVnZXggPSBuZXcgUmVnRXhwKCdbJyArIElURU1fU1BMSVRFUiArICddKycsICdnJyk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0c3ZcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVRTVkNvbnRlbnRzKHRzdikge1xuICB2YXIgdHN2TGluZXMgPSB0c3Yuc3BsaXQoL1xcbisvZyk7XG4gIHZhciBoZWFkZXJzID0gdHJpbSh0c3ZMaW5lcy5zaGlmdCgpKS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG4gIHZhciBjYXRlZ29yaWVzID0gW107XG4gIHZhciBzZXJpZXMgPSB6clV0aWwubWFwKGhlYWRlcnMsIGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogaGVhZGVyLFxuICAgICAgZGF0YTogW11cbiAgICB9O1xuICB9KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRzdkxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW1zID0gdHJpbSh0c3ZMaW5lc1tpXSkuc3BsaXQoaXRlbVNwbGl0UmVnZXgpO1xuICAgIGNhdGVnb3JpZXMucHVzaChpdGVtcy5zaGlmdCgpKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHNlcmllc1tqXSAmJiAoc2VyaWVzW2pdLmRhdGFbaV0gPSBpdGVtc1tqXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZXJpZXM6IHNlcmllcyxcbiAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzXG4gIH07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fVxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUxpc3RDb250ZW50cyhzdHIpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXG4rL2cpO1xuICB2YXIgc2VyaWVzTmFtZSA9IHRyaW0obGluZXMuc2hpZnQoKSk7XG4gIHZhciBkYXRhID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtcyA9IHRyaW0obGluZXNbaV0pLnNwbGl0KGl0ZW1TcGxpdFJlZ2V4KTtcbiAgICB2YXIgbmFtZSA9ICcnO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgaGFzTmFtZSA9IGZhbHNlO1xuXG4gICAgaWYgKGlzTmFOKGl0ZW1zWzBdKSkge1xuICAgICAgLy8gRmlyc3QgaXRlbSBpcyBuYW1lXG4gICAgICBoYXNOYW1lID0gdHJ1ZTtcbiAgICAgIG5hbWUgPSBpdGVtc1swXTtcbiAgICAgIGl0ZW1zID0gaXRlbXMuc2xpY2UoMSk7XG4gICAgICBkYXRhW2ldID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogW11cbiAgICAgIH07XG4gICAgICB2YWx1ZSA9IGRhdGFbaV0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gZGF0YVtpXSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhbHVlLnB1c2goK2l0ZW1zW2pdKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBoYXNOYW1lID8gZGF0YVtpXS52YWx1ZSA9IHZhbHVlWzBdIDogZGF0YVtpXSA9IHZhbHVlWzBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogc2VyaWVzTmFtZSxcbiAgICBkYXRhOiBkYXRhXG4gIH07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGJsb2NrTWV0YUxpc3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VDb250ZW50cyhzdHIsIGJsb2NrTWV0YUxpc3QpIHtcbiAgdmFyIGJsb2NrcyA9IHN0ci5zcGxpdChuZXcgUmVnRXhwKCdcXG4qJyArIEJMT0NLX1NQTElURVIgKyAnXFxuKicsICdnJykpO1xuICB2YXIgbmV3T3B0aW9uID0ge1xuICAgIHNlcmllczogW11cbiAgfTtcbiAgenJVdGlsLmVhY2goYmxvY2tzLCBmdW5jdGlvbiAoYmxvY2ssIGlkeCkge1xuICAgIGlmIChpc1RTVkZvcm1hdChibG9jaykpIHtcbiAgICAgIHZhciByZXN1bHQgPSBwYXJzZVRTVkNvbnRlbnRzKGJsb2NrKTtcbiAgICAgIHZhciBibG9ja01ldGEgPSBibG9ja01ldGFMaXN0W2lkeF07XG4gICAgICB2YXIgYXhpc0tleSA9IGJsb2NrTWV0YS5heGlzRGltICsgJ0F4aXMnO1xuXG4gICAgICBpZiAoYmxvY2tNZXRhKSB7XG4gICAgICAgIG5ld09wdGlvbltheGlzS2V5XSA9IG5ld09wdGlvbltheGlzS2V5XSB8fCBbXTtcbiAgICAgICAgbmV3T3B0aW9uW2F4aXNLZXldW2Jsb2NrTWV0YS5heGlzSW5kZXhdID0ge1xuICAgICAgICAgIGRhdGE6IHJlc3VsdC5jYXRlZ29yaWVzXG4gICAgICAgIH07XG4gICAgICAgIG5ld09wdGlvbi5zZXJpZXMgPSBuZXdPcHRpb24uc2VyaWVzLmNvbmNhdChyZXN1bHQuc2VyaWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGlzdENvbnRlbnRzKGJsb2NrKTtcbiAgICAgIG5ld09wdGlvbi5zZXJpZXMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdPcHRpb247XG59XG4vKipcbiAqIEBhbGlhcyB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhVmlld31cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcbiAqL1xuXG5cbmZ1bmN0aW9uIERhdGFWaWV3KG1vZGVsKSB7XG4gIHRoaXMuX2RvbSA9IG51bGw7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbn1cblxuRGF0YVZpZXcuZGVmYXVsdE9wdGlvbiA9IHtcbiAgc2hvdzogdHJ1ZSxcbiAgcmVhZE9ubHk6IGZhbHNlLFxuICBvcHRpb25Ub0NvbnRlbnQ6IG51bGwsXG4gIGNvbnRlbnRUb09wdGlvbjogbnVsbCxcbiAgaWNvbjogJ00xNy41LDE3LjNIMzMgTTE3LjUsMTcuM0gzMyBNNDUuNCwyOS41aC0yOCBNMTEuNSwydjU2SDUxVjE0LjhMMzguNCwySDExLjV6IE0zOC40LDIuMnYxMi43SDUxIE00NS40LDQxLjdoLTI4JyxcbiAgdGl0bGU6IHpyVXRpbC5jbG9uZShkYXRhVmlld0xhbmcudGl0bGUpLFxuICBsYW5nOiB6clV0aWwuY2xvbmUoZGF0YVZpZXdMYW5nLmxhbmcpLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJyxcbiAgdGV4dENvbG9yOiAnIzAwMCcsXG4gIHRleHRhcmVhQ29sb3I6ICcjZmZmJyxcbiAgdGV4dGFyZWFCb3JkZXJDb2xvcjogJyMzMzMnLFxuICBidXR0b25Db2xvcjogJyNjMjM1MzEnLFxuICBidXR0b25UZXh0Q29sb3I6ICcjZmZmJ1xufTtcblxuRGF0YVZpZXcucHJvdG90eXBlLm9uY2xpY2sgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBjb250YWluZXIgPSBhcGkuZ2V0RG9tKCk7XG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG5cbiAgaWYgKHRoaXMuX2RvbSkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9kb20pO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcm9vdC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6NXB4O3RvcDo1cHg7Ym90dG9tOjVweDtyaWdodDo1cHg7JztcbiAgcm9vdC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBtb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpIHx8ICcjZmZmJzsgLy8gQ3JlYXRlIGVsZW1lbnRzXG5cbiAgdmFyIGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2g0Jyk7XG4gIHZhciBsYW5nID0gbW9kZWwuZ2V0KCdsYW5nJykgfHwgW107XG4gIGhlYWRlci5pbm5lckhUTUwgPSBsYW5nWzBdIHx8IG1vZGVsLmdldCgndGl0bGUnKTtcbiAgaGVhZGVyLnN0eWxlLmNzc1RleHQgPSAnbWFyZ2luOiAxMHB4IDIwcHg7JztcbiAgaGVhZGVyLnN0eWxlLmNvbG9yID0gbW9kZWwuZ2V0KCd0ZXh0Q29sb3InKTtcbiAgdmFyIHZpZXdNYWluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gIHZpZXdNYWluLnN0eWxlLmNzc1RleHQgPSAnZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO292ZXJmbG93OmF1dG87JztcbiAgdmFyIG9wdGlvblRvQ29udGVudCA9IG1vZGVsLmdldCgnb3B0aW9uVG9Db250ZW50Jyk7XG4gIHZhciBjb250ZW50VG9PcHRpb24gPSBtb2RlbC5nZXQoJ2NvbnRlbnRUb09wdGlvbicpO1xuICB2YXIgcmVzdWx0ID0gZ2V0Q29udGVudEZyb21Nb2RlbChlY01vZGVsKTtcblxuICBpZiAodHlwZW9mIG9wdGlvblRvQ29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBodG1sT3JEb20gPSBvcHRpb25Ub0NvbnRlbnQoYXBpLmdldE9wdGlvbigpKTtcblxuICAgIGlmICh0eXBlb2YgaHRtbE9yRG9tID09PSAnc3RyaW5nJykge1xuICAgICAgdmlld01haW4uaW5uZXJIVE1MID0gaHRtbE9yRG9tO1xuICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzRG9tKGh0bWxPckRvbSkpIHtcbiAgICAgIHZpZXdNYWluLmFwcGVuZENoaWxkKGh0bWxPckRvbSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFVzZSBkZWZhdWx0IHRleHRhcmVhXG4gICAgdmlld01haW4uYXBwZW5kQ2hpbGQodGV4dGFyZWEpO1xuICAgIHRleHRhcmVhLnJlYWRPbmx5ID0gbW9kZWwuZ2V0KCdyZWFkT25seScpO1xuICAgIHRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSAnd2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtmb250LWZhbWlseTptb25vc3BhY2U7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS42cmVtOyc7XG4gICAgdGV4dGFyZWEuc3R5bGUuY29sb3IgPSBtb2RlbC5nZXQoJ3RleHRDb2xvcicpO1xuICAgIHRleHRhcmVhLnN0eWxlLmJvcmRlckNvbG9yID0gbW9kZWwuZ2V0KCd0ZXh0YXJlYUJvcmRlckNvbG9yJyk7XG4gICAgdGV4dGFyZWEuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbW9kZWwuZ2V0KCd0ZXh0YXJlYUNvbG9yJyk7XG4gICAgdGV4dGFyZWEudmFsdWUgPSByZXN1bHQudmFsdWU7XG4gIH1cblxuICB2YXIgYmxvY2tNZXRhTGlzdCA9IHJlc3VsdC5tZXRhO1xuICB2YXIgYnV0dG9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJ1dHRvbkNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO2xlZnQ6MDtyaWdodDowOyc7XG4gIHZhciBidXR0b25TdHlsZSA9ICdmbG9hdDpyaWdodDttYXJnaW4tcmlnaHQ6MjBweDtib3JkZXI6bm9uZTsnICsgJ2N1cnNvcjpwb2ludGVyO3BhZGRpbmc6MnB4IDVweDtmb250LXNpemU6MTJweDtib3JkZXItcmFkaXVzOjNweCc7XG4gIHZhciBjbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgcmVmcmVzaEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBidXR0b25TdHlsZSArPSAnO2JhY2tncm91bmQtY29sb3I6JyArIG1vZGVsLmdldCgnYnV0dG9uQ29sb3InKTtcbiAgYnV0dG9uU3R5bGUgKz0gJztjb2xvcjonICsgbW9kZWwuZ2V0KCdidXR0b25UZXh0Q29sb3InKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290KTtcbiAgICBzZWxmLl9kb20gPSBudWxsO1xuICB9XG5cbiAgZXZlbnRUb29sLmFkZEV2ZW50TGlzdGVuZXIoY2xvc2VCdXR0b24sICdjbGljaycsIGNsb3NlKTtcbiAgZXZlbnRUb29sLmFkZEV2ZW50TGlzdGVuZXIocmVmcmVzaEJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdPcHRpb247XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBjb250ZW50VG9PcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbmV3T3B0aW9uID0gY29udGVudFRvT3B0aW9uKHZpZXdNYWluLCBhcGkuZ2V0T3B0aW9uKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3T3B0aW9uID0gcGFyc2VDb250ZW50cyh0ZXh0YXJlYS52YWx1ZSwgYmxvY2tNZXRhTGlzdCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2xvc2UoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSB2aWV3IGZvcm1hdCBlcnJvciAnICsgZSk7XG4gICAgfVxuXG4gICAgaWYgKG5ld09wdGlvbikge1xuICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ2NoYW5nZURhdGFWaWV3JyxcbiAgICAgICAgbmV3T3B0aW9uOiBuZXdPcHRpb25cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsb3NlKCk7XG4gIH0pO1xuICBjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSBsYW5nWzFdO1xuICByZWZyZXNoQnV0dG9uLmlubmVySFRNTCA9IGxhbmdbMl07XG4gIHJlZnJlc2hCdXR0b24uc3R5bGUuY3NzVGV4dCA9IGJ1dHRvblN0eWxlO1xuICBjbG9zZUJ1dHRvbi5zdHlsZS5jc3NUZXh0ID0gYnV0dG9uU3R5bGU7XG4gICFtb2RlbC5nZXQoJ3JlYWRPbmx5JykgJiYgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlZnJlc2hCdXR0b24pO1xuICBidXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b24pOyAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY2MzczNDEvdXNlLXRhYi10by1pbmRlbnQtaW4tdGV4dGFyZWFcblxuICBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcih0ZXh0YXJlYSwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmICgoZS5rZXlDb2RlIHx8IGUud2hpY2gpID09PSA5KSB7XG4gICAgICAvLyBnZXQgY2FyZXQgcG9zaXRpb24vc2VsZWN0aW9uXG4gICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZTtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB2YXIgZW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7IC8vIHNldCB0ZXh0YXJlYSB2YWx1ZSB0bzogdGV4dCBiZWZvcmUgY2FyZXQgKyB0YWIgKyB0ZXh0IGFmdGVyIGNhcmV0XG5cbiAgICAgIHRoaXMudmFsdWUgPSB2YWwuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIElURU1fU1BMSVRFUiArIHZhbC5zdWJzdHJpbmcoZW5kKTsgLy8gcHV0IGNhcmV0IGF0IHJpZ2h0IHBvc2l0aW9uIGFnYWluXG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZCA9IHN0YXJ0ICsgMTsgLy8gcHJldmVudCB0aGUgZm9jdXMgbG9zZVxuXG4gICAgICBldmVudFRvb2wuc3RvcChlKTtcbiAgICB9XG4gIH0pO1xuICByb290LmFwcGVuZENoaWxkKGhlYWRlcik7XG4gIHJvb3QuYXBwZW5kQ2hpbGQodmlld01haW4pO1xuICByb290LmFwcGVuZENoaWxkKGJ1dHRvbkNvbnRhaW5lcik7XG4gIHZpZXdNYWluLnN0eWxlLmhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgLSA4MCArICdweCc7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyb290KTtcbiAgdGhpcy5fZG9tID0gcm9vdDtcbn07XG5cbkRhdGFWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gIHRoaXMuX2RvbSAmJiBhcGkuZ2V0RG9tKCkucmVtb3ZlQ2hpbGQodGhpcy5fZG9tKTtcbn07XG5cbkRhdGFWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICB0aGlzLnJlbW92ZShlY01vZGVsLCBhcGkpO1xufTtcbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiB0cnlNZXJnZURhdGFPcHRpb24obmV3RGF0YSwgb3JpZ2luYWxEYXRhKSB7XG4gIHJldHVybiB6clV0aWwubWFwKG5ld0RhdGEsIGZ1bmN0aW9uIChuZXdWYWwsIGlkeCkge1xuICAgIHZhciBvcmlnaW5hbCA9IG9yaWdpbmFsRGF0YSAmJiBvcmlnaW5hbERhdGFbaWR4XTtcblxuICAgIGlmICh6clV0aWwuaXNPYmplY3Qob3JpZ2luYWwpICYmICF6clV0aWwuaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICAgIGlmICh6clV0aWwuaXNPYmplY3QobmV3VmFsKSAmJiAhenJVdGlsLmlzQXJyYXkobmV3VmFsKSkge1xuICAgICAgICBuZXdWYWwgPSBuZXdWYWwudmFsdWU7XG4gICAgICB9IC8vIE9yaWdpbmFsIGRhdGEgaGFzIG9wdGlvblxuXG5cbiAgICAgIHJldHVybiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICB2YWx1ZTogbmV3VmFsXG4gICAgICB9LCBvcmlnaW5hbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXdWYWw7XG4gICAgfVxuICB9KTtcbn1cblxuZmVhdHVyZU1hbmFnZXIucmVnaXN0ZXIoJ2RhdGFWaWV3JywgRGF0YVZpZXcpO1xuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICdjaGFuZ2VEYXRhVmlldycsXG4gIGV2ZW50OiAnZGF0YVZpZXdDaGFuZ2VkJyxcbiAgdXBkYXRlOiAncHJlcGFyZUFuZFVwZGF0ZSdcbn0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gIHZhciBuZXdTZXJpZXNPcHRMaXN0ID0gW107XG4gIHpyVXRpbC5lYWNoKHBheWxvYWQubmV3T3B0aW9uLnNlcmllcywgZnVuY3Rpb24gKHNlcmllc09wdCkge1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlOYW1lKHNlcmllc09wdC5uYW1lKVswXTtcblxuICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgIC8vIE5ldyBjcmVhdGVkIHNlcmllc1xuICAgICAgLy8gR2V1c3MgdGhlIHNlcmllcyB0eXBlXG4gICAgICBuZXdTZXJpZXNPcHRMaXN0LnB1c2goenJVdGlsLmV4dGVuZCh7XG4gICAgICAgIC8vIERlZmF1bHQgaXMgc2NhdHRlclxuICAgICAgICB0eXBlOiAnc2NhdHRlcidcbiAgICAgIH0sIHNlcmllc09wdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3JpZ2luYWxEYXRhID0gc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJyk7XG4gICAgICBuZXdTZXJpZXNPcHRMaXN0LnB1c2goe1xuICAgICAgICBuYW1lOiBzZXJpZXNPcHQubmFtZSxcbiAgICAgICAgZGF0YTogdHJ5TWVyZ2VEYXRhT3B0aW9uKHNlcmllc09wdC5kYXRhLCBvcmlnaW5hbERhdGEpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBlY01vZGVsLm1lcmdlT3B0aW9uKHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgc2VyaWVzOiBuZXdTZXJpZXNPcHRMaXN0XG4gIH0sIHBheWxvYWQubmV3T3B0aW9uKSk7XG59KTtcbnZhciBfZGVmYXVsdCA9IERhdGFWaWV3O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL0RhdGFWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL0RhdGFWaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBCcnVzaENvbnRyb2xsZXIgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVyL0JydXNoQ29udHJvbGxlclwiKTtcblxudmFyIEJydXNoVGFyZ2V0TWFuYWdlciA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXIvQnJ1c2hUYXJnZXRNYW5hZ2VyXCIpO1xuXG52YXIgaGlzdG9yeSA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhWm9vbS9oaXN0b3J5XCIpO1xuXG52YXIgc2xpZGVyTW92ZSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXIvc2xpZGVyTW92ZVwiKTtcblxudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGFuZ1wiKTtcblxudmFyIGZlYXR1cmVNYW5hZ2VyID0gcmVxdWlyZShcIi4uL2ZlYXR1cmVNYW5hZ2VyXCIpO1xuXG5yZXF1aXJlKFwiLi4vLi4vZGF0YVpvb21TZWxlY3RcIik7XG5cbi8vIFVzZSBkYXRhWm9vbVNlbGVjdFxudmFyIGRhdGFab29tTGFuZyA9IGxhbmcudG9vbGJveC5kYXRhWm9vbTtcbnZhciBlYWNoID0genJVdGlsLmVhY2g7IC8vIFNwZWN0aWFsIGNvbXBvbmVudCBpZCBzdGFydCB3aXRoIFxcMGVjXFwwLCBzZWUgZWNoYXJ0cy9tb2RlbC9HbG9iYWwuanN+aGFzSW5uZXJJZFxuXG52YXIgREFUQV9aT09NX0lEX0JBU0UgPSAnXFwwX2VjX1xcMHRvb2xib3gtZGF0YVpvb21fJztcblxuZnVuY3Rpb24gRGF0YVpvb20obW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyfVxuICAgKi9cbiAgKHRoaXMuX2JydXNoQ29udHJvbGxlciA9IG5ldyBCcnVzaENvbnRyb2xsZXIoYXBpLmdldFpyKCkpKS5vbignYnJ1c2gnLCB6clV0aWwuYmluZCh0aGlzLl9vbkJydXNoLCB0aGlzKSkubW91bnQoKTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuICB0aGlzLl9pc1pvb21BY3RpdmU7XG59XG5cbkRhdGFab29tLmRlZmF1bHRPcHRpb24gPSB7XG4gIHNob3c6IHRydWUsXG4gIC8vIEljb24gZ3JvdXBcbiAgaWNvbjoge1xuICAgIHpvb206ICdNMCwxMy41aDI2LjkgTTEzLjUsMjYuOVYwIE0zMi4xLDEzLjVINThWNThIMTMuNSBWMzIuMScsXG4gICAgYmFjazogJ00yMiwxLjRMOS45LDEzLjVsMTIuMywxMi4zIE0xMC4zLDEzLjVINTQuOXY0NC42IEgxMC4zdi0yNidcbiAgfSxcbiAgLy8gYHpvb21gLCBgYmFja2BcbiAgdGl0bGU6IHpyVXRpbC5jbG9uZShkYXRhWm9vbUxhbmcudGl0bGUpXG59O1xudmFyIHByb3RvID0gRGF0YVpvb20ucHJvdG90eXBlO1xuXG5wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgdGhpcy5tb2RlbCA9IGZlYXR1cmVNb2RlbDtcbiAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgdGhpcy5hcGkgPSBhcGk7XG4gIHVwZGF0ZVpvb21CdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCB0aGlzLCBwYXlsb2FkLCBhcGkpO1xuICB1cGRhdGVCYWNrQnRuU3RhdHVzKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCk7XG59O1xuXG5wcm90by5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgdHlwZSkge1xuICBoYW5kbGVyc1t0eXBlXS5jYWxsKHRoaXMpO1xufTtcblxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICB0aGlzLl9icnVzaENvbnRyb2xsZXIudW5tb3VudCgpO1xufTtcblxucHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgdGhpcy5fYnJ1c2hDb250cm9sbGVyLmRpc3Bvc2UoKTtcbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgaGFuZGxlcnMgPSB7XG4gIHpvb206IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dEFjdGl2ZSA9ICF0aGlzLl9pc1pvb21BY3RpdmU7XG4gICAgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLFxuICAgICAga2V5OiAnZGF0YVpvb21TZWxlY3QnLFxuICAgICAgZGF0YVpvb21TZWxlY3RBY3RpdmU6IG5leHRBY3RpdmVcbiAgICB9KTtcbiAgfSxcbiAgYmFjazogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbihoaXN0b3J5LnBvcCh0aGlzLmVjTW9kZWwpKTtcbiAgfVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5wcm90by5fb25CcnVzaCA9IGZ1bmN0aW9uIChhcmVhcywgb3B0KSB7XG4gIGlmICghb3B0LmlzRW5kIHx8ICFhcmVhcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc25hcHNob3QgPSB7fTtcbiAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG5cbiAgdGhpcy5fYnJ1c2hDb250cm9sbGVyLnVwZGF0ZUNvdmVycyhbXSk7IC8vIHJlbW92ZSBjb3ZlclxuXG5cbiAgdmFyIGJydXNoVGFyZ2V0TWFuYWdlciA9IG5ldyBCcnVzaFRhcmdldE1hbmFnZXIocmV0cmlldmVBeGlzU2V0dGluZyh0aGlzLm1vZGVsLm9wdGlvbiksIGVjTW9kZWwsIHtcbiAgICBpbmNsdWRlOiBbJ2dyaWQnXVxuICB9KTtcbiAgYnJ1c2hUYXJnZXRNYW5hZ2VyLm1hdGNoT3V0cHV0UmFuZ2VzKGFyZWFzLCBlY01vZGVsLCBmdW5jdGlvbiAoYXJlYSwgY29vcmRSYW5nZSwgY29vcmRTeXMpIHtcbiAgICBpZiAoY29vcmRTeXMudHlwZSAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBicnVzaFR5cGUgPSBhcmVhLmJydXNoVHlwZTtcblxuICAgIGlmIChicnVzaFR5cGUgPT09ICdyZWN0Jykge1xuICAgICAgc2V0QmF0Y2goJ3gnLCBjb29yZFN5cywgY29vcmRSYW5nZVswXSk7XG4gICAgICBzZXRCYXRjaCgneScsIGNvb3JkU3lzLCBjb29yZFJhbmdlWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0QmF0Y2goe1xuICAgICAgICBsaW5lWDogJ3gnLFxuICAgICAgICBsaW5lWTogJ3knXG4gICAgICB9W2JydXNoVHlwZV0sIGNvb3JkU3lzLCBjb29yZFJhbmdlKTtcbiAgICB9XG4gIH0pO1xuICBoaXN0b3J5LnB1c2goZWNNb2RlbCwgc25hcHNob3QpO1xuXG4gIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbihzbmFwc2hvdCk7XG5cbiAgZnVuY3Rpb24gc2V0QmF0Y2goZGltTmFtZSwgY29vcmRTeXMsIG1pbk1heCkge1xuICAgIHZhciBheGlzID0gY29vcmRTeXMuZ2V0QXhpcyhkaW1OYW1lKTtcbiAgICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IGZpbmREYXRhWm9vbShkaW1OYW1lLCBheGlzTW9kZWwsIGVjTW9kZWwpOyAvLyBSZXN0cmljdCByYW5nZS5cblxuICAgIHZhciBtaW5NYXhTcGFuID0gZGF0YVpvb21Nb2RlbC5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoYXhpc01vZGVsKS5nZXRNaW5NYXhTcGFuKCk7XG5cbiAgICBpZiAobWluTWF4U3Bhbi5taW5WYWx1ZVNwYW4gIT0gbnVsbCB8fCBtaW5NYXhTcGFuLm1heFZhbHVlU3BhbiAhPSBudWxsKSB7XG4gICAgICBtaW5NYXggPSBzbGlkZXJNb3ZlKDAsIG1pbk1heC5zbGljZSgpLCBheGlzLnNjYWxlLmdldEV4dGVudCgpLCAwLCBtaW5NYXhTcGFuLm1pblZhbHVlU3BhbiwgbWluTWF4U3Bhbi5tYXhWYWx1ZVNwYW4pO1xuICAgIH1cblxuICAgIGRhdGFab29tTW9kZWwgJiYgKHNuYXBzaG90W2RhdGFab29tTW9kZWwuaWRdID0ge1xuICAgICAgZGF0YVpvb21JZDogZGF0YVpvb21Nb2RlbC5pZCxcbiAgICAgIHN0YXJ0VmFsdWU6IG1pbk1heFswXSxcbiAgICAgIGVuZFZhbHVlOiBtaW5NYXhbMV1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmREYXRhWm9vbShkaW1OYW1lLCBheGlzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgZm91bmQ7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnZGF0YVpvb20nLFxuICAgICAgc3ViVHlwZTogJ3NlbGVjdCdcbiAgICB9LCBmdW5jdGlvbiAoZHpNb2RlbCkge1xuICAgICAgdmFyIGhhcyA9IGR6TW9kZWwuZ2V0QXhpc01vZGVsKGRpbU5hbWUsIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgICBoYXMgJiYgKGZvdW5kID0gZHpNb2RlbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxucHJvdG8uX2Rpc3BhdGNoWm9vbUFjdGlvbiA9IGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICB2YXIgYmF0Y2ggPSBbXTsgLy8gQ29udmVydCBmcm9tIGhhc2ggbWFwIHRvIGFycmF5LlxuXG4gIGVhY2goc25hcHNob3QsIGZ1bmN0aW9uIChiYXRjaEl0ZW0sIGRhdGFab29tSWQpIHtcbiAgICBiYXRjaC5wdXNoKHpyVXRpbC5jbG9uZShiYXRjaEl0ZW0pKTtcbiAgfSk7XG4gIGJhdGNoLmxlbmd0aCAmJiB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgdHlwZTogJ2RhdGFab29tJyxcbiAgICBmcm9tOiB0aGlzLnVpZCxcbiAgICBiYXRjaDogYmF0Y2hcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiByZXRyaWV2ZUF4aXNTZXR0aW5nKG9wdGlvbikge1xuICB2YXIgc2V0dGluZyA9IHt9OyAvLyBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgc2V0dGluZzogbnVsbCA9PiBhbGwgYXhpcywgZmFsc2UgPT4gbm8gYXhpcy5cblxuICB6clV0aWwuZWFjaChbJ3hBeGlzSW5kZXgnLCAneUF4aXNJbmRleCddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHNldHRpbmdbbmFtZV0gPSBvcHRpb25bbmFtZV07XG4gICAgc2V0dGluZ1tuYW1lXSA9PSBudWxsICYmIChzZXR0aW5nW25hbWVdID0gJ2FsbCcpO1xuICAgIChzZXR0aW5nW25hbWVdID09PSBmYWxzZSB8fCBzZXR0aW5nW25hbWVdID09PSAnbm9uZScpICYmIChzZXR0aW5nW25hbWVdID0gW10pO1xuICB9KTtcbiAgcmV0dXJuIHNldHRpbmc7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUJhY2tCdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsKSB7XG4gIGZlYXR1cmVNb2RlbC5zZXRJY29uU3RhdHVzKCdiYWNrJywgaGlzdG9yeS5jb3VudChlY01vZGVsKSA+IDEgPyAnZW1waGFzaXMnIDogJ25vcm1hbCcpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVab29tQnRuU3RhdHVzKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgdmlldywgcGF5bG9hZCwgYXBpKSB7XG4gIHZhciB6b29tQWN0aXZlID0gdmlldy5faXNab29tQWN0aXZlO1xuXG4gIGlmIChwYXlsb2FkICYmIHBheWxvYWQudHlwZSA9PT0gJ3Rha2VHbG9iYWxDdXJzb3InKSB7XG4gICAgem9vbUFjdGl2ZSA9IHBheWxvYWQua2V5ID09PSAnZGF0YVpvb21TZWxlY3QnID8gcGF5bG9hZC5kYXRhWm9vbVNlbGVjdEFjdGl2ZSA6IGZhbHNlO1xuICB9XG5cbiAgdmlldy5faXNab29tQWN0aXZlID0gem9vbUFjdGl2ZTtcbiAgZmVhdHVyZU1vZGVsLnNldEljb25TdGF0dXMoJ3pvb20nLCB6b29tQWN0aXZlID8gJ2VtcGhhc2lzJyA6ICdub3JtYWwnKTtcbiAgdmFyIGJydXNoVGFyZ2V0TWFuYWdlciA9IG5ldyBCcnVzaFRhcmdldE1hbmFnZXIocmV0cmlldmVBeGlzU2V0dGluZyhmZWF0dXJlTW9kZWwub3B0aW9uKSwgZWNNb2RlbCwge1xuICAgIGluY2x1ZGU6IFsnZ3JpZCddXG4gIH0pO1xuXG4gIHZpZXcuX2JydXNoQ29udHJvbGxlci5zZXRQYW5lbHMoYnJ1c2hUYXJnZXRNYW5hZ2VyLm1ha2VQYW5lbE9wdHMoYXBpLCBmdW5jdGlvbiAodGFyZ2V0SW5mbykge1xuICAgIHJldHVybiB0YXJnZXRJbmZvLnhBeGlzRGVjbGFyZWQgJiYgIXRhcmdldEluZm8ueUF4aXNEZWNsYXJlZCA/ICdsaW5lWCcgOiAhdGFyZ2V0SW5mby54QXhpc0RlY2xhcmVkICYmIHRhcmdldEluZm8ueUF4aXNEZWNsYXJlZCA/ICdsaW5lWScgOiAncmVjdCc7XG4gIH0pKS5lbmFibGVCcnVzaCh6b29tQWN0aXZlID8ge1xuICAgIGJydXNoVHlwZTogJ2F1dG8nLFxuICAgIGJydXNoU3R5bGU6IHtcbiAgICAgIC8vIEZJWE1FIHVzZXIgY3VzdG9taXplZD9cbiAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgIGZpbGw6ICdyZ2JhKDAsMCwwLDAuMiknXG4gICAgfVxuICB9IDogZmFsc2UpO1xufVxuXG5mZWF0dXJlTWFuYWdlci5yZWdpc3RlcignZGF0YVpvb20nLCBEYXRhWm9vbSk7IC8vIENyZWF0ZSBzcGVjaWFsIGRhdGFab29tIG9wdGlvbiBmb3Igc2VsZWN0XG5cbmVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdGlvbikge1xuICBpZiAoIW9wdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhWm9vbU9wdHMgPSBvcHRpb24uZGF0YVpvb20gfHwgKG9wdGlvbi5kYXRhWm9vbSA9IFtdKTtcblxuICBpZiAoIXpyVXRpbC5pc0FycmF5KGRhdGFab29tT3B0cykpIHtcbiAgICBvcHRpb24uZGF0YVpvb20gPSBkYXRhWm9vbU9wdHMgPSBbZGF0YVpvb21PcHRzXTtcbiAgfVxuXG4gIHZhciB0b29sYm94T3B0ID0gb3B0aW9uLnRvb2xib3g7XG5cbiAgaWYgKHRvb2xib3hPcHQpIHtcbiAgICAvLyBBc3N1bWUgdGhlcmUgaXMgb25seSBvbmUgdG9vbGJveFxuICAgIGlmICh6clV0aWwuaXNBcnJheSh0b29sYm94T3B0KSkge1xuICAgICAgdG9vbGJveE9wdCA9IHRvb2xib3hPcHRbMF07XG4gICAgfVxuXG4gICAgaWYgKHRvb2xib3hPcHQgJiYgdG9vbGJveE9wdC5mZWF0dXJlKSB7XG4gICAgICB2YXIgZGF0YVpvb21PcHQgPSB0b29sYm94T3B0LmZlYXR1cmUuZGF0YVpvb207XG4gICAgICBhZGRGb3JBeGlzKCd4QXhpcycsIGRhdGFab29tT3B0KTtcbiAgICAgIGFkZEZvckF4aXMoJ3lBeGlzJywgZGF0YVpvb21PcHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEZvckF4aXMoYXhpc05hbWUsIGRhdGFab29tT3B0KSB7XG4gICAgaWYgKCFkYXRhWm9vbU9wdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVHJ5IG5vdCB0byBtb2RpZnkgbW9kZWwsIGJlY2F1c2UgaXQgaXMgbm90IG1lcmdlZCB5ZXQuXG5cblxuICAgIHZhciBheGlzSW5kaWNlc05hbWUgPSBheGlzTmFtZSArICdJbmRleCc7XG4gICAgdmFyIGdpdmVuQXhpc0luZGljZXMgPSBkYXRhWm9vbU9wdFtheGlzSW5kaWNlc05hbWVdO1xuXG4gICAgaWYgKGdpdmVuQXhpc0luZGljZXMgIT0gbnVsbCAmJiBnaXZlbkF4aXNJbmRpY2VzICE9ICdhbGwnICYmICF6clV0aWwuaXNBcnJheShnaXZlbkF4aXNJbmRpY2VzKSkge1xuICAgICAgZ2l2ZW5BeGlzSW5kaWNlcyA9IGdpdmVuQXhpc0luZGljZXMgPT09IGZhbHNlIHx8IGdpdmVuQXhpc0luZGljZXMgPT09ICdub25lJyA/IFtdIDogW2dpdmVuQXhpc0luZGljZXNdO1xuICAgIH1cblxuICAgIGZvckVhY2hDb21wb25lbnQoYXhpc05hbWUsIGZ1bmN0aW9uIChheGlzT3B0LCBheGlzSW5kZXgpIHtcbiAgICAgIGlmIChnaXZlbkF4aXNJbmRpY2VzICE9IG51bGwgJiYgZ2l2ZW5BeGlzSW5kaWNlcyAhPSAnYWxsJyAmJiB6clV0aWwuaW5kZXhPZihnaXZlbkF4aXNJbmRpY2VzLCBheGlzSW5kZXgpID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdPcHQgPSB7XG4gICAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgICAkZnJvbVRvb2xib3g6IHRydWUsXG4gICAgICAgIC8vIElkIGZvciBtZXJnZSBtYXBwaW5nLlxuICAgICAgICBpZDogREFUQV9aT09NX0lEX0JBU0UgKyBheGlzTmFtZSArIGF4aXNJbmRleFxuICAgICAgfTsgLy8gRklYTUVcbiAgICAgIC8vIE9ubHkgc3VwcG9ydCBvbmUgYXhpcyBub3cuXG5cbiAgICAgIG5ld09wdFtheGlzSW5kaWNlc05hbWVdID0gYXhpc0luZGV4O1xuICAgICAgZGF0YVpvb21PcHRzLnB1c2gobmV3T3B0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckVhY2hDb21wb25lbnQobWFpblR5cGUsIGNiKSB7XG4gICAgdmFyIG9wdHMgPSBvcHRpb25bbWFpblR5cGVdO1xuXG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShvcHRzKSkge1xuICAgICAgb3B0cyA9IG9wdHMgPyBbb3B0c10gOiBbXTtcbiAgICB9XG5cbiAgICBlYWNoKG9wdHMsIGNiKTtcbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBEYXRhWm9vbTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhWm9vbS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhWm9vbS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9sYW5nXCIpO1xuXG52YXIgZmVhdHVyZU1hbmFnZXIgPSByZXF1aXJlKFwiLi4vZmVhdHVyZU1hbmFnZXJcIik7XG5cbnZhciBtYWdpY1R5cGVMYW5nID0gbGFuZy50b29sYm94Lm1hZ2ljVHlwZTtcblxuZnVuY3Rpb24gTWFnaWNUeXBlKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbn1cblxuTWFnaWNUeXBlLmRlZmF1bHRPcHRpb24gPSB7XG4gIHNob3c6IHRydWUsXG4gIHR5cGU6IFtdLFxuICAvLyBJY29uIGdyb3VwXG4gIGljb246IHtcbiAgICBsaW5lOiAnTTQuMSwyOC45aDcuMWw5LjMtMjJsNy40LDM4bDkuNy0xOS43bDMsMTIuOGgxNC45TTQuMSw1OGg1MS40JyxcbiAgICBiYXI6ICdNNi43LDIyLjloMTBWNDhoLTEwVjIyLjl6TTI0LjksMTNoMTB2MzVoLTEwVjEzek00My4yLDJoMTB2NDZoLTEwVjJ6TTMuMSw1OGg1My43JyxcbiAgICBzdGFjazogJ004LjIsMzguNGwtOC40LDQuMWwzMC42LDE1LjNMNjAsNDIuNWwtOC4xLTQuMWwtMjEuNSwxMUw4LjIsMzguNHogTTUxLjksMzBsLTguMSw0LjJsLTEzLjQsNi45bC0xMy45LTYuOUw4LjIsMzBsLTguNCw0LjJsOC40LDQuMmwyMi4yLDExbDIxLjUtMTFsOC4xLTQuMkw1MS45LDMweiBNNTEuOSwyMS43bC04LjEsNC4yTDM1LjcsMzBsLTUuMywyLjhMMjQuOSwzMGwtOC40LTQuMWwtOC4zLTQuMmwtOC40LDQuMkw4LjIsMzBsOC4zLDQuMmwxMy45LDYuOWwxMy40LTYuOWw4LjEtNC4ybDguMS00LjFMNTEuOSwyMS43ek0zMC40LDIuMkwtMC4yLDE3LjVsOC40LDQuMWw4LjMsNC4ybDguNCw0LjJsNS41LDIuN2w1LjMtMi43bDguMS00LjJsOC4xLTQuMmw4LjEtNC4xTDMwLjQsMi4yeicsXG4gICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgdGlsZWQ6ICdNMi4zLDIuMmgyMi44VjI1SDIuM1YyLjJ6IE0zNSwyLjJoMjIuOFYyNUgzNVYyLjJ6TTIuMywzNWgyMi44djIyLjhIMi4zVjM1eiBNMzUsMzVoMjIuOHYyMi44SDM1VjM1eidcbiAgfSxcbiAgLy8gYGxpbmVgLCBgYmFyYCwgYHN0YWNrYCwgYHRpbGVkYFxuICB0aXRsZTogenJVdGlsLmNsb25lKG1hZ2ljVHlwZUxhbmcudGl0bGUpLFxuICBvcHRpb246IHt9LFxuICBzZXJpZXNJbmRleDoge31cbn07XG52YXIgcHJvdG8gPSBNYWdpY1R5cGUucHJvdG90eXBlO1xuXG5wcm90by5nZXRJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgdmFyIGF2YWlsYWJsZUljb25zID0gbW9kZWwuZ2V0KCdpY29uJyk7XG4gIHZhciBpY29ucyA9IHt9O1xuICB6clV0aWwuZWFjaChtb2RlbC5nZXQoJ3R5cGUnKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAoYXZhaWxhYmxlSWNvbnNbdHlwZV0pIHtcbiAgICAgIGljb25zW3R5cGVdID0gYXZhaWxhYmxlSWNvbnNbdHlwZV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGljb25zO1xufTtcblxudmFyIHNlcmllc09wdEdlbnJlYXRvciA9IHtcbiAgJ2xpbmUnOiBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgc2VyaWVzSWQsIHNlcmllc01vZGVsLCBtb2RlbCkge1xuICAgIGlmIChzZXJpZXNUeXBlID09PSAnYmFyJykge1xuICAgICAgcmV0dXJuIHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAvLyBQcmVzZXJ2ZSBkYXRhIHJlbGF0ZWQgb3B0aW9uXG4gICAgICAgIGRhdGE6IHNlcmllc01vZGVsLmdldCgnZGF0YScpLFxuICAgICAgICBzdGFjazogc2VyaWVzTW9kZWwuZ2V0KCdzdGFjaycpLFxuICAgICAgICBtYXJrUG9pbnQ6IHNlcmllc01vZGVsLmdldCgnbWFya1BvaW50JyksXG4gICAgICAgIG1hcmtMaW5lOiBzZXJpZXNNb2RlbC5nZXQoJ21hcmtMaW5lJylcbiAgICAgIH0sIG1vZGVsLmdldCgnb3B0aW9uLmxpbmUnKSB8fCB7fSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICAnYmFyJzogZnVuY3Rpb24gKHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWwpIHtcbiAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICByZXR1cm4genJVdGlsLm1lcmdlKHtcbiAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgLy8gUHJlc2VydmUgZGF0YSByZWxhdGVkIG9wdGlvblxuICAgICAgICBkYXRhOiBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKSxcbiAgICAgICAgc3RhY2s6IHNlcmllc01vZGVsLmdldCgnc3RhY2snKSxcbiAgICAgICAgbWFya1BvaW50OiBzZXJpZXNNb2RlbC5nZXQoJ21hcmtQb2ludCcpLFxuICAgICAgICBtYXJrTGluZTogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrTGluZScpXG4gICAgICB9LCBtb2RlbC5nZXQoJ29wdGlvbi5iYXInKSB8fCB7fSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICAnc3RhY2snOiBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgc2VyaWVzSWQsIHNlcmllc01vZGVsLCBtb2RlbCkge1xuICAgIGlmIChzZXJpZXNUeXBlID09PSAnbGluZScgfHwgc2VyaWVzVHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgIHJldHVybiB6clV0aWwubWVyZ2Uoe1xuICAgICAgICBpZDogc2VyaWVzSWQsXG4gICAgICAgIHN0YWNrOiAnX19lY19tYWdpY1R5cGVfc3RhY2tfXydcbiAgICAgIH0sIG1vZGVsLmdldCgnb3B0aW9uLnN0YWNrJykgfHwge30sIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgJ3RpbGVkJzogZnVuY3Rpb24gKHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWwpIHtcbiAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2xpbmUnIHx8IHNlcmllc1R5cGUgPT09ICdiYXInKSB7XG4gICAgICByZXR1cm4genJVdGlsLm1lcmdlKHtcbiAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICBzdGFjazogJydcbiAgICAgIH0sIG1vZGVsLmdldCgnb3B0aW9uLnRpbGVkJykgfHwge30sIHRydWUpO1xuICAgIH1cbiAgfVxufTtcbnZhciByYWRpb1R5cGVzID0gW1snbGluZScsICdiYXInXSwgWydzdGFjaycsICd0aWxlZCddXTtcblxucHJvdG8ub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGksIHR5cGUpIHtcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgdmFyIHNlcmllc0luZGV4ID0gbW9kZWwuZ2V0KCdzZXJpZXNJbmRleC4nICsgdHlwZSk7IC8vIE5vdCBzdXBwb3J0ZWQgbWFnaWNUeXBlXG5cbiAgaWYgKCFzZXJpZXNPcHRHZW5yZWF0b3JbdHlwZV0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV3T3B0aW9uID0ge1xuICAgIHNlcmllczogW11cbiAgfTtcblxuICB2YXIgZ2VuZXJhdGVOZXdTZXJpZXNUeXBlcyA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBzZXJpZXNUeXBlID0gc2VyaWVzTW9kZWwuc3ViVHlwZTtcbiAgICB2YXIgc2VyaWVzSWQgPSBzZXJpZXNNb2RlbC5pZDtcbiAgICB2YXIgbmV3U2VyaWVzT3B0ID0gc2VyaWVzT3B0R2VucmVhdG9yW3R5cGVdKHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWwpO1xuXG4gICAgaWYgKG5ld1Nlcmllc09wdCkge1xuICAgICAgLy8gUEVORElORyBJZiBtZXJnZSBvcmlnaW5hbCBvcHRpb24/XG4gICAgICB6clV0aWwuZGVmYXVsdHMobmV3U2VyaWVzT3B0LCBzZXJpZXNNb2RlbC5vcHRpb24pO1xuICAgICAgbmV3T3B0aW9uLnNlcmllcy5wdXNoKG5ld1Nlcmllc09wdCk7XG4gICAgfSAvLyBNb2RpZnkgYm91bmRhcnlHYXBcblxuXG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnICYmICh0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ2JhcicpKSB7XG4gICAgICB2YXIgY2F0ZWdvcnlBeGlzID0gY29vcmRTeXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXTtcblxuICAgICAgaWYgKGNhdGVnb3J5QXhpcykge1xuICAgICAgICB2YXIgYXhpc0RpbSA9IGNhdGVnb3J5QXhpcy5kaW07XG4gICAgICAgIHZhciBheGlzVHlwZSA9IGF4aXNEaW0gKyAnQXhpcyc7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgbWFpblR5cGU6IGF4aXNUeXBlLFxuICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQobmFtZSArICdJbmRleCcpLFxuICAgICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQobmFtZSArICdJZCcpXG4gICAgICAgIH0pWzBdO1xuICAgICAgICB2YXIgYXhpc0luZGV4ID0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4O1xuICAgICAgICBuZXdPcHRpb25bYXhpc1R5cGVdID0gbmV3T3B0aW9uW2F4aXNUeXBlXSB8fCBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBheGlzSW5kZXg7IGkrKykge1xuICAgICAgICAgIG5ld09wdGlvbltheGlzVHlwZV1bYXhpc0luZGV4XSA9IG5ld09wdGlvbltheGlzVHlwZV1bYXhpc0luZGV4XSB8fCB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld09wdGlvbltheGlzVHlwZV1bYXhpc0luZGV4XS5ib3VuZGFyeUdhcCA9IHR5cGUgPT09ICdiYXInID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB6clV0aWwuZWFjaChyYWRpb1R5cGVzLCBmdW5jdGlvbiAocmFkaW8pIHtcbiAgICBpZiAoenJVdGlsLmluZGV4T2YocmFkaW8sIHR5cGUpID49IDApIHtcbiAgICAgIHpyVXRpbC5lYWNoKHJhZGlvLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBtb2RlbC5zZXRJY29uU3RhdHVzKGl0ZW0sICdub3JtYWwnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIG1vZGVsLnNldEljb25TdGF0dXModHlwZSwgJ2VtcGhhc2lzJyk7XG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgIHF1ZXJ5OiBzZXJpZXNJbmRleCA9PSBudWxsID8gbnVsbCA6IHtcbiAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleFxuICAgIH1cbiAgfSwgZ2VuZXJhdGVOZXdTZXJpZXNUeXBlcyk7XG4gIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgdHlwZTogJ2NoYW5nZU1hZ2ljVHlwZScsXG4gICAgY3VycmVudFR5cGU6IHR5cGUsXG4gICAgbmV3T3B0aW9uOiBuZXdPcHRpb25cbiAgfSk7XG59O1xuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ2NoYW5nZU1hZ2ljVHlwZScsXG4gIGV2ZW50OiAnbWFnaWNUeXBlQ2hhbmdlZCcsXG4gIHVwZGF0ZTogJ3ByZXBhcmVBbmRVcGRhdGUnXG59LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICBlY01vZGVsLm1lcmdlT3B0aW9uKHBheWxvYWQubmV3T3B0aW9uKTtcbn0pO1xuZmVhdHVyZU1hbmFnZXIucmVnaXN0ZXIoJ21hZ2ljVHlwZScsIE1hZ2ljVHlwZSk7XG52YXIgX2RlZmF1bHQgPSBNYWdpY1R5cGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvTWFnaWNUeXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL01hZ2ljVHlwZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2VjaGFydHNcIik7XG5cbnZhciBoaXN0b3J5ID0gcmVxdWlyZShcIi4uLy4uL2RhdGFab29tL2hpc3RvcnlcIik7XG5cbnZhciBsYW5nID0gcmVxdWlyZShcIi4uLy4uLy4uL2xhbmdcIik7XG5cbnZhciBmZWF0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9mZWF0dXJlTWFuYWdlclwiKTtcblxudmFyIHJlc3RvcmVMYW5nID0gbGFuZy50b29sYm94LnJlc3RvcmU7XG5cbmZ1bmN0aW9uIFJlc3RvcmUobW9kZWwpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xufVxuXG5SZXN0b3JlLmRlZmF1bHRPcHRpb24gPSB7XG4gIHNob3c6IHRydWUsXG4gIGljb246ICdNMy44LDMzLjQgTTQ3LDE4LjloOS44VjguNyBNNTYuMywyMC4xIEM1Mi4xLDksNDAuNSwwLjYsMjYuOCwyLjFDMTIuNiwzLjcsMS42LDE2LjIsMi4xLDMwLjYgTTEzLDQxLjFIMy4xdjEwLjIgTTMuNywzOS45YzQuMiwxMS4xLDE1LjgsMTkuNSwyOS41LDE4IGMxNC4yLTEuNiwyNS4yLTE0LjEsMjQuNy0yOC41JyxcbiAgdGl0bGU6IHJlc3RvcmVMYW5nLnRpdGxlXG59O1xudmFyIHByb3RvID0gUmVzdG9yZS5wcm90b3R5cGU7XG5cbnByb3RvLm9uY2xpY2sgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpLCB0eXBlKSB7XG4gIGhpc3RvcnkuY2xlYXIoZWNNb2RlbCk7XG4gIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgdHlwZTogJ3Jlc3RvcmUnLFxuICAgIGZyb206IHRoaXMudWlkXG4gIH0pO1xufTtcblxuZmVhdHVyZU1hbmFnZXIucmVnaXN0ZXIoJ3Jlc3RvcmUnLCBSZXN0b3JlKTtcbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiAncmVzdG9yZScsXG4gIGV2ZW50OiAncmVzdG9yZScsXG4gIHVwZGF0ZTogJ3ByZXBhcmVBbmRVcGRhdGUnXG59LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICBlY01vZGVsLnJlc2V0T3B0aW9uKCdyZWNyZWF0ZScpO1xufSk7XG52YXIgX2RlZmF1bHQgPSBSZXN0b3JlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL1Jlc3RvcmUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvUmVzdG9yZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBsYW5nID0gcmVxdWlyZShcIi4uLy4uLy4uL2xhbmdcIik7XG5cbnZhciBmZWF0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9mZWF0dXJlTWFuYWdlclwiKTtcblxudmFyIHNhdmVBc0ltYWdlTGFuZyA9IGxhbmcudG9vbGJveC5zYXZlQXNJbWFnZTtcblxuZnVuY3Rpb24gU2F2ZUFzSW1hZ2UobW9kZWwpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xufVxuXG5TYXZlQXNJbWFnZS5kZWZhdWx0T3B0aW9uID0ge1xuICBzaG93OiB0cnVlLFxuICBpY29uOiAnTTQuNywyMi45TDI5LjMsNDUuNUw1NC43LDIzLjRNNC42LDQzLjZMNC42LDU4TDUzLjgsNThMNTMuOCw0My42TTI5LjIsNDUuMUwyOS4yLDAnLFxuICB0aXRsZTogc2F2ZUFzSW1hZ2VMYW5nLnRpdGxlLFxuICB0eXBlOiAncG5nJyxcbiAgLy8gRGVmYXVsdCB1c2Ugb3B0aW9uLmJhY2tncm91bmRDb2xvclxuICAvLyBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJyxcbiAgbmFtZTogJycsXG4gIGV4Y2x1ZGVDb21wb25lbnRzOiBbJ3Rvb2xib3gnXSxcbiAgcGl4ZWxSYXRpbzogMSxcbiAgbGFuZzogc2F2ZUFzSW1hZ2VMYW5nLmxhbmcuc2xpY2UoKVxufTtcblNhdmVBc0ltYWdlLnByb3RvdHlwZS51bnVzYWJsZSA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xudmFyIHByb3RvID0gU2F2ZUFzSW1hZ2UucHJvdG90eXBlO1xuXG5wcm90by5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICB2YXIgdGl0bGUgPSBtb2RlbC5nZXQoJ25hbWUnKSB8fCBlY01vZGVsLmdldCgndGl0bGUuMC50ZXh0JykgfHwgJ2VjaGFydHMnO1xuICB2YXIgJGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIHZhciB0eXBlID0gbW9kZWwuZ2V0KCd0eXBlJywgdHJ1ZSkgfHwgJ3BuZyc7XG4gICRhLmRvd25sb2FkID0gdGl0bGUgKyAnLicgKyB0eXBlO1xuICAkYS50YXJnZXQgPSAnX2JsYW5rJztcbiAgdmFyIHVybCA9IGFwaS5nZXRDb25uZWN0ZWREYXRhVVJMKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGJhY2tncm91bmRDb2xvcjogbW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InLCB0cnVlKSB8fCBlY01vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJyNmZmYnLFxuICAgIGV4Y2x1ZGVDb21wb25lbnRzOiBtb2RlbC5nZXQoJ2V4Y2x1ZGVDb21wb25lbnRzJyksXG4gICAgcGl4ZWxSYXRpbzogbW9kZWwuZ2V0KCdwaXhlbFJhdGlvJylcbiAgfSk7XG4gICRhLmhyZWYgPSB1cmw7IC8vIENocm9tZSBhbmQgRmlyZWZveFxuXG4gIGlmICh0eXBlb2YgTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiAhZW52LmJyb3dzZXIuaWUgJiYgIWVudi5icm93c2VyLmVkZ2UpIHtcbiAgICB2YXIgZXZ0ID0gbmV3IE1vdXNlRXZlbnQoJ2NsaWNrJywge1xuICAgICAgdmlldzogd2luZG93LFxuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgJGEuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9IC8vIElFXG4gIGVsc2Uge1xuICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICB2YXIgYnN0ciA9IGF0b2IodXJsLnNwbGl0KCcsJylbMV0pO1xuICAgICAgICB2YXIgbiA9IGJzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgdThhcnIgPSBuZXcgVWludDhBcnJheShuKTtcblxuICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgdThhcnJbbl0gPSBic3RyLmNoYXJDb2RlQXQobik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFt1OGFycl0pO1xuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgdGl0bGUgKyAnLicgKyB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYW5nID0gbW9kZWwuZ2V0KCdsYW5nJyk7XG4gICAgICAgIHZhciBodG1sID0gJycgKyAnPGJvZHkgc3R5bGU9XCJtYXJnaW46MDtcIj4nICsgJzxpbWcgc3JjPVwiJyArIHVybCArICdcIiBzdHlsZT1cIm1heC13aWR0aDoxMDAlO1wiIHRpdGxlPVwiJyArIChsYW5nICYmIGxhbmdbMF0gfHwgJycpICsgJ1wiIC8+JyArICc8L2JvZHk+JztcbiAgICAgICAgdmFyIHRhYiA9IHdpbmRvdy5vcGVuKCk7XG4gICAgICAgIHRhYi5kb2N1bWVudC53cml0ZShodG1sKTtcbiAgICAgIH1cbiAgICB9XG59O1xuXG5mZWF0dXJlTWFuYWdlci5yZWdpc3Rlcignc2F2ZUFzSW1hZ2UnLCBTYXZlQXNJbWFnZSk7XG52YXIgX2RlZmF1bHQgPSBTYXZlQXNJbWFnZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9TYXZlQXNJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9TYXZlQXNJbWFnZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBmZWF0dXJlcyA9IHt9O1xuXG5mdW5jdGlvbiByZWdpc3RlcihuYW1lLCBjdG9yKSB7XG4gIGZlYXR1cmVzW25hbWVdID0gY3Rvcjtcbn1cblxuZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgcmV0dXJuIGZlYXR1cmVzW25hbWVdO1xufVxuXG5leHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG5leHBvcnRzLmdldCA9IGdldDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG5yZXF1aXJlKFwiLi9heGlzUG9pbnRlclwiKTtcblxucmVxdWlyZShcIi4vdG9vbHRpcC9Ub29sdGlwTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL3Rvb2x0aXAvVG9vbHRpcFZpZXdcIik7XG5cbi8vIEZJWE1FIEJldHRlciB3YXkgdG8gcGFjayBkYXRhIGluIGdyYXBoaWMgZWxlbWVudFxuXG4vKipcbiAqIEBhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2VyaWVzSW5kZXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeV1cbiAqL1xuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICdzaG93VGlwJyxcbiAgZXZlbnQ6ICdzaG93VGlwJyxcbiAgdXBkYXRlOiAndG9vbHRpcDptYW51YWxseVNob3dUaXAnXG59LCAvLyBub29wXG5mdW5jdGlvbiAoKSB7fSk7XG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ2hpZGVUaXAnLFxuICBldmVudDogJ2hpZGVUaXAnLFxuICB1cGRhdGU6ICd0b29sdGlwOm1hbnVhbGx5SGlkZVRpcCdcbn0sIC8vIG5vb3BcbmZ1bmN0aW9uICgpIHt9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIHpyQ29sb3IgPSByZXF1aXJlKFwienJlbmRlci9saWIvdG9vbC9jb2xvclwiKTtcblxudmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZW52XCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciB0b0NhbWVsQ2FzZSA9IGZvcm1hdFV0aWwudG9DYW1lbENhc2U7XG52YXIgdmVuZG9ycyA9IFsnJywgJy13ZWJraXQtJywgJy1tb3otJywgJy1vLSddO1xudmFyIGdDc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7Ym9yZGVyLXN0eWxlOnNvbGlkO3doaXRlLXNwYWNlOm5vd3JhcDt6LWluZGV4Ojk5OTk5OTk7Jztcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAaW5uZXJcbiAqL1xuXG5mdW5jdGlvbiBhc3NlbWJsZVRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgdmFyIHRyYW5zaXRpb25DdXJ2ZSA9ICdjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSknO1xuICB2YXIgdHJhbnNpdGlvblRleHQgPSAnbGVmdCAnICsgZHVyYXRpb24gKyAncyAnICsgdHJhbnNpdGlvbkN1cnZlICsgJywnICsgJ3RvcCAnICsgZHVyYXRpb24gKyAncyAnICsgdHJhbnNpdGlvbkN1cnZlO1xuICByZXR1cm4genJVdGlsLm1hcCh2ZW5kb3JzLCBmdW5jdGlvbiAodmVuZG9yUHJlZml4KSB7XG4gICAgcmV0dXJuIHZlbmRvclByZWZpeCArICd0cmFuc2l0aW9uOicgKyB0cmFuc2l0aW9uVGV4dDtcbiAgfSkuam9pbignOycpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkge1xuICB2YXIgY3NzVGV4dCA9IFtdO1xuICB2YXIgZm9udFNpemUgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ2ZvbnRTaXplJyk7XG4gIHZhciBjb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpO1xuICBjb2xvciAmJiBjc3NUZXh0LnB1c2goJ2NvbG9yOicgKyBjb2xvcik7XG4gIGNzc1RleHQucHVzaCgnZm9udDonICsgdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpKTtcbiAgZm9udFNpemUgJiYgY3NzVGV4dC5wdXNoKCdsaW5lLWhlaWdodDonICsgTWF0aC5yb3VuZChmb250U2l6ZSAqIDMgLyAyKSArICdweCcpO1xuICBlYWNoKFsnZGVjb3JhdGlvbicsICdhbGlnbiddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWwgPSB0ZXh0U3R5bGVNb2RlbC5nZXQobmFtZSk7XG4gICAgdmFsICYmIGNzc1RleHQucHVzaCgndGV4dC0nICsgbmFtZSArICc6JyArIHZhbCk7XG4gIH0pO1xuICByZXR1cm4gY3NzVGV4dC5qb2luKCc7Jyk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b29sdGlwTW9kZWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gYXNzZW1ibGVDc3NUZXh0KHRvb2x0aXBNb2RlbCkge1xuICB2YXIgY3NzVGV4dCA9IFtdO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gdG9vbHRpcE1vZGVsLmdldCgndHJhbnNpdGlvbkR1cmF0aW9uJyk7XG4gIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSB0b29sdGlwTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgdmFyIHRleHRTdHlsZU1vZGVsID0gdG9vbHRpcE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgdmFyIHBhZGRpbmcgPSB0b29sdGlwTW9kZWwuZ2V0KCdwYWRkaW5nJyk7IC8vIEFuaW1hdGlvbiB0cmFuc2l0aW9uLiBEbyBub3QgYW5pbWF0ZSB3aGVuIHRyYW5zaXRpb25EdXJhdGlvbiBpcyAwLlxuXG4gIHRyYW5zaXRpb25EdXJhdGlvbiAmJiBjc3NUZXh0LnB1c2goYXNzZW1ibGVUcmFuc2l0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikpO1xuXG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBpZiAoZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgY3NzVGV4dC5wdXNoKCdiYWNrZ3JvdW5kLUNvbG9yOicgKyBiYWNrZ3JvdW5kQ29sb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgaWVcbiAgICAgIGNzc1RleHQucHVzaCgnYmFja2dyb3VuZC1Db2xvcjojJyArIHpyQ29sb3IudG9IZXgoYmFja2dyb3VuZENvbG9yKSk7XG4gICAgICBjc3NUZXh0LnB1c2goJ2ZpbHRlcjphbHBoYShvcGFjaXR5PTcwKScpO1xuICAgIH1cbiAgfSAvLyBCb3JkZXIgc3R5bGVcblxuXG4gIGVhY2goWyd3aWR0aCcsICdjb2xvcicsICdyYWRpdXMnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgYm9yZGVyTmFtZSA9ICdib3JkZXItJyArIG5hbWU7XG4gICAgdmFyIGNhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlKGJvcmRlck5hbWUpO1xuICAgIHZhciB2YWwgPSB0b29sdGlwTW9kZWwuZ2V0KGNhbWVsQ2FzZSk7XG4gICAgdmFsICE9IG51bGwgJiYgY3NzVGV4dC5wdXNoKGJvcmRlck5hbWUgKyAnOicgKyB2YWwgKyAobmFtZSA9PT0gJ2NvbG9yJyA/ICcnIDogJ3B4JykpO1xuICB9KTsgLy8gVGV4dCBzdHlsZVxuXG4gIGNzc1RleHQucHVzaChhc3NlbWJsZUZvbnQodGV4dFN0eWxlTW9kZWwpKTsgLy8gUGFkZGluZ1xuXG4gIGlmIChwYWRkaW5nICE9IG51bGwpIHtcbiAgICBjc3NUZXh0LnB1c2goJ3BhZGRpbmc6JyArIGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkocGFkZGluZykuam9pbigncHggJykgKyAncHgnKTtcbiAgfVxuXG4gIHJldHVybiBjc3NUZXh0LmpvaW4oJzsnKSArICc7Jztcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbmZ1bmN0aW9uIFRvb2x0aXBDb250ZW50KGNvbnRhaW5lciwgYXBpKSB7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgenIgPSB0aGlzLl96ciA9IGFwaS5nZXRacigpO1xuICB0aGlzLmVsID0gZWw7XG4gIHRoaXMuX3ggPSBhcGkuZ2V0V2lkdGgoKSAvIDI7XG4gIHRoaXMuX3kgPSBhcGkuZ2V0SGVpZ2h0KCkgLyAyO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gIHRoaXMuX3Nob3cgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2hpZGVUaW1lb3V0O1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZWwub25tb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGNsZWFyIHRoZSB0aW1lb3V0IGluIGhpZGVMYXRlciBhbmQga2VlcCBzaG93aW5nIHRvb2x0aXBcbiAgICBpZiAoc2VsZi5fZW50ZXJhYmxlKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5faGlkZVRpbWVvdXQpO1xuICAgICAgc2VsZi5fc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgc2VsZi5faW5Db250ZW50ID0gdHJ1ZTtcbiAgfTtcblxuICBlbC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgaWYgKCFzZWxmLl9lbnRlcmFibGUpIHtcbiAgICAgIC8vIFRyeSB0cmlnZ2VyIHpyZW5kZXIgZXZlbnQgdG8gYXZvaWQgbW91c2VcbiAgICAgIC8vIGluIGFuZCBvdXQgc2hhcGUgdG9vIGZyZXF1ZW50bHlcbiAgICAgIHZhciBoYW5kbGVyID0genIuaGFuZGxlcjtcbiAgICAgIGV2ZW50VXRpbC5ub3JtYWxpemVFdmVudChjb250YWluZXIsIGUsIHRydWUpO1xuICAgICAgaGFuZGxlci5kaXNwYXRjaCgnbW91c2Vtb3ZlJywgZSk7XG4gICAgfVxuICB9O1xuXG4gIGVsLm9ubW91c2VsZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5fZW50ZXJhYmxlKSB7XG4gICAgICBpZiAoc2VsZi5fc2hvdykge1xuICAgICAgICBzZWxmLmhpZGVMYXRlcihzZWxmLl9oaWRlRGVsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuX2luQ29udGVudCA9IGZhbHNlO1xuICB9O1xufVxuXG5Ub29sdGlwQ29udGVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUb29sdGlwQ29udGVudCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBfZW50ZXJhYmxlOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgd2hlbiB0b29sdGlwIGlzIHJlbmRlcmVkXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIE1vdmUgdGhpcyBsb2dpYyB0byBlYyBtYWluP1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG4gICAgdmFyIHN0bCA9IGNvbnRhaW5lci5jdXJyZW50U3R5bGUgfHwgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgIHZhciBkb21TdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcblxuICAgIGlmIChkb21TdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdGwucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgIGRvbVN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9IC8vIEhpZGUgdGhlIHRvb2x0aXBcbiAgICAvLyBQRU5ESU5HXG4gICAgLy8gdGhpcy5oaWRlKCk7XG5cbiAgfSxcbiAgc2hvdzogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dCk7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gZ0Nzc1RleHQgKyBhc3NlbWJsZUNzc1RleHQodG9vbHRpcE1vZGVsKSAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxMTI1NTg3L2NzczMtdHJhbnNpdGlvbi1ub3Qtd29ya2luZy1pbi1jaHJvbWUtYW55bW9yZVxuICAgICsgJztsZWZ0OicgKyB0aGlzLl94ICsgJ3B4O3RvcDonICsgdGhpcy5feSArICdweDsnICsgKHRvb2x0aXBNb2RlbC5nZXQoJ2V4dHJhQ3NzVGV4dCcpIHx8ICcnKTtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuaW5uZXJIVE1MID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICB0aGlzLl9zaG93ID0gdHJ1ZTtcbiAgfSxcbiAgc2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICB0aGlzLmVsLmlubmVySFRNTCA9IGNvbnRlbnQgPT0gbnVsbCA/ICcnIDogY29udGVudDtcbiAgfSxcbiAgc2V0RW50ZXJhYmxlOiBmdW5jdGlvbiAoZW50ZXJhYmxlKSB7XG4gICAgdGhpcy5fZW50ZXJhYmxlID0gZW50ZXJhYmxlO1xuICB9LFxuICBnZXRTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICByZXR1cm4gW2VsLmNsaWVudFdpZHRoLCBlbC5jbGllbnRIZWlnaHRdO1xuICB9LFxuICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgLy8geHkgc2hvdWxkIGJlIGJhc2VkIG9uIGNhbnZhcyByb290LiBCdXQgdG9vbHRpcENvbnRlbnQgaXNcbiAgICAvLyB0aGUgc2libGluZyBvZiBjYW52YXMgcm9vdC4gU28gcGFkZGluZyBvZiBlYyBjb250YWluZXJcbiAgICAvLyBzaG91bGQgYmUgY29uc2lkZXJlZCBoZXJlLlxuICAgIHZhciB6ciA9IHRoaXMuX3pyO1xuICAgIHZhciB2aWV3cG9ydFJvb3RPZmZzZXQ7XG5cbiAgICBpZiAoenIgJiYgenIucGFpbnRlciAmJiAodmlld3BvcnRSb290T2Zmc2V0ID0genIucGFpbnRlci5nZXRWaWV3cG9ydFJvb3RPZmZzZXQoKSkpIHtcbiAgICAgIHggKz0gdmlld3BvcnRSb290T2Zmc2V0Lm9mZnNldExlZnQ7XG4gICAgICB5ICs9IHZpZXdwb3J0Um9vdE9mZnNldC5vZmZzZXRUb3A7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gdGhpcy5lbC5zdHlsZTtcbiAgICBzdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgc3R5bGUudG9wID0geSArICdweCc7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gIH0sXG4gIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICB9LFxuICBoaWRlTGF0ZXI6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgaWYgKHRoaXMuX3Nob3cgJiYgISh0aGlzLl9pbkNvbnRlbnQgJiYgdGhpcy5fZW50ZXJhYmxlKSkge1xuICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgdGhpcy5faGlkZURlbGF5ID0gdGltZTsgLy8gU2V0IHNob3cgZmFsc2UgdG8gYXZvaWQgaW52b2tlIGhpZGVMYXRlciBtdXRpcGxlIHRpbWVzXG5cbiAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oaWRlVGltZW91dCA9IHNldFRpbWVvdXQoenJVdGlsLmJpbmQodGhpcy5oaWRlLCB0aGlzKSwgdGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlzU2hvdzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaG93O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gVG9vbHRpcENvbnRlbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciBfZGVmYXVsdCA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuICB0eXBlOiAndG9vbHRpcCcsXG4gIGRlcGVuZGVuY2llczogWydheGlzUG9pbnRlciddLFxuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDgsXG4gICAgc2hvdzogdHJ1ZSxcbiAgICAvLyB0b29sdGlw5Li75L2T5YaF5a65XG4gICAgc2hvd0NvbnRlbnQ6IHRydWUsXG4gICAgLy8gJ3RyaWdnZXInIG9ubHkgd29ya3Mgb24gY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgLy8gJ2l0ZW0nIHwgJ2F4aXMnIHwgJ25vbmUnXG4gICAgdHJpZ2dlcjogJ2l0ZW0nLFxuICAgIC8vICdjbGljaycgfCAnbW91c2Vtb3ZlJyB8ICdub25lJ1xuICAgIHRyaWdnZXJPbjogJ21vdXNlbW92ZXxjbGljaycsXG4gICAgYWx3YXlzU2hvd0NvbnRlbnQ6IGZhbHNlLFxuICAgIGRpc3BsYXlNb2RlOiAnc2luZ2xlJyxcbiAgICAvLyAnc2luZ2xlJyB8ICdtdWx0aXBsZUJ5Q29vcmRTeXMnXG4gICAgLy8g5L2N572uIHtBcnJheX0gfCB7RnVuY3Rpb259XG4gICAgLy8gcG9zaXRpb246IG51bGxcbiAgICAvLyBDb25zaWRlciB0cmlnZ2VyZWQgZnJvbSBheGlzUG9pbnRlciBoYW5kbGUsIHZlcnRpY2FsQWxpZ24gc2hvdWxkIGJlICdtaWRkbGUnXG4gICAgLy8gYWxpZ246IG51bGwsXG4gICAgLy8gdmVydGljYWxBbGlnbjogbnVsbCxcbiAgICAvLyDmmK/lkKbnuqbmnZ8gY29udGVudCDlnKggdmlld1JlY3Qg5Lit44CC6buY6K6kIGZhbHNlIOaYr+S4uuS6huWFvOWuueS7peWJjeeJiOacrOOAglxuICAgIGNvbmZpbmU6IGZhbHNlLFxuICAgIC8vIOWGheWuueagvOW8j+WZqO+8mntzdHJpbmd977yIVGVtcGxhdGXvvIkgwqYge0Z1bmN0aW9ufVxuICAgIC8vIGZvcm1hdHRlcjogbnVsbFxuICAgIHNob3dEZWxheTogMCxcbiAgICAvLyDpmpDol4/lu7bov5/vvIzljZXkvY1tc1xuICAgIGhpZGVEZWxheTogMTAwLFxuICAgIC8vIOWKqOeUu+WPmOaNouaXtumXtO+8jOWNleS9jXNcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IDAuNCxcbiAgICBlbnRlcmFibGU6IGZhbHNlLFxuICAgIC8vIOaPkOekuuiDjOaZr+minOiJsu+8jOm7mOiupOS4uumAj+aYjuW6puS4ujAuN+eahOm7keiJslxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoNTAsNTAsNTAsMC43KScsXG4gICAgLy8g5o+Q56S66L655qGG6aKc6ImyXG4gICAgYm9yZGVyQ29sb3I6ICcjMzMzJyxcbiAgICAvLyDmj5DnpLrovrnmoYblnIbop5LvvIzljZXkvY1weO+8jOm7mOiupOS4ujRcbiAgICBib3JkZXJSYWRpdXM6IDQsXG4gICAgLy8g5o+Q56S66L655qGG57q/5a6977yM5Y2V5L2NcHjvvIzpu5jorqTkuLow77yI5peg6L655qGG77yJXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgLy8g5o+Q56S65YaF6L656Led77yM5Y2V5L2NcHjvvIzpu5jorqTlkITmlrnlkJHlhoXovrnot53kuLo177yMXG4gICAgLy8g5o6l5Y+X5pWw57uE5YiG5Yir6K6+5a6a5LiK5Y+z5LiL5bem6L656Led77yM5ZCMY3NzXG4gICAgcGFkZGluZzogNSxcbiAgICAvLyBFeHRyYSBjc3MgdGV4dFxuICAgIGV4dHJhQ3NzVGV4dDogJycsXG4gICAgLy8g5Z2Q5qCH6L205oyH56S65Zmo77yM5Z2Q5qCH6L206Kem5Y+R5pyJ5pWIXG4gICAgYXhpc1BvaW50ZXI6IHtcbiAgICAgIC8vIOm7mOiupOS4uuebtOe6v1xuICAgICAgLy8g5Y+v6YCJ5Li677yaJ2xpbmUnIHwgJ3NoYWRvdycgfCAnY3Jvc3MnXG4gICAgICB0eXBlOiAnbGluZScsXG4gICAgICAvLyB0eXBlIOS4uiBsaW5lIOeahOaXtuWAmeacieaViO+8jOaMh+WumiB0b29sdGlwIGxpbmUg5omA5Zyo55qE6L2077yM5Y+v6YCJXG4gICAgICAvLyDlj6/pgIkgJ3gnIHwgJ3knIHwgJ2FuZ2xlJyB8ICdyYWRpdXMnIHwgJ2F1dG8nXG4gICAgICAvLyDpu5jorqQgJ2F1dG8n77yM5Lya6YCJ5oup57G75Z6L5Li6IGNhdGVvZ3J5IOeahOi9tO+8jOWvueS6juWPjOaVsOWAvOi9tO+8jOesm+WNoeWwlOWdkOagh+ezu+S8mum7mOiupOmAieaLqSB4IOi9tFxuICAgICAgLy8g5p6B5Z2Q5qCH57O75Lya6buY6K6k6YCJ5oupIGFuZ2xlIOi9tFxuICAgICAgYXhpczogJ2F1dG8nLFxuICAgICAgYW5pbWF0aW9uOiAnYXV0bycsXG4gICAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogMjAwLFxuICAgICAgYW5pbWF0aW9uRWFzaW5nVXBkYXRlOiAnZXhwb25lbnRpYWxPdXQnLFxuICAgICAgY3Jvc3NTdHlsZToge1xuICAgICAgICBjb2xvcjogJyM5OTknLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgdHlwZTogJ2Rhc2hlZCcsXG4gICAgICAgIC8vIFRPRE8gZm9ybWF0dGVyXG4gICAgICAgIHRleHRTdHlsZToge30gLy8gbGluZVN0eWxlIGFuZCBzaGFkb3dTdHlsZSBzaG91bGQgbm90IGJlIHNwZWNpZmllZCBoZXJlLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQgd2lsbCBhbHdheXMgb3ZlcnJpZGUgdGhvc2Ugc3R5bGVzIG9uIG9wdGlvbi5heGlzUG9pbnRlci5cblxuICAgICAgfVxuICAgIH0sXG4gICAgdGV4dFN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgZm9udFNpemU6IDE0XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZW52XCIpO1xuXG52YXIgVG9vbHRpcENvbnRlbnQgPSByZXF1aXJlKFwiLi9Ub29sdGlwQ29udGVudFwiKTtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBmaW5kUG9pbnRGcm9tU2VyaWVzID0gcmVxdWlyZShcIi4uL2F4aXNQb2ludGVyL2ZpbmRQb2ludEZyb21TZXJpZXNcIik7XG5cbnZhciBsYXlvdXRVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTW9kZWxcIik7XG5cbnZhciBnbG9iYWxMaXN0ZW5lciA9IHJlcXVpcmUoXCIuLi9heGlzUG9pbnRlci9nbG9iYWxMaXN0ZW5lclwiKTtcblxudmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKFwiLi4vLi4vY29vcmQvYXhpc0hlbHBlclwiKTtcblxudmFyIGF4aXNQb2ludGVyVmlld0hlbHBlciA9IHJlcXVpcmUoXCIuLi9heGlzUG9pbnRlci92aWV3SGVscGVyXCIpO1xuXG52YXIgYmluZCA9IHpyVXRpbC5iaW5kO1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBwYXJzZVBlcmNlbnQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudDtcbnZhciBwcm94eVJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgc2hhcGU6IHtcbiAgICB4OiAtMSxcbiAgICB5OiAtMSxcbiAgICB3aWR0aDogMixcbiAgICBoZWlnaHQ6IDJcbiAgfVxufSk7XG5cbnZhciBfZGVmYXVsdCA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG4gIHR5cGU6ICd0b29sdGlwJyxcbiAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0b29sdGlwQ29udGVudCA9IG5ldyBUb29sdGlwQ29udGVudChhcGkuZ2V0RG9tKCksIGFwaSk7XG4gICAgdGhpcy5fdG9vbHRpcENvbnRlbnQgPSB0b29sdGlwQ29udGVudDtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFJlc2V0XG5cblxuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsfVxuICAgICAqL1xuXG4gICAgdGhpcy5fdG9vbHRpcE1vZGVsID0gdG9vbHRpcE1vZGVsO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICAgKi9cblxuICAgIHRoaXMuX2VjTW9kZWwgPSBlY01vZGVsO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAgICAgKi9cblxuICAgIHRoaXMuX2FwaSA9IGFwaTtcbiAgICAvKipcbiAgICAgKiBTaG91bGQgYmUgY2xlYW5lZCB3aGVuIHJlbmRlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPE9iamVjdD4+fVxuICAgICAqL1xuXG4gICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgdGhpcy5fYWx3YXlzU2hvd0NvbnRlbnQgPSB0b29sdGlwTW9kZWwuZ2V0KCdhbHdheXNTaG93Q29udGVudCcpO1xuICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xuICAgIHRvb2x0aXBDb250ZW50LnVwZGF0ZSgpO1xuICAgIHRvb2x0aXBDb250ZW50LnNldEVudGVyYWJsZSh0b29sdGlwTW9kZWwuZ2V0KCdlbnRlcmFibGUnKSk7XG5cbiAgICB0aGlzLl9pbml0R2xvYmFsTGlzdGVuZXIoKTtcblxuICAgIHRoaXMuX2tlZXBTaG93KCk7XG4gIH0sXG4gIF9pbml0R2xvYmFsTGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgIHZhciB0cmlnZ2VyT24gPSB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKTtcbiAgICBnbG9iYWxMaXN0ZW5lci5yZWdpc3RlcignaXRlbVRvb2x0aXAnLCB0aGlzLl9hcGksIGJpbmQoZnVuY3Rpb24gKGN1cnJUcmlnZ2VyLCBlLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgLy8gSWYgJ25vbmUnLCBpdCBpcyBub3QgY29udHJvbGxlZCBieSBtb3VzZSB0b3RhbGx5LlxuICAgICAgaWYgKHRyaWdnZXJPbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGlmICh0cmlnZ2VyT24uaW5kZXhPZihjdXJyVHJpZ2dlcikgPj0gMCkge1xuICAgICAgICAgIHRoaXMuX3RyeVNob3coZSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJUcmlnZ2VyID09PSAnbGVhdmUnKSB7XG4gICAgICAgICAgdGhpcy5faGlkZShkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzKSk7XG4gIH0sXG4gIF9rZWVwU2hvdzogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9lY01vZGVsO1xuICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7IC8vIFRyeSB0byBrZWVwIHRoZSB0b29sdGlwIHNob3cgd2hlbiByZWZyZXNoaW5nXG5cbiAgICBpZiAodGhpcy5fbGFzdFggIT0gbnVsbCAmJiB0aGlzLl9sYXN0WSAhPSBudWxsIC8vIFdoZW4gdXNlciBpcyB3aWxsaW5nIHRvIGNvbnRyb2wgdG9vbHRpcCB0b3RhbGx5IHVzaW5nIEFQSSxcbiAgICAvLyBzZWxmLm1hbnVhbGx5U2hvd1RpcCh7eCwgeX0pIG1pZ2h0IGNhdXNlIHRvb2x0aXAgaGlkZSxcbiAgICAvLyB3aGljaCBpcyBub3QgZXhwZWN0ZWQuXG4gICAgJiYgdG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlck9uJykgIT09ICdub25lJykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlZnJlc2hVcGRhdGVUaW1lb3V0KTtcbiAgICAgIHRoaXMuX3JlZnJlc2hVcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNob3cgdGlwIG5leHQgdGljayBhZnRlciBvdGhlciBjaGFydHMgYXJlIHJlbmRlcmVkXG4gICAgICAgIC8vIEluIGNhc2UgaGlnaGxpZ2h0IGFjdGlvbiBoYXMgd3JvbmcgcmVzdWx0XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIHNlbGYubWFudWFsbHlTaG93VGlwKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCB7XG4gICAgICAgICAgeDogc2VsZi5fbGFzdFgsXG4gICAgICAgICAgeTogc2VsZi5fbGFzdFlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3cgdGlwIG1hbnVhbGx5IGJ5XG4gICAqIGRpc3BhdGNoQWN0aW9uKHtcbiAgICogICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICogICAgIHg6IDEwLFxuICAgKiAgICAgeTogMTBcbiAgICogfSk7XG4gICAqIE9yXG4gICAqIGRpc3BhdGNoQWN0aW9uKHtcbiAgICogICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAqICAgICAgc2VyaWVzSW5kZXg6IDAsXG4gICAqICAgICAgZGF0YUluZGV4IG9yIGRhdGFJbmRleEluc2lkZSBvciBuYW1lXG4gICAqIH0pO1xuICAgKlxuICAgKiAgVE9ETyBCYXRjaFxuICAgKi9cbiAgbWFudWFsbHlTaG93VGlwOiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICBpZiAocGF5bG9hZC5mcm9tID09PSB0aGlzLnVpZCB8fCBlbnYubm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXNwYXRjaEFjdGlvbiA9IG1ha2VEaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBhcGkpOyAvLyBSZXNldCB0aWNrZXRcblxuICAgIHRoaXMuX3RpY2tldCA9ICcnOyAvLyBXaGVuIHRyaWdnZXJlZCBmcm9tIGF4aXNQb2ludGVyLlxuXG4gICAgdmFyIGRhdGFCeUNvb3JkU3lzID0gcGF5bG9hZC5kYXRhQnlDb29yZFN5cztcblxuICAgIGlmIChwYXlsb2FkLnRvb2x0aXAgJiYgcGF5bG9hZC54ICE9IG51bGwgJiYgcGF5bG9hZC55ICE9IG51bGwpIHtcbiAgICAgIHZhciBlbCA9IHByb3h5UmVjdDtcbiAgICAgIGVsLnBvc2l0aW9uID0gW3BheWxvYWQueCwgcGF5bG9hZC55XTtcbiAgICAgIGVsLnVwZGF0ZSgpO1xuICAgICAgZWwudG9vbHRpcCA9IHBheWxvYWQudG9vbHRpcDsgLy8gTWFudWFsbHkgc2hvdyB0b29sdGlwIHdoaWxlIHZpZXcgaXMgbm90IHVzaW5nIHpyZW5kZXIgZWxlbWVudHMuXG5cbiAgICAgIHRoaXMuX3RyeVNob3coe1xuICAgICAgICBvZmZzZXRYOiBwYXlsb2FkLngsXG4gICAgICAgIG9mZnNldFk6IHBheWxvYWQueSxcbiAgICAgICAgdGFyZ2V0OiBlbFxuICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoZGF0YUJ5Q29vcmRTeXMpIHtcbiAgICAgIHRoaXMuX3RyeVNob3coe1xuICAgICAgICBvZmZzZXRYOiBwYXlsb2FkLngsXG4gICAgICAgIG9mZnNldFk6IHBheWxvYWQueSxcbiAgICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgICAgIGV2ZW50OiB7fSxcbiAgICAgICAgZGF0YUJ5Q29vcmRTeXM6IHBheWxvYWQuZGF0YUJ5Q29vcmRTeXMsXG4gICAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWQudG9vbHRpcE9wdGlvblxuICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZC5zZXJpZXNJbmRleCAhPSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5fbWFudWFsbHlBeGlzU2hvd1RpcCh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRJbmZvID0gZmluZFBvaW50RnJvbVNlcmllcyhwYXlsb2FkLCBlY01vZGVsKTtcbiAgICAgIHZhciBjeCA9IHBvaW50SW5mby5wb2ludFswXTtcbiAgICAgIHZhciBjeSA9IHBvaW50SW5mby5wb2ludFsxXTtcblxuICAgICAgaWYgKGN4ICE9IG51bGwgJiYgY3kgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgICBvZmZzZXRYOiBjeCxcbiAgICAgICAgICBvZmZzZXRZOiBjeSxcbiAgICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgICB0YXJnZXQ6IHBvaW50SW5mby5lbCxcbiAgICAgICAgICBldmVudDoge31cbiAgICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZC54ICE9IG51bGwgJiYgcGF5bG9hZC55ICE9IG51bGwpIHtcbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyBzaG91bGQgd3JhcCBkaXNwYXRjaEFjdGlvbiBsaWtlIGBheGlzUG9pbnRlci9nbG9iYWxMaXN0ZW5lcmAgP1xuICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgICAgeDogcGF5bG9hZC54LFxuICAgICAgICB5OiBwYXlsb2FkLnlcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgb2Zmc2V0WDogcGF5bG9hZC54LFxuICAgICAgICBvZmZzZXRZOiBwYXlsb2FkLnksXG4gICAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IGFwaS5nZXRacigpLmZpbmRIb3ZlcihwYXlsb2FkLngsIHBheWxvYWQueSkudGFyZ2V0LFxuICAgICAgICBldmVudDoge31cbiAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICB9XG4gIH0sXG4gIG1hbnVhbGx5SGlkZVRpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XG5cbiAgICBpZiAoIXRoaXMuX2Fsd2F5c1Nob3dDb250ZW50KSB7XG4gICAgICB0b29sdGlwQ29udGVudC5oaWRlTGF0ZXIodGhpcy5fdG9vbHRpcE1vZGVsLmdldCgnaGlkZURlbGF5JykpO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RYID0gdGhpcy5fbGFzdFkgPSBudWxsO1xuXG4gICAgaWYgKHBheWxvYWQuZnJvbSAhPT0gdGhpcy51aWQpIHtcbiAgICAgIHRoaXMuX2hpZGUobWFrZURpc3BhdGNoQWN0aW9uKHBheWxvYWQsIGFwaSkpO1xuICAgIH1cbiAgfSxcbiAgLy8gQmUgY29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIGRlc2lnbiwgdGhhdCBpcywgd2hlbiB0b29sdGlwLnR5cGUgaXMgJ2F4aXMnIGFuZFxuICAvLyBkaXNwYXRjaEFjdGlvbiAnc2hvd1RpcCcgd2l0aCBzZXJpZXNJbmRleCBhbmQgZGF0YUluZGV4IHdpbGwgdHJpZ2dlciBheGlzIHBvaW50ZXJcbiAgLy8gYW5kIHRvb2x0aXAuXG4gIF9tYW51YWxseUF4aXNTaG93VGlwOiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgc2VyaWVzSW5kZXggPSBwYXlsb2FkLnNlcmllc0luZGV4O1xuICAgIHZhciBkYXRhSW5kZXggPSBwYXlsb2FkLmRhdGFJbmRleDtcbiAgICB2YXIgY29vcmRTeXNBeGVzSW5mbyA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpLmNvb3JkU3lzQXhlc0luZm87XG5cbiAgICBpZiAoc2VyaWVzSW5kZXggPT0gbnVsbCB8fCBkYXRhSW5kZXggPT0gbnVsbCB8fCBjb29yZFN5c0F4ZXNJbmZvID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoc2VyaWVzSW5kZXgpO1xuXG4gICAgaWYgKCFzZXJpZXNNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciB0b29sdGlwTW9kZWwgPSBidWlsZFRvb2x0aXBNb2RlbChbZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KSwgc2VyaWVzTW9kZWwsIChzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtIHx8IHt9KS5tb2RlbCwgdG9vbHRpcE1vZGVsXSk7XG5cbiAgICBpZiAodG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlcicpICE9PSAnYXhpcycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgIGRhdGFJbmRleDogZGF0YUluZGV4LFxuICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb25cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgX3RyeVNob3c6IGZ1bmN0aW9uIChlLCBkaXNwYXRjaEFjdGlvbikge1xuICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgIHZhciB0b29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG5cbiAgICBpZiAoIXRvb2x0aXBNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gU2F2ZSBtb3VzZSB4LCBtb3VzZSB5LiBTbyB3ZSBjYW4gdHJ5IHRvIGtlZXAgc2hvd2luZyB0aGUgdGlwIGlmIGNoYXJ0IGlzIHJlZnJlc2hlZFxuXG5cbiAgICB0aGlzLl9sYXN0WCA9IGUub2Zmc2V0WDtcbiAgICB0aGlzLl9sYXN0WSA9IGUub2Zmc2V0WTtcbiAgICB2YXIgZGF0YUJ5Q29vcmRTeXMgPSBlLmRhdGFCeUNvb3JkU3lzO1xuXG4gICAgaWYgKGRhdGFCeUNvb3JkU3lzICYmIGRhdGFCeUNvb3JkU3lzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2hvd0F4aXNUb29sdGlwKGRhdGFCeUNvb3JkU3lzLCBlKTtcbiAgICB9IC8vIEFsd2F5cyBzaG93IGl0ZW0gdG9vbHRpcCBpZiBtb3VzZSBpcyBvbiB0aGUgZWxlbWVudCB3aXRoIGRhdGFJbmRleFxuICAgIGVsc2UgaWYgKGVsICYmIGVsLmRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fc2hvd1Nlcmllc0l0ZW1Ub29sdGlwKGUsIGVsLCBkaXNwYXRjaEFjdGlvbik7XG4gICAgICB9IC8vIFRvb2x0aXAgcHJvdmlkZWQgZGlyZWN0bHkuIExpa2UgbGVnZW5kLlxuICAgICAgZWxzZSBpZiAoZWwgJiYgZWwudG9vbHRpcCkge1xuICAgICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG5cbiAgICAgICAgICB0aGlzLl9zaG93Q29tcG9uZW50SXRlbVRvb2x0aXAoZSwgZWwsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuXG4gICAgICAgICAgdGhpcy5faGlkZShkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgIH1cbiAgfSxcbiAgX3Nob3dPck1vdmU6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGNiKSB7XG4gICAgLy8gc2hvd0RlbGF5IGlzIHVzZWQgaW4gdGhpcyBjYXNlOiB0b29sdGlwLmVudGVyYWJsZSBpcyBzZXRcbiAgICAvLyBhcyB0cnVlLiBVc2VyIGludGVudCB0byBtb3ZlIG1vdXNlIGludG8gdG9vbHRpcCBhbmQgY2xpY2tcbiAgICAvLyBzb21ldGhpbmcuIGBzaG93RGVsYXlgIG1ha2VzIGl0IGVhc3llciB0byBlbnRlciB0aGUgY29udGVudFxuICAgIC8vIGJ1dCB0b29sdGlwIGRvIG5vdCBtb3ZlIGltbWVkaWF0ZWx5LlxuICAgIHZhciBkZWxheSA9IHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dEZWxheScpO1xuICAgIGNiID0genJVdGlsLmJpbmQoY2IsIHRoaXMpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaG93VGltb3V0KTtcbiAgICBkZWxheSA+IDAgPyB0aGlzLl9zaG93VGltb3V0ID0gc2V0VGltZW91dChjYiwgZGVsYXkpIDogY2IoKTtcbiAgfSxcbiAgX3Nob3dBeGlzVG9vbHRpcDogZnVuY3Rpb24gKGRhdGFCeUNvb3JkU3lzLCBlKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9lY01vZGVsO1xuICAgIHZhciBnbG9iYWxUb29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG4gICAgdmFyIHBvaW50ID0gW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXTtcbiAgICB2YXIgc2luZ2xlRGVmYXVsdEhUTUwgPSBbXTtcbiAgICB2YXIgc2luZ2xlUGFyYW1zTGlzdCA9IFtdO1xuICAgIHZhciBzaW5nbGVUb29sdGlwTW9kZWwgPSBidWlsZFRvb2x0aXBNb2RlbChbZS50b29sdGlwT3B0aW9uLCBnbG9iYWxUb29sdGlwTW9kZWxdKTtcbiAgICBlYWNoKGRhdGFCeUNvb3JkU3lzLCBmdW5jdGlvbiAoaXRlbUNvb3JkU3lzKSB7XG4gICAgICAvLyB2YXIgY29vcmRQYXJhbUxpc3QgPSBbXTtcbiAgICAgIC8vIHZhciBjb29yZERlZmF1bHRIVE1MID0gW107XG4gICAgICAvLyB2YXIgY29vcmRUb29sdGlwTW9kZWwgPSBidWlsZFRvb2x0aXBNb2RlbChbXG4gICAgICAvLyAgICAgZS50b29sdGlwT3B0aW9uLFxuICAgICAgLy8gICAgIGl0ZW1Db29yZFN5cy50b29sdGlwT3B0aW9uLFxuICAgICAgLy8gICAgIGVjTW9kZWwuZ2V0Q29tcG9uZW50KGl0ZW1Db29yZFN5cy5jb29yZFN5c01haW5UeXBlLCBpdGVtQ29vcmRTeXMuY29vcmRTeXNJbmRleCksXG4gICAgICAvLyAgICAgZ2xvYmFsVG9vbHRpcE1vZGVsXG4gICAgICAvLyBdKTtcbiAgICAgIC8vIHZhciBkaXNwbGF5TW9kZSA9IGNvb3JkVG9vbHRpcE1vZGVsLmdldCgnZGlzcGxheU1vZGUnKTtcbiAgICAgIC8vIHZhciBwYXJhbXNMaXN0ID0gZGlzcGxheU1vZGUgPT09ICdzaW5nbGUnID8gc2luZ2xlUGFyYW1zTGlzdCA6IFtdO1xuICAgICAgZWFjaChpdGVtQ29vcmRTeXMuZGF0YUJ5QXhpcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGl0ZW0uYXhpc0RpbSArICdBeGlzJywgaXRlbS5heGlzSW5kZXgpO1xuICAgICAgICB2YXIgYXhpc1ZhbHVlID0gaXRlbS52YWx1ZTtcbiAgICAgICAgdmFyIHNlcmllc0RlZmF1bHRIVE1MID0gW107XG5cbiAgICAgICAgaWYgKCFheGlzTW9kZWwgfHwgYXhpc1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWVMYWJlbCA9IGF4aXNQb2ludGVyVmlld0hlbHBlci5nZXRWYWx1ZUxhYmVsKGF4aXNWYWx1ZSwgYXhpc01vZGVsLmF4aXMsIGVjTW9kZWwsIGl0ZW0uc2VyaWVzRGF0YUluZGljZXMsIGl0ZW0udmFsdWVMYWJlbE9wdCk7XG4gICAgICAgIHpyVXRpbC5lYWNoKGl0ZW0uc2VyaWVzRGF0YUluZGljZXMsIGZ1bmN0aW9uIChpZHhJdGVtKSB7XG4gICAgICAgICAgdmFyIHNlcmllcyA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChpZHhJdGVtLnNlcmllc0luZGV4KTtcbiAgICAgICAgICB2YXIgZGF0YUluZGV4ID0gaWR4SXRlbS5kYXRhSW5kZXhJbnNpZGU7XG4gICAgICAgICAgdmFyIGRhdGFQYXJhbXMgPSBzZXJpZXMgJiYgc2VyaWVzLmdldERhdGFQYXJhbXMoZGF0YUluZGV4KTtcbiAgICAgICAgICBkYXRhUGFyYW1zLmF4aXNEaW0gPSBpdGVtLmF4aXNEaW07XG4gICAgICAgICAgZGF0YVBhcmFtcy5heGlzSW5kZXggPSBpdGVtLmF4aXNJbmRleDtcbiAgICAgICAgICBkYXRhUGFyYW1zLmF4aXNUeXBlID0gaXRlbS5heGlzVHlwZTtcbiAgICAgICAgICBkYXRhUGFyYW1zLmF4aXNJZCA9IGl0ZW0uYXhpc0lkO1xuICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc1ZhbHVlID0gYXhpc0hlbHBlci5nZXRBeGlzUmF3VmFsdWUoYXhpc01vZGVsLmF4aXMsIGF4aXNWYWx1ZSk7XG4gICAgICAgICAgZGF0YVBhcmFtcy5heGlzVmFsdWVMYWJlbCA9IHZhbHVlTGFiZWw7XG5cbiAgICAgICAgICBpZiAoZGF0YVBhcmFtcykge1xuICAgICAgICAgICAgc2luZ2xlUGFyYW1zTGlzdC5wdXNoKGRhdGFQYXJhbXMpO1xuICAgICAgICAgICAgc2VyaWVzRGVmYXVsdEhUTUwucHVzaChzZXJpZXMuZm9ybWF0VG9vbHRpcChkYXRhSW5kZXgsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBEZWZhdWx0IHRvb2x0aXAgY29udGVudFxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyAoMSkgc2hvbGQgYmUgdGhlIGZpcnN0IGRhdGEgd2hpY2ggaGFzIG5hbWU/XG4gICAgICAgIC8vICgyKSB0aGVtZVJpdmVyLCBmaXJzdERhdGFJbmRleCBpcyBhcnJheSwgYW5kIGZpcnN0IGxpbmUgaXMgdW5uZWNlc3NhcnkuXG5cbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IHZhbHVlTGFiZWw7XG4gICAgICAgIHNpbmdsZURlZmF1bHRIVE1MLnB1c2goKGZpcnN0TGluZSA/IGZvcm1hdFV0aWwuZW5jb2RlSFRNTChmaXJzdExpbmUpICsgJzxiciAvPicgOiAnJykgKyBzZXJpZXNEZWZhdWx0SFRNTC5qb2luKCc8YnIgLz4nKSk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTsgLy8gSW4gbW9zdCBjYXNlLCB0aGUgc2Vjb25kIGF4aXMgaXMgc2hvd24gdXBwZXIgdGhhbiB0aGUgZmlyc3Qgb25lLlxuXG4gICAgc2luZ2xlRGVmYXVsdEhUTUwucmV2ZXJzZSgpO1xuICAgIHNpbmdsZURlZmF1bHRIVE1MID0gc2luZ2xlRGVmYXVsdEhUTUwuam9pbignPGJyIC8+PGJyIC8+Jyk7XG4gICAgdmFyIHBvc2l0aW9uRXhwciA9IGUucG9zaXRpb247XG5cbiAgICB0aGlzLl9zaG93T3JNb3ZlKHNpbmdsZVRvb2x0aXBNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX3VwZGF0ZUNvbnRlbnROb3RDaGFuZ2VkT25BeGlzKGRhdGFCeUNvb3JkU3lzKSkge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbihzaW5nbGVUb29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgcG9pbnRbMF0sIHBvaW50WzFdLCB0aGlzLl90b29sdGlwQ29udGVudCwgc2luZ2xlUGFyYW1zTGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcENvbnRlbnQoc2luZ2xlVG9vbHRpcE1vZGVsLCBzaW5nbGVEZWZhdWx0SFRNTCwgc2luZ2xlUGFyYW1zTGlzdCwgTWF0aC5yYW5kb20oKSwgcG9pbnRbMF0sIHBvaW50WzFdLCBwb3NpdGlvbkV4cHIpO1xuICAgICAgfVxuICAgIH0pOyAvLyBEbyBub3QgdHJpZ2dlciBldmVudHMgaGVyZSwgYmVjYXVzZSB0aGlzIGJyYW5jaCBvbmx5IGJlIGVudGVyZWRcbiAgICAvLyBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuXG4gIH0sXG4gIF9zaG93U2VyaWVzSXRlbVRvb2x0aXA6IGZ1bmN0aW9uIChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX2VjTW9kZWw7IC8vIFVzZSBkYXRhTW9kZWwgaW4gZWxlbWVudCBpZiBwb3NzaWJsZVxuICAgIC8vIFVzZWQgd2hlbiBtb3VzZW92ZXIgb24gYSBlbGVtZW50IGxpa2UgbWFya1BvaW50IG9yIGVkZ2VcbiAgICAvLyBJbiB3aGljaCBjYXNlLCB0aGUgZGF0YSBpcyBub3QgbWFpbiBkYXRhIGluIHNlcmllcy5cblxuICAgIHZhciBzZXJpZXNJbmRleCA9IGVsLnNlcmllc0luZGV4O1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCk7IC8vIEZvciBleGFtcGxlLCBncmFwaCBsaW5rLlxuXG4gICAgdmFyIGRhdGFNb2RlbCA9IGVsLmRhdGFNb2RlbCB8fCBzZXJpZXNNb2RlbDtcbiAgICB2YXIgZGF0YUluZGV4ID0gZWwuZGF0YUluZGV4O1xuICAgIHZhciBkYXRhVHlwZSA9IGVsLmRhdGFUeXBlO1xuICAgIHZhciBkYXRhID0gZGF0YU1vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW2RhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCksIGRhdGFNb2RlbCwgc2VyaWVzTW9kZWwgJiYgKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gfHwge30pLm1vZGVsLCB0aGlzLl90b29sdGlwTW9kZWxdKTtcbiAgICB2YXIgdG9vbHRpcFRyaWdnZXIgPSB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJyk7XG5cbiAgICBpZiAodG9vbHRpcFRyaWdnZXIgIT0gbnVsbCAmJiB0b29sdGlwVHJpZ2dlciAhPT0gJ2l0ZW0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IGRhdGFNb2RlbC5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgIHZhciBkZWZhdWx0SHRtbCA9IGRhdGFNb2RlbC5mb3JtYXRUb29sdGlwKGRhdGFJbmRleCwgZmFsc2UsIGRhdGFUeXBlKTtcbiAgICB2YXIgYXN5bmNUaWNrZXQgPSAnaXRlbV8nICsgZGF0YU1vZGVsLm5hbWUgKyAnXycgKyBkYXRhSW5kZXg7XG5cbiAgICB0aGlzLl9zaG93T3JNb3ZlKHRvb2x0aXBNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KHRvb2x0aXBNb2RlbCwgZGVmYXVsdEh0bWwsIHBhcmFtcywgYXN5bmNUaWNrZXQsIGUub2Zmc2V0WCwgZS5vZmZzZXRZLCBlLnBvc2l0aW9uLCBlLnRhcmdldCk7XG4gICAgfSk7IC8vIEZJWE1FXG4gICAgLy8gZHVwbGljYXRlZCBzaG93dGlwIGlmIG1hbnVhbGx5U2hvd1RpcCBpcyBjYWxsZWQgZnJvbSBkaXNwYXRjaEFjdGlvbi5cblxuXG4gICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgZGF0YUluZGV4SW5zaWRlOiBkYXRhSW5kZXgsXG4gICAgICBkYXRhSW5kZXg6IGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KSxcbiAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgIGZyb206IHRoaXMudWlkXG4gICAgfSk7XG4gIH0sXG4gIF9zaG93Q29tcG9uZW50SXRlbVRvb2x0aXA6IGZ1bmN0aW9uIChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICB2YXIgdG9vbHRpcE9wdCA9IGVsLnRvb2x0aXA7XG5cbiAgICBpZiAodHlwZW9mIHRvb2x0aXBPcHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgY29udGVudCA9IHRvb2x0aXBPcHQ7XG4gICAgICB0b29sdGlwT3B0ID0ge1xuICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAvLyBGaXhlZCBmb3JtYXR0ZXJcbiAgICAgICAgZm9ybWF0dGVyOiBjb250ZW50XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzdWJUb29sdGlwTW9kZWwgPSBuZXcgTW9kZWwodG9vbHRpcE9wdCwgdGhpcy5fdG9vbHRpcE1vZGVsLCB0aGlzLl9lY01vZGVsKTtcbiAgICB2YXIgZGVmYXVsdEh0bWwgPSBzdWJUb29sdGlwTW9kZWwuZ2V0KCdjb250ZW50Jyk7XG4gICAgdmFyIGFzeW5jVGlja2V0ID0gTWF0aC5yYW5kb20oKTsgLy8gRG8gbm90IGNoZWNrIHdoZXRoZXIgYHRyaWdnZXJgIGlzICdub25lJyBoZXJlLCBiZWNhdXNlIGB0cmlnZ2VyYFxuICAgIC8vIG9ubHkgd29ya3Mgb24gY29vcmlkaW5hdGUgc3lzdGVtLiBJbiBmYWN0LCB3ZSBoYXZlIG5vdCBmb3VuZCBjYXNlXG4gICAgLy8gdGhhdCByZXF1aXJlcyBzZXR0aW5nIGB0cmlnZ2VyYCBub3RoaW5nIG9uIGNvbXBvbmVudCB5ZXQuXG5cbiAgICB0aGlzLl9zaG93T3JNb3ZlKHN1YlRvb2x0aXBNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KHN1YlRvb2x0aXBNb2RlbCwgZGVmYXVsdEh0bWwsIHN1YlRvb2x0aXBNb2RlbC5nZXQoJ2Zvcm1hdHRlclBhcmFtcycpIHx8IHt9LCBhc3luY1RpY2tldCwgZS5vZmZzZXRYLCBlLm9mZnNldFksIGUucG9zaXRpb24sIGVsKTtcbiAgICB9KTsgLy8gSWYgbm90IGRpc3BhdGNoIHNob3dUaXAsIHRpcCBtYXkgYmUgaGlkZSB0cmlnZ2VyZWQgYnkgYXhpcy5cblxuXG4gICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgZnJvbTogdGhpcy51aWRcbiAgICB9KTtcbiAgfSxcbiAgX3Nob3dUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZGVmYXVsdEh0bWwsIHBhcmFtcywgYXN5bmNUaWNrZXQsIHgsIHksIHBvc2l0aW9uRXhwciwgZWwpIHtcbiAgICAvLyBSZXNldCB0aWNrZXRcbiAgICB0aGlzLl90aWNrZXQgPSAnJztcblxuICAgIGlmICghdG9vbHRpcE1vZGVsLmdldCgnc2hvd0NvbnRlbnQnKSB8fCAhdG9vbHRpcE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Zvcm1hdHRlcicpO1xuICAgIHBvc2l0aW9uRXhwciA9IHBvc2l0aW9uRXhwciB8fCB0b29sdGlwTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgIHZhciBodG1sID0gZGVmYXVsdEh0bWw7XG5cbiAgICBpZiAoZm9ybWF0dGVyICYmIHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBodG1sID0gZm9ybWF0VXRpbC5mb3JtYXRUcGwoZm9ybWF0dGVyLCBwYXJhbXMsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNhbGxiYWNrID0gYmluZChmdW5jdGlvbiAoY2JUaWNrZXQsIGh0bWwpIHtcbiAgICAgICAgaWYgKGNiVGlja2V0ID09PSB0aGlzLl90aWNrZXQpIHtcbiAgICAgICAgICB0b29sdGlwQ29udGVudC5zZXRDb250ZW50KGh0bWwpO1xuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24odG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIGVsKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLl90aWNrZXQgPSBhc3luY1RpY2tldDtcbiAgICAgIGh0bWwgPSBmb3JtYXR0ZXIocGFyYW1zLCBhc3luY1RpY2tldCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCk7XG4gICAgdG9vbHRpcENvbnRlbnQuc2hvdyh0b29sdGlwTW9kZWwpO1xuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24odG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIGVsKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7c3RyaW5nfEZ1bmN0aW9ufEFycmF5LjxudW1iZXI+fE9iamVjdH0gcG9zaXRpb25FeHByXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBNb3VzZSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geSBNb3VzZSB5XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGNvbmZpbmUgV2hldGhlciBjb25maW5lIHRvb2x0aXAgY29udGVudCBpbiB2aWV3IHJlY3QuXG4gICAqIEBwYXJhbSAge09iamVjdHw8QXJyYXkuPE9iamVjdD59IHBhcmFtc1xuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgcG9zaXRpb25FeHByLCB4LCB5LCBjb250ZW50LCBwYXJhbXMsIGVsKSB7XG4gICAgdmFyIHZpZXdXaWR0aCA9IHRoaXMuX2FwaS5nZXRXaWR0aCgpO1xuXG4gICAgdmFyIHZpZXdIZWlnaHQgPSB0aGlzLl9hcGkuZ2V0SGVpZ2h0KCk7XG5cbiAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIgfHwgdG9vbHRpcE1vZGVsLmdldCgncG9zaXRpb24nKTtcbiAgICB2YXIgY29udGVudFNpemUgPSBjb250ZW50LmdldFNpemUoKTtcbiAgICB2YXIgYWxpZ24gPSB0b29sdGlwTW9kZWwuZ2V0KCdhbGlnbicpO1xuICAgIHZhciB2QWxpZ24gPSB0b29sdGlwTW9kZWwuZ2V0KCd2ZXJ0aWNhbEFsaWduJyk7XG4gICAgdmFyIHJlY3QgPSBlbCAmJiBlbC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICAgIGVsICYmIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcblxuICAgIGlmICh0eXBlb2YgcG9zaXRpb25FeHByID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBDYWxsYmFjayBvZiBwb3NpdGlvbiBjYW4gYmUgYW4gYXJyYXkgb3IgYSBzdHJpbmcgc3BlY2lmeSB0aGUgcG9zaXRpb25cbiAgICAgIHBvc2l0aW9uRXhwciA9IHBvc2l0aW9uRXhwcihbeCwgeV0sIHBhcmFtcywgY29udGVudC5lbCwgcmVjdCwge1xuICAgICAgICB2aWV3U2l6ZTogW3ZpZXdXaWR0aCwgdmlld0hlaWdodF0sXG4gICAgICAgIGNvbnRlbnRTaXplOiBjb250ZW50U2l6ZS5zbGljZSgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoenJVdGlsLmlzQXJyYXkocG9zaXRpb25FeHByKSkge1xuICAgICAgeCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkV4cHJbMF0sIHZpZXdXaWR0aCk7XG4gICAgICB5ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uRXhwclsxXSwgdmlld0hlaWdodCk7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNPYmplY3QocG9zaXRpb25FeHByKSkge1xuICAgICAgcG9zaXRpb25FeHByLndpZHRoID0gY29udGVudFNpemVbMF07XG4gICAgICBwb3NpdGlvbkV4cHIuaGVpZ2h0ID0gY29udGVudFNpemVbMV07XG4gICAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dFV0aWwuZ2V0TGF5b3V0UmVjdChwb3NpdGlvbkV4cHIsIHtcbiAgICAgICAgd2lkdGg6IHZpZXdXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB2aWV3SGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHggPSBsYXlvdXRSZWN0Lng7XG4gICAgICB5ID0gbGF5b3V0UmVjdC55O1xuICAgICAgYWxpZ24gPSBudWxsOyAvLyBXaGVuIHBvc2l0aW9uRXhwciBpcyBsZWZ0L3RvcC9yaWdodC9ib3R0b20sXG4gICAgICAvLyBhbGlnbiBhbmQgdmVydGljYWxBbGlnbiB3aWxsIG5vdCB3b3JrLlxuXG4gICAgICB2QWxpZ24gPSBudWxsO1xuICAgIH0gLy8gU3BlY2lmeSB0b29sdGlwIHBvc2l0aW9uIGJ5IHN0cmluZyAndG9wJyAnYm90dG9tJyAnbGVmdCcgJ3JpZ2h0JyBhcm91bmQgZ3JhcGhpYyBlbGVtZW50XG4gICAgZWxzZSBpZiAodHlwZW9mIHBvc2l0aW9uRXhwciA9PT0gJ3N0cmluZycgJiYgZWwpIHtcbiAgICAgICAgdmFyIHBvcyA9IGNhbGNUb29sdGlwUG9zaXRpb24ocG9zaXRpb25FeHByLCByZWN0LCBjb250ZW50U2l6ZSk7XG4gICAgICAgIHggPSBwb3NbMF07XG4gICAgICAgIHkgPSBwb3NbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcG9zID0gcmVmaXhUb29sdGlwUG9zaXRpb24oeCwgeSwgY29udGVudC5lbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0LCBhbGlnbiA/IG51bGwgOiAyMCwgdkFsaWduID8gbnVsbCA6IDIwKTtcbiAgICAgICAgeCA9IHBvc1swXTtcbiAgICAgICAgeSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgIGFsaWduICYmICh4IC09IGlzQ2VudGVyQWxpZ24oYWxpZ24pID8gY29udGVudFNpemVbMF0gLyAyIDogYWxpZ24gPT09ICdyaWdodCcgPyBjb250ZW50U2l6ZVswXSA6IDApO1xuICAgIHZBbGlnbiAmJiAoeSAtPSBpc0NlbnRlckFsaWduKHZBbGlnbikgPyBjb250ZW50U2l6ZVsxXSAvIDIgOiB2QWxpZ24gPT09ICdib3R0b20nID8gY29udGVudFNpemVbMV0gOiAwKTtcblxuICAgIGlmICh0b29sdGlwTW9kZWwuZ2V0KCdjb25maW5lJykpIHtcbiAgICAgIHZhciBwb3MgPSBjb25maW5lVG9vbHRpcFBvc2l0aW9uKHgsIHksIGNvbnRlbnQuZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgICB4ID0gcG9zWzBdO1xuICAgICAgeSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICBjb250ZW50Lm1vdmVUbyh4LCB5KTtcbiAgfSxcbiAgLy8gRklYTUVcbiAgLy8gU2hvdWxkIHdlIHJlbW92ZSB0aGlzIGJ1dCBsZWF2ZSB0aGlzIHRvIHVzZXI/XG4gIF91cGRhdGVDb250ZW50Tm90Q2hhbmdlZE9uQXhpczogZnVuY3Rpb24gKGRhdGFCeUNvb3JkU3lzKSB7XG4gICAgdmFyIGxhc3RDb29yZFN5cyA9IHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cztcbiAgICB2YXIgY29udGVudE5vdENoYW5nZWQgPSAhIWxhc3RDb29yZFN5cyAmJiBsYXN0Q29vcmRTeXMubGVuZ3RoID09PSBkYXRhQnlDb29yZFN5cy5sZW5ndGg7XG4gICAgY29udGVudE5vdENoYW5nZWQgJiYgZWFjaChsYXN0Q29vcmRTeXMsIGZ1bmN0aW9uIChsYXN0SXRlbUNvb3JkU3lzLCBpbmRleENvb3JkU3lzKSB7XG4gICAgICB2YXIgbGFzdERhdGFCeUF4aXMgPSBsYXN0SXRlbUNvb3JkU3lzLmRhdGFCeUF4aXMgfHwge307XG4gICAgICB2YXIgdGhpc0l0ZW1Db29yZFN5cyA9IGRhdGFCeUNvb3JkU3lzW2luZGV4Q29vcmRTeXNdIHx8IHt9O1xuICAgICAgdmFyIHRoaXNEYXRhQnlBeGlzID0gdGhpc0l0ZW1Db29yZFN5cy5kYXRhQnlBeGlzIHx8IFtdO1xuICAgICAgY29udGVudE5vdENoYW5nZWQgJj0gbGFzdERhdGFCeUF4aXMubGVuZ3RoID09PSB0aGlzRGF0YUJ5QXhpcy5sZW5ndGg7XG4gICAgICBjb250ZW50Tm90Q2hhbmdlZCAmJiBlYWNoKGxhc3REYXRhQnlBeGlzLCBmdW5jdGlvbiAobGFzdEl0ZW0sIGluZGV4QXhpcykge1xuICAgICAgICB2YXIgdGhpc0l0ZW0gPSB0aGlzRGF0YUJ5QXhpc1tpbmRleEF4aXNdIHx8IHt9O1xuICAgICAgICB2YXIgbGFzdEluZGljZXMgPSBsYXN0SXRlbS5zZXJpZXNEYXRhSW5kaWNlcyB8fCBbXTtcbiAgICAgICAgdmFyIG5ld0luZGljZXMgPSB0aGlzSXRlbS5zZXJpZXNEYXRhSW5kaWNlcyB8fCBbXTtcbiAgICAgICAgY29udGVudE5vdENoYW5nZWQgJj0gbGFzdEl0ZW0udmFsdWUgPT09IHRoaXNJdGVtLnZhbHVlICYmIGxhc3RJdGVtLmF4aXNUeXBlID09PSB0aGlzSXRlbS5heGlzVHlwZSAmJiBsYXN0SXRlbS5heGlzSWQgPT09IHRoaXNJdGVtLmF4aXNJZCAmJiBsYXN0SW5kaWNlcy5sZW5ndGggPT09IG5ld0luZGljZXMubGVuZ3RoO1xuICAgICAgICBjb250ZW50Tm90Q2hhbmdlZCAmJiBlYWNoKGxhc3RJbmRpY2VzLCBmdW5jdGlvbiAobGFzdElkeEl0ZW0sIGopIHtcbiAgICAgICAgICB2YXIgbmV3SWR4SXRlbSA9IG5ld0luZGljZXNbal07XG4gICAgICAgICAgY29udGVudE5vdENoYW5nZWQgJj0gbGFzdElkeEl0ZW0uc2VyaWVzSW5kZXggPT09IG5ld0lkeEl0ZW0uc2VyaWVzSW5kZXggJiYgbGFzdElkeEl0ZW0uZGF0YUluZGV4ID09PSBuZXdJZHhJdGVtLmRhdGFJbmRleDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBkYXRhQnlDb29yZFN5cztcbiAgICByZXR1cm4gISFjb250ZW50Tm90Q2hhbmdlZDtcbiAgfSxcbiAgX2hpZGU6IGZ1bmN0aW9uIChkaXNwYXRjaEFjdGlvbikge1xuICAgIC8vIERvIG5vdCBkaXJlY3RseSBoaWRlTGF0ZXIgaGVyZSwgYmVjYXVzZSB0aGlzIGJlaGF2aW9yIG1heSBiZSBwcmV2ZW50ZWRcbiAgICAvLyBpbiBkaXNwYXRjaEFjdGlvbiB3aGVuIHNob3dUaXAgaXMgZGlzcGF0Y2hlZC5cbiAgICAvLyBGSVhNRVxuICAgIC8vIGR1cGxpY2F0ZWQgaGlkZVRpcCBpZiBtYW51YWxseUhpZGVUaXAgaXMgY2FsbGVkIGZyb20gZGlzcGF0Y2hBY3Rpb24uXG4gICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcbiAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnaGlkZVRpcCcsXG4gICAgICBmcm9tOiB0aGlzLnVpZFxuICAgIH0pO1xuICB9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdG9vbHRpcENvbnRlbnQuaGlkZSgpO1xuXG4gICAgZ2xvYmFsTGlzdGVuZXIudW5yZWdpc3RlcignaXRlbVRvb2x0aXAnLCBhcGkpO1xuICB9XG59KTtcbi8qKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0fG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPn0gbW9kZWxDYXNjYWRlXG4gKiBGcm9tIHRvcCB0byBib3R0b20uICh0aGUgbGFzdCBvbmUgc2hvdWxkIGJlIGdsb2JhbFRvb2x0aXBNb2RlbCk7XG4gKi9cblxuXG5mdW5jdGlvbiBidWlsZFRvb2x0aXBNb2RlbChtb2RlbENhc2NhZGUpIHtcbiAgdmFyIHJlc3VsdE1vZGVsID0gbW9kZWxDYXNjYWRlLnBvcCgpO1xuXG4gIHdoaWxlIChtb2RlbENhc2NhZGUubGVuZ3RoKSB7XG4gICAgdmFyIHRvb2x0aXBPcHQgPSBtb2RlbENhc2NhZGUucG9wKCk7XG5cbiAgICBpZiAodG9vbHRpcE9wdCkge1xuICAgICAgaWYgKHRvb2x0aXBPcHQgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICB0b29sdGlwT3B0ID0gdG9vbHRpcE9wdC5nZXQoJ3Rvb2x0aXAnLCB0cnVlKTtcbiAgICAgIH0gLy8gSW4gZWFjaCBkYXRhIGl0ZW0gdG9vbHRpcCBjYW4gYmUgc2ltcGx5IHdyaXRlOlxuICAgICAgLy8ge1xuICAgICAgLy8gIHZhbHVlOiAxMCxcbiAgICAgIC8vICB0b29sdGlwOiAnU29tZXRoaW5nIHlvdSBuZWVkIHRvIGtub3cnXG4gICAgICAvLyB9XG5cblxuICAgICAgaWYgKHR5cGVvZiB0b29sdGlwT3B0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b29sdGlwT3B0ID0ge1xuICAgICAgICAgIGZvcm1hdHRlcjogdG9vbHRpcE9wdFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXN1bHRNb2RlbCA9IG5ldyBNb2RlbCh0b29sdGlwT3B0LCByZXN1bHRNb2RlbCwgcmVzdWx0TW9kZWwuZWNNb2RlbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdE1vZGVsO1xufVxuXG5mdW5jdGlvbiBtYWtlRGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCwgYXBpKSB7XG4gIHJldHVybiBwYXlsb2FkLmRpc3BhdGNoQWN0aW9uIHx8IHpyVXRpbC5iaW5kKGFwaS5kaXNwYXRjaEFjdGlvbiwgYXBpKTtcbn1cblxuZnVuY3Rpb24gcmVmaXhUb29sdGlwUG9zaXRpb24oeCwgeSwgZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgZ2FwSCwgZ2FwVikge1xuICB2YXIgc2l6ZSA9IGdldE91dGVyU2l6ZShlbCk7XG4gIHZhciB3aWR0aCA9IHNpemUud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcblxuICBpZiAoZ2FwSCAhPSBudWxsKSB7XG4gICAgaWYgKHggKyB3aWR0aCArIGdhcEggPiB2aWV3V2lkdGgpIHtcbiAgICAgIHggLT0gd2lkdGggKyBnYXBIO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IGdhcEg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGdhcFYgIT0gbnVsbCkge1xuICAgIGlmICh5ICsgaGVpZ2h0ICsgZ2FwViA+IHZpZXdIZWlnaHQpIHtcbiAgICAgIHkgLT0gaGVpZ2h0ICsgZ2FwVjtcbiAgICB9IGVsc2Uge1xuICAgICAgeSArPSBnYXBWO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbeCwgeV07XG59XG5cbmZ1bmN0aW9uIGNvbmZpbmVUb29sdGlwUG9zaXRpb24oeCwgeSwgZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICB2YXIgc2l6ZSA9IGdldE91dGVyU2l6ZShlbCk7XG4gIHZhciB3aWR0aCA9IHNpemUud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgeCA9IE1hdGgubWluKHggKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xuICB5ID0gTWF0aC5taW4oeSArIGhlaWdodCwgdmlld0hlaWdodCkgLSBoZWlnaHQ7XG4gIHggPSBNYXRoLm1heCh4LCAwKTtcbiAgeSA9IE1hdGgubWF4KHksIDApO1xuICByZXR1cm4gW3gsIHldO1xufVxuXG5mdW5jdGlvbiBnZXRPdXRlclNpemUoZWwpIHtcbiAgdmFyIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7IC8vIENvbnNpZGVyIGJyb3dzZXIgY29tcGF0aWJpbGl0eS5cbiAgLy8gSUU4IGRvZXMgbm90IHN1cHBvcnQgZ2V0Q29tcHV0ZWRTdHlsZS5cblxuICBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIHZhciBzdGwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcblxuICAgIGlmIChzdGwpIHtcbiAgICAgIHdpZHRoICs9IHBhcnNlSW50KHN0bC5wYWRkaW5nTGVmdCwgMTApICsgcGFyc2VJbnQoc3RsLnBhZGRpbmdSaWdodCwgMTApICsgcGFyc2VJbnQoc3RsLmJvcmRlckxlZnRXaWR0aCwgMTApICsgcGFyc2VJbnQoc3RsLmJvcmRlclJpZ2h0V2lkdGgsIDEwKTtcbiAgICAgIGhlaWdodCArPSBwYXJzZUludChzdGwucGFkZGluZ1RvcCwgMTApICsgcGFyc2VJbnQoc3RsLnBhZGRpbmdCb3R0b20sIDEwKSArIHBhcnNlSW50KHN0bC5ib3JkZXJUb3BXaWR0aCwgMTApICsgcGFyc2VJbnQoc3RsLmJvcmRlckJvdHRvbVdpZHRoLCAxMCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsY1Rvb2x0aXBQb3NpdGlvbihwb3NpdGlvbiwgcmVjdCwgY29udGVudFNpemUpIHtcbiAgdmFyIGRvbVdpZHRoID0gY29udGVudFNpemVbMF07XG4gIHZhciBkb21IZWlnaHQgPSBjb250ZW50U2l6ZVsxXTtcbiAgdmFyIGdhcCA9IDU7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcblxuICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggLyAyIC0gZG9tV2lkdGggLyAyO1xuICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggLyAyIC0gZG9tV2lkdGggLyAyO1xuICAgICAgeSA9IHJlY3QueSAtIGRvbUhlaWdodCAtIGdhcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggLyAyIC0gZG9tV2lkdGggLyAyO1xuICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgKyBnYXA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgeCA9IHJlY3QueCAtIGRvbVdpZHRoIC0gZ2FwO1xuICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCArIGdhcDtcbiAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gIH1cblxuICByZXR1cm4gW3gsIHldO1xufVxuXG5mdW5jdGlvbiBpc0NlbnRlckFsaWduKGFsaWduKSB7XG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcicgfHwgYWxpZ24gPT09ICdtaWRkbGUnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vICgxKSBUaGUgY29kZSBgaWYgKF9fREVWX18pIC4uLmAgY2FuIGJlIHJlbW92ZWQgYnkgYnVpbGQgdG9vbC5cbi8vICgyKSBJZiBpbnRlbmQgdG8gdXNlIGBfX0RFVl9fYCwgdGhpcyBtb2R1bGUgc2hvdWxkIGJlIGltcG9ydGVkLiBVc2UgYSBnbG9iYWxcbi8vIHZhcmlhYmxlIGBfX0RFVl9fYCBtYXkgY2F1c2UgdGhhdCBtaXNzIHRoZSBkZWNsYXJhdGlvbiAoc2VlICM2NTM1KSwgb3IgdGhlXG4vLyBkZWNsYXJhdGlvbiBpcyBiZWhpbmQgb2YgdGhlIHVzaW5nIHBvc2l0aW9uIChmb3IgZXhhbXBsZSBpbiBgTW9kZWwuZXh0ZW50YCxcbi8vIEFuZCB0b29scyBsaWtlIHJvbGx1cCBjYW4gbm90IGFuYWx5c2lzIHRoZSBkZXBlbmRlbmN5IGlmIG5vdCBpbXBvcnQpLlxudmFyIGRldjsgLy8gSW4gYnJvd3NlclxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZGV2ID0gd2luZG93Ll9fREVWX187XG59IC8vIEluIG5vZGVcbmVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGV2ID0gZ2xvYmFsLl9fREVWX187XG4gIH1cblxuaWYgKHR5cGVvZiBkZXYgPT09ICd1bmRlZmluZWQnKSB7XG4gIGRldiA9IHRydWU7XG59XG5cbnZhciBfX0RFVl9fID0gZGV2O1xuZXhwb3J0cy5fX0RFVl9fID0gX19ERVZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL251bWJlclwiKTtcblxudmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKFwiLi9heGlzSGVscGVyXCIpO1xuXG52YXIgbGluZWFyTWFwID0gbnVtYmVyVXRpbC5saW5lYXJNYXA7XG5cbmZ1bmN0aW9uIGZpeEV4dGVudFdpdGhCYW5kcyhleHRlbnQsIG5UaWNrKSB7XG4gIHZhciBzaXplID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICB2YXIgbGVuID0gblRpY2s7XG4gIHZhciBtYXJnaW4gPSBzaXplIC8gbGVuIC8gMjtcbiAgZXh0ZW50WzBdICs9IG1hcmdpbjtcbiAgZXh0ZW50WzFdIC09IG1hcmdpbjtcbn1cblxudmFyIG5vcm1hbGl6ZWRFeHRlbnQgPSBbMCwgMV07XG4vKipcbiAqIEBuYW1lIG1vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbkF4aXNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBBeGlzID0gZnVuY3Rpb24gKGRpbSwgc2NhbGUsIGV4dGVudCkge1xuICAvKipcbiAgICogQXhpcyBkaW1lbnNpb24uIFN1Y2ggYXMgJ3gnLCAneScsICd6JywgJ2FuZ2xlJywgJ3JhZGl1cydcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuZGltID0gZGltO1xuICAvKipcbiAgICogQXhpcyBzY2FsZVxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29vcmQvc2NhbGUvKn1cbiAgICovXG5cbiAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9leHRlbnQgPSBleHRlbnQgfHwgWzAsIDBdO1xuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMuaW52ZXJzZSA9IGZhbHNlO1xuICAvKipcbiAgICogVXN1YWxseSB0cnVlIHdoZW4gYXhpcyBoYXMgYSBvcmRpbmFsIHNjYWxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuICB0aGlzLm9uQmFuZCA9IGZhbHNlO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fbGFiZWxJbnRlcnZhbDtcbn07XG5cbkF4aXMucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQXhpcyxcblxuICAvKipcbiAgICogSWYgYXhpcyBleHRlbnQgY29udGFpbiBnaXZlbiBjb29yZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY29vcmRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW46IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgoZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICAgIHJldHVybiBjb29yZCA+PSBtaW4gJiYgY29vcmQgPD0gbWF4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBheGlzIGV4dGVudCBjb250YWluIGdpdmVuIGRhdGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5EYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW4odGhpcy5kYXRhVG9Db29yZChkYXRhKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjb29yZCBleHRlbnQuXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZ2V0RXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dGVudC5zbGljZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcHJlY2lzaW9uIHVzZWQgZm9yIGZvcm1hdHRpbmdcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW2RhdGFFeHRlbnRdXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFBpeGVsUHJlY2lzaW9uOiBmdW5jdGlvbiAoZGF0YUV4dGVudCkge1xuICAgIHJldHVybiBudW1iZXJVdGlsLmdldFBpeGVsUHJlY2lzaW9uKGRhdGFFeHRlbnQgfHwgdGhpcy5zY2FsZS5nZXRFeHRlbnQoKSwgdGhpcy5fZXh0ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGNvb3JkIGV4dGVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgKi9cbiAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgZXh0ZW50WzBdID0gc3RhcnQ7XG4gICAgZXh0ZW50WzFdID0gZW5kO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGRhdGEgdG8gY29vcmQuIERhdGEgaXMgdGhlIHJhbmsgaWYgaXQgaGFzIGEgb3JkaW5hbCBzY2FsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkYXRhVG9Db29yZDogZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIGRhdGEgPSBzY2FsZS5ub3JtYWxpemUoZGF0YSk7XG5cbiAgICBpZiAodGhpcy5vbkJhbmQgJiYgc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICBleHRlbnQgPSBleHRlbnQuc2xpY2UoKTtcbiAgICAgIGZpeEV4dGVudFdpdGhCYW5kcyhleHRlbnQsIHNjYWxlLmNvdW50KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lYXJNYXAoZGF0YSwgbm9ybWFsaXplZEV4dGVudCwgZXh0ZW50LCBjbGFtcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgY29vcmQgdG8gZGF0YS4gRGF0YSBpcyB0aGUgcmFuayBpZiBpdCBoYXMgYSBvcmRpbmFsIHNjYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb29yZFxuICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb29yZFRvRGF0YTogZnVuY3Rpb24gKGNvb3JkLCBjbGFtcCkge1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblxuICAgIGlmICh0aGlzLm9uQmFuZCAmJiBzY2FsZS50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgIGV4dGVudCA9IGV4dGVudC5zbGljZSgpO1xuICAgICAgZml4RXh0ZW50V2l0aEJhbmRzKGV4dGVudCwgc2NhbGUuY291bnQoKSk7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBsaW5lYXJNYXAoY29vcmQsIGV4dGVudCwgbm9ybWFsaXplZEV4dGVudCwgY2xhbXApO1xuICAgIHJldHVybiB0aGlzLnNjYWxlLnNjYWxlKHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHBpeGVsIHBvaW50IHRvIGRhdGEgaW4gYXhpc1xuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGRhdGFcbiAgICovXG4gIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7Ly8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGRlcml2ZWQgY2xhc3MgaWYgbmVjZXNzYXJ5LlxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGdldFRpY2tzQ29vcmRzOiBmdW5jdGlvbiAoYWxpZ25XaXRoTGFiZWwpIHtcbiAgICBpZiAodGhpcy5vbkJhbmQgJiYgIWFsaWduV2l0aExhYmVsKSB7XG4gICAgICB2YXIgYmFuZHMgPSB0aGlzLmdldEJhbmRzKCk7XG4gICAgICB2YXIgY29vcmRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29vcmRzLnB1c2goYmFuZHNbaV1bMF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmFuZHNbaSAtIDFdKSB7XG4gICAgICAgIGNvb3Jkcy5wdXNoKGJhbmRzW2kgLSAxXVsxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB6clV0aWwubWFwKHRoaXMuc2NhbGUuZ2V0VGlja3MoKSwgdGhpcy5kYXRhVG9Db29yZCwgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb29yZHMgb2YgbGFiZWxzIGFyZSBvbiB0aGUgdGlja3Mgb3Igb24gdGhlIG1pZGRsZSBvZiBiYW5kc1xuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGdldExhYmVsc0Nvb3JkczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB6clV0aWwubWFwKHRoaXMuc2NhbGUuZ2V0VGlja3MoKSwgdGhpcy5kYXRhVG9Db29yZCwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBiYW5kcy5cbiAgICpcbiAgICogSWYgYXhpcyBoYXMgbGFiZWxzIFsxLCAyLCAzLCA0XS4gQmFuZHMgb24gdGhlIGF4aXMgYXJlXG4gICAqIHwtLS0xLS0tfC0tLTItLS18LS0tMy0tLXwtLS00LS0tfC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICAvLyBGSVhNRSBTaXR1YXRpb24gd2hlbiBsYWJlbHMgaXMgb24gdGlja3NcbiAgZ2V0QmFuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgYmFuZHMgPSBbXTtcbiAgICB2YXIgbGVuID0gdGhpcy5zY2FsZS5jb3VudCgpO1xuICAgIHZhciBzdGFydCA9IGV4dGVudFswXTtcbiAgICB2YXIgZW5kID0gZXh0ZW50WzFdO1xuICAgIHZhciBzcGFuID0gZW5kIC0gc3RhcnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBiYW5kcy5wdXNoKFtzcGFuICogaSAvIGxlbiArIHN0YXJ0LCBzcGFuICogKGkgKyAxKSAvIGxlbiArIHN0YXJ0XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhbmRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgd2lkdGggb2YgYmFuZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRCYW5kV2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGxlbiA9IGRhdGFFeHRlbnRbMV0gLSBkYXRhRXh0ZW50WzBdICsgKHRoaXMub25CYW5kID8gMSA6IDApOyAvLyBGaXggIzI3MjgsIGF2b2lkIE5hTiB3aGVuIG9ubHkgb25lIGRhdGEuXG5cbiAgICBsZW4gPT09IDAgJiYgKGxlbiA9IDEpO1xuICAgIHZhciBzaXplID0gTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pO1xuICAgIHJldHVybiBNYXRoLmFicyhzaXplKSAvIGxlbjtcbiAgfSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGhvcml6b250YWxcbiAgICovXG4gIGlzSG9yaXpvbnRhbDogbnVsbCxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge251bWJlcn0gR2V0IGF4aXMgcm90YXRlLCBieSBkZWdyZWUuXG4gICAqL1xuICBnZXRSb3RhdGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEdldCBpbnRlcnZhbCBvZiB0aGUgYXhpcyBsYWJlbC5cbiAgICogVG8gZ2V0IHByZWNpc2UgcmVzdWx0LCBhdCBsZWFzdCBvbmUgb2YgYGdldFJvdGF0ZWAgYW5kIGBpc0hvcml6b250YWxgXG4gICAqIHNob3VsZCBiZSBpbXBsZW1lbnRlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGFiZWxJbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYWJlbEludGVydmFsID0gdGhpcy5fbGFiZWxJbnRlcnZhbDtcblxuICAgIGlmICghbGFiZWxJbnRlcnZhbCkge1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgbGFiZWxNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJyk7XG4gICAgICBsYWJlbEludGVydmFsID0gbGFiZWxNb2RlbC5nZXQoJ2ludGVydmFsJyk7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgKGxhYmVsSW50ZXJ2YWwgPT0gbnVsbCB8fCBsYWJlbEludGVydmFsID09PSAnYXV0bycpKSB7XG4gICAgICAgIGxhYmVsSW50ZXJ2YWwgPSBheGlzSGVscGVyLmdldEF4aXNMYWJlbEludGVydmFsKHpyVXRpbC5tYXAodGhpcy5zY2FsZS5nZXRUaWNrcygpLCB0aGlzLmRhdGFUb0Nvb3JkLCB0aGlzKSwgYXhpc01vZGVsLmdldEZvcm1hdHRlZExhYmVscygpLCBsYWJlbE1vZGVsLmdldEZvbnQoKSwgdGhpcy5nZXRSb3RhdGUgPyB0aGlzLmdldFJvdGF0ZSgpIDogdGhpcy5pc0hvcml6b250YWwgJiYgIXRoaXMuaXNIb3Jpem9udGFsKCkgPyA5MCA6IDAsIGxhYmVsTW9kZWwuZ2V0KCdyb3RhdGUnKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhYmVsSW50ZXJ2YWwgPSBsYWJlbEludGVydmFsO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbEludGVydmFsO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQXhpcztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvQXhpcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvQXhpcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZGVmYXVsdE9wdGlvbiA9IHtcbiAgc2hvdzogdHJ1ZSxcbiAgemxldmVsOiAwLFxuICAvLyDkuIDnuqflsYLlj6BcbiAgejogMCxcbiAgLy8g5LqM57qn5bGC5Y+gXG4gIC8vIOWPjeWQkeWdkOagh+i9tFxuICBpbnZlcnNlOiBmYWxzZSxcbiAgLy8g5Z2Q5qCH6L205ZCN5a2X77yM6buY6K6k5Li656m6XG4gIG5hbWU6ICcnLFxuICAvLyDlnZDmoIfovbTlkI3lrZfkvY3nva7vvIzmlK/mjIEnc3RhcnQnIHwgJ21pZGRsZScgfCAnZW5kJ1xuICBuYW1lTG9jYXRpb246ICdlbmQnLFxuICAvLyDlnZDmoIfovbTlkI3lrZfml4vovazvvIxkZWdyZWXjgIJcbiAgbmFtZVJvdGF0ZTogbnVsbCxcbiAgLy8gQWRhcHQgdG8gYXhpcyByb3RhdGUsIHdoZW4gbmFtZUxvY2F0aW9uIGlzICdtaWRkbGUnLlxuICBuYW1lVHJ1bmNhdGU6IHtcbiAgICBtYXhXaWR0aDogbnVsbCxcbiAgICBlbGxpcHNpczogJy4uLicsXG4gICAgcGxhY2Vob2xkZXI6ICcuJ1xuICB9LFxuICAvLyDlnZDmoIfovbTmloflrZfmoLflvI/vvIzpu5jorqTlj5blhajlsYDmoLflvI9cbiAgbmFtZVRleHRTdHlsZToge30sXG4gIC8vIOaWh+Wtl+S4jui9tOe6v+i3neemu1xuICBuYW1lR2FwOiAxNSxcbiAgc2lsZW50OiBmYWxzZSxcbiAgLy8gRGVmYXVsdCBmYWxzZSB0byBzdXBwb3J0IHRvb2x0aXAuXG4gIHRyaWdnZXJFdmVudDogZmFsc2UsXG4gIC8vIERlZmF1bHQgZmFsc2UgdG8gYXZvaWQgbGVnYWN5IHVzZXIgZXZlbnQgbGlzdGVuZXIgZmFpbC5cbiAgdG9vbHRpcDoge1xuICAgIHNob3c6IGZhbHNlXG4gIH0sXG4gIGF4aXNQb2ludGVyOiB7fSxcbiAgLy8g5Z2Q5qCH6L2057q/XG4gIGF4aXNMaW5lOiB7XG4gICAgLy8g6buY6K6k5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgIHNob3c6IHRydWUsXG4gICAgb25aZXJvOiB0cnVlLFxuICAgIG9uWmVyb0F4aXNJbmRleDogbnVsbCxcbiAgICAvLyDlsZ7mgKdsaW5lU3R5bGXmjqfliLbnur/mnaHmoLflvI9cbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnIzMzMycsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICB9LFxuICAgIC8vIOWdkOagh+i9tOS4pOerr+eahOeureWktFxuICAgIHN5bWJvbDogWydub25lJywgJ25vbmUnXSxcbiAgICBzeW1ib2xTaXplOiBbMTAsIDE1XVxuICB9LFxuICAvLyDlnZDmoIfovbTlsI/moIforrBcbiAgYXhpc1RpY2s6IHtcbiAgICAvLyDlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCm77yM6buY6K6k5pi+56S6XG4gICAgc2hvdzogdHJ1ZSxcbiAgICAvLyDmjqfliLblsI/moIforrDmmK/lkKblnKhncmlk6YeMXG4gICAgaW5zaWRlOiBmYWxzZSxcbiAgICAvLyDlsZ7mgKdsZW5ndGjmjqfliLbnur/plb9cbiAgICBsZW5ndGg6IDUsXG4gICAgLy8g5bGe5oCnbGluZVN0eWxl5o6n5Yi257q/5p2h5qC35byPXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICB3aWR0aDogMVxuICAgIH1cbiAgfSxcbiAgLy8g5Z2Q5qCH6L205paH5pys5qCH562+77yM6K+m6KeBYXhpcy5heGlzTGFiZWxcbiAgYXhpc0xhYmVsOiB7XG4gICAgc2hvdzogdHJ1ZSxcbiAgICAvLyDmjqfliLbmlofmnKzmoIfnrb7mmK/lkKblnKhncmlk6YeMXG4gICAgaW5zaWRlOiBmYWxzZSxcbiAgICByb3RhdGU6IDAsXG4gICAgc2hvd01pbkxhYmVsOiBudWxsLFxuICAgIC8vIHRydWUgfCBmYWxzZSB8IG51bGwgKGF1dG8pXG4gICAgc2hvd01heExhYmVsOiBudWxsLFxuICAgIC8vIHRydWUgfCBmYWxzZSB8IG51bGwgKGF1dG8pXG4gICAgbWFyZ2luOiA4LFxuICAgIC8vIGZvcm1hdHRlcjogbnVsbCxcbiAgICAvLyDlhbbkvZnlsZ7mgKfpu5jorqTkvb/nlKjlhajlsYDmlofmnKzmoLflvI/vvIzor6bop4FURVhUU1RZTEVcbiAgICBmb250U2l6ZTogMTJcbiAgfSxcbiAgLy8g5YiG6ZqU57q/XG4gIHNwbGl0TGluZToge1xuICAgIC8vIOm7mOiupOaYvuekuu+8jOWxnuaAp3Nob3fmjqfliLbmmL7npLrkuI7lkKZcbiAgICBzaG93OiB0cnVlLFxuICAgIC8vIOWxnuaAp2xpbmVTdHlsZe+8iOivpuingWxpbmVTdHlsZe+8ieaOp+WItue6v+adoeagt+W8j1xuICAgIGxpbmVTdHlsZToge1xuICAgICAgY29sb3I6IFsnI2NjYyddLFxuICAgICAgd2lkdGg6IDEsXG4gICAgICB0eXBlOiAnc29saWQnXG4gICAgfVxuICB9LFxuICAvLyDliIbpmpTljLrln59cbiAgc3BsaXRBcmVhOiB7XG4gICAgLy8g6buY6K6k5LiN5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgIHNob3c6IGZhbHNlLFxuICAgIC8vIOWxnuaAp2FyZWFTdHlsZe+8iOivpuingWFyZWFTdHlsZe+8ieaOp+WItuWMuuWfn+agt+W8j1xuICAgIGFyZWFTdHlsZToge1xuICAgICAgY29sb3I6IFsncmdiYSgyNTAsMjUwLDI1MCwwLjMpJywgJ3JnYmEoMjAwLDIwMCwyMDAsMC4zKSddXG4gICAgfVxuICB9XG59O1xudmFyIGF4aXNEZWZhdWx0ID0ge307XG5heGlzRGVmYXVsdC5jYXRlZ29yeUF4aXMgPSB6clV0aWwubWVyZ2Uoe1xuICAvLyDnsbvnm67otbflp4vlkoznu5PmnZ/kuKTnq6/nqbrnmb3nrZbnlaVcbiAgYm91bmRhcnlHYXA6IHRydWUsXG4gIC8vIHNwbGl0QXJlYToge1xuICAvLyBzaG93OiBmYWxzZVxuICAvLyB9LFxuICBzcGxpdExpbmU6IHtcbiAgICBzaG93OiBmYWxzZVxuICB9LFxuICAvLyDlnZDmoIfovbTlsI/moIforrBcbiAgYXhpc1RpY2s6IHtcbiAgICAvLyBJZiB0aWNrIGlzIGFsaWduIHdpdGggbGFiZWwgd2hlbiBib3VuZGFyeUdhcCBpcyB0cnVlXG4gICAgYWxpZ25XaXRoTGFiZWw6IGZhbHNlLFxuICAgIGludGVydmFsOiAnYXV0bydcbiAgfSxcbiAgLy8g5Z2Q5qCH6L205paH5pys5qCH562+77yM6K+m6KeBYXhpcy5heGlzTGFiZWxcbiAgYXhpc0xhYmVsOiB7XG4gICAgaW50ZXJ2YWw6ICdhdXRvJ1xuICB9XG59LCBkZWZhdWx0T3B0aW9uKTtcbmF4aXNEZWZhdWx0LnZhbHVlQXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gIC8vIOaVsOWAvOi1t+Wni+WSjOe7k+adn+S4pOerr+epuueZveetlueVpVxuICBib3VuZGFyeUdhcDogWzAsIDBdLFxuICAvLyDmnIDlsI/lgLwsIOiuvue9ruaIkCAnZGF0YU1pbicg5YiZ5LuO5pWw5o2u5Lit6K6h566X5pyA5bCP5YC8XG4gIC8vIG1pbjogbnVsbCxcbiAgLy8g5pyA5aSn5YC877yM6K6+572u5oiQICdkYXRhTWF4JyDliJnku47mlbDmja7kuK3orqHnrpfmnIDlpKflgLxcbiAgLy8gbWF4OiBudWxsLFxuICAvLyBSZWFkb25seSBwcm9wLCBzcGVjaWZpZXMgc3RhcnQgdmFsdWUgb2YgdGhlIHJhbmdlIHdoZW4gdXNpbmcgZGF0YSB6b29tLlxuICAvLyByYW5nZVN0YXJ0OiBudWxsXG4gIC8vIFJlYWRvbmx5IHByb3AsIHNwZWNpZmllcyBlbmQgdmFsdWUgb2YgdGhlIHJhbmdlIHdoZW4gdXNpbmcgZGF0YSB6b29tLlxuICAvLyByYW5nZUVuZDogbnVsbFxuICAvLyDohLHnprsw5YC85q+U5L6L77yM5pS+5aSn6IGa54Sm5Yiw5pyA57uIX21pbu+8jF9tYXjljLrpl7RcbiAgLy8gc2NhbGU6IGZhbHNlLFxuICAvLyDliIblibLmrrXmlbDvvIzpu5jorqTkuLo1XG4gIHNwbGl0TnVtYmVyOiA1IC8vIE1pbmltdW0gaW50ZXJ2YWxcbiAgLy8gbWluSW50ZXJ2YWw6IG51bGxcbiAgLy8gbWF4SW50ZXJ2YWw6IG51bGxcblxufSwgZGVmYXVsdE9wdGlvbik7IC8vIEZJWE1FXG5cbmF4aXNEZWZhdWx0LnRpbWVBeGlzID0genJVdGlsLmRlZmF1bHRzKHtcbiAgc2NhbGU6IHRydWUsXG4gIG1pbjogJ2RhdGFNaW4nLFxuICBtYXg6ICdkYXRhTWF4J1xufSwgYXhpc0RlZmF1bHQudmFsdWVBeGlzKTtcbmF4aXNEZWZhdWx0LmxvZ0F4aXMgPSB6clV0aWwuZGVmYXVsdHMoe1xuICBzY2FsZTogdHJ1ZSxcbiAgbG9nQmFzZTogMTBcbn0sIGF4aXNEZWZhdWx0LnZhbHVlQXhpcyk7XG52YXIgX2RlZmF1bHQgPSBheGlzRGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc0RlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNEZWZhdWx0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluL3RleHRcIik7XG5cbnZhciBPcmRpbmFsU2NhbGUgPSByZXF1aXJlKFwiLi4vc2NhbGUvT3JkaW5hbFwiKTtcblxudmFyIEludGVydmFsU2NhbGUgPSByZXF1aXJlKFwiLi4vc2NhbGUvSW50ZXJ2YWxcIik7XG5cbnZhciBTY2FsZSA9IHJlcXVpcmUoXCIuLi9zY2FsZS9TY2FsZVwiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9udW1iZXJcIik7XG5cbnJlcXVpcmUoXCIuLi9zY2FsZS9UaW1lXCIpO1xuXG5yZXF1aXJlKFwiLi4vc2NhbGUvTG9nXCIpO1xuXG4vKipcbiAqIEdldCBheGlzIHNjYWxlIGV4dGVudCBiZWZvcmUgbmljZWQuXG4gKiBJdGVtIG9mIHJldHVybmVkIGFycmF5IGNhbiBvbmx5IGJlIG51bWJlciAoaW5jbHVkaW5nIEluZmluaXR5IGFuZCBOYU4pLlxuICovXG5mdW5jdGlvbiBnZXRTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpIHtcbiAgdmFyIHNjYWxlVHlwZSA9IHNjYWxlLnR5cGU7XG4gIHZhciBtaW4gPSBtb2RlbC5nZXRNaW4oKTtcbiAgdmFyIG1heCA9IG1vZGVsLmdldE1heCgpO1xuICB2YXIgZml4TWluID0gbWluICE9IG51bGw7XG4gIHZhciBmaXhNYXggPSBtYXggIT0gbnVsbDtcbiAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCk7XG4gIHZhciBheGlzRGF0YUxlbjtcbiAgdmFyIGJvdW5kYXJ5R2FwO1xuICB2YXIgc3BhbjtcblxuICBpZiAoc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICBheGlzRGF0YUxlbiA9IChtb2RlbC5nZXQoJ2RhdGEnKSB8fCBbXSkubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kYXJ5R2FwID0gbW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuXG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShib3VuZGFyeUdhcCkpIHtcbiAgICAgIGJvdW5kYXJ5R2FwID0gW2JvdW5kYXJ5R2FwIHx8IDAsIGJvdW5kYXJ5R2FwIHx8IDBdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYm91bmRhcnlHYXBbMF0gPT09ICdib29sZWFuJykge1xuICAgICAgYm91bmRhcnlHYXAgPSBbMCwgMF07XG4gICAgfVxuXG4gICAgYm91bmRhcnlHYXBbMF0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFswXSwgMSk7XG4gICAgYm91bmRhcnlHYXBbMV0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFsxXSwgMSk7XG4gICAgc3BhbiA9IG9yaWdpbmFsRXh0ZW50WzFdIC0gb3JpZ2luYWxFeHRlbnRbMF0gfHwgTWF0aC5hYnMob3JpZ2luYWxFeHRlbnRbMF0pO1xuICB9IC8vIE5vdGljZTogV2hlbiBtaW4vbWF4IGlzIG5vdCBzZXQgKHRoYXQgaXMsIHdoZW4gdGhlcmUgYXJlIG51bGwvdW5kZWZpbmVkLFxuICAvLyB3aGljaCBpcyB0aGUgbW9zdCBjb21tb24gY2FzZSksIHRoZXNlIGNhc2VzIHNob3VsZCBiZSBlbnN1cmVkOlxuICAvLyAoMSkgRm9yICdvcmRpbmFsJywgc2hvdyBhbGwgYXhpcy5kYXRhLlxuICAvLyAoMikgRm9yIG90aGVyczpcbiAgLy8gICAgICArIGBib3VuZGFyeUdhcGAgaXMgYXBwbGllZCAoaWYgbWluL21heCBzZXQsIGJvdW5kYXJ5R2FwIGlzXG4gIC8vICAgICAgZGlzYWJsZWQpLlxuICAvLyAgICAgICsgSWYgYG5lZWRDcm9zc1plcm9gLCBtaW4vbWF4IHNob3VsZCBiZSB6ZXJvLCBvdGhlcndpc2UsIG1pbi9tYXggc2hvdWxkXG4gIC8vICAgICAgYmUgdGhlIHJlc3VsdCB0aGF0IG9yaWdpbmFsRXh0ZW50IGVubGFyZ2VkIGJ5IGJvdW5kYXJ5R2FwLlxuICAvLyAoMykgSWYgbm8gZGF0YSwgaXQgc2hvdWxkIGJlIGVuc3VyZWQgdGhhdCBgc2NhbGUuc2V0QmxhbmtgIGlzIHNldC5cbiAgLy8gRklYTUVcbiAgLy8gKDEpIFdoZW4gbWluL21heCBpcyAnZGF0YU1pbicgb3IgJ2RhdGFNYXgnLCBzaG91bGQgYm91bmRhcnlHYXAgYmUgYWJsZSB0byB1c2VkP1xuICAvLyAoMikgV2hlbiBgbmVlZENyb3NzWmVyb2AgYW5kIGFsbCBkYXRhIGlzIHBvc2l0aXZlL25lZ2F0aXZlLCBzaG91bGQgaXQgYmUgZW5zdXJlZFxuICAvLyB0aGF0IHRoZSByZXN1bHRzIHByb2Nlc3NlZCBieSBib3VuZGFyeUdhcCBhcmUgcG9zaXRpdmUvbmVnYXRpdmU/XG5cblxuICBpZiAobWluID09IG51bGwpIHtcbiAgICBtaW4gPSBzY2FsZVR5cGUgPT09ICdvcmRpbmFsJyA/IGF4aXNEYXRhTGVuID8gMCA6IE5hTiA6IG9yaWdpbmFsRXh0ZW50WzBdIC0gYm91bmRhcnlHYXBbMF0gKiBzcGFuO1xuICB9XG5cbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gc2NhbGVUeXBlID09PSAnb3JkaW5hbCcgPyBheGlzRGF0YUxlbiA/IGF4aXNEYXRhTGVuIC0gMSA6IE5hTiA6IG9yaWdpbmFsRXh0ZW50WzFdICsgYm91bmRhcnlHYXBbMV0gKiBzcGFuO1xuICB9XG5cbiAgaWYgKG1pbiA9PT0gJ2RhdGFNaW4nKSB7XG4gICAgbWluID0gb3JpZ2luYWxFeHRlbnRbMF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1pbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1pbiA9IG1pbih7XG4gICAgICBtaW46IG9yaWdpbmFsRXh0ZW50WzBdLFxuICAgICAgbWF4OiBvcmlnaW5hbEV4dGVudFsxXVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG1heCA9PT0gJ2RhdGFNYXgnKSB7XG4gICAgbWF4ID0gb3JpZ2luYWxFeHRlbnRbMV07XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1heCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1heCA9IG1heCh7XG4gICAgICBtaW46IG9yaWdpbmFsRXh0ZW50WzBdLFxuICAgICAgbWF4OiBvcmlnaW5hbEV4dGVudFsxXVxuICAgIH0pO1xuICB9XG5cbiAgKG1pbiA9PSBudWxsIHx8ICFpc0Zpbml0ZShtaW4pKSAmJiAobWluID0gTmFOKTtcbiAgKG1heCA9PSBudWxsIHx8ICFpc0Zpbml0ZShtYXgpKSAmJiAobWF4ID0gTmFOKTtcbiAgc2NhbGUuc2V0QmxhbmsoenJVdGlsLmVxTmFOKG1pbikgfHwgenJVdGlsLmVxTmFOKG1heCkpOyAvLyBFdmFsdWF0ZSBpZiBheGlzIG5lZWRzIGNyb3NzIHplcm9cblxuICBpZiAobW9kZWwuZ2V0TmVlZENyb3NzWmVybygpKSB7XG4gICAgLy8gQXhpcyBpcyBvdmVyIHplcm8gYW5kIG1pbiBpcyBub3Qgc2V0XG4gICAgaWYgKG1pbiA+IDAgJiYgbWF4ID4gMCAmJiAhZml4TWluKSB7XG4gICAgICBtaW4gPSAwO1xuICAgIH0gLy8gQXhpcyBpcyB1bmRlciB6ZXJvIGFuZCBtYXggaXMgbm90IHNldFxuXG5cbiAgICBpZiAobWluIDwgMCAmJiBtYXggPCAwICYmICFmaXhNYXgpIHtcbiAgICAgIG1heCA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbmZ1bmN0aW9uIG5pY2VTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpIHtcbiAgdmFyIGV4dGVudCA9IGdldFNjYWxlRXh0ZW50KHNjYWxlLCBtb2RlbCk7XG4gIHZhciBmaXhNaW4gPSBtb2RlbC5nZXRNaW4oKSAhPSBudWxsO1xuICB2YXIgZml4TWF4ID0gbW9kZWwuZ2V0TWF4KCkgIT0gbnVsbDtcbiAgdmFyIHNwbGl0TnVtYmVyID0gbW9kZWwuZ2V0KCdzcGxpdE51bWJlcicpO1xuXG4gIGlmIChzY2FsZS50eXBlID09PSAnbG9nJykge1xuICAgIHNjYWxlLmJhc2UgPSBtb2RlbC5nZXQoJ2xvZ0Jhc2UnKTtcbiAgfVxuXG4gIHZhciBzY2FsZVR5cGUgPSBzY2FsZS50eXBlO1xuICBzY2FsZS5zZXRFeHRlbnQoZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICBzY2FsZS5uaWNlRXh0ZW50KHtcbiAgICBzcGxpdE51bWJlcjogc3BsaXROdW1iZXIsXG4gICAgZml4TWluOiBmaXhNaW4sXG4gICAgZml4TWF4OiBmaXhNYXgsXG4gICAgbWluSW50ZXJ2YWw6IHNjYWxlVHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyA/IG1vZGVsLmdldCgnbWluSW50ZXJ2YWwnKSA6IG51bGwsXG4gICAgbWF4SW50ZXJ2YWw6IHNjYWxlVHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyA/IG1vZGVsLmdldCgnbWF4SW50ZXJ2YWwnKSA6IG51bGxcbiAgfSk7IC8vIElmIHNvbWUgb25lIHNwZWNpZmllZCB0aGUgbWluLCBtYXguIEFuZCB0aGUgZGVmYXVsdCBjYWxjdWxhdGVkIGludGVydmFsXG4gIC8vIGlzIG5vdCBnb29kIGVub3VnaC4gSGUgY2FuIHNwZWNpZnkgdGhlIGludGVydmFsLiBJdCBpcyBvZnRlbiBhcHBlYXJlZFxuICAvLyBpbiBhbmdsZSBheGlzIHdpdGggYW5nbGUgMCAtIDM2MC4gSW50ZXJ2YWwgY2FsY3VsYXRlZCBpbiBpbnRlcnZhbCBzY2FsZSBpcyBoYXJkXG4gIC8vIHRvIGJlIDYwLlxuICAvLyBGSVhNRVxuXG4gIHZhciBpbnRlcnZhbCA9IG1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcblxuICBpZiAoaW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgIHNjYWxlLnNldEludGVydmFsICYmIHNjYWxlLnNldEludGVydmFsKGludGVydmFsKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtzdHJpbmd9IFtheGlzVHlwZV0gRGVmYXVsdCByZXRyaWV2ZSBmcm9tIG1vZGVsLnR5cGVcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlLyp9XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZUJ5TW9kZWwobW9kZWwsIGF4aXNUeXBlKSB7XG4gIGF4aXNUeXBlID0gYXhpc1R5cGUgfHwgbW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgaWYgKGF4aXNUeXBlKSB7XG4gICAgc3dpdGNoIChheGlzVHlwZSkge1xuICAgICAgLy8gQnVpbGRpbiBzY2FsZVxuICAgICAgY2FzZSAnY2F0ZWdvcnknOlxuICAgICAgICByZXR1cm4gbmV3IE9yZGluYWxTY2FsZShtb2RlbC5nZXRDYXRlZ29yaWVzKCksIFtJbmZpbml0eSwgLUluZmluaXR5XSk7XG5cbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgICAvLyBFeHRlbmRlZCBzY2FsZSwgbGlrZSB0aW1lIGFuZCBsb2dcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIChTY2FsZS5nZXRDbGFzcyhheGlzVHlwZSkgfHwgSW50ZXJ2YWxTY2FsZSkuY3JlYXRlKG1vZGVsKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGF4aXMgY29yc3MgMFxuICovXG5cblxuZnVuY3Rpb24gaWZBeGlzQ3Jvc3NaZXJvKGF4aXMpIHtcbiAgdmFyIGRhdGFFeHRlbnQgPSBheGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICB2YXIgbWluID0gZGF0YUV4dGVudFswXTtcbiAgdmFyIG1heCA9IGRhdGFFeHRlbnRbMV07XG4gIHJldHVybiAhKG1pbiA+IDAgJiYgbWF4ID4gMCB8fCBtaW4gPCAwICYmIG1heCA8IDApO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0aWNrQ29vcmRzIEluIGF4aXMgc2VsZiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHBhcmFtIHtudW1iZXJ9IGF4aXNSb3RhdGUgMDogdG93YXJkcyByaWdodCBob3Jpem9udGFsbHksIGNsb2NrLXdpc2UgaXMgbmVnYXRpdmUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xhYmVsUm90YXRlPTBdIDA6IHRvd2FyZHMgcmlnaHQgaG9yaXpvbnRhbGx5LCBjbG9jay13aXNlIGlzIG5lZ2F0aXZlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0QXhpc0xhYmVsSW50ZXJ2YWwodGlja0Nvb3JkcywgbGFiZWxzLCBmb250LCBheGlzUm90YXRlLCBsYWJlbFJvdGF0ZSkge1xuICB2YXIgdGV4dFNwYWNlVGFrZW5SZWN0O1xuICB2YXIgYXV0b0xhYmVsSW50ZXJ2YWwgPSAwO1xuICB2YXIgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsID0gMDtcbiAgdmFyIHJvdGF0aW9uID0gKGF4aXNSb3RhdGUgLSBsYWJlbFJvdGF0ZSkgLyAxODAgKiBNYXRoLlBJO1xuICB2YXIgc3RlcCA9IDE7XG5cbiAgaWYgKGxhYmVscy5sZW5ndGggPiA0MCkge1xuICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb24gZm9yIGxhcmdlIGFtb3VudCBvZiBsYWJlbHNcbiAgICBzdGVwID0gTWF0aC5mbG9vcihsYWJlbHMubGVuZ3RoIC8gNDApO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrQ29vcmRzLmxlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgdmFyIHRpY2tDb29yZCA9IHRpY2tDb29yZHNbaV07IC8vIE5vdCBwcmVjaXNlLCBkbyBub3QgY29uc2lkZXIgYWxpZ24gYW5kIHZlcnRpY2FsIGFsaWduXG4gICAgLy8gYW5kIGVhY2ggZGlzdGFuY2UgZnJvbSBheGlzIGxpbmUgeWV0LlxuXG4gICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QobGFiZWxzW2ldLCBmb250LCAnY2VudGVyJywgJ3RvcCcpO1xuICAgIHJlY3QueCArPSB0aWNrQ29vcmQgKiBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgcmVjdC55ICs9IHRpY2tDb29yZCAqIE1hdGguc2luKHJvdGF0aW9uKTsgLy8gTWFnaWMgbnVtYmVyXG5cbiAgICByZWN0LndpZHRoICo9IDEuMztcbiAgICByZWN0LmhlaWdodCAqPSAxLjM7XG5cbiAgICBpZiAoIXRleHRTcGFjZVRha2VuUmVjdCkge1xuICAgICAgdGV4dFNwYWNlVGFrZW5SZWN0ID0gcmVjdC5jbG9uZSgpO1xuICAgIH0gLy8gVGhlcmUgaXMgbm8gc3BhY2UgZm9yIGN1cnJlbnQgbGFiZWw7XG4gICAgZWxzZSBpZiAodGV4dFNwYWNlVGFrZW5SZWN0LmludGVyc2VjdChyZWN0KSkge1xuICAgICAgICBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwrKztcbiAgICAgICAgYXV0b0xhYmVsSW50ZXJ2YWwgPSBNYXRoLm1heChhdXRvTGFiZWxJbnRlcnZhbCwgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHRTcGFjZVRha2VuUmVjdC51bmlvbihyZWN0KTsgLy8gUmVzZXRcblxuICAgICAgICBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwgPSAwO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKGF1dG9MYWJlbEludGVydmFsID09PSAwICYmIHN0ZXAgPiAxKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gKGF1dG9MYWJlbEludGVydmFsICsgMSkgKiBzdGVwIC0gMTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGF4aXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxhYmVsRm9ybWF0dGVyXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEZvcm1hdHRlZExhYmVscyhheGlzLCBsYWJlbEZvcm1hdHRlcikge1xuICB2YXIgc2NhbGUgPSBheGlzLnNjYWxlO1xuICB2YXIgbGFiZWxzID0gc2NhbGUuZ2V0VGlja3NMYWJlbHMoKTtcbiAgdmFyIHRpY2tzID0gc2NhbGUuZ2V0VGlja3MoKTtcblxuICBpZiAodHlwZW9mIGxhYmVsRm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgIGxhYmVsRm9ybWF0dGVyID0gZnVuY3Rpb24gKHRwbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRwbC5yZXBsYWNlKCd7dmFsdWV9JywgdmFsICE9IG51bGwgPyB2YWwgOiAnJyk7XG4gICAgICB9O1xuICAgIH0obGFiZWxGb3JtYXR0ZXIpOyAvLyBDb25zaWRlciBlbXB0eSBhcnJheVxuXG5cbiAgICByZXR1cm4genJVdGlsLm1hcChsYWJlbHMsIGxhYmVsRm9ybWF0dGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4genJVdGlsLm1hcCh0aWNrcywgZnVuY3Rpb24gKHRpY2ssIGlkeCkge1xuICAgICAgcmV0dXJuIGxhYmVsRm9ybWF0dGVyKGdldEF4aXNSYXdWYWx1ZShheGlzLCB0aWNrKSwgaWR4KTtcbiAgICB9LCB0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGFiZWxzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNSYXdWYWx1ZShheGlzLCB2YWx1ZSkge1xuICAvLyBJbiBjYXRlZ29yeSBheGlzIHdpdGggZGF0YSB6b29tLCB0aWNrIGlzIG5vdCB0aGUgb3JpZ2luYWxcbiAgLy8gaW5kZXggb2YgYXhpcy5kYXRhLiBTbyB0aWNrIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2VyXG4gIC8vIGluIGNhdGVnb3J5IGF4aXMuXG4gIHJldHVybiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBheGlzLnNjYWxlLmdldExhYmVsKHZhbHVlKSA6IHZhbHVlO1xufVxuXG5leHBvcnRzLmdldFNjYWxlRXh0ZW50ID0gZ2V0U2NhbGVFeHRlbnQ7XG5leHBvcnRzLm5pY2VTY2FsZUV4dGVudCA9IG5pY2VTY2FsZUV4dGVudDtcbmV4cG9ydHMuY3JlYXRlU2NhbGVCeU1vZGVsID0gY3JlYXRlU2NhbGVCeU1vZGVsO1xuZXhwb3J0cy5pZkF4aXNDcm9zc1plcm8gPSBpZkF4aXNDcm9zc1plcm87XG5leHBvcnRzLmdldEF4aXNMYWJlbEludGVydmFsID0gZ2V0QXhpc0xhYmVsSW50ZXJ2YWw7XG5leHBvcnRzLmdldEZvcm1hdHRlZExhYmVscyA9IGdldEZvcm1hdHRlZExhYmVscztcbmV4cG9ydHMuZ2V0QXhpc1Jhd1ZhbHVlID0gZ2V0QXhpc1Jhd1ZhbHVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNIZWxwZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKFwiLi9heGlzSGVscGVyXCIpO1xuXG5mdW5jdGlvbiBnZXROYW1lKG9iaikge1xuICBpZiAoenJVdGlsLmlzT2JqZWN0KG9iaikgJiYgb2JqLnZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gb2JqLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmogKyAnJztcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXQgbGFiZWxzXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0Rm9ybWF0dGVkTGFiZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGF4aXNIZWxwZXIuZ2V0Rm9ybWF0dGVkTGFiZWxzKHRoaXMuYXhpcywgdGhpcy5nZXQoJ2F4aXNMYWJlbC5mb3JtYXR0ZXInKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjYXRlZ29yaWVzXG4gICAqL1xuICBnZXRDYXRlZ29yaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCd0eXBlJykgPT09ICdjYXRlZ29yeScgJiYgenJVdGlsLm1hcCh0aGlzLmdldCgnZGF0YScpLCBnZXROYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBvcmlnaW5cbiAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ30gbWluIHZhbHVlIG9yICdkYXRhTWluJyBvciBudWxsL3VuZGVmaW5lZCAobWVhbnMgYXV0bykgb3IgTmFOXG4gICAqL1xuICBnZXRNaW46IGZ1bmN0aW9uIChvcmlnaW4pIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIG1pbiA9ICFvcmlnaW4gJiYgb3B0aW9uLnJhbmdlU3RhcnQgIT0gbnVsbCA/IG9wdGlvbi5yYW5nZVN0YXJ0IDogb3B0aW9uLm1pbjtcblxuICAgIGlmICh0aGlzLmF4aXMgJiYgbWluICE9IG51bGwgJiYgbWluICE9PSAnZGF0YU1pbicgJiYgdHlwZW9mIG1pbiAhPT0gJ2Z1bmN0aW9uJyAmJiAhenJVdGlsLmVxTmFOKG1pbikpIHtcbiAgICAgIG1pbiA9IHRoaXMuYXhpcy5zY2FsZS5wYXJzZShtaW4pO1xuICAgIH1cblxuICAgIHJldHVybiBtaW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3JpZ2luXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9IG1heCB2YWx1ZSBvciAnZGF0YU1heCcgb3IgbnVsbC91bmRlZmluZWQgKG1lYW5zIGF1dG8pIG9yIE5hTlxuICAgKi9cbiAgZ2V0TWF4OiBmdW5jdGlvbiAob3JpZ2luKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBtYXggPSAhb3JpZ2luICYmIG9wdGlvbi5yYW5nZUVuZCAhPSBudWxsID8gb3B0aW9uLnJhbmdlRW5kIDogb3B0aW9uLm1heDtcblxuICAgIGlmICh0aGlzLmF4aXMgJiYgbWF4ICE9IG51bGwgJiYgbWF4ICE9PSAnZGF0YU1heCcgJiYgdHlwZW9mIG1heCAhPT0gJ2Z1bmN0aW9uJyAmJiAhenJVdGlsLmVxTmFOKG1heCkpIHtcbiAgICAgIG1heCA9IHRoaXMuYXhpcy5zY2FsZS5wYXJzZShtYXgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXROZWVkQ3Jvc3NaZXJvOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHJldHVybiBvcHRpb24ucmFuZ2VTdGFydCAhPSBudWxsIHx8IG9wdGlvbi5yYW5nZUVuZCAhPSBudWxsID8gZmFsc2UgOiAhb3B0aW9uLnNjYWxlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBheGlzIG1vZGVsIGlmIG5lY2Vzc2FyeS5cbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBjb29yZGluYXRlIHN5c3RlbSBtb2RlbFxuICAgKi9cbiAgZ2V0Q29vcmRTeXNNb2RlbDogenJVdGlsLm5vb3AsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZVN0YXJ0IENhbiBvbmx5IGJlIGZpbml0ZSBudW1iZXIgb3IgbnVsbC91bmRlZmluZWQgb3IgTmFOLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFuZ2VFbmQgQ2FuIG9ubHkgYmUgZmluaXRlIG51bWJlciBvciBudWxsL3VuZGVmaW5lZCBvciBOYU4uXG4gICAqL1xuICBzZXRSYW5nZTogZnVuY3Rpb24gKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSB7XG4gICAgdGhpcy5vcHRpb24ucmFuZ2VTdGFydCA9IHJhbmdlU3RhcnQ7XG4gICAgdGhpcy5vcHRpb24ucmFuZ2VFbmQgPSByYW5nZUVuZDtcbiAgfSxcblxuICAvKipcbiAgICogUmVzZXQgcmFuZ2VcbiAgICovXG4gIHJlc2V0UmFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByYW5nZVN0YXJ0IGFuZCByYW5nZUVuZCBpcyByZWFkb25seS5cbiAgICB0aGlzLm9wdGlvbi5yYW5nZVN0YXJ0ID0gdGhpcy5vcHRpb24ucmFuZ2VFbmQgPSBudWxsO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzTW9kZWxDb21tb25NaXhpbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGF4aXNEZWZhdWx0ID0gcmVxdWlyZShcIi4vYXhpc0RlZmF1bHRcIik7XG5cbnZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoXCIuLi9tb2RlbC9Db21wb25lbnRcIik7XG5cbnZhciBfbGF5b3V0ID0gcmVxdWlyZShcIi4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgZ2V0TGF5b3V0UGFyYW1zID0gX2xheW91dC5nZXRMYXlvdXRQYXJhbXM7XG52YXIgbWVyZ2VMYXlvdXRQYXJhbSA9IF9sYXlvdXQubWVyZ2VMYXlvdXRQYXJhbTtcbi8vIEZJWE1FIGF4aXNUeXBlIGlzIGZpeGVkID9cbnZhciBBWElTX1RZUEVTID0gWyd2YWx1ZScsICdjYXRlZ29yeScsICd0aW1lJywgJ2xvZyddO1xuLyoqXG4gKiBHZW5lcmF0ZSBzdWIgYXhpcyBtb2RlbCBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXNOYW1lICd4JyAneScgJ3JhZGl1cycgJ2FuZ2xlJyAncGFyYWxsZWwnXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gQmFzZUF4aXNNb2RlbENsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBheGlzVHlwZURlZmF1bHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtleHRyYURlZmF1bHRPcHRpb25dXG4gKi9cblxuZnVuY3Rpb24gX2RlZmF1bHQoYXhpc05hbWUsIEJhc2VBeGlzTW9kZWxDbGFzcywgYXhpc1R5cGVEZWZhdWx0ZXIsIGV4dHJhRGVmYXVsdE9wdGlvbikge1xuICB6clV0aWwuZWFjaChBWElTX1RZUEVTLCBmdW5jdGlvbiAoYXhpc1R5cGUpIHtcbiAgICBCYXNlQXhpc01vZGVsQ2xhc3MuZXh0ZW5kKHtcbiAgICAgIHR5cGU6IGF4aXNOYW1lICsgJ0F4aXMuJyArIGF4aXNUeXBlLFxuICAgICAgbWVyZ2VEZWZhdWx0QW5kVGhlbWU6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG4gICAgICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0TW9kZSA/IGdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG4gICAgICAgIHZhciB0aGVtZU1vZGVsID0gZWNNb2RlbC5nZXRUaGVtZSgpO1xuICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGVtZU1vZGVsLmdldChheGlzVHlwZSArICdBeGlzJykpO1xuICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XG4gICAgICAgIG9wdGlvbi50eXBlID0gYXhpc1R5cGVEZWZhdWx0ZXIoYXhpc05hbWUsIG9wdGlvbik7XG5cbiAgICAgICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgICAgICBtZXJnZUxheW91dFBhcmFtKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcywgbGF5b3V0TW9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0T3B0aW9uOiB6clV0aWwubWVyZ2VBbGwoW3t9LCBheGlzRGVmYXVsdFtheGlzVHlwZSArICdBeGlzJ10sIGV4dHJhRGVmYXVsdE9wdGlvbl0sIHRydWUpXG4gICAgfSk7XG4gIH0pO1xuICBDb21wb25lbnRNb2RlbC5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoYXhpc05hbWUgKyAnQXhpcycsIHpyVXRpbC5jdXJyeShheGlzVHlwZURlZmF1bHRlciwgYXhpc05hbWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzTW9kZWxDcmVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzTW9kZWxDcmVhdG9yLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBBeGlzID0gcmVxdWlyZShcIi4uL0F4aXNcIik7XG5cbi8qKlxuICogRXh0ZW5kIGF4aXMgMmRcbiAqIEBjb25zdHJ1Y3RvciBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXN9XG4gKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gKiBAcGFyYW0geyp9IHNjYWxlXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjb29yZEV4dGVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXNUeXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25cbiAqL1xudmFyIEF4aXMyRCA9IGZ1bmN0aW9uIChkaW0sIHNjYWxlLCBjb29yZEV4dGVudCwgYXhpc1R5cGUsIHBvc2l0aW9uKSB7XG4gIEF4aXMuY2FsbCh0aGlzLCBkaW0sIHNjYWxlLCBjb29yZEV4dGVudCk7XG4gIC8qKlxuICAgKiBBeGlzIHR5cGVcbiAgICogIC0gJ2NhdGVnb3J5J1xuICAgKiAgLSAndmFsdWUnXG4gICAqICAtICd0aW1lJ1xuICAgKiAgLSAnbG9nJ1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLnR5cGUgPSBheGlzVHlwZSB8fCAndmFsdWUnO1xuICAvKipcbiAgICogQXhpcyBwb3NpdGlvblxuICAgKiAgLSAndG9wJ1xuICAgKiAgLSAnYm90dG9tJ1xuICAgKiAgLSAnbGVmdCdcbiAgICogIC0gJ3JpZ2h0J1xuICAgKi9cblxuICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gfHwgJ2JvdHRvbSc7XG59O1xuXG5BeGlzMkQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQXhpczJELFxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBheGlzLCBjYW4gYmUgdXNlZCBhcyBrZXlcbiAgICovXG4gIGluZGV4OiAwLFxuXG4gIC8qKlxuICAgKiBJZiBheGlzIGlzIG9uIHRoZSB6ZXJvIHBvc2l0aW9uIG9mIHRoZSBvdGhlciBheGlzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgb25aZXJvOiBmYWxzZSxcblxuICAvKipcbiAgICogQXhpcyBtb2RlbFxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9XG4gICAqL1xuICBtb2RlbDogbnVsbCxcbiAgaXNIb3Jpem9udGFsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfSxcblxuICAvKipcbiAgICogRWFjaCBpdGVtIGNvb3Jlc3BvbmRzIHRvIHRoaXMuZ2V0RXh0ZW50KCksIHdoaWNoXG4gICAqIG1lYW5zIGdsb2JhbEV4dGVudFswXSBtYXkgZ3JlYXRlciB0aGFuIGdsb2JhbEV4dGVudFsxXSxcbiAgICogdW5sZXNzIGBhc2NgIGlzIGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthc2NdXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZ2V0R2xvYmFsRXh0ZW50OiBmdW5jdGlvbiAoYXNjKSB7XG4gICAgdmFyIHJldCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgcmV0WzBdID0gdGhpcy50b0dsb2JhbENvb3JkKHJldFswXSk7XG4gICAgcmV0WzFdID0gdGhpcy50b0dsb2JhbENvb3JkKHJldFsxXSk7XG4gICAgYXNjICYmIHJldFswXSA+IHJldFsxXSAmJiByZXQucmV2ZXJzZSgpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGdldE90aGVyQXhpczogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ3JpZC5nZXRPdGhlckF4aXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgbGFiZWwgaXMgaWdub3JlZC5cbiAgICogQXV0b21hdGljYWxseSB1c2VkIHdoZW4gYXhpcyBpcyBjYXRlZ29yeSBhbmQgbGFiZWwgY2FuIG5vdCBiZSBhbGwgc2hvd25cbiAgICogQHBhcmFtICB7bnVtYmVyfSAgaWR4XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0xhYmVsSWdub3JlZDogZnVuY3Rpb24gKGlkeCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgIHZhciBsYWJlbEludGVydmFsID0gdGhpcy5nZXRMYWJlbEludGVydmFsKCk7XG4gICAgICByZXR1cm4gdHlwZW9mIGxhYmVsSW50ZXJ2YWwgPT09ICdmdW5jdGlvbicgJiYgIWxhYmVsSW50ZXJ2YWwoaWR4LCB0aGlzLnNjYWxlLmdldExhYmVsKGlkeCkpIHx8IGlkeCAlIChsYWJlbEludGVydmFsICsgMSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7XG4gICAgcmV0dXJuIHRoaXMuY29vcmRUb0RhdGEodGhpcy50b0xvY2FsQ29vcmQocG9pbnRbdGhpcy5kaW0gPT09ICd4JyA/IDAgOiAxXSksIGNsYW1wKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhbnNmb3JtIGdsb2JhbCBjb29yZCB0byBsb2NhbCBjb29yZCxcbiAgICogaS5lLiB2YXIgbG9jYWxDb29yZCA9IGF4aXMudG9Mb2NhbENvb3JkKDgwKTtcbiAgICogZGVzaWduYXRlIGJ5IG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICB0b0xvY2FsQ29vcmQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBnbG9iYWwgY29vcmQgdG8gbG9jYWwgY29vcmQsXG4gICAqIGkuZS4gdmFyIGdsb2JhbENvb3JkID0gYXhpcy50b0xvY2FsQ29vcmQoNDApO1xuICAgKiBkZXNpZ25hdGUgYnkgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWQuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHRvR2xvYmFsQ29vcmQ6IG51bGxcbn07XG56clV0aWwuaW5oZXJpdHMoQXhpczJELCBBeGlzKTtcbnZhciBfZGVmYXVsdCA9IEF4aXMyRDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0F4aXMyRC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0F4aXMyRC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvQ29tcG9uZW50XCIpO1xuXG52YXIgYXhpc01vZGVsQ3JlYXRvciA9IHJlcXVpcmUoXCIuLi9heGlzTW9kZWxDcmVhdG9yXCIpO1xuXG52YXIgYXhpc01vZGVsQ29tbW9uTWl4aW4gPSByZXF1aXJlKFwiLi4vYXhpc01vZGVsQ29tbW9uTWl4aW5cIik7XG5cbnZhciBBeGlzTW9kZWwgPSBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnY2FydGVzaWFuMmRBeGlzJyxcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9XG4gICAqL1xuICBheGlzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBBeGlzTW9kZWwuc3VwZXJBcHBseSh0aGlzLCAnaW5pdCcsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZXNldFJhbmdlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICBBeGlzTW9kZWwuc3VwZXJBcHBseSh0aGlzLCAnbWVyZ2VPcHRpb24nLCBhcmd1bWVudHMpO1xuICAgIHRoaXMucmVzZXRSYW5nZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgQXhpc01vZGVsLnN1cGVyQXBwbHkodGhpcywgJ3Jlc3RvcmVEYXRhJywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnJlc2V0UmFuZ2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH1cbiAgICovXG4gIGdldENvb3JkU3lzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICBtYWluVHlwZTogJ2dyaWQnLFxuICAgICAgaW5kZXg6IHRoaXMub3B0aW9uLmdyaWRJbmRleCxcbiAgICAgIGlkOiB0aGlzLm9wdGlvbi5ncmlkSWRcbiAgICB9KVswXTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldEF4aXNUeXBlKGF4aXNEaW0sIG9wdGlvbikge1xuICAvLyBEZWZhdWx0IGF4aXMgd2l0aCBkYXRhIGlzIGNhdGVnb3J5IGF4aXNcbiAgcmV0dXJuIG9wdGlvbi50eXBlIHx8IChvcHRpb24uZGF0YSA/ICdjYXRlZ29yeScgOiAndmFsdWUnKTtcbn1cblxuenJVdGlsLm1lcmdlKEF4aXNNb2RlbC5wcm90b3R5cGUsIGF4aXNNb2RlbENvbW1vbk1peGluKTtcbnZhciBleHRyYU9wdGlvbiA9IHtcbiAgLy8gZ3JpZEluZGV4OiAwLFxuICAvLyBncmlkSWQ6ICcnLFxuICAvLyBPZmZzZXQgaXMgZm9yIG11bHRpcGxlIGF4aXMgb24gdGhlIHNhbWUgcG9zaXRpb25cbiAgb2Zmc2V0OiAwXG59O1xuYXhpc01vZGVsQ3JlYXRvcigneCcsIEF4aXNNb2RlbCwgZ2V0QXhpc1R5cGUsIGV4dHJhT3B0aW9uKTtcbmF4aXNNb2RlbENyZWF0b3IoJ3knLCBBeGlzTW9kZWwsIGdldEF4aXNUeXBlLCBleHRyYU9wdGlvbik7XG52YXIgX2RlZmF1bHQgPSBBeGlzTW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxuLyoqXG4gKiBDYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1cbiAqIEBtb2R1bGUgIGVjaGFydHMvY29vcmQvQ2FydGVzaWFuXG4gKlxuICovXG5mdW5jdGlvbiBkaW1BeGlzTWFwcGVyKGRpbSkge1xuICByZXR1cm4gdGhpcy5fYXhlc1tkaW1dO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBDYXJ0ZXNpYW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICB0aGlzLl9heGVzID0ge307XG4gIHRoaXMuX2RpbUxpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMubmFtZSA9IG5hbWUgfHwgJyc7XG59O1xuXG5DYXJ0ZXNpYW4ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ2FydGVzaWFuLFxuICB0eXBlOiAnY2FydGVzaWFuJyxcblxuICAvKipcbiAgICogR2V0IGF4aXNcbiAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gZGltXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbn5BeGlzfVxuICAgKi9cbiAgZ2V0QXhpczogZnVuY3Rpb24gKGRpbSkge1xuICAgIHJldHVybiB0aGlzLl9heGVzW2RpbV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBheGVzIGxpc3RcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbn5BeGlzPn1cbiAgICovXG4gIGdldEF4ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4genJVdGlsLm1hcCh0aGlzLl9kaW1MaXN0LCBkaW1BeGlzTWFwcGVyLCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGF4ZXMgbGlzdCBieSBnaXZlbiBzY2FsZSB0eXBlXG4gICAqL1xuICBnZXRBeGVzQnlTY2FsZTogZnVuY3Rpb24gKHNjYWxlVHlwZSkge1xuICAgIHNjYWxlVHlwZSA9IHNjYWxlVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB6clV0aWwuZmlsdGVyKHRoaXMuZ2V0QXhlcygpLCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgcmV0dXJuIGF4aXMuc2NhbGUudHlwZSA9PT0gc2NhbGVUeXBlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYXhpc1xuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbi5BeGlzfVxuICAgKi9cbiAgYWRkQXhpczogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICB2YXIgZGltID0gYXhpcy5kaW07XG4gICAgdGhpcy5fYXhlc1tkaW1dID0gYXhpcztcblxuICAgIHRoaXMuX2RpbUxpc3QucHVzaChkaW0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGRhdGEgdG8gY29vcmQgaW4gbmQgc3BhY2VcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gdmFsXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fE9iamVjdC48c3RyaW5nLCBudW1iZXI+fVxuICAgKi9cbiAgZGF0YVRvQ29vcmQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkQ29udmVydCh2YWwsICdkYXRhVG9Db29yZCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGNvb3JkIGluIG5kIHNwYWNlIHRvIGRhdGFcbiAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHZhbFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAgICovXG4gIGNvb3JkVG9EYXRhOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFDb29yZENvbnZlcnQodmFsLCAnY29vcmRUb0RhdGEnKTtcbiAgfSxcbiAgX2RhdGFDb29yZENvbnZlcnQ6IGZ1bmN0aW9uIChpbnB1dCwgbWV0aG9kKSB7XG4gICAgdmFyIGRpbUxpc3QgPSB0aGlzLl9kaW1MaXN0O1xuICAgIHZhciBvdXRwdXQgPSBpbnB1dCBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRpbSA9IGRpbUxpc3RbaV07XG4gICAgICB2YXIgYXhpcyA9IHRoaXMuX2F4ZXNbZGltXTtcbiAgICAgIG91dHB1dFtkaW1dID0gYXhpc1ttZXRob2RdKGlucHV0W2RpbV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBDYXJ0ZXNpYW47XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIENhcnRlc2lhbiA9IHJlcXVpcmUoXCIuL0NhcnRlc2lhblwiKTtcblxuZnVuY3Rpb24gQ2FydGVzaWFuMkQobmFtZSkge1xuICBDYXJ0ZXNpYW4uY2FsbCh0aGlzLCBuYW1lKTtcbn1cblxuQ2FydGVzaWFuMkQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ2FydGVzaWFuMkQsXG4gIHR5cGU6ICdjYXJ0ZXNpYW4yZCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBkaW1lbnNpb25zOiBbJ3gnLCAneSddLFxuXG4gIC8qKlxuICAgKiBCYXNlIGF4aXMgd2lsbCBiZSB1c2VkIG9uIHN0YWNraW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEfVxuICAgKi9cbiAgZ2V0QmFzZUF4aXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGVzQnlTY2FsZSgnb3JkaW5hbCcpWzBdIHx8IHRoaXMuZ2V0QXhlc0J5U2NhbGUoJ3RpbWUnKVswXSB8fCB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgY29udGFpbiBwb2ludFxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpblBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgYXhpc1ggPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICB2YXIgYXhpc1kgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICByZXR1cm4gYXhpc1guY29udGFpbihheGlzWC50b0xvY2FsQ29vcmQocG9pbnRbMF0pKSAmJiBheGlzWS5jb250YWluKGF4aXNZLnRvTG9jYWxDb29yZChwb2ludFsxXSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBjb250YWluIGRhdGFcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbkRhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXhpcygneCcpLmNvbnRhaW5EYXRhKGRhdGFbMF0pICYmIHRoaXMuZ2V0QXhpcygneScpLmNvbnRhaW5EYXRhKGRhdGFbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsYW1wPWZhbHNlXVxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGRhdGFUb1BvaW50OiBmdW5jdGlvbiAoZGF0YSwgY2xhbXApIHtcbiAgICB2YXIgeEF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICB2YXIgeUF4aXMgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICByZXR1cm4gW3hBeGlzLnRvR2xvYmFsQ29vcmQoeEF4aXMuZGF0YVRvQ29vcmQoZGF0YVswXSwgY2xhbXApKSwgeUF4aXMudG9HbG9iYWxDb29yZCh5QXhpcy5kYXRhVG9Db29yZChkYXRhWzFdLCBjbGFtcCkpXTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9pbnRcbiAgICogQHBhcmFtIHtib29sZWFufSBbY2xhbXA9ZmFsc2VdXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgcG9pbnRUb0RhdGE6IGZ1bmN0aW9uIChwb2ludCwgY2xhbXApIHtcbiAgICB2YXIgeEF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICB2YXIgeUF4aXMgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICByZXR1cm4gW3hBeGlzLmNvb3JkVG9EYXRhKHhBeGlzLnRvTG9jYWxDb29yZChwb2ludFswXSksIGNsYW1wKSwgeUF4aXMuY29vcmRUb0RhdGEoeUF4aXMudG9Mb2NhbENvb3JkKHBvaW50WzFdKSwgY2xhbXApXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IG90aGVyIGF4aXNcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEfSBheGlzXG4gICAqL1xuICBnZXRPdGhlckF4aXM6IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXhpcyhheGlzLmRpbSA9PT0gJ3gnID8gJ3knIDogJ3gnKTtcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhDYXJ0ZXNpYW4yRCwgQ2FydGVzaWFuKTtcbnZhciBfZGVmYXVsdCA9IENhcnRlc2lhbjJEO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuMkQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgX2xheW91dCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xheW91dFwiKTtcblxudmFyIGdldExheW91dFJlY3QgPSBfbGF5b3V0LmdldExheW91dFJlY3Q7XG5cbnZhciBheGlzSGVscGVyID0gcmVxdWlyZShcIi4uLy4uL2Nvb3JkL2F4aXNIZWxwZXJcIik7XG5cbnZhciBDYXJ0ZXNpYW4yRCA9IHJlcXVpcmUoXCIuL0NhcnRlc2lhbjJEXCIpO1xuXG52YXIgQXhpczJEID0gcmVxdWlyZShcIi4vQXhpczJEXCIpO1xuXG52YXIgQ29vcmRpbmF0ZVN5c3RlbSA9IHJlcXVpcmUoXCIuLi8uLi9Db29yZGluYXRlU3lzdGVtXCIpO1xuXG5yZXF1aXJlKFwiLi9HcmlkTW9kZWxcIik7XG5cbi8qKlxuICogR3JpZCBpcyBhIHJlZ2lvbiB3aGljaCBjb250YWlucyBhdCBtb3N0IDQgY2FydGVzaWFuIHN5c3RlbXNcbiAqXG4gKiBUT0RPIERlZmF1bHQgY2FydGVzaWFuXG4gKi9cbi8vIERlcGVuZHMgb24gR3JpZE1vZGVsLCBBeGlzTW9kZWwsIHdoaWNoIHBlcmZvcm1zIHByZXByb2Nlc3MuXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGlmQXhpc0Nyb3NzWmVybyA9IGF4aXNIZWxwZXIuaWZBeGlzQ3Jvc3NaZXJvO1xudmFyIG5pY2VTY2FsZUV4dGVudCA9IGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgYXhpcyBpcyB1c2VkIGluIHRoZSBzcGVjaWZpZWQgZ3JpZFxuICogQGlubmVyXG4gKi9cblxuZnVuY3Rpb24gaXNBeGlzVXNlZEluVGhlR3JpZChheGlzTW9kZWwsIGdyaWRNb2RlbCwgZWNNb2RlbCkge1xuICByZXR1cm4gYXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKSA9PT0gZ3JpZE1vZGVsO1xufVxuXG5mdW5jdGlvbiByb3RhdGVUZXh0UmVjdCh0ZXh0UmVjdCwgcm90YXRlKSB7XG4gIHZhciByb3RhdGVSYWRpYW5zID0gcm90YXRlICogTWF0aC5QSSAvIDE4MDtcbiAgdmFyIGJvdW5kaW5nQm94ID0gdGV4dFJlY3QucGxhaW4oKTtcbiAgdmFyIGJlZm9yZVdpZHRoID0gYm91bmRpbmdCb3gud2lkdGg7XG4gIHZhciBiZWZvcmVIZWlnaHQgPSBib3VuZGluZ0JveC5oZWlnaHQ7XG4gIHZhciBhZnRlcldpZHRoID0gYmVmb3JlV2lkdGggKiBNYXRoLmNvcyhyb3RhdGVSYWRpYW5zKSArIGJlZm9yZUhlaWdodCAqIE1hdGguc2luKHJvdGF0ZVJhZGlhbnMpO1xuICB2YXIgYWZ0ZXJIZWlnaHQgPSBiZWZvcmVXaWR0aCAqIE1hdGguc2luKHJvdGF0ZVJhZGlhbnMpICsgYmVmb3JlSGVpZ2h0ICogTWF0aC5jb3Mocm90YXRlUmFkaWFucyk7XG4gIHZhciByb3RhdGVkUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoYm91bmRpbmdCb3gueCwgYm91bmRpbmdCb3gueSwgYWZ0ZXJXaWR0aCwgYWZ0ZXJIZWlnaHQpO1xuICByZXR1cm4gcm90YXRlZFJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldExhYmVsVW5pb25SZWN0KGF4aXMpIHtcbiAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gIHZhciBsYWJlbHMgPSBheGlzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWxzKCk7XG4gIHZhciBheGlzTGFiZWxNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJyk7XG4gIHZhciByZWN0O1xuICB2YXIgc3RlcCA9IDE7XG4gIHZhciBsYWJlbENvdW50ID0gbGFiZWxzLmxlbmd0aDtcblxuICBpZiAobGFiZWxDb3VudCA+IDQwKSB7XG4gICAgLy8gU2ltcGxlIG9wdGltaXphdGlvbiBmb3IgbGFyZ2UgYW1vdW50IG9mIGxhYmVsc1xuICAgIHN0ZXAgPSBNYXRoLmNlaWwobGFiZWxDb3VudCAvIDQwKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSArPSBzdGVwKSB7XG4gICAgaWYgKCFheGlzLmlzTGFiZWxJZ25vcmVkKGkpKSB7XG4gICAgICB2YXIgdW5yb3RhdGVkU2luZ2xlUmVjdCA9IGF4aXNMYWJlbE1vZGVsLmdldFRleHRSZWN0KGxhYmVsc1tpXSk7XG4gICAgICB2YXIgc2luZ2xlUmVjdCA9IHJvdGF0ZVRleHRSZWN0KHVucm90YXRlZFNpbmdsZVJlY3QsIGF4aXNMYWJlbE1vZGVsLmdldCgncm90YXRlJykgfHwgMCk7XG4gICAgICByZWN0ID8gcmVjdC51bmlvbihzaW5nbGVSZWN0KSA6IHJlY3QgPSBzaW5nbGVSZWN0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBHcmlkKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLl9jb29yZHNNYXAgPSB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2Nvb3Jkc0xpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2F4ZXNNYXAgPSB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2F4ZXNMaXN0ID0gW107XG5cbiAgdGhpcy5faW5pdENhcnRlc2lhbihncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG5cbiAgdGhpcy5tb2RlbCA9IGdyaWRNb2RlbDtcbn1cblxudmFyIGdyaWRQcm90byA9IEdyaWQucHJvdG90eXBlO1xuZ3JpZFByb3RvLnR5cGUgPSAnZ3JpZCc7XG5ncmlkUHJvdG8uYXhpc1BvaW50ZXJFbmFibGVkID0gdHJ1ZTtcblxuZ3JpZFByb3RvLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWN0O1xufTtcblxuZ3JpZFByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGF4ZXNNYXAgPSB0aGlzLl9heGVzTWFwO1xuXG4gIHRoaXMuX3VwZGF0ZVNjYWxlKGVjTW9kZWwsIHRoaXMubW9kZWwpO1xuXG4gIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMpIHtcbiAgICBuaWNlU2NhbGVFeHRlbnQoeEF4aXMuc2NhbGUsIHhBeGlzLm1vZGVsKTtcbiAgfSk7XG4gIGVhY2goYXhlc01hcC55LCBmdW5jdGlvbiAoeUF4aXMpIHtcbiAgICBuaWNlU2NhbGVFeHRlbnQoeUF4aXMuc2NhbGUsIHlBeGlzLm1vZGVsKTtcbiAgfSk7XG4gIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMpIHtcbiAgICBmaXhBeGlzT25aZXJvKGF4ZXNNYXAsICd5JywgeEF4aXMpO1xuICB9KTtcbiAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcykge1xuICAgIGZpeEF4aXNPblplcm8oYXhlc01hcCwgJ3gnLCB5QXhpcyk7XG4gIH0pOyAvLyBSZXNpemUgYWdhaW4gaWYgY29udGFpbkxhYmVsIGlzIGVuYWJsZWRcbiAgLy8gRklYTUUgSXQgbWF5IGNhdXNlIGdldHRpbmcgd3JvbmcgZ3JpZCBzaXplIGluIGRhdGEgcHJvY2Vzc2luZyBzdGFnZVxuXG4gIHRoaXMucmVzaXplKHRoaXMubW9kZWwsIGFwaSk7XG59O1xuXG5mdW5jdGlvbiBmaXhBeGlzT25aZXJvKGF4ZXNNYXAsIG90aGVyQXhpc0RpbSwgYXhpcykge1xuICAvLyBvblplcm8gY2FuIG5vdCBiZSBlbmFibGVkIGluIHRoZXNlIHR3byBzaXR1YXRpb25zOlxuICAvLyAxLiBXaGVuIGFueSBvdGhlciBheGlzIGlzIGEgY2F0ZWdvcnkgYXhpcy5cbiAgLy8gMi4gV2hlbiBubyBheGlzIGlzIGNyb3NzIDAgcG9pbnQuXG4gIHZhciBheGVzID0gYXhlc01hcFtvdGhlckF4aXNEaW1dO1xuXG4gIGlmICghYXhpcy5vblplcm8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb25aZXJvQXhpc0luZGV4ID0gYXhpcy5vblplcm9BeGlzSW5kZXg7IC8vIElmIHRhcmdldCBheGlzIGlzIHNwZWNpZmllZC5cblxuICBpZiAob25aZXJvQXhpc0luZGV4ICE9IG51bGwpIHtcbiAgICB2YXIgb3RoZXJBeGlzID0gYXhlc1tvblplcm9BeGlzSW5kZXhdO1xuXG4gICAgaWYgKG90aGVyQXhpcyAmJiBjYW5Ob3RPblplcm9Ub0F4aXMob3RoZXJBeGlzKSkge1xuICAgICAgYXhpcy5vblplcm8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpZHggaW4gYXhlcykge1xuICAgIGlmIChheGVzLmhhc093blByb3BlcnR5KGlkeCkpIHtcbiAgICAgIHZhciBvdGhlckF4aXMgPSBheGVzW2lkeF07XG5cbiAgICAgIGlmIChvdGhlckF4aXMgJiYgIWNhbk5vdE9uWmVyb1RvQXhpcyhvdGhlckF4aXMpKSB7XG4gICAgICAgIG9uWmVyb0F4aXNJbmRleCA9ICtpZHg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvblplcm9BeGlzSW5kZXggPT0gbnVsbCkge1xuICAgIGF4aXMub25aZXJvID0gZmFsc2U7XG4gIH1cblxuICBheGlzLm9uWmVyb0F4aXNJbmRleCA9IG9uWmVyb0F4aXNJbmRleDtcbn1cblxuZnVuY3Rpb24gY2FuTm90T25aZXJvVG9BeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCBheGlzLnR5cGUgPT09ICd0aW1lJyB8fCAhaWZBeGlzQ3Jvc3NaZXJvKGF4aXMpO1xufVxuLyoqXG4gKiBSZXNpemUgdGhlIGdyaWRcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbH0gZ3JpZE1vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gKi9cblxuXG5ncmlkUHJvdG8ucmVzaXplID0gZnVuY3Rpb24gKGdyaWRNb2RlbCwgYXBpLCBpZ25vcmVDb250YWluTGFiZWwpIHtcbiAgdmFyIGdyaWRSZWN0ID0gZ2V0TGF5b3V0UmVjdChncmlkTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCksIHtcbiAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgfSk7XG4gIHRoaXMuX3JlY3QgPSBncmlkUmVjdDtcbiAgdmFyIGF4ZXNMaXN0ID0gdGhpcy5fYXhlc0xpc3Q7XG4gIGFkanVzdEF4ZXMoKTsgLy8gTWludXMgbGFiZWwgc2l6ZVxuXG4gIGlmICghaWdub3JlQ29udGFpbkxhYmVsICYmIGdyaWRNb2RlbC5nZXQoJ2NvbnRhaW5MYWJlbCcpKSB7XG4gICAgZWFjaChheGVzTGlzdCwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgIGlmICghYXhpcy5tb2RlbC5nZXQoJ2F4aXNMYWJlbC5pbnNpZGUnKSkge1xuICAgICAgICB2YXIgbGFiZWxVbmlvblJlY3QgPSBnZXRMYWJlbFVuaW9uUmVjdChheGlzKTtcblxuICAgICAgICBpZiAobGFiZWxVbmlvblJlY3QpIHtcbiAgICAgICAgICB2YXIgZGltID0gYXhpcy5pc0hvcml6b250YWwoKSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgICB2YXIgbWFyZ2luID0gYXhpcy5tb2RlbC5nZXQoJ2F4aXNMYWJlbC5tYXJnaW4nKTtcbiAgICAgICAgICBncmlkUmVjdFtkaW1dIC09IGxhYmVsVW5pb25SZWN0W2RpbV0gKyBtYXJnaW47XG5cbiAgICAgICAgICBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIGdyaWRSZWN0LnkgKz0gbGFiZWxVbmlvblJlY3QuaGVpZ2h0ICsgbWFyZ2luO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBncmlkUmVjdC54ICs9IGxhYmVsVW5pb25SZWN0LndpZHRoICsgbWFyZ2luO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGFkanVzdEF4ZXMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdEF4ZXMoKSB7XG4gICAgZWFjaChheGVzTGlzdCwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgdmFyIGV4dGVudCA9IGlzSG9yaXpvbnRhbCA/IFswLCBncmlkUmVjdC53aWR0aF0gOiBbMCwgZ3JpZFJlY3QuaGVpZ2h0XTtcbiAgICAgIHZhciBpZHggPSBheGlzLmludmVyc2UgPyAxIDogMDtcbiAgICAgIGF4aXMuc2V0RXh0ZW50KGV4dGVudFtpZHhdLCBleHRlbnRbMSAtIGlkeF0pO1xuICAgICAgdXBkYXRlQXhpc1RyYW5zZnJvbShheGlzLCBpc0hvcml6b250YWwgPyBncmlkUmVjdC54IDogZ3JpZFJlY3QueSk7XG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzVHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IFtheGlzSW5kZXhdXG4gKi9cblxuXG5ncmlkUHJvdG8uZ2V0QXhpcyA9IGZ1bmN0aW9uIChheGlzVHlwZSwgYXhpc0luZGV4KSB7XG4gIHZhciBheGVzTWFwT25EaW0gPSB0aGlzLl9heGVzTWFwW2F4aXNUeXBlXTtcblxuICBpZiAoYXhlc01hcE9uRGltICE9IG51bGwpIHtcbiAgICBpZiAoYXhpc0luZGV4ID09IG51bGwpIHtcbiAgICAgIC8vIEZpbmQgZmlyc3QgYXhpc1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBheGVzTWFwT25EaW0pIHtcbiAgICAgICAgaWYgKGF4ZXNNYXBPbkRpbS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHJldHVybiBheGVzTWFwT25EaW1bbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXhlc01hcE9uRGltW2F4aXNJbmRleF07XG4gIH1cbn07XG4vKipcbiAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzPn1cbiAqL1xuXG5cbmdyaWRQcm90by5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fYXhlc0xpc3Quc2xpY2UoKTtcbn07XG4vKipcbiAqIFVzYWdlOlxuICogICAgICBncmlkLmdldENhcnRlc2lhbih4QXhpc0luZGV4LCB5QXhpc0luZGV4KTtcbiAqICAgICAgZ3JpZC5nZXRDYXJ0ZXNpYW4oeEF4aXNJbmRleCk7XG4gKiAgICAgIGdyaWQuZ2V0Q2FydGVzaWFuKG51bGwsIHlBeGlzSW5kZXgpO1xuICogICAgICBncmlkLmdldENhcnRlc2lhbih7eEF4aXNJbmRleDogLi4uLCB5QXhpc0luZGV4OiAuLi59KTtcbiAqXG4gKiBAcGFyYW0ge251bWJlcnxPYmplY3R9IFt4QXhpc0luZGV4XVxuICogQHBhcmFtIHtudW1iZXJ9IFt5QXhpc0luZGV4XVxuICovXG5cblxuZ3JpZFByb3RvLmdldENhcnRlc2lhbiA9IGZ1bmN0aW9uICh4QXhpc0luZGV4LCB5QXhpc0luZGV4KSB7XG4gIGlmICh4QXhpc0luZGV4ICE9IG51bGwgJiYgeUF4aXNJbmRleCAhPSBudWxsKSB7XG4gICAgdmFyIGtleSA9ICd4JyArIHhBeGlzSW5kZXggKyAneScgKyB5QXhpc0luZGV4O1xuICAgIHJldHVybiB0aGlzLl9jb29yZHNNYXBba2V5XTtcbiAgfVxuXG4gIGlmICh6clV0aWwuaXNPYmplY3QoeEF4aXNJbmRleCkpIHtcbiAgICB5QXhpc0luZGV4ID0geEF4aXNJbmRleC55QXhpc0luZGV4O1xuICAgIHhBeGlzSW5kZXggPSB4QXhpc0luZGV4LnhBeGlzSW5kZXg7XG4gIH0gLy8gV2hlbiBvbmx5IHhBeGlzSW5kZXggb3IgeUF4aXNJbmRleCBnaXZlbiwgZmluZCBpdHMgZmlyc3QgY2FydGVzaWFuLlxuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGNvb3JkTGlzdCA9IHRoaXMuX2Nvb3Jkc0xpc3Q7IGkgPCBjb29yZExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY29vcmRMaXN0W2ldLmdldEF4aXMoJ3gnKS5pbmRleCA9PT0geEF4aXNJbmRleCB8fCBjb29yZExpc3RbaV0uZ2V0QXhpcygneScpLmluZGV4ID09PSB5QXhpc0luZGV4KSB7XG4gICAgICByZXR1cm4gY29vcmRMaXN0W2ldO1xuICAgIH1cbiAgfVxufTtcblxuZ3JpZFByb3RvLmdldENhcnRlc2lhbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9jb29yZHNMaXN0LnNsaWNlKCk7XG59O1xuLyoqXG4gKiBAaW1wbGVtZW50c1xuICogc2VlIHttb2R1bGU6ZWNoYXJ0cy9Db29kaW5hdGVTeXN0ZW19XG4gKi9cblxuXG5ncmlkUHJvdG8uY29udmVydFRvUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICB2YXIgdGFyZ2V0ID0gdGhpcy5fZmluZENvbnZlcnRUYXJnZXQoZWNNb2RlbCwgZmluZGVyKTtcblxuICByZXR1cm4gdGFyZ2V0LmNhcnRlc2lhbiA/IHRhcmdldC5jYXJ0ZXNpYW4uZGF0YVRvUG9pbnQodmFsdWUpIDogdGFyZ2V0LmF4aXMgPyB0YXJnZXQuYXhpcy50b0dsb2JhbENvb3JkKHRhcmdldC5heGlzLmRhdGFUb0Nvb3JkKHZhbHVlKSkgOiBudWxsO1xufTtcbi8qKlxuICogQGltcGxlbWVudHNcbiAqIHNlZSB7bW9kdWxlOmVjaGFydHMvQ29vZGluYXRlU3lzdGVtfVxuICovXG5cblxuZ3JpZFByb3RvLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICB2YXIgdGFyZ2V0ID0gdGhpcy5fZmluZENvbnZlcnRUYXJnZXQoZWNNb2RlbCwgZmluZGVyKTtcblxuICByZXR1cm4gdGFyZ2V0LmNhcnRlc2lhbiA/IHRhcmdldC5jYXJ0ZXNpYW4ucG9pbnRUb0RhdGEodmFsdWUpIDogdGFyZ2V0LmF4aXMgPyB0YXJnZXQuYXhpcy5jb29yZFRvRGF0YSh0YXJnZXQuYXhpcy50b0xvY2FsQ29vcmQodmFsdWUpKSA6IG51bGw7XG59O1xuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmdyaWRQcm90by5fZmluZENvbnZlcnRUYXJnZXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyKSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGZpbmRlci5zZXJpZXNNb2RlbDtcbiAgdmFyIHhBeGlzTW9kZWwgPSBmaW5kZXIueEF4aXNNb2RlbCB8fCBzZXJpZXNNb2RlbCAmJiBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCd4QXhpcycpWzBdO1xuICB2YXIgeUF4aXNNb2RlbCA9IGZpbmRlci55QXhpc01vZGVsIHx8IHNlcmllc01vZGVsICYmIHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3lBeGlzJylbMF07XG4gIHZhciBncmlkTW9kZWwgPSBmaW5kZXIuZ3JpZE1vZGVsO1xuICB2YXIgY29vcmRzTGlzdCA9IHRoaXMuX2Nvb3Jkc0xpc3Q7XG4gIHZhciBjYXJ0ZXNpYW47XG4gIHZhciBheGlzO1xuXG4gIGlmIChzZXJpZXNNb2RlbCkge1xuICAgIGNhcnRlc2lhbiA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgenJVdGlsLmluZGV4T2YoY29vcmRzTGlzdCwgY2FydGVzaWFuKSA8IDAgJiYgKGNhcnRlc2lhbiA9IG51bGwpO1xuICB9IGVsc2UgaWYgKHhBeGlzTW9kZWwgJiYgeUF4aXNNb2RlbCkge1xuICAgIGNhcnRlc2lhbiA9IHRoaXMuZ2V0Q2FydGVzaWFuKHhBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICB9IGVsc2UgaWYgKHhBeGlzTW9kZWwpIHtcbiAgICBheGlzID0gdGhpcy5nZXRBeGlzKCd4JywgeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gIH0gZWxzZSBpZiAoeUF4aXNNb2RlbCkge1xuICAgIGF4aXMgPSB0aGlzLmdldEF4aXMoJ3knLCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgfSAvLyBMb3dlc3QgcHJpb3JpdHkuXG4gIGVsc2UgaWYgKGdyaWRNb2RlbCkge1xuICAgICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgICAgaWYgKGdyaWQgPT09IHRoaXMpIHtcbiAgICAgICAgY2FydGVzaWFuID0gdGhpcy5fY29vcmRzTGlzdFswXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjYXJ0ZXNpYW46IGNhcnRlc2lhbixcbiAgICBheGlzOiBheGlzXG4gIH07XG59O1xuLyoqXG4gKiBAaW1wbGVtZW50c1xuICogc2VlIHttb2R1bGU6ZWNoYXJ0cy9Db29kaW5hdGVTeXN0ZW19XG4gKi9cblxuXG5ncmlkUHJvdG8uY29udGFpblBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gIHZhciBjb29yZCA9IHRoaXMuX2Nvb3Jkc0xpc3RbMF07XG5cbiAgaWYgKGNvb3JkKSB7XG4gICAgcmV0dXJuIGNvb3JkLmNvbnRhaW5Qb2ludChwb2ludCk7XG4gIH1cbn07XG4vKipcbiAqIEluaXRpYWxpemUgY2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtc1xuICogQHByaXZhdGVcbiAqL1xuXG5cbmdyaWRQcm90by5faW5pdENhcnRlc2lhbiA9IGZ1bmN0aW9uIChncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICB2YXIgYXhpc1Bvc2l0aW9uVXNlZCA9IHtcbiAgICBsZWZ0OiBmYWxzZSxcbiAgICByaWdodDogZmFsc2UsXG4gICAgdG9wOiBmYWxzZSxcbiAgICBib3R0b206IGZhbHNlXG4gIH07XG4gIHZhciBheGVzTWFwID0ge1xuICAgIHg6IHt9LFxuICAgIHk6IHt9XG4gIH07XG4gIHZhciBheGVzQ291bnQgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07IC8vLyBDcmVhdGUgYXhpc1xuXG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCgneEF4aXMnLCBjcmVhdGVBeGlzQ3JlYXRvcigneCcpLCB0aGlzKTtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCd5QXhpcycsIGNyZWF0ZUF4aXNDcmVhdG9yKCd5JyksIHRoaXMpO1xuXG4gIGlmICghYXhlc0NvdW50LnggfHwgIWF4ZXNDb3VudC55KSB7XG4gICAgLy8gUm9sbCBiYWNrIHdoZW4gdGhlcmUgbm8gZWl0aGVyIHggb3IgeSBheGlzXG4gICAgdGhpcy5fYXhlc01hcCA9IHt9O1xuICAgIHRoaXMuX2F4ZXNMaXN0ID0gW107XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fYXhlc01hcCA9IGF4ZXNNYXA7IC8vLyBDcmVhdGUgY2FydGVzaWFuMmRcblxuICBlYWNoKGF4ZXNNYXAueCwgZnVuY3Rpb24gKHhBeGlzLCB4QXhpc0luZGV4KSB7XG4gICAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcywgeUF4aXNJbmRleCkge1xuICAgICAgdmFyIGtleSA9ICd4JyArIHhBeGlzSW5kZXggKyAneScgKyB5QXhpc0luZGV4O1xuICAgICAgdmFyIGNhcnRlc2lhbiA9IG5ldyBDYXJ0ZXNpYW4yRChrZXkpO1xuICAgICAgY2FydGVzaWFuLmdyaWQgPSB0aGlzO1xuICAgICAgY2FydGVzaWFuLm1vZGVsID0gZ3JpZE1vZGVsO1xuICAgICAgdGhpcy5fY29vcmRzTWFwW2tleV0gPSBjYXJ0ZXNpYW47XG5cbiAgICAgIHRoaXMuX2Nvb3Jkc0xpc3QucHVzaChjYXJ0ZXNpYW4pO1xuXG4gICAgICBjYXJ0ZXNpYW4uYWRkQXhpcyh4QXhpcyk7XG4gICAgICBjYXJ0ZXNpYW4uYWRkQXhpcyh5QXhpcyk7XG4gICAgfSwgdGhpcyk7XG4gIH0sIHRoaXMpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUF4aXNDcmVhdG9yKGF4aXNUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChheGlzTW9kZWwsIGlkeCkge1xuICAgICAgaWYgKCFpc0F4aXNVc2VkSW5UaGVHcmlkKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBheGlzUG9zaXRpb24gPSBheGlzTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuXG4gICAgICBpZiAoYXhpc1R5cGUgPT09ICd4Jykge1xuICAgICAgICAvLyBGaXggcG9zaXRpb25cbiAgICAgICAgaWYgKGF4aXNQb3NpdGlvbiAhPT0gJ3RvcCcgJiYgYXhpc1Bvc2l0aW9uICE9PSAnYm90dG9tJykge1xuICAgICAgICAgIC8vIERlZmF1bHQgYm90dG9tIG9mIFhcbiAgICAgICAgICBheGlzUG9zaXRpb24gPSAnYm90dG9tJztcblxuICAgICAgICAgIGlmIChheGlzUG9zaXRpb25Vc2VkW2F4aXNQb3NpdGlvbl0pIHtcbiAgICAgICAgICAgIGF4aXNQb3NpdGlvbiA9IGF4aXNQb3NpdGlvbiA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRml4IHBvc2l0aW9uXG4gICAgICAgIGlmIChheGlzUG9zaXRpb24gIT09ICdsZWZ0JyAmJiBheGlzUG9zaXRpb24gIT09ICdyaWdodCcpIHtcbiAgICAgICAgICAvLyBEZWZhdWx0IGxlZnQgb2YgWVxuICAgICAgICAgIGF4aXNQb3NpdGlvbiA9ICdsZWZ0JztcblxuICAgICAgICAgIGlmIChheGlzUG9zaXRpb25Vc2VkW2F4aXNQb3NpdGlvbl0pIHtcbiAgICAgICAgICAgIGF4aXNQb3NpdGlvbiA9IGF4aXNQb3NpdGlvbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXhpc1Bvc2l0aW9uVXNlZFtheGlzUG9zaXRpb25dID0gdHJ1ZTtcbiAgICAgIHZhciBheGlzID0gbmV3IEF4aXMyRChheGlzVHlwZSwgYXhpc0hlbHBlci5jcmVhdGVTY2FsZUJ5TW9kZWwoYXhpc01vZGVsKSwgWzAsIDBdLCBheGlzTW9kZWwuZ2V0KCd0eXBlJyksIGF4aXNQb3NpdGlvbik7XG4gICAgICB2YXIgaXNDYXRlZ29yeSA9IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICAgIGF4aXMub25CYW5kID0gaXNDYXRlZ29yeSAmJiBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgYXhpcy5pbnZlcnNlID0gYXhpc01vZGVsLmdldCgnaW52ZXJzZScpO1xuICAgICAgYXhpcy5vblplcm8gPSBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5vblplcm8nKTtcbiAgICAgIGF4aXMub25aZXJvQXhpc0luZGV4ID0gYXhpc01vZGVsLmdldCgnYXhpc0xpbmUub25aZXJvQXhpc0luZGV4Jyk7IC8vIEluamVjdCBheGlzIGludG8gYXhpc01vZGVsXG5cbiAgICAgIGF4aXNNb2RlbC5heGlzID0gYXhpczsgLy8gSW5qZWN0IGF4aXNNb2RlbCBpbnRvIGF4aXNcblxuICAgICAgYXhpcy5tb2RlbCA9IGF4aXNNb2RlbDsgLy8gSW5qZWN0IGdyaWQgaW5mbyBheGlzXG5cbiAgICAgIGF4aXMuZ3JpZCA9IHRoaXM7IC8vIEluZGV4IG9mIGF4aXMsIGNhbiBiZSB1c2VkIGFzIGtleVxuXG4gICAgICBheGlzLmluZGV4ID0gaWR4O1xuXG4gICAgICB0aGlzLl9heGVzTGlzdC5wdXNoKGF4aXMpO1xuXG4gICAgICBheGVzTWFwW2F4aXNUeXBlXVtpZHhdID0gYXhpcztcbiAgICAgIGF4ZXNDb3VudFtheGlzVHlwZV0rKztcbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBVcGRhdGUgY2FydGVzaWFuIHByb3BlcnRpZXMgZnJvbSBzZXJpZXNcbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL09wdGlvbn0gb3B0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZ3JpZFByb3RvLl91cGRhdGVTY2FsZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBncmlkTW9kZWwpIHtcbiAgLy8gUmVzZXQgc2NhbGVcbiAgenJVdGlsLmVhY2godGhpcy5fYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgYXhpcy5zY2FsZS5zZXRFeHRlbnQoSW5maW5pdHksIC1JbmZpbml0eSk7XG4gIH0pO1xuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgaWYgKGlzQ2FydGVzaWFuMkQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICB2YXIgYXhlc01vZGVscyA9IGZpbmRBeGVzTW9kZWxzKHNlcmllc01vZGVsLCBlY01vZGVsKTtcbiAgICAgIHZhciB4QXhpc01vZGVsID0gYXhlc01vZGVsc1swXTtcbiAgICAgIHZhciB5QXhpc01vZGVsID0gYXhlc01vZGVsc1sxXTtcblxuICAgICAgaWYgKCFpc0F4aXNVc2VkSW5UaGVHcmlkKHhBeGlzTW9kZWwsIGdyaWRNb2RlbCwgZWNNb2RlbCkgfHwgIWlzQXhpc1VzZWRJblRoZUdyaWQoeUF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXJ0ZXNpYW4gPSB0aGlzLmdldENhcnRlc2lhbih4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIHhBeGlzID0gY2FydGVzaWFuLmdldEF4aXMoJ3gnKTtcbiAgICAgIHZhciB5QXhpcyA9IGNhcnRlc2lhbi5nZXRBeGlzKCd5Jyk7XG5cbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICB1bmlvbkV4dGVudChkYXRhLCB4QXhpcywgc2VyaWVzTW9kZWwpO1xuICAgICAgICB1bmlvbkV4dGVudChkYXRhLCB5QXhpcywgc2VyaWVzTW9kZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgZnVuY3Rpb24gdW5pb25FeHRlbnQoZGF0YSwgYXhpcywgc2VyaWVzTW9kZWwpIHtcbiAgICBlYWNoKHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGF4aXMuZGltKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgYXhpcy5zY2FsZS51bmlvbkV4dGVudEZyb21EYXRhKGRhdGEsIGRpbSk7XG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZGltXSAneCcgb3IgJ3knIG9yICdhdXRvJyBvciBudWxsL3VuZGVmaW5lZFxuICogQHJldHVybiB7T2JqZWN0fSB7YmFzZUF4ZXM6IFtdLCBvdGhlckF4ZXM6IFtdfVxuICovXG5cblxuZ3JpZFByb3RvLmdldFRvb2x0aXBBeGVzID0gZnVuY3Rpb24gKGRpbSkge1xuICB2YXIgYmFzZUF4ZXMgPSBbXTtcbiAgdmFyIG90aGVyQXhlcyA9IFtdO1xuICBlYWNoKHRoaXMuZ2V0Q2FydGVzaWFucygpLCBmdW5jdGlvbiAoY2FydGVzaWFuKSB7XG4gICAgdmFyIGJhc2VBeGlzID0gZGltICE9IG51bGwgJiYgZGltICE9PSAnYXV0bycgPyBjYXJ0ZXNpYW4uZ2V0QXhpcyhkaW0pIDogY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgdmFyIG90aGVyQXhpcyA9IGNhcnRlc2lhbi5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICAgIHpyVXRpbC5pbmRleE9mKGJhc2VBeGVzLCBiYXNlQXhpcykgPCAwICYmIGJhc2VBeGVzLnB1c2goYmFzZUF4aXMpO1xuICAgIHpyVXRpbC5pbmRleE9mKG90aGVyQXhlcywgb3RoZXJBeGlzKSA8IDAgJiYgb3RoZXJBeGVzLnB1c2gob3RoZXJBeGlzKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYmFzZUF4ZXM6IGJhc2VBeGVzLFxuICAgIG90aGVyQXhlczogb3RoZXJBeGVzXG4gIH07XG59O1xuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZUF4aXNUcmFuc2Zyb20oYXhpcywgY29vcmRCYXNlKSB7XG4gIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRFeHRlbnQoKTtcbiAgdmFyIGF4aXNFeHRlbnRTdW0gPSBheGlzRXh0ZW50WzBdICsgYXhpc0V4dGVudFsxXTsgLy8gRmFzdCB0cmFuc2Zvcm1cblxuICBheGlzLnRvR2xvYmFsQ29vcmQgPSBheGlzLmRpbSA9PT0gJ3gnID8gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgcmV0dXJuIGNvb3JkICsgY29vcmRCYXNlO1xuICB9IDogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgcmV0dXJuIGF4aXNFeHRlbnRTdW0gLSBjb29yZCArIGNvb3JkQmFzZTtcbiAgfTtcbiAgYXhpcy50b0xvY2FsQ29vcmQgPSBheGlzLmRpbSA9PT0gJ3gnID8gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgcmV0dXJuIGNvb3JkIC0gY29vcmRCYXNlO1xuICB9IDogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgcmV0dXJuIGF4aXNFeHRlbnRTdW0gLSBjb29yZCArIGNvb3JkQmFzZTtcbiAgfTtcbn1cblxudmFyIGF4ZXNUeXBlcyA9IFsneEF4aXMnLCAneUF4aXMnXTtcbi8qKlxuICogQGlubmVyXG4gKi9cblxuZnVuY3Rpb24gZmluZEF4ZXNNb2RlbHMoc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgcmV0dXJuIHpyVXRpbC5tYXAoYXhlc1R5cGVzLCBmdW5jdGlvbiAoYXhpc1R5cGUpIHtcbiAgICB2YXIgYXhpc01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cyhheGlzVHlwZSlbMF07XG4gICAgcmV0dXJuIGF4aXNNb2RlbDtcbiAgfSk7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gaXNDYXJ0ZXNpYW4yRChzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykgPT09ICdjYXJ0ZXNpYW4yZCc7XG59XG5cbkdyaWQuY3JlYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICB2YXIgZ3JpZHMgPSBbXTtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdncmlkJywgZnVuY3Rpb24gKGdyaWRNb2RlbCwgaWR4KSB7XG4gICAgdmFyIGdyaWQgPSBuZXcgR3JpZChncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgZ3JpZC5uYW1lID0gJ2dyaWRfJyArIGlkeDsgLy8gZGF0YVNhbXBsaW5nIHJlcXVpcmVzIGF4aXMgZXh0ZW50LCBzbyByZXNpemVcbiAgICAvLyBzaG91bGQgYmUgcGVyZm9ybWVkIGluIGNyZWF0ZSBzdGFnZS5cblxuICAgIGdyaWQucmVzaXplKGdyaWRNb2RlbCwgYXBpLCB0cnVlKTtcbiAgICBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IGdyaWQ7XG4gICAgZ3JpZHMucHVzaChncmlkKTtcbiAgfSk7IC8vIEluamVjdCB0aGUgY29vcmRpbmF0ZVN5c3RlbXMgaW50byBzZXJpZXNNb2RlbFxuXG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBpZiAoIWlzQ2FydGVzaWFuMkQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF4ZXNNb2RlbHMgPSBmaW5kQXhlc01vZGVscyhzZXJpZXNNb2RlbCwgZWNNb2RlbCk7XG4gICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzBdO1xuICAgIHZhciB5QXhpc01vZGVsID0gYXhlc01vZGVsc1sxXTtcbiAgICB2YXIgZ3JpZE1vZGVsID0geEF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCk7XG4gICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gZ3JpZC5nZXRDYXJ0ZXNpYW4oeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gIH0pO1xuICByZXR1cm4gZ3JpZHM7XG59OyAvLyBGb3IgZGVjaWRpbmcgd2hpY2ggZGltZW5zaW9ucyB0byB1c2Ugd2hlbiBjcmVhdGluZyBsaXN0IGRhdGFcblxuXG5HcmlkLmRpbWVuc2lvbnMgPSBHcmlkLnByb3RvdHlwZS5kaW1lbnNpb25zID0gQ2FydGVzaWFuMkQucHJvdG90eXBlLmRpbWVuc2lvbnM7XG5Db29yZGluYXRlU3lzdGVtLnJlZ2lzdGVyKCdjYXJ0ZXNpYW4yZCcsIEdyaWQpO1xudmFyIF9kZWZhdWx0ID0gR3JpZDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZShcIi4vQXhpc01vZGVsXCIpO1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvQ29tcG9uZW50XCIpO1xuXG4vLyBHcmlkIOaYr+WcqOacieebtOinkuWdkOagh+ezu+eahOaXtuWAmeW/hemhu+imgeWtmOWcqOeahFxuLy8g5omA5Lul6L+Z6YeM5Lmf6KaB6KKrIENhcnRlc2lhbjJEIOS+nei1llxudmFyIF9kZWZhdWx0ID0gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ2dyaWQnLFxuICBkZXBlbmRlbmNpZXM6IFsneEF4aXMnLCAneUF4aXMnXSxcbiAgbGF5b3V0TW9kZTogJ2JveCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZH1cbiAgICovXG4gIGNvb3JkaW5hdGVTeXN0ZW06IG51bGwsXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICBzaG93OiBmYWxzZSxcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMCxcbiAgICBsZWZ0OiAnMTAlJyxcbiAgICB0b3A6IDYwLFxuICAgIHJpZ2h0OiAnMTAlJyxcbiAgICBib3R0b206IDYwLFxuICAgIC8vIElmIGdyaWQgc2l6ZSBjb250YWluIGxhYmVsXG4gICAgY29udGFpbkxhYmVsOiBmYWxzZSxcbiAgICAvLyB3aWR0aDoge3RvdGFsV2lkdGh9IC0gbGVmdCAtIHJpZ2h0LFxuICAgIC8vIGhlaWdodDoge3RvdGFsSGVpZ2h0fSAtIHRvcCAtIGJvdHRvbSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJXaWR0aDogMSxcbiAgICBib3JkZXJDb2xvcjogJyNjY2MnXG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgYmJveCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2Jib3hcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgcG9seWdvbkNvbnRhaW4gPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbi9wb2x5Z29uXCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb29yZC9nZW8vUmVnaW9uXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtBcnJheX0gZ2VvbWV0cmllc1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gY3BcbiAqL1xuZnVuY3Rpb24gUmVnaW9uKG5hbWUsIGdlb21ldHJpZXMsIGNwKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5Pn1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuXG4gIHRoaXMuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG5cbiAgaWYgKCFjcCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICBjcCA9IFtyZWN0LnggKyByZWN0LndpZHRoIC8gMiwgcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyXTtcbiAgfSBlbHNlIHtcbiAgICBjcCA9IFtjcFswXSwgY3BbMV1dO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuXG5cbiAgdGhpcy5jZW50ZXIgPSBjcDtcbn1cblxuUmVnaW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFJlZ2lvbixcbiAgcHJvcGVydGllczogbnVsbCxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG5cbiAgICBpZiAocmVjdCkge1xuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgdmFyIE1BWF9OVU1CRVIgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBtaW4gPSBbTUFYX05VTUJFUiwgTUFYX05VTUJFUl07XG4gICAgdmFyIG1heCA9IFstTUFYX05VTUJFUiwgLU1BWF9OVU1CRVJdO1xuICAgIHZhciBtaW4yID0gW107XG4gICAgdmFyIG1heDIgPSBbXTtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IHRoaXMuZ2VvbWV0cmllcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gT25seSBzdXBwb3J0IHBvbHlnb25cbiAgICAgIGlmIChnZW9tZXRyaWVzW2ldLnR5cGUgIT09ICdwb2x5Z29uJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gRG9lc24ndCBjb25zaWRlciBob2xlXG5cblxuICAgICAgdmFyIGV4dGVyaW9yID0gZ2VvbWV0cmllc1tpXS5leHRlcmlvcjtcbiAgICAgIGJib3guZnJvbVBvaW50cyhleHRlcmlvciwgbWluMiwgbWF4Mik7XG4gICAgICB2ZWMyLm1pbihtaW4sIG1pbiwgbWluMik7XG4gICAgICB2ZWMyLm1heChtYXgsIG1heCwgbWF4Mik7XG4gICAgfSAvLyBObyBkYXRhXG5cblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBtaW5bMF0gPSBtaW5bMV0gPSBtYXhbMF0gPSBtYXhbMV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gezxBcnJheS48bnVtYmVyPn0gY29vcmRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW46IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IHRoaXMuZ2VvbWV0cmllcztcblxuICAgIGlmICghcmVjdC5jb250YWluKGNvb3JkWzBdLCBjb29yZFsxXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsb29wR2VvOiBmb3IgKHZhciBpID0gMCwgbGVuID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gT25seSBzdXBwb3J0IHBvbHlnb24uXG4gICAgICBpZiAoZ2VvbWV0cmllc1tpXS50eXBlICE9PSAncG9seWdvbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBleHRlcmlvciA9IGdlb21ldHJpZXNbaV0uZXh0ZXJpb3I7XG4gICAgICB2YXIgaW50ZXJpb3JzID0gZ2VvbWV0cmllc1tpXS5pbnRlcmlvcnM7XG5cbiAgICAgIGlmIChwb2x5Z29uQ29udGFpbi5jb250YWluKGV4dGVyaW9yLCBjb29yZFswXSwgY29vcmRbMV0pKSB7XG4gICAgICAgIC8vIE5vdCBpbiB0aGUgcmVnaW9uIGlmIHBvaW50IGlzIGluIHRoZSBob2xlLlxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IChpbnRlcmlvcnMgPyBpbnRlcmlvcnMubGVuZ3RoIDogMCk7IGsrKykge1xuICAgICAgICAgIGlmIChwb2x5Z29uQ29udGFpbi5jb250YWluKGludGVyaW9yc1trXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlIGxvb3BHZW87XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICB0cmFuc2Zvcm1UbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIGFzcGVjdCA9IHJlY3Qud2lkdGggLyByZWN0LmhlaWdodDtcblxuICAgIGlmICghd2lkdGgpIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0ICogaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoIWhlaWdodCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHRyYW5zZm9ybSA9IHJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHRhcmdldCk7XG4gICAgdmFyIGdlb21ldHJpZXMgPSB0aGlzLmdlb21ldHJpZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE9ubHkgc3VwcG9ydCBwb2x5Z29uLlxuICAgICAgaWYgKGdlb21ldHJpZXNbaV0udHlwZSAhPT0gJ3BvbHlnb24nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXh0ZXJpb3IgPSBnZW9tZXRyaWVzW2ldLmV4dGVyaW9yO1xuICAgICAgdmFyIGludGVyaW9ycyA9IGdlb21ldHJpZXNbaV0uaW50ZXJpb3JzO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IGV4dGVyaW9yLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIHZlYzIuYXBwbHlUcmFuc2Zvcm0oZXh0ZXJpb3JbcF0sIGV4dGVyaW9yW3BdLCB0cmFuc2Zvcm0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBoID0gMDsgaCA8IChpbnRlcmlvcnMgPyBpbnRlcmlvcnMubGVuZ3RoIDogMCk7IGgrKykge1xuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IGludGVyaW9yc1toXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgIHZlYzIuYXBwbHlUcmFuc2Zvcm0oaW50ZXJpb3JzW2hdW3BdLCBpbnRlcmlvcnNbaF1bcF0sIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICByZWN0LmNvcHkodGFyZ2V0KTsgLy8gVXBkYXRlIGNlbnRlclxuXG4gICAgdGhpcy5jZW50ZXIgPSBbcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMl07XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBSZWdpb247XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9SZWdpb24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9SZWdpb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFJlZ2lvbiA9IHJlcXVpcmUoXCIuL1JlZ2lvblwiKTtcblxuLyoqXG4gKiBQYXJzZSBhbmQgZGVjb2RlIGdlbyBqc29uXG4gKiBAbW9kdWxlIGVjaGFydHMvY29vcmQvZ2VvL3BhcnNlR2VvSnNvblxuICovXG5mdW5jdGlvbiBkZWNvZGUoanNvbikge1xuICBpZiAoIWpzb24uVVRGOEVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICB2YXIgZW5jb2RlU2NhbGUgPSBqc29uLlVURjhTY2FsZTtcblxuICBpZiAoZW5jb2RlU2NhbGUgPT0gbnVsbCkge1xuICAgIGVuY29kZVNjYWxlID0gMTAyNDtcbiAgfVxuXG4gIHZhciBmZWF0dXJlcyA9IGpzb24uZmVhdHVyZXM7XG5cbiAgZm9yICh2YXIgZiA9IDA7IGYgPCBmZWF0dXJlcy5sZW5ndGg7IGYrKykge1xuICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbZl07XG4gICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZW9tZXRyeTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICB2YXIgZW5jb2RlT2Zmc2V0cyA9IGdlb21ldHJ5LmVuY29kZU9mZnNldHM7XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2NdO1xuXG4gICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzW2NdID0gZGVjb2RlUG9seWdvbihjb29yZGluYXRlLCBlbmNvZGVPZmZzZXRzW2NdLCBlbmNvZGVTY2FsZSk7XG4gICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIGZvciAodmFyIGMyID0gMDsgYzIgPCBjb29yZGluYXRlLmxlbmd0aDsgYzIrKykge1xuICAgICAgICAgIHZhciBwb2x5Z29uID0gY29vcmRpbmF0ZVtjMl07XG4gICAgICAgICAgY29vcmRpbmF0ZVtjMl0gPSBkZWNvZGVQb2x5Z29uKHBvbHlnb24sIGVuY29kZU9mZnNldHNbY11bYzJdLCBlbmNvZGVTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSGFzIGJlZW4gZGVjb2RlZFxuXG5cbiAganNvbi5VVEY4RW5jb2RpbmcgPSBmYWxzZTtcbiAgcmV0dXJuIGpzb247XG59XG5cbmZ1bmN0aW9uIGRlY29kZVBvbHlnb24oY29vcmRpbmF0ZSwgZW5jb2RlT2Zmc2V0cywgZW5jb2RlU2NhbGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgcHJldlggPSBlbmNvZGVPZmZzZXRzWzBdO1xuICB2YXIgcHJldlkgPSBlbmNvZGVPZmZzZXRzWzFdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZS5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB4ID0gY29vcmRpbmF0ZS5jaGFyQ29kZUF0KGkpIC0gNjQ7XG4gICAgdmFyIHkgPSBjb29yZGluYXRlLmNoYXJDb2RlQXQoaSArIDEpIC0gNjQ7IC8vIFppZ1phZyBkZWNvZGluZ1xuXG4gICAgeCA9IHggPj4gMSBeIC0oeCAmIDEpO1xuICAgIHkgPSB5ID4+IDEgXiAtKHkgJiAxKTsgLy8gRGVsdGEgZGVvY2RpbmdcblxuICAgIHggKz0gcHJldlg7XG4gICAgeSArPSBwcmV2WTtcbiAgICBwcmV2WCA9IHg7XG4gICAgcHJldlkgPSB5OyAvLyBEZXF1YW50aXplXG5cbiAgICByZXN1bHQucHVzaChbeCAvIGVuY29kZVNjYWxlLCB5IC8gZW5jb2RlU2NhbGVdKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9nZW8vcGFyc2VHZW9Kc29uXG4gKiBAcGFyYW0ge09iamVjdH0gZ2VvSnNvblxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICovXG5cblxuZnVuY3Rpb24gX2RlZmF1bHQoZ2VvSnNvbikge1xuICBkZWNvZGUoZ2VvSnNvbik7XG4gIHJldHVybiB6clV0aWwubWFwKHpyVXRpbC5maWx0ZXIoZ2VvSnNvbi5mZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmVPYmopIHtcbiAgICAvLyBPdXRwdXQgb2YgbWFwc2hhcGVyIG1heSBoYXZlIGdlb21ldHJ5IG51bGxcbiAgICByZXR1cm4gZmVhdHVyZU9iai5nZW9tZXRyeSAmJiBmZWF0dXJlT2JqLnByb3BlcnRpZXMgJiYgZmVhdHVyZU9iai5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggPiAwO1xuICB9KSwgZnVuY3Rpb24gKGZlYXR1cmVPYmopIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IGZlYXR1cmVPYmoucHJvcGVydGllcztcbiAgICB2YXIgZ2VvID0gZmVhdHVyZU9iai5nZW9tZXRyeTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW8uY29vcmRpbmF0ZXM7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBbXTtcblxuICAgIGlmIChnZW8udHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICBnZW9tZXRyaWVzLnB1c2goe1xuICAgICAgICB0eXBlOiAncG9seWdvbicsXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgR2VvSlNPTiBzcGVjaWZpY2F0aW9uLlxuICAgICAgICAvLyBGaXJzdCBtdXN0IGJlIGV4dGVyaW9yLCBhbmQgdGhlIHJlc3QgYXJlIGFsbCBpbnRlcmlvcihob2xlcykuXG4gICAgICAgIGV4dGVyaW9yOiBjb29yZGluYXRlc1swXSxcbiAgICAgICAgaW50ZXJpb3JzOiBjb29yZGluYXRlcy5zbGljZSgxKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGdlby50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgenJVdGlsLmVhY2goY29vcmRpbmF0ZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtWzBdKSB7XG4gICAgICAgICAgZ2VvbWV0cmllcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcbiAgICAgICAgICAgIGV4dGVyaW9yOiBpdGVtWzBdLFxuICAgICAgICAgICAgaW50ZXJpb3JzOiBpdGVtLnNsaWNlKDEpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciByZWdpb24gPSBuZXcgUmVnaW9uKHByb3BlcnRpZXMubmFtZSwgZ2VvbWV0cmllcywgcHJvcGVydGllcy5jcCk7XG4gICAgcmVnaW9uLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgIHJldHVybiByZWdpb247XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9wYXJzZUdlb0pzb24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9wYXJzZUdlb0pzb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJmdW5jdGlvbiBkZWZhdWx0S2V5R2V0dGVyKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW07XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IG9sZEFyclxuICogQHBhcmFtIHtBcnJheX0gbmV3QXJyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbGRLZXlHZXR0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5ld0tleUdldHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDYW4gYmUgdmlzaXRlZCBieSB0aGlzLmNvbnRleHQgaW4gY2FsbGJhY2suXG4gKi9cblxuXG5mdW5jdGlvbiBEYXRhRGlmZmVyKG9sZEFyciwgbmV3QXJyLCBvbGRLZXlHZXR0ZXIsIG5ld0tleUdldHRlciwgY29udGV4dCkge1xuICB0aGlzLl9vbGQgPSBvbGRBcnI7XG4gIHRoaXMuX25ldyA9IG5ld0FycjtcbiAgdGhpcy5fb2xkS2V5R2V0dGVyID0gb2xkS2V5R2V0dGVyIHx8IGRlZmF1bHRLZXlHZXR0ZXI7XG4gIHRoaXMuX25ld0tleUdldHRlciA9IG5ld0tleUdldHRlciB8fCBkZWZhdWx0S2V5R2V0dGVyO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG5EYXRhRGlmZmVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERhdGFEaWZmZXIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYWRkIGEgZGF0YVxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoZnVuYykge1xuICAgIHRoaXMuX2FkZCA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdXBkYXRlIGEgZGF0YVxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAoZnVuYykge1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gcmVtb3ZlIGEgZGF0YVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZnVuYykge1xuICAgIHRoaXMuX3JlbW92ZSA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGV4ZWN1dGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2xkQXJyID0gdGhpcy5fb2xkO1xuICAgIHZhciBuZXdBcnIgPSB0aGlzLl9uZXc7XG4gICAgdmFyIG9sZERhdGFJbmRleE1hcCA9IHt9O1xuICAgIHZhciBuZXdEYXRhSW5kZXhNYXAgPSB7fTtcbiAgICB2YXIgb2xkRGF0YUtleUFyciA9IFtdO1xuICAgIHZhciBuZXdEYXRhS2V5QXJyID0gW107XG4gICAgdmFyIGk7XG4gICAgaW5pdEluZGV4TWFwKG9sZEFyciwgb2xkRGF0YUluZGV4TWFwLCBvbGREYXRhS2V5QXJyLCAnX29sZEtleUdldHRlcicsIHRoaXMpO1xuICAgIGluaXRJbmRleE1hcChuZXdBcnIsIG5ld0RhdGFJbmRleE1hcCwgbmV3RGF0YUtleUFyciwgJ19uZXdLZXlHZXR0ZXInLCB0aGlzKTsgLy8gVHJhdmVsIGJ5IGludmVydGVkIG9yZGVyIHRvIG1ha2Ugc3VyZSBvcmRlciBjb25zaXN0ZW5jeVxuICAgIC8vIHdoZW4gZHVwbGljYXRlIGtleXMgZXhpc3RzIChjb25zaWRlciBuZXdEYXRhSW5kZXgucG9wKCkgYmVsb3cpLlxuICAgIC8vIEZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLCB0aGVzZSBjb2RlIGJlbG93IGRvIG5vdCBsb29rIG5lYXQuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgb2xkQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gb2xkRGF0YUtleUFycltpXTtcbiAgICAgIHZhciBpZHggPSBuZXdEYXRhSW5kZXhNYXBba2V5XTsgLy8gaWR4IGNhbiBuZXZlciBiZSBlbXB0eSBhcnJheSBoZXJlLiBzZWUgJ3NldCBudWxsJyBsb2dpYyBiZWxvdy5cblxuICAgICAgaWYgKGlkeCAhPSBudWxsKSB7XG4gICAgICAgIC8vIENvbnNpZGVyIHRoZXJlIGlzIGR1cGxpY2F0ZSBrZXkgKGZvciBleGFtcGxlLCB1c2UgZGF0YUl0ZW0ubmFtZSBhcyBrZXkpLlxuICAgICAgICAvLyBXZSBzaG91bGQgbWFrZSBzdXJlIGV2ZXJ5IGl0ZW0gaW4gbmV3QXJyIGFuZCBvbGRBcnIgY2FuIGJlIHZpc2l0ZWQuXG4gICAgICAgIHZhciBsZW4gPSBpZHgubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICBsZW4gPT09IDEgJiYgKG5ld0RhdGFJbmRleE1hcFtrZXldID0gbnVsbCk7XG4gICAgICAgICAgaWR4ID0gaWR4LnVuc2hpZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdEYXRhSW5kZXhNYXBba2V5XSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUgJiYgdGhpcy5fdXBkYXRlKGlkeCwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmUgJiYgdGhpcy5fcmVtb3ZlKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGF0YUtleUFyci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IG5ld0RhdGFLZXlBcnJbaV07XG5cbiAgICAgIGlmIChuZXdEYXRhSW5kZXhNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgaWR4ID0gbmV3RGF0YUluZGV4TWFwW2tleV07XG5cbiAgICAgICAgaWYgKGlkeCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaWR4IGNhbiBuZXZlciBiZSBlbXB0eSBhcnJheSBoZXJlLiBzZWUgJ3NldCBudWxsJyBsb2dpYyBhYm92ZS5cblxuXG4gICAgICAgIGlmICghaWR4Lmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX2FkZCAmJiB0aGlzLl9hZGQoaWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gaWR4Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGQgJiYgdGhpcy5fYWRkKGlkeFtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpbml0SW5kZXhNYXAoYXJyLCBtYXAsIGtleUFyciwga2V5R2V0dGVyTmFtZSwgZGF0YURpZmZlcikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIC8vIEFkZCBwcmVmaXggdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlLlxuICAgIHZhciBrZXkgPSAnX2VjXycgKyBkYXRhRGlmZmVyW2tleUdldHRlck5hbWVdKGFycltpXSwgaSk7XG4gICAgdmFyIGV4aXN0ZW5jZSA9IG1hcFtrZXldO1xuXG4gICAgaWYgKGV4aXN0ZW5jZSA9PSBudWxsKSB7XG4gICAgICBrZXlBcnIucHVzaChrZXkpO1xuICAgICAgbWFwW2tleV0gPSBpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWV4aXN0ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgbWFwW2tleV0gPSBleGlzdGVuY2UgPSBbZXhpc3RlbmNlXTtcbiAgICAgIH1cblxuICAgICAgZXhpc3RlbmNlLnB1c2goaSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBfZGVmYXVsdCA9IERhdGFEaWZmZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvRGF0YURpZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9EYXRhRGlmZmVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIERhdGFEaWZmZXIgPSByZXF1aXJlKFwiLi9EYXRhRGlmZmVyXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbW9kZWxcIik7XG5cbi8qKlxuICogTGlzdCBmb3IgZGF0YSBzdG9yYWdlXG4gKiBAbW9kdWxlIGVjaGFydHMvZGF0YS9MaXN0XG4gKi9cbnZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcbnZhciBVTkRFRklORUQgPSAndW5kZWZpbmVkJztcbnZhciBnbG9iYWxPYmogPSB0eXBlb2Ygd2luZG93ID09PSBVTkRFRklORUQgPyBnbG9iYWwgOiB3aW5kb3c7XG52YXIgZGF0YUN0b3JzID0ge1xuICAnZmxvYXQnOiB0eXBlb2YgZ2xvYmFsT2JqLkZsb2F0NjRBcnJheSA9PT0gVU5ERUZJTkVEID8gQXJyYXkgOiBnbG9iYWxPYmouRmxvYXQ2NEFycmF5LFxuICAnaW50JzogdHlwZW9mIGdsb2JhbE9iai5JbnQzMkFycmF5ID09PSBVTkRFRklORUQgPyBBcnJheSA6IGdsb2JhbE9iai5JbnQzMkFycmF5LFxuICAvLyBPcmRpbmFsIGRhdGEgdHlwZSBjYW4gYmUgc3RyaW5nIG9yIGludFxuICAnb3JkaW5hbCc6IEFycmF5LFxuICAnbnVtYmVyJzogQXJyYXksXG4gICd0aW1lJzogQXJyYXlcbn07XG52YXIgVFJBTlNGRVJBQkxFX1BST1BFUlRJRVMgPSBbJ3N0YWNrZWRPbicsICdoYXNJdGVtT3B0aW9uJywgJ19uYW1lTGlzdCcsICdfaWRMaXN0JywgJ19yYXdEYXRhJ107XG5cbmZ1bmN0aW9uIHRyYW5zZmVyUHJvcGVydGllcyhhLCBiKSB7XG4gIHpyVXRpbC5lYWNoKFRSQU5TRkVSQUJMRV9QUk9QRVJUSUVTLmNvbmNhdChiLl9fd3JhcHBlZE1ldGhvZHMgfHwgW10pLCBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGFbcHJvcE5hbWVdID0gYltwcm9wTmFtZV07XG4gICAgfVxuICB9KTtcbiAgYS5fX3dyYXBwZWRNZXRob2RzID0gYi5fX3dyYXBwZWRNZXRob2RzO1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0RGF0YVByb3ZpZGVyKGRhdGFBcnJheSkge1xuICB0aGlzLl9hcnJheSA9IGRhdGFBcnJheSB8fCBbXTtcbn1cblxuRGVmYXVsdERhdGFQcm92aWRlci5wcm90b3R5cGUucHVyZSA9IGZhbHNlO1xuXG5EZWZhdWx0RGF0YVByb3ZpZGVyLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2FycmF5Lmxlbmd0aDtcbn07XG5cbkRlZmF1bHREYXRhUHJvdmlkZXIucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHJldHVybiB0aGlzLl9hcnJheVtpZHhdO1xufTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0XG4gKlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nfE9iamVjdD59IGRpbWVuc2lvbnNcbiAqICAgICAgRm9yIGV4YW1wbGUsIFsnc29tZURpbU5hbWUnLCB7bmFtZTogJ3NvbWVEaW1OYW1lJywgdHlwZTogJ3NvbWVEaW1UeXBlJ30sIC4uLl0uXG4gKiAgICAgIERpbWVuc2lvbnMgc2hvdWxkIGJlIGNvbmNyZXRlIG5hbWVzIGxpa2UgeCwgeSwgeiwgbG5nLCBsYXQsIGFuZ2xlLCByYWRpdXNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGhvc3RNb2RlbFxuICovXG5cblxudmFyIExpc3QgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgaG9zdE1vZGVsKSB7XG4gIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zIHx8IFsneCcsICd5J107XG4gIHZhciBkaW1lbnNpb25JbmZvcyA9IHt9O1xuICB2YXIgZGltZW5zaW9uTmFtZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltZW5zaW9uTmFtZTtcbiAgICB2YXIgZGltZW5zaW9uSW5mbyA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBkaW1lbnNpb25zW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgZGltZW5zaW9uTmFtZSA9IGRpbWVuc2lvbnNbaV07XG4gICAgICBkaW1lbnNpb25JbmZvID0ge1xuICAgICAgICBuYW1lOiBkaW1lbnNpb25OYW1lLFxuICAgICAgICBjb29yZERpbTogZGltZW5zaW9uTmFtZSxcbiAgICAgICAgY29vcmREaW1JbmRleDogMCxcbiAgICAgICAgc3RhY2thYmxlOiBmYWxzZSxcbiAgICAgICAgLy8gVHlwZSBjYW4gYmUgJ2Zsb2F0JywgJ2ludCcsICdudW1iZXInXG4gICAgICAgIC8vIERlZmF1bHQgaXMgbnVtYmVyLCBQcmVjaXNpb24gb2YgZmxvYXQgbWF5IG5vdCBlbm91Z2hcbiAgICAgICAgdHlwZTogJ251bWJlcidcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpbWVuc2lvbkluZm8gPSBkaW1lbnNpb25zW2ldO1xuICAgICAgZGltZW5zaW9uTmFtZSA9IGRpbWVuc2lvbkluZm8ubmFtZTtcbiAgICAgIGRpbWVuc2lvbkluZm8udHlwZSA9IGRpbWVuc2lvbkluZm8udHlwZSB8fCAnbnVtYmVyJztcblxuICAgICAgaWYgKCFkaW1lbnNpb25JbmZvLmNvb3JkRGltKSB7XG4gICAgICAgIGRpbWVuc2lvbkluZm8uY29vcmREaW0gPSBkaW1lbnNpb25OYW1lO1xuICAgICAgICBkaW1lbnNpb25JbmZvLmNvb3JkRGltSW5kZXggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRpbWVuc2lvbkluZm8ub3RoZXJEaW1zID0gZGltZW5zaW9uSW5mby5vdGhlckRpbXMgfHwge307XG4gICAgZGltZW5zaW9uTmFtZXMucHVzaChkaW1lbnNpb25OYW1lKTtcbiAgICBkaW1lbnNpb25JbmZvc1tkaW1lbnNpb25OYW1lXSA9IGRpbWVuc2lvbkluZm87XG4gIH1cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuXG5cbiAgdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9uTmFtZXM7XG4gIC8qKlxuICAgKiBJbmZvbWF0aW9uIG9mIGVhY2ggZGF0YSBkaW1lbnNpb24sIGxpa2UgZGF0YSB0eXBlLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9kaW1lbnNpb25JbmZvcyA9IGRpbWVuc2lvbkluZm9zO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgKi9cblxuICB0aGlzLmhvc3RNb2RlbCA9IGhvc3RNb2RlbDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICovXG5cbiAgdGhpcy5kYXRhVHlwZTtcbiAgLyoqXG4gICAqIEluZGljZXMgc3RvcmVzIHRoZSBpbmRpY2VzIG9mIGRhdGEgc3Vic2V0IGFmdGVyIGZpbHRlcmVkLlxuICAgKiBUaGlzIGRhdGEgc3Vic2V0IHdpbGwgYmUgdXNlZCBpbiBjaGFydC5cbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy5pbmRpY2VzID0gW107XG4gIC8qKlxuICAgKiBEYXRhIHN0b3JhZ2VcbiAgICogQHR5cGUge09iamVjdC48a2V5LCBUeXBlZEFycmF5fEFycmF5Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fc3RvcmFnZSA9IHt9O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cblxuICB0aGlzLl9uYW1lTGlzdCA9IFtdO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cblxuICB0aGlzLl9pZExpc3QgPSBbXTtcbiAgLyoqXG4gICAqIE1vZGVscyBvZiBkYXRhIG9wdGlvbiBpcyBzdG9yZWQgc3BhcnNlIGZvciBvcHRpbWl6aW5nIG1lbW9yeSBjb3N0XG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9vcHRpb25Nb2RlbHMgPSBbXTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fVxuICAgKi9cblxuICB0aGlzLnN0YWNrZWRPbiA9IG51bGw7XG4gIC8qKlxuICAgKiBHbG9iYWwgdmlzdWFsIHByb3BlcnRpZXMgYWZ0ZXIgdmlzdWFsIGNvZGluZ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl92aXN1YWwgPSB7fTtcbiAgLyoqXG4gICAqIEdsb2JlbCBsYXlvdXQgcHJvcGVydGllcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fbGF5b3V0ID0ge307XG4gIC8qKlxuICAgKiBJdGVtIHZpc3VhbCBwcm9wZXJ0aWVzIGFmdGVyIHZpc3VhbCBjb2RpbmdcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9pdGVtVmlzdWFscyA9IFtdO1xuICAvKipcbiAgICogSXRlbSBsYXlvdXQgcHJvcGVydGllcyBhZnRlciBsYXlvdXRcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9pdGVtTGF5b3V0cyA9IFtdO1xuICAvKipcbiAgICogR3JhcGhpYyBlbGVtbmVudHNcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6enJlbmRlci9FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fZ3JhcGhpY0VscyA9IFtdO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxBcnJheXxPYmplY3Q+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9yYXdEYXRhO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fZXh0ZW50O1xufTtcblxudmFyIGxpc3RQcm90byA9IExpc3QucHJvdG90eXBlO1xubGlzdFByb3RvLnR5cGUgPSAnbGlzdCc7XG4vKipcbiAqIElmIGVhY2ggZGF0YSBpdGVtIGhhcyBpdCdzIG93biBvcHRpb25cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5cbmxpc3RQcm90by5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbi8qKlxuICogR2V0IGRpbWVuc2lvbiBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRpbVxuICogICAgICAgIERpbWVuc2lvbiBjYW4gYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xuICogICAgICAgIE9yIGEgb3JkaW5hbCBudW1iZXIuIEZvciBleGFtcGxlIGdldERpbWVuc2lvbkluZm8oMCkgd2lsbCByZXR1cm4gJ3gnIG9yICdsbmcnIG9yICdyYWRpdXMnXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNyZXRlIGRpbSBuYW1lLlxuICovXG5cbmxpc3RQcm90by5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiAoZGltKSB7XG4gIGlmICghaXNOYU4oZGltKSkge1xuICAgIGRpbSA9IHRoaXMuZGltZW5zaW9uc1tkaW1dIHx8IGRpbTtcbiAgfVxuXG4gIHJldHVybiBkaW07XG59O1xuLyoqXG4gKiBHZXQgdHlwZSBhbmQgc3RhY2thYmxlIGluZm8gb2YgcGFydGljdWxhciBkaW1lbnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGltXG4gKiAgICAgICAgRGltZW5zaW9uIGNhbiBiZSBjb25jcmV0ZSBuYW1lcyBsaWtlIHgsIHksIHosIGxuZywgbGF0LCBhbmdsZSwgcmFkaXVzXG4gKiAgICAgICAgT3IgYSBvcmRpbmFsIG51bWJlci4gRm9yIGV4YW1wbGUgZ2V0RGltZW5zaW9uSW5mbygwKSB3aWxsIHJldHVybiAneCcgb3IgJ2xuZycgb3IgJ3JhZGl1cydcbiAqL1xuXG5cbmxpc3RQcm90by5nZXREaW1lbnNpb25JbmZvID0gZnVuY3Rpb24gKGRpbSkge1xuICByZXR1cm4genJVdGlsLmNsb25lKHRoaXMuX2RpbWVuc2lvbkluZm9zW3RoaXMuZ2V0RGltZW5zaW9uKGRpbSldKTtcbn07XG4vKipcbiAqIEluaXRpYWxpemUgZnJvbSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3R8bnVtYmVyfEFycmF5Pn0gZGF0YVxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW25hbWVMaXN0XVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2RpbVZhbHVlR2V0dGVyXSAoZGF0YUl0ZW0sIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpID0+IG51bWJlclxuICovXG5cblxubGlzdFByb3RvLmluaXREYXRhID0gZnVuY3Rpb24gKGRhdGEsIG5hbWVMaXN0LCBkaW1WYWx1ZUdldHRlcikge1xuICBkYXRhID0gZGF0YSB8fCBbXTtcbiAgdmFyIGlzRGF0YUFycmF5ID0genJVdGlsLmlzQXJyYXkoZGF0YSk7XG5cbiAgaWYgKGlzRGF0YUFycmF5KSB7XG4gICAgZGF0YSA9IG5ldyBEZWZhdWx0RGF0YVByb3ZpZGVyKGRhdGEpO1xuICB9XG5cbiAgdGhpcy5fcmF3RGF0YSA9IGRhdGE7IC8vIENsZWFyXG5cbiAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlID0ge307XG4gIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzID0gW107XG4gIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICB2YXIgZGltZW5zaW9uSW5mb01hcCA9IHRoaXMuX2RpbWVuc2lvbkluZm9zO1xuICB2YXIgc2l6ZSA9IGRhdGEuY291bnQoKTtcbiAgdmFyIGlkTGlzdCA9IFtdO1xuICB2YXIgbmFtZVJlcGVhdENvdW50ID0ge307XG4gIHZhciBuYW1lRGltSWR4O1xuICBuYW1lTGlzdCA9IG5hbWVMaXN0IHx8IFtdOyAvLyBJbml0IHN0b3JhZ2VcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltSW5mbyA9IGRpbWVuc2lvbkluZm9NYXBbZGltZW5zaW9uc1tpXV07XG4gICAgZGltSW5mby5vdGhlckRpbXMuaXRlbU5hbWUgPT09IDAgJiYgKG5hbWVEaW1JZHggPSBpKTtcbiAgICB2YXIgRGF0YUN0b3IgPSBkYXRhQ3RvcnNbZGltSW5mby50eXBlXTtcbiAgICBzdG9yYWdlW2RpbWVuc2lvbnNbaV1dID0gbmV3IERhdGFDdG9yKHNpemUpO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghZGltVmFsdWVHZXR0ZXIpIHtcbiAgICBzZWxmLmhhc0l0ZW1PcHRpb24gPSBmYWxzZTtcbiAgfSAvLyBEZWZhdWx0IGRpbSB2YWx1ZSBnZXR0ZXJcblxuXG4gIGRpbVZhbHVlR2V0dGVyID0gZGltVmFsdWVHZXR0ZXIgfHwgZnVuY3Rpb24gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgdmFyIHZhbHVlID0gbW9kZWxVdGlsLmdldERhdGFJdGVtVmFsdWUoZGF0YUl0ZW0pOyAvLyBJZiBhbnkgZGF0YUl0ZW0gaXMgbGlrZSB7IHZhbHVlOiAxMCB9XG5cbiAgICBpZiAobW9kZWxVdGlsLmlzRGF0YUl0ZW1PcHRpb24oZGF0YUl0ZW0pKSB7XG4gICAgICBzZWxmLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlbFV0aWwuY29udmVyRGF0YVZhbHVlKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgPyB2YWx1ZVtkaW1JbmRleF0gLy8gSWYgdmFsdWUgaXMgYSBzaW5nbGUgbnVtYmVyIG9yIHNvbWV0aGluZyBlbHNlIG5vdCBhcnJheS5cbiAgICA6IHZhbHVlLCBkaW1lbnNpb25JbmZvTWFwW2RpbU5hbWVdKTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIC8vIE5PVElDRTogVHJ5IG5vdCB0byB3cml0ZSB0aGluZ3MgaW50byBkYXRhSXRlbVxuICAgIHZhciBkYXRhSXRlbSA9IGRhdGEuZ2V0SXRlbShpKTsgLy8gRWFjaCBkYXRhIGl0ZW0gaXMgdmFsdWVcbiAgICAvLyBbMSwgMl1cbiAgICAvLyAyXG4gICAgLy8gQmFyIGNoYXJ0LCBsaW5lIGNoYXJ0IHdoaWNoIHVzZXMgY2F0ZWdvcnkgYXhpc1xuICAgIC8vIG9ubHkgZ2l2ZXMgdGhlICd5JyB2YWx1ZS4gJ3gnIHZhbHVlIGlzIHRoZSBpbmRpY2VzIG9mIGNhdGVvZ3J5XG4gICAgLy8gVXNlIGEgdGVtcFZhbHVlIHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgdG8gYmUgYSAoeCwgeSkgdmFsdWVcbiAgICAvLyBTdG9yZSB0aGUgZGF0YSBieSBkaW1lbnNpb25zXG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGRpbWVuc2lvbnMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBkaW0gPSBkaW1lbnNpb25zW2tdO1xuICAgICAgdmFyIGRpbVN0b3JhZ2UgPSBzdG9yYWdlW2RpbV07IC8vIFBFTkRJTkcgTlVMTCBpcyBlbXB0eSBvciB6ZXJvXG5cbiAgICAgIGRpbVN0b3JhZ2VbaV0gPSBkaW1WYWx1ZUdldHRlcihkYXRhSXRlbSwgZGltLCBpLCBrKTtcbiAgICB9XG5cbiAgICBpbmRpY2VzLnB1c2goaSk7XG4gIH0gLy8gVXNlIHRoZSBuYW1lIGluIG9wdGlvbiBhbmQgY3JlYXRlIGlkXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHZhciBkYXRhSXRlbSA9IGRhdGEuZ2V0SXRlbShpKTtcblxuICAgIGlmICghbmFtZUxpc3RbaV0gJiYgZGF0YUl0ZW0pIHtcbiAgICAgIGlmIChkYXRhSXRlbS5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZUxpc3RbaV0gPSBkYXRhSXRlbS5uYW1lO1xuICAgICAgfSBlbHNlIGlmIChuYW1lRGltSWR4ICE9IG51bGwpIHtcbiAgICAgICAgbmFtZUxpc3RbaV0gPSBzdG9yYWdlW2RpbWVuc2lvbnNbbmFtZURpbUlkeF1dW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gbmFtZUxpc3RbaV0gfHwgJyc7IC8vIFRyeSB1c2luZyB0aGUgaWQgaW4gb3B0aW9uXG5cbiAgICB2YXIgaWQgPSBkYXRhSXRlbSAmJiBkYXRhSXRlbS5pZDtcblxuICAgIGlmICghaWQgJiYgbmFtZSkge1xuICAgICAgLy8gVXNlIG5hbWUgYXMgaWQgYW5kIGFkZCBjb3VudGVyIHRvIGF2b2lkIHNhbWUgbmFtZVxuICAgICAgbmFtZVJlcGVhdENvdW50W25hbWVdID0gbmFtZVJlcGVhdENvdW50W25hbWVdIHx8IDA7XG4gICAgICBpZCA9IG5hbWU7XG5cbiAgICAgIGlmIChuYW1lUmVwZWF0Q291bnRbbmFtZV0gPiAwKSB7XG4gICAgICAgIGlkICs9ICdfX2VjX18nICsgbmFtZVJlcGVhdENvdW50W25hbWVdO1xuICAgICAgfVxuXG4gICAgICBuYW1lUmVwZWF0Q291bnRbbmFtZV0rKztcbiAgICB9XG5cbiAgICBpZCAmJiAoaWRMaXN0W2ldID0gaWQpO1xuICB9XG5cbiAgdGhpcy5fbmFtZUxpc3QgPSBuYW1lTGlzdDtcbiAgdGhpcy5faWRMaXN0ID0gaWRMaXN0O1xufTtcbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pbmRpY2VzLmxlbmd0aDtcbn07XG4vKipcbiAqIEdldCB2YWx1ZS4gUmV0dXJuIE5hTiBpZiBpZHggaXMgb3V0IG9mIHJhbmdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGRpbSBEaW0gbXVzdCBiZSBjb25jcmV0ZSBuYW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmdldCA9IGZ1bmN0aW9uIChkaW0sIGlkeCwgc3RhY2spIHtcbiAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICB2YXIgZGF0YUluZGV4ID0gdGhpcy5pbmRpY2VzW2lkeF07IC8vIElmIHZhbHVlIG5vdCBleGlzdHNcblxuICBpZiAoZGF0YUluZGV4ID09IG51bGwgfHwgIXN0b3JhZ2VbZGltXSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBzdG9yYWdlW2RpbV1bZGF0YUluZGV4XTsgLy8gRklYTUUgb3JkaW5hbCBkYXRhIHR5cGUgaXMgbm90IHN0YWNrYWJsZVxuXG4gIGlmIChzdGFjaykge1xuICAgIHZhciBkaW1lbnNpb25JbmZvID0gdGhpcy5fZGltZW5zaW9uSW5mb3NbZGltXTtcblxuICAgIGlmIChkaW1lbnNpb25JbmZvICYmIGRpbWVuc2lvbkluZm8uc3RhY2thYmxlKSB7XG4gICAgICB2YXIgc3RhY2tlZE9uID0gdGhpcy5zdGFja2VkT247XG5cbiAgICAgIHdoaWxlIChzdGFja2VkT24pIHtcbiAgICAgICAgLy8gR2V0IG5vIHN0YWNrZWQgZGF0YSBvZiBzdGFja2VkIG9uXG4gICAgICAgIHZhciBzdGFja2VkVmFsdWUgPSBzdGFja2VkT24uZ2V0KGRpbSwgaWR4KTsgLy8gQ29uc2lkZXJpbmcgcG9zaXRpdmUgc3RhY2ssIG5lZ2F0aXZlIHN0YWNrIGFuZCBlbXB0eSBkYXRhXG5cbiAgICAgICAgaWYgKHZhbHVlID49IDAgJiYgc3RhY2tlZFZhbHVlID4gMCB8fCAvLyBQb3NpdGl2ZSBzdGFja1xuICAgICAgICB2YWx1ZSA8PSAwICYmIHN0YWNrZWRWYWx1ZSA8IDAgLy8gTmVnYXRpdmUgc3RhY2tcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzdGFja2VkVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIHN0YWNrZWRPbiA9IHN0YWNrZWRPbi5zdGFja2VkT247XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogR2V0IHZhbHVlIGZvciBtdWx0aSBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW2RpbWVuc2lvbnNdIElmIGlnbm9yZWQsIHVzaW5nIGFsbCBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBpZHgsIHN0YWNrKSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBpZiAoIXpyVXRpbC5pc0FycmF5KGRpbWVuc2lvbnMpKSB7XG4gICAgc3RhY2sgPSBpZHg7XG4gICAgaWR4ID0gZGltZW5zaW9ucztcbiAgICBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpbWVuc2lvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YWx1ZXMucHVzaCh0aGlzLmdldChkaW1lbnNpb25zW2ldLCBpZHgsIHN0YWNrKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufTtcbi8qKlxuICogSWYgdmFsdWUgaXMgTmFOLiBJbmxjdWRpbmcgJy0nXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uaGFzVmFsdWUgPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICB2YXIgZGltZW5zaW9uSW5mb3MgPSB0aGlzLl9kaW1lbnNpb25JbmZvcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGltZW5zaW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICggLy8gT3JkaW5hbCB0eXBlIGNhbiBiZSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgZGltZW5zaW9uSW5mb3NbZGltZW5zaW9uc1tpXV0udHlwZSAhPT0gJ29yZGluYWwnICYmIGlzTmFOKHRoaXMuZ2V0KGRpbWVuc2lvbnNbaV0sIGlkeCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBHZXQgZXh0ZW50IG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyXG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0RGF0YUV4dGVudCA9IGZ1bmN0aW9uIChkaW0sIHN0YWNrLCBmaWx0ZXIpIHtcbiAgZGltID0gdGhpcy5nZXREaW1lbnNpb24oZGltKTtcbiAgdmFyIGRpbURhdGEgPSB0aGlzLl9zdG9yYWdlW2RpbV07XG4gIHZhciBkaW1JbmZvID0gdGhpcy5nZXREaW1lbnNpb25JbmZvKGRpbSk7XG4gIHN0YWNrID0gZGltSW5mbyAmJiBkaW1JbmZvLnN0YWNrYWJsZSAmJiBzdGFjaztcbiAgdmFyIGRpbUV4dGVudCA9ICh0aGlzLl9leHRlbnQgfHwgKHRoaXMuX2V4dGVudCA9IHt9KSlbZGltICsgISFzdGFja107XG4gIHZhciB2YWx1ZTtcblxuICBpZiAoZGltRXh0ZW50KSB7XG4gICAgcmV0dXJuIGRpbUV4dGVudDtcbiAgfSAvLyB2YXIgZGltSW5mbyA9IHRoaXMuX2RpbWVuc2lvbkluZm9zW2RpbV07XG5cblxuICBpZiAoZGltRGF0YSkge1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5OyAvLyB2YXIgaXNPcmRpbmFsID0gZGltSW5mby50eXBlID09PSAnb3JkaW5hbCc7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXQoZGltLCBpLCBzdGFjayk7IC8vIEZJWE1FXG4gICAgICAvLyBpZiAoaXNPcmRpbmFsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vICAgICB2YWx1ZSA9IHpyVXRpbC5pbmRleE9mKGRpbURhdGEsIHZhbHVlKTtcbiAgICAgIC8vIH1cblxuICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKHZhbHVlLCBkaW0sIGkpKSB7XG4gICAgICAgIHZhbHVlIDwgbWluICYmIChtaW4gPSB2YWx1ZSk7XG4gICAgICAgIHZhbHVlID4gbWF4ICYmIChtYXggPSB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2V4dGVudFtkaW0gKyAhIXN0YWNrXSA9IFttaW4sIG1heF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgfVxufTtcbi8qKlxuICogR2V0IHN1bSBvZiBkYXRhIGluIG9uZSBkaW1lbnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tcbiAqL1xuXG5cbmxpc3RQcm90by5nZXRTdW0gPSBmdW5jdGlvbiAoZGltLCBzdGFjaykge1xuICB2YXIgZGltRGF0YSA9IHRoaXMuX3N0b3JhZ2VbZGltXTtcbiAgdmFyIHN1bSA9IDA7XG5cbiAgaWYgKGRpbURhdGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGRpbSwgaSwgc3RhY2spO1xuXG4gICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1bTtcbn07XG4vKipcbiAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuLy8gRklYTUUgUHJlY2lzaW9uIG9mIGZsb2F0IHZhbHVlXG5cblxubGlzdFByb3RvLmluZGV4T2YgPSBmdW5jdGlvbiAoZGltLCB2YWx1ZSkge1xuICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gIHZhciBkaW1EYXRhID0gc3RvcmFnZVtkaW1dO1xuICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcblxuICBpZiAoZGltRGF0YSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcmF3SW5kZXggPSBpbmRpY2VzW2ldO1xuXG4gICAgICBpZiAoZGltRGF0YVtyYXdJbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn07XG4vKipcbiAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBuYW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uaW5kZXhPZk5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgdmFyIG5hbWVMaXN0ID0gdGhpcy5fbmFtZUxpc3Q7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcmF3SW5kZXggPSBpbmRpY2VzW2ldO1xuXG4gICAgaWYgKG5hbWVMaXN0W3Jhd0luZGV4XSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogUmV0cmVpdmUgdGhlIGluZGV4IHdpdGggZ2l2ZW4gcmF3IGRhdGEgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBuYW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uaW5kZXhPZlJhd0luZGV4ID0gZnVuY3Rpb24gKHJhd0luZGV4KSB7XG4gIC8vIEluZGljZXMgYXJlIGFzY2VuZGluZ1xuICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlczsgLy8gSWYgcmF3SW5kZXggPT09IGRhdGFJbmRleFxuXG4gIHZhciByYXdEYXRhSW5kZXggPSBpbmRpY2VzW3Jhd0luZGV4XTtcblxuICBpZiAocmF3RGF0YUluZGV4ICE9IG51bGwgJiYgcmF3RGF0YUluZGV4ID09PSByYXdJbmRleCkge1xuICAgIHJldHVybiByYXdJbmRleDtcbiAgfVxuXG4gIHZhciBsZWZ0ID0gMDtcbiAgdmFyIHJpZ2h0ID0gaW5kaWNlcy5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgdmFyIG1pZCA9IChsZWZ0ICsgcmlnaHQpIC8gMiB8IDA7XG5cbiAgICBpZiAoaW5kaWNlc1ttaWRdIDwgcmF3SW5kZXgpIHtcbiAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSBpZiAoaW5kaWNlc1ttaWRdID4gcmF3SW5kZXgpIHtcbiAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuLyoqXG4gKiBSZXRyZWl2ZSB0aGUgaW5kZXggb2YgbmVhcmVzdCB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrIElmIGdpdmVuIHZhbHVlIGlzIGFmdGVyIHN0YWNrZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RGlzdGFuY2U9SW5maW5pdHldXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gQ29uc2lkZXJlIG11bHRpcGxlIHBvaW50cyBoYXMgdGhlIHNhbWUgdmFsdWUuXG4gKi9cblxuXG5saXN0UHJvdG8uaW5kaWNlc09mTmVhcmVzdCA9IGZ1bmN0aW9uIChkaW0sIHZhbHVlLCBzdGFjaywgbWF4RGlzdGFuY2UpIHtcbiAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICB2YXIgZGltRGF0YSA9IHN0b3JhZ2VbZGltXTtcbiAgdmFyIG5lYXJlc3RJbmRpY2VzID0gW107XG5cbiAgaWYgKCFkaW1EYXRhKSB7XG4gICAgcmV0dXJuIG5lYXJlc3RJbmRpY2VzO1xuICB9XG5cbiAgaWYgKG1heERpc3RhbmNlID09IG51bGwpIHtcbiAgICBtYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuICB9XG5cbiAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICB2YXIgbWluRGlmZiA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBkaWZmID0gdmFsdWUgLSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTtcbiAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRpZmYpO1xuXG4gICAgaWYgKGRpZmYgPD0gbWF4RGlzdGFuY2UgJiYgZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICAvLyBGb3IgdGhlIGNhc2Ugb2YgdHdvIGRhdGEgYXJlIHNhbWUgb24geEF4aXMsIHdoaWNoIGhhcyBzZXF1ZW5jZSBkYXRhLlxuICAgICAgLy8gU2hvdyB0aGUgbmVhcmVzdCBpbmRleFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS9lY2hhcnRzL2lzc3Vlcy8yODY5XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QgfHwgZGlmZiA+PSAwICYmIG1pbkRpZmYgPCAwKSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBtaW5EaWZmID0gZGlmZjtcbiAgICAgICAgbmVhcmVzdEluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgICAgbmVhcmVzdEluZGljZXMucHVzaChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcmVzdEluZGljZXM7XG59O1xuLyoqXG4gKiBHZXQgcmF3IGRhdGEgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRSYXdJbmRleCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgdmFyIHJhd0lkeCA9IHRoaXMuaW5kaWNlc1tpZHhdO1xuICByZXR1cm4gcmF3SWR4ID09IG51bGwgPyAtMSA6IHJhd0lkeDtcbn07XG4vKipcbiAqIEdldCByYXcgZGF0YSBpdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0UmF3RGF0YUl0ZW0gPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHJldHVybiB0aGlzLl9yYXdEYXRhLmdldEl0ZW0odGhpcy5nZXRSYXdJbmRleChpZHgpKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vdERlZmF1bHRJZHg9ZmFsc2VdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0TmFtZSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgcmV0dXJuIHRoaXMuX25hbWVMaXN0W3RoaXMuaW5kaWNlc1tpZHhdXSB8fCAnJztcbn07XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vdERlZmF1bHRJZHg9ZmFsc2VdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0SWQgPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHJldHVybiB0aGlzLl9pZExpc3RbdGhpcy5pbmRpY2VzW2lkeF1dIHx8IHRoaXMuZ2V0UmF3SW5kZXgoaWR4KSArICcnO1xufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGltZW5zaW9ucyhkaW1lbnNpb25zKSB7XG4gIGlmICghenJVdGlsLmlzQXJyYXkoZGltZW5zaW9ucykpIHtcbiAgICBkaW1lbnNpb25zID0gW2RpbWVuc2lvbnNdO1xuICB9XG5cbiAgcmV0dXJuIGRpbWVuc2lvbnM7XG59XG4vKipcbiAqIERhdGEgaXRlcmF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFjaz1mYWxzZV1cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc11cbiAqXG4gKiBAZXhhbXBsZVxuICogIGxpc3QuZWFjaCgneCcsIGZ1bmN0aW9uICh4LCBpZHgpIHt9KTtcbiAqICBsaXN0LmVhY2goWyd4JywgJ3knXSwgZnVuY3Rpb24gKHgsIHksIGlkeCkge30pO1xuICogIGxpc3QuZWFjaChmdW5jdGlvbiAoaWR4KSB7fSlcbiAqL1xuXG5cbmxpc3RQcm90by5lYWNoID0gZnVuY3Rpb24gKGRpbXMsIGNiLCBzdGFjaywgY29udGV4dCkge1xuICBpZiAodHlwZW9mIGRpbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb250ZXh0ID0gc3RhY2s7XG4gICAgc3RhY2sgPSBjYjtcbiAgICBjYiA9IGRpbXM7XG4gICAgZGltcyA9IFtdO1xuICB9XG5cbiAgZGltcyA9IHpyVXRpbC5tYXAobm9ybWFsaXplRGltZW5zaW9ucyhkaW1zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXMpO1xuICB2YXIgdmFsdWUgPSBbXTtcbiAgdmFyIGRpbVNpemUgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgIHN3aXRjaCAoZGltU2l6ZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuZ2V0KGRpbXNbMF0sIGksIHN0YWNrKSwgaSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5nZXQoZGltc1swXSwgaSwgc3RhY2spLCB0aGlzLmdldChkaW1zWzFdLCBpLCBzdGFjayksIGkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkaW1TaXplOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZVtrXSA9IHRoaXMuZ2V0KGRpbXNba10sIGksIHN0YWNrKTtcbiAgICAgICAgfSAvLyBJbmRleFxuXG5cbiAgICAgICAgdmFsdWVba10gPSBpO1xuICAgICAgICBjYi5hcHBseShjb250ZXh0LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBEYXRhIGZpbHRlclxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gKi9cblxuXG5saXN0UHJvdG8uZmlsdGVyU2VsZiA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiBkaW1lbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGV4dCA9IHN0YWNrO1xuICAgIHN0YWNrID0gY2I7XG4gICAgY2IgPSBkaW1lbnNpb25zO1xuICAgIGRpbWVuc2lvbnMgPSBbXTtcbiAgfVxuXG4gIGRpbWVuc2lvbnMgPSB6clV0aWwubWFwKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzKTtcbiAgdmFyIG5ld0luZGljZXMgPSBbXTtcbiAgdmFyIHZhbHVlID0gW107XG4gIHZhciBkaW1TaXplID0gZGltZW5zaW9ucy5sZW5ndGg7XG4gIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZWVwOyAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG5cbiAgICBpZiAoIWRpbVNpemUpIHtcbiAgICAgIGtlZXAgPSBjYi5jYWxsKGNvbnRleHQsIGkpO1xuICAgIH0gZWxzZSBpZiAoZGltU2l6ZSA9PT0gMSkge1xuICAgICAga2VlcCA9IGNiLmNhbGwoY29udGV4dCwgdGhpcy5nZXQoZGltZW5zaW9uc1swXSwgaSwgc3RhY2spLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkaW1TaXplOyBrKyspIHtcbiAgICAgICAgdmFsdWVba10gPSB0aGlzLmdldChkaW1lbnNpb25zW2tdLCBpLCBzdGFjayk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlW2tdID0gaTtcbiAgICAgIGtlZXAgPSBjYi5hcHBseShjb250ZXh0LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGtlZXApIHtcbiAgICAgIG5ld0luZGljZXMucHVzaChpbmRpY2VzW2ldKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmluZGljZXMgPSBuZXdJbmRpY2VzOyAvLyBSZXNldCBkYXRhIGV4dGVudFxuXG4gIHRoaXMuX2V4dGVudCA9IHt9O1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIERhdGEgbWFwcGluZyB0byBhIHBsYWluIGFycmF5XG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2RpbWVuc2lvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmxpc3RQcm90by5tYXBBcnJheSA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiBkaW1lbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGV4dCA9IHN0YWNrO1xuICAgIHN0YWNrID0gY2I7XG4gICAgY2IgPSBkaW1lbnNpb25zO1xuICAgIGRpbWVuc2lvbnMgPSBbXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdGhpcy5lYWNoKGRpbWVuc2lvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICByZXN1bHQucHVzaChjYiAmJiBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSwgc3RhY2ssIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKG9yaWdpbmFsLCBleGNsdWRlRGltZW5zaW9ucykge1xuICB2YXIgYWxsRGltZW5zaW9ucyA9IG9yaWdpbmFsLmRpbWVuc2lvbnM7XG4gIHZhciBsaXN0ID0gbmV3IExpc3QoenJVdGlsLm1hcChhbGxEaW1lbnNpb25zLCBvcmlnaW5hbC5nZXREaW1lbnNpb25JbmZvLCBvcmlnaW5hbCksIG9yaWdpbmFsLmhvc3RNb2RlbCk7IC8vIEZJWE1FIElmIG5lZWRzIHN0YWNrZWRPbiwgdmFsdWUgbWF5IGFscmVhZHkgYmVlbiBzdGFja2VkXG5cbiAgdHJhbnNmZXJQcm9wZXJ0aWVzKGxpc3QsIG9yaWdpbmFsKTtcbiAgdmFyIHN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlID0ge307XG4gIHZhciBvcmlnaW5hbFN0b3JhZ2UgPSBvcmlnaW5hbC5fc3RvcmFnZTsgLy8gSW5pdCBzdG9yYWdlXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxEaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpbSA9IGFsbERpbWVuc2lvbnNbaV07XG4gICAgdmFyIGRpbVN0b3JlID0gb3JpZ2luYWxTdG9yYWdlW2RpbV07XG5cbiAgICBpZiAoenJVdGlsLmluZGV4T2YoZXhjbHVkZURpbWVuc2lvbnMsIGRpbSkgPj0gMCkge1xuICAgICAgc3RvcmFnZVtkaW1dID0gbmV3IGRpbVN0b3JlLmNvbnN0cnVjdG9yKG9yaWdpbmFsU3RvcmFnZVtkaW1dLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERpcmVjdCByZWZlcmVuY2UgZm9yIG90aGVyIGRpbWVuc2lvbnNcbiAgICAgIHN0b3JhZ2VbZGltXSA9IG9yaWdpbmFsU3RvcmFnZVtkaW1dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufVxuLyoqXG4gKiBEYXRhIG1hcHBpbmcgdG8gYSBuZXcgTGlzdCB3aXRoIGdpdmVuIGRpbWVuc2lvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmxpc3RQcm90by5tYXAgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gIGRpbWVuc2lvbnMgPSB6clV0aWwubWFwKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzKTtcbiAgdmFyIGxpc3QgPSBjbG9uZUxpc3RGb3JNYXBBbmRTYW1wbGUodGhpcywgZGltZW5zaW9ucyk7IC8vIEZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBhbGwgaW1tdXRhYmxlLlxuICAvLyBTbyB3ZSBjYW4gcmVmZXJlbmNlIHRvIHRoZSBzYW1lIHZhbHVlXG5cbiAgdmFyIGluZGljZXMgPSBsaXN0LmluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gIHZhciBzdG9yYWdlID0gbGlzdC5fc3RvcmFnZTtcbiAgdmFyIHRtcFJldFZhbHVlID0gW107XG4gIHRoaXMuZWFjaChkaW1lbnNpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHJldFZhbHVlID0gY2IgJiYgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmIChyZXRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBhIG51bWJlclxuICAgICAgaWYgKHR5cGVvZiByZXRWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdG1wUmV0VmFsdWVbMF0gPSByZXRWYWx1ZTtcbiAgICAgICAgcmV0VmFsdWUgPSB0bXBSZXRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGltID0gZGltZW5zaW9uc1tpXTtcbiAgICAgICAgdmFyIGRpbVN0b3JlID0gc3RvcmFnZVtkaW1dO1xuICAgICAgICB2YXIgcmF3SWR4ID0gaW5kaWNlc1tpZHhdO1xuXG4gICAgICAgIGlmIChkaW1TdG9yZSkge1xuICAgICAgICAgIGRpbVN0b3JlW3Jhd0lkeF0gPSByZXRWYWx1ZVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgc3RhY2ssIGNvbnRleHQpO1xuICByZXR1cm4gbGlzdDtcbn07XG4vKipcbiAqIExhcmdlIGRhdGEgZG93biBzYW1wbGluZyBvbiBnaXZlbiBkaW1lbnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSByYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzYW1wbGVWYWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2FtcGxlSW5kZXggU2FtcGxlIGluZGV4IGZvciBuYW1lIGFuZCBpZFxuICovXG5cblxubGlzdFByb3RvLmRvd25TYW1wbGUgPSBmdW5jdGlvbiAoZGltZW5zaW9uLCByYXRlLCBzYW1wbGVWYWx1ZSwgc2FtcGxlSW5kZXgpIHtcbiAgdmFyIGxpc3QgPSBjbG9uZUxpc3RGb3JNYXBBbmRTYW1wbGUodGhpcywgW2RpbWVuc2lvbl0pO1xuICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gIHZhciB0YXJnZXRTdG9yYWdlID0gbGlzdC5fc3RvcmFnZTtcbiAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgdmFyIGluZGljZXMgPSBsaXN0LmluZGljZXMgPSBbXTtcbiAgdmFyIGZyYW1lVmFsdWVzID0gW107XG4gIHZhciBmcmFtZUluZGljZXMgPSBbXTtcbiAgdmFyIGZyYW1lU2l6ZSA9IE1hdGguZmxvb3IoMSAvIHJhdGUpO1xuICB2YXIgZGltU3RvcmUgPSB0YXJnZXRTdG9yYWdlW2RpbWVuc2lvbl07XG4gIHZhciBsZW4gPSB0aGlzLmNvdW50KCk7IC8vIENvcHkgZGF0YSBmcm9tIG9yaWdpbmFsIGRhdGFcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JhZ2VbZGltZW5zaW9uXS5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldFN0b3JhZ2VbZGltZW5zaW9uXVtpXSA9IHN0b3JhZ2VbZGltZW5zaW9uXVtpXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IGZyYW1lU2l6ZSkge1xuICAgIC8vIExhc3QgZnJhbWVcbiAgICBpZiAoZnJhbWVTaXplID4gbGVuIC0gaSkge1xuICAgICAgZnJhbWVTaXplID0gbGVuIC0gaTtcbiAgICAgIGZyYW1lVmFsdWVzLmxlbmd0aCA9IGZyYW1lU2l6ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGZyYW1lU2l6ZTsgaysrKSB7XG4gICAgICB2YXIgaWR4ID0gb3JpZ2luYWxJbmRpY2VzW2kgKyBrXTtcbiAgICAgIGZyYW1lVmFsdWVzW2tdID0gZGltU3RvcmVbaWR4XTtcbiAgICAgIGZyYW1lSW5kaWNlc1trXSA9IGlkeDtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBzYW1wbGVWYWx1ZShmcmFtZVZhbHVlcyk7XG4gICAgdmFyIGlkeCA9IGZyYW1lSW5kaWNlc1tzYW1wbGVJbmRleChmcmFtZVZhbHVlcywgdmFsdWUpIHx8IDBdOyAvLyBPbmx5IHdyaXRlIHZhbHVlIG9uIHRoZSBmaWx0ZXJlZCBkYXRhXG5cbiAgICBkaW1TdG9yZVtpZHhdID0gdmFsdWU7XG4gICAgaW5kaWNlcy5wdXNoKGlkeCk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn07XG4vKipcbiAqIEdldCBtb2RlbCBvZiBvbmUgZGF0YSBpdGVtLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqL1xuLy8gRklYTUUgTW9kZWwgcHJveHkgP1xuXG5cbmxpc3RQcm90by5nZXRJdGVtTW9kZWwgPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHZhciBob3N0TW9kZWwgPSB0aGlzLmhvc3RNb2RlbDtcbiAgaWR4ID0gdGhpcy5pbmRpY2VzW2lkeF07XG4gIHJldHVybiBuZXcgTW9kZWwodGhpcy5fcmF3RGF0YS5nZXRJdGVtKGlkeCksIGhvc3RNb2RlbCwgaG9zdE1vZGVsICYmIGhvc3RNb2RlbC5lY01vZGVsKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhIGRhdGEgZGlmZmVyXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gb3RoZXJMaXN0XG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0RhdGFEaWZmZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uZGlmZiA9IGZ1bmN0aW9uIChvdGhlckxpc3QpIHtcbiAgdmFyIGlkTGlzdCA9IHRoaXMuX2lkTGlzdDtcbiAgdmFyIG90aGVySWRMaXN0ID0gb3RoZXJMaXN0ICYmIG90aGVyTGlzdC5faWRMaXN0O1xuICB2YXIgdmFsOyAvLyBVc2UgcHJlZml4IHRvIGF2b2lkIGluZGV4IHRvIGJlIHRoZSBzYW1lIGFzIG90aGVySWRMaXN0W2lkeF0sXG4gIC8vIHdoaWNoIHdpbGwgY2F1c2Ugd2VpcmQgdWRwYXRlIGFuaW1hdGlvbi5cblxuICB2YXIgcHJlZml4ID0gJ2VcXDBcXDAnO1xuICByZXR1cm4gbmV3IERhdGFEaWZmZXIob3RoZXJMaXN0ID8gb3RoZXJMaXN0LmluZGljZXMgOiBbXSwgdGhpcy5pbmRpY2VzLCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuICh2YWwgPSBvdGhlcklkTGlzdFtpZHhdKSAhPSBudWxsID8gdmFsIDogcHJlZml4ICsgaWR4O1xuICB9LCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuICh2YWwgPSBpZExpc3RbaWR4XSkgIT0gbnVsbCA/IHZhbCA6IHByZWZpeCArIGlkeDtcbiAgfSk7XG59O1xuLyoqXG4gKiBHZXQgdmlzdWFsIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cblxubGlzdFByb3RvLmdldFZpc3VhbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHZpc3VhbCA9IHRoaXMuX3Zpc3VhbDtcbiAgcmV0dXJuIHZpc3VhbCAmJiB2aXN1YWxba2V5XTtcbn07XG4vKipcbiAqIFNldCB2aXN1YWwgcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gKiBAcGFyYW0geyp9IFt2YWx1ZV1cbiAqXG4gKiBAZXhhbXBsZVxuICogIHNldFZpc3VhbCgnY29sb3InLCBjb2xvcik7XG4gKiAgc2V0VmlzdWFsKHtcbiAqICAgICAgJ2NvbG9yJzogY29sb3JcbiAqICB9KTtcbiAqL1xuXG5cbmxpc3RQcm90by5zZXRWaXN1YWwgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB0aGlzLnNldFZpc3VhbChuYW1lLCBrZXlbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3Zpc3VhbCA9IHRoaXMuX3Zpc3VhbCB8fCB7fTtcbiAgdGhpcy5fdmlzdWFsW2tleV0gPSB2YWw7XG59O1xuLyoqXG4gKiBTZXQgbGF5b3V0IHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAqIEBwYXJhbSB7Kn0gW3ZhbF1cbiAqL1xuXG5cbmxpc3RQcm90by5zZXRMYXlvdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB0aGlzLnNldExheW91dChuYW1lLCBrZXlbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2xheW91dFtrZXldID0gdmFsO1xufTtcbi8qKlxuICogR2V0IGxheW91dCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5LlxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRMYXlvdXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9sYXlvdXRba2V5XTtcbn07XG4vKipcbiAqIEdldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICovXG5cblxubGlzdFByb3RvLmdldEl0ZW1MYXlvdXQgPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHJldHVybiB0aGlzLl9pdGVtTGF5b3V0c1tpZHhdO1xufTtcbi8qKlxuICogU2V0IGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0XG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBbbWVyZ2U9ZmFsc2VdXG4gKi9cblxuXG5saXN0UHJvdG8uc2V0SXRlbUxheW91dCA9IGZ1bmN0aW9uIChpZHgsIGxheW91dCwgbWVyZ2UpIHtcbiAgdGhpcy5faXRlbUxheW91dHNbaWR4XSA9IG1lcmdlID8genJVdGlsLmV4dGVuZCh0aGlzLl9pdGVtTGF5b3V0c1tpZHhdIHx8IHt9LCBsYXlvdXQpIDogbGF5b3V0O1xufTtcbi8qKlxuICogQ2xlYXIgYWxsIGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gKi9cblxuXG5saXN0UHJvdG8uY2xlYXJJdGVtTGF5b3V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faXRlbUxheW91dHMubGVuZ3RoID0gMDtcbn07XG4vKipcbiAqIEdldCB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlUGFyZW50PWZhbHNlXVxuICovXG5cblxubGlzdFByb3RvLmdldEl0ZW1WaXN1YWwgPSBmdW5jdGlvbiAoaWR4LCBrZXksIGlnbm9yZVBhcmVudCkge1xuICB2YXIgaXRlbVZpc3VhbCA9IHRoaXMuX2l0ZW1WaXN1YWxzW2lkeF07XG4gIHZhciB2YWwgPSBpdGVtVmlzdWFsICYmIGl0ZW1WaXN1YWxba2V5XTtcblxuICBpZiAodmFsID09IG51bGwgJiYgIWlnbm9yZVBhcmVudCkge1xuICAgIC8vIFVzZSBnbG9iYWwgdmlzdWFsIHByb3BlcnR5XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmlzdWFsKGtleSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcbi8qKlxuICogU2V0IHZpc3VhbCBwcm9wZXJ0eSBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxuICpcbiAqIEBleGFtcGxlXG4gKiAgc2V0SXRlbVZpc3VhbCgwLCAnY29sb3InLCBjb2xvcik7XG4gKiAgc2V0SXRlbVZpc3VhbCgwLCB7XG4gKiAgICAgICdjb2xvcic6IGNvbG9yXG4gKiAgfSk7XG4gKi9cblxuXG5saXN0UHJvdG8uc2V0SXRlbVZpc3VhbCA9IGZ1bmN0aW9uIChpZHgsIGtleSwgdmFsdWUpIHtcbiAgdmFyIGl0ZW1WaXN1YWwgPSB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdIHx8IHt9O1xuICB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdID0gaXRlbVZpc3VhbDtcblxuICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGl0ZW1WaXN1YWxbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaXRlbVZpc3VhbFtrZXldID0gdmFsdWU7XG59O1xuLyoqXG4gKiBDbGVhciBpdGVtVmlzdWFscyBhbmQgbGlzdCB2aXN1YWwuXG4gKi9cblxuXG5saXN0UHJvdG8uY2xlYXJBbGxWaXN1YWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3Zpc3VhbCA9IHt9O1xuICB0aGlzLl9pdGVtVmlzdWFscyA9IFtdO1xufTtcblxudmFyIHNldEl0ZW1EYXRhQW5kU2VyaWVzSW5kZXggPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgY2hpbGQuc2VyaWVzSW5kZXggPSB0aGlzLnNlcmllc0luZGV4O1xuICBjaGlsZC5kYXRhSW5kZXggPSB0aGlzLmRhdGFJbmRleDtcbiAgY2hpbGQuZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlO1xufTtcbi8qKlxuICogU2V0IGdyYXBoaWMgZWxlbWVudCByZWxhdGl2ZSB0byBkYXRhLiBJdCBjYW4gYmUgc2V0IGFzIG51bGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gW2VsXVxuICovXG5cblxubGlzdFByb3RvLnNldEl0ZW1HcmFwaGljRWwgPSBmdW5jdGlvbiAoaWR4LCBlbCkge1xuICB2YXIgaG9zdE1vZGVsID0gdGhpcy5ob3N0TW9kZWw7XG5cbiAgaWYgKGVsKSB7XG4gICAgLy8gQWRkIGRhdGEgaW5kZXggYW5kIHNlcmllcyBpbmRleCBmb3IgaW5kZXhpbmcgdGhlIGRhdGEgYnkgZWxlbWVudFxuICAgIC8vIFVzZWZ1bCBpbiB0b29sdGlwXG4gICAgZWwuZGF0YUluZGV4ID0gaWR4O1xuICAgIGVsLmRhdGFUeXBlID0gdGhpcy5kYXRhVHlwZTtcbiAgICBlbC5zZXJpZXNJbmRleCA9IGhvc3RNb2RlbCAmJiBob3N0TW9kZWwuc2VyaWVzSW5kZXg7XG5cbiAgICBpZiAoZWwudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgZWwudHJhdmVyc2Uoc2V0SXRlbURhdGFBbmRTZXJpZXNJbmRleCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2dyYXBoaWNFbHNbaWR4XSA9IGVsO1xufTtcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRJdGVtR3JhcGhpY0VsID0gZnVuY3Rpb24gKGlkeCkge1xuICByZXR1cm4gdGhpcy5fZ3JhcGhpY0Vsc1tpZHhdO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICovXG5cblxubGlzdFByb3RvLmVhY2hJdGVtR3JhcGhpY0VsID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gIHpyVXRpbC5lYWNoKHRoaXMuX2dyYXBoaWNFbHMsIGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBjYiAmJiBjYi5jYWxsKGNvbnRleHQsIGVsLCBpZHgpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBTaGFsbG93IGNsb25lIGEgbmV3IGxpc3QgZXhjZXB0IHZpc3VhbCBhbmQgbGF5b3V0IHByb3BlcnRpZXMsIGFuZCBncmFwaCBlbGVtZW50cy5cbiAqIE5ldyBsaXN0IG9ubHkgY2hhbmdlIHRoZSBpbmRpY2VzLlxuICovXG5cblxubGlzdFByb3RvLmNsb25lU2hhbGxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRpbWVuc2lvbkluZm9MaXN0ID0genJVdGlsLm1hcCh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuZ2V0RGltZW5zaW9uSW5mbywgdGhpcyk7XG4gIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9uSW5mb0xpc3QsIHRoaXMuaG9zdE1vZGVsKTsgLy8gRklYTUVcblxuICBsaXN0Ll9zdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgdHJhbnNmZXJQcm9wZXJ0aWVzKGxpc3QsIHRoaXMpOyAvLyBDbG9uZSB3aWxsIG5vdCBjaGFuZ2UgdGhlIGRhdGEgZXh0ZW50IGFuZCBpbmRpY2VzXG5cbiAgbGlzdC5pbmRpY2VzID0gdGhpcy5pbmRpY2VzLnNsaWNlKCk7XG5cbiAgaWYgKHRoaXMuX2V4dGVudCkge1xuICAgIGxpc3QuX2V4dGVudCA9IHpyVXRpbC5leHRlbmQoe30sIHRoaXMuX2V4dGVudCk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn07XG4vKipcbiAqIFdyYXAgc29tZSBtZXRob2QgdG8gYWRkIG1vcmUgZmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGluamVjdEZ1bmN0aW9uXG4gKi9cblxuXG5saXN0UHJvdG8ud3JhcE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmplY3RGdW5jdGlvbikge1xuICB2YXIgb3JpZ2luYWxNZXRob2QgPSB0aGlzW21ldGhvZE5hbWVdO1xuXG4gIGlmICh0eXBlb2Ygb3JpZ2luYWxNZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9fd3JhcHBlZE1ldGhvZHMgPSB0aGlzLl9fd3JhcHBlZE1ldGhvZHMgfHwgW107XG5cbiAgdGhpcy5fX3dyYXBwZWRNZXRob2RzLnB1c2gobWV0aG9kTmFtZSk7XG5cbiAgdGhpc1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzID0gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaW5qZWN0RnVuY3Rpb24uYXBwbHkodGhpcywgW3Jlc10uY29uY2F0KHpyVXRpbC5zbGljZShhcmd1bWVudHMpKSk7XG4gIH07XG59OyAvLyBNZXRob2RzIHRoYXQgY3JlYXRlIGEgbmV3IGxpc3QgYmFzZWQgb24gdGhpcyBsaXN0IHNob3VsZCBiZSBsaXN0ZWQgaGVyZS5cbi8vIE5vdGljZSB0aGF0IHRob3NlIG1ldGhvZCBzaG91bGQgYFJFVFVSTmAgdGhlIG5ldyBsaXN0LlxuXG5cbmxpc3RQcm90by5UUkFOU0ZFUkFCTEVfTUVUSE9EUyA9IFsnY2xvbmVTaGFsbG93JywgJ2Rvd25TYW1wbGUnLCAnbWFwJ107IC8vIE1ldGhvZHMgdGhhdCBjaGFuZ2UgaW5kaWNlcyBvZiB0aGlzIGxpc3Qgc2hvdWxkIGJlIGxpc3RlZCBoZXJlLlxuXG5saXN0UHJvdG8uQ0hBTkdBQkxFX01FVEhPRFMgPSBbJ2ZpbHRlclNlbGYnXTtcbnZhciBfZGVmYXVsdCA9IExpc3Q7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9MaXN0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBfbW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIG5vcm1hbGl6ZVRvQXJyYXkgPSBfbW9kZWwubm9ybWFsaXplVG9BcnJheTtcblxuLyoqXG4gKiBDb21wbGV0ZSBkaW1lbnNpb25zIGJ5IGRhdGEgKGd1ZXNzIGRpbWVuc2lvbikuXG4gKi9cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgaXNTdHJpbmcgPSB6clV0aWwuaXNTdHJpbmc7XG52YXIgZGVmYXVsdHMgPSB6clV0aWwuZGVmYXVsdHM7XG52YXIgT1RIRVJfRElNUyA9IHtcbiAgdG9vbHRpcDogMSxcbiAgbGFiZWw6IDEsXG4gIGl0ZW1OYW1lOiAxXG59O1xuLyoqXG4gKiBDb21wbGV0ZSB0aGUgZGltZW5zaW9ucyBhcnJheSwgYnkgdXNlciBkZWZpbmVkIGBkaW1lbnNpb25gIGFuZCBgZW5jb2RlYCxcbiAqIGFuZCBndWVzc2luZyBmcm9tIHRoZSBkYXRhIHN0cnVjdHVyZS5cbiAqIElmIG5vICd2YWx1ZScgZGltZW5zaW9uIHNwZWNpZmllZCwgdGhlIGZpcnN0IG5vLW5hbWVkIGRpbWVuc2lvbiB3aWxsIGJlXG4gKiBuYW1lZCBhcyAndmFsdWUnLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHN5c0RpbXMgTmVjZXNzYXJ5IGRpbWVuc2lvbnMsIGxpa2UgWyd4JywgJ3knXSwgd2hpY2hcbiAqICAgICAgcHJvdmlkZXMgbm90IG9ubHkgZGltIHRlbXBsYXRlLCBidXQgYWxzbyBkZWZhdWx0IG9yZGVyLlxuICogICAgICBgbmFtZWAgb2YgZWFjaCBpdGVtIHByb3ZpZGVzIGRlZmF1bHQgY29vcmQgbmFtZS5cbiAqICAgICAgW3tkaW1zRGVmOiBbXX0sIC4uLl0gY2FuIGJlIHNwZWNpZmllZCB0byBnaXZlIG5hbWVzLlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBEYXRhIGxpc3QuIFtbMSwgMiwgM10sIFsyLCAzLCA0XV0uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdHxzdHJpbmc+fSBbb3B0LmRpbXNEZWZdIG9wdGlvbi5zZXJpZXMuZGltZW5zaW9ucyBVc2VyIGRlZmluZWQgZGltZW5zaW9uc1xuICogICAgICBGb3IgZXhhbXBsZTogWydhc2RmJywge25hbWUsIHR5cGV9LCAuLi5dLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQuZW5jb2RlRGVmXSBvcHRpb24uc2VyaWVzLmVuY29kZSB7eDogMiwgeTogWzMsIDFdLCB0b29sdGlwOiBbMSwgMl0sIGxhYmVsOiAzfVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuZXh0cmFQcmVmaXhdIFByZWZpeCBvZiBuYW1lIHdoZW4gZmlsbGluZyB0aGUgbGVmdCBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuZXh0cmFGcm9tWmVyb10gSWYgc3BlY2lmaWVkLCBleHRyYSBkaW0gbmFtZXMgd2lsbCBiZTpcbiAqICAgICAgICAgICAgICAgICAgICAgIGV4dHJhUHJlZml4ICsgMCwgZXh0cmFQcmVmaXggKyBleHRyYUJhc2VJbmRleCArIDEgLi4uXG4gKiAgICAgICAgICAgICAgICAgICAgICBJZiBub3Qgc3BlY2lmaWVkLCBleHRyYSBkaW0gbmFtZXMgd2lsbCBiZTpcbiAqICAgICAgICAgICAgICAgICAgICAgIGV4dHJhUHJlZml4LCBleHRyYVByZWZpeCArIDAsIGV4dHJhUHJlZml4ICsgMSAuLi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmRpbUNvdW50XSBJZiBub3Qgc3BlY2lmaWVkLCBndWVzcyBieSB0aGUgZmlyc3QgZGF0YSBpdGVtLlxuICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59IFt7XG4gKiAgICAgIG5hbWU6IHN0cmluZyBtYW5kYXRvcnksXG4gKiAgICAgIGNvb3JkRGltOiBzdHJpbmcgbWFuZGF0b3J5LFxuICogICAgICBjb29yZERpbUluZGV4OiBudW1iZXIgbWFuZGF0b3J5LFxuICogICAgICB0eXBlOiBzdHJpbmcgb3B0aW9uYWwsXG4gKiAgICAgIHRvb2x0aXBOYW1lOiBzdHJpbmcgb3B0aW9uYWwsXG4gKiAgICAgIG90aGVyRGltczoge1xuICogICAgICAgICAgdG9vbHRpcDogbnVtYmVyIG9wdGlvbmFsLFxuICogICAgICAgICAgbGFiZWw6IG51bWJlciBvcHRpb25hbFxuICogICAgICB9LFxuICogICAgICBpc0V4dHJhQ29vcmQ6IGJvb2xlYW4gdHJ1ZSBvciB1bmRlZmluZWQuXG4gKiAgICAgIG90aGVyIHByb3BzIC4uLlxuICogfV1cbiAqL1xuXG5mdW5jdGlvbiBjb21wbGV0ZURpbWVuc2lvbnMoc3lzRGltcywgZGF0YSwgb3B0KSB7XG4gIGRhdGEgPSBkYXRhIHx8IFtdO1xuICBvcHQgPSBvcHQgfHwge307XG4gIHN5c0RpbXMgPSAoc3lzRGltcyB8fCBbXSkuc2xpY2UoKTtcbiAgdmFyIGRpbXNEZWYgPSAob3B0LmRpbXNEZWYgfHwgW10pLnNsaWNlKCk7XG4gIHZhciBlbmNvZGVEZWYgPSB6clV0aWwuY3JlYXRlSGFzaE1hcChvcHQuZW5jb2RlRGVmKTtcbiAgdmFyIGRhdGFEaW1OYW1lTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgdmFyIGNvb3JkRGltTmFtZU1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7IC8vIHZhciB2YWx1ZUNhbmRpZGF0ZTtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBkaW1Db3VudCA9IG9wdC5kaW1Db3VudDtcblxuICBpZiAoZGltQ291bnQgPT0gbnVsbCkge1xuICAgIHZhciB2YWx1ZTAgPSByZXRyaWV2ZVZhbHVlKGRhdGFbMF0pO1xuICAgIGRpbUNvdW50ID0gTWF0aC5tYXgoenJVdGlsLmlzQXJyYXkodmFsdWUwKSAmJiB2YWx1ZTAubGVuZ3RoIHx8IDEsIHN5c0RpbXMubGVuZ3RoLCBkaW1zRGVmLmxlbmd0aCk7XG4gICAgZWFjaChzeXNEaW1zLCBmdW5jdGlvbiAoc3lzRGltSXRlbSkge1xuICAgICAgdmFyIHN5c0RpbUl0ZW1EaW1zRGVmID0gc3lzRGltSXRlbS5kaW1zRGVmO1xuICAgICAgc3lzRGltSXRlbURpbXNEZWYgJiYgKGRpbUNvdW50ID0gTWF0aC5tYXgoZGltQ291bnQsIHN5c0RpbUl0ZW1EaW1zRGVmLmxlbmd0aCkpO1xuICAgIH0pO1xuICB9IC8vIEFwcGx5IHVzZXIgZGVmaW5lZCBkaW1zIChgbmFtZWAgYW5kIGB0eXBlYCkgYW5kIGluaXQgcmVzdWx0LlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1Db3VudDsgaSsrKSB7XG4gICAgdmFyIGRpbURlZkl0ZW0gPSBpc1N0cmluZyhkaW1zRGVmW2ldKSA/IHtcbiAgICAgIG5hbWU6IGRpbXNEZWZbaV1cbiAgICB9IDogZGltc0RlZltpXSB8fCB7fTtcbiAgICB2YXIgdXNlckRpbU5hbWUgPSBkaW1EZWZJdGVtLm5hbWU7XG4gICAgdmFyIHJlc3VsdEl0ZW0gPSByZXN1bHRbaV0gPSB7XG4gICAgICBvdGhlckRpbXM6IHt9XG4gICAgfTsgLy8gTmFtZSB3aWxsIGJlIGFwcGxpZWQgbGF0ZXIgZm9yIGF2b2lkaW5nIGR1cGxpY2F0aW9uLlxuXG4gICAgaWYgKHVzZXJEaW1OYW1lICE9IG51bGwgJiYgZGF0YURpbU5hbWVNYXAuZ2V0KHVzZXJEaW1OYW1lKSA9PSBudWxsKSB7XG4gICAgICAvLyBPbmx5IGlmIGBzZXJpZXMuZGltZW5zaW9uc2AgaXMgZGVmaW5lZCBpbiBvcHRpb24sIHRvb2x0aXBOYW1lXG4gICAgICAvLyB3aWxsIGJlIHNldCwgYW5kIGRpbWVuc2lvbiB3aWxsIGJlIGRpcGxheWVkIHZlcnRpY2FsbHkgaW5cbiAgICAgIC8vIHRvb2x0aXAgYnkgZGVmYXVsdC5cbiAgICAgIHJlc3VsdEl0ZW0ubmFtZSA9IHJlc3VsdEl0ZW0udG9vbHRpcE5hbWUgPSB1c2VyRGltTmFtZTtcbiAgICAgIGRhdGFEaW1OYW1lTWFwLnNldCh1c2VyRGltTmFtZSwgaSk7XG4gICAgfVxuXG4gICAgZGltRGVmSXRlbS50eXBlICE9IG51bGwgJiYgKHJlc3VsdEl0ZW0udHlwZSA9IGRpbURlZkl0ZW0udHlwZSk7XG4gIH0gLy8gU2V0IGBjb29yZERpbWAgYW5kIGBjb29yZERpbUluZGV4YCBieSBgZW5jb2RlRGVmYCBhbmQgbm9ybWFsaXplIGBlbmNvZGVEZWZgLlxuXG5cbiAgZW5jb2RlRGVmLmVhY2goZnVuY3Rpb24gKGRhdGFEaW1zLCBjb29yZERpbSkge1xuICAgIGRhdGFEaW1zID0gZW5jb2RlRGVmLnNldChjb29yZERpbSwgbm9ybWFsaXplVG9BcnJheShkYXRhRGltcykuc2xpY2UoKSk7XG4gICAgZWFjaChkYXRhRGltcywgZnVuY3Rpb24gKHJlc3VsdERpbUlkeCwgY29vcmREaW1JbmRleCkge1xuICAgICAgLy8gVGhlIGlucHV0IHJlc3VsdERpbUlkeCBjYW4gYmUgZGltIG5hbWUgb3IgaW5kZXguXG4gICAgICBpc1N0cmluZyhyZXN1bHREaW1JZHgpICYmIChyZXN1bHREaW1JZHggPSBkYXRhRGltTmFtZU1hcC5nZXQocmVzdWx0RGltSWR4KSk7XG5cbiAgICAgIGlmIChyZXN1bHREaW1JZHggIT0gbnVsbCAmJiByZXN1bHREaW1JZHggPCBkaW1Db3VudCkge1xuICAgICAgICBkYXRhRGltc1tjb29yZERpbUluZGV4XSA9IHJlc3VsdERpbUlkeDtcbiAgICAgICAgYXBwbHlEaW0ocmVzdWx0W3Jlc3VsdERpbUlkeF0sIGNvb3JkRGltLCBjb29yZERpbUluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIEFwcGx5IHRlbXBsZXRlcyBhbmQgZGVmYXVsdCBvcmRlciBmcm9tIGBzeXNEaW1zYC5cblxuICB2YXIgYXZhaWxEaW1JZHggPSAwO1xuICBlYWNoKHN5c0RpbXMsIGZ1bmN0aW9uIChzeXNEaW1JdGVtLCBzeXNEaW1JbmRleCkge1xuICAgIHZhciBjb29yZERpbTtcbiAgICB2YXIgc3lzRGltSXRlbTtcbiAgICB2YXIgc3lzRGltSXRlbURpbXNEZWY7XG4gICAgdmFyIHN5c0RpbUl0ZW1PdGhlckRpbXM7XG5cbiAgICBpZiAoaXNTdHJpbmcoc3lzRGltSXRlbSkpIHtcbiAgICAgIGNvb3JkRGltID0gc3lzRGltSXRlbTtcbiAgICAgIHN5c0RpbUl0ZW0gPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmREaW0gPSBzeXNEaW1JdGVtLm5hbWU7XG4gICAgICBzeXNEaW1JdGVtID0genJVdGlsLmNsb25lKHN5c0RpbUl0ZW0pOyAvLyBgY29vcmREaW1JbmRleGAgc2hvdWxkIG5vdCBiZSBzZXQgZGlyZWN0bHkuXG5cbiAgICAgIHN5c0RpbUl0ZW1EaW1zRGVmID0gc3lzRGltSXRlbS5kaW1zRGVmO1xuICAgICAgc3lzRGltSXRlbU90aGVyRGltcyA9IHN5c0RpbUl0ZW0ub3RoZXJEaW1zO1xuICAgICAgc3lzRGltSXRlbS5uYW1lID0gc3lzRGltSXRlbS5jb29yZERpbSA9IHN5c0RpbUl0ZW0uY29vcmREaW1JbmRleCA9IHN5c0RpbUl0ZW0uZGltc0RlZiA9IHN5c0RpbUl0ZW0ub3RoZXJEaW1zID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZGF0YURpbXMgPSBub3JtYWxpemVUb0FycmF5KGVuY29kZURlZi5nZXQoY29vcmREaW0pKTsgLy8gZGltZW5zaW9ucyBwcm92aWRlcyBkZWZhdWx0IGRpbSBzZXF1ZW5jZXMuXG5cbiAgICBpZiAoIWRhdGFEaW1zLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoc3lzRGltSXRlbURpbXNEZWYgJiYgc3lzRGltSXRlbURpbXNEZWYubGVuZ3RoIHx8IDEpOyBpKyspIHtcbiAgICAgICAgd2hpbGUgKGF2YWlsRGltSWR4IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbYXZhaWxEaW1JZHhdLmNvb3JkRGltICE9IG51bGwpIHtcbiAgICAgICAgICBhdmFpbERpbUlkeCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgYXZhaWxEaW1JZHggPCByZXN1bHQubGVuZ3RoICYmIGRhdGFEaW1zLnB1c2goYXZhaWxEaW1JZHgrKyk7XG4gICAgICB9XG4gICAgfSAvLyBBcHBseSB0ZW1wbGF0ZXMuXG5cblxuICAgIGVhY2goZGF0YURpbXMsIGZ1bmN0aW9uIChyZXN1bHREaW1JZHgsIGNvb3JkRGltSW5kZXgpIHtcbiAgICAgIHZhciByZXN1bHRJdGVtID0gcmVzdWx0W3Jlc3VsdERpbUlkeF07XG4gICAgICBhcHBseURpbShkZWZhdWx0cyhyZXN1bHRJdGVtLCBzeXNEaW1JdGVtKSwgY29vcmREaW0sIGNvb3JkRGltSW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0SXRlbS5uYW1lID09IG51bGwgJiYgc3lzRGltSXRlbURpbXNEZWYpIHtcbiAgICAgICAgcmVzdWx0SXRlbS5uYW1lID0gcmVzdWx0SXRlbS50b29sdGlwTmFtZSA9IHN5c0RpbUl0ZW1EaW1zRGVmW2Nvb3JkRGltSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBzeXNEaW1JdGVtT3RoZXJEaW1zICYmIGRlZmF1bHRzKHJlc3VsdEl0ZW0ub3RoZXJEaW1zLCBzeXNEaW1JdGVtT3RoZXJEaW1zKTtcbiAgICB9KTtcbiAgfSk7IC8vIE1ha2Ugc3VyZSB0aGUgZmlyc3QgZXh0cmEgZGltIGlzICd2YWx1ZScuXG5cbiAgdmFyIGV4dHJhID0gb3B0LmV4dHJhUHJlZml4IHx8ICd2YWx1ZSc7IC8vIFNldCBkaW0gYG5hbWVgIGFuZCBvdGhlciBgY29vcmREaW1gIGFuZCBvdGhlciBwcm9wcy5cblxuICBmb3IgKHZhciByZXN1bHREaW1JZHggPSAwOyByZXN1bHREaW1JZHggPCBkaW1Db3VudDsgcmVzdWx0RGltSWR4KyspIHtcbiAgICB2YXIgcmVzdWx0SXRlbSA9IHJlc3VsdFtyZXN1bHREaW1JZHhdID0gcmVzdWx0W3Jlc3VsdERpbUlkeF0gfHwge307XG4gICAgdmFyIGNvb3JkRGltID0gcmVzdWx0SXRlbS5jb29yZERpbTtcbiAgICBjb29yZERpbSA9PSBudWxsICYmIChyZXN1bHRJdGVtLmNvb3JkRGltID0gZ2VuTmFtZShleHRyYSwgY29vcmREaW1OYW1lTWFwLCBvcHQuZXh0cmFGcm9tWmVybyksIHJlc3VsdEl0ZW0uY29vcmREaW1JbmRleCA9IDAsIHJlc3VsdEl0ZW0uaXNFeHRyYUNvb3JkID0gdHJ1ZSk7XG4gICAgcmVzdWx0SXRlbS5uYW1lID09IG51bGwgJiYgKHJlc3VsdEl0ZW0ubmFtZSA9IGdlbk5hbWUocmVzdWx0SXRlbS5jb29yZERpbSwgZGF0YURpbU5hbWVNYXApKTtcbiAgICByZXN1bHRJdGVtLnR5cGUgPT0gbnVsbCAmJiBndWVzc09yZGluYWwoZGF0YSwgcmVzdWx0RGltSWR4KSAmJiAocmVzdWx0SXRlbS50eXBlID0gJ29yZGluYWwnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG5cbiAgZnVuY3Rpb24gYXBwbHlEaW0ocmVzdWx0SXRlbSwgY29vcmREaW0sIGNvb3JkRGltSW5kZXgpIHtcbiAgICBpZiAoT1RIRVJfRElNU1tjb29yZERpbV0pIHtcbiAgICAgIHJlc3VsdEl0ZW0ub3RoZXJEaW1zW2Nvb3JkRGltXSA9IGNvb3JkRGltSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdEl0ZW0uY29vcmREaW0gPSBjb29yZERpbTtcbiAgICAgIHJlc3VsdEl0ZW0uY29vcmREaW1JbmRleCA9IGNvb3JkRGltSW5kZXg7XG4gICAgICBjb29yZERpbU5hbWVNYXAuc2V0KGNvb3JkRGltLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5OYW1lKG5hbWUsIG1hcCwgZnJvbVplcm8pIHtcbiAgICBpZiAoZnJvbVplcm8gfHwgbWFwLmdldChuYW1lKSAhPSBudWxsKSB7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChtYXAuZ2V0KG5hbWUgKyBpKSAhPSBudWxsKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgbmFtZSArPSBpO1xuICAgIH1cblxuICAgIG1hcC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn0gLy8gVGhlIHJ1bGUgc2hvdWxkIG5vdCBiZSBjb21wbGV4LCBvdGhlcndpc2UgdXNlciBtaWdodCBub3Rcbi8vIGJlIGFibGUgdG8ga25vd24gd2hlcmUgdGhlIGRhdGEgaXMgd3JvbmcuXG5cblxudmFyIGd1ZXNzT3JkaW5hbCA9IGNvbXBsZXRlRGltZW5zaW9ucy5ndWVzc09yZGluYWwgPSBmdW5jdGlvbiAoZGF0YSwgZGltSW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSByZXRyaWV2ZVZhbHVlKGRhdGFbaV0pO1xuXG4gICAgaWYgKCF6clV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSB2YWx1ZVtkaW1JbmRleF07IC8vIENvbnNpZGVyIHVzYWdlIGNvbnZlbmllbmNlLCAnMScsICcyJyB3aWxsIGJlIHRyZWF0ZWQgYXMgXCJudW1iZXJcIi5cbiAgICAvLyBgaXNGaW5pdCgnJylgIGdldCBgdHJ1ZWAuXG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUgIT09ICctJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmV0cmlldmVWYWx1ZShvKSB7XG4gIHJldHVybiB6clV0aWwuaXNBcnJheShvKSA/IG8gOiB6clV0aWwuaXNPYmplY3QobykgPyBvLnZhbHVlIDogbztcbn1cblxudmFyIF9kZWZhdWx0ID0gY29tcGxldGVEaW1lbnNpb25zO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyZW5kZXIgPSByZXF1aXJlKFwienJlbmRlci9saWIvenJlbmRlclwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBjb2xvclRvb2wgPSByZXF1aXJlKFwienJlbmRlci9saWIvdG9vbC9jb2xvclwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2VudlwiKTtcblxudmFyIHRpbXNvcnQgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS90aW1zb3J0XCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBHbG9iYWxNb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsL0dsb2JhbFwiKTtcblxudmFyIEV4dGVuc2lvbkFQSSA9IHJlcXVpcmUoXCIuL0V4dGVuc2lvbkFQSVwiKTtcblxudmFyIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyID0gcmVxdWlyZShcIi4vQ29vcmRpbmF0ZVN5c3RlbVwiKTtcblxudmFyIE9wdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9tb2RlbC9PcHRpb25NYW5hZ2VyXCIpO1xuXG52YXIgYmFja3dhcmRDb21wYXQgPSByZXF1aXJlKFwiLi9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXRcIik7XG5cbnZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsL0NvbXBvbmVudFwiKTtcblxudmFyIFNlcmllc01vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvU2VyaWVzXCIpO1xuXG52YXIgQ29tcG9uZW50VmlldyA9IHJlcXVpcmUoXCIuL3ZpZXcvQ29tcG9uZW50XCIpO1xuXG52YXIgQ2hhcnRWaWV3ID0gcmVxdWlyZShcIi4vdmlldy9DaGFydFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21vZGVsXCIpO1xuXG52YXIgX3Rocm90dGxlID0gcmVxdWlyZShcIi4vdXRpbC90aHJvdHRsZVwiKTtcblxudmFyIHRocm90dGxlID0gX3Rocm90dGxlLnRocm90dGxlO1xuXG52YXIgc2VyaWVzQ29sb3IgPSByZXF1aXJlKFwiLi92aXN1YWwvc2VyaWVzQ29sb3JcIik7XG5cbnZhciBsb2FkaW5nRGVmYXVsdCA9IHJlcXVpcmUoXCIuL2xvYWRpbmcvZGVmYXVsdFwiKTtcblxuLyohXG4gKiBFQ2hhcnRzLCBhIGphdmFzY3JpcHQgaW50ZXJhY3RpdmUgY2hhcnQgbGlicmFyeS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJhaWR1IEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS9lY2hhcnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4gKi9cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgcGFyc2VDbGFzc1R5cGUgPSBDb21wb25lbnRNb2RlbC5wYXJzZUNsYXNzVHlwZTtcbnZhciB2ZXJzaW9uID0gJzMuOC41JztcbnZhciBkZXBlbmRlbmNpZXMgPSB7XG4gIHpyZW5kZXI6ICczLjcuNCdcbn07XG52YXIgUFJJT1JJVFlfUFJPQ0VTU09SX0ZJTFRFUiA9IDEwMDA7XG52YXIgUFJJT1JJVFlfUFJPQ0VTU09SX1NUQVRJU1RJQyA9IDUwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0xBWU9VVCA9IDEwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0dMT0JBTCA9IDIwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0NIQVJUID0gMzAwMDtcbnZhciBQUklPUklUWV9WSVNVQUxfQ09NUE9ORU5UID0gNDAwMDsgLy8gRklYTUVcbi8vIG5lY2Vzc2FyeT9cblxudmFyIFBSSU9SSVRZX1ZJU1VBTF9CUlVTSCA9IDUwMDA7XG52YXIgUFJJT1JJVFkgPSB7XG4gIFBST0NFU1NPUjoge1xuICAgIEZJTFRFUjogUFJJT1JJVFlfUFJPQ0VTU09SX0ZJTFRFUixcbiAgICBTVEFUSVNUSUM6IFBSSU9SSVRZX1BST0NFU1NPUl9TVEFUSVNUSUNcbiAgfSxcbiAgVklTVUFMOiB7XG4gICAgTEFZT1VUOiBQUklPUklUWV9WSVNVQUxfTEFZT1VULFxuICAgIEdMT0JBTDogUFJJT1JJVFlfVklTVUFMX0dMT0JBTCxcbiAgICBDSEFSVDogUFJJT1JJVFlfVklTVUFMX0NIQVJULFxuICAgIENPTVBPTkVOVDogUFJJT1JJVFlfVklTVUFMX0NPTVBPTkVOVCxcbiAgICBCUlVTSDogUFJJT1JJVFlfVklTVUFMX0JSVVNIXG4gIH1cbn07IC8vIE1haW4gcHJvY2VzcyBoYXZlIHRocmVlIGVudHJpZXM6IGBzZXRPcHRpb25gLCBgZGlzcGF0Y2hBY3Rpb25gIGFuZCBgcmVzaXplYCxcbi8vIHdoZXJlIHRoZXkgbXVzdCBub3QgYmUgaW52b2tlZCBuZXN0ZWRseSwgZXhjZXB0IHRoZSBvbmx5IGNhc2U6IGludm9rZVxuLy8gZGlzcGF0Y2hBY3Rpb24gd2l0aCB1cGRhdGVNZXRob2QgXCJub25lXCIgaW4gbWFpbiBwcm9jZXNzLlxuLy8gVGhpcyBmbGFnIGlzIHVzZWQgdG8gY2Fycnkgb3V0IHRoaXMgcnVsZS5cbi8vIEFsbCBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQgb3V0IHNpZGUgbWFpbiBwcm9jZXNzIChpLmUuIHdoZW4gIXRoaXNbSU5fTUFJTl9QUk9DRVNTXSkuXG5cbnZhciBJTl9NQUlOX1BST0NFU1MgPSAnX19mbGFnSW5NYWluUHJvY2Vzcyc7XG52YXIgSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkcgPSAnX19oYXNHcmFkaWVudE9yUGF0dGVybkJnJztcbnZhciBPUFRJT05fVVBEQVRFRCA9ICdfX29wdGlvblVwZGF0ZWQnO1xudmFyIEFDVElPTl9SRUcgPSAvXlthLXpBLVowLTlfXSskLztcblxuZnVuY3Rpb24gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIC8vIEV2ZW50IG5hbWUgaXMgYWxsIGxvd2VyY2FzZVxuICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZSAmJiBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBFdmVudGZ1bC5wcm90b3R5cGVbbWV0aG9kXS5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlciwgY29udGV4dCk7XG4gIH07XG59XG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0c35NZXNzYWdlQ2VudGVyXG4gKi9cblxuXG5mdW5jdGlvbiBNZXNzYWdlQ2VudGVyKCkge1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xufVxuXG5NZXNzYWdlQ2VudGVyLnByb3RvdHlwZS5vbiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb24nKTtcbk1lc3NhZ2VDZW50ZXIucHJvdG90eXBlLm9mZiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb2ZmJyk7XG5NZXNzYWdlQ2VudGVyLnByb3RvdHlwZS5vbmUgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uZScpO1xuenJVdGlsLm1peGluKE1lc3NhZ2VDZW50ZXIsIEV2ZW50ZnVsKTtcbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzfkVDaGFydHNcbiAqL1xuXG5mdW5jdGlvbiBFQ2hhcnRzKGRvbSwgdGhlbWUsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307IC8vIEdldCB0aGVtZSBieSBuYW1lXG5cbiAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGVtZSA9IHRoZW1lU3RvcmFnZVt0aGVtZV07XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgdGhpcy5pZDtcbiAgLyoqXG4gICAqIEdyb3VwIGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuZ3JvdXA7XG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2RvbSA9IGRvbTtcbiAgdmFyIGRlZmF1bHRSZW5kZXJlciA9ICdjYW52YXMnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciB6ciA9IHRoaXMuX3pyID0genJlbmRlci5pbml0KGRvbSwge1xuICAgIHJlbmRlcmVyOiBvcHRzLnJlbmRlcmVyIHx8IGRlZmF1bHRSZW5kZXJlcixcbiAgICBkZXZpY2VQaXhlbFJhdGlvOiBvcHRzLmRldmljZVBpeGVsUmF0aW8sXG4gICAgd2lkdGg6IG9wdHMud2lkdGgsXG4gICAgaGVpZ2h0OiBvcHRzLmhlaWdodFxuICB9KTtcbiAgLyoqXG4gICAqIEV4cGVjdCA2MCBwZnMuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fdGhyb3R0bGVkWnJGbHVzaCA9IHRocm90dGxlKHpyVXRpbC5iaW5kKHpyLmZsdXNoLCB6ciksIDE3KTtcbiAgdmFyIHRoZW1lID0genJVdGlsLmNsb25lKHRoZW1lKTtcbiAgdGhlbWUgJiYgYmFja3dhcmRDb21wYXQodGhlbWUsIHRydWUpO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fdGhlbWUgPSB0aGVtZTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvdmlldy9DaGFydD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2NoYXJ0c1ZpZXdzID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9jaGFydHNNYXAgPSB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9jb21wb25lbnRzVmlld3MgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9jb21wb25lbnRzTWFwID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvQ29vcmRpbmF0ZVN5c3RlbX1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY29vcmRTeXNNZ3IgPSBuZXcgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2FwaSA9IGNyZWF0ZUV4dGVuc2lvbkFQSSh0aGlzKTtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0c35NZXNzYWdlQ2VudGVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9tZXNzYWdlQ2VudGVyID0gbmV3IE1lc3NhZ2VDZW50ZXIoKTsgLy8gSW5pdCBtb3VzZSBldmVudHNcblxuICB0aGlzLl9pbml0RXZlbnRzKCk7IC8vIEluIGNhc2Ugc29tZSBwZW9wbGUgd3JpdGUgYHdpbmRvdy5vbnJlc2l6ZSA9IGNoYXJ0LnJlc2l6ZWBcblxuXG4gIHRoaXMucmVzaXplID0genJVdGlsLmJpbmQodGhpcy5yZXNpemUsIHRoaXMpOyAvLyBDYW4ndCBkaXNwYXRjaCBhY3Rpb24gZHVyaW5nIHJlbmRlcmluZyBwcm9jZWR1cmVcblxuICB0aGlzLl9wZW5kaW5nQWN0aW9ucyA9IFtdOyAvLyBTb3J0IG9uIGRlbWFuZFxuXG4gIGZ1bmN0aW9uIHByaW9yaXR5U29ydEZ1bmMoYSwgYikge1xuICAgIHJldHVybiBhLnByaW8gLSBiLnByaW87XG4gIH1cblxuICB0aW1zb3J0KHZpc3VhbEZ1bmNzLCBwcmlvcml0eVNvcnRGdW5jKTtcbiAgdGltc29ydChkYXRhUHJvY2Vzc29yRnVuY3MsIHByaW9yaXR5U29ydEZ1bmMpO1xuICB6ci5hbmltYXRpb24ub24oJ2ZyYW1lJywgdGhpcy5fb25mcmFtZSwgdGhpcyk7IC8vIEVDaGFydHMgaW5zdGFuY2UgY2FuIGJlIHVzZWQgYXMgdmFsdWUuXG5cbiAgenJVdGlsLnNldEFzUHJpbWl0aXZlKHRoaXMpO1xufVxuXG52YXIgZWNoYXJ0c1Byb3RvID0gRUNoYXJ0cy5wcm90b3R5cGU7XG5cbmVjaGFydHNQcm90by5fb25mcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gTGF6eSB1cGRhdGVcbiAgaWYgKHRoaXNbT1BUSU9OX1VQREFURURdKSB7XG4gICAgdmFyIHNpbGVudCA9IHRoaXNbT1BUSU9OX1VQREFURURdLnNpbGVudDtcbiAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuICAgIHVwZGF0ZU1ldGhvZHMucHJlcGFyZUFuZFVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0gZmFsc2U7XG4gICAgZmx1c2hQZW5kaW5nQWN0aW9ucy5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gIH1cbn07XG4vKipcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldERvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RvbTtcbn07XG4vKipcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyflpSZW5kZXJ9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0WnIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl96cjtcbn07XG4vKipcbiAqIFVzYWdlOlxuICogY2hhcnQuc2V0T3B0aW9uKG9wdGlvbiwgbm90TWVyZ2UsIGxhenlVcGRhdGUpO1xuICogY2hhcnQuc2V0T3B0aW9uKG9wdGlvbiwge1xuICogICAgIG5vdE1lcmdlOiAuLi4sXG4gKiAgICAgbGF6eVVwZGF0ZTogLi4uLFxuICogICAgIHNpbGVudDogLi4uXG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gKiBAcGFyYW0ge09iamVjdHxib29sZWFufSBbb3B0c10gb3B0cyBvciBub3RNZXJnZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMubm90TWVyZ2U9ZmFsc2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmxhenlVcGRhdGU9ZmFsc2VdIFVzZWZ1bCB3aGVuIHNldE9wdGlvbiBmcmVxdWVudGx5LlxuICovXG5cblxuZWNoYXJ0c1Byb3RvLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24sIG5vdE1lcmdlLCBsYXp5VXBkYXRlKSB7XG4gIHZhciBzaWxlbnQ7XG5cbiAgaWYgKHpyVXRpbC5pc09iamVjdChub3RNZXJnZSkpIHtcbiAgICBsYXp5VXBkYXRlID0gbm90TWVyZ2UubGF6eVVwZGF0ZTtcbiAgICBzaWxlbnQgPSBub3RNZXJnZS5zaWxlbnQ7XG4gICAgbm90TWVyZ2UgPSBub3RNZXJnZS5ub3RNZXJnZTtcbiAgfVxuXG4gIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG5cbiAgaWYgKCF0aGlzLl9tb2RlbCB8fCBub3RNZXJnZSkge1xuICAgIHZhciBvcHRpb25NYW5hZ2VyID0gbmV3IE9wdGlvbk1hbmFnZXIodGhpcy5fYXBpKTtcbiAgICB2YXIgdGhlbWUgPSB0aGlzLl90aGVtZTtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsID0gbmV3IEdsb2JhbE1vZGVsKG51bGwsIG51bGwsIHRoZW1lLCBvcHRpb25NYW5hZ2VyKTtcbiAgICBlY01vZGVsLmluaXQobnVsbCwgbnVsbCwgdGhlbWUsIG9wdGlvbk1hbmFnZXIpO1xuICB9XG5cbiAgdGhpcy5fbW9kZWwuc2V0T3B0aW9uKG9wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpO1xuXG4gIGlmIChsYXp5VXBkYXRlKSB7XG4gICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSB7XG4gICAgICBzaWxlbnQ6IHNpbGVudFxuICAgIH07XG4gICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlTWV0aG9kcy5wcmVwYXJlQW5kVXBkYXRlLmNhbGwodGhpcyk7IC8vIEVuc3VyZSB6ciByZWZyZXNoIHN5Y2hyb25vdXNseSwgYW5kIHRoZW4gcGl4ZWwgaW4gY2FudmFzIGNhbiBiZVxuICAgIC8vIGZldGNoZWQgYWZ0ZXIgYHNldE9wdGlvbmAuXG5cbiAgICB0aGlzLl96ci5mbHVzaCgpO1xuXG4gICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSBmYWxzZTtcbiAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcbiAgICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgc2lsZW50KTtcbiAgICB0cmlnZ2VyVXBkYXRlZEV2ZW50LmNhbGwodGhpcywgc2lsZW50KTtcbiAgfVxufTtcbi8qKlxuICogQERFUFJFQ0FURURcbiAqL1xuXG5cbmVjaGFydHNQcm90by5zZXRUaGVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc29sZS5sb2coJ0VDaGFydHMjc2V0VGhlbWUoKSBpcyBERVBSRUNBVEVEIGluIEVDaGFydHMgMy4wJyk7XG59O1xuLyoqXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlbDtcbn07XG4vKipcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRPcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlbCAmJiB0aGlzLl9tb2RlbC5nZXRPcHRpb24oKTtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3pyLmdldFdpZHRoKCk7XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fenIuZ2V0SGVpZ2h0KCk7XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0RGV2aWNlUGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3pyLnBhaW50ZXIuZHByIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG59O1xuLyoqXG4gKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldFJlbmRlcmVkQ2FudmFzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMucGl4ZWxSYXRpbyA9IG9wdHMucGl4ZWxSYXRpbyB8fCAxO1xuICBvcHRzLmJhY2tncm91bmRDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yIHx8IHRoaXMuX21vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gIHZhciB6ciA9IHRoaXMuX3pyO1xuICB2YXIgbGlzdCA9IHpyLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTsgLy8gU3RvcCBhbmltYXRpb25zXG5cbiAgenJVdGlsLmVhY2gobGlzdCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgfSk7XG4gIHJldHVybiB6ci5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKG9wdHMpO1xufTtcbi8qKlxuICogR2V0IHN2ZyBkYXRhIHVybFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldFN2Z0RhdGFVcmwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghZW52LnN2Z1N1cHBvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB6ciA9IHRoaXMuX3pyO1xuICB2YXIgbGlzdCA9IHpyLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTsgLy8gU3RvcCBhbmltYXRpb25zXG5cbiAgenJVdGlsLmVhY2gobGlzdCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgfSk7XG4gIHJldHVybiB6ci5wYWludGVyLnBhdGhUb1N2ZygpO1xufTtcbi8qKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50eXBlPSdwbmcnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnBpeGVsUmF0aW89MV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZXhjbHVkZUNvbXBvbmVudHNdXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0RGF0YVVSTCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgZXhjbHVkZUNvbXBvbmVudHMgPSBvcHRzLmV4Y2x1ZGVDb21wb25lbnRzO1xuICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICB2YXIgZXhjbHVkZXNDb21wb25lbnRWaWV3cyA9IFtdO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGVhY2goZXhjbHVkZUNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiBjb21wb25lbnRUeXBlXG4gICAgfSwgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgdmFyIHZpZXcgPSBzZWxmLl9jb21wb25lbnRzTWFwW2NvbXBvbmVudC5fX3ZpZXdJZF07XG5cbiAgICAgIGlmICghdmlldy5ncm91cC5pZ25vcmUpIHtcbiAgICAgICAgZXhjbHVkZXNDb21wb25lbnRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICB2aWV3Lmdyb3VwLmlnbm9yZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgdXJsID0gdGhpcy5fenIucGFpbnRlci5nZXRUeXBlKCkgPT09ICdzdmcnID8gdGhpcy5nZXRTdmdEYXRhVXJsKCkgOiB0aGlzLmdldFJlbmRlcmVkQ2FudmFzKG9wdHMpLnRvRGF0YVVSTCgnaW1hZ2UvJyArIChvcHRzICYmIG9wdHMudHlwZSB8fCAncG5nJykpO1xuICBlYWNoKGV4Y2x1ZGVzQ29tcG9uZW50Vmlld3MsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgdmlldy5ncm91cC5pZ25vcmUgPSBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiB1cmw7XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnR5cGU9J3BuZyddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucGl4ZWxSYXRpbz0xXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRDb25uZWN0ZWREYXRhVVJMID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdyb3VwSWQgPSB0aGlzLmdyb3VwO1xuICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICB2YXIgTUFYX05VTUJFUiA9IEluZmluaXR5O1xuXG4gIGlmIChjb25uZWN0ZWRHcm91cHNbZ3JvdXBJZF0pIHtcbiAgICB2YXIgbGVmdCA9IE1BWF9OVU1CRVI7XG4gICAgdmFyIHRvcCA9IE1BWF9OVU1CRVI7XG4gICAgdmFyIHJpZ2h0ID0gLU1BWF9OVU1CRVI7XG4gICAgdmFyIGJvdHRvbSA9IC1NQVhfTlVNQkVSO1xuICAgIHZhciBjYW52YXNMaXN0ID0gW107XG4gICAgdmFyIGRwciA9IG9wdHMgJiYgb3B0cy5waXhlbFJhdGlvIHx8IDE7XG4gICAgenJVdGlsLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbiAoY2hhcnQsIGlkKSB7XG4gICAgICBpZiAoY2hhcnQuZ3JvdXAgPT09IGdyb3VwSWQpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGNoYXJ0LmdldFJlbmRlcmVkQ2FudmFzKHpyVXRpbC5jbG9uZShvcHRzKSk7XG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBjaGFydC5nZXREb20oKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGVmdCA9IG1hdGhNaW4oYm91bmRpbmdSZWN0LmxlZnQsIGxlZnQpO1xuICAgICAgICB0b3AgPSBtYXRoTWluKGJvdW5kaW5nUmVjdC50b3AsIHRvcCk7XG4gICAgICAgIHJpZ2h0ID0gbWF0aE1heChib3VuZGluZ1JlY3QucmlnaHQsIHJpZ2h0KTtcbiAgICAgICAgYm90dG9tID0gbWF0aE1heChib3VuZGluZ1JlY3QuYm90dG9tLCBib3R0b20pO1xuICAgICAgICBjYW52YXNMaXN0LnB1c2goe1xuICAgICAgICAgIGRvbTogY2FudmFzLFxuICAgICAgICAgIGxlZnQ6IGJvdW5kaW5nUmVjdC5sZWZ0LFxuICAgICAgICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZWZ0ICo9IGRwcjtcbiAgICB0b3AgKj0gZHByO1xuICAgIHJpZ2h0ICo9IGRwcjtcbiAgICBib3R0b20gKj0gZHByO1xuICAgIHZhciB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgIHZhciB0YXJnZXRDYW52YXMgPSB6clV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgenIgPSB6cmVuZGVyLmluaXQodGFyZ2V0Q2FudmFzKTtcbiAgICBlYWNoKGNhbnZhc0xpc3QsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgaW1nID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHg6IGl0ZW0ubGVmdCAqIGRwciAtIGxlZnQsXG4gICAgICAgICAgeTogaXRlbS50b3AgKiBkcHIgLSB0b3AsXG4gICAgICAgICAgaW1hZ2U6IGl0ZW0uZG9tXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgenIuYWRkKGltZyk7XG4gICAgfSk7XG4gICAgenIucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgcmV0dXJuIHRhcmdldENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlLycgKyAob3B0cyAmJiBvcHRzLnR5cGUgfHwgJ3BuZycpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRhVVJMKG9wdHMpO1xuICB9XG59O1xuLyoqXG4gKiBDb252ZXJ0IGZyb20gbG9naWNhbCBjb29yZGluYXRlIHN5c3RlbSB0byBwaXhlbCBjb29yZGluYXRlIHN5c3RlbS5cbiAqIFNlZSBDb29yZGluYXRlU3lzdGVtI2NvbnZlcnRUb1BpeGVsLlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdnZW8nLCBtZWFucyB7Z2VvSW5kZXg6IDB9LlxuICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gKiAgICAgICAge1xuICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcbiAqICAgICAgICAgICAgZ2VvSW5kZXggLyBnZW9JZCwgZ2VvTmFtZSxcbiAqICAgICAgICAgICAgYm1hcEluZGV4IC8gYm1hcElkIC8gYm1hcE5hbWUsXG4gKiAgICAgICAgICAgIHhBeGlzSW5kZXggLyB4QXhpc0lkIC8geEF4aXNOYW1lLFxuICogICAgICAgICAgICB5QXhpc0luZGV4IC8geUF4aXNJZCAvIHlBeGlzTmFtZSxcbiAqICAgICAgICAgICAgZ3JpZEluZGV4IC8gZ3JpZElkIC8gZ3JpZE5hbWUsXG4gKiAgICAgICAgICAgIC4uLiAoY2FuIGJlIGV4dGVuZGVkKVxuICogICAgICAgIH1cbiAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7QXJyYXl8bnVtYmVyfSByZXN1bHRcbiAqL1xuXG5cbmVjaGFydHNQcm90by5jb252ZXJ0VG9QaXhlbCA9IHpyVXRpbC5jdXJyeShkb0NvbnZlcnRQaXhlbCwgJ2NvbnZlcnRUb1BpeGVsJyk7XG4vKipcbiAqIENvbnZlcnQgZnJvbSBwaXhlbCBjb29yZGluYXRlIHN5c3RlbSB0byBsb2dpY2FsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICogU2VlIENvb3JkaW5hdGVTeXN0ZW0jY29udmVydEZyb21QaXhlbC5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gKiAgICAgICAgICAgIGdlb0luZGV4IC8gZ2VvSWQgLyBnZW9OYW1lLFxuICogICAgICAgICAgICBibWFwSW5kZXggLyBibWFwSWQgLyBibWFwTmFtZSxcbiAqICAgICAgICAgICAgeEF4aXNJbmRleCAvIHhBeGlzSWQgLyB4QXhpc05hbWUsXG4gKiAgICAgICAgICAgIHlBeGlzSW5kZXggLyB5QXhpc0lkIC8geUF4aXNOYW1lXG4gKiAgICAgICAgICAgIGdyaWRJbmRleCAvIGdyaWRJZCAvIGdyaWROYW1lLFxuICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAqICAgICAgICB9XG4gKiBAcGFyYW0ge0FycmF5fG51bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fG51bWJlcn0gcmVzdWx0XG4gKi9cblxuZWNoYXJ0c1Byb3RvLmNvbnZlcnRGcm9tUGl4ZWwgPSB6clV0aWwuY3VycnkoZG9Db252ZXJ0UGl4ZWwsICdjb252ZXJ0RnJvbVBpeGVsJyk7XG5cbmZ1bmN0aW9uIGRvQ29udmVydFBpeGVsKG1ldGhvZE5hbWUsIGZpbmRlciwgdmFsdWUpIHtcbiAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICB2YXIgY29vcmRTeXNMaXN0ID0gdGhpcy5fY29vcmRTeXNNZ3IuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKTtcblxuICB2YXIgcmVzdWx0O1xuICBmaW5kZXIgPSBtb2RlbFV0aWwucGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkU3lzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb29yZFN5cyA9IGNvb3JkU3lzTGlzdFtpXTtcblxuICAgIGlmIChjb29yZFN5c1ttZXRob2ROYW1lXSAmJiAocmVzdWx0ID0gY29vcmRTeXNbbWV0aG9kTmFtZV0oZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkpICE9IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIElzIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZSBzeXN0ZW1zIG9yIGNvbXBvbmVudHMgY29udGFpbiB0aGUgZ2l2ZW4gcGl4ZWwgcG9pbnQuXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICogICAgICAgICAgICBnZW9JbmRleCAvIGdlb0lkIC8gZ2VvTmFtZSxcbiAqICAgICAgICAgICAgYm1hcEluZGV4IC8gYm1hcElkIC8gYm1hcE5hbWUsXG4gKiAgICAgICAgICAgIHhBeGlzSW5kZXggLyB4QXhpc0lkIC8geEF4aXNOYW1lLFxuICogICAgICAgICAgICB5QXhpc0luZGV4IC8geUF4aXNJZCAvIHlBeGlzTmFtZSxcbiAqICAgICAgICAgICAgZ3JpZEluZGV4IC8gZ3JpZElkIC8gZ3JpZE5hbWUsXG4gKiAgICAgICAgICAgIC4uLiAoY2FuIGJlIGV4dGVuZGVkKVxuICogICAgICAgIH1cbiAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gcmVzdWx0XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uY29udGFpblBpeGVsID0gZnVuY3Rpb24gKGZpbmRlciwgdmFsdWUpIHtcbiAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgdmFyIHJlc3VsdDtcbiAgZmluZGVyID0gbW9kZWxVdGlsLnBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlcik7XG4gIHpyVXRpbC5lYWNoKGZpbmRlciwgZnVuY3Rpb24gKG1vZGVscywga2V5KSB7XG4gICAga2V5LmluZGV4T2YoJ01vZGVscycpID49IDAgJiYgenJVdGlsLmVhY2gobW9kZWxzLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgIHZhciBjb29yZFN5cyA9IG1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy5jb250YWluUG9pbnQpIHtcbiAgICAgICAgcmVzdWx0IHw9ICEhY29vcmRTeXMuY29udGFpblBvaW50KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VyaWVzTW9kZWxzJykge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2NoYXJ0c01hcFttb2RlbC5fX3ZpZXdJZF07XG5cbiAgICAgICAgaWYgKHZpZXcgJiYgdmlldy5jb250YWluUG9pbnQpIHtcbiAgICAgICAgICByZXN1bHQgfD0gdmlldy5jb250YWluUG9pbnQodmFsdWUsIG1vZGVsKTtcbiAgICAgICAgfSBlbHNlIHt9XG4gICAgICB9IGVsc2Uge31cbiAgICB9LCB0aGlzKTtcbiAgfSwgdGhpcyk7XG4gIHJldHVybiAhIXJlc3VsdDtcbn07XG4vKipcbiAqIEdldCB2aXN1YWwgZnJvbSBzZXJpZXMgb3IgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnc2VyaWVzJywgbWVhbnMge3Nlcmllc0luZGV4OiAwfS5cbiAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gKiAgICAgICAgICAgIGRhdGFJbmRleCAvIGRhdGFJbmRleEluc2lkZVxuICogICAgICAgIH1cbiAqICAgICAgICBJZiBkYXRhSW5kZXggaXMgbm90IHNwZWNpZmllZCwgc2VyaWVzIHZpc3VhbCB3aWxsIGJlIGZldGNoZWQsXG4gKiAgICAgICAgYnV0IG5vdCBkYXRhIGl0ZW0gdmlzdWFsLlxuICogICAgICAgIElmIGFsbCBvZiBzZXJpZXNJbmRleCwgc2VyaWVzSWQsIHNlcmllc05hbWUgYXJlIG5vdCBzcGVjaWZpZWQsXG4gKiAgICAgICAgdmlzdWFsIHdpbGwgYmUgZmV0Y2hlZCBmcm9tIGZpcnN0IHNlcmllcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aXN1YWxUeXBlICdjb2xvcicsICdzeW1ib2wnLCAnc3ltYm9sU2l6ZSdcbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRWaXN1YWwgPSBmdW5jdGlvbiAoZmluZGVyLCB2aXN1YWxUeXBlKSB7XG4gIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gIGZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIsIHtcbiAgICBkZWZhdWx0TWFpblR5cGU6ICdzZXJpZXMnXG4gIH0pO1xuICB2YXIgc2VyaWVzTW9kZWwgPSBmaW5kZXIuc2VyaWVzTW9kZWw7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB2YXIgZGF0YUluZGV4SW5zaWRlID0gZmluZGVyLmhhc093blByb3BlcnR5KCdkYXRhSW5kZXhJbnNpZGUnKSA/IGZpbmRlci5kYXRhSW5kZXhJbnNpZGUgOiBmaW5kZXIuaGFzT3duUHJvcGVydHkoJ2RhdGFJbmRleCcpID8gZGF0YS5pbmRleE9mUmF3SW5kZXgoZmluZGVyLmRhdGFJbmRleCkgOiBudWxsO1xuICByZXR1cm4gZGF0YUluZGV4SW5zaWRlICE9IG51bGwgPyBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4SW5zaWRlLCB2aXN1YWxUeXBlKSA6IGRhdGEuZ2V0VmlzdWFsKHZpc3VhbFR5cGUpO1xufTtcbi8qKlxuICogR2V0IHZpZXcgb2YgY29ycmVzcG9uZGluZyBjb21wb25lbnQgbW9kZWxcbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29tcG9uZW50TW9kZWxcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldFZpZXdPZkNvbXBvbmVudE1vZGVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE1vZGVsKSB7XG4gIHJldHVybiB0aGlzLl9jb21wb25lbnRzTWFwW2NvbXBvbmVudE1vZGVsLl9fdmlld0lkXTtcbn07XG4vKipcbiAqIEdldCB2aWV3IG9mIGNvcnJlc3BvbmRpbmcgc2VyaWVzIG1vZGVsXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0fVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldFZpZXdPZlNlcmllc01vZGVsID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gIHJldHVybiB0aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xufTtcblxudmFyIHVwZGF0ZU1ldGhvZHMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIC8vIGNvbnNvbGUucHJvZmlsZSAmJiBjb25zb2xlLnByb2ZpbGUoJ3VwZGF0ZScpO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICB2YXIgY29vcmRTeXNNZ3IgPSB0aGlzLl9jb29yZFN5c01ncjtcbiAgICB2YXIgenIgPSB0aGlzLl96cjsgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cblxuICAgIGlmICghZWNNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRml4bWUgRmlyc3QgdGltZSB1cGRhdGUgP1xuXG5cbiAgICBlY01vZGVsLnJlc3RvcmVEYXRhKCk7IC8vIFRPRE9cbiAgICAvLyBTYXZlIHRvdGFsIGVjTW9kZWwgaGVyZSBmb3IgdW5kby9yZWRvIChhZnRlciByZXN0b3JpbmcgZGF0YSBhbmQgYmVmb3JlIHByb2Nlc3NpbmcgZGF0YSkuXG4gICAgLy8gVW5kbyAocmVzdG9yYXRpb24gb2YgdG90YWwgZWNNb2RlbCkgY2FuIGJlIGNhcnJpZWQgb3V0IGluICdhY3Rpb24nIG9yIG91dHNpZGUgQVBJIGNhbGwuXG4gICAgLy8gQ3JlYXRlIG5ldyBjb29yZGluYXRlIHN5c3RlbSBlYWNoIHVwZGF0ZVxuICAgIC8vIEluIExpbmVWaWV3IG1heSBzYXZlIHRoZSBvbGQgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIHVzZSBpdCB0byBnZXQgdGhlIG9yaWduYWwgcG9pbnRcblxuICAgIGNvb3JkU3lzTWdyLmNyZWF0ZSh0aGlzLl9tb2RlbCwgdGhpcy5fYXBpKTtcbiAgICBwcm9jZXNzRGF0YS5jYWxsKHRoaXMsIGVjTW9kZWwsIGFwaSk7XG4gICAgc3RhY2tTZXJpZXNEYXRhLmNhbGwodGhpcywgZWNNb2RlbCk7XG4gICAgY29vcmRTeXNNZ3IudXBkYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgZG9WaXN1YWxFbmNvZGluZy5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQpO1xuICAgIGRvUmVuZGVyLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7IC8vIFNldCBiYWNrZ3JvdW5kXG5cbiAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gZWNNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgdmFyIHBhaW50ZXIgPSB6ci5wYWludGVyOyAvLyBUT0RPIGFsbCB1c2UgY2xlYXJDb2xvciA/XG5cbiAgICBpZiAocGFpbnRlci5pc1NpbmdsZUNhbnZhcyAmJiBwYWludGVyLmlzU2luZ2xlQ2FudmFzKCkpIHtcbiAgICAgIHpyLmNvbmZpZ0xheWVyKDAsIHtcbiAgICAgICAgY2xlYXJDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gSUU4XG4gICAgICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIGJhY2tncm91bmRDb2xvciA9IGNvbG9yVG9vbC5zdHJpbmdpZnkoY29sb3JBcnIsICdyZ2InKTtcblxuICAgICAgICBpZiAoY29sb3JBcnJbM10gPT09IDApIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IuY29sb3JTdG9wcyB8fCBiYWNrZ3JvdW5kQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgLy8gR3JhZGllbnQgYmFja2dyb3VuZFxuICAgICAgICAvLyBGSVhNRSBGaXhlZCBsYXllcu+8n1xuICAgICAgICB6ci5jb25maWdMYXllcigwLCB7XG4gICAgICAgICAgY2xlYXJDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzW0hBU19HUkFESUVOVF9PUl9QQVRURVJOX0JHXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzW0hBU19HUkFESUVOVF9PUl9QQVRURVJOX0JHXSkge1xuICAgICAgICAgIHpyLmNvbmZpZ0xheWVyKDAsIHtcbiAgICAgICAgICAgIGNsZWFyQ29sb3I6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkddID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVhY2gocG9zdFVwZGF0ZUZ1bmNzLCBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgZnVuYyhlY01vZGVsLCBhcGkpO1xuICAgIH0pOyAvLyBjb25zb2xlLnByb2ZpbGUgJiYgY29uc29sZS5wcm9maWxlRW5kKCd1cGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVZpZXc6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDsgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cblxuICAgIGlmICghZWNNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHNlcmllc01vZGVsLmdldERhdGEoKS5jbGVhckFsbFZpc3VhbCgpO1xuICAgIH0pO1xuICAgIGRvVmlzdWFsRW5jb2RpbmcuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgICBpbnZva2VVcGRhdGVNZXRob2QuY2FsbCh0aGlzLCAndXBkYXRlVmlldycsIGVjTW9kZWwsIHBheWxvYWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlVmlzdWFsOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7IC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG5cbiAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY2xlYXJBbGxWaXN1YWwoKTtcbiAgICB9KTtcbiAgICBkb1Zpc3VhbEVuY29kaW5nLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCwgdHJ1ZSk7XG4gICAgaW52b2tlVXBkYXRlTWV0aG9kLmNhbGwodGhpcywgJ3VwZGF0ZVZpc3VhbCcsIGVjTW9kZWwsIHBheWxvYWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7IC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG5cbiAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkb0xheW91dC5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQpO1xuICAgIGludm9rZVVwZGF0ZU1ldGhvZC5jYWxsKHRoaXMsICd1cGRhdGVMYXlvdXQnLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByZXBhcmVBbmRVcGRhdGU6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICBwcmVwYXJlVmlldy5jYWxsKHRoaXMsICdjb21wb25lbnQnLCBlY01vZGVsKTtcbiAgICBwcmVwYXJlVmlldy5jYWxsKHRoaXMsICdjaGFydCcsIGVjTW9kZWwpO1xuICAgIHVwZGF0ZU1ldGhvZHMudXBkYXRlLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0bHkoZWNJbnMsIG1ldGhvZCwgcGF5bG9hZCwgbWFpblR5cGUsIHN1YlR5cGUpIHtcbiAgdmFyIGVjTW9kZWwgPSBlY0lucy5fbW9kZWw7IC8vIGJyb2FkY2FzdFxuXG4gIGlmICghbWFpblR5cGUpIHtcbiAgICBlYWNoKGVjSW5zLl9jb21wb25lbnRzVmlld3MuY29uY2F0KGVjSW5zLl9jaGFydHNWaWV3cyksIGNhbGxWaWV3KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcXVlcnkgPSB7fTtcbiAgcXVlcnlbbWFpblR5cGUgKyAnSWQnXSA9IHBheWxvYWRbbWFpblR5cGUgKyAnSWQnXTtcbiAgcXVlcnlbbWFpblR5cGUgKyAnSW5kZXgnXSA9IHBheWxvYWRbbWFpblR5cGUgKyAnSW5kZXgnXTtcbiAgcXVlcnlbbWFpblR5cGUgKyAnTmFtZSddID0gcGF5bG9hZFttYWluVHlwZSArICdOYW1lJ107XG4gIHZhciBjb25kaXRpb24gPSB7XG4gICAgbWFpblR5cGU6IG1haW5UeXBlLFxuICAgIHF1ZXJ5OiBxdWVyeVxuICB9O1xuICBzdWJUeXBlICYmIChjb25kaXRpb24uc3ViVHlwZSA9IHN1YlR5cGUpOyAvLyBzdWJUeXBlIG1heSBiZSAnJyBieSBwYXJzZUNsYXNzVHlwZTtcbiAgLy8gSWYgZGlzcGF0Y2hBY3Rpb24gYmVmb3JlIHNldE9wdGlvbiwgZG8gbm90aGluZy5cblxuICBlY01vZGVsICYmIGVjTW9kZWwuZWFjaENvbXBvbmVudChjb25kaXRpb24sIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHtcbiAgICBjYWxsVmlldyhlY0luc1ttYWluVHlwZSA9PT0gJ3NlcmllcycgPyAnX2NoYXJ0c01hcCcgOiAnX2NvbXBvbmVudHNNYXAnXVttb2RlbC5fX3ZpZXdJZF0pO1xuICB9LCBlY0lucyk7XG5cbiAgZnVuY3Rpb24gY2FsbFZpZXcodmlldykge1xuICAgIHZpZXcgJiYgdmlldy5fX2FsaXZlICYmIHZpZXdbbWV0aG9kXSAmJiB2aWV3W21ldGhvZF0odmlldy5fX21vZGVsLCBlY01vZGVsLCBlY0lucy5fYXBpLCBwYXlsb2FkKTtcbiAgfVxufVxuLyoqXG4gKiBSZXNpemUgdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zaWxlbnQ9ZmFsc2VdXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8ucmVzaXplID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gdHJ1ZTtcblxuICB0aGlzLl96ci5yZXNpemUob3B0cyk7XG5cbiAgdmFyIG9wdGlvbkNoYW5nZWQgPSB0aGlzLl9tb2RlbCAmJiB0aGlzLl9tb2RlbC5yZXNldE9wdGlvbignbWVkaWEnKTtcblxuICB2YXIgdXBkYXRlTWV0aG9kID0gb3B0aW9uQ2hhbmdlZCA/ICdwcmVwYXJlQW5kVXBkYXRlJyA6ICd1cGRhdGUnO1xuICB1cGRhdGVNZXRob2RzW3VwZGF0ZU1ldGhvZF0uY2FsbCh0aGlzKTsgLy8gUmVzaXplIGxvYWRpbmcgZWZmZWN0XG5cbiAgdGhpcy5fbG9hZGluZ0ZYICYmIHRoaXMuX2xvYWRpbmdGWC5yZXNpemUoKTtcbiAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG4gIHZhciBzaWxlbnQgPSBvcHRzICYmIG9wdHMuc2lsZW50O1xuICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgc2lsZW50KTtcbiAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG59O1xuLyoqXG4gKiBTaG93IGxvYWRpbmcgZWZmZWN0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtuYW1lPSdkZWZhdWx0J11cbiAqIEBwYXJhbSAge09iamVjdH0gW2NmZ11cbiAqL1xuXG5cbmVjaGFydHNQcm90by5zaG93TG9hZGluZyA9IGZ1bmN0aW9uIChuYW1lLCBjZmcpIHtcbiAgaWYgKHpyVXRpbC5pc09iamVjdChuYW1lKSkge1xuICAgIGNmZyA9IG5hbWU7XG4gICAgbmFtZSA9ICcnO1xuICB9XG5cbiAgbmFtZSA9IG5hbWUgfHwgJ2RlZmF1bHQnO1xuICB0aGlzLmhpZGVMb2FkaW5nKCk7XG5cbiAgaWYgKCFsb2FkaW5nRWZmZWN0c1tuYW1lXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbCA9IGxvYWRpbmdFZmZlY3RzW25hbWVdKHRoaXMuX2FwaSwgY2ZnKTtcbiAgdmFyIHpyID0gdGhpcy5fenI7XG4gIHRoaXMuX2xvYWRpbmdGWCA9IGVsO1xuICB6ci5hZGQoZWwpO1xufTtcbi8qKlxuICogSGlkZSBsb2FkaW5nIGVmZmVjdFxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmhpZGVMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9sb2FkaW5nRlggJiYgdGhpcy5fenIucmVtb3ZlKHRoaXMuX2xvYWRpbmdGWCk7XG4gIHRoaXMuX2xvYWRpbmdGWCA9IG51bGw7XG59O1xuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRPYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5tYWtlQWN0aW9uRnJvbUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50T2JqKSB7XG4gIHZhciBwYXlsb2FkID0genJVdGlsLmV4dGVuZCh7fSwgZXZlbnRPYmopO1xuICBwYXlsb2FkLnR5cGUgPSBldmVudEFjdGlvbk1hcFtldmVudE9iai50eXBlXTtcbiAgcmV0dXJuIHBheWxvYWQ7XG59O1xuLyoqXG4gKiBAcHViaWxjXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXlsb2FkLnR5cGVdIEFjdGlvbiB0eXBlXG4gKiBAcGFyYW0ge09iamVjdHxib29sZWFufSBbb3B0XSBJZiBwYXNzIGJvb2xlYW4sIG1lYW5zIG9wdC5zaWxlbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5zaWxlbnQ9ZmFsc2VdIFdoZXRoZXIgdHJpZ2dlciBldmVudHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuZmx1c2g9dW5kZWZpbmVkXVxuICogICAgICAgICAgICAgICAgICB0cnVlOiBGbHVzaCBpbW1lZGlhdGVseSwgYW5kIHRoZW4gcGl4ZWwgaW4gY2FudmFzIGNhbiBiZSBmZXRjaGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGVseS4gQ2F1dGlvbjogaXQgbWlnaHQgYWZmZWN0IHBlcmZvcm1hbmNlLlxuICogICAgICAgICAgICAgICAgICBmYWxzZTogTm90IG5vdCBmbHVzaC5cbiAqICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkOiBBdXRvIGRlY2lkZSB3aGV0aGVyIHBlcmZvcm0gZmx1c2guXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZGlzcGF0Y2hBY3Rpb24gPSBmdW5jdGlvbiAocGF5bG9hZCwgb3B0KSB7XG4gIGlmICghenJVdGlsLmlzT2JqZWN0KG9wdCkpIHtcbiAgICBvcHQgPSB7XG4gICAgICBzaWxlbnQ6ICEhb3B0XG4gICAgfTtcbiAgfVxuXG4gIGlmICghYWN0aW9uc1twYXlsb2FkLnR5cGVdKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIEF2b2lkIGRpc3BhdGNoIGFjdGlvbiBiZWZvcmUgc2V0T3B0aW9uLiBFc3BlY2lhbGx5IGluIGBjb25uZWN0YC5cblxuXG4gIGlmICghdGhpcy5fbW9kZWwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gTWF5IGRpc3BhdGNoQWN0aW9uIGluIHJlbmRlcmluZyBwcm9jZWR1cmVcblxuXG4gIGlmICh0aGlzW0lOX01BSU5fUFJPQ0VTU10pIHtcbiAgICB0aGlzLl9wZW5kaW5nQWN0aW9ucy5wdXNoKHBheWxvYWQpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZG9EaXNwYXRjaEFjdGlvbi5jYWxsKHRoaXMsIHBheWxvYWQsIG9wdC5zaWxlbnQpO1xuXG4gIGlmIChvcHQuZmx1c2gpIHtcbiAgICB0aGlzLl96ci5mbHVzaCh0cnVlKTtcbiAgfSBlbHNlIGlmIChvcHQuZmx1c2ggIT09IGZhbHNlICYmIGVudi5icm93c2VyLndlQ2hhdCkge1xuICAgIC8vIEluIFdlQ2hhdCBlbWJlZGVkIGJyb3dzZXIsIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFuZCBgc2V0SW50ZXJ2YWxgXG4gICAgLy8gaGFuZyB3aGVuIHNsaWRpbmcgcGFnZSAob24gdG91Y2ggZXZlbnQpLCB3aGljaCBjYXVzZSB0aGF0IHpyIGRvZXMgbm90XG4gICAgLy8gcmVmcmVzaCB1dGlsIHVzZXIgaW50ZXJhY3Rpb24gZmluaXNoZWQsIHdoaWNoIGlzIG5vdCBleHBlY3RlZC5cbiAgICAvLyBCdXQgYGRpc3BhdGNoQWN0aW9uYCBtYXkgYmUgY2FsbGVkIHRvbyBmcmVxdWVudGx5IHdoZW4gcGFuIG9uIHRvdWNoXG4gICAgLy8gc2NyZWVuLCB3aGljaCBpbXBhY3RzIHBlcmZvcm1hbmNlIGlmIGRvIG5vdCB0aHJvdHRsZSB0aGVtLlxuICAgIHRoaXMuX3Rocm90dGxlZFpyRmx1c2goKTtcbiAgfVxuXG4gIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBvcHQuc2lsZW50KTtcbiAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIG9wdC5zaWxlbnQpO1xufTtcblxuZnVuY3Rpb24gZG9EaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBzaWxlbnQpIHtcbiAgdmFyIHBheWxvYWRUeXBlID0gcGF5bG9hZC50eXBlO1xuICB2YXIgZXNjYXBlQ29ubmVjdCA9IHBheWxvYWQuZXNjYXBlQ29ubmVjdDtcbiAgdmFyIGFjdGlvbldyYXAgPSBhY3Rpb25zW3BheWxvYWRUeXBlXTtcbiAgdmFyIGFjdGlvbkluZm8gPSBhY3Rpb25XcmFwLmFjdGlvbkluZm87XG4gIHZhciBjcHRUeXBlID0gKGFjdGlvbkluZm8udXBkYXRlIHx8ICd1cGRhdGUnKS5zcGxpdCgnOicpO1xuICB2YXIgdXBkYXRlTWV0aG9kID0gY3B0VHlwZS5wb3AoKTtcbiAgY3B0VHlwZSA9IGNwdFR5cGVbMF0gIT0gbnVsbCAmJiBwYXJzZUNsYXNzVHlwZShjcHRUeXBlWzBdKTtcbiAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gdHJ1ZTtcbiAgdmFyIHBheWxvYWRzID0gW3BheWxvYWRdO1xuICB2YXIgYmF0Y2hlZCA9IGZhbHNlOyAvLyBCYXRjaCBhY3Rpb25cblxuICBpZiAocGF5bG9hZC5iYXRjaCkge1xuICAgIGJhdGNoZWQgPSB0cnVlO1xuICAgIHBheWxvYWRzID0genJVdGlsLm1hcChwYXlsb2FkLmJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaXRlbSA9IHpyVXRpbC5kZWZhdWx0cyh6clV0aWwuZXh0ZW5kKHt9LCBpdGVtKSwgcGF5bG9hZCk7XG4gICAgICBpdGVtLmJhdGNoID0gbnVsbDtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGV2ZW50T2JqQmF0Y2ggPSBbXTtcbiAgdmFyIGV2ZW50T2JqO1xuICB2YXIgaXNIaWdoRG93biA9IHBheWxvYWRUeXBlID09PSAnaGlnaGxpZ2h0JyB8fCBwYXlsb2FkVHlwZSA9PT0gJ2Rvd25wbGF5JztcbiAgZWFjaChwYXlsb2FkcywgZnVuY3Rpb24gKGJhdGNoSXRlbSkge1xuICAgIC8vIEFjdGlvbiBjYW4gc3BlY2lmeSB0aGUgZXZlbnQgYnkgcmV0dXJuIGl0LlxuICAgIGV2ZW50T2JqID0gYWN0aW9uV3JhcC5hY3Rpb24oYmF0Y2hJdGVtLCB0aGlzLl9tb2RlbCwgdGhpcy5fYXBpKTsgLy8gRW1pdCBldmVudCBvdXRzaWRlXG5cbiAgICBldmVudE9iaiA9IGV2ZW50T2JqIHx8IHpyVXRpbC5leHRlbmQoe30sIGJhdGNoSXRlbSk7IC8vIENvbnZlcnQgdHlwZSB0byBldmVudFR5cGVcblxuICAgIGV2ZW50T2JqLnR5cGUgPSBhY3Rpb25JbmZvLmV2ZW50IHx8IGV2ZW50T2JqLnR5cGU7XG4gICAgZXZlbnRPYmpCYXRjaC5wdXNoKGV2ZW50T2JqKTsgLy8gbGlnaHQgdXBkYXRlIGRvZXMgbm90IHBlcmZvcm0gZGF0YSBwcm9jZXNzLCBsYXlvdXQgYW5kIHZpc3VhbC5cblxuICAgIGlmIChpc0hpZ2hEb3duKSB7XG4gICAgICAvLyBtZXRob2QsIHBheWxvYWQsIG1haW5UeXBlLCBzdWJUeXBlXG4gICAgICB1cGRhdGVEaXJlY3RseSh0aGlzLCB1cGRhdGVNZXRob2QsIGJhdGNoSXRlbSwgJ3NlcmllcycpO1xuICAgIH0gZWxzZSBpZiAoY3B0VHlwZSkge1xuICAgICAgdXBkYXRlRGlyZWN0bHkodGhpcywgdXBkYXRlTWV0aG9kLCBiYXRjaEl0ZW0sIGNwdFR5cGUubWFpbiwgY3B0VHlwZS5zdWIpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgaWYgKHVwZGF0ZU1ldGhvZCAhPT0gJ25vbmUnICYmICFpc0hpZ2hEb3duICYmICFjcHRUeXBlKSB7XG4gICAgLy8gU3RpbGwgZGlydHlcbiAgICBpZiAodGhpc1tPUFRJT05fVVBEQVRFRF0pIHtcbiAgICAgIC8vIEZJWE1FIFBhc3MgcGF5bG9hZCA/XG4gICAgICB1cGRhdGVNZXRob2RzLnByZXBhcmVBbmRVcGRhdGUuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZU1ldGhvZHNbdXBkYXRlTWV0aG9kXS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgIH1cbiAgfSAvLyBGb2xsb3cgdGhlIHJ1bGUgb2YgYWN0aW9uIGJhdGNoXG5cblxuICBpZiAoYmF0Y2hlZCkge1xuICAgIGV2ZW50T2JqID0ge1xuICAgICAgdHlwZTogYWN0aW9uSW5mby5ldmVudCB8fCBwYXlsb2FkVHlwZSxcbiAgICAgIGVzY2FwZUNvbm5lY3Q6IGVzY2FwZUNvbm5lY3QsXG4gICAgICBiYXRjaDogZXZlbnRPYmpCYXRjaFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRPYmogPSBldmVudE9iakJhdGNoWzBdO1xuICB9XG5cbiAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG4gICFzaWxlbnQgJiYgdGhpcy5fbWVzc2FnZUNlbnRlci50cmlnZ2VyKGV2ZW50T2JqLnR5cGUsIGV2ZW50T2JqKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hQZW5kaW5nQWN0aW9ucyhzaWxlbnQpIHtcbiAgdmFyIHBlbmRpbmdBY3Rpb25zID0gdGhpcy5fcGVuZGluZ0FjdGlvbnM7XG5cbiAgd2hpbGUgKHBlbmRpbmdBY3Rpb25zLmxlbmd0aCkge1xuICAgIHZhciBwYXlsb2FkID0gcGVuZGluZ0FjdGlvbnMuc2hpZnQoKTtcbiAgICBkb0Rpc3BhdGNoQWN0aW9uLmNhbGwodGhpcywgcGF5bG9hZCwgc2lsZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmlnZ2VyVXBkYXRlZEV2ZW50KHNpbGVudCkge1xuICAhc2lsZW50ICYmIHRoaXMudHJpZ2dlcigndXBkYXRlZCcpO1xufVxuLyoqXG4gKiBSZWdpc3RlciBldmVudFxuICogQG1ldGhvZFxuICovXG5cblxuZWNoYXJ0c1Byb3RvLm9uID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbicpO1xuZWNoYXJ0c1Byb3RvLm9mZiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb2ZmJyk7XG5lY2hhcnRzUHJvdG8ub25lID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbmUnKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWVcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlVXBkYXRlTWV0aG9kKG1ldGhvZE5hbWUsIGVjTW9kZWwsIHBheWxvYWQpIHtcbiAgdmFyIGFwaSA9IHRoaXMuX2FwaTsgLy8gVXBkYXRlIGFsbCBjb21wb25lbnRzXG5cbiAgZWFjaCh0aGlzLl9jb21wb25lbnRzVmlld3MsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICB2YXIgY29tcG9uZW50TW9kZWwgPSBjb21wb25lbnQuX19tb2RlbDtcbiAgICBjb21wb25lbnRbbWV0aG9kTmFtZV0oY29tcG9uZW50TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgdXBkYXRlWihjb21wb25lbnRNb2RlbCwgY29tcG9uZW50KTtcbiAgfSwgdGhpcyk7IC8vIFVwYXRlIGFsbCBjaGFydHNcblxuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsLCBpZHgpIHtcbiAgICB2YXIgY2hhcnQgPSB0aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgIGNoYXJ0W21ldGhvZE5hbWVdKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIHVwZGF0ZVooc2VyaWVzTW9kZWwsIGNoYXJ0KTtcbiAgICB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydCk7XG4gIH0sIHRoaXMpOyAvLyBJZiB1c2UgaG92ZXIgbGF5ZXJcblxuICB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHRoaXMuX3pyLCBlY01vZGVsKTsgLy8gUG9zdCByZW5kZXJcblxuICBlYWNoKHBvc3RVcGRhdGVGdW5jcywgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBmdW5jKGVjTW9kZWwsIGFwaSk7XG4gIH0pO1xufVxuLyoqXG4gKiBQcmVwYXJlIHZpZXcgaW5zdGFuY2VzIG9mIGNoYXJ0cyBhbmQgY29tcG9uZW50c1xuICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gcHJlcGFyZVZpZXcodHlwZSwgZWNNb2RlbCkge1xuICB2YXIgaXNDb21wb25lbnQgPSB0eXBlID09PSAnY29tcG9uZW50JztcbiAgdmFyIHZpZXdMaXN0ID0gaXNDb21wb25lbnQgPyB0aGlzLl9jb21wb25lbnRzVmlld3MgOiB0aGlzLl9jaGFydHNWaWV3cztcbiAgdmFyIHZpZXdNYXAgPSBpc0NvbXBvbmVudCA/IHRoaXMuX2NvbXBvbmVudHNNYXAgOiB0aGlzLl9jaGFydHNNYXA7XG4gIHZhciB6ciA9IHRoaXMuX3pyO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2aWV3TGlzdFtpXS5fX2FsaXZlID0gZmFsc2U7XG4gIH1cblxuICBlY01vZGVsW2lzQ29tcG9uZW50ID8gJ2VhY2hDb21wb25lbnQnIDogJ2VhY2hTZXJpZXMnXShmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgbW9kZWwpIHtcbiAgICBpZiAoaXNDb21wb25lbnQpIHtcbiAgICAgIGlmIChjb21wb25lbnRUeXBlID09PSAnc2VyaWVzJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsID0gY29tcG9uZW50VHlwZTtcbiAgICB9IC8vIENvbnNpZGVyOiBpZCBzYW1lIGFuZCB0eXBlIGNoYW5nZWQuXG5cblxuICAgIHZhciB2aWV3SWQgPSAnX2VjXycgKyBtb2RlbC5pZCArICdfJyArIG1vZGVsLnR5cGU7XG4gICAgdmFyIHZpZXcgPSB2aWV3TWFwW3ZpZXdJZF07XG5cbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShtb2RlbC50eXBlKTtcbiAgICAgIHZhciBDbGF6eiA9IGlzQ29tcG9uZW50ID8gQ29tcG9uZW50Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YikgOiBDaGFydFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLnN1Yik7XG5cbiAgICAgIGlmIChDbGF6eikge1xuICAgICAgICB2aWV3ID0gbmV3IENsYXp6KCk7XG4gICAgICAgIHZpZXcuaW5pdChlY01vZGVsLCB0aGlzLl9hcGkpO1xuICAgICAgICB2aWV3TWFwW3ZpZXdJZF0gPSB2aWV3O1xuICAgICAgICB2aWV3TGlzdC5wdXNoKHZpZXcpO1xuICAgICAgICB6ci5hZGQodmlldy5ncm91cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFcnJvclxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kZWwuX192aWV3SWQgPSB2aWV3Ll9faWQgPSB2aWV3SWQ7XG4gICAgdmlldy5fX2FsaXZlID0gdHJ1ZTtcbiAgICB2aWV3Ll9fbW9kZWwgPSBtb2RlbDtcbiAgICB2aWV3Lmdyb3VwLl9fZWNDb21wb25lbnRJbmZvID0ge1xuICAgICAgbWFpblR5cGU6IG1vZGVsLm1haW5UeXBlLFxuICAgICAgaW5kZXg6IG1vZGVsLmNvbXBvbmVudEluZGV4XG4gICAgfTtcbiAgfSwgdGhpcyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3TGlzdC5sZW5ndGg7KSB7XG4gICAgdmFyIHZpZXcgPSB2aWV3TGlzdFtpXTtcblxuICAgIGlmICghdmlldy5fX2FsaXZlKSB7XG4gICAgICB6ci5yZW1vdmUodmlldy5ncm91cCk7XG4gICAgICB2aWV3LmRpc3Bvc2UoZWNNb2RlbCwgdGhpcy5fYXBpKTtcbiAgICAgIHZpZXdMaXN0LnNwbGljZShpLCAxKTtcbiAgICAgIGRlbGV0ZSB2aWV3TWFwW3ZpZXcuX19pZF07XG4gICAgICB2aWV3Ll9faWQgPSB2aWV3Lmdyb3VwLl9fZWNDb21wb25lbnRJbmZvID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBQcm9jZXNzb3IgZGF0YSBpbiBlYWNoIHNlcmllc1xuICpcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gcHJvY2Vzc0RhdGEoZWNNb2RlbCwgYXBpKSB7XG4gIGVhY2goZGF0YVByb2Nlc3NvckZ1bmNzLCBmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgIHByb2Nlc3MuZnVuYyhlY01vZGVsLCBhcGkpO1xuICB9KTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0YWNrU2VyaWVzRGF0YShlY01vZGVsKSB7XG4gIHZhciBzdGFja2VkRGF0YU1hcCA9IHt9O1xuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllcykge1xuICAgIHZhciBzdGFjayA9IHNlcmllcy5nZXQoJ3N0YWNrJyk7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXMuZ2V0RGF0YSgpO1xuXG4gICAgaWYgKHN0YWNrICYmIGRhdGEudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICB2YXIgcHJldmlvdXNTdGFjayA9IHN0YWNrZWREYXRhTWFwW3N0YWNrXTsgLy8gQXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlXG5cbiAgICAgIGlmIChzdGFja2VkRGF0YU1hcC5oYXNPd25Qcm9wZXJ0eShzdGFjaykgJiYgcHJldmlvdXNTdGFjaykge1xuICAgICAgICBkYXRhLnN0YWNrZWRPbiA9IHByZXZpb3VzU3RhY2s7XG4gICAgICB9XG5cbiAgICAgIHN0YWNrZWREYXRhTWFwW3N0YWNrXSA9IGRhdGE7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogTGF5b3V0IGJlZm9yZSBlYWNoIGNoYXJ0IHJlbmRlciB0aGVyZSBzZXJpZXMsIHNwZWNpYWwgdmlzdWFsIGVuY29kaW5nIHN0YWdlXG4gKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBkb0xheW91dChlY01vZGVsLCBwYXlsb2FkKSB7XG4gIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gIGVhY2godmlzdWFsRnVuY3MsIGZ1bmN0aW9uICh2aXN1YWwpIHtcbiAgICBpZiAodmlzdWFsLmlzTGF5b3V0KSB7XG4gICAgICB2aXN1YWwuZnVuYyhlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEVuY29kZSB2aXN1YWwgaW5mb21hdGlvbiBmcm9tIGRhdGEgYWZ0ZXIgZGF0YSBwcm9jZXNzaW5nXG4gKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7b2JqZWN0fSBsYXlvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGVzTGF5b3V0XVxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGRvVmlzdWFsRW5jb2RpbmcoZWNNb2RlbCwgcGF5bG9hZCwgZXhjbHVkZXNMYXlvdXQpIHtcbiAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgZWNNb2RlbC5jbGVhckNvbG9yUGFsZXR0ZSgpO1xuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgc2VyaWVzTW9kZWwuY2xlYXJDb2xvclBhbGV0dGUoKTtcbiAgfSk7XG4gIGVhY2godmlzdWFsRnVuY3MsIGZ1bmN0aW9uICh2aXN1YWwpIHtcbiAgICAoIWV4Y2x1ZGVzTGF5b3V0IHx8ICF2aXN1YWwuaXNMYXlvdXQpICYmIHZpc3VhbC5mdW5jKGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH0pO1xufVxuLyoqXG4gKiBSZW5kZXIgZWFjaCBjaGFydCBhbmQgY29tcG9uZW50XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZG9SZW5kZXIoZWNNb2RlbCwgcGF5bG9hZCkge1xuICB2YXIgYXBpID0gdGhpcy5fYXBpOyAvLyBSZW5kZXIgYWxsIGNvbXBvbmVudHNcblxuICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudFZpZXcpIHtcbiAgICB2YXIgY29tcG9uZW50TW9kZWwgPSBjb21wb25lbnRWaWV3Ll9fbW9kZWw7XG4gICAgY29tcG9uZW50Vmlldy5yZW5kZXIoY29tcG9uZW50TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgdXBkYXRlWihjb21wb25lbnRNb2RlbCwgY29tcG9uZW50Vmlldyk7XG4gIH0sIHRoaXMpO1xuICBlYWNoKHRoaXMuX2NoYXJ0c1ZpZXdzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICBjaGFydC5fX2FsaXZlID0gZmFsc2U7XG4gIH0sIHRoaXMpOyAvLyBSZW5kZXIgYWxsIGNoYXJ0c1xuXG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgIHZhciBjaGFydFZpZXcgPSB0aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgIGNoYXJ0Vmlldy5fX2FsaXZlID0gdHJ1ZTtcbiAgICBjaGFydFZpZXcucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIGNoYXJ0Vmlldy5ncm91cC5zaWxlbnQgPSAhIXNlcmllc01vZGVsLmdldCgnc2lsZW50Jyk7XG4gICAgdXBkYXRlWihzZXJpZXNNb2RlbCwgY2hhcnRWaWV3KTtcbiAgICB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuICB9LCB0aGlzKTsgLy8gSWYgdXNlIGhvdmVyIGxheWVyXG5cbiAgdXBkYXRlSG92ZXJMYXllclN0YXR1cyh0aGlzLl96ciwgZWNNb2RlbCk7IC8vIFJlbW92ZSBncm91cHMgb2YgdW5yZW5kZXJlZCBjaGFydHNcblxuICBlYWNoKHRoaXMuX2NoYXJ0c1ZpZXdzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICBpZiAoIWNoYXJ0Ll9fYWxpdmUpIHtcbiAgICAgIGNoYXJ0LnJlbW92ZShlY01vZGVsLCBhcGkpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG59XG5cbnZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ21vdXNlbW92ZScsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdnbG9iYWxvdXQnLCAnY29udGV4dG1lbnUnXTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5lY2hhcnRzUHJvdG8uX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIGVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XG4gICAgdGhpcy5fenIub24oZXZlTmFtZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBlY01vZGVsID0gdGhpcy5nZXRNb2RlbCgpO1xuICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICB2YXIgcGFyYW1zOyAvLyBubyBlLnRhcmdldCB3aGVuICdnbG9iYWxvdXQnLlxuXG4gICAgICBpZiAoZXZlTmFtZSA9PT0gJ2dsb2JhbG91dCcpIHtcbiAgICAgICAgcGFyYW1zID0ge307XG4gICAgICB9IGVsc2UgaWYgKGVsICYmIGVsLmRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkYXRhTW9kZWwgPSBlbC5kYXRhTW9kZWwgfHwgZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KGVsLnNlcmllc0luZGV4KTtcbiAgICAgICAgcGFyYW1zID0gZGF0YU1vZGVsICYmIGRhdGFNb2RlbC5nZXREYXRhUGFyYW1zKGVsLmRhdGFJbmRleCwgZWwuZGF0YVR5cGUpIHx8IHt9O1xuICAgICAgfSAvLyBJZiBlbGVtZW50IGhhcyBjdXN0b20gZXZlbnREYXRhIG9mIGNvbXBvbmVudHNcbiAgICAgIGVsc2UgaWYgKGVsICYmIGVsLmV2ZW50RGF0YSkge1xuICAgICAgICAgIHBhcmFtcyA9IHpyVXRpbC5leHRlbmQoe30sIGVsLmV2ZW50RGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xuICAgICAgICBwYXJhbXMudHlwZSA9IGV2ZU5hbWU7XG4gICAgICAgIHRoaXMudHJpZ2dlcihldmVOYW1lLCBwYXJhbXMpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LCB0aGlzKTtcbiAgZWFjaChldmVudEFjdGlvbk1hcCwgZnVuY3Rpb24gKGFjdGlvblR5cGUsIGV2ZW50VHlwZSkge1xuICAgIHRoaXMuX21lc3NhZ2VDZW50ZXIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihldmVudFR5cGUsIGV2ZW50KTtcbiAgICB9LCB0aGlzKTtcbiAgfSwgdGhpcyk7XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmlzRGlzcG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbn07XG4vKipcbiAqIENsZWFyXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2V0T3B0aW9uKHtcbiAgICBzZXJpZXM6IFtdXG4gIH0sIHRydWUpO1xufTtcbi8qKlxuICogRGlzcG9zZSBpbnN0YW5jZVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgZWFjaCh0aGlzLl9jb21wb25lbnRzVmlld3MsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICB9KTtcbiAgZWFjaCh0aGlzLl9jaGFydHNWaWV3cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgY2hhcnQuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICB9KTsgLy8gRGlzcG9zZSBhZnRlciBhbGwgdmlld3MgZGlzcG9zZWRcblxuICB0aGlzLl96ci5kaXNwb3NlKCk7XG5cbiAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcbn07XG5cbnpyVXRpbC5taXhpbihFQ2hhcnRzLCBFdmVudGZ1bCk7XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvdmVyTGF5ZXJTdGF0dXMoenIsIGVjTW9kZWwpIHtcbiAgdmFyIHN0b3JhZ2UgPSB6ci5zdG9yYWdlO1xuICB2YXIgZWxDb3VudCA9IDA7XG4gIHN0b3JhZ2UudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICBlbENvdW50Kys7XG4gICAgfVxuICB9KTtcblxuICBpZiAoZWxDb3VudCA+IGVjTW9kZWwuZ2V0KCdob3ZlckxheWVyVGhyZXNob2xkJykgJiYgIWVudi5ub2RlKSB7XG4gICAgc3RvcmFnZS50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICBlbC51c2VIb3ZlckxheWVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBVcGRhdGUgY2hhcnQgcHJvZ3Jlc3NpdmUgYW5kIGJsZW5kLlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN8bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBtb2RlbFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudHxtb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0fSB2aWV3XG4gKi9cblxuXG5mdW5jdGlvbiB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpIHtcbiAgLy8gUHJvZ3Jlc3NpdmUgY29uZmlndXJhdGlvblxuICB2YXIgZWxDb3VudCA9IDA7XG4gIGNoYXJ0Vmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwudHlwZSAhPT0gJ2dyb3VwJyAmJiAhZWwuaWdub3JlKSB7XG4gICAgICBlbENvdW50Kys7XG4gICAgfVxuICB9KTtcbiAgdmFyIGZyYW1lRHJhd051bSA9ICtzZXJpZXNNb2RlbC5nZXQoJ3Byb2dyZXNzaXZlJyk7XG4gIHZhciBuZWVkUHJvZ3Jlc3NpdmUgPSBlbENvdW50ID4gc2VyaWVzTW9kZWwuZ2V0KCdwcm9ncmVzc2l2ZVRocmVzaG9sZCcpICYmIGZyYW1lRHJhd051bSAmJiAhZW52Lm5vZGU7XG5cbiAgaWYgKG5lZWRQcm9ncmVzc2l2ZSkge1xuICAgIGNoYXJ0Vmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgIC8vIEZJWE1FIG1hcmtlciBhbmQgb3RoZXIgY29tcG9uZW50c1xuICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgIGVsLnByb2dyZXNzaXZlID0gbmVlZFByb2dyZXNzaXZlID8gTWF0aC5mbG9vcihlbENvdW50KysgLyBmcmFtZURyYXdOdW0pIDogLTE7XG5cbiAgICAgICAgaWYgKG5lZWRQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgIGVsLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBCbGVuZCBjb25maWdyYXRpb25cblxuXG4gIHZhciBibGVuZE1vZGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2JsZW5kTW9kZScpIHx8IG51bGw7XG4gIGNoYXJ0Vmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAvLyBGSVhNRSBtYXJrZXIgYW5kIG90aGVyIGNvbXBvbmVudHNcbiAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgIGVsLnNldFN0eWxlKCdibGVuZCcsIGJsZW5kTW9kZSk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN8bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBtb2RlbFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudHxtb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0fSB2aWV3XG4gKi9cblxuXG5mdW5jdGlvbiB1cGRhdGVaKG1vZGVsLCB2aWV3KSB7XG4gIHZhciB6ID0gbW9kZWwuZ2V0KCd6Jyk7XG4gIHZhciB6bGV2ZWwgPSBtb2RlbC5nZXQoJ3psZXZlbCcpOyAvLyBTZXQgeiBhbmQgemxldmVsXG5cbiAgdmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgeiAhPSBudWxsICYmIChlbC56ID0geik7XG4gICAgICB6bGV2ZWwgIT0gbnVsbCAmJiAoZWwuemxldmVsID0gemxldmVsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFeHRlbnNpb25BUEkoZWNJbnN0YW5jZSkge1xuICB2YXIgY29vcmRTeXNNZ3IgPSBlY0luc3RhbmNlLl9jb29yZFN5c01ncjtcbiAgcmV0dXJuIHpyVXRpbC5leHRlbmQobmV3IEV4dGVuc2lvbkFQSShlY0luc3RhbmNlKSwge1xuICAgIC8vIEluamVjdCBtZXRob2RzXG4gICAgZ2V0Q29vcmRpbmF0ZVN5c3RlbXM6IHpyVXRpbC5iaW5kKGNvb3JkU3lzTWdyLmdldENvb3JkaW5hdGVTeXN0ZW1zLCBjb29yZFN5c01nciksXG4gICAgZ2V0Q29tcG9uZW50QnlFbGVtZW50OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICB2YXIgbW9kZWxJbmZvID0gZWwuX19lY0NvbXBvbmVudEluZm87XG5cbiAgICAgICAgaWYgKG1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGVjSW5zdGFuY2UuX21vZGVsLmdldENvbXBvbmVudChtb2RlbEluZm8ubWFpblR5cGUsIG1vZGVsSW5mby5pbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0fSBrZXk6IGFjdGlvblR5cGUuXG4gKiBAaW5uZXJcbiAqL1xuXG5cbnZhciBhY3Rpb25zID0ge307XG4vKipcbiAqIE1hcCBldmVudFR5cGUgdG8gYWN0aW9uVHlwZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG52YXIgZXZlbnRBY3Rpb25NYXAgPSB7fTtcbi8qKlxuICogRGF0YSBwcm9jZXNzb3IgZnVuY3Rpb25zIG9mIGVhY2ggc3RhZ2VcbiAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsIEZ1bmN0aW9uPj59XG4gKiBAaW5uZXJcbiAqL1xuXG52YXIgZGF0YVByb2Nlc3NvckZ1bmNzID0gW107XG4vKipcbiAqIEB0eXBlIHtBcnJheS48RnVuY3Rpb24+fVxuICogQGlubmVyXG4gKi9cblxudmFyIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzID0gW107XG4vKipcbiAqIEB0eXBlIHtBcnJheS48RnVuY3Rpb24+fVxuICogQGlubmVyXG4gKi9cblxudmFyIHBvc3RVcGRhdGVGdW5jcyA9IFtdO1xuLyoqXG4gKiBWaXN1YWwgZW5jb2RpbmcgZnVuY3Rpb25zIG9mIGVhY2ggc3RhZ2VcbiAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsIEZ1bmN0aW9uPj59XG4gKiBAaW5uZXJcbiAqL1xuXG52YXIgdmlzdWFsRnVuY3MgPSBbXTtcbi8qKlxuICogVGhlbWUgc3RvcmFnZVxuICogQHR5cGUge09iamVjdC48a2V5LCBPYmplY3Q+fVxuICovXG5cbnZhciB0aGVtZVN0b3JhZ2UgPSB7fTtcbi8qKlxuICogTG9hZGluZyBlZmZlY3RzXG4gKi9cblxudmFyIGxvYWRpbmdFZmZlY3RzID0ge307XG52YXIgaW5zdGFuY2VzID0ge307XG52YXIgY29ubmVjdGVkR3JvdXBzID0ge307XG52YXIgaWRCYXNlID0gbmV3IERhdGUoKSAtIDA7XG52YXIgZ3JvdXBJZEJhc2UgPSBuZXcgRGF0ZSgpIC0gMDtcbnZhciBET01fQVRUUklCVVRFX0tFWSA9ICdfZWNoYXJ0c19pbnN0YW5jZV8nO1xudmFyIG1hcERhdGFTdG9yZXMgPSB7fTtcblxuZnVuY3Rpb24gZW5hYmxlQ29ubmVjdChjaGFydCkge1xuICB2YXIgU1RBVFVTX1BFTkRJTkcgPSAwO1xuICB2YXIgU1RBVFVTX1VQREFUSU5HID0gMTtcbiAgdmFyIFNUQVRVU19VUERBVEVEID0gMjtcbiAgdmFyIFNUQVRVU19LRVkgPSAnX19jb25uZWN0VXBkYXRlU3RhdHVzJztcblxuICBmdW5jdGlvbiB1cGRhdGVDb25uZWN0ZWRDaGFydHNTdGF0dXMoY2hhcnRzLCBzdGF0dXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyQ2hhcnQgPSBjaGFydHNbaV07XG4gICAgICBvdGhlckNoYXJ0W1NUQVRVU19LRVldID0gc3RhdHVzO1xuICAgIH1cbiAgfVxuXG4gIHpyVXRpbC5lYWNoKGV2ZW50QWN0aW9uTWFwLCBmdW5jdGlvbiAoYWN0aW9uVHlwZSwgZXZlbnRUeXBlKSB7XG4gICAgY2hhcnQuX21lc3NhZ2VDZW50ZXIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChjb25uZWN0ZWRHcm91cHNbY2hhcnQuZ3JvdXBdICYmIGNoYXJ0W1NUQVRVU19LRVldICE9PSBTVEFUVVNfUEVORElORykge1xuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuZXNjYXBlQ29ubmVjdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb24gPSBjaGFydC5tYWtlQWN0aW9uRnJvbUV2ZW50KGV2ZW50KTtcbiAgICAgICAgdmFyIG90aGVyQ2hhcnRzID0gW107XG4gICAgICAgIHpyVXRpbC5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24gKG90aGVyQ2hhcnQpIHtcbiAgICAgICAgICBpZiAob3RoZXJDaGFydCAhPT0gY2hhcnQgJiYgb3RoZXJDaGFydC5ncm91cCA9PT0gY2hhcnQuZ3JvdXApIHtcbiAgICAgICAgICAgIG90aGVyQ2hhcnRzLnB1c2gob3RoZXJDaGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKG90aGVyQ2hhcnRzLCBTVEFUVVNfUEVORElORyk7XG4gICAgICAgIGVhY2gob3RoZXJDaGFydHMsIGZ1bmN0aW9uIChvdGhlckNoYXJ0KSB7XG4gICAgICAgICAgaWYgKG90aGVyQ2hhcnRbU1RBVFVTX0tFWV0gIT09IFNUQVRVU19VUERBVElORykge1xuICAgICAgICAgICAgb3RoZXJDaGFydC5kaXNwYXRjaEFjdGlvbihhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZUNvbm5lY3RlZENoYXJ0c1N0YXR1cyhvdGhlckNoYXJ0cywgU1RBVFVTX1VQREFURUQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge09iamVjdH0gW3RoZW1lXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXSBVc2Ugd2luZG93LmRldmljZVBpeGVsUmF0aW8gYnkgZGVmYXVsdFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyXSBDdXJyZW50bHkgb25seSAnY2FudmFzJyBpcyBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMud2lkdGhdIFVzZSBjbGllbnRXaWR0aCBvZiB0aGUgaW5wdXQgYGRvbWAgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBVc2UgY2xpZW50SGVpZ2h0IG9mIHRoZSBpbnB1dCBgZG9tYCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKi9cblxuXG5mdW5jdGlvbiBpbml0KGRvbSwgdGhlbWUsIG9wdHMpIHtcbiAgdmFyIGV4aXN0SW5zdGFuY2UgPSBnZXRJbnN0YW5jZUJ5RG9tKGRvbSk7XG5cbiAgaWYgKGV4aXN0SW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZXhpc3RJbnN0YW5jZTtcbiAgfVxuXG4gIHZhciBjaGFydCA9IG5ldyBFQ2hhcnRzKGRvbSwgdGhlbWUsIG9wdHMpO1xuICBjaGFydC5pZCA9ICdlY18nICsgaWRCYXNlKys7XG4gIGluc3RhbmNlc1tjaGFydC5pZF0gPSBjaGFydDtcblxuICBpZiAoZG9tLnNldEF0dHJpYnV0ZSkge1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVksIGNoYXJ0LmlkKTtcbiAgfSBlbHNlIHtcbiAgICBkb21bRE9NX0FUVFJJQlVURV9LRVldID0gY2hhcnQuaWQ7XG4gIH1cblxuICBlbmFibGVDb25uZWN0KGNoYXJ0KTtcbiAgcmV0dXJuIGNoYXJ0O1xufVxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXkuPG1vZHVsZTplY2hhcnRzfkVDaGFydHM+fSBncm91cElkXG4gKi9cblxuXG5mdW5jdGlvbiBjb25uZWN0KGdyb3VwSWQpIHtcbiAgLy8gSXMgYXJyYXkgb2YgY2hhcnRzXG4gIGlmICh6clV0aWwuaXNBcnJheShncm91cElkKSkge1xuICAgIHZhciBjaGFydHMgPSBncm91cElkO1xuICAgIGdyb3VwSWQgPSBudWxsOyAvLyBJZiBhbnkgY2hhcnQgaGFzIGdyb3VwXG5cbiAgICB6clV0aWwuZWFjaChjaGFydHMsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgaWYgKGNoYXJ0Lmdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgZ3JvdXBJZCA9IGNoYXJ0Lmdyb3VwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGdyb3VwSWQgPSBncm91cElkIHx8ICdnXycgKyBncm91cElkQmFzZSsrO1xuICAgIHpyVXRpbC5lYWNoKGNoYXJ0cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICBjaGFydC5ncm91cCA9IGdyb3VwSWQ7XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRHcm91cHNbZ3JvdXBJZF0gPSB0cnVlO1xuICByZXR1cm4gZ3JvdXBJZDtcbn1cbi8qKlxuICogQERFUFJFQ0FURURcbiAqIEByZXR1cm4ge3N0cmluZ30gZ3JvdXBJZFxuICovXG5cblxuZnVuY3Rpb24gZGlzQ29ubmVjdChncm91cElkKSB7XG4gIGNvbm5lY3RlZEdyb3Vwc1tncm91cElkXSA9IGZhbHNlO1xufVxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGdyb3VwSWRcbiAqL1xuXG5cbnZhciBkaXNjb25uZWN0ID0gZGlzQ29ubmVjdDtcbi8qKlxuICogRGlzcG9zZSBhIGNoYXJ0IGluc3RhbmNlXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0c35FQ2hhcnRzfEhUTUxEb21FbGVtZW50fHN0cmluZ30gY2hhcnRcbiAqL1xuXG5mdW5jdGlvbiBkaXNwb3NlKGNoYXJ0KSB7XG4gIGlmICh0eXBlb2YgY2hhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgY2hhcnQgPSBpbnN0YW5jZXNbY2hhcnRdO1xuICB9IGVsc2UgaWYgKCEoY2hhcnQgaW5zdGFuY2VvZiBFQ2hhcnRzKSkge1xuICAgIC8vIFRyeSB0byB0cmVhdCBhcyBkb21cbiAgICBjaGFydCA9IGdldEluc3RhbmNlQnlEb20oY2hhcnQpO1xuICB9XG5cbiAgaWYgKGNoYXJ0IGluc3RhbmNlb2YgRUNoYXJ0cyAmJiAhY2hhcnQuaXNEaXNwb3NlZCgpKSB7XG4gICAgY2hhcnQuZGlzcG9zZSgpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBkb21cbiAqIEByZXR1cm4ge2VjaGFydHN+RUNoYXJ0c31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlQnlEb20oZG9tKSB7XG4gIHZhciBrZXk7XG5cbiAgaWYgKGRvbS5nZXRBdHRyaWJ1dGUpIHtcbiAgICBrZXkgPSBkb20uZ2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZKTtcbiAgfSBlbHNlIHtcbiAgICBrZXkgPSBkb21bRE9NX0FUVFJJQlVURV9LRVldO1xuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlc1trZXldO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtlY2hhcnRzfkVDaGFydHN9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUJ5SWQoa2V5KSB7XG4gIHJldHVybiBpbnN0YW5jZXNba2V5XTtcbn1cbi8qKlxuICogUmVnaXN0ZXIgdGhlbWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyVGhlbWUobmFtZSwgdGhlbWUpIHtcbiAgdGhlbWVTdG9yYWdlW25hbWVdID0gdGhlbWU7XG59XG4vKipcbiAqIFJlZ2lzdGVyIG9wdGlvbiBwcmVwcm9jZXNzb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXByb2Nlc3NvckZ1bmNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUHJlcHJvY2Vzc29yKHByZXByb2Nlc3NvckZ1bmMpIHtcbiAgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MucHVzaChwcmVwcm9jZXNzb3JGdW5jKTtcbn1cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvY2Vzc29yRnVuY1xuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJQcm9jZXNzb3IocHJpb3JpdHksIHByb2Nlc3NvckZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3NvckZ1bmMgPSBwcmlvcml0eTtcbiAgICBwcmlvcml0eSA9IFBSSU9SSVRZX1BST0NFU1NPUl9GSUxURVI7XG4gIH1cblxuICBkYXRhUHJvY2Vzc29yRnVuY3MucHVzaCh7XG4gICAgcHJpbzogcHJpb3JpdHksXG4gICAgZnVuYzogcHJvY2Vzc29yRnVuY1xuICB9KTtcbn1cbi8qKlxuICogUmVnaXN0ZXIgcG9zdFVwZGF0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvc3RVcGRhdGVGdW5jXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlclBvc3RVcGRhdGUocG9zdFVwZGF0ZUZ1bmMpIHtcbiAgcG9zdFVwZGF0ZUZ1bmNzLnB1c2gocG9zdFVwZGF0ZUZ1bmMpO1xufVxuLyoqXG4gKiBVc2FnZTpcbiAqIHJlZ2lzdGVyQWN0aW9uKCdzb21lQWN0aW9uJywgJ3NvbWVFdmVudCcsIGZ1bmN0aW9uICgpIHsgLi4uIH0pO1xuICogcmVnaXN0ZXJBY3Rpb24oJ3NvbWVBY3Rpb24nLCBmdW5jdGlvbiAoKSB7IC4uLiB9KTtcbiAqIHJlZ2lzdGVyQWN0aW9uKFxuICogICAgIHt0eXBlOiAnc29tZUFjdGlvbicsIGV2ZW50OiAnc29tZUV2ZW50JywgdXBkYXRlOiAndXBkYXRlVmlldyd9LFxuICogICAgIGZ1bmN0aW9uICgpIHsgLi4uIH1cbiAqICk7XG4gKlxuICogQHBhcmFtIHsoc3RyaW5nfE9iamVjdCl9IGFjdGlvbkluZm9cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25JbmZvLnR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYWN0aW9uSW5mby5ldmVudF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYWN0aW9uSW5mby51cGRhdGVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V2ZW50TmFtZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvblxuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24oYWN0aW9uSW5mbywgZXZlbnROYW1lLCBhY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhY3Rpb24gPSBldmVudE5hbWU7XG4gICAgZXZlbnROYW1lID0gJyc7XG4gIH1cblxuICB2YXIgYWN0aW9uVHlwZSA9IHpyVXRpbC5pc09iamVjdChhY3Rpb25JbmZvKSA/IGFjdGlvbkluZm8udHlwZSA6IFthY3Rpb25JbmZvLCBhY3Rpb25JbmZvID0ge1xuICAgIGV2ZW50OiBldmVudE5hbWVcbiAgfV1bMF07IC8vIEV2ZW50IG5hbWUgaXMgYWxsIGxvd2VyY2FzZVxuXG4gIGFjdGlvbkluZm8uZXZlbnQgPSAoYWN0aW9uSW5mby5ldmVudCB8fCBhY3Rpb25UeXBlKS50b0xvd2VyQ2FzZSgpO1xuICBldmVudE5hbWUgPSBhY3Rpb25JbmZvLmV2ZW50OyAvLyBWYWxpZGF0ZSBhY3Rpb24gdHlwZSBhbmQgZXZlbnQgbmFtZS5cblxuICB6clV0aWwuYXNzZXJ0KEFDVElPTl9SRUcudGVzdChhY3Rpb25UeXBlKSAmJiBBQ1RJT05fUkVHLnRlc3QoZXZlbnROYW1lKSk7XG5cbiAgaWYgKCFhY3Rpb25zW2FjdGlvblR5cGVdKSB7XG4gICAgYWN0aW9uc1thY3Rpb25UeXBlXSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgYWN0aW9uSW5mbzogYWN0aW9uSW5mb1xuICAgIH07XG4gIH1cblxuICBldmVudEFjdGlvbk1hcFtldmVudE5hbWVdID0gYWN0aW9uVHlwZTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gQ29vcmRpbmF0ZVN5c3RlbVxuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtKHR5cGUsIENvb3JkaW5hdGVTeXN0ZW0pIHtcbiAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucmVnaXN0ZXIodHlwZSwgQ29vcmRpbmF0ZVN5c3RlbSk7XG59XG4vKipcbiAqIEdldCBkaW1lbnNpb25zIG9mIHNwZWNpZmllZCBjb29yZGluYXRlIHN5c3RlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nfE9iamVjdD59XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb29yZGluYXRlU3lzdGVtRGltZW5zaW9ucyh0eXBlKSB7XG4gIHZhciBjb29yZFN5c0NyZWF0b3IgPSBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5nZXQodHlwZSk7XG5cbiAgaWYgKGNvb3JkU3lzQ3JlYXRvcikge1xuICAgIHJldHVybiBjb29yZFN5c0NyZWF0b3IuZ2V0RGltZW5zaW9uc0luZm8gPyBjb29yZFN5c0NyZWF0b3IuZ2V0RGltZW5zaW9uc0luZm8oKSA6IGNvb3JkU3lzQ3JlYXRvci5kaW1lbnNpb25zLnNsaWNlKCk7XG4gIH1cbn1cbi8qKlxuICogTGF5b3V0IGlzIGEgc3BlY2lhbCBzdGFnZSBvZiB2aXN1YWwgZW5jb2RpbmdcbiAqIE1vc3QgdmlzdWFsIGVuY29kaW5nIGxpa2UgY29sb3IgYXJlIGNvbW1vbiBmb3IgZGlmZmVyZW50IGNoYXJ0XG4gKiBCdXQgZWFjaCBjaGFydCBoYXMgaXQncyBvd24gbGF5b3V0IGFsZ29yaXRobVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MTAwMF1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxheW91dEZ1bmNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTGF5b3V0KHByaW9yaXR5LCBsYXlvdXRGdW5jKSB7XG4gIGlmICh0eXBlb2YgcHJpb3JpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBsYXlvdXRGdW5jID0gcHJpb3JpdHk7XG4gICAgcHJpb3JpdHkgPSBQUklPUklUWV9WSVNVQUxfTEFZT1VUO1xuICB9XG5cbiAgdmlzdWFsRnVuY3MucHVzaCh7XG4gICAgcHJpbzogcHJpb3JpdHksXG4gICAgZnVuYzogbGF5b3V0RnVuYyxcbiAgICBpc0xheW91dDogdHJ1ZVxuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0zMDAwXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdmlzdWFsRnVuY1xuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJWaXN1YWwocHJpb3JpdHksIHZpc3VhbEZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZpc3VhbEZ1bmMgPSBwcmlvcml0eTtcbiAgICBwcmlvcml0eSA9IFBSSU9SSVRZX1ZJU1VBTF9DSEFSVDtcbiAgfVxuXG4gIHZpc3VhbEZ1bmNzLnB1c2goe1xuICAgIHByaW86IHByaW9yaXR5LFxuICAgIGZ1bmM6IHZpc3VhbEZ1bmNcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlckxvYWRpbmcobmFtZSwgbG9hZGluZ0Z4KSB7XG4gIGxvYWRpbmdFZmZlY3RzW25hbWVdID0gbG9hZGluZ0Z4O1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdXBlckNsYXNzXVxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kQ29tcG9uZW50TW9kZWwob3B0c1xuLyosIHN1cGVyQ2xhc3MqL1xuKSB7XG4gIC8vIHZhciBDbGF6eiA9IENvbXBvbmVudE1vZGVsO1xuICAvLyBpZiAoc3VwZXJDbGFzcykge1xuICAvLyAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAvLyAgICAgQ2xhenogPSBDb21wb25lbnRNb2RlbC5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YiwgdHJ1ZSk7XG4gIC8vIH1cbiAgcmV0dXJuIENvbXBvbmVudE1vZGVsLmV4dGVuZChvcHRzKTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dGVuZENvbXBvbmVudFZpZXcob3B0c1xuLyosIHN1cGVyQ2xhc3MqL1xuKSB7XG4gIC8vIHZhciBDbGF6eiA9IENvbXBvbmVudFZpZXc7XG4gIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gIC8vICAgICBDbGF6eiA9IENvbXBvbmVudFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIsIHRydWUpO1xuICAvLyB9XG4gIHJldHVybiBDb21wb25lbnRWaWV3LmV4dGVuZChvcHRzKTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dGVuZFNlcmllc01vZGVsKG9wdHNcbi8qLCBzdXBlckNsYXNzKi9cbikge1xuICAvLyB2YXIgQ2xhenogPSBTZXJpZXNNb2RlbDtcbiAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgLy8gICAgIHN1cGVyQ2xhc3MgPSAnc2VyaWVzLicgKyBzdXBlckNsYXNzLnJlcGxhY2UoJ3Nlcmllcy4nLCAnJyk7XG4gIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gIC8vICAgICBDbGF6eiA9IENvbXBvbmVudE1vZGVsLmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViLCB0cnVlKTtcbiAgLy8gfVxuICByZXR1cm4gU2VyaWVzTW9kZWwuZXh0ZW5kKG9wdHMpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdXBlckNsYXNzXVxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kQ2hhcnRWaWV3KG9wdHNcbi8qLCBzdXBlckNsYXNzKi9cbikge1xuICAvLyB2YXIgQ2xhenogPSBDaGFydFZpZXc7XG4gIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gIC8vICAgICBzdXBlckNsYXNzID0gc3VwZXJDbGFzcy5yZXBsYWNlKCdzZXJpZXMuJywgJycpO1xuICAvLyAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAvLyAgICAgQ2xhenogPSBDaGFydFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIHRydWUpO1xuICAvLyB9XG4gIHJldHVybiBDaGFydFZpZXcuZXh0ZW5kKG9wdHMpO1xufVxuLyoqXG4gKiBaUmVuZGVyIG5lZWQgYSBjYW52YXMgY29udGV4dCB0byBkbyBtZWFzdXJlVGV4dC5cbiAqIEJ1dCBpbiBub2RlIGVudmlyb25tZW50IGNhbnZhcyBtYXkgYmUgY3JlYXRlZCBieSBub2RlLWNhbnZhcy5cbiAqIFNvIHdlIG5lZWQgdG8gc3BlY2lmeSBob3cgdG8gY3JlYXRlIGEgY2FudmFzIGluc3RlYWQgb2YgdXNpbmcgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAqXG4gKiBCZSBjYXJlZnVsIG9mIHVzaW5nIGl0IGluIHRoZSBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNyZWF0b3JcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIENhbnZhcyA9IHJlcXVpcmUoJ2NhbnZhcycpO1xuICogICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnZWNoYXJ0cycpO1xuICogICAgIGVjaGFydHMuc2V0Q2FudmFzQ3JlYXRvcihmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIC8vIFNtYWxsIHNpemUgaXMgZW5vdWdoLlxuICogICAgICAgICByZXR1cm4gbmV3IENhbnZhcygzMiwgMzIpO1xuICogICAgIH0pO1xuICovXG5cblxuZnVuY3Rpb24gc2V0Q2FudmFzQ3JlYXRvcihjcmVhdG9yKSB7XG4gIHpyVXRpbC4kb3ZlcnJpZGUoJ2NyZWF0ZUNhbnZhcycsIGNyZWF0b3IpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFwTmFtZVxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBnZW9Kc29uXG4gKiBAcGFyYW0ge09iamVjdH0gW3NwZWNpYWxBcmVhc11cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgICQuZ2V0KCdVU0EuanNvbicsIGZ1bmN0aW9uIChnZW9Kc29uKSB7XG4gKiAgICAgICAgIGVjaGFydHMucmVnaXN0ZXJNYXAoJ1VTQScsIGdlb0pzb24pO1xuICogICAgICAgICAvLyBPclxuICogICAgICAgICBlY2hhcnRzLnJlZ2lzdGVyTWFwKCdVU0EnLCB7XG4gKiAgICAgICAgICAgICBnZW9Kc29uOiBnZW9Kc29uLFxuICogICAgICAgICAgICAgc3BlY2lhbEFyZWFzOiB7fVxuICogICAgICAgICB9KVxuICogICAgIH0pO1xuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJNYXAobWFwTmFtZSwgZ2VvSnNvbiwgc3BlY2lhbEFyZWFzKSB7XG4gIGlmIChnZW9Kc29uLmdlb0pzb24gJiYgIWdlb0pzb24uZmVhdHVyZXMpIHtcbiAgICBzcGVjaWFsQXJlYXMgPSBnZW9Kc29uLnNwZWNpYWxBcmVhcztcbiAgICBnZW9Kc29uID0gZ2VvSnNvbi5nZW9Kc29uO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnZW9Kc29uID09PSAnc3RyaW5nJykge1xuICAgIGdlb0pzb24gPSB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgJiYgSlNPTi5wYXJzZSA/IEpTT04ucGFyc2UoZ2VvSnNvbikgOiBuZXcgRnVuY3Rpb24oJ3JldHVybiAoJyArIGdlb0pzb24gKyAnKTsnKSgpO1xuICB9XG5cbiAgbWFwRGF0YVN0b3Jlc1ttYXBOYW1lXSA9IHtcbiAgICBnZW9Kc29uOiBnZW9Kc29uLFxuICAgIHNwZWNpYWxBcmVhczogc3BlY2lhbEFyZWFzXG4gIH07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRNYXAobWFwTmFtZSkge1xuICByZXR1cm4gbWFwRGF0YVN0b3Jlc1ttYXBOYW1lXTtcbn1cblxucmVnaXN0ZXJWaXN1YWwoUFJJT1JJVFlfVklTVUFMX0dMT0JBTCwgc2VyaWVzQ29sb3IpO1xucmVnaXN0ZXJQcmVwcm9jZXNzb3IoYmFja3dhcmRDb21wYXQpO1xucmVnaXN0ZXJMb2FkaW5nKCdkZWZhdWx0JywgbG9hZGluZ0RlZmF1bHQpOyAvLyBEZWZhdWx0IGFjdGlvbnNcblxucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiAnaGlnaGxpZ2h0JyxcbiAgZXZlbnQ6ICdoaWdobGlnaHQnLFxuICB1cGRhdGU6ICdoaWdobGlnaHQnXG59LCB6clV0aWwubm9vcCk7XG5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICdkb3ducGxheScsXG4gIGV2ZW50OiAnZG93bnBsYXknLFxuICB1cGRhdGU6ICdkb3ducGxheSdcbn0sIHpyVXRpbC5ub29wKTsgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHdoZXJlIHRoZSBuYW1lc3BhY2UgYGRhdGFUb29sYCB3aWxsXG4vLyBiZSBtb3VudGVkIG9uIGBlY2hhcnRzYCBpcyB0aGUgZXh0ZW5zaW9uIGBkYXRhVG9vbGAgaXMgaW1wb3J0ZWQuXG5cbnZhciBkYXRhVG9vbCA9IHt9O1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuZXhwb3J0cy5QUklPUklUWSA9IFBSSU9SSVRZO1xuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMuY29ubmVjdCA9IGNvbm5lY3Q7XG5leHBvcnRzLmRpc0Nvbm5lY3QgPSBkaXNDb25uZWN0O1xuZXhwb3J0cy5kaXNjb25uZWN0ID0gZGlzY29ubmVjdDtcbmV4cG9ydHMuZGlzcG9zZSA9IGRpc3Bvc2U7XG5leHBvcnRzLmdldEluc3RhbmNlQnlEb20gPSBnZXRJbnN0YW5jZUJ5RG9tO1xuZXhwb3J0cy5nZXRJbnN0YW5jZUJ5SWQgPSBnZXRJbnN0YW5jZUJ5SWQ7XG5leHBvcnRzLnJlZ2lzdGVyVGhlbWUgPSByZWdpc3RlclRoZW1lO1xuZXhwb3J0cy5yZWdpc3RlclByZXByb2Nlc3NvciA9IHJlZ2lzdGVyUHJlcHJvY2Vzc29yO1xuZXhwb3J0cy5yZWdpc3RlclByb2Nlc3NvciA9IHJlZ2lzdGVyUHJvY2Vzc29yO1xuZXhwb3J0cy5yZWdpc3RlclBvc3RVcGRhdGUgPSByZWdpc3RlclBvc3RVcGRhdGU7XG5leHBvcnRzLnJlZ2lzdGVyQWN0aW9uID0gcmVnaXN0ZXJBY3Rpb247XG5leHBvcnRzLnJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSA9IHJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbTtcbmV4cG9ydHMuZ2V0Q29vcmRpbmF0ZVN5c3RlbURpbWVuc2lvbnMgPSBnZXRDb29yZGluYXRlU3lzdGVtRGltZW5zaW9ucztcbmV4cG9ydHMucmVnaXN0ZXJMYXlvdXQgPSByZWdpc3RlckxheW91dDtcbmV4cG9ydHMucmVnaXN0ZXJWaXN1YWwgPSByZWdpc3RlclZpc3VhbDtcbmV4cG9ydHMucmVnaXN0ZXJMb2FkaW5nID0gcmVnaXN0ZXJMb2FkaW5nO1xuZXhwb3J0cy5leHRlbmRDb21wb25lbnRNb2RlbCA9IGV4dGVuZENvbXBvbmVudE1vZGVsO1xuZXhwb3J0cy5leHRlbmRDb21wb25lbnRWaWV3ID0gZXh0ZW5kQ29tcG9uZW50VmlldztcbmV4cG9ydHMuZXh0ZW5kU2VyaWVzTW9kZWwgPSBleHRlbmRTZXJpZXNNb2RlbDtcbmV4cG9ydHMuZXh0ZW5kQ2hhcnRWaWV3ID0gZXh0ZW5kQ2hhcnRWaWV3O1xuZXhwb3J0cy5zZXRDYW52YXNDcmVhdG9yID0gc2V0Q2FudmFzQ3JlYXRvcjtcbmV4cG9ydHMucmVnaXN0ZXJNYXAgPSByZWdpc3Rlck1hcDtcbmV4cG9ydHMuZ2V0TWFwID0gZ2V0TWFwO1xuZXhwb3J0cy5kYXRhVG9vbCA9IGRhdGFUb29sO1xudmFyIF9fX2VjX2V4cG9ydCA9IHJlcXVpcmUoXCIuL2V4cG9ydFwiKTtcbihmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIF9fX2VjX2V4cG9ydCkge1xuICAgICAgICBpZiAoX19fZWNfZXhwb3J0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGV4cG9ydHNba2V5XSA9IF9fX2VjX2V4cG9ydFtrZXldO1xuICAgICAgICB9XG4gICAgfVxufSkoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9lY2hhcnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9lY2hhcnRzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyZW5kZXIgPSByZXF1aXJlKFwienJlbmRlci9saWIvenJlbmRlclwiKTtcblxuZXhwb3J0cy56cmVuZGVyID0genJlbmRlcjtcblxudmFyIG1hdHJpeCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL21hdHJpeFwiKTtcblxuZXhwb3J0cy5tYXRyaXggPSBtYXRyaXg7XG5cbnZhciB2ZWN0b3IgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS92ZWN0b3JcIik7XG5cbmV4cG9ydHMudmVjdG9yID0gdmVjdG9yO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi90b29sL2NvbG9yXCIpO1xuXG5leHBvcnRzLmNvbG9yID0gY29sb3JUb29sO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuL3V0aWwvZ3JhcGhpY1wiKTtcblxuZXhwb3J0cy5ncmFwaGljID0gZ3JhcGhpYztcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi91dGlsL251bWJlclwiKTtcblxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXJVdGlsO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvZm9ybWF0XCIpO1xuXG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdFV0aWw7XG5cbnZhciBfdGhyb3R0bGUgPSByZXF1aXJlKFwiLi91dGlsL3Rocm90dGxlXCIpO1xuXG52YXIgdGhyb3R0bGUgPSBfdGhyb3R0bGUudGhyb3R0bGU7XG5leHBvcnRzLnRocm90dGxlID0gX3Rocm90dGxlLnRocm90dGxlO1xuXG52YXIgZWNIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5cbmV4cG9ydHMuaGVscGVyID0gZWNIZWxwZXI7XG5cbnZhciBfTGlzdCA9IHJlcXVpcmUoXCIuL2RhdGEvTGlzdFwiKTtcblxuZXhwb3J0cy5MaXN0ID0gX0xpc3Q7XG5cbnZhciBfTW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbC9Nb2RlbFwiKTtcblxuZXhwb3J0cy5Nb2RlbCA9IF9Nb2RlbDtcblxudmFyIF9BeGlzID0gcmVxdWlyZShcIi4vY29vcmQvQXhpc1wiKTtcblxuZXhwb3J0cy5BeGlzID0gX0F4aXM7XG5cbnZhciBfZW52ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZW52XCIpO1xuXG5leHBvcnRzLmVudiA9IF9lbnY7XG5cbnZhciBfcGFyc2VHZW9Kc29uID0gcmVxdWlyZShcIi4vY29vcmQvZ2VvL3BhcnNlR2VvSnNvblwiKTtcblxuZXhwb3J0cy5wYXJzZUdlb0pzb24gPSBfcGFyc2VHZW9Kc29uO1xuXG4vKipcbiAqIERvIG5vdCBtb3VudCB0aG9zZSBtb2R1bGVzIG9uICdzcmMvZWNoYXJ0cycgZm9yIGJldHRlciB0cmVlIHNoYWtpbmcuXG4gKi9cbnZhciBlY1V0aWwgPSB7fTtcbnpyVXRpbC5lYWNoKFsnbWFwJywgJ2VhY2gnLCAnZmlsdGVyJywgJ2luZGV4T2YnLCAnaW5oZXJpdHMnLCAncmVkdWNlJywgJ2ZpbHRlcicsICdiaW5kJywgJ2N1cnJ5JywgJ2lzQXJyYXknLCAnaXNTdHJpbmcnLCAnaXNPYmplY3QnLCAnaXNGdW5jdGlvbicsICdleHRlbmQnLCAnZGVmYXVsdHMnLCAnY2xvbmUnLCAnbWVyZ2UnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZWNVdGlsW25hbWVdID0genJVdGlsW25hbWVdO1xufSk7XG5leHBvcnRzLnV0aWwgPSBlY1V0aWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9leHBvcnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKFwiLi9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheVwiKTtcblxudmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKFwiLi9jb29yZC9heGlzSGVscGVyXCIpO1xuXG52YXIgYXhpc01vZGVsQ29tbW9uTWl4aW4gPSByZXF1aXJlKFwiLi9jb29yZC9heGlzTW9kZWxDb21tb25NaXhpblwiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvTW9kZWxcIik7XG5cbnZhciBfY29tcGxldGVEaW1lbnNpb25zID0gcmVxdWlyZShcIi4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zXCIpO1xuXG5leHBvcnRzLmNvbXBsZXRlRGltZW5zaW9ucyA9IF9jb21wbGV0ZURpbWVuc2lvbnM7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4vdXRpbC9zeW1ib2xcIik7XG5cbmV4cG9ydHMuY3JlYXRlU3ltYm9sID0gX3N5bWJvbC5jcmVhdGVTeW1ib2w7XG5cbi8qKlxuICogQ3JlYXRlIGEgbXV0aSBkaW1lbnNpb24gTGlzdCBzdHJ1Y3R1cmUgZnJvbSBzZXJpZXNNb2RlbC5cbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBzZXJpZXNNb2RlbFxuICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBsaXN0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxpc3Qoc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKTtcbiAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkoZGF0YSwgc2VyaWVzTW9kZWwsIHNlcmllc01vZGVsLmVjTW9kZWwpO1xufVxuLyoqXG4gKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZSBzY2FsZVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YUV4dGVudFxuICogQHBhcmFtIHtPYmplY3R8bW9kdWxlOmVjaGFydHMvTW9kZWx9IG9wdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVTY2FsZShkYXRhRXh0ZW50LCBvcHRpb24pIHtcbiAgdmFyIGF4aXNNb2RlbCA9IG9wdGlvbjtcblxuICBpZiAoIShvcHRpb24gaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICBheGlzTW9kZWwgPSBuZXcgTW9kZWwob3B0aW9uKTtcbiAgICB6clV0aWwubWl4aW4oYXhpc01vZGVsLCBheGlzTW9kZWxDb21tb25NaXhpbik7XG4gIH1cblxuICB2YXIgc2NhbGUgPSBheGlzSGVscGVyLmNyZWF0ZVNjYWxlQnlNb2RlbChheGlzTW9kZWwpO1xuICBzY2FsZS5zZXRFeHRlbnQoZGF0YUV4dGVudFswXSwgZGF0YUV4dGVudFsxXSk7XG4gIGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50KHNjYWxlLCBheGlzTW9kZWwpO1xuICByZXR1cm4gc2NhbGU7XG59XG4vKipcbiAqIE1peGluIGNvbW1vbiBtZXRob2RzIHRvIGF4aXMgbW9kZWwsXG4gKlxuICogSW5sY3VkZSBtZXRob2RzXG4gKiBgZ2V0Rm9ybWF0dGVkTGFiZWxzKCkgPT4gQXJyYXkuPHN0cmluZz5gXG4gKiBgZ2V0Q2F0ZWdvcmllcygpID0+IEFycmF5LjxzdHJpbmc+YFxuICogYGdldE1pbihvcmlnaW46IGJvb2xlYW4pID0+IG51bWJlcmBcbiAqIGBnZXRNYXgob3JpZ2luOiBib29sZWFuKSA9PiBudW1iZXJgXG4gKiBgZ2V0TmVlZENyb3NzWmVybygpID0+IGJvb2xlYW5gXG4gKiBgc2V0UmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpYFxuICogYHJlc2V0UmFuZ2UoKWBcbiAqL1xuXG5cbmZ1bmN0aW9uIG1peGluQXhpc01vZGVsQ29tbW9uTWV0aG9kcyhNb2RlbCkge1xuICB6clV0aWwubWl4aW4oTW9kZWwsIGF4aXNNb2RlbENvbW1vbk1peGluKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVMaXN0ID0gY3JlYXRlTGlzdDtcbmV4cG9ydHMuY3JlYXRlU2NhbGUgPSBjcmVhdGVTY2FsZTtcbmV4cG9ydHMubWl4aW5BeGlzTW9kZWxDb21tb25NZXRob2RzID0gbWl4aW5BeGlzTW9kZWxDb21tb25NZXRob2RzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvaGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9kZWZhdWx0ID0ge1xuICB0b29sYm94OiB7XG4gICAgYnJ1c2g6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHJlY3Q6ICfnn6nlvaLpgInmi6knLFxuICAgICAgICBwb2x5Z29uOiAn5ZyI6YCJJyxcbiAgICAgICAgbGluZVg6ICfmqKrlkJHpgInmi6knLFxuICAgICAgICBsaW5lWTogJ+e6teWQkemAieaLqScsXG4gICAgICAgIGtlZXA6ICfkv53mjIHpgInmi6knLFxuICAgICAgICBjbGVhcjogJ+a4hemZpOmAieaLqSdcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGFWaWV3OiB7XG4gICAgICB0aXRsZTogJ+aVsOaNruinhuWbvicsXG4gICAgICBsYW5nOiBbJ+aVsOaNruinhuWbvicsICflhbPpl60nLCAn5Yi35pawJ11cbiAgICB9LFxuICAgIGRhdGFab29tOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICB6b29tOiAn5Yy65Z+f57yp5pS+JyxcbiAgICAgICAgYmFjazogJ+WMuuWfn+e8qeaUvui/mOWOnydcbiAgICAgIH1cbiAgICB9LFxuICAgIG1hZ2ljVHlwZToge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgbGluZTogJ+WIh+aNouS4uuaKmOe6v+WbvicsXG4gICAgICAgIGJhcjogJ+WIh+aNouS4uuafseeKtuWbvicsXG4gICAgICAgIHN0YWNrOiAn5YiH5o2i5Li65aCG5Y+gJyxcbiAgICAgICAgdGlsZWQ6ICfliIfmjaLkuLrlubPpk7onXG4gICAgICB9XG4gICAgfSxcbiAgICByZXN0b3JlOiB7XG4gICAgICB0aXRsZTogJ+i/mOWOnydcbiAgICB9LFxuICAgIHNhdmVBc0ltYWdlOiB7XG4gICAgICB0aXRsZTogJ+S/neWtmOS4uuWbvueJhycsXG4gICAgICBsYW5nOiBbJ+WPs+mUruWPpuWtmOS4uuWbvueJhyddXG4gICAgfVxuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYW5nLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBfbnVtYmVyID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgcGFyc2VQZXJjZW50ID0gX251bWJlci5wYXJzZVBlcmNlbnQ7XG52YXIgU1RBQ0tfUFJFRklYID0gJ19fZWNfc3RhY2tfJztcblxuZnVuY3Rpb24gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0KCdzdGFjaycpIHx8IFNUQUNLX1BSRUZJWCArIHNlcmllc01vZGVsLnNlcmllc0luZGV4O1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzS2V5KGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMuZGltICsgYXhpcy5pbmRleDtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBvcHQuYXhpcyBPbmx5IHN1cHBvcnQgY2F0ZWdvcnkgYXhpcyBjdXJyZW50bHkuXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0LmNvdW50IFBvc2l0aXZlIGludGVyZ2VyLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuYmFyV2lkdGhdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJNYXhXaWR0aF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmJhckdhcF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmJhckNhdGVnb3J5R2FwXVxuICogQHJldHVybiB7T2JqZWN0fSB7d2lkdGgsIG9mZnNldCwgb2Zmc2V0Q2VudGVyfSBJZiBheGlzLnR5cGUgaXMgbm90ICdjYXRlZ29yeScsIHJldHVybiB1bmRlZmluZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMYXlvdXRPbkF4aXMob3B0LCBhcGkpIHtcbiAgdmFyIHBhcmFtcyA9IFtdO1xuICB2YXIgYmFzZUF4aXMgPSBvcHQuYXhpcztcbiAgdmFyIGF4aXNLZXkgPSAnYXhpczAnO1xuXG4gIGlmIChiYXNlQXhpcy50eXBlICE9PSAnY2F0ZWdvcnknKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJhbmRXaWR0aCA9IGJhc2VBeGlzLmdldEJhbmRXaWR0aCgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0LmNvdW50IHx8IDA7IGkrKykge1xuICAgIHBhcmFtcy5wdXNoKHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICBiYW5kV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgIGF4aXNLZXk6IGF4aXNLZXksXG4gICAgICBzdGFja0lkOiBTVEFDS19QUkVGSVggKyBpXG4gICAgfSwgb3B0KSk7XG4gIH1cblxuICB2YXIgd2lkdGhBbmRPZmZzZXRzID0gZG9DYWxCYXJXaWR0aEFuZE9mZnNldChwYXJhbXMsIGFwaSk7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdC5jb3VudDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSB3aWR0aEFuZE9mZnNldHNbYXhpc0tleV1bU1RBQ0tfUFJFRklYICsgaV07XG4gICAgaXRlbS5vZmZzZXRDZW50ZXIgPSBpdGVtLm9mZnNldCArIGl0ZW0ud2lkdGggLyAyO1xuICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2FsQmFyV2lkdGhBbmRPZmZzZXQoYmFyU2VyaWVzLCBhcGkpIHtcbiAgdmFyIHNlcmllc0luZm9MaXN0ID0genJVdGlsLm1hcChiYXJTZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBiYXNlQXhpcyA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpO1xuICAgIHZhciBheGlzRXh0ZW50ID0gYmFzZUF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGJhbmRXaWR0aCA9IGJhc2VBeGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBiYXNlQXhpcy5nZXRCYW5kV2lkdGgoKSA6IE1hdGguYWJzKGF4aXNFeHRlbnRbMV0gLSBheGlzRXh0ZW50WzBdKSAvIGRhdGEuY291bnQoKTtcbiAgICB2YXIgYmFyV2lkdGggPSBwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdiYXJXaWR0aCcpLCBiYW5kV2lkdGgpO1xuICAgIHZhciBiYXJNYXhXaWR0aCA9IHBhcnNlUGVyY2VudChzZXJpZXNNb2RlbC5nZXQoJ2Jhck1heFdpZHRoJyksIGJhbmRXaWR0aCk7XG4gICAgdmFyIGJhckdhcCA9IHNlcmllc01vZGVsLmdldCgnYmFyR2FwJyk7XG4gICAgdmFyIGJhckNhdGVnb3J5R2FwID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJDYXRlZ29yeUdhcCcpO1xuICAgIHJldHVybiB7XG4gICAgICBiYW5kV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgIGJhck1heFdpZHRoOiBiYXJNYXhXaWR0aCxcbiAgICAgIGJhckdhcDogYmFyR2FwLFxuICAgICAgYmFyQ2F0ZWdvcnlHYXA6IGJhckNhdGVnb3J5R2FwLFxuICAgICAgYXhpc0tleTogZ2V0QXhpc0tleShiYXNlQXhpcyksXG4gICAgICBzdGFja0lkOiBnZXRTZXJpZXNTdGFja0lkKHNlcmllc01vZGVsKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZG9DYWxCYXJXaWR0aEFuZE9mZnNldChzZXJpZXNJbmZvTGlzdCwgYXBpKTtcbn1cblxuZnVuY3Rpb24gZG9DYWxCYXJXaWR0aEFuZE9mZnNldChzZXJpZXNJbmZvTGlzdCwgYXBpKSB7XG4gIC8vIENvbHVtbnMgaW5mbyBvbiBlYWNoIGNhdGVnb3J5IGF4aXMuIEtleSBpcyBjYXJ0ZXNpYW4gbmFtZVxuICB2YXIgY29sdW1uc01hcCA9IHt9O1xuICB6clV0aWwuZWFjaChzZXJpZXNJbmZvTGlzdCwgZnVuY3Rpb24gKHNlcmllc0luZm8sIGlkeCkge1xuICAgIHZhciBheGlzS2V5ID0gc2VyaWVzSW5mby5heGlzS2V5O1xuICAgIHZhciBiYW5kV2lkdGggPSBzZXJpZXNJbmZvLmJhbmRXaWR0aDtcbiAgICB2YXIgY29sdW1uc09uQXhpcyA9IGNvbHVtbnNNYXBbYXhpc0tleV0gfHwge1xuICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICByZW1haW5lZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICBhdXRvV2lkdGhDb3VudDogMCxcbiAgICAgIGNhdGVnb3J5R2FwOiAnMjAlJyxcbiAgICAgIGdhcDogJzMwJScsXG4gICAgICBzdGFja3M6IHt9XG4gICAgfTtcbiAgICB2YXIgc3RhY2tzID0gY29sdW1uc09uQXhpcy5zdGFja3M7XG4gICAgY29sdW1uc01hcFtheGlzS2V5XSA9IGNvbHVtbnNPbkF4aXM7XG4gICAgdmFyIHN0YWNrSWQgPSBzZXJpZXNJbmZvLnN0YWNrSWQ7XG5cbiAgICBpZiAoIXN0YWNrc1tzdGFja0lkXSkge1xuICAgICAgY29sdW1uc09uQXhpcy5hdXRvV2lkdGhDb3VudCsrO1xuICAgIH1cblxuICAgIHN0YWNrc1tzdGFja0lkXSA9IHN0YWNrc1tzdGFja0lkXSB8fCB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIG1heFdpZHRoOiAwXG4gICAgfTsgLy8gQ2F1dGlvbjogSW4gYSBzaW5nbGUgY29vcmRpbmF0ZSBzeXN0ZW0sIHRoZXNlIGJhckdyaWQgYXR0cmlidXRlc1xuICAgIC8vIHdpbGwgYmUgc2hhcmVkIGJ5IHNlcmllcy4gQ29uc2lkZXIgdGhhdCB0aGV5IGhhdmUgZGVmYXVsdCB2YWx1ZXMsXG4gICAgLy8gb25seSB0aGUgYXR0cmlidXRlcyBzZXQgb24gdGhlIGxhc3Qgc2VyaWVzIHdpbGwgd29yay5cbiAgICAvLyBEbyBub3QgY2hhbmdlIHRoaXMgZmFjdCB1bmxlc3MgdGhlcmUgd2lsbCBiZSBhIGJyZWFrIGNoYW5nZS5cbiAgICAvLyBUT0RPXG5cbiAgICB2YXIgYmFyV2lkdGggPSBzZXJpZXNJbmZvLmJhcldpZHRoO1xuXG4gICAgaWYgKGJhcldpZHRoICYmICFzdGFja3Nbc3RhY2tJZF0ud2lkdGgpIHtcbiAgICAgIC8vIFNlZSAjNjMxMiwgZG8gbm90IHJlc3RyaWN0IHdpZHRoLlxuICAgICAgc3RhY2tzW3N0YWNrSWRdLndpZHRoID0gYmFyV2lkdGg7XG4gICAgICBiYXJXaWR0aCA9IE1hdGgubWluKGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aCwgYmFyV2lkdGgpO1xuICAgICAgY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoIC09IGJhcldpZHRoO1xuICAgIH1cblxuICAgIHZhciBiYXJNYXhXaWR0aCA9IHNlcmllc0luZm8uYmFyTWF4V2lkdGg7XG4gICAgYmFyTWF4V2lkdGggJiYgKHN0YWNrc1tzdGFja0lkXS5tYXhXaWR0aCA9IGJhck1heFdpZHRoKTtcbiAgICB2YXIgYmFyR2FwID0gc2VyaWVzSW5mby5iYXJHYXA7XG4gICAgYmFyR2FwICE9IG51bGwgJiYgKGNvbHVtbnNPbkF4aXMuZ2FwID0gYmFyR2FwKTtcbiAgICB2YXIgYmFyQ2F0ZWdvcnlHYXAgPSBzZXJpZXNJbmZvLmJhckNhdGVnb3J5R2FwO1xuICAgIGJhckNhdGVnb3J5R2FwICE9IG51bGwgJiYgKGNvbHVtbnNPbkF4aXMuY2F0ZWdvcnlHYXAgPSBiYXJDYXRlZ29yeUdhcCk7XG4gIH0pO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHpyVXRpbC5lYWNoKGNvbHVtbnNNYXAsIGZ1bmN0aW9uIChjb2x1bW5zT25BeGlzLCBjb29yZFN5c05hbWUpIHtcbiAgICByZXN1bHRbY29vcmRTeXNOYW1lXSA9IHt9O1xuICAgIHZhciBzdGFja3MgPSBjb2x1bW5zT25BeGlzLnN0YWNrcztcbiAgICB2YXIgYmFuZFdpZHRoID0gY29sdW1uc09uQXhpcy5iYW5kV2lkdGg7XG4gICAgdmFyIGNhdGVnb3J5R2FwID0gcGFyc2VQZXJjZW50KGNvbHVtbnNPbkF4aXMuY2F0ZWdvcnlHYXAsIGJhbmRXaWR0aCk7XG4gICAgdmFyIGJhckdhcFBlcmNlbnQgPSBwYXJzZVBlcmNlbnQoY29sdW1uc09uQXhpcy5nYXAsIDEpO1xuICAgIHZhciByZW1haW5lZFdpZHRoID0gY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoO1xuICAgIHZhciBhdXRvV2lkdGhDb3VudCA9IGNvbHVtbnNPbkF4aXMuYXV0b1dpZHRoQ291bnQ7XG4gICAgdmFyIGF1dG9XaWR0aCA9IChyZW1haW5lZFdpZHRoIC0gY2F0ZWdvcnlHYXApIC8gKGF1dG9XaWR0aENvdW50ICsgKGF1dG9XaWR0aENvdW50IC0gMSkgKiBiYXJHYXBQZXJjZW50KTtcbiAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApOyAvLyBGaW5kIGlmIGFueSBhdXRvIGNhbGN1bGF0ZWQgYmFyIGV4Y2VlZGVkIG1heEJhcldpZHRoXG5cbiAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrKSB7XG4gICAgICB2YXIgbWF4V2lkdGggPSBjb2x1bW4ubWF4V2lkdGg7XG5cbiAgICAgIGlmIChtYXhXaWR0aCAmJiBtYXhXaWR0aCA8IGF1dG9XaWR0aCkge1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKG1heFdpZHRoLCByZW1haW5lZFdpZHRoKTtcblxuICAgICAgICBpZiAoY29sdW1uLndpZHRoKSB7XG4gICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCwgY29sdW1uLndpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbWFpbmVkV2lkdGggLT0gbWF4V2lkdGg7XG4gICAgICAgIGNvbHVtbi53aWR0aCA9IG1heFdpZHRoO1xuICAgICAgICBhdXRvV2lkdGhDb3VudC0tO1xuICAgICAgfVxuICAgIH0pOyAvLyBSZWNhbGN1bGF0ZSB3aWR0aCBhZ2FpblxuXG4gICAgYXV0b1dpZHRoID0gKHJlbWFpbmVkV2lkdGggLSBjYXRlZ29yeUdhcCkgLyAoYXV0b1dpZHRoQ291bnQgKyAoYXV0b1dpZHRoQ291bnQgLSAxKSAqIGJhckdhcFBlcmNlbnQpO1xuICAgIGF1dG9XaWR0aCA9IE1hdGgubWF4KGF1dG9XaWR0aCwgMCk7XG4gICAgdmFyIHdpZHRoU3VtID0gMDtcbiAgICB2YXIgbGFzdENvbHVtbjtcbiAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIGlkeCkge1xuICAgICAgaWYgKCFjb2x1bW4ud2lkdGgpIHtcbiAgICAgICAgY29sdW1uLndpZHRoID0gYXV0b1dpZHRoO1xuICAgICAgfVxuXG4gICAgICBsYXN0Q29sdW1uID0gY29sdW1uO1xuICAgICAgd2lkdGhTdW0gKz0gY29sdW1uLndpZHRoICogKDEgKyBiYXJHYXBQZXJjZW50KTtcbiAgICB9KTtcblxuICAgIGlmIChsYXN0Q29sdW1uKSB7XG4gICAgICB3aWR0aFN1bSAtPSBsYXN0Q29sdW1uLndpZHRoICogYmFyR2FwUGVyY2VudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gLXdpZHRoU3VtIC8gMjtcbiAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrSWQpIHtcbiAgICAgIHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdID0gcmVzdWx0W2Nvb3JkU3lzTmFtZV1bc3RhY2tJZF0gfHwge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgd2lkdGg6IGNvbHVtbi53aWR0aFxuICAgICAgfTtcbiAgICAgIG9mZnNldCArPSBjb2x1bW4ud2lkdGggKiAoMSArIGJhckdhcFBlcmNlbnQpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlcmllc1R5cGVcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gKi9cblxuXG5mdW5jdGlvbiBiYXJMYXlvdXRHcmlkKHNlcmllc1R5cGUsIGVjTW9kZWwsIGFwaSkge1xuICB2YXIgYmFyV2lkdGhBbmRPZmZzZXQgPSBjYWxCYXJXaWR0aEFuZE9mZnNldCh6clV0aWwuZmlsdGVyKGVjTW9kZWwuZ2V0U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUpLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICByZXR1cm4gIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkgJiYgc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSAmJiBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCc7XG4gIH0pKTtcbiAgdmFyIGxhc3RTdGFja0Nvb3JkcyA9IHt9O1xuICB2YXIgbGFzdFN0YWNrQ29vcmRzT3JpZ2luID0ge307XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAvLyBDaGVjayBzZXJpZXMgY29vcmRpbmF0ZSwgZG8gbGF5b3V0IGZvciBjYXJ0ZXNpYW4yZCBvbmx5XG4gICAgaWYgKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0udHlwZSAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBiYXNlQXhpcyA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpO1xuICAgIHZhciBzdGFja0lkID0gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCk7XG4gICAgdmFyIGNvbHVtbkxheW91dEluZm8gPSBiYXJXaWR0aEFuZE9mZnNldFtnZXRBeGlzS2V5KGJhc2VBeGlzKV1bc3RhY2tJZF07XG4gICAgdmFyIGNvbHVtbk9mZnNldCA9IGNvbHVtbkxheW91dEluZm8ub2Zmc2V0O1xuICAgIHZhciBjb2x1bW5XaWR0aCA9IGNvbHVtbkxheW91dEluZm8ud2lkdGg7XG4gICAgdmFyIHZhbHVlQXhpcyA9IGNhcnRlc2lhbi5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICAgIHZhciBiYXJNaW5IZWlnaHQgPSBzZXJpZXNNb2RlbC5nZXQoJ2Jhck1pbkhlaWdodCcpIHx8IDA7XG4gICAgdmFyIHZhbHVlQXhpc1N0YXJ0ID0gYmFzZUF4aXMub25aZXJvID8gdmFsdWVBeGlzLnRvR2xvYmFsQ29vcmQodmFsdWVBeGlzLmRhdGFUb0Nvb3JkKDApKSA6IHZhbHVlQXhpcy5nZXRHbG9iYWxFeHRlbnQoKVswXTtcbiAgICB2YXIgY29vcmREaW1zID0gW3Nlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKCd4JylbMF0sIHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKCd5JylbMF1dO1xuICAgIHZhciBjb29yZHMgPSBkYXRhLm1hcEFycmF5KGNvb3JkRGltcywgZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiBjYXJ0ZXNpYW4uZGF0YVRvUG9pbnQoW3gsIHldKTtcbiAgICB9LCB0cnVlKTtcbiAgICBsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF0gPSBsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF0gfHwgW107XG4gICAgbGFzdFN0YWNrQ29vcmRzT3JpZ2luW3N0YWNrSWRdID0gbGFzdFN0YWNrQ29vcmRzT3JpZ2luW3N0YWNrSWRdIHx8IFtdOyAvLyBGaXggIzQyNDNcblxuICAgIGRhdGEuc2V0TGF5b3V0KHtcbiAgICAgIG9mZnNldDogY29sdW1uT2Zmc2V0LFxuICAgICAgc2l6ZTogY29sdW1uV2lkdGhcbiAgICB9KTtcbiAgICBkYXRhLmVhY2goc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0odmFsdWVBeGlzLmRpbSlbMF0sIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1baWR4XSkge1xuICAgICAgICBsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1baWR4XSA9IHtcbiAgICAgICAgICBwOiB2YWx1ZUF4aXNTdGFydCxcbiAgICAgICAgICAvLyBQb3NpdGl2ZSBzdGFja1xuICAgICAgICAgIG46IHZhbHVlQXhpc1N0YXJ0IC8vIE5lZ2F0aXZlIHN0YWNrXG5cbiAgICAgICAgfTtcbiAgICAgICAgbGFzdFN0YWNrQ29vcmRzT3JpZ2luW3N0YWNrSWRdW2lkeF0gPSB7XG4gICAgICAgICAgcDogdmFsdWVBeGlzU3RhcnQsXG4gICAgICAgICAgLy8gUG9zaXRpdmUgc3RhY2tcbiAgICAgICAgICBuOiB2YWx1ZUF4aXNTdGFydCAvLyBOZWdhdGl2ZSBzdGFja1xuXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBzaWduID0gdmFsdWUgPj0gMCA/ICdwJyA6ICduJztcbiAgICAgIHZhciBjb29yZCA9IGNvb3Jkc1tpZHhdO1xuICAgICAgdmFyIGxhc3RDb29yZCA9IGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dO1xuICAgICAgdmFyIGxhc3RDb29yZE9yaWdpbiA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dO1xuICAgICAgdmFyIHg7XG4gICAgICB2YXIgeTtcbiAgICAgIHZhciB3aWR0aDtcbiAgICAgIHZhciBoZWlnaHQ7XG5cbiAgICAgIGlmICh2YWx1ZUF4aXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgeCA9IGxhc3RDb29yZDtcbiAgICAgICAgeSA9IGNvb3JkWzFdICsgY29sdW1uT2Zmc2V0O1xuICAgICAgICB3aWR0aCA9IGNvb3JkWzBdIC0gbGFzdENvb3JkT3JpZ2luO1xuICAgICAgICBoZWlnaHQgPSBjb2x1bW5XaWR0aDtcbiAgICAgICAgbGFzdFN0YWNrQ29vcmRzT3JpZ2luW3N0YWNrSWRdW2lkeF1bc2lnbl0gKz0gd2lkdGg7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHdpZHRoKSA8IGJhck1pbkhlaWdodCkge1xuICAgICAgICAgIHdpZHRoID0gKHdpZHRoIDwgMCA/IC0xIDogMSkgKiBiYXJNaW5IZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1baWR4XVtzaWduXSArPSB3aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBjb29yZFswXSArIGNvbHVtbk9mZnNldDtcbiAgICAgICAgeSA9IGxhc3RDb29yZDtcbiAgICAgICAgd2lkdGggPSBjb2x1bW5XaWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gY29vcmRbMV0gLSBsYXN0Q29vcmRPcmlnaW47XG4gICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dICs9IGhlaWdodDtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoaGVpZ2h0KSA8IGJhck1pbkhlaWdodCkge1xuICAgICAgICAgIC8vIEluY2x1ZGUgemVybyB0byBoYXMgYSBwb3NpdGl2ZSBiYXJcbiAgICAgICAgICBoZWlnaHQgPSAoaGVpZ2h0IDw9IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF1bc2lnbl0gKz0gaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH0sIHRydWUpO1xuICB9LCB0aGlzKTtcbn1cblxuYmFyTGF5b3V0R3JpZC5nZXRMYXlvdXRPbkF4aXMgPSBnZXRMYXlvdXRPbkF4aXM7XG52YXIgX2RlZmF1bHQgPSBiYXJMYXlvdXRHcmlkO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYXlvdXQvYmFyR3JpZC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L2JhckdyaWQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJmdW5jdGlvbiBfZGVmYXVsdChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgaWYgKCFjb29yZFN5cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaW1zID0gW107XG4gICAgdmFyIGNvb3JkRGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkRGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGltcy5wdXNoKHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGNvb3JkU3lzLmRpbWVuc2lvbnNbaV0pWzBdKTtcbiAgICB9XG5cbiAgICBpZiAoZGltcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRhdGEuZWFjaChkaW1zWzBdLCBmdW5jdGlvbiAoeCwgaWR4KSB7XG4gICAgICAgIC8vIEFsc28ge0FycmF5LjxudW1iZXI+fSwgbm90IHVuZGVmaW5lZCB0byBhdm9pZCBpZi4uLmVsc2UuLi4gc3RhdGVtZW50XG4gICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIGlzTmFOKHgpID8gW05hTiwgTmFOXSA6IGNvb3JkU3lzLmRhdGFUb1BvaW50KHgpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGltcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGRhdGEuZWFjaChkaW1zLCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICAgIC8vIEFsc28ge0FycmF5LjxudW1iZXI+fSwgbm90IHVuZGVmaW5lZCB0byBhdm9pZCBpZi4uLmVsc2UuLi4gc3RhdGVtZW50XG4gICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIGlzTmFOKHgpIHx8IGlzTmFOKHkpID8gW05hTiwgTmFOXSA6IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSkpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYXlvdXQvcG9pbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYXlvdXQvcG9pbnRzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIFBJID0gTWF0aC5QSTtcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRleHRdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29sb3JdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudGV4dENvbG9yXVxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBfZGVmYXVsdChhcGksIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHpyVXRpbC5kZWZhdWx0cyhvcHRzLCB7XG4gICAgdGV4dDogJ2xvYWRpbmcnLFxuICAgIGNvbG9yOiAnI2MyMzUzMScsXG4gICAgdGV4dENvbG9yOiAnIzAwMCcsXG4gICAgbWFza0NvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpJyxcbiAgICB6bGV2ZWw6IDBcbiAgfSk7XG4gIHZhciBtYXNrID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZpbGw6IG9wdHMubWFza0NvbG9yXG4gICAgfSxcbiAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgIHo6IDEwMDAwXG4gIH0pO1xuICB2YXIgYXJjID0gbmV3IGdyYXBoaWMuQXJjKHtcbiAgICBzaGFwZToge1xuICAgICAgc3RhcnRBbmdsZTogLVBJIC8gMixcbiAgICAgIGVuZEFuZ2xlOiAtUEkgLyAyICsgMC4xLFxuICAgICAgcjogMTBcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBzdHJva2U6IG9wdHMuY29sb3IsXG4gICAgICBsaW5lQ2FwOiAncm91bmQnLFxuICAgICAgbGluZVdpZHRoOiA1XG4gICAgfSxcbiAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgIHo6IDEwMDAxXG4gIH0pO1xuICB2YXIgbGFiZWxSZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgIHRleHQ6IG9wdHMudGV4dCxcbiAgICAgIHRleHRQb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgIHRleHREaXN0YW5jZTogMTAsXG4gICAgICB0ZXh0RmlsbDogb3B0cy50ZXh0Q29sb3JcbiAgICB9LFxuICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgejogMTAwMDFcbiAgfSk7XG4gIGFyYy5hbmltYXRlU2hhcGUodHJ1ZSkud2hlbigxMDAwLCB7XG4gICAgZW5kQW5nbGU6IFBJICogMyAvIDJcbiAgfSkuc3RhcnQoJ2NpcmN1bGFySW5PdXQnKTtcbiAgYXJjLmFuaW1hdGVTaGFwZSh0cnVlKS53aGVuKDEwMDAsIHtcbiAgICBzdGFydEFuZ2xlOiBQSSAqIDMgLyAyXG4gIH0pLmRlbGF5KDMwMCkuc3RhcnQoJ2NpcmN1bGFySW5PdXQnKTtcbiAgdmFyIGdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgZ3JvdXAuYWRkKGFyYyk7XG4gIGdyb3VwLmFkZChsYWJlbFJlY3QpO1xuICBncm91cC5hZGQobWFzayk7IC8vIEluamVjdCByZXNpemVcblxuICBncm91cC5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN4ID0gYXBpLmdldFdpZHRoKCkgLyAyO1xuICAgIHZhciBjeSA9IGFwaS5nZXRIZWlnaHQoKSAvIDI7XG4gICAgYXJjLnNldFNoYXBlKHtcbiAgICAgIGN4OiBjeCxcbiAgICAgIGN5OiBjeVxuICAgIH0pO1xuICAgIHZhciByID0gYXJjLnNoYXBlLnI7XG4gICAgbGFiZWxSZWN0LnNldFNoYXBlKHtcbiAgICAgIHg6IGN4IC0gcixcbiAgICAgIHk6IGN5IC0gcixcbiAgICAgIHdpZHRoOiByICogMixcbiAgICAgIGhlaWdodDogciAqIDJcbiAgICB9KTtcbiAgICBtYXNrLnNldFNoYXBlKHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9KTtcbiAgfTtcblxuICBncm91cC5yZXNpemUoKTtcbiAgcmV0dXJuIGdyb3VwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xvYWRpbmcvZGVmYXVsdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbG9hZGluZy9kZWZhdWx0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuL01vZGVsXCIpO1xuXG52YXIgY29tcG9uZW50VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbXBvbmVudFwiKTtcblxudmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2NsYXp6XCIpO1xuXG52YXIgbGF5b3V0ID0gcmVxdWlyZShcIi4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgYm94TGF5b3V0TWl4aW4gPSByZXF1aXJlKFwiLi9taXhpbi9ib3hMYXlvdXRcIik7XG5cbi8qKlxuICogQ29tcG9uZW50IG1vZGVsXG4gKlxuICogQG1vZHVsZSBlY2hhcnRzL21vZGVsL0NvbXBvbmVudFxuICovXG52YXIgYXJyYXlQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gcGFyZW50TW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGVjTW9kZWxcbiAqL1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSBNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnY29tcG9uZW50JyxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBpZDogJycsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgbmFtZTogJycsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgbWFpblR5cGU6ICcnLFxuXG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN1YlR5cGU6ICcnLFxuXG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGNvbXBvbmVudEluZGV4OiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGVjTW9kZWw6IG51bGwsXG5cbiAgLyoqXG4gICAqIGtleTogY29tcG9uZW50VHlwZVxuICAgKiB2YWx1ZTogIENvbXBvbmVudCBtb2RlbCBsaXN0LCBjYW4gbm90IGJlIG51bGwuXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPj59XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZGVwZW5kZW50TW9kZWxzOiBbXSxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB1aWQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIFN1cHBvcnQgbWVyZ2UgbGF5b3V0IHBhcmFtcy5cbiAgICogT25seSBzdXBwb3J0ICdib3gnIG5vdyAobGVmdC9yaWdodC90b3AvYm90dG9tL3dpZHRoL2hlaWdodCkuXG4gICAqIEB0eXBlIHtzdHJpbmd8T2JqZWN0fSBPYmplY3QgY2FuIGJlIHtpZ25vcmVTaXplOiB0cnVlfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGxheW91dE1vZGU6IG51bGwsXG4gICRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4gICAgTW9kZWwuY2FsbCh0aGlzLCBvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCk7XG4gICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgnY29tcG9uZW50TW9kZWwnKTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICB9LFxuICBtZXJnZURlZmF1bHRBbmRUaGVtZTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0TW9kZSA/IGxheW91dC5nZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9O1xuICAgIHZhciB0aGVtZU1vZGVsID0gZWNNb2RlbC5nZXRUaGVtZSgpO1xuICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoZW1lTW9kZWwuZ2V0KHRoaXMubWFpblR5cGUpKTtcbiAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XG5cbiAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0ob3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zLCBsYXlvdXRNb2RlKTtcbiAgICB9XG4gIH0sXG4gIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uLCBleHRyYU9wdCkge1xuICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgb3B0aW9uLCB0cnVlKTtcbiAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcblxuICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzLm9wdGlvbiwgb3B0aW9uLCBsYXlvdXRNb2RlKTtcbiAgICB9XG4gIH0sXG4gIC8vIEhvb2tlciBhZnRlciBpbml0IG9yIG1lcmdlT3B0aW9uXG4gIG9wdGlvblVwZGF0ZWQ6IGZ1bmN0aW9uIChuZXdDcHRPcHRpb24sIGlzSW5pdCkge30sXG4gIGdldERlZmF1bHRPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNsYXp6VXRpbC5oYXNPd24odGhpcywgJ19fZGVmYXVsdE9wdGlvbicpKSB7XG4gICAgICB2YXIgb3B0TGlzdCA9IFtdO1xuICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgICAgd2hpbGUgKENsYXNzKSB7XG4gICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcbiAgICAgICAgb3B0ICYmIG9wdExpc3QucHVzaChvcHQpO1xuICAgICAgICBDbGFzcyA9IENsYXNzLnN1cGVyQ2xhc3M7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSBvcHRMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNsYXp6VXRpbC5zZXQodGhpcywgJ19fZGVmYXVsdE9wdGlvbicsIGRlZmF1bHRPcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBjbGF6elV0aWwuZ2V0KHRoaXMsICdfX2RlZmF1bHRPcHRpb24nKTtcbiAgfSxcbiAgZ2V0UmVmZXJyaW5nQ29tcG9uZW50czogZnVuY3Rpb24gKG1haW5UeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgbWFpblR5cGU6IG1haW5UeXBlLFxuICAgICAgaW5kZXg6IHRoaXMuZ2V0KG1haW5UeXBlICsgJ0luZGV4JywgdHJ1ZSksXG4gICAgICBpZDogdGhpcy5nZXQobWFpblR5cGUgKyAnSWQnLCB0cnVlKVxuICAgIH0pO1xuICB9XG59KTsgLy8gUmVzZXQgQ29tcG9uZW50TW9kZWwuZXh0ZW5kLCBhZGQgcHJlQ29uc3RydWN0LlxuLy8gY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKFxuLy8gICAgIENvbXBvbmVudE1vZGVsLFxuLy8gICAgIGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuLy8gICAgICAgICAvLyBTZXQgZGVwZW5kZW50TW9kZWxzLCBjb21wb25lbnRJbmRleCwgbmFtZSwgaWQsIG1haW5UeXBlLCBzdWJUeXBlLlxuLy8gICAgICAgICB6clV0aWwuZXh0ZW5kKHRoaXMsIGV4dHJhT3B0KTtcbi8vICAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgnY29tcG9uZW50TW9kZWwnKTtcbi8vICAgICAgICAgLy8gdGhpcy5zZXRSZWFkT25seShbXG4vLyAgICAgICAgIC8vICAgICAndHlwZScsICdpZCcsICd1aWQnLCAnbmFtZScsICdtYWluVHlwZScsICdzdWJUeXBlJyxcbi8vICAgICAgICAgLy8gICAgICdkZXBlbmRlbnRNb2RlbHMnLCAnY29tcG9uZW50SW5kZXgnXG4vLyAgICAgICAgIC8vIF0pO1xuLy8gICAgIH1cbi8vICk7XG4vLyBBZGQgY2FwYWJpbGl0eSBvZiByZWdpc3RlckNsYXNzLCBnZXRDbGFzcywgaGFzQ2xhc3MsIHJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciBhbmQgc28gb24uXG5cbmNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ29tcG9uZW50TW9kZWwsIHtcbiAgcmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlXG59KTtcbmNvbXBvbmVudFV0aWwuZW5hYmxlU3ViVHlwZURlZmF1bHRlcihDb21wb25lbnRNb2RlbCk7IC8vIEFkZCBjYXBhYmlsaXR5IG9mIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsLlxuXG5jb21wb25lbnRVdGlsLmVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsKENvbXBvbmVudE1vZGVsLCBnZXREZXBlbmRlbmNpZXMpO1xuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoY29tcG9uZW50VHlwZSkge1xuICB2YXIgZGVwcyA9IFtdO1xuICB6clV0aWwuZWFjaChDb21wb25lbnRNb2RlbC5nZXRDbGFzc2VzQnlNYWluVHlwZShjb21wb25lbnRUeXBlKSwgZnVuY3Rpb24gKENsYXp6KSB7XG4gICAgYXJyYXlQdXNoLmFwcGx5KGRlcHMsIENsYXp6LnByb3RvdHlwZS5kZXBlbmRlbmNpZXMgfHwgW10pO1xuICB9KTsgLy8gRW5zdXJlIG1haW4gdHlwZVxuXG4gIHJldHVybiB6clV0aWwubWFwKGRlcHMsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIGNsYXp6VXRpbC5wYXJzZUNsYXNzVHlwZSh0eXBlKS5tYWluO1xuICB9KTtcbn1cblxuenJVdGlsLm1peGluKENvbXBvbmVudE1vZGVsLCBib3hMYXlvdXRNaXhpbik7XG52YXIgX2RlZmF1bHQgPSBDb21wb25lbnRNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9Db21wb25lbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21vZGVsXCIpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi9Nb2RlbFwiKTtcblxudmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZShcIi4vQ29tcG9uZW50XCIpO1xuXG52YXIgZ2xvYmFsRGVmYXVsdCA9IHJlcXVpcmUoXCIuL2dsb2JhbERlZmF1bHRcIik7XG5cbnZhciBjb2xvclBhbGV0dGVNaW5pbiA9IHJlcXVpcmUoXCIuL21peGluL2NvbG9yUGFsZXR0ZVwiKTtcblxuLyoqXG4gKiBFQ2hhcnRzIGdsb2JhbCBtb2RlbFxuICpcbiAqIEBtb2R1bGUge2VjaGFydHMvbW9kZWwvR2xvYmFsfVxuICovXG5cbi8qKlxuICogQ2F1dGlvbjogSWYgdGhlIG1lY2hhbmlzbSBzaG91bGQgYmUgY2hhbmdlZCBzb21lIGRheSwgdGhlc2UgY2FzZXNcbiAqIHNob3VsZCBiZSBjb25zaWRlcmVkOlxuICpcbiAqICgxKSBJbiBgbWVyZ2Ugb3B0aW9uYCBtb2RlLCBpZiB1c2luZyB0aGUgc2FtZSBvcHRpb24gdG8gY2FsbCBgc2V0T3B0aW9uYFxuICogbWFueSB0aW1lcywgdGhlIHJlc3VsdCBzaG91bGQgYmUgdGhlIHNhbWUgKHRyeSBvdXIgYmVzdCB0byBlbnN1cmUgdGhhdCkuXG4gKiAoMikgSW4gYG1lcmdlIG9wdGlvbmAgbW9kZSwgaWYgYSBjb21wb25lbnQgaGFzIG5vIGlkL25hbWUgc3BlY2lmaWVkLCBpdFxuICogd2lsbCBiZSBtZXJnZWQgYnkgaW5kZXgsIGFuZCB0aGUgcmVzdWx0IHNlcXVlbmNlIG9mIHRoZSBjb21wb25lbnRzIGlzXG4gKiBjb25zaXN0ZW50IHRvIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS5cbiAqICgzKSBgcmVzZXRgIGZlYXR1cmUgKGluIHRvb2xib3gpLiBGaW5kIGRldGFpbGVkIGluZm8gaW4gY29tbWVudHMgYWJvdXRcbiAqIGBtZXJnZU9wdGlvbmAgaW4gbW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlci5cbiAqL1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBmaWx0ZXIgPSB6clV0aWwuZmlsdGVyO1xudmFyIG1hcCA9IHpyVXRpbC5tYXA7XG52YXIgaXNBcnJheSA9IHpyVXRpbC5pc0FycmF5O1xudmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcbnZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcbnZhciBPUFRJT05fSU5ORVJfS0VZID0gJ1xcMF9lY19pbm5lcic7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBwYXJlbnRNb2RlbFxuICogQHBhcmFtIHtPYmplY3R9IHRoZW1lXG4gKi9cblxudmFyIEdsb2JhbE1vZGVsID0gTW9kZWwuZXh0ZW5kKHtcbiAgY29uc3RydWN0b3I6IEdsb2JhbE1vZGVsLFxuICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgdGhlbWUsIG9wdGlvbk1hbmFnZXIpIHtcbiAgICB0aGVtZSA9IHRoZW1lIHx8IHt9O1xuICAgIHRoaXMub3B0aW9uID0gbnVsbDsgLy8gTWFyayBhcyBub3QgaW5pdGlhbGl6ZWQuXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX3RoZW1lID0gbmV3IE1vZGVsKHRoZW1lKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuX29wdGlvbk1hbmFnZXIgPSBvcHRpb25NYW5hZ2VyO1xuICB9LFxuICBzZXRPcHRpb246IGZ1bmN0aW9uIChvcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgenJVdGlsLmFzc2VydCghKE9QVElPTl9JTk5FUl9LRVkgaW4gb3B0aW9uKSwgJ3BsZWFzZSB1c2UgY2hhcnQuZ2V0T3B0aW9uKCknKTtcblxuICAgIHRoaXMuX29wdGlvbk1hbmFnZXIuc2V0T3B0aW9uKG9wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpO1xuXG4gICAgdGhpcy5yZXNldE9wdGlvbihudWxsKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgbnVsbC91bmRlZmluZWQ6IHJlc2V0IGFsbC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgJ3JlY3JlYXRlJzogZm9yY2UgcmVjcmVhdGUgYWxsLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAndGltZWxpbmUnOiBvbmx5IHJlc2V0IHRpbWVsaW5lIG9wdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAnbWVkaWEnOiBvbmx5IHJlc2V0IG1lZGlhIHF1ZXJ5IG9wdGlvblxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9wdGlvbiBjaGFuZ2VkLlxuICAgKi9cbiAgcmVzZXRPcHRpb246IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIG9wdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgb3B0aW9uTWFuYWdlciA9IHRoaXMuX29wdGlvbk1hbmFnZXI7XG5cbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJykge1xuICAgICAgdmFyIGJhc2VPcHRpb24gPSBvcHRpb25NYW5hZ2VyLm1vdW50T3B0aW9uKHR5cGUgPT09ICdyZWNyZWF0ZScpO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9uIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScpIHtcbiAgICAgICAgaW5pdEJhc2UuY2FsbCh0aGlzLCBiYXNlT3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihiYXNlT3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICd0aW1lbGluZScgfHwgdHlwZSA9PT0gJ21lZGlhJykge1xuICAgICAgdGhpcy5yZXN0b3JlRGF0YSgpO1xuICAgIH1cblxuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnIHx8IHR5cGUgPT09ICd0aW1lbGluZScpIHtcbiAgICAgIHZhciB0aW1lbGluZU9wdGlvbiA9IG9wdGlvbk1hbmFnZXIuZ2V0VGltZWxpbmVPcHRpb24odGhpcyk7XG4gICAgICB0aW1lbGluZU9wdGlvbiAmJiAodGhpcy5tZXJnZU9wdGlvbih0aW1lbGluZU9wdGlvbiksIG9wdGlvbkNoYW5nZWQgPSB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJyB8fCB0eXBlID09PSAnbWVkaWEnKSB7XG4gICAgICB2YXIgbWVkaWFPcHRpb25zID0gb3B0aW9uTWFuYWdlci5nZXRNZWRpYU9wdGlvbih0aGlzLCB0aGlzLl9hcGkpO1xuXG4gICAgICBpZiAobWVkaWFPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICBlYWNoKG1lZGlhT3B0aW9ucywgZnVuY3Rpb24gKG1lZGlhT3B0aW9uKSB7XG4gICAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihtZWRpYU9wdGlvbiwgb3B0aW9uQ2hhbmdlZCA9IHRydWUpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uQ2hhbmdlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIGNvbXBvbmVudHNNYXAgPSB0aGlzLl9jb21wb25lbnRzTWFwO1xuICAgIHZhciBuZXdDcHRUeXBlcyA9IFtdOyAvLyDlpoLmnpzkuI3lrZjlnKjlr7nlupTnmoQgY29tcG9uZW50IG1vZGVsIOWImeebtOaOpSBtZXJnZVxuXG4gICAgZWFjaChuZXdPcHRpb24sIGZ1bmN0aW9uIChjb21wb25lbnRPcHRpb24sIG1haW5UeXBlKSB7XG4gICAgICBpZiAoY29tcG9uZW50T3B0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgICBvcHRpb25bbWFpblR5cGVdID0gb3B0aW9uW21haW5UeXBlXSA9PSBudWxsID8genJVdGlsLmNsb25lKGNvbXBvbmVudE9wdGlvbikgOiB6clV0aWwubWVyZ2Uob3B0aW9uW21haW5UeXBlXSwgY29tcG9uZW50T3B0aW9uLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NwdFR5cGVzLnB1c2gobWFpblR5cGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBGSVhNRSBPUFRJT04g5ZCM5q2l5piv5ZCm6KaB5pS55Zue5Y6f5p2l55qEXG5cbiAgICBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbChuZXdDcHRUeXBlcywgQ29tcG9uZW50TW9kZWwuZ2V0QWxsQ2xhc3NNYWluVHlwZXMoKSwgdmlzaXRDb21wb25lbnQsIHRoaXMpO1xuICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSB0aGlzLl9zZXJpZXNJbmRpY2VzIHx8IFtdO1xuXG4gICAgZnVuY3Rpb24gdmlzaXRDb21wb25lbnQobWFpblR5cGUsIGRlcGVuZGVuY2llcykge1xuICAgICAgdmFyIG5ld0NwdE9wdGlvbkxpc3QgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShuZXdPcHRpb25bbWFpblR5cGVdKTtcbiAgICAgIHZhciBtYXBSZXN1bHQgPSBtb2RlbFV0aWwubWFwcGluZ1RvRXhpc3RzKGNvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKSwgbmV3Q3B0T3B0aW9uTGlzdCk7XG4gICAgICBtb2RlbFV0aWwubWFrZUlkQW5kTmFtZShtYXBSZXN1bHQpOyAvLyBTZXQgbWFpblR5cGUgYW5kIGNvbXBsZXRlIHN1YlR5cGUuXG5cbiAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG9wdCA9IGl0ZW0ub3B0aW9uO1xuXG4gICAgICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICAgICAgaXRlbS5rZXlJbmZvLm1haW5UeXBlID0gbWFpblR5cGU7XG4gICAgICAgICAgaXRlbS5rZXlJbmZvLnN1YlR5cGUgPSBkZXRlcm1pbmVTdWJUeXBlKG1haW5UeXBlLCBvcHQsIGl0ZW0uZXhpc3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBkZXBlbmRlbnRNb2RlbHMgPSBnZXRDb21wb25lbnRzQnlUeXBlcyhjb21wb25lbnRzTWFwLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgb3B0aW9uW21haW5UeXBlXSA9IFtdO1xuICAgICAgY29tcG9uZW50c01hcC5zZXQobWFpblR5cGUsIFtdKTtcbiAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAocmVzdWx0SXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE1vZGVsID0gcmVzdWx0SXRlbS5leGlzdDtcbiAgICAgICAgdmFyIG5ld0NwdE9wdGlvbiA9IHJlc3VsdEl0ZW0ub3B0aW9uO1xuICAgICAgICB6clV0aWwuYXNzZXJ0KGlzT2JqZWN0KG5ld0NwdE9wdGlvbikgfHwgY29tcG9uZW50TW9kZWwsICdFbXB0eSBjb21wb25lbnQgZGVmaW5pdGlvbicpOyAvLyBDb25zaWRlciB3aGVyZSBpcyBubyBuZXcgb3B0aW9uIGFuZCBzaG91bGQgYmUgbWVyZ2VkIHVzaW5nIHt9LFxuICAgICAgICAvLyBzZWUgcmVtb3ZlRWRnZUFuZEFkZCBpbiB0b3BvbG9naWNhbFRyYXZlbCBhbmRcbiAgICAgICAgLy8gQ29tcG9uZW50TW9kZWwuZ2V0QWxsQ2xhc3NNYWluVHlwZXMuXG5cbiAgICAgICAgaWYgKCFuZXdDcHRPcHRpb24pIHtcbiAgICAgICAgICBjb21wb25lbnRNb2RlbC5tZXJnZU9wdGlvbih7fSwgdGhpcyk7XG4gICAgICAgICAgY29tcG9uZW50TW9kZWwub3B0aW9uVXBkYXRlZCh7fSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBDb21wb25lbnRNb2RlbENsYXNzID0gQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3MobWFpblR5cGUsIHJlc3VsdEl0ZW0ua2V5SW5mby5zdWJUeXBlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChjb21wb25lbnRNb2RlbCAmJiBjb21wb25lbnRNb2RlbCBpbnN0YW5jZW9mIENvbXBvbmVudE1vZGVsQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm5hbWUgPSByZXN1bHRJdGVtLmtleUluZm8ubmFtZTtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm1lcmdlT3B0aW9uKG5ld0NwdE9wdGlvbiwgdGhpcyk7XG4gICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKG5ld0NwdE9wdGlvbiwgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQRU5ESU5HIEdsb2JhbCBhcyBwYXJlbnQgP1xuICAgICAgICAgICAgdmFyIGV4dHJhT3B0ID0genJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgIGRlcGVuZGVudE1vZGVsczogZGVwZW5kZW50TW9kZWxzLFxuICAgICAgICAgICAgICBjb21wb25lbnRJbmRleDogaW5kZXhcbiAgICAgICAgICAgIH0sIHJlc3VsdEl0ZW0ua2V5SW5mbyk7XG4gICAgICAgICAgICBjb21wb25lbnRNb2RlbCA9IG5ldyBDb21wb25lbnRNb2RlbENsYXNzKG5ld0NwdE9wdGlvbiwgdGhpcywgdGhpcywgZXh0cmFPcHQpO1xuICAgICAgICAgICAgenJVdGlsLmV4dGVuZChjb21wb25lbnRNb2RlbCwgZXh0cmFPcHQpO1xuICAgICAgICAgICAgY29tcG9uZW50TW9kZWwuaW5pdChuZXdDcHRPcHRpb24sIHRoaXMsIHRoaXMsIGV4dHJhT3B0KTsgLy8gQ2FsbCBvcHRpb25VcGRhdGVkIGFmdGVyIGluaXQuXG4gICAgICAgICAgICAvLyBuZXdDcHRPcHRpb24gaGFzIGJlZW4gdXNlZCBhcyBjb21wb25lbnRNb2RlbC5vcHRpb25cbiAgICAgICAgICAgIC8vIGFuZCBtYXkgYmUgbWVyZ2VkIHdpdGggdGhlbWUgYW5kIGRlZmF1bHQsIHNvIHBhc3MgbnVsbFxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgY29uZnVzaW9uLlxuXG4gICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKG51bGwsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKVtpbmRleF0gPSBjb21wb25lbnRNb2RlbDtcbiAgICAgICAgb3B0aW9uW21haW5UeXBlXVtpbmRleF0gPSBjb21wb25lbnRNb2RlbC5vcHRpb247XG4gICAgICB9LCB0aGlzKTsgLy8gQmFja3VwIHNlcmllcyBmb3IgZmlsdGVyaW5nLlxuXG4gICAgICBpZiAobWFpblR5cGUgPT09ICdzZXJpZXMnKSB7XG4gICAgICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSBjcmVhdGVTZXJpZXNJbmRpY2VzKGNvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgb3B0aW9uIGZvciBvdXRwdXQgKGNsb25lZCBvcHRpb24gYW5kIGlubmVyIGluZm8gcmVtb3ZlZClcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9uID0genJVdGlsLmNsb25lKHRoaXMub3B0aW9uKTtcbiAgICBlYWNoKG9wdGlvbiwgZnVuY3Rpb24gKG9wdHMsIG1haW5UeXBlKSB7XG4gICAgICBpZiAoQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICAgIHZhciBvcHRzID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkob3B0cyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IG9wdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAvLyBSZW1vdmUgb3B0aW9ucyB3aXRoIGlubmVyIGlkLlxuICAgICAgICAgIGlmIChtb2RlbFV0aWwuaXNJZElubmVyKG9wdHNbaV0pKSB7XG4gICAgICAgICAgICBvcHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25bbWFpblR5cGVdID0gb3B0cztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWxldGUgb3B0aW9uW09QVElPTl9JTk5FUl9LRVldO1xuICAgIHJldHVybiBvcHRpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgKi9cbiAgZ2V0VGhlbWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYWluVHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2lkeD0wXVxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9XG4gICAqL1xuICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIChtYWluVHlwZSwgaWR4KSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzTWFwLmdldChtYWluVHlwZSk7XG5cbiAgICBpZiAobGlzdCkge1xuICAgICAgcmV0dXJuIGxpc3RbaWR4IHx8IDBdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSWYgbm9uZSBvZiBpbmRleCBhbmQgaWQgYW5kIG5hbWUgdXNlZCwgcmV0dXJuIGFsbCBjb21wb25lbnRzIHdpdGggbWFpblR5cGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmRpdGlvbi5tYWluVHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmRpdGlvbi5zdWJUeXBlXSBJZiBpZ25vcmUsIG9ubHkgcXVlcnkgYnkgbWFpblR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtjb25kaXRpb24uaW5kZXhdIEVpdGhlciBpbnB1dCBpbmRleCBvciBpZCBvciBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2NvbmRpdGlvbi5pZF0gRWl0aGVyIGlucHV0IGluZGV4IG9yIGlkIG9yIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbY29uZGl0aW9uLm5hbWVdIEVpdGhlciBpbnB1dCBpbmRleCBvciBpZCBvciBuYW1lLlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50Pn1cbiAgICovXG4gIHF1ZXJ5Q29tcG9uZW50czogZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIHZhciBtYWluVHlwZSA9IGNvbmRpdGlvbi5tYWluVHlwZTtcblxuICAgIGlmICghbWFpblR5cGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBjb25kaXRpb24uaW5kZXg7XG4gICAgdmFyIGlkID0gY29uZGl0aW9uLmlkO1xuICAgIHZhciBuYW1lID0gY29uZGl0aW9uLm5hbWU7XG5cbiAgICB2YXIgY3B0cyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKTtcblxuICAgIGlmICghY3B0cyB8fCAhY3B0cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgIGlmICghaXNBcnJheShpbmRleCkpIHtcbiAgICAgICAgaW5kZXggPSBbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBmaWx0ZXIobWFwKGluZGV4LCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiBjcHRzW2lkeF07XG4gICAgICB9KSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gISF2YWw7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgIHZhciBpc0lkQXJyYXkgPSBpc0FycmF5KGlkKTtcbiAgICAgIHJlc3VsdCA9IGZpbHRlcihjcHRzLCBmdW5jdGlvbiAoY3B0KSB7XG4gICAgICAgIHJldHVybiBpc0lkQXJyYXkgJiYgaW5kZXhPZihpZCwgY3B0LmlkKSA+PSAwIHx8ICFpc0lkQXJyYXkgJiYgY3B0LmlkID09PSBpZDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICB2YXIgaXNOYW1lQXJyYXkgPSBpc0FycmF5KG5hbWUpO1xuICAgICAgcmVzdWx0ID0gZmlsdGVyKGNwdHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFtZUFycmF5ICYmIGluZGV4T2YobmFtZSwgY3B0Lm5hbWUpID49IDAgfHwgIWlzTmFtZUFycmF5ICYmIGNwdC5uYW1lID09PSBuYW1lO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldHVybiBhbGwgY29tcG9uZW50cyB3aXRoIG1haW5UeXBlXG4gICAgICByZXN1bHQgPSBjcHRzLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlckJ5U3ViVHlwZShyZXN1bHQsIGNvbmRpdGlvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlcmZhY2UgaXMgZGlmZmVyZW50IGZyb20gcXVlcnlDb21wb25lbnRzLFxuICAgKiB3aGljaCBpcyBjb252ZW5pZW50IGZvciBpbm5lciB1c2FnZS5cbiAgICpcbiAgICogQHVzYWdlXG4gICAqIHZhciByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcbiAgICogICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHtkYXRhWm9vbUlkOiAnYWJjJ319XG4gICAqICk7XG4gICAqIHZhciByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcbiAgICogICAgIHttYWluVHlwZTogJ3NlcmllcycsIHN1YlR5cGU6ICdwaWUnLCBxdWVyeToge3Nlcmllc05hbWU6ICd1aW8nfX1cbiAgICogKTtcbiAgICogdmFyIHJlc3VsdCA9IGZpbmRDb21wb25lbnRzKFxuICAgKiAgICAge21haW5UeXBlOiAnc2VyaWVzJ30sXG4gICAqICAgICBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7Li4ufVxuICAgKiApO1xuICAgKiAvLyByZXN1bHQgbGlrZSBbY29tcG9uZW50MCwgY29tcG9ubmV0MSwgLi4uXVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb25kaXRpb24ubWFpblR5cGUgTWFuZGF0b3J5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmRpdGlvbi5zdWJUeXBlXSBPcHRpb25hbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb24ucXVlcnldIGxpa2Uge3h4eEluZGV4LCB4eHhJZCwgeHh4TmFtZX0sXG4gICAqICAgICAgICB3aGVyZSB4eHggaXMgbWFpblR5cGUuXG4gICAqICAgICAgICBJZiBxdWVyeSBhdHRyaWJ1dGUgaXMgbnVsbC91bmRlZmluZWQgb3IgaGFzIG5vIGluZGV4L2lkL25hbWUsXG4gICAqICAgICAgICBkbyBub3QgZmlsdGVyaW5nIGJ5IHF1ZXJ5IGNvbmRpdGlvbnMsIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yXG4gICAqICAgICAgICBuby1wYXlsb2FkIHNpdHVhdGlvbnMgb3Igd2hlbiB0YXJnZXQgb2YgYWN0aW9uIGlzIGdsb2JhbC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmRpdGlvbi5maWx0ZXJdIHBhcmFtZXRlcjogY29tcG9uZW50LCByZXR1cm4gYm9vbGVhbi5cbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59XG4gICAqL1xuICBmaW5kQ29tcG9uZW50czogZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIHZhciBxdWVyeSA9IGNvbmRpdGlvbi5xdWVyeTtcbiAgICB2YXIgbWFpblR5cGUgPSBjb25kaXRpb24ubWFpblR5cGU7XG4gICAgdmFyIHF1ZXJ5Q29uZCA9IGdldFF1ZXJ5Q29uZChxdWVyeSk7XG4gICAgdmFyIHJlc3VsdCA9IHF1ZXJ5Q29uZCA/IHRoaXMucXVlcnlDb21wb25lbnRzKHF1ZXJ5Q29uZCkgOiB0aGlzLl9jb21wb25lbnRzTWFwLmdldChtYWluVHlwZSk7XG4gICAgcmV0dXJuIGRvRmlsdGVyKGZpbHRlckJ5U3ViVHlwZShyZXN1bHQsIGNvbmRpdGlvbikpO1xuXG4gICAgZnVuY3Rpb24gZ2V0UXVlcnlDb25kKHEpIHtcbiAgICAgIHZhciBpbmRleEF0dHIgPSBtYWluVHlwZSArICdJbmRleCc7XG4gICAgICB2YXIgaWRBdHRyID0gbWFpblR5cGUgKyAnSWQnO1xuICAgICAgdmFyIG5hbWVBdHRyID0gbWFpblR5cGUgKyAnTmFtZSc7XG4gICAgICByZXR1cm4gcSAmJiAocVtpbmRleEF0dHJdICE9IG51bGwgfHwgcVtpZEF0dHJdICE9IG51bGwgfHwgcVtuYW1lQXR0cl0gIT0gbnVsbCkgPyB7XG4gICAgICAgIG1haW5UeXBlOiBtYWluVHlwZSxcbiAgICAgICAgLy8gc3ViVHlwZSB3aWxsIGJlIGZpbHRlcmVkIGZpbmFsbHkuXG4gICAgICAgIGluZGV4OiBxW2luZGV4QXR0cl0sXG4gICAgICAgIGlkOiBxW2lkQXR0cl0sXG4gICAgICAgIG5hbWU6IHFbbmFtZUF0dHJdXG4gICAgICB9IDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb0ZpbHRlcihyZXMpIHtcbiAgICAgIHJldHVybiBjb25kaXRpb24uZmlsdGVyID8gZmlsdGVyKHJlcywgY29uZGl0aW9uLmZpbHRlcikgOiByZXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdXNhZ2VcbiAgICogZWFjaENvbXBvbmVudCgnbGVnZW5kJywgZnVuY3Rpb24gKGxlZ2VuZE1vZGVsLCBpbmRleCkge1xuICAgKiAgICAgLi4uXG4gICAqIH0pO1xuICAgKiBlYWNoQ29tcG9uZW50KGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBtb2RlbCwgaW5kZXgpIHtcbiAgICogICAgIC8vIGNvbXBvbmVudFR5cGUgZG9lcyBub3QgaW5jbHVkZSBzdWJUeXBlXG4gICAqICAgICAvLyAoY29tcG9uZW50VHlwZSBpcyAneHh4JyBidXQgbm90ICd4eHguYWEnKVxuICAgKiB9KTtcbiAgICogZWFjaENvbXBvbmVudChcbiAgICogICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHtkYXRhWm9vbUlkOiAnYWJjJ319LFxuICAgKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkgey4uLn1cbiAgICogKTtcbiAgICogZWFjaENvbXBvbmVudChcbiAgICogICAgIHttYWluVHlwZTogJ3NlcmllcycsIHN1YlR5cGU6ICdwaWUnLCBxdWVyeToge3Nlcmllc05hbWU6ICd1aW8nfX0sXG4gICAqICAgICBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7Li4ufVxuICAgKiApO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3Q9fSBtYWluVHlwZSBXaGVuIG1haW5UeXBlIGlzIG9iamVjdCwgdGhlIGRlZmluaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdGhlIHNhbWUgYXMgdGhlIG1ldGhvZCAnZmluZENvbXBvbmVudHMnLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICovXG4gIGVhY2hDb21wb25lbnQ6IGZ1bmN0aW9uIChtYWluVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG5cbiAgICBpZiAodHlwZW9mIG1haW5UeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZXh0ID0gY2I7XG4gICAgICBjYiA9IG1haW5UeXBlO1xuICAgICAgY29tcG9uZW50c01hcC5lYWNoKGZ1bmN0aW9uIChjb21wb25lbnRzLCBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgIGVhY2goY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNvbXBvbmVudFR5cGUsIGNvbXBvbmVudCwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzU3RyaW5nKG1haW5UeXBlKSkge1xuICAgICAgZWFjaChjb21wb25lbnRzTWFwLmdldChtYWluVHlwZSksIGNiLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG1haW5UeXBlKSkge1xuICAgICAgdmFyIHF1ZXJ5UmVzdWx0ID0gdGhpcy5maW5kQ29tcG9uZW50cyhtYWluVHlwZSk7XG4gICAgICBlYWNoKHF1ZXJ5UmVzdWx0LCBjYiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICovXG4gIGdldFNlcmllc0J5TmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpO1xuXG4gICAgcmV0dXJuIGZpbHRlcihzZXJpZXMsIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgIHJldHVybiBvbmVTZXJpZXMubmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc31cbiAgICovXG4gIGdldFNlcmllc0J5SW5kZXg6IGZ1bmN0aW9uIChzZXJpZXNJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJylbc2VyaWVzSW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViVHlwZVxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICovXG4gIGdldFNlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUpIHtcbiAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpO1xuXG4gICAgcmV0dXJuIGZpbHRlcihzZXJpZXMsIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgIHJldHVybiBvbmVTZXJpZXMuc3ViVHlwZSA9PT0gc3ViVHlwZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59XG4gICAqL1xuICBnZXRTZXJpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpLnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFmdGVyIGZpbHRlcmluZywgc2VyaWVzIG1heSBiZSBkaWZmZXJlbnRcbiAgICogZnJvbWUgcmF3IHNlcmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBlYWNoU2VyaWVzOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKVtyYXdTZXJpZXNJbmRleF07XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgc2VyaWVzLCByYXdTZXJpZXNJbmRleCk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgcmF3IHNlcmllcyBiZWZvcmUgZmlsdGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgKi9cbiAgZWFjaFJhd1NlcmllczogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZWFjaCh0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyksIGNiLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgZmlsdGVyaW5nLCBzZXJpZXMgbWF5IGJlIGRpZmZlcmVudC5cbiAgICogZnJvbWUgcmF3IHNlcmllcy5cbiAgICpcbiAgICogQHBhcm1hIHtzdHJpbmd9IHN1YlR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBlYWNoU2VyaWVzQnlUeXBlOiBmdW5jdGlvbiAoc3ViVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKVtyYXdTZXJpZXNJbmRleF07XG5cbiAgICAgIGlmIChzZXJpZXMuc3ViVHlwZSA9PT0gc3ViVHlwZSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHNlcmllcywgcmF3U2VyaWVzSW5kZXgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHJhdyBzZXJpZXMgYmVmb3JlIGZpbHRlcmVkIG9mIGdpdmVuIHR5cGUuXG4gICAqXG4gICAqIEBwYXJtYSB7c3RyaW5nfSBzdWJUeXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgKi9cbiAgZWFjaFJhd1Nlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGVhY2godGhpcy5nZXRTZXJpZXNCeVR5cGUoc3ViVHlwZSksIGNiLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAqL1xuICBpc1Nlcmllc0ZpbHRlcmVkOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICByZXR1cm4genJVdGlsLmluZGV4T2YodGhpcy5fc2VyaWVzSW5kaWNlcywgc2VyaWVzTW9kZWwuY29tcG9uZW50SW5kZXgpIDwgMDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBnZXRDdXJyZW50U2VyaWVzSW5kaWNlczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fc2VyaWVzSW5kaWNlcyB8fCBbXSkuc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBmaWx0ZXJTZXJpZXM6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgIHZhciBmaWx0ZXJlZFNlcmllcyA9IGZpbHRlcih0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyksIGNiLCBjb250ZXh0KTtcbiAgICB0aGlzLl9zZXJpZXNJbmRpY2VzID0gY3JlYXRlU2VyaWVzSW5kaWNlcyhmaWx0ZXJlZFNlcmllcyk7XG4gIH0sXG4gIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXBvbmVudHNNYXAgPSB0aGlzLl9jb21wb25lbnRzTWFwO1xuICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSBjcmVhdGVTZXJpZXNJbmRpY2VzKGNvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSk7XG4gICAgdmFyIGNvbXBvbmVudFR5cGVzID0gW107XG4gICAgY29tcG9uZW50c01hcC5lYWNoKGZ1bmN0aW9uIChjb21wb25lbnRzLCBjb21wb25lbnRUeXBlKSB7XG4gICAgICBjb21wb25lbnRUeXBlcy5wdXNoKGNvbXBvbmVudFR5cGUpO1xuICAgIH0pO1xuICAgIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsKGNvbXBvbmVudFR5cGVzLCBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcygpLCBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICBlYWNoKGNvbXBvbmVudHNNYXAuZ2V0KGNvbXBvbmVudFR5cGUpLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIGNvbXBvbmVudC5yZXN0b3JlRGF0YSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZVRoZW1lKG9wdGlvbiwgdGhlbWUpIHtcbiAgenJVdGlsLmVhY2godGhlbWUsIGZ1bmN0aW9uICh0aGVtZUl0ZW0sIG5hbWUpIHtcbiAgICAvLyDlpoLmnpzmnIkgY29tcG9uZW50IG1vZGVsIOWImeaKiuWFt+S9k+eahCBtZXJnZSDpgLvovpHkuqTnu5nor6UgbW9kZWwg5aSE55CGXG4gICAgaWYgKCFDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhuYW1lKSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGVtZUl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbltuYW1lXSA9ICFvcHRpb25bbmFtZV0gPyB6clV0aWwuY2xvbmUodGhlbWVJdGVtKSA6IHpyVXRpbC5tZXJnZShvcHRpb25bbmFtZV0sIHRoZW1lSXRlbSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9uW25hbWVdID0gdGhlbWVJdGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdEJhc2UoYmFzZU9wdGlvbikge1xuICBiYXNlT3B0aW9uID0gYmFzZU9wdGlvbjsgLy8gVXNpbmcgT1BUSU9OX0lOTkVSX0tFWSB0byBtYXJrIHRoYXQgdGhpcyBvcHRpb24gY2FuIG5vdCBiZSB1c2VkIG91dHNpZGUsXG4gIC8vIGkuZS4gYGNoYXJ0LnNldE9wdGlvbihjaGFydC5nZXRNb2RlbCgpLm9wdGlvbik7YCBpcyBmb3JiaWRlbi5cblxuICB0aGlzLm9wdGlvbiA9IHt9O1xuICB0aGlzLm9wdGlvbltPUFRJT05fSU5ORVJfS0VZXSA9IDE7XG4gIC8qKlxuICAgKiBJbml0IHdpdGggc2VyaWVzOiBbXSwgaW4gY2FzZSBvZiBjYWxsaW5nIGZpbmRTZXJpZXMgbWV0aG9kXG4gICAqIGJlZm9yZSBzZXJpZXMgaW5pdGlhbGl6ZWQuXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2NvbXBvbmVudHNNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCh7XG4gICAgc2VyaWVzOiBbXVxuICB9KTtcbiAgLyoqXG4gICAqIE1hcHBpbmcgYmV0d2VlbiBmaWx0ZXJlZCBzZXJpZXMgbGlzdCBhbmQgcmF3IHNlcmllcyBsaXN0LlxuICAgKiBrZXk6IGZpbHRlcmVkIHNlcmllcyBpbmRpY2VzLCB2YWx1ZTogcmF3IHNlcmllcyBpbmRpY2VzLlxuICAgKiBAdHlwZSB7QXJyYXkuPG51Ym1lcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3Nlcmllc0luZGljZXMgPSBudWxsO1xuICBtZXJnZVRoZW1lKGJhc2VPcHRpb24sIHRoaXMuX3RoZW1lLm9wdGlvbik7IC8vIFRPRE8gTmVlZHMgY2xvbmUgd2hlbiBtZXJnaW5nIHRvIHRoZSB1bmV4aXN0ZWQgcHJvcGVydHlcblxuICB6clV0aWwubWVyZ2UoYmFzZU9wdGlvbiwgZ2xvYmFsRGVmYXVsdCwgZmFsc2UpO1xuICB0aGlzLm1lcmdlT3B0aW9uKGJhc2VPcHRpb24pO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSB0eXBlcyBtb2RlbCB0eXBlc1xuICogQHJldHVybiB7T2JqZWN0fSBrZXk6IHtzdHJpbmd9IHR5cGUsIHZhbHVlOiB7QXJyYXkuPE9iamVjdD59IG1vZGVsc1xuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50c0J5VHlwZXMoY29tcG9uZW50c01hcCwgdHlwZXMpIHtcbiAgaWYgKCF6clV0aWwuaXNBcnJheSh0eXBlcykpIHtcbiAgICB0eXBlcyA9IHR5cGVzID8gW3R5cGVzXSA6IFtdO1xuICB9XG5cbiAgdmFyIHJldCA9IHt9O1xuICBlYWNoKHR5cGVzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldFt0eXBlXSA9IChjb21wb25lbnRzTWFwLmdldCh0eXBlKSB8fCBbXSkuc2xpY2UoKTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZGV0ZXJtaW5lU3ViVHlwZShtYWluVHlwZSwgbmV3Q3B0T3B0aW9uLCBleGlzdENvbXBvbmVudCkge1xuICB2YXIgc3ViVHlwZSA9IG5ld0NwdE9wdGlvbi50eXBlID8gbmV3Q3B0T3B0aW9uLnR5cGUgOiBleGlzdENvbXBvbmVudCA/IGV4aXN0Q29tcG9uZW50LnN1YlR5cGUgLy8gVXNlIGRldGVybWluZVN1YlR5cGUgb25seSB3aGVuIHRoZXJlIGlzIG5vIGV4aXN0Q29tcG9uZW50LlxuICA6IENvbXBvbmVudE1vZGVsLmRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbik7IC8vIHRvb2x0aXAsIG1hcmtsaW5lLCBtYXJrcG9pbnQgbWF5IGFsd2F5cyBoYXMgbm8gc3ViVHlwZVxuXG4gIHJldHVybiBzdWJUeXBlO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcmllc0luZGljZXMoc2VyaWVzTW9kZWxzKSB7XG4gIHJldHVybiBtYXAoc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgcmV0dXJuIHNlcmllcy5jb21wb25lbnRJbmRleDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZmlsdGVyQnlTdWJUeXBlKGNvbXBvbmVudHMsIGNvbmRpdGlvbikge1xuICAvLyBVc2luZyBoYXNPd25Qcm9wZXJ0eSBmb3IgcmVzdHJpY3QuIENvbnNpZGVyXG4gIC8vIHN1YlR5cGUgaXMgdW5kZWZpbmVkIGluIHVzZXIgcGF5bG9hZC5cbiAgcmV0dXJuIGNvbmRpdGlvbi5oYXNPd25Qcm9wZXJ0eSgnc3ViVHlwZScpID8gZmlsdGVyKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICByZXR1cm4gY3B0LnN1YlR5cGUgPT09IGNvbmRpdGlvbi5zdWJUeXBlO1xuICB9KSA6IGNvbXBvbmVudHM7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQoZWNNb2RlbCkge31cblxuenJVdGlsLm1peGluKEdsb2JhbE1vZGVsLCBjb2xvclBhbGV0dGVNaW5pbik7XG52YXIgX2RlZmF1bHQgPSBHbG9iYWxNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvR2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9HbG9iYWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2VudlwiKTtcblxudmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2NsYXp6XCIpO1xuXG52YXIgbGluZVN0eWxlTWl4aW4gPSByZXF1aXJlKFwiLi9taXhpbi9saW5lU3R5bGVcIik7XG5cbnZhciBhcmVhU3R5bGVNaXhpbiA9IHJlcXVpcmUoXCIuL21peGluL2FyZWFTdHlsZVwiKTtcblxudmFyIHRleHRTdHlsZU1peGluID0gcmVxdWlyZShcIi4vbWl4aW4vdGV4dFN0eWxlXCIpO1xuXG52YXIgaXRlbVN0eWxlTWl4aW4gPSByZXF1aXJlKFwiLi9taXhpbi9pdGVtU3R5bGVcIik7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL21vZGVsL01vZGVsXG4gKi9cbnZhciBtaXhpbiA9IHpyVXRpbC5taXhpbjtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtwYXJlbnRNb2RlbF1cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBbZWNNb2RlbF1cbiAqL1xuXG5mdW5jdGlvbiBNb2RlbChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgdGhpcy5wYXJlbnRNb2RlbCA9IHBhcmVudE1vZGVsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuXG4gIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG4gIHRoaXMub3B0aW9uID0gb3B0aW9uOyAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gIC8vIGlmICh0aGlzLmluaXQpIHtcbiAgLy8gICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDQpIHtcbiAgLy8gICAgICAgICB0aGlzLmluaXQob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpO1xuICAvLyAgICAgfVxuICAvLyAgICAgZWxzZSB7XG4gIC8vICAgICAgICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIC8vICAgICB9XG4gIC8vIH1cbn1cblxuTW9kZWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTW9kZWwsXG5cbiAgLyoqXG4gICAqIE1vZGVsIOeahOWIneWni+WMluWHveaVsFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gICAqL1xuICBpbml0OiBudWxsLFxuXG4gIC8qKlxuICAgKiDku47mlrDnmoQgT3B0aW9uIG1lcmdlXG4gICAqL1xuICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgb3B0aW9uLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlUGFyZW50PWZhbHNlXVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgaWdub3JlUGFyZW50KSB7XG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBkb0dldCh0aGlzLm9wdGlvbiwgdGhpcy5wYXJzZVBhdGgocGF0aCksICFpZ25vcmVQYXJlbnQgJiYgZ2V0UGFyZW50KHRoaXMsIHBhdGgpKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVQYXJlbnQ9ZmFsc2VdXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXRTaGFsbG93OiBmdW5jdGlvbiAoa2V5LCBpZ25vcmVQYXJlbnQpIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIHZhbCA9IG9wdGlvbiA9PSBudWxsID8gb3B0aW9uIDogb3B0aW9uW2tleV07XG4gICAgdmFyIHBhcmVudE1vZGVsID0gIWlnbm9yZVBhcmVudCAmJiBnZXRQYXJlbnQodGhpcywga2V5KTtcblxuICAgIGlmICh2YWwgPT0gbnVsbCAmJiBwYXJlbnRNb2RlbCkge1xuICAgICAgdmFsID0gcGFyZW50TW9kZWwuZ2V0U2hhbGxvdyhrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbcGF0aF1cbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3BhcmVudE1vZGVsXVxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICovXG4gIGdldE1vZGVsOiBmdW5jdGlvbiAocGF0aCwgcGFyZW50TW9kZWwpIHtcbiAgICB2YXIgb2JqID0gcGF0aCA9PSBudWxsID8gdGhpcy5vcHRpb24gOiBkb0dldCh0aGlzLm9wdGlvbiwgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpKTtcbiAgICB2YXIgdGhpc1BhcmVudE1vZGVsO1xuICAgIHBhcmVudE1vZGVsID0gcGFyZW50TW9kZWwgfHwgKHRoaXNQYXJlbnRNb2RlbCA9IGdldFBhcmVudCh0aGlzLCBwYXRoKSkgJiYgdGhpc1BhcmVudE1vZGVsLmdldE1vZGVsKHBhdGgpO1xuICAgIHJldHVybiBuZXcgTW9kZWwob2JqLCBwYXJlbnRNb2RlbCwgdGhpcy5lY01vZGVsKTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgbW9kZWwgaGFzIG9wdGlvblxuICAgKi9cbiAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbiA9PSBudWxsO1xuICB9LFxuICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXG4gIC8vIFBlbmRpbmdcbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgQ3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG5ldyBDdG9yKHpyVXRpbC5jbG9uZSh0aGlzLm9wdGlvbikpO1xuICB9LFxuICBzZXRSZWFkT25seTogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICBjbGF6elV0aWwuc2V0UmVhZE9ubHkodGhpcywgcHJvcGVydGllcyk7XG4gIH0sXG4gIC8vIElmIHBhdGggaXMgbnVsbC91bmRlZmluZWQsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAgcGFyc2VQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldFBhcmVudE1ldGhvZFxuICAgKiAgICAgICAgcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gcGF0aFxuICAgKiAgICAgICAgcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICovXG4gIGN1c3RvbWl6ZUdldFBhcmVudDogZnVuY3Rpb24gKGdldFBhcmVudE1ldGhvZCkge1xuICAgIGNsYXp6VXRpbC5zZXQodGhpcywgJ2dldFBhcmVudCcsIGdldFBhcmVudE1ldGhvZCk7XG4gIH0sXG4gIGlzQW5pbWF0aW9uRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZW52Lm5vZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbi5hbmltYXRpb24gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLm9wdGlvbi5hbmltYXRpb247XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50TW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBkb0dldChvYmosIHBhdGhBcnIsIHBhcmVudE1vZGVsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEFyci5sZW5ndGg7IGkrKykge1xuICAgIC8vIElnbm9yZSBlbXB0eVxuICAgIGlmICghcGF0aEFycltpXSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBvYmogY291bGQgYmUgbnVtYmVyL3N0cmluZy8uLi4gKGxpa2UgMClcblxuXG4gICAgb2JqID0gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnID8gb2JqW3BhdGhBcnJbaV1dIDogbnVsbDtcblxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9iaiA9PSBudWxsICYmIHBhcmVudE1vZGVsKSB7XG4gICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGhBcnIpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0gLy8gYHBhdGhgIGNhbiBiZSBudWxsL3VuZGVmaW5lZFxuXG5cbmZ1bmN0aW9uIGdldFBhcmVudChtb2RlbCwgcGF0aCkge1xuICB2YXIgZ2V0UGFyZW50TWV0aG9kID0gY2xhenpVdGlsLmdldChtb2RlbCwgJ2dldFBhcmVudCcpO1xuICByZXR1cm4gZ2V0UGFyZW50TWV0aG9kID8gZ2V0UGFyZW50TWV0aG9kLmNhbGwobW9kZWwsIHBhdGgpIDogbW9kZWwucGFyZW50TW9kZWw7XG59IC8vIEVuYWJsZSBNb2RlbC5leHRlbmQuXG5cblxuY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcbm1peGluKE1vZGVsLCBsaW5lU3R5bGVNaXhpbik7XG5taXhpbihNb2RlbCwgYXJlYVN0eWxlTWl4aW4pO1xubWl4aW4oTW9kZWwsIHRleHRTdHlsZU1peGluKTtcbm1peGluKE1vZGVsLCBpdGVtU3R5bGVNaXhpbik7XG52YXIgX2RlZmF1bHQgPSBNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL01vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZShcIi4vQ29tcG9uZW50XCIpO1xuXG4vKipcbiAqIEVDaGFydHMgb3B0aW9uIG1hbmFnZXJcbiAqXG4gKiBAbW9kdWxlIHtlY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXJ9XG4gKi9cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG52YXIgbWFwID0genJVdGlsLm1hcDtcbnZhciBtZXJnZSA9IHpyVXRpbC5tZXJnZTtcbnZhciBRVUVSWV9SRUcgPSAvXihtaW58bWF4KT8oLispJC87XG4vKipcbiAqIFRFUk0gRVhQTEFOQVRJT05TOlxuICpcbiAqIFtvcHRpb25dOlxuICpcbiAqICAgICBBbiBvYmplY3QgdGhhdCBjb250YWlucyBkZWZpbml0aW9ucyBvZiBjb21wb25lbnRzLiBGb3IgZXhhbXBsZTpcbiAqICAgICB2YXIgb3B0aW9uID0ge1xuICogICAgICAgICB0aXRsZTogey4uLn0sXG4gKiAgICAgICAgIGxlZ2VuZDogey4uLn0sXG4gKiAgICAgICAgIHZpc3VhbE1hcDogey4uLn0sXG4gKiAgICAgICAgIHNlcmllczogW1xuICogICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAqICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gKiAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgXVxuICogICAgIH07XG4gKlxuICogW3Jhd09wdGlvbl06XG4gKlxuICogICAgIEFuIG9iamVjdCBpbnB1dCB0byBlY2hhcnRzLnNldE9wdGlvbi4gJ3Jhd09wdGlvbicgbWF5IGJlIGFuXG4gKiAgICAgJ29wdGlvbicsIG9yIG1heSBiZSBhbiBvYmplY3QgY29udGFpbnMgbXVsdGktb3B0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKiAgICAgdmFyIG9wdGlvbiA9IHtcbiAqICAgICAgICAgYmFzZU9wdGlvbjoge1xuICogICAgICAgICAgICAgdGl0bGU6IHsuLi59LFxuICogICAgICAgICAgICAgbGVnZW5kOiB7Li4ufSxcbiAqICAgICAgICAgICAgIHNlcmllczogW1xuICogICAgICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gKiAgICAgICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAqICAgICAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgICAgIF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgdGltZWxpbmU6IHsuLi59LFxuICogICAgICAgICBvcHRpb25zOiBbXG4gKiAgICAgICAgICAgICB7dGl0bGU6IHsuLi59LCBzZXJpZXM6IHtkYXRhOiBbLi4uXX19LFxuICogICAgICAgICAgICAge3RpdGxlOiB7Li4ufSwgc2VyaWVzOiB7ZGF0YTogWy4uLl19fSxcbiAqICAgICAgICAgICAgIC4uLlxuICogICAgICAgICBdLFxuICogICAgICAgICBtZWRpYTogW1xuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIHF1ZXJ5OiB7bWF4V2lkdGg6IDMyMH0sXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogMjB9LCB2aXN1YWxNYXA6IHtzaG93OiBmYWxzZX19XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIHF1ZXJ5OiB7bWluV2lkdGg6IDMyMCwgbWF4V2lkdGg6IDcyMH0sXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogNTAwfSwgdmlzdWFsTWFwOiB7c2hvdzogdHJ1ZX19XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIG9wdGlvbjoge3Nlcmllczoge3g6IDEyMDB9LCB2aXN1YWxNYXA6IHtzaG93OiB0cnVlfX1cbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgXVxuICogICAgIH07XG4gKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqL1xuXG5mdW5jdGlvbiBPcHRpb25NYW5hZ2VyKGFwaSkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAgICovXG4gIHRoaXMuX2FwaSA9IGFwaTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cbiAgdGhpcy5fdGltZWxpbmVPcHRpb25zID0gW107XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAqL1xuXG4gIHRoaXMuX21lZGlhTGlzdCA9IFtdO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5fbWVkaWFEZWZhdWx0O1xuICAvKipcbiAgICogLTEsIG1lYW5zIGRlZmF1bHQuXG4gICAqIGVtcHR5IG1lYW5zIG5vIG1lZGlhLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuXG4gIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBbXTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX29wdGlvbkJhY2t1cDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX25ld0Jhc2VPcHRpb247XG59IC8vIHRpbWVsaW5lLm5vdE1lcmdlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZWMzLiBGaXJzdGx5IHRoZXJlIGlzIHJlYXJseVxuLy8gY2FzZSB0aGF0IG5vdE1lcmdlIGlzIG5lZWRlZC4gU2Vjb25kbHkgc3VwcG9ydGluZyAnbm90TWVyZ2UnIHJlcXVpcmVzXG4vLyByYXdPcHRpb24gY2xvbmVkIGFuZCBiYWNrdXBlZCB3aGVuIHRpbWVsaW5lIGNoYW5nZWQsIHdoaWNoIGRvZXMgbm9cbi8vIGdvb2QgdG8gcGVyZm9ybWFuY2UuIFdoYXQncyBtb3JlLCB0aGF0IGJvdGggdGltZWxpbmUgYW5kIHNldE9wdGlvblxuLy8gbWV0aG9kIHN1cHBseSAnbm90TWVyZ2UnIGJyaW5ncyBjb21wbGV4IGFuZCBzb21lIHByb2JsZW1zLlxuLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxuLy8gKHN0ZXAxKSBjaGFydC5zZXRPcHRpb24oe3RpbWVsaW5lOiB7bm90TWVyZ2U6IGZhbHNlfSwgLi4ufSwgZmFsc2UpO1xuLy8gKHN0ZXAyKSBjaGFydC5zZXRPcHRpb24oe3RpbWVsaW5lOiB7bm90TWVyZ2U6IHRydWV9LCAuLi59LCBmYWxzZSk7XG5cblxuT3B0aW9uTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBPcHRpb25NYW5hZ2VyLFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByYXdPcHRpb24gUmF3IG9wdGlvbi5cbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtIHtBcnJheS48RnVuY3Rpb24+fSBvcHRpb25QcmVwcm9jZXNzb3JGdW5jc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEluaXQgb3B0aW9uXG4gICAqL1xuICBzZXRPcHRpb246IGZ1bmN0aW9uIChyYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgcmF3T3B0aW9uID0gY2xvbmUocmF3T3B0aW9uLCB0cnVlKTsgLy8gRklYTUVcbiAgICAvLyDlpoLmnpwgdGltZWxpbmUgb3B0aW9ucyDmiJbogIUgbWVkaWEg5Lit6K6+572u5LqG5p+Q5Liq5bGe5oCn77yM6ICMYmFzZU9wdGlvbuS4reayoeacieiuvue9ru+8jOWImei/m+ihjOitpuWRiuOAglxuXG4gICAgdmFyIG9sZE9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDtcbiAgICB2YXIgbmV3UGFyc2VkT3B0aW9uID0gcGFyc2VSYXdPcHRpb24uY2FsbCh0aGlzLCByYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCAhb2xkT3B0aW9uQmFja3VwKTtcbiAgICB0aGlzLl9uZXdCYXNlT3B0aW9uID0gbmV3UGFyc2VkT3B0aW9uLmJhc2VPcHRpb247IC8vIEZvciBzZXRPcHRpb24gYXQgc2Vjb25kIHRpbWUgKHVzaW5nIG1lcmdlIG1vZGUpO1xuXG4gICAgaWYgKG9sZE9wdGlvbkJhY2t1cCkge1xuICAgICAgLy8gT25seSBiYXNlT3B0aW9uIGNhbiBiZSBtZXJnZWQuXG4gICAgICBtZXJnZU9wdGlvbihvbGRPcHRpb25CYWNrdXAuYmFzZU9wdGlvbiwgbmV3UGFyc2VkT3B0aW9uLmJhc2VPcHRpb24pOyAvLyBGb3Igc2ltcGxpY2l0eSwgdGltZWxpbmUgb3B0aW9ucyBhbmQgbWVkaWEgb3B0aW9ucyBkbyBub3Qgc3VwcG9ydCBtZXJnZSxcbiAgICAgIC8vIHRoYXQgaXMsIGlmIHlvdSBgc2V0T3B0aW9uYCB0d2ljZSBhbmQgYm90aCBoYXMgdGltZWxpbmUgb3B0aW9ucywgdGhlIGxhdHRlclxuICAgICAgLy8gdGltZWxpbmUgb3BpdG9ucyB3aWxsIG5vdCBiZSBtZXJnZWQgdG8gdGhlIGZvcm1lcnMsIGJ1dCBqdXN0IHN1YnN0aXR1ZGUgdGhlbS5cblxuICAgICAgaWYgKG5ld1BhcnNlZE9wdGlvbi50aW1lbGluZU9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIG9sZE9wdGlvbkJhY2t1cC50aW1lbGluZU9wdGlvbnMgPSBuZXdQYXJzZWRPcHRpb24udGltZWxpbmVPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3UGFyc2VkT3B0aW9uLm1lZGlhTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgb2xkT3B0aW9uQmFja3VwLm1lZGlhTGlzdCA9IG5ld1BhcnNlZE9wdGlvbi5tZWRpYUxpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24ubWVkaWFEZWZhdWx0KSB7XG4gICAgICAgIG9sZE9wdGlvbkJhY2t1cC5tZWRpYURlZmF1bHQgPSBuZXdQYXJzZWRPcHRpb24ubWVkaWFEZWZhdWx0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcHRpb25CYWNrdXAgPSBuZXdQYXJzZWRPcHRpb247XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmVjcmVhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgbW91bnRPcHRpb246IGZ1bmN0aW9uIChpc1JlY3JlYXRlKSB7XG4gICAgdmFyIG9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDsgLy8gVE9ET1xuICAgIC8vIOWmguaenOayoeaciXJlc2V05Yqf6IO95YiZ5LiNY2xvbmXjgIJcblxuICAgIHRoaXMuX3RpbWVsaW5lT3B0aW9ucyA9IG1hcChvcHRpb25CYWNrdXAudGltZWxpbmVPcHRpb25zLCBjbG9uZSk7XG4gICAgdGhpcy5fbWVkaWFMaXN0ID0gbWFwKG9wdGlvbkJhY2t1cC5tZWRpYUxpc3QsIGNsb25lKTtcbiAgICB0aGlzLl9tZWRpYURlZmF1bHQgPSBjbG9uZShvcHRpb25CYWNrdXAubWVkaWFEZWZhdWx0KTtcbiAgICB0aGlzLl9jdXJyZW50TWVkaWFJbmRpY2VzID0gW107XG4gICAgcmV0dXJuIGNsb25lKGlzUmVjcmVhdGUgLy8gdGhpcy5fb3B0aW9uQmFja3VwLmJhc2VPcHRpb24sIHdoaWNoIGlzIGNyZWF0ZWQgYXQgdGhlIGZpcnN0IGBzZXRPcHRpb25gXG4gICAgLy8gY2FsbGVkLCBhbmQgaXMgbWVyZ2VkIGludG8gZXZlcnkgbmV3IG9wdGlvbiBieSBpbm5lciBtZXRob2QgYG1lcmdlT3B0aW9uYFxuICAgIC8vIGVhY2ggdGltZSBgc2V0T3B0aW9uYCBjYWxsZWQsIGNhbiBiZSBvbmx5IHVzZWQgaW4gYGlzUmVjcmVhdGVgLCBiZWNhdXNlXG4gICAgLy8gaXRzIHJlbGlhYmlsaXR5IGlzIHVuZGVyIHN1c3BpY2lvbi4gSW4gb3RoZXIgY2FzZXMgb3B0aW9uIG1lcmdlIGlzXG4gICAgLy8gcGVyZm9ybWVkIGJ5IGBtb2RlbC5tZXJnZU9wdGlvbmAuXG4gICAgPyBvcHRpb25CYWNrdXAuYmFzZU9wdGlvbiA6IHRoaXMuX25ld0Jhc2VPcHRpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRUaW1lbGluZU9wdGlvbjogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgb3B0aW9uO1xuICAgIHZhciB0aW1lbGluZU9wdGlvbnMgPSB0aGlzLl90aW1lbGluZU9wdGlvbnM7XG5cbiAgICBpZiAodGltZWxpbmVPcHRpb25zLmxlbmd0aCkge1xuICAgICAgLy8gZ2V0VGltZWxpbmVPcHRpb24gY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGVjTW9kZWwgaW5pdGVkLFxuICAgICAgLy8gc28gd2UgY2FuIGdldCBjdXJyZW50SW5kZXggZnJvbSB0aW1lbGluZU1vZGVsLlxuICAgICAgdmFyIHRpbWVsaW5lTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgndGltZWxpbmUnKTtcblxuICAgICAgaWYgKHRpbWVsaW5lTW9kZWwpIHtcbiAgICAgICAgb3B0aW9uID0gY2xvbmUodGltZWxpbmVPcHRpb25zW3RpbWVsaW5lTW9kZWwuZ2V0Q3VycmVudEluZGV4KCldLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn1cbiAgICovXG4gIGdldE1lZGlhT3B0aW9uOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBlY1dpZHRoID0gdGhpcy5fYXBpLmdldFdpZHRoKCk7XG5cbiAgICB2YXIgZWNIZWlnaHQgPSB0aGlzLl9hcGkuZ2V0SGVpZ2h0KCk7XG5cbiAgICB2YXIgbWVkaWFMaXN0ID0gdGhpcy5fbWVkaWFMaXN0O1xuICAgIHZhciBtZWRpYURlZmF1bHQgPSB0aGlzLl9tZWRpYURlZmF1bHQ7XG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107IC8vIE5vIG1lZGlhIGRlZmluZWQuXG5cbiAgICBpZiAoIW1lZGlhTGlzdC5sZW5ndGggJiYgIW1lZGlhRGVmYXVsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IC8vIE11bHRpIG1lZGlhIG1heSBiZSBhcHBsaWVkLCB0aGUgbGF0dGVyIGRlZmluZWQgbWVkaWEgaGFzIGhpZ2hlciBwcmlvcml0eS5cblxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1lZGlhTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGFwcGx5TWVkaWFRdWVyeShtZWRpYUxpc3RbaV0ucXVlcnksIGVjV2lkdGgsIGVjSGVpZ2h0KSkge1xuICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfSAvLyBGSVhNRVxuICAgIC8vIOaYr+WQpm1lZGlhRGVmYXVsdOW6lOivpeW8uuWItueUqOaIt+iuvue9ru+8jOWQpuWImeWPr+iDveS/ruaUueS4jeiDveWbnuW9kuOAglxuXG5cbiAgICBpZiAoIWluZGljZXMubGVuZ3RoICYmIG1lZGlhRGVmYXVsdCkge1xuICAgICAgaW5kaWNlcyA9IFstMV07XG4gICAgfVxuXG4gICAgaWYgKGluZGljZXMubGVuZ3RoICYmICFpbmRpY2VzRXF1YWxzKGluZGljZXMsIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMpKSB7XG4gICAgICByZXN1bHQgPSBtYXAoaW5kaWNlcywgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBjbG9uZShpbmRleCA9PT0gLTEgPyBtZWRpYURlZmF1bHQub3B0aW9uIDogbWVkaWFMaXN0W2luZGV4XS5vcHRpb24pO1xuICAgICAgfSk7XG4gICAgfSAvLyBPdGhlcndpc2UgcmV0dXJuIG5vdGhpbmcuXG5cblxuICAgIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBpbmRpY2VzO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhcnNlUmF3T3B0aW9uKHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsIGlzTmV3KSB7XG4gIHZhciB0aW1lbGluZU9wdGlvbnMgPSBbXTtcbiAgdmFyIG1lZGlhTGlzdCA9IFtdO1xuICB2YXIgbWVkaWFEZWZhdWx0O1xuICB2YXIgYmFzZU9wdGlvbjsgLy8gQ29tcGF0aWJsZSB3aXRoIGVjMi5cblxuICB2YXIgdGltZWxpbmVPcHQgPSByYXdPcHRpb24udGltZWxpbmU7XG5cbiAgaWYgKHJhd09wdGlvbi5iYXNlT3B0aW9uKSB7XG4gICAgYmFzZU9wdGlvbiA9IHJhd09wdGlvbi5iYXNlT3B0aW9uO1xuICB9IC8vIEZvciB0aW1lbGluZVxuXG5cbiAgaWYgKHRpbWVsaW5lT3B0IHx8IHJhd09wdGlvbi5vcHRpb25zKSB7XG4gICAgYmFzZU9wdGlvbiA9IGJhc2VPcHRpb24gfHwge307XG4gICAgdGltZWxpbmVPcHRpb25zID0gKHJhd09wdGlvbi5vcHRpb25zIHx8IFtdKS5zbGljZSgpO1xuICB9IC8vIEZvciBtZWRpYSBxdWVyeVxuXG5cbiAgaWYgKHJhd09wdGlvbi5tZWRpYSkge1xuICAgIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uIHx8IHt9O1xuICAgIHZhciBtZWRpYSA9IHJhd09wdGlvbi5tZWRpYTtcbiAgICBlYWNoKG1lZGlhLCBmdW5jdGlvbiAoc2luZ2xlTWVkaWEpIHtcbiAgICAgIGlmIChzaW5nbGVNZWRpYSAmJiBzaW5nbGVNZWRpYS5vcHRpb24pIHtcbiAgICAgICAgaWYgKHNpbmdsZU1lZGlhLnF1ZXJ5KSB7XG4gICAgICAgICAgbWVkaWFMaXN0LnB1c2goc2luZ2xlTWVkaWEpO1xuICAgICAgICB9IGVsc2UgaWYgKCFtZWRpYURlZmF1bHQpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IG1lZGlhIGRlZmF1bHQuXG4gICAgICAgICAgbWVkaWFEZWZhdWx0ID0gc2luZ2xlTWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBGb3Igbm9ybWFsIG9wdGlvblxuXG5cbiAgaWYgKCFiYXNlT3B0aW9uKSB7XG4gICAgYmFzZU9wdGlvbiA9IHJhd09wdGlvbjtcbiAgfSAvLyBTZXQgdGltZWxpbmVPcHQgdG8gYmFzZU9wdGlvbiBpbiBlYzMsXG4gIC8vIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yIG1lcmdlIG9wdGlvbi5cblxuXG4gIGlmICghYmFzZU9wdGlvbi50aW1lbGluZSkge1xuICAgIGJhc2VPcHRpb24udGltZWxpbmUgPSB0aW1lbGluZU9wdDtcbiAgfSAvLyBQcmVwcm9jZXNzLlxuXG5cbiAgZWFjaChbYmFzZU9wdGlvbl0uY29uY2F0KHRpbWVsaW5lT3B0aW9ucykuY29uY2F0KHpyVXRpbC5tYXAobWVkaWFMaXN0LCBmdW5jdGlvbiAobWVkaWEpIHtcbiAgICByZXR1cm4gbWVkaWEub3B0aW9uO1xuICB9KSksIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBlYWNoKG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCBmdW5jdGlvbiAocHJlUHJvY2Vzcykge1xuICAgICAgcHJlUHJvY2VzcyhvcHRpb24sIGlzTmV3KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYmFzZU9wdGlvbjogYmFzZU9wdGlvbixcbiAgICB0aW1lbGluZU9wdGlvbnM6IHRpbWVsaW5lT3B0aW9ucyxcbiAgICBtZWRpYURlZmF1bHQ6IG1lZGlhRGVmYXVsdCxcbiAgICBtZWRpYUxpc3Q6IG1lZGlhTGlzdFxuICB9O1xufVxuLyoqXG4gKiBAc2VlIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLW1lZGlhcXVlcmllcy8jbWVkaWExPlxuICogU3VwcG9ydDogd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW9cbiAqIENhbiB1c2UgbWF4IG9yIG1pbiBhcyBwcmVmaXguXG4gKi9cblxuXG5mdW5jdGlvbiBhcHBseU1lZGlhUXVlcnkocXVlcnksIGVjV2lkdGgsIGVjSGVpZ2h0KSB7XG4gIHZhciByZWFsTWFwID0ge1xuICAgIHdpZHRoOiBlY1dpZHRoLFxuICAgIGhlaWdodDogZWNIZWlnaHQsXG4gICAgYXNwZWN0cmF0aW86IGVjV2lkdGggLyBlY0hlaWdodCAvLyBsb3dzZXIgY2FzZSBmb3IgY29udmVuaWVudGNlLlxuXG4gIH07XG4gIHZhciBhcHBsaWNhdGFibGUgPSB0cnVlO1xuICB6clV0aWwuZWFjaChxdWVyeSwgZnVuY3Rpb24gKHZhbHVlLCBhdHRyKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBhdHRyLm1hdGNoKFFVRVJZX1JFRyk7XG5cbiAgICBpZiAoIW1hdGNoZWQgfHwgIW1hdGNoZWRbMV0gfHwgIW1hdGNoZWRbMl0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3BlcmF0b3IgPSBtYXRjaGVkWzFdO1xuICAgIHZhciByZWFsQXR0ciA9IG1hdGNoZWRbMl0udG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICghY29tcGFyZShyZWFsTWFwW3JlYWxBdHRyXSwgdmFsdWUsIG9wZXJhdG9yKSkge1xuICAgICAgYXBwbGljYXRhYmxlID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFwcGxpY2F0YWJsZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZShyZWFsLCBleHBlY3QsIG9wZXJhdG9yKSB7XG4gIGlmIChvcGVyYXRvciA9PT0gJ21pbicpIHtcbiAgICByZXR1cm4gcmVhbCA+PSBleHBlY3Q7XG4gIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdtYXgnKSB7XG4gICAgcmV0dXJuIHJlYWwgPD0gZXhwZWN0O1xuICB9IGVsc2Uge1xuICAgIC8vIEVxdWFsc1xuICAgIHJldHVybiByZWFsID09PSBleHBlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kaWNlc0VxdWFscyhpbmRpY2VzMSwgaW5kaWNlczIpIHtcbiAgLy8gaW5kaWNlcyBpcyBhbHdheXMgb3JkZXIgYnkgYXNjIGFuZCBoYXMgb25seSBmaW5pdGUgbnVtYmVyLlxuICByZXR1cm4gaW5kaWNlczEuam9pbignLCcpID09PSBpbmRpY2VzMi5qb2luKCcsJyk7XG59XG4vKipcbiAqIENvbnNpZGVyIGNhc2U6XG4gKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpO2BcbiAqIFRoZW4gdXNlciBkbyBzb21lIGludGVyYWN0aW9uIGxpa2UgZGF0YVpvb20sIGRhdGFWaWV3IGNoYW5naW5nLlxuICogYGNoYXJ0LnNldE9wdGlvbihvcHQyKTtgXG4gKiBUaGVuIHVzZXIgcHJlc3MgJ3Jlc2V0IGJ1dHRvbicgaW4gdG9vbGJveC5cbiAqXG4gKiBBZnRlciBkb2luZyB0aGF0IGFsbCBvZiB0aGUgaW50ZXJhY3Rpb24gZWZmZWN0cyBzaG91bGQgYmUgcmVzZXQsIHRoZVxuICogY2hhcnQgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSByZXN1bHQgb2YgaW52b2tlXG4gKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpOyBjaGFydC5zZXRPcHRpb24ob3B0Mik7YC5cbiAqXG4gKiBBbHRob3VnaCBpdCBpcyBub3QgYWJsZSBlbnN1cmUgdGhhdFxuICogYGNoYXJ0LnNldE9wdGlvbihvcHQxKTsgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2AgaXMgZXF1aXZhbGVudHMgdG9cbiAqIGBjaGFydC5zZXRPcHRpb24obWVyZ2Uob3B0MSwgb3B0MikpO2AgZXhhY3RseSxcbiAqIHRoaXMgbWlnaHQgYmUgdGhlIG9ubHkgc2ltcGxlIHdheSB0byBpbXBsZW1lbnQgdGhhdCBmZWF0dXJlLlxuICpcbiAqIE1FTU86IFdlJ3ZlIGNvbnNpZGVyZWQgc29tZSBvdGhlciBhcHByb2FjaGVzOlxuICogMS4gRWFjaCBtb2RlbCBoYW5kbGUgaXRzIHNlbGYgcmVzdG9yYXRpb24gYnV0IG5vdCB1bmlmb3JtIHRyZWF0bWVudC5cbiAqICAgICAoVG9vIGNvbXBsZXggaW4gbG9naWMgYW5kIGVycm9yLXByb25lKVxuICogMi4gVXNlIGEgc2hhZG93IGVjTW9kZWwuIChQZXJmb3JtYWNlIGV4cGVuc2l2ZSlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlT3B0aW9uKG9sZE9wdGlvbiwgbmV3T3B0aW9uKSB7XG4gIG5ld09wdGlvbiA9IG5ld09wdGlvbiB8fCB7fTtcbiAgZWFjaChuZXdPcHRpb24sIGZ1bmN0aW9uIChuZXdDcHRPcHQsIG1haW5UeXBlKSB7XG4gICAgaWYgKG5ld0NwdE9wdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9sZENwdE9wdCA9IG9sZE9wdGlvblttYWluVHlwZV07XG5cbiAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgb2xkT3B0aW9uW21haW5UeXBlXSA9IG1lcmdlKG9sZENwdE9wdCwgbmV3Q3B0T3B0LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q3B0T3B0ID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkobmV3Q3B0T3B0KTtcbiAgICAgIG9sZENwdE9wdCA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG9sZENwdE9wdCk7XG4gICAgICB2YXIgbWFwUmVzdWx0ID0gbW9kZWxVdGlsLm1hcHBpbmdUb0V4aXN0cyhvbGRDcHRPcHQsIG5ld0NwdE9wdCk7XG4gICAgICBvbGRPcHRpb25bbWFpblR5cGVdID0gbWFwKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ub3B0aW9uICYmIGl0ZW0uZXhpc3QgPyBtZXJnZShpdGVtLmV4aXN0LCBpdGVtLm9wdGlvbiwgdHJ1ZSkgOiBpdGVtLmV4aXN0IHx8IGl0ZW0ub3B0aW9uO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gT3B0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvT3B0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvT3B0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZW52XCIpO1xuXG52YXIgX2Zvcm1hdCA9IHJlcXVpcmUoXCIuLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIGZvcm1hdFRpbWUgPSBfZm9ybWF0LmZvcm1hdFRpbWU7XG52YXIgZW5jb2RlSFRNTCA9IF9mb3JtYXQuZW5jb2RlSFRNTDtcbnZhciBhZGRDb21tYXMgPSBfZm9ybWF0LmFkZENvbW1hcztcbnZhciBnZXRUb29sdGlwTWFya2VyID0gX2Zvcm1hdC5nZXRUb29sdGlwTWFya2VyO1xuXG52YXIgX2NsYXp6ID0gcmVxdWlyZShcIi4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBzZXQgPSBfY2xhenouc2V0O1xudmFyIGdldCA9IF9jbGF6ei5nZXQ7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZShcIi4vQ29tcG9uZW50XCIpO1xuXG52YXIgY29sb3JQYWxldHRlTWl4aW4gPSByZXF1aXJlKFwiLi9taXhpbi9jb2xvclBhbGV0dGVcIik7XG5cbnZhciBfbGF5b3V0ID0gcmVxdWlyZShcIi4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgZ2V0TGF5b3V0UGFyYW1zID0gX2xheW91dC5nZXRMYXlvdXRQYXJhbXM7XG52YXIgbWVyZ2VMYXlvdXRQYXJhbSA9IF9sYXlvdXQubWVyZ2VMYXlvdXRQYXJhbTtcbnZhciBTZXJpZXNNb2RlbCA9IENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdzZXJpZXMuX19iYXNlX18nLFxuXG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHNlcmllc0luZGV4OiAwLFxuICAvLyBjb29kaW5hdGVTeXN0ZW0gd2lsbCBiZSBpbmplY3RlZCBpbiB0aGUgZWNoYXJ0cy9Db29yZGluYXRlU3lzdGVtXG4gIGNvb3JkaW5hdGVTeXN0ZW06IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRlZmF1bHRPcHRpb246IG51bGwsXG5cbiAgLyoqXG4gICAqIERhdGEgcHJvdmlkZWQgZm9yIGxlZ2VuZFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvLyBQRU5ESU5HXG4gIGxlZ2VuZERhdGFQcm92aWRlcjogbnVsbCxcblxuICAvKipcbiAgICogQWNjZXNzIHBhdGggb2YgY29sb3IgZm9yIHZpc3VhbFxuICAgKi9cbiAgdmlzdWFsQ29sb3JBY2Nlc3NQYXRoOiAnaXRlbVN0eWxlLm5vcm1hbC5jb2xvcicsXG5cbiAgLyoqXG4gICAqIFN1cHBvcnQgbWVyZ2UgbGF5b3V0IHBhcmFtcy5cbiAgICogT25seSBzdXBwb3J0ICdib3gnIG5vdyAobGVmdC9yaWdodC90b3AvYm90dG9tL3dpZHRoL2hlaWdodCkuXG4gICAqIEB0eXBlIHtzdHJpbmd8T2JqZWN0fSBPYmplY3QgY2FuIGJlIHtpZ25vcmVTaXplOiB0cnVlfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGxheW91dE1vZGU6IG51bGwsXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5zZXJpZXNJbmRleCA9IHRoaXMuY29tcG9uZW50SW5kZXg7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXRJbml0aWFsRGF0YShvcHRpb24sIGVjTW9kZWwpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdHxtb2R1bGU6ZWNoYXJ0cy9kYXRhL1RyZWV8bW9kdWxlOmVjaGFydHMvZGF0YS9HcmFwaH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNldCh0aGlzLCAnZGF0YUJlZm9yZVByb2Nlc3NlZCcsIGRhdGEpOyAvLyBJZiB3ZSByZXZlcnNlIHRoZSBvcmRlciAobWFrZSBkYXRhIGZpcnN0bHksIGFuZCB0aGVuIG1ha2VcbiAgICAvLyBkYXRhQmVmb3JlUHJvY2Vzc2VkIGJ5IGNsb25lU2hhbGxvdyksIGNsb25lU2hhbGxvdyB3aWxsXG4gICAgLy8gY2F1c2UgZGF0YS5ncmFwaC5kYXRhICE9PSBkYXRhIHdoZW4gdXNpbmdcbiAgICAvLyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL0dyYXBoIG9yIG1vZHVsZTplY2hhcnRzL2RhdGEvVHJlZS5cbiAgICAvLyBTZWUgbW9kdWxlOmVjaGFydHMvZGF0YS9oZWxwZXIvbGlua0xpc3RcblxuICAgIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgfSxcblxuICAvKipcbiAgICogVXRpbCBmb3IgbWVyZ2UgZGVmYXVsdCBhbmQgdGhlbWUgdG8gb3B0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKi9cbiAgbWVyZ2VEZWZhdWx0QW5kVGhlbWU6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcbiAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGUgPyBnZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9OyAvLyBCYWNrd2FyZCBjb21wYXQ6IHVzaW5nIHN1YlR5cGUgb24gdGhlbWUuXG4gICAgLy8gQnV0IGlmIG5hbWUgZHVwbGljYXRlIGJldHdlZW4gc2VyaWVzIHN1YlR5cGVcbiAgICAvLyAoZm9yIGV4YW1wbGU6IHBhcmFsbGVsKSBhZGQgY29tcG9uZW50IG1haW5UeXBlLFxuICAgIC8vIGFkZCBzdWZmaXggJ1NlcmllcycuXG5cbiAgICB2YXIgdGhlbWVTdWJUeXBlID0gdGhpcy5zdWJUeXBlO1xuXG4gICAgaWYgKENvbXBvbmVudE1vZGVsLmhhc0NsYXNzKHRoZW1lU3ViVHlwZSkpIHtcbiAgICAgIHRoZW1lU3ViVHlwZSArPSAnU2VyaWVzJztcbiAgICB9XG5cbiAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCBlY01vZGVsLmdldFRoZW1lKCkuZ2V0KHRoaXMuc3ViVHlwZSkpO1xuICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTsgLy8gRGVmYXVsdCBsYWJlbCBlbXBoYXNpcyBgc2hvd2BcblxuICAgIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMob3B0aW9uLmxhYmVsLCBbJ3Nob3cnXSk7XG4gICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShvcHRpb24uZGF0YSk7XG5cbiAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgbWVyZ2VMYXlvdXRQYXJhbShvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMsIGxheW91dE1vZGUpO1xuICAgIH1cbiAgfSxcbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdTZXJpZXNPcHRpb24sIGVjTW9kZWwpIHtcbiAgICBuZXdTZXJpZXNPcHRpb24gPSB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG5ld1Nlcmllc09wdGlvbiwgdHJ1ZSk7XG4gICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShuZXdTZXJpZXNPcHRpb24uZGF0YSk7XG4gICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG5cbiAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgbWVyZ2VMYXlvdXRQYXJhbSh0aGlzLm9wdGlvbiwgbmV3U2VyaWVzT3B0aW9uLCBsYXlvdXRNb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0SW5pdGlhbERhdGEobmV3U2VyaWVzT3B0aW9uLCBlY01vZGVsKTsgLy8gVE9ETyBNZXJnZSBkYXRhP1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHNldCh0aGlzLCAnZGF0YScsIGRhdGEpO1xuICAgICAgc2V0KHRoaXMsICdkYXRhQmVmb3JlUHJvY2Vzc2VkJywgZGF0YS5jbG9uZVNoYWxsb3coKSk7XG4gICAgfVxuICB9LFxuICBmaWxsRGF0YVRleHRTdHlsZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyBEZWZhdWx0IGRhdGEgbGFiZWwgZW1waGFzaXMgYHNob3dgXG4gICAgLy8gRklYTUUgVHJlZSBzdHJ1Y3R1cmUgZGF0YSA/XG4gICAgLy8gRklYTUUgUGVyZm9ybWFuY2UgP1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB2YXIgcHJvcHMgPSBbJ3Nob3cnXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2ldICYmIGRhdGFbaV0ubGFiZWwpIHtcbiAgICAgICAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzKGRhdGFbaV0ubGFiZWwsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdCBhIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSByZWxhdGVkIG9wdGlvbiBpbiBzZXJpZXNcbiAgICogTXVzdCBiZSBvdmVyd3JpdHRlblxuICAgKi9cbiAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAqL1xuICBnZXREYXRhOiBmdW5jdGlvbiAoZGF0YVR5cGUpIHtcbiAgICB2YXIgZGF0YSA9IGdldCh0aGlzLCAnZGF0YScpO1xuICAgIHJldHVybiBkYXRhVHlwZSA9PSBudWxsID8gZGF0YSA6IGRhdGEuZ2V0TGlua2VkRGF0YShkYXRhVHlwZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAqL1xuICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNldCh0aGlzLCAnZGF0YScsIGRhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YSBiZWZvcmUgcHJvY2Vzc2VkXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH1cbiAgICovXG4gIGdldFJhd0RhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsICdkYXRhQmVmb3JlUHJvY2Vzc2VkJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvb3JkIGRpbWVuc2lvbiB0byBkYXRhIGRpbWVuc2lvbi5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGUgcmVzdWx0IGlzIHRoZSBzYW1lIGFzIGRpbWVuc2lvbnMgb2Ygc2VyaWVzIGRhdGEuXG4gICAqIEJ1dCBpbiBzb21lIHNlcmllcyBkYXRhIGRpbWVuc2lvbnMgYXJlIGRpZmZlcmVudCBmcm9tIGNvb3JkIGRpbWVuc2lvbnMgKGkuZS5cbiAgICogY2FuZGxlc3RpY2sgYW5kIGJveHBsb3QpLiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBoYW5kbGUgdGhvc2UgY2FzZXMuXG4gICAqXG4gICAqIENvb3JkIGRpbWVuc2lvbiB0byBkYXRhIGRpbWVuc2lvbiBjYW4gYmUgb25lLXRvLW1hbnlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkRGltXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBkaW1lbnNpb25zIG9uIHRoZSBheGlzLlxuICAgKi9cbiAgY29vcmREaW1Ub0RhdGFEaW06IGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgIHJldHVybiBtb2RlbFV0aWwuY29vcmREaW1Ub0RhdGFEaW0odGhpcy5nZXREYXRhKCksIGNvb3JkRGltKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBkYXRhIGRpbWVuc2lvbiB0byBjb29yZCBkaW1lbnNpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGF0YURpbVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBkYXRhRGltVG9Db29yZERpbTogZnVuY3Rpb24gKGRhdGFEaW0pIHtcbiAgICByZXR1cm4gbW9kZWxVdGlsLmRhdGFEaW1Ub0Nvb3JkRGltKHRoaXMuZ2V0RGF0YSgpLCBkYXRhRGltKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGJhc2UgYXhpcyBpZiBoYXMgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIGhhcyBheGlzLlxuICAgKiBCeSBkZWZhdWx0IHVzZSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgKiBDYW4gYmUgb3ZlcnJpZGVkIGZvciBzb21lIGNoYXJ0LlxuICAgKiBAcmV0dXJuIHt0eXBlfSBkZXNjcmlwdGlvblxuICAgKi9cbiAgZ2V0QmFzZUF4aXM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgcmV0dXJuIGNvb3JkU3lzICYmIGNvb3JkU3lzLmdldEJhc2VBeGlzICYmIGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gIH0sXG4gIC8vIEZJWE1FXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdG9vbHRpcCBmb3JtYXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aXBsZVNlcmllcz1mYWxzZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhVHlwZV1cbiAgICovXG4gIGZvcm1hdFRvb2x0aXA6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG11bHRpcGxlU2VyaWVzLCBkYXRhVHlwZSkge1xuICAgIGZ1bmN0aW9uIGZvcm1hdEFycmF5VmFsdWUodmFsdWUpIHtcbiAgICAgIHZhciB2ZXJ0aWFsbHkgPSB6clV0aWwucmVkdWNlKHZhbHVlLCBmdW5jdGlvbiAodmVydGlhbGx5LCB2YWwsIGlkeCkge1xuICAgICAgICB2YXIgZGltSXRlbSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhpZHgpO1xuICAgICAgICByZXR1cm4gdmVydGlhbGx5IHw9IGRpbUl0ZW0gJiYgZGltSXRlbS50b29sdGlwICE9PSBmYWxzZSAmJiBkaW1JdGVtLnRvb2x0aXBOYW1lICE9IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciB0b29sdGlwRGltcyA9IG1vZGVsVXRpbC5vdGhlckRpbVRvRGF0YURpbShkYXRhLCAndG9vbHRpcCcpO1xuICAgICAgdG9vbHRpcERpbXMubGVuZ3RoID8genJVdGlsLmVhY2godG9vbHRpcERpbXMsIGZ1bmN0aW9uIChkaW1JZHgpIHtcbiAgICAgICAgc2V0RWFjaEl0ZW0oZGF0YS5nZXQoZGltSWR4LCBkYXRhSW5kZXgpLCBkaW1JZHgpO1xuICAgICAgfSkgLy8gQnkgZGVmYXVsdCwgYWxsIGRpbXMgaXMgdXNlZCBvbiB0b29sdGlwLlxuICAgICAgOiB6clV0aWwuZWFjaCh2YWx1ZSwgc2V0RWFjaEl0ZW0pO1xuXG4gICAgICBmdW5jdGlvbiBzZXRFYWNoSXRlbSh2YWwsIGRpbUlkeCkge1xuICAgICAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1JZHgpOyAvLyBJZiBgZGltSW5mby50b29sdGlwYCBpcyBub3Qgc2V0LCBzaG93IHRvb2x0aXAuXG5cbiAgICAgICAgaWYgKCFkaW1JbmZvIHx8IGRpbUluZm8ub3RoZXJEaW1zLnRvb2x0aXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpbVR5cGUgPSBkaW1JbmZvLnR5cGU7XG4gICAgICAgIHZhciB2YWxTdHIgPSAodmVydGlhbGx5ID8gJy0gJyArIChkaW1JbmZvLnRvb2x0aXBOYW1lIHx8IGRpbUluZm8ubmFtZSkgKyAnOiAnIDogJycpICsgKGRpbVR5cGUgPT09ICdvcmRpbmFsJyA/IHZhbCArICcnIDogZGltVHlwZSA9PT0gJ3RpbWUnID8gbXVsdGlwbGVTZXJpZXMgPyAnJyA6IGZvcm1hdFRpbWUoJ3l5eXkvTU0vZGQgaGg6bW06c3MnLCB2YWwpIDogYWRkQ29tbWFzKHZhbCkpO1xuICAgICAgICB2YWxTdHIgJiYgcmVzdWx0LnB1c2goZW5jb2RlSFRNTCh2YWxTdHIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICh2ZXJ0aWFsbHkgPyAnPGJyLz4nIDogJycpICsgcmVzdWx0LmpvaW4odmVydGlhbGx5ID8gJzxici8+JyA6ICcsICcpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gZ2V0KHRoaXMsICdkYXRhJyk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpO1xuICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHpyVXRpbC5pc0FycmF5KHZhbHVlKSA/IGZvcm1hdEFycmF5VmFsdWUodmFsdWUpIDogZW5jb2RlSFRNTChhZGRDb21tYXModmFsdWUpKTtcbiAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgpO1xuICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdjb2xvcicpO1xuXG4gICAgaWYgKHpyVXRpbC5pc09iamVjdChjb2xvcikgJiYgY29sb3IuY29sb3JTdG9wcykge1xuICAgICAgY29sb3IgPSAoY29sb3IuY29sb3JTdG9wc1swXSB8fCB7fSkuY29sb3I7XG4gICAgfVxuXG4gICAgY29sb3IgPSBjb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgIHZhciBjb2xvckVsID0gZ2V0VG9vbHRpcE1hcmtlcihjb2xvcik7XG4gICAgdmFyIHNlcmllc05hbWUgPSB0aGlzLm5hbWU7IC8vIEZJWE1FXG5cbiAgICBpZiAoc2VyaWVzTmFtZSA9PT0gJ1xcMC0nKSB7XG4gICAgICAvLyBOb3Qgc2hvdyAnLSdcbiAgICAgIHNlcmllc05hbWUgPSAnJztcbiAgICB9XG5cbiAgICBzZXJpZXNOYW1lID0gc2VyaWVzTmFtZSA/IGVuY29kZUhUTUwoc2VyaWVzTmFtZSkgKyAoIW11bHRpcGxlU2VyaWVzID8gJzxici8+JyA6ICc6ICcpIDogJyc7XG4gICAgcmV0dXJuICFtdWx0aXBsZVNlcmllcyA/IHNlcmllc05hbWUgKyBjb2xvckVsICsgKG5hbWUgPyBlbmNvZGVIVE1MKG5hbWUpICsgJzogJyArIGZvcm1hdHRlZFZhbHVlIDogZm9ybWF0dGVkVmFsdWUpIDogY29sb3JFbCArIHNlcmllc05hbWUgKyBmb3JtYXR0ZWRWYWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQW5pbWF0aW9uRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhbmltYXRpb25FbmFibGVkID0gdGhpcy5nZXRTaGFsbG93KCdhbmltYXRpb24nKTtcblxuICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICBpZiAodGhpcy5nZXREYXRhKCkuY291bnQoKSA+IHRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uVGhyZXNob2xkJykpIHtcbiAgICAgICAgYW5pbWF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25FbmFibGVkO1xuICB9LFxuICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHNldCh0aGlzLCAnZGF0YScsIGdldCh0aGlzLCAnZGF0YUJlZm9yZVByb2Nlc3NlZCcpLmNsb25lU2hhbGxvdygpKTtcbiAgfSxcbiAgZ2V0Q29sb3JGcm9tUGFsZXR0ZTogZnVuY3Rpb24gKG5hbWUsIHNjb3BlKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7IC8vIFBFTkRJTkdcblxuICAgIHZhciBjb2xvciA9IGNvbG9yUGFsZXR0ZU1peGluLmdldENvbG9yRnJvbVBhbGV0dGUuY2FsbCh0aGlzLCBuYW1lLCBzY29wZSk7XG5cbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICBjb2xvciA9IGVjTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShuYW1lLCBzY29wZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YSBpbmRpY2VzIGZvciBzaG93IHRvb2x0aXAgY29udGVudC4gU2VlIHRvb2x0aXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gZGltXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvc2luZ2xlL1NpbmdsZUF4aXN9IGJhc2VBeGlzXG4gICAqIEByZXR1cm4ge09iamVjdH0ge2RhdGFJbmRpY2VzLCBuZXN0ZXN0VmFsdWV9LlxuICAgKi9cbiAgZ2V0QXhpc1Rvb2x0aXBEYXRhOiBudWxsLFxuXG4gIC8qKlxuICAgKiBTZWUgdG9vbHRpcC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFBvaW50IG9mIHRvb2x0aXAuIG51bGwvdW5kZWZpbmVkIGNhbiBiZSByZXR1cm5lZC5cbiAgICovXG4gIGdldFRvb2x0aXBQb3NpdGlvbjogbnVsbFxufSk7XG56clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIG1vZGVsVXRpbC5kYXRhRm9ybWF0TWl4aW4pO1xuenJVdGlsLm1peGluKFNlcmllc01vZGVsLCBjb2xvclBhbGV0dGVNaXhpbik7XG52YXIgX2RlZmF1bHQgPSBTZXJpZXNNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9TZXJpZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgcGxhdGZvcm0gPSAnJzsgLy8gTmF2aWdhdG9yIG5vdCBleGlzdHMgaW4gbm9kZVxuXG5pZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm0gfHwgJyc7XG59XG5cbnZhciBfZGVmYXVsdCA9IHtcbiAgLy8g5YWo5Zu+6buY6K6k6IOM5pmvXG4gIC8vIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAvLyBodHRwczovL2RyaWJiYmxlLmNvbS9zaG90cy8xMDY1OTYwLUluZm9ncmFwaGljLVBpZS1jaGFydC12aXN1YWxpemF0aW9uXG4gIC8vIGNvbG9yOiBbJyM1NzkzZjMnLCAnI2QxNGE2MScsICcjZmQ5YzM1JywgJyM2NzViYmEnLCAnI2ZlYzQyYycsICcjZGQ0NDQ0JywgJyNkNGRmNWEnLCAnI2NkNDg3MCddLFxuICAvLyDmtYXoibJcbiAgLy8gY29sb3I6IFsnI2JjZDNiYicsICcjZTg4ZjcwJywgJyNlZGMxYTUnLCAnIzlkYzVjOCcsICcjZTFlOGM4JywgJyM3YjdjNjgnLCAnI2U1YjViNScsICcjZjBiNDg5JywgJyM5MjhlYTgnLCAnI2JkYTI5YSddLFxuICAvLyBjb2xvcjogWycjY2M1NjY0JywgJyM5YmQ2ZWMnLCAnI2VhOTQ2ZScsICcjOGFjYWFhJywgJyNmMWVjNjQnLCAnI2VlODY4NicsICcjYTQ4ZGMxJywgJyM1ZGE2YmMnLCAnI2I5ZGNhZSddLFxuICAvLyDmt7HoibJcbiAgY29sb3I6IFsnI2MyMzUzMScsICcjMmY0NTU0JywgJyM2MWEwYTgnLCAnI2Q0ODI2NScsICcjOTFjN2FlJywgJyM3NDlmODMnLCAnI2NhODYyMicsICcjYmRhMjlhJywgJyM2ZTcwNzQnLCAnIzU0NjU3MCcsICcjYzRjY2QzJ10sXG4gIC8vIOm7mOiupOmcgOimgSBHcmlkIOmFjee9rumhuVxuICAvLyBncmlkOiB7fSxcbiAgLy8g5Li76aKY77yM5Li76aKYXG4gIHRleHRTdHlsZToge1xuICAgIC8vIGNvbG9yOiAnIzAwMCcsXG4gICAgLy8gZGVjb3JhdGlvbjogJ25vbmUnLFxuICAgIC8vIFBFTkRJTkdcbiAgICBmb250RmFtaWx5OiBwbGF0Zm9ybS5tYXRjaCgvXldpbi8pID8gJ01pY3Jvc29mdCBZYUhlaScgOiAnc2Fucy1zZXJpZicsXG4gICAgLy8gZm9udEZhbWlseTogJ0FyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJyxcbiAgICBmb250U2l6ZTogMTIsXG4gICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcbiAgICBmb250V2VpZ2h0OiAnbm9ybWFsJ1xuICB9LFxuICAvLyBodHRwOi8vYmxvZ3MuYWRvYmUuY29tL3dlYnBsYXRmb3JtLzIwMTQvMDIvMjQvdXNpbmctYmxlbmQtbW9kZXMtaW4taHRtbC1jYW52YXMvXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gIC8vIERlZmF1bHQgaXMgc291cmNlLW92ZXJcbiAgYmxlbmRNb2RlOiBudWxsLFxuICBhbmltYXRpb246ICdhdXRvJyxcbiAgYW5pbWF0aW9uRHVyYXRpb246IDEwMDAsXG4gIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAzMDAsXG4gIGFuaW1hdGlvbkVhc2luZzogJ2V4cG9uZW50aWFsT3V0JyxcbiAgYW5pbWF0aW9uRWFzaW5nVXBkYXRlOiAnY3ViaWNPdXQnLFxuICBhbmltYXRpb25UaHJlc2hvbGQ6IDIwMDAsXG4gIC8vIENvbmZpZ3VyYXRpb24gZm9yIHByb2dyZXNzaXZlL2luY3JlbWVudGFsIHJlbmRlcmluZ1xuICBwcm9ncmVzc2l2ZVRocmVzaG9sZDogMzAwMCxcbiAgcHJvZ3Jlc3NpdmU6IDQwMCxcbiAgLy8gVGhyZXNob2xkIG9mIGlmIHVzZSBzaW5nbGUgaG92ZXIgbGF5ZXIgdG8gb3B0aW1pemUuXG4gIC8vIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgYGhvdmVyTGF5ZXJUaHJlc2hvbGRgIGlzIGVxdWl2YWxlbnQgdG8gb3IgbGVzcyB0aGFuXG4gIC8vIGBwcm9ncmVzc2l2ZVRocmVzaG9sZGAsIG90aGVyd2lzZSBob3ZlciB3aWxsIGNhdXNlIHJlc3RhcnQgb2YgcHJvZ3Jlc3NpdmUsXG4gIC8vIHdoaWNoIGlzIHVuZXhwZWN0ZWQuXG4gIC8vIHNlZSBleGFtcGxlIDxlY2hhcnRzL3Rlc3QvaGVhdG1hcC1sYXJnZS5odG1sPi5cbiAgaG92ZXJMYXllclRocmVzaG9sZDogMzAwMCxcbiAgLy8gU2VlOiBtb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lXG4gIHVzZVVUQzogZmFsc2Vcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL2dsb2JhbERlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL2dsb2JhbERlZmF1bHQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbWFrZVN0eWxlTWFwcGVyID0gcmVxdWlyZShcIi4vbWFrZVN0eWxlTWFwcGVyXCIpO1xuXG52YXIgZ2V0QXJlYVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2ZpbGwnLCAnY29sb3InXSwgWydzaGFkb3dCbHVyJ10sIFsnc2hhZG93T2Zmc2V0WCddLCBbJ3NoYWRvd09mZnNldFknXSwgWydvcGFjaXR5J10sIFsnc2hhZG93Q29sb3InXV0pO1xudmFyIF9kZWZhdWx0ID0ge1xuICBnZXRBcmVhU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcywgaW5jbHVkZXMpIHtcbiAgICByZXR1cm4gZ2V0QXJlYVN0eWxlKHRoaXMsIGV4Y2x1ZGVzLCBpbmNsdWRlcyk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2FyZWFTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vYXJlYVN0eWxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9kZWZhdWx0ID0ge1xuICBnZXRCb3hMYXlvdXRQYXJhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5nZXQoJ2xlZnQnKSxcbiAgICAgIHRvcDogdGhpcy5nZXQoJ3RvcCcpLFxuICAgICAgcmlnaHQ6IHRoaXMuZ2V0KCdyaWdodCcpLFxuICAgICAgYm90dG9tOiB0aGlzLmdldCgnYm90dG9tJyksXG4gICAgICB3aWR0aDogdGhpcy5nZXQoJ3dpZHRoJyksXG4gICAgICBoZWlnaHQ6IHRoaXMuZ2V0KCdoZWlnaHQnKVxuICAgIH07XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2JveExheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vYm94TGF5b3V0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jbGF6eiA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2NsYXp6XCIpO1xuXG52YXIgc2V0ID0gX2NsYXp6LnNldDtcbnZhciBnZXQgPSBfY2xhenouZ2V0O1xudmFyIF9kZWZhdWx0ID0ge1xuICBjbGVhckNvbG9yUGFsZXR0ZTogZnVuY3Rpb24gKCkge1xuICAgIHNldCh0aGlzLCAnY29sb3JJZHgnLCAwKTtcbiAgICBzZXQodGhpcywgJ2NvbG9yTmFtZU1hcCcsIHt9KTtcbiAgfSxcbiAgZ2V0Q29sb3JGcm9tUGFsZXR0ZTogZnVuY3Rpb24gKG5hbWUsIHNjb3BlKSB7XG4gICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xuICAgIHZhciBjb2xvcklkeCA9IGdldChzY29wZSwgJ2NvbG9ySWR4JykgfHwgMDtcbiAgICB2YXIgY29sb3JOYW1lTWFwID0gZ2V0KHNjb3BlLCAnY29sb3JOYW1lTWFwJykgfHwgc2V0KHNjb3BlLCAnY29sb3JOYW1lTWFwJywge30pOyAvLyBVc2UgYGhhc093blByb3BlcnR5YCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG5cbiAgICBpZiAoY29sb3JOYW1lTWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gY29sb3JOYW1lTWFwW25hbWVdO1xuICAgIH1cblxuICAgIHZhciBjb2xvclBhbGV0dGUgPSB0aGlzLmdldCgnY29sb3InLCB0cnVlKSB8fCBbXTtcblxuICAgIGlmICghY29sb3JQYWxldHRlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb2xvciA9IGNvbG9yUGFsZXR0ZVtjb2xvcklkeF07XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgY29sb3JOYW1lTWFwW25hbWVdID0gY29sb3I7XG4gICAgfVxuXG4gICAgc2V0KHNjb3BlLCAnY29sb3JJZHgnLCAoY29sb3JJZHggKyAxKSAlIGNvbG9yUGFsZXR0ZS5sZW5ndGgpO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vY29sb3JQYWxldHRlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9jb2xvclBhbGV0dGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbWFrZVN0eWxlTWFwcGVyID0gcmVxdWlyZShcIi4vbWFrZVN0eWxlTWFwcGVyXCIpO1xuXG52YXIgZ2V0SXRlbVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2ZpbGwnLCAnY29sb3InXSwgWydzdHJva2UnLCAnYm9yZGVyQ29sb3InXSwgWydsaW5lV2lkdGgnLCAnYm9yZGVyV2lkdGgnXSwgWydvcGFjaXR5J10sIFsnc2hhZG93Qmx1ciddLCBbJ3NoYWRvd09mZnNldFgnXSwgWydzaGFkb3dPZmZzZXRZJ10sIFsnc2hhZG93Q29sb3InXSwgWyd0ZXh0UG9zaXRpb24nXSwgWyd0ZXh0QWxpZ24nXV0pO1xudmFyIF9kZWZhdWx0ID0ge1xuICBnZXRJdGVtU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcywgaW5jbHVkZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRJdGVtU3R5bGUodGhpcywgZXhjbHVkZXMsIGluY2x1ZGVzKTtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLmdldEJvcmRlckxpbmVEYXNoKCk7XG4gICAgbGluZURhc2ggJiYgKHN0eWxlLmxpbmVEYXNoID0gbGluZURhc2gpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgZ2V0Qm9yZGVyTGluZURhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGluZVR5cGUgPSB0aGlzLmdldCgnYm9yZGVyVHlwZScpO1xuICAgIHJldHVybiBsaW5lVHlwZSA9PT0gJ3NvbGlkJyB8fCBsaW5lVHlwZSA9PSBudWxsID8gbnVsbCA6IGxpbmVUeXBlID09PSAnZGFzaGVkJyA/IFs1LCA1XSA6IFsxLCAxXTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vaXRlbVN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9pdGVtU3R5bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbWFrZVN0eWxlTWFwcGVyID0gcmVxdWlyZShcIi4vbWFrZVN0eWxlTWFwcGVyXCIpO1xuXG52YXIgZ2V0TGluZVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2xpbmVXaWR0aCcsICd3aWR0aCddLCBbJ3N0cm9rZScsICdjb2xvciddLCBbJ29wYWNpdHknXSwgWydzaGFkb3dCbHVyJ10sIFsnc2hhZG93T2Zmc2V0WCddLCBbJ3NoYWRvd09mZnNldFknXSwgWydzaGFkb3dDb2xvciddXSk7XG52YXIgX2RlZmF1bHQgPSB7XG4gIGdldExpbmVTdHlsZTogZnVuY3Rpb24gKGV4Y2x1ZGVzKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0TGluZVN0eWxlKHRoaXMsIGV4Y2x1ZGVzKTtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLmdldExpbmVEYXNoKHN0eWxlLmxpbmVXaWR0aCk7XG4gICAgbGluZURhc2ggJiYgKHN0eWxlLmxpbmVEYXNoID0gbGluZURhc2gpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgZ2V0TGluZURhc2g6IGZ1bmN0aW9uIChsaW5lV2lkdGgpIHtcbiAgICBpZiAobGluZVdpZHRoID09IG51bGwpIHtcbiAgICAgIGxpbmVXaWR0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVUeXBlID0gdGhpcy5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgZG90U2l6ZSA9IE1hdGgubWF4KGxpbmVXaWR0aCwgMik7XG4gICAgdmFyIGRhc2hTaXplID0gbGluZVdpZHRoICogNDtcbiAgICByZXR1cm4gbGluZVR5cGUgPT09ICdzb2xpZCcgfHwgbGluZVR5cGUgPT0gbnVsbCA/IG51bGwgOiBsaW5lVHlwZSA9PT0gJ2Rhc2hlZCcgPyBbZGFzaFNpemUsIGRhc2hTaXplXSA6IFtkb3RTaXplLCBkb3RTaXplXTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vbGluZVN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9saW5lU3R5bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxuLy8gVE9ETyBQYXJzZSBzaGFkb3cgc3R5bGVcbi8vIFRPRE8gT25seSBzaGFsbG93IHBhdGggc3VwcG9ydFxuZnVuY3Rpb24gX2RlZmF1bHQocHJvcGVydGllcykge1xuICAvLyBOb3JtYWxpemVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFwcm9wZXJ0aWVzW2ldWzFdKSB7XG4gICAgICBwcm9wZXJ0aWVzW2ldWzFdID0gcHJvcGVydGllc1tpXVswXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG1vZGVsLCBleGNsdWRlcywgaW5jbHVkZXMpIHtcbiAgICB2YXIgc3R5bGUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydGllc1tpXVsxXTtcblxuICAgICAgaWYgKGV4Y2x1ZGVzICYmIHpyVXRpbC5pbmRleE9mKGV4Y2x1ZGVzLCBwcm9wTmFtZSkgPj0gMCB8fCBpbmNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihpbmNsdWRlcywgcHJvcE5hbWUpIDwgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbCA9IG1vZGVsLmdldFNoYWxsb3cocHJvcE5hbWUpO1xuXG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydGllc1tpXVswXV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHRleHRDb250YWluID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIGdyYXBoaWNVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIFBBVEhfQ09MT1IgPSBbJ3RleHRTdHlsZScsICdjb2xvciddO1xudmFyIF9kZWZhdWx0ID0ge1xuICAvKipcbiAgICogR2V0IGNvbG9yIHByb3BlcnR5IG9yIGdldCBjb2xvciBmcm9tIG9wdGlvbi50ZXh0U3R5bGUuY29sb3JcbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNFbXBoYXNpc11cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dENvbG9yOiBmdW5jdGlvbiAoaXNFbXBoYXNpcykge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIHJldHVybiB0aGlzLmdldFNoYWxsb3coJ2NvbG9yJykgfHwgKCFpc0VtcGhhc2lzICYmIGVjTW9kZWwgPyBlY01vZGVsLmdldChQQVRIX0NPTE9SKSA6IG51bGwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZm9udCBzdHJpbmcgZnJvbSBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEZvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ3JhcGhpY1V0aWwuZ2V0Rm9udCh7XG4gICAgICBmb250U3R5bGU6IHRoaXMuZ2V0U2hhbGxvdygnZm9udFN0eWxlJyksXG4gICAgICBmb250V2VpZ2h0OiB0aGlzLmdldFNoYWxsb3coJ2ZvbnRXZWlnaHQnKSxcbiAgICAgIGZvbnRTaXplOiB0aGlzLmdldFNoYWxsb3coJ2ZvbnRTaXplJyksXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmdldFNoYWxsb3coJ2ZvbnRGYW1pbHknKVxuICAgIH0sIHRoaXMuZWNNb2RlbCk7XG4gIH0sXG4gIGdldFRleHRSZWN0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgIHJldHVybiB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgdGhpcy5nZXRGb250KCksIHRoaXMuZ2V0U2hhbGxvdygnYWxpZ24nKSwgdGhpcy5nZXRTaGFsbG93KCd2ZXJ0aWNhbEFsaWduJykgfHwgdGhpcy5nZXRTaGFsbG93KCdiYXNlbGluZScpLCB0aGlzLmdldFNoYWxsb3coJ3BhZGRpbmcnKSwgdGhpcy5nZXRTaGFsbG93KCdyaWNoJyksIHRoaXMuZ2V0U2hhbGxvdygndHJ1bmNhdGVUZXh0JykpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi90ZXh0U3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL3RleHRTdHlsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcbnZhciBpc0FycmF5ID0gX3V0aWwuaXNBcnJheTtcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xuXG52YXIgY29tcGF0U3R5bGUgPSByZXF1aXJlKFwiLi9oZWxwZXIvY29tcGF0U3R5bGVcIik7XG5cbnZhciBfbW9kZWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIG5vcm1hbGl6ZVRvQXJyYXkgPSBfbW9kZWwubm9ybWFsaXplVG9BcnJheTtcblxuLy8gQ29tcGF0aXRhYmxlIHdpdGggMi4wXG5mdW5jdGlvbiBnZXQob3B0LCBwYXRoKSB7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcsJyk7XG4gIHZhciBvYmogPSBvcHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgb2JqID0gb2JqICYmIG9ialtwYXRoW2ldXTtcblxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gc2V0KG9wdCwgcGF0aCwgdmFsLCBvdmVyd3JpdGUpIHtcbiAgcGF0aCA9IHBhdGguc3BsaXQoJywnKTtcbiAgdmFyIG9iaiA9IG9wdDtcbiAgdmFyIGtleTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAga2V5ID0gcGF0aFtpXTtcblxuICAgIGlmIChvYmpba2V5XSA9PSBudWxsKSB7XG4gICAgICBvYmpba2V5XSA9IHt9O1xuICAgIH1cblxuICAgIG9iaiA9IG9ialtrZXldO1xuICB9XG5cbiAgaWYgKG92ZXJ3cml0ZSB8fCBvYmpbcGF0aFtpXV0gPT0gbnVsbCkge1xuICAgIG9ialtwYXRoW2ldXSA9IHZhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXRMYXlvdXRQcm9wZXJ0aWVzKG9wdGlvbikge1xuICBlYWNoKExBWU9VVF9QUk9QRVJUSUVTLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIGlmIChwcm9wWzBdIGluIG9wdGlvbiAmJiAhKHByb3BbMV0gaW4gb3B0aW9uKSkge1xuICAgICAgb3B0aW9uW3Byb3BbMV1dID0gb3B0aW9uW3Byb3BbMF1dO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBMQVlPVVRfUFJPUEVSVElFUyA9IFtbJ3gnLCAnbGVmdCddLCBbJ3knLCAndG9wJ10sIFsneDInLCAncmlnaHQnXSwgWyd5MicsICdib3R0b20nXV07XG52YXIgQ09NUEFUSVRBQkxFX0NPTVBPTkVOVFMgPSBbJ2dyaWQnLCAnZ2VvJywgJ3BhcmFsbGVsJywgJ2xlZ2VuZCcsICd0b29sYm94JywgJ3RpdGxlJywgJ3Zpc3VhbE1hcCcsICdkYXRhWm9vbScsICd0aW1lbGluZSddO1xudmFyIENPTVBBVElUQUJMRV9TRVJJRVMgPSBbJ2JhcicsICdib3hwbG90JywgJ2NhbmRsZXN0aWNrJywgJ2Nob3JkJywgJ2VmZmVjdFNjYXR0ZXInLCAnZnVubmVsJywgJ2dhdWdlJywgJ2xpbmVzJywgJ2dyYXBoJywgJ2hlYXRtYXAnLCAnbGluZScsICdtYXAnLCAncGFyYWxsZWwnLCAncGllJywgJ3JhZGFyJywgJ3NhbmtleScsICdzY2F0dGVyJywgJ3RyZWVtYXAnXTtcblxuZnVuY3Rpb24gX2RlZmF1bHQob3B0aW9uLCBpc1RoZW1lKSB7XG4gIGNvbXBhdFN0eWxlKG9wdGlvbiwgaXNUaGVtZSk7IC8vIE1ha2Ugc3VyZSBzZXJpZXMgYXJyYXkgZm9yIG1vZGVsIGluaXRpYWxpemF0aW9uLlxuXG4gIG9wdGlvbi5zZXJpZXMgPSBub3JtYWxpemVUb0FycmF5KG9wdGlvbi5zZXJpZXMpO1xuICBlYWNoKG9wdGlvbi5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHNlcmllc09wdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VyaWVzVHlwZSA9IHNlcmllc09wdC50eXBlO1xuXG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdwaWUnIHx8IHNlcmllc1R5cGUgPT09ICdnYXVnZScpIHtcbiAgICAgIGlmIChzZXJpZXNPcHQuY2xvY2tXaXNlICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWVzT3B0LmNsb2Nrd2lzZSA9IHNlcmllc09wdC5jbG9ja1dpc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdnYXVnZScpIHtcbiAgICAgIHZhciBwb2ludGVyQ29sb3IgPSBnZXQoc2VyaWVzT3B0LCAncG9pbnRlci5jb2xvcicpO1xuICAgICAgcG9pbnRlckNvbG9yICE9IG51bGwgJiYgc2V0KHNlcmllc09wdCwgJ2l0ZW1TdHlsZS5ub3JtYWwuY29sb3InLCBwb2ludGVyQ29sb3IpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ09NUEFUSVRBQkxFX1NFUklFUy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKENPTVBBVElUQUJMRV9TRVJJRVNbaV0gPT09IHNlcmllc09wdC50eXBlKSB7XG4gICAgICAgIGNvbXBhdExheW91dFByb3BlcnRpZXMoc2VyaWVzT3B0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTsgLy8gZGF0YVJhbmdlIGhhcyBjaGFuZ2VkIHRvIHZpc3VhbE1hcFxuXG4gIGlmIChvcHRpb24uZGF0YVJhbmdlKSB7XG4gICAgb3B0aW9uLnZpc3VhbE1hcCA9IG9wdGlvbi5kYXRhUmFuZ2U7XG4gIH1cblxuICBlYWNoKENPTVBBVElUQUJMRV9DT01QT05FTlRTLCBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSkge1xuICAgIHZhciBvcHRpb25zID0gb3B0aW9uW2NvbXBvbmVudE5hbWVdO1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICghaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gW29wdGlvbnNdO1xuICAgICAgfVxuXG4gICAgICBlYWNoKG9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgY29tcGF0TGF5b3V0UHJvcGVydGllcyhvcHRpb24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG52YXIgUE9TU0lCTEVfU1RZTEVTID0gWydhcmVhU3R5bGUnLCAnbGluZVN0eWxlJywgJ25vZGVTdHlsZScsICdsaW5rU3R5bGUnLCAnY2hvcmRTdHlsZScsICdsYWJlbCcsICdsYWJlbExpbmUnXTtcblxuZnVuY3Rpb24gY29tcGF0SXRlbVN0eWxlKG9wdCkge1xuICB2YXIgaXRlbVN0eWxlT3B0ID0gb3B0ICYmIG9wdC5pdGVtU3R5bGU7XG5cbiAgaWYgKCFpdGVtU3R5bGVPcHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gUE9TU0lCTEVfU1RZTEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHN0eWxlTmFtZSA9IFBPU1NJQkxFX1NUWUxFU1tpXTtcbiAgICB2YXIgbm9ybWFsSXRlbVN0eWxlT3B0ID0gaXRlbVN0eWxlT3B0Lm5vcm1hbDtcbiAgICB2YXIgZW1waGFzaXNJdGVtU3R5bGVPcHQgPSBpdGVtU3R5bGVPcHQuZW1waGFzaXM7XG5cbiAgICBpZiAobm9ybWFsSXRlbVN0eWxlT3B0ICYmIG5vcm1hbEl0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdKSB7XG4gICAgICBvcHRbc3R5bGVOYW1lXSA9IG9wdFtzdHlsZU5hbWVdIHx8IHt9O1xuXG4gICAgICBpZiAoIW9wdFtzdHlsZU5hbWVdLm5vcm1hbCkge1xuICAgICAgICBvcHRbc3R5bGVOYW1lXS5ub3JtYWwgPSBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpyVXRpbC5tZXJnZShvcHRbc3R5bGVOYW1lXS5ub3JtYWwsIG5vcm1hbEl0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0gPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChlbXBoYXNpc0l0ZW1TdHlsZU9wdCAmJiBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdKSB7XG4gICAgICBvcHRbc3R5bGVOYW1lXSA9IG9wdFtzdHlsZU5hbWVdIHx8IHt9O1xuXG4gICAgICBpZiAoIW9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzKSB7XG4gICAgICAgIG9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzID0gZW1waGFzaXNJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpyVXRpbC5tZXJnZShvcHRbc3R5bGVOYW1lXS5lbXBoYXNpcywgZW1waGFzaXNJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXRUZXh0U3R5bGUob3B0LCBwcm9wTmFtZSkge1xuICB2YXIgbGFiZWxPcHRTaW5nbGUgPSBpc09iamVjdChvcHQpICYmIG9wdFtwcm9wTmFtZV07XG4gIHZhciB0ZXh0U3R5bGUgPSBpc09iamVjdChsYWJlbE9wdFNpbmdsZSkgJiYgbGFiZWxPcHRTaW5nbGUudGV4dFN0eWxlO1xuXG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbW9kZWxVdGlsLlRFWFRfU1RZTEVfT1BUSU9OUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHByb3BOYW1lID0gbW9kZWxVdGlsLlRFWFRfU1RZTEVfT1BUSU9OU1tpXTtcblxuICAgICAgaWYgKHRleHRTdHlsZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgbGFiZWxPcHRTaW5nbGVbcHJvcE5hbWVdID0gdGV4dFN0eWxlW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGF0TGFiZWxUZXh0U3R5bGUobGFiZWxPcHQpIHtcbiAgaWYgKGlzT2JqZWN0KGxhYmVsT3B0KSkge1xuICAgIGNvbXBhdFRleHRTdHlsZShsYWJlbE9wdCwgJ25vcm1hbCcpO1xuICAgIGNvbXBhdFRleHRTdHlsZShsYWJlbE9wdCwgJ2VtcGhhc2lzJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1NlcmllcyhzZXJpZXNPcHQpIHtcbiAgaWYgKCFpc09iamVjdChzZXJpZXNPcHQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29tcGF0SXRlbVN0eWxlKHNlcmllc09wdCk7XG4gIGNvbXBhdExhYmVsVGV4dFN0eWxlKHNlcmllc09wdC5sYWJlbCk7IC8vIHRyZWVtYXBcblxuICBjb21wYXRMYWJlbFRleHRTdHlsZShzZXJpZXNPcHQudXBwZXJMYWJlbCk7IC8vIGdyYXBoXG5cbiAgY29tcGF0TGFiZWxUZXh0U3R5bGUoc2VyaWVzT3B0LmVkZ2VMYWJlbCk7XG4gIHZhciBtYXJrUG9pbnQgPSBzZXJpZXNPcHQubWFya1BvaW50O1xuICBjb21wYXRJdGVtU3R5bGUobWFya1BvaW50KTtcbiAgY29tcGF0TGFiZWxUZXh0U3R5bGUobWFya1BvaW50ICYmIG1hcmtQb2ludC5sYWJlbCk7XG4gIHZhciBtYXJrTGluZSA9IHNlcmllc09wdC5tYXJrTGluZTtcbiAgY29tcGF0SXRlbVN0eWxlKHNlcmllc09wdC5tYXJrTGluZSk7XG4gIGNvbXBhdExhYmVsVGV4dFN0eWxlKG1hcmtMaW5lICYmIG1hcmtMaW5lLmxhYmVsKTtcbiAgdmFyIG1hcmtBcmVhID0gc2VyaWVzT3B0Lm1hcmtBcmVhO1xuICBjb21wYXRMYWJlbFRleHRTdHlsZShtYXJrQXJlYSAmJiBtYXJrQXJlYS5sYWJlbCk7IC8vIEZvciBnYXVnZVxuXG4gIGNvbXBhdFRleHRTdHlsZShzZXJpZXNPcHQsICdheGlzTGFiZWwnKTtcbiAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ3RpdGxlJyk7XG4gIGNvbXBhdFRleHRTdHlsZShzZXJpZXNPcHQsICdkZXRhaWwnKTtcbiAgdmFyIGRhdGEgPSBzZXJpZXNPcHQuZGF0YTtcblxuICBpZiAoZGF0YSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29tcGF0SXRlbVN0eWxlKGRhdGFbaV0pO1xuICAgICAgY29tcGF0TGFiZWxUZXh0U3R5bGUoZGF0YVtpXSAmJiBkYXRhW2ldLmxhYmVsKTtcbiAgICB9XG4gIH0gLy8gbWFyayBwb2ludCBkYXRhXG5cblxuICB2YXIgbWFya1BvaW50ID0gc2VyaWVzT3B0Lm1hcmtQb2ludDtcblxuICBpZiAobWFya1BvaW50ICYmIG1hcmtQb2ludC5kYXRhKSB7XG4gICAgdmFyIG1wRGF0YSA9IG1hcmtQb2ludC5kYXRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtcERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbXBhdEl0ZW1TdHlsZShtcERhdGFbaV0pO1xuICAgICAgY29tcGF0TGFiZWxUZXh0U3R5bGUobXBEYXRhW2ldICYmIG1wRGF0YVtpXS5sYWJlbCk7XG4gICAgfVxuICB9IC8vIG1hcmsgbGluZSBkYXRhXG5cblxuICB2YXIgbWFya0xpbmUgPSBzZXJpZXNPcHQubWFya0xpbmU7XG5cbiAgaWYgKG1hcmtMaW5lICYmIG1hcmtMaW5lLmRhdGEpIHtcbiAgICB2YXIgbWxEYXRhID0gbWFya0xpbmUuZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoenJVdGlsLmlzQXJyYXkobWxEYXRhW2ldKSkge1xuICAgICAgICBjb21wYXRJdGVtU3R5bGUobWxEYXRhW2ldWzBdKTtcbiAgICAgICAgY29tcGF0TGFiZWxUZXh0U3R5bGUobWxEYXRhW2ldWzBdICYmIG1sRGF0YVtpXVswXS5sYWJlbCk7XG4gICAgICAgIGNvbXBhdEl0ZW1TdHlsZShtbERhdGFbaV1bMV0pO1xuICAgICAgICBjb21wYXRMYWJlbFRleHRTdHlsZShtbERhdGFbaV1bMV0gJiYgbWxEYXRhW2ldWzFdLmxhYmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBhdEl0ZW1TdHlsZShtbERhdGFbaV0pO1xuICAgICAgICBjb21wYXRMYWJlbFRleHRTdHlsZShtbERhdGFbaV0gJiYgbWxEYXRhW2ldLmxhYmVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9BcnIobykge1xuICByZXR1cm4genJVdGlsLmlzQXJyYXkobykgPyBvIDogbyA/IFtvXSA6IFtdO1xufVxuXG5mdW5jdGlvbiB0b09iaihvKSB7XG4gIHJldHVybiAoenJVdGlsLmlzQXJyYXkobykgPyBvWzBdIDogbykgfHwge307XG59XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KG9wdGlvbiwgaXNUaGVtZSkge1xuICBlYWNoKHRvQXJyKG9wdGlvbi5zZXJpZXMpLCBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgaXNPYmplY3Qoc2VyaWVzT3B0KSAmJiBwcm9jZXNzU2VyaWVzKHNlcmllc09wdCk7XG4gIH0pO1xuICB2YXIgYXhlcyA9IFsneEF4aXMnLCAneUF4aXMnLCAncmFkaXVzQXhpcycsICdhbmdsZUF4aXMnLCAnc2luZ2xlQXhpcycsICdwYXJhbGxlbEF4aXMnLCAncmFkYXInXTtcbiAgaXNUaGVtZSAmJiBheGVzLnB1c2goJ3ZhbHVlQXhpcycsICdjYXRlZ29yeUF4aXMnLCAnbG9nQXhpcycsICd0aW1lQXhpcycpO1xuICBlYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzTmFtZSkge1xuICAgIGVhY2godG9BcnIob3B0aW9uW2F4aXNOYW1lXSksIGZ1bmN0aW9uIChheGlzT3B0KSB7XG4gICAgICBpZiAoYXhpc09wdCkge1xuICAgICAgICBjb21wYXRUZXh0U3R5bGUoYXhpc09wdCwgJ2F4aXNMYWJlbCcpO1xuICAgICAgICBjb21wYXRUZXh0U3R5bGUoYXhpc09wdC5heGlzUG9pbnRlciwgJ2xhYmVsJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBlYWNoKHRvQXJyKG9wdGlvbi5wYXJhbGxlbCksIGZ1bmN0aW9uIChwYXJhbGxlbE9wdCkge1xuICAgIHZhciBwYXJhbGxlbEF4aXNEZWZhdWx0ID0gcGFyYWxsZWxPcHQgJiYgcGFyYWxsZWxPcHQucGFyYWxsZWxBeGlzRGVmYXVsdDtcbiAgICBjb21wYXRUZXh0U3R5bGUocGFyYWxsZWxBeGlzRGVmYXVsdCwgJ2F4aXNMYWJlbCcpO1xuICAgIGNvbXBhdFRleHRTdHlsZShwYXJhbGxlbEF4aXNEZWZhdWx0ICYmIHBhcmFsbGVsQXhpc0RlZmF1bHQuYXhpc1BvaW50ZXIsICdsYWJlbCcpO1xuICB9KTtcbiAgZWFjaCh0b0FycihvcHRpb24uY2FsZW5kYXIpLCBmdW5jdGlvbiAoY2FsZW5kYXJPcHQpIHtcbiAgICBjb21wYXRUZXh0U3R5bGUoY2FsZW5kYXJPcHQsICdkYXlMYWJlbCcpO1xuICAgIGNvbXBhdFRleHRTdHlsZShjYWxlbmRhck9wdCwgJ21vbnRoTGFiZWwnKTtcbiAgICBjb21wYXRUZXh0U3R5bGUoY2FsZW5kYXJPcHQsICd5ZWFyTGFiZWwnKTtcbiAgfSk7IC8vIHJhZGFyLm5hbWUudGV4dFN0eWxlXG5cbiAgZWFjaCh0b0FycihvcHRpb24ucmFkYXIpLCBmdW5jdGlvbiAocmFkYXJPcHQpIHtcbiAgICBjb21wYXRUZXh0U3R5bGUocmFkYXJPcHQsICduYW1lJyk7XG4gIH0pO1xuICBlYWNoKHRvQXJyKG9wdGlvbi5nZW8pLCBmdW5jdGlvbiAoZ2VvT3B0KSB7XG4gICAgaWYgKGlzT2JqZWN0KGdlb09wdCkpIHtcbiAgICAgIGNvbXBhdExhYmVsVGV4dFN0eWxlKGdlb09wdC5sYWJlbCk7XG4gICAgICBlYWNoKHRvQXJyKGdlb09wdC5yZWdpb25zKSwgZnVuY3Rpb24gKHJlZ2lvbk9iaikge1xuICAgICAgICBjb21wYXRMYWJlbFRleHRTdHlsZShyZWdpb25PYmoubGFiZWwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgY29tcGF0TGFiZWxUZXh0U3R5bGUodG9PYmoob3B0aW9uLnRpbWVsaW5lKS5sYWJlbCk7XG4gIGNvbXBhdFRleHRTdHlsZSh0b09iaihvcHRpb24uYXhpc1BvaW50ZXIpLCAnbGFiZWwnKTtcbiAgY29tcGF0VGV4dFN0eWxlKHRvT2JqKG9wdGlvbi50b29sdGlwKS5heGlzUG9pbnRlciwgJ2xhYmVsJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJlcHJvY2Vzc29yL2hlbHBlci9jb21wYXRTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJlcHJvY2Vzc29yL2hlbHBlci9jb21wYXRTdHlsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBzYW1wbGVycyA9IHtcbiAgYXZlcmFnZTogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghaXNOYU4oZnJhbWVbaV0pKSB7XG4gICAgICAgIHN1bSArPSBmcmFtZVtpXTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9IC8vIFJldHVybiBOYU4gaWYgY291bnQgaXMgMFxuXG5cbiAgICByZXR1cm4gY291bnQgPT09IDAgPyBOYU4gOiBzdW0gLyBjb3VudDtcbiAgfSxcbiAgc3VtOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgc3VtID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIElnbm9yZSBOYU5cbiAgICAgIHN1bSArPSBmcmFtZVtpXSB8fCAwO1xuICAgIH1cblxuICAgIHJldHVybiBzdW07XG4gIH0sXG4gIG1heDogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYW1lW2ldID4gbWF4ICYmIChtYXggPSBmcmFtZVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heDtcbiAgfSxcbiAgbWluOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFtZVtpXSA8IG1pbiAmJiAobWluID0gZnJhbWVbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBtaW47XG4gIH0sXG4gIC8vIFRPRE9cbiAgLy8gTWVkaWFuXG4gIG5lYXJlc3Q6IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHJldHVybiBmcmFtZVswXTtcbiAgfVxufTtcblxudmFyIGluZGV4U2FtcGxlciA9IGZ1bmN0aW9uIChmcmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoZnJhbWUubGVuZ3RoIC8gMik7XG59O1xuXG5mdW5jdGlvbiBfZGVmYXVsdChzZXJpZXNUeXBlLCBlY01vZGVsLCBhcGkpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBzYW1wbGluZyA9IHNlcmllc01vZGVsLmdldCgnc2FtcGxpbmcnKTtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtOyAvLyBPbmx5IGNhcnRlc2lhbjJkIHN1cHBvcnQgZG93biBzYW1wbGluZ1xuXG4gICAgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgJiYgc2FtcGxpbmcpIHtcbiAgICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICB2YXIgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgICAgIHZhciBleHRlbnQgPSBiYXNlQXhpcy5nZXRFeHRlbnQoKTsgLy8gQ29vcmRpbnN0ZSBzeXN0ZW0gaGFzIGJlZW4gcmVzaXplZFxuXG4gICAgICB2YXIgc2l6ZSA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgIHZhciByYXRlID0gTWF0aC5yb3VuZChkYXRhLmNvdW50KCkgLyBzaXplKTtcblxuICAgICAgaWYgKHJhdGUgPiAxKSB7XG4gICAgICAgIHZhciBzYW1wbGVyO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2FtcGxpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgc2FtcGxlciA9IHNhbXBsZXJzW3NhbXBsaW5nXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2FtcGxpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYW1wbGVyID0gc2FtcGxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2FtcGxlcikge1xuICAgICAgICAgIGRhdGEgPSBkYXRhLmRvd25TYW1wbGUodmFsdWVBeGlzLmRpbSwgMSAvIHJhdGUsIHNhbXBsZXIsIGluZGV4U2FtcGxlcik7XG4gICAgICAgICAgc2VyaWVzTW9kZWwuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJvY2Vzc29yL2RhdGFTYW1wbGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBmb3JtYXRVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvZm9ybWF0XCIpO1xuXG52YXIgU2NhbGUgPSByZXF1aXJlKFwiLi9TY2FsZVwiKTtcblxudmFyIGhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxuLyoqXG4gKiBJbnRlcnZhbCBzY2FsZVxuICogQG1vZHVsZSBlY2hhcnRzL3NjYWxlL0ludGVydmFsXG4gKi9cbnZhciByb3VuZE51bWJlciA9IG51bWJlclV0aWwucm91bmQ7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9zY2FsZS9JbnRlcnZhbFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIEludGVydmFsU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuICB0eXBlOiAnaW50ZXJ2YWwnLFxuICBfaW50ZXJ2YWw6IDAsXG4gIF9pbnRlcnZhbFByZWNpc2lvbjogMixcbiAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciB0aGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50OyAvL3N0YXJ0LGVuZCBtYXkgYmUgYSBOdW1iZXIgbGlrZSAnMjUnLHNvLi4uXG5cbiAgICBpZiAoIWlzTmFOKHN0YXJ0KSkge1xuICAgICAgdGhpc0V4dGVudFswXSA9IHBhcnNlRmxvYXQoc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICghaXNOYU4oZW5kKSkge1xuICAgICAgdGhpc0V4dGVudFsxXSA9IHBhcnNlRmxvYXQoZW5kKTtcbiAgICB9XG4gIH0sXG4gIHVuaW9uRXh0ZW50OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIG90aGVyWzBdIDwgZXh0ZW50WzBdICYmIChleHRlbnRbMF0gPSBvdGhlclswXSk7XG4gICAgb3RoZXJbMV0gPiBleHRlbnRbMV0gJiYgKGV4dGVudFsxXSA9IG90aGVyWzFdKTsgLy8gdW5pb25FeHRlbnQgbWF5IGNhbGxlZCBieSBpdCdzIHN1YiBjbGFzc2VzXG5cbiAgICBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZS5zZXRFeHRlbnQuY2FsbCh0aGlzLCBleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBpbnRlcnZhbFxuICAgKi9cbiAgZ2V0SW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBpbnRlcnZhbFxuICAgKi9cbiAgc2V0SW50ZXJ2YWw6IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWw7IC8vIERyb3BwZWQgYXV0byBjYWxjdWxhdGVkIG5pY2VFeHRlbnQgYW5kIHVzZSB1c2VyIHNldHRlZCBleHRlbnRcbiAgICAvLyBXZSBhc3N1bWUgdXNlciB3YW4ndCB0byBzZXQgYm90aCBpbnRlcnZhbCwgbWluLCBtYXggdG8gZ2V0IGEgYmV0dGVyIHJlc3VsdFxuXG4gICAgdGhpcy5fbmljZUV4dGVudCA9IHRoaXMuX2V4dGVudC5zbGljZSgpO1xuICAgIHRoaXMuX2ludGVydmFsUHJlY2lzaW9uID0gaGVscGVyLmdldEludGVydmFsUHJlY2lzaW9uKGludGVydmFsKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBnZXRUaWNrczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoZWxwZXIuaW50ZXJ2YWxTY2FsZUdldFRpY2tzKHRoaXMuX2ludGVydmFsLCB0aGlzLl9leHRlbnQsIHRoaXMuX25pY2VFeHRlbnQsIHRoaXMuX2ludGVydmFsUHJlY2lzaW9uKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuICBnZXRUaWNrc0xhYmVsczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICB2YXIgdGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsYWJlbHMucHVzaCh0aGlzLmdldExhYmVsKHRpY2tzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVscztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdC5wcmVjaXNpb25dIElmICdhdXRvJywgdXNlIG5pY2UgcHJlc2lzaW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQucGFkXSByZXR1cm5zIDEuNTAgYnV0IG5vdCAxLjUgaWYgcHJlY2lzaW9uIGlzIDIuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldExhYmVsOiBmdW5jdGlvbiAoZGF0YSwgb3B0KSB7XG4gICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBwcmVjaXNpb24gPSBvcHQgJiYgb3B0LnByZWNpc2lvbjtcblxuICAgIGlmIChwcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgcHJlY2lzaW9uID0gbnVtYmVyVXRpbC5nZXRQcmVjaXNpb25TYWZlKGRhdGEpIHx8IDA7XG4gICAgfSBlbHNlIGlmIChwcmVjaXNpb24gPT09ICdhdXRvJykge1xuICAgICAgLy8gU2hvdWxkIGJlIG1vcmUgcHJlY2lzZSB0aGVuIHRpY2suXG4gICAgICBwcmVjaXNpb24gPSB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbjtcbiAgICB9IC8vICgxKSBJZiBgcHJlY2lzaW9uYCBpcyBzZXQsIDEyLjAwNSBzaG91bGQgYmUgZGlzcGxheSBhcyAnMTIuMDA1MDAnLlxuICAgIC8vICgyKSBVc2Ugcm91bmROdW1iZXIgKHRvRml4ZWQpIHRvIGF2b2lkIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAnMy41ZS03Jy5cblxuXG4gICAgZGF0YSA9IHJvdW5kTnVtYmVyKGRhdGEsIHByZWNpc2lvbiwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZvcm1hdFV0aWwuYWRkQ29tbWFzKGRhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgaW50ZXJ2YWwgYW5kIGV4dGVudCBvZiBpbnRlcnZhbHMgZm9yIG5pY2UgdGlja3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzcGxpdE51bWJlciA9IDVdIERlc2lyZWQgbnVtYmVyIG9mIHRpY2tzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluSW50ZXJ2YWxdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4SW50ZXJ2YWxdXG4gICAqL1xuICBuaWNlVGlja3M6IGZ1bmN0aW9uIChzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwsIG1heEludGVydmFsKSB7XG4gICAgc3BsaXROdW1iZXIgPSBzcGxpdE51bWJlciB8fCA1O1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG5cbiAgICBpZiAoIWlzRmluaXRlKHNwYW4pKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBVc2VyIG1heSBzZXQgYXhpcyBtaW4gMCBhbmQgZGF0YSBhcmUgYWxsIG5lZ2F0aXZlXG4gICAgLy8gRklYTUUgSWYgaXQgbmVlZHMgdG8gcmV2ZXJzZSA/XG5cblxuICAgIGlmIChzcGFuIDwgMCkge1xuICAgICAgc3BhbiA9IC1zcGFuO1xuICAgICAgZXh0ZW50LnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gaGVscGVyLmludGVydmFsU2NhbGVOaWNlVGlja3MoZXh0ZW50LCBzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwsIG1heEludGVydmFsKTtcbiAgICB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbiA9IHJlc3VsdC5pbnRlcnZhbFByZWNpc2lvbjtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbDtcbiAgICB0aGlzLl9uaWNlRXh0ZW50ID0gcmVzdWx0Lm5pY2VUaWNrRXh0ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBOaWNlIGV4dGVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zcGxpdE51bWJlciA9IDVdIEdpdmVuIGFwcHJveCB0aWNrIG51bWJlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuZml4TWluPWZhbHNlXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuZml4TWF4PWZhbHNlXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQubWluSW50ZXJ2YWxdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5tYXhJbnRlcnZhbF1cbiAgICovXG4gIG5pY2VFeHRlbnQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50OyAvLyBJZiBleHRlbnQgc3RhcnQgYW5kIGVuZCBhcmUgc2FtZSwgZXhwYW5kIHRoZW1cblxuICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgaWYgKGV4dGVudFswXSAhPT0gMCkge1xuICAgICAgICAvLyBFeHBhbmQgZXh0ZW50XG4gICAgICAgIHZhciBleHBhbmRTaXplID0gZXh0ZW50WzBdOyAvLyBJbiB0aGUgZm93bGxvd2luZyBjYXNlXG4gICAgICAgIC8vICAgICAgQXhpcyBoYXMgYmVlbiBmaXhlZCBtYXggMTAwXG4gICAgICAgIC8vICAgICAgUGx1cyBkYXRhIGFyZSBhbGwgMTAwIGFuZCBheGlzIGV4dGVudCBhcmUgWzEwMCwgMTAwXS5cbiAgICAgICAgLy8gRXh0ZW5kIHRvIHRoZSBib3RoIHNpZGUgd2lsbCBjYXVzZSBleHBhbmRlZCBtYXggaXMgbGFyZ2VyIHRoYW4gZml4ZWQgbWF4LlxuICAgICAgICAvLyBTbyBvbmx5IGV4cGFuZCB0byB0aGUgc21hbGxlciBzaWRlLlxuXG4gICAgICAgIGlmICghb3B0LmZpeE1heCkge1xuICAgICAgICAgIGV4dGVudFsxXSArPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgICBleHRlbnRbMF0gLT0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0ZW50WzBdIC09IGV4cGFuZFNpemUgLyAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlbnRbMV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdOyAvLyBJZiB0aGVyZSBhcmUgbm8gZGF0YSBhbmQgZXh0ZW50IGFyZSBbSW5maW5pdHksIC1JbmZpbml0eV1cblxuICAgIGlmICghaXNGaW5pdGUoc3BhbikpIHtcbiAgICAgIGV4dGVudFswXSA9IDA7XG4gICAgICBleHRlbnRbMV0gPSAxO1xuICAgIH1cblxuICAgIHRoaXMubmljZVRpY2tzKG9wdC5zcGxpdE51bWJlciwgb3B0Lm1pbkludGVydmFsLCBvcHQubWF4SW50ZXJ2YWwpOyAvLyB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuXG4gICAgdmFyIGludGVydmFsID0gdGhpcy5faW50ZXJ2YWw7XG5cbiAgICBpZiAoIW9wdC5maXhNaW4pIHtcbiAgICAgIGV4dGVudFswXSA9IHJvdW5kTnVtYmVyKE1hdGguZmxvb3IoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIGlmICghb3B0LmZpeE1heCkge1xuICAgICAgZXh0ZW50WzFdID0gcm91bmROdW1iZXIoTWF0aC5jZWlsKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICB9XG4gIH1cbn0pO1xuLyoqXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lfVxuICovXG5cbkludGVydmFsU2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IEludGVydmFsU2NhbGUoKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IEludGVydmFsU2NhbGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL0ludGVydmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9JbnRlcnZhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgU2NhbGUgPSByZXF1aXJlKFwiLi9TY2FsZVwiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBJbnRlcnZhbFNjYWxlID0gcmVxdWlyZShcIi4vSW50ZXJ2YWxcIik7XG5cbi8qKlxuICogTG9nIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvc2NhbGUvTG9nXG4gKi9cbi8vIFVzZSBzb21lIG1ldGhvZCBvZiBJbnRlcnZhbFNjYWxlXG52YXIgc2NhbGVQcm90byA9IFNjYWxlLnByb3RvdHlwZTtcbnZhciBpbnRlcnZhbFNjYWxlUHJvdG8gPSBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZTtcbnZhciBnZXRQcmVjaXNpb25TYWZlID0gbnVtYmVyVXRpbC5nZXRQcmVjaXNpb25TYWZlO1xudmFyIHJvdW5kaW5nRXJyb3JGaXggPSBudW1iZXJVdGlsLnJvdW5kO1xudmFyIG1hdGhGbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbWF0aENlaWwgPSBNYXRoLmNlaWw7XG52YXIgbWF0aFBvdyA9IE1hdGgucG93O1xudmFyIG1hdGhMb2cgPSBNYXRoLmxvZztcbnZhciBMb2dTY2FsZSA9IFNjYWxlLmV4dGVuZCh7XG4gIHR5cGU6ICdsb2cnLFxuICBiYXNlOiAxMCxcbiAgJGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgU2NhbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLl9vcmlnaW5hbFNjYWxlID0gbmV3IEludGVydmFsU2NhbGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBnZXRUaWNrczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmlnaW5hbFNjYWxlID0gdGhpcy5fb3JpZ2luYWxTY2FsZTtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBvcmlnaW5hbEV4dGVudCA9IG9yaWdpbmFsU2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgcmV0dXJuIHpyVXRpbC5tYXAoaW50ZXJ2YWxTY2FsZVByb3RvLmdldFRpY2tzLmNhbGwodGhpcyksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHZhciBwb3dWYWwgPSBudW1iZXJVdGlsLnJvdW5kKG1hdGhQb3codGhpcy5iYXNlLCB2YWwpKTsgLy8gRml4ICM0MTU4XG5cbiAgICAgIHBvd1ZhbCA9IHZhbCA9PT0gZXh0ZW50WzBdICYmIG9yaWdpbmFsU2NhbGUuX19maXhNaW4gPyBmaXhSb3VuZGluZ0Vycm9yKHBvd1ZhbCwgb3JpZ2luYWxFeHRlbnRbMF0pIDogcG93VmFsO1xuICAgICAgcG93VmFsID0gdmFsID09PSBleHRlbnRbMV0gJiYgb3JpZ2luYWxTY2FsZS5fX2ZpeE1heCA/IGZpeFJvdW5kaW5nRXJyb3IocG93VmFsLCBvcmlnaW5hbEV4dGVudFsxXSkgOiBwb3dWYWw7XG4gICAgICByZXR1cm4gcG93VmFsO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldExhYmVsOiBpbnRlcnZhbFNjYWxlUHJvdG8uZ2V0TGFiZWwsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHNjYWxlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gc2NhbGVQcm90by5zY2FsZS5jYWxsKHRoaXMsIHZhbCk7XG4gICAgcmV0dXJuIG1hdGhQb3codGhpcy5iYXNlLCB2YWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgKi9cbiAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgIHN0YXJ0ID0gbWF0aExvZyhzdGFydCkgLyBtYXRoTG9nKGJhc2UpO1xuICAgIGVuZCA9IG1hdGhMb2coZW5kKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgaW50ZXJ2YWxTY2FsZVByb3RvLnNldEV4dGVudC5jYWxsKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGVuZFxuICAgKi9cbiAgZ2V0RXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgdmFyIGV4dGVudCA9IHNjYWxlUHJvdG8uZ2V0RXh0ZW50LmNhbGwodGhpcyk7XG4gICAgZXh0ZW50WzBdID0gbWF0aFBvdyhiYXNlLCBleHRlbnRbMF0pO1xuICAgIGV4dGVudFsxXSA9IG1hdGhQb3coYmFzZSwgZXh0ZW50WzFdKTsgLy8gRml4ICM0MTU4XG5cbiAgICB2YXIgb3JpZ2luYWxTY2FsZSA9IHRoaXMuX29yaWdpbmFsU2NhbGU7XG4gICAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gb3JpZ2luYWxTY2FsZS5nZXRFeHRlbnQoKTtcbiAgICBvcmlnaW5hbFNjYWxlLl9fZml4TWluICYmIChleHRlbnRbMF0gPSBmaXhSb3VuZGluZ0Vycm9yKGV4dGVudFswXSwgb3JpZ2luYWxFeHRlbnRbMF0pKTtcbiAgICBvcmlnaW5hbFNjYWxlLl9fZml4TWF4ICYmIChleHRlbnRbMV0gPSBmaXhSb3VuZGluZ0Vycm9yKGV4dGVudFsxXSwgb3JpZ2luYWxFeHRlbnRbMV0pKTtcbiAgICByZXR1cm4gZXh0ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZXh0ZW50XG4gICAqL1xuICB1bmlvbkV4dGVudDogZnVuY3Rpb24gKGV4dGVudCkge1xuICAgIHRoaXMuX29yaWdpbmFsU2NhbGUudW5pb25FeHRlbnQoZXh0ZW50KTtcblxuICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgIGV4dGVudFswXSA9IG1hdGhMb2coZXh0ZW50WzBdKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgZXh0ZW50WzFdID0gbWF0aExvZyhleHRlbnRbMV0pIC8gbWF0aExvZyhiYXNlKTtcbiAgICBzY2FsZVByb3RvLnVuaW9uRXh0ZW50LmNhbGwodGhpcywgZXh0ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB1bmlvbkV4dGVudEZyb21EYXRhOiBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gICAgdGhpcy51bmlvbkV4dGVudChkYXRhLmdldERhdGFFeHRlbnQoZGltLCB0cnVlLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gdmFsID4gMDtcbiAgICB9KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBpbnRlcnZhbCBhbmQgZXh0ZW50IG9mIGludGVydmFscyBmb3IgbmljZSB0aWNrc1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFthcHByb3hUaWNrTnVtID0gMTBdIEdpdmVuIGFwcHJveCB0aWNrIG51bWJlclxuICAgKi9cbiAgbmljZVRpY2tzOiBmdW5jdGlvbiAoYXBwcm94VGlja051bSkge1xuICAgIGFwcHJveFRpY2tOdW0gPSBhcHByb3hUaWNrTnVtIHx8IDEwO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG5cbiAgICBpZiAoc3BhbiA9PT0gSW5maW5pdHkgfHwgc3BhbiA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGludGVydmFsID0gbnVtYmVyVXRpbC5xdWFudGl0eShzcGFuKTtcbiAgICB2YXIgZXJyID0gYXBwcm94VGlja051bSAvIHNwYW4gKiBpbnRlcnZhbDsgLy8gRmlsdGVyIHRpY2tzIHRvIGdldCBjbG9zZXIgdG8gdGhlIGRlc2lyZWQgY291bnQuXG5cbiAgICBpZiAoZXJyIDw9IDAuNSkge1xuICAgICAgaW50ZXJ2YWwgKj0gMTA7XG4gICAgfSAvLyBJbnRlcnZhbCBzaG91bGQgYmUgaW50ZWdlclxuXG5cbiAgICB3aGlsZSAoIWlzTmFOKGludGVydmFsKSAmJiBNYXRoLmFicyhpbnRlcnZhbCkgPCAxICYmIE1hdGguYWJzKGludGVydmFsKSA+IDApIHtcbiAgICAgIGludGVydmFsICo9IDEwO1xuICAgIH1cblxuICAgIHZhciBuaWNlRXh0ZW50ID0gW251bWJlclV0aWwucm91bmQobWF0aENlaWwoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpLCBudW1iZXJVdGlsLnJvdW5kKG1hdGhGbG9vcihleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCldO1xuICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgdGhpcy5fbmljZUV4dGVudCA9IG5pY2VFeHRlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5pY2UgZXh0ZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG5pY2VFeHRlbnQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICBpbnRlcnZhbFNjYWxlUHJvdG8ubmljZUV4dGVudC5jYWxsKHRoaXMsIG9wdCk7XG4gICAgdmFyIG9yaWdpbmFsU2NhbGUgPSB0aGlzLl9vcmlnaW5hbFNjYWxlO1xuICAgIG9yaWdpbmFsU2NhbGUuX19maXhNaW4gPSBvcHQuZml4TWluO1xuICAgIG9yaWdpbmFsU2NhbGUuX19maXhNYXggPSBvcHQuZml4TWF4O1xuICB9XG59KTtcbnpyVXRpbC5lYWNoKFsnY29udGFpbicsICdub3JtYWxpemUnXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgTG9nU2NhbGUucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IG1hdGhMb2codmFsKSAvIG1hdGhMb2codGhpcy5iYXNlKTtcbiAgICByZXR1cm4gc2NhbGVQcm90b1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIHZhbCk7XG4gIH07XG59KTtcblxuTG9nU2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IExvZ1NjYWxlKCk7XG59O1xuXG5mdW5jdGlvbiBmaXhSb3VuZGluZ0Vycm9yKHZhbCwgb3JpZ2luYWxWYWwpIHtcbiAgcmV0dXJuIHJvdW5kaW5nRXJyb3JGaXgodmFsLCBnZXRQcmVjaXNpb25TYWZlKG9yaWdpbmFsVmFsKSk7XG59XG5cbnZhciBfZGVmYXVsdCA9IExvZ1NjYWxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9Mb2cuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL0xvZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgU2NhbGUgPSByZXF1aXJlKFwiLi9TY2FsZVwiKTtcblxuLyoqXG4gKiBMaW5lYXIgY29udGludW91cyBzY2FsZVxuICogQG1vZHVsZSBlY2hhcnRzL2Nvb3JkL3NjYWxlL09yZGluYWxcbiAqXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldmVsX29mX21lYXN1cmVtZW50XG4gKi9cbi8vIEZJWE1FIG9ubHkgb25lIGRhdGFcbnZhciBzY2FsZVByb3RvID0gU2NhbGUucHJvdG90eXBlO1xudmFyIE9yZGluYWxTY2FsZSA9IFNjYWxlLmV4dGVuZCh7XG4gIHR5cGU6ICdvcmRpbmFsJyxcbiAgaW5pdDogZnVuY3Rpb24gKGRhdGEsIGV4dGVudCkge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMuX2V4dGVudCA9IGV4dGVudCB8fCBbMCwgZGF0YS5sZW5ndGggLSAxXTtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyB6clV0aWwuaW5kZXhPZih0aGlzLl9kYXRhLCB2YWwpIC8vIHZhbCBtaWdodCBiZSBmbG9hdC5cbiAgICA6IE1hdGgucm91bmQodmFsKTtcbiAgfSxcbiAgY29udGFpbjogZnVuY3Rpb24gKHJhbmspIHtcbiAgICByYW5rID0gdGhpcy5wYXJzZShyYW5rKTtcbiAgICByZXR1cm4gc2NhbGVQcm90by5jb250YWluLmNhbGwodGhpcywgcmFuaykgJiYgdGhpcy5fZGF0YVtyYW5rXSAhPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgZ2l2ZW4gcmFuayBvciBuYW1lIHRvIGxpbmVhciBbMCwgMV1cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbdmFsXVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBub3JtYWxpemU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gc2NhbGVQcm90by5ub3JtYWxpemUuY2FsbCh0aGlzLCB0aGlzLnBhcnNlKHZhbCkpO1xuICB9LFxuICBzY2FsZTogZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHNjYWxlUHJvdG8uc2NhbGUuY2FsbCh0aGlzLCB2YWwpKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBnZXRUaWNrczogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aWNrcyA9IFtdO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHJhbmsgPSBleHRlbnRbMF07XG5cbiAgICB3aGlsZSAocmFuayA8PSBleHRlbnRbMV0pIHtcbiAgICAgIHRpY2tzLnB1c2gocmFuayk7XG4gICAgICByYW5rKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgaXRlbSBvbiByYW5rIG5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0TGFiZWw6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbbl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dGVudFsxXSAtIHRoaXMuX2V4dGVudFswXSArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdW5pb25FeHRlbnRGcm9tRGF0YTogZnVuY3Rpb24gKGRhdGEsIGRpbSkge1xuICAgIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXREYXRhRXh0ZW50KGRpbSwgZmFsc2UpKTtcbiAgfSxcbiAgbmljZVRpY2tzOiB6clV0aWwubm9vcCxcbiAgbmljZUV4dGVudDogenJVdGlsLm5vb3Bcbn0pO1xuLyoqXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lfVxuICovXG5cbk9yZGluYWxTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgT3JkaW5hbFNjYWxlKCk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBPcmRpbmFsU2NhbGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY2xhenpVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY2xhenpcIik7XG5cbi8qKlxuICogLy8gU2NhbGUgY2xhc3MgbWFuYWdlbWVudFxuICogQG1vZHVsZSBlY2hhcnRzL3NjYWxlL1NjYWxlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gW3NldHRpbmddXG4gKi9cbmZ1bmN0aW9uIFNjYWxlKHNldHRpbmcpIHtcbiAgdGhpcy5fc2V0dGluZyA9IHNldHRpbmcgfHwge307XG4gIC8qKlxuICAgKiBFeHRlbnRcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG4gIHRoaXMuX2V4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgLyoqXG4gICAqIFN0ZXAgaXMgY2FsY3VsYXRlZCBpbiBhZGp1c3RFeHRlbnRcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG4gIHRoaXMuX2ludGVydmFsID0gMDtcbiAgdGhpcy5pbml0ICYmIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLyoqXG4gKiBQYXJzZSBpbnB1dCB2YWwgdG8gdmFsaWQgaW5uZXIgbnVtYmVyLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgLy8gTm90aWNlOiBUaGlzIHdvdWxkIGJlIGEgdHJhcCBoZXJlLCBJZiB0aGUgaW1wbGVtZW50YXRpb25cbiAgLy8gb2YgdGhpcyBtZXRob2QgZGVwZW5kcyBvbiBleHRlbnQsIGFuZCB0aGlzIG1ldGhvZCBpcyB1c2VkXG4gIC8vIGJlZm9yZSBleHRlbnQgc2V0IChsaWtlIGluIGRhdGFab29tKSwgaXQgd291bGQgYmUgd3JvbmcuXG4gIC8vIE5ldmVydGhlbGVzcywgcGFyc2UgZG9lcyBub3QgZGVwZW5kIG9uIGV4dGVudCBnZW5lcmFsbHkuXG4gIHJldHVybiB2YWw7XG59O1xuXG5TY2FsZS5wcm90b3R5cGUuZ2V0U2V0dGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9zZXR0aW5nW25hbWVdO1xufTtcblxuU2NhbGUucHJvdG90eXBlLmNvbnRhaW4gPSBmdW5jdGlvbiAodmFsKSB7XG4gIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gIHJldHVybiB2YWwgPj0gZXh0ZW50WzBdICYmIHZhbCA8PSBleHRlbnRbMV07XG59O1xuLyoqXG4gKiBOb3JtYWxpemUgdmFsdWUgdG8gbGluZWFyIFswLCAxXSwgcmV0dXJuIDAuNSBpZiBleHRlbnQgc3BhbiBpcyAwXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5TY2FsZS5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKHZhbCkge1xuICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuXG4gIGlmIChleHRlbnRbMV0gPT09IGV4dGVudFswXSkge1xuICAgIHJldHVybiAwLjU7XG4gIH1cblxuICByZXR1cm4gKHZhbCAtIGV4dGVudFswXSkgLyAoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKTtcbn07XG4vKipcbiAqIFNjYWxlIG5vcm1hbGl6ZWQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgcmV0dXJuIHZhbCAqIChleHRlbnRbMV0gLSBleHRlbnRbMF0pICsgZXh0ZW50WzBdO1xufTtcbi8qKlxuICogU2V0IGV4dGVudCBmcm9tIGRhdGFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG90aGVyXG4gKi9cblxuXG5TY2FsZS5wcm90b3R5cGUudW5pb25FeHRlbnQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgb3RoZXJbMF0gPCBleHRlbnRbMF0gJiYgKGV4dGVudFswXSA9IG90aGVyWzBdKTtcbiAgb3RoZXJbMV0gPiBleHRlbnRbMV0gJiYgKGV4dGVudFsxXSA9IG90aGVyWzFdKTsgLy8gbm90IHNldEV4dGVudCBiZWNhdXNlIGluIGxvZyBheGlzIGl0IG1heSB0cmFuc2Zvcm1lZCB0byBwb3dlclxuICAvLyB0aGlzLnNldEV4dGVudChleHRlbnRbMF0sIGV4dGVudFsxXSk7XG59O1xuLyoqXG4gKiBTZXQgZXh0ZW50IGZyb20gZGF0YVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS51bmlvbkV4dGVudEZyb21EYXRhID0gZnVuY3Rpb24gKGRhdGEsIGRpbSkge1xuICB0aGlzLnVuaW9uRXh0ZW50KGRhdGEuZ2V0RGF0YUV4dGVudChkaW0sIHRydWUpKTtcbn07XG4vKipcbiAqIEdldCBleHRlbnRcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2V4dGVudC5zbGljZSgpO1xufTtcbi8qKlxuICogU2V0IGV4dGVudFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKi9cblxuXG5TY2FsZS5wcm90b3R5cGUuc2V0RXh0ZW50ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRoaXNFeHRlbnQgPSB0aGlzLl9leHRlbnQ7XG5cbiAgaWYgKCFpc05hTihzdGFydCkpIHtcbiAgICB0aGlzRXh0ZW50WzBdID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoIWlzTmFOKGVuZCkpIHtcbiAgICB0aGlzRXh0ZW50WzFdID0gZW5kO1xuICB9XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS5nZXRUaWNrc0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxhYmVscyA9IFtdO1xuICB2YXIgdGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGxhYmVscy5wdXNoKHRoaXMuZ2V0TGFiZWwodGlja3NbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBsYWJlbHM7XG59O1xuLyoqXG4gKiBXaGVuIGF4aXMgZXh0ZW50IGRlcGVuZHMgb24gZGF0YSBhbmQgbm8gZGF0YSBleGlzdHMsXG4gKiBheGlzIHRpY2tzIHNob3VsZCBub3QgYmUgZHJhd24sIHdoaWNoIGlzIG5hbWVkICdibGFuaycuXG4gKi9cblxuXG5TY2FsZS5wcm90b3R5cGUuaXNCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzQmxhbms7XG59LFxuLyoqXG4gKiBXaGVuIGF4aXMgZXh0ZW50IGRlcGVuZHMgb24gZGF0YSBhbmQgbm8gZGF0YSBleGlzdHMsXG4gKiBheGlzIHRpY2tzIHNob3VsZCBub3QgYmUgZHJhd24sIHdoaWNoIGlzIG5hbWVkICdibGFuaycuXG4gKi9cblNjYWxlLnByb3RvdHlwZS5zZXRCbGFuayA9IGZ1bmN0aW9uIChpc0JsYW5rKSB7XG4gIHRoaXMuX2lzQmxhbmsgPSBpc0JsYW5rO1xufTtcbmNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChTY2FsZSk7XG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KFNjYWxlLCB7XG4gIHJlZ2lzdGVyV2hlbkV4dGVuZDogdHJ1ZVxufSk7XG52YXIgX2RlZmF1bHQgPSBTY2FsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvU2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL1NjYWxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIHNjYWxlSGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuXG52YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoXCIuL0ludGVydmFsXCIpO1xuXG4vLyBbQWJvdXQgVVRDIGFuZCBsb2NhbCB0aW1lIHpvbmVdOlxuLy8gSW4gbW9zdCBjYXNlcywgYG51bWJlci5wYXJzZURhdGVgIHdpbGwgdHJlYXQgaW5wdXQgZGF0YSBzdHJpbmcgYXMgbG9jYWwgdGltZVxuLy8gKGV4Y2VwdCB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkIGluIHRpbWUgc3RyaW5nKS4gQW5kIGBmb3JtYXQuZm9ybWF0ZVRpbWVgIHJldHVybnNcbi8vIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC4gb3B0aW9uLnVzZVVUQyBpcyBmYWxzZSBieSBkZWZhdWx0LiBUaGlzIGRlc2lnbiBoYXZlXG4vLyBjb25jaWRlcmVkIHRoZXNlIGNvbW1vbiBjYXNlOlxuLy8gKDEpIFRpbWUgdGhhdCBpcyBwZXJzaXN0ZW50IGluIHNlcnZlciBpcyBpbiBVVEMsIGJ1dCBpdCBpcyBuZWVkZWQgdG8gYmUgZGlwbGF5ZWRcbi8vIGluIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC5cbi8vICgyKSBCeSBkZWZhdWx0LCB0aGUgaW5wdXQgZGF0YSBzdHJpbmcgKGUuZy4sICcyMDExLTAxLTAyJykgc2hvdWxkIGJlIGRpc3BsYXllZFxuLy8gYXMgaXRzIG9yaWdpbmFsIHRpbWUsIHdpdGhvdXQgYW55IHRpbWUgZGlmZmVyZW5jZS5cbnZhciBpbnRlcnZhbFNjYWxlUHJvdG8gPSBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZTtcbnZhciBtYXRoQ2VpbCA9IE1hdGguY2VpbDtcbnZhciBtYXRoRmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIE9ORV9TRUNPTkQgPSAxMDAwO1xudmFyIE9ORV9NSU5VVEUgPSBPTkVfU0VDT05EICogNjA7XG52YXIgT05FX0hPVVIgPSBPTkVfTUlOVVRFICogNjA7XG52YXIgT05FX0RBWSA9IE9ORV9IT1VSICogMjQ7IC8vIEZJWE1FIOWFrOeUqO+8n1xuXG52YXIgYmlzZWN0ID0gZnVuY3Rpb24gKGEsIHgsIGxvLCBoaSkge1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuXG4gICAgaWYgKGFbbWlkXVsxXSA8IHgpIHtcbiAgICAgIGxvID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvO1xufTtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlL1RpbWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFRpbWVTY2FsZSA9IEludGVydmFsU2NhbGUuZXh0ZW5kKHtcbiAgdHlwZTogJ3RpbWUnLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldExhYmVsOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIHN0ZXBMdmwgPSB0aGlzLl9zdGVwTHZsO1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUodmFsKTtcbiAgICByZXR1cm4gZm9ybWF0VXRpbC5mb3JtYXRUaW1lKHN0ZXBMdmxbMF0sIGRhdGUsIHRoaXMuZ2V0U2V0dGluZygndXNlVVRDJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG5pY2VFeHRlbnQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50OyAvLyBJZiBleHRlbnQgc3RhcnQgYW5kIGVuZCBhcmUgc2FtZSwgZXhwYW5kIHRoZW1cblxuICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgLy8gRXhwYW5kIGV4dGVudFxuICAgICAgZXh0ZW50WzBdIC09IE9ORV9EQVk7XG4gICAgICBleHRlbnRbMV0gKz0gT05FX0RBWTtcbiAgICB9IC8vIElmIHRoZXJlIGFyZSBubyBkYXRhIGFuZCBleHRlbnQgYXJlIFtJbmZpbml0eSwgLUluZmluaXR5XVxuXG5cbiAgICBpZiAoZXh0ZW50WzFdID09PSAtSW5maW5pdHkgJiYgZXh0ZW50WzBdID09PSBJbmZpbml0eSkge1xuICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgZXh0ZW50WzFdID0gK25ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG4gICAgICBleHRlbnRbMF0gPSBleHRlbnRbMV0gLSBPTkVfREFZO1xuICAgIH1cblxuICAgIHRoaXMubmljZVRpY2tzKG9wdC5zcGxpdE51bWJlciwgb3B0Lm1pbkludGVydmFsLCBvcHQubWF4SW50ZXJ2YWwpOyAvLyB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuXG4gICAgdmFyIGludGVydmFsID0gdGhpcy5faW50ZXJ2YWw7XG5cbiAgICBpZiAoIW9wdC5maXhNaW4pIHtcbiAgICAgIGV4dGVudFswXSA9IG51bWJlclV0aWwucm91bmQobWF0aEZsb29yKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdC5maXhNYXgpIHtcbiAgICAgIGV4dGVudFsxXSA9IG51bWJlclV0aWwucm91bmQobWF0aENlaWwoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBuaWNlVGlja3M6IGZ1bmN0aW9uIChhcHByb3hUaWNrTnVtLCBtaW5JbnRlcnZhbCwgbWF4SW50ZXJ2YWwpIHtcbiAgICBhcHByb3hUaWNrTnVtID0gYXBwcm94VGlja051bSB8fCAxMDtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgIHZhciBhcHByb3hJbnRlcnZhbCA9IHNwYW4gLyBhcHByb3hUaWNrTnVtO1xuXG4gICAgaWYgKG1pbkludGVydmFsICE9IG51bGwgJiYgYXBwcm94SW50ZXJ2YWwgPCBtaW5JbnRlcnZhbCkge1xuICAgICAgYXBwcm94SW50ZXJ2YWwgPSBtaW5JbnRlcnZhbDtcbiAgICB9XG5cbiAgICBpZiAobWF4SW50ZXJ2YWwgIT0gbnVsbCAmJiBhcHByb3hJbnRlcnZhbCA+IG1heEludGVydmFsKSB7XG4gICAgICBhcHByb3hJbnRlcnZhbCA9IG1heEludGVydmFsO1xuICAgIH1cblxuICAgIHZhciBzY2FsZUxldmVsc0xlbiA9IHNjYWxlTGV2ZWxzLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gYmlzZWN0KHNjYWxlTGV2ZWxzLCBhcHByb3hJbnRlcnZhbCwgMCwgc2NhbGVMZXZlbHNMZW4pO1xuICAgIHZhciBsZXZlbCA9IHNjYWxlTGV2ZWxzW01hdGgubWluKGlkeCwgc2NhbGVMZXZlbHNMZW4gLSAxKV07XG4gICAgdmFyIGludGVydmFsID0gbGV2ZWxbMV07IC8vIFNhbWUgd2l0aCBpbnRlcnZhbCBzY2FsZSBpZiBzcGFuIGlzIG11Y2ggbGFyZ2VyIHRoYW4gMSB5ZWFyXG5cbiAgICBpZiAobGV2ZWxbMF0gPT09ICd5ZWFyJykge1xuICAgICAgdmFyIHllYXJTcGFuID0gc3BhbiAvIGludGVydmFsOyAvLyBGcm9tIFwiTmljZSBOdW1iZXJzIGZvciBHcmFwaCBMYWJlbHNcIiBvZiBHcmFwaGljIEdlbXNcbiAgICAgIC8vIHZhciBuaWNlWWVhclNwYW4gPSBudW1iZXJVdGlsLm5pY2UoeWVhclNwYW4sIGZhbHNlKTtcblxuICAgICAgdmFyIHllYXJTdGVwID0gbnVtYmVyVXRpbC5uaWNlKHllYXJTcGFuIC8gYXBwcm94VGlja051bSwgdHJ1ZSk7XG4gICAgICBpbnRlcnZhbCAqPSB5ZWFyU3RlcDtcbiAgICB9XG5cbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSB0aGlzLmdldFNldHRpbmcoJ3VzZVVUQycpID8gMCA6IG5ldyBEYXRlKCtleHRlbnRbMF0gfHwgK2V4dGVudFsxXSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMDtcbiAgICB2YXIgbmljZUV4dGVudCA9IFtNYXRoLnJvdW5kKG1hdGhDZWlsKChleHRlbnRbMF0gLSB0aW1lem9uZU9mZnNldCkgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCArIHRpbWV6b25lT2Zmc2V0KSwgTWF0aC5yb3VuZChtYXRoRmxvb3IoKGV4dGVudFsxXSAtIHRpbWV6b25lT2Zmc2V0KSAvIGludGVydmFsKSAqIGludGVydmFsICsgdGltZXpvbmVPZmZzZXQpXTtcbiAgICBzY2FsZUhlbHBlci5maXhFeHRlbnQobmljZUV4dGVudCwgZXh0ZW50KTtcbiAgICB0aGlzLl9zdGVwTHZsID0gbGV2ZWw7IC8vIEludGVydmFsIHdpbGwgYmUgdXNlZCBpbiBnZXRUaWNrc1xuXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICB0aGlzLl9uaWNlRXh0ZW50ID0gbmljZUV4dGVudDtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyB2YWwgbWlnaHQgYmUgZmxvYXQuXG4gICAgcmV0dXJuICtudW1iZXJVdGlsLnBhcnNlRGF0ZSh2YWwpO1xuICB9XG59KTtcbnpyVXRpbC5lYWNoKFsnY29udGFpbicsICdub3JtYWxpemUnXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgVGltZVNjYWxlLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gaW50ZXJ2YWxTY2FsZVByb3RvW21ldGhvZE5hbWVdLmNhbGwodGhpcywgdGhpcy5wYXJzZSh2YWwpKTtcbiAgfTtcbn0pOyAvLyBTdGVwcyBmcm9tIGQzXG5cbnZhciBzY2FsZUxldmVscyA9IFsvLyBGb3JtYXQgICAgICAgICAgICAgIGludGVydmFsXG5bJ2hoOm1tOnNzJywgT05FX1NFQ09ORF0sIC8vIDFzXG5bJ2hoOm1tOnNzJywgT05FX1NFQ09ORCAqIDVdLCAvLyA1c1xuWydoaDptbTpzcycsIE9ORV9TRUNPTkQgKiAxMF0sIC8vIDEwc1xuWydoaDptbTpzcycsIE9ORV9TRUNPTkQgKiAxNV0sIC8vIDE1c1xuWydoaDptbTpzcycsIE9ORV9TRUNPTkQgKiAzMF0sIC8vIDMwc1xuWydoaDptbVxcbk1NLWRkJywgT05FX01JTlVURV0sIC8vIDFtXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfTUlOVVRFICogNV0sIC8vIDVtXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfTUlOVVRFICogMTBdLCAvLyAxMG1cblsnaGg6bW1cXG5NTS1kZCcsIE9ORV9NSU5VVEUgKiAxNV0sIC8vIDE1bVxuWydoaDptbVxcbk1NLWRkJywgT05FX01JTlVURSAqIDMwXSwgLy8gMzBtXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfSE9VUl0sIC8vIDFoXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfSE9VUiAqIDJdLCAvLyAyaFxuWydoaDptbVxcbk1NLWRkJywgT05FX0hPVVIgKiA2XSwgLy8gNmhcblsnaGg6bW1cXG5NTS1kZCcsIE9ORV9IT1VSICogMTJdLCAvLyAxMmhcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWV0sIC8vIDFkXG5bJ01NLWRkXFxueXl5eScsIE9ORV9EQVkgKiAyXSwgLy8gMmRcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWSAqIDNdLCAvLyAzZFxuWydNTS1kZFxcbnl5eXknLCBPTkVfREFZICogNF0sIC8vIDRkXG5bJ01NLWRkXFxueXl5eScsIE9ORV9EQVkgKiA1XSwgLy8gNWRcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWSAqIDZdLCAvLyA2ZFxuWyd3ZWVrJywgT05FX0RBWSAqIDddLCAvLyA3ZFxuWydNTS1kZFxcbnl5eXknLCBPTkVfREFZICogMTBdLCAvLyAxMGRcblsnd2VlaycsIE9ORV9EQVkgKiAxNF0sIC8vIDJ3XG5bJ3dlZWsnLCBPTkVfREFZICogMjFdLCAvLyAzd1xuWydtb250aCcsIE9ORV9EQVkgKiAzMV0sIC8vIDFNXG5bJ3dlZWsnLCBPTkVfREFZICogNDJdLCAvLyA2d1xuWydtb250aCcsIE9ORV9EQVkgKiA2Ml0sIC8vIDJNXG5bJ3dlZWsnLCBPTkVfREFZICogNDJdLCAvLyAxMHdcblsncXVhcnRlcicsIE9ORV9EQVkgKiAzODAgLyA0XSwgLy8gM01cblsnbW9udGgnLCBPTkVfREFZICogMzEgKiA0XSwgLy8gNE1cblsnbW9udGgnLCBPTkVfREFZICogMzEgKiA1XSwgLy8gNU1cblsnaGFsZi15ZWFyJywgT05FX0RBWSAqIDM4MCAvIDJdLCAvLyA2TVxuWydtb250aCcsIE9ORV9EQVkgKiAzMSAqIDhdLCAvLyA4TVxuWydtb250aCcsIE9ORV9EQVkgKiAzMSAqIDEwXSwgLy8gMTBNXG5bJ3llYXInLCBPTkVfREFZICogMzgwXSAvLyAxWVxuXTtcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWV9XG4gKi9cblxuVGltZVNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICByZXR1cm4gbmV3IFRpbWVTY2FsZSh7XG4gICAgdXNlVVRDOiBtb2RlbC5lY01vZGVsLmdldCgndXNlVVRDJylcbiAgfSk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBUaW1lU2NhbGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL1RpbWUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL1RpbWUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL251bWJlclwiKTtcblxuLyoqXG4gKiBGb3IgdGVzdGFibGUuXG4gKi9cbnZhciByb3VuZE51bWJlciA9IG51bWJlclV0aWwucm91bmQ7XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGV4dGVudCBCb3RoIGV4dGVudFswXSBhbmQgZXh0ZW50WzFdIHNob3VsZCBiZSB2YWxpZCBudW1iZXIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2hvdWxkIGJlIGV4dGVudFswXSA8IGV4dGVudFsxXS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGxpdE51bWJlciBzcGxpdE51bWJlciBzaG91bGQgYmUgPj0gMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluSW50ZXJ2YWxdXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEludGVydmFsXVxuICogQHJldHVybiB7T2JqZWN0fSB7aW50ZXJ2YWwsIGludGVydmFsUHJlY2lzaW9uLCBuaWNlVGlja0V4dGVudH1cbiAqL1xuXG5mdW5jdGlvbiBpbnRlcnZhbFNjYWxlTmljZVRpY2tzKGV4dGVudCwgc3BsaXROdW1iZXIsIG1pbkludGVydmFsLCBtYXhJbnRlcnZhbCkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICB2YXIgaW50ZXJ2YWwgPSByZXN1bHQuaW50ZXJ2YWwgPSBudW1iZXJVdGlsLm5pY2Uoc3BhbiAvIHNwbGl0TnVtYmVyLCB0cnVlKTtcblxuICBpZiAobWluSW50ZXJ2YWwgIT0gbnVsbCAmJiBpbnRlcnZhbCA8IG1pbkludGVydmFsKSB7XG4gICAgaW50ZXJ2YWwgPSByZXN1bHQuaW50ZXJ2YWwgPSBtaW5JbnRlcnZhbDtcbiAgfVxuXG4gIGlmIChtYXhJbnRlcnZhbCAhPSBudWxsICYmIGludGVydmFsID4gbWF4SW50ZXJ2YWwpIHtcbiAgICBpbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbCA9IG1heEludGVydmFsO1xuICB9IC8vIFRvdyBtb3JlIGRpZ2l0YWwgZm9yIHRpY2suXG5cblxuICB2YXIgcHJlY2lzaW9uID0gcmVzdWx0LmludGVydmFsUHJlY2lzaW9uID0gZ2V0SW50ZXJ2YWxQcmVjaXNpb24oaW50ZXJ2YWwpOyAvLyBOaWNlZCBleHRlbnQgaW5zaWRlIG9yaWdpbmFsIGV4dGVudFxuXG4gIHZhciBuaWNlVGlja0V4dGVudCA9IHJlc3VsdC5uaWNlVGlja0V4dGVudCA9IFtyb3VuZE51bWJlcihNYXRoLmNlaWwoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwsIHByZWNpc2lvbiksIHJvdW5kTnVtYmVyKE1hdGguZmxvb3IoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwsIHByZWNpc2lvbildO1xuICBmaXhFeHRlbnQobmljZVRpY2tFeHRlbnQsIGV4dGVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbFxuICogQHJldHVybiB7bnVtYmVyfSBpbnRlcnZhbCBwcmVjaXNpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEludGVydmFsUHJlY2lzaW9uKGludGVydmFsKSB7XG4gIC8vIFRvdyBtb3JlIGRpZ2l0YWwgZm9yIHRpY2suXG4gIHJldHVybiBudW1iZXJVdGlsLmdldFByZWNpc2lvblNhZmUoaW50ZXJ2YWwpICsgMjtcbn1cblxuZnVuY3Rpb24gY2xhbXAobmljZVRpY2tFeHRlbnQsIGlkeCwgZXh0ZW50KSB7XG4gIG5pY2VUaWNrRXh0ZW50W2lkeF0gPSBNYXRoLm1heChNYXRoLm1pbihuaWNlVGlja0V4dGVudFtpZHhdLCBleHRlbnRbMV0pLCBleHRlbnRbMF0pO1xufSAvLyBJbiBzb21lIGNhc2VzIChlLmcuLCBzcGxpdE51bWJlciBpcyAxKSwgbmljZVRpY2tFeHRlbnQgbWF5IGJlIG91dCBvZiBleHRlbnQuXG5cblxuZnVuY3Rpb24gZml4RXh0ZW50KG5pY2VUaWNrRXh0ZW50LCBleHRlbnQpIHtcbiAgIWlzRmluaXRlKG5pY2VUaWNrRXh0ZW50WzBdKSAmJiAobmljZVRpY2tFeHRlbnRbMF0gPSBleHRlbnRbMF0pO1xuICAhaXNGaW5pdGUobmljZVRpY2tFeHRlbnRbMV0pICYmIChuaWNlVGlja0V4dGVudFsxXSA9IGV4dGVudFsxXSk7XG4gIGNsYW1wKG5pY2VUaWNrRXh0ZW50LCAwLCBleHRlbnQpO1xuICBjbGFtcChuaWNlVGlja0V4dGVudCwgMSwgZXh0ZW50KTtcblxuICBpZiAobmljZVRpY2tFeHRlbnRbMF0gPiBuaWNlVGlja0V4dGVudFsxXSkge1xuICAgIG5pY2VUaWNrRXh0ZW50WzBdID0gbmljZVRpY2tFeHRlbnRbMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJ2YWxTY2FsZUdldFRpY2tzKGludGVydmFsLCBleHRlbnQsIG5pY2VUaWNrRXh0ZW50LCBpbnRlcnZhbFByZWNpc2lvbikge1xuICB2YXIgdGlja3MgPSBbXTsgLy8gSWYgaW50ZXJ2YWwgaXMgMCwgcmV0dXJuIFtdO1xuXG4gIGlmICghaW50ZXJ2YWwpIHtcbiAgICByZXR1cm4gdGlja3M7XG4gIH0gLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiB1c2luZyBkYXRhWm9vbSB0b29sYm94LCB6b29tIGFuZCB6b29tLlxuXG5cbiAgdmFyIHNhZmVMaW1pdCA9IDEwMDAwO1xuXG4gIGlmIChleHRlbnRbMF0gPCBuaWNlVGlja0V4dGVudFswXSkge1xuICAgIHRpY2tzLnB1c2goZXh0ZW50WzBdKTtcbiAgfVxuXG4gIHZhciB0aWNrID0gbmljZVRpY2tFeHRlbnRbMF07XG5cbiAgd2hpbGUgKHRpY2sgPD0gbmljZVRpY2tFeHRlbnRbMV0pIHtcbiAgICB0aWNrcy5wdXNoKHRpY2spOyAvLyBBdm9pZCByb3VuZGluZyBlcnJvclxuXG4gICAgdGljayA9IHJvdW5kTnVtYmVyKHRpY2sgKyBpbnRlcnZhbCwgaW50ZXJ2YWxQcmVjaXNpb24pO1xuXG4gICAgaWYgKHRpY2sgPT09IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAvLyBDb25zaWRlciBvdXQgb2Ygc2FmZSBmbG9hdCBwb2ludCwgZS5nLixcbiAgICAgIC8vIC0zNzExMTI2Ljk5MDc3MDcgKyAyZS0xMCA9PT0gLTM3MTExMjYuOTkwNzcwN1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IHNhZmVMaW1pdCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSAvLyBDb25zaWRlciB0aGlzIGNhc2U6IHRoZSBsYXN0IGl0ZW0gb2YgdGlja3MgaXMgc21hbGxlclxuICAvLyB0aGFuIG5pY2VUaWNrRXh0ZW50WzFdIGFuZCBuaWNlVGlja0V4dGVudFsxXSA9PT0gZXh0ZW50WzFdLlxuXG5cbiAgaWYgKGV4dGVudFsxXSA+ICh0aWNrcy5sZW5ndGggPyB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSA6IG5pY2VUaWNrRXh0ZW50WzFdKSkge1xuICAgIHRpY2tzLnB1c2goZXh0ZW50WzFdKTtcbiAgfVxuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0cy5pbnRlcnZhbFNjYWxlTmljZVRpY2tzID0gaW50ZXJ2YWxTY2FsZU5pY2VUaWNrcztcbmV4cG9ydHMuZ2V0SW50ZXJ2YWxQcmVjaXNpb24gPSBnZXRJbnRlcnZhbFByZWNpc2lvbjtcbmV4cG9ydHMuZml4RXh0ZW50ID0gZml4RXh0ZW50O1xuZXhwb3J0cy5pbnRlcnZhbFNjYWxlR2V0VGlja3MgPSBpbnRlcnZhbFNjYWxlR2V0VGlja3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvaGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9oZWxwZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFRZUEVfREVMSU1JVEVSID0gJy4nO1xudmFyIElTX0NPTlRBSU5FUiA9ICdfX19FQ19fQ09NUE9ORU5UX19DT05UQUlORVJfX18nO1xudmFyIE1FTUJFUl9QUklGSVggPSAnXFwwZWNfXFwwJztcbi8qKlxuICogSGlkZSBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAqIFRoZSBzYW1lIGJlaGF2aW9yIGFzIGBob3N0W25hbWVdID0gdmFsdWU7YCAoY2FuIGJlIHJpZ2h0LXZhbHVlKVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHNldChob3N0LCBuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gaG9zdFtNRU1CRVJfUFJJRklYICsgbmFtZV0gPSB2YWx1ZTtcbn1cbi8qKlxuICogSGlkZSBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAqIFRoZSBzYW1lIGJlaGF2aW9yIGFzIGBob3N0W25hbWVdO2BcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldChob3N0LCBuYW1lKSB7XG4gIHJldHVybiBob3N0W01FTUJFUl9QUklGSVggKyBuYW1lXTtcbn1cbi8qKlxuICogRm9yIGhpZGRlbiBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAqIFRoZSBzYW1lIGJlaGF2aW9yIGFzIGBob3N0Lmhhc093blByb3BlcnR5KG5hbWUpO2BcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGhhc093bihob3N0LCBuYW1lKSB7XG4gIHJldHVybiBob3N0Lmhhc093blByb3BlcnR5KE1FTUJFUl9QUklGSVggKyBuYW1lKTtcbn1cbi8qKlxuICogTm90aWNlLCBwYXJzZUNsYXNzVHlwZSgnJykgc2hvdWxkIHJldHVybnMge21haW46ICcnLCBzdWI6ICcnfVxuICogQHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSkge1xuICB2YXIgcmV0ID0ge1xuICAgIG1haW46ICcnLFxuICAgIHN1YjogJydcbiAgfTtcblxuICBpZiAoY29tcG9uZW50VHlwZSkge1xuICAgIGNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlLnNwbGl0KFRZUEVfREVMSU1JVEVSKTtcbiAgICByZXQubWFpbiA9IGNvbXBvbmVudFR5cGVbMF0gfHwgJyc7XG4gICAgcmV0LnN1YiA9IGNvbXBvbmVudFR5cGVbMV0gfHwgJyc7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBjaGVja0NsYXNzVHlwZShjb21wb25lbnRUeXBlKSB7XG4gIHpyVXRpbC5hc3NlcnQoL15bYS16QS1aMC05X10rKFsuXVthLXpBLVowLTlfXSspPyQvLnRlc3QoY29tcG9uZW50VHlwZSksICdjb21wb25lbnRUeXBlIFwiJyArIGNvbXBvbmVudFR5cGUgKyAnXCIgaWxsZWdhbCcpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBlbmFibGVDbGFzc0V4dGVuZChSb290Q2xhc3MsIG1hbmRhdG9yeU1ldGhvZHMpIHtcbiAgUm9vdENsYXNzLiRjb25zdHJ1Y3RvciA9IFJvb3RDbGFzcztcblxuICBSb290Q2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XG4gICAgdmFyIHN1cGVyQ2xhc3MgPSB0aGlzO1xuXG4gICAgdmFyIEV4dGVuZGVkQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXByb3RvLiRjb25zdHJ1Y3Rvcikge1xuICAgICAgICBzdXBlckNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90by4kY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmV4dGVuZChFeHRlbmRlZENsYXNzLnByb3RvdHlwZSwgcHJvdG8pO1xuICAgIEV4dGVuZGVkQ2xhc3MuZXh0ZW5kID0gdGhpcy5leHRlbmQ7XG4gICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNhbGwgPSBzdXBlckNhbGw7XG4gICAgRXh0ZW5kZWRDbGFzcy5zdXBlckFwcGx5ID0gc3VwZXJBcHBseTtcbiAgICB6clV0aWwuaW5oZXJpdHMoRXh0ZW5kZWRDbGFzcywgdGhpcyk7XG4gICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcbiAgICByZXR1cm4gRXh0ZW5kZWRDbGFzcztcbiAgfTtcbn0gLy8gc3VwZXJDYWxsIHNob3VsZCBoYXZlIGNsYXNzIGluZm8sIHdoaWNoIGNhbiBub3QgYmUgZmV0Y2ggZnJvbSAndGhpcycuXG4vLyBDb25zaWRlciB0aGlzIGNhc2U6XG4vLyBjbGFzcyBBIGhhcyBtZXRob2QgZixcbi8vIGNsYXNzIEIgaW5oZXJpdHMgY2xhc3MgQSwgb3ZlcnJpZGVzIG1ldGhvZCBmLCBmIGNhbGwgc3VwZXJBcHBseSgnZicpLFxuLy8gY2xhc3MgQyBpbmhlcml0cyBjbGFzcyBCLCBkbyBub3Qgb3ZlcnJpZGVzIG1ldGhvZCBmLFxuLy8gdGhlbiB3aGVuIG1ldGhvZCBvZiBjbGFzcyBDIGlzIGNhbGxlZCwgZGVhZCBsb29wIG9jY3VyZWQuXG5cblxuZnVuY3Rpb24gc3VwZXJDYWxsKGNvbnRleHQsIG1ldGhvZE5hbWUpIHtcbiAgdmFyIGFyZ3MgPSB6clV0aWwuc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XG59XG5cbmZ1bmN0aW9uIHN1cGVyQXBwbHkoY29udGV4dCwgbWV0aG9kTmFtZSwgYXJncykge1xuICByZXR1cm4gdGhpcy5zdXBlckNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseShjb250ZXh0LCBhcmdzKTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGVudGl0eVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kXVxuICogQHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KGVudGl0eSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgLyoqXG4gICAqIENvbXBvbmVudCBtb2RlbCBjbGFzc2VzXG4gICAqIGtleTogY29tcG9uZW50VHlwZSxcbiAgICogdmFsdWU6XG4gICAqICAgICBjb21wb25lbnRDbGFzcywgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgnXG4gICAqICAgICBvciBPYmplY3QuPHN1YktleSwgY29tcG9uZW50Q2xhc3M+LCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eC55eSdcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdmFyIHN0b3JhZ2UgPSB7fTtcblxuICBlbnRpdHkucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChDbGF6eiwgY29tcG9uZW50VHlwZSkge1xuICAgIGlmIChjb21wb25lbnRUeXBlKSB7XG4gICAgICBjaGVja0NsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcblxuICAgICAgaWYgKCFjb21wb25lbnRUeXBlLnN1Yikge1xuICAgICAgICBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0gPSBDbGF6ejtcbiAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50VHlwZS5zdWIgIT09IElTX0NPTlRBSU5FUikge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKTtcbiAgICAgICAgY29udGFpbmVyW2NvbXBvbmVudFR5cGUuc3ViXSA9IENsYXp6O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDbGF6ejtcbiAgfTtcblxuICBlbnRpdHkuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50TWFpblR5cGUsIHN1YlR5cGUsIHRocm93V2hlbk5vdEZvdW5kKSB7XG4gICAgdmFyIENsYXp6ID0gc3RvcmFnZVtjb21wb25lbnRNYWluVHlwZV07XG5cbiAgICBpZiAoQ2xhenogJiYgQ2xhenpbSVNfQ09OVEFJTkVSXSkge1xuICAgICAgQ2xhenogPSBzdWJUeXBlID8gQ2xhenpbc3ViVHlwZV0gOiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aHJvd1doZW5Ob3RGb3VuZCAmJiAhQ2xhenopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcighc3ViVHlwZSA/IGNvbXBvbmVudE1haW5UeXBlICsgJy4nICsgJ3R5cGUgc2hvdWxkIGJlIHNwZWNpZmllZC4nIDogJ0NvbXBvbmVudCAnICsgY29tcG9uZW50TWFpblR5cGUgKyAnLicgKyAoc3ViVHlwZSB8fCAnJykgKyAnIG5vdCBleGlzdHMuIExvYWQgaXQgZmlyc3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENsYXp6O1xuICB9O1xuXG4gIGVudGl0eS5nZXRDbGFzc2VzQnlNYWluVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuXG4gICAgaWYgKG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXSkge1xuICAgICAgenJVdGlsLmVhY2gob2JqLCBmdW5jdGlvbiAobywgdHlwZSkge1xuICAgICAgICB0eXBlICE9PSBJU19DT05UQUlORVIgJiYgcmVzdWx0LnB1c2gobyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gob2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGVudGl0eS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgLy8gSnVzdCBjb25zaWRlciBjb21wb25lbnRUeXBlLm1haW4uXG4gICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgIHJldHVybiAhIXN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBMaWtlIFsnYWEnLCAnYmInXSwgYnV0IGNhbiBub3QgYmUgWydhYS54eCddXG4gICAqL1xuXG5cbiAgZW50aXR5LmdldEFsbENsYXNzTWFpblR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlcyA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKHN0b3JhZ2UsIGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcbiAgICAgIHR5cGVzLnB1c2godHlwZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9O1xuICAvKipcbiAgICogSWYgYSBtYWluIHR5cGUgaXMgY29udGFpbmVyIGFuZCBoYXMgc3ViIHR5cGVzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG1haW5UeXBlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgZW50aXR5Lmhhc1N1YlR5cGVzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcbiAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG4gICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcbiAgICByZXR1cm4gb2JqICYmIG9ialtJU19DT05UQUlORVJdO1xuICB9O1xuXG4gIGVudGl0eS5wYXJzZUNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlO1xuXG4gIGZ1bmN0aW9uIG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZSkge1xuICAgIHZhciBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XG5cbiAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyW0lTX0NPTlRBSU5FUl0pIHtcbiAgICAgIGNvbnRhaW5lciA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IHt9O1xuICAgICAgY29udGFpbmVyW0lTX0NPTlRBSU5FUl0gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZWdpc3RlcldoZW5FeHRlbmQpIHtcbiAgICB2YXIgb3JpZ2luYWxFeHRlbmQgPSBlbnRpdHkuZXh0ZW5kO1xuXG4gICAgaWYgKG9yaWdpbmFsRXh0ZW5kKSB7XG4gICAgICBlbnRpdHkuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XG4gICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gb3JpZ2luYWxFeHRlbmQuY2FsbCh0aGlzLCBwcm90byk7XG4gICAgICAgIHJldHVybiBlbnRpdHkucmVnaXN0ZXJDbGFzcyhFeHRlbmRlZENsYXNzLCBwcm90by50eXBlKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVudGl0eTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IHByb3BlcnRpZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFJlYWRPbmx5KG9iaiwgcHJvcGVydGllcykgey8vIEZJWE1FIEl0IHNlZW1zIGJyb2tlbiBpbiBJRTggc2ltdWxhdGlvbiBvZiBJRTExXG4gIC8vIGlmICghenJVdGlsLmlzQXJyYXkocHJvcGVydGllcykpIHtcbiAgLy8gICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzICE9IG51bGwgPyBbcHJvcGVydGllc10gOiBbXTtcbiAgLy8gfVxuICAvLyB6clV0aWwuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbiAocHJvcCkge1xuICAvLyAgICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAvLyAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gIC8vICAgICAgICAgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAvLyAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsIHdyaXRhYmxlOiBmYWxzZVxuICAvLyAgICAgICAgIH0pO1xuICAvLyAgICAgenJVdGlsLmlzQXJyYXkob2JqW3Byb3BdKVxuICAvLyAgICAgICAgICYmIE9iamVjdC5mcmVlemVcbiAgLy8gICAgICAgICAmJiBPYmplY3QuZnJlZXplKG9ialtwcm9wXSk7XG4gIC8vIH0pO1xufVxuXG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuZ2V0ID0gZ2V0O1xuZXhwb3J0cy5oYXNPd24gPSBoYXNPd247XG5leHBvcnRzLnBhcnNlQ2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGU7XG5leHBvcnRzLmVuYWJsZUNsYXNzRXh0ZW5kID0gZW5hYmxlQ2xhc3NFeHRlbmQ7XG5leHBvcnRzLmVuYWJsZUNsYXNzTWFuYWdlbWVudCA9IGVuYWJsZUNsYXNzTWFuYWdlbWVudDtcbmV4cG9ydHMuc2V0UmVhZE9ubHkgPSBzZXRSZWFkT25seTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2NsYXp6LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2NsYXp6LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBfY2xhenogPSByZXF1aXJlKFwiLi9jbGF6elwiKTtcblxudmFyIHBhcnNlQ2xhc3NUeXBlID0gX2NsYXp6LnBhcnNlQ2xhc3NUeXBlO1xudmFyIGJhc2UgPSAwO1xudmFyIERFTElNSVRFUiA9ICdfJztcbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRVSUQodHlwZSkge1xuICAvLyBDb25zaWRlcmluZyB0aGUgY2FzZSBvZiBjcm9zc2luZyBqcyBjb250ZXh0LFxuICAvLyB1c2UgTWF0aC5yYW5kb20gdG8gbWFrZSBpZCBhcyB1bmlxdWUgYXMgcG9zc2libGUuXG4gIHJldHVybiBbdHlwZSB8fCAnJywgYmFzZSsrLCBNYXRoLnJhbmRvbSgpXS5qb2luKERFTElNSVRFUik7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZW5hYmxlU3ViVHlwZURlZmF1bHRlcihlbnRpdHkpIHtcbiAgdmFyIHN1YlR5cGVEZWZhdWx0ZXJzID0ge307XG5cbiAgZW50aXR5LnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBkZWZhdWx0ZXIpIHtcbiAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG4gICAgc3ViVHlwZURlZmF1bHRlcnNbY29tcG9uZW50VHlwZS5tYWluXSA9IGRlZmF1bHRlcjtcbiAgfTtcblxuICBlbnRpdHkuZGV0ZXJtaW5lU3ViVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBvcHRpb24pIHtcbiAgICB2YXIgdHlwZSA9IG9wdGlvbi50eXBlO1xuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB2YXIgY29tcG9uZW50VHlwZU1haW4gPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKS5tYWluO1xuXG4gICAgICBpZiAoZW50aXR5Lmhhc1N1YlR5cGVzKGNvbXBvbmVudFR5cGUpICYmIHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGVNYWluXSkge1xuICAgICAgICB0eXBlID0gc3ViVHlwZURlZmF1bHRlcnNbY29tcG9uZW50VHlwZU1haW5dKG9wdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH07XG5cbiAgcmV0dXJuIGVudGl0eTtcbn1cbi8qKlxuICogVG9wb2xvZ2ljYWwgdHJhdmVsIG9uIEFjdGl2aXR5IE5ldHdvcmsgKEFjdGl2aXR5IE9uIFZlcnRpY2VzKS5cbiAqIERlcGVuZGVuY2llcyBpcyBkZWZpbmVkIGluIE1vZGVsLnByb3RvdHlwZS5kZXBlbmRlbmNpZXMsIGxpa2UgWyd4QXhpcycsICd5QXhpcyddLlxuICpcbiAqIElmICd4QXhpcycgb3IgJ3lBeGlzJyBpcyBhYnNlbnQgaW4gY29tcG9uZW50VHlwZUxpc3QsIGp1c3QgaWdub3JlIGl0IGluIHRvcG9sb2d5LlxuICpcbiAqIElmIHRoZXJlIGlzIGNpcmNsZSBkZXBlbmRlbmNleSwgRXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKlxuICovXG5cblxuZnVuY3Rpb24gZW5hYmxlVG9wb2xvZ2ljYWxUcmF2ZWwoZW50aXR5LCBkZXBlbmRlbmN5R2V0dGVyKSB7XG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHRhcmdldE5hbWVMaXN0IFRhcmdldCBDb21wb25lbnQgdHlwZSBsaXN0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgWydhYScsICdiYicsICdhYS54eCddXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGZ1bGxOYW1lTGlzdCBCeSB3aGljaCB3ZSBjYW4gYnVpbGQgZGVwZW5kZW5jeSBncmFwaC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgUGFyYW1zOiBjb21wb25lbnRUeXBlLCBkZXBlbmRlbmNpZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFNjb3BlIG9mIGNhbGxiYWNrLlxuICAgKi9cbiAgZW50aXR5LnRvcG9sb2dpY2FsVHJhdmVsID0gZnVuY3Rpb24gKHRhcmdldE5hbWVMaXN0LCBmdWxsTmFtZUxpc3QsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKCF0YXJnZXROYW1lTGlzdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gbWFrZURlcG5kZW5jeUdyYXBoKGZ1bGxOYW1lTGlzdCk7XG4gICAgdmFyIGdyYXBoID0gcmVzdWx0LmdyYXBoO1xuICAgIHZhciBzdGFjayA9IHJlc3VsdC5ub0VudHJ5TGlzdDtcbiAgICB2YXIgdGFyZ2V0TmFtZVNldCA9IHt9O1xuICAgIHpyVXRpbC5lYWNoKHRhcmdldE5hbWVMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdGFyZ2V0TmFtZVNldFtuYW1lXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICB2YXIgY3VyckNvbXBvbmVudFR5cGUgPSBzdGFjay5wb3AoKTtcbiAgICAgIHZhciBjdXJyVmVydGV4ID0gZ3JhcGhbY3VyckNvbXBvbmVudFR5cGVdO1xuICAgICAgdmFyIGlzSW5UYXJnZXROYW1lU2V0ID0gISF0YXJnZXROYW1lU2V0W2N1cnJDb21wb25lbnRUeXBlXTtcblxuICAgICAgaWYgKGlzSW5UYXJnZXROYW1lU2V0KSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgY3VyckNvbXBvbmVudFR5cGUsIGN1cnJWZXJ0ZXgub3JpZ2luYWxEZXBzLnNsaWNlKCkpO1xuICAgICAgICBkZWxldGUgdGFyZ2V0TmFtZVNldFtjdXJyQ29tcG9uZW50VHlwZV07XG4gICAgICB9XG5cbiAgICAgIHpyVXRpbC5lYWNoKGN1cnJWZXJ0ZXguc3VjY2Vzc29yLCBpc0luVGFyZ2V0TmFtZVNldCA/IHJlbW92ZUVkZ2VBbmRBZGQgOiByZW1vdmVFZGdlKTtcbiAgICB9XG5cbiAgICB6clV0aWwuZWFjaCh0YXJnZXROYW1lU2V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSBkZXBlbmRlbmN5IG1heSBleGlzdHMnKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVkZ2Uoc3VjY0NvbXBvbmVudFR5cGUpIHtcbiAgICAgIGdyYXBoW3N1Y2NDb21wb25lbnRUeXBlXS5lbnRyeUNvdW50LS07XG5cbiAgICAgIGlmIChncmFwaFtzdWNjQ29tcG9uZW50VHlwZV0uZW50cnlDb3VudCA9PT0gMCkge1xuICAgICAgICBzdGFjay5wdXNoKHN1Y2NDb21wb25lbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9IC8vIENvbnNpZGVyIHRoaXMgY2FzZTogbGVnZW5kIGRlcGVuZHMgb24gc2VyaWVzLCBhbmQgd2UgY2FsbFxuICAgIC8vIGNoYXJ0LnNldE9wdGlvbih7c2VyaWVzOiBbLi4uXX0pLCB3aGVyZSBvbmx5IHNlcmllcyBpcyBpbiBvcHRpb24uXG4gICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgJ3JlbW92ZUVkZ2VBbmRBZGQnLCBsZWdlbmRNb2RlbC5tZXJnZU9wdGlvbiB3aWxsXG4gICAgLy8gbm90IGJlIGNhbGxlZCwgYnV0IG9ubHkgc2VyZWlzLm1lcmdlT3B0aW9uIGlzIGNhbGxlZC4gVGh1cyBsZWdlbmRcbiAgICAvLyBoYXZlIG5vIGNoYW5jZSB0byB1cGRhdGUgaXRzIGxvY2FsIHJlY29yZCBhYm91dCBzZXJpZXMgKGxpa2Ugd2hpY2hcbiAgICAvLyBuYW1lIG9mIHNlcmllcyBpcyBhdmFpbGFibGUgaW4gbGVnZW5kKS5cblxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWRnZUFuZEFkZChzdWNjQ29tcG9uZW50VHlwZSkge1xuICAgICAgdGFyZ2V0TmFtZVNldFtzdWNjQ29tcG9uZW50VHlwZV0gPSB0cnVlO1xuICAgICAgcmVtb3ZlRWRnZShzdWNjQ29tcG9uZW50VHlwZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRGVwbmRlbmN5R3JhcGg6IHtPYmplY3R9XG4gICAqIGtleTogY29ucG9uZW50VHlwZSxcbiAgICogdmFsdWU6IHtcbiAgICogICAgIHN1Y2Nlc3NvcjogW2NvbnBvbmVudFR5cGVzLi4uXSxcbiAgICogICAgIG9yaWdpbmFsRGVwczogW2NvbnBvbmVudFR5cGVzLi4uXSxcbiAgICogICAgIGVudHJ5Q291bnQ6IHtudW1iZXJ9XG4gICAqIH1cbiAgICovXG5cblxuICBmdW5jdGlvbiBtYWtlRGVwbmRlbmN5R3JhcGgoZnVsbE5hbWVMaXN0KSB7XG4gICAgdmFyIGdyYXBoID0ge307XG4gICAgdmFyIG5vRW50cnlMaXN0ID0gW107XG4gICAgenJVdGlsLmVhY2goZnVsbE5hbWVMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHRoaXNJdGVtID0gY3JlYXRlRGVwZW5kZW5jeUdyYXBoSXRlbShncmFwaCwgbmFtZSk7XG4gICAgICB2YXIgb3JpZ2luYWxEZXBzID0gdGhpc0l0ZW0ub3JpZ2luYWxEZXBzID0gZGVwZW5kZW5jeUdldHRlcihuYW1lKTtcbiAgICAgIHZhciBhdmFpbGFibGVEZXBzID0gZ2V0QXZhaWxhYmxlRGVwZW5kZW5jaWVzKG9yaWdpbmFsRGVwcywgZnVsbE5hbWVMaXN0KTtcbiAgICAgIHRoaXNJdGVtLmVudHJ5Q291bnQgPSBhdmFpbGFibGVEZXBzLmxlbmd0aDtcblxuICAgICAgaWYgKHRoaXNJdGVtLmVudHJ5Q291bnQgPT09IDApIHtcbiAgICAgICAgbm9FbnRyeUxpc3QucHVzaChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgenJVdGlsLmVhY2goYXZhaWxhYmxlRGVwcywgZnVuY3Rpb24gKGRlcGVuZGVudE5hbWUpIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKHRoaXNJdGVtLnByZWRlY2Vzc29yLCBkZXBlbmRlbnROYW1lKSA8IDApIHtcbiAgICAgICAgICB0aGlzSXRlbS5wcmVkZWNlc3Nvci5wdXNoKGRlcGVuZGVudE5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoYXRJdGVtID0gY3JlYXRlRGVwZW5kZW5jeUdyYXBoSXRlbShncmFwaCwgZGVwZW5kZW50TmFtZSk7XG5cbiAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKHRoYXRJdGVtLnN1Y2Nlc3NvciwgZGVwZW5kZW50TmFtZSkgPCAwKSB7XG4gICAgICAgICAgdGhhdEl0ZW0uc3VjY2Vzc29yLnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBncmFwaDogZ3JhcGgsXG4gICAgICBub0VudHJ5TGlzdDogbm9FbnRyeUxpc3RcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRGVwZW5kZW5jeUdyYXBoSXRlbShncmFwaCwgbmFtZSkge1xuICAgIGlmICghZ3JhcGhbbmFtZV0pIHtcbiAgICAgIGdyYXBoW25hbWVdID0ge1xuICAgICAgICBwcmVkZWNlc3NvcjogW10sXG4gICAgICAgIHN1Y2Nlc3NvcjogW11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYXBoW25hbWVdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlRGVwZW5kZW5jaWVzKG9yaWdpbmFsRGVwcywgZnVsbE5hbWVMaXN0KSB7XG4gICAgdmFyIGF2YWlsYWJsZURlcHMgPSBbXTtcbiAgICB6clV0aWwuZWFjaChvcmlnaW5hbERlcHMsIGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIHpyVXRpbC5pbmRleE9mKGZ1bGxOYW1lTGlzdCwgZGVwKSA+PSAwICYmIGF2YWlsYWJsZURlcHMucHVzaChkZXApO1xuICAgIH0pO1xuICAgIHJldHVybiBhdmFpbGFibGVEZXBzO1xuICB9XG59XG5cbmV4cG9ydHMuZ2V0VUlEID0gZ2V0VUlEO1xuZXhwb3J0cy5lbmFibGVTdWJUeXBlRGVmYXVsdGVyID0gZW5hYmxlU3ViVHlwZURlZmF1bHRlcjtcbmV4cG9ydHMuZW5hYmxlVG9wb2xvZ2ljYWxUcmF2ZWwgPSBlbmFibGVUb3BvbG9naWNhbFRyYXZlbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9jb21wb25lbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi9udW1iZXJcIik7XG5cbi8qKlxuICog5q+P5LiJ5L2N6buY6K6k5YqgLOagvOW8j+WMllxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGFkZENvbW1hcyh4KSB7XG4gIGlmIChpc05hTih4KSkge1xuICAgIHJldHVybiAnLSc7XG4gIH1cblxuICB4ID0gKHggKyAnJykuc3BsaXQoJy4nKTtcbiAgcmV0dXJuIHhbMF0ucmVwbGFjZSgvKFxcZHsxLDN9KSg/PSg/OlxcZHszfSkrKD8hXFxkKSkvZywgJyQxLCcpICsgKHgubGVuZ3RoID4gMSA/ICcuJyArIHhbMV0gOiAnJyk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwcGVyQ2FzZUZpcnN0PWZhbHNlXVxuICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0ciwgdXBwZXJDYXNlRmlyc3QpIHtcbiAgc3RyID0gKHN0ciB8fCAnJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uIChtYXRjaCwgZ3JvdXAxKSB7XG4gICAgcmV0dXJuIGdyb3VwMS50b1VwcGVyQ2FzZSgpO1xuICB9KTtcblxuICBpZiAodXBwZXJDYXNlRmlyc3QgJiYgc3RyKSB7XG4gICAgc3RyID0gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIG5vcm1hbGl6ZUNzc0FycmF5ID0genJVdGlsLm5vcm1hbGl6ZUNzc0FycmF5O1xuXG5mdW5jdGlvbiBlbmNvZGVIVE1MKHNvdXJjZSkge1xuICByZXR1cm4gU3RyaW5nKHNvdXJjZSkucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuXG52YXIgVFBMX1ZBUl9BTElBUyA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZyddO1xuXG52YXIgd3JhcFZhciA9IGZ1bmN0aW9uICh2YXJOYW1lLCBzZXJpZXNJZHgpIHtcbiAgcmV0dXJuICd7JyArIHZhck5hbWUgKyAoc2VyaWVzSWR4ID09IG51bGwgPyAnJyA6IHNlcmllc0lkeCkgKyAnfSc7XG59O1xuLyoqXG4gKiBUZW1wbGF0ZSBmb3JtYXR0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0cGxcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD58T2JqZWN0fSBwYXJhbXNMaXN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmNvZGU9ZmFsc2VdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRUcGwodHBsLCBwYXJhbXNMaXN0LCBlbmNvZGUpIHtcbiAgaWYgKCF6clV0aWwuaXNBcnJheShwYXJhbXNMaXN0KSkge1xuICAgIHBhcmFtc0xpc3QgPSBbcGFyYW1zTGlzdF07XG4gIH1cblxuICB2YXIgc2VyaWVzTGVuID0gcGFyYW1zTGlzdC5sZW5ndGg7XG5cbiAgaWYgKCFzZXJpZXNMZW4pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgJHZhcnMgPSBwYXJhbXNMaXN0WzBdLiR2YXJzIHx8IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgJHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYWxpYXMgPSBUUExfVkFSX0FMSUFTW2ldO1xuICAgIHZhciB2YWwgPSB3cmFwVmFyKGFsaWFzLCAwKTtcbiAgICB0cGwgPSB0cGwucmVwbGFjZSh3cmFwVmFyKGFsaWFzKSwgZW5jb2RlID8gZW5jb2RlSFRNTCh2YWwpIDogdmFsKTtcbiAgfVxuXG4gIGZvciAodmFyIHNlcmllc0lkeCA9IDA7IHNlcmllc0lkeCA8IHNlcmllc0xlbjsgc2VyaWVzSWR4KyspIHtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8ICR2YXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICB2YXIgdmFsID0gcGFyYW1zTGlzdFtzZXJpZXNJZHhdWyR2YXJzW2tdXTtcbiAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHdyYXBWYXIoVFBMX1ZBUl9BTElBU1trXSwgc2VyaWVzSWR4KSwgZW5jb2RlID8gZW5jb2RlSFRNTCh2YWwpIDogdmFsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHBsO1xufVxuLyoqXG4gKiBzaW1wbGUgVGVtcGxhdGUgZm9ybWF0dGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmNvZGU9ZmFsc2VdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRUcGxTaW1wbGUodHBsLCBwYXJhbSwgZW5jb2RlKSB7XG4gIHpyVXRpbC5lYWNoKHBhcmFtLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHRwbCA9IHRwbC5yZXBsYWNlKCd7JyArIGtleSArICd9JywgZW5jb2RlID8gZW5jb2RlSFRNTCh2YWx1ZSkgOiB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gdHBsO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXh0cmFDc3NUZXh0XVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VG9vbHRpcE1hcmtlcihjb2xvciwgZXh0cmFDc3NUZXh0KSB7XG4gIHJldHVybiBjb2xvciA/ICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1yaWdodDo1cHg7JyArICdib3JkZXItcmFkaXVzOjEwcHg7d2lkdGg6OXB4O2hlaWdodDo5cHg7YmFja2dyb3VuZC1jb2xvcjonICsgZW5jb2RlSFRNTChjb2xvcikgKyAnOycgKyAoZXh0cmFDc3NUZXh0IHx8ICcnKSArICdcIj48L3NwYW4+JyA6ICcnO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAaW5uZXJcbiAqL1xuXG5cbnZhciBzMmQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIgPCAxMCA/ICcwJyArIHN0ciA6IHN0cjtcbn07XG4vKipcbiAqIElTTyBEYXRlIGZvcm1hdFxuICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1VUQz1mYWxzZV0gRGVmYXVsdCBpbiBsb2NhbCB0aW1lLlxuICogICAgICAgICAgIHNlZSBgbW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZWBcbiAqICAgICAgICAgICBhbmQgYG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyI3BhcnNlRGF0ZWAuXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWUodHBsLCB2YWx1ZSwgaXNVVEMpIHtcbiAgaWYgKHRwbCA9PT0gJ3dlZWsnIHx8IHRwbCA9PT0gJ21vbnRoJyB8fCB0cGwgPT09ICdxdWFydGVyJyB8fCB0cGwgPT09ICdoYWxmLXllYXInIHx8IHRwbCA9PT0gJ3llYXInKSB7XG4gICAgdHBsID0gJ01NLWRkXFxueXl5eSc7XG4gIH1cblxuICB2YXIgZGF0ZSA9IG51bWJlclV0aWwucGFyc2VEYXRlKHZhbHVlKTtcbiAgdmFyIHV0YyA9IGlzVVRDID8gJ1VUQycgOiAnJztcbiAgdmFyIHkgPSBkYXRlWydnZXQnICsgdXRjICsgJ0Z1bGxZZWFyJ10oKTtcbiAgdmFyIE0gPSBkYXRlWydnZXQnICsgdXRjICsgJ01vbnRoJ10oKSArIDE7XG4gIHZhciBkID0gZGF0ZVsnZ2V0JyArIHV0YyArICdEYXRlJ10oKTtcbiAgdmFyIGggPSBkYXRlWydnZXQnICsgdXRjICsgJ0hvdXJzJ10oKTtcbiAgdmFyIG0gPSBkYXRlWydnZXQnICsgdXRjICsgJ01pbnV0ZXMnXSgpO1xuICB2YXIgcyA9IGRhdGVbJ2dldCcgKyB1dGMgKyAnU2Vjb25kcyddKCk7XG4gIHRwbCA9IHRwbC5yZXBsYWNlKCdNTScsIHMyZChNKSkucmVwbGFjZSgnTScsIE0pLnJlcGxhY2UoJ3l5eXknLCB5KS5yZXBsYWNlKCd5eScsIHkgJSAxMDApLnJlcGxhY2UoJ2RkJywgczJkKGQpKS5yZXBsYWNlKCdkJywgZCkucmVwbGFjZSgnaGgnLCBzMmQoaCkpLnJlcGxhY2UoJ2gnLCBoKS5yZXBsYWNlKCdtbScsIHMyZChtKSkucmVwbGFjZSgnbScsIG0pLnJlcGxhY2UoJ3NzJywgczJkKHMpKS5yZXBsYWNlKCdzJywgcyk7XG4gIHJldHVybiB0cGw7XG59XG4vKipcbiAqIENhcGl0YWwgZmlyc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhcGl0YWxGaXJzdChzdHIpIHtcbiAgcmV0dXJuIHN0ciA/IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHIoMSkgOiBzdHI7XG59XG5cbnZhciB0cnVuY2F0ZVRleHQgPSB0ZXh0Q29udGFpbi50cnVuY2F0ZVRleHQ7XG52YXIgZ2V0VGV4dFJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3Q7XG5leHBvcnRzLmFkZENvbW1hcyA9IGFkZENvbW1hcztcbmV4cG9ydHMudG9DYW1lbENhc2UgPSB0b0NhbWVsQ2FzZTtcbmV4cG9ydHMubm9ybWFsaXplQ3NzQXJyYXkgPSBub3JtYWxpemVDc3NBcnJheTtcbmV4cG9ydHMuZW5jb2RlSFRNTCA9IGVuY29kZUhUTUw7XG5leHBvcnRzLmZvcm1hdFRwbCA9IGZvcm1hdFRwbDtcbmV4cG9ydHMuZm9ybWF0VHBsU2ltcGxlID0gZm9ybWF0VHBsU2ltcGxlO1xuZXhwb3J0cy5nZXRUb29sdGlwTWFya2VyID0gZ2V0VG9vbHRpcE1hcmtlcjtcbmV4cG9ydHMuZm9ybWF0VGltZSA9IGZvcm1hdFRpbWU7XG5leHBvcnRzLmNhcGl0YWxGaXJzdCA9IGNhcGl0YWxGaXJzdDtcbmV4cG9ydHMudHJ1bmNhdGVUZXh0ID0gdHJ1bmNhdGVUZXh0O1xuZXhwb3J0cy5nZXRUZXh0UmVjdCA9IGdldFRleHRSZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvZm9ybWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2Zvcm1hdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgcGF0aFRvb2wgPSByZXF1aXJlKFwienJlbmRlci9saWIvdG9vbC9wYXRoXCIpO1xuXG52YXIgY29sb3JUb29sID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3Rvb2wvY29sb3JcIik7XG5cbnZhciBtYXRyaXggPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9tYXRyaXhcIik7XG5cbnZhciB2ZWN0b3IgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS92ZWN0b3JcIik7XG5cbnZhciBQYXRoID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKFwienJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZVwiKTtcblxudmFyIEltYWdlID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2VcIik7XG5cbmV4cG9ydHMuSW1hZ2UgPSBJbWFnZTtcblxudmFyIEdyb3VwID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cFwiKTtcblxuZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xuXG52YXIgVGV4dCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL1RleHRcIik7XG5cbmV4cG9ydHMuVGV4dCA9IFRleHQ7XG5cbnZhciBDaXJjbGUgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGVcIik7XG5cbmV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlO1xuXG52YXIgU2VjdG9yID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yXCIpO1xuXG5leHBvcnRzLlNlY3RvciA9IFNlY3RvcjtcblxudmFyIFJpbmcgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nXCIpO1xuXG5leHBvcnRzLlJpbmcgPSBSaW5nO1xuXG52YXIgUG9seWdvbiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb25cIik7XG5cbmV4cG9ydHMuUG9seWdvbiA9IFBvbHlnb247XG5cbnZhciBQb2x5bGluZSA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXCIpO1xuXG5leHBvcnRzLlBvbHlsaW5lID0gUG9seWxpbmU7XG5cbnZhciBSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdFwiKTtcblxuZXhwb3J0cy5SZWN0ID0gUmVjdDtcblxudmFyIExpbmUgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lXCIpO1xuXG5leHBvcnRzLkxpbmUgPSBMaW5lO1xuXG52YXIgQmV6aWVyQ3VydmUgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZVwiKTtcblxuZXhwb3J0cy5CZXppZXJDdXJ2ZSA9IEJlemllckN1cnZlO1xuXG52YXIgQXJjID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjXCIpO1xuXG5leHBvcnRzLkFyYyA9IEFyYztcblxudmFyIENvbXBvdW5kUGF0aCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL0NvbXBvdW5kUGF0aFwiKTtcblxuZXhwb3J0cy5Db21wb3VuZFBhdGggPSBDb21wb3VuZFBhdGg7XG5cbnZhciBMaW5lYXJHcmFkaWVudCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50XCIpO1xuXG5leHBvcnRzLkxpbmVhckdyYWRpZW50ID0gTGluZWFyR3JhZGllbnQ7XG5cbnZhciBSYWRpYWxHcmFkaWVudCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50XCIpO1xuXG5leHBvcnRzLlJhZGlhbEdyYWRpZW50ID0gUmFkaWFsR3JhZGllbnQ7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbmV4cG9ydHMuQm91bmRpbmdSZWN0ID0gQm91bmRpbmdSZWN0O1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIEVNUFRZX09CSiA9IHt9O1xuLyoqXG4gKiBFeHRlbmQgc2hhcGUgd2l0aCBwYXJhbWV0ZXJzXG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5kU2hhcGUob3B0cykge1xuICByZXR1cm4gUGF0aC5leHRlbmQob3B0cyk7XG59XG4vKipcbiAqIEV4dGVuZCBwYXRoXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRQYXRoKHBhdGhEYXRhLCBvcHRzKSB7XG4gIHJldHVybiBwYXRoVG9vbC5leHRlbmRGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCBlbGVtZW50IGZyb20gcGF0aCBkYXRhIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhEYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQ9Y292ZXJdICdjZW50ZXInIG9yICdjb3ZlcidcbiAqL1xuXG5cbmZ1bmN0aW9uIG1ha2VQYXRoKHBhdGhEYXRhLCBvcHRzLCByZWN0LCBsYXlvdXQpIHtcbiAgdmFyIHBhdGggPSBwYXRoVG9vbC5jcmVhdGVGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcbiAgdmFyIGJvdW5kaW5nUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgaWYgKHJlY3QpIHtcbiAgICBpZiAobGF5b3V0ID09PSAnY2VudGVyJykge1xuICAgICAgcmVjdCA9IGNlbnRlckdyYXBoaWMocmVjdCwgYm91bmRpbmdSZWN0KTtcbiAgICB9XG5cbiAgICByZXNpemVQYXRoKHBhdGgsIHJlY3QpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIENyZWF0ZSBhIGltYWdlIGVsZW1lbnQgZnJvbSBpbWFnZSB1cmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVVybCBpbWFnZSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbnNcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3QgY29uc3RyYWluIHJlY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0PWNvdmVyXSAnY2VudGVyJyBvciAnY292ZXInXG4gKi9cblxuXG5mdW5jdGlvbiBtYWtlSW1hZ2UoaW1hZ2VVcmwsIHJlY3QsIGxheW91dCkge1xuICB2YXIgcGF0aCA9IG5ldyBJbWFnZSh7XG4gICAgc3R5bGU6IHtcbiAgICAgIGltYWdlOiBpbWFnZVVybCxcbiAgICAgIHg6IHJlY3QueCxcbiAgICAgIHk6IHJlY3QueSxcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgIH0sXG4gICAgb25sb2FkOiBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICBpZiAobGF5b3V0ID09PSAnY2VudGVyJykge1xuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0ge1xuICAgICAgICAgIHdpZHRoOiBpbWcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBpbWcuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHBhdGguc2V0U3R5bGUoY2VudGVyR3JhcGhpYyhyZWN0LCBib3VuZGluZ1JlY3QpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogR2V0IHBvc2l0aW9uIG9mIGNlbnRlcmVkIGVsZW1lbnQgaW4gYm91bmRpbmcgYm94LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gcmVjdCAgICAgICAgIGVsZW1lbnQgbG9jYWwgYm91bmRpbmcgYm94XG4gKiBAcGFyYW0gIHtPYmplY3R9IGJvdW5kaW5nUmVjdCBjb25zdHJhaW50IGJvdW5kaW5nIGJveFxuICogQHJldHVybiB7T2JqZWN0fSBlbGVtZW50IHBvc2l0aW9uIGNvbnRhaW5pbmcgeCwgeSwgd2lkdGgsIGFuZCBoZWlnaHRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNlbnRlckdyYXBoaWMocmVjdCwgYm91bmRpbmdSZWN0KSB7XG4gIC8vIFNldCByZWN0IHRvIGNlbnRlciwga2VlcCB3aWR0aCAvIGhlaWdodCByYXRpby5cbiAgdmFyIGFzcGVjdCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGJvdW5kaW5nUmVjdC5oZWlnaHQ7XG4gIHZhciB3aWR0aCA9IHJlY3QuaGVpZ2h0ICogYXNwZWN0O1xuICB2YXIgaGVpZ2h0O1xuXG4gIGlmICh3aWR0aCA8PSByZWN0LndpZHRoKSB7XG4gICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgd2lkdGggPSByZWN0LndpZHRoO1xuICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xuICB9XG5cbiAgdmFyIGN4ID0gcmVjdC54ICsgcmVjdC53aWR0aCAvIDI7XG4gIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcbiAgcmV0dXJuIHtcbiAgICB4OiBjeCAtIHdpZHRoIC8gMixcbiAgICB5OiBjeSAtIGhlaWdodCAvIDIsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5cbnZhciBtZXJnZVBhdGggPSBwYXRoVG9vbC5tZXJnZVBhdGg7XG4vKipcbiAqIFJlc2l6ZSBhIHBhdGggdG8gZml0IHRoZSByZWN0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAqL1xuXG5mdW5jdGlvbiByZXNpemVQYXRoKHBhdGgsIHJlY3QpIHtcbiAgaWYgKCFwYXRoLmFwcGx5VHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhdGhSZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgdmFyIG0gPSBwYXRoUmVjdC5jYWxjdWxhdGVUcmFuc2Zvcm0ocmVjdCk7XG4gIHBhdGguYXBwbHlUcmFuc2Zvcm0obSk7XG59XG4vKipcbiAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBsaW5lIGZvciBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngxXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDJdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkyXVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxuICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxuICovXG5cblxuZnVuY3Rpb24gc3ViUGl4ZWxPcHRpbWl6ZUxpbmUocGFyYW0pIHtcbiAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XG4gIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XG5cbiAgaWYgKHJvdW5kKHNoYXBlLngxICogMikgPT09IHJvdW5kKHNoYXBlLngyICogMikpIHtcbiAgICBzaGFwZS54MSA9IHNoYXBlLngyID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54MSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChyb3VuZChzaGFwZS55MSAqIDIpID09PSByb3VuZChzaGFwZS55MiAqIDIpKSB7XG4gICAgc2hhcGUueTEgPSBzaGFwZS55MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueTEsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW07XG59XG4vKipcbiAqIFN1YiBwaXhlbCBvcHRpbWl6ZSByZWN0IGZvciBjYW52YXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnhdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnldXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLndpZHRoXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS5oZWlnaHRdXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zdHlsZS5saW5lV2lkdGhdXG4gKiBAcmV0dXJuIHtPYmplY3R9IE1vZGlmaWVkIHBhcmFtXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJQaXhlbE9wdGltaXplUmVjdChwYXJhbSkge1xuICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcbiAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcbiAgdmFyIG9yaWdpblggPSBzaGFwZS54O1xuICB2YXIgb3JpZ2luWSA9IHNoYXBlLnk7XG4gIHZhciBvcmlnaW5XaWR0aCA9IHNoYXBlLndpZHRoO1xuICB2YXIgb3JpZ2luSGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICBzaGFwZS54ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54LCBsaW5lV2lkdGgsIHRydWUpO1xuICBzaGFwZS55ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS55LCBsaW5lV2lkdGgsIHRydWUpO1xuICBzaGFwZS53aWR0aCA9IE1hdGgubWF4KHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWCArIG9yaWdpbldpZHRoLCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLngsIG9yaWdpbldpZHRoID09PSAwID8gMCA6IDEpO1xuICBzaGFwZS5oZWlnaHQgPSBNYXRoLm1heChzdWJQaXhlbE9wdGltaXplKG9yaWdpblkgKyBvcmlnaW5IZWlnaHQsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueSwgb3JpZ2luSGVpZ2h0ID09PSAwID8gMCA6IDEpO1xuICByZXR1cm4gcGFyYW07XG59XG4vKipcbiAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBmb3IgY2FudmFzXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIENvb3JkaW5hdGUsIHN1Y2ggYXMgeCwgeVxuICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBTaG91bGQgYmUgbm9ubmVnYXRpdmUgaW50ZWdlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHBvc2l0aXZlT3JOZWdhdGl2ZSBEZWZhdWx0IGZhbHNlIChuZWdhdGl2ZSkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE9wdGltaXplZCBwb3NpdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YlBpeGVsT3B0aW1pemUocG9zaXRpb24sIGxpbmVXaWR0aCwgcG9zaXRpdmVPck5lZ2F0aXZlKSB7XG4gIC8vIEFzc3VyZSB0aGF0IChwb3NpdGlvbiArIGxpbmVXaWR0aCAvIDIpIGlzIG5lYXIgaW50ZWdlciBlZGdlLFxuICAvLyBvdGhlcndpc2UgbGluZSB3aWxsIGJlIGZ1enp5IGluIGNhbnZhcy5cbiAgdmFyIGRvdWJsZWRQb3NpdGlvbiA9IHJvdW5kKHBvc2l0aW9uICogMik7XG4gIHJldHVybiAoZG91YmxlZFBvc2l0aW9uICsgcm91bmQobGluZVdpZHRoKSkgJSAyID09PSAwID8gZG91YmxlZFBvc2l0aW9uIC8gMiA6IChkb3VibGVkUG9zaXRpb24gKyAocG9zaXRpdmVPck5lZ2F0aXZlID8gMSA6IC0xKSkgLyAyO1xufVxuXG5mdW5jdGlvbiBoYXNGaWxsT3JTdHJva2UoZmlsbE9yU3Ryb2tlKSB7XG4gIHJldHVybiBmaWxsT3JTdHJva2UgIT0gbnVsbCAmJiBmaWxsT3JTdHJva2UgIT0gJ25vbmUnO1xufVxuXG5mdW5jdGlvbiBsaWZ0Q29sb3IoY29sb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgPyBjb2xvclRvb2wubGlmdChjb2xvciwgLTAuMSkgOiBjb2xvcjtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNhY2hlRWxlbWVudFN0bChlbCkge1xuICBpZiAoZWwuX19ob3ZlclN0bERpcnR5KSB7XG4gICAgdmFyIHN0cm9rZSA9IGVsLnN0eWxlLnN0cm9rZTtcbiAgICB2YXIgZmlsbCA9IGVsLnN0eWxlLmZpbGw7IC8vIENyZWF0ZSBob3ZlclN0eWxlIG9uIG1vdXNlb3ZlclxuXG4gICAgdmFyIGhvdmVyU3R5bGUgPSBlbC5fX2hvdmVyU3RsO1xuICAgIGhvdmVyU3R5bGUuZmlsbCA9IGhvdmVyU3R5bGUuZmlsbCB8fCAoaGFzRmlsbE9yU3Ryb2tlKGZpbGwpID8gbGlmdENvbG9yKGZpbGwpIDogbnVsbCk7XG4gICAgaG92ZXJTdHlsZS5zdHJva2UgPSBob3ZlclN0eWxlLnN0cm9rZSB8fCAoaGFzRmlsbE9yU3Ryb2tlKHN0cm9rZSkgPyBsaWZ0Q29sb3Ioc3Ryb2tlKSA6IG51bGwpO1xuICAgIHZhciBub3JtYWxTdHlsZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBob3ZlclN0eWxlKSB7XG4gICAgICAvLyBTZWUgY29tbWVudCBpbiBgZG9TaW5nbGVFbnRlckhvdmVyYC5cbiAgICAgIGlmIChob3ZlclN0eWxlW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgbm9ybWFsU3R5bGVbbmFtZV0gPSBlbC5zdHlsZVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbC5fX25vcm1hbFN0bCA9IG5vcm1hbFN0eWxlO1xuICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IGZhbHNlO1xuICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBkb1NpbmdsZUVudGVySG92ZXIoZWwpIHtcbiAgaWYgKGVsLl9faXNIb3Zlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNhY2hlRWxlbWVudFN0bChlbCk7XG5cbiAgaWYgKGVsLnVzZUhvdmVyTGF5ZXIpIHtcbiAgICBlbC5fX3pyICYmIGVsLl9fenIuYWRkSG92ZXIoZWwsIGVsLl9faG92ZXJTdGwpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdHlsZSA9IGVsLnN0eWxlO1xuICAgIHZhciBpbnNpZGVSb2xsYmFja09wdCA9IHN0eWxlLmluc2lkZVJvbGxiYWNrT3B0OyAvLyBDb25zaWRlciBjYXNlOiBvbmx5IGBwb3NpdGlvbjogJ3RvcCdgIGlzIHNldCBvbiBlbXBoYXNpcywgdGhlbiB0ZXh0XG4gICAgLy8gY29sb3Igc2hvdWxkIGJlIHJldHVybmVkIHRvIGBhdXRvQ29sb3JgLCByYXRoZXIgdGhhbiByZW1haW4gJyNmZmYnLlxuICAgIC8vIFNvIHdlIHNob3VsZCByb2xsYmFjayB0aGVuIGFwcGx5IGFnYWluIGFmdGVyIHN0eWxlIG1lcmdpbmcuXG5cbiAgICBpbnNpZGVSb2xsYmFja09wdCAmJiByb2xsYmFja0luc2lkZVN0eWxlKHN0eWxlKTsgLy8gc3R5bGVzIGNhbiBiZTpcbiAgICAvLyB7XG4gICAgLy8gICAgIGxhYmVsOiB7XG4gICAgLy8gICAgICAgICBub3JtYWw6IHtcbiAgICAvLyAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAvLyAgICAgICAgICAgICBwb3NpdGlvbjogJ291dHNpZGUnLFxuICAgIC8vICAgICAgICAgICAgIGZvbnRTaXplOiAxOFxuICAgIC8vICAgICAgICAgfSxcbiAgICAvLyAgICAgICAgIGVtcGhhc2lzOiB7XG4gICAgLy8gICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gfSxcbiAgICAvLyB3aGVyZSBwcm9wZXJ0aWVzIG9mIGBlbXBoYXNpc2AgbWF5IG5vdCBhcHBlYXIgaW4gYG5vcm1hbGAuIFdlIHByZXZpb3VzbHkgdXNlXG4gICAgLy8gbW9kdWxlOmVjaGFydHMvdXRpbC9tb2RlbCNkZWZhdWx0RW1waGFzaXMgdG8gbWVyZ2UgYG5vcm1hbGAgdG8gYGVtcGhhc2lzYC5cbiAgICAvLyBCdXQgY29uc2lkZXIgcmljaCB0ZXh0IGFuZCBzZXRPcHRpb24gaW4gbWVyZ2UgbW9kZSwgaXQgaXMgaW1wb3NzaWJsZSB0byBjb3ZlclxuICAgIC8vIGFsbCBwcm9wZXJ0aWVzIGluIG1lcmdlLiBTbyB3ZSB1c2UgbWVyZ2UgbW9kZSB3aGVuIHNldHRpbmcgc3R5bGUgaGVyZSwgd2hlcmVcbiAgICAvLyBvbmx5IHByb3BlcnRpZXMgdGhhdCBpcyBub3QgYG51bGwvdW5kZWZpbmVkYCBjYW4gYmUgc2V0LiBUaGUgZGlzYWR2ZW50YWdlOlxuICAgIC8vIG51bGwvdW5kZWZpbmVkIGNhbiBub3QgYmUgdXNlZCB0byByZW1vdmUgc3R5bGUgYW55IG1vcmUgaW4gYGVtcGhhc2lzYC5cblxuICAgIHN0eWxlLmV4dGVuZEZyb20oZWwuX19ob3ZlclN0bCk7IC8vIERvIG5vdCBzYXZlIGBpbnNpZGVSb2xsYmFja2AuXG5cbiAgICBpZiAoaW5zaWRlUm9sbGJhY2tPcHQpIHtcbiAgICAgIGFwcGx5SW5zaWRlU3R5bGUoc3R5bGUsIHN0eWxlLmluc2lkZU9yaWdpbmFsVGV4dFBvc2l0aW9uLCBpbnNpZGVSb2xsYmFja09wdCk7IC8vIHRleHRGaWxsIG1heSBiZSByb2xsYmFja2VkIHRvIG51bGwuXG5cbiAgICAgIGlmIChzdHlsZS50ZXh0RmlsbCA9PSBudWxsKSB7XG4gICAgICAgIHN0eWxlLnRleHRGaWxsID0gaW5zaWRlUm9sbGJhY2tPcHQuYXV0b0NvbG9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsLmRpcnR5KGZhbHNlKTtcbiAgICBlbC56MiArPSAxO1xuICB9XG5cbiAgZWwuX19pc0hvdmVyID0gdHJ1ZTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpIHtcbiAgaWYgKCFlbC5fX2lzSG92ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbm9ybWFsU3RsID0gZWwuX19ub3JtYWxTdGw7XG5cbiAgaWYgKGVsLnVzZUhvdmVyTGF5ZXIpIHtcbiAgICBlbC5fX3pyICYmIGVsLl9fenIucmVtb3ZlSG92ZXIoZWwpO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnNpZGVyIG51bGwvdW5kZWZpbmVkIHZhbHVlLCBzaG91bGQgdXNlXG4gICAgLy8gYHNldFN0eWxlYCBidXQgbm90IGBleHRlbmRGcm9tKHN0bCwgdHJ1ZSlgLlxuICAgIG5vcm1hbFN0bCAmJiBlbC5zZXRTdHlsZShub3JtYWxTdGwpO1xuICAgIGVsLnoyIC09IDE7XG4gIH1cblxuICBlbC5fX2lzSG92ZXIgPSBmYWxzZTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBkb0VudGVySG92ZXIoZWwpIHtcbiAgZWwudHlwZSA9PT0gJ2dyb3VwJyA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICBkb1NpbmdsZUVudGVySG92ZXIoY2hpbGQpO1xuICAgIH1cbiAgfSkgOiBkb1NpbmdsZUVudGVySG92ZXIoZWwpO1xufVxuXG5mdW5jdGlvbiBkb0xlYXZlSG92ZXIoZWwpIHtcbiAgZWwudHlwZSA9PT0gJ2dyb3VwJyA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICBkb1NpbmdsZUxlYXZlSG92ZXIoY2hpbGQpO1xuICAgIH1cbiAgfSkgOiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdGwpIHtcbiAgLy8gSWYgZWxlbWVudCBoYXMgc2VwY2lmaWVkIGhvdmVyU3R5bGUsIHRoZW4gdXNlIGl0IGluc3RlYWQgb2YgZ2l2ZW4gaG92ZXJTdHlsZVxuICAvLyBPZnRlbiB1c2VkIHdoZW4gaXRlbSBncm91cCBoYXMgYSBsYWJlbCBlbGVtZW50IGFuZCBpdCdzIGhvdmVyU3R5bGUgaXMgZGlmZmVyZW50XG4gIGVsLl9faG92ZXJTdGwgPSBlbC5ob3ZlclN0eWxlIHx8IGhvdmVyU3RsIHx8IHt9O1xuICBlbC5fX2hvdmVyU3RsRGlydHkgPSB0cnVlO1xuXG4gIGlmIChlbC5fX2lzSG92ZXIpIHtcbiAgICBjYWNoZUVsZW1lbnRTdGwoZWwpO1xuICB9XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdmVyKGUpIHtcbiAgaWYgKHRoaXMuX19ob3ZlclNpbGVudE9uVG91Y2ggJiYgZS56ckJ5VG91Y2gpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcblxuXG4gICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0VudGVySG92ZXIodGhpcyk7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdXQoZSkge1xuICBpZiAodGhpcy5fX2hvdmVyU2lsZW50T25Ub3VjaCAmJiBlLnpyQnlUb3VjaCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xuXG5cbiAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvTGVhdmVIb3Zlcih0aGlzKTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBlbnRlckVtcGhhc2lzKCkge1xuICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XG4gIGRvRW50ZXJIb3Zlcih0aGlzKTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBsZWF2ZUVtcGhhc2lzKCkge1xuICB0aGlzLl9faXNFbXBoYXNpcyA9IGZhbHNlO1xuICBkb0xlYXZlSG92ZXIodGhpcyk7XG59XG4vKipcbiAqIFNldCBob3ZlciBzdHlsZSBvZiBlbGVtZW50LlxuICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCByZXBlYXRseSB3aXRob3V0IHNpZGUtZWZmZWN0cy5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaG92ZXJTdHlsZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0LmhvdmVyU2lsZW50T25Ub3VjaD1mYWxzZV1cbiAqICAgICAgICBJbiB0b3VjaCBkZXZpY2UsIG1vdXNlb3ZlciBldmVudCB3aWxsIGJlIHRyaWdnZXIgb24gdG91Y2hzdGFydCBldmVudFxuICogICAgICAgIChzZWUgbW9kdWxlOnpyZW5kZXIvZG9tL0hhbmRsZXJQcm94eSkuIEJ5IHRoaXMgbWVjaGFuaXNtLCB3ZSBjYW5cbiAqICAgICAgICBjb252aW5pZW50bHkgdXNlIGhvdmVyU3R5bGUgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuIHdpdGhvdXQgYWRkaXRpb25hbFxuICogICAgICAgIGNvZGUgZm9yIGNvbXBhdGliaWxpdHkuXG4gKiAgICAgICAgQnV0IGlmIHRoZSBjaGFydC9jb21wb25lbnQgaGFzIHNlbGVjdCBmZWF0dXJlLCB3aGljaCB1c3VhbGx5IGFsc28gdXNlXG4gKiAgICAgICAgaG92ZXJTdHlsZSwgdGhlcmUgbWlnaHQgYmUgY29uZmxpY3QgYmV0d2VlbiAnc2VsZWN0LWhpZ2hsaWdodCcgYW5kXG4gKiAgICAgICAgJ2hvdmVyLWhpZ2hsaWdodCcgZXNwZWNpYWxseSB3aGVuIHJvYW0gaXMgZW5hYmxlZCAoc2VlIGdlbyBmb3IgZXhhbXBsZSkuXG4gKiAgICAgICAgSW4gdGhpcyBjYXNlLCBob3ZlclNpbGVudE9uVG91Y2ggc2hvdWxkIGJlIHVzZWQgdG8gZGlzYWJsZSBob3Zlci1oaWdobGlnaHRcbiAqICAgICAgICBvbiB0b3VjaCBkZXZpY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRIb3ZlclN0eWxlKGVsLCBob3ZlclN0eWxlLCBvcHQpIHtcbiAgZWwuX19ob3ZlclNpbGVudE9uVG91Y2ggPSBvcHQgJiYgb3B0LmhvdmVyU2lsZW50T25Ub3VjaDtcbiAgZWwudHlwZSA9PT0gJ2dyb3VwJyA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICBzZXRFbGVtZW50SG92ZXJTdGwoY2hpbGQsIGhvdmVyU3R5bGUpO1xuICAgIH1cbiAgfSkgOiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3R5bGUpOyAvLyBEdXBsaWNhdGVkIGZ1bmN0aW9uIHdpbGwgYmUgYXV0by1pZ25vcmVkLCBzZWUgRXZlbnRmdWwuanMuXG5cbiAgZWwub24oJ21vdXNlb3ZlcicsIG9uRWxlbWVudE1vdXNlT3Zlcikub24oJ21vdXNlb3V0Jywgb25FbGVtZW50TW91c2VPdXQpOyAvLyBFbXBoYXNpcywgbm9ybWFsIGNhbiBiZSB0cmlnZ2VyZWQgbWFudWFsbHlcblxuICBlbC5vbignZW1waGFzaXMnLCBlbnRlckVtcGhhc2lzKS5vbignbm9ybWFsJywgbGVhdmVFbXBoYXNpcyk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IG5vcm1hbFN0eWxlXG4gKiBAcGFyYW0ge09iamVjdH0gZW1waGFzaXNTdHlsZVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbm9ybWFsTW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGVtcGhhc2lzTW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgQ2hlY2sgYG9wdGAgb2YgYHNldFRleHRTdHlsZUNvbW1vbmAgdG8gZmluZCBvdGhlciBwcm9wcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0LmRlZmF1bHRUZXh0XVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW29wdC5sYWJlbEZldGNoZXJdIEZldGNoIHRleHQgYnlcbiAqICAgICAgYG9wdC5sYWJlbEZldGNoZXIuZ2V0Rm9ybWF0dGVkTGFiZWwob3B0LmxhYmVsRGF0YUluZGV4LCAnbm9ybWFsJy8nZW1waGFzaXMnLCBudWxsLCBvcHQubGFiZWxEaW1JbmRleClgXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbb3B0LmxhYmVsRGF0YUluZGV4XSBGZXRjaCB0ZXh0IGJ5XG4gKiAgICAgIGBvcHQudGV4dEZldGNoZXIuZ2V0Rm9ybWF0dGVkTGFiZWwob3B0LmxhYmVsRGF0YUluZGV4LCAnbm9ybWFsJy8nZW1waGFzaXMnLCBudWxsLCBvcHQubGFiZWxEaW1JbmRleClgXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbb3B0LmxhYmVsRGltSW5kZXhdIEZldGNoIHRleHQgYnlcbiAqICAgICAgYG9wdC50ZXh0RmV0Y2hlci5nZXRGb3JtYXR0ZWRMYWJlbChvcHQubGFiZWxEYXRhSW5kZXgsICdub3JtYWwnLydlbXBoYXNpcycsIG51bGwsIG9wdC5sYWJlbERpbUluZGV4KWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbbm9ybWFsU3BlY2lmaWVkXVxuICogQHBhcmFtIHtPYmplY3R9IFtlbXBoYXNpc1NwZWNpZmllZF1cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldExhYmVsU3R5bGUobm9ybWFsU3R5bGUsIGVtcGhhc2lzU3R5bGUsIG5vcm1hbE1vZGVsLCBlbXBoYXNpc01vZGVsLCBvcHQsIG5vcm1hbFNwZWNpZmllZCwgZW1waGFzaXNTcGVjaWZpZWQpIHtcbiAgb3B0ID0gb3B0IHx8IEVNUFRZX09CSjtcbiAgdmFyIGxhYmVsRmV0Y2hlciA9IG9wdC5sYWJlbEZldGNoZXI7XG4gIHZhciBsYWJlbERhdGFJbmRleCA9IG9wdC5sYWJlbERhdGFJbmRleDtcbiAgdmFyIGxhYmVsRGltSW5kZXggPSBvcHQubGFiZWxEaW1JbmRleDsgLy8gVGhpcyBzY2VuYXJpbywgYGxhYmVsLm5vcm1hbC5zaG93ID0gdHJ1ZTsgbGFiZWwuZW1waGFzaXMuc2hvdyA9IGZhbHNlYCxcbiAgLy8gaXMgbm90IHN1cHBvcnRlZCB1dGlsIHNvbWVvbmUgcmVxdWVzdHMuXG5cbiAgdmFyIHNob3dOb3JtYWwgPSBub3JtYWxNb2RlbC5nZXRTaGFsbG93KCdzaG93Jyk7XG4gIHZhciBzaG93RW1waGFzaXMgPSBlbXBoYXNpc01vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTsgLy8gQ29uc2lkZXIgcGVyZm9ybWFuY2UsIG9ubHkgZmV0Y2ggbGFiZWwgd2hlbiBuZWNlc3NhcnkuXG4gIC8vIElmIGBub3JtYWwuc2hvd2AgaXMgYGZhbHNlYCBhbmQgYGVtcGhhc2lzLnNob3dgIGlzIGB0cnVlYCBhbmQgYGVtcGhhc2lzLmZvcm1hdHRlcmAgaXMgbm90IHNldCxcbiAgLy8gbGFiZWwgc2hvdWxkIGJlIGRpc3BsYXllZCwgd2hlcmUgdGV4dCBpcyBmZXRjaGVkIGJ5IGBub3JtYWwuZm9ybWF0dGVyYCBvciBgb3B0LmRlZmF1bHRUZXh0YC5cblxuICB2YXIgYmFzZVRleHQgPSBzaG93Tm9ybWFsIHx8IHNob3dFbXBoYXNpcyA/IHpyVXRpbC5yZXRyaWV2ZTIobGFiZWxGZXRjaGVyID8gbGFiZWxGZXRjaGVyLmdldEZvcm1hdHRlZExhYmVsKGxhYmVsRGF0YUluZGV4LCAnbm9ybWFsJywgbnVsbCwgbGFiZWxEaW1JbmRleCkgOiBudWxsLCBvcHQuZGVmYXVsdFRleHQpIDogbnVsbDtcbiAgdmFyIG5vcm1hbFN0eWxlVGV4dCA9IHNob3dOb3JtYWwgPyBiYXNlVGV4dCA6IG51bGw7XG4gIHZhciBlbXBoYXNpc1N0eWxlVGV4dCA9IHNob3dFbXBoYXNpcyA/IHpyVXRpbC5yZXRyaWV2ZTIobGFiZWxGZXRjaGVyID8gbGFiZWxGZXRjaGVyLmdldEZvcm1hdHRlZExhYmVsKGxhYmVsRGF0YUluZGV4LCAnZW1waGFzaXMnLCBudWxsLCBsYWJlbERpbUluZGV4KSA6IG51bGwsIGJhc2VUZXh0KSA6IG51bGw7IC8vIE9wdGltaXplOiBJZiBzdHlsZS50ZXh0IGlzIG51bGwsIHRleHQgd2lsbCBub3QgYmUgZHJhd24uXG5cbiAgaWYgKG5vcm1hbFN0eWxlVGV4dCAhPSBudWxsIHx8IGVtcGhhc2lzU3R5bGVUZXh0ICE9IG51bGwpIHtcbiAgICAvLyBBbHdheXMgc2V0IGB0ZXh0U3R5bGVgIGV2ZW4gaWYgYG5vcm1hbFN0eWxlLnRleHRgIGlzIG51bGwsIGJlY2F1c2UgZGVmYXVsdFxuICAgIC8vIHZhbHVlcyBoYXZlIHRvIGJlIHNldCBvbiBgbm9ybWFsU3R5bGVgLlxuICAgIC8vIElmIHdlIHNldCBkZWZhdWx0IHZhbHVlcyBvbiBgZW1waGFzaXNTdHlsZWAsIGNvbnNpZGVyIGNhc2U6XG4gICAgLy8gRmlyc3RseSwgYHNldE9wdGlvbiguLi4gbGFiZWw6IHtub3JtYWw6IHt0ZXh0OiBudWxsfSwgZW1waGFzaXM6IHtzaG93OiB0cnVlfX0gLi4uKTtgXG4gICAgLy8gU2Vjb25kbHksIGBzZXRPcHRpb24oLi4uIGxhYmVsOiB7bm9yYW1sOiB7c2hvdzogdHJ1ZSwgdGV4dDogJ2FiYycsIGNvbG9yOiAncmVkJ30gLi4uKTtgXG4gICAgLy8gVGhlbiB0aGUgJ3JlZCcgd2lsbCBub3Qgd29yayBvbiBlbXBoYXNpcy5cbiAgICBzZXRUZXh0U3R5bGUobm9ybWFsU3R5bGUsIG5vcm1hbE1vZGVsLCBub3JtYWxTcGVjaWZpZWQsIG9wdCk7XG4gICAgc2V0VGV4dFN0eWxlKGVtcGhhc2lzU3R5bGUsIGVtcGhhc2lzTW9kZWwsIGVtcGhhc2lzU3BlY2lmaWVkLCBvcHQsIHRydWUpO1xuICB9XG5cbiAgbm9ybWFsU3R5bGUudGV4dCA9IG5vcm1hbFN0eWxlVGV4dDtcbiAgZW1waGFzaXNTdHlsZS50ZXh0ID0gZW1waGFzaXNTdHlsZVRleHQ7XG59XG4vKipcbiAqIFNldCBiYXNpYyB0ZXh0U3R5bGUgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHRleHRTdHlsZVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3BlY2lmaWVkVGV4dFN0eWxlXSBDYW4gYmUgb3ZlcnJpZGVkIGJ5IHNldHRpbmdzIGluIG1vZGVsLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRdIFNlZSBgb3B0YCBvZiBgc2V0VGV4dFN0eWxlQ29tbW9uYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRW1waGFzaXNdXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUZXh0U3R5bGUodGV4dFN0eWxlLCB0ZXh0U3R5bGVNb2RlbCwgc3BlY2lmaWVkVGV4dFN0eWxlLCBvcHQsIGlzRW1waGFzaXMpIHtcbiAgc2V0VGV4dFN0eWxlQ29tbW9uKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIG9wdCwgaXNFbXBoYXNpcyk7XG4gIHNwZWNpZmllZFRleHRTdHlsZSAmJiB6clV0aWwuZXh0ZW5kKHRleHRTdHlsZSwgc3BlY2lmaWVkVGV4dFN0eWxlKTtcbiAgdGV4dFN0eWxlLmhvc3QgJiYgdGV4dFN0eWxlLmhvc3QuZGlydHkgJiYgdGV4dFN0eWxlLmhvc3QuZGlydHkoZmFsc2UpO1xuICByZXR1cm4gdGV4dFN0eWxlO1xufVxuLyoqXG4gKiBTZXQgdGV4dCBvcHRpb24gaW4gdGhlIHN0eWxlLlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0U3R5bGVcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGxhYmVsTW9kZWxcbiAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IGRlZmF1bHRDb2xvciBEZWZhdWx0IHRleHQgY29sb3IuXG4gKiAgICAgICAgSWYgc2V0IGFzIGZhbHNlLCBpdCB3aWxsIGJlIHByb2Nlc3NlZCBhcyBhIGVtcGhhc2lzIHN0eWxlLlxuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dCh0ZXh0U3R5bGUsIGxhYmVsTW9kZWwsIGRlZmF1bHRDb2xvcikge1xuICB2YXIgb3B0ID0ge1xuICAgIGlzUmVjdFRleHQ6IHRydWVcbiAgfTtcbiAgdmFyIGlzRW1waGFzaXM7XG5cbiAgaWYgKGRlZmF1bHRDb2xvciA9PT0gZmFsc2UpIHtcbiAgICBpc0VtcGhhc2lzID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdXBwb3J0IHNldHRpbmcgY29sb3IgYXMgJ2F1dG8nIHRvIGdldCB2aXN1YWwgY29sb3IuXG4gICAgb3B0LmF1dG9Db2xvciA9IGRlZmF1bHRDb2xvcjtcbiAgfVxuXG4gIHNldFRleHRTdHlsZUNvbW1vbih0ZXh0U3R5bGUsIGxhYmVsTW9kZWwsIG9wdCwgaXNFbXBoYXNpcyk7XG4gIHRleHRTdHlsZS5ob3N0ICYmIHRleHRTdHlsZS5ob3N0LmRpcnR5ICYmIHRleHRTdHlsZS5ob3N0LmRpcnR5KGZhbHNlKTtcbn1cbi8qKlxuICoge1xuICogICAgICBkaXNhYmxlQm94OiBib29sZWFuLCBXaGV0aGVyIGRpYWJsZSBkcmF3aW5nIGJveCBvZiBibG9jayAob3V0ZXIgbW9zdCkuXG4gKiAgICAgIGlzUmVjdFRleHQ6IGJvb2xlYW4sXG4gKiAgICAgIGF1dG9Db2xvcjogc3RyaW5nLCBzcGVjaWZ5IGEgY29sb3Igd2hlbiBjb2xvciBpcyAnYXV0bycsXG4gKiAgICAgICAgICAgICAgZm9yIHRleHRGaWxsLCB0ZXh0U3Ryb2tlLCB0ZXh0QmFja2dyb3VuZENvbG9yLCBhbmQgdGV4dEJvcmRlckNvbG9yLlxuICogICAgICAgICAgICAgIElmIGF1dG9Db2xvciBzcGVjaWZpZWQsIGl0IGlzIHVzZWQgYXMgZGVmYXVsdCB0ZXh0RmlsbC5cbiAqICAgICAgdXNlSW5zaWRlU3R5bGU6XG4gKiAgICAgICAgICAgICAgYHRydWVgOiBVc2UgaW5zaWRlIHN0eWxlICh0ZXh0RmlsbCwgdGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKVxuICogICAgICAgICAgICAgICAgICBpZiBgdGV4dEZpbGxgIGlzIG5vdCBzcGVjaWZpZWQuXG4gKiAgICAgICAgICAgICAgYGZhbHNlYDogRG8gbm90IHVzZSBpbnNpZGUgc3R5bGUuXG4gKiAgICAgICAgICAgICAgYG51bGwvdW5kZWZpbmVkYDogdXNlIGluc2lkZSBzdHlsZSBpZiBgaXNSZWN0VGV4dGAgaXMgdHJ1ZSBhbmRcbiAqICAgICAgICAgICAgICAgICAgYHRleHRGaWxsYCBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0ZXh0UG9zaXRpb24gY29udGFpbnMgYCdpbnNpZGUnYC5cbiAqICAgICAgZm9yY2VSaWNoOiBib29sZWFuXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUZXh0U3R5bGVDb21tb24odGV4dFN0eWxlLCB0ZXh0U3R5bGVNb2RlbCwgb3B0LCBpc0VtcGhhc2lzKSB7XG4gIC8vIENvbnNpZGVyIHRoZXJlIHdpbGwgYmUgYWJub3JtYWwgd2hlbiBtZXJnZSBob3ZlciBzdHlsZSB0byBub3JtYWwgc3R5bGUgaWYgZ2l2ZW4gZGVmYXVsdCB2YWx1ZS5cbiAgb3B0ID0gb3B0IHx8IEVNUFRZX09CSjtcblxuICBpZiAob3B0LmlzUmVjdFRleHQpIHtcbiAgICB2YXIgdGV4dFBvc2l0aW9uID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygncG9zaXRpb24nKSB8fCAoaXNFbXBoYXNpcyA/IG51bGwgOiAnaW5zaWRlJyk7IC8vICdvdXRzaWRlJyBpcyBub3QgYSB2YWxpZCB6ciB0ZXh0UG9zdGlvbiB2YWx1ZSwgYnV0IHVzZWRcbiAgICAvLyBpbiBiYXIgc2VyaWVzLCBhbmQgbWFncmljIHR5cGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQuXG5cbiAgICB0ZXh0UG9zaXRpb24gPT09ICdvdXRzaWRlJyAmJiAodGV4dFBvc2l0aW9uID0gJ3RvcCcpO1xuICAgIHRleHRTdHlsZS50ZXh0UG9zaXRpb24gPSB0ZXh0UG9zaXRpb247XG4gICAgdGV4dFN0eWxlLnRleHRPZmZzZXQgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdvZmZzZXQnKTtcbiAgICB2YXIgbGFiZWxSb3RhdGUgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdyb3RhdGUnKTtcbiAgICBsYWJlbFJvdGF0ZSAhPSBudWxsICYmIChsYWJlbFJvdGF0ZSAqPSBNYXRoLlBJIC8gMTgwKTtcbiAgICB0ZXh0U3R5bGUudGV4dFJvdGF0aW9uID0gbGFiZWxSb3RhdGU7XG4gICAgdGV4dFN0eWxlLnRleHREaXN0YW5jZSA9IHpyVXRpbC5yZXRyaWV2ZTIodGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZGlzdGFuY2UnKSwgaXNFbXBoYXNpcyA/IG51bGwgOiA1KTtcbiAgfVxuXG4gIHZhciBlY01vZGVsID0gdGV4dFN0eWxlTW9kZWwuZWNNb2RlbDtcbiAgdmFyIGdsb2JhbFRleHRTdHlsZSA9IGVjTW9kZWwgJiYgZWNNb2RlbC5vcHRpb24udGV4dFN0eWxlOyAvLyBDb25zaWRlciBjYXNlOlxuICAvLyB7XG4gIC8vICAgICBkYXRhOiBbe1xuICAvLyAgICAgICAgIHZhbHVlOiAxMixcbiAgLy8gICAgICAgICBsYWJlbDoge1xuICAvLyAgICAgICAgICAgICBub3JtYWw6IHtcbiAgLy8gICAgICAgICAgICAgICAgIHJpY2g6IHtcbiAgLy8gICAgICAgICAgICAgICAgICAgICAvLyBubyAnYScgaGVyZSBidXQgdXNpbmcgcGFyZW50ICdhJy5cbiAgLy8gICAgICAgICAgICAgICAgIH1cbiAgLy8gICAgICAgICAgICAgfVxuICAvLyAgICAgICAgIH1cbiAgLy8gICAgIH1dLFxuICAvLyAgICAgcmljaDoge1xuICAvLyAgICAgICAgIGE6IHsgLi4uIH1cbiAgLy8gICAgIH1cbiAgLy8gfVxuXG4gIHZhciByaWNoSXRlbU5hbWVzID0gZ2V0UmljaEl0ZW1OYW1lcyh0ZXh0U3R5bGVNb2RlbCk7XG4gIHZhciByaWNoUmVzdWx0O1xuXG4gIGlmIChyaWNoSXRlbU5hbWVzKSB7XG4gICAgcmljaFJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiByaWNoSXRlbU5hbWVzKSB7XG4gICAgICBpZiAocmljaEl0ZW1OYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAvLyBDYXNjYWRlIGlzIHN1cHBvcnRlZCBpbiByaWNoLlxuICAgICAgICB2YXIgcmljaFRleHRTdHlsZSA9IHRleHRTdHlsZU1vZGVsLmdldE1vZGVsKFsncmljaCcsIG5hbWVdKTsgLy8gSW4gcmljaCwgbmV2ZXIgYGRpc2FibGVCb3hgLlxuXG4gICAgICAgIHNldFRva2VuVGV4dFN0eWxlKHJpY2hSZXN1bHRbbmFtZV0gPSB7fSwgcmljaFRleHRTdHlsZSwgZ2xvYmFsVGV4dFN0eWxlLCBvcHQsIGlzRW1waGFzaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRleHRTdHlsZS5yaWNoID0gcmljaFJlc3VsdDtcbiAgc2V0VG9rZW5UZXh0U3R5bGUodGV4dFN0eWxlLCB0ZXh0U3R5bGVNb2RlbCwgZ2xvYmFsVGV4dFN0eWxlLCBvcHQsIGlzRW1waGFzaXMsIHRydWUpO1xuXG4gIGlmIChvcHQuZm9yY2VSaWNoICYmICFvcHQudGV4dFN0eWxlKSB7XG4gICAgb3B0LnRleHRTdHlsZSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHRleHRTdHlsZTtcbn0gLy8gQ29uc2lkZXIgY2FzZTpcbi8vIHtcbi8vICAgICBkYXRhOiBbe1xuLy8gICAgICAgICB2YWx1ZTogMTIsXG4vLyAgICAgICAgIGxhYmVsOiB7XG4vLyAgICAgICAgICAgICBub3JtYWw6IHtcbi8vICAgICAgICAgICAgICAgICByaWNoOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgIC8vIG5vICdhJyBoZXJlIGJ1dCB1c2luZyBwYXJlbnQgJ2EnLlxuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gICAgIH1dLFxuLy8gICAgIHJpY2g6IHtcbi8vICAgICAgICAgYTogeyAuLi4gfVxuLy8gICAgIH1cbi8vIH1cblxuXG5mdW5jdGlvbiBnZXRSaWNoSXRlbU5hbWVzKHRleHRTdHlsZU1vZGVsKSB7XG4gIC8vIFVzZSBvYmplY3QgdG8gcmVtb3ZlIGR1cGxpY2F0ZWQgbmFtZXMuXG4gIHZhciByaWNoSXRlbU5hbWVNYXA7XG5cbiAgd2hpbGUgKHRleHRTdHlsZU1vZGVsICYmIHRleHRTdHlsZU1vZGVsICE9PSB0ZXh0U3R5bGVNb2RlbC5lY01vZGVsKSB7XG4gICAgdmFyIHJpY2ggPSAodGV4dFN0eWxlTW9kZWwub3B0aW9uIHx8IEVNUFRZX09CSikucmljaDtcblxuICAgIGlmIChyaWNoKSB7XG4gICAgICByaWNoSXRlbU5hbWVNYXAgPSByaWNoSXRlbU5hbWVNYXAgfHwge307XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcmljaCkge1xuICAgICAgICBpZiAocmljaC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHJpY2hJdGVtTmFtZU1hcFtuYW1lXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXh0U3R5bGVNb2RlbCA9IHRleHRTdHlsZU1vZGVsLnBhcmVudE1vZGVsO1xuICB9XG5cbiAgcmV0dXJuIHJpY2hJdGVtTmFtZU1hcDtcbn1cblxuZnVuY3Rpb24gc2V0VG9rZW5UZXh0U3R5bGUodGV4dFN0eWxlLCB0ZXh0U3R5bGVNb2RlbCwgZ2xvYmFsVGV4dFN0eWxlLCBvcHQsIGlzRW1waGFzaXMsIGlzQmxvY2spIHtcbiAgLy8gSW4gbWVyZ2UgbW9kZSwgZGVmYXVsdCB2YWx1ZSBzaG91bGQgbm90IGJlIGdpdmVuLlxuICBnbG9iYWxUZXh0U3R5bGUgPSAhaXNFbXBoYXNpcyAmJiBnbG9iYWxUZXh0U3R5bGUgfHwgRU1QVFlfT0JKO1xuICB0ZXh0U3R5bGUudGV4dEZpbGwgPSBnZXRBdXRvQ29sb3IodGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnY29sb3InKSwgb3B0KSB8fCBnbG9iYWxUZXh0U3R5bGUuY29sb3I7XG4gIHRleHRTdHlsZS50ZXh0U3Ryb2tlID0gZ2V0QXV0b0NvbG9yKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RleHRCb3JkZXJDb2xvcicpLCBvcHQpIHx8IGdsb2JhbFRleHRTdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG4gIHRleHRTdHlsZS50ZXh0U3Ryb2tlV2lkdGggPSB6clV0aWwucmV0cmlldmUyKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RleHRCb3JkZXJXaWR0aCcpLCBnbG9iYWxUZXh0U3R5bGUudGV4dEJvcmRlcldpZHRoKTtcblxuICBpZiAoIWlzRW1waGFzaXMpIHtcbiAgICBpZiAoaXNCbG9jaykge1xuICAgICAgLy8gQWx3YXlzIHNldCBgaW5zaWRlUm9sbGJhY2tgLCBmb3IgY2xlYXJpbmcgcHJldmlvdXMuXG4gICAgICB2YXIgb3JpZ2luYWxUZXh0UG9zaXRpb24gPSB0ZXh0U3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgdGV4dFN0eWxlLmluc2lkZVJvbGxiYWNrID0gYXBwbHlJbnNpZGVTdHlsZSh0ZXh0U3R5bGUsIG9yaWdpbmFsVGV4dFBvc2l0aW9uLCBvcHQpOyAvLyBTYXZlIG9yaWdpbmFsIHRleHRQb3NpdGlvbiwgYmVjYXVzZSBzdHlsZS50ZXh0UG9zaXRpb24gd2lsbCBiZSByZXBhbGNlZCBieVxuICAgICAgLy8gcmVhbCBsb2NhdGlvbiAobGlrZSBbMTAsIDMwXSkgaW4genJlbmRlci5cblxuICAgICAgdGV4dFN0eWxlLmluc2lkZU9yaWdpbmFsVGV4dFBvc2l0aW9uID0gb3JpZ2luYWxUZXh0UG9zaXRpb247XG4gICAgICB0ZXh0U3R5bGUuaW5zaWRlUm9sbGJhY2tPcHQgPSBvcHQ7XG4gICAgfSAvLyBTZXQgZGVmYXVsdCBmaW5hbGx5LlxuXG5cbiAgICBpZiAodGV4dFN0eWxlLnRleHRGaWxsID09IG51bGwpIHtcbiAgICAgIHRleHRTdHlsZS50ZXh0RmlsbCA9IG9wdC5hdXRvQ29sb3I7XG4gICAgfVxuICB9IC8vIERvIG5vdCB1c2UgYGdldEZvbnRgIGhlcmUsIGJlY2F1c2UgbWVyZ2Ugc2hvdWxkIGJlIHN1cHBvcnRlZCwgd2hlcmVcbiAgLy8gcGFydCBvZiB0aGVzZSBwcm9wZXJ0aWVzIG1heSBiZSBjaGFuZ2VkIGluIGVtcGhhc2lzIHN0eWxlLCBhbmQgdGhlXG4gIC8vIG90aGVycyBzaG91bGQgcmVtYWluIHRoZWlyIG9yaWdpbmFsIHZhbHVlIGdvdCBmcm9tIG5vcm1hbCBzdHlsZS5cblxuXG4gIHRleHRTdHlsZS5mb250U3R5bGUgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250U3R5bGUnKSB8fCBnbG9iYWxUZXh0U3R5bGUuZm9udFN0eWxlO1xuICB0ZXh0U3R5bGUuZm9udFdlaWdodCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRXZWlnaHQnKSB8fCBnbG9iYWxUZXh0U3R5bGUuZm9udFdlaWdodDtcbiAgdGV4dFN0eWxlLmZvbnRTaXplID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFNpemUnKSB8fCBnbG9iYWxUZXh0U3R5bGUuZm9udFNpemU7XG4gIHRleHRTdHlsZS5mb250RmFtaWx5ID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udEZhbWlseScpIHx8IGdsb2JhbFRleHRTdHlsZS5mb250RmFtaWx5O1xuICB0ZXh0U3R5bGUudGV4dEFsaWduID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnYWxpZ24nKTtcbiAgdGV4dFN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygndmVydGljYWxBbGlnbicpIHx8IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2Jhc2VsaW5lJyk7XG4gIHRleHRTdHlsZS50ZXh0TGluZUhlaWdodCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2xpbmVIZWlnaHQnKTtcbiAgdGV4dFN0eWxlLnRleHRXaWR0aCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3dpZHRoJyk7XG4gIHRleHRTdHlsZS50ZXh0SGVpZ2h0ID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnaGVpZ2h0Jyk7XG4gIHRleHRTdHlsZS50ZXh0VGFnID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygndGFnJyk7XG5cbiAgaWYgKCFpc0Jsb2NrIHx8ICFvcHQuZGlzYWJsZUJveCkge1xuICAgIHRleHRTdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yID0gZ2V0QXV0b0NvbG9yKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2JhY2tncm91bmRDb2xvcicpLCBvcHQpO1xuICAgIHRleHRTdHlsZS50ZXh0UGFkZGluZyA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3BhZGRpbmcnKTtcbiAgICB0ZXh0U3R5bGUudGV4dEJvcmRlckNvbG9yID0gZ2V0QXV0b0NvbG9yKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2JvcmRlckNvbG9yJyksIG9wdCk7XG4gICAgdGV4dFN0eWxlLnRleHRCb3JkZXJXaWR0aCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2JvcmRlcldpZHRoJyk7XG4gICAgdGV4dFN0eWxlLnRleHRCb3JkZXJSYWRpdXMgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdib3JkZXJSYWRpdXMnKTtcbiAgICB0ZXh0U3R5bGUudGV4dEJveFNoYWRvd0NvbG9yID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnc2hhZG93Q29sb3InKTtcbiAgICB0ZXh0U3R5bGUudGV4dEJveFNoYWRvd0JsdXIgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdzaGFkb3dCbHVyJyk7XG4gICAgdGV4dFN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRYID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnc2hhZG93T2Zmc2V0WCcpO1xuICAgIHRleHRTdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WSA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3NoYWRvd09mZnNldFknKTtcbiAgfVxuXG4gIHRleHRTdHlsZS50ZXh0U2hhZG93Q29sb3IgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0ZXh0U2hhZG93Q29sb3InKSB8fCBnbG9iYWxUZXh0U3R5bGUudGV4dFNoYWRvd0NvbG9yO1xuICB0ZXh0U3R5bGUudGV4dFNoYWRvd0JsdXIgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0ZXh0U2hhZG93Qmx1cicpIHx8IGdsb2JhbFRleHRTdHlsZS50ZXh0U2hhZG93Qmx1cjtcbiAgdGV4dFN0eWxlLnRleHRTaGFkb3dPZmZzZXRYID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygndGV4dFNoYWRvd09mZnNldFgnKSB8fCBnbG9iYWxUZXh0U3R5bGUudGV4dFNoYWRvd09mZnNldFg7XG4gIHRleHRTdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RleHRTaGFkb3dPZmZzZXRZJykgfHwgZ2xvYmFsVGV4dFN0eWxlLnRleHRTaGFkb3dPZmZzZXRZO1xufVxuXG5mdW5jdGlvbiBnZXRBdXRvQ29sb3IoY29sb3IsIG9wdCkge1xuICByZXR1cm4gY29sb3IgIT09ICdhdXRvJyA/IGNvbG9yIDogb3B0ICYmIG9wdC5hdXRvQ29sb3IgPyBvcHQuYXV0b0NvbG9yIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbnNpZGVTdHlsZSh0ZXh0U3R5bGUsIHRleHRQb3NpdGlvbiwgb3B0KSB7XG4gIHZhciB1c2VJbnNpZGVTdHlsZSA9IG9wdC51c2VJbnNpZGVTdHlsZTtcbiAgdmFyIGluc2lkZVJvbGxiYWNrO1xuXG4gIGlmICh0ZXh0U3R5bGUudGV4dEZpbGwgPT0gbnVsbCAmJiB1c2VJbnNpZGVTdHlsZSAhPT0gZmFsc2UgJiYgKHVzZUluc2lkZVN0eWxlID09PSB0cnVlIHx8IG9wdC5pc1JlY3RUZXh0ICYmIHRleHRQb3NpdGlvbiAvLyB0ZXh0UG9zaXRpb24gY2FuIGJlIFsxMCwgMzBdXG4gICYmIHR5cGVvZiB0ZXh0UG9zaXRpb24gPT09ICdzdHJpbmcnICYmIHRleHRQb3NpdGlvbi5pbmRleE9mKCdpbnNpZGUnKSA+PSAwKSkge1xuICAgIGluc2lkZVJvbGxiYWNrID0ge1xuICAgICAgdGV4dEZpbGw6IG51bGwsXG4gICAgICB0ZXh0U3Ryb2tlOiB0ZXh0U3R5bGUudGV4dFN0cm9rZSxcbiAgICAgIHRleHRTdHJva2VXaWR0aDogdGV4dFN0eWxlLnRleHRTdHJva2VXaWR0aFxuICAgIH07XG4gICAgdGV4dFN0eWxlLnRleHRGaWxsID0gJyNmZmYnOyAvLyBDb25zaWRlciB0ZXh0IHdpdGggI2ZmZiBvdmVyZmxvdyBpdHMgY29udGFpbmVyLlxuXG4gICAgaWYgKHRleHRTdHlsZS50ZXh0U3Ryb2tlID09IG51bGwpIHtcbiAgICAgIHRleHRTdHlsZS50ZXh0U3Ryb2tlID0gb3B0LmF1dG9Db2xvcjtcbiAgICAgIHRleHRTdHlsZS50ZXh0U3Ryb2tlV2lkdGggPT0gbnVsbCAmJiAodGV4dFN0eWxlLnRleHRTdHJva2VXaWR0aCA9IDIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnNpZGVSb2xsYmFjaztcbn1cblxuZnVuY3Rpb24gcm9sbGJhY2tJbnNpZGVTdHlsZShzdHlsZSkge1xuICB2YXIgaW5zaWRlUm9sbGJhY2sgPSBzdHlsZS5pbnNpZGVSb2xsYmFjaztcblxuICBpZiAoaW5zaWRlUm9sbGJhY2spIHtcbiAgICBzdHlsZS50ZXh0RmlsbCA9IGluc2lkZVJvbGxiYWNrLnRleHRGaWxsO1xuICAgIHN0eWxlLnRleHRTdHJva2UgPSBpbnNpZGVSb2xsYmFjay50ZXh0U3Ryb2tlO1xuICAgIHN0eWxlLnRleHRTdHJva2VXaWR0aCA9IGluc2lkZVJvbGxiYWNrLnRleHRTdHJva2VXaWR0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGb250KG9wdCwgZWNNb2RlbCkge1xuICAvLyBlY01vZGVsIG9yIGRlZmF1bHQgdGV4dCBzdHlsZSBtb2RlbC5cbiAgdmFyIGdUZXh0U3R5bGVNb2RlbCA9IGVjTW9kZWwgfHwgZWNNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gIHJldHVybiBbLy8gRklYTUUgaW4gbm9kZS1jYW52YXMgZm9udFdlaWdodCBpcyBiZWZvcmUgZm9udFN0eWxlXG4gIG9wdC5mb250U3R5bGUgfHwgZ1RleHRTdHlsZU1vZGVsICYmIGdUZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250U3R5bGUnKSB8fCAnJywgb3B0LmZvbnRXZWlnaHQgfHwgZ1RleHRTdHlsZU1vZGVsICYmIGdUZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250V2VpZ2h0JykgfHwgJycsIChvcHQuZm9udFNpemUgfHwgZ1RleHRTdHlsZU1vZGVsICYmIGdUZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250U2l6ZScpIHx8IDEyKSArICdweCcsIG9wdC5mb250RmFtaWx5IHx8IGdUZXh0U3R5bGVNb2RlbCAmJiBnVGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udEZhbWlseScpIHx8ICdzYW5zLXNlcmlmJ10uam9pbignICcpO1xufVxuXG5mdW5jdGlvbiBhbmltYXRlT3JTZXRQcm9wcyhpc1VwZGF0ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgaWYgKHR5cGVvZiBkYXRhSW5kZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGRhdGFJbmRleDtcbiAgICBkYXRhSW5kZXggPSBudWxsO1xuICB9IC8vIERvIG5vdCBjaGVjayAnYW5pbWF0aW9uJyBwcm9wZXJ0eSBkaXJlY3RseSBoZXJlLiBDb25zaWRlciB0aGlzIGNhc2U6XG4gIC8vIGFuaW1hdGlvbiBtb2RlbCBpcyBhbiBgaXRlbU1vZGVsYCwgd2hvc2UgZG9lcyBub3QgaGF2ZSBgaXNBbmltYXRpb25FbmFibGVkYFxuICAvLyBidXQgaXRzIHBhcmVudCBtb2RlbCAoYHNlcmllc01vZGVsYCkgZG9lcy5cblxuXG4gIHZhciBhbmltYXRpb25FbmFibGVkID0gYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcblxuICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgIHZhciBwb3N0Zml4ID0gaXNVcGRhdGUgPyAnVXBkYXRlJyA6ICcnO1xuICAgIHZhciBkdXJhdGlvbiA9IGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25EdXJhdGlvbicgKyBwb3N0Zml4KTtcbiAgICB2YXIgYW5pbWF0aW9uRWFzaW5nID0gYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkVhc2luZycgKyBwb3N0Zml4KTtcbiAgICB2YXIgYW5pbWF0aW9uRGVsYXkgPSBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRGVsYXknICsgcG9zdGZpeCk7XG5cbiAgICBpZiAodHlwZW9mIGFuaW1hdGlvbkRlbGF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhbmltYXRpb25EZWxheSA9IGFuaW1hdGlvbkRlbGF5KGRhdGFJbmRleCwgYW5pbWF0YWJsZU1vZGVsLmdldEFuaW1hdGlvbkRlbGF5UGFyYW1zID8gYW5pbWF0YWJsZU1vZGVsLmdldEFuaW1hdGlvbkRlbGF5UGFyYW1zKGVsLCBkYXRhSW5kZXgpIDogbnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbihkYXRhSW5kZXgpO1xuICAgIH1cblxuICAgIGR1cmF0aW9uID4gMCA/IGVsLmFuaW1hdGVUbyhwcm9wcywgZHVyYXRpb24sIGFuaW1hdGlvbkRlbGF5IHx8IDAsIGFuaW1hdGlvbkVhc2luZywgY2IsICEhY2IpIDogKGVsLnN0b3BBbmltYXRpb24oKSwgZWwuYXR0cihwcm9wcyksIGNiICYmIGNiKCkpO1xuICB9IGVsc2Uge1xuICAgIGVsLnN0b3BBbmltYXRpb24oKTtcbiAgICBlbC5hdHRyKHByb3BzKTtcbiAgICBjYiAmJiBjYigpO1xuICB9XG59XG4vKipcbiAqIFVwZGF0ZSBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGVcbiAqIGNvbmZpZ3VyYXRpb24gaW4gc2VyaWVzLlxuICpcbiAqIENhdXRpb246IHRoaXMgbWV0aG9kIHdpbGwgc3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG4gKiBTbyBpZiBkbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIG9uZSBlbGVtZW50IHR3aWNlIGJlZm9yZVxuICogYW5pbWF0aW9uIHN0YXJ0cywgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFthbmltYXRhYmxlTW9kZWxdXG4gKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqIEBleGFtcGxlXG4gKiAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICogICAgICAgICBwb3NpdGlvbjogWzEwMCwgMTAwXVxuICogICAgIH0sIHNlcmllc01vZGVsLCBkYXRhSW5kZXgsIGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ0FuaW1hdGlvbiBkb25lIScpOyB9KTtcbiAqICAgICAvLyBPclxuICogICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHtcbiAqICAgICAgICAgcG9zaXRpb246IFsxMDAsIDEwMF1cbiAqICAgICB9LCBzZXJpZXNNb2RlbCwgZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnQW5pbWF0aW9uIGRvbmUhJyk7IH0pO1xuICovXG5cblxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgYW5pbWF0ZU9yU2V0UHJvcHModHJ1ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpO1xufVxuLyoqXG4gKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZVxuICogY29uZmlndXJhdGlvbiBpbiBzZXJpZXMuXG4gKlxuICogQ2F1dGlvbjogdGhpcyBtZXRob2Qgd2lsbCBzdG9wIHByZXZpb3VzIGFuaW1hdGlvbi5cbiAqIFNvIGlmIGRvIG5vdCB1c2UgdGhpcyBtZXRob2QgdG8gb25lIGVsZW1lbnQgdHdpY2UgYmVmb3JlXG4gKiBhbmltYXRpb24gc3RhcnRzLCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgZGF0YUluZGV4LCBjYikge1xuICBhbmltYXRlT3JTZXRQcm9wcyhmYWxzZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpO1xufVxuLyoqXG4gKiBHZXQgdHJhbnNmb3JtIG1hdHJpeCBvZiB0YXJnZXQgKHBhcmFtIHRhcmdldCksXG4gKiBpbiBjb29yZGluYXRlIG9mIGl0cyBhbmNlc3RvciAocGFyYW0gYW5jZXN0b3IpXG4gKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSB0YXJnZXRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gW2FuY2VzdG9yXVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKHRhcmdldCwgYW5jZXN0b3IpIHtcbiAgdmFyIG1hdCA9IG1hdHJpeC5pZGVudGl0eShbXSk7XG5cbiAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IGFuY2VzdG9yKSB7XG4gICAgbWF0cml4Lm11bChtYXQsIHRhcmdldC5nZXRMb2NhbFRyYW5zZm9ybSgpLCBtYXQpO1xuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gbWF0O1xufVxuLyoqXG4gKiBBcHBseSB0cmFuc2Zvcm0gdG8gYW4gdmVydGV4LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdGFyZ2V0IFt4LCB5XVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPnxUeXBlZEFycmF5LjxudW1iZXI+fE9iamVjdH0gdHJhbnNmb3JtIENhbiBiZTpcbiAqICAgICAgKyBUcmFuc2Zvcm0gbWF0cml4OiBsaWtlIFsxLCAwLCAwLCAxLCAwLCAwXVxuICogICAgICArIHtwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlfSwgdGhlIHNhbWUgYXMgYHpyZW5kZXIvVHJhbnNmb3JtYWJsZWAuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbeCwgeV1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKHRhcmdldCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcbiAgaWYgKHRyYW5zZm9ybSAmJiAhenJVdGlsLmlzQXJyYXlMaWtlKHRyYW5zZm9ybSkpIHtcbiAgICB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gIH1cblxuICBpZiAoaW52ZXJ0KSB7XG4gICAgdHJhbnNmb3JtID0gbWF0cml4LmludmVydChbXSwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHRhcmdldCwgdHJhbnNmb3JtKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVHJhbnNmb3JtZWQgZGlyZWN0aW9uLiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcbiAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxuICB2YXIgaEJhc2UgPSB0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMCA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzBdKTtcbiAgdmFyIHZCYXNlID0gdHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMl0gPT09IDAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVsyXSk7XG4gIHZhciB2ZXJ0ZXggPSBbZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXTtcbiAgdmVydGV4ID0gYXBwbHlUcmFuc2Zvcm0odmVydGV4LCB0cmFuc2Zvcm0sIGludmVydCk7XG4gIHJldHVybiBNYXRoLmFicyh2ZXJ0ZXhbMF0pID4gTWF0aC5hYnModmVydGV4WzFdKSA/IHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnIDogdmVydGV4WzFdID4gMCA/ICdib3R0b20nIDogJ3RvcCc7XG59XG4vKipcbiAqIEFwcGx5IGdyb3VwIHRyYW5zaXRpb24gYW5pbWF0aW9uIGZyb20gZzEgdG8gZzIuXG4gKiBJZiBubyBhbmltYXRhYmxlTW9kZWwsIG5vIGFuaW1hdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdyb3VwVHJhbnNpdGlvbihnMSwgZzIsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcbiAgaWYgKCFnMSB8fCAhZzIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbE1hcChnKSB7XG4gICAgdmFyIGVsTWFwID0ge307XG4gICAgZy50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGlmICghZWwuaXNHcm91cCAmJiBlbC5hbmlkKSB7XG4gICAgICAgIGVsTWFwW2VsLmFuaWRdID0gZWw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVsTWFwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZVByb3BzKGVsKSB7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHBvc2l0aW9uOiB2ZWN0b3IuY2xvbmUoZWwucG9zaXRpb24pLFxuICAgICAgcm90YXRpb246IGVsLnJvdGF0aW9uXG4gICAgfTtcblxuICAgIGlmIChlbC5zaGFwZSkge1xuICAgICAgb2JqLnNoYXBlID0genJVdGlsLmV4dGVuZCh7fSwgZWwuc2hhcGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgZWxNYXAxID0gZ2V0RWxNYXAoZzEpO1xuICBnMi50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoIWVsLmlzR3JvdXAgJiYgZWwuYW5pZCkge1xuICAgICAgdmFyIG9sZEVsID0gZWxNYXAxW2VsLmFuaWRdO1xuXG4gICAgICBpZiAob2xkRWwpIHtcbiAgICAgICAgdmFyIG5ld1Byb3AgPSBnZXRBbmltYXRhYmxlUHJvcHMoZWwpO1xuICAgICAgICBlbC5hdHRyKGdldEFuaW1hdGFibGVQcm9wcyhvbGRFbCkpO1xuICAgICAgICB1cGRhdGVQcm9wcyhlbCwgbmV3UHJvcCwgYW5pbWF0YWJsZU1vZGVsLCBlbC5kYXRhSW5kZXgpO1xuICAgICAgfSAvLyBlbHNlIHtcbiAgICAgIC8vICAgICBpZiAoZWwucHJldmlvdXNQcm9wcykge1xuICAgICAgLy8gICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gfVxuXG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHMgTGlrZTogW1syMywgNDRdLCBbNTMsIDY2XSwgLi4uXVxuICogQHBhcmFtIHtPYmplY3R9IHJlY3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBBIG5ldyBjbGlwcGVkIHBvaW50cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNsaXBQb2ludHNCeVJlY3QocG9pbnRzLCByZWN0KSB7XG4gIHJldHVybiB6clV0aWwubWFwKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIHggPSBwb2ludFswXTtcbiAgICB4ID0gbWF0aE1heCh4LCByZWN0LngpO1xuICAgIHggPSBtYXRoTWluKHgsIHJlY3QueCArIHJlY3Qud2lkdGgpO1xuICAgIHZhciB5ID0gcG9pbnRbMV07XG4gICAgeSA9IG1hdGhNYXgoeSwgcmVjdC55KTtcbiAgICB5ID0gbWF0aE1pbih5LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRSZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHBhcmFtIHtPYmplY3R9IHJlY3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IGNsaXBwZWQgcmVjdC4gSWYgcmVjdCBzaXplIGFyZSBuZWdhdGl2ZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNsaXBSZWN0QnlSZWN0KHRhcmdldFJlY3QsIHJlY3QpIHtcbiAgdmFyIHggPSBtYXRoTWF4KHRhcmdldFJlY3QueCwgcmVjdC54KTtcbiAgdmFyIHgyID0gbWF0aE1pbih0YXJnZXRSZWN0LnggKyB0YXJnZXRSZWN0LndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKTtcbiAgdmFyIHkgPSBtYXRoTWF4KHRhcmdldFJlY3QueSwgcmVjdC55KTtcbiAgdmFyIHkyID0gbWF0aE1pbih0YXJnZXRSZWN0LnkgKyB0YXJnZXRSZWN0LmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXG4gIGlmICh4MiA+PSB4ICYmIHkyID49IHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogeDIgLSB4LFxuICAgICAgaGVpZ2h0OiB5MiAtIHlcbiAgICB9O1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpY29uU3RyIFN1cHBvcnQgJ2ltYWdlOi8vJyBvciAncGF0aDovLycgb3IgZGlyZWN0IHN2ZyBwYXRoLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRdIFByb3BlcnRpZXMgb2YgYG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRgLCBleGNlcHQgYHN0eWxlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVjdF0ge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBJY29uIHBhdGggb3IgaW1hZ2UgZWxlbWVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUljb24oaWNvblN0ciwgb3B0LCByZWN0KSB7XG4gIG9wdCA9IHpyVXRpbC5leHRlbmQoe1xuICAgIHJlY3RIb3ZlcjogdHJ1ZVxuICB9LCBvcHQpO1xuICB2YXIgc3R5bGUgPSBvcHQuc3R5bGUgPSB7XG4gICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICB9O1xuICByZWN0ID0gcmVjdCB8fCB7XG4gICAgeDogLTEsXG4gICAgeTogLTEsXG4gICAgd2lkdGg6IDIsXG4gICAgaGVpZ2h0OiAyXG4gIH07XG5cbiAgaWYgKGljb25TdHIpIHtcbiAgICByZXR1cm4gaWNvblN0ci5pbmRleE9mKCdpbWFnZTovLycpID09PSAwID8gKHN0eWxlLmltYWdlID0gaWNvblN0ci5zbGljZSg4KSwgenJVdGlsLmRlZmF1bHRzKHN0eWxlLCByZWN0KSwgbmV3IEltYWdlKG9wdCkpIDogbWFrZVBhdGgoaWNvblN0ci5yZXBsYWNlKCdwYXRoOi8vJywgJycpLCBvcHQsIHJlY3QsICdjZW50ZXInKTtcbiAgfVxufVxuXG5leHBvcnRzLmV4dGVuZFNoYXBlID0gZXh0ZW5kU2hhcGU7XG5leHBvcnRzLmV4dGVuZFBhdGggPSBleHRlbmRQYXRoO1xuZXhwb3J0cy5tYWtlUGF0aCA9IG1ha2VQYXRoO1xuZXhwb3J0cy5tYWtlSW1hZ2UgPSBtYWtlSW1hZ2U7XG5leHBvcnRzLm1lcmdlUGF0aCA9IG1lcmdlUGF0aDtcbmV4cG9ydHMucmVzaXplUGF0aCA9IHJlc2l6ZVBhdGg7XG5leHBvcnRzLnN1YlBpeGVsT3B0aW1pemVMaW5lID0gc3ViUGl4ZWxPcHRpbWl6ZUxpbmU7XG5leHBvcnRzLnN1YlBpeGVsT3B0aW1pemVSZWN0ID0gc3ViUGl4ZWxPcHRpbWl6ZVJlY3Q7XG5leHBvcnRzLnN1YlBpeGVsT3B0aW1pemUgPSBzdWJQaXhlbE9wdGltaXplO1xuZXhwb3J0cy5zZXRIb3ZlclN0eWxlID0gc2V0SG92ZXJTdHlsZTtcbmV4cG9ydHMuc2V0TGFiZWxTdHlsZSA9IHNldExhYmVsU3R5bGU7XG5leHBvcnRzLnNldFRleHRTdHlsZSA9IHNldFRleHRTdHlsZTtcbmV4cG9ydHMuc2V0VGV4dCA9IHNldFRleHQ7XG5leHBvcnRzLmdldEZvbnQgPSBnZXRGb250O1xuZXhwb3J0cy51cGRhdGVQcm9wcyA9IHVwZGF0ZVByb3BzO1xuZXhwb3J0cy5pbml0UHJvcHMgPSBpbml0UHJvcHM7XG5leHBvcnRzLmdldFRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybTtcbmV4cG9ydHMuYXBwbHlUcmFuc2Zvcm0gPSBhcHBseVRyYW5zZm9ybTtcbmV4cG9ydHMudHJhbnNmb3JtRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uO1xuZXhwb3J0cy5ncm91cFRyYW5zaXRpb24gPSBncm91cFRyYW5zaXRpb247XG5leHBvcnRzLmNsaXBQb2ludHNCeVJlY3QgPSBjbGlwUG9pbnRzQnlSZWN0O1xuZXhwb3J0cy5jbGlwUmVjdEJ5UmVjdCA9IGNsaXBSZWN0QnlSZWN0O1xuZXhwb3J0cy5jcmVhdGVJY29uID0gY3JlYXRlSWNvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2dyYXBoaWMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvZ3JhcGhpYy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuL251bWJlclwiKTtcblxudmFyIHBhcnNlUGVyY2VudCA9IF9udW1iZXIucGFyc2VQZXJjZW50O1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcblxuLy8gTGF5b3V0IGhlbHBlcnMgZm9yIGVhY2ggY29tcG9uZW50IHBvc2l0aW9uaW5nXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cblxudmFyIExPQ0FUSU9OX1BBUkFNUyA9IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ3dpZHRoJywgJ2hlaWdodCddO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cblxudmFyIEhWX05BTUVTID0gW1snd2lkdGgnLCAnbGVmdCcsICdyaWdodCddLCBbJ2hlaWdodCcsICd0b3AnLCAnYm90dG9tJ11dO1xuXG5mdW5jdGlvbiBib3hMYXlvdXQob3JpZW50LCBncm91cCwgZ2FwLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuXG4gIGlmIChtYXhXaWR0aCA9PSBudWxsKSB7XG4gICAgbWF4V2lkdGggPSBJbmZpbml0eTtcbiAgfVxuXG4gIGlmIChtYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgIG1heEhlaWdodCA9IEluZmluaXR5O1xuICB9XG5cbiAgdmFyIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IDA7XG4gIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGNoaWxkLnBvc2l0aW9uO1xuICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIG5leHRDaGlsZCA9IGdyb3VwLmNoaWxkQXQoaWR4ICsgMSk7XG4gICAgdmFyIG5leHRDaGlsZFJlY3QgPSBuZXh0Q2hpbGQgJiYgbmV4dENoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBuZXh0WDtcbiAgICB2YXIgbmV4dFk7XG5cbiAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHZhciBtb3ZlWCA9IHJlY3Qud2lkdGggKyAobmV4dENoaWxkUmVjdCA/IC1uZXh0Q2hpbGRSZWN0LnggKyByZWN0LnggOiAwKTtcbiAgICAgIG5leHRYID0geCArIG1vdmVYOyAvLyBXcmFwIHdoZW4gd2lkdGggZXhjZWVkcyBtYXhXaWR0aCBvciBtZWV0IGEgYG5ld2xpbmVgIGdyb3VwXG4gICAgICAvLyBGSVhNRSBjb21wYXJlIGJlZm9yZSBhZGRpbmcgZ2FwP1xuXG4gICAgICBpZiAobmV4dFggPiBtYXhXaWR0aCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgICBuZXh0WCA9IG1vdmVYO1xuICAgICAgICB5ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGSVhNRTogY29uc2lkZXIgcmVjdC55IGlzIG5vdCBgMGA/XG4gICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRMaW5lTWF4U2l6ZSwgcmVjdC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW92ZVkgPSByZWN0LmhlaWdodCArIChuZXh0Q2hpbGRSZWN0ID8gLW5leHRDaGlsZFJlY3QueSArIHJlY3QueSA6IDApO1xuICAgICAgbmV4dFkgPSB5ICsgbW92ZVk7IC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heEhlaWdodCBvciBtZWV0IGEgYG5ld2xpbmVgIGdyb3VwXG5cbiAgICAgIGlmIChuZXh0WSA+IG1heEhlaWdodCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgIHggKz0gY3VycmVudExpbmVNYXhTaXplICsgZ2FwO1xuICAgICAgICB5ID0gMDtcbiAgICAgICAgbmV4dFkgPSBtb3ZlWTtcbiAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRMaW5lTWF4U2l6ZSwgcmVjdC53aWR0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLm5ld2xpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb3NpdGlvblswXSA9IHg7XG4gICAgcG9zaXRpb25bMV0gPSB5O1xuICAgIG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8geCA9IG5leHRYICsgZ2FwIDogeSA9IG5leHRZICsgZ2FwO1xuICB9KTtcbn1cbi8qKlxuICogVkJveCBvciBIQm94IGxheW91dGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPUluZmluaXR5XVxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9SW5maW5pdHldXG4gKi9cblxuXG52YXIgYm94ID0gYm94TGF5b3V0O1xuLyoqXG4gKiBWQm94IGxheW91dGluZ1xuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPUluZmluaXR5XVxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9SW5maW5pdHldXG4gKi9cblxudmFyIHZib3ggPSB6clV0aWwuY3VycnkoYm94TGF5b3V0LCAndmVydGljYWwnKTtcbi8qKlxuICogSEJveCBsYXlvdXRpbmdcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICogQHBhcmFtIHtudW1iZXJ9IGdhcFxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PUluZmluaXR5XVxuICovXG5cbnZhciBoYm94ID0genJVdGlsLmN1cnJ5KGJveExheW91dCwgJ2hvcml6b250YWwnKTtcbi8qKlxuICogSWYgeCBvciB4MiBpcyBub3Qgc3BlY2lmaWVkIG9yICdjZW50ZXInICdsZWZ0JyAncmlnaHQnLFxuICogdGhlIHdpZHRoIHdvdWxkIGJlIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gKiBJZiB5IG9yIHkyIGlzIG5vdCBzcGVjaWZpZWQgb3IgJ21pZGRsZScgJ3RvcCcgJ2JvdHRvbScsXG4gKiB0aGUgaGVpZ2h0IHdvdWxkIGJlIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uSW5mb1xuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnhdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueV1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby54Ml1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby55Ml1cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJSZWN0IHt3aWR0aCwgaGVpZ2h0fVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBtYXJnaW5cbiAqIEByZXR1cm4ge09iamVjdH0ge3dpZHRoLCBoZWlnaHR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0QXZhaWxhYmxlU2l6ZShwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbikge1xuICB2YXIgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWN0LndpZHRoO1xuICB2YXIgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyUmVjdC5oZWlnaHQ7XG4gIHZhciB4ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby54LCBjb250YWluZXJXaWR0aCk7XG4gIHZhciB5ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby55LCBjb250YWluZXJIZWlnaHQpO1xuICB2YXIgeDIgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLngyLCBjb250YWluZXJXaWR0aCk7XG4gIHZhciB5MiA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueTIsIGNvbnRhaW5lckhlaWdodCk7XG4gIChpc05hTih4KSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby54KSkpICYmICh4ID0gMCk7XG4gIChpc05hTih4MikgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueDIpKSkgJiYgKHgyID0gY29udGFpbmVyV2lkdGgpO1xuICAoaXNOYU4oeSkgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueSkpKSAmJiAoeSA9IDApO1xuICAoaXNOYU4oeTIpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLnkyKSkpICYmICh5MiA9IGNvbnRhaW5lckhlaWdodCk7XG4gIG1hcmdpbiA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkobWFyZ2luIHx8IDApO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBNYXRoLm1heCh4MiAtIHggLSBtYXJnaW5bMV0gLSBtYXJnaW5bM10sIDApLFxuICAgIGhlaWdodDogTWF0aC5tYXgoeTIgLSB5IC0gbWFyZ2luWzBdIC0gbWFyZ2luWzJdLCAwKVxuICB9O1xufVxuLyoqXG4gKiBQYXJzZSBwb3NpdGlvbiBpbmZvLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbkluZm9cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5sZWZ0XVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnRvcF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5yaWdodF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5ib3R0b21dXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ud2lkdGhdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uaGVpZ2h0XVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmFzcGVjdF0gQXNwZWN0IGlzIHdpZHRoIC8gaGVpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyUmVjdFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbbWFyZ2luXVxuICpcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbikge1xuICBtYXJnaW4gPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KG1hcmdpbiB8fCAwKTtcbiAgdmFyIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyUmVjdC53aWR0aDtcbiAgdmFyIGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lclJlY3QuaGVpZ2h0O1xuICB2YXIgbGVmdCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ubGVmdCwgY29udGFpbmVyV2lkdGgpO1xuICB2YXIgdG9wID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby50b3AsIGNvbnRhaW5lckhlaWdodCk7XG4gIHZhciByaWdodCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ucmlnaHQsIGNvbnRhaW5lcldpZHRoKTtcbiAgdmFyIGJvdHRvbSA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8uYm90dG9tLCBjb250YWluZXJIZWlnaHQpO1xuICB2YXIgd2lkdGggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLndpZHRoLCBjb250YWluZXJXaWR0aCk7XG4gIHZhciBoZWlnaHQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmhlaWdodCwgY29udGFpbmVySGVpZ2h0KTtcbiAgdmFyIHZlcnRpY2FsTWFyZ2luID0gbWFyZ2luWzJdICsgbWFyZ2luWzBdO1xuICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IG1hcmdpblsxXSArIG1hcmdpblszXTtcbiAgdmFyIGFzcGVjdCA9IHBvc2l0aW9uSW5mby5hc3BlY3Q7IC8vIElmIHdpZHRoIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSB3aWR0aCBmcm9tIGxlZnQgYW5kIHJpZ2h0XG5cbiAgaWYgKGlzTmFOKHdpZHRoKSkge1xuICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGggLSByaWdodCAtIGhvcml6b250YWxNYXJnaW4gLSBsZWZ0O1xuICB9XG5cbiAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSB2ZXJ0aWNhbE1hcmdpbiAtIHRvcDtcbiAgfVxuXG4gIGlmIChhc3BlY3QgIT0gbnVsbCkge1xuICAgIC8vIElmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIG5vdCBnaXZlblxuICAgIC8vIDEuIEdyYXBoIHNob3VsZCBub3QgZXhjZWVkcyB0aGUgY29udGFpbmVyXG4gICAgLy8gMi4gQXNwZWN0IG11c3QgYmUga2VlcGVkXG4gICAgLy8gMy4gR3JhcGggc2hvdWxkIHRha2UgdGhlIHNwYWNlIGFzIG1vcmUgYXMgcG9zc2libGVcbiAgICAvLyBGSVhNRVxuICAgIC8vIE1hcmdpbiBpcyBub3QgY29uc2lkZXJlZCwgYmVjYXVzZSB0aGVyZSBpcyBubyBjYXNlIHRoYXQgYm90aFxuICAgIC8vIHVzaW5nIG1hcmdpbiBhbmQgYXNwZWN0IHNvIGZhci5cbiAgICBpZiAoaXNOYU4od2lkdGgpICYmIGlzTmFOKGhlaWdodCkpIHtcbiAgICAgIGlmIChhc3BlY3QgPiBjb250YWluZXJXaWR0aCAvIGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoICogMC44O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0ICogMC44O1xuICAgICAgfVxuICAgIH0gLy8gQ2FsY3VsYXRlIHdpZHRoIG9yIGhlaWdodCB3aXRoIGdpdmVuIGFzcGVjdFxuXG5cbiAgICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdCAqIGhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfVxuICB9IC8vIElmIGxlZnQgaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIGxlZnQgZnJvbSByaWdodCBhbmQgd2lkdGhcblxuXG4gIGlmIChpc05hTihsZWZ0KSkge1xuICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gd2lkdGggLSBob3Jpem9udGFsTWFyZ2luO1xuICB9XG5cbiAgaWYgKGlzTmFOKHRvcCkpIHtcbiAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSBoZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbjtcbiAgfSAvLyBBbGlnbiBsZWZ0IGFuZCB0b3BcblxuXG4gIHN3aXRjaCAocG9zaXRpb25JbmZvLmxlZnQgfHwgcG9zaXRpb25JbmZvLnJpZ2h0KSB7XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAvIDIgLSB3aWR0aCAvIDIgLSBtYXJnaW5bM107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbjtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3dpdGNoIChwb3NpdGlvbkluZm8udG9wIHx8IHBvc2l0aW9uSW5mby5ib3R0b20pIHtcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMiAtIG1hcmdpblswXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAtIGhlaWdodCAtIHZlcnRpY2FsTWFyZ2luO1xuICAgICAgYnJlYWs7XG4gIH0gLy8gSWYgc29tZXRoaW5nIGlzIHdyb25nIGFuZCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgYXJlIGNhbGN1bGF0ZWQgYXMgTmFOXG5cblxuICBsZWZ0ID0gbGVmdCB8fCAwO1xuICB0b3AgPSB0b3AgfHwgMDtcblxuICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgLy8gV2lkdGggbWF5IGJlIE5hTiBpZiBvbmx5IG9uZSB2YWx1ZSBpcyBnaXZlbiBleGNlcHQgd2lkdGhcbiAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbiAtIGxlZnQgLSAocmlnaHQgfHwgMCk7XG4gIH1cblxuICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgIC8vIEhlaWdodCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCBoZWlnaHRcbiAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbiAtIHRvcCAtIChib3R0b20gfHwgMCk7XG4gIH1cblxuICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QobGVmdCArIG1hcmdpblszXSwgdG9wICsgbWFyZ2luWzBdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgcmVjdC5tYXJnaW4gPSBtYXJnaW47XG4gIHJldHVybiByZWN0O1xufVxuLyoqXG4gKiBQb3NpdGlvbiBhIHpyIGVsZW1lbnQgaW4gdmlld3BvcnRcbiAqICBHcm91cCBwb3NpdGlvbiBpcyBzcGVjaWZpZWQgYnkgZWl0aGVyXG4gKiAge2xlZnQsIHRvcH0sIHtyaWdodCwgYm90dG9tfVxuICogIElmIGFsbCBwcm9wZXJ0aWVzIGV4aXN0cywgcmlnaHQgYW5kIGJvdHRvbSB3aWxsIGJlIGlnb25yZWQuXG4gKlxuICogTG9naWM6XG4gKiAgICAgMS4gU2NhbGUgKGFnYWluc3Qgb3JpZ2luIHBvaW50IGluIHBhcmVudCBjb29yZClcbiAqICAgICAyLiBSb3RhdGUgKGFnYWluc3Qgb3JpZ2luIHBvaW50IGluIHBhcmVudCBjb29yZClcbiAqICAgICAzLiBUcmFzbGF0ZSAod2l0aCBlbC5wb3NpdGlvbiBieSB0aGlzIG1ldGhvZClcbiAqIFNvIHRoaXMgbWV0aG9kIG9ubHkgZml4ZXMgdGhlIGxhc3Qgc3RlcCAnVHJhc2xhdGUnLCB3aGljaCBkb2VzIG5vdCBhZmZlY3RcbiAqIHNjYWxpbmcgYW5kIHJvdGF0aW5nLlxuICpcbiAqIElmIGJlIGNhbGxlZCByZXBlYXRseSB3aXRoIHRoZSBzYW1lIGlucHV0IGVsLCB0aGUgc2FtZSByZXN1bHQgd2lsbCBiZSBnb3R0ZW4uXG4gKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbCBTaG91bGQgaGF2ZSBgZ2V0Qm91bmRpbmdSZWN0YCBtZXRob2QuXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25JbmZvXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ubGVmdF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby50b3BdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ucmlnaHRdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uYm90dG9tXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLndpZHRoXSBPbmx5IGZvciBvcHQuYm91bmRpbmdNb2RlbDogJ3JhdydcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5oZWlnaHRdIE9ubHkgZm9yIG9wdC5ib3VuZGluZ01vZGVsOiAncmF3J1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclJlY3RcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbWFyZ2luXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHQuaHY9WzEsMV1dIE9ubHkgaG9yaXpvbnRhbCBvciBvbmx5IHZlcnRpY2FsLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW29wdC5ib3VuZGluZ01vZGU9J2FsbCddXG4gKiAgICAgICAgU3BlY2lmeSBob3cgdG8gY2FsY3VsYXRlIGJvdW5kaW5nUmVjdCB3aGVuIGxvY2F0aW5nLlxuICogICAgICAgICdhbGwnOiBQb3NpdGlvbiB0aGUgYm91bmRpbmdSZWN0IHRoYXQgaXMgdHJhbnNmb3JtZWQgYW5kIHVpb25lZFxuICogICAgICAgICAgICAgICBib3RoIGl0c2VsZiBhbmQgaXRzIGRlc2NlbmRhbnRzLlxuICogICAgICAgICAgICAgICBUaGlzIG1vZGUgc2ltcGxpZXMgY29uZmluZSB0aGUgZWxlbWVudHMgaW4gdGhlIGJvdW5kaW5nXG4gKiAgICAgICAgICAgICAgIG9mIHRoZWlyIGNvbnRhaW5lciAoZS5nLiwgdXNpbmcgJ3JpZ2h0OiAwJykuXG4gKiAgICAgICAgJ3Jhdyc6IFBvc2l0aW9uIHRoZSBib3VuZGluZ1JlY3QgdGhhdCBpcyBub3QgdHJhbnNmb3JtZWQgYW5kIG9ubHkgaXRzZWxmLlxuICogICAgICAgICAgICAgICBUaGlzIG1vZGUgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgYSBlbGVtZW50IGNhbiBvdmVyZmxvdyBpdHNcbiAqICAgICAgICAgICAgICAgY29udGFpbmVyLiAoQ29uc2lkZXIgYSByb3RhdGVkIGNpcmNsZSBuZWVkcyB0byBiZSBsb2NhdGVkIGluIGEgY29ybmVyLilcbiAqICAgICAgICAgICAgICAgSW4gdGhpcyBtb2RlIHBvc2l0aW9uSW5mby53aWR0aC9oZWlnaHQgY2FuIG9ubHkgYmUgbnVtYmVyLlxuICovXG5cblxuZnVuY3Rpb24gcG9zaXRpb25FbGVtZW50KGVsLCBwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbiwgb3B0KSB7XG4gIHZhciBoID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlswXTtcbiAgdmFyIHYgPSAhb3B0IHx8ICFvcHQuaHYgfHwgb3B0Lmh2WzFdO1xuICB2YXIgYm91bmRpbmdNb2RlID0gb3B0ICYmIG9wdC5ib3VuZGluZ01vZGUgfHwgJ2FsbCc7XG5cbiAgaWYgKCFoICYmICF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlY3Q7XG5cbiAgaWYgKGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycpIHtcbiAgICByZWN0ID0gZWwudHlwZSA9PT0gJ2dyb3VwJyA/IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgK3Bvc2l0aW9uSW5mby53aWR0aCB8fCAwLCArcG9zaXRpb25JbmZvLmhlaWdodCB8fCAwKSA6IGVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICB9IGVsc2Uge1xuICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcblxuICAgIGlmIChlbC5uZWVkTG9jYWxUcmFuc2Zvcm0oKSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsLmdldExvY2FsVHJhbnNmb3JtKCk7IC8vIE5vdGljZTogcmF3IHJlY3QgbWF5IGJlIGlubmVyIG9iamVjdCBvZiBlbCxcbiAgICAgIC8vIHdoaWNoIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXG5cbiAgICAgIHJlY3QgPSByZWN0LmNsb25lKCk7XG4gICAgICByZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgfVxuICB9IC8vIFRoZSByZWFsIHdpZHRoIGFuZCBoZWlnaHQgY2FuIG5vdCBiZSBzcGVjaWZpZWQgYnV0IGNhbGN1bGF0ZWQgYnkgdGhlIGdpdmVuIGVsLlxuXG5cbiAgcG9zaXRpb25JbmZvID0gZ2V0TGF5b3V0UmVjdCh6clV0aWwuZGVmYXVsdHMoe1xuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfSwgcG9zaXRpb25JbmZvKSwgY29udGFpbmVyUmVjdCwgbWFyZ2luKTsgLy8gQmVjYXVzZSAndHJhbmxhdGUnIGlzIHRoZSBsYXN0IHN0ZXAgaW4gdHJhbnNmb3JtXG4gIC8vIChzZWUgenJlbmRlci9jb3JlL1RyYW5zZm9ybWFibGUjZ2V0TG9jYWxUcmFuc2Zyb20pLFxuICAvLyB3ZSBjYW4ganVzdCBvbmx5IG1vZGlmeSBlbC5wb3NpdGlvbiB0byBnZXQgZmluYWwgcmVzdWx0LlxuXG4gIHZhciBlbFBvcyA9IGVsLnBvc2l0aW9uO1xuICB2YXIgZHggPSBoID8gcG9zaXRpb25JbmZvLnggLSByZWN0LnggOiAwO1xuICB2YXIgZHkgPSB2ID8gcG9zaXRpb25JbmZvLnkgLSByZWN0LnkgOiAwO1xuICBlbC5hdHRyKCdwb3NpdGlvbicsIGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycgPyBbZHgsIGR5XSA6IFtlbFBvc1swXSArIGR4LCBlbFBvc1sxXSArIGR5XSk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24gQ29udGFpbnMgc29tZSBvZiB0aGUgcHJvcGVydGllcyBpbiBIVl9OQU1FUy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBodklkeCAwOiBob3Jpem9udGFsOyAxOiB2ZXJ0aWNhbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNpemVDYWxjdWxhYmxlKG9wdGlvbiwgaHZJZHgpIHtcbiAgcmV0dXJuIG9wdGlvbltIVl9OQU1FU1todklkeF1bMF1dICE9IG51bGwgfHwgb3B0aW9uW0hWX05BTUVTW2h2SWR4XVsxXV0gIT0gbnVsbCAmJiBvcHRpb25bSFZfTkFNRVNbaHZJZHhdWzJdXSAhPSBudWxsO1xufVxuLyoqXG4gKiBDb25zaWRlciBDYXNlOlxuICogV2hlbiBkZWZ1bGF0IG9wdGlvbiBoYXMge2xlZnQ6IDAsIHdpZHRoOiAxMDB9LCBhbmQgd2Ugc2V0IHtyaWdodDogMH1cbiAqIHRocm91Z2ggc2V0T3B0aW9uIG9yIG1lZGlhIHF1ZXJ5LCB1c2luZyBub3JtYWwgenJVdGlsLm1lcmdlIHdpbGwgY2F1c2VcbiAqIHtyaWdodDogMH0gZG9lcyBub3QgdGFrZSBlZmZlY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG4gKiAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICogICAgICAgICAuLi5cbiAqICAgICAgICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbik7XG4gKiAgICAgICAgIHRoaXMubWVyZ2VPcHRpb24oaW5wdXRQb3NpdGlvblBhcmFtcyk7XG4gKiAgICAgfSxcbiAqICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICogICAgICAgICBuZXdPcHRpb24gJiYgenJVdGlsLm1lcmdlKHRoaXNPcHRpb24sIG5ld09wdGlvbiwgdHJ1ZSk7XG4gKiAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKHRoaXNPcHRpb24sIG5ld09wdGlvbik7XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldE9wdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG5ld09wdGlvblxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0XVxuICogQHBhcmFtIHtib29sZWFufEFycmF5Ljxib29sZWFuPn0gW29wdC5pZ25vcmVTaXplPWZhbHNlXSBVc2VkIGZvciB0aGUgY29tcG9uZW50c1xuICogIHRoYXQgd2lkdGggKG9yIGhlaWdodCkgc2hvdWxkIG5vdCBiZSBjYWxjdWxhdGVkIGJ5IGxlZnQgYW5kIHJpZ2h0IChvciB0b3AgYW5kIGJvdHRvbSkuXG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZUxheW91dFBhcmFtKHRhcmdldE9wdGlvbiwgbmV3T3B0aW9uLCBvcHQpIHtcbiAgIXpyVXRpbC5pc09iamVjdChvcHQpICYmIChvcHQgPSB7fSk7XG4gIHZhciBpZ25vcmVTaXplID0gb3B0Lmlnbm9yZVNpemU7XG4gICF6clV0aWwuaXNBcnJheShpZ25vcmVTaXplKSAmJiAoaWdub3JlU2l6ZSA9IFtpZ25vcmVTaXplLCBpZ25vcmVTaXplXSk7XG4gIHZhciBoUmVzdWx0ID0gbWVyZ2UoSFZfTkFNRVNbMF0sIDApO1xuICB2YXIgdlJlc3VsdCA9IG1lcmdlKEhWX05BTUVTWzFdLCAxKTtcbiAgY29weShIVl9OQU1FU1swXSwgdGFyZ2V0T3B0aW9uLCBoUmVzdWx0KTtcbiAgY29weShIVl9OQU1FU1sxXSwgdGFyZ2V0T3B0aW9uLCB2UmVzdWx0KTtcblxuICBmdW5jdGlvbiBtZXJnZShuYW1lcywgaHZJZHgpIHtcbiAgICB2YXIgbmV3UGFyYW1zID0ge307XG4gICAgdmFyIG5ld1ZhbHVlQ291bnQgPSAwO1xuICAgIHZhciBtZXJnZWQgPSB7fTtcbiAgICB2YXIgbWVyZ2VkVmFsdWVDb3VudCA9IDA7XG4gICAgdmFyIGVub3VnaFBhcmFtTnVtYmVyID0gMjtcbiAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbWVyZ2VkW25hbWVdID0gdGFyZ2V0T3B0aW9uW25hbWVdO1xuICAgIH0pO1xuICAgIGVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAvLyBDb25zaWRlciBjYXNlOiBuZXdPcHRpb24ud2lkdGggaXMgbnVsbCwgd2hpY2ggaXNcbiAgICAgIC8vIHNldCBieSB1c2VyIGZvciByZW1vdmluZyB3aWR0aCBzZXR0aW5nLlxuICAgICAgaGFzUHJvcChuZXdPcHRpb24sIG5hbWUpICYmIChuZXdQYXJhbXNbbmFtZV0gPSBtZXJnZWRbbmFtZV0gPSBuZXdPcHRpb25bbmFtZV0pO1xuICAgICAgaGFzVmFsdWUobmV3UGFyYW1zLCBuYW1lKSAmJiBuZXdWYWx1ZUNvdW50Kys7XG4gICAgICBoYXNWYWx1ZShtZXJnZWQsIG5hbWUpICYmIG1lcmdlZFZhbHVlQ291bnQrKztcbiAgICB9KTtcblxuICAgIGlmIChpZ25vcmVTaXplW2h2SWR4XSkge1xuICAgICAgLy8gT25seSBvbmUgb2YgbGVmdC9yaWdodCBpcyBwcmVtaXR0ZWQgdG8gZXhpc3QuXG4gICAgICBpZiAoaGFzVmFsdWUobmV3T3B0aW9uLCBuYW1lc1sxXSkpIHtcbiAgICAgICAgbWVyZ2VkW25hbWVzWzJdXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGhhc1ZhbHVlKG5ld09wdGlvbiwgbmFtZXNbMl0pKSB7XG4gICAgICAgIG1lcmdlZFtuYW1lc1sxXV0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH0gLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgLy8gb3IgdGFyZ2V0T3B0aW9uOiB7cmlnaHQ6IC4uLn0gYW5kIG5ld09wdGlvbjoge3dpZHRoOiAuLi59LFxuICAgIC8vIFRoZXJlIGlzIG5vIGNvbmZsaWN0IHdoZW4gbWVyZ2VkIG9ubHkgaGFzIHBhcmFtcyBjb3VudFxuICAgIC8vIGxpdHRsZSB0aGFuIGVub3VnaFBhcmFtTnVtYmVyLlxuXG5cbiAgICBpZiAobWVyZ2VkVmFsdWVDb3VudCA9PT0gZW5vdWdoUGFyYW1OdW1iZXIgfHwgIW5ld1ZhbHVlQ291bnQpIHtcbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSAvLyBDYXNlOiBuZXdPcHRpb246IHt3aWR0aDogLi4uLCByaWdodDogLi4ufSxcbiAgICAvLyBUaGFuIHdlIGNhbiBtYWtlIHN1cmUgdXNlciBvbmx5IHdhbnQgdGhvc2UgdHdvLCBhbmQgaWdub3JlXG4gICAgLy8gYWxsIG9yaWdpbiBwYXJhbXMgaW4gdGFyZ2V0T3B0aW9uLlxuICAgIGVsc2UgaWYgKG5ld1ZhbHVlQ291bnQgPj0gZW5vdWdoUGFyYW1OdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENob3NlIGFub3RoZXIgcGFyYW0gZnJvbSB0YXJnZXRPcHRpb24gYnkgcHJpb3JpdHkuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuXG4gICAgICAgICAgaWYgKCFoYXNQcm9wKG5ld1BhcmFtcywgbmFtZSkgJiYgaGFzUHJvcCh0YXJnZXRPcHRpb24sIG5hbWUpKSB7XG4gICAgICAgICAgICBuZXdQYXJhbXNbbmFtZV0gPSB0YXJnZXRPcHRpb25bbmFtZV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzUHJvcChvYmosIG5hbWUpIHtcbiAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzVmFsdWUob2JqLCBuYW1lKSB7XG4gICAgcmV0dXJuIG9ialtuYW1lXSAhPSBudWxsICYmIG9ialtuYW1lXSAhPT0gJ2F1dG8nO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weShuYW1lcywgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIFJldHJpZXZlICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0JyBmcm9tIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAqIEByZXR1cm4ge09iamVjdH0gUmVzdWx0IGNvbnRhaW5zIHRob3NlIHByb3BzLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGF5b3V0UGFyYW1zKHNvdXJjZSkge1xuICByZXR1cm4gY29weUxheW91dFBhcmFtcyh7fSwgc291cmNlKTtcbn1cbi8qKlxuICogUmV0cmlldmUgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnIGZyb20gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICogQHJldHVybiB7T2JqZWN0fSBSZXN1bHQgY29udGFpbnMgdGhvc2UgcHJvcHMuXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5TGF5b3V0UGFyYW1zKHRhcmdldCwgc291cmNlKSB7XG4gIHNvdXJjZSAmJiB0YXJnZXQgJiYgZWFjaChMT0NBVElPTl9QQVJBTVMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgc291cmNlLmhhc093blByb3BlcnR5KG5hbWUpICYmICh0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0cy5MT0NBVElPTl9QQVJBTVMgPSBMT0NBVElPTl9QQVJBTVM7XG5leHBvcnRzLkhWX05BTUVTID0gSFZfTkFNRVM7XG5leHBvcnRzLmJveCA9IGJveDtcbmV4cG9ydHMudmJveCA9IHZib3g7XG5leHBvcnRzLmhib3ggPSBoYm94O1xuZXhwb3J0cy5nZXRBdmFpbGFibGVTaXplID0gZ2V0QXZhaWxhYmxlU2l6ZTtcbmV4cG9ydHMuZ2V0TGF5b3V0UmVjdCA9IGdldExheW91dFJlY3Q7XG5leHBvcnRzLnBvc2l0aW9uRWxlbWVudCA9IHBvc2l0aW9uRWxlbWVudDtcbmV4cG9ydHMuc2l6ZUNhbGN1bGFibGUgPSBzaXplQ2FsY3VsYWJsZTtcbmV4cG9ydHMubWVyZ2VMYXlvdXRQYXJhbSA9IG1lcmdlTGF5b3V0UGFyYW07XG5leHBvcnRzLmdldExheW91dFBhcmFtcyA9IGdldExheW91dFBhcmFtcztcbmV4cG9ydHMuY29weUxheW91dFBhcmFtcyA9IGNvcHlMYXlvdXRQYXJhbXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9sYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbGF5b3V0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBmb3JtYXRVdGlsID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuXG52YXIgbnVibWVyVXRpbCA9IHJlcXVpcmUoXCIuL251bWJlclwiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4uL21vZGVsL01vZGVsXCIpO1xuXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xuLyoqXG4gKiBJZiB2YWx1ZSBpcyBub3QgYXJyYXksIHRoZW4gdHJhbnNsYXRlIGl0IHRvIGFycmF5LlxuICogQHBhcmFtICB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fSBbdmFsdWVdIG9yIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/IHZhbHVlIDogdmFsdWUgPT0gbnVsbCA/IFtdIDogW3ZhbHVlXTtcbn1cbi8qKlxuICogU3luYyBkZWZhdWx0IG9wdGlvbiBiZXR3ZWVuIG5vcm1hbCBhbmQgZW1waGFzaXMgbGlrZSBgcG9zaXRpb25gIGFuZCBgc2hvd2BcbiAqIEluIGNhc2Ugc29tZSBvbmUgd2lsbCB3cml0ZSBjb2RlIGxpa2VcbiAqICAgICBsYWJlbDoge1xuICogICAgICAgICBub3JtYWw6IHtcbiAqICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICogICAgICAgICAgICAgcG9zaXRpb246ICdvdXRzaWRlJyxcbiAqICAgICAgICAgICAgIGZvbnRTaXplOiAxOFxuICogICAgICAgICB9LFxuICogICAgICAgICBlbXBoYXNpczoge1xuICogICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICogICAgICAgICB9XG4gKiAgICAgfVxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc3ViT3B0c1xuICovXG5cblxuZnVuY3Rpb24gZGVmYXVsdEVtcGhhc2lzKG9wdCwgc3ViT3B0cykge1xuICBpZiAob3B0KSB7XG4gICAgdmFyIGVtcGhhc2lzT3B0ID0gb3B0LmVtcGhhc2lzID0gb3B0LmVtcGhhc2lzIHx8IHt9O1xuICAgIHZhciBub3JtYWxPcHQgPSBvcHQubm9ybWFsID0gb3B0Lm5vcm1hbCB8fCB7fTsgLy8gRGVmYXVsdCBlbXBoYXNpcyBvcHRpb24gZnJvbSBub3JtYWxcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJPcHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3ViT3B0TmFtZSA9IHN1Yk9wdHNbaV07XG5cbiAgICAgIGlmICghZW1waGFzaXNPcHQuaGFzT3duUHJvcGVydHkoc3ViT3B0TmFtZSkgJiYgbm9ybWFsT3B0Lmhhc093blByb3BlcnR5KHN1Yk9wdE5hbWUpKSB7XG4gICAgICAgIGVtcGhhc2lzT3B0W3N1Yk9wdE5hbWVdID0gbm9ybWFsT3B0W3N1Yk9wdE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgVEVYVF9TVFlMRV9PUFRJT05TID0gWydmb250U3R5bGUnLCAnZm9udFdlaWdodCcsICdmb250U2l6ZScsICdmb250RmFtaWx5JywgJ3JpY2gnLCAndGFnJywgJ2NvbG9yJywgJ3RleHRCb3JkZXJDb2xvcicsICd0ZXh0Qm9yZGVyV2lkdGgnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2xpbmVIZWlnaHQnLCAnYWxpZ24nLCAndmVydGljYWxBbGlnbicsICdiYXNlbGluZScsICdzaGFkb3dDb2xvcicsICdzaGFkb3dCbHVyJywgJ3NoYWRvd09mZnNldFgnLCAnc2hhZG93T2Zmc2V0WScsICd0ZXh0U2hhZG93Q29sb3InLCAndGV4dFNoYWRvd0JsdXInLCAndGV4dFNoYWRvd09mZnNldFgnLCAndGV4dFNoYWRvd09mZnNldFknLCAnYmFja2dyb3VuZENvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JvcmRlcldpZHRoJywgJ2JvcmRlclJhZGl1cycsICdwYWRkaW5nJ107IC8vIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TID0gbW9kZWxVdGlsLlRFWFRfU1RZTEVfT1BUSU9OUy5jb25jYXQoW1xuLy8gICAgICdwb3NpdGlvbicsICdvZmZzZXQnLCAncm90YXRlJywgJ29yaWdpbicsICdzaG93JywgJ2Rpc3RhbmNlJywgJ2Zvcm1hdHRlcicsXG4vLyAgICAgJ2ZvbnRTdHlsZScsICdmb250V2VpZ2h0JywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknLFxuLy8gICAgIC8vIEZJWE1FOiBkZXByZWNhdGVkLCBjaGVjayBhbmQgcmVtb3ZlIGl0LlxuLy8gICAgICd0ZXh0U3R5bGUnXG4vLyBdKTtcblxuLyoqXG4gKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxuICogVGhpcyBoZWxwZXIgbWV0aG9kIHJldGlldmVzIHZhbHVlIGZyb20gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxEYXRlfEFycmF5fE9iamVjdH0gZGF0YUl0ZW1cbiAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd8RGF0ZXxBcnJheS48bnVtYmVyfHN0cmluZ3xEYXRlPn1cbiAqL1xuXG5mdW5jdGlvbiBnZXREYXRhSXRlbVZhbHVlKGRhdGFJdGVtKSB7XG4gIC8vIFBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgcmV0dXJuIGRhdGFJdGVtICYmIChkYXRhSXRlbS52YWx1ZSA9PSBudWxsID8gZGF0YUl0ZW0gOiBkYXRhSXRlbS52YWx1ZSk7XG59XG4vKipcbiAqIGRhdGEgY291bGQgYmUgWzEyLCAyMzIzLCB7dmFsdWU6IDIyM30sIFsxMjIxLCAyM10sIHt2YWx1ZTogWzIsIDIzXX1dXG4gKiBUaGlzIGhlbHBlciBtZXRob2QgZGV0ZXJtaW5lIGlmIGRhdGFJdGVtIGhhcyBleHRyYSBvcHRpb24gYmVzaWRlcyB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV8QXJyYXl8T2JqZWN0fSBkYXRhSXRlbVxuICovXG5cblxuZnVuY3Rpb24gaXNEYXRhSXRlbU9wdGlvbihkYXRhSXRlbSkge1xuICByZXR1cm4gaXNPYmplY3QoZGF0YUl0ZW0pICYmICEoZGF0YUl0ZW0gaW5zdGFuY2VvZiBBcnJheSk7IC8vIC8vIG1hcmtMaW5lIGRhdGEgY2FuIGJlIGFycmF5XG4gIC8vICYmICEoZGF0YUl0ZW1bMF0gJiYgaXNPYmplY3QoZGF0YUl0ZW1bMF0pICYmICEoZGF0YUl0ZW1bMF0gaW5zdGFuY2VvZiBBcnJheSkpO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciBtZXRob2QgY29udmVydCB2YWx1ZSBpbiBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtkaW1JbmZvXSBJZiBzdHJpbmcgKGxpa2UgJ3gnKSwgZGltVHlwZSBkZWZhdWx0cyAnbnVtYmVyJy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbnZlckRhdGFWYWx1ZSh2YWx1ZSwgZGltSW5mbykge1xuICAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIHZhciBkaW1UeXBlID0gZGltSW5mbyAmJiBkaW1JbmZvLnR5cGU7XG5cbiAgaWYgKGRpbVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChkaW1UeXBlID09PSAndGltZScgLy8gc3BlYWQgdXAgd2hlbiB1c2luZyB0aW1lc3RhbXBcbiAgJiYgdHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnLScpIHtcbiAgICB2YWx1ZSA9ICtudWJtZXJVdGlsLnBhcnNlRGF0ZSh2YWx1ZSk7XG4gIH0gLy8gZGltVHlwZSBkZWZhdWx0cyAnbnVtYmVyJy5cbiAgLy8gSWYgZGltVHlwZSBpcyBub3Qgb3JkaW5hbCBhbmQgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgTmFOIG9yICctJyxcbiAgLy8gcGFyc2UgdG8gTmFOLlxuXG5cbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnID8gTmFOIDogK3ZhbHVlOyAvLyBJZiBzdHJpbmcgKGxpa2UgJy0nKSwgdXNpbmcgJysnIHBhcnNlIHRvIE5hTlxufVxuLyoqXG4gKiBDcmVhdGUgYSBtb2RlbCBwcm94eSB0byBiZSB1c2VkIGluIHRvb2x0aXAgZm9yIGVkZ2UgZGF0YSwgbWFya0xpbmUgZGF0YSwgbWFya1BvaW50IGRhdGEuXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuc2VyaWVzSW5kZXhdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdC5uYW1lXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQubWFpblR5cGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdC5zdWJUeXBlXVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRGF0YUZvcm1hdE1vZGVsKGRhdGEsIG9wdCkge1xuICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoKTtcbiAgenJVdGlsLm1peGluKG1vZGVsLCBkYXRhRm9ybWF0TWl4aW4pO1xuICBtb2RlbC5zZXJpZXNJbmRleCA9IG9wdC5zZXJpZXNJbmRleDtcbiAgbW9kZWwubmFtZSA9IG9wdC5uYW1lIHx8ICcnO1xuICBtb2RlbC5tYWluVHlwZSA9IG9wdC5tYWluVHlwZTtcbiAgbW9kZWwuc3ViVHlwZSA9IG9wdC5zdWJUeXBlO1xuXG4gIG1vZGVsLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIG1vZGVsO1xufSAvLyBQRU5ESU5HIEEgbGl0dGxlIHVnbHlcblxuXG52YXIgZGF0YUZvcm1hdE1peGluID0ge1xuICAvKipcbiAgICogR2V0IHBhcmFtcyBmb3IgZm9ybWF0dGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0RGF0YVBhcmFtczogZnVuY3Rpb24gKGRhdGFJbmRleCwgZGF0YVR5cGUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgdmFyIHJhd1ZhbHVlID0gdGhpcy5nZXRSYXdWYWx1ZShkYXRhSW5kZXgsIGRhdGFUeXBlKTtcbiAgICB2YXIgcmF3RGF0YUluZGV4ID0gZGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpO1xuICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCwgdHJ1ZSk7XG4gICAgdmFyIGl0ZW1PcHQgPSBkYXRhLmdldFJhd0RhdGFJdGVtKGRhdGFJbmRleCk7XG4gICAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ2NvbG9yJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvbmVudFR5cGU6IHRoaXMubWFpblR5cGUsXG4gICAgICBjb21wb25lbnRTdWJUeXBlOiB0aGlzLnN1YlR5cGUsXG4gICAgICBzZXJpZXNUeXBlOiB0aGlzLm1haW5UeXBlID09PSAnc2VyaWVzJyA/IHRoaXMuc3ViVHlwZSA6IG51bGwsXG4gICAgICBzZXJpZXNJbmRleDogdGhpcy5zZXJpZXNJbmRleCxcbiAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgc2VyaWVzTmFtZTogdGhpcy5uYW1lLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRhdGFJbmRleDogcmF3RGF0YUluZGV4LFxuICAgICAgZGF0YTogaXRlbU9wdCxcbiAgICAgIGRhdGFUeXBlOiBkYXRhVHlwZSxcbiAgICAgIHZhbHVlOiByYXdWYWx1ZSxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIG1hcmtlcjogZm9ybWF0VXRpbC5nZXRUb29sdGlwTWFya2VyKGNvbG9yKSxcbiAgICAgIC8vIFBhcmFtIG5hbWUgbGlzdCBmb3IgbWFwcGluZyBgYWAsIGBiYCwgYGNgLCBgZGAsIGBlYFxuICAgICAgJHZhcnM6IFsnc2VyaWVzTmFtZScsICduYW1lJywgJ3ZhbHVlJ11cbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JtYXQgbGFiZWxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YXR1cz0nbm9ybWFsJ10gJ25vcm1hbCcgb3IgJ2VtcGhhc2lzJ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RpbUluZGV4XVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsUHJvcD0nbGFiZWwnXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRGb3JtYXR0ZWRMYWJlbDogZnVuY3Rpb24gKGRhdGFJbmRleCwgc3RhdHVzLCBkYXRhVHlwZSwgZGltSW5kZXgsIGxhYmVsUHJvcCkge1xuICAgIHN0YXR1cyA9IHN0YXR1cyB8fCAnbm9ybWFsJztcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgsIGRhdGFUeXBlKTtcblxuICAgIGlmIChkaW1JbmRleCAhPSBudWxsICYmIHBhcmFtcy52YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBwYXJhbXMudmFsdWUgPSBwYXJhbXMudmFsdWVbZGltSW5kZXhdO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0ZXIgPSBpdGVtTW9kZWwuZ2V0KFtsYWJlbFByb3AgfHwgJ2xhYmVsJywgc3RhdHVzLCAnZm9ybWF0dGVyJ10pO1xuXG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcmFtcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyKHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZvcm1hdFV0aWwuZm9ybWF0VHBsKGZvcm1hdHRlciwgcGFyYW1zKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCByYXcgdmFsdWUgaW4gb3B0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UmF3VmFsdWU6IGZ1bmN0aW9uIChpZHgsIGRhdGFUeXBlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgIHZhciBkYXRhSXRlbSA9IGRhdGEuZ2V0UmF3RGF0YUl0ZW0oaWR4KTtcblxuICAgIGlmIChkYXRhSXRlbSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QoZGF0YUl0ZW0pICYmICEoZGF0YUl0ZW0gaW5zdGFuY2VvZiBBcnJheSkgPyBkYXRhSXRlbS52YWx1ZSA6IGRhdGFJdGVtO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2hvdWxkIGJlIGltcGxlbWVudGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211bHRpcGxlU2VyaWVzPWZhbHNlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFUeXBlXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRvb2x0aXAgc3RyaW5nXG4gICAqL1xuICBmb3JtYXRUb29sdGlwOiB6clV0aWwubm9vcFxufTtcbi8qKlxuICogTWFwcGluZyB0byBleGlzdHMgZm9yIG1lcmdlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD58QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59IGV4aXN0c1xuICogQHBhcmFtIHtPYmplY3R8QXJyYXkuPE9iamVjdD59IG5ld0NwdE9wdGlvbnNcbiAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBSZXN1bHQsIGxpa2UgW3tleGlzdDogLi4uLCBvcHRpb246IC4uLn0sIHt9XSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCBvZiB3aGljaCBpcyB0aGUgc2FtZSBhcyBleGlzdHMuXG4gKi9cblxuZnVuY3Rpb24gbWFwcGluZ1RvRXhpc3RzKGV4aXN0cywgbmV3Q3B0T3B0aW9ucykge1xuICAvLyBNYXBwaW5nIGJ5IHRoZSBvcmRlciBieSBvcmlnaW5hbCBvcHRpb24gKGJ1dCBub3Qgb3JkZXIgb2ZcbiAgLy8gbmV3IG9wdGlvbikgaW4gbWVyZ2UgbW9kZS4gQmVjYXVzZSB3ZSBzaG91bGQgZW5zdXJlXG4gIC8vIHNvbWUgc3BlY2lmaWVkIGluZGV4IChsaWtlIHhBeGlzSW5kZXgpIGlzIGNvbnNpc3RlbnQgd2l0aFxuICAvLyBvcmlnaW5hbCBvcHRpb24sIHdoaWNoIGlzIGVhc3kgdG8gdW5kZXJzdGFuZCwgZXNwYXRpYWxseSBpblxuICAvLyBtZWRpYSBxdWVyeS4gQW5kIGluIG1vc3QgY2FzZSwgbWVyZ2Ugb3B0aW9uIGlzIHVzZWQgdG9cbiAgLy8gdXBkYXRlIHBhcnRpYWwgb3B0aW9uIGJ1dCBub3QgYmUgZXhwZWN0ZWQgdG8gY2hhbmdlIG9yZGVyLlxuICBuZXdDcHRPcHRpb25zID0gKG5ld0NwdE9wdGlvbnMgfHwgW10pLnNsaWNlKCk7XG4gIHZhciByZXN1bHQgPSB6clV0aWwubWFwKGV4aXN0cyB8fCBbXSwgZnVuY3Rpb24gKG9iaiwgaW5kZXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhpc3Q6IG9ialxuICAgIH07XG4gIH0pOyAvLyBNYXBwaW5nIGJ5IGlkIG9yIG5hbWUgaWYgc3BlY2lmaWVkLlxuXG4gIGVhY2gobmV3Q3B0T3B0aW9ucywgZnVuY3Rpb24gKGNwdE9wdGlvbiwgaW5kZXgpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNwdE9wdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlkIGhhcyBoaWdoZXN0IHByaW9yaXR5LlxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFyZXN1bHRbaV0ub3B0aW9uIC8vIENvbnNpZGVyIG5hbWU6IHR3byBtYXAgdG8gb25lLlxuICAgICAgJiYgY3B0T3B0aW9uLmlkICE9IG51bGwgJiYgcmVzdWx0W2ldLmV4aXN0LmlkID09PSBjcHRPcHRpb24uaWQgKyAnJykge1xuICAgICAgICByZXN1bHRbaV0ub3B0aW9uID0gY3B0T3B0aW9uO1xuICAgICAgICBuZXdDcHRPcHRpb25zW2luZGV4XSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4aXN0ID0gcmVzdWx0W2ldLmV4aXN0O1xuXG4gICAgICBpZiAoIXJlc3VsdFtpXS5vcHRpb24gLy8gQ29uc2lkZXIgbmFtZTogdHdvIG1hcCB0byBvbmUuXG4gICAgICAvLyBDYW4gbm90IG1hdGNoIHdoZW4gYm90aCBpZHMgZXhpc3QgYnV0IGRpZmZlcmVudC5cbiAgICAgICYmIChleGlzdC5pZCA9PSBudWxsIHx8IGNwdE9wdGlvbi5pZCA9PSBudWxsKSAmJiBjcHRPcHRpb24ubmFtZSAhPSBudWxsICYmICFpc0lkSW5uZXIoY3B0T3B0aW9uKSAmJiAhaXNJZElubmVyKGV4aXN0KSAmJiBleGlzdC5uYW1lID09PSBjcHRPcHRpb24ubmFtZSArICcnKSB7XG4gICAgICAgIHJlc3VsdFtpXS5vcHRpb24gPSBjcHRPcHRpb247XG4gICAgICAgIG5ld0NwdE9wdGlvbnNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIE90aGVyd2lzZSBtYXBwaW5nIGJ5IGluZGV4LlxuXG4gIGVhY2gobmV3Q3B0T3B0aW9ucywgZnVuY3Rpb24gKGNwdE9wdGlvbiwgaW5kZXgpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNwdE9wdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4aXN0ID0gcmVzdWx0W2ldLmV4aXN0O1xuXG4gICAgICBpZiAoIXJlc3VsdFtpXS5vcHRpb24gLy8gRXhpc3RpbmcgbW9kZWwgdGhhdCBhbHJlYWR5IGhhcyBpZCBzaG91bGQgYmUgYWJsZSB0b1xuICAgICAgLy8gbWFwcGVkIHRvIChiZWNhdXNlIGFmdGVyIG1hcHBpbmcgcGVyZm9ybWVkIG1vZGVsIG1heVxuICAgICAgLy8gYmUgYXNzaWduZWQgd2l0aCBhIGlkLCB3aGlzaCBzaG91bGQgbm90IGFmZmVjdCBuZXh0XG4gICAgICAvLyBtYXBwaW5nKSwgZXhjZXB0IHRob3NlIGhhcyBpbm5lciBpZC5cbiAgICAgICYmICFpc0lkSW5uZXIoZXhpc3QpIC8vIENhdXRpb246XG4gICAgICAvLyBEbyBub3Qgb3ZlcndyaXRlIGlkLiBCdXQgbmFtZSBjYW4gYmUgb3ZlcndyaXR0ZW4sXG4gICAgICAvLyBiZWNhdXNlIGF4aXMgdXNlIG5hbWUgYXMgJ3Nob3cgbGFiZWwgdGV4dCcuXG4gICAgICAvLyAnZXhpc3QnIGFsd2F5cyBoYXMgaWQgYW5kIG5hbWUgYW5kIHdlIGRvbnRcbiAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaXQuXG4gICAgICAmJiBjcHRPcHRpb24uaWQgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHRbaV0ub3B0aW9uID0gY3B0T3B0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIG9wdGlvbjogY3B0T3B0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBNYWtlIGlkIGFuZCBuYW1lIGZvciBtYXBwaW5nIHJlc3VsdCAocmVzdWx0IG9mIG1hcHBpbmdUb0V4aXN0cylcbiAqIGludG8gYGtleUluZm9gIGZpZWxkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFJlc3VsdCwgbGlrZSBbe2V4aXN0OiAuLi4sIG9wdGlvbjogLi4ufSwge31dLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIG9yZGVyIGlzIHRoZSBzYW1lIGFzIGV4aXN0cy5cbiAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBUaGUgaW5wdXQuXG4gKi9cblxuXG5mdW5jdGlvbiBtYWtlSWRBbmROYW1lKG1hcFJlc3VsdCkge1xuICAvLyBXZSB1c2UgdGhpcyBpZCB0byBoYXNoIGNvbXBvbmVudCBtb2RlbHMgYW5kIHZpZXcgaW5zdGFuY2VzXG4gIC8vIGluIGVjaGFydHMuIGlkIGNhbiBiZSBzcGVjaWZpZWQgYnkgdXNlciwgb3IgYXV0byBnZW5lcmF0ZWQuXG4gIC8vIFRoZSBpZCBnZW5lcmF0aW9uIHJ1bGUgZW5zdXJlcyBuZXcgdmlldyBpbnN0YW5jZSBhcmUgYWJsZVxuICAvLyB0byBtYXBwZWQgdG8gb2xkIGluc3RhbmNlIHdoZW4gc2V0T3B0aW9uIGFyZSBjYWxsZWQgaW5cbiAgLy8gbm8tbWVyZ2UgbW9kZS4gU28gd2UgZ2VuZXJhdGUgbW9kZWwgaWQgYnkgbmFtZSBhbmQgcGx1c1xuICAvLyB0eXBlIGluIHZpZXcgaWQuXG4gIC8vIG5hbWUgY2FuIGJlIGR1cGxpY2F0ZWQgYW1vbmcgY29tcG9uZW50cywgd2hpY2ggaXMgY29udmVuaWVudFxuICAvLyB0byBzcGVjaWZ5IG11bHRpIGNvbXBvbmVudHMgKGxpa2Ugc2VyaWVzKSBieSBvbmUgbmFtZS5cbiAgLy8gRW5zdXJlIHRoYXQgZWFjaCBpZCBpcyBkaXN0aW5jdC5cbiAgdmFyIGlkTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHZhciBleGlzdENwdCA9IGl0ZW0uZXhpc3Q7XG4gICAgZXhpc3RDcHQgJiYgaWRNYXAuc2V0KGV4aXN0Q3B0LmlkLCBpdGVtKTtcbiAgfSk7XG4gIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICB2YXIgb3B0ID0gaXRlbS5vcHRpb247XG4gICAgenJVdGlsLmFzc2VydCghb3B0IHx8IG9wdC5pZCA9PSBudWxsIHx8ICFpZE1hcC5nZXQob3B0LmlkKSB8fCBpZE1hcC5nZXQob3B0LmlkKSA9PT0gaXRlbSwgJ2lkIGR1cGxpY2F0ZXM6ICcgKyAob3B0ICYmIG9wdC5pZCkpO1xuICAgIG9wdCAmJiBvcHQuaWQgIT0gbnVsbCAmJiBpZE1hcC5zZXQob3B0LmlkLCBpdGVtKTtcbiAgICAhaXRlbS5rZXlJbmZvICYmIChpdGVtLmtleUluZm8gPSB7fSk7XG4gIH0pOyAvLyBNYWtlIG5hbWUgYW5kIGlkLlxuXG4gIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICB2YXIgZXhpc3RDcHQgPSBpdGVtLmV4aXN0O1xuICAgIHZhciBvcHQgPSBpdGVtLm9wdGlvbjtcbiAgICB2YXIga2V5SW5mbyA9IGl0ZW0ua2V5SW5mbztcblxuICAgIGlmICghaXNPYmplY3Qob3B0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbmFtZSBjYW4gYmUgb3ZlcndpdHRlbi4gQ29uc2lkZXIgY2FzZTogYXhpcy5uYW1lID0gJzIwa20nLlxuICAgIC8vIEJ1dCBpZCBnZW5lcmF0ZWQgYnkgbmFtZSB3aWxsIG5vdCBiZSBjaGFuZ2VkLCB3aGljaCBhZmZlY3RcbiAgICAvLyBvbmx5IGluIHRoYXQgY2FzZTogc2V0T3B0aW9uIHdpdGggJ25vdCBtZXJnZSBtb2RlJyBhbmQgdmlld1xuICAgIC8vIGluc3RhbmNlIHdpbGwgYmUgcmVjcmVhdGVkLCB3aGljaCBjYW4gYmUgYWNjZXB0ZWQuXG5cblxuICAgIGtleUluZm8ubmFtZSA9IG9wdC5uYW1lICE9IG51bGwgPyBvcHQubmFtZSArICcnIDogZXhpc3RDcHQgPyBleGlzdENwdC5uYW1lIDogJ1xcMC0nOyAvLyBuYW1lIG1heSBiZSBkaXNwbGF5ZWQgb24gc2NyZWVuLCBzbyB1c2UgJy0nLlxuXG4gICAgaWYgKGV4aXN0Q3B0KSB7XG4gICAgICBrZXlJbmZvLmlkID0gZXhpc3RDcHQuaWQ7XG4gICAgfSBlbHNlIGlmIChvcHQuaWQgIT0gbnVsbCkge1xuICAgICAga2V5SW5mby5pZCA9IG9wdC5pZCArICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb25zaWRlciB0aGlzIHNpdHVhdG9pbjpcbiAgICAgIC8vICBvcHRpb25BOiBbe25hbWU6ICdhJ30sIHtuYW1lOiAnYSd9LCB7Li59XVxuICAgICAgLy8gIG9wdGlvbkIgW3suLn0sIHtuYW1lOiAnYSd9LCB7bmFtZTogJ2EnfV1cbiAgICAgIC8vIFNlcmllcyB3aXRoIHRoZSBzYW1lIG5hbWUgYmV0d2VlbiBvcHRpb25BIGFuZCBvcHRpb25CXG4gICAgICAvLyBzaG91bGQgYmUgbWFwcGVkLlxuICAgICAgdmFyIGlkTnVtID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICBrZXlJbmZvLmlkID0gJ1xcMCcgKyBrZXlJbmZvLm5hbWUgKyAnXFwwJyArIGlkTnVtKys7XG4gICAgICB9IHdoaWxlIChpZE1hcC5nZXQoa2V5SW5mby5pZCkpO1xuICAgIH1cblxuICAgIGlkTWFwLnNldChrZXlJbmZvLmlkLCBpdGVtKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjcHRPcHRpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0lkSW5uZXIoY3B0T3B0aW9uKSB7XG4gIHJldHVybiBpc09iamVjdChjcHRPcHRpb24pICYmIGNwdE9wdGlvbi5pZCAmJiAoY3B0T3B0aW9uLmlkICsgJycpLmluZGV4T2YoJ1xcMF9lY19cXDAnKSA9PT0gMDtcbn1cbi8qKlxuICogQSBoZWxwZXIgZm9yIHJlbW92aW5nIGR1cGxpY2F0ZSBpdGVtcyBiZXR3ZWVuIGJhdGNoQSBhbmQgYmF0Y2hCLFxuICogYW5kIGluIHRoZW1zZWx2ZXMsIGFuZCBjYXRlZ29yaXplIGJ5IHNlcmllcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBiYXRjaEEgTGlrZTogW3tzZXJpZXNJZDogMiwgZGF0YUluZGV4OiBbMzIsIDQsIDVdfSwgLi4uXVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYmF0Y2hCIExpa2U6IFt7c2VyaWVzSWQ6IDIsIGRhdGFJbmRleDogWzMyLCA0LCA1XX0sIC4uLl1cbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48T2JqZWN0PiwgQXJyYXkuPE9iamVjdD4+fSByZXN1bHQ6IFtyZXN1bHRCYXRjaEEsIHJlc3VsdEJhdGNoQl1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXByZXNzQmF0Y2hlcyhiYXRjaEEsIGJhdGNoQikge1xuICB2YXIgbWFwQSA9IHt9O1xuICB2YXIgbWFwQiA9IHt9O1xuICBtYWtlTWFwKGJhdGNoQSB8fCBbXSwgbWFwQSk7XG4gIG1ha2VNYXAoYmF0Y2hCIHx8IFtdLCBtYXBCLCBtYXBBKTtcbiAgcmV0dXJuIFttYXBUb0FycmF5KG1hcEEpLCBtYXBUb0FycmF5KG1hcEIpXTtcblxuICBmdW5jdGlvbiBtYWtlTWFwKHNvdXJjZUJhdGNoLCBtYXAsIG90aGVyTWFwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZUJhdGNoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc2VyaWVzSWQgPSBzb3VyY2VCYXRjaFtpXS5zZXJpZXNJZDtcbiAgICAgIHZhciBkYXRhSW5kaWNlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoc291cmNlQmF0Y2hbaV0uZGF0YUluZGV4KTtcbiAgICAgIHZhciBvdGhlckRhdGFJbmRpY2VzID0gb3RoZXJNYXAgJiYgb3RoZXJNYXBbc2VyaWVzSWRdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgbGVuaiA9IGRhdGFJbmRpY2VzLmxlbmd0aDsgaiA8IGxlbmo7IGorKykge1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gZGF0YUluZGljZXNbal07XG5cbiAgICAgICAgaWYgKG90aGVyRGF0YUluZGljZXMgJiYgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdKSB7XG4gICAgICAgICAgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAobWFwW3Nlcmllc0lkXSB8fCAobWFwW3Nlcmllc0lkXSA9IHt9KSlbZGF0YUluZGV4XSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCwgaXNEYXRhKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSBpbiBtYXApIHtcbiAgICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkoaSkgJiYgbWFwW2ldICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzRGF0YSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCtpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZGF0YUluZGljZXMgPSBtYXBUb0FycmF5KG1hcFtpXSwgdHJ1ZSk7XG4gICAgICAgICAgZGF0YUluZGljZXMubGVuZ3RoICYmIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHNlcmllc0lkOiBpLFxuICAgICAgICAgICAgZGF0YUluZGV4OiBkYXRhSW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgQ29udGFpbnMgZGF0YUluZGV4IChtZWFucyByYXdJbmRleCkgLyBkYXRhSW5kZXhJbnNpZGUgLyBuYW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIG9mIHdoaWNoIGNhbiBiZSBBcnJheSBvciBwcmltYXJ5IHR5cGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IGRhdGFJbmRleCBJZiBub3QgZm91bmQsIHJldHVybiB1bmRlZmluZWQvbnVsbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1ZXJ5RGF0YUluZGV4KGRhdGEsIHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuZGF0YUluZGV4SW5zaWRlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGF5bG9hZC5kYXRhSW5kZXhJbnNpZGU7XG4gIH0gZWxzZSBpZiAocGF5bG9hZC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgIHJldHVybiB6clV0aWwuaXNBcnJheShwYXlsb2FkLmRhdGFJbmRleCkgPyB6clV0aWwubWFwKHBheWxvYWQuZGF0YUluZGV4LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkYXRhLmluZGV4T2ZSYXdJbmRleCh2YWx1ZSk7XG4gICAgfSkgOiBkYXRhLmluZGV4T2ZSYXdJbmRleChwYXlsb2FkLmRhdGFJbmRleCk7XG4gIH0gZWxzZSBpZiAocGF5bG9hZC5uYW1lICE9IG51bGwpIHtcbiAgICByZXR1cm4genJVdGlsLmlzQXJyYXkocGF5bG9hZC5uYW1lKSA/IHpyVXRpbC5tYXAocGF5bG9hZC5uYW1lLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkYXRhLmluZGV4T2ZOYW1lKHZhbHVlKTtcbiAgICB9KSA6IGRhdGEuaW5kZXhPZk5hbWUocGF5bG9hZC5uYW1lKTtcbiAgfVxufVxuLyoqXG4gKiBFbmFibGUgcHJvcGVydHkgc3RvcmFnZSB0byBhbnkgaG9zdCBvYmplY3QuXG4gKiBOb3RpY2U6IFNlcmlhbGl6YXRpb24gaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqIHZhciBnZXQgPSBtb2RlbFVpdGwubWFrZUdldHRlcigpO1xuICpcbiAqIGZ1bmN0aW9uIHNvbWUoaG9zdE9iaikge1xuICogICAgICBnZXQoaG9zdE9iaikuX3NvbWVQcm9wZXJ0eSA9IDEyMTI7XG4gKiAgICAgIC4uLlxuICogfVxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxudmFyIG1ha2VHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleSA9ICdcXDBfX2VjX3Byb3BfZ2V0dGVyXycgKyBpbmRleCsrO1xuICAgIHJldHVybiBmdW5jdGlvbiAoaG9zdE9iaikge1xuICAgICAgcmV0dXJuIGhvc3RPYmpba2V5XSB8fCAoaG9zdE9ialtrZXldID0ge30pO1xuICAgIH07XG4gIH07XG59KCk7XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHNlcmllc0luZGV4LCBzZXJpZXNJZCwgc2VyaWVzTmFtZSxcbiAqICAgICAgICAgICAgZ2VvSW5kZXgsIGdlb0lkLCBnZW9OYW1lLFxuICogICAgICAgICAgICBibWFwSW5kZXgsIGJtYXBJZCwgYm1hcE5hbWUsXG4gKiAgICAgICAgICAgIHhBeGlzSW5kZXgsIHhBeGlzSWQsIHhBeGlzTmFtZSxcbiAqICAgICAgICAgICAgeUF4aXNJbmRleCwgeUF4aXNJZCwgeUF4aXNOYW1lLFxuICogICAgICAgICAgICBncmlkSW5kZXgsIGdyaWRJZCwgZ3JpZE5hbWUsXG4gKiAgICAgICAgICAgIC4uLiAoY2FuIGJlIGV4dGVuZGVkKVxuICogICAgICAgIH1cbiAqICAgICAgICBFYWNoIHByb3BlcnRpZXMgY2FuIGJlIG51bWJlcnxzdHJpbmd8QXJyYXkuPG51bWJlcj58QXJyYXkuPHN0cmluZz5cbiAqICAgICAgICBGb3IgZXhhbXBsZSwgYSBmaW5kZXIgY291bGQgYmVcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHNlcmllc0luZGV4OiAzLFxuICogICAgICAgICAgICBnZW9JZDogWydhYScsICdjYyddLFxuICogICAgICAgICAgICBncmlkTmFtZTogWyd4eCcsICdyciddXG4gKiAgICAgICAgfVxuICogICAgICAgIHh4eEluZGV4IGNhbiBiZSBzZXQgYXMgJ2FsbCcgKG1lYW5zIGFsbCB4eHgpIG9yICdub25lJyAobWVhbnMgbm90IHNwZWNpZnkpXG4gKiAgICAgICAgSWYgbm90aGluZyBvciBudWxsL3VuZGVmaW5lZCBzcGVjaWZpZWQsIHJldHVybiBub3RoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdC5kZWZhdWx0TWFpblR5cGVdXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbb3B0LmluY2x1ZGVNYWluVHlwZXNdXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdCBsaWtlOlxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgc2VyaWVzTW9kZWxzOiBbc2VyaWVzTW9kZWwxLCBzZXJpZXNNb2RlbDJdLFxuICogICAgICAgICAgICBzZXJpZXNNb2RlbDogc2VyaWVzTW9kZWwxLCAvLyBUaGUgZmlyc3QgbW9kZWxcbiAqICAgICAgICAgICAgZ2VvTW9kZWxzOiBbZ2VvTW9kZWwxLCBnZW9Nb2RlbDJdLFxuICogICAgICAgICAgICBnZW9Nb2RlbDogZ2VvTW9kZWwxLCAvLyBUaGUgZmlyc3QgbW9kZWxcbiAqICAgICAgICAgICAgLi4uXG4gKiAgICAgICAgfVxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyLCBvcHQpIHtcbiAgaWYgKHpyVXRpbC5pc1N0cmluZyhmaW5kZXIpKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIG9ialtmaW5kZXIgKyAnSW5kZXgnXSA9IDA7XG4gICAgZmluZGVyID0gb2JqO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRNYWluVHlwZSA9IG9wdCAmJiBvcHQuZGVmYXVsdE1haW5UeXBlO1xuXG4gIGlmIChkZWZhdWx0TWFpblR5cGUgJiYgIWhhcyhmaW5kZXIsIGRlZmF1bHRNYWluVHlwZSArICdJbmRleCcpICYmICFoYXMoZmluZGVyLCBkZWZhdWx0TWFpblR5cGUgKyAnSWQnKSAmJiAhaGFzKGZpbmRlciwgZGVmYXVsdE1haW5UeXBlICsgJ05hbWUnKSkge1xuICAgIGZpbmRlcltkZWZhdWx0TWFpblR5cGUgKyAnSW5kZXgnXSA9IDA7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0ge307XG4gIGVhY2goZmluZGVyLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHZhciB2YWx1ZSA9IGZpbmRlcltrZXldOyAvLyBFeGNsdWRlICdkYXRhSW5kZXgnIGFuZCBvdGhlciBpbGxnYWwga2V5cy5cblxuICAgIGlmIChrZXkgPT09ICdkYXRhSW5kZXgnIHx8IGtleSA9PT0gJ2RhdGFJbmRleEluc2lkZScpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZEtleSA9IGtleS5tYXRjaCgvXihcXHcrKShJbmRleHxJZHxOYW1lKSQvKSB8fCBbXTtcbiAgICB2YXIgbWFpblR5cGUgPSBwYXJzZWRLZXlbMV07XG4gICAgdmFyIHF1ZXJ5VHlwZSA9IChwYXJzZWRLZXlbMl0gfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIW1haW5UeXBlIHx8ICFxdWVyeVR5cGUgfHwgdmFsdWUgPT0gbnVsbCB8fCBxdWVyeVR5cGUgPT09ICdpbmRleCcgJiYgdmFsdWUgPT09ICdub25lJyB8fCBvcHQgJiYgb3B0LmluY2x1ZGVNYWluVHlwZXMgJiYgenJVdGlsLmluZGV4T2Yob3B0LmluY2x1ZGVNYWluVHlwZXMsIG1haW5UeXBlKSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcXVlcnlQYXJhbSA9IHtcbiAgICAgIG1haW5UeXBlOiBtYWluVHlwZVxuICAgIH07XG5cbiAgICBpZiAocXVlcnlUeXBlICE9PSAnaW5kZXgnIHx8IHZhbHVlICE9PSAnYWxsJykge1xuICAgICAgcXVlcnlQYXJhbVtxdWVyeVR5cGVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIG1vZGVscyA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHF1ZXJ5UGFyYW0pO1xuICAgIHJlc3VsdFttYWluVHlwZSArICdNb2RlbHMnXSA9IG1vZGVscztcbiAgICByZXN1bHRbbWFpblR5cGUgKyAnTW9kZWwnXSA9IG1vZGVsc1swXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBzZWUge21vZHVsZTplY2hhcnRzL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9uc31cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRhdGFEaW1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGRhdGFEaW1Ub0Nvb3JkRGltKGRhdGEsIGRhdGFEaW0pIHtcbiAgdmFyIGRpbWVuc2lvbnMgPSBkYXRhLmRpbWVuc2lvbnM7XG4gIGRhdGFEaW0gPSBkYXRhLmdldERpbWVuc2lvbihkYXRhRGltKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltSXRlbSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1lbnNpb25zW2ldKTtcblxuICAgIGlmIChkaW1JdGVtLm5hbWUgPT09IGRhdGFEaW0pIHtcbiAgICAgIHJldHVybiBkaW1JdGVtLmNvb3JkRGltO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkRGltXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gZGF0YSBkaW1lbnNpb25zIG9uIHRoZSBjb29yZERpbS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvb3JkRGltVG9EYXRhRGltKGRhdGEsIGNvb3JkRGltKSB7XG4gIHZhciBkYXRhRGltID0gW107XG4gIGVhY2goZGF0YS5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltTmFtZSkge1xuICAgIHZhciBkaW1JdGVtID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbU5hbWUpO1xuXG4gICAgaWYgKGRpbUl0ZW0uY29vcmREaW0gPT09IGNvb3JkRGltKSB7XG4gICAgICBkYXRhRGltW2RpbUl0ZW0uY29vcmREaW1JbmRleF0gPSBkaW1JdGVtLm5hbWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGFEaW07XG59XG4vKipcbiAqIEBzZWUge21vZHVsZTplY2hhcnRzL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9uc31cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gb3RoZXJEaW0gQ2FuIGJlIGBvdGhlckRpbXNgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGxpa2UgJ2xhYmVsJyBvciAndG9vbHRpcCcuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gZGF0YSBkaW1lbnNpb25zIG9uIHRoZSBvdGhlckRpbS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG90aGVyRGltVG9EYXRhRGltKGRhdGEsIG90aGVyRGltKSB7XG4gIHZhciBkYXRhRGltID0gW107XG4gIGVhY2goZGF0YS5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltTmFtZSkge1xuICAgIHZhciBkaW1JdGVtID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbU5hbWUpO1xuICAgIHZhciBvdGhlckRpbXMgPSBkaW1JdGVtLm90aGVyRGltcztcbiAgICB2YXIgZGltSW5kZXggPSBvdGhlckRpbXNbb3RoZXJEaW1dO1xuXG4gICAgaWYgKGRpbUluZGV4ICE9IG51bGwgJiYgZGltSW5kZXggIT09IGZhbHNlKSB7XG4gICAgICBkYXRhRGltW2RpbUluZGV4XSA9IGRpbUl0ZW0ubmFtZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YURpbTtcbn1cblxuZnVuY3Rpb24gaGFzKG9iaiwgcHJvcCkge1xuICByZXR1cm4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVUb0FycmF5ID0gbm9ybWFsaXplVG9BcnJheTtcbmV4cG9ydHMuZGVmYXVsdEVtcGhhc2lzID0gZGVmYXVsdEVtcGhhc2lzO1xuZXhwb3J0cy5URVhUX1NUWUxFX09QVElPTlMgPSBURVhUX1NUWUxFX09QVElPTlM7XG5leHBvcnRzLmdldERhdGFJdGVtVmFsdWUgPSBnZXREYXRhSXRlbVZhbHVlO1xuZXhwb3J0cy5pc0RhdGFJdGVtT3B0aW9uID0gaXNEYXRhSXRlbU9wdGlvbjtcbmV4cG9ydHMuY29udmVyRGF0YVZhbHVlID0gY29udmVyRGF0YVZhbHVlO1xuZXhwb3J0cy5jcmVhdGVEYXRhRm9ybWF0TW9kZWwgPSBjcmVhdGVEYXRhRm9ybWF0TW9kZWw7XG5leHBvcnRzLmRhdGFGb3JtYXRNaXhpbiA9IGRhdGFGb3JtYXRNaXhpbjtcbmV4cG9ydHMubWFwcGluZ1RvRXhpc3RzID0gbWFwcGluZ1RvRXhpc3RzO1xuZXhwb3J0cy5tYWtlSWRBbmROYW1lID0gbWFrZUlkQW5kTmFtZTtcbmV4cG9ydHMuaXNJZElubmVyID0gaXNJZElubmVyO1xuZXhwb3J0cy5jb21wcmVzc0JhdGNoZXMgPSBjb21wcmVzc0JhdGNoZXM7XG5leHBvcnRzLnF1ZXJ5RGF0YUluZGV4ID0gcXVlcnlEYXRhSW5kZXg7XG5leHBvcnRzLm1ha2VHZXR0ZXIgPSBtYWtlR2V0dGVyO1xuZXhwb3J0cy5wYXJzZUZpbmRlciA9IHBhcnNlRmluZGVyO1xuZXhwb3J0cy5kYXRhRGltVG9Db29yZERpbSA9IGRhdGFEaW1Ub0Nvb3JkRGltO1xuZXhwb3J0cy5jb29yZERpbVRvRGF0YURpbSA9IGNvb3JkRGltVG9EYXRhRGltO1xuZXhwb3J0cy5vdGhlckRpbVRvRGF0YURpbSA9IG90aGVyRGltVG9EYXRhRGltO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFJBRElBTl9FUFNJTE9OID0gMWUtNDtcblxuZnVuY3Rpb24gX3RyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG59XG4vKipcbiAqIExpbmVhciBtYXBwaW5nIGEgdmFsdWUgZnJvbSBkb21haW4gdG8gcmFuZ2VcbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZWNoYXJ0cy91dGlsL251bWJlclxuICogQHBhcmFtICB7KG51bWJlcnxBcnJheS48bnVtYmVyPil9IHZhbFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGRvbWFpbiBEb21haW4gZXh0ZW50IGRvbWFpblswXSBjYW4gYmUgYmlnZ2VyIHRoYW4gZG9tYWluWzFdXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcmFuZ2UgIFJhbmdlIGV4dGVudCByYW5nZVswXSBjYW4gYmUgYmlnZ2VyIHRoYW4gcmFuZ2VbMV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gKiBAcmV0dXJuIHsobnVtYmVyfEFycmF5LjxudW1iZXI+fVxuICovXG5cblxuZnVuY3Rpb24gbGluZWFyTWFwKHZhbCwgZG9tYWluLCByYW5nZSwgY2xhbXApIHtcbiAgdmFyIHN1YkRvbWFpbiA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcbiAgdmFyIHN1YlJhbmdlID0gcmFuZ2VbMV0gLSByYW5nZVswXTtcblxuICBpZiAoc3ViRG9tYWluID09PSAwKSB7XG4gICAgcmV0dXJuIHN1YlJhbmdlID09PSAwID8gcmFuZ2VbMF0gOiAocmFuZ2VbMF0gKyByYW5nZVsxXSkgLyAyO1xuICB9IC8vIEF2b2lkIGFjY3VyYWN5IHByb2JsZW0gaW4gZWRnZSwgc3VjaCBhc1xuICAvLyAxNDYuMzkgLSA2Mi44MyA9PT0gODMuNTU5OTk5OTk5OTk5OTkuXG4gIC8vIFNlZSBlY2hhcnRzL3Rlc3QvdXQvc3BlYy91dGlsL251bWJlci5qcyNsaW5lYXJNYXAjYWNjdXJhY3lFcnJvclxuICAvLyBJdCBpcyBhIGxpdHRsZSB2ZXJib3NlIGZvciBlZmZpY2llbmN5IGNvbnNpZGVyaW5nIHRoaXMgbWV0aG9kXG4gIC8vIGlzIGEgaG90c3BvdC5cblxuXG4gIGlmIChjbGFtcCkge1xuICAgIGlmIChzdWJEb21haW4gPiAwKSB7XG4gICAgICBpZiAodmFsIDw9IGRvbWFpblswXSkge1xuICAgICAgICByZXR1cm4gcmFuZ2VbMF07XG4gICAgICB9IGVsc2UgaWYgKHZhbCA+PSBkb21haW5bMV0pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsID49IGRvbWFpblswXSkge1xuICAgICAgICByZXR1cm4gcmFuZ2VbMF07XG4gICAgICB9IGVsc2UgaWYgKHZhbCA8PSBkb21haW5bMV0pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlWzFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID09PSBkb21haW5bMF0pIHtcbiAgICAgIHJldHVybiByYW5nZVswXTtcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSBkb21haW5bMV0pIHtcbiAgICAgIHJldHVybiByYW5nZVsxXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKHZhbCAtIGRvbWFpblswXSkgLyBzdWJEb21haW4gKiBzdWJSYW5nZSArIHJhbmdlWzBdO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgcGVyY2VudCBzdHJpbmcgdG8gYWJzb2x1dGUgbnVtYmVyLlxuICogUmV0dXJucyBOYU4gaWYgcGVyY2VudCBpcyBub3QgYSB2YWxpZCBzdHJpbmcgb3IgbnVtYmVyXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmVjaGFydHMvdXRpbC9udW1iZXJcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcGVyY2VudFxuICogQHBhcmFtIHtudW1iZXJ9IGFsbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VQZXJjZW50KHBlcmNlbnQsIGFsbCkge1xuICBzd2l0Y2ggKHBlcmNlbnQpIHtcbiAgICBjYXNlICdjZW50ZXInOlxuICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICBwZXJjZW50ID0gJzUwJSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBwZXJjZW50ID0gJzAlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBwZXJjZW50ID0gJzEwMCUnO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAodHlwZW9mIHBlcmNlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKF90cmltKHBlcmNlbnQpLm1hdGNoKC8lJC8pKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChwZXJjZW50KSAvIDEwMCAqIGFsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChwZXJjZW50KTtcbiAgfVxuXG4gIHJldHVybiBwZXJjZW50ID09IG51bGwgPyBOYU4gOiArcGVyY2VudDtcbn1cbi8qKlxuICogKDEpIEZpeCByb3VuZGluZyBlcnJvciBvZiBmbG9hdCBudW1iZXJzLlxuICogKDIpIFN1cHBvcnQgcmV0dXJuIHN0cmluZyB0byBhdm9pZCBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgJzMuNWUtNycuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHBhcmFtIHtib29sZWFufSBbcmV0dXJuU3RyXVxuICogQHJldHVybiB7bnVtYmVyfHN0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdW5kKHgsIHByZWNpc2lvbiwgcmV0dXJuU3RyKSB7XG4gIGlmIChwcmVjaXNpb24gPT0gbnVsbCkge1xuICAgIHByZWNpc2lvbiA9IDEwO1xuICB9IC8vIEF2b2lkIHJhbmdlIGVycm9yXG5cblxuICBwcmVjaXNpb24gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBwcmVjaXNpb24pLCAyMCk7XG4gIHggPSAoK3gpLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgcmV0dXJuIHJldHVyblN0ciA/IHggOiAreDtcbn1cblxuZnVuY3Rpb24gYXNjKGFycikge1xuICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG4gIHJldHVybiBhcnI7XG59XG4vKipcbiAqIEdldCBwcmVjaXNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFByZWNpc2lvbih2YWwpIHtcbiAgdmFsID0gK3ZhbDtcblxuICBpZiAoaXNOYU4odmFsKSkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIEl0IGlzIG11Y2ggZmFzdGVyIHRoYW4gbWV0aG9kcyBjb252ZXJ0aW5nIG51bWJlciB0byBzdHJpbmcgYXMgZm9sbG93c1xuICAvLyAgICAgIHZhciB0bXAgPSB2YWwudG9TdHJpbmcoKTtcbiAgLy8gICAgICByZXR1cm4gdG1wLmxlbmd0aCAtIDEgLSB0bXAuaW5kZXhPZignLicpO1xuICAvLyBlc3BlY2lhbGx5IHdoZW4gcHJlY2lzaW9uIGlzIGxvd1xuXG5cbiAgdmFyIGUgPSAxO1xuICB2YXIgY291bnQgPSAwO1xuXG4gIHdoaWxlIChNYXRoLnJvdW5kKHZhbCAqIGUpIC8gZSAhPT0gdmFsKSB7XG4gICAgZSAqPSAxMDtcbiAgICBjb3VudCsrO1xuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0UHJlY2lzaW9uU2FmZSh2YWwpIHtcbiAgdmFyIHN0ciA9IHZhbC50b1N0cmluZygpOyAvLyBDb25zaWRlciBzY2llbnRpZmljIG5vdGF0aW9uOiAnMy40ZS0xMicgJzMuNGUrMTInXG5cbiAgdmFyIGVJbmRleCA9IHN0ci5pbmRleE9mKCdlJyk7XG5cbiAgaWYgKGVJbmRleCA+IDApIHtcbiAgICB2YXIgcHJlY2lzaW9uID0gK3N0ci5zbGljZShlSW5kZXggKyAxKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uIDwgMCA/IC1wcmVjaXNpb24gOiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciBkb3RJbmRleCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgcmV0dXJuIGRvdEluZGV4IDwgMCA/IDAgOiBzdHIubGVuZ3RoIC0gMSAtIGRvdEluZGV4O1xuICB9XG59XG4vKipcbiAqIE1pbmltYWwgZGljZXJuaWJsZSBkYXRhIHByZWNpc2lvaW4gYWNjb3JkaW5nIHRvIGEgc2luZ2xlIHBpeGVsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGFFeHRlbnRcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBpeGVsRXh0ZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHByZWNpc2lvblxuICovXG5cblxuZnVuY3Rpb24gZ2V0UGl4ZWxQcmVjaXNpb24oZGF0YUV4dGVudCwgcGl4ZWxFeHRlbnQpIHtcbiAgdmFyIGxvZyA9IE1hdGgubG9nO1xuICB2YXIgTE4xMCA9IE1hdGguTE4xMDtcbiAgdmFyIGRhdGFRdWFudGl0eSA9IE1hdGguZmxvb3IobG9nKGRhdGFFeHRlbnRbMV0gLSBkYXRhRXh0ZW50WzBdKSAvIExOMTApO1xuICB2YXIgc2l6ZVF1YW50aXR5ID0gTWF0aC5yb3VuZChsb2coTWF0aC5hYnMocGl4ZWxFeHRlbnRbMV0gLSBwaXhlbEV4dGVudFswXSkpIC8gTE4xMCk7IC8vIHRvRml4ZWQoKSBkaWdpdHMgYXJndW1lbnQgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDIwLlxuXG4gIHZhciBwcmVjaXNpb24gPSBNYXRoLm1pbihNYXRoLm1heCgtZGF0YVF1YW50aXR5ICsgc2l6ZVF1YW50aXR5LCAwKSwgMjApO1xuICByZXR1cm4gIWlzRmluaXRlKHByZWNpc2lvbikgPyAyMCA6IHByZWNpc2lvbjtcbn1cbi8qKlxuICogR2V0IGEgZGF0YSBvZiBnaXZlbiBwcmVjaXNpb24sIGFzc3VyaW5nIHRoZSBzdW0gb2YgcGVyY2VudGFnZXNcbiAqIGluIHZhbHVlTGlzdCBpcyAxLlxuICogVGhlIGxhcmdlc3QgcmVtYWluZXIgbWV0aG9kIGlzIHVzZWQuXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXJnZXN0X3JlbWFpbmRlcl9tZXRob2RcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZUxpc3QgYSBsaXN0IG9mIGFsbCBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4IGluZGV4IG9mIHRoZSBkYXRhIHRvIGJlIHByb2Nlc3NlZCBpbiB2YWx1ZUxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjaXNpb24gaW50ZWdlciBudW1iZXIgc2hvd2luZyBkaWdpdHMgb2YgcHJlY2lzaW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHBlcmNlbnQgcmFuZ2luZyBmcm9tIDAgdG8gMTAwXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQZXJjZW50V2l0aFByZWNpc2lvbih2YWx1ZUxpc3QsIGlkeCwgcHJlY2lzaW9uKSB7XG4gIGlmICghdmFsdWVMaXN0W2lkeF0pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzdW0gPSB6clV0aWwucmVkdWNlKHZhbHVlTGlzdCwgZnVuY3Rpb24gKGFjYywgdmFsKSB7XG4gICAgcmV0dXJuIGFjYyArIChpc05hTih2YWwpID8gMCA6IHZhbCk7XG4gIH0sIDApO1xuXG4gIGlmIChzdW0gPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkaWdpdHMgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgdmFyIHZvdGVzUGVyUXVvdGEgPSB6clV0aWwubWFwKHZhbHVlTGlzdCwgZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAoaXNOYU4odmFsKSA/IDAgOiB2YWwpIC8gc3VtICogZGlnaXRzICogMTAwO1xuICB9KTtcbiAgdmFyIHRhcmdldFNlYXRzID0gZGlnaXRzICogMTAwO1xuICB2YXIgc2VhdHMgPSB6clV0aWwubWFwKHZvdGVzUGVyUXVvdGEsIGZ1bmN0aW9uICh2b3Rlcykge1xuICAgIC8vIEFzc2lnbiBhdXRvbWF0aWMgc2VhdHMuXG4gICAgcmV0dXJuIE1hdGguZmxvb3Iodm90ZXMpO1xuICB9KTtcbiAgdmFyIGN1cnJlbnRTdW0gPSB6clV0aWwucmVkdWNlKHNlYXRzLCBmdW5jdGlvbiAoYWNjLCB2YWwpIHtcbiAgICByZXR1cm4gYWNjICsgdmFsO1xuICB9LCAwKTtcbiAgdmFyIHJlbWFpbmRlciA9IHpyVXRpbC5tYXAodm90ZXNQZXJRdW90YSwgZnVuY3Rpb24gKHZvdGVzLCBpZHgpIHtcbiAgICByZXR1cm4gdm90ZXMgLSBzZWF0c1tpZHhdO1xuICB9KTsgLy8gSGFzIHJlbWFpbmRpbmcgdm90ZXMuXG5cbiAgd2hpbGUgKGN1cnJlbnRTdW0gPCB0YXJnZXRTZWF0cykge1xuICAgIC8vIEZpbmQgbmV4dCBsYXJnZXN0IHJlbWFpbmRlci5cbiAgICB2YXIgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIHZhciBtYXhJZCA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVtYWluZGVyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAocmVtYWluZGVyW2ldID4gbWF4KSB7XG4gICAgICAgIG1heCA9IHJlbWFpbmRlcltpXTtcbiAgICAgICAgbWF4SWQgPSBpO1xuICAgICAgfVxuICAgIH0gLy8gQWRkIGEgdm90ZSB0byBtYXggcmVtYWluZGVyLlxuXG5cbiAgICArK3NlYXRzW21heElkXTtcbiAgICByZW1haW5kZXJbbWF4SWRdID0gMDtcbiAgICArK2N1cnJlbnRTdW07XG4gIH1cblxuICByZXR1cm4gc2VhdHNbaWR4XSAvIGRpZ2l0cztcbn0gLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIGllIGRvIG5vdCBzdXBwb3J0LlxuXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbi8qKlxuICogVG8gMCAtIDIgKiBQSSwgY29uc2lkZXJpbmcgbmVnYXRpdmUgcmFkaWFuLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhblxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIHJlbVJhZGlhbihyYWRpYW4pIHtcbiAgdmFyIHBpMiA9IE1hdGguUEkgKiAyO1xuICByZXR1cm4gKHJhZGlhbiAlIHBpMiArIHBpMikgJSBwaTI7XG59XG4vKipcbiAqIEBwYXJhbSB7dHlwZX0gcmFkaWFuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNSYWRpYW5Bcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gLVJBRElBTl9FUFNJTE9OICYmIHZhbCA8IFJBRElBTl9FUFNJTE9OO1xufVxuXG52YXIgVElNRV9SRUcgPSAvXig/OihcXGR7NH0pKD86Wy1cXC9dKFxcZHsxLDJ9KSg/OlstXFwvXShcXGR7MSwyfSkoPzpbVCBdKFxcZHsxLDJ9KSg/OjooXFxkXFxkKSg/OjooXFxkXFxkKSg/OlsuLF0oXFxkKykpPyk/KT8oWnxbXFwrXFwtXVxcZFxcZDo/XFxkXFxkKT8pPyk/KT8pPyQvOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xEYXRlfG51bWJlcn0gdmFsdWUgVGhlc2UgdmFsdWVzIGNhbiBiZSBhY2NlcHRlZDpcbiAqICAgKyBBbiBpbnN0YW5jZSBvZiBEYXRlLCByZXByZXNlbnQgYSB0aW1lIGluIGl0cyBvd24gdGltZSB6b25lLlxuICogICArIE9yIHN0cmluZyBpbiBhIHN1YnNldCBvZiBJU08gODYwMSwgb25seSBpbmNsdWRpbmc6XG4gKiAgICAgKyBvbmx5IHllYXIsIG1vbnRoLCBkYXRlOiAnMjAxMi0wMycsICcyMDEyLTAzLTAxJywgJzIwMTItMDMtMDEgMDUnLCAnMjAxMi0wMy0wMSAwNTowNicsXG4gKiAgICAgKyBzZXBhcmF0ZWQgd2l0aCBUIG9yIHNwYWNlOiAnMjAxMi0wMy0wMVQxMjoyMjozMy4xMjMnLCAnMjAxMi0wMy0wMSAxMjoyMjozMy4xMjMnLFxuICogICAgICsgdGltZSB6b25lOiAnMjAxMi0wMy0wMVQxMjoyMjozM1onLCAnMjAxMi0wMy0wMVQxMjoyMjozMys4MDAwJywgJzIwMTItMDMtMDFUMTI6MjI6MzMtMDU6MDAnLFxuICogICAgIGFsbCBvZiB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgbG9jYWwgdGltZSBpZiB0aW1lIHpvbmUgaXMgbm90IHNwZWNpZmllZFxuICogICAgIChzZWUgPGh0dHBzOi8vbW9tZW50anMuY29tLz4pLlxuICogICArIE9yIG90aGVyIHN0cmluZyBmb3JtYXQsIGluY2x1ZGluZyAoYWxsIG9mIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCBhcyBsb2FjYWwgdGltZSk6XG4gKiAgICAgJzIwMTInLCAnMjAxMi0zLTEnLCAnMjAxMi8zLzEnLCAnMjAxMi8wMy8wMScsXG4gKiAgICAgJzIwMDkvNi8xMiAyOjAwJywgJzIwMDkvNi8xMiAyOjA1OjA4JywgJzIwMDkvNi8xMiAyOjA1OjA4LjEyMydcbiAqICAgKyBhIHRpbWVzdGFtcCwgd2hpY2ggcmVwcmVzZW50IGEgdGltZSBpbiBVVEMuXG4gKiBAcmV0dXJuIHtEYXRlfSBkYXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VEYXRlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIC8vIERpZmZlcmVudCBicm93c2VycyBwYXJzZSBkYXRlIGluIGRpZmZlcmVudCB3YXksIHNvIHdlIHBhcnNlIGl0IG1hbnVhbGx5LlxuICAgIC8vIFNvbWUgb3RoZXIgaXNzdWVzOlxuICAgIC8vIG5ldyBEYXRlKCcxOTcwLTAxLTAxJykgaXMgVVRDLFxuICAgIC8vIG5ldyBEYXRlKCcxOTcwLzAxLzAxJykgYW5kIG5ldyBEYXRlKCcxOTcwLTEtMDEnKSBpcyBsb2NhbC5cbiAgICAvLyBTZWUgaXNzdWUgIzM2MjNcbiAgICB2YXIgbWF0Y2ggPSBUSU1FX1JFRy5leGVjKHZhbHVlKTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIC8vIHJldHVybiBJbnZhbGlkIERhdGUuXG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICB9IC8vIFVzZSBsb2NhbCB0aW1lIHdoZW4gbm8gdGltZXpvbmUgb2Zmc2V0IHNwZWNpZmVkLlxuXG5cbiAgICBpZiAoIW1hdGNoWzhdKSB7XG4gICAgICAvLyBtYXRjaFtuXSBjYW4gb25seSBiZSBzdHJpbmcgb3IgdW5kZWZpbmVkLlxuICAgICAgLy8gQnV0IHRha2UgY2FyZSBvZiAnMTInICsgMSA9PiAnMTIxJy5cbiAgICAgIHJldHVybiBuZXcgRGF0ZSgrbWF0Y2hbMV0sICsobWF0Y2hbMl0gfHwgMSkgLSAxLCArbWF0Y2hbM10gfHwgMSwgK21hdGNoWzRdIHx8IDAsICsobWF0Y2hbNV0gfHwgMCksICttYXRjaFs2XSB8fCAwLCArbWF0Y2hbN10gfHwgMCk7XG4gICAgfSAvLyBUaW1lem9uZW9mZnNldCBvZiBKYXZhc2NyaXB0IERhdGUgaGFzIGNvbnNpZGVyZWQgRFNUIChEYXlsaWdodCBTYXZpbmcgVGltZSxcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kYXlsaWdodC1zYXZpbmctdGltZS1hZGp1c3RtZW50KS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgc3lzdGVtIHRpbWV6b25lIGlzIHNldCBhcyBcIlRpbWUgWm9uZTogQW1lcmljYS9Ub3JvbnRvXCIsXG4gICAgLy8gdGhlbiB0aGVzZSBjb2RlIHdpbGwgZ2V0IGRpZmZlcmVudCByZXN1bHQ6XG4gICAgLy8gYG5ldyBEYXRlKDE0Nzg0MTE5OTk5OTkpLmdldFRpbWV6b25lT2Zmc2V0KCk7ICAvLyBnZXQgMjQwYFxuICAgIC8vIGBuZXcgRGF0ZSgxNDc4NDEyMDAwMDAwKS5nZXRUaW1lem9uZU9mZnNldCgpOyAgLy8gZ2V0IDMwMGBcbiAgICAvLyBTbyB3ZSBzaG91bGQgbm90IHVzZSBgbmV3IERhdGVgLCBidXQgdXNlIGBEYXRlLlVUQ2AuXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBob3VyID0gK21hdGNoWzRdIHx8IDA7XG5cbiAgICAgICAgaWYgKG1hdGNoWzhdLnRvVXBwZXJDYXNlKCkgIT09ICdaJykge1xuICAgICAgICAgIGhvdXIgLT0gbWF0Y2hbOF0uc2xpY2UoMCwgMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoK21hdGNoWzFdLCArKG1hdGNoWzJdIHx8IDEpIC0gMSwgK21hdGNoWzNdIHx8IDEsIGhvdXIsICsobWF0Y2hbNV0gfHwgMCksICttYXRjaFs2XSB8fCAwLCArbWF0Y2hbN10gfHwgMCkpO1xuICAgICAgfVxuICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0ZShNYXRoLnJvdW5kKHZhbHVlKSk7XG59XG4vKipcbiAqIFF1YW50aXR5IG9mIGEgbnVtYmVyLiBlLmcuIDAuMSwgMSwgMTAsIDEwMFxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFudGl0eSh2YWwpIHtcbiAgcmV0dXJuIE1hdGgucG93KDEwLCBxdWFudGl0eUV4cG9uZW50KHZhbCkpO1xufVxuXG5mdW5jdGlvbiBxdWFudGl0eUV4cG9uZW50KHZhbCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjEwKTtcbn1cbi8qKlxuICogZmluZCBhIOKAnG5pY2XigJ0gbnVtYmVyIGFwcHJveGltYXRlbHkgZXF1YWwgdG8geC4gUm91bmQgdGhlIG51bWJlciBpZiByb3VuZCA9IHRydWUsXG4gKiB0YWtlIGNlaWxpbmcgaWYgcm91bmQgPSBmYWxzZS4gVGhlIHByaW1hcnkgb2JzZXJ2YXRpb24gaXMgdGhhdCB0aGUg4oCcbmljZXN04oCdXG4gKiBudW1iZXJzIGluIGRlY2ltYWwgYXJlIDEsIDIsIGFuZCA1LCBhbmQgYWxsIHBvd2VyLW9mLXRlbiBtdWx0aXBsZXMgb2YgdGhlc2UgbnVtYmVycy5cbiAqXG4gKiBTZWUgXCJOaWNlIE51bWJlcnMgZm9yIEdyYXBoIExhYmVsc1wiIG9mIEdyYXBoaWMgR2Vtcy5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbCBOb24tbmVnYXRpdmUgdmFsdWUuXG4gKiBAcGFyYW0gIHtib29sZWFufSByb3VuZFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gbmljZSh2YWwsIHJvdW5kKSB7XG4gIHZhciBleHBvbmVudCA9IHF1YW50aXR5RXhwb25lbnQodmFsKTtcbiAgdmFyIGV4cDEwID0gTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcbiAgdmFyIGYgPSB2YWwgLyBleHAxMDsgLy8gMSA8PSBmIDwgMTBcblxuICB2YXIgbmY7XG5cbiAgaWYgKHJvdW5kKSB7XG4gICAgaWYgKGYgPCAxLjUpIHtcbiAgICAgIG5mID0gMTtcbiAgICB9IGVsc2UgaWYgKGYgPCAyLjUpIHtcbiAgICAgIG5mID0gMjtcbiAgICB9IGVsc2UgaWYgKGYgPCA0KSB7XG4gICAgICBuZiA9IDM7XG4gICAgfSBlbHNlIGlmIChmIDwgNykge1xuICAgICAgbmYgPSA1O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZiA9IDEwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZiA8IDEpIHtcbiAgICAgIG5mID0gMTtcbiAgICB9IGVsc2UgaWYgKGYgPCAyKSB7XG4gICAgICBuZiA9IDI7XG4gICAgfSBlbHNlIGlmIChmIDwgMykge1xuICAgICAgbmYgPSAzO1xuICAgIH0gZWxzZSBpZiAoZiA8IDUpIHtcbiAgICAgIG5mID0gNTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmYgPSAxMDtcbiAgICB9XG4gIH1cblxuICB2YWwgPSBuZiAqIGV4cDEwOyAvLyBGaXggMyAqIDAuMSA9PT0gMC4zMDAwMDAwMDAwMDAwMDAwNCBpc3N1ZSAoc2VlIElFRUUgNzU0KS5cbiAgLy8gMjAgaXMgdGhlIHVwcHBlciBib3VuZCBvZiB0b0ZpeGVkLlxuXG4gIHJldHVybiBleHBvbmVudCA+PSAtMjAgPyArdmFsLnRvRml4ZWQoZXhwb25lbnQgPCAwID8gLWV4cG9uZW50IDogMCkgOiB2YWw7XG59XG4vKipcbiAqIE9yZGVyIGludGVydmFscyBhc2MsIGFuZCBzcGxpdCB0aGVtIHdoZW4gb3ZlcmxhcC5cbiAqIGV4cGVjdChudW1iZXJVdGlsLnJlZm9ybUludGVydmFscyhbXG4gKiAgICAge2ludGVydmFsOiBbMTgsIDYyXSwgY2xvc2U6IFsxLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbLUluZmluaXR5LCAtNzBdLCBjbG9zZTogWzAsIDBdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFstNzAsIC0yNl0sIGNsb3NlOiBbMSwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWy0yNiwgMThdLCBjbG9zZTogWzEsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFs2MiwgMTUwXSwgY2xvc2U6IFsxLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbMTA2LCAxNTBdLCBjbG9zZTogWzEsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFsxNTAsIEluZmluaXR5XSwgY2xvc2U6IFswLCAwXX1cbiAqIF0pKS50b0VxdWFsKFtcbiAqICAgICB7aW50ZXJ2YWw6IFstSW5maW5pdHksIC03MF0sIGNsb3NlOiBbMCwgMF19LFxuICogICAgIHtpbnRlcnZhbDogWy03MCwgLTI2XSwgY2xvc2U6IFsxLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbLTI2LCAxOF0sIGNsb3NlOiBbMCwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWzE4LCA2Ml0sIGNsb3NlOiBbMCwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWzYyLCAxNTBdLCBjbG9zZTogWzAsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFsxNTAsIEluZmluaXR5XSwgY2xvc2U6IFswLCAwXX1cbiAqIF0pO1xuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gbGlzdCwgd2hlcmUgYGNsb3NlYCBtZWFuIG9wZW4gb3IgY2xvc2VcbiAqICAgICAgICBvZiB0aGUgaW50ZXJ2YWwsIGFuZCBJbmZpbml0eSBjYW4gYmUgdXNlZC5cbiAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBUaGUgb3JpZ2luIGxpc3QsIHdoaWNoIGhhcyBiZWVuIHJlZm9ybWVkLlxuICovXG5cblxuZnVuY3Rpb24gcmVmb3JtSW50ZXJ2YWxzKGxpc3QpIHtcbiAgbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGxpdHRsZVRoYW4oYSwgYiwgMCkgPyAtMSA6IDE7XG4gIH0pO1xuICB2YXIgY3VyciA9IC1JbmZpbml0eTtcbiAgdmFyIGN1cnJDbG9zZSA9IDE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDspIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSBsaXN0W2ldLmludGVydmFsO1xuICAgIHZhciBjbG9zZSA9IGxpc3RbaV0uY2xvc2U7XG5cbiAgICBmb3IgKHZhciBsZyA9IDA7IGxnIDwgMjsgbGcrKykge1xuICAgICAgaWYgKGludGVydmFsW2xnXSA8PSBjdXJyKSB7XG4gICAgICAgIGludGVydmFsW2xnXSA9IGN1cnI7XG4gICAgICAgIGNsb3NlW2xnXSA9ICFsZyA/IDEgLSBjdXJyQ2xvc2UgOiAxO1xuICAgICAgfVxuXG4gICAgICBjdXJyID0gaW50ZXJ2YWxbbGddO1xuICAgICAgY3VyckNsb3NlID0gY2xvc2VbbGddO1xuICAgIH1cblxuICAgIGlmIChpbnRlcnZhbFswXSA9PT0gaW50ZXJ2YWxbMV0gJiYgY2xvc2VbMF0gKiBjbG9zZVsxXSAhPT0gMSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdDtcblxuICBmdW5jdGlvbiBsaXR0bGVUaGFuKGEsIGIsIGxnKSB7XG4gICAgcmV0dXJuIGEuaW50ZXJ2YWxbbGddIDwgYi5pbnRlcnZhbFtsZ10gfHwgYS5pbnRlcnZhbFtsZ10gPT09IGIuaW50ZXJ2YWxbbGddICYmIChhLmNsb3NlW2xnXSAtIGIuY2xvc2VbbGddID09PSAoIWxnID8gMSA6IC0xKSB8fCAhbGcgJiYgbGl0dGxlVGhhbihhLCBiLCAxKSk7XG4gIH1cbn1cbi8qKlxuICogcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuICogLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuICogc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG4gKlxuICogQHBhcmFtIHsqfSB2XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNOdW1lcmljKHYpIHtcbiAgcmV0dXJuIHYgLSBwYXJzZUZsb2F0KHYpID49IDA7XG59XG5cbmV4cG9ydHMubGluZWFyTWFwID0gbGluZWFyTWFwO1xuZXhwb3J0cy5wYXJzZVBlcmNlbnQgPSBwYXJzZVBlcmNlbnQ7XG5leHBvcnRzLnJvdW5kID0gcm91bmQ7XG5leHBvcnRzLmFzYyA9IGFzYztcbmV4cG9ydHMuZ2V0UHJlY2lzaW9uID0gZ2V0UHJlY2lzaW9uO1xuZXhwb3J0cy5nZXRQcmVjaXNpb25TYWZlID0gZ2V0UHJlY2lzaW9uU2FmZTtcbmV4cG9ydHMuZ2V0UGl4ZWxQcmVjaXNpb24gPSBnZXRQaXhlbFByZWNpc2lvbjtcbmV4cG9ydHMuZ2V0UGVyY2VudFdpdGhQcmVjaXNpb24gPSBnZXRQZXJjZW50V2l0aFByZWNpc2lvbjtcbmV4cG9ydHMuTUFYX1NBRkVfSU5URUdFUiA9IE1BWF9TQUZFX0lOVEVHRVI7XG5leHBvcnRzLnJlbVJhZGlhbiA9IHJlbVJhZGlhbjtcbmV4cG9ydHMuaXNSYWRpYW5Bcm91bmRaZXJvID0gaXNSYWRpYW5Bcm91bmRaZXJvO1xuZXhwb3J0cy5wYXJzZURhdGUgPSBwYXJzZURhdGU7XG5leHBvcnRzLnF1YW50aXR5ID0gcXVhbnRpdHk7XG5leHBvcnRzLm5pY2UgPSBuaWNlO1xuZXhwb3J0cy5yZWZvcm1JbnRlcnZhbHMgPSByZWZvcm1JbnRlcnZhbHM7XG5leHBvcnRzLmlzTnVtZXJpYyA9IGlzTnVtZXJpYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL251bWJlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9udW1iZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi9ncmFwaGljXCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG4vLyBTeW1ib2wgZmFjdG9yeVxuXG4vKipcbiAqIFRyaWFuZ2xlIHNoYXBlXG4gKiBAaW5uZXJcbiAqL1xudmFyIFRyaWFuZ2xlID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gIHR5cGU6ICd0cmlhbmdsZScsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgdmFyIGN4ID0gc2hhcGUuY3g7XG4gICAgdmFyIGN5ID0gc2hhcGUuY3k7XG4gICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xuICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xuICAgIHBhdGgubW92ZVRvKGN4LCBjeSAtIGhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kgKyBoZWlnaHQpO1xuICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5ICsgaGVpZ2h0KTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59KTtcbi8qKlxuICogRGlhbW9uZCBzaGFwZVxuICogQGlubmVyXG4gKi9cblxudmFyIERpYW1vbmQgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgdHlwZTogJ2RpYW1vbmQnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xuICAgIHZhciBjeCA9IHNoYXBlLmN4O1xuICAgIHZhciBjeSA9IHNoYXBlLmN5O1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcbiAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcbiAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xuICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5KTtcbiAgICBwYXRoLmxpbmVUbyhjeCwgY3kgKyBoZWlnaHQpO1xuICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5KTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59KTtcbi8qKlxuICogUGluIHNoYXBlXG4gKiBAaW5uZXJcbiAqL1xuXG52YXIgUGluID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gIHR5cGU6ICdwaW4nLFxuICBzaGFwZToge1xuICAgIC8vIHgsIHkgb24gdGhlIGN1c3BcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS54O1xuICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICB2YXIgdyA9IHNoYXBlLndpZHRoIC8gNSAqIDM7IC8vIEhlaWdodCBtdXN0IGJlIGxhcmdlciB0aGFuIHdpZHRoXG5cbiAgICB2YXIgaCA9IE1hdGgubWF4KHcsIHNoYXBlLmhlaWdodCk7XG4gICAgdmFyIHIgPSB3IC8gMjsgLy8gRGlzdCBvbiB5IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxuXG4gICAgdmFyIGR5ID0gciAqIHIgLyAoaCAtIHIpO1xuICAgIHZhciBjeSA9IHkgLSBoICsgciArIGR5O1xuICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbihkeSAvIHIpOyAvLyBEaXN0IG9uIHggd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXG5cbiAgICB2YXIgZHggPSBNYXRoLmNvcyhhbmdsZSkgKiByO1xuICAgIHZhciB0YW5YID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciB0YW5ZID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciBjcExlbiA9IHIgKiAwLjY7XG4gICAgdmFyIGNwTGVuMiA9IHIgKiAwLjc7XG4gICAgcGF0aC5tb3ZlVG8oeCAtIGR4LCBjeSArIGR5KTtcbiAgICBwYXRoLmFyYyh4LCBjeSwgciwgTWF0aC5QSSAtIGFuZ2xlLCBNYXRoLlBJICogMiArIGFuZ2xlKTtcbiAgICBwYXRoLmJlemllckN1cnZlVG8oeCArIGR4IC0gdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLCB4LCB5IC0gY3BMZW4yLCB4LCB5KTtcbiAgICBwYXRoLmJlemllckN1cnZlVG8oeCwgeSAtIGNwTGVuMiwgeCAtIGR4ICsgdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLCB4IC0gZHgsIGN5ICsgZHkpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuLyoqXG4gKiBBcnJvdyBzaGFwZVxuICogQGlubmVyXG4gKi9cblxudmFyIEFycm93ID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gIHR5cGU6ICdhcnJvdycsXG4gIHNoYXBlOiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgdmFyIHkgPSBzaGFwZS55O1xuICAgIHZhciBkeCA9IHdpZHRoIC8gMyAqIDI7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjdHgubGluZVRvKHggKyBkeCwgeSArIGhlaWdodCk7XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgaGVpZ2h0IC8gNCAqIDMpO1xuICAgIGN0eC5saW5lVG8oeCAtIGR4LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG4vKipcbiAqIE1hcCBvZiBwYXRoIGNvbnRydWN0b3JzXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aD59XG4gKi9cblxudmFyIHN5bWJvbEN0b3JzID0ge1xuICBsaW5lOiBncmFwaGljLkxpbmUsXG4gIHJlY3Q6IGdyYXBoaWMuUmVjdCxcbiAgcm91bmRSZWN0OiBncmFwaGljLlJlY3QsXG4gIHNxdWFyZTogZ3JhcGhpYy5SZWN0LFxuICBjaXJjbGU6IGdyYXBoaWMuQ2lyY2xlLFxuICBkaWFtb25kOiBEaWFtb25kLFxuICBwaW46IFBpbixcbiAgYXJyb3c6IEFycm93LFxuICB0cmlhbmdsZTogVHJpYW5nbGVcbn07XG52YXIgc3ltYm9sU2hhcGVNYWtlcnMgPSB7XG4gIGxpbmU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIC8vIEZJWE1FXG4gICAgc2hhcGUueDEgPSB4O1xuICAgIHNoYXBlLnkxID0geSArIGggLyAyO1xuICAgIHNoYXBlLngyID0geCArIHc7XG4gICAgc2hhcGUueTIgPSB5ICsgaCAvIDI7XG4gIH0sXG4gIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLnggPSB4O1xuICAgIHNoYXBlLnkgPSB5O1xuICAgIHNoYXBlLndpZHRoID0gdztcbiAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICB9LFxuICByb3VuZFJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLnggPSB4O1xuICAgIHNoYXBlLnkgPSB5O1xuICAgIHNoYXBlLndpZHRoID0gdztcbiAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDQ7XG4gIH0sXG4gIHNxdWFyZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgdmFyIHNpemUgPSBNYXRoLm1pbih3LCBoKTtcbiAgICBzaGFwZS54ID0geDtcbiAgICBzaGFwZS55ID0geTtcbiAgICBzaGFwZS53aWR0aCA9IHNpemU7XG4gICAgc2hhcGUuaGVpZ2h0ID0gc2l6ZTtcbiAgfSxcbiAgY2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAvLyBQdXQgY2lyY2xlIGluIHRoZSBjZW50ZXIgb2Ygc3F1YXJlXG4gICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XG4gICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XG4gICAgc2hhcGUuciA9IE1hdGgubWluKHcsIGgpIC8gMjtcbiAgfSxcbiAgZGlhbW9uZDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XG4gICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XG4gICAgc2hhcGUud2lkdGggPSB3O1xuICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gIH0sXG4gIHBpbjogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgc2hhcGUueCA9IHggKyB3IC8gMjtcbiAgICBzaGFwZS55ID0geSArIGggLyAyO1xuICAgIHNoYXBlLndpZHRoID0gdztcbiAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICB9LFxuICBhcnJvdzogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgc2hhcGUueCA9IHggKyB3IC8gMjtcbiAgICBzaGFwZS55ID0geSArIGggLyAyO1xuICAgIHNoYXBlLndpZHRoID0gdztcbiAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICB9LFxuICB0cmlhbmdsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XG4gICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XG4gICAgc2hhcGUud2lkdGggPSB3O1xuICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gIH1cbn07XG52YXIgc3ltYm9sQnVpbGRQcm94aWVzID0ge307XG56clV0aWwuZWFjaChzeW1ib2xDdG9ycywgZnVuY3Rpb24gKEN0b3IsIG5hbWUpIHtcbiAgc3ltYm9sQnVpbGRQcm94aWVzW25hbWVdID0gbmV3IEN0b3IoKTtcbn0pO1xudmFyIFN5bWJvbENseiA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuICB0eXBlOiAnc3ltYm9sJyxcbiAgc2hhcGU6IHtcbiAgICBzeW1ib2xUeXBlOiAnJyxcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlOyAvLyBGSVhNRVxuXG4gICAgaWYgKHNoYXBlLnN5bWJvbFR5cGUgPT09ICdwaW4nICYmIHN0eWxlLnRleHRQb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcbiAgICAgIHN0eWxlLnRleHRQb3NpdGlvbiA9IFsnNTAlJywgJzQwJSddO1xuICAgICAgc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgIH1cbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcbiAgICB2YXIgc3ltYm9sVHlwZSA9IHNoYXBlLnN5bWJvbFR5cGU7XG4gICAgdmFyIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xuXG4gICAgaWYgKHNoYXBlLnN5bWJvbFR5cGUgIT09ICdub25lJykge1xuICAgICAgaWYgKCFwcm94eVN5bWJvbCkge1xuICAgICAgICAvLyBEZWZhdWx0IHJlY3RcbiAgICAgICAgc3ltYm9sVHlwZSA9ICdyZWN0JztcbiAgICAgICAgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XG4gICAgICB9XG5cbiAgICAgIHN5bWJvbFNoYXBlTWFrZXJzW3N5bWJvbFR5cGVdKHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQsIHByb3h5U3ltYm9sLnNoYXBlKTtcbiAgICAgIHByb3h5U3ltYm9sLmJ1aWxkUGF0aChjdHgsIHByb3h5U3ltYm9sLnNoYXBlLCBpbkJ1bmRsZSk7XG4gICAgfVxuICB9XG59KTsgLy8gUHJvdmlkZSBzZXRDb2xvciBoZWxwZXIgbWV0aG9kIHRvIGF2b2lkIGRldGVybWluZSBpZiBzZXQgdGhlIGZpbGwgb3Igc3Ryb2tlIG91dHNpZGVcblxuZnVuY3Rpb24gc3ltYm9sUGF0aFNldENvbG9yKGNvbG9yLCBpbm5lckNvbG9yKSB7XG4gIGlmICh0aGlzLnR5cGUgIT09ICdpbWFnZScpIHtcbiAgICB2YXIgc3ltYm9sU3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBzeW1ib2xTaGFwZSA9IHRoaXMuc2hhcGU7XG5cbiAgICBpZiAoc3ltYm9sU2hhcGUgJiYgc3ltYm9sU2hhcGUuc3ltYm9sVHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICBzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX19pc0VtcHR5QnJ1c2gpIHtcbiAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xuICAgICAgc3ltYm9sU3R5bGUuZmlsbCA9IGlubmVyQ29sb3IgfHwgJyNmZmYnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGSVhNRSDliKTmlq3lm77lvaLpu5jorqTmmK/loavlhYXov5jmmK/mj4/ovrnvvIzkvb/nlKggb25seVN0cm9rZSA/XG4gICAgICBzeW1ib2xTdHlsZS5maWxsICYmIChzeW1ib2xTdHlsZS5maWxsID0gY29sb3IpO1xuICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlICYmIChzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcik7XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgc3ltYm9sIGVsZW1lbnQgd2l0aCBnaXZlbiBzeW1ib2wgY29uZmlndXJhdGlvbjogc2hhcGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sVHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gd1xuICogQHBhcmFtIHtudW1iZXJ9IGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtib29sZWFufSBba2VlcEFzcGVjdD1mYWxzZV0gd2hldGhlciB0byBrZWVwIHRoZSByYXRpbyBvZiB3L2gsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgcGF0aCBhbmQgaW1hZ2Ugb25seS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCB4LCB5LCB3LCBoLCBjb2xvciwga2VlcEFzcGVjdCkge1xuICAvLyBUT0RPIFN1cHBvcnQgaW1hZ2Ugb2JqZWN0LCBEeW5hbWljSW1hZ2UuXG4gIHZhciBpc0VtcHR5ID0gc3ltYm9sVHlwZS5pbmRleE9mKCdlbXB0eScpID09PSAwO1xuXG4gIGlmIChpc0VtcHR5KSB7XG4gICAgc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGUuc3Vic3RyKDUsIDEpLnRvTG93ZXJDYXNlKCkgKyBzeW1ib2xUeXBlLnN1YnN0cig2KTtcbiAgfVxuXG4gIHZhciBzeW1ib2xQYXRoO1xuXG4gIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDApIHtcbiAgICBzeW1ib2xQYXRoID0gZ3JhcGhpYy5tYWtlSW1hZ2Uoc3ltYm9sVHlwZS5zbGljZSg4KSwgbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCB3LCBoKSwga2VlcEFzcGVjdCA/ICdjZW50ZXInIDogJ2NvdmVyJyk7XG4gIH0gZWxzZSBpZiAoc3ltYm9sVHlwZS5pbmRleE9mKCdwYXRoOi8vJykgPT09IDApIHtcbiAgICBzeW1ib2xQYXRoID0gZ3JhcGhpYy5tYWtlUGF0aChzeW1ib2xUeXBlLnNsaWNlKDcpLCB7fSwgbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCB3LCBoKSwga2VlcEFzcGVjdCA/ICdjZW50ZXInIDogJ2NvdmVyJyk7XG4gIH0gZWxzZSB7XG4gICAgc3ltYm9sUGF0aCA9IG5ldyBTeW1ib2xDbHooe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgc3ltYm9sVHlwZTogc3ltYm9sVHlwZSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgIGhlaWdodDogaFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3ltYm9sUGF0aC5fX2lzRW1wdHlCcnVzaCA9IGlzRW1wdHk7XG4gIHN5bWJvbFBhdGguc2V0Q29sb3IgPSBzeW1ib2xQYXRoU2V0Q29sb3I7XG4gIHN5bWJvbFBhdGguc2V0Q29sb3IoY29sb3IpO1xuICByZXR1cm4gc3ltYm9sUGF0aDtcbn1cblxuZXhwb3J0cy5jcmVhdGVTeW1ib2wgPSBjcmVhdGVTeW1ib2w7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvc3ltYm9sLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIE9SSUdJTl9NRVRIT0QgPSAnXFwwX190aHJvdHRsZU9yaWdpbk1ldGhvZCc7XG52YXIgUkFURSA9ICdcXDBfX3Rocm90dGxlUmF0ZSc7XG52YXIgVEhST1RUTEVfVFlQRSA9ICdcXDBfX3Rocm90dGxlVHlwZSc7XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7KEZ1bmN0aW9uKX0gZm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gVW5pdDogbXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWJvdW5jZT1mYWxzZV1cbiAqICAgICAgICB0cnVlOiBJZiBjYWxsIGludGVydmFsIGxlc3MgdGhhbiBgZGVsYXlgLCBvbmx5IHRoZSBsYXN0IGNhbGwgd29ya3MuXG4gKiAgICAgICAgZmFsc2U6IElmIGNhbGwgaW50ZXJ2YWwgbGVzcyB0aGFuIGBkZWxheSwgY2FsbCB3b3JrcyBvbiBmaXhlZCByYXRlLlxuICogQHJldHVybiB7KEZ1bmN0aW9uKX0gdGhyb3R0bGVkIGZuLlxuICovXG5cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBkZWxheSwgZGVib3VuY2UpIHtcbiAgdmFyIGN1cnJDYWxsO1xuICB2YXIgbGFzdENhbGwgPSAwO1xuICB2YXIgbGFzdEV4ZWMgPSAwO1xuICB2YXIgdGltZXIgPSBudWxsO1xuICB2YXIgZGlmZjtcbiAgdmFyIHNjb3BlO1xuICB2YXIgYXJncztcbiAgdmFyIGRlYm91bmNlTmV4dENhbGw7XG4gIGRlbGF5ID0gZGVsYXkgfHwgMDtcblxuICBmdW5jdGlvbiBleGVjKCkge1xuICAgIGxhc3RFeGVjID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGltZXIgPSBudWxsO1xuICAgIGZuLmFwcGx5KHNjb3BlLCBhcmdzIHx8IFtdKTtcbiAgfVxuXG4gIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyQ2FsbCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHNjb3BlID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciB0aGlzRGVsYXkgPSBkZWJvdW5jZU5leHRDYWxsIHx8IGRlbGF5O1xuICAgIHZhciB0aGlzRGVib3VuY2UgPSBkZWJvdW5jZU5leHRDYWxsIHx8IGRlYm91bmNlO1xuICAgIGRlYm91bmNlTmV4dENhbGwgPSBudWxsO1xuICAgIGRpZmYgPSBjdXJyQ2FsbCAtICh0aGlzRGVib3VuY2UgPyBsYXN0Q2FsbCA6IGxhc3RFeGVjKSAtIHRoaXNEZWxheTtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgaWYgKHRoaXNEZWJvdW5jZSkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIHRoaXNEZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaWZmID49IDApIHtcbiAgICAgICAgZXhlYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIC1kaWZmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0Q2FsbCA9IGN1cnJDYWxsO1xuICB9O1xuICAvKipcbiAgICogQ2xlYXIgdGhyb3R0bGUuXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICBjYi5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRW5hYmxlIGRlYm91bmNlIG9uY2UuXG4gICAqL1xuXG5cbiAgY2IuZGVib3VuY2VOZXh0Q2FsbCA9IGZ1bmN0aW9uIChkZWJvdW5jZURlbGF5KSB7XG4gICAgZGVib3VuY2VOZXh0Q2FsbCA9IGRlYm91bmNlRGVsYXk7XG4gIH07XG5cbiAgcmV0dXJuIGNiO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhyb3R0bGUgbWV0aG9kIG9yIHVwZGF0ZSB0aHJvdHRsZSByYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgLi4uXG4gKiAgICAgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUoXG4gKiAgICAgICAgIHRoaXMsXG4gKiAgICAgICAgICdfZGlzcGF0Y2hBY3Rpb24nLFxuICogICAgICAgICB0aGlzLm1vZGVsLmdldCgndGhyb3R0bGUnKSxcbiAqICAgICAgICAgJ2ZpeFJhdGUnXG4gKiAgICAgKTtcbiAqIH07XG4gKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaEFjdGlvbicpO1xuICogfTtcbiAqIENvbXBvbmVudFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaEFjdGlvbicpO1xuICogfTtcbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5BdHRyXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Rocm90dGxlVHlwZT0nZml4UmF0ZSddICdmaXhSYXRlJyBvciAnZGVib3VuY2UnXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUob2JqLCBmbkF0dHIsIHJhdGUsIHRocm90dGxlVHlwZSkge1xuICB2YXIgZm4gPSBvYmpbZm5BdHRyXTtcblxuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9yaWdpbkZuID0gZm5bT1JJR0lOX01FVEhPRF0gfHwgZm47XG4gIHZhciBsYXN0VGhyb3R0bGVUeXBlID0gZm5bVEhST1RUTEVfVFlQRV07XG4gIHZhciBsYXN0UmF0ZSA9IGZuW1JBVEVdO1xuXG4gIGlmIChsYXN0UmF0ZSAhPT0gcmF0ZSB8fCBsYXN0VGhyb3R0bGVUeXBlICE9PSB0aHJvdHRsZVR5cGUpIHtcbiAgICBpZiAocmF0ZSA9PSBudWxsIHx8ICF0aHJvdHRsZVR5cGUpIHtcbiAgICAgIHJldHVybiBvYmpbZm5BdHRyXSA9IG9yaWdpbkZuO1xuICAgIH1cblxuICAgIGZuID0gb2JqW2ZuQXR0cl0gPSB0aHJvdHRsZShvcmlnaW5GbiwgcmF0ZSwgdGhyb3R0bGVUeXBlID09PSAnZGVib3VuY2UnKTtcbiAgICBmbltPUklHSU5fTUVUSE9EXSA9IG9yaWdpbkZuO1xuICAgIGZuW1RIUk9UVExFX1RZUEVdID0gdGhyb3R0bGVUeXBlO1xuICAgIGZuW1JBVEVdID0gcmF0ZTtcbiAgfVxuXG4gIHJldHVybiBmbjtcbn1cbi8qKlxuICogQ2xlYXIgdGhyb3R0bGUuIEV4YW1wbGUgc2VlIHRocm90dGxlLmNyZWF0ZU9yVXBkYXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbkF0dHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsZWFyKG9iaiwgZm5BdHRyKSB7XG4gIHZhciBmbiA9IG9ialtmbkF0dHJdO1xuXG4gIGlmIChmbiAmJiBmbltPUklHSU5fTUVUSE9EXSkge1xuICAgIG9ialtmbkF0dHJdID0gZm5bT1JJR0lOX01FVEhPRF07XG4gIH1cbn1cblxuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xuZXhwb3J0cy5jcmVhdGVPclVwZGF0ZSA9IGNyZWF0ZU9yVXBkYXRlO1xuZXhwb3J0cy5jbGVhciA9IGNsZWFyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvdGhyb3R0bGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvdGhyb3R0bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIEdyb3VwID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cFwiKTtcblxudmFyIGNvbXBvbmVudFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9jb21wb25lbnRcIik7XG5cbnZhciBjbGF6elV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9jbGF6elwiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21vZGVsXCIpO1xuXG5mdW5jdGlvbiBDaGFydCgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuXG4gIHRoaXMudWlkID0gY29tcG9uZW50VXRpbC5nZXRVSUQoJ3ZpZXdDaGFydCcpO1xufVxuXG5DaGFydC5wcm90b3R5cGUgPSB7XG4gIHR5cGU6ICdjaGFydCcsXG5cbiAgLyoqXG4gICAqIEluaXQgdGhlIGNoYXJ0XG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge30sXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgY2hhcnRcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7fSxcblxuICAvKipcbiAgICogSGlnaGxpZ2h0IHNlcmllcyBvciBzcGVjaWZpZWQgZGF0YSBpdGVtXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgKi9cbiAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRvZ2dsZUhpZ2hsaWdodChzZXJpZXNNb2RlbC5nZXREYXRhKCksIHBheWxvYWQsICdlbXBoYXNpcycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEb3ducGxheSBzZXJpZXMgb3Igc3BlY2lmaWVkIGRhdGEgaXRlbVxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWRcbiAgICovXG4gIGRvd25wbGF5OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRvZ2dsZUhpZ2hsaWdodChzZXJpZXNNb2RlbC5nZXREYXRhKCksIHBheWxvYWQsICdub3JtYWwnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGZcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIHNlbGZcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxuICAvKipcbiAgICogVGhlIHZpZXcgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxuICAgKiBAaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICAvLyBjb250YWluUG9pbnQ6IGZ1bmN0aW9uICgpIHt9XG5cbn07XG52YXIgY2hhcnRQcm90byA9IENoYXJ0LnByb3RvdHlwZTtcblxuY2hhcnRQcm90by51cGRhdGVWaWV3ID0gY2hhcnRQcm90by51cGRhdGVMYXlvdXQgPSBjaGFydFByb3RvLnVwZGF0ZVZpc3VhbCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gIHRoaXMucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xufTtcbi8qKlxuICogU2V0IHN0YXRlIG9mIHNpbmdsZSBlbGVtZW50XG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICogQHBhcmFtICB7c3RyaW5nfSBzdGF0ZVxuICovXG5cblxuZnVuY3Rpb24gZWxTZXRTdGF0ZShlbCwgc3RhdGUpIHtcbiAgaWYgKGVsKSB7XG4gICAgZWwudHJpZ2dlcihzdGF0ZSk7XG5cbiAgICBpZiAoZWwudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5jaGlsZENvdW50KCk7IGkrKykge1xuICAgICAgICBlbFNldFN0YXRlKGVsLmNoaWxkQXQoaSksIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RhdGUgJ25vcm1hbCd8J2VtcGhhc2lzJ1xuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiB0b2dnbGVIaWdobGlnaHQoZGF0YSwgcGF5bG9hZCwgc3RhdGUpIHtcbiAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcblxuICBpZiAoZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICB6clV0aWwuZWFjaChtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShkYXRhSW5kZXgpLCBmdW5jdGlvbiAoZGF0YUlkeCkge1xuICAgICAgZWxTZXRTdGF0ZShkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUlkeCksIHN0YXRlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWxTZXRTdGF0ZShlbCwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59IC8vIEVuYWJsZSBDaGFydC5leHRlbmQuXG5cblxuY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKENoYXJ0LCBbJ2Rpc3Bvc2UnXSk7IC8vIEFkZCBjYXBhYmlsaXR5IG9mIHJlZ2lzdGVyQ2xhc3MsIGdldENsYXNzLCBoYXNDbGFzcywgcmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyIGFuZCBzbyBvbi5cblxuY2xhenpVdGlsLmVuYWJsZUNsYXNzTWFuYWdlbWVudChDaGFydCwge1xuICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcbn0pO1xudmFyIF9kZWZhdWx0ID0gQ2hhcnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ZpZXcvQ2hhcnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ZpZXcvQ2hhcnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgR3JvdXAgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwXCIpO1xuXG52YXIgY29tcG9uZW50VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbXBvbmVudFwiKTtcblxudmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2NsYXp6XCIpO1xuXG52YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKCk7XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgndmlld0NvbXBvbmVudCcpO1xufTtcblxuQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IENvbXBvbmVudCxcbiAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge30sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHt9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxufTtcbnZhciBjb21wb25lbnRQcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbmNvbXBvbmVudFByb3RvLnVwZGF0ZVZpZXcgPSBjb21wb25lbnRQcm90by51cGRhdGVMYXlvdXQgPSBjb21wb25lbnRQcm90by51cGRhdGVWaXN1YWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkgey8vIERvIG5vdGhpbmc7XG59OyAvLyBFbmFibGUgQ29tcG9uZW50LmV4dGVuZC5cblxuXG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoQ29tcG9uZW50KTsgLy8gRW5hYmxlIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuXG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KENvbXBvbmVudCwge1xuICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcbn0pO1xudmFyIF9kZWZhdWx0ID0gQ29tcG9uZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aWV3L0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlldy9Db21wb25lbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgR3JhZGllbnQgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudFwiKTtcblxuZnVuY3Rpb24gX2RlZmF1bHQoZWNNb2RlbCkge1xuICBmdW5jdGlvbiBlbmNvZGVDb2xvcihzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb2xvckFjY2Vzc1BhdGggPSAoc2VyaWVzTW9kZWwudmlzdWFsQ29sb3JBY2Nlc3NQYXRoIHx8ICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykuc3BsaXQoJy4nKTtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgY29sb3IgPSBzZXJpZXNNb2RlbC5nZXQoY29sb3JBY2Nlc3NQYXRoKSAvLyBTZXQgaW4gaXRlbVN0eWxlXG4gICAgfHwgc2VyaWVzTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShzZXJpZXNNb2RlbC5nZXQoJ25hbWUnKSk7IC8vIERlZmF1bHQgY29sb3JcbiAgICAvLyBGSVhNRSBTZXQgY29sb3IgZnVuY3Rpb24gb3IgdXNlIHRoZSBwbGF0dGUgY29sb3JcblxuICAgIGRhdGEuc2V0VmlzdWFsKCdjb2xvcicsIGNvbG9yKTsgLy8gT25seSB2aXNpYmxlIHNlcmllcyBoYXMgZWFjaCBkYXRhIGJlIHZpc3VhbCBlbmNvZGVkXG5cbiAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdmdW5jdGlvbicgJiYgIShjb2xvciBpbnN0YW5jZW9mIEdyYWRpZW50KSkge1xuICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicsIGNvbG9yKHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoaWR4KSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gaXRlbVN0eWxlIGluIGVhY2ggZGF0YSBpdGVtXG5cblxuICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgIHZhciBjb2xvciA9IGl0ZW1Nb2RlbC5nZXQoY29sb3JBY2Nlc3NQYXRoLCB0cnVlKTtcblxuICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzKGVuY29kZUNvbG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvc2VyaWVzQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Zpc3VhbC9zZXJpZXNDb2xvci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImZ1bmN0aW9uIF9kZWZhdWx0KHNlcmllc1R5cGUsIGRlZmF1bHRTeW1ib2xUeXBlLCBsZWdlbmRTeW1ib2wsIGVjTW9kZWwsIGFwaSkge1xuICAvLyBFbmNvZGluZyB2aXN1YWwgZm9yIGFsbCBzZXJpZXMgaW5jbHVkZSB3aGljaCBpcyBmaWx0ZXJlZCBmb3IgbGVnZW5kIGRyYXdpbmdcbiAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBzeW1ib2xUeXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdzeW1ib2wnKSB8fCBkZWZhdWx0U3ltYm9sVHlwZTtcbiAgICB2YXIgc3ltYm9sU2l6ZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuICAgIGRhdGEuc2V0VmlzdWFsKHtcbiAgICAgIGxlZ2VuZFN5bWJvbDogbGVnZW5kU3ltYm9sIHx8IHN5bWJvbFR5cGUsXG4gICAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgICBzeW1ib2xTaXplOiBzeW1ib2xTaXplXG4gICAgfSk7IC8vIE9ubHkgdmlzaWJsZSBzZXJpZXMgaGFzIGVhY2ggZGF0YSBiZSB2aXN1YWwgZW5jb2RlZFxuXG4gICAgaWYgKCFlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICBpZiAodHlwZW9mIHN5bWJvbFNpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICB2YXIgcmF3VmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpZHgpOyAvLyBGSVhNRVxuXG4gICAgICAgICAgdmFyIHBhcmFtcyA9IHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoaWR4KTtcbiAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScsIHN5bWJvbFNpemUocmF3VmFsdWUsIHBhcmFtcykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgIHZhciBpdGVtU3ltYm9sVHlwZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2wnLCB0cnVlKTtcbiAgICAgICAgdmFyIGl0ZW1TeW1ib2xTaXplID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFNpemUnLCB0cnVlKTsgLy8gSWYgaGFzIGl0ZW0gc3ltYm9sXG5cbiAgICAgICAgaWYgKGl0ZW1TeW1ib2xUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJywgaXRlbVN5bWJvbFR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1TeW1ib2xTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBQRU5ESU5HIFRyYW5zZm9ybSBzeW1ib2xTaXplID9cbiAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScsIGl0ZW1TeW1ib2xTaXplKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvc3ltYm9sLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uX20oMClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwid2VsY29tZVwiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHtcbiAgICAgICAgc3RhdGljU3R5bGU6IHsgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiNTAwcHhcIiB9LFxuICAgICAgICBhdHRyczogeyBpZDogXCJvcmRlcl9pbnRvXCIgfVxuICAgICAgfSlcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbm1vZHVsZS5leHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi1hMGZhY2VkZVwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYTBmYWNlZGVcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvaW5kZXgvd2VsY29tZS52dWVcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4LmpzP3tcImlkXCI6XCJkYXRhLXYtYTBmYWNlZGVcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvaW5kZXgvd2VsY29tZS52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgVHJhbnNmb3JtYWJsZSA9IHJlcXVpcmUoXCIuL21peGluL1RyYW5zZm9ybWFibGVcIik7XG5cbnZhciBBbmltYXRhYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vQW5pbWF0YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfVxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICovXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBUcmFuc2Zvcm1hYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gIEFuaW1hdGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgLyoqXG4gICAqIOeUu+W4g+WFg+e0oElEXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuaWQgPSBvcHRzLmlkIHx8IGd1aWQoKTtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlID0ge1xuICAvKipcbiAgICog5YWD57Sg57G75Z6LXG4gICAqIEVsZW1lbnQgdHlwZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ2VsZW1lbnQnLFxuXG4gIC8qKlxuICAgKiDlhYPntKDlkI3lrZdcbiAgICogRWxlbWVudCBuYW1lXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBuYW1lOiAnJyxcblxuICAvKipcbiAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICogWlJlbmRlciBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHdoZW4gZWxlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGggenJlbmRlclxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNfX3pyXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgKi9cbiAgX196cjogbnVsbCxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5b+955Wl77yM5Li6dHJ1ZeaXtuW/veeVpeWbvuW9oueahOe7mOWItuS7peWPiuS6i+S7tuinpuWPkVxuICAgKiBJZiBpZ25vcmUgZHJhd2luZyBhbmQgZXZlbnRzIG9mIHRoZSBlbGVtZW50IG9iamVjdFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpZ25vcmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgKiDor6Xot6/lvoTkvJrnu6fmib/ooqvoo4Hlh4/lr7nosaHnmoTlj5jmjaJcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH1cbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGNsaXBQYXRoOiBudWxsLFxuXG4gIC8qKlxuICAgKiBEcmlmdCBlbGVtZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gZHggZHggb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IGR5IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICovXG4gIGRyaWZ0OiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgc3dpdGNoICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgIGR5ID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgZHggPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gICAgaWYgKCFtKSB7XG4gICAgICBtID0gdGhpcy50cmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgfVxuXG4gICAgbVs0XSArPSBkeDtcbiAgICBtWzVdICs9IGR5O1xuICAgIHRoaXMuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhvb2sgYmVmb3JlIHVwZGF0ZVxuICAgKi9cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICogSG9vayBhZnRlciB1cGRhdGVcbiAgICovXG4gIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICogVXBkYXRlIGVhY2ggZnJhbWVcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge30sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nIHx8IGtleSA9PT0gJ3NjYWxlJyB8fCBrZXkgPT09ICdvcmlnaW4nKSB7XG4gICAgICAvLyBDb3B5IHRoZSBhcnJheVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXQgPSB0aGlzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFswXSA9IHZhbHVlWzBdO1xuICAgICAgICB0YXJnZXRbMV0gPSB2YWx1ZVsxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBlbGVtZW50XG4gICAqL1xuICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pZ25vcmUgPSB0cnVlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBlbGVtZW50XG4gICAqL1xuICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pZ25vcmUgPSBmYWxzZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgYXR0cjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuYXR0cktWKGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmF0dHJLVihuYW1lLCBrZXlbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBjbGlwUGF0aFxuICAgKi9cbiAgc2V0Q2xpcFBhdGg6IGZ1bmN0aW9uIChjbGlwUGF0aCkge1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcblxuICAgIGlmICh6cikge1xuICAgICAgY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgIH0gLy8gUmVtb3ZlIHByZXZpb3VzIGNsaXAgcGF0aFxuXG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCAmJiB0aGlzLmNsaXBQYXRoICE9PSBjbGlwUGF0aCkge1xuICAgICAgdGhpcy5yZW1vdmVDbGlwUGF0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICBjbGlwUGF0aC5fX3pyID0genI7XG4gICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gdGhpcztcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICovXG4gIHJlbW92ZUNsaXBQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aDtcblxuICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgaWYgKGNsaXBQYXRoLl9fenIpIHtcbiAgICAgICAgY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acihjbGlwUGF0aC5fX3pyKTtcbiAgICAgIH1cblxuICAgICAgY2xpcFBhdGguX196ciA9IG51bGw7XG4gICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5jbGlwUGF0aCA9IG51bGw7XG4gICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAqL1xuICBhZGRTZWxmVG9acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgdGhpcy5fX3pyID0genI7IC8vIOa3u+WKoOWKqOeUu1xuXG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuXG4gICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMuY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICovXG4gIHJlbW92ZVNlbGZGcm9tWnI6IGZ1bmN0aW9uICh6cikge1xuICAgIHRoaXMuX196ciA9IG51bGw7IC8vIOenu+mZpOWKqOeUu1xuXG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuXG4gICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgenIuYW5pbWF0aW9uLnJlbW92ZUFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMuY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acih6cik7XG4gICAgfVxuICB9XG59O1xuenJVdGlsLm1peGluKEVsZW1lbnQsIEFuaW1hdGFibGUpO1xuenJVdGlsLm1peGluKEVsZW1lbnQsIFRyYW5zZm9ybWFibGUpO1xuenJVdGlsLm1peGluKEVsZW1lbnQsIEV2ZW50ZnVsKTtcbnZhciBfZGVmYXVsdCA9IEVsZW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0VsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0VsZW1lbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoXCIuL21peGluL0RyYWdnYWJsZVwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbi8qKlxuICogSGFuZGxlclxuICogQG1vZHVsZSB6cmVuZGVyL0hhbmRsZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChzaGVueWkuOTE0QGdtYWlsLmNvbSlcbiAqL1xudmFyIFNJTEVOVCA9ICdzaWxlbnQnO1xuXG5mdW5jdGlvbiBtYWtlRXZlbnRQYWNrZXQoZXZlVHlwZSwgdGFyZ2V0SW5mbywgZXZlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBldmVUeXBlLFxuICAgIGV2ZW50OiBldmVudCxcbiAgICAvLyB0YXJnZXQgY2FuIG9ubHkgYmUgYW4gZWxlbWVudCB0aGF0IGlzIG5vdCBzaWxlbnQuXG4gICAgdGFyZ2V0OiB0YXJnZXRJbmZvLnRhcmdldCxcbiAgICAvLyB0b3BUYXJnZXQgY2FuIGJlIGEgc2lsZW50IGVsZW1lbnQuXG4gICAgdG9wVGFyZ2V0OiB0YXJnZXRJbmZvLnRvcFRhcmdldCxcbiAgICBjYW5jZWxCdWJibGU6IGZhbHNlLFxuICAgIG9mZnNldFg6IGV2ZW50LnpyWCxcbiAgICBvZmZzZXRZOiBldmVudC56clksXG4gICAgZ2VzdHVyZUV2ZW50OiBldmVudC5nZXN0dXJlRXZlbnQsXG4gICAgcGluY2hYOiBldmVudC5waW5jaFgsXG4gICAgcGluY2hZOiBldmVudC5waW5jaFksXG4gICAgcGluY2hTY2FsZTogZXZlbnQucGluY2hTY2FsZSxcbiAgICB3aGVlbERlbHRhOiBldmVudC56ckRlbHRhLFxuICAgIHpyQnlUb3VjaDogZXZlbnQuenJCeVRvdWNoLFxuICAgIHdoaWNoOiBldmVudC53aGljaFxuICB9O1xufVxuXG5mdW5jdGlvbiBFbXB0eVByb3h5KCkge31cblxuRW1wdHlQcm94eS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgaGFuZGxlck5hbWVzID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSddO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvSGFuZGxlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlIFN0b3JhZ2UgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZG9tL0hhbmRsZXJQcm94eX0gcHJveHkgSGFuZGxlclByb3h5IGluc3RhbmNlLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFpbnRlclJvb3QgcGFpbnRlci5yb290IChub3QgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkuXG4gKi9cblxudmFyIEhhbmRsZXIgPSBmdW5jdGlvbiAoc3RvcmFnZSwgcGFpbnRlciwgcHJveHksIHBhaW50ZXJSb290KSB7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHRoaXMucGFpbnRlclJvb3QgPSBwYWludGVyUm9vdDtcbiAgcHJveHkgPSBwcm94eSB8fCBuZXcgRW1wdHlQcm94eSgpO1xuICAvKipcbiAgICogUHJveHkgb2YgZXZlbnQuIGNhbiBiZSBEb20sIFdlYkdMU3VyZmFjZSwgZXRjLlxuICAgKi9cblxuICB0aGlzLnByb3h5ID0gcHJveHk7IC8vIEF0dGFjaCBoYW5kbGVyXG5cbiAgcHJveHkuaGFuZGxlciA9IHRoaXM7XG4gIC8qKlxuICAgKiB7dGFyZ2V0LCB0b3BUYXJnZXQsIHgsIHl9XG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX2hvdmVyZWQgPSB7fTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKi9cblxuICB0aGlzLl9sYXN0VG91Y2hNb21lbnQ7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl9sYXN0WDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RZO1xuICBEcmFnZ2FibGUuY2FsbCh0aGlzKTtcbiAgdXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBwcm94eS5vbiAmJiBwcm94eS5vbihuYW1lLCB0aGlzW25hbWVdLCB0aGlzKTtcbiAgfSwgdGhpcyk7XG59O1xuXG5IYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEhhbmRsZXIsXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHggPSBldmVudC56clg7XG4gICAgdmFyIHkgPSBldmVudC56clk7XG4gICAgdmFyIGxhc3RIb3ZlcmVkID0gdGhpcy5faG92ZXJlZDtcbiAgICB2YXIgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7IC8vIElmIGxhc3RIb3ZlcmVkVGFyZ2V0IGlzIHJlbW92ZWQgZnJvbSB6ciAoZGV0ZWN0ZWQgYnkgJ19fenInKSBieSBzb21lIEFQSSBjYWxsXG4gICAgLy8gKGxpa2UgJ3NldE9wdGlvbicgb3IgJ2Rpc3BhdGNoQWN0aW9uJykgaW4gZXZlbnQgaGFuZGxlcnMsIHdlIHNob3VsZCBmaW5kXG4gICAgLy8gbGFzdEhvdmVyZWQgYWdhaW4gaGVyZS4gT3RoZXJ3aXNlICdtb3VzZW91dCcgY2FuIG5vdCBiZSB0cmlnZ2VyZWQgbm9ybWFsbHkuXG4gICAgLy8gU2VlICM2MTk4LlxuXG4gICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmICFsYXN0SG92ZXJlZFRhcmdldC5fX3pyKSB7XG4gICAgICBsYXN0SG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGxhc3RIb3ZlcmVkLngsIGxhc3RIb3ZlcmVkLnkpO1xuICAgICAgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoeCwgeSk7XG4gICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcbiAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoaG92ZXJlZFRhcmdldCA/IGhvdmVyZWRUYXJnZXQuY3Vyc29yIDogJ2RlZmF1bHQnKTsgLy8gTW91c2Ugb3V0IG9uIHByZXZpb3VzIGhvdmVyZWQgZWxlbWVudFxuXG4gICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGxhc3RIb3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgfSAvLyBNb3VzZSBtb3Zpbmcgb24gb25lIGVsZW1lbnRcblxuXG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2Vtb3ZlJywgZXZlbnQpOyAvLyBNb3VzZSBvdmVyIG9uIGEgbmV3IGVsZW1lbnRcblxuICAgIGlmIChob3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9ob3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7IC8vIFRoZXJlIG1pZ2h0IGJlIHNvbWUgZG9tcyBjcmVhdGVkIGJ5IHVwcGVyIGxheWVyIGFwcGxpY2F0aW9uXG4gICAgLy8gYXQgdGhlIHNhbWUgbGV2ZWwgb2YgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSAoZS5nLiwgdG9vbHRpcFxuICAgIC8vIGRvbSBjcmVhdGVkIGJ5IGVjaGFydHMpLCB3aGVyZSAnZ2xvYmFsb3V0JyBldmVudCBzaG91bGQgbm90XG4gICAgLy8gYmUgdHJpZ2dlcmVkIHdoZW4gbW91c2UgZW50ZXJzIHRoZXNlIGRvbXMuIChCdXQgJ21vdXNlb3V0J1xuICAgIC8vIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQgdGhlIG9yaWdpbmFsIGhvdmVyZWQgZWxlbWVudCBhcyB1c3VhbCkuXG5cbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIHZhciBpbm5lckRvbTtcblxuICAgIGRvIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSAmJiAhKGlubmVyRG9tID0gZWxlbWVudCA9PT0gdGhpcy5wYWludGVyUm9vdCkpO1xuXG4gICAgIWlubmVyRG9tICYmIHRoaXMudHJpZ2dlcignZ2xvYmFsb3V0Jywge1xuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9ob3ZlcmVkID0ge307XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtldmVudD19IGV2ZW50QXJnc1xuICAgKi9cbiAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJncykge1xuICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50QXJncyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3Bvc2VcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLnN0b3JhZ2UgPSB0aGlzLnByb3h5ID0gdGhpcy5wYWludGVyID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAqL1xuICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGN1cnNvclN0eWxlKTtcbiAgfSxcblxuICAvKipcbiAgICog5LqL5Lu25YiG5Y+R5Luj55CGXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRJbmZvIHt0YXJnZXQsIHRvcFRhcmdldH0g55uu5qCH5Zu+5b2i5YWD57SgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCN56ewXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAgICovXG4gIGRpc3BhdGNoVG9FbGVtZW50OiBmdW5jdGlvbiAodGFyZ2V0SW5mbywgZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRhcmdldEluZm8gPSB0YXJnZXRJbmZvIHx8IHt9O1xuICAgIHZhciBlbCA9IHRhcmdldEluZm8udGFyZ2V0O1xuXG4gICAgaWYgKGVsICYmIGVsLnNpbGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBldmVudEhhbmRsZXIgPSAnb24nICsgZXZlbnROYW1lO1xuICAgIHZhciBldmVudFBhY2tldCA9IG1ha2VFdmVudFBhY2tldChldmVudE5hbWUsIHRhcmdldEluZm8sIGV2ZW50KTtcblxuICAgIHdoaWxlIChlbCkge1xuICAgICAgZWxbZXZlbnRIYW5kbGVyXSAmJiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlID0gZWxbZXZlbnRIYW5kbGVyXS5jYWxsKGVsLCBldmVudFBhY2tldCkpO1xuICAgICAgZWwudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgIGVsID0gZWwucGFyZW50O1xuXG4gICAgICBpZiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAvLyDlhpLms6HliLDpobbnuqcgenJlbmRlciDlr7nosaFcbiAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTsgLy8g5YiG5Y+R5LqL5Lu25Yiw55So5oi36Ieq5a6a5LmJ5bGCXG4gICAgICAvLyDnlKjmiLfmnInlj6/og73lnKjlhajlsYAgY2xpY2sg5LqL5Lu25LitIGRpc3Bvc2XvvIzmiYDku6XpnIDopoHliKTmlq3kuIsgcGFpbnRlciDmmK/lkKblrZjlnKhcblxuICAgICAgdGhpcy5wYWludGVyICYmIHRoaXMucGFpbnRlci5lYWNoT3RoZXJMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsYXllcltldmVudEhhbmRsZXJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBsYXllcltldmVudEhhbmRsZXJdLmNhbGwobGF5ZXIsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9IGV4Y2x1ZGVcbiAgICogQHJldHVybiB7bW9kZWw6enJlbmRlci9FbGVtZW50fVxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBmaW5kSG92ZXI6IGZ1bmN0aW9uICh4LCB5LCBleGNsdWRlKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgICB2YXIgb3V0ID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBob3ZlckNoZWNrUmVzdWx0O1xuXG4gICAgICBpZiAobGlzdFtpXSAhPT0gZXhjbHVkZSAvLyBnZXREaXNwbGF5TGlzdCBtYXkgaW5jbHVkZSBpZ25vcmVkIGl0ZW0gaW4gVk1MIG1vZGVcbiAgICAgICYmICFsaXN0W2ldLmlnbm9yZSAmJiAoaG92ZXJDaGVja1Jlc3VsdCA9IGlzSG92ZXIobGlzdFtpXSwgeCwgeSkpKSB7XG4gICAgICAgICFvdXQudG9wVGFyZ2V0ICYmIChvdXQudG9wVGFyZ2V0ID0gbGlzdFtpXSk7XG5cbiAgICAgICAgaWYgKGhvdmVyQ2hlY2tSZXN1bHQgIT09IFNJTEVOVCkge1xuICAgICAgICAgIG91dC50YXJnZXQgPSBsaXN0W2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxufTsgLy8gQ29tbW9uIGhhbmRsZXJzXG5cbnV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBGaW5kIGhvdmVyIGFnYWluIHRvIGF2b2lkIGNsaWNrIGV2ZW50IGlzIGRpc3BhdGNoZWQgbWFudWFsbHkuIE9yIGNsaWNrIGlzIHRyaWdnZXJlZCB3aXRob3V0IG1vdXNlb3ZlclxuICAgIHZhciBob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clkpO1xuICAgIHZhciBob3ZlcmVkVGFyZ2V0ID0gaG92ZXJlZC50YXJnZXQ7XG5cbiAgICBpZiAobmFtZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgIHRoaXMuX2Rvd25FbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgICB0aGlzLl9kb3duUG9pbnQgPSBbZXZlbnQuenJYLCBldmVudC56clldOyAvLyBJbiBjYXNlIGNsaWNrIHRyaWdnZXJlZCBiZWZvcmUgbW91c2V1cFxuXG4gICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdtb3N1ZXVwJykge1xuICAgICAgdGhpcy5fdXBFbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBpZiAodGhpcy5fZG93bkVsICE9PSB0aGlzLl91cEVsIC8vIE9yaWdpbmFsIGNsaWNrIGV2ZW50IGlzIHRyaWdnZXJlZCBvbiB0aGUgd2hvbGUgY2FudmFzIGVsZW1lbnQsXG4gICAgICAvLyBpbmNsdWRpbmcgdGhlIGNhc2UgdGhhdCBgbW91c2Vkb3duYCAtIGBtb3VzZW1vdmVgIC0gYG1vdXNldXBgLFxuICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIGZpbHRlcmVkLCBvdGhlcndpc2UgaXQgd2lsbCBicmluZyB0cm91YmxlIHRvXG4gICAgICAvLyBwYW4gYW5kIHpvb20uXG4gICAgICB8fCAhdGhpcy5fZG93blBvaW50IC8vIEFyYml0cmFyeSB2YWx1ZVxuICAgICAgfHwgdmVjMi5kaXN0KHRoaXMuX2Rvd25Qb2ludCwgW2V2ZW50LnpyWCwgZXZlbnQuenJZXSkgPiA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG93blBvaW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsIG5hbWUsIGV2ZW50KTtcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gIGlmIChkaXNwbGF5YWJsZVtkaXNwbGF5YWJsZS5yZWN0SG92ZXIgPyAncmVjdENvbnRhaW4nIDogJ2NvbnRhaW4nXSh4LCB5KSkge1xuICAgIHZhciBlbCA9IGRpc3BsYXlhYmxlO1xuICAgIHZhciBpc1NpbGVudDtcblxuICAgIHdoaWxlIChlbCkge1xuICAgICAgLy8gSWYgY2xpcHBlZCBieSBhbmNlc3Rvci5cbiAgICAgIC8vIEZJWE1FOiBJZiBjbGlwUGF0aCBoYXMgbmVpdGhlciBzdHJva2Ugbm9yIGZpbGwsXG4gICAgICAvLyBlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICAgIGlmIChlbC5jbGlwUGF0aCAmJiAhZWwuY2xpcFBhdGguY29udGFpbih4LCB5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5zaWxlbnQpIHtcbiAgICAgICAgaXNTaWxlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNTaWxlbnQgPyBTSUxFTlQgOiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG51dGlsLm1peGluKEhhbmRsZXIsIEV2ZW50ZnVsKTtcbnV0aWwubWl4aW4oSGFuZGxlciwgRHJhZ2dhYmxlKTtcbnZhciBfZGVmYXVsdCA9IEhhbmRsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5cbnZhciBkZXZpY2VQaXhlbFJhdGlvID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9ncmFwaGljL1N0eWxlXCIpO1xuXG52YXIgUGF0dGVybiA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvUGF0dGVyblwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvTGF5ZXJcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIOWIm+W7umRvbVxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtzdHJpbmd9IGlkIGRvbSBpZCDlvoXnlKhcbiAqIEBwYXJhbSB7UGFpbnRlcn0gcGFpbnRlciBwYWludGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVEb20oaWQsIHBhaW50ZXIsIGRwcikge1xuICB2YXIgbmV3RG9tID0gdXRpbC5jcmVhdGVDYW52YXMoKTtcbiAgdmFyIHdpZHRoID0gcGFpbnRlci5nZXRXaWR0aCgpO1xuICB2YXIgaGVpZ2h0ID0gcGFpbnRlci5nZXRIZWlnaHQoKTtcbiAgdmFyIG5ld0RvbVN0eWxlID0gbmV3RG9tLnN0eWxlOyAvLyDmsqFhcHBlbmTlkaLvvIzor7fljp/osIXmiJHov5nmoLflhpnvvIzmuIXmmbB+XG5cbiAgbmV3RG9tU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBuZXdEb21TdHlsZS5sZWZ0ID0gMDtcbiAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgbmV3RG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIG5ld0RvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIG5ld0RvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICBuZXdEb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByOyAvLyBpZOS4jeS9nOS4uue0ouW8leeUqO+8jOmBv+WFjeWPr+iDvemAoOaIkOeahOmHjeWQje+8jOWumuS5ieS4uuengeacieWxnuaAp1xuXG4gIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICByZXR1cm4gbmV3RG9tO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvTGF5ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHByXVxuICovXG5cblxudmFyIExheWVyID0gZnVuY3Rpb24gKGlkLCBwYWludGVyLCBkcHIpIHtcbiAgdmFyIGRvbTtcbiAgZHByID0gZHByIHx8IGRldmljZVBpeGVsUmF0aW87XG5cbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICBkb20gPSBjcmVhdGVEb20oaWQsIHBhaW50ZXIsIGRwcik7XG4gIH0gLy8gTm90IHVzaW5nIGlzRG9tIGJlY2F1c2UgaW4gbm9kZSBpdCB3aWxsIHJldHVybiBmYWxzZVxuICBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGlkKSkge1xuICAgICAgZG9tID0gaWQ7XG4gICAgICBpZCA9IGRvbS5pZDtcbiAgICB9XG5cbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmRvbSA9IGRvbTtcbiAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuXG4gIGlmIChkb21TdHlsZSkge1xuICAgIC8vIE5vdCBpbiBub2RlXG4gICAgZG9tLm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG5cbiAgICBkb21TdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gJ25vbmUnO1xuICAgIGRvbVN0eWxlWyd1c2VyLXNlbGVjdCddID0gJ25vbmUnO1xuICAgIGRvbVN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgZG9tU3R5bGVbJ3BhZGRpbmcnXSA9IDA7XG4gICAgZG9tU3R5bGVbJ21hcmdpbiddID0gMDtcbiAgICBkb21TdHlsZVsnYm9yZGVyLXdpZHRoJ10gPSAwO1xuICB9XG5cbiAgdGhpcy5kb21CYWNrID0gbnVsbDtcbiAgdGhpcy5jdHhCYWNrID0gbnVsbDtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdGhpcy5jb25maWcgPSBudWxsOyAvLyBDb25maWdzXG5cbiAgLyoqXG4gICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuXG4gIHRoaXMuY2xlYXJDb2xvciA9IDA7XG4gIC8qKlxuICAgKiDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuXG4gIHRoaXMubW90aW9uQmx1ciA9IGZhbHNlO1xuICAvKipcbiAgICog5Zyo5byA5ZCv5Yqo5oCB5qih57OK55qE5pe25YCZ5L2/55So77yM5LiO5LiK5LiA5bin5re35ZCI55qEYWxwaGHlgLzvvIzlgLzotorlpKflsL7ov7notormmI7mmL5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMC43XG4gICAqL1xuXG4gIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG4gIC8qKlxuICAgKiBMYXllciBkcHJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5kcHIgPSBkcHI7XG59O1xuXG5MYXllci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMYXllcixcbiAgZWxDb3VudDogMCxcbiAgX19kaXJ0eTogdHJ1ZSxcbiAgaW5pdENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmN0eCA9IHRoaXMuZG9tLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy5jdHguX19jdXJyZW50VmFsdWVzID0ge307XG4gICAgdGhpcy5jdHguZHByID0gdGhpcy5kcHI7XG4gIH0sXG4gIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgdGhpcy5kb21CYWNrID0gY3JlYXRlRG9tKCdiYWNrLScgKyB0aGlzLmlkLCB0aGlzLnBhaW50ZXIsIGRwcik7XG4gICAgdGhpcy5jdHhCYWNrID0gdGhpcy5kb21CYWNrLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy5jdHhCYWNrLl9fY3VycmVudFZhbHVlcyA9IHt9O1xuXG4gICAgaWYgKGRwciAhPSAxKSB7XG4gICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuICAgIGRvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGRvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgZG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgIGlmIChkb21CYWNrKSB7XG4gICAgICBkb21CYWNrLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICBkb21CYWNrLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgaWYgKGRwciAhPSAxKSB7XG4gICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXnqbror6XlsYLnlLvluINcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhckFsbCBDbGVhciBhbGwgd2l0aCBvdXQgbW90aW9uIGJsdXJcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoY2xlYXJBbGwpIHtcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgIHZhciB3aWR0aCA9IGRvbS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcbiAgICB2YXIgY2xlYXJDb2xvciA9IHRoaXMuY2xlYXJDb2xvcjtcbiAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgIHZhciBsYXN0RnJhbWVBbHBoYSA9IHRoaXMubGFzdEZyYW1lQWxwaGE7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHhCYWNrLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoZG9tLCAwLCAwLCB3aWR0aCAvIGRwciwgaGVpZ2h0IC8gZHByKTtcbiAgICB9XG5cbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYgKGNsZWFyQ29sb3IpIHtcbiAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47IC8vIEdyYWRpZW50XG5cbiAgICAgIGlmIChjbGVhckNvbG9yLmNvbG9yU3RvcHMpIHtcbiAgICAgICAgLy8gQ2FjaGUgY2FudmFzIGdyYWRpZW50XG4gICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCB8fCBTdHlsZS5nZXRHcmFkaWVudChjdHgsIGNsZWFyQ29sb3IsIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICB9IC8vIFBhdHRlcm5cbiAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuLmNhbGwoY2xlYXJDb2xvciwgY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgY3R4LmRyYXdJbWFnZShkb21CYWNrLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gTGF5ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0xheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9MYXllci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBsb2cgPSByZXF1aXJlKFwiLi9jb3JlL2xvZ1wiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCIuL2NvcmUvdGltc29ydFwiKTtcblxudmFyIExheWVyID0gcmVxdWlyZShcIi4vTGF5ZXJcIik7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgSW1hZ2UgPSByZXF1aXJlKFwiLi9ncmFwaGljL0ltYWdlXCIpO1xuXG4vKipcbiAqIERlZmF1bHQgY2FudmFzIHBhaW50ZXJcbiAqIEBtb2R1bGUgenJlbmRlci9QYWludGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBQRU5ESUdOXG4vLyBMYXllciBleGNlZWRzIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgbWF5IGhhdmUgc29tZSBwcm9ibGVtIHdoZW4gZmx1c2ggZGlyZWN0bHkgc2Vjb25kIHRpbWUuXG4vL1xuLy8gTWF4aW11bSBwcm9ncmVzc2l2ZSBsYXllci4gV2hlbiBleGNlZWRpbmcgdGhpcyBudW1iZXIuIEFsbCBlbGVtZW50cyB3aWxsIGJlIGRyYXdlZCBpbiB0aGUgbGFzdCBsYXllci5cbnZhciBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSID0gNTtcblxuZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0xheWVyVmFsaWQobGF5ZXIpIHtcbiAgaWYgKCFsYXllcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsYXllci5yZXNpemUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGxheWVyLnJlZnJlc2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJlUHJvY2Vzc0xheWVyKGxheWVyKSB7XG4gIGxheWVyLl9fdW51c2VkQ291bnQrKztcbn1cblxuZnVuY3Rpb24gcG9zdFByb2Nlc3NMYXllcihsYXllcikge1xuICBpZiAobGF5ZXIuX191bnVzZWRDb3VudCA9PSAxKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfVxufVxuXG52YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG52YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuXG5mdW5jdGlvbiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRtcFJlY3QuY29weShlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cbiAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgcHJldkNsaXBQYXRocykge1xuICBpZiAoY2xpcFBhdGhzID09IHByZXZDbGlwUGF0aHMpIHtcbiAgICAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghY2xpcFBhdGhzIHx8ICFwcmV2Q2xpcFBhdGhzIHx8IGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgY2xpcFBhdGguc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICBjdHguY2xpcCgpOyAvLyBUcmFuc2Zvcm0gYmFja1xuXG4gICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3Qod2lkdGgsIGhlaWdodCkge1xuICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBkb21Sb290Lm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG5cbiAgZG9tUm9vdC5zdHlsZS5jc3NUZXh0ID0gWydwb3NpdGlvbjpyZWxhdGl2ZScsICdvdmVyZmxvdzpoaWRkZW4nLCAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JywgJ2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4JywgJ3BhZGRpbmc6MCcsICdtYXJnaW46MCcsICdib3JkZXItd2lkdGg6MCddLmpvaW4oJzsnKSArICc7JztcbiAgcmV0dXJuIGRvbVJvb3Q7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3Qg57uY5Zu+5a655ZmoXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuXG52YXIgUGFpbnRlciA9IGZ1bmN0aW9uIChyb290LCBzdG9yYWdlLCBvcHRzKSB7XG4gIHRoaXMudHlwZSA9ICdjYW52YXMnOyAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG5cbiAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBvcHRzIHx8IHt9KTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGRldmljZVBpeGVsUmF0aW87XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAvKipcbiAgICog57uY5Zu+5a655ZmoXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgaWYgKHJvb3RTdHlsZSkge1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICByb290LmlubmVySFRNTCA9ICcnO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICovXG5cblxuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvTGF5ZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XG4gICAqIEB0eXBlIHtwcml2YXRlfVxuICAgKi9cblxuICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuXG4gIGlmICghc2luZ2xlQ2FudmFzKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290ID0gY3JlYXRlUm9vdCh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRzLndpZHRoICE9IG51bGwpIHtcbiAgICAgIHJvb3Qud2lkdGggPSBvcHRzLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICByb290LmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgIH0gLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG5cblxuICAgIHZhciB3aWR0aCA9IHJvb3Qud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0OyAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuXG4gICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICBtYWluTGF5ZXIuaW5pdENvbnRleHQoKTsgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgLy8gbWFpbkxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGxheWVyc1swXSA9IG1haW5MYXllcjtcbiAgICB6bGV2ZWxMaXN0LnB1c2goMCk7XG4gICAgdGhpcy5fZG9tUm9vdCA9IHJvb3Q7XG4gIH0gLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcblxuXG4gIHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2hvdmVybGF5ZXI7XG4gIHRoaXMuX2hvdmVyRWxlbWVudHMgPSBbXTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnY2FudmFzJztcbiAgfSxcblxuICAvKipcbiAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbVJvb3Q7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliLfmlrBcbiAgICogQHBhcmFtIHtib29sZWFufSBbcGFpbnRBbGw9ZmFsc2VdIOW8uuWItue7mOWItuaJgOaciWRpc3BsYXlhYmxlXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAocGFpbnRBbGwpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCwgcGFpbnRBbGwpOyAvLyBQYWludCBjdXN0dW0gbGF5ZXJzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIGxheWVyLnJlZnJlc2gpIHtcbiAgICAgICAgbGF5ZXIucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgIGlmIChlbC5fX2hvdmVyTWlyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsTWlycm9yID0gbmV3IGVsLmNvbnN0cnVjdG9yKHtcbiAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgIHNoYXBlOiBlbC5zaGFwZVxuICAgIH0pO1xuICAgIGVsTWlycm9yLl9fZnJvbSA9IGVsO1xuICAgIGVsLl9faG92ZXJNaXIgPSBlbE1pcnJvcjtcbiAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcblxuICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gIH0sXG4gIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgZWxNaXJyb3IgPSBlbC5fX2hvdmVyTWlyO1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKGhvdmVyRWxlbWVudHMsIGVsTWlycm9yKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICBlbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgfSxcbiAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZnJvbSA9IGhvdmVyRWxlbWVudHNbaV0uX19mcm9tO1xuXG4gICAgICBpZiAoZnJvbSkge1xuICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXI7XG4gICAgaG92ZXJMYXllciAmJiBob3ZlckxheWVyLmNsZWFyKCk7XG5cbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpOyAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgIC8vIEZJWE1FP1xuXG4gICAgaWYgKCFob3ZlckxheWVyKSB7XG4gICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgIHZhciBlbCA9IGhvdmVyRWxlbWVudHNbaV07XG4gICAgICB2YXIgb3JpZ2luYWxFbCA9IGVsLl9fZnJvbTsgLy8gT3JpZ2luYWwgZWwgaXMgcmVtb3ZlZFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoIShvcmlnaW5hbEVsICYmIG9yaWdpbmFsRWwuX196cikpIHtcbiAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG9yaWdpbmFsRWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgIGxlbi0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaSsrOyAvLyBVc2UgdHJhbnNmb3JtXG4gICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuXG4gICAgICBpZiAoIW9yaWdpbmFsRWwuaW52aXNpYmxlKSB7XG4gICAgICAgIGVsLnRyYW5zZm9ybSA9IG9yaWdpbmFsRWwudHJhbnNmb3JtO1xuICAgICAgICBlbC5pbnZUcmFuc2Zvcm0gPSBvcmlnaW5hbEVsLmludlRyYW5zZm9ybTtcbiAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBvcmlnaW5hbEVsLl9fY2xpcFBhdGhzOyAvLyBlbC5cblxuICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gIH0sXG4gIF9zdGFydFByb2dlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAvLyBwcmV2aW91cyB6ci5yZWZyZXNoIGNhbGxpbmcuXG5cblxuICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcbiAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgaWYgKHRva2VuID09PSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuICYmIHNlbGYuc3RvcmFnZSkge1xuICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NsZWFyUHJvZ3Jlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgfSk7XG4gIH0sXG4gIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgIGlmIChwYWludEFsbCA9PSBudWxsKSB7XG4gICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuXG4gICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHByZVByb2Nlc3NMYXllcik7XG5cbiAgICB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gIH0sXG4gIF9kb1BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG4gICAgdmFyIGN1cnJlbnRMYXllcjtcbiAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICB2YXIgY3R4OyAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG5cbiAgICB2YXIgc2NvcGU7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIHZhciBsYXllclByb2dyZXNzO1xuICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuXG4gICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDA7IC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcblxuICAgICAgY3VycmVudExheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciBlbFpMZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG4gICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWU7IC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgfSAvLyBDaGFuZ2UgZHJhdyBsYXllclxuXG5cbiAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSAvLyBSZXNldCBzY29wZVxuXG5cbiAgICAgICAgc2NvcGUgPSB7fTsgLy8gT25seSAwIHpsZXZlbCBpZiBvbmx5IGhhcyBvbmUgY2FudmFzXG5cbiAgICAgICAgY3VycmVudFpMZXZlbCA9IGVsWkxldmVsO1xuICAgICAgICBjdXJyZW50TGF5ZXIgPSB0aGlzLmdldExheWVyKGN1cnJlbnRaTGV2ZWwpO1xuXG4gICAgICAgIGlmICghY3VycmVudExheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTsgLy8gUmVzZXQgdGhlIGNvdW50XG5cbiAgICAgICAgY3VycmVudExheWVyLl9fdW51c2VkQ291bnQgPSAwO1xuXG4gICAgICAgIGlmIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkge1xuICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsRnJhbWUgPj0gMCkge1xuICAgICAgICAvLyBQcm9ncmVzc2l2ZSBsYXllciBjaGFuZ2VkXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW01hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJJZHgrKywgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpXTtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcyA+IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgLy8gQWxsIHByb2dyZXNzaXZlIGVsZW1lbnQgYXJlIG5vdCBkaXJ0eSwganVtcCBvdmVyIGFuZCBmbHVzaCBkaXJlY3RseVxuICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxOyAvLyBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxheWVyUHJvZ3Jlc3MgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAvLyBLZWVwIHJlbmRlcmluZ1xuICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPSBmcmFtZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxGcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgfVxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgIH0gLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuXG5cbiAgICBjdHggJiYgY3R4LnJlc3RvcmUoKTsgLy8gSWYgc3RpbGwgaGFzIGNsaXBwaW5nIHN0YXRlXG4gICAgLy8gaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgIC8vIH1cblxuICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgIHZhciBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuXG4gICAgaWYgKChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KSAmJiAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAhZWwuaW52aXNpYmxlIC8vIElnbm9yZSB0cmFuc3BhcmVudCBlbGVtZW50XG4gICAgJiYgZWwuc3R5bGUub3BhY2l0eSAhPT0gMCAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKSAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpKSB7XG4gICAgICB2YXIgY2xpcFBhdGhzID0gZWwuX19jbGlwUGF0aHM7IC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG5cbiAgICAgIGlmIChzY29wZS5wcmV2Q2xpcExheWVyICE9PSBjdXJyZW50TGF5ZXIgfHwgaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBzY29wZS5wcmV2RWxDbGlwUGF0aHMpKSB7XG4gICAgICAgIC8vIElmIGhhcyBwcmV2aW91cyBjbGlwcGluZyBzdGF0ZSwgcmVzdG9yZSBmcm9tIGl0XG4gICAgICAgIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7IC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG5cbiAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICB9IC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuXG5cbiAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gY3VycmVudExheWVyO1xuICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICBzY29wZS5wcmV2RWwgPSBlbDtcbiAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaChjdHgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICovXG4gIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgIGxheWVyLl9fYnVpbHRpbl9fID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0TGF5ZXIoemxldmVsLCBsYXllcik7IC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgIC8vIE9yIGV4Y2FudmFzIHdpbGwgZ2V0IDBweCBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0XG5cbiAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9LFxuICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcbiAgICB2YXIgbGF5ZXJzTWFwID0gdGhpcy5fbGF5ZXJzO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGVuID0gemxldmVsTGlzdC5sZW5ndGg7XG4gICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG5cbiAgICBpZiAobGF5ZXJzTWFwW3psZXZlbF0pIHtcbiAgICAgIGxvZygnWkxldmVsICcgKyB6bGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuXG5cbiAgICBpZiAoIWlzTGF5ZXJWYWxpZChsYXllcikpIHtcbiAgICAgIGxvZygnTGF5ZXIgb2YgemxldmVsICcgKyB6bGV2ZWwgKyAnIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHpsZXZlbExpc3RbaV0gPCB6bGV2ZWwgJiYgemxldmVsTGlzdFtpICsgMV0gPiB6bGV2ZWwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2TGF5ZXIgPSBsYXllcnNNYXBbemxldmVsTGlzdFtpXV07XG4gICAgfVxuXG4gICAgemxldmVsTGlzdC5zcGxpY2UoaSArIDEsIDAsIHpsZXZlbCk7XG4gICAgbGF5ZXJzTWFwW3psZXZlbF0gPSBsYXllcjsgLy8gVml0dWFsIGxheWVyIHdpbGwgbm90IGRpcmVjdGx5IHNob3cgb24gdGhlIHNjcmVlbi5cbiAgICAvLyAoSXQgY2FuIGJlIGEgV2ViR0wgbGF5ZXIgYW5kIGFzc2lnbmVkIHRvIGEgWkltYWdlIGVsZW1lbnQpXG4gICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cblxuICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgaWYgKHByZXZMYXllcikge1xuICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG5cbiAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIHByZXZEb20ubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICBlYWNoTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBidWlsZGluIGxheWVyXG4gIGVhY2hCdWlsdGluTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXI7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgKi9cbiAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVycztcbiAgfSxcbiAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJzID0gdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnM7XG4gICAgdmFyIGVsQ291bnRzTGFzdEZyYW1lID0ge307XG4gICAgdmFyIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJDb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgdmFyIGZyYW1lQ291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuXG4gICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuZWxDb3VudCsrO1xuICAgICAgICBsYXllci5fX2RpcnR5ID0gbGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgfSAvLy8vLy8vIFVwZGF0ZSBwcm9ncmVzc2l2ZVxuXG5cbiAgICAgIGlmIChlbFByb2dyZXNzID49IDApIHtcbiAgICAgICAgLy8gRml4IHdyb25nIHByb2dyZXNzaXZlIHNlcXVlbmNlIHByb2JsZW0uXG4gICAgICAgIGlmIChsYXN0UHJvZ3Jlc3NpdmVLZXkgIT09IGVsUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgIGZyYW1lQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKCdwcm9ncmVzc2l2ZScsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5ID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5lbENvdW50Kys7XG4gICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSBNYXRoLm1heChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lKTtcblxuICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuX19mcmFtZSA9IC0xO1xuXG4gICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICB9IC8vIOWxguS4reeahOWFg+e0oOaVsOmHj+acieWPkeeUn+WPmOWMllxuXG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBpZiAoZWxDb3VudHNMYXN0RnJhbWVbel0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSKTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBpZiAocHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZVtpZHhdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgIGVsLl9fZGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICBsYXllci5fX3Byb2dyZXNzID0gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICog5riF6ZmkaG92ZXLlsYLlpJbmiYDmnInlhoXlrrlcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY2xlYXJMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICog5L+u5pS55oyH5a6aemxldmVs55qE57uY5Yi25Y+C5pWwXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6bGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyDphY3nva7lr7nosaFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0g5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN11cbiAgICogICAgICAgICAgICAgICAgIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5fbGF5ZXJDb25maWc7XG5cbiAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAqL1xuICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgZGVsZXRlIGxheWVyc1t6bGV2ZWxdO1xuICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290OyAvLyBGSVhNRSBXaHkgP1xuXG4gICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBTYXZlIGlucHV0IHcvaFxuXG4gICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgaGVpZ2h0ICE9IG51bGwgJiYgKG9wdHMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcbiAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnJzsgLy8g5LyY5YyW5rKh5pyJ5a6e6ZmF5pS55Y+Y55qEcmVzaXplXG5cbiAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGRvbVJvb3Quc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXllcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAqL1xuICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDph4rmlL5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5yb290ID0gdGhpcy5zdG9yYWdlID0gdGhpcy5fZG9tUm9vdCA9IHRoaXMuX2xheWVycyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMucGl4ZWxSYXRpb11cbiAgICovXG4gIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXS5kb207XG4gICAgfVxuXG4gICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgaW1hZ2VMYXllci5jbGVhcigpO1xuICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICB2YXIgemxldmVsO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmRBbmREcmF3T3RoZXJMYXllcihzbWFsbGVyLCBsYXJnZXIpIHtcbiAgICAgIHZhciB6bGV2ZWxMaXN0ID0gc2VsZi5femxldmVsTGlzdDtcblxuICAgICAgaWYgKHNtYWxsZXIgPT0gbnVsbCkge1xuICAgICAgICBzbWFsbGVyID0gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZXJtZWRpYXRlTGF5ZXI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgIHZhciBsYXllciA9IHNlbGYuX2xheWVyc1t6XTtcblxuICAgICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIHogPiBzbWFsbGVyICYmIHogPCBsYXJnZXIpIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVMYXllciA9IGxheWVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlcm1lZGlhdGVMYXllciAmJiBpbnRlcm1lZGlhdGVMYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgIGludGVybWVkaWF0ZUxheWVyLnJlbmRlclRvQ2FudmFzKGltYWdlTGF5ZXIuY3R4KTtcbiAgICAgICAgaW1hZ2VMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGRpc3BsYXlMaXN0W2ldO1xuXG4gICAgICBpZiAoZWwuemxldmVsICE9PSB6bGV2ZWwpIHtcbiAgICAgICAgZmluZEFuZERyYXdPdGhlckxheWVyKHpsZXZlbCwgZWwuemxldmVsKTtcbiAgICAgICAgemxldmVsID0gZWwuemxldmVsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGltYWdlTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICB9XG5cbiAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGltYWdlTGF5ZXIuZG9tO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICovXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIF9nZXRTaXplOiBmdW5jdGlvbiAod2hJZHgpIHtcbiAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIGN3aCA9IFsnY2xpZW50V2lkdGgnLCAnY2xpZW50SGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBwbHQgPSBbJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdUb3AnXVt3aElkeF07XG4gICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7IC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUsIGJ1dCBpdCB1c2UgVk1MLlxuXG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG4gICAgcmV0dXJuIChyb290W2N3aF0gfHwgcGFyc2VJbnQxMChzdGxbd2hdKSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGVbd2hdKSkgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMCkgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMCkgfCAwO1xuICB9LFxuICBwYXRoVG9JbWFnZTogZnVuY3Rpb24gKHBhdGgsIGRwcikge1xuICAgIGRwciA9IGRwciB8fCB0aGlzLmRwcjtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSBwYXRoLnN0eWxlO1xuICAgIHZhciBzaGFkb3dCbHVyU2l6ZSA9IHN0eWxlLnNoYWRvd0JsdXI7XG4gICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xuICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGUuc2hhZG93T2Zmc2V0WTtcbiAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5saW5lV2lkdGggOiAwO1xuICAgIHZhciBsZWZ0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHJpZ2h0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgdG9wTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIGJvdHRvbU1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCArIGxlZnRNYXJnaW4gKyByaWdodE1hcmdpbjtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyB0b3BNYXJnaW4gKyBib3R0b21NYXJnaW47XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmRwciA9IGRwcjtcbiAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgIHBvc2l0aW9uOiBwYXRoLnBvc2l0aW9uLFxuICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgIH07XG4gICAgcGF0aC5wb3NpdGlvbiA9IFtsZWZ0TWFyZ2luIC0gcmVjdC54LCB0b3BNYXJnaW4gLSByZWN0LnldO1xuICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgIHBhdGguc2NhbGUgPSBbMSwgMV07XG4gICAgcGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgfVxuXG4gICAgdmFyIEltYWdlU2hhcGUgPSBJbWFnZTtcbiAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICBzdHlsZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnJvdGF0aW9uID0gcGF0aC5yb3RhdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucm90YXRpb247XG4gICAgfVxuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1nU2hhcGU7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9QYWludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9QYWludGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIEdyb3VwID0gcmVxdWlyZShcIi4vY29udGFpbmVyL0dyb3VwXCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCIuL2NvcmUvdGltc29ydFwiKTtcblxuLyoqXG4gKiBTdG9yYWdl5YaF5a655LuT5bqT5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvU3RvcmFnZVxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nLylcbiAqL1xuLy8gVXNlIHRpbXNvcnQgYmVjYXVzZSBpbiBtb3N0IGNhc2UgZWxlbWVudHMgYXJlIHBhcnRpYWxseSBzb3J0ZWRcbi8vIGh0dHBzOi8vanNmaWRkbGUubmV0L3Bpc3NhbmcvanI0eDdtZG0vOC9cbmZ1bmN0aW9uIHNoYXBlQ29tcGFyZUZ1bmMoYSwgYikge1xuICBpZiAoYS56bGV2ZWwgPT09IGIuemxldmVsKSB7XG4gICAgaWYgKGEueiA9PT0gYi56KSB7XG4gICAgICAvLyBpZiAoYS56MiA9PT0gYi56Mikge1xuICAgICAgLy8gICAgIC8vIEZJWE1FIFNsb3cgaGFzIHJlbmRlcmlkeCBjb21wYXJlXG4gICAgICAvLyAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDg4MzQyMS9zb3J0aW5nLWluLWphdmFzY3JpcHQtc2hvdWxkLWV2ZXJ5LWNvbXBhcmUtZnVuY3Rpb24taGF2ZS1hLXJldHVybi0wLXN0YXRlbWVudFxuICAgICAgLy8gICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzQ3Y2NlNTQ0YTMxZWQ1NTc3ZmZlMjk2M2Y2N2FjYjQxNDRlZTAyMzIvc3JjL2pzL2FycmF5LmpzI0wxMDEyXG4gICAgICAvLyAgICAgcmV0dXJuIGEuX19yZW5kZXJpZHggLSBiLl9fcmVuZGVyaWR4O1xuICAgICAgLy8gfVxuICAgICAgcmV0dXJuIGEuejIgLSBiLnoyO1xuICAgIH1cblxuICAgIHJldHVybiBhLnogLSBiLno7XG4gIH1cblxuICByZXR1cm4gYS56bGV2ZWwgLSBiLnpsZXZlbDtcbn1cbi8qKlxuICog5YaF5a655LuT5bqTIChNKVxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1N0b3JhZ2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICB0aGlzLl9yb290cyA9IFtdO1xuICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG59O1xuXG5TdG9yYWdlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFN0b3JhZ2UsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKlxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3Jvb3RzW2ldLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOi/lOWbnuaJgOacieWbvuW9oueahOe7mOWItumYn+WIl1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGU9ZmFsc2VdIOaYr+WQpuWcqOi/lOWbnuWJjeabtOaWsOivpeaVsOe7hFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICpcbiAgICog6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0fVxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAqL1xuICBnZXREaXNwbGF5TGlzdDogZnVuY3Rpb24gKHVwZGF0ZSwgaW5jbHVkZUlnbm9yZSkge1xuICAgIGluY2x1ZGVJZ25vcmUgPSBpbmNsdWRlSWdub3JlIHx8IGZhbHNlO1xuXG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVEaXNwbGF5TGlzdChpbmNsdWRlSWdub3JlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGlzcGxheUxpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOabtOaWsOWbvuW9oueahOe7mOWItumYn+WIl+OAglxuICAgKiDmr4/mrKHnu5jliLbliY3pg73kvJrosIPnlKjvvIzor6Xmlrnms5XkvJrlhYjmt7HluqbkvJjlhYjpgY3ljobmlbTkuKrmoJHvvIzmm7TmlrDmiYDmnIlHcm91cOWSjFNoYXBl55qE5Y+Y5o2i5bm25LiU5oqK5omA5pyJ5Y+v6KeB55qEU2hhcGXkv53lrZjliLDmlbDnu4TkuK3vvIxcbiAgICog5pyA5ZCO5qC55o2u57uY5Yi255qE5LyY5YWI57qn77yIemxldmVsID4geiA+IOaPkuWFpemhuuW6j++8ieaOkuW6j+W+l+WIsOe7mOWItumYn+WIl1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hFxuICAgKi9cbiAgdXBkYXRlRGlzcGxheUxpc3Q6IGZ1bmN0aW9uIChpbmNsdWRlSWdub3JlKSB7XG4gICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgIHZhciByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuX2Rpc3BsYXlMaXN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvb3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShyb290c1tpXSwgbnVsbCwgaW5jbHVkZUlnbm9yZSk7XG4gICAgfVxuXG4gICAgZGlzcGxheUxpc3QubGVuZ3RoID0gdGhpcy5fZGlzcGxheUxpc3RMZW47IC8vIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaXNwbGF5TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIC8vICAgICBkaXNwbGF5TGlzdFtpXS5fX3JlbmRlcmlkeCA9IGk7XG4gICAgLy8gfVxuICAgIC8vIGRpc3BsYXlMaXN0LnNvcnQoc2hhcGVDb21wYXJlRnVuYyk7XG5cbiAgICBlbnYuY2FudmFzU3VwcG9ydGVkICYmIHRpbXNvcnQoZGlzcGxheUxpc3QsIHNoYXBlQ29tcGFyZUZ1bmMpO1xuICB9LFxuICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgaWYgKGVsLmlnbm9yZSAmJiAhaW5jbHVkZUlnbm9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgIGVsLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGVsLmFmdGVyVXBkYXRlKCk7XG4gICAgdmFyIHVzZXJTZXRDbGlwUGF0aCA9IGVsLmNsaXBQYXRoO1xuXG4gICAgaWYgKHVzZXJTZXRDbGlwUGF0aCkge1xuICAgICAgLy8gRklYTUUg5pWI546H5b2x5ZONXG4gICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpcFBhdGhzID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50Q2xpcFBhdGggPSB1c2VyU2V0Q2xpcFBhdGg7XG4gICAgICB2YXIgcGFyZW50Q2xpcFBhdGggPSBlbDsgLy8gUmVjdXJzaXZlbHkgYWRkIGNsaXAgcGF0aFxuXG4gICAgICB3aGlsZSAoY3VycmVudENsaXBQYXRoKSB7XG4gICAgICAgIC8vIGNsaXBQYXRoIOeahOWPmOaNouaYr+WfuuS6juS9v+eUqOi/meS4qiBjbGlwUGF0aCDnmoTlhYPntKBcbiAgICAgICAgY3VycmVudENsaXBQYXRoLnBhcmVudCA9IHBhcmVudENsaXBQYXRoO1xuICAgICAgICBjdXJyZW50Q2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIGNsaXBQYXRocy5wdXNoKGN1cnJlbnRDbGlwUGF0aCk7XG4gICAgICAgIHBhcmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoO1xuICAgICAgICBjdXJyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGguY2xpcFBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTsgLy8gRm9yY2UgdG8gbWFyayBhcyBkaXJ0eSBpZiBncm91cCBpcyBkaXJ0eVxuICAgICAgICAvLyBGSVhNRSBfX2RpcnR5UGF0aCA/XG5cbiAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICBjaGlsZC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKGNoaWxkLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgfSAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcblxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXAp5Yiw5qC56IqC54K5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIGFkZFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC5fX3N0b3JhZ2UgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgZWwuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2UodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRUb1N0b3JhZ2UoZWwpO1xuXG4gICAgdGhpcy5fcm9vdHMucHVzaChlbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOaMh+WumueahOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXApXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbZWxdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICovXG4gIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCA9PSBudWxsKSB7XG4gICAgICAvLyDkuI3mjIflrpplbOa4heepulxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3RzW2ldO1xuXG4gICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICByb290LmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVsUm9vdChlbFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKHRoaXMuX3Jvb3RzLCBlbCk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuZGVsRnJvbVN0b3JhZ2UoZWwpO1xuXG4gICAgICB0aGlzLl9yb290cy5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFkZFRvU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwuX19zdG9yYWdlID0gdGhpcztcbiAgICBlbC5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRlbEZyb21TdG9yYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLl9fc3RvcmFnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4heepuuW5tuS4lOmHiuaUvlN0b3JhZ2VcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZW5kZXJMaXN0ID0gdGhpcy5fcm9vdHMgPSBudWxsO1xuICB9LFxuICBkaXNwbGF5YWJsZVNvcnRGdW5jOiBzaGFwZUNvbXBhcmVGdW5jXG59O1xudmFyIF9kZWZhdWx0ID0gU3RvcmFnZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvU3RvcmFnZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvU3RvcmFnZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB1dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIF9ldmVudCA9IHJlcXVpcmUoXCIuLi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgRGlzcGF0Y2hlciA9IF9ldmVudC5EaXNwYXRjaGVyO1xuXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZShcIi4vcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgQW5pbWF0b3IgPSByZXF1aXJlKFwiLi9BbmltYXRvclwiKTtcblxuLyoqXG4gKiDliqjnlLvkuLvnsbssIOiwg+W6puWSjOeuoeeQhuaJgOacieWKqOeUu+aOp+WItuWZqFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbi8vIFRPRE8gQWRkaXRpdmUgYW5pbWF0aW9uXG4vLyBodHRwOi8vaW9zb3RlcmljLmNvbS9hZGRpdGl2ZS1hbmltYXRpb25zLWFuaW1hdGV3aXRoZHVyYXRpb24taW4taW9zLTgvXG4vLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vdmlkZW9zL3d3ZGMyMDE0LyMyMzZcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJWlJlbmRlclN0YWdlXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cGRhdGVcbiAqL1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uZnJhbWVdXG4gKiBAcGFyYW0ge0laUmVuZGVyU3RhZ2V9IFtvcHRpb25zLnN0YWdlXVxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigpO1xuICogICAgIHZhciBvYmogPSB7XG4gKiAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgeTogMTAwXG4gKiAgICAgfTtcbiAqICAgICBhbmltYXRpb24uYW5pbWF0ZShub2RlLnBvc2l0aW9uKVxuICogICAgICAgICAud2hlbigxMDAwLCB7XG4gKiAgICAgICAgICAgICB4OiA1MDAsXG4gKiAgICAgICAgICAgICB5OiA1MDBcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLndoZW4oMjAwMCwge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC5zdGFydCgnc3BsaW5lJyk7XG4gKi9cbnZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5zdGFnZSA9IG9wdGlvbnMuc3RhZ2UgfHwge307XG5cbiAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lIHx8IGZ1bmN0aW9uICgpIHt9OyAvLyBwcml2YXRlIHByb3BlcnRpZXNcblxuXG4gIHRoaXMuX2NsaXBzID0gW107XG4gIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgdGhpcy5fdGltZTtcbiAgdGhpcy5fcGF1c2VkVGltZTtcbiAgdGhpcy5fcGF1c2VTdGFydDtcbiAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcbn07XG5cbkFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBbmltYXRpb24sXG5cbiAgLyoqXG4gICAqIOa3u+WKoCBjbGlwXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICovXG4gIGFkZENsaXA6IGZ1bmN0aW9uIChjbGlwKSB7XG4gICAgdGhpcy5fY2xpcHMucHVzaChjbGlwKTtcbiAgfSxcblxuICAvKipcbiAgICog5re75YqgIGFuaW1hdG9yXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgKi9cbiAgYWRkQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IHRoaXM7XG4gICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYWRkQ2xpcChjbGlwc1tpXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTliqjnlLvniYfmrrVcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgKi9cbiAgcmVtb3ZlQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKHRoaXMuX2NsaXBzLCBjbGlwKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgdGhpcy5fY2xpcHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTliqjnlLvniYfmrrVcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAqL1xuICByZW1vdmVBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xpcChjbGlwc1tpXSk7XG4gICAgfVxuXG4gICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gbnVsbDtcbiAgfSxcbiAgX3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9wYXVzZWRUaW1lO1xuXG4gICAgdmFyIGRlbHRhID0gdGltZSAtIHRoaXMuX3RpbWU7XG4gICAgdmFyIGNsaXBzID0gdGhpcy5fY2xpcHM7XG4gICAgdmFyIGxlbiA9IGNsaXBzLmxlbmd0aDtcbiAgICB2YXIgZGVmZXJyZWRFdmVudHMgPSBbXTtcbiAgICB2YXIgZGVmZXJyZWRDbGlwcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGNsaXAgPSBjbGlwc1tpXTtcbiAgICAgIHZhciBlID0gY2xpcC5zdGVwKHRpbWUsIGRlbHRhKTsgLy8gVGhyb3cgb3V0IHRoZSBldmVudHMgbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXJcbiAgICAgIC8vIHN0YWdlLnVwZGF0ZSwgbGlrZSBkZXN0cm95XG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGRlZmVycmVkRXZlbnRzLnB1c2goZSk7XG4gICAgICAgIGRlZmVycmVkQ2xpcHMucHVzaChjbGlwKTtcbiAgICAgIH1cbiAgICB9IC8vIFJlbW92ZSB0aGUgZmluaXNoZWQgY2xpcFxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgIGlmIChjbGlwc1tpXS5fbmVlZHNSZW1vdmUpIHtcbiAgICAgICAgY2xpcHNbaV0gPSBjbGlwc1tsZW4gLSAxXTtcbiAgICAgICAgY2xpcHMucG9wKCk7XG4gICAgICAgIGxlbi0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxlbiA9IGRlZmVycmVkRXZlbnRzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlZmVycmVkQ2xpcHNbaV0uZmlyZShkZWZlcnJlZEV2ZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgdGhpcy5vbmZyYW1lKGRlbHRhKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2ZyYW1lJywgZGVsdGEpO1xuXG4gICAgaWYgKHRoaXMuc3RhZ2UudXBkYXRlKSB7XG4gICAgICB0aGlzLnN0YWdlLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSxcbiAgX3N0YXJ0TG9vcDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICBpZiAoc2VsZi5fcnVubmluZykge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgICFzZWxmLl9wYXVzZWQgJiYgc2VsZi5fdXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlvIDlp4vov5DooYzliqjnlLtcbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuXG4gICAgdGhpcy5fc3RhcnRMb29wKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWBnOatoui/kOihjOWKqOeUu1xuICAgKi9cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUGF1c2VcbiAgICovXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXN1bWVcbiAgICovXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgIHRoaXMuX3BhdXNlZFRpbWUgKz0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9wYXVzZVN0YXJ0O1xuICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXpmaTmiYDmnInliqjnlLvniYfmrrVcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xpcHMgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICog5a+55LiA5Liq55uu5qCH5Yib5bu65LiA5LiqYW5pbWF0b3Llr7nosaHvvIzlj6/ku6XmjIflrprnm67moIfkuK3nmoTlsZ7mgKfkvb/nlKjliqjnlLtcbiAgICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmxvb3A9ZmFsc2VdIOaYr+WQpuW+queOr+aSreaUvuWKqOeUu1xuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2V0dGVyPW51bGxdXG4gICAqICAgICAgICAg5aaC5p6c5oyH5a6aZ2V0dGVy5Ye95pWw77yM5Lya6YCa6L+HZ2V0dGVy5Ye95pWw5Y+W5bGe5oCn5YC8XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5zZXR0ZXI9bnVsbF1cbiAgICogICAgICAgICDlpoLmnpzmjIflrppzZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dzZXR0ZXLlh73mlbDorr7nva7lsZ7mgKflgLxcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn5BbmltYXRvcn1cbiAgICovXG4gIC8vIFRPRE8gR2FwXG4gIGFuaW1hdGU6IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGFyZ2V0LCBvcHRpb25zLmxvb3AsIG9wdGlvbnMuZ2V0dGVyLCBvcHRpb25zLnNldHRlcik7XG4gICAgdGhpcy5hZGRBbmltYXRvcihhbmltYXRvcik7XG4gICAgcmV0dXJuIGFuaW1hdG9yO1xuICB9XG59O1xudXRpbC5taXhpbihBbmltYXRpb24sIERpc3BhdGNoZXIpO1xudmFyIF9kZWZhdWx0ID0gQW5pbWF0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIENsaXAgPSByZXF1aXJlKFwiLi9DbGlwXCIpO1xuXG52YXIgY29sb3IgPSByZXF1aXJlKFwiLi4vdG9vbC9jb2xvclwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGlzQXJyYXlMaWtlID0gX3V0aWwuaXNBcnJheUxpa2U7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2FuaW1hdGlvbi9BbmltYXRvclxuICovXG52YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gZGVmYXVsdEdldHRlcih0YXJnZXQsIGtleSkge1xuICByZXR1cm4gdGFyZ2V0W2tleV07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXR0ZXIodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gIHRhcmdldFtrZXldID0gdmFsdWU7XG59XG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVOdW1iZXIocDAsIHAxLCBwZXJjZW50KSB7XG4gIHJldHVybiAocDEgLSBwMCkgKiBwZXJjZW50ICsgcDA7XG59XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gcDBcbiAqIEBwYXJhbSAge3N0cmluZ30gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVTdHJpbmcocDAsIHAxLCBwZXJjZW50KSB7XG4gIHJldHVybiBwZXJjZW50ID4gMC41ID8gcDEgOiBwMDtcbn1cbi8qKlxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwZXJjZW50LCBvdXQsIGFyckRpbSkge1xuICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuXG4gIGlmIChhcnJEaW0gPT0gMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG91dFtpXSA9IGludGVycG9sYXRlTnVtYmVyKHAwW2ldLCBwMVtpXSwgcGVyY2VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gbGVuICYmIHAwWzBdLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIG91dFtpXVtqXSA9IGludGVycG9sYXRlTnVtYmVyKHAwW2ldW2pdLCBwMVtpXVtqXSwgcGVyY2VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIGFycjAgaXMgc291cmNlIGFycmF5LCBhcnIxIGlzIHRhcmdldCBhcnJheS5cbi8vIERvIHNvbWUgcHJlcHJvY2VzcyB0byBhdm9pZCBlcnJvciBoYXBwZW5lZCB3aGVuIGludGVycG9sYXRpbmcgZnJvbSBhcnIwIHRvIGFycjFcblxuXG5mdW5jdGlvbiBmaWxsQXJyKGFycjAsIGFycjEsIGFyckRpbSkge1xuICB2YXIgYXJyMExlbiA9IGFycjAubGVuZ3RoO1xuICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuXG4gIGlmIChhcnIwTGVuICE9PSBhcnIxTGVuKSB7XG4gICAgLy8gRklYTUUgTm90IHdvcmsgZm9yIFR5cGVkQXJyYXlcbiAgICB2YXIgaXNQcmV2aW91c0xhcmdlciA9IGFycjBMZW4gPiBhcnIxTGVuO1xuXG4gICAgaWYgKGlzUHJldmlvdXNMYXJnZXIpIHtcbiAgICAgIC8vIEN1dCB0aGUgcHJldmlvdXNcbiAgICAgIGFycjAubGVuZ3RoID0gYXJyMUxlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmlsbCB0aGUgcHJldmlvdXNcbiAgICAgIGZvciAodmFyIGkgPSBhcnIwTGVuOyBpIDwgYXJyMUxlbjsgaSsrKSB7XG4gICAgICAgIGFycjAucHVzaChhcnJEaW0gPT09IDEgPyBhcnIxW2ldIDogYXJyYXlTbGljZS5jYWxsKGFycjFbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSGFuZGxpbmcgTmFOIHZhbHVlXG5cblxuICB2YXIgbGVuMiA9IGFycjBbMF0gJiYgYXJyMFswXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgICAgaWYgKGlzTmFOKGFycjBbaV0pKSB7XG4gICAgICAgIGFycjBbaV0gPSBhcnIxW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBpZiAoaXNOYU4oYXJyMFtpXVtqXSkpIHtcbiAgICAgICAgICBhcnIwW2ldW2pdID0gYXJyMVtpXVtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyMFxuICogQHBhcmFtICB7QXJyYXl9IGFycjFcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNBcnJheVNhbWUoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gIGlmIChhcnIwID09PSBhcnIxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGVuID0gYXJyMC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAhPT0gYXJyMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGFycjBbaV0gIT09IGFycjFbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuMiA9IGFycjBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgaWYgKGFycjBbaV1bal0gIT09IGFycjFbaV1bal0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgYXJyYXlcbiAqIEBwYXJhbSAge0FycmF5fSBwMFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAqIEBwYXJhbSAge0FycmF5fSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICovXG5cblxuZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mywgb3V0LCBhcnJEaW0pIHtcbiAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcblxuICBpZiAoYXJyRGltID09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQsIHQyLCB0Myk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgb3V0W2ldW2pdID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwW2ldW2pdLCBwMVtpXVtqXSwgcDJbaV1bal0sIHAzW2ldW2pdLCB0LCB0MiwgdDMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBudW1iZXJcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDMgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufVxuXG5mdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKTtcbiAgcmdiYVsyXSA9IE1hdGguZmxvb3IocmdiYVsyXSk7XG4gIHJldHVybiAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5RGltKGtleWZyYW1lcykge1xuICB2YXIgbGFzdFZhbHVlID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKGxhc3RWYWx1ZSAmJiBsYXN0VmFsdWVbMF0pID8gMiA6IDE7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYWNrQ2xpcChhbmltYXRvciwgZWFzaW5nLCBvbmVUcmFja0RvbmUsIGtleWZyYW1lcywgcHJvcE5hbWUsIGZvcmNlQW5pbWF0ZSkge1xuICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuICB2YXIgdHJhY2tMZW4gPSBrZXlmcmFtZXMubGVuZ3RoO1xuXG4gIGlmICghdHJhY2tMZW4pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gR3Vlc3MgZGF0YSB0eXBlXG5cblxuICB2YXIgZmlyc3RWYWwgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gIHZhciBpc1ZhbHVlQXJyYXkgPSBpc0FycmF5TGlrZShmaXJzdFZhbCk7XG4gIHZhciBpc1ZhbHVlQ29sb3IgPSBmYWxzZTtcbiAgdmFyIGlzVmFsdWVTdHJpbmcgPSBmYWxzZTsgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG5cbiAgdmFyIGFyckRpbSA9IGlzVmFsdWVBcnJheSA/IGdldEFycmF5RGltKGtleWZyYW1lcykgOiAwO1xuICB2YXIgdHJhY2tNYXhUaW1lOyAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuXG4gIGtleWZyYW1lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEudGltZSAtIGIudGltZTtcbiAgfSk7XG4gIHRyYWNrTWF4VGltZSA9IGtleWZyYW1lc1t0cmFja0xlbiAtIDFdLnRpbWU7IC8vIFBlcmNlbnRzIG9mIGVhY2gga2V5ZnJhbWVcblxuICB2YXIga2ZQZXJjZW50cyA9IFtdOyAvLyBWYWx1ZSBvZiBlYWNoIGtleWZyYW1lXG5cbiAgdmFyIGtmVmFsdWVzID0gW107XG4gIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW47IGkrKykge1xuICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7IC8vIEFzc3VtZSB2YWx1ZSBpcyBhIGNvbG9yIHdoZW4gaXQgaXMgYSBzdHJpbmdcblxuICAgIHZhciB2YWx1ZSA9IGtleWZyYW1lc1tpXS52YWx1ZTsgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgZXF1YWwsIGRlZXAgY2hlY2sgaWYgdmFsdWUgaXMgYXJyYXlcblxuICAgIGlmICghKGlzVmFsdWVBcnJheSAmJiBpc0FycmF5U2FtZSh2YWx1ZSwgcHJldlZhbHVlLCBhcnJEaW0pIHx8ICFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpIHtcbiAgICAgIGlzQWxsVmFsdWVFcXVhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByZXZWYWx1ZSA9IHZhbHVlOyAvLyBUcnkgY29udmVydGluZyBhIHN0cmluZyB0byBhIGNvbG9yIGFycmF5XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgY29sb3JBcnJheSA9IGNvbG9yLnBhcnNlKHZhbHVlKTtcblxuICAgICAgaWYgKGNvbG9yQXJyYXkpIHtcbiAgICAgICAgdmFsdWUgPSBjb2xvckFycmF5O1xuICAgICAgICBpc1ZhbHVlQ29sb3IgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNWYWx1ZVN0cmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAga2ZWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIWZvcmNlQW5pbWF0ZSAmJiBpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0ga2ZWYWx1ZXNbdHJhY2tMZW4gLSAxXTsgLy8gUG9seWZpbGwgYXJyYXkgYW5kIE5hTiB2YWx1ZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW4gLSAxOyBpKyspIHtcbiAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICBmaWxsQXJyKGtmVmFsdWVzW2ldLCBsYXN0VmFsdWUsIGFyckRpbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc05hTihrZlZhbHVlc1tpXSkgJiYgIWlzTmFOKGxhc3RWYWx1ZSkgJiYgIWlzVmFsdWVTdHJpbmcgJiYgIWlzVmFsdWVDb2xvcikge1xuICAgICAgICBrZlZhbHVlc1tpXSA9IGxhc3RWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1ZhbHVlQXJyYXkgJiYgZmlsbEFycihnZXR0ZXIoYW5pbWF0b3IuX3RhcmdldCwgcHJvcE5hbWUpLCBsYXN0VmFsdWUsIGFyckRpbSk7IC8vIENhY2hlIHRoZSBrZXkgb2YgbGFzdCBmcmFtZSB0byBzcGVlZCB1cCB3aGVuXG4gIC8vIGFuaW1hdGlvbiBwbGF5YmFjayBpcyBzZXF1ZW5jeVxuXG4gIHZhciBsYXN0RnJhbWUgPSAwO1xuICB2YXIgbGFzdEZyYW1lUGVyY2VudCA9IDA7XG4gIHZhciBzdGFydDtcbiAgdmFyIHc7XG4gIHZhciBwMDtcbiAgdmFyIHAxO1xuICB2YXIgcDI7XG4gIHZhciBwMztcblxuICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgdmFyIHJnYmEgPSBbMCwgMCwgMCwgMF07XG4gIH1cblxuICB2YXIgb25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAvLyBGaW5kIHRoZSByYW5nZSBrZXlmcmFtZXNcbiAgICAvLyBrZjEtLS0tLWtmMi0tLS0tLS0tLWN1cnJlbnQtLS0tLS0tLWtmM1xuICAgIC8vIGZpbmQga2YyIGFuZCBrZjMgYW5kIGRvIGludGVycG9sYXRpb25cbiAgICB2YXIgZnJhbWU7IC8vIEluIHRoZSBlYXNpbmcgZnVuY3Rpb24gbGlrZSBlbGFzdGljT3V0LCBwZXJjZW50IG1heSBsZXNzIHRoYW4gMFxuXG4gICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICBmcmFtZSA9IDA7XG4gICAgfSBlbHNlIGlmIChwZXJjZW50IDwgbGFzdEZyYW1lUGVyY2VudCkge1xuICAgICAgLy8gU3RhcnQgZnJvbSBuZXh0IGtleVxuICAgICAgLy8gUEVORElORyBzdGFydCBmcm9tIGxhc3RGcmFtZSA/XG4gICAgICBzdGFydCA9IE1hdGgubWluKGxhc3RGcmFtZSArIDEsIHRyYWNrTGVuIC0gMSk7XG5cbiAgICAgIGZvciAoZnJhbWUgPSBzdGFydDsgZnJhbWUgPj0gMDsgZnJhbWUtLSkge1xuICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPD0gcGVyY2VudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XG5cblxuICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgdHJhY2tMZW4gLSAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChmcmFtZSA9IGxhc3RGcmFtZTsgZnJhbWUgPCB0cmFja0xlbjsgZnJhbWUrKykge1xuICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPiBwZXJjZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIHRyYWNrTGVuIC0gMik7XG4gICAgfVxuXG4gICAgbGFzdEZyYW1lID0gZnJhbWU7XG4gICAgbGFzdEZyYW1lUGVyY2VudCA9IHBlcmNlbnQ7XG4gICAgdmFyIHJhbmdlID0ga2ZQZXJjZW50c1tmcmFtZSArIDFdIC0ga2ZQZXJjZW50c1tmcmFtZV07XG5cbiAgICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdyA9IChwZXJjZW50IC0ga2ZQZXJjZW50c1tmcmFtZV0pIC8gcmFuZ2U7XG4gICAgfVxuXG4gICAgaWYgKHVzZVNwbGluZSkge1xuICAgICAgcDEgPSBrZlZhbHVlc1tmcmFtZV07XG4gICAgICBwMCA9IGtmVmFsdWVzW2ZyYW1lID09PSAwID8gZnJhbWUgOiBmcmFtZSAtIDFdO1xuICAgICAgcDIgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMiA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMV07XG4gICAgICBwMyA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAzID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAyXTtcblxuICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdywgZ2V0dGVyKHRhcmdldCwgcHJvcE5hbWUpLCBhcnJEaW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LCByZ2JhLCAxKTtcbiAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKHAxLCBwMiwgdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGVyKHRhcmdldCwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdywgZ2V0dGVyKHRhcmdldCwgcHJvcE5hbWUpLCBhcnJEaW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdywgcmdiYSwgMSk7XG4gICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gaW50ZXJwb2xhdGVOdW1iZXIoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRlcih0YXJnZXQsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbGlwID0gbmV3IENsaXAoe1xuICAgIHRhcmdldDogYW5pbWF0b3IuX3RhcmdldCxcbiAgICBsaWZlOiB0cmFja01heFRpbWUsXG4gICAgbG9vcDogYW5pbWF0b3IuX2xvb3AsXG4gICAgZGVsYXk6IGFuaW1hdG9yLl9kZWxheSxcbiAgICBvbmZyYW1lOiBvbmZyYW1lLFxuICAgIG9uZGVzdHJveTogb25lVHJhY2tEb25lXG4gIH0pO1xuXG4gIGlmIChlYXNpbmcgJiYgZWFzaW5nICE9PSAnc3BsaW5lJykge1xuICAgIGNsaXAuZWFzaW5nID0gZWFzaW5nO1xuICB9XG5cbiAgcmV0dXJuIGNsaXA7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3JcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlclxuICovXG5cblxudmFyIEFuaW1hdG9yID0gZnVuY3Rpb24gKHRhcmdldCwgbG9vcCwgZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgdGhpcy5fdHJhY2tzID0ge307XG4gIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgdGhpcy5fbG9vcCA9IGxvb3AgfHwgZmFsc2U7XG4gIHRoaXMuX2dldHRlciA9IGdldHRlciB8fCBkZWZhdWx0R2V0dGVyO1xuICB0aGlzLl9zZXR0ZXIgPSBzZXR0ZXIgfHwgZGVmYXVsdFNldHRlcjtcbiAgdGhpcy5fY2xpcENvdW50ID0gMDtcbiAgdGhpcy5fZGVsYXkgPSAwO1xuICB0aGlzLl9kb25lTGlzdCA9IFtdO1xuICB0aGlzLl9vbmZyYW1lTGlzdCA9IFtdO1xuICB0aGlzLl9jbGlwTGlzdCA9IFtdO1xufTtcblxuQW5pbWF0b3IucHJvdG90eXBlID0ge1xuICAvKipcbiAgICog6K6+572u5Yqo55S75YWz6ZSu5binXG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDlhbPplK7luKfml7bpl7TvvIzljZXkvY3mmK9tc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzIOWFs+mUruW4p+eahOWxnuaAp+WAvO+8jGtleS12YWx1ZeihqOekulxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICB3aGVuOiBmdW5jdGlvbiAodGltZVxuICAvKiBtcyAqL1xuICAsIHByb3BzKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMuX3RyYWNrcztcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFja3NbcHJvcE5hbWVdKSB7XG4gICAgICAgIHRyYWNrc1twcm9wTmFtZV0gPSBbXTsgLy8gSW52YWxpZCB2YWx1ZVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl90YXJnZXQsIHByb3BOYW1lKTtcblxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHpyTG9nKCdJbnZhbGlkIHByb3BlcnR5ICcgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSWYgdGltZSBpcyAwXG4gICAgICAgIC8vICBUaGVuIHByb3BzIGlzIGdpdmVuIGluaXRpYWxpemUgdmFsdWVcbiAgICAgICAgLy8gRWxzZVxuICAgICAgICAvLyAgSW5pdGlhbGl6ZSB2YWx1ZSBmcm9tIGN1cnJlbnQgcHJvcCB2YWx1ZVxuXG5cbiAgICAgICAgaWYgKHRpbWUgIT09IDApIHtcbiAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIHZhbHVlOiBjbG9uZVZhbHVlKHZhbHVlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIHZhbHVlOiBwcm9wc1twcm9wTmFtZV1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDliqjnlLvmr4/kuIDluKfnmoTlm57osIPlh73mlbBcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIGR1cmluZzogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fb25mcmFtZUxpc3QucHVzaChjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jbGlwTGlzdFtpXS5wYXVzZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH0sXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NsaXBMaXN0W2ldLnJlc3VtZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB9LFxuICBpc1BhdXNlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3BhdXNlZDtcbiAgfSxcbiAgX2RvbmVDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgIC8vIENsZWFyIGFsbCB0cmFja3NcbiAgICB0aGlzLl90cmFja3MgPSB7fTsgLy8gQ2xlYXIgYWxsIGNsaXBzXG5cbiAgICB0aGlzLl9jbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgIHZhciBkb25lTGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgIHZhciBsZW4gPSBkb25lTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkb25lTGlzdFtpXS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5byA5aeL5omn6KGM5Yqo55S7XG4gICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gW2Vhc2luZ11cbiAgICogICAgICAgICDliqjnlLvnvJPliqjlh73mlbDvvIzor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ31cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZm9yY2VBbmltYXRlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nLCBmb3JjZUFuaW1hdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNsaXBDb3VudCA9IDA7XG5cbiAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xpcENvdW50LS07XG5cbiAgICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICAgIHNlbGYuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGFzdENsaXA7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0aGlzLl90cmFja3MpIHtcbiAgICAgIGlmICghdGhpcy5fdHJhY2tzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsaXAgPSBjcmVhdGVUcmFja0NsaXAodGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lLCBmb3JjZUFuaW1hdGUpO1xuXG4gICAgICBpZiAoY2xpcCkge1xuICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuXG4gICAgICAgIGNsaXBDb3VudCsrOyAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cblxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgfVxuICAgIH0gLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG5cblxuICAgIGlmIChsYXN0Q2xpcCkge1xuICAgICAgdmFyIG9sZE9uRnJhbWUgPSBsYXN0Q2xpcC5vbmZyYW1lO1xuXG4gICAgICBsYXN0Q2xpcC5vbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICBvbGRPbkZyYW1lKHRhcmdldCwgcGVyY2VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9vbmZyYW1lTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAvLyBUaGlzIG9wdGltaXphdGlvbiB3aWxsIGhlbHAgdGhlIGNhc2UgdGhhdCBpbiB0aGUgdXBwZXIgYXBwbGljYXRpb25cbiAgICAvLyB0aGUgdmlldyBtYXkgYmUgcmVmcmVzaGVkIGZyZXF1ZW50bHksIHdoZXJlIGFuaW1hdGlvbiB3aWxsIGJlXG4gICAgLy8gY2FsbGVkIHJlcGVhdGx5IGJ1dCBub3RoaW5nIGNoYW5nZWQuXG5cblxuICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICB0aGlzLl9kb25lQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i5Yqo55S7XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICovXG4gIHN0b3A6IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgdmFyIGNsaXBMaXN0ID0gdGhpcy5fY2xpcExpc3Q7XG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNsaXAgPSBjbGlwTGlzdFtpXTtcblxuICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgLy8gTW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgIGNsaXAub25mcmFtZSh0aGlzLl90YXJnZXQsIDEpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgfVxuXG4gICAgY2xpcExpc3QubGVuZ3RoID0gMDtcbiAgfSxcblxuICAvKipcbiAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICB0aGlzLl9kZWxheSA9IHRpbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWKqOeUu+e7k+adn+eahOWbnuiwg1xuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZG9uZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0aGlzLl9kb25lTGlzdC5wdXNoKGNiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICovXG4gIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaXBMaXN0O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQW5pbWF0b3I7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVhc2luZ0Z1bmNzID0gcmVxdWlyZShcIi4vZWFzaW5nXCIpO1xuXG4vKipcbiAqIOWKqOeUu+S4u+aOp+WItuWZqFxuICogQGNvbmZpZyB0YXJnZXQg5Yqo55S75a+56LGh77yM5Y+v5Lul5piv5pWw57uE77yM5aaC5p6c5piv5pWw57uE55qE6K+d5Lya5om56YeP5YiG5Y+Rb25mcmFtZeetieS6i+S7tlxuICogQGNvbmZpZyBsaWZlKDEwMDApIOWKqOeUu+aXtumVv1xuICogQGNvbmZpZyBkZWxheSgwKSDliqjnlLvlu7bov5/ml7bpl7RcbiAqIEBjb25maWcgbG9vcCh0cnVlKVxuICogQGNvbmZpZyBnYXAoMCkg5b6q546v55qE6Ze06ZqU5pe26Ze0XG4gKiBAY29uZmlnIG9uZnJhbWVcbiAqIEBjb25maWcgZWFzaW5nKG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbmRlc3Ryb3kob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9ucmVzdGFydChvcHRpb25hbClcbiAqXG4gKiBUT0RPIHBhdXNlXG4gKi9cbmZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuICB0aGlzLl90YXJnZXQgPSBvcHRpb25zLnRhcmdldDsgLy8g55Sf5ZG95ZGo5pyfXG5cbiAgdGhpcy5fbGlmZSA9IG9wdGlvbnMubGlmZSB8fCAxMDAwOyAvLyDlu7bml7ZcblxuICB0aGlzLl9kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDsgLy8g5byA5aeL5pe26Ze0XG4gIC8vIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5fZGVsYXk7Ly8g5Y2V5L2N5q+r56eSXG5cbiAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy8g5piv5ZCm5b6q546vXG5cbiAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnMubG9vcDtcbiAgdGhpcy5nYXAgPSBvcHRpb25zLmdhcCB8fCAwO1xuICB0aGlzLmVhc2luZyA9IG9wdGlvbnMuZWFzaW5nIHx8ICdMaW5lYXInO1xuICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWU7XG4gIHRoaXMub25kZXN0cm95ID0gb3B0aW9ucy5vbmRlc3Ryb3k7XG4gIHRoaXMub25yZXN0YXJ0ID0gb3B0aW9ucy5vbnJlc3RhcnQ7XG4gIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbn1cblxuQ2xpcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBDbGlwLFxuICBzdGVwOiBmdW5jdGlvbiAoZ2xvYmFsVGltZSwgZGVsdGFUaW1lKSB7XG4gICAgLy8gU2V0IHN0YXJ0VGltZSBvbiBmaXJzdCBzdGVwLCBvciBfc3RhcnRUaW1lIG1heSBoYXMgbWlsbGVzZWNvbmRzIGRpZmZlcmVudCBiZXR3ZWVuIGNsaXBzXG4gICAgLy8gUEVORElOR1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgKyB0aGlzLl9kZWxheTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IGRlbHRhVGltZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGVyY2VudCA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgLyB0aGlzLl9saWZlOyAvLyDov5jmsqHlvIDlp4tcblxuICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBlcmNlbnQgPSBNYXRoLm1pbihwZXJjZW50LCAxKTtcbiAgICB2YXIgZWFzaW5nID0gdGhpcy5lYXNpbmc7XG4gICAgdmFyIGVhc2luZ0Z1bmMgPSB0eXBlb2YgZWFzaW5nID09ICdzdHJpbmcnID8gZWFzaW5nRnVuY3NbZWFzaW5nXSA6IGVhc2luZztcbiAgICB2YXIgc2NoZWR1bGUgPSB0eXBlb2YgZWFzaW5nRnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IGVhc2luZ0Z1bmMocGVyY2VudCkgOiBwZXJjZW50O1xuICAgIHRoaXMuZmlyZSgnZnJhbWUnLCBzY2hlZHVsZSk7IC8vIOe7k+adn1xuXG4gICAgaWYgKHBlcmNlbnQgPT0gMSkge1xuICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICB0aGlzLnJlc3RhcnQoZ2xvYmFsVGltZSk7IC8vIOmHjeaWsOW8gOWni+WRqOacn1xuICAgICAgICAvLyDmipvlh7rogIzkuI3mmK/nm7TmjqXosIPnlKjkuovku7bnm7TliLAgc3RhZ2UudXBkYXRlIOWQjuWGjee7n+S4gOiwg+eUqOi/meS6m+S6i+S7tlxuXG4gICAgICAgIHJldHVybiAncmVzdGFydCc7XG4gICAgICB9IC8vIOWKqOeUu+WujOaIkOWwhui/meS4quaOp+WItuWZqOagh+ivhuS4uuW+heWIoOmZpFxuICAgICAgLy8g5ZyoQW5pbWF0aW9uLnVwZGF0ZeS4rei/m+ihjOaJuemHj+WIoOmZpFxuXG5cbiAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAnZGVzdHJveSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uIChnbG9iYWxUaW1lKSB7XG4gICAgdmFyIHJlbWFpbmRlciA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgJSB0aGlzLl9saWZlO1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgLSByZW1haW5kZXIgKyB0aGlzLmdhcDtcbiAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcbiAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IGZhbHNlO1xuICB9LFxuICBmaXJlOiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBhcmcpIHtcbiAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuXG4gICAgaWYgKHRoaXNbZXZlbnRUeXBlXSkge1xuICAgICAgdGhpc1tldmVudFR5cGVdKHRoaXMuX3RhcmdldCwgYXJnKTtcbiAgICB9XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBDbGlwO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIOe8k+WKqOS7o+eggeadpeiHqiBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ibG9iL21hc3Rlci9zcmMvVHdlZW4uanNcbiAqIEBzZWUgaHR0cDovL3NvbGUuZ2l0aHViLmlvL3R3ZWVuLmpzL2V4YW1wbGVzLzAzX2dyYXBocy5odG1sXG4gKiBAZXhwb3J0cyB6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmdcbiAqL1xudmFyIGVhc2luZyA9IHtcbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGxpbmVhcjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICB9LFxuICAvLyDkuInmrKHmlrnnmoTnvJPliqjvvIh0XjPvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gIH0sXG4gIC8vIOWbm+asoeaWueeahOe8k+WKqO+8iHReNO+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSAtLWsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuICB9LFxuICAvLyDkupTmrKHmlrnnmoTnvJPliqjvvIh0XjXvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcbiAgfSxcbiAgLy8g5q2j5bym5puy57q/55qE57yT5Yqo77yIc2luKHQp77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIE1hdGguY29zKGsgKiBNYXRoLlBJIC8gMik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICB9LFxuICAvLyDmjIfmlbDmm7Lnur/nmoTnvJPliqjvvIgyXnTvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcbiAgfSxcbiAgLy8g5ZyG5b2i5puy57q/55qE57yT5Yqo77yIc3FydCgxLXReMinvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjaXJjdWxhck91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLWsgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG4gIH0sXG4gIC8vIOWIm+W7uuexu+S8vOS6juW8ueewp+WcqOWBnOatouWJjeadpeWbnuaMr+iNoeeahOWKqOeUu1xuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGVsYXN0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcbiAgfSxcbiAgLy8g5Zyo5p+Q5LiA5Yqo55S75byA5aeL5rK/5oyH56S655qE6Lev5b6E6L+b6KGM5Yqo55S75aSE55CG5YmN56iN56iN5pS25Zue6K+l5Yqo55S755qE56e75YqoXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tJbjogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcbiAgfSxcbiAgLy8g5Yib5bu65by56Lez5pWI5p6cXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZUluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gZWFzaW5nLmJvdW5jZU91dCgxIC0gayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZU91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA8IDEgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogayAqIGs7XG4gICAgfSBlbHNlIGlmIChrIDwgMiAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAxLjUgLyAyLjc1KSAqIGsgKyAwLjc1O1xuICAgIH0gZWxzZSBpZiAoayA8IDIuNSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjI1IC8gMi43NSkgKiBrICsgMC45Mzc1O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMi42MjUgLyAyLjc1KSAqIGsgKyAwLjk4NDM3NTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZUluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmIChrIDwgMC41KSB7XG4gICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZUluKGsgKiAyKSAqIDAuNTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWFzaW5nLmJvdW5jZU91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gZWFzaW5nO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9kZWZhdWx0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2lzc3Vlcy8xODkjaXNzdWVjb21tZW50LTIyNDkxOTgwOVxud2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB8fCBmdW5jdGlvbiAoZnVuYykge1xuICBzZXRUaW1lb3V0KGZ1bmMsIDE2KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBkcHIgPSAxOyAvLyBJZiBpbiBicm93c2VyIGVudmlyb25tZW50XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBkcHIgPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCAxKTtcbn1cbi8qKlxuICogY29uZmln6buY6K6k6YWN572u6aG5XG4gKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBkZWJ1Z+aXpeW/l+mAiemhue+8mmNhdGNoQnJ1c2hFeGNlcHRpb27kuLp0cnVl5LiL5pyJ5pWIXG4gKiAwIDog5LiN55Sf5oiQZGVidWfmlbDmja7vvIzlj5HluIPnlKhcbiAqIDEgOiDlvILluLjmipvlh7rvvIzosIPor5XnlKhcbiAqIDIgOiDmjqfliLblj7DovpPlh7rvvIzosIPor5XnlKhcbiAqL1xuXG5cbnZhciBkZWJ1Z01vZGUgPSAwOyAvLyByZXRpbmEg5bGP5bmV5LyY5YyWXG5cbnZhciBkZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuZXhwb3J0cy5kZWJ1Z01vZGUgPSBkZWJ1Z01vZGU7XG5leHBvcnRzLmRldmljZVBpeGVsUmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29uZmlnLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIG5vcm1hbGl6ZVJhZGlhbiA9IF91dGlsLm5vcm1hbGl6ZVJhZGlhbjtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbi8qKlxuICog5ZyG5byn5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBjeFxuICogQHBhcmFtICB7bnVtYmVyfSAgY3lcbiAqIEBwYXJhbSAge251bWJlcn0gIHJcbiAqIEBwYXJhbSAge251bWJlcn0gIHN0YXJ0QW5nbGVcbiAqIEBwYXJhbSAge251bWJlcn0gIGVuZEFuZ2xlXG4gKiBAcGFyYW0gIHtib29sZWFufSAgYW50aWNsb2Nrd2lzZVxuICogQHBhcmFtICB7bnVtYmVyfSBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gY29udGFpblN0cm9rZShjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgeCAtPSBjeDtcbiAgeSAtPSBjeTtcbiAgdmFyIGQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cbiAgaWYgKGQgLSBfbCA+IHIgfHwgZCArIF9sIDwgcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpICUgUEkyIDwgMWUtNCkge1xuICAgIC8vIElzIGEgY2lyY2xlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihzdGFydEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgZW5kQW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4KTtcblxuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgcmV0dXJuIGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUgfHwgYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZTtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL2FyYy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9hcmMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY3VydmUgPSByZXF1aXJlKFwiLi4vY29yZS9jdXJ2ZVwiKTtcblxuLyoqXG4gKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIHgzXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5M1xuICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7IC8vIFF1aWNrIHJlamVjdFxuXG4gIGlmICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbCAmJiB5ID4geTMgKyBfbCB8fCB5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCAmJiB5IDwgeTMgLSBfbCB8fCB4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCAmJiB4ID4geDMgKyBfbCB8fCB4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbCAmJiB4IDwgeDMgLSBfbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkID0gY3VydmUuY3ViaWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5LCBudWxsKTtcbiAgcmV0dXJuIGQgPD0gX2wgLyAyO1xufVxuXG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIOe6v+auteWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHZhciBfYSA9IDA7XG4gIHZhciBfYiA9IHgwOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoeDAgIT09IHgxKSB7XG4gICAgX2EgPSAoeTAgLSB5MSkgLyAoeDAgLSB4MSk7XG4gICAgX2IgPSAoeDAgKiB5MSAtIHgxICogeTApIC8gKHgwIC0geDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNYXRoLmFicyh4IC0geDApIDw9IF9sIC8gMjtcbiAgfVxuXG4gIHZhciB0bXAgPSBfYSAqIHggLSB5ICsgX2I7XG5cbiAgdmFyIF9zID0gdG1wICogdG1wIC8gKF9hICogX2EgKyAxKTtcblxuICByZXR1cm4gX3MgPD0gX2wgLyAyICogX2wgLyAyO1xufVxuXG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9saW5lLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIGxpbmUgPSByZXF1aXJlKFwiLi9saW5lXCIpO1xuXG52YXIgY3ViaWMgPSByZXF1aXJlKFwiLi9jdWJpY1wiKTtcblxudmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoXCIuL3F1YWRyYXRpY1wiKTtcblxudmFyIGFyYyA9IHJlcXVpcmUoXCIuL2FyY1wiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIG5vcm1hbGl6ZVJhZGlhbiA9IF91dGlsLm5vcm1hbGl6ZVJhZGlhbjtcblxudmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbnZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoXCIuL3dpbmRpbmdMaW5lXCIpO1xuXG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBFUFNJTE9OID0gMWUtNDtcblxuZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xufSAvLyDkuLTml7bmlbDnu4RcblxuXG52YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG52YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG5mdW5jdGlvbiBzd2FwRXh0cmVtYSgpIHtcbiAgdmFyIHRtcCA9IGV4dHJlbWFbMF07XG4gIGV4dHJlbWFbMF0gPSBleHRyZW1hWzFdO1xuICBleHRyZW1hWzFdID0gdG1wO1xufVxuXG5mdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gIC8vIFF1aWNrIHJlamVjdFxuICBpZiAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzIHx8IHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5Mykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB3ID0gMDtcbiAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICB2YXIgeTBfLCB5MV87XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJvb3RzW2ldOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICAgICAgdmFyIHVuaXQgPSB0ID09PSAwIHx8IHQgPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG5cbiAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPCAwKSB7XG4gICAgICAgIG5FeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hKTtcblxuICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgc3dhcEV4dHJlbWEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuXG4gICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICB5MV8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPT0gMikge1xuICAgICAgICAvLyDliIbmiJDkuInmrrXljZXosIPlh73mlbBcbiAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgZXh0cmVtYVsxXSkge1xuICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTMgPCB5MV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIOWIhuaIkOS4pOauteWNleiwg+WHveaVsFxuICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxufVxuXG5mdW5jdGlvbiB3aW5kaW5nUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgLy8gUXVpY2sgcmVqZWN0XG4gIGlmICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MiB8fCB5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5Mikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLnF1YWRyYXRpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG5cbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgdmFyIHcgPSAwO1xuICAgICAgdmFyIHlfID0gY3VydmUucXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgICAgdmFyIHVuaXQgPSByb290c1tpXSA9PT0gMCB8fCByb290c1tpXSA9PT0gMSA/IDAuNSA6IDE7XG4gICAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzW2ldKTtcblxuICAgICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgdyArPSB5XyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTIgPCB5XyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgIHZhciB1bml0ID0gcm9vdHNbMF0gPT09IDAgfHwgcm9vdHNbMF0gPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbMF0pO1xuXG4gICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgfVxuICB9XG59IC8vIFRPRE9cbi8vIEFyYyDml4vovaxcblxuXG5mdW5jdGlvbiB3aW5kaW5nQXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHkpIHtcbiAgeSAtPSBjeTtcblxuICBpZiAoeSA+IHIgfHwgeSA8IC1yKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgdG1wID0gTWF0aC5zcXJ0KHIgKiByIC0geSAqIHkpO1xuICByb290c1swXSA9IC10bXA7XG4gIHJvb3RzWzFdID0gdG1wO1xuICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cbiAgaWYgKGRpZmYgPCAxZS00KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHN0YXJ0QW5nbGUgPSAwO1xuICAgIGVuZEFuZ2xlID0gUEkyO1xuICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuXG4gICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgIHJldHVybiBkaXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICBlbmRBbmdsZSArPSBQSTI7XG4gIH1cblxuICB2YXIgdyA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICB2YXIgeF8gPSByb290c1tpXTtcblxuICAgIGlmICh4XyArIGN4ID4geCkge1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4Xyk7XG4gICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcblxuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSA9IFBJMiArIGFuZ2xlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSB8fCBhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKSB7XG4gICAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkgLyAyICYmIGFuZ2xlIDwgTWF0aC5QSSAqIDEuNSkge1xuICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgIH1cblxuICAgICAgICB3ICs9IGRpcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdztcbn1cblxuZnVuY3Rpb24gY29udGFpblBhdGgoZGF0YSwgbGluZVdpZHRoLCBpc1N0cm9rZSwgeCwgeSkge1xuICB2YXIgdyA9IDA7XG4gIHZhciB4aSA9IDA7XG4gIHZhciB5aSA9IDA7XG4gIHZhciB4MCA9IDA7XG4gIHZhciB5MCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICB2YXIgY21kID0gZGF0YVtpKytdOyAvLyBCZWdpbiBhIG5ldyBzdWJwYXRoXG5cbiAgICBpZiAoY21kID09PSBDTUQuTSAmJiBpID4gMSkge1xuICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc3VicGF0aFxuICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgIH0gLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgLy8gfVxuXG4gICAgfVxuXG4gICAgaWYgKGkgPT0gMSkge1xuICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgIC8vXG4gICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcbiAgICAgIHgwID0geGk7XG4gICAgICB5MCA9IHlpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIENNRC5NOlxuICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgIHhpID0geDA7XG4gICAgICAgIHlpID0geTA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5MOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5DOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAoY3ViaWMuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5ROlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAocXVhZHJhdGljLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdRdWFkcmF0aWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5BOlxuICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgdGhldGEgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBkVGhldGEgPSBkYXRhW2krK107IC8vIFRPRE8gQXJjIOaXi+i9rFxuXG4gICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHgxID0gTWF0aC5jb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odGhldGEpICogcnkgKyBjeTsgLy8g5LiN5piv55u05o6l5L2/55SoIGFyYyDlkb3ku6RcblxuICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgIHkwID0geTE7XG4gICAgICAgIH0gLy8genIg5L2/55Soc2NhbGXmnaXmqKHmi5/mpK3lnIYsIOi/memHjOS5n+WvuXjlgZrkuIDlrprnmoTnvKnmlL5cblxuXG4gICAgICAgIHZhciBfeCA9ICh4IC0gY3gpICogcnkgLyByeCArIGN4O1xuXG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChhcmMuY29udGFpblN0cm9rZShjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsIGxpbmVXaWR0aCwgX3gsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nQXJjKGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSwgX3gsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5SOlxuICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB4MSA9IHgwICsgd2lkdGg7XG4gICAgICAgIHZhciB5MSA9IHkwICsgaGVpZ2h0O1xuXG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgxLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MSwgeTEsIHgwLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGSVhNRSBDbG9ja3dpc2UgP1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDAsIHkxLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeGksIHlpLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTsgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgLy8gRklYTUUgc3VicGF0aHMgbWF5IG92ZXJsYXBcbiAgICAgICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IHgwO1xuICAgICAgICB5aSA9IHkwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzU3Ryb2tlICYmICFpc0Fyb3VuZEVxdWFsKHlpLCB5MCkpIHtcbiAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIHcgIT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW4ocGF0aERhdGEsIHgsIHkpIHtcbiAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UocGF0aERhdGEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIGxpbmVXaWR0aCwgdHJ1ZSwgeCwgeSk7XG59XG5cbmV4cG9ydHMuY29udGFpbiA9IGNvbnRhaW47XG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHdpbmRpbmdMaW5lID0gcmVxdWlyZShcIi4vd2luZGluZ0xpbmVcIik7XG5cbnZhciBFUFNJTE9OID0gMWUtODtcblxuZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xufVxuXG5mdW5jdGlvbiBjb250YWluKHBvaW50cywgeCwgeSkge1xuICB2YXIgdyA9IDA7XG4gIHZhciBwID0gcG9pbnRzWzBdO1xuXG4gIGlmICghcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAyID0gcG9pbnRzW2ldO1xuICAgIHcgKz0gd2luZGluZ0xpbmUocFswXSwgcFsxXSwgcDJbMF0sIHAyWzFdLCB4LCB5KTtcbiAgICBwID0gcDI7XG4gIH0gLy8gQ2xvc2UgcG9seWdvblxuXG5cbiAgdmFyIHAwID0gcG9pbnRzWzBdO1xuXG4gIGlmICghaXNBcm91bmRFcXVhbChwWzBdLCBwMFswXSkgfHwgIWlzQXJvdW5kRXF1YWwocFsxXSwgcDBbMV0pKSB7XG4gICAgdyArPSB3aW5kaW5nTGluZShwWzBdLCBwWzFdLCBwMFswXSwgcDBbMV0sIHgsIHkpO1xuICB9XG5cbiAgcmV0dXJuIHcgIT09IDA7XG59XG5cbmV4cG9ydHMuY29udGFpbiA9IGNvbnRhaW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3BvbHlnb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2N1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbnZhciBxdWFkcmF0aWNQcm9qZWN0UG9pbnQgPSBfY3VydmUucXVhZHJhdGljUHJvamVjdFBvaW50O1xuXG4vKipcbiAqIOS6jOasoei0neWhnuWwlOabsue6v+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MlxuICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZCA9IHF1YWRyYXRpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4LCB5LCBudWxsKTtcbiAgcmV0dXJuIGQgPD0gX2wgLyAyO1xufVxuXG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBpbWFnZUhlbHBlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL2hlbHBlci9pbWFnZVwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGdldENvbnRleHQgPSBfdXRpbC5nZXRDb250ZXh0O1xudmFyIGV4dGVuZCA9IF91dGlsLmV4dGVuZDtcbnZhciByZXRyaWV2ZTIgPSBfdXRpbC5yZXRyaWV2ZTI7XG52YXIgcmV0cmlldmUzID0gX3V0aWwucmV0cmlldmUzO1xudmFyIHRleHRXaWR0aENhY2hlID0ge307XG52YXIgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbnZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG52YXIgU1RZTEVfUkVHID0gL1xceyhbYS16QS1aMC05X10rKVxcfChbXn1dKilcXH0vZztcbnZhciBERUZBVUxUX0ZPTlQgPSAnMTJweCBzYW5zLXNlcmlmJzsgLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxudmFyIG1ldGhvZHMgPSB7fTtcblxuZnVuY3Rpb24gJG92ZXJyaWRlKG5hbWUsIGZuKSB7XG4gIG1ldGhvZHNbbmFtZV0gPSBmbjtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRXaWR0aCh0ZXh0LCBmb250KSB7XG4gIGZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgdmFyIGtleSA9IHRleHQgKyAnOicgKyBmb250O1xuXG4gIGlmICh0ZXh0V2lkdGhDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIHRleHRXaWR0aENhY2hlW2tleV07XG4gIH1cblxuICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICB2YXIgd2lkdGggPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIC8vIHRleHRDb250YWluLm1lYXN1cmVUZXh0IG1heSBiZSBvdmVycmlkZWQgaW4gU1ZHIG9yIFZNTFxuICAgIHdpZHRoID0gTWF0aC5tYXgobWVhc3VyZVRleHQodGV4dExpbmVzW2ldLCBmb250KS53aWR0aCwgd2lkdGgpO1xuICB9XG5cbiAgaWYgKHRleHRXaWR0aENhY2hlQ291bnRlciA+IFRFWFRfQ0FDSEVfTUFYKSB7XG4gICAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbiAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICB9XG5cbiAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyKys7XG4gIHRleHRXaWR0aENhY2hlW2tleV0gPSB3aWR0aDtcbiAgcmV0dXJuIHdpZHRoO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dEFsaWduPSdsZWZ0J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dFZlcnRpY2FsQWxpZ249J3RvcCddXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbdGV4dFBhZGRpbmddXG4gKiBAcGFyYW0ge09iamVjdH0gW3JpY2hdXG4gKiBAcGFyYW0ge09iamVjdH0gW3RydW5jYXRlXVxuICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGluZUhlaWdodH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgcmljaCwgdHJ1bmNhdGUpIHtcbiAgcmV0dXJuIHJpY2ggPyBnZXRSaWNoVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSA6IGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGxhaW5UZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpIHtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IHBhcnNlUGxhaW5UZXh0KHRleHQsIGZvbnQsIHRleHRQYWRkaW5nLCB0cnVuY2F0ZSk7XG4gIHZhciBvdXRlcldpZHRoID0gZ2V0V2lkdGgodGV4dCwgZm9udCk7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgb3V0ZXJXaWR0aCArPSB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdO1xuICB9XG5cbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgeCA9IGFkanVzdFRleHRYKDAsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gIHZhciB5ID0gYWRqdXN0VGV4dFkoMCwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbiAgcmVjdC5saW5lSGVpZ2h0ID0gY29udGVudEJsb2NrLmxpbmVIZWlnaHQ7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRSaWNoVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVJpY2hUZXh0KHRleHQsIHtcbiAgICByaWNoOiByaWNoLFxuICAgIHRydW5jYXRlOiB0cnVuY2F0ZSxcbiAgICBmb250OiBmb250LFxuICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgIHRleHRQYWRkaW5nOiB0ZXh0UGFkZGluZ1xuICB9KTtcbiAgdmFyIG91dGVyV2lkdGggPSBjb250ZW50QmxvY2sub3V0ZXJXaWR0aDtcbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgeCA9IGFkanVzdFRleHRYKDAsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gIHZhciB5ID0gYWRqdXN0VGV4dFkoMCwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFkanVzdGVkIHguXG4gKi9cblxuXG5mdW5jdGlvbiBhZGp1c3RUZXh0WCh4LCB3aWR0aCwgdGV4dEFsaWduKSB7XG4gIC8vIEZJWE1FIFJpZ2h0IHRvIGxlZnQgbGFuZ3VhZ2VcbiAgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gd2lkdGg7XG4gIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gd2lkdGggLyAyO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICogQHJldHVybiB7bnVtYmVyfSBBZGp1c3RlZCB5LlxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFkoeSwgaGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbikge1xuICBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgeSAtPSBoZWlnaHQgLyAyO1xuICB9IGVsc2UgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3Rpcm5nfSB0ZXh0UG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHt4LCB5LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWdufVxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgZGlzdGFuY2UpIHtcbiAgdmFyIHggPSByZWN0Lng7XG4gIHZhciB5ID0gcmVjdC55O1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG5cbiAgc3dpdGNoICh0ZXh0UG9zaXRpb24pIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHggLT0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgeCArPSBkaXN0YW5jZSArIHdpZHRoO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSAtPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoZWlnaHQgKyBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUxlZnQnOlxuICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3AnOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVRvcExlZnQnOlxuICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVRvcFJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b21MZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tUmlnaHQnOlxuICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgfTtcbn1cbi8qKlxuICogU2hvdyBlbGxpcHNpcyBpZiBvdmVyZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSAge3N0cmluZ30gY29udGFpbmVyV2lkdGhcbiAqIEBwYXJhbSAge3N0cmluZ30gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBbZWxsaXBzaXM9Jy4uLiddXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJdGVyYXRpb25zPTNdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLm1pbkNoYXI9MF0gSWYgdHJ1bmNhdGUgcmVzdWx0IGFyZSBsZXNzXG4gKiAgICAgICAgICAgICAgICAgIHRoZW4gbWluQ2hhciwgZWxsaXBzaXMgd2lsbCBub3Qgc2hvdywgd2hpY2ggaXNcbiAqICAgICAgICAgICAgICAgICAgYmV0dGVyIGZvciB1c2VyIGhpbnQgaW4gc29tZSBjYXNlcy5cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMucGxhY2Vob2xkZXI9JyddIFdoZW4gYWxsIHRydW5jYXRlZCwgdXNlIHRoZSBwbGFjZWhvbGRlci5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0LCBjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFjb250YWluZXJXaWR0aCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0ZXh0TGluZXMgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7XG4gIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKGNvbnRhaW5lcldpZHRoLCBmb250LCBlbGxpcHNpcywgb3B0aW9ucyk7IC8vIEZJWE1FXG4gIC8vIEl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0aGF0IGV2ZXJ5IGxpbmUgaGFzICcuLi4nIHdoZW4gdHJ1bmNhdGUgbXVsdGlwbGUgbGluZXMuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHRleHRMaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZSh0ZXh0TGluZXNbaV0sIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIG9wdGlvbnMuZm9udCA9IGZvbnQ7XG4gIHZhciBlbGxpcHNpcyA9IHJldHJpZXZlMihlbGxpcHNpcywgJy4uLicpO1xuICBvcHRpb25zLm1heEl0ZXJhdGlvbnMgPSByZXRyaWV2ZTIob3B0aW9ucy5tYXhJdGVyYXRpb25zLCAyKTtcbiAgdmFyIG1pbkNoYXIgPSBvcHRpb25zLm1pbkNoYXIgPSByZXRyaWV2ZTIob3B0aW9ucy5taW5DaGFyLCAwKTsgLy8gRklYTUVcbiAgLy8gT3RoZXIgbGFuZ3VhZ2VzP1xuXG4gIG9wdGlvbnMuY25DaGFyV2lkdGggPSBnZXRXaWR0aCgn5Zu9JywgZm9udCk7IC8vIEZJWE1FXG4gIC8vIENvbnNpZGVyIHByb3BvcnRpb25hbCBmb250P1xuXG4gIHZhciBhc2NDaGFyV2lkdGggPSBvcHRpb25zLmFzY0NoYXJXaWR0aCA9IGdldFdpZHRoKCdhJywgZm9udCk7XG4gIG9wdGlvbnMucGxhY2Vob2xkZXIgPSByZXRyaWV2ZTIob3B0aW9ucy5wbGFjZWhvbGRlciwgJycpOyAvLyBFeGFtcGxlIDE6IG1pbkNoYXI6IDMsIHRleHQ6ICdhc2RmenhjdicsIHRydW5jYXRlIHJlc3VsdDogJ2FzZGYnLCBidXQgbm90OiAnYS4uLicuXG4gIC8vIEV4YW1wbGUgMjogbWluQ2hhcjogMywgdGV4dDogJ+e7tOW6picsIHRydW5jYXRlIHJlc3VsdDogJ+e7tCcsIGJ1dCBub3Q6ICcuLi4nLlxuXG4gIHZhciBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCA9IE1hdGgubWF4KDAsIGNvbnRhaW5lcldpZHRoIC0gMSk7IC8vIFJlc2VydmUgc29tZSBnYXAuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DaGFyICYmIGNvbnRlbnRXaWR0aCA+PSBhc2NDaGFyV2lkdGg7IGkrKykge1xuICAgIGNvbnRlbnRXaWR0aCAtPSBhc2NDaGFyV2lkdGg7XG4gIH1cblxuICB2YXIgZWxsaXBzaXNXaWR0aCA9IGdldFdpZHRoKGVsbGlwc2lzKTtcblxuICBpZiAoZWxsaXBzaXNXaWR0aCA+IGNvbnRlbnRXaWR0aCkge1xuICAgIGVsbGlwc2lzID0gJyc7XG4gICAgZWxsaXBzaXNXaWR0aCA9IDA7XG4gIH1cblxuICBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCAtIGVsbGlwc2lzV2lkdGg7XG4gIG9wdGlvbnMuZWxsaXBzaXMgPSBlbGxpcHNpcztcbiAgb3B0aW9ucy5lbGxpcHNpc1dpZHRoID0gZWxsaXBzaXNXaWR0aDtcbiAgb3B0aW9ucy5jb250ZW50V2lkdGggPSBjb250ZW50V2lkdGg7XG4gIG9wdGlvbnMuY29udGFpbmVyV2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlU2luZ2xlTGluZSh0ZXh0TGluZSwgb3B0aW9ucykge1xuICB2YXIgY29udGFpbmVyV2lkdGggPSBvcHRpb25zLmNvbnRhaW5lcldpZHRoO1xuICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IG9wdGlvbnMuY29udGVudFdpZHRoO1xuXG4gIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgbGluZVdpZHRoID0gZ2V0V2lkdGgodGV4dExpbmUsIGZvbnQpO1xuXG4gIGlmIChsaW5lV2lkdGggPD0gY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gdGV4dExpbmU7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDs7IGorKykge1xuICAgIGlmIChsaW5lV2lkdGggPD0gY29udGVudFdpZHRoIHx8IGogPj0gb3B0aW9ucy5tYXhJdGVyYXRpb25zKSB7XG4gICAgICB0ZXh0TGluZSArPSBvcHRpb25zLmVsbGlwc2lzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHN1Ykxlbmd0aCA9IGogPT09IDAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBvcHRpb25zLmFzY0NoYXJXaWR0aCwgb3B0aW9ucy5jbkNoYXJXaWR0aCkgOiBsaW5lV2lkdGggPiAwID8gTWF0aC5mbG9vcih0ZXh0TGluZS5sZW5ndGggKiBjb250ZW50V2lkdGggLyBsaW5lV2lkdGgpIDogMDtcbiAgICB0ZXh0TGluZSA9IHRleHRMaW5lLnN1YnN0cigwLCBzdWJMZW5ndGgpO1xuICAgIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcbiAgfVxuXG4gIGlmICh0ZXh0TGluZSA9PT0gJycpIHtcbiAgICB0ZXh0TGluZSA9IG9wdGlvbnMucGxhY2Vob2xkZXI7XG4gIH1cblxuICByZXR1cm4gdGV4dExpbmU7XG59XG5cbmZ1bmN0aW9uIGVzdGltYXRlTGVuZ3RoKHRleHQsIGNvbnRlbnRXaWR0aCwgYXNjQ2hhcldpZHRoLCBjbkNoYXJXaWR0aCkge1xuICB2YXIgd2lkdGggPSAwO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICh2YXIgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW4gJiYgd2lkdGggPCBjb250ZW50V2lkdGg7IGkrKykge1xuICAgIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICB3aWR0aCArPSAwIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDEyNyA/IGFzY0NoYXJXaWR0aCA6IGNuQ2hhcldpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtudW1iZXJ9IGxpbmUgaGVpZ2h0XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMaW5lSGVpZ2h0KGZvbnQpIHtcbiAgLy8gRklYTUUgQSByb3VnaCBhcHByb2FjaC5cbiAgcmV0dXJuIGdldFdpZHRoKCflm70nLCBmb250KTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpZHRoXG4gKi9cblxuXG5mdW5jdGlvbiBtZWFzdXJlVGV4dCh0ZXh0LCBmb250KSB7XG4gIHJldHVybiBtZXRob2RzLm1lYXN1cmVUZXh0KHRleHQsIGZvbnQpO1xufSAvLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxuXG5cbm1ldGhvZHMubWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgZm9udCkge1xuICB2YXIgY3R4ID0gZ2V0Q29udGV4dCgpO1xuICBjdHguZm9udCA9IGZvbnQgfHwgREVGQVVMVF9GT05UO1xuICByZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xufTtcbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge09iamVjdH0gW3RydW5jYXRlXVxuICogQHJldHVybiB7T2JqZWN0fSBibG9jazoge2xpbmVIZWlnaHQsIGxpbmVzLCBoZWlnaHQsIG91dGVySGVpZ2h0fVxuICogIE5vdGljZTogZm9yIHBlcmZvcm1hbmNlLCBkbyBub3QgY2FsY3VsYXRlIG91dGVyV2lkdGggdXRpbCBuZWVkZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCBwYWRkaW5nLCB0cnVuY2F0ZSkge1xuICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuICB2YXIgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoZm9udCk7XG4gIHZhciBsaW5lcyA9IHRleHQgPyB0ZXh0LnNwbGl0KCdcXG4nKSA6IFtdO1xuICB2YXIgaGVpZ2h0ID0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodDtcbiAgdmFyIG91dGVySGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIGlmIChwYWRkaW5nKSB7XG4gICAgb3V0ZXJIZWlnaHQgKz0gcGFkZGluZ1swXSArIHBhZGRpbmdbMl07XG4gIH1cblxuICBpZiAodGV4dCAmJiB0cnVuY2F0ZSkge1xuICAgIHZhciB0cnVuY091dGVySGVpZ2h0ID0gdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG4gICAgdmFyIHRydW5jT3V0ZXJXaWR0aCA9IHRydW5jYXRlLm91dGVyV2lkdGg7XG5cbiAgICBpZiAodHJ1bmNPdXRlckhlaWdodCAhPSBudWxsICYmIG91dGVySGVpZ2h0ID4gdHJ1bmNPdXRlckhlaWdodCkge1xuICAgICAgdGV4dCA9ICcnO1xuICAgICAgbGluZXMgPSBbXTtcbiAgICB9IGVsc2UgaWYgKHRydW5jT3V0ZXJXaWR0aCAhPSBudWxsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHByZXBhcmVUcnVuY2F0ZU9wdGlvbnModHJ1bmNPdXRlcldpZHRoIC0gKHBhZGRpbmcgPyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSA6IDApLCBmb250LCB0cnVuY2F0ZS5lbGxpcHNpcywge1xuICAgICAgICBtaW5DaGFyOiB0cnVuY2F0ZS5taW5DaGFyLFxuICAgICAgICBwbGFjZWhvbGRlcjogdHJ1bmNhdGUucGxhY2Vob2xkZXJcbiAgICAgIH0pOyAvLyBGSVhNRVxuICAgICAgLy8gSXQgaXMgbm90IGFwcHJvcHJpYXRlIHRoYXQgZXZlcnkgbGluZSBoYXMgJy4uLicgd2hlbiB0cnVuY2F0ZSBtdWx0aXBsZSBsaW5lcy5cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gdHJ1bmNhdGVTaW5nbGVMaW5lKGxpbmVzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lcyxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBvdXRlckhlaWdodDogb3V0ZXJIZWlnaHQsXG4gICAgbGluZUhlaWdodDogbGluZUhlaWdodFxuICB9O1xufVxuLyoqXG4gKiBGb3IgZXhhbXBsZTogJ3NvbWUgdGV4dCB7YXxzb21lIHRleHR9b3RoZXIgdGV4dHtifHNvbWUgdGV4dH14eHh7Y3x9eHh4J1xuICogQWxzbyBjb25zaWRlciAnYmJiYnthfHh4eFxcbnp6en14eHh4XFxuYWFhYScuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICogQHJldHVybiB7T2JqZWN0fSBibG9ja1xuICoge1xuICogICAgICB3aWR0aCxcbiAqICAgICAgaGVpZ2h0LFxuICogICAgICBsaW5lczogW3tcbiAqICAgICAgICAgIGxpbmVIZWlnaHQsXG4gKiAgICAgICAgICB3aWR0aCxcbiAqICAgICAgICAgIHRva2VuczogW1t7XG4gKiAgICAgICAgICAgICAgc3R5bGVOYW1lLFxuICogICAgICAgICAgICAgIHRleHQsXG4gKiAgICAgICAgICAgICAgd2lkdGgsICAgICAgLy8gaW5jbHVkZSB0ZXh0UGFkZGluZ1xuICogICAgICAgICAgICAgIGhlaWdodCwgICAgIC8vIGluY2x1ZGUgdGV4dFBhZGRpbmdcbiAqICAgICAgICAgICAgICB0ZXh0V2lkdGgsIC8vIHB1cmUgdGV4dCB3aWR0aFxuICogICAgICAgICAgICAgIHRleHRIZWlnaHQsIC8vIHB1cmUgdGV4dCBoZWlnaHRcbiAqICAgICAgICAgICAgICBsaW5lSGVpaGd0LFxuICogICAgICAgICAgICAgIGZvbnQsXG4gKiAgICAgICAgICAgICAgdGV4dEFsaWduLFxuICogICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduXG4gKiAgICAgICAgICB9XSwgWy4uLl0sIC4uLl1cbiAqICAgICAgfSwgLi4uXVxuICogfVxuICogSWYgc3R5bGVOYW1lIGlzIHVuZGVmaW5lZCwgaXQgaXMgcGxhaW4gdGV4dC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpIHtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IHtcbiAgICBsaW5lczogW10sXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbiAgfVxuXG4gIHZhciBsYXN0SW5kZXggPSBTVFlMRV9SRUcubGFzdEluZGV4ID0gMDtcbiAgdmFyIHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IFNUWUxFX1JFRy5leGVjKHRleHQpKSAhPSBudWxsKSB7XG4gICAgdmFyIG1hdGNoZWRJbmRleCA9IHJlc3VsdC5pbmRleDtcblxuICAgIGlmIChtYXRjaGVkSW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoZWRJbmRleCkpO1xuICAgIH1cblxuICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCByZXN1bHRbMl0sIHJlc3VsdFsxXSk7XG4gICAgbGFzdEluZGV4ID0gU1RZTEVfUkVHLmxhc3RJbmRleDtcbiAgfVxuXG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgsIHRleHQubGVuZ3RoKSk7XG4gIH1cblxuICB2YXIgbGluZXMgPSBjb250ZW50QmxvY2subGluZXM7XG4gIHZhciBjb250ZW50SGVpZ2h0ID0gMDtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IDA7IC8vIEZvciBgdGV4dFdpZHRoOiAxMDAlYFxuXG4gIHZhciBwZW5kaW5nTGlzdCA9IFtdO1xuICB2YXIgc3RsUGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgdHJ1bmNhdGUgPSBzdHlsZS50cnVuY2F0ZTtcbiAgdmFyIHRydW5jYXRlV2lkdGggPSB0cnVuY2F0ZSAmJiB0cnVuY2F0ZS5vdXRlcldpZHRoO1xuICB2YXIgdHJ1bmNhdGVIZWlnaHQgPSB0cnVuY2F0ZSAmJiB0cnVuY2F0ZS5vdXRlckhlaWdodDtcblxuICBpZiAoc3RsUGFkZGluZykge1xuICAgIHRydW5jYXRlV2lkdGggIT0gbnVsbCAmJiAodHJ1bmNhdGVXaWR0aCAtPSBzdGxQYWRkaW5nWzFdICsgc3RsUGFkZGluZ1szXSk7XG4gICAgdHJ1bmNhdGVIZWlnaHQgIT0gbnVsbCAmJiAodHJ1bmNhdGVIZWlnaHQgLT0gc3RsUGFkZGluZ1swXSArIHN0bFBhZGRpbmdbMl0pO1xuICB9IC8vIENhbGN1bGF0ZSBsYXlvdXQgaW5mbyBvZiB0b2tlbnMuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICB2YXIgbGluZUhlaWdodCA9IDA7XG4gICAgdmFyIGxpbmVXaWR0aCA9IDA7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmUudG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdG9rZW4gPSBsaW5lLnRva2Vuc1tqXTtcbiAgICAgIHZhciB0b2tlblN0eWxlID0gdG9rZW4uc3R5bGVOYW1lICYmIHN0eWxlLnJpY2hbdG9rZW4uc3R5bGVOYW1lXSB8fCB7fTsgLy8gdGV4dFBhZGRpbmcgc2hvdWxkIG5vdCBpbmhlcml0IGZyb20gc3R5bGUuXG5cbiAgICAgIHZhciB0ZXh0UGFkZGluZyA9IHRva2VuLnRleHRQYWRkaW5nID0gdG9rZW5TdHlsZS50ZXh0UGFkZGluZzsgLy8gdGV4dEZvbnQgaGFzIGJlZW4gYXNpZ25lZCB0byBmb250IGJ5IGBub3JtYWxpemVTdHlsZWAuXG5cbiAgICAgIHZhciBmb250ID0gdG9rZW4uZm9udCA9IHRva2VuU3R5bGUuZm9udCB8fCBzdHlsZS5mb250OyAvLyB0ZXh0SGVpZ2h0IGNhbiBiZSB1c2VkIHdoZW4gdGV4dFZlcnRpY2FsQWxpZ24gaXMgc3BlY2lmaWVkIGluIHRva2VuLlxuXG4gICAgICB2YXIgdG9rZW5IZWlnaHQgPSB0b2tlbi50ZXh0SGVpZ2h0ID0gcmV0cmlldmUyKCAvLyB0ZXh0SGVpZ2h0IHNob3VsZCBub3QgYmUgaW5oZXJpdGVkLCBjb25zaWRlciBpdCBjYW4gYmUgc3BlY2lmaWVkXG4gICAgICAvLyBhcyBib3ggaGVpZ2h0IG9mIHRoZSBibG9jay5cbiAgICAgIHRva2VuU3R5bGUudGV4dEhlaWdodCwgZ2V0TGluZUhlaWdodChmb250KSk7XG4gICAgICB0ZXh0UGFkZGluZyAmJiAodG9rZW5IZWlnaHQgKz0gdGV4dFBhZGRpbmdbMF0gKyB0ZXh0UGFkZGluZ1syXSk7XG4gICAgICB0b2tlbi5oZWlnaHQgPSB0b2tlbkhlaWdodDtcbiAgICAgIHRva2VuLmxpbmVIZWlnaHQgPSByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0TGluZUhlaWdodCwgc3R5bGUudGV4dExpbmVIZWlnaHQsIHRva2VuSGVpZ2h0KTtcbiAgICAgIHRva2VuLnRleHRBbGlnbiA9IHRva2VuU3R5bGUgJiYgdG9rZW5TdHlsZS50ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduO1xuICAgICAgdG9rZW4udGV4dFZlcnRpY2FsQWxpZ24gPSB0b2tlblN0eWxlICYmIHRva2VuU3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gfHwgJ21pZGRsZSc7XG5cbiAgICAgIGlmICh0cnVuY2F0ZUhlaWdodCAhPSBudWxsICYmIGNvbnRlbnRIZWlnaHQgKyB0b2tlbi5saW5lSGVpZ2h0ID4gdHJ1bmNhdGVIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lczogW10sXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRva2VuLnRleHRXaWR0aCA9IGdldFdpZHRoKHRva2VuLnRleHQsIGZvbnQpO1xuICAgICAgdmFyIHRva2VuV2lkdGggPSB0b2tlblN0eWxlLnRleHRXaWR0aDtcbiAgICAgIHZhciB0b2tlbldpZHRoTm90U3BlY2lmaWVkID0gdG9rZW5XaWR0aCA9PSBudWxsIHx8IHRva2VuV2lkdGggPT09ICdhdXRvJzsgLy8gUGVyY2VudCB3aWR0aCwgY2FuIGJlIGAxMDAlYCwgY2FuIGJlIHVzZWQgaW4gZHJhd2luZyBzZXBhcmF0ZVxuICAgICAgLy8gbGluZSB3aGVuIGJveCB3aWR0aCBpcyBuZWVkZWQgdG8gYmUgYXV0by5cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbldpZHRoID09PSAnc3RyaW5nJyAmJiB0b2tlbldpZHRoLmNoYXJBdCh0b2tlbldpZHRoLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgdG9rZW4ucGVyY2VudFdpZHRoID0gdG9rZW5XaWR0aDtcbiAgICAgICAgcGVuZGluZ0xpc3QucHVzaCh0b2tlbik7XG4gICAgICAgIHRva2VuV2lkdGggPSAwOyAvLyBEbyBub3QgdHJ1bmNhdGUgaW4gdGhpcyBjYXNlLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHVzZXIgY2FzZVxuICAgICAgICAvLyBhbmQgaXQgaXMgdG9vIGNvbXBsaWNhdGVkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva2VuV2lkdGhOb3RTcGVjaWZpZWQpIHtcbiAgICAgICAgICB0b2tlbldpZHRoID0gdG9rZW4udGV4dFdpZHRoOyAvLyBGSVhNRTogSWYgaW1hZ2UgaXMgbm90IGxvYWRlZCBhbmQgdGV4dFdpZHRoIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGxpbmdcbiAgICAgICAgICAvLyBgZ2V0Qm91bmRpbmdSZWN0KClgIHdpbGwgbm90IGdldCBjb3JyZWN0IHJlc3VsdC5cblxuICAgICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gdG9rZW5TdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgIHZhciBiZ0ltZyA9IHRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTsgLy8gVXNlIGNhc2VzOlxuICAgICAgICAgIC8vICgxKSBJZiBpbWFnZSBpcyBub3QgbG9hZGVkLCBpdCB3aWxsIGJlIGxvYWRlZCBhdCByZW5kZXIgcGhhc2UgYW5kIGNhbGxcbiAgICAgICAgICAvLyBgZGlydHkoKWAgYW5kIGB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGxvYWRlZFxuICAgICAgICAgIC8vIGltYWdlLCBhbmQgdGhlbiB0aGUgcmlnaHQgc2l6ZSB3aWxsIGJlIGNhbGN1bGF0ZWQgaGVyZSBhdCB0aGUgbmV4dCB0aWNrLlxuICAgICAgICAgIC8vIFNlZSBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qc2AuXG4gICAgICAgICAgLy8gKDIpIElmIGltYWdlIGxvYWRlZCwgYW5kIGB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlYCBpcyBpbWFnZSBzcmMgc3RyaW5nLFxuICAgICAgICAgIC8vIHVzZSBgaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2VgIHRvIGZpbmQgY2FjaGVkIGltYWdlLlxuICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5maW5kRXhpc3RJbWFnZWAgd2lsbCBhbHdheXMgYmUgY2FsbGVkIGhlcmUgYmVmb3JlXG4gICAgICAgICAgLy8gYGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2VgIGluIGBncmFwaGljL2hlbHBlci90ZXh0LmpzI3JlbmRlclJpY2hUZXh0YFxuICAgICAgICAgIC8vIHdoaWNoIGVuc3VyZXMgdGhhdCBpbWFnZSB3aWxsIG5vdCBiZSByZW5kZXJlZCBiZWZvcmUgY29ycmVjdCBzaXplIGNhbGN1YWx0ZWQuXG5cbiAgICAgICAgICBpZiAoYmdJbWcpIHtcbiAgICAgICAgICAgIGJnSW1nID0gaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2UoYmdJbWcpO1xuXG4gICAgICAgICAgICBpZiAoaW1hZ2VIZWxwZXIuaXNJbWFnZVJlYWR5KGJnSW1nKSkge1xuICAgICAgICAgICAgICB0b2tlbldpZHRoID0gTWF0aC5tYXgodG9rZW5XaWR0aCwgYmdJbWcud2lkdGggKiB0b2tlbkhlaWdodCAvIGJnSW1nLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhZGRpbmdXID0gdGV4dFBhZGRpbmcgPyB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdIDogMDtcbiAgICAgICAgdG9rZW5XaWR0aCArPSBwYWRkaW5nVztcbiAgICAgICAgdmFyIHJlbWlhblRydW5jV2lkdGggPSB0cnVuY2F0ZVdpZHRoICE9IG51bGwgPyB0cnVuY2F0ZVdpZHRoIC0gbGluZVdpZHRoIDogbnVsbDtcblxuICAgICAgICBpZiAocmVtaWFuVHJ1bmNXaWR0aCAhPSBudWxsICYmIHJlbWlhblRydW5jV2lkdGggPCB0b2tlbldpZHRoKSB7XG4gICAgICAgICAgaWYgKCF0b2tlbldpZHRoTm90U3BlY2lmaWVkIHx8IHJlbWlhblRydW5jV2lkdGggPCBwYWRkaW5nVykge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9ICcnO1xuICAgICAgICAgICAgdG9rZW4udGV4dFdpZHRoID0gdG9rZW5XaWR0aCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSB0cnVuY2F0ZVRleHQodG9rZW4udGV4dCwgcmVtaWFuVHJ1bmNXaWR0aCAtIHBhZGRpbmdXLCBmb250LCB0cnVuY2F0ZS5lbGxpcHNpcywge1xuICAgICAgICAgICAgICBtaW5DaGFyOiB0cnVuY2F0ZS5taW5DaGFyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRva2VuLnRleHRXaWR0aCA9IGdldFdpZHRoKHRva2VuLnRleHQsIGZvbnQpO1xuICAgICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aCArIHBhZGRpbmdXO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5lV2lkdGggKz0gdG9rZW4ud2lkdGggPSB0b2tlbldpZHRoO1xuICAgICAgdG9rZW5TdHlsZSAmJiAobGluZUhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIHRva2VuLmxpbmVIZWlnaHQpKTtcbiAgICB9XG5cbiAgICBsaW5lLndpZHRoID0gbGluZVdpZHRoO1xuICAgIGxpbmUubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgY29udGVudEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWF4KGNvbnRlbnRXaWR0aCwgbGluZVdpZHRoKTtcbiAgfVxuXG4gIGNvbnRlbnRCbG9jay5vdXRlcldpZHRoID0gY29udGVudEJsb2NrLndpZHRoID0gcmV0cmlldmUyKHN0eWxlLnRleHRXaWR0aCwgY29udGVudFdpZHRoKTtcbiAgY29udGVudEJsb2NrLm91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLmhlaWdodCA9IHJldHJpZXZlMihzdHlsZS50ZXh0SGVpZ2h0LCBjb250ZW50SGVpZ2h0KTtcblxuICBpZiAoc3RsUGFkZGluZykge1xuICAgIGNvbnRlbnRCbG9jay5vdXRlcldpZHRoICs9IHN0bFBhZGRpbmdbMV0gKyBzdGxQYWRkaW5nWzNdO1xuICAgIGNvbnRlbnRCbG9jay5vdXRlckhlaWdodCArPSBzdGxQYWRkaW5nWzBdICsgc3RsUGFkZGluZ1syXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGVuZGluZ0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSBwZW5kaW5nTGlzdFtpXTtcbiAgICB2YXIgcGVyY2VudFdpZHRoID0gdG9rZW4ucGVyY2VudFdpZHRoOyAvLyBTaG91bGQgbm90IGJhc2Ugb24gb3V0ZXJXaWR0aCwgYmVjYXVzZSB0b2tlbiBjYW4gbm90IGJlIHBsYWNlZCBvdXQgb2YgcGFkZGluZy5cblxuICAgIHRva2VuLndpZHRoID0gcGFyc2VJbnQocGVyY2VudFdpZHRoLCAxMCkgLyAxMDAgKiBjb250ZW50V2lkdGg7XG4gIH1cblxuICByZXR1cm4gY29udGVudEJsb2NrO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9rZW5zKGJsb2NrLCBzdHIsIHN0eWxlTmFtZSkge1xuICB2YXIgaXNFbXB0eVN0ciA9IHN0ciA9PT0gJyc7XG4gIHZhciBzdHJzID0gc3RyLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGxpbmVzID0gYmxvY2subGluZXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRleHQgPSBzdHJzW2ldO1xuICAgIHZhciB0b2tlbiA9IHtcbiAgICAgIHN0eWxlTmFtZTogc3R5bGVOYW1lLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGlzTGluZUhvbGRlcjogIXRleHQgJiYgIWlzRW1wdHlTdHJcbiAgICB9OyAvLyBUaGUgZmlyc3QgdG9rZW4gc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBsYXN0IGxpbmUuXG5cbiAgICBpZiAoIWkpIHtcbiAgICAgIHZhciB0b2tlbnMgPSAobGluZXNbbGluZXMubGVuZ3RoIC0gMV0gfHwgKGxpbmVzWzBdID0ge1xuICAgICAgICB0b2tlbnM6IFtdXG4gICAgICB9KSkudG9rZW5zOyAvLyBDb25zaWRlciBjYXNlczpcbiAgICAgIC8vICgxKSAnJy5zcGxpdCgnXFxuJykgPT4gWycnLCAnXFxuJywgJyddLCB0aGUgJycgYXQgdGhlIGZpcnN0IGl0ZW1cbiAgICAgIC8vICh3aGljaCBpcyBhIHBsYWNlaG9sZGVyKSBzaG91bGQgYmUgcmVwbGFjZWQgYnkgbmV3IHRva2VuLlxuICAgICAgLy8gKDIpIEEgaW1hZ2UgYmFja2FnZSwgd2hlcmUgdG9rZW4gbGlrZXMge2F8fS5cbiAgICAgIC8vICgzKSBBIHJlZHVuZGFudCAnJyB3aWxsIGFmZmVjdCB0ZXh0QWxpZ24gaW4gbGluZS5cbiAgICAgIC8vICg0KSB0b2tlbnMgd2l0aCB0aGUgc2FtZSB0cGxOYW1lIHNob3VsZCBub3QgYmUgbWVyZ2VkLCBiZWNhdXNlXG4gICAgICAvLyB0aGV5IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gZGlmZmVyZW50IGJveCAod2l0aCBib3JkZXIgYW5kIHBhZGRpbmcpLlxuXG4gICAgICB2YXIgdG9rZW5zTGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgIHRva2Vuc0xlbiA9PT0gMSAmJiB0b2tlbnNbMF0uaXNMaW5lSG9sZGVyID8gdG9rZW5zWzBdID0gdG9rZW4gOiAvLyBDb25zaWRlciB0ZXh0IGlzICcnLCBvbmx5IGluc2VydCB3aGVuIGl0IGlzIHRoZSBcImxpbmVIb2xkZXJcIiBvclxuICAgICAgLy8gXCJlbXB0eVN0clwiLiBPdGhlcndpc2UgYSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAodGV4dCB8fCAhdG9rZW5zTGVuIHx8IGlzRW1wdHlTdHIpICYmIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9IC8vIE90aGVyIHRva2VucyBhbHdheXMgc3RhcnQgYSBuZXcgbGluZS5cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgJycsIGluc2VydCBpdCBhcyBhIHBsYWNlaG9sZGVyLlxuICAgICAgICBsaW5lcy5wdXNoKHtcbiAgICAgICAgICB0b2tlbnM6IFt0b2tlbl1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZvbnQoc3R5bGUpIHtcbiAgLy8gRklYTUUgaW4gbm9kZS1jYW52YXMgZm9udFdlaWdodCBpcyBiZWZvcmUgZm9udFN0eWxlXG4gIC8vIFVzZSBgZm9udFNpemVgIGBmb250RmFtaWx5YCB0byBjaGVjayB3aGV0aGVyIGZvbnQgcHJvcGVydGllcyBhcmUgZGVmaW5lZC5cbiAgcmV0dXJuIChzdHlsZS5mb250U2l6ZSB8fCBzdHlsZS5mb250RmFtaWx5KSAmJiBbc3R5bGUuZm9udFN0eWxlLCBzdHlsZS5mb250V2VpZ2h0LCAoc3R5bGUuZm9udFNpemUgfHwgMTIpICsgJ3B4JywgLy8gSWYgZm9udCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLCBgZm9udEZhbWlseWAgc2hvdWxkIG5vdCBiZSBpZ25vcmVkLlxuICBzdHlsZS5mb250RmFtaWx5IHx8ICdzYW5zLXNlcmlmJ10uam9pbignICcpIHx8IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG59XG5cbmV4cG9ydHMuREVGQVVMVF9GT05UID0gREVGQVVMVF9GT05UO1xuZXhwb3J0cy4kb3ZlcnJpZGUgPSAkb3ZlcnJpZGU7XG5leHBvcnRzLmdldFdpZHRoID0gZ2V0V2lkdGg7XG5leHBvcnRzLmdldEJvdW5kaW5nUmVjdCA9IGdldEJvdW5kaW5nUmVjdDtcbmV4cG9ydHMuYWRqdXN0VGV4dFggPSBhZGp1c3RUZXh0WDtcbmV4cG9ydHMuYWRqdXN0VGV4dFkgPSBhZGp1c3RUZXh0WTtcbmV4cG9ydHMuYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0ID0gYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0O1xuZXhwb3J0cy50cnVuY2F0ZVRleHQgPSB0cnVuY2F0ZVRleHQ7XG5leHBvcnRzLmdldExpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0O1xuZXhwb3J0cy5tZWFzdXJlVGV4dCA9IG1lYXN1cmVUZXh0O1xuZXhwb3J0cy5wYXJzZVBsYWluVGV4dCA9IHBhcnNlUGxhaW5UZXh0O1xuZXhwb3J0cy5wYXJzZVJpY2hUZXh0ID0gcGFyc2VSaWNoVGV4dDtcbmV4cG9ydHMubWFrZUZvbnQgPSBtYWtlRm9udDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3RleHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQSTIgPSBNYXRoLlBJICogMjtcblxuZnVuY3Rpb24gbm9ybWFsaXplUmFkaWFuKGFuZ2xlKSB7XG4gIGFuZ2xlICU9IFBJMjtcblxuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgcmV0dXJuIGFuZ2xlO1xufVxuXG5leHBvcnRzLm5vcm1hbGl6ZVJhZGlhbiA9IG5vcm1hbGl6ZVJhZGlhbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImZ1bmN0aW9uIHdpbmRpbmdMaW5lKHgwLCB5MCwgeDEsIHkxLCB4LCB5KSB7XG4gIGlmICh5ID4geTAgJiYgeSA+IHkxIHx8IHkgPCB5MCAmJiB5IDwgeTEpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBJZ25vcmUgaG9yaXpvbnRhbCBsaW5lXG5cblxuICBpZiAoeTEgPT09IHkwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgZGlyID0geTEgPCB5MCA/IDEgOiAtMTtcbiAgdmFyIHQgPSAoeSAtIHkwKSAvICh5MSAtIHkwKTsgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG5cbiAgaWYgKHQgPT09IDEgfHwgdCA9PT0gMCkge1xuICAgIGRpciA9IHkxIDwgeTAgPyAwLjUgOiAtMC41O1xuICB9XG5cbiAgdmFyIHhfID0gdCAqICh4MSAtIHgwKSArIHgwO1xuICByZXR1cm4geF8gPiB4ID8gZGlyIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW5kaW5nTGluZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZShcIi4uL0VsZW1lbnRcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8qKlxuICogR3JvdXDmmK/kuIDkuKrlrrnlmajvvIzlj6/ku6Xmj5LlhaXlrZDoioLngrnvvIxHcm91cOeahOWPmOaNouS5n+S8muiiq+W6lOeUqOWIsOWtkOiKgueCueS4ilxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9jb250YWluZXIvR3JvdXAnKTtcbiAqICAgICB2YXIgQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqL1xudmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBmb3IgKHZhciBrZXkgaW4gb3B0cykge1xuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICB0aGlzLl9fc3RvcmFnZSA9IG51bGw7XG4gIHRoaXMuX19kaXJ0eSA9IHRydWU7XG59O1xuXG5Hcm91cC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcm91cCxcbiAgaXNHcm91cDogdHJ1ZSxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHR5cGU6ICdncm91cCcsXG5cbiAgLyoqXG4gICAqIOaJgOacieWtkOWtmeWFg+e0oOaYr+WQpuWTjeW6lOm8oOagh+S6i+S7tlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvY29udGFpbmVyL0dyb3VwI3NpbGVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9FbGVtZW50Pn1cbiAgICovXG4gIGNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPluaMh+WumiBpbmRleCDnmoTlhL/lrZDoioLngrlcbiAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICovXG4gIGNoaWxkQXQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5baWR4XTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W5oyH5a6a5ZCN5a2X55qE5YS/5a2Q6IqC54K5XG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgKi9cbiAgY2hpbGRPZk5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6IqC54K55Yiw5pyA5ZCOXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gbmV4dFNpYmxpbmdcbiAgICovXG4gIGFkZEJlZm9yZTogZnVuY3Rpb24gKGNoaWxkLCBuZXh0U2libGluZykge1xuICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMgJiYgbmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgIHZhciBpZHggPSBjaGlsZHJlbi5pbmRleE9mKG5leHRTaWJsaW5nKTtcblxuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDAsIGNoaWxkKTtcblxuICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9kb0FkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gICAgfVxuXG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcblxuICAgIGlmIChzdG9yYWdlICYmIHN0b3JhZ2UgIT09IGNoaWxkLl9fc3RvcmFnZSkge1xuICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOenu+mZpOWtkOiKgueCuVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZihjaGlsZHJlbiwgY2hpbGQpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG5cbiAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgenIgJiYgenIucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnp7vpmaTmiYDmnInlrZDoioLngrlcbiAgICovXG4gIHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDpgY3ljobmiYDmnInlrZDoioLngrlcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICBlYWNoQ2hpbGQ6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkLCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5rex5bqm5LyY5YWI6YGN5Y6G5omA5pyJ5a2Q5a2Z6IqC54K5XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgIGNoaWxkLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkQ2hpbGRyZW5Ub1N0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKGluY2x1ZGVDaGlsZHJlbikge1xuICAgIC8vIFRPRE8gQ2FjaGluZ1xuICAgIHZhciByZWN0ID0gbnVsbDtcbiAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgdmFyIGNoaWxkcmVuID0gaW5jbHVkZUNoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciB0bXBNYXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2hpbGQuaWdub3JlIHx8IGNoaWxkLmludmlzaWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGNoaWxkLmdldExvY2FsVHJhbnNmb3JtKHRtcE1hdCk7IC8vIFRPRE9cbiAgICAgIC8vIFRoZSBib3VuZGluZ1JlY3QgY2FjbHVhdGVkIGJ5IHRyYW5zZm9ybWluZyBvcmlnaW5hbFxuICAgICAgLy8gcmVjdCBtYXkgYmUgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCBidW5kaW5nUmVjdCB3aGVuIHJvdGF0aW9uXG4gICAgICAvLyBpcyB1c2VkLiAoQ29uc2lkZXIgYSBjaXJjbGUgcm90YXRlZCBhZ2luc3QgaXRzIGNlbnRlciwgd2hlcmVcbiAgICAgIC8vIHRoZSBhY3R1YWwgYm91bmRpbmdSZWN0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGF0IG5vdCBiZVxuICAgICAgLy8gcm90YXRlZC4pIEJ1dCB3ZSBjYW4gbm90IGZpbmQgYmV0dGVyIGFwcHJvYWNoIHRvIGNhbGN1bGF0ZVxuICAgICAgLy8gYWN0dWFsIGJvdW5kaW5nUmVjdCB5ZXQsIGNvbnNpZGVyaW5nIHBlcmZvcm1hbmNlLlxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRtcFJlY3QuY29weShjaGlsZFJlY3QpO1xuICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRtcFJlY3QuY2xvbmUoKTtcbiAgICAgICAgcmVjdC51bmlvbih0bXBSZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IGNoaWxkUmVjdC5jbG9uZSgpO1xuICAgICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3QgfHwgdG1wUmVjdDtcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhHcm91cCwgRWxlbWVudCk7XG52YXIgX2RlZmF1bHQgPSBHcm91cDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuL21hdHJpeFwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICovXG5cbmZ1bmN0aW9uIEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmICh3aWR0aCA8IDApIHtcbiAgICB4ID0geCArIHdpZHRoO1xuICAgIHdpZHRoID0gLXdpZHRoO1xuICB9XG5cbiAgaWYgKGhlaWdodCA8IDApIHtcbiAgICB5ID0geSArIGhlaWdodDtcbiAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuXG4gIHRoaXMueCA9IHg7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLnkgPSB5O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59XG5cbkJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBCb3VuZGluZ1JlY3QsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9IG90aGVyXG4gICAqL1xuICB1bmlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIHggPSBtYXRoTWluKG90aGVyLngsIHRoaXMueCk7XG4gICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG4gICAgdGhpcy53aWR0aCA9IG1hdGhNYXgob3RoZXIueCArIG90aGVyLndpZHRoLCB0aGlzLnggKyB0aGlzLndpZHRoKSAtIHg7XG4gICAgdGhpcy5oZWlnaHQgPSBtYXRoTWF4KG90aGVyLnkgKyBvdGhlci5oZWlnaHQsIHRoaXMueSArIHRoaXMuaGVpZ2h0KSAtIHk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAqIEBtZXRob2RzXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsdCA9IFtdO1xuICAgIHZhciByYiA9IFtdO1xuICAgIHZhciBsYiA9IFtdO1xuICAgIHZhciBydCA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobSkge1xuICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgIC8vIGVsLmdldEJvdW5kaW5nUmVjdCgpLmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSlcbiAgICAgIC8vIEFuZCBlbGVtZW50IGhhcyBubyB0cmFuc2Zvcm1cbiAgICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGx0WzBdID0gbGJbMF0gPSB0aGlzLng7XG4gICAgICBsdFsxXSA9IHJ0WzFdID0gdGhpcy55O1xuICAgICAgcmJbMF0gPSBydFswXSA9IHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgICByYlsxXSA9IGxiWzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKGx0LCBsdCwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHJiLCByYiwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKGxiLCBsYiwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHJ0LCBydCwgbSk7XG4gICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgIHRoaXMueSA9IG1hdGhNaW4obHRbMV0sIHJiWzFdLCBsYlsxXSwgcnRbMV0pO1xuICAgICAgdmFyIG1heFggPSBtYXRoTWF4KGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICB0aGlzLndpZHRoID0gbWF4WCAtIHRoaXMueDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWF4WSAtIHRoaXMueTtcbiAgICB9O1xuICB9KCksXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBtYXRyaXggb2YgdHJhbnNmb3JtaW5nIGZyb20gc2VsZiB0byB0YXJnZXQgcmVjdFxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gYlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGNhbGN1bGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGIpIHtcbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgdmFyIHN5ID0gYi5oZWlnaHQgLyBhLmhlaWdodDtcbiAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTsgLy8g55+p6Zi15Y+z5LmYXG5cbiAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgbWF0cml4LnNjYWxlKG0sIG0sIFtzeCwgc3ldKTtcbiAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFtiLngsIGIueV0pO1xuICAgIHJldHVybiBtO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyhtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdHxPYmplY3QpfSBiXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKCFiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIEJvdW5kaW5nUmVjdCkpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSBuZWdhdGl2ZSB3aWR0aC9oZWlnaHQuXG4gICAgICBiID0gQm91bmRpbmdSZWN0LmNyZWF0ZShiKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGF4MCA9IGEueDtcbiAgICB2YXIgYXgxID0gYS54ICsgYS53aWR0aDtcbiAgICB2YXIgYXkwID0gYS55O1xuICAgIHZhciBheTEgPSBhLnkgKyBhLmhlaWdodDtcbiAgICB2YXIgYngwID0gYi54O1xuICAgIHZhciBieDEgPSBiLnggKyBiLndpZHRoO1xuICAgIHZhciBieTAgPSBiLnk7XG4gICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuICAgIHJldHVybiAhKGF4MSA8IGJ4MCB8fCBieDEgPCBheDAgfHwgYXkxIDwgYnkwIHx8IGJ5MSA8IGF5MCk7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgIHJldHVybiB4ID49IHJlY3QueCAmJiB4IDw9IHJlY3QueCArIHJlY3Qud2lkdGggJiYgeSA+PSByZWN0LnkgJiYgeSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcHkgZnJvbSBhbm90aGVyIHJlY3RcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICB0aGlzLndpZHRoID0gb3RoZXIud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gIH0sXG4gIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueSxcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC54XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC53aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QuaGVpZ2h0XG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAqL1xuXG5Cb3VuZGluZ1JlY3QuY3JlYXRlID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IEJvdW5kaW5nUmVjdDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoXCIuL2V2ZW50XCIpO1xuXG4vKipcbiAqIE9ubHkgaW1wbGVtZW50cyBuZWVkZWQgZ2VzdHVyZXMgZm9yIG1vYmlsZS5cbiAqL1xudmFyIEdlc3R1cmVNZ3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAqL1xuICB0aGlzLl90cmFjayA9IFtdO1xufTtcblxuR2VzdHVyZU1nci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHZXN0dXJlTWdyLFxuICByZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgdGhpcy5fZG9UcmFjayhldmVudCwgdGFyZ2V0LCByb290KTtcblxuICAgIHJldHVybiB0aGlzLl9yZWNvZ25pemUoZXZlbnQpO1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3RyYWNrLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9kb1RyYWNrOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcblxuICAgIGlmICghdG91Y2hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0cmFja0l0ZW0gPSB7XG4gICAgICBwb2ludHM6IFtdLFxuICAgICAgdG91Y2hlczogW10sXG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcbiAgICAgIHZhciBwb3MgPSBldmVudFV0aWwuY2xpZW50VG9Mb2NhbChyb290LCB0b3VjaCwge30pO1xuICAgICAgdHJhY2tJdGVtLnBvaW50cy5wdXNoKFtwb3MuenJYLCBwb3MuenJZXSk7XG4gICAgICB0cmFja0l0ZW0udG91Y2hlcy5wdXNoKHRvdWNoKTtcbiAgICB9XG5cbiAgICB0aGlzLl90cmFjay5wdXNoKHRyYWNrSXRlbSk7XG4gIH0sXG4gIF9yZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiByZWNvZ25pemVycykge1xuICAgICAgaWYgKHJlY29nbml6ZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgdmFyIGdlc3R1cmVJbmZvID0gcmVjb2duaXplcnNbZXZlbnROYW1lXSh0aGlzLl90cmFjaywgZXZlbnQpO1xuXG4gICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgIHJldHVybiBnZXN0dXJlSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZGlzdChwb2ludFBhaXIpIHtcbiAgdmFyIGR4ID0gcG9pbnRQYWlyWzFdWzBdIC0gcG9pbnRQYWlyWzBdWzBdO1xuICB2YXIgZHkgPSBwb2ludFBhaXJbMV1bMV0gLSBwb2ludFBhaXJbMF1bMV07XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xufVxuXG5mdW5jdGlvbiBjZW50ZXIocG9pbnRQYWlyKSB7XG4gIHJldHVybiBbKHBvaW50UGFpclswXVswXSArIHBvaW50UGFpclsxXVswXSkgLyAyLCAocG9pbnRQYWlyWzBdWzFdICsgcG9pbnRQYWlyWzFdWzFdKSAvIDJdO1xufVxuXG52YXIgcmVjb2duaXplcnMgPSB7XG4gIHBpbmNoOiBmdW5jdGlvbiAodHJhY2ssIGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrTGVuID0gdHJhY2subGVuZ3RoO1xuXG4gICAgaWYgKCF0cmFja0xlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwaW5jaEVuZCA9ICh0cmFja1t0cmFja0xlbiAtIDFdIHx8IHt9KS5wb2ludHM7XG4gICAgdmFyIHBpbmNoUHJlID0gKHRyYWNrW3RyYWNrTGVuIC0gMl0gfHwge30pLnBvaW50cyB8fCBwaW5jaEVuZDtcblxuICAgIGlmIChwaW5jaFByZSAmJiBwaW5jaFByZS5sZW5ndGggPiAxICYmIHBpbmNoRW5kICYmIHBpbmNoRW5kLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBwaW5jaFNjYWxlID0gZGlzdChwaW5jaEVuZCkgLyBkaXN0KHBpbmNoUHJlKTtcbiAgICAgICFpc0Zpbml0ZShwaW5jaFNjYWxlKSAmJiAocGluY2hTY2FsZSA9IDEpO1xuICAgICAgZXZlbnQucGluY2hTY2FsZSA9IHBpbmNoU2NhbGU7XG4gICAgICB2YXIgcGluY2hDZW50ZXIgPSBjZW50ZXIocGluY2hFbmQpO1xuICAgICAgZXZlbnQucGluY2hYID0gcGluY2hDZW50ZXJbMF07XG4gICAgICBldmVudC5waW5jaFkgPSBwaW5jaENlbnRlclsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdwaW5jaCcsXG4gICAgICAgIHRhcmdldDogdHJhY2tbMF0udGFyZ2V0LFxuICAgICAgICBldmVudDogZXZlbnRcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIE9ubHkgcGluY2ggY3VycmVudGx5LlxuXG59O1xudmFyIF9kZWZhdWx0ID0gR2VzdHVyZU1ncjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBTaW1wbGUgTFJVIGNhY2hlIHVzZSBkb3VibHkgbGlua2VkIGxpc3Rcbi8vIEBtb2R1bGUgenJlbmRlci9jb3JlL0xSVVxuXG4vKipcbiAqIFNpbXBsZSBkb3VibGUgbGlua2VkIGxpc3QuIENvbXBhcmVkIHdpdGggYXJyYXksIGl0IGhhcyBPKDEpIHJlbW92ZSBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIExpbmtlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLl9sZW4gPSAwO1xufTtcblxudmFyIGxpbmtlZExpc3RQcm90byA9IExpbmtlZExpc3QucHJvdG90eXBlO1xuLyoqXG4gKiBJbnNlcnQgYSBuZXcgdmFsdWUgYXQgdGhlIHRhaWxcbiAqIEBwYXJhbSAge30gdmFsXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAqL1xuXG5saW5rZWRMaXN0UHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24gKHZhbCkge1xuICB2YXIgZW50cnkgPSBuZXcgRW50cnkodmFsKTtcbiAgdGhpcy5pbnNlcnRFbnRyeShlbnRyeSk7XG4gIHJldHVybiBlbnRyeTtcbn07XG4vKipcbiAqIEluc2VydCBhbiBlbnRyeSBhdCB0aGUgdGFpbFxuICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8uaW5zZXJ0RW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgIGVudHJ5LnByZXYgPSB0aGlzLnRhaWw7XG4gICAgZW50cnkubmV4dCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gIH1cblxuICB0aGlzLl9sZW4rKztcbn07XG4vKipcbiAqIFJlbW92ZSBlbnRyeS5cbiAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICB2YXIgcHJldiA9IGVudHJ5LnByZXY7XG4gIHZhciBuZXh0ID0gZW50cnkubmV4dDtcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gSXMgaGVhZFxuICAgIHRoaXMuaGVhZCA9IG5leHQ7XG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXY7XG4gIH0gZWxzZSB7XG4gICAgLy8gSXMgdGFpbFxuICAgIHRoaXMudGFpbCA9IHByZXY7XG4gIH1cblxuICBlbnRyeS5uZXh0ID0gZW50cnkucHJldiA9IG51bGw7XG4gIHRoaXMuX2xlbi0tO1xufTtcbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmxlbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xlbjtcbn07XG4vKipcbiAqIENsZWFyIGxpc3RcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5fbGVuID0gMDtcbn07XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHt9IHZhbFxuICovXG5cblxudmFyIEVudHJ5ID0gZnVuY3Rpb24gKHZhbCkge1xuICAvKipcbiAgICogQHR5cGUge31cbiAgICovXG4gIHRoaXMudmFsdWUgPSB2YWw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMubmV4dDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy5wcmV2O1xufTtcbi8qKlxuICogTFJVIENhY2hlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL0xSVVxuICovXG5cblxudmFyIExSVSA9IGZ1bmN0aW9uIChtYXhTaXplKSB7XG4gIHRoaXMuX2xpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xuICB0aGlzLl9tYXAgPSB7fTtcbiAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemUgfHwgMTA7XG4gIHRoaXMuX2xhc3RSZW1vdmVkRW50cnkgPSBudWxsO1xufTtcblxudmFyIExSVVByb3RvID0gTFJVLnByb3RvdHlwZTtcbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSAge30gdmFsdWVcbiAqIEByZXR1cm4ge30gUmVtb3ZlZCB2YWx1ZVxuICovXG5cbkxSVVByb3RvLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgdmFyIHJlbW92ZWQgPSBudWxsO1xuXG4gIGlmIChtYXBba2V5XSA9PSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuKCk7IC8vIFJldXNlIGxhc3QgcmVtb3ZlZCBlbnRyeVxuXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5fbGFzdFJlbW92ZWRFbnRyeTtcblxuICAgIGlmIChsZW4gPj0gdGhpcy5fbWF4U2l6ZSAmJiBsZW4gPiAwKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWRcbiAgICAgIHZhciBsZWFzdFVzZWRFbnRyeSA9IGxpc3QuaGVhZDtcbiAgICAgIGxpc3QucmVtb3ZlKGxlYXN0VXNlZEVudHJ5KTtcbiAgICAgIGRlbGV0ZSBtYXBbbGVhc3RVc2VkRW50cnkua2V5XTtcbiAgICAgIHJlbW92ZWQgPSBsZWFzdFVzZWRFbnRyeS52YWx1ZTtcbiAgICAgIHRoaXMuX2xhc3RSZW1vdmVkRW50cnkgPSBsZWFzdFVzZWRFbnRyeTtcbiAgICB9XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudHJ5ID0gbmV3IEVudHJ5KHZhbHVlKTtcbiAgICB9XG5cbiAgICBlbnRyeS5rZXkgPSBrZXk7XG4gICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgbWFwW2tleV0gPSBlbnRyeTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVkO1xufTtcbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge31cbiAqL1xuXG5cbkxSVVByb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbWFwW2tleV07XG4gIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcblxuICBpZiAoZW50cnkgIT0gbnVsbCkge1xuICAgIC8vIFB1dCB0aGUgbGF0ZXN0IHVzZWQgZW50cnkgaW4gdGhlIHRhaWxcbiAgICBpZiAoZW50cnkgIT09IGxpc3QudGFpbCkge1xuICAgICAgbGlzdC5yZW1vdmUoZW50cnkpO1xuICAgICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICB9XG59O1xuLyoqXG4gKiBDbGVhciB0aGUgY2FjaGVcbiAqL1xuXG5cbkxSVVByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9saXN0LmNsZWFyKCk7XG5cbiAgdGhpcy5fbWFwID0ge307XG59O1xuXG52YXIgX2RlZmF1bHQgPSBMUlU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvTFJVLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0xSVS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuL2N1cnZlXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIGJib3ggPSByZXF1aXJlKFwiLi9iYm94XCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4vQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBkcHIgPSBfY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG5cbi8qKlxuICogUGF0aCDku6PnkIbvvIzlj6/ku6XlnKhgYnVpbGRQYXRoYOS4reeUqOS6juabv+S7o2BjdHhgLCDkvJrkv53lrZjmr4/kuKpwYXRo5pON5L2c55qE5ZG95Luk5YiwcGF0aENvbW1hbmRz5bGe5oCn5LitXG4gKiDlj6/ku6XnlKjkuo4gaXNJbnNpZGVQYXRoIOWIpOaWreS7peWPiuiOt+WPlmJvdW5kaW5nUmVjdFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGF1dGhvciBZaSBTaGVuIChodHRwOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBnZXRUb3RhbExlbmd0aCwgZ2V0UG9pbnRBdExlbmd0aFxudmFyIENNRCA9IHtcbiAgTTogMSxcbiAgTDogMixcbiAgQzogMyxcbiAgUTogNCxcbiAgQTogNSxcbiAgWjogNixcbiAgLy8gUmVjdFxuICBSOiA3XG59OyAvLyB2YXIgQ01EX01FTV9TSVpFID0ge1xuLy8gICAgIE06IDMsXG4vLyAgICAgTDogMyxcbi8vICAgICBDOiA3LFxuLy8gICAgIFE6IDUsXG4vLyAgICAgQTogOSxcbi8vICAgICBSOiA1LFxuLy8gICAgIFo6IDFcbi8vIH07XG5cbnZhciBtaW4gPSBbXTtcbnZhciBtYXggPSBbXTtcbnZhciBtaW4yID0gW107XG52YXIgbWF4MiA9IFtdO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG52YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIFBhdGhQcm94eSA9IGZ1bmN0aW9uIChub3RTYXZlRGF0YSkge1xuICB0aGlzLl9zYXZlRGF0YSA9ICEobm90U2F2ZURhdGEgfHwgZmFsc2UpO1xuXG4gIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgIC8qKlxuICAgICAqIFBhdGggZGF0YS4gU3RvcmVkIGFzIGZsYXQgYXJyYXlcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gW107XG4gIH1cblxuICB0aGlzLl9jdHggPSBudWxsO1xufTtcbi8qKlxuICog5b+r6YCf6K6h566XUGF0aOWMheWbtOebku+8iOW5tuS4jeaYr+acgOWwj+WMheWbtOebku+8iVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cblxuUGF0aFByb3h5LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGhQcm94eSxcbiAgX3hpOiAwLFxuICBfeWk6IDAsXG4gIF94MDogMCxcbiAgX3kwOiAwLFxuICAvLyBVbml0IHgsIFVuaXQgeS4gUHJvdmlkZSBmb3IgYXZvaWRpbmcgZHJhd2luZyB0aGF0IHRvbyBzaG9ydCBsaW5lIHNlZ21lbnRcbiAgX3V4OiAwLFxuICBfdXk6IDAsXG4gIF9sZW46IDAsXG4gIF9saW5lRGFzaDogbnVsbCxcbiAgX2Rhc2hPZmZzZXQ6IDAsXG4gIF9kYXNoSWR4OiAwLFxuICBfZGFzaFN1bTogMCxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBzZXRTY2FsZTogZnVuY3Rpb24gKHN4LCBzeSkge1xuICAgIHRoaXMuX3V4ID0gbWF0aEFicygxIC8gZHByIC8gc3gpIHx8IDA7XG4gICAgdGhpcy5fdXkgPSBtYXRoQWJzKDEgLyBkcHIgLyBzeSkgfHwgMDtcbiAgfSxcbiAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4ICYmICh0aGlzLmRwciA9IGN0eC5kcHIpOyAvLyBSZXNldFxuXG4gICAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgdGhpcy5fbGluZURhc2ggPSBudWxsO1xuICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5NLCB4LCB5KTtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTsgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgLy8geGksIHlpIOiusOW9leW9k+WJjeeCuSwgeDAsIHkwIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5Zue5Yiw6LW35aeL54K544CCXG4gICAgLy8g5pyJ5Y+v6IO95ZyoIGJlZ2luUGF0aCDkuYvlkI7nm7TmjqXosIPnlKggbGluZVRv77yM6L+Z5pe25YCZIHgwLCB5MCDpnIDopoFcbiAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcblxuICAgIHRoaXMuX3gwID0geDtcbiAgICB0aGlzLl95MCA9IHk7XG4gICAgdGhpcy5feGkgPSB4O1xuICAgIHRoaXMuX3lpID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgZXhjZWVkVW5pdCA9IG1hdGhBYnMoeCAtIHRoaXMuX3hpKSA+IHRoaXMuX3V4IHx8IG1hdGhBYnMoeSAtIHRoaXMuX3lpKSA+IHRoaXMuX3V5IC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICB8fCB0aGlzLl9sZW4gPCA1O1xuICAgIHRoaXMuYWRkRGF0YShDTUQuTCwgeCwgeSk7XG5cbiAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkTGluZVRvKHgsIHkpIDogdGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgdGhpcy5feWkgPSB5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5DLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgzO1xuICAgIHRoaXMuX3lpID0geTM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlEsIHgxLCB5MSwgeDIsIHkyKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDI7XG4gICAgdGhpcy5feWkgPSB5MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuQSwgY3gsIGN5LCByLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUsIDAsIGFudGljbG9ja3dpc2UgPyAwIDogMSk7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG4gICAgdGhpcy5feGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICB0aGlzLl95aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBUT0RPXG4gIGFyY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX2N0eC5hcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVE9ET1xuICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuWik7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICB2YXIgeDAgPSB0aGlzLl94MDtcbiAgICB2YXIgeTAgPSB0aGlzLl95MDtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpICYmIHRoaXMuX2Rhc2hlZExpbmVUbyh4MCwgeTApO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDA7XG4gICAgdGhpcy5feWkgPSB5MDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ29udGV4dCDku47lpJbpg6jkvKDlhaXvvIzlm6DkuLrmnInlj6/og73mmK8gcmVidWlsZFBhdGgg5a6M5LmL5ZCO5YaNIGZpbGzjgIJcbiAgICogc3Ryb2tlIOWQjOagt1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgZmlsbDogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHN0cm9rZTogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguc3Ryb2tlKCk7XG4gICAgdGhpcy50b1N0YXRpYygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgaWYgKGxpbmVEYXNoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcbiAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZURhc2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZURhc2hTdW0gKz0gbGluZURhc2hbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Rhc2hTdW0gPSBsaW5lRGFzaFN1bTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc2V0TGluZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgfSxcblxuICAvKipcbiAgICog55u05o6l6K6+572uIFBhdGgg5pWw5o2uXG4gICAqL1xuICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmICghKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoID09IGxlbikgJiYgaGFzVHlwZWRBcnJheSkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuZGF0YVtpXSA9IGRhdGFbaV07XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuID0gbGVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDot6/lvoRcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eXxBcnJheS48bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHk+fSBwYXRoXG4gICAqL1xuICBhcHBlbmRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcHBlbmRTaXplID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbGVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXBwZW5kU2l6ZSArPSBwYXRoW2ldLmxlbigpO1xuICAgIH1cblxuICAgIGlmIChoYXNUeXBlZEFycmF5ICYmIHRoaXMuZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXBwZW5kUGF0aERhdGEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdGhpcy5kYXRhW29mZnNldCsrXSA9IGFwcGVuZFBhdGhEYXRhW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2xlbiA9IG9mZnNldDtcbiAgfSxcblxuICAvKipcbiAgICog5aGr5YWFIFBhdGgg5pWw5o2u44CCXG4gICAqIOWwvemHj+WkjeeUqOiAjOS4jeeUs+aYjuaWsOeahOaVsOe7hOOAguWkp+mDqOWIhuWbvuW9oumHjee7mOeahOaMh+S7pOaVsOaNrumVv+W6pumDveaYr+S4jeWPmOeahOOAglxuICAgKi9cbiAgYWRkRGF0YTogZnVuY3Rpb24gKGNtZCkge1xuICAgIGlmICghdGhpcy5fc2F2ZURhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIGlmICh0aGlzLl9sZW4gKyBhcmd1bWVudHMubGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIOWboOS4uuS5i+WJjeeahOaVsOe7hOW3sue7j+i9rOaNouaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXlcbiAgICAgIC8vIOaJgOS7peS4jeWkn+eUqOaXtumcgOimgeaJqeWxleS4gOS4quaWsOeahOWKqOaAgeaVsOe7hFxuICAgICAgdGhpcy5fZXhwYW5kRGF0YSgpO1xuXG4gICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW3RoaXMuX2xlbisrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmV2Q21kID0gY21kO1xuICB9LFxuICBfZXhwYW5kRGF0YTogZnVuY3Rpb24gKCkge1xuICAgIC8vIE9ubHkgaWYgZGF0YSBpcyBGbG9hdDMyQXJyYXlcbiAgICBpZiAoISh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGVuOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG5lZWRzIGpzIGltcGxlbWVudGVkIGRhc2hlZCBsaW5lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbmVlZHNEYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVEYXNoO1xuICB9LFxuICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgdmFyIGR4ID0geDEgLSB4MDtcbiAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgIHZhciBkaXN0ID0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIHZhciB4ID0geDA7XG4gICAgdmFyIHkgPSB5MDtcbiAgICB2YXIgZGFzaDtcbiAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG4gICAgdmFyIGlkeDtcbiAgICBkeCAvPSBkaXN0O1xuICAgIGR5IC89IGRpc3Q7XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICU9IGRhc2hTdW07XG4gICAgeCAtPSBvZmZzZXQgKiBkeDtcbiAgICB5IC09IG9mZnNldCAqIGR5O1xuXG4gICAgd2hpbGUgKGR4ID4gMCAmJiB4IDw9IHgxIHx8IGR4IDwgMCAmJiB4ID49IHgxIHx8IGR4ID09IDAgJiYgKGR5ID4gMCAmJiB5IDw9IHkxIHx8IGR5IDwgMCAmJiB5ID49IHkxKSkge1xuICAgICAgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICAgIGRhc2ggPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgeCArPSBkeCAqIGRhc2g7XG4gICAgICB5ICs9IGR5ICogZGFzaDtcbiAgICAgIHRoaXMuX2Rhc2hJZHggPSAoaWR4ICsgMSkgJSBuRGFzaDsgLy8gU2tpcCBwb3NpdGl2ZSBvZmZzZXRcblxuICAgICAgaWYgKGR4ID4gMCAmJiB4IDwgeDAgfHwgZHggPCAwICYmIHggPiB4MCB8fCBkeSA+IDAgJiYgeSA8IHkwIHx8IGR5IDwgMCAmJiB5ID4geTApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGN0eFtpZHggJSAyID8gJ21vdmVUbycgOiAnbGluZVRvJ10oZHggPj0gMCA/IG1hdGhNaW4oeCwgeDEpIDogbWF0aE1heCh4LCB4MSksIGR5ID49IDAgPyBtYXRoTWluKHksIHkxKSA6IG1hdGhNYXgoeSwgeTEpKTtcbiAgICB9IC8vIE9mZnNldCBmb3IgbmV4dCBsaW5lVG9cblxuXG4gICAgZHggPSB4IC0geDE7XG4gICAgZHkgPSB5IC0geTE7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIH0sXG4gIC8vIE5vdCBhY2N1cmF0ZSBkYXNoZWQgbGluZSB0b1xuICBfZGFzaGVkQmV6aWVyVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgdmFyIHQ7XG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcbiAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgdmFyIGJlemllckxlbiA9IDA7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgIHZhciB4O1xuICAgIHZhciB5O1xuICAgIHZhciB0bXBMZW4gPSAwO1xuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIG9mZnNldCAlPSBkYXNoU3VtOyAvLyBCZXppZXIgYXBwcm94IGxlbmd0aFxuXG4gICAgZm9yICh0ID0gMDsgdCA8IDE7IHQgKz0gMC4xKSB7XG4gICAgICBkeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQgKyAwLjEpIC0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICBkeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQgKyAwLjEpIC0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICBiZXppZXJMZW4gKz0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0gLy8gRmluZCBpZHggYWZ0ZXIgYWRkIG9mZnNldFxuXG5cbiAgICBmb3IgKDsgaWR4IDwgbkRhc2g7IGlkeCsrKSB7XG4gICAgICB0bXBMZW4gKz0gbGluZURhc2hbaWR4XTtcblxuICAgICAgaWYgKHRtcExlbiA+IG9mZnNldCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0ID0gKHRtcExlbiAtIG9mZnNldCkgLyBiZXppZXJMZW47XG5cbiAgICB3aGlsZSAodCA8PSAxKSB7XG4gICAgICB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7IC8vIFVzZSBsaW5lIHRvIGFwcHJveGltYXRlIGRhc2hlZCBiZXppZXJcbiAgICAgIC8vIEJhZCByZXN1bHQgaWYgZGFzaCBpcyBsb25nXG5cbiAgICAgIGlkeCAlIDIgPyBjdHgubW92ZVRvKHgsIHkpIDogY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHQgKz0gbGluZURhc2hbaWR4XSAvIGJlemllckxlbjtcbiAgICAgIGlkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgIH0gLy8gRmluaXNoIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGNhbGN1bGF0ZSB0aGUgbmV3IG9mZnNldFxuXG5cbiAgICBpZHggJSAyICE9PSAwICYmIGN0eC5saW5lVG8oeDMsIHkzKTtcbiAgICBkeCA9IHgzIC0geDtcbiAgICBkeSA9IHkzIC0geTtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgfSxcbiAgX2Rhc2hlZFF1YWRyYXRpY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgdmFyIHgzID0geDI7XG4gICAgdmFyIHkzID0geTI7XG4gICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgIHgxID0gKHRoaXMuX3hpICsgMiAqIHgxKSAvIDM7XG4gICAgeTEgPSAodGhpcy5feWkgKyAyICogeTEpIC8gMztcblxuICAgIHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDovazmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5IOWHj+WwkeWghuWGheWtmOWNoOeUqFxuICAgKiBDb252ZXJ0IGR5bmFtaWMgYXJyYXkgdG8gc3RhdGljIEZsb2F0MzJBcnJheVxuICAgKi9cbiAgdG9TdGF0aWM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGRhdGEubGVuZ3RoID0gdGhpcy5fbGVuO1xuXG4gICAgICBpZiAoaGFzVHlwZWRBcnJheSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICBtaW5bMF0gPSBtaW5bMV0gPSBtaW4yWzBdID0gbWluMlsxXSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbWF4WzBdID0gbWF4WzFdID0gbWF4MlswXSA9IG1heDJbMV0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgeGkgPSAwO1xuICAgIHZhciB5aSA9IDA7XG4gICAgdmFyIHgwID0gMDtcbiAgICB2YXIgeTAgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgIHZhciBjbWQgPSBkYXRhW2krK107XG5cbiAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAvL1xuICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgIHlpID0gZGF0YVtpICsgMV07XG4gICAgICAgIHgwID0geGk7XG4gICAgICAgIHkwID0geWk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICBtaW4yWzBdID0geDA7XG4gICAgICAgICAgbWluMlsxXSA9IHkwO1xuICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICBtYXgyWzFdID0geTA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICBiYm94LmZyb21MaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgYmJveC5mcm9tQ3ViaWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgIGJib3guZnJvbVF1YWRyYXRpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTsgLy8gVE9ETyBBcmMg5peL6L2sXG5cbiAgICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcblxuICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgIHgwID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJib3guZnJvbUFyYyhjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdOyAvLyBVc2UgZnJvbUxpbmVcblxuICAgICAgICAgIGJib3guZnJvbUxpbmUoeDAsIHkwLCB4MCArIHdpZHRoLCB5MCArIGhlaWdodCwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIFVuaW9uXG5cblxuICAgICAgdmVjMi5taW4obWluLCBtaW4sIG1pbjIpO1xuICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIG1heDIpO1xuICAgIH0gLy8gTm8gZGF0YVxuXG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICByZWJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgIHZhciB4MCwgeTA7XG4gICAgdmFyIHhpLCB5aTtcbiAgICB2YXIgeCwgeTtcbiAgICB2YXIgdXggPSB0aGlzLl91eDtcbiAgICB2YXIgdXkgPSB0aGlzLl91eTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgY21kID0gZFtpKytdO1xuXG4gICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgeGkgPSBkW2ldO1xuICAgICAgICB5aSA9IGRbaSArIDFdO1xuICAgICAgICB4MCA9IHhpO1xuICAgICAgICB5MCA9IHlpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgIHgwID0geGkgPSBkW2krK107XG4gICAgICAgICAgeTAgPSB5aSA9IGRbaSsrXTtcbiAgICAgICAgICBjdHgubW92ZVRvKHhpLCB5aSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICB4ID0gZFtpKytdO1xuICAgICAgICAgIHkgPSBkW2krK107IC8vIE5vdCBkcmF3IHRvbyBzbWFsbCBzZWcgYmV0d2VlblxuXG4gICAgICAgICAgaWYgKG1hdGhBYnMoeCAtIHhpKSA+IHV4IHx8IG1hdGhBYnMoeSAtIHlpKSA+IHV5IHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB4aSA9IHg7XG4gICAgICAgICAgICB5aSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgIHZhciBjeCA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgY3kgPSBkW2krK107XG4gICAgICAgICAgdmFyIHJ4ID0gZFtpKytdO1xuICAgICAgICAgIHZhciByeSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgdGhldGEgPSBkW2krK107XG4gICAgICAgICAgdmFyIGRUaGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcHNpID0gZFtpKytdO1xuICAgICAgICAgIHZhciBmcyA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgdmFyIHNjYWxlWSA9IHJ4ID4gcnkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICB2YXIgaXNFbGxpcHNlID0gTWF0aC5hYnMocnggLSByeSkgPiAxZS0zO1xuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHRoZXRhICsgZFRoZXRhO1xuXG4gICAgICAgICAgaWYgKGlzRWxsaXBzZSkge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtcHNpKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgIHgwID0gbWF0aENvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgeTAgPSBtYXRoU2luKHRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICB4MCA9IHhpID0gZFtpXTtcbiAgICAgICAgICB5MCA9IHlpID0gZFtpICsgMV07XG4gICAgICAgICAgY3R4LnJlY3QoZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuUGF0aFByb3h5LkNNRCA9IENNRDtcbnZhciBfZGVmYXVsdCA9IFBhdGhQcm94eTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuL2N1cnZlXCIpO1xuXG4vKipcbiAqIEBhdXRob3IgWWkgU2hlbihodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBzdGFydCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbnZhciBleHRyZW1pdHkgPSB2ZWMyLmNyZWF0ZSgpO1xuLyoqXG4gKiDku47pobbngrnmlbDnu4TkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvaW50cyDpobbngrnmlbDnu4RcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqL1xuXG5mdW5jdGlvbiBmcm9tUG9pbnRzKHBvaW50cywgbWluLCBtYXgpIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcCA9IHBvaW50c1swXTtcbiAgdmFyIGxlZnQgPSBwWzBdO1xuICB2YXIgcmlnaHQgPSBwWzBdO1xuICB2YXIgdG9wID0gcFsxXTtcbiAgdmFyIGJvdHRvbSA9IHBbMV07XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBwID0gcG9pbnRzW2ldO1xuICAgIGxlZnQgPSBtYXRoTWluKGxlZnQsIHBbMF0pO1xuICAgIHJpZ2h0ID0gbWF0aE1heChyaWdodCwgcFswXSk7XG4gICAgdG9wID0gbWF0aE1pbih0b3AsIHBbMV0pO1xuICAgIGJvdHRvbSA9IG1hdGhNYXgoYm90dG9tLCBwWzFdKTtcbiAgfVxuXG4gIG1pblswXSA9IGxlZnQ7XG4gIG1pblsxXSA9IHRvcDtcbiAgbWF4WzBdID0gcmlnaHQ7XG4gIG1heFsxXSA9IGJvdHRvbTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbUxpbmUoeDAsIHkwLCB4MSwgeTEsIG1pbiwgbWF4KSB7XG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgeTEpO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbn1cblxudmFyIHhEaW0gPSBbXTtcbnZhciB5RGltID0gW107XG4vKipcbiAqIOS7juS4iemYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyLCBwMynkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge251bWJlcn0geDNcbiAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5mdW5jdGlvbiBmcm9tQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW4sIG1heCkge1xuICB2YXIgY3ViaWNFeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hO1xuICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gIHZhciBpO1xuICB2YXIgbiA9IGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgeERpbSk7XG4gIG1pblswXSA9IEluZmluaXR5O1xuICBtaW5bMV0gPSBJbmZpbml0eTtcbiAgbWF4WzBdID0gLUluZmluaXR5O1xuICBtYXhbMV0gPSAtSW5maW5pdHk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgeERpbVtpXSk7XG4gICAgbWluWzBdID0gbWF0aE1pbih4LCBtaW5bMF0pO1xuICAgIG1heFswXSA9IG1hdGhNYXgoeCwgbWF4WzBdKTtcbiAgfVxuXG4gIG4gPSBjdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIHlEaW0pO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHlEaW1baV0pO1xuICAgIG1pblsxXSA9IG1hdGhNaW4oeSwgbWluWzFdKTtcbiAgICBtYXhbMV0gPSBtYXRoTWF4KHksIG1heFsxXSk7XG4gIH1cblxuICBtaW5bMF0gPSBtYXRoTWluKHgwLCBtaW5bMF0pO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCBtYXhbMF0pO1xuICBtaW5bMF0gPSBtYXRoTWluKHgzLCBtaW5bMF0pO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgzLCBtYXhbMF0pO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCBtaW5bMV0pO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCBtYXhbMV0pO1xuICBtaW5bMV0gPSBtYXRoTWluKHkzLCBtaW5bMV0pO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkzLCBtYXhbMV0pO1xufVxuLyoqXG4gKiDku47kuozpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMinkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbVF1YWRyYXRpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBtaW4sIG1heCkge1xuICB2YXIgcXVhZHJhdGljRXh0cmVtdW0gPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bTtcbiAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmUucXVhZHJhdGljQXQ7IC8vIEZpbmQgZXh0cmVtaXRpZXMsIHdoZXJlIGRlcml2YXRpdmUgaW4geCBkaW0gb3IgeSBkaW0gaXMgemVyb1xuXG4gIHZhciB0eCA9IG1hdGhNYXgobWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDApO1xuICB2YXIgdHkgPSBtYXRoTWF4KG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5MiksIDEpLCAwKTtcbiAgdmFyIHggPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0eCk7XG4gIHZhciB5ID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdHkpO1xuICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MiwgeCk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDIsIHgpO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MiwgeSk7XG59XG4vKipcbiAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IHJ4XG4gKiBAcGFyYW0ge251bWJlcn0gcnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbUFyYyh4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heCkge1xuICB2YXIgdmVjMk1pbiA9IHZlYzIubWluO1xuICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cbiAgaWYgKGRpZmYgJSBQSTIgPCAxZS00ICYmIGRpZmYgPiAxZS00KSB7XG4gICAgLy8gSXMgYSBjaXJjbGVcbiAgICBtaW5bMF0gPSB4IC0gcng7XG4gICAgbWluWzFdID0geSAtIHJ5O1xuICAgIG1heFswXSA9IHggKyByeDtcbiAgICBtYXhbMV0gPSB5ICsgcnk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhcnRbMF0gPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyB4O1xuICBzdGFydFsxXSA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIHk7XG4gIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICBlbmRbMV0gPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgeTtcbiAgdmVjMk1pbihtaW4sIHN0YXJ0LCBlbmQpO1xuICB2ZWMyTWF4KG1heCwgc3RhcnQsIGVuZCk7IC8vIFRocmVzaCB0byBbMCwgTWF0aC5QSSAqIDJdXG5cbiAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgJSBQSTI7XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPCAwKSB7XG4gICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBQSTI7XG4gIH1cblxuICBlbmRBbmdsZSA9IGVuZEFuZ2xlICUgUEkyO1xuXG4gIGlmIChlbmRBbmdsZSA8IDApIHtcbiAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICsgUEkyO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSAmJiAhYW50aWNsb2Nrd2lzZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfSBlbHNlIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUgJiYgYW50aWNsb2Nrd2lzZSkge1xuICAgIHN0YXJ0QW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gZW5kQW5nbGU7XG4gICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gIH0gLy8gdmFyIG51bWJlciA9IDA7XG4gIC8vIHZhciBzdGVwID0gKGFudGljbG9ja3dpc2UgPyAtTWF0aC5QSSA6IE1hdGguUEkpIC8gMjtcblxuXG4gIGZvciAodmFyIGFuZ2xlID0gMDsgYW5nbGUgPCBlbmRBbmdsZTsgYW5nbGUgKz0gTWF0aC5QSSAvIDIpIHtcbiAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICBleHRyZW1pdHlbMF0gPSBtYXRoQ29zKGFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgIGV4dHJlbWl0eVsxXSA9IG1hdGhTaW4oYW5nbGUpICogcnkgKyB5O1xuICAgICAgdmVjMk1pbihtaW4sIGV4dHJlbWl0eSwgbWluKTtcbiAgICAgIHZlYzJNYXgobWF4LCBleHRyZW1pdHksIG1heCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZnJvbVBvaW50cyA9IGZyb21Qb2ludHM7XG5leHBvcnRzLmZyb21MaW5lID0gZnJvbUxpbmU7XG5leHBvcnRzLmZyb21DdWJpYyA9IGZyb21DdWJpYztcbmV4cG9ydHMuZnJvbVF1YWRyYXRpYyA9IGZyb21RdWFkcmF0aWM7XG5leHBvcnRzLmZyb21BcmMgPSBmcm9tQXJjO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9iYm94LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciB2MkNyZWF0ZSA9IF92ZWN0b3IuY3JlYXRlO1xudmFyIHYyRGlzdFNxdWFyZSA9IF92ZWN0b3IuZGlzdFNxdWFyZTtcblxuLyoqXG4gKiDmm7Lnur/ovoXliqnmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2N1cnZlXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbWF0aFBvdyA9IE1hdGgucG93O1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIEVQU0lMT04gPSAxZS04O1xudmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG52YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xudmFyIE9ORV9USElSRCA9IDEgLyAzOyAvLyDkuLTml7blj5jph49cblxudmFyIF92MCA9IHYyQ3JlYXRlKCk7XG5cbnZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuXG52YXIgX3YyID0gdjJDcmVhdGUoKTtcblxuZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbn1cblxuZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0F0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiBvbmV0ICogb25ldCAqIChvbmV0ICogcDAgKyAzICogdCAqIHAxKSArIHQgKiB0ICogKHQgKiBwMyArIDMgKiBvbmV0ICogcDIpO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiAzICogKCgocDEgLSBwMCkgKiBvbmV0ICsgMiAqIChwMiAtIHAxKSAqIHQpICogb25ldCArIChwMyAtIHAyKSAqIHQgKiB0KTtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5qC577yM5L2/55So55ub6YeR5YWs5byPXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljUm9vdEF0KHAwLCBwMSwgcDIsIHAzLCB2YWwsIHJvb3RzKSB7XG4gIC8vIEV2YWx1YXRlIHJvb3RzIG9mIGN1YmljIGZ1bmN0aW9uc1xuICB2YXIgYSA9IHAzICsgMyAqIChwMSAtIHAyKSAtIHAwO1xuICB2YXIgYiA9IDMgKiAocDIgLSBwMSAqIDIgKyBwMCk7XG4gIHZhciBjID0gMyAqIChwMSAtIHAwKTtcbiAgdmFyIGQgPSBwMCAtIHZhbDtcbiAgdmFyIEEgPSBiICogYiAtIDMgKiBhICogYztcbiAgdmFyIEIgPSBiICogYyAtIDkgKiBhICogZDtcbiAgdmFyIEMgPSBjICogYyAtIDMgKiBiICogZDtcbiAgdmFyIG4gPSAwO1xuXG4gIGlmIChpc0Fyb3VuZFplcm8oQSkgJiYgaXNBcm91bmRaZXJvKEIpKSB7XG4gICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgcm9vdHNbMF0gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdDEgPSAtYyAvIGI7IC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBCICogQiAtIDQgKiBBICogQztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIHZhciBLID0gQiAvIEE7XG4gICAgICB2YXIgdDEgPSAtYiAvIGEgKyBLOyAvLyB0MSwgYSBpcyBub3QgemVyb1xuXG4gICAgICB2YXIgdDIgPSAtSyAvIDI7IC8vIHQyLCB0M1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgWTEgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgKyBkaXNjU3FydCk7XG4gICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG5cbiAgICAgIGlmIChZMSA8IDApIHtcbiAgICAgICAgWTEgPSAtbWF0aFBvdygtWTEsIE9ORV9USElSRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBZMSA9IG1hdGhQb3coWTEsIE9ORV9USElSRCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChZMiA8IDApIHtcbiAgICAgICAgWTIgPSAtbWF0aFBvdygtWTIsIE9ORV9USElSRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBZMiA9IG1hdGhQb3coWTIsIE9ORV9USElSRCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0MSA9ICgtYiAtIChZMSArIFkyKSkgLyAoMyAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MoVCkgLyAzO1xuICAgICAgdmFyIEFTcXJ0ID0gbWF0aFNxcnQoQSk7XG4gICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgKyBBU3FydCAqICh0bXAgKyBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgdmFyIHQzID0gKC1iICsgQVNxcnQgKiAodG1wIC0gVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC855qE5L2N572uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGV4dHJlbWFcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgdmFyIHQxID0gLWMgLyBiO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgZXh0cmVtYVswXSA9IC1iIC8gKDIgKiBhKTtcbiAgICB9IGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHAzLCB0LCBvdXQpIHtcbiAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgdmFyIHAyMyA9IChwMyAtIHAyKSAqIHQgKyBwMjtcbiAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7XG4gIHZhciBwMTIzID0gKHAyMyAtIHAxMikgKiB0ICsgcDEyO1xuICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7IC8vIFNlZzBcblxuICBvdXRbMF0gPSBwMDtcbiAgb3V0WzFdID0gcDAxO1xuICBvdXRbMl0gPSBwMDEyO1xuICBvdXRbM10gPSBwMDEyMzsgLy8gU2VnMVxuXG4gIG91dFs0XSA9IHAwMTIzO1xuICBvdXRbNV0gPSBwMTIzO1xuICBvdXRbNl0gPSBwMjM7XG4gIG91dFs3XSA9IHAzO1xufVxuLyoqXG4gKiDmipXlsITngrnliLDkuInmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gKiBAcGFyYW0ge251bWJlcn0geTNcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0g5oqV5bCE54K5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHgsIHksIG91dCkge1xuICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gIHZhciB0O1xuICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgdmFyIGQgPSBJbmZpbml0eTtcbiAgdmFyIHByZXY7XG4gIHZhciBuZXh0O1xuICB2YXIgZDE7XG4gIHZhciBkMjtcbiAgX3YwWzBdID0geDtcbiAgX3YwWzFdID0geTsgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gIC8vIFBFTkRJTkdcblxuICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIF90KTtcbiAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBfdCk7XG4gICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuXG4gICAgaWYgKGQxIDwgZCkge1xuICAgICAgdCA9IF90O1xuICAgICAgZCA9IGQxO1xuICAgIH1cbiAgfVxuXG4gIGQgPSBJbmZpbml0eTsgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByZXYgPSB0IC0gaW50ZXJ2YWw7XG4gICAgbmV4dCA9IHQgKyBpbnRlcnZhbDsgLy8gdCAtIGludGVydmFsXG5cbiAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBwcmV2KTtcbiAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcbiAgICBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgdCA9IHByZXY7XG4gICAgICBkID0gZDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgX3YyWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgbmV4dCk7XG4gICAgICBfdjJbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBuZXh0KTtcbiAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgIGQgPSBkMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gdFxuXG5cbiAgaWYgKG91dCkge1xuICAgIG91dFswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgIG91dFsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICB9IC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcblxuXG4gIHJldHVybiBtYXRoU3FydChkKTtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5YC8XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0F0KHAwLCBwMSwgcDIsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIG9uZXQgKiAob25ldCAqIHAwICsgMiAqIHQgKiBwMSkgKyB0ICogdCAqIHAyO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlr7zmlbDlgLxcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuIDIgKiAoKDEgLSB0KSAqIChwMSAtIHAwKSArIHQgKiAocDIgLSBwMSkpO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljUm9vdEF0KHAwLCBwMSwgcDIsIHZhbCwgcm9vdHMpIHtcbiAgdmFyIGEgPSBwMCAtIDIgKiBwMSArIHAyO1xuICB2YXIgYiA9IDIgKiAocDEgLSBwMCk7XG4gIHZhciBjID0gcDAgLSB2YWw7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgdmFyIHQxID0gLWMgLyBiO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNFeHRyZW11bShwMCwgcDEsIHAyKSB7XG4gIHZhciBkaXZpZGVyID0gcDAgKyBwMiAtIDIgKiBwMTtcblxuICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgIC8vIHAxIGlzIGNlbnRlciBvZiBwMCBhbmQgcDJcbiAgICByZXR1cm4gMC41O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICB9XG59XG4vKipcbiAqIOe7huWIhuS6jOasoei0neWhnuWwlOabsue6v1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTsgLy8gU2VnMFxuXG4gIG91dFswXSA9IHAwO1xuICBvdXRbMV0gPSBwMDE7XG4gIG91dFsyXSA9IHAwMTI7IC8vIFNlZzFcblxuICBvdXRbM10gPSBwMDEyO1xuICBvdXRbNF0gPSBwMTI7XG4gIG91dFs1XSA9IHAyO1xufVxuLyoqXG4gKiDmipXlsITngrnliLDkuozmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgb3V0KSB7XG4gIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgdmFyIHQ7XG4gIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICB2YXIgZCA9IEluZmluaXR5O1xuICBfdjBbMF0gPSB4O1xuICBfdjBbMV0gPSB5OyAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgLy8gUEVORElOR1xuXG4gIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgX3YxWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgX3QpO1xuICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuXG4gICAgaWYgKGQxIDwgZCkge1xuICAgICAgdCA9IF90O1xuICAgICAgZCA9IGQxO1xuICAgIH1cbiAgfVxuXG4gIGQgPSBJbmZpbml0eTsgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgIHZhciBuZXh0ID0gdCArIGludGVydmFsOyAvLyB0IC0gaW50ZXJ2YWxcblxuICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHByZXYpO1xuICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgdCA9IHByZXY7XG4gICAgICBkID0gZDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICBfdjJbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBuZXh0KTtcbiAgICAgIHZhciBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgIHQgPSBuZXh0O1xuICAgICAgICBkID0gZDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHRcblxuXG4gIGlmIChvdXQpIHtcbiAgICBvdXRbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0KTtcbiAgICBvdXRbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgfSAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG5cblxuICByZXR1cm4gbWF0aFNxcnQoZCk7XG59XG5cbmV4cG9ydHMuY3ViaWNBdCA9IGN1YmljQXQ7XG5leHBvcnRzLmN1YmljRGVyaXZhdGl2ZUF0ID0gY3ViaWNEZXJpdmF0aXZlQXQ7XG5leHBvcnRzLmN1YmljUm9vdEF0ID0gY3ViaWNSb290QXQ7XG5leHBvcnRzLmN1YmljRXh0cmVtYSA9IGN1YmljRXh0cmVtYTtcbmV4cG9ydHMuY3ViaWNTdWJkaXZpZGUgPSBjdWJpY1N1YmRpdmlkZTtcbmV4cG9ydHMuY3ViaWNQcm9qZWN0UG9pbnQgPSBjdWJpY1Byb2plY3RQb2ludDtcbmV4cG9ydHMucXVhZHJhdGljQXQgPSBxdWFkcmF0aWNBdDtcbmV4cG9ydHMucXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xuZXhwb3J0cy5xdWFkcmF0aWNSb290QXQgPSBxdWFkcmF0aWNSb290QXQ7XG5leHBvcnRzLnF1YWRyYXRpY0V4dHJlbXVtID0gcXVhZHJhdGljRXh0cmVtdW07XG5leHBvcnRzLnF1YWRyYXRpY1N1YmRpdmlkZSA9IHF1YWRyYXRpY1N1YmRpdmlkZTtcbmV4cG9ydHMucXVhZHJhdGljUHJvamVjdFBvaW50ID0gcXVhZHJhdGljUHJvamVjdFBvaW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvY3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvY3VydmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIGVjaGFydHPorr7lpIfnjq/looPor4bliKtcbiAqXG4gKiBAZGVzYyBlY2hhcnRz5Z+65LqOQ2FudmFz77yM57qvSmF2YXNjcmlwdOWbvuihqOW6k++8jOaPkOS+m+ebtOingu+8jOeUn+WKqO+8jOWPr+S6pOS6ku+8jOWPr+S4quaAp+WMluWumuWItueahOaVsOaNrue7n+iuoeWbvuihqOOAglxuICogQGF1dGhvciBmaXJlZGVbZmlyZWRlQGZpcmVkZS51c11cbiAqIEBkZXNjIHRoYW5rcyB6ZXB0by5cbiAqL1xudmFyIGVudiA9IHt9O1xuXG5pZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gSW4gbm9kZVxuICBlbnYgPSB7XG4gICAgYnJvd3Nlcjoge30sXG4gICAgb3M6IHt9LFxuICAgIG5vZGU6IHRydWUsXG4gICAgLy8gQXNzdW1lIGNhbnZhcyBpcyBzdXBwb3J0ZWRcbiAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgc3ZnU3VwcG9ydGVkOiB0cnVlXG4gIH07XG59IGVsc2Uge1xuICBlbnYgPSBkZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IGVudjsgLy8gWmVwdG8uanNcbi8vIChjKSAyMDEwLTIwMTMgVGhvbWFzIEZ1Y2hzXG4vLyBaZXB0by5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG4gIHZhciBvcyA9IHt9O1xuICB2YXIgYnJvd3NlciA9IHt9OyAvLyB2YXIgd2Via2l0ID0gdWEubWF0Y2goL1dlYltrS11pdFtcXC9dezAsMX0oW1xcZC5dKykvKTtcbiAgLy8gdmFyIGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7XG4gIC8vIHZhciBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgLy8gdmFyIGlwb2QgPSB1YS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pO1xuICAvLyB2YXIgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKTtcbiAgLy8gdmFyIHdlYm9zID0gdWEubWF0Y2goLyh3ZWJPU3xocHdPUylbXFxzXFwvXShbXFxkLl0rKS8pO1xuICAvLyB2YXIgdG91Y2hwYWQgPSB3ZWJvcyAmJiB1YS5tYXRjaCgvVG91Y2hQYWQvKTtcbiAgLy8gdmFyIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHNpbGsgPSB1YS5tYXRjaCgvU2lsa1xcLyhbXFxkLl9dKykvKTtcbiAgLy8gdmFyIGJsYWNrYmVycnkgPSB1YS5tYXRjaCgvKEJsYWNrQmVycnkpLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgcmltdGFibGV0b3MgPSB1YS5tYXRjaCgvKFJJTVxcc1RhYmxldFxcc09TKVxccyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgcGxheWJvb2sgPSB1YS5tYXRjaCgvUGxheUJvb2svKTtcbiAgLy8gdmFyIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKTtcblxuICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7IC8vIHZhciBzYWZhcmkgPSB3ZWJraXQgJiYgdWEubWF0Y2goL01vYmlsZVxcLy8pICYmICFjaHJvbWU7XG4gIC8vIHZhciB3ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSAmJiAhY2hyb21lO1xuXG4gIHZhciBpZSA9IHVhLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLykgLy8gSUUgMTEgVHJpZGVudC83LjA7IHJ2OjExLjBcbiAgfHwgdWEubWF0Y2goL1RyaWRlbnRcXC8uKz9ydjooKFtcXGQuXSspKS8pO1xuICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICB2YXIgd2VDaGF0ID0gL21pY3JvbWVzc2VuZ2VyL2kudGVzdCh1YSk7IC8vIFRvZG86IGNsZWFuIHRoaXMgdXAgd2l0aCBhIGJldHRlciBPUy9icm93c2VyIHNlcGVyYXRpb246XG4gIC8vIC0gZGlzY2VybiAobW9yZSkgYmV0d2VlbiBtdWx0aXBsZSBicm93c2VycyBvbiBhbmRyb2lkXG4gIC8vIC0gZGVjaWRlIGlmIGtpbmRsZSBmaXJlIGluIHNpbGsgbW9kZSBpcyBhbmRyb2lkIG9yIG5vdFxuICAvLyAtIEZpcmVmb3ggb24gQW5kcm9pZCBkb2Vzbid0IHNwZWNpZnkgdGhlIEFuZHJvaWQgdmVyc2lvblxuICAvLyAtIHBvc3NpYmx5IGRldmlkZSBpbiBvcywgZGV2aWNlIGFuZCBicm93c2VyIGhhc2hlc1xuICAvLyBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdO1xuICAvLyBpZiAoYW5kcm9pZCkgb3MuYW5kcm9pZCA9IHRydWUsIG9zLnZlcnNpb24gPSBhbmRyb2lkWzJdO1xuICAvLyBpZiAoaXBob25lICYmICFpcG9kKSBvcy5pb3MgPSBvcy5pcGhvbmUgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBob25lWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgLy8gaWYgKGlwYWQpIG9zLmlvcyA9IG9zLmlwYWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBhZFsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gIC8vIGlmIChpcG9kKSBvcy5pb3MgPSBvcy5pcG9kID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwb2RbM10gPyBpcG9kWzNdLnJlcGxhY2UoL18vZywgJy4nKSA6IG51bGw7XG4gIC8vIGlmICh3ZWJvcykgb3Mud2Vib3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gd2Vib3NbMl07XG4gIC8vIGlmICh0b3VjaHBhZCkgb3MudG91Y2hwYWQgPSB0cnVlO1xuICAvLyBpZiAoYmxhY2tiZXJyeSkgb3MuYmxhY2tiZXJyeSA9IHRydWUsIG9zLnZlcnNpb24gPSBibGFja2JlcnJ5WzJdO1xuICAvLyBpZiAoYmIxMCkgb3MuYmIxMCA9IHRydWUsIG9zLnZlcnNpb24gPSBiYjEwWzJdO1xuICAvLyBpZiAocmltdGFibGV0b3MpIG9zLnJpbXRhYmxldG9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHJpbXRhYmxldG9zWzJdO1xuICAvLyBpZiAocGxheWJvb2spIGJyb3dzZXIucGxheWJvb2sgPSB0cnVlO1xuICAvLyBpZiAoa2luZGxlKSBvcy5raW5kbGUgPSB0cnVlLCBvcy52ZXJzaW9uID0ga2luZGxlWzFdO1xuICAvLyBpZiAoc2lsaykgYnJvd3Nlci5zaWxrID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gc2lsa1sxXTtcbiAgLy8gaWYgKCFzaWxrICYmIG9zLmFuZHJvaWQgJiYgdWEubWF0Y2goL0tpbmRsZSBGaXJlLykpIGJyb3dzZXIuc2lsayA9IHRydWU7XG4gIC8vIGlmIChjaHJvbWUpIGJyb3dzZXIuY2hyb21lID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gY2hyb21lWzFdO1xuXG4gIGlmIChmaXJlZm94KSB7XG4gICAgYnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBmaXJlZm94WzFdO1xuICB9IC8vIGlmIChzYWZhcmkgJiYgKHVhLm1hdGNoKC9TYWZhcmkvKSB8fCAhIW9zLmlvcykpIGJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbiAgLy8gaWYgKHdlYnZpZXcpIGJyb3dzZXIud2VidmlldyA9IHRydWU7XG5cblxuICBpZiAoaWUpIHtcbiAgICBicm93c2VyLmllID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgfVxuXG4gIGlmIChlZGdlKSB7XG4gICAgYnJvd3Nlci5lZGdlID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICB9IC8vIEl0IGlzIGRpZmZpY3VsdCB0byBkZXRlY3QgV2VDaGF0IGluIFdpbiBQaG9uZSBwcmVjaXNlbHksIGJlY2F1c2UgdWEgY2FuXG4gIC8vIG5vdCBiZSBzZXQgb24gd2luIHBob25lLiBTbyB3ZSBkbyBub3QgY29uc2lkZXIgV2luIFBob25lLlxuXG5cbiAgaWYgKHdlQ2hhdCkge1xuICAgIGJyb3dzZXIud2VDaGF0ID0gdHJ1ZTtcbiAgfSAvLyBvcy50YWJsZXQgPSAhIShpcGFkIHx8IHBsYXlib29rIHx8IChhbmRyb2lkICYmICF1YS5tYXRjaCgvTW9iaWxlLykpIHx8XG4gIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvVGFibGV0LykpIHx8IChpZSAmJiAhdWEubWF0Y2goL1Bob25lLykgJiYgdWEubWF0Y2goL1RvdWNoLykpKTtcbiAgLy8gb3MucGhvbmUgID0gISEoIW9zLnRhYmxldCAmJiAhb3MuaXBvZCAmJiAoYW5kcm9pZCB8fCBpcGhvbmUgfHwgd2Vib3MgfHxcbiAgLy8gICAgIChjaHJvbWUgJiYgdWEubWF0Y2goL0FuZHJvaWQvKSkgfHwgKGNocm9tZSAmJiB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKSkgfHxcbiAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9Nb2JpbGUvKSkgfHwgKGllICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSkpO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIG9zOiBvcyxcbiAgICBub2RlOiBmYWxzZSxcbiAgICAvLyDljp/nlJ9jYW52YXPmlK/mjIHvvIzmlLnmnoHnq6/ngrnkuoZcbiAgICAvLyBjYW52YXNTdXBwb3J0ZWQgOiAhKGJyb3dzZXIuaWUgJiYgcGFyc2VGbG9hdChicm93c2VyLnZlcnNpb24pIDwgOSlcbiAgICBjYW52YXNTdXBwb3J0ZWQ6ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcbiAgICBzdmdTdXBwb3J0ZWQ6IHR5cGVvZiBTVkdSZWN0ICE9PSAndW5kZWZpbmVkJyxcbiAgICAvLyBAc2VlIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ4MTcwMjkvd2hhdHMtdGhlLWJlc3Qtd2F5LXRvLWRldGVjdC1hLXRvdWNoLXNjcmVlbi1kZXZpY2UtdXNpbmctamF2YXNjcmlwdD5cbiAgICAvLyB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4gICAgLy8gSUUxMC8xMSBkb2VzIG5vdCBzdXBwb3J0IHRvdWNoIGV2ZW50LCBhbmQgTVMgRWRnZSBzdXBwb3J0cyB0aGVtIGJ1dCBub3QgYnlcbiAgICAvLyBkZWZhdWx0LCBzbyB3ZSBkb250IGNoZWNrIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyBmb3IgdGhlbSBoZXJlLlxuICAgIHRvdWNoRXZlbnRzU3VwcG9ydGVkOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIWJyb3dzZXIuaWUgJiYgIWJyb3dzZXIuZWRnZSxcbiAgICAvLyA8aHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cG9pbnRlciUyMGV2ZW50Pi5cbiAgICBwb2ludGVyRXZlbnRzU3VwcG9ydGVkOiAnb25wb2ludGVyZG93bicgaW4gd2luZG93IC8vIEZpcmVmb3ggc3VwcG9ydHMgcG9pbnRlciBidXQgbm90IGJ5IGRlZmF1bHQsIG9ubHkgTVMgYnJvd3NlcnMgYXJlIHJlbGlhYmxlIG9uIHBvaW50ZXJcbiAgICAvLyBldmVudHMgY3VycmVudGx5LiBTbyB3ZSBkb250IHVzZSB0aGF0IG9uIG90aGVyIGJyb3dzZXJzIHVubGVzcyB0ZXN0ZWQgc3VmZmljaWVudGx5LlxuICAgIC8vIEFsdGhvdWdoIElFIDEwIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnQsIGl0IHVzZSBvbGQgc3R5bGUgYW5kIGlzIGRpZmZlcmVudCBmcm9tIHRoZVxuICAgIC8vIHN0YW5kYXJkLiBTbyB3ZSBleGNsdWRlIHRoYXQuIChJRSAxMCBpcyBoYXJkbHkgdXNlZCBvbiB0b3VjaCBkZXZpY2UpXG4gICAgJiYgKGJyb3dzZXIuZWRnZSB8fCBicm93c2VyLmllICYmIGJyb3dzZXIudmVyc2lvbiA+PSAxMSlcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2Vudi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9lbnYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbmV4cG9ydHMuRGlzcGF0Y2hlciA9IEV2ZW50ZnVsO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vZW52XCIpO1xuXG4vKipcbiAqIOS6i+S7tui+heWKqeexu1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG52YXIgaXNEb21MZXZlbDIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xudmFyIE1PVVNFX0VWRU5UX1JFRyA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLztcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG4gIH07XG59IC8vIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlXG5cblxuZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0LCBjYWxjdWxhdGUpIHtcbiAgb3V0ID0gb3V0IHx8IHt9OyAvLyBBY2NvcmRpbmcgdG8gdGhlIFczQyBXb3JraW5nIERyYWZ0LCBvZmZzZXRYIGFuZCBvZmZzZXRZIHNob3VsZCBiZSByZWxhdGl2ZVxuICAvLyB0byB0aGUgcGFkZGluZyBlZGdlIG9mIHRoZSB0YXJnZXQgZWxlbWVudC4gVGhlIG9ubHkgYnJvd3NlciB1c2luZyB0aGlzIGNvbnZlbnRpb25cbiAgLy8gaXMgSUUuIFdlYmtpdCB1c2VzIHRoZSBib3JkZXIgZWRnZSwgT3BlcmEgdXNlcyB0aGUgY29udGVudCBlZGdlLCBhbmQgRmlyZUZveCBkb2VzXG4gIC8vIG5vdCBzdXBwb3J0IHRoZSBwcm9wZXJ0aWVzLlxuICAvLyAoc2VlIGh0dHA6Ly93d3cuamFja2xtb29yZS5jb20vbm90ZXMvbW91c2UtcG9zaXRpb24vKVxuICAvLyBJbiB6ciBwYWludGVyLmRvbSwgcGFkZGluZyBlZGdlIGVxdWFscyB0byBib3JkZXIgZWRnZS5cbiAgLy8gRklYTUVcbiAgLy8gV2hlbiBtb3VzZW1vdmUgZXZlbnQgdHJpZ2dlcmVkIG9uIGVjIHRvb2x0aXAsIHRhcmdldCBpcyBub3QgenIgcGFpbnRlci5kb20sIGFuZFxuICAvLyBvZmZzZXRYL1kgaXMgcmVsYXRpdmUgdG8gZS50YXJnZXQsIHdoZXJlIHRoZSBjYWxjdWxhdGlvbiBvZiB6clgvWSB2aWEgb2Zmc2V0WC9ZXG4gIC8vIGlzIHRvbyBjb21wbGV4LiBTbyBjc3MtdHJhbnNmcm9tIGRvbnQgc3VwcG9ydCBpbiB0aGlzIGNhc2UgdGVtcG9yYXJpbHkuXG5cbiAgaWYgKGNhbGN1bGF0ZSB8fCAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICB9IC8vIENhdXRpb246IEluIEZpcmVGb3gsIGxheWVyWC9sYXllclkgTW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGNsb3Nlc3QgcG9zaXRpb25lZFxuICAvLyBhbmNlc3RvciBlbGVtZW50LCBzbyB3ZSBzaG91bGQgbWFrZSBzdXJlIGVsIGlzIHBvc2l0aW9uZWQgKGUuZy4sIG5vdCBwb3NpdGlvbjpzdGF0aWMpLlxuICAvLyBCVFcxLCBXZWJraXQgZG9uJ3QgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgRkYgaW4gbm9uLXNpbXBsZSBjYXNlcyAobGlrZSBhZGRcbiAgLy8gem9vbS1mYWN0b3IsIG92ZXJmbG93IC8gb3BhY2l0eSBsYXllcnMsIHRyYW5zZm9ybXMgLi4uKVxuICAvLyBCVFcyLCAoZXYub2Zmc2V0WSB8fCBldi5wYWdlWSAtICQoZXYudGFyZ2V0KS5vZmZzZXQoKS50b3ApIGlzIG5vdCBjb3JyZWN0IGluIHByZXNlcnZlLTNkLlxuICAvLyA8aHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzg1MjMjY29tbWVudDoxND5cbiAgLy8gQlRXMywgSW4gZmYsIG9mZnNldFgvb2Zmc2V0WSBpcyBhbHdheXMgMC5cbiAgZWxzZSBpZiAoZW52LmJyb3dzZXIuZmlyZWZveCAmJiBlLmxheWVyWCAhPSBudWxsICYmIGUubGF5ZXJYICE9PSBlLm9mZnNldFgpIHtcbiAgICAgIG91dC56clggPSBlLmxheWVyWDtcbiAgICAgIG91dC56clkgPSBlLmxheWVyWTtcbiAgICB9IC8vIEZvciBJRTYrLCBjaHJvbWUsIHNhZmFyaSwgb3BlcmEuIChXaGVuIHdpbGwgZmYgc3VwcG9ydCBvZmZzZXRYPylcbiAgICBlbHNlIGlmIChlLm9mZnNldFggIT0gbnVsbCkge1xuICAgICAgICBvdXQuenJYID0gZS5vZmZzZXRYO1xuICAgICAgICBvdXQuenJZID0gZS5vZmZzZXRZO1xuICAgICAgfSAvLyBGb3Igc29tZSBvdGhlciBkZXZpY2UsIGUuZy4sIElPUyBzYWZhcmkuXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KTtcbiAgICAgICAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpIHtcbiAgLy8gVGhpcyB3ZWxsLWtub3duIG1ldGhvZCBiZWxvdyBkb2VzIG5vdCBzdXBwb3J0IGNzcyB0cmFuc2Zvcm0uXG4gIHZhciBib3ggPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuICBvdXQuenJYID0gZS5jbGllbnRYIC0gYm94LmxlZnQ7XG4gIG91dC56clkgPSBlLmNsaWVudFkgLSBib3gudG9wO1xufVxuLyoqXG4gKiDlpoLmnpzlrZjlnKjnrKzkuInmlrnltYzlhaXnmoTkuIDkuptkb23op6blj5HnmoTkuovku7bvvIzmiJZ0b3VjaOS6i+S7tu+8jOmcgOimgei9rOaNouS4gOS4i+S6i+S7tuWdkOaghy5cbiAqIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUsIGNhbGN1bGF0ZSkge1xuICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHZhciBldmVudFR5cGUgPSBlLnR5cGU7XG4gIHZhciBpc1RvdWNoID0gZXZlbnRUeXBlICYmIGV2ZW50VHlwZS5pbmRleE9mKCd0b3VjaCcpID49IDA7XG5cbiAgaWYgKCFpc1RvdWNoKSB7XG4gICAgY2xpZW50VG9Mb2NhbChlbCwgZSwgZSwgY2FsY3VsYXRlKTtcbiAgICBlLnpyRGVsdGEgPSBlLndoZWVsRGVsdGEgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgfSBlbHNlIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudFR5cGUgIT0gJ3RvdWNoZW5kJyA/IGUudGFyZ2V0VG91Y2hlc1swXSA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdG91Y2ggJiYgY2xpZW50VG9Mb2NhbChlbCwgdG91Y2gsIGUsIGNhbGN1bGF0ZSk7XG4gIH0gLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodDsgb3RoZXJ3aXNlOiAwO1xuICAvLyBTZWUgalF1ZXJ5OiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvZXZlbnQuanNcbiAgLy8gSWYgZS53aGljaCBoYXMgYmVlbiBkZWZpbmVkLCBpZiBtYXkgYmUgcmVhZG9ubHksXG4gIC8vIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvd2hpY2hcblxuXG4gIHZhciBidXR0b24gPSBlLmJ1dHRvbjtcblxuICBpZiAoZS53aGljaCA9PSBudWxsICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIE1PVVNFX0VWRU5UX1JFRy50ZXN0KGUudHlwZSkpIHtcbiAgICBlLndoaWNoID0gYnV0dG9uICYgMSA/IDEgOiBidXR0b24gJiAyID8gMyA6IGJ1dHRvbiAmIDQgPyAyIDogMDtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gIGlmIChpc0RvbUxldmVsMikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gIH1cbn1cbi8qKlxuICogcHJldmVudERlZmF1bHQgYW5kIHN0b3BQcm9wYWdhdGlvbi5cbiAqIE5vdGljZTogZG8gbm90IGRvIHRoYXQgaW4genJlbmRlci4gVXBwZXIgYXBwbGljYXRpb25cbiAqIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2V2ZW50XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge0V2ZW50fSBlIDogZXZlbnTlr7nosaFcbiAqL1xuXG5cbnZhciBzdG9wID0gaXNEb21MZXZlbDIgPyBmdW5jdGlvbiAoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn0gOiBmdW5jdGlvbiAoZSkge1xuICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIG5vdExlZnRNb3VzZShlKSB7XG4gIC8vIElmIGUud2hpY2ggaXMgdW5kZWZpbmVkLCBjb25zaWRlcmVkIGFzIGxlZnQgbW91c2UgZXZlbnQuXG4gIHJldHVybiBlLndoaWNoID4gMTtcbn0gLy8g5YGa5ZCR5LiK5YW85a65XG5cblxuZXhwb3J0cy5jbGllbnRUb0xvY2FsID0gY2xpZW50VG9Mb2NhbDtcbmV4cG9ydHMubm9ybWFsaXplRXZlbnQgPSBub3JtYWxpemVFdmVudDtcbmV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5zdG9wID0gc3RvcDtcbmV4cG9ydHMubm90TGVmdE1vdXNlID0gbm90TGVmdE1vdXNlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIHpyZW5kZXI6IOeUn+aIkOWUr+S4gGlkXG4gKlxuICogQGF1dGhvciBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG52YXIgaWRTdGFydCA9IDB4MDkwNztcblxuZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gIHJldHVybiBpZFN0YXJ0Kys7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9ndWlkLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBkZWJ1Z01vZGUgPSBfY29uZmlnLmRlYnVnTW9kZTtcblxudmFyIGxvZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5pZiAoZGVidWdNb2RlID09PSAxKSB7XG4gIGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3VtZW50c1trXSk7XG4gICAgfVxuICB9O1xufSBlbHNlIGlmIChkZWJ1Z01vZGUgPiAxKSB7XG4gIGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzW2tdKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IGxvZztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9sb2cuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiAzeDLnn6npmLXmk43kvZznsbtcbiAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC9tYXRyaXhcbiAqL1xudmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gQXJyYXkgOiBGbG9hdDMyQXJyYXk7XG4vKipcbiAqIOWIm+W7uuS4gOS4quWNleS9jeefqemYtVxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoNik7XG4gIGlkZW50aXR5KG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuvue9ruefqemYteS4uuWNleS9jeefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWkjeWItuefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBtKSB7XG4gIG91dFswXSA9IG1bMF07XG4gIG91dFsxXSA9IG1bMV07XG4gIG91dFsyXSA9IG1bMl07XG4gIG91dFszXSA9IG1bM107XG4gIG91dFs0XSA9IG1bNF07XG4gIG91dFs1XSA9IG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOefqemYteebuOS5mFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0xXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bChvdXQsIG0xLCBtMikge1xuICAvLyBDb25zaWRlciBtYXRyaXgubXVsKG0sIG0yLCBtKTtcbiAgLy8gd2hlcmUgb3V0IGlzIHRoZSBzYW1lIGFzIG0yLlxuICAvLyBTbyB1c2UgdGVtcCB2YXJpYWJsZSB0byBlc2NhcGUgZXJyb3IuXG4gIHZhciBvdXQwID0gbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV07XG4gIHZhciBvdXQxID0gbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV07XG4gIHZhciBvdXQyID0gbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM107XG4gIHZhciBvdXQzID0gbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM107XG4gIHZhciBvdXQ0ID0gbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XTtcbiAgdmFyIG91dDUgPSBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdO1xuICBvdXRbMF0gPSBvdXQwO1xuICBvdXRbMV0gPSBvdXQxO1xuICBvdXRbMl0gPSBvdXQyO1xuICBvdXRbM10gPSBvdXQzO1xuICBvdXRbNF0gPSBvdXQ0O1xuICBvdXRbNV0gPSBvdXQ1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlubPnp7vlj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgdlswXTtcbiAgb3V0WzVdID0gYVs1XSArIHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaXi+i9rOWPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYWEgPSBhWzBdO1xuICB2YXIgYWMgPSBhWzJdO1xuICB2YXIgYXR4ID0gYVs0XTtcbiAgdmFyIGFiID0gYVsxXTtcbiAgdmFyIGFkID0gYVszXTtcbiAgdmFyIGF0eSA9IGFbNV07XG4gIHZhciBzdCA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjdCA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGFhICogY3QgKyBhYiAqIHN0O1xuICBvdXRbMV0gPSAtYWEgKiBzdCArIGFiICogY3Q7XG4gIG91dFsyXSA9IGFjICogY3QgKyBhZCAqIHN0O1xuICBvdXRbM10gPSAtYWMgKiBzdCArIGN0ICogYWQ7XG4gIG91dFs0XSA9IGN0ICogYXR4ICsgc3QgKiBhdHk7XG4gIG91dFs1XSA9IGN0ICogYXR5IC0gc3QgKiBhdHg7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOe8qeaUvuWPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHZ4ID0gdlswXTtcbiAgdmFyIHZ5ID0gdlsxXTtcbiAgb3V0WzBdID0gYVswXSAqIHZ4O1xuICBvdXRbMV0gPSBhWzFdICogdnk7XG4gIG91dFsyXSA9IGFbMl0gKiB2eDtcbiAgb3V0WzNdID0gYVszXSAqIHZ5O1xuICBvdXRbNF0gPSBhWzRdICogdng7XG4gIG91dFs1XSA9IGFbNV0gKiB2eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC6YCG55+p6Zi1XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICovXG5cblxuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYWEgPSBhWzBdO1xuICB2YXIgYWMgPSBhWzJdO1xuICB2YXIgYXR4ID0gYVs0XTtcbiAgdmFyIGFiID0gYVsxXTtcbiAgdmFyIGFkID0gYVszXTtcbiAgdmFyIGF0eSA9IGFbNV07XG4gIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgb3V0WzFdID0gLWFiICogZGV0O1xuICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gIG91dFszXSA9IGFhICogZGV0O1xuICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5tdWwgPSBtdWw7XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbmV4cG9ydHMucm90YXRlID0gcm90YXRlO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9tYXRyaXguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL216aWNjYXJkL25vZGUtdGltc29ydFxudmFyIERFRkFVTFRfTUlOX01FUkdFID0gMzI7XG52YXIgREVGQVVMVF9NSU5fR0FMTE9QSU5HID0gNztcbnZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuZnVuY3Rpb24gbWluUnVuTGVuZ3RoKG4pIHtcbiAgdmFyIHIgPSAwO1xuXG4gIHdoaWxlIChuID49IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgciB8PSBuICYgMTtcbiAgICBuID4+PSAxO1xuICB9XG5cbiAgcmV0dXJuIG4gKyByO1xufVxuXG5mdW5jdGlvbiBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpIHtcbiAgdmFyIHJ1bkhpID0gbG8gKyAxO1xuXG4gIGlmIChydW5IaSA9PT0gaGkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA8IDApIHtcbiAgICAgIHJ1bkhpKys7XG4gICAgfVxuXG4gICAgcmV2ZXJzZVJ1bihhcnJheSwgbG8sIHJ1bkhpKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgcnVuSGkrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnVuSGkgLSBsbztcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVJ1bihhcnJheSwgbG8sIGhpKSB7XG4gIGhpLS07XG5cbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgdCA9IGFycmF5W2xvXTtcbiAgICBhcnJheVtsbysrXSA9IGFycmF5W2hpXTtcbiAgICBhcnJheVtoaS0tXSA9IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBzdGFydCwgY29tcGFyZSkge1xuICBpZiAoc3RhcnQgPT09IGxvKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuXG4gIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgdmFyIHBpdm90ID0gYXJyYXlbc3RhcnRdO1xuICAgIHZhciBsZWZ0ID0gbG87XG4gICAgdmFyIHJpZ2h0ID0gc3RhcnQ7XG4gICAgdmFyIG1pZDtcblxuICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgIG1pZCA9IGxlZnQgKyByaWdodCA+Pj4gMTtcblxuICAgICAgaWYgKGNvbXBhcmUocGl2b3QsIGFycmF5W21pZF0pIDwgMCkge1xuICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuID0gc3RhcnQgLSBsZWZ0O1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGFycmF5W2xlZnQgKyAzXSA9IGFycmF5W2xlZnQgKyAyXTtcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBhcnJheVtsZWZ0ICsgMl0gPSBhcnJheVtsZWZ0ICsgMV07XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYXJyYXlbbGVmdF0gPSBwaXZvdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnYWxsb3BMZWZ0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gIHZhciBtYXhPZmZzZXQgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMTtcblxuICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPiAwKSB7XG4gICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPiAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICBvZmZzZXQgKz0gaGludDtcbiAgfSBlbHNlIHtcbiAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPD0gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICB9XG5cbiAgbGFzdE9mZnNldCsrO1xuXG4gIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pID4gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSBtO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGdhbGxvcFJpZ2h0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gIHZhciBtYXhPZmZzZXQgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMTtcblxuICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPCAwKSB7XG4gICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDwgMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICB9IGVsc2Uge1xuICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID49IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgIG9mZnNldCArPSBoaW50O1xuICB9XG5cbiAgbGFzdE9mZnNldCsrO1xuXG4gIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgb2Zmc2V0ID0gbTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgdmFyIG1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciB0bXBTdG9yYWdlTGVuZ3RoID0gREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEg7XG4gIHZhciBzdGFja0xlbmd0aCA9IDA7XG4gIHZhciBydW5TdGFydDtcbiAgdmFyIHJ1bkxlbmd0aDtcbiAgdmFyIHN0YWNrU2l6ZSA9IDA7XG4gIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgMiAqIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIKSB7XG4gICAgdG1wU3RvcmFnZUxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgfVxuXG4gIHZhciB0bXAgPSBbXTtcbiAgc3RhY2tMZW5ndGggPSBsZW5ndGggPCAxMjAgPyA1IDogbGVuZ3RoIDwgMTU0MiA/IDEwIDogbGVuZ3RoIDwgMTE5MTUxID8gMTkgOiA0MDtcbiAgcnVuU3RhcnQgPSBbXTtcbiAgcnVuTGVuZ3RoID0gW107XG5cbiAgZnVuY3Rpb24gcHVzaFJ1bihfcnVuU3RhcnQsIF9ydW5MZW5ndGgpIHtcbiAgICBydW5TdGFydFtzdGFja1NpemVdID0gX3J1blN0YXJ0O1xuICAgIHJ1bkxlbmd0aFtzdGFja1NpemVdID0gX3J1bkxlbmd0aDtcbiAgICBzdGFja1NpemUgKz0gMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlUnVucygpIHtcbiAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICBpZiAobiA+PSAxICYmIHJ1bkxlbmd0aFtuIC0gMV0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgcnVuTGVuZ3RoW24gLSAyXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgIGlmIChydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChydW5MZW5ndGhbbl0gPiBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBtZXJnZUF0KG4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlTWVyZ2VSdW5zKCkge1xuICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgIGlmIChuID4gMCAmJiBydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICBuLS07XG4gICAgICB9XG5cbiAgICAgIG1lcmdlQXQobik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VBdChpKSB7XG4gICAgdmFyIHN0YXJ0MSA9IHJ1blN0YXJ0W2ldO1xuICAgIHZhciBsZW5ndGgxID0gcnVuTGVuZ3RoW2ldO1xuICAgIHZhciBzdGFydDIgPSBydW5TdGFydFtpICsgMV07XG4gICAgdmFyIGxlbmd0aDIgPSBydW5MZW5ndGhbaSArIDFdO1xuICAgIHJ1bkxlbmd0aFtpXSA9IGxlbmd0aDEgKyBsZW5ndGgyO1xuXG4gICAgaWYgKGkgPT09IHN0YWNrU2l6ZSAtIDMpIHtcbiAgICAgIHJ1blN0YXJ0W2kgKyAxXSA9IHJ1blN0YXJ0W2kgKyAyXTtcbiAgICAgIHJ1bkxlbmd0aFtpICsgMV0gPSBydW5MZW5ndGhbaSArIDJdO1xuICAgIH1cblxuICAgIHN0YWNrU2l6ZS0tO1xuICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgc3RhcnQxICs9IGs7XG4gICAgbGVuZ3RoMSAtPSBrO1xuXG4gICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZW5ndGgyID0gZ2FsbG9wTGVmdChhcnJheVtzdGFydDEgKyBsZW5ndGgxIC0gMV0sIGFycmF5LCBzdGFydDIsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDEgPD0gbGVuZ3RoMikge1xuICAgICAgbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQxICsgaV07XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvcjEgPSAwO1xuICAgIHZhciBjdXJzb3IyID0gc3RhcnQyO1xuICAgIHZhciBkZXN0ID0gc3RhcnQxO1xuICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG4gICAgdmFyIGNvdW50MSwgY291bnQyLCBleGl0O1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGNvdW50MSA9IDA7XG4gICAgICBjb3VudDIgPSAwO1xuICAgICAgZXhpdCA9IGZhbHNlO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb21wYXJlKGFycmF5W2N1cnNvcjJdLCB0bXBbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG4gICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZG8ge1xuICAgICAgICBjb3VudDEgPSBnYWxsb3BSaWdodChhcnJheVtjdXJzb3IyXSwgdG1wLCBjdXJzb3IxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MTsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3QgKz0gY291bnQxO1xuICAgICAgICAgIGN1cnNvcjEgKz0gY291bnQxO1xuICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aDEgPD0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudDIgPSBnYWxsb3BMZWZ0KHRtcFtjdXJzb3IxXSwgYXJyYXksIGN1cnNvcjIsIGxlbmd0aDIsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0ICs9IGNvdW50MjtcbiAgICAgICAgICBjdXJzb3IyICs9IGNvdW50MjtcbiAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcblxuICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKF9taW5HYWxsb3AgPCAwKSB7XG4gICAgICAgIF9taW5HYWxsb3AgPSAwO1xuICAgICAgfVxuXG4gICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgfVxuXG4gICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcbiAgICBtaW5HYWxsb3AgPCAxICYmIChtaW5HYWxsb3AgPSAxKTtcblxuICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7IC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MiArIGldO1xuICAgIH1cblxuICAgIHZhciBjdXJzb3IxID0gc3RhcnQxICsgbGVuZ3RoMSAtIDE7XG4gICAgdmFyIGN1cnNvcjIgPSBsZW5ndGgyIC0gMTtcbiAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgIHZhciBjdXN0b21DdXJzb3IgPSAwO1xuICAgIHZhciBjdXN0b21EZXN0ID0gMDtcbiAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgdmFyIGNvdW50MiA9IDA7XG4gICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb21wYXJlKHRtcFtjdXJzb3IyXSwgYXJyYXlbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgIGNvdW50MiA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG4gICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZG8ge1xuICAgICAgICBjb3VudDEgPSBsZW5ndGgxIC0gZ2FsbG9wUmlnaHQodG1wW2N1cnNvcjJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCBsZW5ndGgxIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgIGRlc3QgLT0gY291bnQxO1xuICAgICAgICAgIGN1cnNvcjEgLT0gY291bnQxO1xuICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY291bnQyID0gbGVuZ3RoMiAtIGdhbGxvcExlZnQoYXJyYXlbY3Vyc29yMV0sIHRtcCwgMCwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICBjdXJzb3IyIC09IGNvdW50MjtcbiAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcbiAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMiArIDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IHRtcFtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMiA8PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICB9XG5cbiAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgaWYgKG1pbkdhbGxvcCA8IDEpIHtcbiAgICAgIG1pbkdhbGxvcCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7IC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VIaWdoIHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMubWVyZ2VSdW5zID0gbWVyZ2VSdW5zO1xuICB0aGlzLmZvcmNlTWVyZ2VSdW5zID0gZm9yY2VNZXJnZVJ1bnM7XG4gIHRoaXMucHVzaFJ1biA9IHB1c2hSdW47XG59XG5cbmZ1bmN0aW9uIHNvcnQoYXJyYXksIGNvbXBhcmUsIGxvLCBoaSkge1xuICBpZiAoIWxvKSB7XG4gICAgbG8gPSAwO1xuICB9XG5cbiAgaWYgKCFoaSkge1xuICAgIGhpID0gYXJyYXkubGVuZ3RoO1xuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgaWYgKHJlbWFpbmluZyA8IDIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcnVuTGVuZ3RoID0gMDtcblxuICBpZiAocmVtYWluaW5nIDwgREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0cyA9IG5ldyBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKTtcbiAgdmFyIG1pblJ1biA9IG1pblJ1bkxlbmd0aChyZW1haW5pbmcpO1xuXG4gIGRvIHtcbiAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuXG4gICAgaWYgKHJ1bkxlbmd0aCA8IG1pblJ1bikge1xuICAgICAgdmFyIGZvcmNlID0gcmVtYWluaW5nO1xuXG4gICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgZm9yY2UgPSBtaW5SdW47XG4gICAgICB9XG5cbiAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBsbyArIGZvcmNlLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICBydW5MZW5ndGggPSBmb3JjZTtcbiAgICB9XG5cbiAgICB0cy5wdXNoUnVuKGxvLCBydW5MZW5ndGgpO1xuICAgIHRzLm1lcmdlUnVucygpO1xuICAgIHJlbWFpbmluZyAtPSBydW5MZW5ndGg7XG4gICAgbG8gKz0gcnVuTGVuZ3RoO1xuICB9IHdoaWxlIChyZW1haW5pbmcgIT09IDApO1xuXG4gIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvdXRpbFxuICovXG4vLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbnZhciBCVUlMVElOX09CSkVDVCA9IHtcbiAgJ1tvYmplY3QgRnVuY3Rpb25dJzogMSxcbiAgJ1tvYmplY3QgUmVnRXhwXSc6IDEsXG4gICdbb2JqZWN0IERhdGVdJzogMSxcbiAgJ1tvYmplY3QgRXJyb3JdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nOiAxLFxuICAvLyBGb3Igbm9kZS1jYW52YXNcbiAgJ1tvYmplY3QgSW1hZ2VdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzXSc6IDFcbn07XG52YXIgVFlQRURfQVJSQVkgPSB7XG4gICdbb2JqZWN0IEludDhBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50OEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgSW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IDFcbn07XG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgbmF0aXZlRm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbnZhciBuYXRpdmVGaWx0ZXIgPSBhcnJheVByb3RvLmZpbHRlcjtcbnZhciBuYXRpdmVTbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG52YXIgbmF0aXZlTWFwID0gYXJyYXlQcm90by5tYXA7XG52YXIgbmF0aXZlUmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIFRob3NlIGRhdGEgdHlwZXMgY2FuIGJlIGNsb25lZDpcbiAqICAgICBQbGFpbiBvYmplY3QsIEFycmF5LCBUeXBlZEFycmF5LCBudW1iZXIsIHN0cmluZywgbnVsbCwgdW5kZWZpbmVkLlxuICogVGhvc2UgZGF0YSB0eXBlcyB3aWxsIGJlIGFzc2dpbmVkIHVzaW5nIHRoZSBvcmdpbmFsIGRhdGE6XG4gKiAgICAgQlVJTFRJTl9PQkpFQ1RcbiAqIEluc3RhbmNlIG9mIHVzZXIgZGVmaW5lZCBjbGFzcyB3aWxsIGJlIGNsb25lZCB0byBhIHBsYWluIG9iamVjdCwgd2l0aG91dFxuICogcHJvcGVydGllcyBpbiBwcm90b3R5cGUuXG4gKiBPdGhlciBkYXRhIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQgKG5vdCBzdXJlIHdoYXQgd2lsbCBoYXBwZW4pLlxuICpcbiAqIENhdXRpb246IGRvIG5vdCBzdXBwb3J0IGNsb25lIERhdGUsIGZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLlxuICogKFRoZXJlIG1pZ2h0IGJlIGEgbGFyZ2UgbnVtYmVyIG9mIGRhdGUgaW4gYHNlcmllcy5kYXRhYCkuXG4gKiBTbyBkYXRlIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgaW4gYW5kIG91dCBvZiBlY2hhcnRzLlxuICpcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcmV0dXJuIHsqfSBuZXdcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICB2YXIgdHlwZVN0ciA9IG9ialRvU3RyaW5nLmNhbGwoc291cmNlKTtcblxuICBpZiAodHlwZVN0ciA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlbdHlwZVN0cl0pIHtcbiAgICB2YXIgQ3RvciA9IHNvdXJjZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChzb3VyY2UuY29uc3RydWN0b3IuZnJvbSkge1xuICAgICAgcmVzdWx0ID0gQ3Rvci5mcm9tKHNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDdG9yKHNvdXJjZS5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFCVUlMVElOX09CSkVDVFt0eXBlU3RyXSAmJiAhaXNQcmltaXRpdmUoc291cmNlKSAmJiAhaXNEb20oc291cmNlKSkge1xuICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBvdmVyd3JpdGUgPyBjbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFyIHRhcmdldFByb3AgPSB0YXJnZXRba2V5XTtcbiAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKSAmJiBpc09iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNBcnJheShzb3VyY2VQcm9wKSAmJiAhaXNBcnJheSh0YXJnZXRQcm9wKSAmJiAhaXNEb20oc291cmNlUHJvcCkgJiYgIWlzRG9tKHRhcmdldFByb3ApICYmICFpc0J1aWx0SW5PYmplY3Qoc291cmNlUHJvcCkgJiYgIWlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNQcmltaXRpdmUoc291cmNlUHJvcCkgJiYgIWlzUHJpbWl0aXZlKHRhcmdldFByb3ApKSB7XG4gICAgICAgIC8vIOWmguaenOmcgOimgemAkuW9kuimhueblu+8jOWwsemAkuW9kuiwg+eUqG1lcmdlXG4gICAgICAgIG1lcmdlKHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSk7XG4gICAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIC8vIOWQpuWImeWPquWkhOeQhm92ZXJ3cml0ZeS4unRydWXvvIzmiJbogIXlnKjnm67moIflr7nosaHkuK3msqHmnInmraTlsZ7mgKfnmoTmg4XlhrVcbiAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0QW5kU291cmNlcyBUaGUgZmlyc3QgaXRlbSBpcyB0YXJnZXQsIGFuZCB0aGUgcmVzdHMgYXJlIHNvdXJjZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqIEByZXR1cm4geyp9IHRhcmdldFxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VBbGwodGFyZ2V0QW5kU291cmNlcywgb3ZlcndyaXRlKSB7XG4gIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0YXJnZXRBbmRTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LCB0YXJnZXRBbmRTb3VyY2VzW2ldLCBvdmVyd3JpdGUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJsYXk9ZmFsc2VdXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChvdmVybGF5ID8gc291cmNlW2tleV0gIT0gbnVsbCA6IHRhcmdldFtrZXldID09IG51bGwpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBtZXRob2RzLmNyZWF0ZUNhbnZhcygpO1xufTtcblxubWV0aG9kcy5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbn07IC8vIEZJWE1FXG5cblxudmFyIF9jdHg7XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghX2N0eCkge1xuICAgIC8vIFVzZSB1dGlsLmNyZWF0ZUNhbnZhcyBpbnN0ZWFkIG9mIGNyZWF0ZUNhbnZhc1xuICAgIC8vIGJlY2F1c2UgY3JlYXRlQ2FudmFzIG1heSBiZSBvdmVyd3JpdHRlbiBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRcbiAgICBfY3R4ID0gY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgfVxuXG4gIHJldHVybiBfY3R4O1xufVxuLyoqXG4gKiDmn6Xor6LmlbDnu4TkuK3lhYPntKDnmoRpbmRleFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgaWYgKGFycmF5KSB7XG4gICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIEYoKSB7fVxuXG4gIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcbiAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgY2xhenoucHJvdG90eXBlW3Byb3BdID0gY2xhenpQcm90b3R5cGVbcHJvcF07XG4gIH1cblxuICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gIHRhcmdldCA9ICdwcm90b3R5cGUnIGluIHRhcmdldCA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gIHNvdXJjZSA9ICdwcm90b3R5cGUnIGluIHNvdXJjZSA/IHNvdXJjZS5wcm90b3R5cGUgOiBzb3VyY2U7XG4gIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KTtcbn1cbi8qKlxuICogQ29uc2lkZXIgdHlwZWQgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbn1cbi8qKlxuICog5pWw57uE5oiW5a+56LGh6YGN5Y6GXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIOaVsOe7hOaYoOWwhFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gbWFwKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmoubWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gW21lbW9dXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiByZWR1Y2Uob2JqLCBjYiwgbWVtbywgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5yZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tov4fmu6RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbHRlcihvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tpobnmn6Xmib5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxuZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICByZXR1cm4gb2JqW2ldO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8ICEhdmFsdWUgJiYgdHlwZSA9PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQnVpbHRJbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gISFCVUlMVElOX09CSkVDVFtvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0RvbSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5vd25lckRvY3VtZW50ID09PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogV2hldGhlciBpcyBleGFjdGx5IE5hTi4gTm90aWNlIGlzTmFOKCdhJykgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVxTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG4vKipcbiAqIElmIHZhbHVlMSBpcyBub3QgbnVsbCwgdGhlbiByZXR1cm4gdmFsdWUxLCBvdGhlcndpc2UganVkZ2V0IHJlc3Qgb2YgdmFsdWVzLlxuICogTG93IHBlcmZvcm1hbmNlLlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHJldHJpZXZlKHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTIodmFsdWUwLCB2YWx1ZTEpIHtcbiAgcmV0dXJuIHZhbHVlMCAhPSBudWxsID8gdmFsdWUwIDogdmFsdWUxO1xufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTModmFsdWUwLCB2YWx1ZTEsIHZhbHVlMikge1xuICByZXR1cm4gdmFsdWUwICE9IG51bGwgPyB2YWx1ZTAgOiB2YWx1ZTEgIT0gbnVsbCA/IHZhbHVlMSA6IHZhbHVlMjtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZEluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIHNsaWNlKCkge1xuICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGNzcyBsaWtlZCBhcnJheSBjb25maWd1cmF0aW9uXG4gKiBlLmcuXG4gKiAgMyA9PiBbMywgMywgMywgM11cbiAqICBbNCwgMl0gPT4gWzQsIDIsIDQsIDJdXG4gKiAgWzQsIDMsIDJdID0+IFs0LCAzLCAyLCAzXVxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVDc3NBcnJheSh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIHZlcnRpY2FsIHwgaG9yaXpvbnRhbFxuICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFswXSwgdmFsWzFdXTtcbiAgfSBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzJdLCB2YWxbMV1dO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBwcmltaXRpdmVLZXkgPSAnX19lY19wcmltaXRpdmVfXyc7XG4vKipcbiAqIFNldCBhbiBvYmplY3QgYXMgcHJpbWl0aXZlIHRvIGJlIGlnbm9yZWQgdHJhdmVyc2luZyBjaGlsZHJlbiBpbiBjbG9uZSBvciBtZXJnZVxuICovXG5cbmZ1bmN0aW9uIHNldEFzUHJpbWl0aXZlKG9iaikge1xuICBvYmpbcHJpbWl0aXZlS2V5XSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICByZXR1cm4gb2JqW3ByaW1pdGl2ZUtleV07XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPbmx5IGFwcGx5IGBvd25Qcm9wZXJ0eWAuXG4gKi9cblxuXG5mdW5jdGlvbiBIYXNoTWFwKG9iaikge1xuICBvYmogJiYgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0sIHRoaXMpO1xufSAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cblxuXG52YXIgSEFTSF9NQVBfUFJFRklYID0gJ19lY18nO1xudmFyIEhBU0hfTUFQX1BSRUZJWF9MRU5HVEggPSA0O1xuSGFzaE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYXNoTWFwLFxuICAvLyBEbyBub3QgcHJvdmlkZSBgaGFzYCBtZXRob2QgdG8gYXZvaWQgZGVmaW5pbmcgd2hhdCBpcyBgaGFzYC5cbiAgLy8gKFdlIHVzdWFsbHkgdHJlYXQgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcyB0aGUgc2FtZSwgZGlmZmVyZW50XG4gIC8vIGZyb20gRVM2IE1hcCkuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV0gPSB2YWx1ZTsgLy8gQ29tcGFyaW5nIHdpdGggaW52b2NhdGlvbiBjaGFpbmluZywgYHJldHVybiB2YWx1ZWAgaXMgbW9yZSBjb21tb25seVxuICAgIC8vIHVzZWQgaW4gdGhpcyBjYXNlOiBgdmFyIHNvbWVWYWwgPSBtYXAuc2V0KCdhJywgZ2VuVmFsKCkpO2BcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgLy8gQWx0aG91Z2ggdXRpbC5lYWNoIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhpcyBoYXNoTWFwIGRpcmVjdGx5LCB1c2VyXG4gIC8vIHNob3VsZCBub3QgdXNlIHRoZSBleHBvc2VkIGtleXMsIHdobyBhcmUgcHJlZml4ZWQuXG4gIGVhY2g6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGNvbnRleHQgIT09IHZvaWQgMCAmJiAoY2IgPSBiaW5kKGNiLCBjb250ZXh0KSk7XG5cbiAgICBmb3IgKHZhciBwcmVmaXhlZEtleSBpbiB0aGlzKSB7XG4gICAgICB0aGlzLmhhc093blByb3BlcnR5KHByZWZpeGVkS2V5KSAmJiBjYih0aGlzW3ByZWZpeGVkS2V5XSwgcHJlZml4ZWRLZXkuc2xpY2UoSEFTSF9NQVBfUFJFRklYX0xFTkdUSCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpZiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIHJlbW92ZUtleTogZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hNYXAob2JqKSB7XG4gIHJldHVybiBuZXcgSGFzaE1hcChvYmopO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0cy4kb3ZlcnJpZGUgPSAkb3ZlcnJpZGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1lcmdlQWxsID0gbWVyZ2VBbGw7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmV4cG9ydHMuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuZXhwb3J0cy5nZXRDb250ZXh0ID0gZ2V0Q29udGV4dDtcbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5leHBvcnRzLm1peGluID0gbWl4aW47XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG5leHBvcnRzLmVhY2ggPSBlYWNoO1xuZXhwb3J0cy5tYXAgPSBtYXA7XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5maW5kID0gZmluZDtcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNCdWlsdEluT2JqZWN0ID0gaXNCdWlsdEluT2JqZWN0O1xuZXhwb3J0cy5pc0RvbSA9IGlzRG9tO1xuZXhwb3J0cy5lcU5hTiA9IGVxTmFOO1xuZXhwb3J0cy5yZXRyaWV2ZSA9IHJldHJpZXZlO1xuZXhwb3J0cy5yZXRyaWV2ZTIgPSByZXRyaWV2ZTI7XG5leHBvcnRzLnJldHJpZXZlMyA9IHJldHJpZXZlMztcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMubm9ybWFsaXplQ3NzQXJyYXkgPSBub3JtYWxpemVDc3NBcnJheTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5zZXRBc1ByaW1pdGl2ZSA9IHNldEFzUHJpbWl0aXZlO1xuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuZXhwb3J0cy5jcmVhdGVIYXNoTWFwID0gY3JlYXRlSGFzaE1hcDtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL3V0aWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBBcnJheSA6IEZsb2F0MzJBcnJheTtcbi8qKlxuICog5Yib5bu65LiA5Liq5ZCR6YePXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUoeCwgeSkge1xuICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcblxuICBpZiAoeCA9PSBudWxsKSB7XG4gICAgeCA9IDA7XG4gIH1cblxuICBpZiAoeSA9PSBudWxsKSB7XG4gICAgeSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlpI3liLblkJHph4/mlbDmja5cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlhYvpmobkuIDkuKrlkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKHYpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuvue9ruWQkemHj+eahOS4pOS4qumhuVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7VmVjdG9yMn0g57uT5p6cXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+ebuOWKoFxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSArIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nvKnmlL7lkI7nm7jliqBcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICovXG5cblxuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCB2MSwgdjIsIGEpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB2MlswXSAqIGE7XG4gIG91dFsxXSA9IHYxWzFdICsgdjJbMV0gKiBhO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nm7jlh49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWIob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gLSB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gLSB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP6ZW/5bqmXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbih2KSB7XG4gIHJldHVybiBNYXRoLnNxcnQobGVuU3F1YXJlKHYpKTtcbn1cblxudmFyIGxlbmd0aCA9IGxlbjsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbi8qKlxuICog5ZCR6YeP6ZW/5bqm5bmz5pa5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiBsZW5TcXVhcmUodikge1xuICByZXR1cm4gdlswXSAqIHZbMF0gKyB2WzFdICogdlsxXTtcbn1cblxudmFyIGxlbmd0aFNxdWFyZSA9IGxlblNxdWFyZTtcbi8qKlxuICog5ZCR6YeP5LmY5rOVXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cbmZ1bmN0aW9uIG11bChvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSAqIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSAqIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/pmaTms5VcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXYob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gLyB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gLyB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP54K55LmYXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBkb3QodjEsIHYyKSB7XG4gIHJldHVybiB2MVswXSAqIHYyWzBdICsgdjFbMV0gKiB2MlsxXTtcbn1cbi8qKlxuICog5ZCR6YeP57yp5pS+XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcGFyYW0ge251bWJlcn0gc1xuICovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCB2LCBzKSB7XG4gIG91dFswXSA9IHZbMF0gKiBzO1xuICBvdXRbMV0gPSB2WzFdICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP5b2S5LiA5YyWXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCB2KSB7XG4gIHZhciBkID0gbGVuKHYpO1xuXG4gIGlmIChkID09PSAwKSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IHZbMF0gLyBkO1xuICAgIG91dFsxXSA9IHZbMV0gLyBkO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog6K6h566X5ZCR6YeP6Ze06Led56a7XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZSh2MSwgdjIpIHtcbiAgcmV0dXJuIE1hdGguc3FydCgodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSkgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSkpO1xufVxuXG52YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXG4gKiDlkJHph4/ot53nprvlubPmlrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiBkaXN0YW5jZVNxdWFyZSh2MSwgdjIpIHtcbiAgcmV0dXJuICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKSArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKTtcbn1cblxudmFyIGRpc3RTcXVhcmUgPSBkaXN0YW5jZVNxdWFyZTtcbi8qKlxuICog5rGC6LSf5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKi9cblxuZnVuY3Rpb24gbmVnYXRlKG91dCwgdikge1xuICBvdXRbMF0gPSAtdlswXTtcbiAgb3V0WzFdID0gLXZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaPkuWAvOS4pOS4queCuVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKi9cblxuXG5mdW5jdGlvbiBsZXJwKG91dCwgdjEsIHYyLCB0KSB7XG4gIG91dFswXSA9IHYxWzBdICsgdCAqICh2MlswXSAtIHYxWzBdKTtcbiAgb3V0WzFdID0gdjFbMV0gKyB0ICogKHYyWzFdIC0gdjFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnn6npmLXlt6bkuZjlkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEBwYXJhbSB7VmVjdG9yMn0gbVxuICovXG5cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0ob3V0LCB2LCBtKSB7XG4gIHZhciB4ID0gdlswXTtcbiAgdmFyIHkgPSB2WzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaxguS4pOS4quWQkemHj+acgOWwj+WAvFxuICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1pbihvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSBNYXRoLm1pbih2MVswXSwgdjJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbih2MVsxXSwgdjJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLkuKTkuKrlkJHph4/mnIDlpKflgLxcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXgob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgodjFbMF0sIHYyWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgodjFbMV0sIHYyWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc2NhbGVBbmRBZGQgPSBzY2FsZUFuZEFkZDtcbmV4cG9ydHMuc3ViID0gc3ViO1xuZXhwb3J0cy5sZW4gPSBsZW47XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMubGVuU3F1YXJlID0gbGVuU3F1YXJlO1xuZXhwb3J0cy5sZW5ndGhTcXVhcmUgPSBsZW5ndGhTcXVhcmU7XG5leHBvcnRzLm11bCA9IG11bDtcbmV4cG9ydHMuZGl2ID0gZGl2O1xuZXhwb3J0cy5kb3QgPSBkb3Q7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuZGlzdCA9IGRpc3Q7XG5leHBvcnRzLmRpc3RhbmNlU3F1YXJlID0gZGlzdGFuY2VTcXVhcmU7XG5leHBvcnRzLmRpc3RTcXVhcmUgPSBkaXN0U3F1YXJlO1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5hcHBseVRyYW5zZm9ybSA9IGFwcGx5VHJhbnNmb3JtO1xuZXhwb3J0cy5taW4gPSBtaW47XG5leHBvcnRzLm1heCA9IG1heDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS92ZWN0b3IuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2V2ZW50ID0gcmVxdWlyZShcIi4uL2NvcmUvZXZlbnRcIik7XG5cbnZhciBhZGRFdmVudExpc3RlbmVyID0gX2V2ZW50LmFkZEV2ZW50TGlzdGVuZXI7XG52YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IF9ldmVudC5yZW1vdmVFdmVudExpc3RlbmVyO1xudmFyIG5vcm1hbGl6ZUV2ZW50ID0gX2V2ZW50Lm5vcm1hbGl6ZUV2ZW50O1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4uL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4uL2NvcmUvZW52XCIpO1xuXG52YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoXCIuLi9jb3JlL0dlc3R1cmVNZ3JcIik7XG5cbnZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcbnZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXTtcbnZhciB0b3VjaEhhbmRsZXJOYW1lcyA9IFsndG91Y2hzdGFydCcsICd0b3VjaGVuZCcsICd0b3VjaG1vdmUnXTtcbnZhciBwb2ludGVyRXZlbnROYW1lcyA9IHtcbiAgcG9pbnRlcmRvd246IDEsXG4gIHBvaW50ZXJ1cDogMSxcbiAgcG9pbnRlcm1vdmU6IDEsXG4gIHBvaW50ZXJvdXQ6IDFcbn07XG52YXIgcG9pbnRlckhhbmRsZXJOYW1lcyA9IHpyVXRpbC5tYXAobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBubSA9IG5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xuICByZXR1cm4gcG9pbnRlckV2ZW50TmFtZXNbbm1dID8gbm0gOiBuYW1lO1xufSk7XG5cbmZ1bmN0aW9uIGV2ZW50TmFtZUZpeChuYW1lKSB7XG4gIHJldHVybiBuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCA/ICdET01Nb3VzZVNjcm9sbCcgOiBuYW1lO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG4gIHN0YWdlID09PSAnc3RhcnQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTtcbiAgdmFyIGdlc3R1cmVJbmZvID0gZ2VzdHVyZU1nci5yZWNvZ25pemUoZXZlbnQsIHByb3h5LmhhbmRsZXIuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZLCBudWxsKS50YXJnZXQsIHByb3h5LmRvbSk7XG4gIHN0YWdlID09PSAnZW5kJyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7IC8vIERvIG5vdCBkbyBhbnkgcHJldmVudERlZmF1bHQgaGVyZS4gVXBwZXIgYXBwbGljYXRpb24gZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG5cbiAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgdmFyIHR5cGUgPSBnZXN0dXJlSW5mby50eXBlO1xuICAgIGV2ZW50Lmdlc3R1cmVFdmVudCA9IHR5cGU7XG4gICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudCh7XG4gICAgICB0YXJnZXQ6IGdlc3R1cmVJbmZvLnRhcmdldFxuICAgIH0sIHR5cGUsIGdlc3R1cmVJbmZvLmV2ZW50KTtcbiAgfVxufSAvLyBmdW5jdGlvbiBvbk1TR2VzdHVyZUNoYW5nZShwcm94eSwgZXZlbnQpIHtcbi8vICAgICBpZiAoZXZlbnQudHJhbnNsYXRpb25YIHx8IGV2ZW50LnRyYW5zbGF0aW9uWSkge1xuLy8gICAgICAgICAvLyBtb3VzZW1vdmUgaXMgY2FycmllZCBieSBNU0dlc3R1cmUgdG8gcmVkdWNlIHRoZSBzZW5zaXRpdml0eS5cbi8vICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChldmVudC50YXJnZXQsICdtb3VzZW1vdmUnLCBldmVudCk7XG4vLyAgICAgfVxuLy8gICAgIGlmIChldmVudC5zY2FsZSAhPT0gMSkge1xuLy8gICAgICAgICBldmVudC5waW5jaFggPSBldmVudC5vZmZzZXRYO1xuLy8gICAgICAgICBldmVudC5waW5jaFkgPSBldmVudC5vZmZzZXRZO1xuLy8gICAgICAgICBldmVudC5waW5jaFNjYWxlID0gZXZlbnQuc2NhbGU7XG4vLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAncGluY2gnLCBldmVudCk7XG4vLyAgICAgfVxuLy8gfVxuXG4vKipcbiAqIFByZXZlbnQgbW91c2UgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkIGFmdGVyIFRvdWNoIEV2ZW50cyBhY3Rpb25cbiAqIEBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9kZWx0YWtvc2gvaGFuZGpzL2Jsb2IvbWFzdGVyL3NyYy9oYW5kLmJhc2UuanM+XG4gKiAxLiBNb2JpbGUgYnJvd3NlcnMgZGlzcGF0Y2ggbW91c2UgZXZlbnRzIDMwMG1zIGFmdGVyIHRvdWNoZW5kLlxuICogMi4gQ2hyb21lIGZvciBBbmRyb2lkIGRpc3BhdGNoIG1vdXNlZG93biBmb3IgbG9uZy10b3VjaCBhYm91dCA2NTBtc1xuICogUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICovXG5cblxuZnVuY3Rpb24gc2V0VG91Y2hUaW1lcihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5fdG91Y2hpbmcgPSB0cnVlO1xuICBjbGVhclRpbWVvdXQoaW5zdGFuY2UuX3RvdWNoVGltZXIpO1xuICBpbnN0YW5jZS5fdG91Y2hUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGluc3RhbmNlLl90b3VjaGluZyA9IGZhbHNlO1xuICB9LCA3MDApO1xufVxuXG52YXIgZG9tSGFuZGxlcnMgPSB7XG4gIC8qKlxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB0aGlzLnRyaWdnZXIoJ21vdXNlbW92ZScsIGV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogTW91c2Ugb3V0IGhhbmRsZXJcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICBpZiAoZWxlbWVudCAhPSB0aGlzLmRvbSkge1xuICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5KSB7XG4gICAgICAgIC8vIOW/veeVpeWMheWQq+WcqHJvb3TkuK3nmoRkb23lvJXotbfnmoRtb3VzZU91dFxuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdGhpcy5kb20pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNo5byA5aeL5ZON5bqU5Ye95pWwXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gRGVmYXVsdCBtb3VzZSBiZWhhdmlvdXIgc2hvdWxkIG5vdCBiZSBkaXNhYmxlZCBoZXJlLlxuICAgIC8vIEZvciBleGFtcGxlLCBwYWdlIG1heSBuZWVkcyB0byBiZSBzbGlkZWQuXG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpOyAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG5cbiAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA9IG5ldyBEYXRlKCk7XG4gICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdzdGFydCcpOyAvLyBJbiB0b3VjaCBkZXZpY2UsIHRyaWdnZXIgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIHNob3VsZFxuICAgIC8vIGJlIHRyaWdnZXJlZCwgYW5kIG11c3QgYmVmb3JlIGBtb3VzZWRvd25gIHRyaWdnZXJlZC5cblxuICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBkb21IYW5kbGVycy5tb3VzZWRvd24uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogVG91Y2jnp7vliqjlk43lupTlh73mlbBcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICB0b3VjaG1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTsgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgIC8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuXG4gICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcbiAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2NoYW5nZScpOyAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudCwgYmVjYXVzZSBtb3VzZSBtb3ZlIGFuZCBwaW5jaCBtYXlcbiAgICAvLyBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUuXG5cbiAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogVG91Y2jnu5PmnZ/lk43lupTlh73mlbBcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICB0b3VjaGVuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpOyAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG5cbiAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnZW5kJyk7XG4gICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTsgLy8gRG8gbm90IHRyaWdnZXIgYG1vdXNlb3V0YCBoZXJlLCBpbiBzcGl0ZSBvZiBgbW91c2Vtb3ZlYChgbW91c2VvdmVyYCkgaXNcbiAgICAvLyB0cmlnZ2VyZWQgaW4gYHRvdWNoc3RhcnRgLiBUaGlzIHNlZW1zIHRvIGJlIGlsbG9naWNhbCwgYnV0IGJ5IHRoaXMgbWVjaGFuaXNtLFxuICAgIC8vIHdlIGNhbiBjb252ZW5pZW50bHkgaW1wbGVtZW50IFwiaG92ZXIgc3R5bGVcIiBpbiBib3RoIFBDIGFuZCB0b3VjaCBkZXZpY2UganVzdFxuICAgIC8vIGJ5IGxpc3RlbmluZyB0byBgbW91c2VvdmVyYCB0byBhZGQgXCJob3ZlciBzdHlsZVwiIGFuZCBsaXN0ZW5pbmcgdG8gYG1vdXNlb3V0YFxuICAgIC8vIHRvIHJlbW92ZSBcImhvdmVyIHN0eWxlXCIgb24gYW4gZWxlbWVudCwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCBjb2RlIGZvclxuICAgIC8vIGNvbXBhdGliaWxpdHkuIChgbW91c2VvdXRgIHdpbGwgbm90IGJlIHRyaWdnZXJlZCBpbiBgdG91Y2hlbmRgLCBzbyBcImhvdmVyXG4gICAgLy8gc3R5bGVcIiB3aWxsIHJlbWFpbiBmb3IgdXNlciB2aWV3KVxuICAgIC8vIGNsaWNrIGV2ZW50IHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudC4gU3lzdGVtIGNsaWNrIGNhbiBub3QgYmUgcHJldmVudGVkLlxuXG4gICAgaWYgKCtuZXcgRGF0ZSgpIC0gdGhpcy5fbGFzdFRvdWNoTW9tZW50IDwgVE9VQ0hfQ0xJQ0tfREVMQVkpIHtcbiAgICAgIGRvbUhhbmRsZXJzLmNsaWNrLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cblxuICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gIH0sXG4gIHBvaW50ZXJkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBkb21IYW5kbGVycy5tb3VzZWRvd24uY2FsbCh0aGlzLCBldmVudCk7IC8vIGlmICh1c2VNU0d1ZXN0dXJlKHRoaXMsIGV2ZW50KSkge1xuICAgIC8vICAgICB0aGlzLl9tc0dlc3R1cmUuYWRkUG9pbnRlcihldmVudC5wb2ludGVySWQpO1xuICAgIC8vIH1cbiAgfSxcbiAgcG9pbnRlcm1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIEZJWE1FXG4gICAgLy8gcG9pbnRlcm1vdmUgaXMgc28gc2Vuc2l0aXZlIHRoYXQgaXQgYWx3YXlzIHRyaWdnZXJlZCB3aGVuXG4gICAgLy8gdGFwKGNsaWNrKSBvbiB0b3VjaCBzY3JlZW4sIHdoaWNoIGFmZmVjdCBzb21lIGp1ZGdlbWVudCBpblxuICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgIC8vIGRldmljZSB5ZXQuXG4gICAgaWYgKCFpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpKSB7XG4gICAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG4gIH0sXG4gIHBvaW50ZXJvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIHBvaW50ZXJvdXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuXG4gICAgLy8gKElFMTErL0VkZ2Ugb24gTVMgU3VyZmFjZSkgYWZ0ZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcmVkLFxuICAgIC8vIHdoaWNoIGlzIGluY29uc2lzdGVudCB3aXRoIHRoZSBtb3Vzb3V0IGJlaGF2aW9yIHdlIGRlZmluZWRcbiAgICAvLyBpbiB0b3VjaGVuZC4gU28gd2UgdW5pZnkgdGhlbS5cbiAgICAvLyAoY2hlY2sgZG9tSGFuZGxlcnMudG91Y2hlbmQgZm9yIGRldGFpbGVkIGV4cGxhbmF0aW9uKVxuICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgZG9tSGFuZGxlcnMubW91c2VvdXQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpIHtcbiAgdmFyIHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gIHJldHVybiBwb2ludGVyVHlwZSA9PT0gJ3BlbicgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG59IC8vIGZ1bmN0aW9uIHVzZU1TR3Vlc3R1cmUoaGFuZGxlclByb3h5LCBldmVudCkge1xuLy8gICAgIHJldHVybiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpICYmICEhaGFuZGxlclByb3h5Ll9tc0dlc3R1cmU7XG4vLyB9XG4vLyBDb21tb24gaGFuZGxlcnNcblxuXG56clV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZG9tSGFuZGxlcnNbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdGhpcy50cmlnZ2VyKG5hbWUsIGV2ZW50KTtcbiAgfTtcbn0pO1xuLyoqXG4gKiDkuLrmjqfliLbnsbvlrp7kvovliJ3lp4vljJZkb20g5LqL5Lu25aSE55CG5Ye95pWwXG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0hhbmRsZXJ9IGluc3RhbmNlIOaOp+WItuexu+WunuS+i1xuICovXG5cbmZ1bmN0aW9uIGluaXREb21IYW5kbGVyKGluc3RhbmNlKSB7XG4gIHpyVXRpbC5lYWNoKHRvdWNoSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gIH0pO1xuICB6clV0aWwuZWFjaChwb2ludGVySGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gIH0pO1xuICB6clV0aWwuZWFjaChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSBtYWtlTW91c2VIYW5kbGVyKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG1ha2VNb3VzZUhhbmRsZXIoZm4sIGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5fdG91Y2hpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4uYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBIYW5kbGVyRG9tUHJveHkoZG9tKSB7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIHRoaXMuZG9tID0gZG9tO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMuX3RvdWNoaW5nID0gZmFsc2U7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl90b3VjaFRpbWVyO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvR2VzdHVyZU1ncn1cbiAgICovXG5cbiAgdGhpcy5fZ2VzdHVyZU1nciA9IG5ldyBHZXN0dXJlTWdyKCk7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGluaXREb21IYW5kbGVyKHRoaXMpO1xuXG4gIGlmIChlbnYucG9pbnRlckV2ZW50c1N1cHBvcnRlZCkge1xuICAgIC8vIE9ubHkgSUUxMSsvRWRnZVxuICAgIC8vIDEuIE9uIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgKGUuZy4sIE1TIFN1cmZhY2UgYW5kIGxlbm92byBYMjQwKSxcbiAgICAvLyBJRTExKy9FZGdlIGRvIG5vdCB0cmlnZ2VyIHRvdWNoIGV2ZW50LCBidXQgdHJpZ2dlciBwb2ludGVyIGV2ZW50IGFuZCBtb3VzZSBldmVudFxuICAgIC8vIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgaXQgcHJvYmFibGVseSBvbmx5IHRyaWdnZXIgbW91c2Vkb3duIGJ1dCBubyBtb3VzZXVwIHdoZW4gdGFwIG9uXG4gICAgLy8gc2NyZWVuLCB3aGljaCBkbyBub3Qgb2NjdXJzIGluIHBvaW50ZXIgZXZlbnQuXG4gICAgLy8gU28gd2UgdXNlIHBvaW50ZXIgZXZlbnQgdG8gYm90aCBkZXRlY3QgdG91Y2ggZ2VzdHVyZSBhbmQgbW91c2UgYmVoYXZpb3IuXG4gICAgbW91bnRIYW5kbGVycyhwb2ludGVySGFuZGxlck5hbWVzLCB0aGlzKTsgLy8gRklYTUVcbiAgICAvLyBOb3RlOiBNUyBHZXN0dXJlIHJlcXVpcmUgQ1NTIHRvdWNoLWFjdGlvbiBzZXQuIEJ1dCB0b3VjaC1hY3Rpb24gaXMgbm90IHJlbGlhYmxlLFxuICAgIC8vIHdoaWNoIGRvZXMgbm90IHByZXZlbnQgZGVmdWF1bHQgYmVoYXZpb3Igb2NjYXNpb25hbGx5ICh3aGljaCBtYXkgY2F1c2UgdmlldyBwb3J0XG4gICAgLy8gem9vbWVkIGluIGJ1dCB1c2UgY2FuIG5vdCB6b29tIGl0IGJhY2spLiBBbmQgZXZlbnQucHJldmVudERlZmF1bHQoKSBkb2VzIG5vdCB3b3JrLlxuICAgIC8vIFNvIHdlIGhhdmUgdG8gbm90IHRvIHVzZSBNU0dlc3R1cmUgYW5kIG5vdCB0byBzdXBwb3J0IHRvdWNobW92ZSBhbmQgcGluY2ggb24gTVNcbiAgICAvLyB0b3VjaCBzY3JlZW4uIEFuZCB3ZSBvbmx5IHN1cHBvcnQgY2xpY2sgYmVoYXZpb3Igb24gTVMgdG91Y2ggc2NyZWVuIG5vdy5cbiAgICAvLyBNUyBHZXN0dXJlIEV2ZW50IGlzIG9ubHkgc3VwcG9ydGVkIG9uIElFMTErL0VkZ2UgYW5kIG9uIFdpbmRvd3MgOCsuXG4gICAgLy8gV2UgZG9udCBzdXBwb3J0IHRvdWNoIG9uIElFIG9uIHdpbjcuXG4gICAgLy8gU2VlIDxodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQzKHY9dnMuODUpLmFzcHg+XG4gICAgLy8gaWYgKHR5cGVvZiBNU0dlc3R1cmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAgICAgKHRoaXMuX21zR2VzdHVyZSA9IG5ldyBNU0dlc3R1cmUoKSkudGFyZ2V0ID0gZG9tOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAvLyAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ01TR2VzdHVyZUNoYW5nZScsIG9uTVNHZXN0dXJlQ2hhbmdlKTtcbiAgICAvLyB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZCkge1xuICAgICAgbW91bnRIYW5kbGVycyh0b3VjaEhhbmRsZXJOYW1lcywgdGhpcyk7IC8vIEhhbmRsZXIgb2YgJ21vdXNlb3V0JyBldmVudCBpcyBuZWVkZWQgaW4gdG91Y2ggbW9kZSwgd2hpY2ggd2lsbCBiZSBtb3VudGVkIGJlbG93LlxuICAgICAgLy8gYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW91c2VvdXQnLCB0aGlzLl9tb3VzZW91dEhhbmRsZXIpO1xuICAgIH0gLy8gMS4gQ29uc2lkZXJpbmcgc29tZSBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIGV2ZW50IChsaWtlIG9uIE1TIFN1cmZhY2VcbiAgICAvLyBhbmQgbGVub3ZvIFgyNDAsIEBzZWUgIzIzNTApLCB3ZSBtYWtlIG1vdXNlIGV2ZW50IGJlIGFsd2F5cyBsaXN0ZW5lZCwgb3RoZXJ3aXNlXG4gICAgLy8gbW91c2UgZXZlbnQgY2FuIG5vdCBiZSBoYW5kbGUgaW4gdGhvc2UgZGV2aWNlcy5cbiAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBDaHJvbWUgd2lsbCB0cmlnZ2VyIGJvdGggdG91Y2ggZXZlbnQgYW5kIG1vdXNlIGV2ZW50LiBIb3cgdG8gcHJldmVudFxuICAgIC8vIG1vdXNlZXZlbnQgYWZ0ZXIgdG91Y2ggZXZlbnQgdHJpZ2dlcmVkLCBzZWUgYHNldFRvdWNoVGltZXJgLlxuXG5cbiAgICBtb3VudEhhbmRsZXJzKG1vdXNlSGFuZGxlck5hbWVzLCB0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgIHpyVXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgfSwgaW5zdGFuY2UpO1xuICB9XG59XG5cbnZhciBoYW5kbGVyRG9tUHJveHlQcm90byA9IEhhbmRsZXJEb21Qcm94eS5wcm90b3R5cGU7XG5cbmhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBoYW5kbGVyTmFtZXNbaV07XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmRvbSwgZXZlbnROYW1lRml4KG5hbWUpLCB0aGlzLl9oYW5kbGVyc1tuYW1lXSk7XG4gIH1cbn07XG5cbmhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG59O1xuXG56clV0aWwubWl4aW4oSGFuZGxlckRvbVByb3h5LCBFdmVudGZ1bCk7XG52YXIgX2RlZmF1bHQgPSBIYW5kbGVyRG9tUHJveHk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5cbi8vIENvbXBvdW5kUGF0aCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdjb21wb3VuZCcsXG4gIHNoYXBlOiB7XG4gICAgcGF0aHM6IG51bGxcbiAgfSxcbiAgX3VwZGF0ZVBhdGhEaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXJ0eVBhdGggPSB0aGlzLl9fZGlydHlQYXRoO1xuICAgIHZhciBwYXRocyA9IHRoaXMuc2hhcGUucGF0aHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBNYXJrIGFzIGRpcnR5IGlmIGFueSBzdWJwYXRoIGlzIGRpcnR5XG4gICAgICBkaXJ0eVBhdGggPSBkaXJ0eVBhdGggfHwgcGF0aHNbaV0uX19kaXJ0eVBhdGg7XG4gICAgfVxuXG4gICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICB0aGlzLl9fZGlydHkgPSB0aGlzLl9fZGlydHkgfHwgZGlydHlQYXRoO1xuICB9LFxuICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuXG4gICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocyB8fCBbXTtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7IC8vIFVwZGF0ZSBwYXRoIHNjYWxlXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXBhdGhzW2ldLnBhdGgpIHtcbiAgICAgICAgcGF0aHNbaV0uY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICB9XG5cbiAgICAgIHBhdGhzW2ldLnBhdGguc2V0U2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdKTtcbiAgICB9XG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgcGF0aHMgPSBzaGFwZS5wYXRocyB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhdGhzW2ldLmJ1aWxkUGF0aChjdHgsIHBhdGhzW2ldLnNoYXBlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgcGF0aHNbaV0uX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuXG4gICAgcmV0dXJuIFBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdC5jYWxsKHRoaXMpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0NvbXBvdW5kUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vU3R5bGVcIik7XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZShcIi4uL0VsZW1lbnRcIik7XG5cbnZhciBSZWN0VGV4dCA9IHJlcXVpcmUoXCIuL21peGluL1JlY3RUZXh0XCIpO1xuXG4vKipcbiAqIOWPr+e7mOWItueahOWbvuW9ouWfuuexu1xuICogQmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheWFibGUgZ3JhcGhpYyBvYmplY3RzXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcbiAqL1xuZnVuY3Rpb24gRGlzcGxheWFibGUob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpOyAvLyBFeHRlbmQgcHJvcGVydGllc1xuXG4gIGZvciAodmFyIG5hbWUgaW4gb3B0cykge1xuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUgIT09ICdzdHlsZScpIHtcbiAgICAgIHRoaXNbbmFtZV0gPSBvcHRzW25hbWVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9XG4gICAqL1xuXG5cbiAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShvcHRzLnN0eWxlLCB0aGlzKTtcbiAgdGhpcy5fcmVjdCA9IG51bGw7IC8vIFNoYXBlcyBmb3IgY2FzY2FkZSBjbGlwcGluZy5cblxuICB0aGlzLl9fY2xpcFBhdGhzID0gW107IC8vIEZJWE1FIFN0YXRlZnVsIG11c3QgYmUgbWl4aW5lZCBhZnRlciBzdHlsZSBpcyBzZXR0ZWRcbiAgLy8gU3RhdGVmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuRGlzcGxheWFibGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGxheWFibGUsXG4gIHR5cGU6ICdkaXNwbGF5YWJsZScsXG5cbiAgLyoqXG4gICAqIERpc3BsYXlhYmxlIOaYr+WQpuS4uuiEj++8jFBhaW50ZXIg5Lit5Lya5qC55o2u6K+l5qCH6K6w5Yik5pat5piv5ZCm6ZyA6KaB5piv5ZCm6ZyA6KaB6YeN5paw57uY5Yi2XG4gICAqIERpcnR5IGZsYWcuIEZyb20gd2hpY2ggcGFpbnRlciB3aWxsIGRldGVybWluZSBpZiB0aGlzIGRpc3BsYXlhYmxlIG9iamVjdCBuZWVkcyBicnVzaFxuICAgKiBAbmFtZSBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI19fZGlydHlcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBfX2RpcnR5OiB0cnVlLFxuXG4gIC8qKlxuICAgKiDlm77lvaLmmK/lkKblj6/op4HvvIzkuLp0cnVl5pe25LiN57uY5Yi25Zu+5b2i77yM5L2G5piv5LuN6IO96Kem5Y+R6byg5qCH5LqL5Lu2XG4gICAqIElmIGlnbm9yZSBkcmF3aW5nIG9mIHRoZSBkaXNwbGF5YWJsZSBvYmplY3QuIE1vdXNlIGV2ZW50IHdpbGwgc3RpbGwgYmUgdHJpZ2dlcmVkXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2ludmlzaWJsZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGludmlzaWJsZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgejogMCxcblxuICAvKipcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB6MjogMCxcblxuICAvKipcbiAgICogeuWxgmxldmVs77yM5Yaz5a6a57uY55S75Zyo5ZOq5bGCY2FudmFz5LitXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3psZXZlbFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB6bGV2ZWw6IDAsXG5cbiAgLyoqXG4gICAqIOaYr+WQpuWPr+aLluaLvVxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDmmK/lkKbmraPlnKjmi5bmi71cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDmmK/lkKbnm7jlupTpvKDmoIfkuovku7ZcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjc2lsZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogSWYgZW5hYmxlIGN1bGxpbmdcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBjdWxsaW5nOiBmYWxzZSxcblxuICAvKipcbiAgICogTW91c2UgY3Vyc29yIHdoZW4gaG92ZXJlZFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNjdXJzb3JcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuXG4gIC8qKlxuICAgKiBJZiBob3ZlciBhcmVhIGlzIGJvdW5kaW5nIHJlY3RcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjcmVjdEhvdmVyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICByZWN0SG92ZXI6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgcHJvZ3Jlc3NpdmVseSB3aGVuIHRoZSB2YWx1ZSA+PSAwLFxuICAgKiB1c2VmdWxsIGZvciBsYXJnZSBkYXRhLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgcHJvZ3Jlc3NpdmU6IC0xLFxuICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG4gIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuXG4gIC8qKlxuICAgKiDlm77lvaLnu5jliLbmlrnms5VcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgLy8gSW50ZXJmYWNlXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHt9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmnIDlsI/ljIXlm7Tnm5JcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICAvLyBJbnRlcmZhY2VcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i5LiKXG4gICAqIElmIGRpc3BsYXlhYmxlIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMucmVjdENvbnRhaW4oeCwgeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9oueahOWMheWbtOebkuS4ilxuICAgKiBJZiBib3VuZGluZyByZWN0IG9mIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHJlY3RDb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBjb29yZCA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICByZXR1cm4gcmVjdC5jb250YWluKGNvb3JkWzBdLCBjb29yZFsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOagh+iusOWbvuW9ouWFg+e0oOS4uuiEj++8jOW5tuS4lOWcqOS4i+S4gOW4p+mHjee7mFxuICAgKiBNYXJrIGRpc3BsYXlhYmxlIGVsZW1lbnQgZGlydHkgYW5kIHJlZnJlc2ggbmV4dCBmcmFtZVxuICAgKi9cbiAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlm77lvaLmmK/lkKbkvJrop6blj5Hkuovku7ZcbiAgICogSWYgZGlzcGxheWFibGUgb2JqZWN0IGJpbmRlZCBhbnkgZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIC8vIFRPRE8sIOmAmui/hyBiaW5kIOe7keWumueahOS6i+S7tlxuICAvLyBpc1NpbGVudDogZnVuY3Rpb24gKCkge1xuICAvLyAgICAgcmV0dXJuICEoXG4gIC8vICAgICAgICAgdGhpcy5ob3ZlcmFibGUgfHwgdGhpcy5kcmFnZ2FibGVcbiAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vtb3ZlIHx8IHRoaXMub25tb3VzZW92ZXIgfHwgdGhpcy5vbm1vdXNlb3V0XG4gIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlZG93biB8fCB0aGlzLm9ubW91c2V1cCB8fCB0aGlzLm9uY2xpY2tcbiAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJhZ2VudGVyIHx8IHRoaXMub25kcmFnb3ZlciB8fCB0aGlzLm9uZHJhZ2xlYXZlXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbmRyb3BcbiAgLy8gICAgICk7XG4gIC8vIH0sXG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBhbmltYXRlKCdzdHlsZScpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgKi9cbiAgYW5pbWF0ZVN0eWxlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3N0eWxlJywgbG9vcCk7XG4gIH0sXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ICE9PSAnc3R5bGUnKSB7XG4gICAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHlsZS5zZXQodmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zdHlsZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZSBnaXZlbiBzdHlsZSBvYmplY3RcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAgICovXG4gIHVzZVN0eWxlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShvYmosIHRoaXMpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKERpc3BsYXlhYmxlLCBFbGVtZW50KTtcbnpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgUmVjdFRleHQpOyAvLyB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFN0YXRlZnVsKTtcblxudmFyIF9kZWZhdWx0ID0gRGlzcGxheWFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqL1xudmFyIEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yU3RvcHMpIHtcbiAgdGhpcy5jb2xvclN0b3BzID0gY29sb3JTdG9wcyB8fCBbXTtcbn07XG5cbkdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyYWRpZW50LFxuICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uIChvZmZzZXQsIGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvaW1hZ2VcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5mdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5aSW1hZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuICB0eXBlOiAnaW1hZ2UnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7IC8vIE11c3QgYmluZCBlYWNoIHRpbWVcblxuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShzcmMsIHRoaXMuX2ltYWdlLCB0aGlzLCB0aGlzLm9ubG9hZCk7XG5cbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlm77niYflt7Lnu4/liqDovb3lrozmiJBcbiAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gRWxzZSBpcyBjYW52YXNcblxuXG4gICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIH0gLy8g6K6+572udHJhbnNmb3JtXG5cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpOyAvLyBEcmF3IHJlY3QgdGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBaSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4vR3JhZGllbnRcIik7XG5cbi8qKlxuICogeCwgeSwgeDIsIHkyIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeDI9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeTI9MF1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICovXG52YXIgTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ2xpbmVhcicsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy54ID0geCA9PSBudWxsID8gMCA6IHg7XG4gIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAgOiB5O1xuICB0aGlzLngyID0geDIgPT0gbnVsbCA/IDEgOiB4MjtcbiAgdGhpcy55MiA9IHkyID09IG51bGwgPyAwIDogeTI7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAnbGluZWFyJzsgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuXG4gIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG4gIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG59O1xuXG5MaW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMaW5lYXJHcmFkaWVudFxufTtcbnpyVXRpbC5pbmhlcml0cyhMaW5lYXJHcmFkaWVudCwgR3JhZGllbnQpO1xudmFyIF9kZWZhdWx0ID0gTGluZWFyR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3BhdGhcIik7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZShcIi4vUGF0dGVyblwiKTtcblxudmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnBhdGggPSBudWxsO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGgsXG4gIHR5cGU6ICdwYXRoJyxcbiAgX19kaXJ0eVBhdGg6IHRydWUsXG4gIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8IHBhdGhQcm94eUZvckRyYXc7XG4gICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhZmlsbC5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISFmaWxsLmltYWdlO1xuICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhc3Ryb2tlLmltYWdlO1xuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICB2YXIgcmVjdDsgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuXG4gICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgIH1cbiAgICB9IC8vIFVzZSB0aGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuXG5cbiAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9maWxsR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgIH1cblxuICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHZhciBjdHhMaW5lRGFzaCA9ICEhY3R4LnNldExpbmVEYXNoOyAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcblxuICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7IC8vIFByb3h5IGNvbnRleHRcbiAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCB8fCBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aChjdHgpOyAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuXG4gICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpOyAvLyBDbGVhciBwYXRoIGRpcnR5IGZsYWdcblxuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG5cbiAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgfVxuXG4gICAgaGFzU3Ryb2tlICYmIHBhdGguc3Ryb2tlKGN0eCk7XG5cbiAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTsgLy8gRHJhdyByZWN0IHRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9LFxuICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gIC8vIExpa2UgaW4gY2lyY2xlXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcbiAgY3JlYXRlUGF0aFByb3h5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG5cbiAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWN0ID0gcmVjdDtcblxuICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7IC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG5cbiAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7IC8vIFBFTkRJTkcsIE1pbiBsaW5lIHdpZHRoIGlzIG5lZWRlZCB3aGVuIGxpbmUgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuXG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG5cbiAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICB9IC8vIENvbnNpZGVyIGxpbmUgd2lkdGhcbiAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG5cbiAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIHJlY3Qgd2l0aCBzdHJva2VcblxuXG4gICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuXG4gICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTsgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAqL1xuICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgIGlmIChkaXJ0eVBhdGggPT0gbnVsbCkge1xuICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICB9IC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cblxuXG4gICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7IC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG5cbiAgICBpZiAodGhpcy5fX2NsaXBUYXJnZXQpIHtcbiAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzaGFwZScsIGxvb3ApO1xuICB9LFxuICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBGSVhNRVxuICAgIGlmIChrZXkgPT09ICdzaGFwZScpIHtcbiAgICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTsgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcblxuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgc2hhcGVbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGdldExpbmVTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07IC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAvLyBEZXRlcm1pbmFudCBvZiBgbWAgbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgIC8vIGZvciB3aWR0aC5cblxuICAgIHJldHVybiBtICYmIGFicyhtWzBdIC0gMSkgPiAxZS0xMCAmJiBhYnMobVszXSAtIDEpID4gMWUtMTAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKSA6IDE7XG4gIH1cbn07XG4vKipcbiAqIOaJqeWxleS4gOS4qiBQYXRoIGVsZW1lbnQsIOavlOWmguaYn+W9ou+8jOWchuetieOAglxuICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy50eXBlIFBhdGggdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5idWlsZFBhdGggT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIEV4dGVuZGVkIGRlZmF1bHQgc3R5bGUgY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICovXG5cblBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIFBhdGguY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgIGlmIChkZWZhdWx0cy5zdHlsZSkge1xuICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc3R5bGVcbiAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgIH0gLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcblxuXG4gICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuXG4gICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICB2YXIgdGhpc1NoYXBlID0gdGhpcy5zaGFwZTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgaWYgKCF0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpc1NoYXBlW25hbWVdID0gZGVmYXVsdFNoYXBlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmYXVsdHMuaW5pdCAmJiBkZWZhdWx0cy5pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gIH07XG5cbiAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7IC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIG5hbWUgIT09ICdzaGFwZScpIHtcbiAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU3ViO1xufTtcblxuenJVdGlsLmluaGVyaXRzKFBhdGgsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFBhdGg7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdHRlcm4gPSBmdW5jdGlvbiAoaW1hZ2UsIHJlcGVhdCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7aW1hZ2U6IC4uLn1gLCB3aGVyZSB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICB0aGlzLnJlcGVhdCA9IHJlcGVhdDsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGVhdCB8fCAncmVwZWF0Jyk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBQYXR0ZXJuO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgR3JhZGllbnQgPSByZXF1aXJlKFwiLi9HcmFkaWVudFwiKTtcblxuLyoqXG4gKiB4LCB5LCByIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTAuNV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wLjVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3I9MC41XVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW2NvbG9yU3RvcHNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAqL1xudmFyIFJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHt0eXBlOiAncmFkaWFsJywgY29sb3JTdG9wczogLi4ufWAsIHdoZXJlXG4gIC8vIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLnggPSB4ID09IG51bGwgPyAwLjUgOiB4O1xuICB0aGlzLnkgPSB5ID09IG51bGwgPyAwLjUgOiB5O1xuICB0aGlzLnIgPSByID09IG51bGwgPyAwLjUgOiByOyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ3JhZGlhbCc7IC8vIElmIHVzZSBnbG9iYWwgY29vcmRcblxuICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xufTtcblxuUmFkaWFsR3JhZGllbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmFkaWFsR3JhZGllbnRcbn07XG56clV0aWwuaW5oZXJpdHMoUmFkaWFsR3JhZGllbnQsIEdyYWRpZW50KTtcbnZhciBfZGVmYXVsdCA9IFJhZGlhbEdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFNUWUxFX0NPTU1PTl9QUk9QUyA9IFtbJ3NoYWRvd0JsdXInLCAwXSwgWydzaGFkb3dPZmZzZXRYJywgMF0sIFsnc2hhZG93T2Zmc2V0WScsIDBdLCBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSwgWydsaW5lQ2FwJywgJ2J1dHQnXSwgWydsaW5lSm9pbicsICdtaXRlciddLCBbJ21pdGVyTGltaXQnLCAxMF1dOyAvLyB2YXIgU0hBRE9XX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDAsIDQpO1xuLy8gdmFyIExJTkVfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoNCk7XG5cbnZhciBTdHlsZSA9IGZ1bmN0aW9uIChvcHRzLCBob3N0KSB7XG4gIHRoaXMuZXh0ZW5kRnJvbShvcHRzLCBmYWxzZSk7XG4gIHRoaXMuaG9zdCA9IGhvc3Q7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwIDogb2JqLng7XG4gIHZhciB4MiA9IG9iai54MiA9PSBudWxsID8gMSA6IG9iai54MjtcbiAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMCA6IG9iai55O1xuICB2YXIgeTIgPSBvYmoueTIgPT0gbnVsbCA/IDAgOiBvYmoueTI7XG5cbiAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgeCA9IHggKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgIHgyID0geDIgKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgIHkgPSB5ICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgeTIgPSB5MiAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICB9XG5cbiAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgyLCB5Mik7XG4gIHJldHVybiBjYW52YXNHcmFkaWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gIHZhciB4ID0gb2JqLnggPT0gbnVsbCA/IDAuNSA6IG9iai54O1xuICB2YXIgeSA9IG9iai55ID09IG51bGwgPyAwLjUgOiBvYmoueTtcbiAgdmFyIHIgPSBvYmouciA9PSBudWxsID8gMC41IDogb2JqLnI7XG5cbiAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgeCA9IHggKiB3aWR0aCArIHJlY3QueDtcbiAgICB5ID0geSAqIGhlaWdodCArIHJlY3QueTtcbiAgICByID0gciAqIG1pbjtcbiAgfVxuXG4gIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCByKTtcbiAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xufVxuXG5TdHlsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTdHlsZSxcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9XG4gICAqL1xuICBob3N0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZmlsbDogJyMwMDAnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3Ryb2tlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgb3BhY2l0eTogMSxcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgbGluZURhc2g6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBsaW5lRGFzaE9mZnNldDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dPZmZzZXRYOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93T2Zmc2V0WTogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxpbmVXaWR0aDogMSxcblxuICAvKipcbiAgICogSWYgc3Ryb2tlIGlnbm9yZSBzY2FsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHN0cm9rZU5vU2NhbGU6IGZhbHNlLFxuICAvLyBCb3VuZGluZyByZWN0IHRleHQgY29uZmlndXJhdGlvblxuICAvLyBOb3QgYWZmZWN0ZWQgYnkgZWxlbWVudCB0cmFuc2Zvcm1cblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIElmIGBmb250U2l6ZWAgb3IgYGZvbnRGYW1pbHlgIGV4aXN0cywgYGZvbnRgIHdpbGwgYmUgcmVzZXQgYnlcbiAgICogYGZvbnRTaXplYCwgYGZvbnRTdHlsZWAsIGBmb250V2VpZ2h0YCwgYGZvbnRGYW1pbHlgLlxuICAgKiBTbyBkbyBub3QgdmlzaXQgaXQgZGlyZWN0bHkgaW4gdXBwZXIgYXBwbGljYXRpb24gKGxpa2UgZWNoYXJ0cyksXG4gICAqIGJ1dCB1c2UgYGNvbnRhaW4vdGV4dCNtYWtlRm9udGAgaW5zdGVhZC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRoZSBzYW1lIGFzIGZvbnQuIFVzZSBmb250IHBsZWFzZS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRGb250OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250U3R5bGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRXZWlnaHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogU2hvdWxkIGJlIDEyIGJ1dCBub3QgJzEycHgnLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZm9udFNpemU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRGYW1pbHk6IG51bGwsXG5cbiAgLyoqXG4gICAqIFJlc2VydmVkIGZvciBzcGVjaWFsIGZ1bmN0aW5hbGl0eSwgbGlrZSAnaHInLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFRhZzogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRGaWxsOiAnIzAwMCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0U3Ryb2tlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFdpZHRoOiBudWxsLFxuXG4gIC8qKlxuICAgKiBPbmx5IGZvciB0ZXh0QmFja2dyb3VuZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRIZWlnaHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIHRleHRTdHJva2UgbWF5IGJlIHNldCBhcyBzb21lIGNvbG9yIGFzIGEgZGVmYXVsdFxuICAgKiB2YWx1ZSBpbiB1cHBlciBhcHBsaWNhaW9uLCB3aGVyZSB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBvZiB0ZXh0U3Ryb2tlV2lkdGggc2hvdWxkIGJlIDAgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICogdXNlciBjYW4gY2hvb3NlIHRvIGRvIG5vdCB1c2UgdGV4dCBzdHJva2UuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0TGluZUhlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogJ2luc2lkZScsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXG4gICAqIFt4LCB5XVxuICAgKiBCYXNlZCBvbiB4LCB5IG9mIHJlY3QuXG4gICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAqIEBkZWZhdWx0ICdpbnNpZGUnXG4gICAqL1xuICB0ZXh0UG9zaXRpb246ICdpbnNpZGUnLFxuXG4gIC8qKlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgdGhlIGJvdW5kaW5nUmVjdCBvZiBhIGBkaXNwbGF5YWJsZWAuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0ZXh0UmVjdDogbnVsbCxcblxuICAvKipcbiAgICogW3gsIHldXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRPZmZzZXQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0QWxpZ246IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0VmVydGljYWxBbGlnbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHREaXN0YW5jZTogNSxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dCbHVyOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93T2Zmc2V0WTogMCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCb3hTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dCbHVyOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93T2Zmc2V0WTogMCxcblxuICAvKipcbiAgICogV2hldGhlciB0cmFuc2Zvcm0gdGV4dC5cbiAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRyYW5zZm9ybVRleHQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBUZXh0IHJvdGF0ZSBhcm91bmQgcG9zaXRpb24gb2YgUGF0aCBvciBJbWFnZVxuICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50IGFuZCB0cmFuc2Zvcm1UZXh0IGlzIGZhbHNlLlxuICAgKi9cbiAgdGV4dFJvdGF0aW9uOiAwLFxuXG4gIC8qKlxuICAgKiBUZXh0IG9yaWdpbiBvZiB0ZXh0IHJvdGF0aW9uLCBsaWtlIFsxMCwgNDBdLlxuICAgKiBCYXNlZCBvbiB4LCB5IG9mIHJlY3QuXG4gICAqIFVzZWZ1bCBpbiBsYWJlbCByb3RhdGlvbiBvZiBjaXJjdWxhciBzeW1ib2wuXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgb3JpZ2luIGlzIHRleHRQb3NpdGlvbi5cbiAgICogQ2FuIGJlICdjZW50ZXInLlxuICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dE9yaWdpbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0Qm9yZGVyQ29sb3I6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm9yZGVyV2lkdGg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm9yZGVyUmFkaXVzOiAwLFxuXG4gIC8qKlxuICAgKiBDYW4gYmUgYDJgIG9yIGBbMiwgNF1gIG9yIGBbMiwgMywgNCwgNV1gXG4gICAqIEB0eXBlIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0UGFkZGluZzogbnVsbCxcblxuICAvKipcbiAgICogVGV4dCBzdHlsZXMgZm9yIHJpY2ggdGV4dC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHJpY2g6IG51bGwsXG5cbiAgLyoqXG4gICAqIHtvdXRlcldpZHRoLCBvdXRlckhlaWdodCwgZWxsaXBzaXMsIHBsYWNlaG9sZGVyfVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdHJ1bmNhdGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBibGVuZDogbnVsbCxcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgYmluZDogZnVuY3Rpb24gKGN0eCwgZWwsIHByZXZFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXM7XG4gICAgdmFyIHByZXZTdHlsZSA9IHByZXZFbCAmJiBwcmV2RWwuc3R5bGU7XG4gICAgdmFyIGZpcnN0RHJhdyA9ICFwcmV2U3R5bGU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICB2YXIgc3R5bGVOYW1lID0gcHJvcFswXTtcblxuICAgICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZVtzdHlsZU5hbWVdICE9PSBwcmV2U3R5bGVbc3R5bGVOYW1lXSkge1xuICAgICAgICAvLyBGSVhNRSBJbnZhbGlkIHByb3BlcnR5IHZhbHVlIHdpbGwgY2F1c2Ugc3R5bGUgbGVhayBmcm9tIHByZXZpb3VzIGVsZW1lbnQuXG4gICAgICAgIGN0eFtzdHlsZU5hbWVdID0gc3R5bGVbc3R5bGVOYW1lXSB8fCBwcm9wWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGUuZmlsbCAhPT0gcHJldlN0eWxlLmZpbGwpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgIH1cblxuICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGUuc3Ryb2tlICE9PSBwcmV2U3R5bGUuc3Ryb2tlKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5vcGFjaXR5ICE9PSBwcmV2U3R5bGUub3BhY2l0eSkge1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUub3BhY2l0eSA9PSBudWxsID8gMSA6IHN0eWxlLm9wYWNpdHk7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5ibGVuZCAhPT0gcHJldlN0eWxlLmJsZW5kKSB7XG4gICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc3R5bGUuYmxlbmQgfHwgJ3NvdXJjZS1vdmVyJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggLyAodGhpcy5zdHJva2VOb1NjYWxlICYmIGVsICYmIGVsLmdldExpbmVTY2FsZSA/IGVsLmdldExpbmVTY2FsZSgpIDogMSk7XG4gICAgfVxuICB9LFxuICBoYXNGaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpbGwgPSB0aGlzLmZpbGw7XG4gICAgcmV0dXJuIGZpbGwgIT0gbnVsbCAmJiBmaWxsICE9PSAnbm9uZSc7XG4gIH0sXG4gIGhhc1N0cm9rZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICByZXR1cm4gc3Ryb2tlICE9IG51bGwgJiYgc3Ryb2tlICE9PSAnbm9uZScgJiYgdGhpcy5saW5lV2lkdGggPiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRlbmQgZnJvbSBvdGhlciBzdHlsZVxuICAgKiBAcGFyYW0ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gb3RoZXJTdHlsZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZSB0cnVlOiBvdmVyd3JpcnRlIGFueSB3YXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlOiBvdmVyd3JpdGUgb25seSB3aGVuICF0YXJnZXQuaGFzT3duUHJvcGVydHlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJzOiBvdmVyd3JpdGUgd2hlbiBwcm9wZXJ0eSBpcyBub3QgbnVsbC91bmRlZmluZWQuXG4gICAqL1xuICBleHRlbmRGcm9tOiBmdW5jdGlvbiAob3RoZXJTdHlsZSwgb3ZlcndyaXRlKSB7XG4gICAgaWYgKG90aGVyU3R5bGUpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXJTdHlsZSkge1xuICAgICAgICBpZiAob3RoZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAob3ZlcndyaXRlID09PSB0cnVlIHx8IChvdmVyd3JpdGUgPT09IGZhbHNlID8gIXRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgOiBvdGhlclN0eWxlW25hbWVdICE9IG51bGwpKSkge1xuICAgICAgICAgIHRoaXNbbmFtZV0gPSBvdGhlclN0eWxlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBCYXRjaCBzZXR0aW5nIHN0eWxlIHdpdGggYSBnaXZlbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvYmpcbiAgICogQHBhcmFtIHsqfSBbb2JqXVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpc1tvYmpdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXh0ZW5kRnJvbShvYmosIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVcbiAgICogQHJldHVybiB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgbmV3U3R5bGUuZXh0ZW5kRnJvbSh0aGlzLCB0cnVlKTtcbiAgICByZXR1cm4gbmV3U3R5bGU7XG4gIH0sXG4gIGdldEdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCBvYmosIHJlY3QpIHtcbiAgICB2YXIgbWV0aG9kID0gb2JqLnR5cGUgPT09ICdyYWRpYWwnID8gY3JlYXRlUmFkaWFsR3JhZGllbnQgOiBjcmVhdGVMaW5lYXJHcmFkaWVudDtcbiAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBtZXRob2QoY3R4LCBvYmosIHJlY3QpO1xuICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChjb2xvclN0b3BzW2ldLm9mZnNldCwgY29sb3JTdG9wc1tpXS5jb2xvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xuICB9XG59O1xudmFyIHN0eWxlUHJvdG8gPSBTdHlsZS5wcm90b3R5cGU7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuXG4gIGlmICghKHByb3BbMF0gaW4gc3R5bGVQcm90bykpIHtcbiAgICBzdHlsZVByb3RvW3Byb3BbMF1dID0gcHJvcFsxXTtcbiAgfVxufSAvLyBQcm92aWRlIGZvciBvdGhlcnNcblxuXG5TdHlsZS5nZXRHcmFkaWVudCA9IHN0eWxlUHJvdG8uZ2V0R3JhZGllbnQ7XG52YXIgX2RlZmF1bHQgPSBTdHlsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlhYmxlXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcIi4uL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvdGV4dFwiKTtcblxuLyoqXG4gKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL1RleHRcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xudmFyIFRleHQgPSBmdW5jdGlvbiAob3B0cykge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbn07XG5cblRleHQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGV4dCxcbiAgdHlwZTogJ3RleHQnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTsgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuXG4gICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTsgLy8gVXNlIHByb3BzIHdpdGggcHJlZml4ICd0ZXh0Jy5cblxuICAgIHN0eWxlLmZpbGwgPSBzdHlsZS5zdHJva2UgPSBzdHlsZS5zaGFkb3dCbHVyID0gc3R5bGUuc2hhZG93Q29sb3IgPSBzdHlsZS5zaGFkb3dPZmZzZXRYID0gc3R5bGUuc2hhZG93T2Zmc2V0WSA9IG51bGw7XG4gICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0OyAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXG4gICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTsgLy8gQWx3YXlzIGJpbmQgc3R5bGVcblxuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuXG4gICAgaWYgKCF0ZXh0SGVscGVyLm5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuICAgIHRleHRIZWxwZXIucmVuZGVyVGV4dCh0aGlzLCBjdHgsIHRleHQsIHN0eWxlKTtcbiAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcbiAgfSxcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTsgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuXG4gICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTtcblxuICAgIGlmICghdGhpcy5fcmVjdCkge1xuICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuICAgICAgdGV4dCAhPSBudWxsID8gdGV4dCArPSAnJyA6IHRleHQgPSAnJztcbiAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHN0eWxlLnRleHQgKyAnJywgc3R5bGUuZm9udCwgc3R5bGUudGV4dEFsaWduLCBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiwgc3R5bGUudGV4dFBhZGRpbmcsIHN0eWxlLnJpY2gpO1xuICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgIHJlY3QueSArPSBzdHlsZS55IHx8IDA7XG5cbiAgICAgIGlmICh0ZXh0SGVscGVyLmdldFN0cm9rZShzdHlsZS50ZXh0U3Ryb2tlLCBzdHlsZS50ZXh0U3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIHZhciB3ID0gc3R5bGUudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgICByZWN0LnggLT0gdyAvIDI7XG4gICAgICAgIHJlY3QueSAtPSB3IC8gMjtcbiAgICAgICAgcmVjdC53aWR0aCArPSB3O1xuICAgICAgICByZWN0LmhlaWdodCArPSB3O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWN0ID0gcmVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhUZXh0LCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBUZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlbnYgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9lbnZcIik7XG5cbi8vIEZpeCB3ZWlyZCBidWcgaW4gc29tZSB2ZXJzaW9uIG9mIElFMTEgKGxpa2UgMTEuMC45NjAwLjE3OCoqKSxcbi8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcbi8vIG1pZ2h0IGJlIHRocm93biB3aGVuIGNhbGxpbmcgY3R4LmZpbGwgb3IgY3R4LnN0cm9rZSBhZnRlciBhIHBhdGhcbi8vIHdob3NlIGFyZWEgc2l6ZSBpcyB6ZXJvIGlzIGRyYXduIGFuZCBjdHguY2xpcCgpIGlzIGNhbGxlZCBhbmRcbi8vIHNoYWRvd0JsdXIgaXMgc2V0LiBTZWUgIzQ1NzIsICMzMTEyLCAjNTc3Ny5cbi8vIChlLmcuLFxuLy8gIGN0eC5tb3ZlVG8oMTAsIDEwKTtcbi8vICBjdHgubGluZVRvKDIwLCAxMCk7XG4vLyAgY3R4LmNsb3NlUGF0aCgpO1xuLy8gIGN0eC5jbGlwKCk7XG4vLyAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcbi8vICAuLi5cbi8vICBjdHguZmlsbCgpO1xuLy8gKVxudmFyIHNoYWRvd1RlbXAgPSBbWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF1dO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChvcmlnbmFsQnJ1c2gpIHtcbiAgLy8gdmVyc2lvbiBzdHJpbmcgY2FuIGJlOiAnMTEuMCdcbiAgcmV0dXJuIGVudi5icm93c2VyLmllICYmIGVudi5icm93c2VyLnZlcnNpb24gPj0gMTEgPyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsaXBQYXRocyA9IHRoaXMuX19jbGlwUGF0aHM7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbW9kaWZpZWQ7XG5cbiAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnNoYXBlO1xuICAgICAgICB2YXIgdHlwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnR5cGU7XG5cbiAgICAgICAgaWYgKHNoYXBlICYmICh0eXBlID09PSAnc2VjdG9yJyAmJiBzaGFwZS5zdGFydEFuZ2xlID09PSBzaGFwZS5lbmRBbmdsZSB8fCB0eXBlID09PSAncmVjdCcgJiYgKCFzaGFwZS53aWR0aCB8fCAhc2hhcGUuaGVpZ2h0KSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIC8vIEl0IGlzIHNhdmUgdG8gcHV0IHNoYWRvd1RlbXAgc3RhdGljLCBiZWNhdXNlIHNoYWRvd1RlbXBcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYWxsIG1vZGlmaWVkIGVhY2ggaXRlbSBicnVzaCBjYWxsZWQuXG4gICAgICAgICAgICBzaGFkb3dUZW1wW2pdWzJdID0gc3R5bGVbc2hhZG93VGVtcFtqXVswXV07XG4gICAgICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3JpZ25hbEJydXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMl07XG4gICAgICB9XG4gICAgfVxuICB9IDogb3JpZ25hbEJydXNoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBMUlUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9MUlVcIik7XG5cbnZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2VcbiAqL1xuXG5mdW5jdGlvbiBmaW5kRXhpc3RJbWFnZShuZXdJbWFnZU9yU3JjKSB7XG4gIGlmICh0eXBlb2YgbmV3SW1hZ2VPclNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG4gICAgcmV0dXJuIGNhY2hlZEltZ09iaiAmJiBjYWNoZWRJbWdPYmouaW1hZ2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gIH1cbn1cbi8qKlxuICogQ2F1dGlvbjogVXNlciBzaG91bGQgY2FjaGUgbG9hZGVkIGltYWdlcywgYnV0IG5vdCBqdXN0IGNvdW50IG9uIExSVS5cbiAqIENvbnNpZGVyIGlmIHJlcXVpcmVkIGltYWdlcyBtb3JlIHRoYW4gTFJVIHNpemUsIHdpbGwgZGVhZCBsb29wIG9jY3VyP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZSBFeGlzdGVudCBpbWFnZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gW2hvc3RFbF0gRm9yIGNhbGxpbmcgYGRpcnR5YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gcGFyYW1zOiAoaW1hZ2UsIGNiUGF5bG9hZClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY2JQYXlsb2FkXSBQYXlsb2FkIG9uIGNiIGNhbGxpbmcuXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlSW1hZ2UobmV3SW1hZ2VPclNyYywgaW1hZ2UsIGhvc3RFbCwgY2IsIGNiUGF5bG9hZCkge1xuICBpZiAoIW5ld0ltYWdlT3JTcmMpIHtcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0ltYWdlT3JTcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSW1hZ2Ugc2hvdWxkIG5vdCBiZSBsb2FkZWQgcmVwZWF0bHkuXG4gICAgaWYgKGltYWdlICYmIGltYWdlLl9fenJJbWFnZVNyYyA9PT0gbmV3SW1hZ2VPclNyYyB8fCAhaG9zdEVsKSB7XG4gICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSAvLyBPbmx5IHdoZW4gdGhlcmUgaXMgbm8gZXhpc3RlbnQgaW1hZ2Ugb3IgZXhpc3RlbnQgaW1hZ2Ugc3JjXG4gICAgLy8gaXMgZGlmZmVyZW50LCB0aGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgbG9hZC5cblxuXG4gICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KG5ld0ltYWdlT3JTcmMpO1xuICAgIHZhciBwZW5kaW5nV3JhcCA9IHtcbiAgICAgIGhvc3RFbDogaG9zdEVsLFxuICAgICAgY2I6IGNiLFxuICAgICAgY2JQYXlsb2FkOiBjYlBheWxvYWRcbiAgICB9O1xuXG4gICAgaWYgKGNhY2hlZEltZ09iaikge1xuICAgICAgaW1hZ2UgPSBjYWNoZWRJbWdPYmouaW1hZ2U7XG4gICAgICAhaXNJbWFnZVJlYWR5KGltYWdlKSAmJiBjYWNoZWRJbWdPYmoucGVuZGluZy5wdXNoKHBlbmRpbmdXcmFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIWltYWdlICYmIChpbWFnZSA9IG5ldyBJbWFnZSgpKTtcbiAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlT25Mb2FkO1xuICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQobmV3SW1hZ2VPclNyYywgaW1hZ2UuX19jYWNoZWRJbWdPYmogPSB7XG4gICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgcGVuZGluZzogW3BlbmRpbmdXcmFwXVxuICAgICAgfSk7XG4gICAgICBpbWFnZS5zcmMgPSBpbWFnZS5fX3pySW1hZ2VTcmMgPSBuZXdJbWFnZU9yU3JjO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZTtcbiAgfSAvLyBuZXdJbWFnZU9yU3JjIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gIGVsc2Uge1xuICAgICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbWFnZU9uTG9hZCgpIHtcbiAgdmFyIGNhY2hlZEltZ09iaiA9IHRoaXMuX19jYWNoZWRJbWdPYmo7XG4gIHRoaXMub25sb2FkID0gdGhpcy5fX2NhY2hlZEltZ09iaiA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwZW5kaW5nV3JhcCA9IGNhY2hlZEltZ09iai5wZW5kaW5nW2ldO1xuICAgIHZhciBjYiA9IHBlbmRpbmdXcmFwLmNiO1xuICAgIGNiICYmIGNiKHRoaXMsIHBlbmRpbmdXcmFwLmNiUGF5bG9hZCk7XG4gICAgcGVuZGluZ1dyYXAuaG9zdEVsLmRpcnR5KCk7XG4gIH1cblxuICBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBpc0ltYWdlUmVhZHkoaW1hZ2UpIHtcbiAgcmV0dXJuIGltYWdlICYmIGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodDtcbn1cblxuZXhwb3J0cy5maW5kRXhpc3RJbWFnZSA9IGZpbmRFeGlzdEltYWdlO1xuZXhwb3J0cy5jcmVhdGVPclVwZGF0ZUltYWdlID0gY3JlYXRlT3JVcGRhdGVJbWFnZTtcbmV4cG9ydHMuaXNJbWFnZVJlYWR5ID0gaXNJbWFnZVJlYWR5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9pbWFnZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBzbW9vdGhTcGxpbmUgPSByZXF1aXJlKFwiLi9zbW9vdGhTcGxpbmVcIik7XG5cbnZhciBzbW9vdGhCZXppZXIgPSByZXF1aXJlKFwiLi9zbW9vdGhCZXppZXJcIik7XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChjdHgsIHNoYXBlLCBjbG9zZVBhdGgpIHtcbiAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgdmFyIHNtb290aCA9IHNoYXBlLnNtb290aDtcblxuICBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGggPj0gMikge1xuICAgIGlmIChzbW9vdGggJiYgc21vb3RoICE9PSAnc3BsaW5lJykge1xuICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBzbW9vdGhCZXppZXIocG9pbnRzLCBzbW9vdGgsIGNsb3NlUGF0aCwgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChjbG9zZVBhdGggPyBsZW4gOiBsZW4gLSAxKTsgaSsrKSB7XG4gICAgICAgIHZhciBjcDEgPSBjb250cm9sUG9pbnRzW2kgKiAyXTtcbiAgICAgICAgdmFyIGNwMiA9IGNvbnRyb2xQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcFswXSwgcFsxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzbW9vdGggPT09ICdzcGxpbmUnKSB7XG4gICAgICAgIHBvaW50cyA9IHNtb290aFNwbGluZShwb2ludHMsIGNsb3NlUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VQYXRoICYmIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuXG5leHBvcnRzLmJ1aWxkUGF0aCA9IGJ1aWxkUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZnVuY3Rpb24gYnVpbGRQYXRoKGN0eCwgc2hhcGUpIHtcbiAgdmFyIHggPSBzaGFwZS54O1xuICB2YXIgeSA9IHNoYXBlLnk7XG4gIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICB2YXIgciA9IHNoYXBlLnI7XG4gIHZhciByMTtcbiAgdmFyIHIyO1xuICB2YXIgcjM7XG4gIHZhciByNDsgLy8gQ29udmVydCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHBvc2l0aXZlIGZvciBiZXR0ZXIgYm9yZGVyUmFkaXVzXG5cbiAgaWYgKHdpZHRoIDwgMCkge1xuICAgIHggPSB4ICsgd2lkdGg7XG4gICAgd2lkdGggPSAtd2lkdGg7XG4gIH1cblxuICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgcjEgPSByMiA9IHIzID0gcjQgPSByO1xuICB9IGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGlmIChyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByWzBdO1xuICAgIH0gZWxzZSBpZiAoci5sZW5ndGggPT09IDIpIHtcbiAgICAgIHIxID0gcjMgPSByWzBdO1xuICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgfSBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMykge1xuICAgICAgcjEgPSByWzBdO1xuICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICByMyA9IHJbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHIxID0gclswXTtcbiAgICAgIHIyID0gclsxXTtcbiAgICAgIHIzID0gclsyXTtcbiAgICAgIHI0ID0gclszXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcjEgPSByMiA9IHIzID0gcjQgPSAwO1xuICB9XG5cbiAgdmFyIHRvdGFsO1xuXG4gIGlmIChyMSArIHIyID4gd2lkdGgpIHtcbiAgICB0b3RhbCA9IHIxICsgcjI7XG4gICAgcjEgKj0gd2lkdGggLyB0b3RhbDtcbiAgICByMiAqPSB3aWR0aCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIzICsgcjQgPiB3aWR0aCkge1xuICAgIHRvdGFsID0gcjMgKyByNDtcbiAgICByMyAqPSB3aWR0aCAvIHRvdGFsO1xuICAgIHI0ICo9IHdpZHRoIC8gdG90YWw7XG4gIH1cblxuICBpZiAocjIgKyByMyA+IGhlaWdodCkge1xuICAgIHRvdGFsID0gcjIgKyByMztcbiAgICByMiAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICByMyAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMSArIHI0ID4gaGVpZ2h0KSB7XG4gICAgdG90YWwgPSByMSArIHI0O1xuICAgIHIxICo9IGhlaWdodCAvIHRvdGFsO1xuICAgIHI0ICo9IGhlaWdodCAvIHRvdGFsO1xuICB9XG5cbiAgY3R4Lm1vdmVUbyh4ICsgcjEsIHkpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHIyLCB5KTtcbiAgcjIgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByMik7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcjMpO1xuICByMyAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHIzLCB5ICsgaGVpZ2h0KTtcbiAgY3R4LmxpbmVUbyh4ICsgcjQsIHkgKyBoZWlnaHQpO1xuICByNCAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcjQpO1xuICBjdHgubGluZVRvKHgsIHkgKyByMSk7XG4gIHIxICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByMSwgeSk7XG59XG5cbmV4cG9ydHMuYnVpbGRQYXRoID0gYnVpbGRQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2Mk1pbiA9IF92ZWN0b3IubWluO1xudmFyIHYyTWF4ID0gX3ZlY3Rvci5tYXg7XG52YXIgdjJTY2FsZSA9IF92ZWN0b3Iuc2NhbGU7XG52YXIgdjJEaXN0YW5jZSA9IF92ZWN0b3IuZGlzdGFuY2U7XG52YXIgdjJBZGQgPSBfdmVjdG9yLmFkZDtcbnZhciB2MkNsb25lID0gX3ZlY3Rvci5jbG9uZTtcbnZhciB2MlN1YiA9IF92ZWN0b3Iuc3ViO1xuXG4vKipcbiAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAqIEBwYXJhbSB7bnVtYmVyfSBzbW9vdGgg5bmz5ruR562J57qnLCAwLTFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50IOWwhuiuoeeul+WHuuadpeeahOaOp+WItueCuee6puadn+WcqOS4gOS4quWMheWbtOebkuWGhVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICDmr5TlpoIgW1swLCAwXSwgWzEwMCwgMTAwXV0sIOi/meS4quWMheWbtOebkuS8muS4jlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICDmlbTkuKrmipjnur/nmoTljIXlm7Tnm5LlgZrkuIDkuKrlubbpm4bnlKjmnaXnuqbmnZ/mjqfliLbngrnjgIJcbiAqIEBwYXJhbSB7QXJyYXl9IOiuoeeul+WHuuadpeeahOaOp+WItueCueaVsOe7hFxuICovXG5mdW5jdGlvbiBfZGVmYXVsdChwb2ludHMsIHNtb290aCwgaXNMb29wLCBjb25zdHJhaW50KSB7XG4gIHZhciBjcHMgPSBbXTtcbiAgdmFyIHYgPSBbXTtcbiAgdmFyIHYxID0gW107XG4gIHZhciB2MiA9IFtdO1xuICB2YXIgcHJldlBvaW50O1xuICB2YXIgbmV4dFBvaW50O1xuICB2YXIgbWluLCBtYXg7XG5cbiAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICBtaW4gPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgICBtYXggPSBbLUluZmluaXR5LCAtSW5maW5pdHldO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdjJNaW4obWluLCBtaW4sIHBvaW50c1tpXSk7XG4gICAgICB2Mk1heChtYXgsIG1heCwgcG9pbnRzW2ldKTtcbiAgICB9IC8vIOS4juaMh+WumueahOWMheWbtOebkuWBmuW5tumbhlxuXG5cbiAgICB2Mk1pbihtaW4sIG1pbiwgY29uc3RyYWludFswXSk7XG4gICAgdjJNYXgobWF4LCBtYXgsIGNvbnN0cmFpbnRbMV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgIGlmIChpc0xvb3ApIHtcbiAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpID8gaSAtIDEgOiBsZW4gLSAxXTtcbiAgICAgIG5leHRQb2ludCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICBjcHMucHVzaCh2MkNsb25lKHBvaW50c1tpXSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV07XG4gICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdjJTdWIodiwgbmV4dFBvaW50LCBwcmV2UG9pbnQpOyAvLyB1c2UgZGVncmVlIHRvIHNjYWxlIHRoZSBoYW5kbGUgbGVuZ3RoXG5cbiAgICB2MlNjYWxlKHYsIHYsIHNtb290aCk7XG4gICAgdmFyIGQwID0gdjJEaXN0YW5jZShwb2ludCwgcHJldlBvaW50KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RhbmNlKHBvaW50LCBuZXh0UG9pbnQpO1xuICAgIHZhciBzdW0gPSBkMCArIGQxO1xuXG4gICAgaWYgKHN1bSAhPT0gMCkge1xuICAgICAgZDAgLz0gc3VtO1xuICAgICAgZDEgLz0gc3VtO1xuICAgIH1cblxuICAgIHYyU2NhbGUodjEsIHYsIC1kMCk7XG4gICAgdjJTY2FsZSh2MiwgdiwgZDEpO1xuICAgIHZhciBjcDAgPSB2MkFkZChbXSwgcG9pbnQsIHYxKTtcbiAgICB2YXIgY3AxID0gdjJBZGQoW10sIHBvaW50LCB2Mik7XG5cbiAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgdjJNYXgoY3AwLCBjcDAsIG1pbik7XG4gICAgICB2Mk1pbihjcDAsIGNwMCwgbWF4KTtcbiAgICAgIHYyTWF4KGNwMSwgY3AxLCBtaW4pO1xuICAgICAgdjJNaW4oY3AxLCBjcDEsIG1heCk7XG4gICAgfVxuXG4gICAgY3BzLnB1c2goY3AwKTtcbiAgICBjcHMucHVzaChjcDEpO1xuICB9XG5cbiAgaWYgKGlzTG9vcCkge1xuICAgIGNwcy5wdXNoKGNwcy5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBjcHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyRGlzdGFuY2UgPSBfdmVjdG9yLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhdG11bGwtUm9tIHNwbGluZSDmj5LlgLzmipjnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBfZGVmYXVsdChwb2ludHMsIGlzTG9vcCkge1xuICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgZGlzdGFuY2UgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICBkaXN0YW5jZSArPSB2MkRpc3RhbmNlKHBvaW50c1tpIC0gMV0sIHBvaW50c1tpXSk7XG4gIH1cblxuICB2YXIgc2VncyA9IGRpc3RhbmNlIC8gMjtcbiAgc2VncyA9IHNlZ3MgPCBsZW4gPyBsZW4gOiBzZWdzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgdmFyIHBvcyA9IGkgLyAoc2VncyAtIDEpICogKGlzTG9vcCA/IGxlbiA6IGxlbiAtIDEpO1xuICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHBvcyk7XG4gICAgdmFyIHcgPSBwb3MgLSBpZHg7XG4gICAgdmFyIHAwO1xuICAgIHZhciBwMSA9IHBvaW50c1tpZHggJSBsZW5dO1xuICAgIHZhciBwMjtcbiAgICB2YXIgcDM7XG5cbiAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgcDAgPSBwb2ludHNbaWR4ID09PSAwID8gaWR4IDogaWR4IC0gMV07XG4gICAgICBwMiA9IHBvaW50c1tpZHggPiBsZW4gLSAyID8gbGVuIC0gMSA6IGlkeCArIDFdO1xuICAgICAgcDMgPSBwb2ludHNbaWR4ID4gbGVuIC0gMyA/IGxlbiAtIDEgOiBpZHggKyAyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcDAgPSBwb2ludHNbKGlkeCAtIDEgKyBsZW4pICUgbGVuXTtcbiAgICAgIHAyID0gcG9pbnRzWyhpZHggKyAxKSAlIGxlbl07XG4gICAgICBwMyA9IHBvaW50c1soaWR4ICsgMikgJSBsZW5dO1xuICAgIH1cblxuICAgIHZhciB3MiA9IHcgKiB3O1xuICAgIHZhciB3MyA9IHcgKiB3MjtcbiAgICByZXQucHVzaChbaW50ZXJwb2xhdGUocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0sIHcsIHcyLCB3MyksIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF91dGlsID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdXRpbFwiKTtcblxudmFyIHJldHJpZXZlMiA9IF91dGlsLnJldHJpZXZlMjtcbnZhciByZXRyaWV2ZTMgPSBfdXRpbC5yZXRyaWV2ZTM7XG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG52YXIgbm9ybWFsaXplQ3NzQXJyYXkgPSBfdXRpbC5ub3JtYWxpemVDc3NBcnJheTtcbnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nO1xudmFyIGlzT2JqZWN0ID0gX3V0aWwuaXNPYmplY3Q7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi8uLi9jb250YWluL3RleHRcIik7XG5cbnZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKFwiLi9yb3VuZFJlY3RcIik7XG5cbnZhciBpbWFnZUhlbHBlciA9IHJlcXVpcmUoXCIuL2ltYWdlXCIpO1xuXG4vLyBUT0RPOiBIYXZlIG5vdCBzdXBwb3J0ICdzdGFydCcsICdlbmQnIHlldC5cbnZhciBWQUxJRF9URVhUX0FMSUdOID0ge1xuICBsZWZ0OiAxLFxuICByaWdodDogMSxcbiAgY2VudGVyOiAxXG59O1xudmFyIFZBTElEX1RFWFRfVkVSVElDQUxfQUxJR04gPSB7XG4gIHRvcDogMSxcbiAgYm90dG9tOiAxLFxuICBtaWRkbGU6IDFcbn07XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gc3R5bGVcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IFRoZSBpbnB1dCBzdHlsZS5cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUpIHtcbiAgbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICBlYWNoKHN0eWxlLnJpY2gsIG5vcm1hbGl6ZVN0eWxlKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZShzdHlsZSkge1xuICBpZiAoc3R5bGUpIHtcbiAgICBzdHlsZS5mb250ID0gdGV4dENvbnRhaW4ubWFrZUZvbnQoc3R5bGUpO1xuICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgdGV4dEFsaWduID09PSAnbWlkZGxlJyAmJiAodGV4dEFsaWduID0gJ2NlbnRlcicpO1xuICAgIHN0eWxlLnRleHRBbGlnbiA9IHRleHRBbGlnbiA9PSBudWxsIHx8IFZBTElEX1RFWFRfQUxJR05bdGV4dEFsaWduXSA/IHRleHRBbGlnbiA6ICdsZWZ0JzsgLy8gQ29tcGF0aWJsZSB3aXRoIHRleHRCYXNlbGluZS5cblxuICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2NlbnRlcicgJiYgKHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZScpO1xuICAgIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFZlcnRpY2FsQWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX1ZFUlRJQ0FMX0FMSUdOW3RleHRWZXJ0aWNhbEFsaWduXSA/IHRleHRWZXJ0aWNhbEFsaWduIDogJ3RvcCc7XG4gICAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG5cbiAgICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICAgIHN0eWxlLnRleHRQYWRkaW5nID0gbm9ybWFsaXplQ3NzQXJyYXkoc3R5bGUudGV4dFBhZGRpbmcpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBzdHlsZVxuICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gW3JlY3RdIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogICAgICAgICAgICAgICAgICBJZiBzZXQgZmFsc2UsIHJlY3QgdGV4dCBpcyBub3QgdXNlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbmRlclRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHN0eWxlLnJpY2ggPyByZW5kZXJSaWNoVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIDogcmVuZGVyUGxhaW5UZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBsYWluVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGZvbnQgPSBzZXRDdHgoY3R4LCAnZm9udCcsIHN0eWxlLmZvbnQgfHwgdGV4dENvbnRhaW4uREVGQVVMVF9GT05UKTtcbiAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHkpIHtcbiAgICBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgc3R5bGUudHJ1bmNhdGUpO1xuICB9XG5cbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgdGV4dExpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICB2YXIgbGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuICB2YXIgYm94UG9zID0gZ2V0Qm94UG9zaXRpb24ob3V0ZXJIZWlnaHQsIHN0eWxlLCByZWN0KTtcbiAgdmFyIGJhc2VYID0gYm94UG9zLmJhc2VYO1xuICB2YXIgYmFzZVkgPSBib3hQb3MuYmFzZVk7XG4gIHZhciB0ZXh0QWxpZ24gPSBib3hQb3MudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBib3hQb3MudGV4dFZlcnRpY2FsQWxpZ247IC8vIE9yaWdpbiBvZiB0ZXh0Um90YXRpb24gc2hvdWxkIGJlIHRoZSBiYXNlIHBvaW50IG9mIHRleHQgZHJhd2luZy5cblxuICBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCBiYXNlWCwgYmFzZVkpO1xuICB2YXIgYm94WSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKGJhc2VZLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICB2YXIgdGV4dFggPSBiYXNlWDtcbiAgdmFyIHRleHRZID0gYm94WTtcbiAgdmFyIG5lZWREcmF3QmcgPSBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpO1xuXG4gIGlmIChuZWVkRHJhd0JnIHx8IHRleHRQYWRkaW5nKSB7XG4gICAgLy8gQ29uc2lkZXIgcGVyZm9ybWFuY2UsIGRvIG5vdCBjYWxsIGdldFRleHRXaWR0aCB1dGlsIG5lY2Vzc2FyeS5cbiAgICB2YXIgdGV4dFdpZHRoID0gdGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dCwgZm9udCk7XG4gICAgdmFyIG91dGVyV2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgdGV4dFBhZGRpbmcgJiYgKG91dGVyV2lkdGggKz0gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXSk7XG4gICAgdmFyIGJveFggPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WChiYXNlWCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgICBuZWVkRHJhd0JnICYmIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgYm94WCwgYm94WSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xuXG4gICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICB0ZXh0WCA9IGdldFRleHRYRm9yUGFkZGluZyhiYXNlWCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZyk7XG4gICAgICB0ZXh0WSArPSB0ZXh0UGFkZGluZ1swXTtcbiAgICB9XG4gIH1cblxuICBzZXRDdHgoY3R4LCAndGV4dEFsaWduJywgdGV4dEFsaWduIHx8ICdsZWZ0Jyk7IC8vIEZvcmNlIGJhc2VsaW5lIHRvIGJlIFwibWlkZGxlXCIuIE90aGVyd2lzZSwgaWYgdXNpbmcgXCJ0b3BcIiwgdGhlXG4gIC8vIHRleHQgd2lsbCBvZmZzZXQgZG93bndhcmQgYSBsaXR0bGUgYml0IGluIGZvbnQgXCJNaWNyb3NvZnQgWWFIZWlcIi5cblxuICBzZXRDdHgoY3R4LCAndGV4dEJhc2VsaW5lJywgJ21pZGRsZScpOyAvLyBBbHdheXMgc2V0IHNoYWRvd0JsdXIgYW5kIHNoYWRvd09mZnNldCB0byBhdm9pZCBsZWFrIGZyb20gZGlzcGxheWFibGUuXG5cbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCBzdHlsZS50ZXh0U2hhZG93Qmx1ciB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZIHx8IDApOyAvLyBgdGV4dEJhc2VsaW5lYCBpcyBzZXQgYXMgJ21pZGRsZScuXG5cbiAgdGV4dFkgKz0gbGluZUhlaWdodCAvIDI7XG4gIHZhciB0ZXh0U3Ryb2tlV2lkdGggPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gIHZhciB0ZXh0U3Ryb2tlID0gZ2V0U3Ryb2tlKHN0eWxlLnRleHRTdHJva2UsIHRleHRTdHJva2VXaWR0aCk7XG4gIHZhciB0ZXh0RmlsbCA9IGdldEZpbGwoc3R5bGUudGV4dEZpbGwpO1xuXG4gIGlmICh0ZXh0U3Ryb2tlKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRTdHJva2VXaWR0aCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dFN0cm9rZSk7XG4gIH1cblxuICBpZiAodGV4dEZpbGwpIHtcbiAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEZpbGwpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBGaWxsIGFmdGVyIHN0cm9rZSBzbyB0aGUgb3V0bGluZSB3aWxsIG5vdCBjb3ZlciB0aGUgbWFpbiBwYXJ0LlxuICAgIHRleHRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB0ZXh0WCwgdGV4dFkpO1xuICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRYLCB0ZXh0WSk7XG4gICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSaWNoVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jaztcblxuICBpZiAoIWNvbnRlbnRCbG9jayB8fCBob3N0RWwuX19kaXJ0eSkge1xuICAgIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jayA9IHRleHRDb250YWluLnBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpO1xuICB9XG5cbiAgZHJhd1JpY2hUZXh0KGhvc3RFbCwgY3R4LCBjb250ZW50QmxvY2ssIHN0eWxlLCByZWN0KTtcbn1cblxuZnVuY3Rpb24gZHJhd1JpY2hUZXh0KGhvc3RFbCwgY3R4LCBjb250ZW50QmxvY2ssIHN0eWxlLCByZWN0KSB7XG4gIHZhciBjb250ZW50V2lkdGggPSBjb250ZW50QmxvY2sud2lkdGg7XG4gIHZhciBvdXRlcldpZHRoID0gY29udGVudEJsb2NrLm91dGVyV2lkdGg7XG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG4gIHZhciBib3hQb3MgPSBnZXRCb3hQb3NpdGlvbihvdXRlckhlaWdodCwgc3R5bGUsIHJlY3QpO1xuICB2YXIgYmFzZVggPSBib3hQb3MuYmFzZVg7XG4gIHZhciBiYXNlWSA9IGJveFBvcy5iYXNlWTtcbiAgdmFyIHRleHRBbGlnbiA9IGJveFBvcy50ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IGJveFBvcy50ZXh0VmVydGljYWxBbGlnbjsgLy8gT3JpZ2luIG9mIHRleHRSb3RhdGlvbiBzaG91bGQgYmUgdGhlIGJhc2UgcG9pbnQgb2YgdGV4dCBkcmF3aW5nLlxuXG4gIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIGJhc2VYLCBiYXNlWSk7XG4gIHZhciBib3hYID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoYmFzZVgsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gIHZhciBib3hZID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoYmFzZVksIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciB4TGVmdCA9IGJveFg7XG4gIHZhciBsaW5lVG9wID0gYm94WTtcblxuICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICB4TGVmdCArPSB0ZXh0UGFkZGluZ1szXTtcbiAgICBsaW5lVG9wICs9IHRleHRQYWRkaW5nWzBdO1xuICB9XG5cbiAgdmFyIHhSaWdodCA9IHhMZWZ0ICsgY29udGVudFdpZHRoO1xuICBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpICYmIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgYm94WCwgYm94WSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEJsb2NrLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBjb250ZW50QmxvY2subGluZXNbaV07XG4gICAgdmFyIHRva2VucyA9IGxpbmUudG9rZW5zO1xuICAgIHZhciB0b2tlbkNvdW50ID0gdG9rZW5zLmxlbmd0aDtcbiAgICB2YXIgbGluZUhlaWdodCA9IGxpbmUubGluZUhlaWdodDtcbiAgICB2YXIgdXNlZFdpZHRoID0gbGluZS53aWR0aDtcbiAgICB2YXIgbGVmdEluZGV4ID0gMDtcbiAgICB2YXIgbGluZVhMZWZ0ID0geExlZnQ7XG4gICAgdmFyIGxpbmVYUmlnaHQgPSB4UmlnaHQ7XG4gICAgdmFyIHJpZ2h0SW5kZXggPSB0b2tlbkNvdW50IC0gMTtcbiAgICB2YXIgdG9rZW47XG5cbiAgICB3aGlsZSAobGVmdEluZGV4IDwgdG9rZW5Db3VudCAmJiAodG9rZW4gPSB0b2tlbnNbbGVmdEluZGV4XSwgIXRva2VuLnRleHRBbGlnbiB8fCB0b2tlbi50ZXh0QWxpZ24gPT09ICdsZWZ0JykpIHtcbiAgICAgIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgbGluZVhMZWZ0LCAnbGVmdCcpO1xuICAgICAgdXNlZFdpZHRoIC09IHRva2VuLndpZHRoO1xuICAgICAgbGluZVhMZWZ0ICs9IHRva2VuLndpZHRoO1xuICAgICAgbGVmdEluZGV4Kys7XG4gICAgfVxuXG4gICAgd2hpbGUgKHJpZ2h0SW5kZXggPj0gMCAmJiAodG9rZW4gPSB0b2tlbnNbcmlnaHRJbmRleF0sIHRva2VuLnRleHRBbGlnbiA9PT0gJ3JpZ2h0JykpIHtcbiAgICAgIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgbGluZVhSaWdodCwgJ3JpZ2h0Jyk7XG4gICAgICB1c2VkV2lkdGggLT0gdG9rZW4ud2lkdGg7XG4gICAgICBsaW5lWFJpZ2h0IC09IHRva2VuLndpZHRoO1xuICAgICAgcmlnaHRJbmRleC0tO1xuICAgIH0gLy8gVGhlIG90aGVyIHRva2VucyBhcmUgcGxhY2VkIGFzIHRleHRBbGlnbiAnY2VudGVyJyBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UuXG5cblxuICAgIGxpbmVYTGVmdCArPSAoY29udGVudFdpZHRoIC0gKGxpbmVYTGVmdCAtIHhMZWZ0KSAtICh4UmlnaHQgLSBsaW5lWFJpZ2h0KSAtIHVzZWRXaWR0aCkgLyAyO1xuXG4gICAgd2hpbGUgKGxlZnRJbmRleCA8PSByaWdodEluZGV4KSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tsZWZ0SW5kZXhdOyAvLyBDb25zaWRlciB3aWR0aCBzcGVjaWZpZWQgYnkgdXNlciwgdXNlICdjZW50ZXInIHJhdGhlciB0aGFuICdsZWZ0Jy5cblxuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWExlZnQgKyB0b2tlbi53aWR0aCAvIDIsICdjZW50ZXInKTtcbiAgICAgIGxpbmVYTGVmdCArPSB0b2tlbi53aWR0aDtcbiAgICAgIGxlZnRJbmRleCsrO1xuICAgIH1cblxuICAgIGxpbmVUb3AgKz0gbGluZUhlaWdodDtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCB4LCB5KSB7XG4gIC8vIHRleHRSb3RhdGlvbiBvbmx5IGFwcGx5IGluIFJlY3RUZXh0LlxuICBpZiAocmVjdCAmJiBzdHlsZS50ZXh0Um90YXRpb24pIHtcbiAgICB2YXIgb3JpZ2luID0gc3R5bGUudGV4dE9yaWdpbjtcblxuICAgIGlmIChvcmlnaW4gPT09ICdjZW50ZXInKSB7XG4gICAgICB4ID0gcmVjdC53aWR0aCAvIDIgKyByZWN0Lng7XG4gICAgICB5ID0gcmVjdC5oZWlnaHQgLyAyICsgcmVjdC55O1xuICAgIH0gZWxzZSBpZiAob3JpZ2luKSB7XG4gICAgICB4ID0gb3JpZ2luWzBdICsgcmVjdC54O1xuICAgICAgeSA9IG9yaWdpblsxXSArIHJlY3QueTtcbiAgICB9XG5cbiAgICBjdHgudHJhbnNsYXRlKHgsIHkpOyAvLyBQb3NpdGl2ZTogYW50aWNsb2Nrd2lzZVxuXG4gICAgY3R4LnJvdGF0ZSgtc3R5bGUudGV4dFJvdGF0aW9uKTtcbiAgICBjdHgudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCB4LCB0ZXh0QWxpZ24pIHtcbiAgdmFyIHRva2VuU3R5bGUgPSBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307IC8vICdjdHgudGV4dEJhc2VsaW5lJyBpcyBhbHdheXMgc2V0IGFzICdtaWRkbGUnLCBmb3Igc2FrZSBvZlxuICAvLyB0aGUgYmlhcyBvZiBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHRva2VuLnRleHRWZXJ0aWNhbEFsaWduO1xuICB2YXIgeSA9IGxpbmVUb3AgKyBsaW5lSGVpZ2h0IC8gMjtcblxuICBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSA9IGxpbmVUb3AgKyB0b2tlbi5oZWlnaHQgLyAyO1xuICB9IGVsc2UgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgPSBsaW5lVG9wICsgbGluZUhlaWdodCAtIHRva2VuLmhlaWdodCAvIDI7XG4gIH1cblxuICAhdG9rZW4uaXNMaW5lSG9sZGVyICYmIG5lZWREcmF3QmFja2dyb3VuZCh0b2tlblN0eWxlKSAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgdG9rZW5TdHlsZSwgdGV4dEFsaWduID09PSAncmlnaHQnID8geCAtIHRva2VuLndpZHRoIDogdGV4dEFsaWduID09PSAnY2VudGVyJyA/IHggLSB0b2tlbi53aWR0aCAvIDIgOiB4LCB5IC0gdG9rZW4uaGVpZ2h0IC8gMiwgdG9rZW4ud2lkdGgsIHRva2VuLmhlaWdodCk7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHRva2VuLnRleHRQYWRkaW5nO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIHggPSBnZXRUZXh0WEZvclBhZGRpbmcoeCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZyk7XG4gICAgeSAtPSB0b2tlbi5oZWlnaHQgLyAyIC0gdGV4dFBhZGRpbmdbMl0gLSB0b2tlbi50ZXh0SGVpZ2h0IC8gMjtcbiAgfVxuXG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd0JsdXIsIHN0eWxlLnRleHRTaGFkb3dCbHVyLCAwKSk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHRva2VuU3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8IHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCwgc3R5bGUudGV4dFNoYWRvd09mZnNldFgsIDApKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSwgc3R5bGUudGV4dFNoYWRvd09mZnNldFksIDApKTtcbiAgc2V0Q3R4KGN0eCwgJ3RleHRBbGlnbicsIHRleHRBbGlnbik7IC8vIEZvcmNlIGJhc2VsaW5lIHRvIGJlIFwibWlkZGxlXCIuIE90aGVyd2lzZSwgaWYgdXNpbmcgXCJ0b3BcIiwgdGhlXG4gIC8vIHRleHQgd2lsbCBvZmZzZXQgZG93bndhcmQgYSBsaXR0bGUgYml0IGluIGZvbnQgXCJNaWNyb3NvZnQgWWFIZWlcIi5cblxuICBzZXRDdHgoY3R4LCAndGV4dEJhc2VsaW5lJywgJ21pZGRsZScpO1xuICBzZXRDdHgoY3R4LCAnZm9udCcsIHRva2VuLmZvbnQgfHwgdGV4dENvbnRhaW4uREVGQVVMVF9GT05UKTtcbiAgdmFyIHRleHRTdHJva2UgPSBnZXRTdHJva2UodG9rZW5TdHlsZS50ZXh0U3Ryb2tlIHx8IHN0eWxlLnRleHRTdHJva2UsIHRleHRTdHJva2VXaWR0aCk7XG4gIHZhciB0ZXh0RmlsbCA9IGdldEZpbGwodG9rZW5TdHlsZS50ZXh0RmlsbCB8fCBzdHlsZS50ZXh0RmlsbCk7XG4gIHZhciB0ZXh0U3Ryb2tlV2lkdGggPSByZXRyaWV2ZTIodG9rZW5TdHlsZS50ZXh0U3Ryb2tlV2lkdGgsIHN0eWxlLnRleHRTdHJva2VXaWR0aCk7IC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG5cbiAgaWYgKHRleHRTdHJva2UpIHtcbiAgICBzZXRDdHgoY3R4LCAnbGluZVdpZHRoJywgdGV4dFN0cm9rZVdpZHRoKTtcbiAgICBzZXRDdHgoY3R4LCAnc3Ryb2tlU3R5bGUnLCB0ZXh0U3Ryb2tlKTtcbiAgICBjdHguc3Ryb2tlVGV4dCh0b2tlbi50ZXh0LCB4LCB5KTtcbiAgfVxuXG4gIGlmICh0ZXh0RmlsbCkge1xuICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0RmlsbCk7XG4gICAgY3R4LmZpbGxUZXh0KHRva2VuLnRleHQsIHgsIHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSkge1xuICByZXR1cm4gc3R5bGUudGV4dEJhY2tncm91bmRDb2xvciB8fCBzdHlsZS50ZXh0Qm9yZGVyV2lkdGggJiYgc3R5bGUudGV4dEJvcmRlckNvbG9yO1xufSAvLyBzdHlsZToge3RleHRCYWNrZ3JvdW5kQ29sb3IsIHRleHRCb3JkZXJXaWR0aCwgdGV4dEJvcmRlckNvbG9yLCB0ZXh0Qm9yZGVyUmFkaXVzfVxuLy8gc2hhcGU6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuXG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBzdHlsZS50ZXh0Qm9yZGVyV2lkdGg7XG4gIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBzdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG4gIHZhciBpc1BsYWluQmcgPSBpc1N0cmluZyh0ZXh0QmFja2dyb3VuZENvbG9yKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCBzdHlsZS50ZXh0Qm94U2hhZG93Qmx1ciB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgc3R5bGUudGV4dEJveFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRYIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRZIHx8IDApO1xuXG4gIGlmIChpc1BsYWluQmcgfHwgdGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB2YXIgdGV4dEJvcmRlclJhZGl1cyA9IHN0eWxlLnRleHRCb3JkZXJSYWRpdXM7XG5cbiAgICBpZiAoIXRleHRCb3JkZXJSYWRpdXMpIHtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICByOiB0ZXh0Qm9yZGVyUmFkaXVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cblxuICBpZiAoaXNQbGFpbkJnKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuICAgIGN0eC5maWxsKCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodGV4dEJhY2tncm91bmRDb2xvcikpIHtcbiAgICB2YXIgaW1hZ2UgPSB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlO1xuICAgIGltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShpbWFnZSwgbnVsbCwgaG9zdEVsLCBvbkJnSW1hZ2VMb2FkZWQsIHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuXG4gICAgaWYgKGltYWdlICYmIGltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShpbWFnZSkpIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0ZXh0Qm9yZGVyV2lkdGggJiYgdGV4dEJvcmRlckNvbG9yKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRCb3JkZXJXaWR0aCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dEJvcmRlckNvbG9yKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25CZ0ltYWdlTG9hZGVkKGltYWdlLCB0ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gIC8vIFJlcGxhY2UgaW1hZ2UsIHNvIHRoYXQgYGNvbnRhaW4vdGV4dC5qcyNwYXJzZVJpY2hUZXh0YFxuICAvLyB3aWxsIGdldCBjb3JyZWN0IHJlc3VsdCBpbiBuZXh0IHRpY2suXG4gIHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2UgPSBpbWFnZTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm94UG9zaXRpb24oYmxvY2tIZWlodCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGJhc2VYID0gc3R5bGUueCB8fCAwO1xuICB2YXIgYmFzZVkgPSBzdHlsZS55IHx8IDA7XG4gIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG5cbiAgaWYgKHJlY3QpIHtcbiAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuXG4gICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAvLyBQZXJjZW50XG4gICAgICBiYXNlWCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgYmFzZVkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QodGV4dFBvc2l0aW9uLCByZWN0LCBzdHlsZS50ZXh0RGlzdGFuY2UpO1xuICAgICAgYmFzZVggPSByZXMueDtcbiAgICAgIGJhc2VZID0gcmVzLnk7IC8vIERlZmF1bHQgYWxpZ24gYW5kIGJhc2VsaW5lIHdoZW4gaGFzIHRleHRQb3NpdGlvblxuXG4gICAgICB0ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gfHwgcmVzLnRleHRBbGlnbjtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFZlcnRpY2FsQWxpZ24gfHwgcmVzLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgIH0gLy8gdGV4dE9mZnNldCBpcyBvbmx5IHN1cHBvcnQgaW4gUmVjdFRleHQsIG90aGVyd2lzZVxuICAgIC8vIHdlIGhhdmUgdG8gYWRqdXN0IGJvdW5kaW5nUmVjdCBmb3IgdGV4dE9mZnNldC5cblxuXG4gICAgdmFyIHRleHRPZmZzZXQgPSBzdHlsZS50ZXh0T2Zmc2V0O1xuXG4gICAgaWYgKHRleHRPZmZzZXQpIHtcbiAgICAgIGJhc2VYICs9IHRleHRPZmZzZXRbMF07XG4gICAgICBiYXNlWSArPSB0ZXh0T2Zmc2V0WzFdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFzZVg6IGJhc2VYLFxuICAgIGJhc2VZOiBiYXNlWSxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgfTtcbn1cblxuZnVuY3Rpb24gc2V0Q3R4KGN0eCwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gRklYTUUgPz8/IHBlcmZvcm1hbmNlIHRyeVxuICAvLyBpZiAoY3R4Ll9fY3VycmVudFZhbHVlc1twcm9wXSAhPT0gdmFsdWUpIHtcbiAgLy8gY3R4W3Byb3BdID0gY3R4Ll9fY3VycmVudFZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICBjdHhbcHJvcF0gPSB2YWx1ZTsgLy8gfVxuXG4gIHJldHVybiBjdHhbcHJvcF07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3Ryb2tlXSBJZiBzcGVjaWZpZWQsIGRvIG5vdCBjaGVjayBzdHlsZS50ZXh0U3Ryb2tlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtsaW5lV2lkdGhdIElmIHNwZWNpZmllZCwgZG8gbm90IGNoZWNrIHN0eWxlLnRleHRTdHJva2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3R5bGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFN0cm9rZShzdHJva2UsIGxpbmVXaWR0aCkge1xuICByZXR1cm4gc3Ryb2tlID09IG51bGwgfHwgbGluZVdpZHRoIDw9IDAgfHwgc3Ryb2tlID09PSAndHJhbnNwYXJlbnQnIHx8IHN0cm9rZSA9PT0gJ25vbmUnID8gbnVsbCAvLyBUT0RPIHBhdHRlcm4gYW5kIGdyYWRpZW50P1xuICA6IHN0cm9rZS5pbWFnZSB8fCBzdHJva2UuY29sb3JTdG9wcyA/ICcjMDAwJyA6IHN0cm9rZTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsbChmaWxsKSB7XG4gIHJldHVybiBmaWxsID09IG51bGwgfHwgZmlsbCA9PT0gJ25vbmUnID8gbnVsbCAvLyBUT0RPIHBhdHRlcm4gYW5kIGdyYWRpZW50P1xuICA6IGZpbGwuaW1hZ2UgfHwgZmlsbC5jb2xvclN0b3BzID8gJyMwMDAnIDogZmlsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQZXJjZW50KHZhbHVlLCBtYXhWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIG1heFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dFhGb3JQYWRkaW5nKHgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpIHtcbiAgcmV0dXJuIHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyA/IHggLSB0ZXh0UGFkZGluZ1sxXSA6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcicgPyB4ICsgdGV4dFBhZGRpbmdbM10gLyAyIC0gdGV4dFBhZGRpbmdbMV0gLyAyIDogeCArIHRleHRQYWRkaW5nWzNdO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdHlsZX0gc3R5bGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBuZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpIHtcbiAgcmV0dXJuIHRleHQgIT0gbnVsbCAmJiAodGV4dCB8fCBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIHx8IHN0eWxlLnRleHRCb3JkZXJXaWR0aCAmJiBzdHlsZS50ZXh0Qm9yZGVyQ29sb3IgfHwgc3R5bGUudGV4dFBhZGRpbmcpO1xufVxuXG5leHBvcnRzLm5vcm1hbGl6ZVRleHRTdHlsZSA9IG5vcm1hbGl6ZVRleHRTdHlsZTtcbmV4cG9ydHMucmVuZGVyVGV4dCA9IHJlbmRlclRleHQ7XG5leHBvcnRzLmdldFN0cm9rZSA9IGdldFN0cm9rZTtcbmV4cG9ydHMuZ2V0RmlsbCA9IGdldEZpbGw7XG5leHBvcnRzLm5lZWREcmF3VGV4dCA9IG5lZWREcmF3VGV4dDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci90ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci90ZXh0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3RleHRcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8qKlxuICogTWl4aW4gZm9yIGRyYXdpbmcgdGV4dCBpbiBhIGVsZW1lbnQgYm91bmRpbmcgcmVjdFxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1JlY3RUZXh0XG4gKi9cbnZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG52YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuUmVjdFRleHQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmVjdFRleHQsXG5cbiAgLyoqXG4gICAqIERyYXcgdGV4dCBpbiBhIHJlY3Qgd2l0aCBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAqL1xuICBkcmF3UmVjdFRleHQ6IGZ1bmN0aW9uIChjdHgsIHJlY3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHJlY3QgPSBzdHlsZS50ZXh0UmVjdCB8fCByZWN0OyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRklYTUVcblxuXG4gICAgY3R4LnNhdmUoKTsgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gICAgaWYgKCFzdHlsZS50cmFuc2Zvcm1UZXh0KSB7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICByZWN0ID0gdG1wUmVjdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICB9IC8vIHRyYW5zZm9ybVRleHQgYW5kIHRleHRSb3RhdGlvbiBjYW4gbm90IGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cblxuXG4gICAgdGV4dEhlbHBlci5yZW5kZXJUZXh0KHRoaXMsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBSZWN0VGV4dDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG5bynXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9BcmNcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnYXJjJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgX2N1cnZlID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvY3VydmVcIik7XG5cbnZhciBxdWFkcmF0aWNTdWJkaXZpZGUgPSBfY3VydmUucXVhZHJhdGljU3ViZGl2aWRlO1xudmFyIGN1YmljU3ViZGl2aWRlID0gX2N1cnZlLmN1YmljU3ViZGl2aWRlO1xudmFyIHF1YWRyYXRpY0F0ID0gX2N1cnZlLnF1YWRyYXRpY0F0O1xudmFyIGN1YmljQXQgPSBfY3VydmUuY3ViaWNBdDtcbnZhciBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBfY3VydmUucXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xudmFyIGN1YmljRGVyaXZhdGl2ZUF0ID0gX2N1cnZlLmN1YmljRGVyaXZhdGl2ZUF0O1xuXG4vKipcbiAqIOi0neWhnuWwlOabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0JlemllckN1cnZlXG4gKi9cbnZhciBvdXQgPSBbXTtcblxuZnVuY3Rpb24gc29tZVZlY3RvckF0KHNoYXBlLCB0LCBpc1RhbmdlbnQpIHtcbiAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG5cbiAgaWYgKGNweDIgPT09IG51bGwgfHwgY3B5MiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLmNweDIsIHNoYXBlLngyLCB0KSwgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLmNweTIsIHNoYXBlLnkyLCB0KV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFsoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS54MiwgdCksIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLnkyLCB0KV07XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnYmV6aWVyLWN1cnZlJyxcbiAgc2hhcGU6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB4MjogMCxcbiAgICB5MjogMCxcbiAgICBjcHgxOiAwLFxuICAgIGNweTE6IDAsXG4gICAgLy8gY3B4MjogMCxcbiAgICAvLyBjcHkyOiAwXG4gICAgLy8gQ3VydmUgc2hvdyBwZXJjZW50LCBmb3IgYW5pbWF0aW5nXG4gICAgcGVyY2VudDogMVxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgIHZhciBjcHgxID0gc2hhcGUuY3B4MTtcbiAgICB2YXIgY3B5MSA9IHNoYXBlLmNweTE7XG4gICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgIGlmIChjcHgyID09IG51bGwgfHwgY3B5MiA9PSBudWxsKSB7XG4gICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHgxLCBjcHgxLCB4MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgeDIgPSBvdXRbMl07XG4gICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZSh5MSwgY3B5MSwgeTIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgIHkyID0gb3V0WzJdO1xuICAgICAgfVxuXG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjcHgxLCBjcHkxLCB4MiwgeTIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgY3ViaWNTdWJkaXZpZGUoeDEsIGNweDEsIGNweDIsIHgyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICBjcHgyID0gb3V0WzJdO1xuICAgICAgICB4MiA9IG91dFszXTtcbiAgICAgICAgY3ViaWNTdWJkaXZpZGUoeTEsIGNweTEsIGNweTIsIHkyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICBjcHkyID0gb3V0WzJdO1xuICAgICAgICB5MiA9IG91dFszXTtcbiAgICAgIH1cblxuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgeDIsIHkyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHBvaW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0YW5nZW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGFuZ2VudEF0OiBmdW5jdGlvbiAodCkge1xuICAgIHZhciBwID0gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIHRydWUpO1xuICAgIHJldHVybiB2ZWMyLm5vcm1hbGl6ZShwLCBwKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQ2lyY2xlXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2NpcmNsZScsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgIC8vIEFsd2F5cyBkbyBpdCBtYXkgaGF2ZSBwZXJmb3JtZW5jZSBpc3N1ZSAoIGZpbGwgbWF5IGJlIDJ4IG1vcmUgY29zdClcbiAgICBpZiAoaW5CdW5kbGUpIHtcbiAgICAgIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG4gICAgfSAvLyBlbHNlIHtcbiAgICAvLyAgICAgaWYgKGN0eC5hbGxvY2F0ZSAmJiAhY3R4LmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gICAgICAgICBjdHguYWxsb2NhdGUoY3R4LkNNRF9NRU1fU0laRS5BKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cbiAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAvLyBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuXG5cbiAgICBjdHguYXJjKHNoYXBlLmN4LCBzaGFwZS5jeSwgc2hhcGUuciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOebtOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZVxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICAvLyBTdGFydCBwb2ludFxuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIC8vIEVuZCBwb2ludFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIHBlcmNlbnQ6IDFcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgeDIgPSB4MSAqICgxIC0gcGVyY2VudCkgKyB4MiAqIHBlcmNlbnQ7XG4gICAgICB5MiA9IHkxICogKDEgLSBwZXJjZW50KSArIHkyICogcGVyY2VudDtcbiAgICB9XG5cbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHBvaW50QXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICByZXR1cm4gW3NoYXBlLngxICogKDEgLSBwKSArIHNoYXBlLngyICogcCwgc2hhcGUueTEgKiAoMSAtIHApICsgc2hhcGUueTIgKiBwXTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvcG9seVwiKTtcblxuLyoqXG4gKiDlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Qb2x5Z29uXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3BvbHlnb24nLFxuICBzaGFwZToge1xuICAgIHBvaW50czogbnVsbCxcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBwb2x5SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9wb2x5XCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3BvbHlsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IG51bGwsXG4gICAgc21vb3RoOiBmYWxzZSxcbiAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgZmFsc2UpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHJvdW5kUmVjdEhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvcm91bmRSZWN0XCIpO1xuXG4vKipcbiAqIOefqeW9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmVjdFxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdyZWN0JyxcbiAgc2hhcGU6IHtcbiAgICAvLyDlt6bkuIrjgIHlj7PkuIrjgIHlj7PkuIvjgIHlt6bkuIvop5LnmoTljYrlvoTkvp3mrKHkuLpyMeOAgXIy44CBcjPjgIFyNFxuICAgIC8vIHLnvKnlhpnkuLoxICAgICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgIC8vIHLnvKnlhpnkuLpbMSwgMl0gICAg55u45b2T5LqOIFsxLCAyLCAxLCAyXVxuICAgIC8vIHLnvKnlhpnkuLpbMSwgMiwgM10g55u45b2T5LqOIFsxLCAyLCAzLCAyXVxuICAgIHI6IDAsXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS54O1xuICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuXG4gICAgaWYgKCFzaGFwZS5yKSB7XG4gICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG546vXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SaW5nXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3JpbmcnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDAsXG4gICAgcjA6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yLCAwLCBQSTIsIGZhbHNlKTtcbiAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yMCwgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgZml4Q2xpcFdpdGhTaGFkb3cgPSByZXF1aXJlKFwiLi4vaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93XCIpO1xuXG4vKipcbiAqIOaJh+W9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvU2VjdG9yXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3NlY3RvcicsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjA6IDAsXG4gICAgcjogMCxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcbiAgICBjbG9ja3dpc2U6IHRydWVcbiAgfSxcbiAgYnJ1c2g6IGZpeENsaXBXaXRoU2hhZG93KFBhdGgucHJvdG90eXBlLmJydXNoKSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgcjAgPSBNYXRoLm1heChzaGFwZS5yMCB8fCAwLCAwKTtcbiAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC5tb3ZlVG8odW5pdFggKiByMCArIHgsIHVuaXRZICogcjAgKyB5KTtcbiAgICBjdHgubGluZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICAgIGN0eC5saW5lVG8oTWF0aC5jb3MoZW5kQW5nbGUpICogcjAgKyB4LCBNYXRoLnNpbihlbmRBbmdsZSkgKiByMCArIHkpO1xuXG4gICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICBjdHguYXJjKHgsIHksIHIwLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgY2xvY2t3aXNlKTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBBbmltYXRvciA9IHJlcXVpcmUoXCIuLi9hbmltYXRpb24vQW5pbWF0b3JcIik7XG5cbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vY29yZS9sb2dcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBfdXRpbC5pc0Z1bmN0aW9uO1xudmFyIGlzT2JqZWN0ID0gX3V0aWwuaXNPYmplY3Q7XG52YXIgaXNBcnJheUxpa2UgPSBfdXRpbC5pc0FycmF5TGlrZTtcbnZhciBpbmRleE9mID0gX3V0aWwuaW5kZXhPZjtcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEFuaW1hdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcj59XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgdGhpcy5hbmltYXRvcnMgPSBbXTtcbn07XG5cbkFuaW1hdGFibGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQW5pbWF0YWJsZSxcblxuICAvKipcbiAgICog5Yqo55S7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGZldGNoIHZhbHVlIGZyb20gb2JqZWN0LCBsaWtlICdhLmIuYycuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvb3BdIFdoZXRoZXIgdG8gbG9vcCBhbmltYXRpb24uXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICogQGV4YW1wbGU6XG4gICAqICAgICBlbC5hbmltYXRlKCdzdHlsZScsIGZhbHNlKVxuICAgKiAgICAgICAgIC53aGVuKDEwMDAsIHt4OiAxMH0gKVxuICAgKiAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCl7IC8vIEFuaW1hdGlvbiBkb25lIH0pXG4gICAqICAgICAgICAgLnN0YXJ0KClcbiAgICovXG4gIGFuaW1hdGU6IGZ1bmN0aW9uIChwYXRoLCBsb29wKSB7XG4gICAgdmFyIHRhcmdldDtcbiAgICB2YXIgYW5pbWF0aW5nU2hhcGUgPSBmYWxzZTtcbiAgICB2YXIgZWwgPSB0aGlzO1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICB2YXIgcGF0aFNwbGl0dGVkID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgdmFyIHByb3AgPSBlbDsgLy8gSWYgYW5pbWF0aW5nIHNoYXBlXG5cbiAgICAgIGFuaW1hdGluZ1NoYXBlID0gcGF0aFNwbGl0dGVkWzBdID09PSAnc2hhcGUnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhTcGxpdHRlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wID0gcHJvcFtwYXRoU3BsaXR0ZWRbaV1dO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcCkge1xuICAgICAgICB0YXJnZXQgPSBwcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQgPSBlbDtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgbG9nKCdQcm9wZXJ0eSBcIicgKyBwYXRoICsgJ1wiIGlzIG5vdCBleGlzdGVkIGluIGVsZW1lbnQgJyArIGVsLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gZWwuYW5pbWF0b3JzO1xuICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIGxvb3ApO1xuICAgIGFuaW1hdG9yLmR1cmluZyhmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBlbC5kaXJ0eShhbmltYXRpbmdTaGFwZSk7XG4gICAgfSkuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBGSVhNRSBBbmltYXRvciB3aWxsIG5vdCBiZSByZW1vdmVkIGlmIHVzZSBgQW5pbWF0b3Ijc3RvcGAgdG8gc3RvcCBhbmltYXRpb25cbiAgICAgIGFuaW1hdG9ycy5zcGxpY2UoaW5kZXhPZihhbmltYXRvcnMsIGFuaW1hdG9yKSwgMSk7XG4gICAgfSk7XG4gICAgYW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpOyAvLyBJZiBhbmltYXRlIGFmdGVyIGFkZGVkIHRvIHRoZSB6cmVuZGVyXG5cbiAgICBpZiAoenIpIHtcbiAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdG9yO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlgZzmraLliqjnlLtcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgKi9cbiAgc3RvcEFuaW1hdGlvbjogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgdmFyIGxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhbmltYXRvcnNbaV0uc3RvcChmb3J3YXJkVG9MYXN0KTtcbiAgICB9XG5cbiAgICBhbmltYXRvcnMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ2F1dGlvbjogdGhpcyBtZXRob2Qgd2lsbCBzdG9wIHByZXZpb3VzIGFuaW1hdGlvbi5cbiAgICogU28gZG8gbm90IHVzZSB0aGlzIG1ldGhvZCB0byBvbmUgZWxlbWVudCB0d2ljZSBiZWZvcmVcbiAgICogYW5pbWF0aW9uIHN0YXJ0cywgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXSBUaW1lIGluIG1zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZWFzaW5nPSdsaW5lYXInXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZvcmNlQW5pbWF0ZV0gUHJldmVudCBzdG9wIGFuaW1hdGlvbiBhbmQgY2FsbGJhY2tcbiAgICogICAgICAgIGltbWVkaWVudGx5IHdoZW4gdGFyZ2V0IHZhbHVlcyBhcmUgdGhlIHNhbWUgYXMgY3VycmVudCB2YWx1ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAqICBlbC5hbmltYXRlVG8oe1xuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSwgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAqXG4gICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXMsIHdpdGggY3ViaWNPdXQgZWFzaW5nXG4gICAqICBlbC5hbmltYXRlVG8oe1xuICAgKiAgICAgIHNoYXBlOiB7XG4gICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICogICAgICB9LFxuICAgKiAgICAgIHN0eWxlOiB7XG4gICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAqICAgICAgfVxuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSwgMTAwLCAxMDAsICdjdWJpY091dCcsIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgKi9cbiAgLy8gVE9ETyBSZXR1cm4gYW5pbWF0aW9uIGtleVxuICBhbmltYXRlVG86IGZ1bmN0aW9uICh0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrLCBmb3JjZUFuaW1hdGUpIHtcbiAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICBpZiAoaXNTdHJpbmcoZGVsYXkpKSB7XG4gICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgIGVhc2luZyA9IGRlbGF5O1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZGVsYXksIGNhbGxiYWNrKTtcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVhc2luZykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgIGVhc2luZyA9ICdsaW5lYXInO1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZGVsYXkpKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBkZWxheTtcbiAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldCwgY2FsbGJhY2spXG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odGltZSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGltZTtcbiAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0KVxuICAgICAgICAgIGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9IC8vIFN0b3AgYWxsIHByZXZpb3VzIGFuaW1hdGlvbnNcblxuXG4gICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG5cbiAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KCcnLCB0aGlzLCB0YXJnZXQsIHRpbWUsIGRlbGF5KTsgLy8gQW5pbWF0b3JzIG1heSBiZSByZW1vdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gICAgLy8gaWYgdGhlcmUgaXMgbm90aGluZyB0byBhbmltYXRlXG5cblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycy5zbGljZSgpO1xuICAgIHZhciBjb3VudCA9IGFuaW1hdG9ycy5sZW5ndGg7XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgY291bnQtLTtcblxuICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0gLy8gTm8gYW5pbWF0b3JzLiBUaGlzIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBhbmltYXRvcnNbaV0uc3RhcnQoKSxcbiAgICAvLyBiZWNhdXNlICdkb25lJyBtYXkgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgaWYgbm8gbmVlZCB0byBhbmltYXRlLlxuXG5cbiAgICBpZiAoIWNvdW50KSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH0gLy8gU3RhcnQgYWZ0ZXIgYWxsIGFuaW1hdG9ycyBjcmVhdGVkXG4gICAgLy8gSW5jYXNlIGFueSBhbmltYXRvciBpcyBkb25lIGltbWVkaWF0ZWx5IHdoZW4gYWxsIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIGFyZSBub3QgY2hhbmdlZFxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgYW5pbWF0b3JzW2ldLmRvbmUoZG9uZSkuc3RhcnQoZWFzaW5nLCBmb3JjZUFuaW1hdGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGg9JydcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZT10aGlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSlcbiAgICpcbiAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtc1xuICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgKiAgICAgIHNoYXBlOiB7XG4gICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICogICAgICB9LFxuICAgKiAgICAgIHN0eWxlOiB7XG4gICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAqICAgICAgfVxuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSwgMTAwLCAxMDApXG4gICAqL1xuICBfYW5pbWF0ZVRvU2hhbGxvdzogZnVuY3Rpb24gKHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSkge1xuICAgIHZhciBvYmpTaGFsbG93ID0ge307XG4gICAgdmFyIHByb3BlcnR5Q291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldFtuYW1lXSkgJiYgIWlzQXJyYXlMaWtlKHRhcmdldFtuYW1lXSkpIHtcbiAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KHBhdGggPyBwYXRoICsgJy4nICsgbmFtZSA6IG5hbWUsIHNvdXJjZVtuYW1lXSwgdGFyZ2V0W25hbWVdLCB0aW1lLCBkZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqU2hhbGxvd1tuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICBwcm9wZXJ0eUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgLy8gQXR0ciBkaXJlY3RseSBpZiBub3QgaGFzIHByb3BlcnR5XG4gICAgICAgIC8vIEZJWE1FLCBpZiBzb21lIHByb3BlcnR5IG5vdCBuZWVkZWQgZm9yIGVsZW1lbnQgP1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICB0aGlzLmF0dHIobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaGFwZSBvciBzdHlsZVxuICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgIHByb3BzW3BhdGhdID0ge307XG4gICAgICAgICAgcHJvcHNbcGF0aF1bbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgdGhpcy5hdHRyKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eUNvdW50ID4gMCkge1xuICAgICAgdGhpcy5hbmltYXRlKHBhdGgsIGZhbHNlKS53aGVuKHRpbWUgPT0gbnVsbCA/IDUwMCA6IHRpbWUsIG9ialNoYWxsb3cpLmRlbGF5KGRlbGF5IHx8IDApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQW5pbWF0YWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFRPRE8gRHJhZ2dhYmxlIGZvciBncm91cFxuLy8gRklYTUUgRHJhZ2dhYmxlIG9uIGVsZW1lbnQgd2hpY2ggaGFzIHBhcmVudCByb3RhdGlvbiBvciBzY2FsZVxuZnVuY3Rpb24gRHJhZ2dhYmxlKCkge1xuICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9kcmFnU3RhcnQsIHRoaXMpO1xuICB0aGlzLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9kcmFnLCB0aGlzKTtcbiAgdGhpcy5vbignbW91c2V1cCcsIHRoaXMuX2RyYWdFbmQsIHRoaXMpO1xuICB0aGlzLm9uKCdnbG9iYWxvdXQnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTsgLy8gdGhpcy5fZHJvcFRhcmdldCA9IG51bGw7XG4gIC8vIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgLy8gdGhpcy5feCA9IDA7XG4gIC8vIHRoaXMuX3kgPSAwO1xufVxuXG5EcmFnZ2FibGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRHJhZ2dhYmxlLFxuICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICYmIGRyYWdnaW5nVGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldDtcbiAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3ggPSBlLm9mZnNldFg7XG4gICAgICB0aGlzLl95ID0gZS5vZmZzZXRZO1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnc3RhcnQnLCBlLmV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIF9kcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuXG4gICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG4gICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuICAgICAgdmFyIGR4ID0geCAtIHRoaXMuX3g7XG4gICAgICB2YXIgZHkgPSB5IC0gdGhpcy5feTtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICBkcmFnZ2luZ1RhcmdldC5kcmlmdChkeCwgZHksIGUpO1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnJywgZS5ldmVudCk7XG4gICAgICB2YXIgZHJvcFRhcmdldCA9IHRoaXMuZmluZEhvdmVyKHgsIHksIGRyYWdnaW5nVGFyZ2V0KS50YXJnZXQ7XG4gICAgICB2YXIgbGFzdERyb3BUYXJnZXQgPSB0aGlzLl9kcm9wVGFyZ2V0O1xuICAgICAgdGhpcy5fZHJvcFRhcmdldCA9IGRyb3BUYXJnZXQ7XG5cbiAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCAhPT0gZHJvcFRhcmdldCkge1xuICAgICAgICBpZiAobGFzdERyb3BUYXJnZXQgJiYgZHJvcFRhcmdldCAhPT0gbGFzdERyb3BUYXJnZXQpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGxhc3REcm9wVGFyZ2V0LCBlKSwgJ2RyYWdsZWF2ZScsIGUuZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyb3BUYXJnZXQgJiYgZHJvcFRhcmdldCAhPT0gbGFzdERyb3BUYXJnZXQpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyb3BUYXJnZXQsIGUpLCAnZHJhZ2VudGVyJywgZS5ldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9kcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuXG4gICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG4gICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ2VuZCcsIGUuZXZlbnQpO1xuXG4gICAgaWYgKHRoaXMuX2Ryb3BUYXJnZXQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0odGhpcy5fZHJvcFRhcmdldCwgZSksICdkcm9wJywgZS5ldmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJhbSh0YXJnZXQsIGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICB0b3BUYXJnZXQ6IGUgJiYgZS50b3BUYXJnZXRcbiAgfTtcbn1cblxudmFyIF9kZWZhdWx0ID0gRHJhZ2dhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICog5LqL5Lu25omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBhcnJ5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4vKipcbiAqIOS6i+S7tuWIhuWPkeWZqFxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgRXZlbnRmdWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xufTtcblxuRXZlbnRmdWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgLyoqXG4gICAqIOWNleasoeinpuWPkee7keWumu+8jHRyaWdnZXLlkI7plIDmr4FcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICBoOiBoYW5kbGVyLFxuICAgICAgb25lOiB0cnVlLFxuICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnu5Hlrprkuovku7ZcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgaDogaGFuZGxlcixcbiAgICAgIG9uZTogZmFsc2UsXG4gICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcbiAgICByZXR1cm4gX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOino+e7keS6i+S7tlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSDkuovku7blpITnkIblh73mlbBcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFldmVudCkge1xuICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX2hbZXZlbnRdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICBuZXdMaXN0LnB1c2goX2hbZXZlbnRdW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfaFtldmVudF0gPSBuZXdMaXN0O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5LqL5Lu25YiG5Y+RXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgaWYgKGFyZ0xlbiA+IDMpIHtcbiAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnNbdHlwZV07XG4gICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgLy8gT3B0aW1pemUgYWR2aXNlIGZyb20gYmFja2JvbmVcbiAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddLCBhcmdzWzFdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddLCBhcmdzWzFdLCBhcmdzWzJdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gaGF2ZSBtb3JlIHRoYW4gMiBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoX2hbaV1bJ2N0eCddLCBhcmdzKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2hbaV1bJ29uZSddKSB7XG4gICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW4puaciWNvbnRleHTnmoTkuovku7bliIblj5EsIOacgOWQjuS4gOS4quWPguaVsOaYr+S6i+S7tuWbnuiwg+eahGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAqL1xuICB0cmlnZ2VyV2l0aENvbnRleHQ6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICBfaFtpXVsnaCddLmFwcGx5KGN0eCwgYXJncyk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59OyAvLyDlr7nosaHlj6/ku6XpgJrov4cgb254eHh4IOe7keWumuS6i+S7tlxuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmNsaWNrXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW92ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3V0XG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW1vdmVcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNld2hlZWxcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlZG93blxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V1cFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ3N0YXJ0XG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW5kXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW50ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdsZWF2ZVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ292ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyb3BcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG52YXIgX2RlZmF1bHQgPSBFdmVudGZ1bDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuLi9jb3JlL21hdHJpeFwiKTtcblxudmFyIHZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxuLyoqXG4gKiDmj5Dkvpvlj5jmjaLmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1JZGVudGl0eSA9IG1hdHJpeC5pZGVudGl0eTtcbnZhciBFUFNJTE9OID0gNWUtNTtcblxuZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFRyYW5zZm9ybWFibGUgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTsgLy8gSWYgdGhlcmUgYXJlIG5vIGdpdmVuIHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGVcblxuICBpZiAoIW9wdHMucG9zaXRpb24pIHtcbiAgICAvKipcbiAgICAgKiDlubPnp7tcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgWzAsIDBdXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IFswLCAwXTtcbiAgfVxuXG4gIGlmIChvcHRzLnJvdGF0aW9uID09IG51bGwpIHtcbiAgICAvKipcbiAgICAgKiDml4vovaxcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICB9XG5cbiAgaWYgKCFvcHRzLnNjYWxlKSB7XG4gICAgLyoqXG4gICAgICog57yp5pS+XG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBkZWZhdWx0IFsxLCAxXVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSBbMSwgMV07XG4gIH1cbiAgLyoqXG4gICAqIOaXi+i9rOWSjOe8qeaUvueahOWOn+eCuVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG5cblxuICB0aGlzLm9yaWdpbiA9IHRoaXMub3JpZ2luIHx8IG51bGw7XG59O1xuXG52YXIgdHJhbnNmb3JtYWJsZVByb3RvID0gVHJhbnNmb3JtYWJsZS5wcm90b3R5cGU7XG50cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtID0gbnVsbDtcbi8qKlxuICog5Yik5pat5piv5ZCm6ZyA6KaB5pyJ5Z2Q5qCH5Y+Y5o2iXG4gKiDlpoLmnpzmnInlnZDmoIflj5jmjaIsIOWImeS7jnBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGXku6Xlj4rniLboioLngrnnmoR0cmFuc2Zvcm3orqHnrpflh7roh6rouqvnmoR0cmFuc2Zvcm3nn6npmLVcbiAqL1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8ubmVlZExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNOb3RBcm91bmRaZXJvKHRoaXMucm90YXRpb24pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzBdKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblsxXSkgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMF0gLSAxKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVsxXSAtIDEpO1xufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICB2YXIgcGFyZW50SGFzVHJhbnNmb3JtID0gcGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm07XG4gIHZhciBuZWVkTG9jYWxUcmFuc2Zvcm0gPSB0aGlzLm5lZWRMb2NhbFRyYW5zZm9ybSgpO1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICghKG5lZWRMb2NhbFRyYW5zZm9ybSB8fCBwYXJlbnRIYXNUcmFuc2Zvcm0pKSB7XG4gICAgbSAmJiBtSWRlbnRpdHkobSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbSA9IG0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuXG4gIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLmdldExvY2FsVHJhbnNmb3JtKG0pO1xuICB9IGVsc2Uge1xuICAgIG1JZGVudGl0eShtKTtcbiAgfSAvLyDlupTnlKjniLboioLngrnlj5jmjaJcblxuXG4gIGlmIChwYXJlbnRIYXNUcmFuc2Zvcm0pIHtcbiAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICBtYXRyaXgubXVsKG0sIHBhcmVudC50cmFuc2Zvcm0sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRyaXguY29weShtLCBwYXJlbnQudHJhbnNmb3JtKTtcbiAgICB9XG4gIH0gLy8g5L+d5a2Y6L+Z5Liq5Y+Y5o2i55+p6Zi1XG5cblxuICB0aGlzLnRyYW5zZm9ybSA9IG07XG4gIHRoaXMuaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuICBtYXRyaXguaW52ZXJ0KHRoaXMuaW52VHJhbnNmb3JtLCBtKTtcbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gIHJldHVybiBUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKHRoaXMsIG0pO1xufTtcbi8qKlxuICog5bCG6Ieq5bex55qEdHJhbnNmb3Jt5bqU55So5YiwY29udGV4dOS4ilxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcblxuICBpZiAobSkge1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByICogbVswXSwgZHByICogbVsxXSwgZHByICogbVsyXSwgZHByICogbVszXSwgZHByICogbVs0XSwgZHByICogbVs1XSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG4gIH1cbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by5yZXN0b3JlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbn07XG5cbnZhciB0bXBUcmFuc2Zvcm0gPSBbXTtcbi8qKlxuICog5YiG6KejYHRyYW5zZm9ybWDnn6npmLXliLBgcG9zaXRpb25gLCBgcm90YXRpb25gLCBgc2NhbGVgXG4gKi9cblxudHJhbnNmb3JtYWJsZVByb3RvLmRlY29tcG9zZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRyYW5zZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm0pIHtcbiAgICAvLyBHZXQgbG9jYWwgdHJhbnNmb3JtIGFuZCBkZWNvbXBvc2UgdGhlbSB0byBwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uXG4gICAgbWF0cml4Lm11bCh0bXBUcmFuc2Zvcm0sIHBhcmVudC5pbnZUcmFuc2Zvcm0sIG0pO1xuICAgIG0gPSB0bXBUcmFuc2Zvcm07XG4gIH1cblxuICB2YXIgc3ggPSBtWzBdICogbVswXSArIG1bMV0gKiBtWzFdO1xuICB2YXIgc3kgPSBtWzJdICogbVsyXSArIG1bM10gKiBtWzNdO1xuICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gIGlmIChpc05vdEFyb3VuZFplcm8oc3ggLSAxKSkge1xuICAgIHN4ID0gTWF0aC5zcXJ0KHN4KTtcbiAgfVxuXG4gIGlmIChpc05vdEFyb3VuZFplcm8oc3kgLSAxKSkge1xuICAgIHN5ID0gTWF0aC5zcXJ0KHN5KTtcbiAgfVxuXG4gIGlmIChtWzBdIDwgMCkge1xuICAgIHN4ID0gLXN4O1xuICB9XG5cbiAgaWYgKG1bM10gPCAwKSB7XG4gICAgc3kgPSAtc3k7XG4gIH1cblxuICBwb3NpdGlvblswXSA9IG1bNF07XG4gIHBvc2l0aW9uWzFdID0gbVs1XTtcbiAgc2NhbGVbMF0gPSBzeDtcbiAgc2NhbGVbMV0gPSBzeTtcbiAgdGhpcy5yb3RhdGlvbiA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbn07XG4vKipcbiAqIEdldCBnbG9iYWwgc2NhbGVcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICghbSkge1xuICAgIHJldHVybiBbMSwgMV07XG4gIH1cblxuICB2YXIgc3ggPSBNYXRoLnNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gIHZhciBzeSA9IE1hdGguc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcblxuICBpZiAobVswXSA8IDApIHtcbiAgICBzeCA9IC1zeDtcbiAgfVxuXG4gIGlmIChtWzNdIDwgMCkge1xuICAgIHN5ID0gLXN5O1xuICB9XG5cbiAgcmV0dXJuIFtzeCwgc3ldO1xufTtcbi8qKlxuICog5Y+Y5o2i5Z2Q5qCH5L2N572u5YiwIHNoYXBlIOeahOWxgOmDqOWdkOagh+epuumXtFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvTG9jYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgdjIgPSBbeCwgeV07XG4gIHZhciBpbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybTtcblxuICBpZiAoaW52VHJhbnNmb3JtKSB7XG4gICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgaW52VHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2Mjtcbn07XG4vKipcbiAqIOWPmOaNouWxgOmDqOWdkOagh+S9jee9ruWIsOWFqOWxgOWdkOagh+epuumXtFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdmFyIHYyID0gW3gsIHldO1xuICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIHRyYW5zZm9ybSk7XG4gIH1cblxuICByZXR1cm4gdjI7XG59O1xuLyoqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQub3JpZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0LnJvdGF0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQucG9zaXRpb25cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFttXVxuICovXG5cblxuVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIG0pIHtcbiAgbSA9IG0gfHwgW107XG4gIG1JZGVudGl0eShtKTtcbiAgdmFyIG9yaWdpbiA9IHRhcmdldC5vcmlnaW47XG4gIHZhciBzY2FsZSA9IHRhcmdldC5zY2FsZSB8fCBbMSwgMV07XG4gIHZhciByb3RhdGlvbiA9IHRhcmdldC5yb3RhdGlvbiB8fCAwO1xuICB2YXIgcG9zaXRpb24gPSB0YXJnZXQucG9zaXRpb24gfHwgWzAsIDBdO1xuXG4gIGlmIChvcmlnaW4pIHtcbiAgICAvLyBUcmFuc2xhdGUgdG8gb3JpZ2luXG4gICAgbVs0XSAtPSBvcmlnaW5bMF07XG4gICAgbVs1XSAtPSBvcmlnaW5bMV07XG4gIH1cblxuICBtYXRyaXguc2NhbGUobSwgbSwgc2NhbGUpO1xuXG4gIGlmIChyb3RhdGlvbikge1xuICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgcm90YXRpb24pO1xuICB9XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIC8vIFRyYW5zbGF0ZSBiYWNrIGZyb20gb3JpZ2luXG4gICAgbVs0XSArPSBvcmlnaW5bMF07XG4gICAgbVs1XSArPSBvcmlnaW5bMV07XG4gIH1cblxuICBtWzRdICs9IHBvc2l0aW9uWzBdO1xuICBtWzVdICs9IHBvc2l0aW9uWzFdO1xuICByZXR1cm4gbTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFRyYW5zZm9ybWFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgTFJVID0gcmVxdWlyZShcIi4uL2NvcmUvTFJVXCIpO1xuXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICd0cmFuc3BhcmVudCc6IFswLCAwLCAwLCAwXSxcbiAgJ2FsaWNlYmx1ZSc6IFsyNDAsIDI0OCwgMjU1LCAxXSxcbiAgJ2FudGlxdWV3aGl0ZSc6IFsyNTAsIDIzNSwgMjE1LCAxXSxcbiAgJ2FxdWEnOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAnYXF1YW1hcmluZSc6IFsxMjcsIDI1NSwgMjEyLCAxXSxcbiAgJ2F6dXJlJzogWzI0MCwgMjU1LCAyNTUsIDFdLFxuICAnYmVpZ2UnOiBbMjQ1LCAyNDUsIDIyMCwgMV0sXG4gICdiaXNxdWUnOiBbMjU1LCAyMjgsIDE5NiwgMV0sXG4gICdibGFjayc6IFswLCAwLCAwLCAxXSxcbiAgJ2JsYW5jaGVkYWxtb25kJzogWzI1NSwgMjM1LCAyMDUsIDFdLFxuICAnYmx1ZSc6IFswLCAwLCAyNTUsIDFdLFxuICAnYmx1ZXZpb2xldCc6IFsxMzgsIDQzLCAyMjYsIDFdLFxuICAnYnJvd24nOiBbMTY1LCA0MiwgNDIsIDFdLFxuICAnYnVybHl3b29kJzogWzIyMiwgMTg0LCAxMzUsIDFdLFxuICAnY2FkZXRibHVlJzogWzk1LCAxNTgsIDE2MCwgMV0sXG4gICdjaGFydHJldXNlJzogWzEyNywgMjU1LCAwLCAxXSxcbiAgJ2Nob2NvbGF0ZSc6IFsyMTAsIDEwNSwgMzAsIDFdLFxuICAnY29yYWwnOiBbMjU1LCAxMjcsIDgwLCAxXSxcbiAgJ2Nvcm5mbG93ZXJibHVlJzogWzEwMCwgMTQ5LCAyMzcsIDFdLFxuICAnY29ybnNpbGsnOiBbMjU1LCAyNDgsIDIyMCwgMV0sXG4gICdjcmltc29uJzogWzIyMCwgMjAsIDYwLCAxXSxcbiAgJ2N5YW4nOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAnZGFya2JsdWUnOiBbMCwgMCwgMTM5LCAxXSxcbiAgJ2RhcmtjeWFuJzogWzAsIDEzOSwgMTM5LCAxXSxcbiAgJ2Rhcmtnb2xkZW5yb2QnOiBbMTg0LCAxMzQsIDExLCAxXSxcbiAgJ2RhcmtncmF5JzogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAnZGFya2dyZWVuJzogWzAsIDEwMCwgMCwgMV0sXG4gICdkYXJrZ3JleSc6IFsxNjksIDE2OSwgMTY5LCAxXSxcbiAgJ2RhcmtraGFraSc6IFsxODksIDE4MywgMTA3LCAxXSxcbiAgJ2RhcmttYWdlbnRhJzogWzEzOSwgMCwgMTM5LCAxXSxcbiAgJ2RhcmtvbGl2ZWdyZWVuJzogWzg1LCAxMDcsIDQ3LCAxXSxcbiAgJ2RhcmtvcmFuZ2UnOiBbMjU1LCAxNDAsIDAsIDFdLFxuICAnZGFya29yY2hpZCc6IFsxNTMsIDUwLCAyMDQsIDFdLFxuICAnZGFya3JlZCc6IFsxMzksIDAsIDAsIDFdLFxuICAnZGFya3NhbG1vbic6IFsyMzMsIDE1MCwgMTIyLCAxXSxcbiAgJ2RhcmtzZWFncmVlbic6IFsxNDMsIDE4OCwgMTQzLCAxXSxcbiAgJ2RhcmtzbGF0ZWJsdWUnOiBbNzIsIDYxLCAxMzksIDFdLFxuICAnZGFya3NsYXRlZ3JheSc6IFs0NywgNzksIDc5LCAxXSxcbiAgJ2RhcmtzbGF0ZWdyZXknOiBbNDcsIDc5LCA3OSwgMV0sXG4gICdkYXJrdHVycXVvaXNlJzogWzAsIDIwNiwgMjA5LCAxXSxcbiAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LCAwLCAyMTEsIDFdLFxuICAnZGVlcHBpbmsnOiBbMjU1LCAyMCwgMTQ3LCAxXSxcbiAgJ2RlZXBza3libHVlJzogWzAsIDE5MSwgMjU1LCAxXSxcbiAgJ2RpbWdyYXknOiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICdkaW1ncmV5JzogWzEwNSwgMTA1LCAxMDUsIDFdLFxuICAnZG9kZ2VyYmx1ZSc6IFszMCwgMTQ0LCAyNTUsIDFdLFxuICAnZmlyZWJyaWNrJzogWzE3OCwgMzQsIDM0LCAxXSxcbiAgJ2Zsb3JhbHdoaXRlJzogWzI1NSwgMjUwLCAyNDAsIDFdLFxuICAnZm9yZXN0Z3JlZW4nOiBbMzQsIDEzOSwgMzQsIDFdLFxuICAnZnVjaHNpYSc6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICdnYWluc2Jvcm8nOiBbMjIwLCAyMjAsIDIyMCwgMV0sXG4gICdnaG9zdHdoaXRlJzogWzI0OCwgMjQ4LCAyNTUsIDFdLFxuICAnZ29sZCc6IFsyNTUsIDIxNSwgMCwgMV0sXG4gICdnb2xkZW5yb2QnOiBbMjE4LCAxNjUsIDMyLCAxXSxcbiAgJ2dyYXknOiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICdncmVlbic6IFswLCAxMjgsIDAsIDFdLFxuICAnZ3JlZW55ZWxsb3cnOiBbMTczLCAyNTUsIDQ3LCAxXSxcbiAgJ2dyZXknOiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICdob25leWRldyc6IFsyNDAsIDI1NSwgMjQwLCAxXSxcbiAgJ2hvdHBpbmsnOiBbMjU1LCAxMDUsIDE4MCwgMV0sXG4gICdpbmRpYW5yZWQnOiBbMjA1LCA5MiwgOTIsIDFdLFxuICAnaW5kaWdvJzogWzc1LCAwLCAxMzAsIDFdLFxuICAnaXZvcnknOiBbMjU1LCAyNTUsIDI0MCwgMV0sXG4gICdraGFraSc6IFsyNDAsIDIzMCwgMTQwLCAxXSxcbiAgJ2xhdmVuZGVyJzogWzIzMCwgMjMwLCAyNTAsIDFdLFxuICAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsIDI0MCwgMjQ1LCAxXSxcbiAgJ2xhd25ncmVlbic6IFsxMjQsIDI1MiwgMCwgMV0sXG4gICdsZW1vbmNoaWZmb24nOiBbMjU1LCAyNTAsIDIwNSwgMV0sXG4gICdsaWdodGJsdWUnOiBbMTczLCAyMTYsIDIzMCwgMV0sXG4gICdsaWdodGNvcmFsJzogWzI0MCwgMTI4LCAxMjgsIDFdLFxuICAnbGlnaHRjeWFuJzogWzIyNCwgMjU1LCAyNTUsIDFdLFxuICAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLCAyNTAsIDIxMCwgMV0sXG4gICdsaWdodGdyYXknOiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICdsaWdodGdyZWVuJzogWzE0NCwgMjM4LCAxNDQsIDFdLFxuICAnbGlnaHRncmV5JzogWzIxMSwgMjExLCAyMTEsIDFdLFxuICAnbGlnaHRwaW5rJzogWzI1NSwgMTgyLCAxOTMsIDFdLFxuICAnbGlnaHRzYWxtb24nOiBbMjU1LCAxNjAsIDEyMiwgMV0sXG4gICdsaWdodHNlYWdyZWVuJzogWzMyLCAxNzgsIDE3MCwgMV0sXG4gICdsaWdodHNreWJsdWUnOiBbMTM1LCAyMDYsIDI1MCwgMV0sXG4gICdsaWdodHNsYXRlZ3JheSc6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgJ2xpZ2h0c2xhdGVncmV5JzogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAnbGlnaHRzdGVlbGJsdWUnOiBbMTc2LCAxOTYsIDIyMiwgMV0sXG4gICdsaWdodHllbGxvdyc6IFsyNTUsIDI1NSwgMjI0LCAxXSxcbiAgJ2xpbWUnOiBbMCwgMjU1LCAwLCAxXSxcbiAgJ2xpbWVncmVlbic6IFs1MCwgMjA1LCA1MCwgMV0sXG4gICdsaW5lbic6IFsyNTAsIDI0MCwgMjMwLCAxXSxcbiAgJ21hZ2VudGEnOiBbMjU1LCAwLCAyNTUsIDFdLFxuICAnbWFyb29uJzogWzEyOCwgMCwgMCwgMV0sXG4gICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwgMjA1LCAxNzAsIDFdLFxuICAnbWVkaXVtYmx1ZSc6IFswLCAwLCAyMDUsIDFdLFxuICAnbWVkaXVtb3JjaGlkJzogWzE4NiwgODUsIDIxMSwgMV0sXG4gICdtZWRpdW1wdXJwbGUnOiBbMTQ3LCAxMTIsIDIxOSwgMV0sXG4gICdtZWRpdW1zZWFncmVlbic6IFs2MCwgMTc5LCAxMTMsIDFdLFxuICAnbWVkaXVtc2xhdGVibHVlJzogWzEyMywgMTA0LCAyMzgsIDFdLFxuICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwgMjUwLCAxNTQsIDFdLFxuICAnbWVkaXVtdHVycXVvaXNlJzogWzcyLCAyMDksIDIwNCwgMV0sXG4gICdtZWRpdW12aW9sZXRyZWQnOiBbMTk5LCAyMSwgMTMzLCAxXSxcbiAgJ21pZG5pZ2h0Ymx1ZSc6IFsyNSwgMjUsIDExMiwgMV0sXG4gICdtaW50Y3JlYW0nOiBbMjQ1LCAyNTUsIDI1MCwgMV0sXG4gICdtaXN0eXJvc2UnOiBbMjU1LCAyMjgsIDIyNSwgMV0sXG4gICdtb2NjYXNpbic6IFsyNTUsIDIyOCwgMTgxLCAxXSxcbiAgJ25hdmFqb3doaXRlJzogWzI1NSwgMjIyLCAxNzMsIDFdLFxuICAnbmF2eSc6IFswLCAwLCAxMjgsIDFdLFxuICAnb2xkbGFjZSc6IFsyNTMsIDI0NSwgMjMwLCAxXSxcbiAgJ29saXZlJzogWzEyOCwgMTI4LCAwLCAxXSxcbiAgJ29saXZlZHJhYic6IFsxMDcsIDE0MiwgMzUsIDFdLFxuICAnb3JhbmdlJzogWzI1NSwgMTY1LCAwLCAxXSxcbiAgJ29yYW5nZXJlZCc6IFsyNTUsIDY5LCAwLCAxXSxcbiAgJ29yY2hpZCc6IFsyMTgsIDExMiwgMjE0LCAxXSxcbiAgJ3BhbGVnb2xkZW5yb2QnOiBbMjM4LCAyMzIsIDE3MCwgMV0sXG4gICdwYWxlZ3JlZW4nOiBbMTUyLCAyNTEsIDE1MiwgMV0sXG4gICdwYWxldHVycXVvaXNlJzogWzE3NSwgMjM4LCAyMzgsIDFdLFxuICAncGFsZXZpb2xldHJlZCc6IFsyMTksIDExMiwgMTQ3LCAxXSxcbiAgJ3BhcGF5YXdoaXAnOiBbMjU1LCAyMzksIDIxMywgMV0sXG4gICdwZWFjaHB1ZmYnOiBbMjU1LCAyMTgsIDE4NSwgMV0sXG4gICdwZXJ1JzogWzIwNSwgMTMzLCA2MywgMV0sXG4gICdwaW5rJzogWzI1NSwgMTkyLCAyMDMsIDFdLFxuICAncGx1bSc6IFsyMjEsIDE2MCwgMjIxLCAxXSxcbiAgJ3Bvd2RlcmJsdWUnOiBbMTc2LCAyMjQsIDIzMCwgMV0sXG4gICdwdXJwbGUnOiBbMTI4LCAwLCAxMjgsIDFdLFxuICAncmVkJzogWzI1NSwgMCwgMCwgMV0sXG4gICdyb3N5YnJvd24nOiBbMTg4LCAxNDMsIDE0MywgMV0sXG4gICdyb3lhbGJsdWUnOiBbNjUsIDEwNSwgMjI1LCAxXSxcbiAgJ3NhZGRsZWJyb3duJzogWzEzOSwgNjksIDE5LCAxXSxcbiAgJ3NhbG1vbic6IFsyNTAsIDEyOCwgMTE0LCAxXSxcbiAgJ3NhbmR5YnJvd24nOiBbMjQ0LCAxNjQsIDk2LCAxXSxcbiAgJ3NlYWdyZWVuJzogWzQ2LCAxMzksIDg3LCAxXSxcbiAgJ3NlYXNoZWxsJzogWzI1NSwgMjQ1LCAyMzgsIDFdLFxuICAnc2llbm5hJzogWzE2MCwgODIsIDQ1LCAxXSxcbiAgJ3NpbHZlcic6IFsxOTIsIDE5MiwgMTkyLCAxXSxcbiAgJ3NreWJsdWUnOiBbMTM1LCAyMDYsIDIzNSwgMV0sXG4gICdzbGF0ZWJsdWUnOiBbMTA2LCA5MCwgMjA1LCAxXSxcbiAgJ3NsYXRlZ3JheSc6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgJ3NsYXRlZ3JleSc6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgJ3Nub3cnOiBbMjU1LCAyNTAsIDI1MCwgMV0sXG4gICdzcHJpbmdncmVlbic6IFswLCAyNTUsIDEyNywgMV0sXG4gICdzdGVlbGJsdWUnOiBbNzAsIDEzMCwgMTgwLCAxXSxcbiAgJ3Rhbic6IFsyMTAsIDE4MCwgMTQwLCAxXSxcbiAgJ3RlYWwnOiBbMCwgMTI4LCAxMjgsIDFdLFxuICAndGhpc3RsZSc6IFsyMTYsIDE5MSwgMjE2LCAxXSxcbiAgJ3RvbWF0byc6IFsyNTUsIDk5LCA3MSwgMV0sXG4gICd0dXJxdW9pc2UnOiBbNjQsIDIyNCwgMjA4LCAxXSxcbiAgJ3Zpb2xldCc6IFsyMzgsIDEzMCwgMjM4LCAxXSxcbiAgJ3doZWF0JzogWzI0NSwgMjIyLCAxNzksIDFdLFxuICAnd2hpdGUnOiBbMjU1LCAyNTUsIDI1NSwgMV0sXG4gICd3aGl0ZXNtb2tlJzogWzI0NSwgMjQ1LCAyNDUsIDFdLFxuICAneWVsbG93JzogWzI1NSwgMjU1LCAwLCAxXSxcbiAgJ3llbGxvd2dyZWVuJzogWzE1NCwgMjA1LCA1MCwgMV1cbn07XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzQnl0ZShpKSB7XG4gIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cblxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzQW5nbGUoaSkge1xuICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMzYwLlxuICBpID0gTWF0aC5yb3VuZChpKTsgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAzNjAgPyAzNjAgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHtcbiAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikge1xuICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgfVxuXG4gIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VJbnQoc3RyLCAxMCkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikge1xuICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgfVxuXG4gIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIHtcbiAgICBoICs9IDE7XG4gIH0gZWxzZSBpZiAoaCA+IDEpIHtcbiAgICBoIC09IDE7XG4gIH1cblxuICBpZiAoaCAqIDYgPCAxKSB7XG4gICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIH1cblxuICBpZiAoaCAqIDIgPCAxKSB7XG4gICAgcmV0dXJuIG0yO1xuICB9XG5cbiAgaWYgKGggKiAzIDwgMikge1xuICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNjtcbiAgfVxuXG4gIHJldHVybiBtMTtcbn1cblxuZnVuY3Rpb24gbGVycE51bWJlcihhLCBiLCBwKSB7XG4gIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG59XG5cbmZ1bmN0aW9uIHNldFJnYmEob3V0LCByLCBnLCBiLCBhKSB7XG4gIG91dFswXSA9IHI7XG4gIG91dFsxXSA9IGc7XG4gIG91dFsyXSA9IGI7XG4gIG91dFszXSA9IGE7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvcHlSZ2JhKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG52YXIgY29sb3JDYWNoZSA9IG5ldyBMUlUoMjApO1xudmFyIGxhc3RSZW1vdmVkQXJyID0gbnVsbDtcblxuZnVuY3Rpb24gcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycikge1xuICAvLyBSZXVzZSByZW1vdmVkIGFycmF5XG4gIGlmIChsYXN0UmVtb3ZlZEFycikge1xuICAgIGNvcHlSZ2JhKGxhc3RSZW1vdmVkQXJyLCByZ2JhQXJyKTtcbiAgfVxuXG4gIGxhc3RSZW1vdmVkQXJyID0gY29sb3JDYWNoZS5wdXQoY29sb3JTdHIsIGxhc3RSZW1vdmVkQXJyIHx8IHJnYmFBcnIuc2xpY2UoKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclN0clxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZShjb2xvclN0ciwgcmdiYUFycikge1xuICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmdiYUFyciA9IHJnYmFBcnIgfHwgW107XG4gIHZhciBjYWNoZWQgPSBjb2xvckNhY2hlLmdldChjb2xvclN0cik7XG5cbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjb3B5UmdiYShyZ2JhQXJyLCBjYWNoZWQpO1xuICB9IC8vIGNvbG9yU3RyIG1heSBiZSBub3Qgc3RyaW5nXG5cblxuICBjb2xvclN0ciA9IGNvbG9yU3RyICsgJyc7IC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuXG4gIHZhciBzdHIgPSBjb2xvclN0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpOyAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG5cbiAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkge1xuICAgIGNvcHlSZ2JhKHJnYmFBcnIsIGtDU1NDb2xvclRhYmxlW3N0cl0pO1xuICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgIHJldHVybiByZ2JhQXJyO1xuICB9IC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuXG5cbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7IC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkge1xuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICByZXR1cm47IC8vIENvdmVycyBOYU4uXG4gICAgICB9XG5cbiAgICAgIHNldFJnYmEocmdiYUFyciwgKGl2ICYgMHhmMDApID4+IDQgfCAoaXYgJiAweGYwMCkgPj4gOCwgaXYgJiAweGYwIHwgKGl2ICYgMHhmMCkgPj4gNCwgaXYgJiAweGYgfCAoaXYgJiAweGYpIDw8IDQsIDEpO1xuICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICByZXR1cm4gcmdiYUFycjtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7XG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjsgLy8gQ292ZXJzIE5hTi5cbiAgICAgIH1cblxuICAgICAgc2V0UmdiYShyZ2JhQXJyLCAoaXYgJiAweGZmMDAwMCkgPj4gMTYsIChpdiAmIDB4ZmYwMCkgPj4gOCwgaXYgJiAweGZmLCAxKTtcbiAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSxcbiAgICAgIGVwID0gc3RyLmluZGV4T2YoJyknKTtcblxuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuXG4gICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhbHBoYSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCBwYXJzZUNzc0ludChwYXJhbXNbMF0pLCBwYXJzZUNzc0ludChwYXJhbXNbMV0pLCBwYXJzZUNzc0ludChwYXJhbXNbMl0pLCBhbHBoYSk7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNbM10gPSBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSk7XG4gICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgcmV0dXJuO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICovXG5cblxuZnVuY3Rpb24gaHNsYTJyZ2JhKGhzbGEsIHJnYmEpIHtcbiAgdmFyIGggPSAocGFyc2VGbG9hdChoc2xhWzBdKSAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7IC8vIDAgLi4gMVxuICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuXG4gIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgdmFyIGwgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMl0pO1xuICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgcmdiYSA9IHJnYmEgfHwgW107XG4gIHNldFJnYmEocmdiYSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGgpICogMjU1KSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCAtIDEgLyAzKSAqIDI1NSksIDEpO1xuXG4gIGlmIChoc2xhLmxlbmd0aCA9PT0gNCkge1xuICAgIHJnYmFbM10gPSBoc2xhWzNdO1xuICB9XG5cbiAgcmV0dXJuIHJnYmE7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKi9cblxuXG5mdW5jdGlvbiByZ2JhMmhzbGEocmdiYSkge1xuICBpZiAoIXJnYmEpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gUkdCIGZyb20gMCB0byAyNTVcblxuXG4gIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICB2YXIgQiA9IHJnYmFbMl0gLyAyNTU7XG4gIHZhciB2TWluID0gTWF0aC5taW4oUiwgRywgQik7IC8vIE1pbi4gdmFsdWUgb2YgUkdCXG5cbiAgdmFyIHZNYXggPSBNYXRoLm1heChSLCBHLCBCKTsgLy8gTWF4LiB2YWx1ZSBvZiBSR0JcblxuICB2YXIgZGVsdGEgPSB2TWF4IC0gdk1pbjsgLy8gRGVsdGEgUkdCIHZhbHVlXG5cbiAgdmFyIEwgPSAodk1heCArIHZNaW4pIC8gMjtcbiAgdmFyIEg7XG4gIHZhciBTOyAvLyBIU0wgcmVzdWx0cyBmcm9tIDAgdG8gMVxuXG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIEggPSAwO1xuICAgIFMgPSAwO1xuICB9IGVsc2Uge1xuICAgIGlmIChMIDwgMC41KSB7XG4gICAgICBTID0gZGVsdGEgLyAodk1heCArIHZNaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBTID0gZGVsdGEgLyAoMiAtIHZNYXggLSB2TWluKTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFSID0gKCh2TWF4IC0gUikgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuICAgIHZhciBkZWx0YUcgPSAoKHZNYXggLSBHKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG4gICAgdmFyIGRlbHRhQiA9ICgodk1heCAtIEIpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcblxuICAgIGlmIChSID09PSB2TWF4KSB7XG4gICAgICBIID0gZGVsdGFCIC0gZGVsdGFHO1xuICAgIH0gZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgSCA9IDEgLyAzICsgZGVsdGFSIC0gZGVsdGFCO1xuICAgIH0gZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgSCA9IDIgLyAzICsgZGVsdGFHIC0gZGVsdGFSO1xuICAgIH1cblxuICAgIGlmIChIIDwgMCkge1xuICAgICAgSCArPSAxO1xuICAgIH1cblxuICAgIGlmIChIID4gMSkge1xuICAgICAgSCAtPSAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoc2xhID0gW0ggKiAzNjAsIFMsIExdO1xuXG4gIGlmIChyZ2JhWzNdICE9IG51bGwpIHtcbiAgICBoc2xhLnB1c2gocmdiYVszXSk7XG4gIH1cblxuICByZXR1cm4gaHNsYTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBsaWZ0KGNvbG9yLCBsZXZlbCkge1xuICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yQXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbG9yQXJyW2ldID0gKDI1NSAtIGNvbG9yQXJyW2ldKSAqIGxldmVsICsgY29sb3JBcnJbaV0gfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3JBcnIsIGNvbG9yQXJyLmxlbmd0aCA9PT0gNCA/ICdyZ2JhJyA6ICdyZ2InKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiB0b0hleChjb2xvcikge1xuICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yQXJyKSB7XG4gICAgcmV0dXJuICgoMSA8PCAyNCkgKyAoY29sb3JBcnJbMF0gPDwgMTYpICsgKGNvbG9yQXJyWzFdIDw8IDgpICsgK2NvbG9yQXJyWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gIH1cbn1cbi8qKlxuICogTWFwIHZhbHVlIHRvIGNvbG9yLiBGYXN0ZXIgdGhhbiBsZXJwIG1ldGhvZHMgYmVjYXVzZSBjb2xvciBpcyByZXByZXNlbnRlZCBieSByZ2JhIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gY29sb3JzIExpc3Qgb2YgcmdiYSBjb2xvciBhcnJheVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0gTWFwcGVkIGdiYSBjb2xvciBhcnJheVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHdpbGwgYmUgbnVsbC91bmRlZmluZWQgaWYgaW5wdXQgaWxsZWdhbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZhc3RMZXJwKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBvdXQpIHtcbiAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3V0ID0gb3V0IHx8IFtdO1xuICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgdmFyIGxlZnRDb2xvciA9IGNvbG9yc1tsZWZ0SW5kZXhdO1xuICB2YXIgcmlnaHRDb2xvciA9IGNvbG9yc1tyaWdodEluZGV4XTtcbiAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gIG91dFswXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKTtcbiAgb3V0WzFdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzFdLCByaWdodENvbG9yWzFdLCBkdikpO1xuICBvdXRbMl0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSk7XG4gIG91dFszXSA9IGNsYW1wQ3NzRmxvYXQobGVycE51bWJlcihsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuXG52YXIgZmFzdE1hcFRvQ29sb3IgPSBmYXN0TGVycDtcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICogQHBhcmFtIHtib29sZWFuPX0gZnVsbE91dHB1dCBEZWZhdWx0IGZhbHNlLlxuICogQHJldHVybiB7KHN0cmluZ3xPYmplY3QpfSBSZXN1bHQgY29sb3IuIElmIGZ1bGxPdXRwdXQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sb3I6IC4uLiwgbGVmdEluZGV4OiAuLi4sIHJpZ2h0SW5kZXg6IC4uLiwgdmFsdWU6IC4uLn0sXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cbmZ1bmN0aW9uIGxlcnAobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIGZ1bGxPdXRwdXQpIHtcbiAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gIHZhciBsZWZ0Q29sb3IgPSBwYXJzZShjb2xvcnNbbGVmdEluZGV4XSk7XG4gIHZhciByaWdodENvbG9yID0gcGFyc2UoY29sb3JzW3JpZ2h0SW5kZXhdKTtcbiAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gIHZhciBjb2xvciA9IHN0cmluZ2lmeShbY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpLCBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSksIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKSwgY2xhbXBDc3NGbG9hdChsZXJwTnVtYmVyKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKV0sICdyZ2JhJyk7XG4gIHJldHVybiBmdWxsT3V0cHV0ID8ge1xuICAgIGNvbG9yOiBjb2xvcixcbiAgICBsZWZ0SW5kZXg6IGxlZnRJbmRleCxcbiAgICByaWdodEluZGV4OiByaWdodEluZGV4LFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9IDogY29sb3I7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuXG52YXIgbWFwVG9Db2xvciA9IGxlcnA7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcGFyYW0ge251bWJlcj19IHMgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcGFyYW0ge251bWJlcj19IGwgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuZnVuY3Rpb24gbW9kaWZ5SFNMKGNvbG9yLCBoLCBzLCBsKSB7XG4gIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvcikge1xuICAgIGNvbG9yID0gcmdiYTJoc2xhKGNvbG9yKTtcbiAgICBoICE9IG51bGwgJiYgKGNvbG9yWzBdID0gY2xhbXBDc3NBbmdsZShoKSk7XG4gICAgcyAhPSBudWxsICYmIChjb2xvclsxXSA9IHBhcnNlQ3NzRmxvYXQocykpO1xuICAgIGwgIT0gbnVsbCAmJiAoY29sb3JbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGhzbGEycmdiYShjb2xvciksICdyZ2JhJyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcj19IGFscGhhIDAgfiAxXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBtb2RpZnlBbHBoYShjb2xvciwgYWxwaGEpIHtcbiAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yICYmIGFscGhhICE9IG51bGwpIHtcbiAgICBjb2xvclszXSA9IGNsYW1wQ3NzRmxvYXQoYWxwaGEpO1xuICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3IsICdyZ2JhJyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyQ29sb3IgbGlrZSBbMTIsMzMsNDQsMC40XVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ3JnYmEnLCAnaHN2YScsIC4uLlxuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHQgY29sb3IuIChJZiBpbnB1dCBpbGxlZ2FsLCByZXR1cm4gdW5kZWZpbmVkKS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnJDb2xvciwgdHlwZSkge1xuICBpZiAoIWFyckNvbG9yIHx8ICFhcnJDb2xvci5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29sb3JTdHIgPSBhcnJDb2xvclswXSArICcsJyArIGFyckNvbG9yWzFdICsgJywnICsgYXJyQ29sb3JbMl07XG5cbiAgaWYgKHR5cGUgPT09ICdyZ2JhJyB8fCB0eXBlID09PSAnaHN2YScgfHwgdHlwZSA9PT0gJ2hzbGEnKSB7XG4gICAgY29sb3JTdHIgKz0gJywnICsgYXJyQ29sb3JbM107XG4gIH1cblxuICByZXR1cm4gdHlwZSArICcoJyArIGNvbG9yU3RyICsgJyknO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLmxpZnQgPSBsaWZ0O1xuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuZXhwb3J0cy5mYXN0TGVycCA9IGZhc3RMZXJwO1xuZXhwb3J0cy5mYXN0TWFwVG9Db2xvciA9IGZhc3RNYXBUb0NvbG9yO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMubWFwVG9Db2xvciA9IG1hcFRvQ29sb3I7XG5leHBvcnRzLm1vZGlmeUhTTCA9IG1vZGlmeUhTTDtcbmV4cG9ydHMubW9kaWZ5QWxwaGEgPSBtb2RpZnlBbHBoYTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciB0cmFuc2Zvcm1QYXRoID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtUGF0aFwiKTtcblxuLy8gY29tbWFuZCBjaGFyc1xudmFyIGNjID0gWydtJywgJ00nLCAnbCcsICdMJywgJ3YnLCAnVicsICdoJywgJ0gnLCAneicsICdaJywgJ2MnLCAnQycsICdxJywgJ1EnLCAndCcsICdUJywgJ3MnLCAnUycsICdhJywgJ0EnXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJID0gTWF0aC5QSTtcblxudmFyIHZNYWcgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xufTtcblxudmFyIHZSYXRpbyA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xufTtcblxudmFyIHZBbmdsZSA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG5cbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gIH1cblxuICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpICogbWF0aFNxcnQoKHJ4ICogcnggKiAocnkgKiByeSkgLSByeCAqIHJ4ICogKHlwICogeXApIC0gcnkgKiByeSAqICh4cCAqIHhwKSkgLyAocnggKiByeCAqICh5cCAqIHlwKSArIHJ5ICogcnkgKiAoeHAgKiB4cCkpKSB8fCAwO1xuICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBtYXRoQ29zKHBzaSkgKiBjeHAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIG1hdGhTaW4ocHNpKSAqIGN4cCArIG1hdGhDb3MocHNpKSAqIGN5cDtcbiAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgZFRoZXRhID0gUEk7XG4gIH1cblxuICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICBkVGhldGEgPSAwO1xuICB9XG5cbiAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gIH1cblxuICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgfVxuXG4gIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyBjb21tYW5kIHN0cmluZ1xuXG5cbiAgdmFyIGNzID0gZGF0YS5yZXBsYWNlKC8tL2csICcgLScpLnJlcGxhY2UoLyAgL2csICcgJykucmVwbGFjZSgvIC9nLCAnLCcpLnJlcGxhY2UoLywsL2csICcsJyk7XG4gIHZhciBuOyAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcblxuICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICB9IC8vIGNyZWF0ZSBhcnJheVxuXG5cbiAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7IC8vIGluaXQgY29udGV4dCBwb2ludFxuXG4gIHZhciBjcHggPSAwO1xuICB2YXIgY3B5ID0gMDtcbiAgdmFyIHBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuICB2YXIgcHJldkNtZDtcblxuICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIHAgPSBzdHIuc2xpY2UoMSkucmVwbGFjZSgvZSwtL2csICdlLScpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNtZDtcblxuICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmYgPCBwLmxlbmd0aCAmJiAhaXNOYU4ocFtvZmZdKSkge1xuICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3RsUHR4O1xuICAgICAgdmFyIGN0bFB0eTtcbiAgICAgIHZhciByeDtcbiAgICAgIHZhciByeTtcbiAgICAgIHZhciBwc2k7XG4gICAgICB2YXIgZmE7XG4gICAgICB2YXIgZnM7XG4gICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICB2YXIgeTEgPSBjcHk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnbCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSk7XG4gICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHkpO1xuICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZzID0gcFtvZmYrK107XG4gICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gJ3onIHx8IGMgPT09ICdaJykge1xuICAgICAgY21kID0gQ01ELlo7XG4gICAgICBwYXRoLmFkZERhdGEoY21kKTtcbiAgICB9XG5cbiAgICBwcmV2Q21kID0gY21kO1xuICB9XG5cbiAgcGF0aC50b1N0YXRpYygpO1xuICByZXR1cm4gcGF0aDtcbn0gLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykge1xuICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHBhdGguc2V0RGF0YSkge1xuICAgICAgcGF0aC5zZXREYXRhKHBhdGhQcm94eS5kYXRhKTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdHggPSBwYXRoO1xuICAgICAgcGF0aFByb3h5LnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIG9wdHMuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgIHRyYW5zZm9ybVBhdGgocGF0aFByb3h5LCBtKTtcbiAgICB0aGlzLmRpcnR5KHRydWUpO1xuICB9O1xuXG4gIHJldHVybiBvcHRzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIG9iamVjdCBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQYXRoKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIGNsYXNzIGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRGcm9tU3RyaW5nKHN0ciwgb3B0cykge1xuICByZXR1cm4gUGF0aC5leHRlbmQoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG59XG4vKipcbiAqIE1lcmdlIG11bHRpcGxlIHBhdGhzXG4gKi9cbi8vIFRPRE8gQXBwbHkgdHJhbnNmb3JtXG4vLyBUT0RPIHN0cm9rZSBkYXNoXG4vLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG5cblxuZnVuY3Rpb24gbWVyZ2VQYXRoKHBhdGhFbHMsIG9wdHMpIHtcbiAgdmFyIHBhdGhMaXN0ID0gW107XG4gIHZhciBsZW4gPSBwYXRoRWxzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhdGhFbCA9IHBhdGhFbHNbaV07XG5cbiAgICBpZiAoIXBhdGhFbC5wYXRoKSB7XG4gICAgICBwYXRoRWwuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhFbC5fX2RpcnR5UGF0aCkge1xuICAgICAgcGF0aEVsLmJ1aWxkUGF0aChwYXRoRWwucGF0aCwgcGF0aEVsLnNoYXBlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwYXRoTGlzdC5wdXNoKHBhdGhFbC5wYXRoKTtcbiAgfVxuXG4gIHZhciBwYXRoQnVuZGxlID0gbmV3IFBhdGgob3B0cyk7IC8vIE5lZWQgcGF0aCBwcm94eS5cblxuICBwYXRoQnVuZGxlLmNyZWF0ZVBhdGhQcm94eSgpO1xuXG4gIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpOyAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcblxuICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHBhdGhCdW5kbGU7XG59XG5cbmV4cG9ydHMuY3JlYXRlRnJvbVN0cmluZyA9IGNyZWF0ZUZyb21TdHJpbmc7XG5leHBvcnRzLmV4dGVuZEZyb21TdHJpbmcgPSBleHRlbmRGcm9tU3RyaW5nO1xuZXhwb3J0cy5tZXJnZVBhdGggPSBtZXJnZVBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC9wYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL3BhdGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSBfdmVjdG9yLmFwcGx5VHJhbnNmb3JtO1xudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIG1hdGhBdGFuMiA9IE1hdGguYXRhbjI7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHBhdGgsIG0pIHtcbiAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gIHZhciBjbWQ7XG4gIHZhciBuUG9pbnQ7XG4gIHZhciBpO1xuICB2YXIgajtcbiAgdmFyIGs7XG4gIHZhciBwO1xuICB2YXIgTSA9IENNRC5NO1xuICB2YXIgQyA9IENNRC5DO1xuICB2YXIgTCA9IENNRC5MO1xuICB2YXIgUiA9IENNRC5SO1xuICB2YXIgQSA9IENNRC5BO1xuICB2YXIgUSA9IENNRC5RO1xuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgY21kID0gZGF0YVtpKytdO1xuICAgIGogPSBpO1xuICAgIG5Qb2ludCA9IDA7XG5cbiAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgY2FzZSBNOlxuICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMOlxuICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDOlxuICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBROlxuICAgICAgICBuUG9pbnQgPSAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBBOlxuICAgICAgICB2YXIgeCA9IG1bNF07XG4gICAgICAgIHZhciB5ID0gbVs1XTtcbiAgICAgICAgdmFyIHN4ID0gbWF0aFNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgIHZhciBzeSA9IG1hdGhTcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICB2YXIgYW5nbGUgPSBtYXRoQXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTsgLy8gY3hcblxuICAgICAgICBkYXRhW2ldICo9IHN4O1xuICAgICAgICBkYXRhW2krK10gKz0geDsgLy8gY3lcblxuICAgICAgICBkYXRhW2ldICo9IHN5O1xuICAgICAgICBkYXRhW2krK10gKz0geTsgLy8gU2NhbGUgcnggYW5kIHJ5XG4gICAgICAgIC8vIEZJWE1FIEFzc3VtZSBwc2kgaXMgMCBoZXJlXG5cbiAgICAgICAgZGF0YVtpKytdICo9IHN4O1xuICAgICAgICBkYXRhW2krK10gKj0gc3k7IC8vIFN0YXJ0IGFuZ2xlXG5cbiAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlOyAvLyBlbmQgYW5nbGVcblxuICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7IC8vIEZJWE1FIHBzaVxuXG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFI6XG4gICAgICAgIC8vIHgwLCB5MFxuICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICBkYXRhW2orK10gPSBwWzFdOyAvLyB4MSwgeTFcblxuICAgICAgICBwWzBdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgcFsxXSArPSBkYXRhW2krK107XG4gICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgfVxuXG4gICAgZm9yIChrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICB2YXIgcCA9IHBvaW50c1trXTtcbiAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTsgLy8gV3JpdGUgYmFja1xuXG4gICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBndWlkID0gcmVxdWlyZShcIi4vY29yZS9ndWlkXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vY29yZS9lbnZcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBIYW5kbGVyID0gcmVxdWlyZShcIi4vSGFuZGxlclwiKTtcblxudmFyIFN0b3JhZ2UgPSByZXF1aXJlKFwiLi9TdG9yYWdlXCIpO1xuXG52YXIgUGFpbnRlciA9IHJlcXVpcmUoXCIuL1BhaW50ZXJcIik7XG5cbnZhciBBbmltYXRpb24gPSByZXF1aXJlKFwiLi9hbmltYXRpb24vQW5pbWF0aW9uXCIpO1xuXG52YXIgSGFuZGxlclByb3h5ID0gcmVxdWlyZShcIi4vZG9tL0hhbmRsZXJQcm94eVwiKTtcblxuLyohXG4qIFpSZW5kZXIsIGEgaGlnaCBwZXJmb3JtYW5jZSAyZCBkcmF3aW5nIGxpYnJhcnkuXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMywgQmFpZHUgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBMSUNFTlNFXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuKi9cbnZhciB1c2VWTUwgPSAhZW52LmNhbnZhc1N1cHBvcnRlZDtcbnZhciBwYWludGVyQ3RvcnMgPSB7XG4gIGNhbnZhczogUGFpbnRlclxufTtcbnZhciBpbnN0YW5jZXMgPSB7fTsgLy8gWlJlbmRlcuWunuS+i21hcOe0ouW8lVxuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblxudmFyIHZlcnNpb24gPSAnMy43LjQnO1xuLyoqXG4gKiBJbml0aWFsaXppbmcgYSB6cmVuZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAqL1xuXG5mdW5jdGlvbiBpbml0KGRvbSwgb3B0cykge1xuICB2YXIgenIgPSBuZXcgWlJlbmRlcihndWlkKCksIGRvbSwgb3B0cyk7XG4gIGluc3RhbmNlc1t6ci5pZF0gPSB6cjtcbiAgcmV0dXJuIHpyO1xufVxuLyoqXG4gKiBEaXNwb3NlIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3Bvc2UoenIpIHtcbiAgaWYgKHpyKSB7XG4gICAgenIuZGlzcG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBpbnN0YW5jZXMpIHtcbiAgICAgIGlmIChpbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpbnN0YW5jZXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2VzID0ge307XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogR2V0IHpyZW5kZXIgaW5zdGFuY2UgYnkgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCB6cmVuZGVyIGluc3RhbmNlIGlkXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2UoaWQpIHtcbiAgcmV0dXJuIGluc3RhbmNlc1tpZF07XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUGFpbnRlcihuYW1lLCBDdG9yKSB7XG4gIHBhaW50ZXJDdG9yc1tuYW1lXSA9IEN0b3I7XG59XG5cbmZ1bmN0aW9uIGRlbEluc3RhbmNlKGlkKSB7XG4gIGRlbGV0ZSBpbnN0YW5jZXNbaWRdO1xufVxuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvWlJlbmRlclxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvWlJlbmRlclxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqL1xuXG5cbnZhciBaUmVuZGVyID0gZnVuY3Rpb24gKGlkLCBkb20sIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTERvbUVsZW1lbnR9XG4gICAqL1xuXG4gIHRoaXMuZG9tID0gZG9tO1xuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5pZCA9IGlkO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKTtcbiAgdmFyIHJlbmRlcmVyVHlwZSA9IG9wdHMucmVuZGVyZXI7IC8vIFRPRE8gV2ViR0xcblxuICBpZiAodXNlVk1MKSB7XG4gICAgaWYgKCFwYWludGVyQ3RvcnMudm1sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHJlcXVpcmUgXFwnenJlbmRlci92bWwvdm1sXFwnIHRvIHN1cHBvcnQgSUU4Jyk7XG4gICAgfVxuXG4gICAgcmVuZGVyZXJUeXBlID0gJ3ZtbCc7XG4gIH0gZWxzZSBpZiAoIXJlbmRlcmVyVHlwZSB8fCAhcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0pIHtcbiAgICByZW5kZXJlclR5cGUgPSAnY2FudmFzJztcbiAgfVxuXG4gIHZhciBwYWludGVyID0gbmV3IHBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKGRvbSwgc3RvcmFnZSwgb3B0cyk7XG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHZhciBoYW5kZXJQcm94eSA9ICFlbnYubm9kZSA/IG5ldyBIYW5kbGVyUHJveHkocGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkgOiBudWxsO1xuICB0aGlzLmhhbmRsZXIgPSBuZXcgSGFuZGxlcihzdG9yYWdlLCBwYWludGVyLCBoYW5kZXJQcm94eSwgcGFpbnRlci5yb290KTtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufVxuICAgKi9cblxuICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oe1xuICAgIHN0YWdlOiB7XG4gICAgICB1cGRhdGU6IHpyVXRpbC5iaW5kKHRoaXMuZmx1c2gsIHRoaXMpXG4gICAgfVxuICB9KTtcbiAgdGhpcy5hbmltYXRpb24uc3RhcnQoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9uZWVkc1JlZnJlc2g7IC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlLCDmr4/mrKHliKDpmaTlhYPntKDkuYvliY3liKDpmaTliqjnlLtcbiAgLy8gRklYTUUg5pyJ54K5dWdseVxuXG4gIHZhciBvbGREZWxGcm9tU3RvcmFnZSA9IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2U7XG4gIHZhciBvbGRBZGRUb1N0b3JhZ2UgPSBzdG9yYWdlLmFkZFRvU3RvcmFnZTtcblxuICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkRGVsRnJvbVN0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG4gICAgZWwgJiYgZWwucmVtb3ZlU2VsZkZyb21acihzZWxmKTtcbiAgfTtcblxuICBzdG9yYWdlLmFkZFRvU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICBlbC5hZGRTZWxmVG9acihzZWxmKTtcbiAgfTtcbn07XG5cblpSZW5kZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWlJlbmRlcixcblxuICAvKipcbiAgICog6I635Y+W5a6e5L6L5ZSv5LiA5qCH6K+GXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldElkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWFg+e0oFxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB0aGlzLnN0b3JhZ2UuYWRkUm9vdChlbCk7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5YWD57SgXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChlbCkge1xuICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KGVsKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgY29uZmlndXJhdGlvbiBvZiBsYXllclxuICAgKiBAcGFyYW0ge3N0cmluZ30gekxldmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSBDbGVhciBjb2xvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSBJZiBlbmFibGUgbW90aW9uIGJsdXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XSBNb3Rpb24gYmx1ciBmYWN0b3IuIExhcmdlciB2YWx1ZSBjYXVzZSBsb25nZXIgdHJhaWxlclxuICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpMZXZlbCwgY29uZmlnKSB7XG4gICAgdGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKHpMZXZlbCwgY29uZmlnKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBjYW52YXMgaW1tZWRpYXRlbHlcbiAgICovXG4gIHJlZnJlc2hJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIC8vIHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XG4gICAgLy8gQ2xlYXIgbmVlZHNSZWZyZXNoIGFoZWFkIHRvIGF2b2lkIHNvbWV0aGluZyB3cm9uZyBoYXBwZW5zIGluIHJlZnJlc2hcbiAgICAvLyBPciBpdCB3aWxsIGNhdXNlIHpyZW5kZXIgcmVmcmVzaGVzIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTtcbiAgICB0aGlzLnBhaW50ZXIucmVmcmVzaCgpO1xuICAgIC8qKlxuICAgICAqIEF2b2lkIHRyaWdnZXIgenIucmVmcmVzaCBpbiBFbGVtZW50I2JlZm9yZVVwZGF0ZSBob29rXG4gICAgICovXG5cbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTsgLy8gdmFyIGVuZCA9IG5ldyBEYXRlKCk7XG4gICAgLy8gdmFyIGxvZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2cnKTtcbiAgICAvLyBpZiAobG9nKSB7XG4gICAgLy8gICAgIGxvZy5pbm5lckhUTUwgPSBsb2cuaW5uZXJIVE1MICsgJzxicj4nICsgKGVuZCAtIHN0YXJ0KTtcbiAgICAvLyB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hcmsgYW5kIHJlcGFpbnQgdGhlIGNhbnZhcyBpbiB0aGUgbmV4dCBmcmFtZSBvZiBicm93c2VyXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbGwgcmVmcmVzaFxuICAgKi9cbiAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fbmVlZHNSZWZyZXNoKSB7XG4gICAgICB0aGlzLnJlZnJlc2hJbW1lZGlhdGVseSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2hIb3Zlcikge1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXJJbW1lZGlhdGVseSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgdG8gaG92ZXIgbGF5ZXJcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAqL1xuICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIuYWRkSG92ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5hZGRIb3ZlcihlbCwgc3R5bGUpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBlbGVtZW50IGZyb20gaG92ZXIgbGF5ZXJcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAodGhpcy5wYWludGVyLnJlbW92ZUhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIoZWwpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBob3ZlciBlbGVtZW50cyBpbiBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIuY2xlYXJIb3Zlcikge1xuICAgICAgdGhpcy5wYWludGVyLmNsZWFySG92ZXIoKTtcbiAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGluIG5leHQgZnJhbWVcbiAgICovXG4gIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaCBob3ZlciBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVmcmVzaEhvdmVySW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlO1xuICAgIHRoaXMucGFpbnRlci5yZWZyZXNoSG92ZXIgJiYgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGNhbnZhcy5cbiAgICogU2hvdWxkIGJlIGludm9rZWQgd2hlbiBjb250YWluZXIgc2l6ZSBpcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLnBhaW50ZXIucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICB0aGlzLmhhbmRsZXIucmVzaXplKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3AgYW5kIGNsZWFyIGFsbCBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICovXG4gIGNsZWFyQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmltYXRpb24uY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciB3aWR0aFxuICAgKi9cbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFdpZHRoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjb250YWluZXIgaGVpZ2h0XG4gICAqL1xuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldEhlaWdodCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvcnQgdGhlIGNhbnZhcyBhcyBCYXNlNjQgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yPScjZmZmJ11cbiAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgVVJMXG4gICAqL1xuICAvLyB0b0RhdGFVUkw6IGZ1bmN0aW9uKHR5cGUsIGJhY2tncm91bmRDb2xvcikge1xuICAvLyAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyh7XG4gIC8vICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgLy8gICAgIH0pLnRvRGF0YVVSTCh0eXBlKTtcbiAgLy8gfSxcblxuICAvKipcbiAgICogQ29udmVydGluZyBhIHBhdGggdG8gaW1hZ2UuXG4gICAqIEl0IGhhcyBtdWNoIGJldHRlciBwZXJmb3JtYW5jZSBvZiBkcmF3aW5nIGltYWdlIHJhdGhlciB0aGFuIGRyYXdpbmcgYSB2ZWN0b3IgcGF0aC5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHBhdGhUb0ltYWdlOiBmdW5jdGlvbiAoZSwgZHByKSB7XG4gICAgcmV0dXJuIHRoaXMucGFpbnRlci5wYXRoVG9JbWFnZShlLCBkcHIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgZGVmYXVsdCBjdXJzb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICovXG4gIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICB0aGlzLmhhbmRsZXIuc2V0Q3Vyc29yU3R5bGUoY3Vyc29yU3R5bGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIGhvdmVyZWQgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHt0YXJnZXQsIHRvcFRhcmdldH1cbiAgICovXG4gIGZpbmRIb3ZlcjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmZpbmRIb3Zlcih4LCB5KTtcbiAgfSxcblxuICAvKipcbiAgICogQmluZCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyIEhhbmRsZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IG9iamVjdFxuICAgKi9cbiAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuaGFuZGxlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuYmluZCBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2V2ZW50SGFuZGxlcl0gSGFuZGxlciBmdW5jdGlvblxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICB0aGlzLmhhbmRsZXIub2ZmKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJpZ2dlciBldmVudCBtYW51YWxseVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtldmVudD19IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0aGlzLmhhbmRsZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIG9iamVjdHMgYW5kIHRoZSBjYW52YXMuXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KCk7XG4gICAgdGhpcy5wYWludGVyLmNsZWFyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugc2VsZi5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5zdG9wKCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuc3RvcmFnZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5wYWludGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdGhpcy5zdG9yYWdlID0gdGhpcy5wYWludGVyID0gdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICBkZWxJbnN0YW5jZSh0aGlzLmlkKTtcbiAgfVxufTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5kaXNwb3NlID0gZGlzcG9zZTtcbmV4cG9ydHMuZ2V0SW5zdGFuY2UgPSBnZXRJbnN0YW5jZTtcbmV4cG9ydHMucmVnaXN0ZXJQYWludGVyID0gcmVnaXN0ZXJQYWludGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbnZhciBfX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj97XFxcImNhY2hlRGlyZWN0b3J5XFxcIjp0cnVlLFxcXCJwcmVzZXRzXFxcIjpbW1xcXCJlbnZcXFwiLHtcXFwibW9kdWxlc1xcXCI6ZmFsc2UsXFxcInRhcmdldHNcXFwiOntcXFwiYnJvd3NlcnNcXFwiOltcXFwiPiAyJVxcXCJdLFxcXCJ1Z2xpZnlcXFwiOnRydWV9fV1dLFxcXCJwbHVnaW5zXFxcIjpbXFxcInRyYW5zZm9ybS1vYmplY3QtcmVzdC1zcHJlYWRcXFwiLFtcXFwidHJhbnNmb3JtLXJ1bnRpbWVcXFwiLHtcXFwicG9seWZpbGxcXFwiOmZhbHNlLFxcXCJoZWxwZXJzXFxcIjpmYWxzZX1dXX0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi93ZWxjb21lLnZ1ZVwiKVxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYTBmYWNlZGVcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi93ZWxjb21lLnZ1ZVwiKVxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJyZXNvdXJjZXNcXFxcYXNzZXRzXFxcXGpzXFxcXGNvbXBvbmVudHNcXFxcaW5kZXhcXFxcd2VsY29tZS52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtYTBmYWNlZGVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1hMGZhY2VkZVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL2luZGV4L3dlbGNvbWUudnVlXG4vLyBtb2R1bGUgaWQgPSAuL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9pbmRleC93ZWxjb21lLnZ1ZVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9