webpackJsonp([0],{

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/index/user_transfer.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");
// 引入柱状图
__webpack_require__("./node_modules/echarts/lib/chart/bar.js");
__webpack_require__("./node_modules/echarts/lib/chart/line.js");
// 引入提示框和标题组件
__webpack_require__("./node_modules/echarts/lib/component/tooltip.js");
__webpack_require__("./node_modules/echarts/lib/component/title.js");
__webpack_require__("./node_modules/echarts/lib/component/legendScroll.js");
__webpack_require__("./node_modules/echarts/lib/component/dataZoom.js");
__webpack_require__("./node_modules/echarts/lib/component/markPoint.js");
__webpack_require__("./node_modules/echarts/lib/component/markLine.js");
__webpack_require__("./node_modules/echarts/lib/component/toolbox.js");

/* harmony default export */ __webpack_exports__["default"] = ({
	data: function data() {
		return {
			chart: ''
		};
	},

	methods: {
		resize: function resize() {
			this.chart.resize();
		}
	},
	mounted: function mounted() {
		var t = this;

		t.chart = echarts.init(document.getElementById('user_transfer'));
		var order_options = {
			title: {
				left: 'center',
				text: '',
				subtext: '包括所有钱包，按日划分，金额单位：分'
			},
			tooltip: {
				trigger: 'axis'
			},
			legend: {
				// type: 'scroll',
				top: '60px',
				// orient: 'vertical',
				// right:'0',
				// bottom:'10px',
				data: []
			},
			// color : ['#7079DF','#D15B7F','#FB6E6C','#FF9F69','#FEB64D','#FFDA43','#FFE88E'],
			toolbox: {
				show: true,
				feature: {
					magicType: { show: true, type: ['line', 'bar'] },
					saveAsImage: { show: true }
				}
			},
			grid: {
				top: '150px',
				// right : '200px',
				containLabel: true
			},
			calculable: true,
			dataZoom: [{
				show: true,
				type: 'inside',
				realtime: true,
				start: 80,
				end: 100,
				zoomOnMouseWheel: false
			}, {}],
			xAxis: [{
				type: 'category',
				nameGap: '60',
				data: []
			}],
			yAxis: [{
				type: 'value'
			}],
			series: []
		};
		t.$API.get('/index/user_transfer').then(function (data) {
			var dates = data.dates;
			var purse_types = data.purse_types;
			var out = data.out;
			var into = data.into;
			var amounts = data.amounts;

			// X 轴数据展示
			order_options.xAxis[0].data = dates;

			// 基本信息变量
			var series_template = function series_template() {
				return {
					name: '',
					type: 'bar',
					stack: '', // 正负轴相同的值会上下顶在一起
					data: [],
					// markPoint : {
					// 	symbol : 'pin',
					// 	data : [
					// 		{type : 'max', name: '最大值'},
					// 		{type : 'min', name: '最小值'}
					// 	]
					// },
					markLine: {
						data: [{ type: 'average', name: '平均值' }]
					},
					label: {
						show: true
					}
				};
			};

			for (var type in amounts) {
				var series = series_template();
				series.name = purse_types[type];
				order_options.legend.data.push(series.name);
				series.stack = type.substr(0, 1) == '-' ? type.substr(1) : type;
				for (var date in amounts[type]) {
					var date_val = amounts[type][date];
					series.data.push({
						value: date_val,
						// 在柱状条上显示数值
						label: {
							normal: {
								show: true,
								rotate: 90
							}
						}
					});
					// if(date_val < 0){
					// 	series.markPoint.symbolRotate = 180;
					// }
				}
				order_options.series.push(series);
			}
			order_options.title.text = '近期 ' + data.days + ' 天每日用户身份收入、支出金额统计';
			t.chart.setOption(order_options);
		}).catch(function (msg) {});

		window.onresize = function () {
			setTimeout(function () {
				t.chart.resize();
			}, 200);
		};
	}
});

/***/ }),

/***/ "./node_modules/echarts/lib/CoordinateSystem.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var coordinateSystemCreators = {};

function CoordinateSystemManager() {
  this._coordinateSystems = [];
}

CoordinateSystemManager.prototype = {
  constructor: CoordinateSystemManager,
  create: function (ecModel, api) {
    var coordinateSystems = [];
    zrUtil.each(coordinateSystemCreators, function (creater, type) {
      var list = creater.create(ecModel, api);
      coordinateSystems = coordinateSystems.concat(list || []);
    });
    this._coordinateSystems = coordinateSystems;
  },
  update: function (ecModel, api) {
    zrUtil.each(this._coordinateSystems, function (coordSys) {
      coordSys.update && coordSys.update(ecModel, api);
    });
  },
  getCoordinateSystems: function () {
    return this._coordinateSystems.slice();
  }
};

CoordinateSystemManager.register = function (type, coordinateSystemCreator) {
  coordinateSystemCreators[type] = coordinateSystemCreator;
};

CoordinateSystemManager.get = function (type) {
  return coordinateSystemCreators[type];
};

var _default = CoordinateSystemManager;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/ExtensionAPI.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var echartsAPIList = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel']; // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js

function ExtensionAPI(chartInstance) {
  zrUtil.each(echartsAPIList, function (name) {
    this[name] = zrUtil.bind(chartInstance[name], chartInstance);
  }, this);
}

var _default = ExtensionAPI;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _barGrid = __webpack_require__("./node_modules/echarts/lib/layout/barGrid.js");

var layout = _barGrid.layout;
var largeLayout = _barGrid.largeLayout;

__webpack_require__("./node_modules/echarts/lib/coord/cartesian/Grid.js");

__webpack_require__("./node_modules/echarts/lib/chart/bar/BarSeries.js");

__webpack_require__("./node_modules/echarts/lib/chart/bar/BarView.js");

__webpack_require__("./node_modules/echarts/lib/component/gridSimple.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// In case developer forget to include grid component
echarts.registerLayout(zrUtil.curry(layout, 'bar')); // Should after normal bar layout, otherwise it is blocked by normal bar layout.

echarts.registerLayout(largeLayout);
echarts.registerVisual({
  seriesType: 'bar',
  reset: function (seriesModel) {
    // Visual coding for legend
    seriesModel.getData().setVisual('legendSymbol', 'roundRect');
  }
});

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/BarSeries.js":
/***/ (function(module, exports, __webpack_require__) {

var BaseBarSeries = __webpack_require__("./node_modules/echarts/lib/chart/bar/BaseBarSeries.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = BaseBarSeries.extend({
  type: 'series.bar',
  dependencies: ['grid', 'polar'],
  brushSelector: 'rect',

  /**
   * @override
   */
  getProgressive: function () {
    // Do not support progressive in normal mode.
    return this.get('large') ? this.get('progressive') : false;
  },

  /**
   * @override
   */
  getProgressiveThreshold: function () {
    // Do not support progressive in normal mode.
    var progressiveThreshold = this.get('progressiveThreshold');
    var largeThreshold = this.get('largeThreshold');

    if (largeThreshold > progressiveThreshold) {
      progressiveThreshold = largeThreshold;
    }

    return progressiveThreshold;
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/BarView.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _helper = __webpack_require__("./node_modules/echarts/lib/chart/bar/helper.js");

var setLabel = _helper.setLabel;

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var barItemStyle = __webpack_require__("./node_modules/echarts/lib/chart/bar/barItemStyle.js");

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'barBorderWidth']; // FIXME
// Just for compatible with ec2.

zrUtil.extend(Model.prototype, barItemStyle);

var _default = echarts.extendChartView({
  type: 'bar',
  render: function (seriesModel, ecModel, api) {
    this._updateDrawMode(seriesModel);

    var coordinateSystemType = seriesModel.get('coordinateSystem');

    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api);
    } else {}

    return this.group;
  },
  incrementalPrepareRender: function (seriesModel, ecModel, api) {
    this._clear();

    this._updateDrawMode(seriesModel);
  },
  incrementalRender: function (params, seriesModel, ecModel, api) {
    // Do not support progressive in normal mode.
    this._incrementalRenderLarge(params, seriesModel);
  },
  _updateDrawMode: function (seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;

    if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;

      this._clear();
    }
  },
  _renderNormal: function (seriesModel, ecModel, api) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coord = seriesModel.coordinateSystem;
    var baseAxis = coord.getBaseAxis();
    var isHorizontalOrRadial;

    if (coord.type === 'cartesian2d') {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === 'polar') {
      isHorizontalOrRadial = baseAxis.dim === 'angle';
    }

    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    data.diff(oldData).add(function (dataIndex) {
      if (!data.hasValue(dataIndex)) {
        return;
      }

      var itemModel = data.getItemModel(dataIndex);
      var layout = getLayout[coord.type](data, dataIndex, itemModel);
      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);
      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
    }).update(function (newIndex, oldIndex) {
      var el = oldData.getItemGraphicEl(oldIndex);

      if (!data.hasValue(newIndex)) {
        group.remove(el);
        return;
      }

      var itemModel = data.getItemModel(newIndex);
      var layout = getLayout[coord.type](data, newIndex, itemModel);

      if (el) {
        graphic.updateProps(el, {
          shape: layout
        }, animationModel, newIndex);
      } else {
        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);
      }

      data.setItemGraphicEl(newIndex, el); // Add back

      group.add(el);
      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
    }).remove(function (dataIndex) {
      var el = oldData.getItemGraphicEl(dataIndex);

      if (coord.type === 'cartesian2d') {
        el && removeRect(dataIndex, animationModel, el);
      } else {
        el && removeSector(dataIndex, animationModel, el);
      }
    }).execute();
    this._data = data;
  },
  _renderLarge: function (seriesModel, ecModel, api) {
    this._clear();

    createLarge(seriesModel, this.group);
  },
  _incrementalRenderLarge: function (params, seriesModel) {
    createLarge(seriesModel, this.group, true);
  },
  dispose: zrUtil.noop,
  remove: function (ecModel) {
    this._clear(ecModel);
  },
  _clear: function (ecModel) {
    var group = this.group;
    var data = this._data;

    if (ecModel && ecModel.get('animation') && data && !this._isLargeDraw) {
      data.eachItemGraphicEl(function (el) {
        if (el.type === 'sector') {
          removeSector(el.dataIndex, ecModel, el);
        } else {
          removeRect(el.dataIndex, ecModel, el);
        }
      });
    } else {
      group.removeAll();
    }

    this._data = null;
  }
});

var elementCreator = {
  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {
    var rect = new graphic.Rect({
      shape: zrUtil.extend({}, layout)
    }); // Animation

    if (animationModel) {
      var rectShape = rect.shape;
      var animateProperty = isHorizontal ? 'height' : 'width';
      var animateTarget = {};
      rectShape[animateProperty] = 0;
      animateTarget[animateProperty] = layout[animateProperty];
      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {
        shape: animateTarget
      }, animationModel, dataIndex);
    }

    return rect;
  },
  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {
    // Keep the same logic with bar in catesion: use end value to control
    // direction. Notice that if clockwise is true (by default), the sector
    // will always draw clockwisely, no matter whether endAngle is greater
    // or less than startAngle.
    var clockwise = layout.startAngle < layout.endAngle;
    var sector = new graphic.Sector({
      shape: zrUtil.defaults({
        clockwise: clockwise
      }, layout)
    }); // Animation

    if (animationModel) {
      var sectorShape = sector.shape;
      var animateProperty = isRadial ? 'r' : 'endAngle';
      var animateTarget = {};
      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
      animateTarget[animateProperty] = layout[animateProperty];
      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {
        shape: animateTarget
      }, animationModel, dataIndex);
    }

    return sector;
  }
};

function removeRect(dataIndex, animationModel, el) {
  // Not show text when animating
  el.style.text = null;
  graphic.updateProps(el, {
    shape: {
      width: 0
    }
  }, animationModel, dataIndex, function () {
    el.parent && el.parent.remove(el);
  });
}

function removeSector(dataIndex, animationModel, el) {
  // Not show text when animating
  el.style.text = null;
  graphic.updateProps(el, {
    shape: {
      r: el.shape.r0
    }
  }, animationModel, dataIndex, function () {
    el.parent && el.parent.remove(el);
  });
}

var getLayout = {
  cartesian2d: function (data, dataIndex, itemModel) {
    var layout = data.getItemLayout(dataIndex);
    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth

    var signX = layout.width > 0 ? 1 : -1;
    var signY = layout.height > 0 ? 1 : -1;
    return {
      x: layout.x + signX * fixedLineWidth / 2,
      y: layout.y + signY * fixedLineWidth / 2,
      width: layout.width - signX * fixedLineWidth,
      height: layout.height - signY * fixedLineWidth
    };
  },
  polar: function (data, dataIndex, itemModel) {
    var layout = data.getItemLayout(dataIndex);
    return {
      cx: layout.cx,
      cy: layout.cy,
      r0: layout.r0,
      r: layout.r,
      startAngle: layout.startAngle,
      endAngle: layout.endAngle
    };
  }
};

function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
  var color = data.getItemVisual(dataIndex, 'color');
  var opacity = data.getItemVisual(dataIndex, 'opacity');
  var itemStyleModel = itemModel.getModel('itemStyle');
  var hoverStyle = itemModel.getModel('emphasis.itemStyle').getBarItemStyle();

  if (!isPolar) {
    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);
  }

  el.useStyle(zrUtil.defaults({
    fill: color,
    opacity: opacity
  }, itemStyleModel.getBarItemStyle()));
  var cursorStyle = itemModel.getShallow('cursor');
  cursorStyle && el.attr('cursor', cursorStyle);
  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';

  if (!isPolar) {
    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);
  }

  graphic.setHoverStyle(el, hoverStyle);
} // In case width or height are too small.


function getLineWidth(itemModel, rawLayout) {
  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));
}

var LargePath = Path.extend({
  type: 'largeBar',
  shape: {
    points: []
  },
  buildPath: function (ctx, shape) {
    // Drawing lines is more efficient than drawing
    // a whole line or drawing rects.
    var points = shape.points;
    var startPoint = this.__startPoint;
    var valueIdx = this.__valueIdx;

    for (var i = 0; i < points.length; i += 2) {
      startPoint[this.__valueIdx] = points[i + valueIdx];
      ctx.moveTo(startPoint[0], startPoint[1]);
      ctx.lineTo(points[i], points[i + 1]);
    }
  }
});

function createLarge(seriesModel, group, incremental) {
  // TODO support polar
  var data = seriesModel.getData();
  var startPoint = [];
  var valueIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;
  startPoint[1 - valueIdx] = data.getLayout('valueAxisStart');
  var el = new LargePath({
    shape: {
      points: data.getLayout('largePoints')
    },
    incremental: !!incremental,
    __startPoint: startPoint,
    __valueIdx: valueIdx
  });
  group.add(el);
  setLargeStyle(el, seriesModel, data);
}

function setLargeStyle(el, seriesModel, data) {
  var borderColor = data.getVisual('borderColor') || data.getVisual('color');
  var itemStyle = seriesModel.getModel('itemStyle').getItemStyle(['color', 'borderColor']);
  el.useStyle(itemStyle);
  el.style.fill = null;
  el.style.stroke = borderColor;
  el.style.lineWidth = data.getLayout('barWidth');
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/BaseBarSeries.js":
/***/ (function(module, exports, __webpack_require__) {

var SeriesModel = __webpack_require__("./node_modules/echarts/lib/model/Series.js");

var createListFromArray = __webpack_require__("./node_modules/echarts/lib/chart/helper/createListFromArray.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = SeriesModel.extend({
  type: 'series.__base_bar__',
  getInitialData: function (option, ecModel) {
    return createListFromArray(this.getSource(), this);
  },
  getMarkerPosition: function (value) {
    var coordSys = this.coordinateSystem;

    if (coordSys) {
      // PENDING if clamp ?
      var pt = coordSys.dataToPoint(coordSys.clampData(value));
      var data = this.getData();
      var offset = data.getLayout('offset');
      var size = data.getLayout('size');
      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
      pt[offsetIndex] += offset + size / 2;
      return pt;
    }

    return [NaN, NaN];
  },
  defaultOption: {
    zlevel: 0,
    // 一级层叠
    z: 2,
    // 二级层叠
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    // stack: null
    // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // 最小高度改为0
    barMinHeight: 0,
    // 最小角度为0，仅对极坐标系下的柱状图有效
    barMinAngle: 0,
    // cursor: null,
    large: false,
    largeThreshold: 400,
    progressive: 5e3,
    progressiveChunkMode: 'mod',
    // barMaxWidth: null,
    // 默认自适应
    // barWidth: null,
    // 柱间距离，默认为柱形宽度的30%，可设固定值
    // barGap: '30%',
    // 类目间柱形距离，默认为类目间距的20%，可设固定值
    // barCategoryGap: '20%',
    // label: {
    //      show: false
    // },
    itemStyle: {},
    emphasis: {}
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/barItemStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__("./node_modules/echarts/lib/model/mixin/makeStyleMapper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2
['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
var _default = {
  getBarItemStyle: function (excludes) {
    var style = getBarItemStyle(this, excludes);

    if (this.getBorderLineDash) {
      var lineDash = this.getBorderLineDash();
      lineDash && (style.lineDash = lineDash);
    }

    return style;
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/helper.js":
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _labelHelper = __webpack_require__("./node_modules/echarts/lib/chart/helper/labelHelper.js");

var getDefaultLabel = _labelHelper.getDefaultLabel;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {
  var labelModel = itemModel.getModel('label');
  var hoverLabelModel = itemModel.getModel('emphasis.label');
  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
    isRectText: true,
    autoColor: color
  });
  fixPosition(normalStyle);
  fixPosition(hoverStyle);
}

function fixPosition(style, labelPositionOutside) {
  if (style.textPosition === 'outside') {
    style.textPosition = labelPositionOutside;
  }
}

exports.setLabel = setLabel;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/Line.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var symbolUtil = __webpack_require__("./node_modules/echarts/lib/util/symbol.js");

var LinePath = __webpack_require__("./node_modules/echarts/lib/chart/helper/LinePath.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var round = _number.round;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @module echarts/chart/helper/Line
 */
var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];

function makeSymbolTypeKey(symbolCategory) {
  return '_' + symbolCategory + 'Type';
}
/**
 * @inner
 */


function createSymbol(name, lineData, idx) {
  var color = lineData.getItemVisual(idx, 'color');
  var symbolType = lineData.getItemVisual(idx, name);
  var symbolSize = lineData.getItemVisual(idx, name + 'Size');

  if (!symbolType || symbolType === 'none') {
    return;
  }

  if (!zrUtil.isArray(symbolSize)) {
    symbolSize = [symbolSize, symbolSize];
  }

  var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);
  symbolPath.name = name;
  return symbolPath;
}

function createLine(points) {
  var line = new LinePath({
    name: 'line'
  });
  setLinePoints(line.shape, points);
  return line;
}

function setLinePoints(targetShape, points) {
  var p1 = points[0];
  var p2 = points[1];
  var cp1 = points[2];
  targetShape.x1 = p1[0];
  targetShape.y1 = p1[1];
  targetShape.x2 = p2[0];
  targetShape.y2 = p2[1];
  targetShape.percent = 1;

  if (cp1) {
    targetShape.cpx1 = cp1[0];
    targetShape.cpy1 = cp1[1];
  } else {
    targetShape.cpx1 = NaN;
    targetShape.cpy1 = NaN;
  }
}

function updateSymbolAndLabelBeforeLineUpdate() {
  var lineGroup = this;
  var symbolFrom = lineGroup.childOfName('fromSymbol');
  var symbolTo = lineGroup.childOfName('toSymbol');
  var label = lineGroup.childOfName('label'); // Quick reject

  if (!symbolFrom && !symbolTo && label.ignore) {
    return;
  }

  var invScale = 1;
  var parentNode = this.parent;

  while (parentNode) {
    if (parentNode.scale) {
      invScale /= parentNode.scale[0];
    }

    parentNode = parentNode.parent;
  }

  var line = lineGroup.childOfName('line'); // If line not changed
  // FIXME Parent scale changed

  if (!this.__dirty && !line.__dirty) {
    return;
  }

  var percent = line.shape.percent;
  var fromPos = line.pointAt(0);
  var toPos = line.pointAt(percent);
  var d = vector.sub([], toPos, fromPos);
  vector.normalize(d, d);

  if (symbolFrom) {
    symbolFrom.attr('position', fromPos);
    var tangent = line.tangentAt(0);
    symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
    symbolFrom.attr('scale', [invScale * percent, invScale * percent]);
  }

  if (symbolTo) {
    symbolTo.attr('position', toPos);
    var tangent = line.tangentAt(1);
    symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
    symbolTo.attr('scale', [invScale * percent, invScale * percent]);
  }

  if (!label.ignore) {
    label.attr('position', toPos);
    var textPosition;
    var textAlign;
    var textVerticalAlign;
    var distance = 5 * invScale; // End

    if (label.__position === 'end') {
      textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];
      textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';
      textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';
    } // Middle
    else if (label.__position === 'middle') {
        var halfPercent = percent / 2;
        var tangent = line.tangentAt(halfPercent);
        var n = [tangent[1], -tangent[0]];
        var cp = line.pointAt(halfPercent);

        if (n[1] > 0) {
          n[0] = -n[0];
          n[1] = -n[1];
        }

        textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];
        textAlign = 'center';
        textVerticalAlign = 'bottom';
        var rotation = -Math.atan2(tangent[1], tangent[0]);

        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }

        label.attr('rotation', rotation);
      } // Start
      else {
          textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];
          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';
          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';
        }

    label.attr({
      style: {
        // Use the user specified text align and baseline first
        textVerticalAlign: label.__verticalAlign || textVerticalAlign,
        textAlign: label.__textAlign || textAlign
      },
      position: textPosition,
      scale: [invScale, invScale]
    });
  }
}
/**
 * @constructor
 * @extends {module:zrender/graphic/Group}
 * @alias {module:echarts/chart/helper/Line}
 */


function Line(lineData, idx, seriesScope) {
  graphic.Group.call(this);

  this._createLine(lineData, idx, seriesScope);
}

var lineProto = Line.prototype; // Update symbol position and rotation

lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;

lineProto._createLine = function (lineData, idx, seriesScope) {
  var seriesModel = lineData.hostModel;
  var linePoints = lineData.getItemLayout(idx);
  var line = createLine(linePoints);
  line.shape.percent = 0;
  graphic.initProps(line, {
    shape: {
      percent: 1
    }
  }, seriesModel, idx);
  this.add(line);
  var label = new graphic.Text({
    name: 'label'
  });
  this.add(label);
  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
    var symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure
    // it will be updated after line#update.
    // Or symbol position and rotation update in line#beforeUpdate will be one frame slow

    this.add(symbol);
    this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
  }, this);

  this._updateCommonStl(lineData, idx, seriesScope);
};

lineProto.updateData = function (lineData, idx, seriesScope) {
  var seriesModel = lineData.hostModel;
  var line = this.childOfName('line');
  var linePoints = lineData.getItemLayout(idx);
  var target = {
    shape: {}
  };
  setLinePoints(target.shape, linePoints);
  graphic.updateProps(line, target, seriesModel, idx);
  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
    var symbolType = lineData.getItemVisual(idx, symbolCategory);
    var key = makeSymbolTypeKey(symbolCategory); // Symbol changed

    if (this[key] !== symbolType) {
      this.remove(this.childOfName(symbolCategory));
      var symbol = createSymbol(symbolCategory, lineData, idx);
      this.add(symbol);
    }

    this[key] = symbolType;
  }, this);

  this._updateCommonStl(lineData, idx, seriesScope);
};

lineProto._updateCommonStl = function (lineData, idx, seriesScope) {
  var seriesModel = lineData.hostModel;
  var line = this.childOfName('line');
  var lineStyle = seriesScope && seriesScope.lineStyle;
  var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
  var labelModel = seriesScope && seriesScope.labelModel;
  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset

  if (!seriesScope || lineData.hasItemOption) {
    var itemModel = lineData.getItemModel(idx);
    lineStyle = itemModel.getModel('lineStyle').getLineStyle();
    hoverLineStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();
    labelModel = itemModel.getModel('label');
    hoverLabelModel = itemModel.getModel('emphasis.label');
  }

  var visualColor = lineData.getItemVisual(idx, 'color');
  var visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1);
  line.useStyle(zrUtil.defaults({
    strokeNoScale: true,
    fill: 'none',
    stroke: visualColor,
    opacity: visualOpacity
  }, lineStyle));
  line.hoverStyle = hoverLineStyle; // Update symbol

  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
    var symbol = this.childOfName(symbolCategory);

    if (symbol) {
      symbol.setColor(visualColor);
      symbol.setStyle({
        opacity: visualOpacity
      });
    }
  }, this);
  var showLabel = labelModel.getShallow('show');
  var hoverShowLabel = hoverLabelModel.getShallow('show');
  var label = this.childOfName('label');
  var defaultLabelColor;
  var baseText; // FIXME: the logic below probably should be merged to `graphic.setLabelStyle`.

  if (showLabel || hoverShowLabel) {
    defaultLabelColor = visualColor || '#000';
    baseText = seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType);

    if (baseText == null) {
      var rawVal = seriesModel.getRawValue(idx);
      baseText = rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;
    }
  }

  var normalText = showLabel ? baseText : null;
  var emphasisText = hoverShowLabel ? zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), baseText) : null;
  var labelStyle = label.style; // Always set `textStyle` even if `normalStyle.text` is null, because default
  // values have to be set on `normalStyle`.

  if (normalText != null || emphasisText != null) {
    graphic.setTextStyle(label.style, labelModel, {
      text: normalText
    }, {
      autoColor: defaultLabelColor
    });
    label.__textAlign = labelStyle.textAlign;
    label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end'

    label.__position = labelModel.get('position') || 'middle';
  }

  if (emphasisText != null) {
    // Only these properties supported in this emphasis style here.
    label.hoverStyle = {
      text: emphasisText,
      textFill: hoverLabelModel.getTextColor(true),
      // For merging hover style to normal style, do not use
      // `hoverLabelModel.getFont()` here.
      fontStyle: hoverLabelModel.getShallow('fontStyle'),
      fontWeight: hoverLabelModel.getShallow('fontWeight'),
      fontSize: hoverLabelModel.getShallow('fontSize'),
      fontFamily: hoverLabelModel.getShallow('fontFamily')
    };
  } else {
    label.hoverStyle = {
      text: null
    };
  }

  label.ignore = !showLabel && !hoverShowLabel;
  graphic.setHoverStyle(this);
};

lineProto.highlight = function () {
  this.trigger('emphasis');
};

lineProto.downplay = function () {
  this.trigger('normal');
};

lineProto.updateLayout = function (lineData, idx) {
  this.setLinePoints(lineData.getItemLayout(idx));
};

lineProto.setLinePoints = function (points) {
  var linePath = this.childOfName('line');
  setLinePoints(linePath.shape, points);
  linePath.dirty();
};

zrUtil.inherits(Line, graphic.Group);
var _default = Line;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/LineDraw.js":
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var LineGroup = __webpack_require__("./node_modules/echarts/lib/chart/helper/Line.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @module echarts/chart/helper/LineDraw
 */
// import IncrementalDisplayable from 'zrender/src/graphic/IncrementalDisplayable';

/**
 * @alias module:echarts/component/marker/LineDraw
 * @constructor
 */
function LineDraw(ctor) {
  this._ctor = ctor || LineGroup;
  this.group = new graphic.Group();
}

var lineDrawProto = LineDraw.prototype;

lineDrawProto.isPersistent = function () {
  return true;
};
/**
 * @param {module:echarts/data/List} lineData
 */


lineDrawProto.updateData = function (lineData) {
  var lineDraw = this;
  var group = lineDraw.group;
  var oldLineData = lineDraw._lineData;
  lineDraw._lineData = lineData; // There is no oldLineData only when first rendering or switching from
  // stream mode to normal mode, where previous elements should be removed.

  if (!oldLineData) {
    group.removeAll();
  }

  var seriesScope = makeSeriesScope(lineData);
  lineData.diff(oldLineData).add(function (idx) {
    doAdd(lineDraw, lineData, idx, seriesScope);
  }).update(function (newIdx, oldIdx) {
    doUpdate(lineDraw, oldLineData, lineData, oldIdx, newIdx, seriesScope);
  }).remove(function (idx) {
    group.remove(oldLineData.getItemGraphicEl(idx));
  }).execute();
};

function doAdd(lineDraw, lineData, idx, seriesScope) {
  var itemLayout = lineData.getItemLayout(idx);

  if (!lineNeedsDraw(itemLayout)) {
    return;
  }

  var el = new lineDraw._ctor(lineData, idx, seriesScope);
  lineData.setItemGraphicEl(idx, el);
  lineDraw.group.add(el);
}

function doUpdate(lineDraw, oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
  var itemEl = oldLineData.getItemGraphicEl(oldIdx);

  if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
    lineDraw.group.remove(itemEl);
    return;
  }

  if (!itemEl) {
    itemEl = new lineDraw._ctor(newLineData, newIdx, seriesScope);
  } else {
    itemEl.updateData(newLineData, newIdx, seriesScope);
  }

  newLineData.setItemGraphicEl(newIdx, itemEl);
  lineDraw.group.add(itemEl);
}

lineDrawProto.updateLayout = function () {
  var lineData = this._lineData; // Do not support update layout in incremental mode.

  if (!lineData) {
    return;
  }

  lineData.eachItemGraphicEl(function (el, idx) {
    el.updateLayout(lineData, idx);
  }, this);
};

lineDrawProto.incrementalPrepareUpdate = function (lineData) {
  this._seriesScope = makeSeriesScope(lineData);
  this._lineData = null;
  this.group.removeAll();
};

lineDrawProto.incrementalUpdate = function (taskParams, lineData) {
  function updateIncrementalAndHover(el) {
    if (!el.isGroup) {
      el.incremental = el.useHoverLayer = true;
    }
  }

  for (var idx = taskParams.start; idx < taskParams.end; idx++) {
    var itemLayout = lineData.getItemLayout(idx);

    if (lineNeedsDraw(itemLayout)) {
      var el = new this._ctor(lineData, idx, this._seriesScope);
      el.traverse(updateIncrementalAndHover);
      this.group.add(el);
      lineData.setItemGraphicEl(idx, el);
    }
  }
};

function makeSeriesScope(lineData) {
  var hostModel = lineData.hostModel;
  return {
    lineStyle: hostModel.getModel('lineStyle').getLineStyle(),
    hoverLineStyle: hostModel.getModel('emphasis.lineStyle').getLineStyle(),
    labelModel: hostModel.getModel('label'),
    hoverLabelModel: hostModel.getModel('emphasis.label')
  };
}

lineDrawProto.remove = function () {
  this._clearIncremental();

  this._incremental = null;
  this.group.removeAll();
};

lineDrawProto._clearIncremental = function () {
  var incremental = this._incremental;

  if (incremental) {
    incremental.clearDisplaybles();
  }
};

function isPointNaN(pt) {
  return isNaN(pt[0]) || isNaN(pt[1]);
}

function lineNeedsDraw(pts) {
  return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
}

var _default = LineDraw;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/LinePath.js":
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Line path for bezier and straight line draw
 */
var straightLineProto = graphic.Line.prototype;
var bezierCurveProto = graphic.BezierCurve.prototype;

function isLine(shape) {
  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
}

var _default = graphic.extendShape({
  type: 'ec-line',
  style: {
    stroke: '#000',
    fill: null
  },
  shape: {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    percent: 1,
    cpx1: null,
    cpy1: null
  },
  buildPath: function (ctx, shape) {
    (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);
  },
  pointAt: function (t) {
    return isLine(this.shape) ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t);
  },
  tangentAt: function (t) {
    var shape = this.shape;
    var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
    return vec2.normalize(p, p);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/Symbol.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _symbol = __webpack_require__("./node_modules/echarts/lib/util/symbol.js");

var createSymbol = _symbol.createSymbol;

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var parsePercent = _number.parsePercent;

var _labelHelper = __webpack_require__("./node_modules/echarts/lib/chart/helper/labelHelper.js");

var getDefaultLabel = _labelHelper.getDefaultLabel;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @module echarts/chart/helper/Symbol
 */

/**
 * @constructor
 * @alias {module:echarts/chart/helper/Symbol}
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @extends {module:zrender/graphic/Group}
 */
function SymbolClz(data, idx, seriesScope) {
  graphic.Group.call(this);
  this.updateData(data, idx, seriesScope);
}

var symbolProto = SymbolClz.prototype;
/**
 * @public
 * @static
 * @param {module:echarts/data/List} data
 * @param {number} dataIndex
 * @return {Array.<number>} [width, height]
 */

var getSymbolSize = SymbolClz.getSymbolSize = function (data, idx) {
  var symbolSize = data.getItemVisual(idx, 'symbolSize');
  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
};

function getScale(symbolSize) {
  return [symbolSize[0] / 2, symbolSize[1] / 2];
}

function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}

symbolProto._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {
  // Remove paths created before
  this.removeAll();
  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(
  //     symbolType, -0.5, -0.5, 1, 1, color
  // );
  // If width/height are set too small (e.g., set to 1) on ios10
  // and macOS Sierra, a circle stroke become a rect, no matter what
  // the scale is set. So we set width/height as 2. See #4150.

  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color, keepAspect);
  symbolPath.attr({
    z2: 100,
    culling: true,
    scale: getScale(symbolSize)
  }); // Rewrite drift method

  symbolPath.drift = driftSymbol;
  this._symbolType = symbolType;
  this.add(symbolPath);
};
/**
 * Stop animation
 * @param {boolean} toLastFrame
 */


symbolProto.stopSymbolAnimation = function (toLastFrame) {
  this.childAt(0).stopAnimation(toLastFrame);
};
/**
 * FIXME:
 * Caution: This method breaks the encapsulation of this module,
 * but it indeed brings convenience. So do not use the method
 * unless you detailedly know all the implements of `Symbol`,
 * especially animation.
 *
 * Get symbol path element.
 */


symbolProto.getSymbolPath = function () {
  return this.childAt(0);
};
/**
 * Get scale(aka, current symbol size).
 * Including the change caused by animation
 */


symbolProto.getScale = function () {
  return this.childAt(0).scale;
};
/**
 * Highlight symbol
 */


symbolProto.highlight = function () {
  this.childAt(0).trigger('emphasis');
};
/**
 * Downplay symbol
 */


symbolProto.downplay = function () {
  this.childAt(0).trigger('normal');
};
/**
 * @param {number} zlevel
 * @param {number} z
 */


symbolProto.setZ = function (zlevel, z) {
  var symbolPath = this.childAt(0);
  symbolPath.zlevel = zlevel;
  symbolPath.z = z;
};

symbolProto.setDraggable = function (draggable) {
  var symbolPath = this.childAt(0);
  symbolPath.draggable = draggable;
  symbolPath.cursor = draggable ? 'move' : 'pointer';
};
/**
 * Update symbol properties
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Object} [seriesScope]
 * @param {Object} [seriesScope.itemStyle]
 * @param {Object} [seriesScope.hoverItemStyle]
 * @param {Object} [seriesScope.symbolRotate]
 * @param {Object} [seriesScope.symbolOffset]
 * @param {module:echarts/model/Model} [seriesScope.labelModel]
 * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]
 * @param {boolean} [seriesScope.hoverAnimation]
 * @param {Object} [seriesScope.cursorStyle]
 * @param {module:echarts/model/Model} [seriesScope.itemModel]
 * @param {string} [seriesScope.symbolInnerColor]
 * @param {Object} [seriesScope.fadeIn=false]
 */


symbolProto.updateData = function (data, idx, seriesScope) {
  this.silent = false;
  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
  var seriesModel = data.hostModel;
  var symbolSize = getSymbolSize(data, idx);
  var isInit = symbolType !== this._symbolType;

  if (isInit) {
    var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');

    this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
  } else {
    var symbolPath = this.childAt(0);
    symbolPath.silent = false;
    graphic.updateProps(symbolPath, {
      scale: getScale(symbolSize)
    }, seriesModel, idx);
  }

  this._updateCommon(data, idx, symbolSize, seriesScope);

  if (isInit) {
    var symbolPath = this.childAt(0);
    var fadeIn = seriesScope && seriesScope.fadeIn;
    var target = {
      scale: symbolPath.scale.slice()
    };
    fadeIn && (target.style = {
      opacity: symbolPath.style.opacity
    });
    symbolPath.scale = [0, 0];
    fadeIn && (symbolPath.style.opacity = 0);
    graphic.initProps(symbolPath, target, seriesModel, idx);
  }

  this._seriesModel = seriesModel;
}; // Update common properties


var normalStyleAccessPath = ['itemStyle'];
var emphasisStyleAccessPath = ['emphasis', 'itemStyle'];
var normalLabelAccessPath = ['label'];
var emphasisLabelAccessPath = ['emphasis', 'label'];
/**
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Array.<number>} symbolSize
 * @param {Object} [seriesScope]
 */

symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {
  var symbolPath = this.childAt(0);
  var seriesModel = data.hostModel;
  var color = data.getItemVisual(idx, 'color'); // Reset style

  if (symbolPath.type !== 'image') {
    symbolPath.useStyle({
      strokeNoScale: true
    });
  }

  var itemStyle = seriesScope && seriesScope.itemStyle;
  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
  var symbolRotate = seriesScope && seriesScope.symbolRotate;
  var symbolOffset = seriesScope && seriesScope.symbolOffset;
  var labelModel = seriesScope && seriesScope.labelModel;
  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
  var cursorStyle = seriesScope && seriesScope.cursorStyle;

  if (!seriesScope || data.hasItemOption) {
    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.
    // Because symbol provide setColor individually to set fill and stroke

    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);
    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
    symbolRotate = itemModel.getShallow('symbolRotate');
    symbolOffset = itemModel.getShallow('symbolOffset');
    labelModel = itemModel.getModel(normalLabelAccessPath);
    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
    hoverAnimation = itemModel.getShallow('hoverAnimation');
    cursorStyle = itemModel.getShallow('cursor');
  } else {
    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);
  }

  var elStyle = symbolPath.style;
  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);

  if (symbolOffset) {
    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);
  }

  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!

  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);
  symbolPath.setStyle(itemStyle);
  var opacity = data.getItemVisual(idx, 'opacity');

  if (opacity != null) {
    elStyle.opacity = opacity;
  }

  var liftZ = data.getItemVisual(idx, 'liftZ');
  var z2Origin = symbolPath.__z2Origin;

  if (liftZ != null) {
    if (z2Origin == null) {
      symbolPath.__z2Origin = symbolPath.z2;
      symbolPath.z2 += liftZ;
    }
  } else if (z2Origin != null) {
    symbolPath.z2 = z2Origin;
    symbolPath.__z2Origin = null;
  }

  var useNameLabel = seriesScope && seriesScope.useNameLabel;
  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
    labelFetcher: seriesModel,
    labelDataIndex: idx,
    defaultText: getLabelDefaultText,
    isRectText: true,
    autoColor: color
  }); // Do not execute util needed.

  function getLabelDefaultText(idx, opt) {
    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);
  }

  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');
  symbolPath.hoverStyle = hoverItemStyle; // FIXME
  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.

  graphic.setHoverStyle(symbolPath);
  var scale = getScale(symbolSize);

  if (hoverAnimation && seriesModel.isAnimationEnabled()) {
    var onEmphasis = function () {
      // Do not support this hover animation util some scenario required.
      // Animation can only be supported in hover layer when using `el.incremetal`.
      if (this.incremental) {
        return;
      }

      var ratio = scale[1] / scale[0];
      this.animateTo({
        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]
      }, 400, 'elasticOut');
    };

    var onNormal = function () {
      if (this.incremental) {
        return;
      }

      this.animateTo({
        scale: scale
      }, 400, 'elasticOut');
    };

    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
  }
};
/**
 * @param {Function} cb
 * @param {Object} [opt]
 * @param {Object} [opt.keepLabel=true]
 */


symbolProto.fadeOut = function (cb, opt) {
  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out

  this.silent = symbolPath.silent = true; // Not show text when animating

  !(opt && opt.keepLabel) && (symbolPath.style.text = null);
  graphic.updateProps(symbolPath, {
    style: {
      opacity: 0
    },
    scale: [0, 0]
  }, this._seriesModel, this.dataIndex, cb);
};

zrUtil.inherits(SymbolClz, graphic.Group);
var _default = SymbolClz;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/SymbolDraw.js":
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var SymbolClz = __webpack_require__("./node_modules/echarts/lib/chart/helper/Symbol.js");

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var isObject = _util.isObject;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @module echarts/chart/helper/SymbolDraw
 */

/**
 * @constructor
 * @alias module:echarts/chart/helper/SymbolDraw
 * @param {module:zrender/graphic/Group} [symbolCtor]
 */
function SymbolDraw(symbolCtor) {
  this.group = new graphic.Group();
  this._symbolCtor = symbolCtor || SymbolClz;
}

var symbolDrawProto = SymbolDraw.prototype;

function symbolNeedsDraw(data, point, idx, opt) {
  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of
  // the symbol element shape. We use the same clip shape here as
  // the line clip.
  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';
}
/**
 * Update symbols draw by new data
 * @param {module:echarts/data/List} data
 * @param {Object} [opt] Or isIgnore
 * @param {Function} [opt.isIgnore]
 * @param {Object} [opt.clipShape]
 */


symbolDrawProto.updateData = function (data, opt) {
  opt = normalizeUpdateOpt(opt);
  var group = this.group;
  var seriesModel = data.hostModel;
  var oldData = this._data;
  var SymbolCtor = this._symbolCtor;
  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from
  // stream mode to normal mode, where previous elements should be removed.

  if (!oldData) {
    group.removeAll();
  }

  data.diff(oldData).add(function (newIdx) {
    var point = data.getItemLayout(newIdx);

    if (symbolNeedsDraw(data, point, newIdx, opt)) {
      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
      symbolEl.attr('position', point);
      data.setItemGraphicEl(newIdx, symbolEl);
      group.add(symbolEl);
    }
  }).update(function (newIdx, oldIdx) {
    var symbolEl = oldData.getItemGraphicEl(oldIdx);
    var point = data.getItemLayout(newIdx);

    if (!symbolNeedsDraw(data, point, newIdx, opt)) {
      group.remove(symbolEl);
      return;
    }

    if (!symbolEl) {
      symbolEl = new SymbolCtor(data, newIdx);
      symbolEl.attr('position', point);
    } else {
      symbolEl.updateData(data, newIdx, seriesScope);
      graphic.updateProps(symbolEl, {
        position: point
      }, seriesModel);
    } // Add back


    group.add(symbolEl);
    data.setItemGraphicEl(newIdx, symbolEl);
  }).remove(function (oldIdx) {
    var el = oldData.getItemGraphicEl(oldIdx);
    el && el.fadeOut(function () {
      group.remove(el);
    });
  }).execute();
  this._data = data;
};

symbolDrawProto.isPersistent = function () {
  return true;
};

symbolDrawProto.updateLayout = function () {
  var data = this._data;

  if (data) {
    // Not use animation
    data.eachItemGraphicEl(function (el, idx) {
      var point = data.getItemLayout(idx);
      el.attr('position', point);
    });
  }
};

symbolDrawProto.incrementalPrepareUpdate = function (data) {
  this._seriesScope = makeSeriesScope(data);
  this._data = null;
  this.group.removeAll();
};
/**
 * Update symbols draw by new data
 * @param {module:echarts/data/List} data
 * @param {Object} [opt] Or isIgnore
 * @param {Function} [opt.isIgnore]
 * @param {Object} [opt.clipShape]
 */


symbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {
  opt = normalizeUpdateOpt(opt);

  function updateIncrementalAndHover(el) {
    if (!el.isGroup) {
      el.incremental = el.useHoverLayer = true;
    }
  }

  for (var idx = taskParams.start; idx < taskParams.end; idx++) {
    var point = data.getItemLayout(idx);

    if (symbolNeedsDraw(data, point, idx, opt)) {
      var el = new this._symbolCtor(data, idx, this._seriesScope);
      el.traverse(updateIncrementalAndHover);
      el.attr('position', point);
      this.group.add(el);
      data.setItemGraphicEl(idx, el);
    }
  }
};

function normalizeUpdateOpt(opt) {
  if (opt != null && !isObject(opt)) {
    opt = {
      isIgnore: opt
    };
  }

  return opt || {};
}

symbolDrawProto.remove = function (enableAnimation) {
  var group = this.group;
  var data = this._data; // Incremental model do not have this._data.

  if (data && enableAnimation) {
    data.eachItemGraphicEl(function (el) {
      el.fadeOut(function () {
        group.remove(el);
      });
    });
  } else {
    group.removeAll();
  }
};

function makeSeriesScope(data) {
  var seriesModel = data.hostModel;
  return {
    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),
    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),
    symbolRotate: seriesModel.get('symbolRotate'),
    symbolOffset: seriesModel.get('symbolOffset'),
    hoverAnimation: seriesModel.get('hoverAnimation'),
    labelModel: seriesModel.getModel('label'),
    hoverLabelModel: seriesModel.getModel('emphasis.label'),
    cursorStyle: seriesModel.get('cursor')
  };
}

var _default = SymbolDraw;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/createListFromArray.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var List = __webpack_require__("./node_modules/echarts/lib/data/List.js");

var createDimensions = __webpack_require__("./node_modules/echarts/lib/data/helper/createDimensions.js");

var _sourceType = __webpack_require__("./node_modules/echarts/lib/data/helper/sourceType.js");

var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;

var _dimensionHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/dimensionHelper.js");

var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var getDataItemValue = _model.getDataItemValue;

var CoordinateSystem = __webpack_require__("./node_modules/echarts/lib/CoordinateSystem.js");

var _referHelper = __webpack_require__("./node_modules/echarts/lib/model/referHelper.js");

var getCoordSysDefineBySeries = _referHelper.getCoordSysDefineBySeries;

var Source = __webpack_require__("./node_modules/echarts/lib/data/Source.js");

var _dataStackHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/dataStackHelper.js");

var enableDataStack = _dataStackHelper.enableDataStack;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @param {module:echarts/data/Source|Array} source Or raw data.
 * @param {module:echarts/model/Series} seriesModel
 * @param {Object} [opt]
 * @param {string} [opt.generateCoord]
 */
function createListFromArray(source, seriesModel, opt) {
  opt = opt || {};

  if (!Source.isInstance(source)) {
    source = Source.seriesDataToSource(source);
  }

  var coordSysName = seriesModel.get('coordinateSystem');
  var registeredCoordSys = CoordinateSystem.get(coordSysName);
  var coordSysDefine = getCoordSysDefineBySeries(seriesModel);
  var coordSysDimDefs;

  if (coordSysDefine) {
    coordSysDimDefs = zrUtil.map(coordSysDefine.coordSysDims, function (dim) {
      var dimInfo = {
        name: dim
      };
      var axisModel = coordSysDefine.axisMap.get(dim);

      if (axisModel) {
        var axisType = axisModel.get('type');
        dimInfo.type = getDimensionTypeByAxis(axisType); // dimInfo.stackable = isStackable(axisType);
      }

      return dimInfo;
    });
  }

  if (!coordSysDimDefs) {
    // Get dimensions from registered coordinate system
    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];
  }

  var dimInfoList = createDimensions(source, {
    coordDimensions: coordSysDimDefs,
    generateCoord: opt.generateCoord
  });
  var firstCategoryDimIndex;
  var hasNameEncode;
  coordSysDefine && zrUtil.each(dimInfoList, function (dimInfo, dimIndex) {
    var coordDim = dimInfo.coordDim;
    var categoryAxisModel = coordSysDefine.categoryAxisMap.get(coordDim);

    if (categoryAxisModel) {
      if (firstCategoryDimIndex == null) {
        firstCategoryDimIndex = dimIndex;
      }

      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
    }

    if (dimInfo.otherDims.itemName != null) {
      hasNameEncode = true;
    }
  });

  if (!hasNameEncode && firstCategoryDimIndex != null) {
    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
  }

  var stackCalculationInfo = enableDataStack(seriesModel, dimInfoList);
  var list = new List(dimInfoList, seriesModel);
  list.setCalculationInfo(stackCalculationInfo);
  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {
    // Use dataIndex as ordinal value in categoryAxis
    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
  } : null;
  list.hasItemOption = false;
  list.initData(source, null, dimValueGetter);
  return list;
}

function isNeedCompleteOrdinalData(source) {
  if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var sampleItem = firstDataNotNull(source.data || []);
    return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));
  }
}

function firstDataNotNull(data) {
  var i = 0;

  while (i < data.length && data[i] == null) {
    i++;
  }

  return data[i];
}

var _default = createListFromArray;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/createRenderPlanner.js":
/***/ (function(module, exports, __webpack_require__) {

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var makeInner = _model.makeInner;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @return {string} If large mode changed, return string 'reset';
 */
function _default() {
  var inner = makeInner();
  return function (seriesModel) {
    var fields = inner(seriesModel);
    var pipelineContext = seriesModel.pipelineContext;
    var originalLarge = fields.large;
    var originalProgressive = fields.progressiveRender;
    var large = fields.large = pipelineContext.large;
    var progressive = fields.progressiveRender = pipelineContext.progressiveRender;
    return !!(originalLarge ^ large || originalProgressive ^ progressive) && 'reset';
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/labelHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var _dataProvider = __webpack_require__("./node_modules/echarts/lib/data/helper/dataProvider.js");

var retrieveRawValue = _dataProvider.retrieveRawValue;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @param {module:echarts/data/List} data
 * @param {number} dataIndex
 * @return {string} label string. Not null/undefined
 */
function getDefaultLabel(data, dataIndex) {
  var labelDims = data.mapDimension('defaultedLabel', true);
  var len = labelDims.length; // Simple optimization (in lots of cases, label dims length is 1)

  if (len === 1) {
    return retrieveRawValue(data, dataIndex, labelDims[0]);
  } else if (len) {
    var vals = [];

    for (var i = 0; i < labelDims.length; i++) {
      var val = retrieveRawValue(data, dataIndex, labelDims[i]);
      vals.push(val);
    }

    return vals.join(' ');
  }
}

exports.getDefaultLabel = getDefaultLabel;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

__webpack_require__("./node_modules/echarts/lib/chart/line/LineSeries.js");

__webpack_require__("./node_modules/echarts/lib/chart/line/LineView.js");

var visualSymbol = __webpack_require__("./node_modules/echarts/lib/visual/symbol.js");

var layoutPoints = __webpack_require__("./node_modules/echarts/lib/layout/points.js");

var dataSample = __webpack_require__("./node_modules/echarts/lib/processor/dataSample.js");

__webpack_require__("./node_modules/echarts/lib/component/gridSimple.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// In case developer forget to include grid component
echarts.registerVisual(visualSymbol('line', 'circle', 'line'));
echarts.registerLayout(layoutPoints('line')); // Down sample after filter

echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/LineSeries.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var createListFromArray = __webpack_require__("./node_modules/echarts/lib/chart/helper/createListFromArray.js");

var SeriesModel = __webpack_require__("./node_modules/echarts/lib/model/Series.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = SeriesModel.extend({
  type: 'series.line',
  dependencies: ['grid', 'polar'],
  getInitialData: function (option, ecModel) {
    return createListFromArray(this.getSource(), this);
  },
  defaultOption: {
    zlevel: 0,
    z: 2,
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    hoverAnimation: true,
    // stack: null
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // polarIndex: 0,
    // If clip the overflow value
    clipOverflow: true,
    // cursor: null,
    label: {
      position: 'top'
    },
    // itemStyle: {
    // },
    lineStyle: {
      width: 2,
      type: 'solid'
    },
    // areaStyle: {
    // origin of areaStyle. Valid values:
    // `'auto'/null/undefined`: from axisLine to data
    // `'start'`: from min to data
    // `'end'`: from data to max
    // origin: 'auto'
    // },
    // false, 'start', 'end', 'middle'
    step: false,
    // Disabled if step is true
    smooth: false,
    smoothMonotone: null,
    symbol: 'emptyCircle',
    symbolSize: 4,
    symbolRotate: null,
    showSymbol: true,
    // `false`: follow the label interval strategy.
    // `true`: show all symbols.
    // `'auto'`: If possible, show all symbols, otherwise
    //           follow the label interval strategy.
    showAllSymbol: 'auto',
    // Whether to connect break point.
    connectNulls: false,
    // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.
    sampling: 'none',
    animationEasing: 'linear',
    // Disable progressive
    progressive: 0,
    hoverLayerThreshold: Infinity
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/LineView.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var SymbolDraw = __webpack_require__("./node_modules/echarts/lib/chart/helper/SymbolDraw.js");

var SymbolClz = __webpack_require__("./node_modules/echarts/lib/chart/helper/Symbol.js");

var lineAnimationDiff = __webpack_require__("./node_modules/echarts/lib/chart/line/lineAnimationDiff.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var _poly = __webpack_require__("./node_modules/echarts/lib/chart/line/poly.js");

var Polyline = _poly.Polyline;
var Polygon = _poly.Polygon;

var ChartView = __webpack_require__("./node_modules/echarts/lib/view/Chart.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var round = _number.round;

var _helper = __webpack_require__("./node_modules/echarts/lib/chart/line/helper.js");

var prepareDataCoordInfo = _helper.prepareDataCoordInfo;
var getStackedOnPoint = _helper.getStackedOnPoint;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// FIXME step not support polar
function isPointsSame(points1, points2) {
  if (points1.length !== points2.length) {
    return;
  }

  for (var i = 0; i < points1.length; i++) {
    var p1 = points1[i];
    var p2 = points2[i];

    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
      return;
    }
  }

  return true;
}

function getSmooth(smooth) {
  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;
}

function getAxisExtentWithGap(axis) {
  var extent = axis.getGlobalExtent();

  if (axis.onBand) {
    // Remove extra 1px to avoid line miter in clipped edge
    var halfBandWidth = axis.getBandWidth() / 2 - 1;
    var dir = extent[1] > extent[0] ? 1 : -1;
    extent[0] += dir * halfBandWidth;
    extent[1] -= dir * halfBandWidth;
  }

  return extent;
}
/**
 * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys
 * @param {module:echarts/data/List} data
 * @param {Object} dataCoordInfo
 * @param {Array.<Array.<number>>} points
 */


function getStackedOnPoints(coordSys, data, dataCoordInfo) {
  if (!dataCoordInfo.valueDim) {
    return [];
  }

  var points = [];

  for (var idx = 0, len = data.count(); idx < len; idx++) {
    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));
  }

  return points;
}

function createGridClipShape(cartesian, hasAnimation, forSymbol, seriesModel) {
  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));
  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));
  var isHorizontal = cartesian.getBaseAxis().isHorizontal();
  var x = Math.min(xExtent[0], xExtent[1]);
  var y = Math.min(yExtent[0], yExtent[1]);
  var width = Math.max(xExtent[0], xExtent[1]) - x;
  var height = Math.max(yExtent[0], yExtent[1]) - y; // Avoid float number rounding error for symbol on the edge of axis extent.
  // See #7913 and `test/dataZoom-clip.html`.

  if (forSymbol) {
    x -= 0.5;
    width += 0.5;
    y -= 0.5;
    height += 0.5;
  } else {
    var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis

    var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);

    if (isHorizontal) {
      y -= expandSize;
      height += expandSize * 2;
    } else {
      x -= expandSize;
      width += expandSize * 2;
    }
  }

  var clipPath = new graphic.Rect({
    shape: {
      x: x,
      y: y,
      width: width,
      height: height
    }
  });

  if (hasAnimation) {
    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;
    graphic.initProps(clipPath, {
      shape: {
        width: width,
        height: height
      }
    }, seriesModel);
  }

  return clipPath;
}

function createPolarClipShape(polar, hasAnimation, forSymbol, seriesModel) {
  var angleAxis = polar.getAngleAxis();
  var radiusAxis = polar.getRadiusAxis();
  var radiusExtent = radiusAxis.getExtent().slice();
  radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
  var angleExtent = angleAxis.getExtent();
  var RADIAN = Math.PI / 180; // Avoid float number rounding error for symbol on the edge of axis extent.

  if (forSymbol) {
    radiusExtent[0] -= 0.5;
    radiusExtent[1] += 0.5;
  }

  var clipPath = new graphic.Sector({
    shape: {
      cx: round(polar.cx, 1),
      cy: round(polar.cy, 1),
      r0: round(radiusExtent[0], 1),
      r: round(radiusExtent[1], 1),
      startAngle: -angleExtent[0] * RADIAN,
      endAngle: -angleExtent[1] * RADIAN,
      clockwise: angleAxis.inverse
    }
  });

  if (hasAnimation) {
    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;
    graphic.initProps(clipPath, {
      shape: {
        endAngle: -angleExtent[1] * RADIAN
      }
    }, seriesModel);
  }

  return clipPath;
}

function createClipShape(coordSys, hasAnimation, forSymbol, seriesModel) {
  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, forSymbol, seriesModel) : createGridClipShape(coordSys, hasAnimation, forSymbol, seriesModel);
}

function turnPointsIntoStep(points, coordSys, stepTurnAt) {
  var baseAxis = coordSys.getBaseAxis();
  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
  var stepPoints = [];

  for (var i = 0; i < points.length - 1; i++) {
    var nextPt = points[i + 1];
    var pt = points[i];
    stepPoints.push(pt);
    var stepPt = [];

    switch (stepTurnAt) {
      case 'end':
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start

        stepPoints.push(stepPt);
        break;

      case 'middle':
        // default is start
        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        var stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt);
        stepPoints.push(stepPt2);
        break;

      default:
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start

        stepPoints.push(stepPt);
    }
  } // Last points


  points[i] && stepPoints.push(points[i]);
  return stepPoints;
}

function getVisualGradient(data, coordSys) {
  var visualMetaList = data.getVisual('visualMeta');

  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    // When data.count() is 0, gradient range can not be calculated.
    return;
  }

  if (coordSys.type !== 'cartesian2d') {
    return;
  }

  var coordDim;
  var visualMeta;

  for (var i = visualMetaList.length - 1; i >= 0; i--) {
    var dimIndex = visualMetaList[i].dimension;
    var dimName = data.dimensions[dimIndex];
    var dimInfo = data.getDimensionInfo(dimName);
    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y

    if (coordDim === 'x' || coordDim === 'y') {
      visualMeta = visualMetaList[i];
      break;
    }
  }

  if (!visualMeta) {
    return;
  } // If the area to be rendered is bigger than area defined by LinearGradient,
  // the canvas spec prescribes that the color of the first stop and the last
  // stop should be used. But if two stops are added at offset 0, in effect
  // browsers use the color of the second stop to render area outside
  // LinearGradient. So we can only infinitesimally extend area defined in
  // LinearGradient to render `outerColors`.


  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.

  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
      color: stop.color
    };
  });
  var stopLen = colorStops.length;
  var outerColors = visualMeta.outerColors.slice();

  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }

  var tinyExtent = 10; // Arbitrary value: 10px

  var minCoord = colorStops[0].coord - tinyExtent;
  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
  var coordSpan = maxCoord - minCoord;

  if (coordSpan < 1e-3) {
    return 'transparent';
  }

  zrUtil.each(colorStops, function (stop) {
    stop.offset = (stop.coord - minCoord) / coordSpan;
  });
  colorStops.push({
    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
    color: outerColors[1] || 'transparent'
  });
  colorStops.unshift({
    // notice colorStops.length have been changed.
    offset: stopLen ? colorStops[0].offset : 0.5,
    color: outerColors[0] || 'transparent'
  }); // zrUtil.each(colorStops, function (colorStop) {
  //     // Make sure each offset has rounded px to avoid not sharp edge
  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);
  // });

  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
  gradient[coordDim] = minCoord;
  gradient[coordDim + '2'] = maxCoord;
  return gradient;
}

function getIsIgnoreFunc(seriesModel, data, coordSys) {
  var showAllSymbol = seriesModel.get('showAllSymbol');
  var isAuto = showAllSymbol === 'auto';

  if (showAllSymbol && !isAuto) {
    return;
  }

  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

  if (!categoryAxis) {
    return;
  } // Note that category label interval strategy might bring some weird effect
  // in some scenario: users may wonder why some of the symbols are not
  // displayed. So we show all symbols as possible as we can.


  if (isAuto // Simplify the logic, do not determine label overlap here.
  && canShowAllSymbolForCategory(categoryAxis, data)) {
    return;
  } // Otherwise follow the label interval strategy on category axis.


  var categoryDataDim = data.mapDimension(categoryAxis.dim);
  var labelMap = {};
  zrUtil.each(categoryAxis.getViewLabels(), function (labelItem) {
    labelMap[labelItem.tickValue] = 1;
  });
  return function (dataIndex) {
    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
  };
}

function canShowAllSymbolForCategory(categoryAxis, data) {
  // In mose cases, line is monotonous on category axis, and the label size
  // is close with each other. So we check the symbol size and some of the
  // label size alone with the category axis to estimate whether all symbol
  // can be shown without overlap.
  var axisExtent = categoryAxis.getExtent();
  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
  isNaN(availSize) && (availSize = 0); // 0/0 is NaN.
  // Sampling some points, max 5.

  var dataLen = data.count();
  var step = Math.max(1, Math.round(dataLen / 5));

  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
    if (SymbolClz.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.
    )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number
    * 1.5 > availSize) {
      return false;
    }
  }

  return true;
}

var _default = ChartView.extend({
  type: 'line',
  init: function () {
    var lineGroup = new graphic.Group();
    var symbolDraw = new SymbolDraw();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
  },
  render: function (seriesModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var lineStyleModel = seriesModel.getModel('lineStyle');
    var areaStyleModel = seriesModel.getModel('areaStyle');
    var points = data.mapArray(data.getItemLayout);
    var isCoordSysPolar = coordSys.type === 'polar';
    var prevCoordSys = this._coordSys;
    var symbolDraw = this._symbolDraw;
    var polyline = this._polyline;
    var polygon = this._polygon;
    var lineGroup = this._lineGroup;
    var hasAnimation = seriesModel.get('animation');
    var isAreaChart = !areaStyleModel.isEmpty();
    var valueOrigin = areaStyleModel.get('origin');
    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);
    var showSymbol = seriesModel.get('showSymbol');
    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols

    var oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function (el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    }); // Remove previous created symbols if showSymbol changed to false

    if (!showSymbol) {
      symbolDraw.remove();
    }

    group.add(lineGroup); // FIXME step not support polar

    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed

    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: createClipShape(coordSys, false, true, seriesModel)
      });

      if (step) {
        // TODO If stacked series is not step
        points = turnPointsIntoStep(points, coordSys, step);
        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
      }

      polyline = this._newPolyline(points, coordSys, hasAnimation);

      if (isAreaChart) {
        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
      }

      lineGroup.setClipPath(createClipShape(coordSys, true, false, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        // If areaStyle is added
        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
      } else if (polygon && !isAreaChart) {
        // If areaStyle is removed
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      } // Update clipPath


      lineGroup.setClipPath(createClipShape(coordSys, false, false, seriesModel)); // Always update, or it is wrong in the case turning on legend
      // because points are not changed

      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: createClipShape(coordSys, false, true, seriesModel)
      }); // Stop symbol animation and sync with line points
      // FIXME performance?

      data.eachItemGraphicEl(function (el) {
        el.stopAnimation(true);
      }); // In the case data zoom triggerred refreshing frequently
      // Data may not change if line has a category axis. So it should animate nothing

      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
        if (hasAnimation) {
          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);
        } else {
          // Not do it in update with animation
          if (step) {
            // TODO If stacked series is not step
            points = turnPointsIntoStep(points, coordSys, step);
            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
          }

          polyline.setShape({
            points: points
          });
          polygon && polygon.setShape({
            points: points,
            stackedOnPoints: stackedOnPoints
          });
        }
      }
    }

    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');
    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first
    lineStyleModel.getLineStyle(), {
      fill: 'none',
      stroke: visualColor,
      lineJoin: 'bevel'
    }));
    var smooth = seriesModel.get('smooth');
    smooth = getSmooth(seriesModel.get('smooth'));
    polyline.setShape({
      smooth: smooth,
      smoothMonotone: seriesModel.get('smoothMonotone'),
      connectNulls: seriesModel.get('connectNulls')
    });

    if (polygon) {
      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
      var stackedOnSmooth = 0;
      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: 'bevel'
      }));

      if (stackedOnSeries) {
        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
      }

      polygon.setShape({
        smooth: smooth,
        stackedOnSmooth: stackedOnSmooth,
        smoothMonotone: seriesModel.get('smoothMonotone'),
        connectNulls: seriesModel.get('connectNulls')
      });
    }

    this._data = data; // Save the coordinate system for transition animation when data changed

    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points;
    this._step = step;
    this._valueOrigin = valueOrigin;
  },
  dispose: function () {},
  highlight: function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = modelUtil.queryDataIndex(data, payload);

    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);

      if (!symbol) {
        // Create a temporary symbol if it is not exists
        var pt = data.getItemLayout(dataIndex);

        if (!pt) {
          // Null data
          return;
        }

        symbol = new SymbolClz(data, dataIndex);
        symbol.position = pt;
        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation

        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }

      symbol.highlight();
    } else {
      // Highlight whole series
      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
    }
  },
  downplay: function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = modelUtil.queryDataIndex(data, payload);

    if (dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);

      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      // FIXME
      // can not downplay completely.
      // Downplay whole series
      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
    }
  },

  /**
   * @param {module:zrender/container/Group} group
   * @param {Array.<Array.<number>>} points
   * @private
   */
  _newPolyline: function (points) {
    var polyline = this._polyline; // Remove previous created polyline

    if (polyline) {
      this._lineGroup.remove(polyline);
    }

    polyline = new Polyline({
      shape: {
        points: points
      },
      silent: true,
      z2: 10
    });

    this._lineGroup.add(polyline);

    this._polyline = polyline;
    return polyline;
  },

  /**
   * @param {module:zrender/container/Group} group
   * @param {Array.<Array.<number>>} stackedOnPoints
   * @param {Array.<Array.<number>>} points
   * @private
   */
  _newPolygon: function (points, stackedOnPoints) {
    var polygon = this._polygon; // Remove previous created polygon

    if (polygon) {
      this._lineGroup.remove(polygon);
    }

    polygon = new Polygon({
      shape: {
        points: points,
        stackedOnPoints: stackedOnPoints
      },
      silent: true
    });

    this._lineGroup.add(polygon);

    this._polygon = polygon;
    return polygon;
  },

  /**
   * @private
   */
  // FIXME Two value axis
  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {
    var polyline = this._polyline;
    var polygon = this._polygon;
    var seriesModel = data.hostModel;
    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
    var current = diff.current;
    var stackedOnCurrent = diff.stackedOnCurrent;
    var next = diff.next;
    var stackedOnNext = diff.stackedOnNext;

    if (step) {
      // TODO If stacked series is not step
      current = turnPointsIntoStep(diff.current, coordSys, step);
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
      next = turnPointsIntoStep(diff.next, coordSys, step);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
    } // `diff.current` is subset of `current` (which should be ensured by
    // turnPointsIntoStep), so points in `__points` can be updated when
    // points in `current` are update during animation.


    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    graphic.updateProps(polyline, {
      shape: {
        points: next
      }
    }, seriesModel);

    if (polygon) {
      polygon.setShape({
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      graphic.updateProps(polygon, {
        shape: {
          points: next,
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel);
    }

    var updatedDataInfo = [];
    var diffStatus = diff.status;

    for (var i = 0; i < diffStatus.length; i++) {
      var cmd = diffStatus[i].cmd;

      if (cmd === '=') {
        var el = data.getItemGraphicEl(diffStatus[i].idx1);

        if (el) {
          updatedDataInfo.push({
            el: el,
            ptIdx: i // Index of points

          });
        }
      }
    }

    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function () {
        for (var i = 0; i < updatedDataInfo.length; i++) {
          var el = updatedDataInfo[i].el;
          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);
        }
      });
    }
  },
  remove: function (ecModel) {
    var group = this.group;
    var oldData = this._data;

    this._lineGroup.removeAll();

    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting


    oldData && oldData.eachItemGraphicEl(function (el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/helper.js":
/***/ (function(module, exports, __webpack_require__) {

var _dataStackHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/dataStackHelper.js");

var isDimensionStacked = _dataStackHelper.isDimensionStacked;

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var map = _util.map;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @param {Object} coordSys
 * @param {module:echarts/data/List} data
 * @param {string} valueOrigin lineSeries.option.areaStyle.origin
 */
function prepareDataCoordInfo(coordSys, data, valueOrigin) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis = coordSys.getOtherAxis(baseAxis);
  var valueStart = getValueStart(valueAxis, valueOrigin);
  var baseAxisDim = baseAxis.dim;
  var valueAxisDim = valueAxis.dim;
  var valueDim = data.mapDimension(valueAxisDim);
  var baseDim = data.mapDimension(baseAxisDim);
  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;
  var dims = map(coordSys.dimensions, function (coordDim) {
    return data.mapDimension(coordDim);
  });
  var stacked;
  var stackResultDim = data.getCalculationInfo('stackResultDimension');

  if (stacked |= isDimensionStacked(data, dims[0]
  /*, dims[1]*/
  )) {
    // jshint ignore:line
    dims[0] = stackResultDim;
  }

  if (stacked |= isDimensionStacked(data, dims[1]
  /*, dims[0]*/
  )) {
    // jshint ignore:line
    dims[1] = stackResultDim;
  }

  return {
    dataDimsForPoint: dims,
    valueStart: valueStart,
    valueAxisDim: valueAxisDim,
    baseAxisDim: baseAxisDim,
    stacked: !!stacked,
    valueDim: valueDim,
    baseDim: baseDim,
    baseDataOffset: baseDataOffset,
    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')
  };
}

function getValueStart(valueAxis, valueOrigin) {
  var valueStart = 0;
  var extent = valueAxis.scale.getExtent();

  if (valueOrigin === 'start') {
    valueStart = extent[0];
  } else if (valueOrigin === 'end') {
    valueStart = extent[1];
  } // auto
  else {
      // Both positive
      if (extent[0] > 0) {
        valueStart = extent[0];
      } // Both negative
      else if (extent[1] < 0) {
          valueStart = extent[1];
        } // If is one positive, and one negative, onZero shall be true

    }

  return valueStart;
}

function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
  var value = NaN;

  if (dataCoordInfo.stacked) {
    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);
  }

  if (isNaN(value)) {
    value = dataCoordInfo.valueStart;
  }

  var baseDataOffset = dataCoordInfo.baseDataOffset;
  var stackedData = [];
  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
  stackedData[1 - baseDataOffset] = value;
  return coordSys.dataToPoint(stackedData);
}

exports.prepareDataCoordInfo = prepareDataCoordInfo;
exports.getStackedOnPoint = getStackedOnPoint;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/lineAnimationDiff.js":
/***/ (function(module, exports, __webpack_require__) {

var _helper = __webpack_require__("./node_modules/echarts/lib/chart/line/helper.js");

var prepareDataCoordInfo = _helper.prepareDataCoordInfo;
var getStackedOnPoint = _helper.getStackedOnPoint;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// var arrayDiff = require('zrender/src/core/arrayDiff');
// 'zrender/src/core/arrayDiff' has been used before, but it did
// not do well in performance when roam with fixed dataZoom window.
// function convertToIntId(newIdList, oldIdList) {
//     // Generate int id instead of string id.
//     // Compare string maybe slow in score function of arrDiff
//     // Assume id in idList are all unique
//     var idIndicesMap = {};
//     var idx = 0;
//     for (var i = 0; i < newIdList.length; i++) {
//         idIndicesMap[newIdList[i]] = idx;
//         newIdList[i] = idx++;
//     }
//     for (var i = 0; i < oldIdList.length; i++) {
//         var oldId = oldIdList[i];
//         // Same with newIdList
//         if (idIndicesMap[oldId]) {
//             oldIdList[i] = idIndicesMap[oldId];
//         }
//         else {
//             oldIdList[i] = idx++;
//         }
//     }
// }
function diffData(oldData, newData) {
  var diffResult = [];
  newData.diff(oldData).add(function (idx) {
    diffResult.push({
      cmd: '+',
      idx: idx
    });
  }).update(function (newIdx, oldIdx) {
    diffResult.push({
      cmd: '=',
      idx: oldIdx,
      idx1: newIdx
    });
  }).remove(function (idx) {
    diffResult.push({
      cmd: '-',
      idx: idx
    });
  }).execute();
  return diffResult;
}

function _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);
  // var oldIdList = oldData.mapArray(oldData.getId);
  // convertToIntId(newIdList, oldIdList);
  // // FIXME One data ?
  // diff = arrayDiff(oldIdList, newIdList);

  var currPoints = [];
  var nextPoints = []; // Points for stacking base line

  var currStackedPoints = [];
  var nextStackedPoints = [];
  var status = [];
  var sortedIndices = [];
  var rawIndices = [];
  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);

  for (var i = 0; i < diff.length; i++) {
    var diffItem = diff[i];
    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast
    // Which is in case remvoing or add more than one data in the tail or head

    switch (diffItem.cmd) {
      case '=':
        var currentPt = oldData.getItemLayout(diffItem.idx);
        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly

        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
          currentPt = nextPt.slice();
        }

        currPoints.push(currentPt);
        nextPoints.push(nextPt);
        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;

      case '+':
        var idx = diffItem.idx;
        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));
        nextPoints.push(newData.getItemLayout(idx).slice());
        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));
        nextStackedPoints.push(newStackedOnPoints[idx]);
        rawIndices.push(newData.getRawIndex(idx));
        break;

      case '-':
        var idx = diffItem.idx;
        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue
        // FIXME FIXME FIXME

        if (rawIndex !== idx) {
          currPoints.push(oldData.getItemLayout(idx));
          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));
          currStackedPoints.push(oldStackedOnPoints[idx]);
          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));
          rawIndices.push(rawIndex);
        } else {
          pointAdded = false;
        }

    } // Original indices


    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  } // Diff result may be crossed if all items are changed
  // Sort by data index


  sortedIndices.sort(function (a, b) {
    return rawIndices[a] - rawIndices[b];
  });
  var sortedCurrPoints = [];
  var sortedNextPoints = [];
  var sortedCurrStackedPoints = [];
  var sortedNextStackedPoints = [];
  var sortedStatus = [];

  for (var i = 0; i < sortedIndices.length; i++) {
    var idx = sortedIndices[i];
    sortedCurrPoints[i] = currPoints[idx];
    sortedNextPoints[i] = nextPoints[idx];
    sortedCurrStackedPoints[i] = currStackedPoints[idx];
    sortedNextStackedPoints[i] = nextStackedPoints[idx];
    sortedStatus[i] = status[idx];
  }

  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/poly.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var fixClipWithShadow = __webpack_require__("./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Poly path support NaN point
var vec2Min = vec2.min;
var vec2Max = vec2.max;
var scaleAndAdd = vec2.scaleAndAdd;
var v2Copy = vec2.copy; // Temporary variable

var v = [];
var cp0 = [];
var cp1 = [];

function isPointNull(p) {
  return isNaN(p[0]) || isNaN(p[1]);
}

function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
  // if (smoothMonotone == null) {
  //     if (isMono(points, 'x')) {
  //         return drawMono(ctx, points, start, segLen, allLen,
  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);
  //     }
  //     else if (isMono(points, 'y')) {
  //         return drawMono(ctx, points, start, segLen, allLen,
  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);
  //     }
  //     else {
  //         return drawNonMono.apply(this, arguments);
  //     }
  // }
  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {
  //     return drawMono.apply(this, arguments);
  // }
  // else {
  //     return drawNonMono.apply(this, arguments);
  // }
  if (smoothMonotone === 'none' || !smoothMonotone) {
    return drawNonMono.apply(this, arguments);
  } else {
    return drawMono.apply(this, arguments);
  }
}
/**
 * Check if points is in monotone.
 *
 * @param {number[][]} points         Array of points which is in [x, y] form
 * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which
 *                                    dimension that is checking.
 *                                    If is 'none', `drawNonMono` should be
 *                                    called.
 *                                    If is undefined, either being monotone
 *                                    in 'x' or 'y' will call `drawMono`.
 */
// function isMono(points, smoothMonotone) {
//     if (points.length <= 1) {
//         return true;
//     }
//     var dim = smoothMonotone === 'x' ? 0 : 1;
//     var last = points[0][dim];
//     var lastDiff = 0;
//     for (var i = 1; i < points.length; ++i) {
//         var diff = points[i][dim] - last;
//         if (!isNaN(diff) && !isNaN(lastDiff)
//             && diff !== 0 && lastDiff !== 0
//             && ((diff >= 0) !== (lastDiff >= 0))
//         ) {
//             return false;
//         }
//         if (!isNaN(diff) && diff !== 0) {
//             lastDiff = diff;
//             last = points[i][dim];
//         }
//     }
//     return true;
// }

/**
 * Draw smoothed line in monotone, in which only vertical or horizontal bezier
 * control points will be used. This should be used when points are monotone
 * either in x or y dimension.
 */


function drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
  var prevIdx = 0;
  var idx = start;

  for (var k = 0; k < segLen; k++) {
    var p = points[idx];

    if (idx >= allLen || idx < 0) {
      break;
    }

    if (isPointNull(p)) {
      if (connectNulls) {
        idx += dir;
        continue;
      }

      break;
    }

    if (idx === start) {
      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
    } else {
      if (smooth > 0) {
        var prevP = points[prevIdx];
        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both

        var ctrlLen = (p[dim] - prevP[dim]) * smooth;
        v2Copy(cp0, prevP);
        cp0[dim] = prevP[dim] + ctrlLen;
        v2Copy(cp1, p);
        cp1[dim] = p[dim] - ctrlLen;
        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
      } else {
        ctx.lineTo(p[0], p[1]);
      }
    }

    prevIdx = idx;
    idx += dir;
  }

  return k;
}
/**
 * Draw smoothed line in non-monotone, in may cause undesired curve in extreme
 * situations. This should be used when points are non-monotone neither in x or
 * y dimension.
 */


function drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
  var prevIdx = 0;
  var idx = start;

  for (var k = 0; k < segLen; k++) {
    var p = points[idx];

    if (idx >= allLen || idx < 0) {
      break;
    }

    if (isPointNull(p)) {
      if (connectNulls) {
        idx += dir;
        continue;
      }

      break;
    }

    if (idx === start) {
      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
      v2Copy(cp0, p);
    } else {
      if (smooth > 0) {
        var nextIdx = idx + dir;
        var nextP = points[nextIdx];

        if (connectNulls) {
          // Find next point not null
          while (nextP && isPointNull(points[nextIdx])) {
            nextIdx += dir;
            nextP = points[nextIdx];
          }
        }

        var ratioNextSeg = 0.5;
        var prevP = points[prevIdx];
        var nextP = points[nextIdx]; // Last point

        if (!nextP || isPointNull(nextP)) {
          v2Copy(cp1, p);
        } else {
          // If next data is null in not connect case
          if (isPointNull(nextP) && !connectNulls) {
            nextP = p;
          }

          vec2.sub(v, nextP, prevP);
          var lenPrevSeg;
          var lenNextSeg;

          if (smoothMonotone === 'x' || smoothMonotone === 'y') {
            var dim = smoothMonotone === 'x' ? 0 : 1;
            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
            lenNextSeg = Math.abs(p[dim] - nextP[dim]);
          } else {
            lenPrevSeg = vec2.dist(p, prevP);
            lenNextSeg = vec2.dist(p, nextP);
          } // Use ratio of seg length


          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));
        } // Smooth constraint


        vec2Min(cp0, cp0, smoothMax);
        vec2Max(cp0, cp0, smoothMin);
        vec2Min(cp1, cp1, smoothMax);
        vec2Max(cp1, cp1, smoothMin);
        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment

        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);
      } else {
        ctx.lineTo(p[0], p[1]);
      }
    }

    prevIdx = idx;
    idx += dir;
  }

  return k;
}

function getBoundingBox(points, smoothConstraint) {
  var ptMin = [Infinity, Infinity];
  var ptMax = [-Infinity, -Infinity];

  if (smoothConstraint) {
    for (var i = 0; i < points.length; i++) {
      var pt = points[i];

      if (pt[0] < ptMin[0]) {
        ptMin[0] = pt[0];
      }

      if (pt[1] < ptMin[1]) {
        ptMin[1] = pt[1];
      }

      if (pt[0] > ptMax[0]) {
        ptMax[0] = pt[0];
      }

      if (pt[1] > ptMax[1]) {
        ptMax[1] = pt[1];
      }
    }
  }

  return {
    min: smoothConstraint ? ptMin : ptMax,
    max: smoothConstraint ? ptMax : ptMin
  };
}

var Polyline = Path.extend({
  type: 'ec-polyline',
  shape: {
    points: [],
    smooth: 0,
    smoothConstraint: true,
    smoothMonotone: null,
    connectNulls: false
  },
  style: {
    fill: null,
    stroke: '#000'
  },
  brush: fixClipWithShadow(Path.prototype.brush),
  buildPath: function (ctx, shape) {
    var points = shape.points;
    var i = 0;
    var len = points.length;
    var result = getBoundingBox(points, shape.smoothConstraint);

    if (shape.connectNulls) {
      // Must remove first and last null values avoid draw error in polygon
      for (; len > 0; len--) {
        if (!isPointNull(points[len - 1])) {
          break;
        }
      }

      for (; i < len; i++) {
        if (!isPointNull(points[i])) {
          break;
        }
      }
    }

    while (i < len) {
      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  }
});
var Polygon = Path.extend({
  type: 'ec-polygon',
  shape: {
    points: [],
    // Offset between stacked base points and points
    stackedOnPoints: [],
    smooth: 0,
    stackedOnSmooth: 0,
    smoothConstraint: true,
    smoothMonotone: null,
    connectNulls: false
  },
  brush: fixClipWithShadow(Path.prototype.brush),
  buildPath: function (ctx, shape) {
    var points = shape.points;
    var stackedOnPoints = shape.stackedOnPoints;
    var i = 0;
    var len = points.length;
    var smoothMonotone = shape.smoothMonotone;
    var bbox = getBoundingBox(points, shape.smoothConstraint);
    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);

    if (shape.connectNulls) {
      // Must remove first and last null values avoid draw error in polygon
      for (; len > 0; len--) {
        if (!isPointNull(points[len - 1])) {
          break;
        }
      }

      for (; i < len; i++) {
        if (!isPointNull(points[i])) {
          break;
        }
      }
    }

    while (i < len) {
      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i += k + 1;
      ctx.closePath();
    }
  }
});
exports.Polyline = Polyline;
exports.Polygon = Polygon;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/coord/cartesian/AxisModel.js");

__webpack_require__("./node_modules/echarts/lib/component/axis/CartesianAxisView.js");

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/AxisBuilder.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var retrieve = _util.retrieve;
var defaults = _util.defaults;
var extend = _util.extend;
var each = _util.each;

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var isRadianAroundZero = _number.isRadianAroundZero;
var remRadian = _number.remRadian;

var _symbol = __webpack_require__("./node_modules/echarts/lib/util/symbol.js");

var createSymbol = _symbol.createSymbol;

var matrixUtil = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

var _vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var v2ApplyTransform = _vector.applyTransform;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var PI = Math.PI;

function makeAxisEventDataBase(axisModel) {
  var eventData = {
    componentType: axisModel.mainType
  };
  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
  return eventData;
}
/**
 * A final axis is translated and rotated from a "standard axis".
 * So opt.position and opt.rotation is required.
 *
 * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
 * for example: (0, 0) ------------> (0, 50)
 *
 * nameDirection or tickDirection or labelDirection is 1 means tick
 * or label is below the standard axis, whereas is -1 means above
 * the standard axis. labelOffset means offset between label and axis,
 * which is useful when 'onZero', where axisLabel is in the grid and
 * label in outside grid.
 *
 * Tips: like always,
 * positive rotation represents anticlockwise, and negative rotation
 * represents clockwise.
 * The direction of position coordinate is the same as the direction
 * of screen coordinate.
 *
 * Do not need to consider axis 'inverse', which is auto processed by
 * axis extent.
 *
 * @param {module:zrender/container/Group} group
 * @param {Object} axisModel
 * @param {Object} opt Standard axis parameters.
 * @param {Array.<number>} opt.position [x, y]
 * @param {number} opt.rotation by radian
 * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.
 * @param {number} [opt.tickDirection=1] 1 or -1
 * @param {number} [opt.labelDirection=1] 1 or -1
 * @param {number} [opt.labelOffset=0] Usefull when onZero.
 * @param {string} [opt.axisLabelShow] default get from axisModel.
 * @param {string} [opt.axisName] default get from axisModel.
 * @param {number} [opt.axisNameAvailableWidth]
 * @param {number} [opt.labelRotate] by degree, default get from axisModel.
 * @param {number} [opt.strokeContainThreshold] Default label interval when label
 * @param {number} [opt.nameTruncateMaxWidth]
 */


var AxisBuilder = function (axisModel, opt) {
  /**
   * @readOnly
   */
  this.opt = opt;
  /**
   * @readOnly
   */

  this.axisModel = axisModel; // Default value

  defaults(opt, {
    labelOffset: 0,
    nameDirection: 1,
    tickDirection: 1,
    labelDirection: 1,
    silent: true
  });
  /**
   * @readOnly
   */

  this.group = new graphic.Group(); // FIXME Not use a seperate text group?

  var dumbGroup = new graphic.Group({
    position: opt.position.slice(),
    rotation: opt.rotation
  }); // this.group.add(dumbGroup);
  // this._dumbGroup = dumbGroup;

  dumbGroup.updateTransform();
  this._transform = dumbGroup.transform;
  this._dumbGroup = dumbGroup;
};

AxisBuilder.prototype = {
  constructor: AxisBuilder,
  hasBuilder: function (name) {
    return !!builders[name];
  },
  add: function (name) {
    builders[name].call(this);
  },
  getGroup: function () {
    return this.group;
  }
};
var builders = {
  /**
   * @private
   */
  axisLine: function () {
    var opt = this.opt;
    var axisModel = this.axisModel;

    if (!axisModel.get('axisLine.show')) {
      return;
    }

    var extent = this.axisModel.axis.getExtent();
    var matrix = this._transform;
    var pt1 = [extent[0], 0];
    var pt2 = [extent[1], 0];

    if (matrix) {
      v2ApplyTransform(pt1, pt1, matrix);
      v2ApplyTransform(pt2, pt2, matrix);
    }

    var lineStyle = extend({
      lineCap: 'round'
    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());
    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({
      // Id for animation
      anid: 'line',
      shape: {
        x1: pt1[0],
        y1: pt1[1],
        x2: pt2[0],
        y2: pt2[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    })));
    var arrows = axisModel.get('axisLine.symbol');
    var arrowSize = axisModel.get('axisLine.symbolSize');
    var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;

    if (typeof arrowOffset === 'number') {
      arrowOffset = [arrowOffset, arrowOffset];
    }

    if (arrows != null) {
      if (typeof arrows === 'string') {
        // Use the same arrow for start and end point
        arrows = [arrows, arrows];
      }

      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {
        // Use the same size for width and height
        arrowSize = [arrowSize, arrowSize];
      }

      var symbolWidth = arrowSize[0];
      var symbolHeight = arrowSize[1];
      each([{
        rotate: opt.rotation + Math.PI / 2,
        offset: arrowOffset[0],
        r: 0
      }, {
        rotate: opt.rotation - Math.PI / 2,
        offset: arrowOffset[1],
        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
      }], function (point, index) {
        if (arrows[index] !== 'none' && arrows[index] != null) {
          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset

          var r = point.r + point.offset;
          var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];
          symbol.attr({
            rotation: point.rotate,
            position: pos,
            silent: true
          });
          this.group.add(symbol);
        }
      }, this);
    }
  },

  /**
   * @private
   */
  axisTickLabel: function () {
    var axisModel = this.axisModel;
    var opt = this.opt;
    var tickEls = buildAxisTick(this, axisModel, opt);
    var labelEls = buildAxisLabel(this, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, tickEls);
  },

  /**
   * @private
   */
  axisName: function () {
    var opt = this.opt;
    var axisModel = this.axisModel;
    var name = retrieve(opt.axisName, axisModel.get('name'));

    if (!name) {
      return;
    }

    var nameLocation = axisModel.get('nameLocation');
    var nameDirection = opt.nameDirection;
    var textStyleModel = axisModel.getModel('nameTextStyle');
    var gap = axisModel.get('nameGap') || 0;
    var extent = this.axisModel.axis.getExtent();
    var gapSignal = extent[0] > extent[1] ? -1 : 1;
    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'
    // Reuse labelOffset.
    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];
    var labelLayout;
    var nameRotation = axisModel.get('nameRotate');

    if (nameRotation != null) {
      nameRotation = nameRotation * PI / 180; // To radian.
    }

    var axisNameAvailableWidth;

    if (isNameLocationCenter(nameLocation)) {
      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
      nameDirection);
    } else {
      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;

      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }

    var textFont = textStyleModel.getFont();
    var truncateOpt = axisModel.get('nameTruncate', true) || {};
    var ellipsis = truncateOpt.ellipsis;
    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME
    // truncate rich text? (consider performance)

    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {
      minChar: 2,
      placeholder: truncateOpt.placeholder
    }) : name;
    var tooltipOpt = axisModel.get('tooltip', true);
    var mainType = axisModel.mainType;
    var formatterParams = {
      componentType: mainType,
      name: name,
      $vars: ['name']
    };
    formatterParams[mainType + 'Index'] = axisModel.componentIndex;
    var textEl = new graphic.Text({
      // Id for animation
      anid: 'name',
      __fullText: name,
      __truncatedText: truncatedText,
      position: pos,
      rotation: labelLayout.rotation,
      silent: isSilent(axisModel),
      z2: 1,
      tooltip: tooltipOpt && tooltipOpt.show ? extend({
        content: name,
        formatter: function () {
          return name;
        },
        formatterParams: formatterParams
      }, tooltipOpt) : null
    });
    graphic.setTextStyle(textEl.style, textStyleModel, {
      text: truncatedText,
      textFont: textFont,
      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),
      textAlign: labelLayout.textAlign,
      textVerticalAlign: labelLayout.textVerticalAlign
    });

    if (axisModel.get('triggerEvent')) {
      textEl.eventData = makeAxisEventDataBase(axisModel);
      textEl.eventData.targetType = 'axisName';
      textEl.eventData.name = name;
    } // FIXME


    this._dumbGroup.add(textEl);

    textEl.updateTransform();
    this.group.add(textEl);
    textEl.decomposeTransform();
  }
};
/**
 * @public
 * @static
 * @param {Object} opt
 * @param {number} axisRotation in radian
 * @param {number} textRotation in radian
 * @param {number} direction
 * @return {Object} {
 *  rotation, // according to axis
 *  textAlign,
 *  textVerticalAlign
 * }
 */

var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
  var rotationDiff = remRadian(textRotation - axisRotation);
  var textAlign;
  var textVerticalAlign;

  if (isRadianAroundZero(rotationDiff)) {
    // Label is parallel with axis line.
    textVerticalAlign = direction > 0 ? 'top' : 'bottom';
    textAlign = 'center';
  } else if (isRadianAroundZero(rotationDiff - PI)) {
    // Label is inverse parallel with axis line.
    textVerticalAlign = direction > 0 ? 'bottom' : 'top';
    textAlign = 'center';
  } else {
    textVerticalAlign = 'middle';

    if (rotationDiff > 0 && rotationDiff < PI) {
      textAlign = direction > 0 ? 'right' : 'left';
    } else {
      textAlign = direction > 0 ? 'left' : 'right';
    }
  }

  return {
    rotation: rotationDiff,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
};

function endTextLayout(opt, textPosition, textRotate, extent) {
  var rotationDiff = remRadian(textRotate - opt.rotation);
  var textAlign;
  var textVerticalAlign;
  var inverse = extent[0] > extent[1];
  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;

  if (isRadianAroundZero(rotationDiff - PI / 2)) {
    textVerticalAlign = onLeft ? 'bottom' : 'top';
    textAlign = 'center';
  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
    textVerticalAlign = onLeft ? 'top' : 'bottom';
    textAlign = 'center';
  } else {
    textVerticalAlign = 'middle';

    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
      textAlign = onLeft ? 'left' : 'right';
    } else {
      textAlign = onLeft ? 'right' : 'left';
    }
  }

  return {
    rotation: rotationDiff,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}

function isSilent(axisModel) {
  var tooltipOpt = axisModel.get('tooltip');
  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.
  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);
}

function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  // If min or max are user set, we need to check
  // If the tick on min(max) are overlap on their neighbour tick
  // If they are overlapped, we need to hide the min(max) tick label
  var showMinLabel = axisModel.get('axisLabel.showMinLabel');
  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME
  // Have not consider onBand yet, where tick els is more than label els.

  labelEls = labelEls || [];
  tickEls = tickEls || [];
  var firstLabel = labelEls[0];
  var nextLabel = labelEls[1];
  var lastLabel = labelEls[labelEls.length - 1];
  var prevLabel = labelEls[labelEls.length - 2];
  var firstTick = tickEls[0];
  var nextTick = tickEls[1];
  var lastTick = tickEls[tickEls.length - 1];
  var prevTick = tickEls[tickEls.length - 2];

  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }

  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}

function ignoreEl(el) {
  el && (el.ignore = true);
}

function isTwoLabelOverlapped(current, next, labelLayout) {
  // current and next has the same rotation.
  var firstRect = current && current.getBoundingRect().clone();
  var nextRect = next && next.getBoundingRect().clone();

  if (!firstRect || !nextRect) {
    return;
  } // When checking intersect of two rotated labels, we use mRotationBack
  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.


  var mRotationBack = matrixUtil.identity([]);
  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));
  return firstRect.intersect(nextRect);
}

function isNameLocationCenter(nameLocation) {
  return nameLocation === 'middle' || nameLocation === 'center';
}

function buildAxisTick(axisBuilder, axisModel, opt) {
  var axis = axisModel.axis;

  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {
    return;
  }

  var tickModel = axisModel.getModel('axisTick');
  var lineStyleModel = tickModel.getModel('lineStyle');
  var tickLen = tickModel.get('length');
  var ticksCoords = axis.getTicksCoords();
  var pt1 = [];
  var pt2 = [];
  var matrix = axisBuilder._transform;
  var tickEls = [];

  for (var i = 0; i < ticksCoords.length; i++) {
    var tickCoord = ticksCoords[i].coord;
    pt1[0] = tickCoord;
    pt1[1] = 0;
    pt2[0] = tickCoord;
    pt2[1] = opt.tickDirection * tickLen;

    if (matrix) {
      v2ApplyTransform(pt1, pt1, matrix);
      v2ApplyTransform(pt2, pt2, matrix);
    } // Tick line, Not use group transform to have better line draw


    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({
      // Id for animation
      anid: 'tick_' + ticksCoords[i].tickValue,
      shape: {
        x1: pt1[0],
        y1: pt1[1],
        x2: pt2[0],
        y2: pt2[1]
      },
      style: defaults(lineStyleModel.getLineStyle(), {
        stroke: axisModel.get('axisLine.lineStyle.color')
      }),
      z2: 2,
      silent: true
    }));
    axisBuilder.group.add(tickEl);
    tickEls.push(tickEl);
  }

  return tickEls;
}

function buildAxisLabel(axisBuilder, axisModel, opt) {
  var axis = axisModel.axis;
  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));

  if (!show || axis.scale.isBlank()) {
    return;
  }

  var labelModel = axisModel.getModel('axisLabel');
  var labelMargin = labelModel.get('margin');
  var labels = axis.getViewLabels(); // Special label rotate.

  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;
  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  var rawCategoryData = axisModel.getCategories(true);
  var labelEls = [];
  var silent = isSilent(axisModel);
  var triggerEvent = axisModel.get('triggerEvent');
  each(labels, function (labelItem, index) {
    var tickValue = labelItem.tickValue;
    var formattedLabel = labelItem.formattedLabel;
    var rawLabel = labelItem.rawLabel;
    var itemLabelModel = labelModel;

    if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
      itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);
    }

    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');
    var tickCoord = axis.dataToCoord(tickValue);
    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
    var textEl = new graphic.Text({
      // Id for animation
      anid: 'label_' + tickValue,
      position: pos,
      rotation: labelLayout.rotation,
      silent: silent,
      z2: 10
    });
    graphic.setTextStyle(textEl.style, itemLabelModel, {
      text: formattedLabel,
      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original
      // index of axis.data. So tick should not be exposed to user
      // in category axis.
      // (2) Compatible with previous version, which always use formatted label as
      // input. But in interval scale the formatted label is like '223,445', which
      // maked user repalce ','. So we modify it to return original val but remain
      // it as 'string' to avoid error in replacing.
      axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor
    }); // Pack data for mouse event

    if (triggerEvent) {
      textEl.eventData = makeAxisEventDataBase(axisModel);
      textEl.eventData.targetType = 'axisLabel';
      textEl.eventData.value = rawLabel;
    } // FIXME


    axisBuilder._dumbGroup.add(textEl);

    textEl.updateTransform();
    labelEls.push(textEl);
    axisBuilder.group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}

var _default = AxisBuilder;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/AxisView.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var axisPointerModelHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/modelHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Base class of AxisView.
 */
var AxisView = echarts.extendComponentView({
  type: 'axis',

  /**
   * @private
   */
  _axisPointer: null,

  /**
   * @protected
   * @type {string}
   */
  axisPointerClass: null,

  /**
   * @override
   */
  render: function (axisModel, ecModel, api, payload) {
    // FIXME
    // This process should proformed after coordinate systems updated
    // (axis scale updated), and should be performed each time update.
    // So put it here temporarily, although it is not appropriate to
    // put a model-writing procedure in `view`.
    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);
    AxisView.superApply(this, 'render', arguments);
    updateAxisPointer(this, axisModel, ecModel, api, payload, true);
  },

  /**
   * Action handler.
   * @public
   * @param {module:echarts/coord/cartesian/AxisModel} axisModel
   * @param {module:echarts/model/Global} ecModel
   * @param {module:echarts/ExtensionAPI} api
   * @param {Object} payload
   */
  updateAxisPointer: function (axisModel, ecModel, api, payload, force) {
    updateAxisPointer(this, axisModel, ecModel, api, payload, false);
  },

  /**
   * @override
   */
  remove: function (ecModel, api) {
    var axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api);
    AxisView.superApply(this, 'remove', arguments);
  },

  /**
   * @override
   */
  dispose: function (ecModel, api) {
    disposeAxisPointer(this, api);
    AxisView.superApply(this, 'dispose', arguments);
  }
});

function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
  var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);

  if (!Clazz) {
    return;
  }

  var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);
  axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
}

function disposeAxisPointer(axisView, ecModel, api) {
  var axisPointer = axisView._axisPointer;
  axisPointer && axisPointer.dispose(ecModel, api);
  axisView._axisPointer = null;
}

var axisPointerClazz = [];

AxisView.registerAxisPointerClass = function (type, clazz) {
  axisPointerClazz[type] = clazz;
};

AxisView.getAxisPointerClass = function (type) {
  return type && axisPointerClazz[type];
};

var _default = AxisView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/CartesianAxisView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var AxisBuilder = __webpack_require__("./node_modules/echarts/lib/component/axis/AxisBuilder.js");

var AxisView = __webpack_require__("./node_modules/echarts/lib/component/axis/AxisView.js");

var cartesianAxisHelper = __webpack_require__("./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
var selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {
//     var alignWithLabel = model.get('alignWithLabel');
//     if (alignWithLabel === 'auto') {
//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');
//     }
//     return alignWithLabel;
// }

var CartesianAxisView = AxisView.extend({
  type: 'cartesianAxis',
  axisPointerClass: 'CartesianAxisPointer',

  /**
   * @override
   */
  render: function (axisModel, ecModel, api, payload) {
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new graphic.Group();
    this.group.add(this._axisGroup);

    if (!axisModel.get('show')) {
      return;
    }

    var gridModel = axisModel.getCoordSysModel();
    var layout = cartesianAxisHelper.layout(gridModel, axisModel);
    var axisBuilder = new AxisBuilder(axisModel, layout);
    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);

    this._axisGroup.add(axisBuilder.getGroup());

    zrUtil.each(selfBuilderAttrs, function (name) {
      if (axisModel.get(name + '.show')) {
        this['_' + name](axisModel, gridModel);
      }
    }, this);
    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);
  },
  remove: function () {
    this._splitAreaColors = null;
  },

  /**
   * @param {module:echarts/coord/cartesian/AxisModel} axisModel
   * @param {module:echarts/coord/cartesian/GridModel} gridModel
   * @private
   */
  _splitLine: function (axisModel, gridModel) {
    var axis = axisModel.axis;

    if (axis.scale.isBlank()) {
      return;
    }

    var splitLineModel = axisModel.getModel('splitLine');
    var lineStyleModel = splitLineModel.getModel('lineStyle');
    var lineColors = lineStyleModel.get('color');
    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p1 = [];
    var p2 = []; // Simple optimization
    // Batching the lines if color are the same

    var lineStyle = lineStyleModel.getLineStyle();

    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);

      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }

      var colorIndex = lineCount++ % lineColors.length;
      var tickValue = ticksCoords[i].tickValue;

      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({
        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        style: zrUtil.defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      })));
    }
  },

  /**
   * @param {module:echarts/coord/cartesian/AxisModel} axisModel
   * @param {module:echarts/coord/cartesian/GridModel} gridModel
   * @private
   */
  _splitArea: function (axisModel, gridModel) {
    var axis = axisModel.axis;

    if (axis.scale.isBlank()) {
      return;
    }

    var splitAreaModel = axisModel.getModel('splitArea');
    var areaStyleModel = splitAreaModel.getModel('areaStyle');
    var areaColors = areaStyleModel.get('color');
    var gridRect = gridModel.coordinateSystem.getRect();
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitAreaModel,
      clamp: true
    });

    if (!ticksCoords.length) {
      return;
    } // For Making appropriate splitArea animation, the color and anid
    // should be corresponding to previous one if possible.


    var areaColorsLen = areaColors.length;
    var lastSplitAreaColors = this._splitAreaColors;
    var newSplitAreaColors = zrUtil.createHashMap();
    var colorIndex = 0;

    if (lastSplitAreaColors) {
      for (var i = 0; i < ticksCoords.length; i++) {
        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);

        if (cIndex != null) {
          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
          break;
        }
      }
    }

    var prev = axis.toGlobalCoord(ticksCoords[0].coord);
    var areaStyle = areaStyleModel.getAreaStyle();
    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];

    for (var i = 1; i < ticksCoords.length; i++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      var x;
      var y;
      var width;
      var height;

      if (axis.isHorizontal()) {
        x = prev;
        y = gridRect.y;
        width = tickCoord - x;
        height = gridRect.height;
        prev = x + width;
      } else {
        x = gridRect.x;
        y = prev;
        width = gridRect.width;
        height = tickCoord - y;
        prev = y + height;
      }

      var tickValue = ticksCoords[i - 1].tickValue;
      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);

      this._axisGroup.add(new graphic.Rect({
        anid: tickValue != null ? 'area_' + tickValue : null,
        shape: {
          x: x,
          y: y,
          width: width,
          height: height
        },
        style: zrUtil.defaults({
          fill: areaColors[colorIndex]
        }, areaStyle),
        silent: true
      }));

      colorIndex = (colorIndex + 1) % areaColorsLen;
    }

    this._splitAreaColors = newSplitAreaColors;
  }
});
CartesianAxisView.extend({
  type: 'xAxis'
});
CartesianAxisView.extend({
  type: 'yAxis'
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var axisPointerModelHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/modelHelper.js");

var axisTrigger = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/axisTrigger.js");

__webpack_require__("./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js");

__webpack_require__("./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js");

__webpack_require__("./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// CartesianAxisPointer is not supposed to be required here. But consider
// echarts.simple.js and online build tooltip, which only require gridSimple,
// CartesianAxisPointer should be able to required somewhere.
echarts.registerPreprocessor(function (option) {
  // Always has a global axisPointerModel for default setting.
  if (option) {
    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
    var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link
    // is not set, remain null/undefined, otherwise it will
    // override existent link setting.

    if (link && !zrUtil.isArray(link)) {
      option.axisPointer.link = [link];
    }
  }
}); // This process should proformed after coordinate systems created
// and series data processed. So put it on statistic processing stage.

echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
  // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
  // allAxesInfo should be updated when setOption performed.
  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);
}); // Broadcast to all views.

echarts.registerAction({
  type: 'updateAxisPointer',
  event: 'updateAxisPointer',
  update: ':updateAxisPointer'
}, axisTrigger);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var AxisPointerModel = echarts.extendComponentModel({
  type: 'axisPointer',
  coordSysAxesInfo: null,
  defaultOption: {
    // 'auto' means that show when triggered by tooltip or handle.
    show: 'auto',
    // 'click' | 'mousemove' | 'none'
    triggerOn: null,
    // set default in AxisPonterView.js
    zlevel: 0,
    z: 50,
    type: 'line',
    // axispointer triggered by tootip determine snap automatically,
    // see `modelHelper`.
    snap: false,
    triggerTooltip: true,
    value: null,
    status: null,
    // Init value depends on whether handle is used.
    // [group0, group1, ...]
    // Each group can be: {
    //      mapper: function () {},
    //      singleTooltip: 'multiple',  // 'multiple' or 'single'
    //      xAxisId: ...,
    //      yAxisName: ...,
    //      angleAxisIndex: ...
    // }
    // mapper: can be ignored.
    //      input: {axisInfo, value}
    //      output: {axisInfo, value}
    link: [],
    // Do not set 'auto' here, otherwise global animation: false
    // will not effect at this axispointer.
    animation: null,
    animationDurationUpdate: 200,
    lineStyle: {
      color: '#aaa',
      width: 1,
      type: 'solid'
    },
    shadowStyle: {
      color: 'rgba(150,150,150,0.3)'
    },
    label: {
      show: true,
      formatter: null,
      // string | Function
      precision: 'auto',
      // Or a number like 0, 1, 2 ...
      margin: 3,
      color: '#fff',
      padding: [5, 7, 5, 7],
      backgroundColor: 'auto',
      // default: axis line color
      borderColor: null,
      borderWidth: 0,
      shadowBlur: 3,
      shadowColor: '#aaa' // Considering applicability, common style should
      // better not have shadowOffset.
      // shadowOffsetX: 0,
      // shadowOffsetY: 2

    },
    handle: {
      show: false,
      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
      // jshint ignore:line
      size: 45,
      // handle margin is from symbol center to axis, which is stable when circular move.
      margin: 50,
      // color: '#1b8bbd'
      // color: '#2f4554'
      color: '#333',
      shadowBlur: 3,
      shadowColor: '#aaa',
      shadowOffsetX: 0,
      shadowOffsetY: 2,
      // For mobile performance
      throttle: 40
    }
  }
});
var _default = AxisPointerModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var globalListener = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/globalListener.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var AxisPointerView = echarts.extendComponentView({
  type: 'axisPointer',
  render: function (globalAxisPointerModel, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent('tooltip');
    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable
    // AxisPointerView to be independent to Tooltip.

    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {
      // If 'none', it is not controlled by mouse totally.
      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction({
          type: 'updateAxisPointer',
          currTrigger: currTrigger,
          x: e && e.offsetX,
          y: e && e.offsetY
        });
      }
    });
  },

  /**
   * @override
   */
  remove: function (ecModel, api) {
    globalListener.unregister(api.getZr(), 'axisPointer');
    AxisPointerView.superApply(this._model, 'remove', arguments);
  },

  /**
   * @override
   */
  dispose: function (ecModel, api) {
    globalListener.unregister('axisPointer', api);
    AxisPointerView.superApply(this._model, 'dispose', arguments);
  }
});
var _default = AxisPointerView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var clazzUtil = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var axisPointerModelHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/modelHelper.js");

var eventTool = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var throttleUtil = __webpack_require__("./node_modules/echarts/lib/util/throttle.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var makeInner = _model.makeInner;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var inner = makeInner();
var clone = zrUtil.clone;
var bind = zrUtil.bind;
/**
 * Base axis pointer class in 2D.
 * Implemenents {module:echarts/component/axis/IAxisPointer}.
 */

function BaseAxisPointer() {}

BaseAxisPointer.prototype = {
  /**
   * @private
   */
  _group: null,

  /**
   * @private
   */
  _lastGraphicKey: null,

  /**
   * @private
   */
  _handle: null,

  /**
   * @private
   */
  _dragging: false,

  /**
   * @private
   */
  _lastValue: null,

  /**
   * @private
   */
  _lastStatus: null,

  /**
   * @private
   */
  _payloadInfo: null,

  /**
   * In px, arbitrary value. Do not set too small,
   * no animation is ok for most cases.
   * @protected
   */
  animationThreshold: 15,

  /**
   * @implement
   */
  render: function (axisModel, axisPointerModel, api, forceRender) {
    var value = axisPointerModel.get('value');
    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not
    // be replaced when user calling setOption in not merge mode.

    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api; // Optimize: `render` will be called repeatly during mouse move.
    // So it is power consuming if performing `render` each time,
    // especially on mobile device.

    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }

    this._lastValue = value;
    this._lastStatus = status;
    var group = this._group;
    var handle = this._handle;

    if (!status || status === 'hide') {
      // Do not clear here, for animation better.
      group && group.hide();
      handle && handle.hide();
      return;
    }

    group && group.show();
    handle && handle.show(); // Otherwise status is 'show'

    var elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.

    var graphicKey = elOption.graphicKey;

    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api);
    }

    this._lastGraphicKey = graphicKey;
    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);

    if (!group) {
      group = this._group = new graphic.Group();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api.getZr().add(group);
    } else {
      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }

    updateMandatoryProps(group, axisPointerModel, true);

    this._renderHandle(value);
  },

  /**
   * @implement
   */
  remove: function (api) {
    this.clear(api);
  },

  /**
   * @implement
   */
  dispose: function (api) {
    this.clear(api);
  },

  /**
   * @protected
   */
  determineAnimation: function (axisModel, axisPointerModel) {
    var animation = axisPointerModel.get('animation');
    var axis = axisModel.axis;
    var isCategoryAxis = axis.type === 'category';
    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.

    if (!useSnap && !isCategoryAxis) {
      return false;
    }

    if (animation === 'auto' || animation == null) {
      var animationThreshold = this.animationThreshold;

      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      } // It is important to auto animation when snap used. Consider if there is
      // a dataZoom, animation will be disabled when too many points exist, while
      // it will be enabled for better visual effect when little points exist.


      if (useSnap) {
        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;
        var axisExtent = axis.getExtent(); // Approximate band width

        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }

      return false;
    }

    return animation === true;
  },

  /**
   * add {pointer, label, graphicKey} to elOption
   * @protected
   */
  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.
  },

  /**
   * @protected
   */
  createPointerEl: function (group, elOption, axisModel, axisPointerModel) {
    var pointerOption = elOption.pointer;

    if (pointerOption) {
      var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));
      group.add(pointerEl);
    }
  },

  /**
   * @protected
   */
  createLabelEl: function (group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      var labelEl = inner(group).labelEl = new graphic.Rect(clone(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  },

  /**
   * @protected
   */
  updatePointerEl: function (group, elOption, updateProps) {
    var pointerEl = inner(group).pointerEl;

    if (pointerEl) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps(pointerEl, {
        shape: elOption.pointer.shape
      });
    }
  },

  /**
   * @protected
   */
  updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {
    var labelEl = inner(group).labelEl;

    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps(labelEl, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        shape: elOption.label.shape,
        position: elOption.label.position
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  },

  /**
   * @private
   */
  _renderHandle: function (value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }

    var axisPointerModel = this._axisPointerModel;

    var zr = this._api.getZr();

    var handle = this._handle;
    var handleModel = axisPointerModel.getModel('handle');
    var status = axisPointerModel.get('status');

    if (!handleModel.get('show') || !status || status === 'hide') {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }

    var isInit;

    if (!this._handle) {
      isInit = true;
      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {
        cursor: 'move',
        draggable: true,
        onmousemove: function (e) {
          // Fot mobile devicem, prevent screen slider on the button.
          eventTool.stop(e.event);
        },
        onmousedown: bind(this._onHandleDragMove, this, 0, 0),
        drift: bind(this._onHandleDragMove, this),
        ondragend: bind(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }

    updateMandatoryProps(handle, axisPointerModel, false); // update style

    var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];
    handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position

    var handleSize = handleModel.get('size');

    if (!zrUtil.isArray(handleSize)) {
      handleSize = [handleSize, handleSize];
    }

    handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);
    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');

    this._moveHandleToValue(value, isInit);
  },

  /**
   * @private
   */
  _moveHandleToValue: function (value, isInit) {
    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  },

  /**
   * @private
   */
  _onHandleDragMove: function (dx, dy) {
    var handle = this._handle;

    if (!handle) {
      return;
    }

    this._dragging = true; // Persistent for throttle.

    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    inner(handle).lastProp = null;

    this._doDispatchAxisPointer();
  },

  /**
   * Throttled method.
   * @private
   */
  _doDispatchAxisPointer: function () {
    var handle = this._handle;

    if (!handle) {
      return;
    }

    var payloadInfo = this._payloadInfo;
    var axisModel = this._axisModel;

    this._api.dispatchAction({
      type: 'updateAxisPointer',
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  },

  /**
   * @private
   */
  _onHandleDragEnd: function (moveAnimation) {
    this._dragging = false;
    var handle = this._handle;

    if (!handle) {
      return;
    }

    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with
    // axisPointer. So move handle to align the exact value position when
    // drag ended.


    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle
    // button, and will be hidden after finger left handle button.


    this._api.dispatchAction({
      type: 'hideTip'
    });
  },

  /**
   * Should be implemenented by sub-class if support `handle`.
   * @protected
   * @param {number} value
   * @param {module:echarts/model/Model} axisModel
   * @param {module:echarts/model/Model} axisPointerModel
   * @return {Object} {position: [x, y], rotation: 0}
   */
  getHandleTransform: null,

  /**
   * * Should be implemenented by sub-class if support `handle`.
   * @protected
   * @param {Object} transform {position, rotation}
   * @param {Array.<number>} delta [dx, dy]
   * @param {module:echarts/model/Model} axisModel
   * @param {module:echarts/model/Model} axisPointerModel
   * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}
   */
  updateHandleTransform: null,

  /**
   * @private
   */
  clear: function (api) {
    this._lastValue = null;
    this._lastStatus = null;
    var zr = api.getZr();
    var group = this._group;
    var handle = this._handle;

    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
  },

  /**
   * @protected
   */
  doClear: function () {// Implemented by sub-class if necessary.
  },

  /**
   * @protected
   * @param {Array.<number>} xy
   * @param {Array.<number>} wh
   * @param {number} [xDimIndex=0] or 1
   */
  buildLabel: function (xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  }
};
BaseAxisPointer.prototype.constructor = BaseAxisPointer;

function updateProps(animationModel, moveAnimation, el, props) {
  // Animation optimize.
  if (!propsEqual(inner(el).lastProp, props)) {
    inner(el).lastProp = props;
    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
  }
}

function propsEqual(lastProps, newProps) {
  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {
    var equals = true;
    zrUtil.each(newProps, function (item, key) {
      equals = equals && propsEqual(lastProps[key], item);
    });
    return !!equals;
  } else {
    return lastProps === newProps;
  }
}

function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();
}

function getHandleTransProps(trans) {
  return {
    position: trans.position.slice(),
    rotation: trans.rotation || 0
  };
}

function updateMandatoryProps(group, axisPointerModel, silent) {
  var z = axisPointerModel.get('z');
  var zlevel = axisPointerModel.get('zlevel');
  group && group.traverse(function (el) {
    if (el.type !== 'group') {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}

clazzUtil.enableClassExtend(BaseAxisPointer);
var _default = BaseAxisPointer;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js":
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var BaseAxisPointer = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js");

var viewHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/viewHelper.js");

var cartesianAxisHelper = __webpack_require__("./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js");

var AxisView = __webpack_require__("./node_modules/echarts/lib/component/axis/AxisView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var CartesianAxisPointer = BaseAxisPointer.extend({
  /**
   * @override
   */
  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisPointerType = axisPointerModel.get('type');
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));

    if (axisPointerType && axisPointerType !== 'none') {
      var elStyle = viewHelper.buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }

    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);
    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
  },

  /**
   * @override
   */
  getHandleTransform: function (value, axisModel, axisPointerModel) {
    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get('handle.margin');
    return {
      position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  },

  /**
   * @override
   */
  updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisExtent = axis.getGlobalExtent(true);
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var dimIndex = axis.dim === 'x' ? 0 : 1;
    var currPosition = transform.position;
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.

    var tooltipOptions = [{
      verticalAlign: 'middle'
    }, {
      align: 'center'
    }];
    return {
      position: currPosition,
      rotation: transform.rotation,
      cursorPoint: cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  }
});

function getCartesian(grid, axis) {
  var opt = {};
  opt[axis.dim + 'AxisIndex'] = axis.index;
  return grid.getCartesian(opt);
}

var pointerShapeBuilder = {
  line: function (axis, pixelValue, otherExtent, elStyle) {
    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    graphic.subPixelOptimizeLine({
      shape: targetShape,
      style: elStyle
    });
    return {
      type: 'Line',
      shape: targetShape
    };
  },
  shadow: function (axis, pixelValue, otherExtent, elStyle) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: 'Rect',
      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};

function getAxisDimIndex(axis) {
  return axis.dim === 'x' ? 0 : 1;
}

AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);
var _default = CartesianAxisPointer;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/axisTrigger.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var makeInner = _model.makeInner;

var modelHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/modelHelper.js");

var findPointFromSeries = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var each = zrUtil.each;
var curry = zrUtil.curry;
var inner = makeInner();
/**
 * Basic logic: check all axis, if they do not demand show/highlight,
 * then hide/downplay them.
 *
 * @param {Object} coordSysAxesInfo
 * @param {Object} payload
 * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'
 * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to
 *              trigger axisPointer and tooltip.
 * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to
 *              trigger axisPointer and tooltip.
 * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.
 * @param {Object} [payload.dataIndex] finder, restrict target axes.
 * @param {Object} [payload.axesInfo] finder, restrict target axes.
 *        [{
 *          axisDim: 'x'|'y'|'angle'|...,
 *          axisIndex: ...,
 *          value: ...
 *        }, ...]
 * @param {Function} [payload.dispatchAction]
 * @param {Object} [payload.tooltipOption]
 * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,
 *        which can be specified in dispatchAction
 * @param {module:echarts/model/Global} ecModel
 * @param {module:echarts/ExtensionAPI} api
 * @return {Object} content of event obj for echarts.connect.
 */

function _default(payload, ecModel, api) {
  var currTrigger = payload.currTrigger;
  var point = [payload.x, payload.y];
  var finder = payload;
  var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending
  // See #6121. But we are not able to reproduce it yet.

  if (!coordSysAxesInfo) {
    return;
  }

  if (illegalPoint(point)) {
    // Used in the default behavior of `connection`: use the sample seriesIndex
    // and dataIndex. And also used in the tooltipView trigger.
    point = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }

  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
  // Notice: In this case, it is difficult to get the `point` (which is necessary to show
  // tooltip, so if point is not given, we just use the point found by sample seriesIndex
  // and dataIndex.

  var inputAxesInfo = finder.axesInfo;
  var axesInfo = coordSysAxesInfo.axesInfo;
  var shouldHide = currTrigger === 'leave' || illegalPoint(point);
  var outputFinder = {};
  var showValueMap = {};
  var dataByCoordSys = {
    list: [],
    map: {}
  };
  var updaters = {
    showPointer: curry(showPointer, showValueMap),
    showTooltip: curry(showTooltip, dataByCoordSys)
  }; // Process for triggered axes.

  each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
    // If a point given, it must be contained by the coordinate system.
    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
      var axis = axisInfo.axis;
      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.

      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        var val = inputAxisInfo && inputAxisInfo.value;

        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point);
        }

        val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);
      }
    });
  }); // Process for linked axes.

  var linkTriggers = {};
  each(axesInfo, function (tarAxisInfo, tarKey) {
    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.

    if (linkGroup && !showValueMap[tarKey]) {
      each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.

        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          var val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  each(linkTriggers, function (val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);
  });
  updateModelActually(showValueMap, axesInfo, outputFinder);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
  dispatchHighDownActually(axesInfo, dispatchAction, api);
  return outputFinder;
}

function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
  var axis = axisInfo.axis;

  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }

  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  } // Heavy calculation. So put it after axis.containData checking.


  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  var payloadBatch = payloadInfo.payloadBatch;
  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.
  // By defualt use the first involved series data as a sample to connect.

  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    zrUtil.extend(outputFinder, payloadBatch[0]);
  } // If no linkSource input, this process is for collecting link
  // target, where snap should not be accepted.


  if (!dontSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }

  updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be
  // incorrect "axis value ~ series value" mapping displayed in tooltip.

  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}

function buildPayloadsBySeries(value, axisInfo) {
  var axis = axisInfo.axis;
  var dim = axis.dim;
  var snapToValue = value;
  var payloadBatch = [];
  var minDist = Number.MAX_VALUE;
  var minDiff = -1;
  each(axisInfo.seriesModels, function (series, idx) {
    var dataDim = series.getData().mapDimension(dim, true);
    var seriesNestestValue;
    var dataIndices;

    if (series.getAxisTooltipData) {
      var result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex
      // when data length is not same.
      // false,
      axis.type === 'category' ? 0.5 : null);

      if (!dataIndices.length) {
        return;
      }

      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }

    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }

    var diff = value - seriesNestestValue;
    var dist = Math.abs(diff); // Consider category case

    if (dist <= minDist) {
      if (dist < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }

      each(dataIndices, function (dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch: payloadBatch,
    snapToValue: snapToValue
  };
}

function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value: value,
    payloadBatch: payloadBatch
  };
}

function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  var payloadBatch = payloadInfo.payloadBatch;
  var axis = axisInfo.axis;
  var axisModel = axis.model;
  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,
  // whose length will be used to judge whether dispatch action.

  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }

  var coordSysModel = axisInfo.coordSys.model;
  var coordSysKey = modelHelper.makeKey(coordSysModel);
  var coordSysItem = dataByCoordSys.map[coordSysKey];

  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }

  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value: value,
    // Caustion: viewHelper.getValueLabel is actually on "view stage", which
    // depends that all models have been updated. So it should not be performed
    // here. Considering axisPointerModel used here is volatile, which is hard
    // to be retrieve in TooltipView, we prepare parameters here.
    valueLabelOpt: {
      precision: axisPointerModel.get('label.precision'),
      formatter: axisPointerModel.get('label.formatter')
    },
    seriesDataIndices: payloadBatch.slice()
  });
}

function updateModelActually(showValueMap, axesInfo, outputFinder) {
  var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.

  each(axesInfo, function (axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    var valItem = showValueMap[key];

    if (valItem) {
      !axisInfo.useHandle && (option.status = 'show');
      option.value = valItem.value; // For label formatter param and highlight.

      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } // When always show (e.g., handle used), remain
    // original value and status.
    else {
        // If hide, value still need to be set, consider
        // click legend to toggle axis blank.
        !axisInfo.useHandle && (option.status = 'hide');
      } // If status is 'hide', should be no info in payload.


    option.status === 'show' && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}

function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
  // Basic logic: If no showTip required, hideTip will be dispatched.
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction({
      type: 'hideTip'
    });
    return;
  } // In most case only one axis (or event one series is used). It is
  // convinient to fetch payload.seriesIndex and payload.dataIndex
  // dirtectly. So put the first seriesIndex and dataIndex of the first
  // axis on the payload.


  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction({
    type: 'showTip',
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}

function dispatchHighDownActually(axesInfo, dispatchAction, api) {
  // FIXME
  // highlight status modification shoule be a stage of main process?
  // (Consider confilct (e.g., legend and axisPointer) and setOption)
  var zr = api.getZr();
  var highDownKey = 'axisPointerLastHighlights';
  var lastHighlights = inner(zr)[highDownKey] || {};
  var newHighlights = inner(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.
  // Build hash map and remove duplicate incidentally.

  each(axesInfo, function (axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {
      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;
      newHighlights[key] = batchItem;
    });
  }); // Diff.

  var toHighlight = [];
  var toDownplay = [];
  zrUtil.each(lastHighlights, function (batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  zrUtil.each(newHighlights, function (batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api.dispatchAction({
    type: 'downplay',
    escapeConnect: true,
    batch: toDownplay
  });
  toHighlight.length && api.dispatchAction({
    type: 'highlight',
    escapeConnect: true,
    batch: toHighlight
  });
}

function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (var i = 0; i < (inputAxesInfo || []).length; i++) {
    var inputAxisInfo = inputAxesInfo[i];

    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}

function makeMapperParam(axisInfo) {
  var axisModel = axisInfo.axis.model;
  var item = {};
  var dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;
  item.axisName = item[dim + 'AxisName'] = axisModel.name;
  item.axisId = item[dim + 'AxisId'] = axisModel.id;
  return item;
}

function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}
 * @param {module:echarts/model/Global} ecModel
 * @return {Object} {point: [x, y], el: ...} point Will not be null.
 */
function _default(finder, ecModel) {
  var point = [];
  var seriesIndex = finder.seriesIndex;
  var seriesModel;

  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }

  var data = seriesModel.getData();
  var dataIndex = modelUtil.queryDataIndex(data, finder);

  if (dataIndex == null || dataIndex < 0 || zrUtil.isArray(dataIndex)) {
    return {
      point: []
    };
  }

  var el = data.getItemGraphicEl(dataIndex);
  var coordSys = seriesModel.coordinateSystem;

  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {
      return data.mapDimension(dim);
    }), dataIndex, true)) || [];
  } else if (el) {
    // Use graphic bounding rect
    var rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }

  return {
    point: point,
    el: el
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/globalListener.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var makeInner = _model.makeInner;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var inner = makeInner();
var each = zrUtil.each;
/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 * @param {Function} handler
 *      param: {string} currTrigger
 *      param: {Array.<number>} point
 */

function register(key, api, handler) {
  if (env.node) {
    return;
  }

  var zr = api.getZr();
  inner(zr).records || (inner(zr).records = {});
  initGlobalListeners(zr, api);
  var record = inner(zr).records[key] || (inner(zr).records[key] = {});
  record.handler = handler;
}

function initGlobalListeners(zr, api) {
  if (inner(zr).initialized) {
    return;
  }

  inner(zr).initialized = true;
  useHandler('click', zrUtil.curry(doEnter, 'click'));
  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);

  useHandler('globalout', onLeave);

  function useHandler(eventType, cb) {
    zr.on(eventType, function (e) {
      var dis = makeDispatchAction(api);
      each(inner(zr).records, function (record) {
        record && cb(record, e, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api);
    });
  }
}

function dispatchTooltipFinally(pendings, api) {
  var showLen = pendings.showTip.length;
  var hideLen = pendings.hideTip.length;
  var actuallyPayload;

  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }

  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api.dispatchAction(actuallyPayload);
  }
}

function onLeave(record, e, dispatchAction) {
  record.handler('leave', null, dispatchAction);
}

function doEnter(currTrigger, record, e, dispatchAction) {
  record.handler(currTrigger, e, dispatchAction);
}

function makeDispatchAction(api) {
  var pendings = {
    showTip: [],
    hideTip: []
  }; // FIXME
  // better approach?
  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
  // So we have to add "final stage" to merge those dispatched actions.

  var dispatchAction = function (payload) {
    var pendingList = pendings[payload.type];

    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction;
      api.dispatchAction(payload);
    }
  };

  return {
    dispatchAction: dispatchAction,
    pendings: pendings
  };
}
/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 */


function unregister(key, api) {
  if (env.node) {
    return;
  }

  var zr = api.getZr();
  var record = (inner(zr).records || {})[key];

  if (record) {
    inner(zr).records[key] = null;
  }
}

exports.register = register;
exports.unregister = unregister;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/modelHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var each = zrUtil.each;
var curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
// allAxesInfo should be updated when setOption performed.

function collect(ecModel, api) {
  var result = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: false,

    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.

  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}

function collectAxesInfo(result, ecModel, api) {
  var globalTooltipModel = ecModel.getComponent('tooltip');
  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.

  var linksOption = globalAxisPointerModel.get('link', true) || [];
  var linkGroups = []; // Collect axes info.

  each(api.getCoordinateSystems(), function (coordSys) {
    // Some coordinate system do not support axes, like geo.
    if (!coordSys.axisPointerEnabled) {
      return;
    }

    var coordSysKey = makeKey(coordSys.model);
    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer
    // for user. So we enable seting tooltip on coordSys model.

    var coordSysModel = coordSys.model;
    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);
    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.
    // Notice this case: coordSys is `grid` but not `cartesian2D` here.

    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not
    // show but axisPointer will show as normal.
    && baseTooltipModel.get('show')) {
      // Compatible with previous logic. But series.tooltip.trigger: 'axis'
      // or series.data[n].tooltip.trigger: 'axis' are not support any more.
      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';
      var cross = baseTooltipModel.get('axisPointer.type') === 'cross';
      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));

      if (triggerAxis || cross) {
        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));
      }

      if (cross) {
        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));
      }
    } // fromTooltip: true | false | 'cross'
    // triggerTooltip: true | false | null


    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);
      var axisPointerShow = axisPointerModel.get('show');

      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }

      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get('triggerTooltip');
      }

      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      var snap = axisPointerModel.get('snap');
      var key = makeKey(axis.model);
      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).

      var axisInfo = result.axesInfo[key] = {
        key: key,
        axis: axis,
        coordSys: coordSys,
        axisPointerModel: axisPointerModel,
        triggerTooltip: triggerTooltip,
        involveSeries: involveSeries,
        snap: snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: []
      };
      axesInfoInCoordSys[key] = axisInfo;
      result.seriesInvolved |= involveSeries;
      var groupIndex = getLinkGroupIndex(linksOption, axis);

      if (groupIndex != null) {
        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
          axesInfo: {}
        });
        linkGroup.axesInfo[key] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}

function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');
  var volatileOption = {};
  each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {
    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));
  }); // category axis do not auto snap, otherwise some tick that do not
  // has value can not be hovered. value/time/log axis default snap if
  // triggered from tooltip and trigger tooltip.

  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.
  // Only these properties can be overrided from tooltip to axisPointer.

  if (tooltipAxisPointerModel.get('type') === 'cross') {
    volatileOption.type = 'line';
  }

  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.

  labelOption.show == null && (labelOption.show = false);

  if (fromTooltip === 'cross') {
    // When 'cross', both axes show labels.
    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get('label.show');
    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true; // If triggerTooltip, this is a base axis, which should better not use cross style
    // (cross style is dashed by default)

    if (!triggerTooltip) {
      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');
      crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);
    }
  }

  return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));
}

function collectSeriesInfo(result, ecModel) {
  // Prepare data for axis trigger
  ecModel.eachSeries(function (seriesModel) {
    // Notice this case: this coordSys is `cartesian2D` but not `grid`.
    var coordSys = seriesModel.coordinateSystem;
    var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);
    var seriesTooltipShow = seriesModel.get('tooltip.show', true);

    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {
      return;
    }

    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
      var axis = axisInfo.axis;

      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  }, this);
}
/**
 * For example:
 * {
 *     axisPointer: {
 *         links: [{
 *             xAxisIndex: [2, 4],
 *             yAxisIndex: 'all'
 *         }, {
 *             xAxisId: ['a5', 'a7'],
 *             xAxisName: 'xxx'
 *         }]
 *     }
 * }
 */


function getLinkGroupIndex(linksOption, axis) {
  var axisModel = axis.model;
  var dim = axis.dim;

  for (var i = 0; i < linksOption.length; i++) {
    var linkOption = linksOption[i] || {};

    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
      return i;
    }
  }
}

function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}

function fixValue(axisModel) {
  var axisInfo = getAxisInfo(axisModel);

  if (!axisInfo) {
    return;
  }

  var axisPointerModel = axisInfo.axisPointerModel;
  var scale = axisInfo.axis.scale;
  var option = axisPointerModel.option;
  var status = axisPointerModel.get('status');
  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.

  if (value != null) {
    value = scale.parse(value);
  }

  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value
  // and status should be initialized.

  if (status == null) {
    option.status = useHandle ? 'show' : 'hide';
  }

  var extent = scale.getExtent().slice();
  extent[0] > extent[1] && extent.reverse();

  if ( // Pick a value on axis when initializing.
  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,
  // where we should re-pick a value to keep `handle` displaying normally.
  || value > extent[1]) {
    // Make handle displayed on the end of the axis when init, which looks better.
    value = extent[1];
  }

  if (value < extent[0]) {
    value = extent[0];
  }

  option.value = value;

  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';
  }
}

function getAxisInfo(axisModel) {
  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}

function getAxisPointerModel(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}

function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get('handle.show');
}
/**
 * @param {module:echarts/model/Model} model
 * @return {string} unique key
 */


function makeKey(model) {
  return model.type + '||' + model.id;
}

exports.collect = collect;
exports.fixValue = fixValue;
exports.getAxisInfo = getAxisInfo;
exports.getAxisPointerModel = getAxisPointerModel;
exports.makeKey = makeKey;

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/viewHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var matrix = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

var axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

var AxisBuilder = __webpack_require__("./node_modules/echarts/lib/component/axis/AxisBuilder.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @param {module:echarts/model/Model} axisPointerModel
 */
function buildElStyle(axisPointerModel) {
  var axisPointerType = axisPointerModel.get('type');
  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');
  var style;

  if (axisPointerType === 'line') {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === 'shadow') {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }

  return style;
}
/**
 * @param {Function} labelPos {align, verticalAlign, position}
 */


function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
  var value = axisPointerModel.get('value');
  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
    precision: axisPointerModel.get('label.precision'),
    formatter: axisPointerModel.get('label.formatter')
  });
  var labelModel = axisPointerModel.getModel('label');
  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);
  var font = labelModel.getFont();
  var textRect = textContain.getBoundingRect(text, font);
  var position = labelPos.position;
  var width = textRect.width + paddings[1] + paddings[3];
  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.

  var align = labelPos.align;
  align === 'right' && (position[0] -= width);
  align === 'center' && (position[0] -= width / 2);
  var verticalAlign = labelPos.verticalAlign;
  verticalAlign === 'bottom' && (position[1] -= height);
  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container

  confineInContainer(position, width, height, api);
  var bgColor = labelModel.get('backgroundColor');

  if (!bgColor || bgColor === 'auto') {
    bgColor = axisModel.get('axisLine.lineStyle.color');
  }

  elOption.label = {
    shape: {
      x: 0,
      y: 0,
      width: width,
      height: height,
      r: labelModel.get('borderRadius')
    },
    position: position.slice(),
    // TODO: rich
    style: {
      text: text,
      textFont: font,
      textFill: labelModel.getTextColor(),
      textPosition: 'inside',
      fill: bgColor,
      stroke: labelModel.get('borderColor') || 'transparent',
      lineWidth: labelModel.get('borderWidth') || 0,
      shadowBlur: labelModel.get('shadowBlur'),
      shadowColor: labelModel.get('shadowColor'),
      shadowOffsetX: labelModel.get('shadowOffsetX'),
      shadowOffsetY: labelModel.get('shadowOffsetY')
    },
    // Lable should be over axisPointer.
    z2: 10
  };
} // Do not overflow ec container


function confineInContainer(position, width, height, api) {
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  position[0] = Math.min(position[0] + width, viewWidth) - width;
  position[1] = Math.min(position[1] + height, viewHeight) - height;
  position[0] = Math.max(position[0], 0);
  position[1] = Math.max(position[1], 0);
}
/**
 * @param {number} value
 * @param {module:echarts/coord/Axis} axis
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} opt
 * @param {Array.<Object>} seriesDataIndices
 * @param {number|string} opt.precision 'auto' or a number
 * @param {string|Function} opt.formatter label formatter
 */


function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  value = axis.scale.parse(value);
  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which
  // helps to debounce when when moving label.
  value, {
    precision: opt.precision
  });
  var formatter = opt.formatter;

  if (formatter) {
    var params = {
      value: axisHelper.getAxisRawValue(axis, value),
      seriesData: []
    };
    zrUtil.each(seriesDataIndices, function (idxItem) {
      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      var dataIndex = idxItem.dataIndexInside;
      var dataParams = series && series.getDataParams(dataIndex);
      dataParams && params.seriesData.push(dataParams);
    });

    if (zrUtil.isString(formatter)) {
      text = formatter.replace('{value}', text);
    } else if (zrUtil.isFunction(formatter)) {
      text = formatter(params);
    }
  }

  return text;
}
/**
 * @param {module:echarts/coord/Axis} axis
 * @param {number} value
 * @param {Object} layoutInfo {
 *  rotation, position, labelOffset, labelDirection, labelMargin
 * }
 */


function getTransformedPosition(axis, value, layoutInfo) {
  var transform = matrix.create();
  matrix.rotate(transform, transform, layoutInfo.rotation);
  matrix.translate(transform, transform, layoutInfo.position);
  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
}

function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get('label.margin');
  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
/**
 * @param {Array.<number>} p1
 * @param {Array.<number>} p2
 * @param {number} [xDimIndex=0] or 1
 */


function makeLineShape(p1, p2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p2[xDimIndex],
    y2: p2[1 - xDimIndex]
  };
}
/**
 * @param {Array.<number>} xy
 * @param {Array.<number>} wh
 * @param {number} [xDimIndex=0] or 1
 */


function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}

function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
  return {
    cx: cx,
    cy: cy,
    r0: r0,
    r: r,
    startAngle: startAngle,
    endAngle: endAngle,
    clockwise: true
  };
}

exports.buildElStyle = buildElStyle;
exports.buildLabelElOption = buildLabelElOption;
exports.getValueLabel = getValueLabel;
exports.getTransformedPosition = getTransformedPosition;
exports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;
exports.makeLineShape = makeLineShape;
exports.makeRectShape = makeRectShape;
exports.makeSectorShape = makeSectorShape;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/AxisProxy.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var helper = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/helper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var each = zrUtil.each;
var asc = numberUtil.asc;
/**
 * Operate single axis.
 * One axis can only operated by one axis operator.
 * Different dataZoomModels may be defined to operate the same axis.
 * (i.e. 'inside' data zoom and 'slider' data zoom components)
 * So dataZoomModels share one axisProxy in that case.
 *
 * @class
 */

var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {
  /**
   * @private
   * @type {string}
   */
  this._dimName = dimName;
  /**
   * @private
   */

  this._axisIndex = axisIndex;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._valueWindow;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._percentWindow;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._dataExtent;
  /**
   * {minSpan, maxSpan, minValueSpan, maxValueSpan}
   * @private
   * @type {Object}
   */

  this._minMaxSpan;
  /**
   * @readOnly
   * @type {module: echarts/model/Global}
   */

  this.ecModel = ecModel;
  /**
   * @private
   * @type {module: echarts/component/dataZoom/DataZoomModel}
   */

  this._dataZoomModel = dataZoomModel; // /**
  //  * @readOnly
  //  * @private
  //  */
  // this.hasSeriesStacked;
};

AxisProxy.prototype = {
  constructor: AxisProxy,

  /**
   * Whether the axisProxy is hosted by dataZoomModel.
   *
   * @public
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   * @return {boolean}
   */
  hostedBy: function (dataZoomModel) {
    return this._dataZoomModel === dataZoomModel;
  },

  /**
   * @return {Array.<number>} Value can only be NaN or finite value.
   */
  getDataValueWindow: function () {
    return this._valueWindow.slice();
  },

  /**
   * @return {Array.<number>}
   */
  getDataPercentWindow: function () {
    return this._percentWindow.slice();
  },

  /**
   * @public
   * @param {number} axisIndex
   * @return {Array} seriesModels
   */
  getTargetSeriesModels: function () {
    var seriesModels = [];
    var ecModel = this.ecModel;
    ecModel.eachSeries(function (seriesModel) {
      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {
        var dimName = this._dimName;
        var axisModel = ecModel.queryComponents({
          mainType: dimName + 'Axis',
          index: seriesModel.get(dimName + 'AxisIndex'),
          id: seriesModel.get(dimName + 'AxisId')
        })[0];

        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {
          seriesModels.push(seriesModel);
        }
      }
    }, this);
    return seriesModels;
  },
  getAxisModel: function () {
    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);
  },
  getOtherAxisModel: function () {
    var axisDim = this._dimName;
    var ecModel = this.ecModel;
    var axisModel = this.getAxisModel();
    var isCartesian = axisDim === 'x' || axisDim === 'y';
    var otherAxisDim;
    var coordSysIndexName;

    if (isCartesian) {
      coordSysIndexName = 'gridIndex';
      otherAxisDim = axisDim === 'x' ? 'y' : 'x';
    } else {
      coordSysIndexName = 'polarIndex';
      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';
    }

    var foundOtherAxisModel;
    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {
      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {
        foundOtherAxisModel = otherAxisModel;
      }
    });
    return foundOtherAxisModel;
  },
  getMinMaxSpan: function () {
    return zrUtil.clone(this._minMaxSpan);
  },

  /**
   * Only calculate by given range and this._dataExtent, do not change anything.
   *
   * @param {Object} opt
   * @param {number} [opt.start]
   * @param {number} [opt.end]
   * @param {number} [opt.startValue]
   * @param {number} [opt.endValue]
   */
  calculateDataWindow: function (opt) {
    var dataExtent = this._dataExtent;
    var axisModel = this.getAxisModel();
    var scale = axisModel.axis.scale;

    var rangePropMode = this._dataZoomModel.getRangePropMode();

    var percentExtent = [0, 100];
    var percentWindow = [opt.start, opt.end];
    var valueWindow = [];
    each(['startValue', 'endValue'], function (prop) {
      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);
    }); // Normalize bound.

    each([0, 1], function (idx) {
      var boundValue = valueWindow[idx];
      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or
      // on `valueProp` ('startValue', 'endValue'). The former one is suitable
      // for cases that a dataZoom component controls multiple axes with different
      // unit or extent, and the latter one is suitable for accurate zoom by pixel
      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,
      // but it is awkward that `percentProp` can not be obtained from `valueProp`
      // accurately (because all of values that are overflow the `dataExtent` will
      // be calculated to percent '100%'). So we have to use
      // `dataZoom.getRangePropMode()` to mark which prop is used.
      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise
      // it remains its original value.

      if (rangePropMode[idx] === 'percent') {
        if (boundPercent == null) {
          boundPercent = percentExtent[idx];
        } // Use scale.parse to math round for category or time axis.


        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));
      } else {
        // Calculating `percent` from `value` may be not accurate, because
        // This calculation can not be inversed, because all of values that
        // are overflow the `dataExtent` will be calculated to percent '100%'
        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);
      } // valueWindow[idx] = round(boundValue);
      // percentWindow[idx] = round(boundPercent);


      valueWindow[idx] = boundValue;
      percentWindow[idx] = boundPercent;
    });
    return {
      valueWindow: asc(valueWindow),
      percentWindow: asc(percentWindow)
    };
  },

  /**
   * Notice: reset should not be called before series.restoreData() called,
   * so it is recommanded to be called in "process stage" but not "model init
   * stage".
   *
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   */
  reset: function (dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }

    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.

    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;
    // each(targetSeries, function (series) {
    // var data = series.getData();
    // var dataDim = data.mapDimension(this._dimName);
    // var stackedDimension = data.getCalculationInfo('stackedDimension');
    // if (stackedDimension && stackedDimension === dataDim) {
    // this.hasSeriesStacked = true;
    // }
    // }, this);

    var dataWindow = this.calculateDataWindow(dataZoomModel.option);
    this._valueWindow = dataWindow.valueWindow;
    this._percentWindow = dataWindow.percentWindow;
    setMinMaxSpan(this); // Update axis setting then.

    setAxisModel(this);
  },

  /**
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   */
  restore: function (dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }

    this._valueWindow = this._percentWindow = null;
    setAxisModel(this, true);
  },

  /**
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   */
  filterData: function (dataZoomModel, api) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }

    var axisDim = this._dimName;
    var seriesModels = this.getTargetSeriesModels();
    var filterMode = dataZoomModel.get('filterMode');
    var valueWindow = this._valueWindow;

    if (filterMode === 'none') {
      return;
    } // FIXME
    // Toolbox may has dataZoom injected. And if there are stacked bar chart
    // with NaN data, NaN will be filtered and stack will be wrong.
    // So we need to force the mode to be set empty.
    // In fect, it is not a big deal that do not support filterMode-'filter'
    // when using toolbox#dataZoom, utill tooltip#dataZoom support "single axis
    // selection" some day, which might need "adapt to data extent on the
    // otherAxis", which is disabled by filterMode-'empty'.
    // But currently, stack has been fixed to based on value but not index,
    // so this is not an issue any more.
    // var otherAxisModel = this.getOtherAxisModel();
    // if (dataZoomModel.get('$fromToolbox')
    //     && otherAxisModel
    //     && otherAxisModel.hasSeriesStacked
    // ) {
    //     filterMode = 'empty';
    // }
    // TODO
    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.
    // Process series data


    each(seriesModels, function (seriesModel) {
      var seriesData = seriesModel.getData();
      var dataDims = seriesData.mapDimension(axisDim, true);

      if (filterMode === 'weakFilter') {
        seriesData.filterSelf(function (dataIndex) {
          var leftOut;
          var rightOut;
          var hasValue;

          for (var i = 0; i < dataDims.length; i++) {
            var value = seriesData.get(dataDims[i], dataIndex);
            var thisHasValue = !isNaN(value);
            var thisLeftOut = value < valueWindow[0];
            var thisRightOut = value > valueWindow[1];

            if (thisHasValue && !thisLeftOut && !thisRightOut) {
              return true;
            }

            thisHasValue && (hasValue = true);
            thisLeftOut && (leftOut = true);
            thisRightOut && (rightOut = true);
          } // If both left out and right out, do not filter.


          return hasValue && leftOut && rightOut;
        });
      } else {
        each(dataDims, function (dim) {
          if (filterMode === 'empty') {
            seriesModel.setData(seriesData.map(dim, function (value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            var range = {};
            range[dim] = valueWindow; // console.time('select');

            seriesData.selectRange(range); // console.timeEnd('select');
          }
        });
      }

      each(dataDims, function (dim) {
        seriesData.setApproximateExtent(valueWindow, dim);
      });
    });

    function isInWindow(value) {
      return value >= valueWindow[0] && value <= valueWindow[1];
    }
  }
};

function calculateDataExtent(axisProxy, axisDim, seriesModels) {
  var dataExtent = [Infinity, -Infinity];
  each(seriesModels, function (seriesModel) {
    var seriesData = seriesModel.getData();

    if (seriesData) {
      each(seriesData.mapDimension(axisDim, true), function (dim) {
        var seriesExtent = seriesData.getApproximateExtent(dim);
        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
      });
    }
  });

  if (dataExtent[1] < dataExtent[0]) {
    dataExtent = [NaN, NaN];
  } // It is important to get "consistent" extent when more then one axes is
  // controlled by a `dataZoom`, otherwise those axes will not be synchronized
  // when zooming. But it is difficult to know what is "consistent", considering
  // axes have different type or even different meanings (For example, two
  // time axes are used to compare data of the same date in different years).
  // So basically dataZoom just obtains extent by series.data (in category axis
  // extent can be obtained from axis.data).
  // Nevertheless, user can set min/max/scale on axes to make extent of axes
  // consistent.


  fixExtentByAxis(axisProxy, dataExtent);
  return dataExtent;
}

function fixExtentByAxis(axisProxy, dataExtent) {
  var axisModel = axisProxy.getAxisModel();
  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined
  // by axis.data by default.

  var isCategoryAxis = axisModel.get('type') === 'category';
  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;

  if (min != null && min !== 'dataMin' && typeof min !== 'function') {
    dataExtent[0] = min;
  } else if (isCategoryAxis) {
    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;
  }

  var max = axisModel.getMax(true);

  if (max != null && max !== 'dataMax' && typeof max !== 'function') {
    dataExtent[1] = max;
  } else if (isCategoryAxis) {
    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;
  }

  if (!axisModel.get('scale', true)) {
    dataExtent[0] > 0 && (dataExtent[0] = 0);
    dataExtent[1] < 0 && (dataExtent[1] = 0);
  } // For value axis, if min/max/scale are not set, we just use the extent obtained
  // by series data, which may be a little different from the extent calculated by
  // `axisHelper.getScaleExtent`. But the different just affects the experience a
  // little when zooming. So it will not be fixed until some users require it strongly.


  return dataExtent;
}

function setAxisModel(axisProxy, isRestore) {
  var axisModel = axisProxy.getAxisModel();
  var percentWindow = axisProxy._percentWindow;
  var valueWindow = axisProxy._valueWindow;

  if (!percentWindow) {
    return;
  } // [0, 500]: arbitrary value, guess axis extent.


  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);
  precision = Math.min(precision, 20); // isRestore or isFull

  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;
  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
}

function setMinMaxSpan(axisProxy) {
  var minMaxSpan = axisProxy._minMaxSpan = {};
  var dataZoomModel = axisProxy._dataZoomModel;
  each(['min', 'max'], function (minMax) {
    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan

    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');

    if (valueSpan != null) {
      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;
      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);

      if (valueSpan != null) {
        var dataExtent = axisProxy._dataExtent;
        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      }
    }
  });
}

var _default = AxisProxy;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var helper = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/helper.js");

var AxisProxy = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/AxisProxy.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var each = zrUtil.each;
var eachAxisDim = helper.eachAxisDim;
var DataZoomModel = echarts.extendComponentModel({
  type: 'dataZoom',
  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],

  /**
   * @protected
   */
  defaultOption: {
    zlevel: 0,
    z: 4,
    // Higher than normal component (z: 2).
    orient: null,
    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.
    xAxisIndex: null,
    // Default the first horizontal category axis.
    yAxisIndex: null,
    // Default the first vertical category axis.
    filterMode: 'filter',
    // Possible values: 'filter' or 'empty' or 'weakFilter'.
    // 'filter': data items which are out of window will be removed. This option is
    //          applicable when filtering outliers. For each data item, it will be
    //          filtered if one of the relevant dimensions is out of the window.
    // 'weakFilter': data items which are out of window will be removed. This option
    //          is applicable when filtering outliers. For each data item, it will be
    //          filtered only if all  of the relevant dimensions are out of the same
    //          side of the window.
    // 'empty': data items which are out of window will be set to empty.
    //          This option is applicable when user should not neglect
    //          that there are some data items out of window.
    // 'none': Do not filter.
    // Taking line chart as an example, line will be broken in
    // the filtered points when filterModel is set to 'empty', but
    // be connected when set to 'filter'.
    throttle: null,
    // Dispatch action by the fixed rate, avoid frequency.
    // default 100. Do not throttle when use null/undefined.
    // If animation === true and animationDurationUpdate > 0,
    // default value is 100, otherwise 20.
    start: 0,
    // Start percent. 0 ~ 100
    end: 100,
    // End percent. 0 ~ 100
    startValue: null,
    // Start value. If startValue specified, start is ignored.
    endValue: null,
    // End value. If endValue specified, end is ignored.
    minSpan: null,
    // 0 ~ 100
    maxSpan: null,
    // 0 ~ 100
    minValueSpan: null,
    // The range of dataZoom can not be smaller than that.
    maxValueSpan: null,
    // The range of dataZoom can not be larger than that.
    rangeMode: null // Array, can be 'value' or 'percent'.

  },

  /**
   * @override
   */
  init: function (option, parentModel, ecModel) {
    /**
     * key like x_0, y_1
     * @private
     * @type {Object}
     */
    this._dataIntervalByAxis = {};
    /**
     * @private
     */

    this._dataInfo = {};
    /**
     * key like x_0, y_1
     * @private
     */

    this._axisProxies = {};
    /**
     * @readOnly
     */

    this.textStyleModel;
    /**
     * @private
     */

    this._autoThrottle = true;
    /**
     * 'percent' or 'value'
     * @private
     */

    this._rangePropMode = ['percent', 'percent'];
    var rawOption = retrieveRaw(option);
    this.mergeDefaultAndTheme(option, ecModel);
    this.doInit(rawOption);
  },

  /**
   * @override
   */
  mergeOption: function (newOption) {
    var rawOption = retrieveRaw(newOption); //FIX #2591

    zrUtil.merge(this.option, newOption, true);
    this.doInit(rawOption);
  },

  /**
   * @protected
   */
  doInit: function (rawOption) {
    var thisOption = this.option; // Disable realtime view update if canvas is not supported.

    if (!env.canvasSupported) {
      thisOption.realtime = false;
    }

    this._setDefaultThrottle(rawOption);

    updateRangeUse(this, rawOption);
    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
      // start/end has higher priority over startValue/endValue if they
      // both set, but we should make chart.setOption({endValue: 1000})
      // effective, rather than chart.setOption({endValue: 1000, end: null}).
      if (this._rangePropMode[index] === 'value') {
        thisOption[names[0]] = null;
      } // Otherwise do nothing and use the merge result.

    }, this);
    this.textStyleModel = this.getModel('textStyle');

    this._resetTarget();

    this._giveAxisProxies();
  },

  /**
   * @private
   */
  _giveAxisProxies: function () {
    var axisProxies = this._axisProxies;
    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {
      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.

      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.
      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME
      // dispose __dzAxisProxy

      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;
    }, this);
  },

  /**
   * @private
   */
  _resetTarget: function () {
    var thisOption = this.option;

    var autoMode = this._judgeAutoMode();

    eachAxisDim(function (dimNames) {
      var axisIndexName = dimNames.axisIndex;
      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);
    }, this);

    if (autoMode === 'axisIndex') {
      this._autoSetAxisIndex();
    } else if (autoMode === 'orient') {
      this._autoSetOrient();
    }
  },

  /**
   * @private
   */
  _judgeAutoMode: function () {
    // Auto set only works for setOption at the first time.
    // The following is user's reponsibility. So using merged
    // option is OK.
    var thisOption = this.option;
    var hasIndexSpecified = false;
    eachAxisDim(function (dimNames) {
      // When user set axisIndex as a empty array, we think that user specify axisIndex
      // but do not want use auto mode. Because empty array may be encountered when
      // some error occured.
      if (thisOption[dimNames.axisIndex] != null) {
        hasIndexSpecified = true;
      }
    }, this);
    var orient = thisOption.orient;

    if (orient == null && hasIndexSpecified) {
      return 'orient';
    } else if (!hasIndexSpecified) {
      if (orient == null) {
        thisOption.orient = 'horizontal';
      }

      return 'axisIndex';
    }
  },

  /**
   * @private
   */
  _autoSetAxisIndex: function () {
    var autoAxisIndex = true;
    var orient = this.get('orient', true);
    var thisOption = this.option;
    var dependentModels = this.dependentModels;

    if (autoAxisIndex) {
      // Find axis that parallel to dataZoom as default.
      var dimName = orient === 'vertical' ? 'y' : 'x';

      if (dependentModels[dimName + 'Axis'].length) {
        thisOption[dimName + 'AxisIndex'] = [0];
        autoAxisIndex = false;
      } else {
        each(dependentModels.singleAxis, function (singleAxisModel) {
          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {
            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];
            autoAxisIndex = false;
          }
        });
      }
    }

    if (autoAxisIndex) {
      // Find the first category axis as default. (consider polar)
      eachAxisDim(function (dimNames) {
        if (!autoAxisIndex) {
          return;
        }

        var axisIndices = [];
        var axisModels = this.dependentModels[dimNames.axis];

        if (axisModels.length && !axisIndices.length) {
          for (var i = 0, len = axisModels.length; i < len; i++) {
            if (axisModels[i].get('type') === 'category') {
              axisIndices.push(i);
            }
          }
        }

        thisOption[dimNames.axisIndex] = axisIndices;

        if (axisIndices.length) {
          autoAxisIndex = false;
        }
      }, this);
    }

    if (autoAxisIndex) {
      // FIXME
      // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），
      // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？
      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,
      // dataZoom component auto adopts series that reference to
      // both xAxis and yAxis which type is 'value'.
      this.ecModel.eachSeries(function (seriesModel) {
        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {
          eachAxisDim(function (dimNames) {
            var axisIndices = thisOption[dimNames.axisIndex];
            var axisIndex = seriesModel.get(dimNames.axisIndex);
            var axisId = seriesModel.get(dimNames.axisId);
            var axisModel = seriesModel.ecModel.queryComponents({
              mainType: dimNames.axis,
              index: axisIndex,
              id: axisId
            })[0];
            axisIndex = axisModel.componentIndex;

            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {
              axisIndices.push(axisIndex);
            }
          });
        }
      }, this);
    }
  },

  /**
   * @private
   */
  _autoSetOrient: function () {
    var dim; // Find the first axis

    this.eachTargetAxis(function (dimNames) {
      !dim && (dim = dimNames.name);
    }, this);
    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';
  },

  /**
   * @private
   */
  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {
    // FIXME
    // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。
    // 例如series.type === scatter时。
    var is = true;
    eachAxisDim(function (dimNames) {
      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);
      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];

      if (!axisModel || axisModel.get('type') !== axisType) {
        is = false;
      }
    }, this);
    return is;
  },

  /**
   * @private
   */
  _setDefaultThrottle: function (rawOption) {
    // When first time user set throttle, auto throttle ends.
    if (rawOption.hasOwnProperty('throttle')) {
      this._autoThrottle = false;
    }

    if (this._autoThrottle) {
      var globalOption = this.ecModel.option;
      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
    }
  },

  /**
   * @public
   */
  getFirstTargetAxisModel: function () {
    var firstAxisModel;
    eachAxisDim(function (dimNames) {
      if (firstAxisModel == null) {
        var indices = this.get(dimNames.axisIndex);

        if (indices.length) {
          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];
        }
      }
    }, this);
    return firstAxisModel;
  },

  /**
   * @public
   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
   */
  eachTargetAxis: function (callback, context) {
    var ecModel = this.ecModel;
    eachAxisDim(function (dimNames) {
      each(this.get(dimNames.axisIndex), function (axisIndex) {
        callback.call(context, dimNames, axisIndex, this, ecModel);
      }, this);
    }, this);
  },

  /**
   * @param {string} dimName
   * @param {number} axisIndex
   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.
   */
  getAxisProxy: function (dimName, axisIndex) {
    return this._axisProxies[dimName + '_' + axisIndex];
  },

  /**
   * @param {string} dimName
   * @param {number} axisIndex
   * @return {module:echarts/model/Model} If not found, return null/undefined.
   */
  getAxisModel: function (dimName, axisIndex) {
    var axisProxy = this.getAxisProxy(dimName, axisIndex);
    return axisProxy && axisProxy.getAxisModel();
  },

  /**
   * If not specified, set to undefined.
   *
   * @public
   * @param {Object} opt
   * @param {number} [opt.start]
   * @param {number} [opt.end]
   * @param {number} [opt.startValue]
   * @param {number} [opt.endValue]
   * @param {boolean} [ignoreUpdateRangeUsg=false]
   */
  setRawRange: function (opt, ignoreUpdateRangeUsg) {
    var option = this.option;
    each([['start', 'startValue'], ['end', 'endValue']], function (names) {
      // If only one of 'start' and 'startValue' is not null/undefined, the other
      // should be cleared, which enable clear the option.
      // If both of them are not set, keep option with the original value, which
      // enable use only set start but not set end when calling `dispatchAction`.
      // The same as 'end' and 'endValue'.
      if (opt[names[0]] != null || opt[names[1]] != null) {
        option[names[0]] = opt[names[0]];
        option[names[1]] = opt[names[1]];
      }
    }, this);
    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);
  },

  /**
   * @public
   * @return {Array.<number>} [startPercent, endPercent]
   */
  getPercentRange: function () {
    var axisProxy = this.findRepresentativeAxisProxy();

    if (axisProxy) {
      return axisProxy.getDataPercentWindow();
    }
  },

  /**
   * @public
   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
   *
   * @param {string} [axisDimName]
   * @param {number} [axisIndex]
   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.
   */
  getValueRange: function (axisDimName, axisIndex) {
    if (axisDimName == null && axisIndex == null) {
      var axisProxy = this.findRepresentativeAxisProxy();

      if (axisProxy) {
        return axisProxy.getDataValueWindow();
      }
    } else {
      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
    }
  },

  /**
   * @public
   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy
   *      corresponding to the axisModel
   * @return {module:echarts/component/dataZoom/AxisProxy}
   */
  findRepresentativeAxisProxy: function (axisModel) {
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    } // Find the first hosted axisProxy


    var axisProxies = this._axisProxies;

    for (var key in axisProxies) {
      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {
        return axisProxies[key];
      }
    } // If no hosted axis find not hosted axisProxy.
    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,
    // and the option.start or option.end settings are different. The percentRange
    // should follow axisProxy.
    // (We encounter this problem in toolbox data zoom.)


    for (var key in axisProxies) {
      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {
        return axisProxies[key];
      }
    }
  },

  /**
   * @return {Array.<string>}
   */
  getRangePropMode: function () {
    return this._rangePropMode.slice();
  }
});

function retrieveRaw(option) {
  var ret = {};
  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {
    option.hasOwnProperty(name) && (ret[name] = option[name]);
  });
  return ret;
}

function updateRangeUse(dataZoomModel, rawOption) {
  var rangePropMode = dataZoomModel._rangePropMode;
  var rangeModeInOption = dataZoomModel.get('rangeMode');
  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
    var percentSpecified = rawOption[names[0]] != null;
    var valueSpecified = rawOption[names[1]] != null;

    if (percentSpecified && !valueSpecified) {
      rangePropMode[index] = 'percent';
    } else if (!percentSpecified && valueSpecified) {
      rangePropMode[index] = 'value';
    } else if (rangeModeInOption) {
      rangePropMode[index] = rangeModeInOption[index];
    } else if (percentSpecified) {
      // percentSpecified && valueSpecified
      rangePropMode[index] = 'percent';
    } // else remain its original setting.

  });
}

var _default = DataZoomModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/DataZoomView.js":
/***/ (function(module, exports, __webpack_require__) {

var ComponentView = __webpack_require__("./node_modules/echarts/lib/view/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = ComponentView.extend({
  type: 'dataZoom',
  render: function (dataZoomModel, ecModel, api, payload) {
    this.dataZoomModel = dataZoomModel;
    this.ecModel = ecModel;
    this.api = api;
  },

  /**
   * Find the first target coordinate system.
   *
   * @protected
   * @return {Object} {
   *                   grid: [
   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
   *                       ...
   *                   ],  // cartesians must not be null/undefined.
   *                   polar: [
   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},
   *                       ...
   *                   ],  // polars must not be null/undefined.
   *                   singleAxis: [
   *                       {model: coord0, axisModels: [], coordIndex: 0}
   *                   ]
   */
  getTargetCoordInfo: function () {
    var dataZoomModel = this.dataZoomModel;
    var ecModel = this.ecModel;
    var coordSysLists = {};
    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);

      if (axisModel) {
        var coordModel = axisModel.getCoordSysModel();
        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);
      }
    }, this);

    function save(coordModel, axisModel, store, coordIndex) {
      var item;

      for (var i = 0; i < store.length; i++) {
        if (store[i].model === coordModel) {
          item = store[i];
          break;
        }
      }

      if (!item) {
        store.push(item = {
          model: coordModel,
          axisModels: [],
          coordIndex: coordIndex
        });
      }

      item.axisModels.push(axisModel);
    }

    return coordSysLists;
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js":
/***/ (function(module, exports, __webpack_require__) {

var DataZoomModel = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = DataZoomModel.extend({
  type: 'dataZoom.inside',

  /**
   * @protected
   */
  defaultOption: {
    disabled: false,
    // Whether disable this inside zoom.
    zoomLock: false,
    // Whether disable zoom but only pan.
    zoomOnMouseWheel: true,
    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
    moveOnMouseMove: true,
    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
    preventDefaultMouseMove: true
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var DataZoomView = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

var sliderMove = __webpack_require__("./node_modules/echarts/lib/component/helper/sliderMove.js");

var roams = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/roams.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var bind = zrUtil.bind;
var InsideZoomView = DataZoomView.extend({
  type: 'dataZoom.inside',

  /**
   * @override
   */
  init: function (ecModel, api) {
    /**
     * 'throttle' is used in this.dispatchAction, so we save range
     * to avoid missing some 'pan' info.
     * @private
     * @type {Array.<number>}
     */
    this._range;
  },

  /**
   * @override
   */
  render: function (dataZoomModel, ecModel, api, payload) {
    InsideZoomView.superApply(this, 'render', arguments); // Hance the `throttle` util ensures to preserve command order,
    // here simply updating range all the time will not cause missing
    // any of the the roam change.

    this._range = dataZoomModel.getPercentRange(); // Reset controllers.

    zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {
      var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {
        return roams.generateCoordId(coordInfo.model);
      });
      zrUtil.each(coordInfoList, function (coordInfo) {
        var coordModel = coordInfo.model;
        var dataZoomOption = dataZoomModel.option;
        roams.register(api, {
          coordId: roams.generateCoordId(coordModel),
          allCoordIds: allCoordIds,
          containsPoint: function (e, x, y) {
            return coordModel.coordinateSystem.containPoint([x, y]);
          },
          dataZoomId: dataZoomModel.id,
          throttleRate: dataZoomModel.get('throttle', true),
          panGetRange: bind(this._onPan, this, coordInfo, coordSysName),
          zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName),
          zoomLock: dataZoomOption.zoomLock,
          disabled: dataZoomOption.disabled,
          roamControllerOpt: {
            zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel,
            moveOnMouseMove: dataZoomOption.moveOnMouseMove,
            preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove
          }
        });
      }, this);
    }, this);
  },

  /**
   * @override
   */
  dispose: function () {
    roams.unregister(this.api, this.dataZoomModel.id);
    InsideZoomView.superApply(this, 'dispose', arguments);
    this._range = null;
  },

  /**
   * @private
   */
  _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {
    var lastRange = this._range;
    var range = lastRange.slice(); // Calculate transform by the first axis.

    var axisModel = coordInfo.axisModels[0];

    if (!axisModel) {
      return;
    }

    var directionInfo = getDirectionInfo[coordSysName]([oldX, oldY], [newX, newY], axisModel, controller, coordInfo);
    var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
    sliderMove(percentDelta, range, [0, 100], 'all');
    this._range = range;

    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  },

  /**
   * @private
   */
  _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {
    var lastRange = this._range;
    var range = lastRange.slice(); // Calculate transform by the first axis.

    var axisModel = coordInfo.axisModels[0];

    if (!axisModel) {
      return;
    }

    var directionInfo = getDirectionInfo[coordSysName](null, [mouseX, mouseY], axisModel, controller, coordInfo);
    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
    scale = Math.max(1 / scale, 0);
    range[0] = (range[0] - percentPoint) * scale + percentPoint;
    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.

    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
    this._range = range;

    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  }
});
var getDirectionInfo = {
  grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var rect = coordInfo.model.coordinateSystem.getRect();
    oldPoint = oldPoint || [0, 0];

    if (axis.dim === 'x') {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // axis.dim === 'y'
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  },
  polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var polar = coordInfo.model.coordinateSystem;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var angleExtent = polar.getAngleAxis().getExtent();
    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
    newPoint = polar.pointToCoord(newPoint);

    if (axisModel.mainType === 'radiusAxis') {
      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);
      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);

      ret.pixelLength = radiusExtent[1] - radiusExtent[0];
      ret.pixelStart = radiusExtent[0];
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // 'angleAxis'
      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);
      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);

      ret.pixelLength = angleExtent[1] - angleExtent[0];
      ret.pixelStart = angleExtent[0];
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  },
  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {
    var axis = axisModel.axis;
    var rect = coordInfo.model.coordinateSystem.getRect();
    var ret = {};
    oldPoint = oldPoint || [0, 0];

    if (axis.orient === 'horizontal') {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // 'vertical'
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  }
};
var _default = InsideZoomView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js":
/***/ (function(module, exports, __webpack_require__) {

var DataZoomModel = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = DataZoomModel.extend({
  type: 'dataZoom.select'
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js":
/***/ (function(module, exports, __webpack_require__) {

var DataZoomView = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = DataZoomView.extend({
  type: 'dataZoom.select'
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js":
/***/ (function(module, exports, __webpack_require__) {

var DataZoomModel = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var SliderZoomModel = DataZoomModel.extend({
  type: 'dataZoom.slider',
  layoutMode: 'box',

  /**
   * @protected
   */
  defaultOption: {
    show: true,
    // ph => placeholder. Using placehoder here because
    // deault value can only be drived in view stage.
    right: 'ph',
    // Default align to grid rect.
    top: 'ph',
    // Default align to grid rect.
    width: 'ph',
    // Default align to grid rect.
    height: 'ph',
    // Default align to grid rect.
    left: null,
    // Default align to grid rect.
    bottom: null,
    // Default align to grid rect.
    backgroundColor: 'rgba(47,69,84,0)',
    // Background of slider zoom component.
    // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,
    // highest priority, remain for compatibility of
    // previous version, but not recommended any more.
    dataBackground: {
      lineStyle: {
        color: '#2f4554',
        width: 0.5,
        opacity: 0.3
      },
      areaStyle: {
        color: 'rgba(47,69,84,0.3)',
        opacity: 0.3
      }
    },
    borderColor: '#ddd',
    // border color of the box. For compatibility,
    // if dataBackgroundColor is set, borderColor
    // is ignored.
    fillerColor: 'rgba(167,183,204,0.4)',
    // Color of selected area.
    // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.
    // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',
    handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',
    // Percent of the slider height
    handleSize: '100%',
    handleStyle: {
      color: '#a7b7cc'
    },
    labelPrecision: null,
    labelFormatter: null,
    showDetail: true,
    showDataShadow: 'auto',
    // Default auto decision.
    realtime: true,
    zoomLock: false,
    // Whether disable zoom.
    textStyle: {
      color: '#333'
    }
  }
});
var _default = SliderZoomModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var eventTool = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var throttle = __webpack_require__("./node_modules/echarts/lib/util/throttle.js");

var DataZoomView = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var sliderMove = __webpack_require__("./node_modules/echarts/lib/component/helper/sliderMove.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var Rect = graphic.Rect;
var linearMap = numberUtil.linearMap;
var asc = numberUtil.asc;
var bind = zrUtil.bind;
var each = zrUtil.each; // Constants

var DEFAULT_LOCATION_EDGE_GAP = 7;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var HORIZONTAL = 'horizontal';
var VERTICAL = 'vertical';
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];
var SliderZoomView = DataZoomView.extend({
  type: 'dataZoom.slider',
  init: function (ecModel, api) {
    /**
     * @private
     * @type {Object}
     */
    this._displayables = {};
    /**
     * @private
     * @type {string}
     */

    this._orient;
    /**
     * [0, 100]
     * @private
     */

    this._range;
    /**
     * [coord of the first handle, coord of the second handle]
     * @private
     */

    this._handleEnds;
    /**
     * [length, thick]
     * @private
     * @type {Array.<number>}
     */

    this._size;
    /**
     * @private
     * @type {number}
     */

    this._handleWidth;
    /**
     * @private
     * @type {number}
     */

    this._handleHeight;
    /**
     * @private
     */

    this._location;
    /**
     * @private
     */

    this._dragging;
    /**
     * @private
     */

    this._dataShadowInfo;
    this.api = api;
  },

  /**
   * @override
   */
  render: function (dataZoomModel, ecModel, api, payload) {
    SliderZoomView.superApply(this, 'render', arguments);
    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');
    this._orient = dataZoomModel.get('orient');

    if (this.dataZoomModel.get('show') === false) {
      this.group.removeAll();
      return;
    } // Notice: this._resetInterval() should not be executed when payload.type
    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'
    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,


    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {
      this._buildView();
    }

    this._updateView();
  },

  /**
   * @override
   */
  remove: function () {
    SliderZoomView.superApply(this, 'remove', arguments);
    throttle.clear(this, '_dispatchZoomAction');
  },

  /**
   * @override
   */
  dispose: function () {
    SliderZoomView.superApply(this, 'dispose', arguments);
    throttle.clear(this, '_dispatchZoomAction');
  },
  _buildView: function () {
    var thisGroup = this.group;
    thisGroup.removeAll();

    this._resetLocation();

    this._resetInterval();

    var barGroup = this._displayables.barGroup = new graphic.Group();

    this._renderBackground();

    this._renderHandle();

    this._renderDataShadow();

    thisGroup.add(barGroup);

    this._positionGroup();
  },

  /**
   * @private
   */
  _resetLocation: function () {
    var dataZoomModel = this.dataZoomModel;
    var api = this.api; // If some of x/y/width/height are not specified,
    // auto-adapt according to target grid.

    var coordRect = this._findCoordRect();

    var ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    }; // Default align by coordinate system rect.

    var positionInfo = this._orient === HORIZONTAL ? {
      // Why using 'right', because right should be used in vertical,
      // and it is better to be consistent for dealing with position param merge.
      right: ecSize.width - coordRect.x - coordRect.width,
      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,
      width: coordRect.width,
      height: DEFAULT_FILLER_SIZE
    } : {
      // vertical
      right: DEFAULT_LOCATION_EDGE_GAP,
      top: coordRect.y,
      width: DEFAULT_FILLER_SIZE,
      height: coordRect.height
    }; // Do not write back to option and replace value 'ph', because
    // the 'ph' value should be recalculated when resize.

    var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.

    zrUtil.each(['right', 'top', 'width', 'height'], function (name) {
      if (layoutParams[name] === 'ph') {
        layoutParams[name] = positionInfo[name];
      }
    });
    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);
    this._location = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    this._size = [layoutRect.width, layoutRect.height];
    this._orient === VERTICAL && this._size.reverse();
  },

  /**
   * @private
   */
  _positionGroup: function () {
    var thisGroup = this.group;
    var location = this._location;
    var orient = this._orient; // Just use the first axis to determine mapping.

    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
    var inverse = targetAxisModel && targetAxisModel.get('inverse');
    var barGroup = this._displayables.barGroup;
    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.

    barGroup.attr(orient === HORIZONTAL && !inverse ? {
      scale: otherAxisInverse ? [1, 1] : [1, -1]
    } : orient === HORIZONTAL && inverse ? {
      scale: otherAxisInverse ? [-1, 1] : [-1, -1]
    } : orient === VERTICAL && !inverse ? {
      scale: otherAxisInverse ? [1, -1] : [1, 1],
      rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.

    } : {
      scale: otherAxisInverse ? [-1, -1] : [-1, 1],
      rotation: Math.PI / 2
    }); // Position barGroup

    var rect = thisGroup.getBoundingRect([barGroup]);
    thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);
  },

  /**
   * @private
   */
  _getViewExtent: function () {
    return [0, this._size[0]];
  },
  _renderBackground: function () {
    var dataZoomModel = this.dataZoomModel;
    var size = this._size;
    var barGroup = this._displayables.barGroup;
    barGroup.add(new Rect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: dataZoomModel.get('backgroundColor')
      },
      z2: -40
    })); // Click panel, over shadow, below handles.

    barGroup.add(new Rect({
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: 'transparent'
      },
      z2: 0,
      onclick: zrUtil.bind(this._onClickPanelClick, this)
    }));
  },
  _renderDataShadow: function () {
    var info = this._dataShadowInfo = this._prepareDataShadowInfo();

    if (!info) {
      return;
    }

    var size = this._size;
    var seriesModel = info.series;
    var data = seriesModel.getRawData();
    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick
    : info.otherDim;

    if (otherDim == null) {
      return;
    }

    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.

    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];
    var otherShadowExtent = [0, size[1]];
    var thisShadowExtent = [0, size[0]];
    var areaPoints = [[size[0], 0], [0, 0]];
    var linePoints = [];
    var step = thisShadowExtent[1] / (data.count() - 1);
    var thisCoord = 0; // Optimize for large data shadow

    var stride = Math.round(data.count() / size[0]);
    var lastIsEmpty;
    data.each([otherDim], function (value, index) {
      if (stride > 0 && index % stride) {
        thisCoord += step;
        return;
      } // FIXME
      // Should consider axis.min/axis.max when drawing dataShadow.
      // FIXME
      // 应该使用统一的空判断？还是在list里进行空判断？


      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.

      var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.

      if (isEmpty && !lastIsEmpty && index) {
        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
        linePoints.push([linePoints[linePoints.length - 1][0], 0]);
      } else if (!isEmpty && lastIsEmpty) {
        areaPoints.push([thisCoord, 0]);
        linePoints.push([thisCoord, 0]);
      }

      areaPoints.push([thisCoord, otherCoord]);
      linePoints.push([thisCoord, otherCoord]);
      thisCoord += step;
      lastIsEmpty = isEmpty;
    });
    var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');

    this._displayables.barGroup.add(new graphic.Polygon({
      shape: {
        points: areaPoints
      },
      style: zrUtil.defaults({
        fill: dataZoomModel.get('dataBackgroundColor')
      }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),
      silent: true,
      z2: -20
    }));

    this._displayables.barGroup.add(new graphic.Polyline({
      shape: {
        points: linePoints
      },
      style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),
      silent: true,
      z2: -19
    }));
  },
  _prepareDataShadowInfo: function () {
    var dataZoomModel = this.dataZoomModel;
    var showDataShadow = dataZoomModel.get('showDataShadow');

    if (showDataShadow === false) {
      return;
    } // Find a representative series.


    var result;
    var ecModel = this.ecModel;
    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
      var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();
      zrUtil.each(seriesModels, function (seriesModel) {
        if (result) {
          return;
        }

        if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {
          return;
        }

        var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;
        var otherDim = getOtherDim(dimNames.name);
        var otherAxisInverse;
        var coordSys = seriesModel.coordinateSystem;

        if (otherDim != null && coordSys.getOtherAxis) {
          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
        }

        otherDim = seriesModel.getData().mapDimension(otherDim);
        result = {
          thisAxis: thisAxis,
          series: seriesModel,
          thisDim: dimNames.name,
          otherDim: otherDim,
          otherAxisInverse: otherAxisInverse
        };
      }, this);
    }, this);
    return result;
  },
  _renderHandle: function () {
    var displaybles = this._displayables;
    var handles = displaybles.handles = [];
    var handleLabels = displaybles.handleLabels = [];
    var barGroup = this._displayables.barGroup;
    var size = this._size;
    var dataZoomModel = this.dataZoomModel;
    barGroup.add(displaybles.filler = new Rect({
      draggable: true,
      cursor: getCursor(this._orient),
      drift: bind(this._onDragMove, this, 'all'),
      onmousemove: function (e) {
        // Fot mobile devicem, prevent screen slider on the button.
        eventTool.stop(e.event);
      },
      ondragstart: bind(this._showDataInfo, this, true),
      ondragend: bind(this._onDragEnd, this),
      onmouseover: bind(this._showDataInfo, this, true),
      onmouseout: bind(this._showDataInfo, this, false),
      style: {
        fill: dataZoomModel.get('fillerColor'),
        textPosition: 'inside'
      }
    })); // Frame border.

    barGroup.add(new Rect(graphic.subPixelOptimizeRect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),
        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
        fill: 'rgba(0,0,0,0)'
      }
    })));
    each([0, 1], function (handleIndex) {
      var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {
        cursor: getCursor(this._orient),
        draggable: true,
        drift: bind(this._onDragMove, this, handleIndex),
        onmousemove: function (e) {
          // Fot mobile devicem, prevent screen slider on the button.
          eventTool.stop(e.event);
        },
        ondragend: bind(this._onDragEnd, this),
        onmouseover: bind(this._showDataInfo, this, true),
        onmouseout: bind(this._showDataInfo, this, false)
      }, {
        x: -1,
        y: 0,
        width: 2,
        height: 2
      });
      var bRect = path.getBoundingRect();
      this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);
      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());
      var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version

      if (handleColor != null) {
        path.style.fill = handleColor;
      }

      barGroup.add(handles[handleIndex] = path);
      var textStyleModel = dataZoomModel.textStyleModel;
      this.group.add(handleLabels[handleIndex] = new graphic.Text({
        silent: true,
        invisible: true,
        style: {
          x: 0,
          y: 0,
          text: '',
          textVerticalAlign: 'middle',
          textAlign: 'center',
          textFill: textStyleModel.getTextColor(),
          textFont: textStyleModel.getFont()
        },
        z2: 10
      }));
    }, this);
  },

  /**
   * @private
   */
  _resetInterval: function () {
    var range = this._range = this.dataZoomModel.getPercentRange();

    var viewExtent = this._getViewExtent();

    this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];
  },

  /**
   * @private
   * @param {(number|string)} handleIndex 0 or 1 or 'all'
   * @param {number} delta
   * @return {boolean} changed
   */
  _updateInterval: function (handleIndex, delta) {
    var dataZoomModel = this.dataZoomModel;
    var handleEnds = this._handleEnds;

    var viewExtend = this._getViewExtent();

    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    var percentExtent = [0, 100];
    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    var lastRange = this._range;
    var range = this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
  },

  /**
   * @private
   */
  _updateView: function (nonRealtime) {
    var displaybles = this._displayables;
    var handleEnds = this._handleEnds;
    var handleInterval = asc(handleEnds.slice());
    var size = this._size;
    each([0, 1], function (handleIndex) {
      // Handles
      var handle = displaybles.handles[handleIndex];
      var handleHeight = this._handleHeight;
      handle.attr({
        scale: [handleHeight / 2, handleHeight / 2],
        position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]
      });
    }, this); // Filler

    displaybles.filler.setShape({
      x: handleInterval[0],
      y: 0,
      width: handleInterval[1] - handleInterval[0],
      height: size[1]
    });

    this._updateDataInfo(nonRealtime);
  },

  /**
   * @private
   */
  _updateDataInfo: function (nonRealtime) {
    var dataZoomModel = this.dataZoomModel;
    var displaybles = this._displayables;
    var handleLabels = displaybles.handleLabels;
    var orient = this._orient;
    var labelTexts = ['', '']; // FIXME
    // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）

    if (dataZoomModel.get('showDetail')) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();

      if (axisProxy) {
        var axis = axisProxy.getAxisModel().axis;
        var range = this._range;
        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.
        ? axisProxy.calculateDataWindow({
          start: range[0],
          end: range[1]
        }).valueWindow : axisProxy.getDataValueWindow();
        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
      }
    }

    var orderedHandleEnds = asc(this._handleEnds.slice());
    setLabel.call(this, 0);
    setLabel.call(this, 1);

    function setLabel(handleIndex) {
      // Label
      // Text should not transform by barGroup.
      // Ignore handlers transform
      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);
      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);
      var offset = this._handleWidth / 2 + LABEL_GAP;
      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,
        textAlign: orient === HORIZONTAL ? direction : 'center',
        text: labelTexts[handleIndex]
      });
    }
  },

  /**
   * @private
   */
  _formatLabel: function (value, axis) {
    var dataZoomModel = this.dataZoomModel;
    var labelFormatter = dataZoomModel.get('labelFormatter');
    var labelPrecision = dataZoomModel.get('labelPrecision');

    if (labelPrecision == null || labelPrecision === 'auto') {
      labelPrecision = axis.getPixelPrecision();
    }

    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code
    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.
    : value.toFixed(Math.min(labelPrecision, 20));
    return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;
  },

  /**
   * @private
   * @param {boolean} showOrHide true: show, false: hide
   */
  _showDataInfo: function (showOrHide) {
    // Always show when drgging.
    showOrHide = this._dragging || showOrHide;
    var handleLabels = this._displayables.handleLabels;
    handleLabels[0].attr('invisible', !showOrHide);
    handleLabels[1].attr('invisible', !showOrHide);
  },
  _onDragMove: function (handleIndex, dx, dy) {
    this._dragging = true; // Transform dx, dy to bar coordination.

    var barTransform = this._displayables.barGroup.getLocalTransform();

    var vertex = graphic.applyTransform([dx, dy], barTransform, true);

    var changed = this._updateInterval(handleIndex, vertex[0]);

    var realtime = this.dataZoomModel.get('realtime');

    this._updateView(!realtime); // Avoid dispatch dataZoom repeatly but range not changed,
    // which cause bad visual effect when progressive enabled.


    changed && realtime && this._dispatchZoomAction();
  },
  _onDragEnd: function () {
    this._dragging = false;

    this._showDataInfo(false); // While in realtime mode and stream mode, dispatch action when
    // drag end will cause the whole view rerender, which is unnecessary.


    var realtime = this.dataZoomModel.get('realtime');
    !realtime && this._dispatchZoomAction();
  },
  _onClickPanelClick: function (e) {
    var size = this._size;

    var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);

    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
      return;
    }

    var handleEnds = this._handleEnds;
    var center = (handleEnds[0] + handleEnds[1]) / 2;

    var changed = this._updateInterval('all', localPoint[0] - center);

    this._updateView();

    changed && this._dispatchZoomAction();
  },

  /**
   * This action will be throttled.
   * @private
   */
  _dispatchZoomAction: function () {
    var range = this._range;
    this.api.dispatchAction({
      type: 'dataZoom',
      from: this.uid,
      dataZoomId: this.dataZoomModel.id,
      start: range[0],
      end: range[1]
    });
  },

  /**
   * @private
   */
  _findCoordRect: function () {
    // Find the grid coresponding to the first axis referred by dataZoom.
    var rect;
    each(this.getTargetCoordInfo(), function (coordInfoList) {
      if (!rect && coordInfoList.length) {
        var coordSys = coordInfoList[0].model.coordinateSystem;
        rect = coordSys.getRect && coordSys.getRect();
      }
    });

    if (!rect) {
      var width = this.api.getWidth();
      var height = this.api.getHeight();
      rect = {
        x: width * 0.2,
        y: height * 0.2,
        width: width * 0.6,
        height: height * 0.6
      };
    }

    return rect;
  }
});

function getOtherDim(thisDim) {
  // FIXME
  // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好
  var map = {
    x: 'y',
    y: 'x',
    radius: 'angle',
    angle: 'radius'
  };
  return map[thisDim];
}

function getCursor(orient) {
  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';
}

var _default = SliderZoomView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var helper = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/helper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
echarts.registerAction('dataZoom', function (payload, ecModel) {
  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {
    return model.get(dimNames.axisIndex);
  });
  var effectedModels = [];
  ecModel.eachComponent({
    mainType: 'dataZoom',
    query: payload
  }, function (model, index) {
    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);
  });
  zrUtil.each(effectedModels, function (dataZoomModel, index) {
    dataZoomModel.setRawRange({
      start: payload.start,
      end: payload.end,
      startValue: payload.startValue,
      endValue: payload.endValue
    });
  });
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var createHashMap = _util.createHashMap;
var each = _util.each;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
echarts.registerProcessor({
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function (ecModel) {
    var seriesModelMap = createHashMap();
    ecModel.eachComponent('dataZoom', function (dataZoomModel) {
      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {
        var axisProxy = dataZoomModel.getAxisProxy(dimNames.name, axisIndex);
        each(axisProxy.getTargetSeriesModels(), function (seriesModel) {
          seriesModelMap.set(seriesModel.uid, seriesModel);
        });
      });
    });
    return seriesModelMap;
  },
  modifyOutputEnd: true,
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function (ecModel, api) {
    ecModel.eachComponent('dataZoom', function (dataZoomModel) {
      // We calculate window and reset axis here but not in model
      // init stage and not after action dispatch handler, because
      // reset should be called after seriesData.restoreData.
      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {
        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel, api);
      }); // Caution: data zoom filtering is order sensitive when using
      // percent range and no min/max/scale set on axis.
      // For example, we have dataZoom definition:
      // [
      //      {xAxisIndex: 0, start: 30, end: 70},
      //      {yAxisIndex: 0, start: 20, end: 80}
      // ]
      // In this case, [20, 80] of y-dataZoom should be based on data
      // that have filtered by x-dataZoom using range of [30, 70],
      // but should not be based on full raw data. Thus sliding
      // x-dataZoom will change both ranges of xAxis and yAxis,
      // while sliding y-dataZoom will only change the range of yAxis.
      // So we should filter x-axis after reset x-axis immediately,
      // and then reset y-axis and filter y-axis.

      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {
        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel, api);
      });
    });
    ecModel.eachComponent('dataZoom', function (dataZoomModel) {
      // Fullfill all of the range props so that user
      // is able to get them from chart.getOption().
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      var percentRange = axisProxy.getDataPercentWindow();
      var valueRange = axisProxy.getDataValueWindow();
      dataZoomModel.setRawRange({
        start: percentRange[0],
        end: percentRange[1],
        startValue: valueRange[0],
        endValue: valueRange[1]
      }, true);
    });
  }
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/helper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.

var COORDS = ['cartesian2d', 'polar', 'singleAxis'];
/**
 * @param {string} coordType
 * @return {boolean}
 */

function isCoordSupported(coordType) {
  return zrUtil.indexOf(COORDS, coordType) >= 0;
}
/**
 * Create "each" method to iterate names.
 *
 * @pubilc
 * @param  {Array.<string>} names
 * @param  {Array.<string>=} attrs
 * @return {Function}
 */


function createNameEach(names, attrs) {
  names = names.slice();
  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);
  attrs = (attrs || []).slice();
  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);
  return function (callback, context) {
    zrUtil.each(names, function (name, index) {
      var nameObj = {
        name: name,
        capital: capitalNames[index]
      };

      for (var j = 0; j < attrs.length; j++) {
        nameObj[attrs[j]] = name + capitalAttrs[j];
      }

      callback.call(context, nameObj);
    });
  };
}
/**
 * Iterate each dimension name.
 *
 * @public
 * @param {Function} callback The parameter is like:
 *                            {
 *                                name: 'angle',
 *                                capital: 'Angle',
 *                                axis: 'angleAxis',
 *                                axisIndex: 'angleAixs',
 *                                index: 'angleIndex'
 *                            }
 * @param {Object} context
 */


var eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);
/**
 * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.
 * dataZoomModels and 'links' make up one or more graphics.
 * This function finds the graphic where the source dataZoomModel is in.
 *
 * @public
 * @param {Function} forEachNode Node iterator.
 * @param {Function} forEachEdgeType edgeType iterator
 * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.
 * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}
 */

function createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {
  return function (sourceNode) {
    var result = {
      nodes: [],
      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).

    };
    forEachEdgeType(function (edgeType) {
      result.records[edgeType.name] = {};
    });

    if (!sourceNode) {
      return result;
    }

    absorb(sourceNode, result);
    var existsLink;

    do {
      existsLink = false;
      forEachNode(processSingleNode);
    } while (existsLink);

    function processSingleNode(node) {
      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {
        absorb(node, result);
        existsLink = true;
      }
    }

    return result;
  };

  function isNodeAbsorded(node, result) {
    return zrUtil.indexOf(result.nodes, node) >= 0;
  }

  function isLinked(node, result) {
    var hasLink = false;
    forEachEdgeType(function (edgeType) {
      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {
        result.records[edgeType.name][edgeId] && (hasLink = true);
      });
    });
    return hasLink;
  }

  function absorb(node, result) {
    result.nodes.push(node);
    forEachEdgeType(function (edgeType) {
      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {
        result.records[edgeType.name][edgeId] = true;
      });
    });
  }
}

exports.isCoordSupported = isCoordSupported;
exports.createNameEach = createNameEach;
exports.eachAxisDim = eachAxisDim;
exports.createLinkedNodesFinder = createLinkedNodesFinder;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/history.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var each = zrUtil.each;
var ATTR = '\0_ec_hist_store';
/**
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}
 */

function push(ecModel, newSnapshot) {
  var store = giveStore(ecModel); // If previous dataZoom can not be found,
  // complete an range with current range.

  each(newSnapshot, function (batchItem, dataZoomId) {
    var i = store.length - 1;

    for (; i >= 0; i--) {
      var snapshot = store[i];

      if (snapshot[dataZoomId]) {
        break;
      }
    }

    if (i < 0) {
      // No origin range set, create one by current range.
      var dataZoomModel = ecModel.queryComponents({
        mainType: 'dataZoom',
        subType: 'select',
        id: dataZoomId
      })[0];

      if (dataZoomModel) {
        var percentRange = dataZoomModel.getPercentRange();
        store[0][dataZoomId] = {
          dataZoomId: dataZoomId,
          start: percentRange[0],
          end: percentRange[1]
        };
      }
    }
  });
  store.push(newSnapshot);
}
/**
 * @param {module:echarts/model/Global} ecModel
 * @return {Object} snapshot
 */


function pop(ecModel) {
  var store = giveStore(ecModel);
  var head = store[store.length - 1];
  store.length > 1 && store.pop(); // Find top for all dataZoom.

  var snapshot = {};
  each(head, function (batchItem, dataZoomId) {
    for (var i = store.length - 1; i >= 0; i--) {
      var batchItem = store[i][dataZoomId];

      if (batchItem) {
        snapshot[dataZoomId] = batchItem;
        break;
      }
    }
  });
  return snapshot;
}
/**
 * @param {module:echarts/model/Global} ecModel
 */


function clear(ecModel) {
  ecModel[ATTR] = null;
}
/**
 * @param {module:echarts/model/Global} ecModel
 * @return {number} records. always >= 1.
 */


function count(ecModel) {
  return giveStore(ecModel).length;
}
/**
 * [{key: dataZoomId, value: {dataZoomId, range}}, ...]
 * History length of each dataZoom may be different.
 * this._history[0] is used to store origin range.
 * @type {Array.<Object>}
 */


function giveStore(ecModel) {
  var store = ecModel[ATTR];

  if (!store) {
    store = ecModel[ATTR] = [{}];
  }

  return store;
}

exports.push = push;
exports.pop = pop;
exports.clear = clear;
exports.count = count;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/roams.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var RoamController = __webpack_require__("./node_modules/echarts/lib/component/helper/RoamController.js");

var throttleUtil = __webpack_require__("./node_modules/echarts/lib/util/throttle.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Only create one roam controller for each coordinate system.
// one roam controller might be refered by two inside data zoom
// components (for example, one for x and one for y). When user
// pan or zoom, only dispatch one action for those data zoom
// components.
var curry = zrUtil.curry;
var ATTR = '\0_ec_dataZoom_roams';
/**
 * @public
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} dataZoomInfo
 * @param {string} dataZoomInfo.coordId
 * @param {Function} dataZoomInfo.containsPoint
 * @param {Array.<string>} dataZoomInfo.allCoordIds
 * @param {string} dataZoomInfo.dataZoomId
 * @param {number} dataZoomInfo.throttleRate
 * @param {Function} dataZoomInfo.panGetRange
 * @param {Function} dataZoomInfo.zoomGetRange
 * @param {boolean} [dataZoomInfo.zoomLock]
 * @param {boolean} [dataZoomInfo.disabled]
 */

function register(api, dataZoomInfo) {
  var store = giveStore(api);
  var theDataZoomId = dataZoomInfo.dataZoomId;
  var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.
  // Avoid memory leak, dispose all not-used-registered.

  zrUtil.each(store, function (record, coordId) {
    var dataZoomInfos = record.dataZoomInfos;

    if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {
      delete dataZoomInfos[theDataZoomId];
      record.count--;
    }
  });
  cleanStore(store);
  var record = store[theCoordId]; // Create if needed.

  if (!record) {
    record = store[theCoordId] = {
      coordId: theCoordId,
      dataZoomInfos: {},
      count: 0
    };
    record.controller = createController(api, record);
    record.dispatchAction = zrUtil.curry(dispatchAction, api);
  } // Update reference of dataZoom.


  !record.dataZoomInfos[theDataZoomId] && record.count++;
  record.dataZoomInfos[theDataZoomId] = dataZoomInfo;
  var controllerParams = mergeControllerParams(record.dataZoomInfos);
  record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.

  record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.

  throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');
}
/**
 * @public
 * @param {module:echarts/ExtensionAPI} api
 * @param {string} dataZoomId
 */


function unregister(api, dataZoomId) {
  var store = giveStore(api);
  zrUtil.each(store, function (record) {
    record.controller.dispose();
    var dataZoomInfos = record.dataZoomInfos;

    if (dataZoomInfos[dataZoomId]) {
      delete dataZoomInfos[dataZoomId];
      record.count--;
    }
  });
  cleanStore(store);
}
/**
 * @public
 */


function generateCoordId(coordModel) {
  return coordModel.type + '\0_' + coordModel.id;
}
/**
 * Key: coordId, value: {dataZoomInfos: [], count, controller}
 * @type {Array.<Object>}
 */


function giveStore(api) {
  // Mount store on zrender instance, so that we do not
  // need to worry about dispose.
  var zr = api.getZr();
  return zr[ATTR] || (zr[ATTR] = {});
}

function createController(api, newRecord) {
  var controller = new RoamController(api.getZr());
  controller.on('pan', curry(onPan, newRecord));
  controller.on('zoom', curry(onZoom, newRecord));
  return controller;
}

function cleanStore(store) {
  zrUtil.each(store, function (record, coordId) {
    if (!record.count) {
      record.controller.dispose();
      delete store[coordId];
    }
  });
}

function onPan(record, dx, dy, oldX, oldY, newX, newY) {
  wrapAndDispatch(record, function (info) {
    return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);
  });
}

function onZoom(record, scale, mouseX, mouseY) {
  wrapAndDispatch(record, function (info) {
    return info.zoomGetRange(record.controller, scale, mouseX, mouseY);
  });
}

function wrapAndDispatch(record, getRange) {
  var batch = [];
  zrUtil.each(record.dataZoomInfos, function (info) {
    var range = getRange(info);
    !info.disabled && range && batch.push({
      dataZoomId: info.dataZoomId,
      start: range[0],
      end: range[1]
    });
  });
  batch.length && record.dispatchAction(batch);
}
/**
 * This action will be throttled.
 */


function dispatchAction(api, batch) {
  api.dispatchAction({
    type: 'dataZoom',
    batch: batch
  });
}
/**
 * Merge roamController settings when multiple dataZooms share one roamController.
 */


function mergeControllerParams(dataZoomInfos) {
  var controlType;
  var opt = {}; // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated
  // as string, it is probably revert to reserved word by compress tool. See #7411.

  var prefix = 'type_';
  var typePriority = {
    'type_true': 2,
    'type_move': 1,
    'type_false': 0,
    'type_undefined': -1
  };
  zrUtil.each(dataZoomInfos, function (dataZoomInfo) {
    var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true;

    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
      controlType = oneType;
    } // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.


    zrUtil.extend(opt, dataZoomInfo.roamControllerOpt);
  });
  return {
    controlType: controlType,
    opt: opt
  };
}

exports.register = register;
exports.unregister = unregister;
exports.generateCoordId = generateCoordId;

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js":
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
Component.registerSubTypeDefaulter('dataZoom', function () {
  // Default 'slider' when no type specified.
  return 'slider';
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoomSelect.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js");

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataset.js":
/***/ (function(module, exports, __webpack_require__) {

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var ComponentView = __webpack_require__("./node_modules/echarts/lib/view/Component.js");

var _sourceHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/sourceHelper.js");

var detectSourceFormat = _sourceHelper.detectSourceFormat;

var _sourceType = __webpack_require__("./node_modules/echarts/lib/data/helper/sourceType.js");

var SERIES_LAYOUT_BY_COLUMN = _sourceType.SERIES_LAYOUT_BY_COLUMN;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * This module is imported by echarts directly.
 *
 * Notice:
 * Always keep this file exists for backward compatibility.
 * Because before 4.1.0, dataset is an optional component,
 * some users may import this module manually.
 */
ComponentModel.extend({
  type: 'dataset',

  /**
   * @protected
   */
  defaultOption: {
    // 'row', 'column'
    seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
    // null/'auto': auto detect header, see "module:echarts/data/helper/sourceHelper"
    sourceHeader: null,
    dimensions: null,
    source: null
  },
  optionUpdated: function () {
    detectSourceFormat(this);
  }
});
ComponentView.extend({
  type: 'dataset'
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/gridSimple.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

__webpack_require__("./node_modules/echarts/lib/coord/cartesian/Grid.js");

__webpack_require__("./node_modules/echarts/lib/component/axis.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Grid view
echarts.extendComponentView({
  type: 'grid',
  render: function (gridModel, ecModel) {
    this.group.removeAll();

    if (gridModel.get('show')) {
      this.group.add(new graphic.Rect({
        shape: gridModel.coordinateSystem.getRect(),
        style: zrUtil.defaults({
          fill: gridModel.get('backgroundColor')
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  }
});
echarts.registerPreprocessor(function (option) {
  // Only create grid when need
  if (option.xAxis && option.yAxis && !option.grid) {
    option.grid = {};
  }
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/BrushController.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var interactionMutex = __webpack_require__("./node_modules/echarts/lib/component/helper/interactionMutex.js");

var DataDiffer = __webpack_require__("./node_modules/echarts/lib/data/DataDiffer.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var curry = zrUtil.curry;
var each = zrUtil.each;
var map = zrUtil.map;
var mathMin = Math.min;
var mathMax = Math.max;
var mathPow = Math.pow;
var COVER_Z = 10000;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = 'globalPan';
var DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
};
var CURSOR_MAP = {
  w: 'ew',
  e: 'ew',
  n: 'ns',
  s: 'ns',
  ne: 'nesw',
  sw: 'nesw',
  nw: 'nwse',
  se: 'nwse'
};
var DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: 'rgba(0,0,0,0.3)',
    fill: 'rgba(0,0,0,0.1)'
  },
  transformable: true,
  brushMode: 'single',
  removeOnClick: false
};
var baseUID = 0;
/**
 * @alias module:echarts/component/helper/BrushController
 * @constructor
 * @mixin {module:zrender/mixin/Eventful}
 * @event module:echarts/component/helper/BrushController#brush
 *        params:
 *            areas: Array.<Array>, coord relates to container group,
 *                                    If no container specified, to global.
 *            opt {
 *                isEnd: boolean,
 *                removeOnClick: boolean
 *            }
 *
 * @param {module:zrender/zrender~ZRender} zr
 */

function BrushController(zr) {
  Eventful.call(this);
  /**
   * @type {module:zrender/zrender~ZRender}
   * @private
   */

  this._zr = zr;
  /**
   * @type {module:zrender/container/Group}
   * @readOnly
   */

  this.group = new graphic.Group();
  /**
   * Only for drawing (after enabledBrush).
   *     'line', 'rect', 'polygon' or false
   *     If passing false/null/undefined, disable brush.
   *     If passing 'auto', determined by panel.defaultBrushType
   * @private
   * @type {string}
   */

  this._brushType;
  /**
   * Only for drawing (after enabledBrush).
   *
   * @private
   * @type {Object}
   */

  this._brushOption;
  /**
   * @private
   * @type {Object}
   */

  this._panels;
  /**
   * @private
   * @type {Array.<nubmer>}
   */

  this._track = [];
  /**
   * @private
   * @type {boolean}
   */

  this._dragging;
  /**
   * @private
   * @type {Array}
   */

  this._covers = [];
  /**
   * @private
   * @type {moudule:zrender/container/Group}
   */

  this._creatingCover;
  /**
   * `true` means global panel
   * @private
   * @type {module:zrender/container/Group|boolean}
   */

  this._creatingPanel;
  /**
   * @private
   * @type {boolean}
   */

  this._enableGlobalPan;
  /**
   * @private
   * @type {boolean}
   */

  /**
   * @private
   * @type {string}
   */
  this._uid = 'brushController_' + baseUID++;
  /**
   * @private
   * @type {Object}
   */

  this._handlers = {};
  each(mouseHandlers, function (handler, eventName) {
    this._handlers[eventName] = zrUtil.bind(handler, this);
  }, this);
}

BrushController.prototype = {
  constructor: BrushController,

  /**
   * If set to null/undefined/false, select disabled.
   * @param {Object} brushOption
   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false
   *                          If passing false/null/undefined, disable brush.
   *                          If passing 'auto', determined by panel.defaultBrushType.
   *                              ('auto' can not be used in global panel)
   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'
   * @param {boolean} [brushOption.transformable=true]
   * @param {boolean} [brushOption.removeOnClick=false]
   * @param {Object} [brushOption.brushStyle]
   * @param {number} [brushOption.brushStyle.width]
   * @param {number} [brushOption.brushStyle.lineWidth]
   * @param {string} [brushOption.brushStyle.stroke]
   * @param {string} [brushOption.brushStyle.fill]
   * @param {number} [brushOption.z]
   */
  enableBrush: function (brushOption) {
    this._brushType && doDisableBrush(this);
    brushOption.brushType && doEnableBrush(this, brushOption);
    return this;
  },

  /**
   * @param {Array.<Object>} panelOpts If not pass, it is global brush.
   *        Each items: {
   *            panelId, // mandatory.
   *            clipPath, // mandatory. function.
   *            isTargetByCursor, // mandatory. function.
   *            defaultBrushType, // optional, only used when brushType is 'auto'.
   *            getLinearBrushOtherExtent, // optional. function.
   *        }
   */
  setPanels: function (panelOpts) {
    if (panelOpts && panelOpts.length) {
      var panels = this._panels = {};
      zrUtil.each(panelOpts, function (panelOpts) {
        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);
      });
    } else {
      this._panels = null;
    }

    return this;
  },

  /**
   * @param {Object} [opt]
   * @return {boolean} [opt.enableGlobalPan=false]
   */
  mount: function (opt) {
    opt = opt || {};
    this._enableGlobalPan = opt.enableGlobalPan;
    var thisGroup = this.group;

    this._zr.add(thisGroup);

    thisGroup.attr({
      position: opt.position || [0, 0],
      rotation: opt.rotation || 0,
      scale: opt.scale || [1, 1]
    });
    this._transform = thisGroup.getLocalTransform();
    return this;
  },
  eachCover: function (cb, context) {
    each(this._covers, cb, context);
  },

  /**
   * Update covers.
   * @param {Array.<Object>} brushOptionList Like:
   *        [
   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},
   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},
   *            ...
   *        ]
   *        `brushType` is required in each cover info. (can not be 'auto')
   *        `id` is not mandatory.
   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.
   *        If brushOptionList is null/undefined, all covers removed.
   */
  updateCovers: function (brushOptionList) {
    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {
      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
    });
    var tmpIdPrefix = '\0-brush-index-';
    var oldCovers = this._covers;
    var newCovers = this._covers = [];
    var controller = this;
    var creatingCover = this._creatingCover;
    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
    return this;

    function getKey(brushOption, index) {
      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;
    }

    function oldGetKey(cover, index) {
      return getKey(cover.__brushOption, index);
    }

    function addOrUpdate(newIndex, oldIndex) {
      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,
      // where updating cover when creating should be forbiden.

      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
        newCovers[newIndex] = oldCovers[oldIndex];
      } else {
        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));
        updateCoverAfterCreation(controller, cover);
      }
    }

    function remove(oldIndex) {
      if (oldCovers[oldIndex] !== creatingCover) {
        controller.group.remove(oldCovers[oldIndex]);
      }
    }
  },
  unmount: function () {
    this.enableBrush(false); // container may 'removeAll' outside.

    clearCovers(this);

    this._zr.remove(this.group);

    return this;
  },
  dispose: function () {
    this.unmount();
    this.off();
  }
};
zrUtil.mixin(BrushController, Eventful);

function doEnableBrush(controller, brushOption) {
  var zr = controller._zr; // Consider roam, which takes globalPan too.

  if (!controller._enableGlobalPan) {
    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);
  }

  each(controller._handlers, function (handler, eventName) {
    zr.on(eventName, handler);
  });
  controller._brushType = brushOption.brushType;
  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
}

function doDisableBrush(controller) {
  var zr = controller._zr;
  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);
  each(controller._handlers, function (handler, eventName) {
    zr.off(eventName, handler);
  });
  controller._brushType = controller._brushOption = null;
}

function createCover(controller, brushOption) {
  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
  cover.__brushOption = brushOption;
  updateZ(cover, brushOption);
  controller.group.add(cover);
  return cover;
}

function endCreating(controller, creatingCover) {
  var coverRenderer = getCoverRenderer(creatingCover);

  if (coverRenderer.endCreating) {
    coverRenderer.endCreating(controller, creatingCover);
    updateZ(creatingCover, creatingCover.__brushOption);
  }

  return creatingCover;
}

function updateCoverShape(controller, cover) {
  var brushOption = cover.__brushOption;
  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}

function updateZ(cover, brushOption) {
  var z = brushOption.z;
  z == null && (z = COVER_Z);
  cover.traverse(function (el) {
    el.z = z;
    el.z2 = z; // Consider in given container.
  });
}

function updateCoverAfterCreation(controller, cover) {
  getCoverRenderer(cover).updateCommon(controller, cover);
  updateCoverShape(controller, cover);
}

function getCoverRenderer(cover) {
  return coverRenderers[cover.__brushOption.brushType];
} // return target panel or `true` (means global panel)


function getPanelByPoint(controller, e, localCursorPoint) {
  var panels = controller._panels;

  if (!panels) {
    return true; // Global panel
  }

  var panel;
  var transform = controller._transform;
  each(panels, function (pn) {
    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);
  });
  return panel;
} // Return a panel or true


function getPanelByCover(controller, cover) {
  var panels = controller._panels;

  if (!panels) {
    return true; // Global panel
  }

  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,
  // which is then treated as global panel.

  return panelId != null ? panels[panelId] : true;
}

function clearCovers(controller) {
  var covers = controller._covers;
  var originalLength = covers.length;
  each(covers, function (cover) {
    controller.group.remove(cover);
  }, controller);
  covers.length = 0;
  return !!originalLength;
}

function trigger(controller, opt) {
  var areas = map(controller._covers, function (cover) {
    var brushOption = cover.__brushOption;
    var range = zrUtil.clone(brushOption.range);
    return {
      brushType: brushOption.brushType,
      panelId: brushOption.panelId,
      range: range
    };
  });
  controller.trigger('brush', areas, {
    isEnd: !!opt.isEnd,
    removeOnClick: !!opt.removeOnClick
  });
}

function shouldShowCover(controller) {
  var track = controller._track;

  if (!track.length) {
    return false;
  }

  var p2 = track[track.length - 1];
  var p1 = track[0];
  var dx = p2[0] - p1[0];
  var dy = p2[1] - p1[1];
  var dist = mathPow(dx * dx + dy * dy, 0.5);
  return dist > UNSELECT_THRESHOLD;
}

function getTrackEnds(track) {
  var tail = track.length - 1;
  tail < 0 && (tail = 0);
  return [track[0], track[tail]];
}

function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {
  var cover = new graphic.Group();
  cover.add(new graphic.Rect({
    name: 'main',
    style: makeStyle(brushOption),
    silent: true,
    draggable: true,
    cursor: 'move',
    drift: curry(doDrift, controller, cover, 'nswe'),
    ondragend: curry(trigger, controller, {
      isEnd: true
    })
  }));
  each(edgeNames, function (name) {
    cover.add(new graphic.Rect({
      name: name,
      style: {
        opacity: 0
      },
      draggable: true,
      silent: true,
      invisible: true,
      drift: curry(doDrift, controller, cover, name),
      ondragend: curry(trigger, controller, {
        isEnd: true
      })
    }));
  });
  return cover;
}

function updateBaseRect(controller, cover, localRange, brushOption) {
  var lineWidth = brushOption.brushStyle.lineWidth || 0;
  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);
  var x = localRange[0][0];
  var y = localRange[1][0];
  var xa = x - lineWidth / 2;
  var ya = y - lineWidth / 2;
  var x2 = localRange[0][1];
  var y2 = localRange[1][1];
  var x2a = x2 - handleSize + lineWidth / 2;
  var y2a = y2 - handleSize + lineWidth / 2;
  var width = x2 - x;
  var height = y2 - y;
  var widtha = width + lineWidth;
  var heighta = height + lineWidth;
  updateRectShape(controller, cover, 'main', x, y, width, height);

  if (brushOption.transformable) {
    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);
    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);
    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);
    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);
    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);
    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);
    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);
    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);
  }
}

function updateCommon(controller, cover) {
  var brushOption = cover.__brushOption;
  var transformable = brushOption.transformable;
  var mainEl = cover.childAt(0);
  mainEl.useStyle(makeStyle(brushOption));
  mainEl.attr({
    silent: !transformable,
    cursor: transformable ? 'move' : 'default'
  });
  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {
    var el = cover.childOfName(name);
    var globalDir = getGlobalDirection(controller, name);
    el && el.attr({
      silent: !transformable,
      invisible: !transformable,
      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null
    });
  });
}

function updateRectShape(controller, cover, name, x, y, w, h) {
  var el = cover.childOfName(name);
  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
}

function makeStyle(brushOption) {
  return zrUtil.defaults({
    strokeNoScale: true
  }, brushOption.brushStyle);
}

function formatRectRange(x, y, x2, y2) {
  var min = [mathMin(x, x2), mathMin(y, y2)];
  var max = [mathMax(x, x2), mathMax(y, y2)];
  return [[min[0], max[0]], // x range
  [min[1], max[1]] // y range
  ];
}

function getTransform(controller) {
  return graphic.getTransform(controller.group);
}

function getGlobalDirection(controller, localDirection) {
  if (localDirection.length > 1) {
    localDirection = localDirection.split('');
    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];
    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();
    return globalDir.join('');
  } else {
    var map = {
      w: 'left',
      e: 'right',
      n: 'top',
      s: 'bottom'
    };
    var inverseMap = {
      left: 'w',
      right: 'e',
      top: 'n',
      bottom: 's'
    };
    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));
    return inverseMap[globalDir];
  }
}

function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {
  var brushOption = cover.__brushOption;
  var rectRange = toRectRange(brushOption.range);
  var localDelta = toLocalDelta(controller, dx, dy);
  each(name.split(''), function (namePart) {
    var ind = DIRECTION_MAP[namePart];
    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
  });
  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}

function driftPolygon(controller, cover, dx, dy, e) {
  var range = cover.__brushOption.range;
  var localDelta = toLocalDelta(controller, dx, dy);
  each(range, function (point) {
    point[0] += localDelta[0];
    point[1] += localDelta[1];
  });
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}

function toLocalDelta(controller, dx, dy) {
  var thisGroup = controller.group;
  var localD = thisGroup.transformCoordToLocal(dx, dy);
  var localZero = thisGroup.transformCoordToLocal(0, 0);
  return [localD[0] - localZero[0], localD[1] - localZero[1]];
}

function clipByPanel(controller, cover, data) {
  var panel = getPanelByCover(controller, cover);
  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);
}

function pointsToRect(points) {
  var xmin = mathMin(points[0][0], points[1][0]);
  var ymin = mathMin(points[0][1], points[1][1]);
  var xmax = mathMax(points[0][0], points[1][0]);
  var ymax = mathMax(points[0][1], points[1][1]);
  return {
    x: xmin,
    y: ymin,
    width: xmax - xmin,
    height: ymax - ymin
  };
}

function resetCursor(controller, e, localCursorPoint) {
  // Check active
  if (!controller._brushType) {
    return;
  }

  var zr = controller._zr;
  var covers = controller._covers;
  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.

  if (!controller._dragging) {
    for (var i = 0; i < covers.length; i++) {
      var brushOption = covers[i].__brushOption;

      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
        // Use cursor style set on cover.
        return;
      }
    }
  }

  currPanel && zr.setCursorStyle('crosshair');
}

function preventDefault(e) {
  var rawE = e.event;
  rawE.preventDefault && rawE.preventDefault();
}

function mainShapeContain(cover, x, y) {
  return cover.childOfName('main').contain(x, y);
}

function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {
  var creatingCover = controller._creatingCover;
  var panel = controller._creatingPanel;
  var thisBrushOption = controller._brushOption;
  var eventParams;

  controller._track.push(localCursorPoint.slice());

  if (shouldShowCover(controller) || creatingCover) {
    if (panel && !creatingCover) {
      thisBrushOption.brushMode === 'single' && clearCovers(controller);
      var brushOption = zrUtil.clone(thisBrushOption);
      brushOption.brushType = determineBrushType(brushOption.brushType, panel);
      brushOption.panelId = panel === true ? null : panel.panelId;
      creatingCover = controller._creatingCover = createCover(controller, brushOption);

      controller._covers.push(creatingCover);
    }

    if (creatingCover) {
      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
      var coverBrushOption = creatingCover.__brushOption;
      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));

      if (isEnd) {
        endCreating(controller, creatingCover);
        coverRenderer.updateCommon(controller, creatingCover);
      }

      updateCoverShape(controller, creatingCover);
      eventParams = {
        isEnd: isEnd
      };
    }
  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {
    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.
    // But a single click do not clear covers, because user may have casual
    // clicks (for example, click on other component and do not expect covers
    // disappear).
    // Only some cover removed, trigger action, but not every click trigger action.
    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {
      eventParams = {
        isEnd: isEnd,
        removeOnClick: true
      };
    }
  }

  return eventParams;
}

function determineBrushType(brushType, panel) {
  if (brushType === 'auto') {
    return panel.defaultBrushType;
  }

  return brushType;
}

var mouseHandlers = {
  mousedown: function (e) {
    if (this._dragging) {
      // In case some browser do not support globalOut,
      // and release mose out side the browser.
      handleDragEnd.call(this, e);
    } else if (!e.target || !e.target.draggable) {
      preventDefault(e);
      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
      this._creatingCover = null;
      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);

      if (panel) {
        this._dragging = true;
        this._track = [localCursorPoint.slice()];
      }
    }
  },
  mousemove: function (e) {
    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
    resetCursor(this, e, localCursorPoint);

    if (this._dragging) {
      preventDefault(e);
      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);
      eventParams && trigger(this, eventParams);
    }
  },
  mouseup: handleDragEnd //,
  // FIXME
  // in tooltip, globalout should not be triggered.
  // globalout: handleDragEnd

};

function handleDragEnd(e) {
  if (this._dragging) {
    preventDefault(e);
    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
    var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);
    this._dragging = false;
    this._track = [];
    this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.

    eventParams && trigger(this, eventParams);
  }
}
/**
 * key: brushType
 * @type {Object}
 */


var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function (controller, brushOption) {
      return createBaseRectCover(curry(driftRect, function (range) {
        return range;
      }, function (range) {
        return range;
      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);
    },
    getCreatingRange: function (localTrack) {
      var ends = getTrackEnds(localTrack);
      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      updateBaseRect(controller, cover, localRange, brushOption);
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function (controller, brushOption) {
      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the
      // border of the shape when drawing, which is a better experience for user.

      cover.add(new graphic.Polyline({
        name: 'main',
        style: makeStyle(brushOption),
        silent: true
      }));
      return cover;
    },
    getCreatingRange: function (localTrack) {
      return localTrack;
    },
    endCreating: function (controller, cover) {
      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.

      cover.add(new graphic.Polygon({
        name: 'main',
        draggable: true,
        drift: curry(driftPolygon, controller, cover),
        ondragend: curry(trigger, controller, {
          isEnd: true
        })
      }));
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      cover.childAt(0).setShape({
        points: clipByPanel(controller, cover, localRange)
      });
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  }
};

function getLineRenderer(xyIndex) {
  return {
    createCover: function (controller, brushOption) {
      return createBaseRectCover(curry(driftRect, function (range) {
        var rectRange = [range, [0, 100]];
        xyIndex && rectRange.reverse();
        return rectRange;
      }, function (rectRange) {
        return rectRange[xyIndex];
      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);
    },
    getCreatingRange: function (localTrack) {
      var ends = getTrackEnds(localTrack);
      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);
      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);
      return [min, max];
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      var otherExtent; // If brushWidth not specified, fit the panel.

      var panel = getPanelByCover(controller, cover);

      if (panel !== true && panel.getLinearBrushOtherExtent) {
        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);
      } else {
        var zr = controller._zr;
        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
      }

      var rectRange = [localRange, otherExtent];
      xyIndex && rectRange.reverse();
      updateBaseRect(controller, cover, rectRange, brushOption);
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  };
}

var _default = BrushController;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/BrushTargetManager.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var brushHelper = __webpack_require__("./node_modules/echarts/lib/component/helper/brushHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var each = zrUtil.each;
var indexOf = zrUtil.indexOf;
var curry = zrUtil.curry;
var COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME
// how to genarialize to more coordinate systems.

var INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];
/**
 * [option in constructor]:
 * {
 *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
 * }
 *
 *
 * [targetInfo]:
 *
 * There can be multiple axes in a single targetInfo. Consider the case
 * of `grid` component, a targetInfo represents a grid which contains one or more
 * cartesian and one or more axes. And consider the case of parallel system,
 * which has multiple axes in a coordinate system.
 * Can be {
 *     panelId: ...,
 *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,
 *     coordSyses: all cartesians.
 *     gridModel: <grid component>
 *     xAxes: correspond to coordSyses on index
 *     yAxes: correspond to coordSyses on index
 * }
 * or {
 *     panelId: ...,
 *     coordSys: <geo coord sys>
 *     coordSyses: [<geo coord sys>]
 *     geoModel: <geo component>
 * }
 *
 *
 * [panelOpt]:
 *
 * Make from targetInfo. Input to BrushController.
 * {
 *     panelId: ...,
 *     rect: ...
 * }
 *
 *
 * [area]:
 *
 * Generated by BrushController or user input.
 * {
 *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.
 *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').
 *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
 *     range: pixel range.
 *     coordRange: representitive coord range (the first one of coordRanges).
 *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.
 * }
 */

/**
 * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid
 *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} [opt]
 * @param {Array.<string>} [opt.include] include coordinate system types.
 */

function BrushTargetManager(option, ecModel, opt) {
  /**
   * @private
   * @type {Array.<Object>}
   */
  var targetInfoList = this._targetInfoList = [];
  var info = {};
  var foundCpts = parseFinder(ecModel, option);
  each(targetInfoBuilders, function (builder, type) {
    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
      builder(foundCpts, targetInfoList, info);
    }
  });
}

var proto = BrushTargetManager.prototype;

proto.setOutputRanges = function (areas, ecModel) {
  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges

    if (!area.coordRange) {
      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not
      // rebuild range by coordRange accrately, which may bring trouble when
      // brushing only one item. So we use __rangeOffset to rebuilding range
      // by coordRange. And this it only used in brush component so it is no
      // need to be adapted to coordRanges.

      var result = coordConvert[area.brushType](0, coordSys, coordRange);
      area.__rangeOffset = {
        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
        xyMinMax: result.xyMinMax
      };
    }
  });
};

proto.matchOutputRanges = function (areas, ecModel, cb) {
  each(areas, function (area) {
    var targetInfo = this.findTargetInfo(area, ecModel);

    if (targetInfo && targetInfo !== true) {
      zrUtil.each(targetInfo.coordSyses, function (coordSys) {
        var result = coordConvert[area.brushType](1, coordSys, area.range);
        cb(area, result.values, coordSys, ecModel);
      });
    }
  }, this);
};

proto.setInputRanges = function (areas, ecModel) {
  each(areas, function (area) {
    var targetInfo = this.findTargetInfo(area, ecModel);
    area.range = area.range || []; // convert coordRange to global range and set panelId.

    if (targetInfo && targetInfo !== true) {
      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does
      // not keep its original value, for the sake of the dataZoom scenario,
      // where area.coordRange remains unchanged but area.range may be changed.
      // (2) Only support converting one coordRange to pixel range in brush
      // component. So do not consider `coordRanges`.
      // (3) About __rangeOffset, see comment above.

      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
      var rangeOffset = area.__rangeOffset;
      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
    }
  }, this);
};

proto.makePanelOpts = function (api, getDefaultBrushType) {
  return zrUtil.map(this._targetInfoList, function (targetInfo) {
    var rect = targetInfo.getPanelRect();
    return {
      panelId: targetInfo.panelId,
      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),
      clipPath: brushHelper.makeRectPanelClipPath(rect),
      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)
    };
  });
};

proto.controlSeries = function (area, seriesModel, ecModel) {
  // Check whether area is bound in coord, and series do not belong to that coord.
  // If do not do this check, some brush (like lineX) will controll all axes.
  var targetInfo = this.findTargetInfo(area, ecModel);
  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
};
/**
 * If return Object, a coord found.
 * If reutrn true, global found.
 * Otherwise nothing found.
 *
 * @param {Object} area
 * @param {Array} targetInfoList
 * @return {Object|boolean}
 */


proto.findTargetInfo = function (area, ecModel) {
  var targetInfoList = this._targetInfoList;
  var foundCpts = parseFinder(ecModel, area);

  for (var i = 0; i < targetInfoList.length; i++) {
    var targetInfo = targetInfoList[i];
    var areaPanelId = area.panelId;

    if (areaPanelId) {
      if (targetInfo.panelId === areaPanelId) {
        return targetInfo;
      }
    } else {
      for (var i = 0; i < targetInfoMatchers.length; i++) {
        if (targetInfoMatchers[i](foundCpts, targetInfo)) {
          return targetInfo;
        }
      }
    }
  }

  return true;
};

function formatMinMax(minMax) {
  minMax[0] > minMax[1] && minMax.reverse();
  return minMax;
}

function parseFinder(ecModel, option) {
  return modelUtil.parseFinder(ecModel, option, {
    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
  });
}

var targetInfoBuilders = {
  grid: function (foundCpts, targetInfoList) {
    var xAxisModels = foundCpts.xAxisModels;
    var yAxisModels = foundCpts.yAxisModels;
    var gridModels = foundCpts.gridModels; // Remove duplicated.

    var gridModelMap = zrUtil.createHashMap();
    var xAxesHas = {};
    var yAxesHas = {};

    if (!xAxisModels && !yAxisModels && !gridModels) {
      return;
    }

    each(xAxisModels, function (axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
    });
    each(yAxisModels, function (axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      yAxesHas[gridModel.id] = true;
    });
    each(gridModels, function (gridModel) {
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
      yAxesHas[gridModel.id] = true;
    });
    gridModelMap.each(function (gridModel) {
      var grid = gridModel.coordinateSystem;
      var cartesians = [];
      each(grid.getCartesians(), function (cartesian, index) {
        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {
          cartesians.push(cartesian);
        }
      });
      targetInfoList.push({
        panelId: 'grid--' + gridModel.id,
        gridModel: gridModel,
        coordSysModel: gridModel,
        // Use the first one as the representitive coordSys.
        coordSys: cartesians[0],
        coordSyses: cartesians,
        getPanelRect: panelRectBuilder.grid,
        xAxisDeclared: xAxesHas[gridModel.id],
        yAxisDeclared: yAxesHas[gridModel.id]
      });
    });
  },
  geo: function (foundCpts, targetInfoList) {
    each(foundCpts.geoModels, function (geoModel) {
      var coordSys = geoModel.coordinateSystem;
      targetInfoList.push({
        panelId: 'geo--' + geoModel.id,
        geoModel: geoModel,
        coordSysModel: geoModel,
        coordSys: coordSys,
        coordSyses: [coordSys],
        getPanelRect: panelRectBuilder.geo
      });
    });
  }
};
var targetInfoMatchers = [// grid
function (foundCpts, targetInfo) {
  var xAxisModel = foundCpts.xAxisModel;
  var yAxisModel = foundCpts.yAxisModel;
  var gridModel = foundCpts.gridModel;
  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
  return gridModel && gridModel === targetInfo.gridModel;
}, // geo
function (foundCpts, targetInfo) {
  var geoModel = foundCpts.geoModel;
  return geoModel && geoModel === targetInfo.geoModel;
}];
var panelRectBuilder = {
  grid: function () {
    // grid is not Transformable.
    return this.coordSys.grid.getRect().clone();
  },
  geo: function () {
    var coordSys = this.coordSys;
    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform

    rect.applyTransform(graphic.getTransform(coordSys));
    return rect;
  }
};
var coordConvert = {
  lineX: curry(axisConvert, 0),
  lineY: curry(axisConvert, 1),
  rect: function (to, coordSys, rangeOrCoordRange) {
    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);
    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);
    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
    return {
      values: values,
      xyMinMax: values
    };
  },
  polygon: function (to, coordSys, rangeOrCoordRange) {
    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
    var values = zrUtil.map(rangeOrCoordRange, function (item) {
      var p = coordSys[COORD_CONVERTS[to]](item);
      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
      return p;
    });
    return {
      values: values,
      xyMinMax: xyMinMax
    };
  }
};

function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);
  var values = formatMinMax(zrUtil.map([0, 1], function (i) {
    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
  }));
  var xyMinMax = [];
  xyMinMax[axisNameIndex] = values;
  xyMinMax[1 - axisNameIndex] = [NaN, NaN];
  return {
    values: values,
    xyMinMax: xyMinMax
  };
}

var diffProcessor = {
  lineX: curry(axisDiffProcessor, 0),
  lineY: curry(axisDiffProcessor, 1),
  rect: function (values, refer, scales) {
    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
  },
  polygon: function (values, refer, scales) {
    return zrUtil.map(values, function (item, idx) {
      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
    });
  }
};

function axisDiffProcessor(axisNameIndex, values, refer, scales) {
  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
} // We have to process scale caused by dataZoom manually,
// although it might be not accurate.


function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
  var sizeCurr = getSize(xyMinMaxCurr);
  var sizeOrigin = getSize(xyMinMaxOrigin);
  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
  isNaN(scales[0]) && (scales[0] = 1);
  isNaN(scales[1]) && (scales[1] = 1);
  return scales;
}

function getSize(xyMinMax) {
  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}

var _default = BrushTargetManager;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/RoamController.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var eventTool = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var interactionMutex = __webpack_require__("./node_modules/echarts/lib/component/helper/interactionMutex.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @alias module:echarts/component/helper/RoamController
 * @constructor
 * @mixin {module:zrender/mixin/Eventful}
 *
 * @param {module:zrender/zrender~ZRender} zr
 */
function RoamController(zr) {
  /**
   * @type {Function}
   */
  this.pointerChecker;
  /**
   * @type {module:zrender}
   */

  this._zr = zr;
  /**
   * @type {Object}
   */

  this._opt = {}; // Avoid two roamController bind the same handler

  var bind = zrUtil.bind;
  var mousedownHandler = bind(mousedown, this);
  var mousemoveHandler = bind(mousemove, this);
  var mouseupHandler = bind(mouseup, this);
  var mousewheelHandler = bind(mousewheel, this);
  var pinchHandler = bind(pinch, this);
  Eventful.call(this);
  /**
   * @param {Function} pointerChecker
   *                   input: x, y
   *                   output: boolean
   */

  this.setPointerChecker = function (pointerChecker) {
    this.pointerChecker = pointerChecker;
  };
  /**
   * Notice: only enable needed types. For example, if 'zoom'
   * is not needed, 'zoom' should not be enabled, otherwise
   * default mousewheel behaviour (scroll page) will be disabled.
   *
   * @param  {boolean|string} [controlType=true] Specify the control type,
   *                          which can be null/undefined or true/false
   *                          or 'pan/move' or 'zoom'/'scale'
   * @param {Object} [opt]
   * @param {Object} [opt.zoomOnMouseWheel=true]
   * @param {Object} [opt.moveOnMouseMove=true]
   * @param {Object} [opt.preventDefaultMouseMove=true] When pan.
   */


  this.enable = function (controlType, opt) {
    // Disable previous first
    this.disable();
    this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      preventDefaultMouseMove: true
    });

    if (controlType == null) {
      controlType = true;
    }

    if (controlType === true || controlType === 'move' || controlType === 'pan') {
      zr.on('mousedown', mousedownHandler);
      zr.on('mousemove', mousemoveHandler);
      zr.on('mouseup', mouseupHandler);
    }

    if (controlType === true || controlType === 'scale' || controlType === 'zoom') {
      zr.on('mousewheel', mousewheelHandler);
      zr.on('pinch', pinchHandler);
    }
  };

  this.disable = function () {
    zr.off('mousedown', mousedownHandler);
    zr.off('mousemove', mousemoveHandler);
    zr.off('mouseup', mouseupHandler);
    zr.off('mousewheel', mousewheelHandler);
    zr.off('pinch', pinchHandler);
  };

  this.dispose = this.disable;

  this.isDragging = function () {
    return this._dragging;
  };

  this.isPinching = function () {
    return this._pinching;
  };
}

zrUtil.mixin(RoamController, Eventful);

function mousedown(e) {
  if (eventTool.notLeftMouse(e) || e.target && e.target.draggable) {
    return;
  }

  var x = e.offsetX;
  var y = e.offsetY; // Only check on mosedown, but not mousemove.
  // Mouse can be out of target when mouse moving.

  if (this.pointerChecker && this.pointerChecker(e, x, y)) {
    this._x = x;
    this._y = y;
    this._dragging = true;
  }
}

function mousemove(e) {
  if (eventTool.notLeftMouse(e) || !checkKeyBinding(this, 'moveOnMouseMove', e) || !this._dragging || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {
    return;
  }

  var x = e.offsetX;
  var y = e.offsetY;
  var oldX = this._x;
  var oldY = this._y;
  var dx = x - oldX;
  var dy = y - oldY;
  this._x = x;
  this._y = y;
  this._opt.preventDefaultMouseMove && eventTool.stop(e.event);
  this.trigger('pan', dx, dy, oldX, oldY, x, y);
}

function mouseup(e) {
  if (!eventTool.notLeftMouse(e)) {
    this._dragging = false;
  }
}

function mousewheel(e) {
  // wheelDelta maybe -0 in chrome mac.
  if (!checkKeyBinding(this, 'zoomOnMouseWheel', e) || e.wheelDelta === 0) {
    return;
  } // Convenience:
  // Mac and VM Windows on Mac: scroll up: zoom out.
  // Windows: scroll up: zoom in.


  var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;
  zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);
}

function pinch(e) {
  if (interactionMutex.isTaken(this._zr, 'globalPan')) {
    return;
  }

  var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
  zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);
}

function zoom(e, zoomDelta, zoomX, zoomY) {
  if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) {
    // When mouse is out of roamController rect,
    // default befavoius should not be be disabled, otherwise
    // page sliding is disabled, contrary to expectation.
    eventTool.stop(e.event);
    this.trigger('zoom', zoomDelta, zoomX, zoomY);
  }
}

function checkKeyBinding(roamController, prop, e) {
  var setting = roamController._opt[prop];
  return setting && (!zrUtil.isString(setting) || e.event[setting + 'Key']);
}

var _default = RoamController;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/brushHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var _cursorHelper = __webpack_require__("./node_modules/echarts/lib/component/helper/cursorHelper.js");

var onIrrelevantElement = _cursorHelper.onIrrelevantElement;

var graphicUtil = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function makeRectPanelClipPath(rect) {
  rect = normalizeRect(rect);
  return function (localPoints, transform) {
    return graphicUtil.clipPointsByRect(localPoints, rect);
  };
}

function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
  rect = normalizeRect(rect);
  return function (xyIndex) {
    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
    var brushWidth = idx ? rect.width : rect.height;
    var base = idx ? rect.x : rect.y;
    return [base, base + (brushWidth || 0)];
  };
}

function makeRectIsTargetByCursor(rect, api, targetModel) {
  rect = normalizeRect(rect);
  return function (e, localCursorPoint, transform) {
    return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);
  };
} // Consider width/height is negative.


function normalizeRect(rect) {
  return BoundingRect.create(rect);
}

exports.makeRectPanelClipPath = makeRectPanelClipPath;
exports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;
exports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/cursorHelper.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var IRRELEVANT_EXCLUDES = {
  'axisPointer': 1,
  'tooltip': 1,
  'brush': 1
};
/**
 * Avoid that: mouse click on a elements that is over geo or graph,
 * but roam is triggered.
 */

function onIrrelevantElement(e, api, targetCoordSysModel) {
  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.

  var coordSys = model && model.coordinateSystem;
  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;
}

exports.onIrrelevantElement = onIrrelevantElement;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/interactionMutex.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var ATTR = '\0_ec_interaction_mutex';

function take(zr, resourceKey, userKey) {
  var store = getStore(zr);
  store[resourceKey] = userKey;
}

function release(zr, resourceKey, userKey) {
  var store = getStore(zr);
  var uKey = store[resourceKey];

  if (uKey === userKey) {
    store[resourceKey] = null;
  }
}

function isTaken(zr, resourceKey) {
  return !!getStore(zr)[resourceKey];
}

function getStore(zr) {
  return zr[ATTR] || (zr[ATTR] = {});
}
/**
 * payload: {
 *     type: 'takeGlobalCursor',
 *     key: 'dataZoomSelect', or 'brush', or ...,
 *         If no userKey, release global cursor.
 * }
 */


echarts.registerAction({
  type: 'takeGlobalCursor',
  event: 'globalCursorTaken',
  update: 'update'
}, function () {});
exports.take = take;
exports.release = release;
exports.isTaken = isTaken;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/listComponent.js":
/***/ (function(module, exports, __webpack_require__) {

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutRect = _layout.getLayoutRect;
var layoutBox = _layout.box;
var positionElement = _layout.positionElement;

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Layout list like component.
 * It will box layout each items in group of component and then position the whole group in the viewport
 * @param {module:zrender/group/Group} group
 * @param {module:echarts/model/Component} componentModel
 * @param {module:echarts/ExtensionAPI}
 */
function layout(group, componentModel, api) {
  var boxLayoutParams = componentModel.getBoxLayoutParams();
  var padding = componentModel.get('padding');
  var viewportSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);
  positionElement(group, boxLayoutParams, viewportSize, padding);
}

function makeBackground(rect, componentModel) {
  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));
  var style = componentModel.getItemStyle(['color', 'opacity']);
  style.fill = componentModel.get('backgroundColor');
  var rect = new graphic.Rect({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get('borderRadius')
    },
    style: style,
    silent: true,
    z2: -1
  }); // FIXME
  // `subPixelOptimizeRect` may bring some gap between edge of viewpart
  // and background rect when setting like `left: 0`, `top: 0`.
  // graphic.subPixelOptimizeRect(rect);

  return rect;
}

exports.layout = layout;
exports.makeBackground = makeBackground;

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/sliderMove.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Calculate slider move result.
 * Usage:
 * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as
 * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.
 * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.
 *
 * @param {number} delta Move length.
 * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].
 *              handleEnds will be modified in this method.
 * @param {Array.<number>} extent handleEnds is restricted by extent.
 *              extent[0] should less or equals than extent[1].
 * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,
 *              where the input minSpan and maxSpan will not work.
 * @param {number} [minSpan] The range of dataZoom can not be smaller than that.
 *              If not set, handle0 and cross handle1. If set as a non-negative
 *              number (including `0`), handles will push each other when reaching
 *              the minSpan.
 * @param {number} [maxSpan] The range of dataZoom can not be larger than that.
 * @return {Array.<number>} The input handleEnds.
 */
function _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
  // Normalize firstly.
  handleEnds[0] = restrict(handleEnds[0], extent);
  handleEnds[1] = restrict(handleEnds[1], extent);
  delta = delta || 0;
  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.

  if (minSpan != null) {
    minSpan = restrict(minSpan, [0, extentSpan]);
  }

  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }

  if (handleIndex === 'all') {
    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleIndex = 0;
  }

  var originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta; // Restrict in extent.

  var extentMinSpan = minSpan || 0;
  var realExtent = extent.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.

  var currDistSign = getSpanSign(handleEnds, handleIndex);

  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    // If minSpan exists, 'cross' is forbinden.
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  } // Shrink span.


  var currDistSign = getSpanSign(handleEnds, handleIndex);

  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }

  return handleEnds;
}

function getSpanSign(handleEnds, handleIndex) {
  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]
  // is at left of handleEnds[1] for non-cross case.

  return {
    span: Math.abs(dist),
    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
  };
}

function restrict(value, extend) {
  return Math.min(extend[1], Math.max(extend[0], value));
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/LegendModel.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/legendAction.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/LegendView.js");

var legendFilter = __webpack_require__("./node_modules/echarts/lib/component/legend/legendFilter.js");

var Component = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Do not contain scrollable legend, for sake of file size.
// Series Filter
echarts.registerProcessor(legendFilter);
Component.registerSubTypeDefaulter('legend', function () {
  // Default 'plain' when no type specified.
  return 'plain';
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/LegendModel.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var isNameSpecified = _model.isNameSpecified;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var LegendModel = echarts.extendComponentModel({
  type: 'legend.plain',
  dependencies: ['series'],
  layoutMode: {
    type: 'box',
    // legend.width/height are maxWidth/maxHeight actually,
    // whereas realy width/height is calculated by its content.
    // (Setting {left: 10, right: 10} does not make sense).
    // So consider the case:
    // `setOption({legend: {left: 10});`
    // then `setOption({legend: {right: 10});`
    // The previous `left` should be cleared by setting `ignoreSize`.
    ignoreSize: true
  },
  init: function (option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};
  },
  mergeOption: function (option) {
    LegendModel.superCall(this, 'mergeOption', option);
  },
  optionUpdated: function () {
    this._updateData(this.ecModel);

    var legendData = this._data; // If selectedMode is single, try to select one

    if (legendData[0] && this.get('selectedMode') === 'single') {
      var hasSelected = false; // If has any selected in option.selected

      for (var i = 0; i < legendData.length; i++) {
        var name = legendData[i].get('name');

        if (this.isSelected(name)) {
          // Force to unselect others
          this.select(name);
          hasSelected = true;
          break;
        }
      } // Try select the first if selectedMode is single


      !hasSelected && this.select(legendData[0].get('name'));
    }
  },
  _updateData: function (ecModel) {
    var potentialData = [];
    var availableNames = [];
    ecModel.eachRawSeries(function (seriesModel) {
      var seriesName = seriesModel.name;
      availableNames.push(seriesName);
      var isPotential;

      if (seriesModel.legendDataProvider) {
        var data = seriesModel.legendDataProvider();
        var names = data.mapArray(data.getName);

        if (!ecModel.isSeriesFiltered(seriesModel)) {
          availableNames = availableNames.concat(names);
        }

        if (names.length) {
          potentialData = potentialData.concat(names);
        } else {
          isPotential = true;
        }
      } else {
        isPotential = true;
      }

      if (isPotential && isNameSpecified(seriesModel)) {
        potentialData.push(seriesModel.name);
      }
    });
    /**
     * @type {Array.<string>}
     * @private
     */

    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,
    // which is convinient for user preparing option.

    var rawData = this.get('data') || potentialData;
    var legendData = zrUtil.map(rawData, function (dataItem) {
      // Can be string or number
      if (typeof dataItem === 'string' || typeof dataItem === 'number') {
        dataItem = {
          name: dataItem
        };
      }

      return new Model(dataItem, this, this.ecModel);
    }, this);
    /**
     * @type {Array.<module:echarts/model/Model>}
     * @private
     */

    this._data = legendData;
  },

  /**
   * @return {Array.<module:echarts/model/Model>}
   */
  getData: function () {
    return this._data;
  },

  /**
   * @param {string} name
   */
  select: function (name) {
    var selected = this.option.selected;
    var selectedMode = this.get('selectedMode');

    if (selectedMode === 'single') {
      var data = this._data;
      zrUtil.each(data, function (dataItem) {
        selected[dataItem.get('name')] = false;
      });
    }

    selected[name] = true;
  },

  /**
   * @param {string} name
   */
  unSelect: function (name) {
    if (this.get('selectedMode') !== 'single') {
      this.option.selected[name] = false;
    }
  },

  /**
   * @param {string} name
   */
  toggleSelected: function (name) {
    var selected = this.option.selected; // Default is true

    if (!selected.hasOwnProperty(name)) {
      selected[name] = true;
    }

    this[selected[name] ? 'unSelect' : 'select'](name);
  },

  /**
   * @param {string} name
   */
  isSelected: function (name) {
    var selected = this.option.selected;
    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;
  },
  defaultOption: {
    // 一级层叠
    zlevel: 0,
    // 二级层叠
    z: 4,
    show: true,
    // 布局方式，默认为水平布局，可选为：
    // 'horizontal' | 'vertical'
    orient: 'horizontal',
    left: 'center',
    // right: 'center',
    top: 0,
    // bottom: null,
    // 水平对齐
    // 'auto' | 'left' | 'right'
    // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐
    align: 'auto',
    backgroundColor: 'rgba(0,0,0,0)',
    // 图例边框颜色
    borderColor: '#ccc',
    borderRadius: 0,
    // 图例边框线宽，单位px，默认为0（无边框）
    borderWidth: 0,
    // 图例内边距，单位px，默认各方向内边距为5，
    // 接受数组分别设定上右下左边距，同css
    padding: 5,
    // 各个item之间的间隔，单位px，默认为10，
    // 横向布局时为水平间隔，纵向布局时为纵向间隔
    itemGap: 10,
    // 图例图形宽度
    itemWidth: 25,
    // 图例图形高度
    itemHeight: 14,
    // 图例关闭时候的颜色
    inactiveColor: '#ccc',
    textStyle: {
      // 图例文字颜色
      color: '#333'
    },
    // formatter: '',
    // 选择模式，默认开启图例开关
    selectedMode: true,
    // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入
    // selected: null,
    // 图例内容（详见legend.data，数组中每一项代表一个item
    // data: [],
    // Tooltip 相关配置
    tooltip: {
      show: false
    }
  }
});
var _default = LegendModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/LegendView.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _symbol = __webpack_require__("./node_modules/echarts/lib/util/symbol.js");

var createSymbol = _symbol.createSymbol;

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _listComponent = __webpack_require__("./node_modules/echarts/lib/component/helper/listComponent.js");

var makeBackground = _listComponent.makeBackground;

var layoutUtil = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var curry = zrUtil.curry;
var each = zrUtil.each;
var Group = graphic.Group;

var _default = echarts.extendComponentView({
  type: 'legend.plain',
  newlineDisabled: false,

  /**
   * @override
   */
  init: function () {
    /**
     * @private
     * @type {module:zrender/container/Group}
     */
    this.group.add(this._contentGroup = new Group());
    /**
     * @private
     * @type {module:zrender/Element}
     */

    this._backgroundEl;
  },

  /**
   * @protected
   */
  getContentGroup: function () {
    return this._contentGroup;
  },

  /**
   * @override
   */
  render: function (legendModel, ecModel, api) {
    this.resetInner();

    if (!legendModel.get('show', true)) {
      return;
    }

    var itemAlign = legendModel.get('align');

    if (!itemAlign || itemAlign === 'auto') {
      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';
    }

    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.

    var positionInfo = legendModel.getBoxLayoutParams();
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var padding = legendModel.get('padding');
    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);
    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.

    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.

    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  },

  /**
   * @protected
   */
  resetInner: function () {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
  },

  /**
   * @protected
   */
  renderInner: function (itemAlign, legendModel, ecModel, api) {
    var contentGroup = this.getContentGroup();
    var legendDrawnMap = zrUtil.createHashMap();
    var selectMode = legendModel.get('selectedMode');
    var excludeSeriesId = [];
    ecModel.eachRawSeries(function (seriesModel) {
      !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);
    });
    each(legendModel.getData(), function (itemModel, dataIndex) {
      var name = itemModel.get('name'); // Use empty string or \n as a newline string

      if (!this.newlineDisabled && (name === '' || name === '\n')) {
        contentGroup.add(new Group({
          newline: true
        }));
        return;
      } // Representitive series.


      var seriesModel = ecModel.getSeriesByName(name)[0];

      if (legendDrawnMap.get(name)) {
        // Have been drawed
        return;
      } // Series legend


      if (seriesModel) {
        var data = seriesModel.getData();
        var color = data.getVisual('color'); // If color is a callback function

        if (typeof color === 'function') {
          // Use the first data
          color = color(seriesModel.getDataParams(0));
        } // Using rect symbol defaultly


        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';
        var symbolType = data.getVisual('symbol');

        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);

        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api, excludeSeriesId));
        legendDrawnMap.set(name, true);
      } else {
        // Data legend of pie, funnel
        ecModel.eachRawSeries(function (seriesModel) {
          // In case multiple series has same data name
          if (legendDrawnMap.get(name)) {
            return;
          }

          if (seriesModel.legendDataProvider) {
            var data = seriesModel.legendDataProvider();
            var idx = data.indexOfName(name);

            if (idx < 0) {
              return;
            }

            var color = data.getItemVisual(idx, 'color');
            var legendSymbolType = 'roundRect';

            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode); // FIXME: consider different series has items with the same name.


            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name
            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api, excludeSeriesId));
            legendDrawnMap.set(name, true);
          }
        }, this);
      }
    }, this);
  },
  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {
    var itemWidth = legendModel.get('itemWidth');
    var itemHeight = legendModel.get('itemHeight');
    var inactiveColor = legendModel.get('inactiveColor');
    var symbolKeepAspect = legendModel.get('symbolKeepAspect');
    var isSelected = legendModel.isSelected(name);
    var itemGroup = new Group();
    var textStyleModel = itemModel.getModel('textStyle');
    var itemIcon = itemModel.get('icon');
    var tooltipModel = itemModel.getModel('tooltip');
    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first

    legendSymbolType = itemIcon || legendSymbolType;
    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend
    symbolKeepAspect == null ? true : symbolKeepAspect)); // Compose symbols
    // PENDING

    if (!itemIcon && symbolType // At least show one symbol, can't be all none
    && (symbolType !== legendSymbolType || symbolType == 'none')) {
      var size = itemHeight * 0.8;

      if (symbolType === 'none') {
        symbolType = 'circle';
      } // Put symbol in the center


      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend
      symbolKeepAspect == null ? true : symbolKeepAspect));
    }

    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
    var textAlign = itemAlign;
    var formatter = legendModel.get('formatter');
    var content = name;

    if (typeof formatter === 'string' && formatter) {
      content = formatter.replace('{name}', name != null ? name : '');
    } else if (typeof formatter === 'function') {
      content = formatter(name);
    }

    itemGroup.add(new graphic.Text({
      style: graphic.setTextStyle({}, textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
        textAlign: textAlign,
        textVerticalAlign: 'middle'
      })
    })); // Add a invisible rect to increase the area of mouse hover

    var hitRect = new graphic.Rect({
      shape: itemGroup.getBoundingRect(),
      invisible: true,
      tooltip: tooltipModel.get('show') ? zrUtil.extend({
        content: name,
        // Defaul formatter
        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {
          return name;
        },
        formatterParams: {
          componentType: 'legend',
          legendIndex: legendModel.componentIndex,
          name: name,
          $vars: ['name']
        }
      }, tooltipModel.option) : null
    });
    itemGroup.add(hitRect);
    itemGroup.eachChild(function (child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    graphic.setHoverStyle(itemGroup);
    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  },

  /**
   * @protected
   */
  layoutInner: function (legendModel, itemAlign, maxSize) {
    var contentGroup = this.getContentGroup(); // Place items in contentGroup.

    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);
    var contentRect = contentGroup.getBoundingRect();
    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);
    return this.group.getBoundingRect();
  }
});

function dispatchSelectAction(name, api) {
  api.dispatchAction({
    type: 'legendToggleSelect',
    name: name
  });
}

function dispatchHighlightAction(seriesModel, dataName, api, excludeSeriesId) {
  // If element hover will move to a hoverLayer.
  var el = api.getZr().storage.getDisplayList()[0];

  if (!(el && el.useHoverLayer)) {
    api.dispatchAction({
      type: 'highlight',
      seriesName: seriesModel.name,
      name: dataName,
      excludeSeriesId: excludeSeriesId
    });
  }
}

function dispatchDownplayAction(seriesModel, dataName, api, excludeSeriesId) {
  // If element hover will move to a hoverLayer.
  var el = api.getZr().storage.getDisplayList()[0];

  if (!(el && el.useHoverLayer)) {
    api.dispatchAction({
      type: 'downplay',
      seriesName: seriesModel.name,
      name: dataName,
      excludeSeriesId: excludeSeriesId
    });
  }
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js":
/***/ (function(module, exports, __webpack_require__) {

var LegendModel = __webpack_require__("./node_modules/echarts/lib/component/legend/LegendModel.js");

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var mergeLayoutParam = _layout.mergeLayoutParam;
var getLayoutParams = _layout.getLayoutParams;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var ScrollableLegendModel = LegendModel.extend({
  type: 'legend.scroll',

  /**
   * @param {number} scrollDataIndex
   */
  setScrollDataIndex: function (scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  },
  defaultOption: {
    scrollDataIndex: 0,
    pageButtonItemGap: 5,
    pageButtonGap: null,
    pageButtonPosition: 'end',
    // 'start' or 'end'
    pageFormatter: '{current}/{total}',
    // If null/undefined, do not show page.
    pageIcons: {
      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']
    },
    pageIconColor: '#2f4554',
    pageIconInactiveColor: '#aaa',
    pageIconSize: 15,
    // Can be [10, 3], which represents [width, height]
    pageTextStyle: {
      color: '#333'
    },
    animationDurationUpdate: 800
  },

  /**
   * @override
   */
  init: function (option, parentModel, ecModel, extraOpt) {
    var inputPositionParams = getLayoutParams(option);
    ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);
    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
  },

  /**
   * @override
   */
  mergeOption: function (option, extraOpt) {
    ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);
    mergeAndNormalizeLayoutParams(this, this.option, option);
  },
  getOrient: function () {
    return this.get('orient') === 'vertical' ? {
      index: 1,
      name: 'vertical'
    } : {
      index: 0,
      name: 'horizontal'
    };
  }
}); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.

function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
  var orient = legendModel.getOrient();
  var ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  mergeLayoutParam(target, raw, {
    type: 'box',
    ignoreSize: ignoreSize
  });
}

var _default = ScrollableLegendModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/ScrollableLegendView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var layoutUtil = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var LegendView = __webpack_require__("./node_modules/echarts/lib/component/legend/LegendView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Separate legend and scrollable legend to reduce package size.
 */
var Group = graphic.Group;
var WH = ['width', 'height'];
var XY = ['x', 'y'];
var ScrollableLegendView = LegendView.extend({
  type: 'legend.scroll',
  newlineDisabled: true,
  init: function () {
    ScrollableLegendView.superCall(this, 'init');
    /**
     * @private
     * @type {number} For `scroll`.
     */

    this._currentIndex = 0;
    /**
     * @private
     * @type {module:zrender/container/Group}
     */

    this.group.add(this._containerGroup = new Group());

    this._containerGroup.add(this.getContentGroup());
    /**
     * @private
     * @type {module:zrender/container/Group}
     */


    this.group.add(this._controllerGroup = new Group());
    /**
     *
     * @private
     */

    this._showController;
  },

  /**
   * @override
   */
  resetInner: function () {
    ScrollableLegendView.superCall(this, 'resetInner');

    this._controllerGroup.removeAll();

    this._containerGroup.removeClipPath();

    this._containerGroup.__rectSize = null;
  },

  /**
   * @override
   */
  renderInner: function (itemAlign, legendModel, ecModel, api) {
    var me = this; // Render content items.

    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);
    var controllerGroup = this._controllerGroup;
    var pageIconSize = legendModel.get('pageIconSize', true);

    if (!zrUtil.isArray(pageIconSize)) {
      pageIconSize = [pageIconSize, pageIconSize];
    }

    createPageButton('pagePrev', 0);
    var pageTextStyleModel = legendModel.getModel('pageTextStyle');
    controllerGroup.add(new graphic.Text({
      name: 'pageText',
      style: {
        textFill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        textVerticalAlign: 'middle',
        textAlign: 'center'
      },
      silent: true
    }));
    createPageButton('pageNext', 1);

    function createPageButton(name, iconIdx) {
      var pageDataIndexName = name + 'DataIndex';
      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {
        // Buttons will be created in each render, so we do not need
        // to worry about avoiding using legendModel kept in scope.
        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)
      }, {
        x: -pageIconSize[0] / 2,
        y: -pageIconSize[1] / 2,
        width: pageIconSize[0],
        height: pageIconSize[1]
      });
      icon.name = name;
      controllerGroup.add(icon);
    }
  },

  /**
   * @override
   */
  layoutInner: function (legendModel, itemAlign, maxSize) {
    var contentGroup = this.getContentGroup();
    var containerGroup = this._containerGroup;
    var controllerGroup = this._controllerGroup;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var hw = WH[1 - orientIdx];
    var yx = XY[1 - orientIdx]; // Place items in contentGroup.

    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    layoutUtil.box( // Buttons in controller are layout always horizontally.
    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));
    var contentRect = contentGroup.getBoundingRect();
    var controllerRect = controllerGroup.getBoundingRect();
    var showController = this._showController = contentRect[wh] > maxSize[wh];
    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.

    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.

    var containerPos = [0, 0];
    var controllerPos = [-controllerRect.x, -controllerRect.y];
    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.

    if (showController) {
      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.

      if (pageButtonPosition === 'end') {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } // controller is on the left / top.
      else {
          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
        }
    } // Always align controller to content as 'middle'.


    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.attr('position', contentPos);
    containerGroup.attr('position', containerPos);
    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.
    // mainRect should not be calculated by `this.group.getBoundingRect()`
    // for sake of the overflow.

    var mainRect = this.group.getBoundingRect();
    var mainRect = {
      x: 0,
      y: 0
    }; // Consider content may be overflow (should be clipped).

    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.

    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];

    if (showController) {
      var clipShape = {
        x: 0,
        y: 0
      };
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new graphic.Rect({
        shape: clipShape
      })); // Consider content may be larger than container, container rect
      // can not be obtained from `containerGroup.getBoundingRect()`.

      containerGroup.__rectSize = clipShape[wh];
    } else {
      // Do not remove or ignore controller. Keep them set as place holders.
      controllerGroup.eachChild(function (child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    } // Content translate animation.


    var pageInfo = this._getPageInfo(legendModel);

    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {
      position: pageInfo.contentPosition
    }, // When switch from "show controller" to "not show controller", view should be
    // updated immediately without animation, otherwise causes weird efffect.
    showController ? legendModel : false);

    this._updatePageInfoView(legendModel, pageInfo);

    return mainRect;
  },
  _pageGo: function (to, legendModel, api) {
    var scrollDataIndex = this._getPageInfo(legendModel)[to];

    scrollDataIndex != null && api.dispatchAction({
      type: 'legendScroll',
      scrollDataIndex: scrollDataIndex,
      legendId: legendModel.id
    });
  },
  _updatePageInfoView: function (legendModel, pageInfo) {
    var controllerGroup = this._controllerGroup;
    zrUtil.each(['pagePrev', 'pageNext'], function (name) {
      var canJump = pageInfo[name + 'DataIndex'] != null;
      var icon = controllerGroup.childOfName(name);

      if (icon) {
        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));
        icon.cursor = canJump ? 'pointer' : 'default';
      }
    });
    var pageText = controllerGroup.childOfName('pageText');
    var pageFormatter = legendModel.get('pageFormatter');
    var pageIndex = pageInfo.pageIndex;
    var current = pageIndex != null ? pageIndex + 1 : 0;
    var total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({
      current: current,
      total: total
    }));
  },

  /**
   * @param {module:echarts/model/Model} legendModel
   * @return {Object} {
   *  contentPosition: Array.<number>, null when data item not found.
   *  pageIndex: number, null when data item not found.
   *  pageCount: number, always be a number, can be 0.
   *  pagePrevDataIndex: number, null when no next page.
   *  pageNextDataIndex: number, null when no previous page.
   * }
   */
  _getPageInfo: function (legendModel) {
    // Align left or top by the current dataIndex.
    var currDataIndex = legendModel.get('scrollDataIndex', true);
    var contentGroup = this.getContentGroup();
    var contentRect = contentGroup.getBoundingRect();
    var containerRectSize = this._containerGroup.__rectSize;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var hw = WH[1 - orientIdx];
    var xy = XY[orientIdx];
    var contentPos = contentGroup.position.slice();
    var pageIndex;
    var pagePrevDataIndex;
    var pageNextDataIndex;
    var targetItemGroup;

    if (this._showController) {
      contentGroup.eachChild(function (child) {
        if (child.__legendDataIndex === currDataIndex) {
          targetItemGroup = child;
        }
      });
    } else {
      targetItemGroup = contentGroup.childAt(0);
    }

    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;

    if (targetItemGroup) {
      var itemRect = targetItemGroup.getBoundingRect();
      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];
      contentPos[orientIdx] = -itemLoc - contentRect[xy];
      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);
      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;
      var winRect = {
        x: 0,
        y: 0
      };
      winRect[wh] = containerRectSize;
      winRect[hw] = contentRect[hw];
      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];
      var startIdx;
      var children = contentGroup.children();
      contentGroup.eachChild(function (child, index) {
        var itemRect = getItemRect(child);

        if (itemRect.intersect(winRect)) {
          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the
          // current window is shown at the begining of next window.

          pageNextDataIndex = child.__legendDataIndex;
        } // If the last item is shown entirely, no next page.


        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {
          pageNextDataIndex = null;
        }
      }); // Always align based on the left/top most item, so the left/top most
      // item in the previous window is needed to be found here.

      if (startIdx != null) {
        var startItem = children[startIdx];
        var startRect = getItemRect(startItem);
        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.

        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {
          pagePrevDataIndex = null;
        } else {
          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {
            startIdx--;
          }

          pagePrevDataIndex = children[startIdx].__legendDataIndex;
        }
      }
    }

    return {
      contentPosition: contentPos,
      pageIndex: pageIndex,
      pageCount: pageCount,
      pagePrevDataIndex: pagePrevDataIndex,
      pageNextDataIndex: pageNextDataIndex
    };

    function getItemRect(el) {
      var itemRect = el.getBoundingRect().clone();
      itemRect[xy] += el.position[orientIdx];
      return itemRect;
    }
  }
});
var _default = ScrollableLegendView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/legendAction.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function legendSelectActionHandler(methodName, payload, ecModel) {
  var selectedMap = {};
  var isToggleSelect = methodName === 'toggleSelected';
  var isSelected; // Update all legend components

  ecModel.eachComponent('legend', function (legendModel) {
    if (isToggleSelect && isSelected != null) {
      // Force other legend has same selected status
      // Or the first is toggled to true and other are toggled to false
      // In the case one legend has some item unSelected in option. And if other legend
      // doesn't has the item, they will assume it is selected.
      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
    } else {
      legendModel[methodName](payload.name);
      isSelected = legendModel.isSelected(payload.name);
    }

    var legendData = legendModel.getData();
    zrUtil.each(legendData, function (model) {
      var name = model.get('name'); // Wrap element

      if (name === '\n' || name === '') {
        return;
      }

      var isItemSelected = legendModel.isSelected(name);

      if (selectedMap.hasOwnProperty(name)) {
        // Unselected if any legend is unselected
        selectedMap[name] = selectedMap[name] && isItemSelected;
      } else {
        selectedMap[name] = isItemSelected;
      }
    });
  }); // Return the event explicitly

  return {
    name: payload.name,
    selected: selectedMap
  };
}
/**
 * @event legendToggleSelect
 * @type {Object}
 * @property {string} type 'legendToggleSelect'
 * @property {string} [from]
 * @property {string} name Series name or data item name
 */


echarts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));
/**
 * @event legendSelect
 * @type {Object}
 * @property {string} type 'legendSelect'
 * @property {string} name Series name or data item name
 */

echarts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));
/**
 * @event legendUnSelect
 * @type {Object}
 * @property {string} type 'legendUnSelect'
 * @property {string} name Series name or data item name
 */

echarts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/legendFilter.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function _default(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: 'legend'
  });

  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function (series) {
      // If in any legend component the status is not selected.
      // Because in legend series is assumed selected when it is not in the legend data.
      for (var i = 0; i < legendModels.length; i++) {
        if (!legendModels[i].isSelected(series.name)) {
          return false;
        }
      }

      return true;
    });
  }
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/scrollableLegendAction.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @event legendScroll
 * @type {Object}
 * @property {string} type 'legendScroll'
 * @property {string} scrollDataIndex
 */
echarts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {
  var scrollDataIndex = payload.scrollDataIndex;
  scrollDataIndex != null && ecModel.eachComponent({
    mainType: 'legend',
    subType: 'scroll',
    query: payload
  }, function (legendModel) {
    legendModel.setScrollDataIndex(scrollDataIndex);
  });
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/legendScroll.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/component/legend.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/ScrollableLegendView.js");

__webpack_require__("./node_modules/echarts/lib/component/legend/scrollableLegendAction.js");

/***/ }),

/***/ "./node_modules/echarts/lib/component/markLine.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

__webpack_require__("./node_modules/echarts/lib/component/marker/MarkLineModel.js");

__webpack_require__("./node_modules/echarts/lib/component/marker/MarkLineView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
echarts.registerPreprocessor(function (opt) {
  // Make sure markLine component is enabled
  opt.markLine = opt.markLine || {};
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/markPoint.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

__webpack_require__("./node_modules/echarts/lib/component/marker/MarkPointModel.js");

__webpack_require__("./node_modules/echarts/lib/component/marker/MarkPointView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// HINT Markpoint can't be used too much
echarts.registerPreprocessor(function (opt) {
  // Make sure markPoint component is enabled
  opt.markPoint = opt.markPoint || {};
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkLineModel.js":
/***/ (function(module, exports, __webpack_require__) {

var MarkerModel = __webpack_require__("./node_modules/echarts/lib/component/marker/MarkerModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = MarkerModel.extend({
  type: 'markLine',
  defaultOption: {
    zlevel: 0,
    z: 5,
    symbol: ['circle', 'arrow'],
    symbolSize: [8, 16],
    //symbolRotate: 0,
    precision: 2,
    tooltip: {
      trigger: 'item'
    },
    label: {
      show: true,
      position: 'end'
    },
    lineStyle: {
      type: 'dashed'
    },
    emphasis: {
      label: {
        show: true
      },
      lineStyle: {
        width: 3
      }
    },
    animationEasing: 'linear'
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkLineView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var List = __webpack_require__("./node_modules/echarts/lib/data/List.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var markerHelper = __webpack_require__("./node_modules/echarts/lib/component/marker/markerHelper.js");

var LineDraw = __webpack_require__("./node_modules/echarts/lib/chart/helper/LineDraw.js");

var MarkerView = __webpack_require__("./node_modules/echarts/lib/component/marker/MarkerView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var markLineTransform = function (seriesModel, coordSys, mlModel, item) {
  var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average', 'median'

  var mlType = item.type;

  if (!zrUtil.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' // In case
  // data: [{
  //   yAxis: 10
  // }]
  || item.xAxis != null || item.yAxis != null)) {
    var valueAxis;
    var valueDataDim;
    var value;

    if (item.yAxis != null || item.xAxis != null) {
      valueDataDim = item.yAxis != null ? 'y' : 'x';
      valueAxis = coordSys.getAxis(valueDataDim);
      value = zrUtil.retrieve(item.yAxis, item.xAxis);
    } else {
      var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
      valueDataDim = axisInfo.valueDataDim;
      valueAxis = axisInfo.valueAxis;
      value = markerHelper.numCalculate(data, valueDataDim, mlType);
    }

    var valueIndex = valueDataDim === 'x' ? 0 : 1;
    var baseIndex = 1 - valueIndex;
    var mlFrom = zrUtil.clone(item);
    var mlTo = {};
    mlFrom.type = null;
    mlFrom.coord = [];
    mlTo.coord = [];
    mlFrom.coord[baseIndex] = -Infinity;
    mlTo.coord[baseIndex] = Infinity;
    var precision = mlModel.get('precision');

    if (precision >= 0 && typeof value === 'number') {
      value = +value.toFixed(Math.min(precision, 20));
    }

    mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
    item = [mlFrom, mlTo, {
      // Extra option for tooltip and label
      type: mlType,
      valueIndex: item.valueIndex,
      // Force to use the value of calculated value.
      value: value
    }];
  }

  item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])]; // Avoid line data type is extended by from(to) data type

  item[2].type = item[2].type || ''; // Merge from option and to option into line option

  zrUtil.merge(item[2], item[0]);
  zrUtil.merge(item[2], item[1]);
  return item;
};

function isInifinity(val) {
  return !isNaN(val) && !isFinite(val);
} // If a markLine has one dim


function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  var otherDimIndex = 1 - dimIndex;
  var dimName = coordSys.dimensions[dimIndex];
  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
}

function markLineFilter(coordSys, item) {
  if (coordSys.type === 'cartesian2d') {
    var fromCoord = item[0].coord;
    var toCoord = item[1].coord; // In case
    // {
    //  markLine: {
    //    data: [{ yAxis: 2 }]
    //  }
    // }

    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
  }

  return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
}

function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  var itemModel = data.getItemModel(idx);
  var point;
  var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
  var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());

  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    // Chart like bar may have there own marker positioning logic
    if (seriesModel.getMarkerPosition) {
      // Use the getMarkerPoisition
      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
    } else {
      var dims = coordSys.dimensions;
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);
      point = coordSys.dataToPoint([x, y]);
    } // Expand line to the edge of grid if value on one axis is Inifnity
    // In case
    //  markLine: {
    //    data: [{
    //      yAxis: 2
    //      // or
    //      type: 'average'
    //    }]
    //  }


    if (coordSys.type === 'cartesian2d') {
      var xAxis = coordSys.getAxis('x');
      var yAxis = coordSys.getAxis('y');
      var dims = coordSys.dimensions;

      if (isInifinity(data.get(dims[0], idx))) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
      } else if (isInifinity(data.get(dims[1], idx))) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
      }
    } // Use x, y if has any


    if (!isNaN(xPx)) {
      point[0] = xPx;
    }

    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }

  data.setItemLayout(idx, point);
}

var _default = MarkerView.extend({
  type: 'markLine',
  // updateLayout: function (markLineModel, ecModel, api) {
  //     ecModel.eachSeries(function (seriesModel) {
  //         var mlModel = seriesModel.markLineModel;
  //         if (mlModel) {
  //             var mlData = mlModel.getData();
  //             var fromData = mlModel.__from;
  //             var toData = mlModel.__to;
  //             // Update visual and layout of from symbol and to symbol
  //             fromData.each(function (idx) {
  //                 updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
  //                 updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
  //             });
  //             // Update layout of line
  //             mlData.each(function (idx) {
  //                 mlData.setItemLayout(idx, [
  //                     fromData.getItemLayout(idx),
  //                     toData.getItemLayout(idx)
  //                 ]);
  //             });
  //             this.markerGroupMap.get(seriesModel.id).updateLayout();
  //         }
  //     }, this);
  // },
  updateTransform: function (markLineModel, ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      var mlModel = seriesModel.markLineModel;

      if (mlModel) {
        var mlData = mlModel.getData();
        var fromData = mlModel.__from;
        var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol

        fromData.each(function (idx) {
          updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
          updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
        }); // Update layout of line

        mlData.each(function (idx) {
          mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
        });
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  },
  renderSeries: function (seriesModel, mlModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var lineDrawMap = this.markerGroupMap;
    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());
    this.group.add(lineDraw.group);
    var mlData = createList(coordSys, seriesModel, mlModel);
    var fromData = mlData.from;
    var toData = mlData.to;
    var lineData = mlData.line;
    mlModel.__from = fromData;
    mlModel.__to = toData; // Line data for tooltip and formatter

    mlModel.setData(lineData);
    var symbolType = mlModel.get('symbol');
    var symbolSize = mlModel.get('symbolSize');

    if (!zrUtil.isArray(symbolType)) {
      symbolType = [symbolType, symbolType];
    }

    if (typeof symbolSize === 'number') {
      symbolSize = [symbolSize, symbolSize];
    } // Update visual and layout of from symbol and to symbol


    mlData.from.each(function (idx) {
      updateDataVisualAndLayout(fromData, idx, true);
      updateDataVisualAndLayout(toData, idx, false);
    }); // Update visual and layout of line

    lineData.each(function (idx) {
      var lineColor = lineData.getItemModel(idx).get('lineStyle.color');
      lineData.setItemVisual(idx, {
        color: lineColor || fromData.getItemVisual(idx, 'color')
      });
      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
      lineData.setItemVisual(idx, {
        'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),
        'fromSymbol': fromData.getItemVisual(idx, 'symbol'),
        'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),
        'toSymbol': toData.getItemVisual(idx, 'symbol')
      });
    });
    lineDraw.updateData(lineData); // Set host model for tooltip
    // FIXME

    mlData.line.eachItemGraphicEl(function (el, idx) {
      el.traverse(function (child) {
        child.dataModel = mlModel;
      });
    });

    function updateDataVisualAndLayout(data, idx, isFrom) {
      var itemModel = data.getItemModel(idx);
      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
      data.setItemVisual(idx, {
        symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],
        symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],
        color: itemModel.get('itemStyle.color') || seriesData.getVisual('color')
      });
    }

    lineDraw.__keep = true;
    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');
  }
});
/**
 * @inner
 * @param {module:echarts/coord/*} coordSys
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */


function createList(coordSys, seriesModel, mlModel) {
  var coordDimsInfos;

  if (coordSys) {
    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

      return zrUtil.defaults({
        name: coordDim
      }, info);
    });
  } else {
    coordDimsInfos = [{
      name: 'value',
      type: 'float'
    }];
  }

  var fromData = new List(coordDimsInfos, mlModel);
  var toData = new List(coordDimsInfos, mlModel); // No dimensions

  var lineData = new List([], mlModel);
  var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));

  if (coordSys) {
    optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));
  }

  var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {
    return item.value;
  };
  fromData.initData(zrUtil.map(optData, function (item) {
    return item[0];
  }), null, dimValueGetter);
  toData.initData(zrUtil.map(optData, function (item) {
    return item[1];
  }), null, dimValueGetter);
  lineData.initData(zrUtil.map(optData, function (item) {
    return item[2];
  }));
  lineData.hasItemOption = true;
  return {
    from: fromData,
    to: toData,
    line: lineData
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkPointModel.js":
/***/ (function(module, exports, __webpack_require__) {

var MarkerModel = __webpack_require__("./node_modules/echarts/lib/component/marker/MarkerModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = MarkerModel.extend({
  type: 'markPoint',
  defaultOption: {
    zlevel: 0,
    z: 5,
    symbol: 'pin',
    symbolSize: 50,
    //symbolRotate: 0,
    //symbolOffset: [0, 0]
    tooltip: {
      trigger: 'item'
    },
    label: {
      show: true,
      position: 'inside'
    },
    itemStyle: {
      borderWidth: 2
    },
    emphasis: {
      label: {
        show: true
      }
    }
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkPointView.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var SymbolDraw = __webpack_require__("./node_modules/echarts/lib/chart/helper/SymbolDraw.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var List = __webpack_require__("./node_modules/echarts/lib/data/List.js");

var markerHelper = __webpack_require__("./node_modules/echarts/lib/component/marker/markerHelper.js");

var MarkerView = __webpack_require__("./node_modules/echarts/lib/component/marker/MarkerView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function updateMarkerLayout(mpData, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  mpData.each(function (idx) {
    var itemModel = mpData.getItemModel(idx);
    var point;
    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());

    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } // Chart like bar may have there own marker positioning logic
    else if (seriesModel.getMarkerPosition) {
        // Use the getMarkerPoisition
        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
      } else if (coordSys) {
        var x = mpData.get(coordSys.dimensions[0], idx);
        var y = mpData.get(coordSys.dimensions[1], idx);
        point = coordSys.dataToPoint([x, y]);
      } // Use x, y if has any


    if (!isNaN(xPx)) {
      point[0] = xPx;
    }

    if (!isNaN(yPx)) {
      point[1] = yPx;
    }

    mpData.setItemLayout(idx, point);
  });
}

var _default = MarkerView.extend({
  type: 'markPoint',
  // updateLayout: function (markPointModel, ecModel, api) {
  //     ecModel.eachSeries(function (seriesModel) {
  //         var mpModel = seriesModel.markPointModel;
  //         if (mpModel) {
  //             updateMarkerLayout(mpModel.getData(), seriesModel, api);
  //             this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
  //         }
  //     }, this);
  // },
  updateTransform: function (markPointModel, ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      var mpModel = seriesModel.markPointModel;

      if (mpModel) {
        updateMarkerLayout(mpModel.getData(), seriesModel, api);
        this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
      }
    }, this);
  },
  renderSeries: function (seriesModel, mpModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var symbolDrawMap = this.markerGroupMap;
    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());
    var mpData = createList(coordSys, seriesModel, mpModel); // FIXME

    mpModel.setData(mpData);
    updateMarkerLayout(mpModel.getData(), seriesModel, api);
    mpData.each(function (idx) {
      var itemModel = mpData.getItemModel(idx);
      var symbolSize = itemModel.getShallow('symbolSize');

      if (typeof symbolSize === 'function') {
        // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？
        symbolSize = symbolSize(mpModel.getRawValue(idx), mpModel.getDataParams(idx));
      }

      mpData.setItemVisual(idx, {
        symbolSize: symbolSize,
        color: itemModel.get('itemStyle.color') || seriesData.getVisual('color'),
        symbol: itemModel.getShallow('symbol')
      });
    }); // TODO Text are wrong

    symbolDraw.updateData(mpData);
    this.group.add(symbolDraw.group); // Set host model for tooltip
    // FIXME

    mpData.eachItemGraphicEl(function (el) {
      el.traverse(function (child) {
        child.dataModel = mpModel;
      });
    });
    symbolDraw.__keep = true;
    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');
  }
});
/**
 * @inner
 * @param {module:echarts/coord/*} [coordSys]
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */


function createList(coordSys, seriesModel, mpModel) {
  var coordDimsInfos;

  if (coordSys) {
    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

      return zrUtil.defaults({
        name: coordDim
      }, info);
    });
  } else {
    coordDimsInfos = [{
      name: 'value',
      type: 'float'
    }];
  }

  var mpData = new List(coordDimsInfos, mpModel);
  var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));

  if (coordSys) {
    dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));
  }

  mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {
    return item.value;
  });
  return mpData;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkerModel.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var dataFormatMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/dataFormat.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var addCommas = formatUtil.addCommas;
var encodeHTML = formatUtil.encodeHTML;

function fillLabel(opt) {
  modelUtil.defaultEmphasis(opt, 'label', ['show']);
}

var MarkerModel = echarts.extendComponentModel({
  type: 'marker',
  dependencies: ['series', 'grid', 'polar', 'geo'],

  /**
   * @overrite
   */
  init: function (option, parentModel, ecModel, extraOpt) {
    this.mergeDefaultAndTheme(option, ecModel);
    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);
  },

  /**
   * @return {boolean}
   */
  isAnimationEnabled: function () {
    if (env.node) {
      return false;
    }

    var hostSeries = this.__hostSeries;
    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();
  },
  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {
    var MarkerModel = this.constructor;
    var modelPropName = this.mainType + 'Model';

    if (!createdBySelf) {
      ecModel.eachSeries(function (seriesModel) {
        var markerOpt = seriesModel.get(this.mainType, true);
        var markerModel = seriesModel[modelPropName];

        if (!markerOpt || !markerOpt.data) {
          seriesModel[modelPropName] = null;
          return;
        }

        if (!markerModel) {
          if (isInit) {
            // Default label emphasis `position` and `show`
            fillLabel(markerOpt);
          }

          zrUtil.each(markerOpt.data, function (item) {
            // FIXME Overwrite fillLabel method ?
            if (item instanceof Array) {
              fillLabel(item[0]);
              fillLabel(item[1]);
            } else {
              fillLabel(item);
            }
          });
          markerModel = new MarkerModel(markerOpt, this, ecModel);
          zrUtil.extend(markerModel, {
            mainType: this.mainType,
            // Use the same series index and name
            seriesIndex: seriesModel.seriesIndex,
            name: seriesModel.name,
            createdBySelf: true
          });
          markerModel.__hostSeries = seriesModel;
        } else {
          markerModel.mergeOption(markerOpt, ecModel, true);
        }

        seriesModel[modelPropName] = markerModel;
      }, this);
    }
  },
  formatTooltip: function (dataIndex) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);
    var name = data.getName(dataIndex);
    var html = encodeHTML(this.name);

    if (value != null || name) {
      html += '<br />';
    }

    if (name) {
      html += encodeHTML(name);

      if (value != null) {
        html += ' : ';
      }
    }

    if (value != null) {
      html += encodeHTML(formattedValue);
    }

    return html;
  },
  getData: function () {
    return this._data;
  },
  setData: function (data) {
    this._data = data;
  }
});
zrUtil.mixin(MarkerModel, dataFormatMixin);
var _default = MarkerModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkerView.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = echarts.extendComponentView({
  type: 'marker',
  init: function () {
    /**
     * Markline grouped by series
     * @private
     * @type {module:zrender/core/util.HashMap}
     */
    this.markerGroupMap = zrUtil.createHashMap();
  },
  render: function (markerModel, ecModel, api) {
    var markerGroupMap = this.markerGroupMap;
    markerGroupMap.each(function (item) {
      item.__keep = false;
    });
    var markerModelKey = this.type + 'Model';
    ecModel.eachSeries(function (seriesModel) {
      var markerModel = seriesModel[markerModelKey];
      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);
    }, this);
    markerGroupMap.each(function (item) {
      !item.__keep && this.group.remove(item.group);
    }, this);
  },
  renderSeries: function () {}
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/markerHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var _dataStackHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/dataStackHelper.js");

var isDimensionStacked = _dataStackHelper.isDimensionStacked;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var indexOf = zrUtil.indexOf;

function hasXOrY(item) {
  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
}

function hasXAndY(item) {
  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
} // Make it simple, do not visit all stacked value to count precision.
// function getPrecision(data, valueAxisDim, dataIndex) {
//     var precision = -1;
//     var stackedDim = data.mapDimension(valueAxisDim);
//     do {
//         precision = Math.max(
//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),
//             precision
//         );
//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
//         if (stackedOnSeries) {
//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);
//             data = stackedOnSeries.getData();
//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);
//             stackedDim = data.getCalculationInfo('stackedDimension');
//         }
//         else {
//             data = null;
//         }
//     } while (data);
//     return precision;
// }


function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
  var coordArr = [];
  var stacked = isDimensionStacked(data, targetDataDim
  /*, otherDataDim*/
  );
  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;
  var value = numCalculate(data, calcDataDim, mlType);
  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.

  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));
  precision = Math.min(precision, 20);

  if (precision >= 0) {
    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
  }

  return coordArr;
}

var curry = zrUtil.curry; // TODO Specified percent

var markerTypeCalculator = {
  /**
   * @method
   * @param {module:echarts/data/List} data
   * @param {string} baseAxisDim
   * @param {string} valueAxisDim
   */
  min: curry(markerTypeCalculatorWithExtent, 'min'),

  /**
   * @method
   * @param {module:echarts/data/List} data
   * @param {string} baseAxisDim
   * @param {string} valueAxisDim
   */
  max: curry(markerTypeCalculatorWithExtent, 'max'),

  /**
   * @method
   * @param {module:echarts/data/List} data
   * @param {string} baseAxisDim
   * @param {string} valueAxisDim
   */
  average: curry(markerTypeCalculatorWithExtent, 'average')
};
/**
 * Transform markPoint data item to format used in List by do the following
 * 1. Calculate statistic like `max`, `min`, `average`
 * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
 * @param  {module:echarts/model/Series} seriesModel
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {Object}
 */

function dataTransform(seriesModel, item) {
  var data = seriesModel.getData();
  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly
  // 2. If `coord` is not a data array. Which uses `xAxis`,
  // `yAxis` to specify the coord on each dimension
  // parseFloat first because item.x and item.y can be percent string like '20%'

  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {
    var dims = coordSys.dimensions;
    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option
    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value

    item = zrUtil.clone(item);

    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.

      item.value = item.coord[targetCoordIndex];
    } else {
      // FIXME Only has one of xAxis and yAxis.
      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average

      for (var i = 0; i < 2; i++) {
        if (markerTypeCalculator[coord[i]]) {
          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
        }
      }

      item.coord = coord;
    }
  }

  return item;
}

function getAxisInfo(item, data, coordSys, seriesModel) {
  var ret = {};

  if (item.valueIndex != null || item.valueDim != null) {
    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
  } else {
    ret.baseAxis = seriesModel.getBaseAxis();
    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
  }

  return ret;
}

function dataDimToCoordDim(seriesModel, dataDim) {
  var data = seriesModel.getData();
  var dimensions = data.dimensions;
  dataDim = data.getDimension(dataDim);

  for (var i = 0; i < dimensions.length; i++) {
    var dimItem = data.getDimensionInfo(dimensions[i]);

    if (dimItem.name === dataDim) {
      return dimItem.coordDim;
    }
  }
}
/**
 * Filter data which is out of coordinateSystem range
 * [dataFilter description]
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {boolean}
 */


function dataFilter(coordSys, item) {
  // Alwalys return true if there is no coordSys
  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
}

function dimValueGetter(item, dimName, dataIndex, dimIndex) {
  // x, y, radius, angle
  if (dimIndex < 2) {
    return item.coord && item.coord[dimIndex];
  }

  return item.value;
}

function numCalculate(data, valueDataDim, type) {
  if (type === 'average') {
    var sum = 0;
    var count = 0;
    data.each(valueDataDim, function (val, idx) {
      if (!isNaN(val)) {
        sum += val;
        count++;
      }
    });
    return sum / count;
  } else if (type === 'median') {
    return data.getMedian(valueDataDim);
  } else {
    // max & min
    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];
  }
}

exports.dataTransform = dataTransform;
exports.getAxisInfo = getAxisInfo;
exports.dataFilter = dataFilter;
exports.dimValueGetter = dimValueGetter;
exports.numCalculate = numCalculate;

/***/ }),

/***/ "./node_modules/echarts/lib/component/title.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutRect = _layout.getLayoutRect;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Model
echarts.extendComponentModel({
  type: 'title',
  layoutMode: {
    type: 'box',
    ignoreSize: true
  },
  defaultOption: {
    // 一级层叠
    zlevel: 0,
    // 二级层叠
    z: 6,
    show: true,
    text: '',
    // 超链接跳转
    // link: null,
    // 仅支持self | blank
    target: 'blank',
    subtext: '',
    // 超链接跳转
    // sublink: null,
    // 仅支持self | blank
    subtarget: 'blank',
    // 'center' ¦ 'left' ¦ 'right'
    // ¦ {number}（x坐标，单位px）
    left: 0,
    // 'top' ¦ 'bottom' ¦ 'center'
    // ¦ {number}（y坐标，单位px）
    top: 0,
    // 水平对齐
    // 'auto' | 'left' | 'right' | 'center'
    // 默认根据 left 的位置判断是左对齐还是右对齐
    // textAlign: null
    //
    // 垂直对齐
    // 'auto' | 'top' | 'bottom' | 'middle'
    // 默认根据 top 位置判断是上对齐还是下对齐
    // textBaseline: null
    backgroundColor: 'rgba(0,0,0,0)',
    // 标题边框颜色
    borderColor: '#ccc',
    // 标题边框线宽，单位px，默认为0（无边框）
    borderWidth: 0,
    // 标题内边距，单位px，默认各方向内边距为5，
    // 接受数组分别设定上右下左边距，同css
    padding: 5,
    // 主副标题纵向间隔，单位px，默认为10，
    itemGap: 10,
    textStyle: {
      fontSize: 18,
      fontWeight: 'bolder',
      color: '#333'
    },
    subtextStyle: {
      color: '#aaa'
    }
  }
}); // View

echarts.extendComponentView({
  type: 'title',
  render: function (titleModel, ecModel, api) {
    this.group.removeAll();

    if (!titleModel.get('show')) {
      return;
    }

    var group = this.group;
    var textStyleModel = titleModel.getModel('textStyle');
    var subtextStyleModel = titleModel.getModel('subtextStyle');
    var textAlign = titleModel.get('textAlign');
    var textBaseline = titleModel.get('textBaseline');
    var textEl = new graphic.Text({
      style: graphic.setTextStyle({}, textStyleModel, {
        text: titleModel.get('text'),
        textFill: textStyleModel.getTextColor()
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var textRect = textEl.getBoundingRect();
    var subText = titleModel.get('subtext');
    var subTextEl = new graphic.Text({
      style: graphic.setTextStyle({}, subtextStyleModel, {
        text: subText,
        textFill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get('itemGap'),
        textVerticalAlign: 'top'
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var link = titleModel.get('link');
    var sublink = titleModel.get('sublink');
    textEl.silent = !link;
    subTextEl.silent = !sublink;

    if (link) {
      textEl.on('click', function () {
        window.open(link, '_' + titleModel.get('target'));
      });
    }

    if (sublink) {
      subTextEl.on('click', function () {
        window.open(sublink, '_' + titleModel.get('subtarget'));
      });
    }

    group.add(textEl);
    subText && group.add(subTextEl); // If no subText, but add subTextEl, there will be an empty line.

    var groupRect = group.getBoundingRect();
    var layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    var layoutRect = getLayoutRect(layoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    }, titleModel.get('padding')); // Adjust text align based on position

    if (!textAlign) {
      // Align left if title is on the left. center and right is same
      textAlign = titleModel.get('left') || titleModel.get('right');

      if (textAlign === 'middle') {
        textAlign = 'center';
      } // Adjust layout by text align


      if (textAlign === 'right') {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === 'center') {
        layoutRect.x += layoutRect.width / 2;
      }
    }

    if (!textBaseline) {
      textBaseline = titleModel.get('top') || titleModel.get('bottom');

      if (textBaseline === 'center') {
        textBaseline = 'middle';
      }

      if (textBaseline === 'bottom') {
        layoutRect.y += layoutRect.height;
      } else if (textBaseline === 'middle') {
        layoutRect.y += layoutRect.height / 2;
      }

      textBaseline = textBaseline || 'top';
    }

    group.attr('position', [layoutRect.x, layoutRect.y]);
    var alignStyle = {
      textAlign: textAlign,
      textVerticalAlign: textBaseline
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle); // Render background
    // Get groupRect again because textAlign has been changed

    groupRect = group.getBoundingRect();
    var padding = layoutRect.margin;
    var style = titleModel.getItemStyle(['color', 'opacity']);
    style.fill = titleModel.get('backgroundColor');
    var rect = new graphic.Rect({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get('borderRadius')
      },
      style: style,
      silent: true
    });
    graphic.subPixelOptimizeRect(rect);
    group.add(rect);
  }
});

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/component/toolbox/ToolboxModel.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/ToolboxView.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/feature/MagicType.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/feature/DataView.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js");

__webpack_require__("./node_modules/echarts/lib/component/toolbox/feature/Restore.js");

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/ToolboxModel.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var ToolboxModel = echarts.extendComponentModel({
  type: 'toolbox',
  layoutMode: {
    type: 'box',
    ignoreSize: true
  },
  optionUpdated: function () {
    ToolboxModel.superApply(this, 'optionUpdated', arguments);
    zrUtil.each(this.option.feature, function (featureOpt, featureName) {
      var Feature = featureManager.get(featureName);
      Feature && zrUtil.merge(featureOpt, Feature.defaultOption);
    });
  },
  defaultOption: {
    show: true,
    z: 6,
    zlevel: 0,
    orient: 'horizontal',
    left: 'right',
    top: 'top',
    // right
    // bottom
    backgroundColor: 'transparent',
    borderColor: '#ccc',
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemSize: 15,
    itemGap: 8,
    showTitle: true,
    iconStyle: {
      borderColor: '#666',
      color: 'none'
    },
    emphasis: {
      iconStyle: {
        borderColor: '#3E98C5'
      } // textStyle: {},
      // feature

    }
  }
});
var _default = ToolboxModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/ToolboxView.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var DataDiffer = __webpack_require__("./node_modules/echarts/lib/data/DataDiffer.js");

var listComponentHelper = __webpack_require__("./node_modules/echarts/lib/component/helper/listComponent.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = echarts.extendComponentView({
  type: 'toolbox',
  render: function (toolboxModel, ecModel, api, payload) {
    var group = this.group;
    group.removeAll();

    if (!toolboxModel.get('show')) {
      return;
    }

    var itemSize = +toolboxModel.get('itemSize');
    var featureOpts = toolboxModel.get('feature') || {};
    var features = this._features || (this._features = {});
    var featureNames = [];
    zrUtil.each(featureOpts, function (opt, name) {
      featureNames.push(name);
    });
    new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute(); // Keep for diff.

    this._featureNames = featureNames;

    function processFeature(newIndex, oldIndex) {
      var featureName = featureNames[newIndex];
      var oldName = featureNames[oldIndex];
      var featureOpt = featureOpts[featureName];
      var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);
      var feature;

      if (featureName && !oldName) {
        // Create
        if (isUserFeatureName(featureName)) {
          feature = {
            model: featureModel,
            onclick: featureModel.option.onclick,
            featureName: featureName
          };
        } else {
          var Feature = featureManager.get(featureName);

          if (!Feature) {
            return;
          }

          feature = new Feature(featureModel, ecModel, api);
        }

        features[featureName] = feature;
      } else {
        feature = features[oldName]; // If feature does not exsit.

        if (!feature) {
          return;
        }

        feature.model = featureModel;
        feature.ecModel = ecModel;
        feature.api = api;
      }

      if (!featureName && oldName) {
        feature.dispose && feature.dispose(ecModel, api);
        return;
      }

      if (!featureModel.get('show') || feature.unusable) {
        feature.remove && feature.remove(ecModel, api);
        return;
      }

      createIconPaths(featureModel, feature, featureName);

      featureModel.setIconStatus = function (iconName, status) {
        var option = this.option;
        var iconPaths = this.iconPaths;
        option.iconStatus = option.iconStatus || {};
        option.iconStatus[iconName] = status; // FIXME

        iconPaths[iconName] && iconPaths[iconName].trigger(status);
      };

      if (feature.render) {
        feature.render(featureModel, ecModel, api, payload);
      }
    }

    function createIconPaths(featureModel, feature, featureName) {
      var iconStyleModel = featureModel.getModel('iconStyle');
      var iconStyleEmphasisModel = featureModel.getModel('emphasis.iconStyle'); // If one feature has mutiple icon. they are orginaized as
      // {
      //     icon: {
      //         foo: '',
      //         bar: ''
      //     },
      //     title: {
      //         foo: '',
      //         bar: ''
      //     }
      // }

      var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');
      var titles = featureModel.get('title') || {};

      if (typeof icons === 'string') {
        var icon = icons;
        var title = titles;
        icons = {};
        titles = {};
        icons[featureName] = icon;
        titles[featureName] = title;
      }

      var iconPaths = featureModel.iconPaths = {};
      zrUtil.each(icons, function (iconStr, iconName) {
        var path = graphic.createIcon(iconStr, {}, {
          x: -itemSize / 2,
          y: -itemSize / 2,
          width: itemSize,
          height: itemSize
        });
        path.setStyle(iconStyleModel.getItemStyle());
        path.hoverStyle = iconStyleEmphasisModel.getItemStyle();
        graphic.setHoverStyle(path);

        if (toolboxModel.get('showTitle')) {
          path.__title = titles[iconName];
          path.on('mouseover', function () {
            // Should not reuse above hoverStyle, which might be modified.
            var hoverStyle = iconStyleEmphasisModel.getItemStyle();
            path.setStyle({
              text: titles[iconName],
              textPosition: hoverStyle.textPosition || 'bottom',
              textFill: hoverStyle.fill || hoverStyle.stroke || '#000',
              textAlign: hoverStyle.textAlign || 'center'
            });
          }).on('mouseout', function () {
            path.setStyle({
              textFill: null
            });
          });
        }

        path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');
        group.add(path);
        path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));
        iconPaths[iconName] = path;
      });
    }

    listComponentHelper.layout(group, toolboxModel, api); // Render background after group is layout
    // FIXME

    group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen

    group.eachChild(function (icon) {
      var titleText = icon.__title;
      var hoverStyle = icon.hoverStyle; // May be background element

      if (hoverStyle && titleText) {
        var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));
        var offsetX = icon.position[0] + group.position[0];
        var offsetY = icon.position[1] + group.position[1] + itemSize;
        var needPutOnTop = false;

        if (offsetY + rect.height > api.getHeight()) {
          hoverStyle.textPosition = 'top';
          needPutOnTop = true;
        }

        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;

        if (offsetX + rect.width / 2 > api.getWidth()) {
          hoverStyle.textPosition = ['100%', topOffset];
          hoverStyle.textAlign = 'right';
        } else if (offsetX - rect.width / 2 < 0) {
          hoverStyle.textPosition = [0, topOffset];
          hoverStyle.textAlign = 'left';
        }
      }
    });
  },
  updateView: function (toolboxModel, ecModel, api, payload) {
    zrUtil.each(this._features, function (feature) {
      feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
    });
  },
  // updateLayout: function (toolboxModel, ecModel, api, payload) {
  //     zrUtil.each(this._features, function (feature) {
  //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
  //     });
  // },
  remove: function (ecModel, api) {
    zrUtil.each(this._features, function (feature) {
      feature.remove && feature.remove(ecModel, api);
    });
    this.group.removeAll();
  },
  dispose: function (ecModel, api) {
    zrUtil.each(this._features, function (feature) {
      feature.dispose && feature.dispose(ecModel, api);
    });
  }
});

function isUserFeatureName(featureName) {
  return featureName.indexOf('my') === 0;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/DataView.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var eventTool = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var dataViewLang = lang.toolbox.dataView;
var BLOCK_SPLITER = new Array(60).join('-');
var ITEM_SPLITER = '\t';
/**
 * Group series into two types
 *  1. on category axis, like line, bar
 *  2. others, like scatter, pie
 * @param {module:echarts/model/Global} ecModel
 * @return {Object}
 * @inner
 */

function groupSeries(ecModel) {
  var seriesGroupByCategoryAxis = {};
  var otherSeries = [];
  var meta = [];
  ecModel.eachRawSeries(function (seriesModel) {
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {
      var baseAxis = coordSys.getBaseAxis();

      if (baseAxis.type === 'category') {
        var key = baseAxis.dim + '_' + baseAxis.index;

        if (!seriesGroupByCategoryAxis[key]) {
          seriesGroupByCategoryAxis[key] = {
            categoryAxis: baseAxis,
            valueAxis: coordSys.getOtherAxis(baseAxis),
            series: []
          };
          meta.push({
            axisDim: baseAxis.dim,
            axisIndex: baseAxis.index
          });
        }

        seriesGroupByCategoryAxis[key].series.push(seriesModel);
      } else {
        otherSeries.push(seriesModel);
      }
    } else {
      otherSeries.push(seriesModel);
    }
  });
  return {
    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,
    other: otherSeries,
    meta: meta
  };
}
/**
 * Assemble content of series on cateogory axis
 * @param {Array.<module:echarts/model/Series>} series
 * @return {string}
 * @inner
 */


function assembleSeriesWithCategoryAxis(series) {
  var tables = [];
  zrUtil.each(series, function (group, key) {
    var categoryAxis = group.categoryAxis;
    var valueAxis = group.valueAxis;
    var valueAxisDim = valueAxis.dim;
    var headers = [' '].concat(zrUtil.map(group.series, function (series) {
      return series.name;
    }));
    var columns = [categoryAxis.model.getCategories()];
    zrUtil.each(group.series, function (series) {
      columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {
        return val;
      }));
    }); // Assemble table content

    var lines = [headers.join(ITEM_SPLITER)];

    for (var i = 0; i < columns[0].length; i++) {
      var items = [];

      for (var j = 0; j < columns.length; j++) {
        items.push(columns[j][i]);
      }

      lines.push(items.join(ITEM_SPLITER));
    }

    tables.push(lines.join('\n'));
  });
  return tables.join('\n\n' + BLOCK_SPLITER + '\n\n');
}
/**
 * Assemble content of other series
 * @param {Array.<module:echarts/model/Series>} series
 * @return {string}
 * @inner
 */


function assembleOtherSeries(series) {
  return zrUtil.map(series, function (series) {
    var data = series.getRawData();
    var lines = [series.name];
    var vals = [];
    data.each(data.dimensions, function () {
      var argLen = arguments.length;
      var dataIndex = arguments[argLen - 1];
      var name = data.getName(dataIndex);

      for (var i = 0; i < argLen - 1; i++) {
        vals[i] = arguments[i];
      }

      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));
    });
    return lines.join('\n');
  }).join('\n\n' + BLOCK_SPLITER + '\n\n');
}
/**
 * @param {module:echarts/model/Global}
 * @return {Object}
 * @inner
 */


function getContentFromModel(ecModel) {
  var result = groupSeries(ecModel);
  return {
    value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {
      return str.replace(/[\n\t\s]/g, '');
    }).join('\n\n' + BLOCK_SPLITER + '\n\n'),
    meta: result.meta
  };
}

function trim(str) {
  return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}
/**
 * If a block is tsv format
 */


function isTSVFormat(block) {
  // Simple method to find out if a block is tsv format
  var firstLine = block.slice(0, block.indexOf('\n'));

  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
    return true;
  }
}

var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');
/**
 * @param {string} tsv
 * @return {Object}
 */

function parseTSVContents(tsv) {
  var tsvLines = tsv.split(/\n+/g);
  var headers = trim(tsvLines.shift()).split(itemSplitRegex);
  var categories = [];
  var series = zrUtil.map(headers, function (header) {
    return {
      name: header,
      data: []
    };
  });

  for (var i = 0; i < tsvLines.length; i++) {
    var items = trim(tsvLines[i]).split(itemSplitRegex);
    categories.push(items.shift());

    for (var j = 0; j < items.length; j++) {
      series[j] && (series[j].data[i] = items[j]);
    }
  }

  return {
    series: series,
    categories: categories
  };
}
/**
 * @param {string} str
 * @return {Array.<Object>}
 * @inner
 */


function parseListContents(str) {
  var lines = str.split(/\n+/g);
  var seriesName = trim(lines.shift());
  var data = [];

  for (var i = 0; i < lines.length; i++) {
    var items = trim(lines[i]).split(itemSplitRegex);
    var name = '';
    var value;
    var hasName = false;

    if (isNaN(items[0])) {
      // First item is name
      hasName = true;
      name = items[0];
      items = items.slice(1);
      data[i] = {
        name: name,
        value: []
      };
      value = data[i].value;
    } else {
      value = data[i] = [];
    }

    for (var j = 0; j < items.length; j++) {
      value.push(+items[j]);
    }

    if (value.length === 1) {
      hasName ? data[i].value = value[0] : data[i] = value[0];
    }
  }

  return {
    name: seriesName,
    data: data
  };
}
/**
 * @param {string} str
 * @param {Array.<Object>} blockMetaList
 * @return {Object}
 * @inner
 */


function parseContents(str, blockMetaList) {
  var blocks = str.split(new RegExp('\n*' + BLOCK_SPLITER + '\n*', 'g'));
  var newOption = {
    series: []
  };
  zrUtil.each(blocks, function (block, idx) {
    if (isTSVFormat(block)) {
      var result = parseTSVContents(block);
      var blockMeta = blockMetaList[idx];
      var axisKey = blockMeta.axisDim + 'Axis';

      if (blockMeta) {
        newOption[axisKey] = newOption[axisKey] || [];
        newOption[axisKey][blockMeta.axisIndex] = {
          data: result.categories
        };
        newOption.series = newOption.series.concat(result.series);
      }
    } else {
      var result = parseListContents(block);
      newOption.series.push(result);
    }
  });
  return newOption;
}
/**
 * @alias {module:echarts/component/toolbox/feature/DataView}
 * @constructor
 * @param {module:echarts/model/Model} model
 */


function DataView(model) {
  this._dom = null;
  this.model = model;
}

DataView.defaultOption = {
  show: true,
  readOnly: false,
  optionToContent: null,
  contentToOption: null,
  icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
  title: zrUtil.clone(dataViewLang.title),
  lang: zrUtil.clone(dataViewLang.lang),
  backgroundColor: '#fff',
  textColor: '#000',
  textareaColor: '#fff',
  textareaBorderColor: '#333',
  buttonColor: '#c23531',
  buttonTextColor: '#fff'
};

DataView.prototype.onclick = function (ecModel, api) {
  var container = api.getDom();
  var model = this.model;

  if (this._dom) {
    container.removeChild(this._dom);
  }

  var root = document.createElement('div');
  root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';
  root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements

  var header = document.createElement('h4');
  var lang = model.get('lang') || [];
  header.innerHTML = lang[0] || model.get('title');
  header.style.cssText = 'margin: 10px 20px;';
  header.style.color = model.get('textColor');
  var viewMain = document.createElement('div');
  var textarea = document.createElement('textarea');
  viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';
  var optionToContent = model.get('optionToContent');
  var contentToOption = model.get('contentToOption');
  var result = getContentFromModel(ecModel);

  if (typeof optionToContent === 'function') {
    var htmlOrDom = optionToContent(api.getOption());

    if (typeof htmlOrDom === 'string') {
      viewMain.innerHTML = htmlOrDom;
    } else if (zrUtil.isDom(htmlOrDom)) {
      viewMain.appendChild(htmlOrDom);
    }
  } else {
    // Use default textarea
    viewMain.appendChild(textarea);
    textarea.readOnly = model.get('readOnly');
    textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';
    textarea.style.color = model.get('textColor');
    textarea.style.borderColor = model.get('textareaBorderColor');
    textarea.style.backgroundColor = model.get('textareaColor');
    textarea.value = result.value;
  }

  var blockMetaList = result.meta;
  var buttonContainer = document.createElement('div');
  buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';
  var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';
  var closeButton = document.createElement('div');
  var refreshButton = document.createElement('div');
  buttonStyle += ';background-color:' + model.get('buttonColor');
  buttonStyle += ';color:' + model.get('buttonTextColor');
  var self = this;

  function close() {
    container.removeChild(root);
    self._dom = null;
  }

  eventTool.addEventListener(closeButton, 'click', close);
  eventTool.addEventListener(refreshButton, 'click', function () {
    var newOption;

    try {
      if (typeof contentToOption === 'function') {
        newOption = contentToOption(viewMain, api.getOption());
      } else {
        newOption = parseContents(textarea.value, blockMetaList);
      }
    } catch (e) {
      close();
      throw new Error('Data view format error ' + e);
    }

    if (newOption) {
      api.dispatchAction({
        type: 'changeDataView',
        newOption: newOption
      });
    }

    close();
  });
  closeButton.innerHTML = lang[1];
  refreshButton.innerHTML = lang[2];
  refreshButton.style.cssText = buttonStyle;
  closeButton.style.cssText = buttonStyle;
  !model.get('readOnly') && buttonContainer.appendChild(refreshButton);
  buttonContainer.appendChild(closeButton); // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea

  eventTool.addEventListener(textarea, 'keydown', function (e) {
    if ((e.keyCode || e.which) === 9) {
      // get caret position/selection
      var val = this.value;
      var start = this.selectionStart;
      var end = this.selectionEnd; // set textarea value to: text before caret + tab + text after caret

      this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end); // put caret at right position again

      this.selectionStart = this.selectionEnd = start + 1; // prevent the focus lose

      eventTool.stop(e);
    }
  });
  root.appendChild(header);
  root.appendChild(viewMain);
  root.appendChild(buttonContainer);
  viewMain.style.height = container.clientHeight - 80 + 'px';
  container.appendChild(root);
  this._dom = root;
};

DataView.prototype.remove = function (ecModel, api) {
  this._dom && api.getDom().removeChild(this._dom);
};

DataView.prototype.dispose = function (ecModel, api) {
  this.remove(ecModel, api);
};
/**
 * @inner
 */


function tryMergeDataOption(newData, originalData) {
  return zrUtil.map(newData, function (newVal, idx) {
    var original = originalData && originalData[idx];

    if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {
      if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {
        newVal = newVal.value;
      } // Original data has option


      return zrUtil.defaults({
        value: newVal
      }, original);
    } else {
      return newVal;
    }
  });
}

featureManager.register('dataView', DataView);
echarts.registerAction({
  type: 'changeDataView',
  event: 'dataViewChanged',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  var newSeriesOptList = [];
  zrUtil.each(payload.newOption.series, function (seriesOpt) {
    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];

    if (!seriesModel) {
      // New created series
      // Geuss the series type
      newSeriesOptList.push(zrUtil.extend({
        // Default is scatter
        type: 'scatter'
      }, seriesOpt));
    } else {
      var originalData = seriesModel.get('data');
      newSeriesOptList.push({
        name: seriesOpt.name,
        data: tryMergeDataOption(seriesOpt.data, originalData)
      });
    }
  });
  ecModel.mergeOption(zrUtil.defaults({
    series: newSeriesOptList
  }, payload.newOption));
});
var _default = DataView;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var BrushController = __webpack_require__("./node_modules/echarts/lib/component/helper/BrushController.js");

var BrushTargetManager = __webpack_require__("./node_modules/echarts/lib/component/helper/BrushTargetManager.js");

var history = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/history.js");

var sliderMove = __webpack_require__("./node_modules/echarts/lib/component/helper/sliderMove.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

__webpack_require__("./node_modules/echarts/lib/component/dataZoomSelect.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Use dataZoomSelect
var dataZoomLang = lang.toolbox.dataZoom;
var each = zrUtil.each; // Spectial component id start with \0ec\0, see echarts/model/Global.js~hasInnerId

var DATA_ZOOM_ID_BASE = '\0_ec_\0toolbox-dataZoom_';

function DataZoom(model, ecModel, api) {
  /**
   * @private
   * @type {module:echarts/component/helper/BrushController}
   */
  (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();
  /**
   * @private
   * @type {boolean}
   */

  this._isZoomActive;
}

DataZoom.defaultOption = {
  show: true,
  // Icon group
  icon: {
    zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
    back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'
  },
  // `zoom`, `back`
  title: zrUtil.clone(dataZoomLang.title)
};
var proto = DataZoom.prototype;

proto.render = function (featureModel, ecModel, api, payload) {
  this.model = featureModel;
  this.ecModel = ecModel;
  this.api = api;
  updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
  updateBackBtnStatus(featureModel, ecModel);
};

proto.onclick = function (ecModel, api, type) {
  handlers[type].call(this);
};

proto.remove = function (ecModel, api) {
  this._brushController.unmount();
};

proto.dispose = function (ecModel, api) {
  this._brushController.dispose();
};
/**
 * @private
 */


var handlers = {
  zoom: function () {
    var nextActive = !this._isZoomActive;
    this.api.dispatchAction({
      type: 'takeGlobalCursor',
      key: 'dataZoomSelect',
      dataZoomSelectActive: nextActive
    });
  },
  back: function () {
    this._dispatchZoomAction(history.pop(this.ecModel));
  }
};
/**
 * @private
 */

proto._onBrush = function (areas, opt) {
  if (!opt.isEnd || !areas.length) {
    return;
  }

  var snapshot = {};
  var ecModel = this.ecModel;

  this._brushController.updateCovers([]); // remove cover


  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {
    include: ['grid']
  });
  brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
    if (coordSys.type !== 'cartesian2d') {
      return;
    }

    var brushType = area.brushType;

    if (brushType === 'rect') {
      setBatch('x', coordSys, coordRange[0]);
      setBatch('y', coordSys, coordRange[1]);
    } else {
      setBatch({
        lineX: 'x',
        lineY: 'y'
      }[brushType], coordSys, coordRange);
    }
  });
  history.push(ecModel, snapshot);

  this._dispatchZoomAction(snapshot);

  function setBatch(dimName, coordSys, minMax) {
    var axis = coordSys.getAxis(dimName);
    var axisModel = axis.model;
    var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.

    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();

    if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
      minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
    }

    dataZoomModel && (snapshot[dataZoomModel.id] = {
      dataZoomId: dataZoomModel.id,
      startValue: minMax[0],
      endValue: minMax[1]
    });
  }

  function findDataZoom(dimName, axisModel, ecModel) {
    var found;
    ecModel.eachComponent({
      mainType: 'dataZoom',
      subType: 'select'
    }, function (dzModel) {
      var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);
      has && (found = dzModel);
    });
    return found;
  }
};
/**
 * @private
 */


proto._dispatchZoomAction = function (snapshot) {
  var batch = []; // Convert from hash map to array.

  each(snapshot, function (batchItem, dataZoomId) {
    batch.push(zrUtil.clone(batchItem));
  });
  batch.length && this.api.dispatchAction({
    type: 'dataZoom',
    from: this.uid,
    batch: batch
  });
};

function retrieveAxisSetting(option) {
  var setting = {}; // Compatible with previous setting: null => all axis, false => no axis.

  zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {
    setting[name] = option[name];
    setting[name] == null && (setting[name] = 'all');
    (setting[name] === false || setting[name] === 'none') && (setting[name] = []);
  });
  return setting;
}

function updateBackBtnStatus(featureModel, ecModel) {
  featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');
}

function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
  var zoomActive = view._isZoomActive;

  if (payload && payload.type === 'takeGlobalCursor') {
    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;
  }

  view._isZoomActive = zoomActive;
  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');
  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {
    include: ['grid']
  });

  view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {
    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';
  })).enableBrush(zoomActive ? {
    brushType: 'auto',
    brushStyle: {
      // FIXME user customized?
      lineWidth: 0,
      fill: 'rgba(0,0,0,0.2)'
    }
  } : false);
}

featureManager.register('dataZoom', DataZoom); // Create special dataZoom option for select
// FIXME consider the case of merge option, where axes options are not exists.

echarts.registerPreprocessor(function (option) {
  if (!option) {
    return;
  }

  var dataZoomOpts = option.dataZoom || (option.dataZoom = []);

  if (!zrUtil.isArray(dataZoomOpts)) {
    option.dataZoom = dataZoomOpts = [dataZoomOpts];
  }

  var toolboxOpt = option.toolbox;

  if (toolboxOpt) {
    // Assume there is only one toolbox
    if (zrUtil.isArray(toolboxOpt)) {
      toolboxOpt = toolboxOpt[0];
    }

    if (toolboxOpt && toolboxOpt.feature) {
      var dataZoomOpt = toolboxOpt.feature.dataZoom; // FIXME: If add dataZoom when setOption in merge mode,
      // no axis info to be added. See `test/dataZoom-extreme.html`

      addForAxis('xAxis', dataZoomOpt);
      addForAxis('yAxis', dataZoomOpt);
    }
  }

  function addForAxis(axisName, dataZoomOpt) {
    if (!dataZoomOpt) {
      return;
    } // Try not to modify model, because it is not merged yet.


    var axisIndicesName = axisName + 'Index';
    var givenAxisIndices = dataZoomOpt[axisIndicesName];

    if (givenAxisIndices != null && givenAxisIndices != 'all' && !zrUtil.isArray(givenAxisIndices)) {
      givenAxisIndices = givenAxisIndices === false || givenAxisIndices === 'none' ? [] : [givenAxisIndices];
    }

    forEachComponent(axisName, function (axisOpt, axisIndex) {
      if (givenAxisIndices != null && givenAxisIndices != 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {
        return;
      }

      var newOpt = {
        type: 'select',
        $fromToolbox: true,
        // Id for merge mapping.
        id: DATA_ZOOM_ID_BASE + axisName + axisIndex
      }; // FIXME
      // Only support one axis now.

      newOpt[axisIndicesName] = axisIndex;
      dataZoomOpts.push(newOpt);
    });
  }

  function forEachComponent(mainType, cb) {
    var opts = option[mainType];

    if (!zrUtil.isArray(opts)) {
      opts = opts ? [opts] : [];
    }

    each(opts, cb);
  }
});
var _default = DataZoom;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/MagicType.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var magicTypeLang = lang.toolbox.magicType;

function MagicType(model) {
  this.model = model;
}

MagicType.defaultOption = {
  show: true,
  type: [],
  // Icon group
  icon: {
    line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
    bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
    stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',
    // jshint ignore:line
    tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'
  },
  // `line`, `bar`, `stack`, `tiled`
  title: zrUtil.clone(magicTypeLang.title),
  option: {},
  seriesIndex: {}
};
var proto = MagicType.prototype;

proto.getIcons = function () {
  var model = this.model;
  var availableIcons = model.get('icon');
  var icons = {};
  zrUtil.each(model.get('type'), function (type) {
    if (availableIcons[type]) {
      icons[type] = availableIcons[type];
    }
  });
  return icons;
};

var seriesOptGenreator = {
  'line': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'bar') {
      return zrUtil.merge({
        id: seriesId,
        type: 'line',
        // Preserve data related option
        data: seriesModel.get('data'),
        stack: seriesModel.get('stack'),
        markPoint: seriesModel.get('markPoint'),
        markLine: seriesModel.get('markLine')
      }, model.get('option.line') || {}, true);
    }
  },
  'bar': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'line') {
      return zrUtil.merge({
        id: seriesId,
        type: 'bar',
        // Preserve data related option
        data: seriesModel.get('data'),
        stack: seriesModel.get('stack'),
        markPoint: seriesModel.get('markPoint'),
        markLine: seriesModel.get('markLine')
      }, model.get('option.bar') || {}, true);
    }
  },
  'stack': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'line' || seriesType === 'bar') {
      return zrUtil.merge({
        id: seriesId,
        stack: '__ec_magicType_stack__'
      }, model.get('option.stack') || {}, true);
    }
  },
  'tiled': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'line' || seriesType === 'bar') {
      return zrUtil.merge({
        id: seriesId,
        stack: ''
      }, model.get('option.tiled') || {}, true);
    }
  }
};
var radioTypes = [['line', 'bar'], ['stack', 'tiled']];

proto.onclick = function (ecModel, api, type) {
  var model = this.model;
  var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType

  if (!seriesOptGenreator[type]) {
    return;
  }

  var newOption = {
    series: []
  };

  var generateNewSeriesTypes = function (seriesModel) {
    var seriesType = seriesModel.subType;
    var seriesId = seriesModel.id;
    var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);

    if (newSeriesOpt) {
      // PENDING If merge original option?
      zrUtil.defaults(newSeriesOpt, seriesModel.option);
      newOption.series.push(newSeriesOpt);
    } // Modify boundaryGap


    var coordSys = seriesModel.coordinateSystem;

    if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {
      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

      if (categoryAxis) {
        var axisDim = categoryAxis.dim;
        var axisType = axisDim + 'Axis';
        var axisModel = ecModel.queryComponents({
          mainType: axisType,
          index: seriesModel.get(name + 'Index'),
          id: seriesModel.get(name + 'Id')
        })[0];
        var axisIndex = axisModel.componentIndex;
        newOption[axisType] = newOption[axisType] || [];

        for (var i = 0; i <= axisIndex; i++) {
          newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
        }

        newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;
      }
    }
  };

  zrUtil.each(radioTypes, function (radio) {
    if (zrUtil.indexOf(radio, type) >= 0) {
      zrUtil.each(radio, function (item) {
        model.setIconStatus(item, 'normal');
      });
    }
  });
  model.setIconStatus(type, 'emphasis');
  ecModel.eachComponent({
    mainType: 'series',
    query: seriesIndex == null ? null : {
      seriesIndex: seriesIndex
    }
  }, generateNewSeriesTypes);
  api.dispatchAction({
    type: 'changeMagicType',
    currentType: type,
    newOption: newOption
  });
};

echarts.registerAction({
  type: 'changeMagicType',
  event: 'magicTypeChanged',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  ecModel.mergeOption(payload.newOption);
});
featureManager.register('magicType', MagicType);
var _default = MagicType;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/Restore.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var history = __webpack_require__("./node_modules/echarts/lib/component/dataZoom/history.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var restoreLang = lang.toolbox.restore;

function Restore(model) {
  this.model = model;
}

Restore.defaultOption = {
  show: true,
  icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
  title: restoreLang.title
};
var proto = Restore.prototype;

proto.onclick = function (ecModel, api, type) {
  history.clear(ecModel);
  api.dispatchAction({
    type: 'restore',
    from: this.uid
  });
};

featureManager.register('restore', Restore);
echarts.registerAction({
  type: 'restore',
  event: 'restore',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  ecModel.resetOption('recreate');
});
var _default = Restore;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js":
/***/ (function(module, exports, __webpack_require__) {

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var featureManager = __webpack_require__("./node_modules/echarts/lib/component/toolbox/featureManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var saveAsImageLang = lang.toolbox.saveAsImage;

function SaveAsImage(model) {
  this.model = model;
}

SaveAsImage.defaultOption = {
  show: true,
  icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
  title: saveAsImageLang.title,
  type: 'png',
  // Default use option.backgroundColor
  // backgroundColor: '#fff',
  name: '',
  excludeComponents: ['toolbox'],
  pixelRatio: 1,
  lang: saveAsImageLang.lang.slice()
};
SaveAsImage.prototype.unusable = !env.canvasSupported;
var proto = SaveAsImage.prototype;

proto.onclick = function (ecModel, api) {
  var model = this.model;
  var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';
  var $a = document.createElement('a');
  var type = model.get('type', true) || 'png';
  $a.download = title + '.' + type;
  $a.target = '_blank';
  var url = api.getConnectedDataURL({
    type: type,
    backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',
    excludeComponents: model.get('excludeComponents'),
    pixelRatio: model.get('pixelRatio')
  });
  $a.href = url; // Chrome and Firefox

  if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {
    var evt = new MouseEvent('click', {
      view: window,
      bubbles: true,
      cancelable: false
    });
    $a.dispatchEvent(evt);
  } // IE
  else {
      if (window.navigator.msSaveOrOpenBlob) {
        var bstr = atob(url.split(',')[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);

        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }

        var blob = new Blob([u8arr]);
        window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);
      } else {
        var lang = model.get('lang');
        var html = '' + '<body style="margin:0;">' + '<img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || '') + '" />' + '</body>';
        var tab = window.open();
        tab.document.write(html);
      }
    }
};

featureManager.register('saveAsImage', SaveAsImage);
var _default = SaveAsImage;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/featureManager.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var features = {};

function register(name, ctor) {
  features[name] = ctor;
}

function get(name) {
  return features[name];
}

exports.register = register;
exports.get = get;

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

__webpack_require__("./node_modules/echarts/lib/component/axisPointer.js");

__webpack_require__("./node_modules/echarts/lib/component/tooltip/TooltipModel.js");

__webpack_require__("./node_modules/echarts/lib/component/tooltip/TooltipView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// FIXME Better way to pack data in graphic element

/**
 * @action
 * @property {string} type
 * @property {number} seriesIndex
 * @property {number} dataIndex
 * @property {number} [x]
 * @property {number} [y]
 */
echarts.registerAction({
  type: 'showTip',
  event: 'showTip',
  update: 'tooltip:manuallyShowTip'
}, // noop
function () {});
echarts.registerAction({
  type: 'hideTip',
  event: 'hideTip',
  update: 'tooltip:manuallyHideTip'
}, // noop
function () {});

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/TooltipContent.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var zrColor = __webpack_require__("./node_modules/zrender/lib/tool/color.js");

var eventUtil = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var each = zrUtil.each;
var toCamelCase = formatUtil.toCamelCase;
var vendors = ['', '-webkit-', '-moz-', '-o-'];
var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';
/**
 * @param {number} duration
 * @return {string}
 * @inner
 */

function assembleTransition(duration) {
  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
  var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;
  return zrUtil.map(vendors, function (vendorPrefix) {
    return vendorPrefix + 'transition:' + transitionText;
  }).join(';');
}
/**
 * @param {Object} textStyle
 * @return {string}
 * @inner
 */


function assembleFont(textStyleModel) {
  var cssText = [];
  var fontSize = textStyleModel.get('fontSize');
  var color = textStyleModel.getTextColor();
  color && cssText.push('color:' + color);
  cssText.push('font:' + textStyleModel.getFont());
  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
  each(['decoration', 'align'], function (name) {
    var val = textStyleModel.get(name);
    val && cssText.push('text-' + name + ':' + val);
  });
  return cssText.join(';');
}
/**
 * @param {Object} tooltipModel
 * @return {string}
 * @inner
 */


function assembleCssText(tooltipModel) {
  var cssText = [];
  var transitionDuration = tooltipModel.get('transitionDuration');
  var backgroundColor = tooltipModel.get('backgroundColor');
  var textStyleModel = tooltipModel.getModel('textStyle');
  var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.

  transitionDuration && cssText.push(assembleTransition(transitionDuration));

  if (backgroundColor) {
    if (env.canvasSupported) {
      cssText.push('background-Color:' + backgroundColor);
    } else {
      // for ie
      cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));
      cssText.push('filter:alpha(opacity=70)');
    }
  } // Border style


  each(['width', 'color', 'radius'], function (name) {
    var borderName = 'border-' + name;
    var camelCase = toCamelCase(borderName);
    var val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
  }); // Text style

  cssText.push(assembleFont(textStyleModel)); // Padding

  if (padding != null) {
    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');
  }

  return cssText.join(';') + ';';
}
/**
 * @alias module:echarts/component/tooltip/TooltipContent
 * @constructor
 */


function TooltipContent(container, api) {
  if (env.wxa) {
    return null;
  }

  var el = document.createElement('div');
  var zr = this._zr = api.getZr();
  this.el = el;
  this._x = api.getWidth() / 2;
  this._y = api.getHeight() / 2;
  container.appendChild(el);
  this._container = container;
  this._show = false;
  /**
   * @private
   */

  this._hideTimeout;
  var self = this;

  el.onmouseenter = function () {
    // clear the timeout in hideLater and keep showing tooltip
    if (self._enterable) {
      clearTimeout(self._hideTimeout);
      self._show = true;
    }

    self._inContent = true;
  };

  el.onmousemove = function (e) {
    e = e || window.event;

    if (!self._enterable) {
      // Try trigger zrender event to avoid mouse
      // in and out shape too frequently
      var handler = zr.handler;
      eventUtil.normalizeEvent(container, e, true);
      handler.dispatch('mousemove', e);
    }
  };

  el.onmouseleave = function () {
    if (self._enterable) {
      if (self._show) {
        self.hideLater(self._hideDelay);
      }
    }

    self._inContent = false;
  };
}

TooltipContent.prototype = {
  constructor: TooltipContent,

  /**
   * @private
   * @type {boolean}
   */
  _enterable: true,

  /**
   * Update when tooltip is rendered
   */
  update: function () {
    // FIXME
    // Move this logic to ec main?
    var container = this._container;
    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
    var domStyle = container.style;

    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
      domStyle.position = 'relative';
    } // Hide the tooltip
    // PENDING
    // this.hide();

  },
  show: function (tooltipModel) {
    clearTimeout(this._hideTimeout);
    var el = this.el;
    el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
    + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');
    el.style.display = el.innerHTML ? 'block' : 'none';
    this._show = true;
  },
  setContent: function (content) {
    this.el.innerHTML = content == null ? '' : content;
  },
  setEnterable: function (enterable) {
    this._enterable = enterable;
  },
  getSize: function () {
    var el = this.el;
    return [el.clientWidth, el.clientHeight];
  },
  moveTo: function (x, y) {
    // xy should be based on canvas root. But tooltipContent is
    // the sibling of canvas root. So padding of ec container
    // should be considered here.
    var zr = this._zr;
    var viewportRootOffset;

    if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {
      x += viewportRootOffset.offsetLeft;
      y += viewportRootOffset.offsetTop;
    }

    var style = this.el.style;
    style.left = x + 'px';
    style.top = y + 'px';
    this._x = x;
    this._y = y;
  },
  hide: function () {
    this.el.style.display = 'none';
    this._show = false;
  },
  hideLater: function (time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times

        this._show = false;
        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  },
  isShow: function () {
    return this._show;
  }
};
var _default = TooltipContent;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/TooltipModel.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = echarts.extendComponentModel({
  type: 'tooltip',
  dependencies: ['axisPointer'],
  defaultOption: {
    zlevel: 0,
    z: 8,
    show: true,
    // tooltip主体内容
    showContent: true,
    // 'trigger' only works on coordinate system.
    // 'item' | 'axis' | 'none'
    trigger: 'item',
    // 'click' | 'mousemove' | 'none'
    triggerOn: 'mousemove|click',
    alwaysShowContent: false,
    displayMode: 'single',
    // 'single' | 'multipleByCoordSys'
    // 位置 {Array} | {Function}
    // position: null
    // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
    // align: null,
    // verticalAlign: null,
    // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。
    confine: false,
    // 内容格式器：{string}（Template） ¦ {Function}
    // formatter: null
    showDelay: 0,
    // 隐藏延迟，单位ms
    hideDelay: 100,
    // 动画变换时间，单位s
    transitionDuration: 0.4,
    enterable: false,
    // 提示背景颜色，默认为透明度为0.7的黑色
    backgroundColor: 'rgba(50,50,50,0.7)',
    // 提示边框颜色
    borderColor: '#333',
    // 提示边框圆角，单位px，默认为4
    borderRadius: 4,
    // 提示边框线宽，单位px，默认为0（无边框）
    borderWidth: 0,
    // 提示内边距，单位px，默认各方向内边距为5，
    // 接受数组分别设定上右下左边距，同css
    padding: 5,
    // Extra css text
    extraCssText: '',
    // 坐标轴指示器，坐标轴触发有效
    axisPointer: {
      // 默认为直线
      // 可选为：'line' | 'shadow' | 'cross'
      type: 'line',
      // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选
      // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'
      // 默认 'auto'，会选择类型为 category 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴
      // 极坐标系会默认选择 angle 轴
      axis: 'auto',
      animation: 'auto',
      animationDurationUpdate: 200,
      animationEasingUpdate: 'exponentialOut',
      crossStyle: {
        color: '#999',
        width: 1,
        type: 'dashed',
        // TODO formatter
        textStyle: {} // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.

      }
    },
    textStyle: {
      color: '#fff',
      fontSize: 14
    }
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/TooltipView.js":
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__("./node_modules/echarts/lib/echarts.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var TooltipContent = __webpack_require__("./node_modules/echarts/lib/component/tooltip/TooltipContent.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var findPointFromSeries = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js");

var layoutUtil = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var globalListener = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/globalListener.js");

var axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

var axisPointerViewHelper = __webpack_require__("./node_modules/echarts/lib/component/axisPointer/viewHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var bind = zrUtil.bind;
var each = zrUtil.each;
var parsePercent = numberUtil.parsePercent;
var proxyRect = new graphic.Rect({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
});

var _default = echarts.extendComponentView({
  type: 'tooltip',
  init: function (ecModel, api) {
    if (env.node) {
      return;
    }

    var tooltipContent = new TooltipContent(api.getDom(), api);
    this._tooltipContent = tooltipContent;
  },
  render: function (tooltipModel, ecModel, api) {
    if (env.node || env.wxa) {
      return;
    } // Reset


    this.group.removeAll();
    /**
     * @private
     * @type {module:echarts/component/tooltip/TooltipModel}
     */

    this._tooltipModel = tooltipModel;
    /**
     * @private
     * @type {module:echarts/model/Global}
     */

    this._ecModel = ecModel;
    /**
     * @private
     * @type {module:echarts/ExtensionAPI}
     */

    this._api = api;
    /**
     * Should be cleaned when render.
     * @private
     * @type {Array.<Array.<Object>>}
     */

    this._lastDataByCoordSys = null;
    /**
     * @private
     * @type {boolean}
     */

    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
    var tooltipContent = this._tooltipContent;
    tooltipContent.update();
    tooltipContent.setEnterable(tooltipModel.get('enterable'));

    this._initGlobalListener();

    this._keepShow();
  },
  _initGlobalListener: function () {
    var tooltipModel = this._tooltipModel;
    var triggerOn = tooltipModel.get('triggerOn');
    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {
      // If 'none', it is not controlled by mouse totally.
      if (triggerOn !== 'none') {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e, dispatchAction);
        } else if (currTrigger === 'leave') {
          this._hide(dispatchAction);
        }
      }
    }, this));
  },
  _keepShow: function () {
    var tooltipModel = this._tooltipModel;
    var ecModel = this._ecModel;
    var api = this._api; // Try to keep the tooltip show when refreshing

    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,
    // self.manuallyShowTip({x, y}) might cause tooltip hide,
    // which is not expected.
    && tooltipModel.get('triggerOn') !== 'none') {
      var self = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function () {
        // Show tip next tick after other charts are rendered
        // In case highlight action has wrong result
        // FIXME
        self.manuallyShowTip(tooltipModel, ecModel, api, {
          x: self._lastX,
          y: self._lastY
        });
      });
    }
  },

  /**
   * Show tip manually by
   * dispatchAction({
   *     type: 'showTip',
   *     x: 10,
   *     y: 10
   * });
   * Or
   * dispatchAction({
   *      type: 'showTip',
   *      seriesIndex: 0,
   *      dataIndex or dataIndexInside or name
   * });
   *
   *  TODO Batch
   */
  manuallyShowTip: function (tooltipModel, ecModel, api, payload) {
    if (payload.from === this.uid || env.node) {
      return;
    }

    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket

    this._ticket = ''; // When triggered from axisPointer.

    var dataByCoordSys = payload.dataByCoordSys;

    if (payload.tooltip && payload.x != null && payload.y != null) {
      var el = proxyRect;
      el.position = [payload.x, payload.y];
      el.update();
      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.

      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        event: {},
        dataByCoordSys: payload.dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
        return;
      }

      var pointInfo = findPointFromSeries(payload, ecModel);
      var cx = pointInfo.point[0];
      var cy = pointInfo.point[1];

      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          position: payload.position,
          target: pointInfo.el,
          event: {}
        }, dispatchAction);
      }
    } else if (payload.x != null && payload.y != null) {
      // FIXME
      // should wrap dispatchAction like `axisPointer/globalListener` ?
      api.dispatchAction({
        type: 'updateAxisPointer',
        x: payload.x,
        y: payload.y
      });

      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api.getZr().findHover(payload.x, payload.y).target,
        event: {}
      }, dispatchAction);
    }
  },
  manuallyHideTip: function (tooltipModel, ecModel, api, payload) {
    var tooltipContent = this._tooltipContent;

    if (!this._alwaysShowContent && this._tooltipModel) {
      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
    }

    this._lastX = this._lastY = null;

    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction(payload, api));
    }
  },
  // Be compatible with previous design, that is, when tooltip.type is 'axis' and
  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
  // and tooltip.
  _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {
    var seriesIndex = payload.seriesIndex;
    var dataIndex = payload.dataIndex;
    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;

    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }

    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);

    if (!seriesModel) {
      return;
    }

    var data = seriesModel.getData();
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);

    if (tooltipModel.get('trigger') !== 'axis') {
      return;
    }

    api.dispatchAction({
      type: 'updateAxisPointer',
      seriesIndex: seriesIndex,
      dataIndex: dataIndex,
      position: payload.position
    });
    return true;
  },
  _tryShow: function (e, dispatchAction) {
    var el = e.target;
    var tooltipModel = this._tooltipModel;

    if (!tooltipModel) {
      return;
    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed


    this._lastX = e.offsetX;
    this._lastY = e.offsetY;
    var dataByCoordSys = e.dataByCoordSys;

    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e);
    } // Always show item tooltip if mouse is on the element with dataIndex
    else if (el && el.dataIndex != null) {
        this._lastDataByCoordSys = null;

        this._showSeriesItemTooltip(e, el, dispatchAction);
      } // Tooltip provided directly. Like legend.
      else if (el && el.tooltip) {
          this._lastDataByCoordSys = null;

          this._showComponentItemTooltip(e, el, dispatchAction);
        } else {
          this._lastDataByCoordSys = null;

          this._hide(dispatchAction);
        }
  },
  _showOrMove: function (tooltipModel, cb) {
    // showDelay is used in this case: tooltip.enterable is set
    // as true. User intent to move mouse into tooltip and click
    // something. `showDelay` makes it easyer to enter the content
    // but tooltip do not move immediately.
    var delay = tooltipModel.get('showDelay');
    cb = zrUtil.bind(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  },
  _showAxisTooltip: function (dataByCoordSys, e) {
    var ecModel = this._ecModel;
    var globalTooltipModel = this._tooltipModel;
    var point = [e.offsetX, e.offsetY];
    var singleDefaultHTML = [];
    var singleParamsList = [];
    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);
    each(dataByCoordSys, function (itemCoordSys) {
      // var coordParamList = [];
      // var coordDefaultHTML = [];
      // var coordTooltipModel = buildTooltipModel([
      //     e.tooltipOption,
      //     itemCoordSys.tooltipOption,
      //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),
      //     globalTooltipModel
      // ]);
      // var displayMode = coordTooltipModel.get('displayMode');
      // var paramsList = displayMode === 'single' ? singleParamsList : [];
      each(itemCoordSys.dataByAxis, function (item) {
        var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);
        var axisValue = item.value;
        var seriesDefaultHTML = [];

        if (!axisModel || axisValue == null) {
          return;
        }

        var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);
        zrUtil.each(item.seriesDataIndices, function (idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var dataParams = series && series.getDataParams(dataIndex);
          dataParams.axisDim = item.axisDim;
          dataParams.axisIndex = item.axisIndex;
          dataParams.axisType = item.axisType;
          dataParams.axisId = item.axisId;
          dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);
          dataParams.axisValueLabel = valueLabel;

          if (dataParams) {
            singleParamsList.push(dataParams);
            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));
          }
        }); // Default tooltip content
        // FIXME
        // (1) shold be the first data which has name?
        // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.

        var firstLine = valueLabel;
        singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));
      });
    }, this); // In most case, the second axis is shown upper than the first one.

    singleDefaultHTML.reverse();
    singleDefaultHTML = singleDefaultHTML.join('<br /><br />');
    var positionExpr = e.position;

    this._showOrMove(singleTooltipModel, function () {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);
      }
    }); // Do not trigger events here, because this branch only be entered
    // from dispatchAction.

  },
  _showSeriesItemTooltip: function (e, el, dispatchAction) {
    var ecModel = this._ecModel; // Use dataModel in element if possible
    // Used when mouseover on a element like markPoint or edge
    // In which case, the data is not main data in series.

    var seriesIndex = el.seriesIndex;
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.

    var dataModel = el.dataModel || seriesModel;
    var dataIndex = el.dataIndex;
    var dataType = el.dataType;
    var data = dataModel.getData();
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
    var tooltipTrigger = tooltipModel.get('trigger');

    if (tooltipTrigger != null && tooltipTrigger !== 'item') {
      return;
    }

    var params = dataModel.getDataParams(dataIndex, dataType);
    var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);
    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;

    this._showOrMove(tooltipModel, function () {
      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);
    }); // FIXME
    // duplicated showtip if manuallyShowTip is called from dispatchAction.


    dispatchAction({
      type: 'showTip',
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex: seriesIndex,
      from: this.uid
    });
  },
  _showComponentItemTooltip: function (e, el, dispatchAction) {
    var tooltipOpt = el.tooltip;

    if (typeof tooltipOpt === 'string') {
      var content = tooltipOpt;
      tooltipOpt = {
        content: content,
        // Fixed formatter
        formatter: content
      };
    }

    var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);
    var defaultHtml = subTooltipModel.get('content');
    var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`
    // only works on cooridinate system. In fact, we have not found case
    // that requires setting `trigger` nothing on component yet.

    this._showOrMove(subTooltipModel, function () {
      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);
    }); // If not dispatch showTip, tip may be hide triggered by axis.


    dispatchAction({
      type: 'showTip',
      from: this.uid
    });
  },
  _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {
    // Reset ticket
    this._ticket = '';

    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
      return;
    }

    var tooltipContent = this._tooltipContent;
    var formatter = tooltipModel.get('formatter');
    positionExpr = positionExpr || tooltipModel.get('position');
    var html = defaultHtml;

    if (formatter && typeof formatter === 'string') {
      html = formatUtil.formatTpl(formatter, params, true);
    } else if (typeof formatter === 'function') {
      var callback = bind(function (cbTicket, html) {
        if (cbTicket === this._ticket) {
          tooltipContent.setContent(html);

          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
        }
      }, this);
      this._ticket = asyncTicket;
      html = formatter(params, asyncTicket, callback);
    }

    tooltipContent.setContent(html);
    tooltipContent.show(tooltipModel);

    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
  },

  /**
   * @param  {string|Function|Array.<number>|Object} positionExpr
   * @param  {number} x Mouse x
   * @param  {number} y Mouse y
   * @param  {boolean} confine Whether confine tooltip content in view rect.
   * @param  {Object|<Array.<Object>} params
   * @param  {module:zrender/Element} el target element
   * @param  {module:echarts/ExtensionAPI} api
   * @return {Array.<number>}
   */
  _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {
    var viewWidth = this._api.getWidth();

    var viewHeight = this._api.getHeight();

    positionExpr = positionExpr || tooltipModel.get('position');
    var contentSize = content.getSize();
    var align = tooltipModel.get('align');
    var vAlign = tooltipModel.get('verticalAlign');
    var rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);

    if (typeof positionExpr === 'function') {
      // Callback of position can be an array or a string specify the position
      positionExpr = positionExpr([x, y], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }

    if (zrUtil.isArray(positionExpr)) {
      x = parsePercent(positionExpr[0], viewWidth);
      y = parsePercent(positionExpr[1], viewHeight);
    } else if (zrUtil.isObject(positionExpr)) {
      positionExpr.width = contentSize[0];
      positionExpr.height = contentSize[1];
      var layoutRect = layoutUtil.getLayoutRect(positionExpr, {
        width: viewWidth,
        height: viewHeight
      });
      x = layoutRect.x;
      y = layoutRect.y;
      align = null; // When positionExpr is left/top/right/bottom,
      // align and verticalAlign will not work.

      vAlign = null;
    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
    else if (typeof positionExpr === 'string' && el) {
        var pos = calcTooltipPosition(positionExpr, rect, contentSize);
        x = pos[0];
        y = pos[1];
      } else {
        var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
        x = pos[0];
        y = pos[1];
      }

    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);

    if (tooltipModel.get('confine')) {
      var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);
      x = pos[0];
      y = pos[1];
    }

    content.moveTo(x, y);
  },
  // FIXME
  // Should we remove this but leave this to user?
  _updateContentNotChangedOnAxis: function (dataByCoordSys) {
    var lastCoordSys = this._lastDataByCoordSys;
    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
      var lastDataByAxis = lastItemCoordSys.dataByAxis || {};
      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {
        var thisItem = thisDataByAxis[indexAxis] || {};
        var lastIndices = lastItem.seriesDataIndices || [];
        var newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {
          var newIdxItem = newIndices[j];
          contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    return !!contentNotChanged;
  },
  _hide: function (dispatchAction) {
    // Do not directly hideLater here, because this behavior may be prevented
    // in dispatchAction when showTip is dispatched.
    // FIXME
    // duplicated hideTip if manuallyHideTip is called from dispatchAction.
    this._lastDataByCoordSys = null;
    dispatchAction({
      type: 'hideTip',
      from: this.uid
    });
  },
  dispose: function (ecModel, api) {
    if (env.node || env.wxa) {
      return;
    }

    this._tooltipContent.hide();

    globalListener.unregister('itemTooltip', api);
  }
});
/**
 * @param {Array.<Object|module:echarts/model/Model>} modelCascade
 * From top to bottom. (the last one should be globalTooltipModel);
 */


function buildTooltipModel(modelCascade) {
  var resultModel = modelCascade.pop();

  while (modelCascade.length) {
    var tooltipOpt = modelCascade.pop();

    if (tooltipOpt) {
      if (Model.isInstance(tooltipOpt)) {
        tooltipOpt = tooltipOpt.get('tooltip', true);
      } // In each data item tooltip can be simply write:
      // {
      //  value: 10,
      //  tooltip: 'Something you need to know'
      // }


      if (typeof tooltipOpt === 'string') {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }

      resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);
    }
  }

  return resultModel;
}

function makeDispatchAction(payload, api) {
  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
}

function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {
  var size = getOuterSize(el);
  var width = size.width;
  var height = size.height;

  if (gapH != null) {
    if (x + width + gapH > viewWidth) {
      x -= width + gapH;
    } else {
      x += gapH;
    }
  }

  if (gapV != null) {
    if (y + height + gapV > viewHeight) {
      y -= height + gapV;
    } else {
      y += gapV;
    }
  }

  return [x, y];
}

function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {
  var size = getOuterSize(el);
  var width = size.width;
  var height = size.height;
  x = Math.min(x + width, viewWidth) - width;
  y = Math.min(y + height, viewHeight) - height;
  x = Math.max(x, 0);
  y = Math.max(y, 0);
  return [x, y];
}

function getOuterSize(el) {
  var width = el.clientWidth;
  var height = el.clientHeight; // Consider browser compatibility.
  // IE8 does not support getComputedStyle.

  if (document.defaultView && document.defaultView.getComputedStyle) {
    var stl = document.defaultView.getComputedStyle(el);

    if (stl) {
      width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
      height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
    }
  }

  return {
    width: width,
    height: height
  };
}

function calcTooltipPosition(position, rect, contentSize) {
  var domWidth = contentSize[0];
  var domHeight = contentSize[1];
  var gap = 5;
  var x = 0;
  var y = 0;
  var rectWidth = rect.width;
  var rectHeight = rect.height;

  switch (position) {
    case 'inside':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;

    case 'top':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y - domHeight - gap;
      break;

    case 'bottom':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight + gap;
      break;

    case 'left':
      x = rect.x - domWidth - gap;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;

    case 'right':
      x = rect.x + rectWidth + gap;
      y = rect.y + rectHeight / 2 - domHeight / 2;
  }

  return [x, y];
}

function isCenterAlign(align) {
  return align === 'center' || align === 'middle';
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/config.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// (1) The code `if (__DEV__) ...` can be removed by build tool.
// (2) If intend to use `__DEV__`, this module should be imported. Use a global
// variable `__DEV__` may cause that miss the declaration (see #6535), or the
// declaration is behind of the using position (for example in `Model.extent`,
// And tools like rollup can not analysis the dependency if not import).
var dev; // In browser

if (typeof window !== 'undefined') {
  dev = window.__DEV__;
} // In node
else if (typeof global !== 'undefined') {
    dev = global.__DEV__;
  }

if (typeof dev === 'undefined') {
  dev = true;
}

var __DEV__ = dev;
exports.__DEV__ = __DEV__;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/echarts/lib/coord/Axis.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var each = _util.each;
var map = _util.map;

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var linearMap = _number.linearMap;
var getPixelPrecision = _number.getPixelPrecision;

var _axisTickLabelBuilder = __webpack_require__("./node_modules/echarts/lib/coord/axisTickLabelBuilder.js");

var createAxisTicks = _axisTickLabelBuilder.createAxisTicks;
var createAxisLabels = _axisTickLabelBuilder.createAxisLabels;
var calculateCategoryInterval = _axisTickLabelBuilder.calculateCategoryInterval;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var NORMALIZED_EXTENT = [0, 1];
/**
 * Base class of Axis.
 * @constructor
 */

var Axis = function (dim, scale, extent) {
  /**
   * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'.
   * @type {string}
   */
  this.dim = dim;
  /**
   * Axis scale
   * @type {module:echarts/coord/scale/*}
   */

  this.scale = scale;
  /**
   * @type {Array.<number>}
   * @private
   */

  this._extent = extent || [0, 0];
  /**
   * @type {boolean}
   */

  this.inverse = false;
  /**
   * Usually true when axis has a ordinal scale
   * @type {boolean}
   */

  this.onBand = false;
};

Axis.prototype = {
  constructor: Axis,

  /**
   * If axis extent contain given coord
   * @param {number} coord
   * @return {boolean}
   */
  contain: function (coord) {
    var extent = this._extent;
    var min = Math.min(extent[0], extent[1]);
    var max = Math.max(extent[0], extent[1]);
    return coord >= min && coord <= max;
  },

  /**
   * If axis extent contain given data
   * @param {number} data
   * @return {boolean}
   */
  containData: function (data) {
    return this.contain(this.dataToCoord(data));
  },

  /**
   * Get coord extent.
   * @return {Array.<number>}
   */
  getExtent: function () {
    return this._extent.slice();
  },

  /**
   * Get precision used for formatting
   * @param {Array.<number>} [dataExtent]
   * @return {number}
   */
  getPixelPrecision: function (dataExtent) {
    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  },

  /**
   * Set coord extent
   * @param {number} start
   * @param {number} end
   */
  setExtent: function (start, end) {
    var extent = this._extent;
    extent[0] = start;
    extent[1] = end;
  },

  /**
   * Convert data to coord. Data is the rank if it has an ordinal scale
   * @param {number} data
   * @param  {boolean} clamp
   * @return {number}
   */
  dataToCoord: function (data, clamp) {
    var extent = this._extent;
    var scale = this.scale;
    data = scale.normalize(data);

    if (this.onBand && scale.type === 'ordinal') {
      extent = extent.slice();
      fixExtentWithBands(extent, scale.count());
    }

    return linearMap(data, NORMALIZED_EXTENT, extent, clamp);
  },

  /**
   * Convert coord to data. Data is the rank if it has an ordinal scale
   * @param {number} coord
   * @param  {boolean} clamp
   * @return {number}
   */
  coordToData: function (coord, clamp) {
    var extent = this._extent;
    var scale = this.scale;

    if (this.onBand && scale.type === 'ordinal') {
      extent = extent.slice();
      fixExtentWithBands(extent, scale.count());
    }

    var t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp);
    return this.scale.scale(t);
  },

  /**
   * Convert pixel point to data in axis
   * @param {Array.<number>} point
   * @param  {boolean} clamp
   * @return {number} data
   */
  pointToData: function (point, clamp) {// Should be implemented in derived class if necessary.
  },

  /**
   * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
   * `axis.getTicksCoords` considers `onBand`, which is used by
   * `boundaryGap:true` of category axis and splitLine and splitArea.
   * @param {Object} [opt]
   * @param {number} [opt.tickModel=axis.model.getModel('axisTick')]
   * @param {boolean} [opt.clamp] If `true`, the first and the last
   *        tick must be at the axis end points. Otherwise, clip ticks
   *        that outside the axis extent.
   * @return {Array.<Object>} [{
   *     coord: ...,
   *     tickValue: ...
   * }, ...]
   */
  getTicksCoords: function (opt) {
    opt = opt || {};
    var tickModel = opt.tickModel || this.getTickModel();
    var result = createAxisTicks(this, tickModel);
    var ticks = result.ticks;
    var ticksCoords = map(ticks, function (tickValue) {
      return {
        coord: this.dataToCoord(tickValue),
        tickValue: tickValue
      };
    }, this);
    var alignWithLabel = tickModel.get('alignWithLabel');
    fixOnBandTicksCoords(this, ticksCoords, result.tickCategoryInterval, alignWithLabel, opt.clamp);
    return ticksCoords;
  },

  /**
   * @return {Array.<Object>} [{
   *     formattedLabel: string,
   *     rawLabel: axis.scale.getLabel(tickValue)
   *     tickValue: number
   * }, ...]
   */
  getViewLabels: function () {
    return createAxisLabels(this).labels;
  },

  /**
   * @return {module:echarts/coord/model/Model}
   */
  getLabelModel: function () {
    return this.model.getModel('axisLabel');
  },

  /**
   * Notice here we only get the default tick model. For splitLine
   * or splitArea, we should pass the splitLineModel or splitAreaModel
   * manually when calling `getTicksCoords`.
   * In GL, this method may be overrided to:
   * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
   * @return {module:echarts/coord/model/Model}
   */
  getTickModel: function () {
    return this.model.getModel('axisTick');
  },

  /**
   * Get width of band
   * @return {number}
   */
  getBandWidth: function () {
    var axisExtent = this._extent;
    var dataExtent = this.scale.getExtent();
    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.

    len === 0 && (len = 1);
    var size = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size) / len;
  },

  /**
   * @abstract
   * @return {boolean} Is horizontal
   */
  isHorizontal: null,

  /**
   * @abstract
   * @return {number} Get axis rotate, by degree.
   */
  getRotate: null,

  /**
   * Only be called in category axis.
   * Can be overrided, consider other axes like in 3D.
   * @return {number} Auto interval for cateogry axis tick and label
   */
  calculateCategoryInterval: function () {
    return calculateCategoryInterval(this);
  }
};

function fixExtentWithBands(extent, nTick) {
  var size = extent[1] - extent[0];
  var len = nTick;
  var margin = size / len / 2;
  extent[0] += margin;
  extent[1] -= margin;
} // If axis has labels [1, 2, 3, 4]. Bands on the axis are
// |---1---|---2---|---3---|---4---|.
// So the displayed ticks and splitLine/splitArea should between
// each data item, otherwise cause misleading (e.g., split tow bars
// of a single data item when there are two bar series).
// Also consider if tickCategoryInterval > 0 and onBand, ticks and
// splitLine/spliteArea should layout appropriately corresponding
// to displayed labels. (So we should not use `getBandWidth` in this
// case).


function fixOnBandTicksCoords(axis, ticksCoords, tickCategoryInterval, alignWithLabel, clamp) {
  var ticksLen = ticksCoords.length;

  if (!axis.onBand || alignWithLabel || !ticksLen) {
    return;
  }

  var axisExtent = axis.getExtent();
  var last;

  if (ticksLen === 1) {
    ticksCoords[0].coord = axisExtent[0];
    last = ticksCoords[1] = {
      coord: axisExtent[0]
    };
  } else {
    var shift = ticksCoords[1].coord - ticksCoords[0].coord;
    each(ticksCoords, function (ticksItem) {
      ticksItem.coord -= shift / 2;
      var tickCategoryInterval = tickCategoryInterval || 0; // Avoid split a single data item when odd interval.

      if (tickCategoryInterval % 2 > 0) {
        ticksItem.coord -= shift / ((tickCategoryInterval + 1) * 2);
      }
    });
    last = {
      coord: ticksCoords[ticksLen - 1].coord + shift
    };
    ticksCoords.push(last);
  }

  var inverse = axisExtent[0] > axisExtent[1];

  if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
    clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
  }

  if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {
    ticksCoords.unshift({
      coord: axisExtent[0]
    });
  }

  if (littleThan(axisExtent[1], last.coord)) {
    clamp ? last.coord = axisExtent[1] : ticksCoords.pop();
  }

  if (clamp && littleThan(last.coord, axisExtent[1])) {
    ticksCoords.push({
      coord: axisExtent[1]
    });
  }

  function littleThan(a, b) {
    return inverse ? a > b : a < b;
  }
}

var _default = Axis;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisDefault.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var defaultOption = {
  show: true,
  zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: false,
  // Axis name displayed.
  name: '',
  // 'start' | 'middle' | 'end'
  nameLocation: 'end',
  // By degree. By defualt auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: '...',
    placeholder: '.'
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: false,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: false,
  tooltip: {
    show: false
  },
  axisPointer: {},
  axisLine: {
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    lineStyle: {
      color: '#333',
      width: 1,
      type: 'solid'
    },
    // The arrow at both ends the the axis.
    symbol: ['none', 'none'],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: true,
    // Whether axisTick is inside the grid or outside the grid.
    inside: false,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: false,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: true,
    lineStyle: {
      color: ['#ccc'],
      width: 1,
      type: 'solid'
    }
  },
  splitArea: {
    show: false,
    areaStyle: {
      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']
    }
  }
};
var axisDefault = {};
axisDefault.categoryAxis = zrUtil.merge({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: true,
  // Set false to faster category collection.
  // Only usefull in the case like: category is
  // ['2012-01-01', '2012-01-02', ...], where the input
  // data has been ensured not duplicate and is large data.
  // null means "auto":
  // if axis.data provided, do not deduplication,
  // else do deduplication.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: false
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: false,
    interval: 'auto'
  },
  axisLabel: {
    interval: 'auto'
  }
}, defaultOption);
axisDefault.valueAxis = zrUtil.merge({
  // The gap at both ends of the axis. For value axis, [GAP, GAP], where
  // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)
  boundaryGap: [0, 0],
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  // Min value of the axis. can be:
  // + a number
  // + 'dataMin': use the min value in data.
  // + null/undefined: auto decide min value (consider pretty look and boundaryGap).
  // min: null,
  // Max value of the axis. can be:
  // + a number
  // + 'dataMax': use the max value in data.
  // + null/undefined: auto decide max value (consider pretty look and boundaryGap).
  // max: null,
  // Readonly prop, specifies start value of the range when using data zoom.
  // rangeStart: null
  // Readonly prop, specifies end value of the range when using data zoom.
  // rangeEnd: null
  // Optional value can be:
  // + `false`: always include value 0.
  // + `true`: the extent do not consider value 0.
  // scale: false,
  // AxisTick and axisLabel and splitLine are caculated based on splitNumber.
  splitNumber: 5 // Interval specifies the span of the ticks is mandatorily.
  // interval: null
  // Specify min interval when auto calculate tick interval.
  // minInterval: null
  // Specify max interval when auto calculate tick interval.
  // maxInterval: null

}, defaultOption);
axisDefault.timeAxis = zrUtil.defaults({
  scale: true,
  min: 'dataMin',
  max: 'dataMax'
}, axisDefault.valueAxis);
axisDefault.logAxis = zrUtil.defaults({
  scale: true,
  logBase: 10
}, axisDefault.valueAxis);
var _default = axisDefault;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var OrdinalScale = __webpack_require__("./node_modules/echarts/lib/scale/Ordinal.js");

var IntervalScale = __webpack_require__("./node_modules/echarts/lib/scale/Interval.js");

var Scale = __webpack_require__("./node_modules/echarts/lib/scale/Scale.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var _barGrid = __webpack_require__("./node_modules/echarts/lib/layout/barGrid.js");

var prepareLayoutBarSeries = _barGrid.prepareLayoutBarSeries;
var makeColumnLayout = _barGrid.makeColumnLayout;
var retrieveColumnLayout = _barGrid.retrieveColumnLayout;

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

__webpack_require__("./node_modules/echarts/lib/scale/Time.js");

__webpack_require__("./node_modules/echarts/lib/scale/Log.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Get axis scale extent before niced.
 * Item of returned array can only be number (including Infinity and NaN).
 */
function getScaleExtent(scale, model) {
  var scaleType = scale.type;
  var min = model.getMin();
  var max = model.getMax();
  var fixMin = min != null;
  var fixMax = max != null;
  var originalExtent = scale.getExtent();
  var axisDataLen;
  var boundaryGap;
  var span;

  if (scaleType === 'ordinal') {
    axisDataLen = model.getCategories().length;
  } else {
    boundaryGap = model.get('boundaryGap');

    if (!zrUtil.isArray(boundaryGap)) {
      boundaryGap = [boundaryGap || 0, boundaryGap || 0];
    }

    if (typeof boundaryGap[0] === 'boolean') {
      boundaryGap = [0, 0];
    }

    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);
    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);
    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);
  } // Notice: When min/max is not set (that is, when there are null/undefined,
  // which is the most common case), these cases should be ensured:
  // (1) For 'ordinal', show all axis.data.
  // (2) For others:
  //      + `boundaryGap` is applied (if min/max set, boundaryGap is
  //      disabled).
  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should
  //      be the result that originalExtent enlarged by boundaryGap.
  // (3) If no data, it should be ensured that `scale.setBlank` is set.
  // FIXME
  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?
  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured
  // that the results processed by boundaryGap are positive/negative?


  if (min == null) {
    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;
  }

  if (max == null) {
    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;
  }

  if (min === 'dataMin') {
    min = originalExtent[0];
  } else if (typeof min === 'function') {
    min = min({
      min: originalExtent[0],
      max: originalExtent[1]
    });
  }

  if (max === 'dataMax') {
    max = originalExtent[1];
  } else if (typeof max === 'function') {
    max = max({
      min: originalExtent[0],
      max: originalExtent[1]
    });
  }

  (min == null || !isFinite(min)) && (min = NaN);
  (max == null || !isFinite(max)) && (max = NaN);
  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max) || scaleType === 'ordinal' && !scale.getOrdinalMeta().categories.length); // Evaluate if axis needs cross zero

  if (model.getNeedCrossZero()) {
    // Axis is over zero and min is not set
    if (min > 0 && max > 0 && !fixMin) {
      min = 0;
    } // Axis is under zero and max is not set


    if (min < 0 && max < 0 && !fixMax) {
      max = 0;
    }
  } // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis
  // is base axis
  // FIXME
  // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.
  // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?
  //     Should not depend on series type `bar`?
  // (3) Fix that might overlap when using dataZoom.
  // (4) Consider other chart types using `barGrid`?
  // See #6728, #4862, `test/bar-overflow-time-plot.html`


  var ecModel = model.ecModel;

  if (ecModel && scaleType === 'time'
  /*|| scaleType === 'interval' */
  ) {
    var barSeriesModels = prepareLayoutBarSeries('bar', ecModel);
    var isBaseAxisAndHasBarSeries;
    zrUtil.each(barSeriesModels, function (seriesModel) {
      isBaseAxisAndHasBarSeries |= seriesModel.getBaseAxis() === model.axis;
    });

    if (isBaseAxisAndHasBarSeries) {
      // Calculate placement of bars on axis
      var barWidthAndOffset = makeColumnLayout(barSeriesModels); // Adjust axis min and max to account for overflow

      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);
      min = adjustedScale.min;
      max = adjustedScale.max;
    }
  }

  return [min, max];
}

function adjustScaleForOverflow(min, max, model, barWidthAndOffset) {
  // Get Axis Length
  var axisExtent = model.axis.getExtent();
  var axisLength = axisExtent[1] - axisExtent[0]; // Get bars on current base axis and calculate min and max overflow

  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);

  if (barsOnCurrentAxis === undefined) {
    return {
      min: min,
      max: max
    };
  }

  var minOverflow = Infinity;
  zrUtil.each(barsOnCurrentAxis, function (item) {
    minOverflow = Math.min(item.offset, minOverflow);
  });
  var maxOverflow = -Infinity;
  zrUtil.each(barsOnCurrentAxis, function (item) {
    maxOverflow = Math.max(item.offset + item.width, maxOverflow);
  });
  minOverflow = Math.abs(minOverflow);
  maxOverflow = Math.abs(maxOverflow);
  var totalOverFlow = minOverflow + maxOverflow; // Calulate required buffer based on old range and overflow

  var oldRange = max - min;
  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
  max += overflowBuffer * (maxOverflow / totalOverFlow);
  min -= overflowBuffer * (minOverflow / totalOverFlow);
  return {
    min: min,
    max: max
  };
}

function niceScaleExtent(scale, model) {
  var extent = getScaleExtent(scale, model);
  var fixMin = model.getMin() != null;
  var fixMax = model.getMax() != null;
  var splitNumber = model.get('splitNumber');

  if (scale.type === 'log') {
    scale.base = model.get('logBase');
  }

  var scaleType = scale.type;
  scale.setExtent(extent[0], extent[1]);
  scale.niceExtent({
    splitNumber: splitNumber,
    fixMin: fixMin,
    fixMax: fixMax,
    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,
    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null
  }); // If some one specified the min, max. And the default calculated interval
  // is not good enough. He can specify the interval. It is often appeared
  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
  // to be 60.
  // FIXME

  var interval = model.get('interval');

  if (interval != null) {
    scale.setInterval && scale.setInterval(interval);
  }
}
/**
 * @param {module:echarts/model/Model} model
 * @param {string} [axisType] Default retrieve from model.type
 * @return {module:echarts/scale/*}
 */


function createScaleByModel(model, axisType) {
  axisType = axisType || model.get('type');

  if (axisType) {
    switch (axisType) {
      // Buildin scale
      case 'category':
        return new OrdinalScale(model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(), [Infinity, -Infinity]);

      case 'value':
        return new IntervalScale();
      // Extended scale, like time and log

      default:
        return (Scale.getClass(axisType) || IntervalScale).create(model);
    }
  }
}
/**
 * Check if the axis corss 0
 */


function ifAxisCrossZero(axis) {
  var dataExtent = axis.scale.getExtent();
  var min = dataExtent[0];
  var max = dataExtent[1];
  return !(min > 0 && max > 0 || min < 0 && max < 0);
}
/**
 * @param {module:echarts/coord/Axis} axis
 * @return {Function} Label formatter function.
 *         param: {number} tickValue,
 *         param: {number} idx, the index in all ticks.
 *                         If category axis, this param is not requied.
 *         return: {string} label string.
 */


function makeLabelFormatter(axis) {
  var labelFormatter = axis.getLabelModel().get('formatter');
  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;

  if (typeof labelFormatter === 'string') {
    labelFormatter = function (tpl) {
      return function (val) {
        return tpl.replace('{value}', val != null ? val : '');
      };
    }(labelFormatter); // Consider empty array


    return labelFormatter;
  } else if (typeof labelFormatter === 'function') {
    return function (tickValue, idx) {
      // The original intention of `idx` is "the index of the tick in all ticks".
      // But the previous implementation of category axis do not consider the
      // `axisLabel.interval`, which cause that, for example, the `interval` is
      // `1`, then the ticks "name5", "name7", "name9" are displayed, where the
      // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep
      // the definition here for back compatibility.
      if (categoryTickStart != null) {
        idx = tickValue - categoryTickStart;
      }

      return labelFormatter(getAxisRawValue(axis, tickValue), idx);
    };
  } else {
    return function (tick) {
      return axis.scale.getLabel(tick);
    };
  }
}

function getAxisRawValue(axis, value) {
  // In category axis with data zoom, tick is not the original
  // index of axis.data. So tick should not be exposed to user
  // in category axis.
  return axis.type === 'category' ? axis.scale.getLabel(value) : value;
}
/**
 * @param {module:echarts/coord/Axis} axis
 * @return {module:zrender/core/BoundingRect} Be null/undefined if no labels.
 */


function estimateLabelUnionRect(axis) {
  var axisModel = axis.model;
  var scale = axis.scale;

  if (!axisModel.get('axisLabel.show') || scale.isBlank()) {
    return;
  }

  var isCategory = axis.type === 'category';
  var realNumberScaleTicks;
  var tickCount;
  var categoryScaleExtent = scale.getExtent(); // Optimize for large category data, avoid call `getTicks()`.

  if (isCategory) {
    tickCount = scale.count();
  } else {
    realNumberScaleTicks = scale.getTicks();
    tickCount = realNumberScaleTicks.length;
  }

  var axisLabelModel = axis.getLabelModel();
  var labelFormatter = makeLabelFormatter(axis);
  var rect;
  var step = 1; // Simple optimization for large amount of labels

  if (tickCount > 40) {
    step = Math.ceil(tickCount / 40);
  }

  for (var i = 0; i < tickCount; i += step) {
    var tickValue = realNumberScaleTicks ? realNumberScaleTicks[i] : categoryScaleExtent[0] + i;
    var label = labelFormatter(tickValue);
    var unrotatedSingleRect = axisLabelModel.getTextRect(label);
    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);
    rect ? rect.union(singleRect) : rect = singleRect;
  }

  return rect;
}

function rotateTextRect(textRect, rotate) {
  var rotateRadians = rotate * Math.PI / 180;
  var boundingBox = textRect.plain();
  var beforeWidth = boundingBox.width;
  var beforeHeight = boundingBox.height;
  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);
  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);
  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);
  return rotatedRect;
}

exports.getScaleExtent = getScaleExtent;
exports.niceScaleExtent = niceScaleExtent;
exports.createScaleByModel = createScaleByModel;
exports.ifAxisCrossZero = ifAxisCrossZero;
exports.makeLabelFormatter = makeLabelFormatter;
exports.getAxisRawValue = getAxisRawValue;
exports.estimateLabelUnionRect = estimateLabelUnionRect;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisModelCommonMixin.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = {
  /**
   * @param {boolean} origin
   * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN
   */
  getMin: function (origin) {
    var option = this.option;
    var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;

    if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !zrUtil.eqNaN(min)) {
      min = this.axis.scale.parse(min);
    }

    return min;
  },

  /**
   * @param {boolean} origin
   * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN
   */
  getMax: function (origin) {
    var option = this.option;
    var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;

    if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !zrUtil.eqNaN(max)) {
      max = this.axis.scale.parse(max);
    }

    return max;
  },

  /**
   * @return {boolean}
   */
  getNeedCrossZero: function () {
    var option = this.option;
    return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;
  },

  /**
   * Should be implemented by each axis model if necessary.
   * @return {module:echarts/model/Component} coordinate system model
   */
  getCoordSysModel: zrUtil.noop,

  /**
   * @param {number} rangeStart Can only be finite number or null/undefined or NaN.
   * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.
   */
  setRange: function (rangeStart, rangeEnd) {
    this.option.rangeStart = rangeStart;
    this.option.rangeEnd = rangeEnd;
  },

  /**
   * Reset range
   */
  resetRange: function () {
    // rangeStart and rangeEnd is readonly.
    this.option.rangeStart = this.option.rangeEnd = null;
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisModelCreator.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var axisDefault = __webpack_require__("./node_modules/echarts/lib/coord/axisDefault.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutParams = _layout.getLayoutParams;
var mergeLayoutParam = _layout.mergeLayoutParam;

var OrdinalMeta = __webpack_require__("./node_modules/echarts/lib/data/OrdinalMeta.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// FIXME axisType is fixed ?
var AXIS_TYPES = ['value', 'category', 'time', 'log'];
/**
 * Generate sub axis model class
 * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
 * @param {module:echarts/model/Component} BaseAxisModelClass
 * @param {Function} axisTypeDefaulter
 * @param {Object} [extraDefaultOption]
 */

function _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
  zrUtil.each(AXIS_TYPES, function (axisType) {
    BaseAxisModelClass.extend({
      /**
       * @readOnly
       */
      type: axisName + 'Axis.' + axisType,
      mergeDefaultAndTheme: function (option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));
        zrUtil.merge(option, this.getDefaultOption());
        option.type = axisTypeDefaulter(axisName, option);

        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      },

      /**
       * @override
       */
      optionUpdated: function () {
        var thisOption = this.option;

        if (thisOption.type === 'category') {
          this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);
        }
      },

      /**
       * Should not be called before all of 'getInitailData' finished.
       * Because categories are collected during initializing data.
       */
      getCategories: function (rawData) {
        var option = this.option; // FIXME
        // warning if called before all of 'getInitailData' finished.

        if (option.type === 'category') {
          if (rawData) {
            return option.data;
          }

          return this.__ordinalMeta.categories;
        }
      },
      getOrdinalMeta: function () {
        return this.__ordinalMeta;
      },
      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)
    });
  });
  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisTickLabelBuilder.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var makeInner = _model.makeInner;

var _axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

var makeLabelFormatter = _axisHelper.makeLabelFormatter;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var inner = makeInner();
/**
 * @param {module:echats/coord/Axis} axis
 * @return {Object} {
 *     labels: [{
 *         formattedLabel: string,
 *         rawLabel: string,
 *         tickValue: number
 *     }, ...],
 *     labelCategoryInterval: number
 * }
 */

function createAxisLabels(axis) {
  // Only ordinal scale support tick interval
  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
}
/**
 * @param {module:echats/coord/Axis} axis
 * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.
 * @return {Object} {
 *     ticks: Array.<number>
 *     tickCategoryInterval: number
 * }
 */


function createAxisTicks(axis, tickModel) {
  // Only ordinal scale support tick interval
  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {
    ticks: axis.scale.getTicks()
  };
}

function makeCategoryLabels(axis) {
  var labelModel = axis.getLabelModel();
  var result = makeCategoryLabelsActually(axis, labelModel);
  return !labelModel.get('show') || axis.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: result.labelCategoryInterval
  } : result;
}

function makeCategoryLabelsActually(axis, labelModel) {
  var labelsCache = getListCache(axis, 'labels');
  var optionLabelInterval = getOptionCategoryInterval(labelModel);
  var result = listCacheGet(labelsCache, optionLabelInterval);

  if (result) {
    return result;
  }

  var labels;
  var numericLabelInterval;

  if (zrUtil.isFunction(optionLabelInterval)) {
    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
  } else {
    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;
    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
  } // Cache to avoid calling interval function repeatly.


  return listCacheSet(labelsCache, optionLabelInterval, {
    labels: labels,
    labelCategoryInterval: numericLabelInterval
  });
}

function makeCategoryTicks(axis, tickModel) {
  var ticksCache = getListCache(axis, 'ticks');
  var optionTickInterval = getOptionCategoryInterval(tickModel);
  var result = listCacheGet(ticksCache, optionTickInterval);

  if (result) {
    return result;
  }

  var ticks;
  var tickCategoryInterval; // Optimize for the case that large category data and no label displayed,
  // we should not return all ticks.

  if (!tickModel.get('show') || axis.scale.isBlank()) {
    ticks = [];
  }

  if (zrUtil.isFunction(optionTickInterval)) {
    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
  } // Always use label interval by default despite label show. Consider this
  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows
  // labels. `splitLine` and `axisTick` should be consistent in this case.
  else if (optionTickInterval === 'auto') {
      var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
      tickCategoryInterval = labelsResult.labelCategoryInterval;
      ticks = zrUtil.map(labelsResult.labels, function (labelItem) {
        return labelItem.tickValue;
      });
    } else {
      tickCategoryInterval = optionTickInterval;
      ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
    } // Cache to avoid calling interval function repeatly.


  return listCacheSet(ticksCache, optionTickInterval, {
    ticks: ticks,
    tickCategoryInterval: tickCategoryInterval
  });
}

function makeRealNumberLabels(axis) {
  var ticks = axis.scale.getTicks();
  var labelFormatter = makeLabelFormatter(axis);
  return {
    labels: zrUtil.map(ticks, function (tickValue, idx) {
      return {
        formattedLabel: labelFormatter(tickValue, idx),
        rawLabel: axis.scale.getLabel(tickValue),
        tickValue: tickValue
      };
    })
  };
} // Large category data calculation is performence sensitive, and ticks and label
// probably be fetched by multiple times. So we cache the result.
// axis is created each time during a ec process, so we do not need to clear cache.


function getListCache(axis, prop) {
  // Because key can be funciton, and cache size always be small, we use array cache.
  return inner(axis)[prop] || (inner(axis)[prop] = []);
}

function listCacheGet(cache, key) {
  for (var i = 0; i < cache.length; i++) {
    if (cache[i].key === key) {
      return cache[i].value;
    }
  }
}

function listCacheSet(cache, key, value) {
  cache.push({
    key: key,
    value: value
  });
  return value;
}

function makeAutoCategoryInterval(axis) {
  var result = inner(axis).autoInterval;
  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();
}
/**
 * Calculate interval for category axis ticks and labels.
 * To get precise result, at least one of `getRotate` and `isHorizontal`
 * should be implemented in axis.
 */


function calculateCategoryInterval(axis) {
  var params = fetchAutoCategoryIntervalCalculationParams(axis);
  var labelFormatter = makeLabelFormatter(axis);
  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:
  // avoid generating a long array by `getTicks`
  // in large category data case.

  var tickCount = ordinalScale.count();

  if (ordinalExtent[1] - ordinalExtent[0] < 1) {
    return 0;
  }

  var step = 1; // Simple optimization. Empirical value: tick count should less than 40.

  if (tickCount > 40) {
    step = Math.max(1, Math.floor(tickCount / 40));
  }

  var tickValue = ordinalExtent[0];
  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
  var unitW = Math.abs(unitSpan * Math.cos(rotation));
  var unitH = Math.abs(unitSpan * Math.sin(rotation));
  var maxW = 0;
  var maxH = 0; // Caution: Performance sensitive for large category data.
  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.

  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    var width = 0;
    var height = 0; // Polar is also calculated in assumptive linear layout here.
    // Not precise, do not consider align and vertical align
    // and each distance from axis line yet.

    var rect = textContain.getBoundingRect(labelFormatter(tickValue), params.font, 'center', 'top'); // Magic number

    width = rect.width * 1.3;
    height = rect.height * 1.3; // Min size, void long loop.

    maxW = Math.max(maxW, width, 7);
    maxH = Math.max(maxH, height, 7);
  }

  var dw = maxW / unitW;
  var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.

  isNaN(dw) && (dw = Infinity);
  isNaN(dh) && (dh = Infinity);
  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
  var cache = inner(axis.model);
  var lastAutoInterval = cache.lastAutoInterval;
  var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,
  // otherwise the calculated interval might jitter when the zoom
  // window size is close to the interval-changing size.

  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical
  // point is not the same when zooming in or zooming out.
  && lastAutoInterval > interval) {
    interval = lastAutoInterval;
  } // Only update cache if cache not used, otherwise the
  // changing of interval is too insensitive.
  else {
      cache.lastTickCount = tickCount;
      cache.lastAutoInterval = interval;
    }

  return interval;
}

function fetchAutoCategoryIntervalCalculationParams(axis) {
  var labelModel = axis.getLabelModel();
  return {
    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
    labelRotate: labelModel.get('rotate') || 0,
    font: labelModel.getFont()
  };
}

function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
  var labelFormatter = makeLabelFormatter(axis);
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var labelModel = axis.getLabelModel();
  var result = []; // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...

  var step = Math.max((categoryInterval || 0) + 1, 1);
  var startTick = ordinalExtent[0];
  var tickCount = ordinalScale.count(); // Calculate start tick based on zero if possible to keep label consistent
  // while zooming and moving while interval > 0. Otherwise the selection
  // of displayable ticks and symbols probably keep changing.
  // 3 is empirical value.

  if (startTick !== 0 && step > 1 && tickCount / step > 2) {
    startTick = Math.round(Math.ceil(startTick / step) * step);
  } // (1) Only add min max label here but leave overlap checking
  // to render stage, which also ensure the returned list
  // suitable for splitLine and splitArea rendering.
  // (2) Scales except category always contain min max label so
  // do not need to perform this process.


  var showMinMax = {
    min: labelModel.get('showMinLabel'),
    max: labelModel.get('showMaxLabel')
  };

  if (showMinMax.min && startTick !== ordinalExtent[0]) {
    addItem(ordinalExtent[0]);
  } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.


  var tickValue = startTick;

  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    addItem(tickValue);
  }

  if (showMinMax.max && tickValue !== ordinalExtent[1]) {
    addItem(ordinalExtent[1]);
  }

  function addItem(tVal) {
    result.push(onlyTick ? tVal : {
      formattedLabel: labelFormatter(tVal),
      rawLabel: ordinalScale.getLabel(tVal),
      tickValue: tVal
    });
  }

  return result;
} // When interval is function, the result `false` means ignore the tick.
// It is time consuming for large category data.


function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
  var ordinalScale = axis.scale;
  var labelFormatter = makeLabelFormatter(axis);
  var result = [];
  zrUtil.each(ordinalScale.getTicks(), function (tickValue) {
    var rawLabel = ordinalScale.getLabel(tickValue);

    if (categoryInterval(tickValue, rawLabel)) {
      result.push(onlyTick ? tickValue : {
        formattedLabel: labelFormatter(tickValue),
        rawLabel: rawLabel,
        tickValue: tickValue
      });
    }
  });
  return result;
} // Can be null|'auto'|number|function


function getOptionCategoryInterval(model) {
  var interval = model.get('interval');
  return interval == null ? 'auto' : interval;
}

exports.createAxisLabels = createAxisLabels;
exports.createAxisTicks = createAxisTicks;
exports.calculateCategoryInterval = calculateCategoryInterval;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Axis2D.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Axis = __webpack_require__("./node_modules/echarts/lib/coord/Axis.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Extend axis 2d
 * @constructor module:echarts/coord/cartesian/Axis2D
 * @extends {module:echarts/coord/cartesian/Axis}
 * @param {string} dim
 * @param {*} scale
 * @param {Array.<number>} coordExtent
 * @param {string} axisType
 * @param {string} position
 */
var Axis2D = function (dim, scale, coordExtent, axisType, position) {
  Axis.call(this, dim, scale, coordExtent);
  /**
   * Axis type
   *  - 'category'
   *  - 'value'
   *  - 'time'
   *  - 'log'
   * @type {string}
   */

  this.type = axisType || 'value';
  /**
   * Axis position
   *  - 'top'
   *  - 'bottom'
   *  - 'left'
   *  - 'right'
   */

  this.position = position || 'bottom';
};

Axis2D.prototype = {
  constructor: Axis2D,

  /**
   * Index of axis, can be used as key
   */
  index: 0,

  /**
   * Implemented in <module:echarts/coord/cartesian/Grid>.
   * @return {Array.<module:echarts/coord/cartesian/Axis2D>}
   *         If not on zero of other axis, return null/undefined.
   *         If no axes, return an empty array.
   */
  getAxesOnZeroOf: null,

  /**
   * Axis model
   * @param {module:echarts/coord/cartesian/AxisModel}
   */
  model: null,
  isHorizontal: function () {
    var position = this.position;
    return position === 'top' || position === 'bottom';
  },

  /**
   * Each item cooresponds to this.getExtent(), which
   * means globalExtent[0] may greater than globalExtent[1],
   * unless `asc` is input.
   *
   * @param {boolean} [asc]
   * @return {Array.<number>}
   */
  getGlobalExtent: function (asc) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc && ret[0] > ret[1] && ret.reverse();
    return ret;
  },
  getOtherAxis: function () {
    this.grid.getOtherAxis();
  },

  /**
   * @override
   */
  pointToData: function (point, clamp) {
    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);
  },

  /**
   * Transform global coord to local coord,
   * i.e. var localCoord = axis.toLocalCoord(80);
   * designate by module:echarts/coord/cartesian/Grid.
   * @type {Function}
   */
  toLocalCoord: null,

  /**
   * Transform global coord to local coord,
   * i.e. var globalCoord = axis.toLocalCoord(40);
   * designate by module:echarts/coord/cartesian/Grid.
   * @type {Function}
   */
  toGlobalCoord: null
};
zrUtil.inherits(Axis2D, Axis);
var _default = Axis2D;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/AxisModel.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var axisModelCreator = __webpack_require__("./node_modules/echarts/lib/coord/axisModelCreator.js");

var axisModelCommonMixin = __webpack_require__("./node_modules/echarts/lib/coord/axisModelCommonMixin.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var AxisModel = ComponentModel.extend({
  type: 'cartesian2dAxis',

  /**
   * @type {module:echarts/coord/cartesian/Axis2D}
   */
  axis: null,

  /**
   * @override
   */
  init: function () {
    AxisModel.superApply(this, 'init', arguments);
    this.resetRange();
  },

  /**
   * @override
   */
  mergeOption: function () {
    AxisModel.superApply(this, 'mergeOption', arguments);
    this.resetRange();
  },

  /**
   * @override
   */
  restoreData: function () {
    AxisModel.superApply(this, 'restoreData', arguments);
    this.resetRange();
  },

  /**
   * @override
   * @return {module:echarts/model/Component}
   */
  getCoordSysModel: function () {
    return this.ecModel.queryComponents({
      mainType: 'grid',
      index: this.option.gridIndex,
      id: this.option.gridId
    })[0];
  }
});

function getAxisType(axisDim, option) {
  // Default axis with data is category axis
  return option.type || (option.data ? 'category' : 'value');
}

zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
var extraOption = {
  // gridIndex: 0,
  // gridId: '',
  // Offset is for multiple axis on the same position
  offset: 0
};
axisModelCreator('x', AxisModel, getAxisType, extraOption);
axisModelCreator('y', AxisModel, getAxisType, extraOption);
var _default = AxisModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Cartesian.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Cartesian coordinate system
 * @module  echarts/coord/Cartesian
 *
 */
function dimAxisMapper(dim) {
  return this._axes[dim];
}
/**
 * @alias module:echarts/coord/Cartesian
 * @constructor
 */


var Cartesian = function (name) {
  this._axes = {};
  this._dimList = [];
  /**
   * @type {string}
   */

  this.name = name || '';
};

Cartesian.prototype = {
  constructor: Cartesian,
  type: 'cartesian',

  /**
   * Get axis
   * @param  {number|string} dim
   * @return {module:echarts/coord/Cartesian~Axis}
   */
  getAxis: function (dim) {
    return this._axes[dim];
  },

  /**
   * Get axes list
   * @return {Array.<module:echarts/coord/Cartesian~Axis>}
   */
  getAxes: function () {
    return zrUtil.map(this._dimList, dimAxisMapper, this);
  },

  /**
   * Get axes list by given scale type
   */
  getAxesByScale: function (scaleType) {
    scaleType = scaleType.toLowerCase();
    return zrUtil.filter(this.getAxes(), function (axis) {
      return axis.scale.type === scaleType;
    });
  },

  /**
   * Add axis
   * @param {module:echarts/coord/Cartesian.Axis}
   */
  addAxis: function (axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;

    this._dimList.push(dim);
  },

  /**
   * Convert data to coord in nd space
   * @param {Array.<number>|Object.<string, number>} val
   * @return {Array.<number>|Object.<string, number>}
   */
  dataToCoord: function (val) {
    return this._dataCoordConvert(val, 'dataToCoord');
  },

  /**
   * Convert coord in nd space to data
   * @param  {Array.<number>|Object.<string, number>} val
   * @return {Array.<number>|Object.<string, number>}
   */
  coordToData: function (val) {
    return this._dataCoordConvert(val, 'coordToData');
  },
  _dataCoordConvert: function (input, method) {
    var dimList = this._dimList;
    var output = input instanceof Array ? [] : {};

    for (var i = 0; i < dimList.length; i++) {
      var dim = dimList[i];
      var axis = this._axes[dim];
      output[dim] = axis[method](input[dim]);
    }

    return output;
  }
};
var _default = Cartesian;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Cartesian = __webpack_require__("./node_modules/echarts/lib/coord/cartesian/Cartesian.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function Cartesian2D(name) {
  Cartesian.call(this, name);
}

Cartesian2D.prototype = {
  constructor: Cartesian2D,
  type: 'cartesian2d',

  /**
   * @type {Array.<string>}
   * @readOnly
   */
  dimensions: ['x', 'y'],

  /**
   * Base axis will be used on stacking.
   *
   * @return {module:echarts/coord/cartesian/Axis2D}
   */
  getBaseAxis: function () {
    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
  },

  /**
   * If contain point
   * @param {Array.<number>} point
   * @return {boolean}
   */
  containPoint: function (point) {
    var axisX = this.getAxis('x');
    var axisY = this.getAxis('y');
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  },

  /**
   * If contain data
   * @param {Array.<number>} data
   * @return {boolean}
   */
  containData: function (data) {
    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
  },

  /**
   * @param {Array.<number>} data
   * @param {Array.<number>} out
   * @return {Array.<number>}
   */
  dataToPoint: function (data, reserved, out) {
    var xAxis = this.getAxis('x');
    var yAxis = this.getAxis('y');
    out = out || [];
    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));
    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));
    return out;
  },

  /**
   * @param {Array.<number>} data
   * @param {Array.<number>} out
   * @return {Array.<number>}
   */
  clampData: function (data, out) {
    var xScale = this.getAxis('x').scale;
    var yScale = this.getAxis('y').scale;
    var xAxisExtent = xScale.getExtent();
    var yAxisExtent = yScale.getExtent();
    var x = xScale.parse(data[0]);
    var y = yScale.parse(data[1]);
    out = out || [];
    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out;
  },

  /**
   * @param {Array.<number>} point
   * @param {Array.<number>} out
   * @return {Array.<number>}
   */
  pointToData: function (point, out) {
    var xAxis = this.getAxis('x');
    var yAxis = this.getAxis('y');
    out = out || [];
    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));
    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));
    return out;
  },

  /**
   * Get other axis
   * @param {module:echarts/coord/cartesian/Axis2D} axis
   */
  getOtherAxis: function (axis) {
    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
  }
};
zrUtil.inherits(Cartesian2D, Cartesian);
var _default = Cartesian2D;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Grid.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var isObject = _util.isObject;
var each = _util.each;
var map = _util.map;
var indexOf = _util.indexOf;
var retrieve = _util.retrieve;

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutRect = _layout.getLayoutRect;

var _axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

var createScaleByModel = _axisHelper.createScaleByModel;
var ifAxisCrossZero = _axisHelper.ifAxisCrossZero;
var niceScaleExtent = _axisHelper.niceScaleExtent;
var estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;

var Cartesian2D = __webpack_require__("./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js");

var Axis2D = __webpack_require__("./node_modules/echarts/lib/coord/cartesian/Axis2D.js");

var CoordinateSystem = __webpack_require__("./node_modules/echarts/lib/CoordinateSystem.js");

var _dataStackHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/dataStackHelper.js");

var getStackedDimension = _dataStackHelper.getStackedDimension;

__webpack_require__("./node_modules/echarts/lib/coord/cartesian/GridModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Grid is a region which contains at most 4 cartesian systems
 *
 * TODO Default cartesian
 */
// Depends on GridModel, AxisModel, which performs preprocess.

/**
 * Check if the axis is used in the specified grid
 * @inner
 */
function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
  return axisModel.getCoordSysModel() === gridModel;
}

function Grid(gridModel, ecModel, api) {
  /**
   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
   * @private
   */
  this._coordsMap = {};
  /**
   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
   * @private
   */

  this._coordsList = [];
  /**
   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}
   * @private
   */

  this._axesMap = {};
  /**
   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
   * @private
   */

  this._axesList = [];

  this._initCartesian(gridModel, ecModel, api);

  this.model = gridModel;
}

var gridProto = Grid.prototype;
gridProto.type = 'grid';
gridProto.axisPointerEnabled = true;

gridProto.getRect = function () {
  return this._rect;
};

gridProto.update = function (ecModel, api) {
  var axesMap = this._axesMap;

  this._updateScale(ecModel, this.model);

  each(axesMap.x, function (xAxis) {
    niceScaleExtent(xAxis.scale, xAxis.model);
  });
  each(axesMap.y, function (yAxis) {
    niceScaleExtent(yAxis.scale, yAxis.model);
  });
  each(axesMap.x, function (xAxis) {
    fixAxisOnZero(axesMap, 'y', xAxis);
  });
  each(axesMap.y, function (yAxis) {
    fixAxisOnZero(axesMap, 'x', yAxis);
  }); // Resize again if containLabel is enabled
  // FIXME It may cause getting wrong grid size in data processing stage

  this.resize(this.model, api);
};

function fixAxisOnZero(axesMap, otherAxisDim, axis) {
  axis.getAxesOnZeroOf = function () {
    // TODO: onZero of multiple axes.
    return otherAxis ? [otherAxis] : [];
  }; // onZero can not be enabled in these two situations:
  // 1. When any other axis is a category axis.
  // 2. When no axis is cross 0 point.


  var otherAxes = axesMap[otherAxisDim];
  var otherAxis;
  var axisModel = axis.model;
  var onZero = axisModel.get('axisLine.onZero');
  var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');

  if (!onZero) {
    return;
  } // If target axis is specified.


  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxis = otherAxes[onZeroAxisIndex];
    }

    return;
  } // Find the first available other axis.


  for (var idx in otherAxes) {
    if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])) {
      otherAxis = otherAxes[idx];
      break;
    }
  }
}

function canOnZeroToAxis(axis) {
  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);
}
/**
 * Resize the grid
 * @param {module:echarts/coord/cartesian/GridModel} gridModel
 * @param {module:echarts/ExtensionAPI} api
 */


gridProto.resize = function (gridModel, api, ignoreContainLabel) {
  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
  this._rect = gridRect;
  var axesList = this._axesList;
  adjustAxes(); // Minus label size

  if (!ignoreContainLabel && gridModel.get('containLabel')) {
    each(axesList, function (axis) {
      if (!axis.model.get('axisLabel.inside')) {
        var labelUnionRect = estimateLabelUnionRect(axis);

        if (labelUnionRect) {
          var dim = axis.isHorizontal() ? 'height' : 'width';
          var margin = axis.model.get('axisLabel.margin');
          gridRect[dim] -= labelUnionRect[dim] + margin;

          if (axis.position === 'top') {
            gridRect.y += labelUnionRect.height + margin;
          } else if (axis.position === 'left') {
            gridRect.x += labelUnionRect.width + margin;
          }
        }
      }
    });
    adjustAxes();
  }

  function adjustAxes() {
    each(axesList, function (axis) {
      var isHorizontal = axis.isHorizontal();
      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
      var idx = axis.inverse ? 1 : 0;
      axis.setExtent(extent[idx], extent[1 - idx]);
      updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
    });
  }
};
/**
 * @param {string} axisType
 * @param {number} [axisIndex]
 */


gridProto.getAxis = function (axisType, axisIndex) {
  var axesMapOnDim = this._axesMap[axisType];

  if (axesMapOnDim != null) {
    if (axisIndex == null) {
      // Find first axis
      for (var name in axesMapOnDim) {
        if (axesMapOnDim.hasOwnProperty(name)) {
          return axesMapOnDim[name];
        }
      }
    }

    return axesMapOnDim[axisIndex];
  }
};
/**
 * @return {Array.<module:echarts/coord/Axis>}
 */


gridProto.getAxes = function () {
  return this._axesList.slice();
};
/**
 * Usage:
 *      grid.getCartesian(xAxisIndex, yAxisIndex);
 *      grid.getCartesian(xAxisIndex);
 *      grid.getCartesian(null, yAxisIndex);
 *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});
 *
 * @param {number|Object} [xAxisIndex]
 * @param {number} [yAxisIndex]
 */


gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {
  if (xAxisIndex != null && yAxisIndex != null) {
    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
    return this._coordsMap[key];
  }

  if (isObject(xAxisIndex)) {
    yAxisIndex = xAxisIndex.yAxisIndex;
    xAxisIndex = xAxisIndex.xAxisIndex;
  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.


  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
      return coordList[i];
    }
  }
};

gridProto.getCartesians = function () {
  return this._coordsList.slice();
};
/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */


gridProto.convertToPixel = function (ecModel, finder, value) {
  var target = this._findConvertTarget(ecModel, finder);

  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
};
/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */


gridProto.convertFromPixel = function (ecModel, finder, value) {
  var target = this._findConvertTarget(ecModel, finder);

  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
};
/**
 * @inner
 */


gridProto._findConvertTarget = function (ecModel, finder) {
  var seriesModel = finder.seriesModel;
  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];
  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];
  var gridModel = finder.gridModel;
  var coordsList = this._coordsList;
  var cartesian;
  var axis;

  if (seriesModel) {
    cartesian = seriesModel.coordinateSystem;
    indexOf(coordsList, cartesian) < 0 && (cartesian = null);
  } else if (xAxisModel && yAxisModel) {
    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
  } else if (xAxisModel) {
    axis = this.getAxis('x', xAxisModel.componentIndex);
  } else if (yAxisModel) {
    axis = this.getAxis('y', yAxisModel.componentIndex);
  } // Lowest priority.
  else if (gridModel) {
      var grid = gridModel.coordinateSystem;

      if (grid === this) {
        cartesian = this._coordsList[0];
      }
    }

  return {
    cartesian: cartesian,
    axis: axis
  };
};
/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */


gridProto.containPoint = function (point) {
  var coord = this._coordsList[0];

  if (coord) {
    return coord.containPoint(point);
  }
};
/**
 * Initialize cartesian coordinate systems
 * @private
 */


gridProto._initCartesian = function (gridModel, ecModel, api) {
  var axisPositionUsed = {
    left: false,
    right: false,
    top: false,
    bottom: false
  };
  var axesMap = {
    x: {},
    y: {}
  };
  var axesCount = {
    x: 0,
    y: 0
  }; /// Create axis

  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);

  if (!axesCount.x || !axesCount.y) {
    // Roll back when there no either x or y axis
    this._axesMap = {};
    this._axesList = [];
    return;
  }

  this._axesMap = axesMap; /// Create cartesian2d

  each(axesMap.x, function (xAxis, xAxisIndex) {
    each(axesMap.y, function (yAxis, yAxisIndex) {
      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
      var cartesian = new Cartesian2D(key);
      cartesian.grid = this;
      cartesian.model = gridModel;
      this._coordsMap[key] = cartesian;

      this._coordsList.push(cartesian);

      cartesian.addAxis(xAxis);
      cartesian.addAxis(yAxis);
    }, this);
  }, this);

  function createAxisCreator(axisType) {
    return function (axisModel, idx) {
      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
        return;
      }

      var axisPosition = axisModel.get('position');

      if (axisType === 'x') {
        // Fix position
        if (axisPosition !== 'top' && axisPosition !== 'bottom') {
          // Default bottom of X
          axisPosition = 'bottom';

          if (axisPositionUsed[axisPosition]) {
            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';
          }
        }
      } else {
        // Fix position
        if (axisPosition !== 'left' && axisPosition !== 'right') {
          // Default left of Y
          axisPosition = 'left';

          if (axisPositionUsed[axisPosition]) {
            axisPosition = axisPosition === 'left' ? 'right' : 'left';
          }
        }
      }

      axisPositionUsed[axisPosition] = true;
      var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);
      var isCategory = axis.type === 'category';
      axis.onBand = isCategory && axisModel.get('boundaryGap');
      axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel

      axisModel.axis = axis; // Inject axisModel into axis

      axis.model = axisModel; // Inject grid info axis

      axis.grid = this; // Index of axis, can be used as key

      axis.index = idx;

      this._axesList.push(axis);

      axesMap[axisType][idx] = axis;
      axesCount[axisType]++;
    };
  }
};
/**
 * Update cartesian properties from series
 * @param  {module:echarts/model/Option} option
 * @private
 */


gridProto._updateScale = function (ecModel, gridModel) {
  // Reset scale
  each(this._axesList, function (axis) {
    axis.scale.setExtent(Infinity, -Infinity);
  });
  ecModel.eachSeries(function (seriesModel) {
    if (isCartesian2D(seriesModel)) {
      var axesModels = findAxesModels(seriesModel, ecModel);
      var xAxisModel = axesModels[0];
      var yAxisModel = axesModels[1];

      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {
        return;
      }

      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      var data = seriesModel.getData();
      var xAxis = cartesian.getAxis('x');
      var yAxis = cartesian.getAxis('y');

      if (data.type === 'list') {
        unionExtent(data, xAxis, seriesModel);
        unionExtent(data, yAxis, seriesModel);
      }
    }
  }, this);

  function unionExtent(data, axis, seriesModel) {
    each(data.mapDimension(axis.dim, true), function (dim) {
      axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension
      // is [0.1, 0.5], the extent of the `stackResultDimension`
      // is [7, 9], the final extent should not include [0.1, 0.5].
      data, getStackedDimension(data, dim));
    });
  }
};
/**
 * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined
 * @return {Object} {baseAxes: [], otherAxes: []}
 */


gridProto.getTooltipAxes = function (dim) {
  var baseAxes = [];
  var otherAxes = [];
  each(this.getCartesians(), function (cartesian) {
    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
    var otherAxis = cartesian.getOtherAxis(baseAxis);
    indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
    indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
  });
  return {
    baseAxes: baseAxes,
    otherAxes: otherAxes
  };
};
/**
 * @inner
 */


function updateAxisTransform(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform

  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
    return coord + coordBase;
  } : function (coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
    return coord - coordBase;
  } : function (coord) {
    return axisExtentSum - coord + coordBase;
  };
}

var axesTypes = ['xAxis', 'yAxis'];
/**
 * @inner
 */

function findAxesModels(seriesModel, ecModel) {
  return map(axesTypes, function (axisType) {
    var axisModel = seriesModel.getReferringComponents(axisType)[0];
    return axisModel;
  });
}
/**
 * @inner
 */


function isCartesian2D(seriesModel) {
  return seriesModel.get('coordinateSystem') === 'cartesian2d';
}

Grid.create = function (ecModel, api) {
  var grids = [];
  ecModel.eachComponent('grid', function (gridModel, idx) {
    var grid = new Grid(gridModel, ecModel, api);
    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize
    // should be performed in create stage.

    grid.resize(gridModel, api, true);
    gridModel.coordinateSystem = grid;
    grids.push(grid);
  }); // Inject the coordinateSystems into seriesModel

  ecModel.eachSeries(function (seriesModel) {
    if (!isCartesian2D(seriesModel)) {
      return;
    }

    var axesModels = findAxesModels(seriesModel, ecModel);
    var xAxisModel = axesModels[0];
    var yAxisModel = axesModels[1];
    var gridModel = xAxisModel.getCoordSysModel();
    var grid = gridModel.coordinateSystem;
    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
  });
  return grids;
}; // For deciding which dimensions to use when creating list data


Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;
CoordinateSystem.register('cartesian2d', Grid);
var _default = Grid;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/GridModel.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/echarts/lib/coord/cartesian/AxisModel.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Grid 是在有直角坐标系的时候必须要存在的
// 所以这里也要被 Cartesian2D 依赖
var _default = ComponentModel.extend({
  type: 'grid',
  dependencies: ['xAxis', 'yAxis'],
  layoutMode: 'box',

  /**
   * @type {module:echarts/coord/cartesian/Grid}
   */
  coordinateSystem: null,
  defaultOption: {
    show: false,
    zlevel: 0,
    z: 0,
    left: '10%',
    top: 60,
    right: '10%',
    bottom: 60,
    // If grid size contain label
    containLabel: false,
    // width: {totalWidth} - left - right,
    // height: {totalHeight} - top - bottom,
    backgroundColor: 'rgba(0,0,0,0)',
    borderWidth: 1,
    borderColor: '#ccc'
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Can only be called after coordinate system creation stage.
 * (Can be called before coordinate system update stage).
 *
 * @param {Object} opt {labelInside}
 * @return {Object} {
 *  position, rotation, labelDirection, labelOffset,
 *  tickDirection, labelRotate, z2
 * }
 */
function layout(gridModel, axisModel, opt) {
  opt = opt || {};
  var grid = gridModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout = {};
  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
  var rawAxisPosition = axis.position;
  var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;
  var axisDim = axis.dim;
  var rect = grid.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var idx = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  };
  var axisOffset = axisModel.get('offset') || 0;
  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];

  if (otherAxisOnZeroOf) {
    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
    posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  } // Axis position


  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation

  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim

  var dirMap = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
  layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;

  if (axisModel.get('axisTick.inside')) {
    layout.tickDirection = -layout.tickDirection;
  }

  if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {
    layout.labelDirection = -layout.labelDirection;
  } // Special label rotation


  var labelRotate = axisModel.get('axisLabel.rotate');
  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // Over splitLine and splitArea

  layout.z2 = 1;
  return layout;
}

exports.layout = layout;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/Region.js":
/***/ (function(module, exports, __webpack_require__) {

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var bbox = __webpack_require__("./node_modules/zrender/lib/core/bbox.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var polygonContain = __webpack_require__("./node_modules/zrender/lib/contain/polygon.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @module echarts/coord/geo/Region
 */

/**
 * @param {string} name
 * @param {Array} geometries
 * @param {Array.<number>} cp
 */
function Region(name, geometries, cp) {
  /**
   * @type {string}
   * @readOnly
   */
  this.name = name;
  /**
   * @type {Array.<Array>}
   * @readOnly
   */

  this.geometries = geometries;

  if (!cp) {
    var rect = this.getBoundingRect();
    cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  } else {
    cp = [cp[0], cp[1]];
  }
  /**
   * @type {Array.<number>}
   */


  this.center = cp;
}

Region.prototype = {
  constructor: Region,
  properties: null,

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function () {
    var rect = this._rect;

    if (rect) {
      return rect;
    }

    var MAX_NUMBER = Number.MAX_VALUE;
    var min = [MAX_NUMBER, MAX_NUMBER];
    var max = [-MAX_NUMBER, -MAX_NUMBER];
    var min2 = [];
    var max2 = [];
    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      // Only support polygon
      if (geometries[i].type !== 'polygon') {
        continue;
      } // Doesn't consider hole


      var exterior = geometries[i].exterior;
      bbox.fromPoints(exterior, min2, max2);
      vec2.min(min, min, min2);
      vec2.max(max, max, max2);
    } // No data


    if (i === 0) {
      min[0] = min[1] = max[0] = max[1] = 0;
    }

    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
  },

  /**
   * @param {<Array.<number>} coord
   * @return {boolean}
   */
  contain: function (coord) {
    var rect = this.getBoundingRect();
    var geometries = this.geometries;

    if (!rect.contain(coord[0], coord[1])) {
      return false;
    }

    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {
      // Only support polygon.
      if (geometries[i].type !== 'polygon') {
        continue;
      }

      var exterior = geometries[i].exterior;
      var interiors = geometries[i].interiors;

      if (polygonContain.contain(exterior, coord[0], coord[1])) {
        // Not in the region if point is in the hole.
        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
          if (polygonContain.contain(interiors[k])) {
            continue loopGeo;
          }
        }

        return true;
      }
    }

    return false;
  },
  transformTo: function (x, y, width, height) {
    var rect = this.getBoundingRect();
    var aspect = rect.width / rect.height;

    if (!width) {
      width = aspect * height;
    } else if (!height) {
      height = width / aspect;
    }

    var target = new BoundingRect(x, y, width, height);
    var transform = rect.calculateTransform(target);
    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      // Only support polygon.
      if (geometries[i].type !== 'polygon') {
        continue;
      }

      var exterior = geometries[i].exterior;
      var interiors = geometries[i].interiors;

      for (var p = 0; p < exterior.length; p++) {
        vec2.applyTransform(exterior[p], exterior[p], transform);
      }

      for (var h = 0; h < (interiors ? interiors.length : 0); h++) {
        for (var p = 0; p < interiors[h].length; p++) {
          vec2.applyTransform(interiors[h][p], interiors[h][p], transform);
        }
      }
    }

    rect = this._rect;
    rect.copy(target); // Update center

    this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }
};
var _default = Region;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/parseGeoJson.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Region = __webpack_require__("./node_modules/echarts/lib/coord/geo/Region.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Parse and decode geo json
 * @module echarts/coord/geo/parseGeoJson
 */
function decode(json) {
  if (!json.UTF8Encoding) {
    return json;
  }

  var encodeScale = json.UTF8Scale;

  if (encodeScale == null) {
    encodeScale = 1024;
  }

  var features = json.features;

  for (var f = 0; f < features.length; f++) {
    var feature = features[f];
    var geometry = feature.geometry;
    var coordinates = geometry.coordinates;
    var encodeOffsets = geometry.encodeOffsets;

    for (var c = 0; c < coordinates.length; c++) {
      var coordinate = coordinates[c];

      if (geometry.type === 'Polygon') {
        coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);
      } else if (geometry.type === 'MultiPolygon') {
        for (var c2 = 0; c2 < coordinate.length; c2++) {
          var polygon = coordinate[c2];
          coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);
        }
      }
    }
  } // Has been decoded


  json.UTF8Encoding = false;
  return json;
}

function decodePolygon(coordinate, encodeOffsets, encodeScale) {
  var result = [];
  var prevX = encodeOffsets[0];
  var prevY = encodeOffsets[1];

  for (var i = 0; i < coordinate.length; i += 2) {
    var x = coordinate.charCodeAt(i) - 64;
    var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding

    x = x >> 1 ^ -(x & 1);
    y = y >> 1 ^ -(y & 1); // Delta deocding

    x += prevX;
    y += prevY;
    prevX = x;
    prevY = y; // Dequantize

    result.push([x / encodeScale, y / encodeScale]);
  }

  return result;
}
/**
 * @alias module:echarts/coord/geo/parseGeoJson
 * @param {Object} geoJson
 * @return {module:zrender/container/Group}
 */


function _default(geoJson) {
  decode(geoJson);
  return zrUtil.map(zrUtil.filter(geoJson.features, function (featureObj) {
    // Output of mapshaper may have geometry null
    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
  }), function (featureObj) {
    var properties = featureObj.properties;
    var geo = featureObj.geometry;
    var coordinates = geo.coordinates;
    var geometries = [];

    if (geo.type === 'Polygon') {
      geometries.push({
        type: 'polygon',
        // According to the GeoJSON specification.
        // First must be exterior, and the rest are all interior(holes).
        exterior: coordinates[0],
        interiors: coordinates.slice(1)
      });
    }

    if (geo.type === 'MultiPolygon') {
      zrUtil.each(coordinates, function (item) {
        if (item[0]) {
          geometries.push({
            type: 'polygon',
            exterior: item[0],
            interiors: item.slice(1)
          });
        }
      });
    }

    var region = new Region(properties.name, geometries, properties.cp);
    region.properties = properties;
    return region;
  });
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/data/DataDiffer.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function defaultKeyGetter(item) {
  return item;
}
/**
 * @param {Array} oldArr
 * @param {Array} newArr
 * @param {Function} oldKeyGetter
 * @param {Function} newKeyGetter
 * @param {Object} [context] Can be visited by this.context in callback.
 */


function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {
  this._old = oldArr;
  this._new = newArr;
  this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
  this._newKeyGetter = newKeyGetter || defaultKeyGetter;
  this.context = context;
}

DataDiffer.prototype = {
  constructor: DataDiffer,

  /**
   * Callback function when add a data
   */
  add: function (func) {
    this._add = func;
    return this;
  },

  /**
   * Callback function when update a data
   */
  update: function (func) {
    this._update = func;
    return this;
  },

  /**
   * Callback function when remove a data
   */
  remove: function (func) {
    this._remove = func;
    return this;
  },
  execute: function () {
    var oldArr = this._old;
    var newArr = this._new;
    var oldDataIndexMap = {};
    var newDataIndexMap = {};
    var oldDataKeyArr = [];
    var newDataKeyArr = [];
    var i;
    initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);
    initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this); // Travel by inverted order to make sure order consistency
    // when duplicate keys exists (consider newDataIndex.pop() below).
    // For performance consideration, these code below do not look neat.

    for (i = 0; i < oldArr.length; i++) {
      var key = oldDataKeyArr[i];
      var idx = newDataIndexMap[key]; // idx can never be empty array here. see 'set null' logic below.

      if (idx != null) {
        // Consider there is duplicate key (for example, use dataItem.name as key).
        // We should make sure every item in newArr and oldArr can be visited.
        var len = idx.length;

        if (len) {
          len === 1 && (newDataIndexMap[key] = null);
          idx = idx.unshift();
        } else {
          newDataIndexMap[key] = null;
        }

        this._update && this._update(idx, i);
      } else {
        this._remove && this._remove(i);
      }
    }

    for (var i = 0; i < newDataKeyArr.length; i++) {
      var key = newDataKeyArr[i];

      if (newDataIndexMap.hasOwnProperty(key)) {
        var idx = newDataIndexMap[key];

        if (idx == null) {
          continue;
        } // idx can never be empty array here. see 'set null' logic above.


        if (!idx.length) {
          this._add && this._add(idx);
        } else {
          for (var j = 0, len = idx.length; j < len; j++) {
            this._add && this._add(idx[j]);
          }
        }
      }
    }
  }
};

function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {
  for (var i = 0; i < arr.length; i++) {
    // Add prefix to avoid conflict with Object.prototype.
    var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);
    var existence = map[key];

    if (existence == null) {
      keyArr.push(key);
      map[key] = i;
    } else {
      if (!existence.length) {
        map[key] = existence = [existence];
      }

      existence.push(i);
    }
  }
}

var _default = DataDiffer;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/data/List.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var DataDiffer = __webpack_require__("./node_modules/echarts/lib/data/DataDiffer.js");

var Source = __webpack_require__("./node_modules/echarts/lib/data/Source.js");

var _dataProvider = __webpack_require__("./node_modules/echarts/lib/data/helper/dataProvider.js");

var defaultDimValueGetters = _dataProvider.defaultDimValueGetters;
var DefaultDataProvider = _dataProvider.DefaultDataProvider;

var _dimensionHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/dimensionHelper.js");

var summarizeDimensions = _dimensionHelper.summarizeDimensions;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * List for data storage
 * @module echarts/data/List
 */
var isObject = zrUtil.isObject;
var UNDEFINED = 'undefined'; // Use prefix to avoid index to be the same as otherIdList[idx],
// which will cause weird udpate animation.

var ID_PREFIX = 'e\0\0';
var dataCtors = {
  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,
  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,
  // Ordinal data type can be string or int
  'ordinal': Array,
  'number': Array,
  'time': Array
}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is
// different from the Ctor of typed array.

var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;

function getIndicesCtor(list) {
  // The possible max value in this._indicies is always this._rawCount despite of filtering.
  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}

function cloneChunk(originalChunk) {
  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.

  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}

var TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];
var CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];

function transferProperties(target, source) {
  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {
    if (source.hasOwnProperty(propName)) {
      target[propName] = source[propName];
    }
  });
  target.__wrappedMethods = source.__wrappedMethods;
  zrUtil.each(CLONE_PROPERTIES, function (propName) {
    target[propName] = zrUtil.clone(source[propName]);
  });
  target._calculationInfo = zrUtil.extend(source._calculationInfo);
}
/**
 * @constructor
 * @alias module:echarts/data/List
 *
 * @param {Array.<string|Object>} dimensions
 *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
 *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
 *      Spetial fields: {
 *          ordinalMeta: <module:echarts/data/OrdinalMeta>
 *          createInvertedIndices: <boolean>
 *      }
 * @param {module:echarts/model/Model} hostModel
 */


var List = function (dimensions, hostModel) {
  dimensions = dimensions || ['x', 'y'];
  var dimensionInfos = {};
  var dimensionNames = [];
  var invertedIndicesMap = {};

  for (var i = 0; i < dimensions.length; i++) {
    // Use the original dimensions[i], where other flag props may exists.
    var dimensionInfo = dimensions[i];

    if (zrUtil.isString(dimensionInfo)) {
      dimensionInfo = {
        name: dimensionInfo
      };
    }

    var dimensionName = dimensionInfo.name;
    dimensionInfo.type = dimensionInfo.type || 'float';

    if (!dimensionInfo.coordDim) {
      dimensionInfo.coordDim = dimensionName;
      dimensionInfo.coordDimIndex = 0;
    }

    dimensionInfo.otherDims = dimensionInfo.otherDims || {};
    dimensionNames.push(dimensionName);
    dimensionInfos[dimensionName] = dimensionInfo;
    dimensionInfo.index = i;

    if (dimensionInfo.createInvertedIndices) {
      invertedIndicesMap[dimensionName] = [];
    }
  }
  /**
   * @readOnly
   * @type {Array.<string>}
   */


  this.dimensions = dimensionNames;
  /**
   * Infomation of each data dimension, like data type.
   * @type {Object}
   */

  this._dimensionInfos = dimensionInfos;
  /**
   * @type {module:echarts/model/Model}
   */

  this.hostModel = hostModel;
  /**
   * @type {module:echarts/model/Model}
   */

  this.dataType;
  /**
   * Indices stores the indices of data subset after filtered.
   * This data subset will be used in chart.
   * @type {Array.<number>}
   * @readOnly
   */

  this._indices = null;
  this._count = 0;
  this._rawCount = 0;
  /**
   * Data storage
   * @type {Object.<key, Array.<TypedArray|Array>>}
   * @private
   */

  this._storage = {};
  /**
   * @type {Array.<string>}
   */

  this._nameList = [];
  /**
   * @type {Array.<string>}
   */

  this._idList = [];
  /**
   * Models of data option is stored sparse for optimizing memory cost
   * @type {Array.<module:echarts/model/Model>}
   * @private
   */

  this._optionModels = [];
  /**
   * Global visual properties after visual coding
   * @type {Object}
   * @private
   */

  this._visual = {};
  /**
   * Globel layout properties.
   * @type {Object}
   * @private
   */

  this._layout = {};
  /**
   * Item visual properties after visual coding
   * @type {Array.<Object>}
   * @private
   */

  this._itemVisuals = [];
  /**
   * Key: visual type, Value: boolean
   * @type {Object}
   * @readOnly
   */

  this.hasItemVisual = {};
  /**
   * Item layout properties after layout
   * @type {Array.<Object>}
   * @private
   */

  this._itemLayouts = [];
  /**
   * Graphic elemnents
   * @type {Array.<module:zrender/Element>}
   * @private
   */

  this._graphicEls = [];
  /**
   * Max size of each chunk.
   * @type {number}
   * @private
   */

  this._chunkSize = 1e5;
  /**
   * @type {number}
   * @private
   */

  this._chunkCount = 0;
  /**
   * @type {Array.<Array|Object>}
   * @private
   */

  this._rawData;
  /**
   * Raw extent will not be cloned, but only transfered.
   * It will not be calculated util needed.
   * key: dim,
   * value: {end: number, extent: Array.<number>}
   * @type {Object}
   * @private
   */

  this._rawExtent = {};
  /**
   * @type {Object}
   * @private
   */

  this._extent = {};
  /**
   * key: dim
   * value: extent
   * @type {Object}
   * @private
   */

  this._approximateExtent = {};
  /**
   * Cache summary info for fast visit. See "dimensionHelper".
   * @type {Object}
   * @private
   */

  this._dimensionsSummary = summarizeDimensions(this);
  /**
   * @type {Object.<Array|TypedArray>}
   * @private
   */

  this._invertedIndicesMap = invertedIndicesMap;
  /**
   * @type {Object}
   * @private
   */

  this._calculationInfo = {};
};

var listProto = List.prototype;
listProto.type = 'list';
/**
 * If each data item has it's own option
 * @type {boolean}
 */

listProto.hasItemOption = true;
/**
 * Get dimension name
 * @param {string|number} dim
 *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
 *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
 * @return {string} Concrete dim name.
 */

listProto.getDimension = function (dim) {
  if (!isNaN(dim)) {
    dim = this.dimensions[dim] || dim;
  }

  return dim;
};
/**
 * Get type and calculation info of particular dimension
 * @param {string|number} dim
 *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
 *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
 */


listProto.getDimensionInfo = function (dim) {
  // Do not clone, because there may be categories in dimInfo.
  return this._dimensionInfos[this.getDimension(dim)];
};
/**
 * @return {Array.<string>} concrete dimension name list on coord.
 */


listProto.getDimensionsOnCoord = function () {
  return this._dimensionsSummary.dataDimsOnCoord.slice();
};
/**
 * @param {string} coordDim
 * @param {number} [idx] A coordDim may map to more than one data dim.
 *        If idx is `true`, return a array of all mapped dims.
 *        If idx is not specified, return the first dim not extra.
 * @return {string|Array.<string>} concrete data dim.
 *        If idx is number, and not found, return null/undefined.
 *        If idx is `true`, and not found, return empty array (always return array).
 */


listProto.mapDimension = function (coordDim, idx) {
  var dimensionsSummary = this._dimensionsSummary;

  if (idx == null) {
    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
  }

  var dims = dimensionsSummary.encode[coordDim];
  return idx === true // always return array if idx is `true`
  ? (dims || []).slice() : dims && dims[idx];
};
/**
 * Initialize from data
 * @param {Array.<Object|number|Array>} data source or data or data provider.
 * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and
 *        defualt label/tooltip.
 *        A name can be specified in encode.itemName,
 *        or dataItem.name (only for series option data),
 *        or provided in nameList from outside.
 * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number
 */


listProto.initData = function (data, nameList, dimValueGetter) {
  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);

  if (notProvider) {
    data = new DefaultDataProvider(data, this.dimensions.length);
  }

  this._rawData = data; // Clear

  this._storage = {};
  this._indices = null;
  this._nameList = nameList || [];
  this._idList = [];
  this._nameRepeatCount = {};

  if (!dimValueGetter) {
    this.hasItemOption = false;
  }
  /**
   * @readOnly
   */


  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter

  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter; // Reset raw extent.

  this._rawExtent = {};

  this._initDataFromProvider(0, data.count()); // If data has no item option.


  if (data.pure) {
    this.hasItemOption = false;
  }
};

listProto.getProvider = function () {
  return this._rawData;
};

listProto.appendData = function (data) {
  var rawData = this._rawData;
  var start = this.count();
  rawData.appendData(data);
  var end = rawData.count();

  if (!rawData.persistent) {
    end += start;
  }

  this._initDataFromProvider(start, end);
};

listProto._initDataFromProvider = function (start, end) {
  // Optimize.
  if (start >= end) {
    return;
  }

  var chunkSize = this._chunkSize;
  var rawData = this._rawData;
  var storage = this._storage;
  var dimensions = this.dimensions;
  var dimLen = dimensions.length;
  var dimensionInfoMap = this._dimensionInfos;
  var nameList = this._nameList;
  var idList = this._idList;
  var rawExtent = this._rawExtent;
  var nameRepeatCount = this._nameRepeatCount = {};
  var nameDimIdx;
  var chunkCount = this._chunkCount;
  var lastChunkIndex = chunkCount - 1;

  for (var i = 0; i < dimLen; i++) {
    var dim = dimensions[i];

    if (!rawExtent[dim]) {
      rawExtent[dim] = getInitialExtent();
    }

    var dimInfo = dimensionInfoMap[dim];

    if (dimInfo.otherDims.itemName === 0) {
      nameDimIdx = this._nameDimIdx = i;
    }

    if (dimInfo.otherDims.itemId === 0) {
      this._idDimIdx = i;
    }

    var DataCtor = dataCtors[dimInfo.type];

    if (!storage[dim]) {
      storage[dim] = [];
    }

    var resizeChunkArray = storage[dim][lastChunkIndex];

    if (resizeChunkArray && resizeChunkArray.length < chunkSize) {
      var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable
      // within the initial chunkSize.

      for (var j = 0; j < resizeChunkArray.length; j++) {
        newStore[j] = resizeChunkArray[j];
      }

      storage[dim][lastChunkIndex] = newStore;
    } // Create new chunks.


    for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {
      storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));
    }

    this._chunkCount = storage[dim].length;
  }

  var dataItem = new Array(dimLen);

  for (var idx = start; idx < end; idx++) {
    // NOTICE: Try not to write things into dataItem
    dataItem = rawData.getItem(idx, dataItem); // Each data item is value
    // [1, 2]
    // 2
    // Bar chart, line chart which uses category axis
    // only gives the 'y' value. 'x' value is the indices of category
    // Use a tempValue to normalize the value to be a (x, y) value

    var chunkIndex = Math.floor(idx / chunkSize);
    var chunkOffset = idx % chunkSize; // Store the data by dimensions

    for (var k = 0; k < dimLen; k++) {
      var dim = dimensions[k];
      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero

      var val = this._dimValueGetter(dataItem, dim, idx, k);

      dimStorage[chunkOffset] = val;
      var dimRawExtent = rawExtent[dim];

      if (val < dimRawExtent[0]) {
        dimRawExtent[0] = val;
      }

      if (val > dimRawExtent[1]) {
        dimRawExtent[1] = val;
      }
    } // ??? FIXME not check by pure but sourceFormat?
    // TODO refactor these logic.


    if (!rawData.pure) {
      var name = nameList[idx];

      if (dataItem && name == null) {
        // If dataItem is {name: ...}, it has highest priority.
        // That is appropriate for many common cases.
        if (dataItem.name != null) {
          // There is no other place to persistent dataItem.name,
          // so save it to nameList.
          nameList[idx] = name = dataItem.name;
        } else if (nameDimIdx != null) {
          var nameDim = dimensions[nameDimIdx];
          var nameDimChunk = storage[nameDim][chunkIndex];

          if (nameDimChunk) {
            name = nameDimChunk[chunkOffset];
            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;

            if (ordinalMeta && ordinalMeta.categories.length) {
              name = ordinalMeta.categories[name];
            }
          }
        }
      } // Try using the id in option
      // id or name is used on dynamical data, mapping old and new items.


      var id = dataItem == null ? null : dataItem.id;

      if (id == null && name != null) {
        // Use name as id and add counter to avoid same name
        nameRepeatCount[name] = nameRepeatCount[name] || 0;
        id = name;

        if (nameRepeatCount[name] > 0) {
          id += '__ec__' + nameRepeatCount[name];
        }

        nameRepeatCount[name]++;
      }

      id != null && (idList[idx] = id);
    }
  }

  if (!rawData.persistent && rawData.clean) {
    // Clean unused data if data source is typed array.
    rawData.clean();
  }

  this._rawCount = this._count = end; // Reset data extent

  this._extent = {};
  prepareInvertedIndex(this);
};

function prepareInvertedIndex(list) {
  var invertedIndicesMap = list._invertedIndicesMap;
  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {
    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.

    var ordinalMeta = dimInfo.ordinalMeta;

    if (ordinalMeta) {
      invertedIndices = invertedIndicesMap[dim] = new CtorUint32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss
      // mapping to 0, we should set it as NaN.

      for (var i = 0; i < invertedIndices.length; i++) {
        invertedIndices[i] = NaN;
      }

      for (var i = 0; i < list._count; i++) {
        // Only support the case that all values are distinct.
        invertedIndices[list.get(dim, i)] = i;
      }
    }
  });
}

function getRawValueFromStore(list, dimIndex, rawIndex) {
  var val;

  if (dimIndex != null) {
    var chunkSize = list._chunkSize;
    var chunkIndex = Math.floor(rawIndex / chunkSize);
    var chunkOffset = rawIndex % chunkSize;
    var dim = list.dimensions[dimIndex];
    var chunk = list._storage[dim][chunkIndex];

    if (chunk) {
      val = chunk[chunkOffset];
      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;

      if (ordinalMeta && ordinalMeta.categories.length) {
        val = ordinalMeta.categories[val];
      }
    }
  }

  return val;
}
/**
 * @return {number}
 */


listProto.count = function () {
  return this._count;
};

listProto.getIndices = function () {
  var newIndices;
  var indices = this._indices;

  if (indices) {
    var Ctor = indices.constructor;
    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.

    if (Ctor === Array) {
      newIndices = new Ctor(thisCount);

      for (var i = 0; i < thisCount; i++) {
        newIndices[i] = indices[i];
      }
    } else {
      newIndices = new Ctor(indices.buffer, 0, thisCount);
    }
  } else {
    var Ctor = getIndicesCtor(this);
    var newIndices = new Ctor(this.count());

    for (var i = 0; i < newIndices.length; i++) {
      newIndices[i] = i;
    }
  }

  return newIndices;
};
/**
 * Get value. Return NaN if idx is out of range.
 * @param {string} dim Dim must be concrete name.
 * @param {number} idx
 * @param {boolean} stack
 * @return {number}
 */


listProto.get = function (dim, idx
/*, stack */
) {
  if (!(idx >= 0 && idx < this._count)) {
    return NaN;
  }

  var storage = this._storage;

  if (!storage[dim]) {
    // TODO Warn ?
    return NaN;
  }

  idx = this.getRawIndex(idx);
  var chunkIndex = Math.floor(idx / this._chunkSize);
  var chunkOffset = idx % this._chunkSize;
  var chunkStore = storage[dim][chunkIndex];
  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable
  // if (stack) {
  //     var dimensionInfo = this._dimensionInfos[dim];
  //     if (dimensionInfo && dimensionInfo.stackable) {
  //         var stackedOn = this.stackedOn;
  //         while (stackedOn) {
  //             // Get no stacked data of stacked on
  //             var stackedValue = stackedOn.get(dim, idx);
  //             // Considering positive stack, negative stack and empty data
  //             if ((value >= 0 && stackedValue > 0)  // Positive stack
  //                 || (value <= 0 && stackedValue < 0) // Negative stack
  //             ) {
  //                 value += stackedValue;
  //             }
  //             stackedOn = stackedOn.stackedOn;
  //         }
  //     }
  // }

  return value;
};
/**
 * @param {string} dim concrete dim
 * @param {number} rawIndex
 * @return {number|string}
 */


listProto.getByRawIndex = function (dim, rawIdx) {
  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
    return NaN;
  }

  var dimStore = this._storage[dim];

  if (!dimStore) {
    // TODO Warn ?
    return NaN;
  }

  var chunkIndex = Math.floor(rawIdx / this._chunkSize);
  var chunkOffset = rawIdx % this._chunkSize;
  var chunkStore = dimStore[chunkIndex];
  return chunkStore[chunkOffset];
};
/**
 * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).
 * Hack a much simpler _getFast
 * @private
 */


listProto._getFast = function (dim, rawIdx) {
  var chunkIndex = Math.floor(rawIdx / this._chunkSize);
  var chunkOffset = rawIdx % this._chunkSize;
  var chunkStore = this._storage[dim][chunkIndex];
  return chunkStore[chunkOffset];
};
/**
 * Get value for multi dimensions.
 * @param {Array.<string>} [dimensions] If ignored, using all dimensions.
 * @param {number} idx
 * @return {number}
 */


listProto.getValues = function (dimensions, idx
/*, stack */
) {
  var values = [];

  if (!zrUtil.isArray(dimensions)) {
    // stack = idx;
    idx = dimensions;
    dimensions = this.dimensions;
  }

  for (var i = 0, len = dimensions.length; i < len; i++) {
    values.push(this.get(dimensions[i], idx
    /*, stack */
    ));
  }

  return values;
};
/**
 * If value is NaN. Inlcuding '-'
 * Only check the coord dimensions.
 * @param {string} dim
 * @param {number} idx
 * @return {number}
 */


listProto.hasValue = function (idx) {
  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;
  var dimensionInfos = this._dimensionInfos;

  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {
    if ( // Ordinal type can be string or number
    dimensionInfos[dataDimsOnCoord[i]].type !== 'ordinal' // FIXME check ordinal when using index?
    && isNaN(this.get(dataDimsOnCoord[i], idx))) {
      return false;
    }
  }

  return true;
};
/**
 * Get extent of data in one dimension
 * @param {string} dim
 * @param {boolean} stack
 */


listProto.getDataExtent = function (dim
/*, stack */
) {
  // Make sure use concrete dim as cache name.
  dim = this.getDimension(dim);
  var dimData = this._storage[dim];
  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));

  if (!dimData) {
    return initialExtent;
  } // Make more strict checkings to ensure hitting cache.


  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');
  // var cacheName = dim;
  // Consider the most cases when using data zoom, `getDataExtent`
  // happened before filtering. We cache raw extent, which is not
  // necessary to be cleared and recalculated when restore data.

  var useRaw = !this._indices; // && !stack;

  var dimExtent;

  if (useRaw) {
    return this._rawExtent[dim].slice();
  }

  dimExtent = this._extent[dim];

  if (dimExtent) {
    return dimExtent.slice();
  }

  dimExtent = initialExtent;
  var min = dimExtent[0];
  var max = dimExtent[1];

  for (var i = 0; i < currEnd; i++) {
    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));
    var value = this._getFast(dim, this.getRawIndex(i));

    value < min && (min = value);
    value > max && (max = value);
  }

  dimExtent = [min, max];
  this._extent[dim] = dimExtent;
  return dimExtent;
};
/**
 * Optimize for the scenario that data is filtered by a given extent.
 * Consider that if data amount is more than hundreds of thousand,
 * extent calculation will cost more than 10ms and the cache will
 * be erased because of the filtering.
 */


listProto.getApproximateExtent = function (dim
/*, stack */
) {
  dim = this.getDimension(dim);
  return this._approximateExtent[dim] || this.getDataExtent(dim
  /*, stack */
  );
};

listProto.setApproximateExtent = function (extent, dim
/*, stack */
) {
  dim = this.getDimension(dim);
  this._approximateExtent[dim] = extent.slice();
};
/**
 * @param {string} key
 * @return {*}
 */


listProto.getCalculationInfo = function (key) {
  return this._calculationInfo[key];
};
/**
 * @param {string|Object} key or k-v object
 * @param {*} [value]
 */


listProto.setCalculationInfo = function (key, value) {
  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
};
/**
 * Get sum of data in one dimension
 * @param {string} dim
 */


listProto.getSum = function (dim
/*, stack */
) {
  var dimData = this._storage[dim];
  var sum = 0;

  if (dimData) {
    for (var i = 0, len = this.count(); i < len; i++) {
      var value = this.get(dim, i
      /*, stack */
      );

      if (!isNaN(value)) {
        sum += value;
      }
    }
  }

  return sum;
};
/**
 * Get median of data in one dimension
 * @param {string} dim
 */


listProto.getMedian = function (dim
/*, stack */
) {
  var dimDataArray = []; // map all data of one dimension

  this.each(dim, function (val, idx) {
    if (!isNaN(val)) {
      dimDataArray.push(val);
    }
  }); // TODO
  // Use quick select?
  // immutability & sort

  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {
    return a - b;
  });
  var len = this.count(); // calculate median

  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;
}; // /**
//  * Retreive the index with given value
//  * @param {string} dim Concrete dimension.
//  * @param {number} value
//  * @return {number}
//  */
// Currently incorrect: should return dataIndex but not rawIndex.
// Do not fix it until this method is to be used somewhere.
// FIXME Precision of float value
// listProto.indexOf = function (dim, value) {
//     var storage = this._storage;
//     var dimData = storage[dim];
//     var chunkSize = this._chunkSize;
//     if (dimData) {
//         for (var i = 0, len = this.count(); i < len; i++) {
//             var chunkIndex = Math.floor(i / chunkSize);
//             var chunkOffset = i % chunkSize;
//             if (dimData[chunkIndex][chunkOffset] === value) {
//                 return i;
//             }
//         }
//     }
//     return -1;
// };

/**
 * Only support the dimension which inverted index created.
 * Do not support other cases until required.
 * @param {string} concrete dim
 * @param {number|string} value
 * @return {number} rawIndex
 */


listProto.rawIndexOf = function (dim, value) {
  var invertedIndices = dim && this._invertedIndicesMap[dim];
  var rawIndex = invertedIndices[value];

  if (rawIndex == null || isNaN(rawIndex)) {
    return -1;
  }

  return rawIndex;
};
/**
 * Retreive the index with given name
 * @param {number} idx
 * @param {number} name
 * @return {number}
 */


listProto.indexOfName = function (name) {
  for (var i = 0, len = this.count(); i < len; i++) {
    if (this.getName(i) === name) {
      return i;
    }
  }

  return -1;
};
/**
 * Retreive the index with given raw data index
 * @param {number} idx
 * @param {number} name
 * @return {number}
 */


listProto.indexOfRawIndex = function (rawIndex) {
  if (!this._indices) {
    return rawIndex;
  }

  if (rawIndex >= this._rawCount || rawIndex < 0) {
    return -1;
  } // Indices are ascending


  var indices = this._indices; // If rawIndex === dataIndex

  var rawDataIndex = indices[rawIndex];

  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
    return rawIndex;
  }

  var left = 0;
  var right = this._count - 1;

  while (left <= right) {
    var mid = (left + right) / 2 | 0;

    if (indices[mid] < rawIndex) {
      left = mid + 1;
    } else if (indices[mid] > rawIndex) {
      right = mid - 1;
    } else {
      return mid;
    }
  }

  return -1;
};
/**
 * Retreive the index of nearest value
 * @param {string} dim
 * @param {number} value
 * @param {number} [maxDistance=Infinity]
 * @return {Array.<number>} Considere multiple points has the same value.
 */


listProto.indicesOfNearest = function (dim, value, maxDistance) {
  var storage = this._storage;
  var dimData = storage[dim];
  var nearestIndices = [];

  if (!dimData) {
    return nearestIndices;
  }

  if (maxDistance == null) {
    maxDistance = Infinity;
  }

  var minDist = Number.MAX_VALUE;
  var minDiff = -1;

  for (var i = 0, len = this.count(); i < len; i++) {
    var diff = value - this.get(dim, i
    /*, stack */
    );
    var dist = Math.abs(diff);

    if (diff <= maxDistance && dist <= minDist) {
      // For the case of two data are same on xAxis, which has sequence data.
      // Show the nearest index
      // https://github.com/ecomfe/echarts/issues/2869
      if (dist < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist;
        minDiff = diff;
        nearestIndices.length = 0;
      }

      nearestIndices.push(i);
    }
  }

  return nearestIndices;
};
/**
 * Get raw data index
 * @param {number} idx
 * @return {number}
 */


listProto.getRawIndex = getRawIndexWithoutIndices;

function getRawIndexWithoutIndices(idx) {
  return idx;
}

function getRawIndexWithIndices(idx) {
  if (idx < this._count && idx >= 0) {
    return this._indices[idx];
  }

  return -1;
}
/**
 * Get raw data item
 * @param {number} idx
 * @return {number}
 */


listProto.getRawDataItem = function (idx) {
  if (!this._rawData.persistent) {
    var val = [];

    for (var i = 0; i < this.dimensions.length; i++) {
      var dim = this.dimensions[i];
      val.push(this.get(dim, idx));
    }

    return val;
  } else {
    return this._rawData.getItem(this.getRawIndex(idx));
  }
};
/**
 * @param {number} idx
 * @param {boolean} [notDefaultIdx=false]
 * @return {string}
 */


listProto.getName = function (idx) {
  var rawIndex = this.getRawIndex(idx);
  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';
};
/**
 * @param {number} idx
 * @param {boolean} [notDefaultIdx=false]
 * @return {string}
 */


listProto.getId = function (idx) {
  return getId(this, this.getRawIndex(idx));
};

function getId(list, rawIndex) {
  var id = list._idList[rawIndex];

  if (id == null) {
    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);
  }

  if (id == null) {
    // FIXME Check the usage in graph, should not use prefix.
    id = ID_PREFIX + rawIndex;
  }

  return id;
}

function normalizeDimensions(dimensions) {
  if (!zrUtil.isArray(dimensions)) {
    dimensions = [dimensions];
  }

  return dimensions;
}

function validateDimensions(list, dims) {
  for (var i = 0; i < dims.length; i++) {
    // stroage may be empty when no data, so use
    // dimensionInfos to check.
    if (!list._dimensionInfos[dims[i]]) {
      console.error('Unkown dimension ' + dims[i]);
    }
  }
}
/**
 * Data iteration
 * @param {string|Array.<string>}
 * @param {Function} cb
 * @param {*} [context=this]
 *
 * @example
 *  list.each('x', function (x, idx) {});
 *  list.each(['x', 'y'], function (x, y, idx) {});
 *  list.each(function (idx) {})
 */


listProto.each = function (dims, cb, context, contextCompat) {
  'use strict';

  if (!this._count) {
    return;
  }

  if (typeof dims === 'function') {
    contextCompat = context;
    context = cb;
    cb = dims;
    dims = [];
  } // contextCompat just for compat echarts3


  context = context || contextCompat || this;
  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);
  var dimSize = dims.length;

  for (var i = 0; i < this.count(); i++) {
    // Simple optimization
    switch (dimSize) {
      case 0:
        cb.call(context, i);
        break;

      case 1:
        cb.call(context, this.get(dims[0], i), i);
        break;

      case 2:
        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);
        break;

      default:
        var k = 0;
        var value = [];

        for (; k < dimSize; k++) {
          value[k] = this.get(dims[k], i);
        } // Index


        value[k] = i;
        cb.apply(context, value);
    }
  }
};
/**
 * Data filter
 * @param {string|Array.<string>}
 * @param {Function} cb
 * @param {*} [context=this]
 */


listProto.filterSelf = function (dimensions, cb, context, contextCompat) {
  'use strict';

  if (!this._count) {
    return;
  }

  if (typeof dimensions === 'function') {
    contextCompat = context;
    context = cb;
    cb = dimensions;
    dimensions = [];
  } // contextCompat just for compat echarts3


  context = context || contextCompat || this;
  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
  var count = this.count();
  var Ctor = getIndicesCtor(this);
  var newIndices = new Ctor(count);
  var value = [];
  var dimSize = dimensions.length;
  var offset = 0;
  var dim0 = dimensions[0];

  for (var i = 0; i < count; i++) {
    var keep;
    var rawIdx = this.getRawIndex(i); // Simple optimization

    if (dimSize === 0) {
      keep = cb.call(context, i);
    } else if (dimSize === 1) {
      var val = this._getFast(dim0, rawIdx);

      keep = cb.call(context, val, i);
    } else {
      for (var k = 0; k < dimSize; k++) {
        value[k] = this._getFast(dim0, rawIdx);
      }

      value[k] = i;
      keep = cb.apply(context, value);
    }

    if (keep) {
      newIndices[offset++] = rawIdx;
    }
  } // Set indices after filtered.


  if (offset < count) {
    this._indices = newIndices;
  }

  this._count = offset; // Reset data extent

  this._extent = {};
  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
  return this;
};
/**
 * Select data in range. (For optimization of filter)
 * (Manually inline code, support 5 million data filtering in data zoom.)
 */


listProto.selectRange = function (range) {
  'use strict';

  if (!this._count) {
    return;
  }

  var dimensions = [];

  for (var dim in range) {
    if (range.hasOwnProperty(dim)) {
      dimensions.push(dim);
    }
  }

  var dimSize = dimensions.length;

  if (!dimSize) {
    return;
  }

  var originalCount = this.count();
  var Ctor = getIndicesCtor(this);
  var newIndices = new Ctor(originalCount);
  var offset = 0;
  var dim0 = dimensions[0];
  var min = range[dim0][0];
  var max = range[dim0][1];
  var quickFinished = false;

  if (!this._indices) {
    // Extreme optimization for common case. About 2x faster in chrome.
    var idx = 0;

    if (dimSize === 1) {
      var dimStorage = this._storage[dimensions[0]];

      for (var k = 0; k < this._chunkCount; k++) {
        var chunkStorage = dimStorage[k];
        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);

        for (var i = 0; i < len; i++) {
          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty
          // value indicates the line should be broken. But for the case like
          // scatter plot, a data item with empty value will not be rendered,
          // but the axis extent may be effected if some other dim of the data
          // item has value. Fortunately it is not a significant negative effect.

          if (val >= min && val <= max || isNaN(val)) {
            newIndices[offset++] = idx;
          }

          idx++;
        }
      }

      quickFinished = true;
    } else if (dimSize === 2) {
      var dimStorage = this._storage[dim0];
      var dimStorage2 = this._storage[dimensions[1]];
      var min2 = range[dimensions[1]][0];
      var max2 = range[dimensions[1]][1];

      for (var k = 0; k < this._chunkCount; k++) {
        var chunkStorage = dimStorage[k];
        var chunkStorage2 = dimStorage2[k];
        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);

        for (var i = 0; i < len; i++) {
          var val = chunkStorage[i];
          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.

          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {
            newIndices[offset++] = idx;
          }

          idx++;
        }
      }

      quickFinished = true;
    }
  }

  if (!quickFinished) {
    if (dimSize === 1) {
      for (var i = 0; i < originalCount; i++) {
        var rawIndex = this.getRawIndex(i);

        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.


        if (val >= min && val <= max || isNaN(val)) {
          newIndices[offset++] = rawIndex;
        }
      }
    } else {
      for (var i = 0; i < originalCount; i++) {
        var keep = true;
        var rawIndex = this.getRawIndex(i);

        for (var k = 0; k < dimSize; k++) {
          var dimk = dimensions[k];

          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.


          if (val < range[dimk][0] || val > range[dimk][1]) {
            keep = false;
          }
        }

        if (keep) {
          newIndices[offset++] = this.getRawIndex(i);
        }
      }
    }
  } // Set indices after filtered.


  if (offset < originalCount) {
    this._indices = newIndices;
  }

  this._count = offset; // Reset data extent

  this._extent = {};
  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
  return this;
};
/**
 * Data mapping to a plain array
 * @param {string|Array.<string>} [dimensions]
 * @param {Function} cb
 * @param {*} [context=this]
 * @return {Array}
 */


listProto.mapArray = function (dimensions, cb, context, contextCompat) {
  'use strict';

  if (typeof dimensions === 'function') {
    contextCompat = context;
    context = cb;
    cb = dimensions;
    dimensions = [];
  } // contextCompat just for compat echarts3


  context = context || contextCompat || this;
  var result = [];
  this.each(dimensions, function () {
    result.push(cb && cb.apply(this, arguments));
  }, context);
  return result;
}; // Data in excludeDimensions is copied, otherwise transfered.


function cloneListForMapAndSample(original, excludeDimensions) {
  var allDimensions = original.dimensions;
  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked

  transferProperties(list, original);
  var storage = list._storage = {};
  var originalStorage = original._storage; // Init storage

  for (var i = 0; i < allDimensions.length; i++) {
    var dim = allDimensions[i];

    if (originalStorage[dim]) {
      // Notice that we do not reset invertedIndicesMap here, becuase
      // there is no scenario of mapping or sampling ordinal dimension.
      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {
        storage[dim] = cloneDimStore(originalStorage[dim]);
        list._rawExtent[dim] = getInitialExtent();
        list._extent[dim] = null;
      } else {
        // Direct reference for other dimensions
        storage[dim] = originalStorage[dim];
      }
    }
  }

  return list;
}

function cloneDimStore(originalDimStore) {
  var newDimStore = new Array(originalDimStore.length);

  for (var j = 0; j < originalDimStore.length; j++) {
    newDimStore[j] = cloneChunk(originalDimStore[j]);
  }

  return newDimStore;
}

function getInitialExtent() {
  return [Infinity, -Infinity];
}
/**
 * Data mapping to a new List with given dimensions
 * @param {string|Array.<string>} dimensions
 * @param {Function} cb
 * @param {*} [context=this]
 * @return {Array}
 */


listProto.map = function (dimensions, cb, context, contextCompat) {
  'use strict'; // contextCompat just for compat echarts3

  context = context || contextCompat || this;
  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.
  // So we can reference to the same value

  list._indices = this._indices;
  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
  var storage = list._storage;
  var tmpRetValue = [];
  var chunkSize = this._chunkSize;
  var dimSize = dimensions.length;
  var dataCount = this.count();
  var values = [];
  var rawExtent = list._rawExtent;

  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {
      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex
      /*, stack */
      );
    }

    values[dimSize] = dataIndex;
    var retValue = cb && cb.apply(context, values);

    if (retValue != null) {
      // a number or string (in oridinal dimension)?
      if (typeof retValue !== 'object') {
        tmpRetValue[0] = retValue;
        retValue = tmpRetValue;
      }

      var rawIndex = this.getRawIndex(dataIndex);
      var chunkIndex = Math.floor(rawIndex / chunkSize);
      var chunkOffset = rawIndex % chunkSize;

      for (var i = 0; i < retValue.length; i++) {
        var dim = dimensions[i];
        var val = retValue[i];
        var rawExtentOnDim = rawExtent[dim];
        var dimStore = storage[dim];

        if (dimStore) {
          dimStore[chunkIndex][chunkOffset] = val;
        }

        if (val < rawExtentOnDim[0]) {
          rawExtentOnDim[0] = val;
        }

        if (val > rawExtentOnDim[1]) {
          rawExtentOnDim[1] = val;
        }
      }
    }
  }

  return list;
};
/**
 * Large data down sampling on given dimension
 * @param {string} dimension
 * @param {number} rate
 * @param {Function} sampleValue
 * @param {Function} sampleIndex Sample index for name and id
 */


listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {
  var list = cloneListForMapAndSample(this, [dimension]);
  var targetStorage = list._storage;
  var frameValues = [];
  var frameSize = Math.floor(1 / rate);
  var dimStore = targetStorage[dimension];
  var len = this.count();
  var chunkSize = this._chunkSize;
  var rawExtentOnDim = list._rawExtent[dimension];
  var newIndices = new (getIndicesCtor(this))(len);
  var offset = 0;

  for (var i = 0; i < len; i += frameSize) {
    // Last frame
    if (frameSize > len - i) {
      frameSize = len - i;
      frameValues.length = frameSize;
    }

    for (var k = 0; k < frameSize; k++) {
      var dataIdx = this.getRawIndex(i + k);
      var originalChunkIndex = Math.floor(dataIdx / chunkSize);
      var originalChunkOffset = dataIdx % chunkSize;
      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];
    }

    var value = sampleValue(frameValues);
    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));
    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);
    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data

    dimStore[sampleChunkIndex][sampleChunkOffset] = value;

    if (value < rawExtentOnDim[0]) {
      rawExtentOnDim[0] = value;
    }

    if (value > rawExtentOnDim[1]) {
      rawExtentOnDim[1] = value;
    }

    newIndices[offset++] = sampleFrameIdx;
  }

  list._count = offset;
  list._indices = newIndices;
  list.getRawIndex = getRawIndexWithIndices;
  return list;
};
/**
 * Get model of one data item.
 *
 * @param {number} idx
 */
// FIXME Model proxy ?


listProto.getItemModel = function (idx) {
  var hostModel = this.hostModel;
  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);
};
/**
 * Create a data differ
 * @param {module:echarts/data/List} otherList
 * @return {module:echarts/data/DataDiffer}
 */


listProto.diff = function (otherList) {
  var thisList = this;
  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {
    return getId(otherList, idx);
  }, function (idx) {
    return getId(thisList, idx);
  });
};
/**
 * Get visual property.
 * @param {string} key
 */


listProto.getVisual = function (key) {
  var visual = this._visual;
  return visual && visual[key];
};
/**
 * Set visual property
 * @param {string|Object} key
 * @param {*} [value]
 *
 * @example
 *  setVisual('color', color);
 *  setVisual({
 *      'color': color
 *  });
 */


listProto.setVisual = function (key, val) {
  if (isObject(key)) {
    for (var name in key) {
      if (key.hasOwnProperty(name)) {
        this.setVisual(name, key[name]);
      }
    }

    return;
  }

  this._visual = this._visual || {};
  this._visual[key] = val;
};
/**
 * Set layout property.
 * @param {string|Object} key
 * @param {*} [val]
 */


listProto.setLayout = function (key, val) {
  if (isObject(key)) {
    for (var name in key) {
      if (key.hasOwnProperty(name)) {
        this.setLayout(name, key[name]);
      }
    }

    return;
  }

  this._layout[key] = val;
};
/**
 * Get layout property.
 * @param  {string} key.
 * @return {*}
 */


listProto.getLayout = function (key) {
  return this._layout[key];
};
/**
 * Get layout of single data item
 * @param {number} idx
 */


listProto.getItemLayout = function (idx) {
  return this._itemLayouts[idx];
};
/**
 * Set layout of single data item
 * @param {number} idx
 * @param {Object} layout
 * @param {boolean=} [merge=false]
 */


listProto.setItemLayout = function (idx, layout, merge) {
  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;
};
/**
 * Clear all layout of single data item
 */


listProto.clearItemLayouts = function () {
  this._itemLayouts.length = 0;
};
/**
 * Get visual property of single data item
 * @param {number} idx
 * @param {string} key
 * @param {boolean} [ignoreParent=false]
 */


listProto.getItemVisual = function (idx, key, ignoreParent) {
  var itemVisual = this._itemVisuals[idx];
  var val = itemVisual && itemVisual[key];

  if (val == null && !ignoreParent) {
    // Use global visual property
    return this.getVisual(key);
  }

  return val;
};
/**
 * Set visual property of single data item
 *
 * @param {number} idx
 * @param {string|Object} key
 * @param {*} [value]
 *
 * @example
 *  setItemVisual(0, 'color', color);
 *  setItemVisual(0, {
 *      'color': color
 *  });
 */


listProto.setItemVisual = function (idx, key, value) {
  var itemVisual = this._itemVisuals[idx] || {};
  var hasItemVisual = this.hasItemVisual;
  this._itemVisuals[idx] = itemVisual;

  if (isObject(key)) {
    for (var name in key) {
      if (key.hasOwnProperty(name)) {
        itemVisual[name] = key[name];
        hasItemVisual[name] = true;
      }
    }

    return;
  }

  itemVisual[key] = value;
  hasItemVisual[key] = true;
};
/**
 * Clear itemVisuals and list visual.
 */


listProto.clearAllVisual = function () {
  this._visual = {};
  this._itemVisuals = [];
  this.hasItemVisual = {};
};

var setItemDataAndSeriesIndex = function (child) {
  child.seriesIndex = this.seriesIndex;
  child.dataIndex = this.dataIndex;
  child.dataType = this.dataType;
};
/**
 * Set graphic element relative to data. It can be set as null
 * @param {number} idx
 * @param {module:zrender/Element} [el]
 */


listProto.setItemGraphicEl = function (idx, el) {
  var hostModel = this.hostModel;

  if (el) {
    // Add data index and series index for indexing the data by element
    // Useful in tooltip
    el.dataIndex = idx;
    el.dataType = this.dataType;
    el.seriesIndex = hostModel && hostModel.seriesIndex;

    if (el.type === 'group') {
      el.traverse(setItemDataAndSeriesIndex, el);
    }
  }

  this._graphicEls[idx] = el;
};
/**
 * @param {number} idx
 * @return {module:zrender/Element}
 */


listProto.getItemGraphicEl = function (idx) {
  return this._graphicEls[idx];
};
/**
 * @param {Function} cb
 * @param {*} context
 */


listProto.eachItemGraphicEl = function (cb, context) {
  zrUtil.each(this._graphicEls, function (el, idx) {
    if (el) {
      cb && cb.call(context, el, idx);
    }
  });
};
/**
 * Shallow clone a new list except visual and layout properties, and graph elements.
 * New list only change the indices.
 */


listProto.cloneShallow = function (list) {
  if (!list) {
    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);
    list = new List(dimensionInfoList, this.hostModel);
  } // FIXME


  list._storage = this._storage;
  transferProperties(list, this); // Clone will not change the data extent and indices

  if (this._indices) {
    var Ctor = this._indices.constructor;
    list._indices = new Ctor(this._indices);
  } else {
    list._indices = null;
  }

  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
  return list;
};
/**
 * Wrap some method to add more feature
 * @param {string} methodName
 * @param {Function} injectFunction
 */


listProto.wrapMethod = function (methodName, injectFunction) {
  var originalMethod = this[methodName];

  if (typeof originalMethod !== 'function') {
    return;
  }

  this.__wrappedMethods = this.__wrappedMethods || [];

  this.__wrappedMethods.push(methodName);

  this[methodName] = function () {
    var res = originalMethod.apply(this, arguments);
    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));
  };
}; // Methods that create a new list based on this list should be listed here.
// Notice that those method should `RETURN` the new list.


listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.

listProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];
var _default = List;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/data/OrdinalMeta.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var createHashMap = _util.createHashMap;
var isObject = _util.isObject;
var map = _util.map;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @constructor
 * @param {Object} [opt]
 * @param {Object} [opt.categories=[]]
 * @param {Object} [opt.needCollect=false]
 * @param {Object} [opt.deduplication=false]
 */
function OrdinalMeta(opt) {
  /**
   * @readOnly
   * @type {Array.<string>}
   */
  this.categories = opt.categories || [];
  /**
   * @private
   * @type {boolean}
   */

  this._needCollect = opt.needCollect;
  /**
   * @private
   * @type {boolean}
   */

  this._deduplication = opt.deduplication;
  /**
   * @private
   * @type {boolean}
   */

  this._map;
}
/**
 * @param {module:echarts/model/Model} axisModel
 * @return {module:echarts/data/OrdinalMeta}
 */


OrdinalMeta.createByAxisModel = function (axisModel) {
  var option = axisModel.option;
  var data = option.data;
  var categories = data && map(data, getName);
  return new OrdinalMeta({
    categories: categories,
    needCollect: !categories,
    // deduplication is default in axis.
    deduplication: option.dedplication !== false
  });
};

var proto = OrdinalMeta.prototype;
/**
 * @param {string} category
 * @return {number} ordinal
 */

proto.getOrdinal = function (category) {
  return getOrCreateMap(this).get(category);
};
/**
 * @param {*} category
 * @return {number} The ordinal. If not found, return NaN.
 */


proto.parseAndCollect = function (category) {
  var index;
  var needCollect = this._needCollect; // The value of category dim can be the index of the given category set.
  // This feature is only supported when !needCollect, because we should
  // consider a common case: a value is 2017, which is a number but is
  // expected to be tread as a category. This case usually happen in dataset,
  // where it happent to be no need of the index feature.

  if (typeof category !== 'string' && !needCollect) {
    return category;
  } // Optimize for the scenario:
  // category is ['2012-01-01', '2012-01-02', ...], where the input
  // data has been ensured not duplicate and is large data.
  // Notice, if a dataset dimension provide categroies, usually echarts
  // should remove duplication except user tell echarts dont do that
  // (set axis.deduplication = false), because echarts do not know whether
  // the values in the category dimension has duplication (consider the
  // parallel-aqi example)


  if (needCollect && !this._deduplication) {
    index = this.categories.length;
    this.categories[index] = category;
    return index;
  }

  var map = getOrCreateMap(this);
  index = map.get(category);

  if (index == null) {
    if (needCollect) {
      index = this.categories.length;
      this.categories[index] = category;
      map.set(category, index);
    } else {
      index = NaN;
    }
  }

  return index;
}; // Consider big data, do not create map until needed.


function getOrCreateMap(ordinalMeta) {
  return ordinalMeta._map || (ordinalMeta._map = createHashMap(ordinalMeta.categories));
}

function getName(obj) {
  if (isObject(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + '';
  }
}

var _default = OrdinalMeta;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/data/Source.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var createHashMap = _util.createHashMap;
var isTypedArray = _util.isTypedArray;

var _clazz = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var enableClassCheck = _clazz.enableClassCheck;

var _sourceType = __webpack_require__("./node_modules/echarts/lib/data/helper/sourceType.js");

var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
var SERIES_LAYOUT_BY_COLUMN = _sourceType.SERIES_LAYOUT_BY_COLUMN;
var SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;
var SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;
var SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * [sourceFormat]
 *
 * + "original":
 * This format is only used in series.data, where
 * itemStyle can be specified in data item.
 *
 * + "arrayRows":
 * [
 *     ['product', 'score', 'amount'],
 *     ['Matcha Latte', 89.3, 95.8],
 *     ['Milk Tea', 92.1, 89.4],
 *     ['Cheese Cocoa', 94.4, 91.2],
 *     ['Walnut Brownie', 85.4, 76.9]
 * ]
 *
 * + "objectRows":
 * [
 *     {product: 'Matcha Latte', score: 89.3, amount: 95.8},
 *     {product: 'Milk Tea', score: 92.1, amount: 89.4},
 *     {product: 'Cheese Cocoa', score: 94.4, amount: 91.2},
 *     {product: 'Walnut Brownie', score: 85.4, amount: 76.9}
 * ]
 *
 * + "keyedColumns":
 * {
 *     'product': ['Matcha Latte', 'Milk Tea', 'Cheese Cocoa', 'Walnut Brownie'],
 *     'count': [823, 235, 1042, 988],
 *     'score': [95.8, 81.4, 91.2, 76.9]
 * }
 *
 * + "typedArray"
 *
 * + "unknown"
 */

/**
 * @constructor
 * @param {Object} fields
 * @param {string} fields.sourceFormat
 * @param {Array|Object} fields.fromDataset
 * @param {Array|Object} [fields.data]
 * @param {string} [seriesLayoutBy='column']
 * @param {Array.<Object|string>} [dimensionsDefine]
 * @param {Objet|HashMap} [encodeDefine]
 * @param {number} [startIndex=0]
 * @param {number} [dimensionsDetectCount]
 */
function Source(fields) {
  /**
   * @type {boolean}
   */
  this.fromDataset = fields.fromDataset;
  /**
   * Not null/undefined.
   * @type {Array|Object}
   */

  this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
  /**
   * See also "detectSourceFormat".
   * Not null/undefined.
   * @type {string}
   */

  this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
  /**
   * 'row' or 'column'
   * Not null/undefined.
   * @type {string} seriesLayoutBy
   */

  this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
  /**
   * dimensions definition in option.
   * can be null/undefined.
   * @type {Array.<Object|string>}
   */

  this.dimensionsDefine = fields.dimensionsDefine;
  /**
   * encode definition in option.
   * can be null/undefined.
   * @type {Objet|HashMap}
   */

  this.encodeDefine = fields.encodeDefine && createHashMap(fields.encodeDefine);
  /**
   * Not null/undefined, uint.
   * @type {number}
   */

  this.startIndex = fields.startIndex || 0;
  /**
   * Can be null/undefined (when unknown), uint.
   * @type {number}
   */

  this.dimensionsDetectCount = fields.dimensionsDetectCount;
}
/**
 * Wrap original series data for some compatibility cases.
 */


Source.seriesDataToSource = function (data) {
  return new Source({
    data: data,
    sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL,
    fromDataset: false
  });
};

enableClassCheck(Source);
var _default = Source;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/data/helper/completeDimensions.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var createHashMap = _util.createHashMap;
var each = _util.each;
var isString = _util.isString;
var defaults = _util.defaults;
var extend = _util.extend;
var isObject = _util.isObject;
var clone = _util.clone;

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var normalizeToArray = _model.normalizeToArray;

var _sourceHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/sourceHelper.js");

var guessOrdinal = _sourceHelper.guessOrdinal;

var Source = __webpack_require__("./node_modules/echarts/lib/data/Source.js");

var _dimensionHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/dimensionHelper.js");

var OTHER_DIMENSIONS = _dimensionHelper.OTHER_DIMENSIONS;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @deprecated
 * Use `echarts/data/helper/createDimensions` instead.
 */

/**
 * @see {module:echarts/test/ut/spec/data/completeDimensions}
 *
 * Complete the dimensions array, by user defined `dimension` and `encode`,
 * and guessing from the data structure.
 * If no 'value' dimension specified, the first no-named dimension will be
 * named as 'value'.
 *
 * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which
 *      provides not only dim template, but also default order.
 *      properties: 'name', 'type', 'displayName'.
 *      `name` of each item provides default coord name.
 *      [{dimsDef: [string|Object, ...]}, ...] dimsDef of sysDim item provides default dim name, and
 *                                    provide dims count that the sysDim required.
 *      [{ordinalMeta}] can be specified.
 * @param {module:echarts/data/Source|Array|Object} source or data (for compatibal with pervious)
 * @param {Object} [opt]
 * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions
 *      For example: ['asdf', {name, type}, ...].
 * @param {Object|HashMap} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}
 * @param {string} [opt.generateCoord] Generate coord dim with the given name.
 *                 If not specified, extra dim names will be:
 *                 'value', 'value0', 'value1', ...
 * @param {number} [opt.generateCoordCount] By default, the generated dim name is `generateCoord`.
 *                 If `generateCoordCount` specified, the generated dim names will be:
 *                 `generateCoord` + 0, `generateCoord` + 1, ...
 *                 can be Infinity, indicate that use all of the remain columns.
 * @param {number} [opt.dimCount] If not specified, guess by the first data item.
 * @param {number} [opt.encodeDefaulter] If not specified, auto find the next available data dim.
 * @return {Array.<Object>} [{
 *      name: string mandatory,
 *      displayName: string, the origin name in dimsDef, see source helper.
 *                 If displayName given, the tooltip will displayed vertically.
 *      coordDim: string mandatory,
 *      coordDimIndex: number mandatory,
 *      type: string optional,
 *      otherDims: { never null/undefined
 *          tooltip: number optional,
 *          label: number optional,
 *          itemName: number optional,
 *          seriesName: number optional,
 *      },
 *      isExtraCoord: boolean true if coord is generated
 *          (not specified in encode and not series specified)
 *      other props ...
 * }]
 */
function completeDimensions(sysDims, source, opt) {
  if (!Source.isInstance(source)) {
    source = Source.seriesDataToSource(source);
  }

  opt = opt || {};
  sysDims = (sysDims || []).slice();
  var dimsDef = (opt.dimsDef || []).slice();
  var encodeDef = createHashMap(opt.encodeDef);
  var dataDimNameMap = createHashMap();
  var coordDimNameMap = createHashMap(); // var valueCandidate;

  var result = [];
  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimCount); // Apply user defined dims (`name` and `type`) and init result.

  for (var i = 0; i < dimCount; i++) {
    var dimDefItem = dimsDef[i] = extend({}, isObject(dimsDef[i]) ? dimsDef[i] : {
      name: dimsDef[i]
    });
    var userDimName = dimDefItem.name;
    var resultItem = result[i] = {
      otherDims: {}
    }; // Name will be applied later for avoiding duplication.

    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      // Only if `series.dimensions` is defined in option
      // displayName, will be set, and dimension will be diplayed vertically in
      // tooltip by default.
      resultItem.name = resultItem.displayName = userDimName;
      dataDimNameMap.set(userDimName, i);
    }

    dimDefItem.type != null && (resultItem.type = dimDefItem.type);
    dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);
  } // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.


  encodeDef.each(function (dataDims, coordDim) {
    dataDims = normalizeToArray(dataDims).slice();
    var validDataDims = encodeDef.set(coordDim, []);
    each(dataDims, function (resultDimIdx, idx) {
      // The input resultDimIdx can be dim name or index.
      isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));

      if (resultDimIdx != null && resultDimIdx < dimCount) {
        validDataDims[idx] = resultDimIdx;
        applyDim(result[resultDimIdx], coordDim, idx);
      }
    });
  }); // Apply templetes and default order from `sysDims`.

  var availDimIdx = 0;
  each(sysDims, function (sysDimItem, sysDimIndex) {
    var coordDim;
    var sysDimItem;
    var sysDimItemDimsDef;
    var sysDimItemOtherDims;

    if (isString(sysDimItem)) {
      coordDim = sysDimItem;
      sysDimItem = {};
    } else {
      coordDim = sysDimItem.name;
      var ordinalMeta = sysDimItem.ordinalMeta;
      sysDimItem.ordinalMeta = null;
      sysDimItem = clone(sysDimItem);
      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.

      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }

    var dataDims = normalizeToArray(encodeDef.get(coordDim)); // dimensions provides default dim sequences.

    if (!dataDims.length) {
      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {
          availDimIdx++;
        }

        availDimIdx < result.length && dataDims.push(availDimIdx++);
      }
    } // Apply templates.


    each(dataDims, function (resultDimIdx, coordDimIndex) {
      var resultItem = result[resultDimIdx];
      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);

      if (resultItem.name == null && sysDimItemDimsDef) {
        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
          name: sysDimItemDimsDefItem
        });
        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;
        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}


      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);
    });
  });

  function applyDim(resultItem, coordDim, coordDimIndex) {
    if (OTHER_DIMENSIONS.get(coordDim) != null) {
      resultItem.otherDims[coordDim] = coordDimIndex;
    } else {
      resultItem.coordDim = coordDim;
      resultItem.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim, true);
    }
  } // Make sure the first extra dim is 'value'.


  var generateCoord = opt.generateCoord;
  var generateCoordCount = opt.generateCoordCount;
  var fromZero = generateCoordCount != null;
  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
  var extra = generateCoord || 'value'; // Set dim `name` and other `coordDim` and other props.

  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
    var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};
    var coordDim = resultItem.coordDim;

    if (coordDim == null) {
      resultItem.coordDim = genName(extra, coordDimNameMap, fromZero);
      resultItem.coordDimIndex = 0;

      if (!generateCoord || generateCoordCount <= 0) {
        resultItem.isExtraCoord = true;
      }

      generateCoordCount--;
    }

    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));

    if (resultItem.type == null && guessOrdinal(source, resultDimIdx, resultItem.name)) {
      resultItem.type = 'ordinal';
    }
  }

  return result;
} // ??? TODO
// Originally detect dimCount by data[0]. Should we
// optimize it to only by sysDims and dimensions and encode.
// So only necessary dims will be initialized.
// But
// (1) custom series should be considered. where other dims
// may be visited.
// (2) sometimes user need to calcualte bubble size or use visualMap
// on other dimensions besides coordSys needed.
// So, dims that is not used by system, should be shared in storage?


function getDimCount(source, sysDims, dimsDef, optDimCount) {
  // Note that the result dimCount should not small than columns count
  // of data, otherwise `dataDimNameMap` checking will be incorrect.
  var dimCount = Math.max(source.dimensionsDetectCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
  each(sysDims, function (sysDimItem) {
    var sysDimItemDimsDef = sysDimItem.dimsDef;
    sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));
  });
  return dimCount;
}

function genName(name, map, fromZero) {
  if (fromZero || map.get(name) != null) {
    var i = 0;

    while (map.get(name + i) != null) {
      i++;
    }

    name += i;
  }

  map.set(name, true);
  return name;
}

var _default = completeDimensions;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/data/helper/createDimensions.js":
/***/ (function(module, exports, __webpack_require__) {

var completeDimensions = __webpack_require__("./node_modules/echarts/lib/data/helper/completeDimensions.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Substitute `completeDimensions`.
 * `completeDimensions` is to be deprecated.
 */

/**
 * @param {module:echarts/data/Source|module:echarts/data/List} source or data.
 * @param {Object|Array} [opt]
 * @param {Array.<string|Object>} [opt.coordDimensions=[]]
 * @param {number} [opt.dimensionsCount]
 * @param {string} [opt.generateCoord]
 * @param {string} [opt.generateCoordCount]
 * @param {Array.<string|Object>} [opt.dimensionsDefine=source.dimensionsDefine] Overwrite source define.
 * @param {Object|HashMap} [opt.encodeDefine=source.encodeDefine] Overwrite source define.
 * @return {Array.<Object>} dimensionsInfo
 */
function _default(source, opt) {
  opt = opt || {};
  return completeDimensions(opt.coordDimensions || [], source, {
    dimsDef: opt.dimensionsDefine || source.dimensionsDefine,
    encodeDef: opt.encodeDefine || source.encodeDefine,
    dimCount: opt.dimensionsCount,
    generateCoord: opt.generateCoord,
    generateCoordCount: opt.generateCoordCount
  });
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/data/helper/dataProvider.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var isTypedArray = _util.isTypedArray;
var extend = _util.extend;
var assert = _util.assert;
var each = _util.each;
var isObject = _util.isObject;

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var getDataItemValue = _model.getDataItemValue;
var isDataItemOption = _model.isDataItemOption;

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var parseDate = _number.parseDate;

var Source = __webpack_require__("./node_modules/echarts/lib/data/Source.js");

var _sourceType = __webpack_require__("./node_modules/echarts/lib/data/helper/sourceType.js");

var SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;
var SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;
var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
var SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// TODO
// ??? refactor? check the outer usage of data provider.
// merge with defaultDimValueGetter?

/**
 * If normal array used, mutable chunk size is supported.
 * If typed array used, chunk size must be fixed.
 */
function DefaultDataProvider(source, dimSize) {
  if (!Source.isInstance(source)) {
    source = Source.seriesDataToSource(source);
  }

  this._source = source;
  var data = this._data = source.data;
  var sourceFormat = source.sourceFormat; // Typed array. TODO IE10+?

  if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
    this._offset = 0;
    this._dimSize = dimSize;
    this._data = data;
  }

  var methods = providerMethods[sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + source.seriesLayoutBy : sourceFormat];
  extend(this, methods);
}

var providerProto = DefaultDataProvider.prototype; // If data is pure without style configuration

providerProto.pure = false; // If data is persistent and will not be released after use.

providerProto.persistent = true; // ???! FIXME legacy data provider do not has method getSource

providerProto.getSource = function () {
  return this._source;
};

var providerMethods = {
  'arrayRows_column': {
    pure: true,
    count: function () {
      return Math.max(0, this._data.length - this._source.startIndex);
    },
    getItem: function (idx) {
      return this._data[idx + this._source.startIndex];
    },
    appendData: appendDataSimply
  },
  'arrayRows_row': {
    pure: true,
    count: function () {
      var row = this._data[0];
      return row ? Math.max(0, row.length - this._source.startIndex) : 0;
    },
    getItem: function (idx) {
      idx += this._source.startIndex;
      var item = [];
      var data = this._data;

      for (var i = 0; i < data.length; i++) {
        var row = data[i];
        item.push(row ? row[idx] : null);
      }

      return item;
    },
    appendData: function () {
      throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
    }
  },
  'objectRows': {
    pure: true,
    count: countSimply,
    getItem: getItemSimply,
    appendData: appendDataSimply
  },
  'keyedColumns': {
    pure: true,
    count: function () {
      var dimName = this._source.dimensionsDefine[0].name;
      var col = this._data[dimName];
      return col ? col.length : 0;
    },
    getItem: function (idx) {
      var item = [];
      var dims = this._source.dimensionsDefine;

      for (var i = 0; i < dims.length; i++) {
        var col = this._data[dims[i].name];
        item.push(col ? col[idx] : null);
      }

      return item;
    },
    appendData: function (newData) {
      var data = this._data;
      each(newData, function (newCol, key) {
        var oldCol = data[key] || (data[key] = []);

        for (var i = 0; i < (newCol || []).length; i++) {
          oldCol.push(newCol[i]);
        }
      });
    }
  },
  'original': {
    count: countSimply,
    getItem: getItemSimply,
    appendData: appendDataSimply
  },
  'typedArray': {
    persistent: false,
    pure: true,
    count: function () {
      return this._data ? this._data.length / this._dimSize : 0;
    },
    getItem: function (idx, out) {
      idx = idx - this._offset;
      out = out || [];
      var offset = this._dimSize * idx;

      for (var i = 0; i < this._dimSize; i++) {
        out[i] = this._data[offset + i];
      }

      return out;
    },
    appendData: function (newData) {
      this._data = newData;
    },
    // Clean self if data is already used.
    clean: function () {
      // PENDING
      this._offset += this.count();
      this._data = null;
    }
  }
};

function countSimply() {
  return this._data.length;
}

function getItemSimply(idx) {
  return this._data[idx];
}

function appendDataSimply(newData) {
  for (var i = 0; i < newData.length; i++) {
    this._data.push(newData[i]);
  }
}

var rawValueGetters = {
  arrayRows: getRawValueSimply,
  objectRows: function (dataItem, dataIndex, dimIndex, dimName) {
    return dimIndex != null ? dataItem[dimName] : dataItem;
  },
  keyedColumns: getRawValueSimply,
  original: function (dataItem, dataIndex, dimIndex, dimName) {
    // FIXME
    // In some case (markpoint in geo (geo-map.html)), dataItem
    // is {coord: [...]}
    var value = getDataItemValue(dataItem);
    return dimIndex == null || !(value instanceof Array) ? value : value[dimIndex];
  },
  typedArray: getRawValueSimply
};

function getRawValueSimply(dataItem, dataIndex, dimIndex, dimName) {
  return dimIndex != null ? dataItem[dimIndex] : dataItem;
}

var defaultDimValueGetters = {
  arrayRows: getDimValueSimply,
  objectRows: function (dataItem, dimName, dataIndex, dimIndex) {
    return converDataValue(dataItem[dimName], this._dimensionInfos[dimName]);
  },
  keyedColumns: getDimValueSimply,
  original: function (dataItem, dimName, dataIndex, dimIndex) {
    // Performance sensitive, do not use modelUtil.getDataItemValue.
    // If dataItem is an plain object with no value field, the var `value`
    // will be assigned with the object, but it will be tread correctly
    // in the `convertDataValue`.
    var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value); // If any dataItem is like { value: 10 }

    if (!this._rawData.pure && isDataItemOption(dataItem)) {
      this.hasItemOption = true;
    }

    return converDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.
    : value, this._dimensionInfos[dimName]);
  },
  typedArray: function (dataItem, dimName, dataIndex, dimIndex) {
    return dataItem[dimIndex];
  }
};

function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {
  return converDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);
}
/**
 * This helper method convert value in data.
 * @param {string|number|Date} value
 * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.
 *        If "dimInfo.ordinalParseAndSave", ordinal value can be parsed.
 */


function converDataValue(value, dimInfo) {
  // Performance sensitive.
  var dimType = dimInfo && dimInfo.type;

  if (dimType === 'ordinal') {
    // If given value is a category string
    var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
    return ordinalMeta ? ordinalMeta.parseAndCollect(value) : value;
  }

  if (dimType === 'time' // spead up when using timestamp
  && typeof value !== 'number' && value != null && value !== '-') {
    value = +parseDate(value);
  } // dimType defaults 'number'.
  // If dimType is not ordinal and value is null or undefined or NaN or '-',
  // parse to NaN.


  return value == null || value === '' ? NaN // If string (like '-'), using '+' parse to NaN
  // If object, also parse to NaN
  : +value;
} // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,
// Consider persistent.
// Caution: why use raw value to display on label or tooltip?
// A reason is to avoid format. For example time value we do not know
// how to format is expected. More over, if stack is used, calculated
// value may be 0.91000000001, which have brings trouble to display.
// TODO: consider how to treat null/undefined/NaN when display?

/**
 * @param {module:echarts/data/List} data
 * @param {number} dataIndex
 * @param {string|number} [dim] dimName or dimIndex
 * @return {Array.<number>|string|number} can be null/undefined.
 */


function retrieveRawValue(data, dataIndex, dim) {
  if (!data) {
    return;
  } // Consider data may be not persistent.


  var dataItem = data.getRawDataItem(dataIndex);

  if (dataItem == null) {
    return;
  }

  var sourceFormat = data.getProvider().getSource().sourceFormat;
  var dimName;
  var dimIndex;
  var dimInfo = data.getDimensionInfo(dim);

  if (dimInfo) {
    dimName = dimInfo.name;
    dimIndex = dimInfo.index;
  }

  return rawValueGetters[sourceFormat](dataItem, dataIndex, dimIndex, dimName);
}
/**
 * Compatible with some cases (in pie, map) like:
 * data: [{name: 'xx', value: 5, selected: true}, ...]
 * where only sourceFormat is 'original' and 'objectRows' supported.
 *
 * ??? TODO
 * Supported detail options in data item when using 'arrayRows'.
 *
 * @param {module:echarts/data/List} data
 * @param {number} dataIndex
 * @param {string} attr like 'selected'
 */


function retrieveRawAttr(data, dataIndex, attr) {
  if (!data) {
    return;
  }

  var sourceFormat = data.getProvider().getSource().sourceFormat;

  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
    return;
  }

  var dataItem = data.getRawDataItem(dataIndex);

  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {
    dataItem = null;
  }

  if (dataItem) {
    return dataItem[attr];
  }
}

exports.DefaultDataProvider = DefaultDataProvider;
exports.defaultDimValueGetters = defaultDimValueGetters;
exports.retrieveRawValue = retrieveRawValue;
exports.retrieveRawAttr = retrieveRawAttr;

/***/ }),

/***/ "./node_modules/echarts/lib/data/helper/dataStackHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var each = _util.each;
var isString = _util.isString;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Note that it is too complicated to support 3d stack by value
 * (have to create two-dimension inverted index), so in 3d case
 * we just support that stacked by index.
 *
 * @param {module:echarts/model/Series} seriesModel
 * @param {Array.<string|Object>} dimensionInfoList The same as the input of <module:echarts/data/List>.
 *        The input dimensionInfoList will be modified.
 * @param {Object} [opt]
 * @param {boolean} [opt.stackedCoordDimension=''] Specify a coord dimension if needed.
 * @param {boolean} [opt.byIndex=false]
 * @return {Object} calculationInfo
 * {
 *     stackedDimension: string
 *     stackedByDimension: string
 *     isStackedByIndex: boolean
 *     stackedOverDimension: string
 *     stackResultDimension: string
 * }
 */
function enableDataStack(seriesModel, dimensionInfoList, opt) {
  opt = opt || {};
  var byIndex = opt.byIndex;
  var stackedCoordDimension = opt.stackedCoordDimension; // Compatibal: when `stack` is set as '', do not stack.

  var mayStack = !!(seriesModel && seriesModel.get('stack'));
  var stackedByDimInfo;
  var stackedDimInfo;
  var stackResultDimension;
  var stackedOverDimension;
  each(dimensionInfoList, function (dimensionInfo, index) {
    if (isString(dimensionInfo)) {
      dimensionInfoList[index] = dimensionInfo = {
        name: dimensionInfo
      };
    }

    if (mayStack && !dimensionInfo.isExtraCoord) {
      // Find the first ordinal dimension as the stackedByDimInfo.
      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
        stackedByDimInfo = dimensionInfo;
      } // Find the first stackable dimension as the stackedDimInfo.


      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
        stackedDimInfo = dimensionInfo;
      }
    }
  });

  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
    // Compatible with previous design, value axis (time axis) only stack by index.
    // It may make sense if the user provides elaborately constructed data.
    byIndex = true;
  } // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.
  // That put stack logic in List is for using conveniently in echarts extensions, but it
  // might not be a good way.


  if (stackedDimInfo) {
    // Use a weird name that not duplicated with other names.
    stackResultDimension = '__\0ecstackresult';
    stackedOverDimension = '__\0ecstackedover'; // Create inverted index to fast query index by value.

    if (stackedByDimInfo) {
      stackedByDimInfo.createInvertedIndices = true;
    }

    var stackedDimCoordDim = stackedDimInfo.coordDim;
    var stackedDimType = stackedDimInfo.type;
    var stackedDimCoordIndex = 0;
    each(dimensionInfoList, function (dimensionInfo) {
      if (dimensionInfo.coordDim === stackedDimCoordDim) {
        stackedDimCoordIndex++;
      }
    });
    dimensionInfoList.push({
      name: stackResultDimension,
      coordDim: stackedDimCoordDim,
      coordDimIndex: stackedDimCoordIndex,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true
    });
    stackedDimCoordIndex++;
    dimensionInfoList.push({
      name: stackedOverDimension,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: stackedOverDimension,
      coordDimIndex: stackedDimCoordIndex,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true
    });
  }

  return {
    stackedDimension: stackedDimInfo && stackedDimInfo.name,
    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
    isStackedByIndex: byIndex,
    stackedOverDimension: stackedOverDimension,
    stackResultDimension: stackResultDimension
  };
}
/**
 * @param {module:echarts/data/List} data
 * @param {string} stackedDim
 */


function isDimensionStacked(data, stackedDim
/*, stackedByDim*/
) {
  // Each single series only maps to one pair of axis. So we do not need to
  // check stackByDim, whatever stacked by a dimension or stacked by index.
  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension'); // && (
  //     stackedByDim != null
  //         ? stackedByDim === data.getCalculationInfo('stackedByDimension')
  //         : data.getCalculationInfo('isStackedByIndex')
  // );
}
/**
 * @param {module:echarts/data/List} data
 * @param {string} targetDim
 * @param {string} [stackedByDim] If not input this parameter, check whether
 *                                stacked by index.
 * @return {string} dimension
 */


function getStackedDimension(data, targetDim) {
  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;
}

exports.enableDataStack = enableDataStack;
exports.isDimensionStacked = isDimensionStacked;
exports.getStackedDimension = getStackedDimension;

/***/ }),

/***/ "./node_modules/echarts/lib/data/helper/dimensionHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var each = _util.each;
var createHashMap = _util.createHashMap;
var assert = _util.assert;

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var OTHER_DIMENSIONS = createHashMap(['tooltip', 'label', 'itemName', 'itemId', 'seriesName']);

function summarizeDimensions(data) {
  var summary = {};
  var encode = summary.encode = {};
  var notExtraCoordDimMap = createHashMap();
  var defaultedLabel = [];
  var defaultedTooltip = [];
  each(data.dimensions, function (dimName) {
    var dimItem = data.getDimensionInfo(dimName);
    var coordDim = dimItem.coordDim;

    if (coordDim) {
      var coordDimArr = encode[coordDim];

      if (!encode.hasOwnProperty(coordDim)) {
        coordDimArr = encode[coordDim] = [];
      }

      coordDimArr[dimItem.coordDimIndex] = dimName;

      if (!dimItem.isExtraCoord) {
        notExtraCoordDimMap.set(coordDim, 1); // Use the last coord dim (and label friendly) as default label,
        // because when dataset is used, it is hard to guess which dimension
        // can be value dimension. If both show x, y on label is not look good,
        // and conventionally y axis is focused more.

        if (mayLabelDimType(dimItem.type)) {
          defaultedLabel[0] = dimName;
        }
      }

      if (dimItem.defaultTooltip) {
        defaultedTooltip.push(dimName);
      }
    }

    OTHER_DIMENSIONS.each(function (v, otherDim) {
      var otherDimArr = encode[otherDim];

      if (!encode.hasOwnProperty(otherDim)) {
        otherDimArr = encode[otherDim] = [];
      }

      var dimIndex = dimItem.otherDims[otherDim];

      if (dimIndex != null && dimIndex !== false) {
        otherDimArr[dimIndex] = dimItem.name;
      }
    });
  });
  var dataDimsOnCoord = [];
  var encodeFirstDimNotExtra = {};
  notExtraCoordDimMap.each(function (v, coordDim) {
    var dimArr = encode[coordDim]; // ??? FIXME extra coord should not be set in dataDimsOnCoord.
    // But should fix the case that radar axes: simplify the logic
    // of `completeDimension`, remove `extraPrefix`.

    encodeFirstDimNotExtra[coordDim] = dimArr[0]; // Not necessary to remove duplicate, because a data
    // dim canot on more than one coordDim.

    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
  });
  summary.dataDimsOnCoord = dataDimsOnCoord;
  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
  var encodeLabel = encode.label; // FIXME `encode.label` is not recommanded, because formatter can not be set
  // in this way. Use label.formatter instead. May be remove this approach someday.

  if (encodeLabel && encodeLabel.length) {
    defaultedLabel = encodeLabel.slice();
  }

  var encodeTooltip = encode.tooltip;

  if (encodeTooltip && encodeTooltip.length) {
    defaultedTooltip = encodeTooltip.slice();
  } else if (!defaultedTooltip.length) {
    defaultedTooltip = defaultedLabel.slice();
  }

  encode.defaultedLabel = defaultedLabel;
  encode.defaultedTooltip = defaultedTooltip;
  return summary;
}

function getDimensionTypeByAxis(axisType) {
  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';
}

function mayLabelDimType(dimType) {
  // In most cases, ordinal and time do not suitable for label.
  // Ordinal info can be displayed on axis. Time is too long.
  return !(dimType === 'ordinal' || dimType === 'time');
} // function findTheLastDimMayLabel(data) {
//     // Get last value dim
//     var dimensions = data.dimensions.slice();
//     var valueType;
//     var valueDim;
//     while (dimensions.length && (
//         valueDim = dimensions.pop(),
//         valueType = data.getDimensionInfo(valueDim).type,
//         valueType === 'ordinal' || valueType === 'time'
//     )) {} // jshint ignore:line
//     return valueDim;
// }


exports.OTHER_DIMENSIONS = OTHER_DIMENSIONS;
exports.summarizeDimensions = summarizeDimensions;
exports.getDimensionTypeByAxis = getDimensionTypeByAxis;

/***/ }),

/***/ "./node_modules/echarts/lib/data/helper/sourceHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var makeInner = _model.makeInner;
var getDataItemValue = _model.getDataItemValue;

var _referHelper = __webpack_require__("./node_modules/echarts/lib/model/referHelper.js");

var getCoordSysDefineBySeries = _referHelper.getCoordSysDefineBySeries;

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var createHashMap = _util.createHashMap;
var each = _util.each;
var map = _util.map;
var isArray = _util.isArray;
var isString = _util.isString;
var isObject = _util.isObject;
var isTypedArray = _util.isTypedArray;
var isArrayLike = _util.isArrayLike;
var extend = _util.extend;
var assert = _util.assert;

var Source = __webpack_require__("./node_modules/echarts/lib/data/Source.js");

var _sourceType = __webpack_require__("./node_modules/echarts/lib/data/helper/sourceType.js");

var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
var SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;
var SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;
var SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;
var SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;
var SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;
var SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var inner = makeInner();
/**
 * @see {module:echarts/data/Source}
 * @param {module:echarts/component/dataset/DatasetModel} datasetModel
 * @return {string} sourceFormat
 */

function detectSourceFormat(datasetModel) {
  var data = datasetModel.option.source;
  var sourceFormat = SOURCE_FORMAT_UNKNOWN;

  if (isTypedArray(data)) {
    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
  } else if (isArray(data)) {
    // FIXME Whether tolerate null in top level array?
    for (var i = 0, len = data.length; i < len; i++) {
      var item = data[i];

      if (item == null) {
        continue;
      } else if (isArray(item)) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        break;
      } else if (isObject(item)) {
        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
        break;
      }
    }
  } else if (isObject(data)) {
    for (var key in data) {
      if (data.hasOwnProperty(key) && isArrayLike(data[key])) {
        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
    }
  } else if (data != null) {
    throw new Error('Invalid data');
  }

  inner(datasetModel).sourceFormat = sourceFormat;
}
/**
 * [Scenarios]:
 * (1) Provide source data directly:
 *     series: {
 *         encode: {...},
 *         dimensions: [...]
 *         seriesLayoutBy: 'row',
 *         data: [[...]]
 *     }
 * (2) Refer to datasetModel.
 *     series: [{
 *         encode: {...}
 *         // Ignore datasetIndex means `datasetIndex: 0`
 *         // and the dimensions defination in dataset is used
 *     }, {
 *         encode: {...},
 *         seriesLayoutBy: 'column',
 *         datasetIndex: 1
 *     }]
 *
 * Get data from series itself or datset.
 * @return {module:echarts/data/Source} source
 */


function getSource(seriesModel) {
  return inner(seriesModel).source;
}
/**
 * MUST be called before mergeOption of all series.
 * @param {module:echarts/model/Global} ecModel
 */


function resetSourceDefaulter(ecModel) {
  // `datasetMap` is used to make default encode.
  inner(ecModel).datasetMap = createHashMap();
}
/**
 * [Caution]:
 * MUST be called after series option merged and
 * before "series.getInitailData()" called.
 *
 * [The rule of making default encode]:
 * Category axis (if exists) alway map to the first dimension.
 * Each other axis occupies a subsequent dimension.
 *
 * [Why make default encode]:
 * Simplify the typing of encode in option, avoiding the case like that:
 * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],
 * where the "y" have to be manually typed as "1, 2, 3, ...".
 *
 * @param {module:echarts/model/Series} seriesModel
 */


function prepareSource(seriesModel) {
  var seriesOption = seriesModel.option;
  var data = seriesOption.data;
  var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
  var fromDataset = false;
  var seriesLayoutBy = seriesOption.seriesLayoutBy;
  var sourceHeader = seriesOption.sourceHeader;
  var dimensionsDefine = seriesOption.dimensions;
  var datasetModel = getDatasetModel(seriesModel);

  if (datasetModel) {
    var datasetOption = datasetModel.option;
    data = datasetOption.source;
    sourceFormat = inner(datasetModel).sourceFormat;
    fromDataset = true; // These settings from series has higher priority.

    seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;
    sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);
    dimensionsDefine = dimensionsDefine || datasetOption.dimensions;
  }

  var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine); // Note: dataset option does not have `encode`.

  var encodeDefine = seriesOption.encode;

  if (!encodeDefine && datasetModel) {
    encodeDefine = makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult);
  }

  inner(seriesModel).source = new Source({
    data: data,
    fromDataset: fromDataset,
    seriesLayoutBy: seriesLayoutBy,
    sourceFormat: sourceFormat,
    dimensionsDefine: completeResult.dimensionsDefine,
    startIndex: completeResult.startIndex,
    dimensionsDetectCount: completeResult.dimensionsDetectCount,
    encodeDefine: encodeDefine
  });
} // return {startIndex, dimensionsDefine, dimensionsCount}


function completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
  if (!data) {
    return {
      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)
    };
  }

  var dimensionsDetectCount;
  var startIndex;
  var findPotentialName;

  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    // Rule: Most of the first line are string: it is header.
    // Caution: consider a line with 5 string and 1 number,
    // it still can not be sure it is a head, because the
    // 5 string may be 5 values of category columns.
    if (sourceHeader === 'auto' || sourceHeader == null) {
      arrayRowsTravelFirst(function (val) {
        // '-' is regarded as null/undefined.
        if (val != null && val !== '-') {
          if (isString(val)) {
            startIndex == null && (startIndex = 1);
          } else {
            startIndex = 0;
          }
        } // 10 is an experience number, avoid long loop.

      }, seriesLayoutBy, data, 10);
    } else {
      startIndex = sourceHeader ? 1 : 0;
    }

    if (!dimensionsDefine && startIndex === 1) {
      dimensionsDefine = [];
      arrayRowsTravelFirst(function (val, index) {
        dimensionsDefine[index] = val != null ? val : '';
      }, seriesLayoutBy, data);
    }

    dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    if (!dimensionsDefine) {
      dimensionsDefine = objectRowsCollectDimensions(data);
      findPotentialName = true;
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    if (!dimensionsDefine) {
      dimensionsDefine = [];
      findPotentialName = true;
      each(data, function (colArr, key) {
        dimensionsDefine.push(key);
      });
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var value0 = getDataItemValue(data[0]);
    dimensionsDetectCount = isArray(value0) && value0.length || 1;
  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {}

  var potentialNameDimIndex;

  if (findPotentialName) {
    each(dimensionsDefine, function (dim, idx) {
      if ((isObject(dim) ? dim.name : dim) === 'name') {
        potentialNameDimIndex = idx;
      }
    });
  }

  return {
    startIndex: startIndex,
    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),
    dimensionsDetectCount: dimensionsDetectCount,
    potentialNameDimIndex: potentialNameDimIndex // TODO: potentialIdDimIdx

  };
} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],
// which is reasonable. But dimension name is duplicated.
// Returns undefined or an array contains only object without null/undefiend or string.


function normalizeDimensionsDefine(dimensionsDefine) {
  if (!dimensionsDefine) {
    // The meaning of null/undefined is different from empty array.
    return;
  }

  var nameMap = createHashMap();
  return map(dimensionsDefine, function (item, index) {
    item = extend({}, isObject(item) ? item : {
      name: item
    }); // User can set null in dimensions.
    // We dont auto specify name, othewise a given name may
    // cause it be refered unexpectedly.

    if (item.name == null) {
      return item;
    } // Also consider number form like 2012.


    item.name += ''; // User may also specify displayName.
    // displayName will always exists except user not
    // specified or dim name is not specified or detected.
    // (A auto generated dim name will not be used as
    // displayName).

    if (item.displayName == null) {
      item.displayName = item.name;
    }

    var exist = nameMap.get(item.name);

    if (!exist) {
      nameMap.set(item.name, {
        count: 1
      });
    } else {
      item.name += '-' + exist.count++;
    }

    return item;
  });
}

function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
  maxLoop == null && (maxLoop = Infinity);

  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
    for (var i = 0; i < data.length && i < maxLoop; i++) {
      cb(data[i] ? data[i][0] : null, i);
    }
  } else {
    var value0 = data[0] || [];

    for (var i = 0; i < value0.length && i < maxLoop; i++) {
      cb(value0[i], i);
    }
  }
}

function objectRowsCollectDimensions(data) {
  var firstIndex = 0;
  var obj;

  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line


  if (obj) {
    var dimensions = [];
    each(obj, function (value, key) {
      dimensions.push(key);
    });
    return dimensions;
  }
} // ??? TODO merge to completedimensions, where also has
// default encode making logic. And the default rule
// should depends on series? consider 'map'.


function makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult) {
  var coordSysDefine = getCoordSysDefineBySeries(seriesModel);
  var encode = {}; // var encodeTooltip = [];
  // var encodeLabel = [];

  var encodeItemName = [];
  var encodeSeriesName = [];
  var seriesType = seriesModel.subType; // ??? TODO refactor: provide by series itself.
  // Consider the case: 'map' series is based on geo coordSys,
  // 'graph', 'heatmap' can be based on cartesian. But can not
  // give default rule simply here.

  var nSeriesMap = createHashMap(['pie', 'map', 'funnel']);
  var cSeriesMap = createHashMap(['line', 'bar', 'pictorialBar', 'scatter', 'effectScatter', 'candlestick', 'boxplot']); // Usually in this case series will use the first data
  // dimension as the "value" dimension, or other default
  // processes respectively.

  if (coordSysDefine && cSeriesMap.get(seriesType) != null) {
    var ecModel = seriesModel.ecModel;
    var datasetMap = inner(ecModel).datasetMap;
    var key = datasetModel.uid + '_' + seriesLayoutBy;
    var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
      categoryWayDim: 1,
      valueWayDim: 0
    }); // TODO
    // Auto detect first time axis and do arrangement.

    each(coordSysDefine.coordSysDims, function (coordDim) {
      // In value way.
      if (coordSysDefine.firstCategoryDimIndex == null) {
        var dataDim = datasetRecord.valueWayDim++;
        encode[coordDim] = dataDim; // ??? TODO give a better default series name rule?
        // especially when encode x y specified.
        // consider: when mutiple series share one dimension
        // category axis, series name should better use
        // the other dimsion name. On the other hand, use
        // both dimensions name.

        encodeSeriesName.push(dataDim); // encodeTooltip.push(dataDim);
        // encodeLabel.push(dataDim);
      } // In category way, category axis.
      else if (coordSysDefine.categoryAxisMap.get(coordDim)) {
          encode[coordDim] = 0;
          encodeItemName.push(0);
        } // In category way, non-category axis.
        else {
            var dataDim = datasetRecord.categoryWayDim++;
            encode[coordDim] = dataDim; // encodeTooltip.push(dataDim);
            // encodeLabel.push(dataDim);

            encodeSeriesName.push(dataDim);
          }
    });
  } // Do not make a complex rule! Hard to code maintain and not necessary.
  // ??? TODO refactor: provide by series itself.
  // [{name: ..., value: ...}, ...] like:
  else if (nSeriesMap.get(seriesType) != null) {
      // Find the first not ordinal. (5 is an experience value)
      var firstNotOrdinal;

      for (var i = 0; i < 5 && firstNotOrdinal == null; i++) {
        if (!doGuessOrdinal(data, sourceFormat, seriesLayoutBy, completeResult.dimensionsDefine, completeResult.startIndex, i)) {
          firstNotOrdinal = i;
        }
      }

      if (firstNotOrdinal != null) {
        encode.value = firstNotOrdinal;
        var nameDimIndex = completeResult.potentialNameDimIndex || Math.max(firstNotOrdinal - 1, 0); // By default, label use itemName in charts.
        // So we dont set encodeLabel here.

        encodeSeriesName.push(nameDimIndex);
        encodeItemName.push(nameDimIndex); // encodeTooltip.push(firstNotOrdinal);
      }
    } // encodeTooltip.length && (encode.tooltip = encodeTooltip);
  // encodeLabel.length && (encode.label = encodeLabel);


  encodeItemName.length && (encode.itemName = encodeItemName);
  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
  return encode;
}
/**
 * If return null/undefined, indicate that should not use datasetModel.
 */


function getDatasetModel(seriesModel) {
  var option = seriesModel.option; // Caution: consider the scenario:
  // A dataset is declared and a series is not expected to use the dataset,
  // and at the beginning `setOption({series: { noData })` (just prepare other
  // option but no data), then `setOption({series: {data: [...]}); In this case,
  // the user should set an empty array to avoid that dataset is used by default.

  var thisData = option.data;

  if (!thisData) {
    return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);
  }
}
/**
 * The rule should not be complex, otherwise user might not
 * be able to known where the data is wrong.
 * The code is ugly, but how to make it neat?
 *
 * @param {module:echars/data/Source} source
 * @param {number} dimIndex
 * @return {boolean} Whether ordinal.
 */


function guessOrdinal(source, dimIndex) {
  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
} // dimIndex may be overflow source data.


function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
  var result; // Experience value.

  var maxLoop = 5;

  if (isTypedArray(data)) {
    return false;
  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine
  // always exists in source.


  var dimName;

  if (dimensionsDefine) {
    dimName = dimensionsDefine[dimIndex];
    dimName = isObject(dimName) ? dimName.name : dimName;
  }

  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      var sample = data[dimIndex];

      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
        if ((result = detectValue(sample[startIndex + i])) != null) {
          return result;
        }
      }
    } else {
      for (var i = 0; i < data.length && i < maxLoop; i++) {
        var row = data[startIndex + i];

        if (row && (result = detectValue(row[dimIndex])) != null) {
          return result;
        }
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    if (!dimName) {
      return;
    }

    for (var i = 0; i < data.length && i < maxLoop; i++) {
      var item = data[i];

      if (item && (result = detectValue(item[dimName])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    if (!dimName) {
      return;
    }

    var sample = data[dimName];

    if (!sample || isTypedArray(sample)) {
      return false;
    }

    for (var i = 0; i < sample.length && i < maxLoop; i++) {
      if ((result = detectValue(sample[i])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    for (var i = 0; i < data.length && i < maxLoop; i++) {
      var item = data[i];
      var val = getDataItemValue(item);

      if (!isArray(val)) {
        return false;
      }

      if ((result = detectValue(val[dimIndex])) != null) {
        return result;
      }
    }
  }

  function detectValue(val) {
    // Consider usage convenience, '1', '2' will be treated as "number".
    // `isFinit('')` get `true`.
    if (val != null && isFinite(val) && val !== '') {
      return false;
    } else if (isString(val) && val !== '-') {
      return true;
    }
  }

  return false;
}

exports.detectSourceFormat = detectSourceFormat;
exports.getSource = getSource;
exports.resetSourceDefaulter = resetSourceDefaulter;
exports.prepareSource = prepareSource;
exports.guessOrdinal = guessOrdinal;

/***/ }),

/***/ "./node_modules/echarts/lib/data/helper/sourceType.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Avoid typo.
var SOURCE_FORMAT_ORIGINAL = 'original';
var SOURCE_FORMAT_ARRAY_ROWS = 'arrayRows';
var SOURCE_FORMAT_OBJECT_ROWS = 'objectRows';
var SOURCE_FORMAT_KEYED_COLUMNS = 'keyedColumns';
var SOURCE_FORMAT_UNKNOWN = 'unknown'; // ??? CHANGE A NAME

var SOURCE_FORMAT_TYPED_ARRAY = 'typedArray';
var SERIES_LAYOUT_BY_COLUMN = 'column';
var SERIES_LAYOUT_BY_ROW = 'row';
exports.SOURCE_FORMAT_ORIGINAL = SOURCE_FORMAT_ORIGINAL;
exports.SOURCE_FORMAT_ARRAY_ROWS = SOURCE_FORMAT_ARRAY_ROWS;
exports.SOURCE_FORMAT_OBJECT_ROWS = SOURCE_FORMAT_OBJECT_ROWS;
exports.SOURCE_FORMAT_KEYED_COLUMNS = SOURCE_FORMAT_KEYED_COLUMNS;
exports.SOURCE_FORMAT_UNKNOWN = SOURCE_FORMAT_UNKNOWN;
exports.SOURCE_FORMAT_TYPED_ARRAY = SOURCE_FORMAT_TYPED_ARRAY;
exports.SERIES_LAYOUT_BY_COLUMN = SERIES_LAYOUT_BY_COLUMN;
exports.SERIES_LAYOUT_BY_ROW = SERIES_LAYOUT_BY_ROW;

/***/ }),

/***/ "./node_modules/echarts/lib/echarts.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrender = __webpack_require__("./node_modules/zrender/lib/zrender.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var colorTool = __webpack_require__("./node_modules/zrender/lib/tool/color.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var timsort = __webpack_require__("./node_modules/zrender/lib/core/timsort.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var GlobalModel = __webpack_require__("./node_modules/echarts/lib/model/Global.js");

var ExtensionAPI = __webpack_require__("./node_modules/echarts/lib/ExtensionAPI.js");

var CoordinateSystemManager = __webpack_require__("./node_modules/echarts/lib/CoordinateSystem.js");

var OptionManager = __webpack_require__("./node_modules/echarts/lib/model/OptionManager.js");

var backwardCompat = __webpack_require__("./node_modules/echarts/lib/preprocessor/backwardCompat.js");

var dataStack = __webpack_require__("./node_modules/echarts/lib/processor/dataStack.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var SeriesModel = __webpack_require__("./node_modules/echarts/lib/model/Series.js");

var ComponentView = __webpack_require__("./node_modules/echarts/lib/view/Component.js");

var ChartView = __webpack_require__("./node_modules/echarts/lib/view/Chart.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var _throttle = __webpack_require__("./node_modules/echarts/lib/util/throttle.js");

var throttle = _throttle.throttle;

var seriesColor = __webpack_require__("./node_modules/echarts/lib/visual/seriesColor.js");

var aria = __webpack_require__("./node_modules/echarts/lib/visual/aria.js");

var loadingDefault = __webpack_require__("./node_modules/echarts/lib/loading/default.js");

var Scheduler = __webpack_require__("./node_modules/echarts/lib/stream/Scheduler.js");

var lightTheme = __webpack_require__("./node_modules/echarts/lib/theme/light.js");

var darkTheme = __webpack_require__("./node_modules/echarts/lib/theme/dark.js");

__webpack_require__("./node_modules/echarts/lib/component/dataset.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var assert = zrUtil.assert;
var each = zrUtil.each;
var isFunction = zrUtil.isFunction;
var isObject = zrUtil.isObject;
var parseClassType = ComponentModel.parseClassType;
var version = '4.1.0';
var dependencies = {
  zrender: '4.0.4'
};
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_FILTER = 1000;
var PRIORITY_PROCESSOR_STATISTIC = 5000;
var PRIORITY_VISUAL_LAYOUT = 1000;
var PRIORITY_VISUAL_GLOBAL = 2000;
var PRIORITY_VISUAL_CHART = 3000;
var PRIORITY_VISUAL_COMPONENT = 4000; // FIXME
// necessary?

var PRIORITY_VISUAL_BRUSH = 5000;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH
  }
}; // Main process have three entries: `setOption`, `dispatchAction` and `resize`,
// where they must not be invoked nestedly, except the only case: invoke
// dispatchAction with updateMethod "none" in main process.
// This flag is used to carry out this rule.
// All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).

var IN_MAIN_PROCESS = '__flagInMainProcess';
var OPTION_UPDATED = '__optionUpdated';
var ACTION_REG = /^[a-zA-Z0-9_]+$/;

function createRegisterEventWithLowercaseName(method) {
  return function (eventName, handler, context) {
    // Event name is all lowercase
    eventName = eventName && eventName.toLowerCase();
    Eventful.prototype[method].call(this, eventName, handler, context);
  };
}
/**
 * @module echarts~MessageCenter
 */


function MessageCenter() {
  Eventful.call(this);
}

MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');
MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');
MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');
zrUtil.mixin(MessageCenter, Eventful);
/**
 * @module echarts~ECharts
 */

function ECharts(dom, theme, opts) {
  opts = opts || {}; // Get theme by name

  if (typeof theme === 'string') {
    theme = themeStorage[theme];
  }
  /**
   * @type {string}
   */


  this.id;
  /**
   * Group id
   * @type {string}
   */

  this.group;
  /**
   * @type {HTMLElement}
   * @private
   */

  this._dom = dom;
  var defaultRenderer = 'canvas';

  /**
   * @type {module:zrender/ZRender}
   * @private
   */
  var zr = this._zr = zrender.init(dom, {
    renderer: opts.renderer || defaultRenderer,
    devicePixelRatio: opts.devicePixelRatio,
    width: opts.width,
    height: opts.height
  });
  /**
   * Expect 60 pfs.
   * @type {Function}
   * @private
   */

  this._throttledZrFlush = throttle(zrUtil.bind(zr.flush, zr), 17);
  var theme = zrUtil.clone(theme);
  theme && backwardCompat(theme, true);
  /**
   * @type {Object}
   * @private
   */

  this._theme = theme;
  /**
   * @type {Array.<module:echarts/view/Chart>}
   * @private
   */

  this._chartsViews = [];
  /**
   * @type {Object.<string, module:echarts/view/Chart>}
   * @private
   */

  this._chartsMap = {};
  /**
   * @type {Array.<module:echarts/view/Component>}
   * @private
   */

  this._componentsViews = [];
  /**
   * @type {Object.<string, module:echarts/view/Component>}
   * @private
   */

  this._componentsMap = {};
  /**
   * @type {module:echarts/CoordinateSystem}
   * @private
   */

  this._coordSysMgr = new CoordinateSystemManager();
  /**
   * @type {module:echarts/ExtensionAPI}
   * @private
   */

  var api = this._api = createExtensionAPI(this); // Sort on demand

  function prioritySortFunc(a, b) {
    return a.__prio - b.__prio;
  }

  timsort(visualFuncs, prioritySortFunc);
  timsort(dataProcessorFuncs, prioritySortFunc);
  /**
   * @type {module:echarts/stream/Scheduler}
   */

  this._scheduler = new Scheduler(this, api, dataProcessorFuncs, visualFuncs);
  Eventful.call(this);
  /**
   * @type {module:echarts~MessageCenter}
   * @private
   */

  this._messageCenter = new MessageCenter(); // Init mouse events

  this._initEvents(); // In case some people write `window.onresize = chart.resize`


  this.resize = zrUtil.bind(this.resize, this); // Can't dispatch action during rendering procedure

  this._pendingActions = [];
  zr.animation.on('frame', this._onframe, this);
  bindRenderedEvent(zr, this); // ECharts instance can be used as value.

  zrUtil.setAsPrimitive(this);
}

var echartsProto = ECharts.prototype;

echartsProto._onframe = function () {
  if (this._disposed) {
    return;
  }

  var scheduler = this._scheduler; // Lazy update

  if (this[OPTION_UPDATED]) {
    var silent = this[OPTION_UPDATED].silent;
    this[IN_MAIN_PROCESS] = true;
    prepare(this);
    updateMethods.update.call(this);
    this[IN_MAIN_PROCESS] = false;
    this[OPTION_UPDATED] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  } // Avoid do both lazy update and progress in one frame.
  else if (scheduler.unfinished) {
      // Stream progress.
      var remainTime = TEST_FRAME_REMAIN_TIME;
      var ecModel = this._model;
      var api = this._api;
      scheduler.unfinished = false;

      do {
        var startTime = +new Date();
        scheduler.performSeriesTasks(ecModel); // Currently dataProcessorFuncs do not check threshold.

        scheduler.performDataProcessorTasks(ecModel);
        updateStreamModes(this, ecModel); // Do not update coordinate system here. Because that coord system update in
        // each frame is not a good user experience. So we follow the rule that
        // the extent of the coordinate system is determin in the first frame (the
        // frame is executed immedietely after task reset.
        // this._coordSysMgr.update(ecModel, api);
        // console.log('--- ec frame visual ---', remainTime);

        scheduler.performVisualTasks(ecModel);
        renderSeries(this, this._model, api, 'remain');
        remainTime -= +new Date() - startTime;
      } while (remainTime > 0 && scheduler.unfinished); // Call flush explicitly for trigger finished event.


      if (!scheduler.unfinished) {
        this._zr.flush();
      } // Else, zr flushing be ensue within the same frame,
      // because zr flushing is after onframe event.

    }
};
/**
 * @return {HTMLElement}
 */


echartsProto.getDom = function () {
  return this._dom;
};
/**
 * @return {module:zrender~ZRender}
 */


echartsProto.getZr = function () {
  return this._zr;
};
/**
 * Usage:
 * chart.setOption(option, notMerge, lazyUpdate);
 * chart.setOption(option, {
 *     notMerge: ...,
 *     lazyUpdate: ...,
 *     silent: ...
 * });
 *
 * @param {Object} option
 * @param {Object|boolean} [opts] opts or notMerge.
 * @param {boolean} [opts.notMerge=false]
 * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.
 */


echartsProto.setOption = function (option, notMerge, lazyUpdate) {
  var silent;

  if (isObject(notMerge)) {
    lazyUpdate = notMerge.lazyUpdate;
    silent = notMerge.silent;
    notMerge = notMerge.notMerge;
  }

  this[IN_MAIN_PROCESS] = true;

  if (!this._model || notMerge) {
    var optionManager = new OptionManager(this._api);
    var theme = this._theme;
    var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);
    ecModel.scheduler = this._scheduler;
    ecModel.init(null, null, theme, optionManager);
  }

  this._model.setOption(option, optionPreprocessorFuncs);

  if (lazyUpdate) {
    this[OPTION_UPDATED] = {
      silent: silent
    };
    this[IN_MAIN_PROCESS] = false;
  } else {
    prepare(this);
    updateMethods.update.call(this); // Ensure zr refresh sychronously, and then pixel in canvas can be
    // fetched after `setOption`.

    this._zr.flush();

    this[OPTION_UPDATED] = false;
    this[IN_MAIN_PROCESS] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  }
};
/**
 * @DEPRECATED
 */


echartsProto.setTheme = function () {
  console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
};
/**
 * @return {module:echarts/model/Global}
 */


echartsProto.getModel = function () {
  return this._model;
};
/**
 * @return {Object}
 */


echartsProto.getOption = function () {
  return this._model && this._model.getOption();
};
/**
 * @return {number}
 */


echartsProto.getWidth = function () {
  return this._zr.getWidth();
};
/**
 * @return {number}
 */


echartsProto.getHeight = function () {
  return this._zr.getHeight();
};
/**
 * @return {number}
 */


echartsProto.getDevicePixelRatio = function () {
  return this._zr.painter.dpr || window.devicePixelRatio || 1;
};
/**
 * Get canvas which has all thing rendered
 * @param {Object} opts
 * @param {string} [opts.backgroundColor]
 * @return {string}
 */


echartsProto.getRenderedCanvas = function (opts) {
  if (!env.canvasSupported) {
    return;
  }

  opts = opts || {};
  opts.pixelRatio = opts.pixelRatio || 1;
  opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');
  var zr = this._zr; // var list = zr.storage.getDisplayList();
  // Stop animations
  // Never works before in init animation, so remove it.
  // zrUtil.each(list, function (el) {
  //     el.stopAnimation(true);
  // });

  return zr.painter.getRenderedCanvas(opts);
};
/**
 * Get svg data url
 * @return {string}
 */


echartsProto.getSvgDataUrl = function () {
  if (!env.svgSupported) {
    return;
  }

  var zr = this._zr;
  var list = zr.storage.getDisplayList(); // Stop animations

  zrUtil.each(list, function (el) {
    el.stopAnimation(true);
  });
  return zr.painter.pathToDataUrl();
};
/**
 * @return {string}
 * @param {Object} opts
 * @param {string} [opts.type='png']
 * @param {string} [opts.pixelRatio=1]
 * @param {string} [opts.backgroundColor]
 * @param {string} [opts.excludeComponents]
 */


echartsProto.getDataURL = function (opts) {
  opts = opts || {};
  var excludeComponents = opts.excludeComponents;
  var ecModel = this._model;
  var excludesComponentViews = [];
  var self = this;
  each(excludeComponents, function (componentType) {
    ecModel.eachComponent({
      mainType: componentType
    }, function (component) {
      var view = self._componentsMap[component.__viewId];

      if (!view.group.ignore) {
        excludesComponentViews.push(view);
        view.group.ignore = true;
      }
    });
  });
  var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataUrl() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));
  each(excludesComponentViews, function (view) {
    view.group.ignore = false;
  });
  return url;
};
/**
 * @return {string}
 * @param {Object} opts
 * @param {string} [opts.type='png']
 * @param {string} [opts.pixelRatio=1]
 * @param {string} [opts.backgroundColor]
 */


echartsProto.getConnectedDataURL = function (opts) {
  if (!env.canvasSupported) {
    return;
  }

  var groupId = this.group;
  var mathMin = Math.min;
  var mathMax = Math.max;
  var MAX_NUMBER = Infinity;

  if (connectedGroups[groupId]) {
    var left = MAX_NUMBER;
    var top = MAX_NUMBER;
    var right = -MAX_NUMBER;
    var bottom = -MAX_NUMBER;
    var canvasList = [];
    var dpr = opts && opts.pixelRatio || 1;
    zrUtil.each(instances, function (chart, id) {
      if (chart.group === groupId) {
        var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));
        var boundingRect = chart.getDom().getBoundingClientRect();
        left = mathMin(boundingRect.left, left);
        top = mathMin(boundingRect.top, top);
        right = mathMax(boundingRect.right, right);
        bottom = mathMax(boundingRect.bottom, bottom);
        canvasList.push({
          dom: canvas,
          left: boundingRect.left,
          top: boundingRect.top
        });
      }
    });
    left *= dpr;
    top *= dpr;
    right *= dpr;
    bottom *= dpr;
    var width = right - left;
    var height = bottom - top;
    var targetCanvas = zrUtil.createCanvas();
    targetCanvas.width = width;
    targetCanvas.height = height;
    var zr = zrender.init(targetCanvas);
    each(canvasList, function (item) {
      var img = new graphic.Image({
        style: {
          x: item.left * dpr - left,
          y: item.top * dpr - top,
          image: item.dom
        }
      });
      zr.add(img);
    });
    zr.refreshImmediately();
    return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
  } else {
    return this.getDataURL(opts);
  }
};
/**
 * Convert from logical coordinate system to pixel coordinate system.
 * See CoordinateSystem#convertToPixel.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId, geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName,
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {Array|number} result
 */


echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');
/**
 * Convert from pixel coordinate system to logical coordinate system.
 * See CoordinateSystem#convertFromPixel.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId / geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {Array|number} result
 */

echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');

function doConvertPixel(methodName, finder, value) {
  var ecModel = this._model;

  var coordSysList = this._coordSysMgr.getCoordinateSystems();

  var result;
  finder = modelUtil.parseFinder(ecModel, finder);

  for (var i = 0; i < coordSysList.length; i++) {
    var coordSys = coordSysList[i];

    if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {
      return result;
    }
  }
}
/**
 * Is the specified coordinate systems or components contain the given pixel point.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId / geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName,
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {boolean} result
 */


echartsProto.containPixel = function (finder, value) {
  var ecModel = this._model;
  var result;
  finder = modelUtil.parseFinder(ecModel, finder);
  zrUtil.each(finder, function (models, key) {
    key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {
      var coordSys = model.coordinateSystem;

      if (coordSys && coordSys.containPoint) {
        result |= !!coordSys.containPoint(value);
      } else if (key === 'seriesModels') {
        var view = this._chartsMap[model.__viewId];

        if (view && view.containPoint) {
          result |= view.containPoint(value, model);
        } else {}
      } else {}
    }, this);
  }, this);
  return !!result;
};
/**
 * Get visual from series or data.
 * @param {string|Object} finder
 *        If string, e.g., 'series', means {seriesIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            dataIndex / dataIndexInside
 *        }
 *        If dataIndex is not specified, series visual will be fetched,
 *        but not data item visual.
 *        If all of seriesIndex, seriesId, seriesName are not specified,
 *        visual will be fetched from first series.
 * @param {string} visualType 'color', 'symbol', 'symbolSize'
 */


echartsProto.getVisual = function (finder, visualType) {
  var ecModel = this._model;
  finder = modelUtil.parseFinder(ecModel, finder, {
    defaultMainType: 'series'
  });
  var seriesModel = finder.seriesModel;
  var data = seriesModel.getData();
  var dataIndexInside = finder.hasOwnProperty('dataIndexInside') ? finder.dataIndexInside : finder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(finder.dataIndex) : null;
  return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);
};
/**
 * Get view of corresponding component model
 * @param  {module:echarts/model/Component} componentModel
 * @return {module:echarts/view/Component}
 */


echartsProto.getViewOfComponentModel = function (componentModel) {
  return this._componentsMap[componentModel.__viewId];
};
/**
 * Get view of corresponding series model
 * @param  {module:echarts/model/Series} seriesModel
 * @return {module:echarts/view/Chart}
 */


echartsProto.getViewOfSeriesModel = function (seriesModel) {
  return this._chartsMap[seriesModel.__viewId];
};

var updateMethods = {
  prepareAndUpdate: function (payload) {
    prepare(this);
    updateMethods.update.call(this, payload);
  },

  /**
   * @param {Object} payload
   * @private
   */
  update: function (payload) {
    // console.profile && console.profile('update');
    var ecModel = this._model;
    var api = this._api;
    var zr = this._zr;
    var coordSysMgr = this._coordSysMgr;
    var scheduler = this._scheduler; // update before setOption

    if (!ecModel) {
      return;
    }

    scheduler.restoreData(ecModel, payload);
    scheduler.performSeriesTasks(ecModel); // TODO
    // Save total ecModel here for undo/redo (after restoring data and before processing data).
    // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
    // Create new coordinate system each update
    // In LineView may save the old coordinate system and use it to get the orignal point

    coordSysMgr.create(ecModel, api);
    scheduler.performDataProcessorTasks(ecModel, payload); // Current stream render is not supported in data process. So we can update
    // stream modes after data processing, where the filtered data is used to
    // deteming whether use progressive rendering.

    updateStreamModes(this, ecModel); // We update stream modes before coordinate system updated, then the modes info
    // can be fetched when coord sys updating (consider the barGrid extent fix). But
    // the drawback is the full coord info can not be fetched. Fortunately this full
    // coord is not requied in stream mode updater currently.

    coordSysMgr.update(ecModel, api);
    clearColorPalette(ecModel);
    scheduler.performVisualTasks(ecModel, payload);
    render(this, ecModel, api, payload); // Set background

    var backgroundColor = ecModel.get('backgroundColor') || 'transparent'; // In IE8

    if (!env.canvasSupported) {
      var colorArr = colorTool.parse(backgroundColor);
      backgroundColor = colorTool.stringify(colorArr, 'rgb');

      if (colorArr[3] === 0) {
        backgroundColor = 'transparent';
      }
    } else {
      zr.setBackgroundColor(backgroundColor);
    }

    performPostUpdateFuncs(ecModel, api); // console.profile && console.profileEnd('update');
  },

  /**
   * @param {Object} payload
   * @private
   */
  updateTransform: function (payload) {
    var ecModel = this._model;
    var ecIns = this;
    var api = this._api; // update before setOption

    if (!ecModel) {
      return;
    } // ChartView.markUpdateMethod(payload, 'updateTransform');


    var componentDirtyList = [];
    ecModel.eachComponent(function (componentType, componentModel) {
      var componentView = ecIns.getViewOfComponentModel(componentModel);

      if (componentView && componentView.__alive) {
        if (componentView.updateTransform) {
          var result = componentView.updateTransform(componentModel, ecModel, api, payload);
          result && result.update && componentDirtyList.push(componentView);
        } else {
          componentDirtyList.push(componentView);
        }
      }
    });
    var seriesDirtyMap = zrUtil.createHashMap();
    ecModel.eachSeries(function (seriesModel) {
      var chartView = ecIns._chartsMap[seriesModel.__viewId];

      if (chartView.updateTransform) {
        var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
        result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
      } else {
        seriesDirtyMap.set(seriesModel.uid, 1);
      }
    });
    clearColorPalette(ecModel); // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
    // this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);

    this._scheduler.performVisualTasks(ecModel, payload, {
      setDirty: true,
      dirtyMap: seriesDirtyMap
    }); // Currently, not call render of components. Geo render cost a lot.
    // renderComponents(ecIns, ecModel, api, payload, componentDirtyList);


    renderSeries(ecIns, ecModel, api, payload, seriesDirtyMap);
    performPostUpdateFuncs(ecModel, this._api);
  },

  /**
   * @param {Object} payload
   * @private
   */
  updateView: function (payload) {
    var ecModel = this._model; // update before setOption

    if (!ecModel) {
      return;
    }

    ChartView.markUpdateMethod(payload, 'updateView');
    clearColorPalette(ecModel); // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.

    this._scheduler.performVisualTasks(ecModel, payload, {
      setDirty: true
    });

    render(this, this._model, this._api, payload);
    performPostUpdateFuncs(ecModel, this._api);
  },

  /**
   * @param {Object} payload
   * @private
   */
  updateVisual: function (payload) {
    updateMethods.update.call(this, payload); // var ecModel = this._model;
    // // update before setOption
    // if (!ecModel) {
    //     return;
    // }
    // ChartView.markUpdateMethod(payload, 'updateVisual');
    // clearColorPalette(ecModel);
    // // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
    // this._scheduler.performVisualTasks(ecModel, payload, {visualType: 'visual', setDirty: true});
    // render(this, this._model, this._api, payload);
    // performPostUpdateFuncs(ecModel, this._api);
  },

  /**
   * @param {Object} payload
   * @private
   */
  updateLayout: function (payload) {
    updateMethods.update.call(this, payload); // var ecModel = this._model;
    // // update before setOption
    // if (!ecModel) {
    //     return;
    // }
    // ChartView.markUpdateMethod(payload, 'updateLayout');
    // // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
    // // this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);
    // this._scheduler.performVisualTasks(ecModel, payload, {setDirty: true});
    // render(this, this._model, this._api, payload);
    // performPostUpdateFuncs(ecModel, this._api);
  }
};

function prepare(ecIns) {
  var ecModel = ecIns._model;
  var scheduler = ecIns._scheduler;
  scheduler.restorePipelines(ecModel);
  scheduler.prepareStageTasks();
  prepareView(ecIns, 'component', ecModel, scheduler);
  prepareView(ecIns, 'chart', ecModel, scheduler);
  scheduler.plan();
}
/**
 * @private
 */


function updateDirectly(ecIns, method, payload, mainType, subType) {
  var ecModel = ecIns._model; // broadcast

  if (!mainType) {
    // FIXME
    // Chart will not be update directly here, except set dirty.
    // But there is no such scenario now.
    each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);
    return;
  }

  var query = {};
  query[mainType + 'Id'] = payload[mainType + 'Id'];
  query[mainType + 'Index'] = payload[mainType + 'Index'];
  query[mainType + 'Name'] = payload[mainType + 'Name'];
  var condition = {
    mainType: mainType,
    query: query
  };
  subType && (condition.subType = subType); // subType may be '' by parseClassType;

  var excludeSeriesId = payload.excludeSeriesId;

  if (excludeSeriesId != null) {
    excludeSeriesId = zrUtil.createHashMap(modelUtil.normalizeToArray(excludeSeriesId));
  } // If dispatchAction before setOption, do nothing.


  ecModel && ecModel.eachComponent(condition, function (model) {
    if (!excludeSeriesId || excludeSeriesId.get(model.id) == null) {
      callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);
    }
  }, ecIns);

  function callView(view) {
    view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
  }
}
/**
 * Resize the chart
 * @param {Object} opts
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 * @param {boolean} [opts.silent=false]
 */


echartsProto.resize = function (opts) {
  this._zr.resize(opts);

  var ecModel = this._model; // Resize loading effect

  this._loadingFX && this._loadingFX.resize();

  if (!ecModel) {
    return;
  }

  var optionChanged = ecModel.resetOption('media');
  var silent = opts && opts.silent;
  this[IN_MAIN_PROCESS] = true;
  optionChanged && prepare(this);
  updateMethods.update.call(this);
  this[IN_MAIN_PROCESS] = false;
  flushPendingActions.call(this, silent);
  triggerUpdatedEvent.call(this, silent);
};

function updateStreamModes(ecIns, ecModel) {
  var chartsMap = ecIns._chartsMap;
  var scheduler = ecIns._scheduler;
  ecModel.eachSeries(function (seriesModel) {
    scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
  });
}
/**
 * Show loading effect
 * @param  {string} [name='default']
 * @param  {Object} [cfg]
 */


echartsProto.showLoading = function (name, cfg) {
  if (isObject(name)) {
    cfg = name;
    name = '';
  }

  name = name || 'default';
  this.hideLoading();

  if (!loadingEffects[name]) {
    return;
  }

  var el = loadingEffects[name](this._api, cfg);
  var zr = this._zr;
  this._loadingFX = el;
  zr.add(el);
};
/**
 * Hide loading effect
 */


echartsProto.hideLoading = function () {
  this._loadingFX && this._zr.remove(this._loadingFX);
  this._loadingFX = null;
};
/**
 * @param {Object} eventObj
 * @return {Object}
 */


echartsProto.makeActionFromEvent = function (eventObj) {
  var payload = zrUtil.extend({}, eventObj);
  payload.type = eventActionMap[eventObj.type];
  return payload;
};
/**
 * @pubilc
 * @param {Object} payload
 * @param {string} [payload.type] Action type
 * @param {Object|boolean} [opt] If pass boolean, means opt.silent
 * @param {boolean} [opt.silent=false] Whether trigger events.
 * @param {boolean} [opt.flush=undefined]
 *                  true: Flush immediately, and then pixel in canvas can be fetched
 *                      immediately. Caution: it might affect performance.
 *                  false: Not not flush.
 *                  undefined: Auto decide whether perform flush.
 */


echartsProto.dispatchAction = function (payload, opt) {
  if (!isObject(opt)) {
    opt = {
      silent: !!opt
    };
  }

  if (!actions[payload.type]) {
    return;
  } // Avoid dispatch action before setOption. Especially in `connect`.


  if (!this._model) {
    return;
  } // May dispatchAction in rendering procedure


  if (this[IN_MAIN_PROCESS]) {
    this._pendingActions.push(payload);

    return;
  }

  doDispatchAction.call(this, payload, opt.silent);

  if (opt.flush) {
    this._zr.flush(true);
  } else if (opt.flush !== false && env.browser.weChat) {
    // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`
    // hang when sliding page (on touch event), which cause that zr does not
    // refresh util user interaction finished, which is not expected.
    // But `dispatchAction` may be called too frequently when pan on touch
    // screen, which impacts performance if do not throttle them.
    this._throttledZrFlush();
  }

  flushPendingActions.call(this, opt.silent);
  triggerUpdatedEvent.call(this, opt.silent);
};

function doDispatchAction(payload, silent) {
  var payloadType = payload.type;
  var escapeConnect = payload.escapeConnect;
  var actionWrap = actions[payloadType];
  var actionInfo = actionWrap.actionInfo;
  var cptType = (actionInfo.update || 'update').split(':');
  var updateMethod = cptType.pop();
  cptType = cptType[0] != null && parseClassType(cptType[0]);
  this[IN_MAIN_PROCESS] = true;
  var payloads = [payload];
  var batched = false; // Batch action

  if (payload.batch) {
    batched = true;
    payloads = zrUtil.map(payload.batch, function (item) {
      item = zrUtil.defaults(zrUtil.extend({}, item), payload);
      item.batch = null;
      return item;
    });
  }

  var eventObjBatch = [];
  var eventObj;
  var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';
  each(payloads, function (batchItem) {
    // Action can specify the event by return it.
    eventObj = actionWrap.action(batchItem, this._model, this._api); // Emit event outside

    eventObj = eventObj || zrUtil.extend({}, batchItem); // Convert type to eventType

    eventObj.type = actionInfo.event || eventObj.type;
    eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual.

    if (isHighDown) {
      // method, payload, mainType, subType
      updateDirectly(this, updateMethod, batchItem, 'series');
    } else if (cptType) {
      updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
    }
  }, this);

  if (updateMethod !== 'none' && !isHighDown && !cptType) {
    // Still dirty
    if (this[OPTION_UPDATED]) {
      // FIXME Pass payload ?
      prepare(this);
      updateMethods.update.call(this, payload);
      this[OPTION_UPDATED] = false;
    } else {
      updateMethods[updateMethod].call(this, payload);
    }
  } // Follow the rule of action batch


  if (batched) {
    eventObj = {
      type: actionInfo.event || payloadType,
      escapeConnect: escapeConnect,
      batch: eventObjBatch
    };
  } else {
    eventObj = eventObjBatch[0];
  }

  this[IN_MAIN_PROCESS] = false;
  !silent && this._messageCenter.trigger(eventObj.type, eventObj);
}

function flushPendingActions(silent) {
  var pendingActions = this._pendingActions;

  while (pendingActions.length) {
    var payload = pendingActions.shift();
    doDispatchAction.call(this, payload, silent);
  }
}

function triggerUpdatedEvent(silent) {
  !silent && this.trigger('updated');
}
/**
 * Event `rendered` is triggered when zr
 * rendered. It is useful for realtime
 * snapshot (reflect animation).
 *
 * Event `finished` is triggered when:
 * (1) zrender rendering finished.
 * (2) initial animation finished.
 * (3) progressive rendering finished.
 * (4) no pending action.
 * (5) no delayed setOption needs to be processed.
 */


function bindRenderedEvent(zr, ecIns) {
  zr.on('rendered', function () {
    ecIns.trigger('rendered'); // The `finished` event should not be triggered repeatly,
    // so it should only be triggered when rendering indeed happend
    // in zrender. (Consider the case that dipatchAction is keep
    // triggering when mouse move).

    if ( // Although zr is dirty if initial animation is not finished
    // and this checking is called on frame, we also check
    // animation finished for robustness.
    zr.animation.isFinished() && !ecIns[OPTION_UPDATED] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
      ecIns.trigger('finished');
    }
  });
}
/**
 * @param {Object} params
 * @param {number} params.seriesIndex
 * @param {Array|TypedArray} params.data
 */


echartsProto.appendData = function (params) {
  var seriesIndex = params.seriesIndex;
  var ecModel = this.getModel();
  var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
  seriesModel.appendData(params); // Note: `appendData` does not support that update extent of coordinate
  // system, util some scenario require that. In the expected usage of
  // `appendData`, the initial extent of coordinate system should better
  // be fixed by axis `min`/`max` setting or initial data, otherwise if
  // the extent changed while `appendData`, the location of the painted
  // graphic elements have to be changed, which make the usage of
  // `appendData` meaningless.

  this._scheduler.unfinished = true;
};
/**
 * Register event
 * @method
 */


echartsProto.on = createRegisterEventWithLowercaseName('on');
echartsProto.off = createRegisterEventWithLowercaseName('off');
echartsProto.one = createRegisterEventWithLowercaseName('one');
/**
 * Prepare view instances of charts and components
 * @param  {module:echarts/model/Global} ecModel
 * @private
 */

function prepareView(ecIns, type, ecModel, scheduler) {
  var isComponent = type === 'component';
  var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
  var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
  var zr = ecIns._zr;
  var api = ecIns._api;

  for (var i = 0; i < viewList.length; i++) {
    viewList[i].__alive = false;
  }

  isComponent ? ecModel.eachComponent(function (componentType, model) {
    componentType !== 'series' && doPrepare(model);
  }) : ecModel.eachSeries(doPrepare);

  function doPrepare(model) {
    // Consider: id same and type changed.
    var viewId = '_ec_' + model.id + '_' + model.type;
    var view = viewMap[viewId];

    if (!view) {
      var classType = parseClassType(model.type);
      var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);
      view = new Clazz();
      view.init(ecModel, api);
      viewMap[viewId] = view;
      viewList.push(view);
      zr.add(view.group);
    }

    model.__viewId = view.__id = viewId;
    view.__alive = true;
    view.__model = model;
    view.group.__ecComponentInfo = {
      mainType: model.mainType,
      index: model.componentIndex
    };
    !isComponent && scheduler.prepareView(view, model, ecModel, api);
  }

  for (var i = 0; i < viewList.length;) {
    var view = viewList[i];

    if (!view.__alive) {
      !isComponent && view.renderTask.dispose();
      zr.remove(view.group);
      view.dispose(ecModel, api);
      viewList.splice(i, 1);
      delete viewMap[view.__id];
      view.__id = view.group.__ecComponentInfo = null;
    } else {
      i++;
    }
  }
} // /**
//  * Encode visual infomation from data after data processing
//  *
//  * @param {module:echarts/model/Global} ecModel
//  * @param {object} layout
//  * @param {boolean} [layoutFilter] `true`: only layout,
//  *                                 `false`: only not layout,
//  *                                 `null`/`undefined`: all.
//  * @param {string} taskBaseTag
//  * @private
//  */
// function startVisualEncoding(ecIns, ecModel, api, payload, layoutFilter) {
//     each(visualFuncs, function (visual, index) {
//         var isLayout = visual.isLayout;
//         if (layoutFilter == null
//             || (layoutFilter === false && !isLayout)
//             || (layoutFilter === true && isLayout)
//         ) {
//             visual.func(ecModel, api, payload);
//         }
//     });
// }


function clearColorPalette(ecModel) {
  ecModel.clearColorPalette();
  ecModel.eachSeries(function (seriesModel) {
    seriesModel.clearColorPalette();
  });
}

function render(ecIns, ecModel, api, payload) {
  renderComponents(ecIns, ecModel, api, payload);
  each(ecIns._chartsViews, function (chart) {
    chart.__alive = false;
  });
  renderSeries(ecIns, ecModel, api, payload); // Remove groups of unrendered charts

  each(ecIns._chartsViews, function (chart) {
    if (!chart.__alive) {
      chart.remove(ecModel, api);
    }
  });
}

function renderComponents(ecIns, ecModel, api, payload, dirtyList) {
  each(dirtyList || ecIns._componentsViews, function (componentView) {
    var componentModel = componentView.__model;
    componentView.render(componentModel, ecModel, api, payload);
    updateZ(componentModel, componentView);
  });
}
/**
 * Render each chart and component
 * @private
 */


function renderSeries(ecIns, ecModel, api, payload, dirtyMap) {
  // Render all charts
  var scheduler = ecIns._scheduler;
  var unfinished;
  ecModel.eachSeries(function (seriesModel) {
    var chartView = ecIns._chartsMap[seriesModel.__viewId];
    chartView.__alive = true;
    var renderTask = chartView.renderTask;
    scheduler.updatePayload(renderTask, payload);

    if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
      renderTask.dirty();
    }

    unfinished |= renderTask.perform(scheduler.getPerformArgs(renderTask));
    chartView.group.silent = !!seriesModel.get('silent');
    updateZ(seriesModel, chartView);
    updateBlend(seriesModel, chartView);
  });
  scheduler.unfinished |= unfinished; // If use hover layer

  updateHoverLayerStatus(ecIns._zr, ecModel); // Add aria

  aria(ecIns._zr.dom, ecModel);
}

function performPostUpdateFuncs(ecModel, api) {
  each(postUpdateFuncs, function (func) {
    func(ecModel, api);
  });
}

var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];
/**
 * @private
 */

echartsProto._initEvents = function () {
  each(MOUSE_EVENT_NAMES, function (eveName) {
    this._zr.on(eveName, function (e) {
      var ecModel = this.getModel();
      var el = e.target;
      var params; // no e.target when 'globalout'.

      if (eveName === 'globalout') {
        params = {};
      } else if (el && el.dataIndex != null) {
        var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
        params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};
      } // If element has custom eventData of components
      else if (el && el.eventData) {
          params = zrUtil.extend({}, el.eventData);
        }

      if (params) {
        params.event = e;
        params.type = eveName;
        this.trigger(eveName, params);
      }
    }, this);
  }, this);
  each(eventActionMap, function (actionType, eventType) {
    this._messageCenter.on(eventType, function (event) {
      this.trigger(eventType, event);
    }, this);
  }, this);
};
/**
 * @return {boolean}
 */


echartsProto.isDisposed = function () {
  return this._disposed;
};
/**
 * Clear
 */


echartsProto.clear = function () {
  this.setOption({
    series: []
  }, true);
};
/**
 * Dispose instance
 */


echartsProto.dispose = function () {
  if (this._disposed) {
    return;
  }

  this._disposed = true;
  modelUtil.setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, '');
  var api = this._api;
  var ecModel = this._model;
  each(this._componentsViews, function (component) {
    component.dispose(ecModel, api);
  });
  each(this._chartsViews, function (chart) {
    chart.dispose(ecModel, api);
  }); // Dispose after all views disposed

  this._zr.dispose();

  delete instances[this.id];
};

zrUtil.mixin(ECharts, Eventful);

function updateHoverLayerStatus(zr, ecModel) {
  var storage = zr.storage;
  var elCount = 0;
  storage.traverse(function (el) {
    if (!el.isGroup) {
      elCount++;
    }
  });

  if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {
    storage.traverse(function (el) {
      if (!el.isGroup) {
        // Don't switch back.
        el.useHoverLayer = true;
      }
    });
  }
}
/**
 * Update chart progressive and blend.
 * @param {module:echarts/model/Series|module:echarts/model/Component} model
 * @param {module:echarts/view/Component|module:echarts/view/Chart} view
 */


function updateBlend(seriesModel, chartView) {
  var blendMode = seriesModel.get('blendMode') || null;
  chartView.group.traverse(function (el) {
    // FIXME marker and other components
    if (!el.isGroup) {
      // Only set if blendMode is changed. In case element is incremental and don't wan't to rerender.
      if (el.style.blend !== blendMode) {
        el.setStyle('blend', blendMode);
      }
    }

    if (el.eachPendingDisplayable) {
      el.eachPendingDisplayable(function (displayable) {
        displayable.setStyle('blend', blendMode);
      });
    }
  });
}
/**
 * @param {module:echarts/model/Series|module:echarts/model/Component} model
 * @param {module:echarts/view/Component|module:echarts/view/Chart} view
 */


function updateZ(model, view) {
  var z = model.get('z');
  var zlevel = model.get('zlevel'); // Set z and zlevel

  view.group.traverse(function (el) {
    if (el.type !== 'group') {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
    }
  });
}

function createExtensionAPI(ecInstance) {
  var coordSysMgr = ecInstance._coordSysMgr;
  return zrUtil.extend(new ExtensionAPI(ecInstance), {
    // Inject methods
    getCoordinateSystems: zrUtil.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),
    getComponentByElement: function (el) {
      while (el) {
        var modelInfo = el.__ecComponentInfo;

        if (modelInfo != null) {
          return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);
        }

        el = el.parent;
      }
    }
  });
}
/**
 * @type {Object} key: actionType.
 * @inner
 */


var actions = {};
/**
 * Map eventType to actionType
 * @type {Object}
 */

var eventActionMap = {};
/**
 * Data processor functions of each stage
 * @type {Array.<Object.<string, Function>>}
 * @inner
 */

var dataProcessorFuncs = [];
/**
 * @type {Array.<Function>}
 * @inner
 */

var optionPreprocessorFuncs = [];
/**
 * @type {Array.<Function>}
 * @inner
 */

var postUpdateFuncs = [];
/**
 * Visual encoding functions of each stage
 * @type {Array.<Object.<string, Function>>}
 */

var visualFuncs = [];
/**
 * Theme storage
 * @type {Object.<key, Object>}
 */

var themeStorage = {};
/**
 * Loading effects
 */

var loadingEffects = {};
var instances = {};
var connectedGroups = {};
var idBase = new Date() - 0;
var groupIdBase = new Date() - 0;
var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
var mapDataStores = {};

function enableConnect(chart) {
  var STATUS_PENDING = 0;
  var STATUS_UPDATING = 1;
  var STATUS_UPDATED = 2;
  var STATUS_KEY = '__connectUpdateStatus';

  function updateConnectedChartsStatus(charts, status) {
    for (var i = 0; i < charts.length; i++) {
      var otherChart = charts[i];
      otherChart[STATUS_KEY] = status;
    }
  }

  each(eventActionMap, function (actionType, eventType) {
    chart._messageCenter.on(eventType, function (event) {
      if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
        if (event && event.escapeConnect) {
          return;
        }

        var action = chart.makeActionFromEvent(event);
        var otherCharts = [];
        each(instances, function (otherChart) {
          if (otherChart !== chart && otherChart.group === chart.group) {
            otherCharts.push(otherChart);
          }
        });
        updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
        each(otherCharts, function (otherChart) {
          if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
            otherChart.dispatchAction(action);
          }
        });
        updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
      }
    });
  });
}
/**
 * @param {HTMLElement} dom
 * @param {Object} [theme]
 * @param {Object} opts
 * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default
 * @param {string} [opts.renderer] Currently only 'canvas' is supported.
 * @param {number} [opts.width] Use clientWidth of the input `dom` by default.
 *                              Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Use clientHeight of the input `dom` by default.
 *                               Can be 'auto' (the same as null/undefined)
 */


function init(dom, theme, opts) {
  var existInstance = getInstanceByDom(dom);

  if (existInstance) {
    return existInstance;
  }

  var chart = new ECharts(dom, theme, opts);
  chart.id = 'ec_' + idBase++;
  instances[chart.id] = chart;
  modelUtil.setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
  enableConnect(chart);
  return chart;
}
/**
 * @return {string|Array.<module:echarts~ECharts>} groupId
 */


function connect(groupId) {
  // Is array of charts
  if (zrUtil.isArray(groupId)) {
    var charts = groupId;
    groupId = null; // If any chart has group

    each(charts, function (chart) {
      if (chart.group != null) {
        groupId = chart.group;
      }
    });
    groupId = groupId || 'g_' + groupIdBase++;
    each(charts, function (chart) {
      chart.group = groupId;
    });
  }

  connectedGroups[groupId] = true;
  return groupId;
}
/**
 * @DEPRECATED
 * @return {string} groupId
 */


function disConnect(groupId) {
  connectedGroups[groupId] = false;
}
/**
 * @return {string} groupId
 */


var disconnect = disConnect;
/**
 * Dispose a chart instance
 * @param  {module:echarts~ECharts|HTMLDomElement|string} chart
 */

function dispose(chart) {
  if (typeof chart === 'string') {
    chart = instances[chart];
  } else if (!(chart instanceof ECharts)) {
    // Try to treat as dom
    chart = getInstanceByDom(chart);
  }

  if (chart instanceof ECharts && !chart.isDisposed()) {
    chart.dispose();
  }
}
/**
 * @param  {HTMLElement} dom
 * @return {echarts~ECharts}
 */


function getInstanceByDom(dom) {
  return instances[modelUtil.getAttribute(dom, DOM_ATTRIBUTE_KEY)];
}
/**
 * @param {string} key
 * @return {echarts~ECharts}
 */


function getInstanceById(key) {
  return instances[key];
}
/**
 * Register theme
 */


function registerTheme(name, theme) {
  themeStorage[name] = theme;
}
/**
 * Register option preprocessor
 * @param {Function} preprocessorFunc
 */


function registerPreprocessor(preprocessorFunc) {
  optionPreprocessorFuncs.push(preprocessorFunc);
}
/**
 * @param {number} [priority=1000]
 * @param {Object|Function} processor
 */


function registerProcessor(priority, processor) {
  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_FILTER);
}
/**
 * Register postUpdater
 * @param {Function} postUpdateFunc
 */


function registerPostUpdate(postUpdateFunc) {
  postUpdateFuncs.push(postUpdateFunc);
}
/**
 * Usage:
 * registerAction('someAction', 'someEvent', function () { ... });
 * registerAction('someAction', function () { ... });
 * registerAction(
 *     {type: 'someAction', event: 'someEvent', update: 'updateView'},
 *     function () { ... }
 * );
 *
 * @param {(string|Object)} actionInfo
 * @param {string} actionInfo.type
 * @param {string} [actionInfo.event]
 * @param {string} [actionInfo.update]
 * @param {string} [eventName]
 * @param {Function} action
 */


function registerAction(actionInfo, eventName, action) {
  if (typeof eventName === 'function') {
    action = eventName;
    eventName = '';
  }

  var actionType = isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
    event: eventName
  }][0]; // Event name is all lowercase

  actionInfo.event = (actionInfo.event || actionType).toLowerCase();
  eventName = actionInfo.event; // Validate action type and event name.

  assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));

  if (!actions[actionType]) {
    actions[actionType] = {
      action: action,
      actionInfo: actionInfo
    };
  }

  eventActionMap[eventName] = actionType;
}
/**
 * @param {string} type
 * @param {*} CoordinateSystem
 */


function registerCoordinateSystem(type, CoordinateSystem) {
  CoordinateSystemManager.register(type, CoordinateSystem);
}
/**
 * Get dimensions of specified coordinate system.
 * @param {string} type
 * @return {Array.<string|Object>}
 */


function getCoordinateSystemDimensions(type) {
  var coordSysCreator = CoordinateSystemManager.get(type);

  if (coordSysCreator) {
    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
  }
}
/**
 * Layout is a special stage of visual encoding
 * Most visual encoding like color are common for different chart
 * But each chart has it's own layout algorithm
 *
 * @param {number} [priority=1000]
 * @param {Function} layoutTask
 */


function registerLayout(priority, layoutTask) {
  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, 'layout');
}
/**
 * @param {number} [priority=3000]
 * @param {module:echarts/stream/Task} visualTask
 */


function registerVisual(priority, visualTask) {
  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, 'visual');
}
/**
 * @param {Object|Function} fn: {seriesType, createOnAllSeries, performRawSeries, reset}
 */


function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
  if (isFunction(priority) || isObject(priority)) {
    fn = priority;
    priority = defaultPriority;
  }

  var stageHandler = Scheduler.wrapStageHandler(fn, visualType);
  stageHandler.__prio = priority;
  stageHandler.__raw = fn;
  targetList.push(stageHandler);
  return stageHandler;
}
/**
 * @param {string} name
 */


function registerLoading(name, loadingFx) {
  loadingEffects[name] = loadingFx;
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendComponentModel(opts
/*, superClass*/
) {
  // var Clazz = ComponentModel;
  // if (superClass) {
  //     var classType = parseClassType(superClass);
  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
  // }
  return ComponentModel.extend(opts);
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendComponentView(opts
/*, superClass*/
) {
  // var Clazz = ComponentView;
  // if (superClass) {
  //     var classType = parseClassType(superClass);
  //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);
  // }
  return ComponentView.extend(opts);
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendSeriesModel(opts
/*, superClass*/
) {
  // var Clazz = SeriesModel;
  // if (superClass) {
  //     superClass = 'series.' + superClass.replace('series.', '');
  //     var classType = parseClassType(superClass);
  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
  // }
  return SeriesModel.extend(opts);
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendChartView(opts
/*, superClass*/
) {
  // var Clazz = ChartView;
  // if (superClass) {
  //     superClass = superClass.replace('series.', '');
  //     var classType = parseClassType(superClass);
  //     Clazz = ChartView.getClass(classType.main, true);
  // }
  return ChartView.extend(opts);
}
/**
 * ZRender need a canvas context to do measureText.
 * But in node environment canvas may be created by node-canvas.
 * So we need to specify how to create a canvas instead of using document.createElement('canvas')
 *
 * Be careful of using it in the browser.
 *
 * @param {Function} creator
 * @example
 *     var Canvas = require('canvas');
 *     var echarts = require('echarts');
 *     echarts.setCanvasCreator(function () {
 *         // Small size is enough.
 *         return new Canvas(32, 32);
 *     });
 */


function setCanvasCreator(creator) {
  zrUtil.$override('createCanvas', creator);
}
/**
 * @param {string} mapName
 * @param {Object|string} geoJson
 * @param {Object} [specialAreas]
 *
 * @example
 *     $.get('USA.json', function (geoJson) {
 *         echarts.registerMap('USA', geoJson);
 *         // Or
 *         echarts.registerMap('USA', {
 *             geoJson: geoJson,
 *             specialAreas: {}
 *         })
 *     });
 */


function registerMap(mapName, geoJson, specialAreas) {
  if (geoJson.geoJson && !geoJson.features) {
    specialAreas = geoJson.specialAreas;
    geoJson = geoJson.geoJson;
  }

  if (typeof geoJson === 'string') {
    geoJson = typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(geoJson) : new Function('return (' + geoJson + ');')();
  }

  mapDataStores[mapName] = {
    geoJson: geoJson,
    specialAreas: specialAreas
  };
}
/**
 * @param {string} mapName
 * @return {Object}
 */


function getMap(mapName) {
  return mapDataStores[mapName];
}

registerVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);
registerPreprocessor(backwardCompat);
registerProcessor(PRIORITY_PROCESSOR_STATISTIC, dataStack);
registerLoading('default', loadingDefault); // Default actions

registerAction({
  type: 'highlight',
  event: 'highlight',
  update: 'highlight'
}, zrUtil.noop);
registerAction({
  type: 'downplay',
  event: 'downplay',
  update: 'downplay'
}, zrUtil.noop); // Default theme

registerTheme('light', lightTheme);
registerTheme('dark', darkTheme); // For backward compatibility, where the namespace `dataTool` will
// be mounted on `echarts` is the extension `dataTool` is imported.

var dataTool = {};
exports.version = version;
exports.dependencies = dependencies;
exports.PRIORITY = PRIORITY;
exports.init = init;
exports.connect = connect;
exports.disConnect = disConnect;
exports.disconnect = disconnect;
exports.dispose = dispose;
exports.getInstanceByDom = getInstanceByDom;
exports.getInstanceById = getInstanceById;
exports.registerTheme = registerTheme;
exports.registerPreprocessor = registerPreprocessor;
exports.registerProcessor = registerProcessor;
exports.registerPostUpdate = registerPostUpdate;
exports.registerAction = registerAction;
exports.registerCoordinateSystem = registerCoordinateSystem;
exports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;
exports.registerLayout = registerLayout;
exports.registerVisual = registerVisual;
exports.registerLoading = registerLoading;
exports.extendComponentModel = extendComponentModel;
exports.extendComponentView = extendComponentView;
exports.extendSeriesModel = extendSeriesModel;
exports.extendChartView = extendChartView;
exports.setCanvasCreator = setCanvasCreator;
exports.registerMap = registerMap;
exports.getMap = getMap;
exports.dataTool = dataTool;
var ___ec_export = __webpack_require__("./node_modules/echarts/lib/export.js");
(function () {
    for (var key in ___ec_export) {
        if (___ec_export.hasOwnProperty(key)) {
            exports[key] = ___ec_export[key];
        }
    }
})();

/***/ }),

/***/ "./node_modules/echarts/lib/export.js":
/***/ (function(module, exports, __webpack_require__) {

var zrender = __webpack_require__("./node_modules/zrender/lib/zrender.js");

exports.zrender = zrender;

var matrix = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

exports.matrix = matrix;

var vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

exports.vector = vector;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var colorTool = __webpack_require__("./node_modules/zrender/lib/tool/color.js");

exports.color = colorTool;

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

exports.graphic = graphic;

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

exports.number = numberUtil;

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

exports.format = formatUtil;

var _throttle = __webpack_require__("./node_modules/echarts/lib/util/throttle.js");

var throttle = _throttle.throttle;
exports.throttle = _throttle.throttle;

var ecHelper = __webpack_require__("./node_modules/echarts/lib/helper.js");

exports.helper = ecHelper;

var parseGeoJSON = __webpack_require__("./node_modules/echarts/lib/coord/geo/parseGeoJson.js");

exports.parseGeoJSON = parseGeoJSON;

var _List = __webpack_require__("./node_modules/echarts/lib/data/List.js");

exports.List = _List;

var _Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

exports.Model = _Model;

var _Axis = __webpack_require__("./node_modules/echarts/lib/coord/Axis.js");

exports.Axis = _Axis;

var _env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

exports.env = _env;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Do not mount those modules on 'src/echarts' for better tree shaking.
 */
var parseGeoJson = parseGeoJSON;
var ecUtil = {};
zrUtil.each(['map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults', 'clone', 'merge'], function (name) {
  ecUtil[name] = zrUtil[name];
});
exports.parseGeoJson = parseGeoJson;
exports.util = ecUtil;

/***/ }),

/***/ "./node_modules/echarts/lib/helper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var createListFromArray = __webpack_require__("./node_modules/echarts/lib/chart/helper/createListFromArray.js");

var axisHelper = __webpack_require__("./node_modules/echarts/lib/coord/axisHelper.js");

var axisModelCommonMixin = __webpack_require__("./node_modules/echarts/lib/coord/axisModelCommonMixin.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutRect = _layout.getLayoutRect;
exports.getLayoutRect = _layout.getLayoutRect;

var _dataStackHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/dataStackHelper.js");

var enableDataStack = _dataStackHelper.enableDataStack;
var isDimensionStacked = _dataStackHelper.isDimensionStacked;
var getStackedDimension = _dataStackHelper.getStackedDimension;

var _completeDimensions = __webpack_require__("./node_modules/echarts/lib/data/helper/completeDimensions.js");

exports.completeDimensions = _completeDimensions;

var _createDimensions = __webpack_require__("./node_modules/echarts/lib/data/helper/createDimensions.js");

exports.createDimensions = _createDimensions;

var _symbol = __webpack_require__("./node_modules/echarts/lib/util/symbol.js");

exports.createSymbol = _symbol.createSymbol;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// import createGraphFromNodeEdge from './chart/helper/createGraphFromNodeEdge';

/**
 * Create a muti dimension List structure from seriesModel.
 * @param  {module:echarts/model/Model} seriesModel
 * @return {module:echarts/data/List} list
 */
function createList(seriesModel) {
  return createListFromArray(seriesModel.getSource(), seriesModel);
} // export function createGraph(seriesModel) {
//     var nodes = seriesModel.get('data');
//     var links = seriesModel.get('links');
//     return createGraphFromNodeEdge(nodes, links, seriesModel);
// }


var dataStack = {
  isDimensionStacked: isDimensionStacked,
  enableDataStack: enableDataStack,
  getStackedDimension: getStackedDimension
};
/**
 * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
 * @see http://echarts.baidu.com/option.html#series-scatter.symbol
 * @param {string} symbolDesc
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {string} color
 */

/**
 * Create scale
 * @param {Array.<number>} dataExtent
 * @param {Object|module:echarts/Model} option
 */
function createScale(dataExtent, option) {
  var axisModel = option;

  if (!Model.isInstance(option)) {
    axisModel = new Model(option);
    zrUtil.mixin(axisModel, axisModelCommonMixin);
  }

  var scale = axisHelper.createScaleByModel(axisModel);
  scale.setExtent(dataExtent[0], dataExtent[1]);
  axisHelper.niceScaleExtent(scale, axisModel);
  return scale;
}
/**
 * Mixin common methods to axis model,
 *
 * Inlcude methods
 * `getFormattedLabels() => Array.<string>`
 * `getCategories() => Array.<string>`
 * `getMin(origin: boolean) => number`
 * `getMax(origin: boolean) => number`
 * `getNeedCrossZero() => boolean`
 * `setRange(start: number, end: number)`
 * `resetRange()`
 */


function mixinAxisModelCommonMethods(Model) {
  zrUtil.mixin(Model, axisModelCommonMixin);
}

exports.createList = createList;
exports.dataStack = dataStack;
exports.createScale = createScale;
exports.mixinAxisModelCommonMethods = mixinAxisModelCommonMethods;

/***/ }),

/***/ "./node_modules/echarts/lib/lang.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = {
  toolbox: {
    brush: {
      title: {
        rect: '矩形选择',
        polygon: '圈选',
        lineX: '横向选择',
        lineY: '纵向选择',
        keep: '保持选择',
        clear: '清除选择'
      }
    },
    dataView: {
      title: '数据视图',
      lang: ['数据视图', '关闭', '刷新']
    },
    dataZoom: {
      title: {
        zoom: '区域缩放',
        back: '区域缩放还原'
      }
    },
    magicType: {
      title: {
        line: '切换为折线图',
        bar: '切换为柱状图',
        stack: '切换为堆叠',
        tiled: '切换为平铺'
      }
    },
    restore: {
      title: '还原'
    },
    saveAsImage: {
      title: '保存为图片',
      lang: ['右键另存为图片']
    }
  },
  series: {
    typeNames: {
      pie: '饼图',
      bar: '柱状图',
      line: '折线图',
      scatter: '散点图',
      effectScatter: '涟漪散点图',
      radar: '雷达图',
      tree: '树图',
      treemap: '矩形树图',
      boxplot: '箱型图',
      candlestick: 'K线图',
      k: 'K线图',
      heatmap: '热力图',
      map: '地图',
      parallel: '平行坐标图',
      lines: '线图',
      graph: '关系图',
      sankey: '桑基图',
      funnel: '漏斗图',
      gauge: '仪表盘图',
      pictorialBar: '象形柱图',
      themeRiver: '主题河流图',
      sunburst: '旭日图'
    }
  },
  aria: {
    general: {
      withTitle: '这是一个关于“{title}”的图表。',
      withoutTitle: '这是一个图表，'
    },
    series: {
      single: {
        prefix: '',
        withName: '图表类型是{seriesType}，表示{seriesName}。',
        withoutName: '图表类型是{seriesType}。'
      },
      multiple: {
        prefix: '它由{seriesCount}个图表系列组成。',
        withName: '第{seriesId}个系列是一个表示{seriesName}的{seriesType}，',
        withoutName: '第{seriesId}个系列是一个{seriesType}，',
        separator: {
          middle: '；',
          end: '。'
        }
      }
    },
    data: {
      allData: '其数据是——',
      partialData: '其中，前{displayCnt}项是——',
      withName: '{name}的数据是{value}',
      withoutName: '{value}',
      separator: {
        middle: '，',
        end: ''
      }
    }
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/layout/barGrid.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var parsePercent = _number.parsePercent;

var _dataStackHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/dataStackHelper.js");

var isDimensionStacked = _dataStackHelper.isDimensionStacked;

var createRenderPlanner = __webpack_require__("./node_modules/echarts/lib/chart/helper/createRenderPlanner.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var STACK_PREFIX = '__ec_stack_';
var LARGE_BAR_MIN_WIDTH = 0.5;
var LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;

function getSeriesStackId(seriesModel) {
  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;
}

function getAxisKey(axis) {
  return axis.dim + axis.index;
}
/**
 * @param {Object} opt
 * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.
 * @param {number} opt.count Positive interger.
 * @param {number} [opt.barWidth]
 * @param {number} [opt.barMaxWidth]
 * @param {number} [opt.barGap]
 * @param {number} [opt.barCategoryGap]
 * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
 */


function getLayoutOnAxis(opt) {
  var params = [];
  var baseAxis = opt.axis;
  var axisKey = 'axis0';

  if (baseAxis.type !== 'category') {
    return;
  }

  var bandWidth = baseAxis.getBandWidth();

  for (var i = 0; i < opt.count || 0; i++) {
    params.push(zrUtil.defaults({
      bandWidth: bandWidth,
      axisKey: axisKey,
      stackId: STACK_PREFIX + i
    }, opt));
  }

  var widthAndOffsets = doCalBarWidthAndOffset(params);
  var result = [];

  for (var i = 0; i < opt.count; i++) {
    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
    item.offsetCenter = item.offset + item.width / 2;
    result.push(item);
  }

  return result;
}

function prepareLayoutBarSeries(seriesType, ecModel) {
  var seriesModels = [];
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    // Check series coordinate, do layout for cartesian2d only
    if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {
      seriesModels.push(seriesModel);
    }
  });
  return seriesModels;
}

function makeColumnLayout(barSeries) {
  var seriesInfoList = [];
  zrUtil.each(barSeries, function (seriesModel) {
    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var axisExtent = baseAxis.getExtent();
    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);
    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);
    var barGap = seriesModel.get('barGap');
    var barCategoryGap = seriesModel.get('barCategoryGap');
    seriesInfoList.push({
      bandWidth: bandWidth,
      barWidth: barWidth,
      barMaxWidth: barMaxWidth,
      barGap: barGap,
      barCategoryGap: barCategoryGap,
      axisKey: getAxisKey(baseAxis),
      stackId: getSeriesStackId(seriesModel)
    });
  });
  return doCalBarWidthAndOffset(seriesInfoList);
}

function doCalBarWidthAndOffset(seriesInfoList) {
  // Columns info on each category axis. Key is cartesian name
  var columnsMap = {};
  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {
    var axisKey = seriesInfo.axisKey;
    var bandWidth = seriesInfo.bandWidth;
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth: bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: '20%',
      gap: '30%',
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = seriesInfo.stackId;

    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }

    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    }; // Caution: In a single coordinate system, these barGrid attributes
    // will be shared by series. Consider that they have default values,
    // only the attributes set on the last series will work.
    // Do not change this fact unless there will be a break change.
    // TODO

    var barWidth = seriesInfo.barWidth;

    if (barWidth && !stacks[stackId].width) {
      // See #6312, do not restrict width.
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }

    var barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    var barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    var barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth

    zrUtil.each(stacks, function (column, stack) {
      var maxWidth = column.maxWidth;

      if (maxWidth && maxWidth < autoWidth) {
        maxWidth = Math.min(maxWidth, remainedWidth);

        if (column.width) {
          maxWidth = Math.min(maxWidth, column.width);
        }

        remainedWidth -= maxWidth;
        column.width = maxWidth;
        autoWidthCount--;
      }
    }); // Recalculate width again

    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    zrUtil.each(stacks, function (column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }

      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });

    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }

    var offset = -widthSum / 2;
    zrUtil.each(stacks, function (column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        offset: offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
/**
 * @param {Object} barWidthAndOffset The result of makeColumnLayout
 * @param {module:echarts/coord/Axis} axis
 * @param {module:echarts/model/Series} [seriesModel] If not provided, return all.
 * @return {Object} {stackId: {offset, width}} or {offset, width} if seriesModel provided.
 */


function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
  if (barWidthAndOffset && axis) {
    var result = barWidthAndOffset[getAxisKey(axis)];

    if (result != null && seriesModel != null) {
      result = result[getSeriesStackId(seriesModel)];
    }

    return result;
  }
}
/**
 * @param {string} seriesType
 * @param {module:echarts/model/Global} ecModel
 */


function layout(seriesType, ecModel) {
  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);
  var barWidthAndOffset = makeColumnLayout(seriesModels);
  var lastStackCoords = {};
  var lastStackCoordsOrigin = {};
  zrUtil.each(seriesModels, function (seriesModel) {
    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var stackId = getSeriesStackId(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    var valueAxis = cartesian.getOtherAxis(baseAxis);
    var barMinHeight = seriesModel.get('barMinHeight') || 0;
    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243

    data.setLayout({
      offset: columnOffset,
      size: columnWidth
    });
    var valueDim = data.mapDimension(valueAxis.dim);
    var baseDim = data.mapDimension(baseAxis.dim);
    var stacked = isDimensionStacked(data, valueDim
    /*, baseDim*/
    );
    var isValueAxisH = valueAxis.isHorizontal();
    var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);

    for (var idx = 0, len = data.count(); idx < len; idx++) {
      var value = data.get(valueDim, idx);
      var baseValue = data.get(baseDim, idx);

      if (isNaN(value)) {
        continue;
      }

      var sign = value >= 0 ? 'p' : 'n';
      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in
      // stackResultDimension directly.

      if (stacked) {
        // Only ordinal axis can be stacked.
        if (!lastStackCoords[stackId][baseValue]) {
          lastStackCoords[stackId][baseValue] = {
            p: valueAxisStart,
            // Positive stack
            n: valueAxisStart // Negative stack

          };
        } // Should also consider #4243


        baseCoord = lastStackCoords[stackId][baseValue][sign];
      }

      var x;
      var y;
      var width;
      var height;

      if (isValueAxisH) {
        var coord = cartesian.dataToPoint([value, baseValue]);
        x = baseCoord;
        y = coord[1] + columnOffset;
        width = coord[0] - valueAxisStart;
        height = columnWidth;

        if (Math.abs(width) < barMinHeight) {
          width = (width < 0 ? -1 : 1) * barMinHeight;
        }

        stacked && (lastStackCoords[stackId][baseValue][sign] += width);
      } else {
        var coord = cartesian.dataToPoint([baseValue, value]);
        x = coord[0] + columnOffset;
        y = baseCoord;
        width = columnWidth;
        height = coord[1] - valueAxisStart;

        if (Math.abs(height) < barMinHeight) {
          // Include zero to has a positive bar
          height = (height <= 0 ? -1 : 1) * barMinHeight;
        }

        stacked && (lastStackCoords[stackId][baseValue][sign] += height);
      }

      data.setItemLayout(idx, {
        x: x,
        y: y,
        width: width,
        height: height
      });
    }
  }, this);
} // TODO: Do not support stack in large mode yet.


var largeLayout = {
  seriesType: 'bar',
  plan: createRenderPlanner(),
  reset: function (seriesModel) {
    if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {
      return;
    }

    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var valueAxis = cartesian.getOtherAxis(baseAxis);
    var valueDim = data.mapDimension(valueAxis.dim);
    var baseDim = data.mapDimension(baseAxis.dim);
    var valueAxisHorizontal = valueAxis.isHorizontal();
    var valueDimIdx = valueAxisHorizontal ? 0 : 1;
    var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;

    if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {
      // jshint ignore:line
      barWidth = LARGE_BAR_MIN_WIDTH;
    }

    return {
      progress: progress
    };

    function progress(params, data) {
      var largePoints = new LargeArr(params.count * 2);
      var dataIndex;
      var coord = [];
      var valuePair = [];
      var offset = 0;

      while ((dataIndex = params.next()) != null) {
        valuePair[valueDimIdx] = data.get(valueDim, dataIndex);
        valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);
        coord = cartesian.dataToPoint(valuePair, null, coord);
        largePoints[offset++] = coord[0];
        largePoints[offset++] = coord[1];
      }

      data.setLayout({
        largePoints: largePoints,
        barWidth: barWidth,
        valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),
        valueAxisHorizontal: valueAxisHorizontal
      });
    }
  }
};

function isOnCartesian(seriesModel) {
  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';
}

function isInLargeMode(seriesModel) {
  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
}

function getValueAxisStart(baseAxis, valueAxis, stacked) {
  return zrUtil.indexOf(baseAxis.getAxesOnZeroOf(), valueAxis) >= 0 || stacked ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];
}

exports.getLayoutOnAxis = getLayoutOnAxis;
exports.prepareLayoutBarSeries = prepareLayoutBarSeries;
exports.makeColumnLayout = makeColumnLayout;
exports.retrieveColumnLayout = retrieveColumnLayout;
exports.layout = layout;
exports.largeLayout = largeLayout;

/***/ }),

/***/ "./node_modules/echarts/lib/layout/points.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var map = _util.map;

var createRenderPlanner = __webpack_require__("./node_modules/echarts/lib/chart/helper/createRenderPlanner.js");

var _dataStackHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/dataStackHelper.js");

var isDimensionStacked = _dataStackHelper.isDimensionStacked;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function _default(seriesType) {
  return {
    seriesType: seriesType,
    plan: createRenderPlanner(),
    reset: function (seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var pipelineContext = seriesModel.pipelineContext;
      var isLargeRender = pipelineContext.large;

      if (!coordSys) {
        return;
      }

      var dims = map(coordSys.dimensions, function (dim) {
        return data.mapDimension(dim);
      }).slice(0, 2);
      var dimLen = dims.length;
      var stackResultDim = data.getCalculationInfo('stackResultDimension');

      if (isDimensionStacked(data, dims[0]
      /*, dims[1]*/
      )) {
        dims[0] = stackResultDim;
      }

      if (isDimensionStacked(data, dims[1]
      /*, dims[0]*/
      )) {
        dims[1] = stackResultDim;
      }

      function progress(params, data) {
        var segCount = params.end - params.start;
        var points = isLargeRender && new Float32Array(segCount * dimLen);

        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {
          var point;

          if (dimLen === 1) {
            var x = data.get(dims[0], i);
            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);
          } else {
            var x = tmpIn[0] = data.get(dims[0], i);
            var y = tmpIn[1] = data.get(dims[1], i); // Also {Array.<number>}, not undefined to avoid if...else... statement

            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);
          }

          if (isLargeRender) {
            points[offset++] = point ? point[0] : NaN;
            points[offset++] = point ? point[1] : NaN;
          } else {
            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);
          }
        }

        isLargeRender && data.setLayout('symbolPoints', points);
      }

      return dimLen && {
        progress: progress
      };
    }
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/loading/default.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var PI = Math.PI;
/**
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} [opts]
 * @param {string} [opts.text]
 * @param {string} [opts.color]
 * @param {string} [opts.textColor]
 * @return {module:zrender/Element}
 */

function _default(api, opts) {
  opts = opts || {};
  zrUtil.defaults(opts, {
    text: 'loading',
    color: '#c23531',
    textColor: '#000',
    maskColor: 'rgba(255, 255, 255, 0.8)',
    zlevel: 0
  });
  var mask = new graphic.Rect({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 10000
  });
  var arc = new graphic.Arc({
    shape: {
      startAngle: -PI / 2,
      endAngle: -PI / 2 + 0.1,
      r: 10
    },
    style: {
      stroke: opts.color,
      lineCap: 'round',
      lineWidth: 5
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  var labelRect = new graphic.Rect({
    style: {
      fill: 'none',
      text: opts.text,
      textPosition: 'right',
      textDistance: 10,
      textFill: opts.textColor
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  arc.animateShape(true).when(1000, {
    endAngle: PI * 3 / 2
  }).start('circularInOut');
  arc.animateShape(true).when(1000, {
    startAngle: PI * 3 / 2
  }).delay(300).start('circularInOut');
  var group = new graphic.Group();
  group.add(arc);
  group.add(labelRect);
  group.add(mask); // Inject resize

  group.resize = function () {
    var cx = api.getWidth() / 2;
    var cy = api.getHeight() / 2;
    arc.setShape({
      cx: cx,
      cy: cy
    });
    var r = arc.shape.r;
    labelRect.setShape({
      x: cx - r,
      y: cy - r,
      width: r * 2,
      height: r * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api.getWidth(),
      height: api.getHeight()
    });
  };

  group.resize();
  return group;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/Component.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var componentUtil = __webpack_require__("./node_modules/echarts/lib/util/component.js");

var _clazz = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var enableClassManagement = _clazz.enableClassManagement;
var parseClassType = _clazz.parseClassType;

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var makeInner = _model.makeInner;

var layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var boxLayoutMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/boxLayout.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Component model
 *
 * @module echarts/model/Component
 */
var inner = makeInner();
/**
 * @alias module:echarts/model/Component
 * @constructor
 * @param {Object} option
 * @param {module:echarts/model/Model} parentModel
 * @param {module:echarts/model/Model} ecModel
 */

var ComponentModel = Model.extend({
  type: 'component',

  /**
   * @readOnly
   * @type {string}
   */
  id: '',

  /**
   * Because simplified concept is probably better, series.name (or component.name)
   * has been having too many resposibilities:
   * (1) Generating id (which requires name in option should not be modified).
   * (2) As an index to mapping series when merging option or calling API (a name
   * can refer to more then one components, which is convinient is some case).
   * (3) Display.
   * @readOnly
   */
  name: '',

  /**
   * @readOnly
   * @type {string}
   */
  mainType: '',

  /**
   * @readOnly
   * @type {string}
   */
  subType: '',

  /**
   * @readOnly
   * @type {number}
   */
  componentIndex: 0,

  /**
   * @type {Object}
   * @protected
   */
  defaultOption: null,

  /**
   * @type {module:echarts/model/Global}
   * @readOnly
   */
  ecModel: null,

  /**
   * key: componentType
   * value:  Component model list, can not be null.
   * @type {Object.<string, Array.<module:echarts/model/Model>>}
   * @readOnly
   */
  dependentModels: [],

  /**
   * @type {string}
   * @readOnly
   */
  uid: null,

  /**
   * Support merge layout params.
   * Only support 'box' now (left/right/top/bottom/width/height).
   * @type {string|Object} Object can be {ignoreSize: true}
   * @readOnly
   */
  layoutMode: null,
  $constructor: function (option, parentModel, ecModel, extraOpt) {
    Model.call(this, option, parentModel, ecModel, extraOpt);
    this.uid = componentUtil.getUID('ec_cpt_model');
  },
  init: function (option, parentModel, ecModel, extraOpt) {
    this.mergeDefaultAndTheme(option, ecModel);
  },
  mergeDefaultAndTheme: function (option, ecModel) {
    var layoutMode = this.layoutMode;
    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
    var themeModel = ecModel.getTheme();
    zrUtil.merge(option, themeModel.get(this.mainType));
    zrUtil.merge(option, this.getDefaultOption());

    if (layoutMode) {
      layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  },
  mergeOption: function (option, extraOpt) {
    zrUtil.merge(this.option, option, true);
    var layoutMode = this.layoutMode;

    if (layoutMode) {
      layout.mergeLayoutParam(this.option, option, layoutMode);
    }
  },
  // Hooker after init or mergeOption
  optionUpdated: function (newCptOption, isInit) {},
  getDefaultOption: function () {
    var fields = inner(this);

    if (!fields.defaultOption) {
      var optList = [];
      var Class = this.constructor;

      while (Class) {
        var opt = Class.prototype.defaultOption;
        opt && optList.push(opt);
        Class = Class.superClass;
      }

      var defaultOption = {};

      for (var i = optList.length - 1; i >= 0; i--) {
        defaultOption = zrUtil.merge(defaultOption, optList[i], true);
      }

      fields.defaultOption = defaultOption;
    }

    return fields.defaultOption;
  },
  getReferringComponents: function (mainType) {
    return this.ecModel.queryComponents({
      mainType: mainType,
      index: this.get(mainType + 'Index', true),
      id: this.get(mainType + 'Id', true)
    });
  }
}); // Reset ComponentModel.extend, add preConstruct.
// clazzUtil.enableClassExtend(
//     ComponentModel,
//     function (option, parentModel, ecModel, extraOpt) {
//         // Set dependentModels, componentIndex, name, id, mainType, subType.
//         zrUtil.extend(this, extraOpt);
//         this.uid = componentUtil.getUID('componentModel');
//         // this.setReadOnly([
//         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',
//         //     'dependentModels', 'componentIndex'
//         // ]);
//     }
// );
// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

enableClassManagement(ComponentModel, {
  registerWhenExtend: true
});
componentUtil.enableSubTypeDefaulter(ComponentModel); // Add capability of ComponentModel.topologicalTravel.

componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);

function getDependencies(componentType) {
  var deps = [];
  zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {
    deps = deps.concat(Clazz.prototype.dependencies || []);
  }); // Ensure main type.

  deps = zrUtil.map(deps, function (type) {
    return parseClassType(type).main;
  }); // Hack dataset for convenience.

  if (componentType !== 'dataset' && zrUtil.indexOf(deps, 'dataset') <= 0) {
    deps.unshift('dataset');
  }

  return deps;
}

zrUtil.mixin(ComponentModel, boxLayoutMixin);
var _default = ComponentModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/Global.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var each = _util.each;
var filter = _util.filter;
var map = _util.map;
var isArray = _util.isArray;
var indexOf = _util.indexOf;
var isObject = _util.isObject;
var isString = _util.isString;
var createHashMap = _util.createHashMap;
var assert = _util.assert;
var clone = _util.clone;
var merge = _util.merge;
var extend = _util.extend;
var mixin = _util.mixin;

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var Model = __webpack_require__("./node_modules/echarts/lib/model/Model.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var globalDefault = __webpack_require__("./node_modules/echarts/lib/model/globalDefault.js");

var colorPaletteMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/colorPalette.js");

var _sourceHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/sourceHelper.js");

var resetSourceDefaulter = _sourceHelper.resetSourceDefaulter;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * ECharts global model
 *
 * @module {echarts/model/Global}
 */

/**
 * Caution: If the mechanism should be changed some day, these cases
 * should be considered:
 *
 * (1) In `merge option` mode, if using the same option to call `setOption`
 * many times, the result should be the same (try our best to ensure that).
 * (2) In `merge option` mode, if a component has no id/name specified, it
 * will be merged by index, and the result sequence of the components is
 * consistent to the original sequence.
 * (3) `reset` feature (in toolbox). Find detailed info in comments about
 * `mergeOption` in module:echarts/model/OptionManager.
 */
var OPTION_INNER_KEY = '\0_ec_inner';
/**
 * @alias module:echarts/model/Global
 *
 * @param {Object} option
 * @param {module:echarts/model/Model} parentModel
 * @param {Object} theme
 */

var GlobalModel = Model.extend({
  init: function (option, parentModel, theme, optionManager) {
    theme = theme || {};
    this.option = null; // Mark as not initialized.

    /**
     * @type {module:echarts/model/Model}
     * @private
     */

    this._theme = new Model(theme);
    /**
     * @type {module:echarts/model/OptionManager}
     */

    this._optionManager = optionManager;
  },
  setOption: function (option, optionPreprocessorFuncs) {
    assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');

    this._optionManager.setOption(option, optionPreprocessorFuncs);

    this.resetOption(null);
  },

  /**
   * @param {string} type null/undefined: reset all.
   *                      'recreate': force recreate all.
   *                      'timeline': only reset timeline option
   *                      'media': only reset media query option
   * @return {boolean} Whether option changed.
   */
  resetOption: function (type) {
    var optionChanged = false;
    var optionManager = this._optionManager;

    if (!type || type === 'recreate') {
      var baseOption = optionManager.mountOption(type === 'recreate');

      if (!this.option || type === 'recreate') {
        initBase.call(this, baseOption);
      } else {
        this.restoreData();
        this.mergeOption(baseOption);
      }

      optionChanged = true;
    }

    if (type === 'timeline' || type === 'media') {
      this.restoreData();
    }

    if (!type || type === 'recreate' || type === 'timeline') {
      var timelineOption = optionManager.getTimelineOption(this);
      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
    }

    if (!type || type === 'recreate' || type === 'media') {
      var mediaOptions = optionManager.getMediaOption(this, this._api);

      if (mediaOptions.length) {
        each(mediaOptions, function (mediaOption) {
          this.mergeOption(mediaOption, optionChanged = true);
        }, this);
      }
    }

    return optionChanged;
  },

  /**
   * @protected
   */
  mergeOption: function (newOption) {
    var option = this.option;
    var componentsMap = this._componentsMap;
    var newCptTypes = [];
    resetSourceDefaulter(this); // If no component class, merge directly.
    // For example: color, animaiton options, etc.

    each(newOption, function (componentOption, mainType) {
      if (componentOption == null) {
        return;
      }

      if (!ComponentModel.hasClass(mainType)) {
        // globalSettingTask.dirty();
        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);
      } else if (mainType) {
        newCptTypes.push(mainType);
      }
    });
    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);

    function visitComponent(mainType, dependencies) {
      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);
      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);
      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.

      each(mapResult, function (item, index) {
        var opt = item.option;

        if (isObject(opt)) {
          item.keyInfo.mainType = mainType;
          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);
        }
      });
      var dependentModels = getComponentsByTypes(componentsMap, dependencies);
      option[mainType] = [];
      componentsMap.set(mainType, []);
      each(mapResult, function (resultItem, index) {
        var componentModel = resultItem.exist;
        var newCptOption = resultItem.option;
        assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},
        // see removeEdgeAndAdd in topologicalTravel and
        // ComponentModel.getAllClassMainTypes.

        if (!newCptOption) {
          componentModel.mergeOption({}, this);
          componentModel.optionUpdated({}, false);
        } else {
          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);

          if (componentModel && componentModel instanceof ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();

            componentModel.mergeOption(newCptOption, this);
            componentModel.optionUpdated(newCptOption, false);
          } else {
            // PENDING Global as parent ?
            var extraOpt = extend({
              dependentModels: dependentModels,
              componentIndex: index
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);
            extend(componentModel, extraOpt);
            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.
            // newCptOption has been used as componentModel.option
            // and may be merged with theme and default, so pass null
            // to avoid confusion.

            componentModel.optionUpdated(null, true);
          }
        }

        componentsMap.get(mainType)[index] = componentModel;
        option[mainType][index] = componentModel.option;
      }, this); // Backup series for filtering.

      if (mainType === 'series') {
        createSeriesIndices(this, componentsMap.get('series'));
      }
    }

    this._seriesIndicesMap = createHashMap(this._seriesIndices = this._seriesIndices || []);
  },

  /**
   * Get option for output (cloned option and inner info removed)
   * @public
   * @return {Object}
   */
  getOption: function () {
    var option = clone(this.option);
    each(option, function (opts, mainType) {
      if (ComponentModel.hasClass(mainType)) {
        var opts = modelUtil.normalizeToArray(opts);

        for (var i = opts.length - 1; i >= 0; i--) {
          // Remove options with inner id.
          if (modelUtil.isIdInner(opts[i])) {
            opts.splice(i, 1);
          }
        }

        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  },

  /**
   * @return {module:echarts/model/Model}
   */
  getTheme: function () {
    return this._theme;
  },

  /**
   * @param {string} mainType
   * @param {number} [idx=0]
   * @return {module:echarts/model/Component}
   */
  getComponent: function (mainType, idx) {
    var list = this._componentsMap.get(mainType);

    if (list) {
      return list[idx || 0];
    }
  },

  /**
   * If none of index and id and name used, return all components with mainType.
   * @param {Object} condition
   * @param {string} condition.mainType
   * @param {string} [condition.subType] If ignore, only query by mainType
   * @param {number|Array.<number>} [condition.index] Either input index or id or name.
   * @param {string|Array.<string>} [condition.id] Either input index or id or name.
   * @param {string|Array.<string>} [condition.name] Either input index or id or name.
   * @return {Array.<module:echarts/model/Component>}
   */
  queryComponents: function (condition) {
    var mainType = condition.mainType;

    if (!mainType) {
      return [];
    }

    var index = condition.index;
    var id = condition.id;
    var name = condition.name;

    var cpts = this._componentsMap.get(mainType);

    if (!cpts || !cpts.length) {
      return [];
    }

    var result;

    if (index != null) {
      if (!isArray(index)) {
        index = [index];
      }

      result = filter(map(index, function (idx) {
        return cpts[idx];
      }), function (val) {
        return !!val;
      });
    } else if (id != null) {
      var isIdArray = isArray(id);
      result = filter(cpts, function (cpt) {
        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
      });
    } else if (name != null) {
      var isNameArray = isArray(name);
      result = filter(cpts, function (cpt) {
        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;
      });
    } else {
      // Return all components with mainType
      result = cpts.slice();
    }

    return filterBySubType(result, condition);
  },

  /**
   * The interface is different from queryComponents,
   * which is convenient for inner usage.
   *
   * @usage
   * var result = findComponents(
   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
   * );
   * var result = findComponents(
   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
   * );
   * var result = findComponents(
   *     {mainType: 'series'},
   *     function (model, index) {...}
   * );
   * // result like [component0, componnet1, ...]
   *
   * @param {Object} condition
   * @param {string} condition.mainType Mandatory.
   * @param {string} [condition.subType] Optional.
   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
   *        where xxx is mainType.
   *        If query attribute is null/undefined or has no index/id/name,
   *        do not filtering by query conditions, which is convenient for
   *        no-payload situations or when target of action is global.
   * @param {Function} [condition.filter] parameter: component, return boolean.
   * @return {Array.<module:echarts/model/Component>}
   */
  findComponents: function (condition) {
    var query = condition.query;
    var mainType = condition.mainType;
    var queryCond = getQueryCond(query);
    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);
    return doFilter(filterBySubType(result, condition));

    function getQueryCond(q) {
      var indexAttr = mainType + 'Index';
      var idAttr = mainType + 'Id';
      var nameAttr = mainType + 'Name';
      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
        mainType: mainType,
        // subType will be filtered finally.
        index: q[indexAttr],
        id: q[idAttr],
        name: q[nameAttr]
      } : null;
    }

    function doFilter(res) {
      return condition.filter ? filter(res, condition.filter) : res;
    }
  },

  /**
   * @usage
   * eachComponent('legend', function (legendModel, index) {
   *     ...
   * });
   * eachComponent(function (componentType, model, index) {
   *     // componentType does not include subType
   *     // (componentType is 'xxx' but not 'xxx.aa')
   * });
   * eachComponent(
   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
   *     function (model, index) {...}
   * );
   * eachComponent(
   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
   *     function (model, index) {...}
   * );
   *
   * @param {string|Object=} mainType When mainType is object, the definition
   *                                  is the same as the method 'findComponents'.
   * @param {Function} cb
   * @param {*} context
   */
  eachComponent: function (mainType, cb, context) {
    var componentsMap = this._componentsMap;

    if (typeof mainType === 'function') {
      context = cb;
      cb = mainType;
      componentsMap.each(function (components, componentType) {
        each(components, function (component, index) {
          cb.call(context, componentType, component, index);
        });
      });
    } else if (isString(mainType)) {
      each(componentsMap.get(mainType), cb, context);
    } else if (isObject(mainType)) {
      var queryResult = this.findComponents(mainType);
      each(queryResult, cb, context);
    }
  },

  /**
   * @param {string} name
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeriesByName: function (name) {
    var series = this._componentsMap.get('series');

    return filter(series, function (oneSeries) {
      return oneSeries.name === name;
    });
  },

  /**
   * @param {number} seriesIndex
   * @return {module:echarts/model/Series}
   */
  getSeriesByIndex: function (seriesIndex) {
    return this._componentsMap.get('series')[seriesIndex];
  },

  /**
   * Get series list before filtered by type.
   * FIXME: rename to getRawSeriesByType?
   *
   * @param {string} subType
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeriesByType: function (subType) {
    var series = this._componentsMap.get('series');

    return filter(series, function (oneSeries) {
      return oneSeries.subType === subType;
    });
  },

  /**
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeries: function () {
    return this._componentsMap.get('series').slice();
  },

  /**
   * @return {number}
   */
  getSeriesCount: function () {
    return this._componentsMap.get('series').length;
  },

  /**
   * After filtering, series may be different
   * frome raw series.
   *
   * @param {Function} cb
   * @param {*} context
   */
  eachSeries: function (cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function (rawSeriesIndex) {
      var series = this._componentsMap.get('series')[rawSeriesIndex];

      cb.call(context, series, rawSeriesIndex);
    }, this);
  },

  /**
   * Iterate raw series before filtered.
   *
   * @param {Function} cb
   * @param {*} context
   */
  eachRawSeries: function (cb, context) {
    each(this._componentsMap.get('series'), cb, context);
  },

  /**
   * After filtering, series may be different.
   * frome raw series.
   *
   * @parma {string} subType
   * @param {Function} cb
   * @param {*} context
   */
  eachSeriesByType: function (subType, cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function (rawSeriesIndex) {
      var series = this._componentsMap.get('series')[rawSeriesIndex];

      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  },

  /**
   * Iterate raw series before filtered of given type.
   *
   * @parma {string} subType
   * @param {Function} cb
   * @param {*} context
   */
  eachRawSeriesByType: function (subType, cb, context) {
    return each(this.getSeriesByType(subType), cb, context);
  },

  /**
   * @param {module:echarts/model/Series} seriesModel
   */
  isSeriesFiltered: function (seriesModel) {
    assertSeriesInitialized(this);
    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
  },

  /**
   * @return {Array.<number>}
   */
  getCurrentSeriesIndices: function () {
    return (this._seriesIndices || []).slice();
  },

  /**
   * @param {Function} cb
   * @param {*} context
   */
  filterSeries: function (cb, context) {
    assertSeriesInitialized(this);
    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);
    createSeriesIndices(this, filteredSeries);
  },
  restoreData: function (payload) {
    var componentsMap = this._componentsMap;
    createSeriesIndices(this, componentsMap.get('series'));
    var componentTypes = [];
    componentsMap.each(function (components, componentType) {
      componentTypes.push(componentType);
    });
    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {
      each(componentsMap.get(componentType), function (component) {
        (componentType !== 'series' || !isNotTargetSeries(component, payload)) && component.restoreData();
      });
    });
  }
});

function isNotTargetSeries(seriesModel, payload) {
  if (payload) {
    var index = payload.seiresIndex;
    var id = payload.seriesId;
    var name = payload.seriesName;
    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;
  }
}
/**
 * @inner
 */


function mergeTheme(option, theme) {
  // PENDING
  // NOT use `colorLayer` in theme if option has `color`
  var notMergeColorLayer = option.color && !option.colorLayer;
  each(theme, function (themeItem, name) {
    if (name === 'colorLayer' && notMergeColorLayer) {
      return;
    } // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理


    if (!ComponentModel.hasClass(name)) {
      if (typeof themeItem === 'object') {
        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);
      } else {
        if (option[name] == null) {
          option[name] = themeItem;
        }
      }
    }
  });
}

function initBase(baseOption) {
  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,
  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.

  this.option = {};
  this.option[OPTION_INNER_KEY] = 1;
  /**
   * Init with series: [], in case of calling findSeries method
   * before series initialized.
   * @type {Object.<string, Array.<module:echarts/model/Model>>}
   * @private
   */

  this._componentsMap = createHashMap({
    series: []
  });
  /**
   * Mapping between filtered series list and raw series list.
   * key: filtered series indices, value: raw series indices.
   * @type {Array.<nubmer>}
   * @private
   */

  this._seriesIndices;
  this._seriesIndicesMap;
  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property

  merge(baseOption, globalDefault, false);
  this.mergeOption(baseOption);
}
/**
 * @inner
 * @param {Array.<string>|string} types model types
 * @return {Object} key: {string} type, value: {Array.<Object>} models
 */


function getComponentsByTypes(componentsMap, types) {
  if (!isArray(types)) {
    types = types ? [types] : [];
  }

  var ret = {};
  each(types, function (type) {
    ret[type] = (componentsMap.get(type) || []).slice();
  });
  return ret;
}
/**
 * @inner
 */


function determineSubType(mainType, newCptOption, existComponent) {
  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.
  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType

  return subType;
}
/**
 * @inner
 */


function createSeriesIndices(ecModel, seriesModels) {
  ecModel._seriesIndicesMap = createHashMap(ecModel._seriesIndices = map(seriesModels, function (series) {
    return series.componentIndex;
  }) || []);
}
/**
 * @inner
 */


function filterBySubType(components, condition) {
  // Using hasOwnProperty for restrict. Consider
  // subType is undefined in user payload.
  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {
    return cpt.subType === condition.subType;
  }) : components;
}
/**
 * @inner
 */


function assertSeriesInitialized(ecModel) {}

mixin(GlobalModel, colorPaletteMixin);
var _default = GlobalModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/Model.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var makeInner = _model.makeInner;

var _clazz = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var enableClassExtend = _clazz.enableClassExtend;
var enableClassCheck = _clazz.enableClassCheck;

var lineStyleMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/lineStyle.js");

var areaStyleMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/areaStyle.js");

var textStyleMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/textStyle.js");

var itemStyleMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/itemStyle.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @module echarts/model/Model
 */
var mixin = zrUtil.mixin;
var inner = makeInner();
/**
 * @alias module:echarts/model/Model
 * @constructor
 * @param {Object} option
 * @param {module:echarts/model/Model} [parentModel]
 * @param {module:echarts/model/Global} [ecModel]
 */

function Model(option, parentModel, ecModel) {
  /**
   * @type {module:echarts/model/Model}
   * @readOnly
   */
  this.parentModel = parentModel;
  /**
   * @type {module:echarts/model/Global}
   * @readOnly
   */

  this.ecModel = ecModel;
  /**
   * @type {Object}
   * @protected
   */

  this.option = option; // Simple optimization
  // if (this.init) {
  //     if (arguments.length <= 4) {
  //         this.init(option, parentModel, ecModel, extraOpt);
  //     }
  //     else {
  //         this.init.apply(this, arguments);
  //     }
  // }
}

Model.prototype = {
  constructor: Model,

  /**
   * Model 的初始化函数
   * @param {Object} option
   */
  init: null,

  /**
   * 从新的 Option merge
   */
  mergeOption: function (option) {
    zrUtil.merge(this.option, option, true);
  },

  /**
   * @param {string|Array.<string>} path
   * @param {boolean} [ignoreParent=false]
   * @return {*}
   */
  get: function (path, ignoreParent) {
    if (path == null) {
      return this.option;
    }

    return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));
  },

  /**
   * @param {string} key
   * @param {boolean} [ignoreParent=false]
   * @return {*}
   */
  getShallow: function (key, ignoreParent) {
    var option = this.option;
    var val = option == null ? option : option[key];
    var parentModel = !ignoreParent && getParent(this, key);

    if (val == null && parentModel) {
      val = parentModel.getShallow(key);
    }

    return val;
  },

  /**
   * @param {string|Array.<string>} [path]
   * @param {module:echarts/model/Model} [parentModel]
   * @return {module:echarts/model/Model}
   */
  getModel: function (path, parentModel) {
    var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));
    var thisParentModel;
    parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);
    return new Model(obj, parentModel, this.ecModel);
  },

  /**
   * If model has option
   */
  isEmpty: function () {
    return this.option == null;
  },
  restoreData: function () {},
  // Pending
  clone: function () {
    var Ctor = this.constructor;
    return new Ctor(zrUtil.clone(this.option));
  },
  setReadOnly: function (properties) {// clazzUtil.setReadOnly(this, properties);
  },
  // If path is null/undefined, return null/undefined.
  parsePath: function (path) {
    if (typeof path === 'string') {
      path = path.split('.');
    }

    return path;
  },

  /**
   * @param {Function} getParentMethod
   *        param {Array.<string>|string} path
   *        return {module:echarts/model/Model}
   */
  customizeGetParent: function (getParentMethod) {
    inner(this).getParent = getParentMethod;
  },
  isAnimationEnabled: function () {
    if (!env.node) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  }
};

function doGet(obj, pathArr, parentModel) {
  for (var i = 0; i < pathArr.length; i++) {
    // Ignore empty
    if (!pathArr[i]) {
      continue;
    } // obj could be number/string/... (like 0)


    obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;

    if (obj == null) {
      break;
    }
  }

  if (obj == null && parentModel) {
    obj = parentModel.get(pathArr);
  }

  return obj;
} // `path` can be null/undefined


function getParent(model, path) {
  var getParentMethod = inner(model).getParent;
  return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;
} // Enable Model.extend.


enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, lineStyleMixin);
mixin(Model, areaStyleMixin);
mixin(Model, textStyleMixin);
mixin(Model, itemStyleMixin);
var _default = Model;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/OptionManager.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * ECharts option manager
 *
 * @module {echarts/model/OptionManager}
 */
var each = zrUtil.each;
var clone = zrUtil.clone;
var map = zrUtil.map;
var merge = zrUtil.merge;
var QUERY_REG = /^(min|max)?(.+)$/;
/**
 * TERM EXPLANATIONS:
 *
 * [option]:
 *
 *     An object that contains definitions of components. For example:
 *     var option = {
 *         title: {...},
 *         legend: {...},
 *         visualMap: {...},
 *         series: [
 *             {data: [...]},
 *             {data: [...]},
 *             ...
 *         ]
 *     };
 *
 * [rawOption]:
 *
 *     An object input to echarts.setOption. 'rawOption' may be an
 *     'option', or may be an object contains multi-options. For example:
 *     var option = {
 *         baseOption: {
 *             title: {...},
 *             legend: {...},
 *             series: [
 *                 {data: [...]},
 *                 {data: [...]},
 *                 ...
 *             ]
 *         },
 *         timeline: {...},
 *         options: [
 *             {title: {...}, series: {data: [...]}},
 *             {title: {...}, series: {data: [...]}},
 *             ...
 *         ],
 *         media: [
 *             {
 *                 query: {maxWidth: 320},
 *                 option: {series: {x: 20}, visualMap: {show: false}}
 *             },
 *             {
 *                 query: {minWidth: 320, maxWidth: 720},
 *                 option: {series: {x: 500}, visualMap: {show: true}}
 *             },
 *             {
 *                 option: {series: {x: 1200}, visualMap: {show: true}}
 *             }
 *         ]
 *     };
 *
 * @alias module:echarts/model/OptionManager
 * @param {module:echarts/ExtensionAPI} api
 */

function OptionManager(api) {
  /**
   * @private
   * @type {module:echarts/ExtensionAPI}
   */
  this._api = api;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._timelineOptions = [];
  /**
   * @private
   * @type {Array.<Object>}
   */

  this._mediaList = [];
  /**
   * @private
   * @type {Object}
   */

  this._mediaDefault;
  /**
   * -1, means default.
   * empty means no media.
   * @private
   * @type {Array.<number>}
   */

  this._currentMediaIndices = [];
  /**
   * @private
   * @type {Object}
   */

  this._optionBackup;
  /**
   * @private
   * @type {Object}
   */

  this._newBaseOption;
} // timeline.notMerge is not supported in ec3. Firstly there is rearly
// case that notMerge is needed. Secondly supporting 'notMerge' requires
// rawOption cloned and backuped when timeline changed, which does no
// good to performance. What's more, that both timeline and setOption
// method supply 'notMerge' brings complex and some problems.
// Consider this case:
// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);


OptionManager.prototype = {
  constructor: OptionManager,

  /**
   * @public
   * @param {Object} rawOption Raw option.
   * @param {module:echarts/model/Global} ecModel
   * @param {Array.<Function>} optionPreprocessorFuncs
   * @return {Object} Init option
   */
  setOption: function (rawOption, optionPreprocessorFuncs) {
    if (rawOption) {
      // That set dat primitive is dangerous if user reuse the data when setOption again.
      zrUtil.each(modelUtil.normalizeToArray(rawOption.series), function (series) {
        series && series.data && zrUtil.isTypedArray(series.data) && zrUtil.setAsPrimitive(series.data);
      });
    } // Caution: some series modify option data, if do not clone,
    // it should ensure that the repeat modify correctly
    // (create a new object when modify itself).


    rawOption = clone(rawOption, true); // FIXME
    // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。

    var oldOptionBackup = this._optionBackup;
    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);

    if (oldOptionBackup) {
      // Only baseOption can be merged.
      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,
      // that is, if you `setOption` twice and both has timeline options, the latter
      // timeline opitons will not be merged to the formers, but just substitude them.

      if (newParsedOption.timelineOptions.length) {
        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
      }

      if (newParsedOption.mediaList.length) {
        oldOptionBackup.mediaList = newParsedOption.mediaList;
      }

      if (newParsedOption.mediaDefault) {
        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  },

  /**
   * @param {boolean} isRecreate
   * @return {Object}
   */
  mountOption: function (isRecreate) {
    var optionBackup = this._optionBackup; // TODO
    // 如果没有reset功能则不clone。

    this._timelineOptions = map(optionBackup.timelineOptions, clone);
    this._mediaList = map(optionBackup.mediaList, clone);
    this._mediaDefault = clone(optionBackup.mediaDefault);
    this._currentMediaIndices = [];
    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`
    // called, and is merged into every new option by inner method `mergeOption`
    // each time `setOption` called, can be only used in `isRecreate`, because
    // its reliability is under suspicion. In other cases option merge is
    // performed by `model.mergeOption`.
    ? optionBackup.baseOption : this._newBaseOption);
  },

  /**
   * @param {module:echarts/model/Global} ecModel
   * @return {Object}
   */
  getTimelineOption: function (ecModel) {
    var option;
    var timelineOptions = this._timelineOptions;

    if (timelineOptions.length) {
      // getTimelineOption can only be called after ecModel inited,
      // so we can get currentIndex from timelineModel.
      var timelineModel = ecModel.getComponent('timeline');

      if (timelineModel) {
        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);
      }
    }

    return option;
  },

  /**
   * @param {module:echarts/model/Global} ecModel
   * @return {Array.<Object>}
   */
  getMediaOption: function (ecModel) {
    var ecWidth = this._api.getWidth();

    var ecHeight = this._api.getHeight();

    var mediaList = this._mediaList;
    var mediaDefault = this._mediaDefault;
    var indices = [];
    var result = []; // No media defined.

    if (!mediaList.length && !mediaDefault) {
      return result;
    } // Multi media may be applied, the latter defined media has higher priority.


    for (var i = 0, len = mediaList.length; i < len; i++) {
      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
        indices.push(i);
      }
    } // FIXME
    // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。


    if (!indices.length && mediaDefault) {
      indices = [-1];
    }

    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map(indices, function (index) {
        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
      });
    } // Otherwise return nothing.


    this._currentMediaIndices = indices;
    return result;
  }
};

function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
  var timelineOptions = [];
  var mediaList = [];
  var mediaDefault;
  var baseOption; // Compatible with ec2.

  var timelineOpt = rawOption.timeline;

  if (rawOption.baseOption) {
    baseOption = rawOption.baseOption;
  } // For timeline


  if (timelineOpt || rawOption.options) {
    baseOption = baseOption || {};
    timelineOptions = (rawOption.options || []).slice();
  } // For media query


  if (rawOption.media) {
    baseOption = baseOption || {};
    var media = rawOption.media;
    each(media, function (singleMedia) {
      if (singleMedia && singleMedia.option) {
        if (singleMedia.query) {
          mediaList.push(singleMedia);
        } else if (!mediaDefault) {
          // Use the first media default.
          mediaDefault = singleMedia;
        }
      }
    });
  } // For normal option


  if (!baseOption) {
    baseOption = rawOption;
  } // Set timelineOpt to baseOption in ec3,
  // which is convenient for merge option.


  if (!baseOption.timeline) {
    baseOption.timeline = timelineOpt;
  } // Preprocess.


  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {
    return media.option;
  })), function (option) {
    each(optionPreprocessorFuncs, function (preProcess) {
      preProcess(option, isNew);
    });
  });
  return {
    baseOption: baseOption,
    timelineOptions: timelineOptions,
    mediaDefault: mediaDefault,
    mediaList: mediaList
  };
}
/**
 * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
 * Support: width, height, aspectRatio
 * Can use max or min as prefix.
 */


function applyMediaQuery(query, ecWidth, ecHeight) {
  var realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight // lowser case for convenientce.

  };
  var applicatable = true;
  zrUtil.each(query, function (value, attr) {
    var matched = attr.match(QUERY_REG);

    if (!matched || !matched[1] || !matched[2]) {
      return;
    }

    var operator = matched[1];
    var realAttr = matched[2].toLowerCase();

    if (!compare(realMap[realAttr], value, operator)) {
      applicatable = false;
    }
  });
  return applicatable;
}

function compare(real, expect, operator) {
  if (operator === 'min') {
    return real >= expect;
  } else if (operator === 'max') {
    return real <= expect;
  } else {
    // Equals
    return real === expect;
  }
}

function indicesEquals(indices1, indices2) {
  // indices is always order by asc and has only finite number.
  return indices1.join(',') === indices2.join(',');
}
/**
 * Consider case:
 * `chart.setOption(opt1);`
 * Then user do some interaction like dataZoom, dataView changing.
 * `chart.setOption(opt2);`
 * Then user press 'reset button' in toolbox.
 *
 * After doing that all of the interaction effects should be reset, the
 * chart should be the same as the result of invoke
 * `chart.setOption(opt1); chart.setOption(opt2);`.
 *
 * Although it is not able ensure that
 * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
 * `chart.setOption(merge(opt1, opt2));` exactly,
 * this might be the only simple way to implement that feature.
 *
 * MEMO: We've considered some other approaches:
 * 1. Each model handle its self restoration but not uniform treatment.
 *     (Too complex in logic and error-prone)
 * 2. Use a shadow ecModel. (Performace expensive)
 */


function mergeOption(oldOption, newOption) {
  newOption = newOption || {};
  each(newOption, function (newCptOpt, mainType) {
    if (newCptOpt == null) {
      return;
    }

    var oldCptOpt = oldOption[mainType];

    if (!ComponentModel.hasClass(mainType)) {
      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);
    } else {
      newCptOpt = modelUtil.normalizeToArray(newCptOpt);
      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);
      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);
      oldOption[mainType] = map(mapResult, function (item) {
        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;
      });
    }
  });
}

var _default = OptionManager;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/Series.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var _format = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var formatTime = _format.formatTime;
var encodeHTML = _format.encodeHTML;
var addCommas = _format.addCommas;
var getTooltipMarker = _format.getTooltipMarker;

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var ComponentModel = __webpack_require__("./node_modules/echarts/lib/model/Component.js");

var colorPaletteMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/colorPalette.js");

var dataFormatMixin = __webpack_require__("./node_modules/echarts/lib/model/mixin/dataFormat.js");

var _layout = __webpack_require__("./node_modules/echarts/lib/util/layout.js");

var getLayoutParams = _layout.getLayoutParams;
var mergeLayoutParam = _layout.mergeLayoutParam;

var _task = __webpack_require__("./node_modules/echarts/lib/stream/task.js");

var createTask = _task.createTask;

var _sourceHelper = __webpack_require__("./node_modules/echarts/lib/data/helper/sourceHelper.js");

var prepareSource = _sourceHelper.prepareSource;
var getSource = _sourceHelper.getSource;

var _dataProvider = __webpack_require__("./node_modules/echarts/lib/data/helper/dataProvider.js");

var retrieveRawValue = _dataProvider.retrieveRawValue;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var inner = modelUtil.makeInner();
var SeriesModel = ComponentModel.extend({
  type: 'series.__base__',

  /**
   * @readOnly
   */
  seriesIndex: 0,
  // coodinateSystem will be injected in the echarts/CoordinateSystem
  coordinateSystem: null,

  /**
   * @type {Object}
   * @protected
   */
  defaultOption: null,

  /**
   * Data provided for legend
   * @type {Function}
   */
  // PENDING
  legendDataProvider: null,

  /**
   * Access path of color for visual
   */
  visualColorAccessPath: 'itemStyle.color',

  /**
   * Support merge layout params.
   * Only support 'box' now (left/right/top/bottom/width/height).
   * @type {string|Object} Object can be {ignoreSize: true}
   * @readOnly
   */
  layoutMode: null,
  init: function (option, parentModel, ecModel, extraOpt) {
    /**
     * @type {number}
     * @readOnly
     */
    this.seriesIndex = this.componentIndex;
    this.dataTask = createTask({
      count: dataTaskCount,
      reset: dataTaskReset
    });
    this.dataTask.context = {
      model: this
    };
    this.mergeDefaultAndTheme(option, ecModel);
    prepareSource(this);
    var data = this.getInitialData(option, ecModel);
    wrapData(data, this);
    this.dataTask.context.data = data;

    /**
     * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}
     * @private
     */
    inner(this).dataBeforeProcessed = data; // If we reverse the order (make data firstly, and then make
    // dataBeforeProcessed by cloneShallow), cloneShallow will
    // cause data.graph.data !== data when using
    // module:echarts/data/Graph or module:echarts/data/Tree.
    // See module:echarts/data/helper/linkList
    // Theoretically, it is unreasonable to call `seriesModel.getData()` in the model
    // init or merge stage, because the data can be restored. So we do not `restoreData`
    // and `setData` here, which forbids calling `seriesModel.getData()` in this stage.
    // Call `seriesModel.getRawData()` instead.
    // this.restoreData();

    autoSeriesName(this);
  },

  /**
   * Util for merge default and theme to option
   * @param  {Object} option
   * @param  {module:echarts/model/Global} ecModel
   */
  mergeDefaultAndTheme: function (option, ecModel) {
    var layoutMode = this.layoutMode;
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {}; // Backward compat: using subType on theme.
    // But if name duplicate between series subType
    // (for example: parallel) add component mainType,
    // add suffix 'Series'.

    var themeSubType = this.subType;

    if (ComponentModel.hasClass(themeSubType)) {
      themeSubType += 'Series';
    }

    zrUtil.merge(option, ecModel.getTheme().get(this.subType));
    zrUtil.merge(option, this.getDefaultOption()); // Default label emphasis `show`

    modelUtil.defaultEmphasis(option, 'label', ['show']);
    this.fillDataTextStyle(option.data);

    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  },
  mergeOption: function (newSeriesOption, ecModel) {
    // this.settingTask.dirty();
    newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    var layoutMode = this.layoutMode;

    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }

    prepareSource(this);
    var data = this.getInitialData(newSeriesOption, ecModel);
    wrapData(data, this);
    this.dataTask.dirty();
    this.dataTask.context.data = data;
    inner(this).dataBeforeProcessed = data;
    autoSeriesName(this);
  },
  fillDataTextStyle: function (data) {
    // Default data label emphasis `show`
    // FIXME Tree structure data ?
    // FIXME Performance ?
    if (data && !zrUtil.isTypedArray(data)) {
      var props = ['show'];

      for (var i = 0; i < data.length; i++) {
        if (data[i] && data[i].label) {
          modelUtil.defaultEmphasis(data[i], 'label', props);
        }
      }
    }
  },

  /**
   * Init a data structure from data related option in series
   * Must be overwritten
   */
  getInitialData: function () {},

  /**
   * Append data to list
   * @param {Object} params
   * @param {Array|TypedArray} params.data
   */
  appendData: function (params) {
    // FIXME ???
    // (1) If data from dataset, forbidden append.
    // (2) support append data of dataset.
    var data = this.getRawData();
    data.appendData(params.data);
  },

  /**
   * Consider some method like `filter`, `map` need make new data,
   * We should make sure that `seriesModel.getData()` get correct
   * data in the stream procedure. So we fetch data from upstream
   * each time `task.perform` called.
   * @param {string} [dataType]
   * @return {module:echarts/data/List}
   */
  getData: function (dataType) {
    var task = getCurrentTask(this);

    if (task) {
      var data = task.context.data;
      return dataType == null ? data : data.getLinkedData(dataType);
    } else {
      // When series is not alive (that may happen when click toolbox
      // restore or setOption with not merge mode), series data may
      // be still need to judge animation or something when graphic
      // elements want to know whether fade out.
      return inner(this).data;
    }
  },

  /**
   * @param {module:echarts/data/List} data
   */
  setData: function (data) {
    var task = getCurrentTask(this);

    if (task) {
      var context = task.context; // Consider case: filter, data sample.

      if (context.data !== data && task.modifyOutputEnd) {
        task.setOutputEnd(data.count());
      }

      context.outputData = data; // Caution: setData should update context.data,
      // Because getData may be called multiply in a
      // single stage and expect to get the data just
      // set. (For example, AxisProxy, x y both call
      // getData and setDate sequentially).
      // So the context.data should be fetched from
      // upstream each time when a stage starts to be
      // performed.

      if (task !== this.dataTask) {
        context.data = data;
      }
    }

    inner(this).data = data;
  },

  /**
   * @see {module:echarts/data/helper/sourceHelper#getSource}
   * @return {module:echarts/data/Source} source
   */
  getSource: function () {
    return getSource(this);
  },

  /**
   * Get data before processed
   * @return {module:echarts/data/List}
   */
  getRawData: function () {
    return inner(this).dataBeforeProcessed;
  },

  /**
   * Get base axis if has coordinate system and has axis.
   * By default use coordSys.getBaseAxis();
   * Can be overrided for some chart.
   * @return {type} description
   */
  getBaseAxis: function () {
    var coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  },
  // FIXME

  /**
   * Default tooltip formatter
   *
   * @param {number} dataIndex
   * @param {boolean} [multipleSeries=false]
   * @param {number} [dataType]
   */
  formatTooltip: function (dataIndex, multipleSeries, dataType) {
    function formatArrayValue(value) {
      // ??? TODO refactor these logic.
      // check: category-no-encode-has-axis-data in dataset.html
      var vertially = zrUtil.reduce(value, function (vertially, val, idx) {
        var dimItem = data.getDimensionInfo(idx);
        return vertially |= dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
      }, 0);
      var result = [];
      tooltipDims.length ? zrUtil.each(tooltipDims, function (dim) {
        setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
      }) // By default, all dims is used on tooltip.
      : zrUtil.each(value, setEachItem);

      function setEachItem(val, dim) {
        var dimInfo = data.getDimensionInfo(dim); // If `dimInfo.tooltip` is not set, show tooltip.

        if (!dimInfo || dimInfo.otherDims.tooltip === false) {
          return;
        }

        var dimType = dimInfo.type;
        var dimHead = getTooltipMarker({
          color: color,
          type: 'subItem'
        });
        var valStr = (vertially ? dimHead + encodeHTML(dimInfo.displayName || '-') + ': ' : '') + // FIXME should not format time for raw data?
        encodeHTML(dimType === 'ordinal' ? val + '' : dimType === 'time' ? multipleSeries ? '' : formatTime('yyyy/MM/dd hh:mm:ss', val) : addCommas(val));
        valStr && result.push(valStr);
      }

      return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');
    }

    function formatSingleValue(val) {
      return encodeHTML(addCommas(val));
    }

    var data = this.getData();
    var tooltipDims = data.mapDimension('defaultedTooltip', true);
    var tooltipDimLen = tooltipDims.length;
    var value = this.getRawValue(dataIndex);
    var isValueArr = zrUtil.isArray(value);
    var color = data.getItemVisual(dataIndex, 'color');

    if (zrUtil.isObject(color) && color.colorStops) {
      color = (color.colorStops[0] || {}).color;
    }

    color = color || 'transparent'; // Complicated rule for pretty tooltip.

    var formattedValue = tooltipDimLen > 1 || isValueArr && !tooltipDimLen ? formatArrayValue(value) : tooltipDimLen ? formatSingleValue(retrieveRawValue(data, dataIndex, tooltipDims[0])) : formatSingleValue(isValueArr ? value[0] : value);
    var colorEl = getTooltipMarker(color);
    var name = data.getName(dataIndex);
    var seriesName = this.name;

    if (!modelUtil.isNameSpecified(this)) {
      seriesName = '';
    }

    seriesName = seriesName ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ') : '';
    return !multipleSeries ? seriesName + colorEl + (name ? encodeHTML(name) + ': ' + formattedValue : formattedValue) : colorEl + seriesName + formattedValue;
  },

  /**
   * @return {boolean}
   */
  isAnimationEnabled: function () {
    if (env.node) {
      return false;
    }

    var animationEnabled = this.getShallow('animation');

    if (animationEnabled) {
      if (this.getData().count() > this.getShallow('animationThreshold')) {
        animationEnabled = false;
      }
    }

    return animationEnabled;
  },
  restoreData: function () {
    this.dataTask.dirty();
  },
  getColorFromPalette: function (name, scope, requestColorNum) {
    var ecModel = this.ecModel; // PENDING

    var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope, requestColorNum);

    if (!color) {
      color = ecModel.getColorFromPalette(name, scope, requestColorNum);
    }

    return color;
  },

  /**
   * Use `data.mapDimension(coordDim, true)` instead.
   * @deprecated
   */
  coordDimToDataDim: function (coordDim) {
    return this.getRawData().mapDimension(coordDim, true);
  },

  /**
   * Get progressive rendering count each step
   * @return {number}
   */
  getProgressive: function () {
    return this.get('progressive');
  },

  /**
   * Get progressive rendering count each step
   * @return {number}
   */
  getProgressiveThreshold: function () {
    return this.get('progressiveThreshold');
  },

  /**
   * Get data indices for show tooltip content. See tooltip.
   * @abstract
   * @param {Array.<string>|string} dim
   * @param {Array.<number>} value
   * @param {module:echarts/coord/single/SingleAxis} baseAxis
   * @return {Object} {dataIndices, nestestValue}.
   */
  getAxisTooltipData: null,

  /**
   * See tooltip.
   * @abstract
   * @param {number} dataIndex
   * @return {Array.<number>} Point of tooltip. null/undefined can be returned.
   */
  getTooltipPosition: null,

  /**
   * @see {module:echarts/stream/Scheduler}
   */
  pipeTask: null,

  /**
   * Convinient for override in extended class.
   * @protected
   * @type {Function}
   */
  preventIncremental: null,

  /**
   * @public
   * @readOnly
   * @type {Object}
   */
  pipelineContext: null
});
zrUtil.mixin(SeriesModel, dataFormatMixin);
zrUtil.mixin(SeriesModel, colorPaletteMixin);
/**
 * MUST be called after `prepareSource` called
 * Here we need to make auto series, especially for auto legend. But we
 * do not modify series.name in option to avoid side effects.
 */

function autoSeriesName(seriesModel) {
  // User specified name has higher priority, otherwise it may cause
  // series can not be queried unexpectedly.
  var name = seriesModel.name;

  if (!modelUtil.isNameSpecified(seriesModel)) {
    seriesModel.name = getSeriesAutoName(seriesModel) || name;
  }
}

function getSeriesAutoName(seriesModel) {
  var data = seriesModel.getRawData();
  var dataDims = data.mapDimension('seriesName', true);
  var nameArr = [];
  zrUtil.each(dataDims, function (dataDim) {
    var dimInfo = data.getDimensionInfo(dataDim);
    dimInfo.displayName && nameArr.push(dimInfo.displayName);
  });
  return nameArr.join(' ');
}

function dataTaskCount(context) {
  return context.model.getRawData().count();
}

function dataTaskReset(context) {
  var seriesModel = context.model;
  seriesModel.setData(seriesModel.getRawData().cloneShallow());
  return dataTaskProgress;
}

function dataTaskProgress(param, context) {
  // Avoid repead cloneShallow when data just created in reset.
  if (param.end > context.outputData.count()) {
    context.model.getRawData().cloneShallow(context.outputData);
  }
} // TODO refactor


function wrapData(data, seriesModel) {
  zrUtil.each(data.CHANGABLE_METHODS, function (methodName) {
    data.wrapMethod(methodName, zrUtil.curry(onDataSelfChange, seriesModel));
  });
}

function onDataSelfChange(seriesModel) {
  var task = getCurrentTask(seriesModel);

  if (task) {
    // Consider case: filter, selectRange
    task.setOutputEnd(this.count());
  }
}

function getCurrentTask(seriesModel) {
  var scheduler = (seriesModel.ecModel || {}).scheduler;
  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);

  if (pipeline) {
    // When pipline finished, the currrentTask keep the last
    // task (renderTask).
    var task = pipeline.currentTask;

    if (task) {
      var agentStubMap = task.agentStubMap;

      if (agentStubMap) {
        task = agentStubMap.get(seriesModel.uid);
      }
    }

    return task;
  }
}

var _default = SeriesModel;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/globalDefault.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var platform = ''; // Navigator not exists in node

if (typeof navigator !== 'undefined') {
  platform = navigator.platform || '';
}

var _default = {
  // backgroundColor: 'rgba(0,0,0,0)',
  // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
  // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
  // Light colors:
  // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
  // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
  // Dark colors:
  color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'],
  gradientColor: ['#f6efa6', '#d88273', '#bf444c'],
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: 'normal',
    fontWeight: 'normal'
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  animation: 'auto',
  animationDuration: 1000,
  animationDurationUpdate: 300,
  animationEasing: 'exponentialOut',
  animationEasingUpdate: 'cubicOut',
  animationThreshold: 2000,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3000,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3000,
  // See: module:echarts/scale/Time
  useUTC: false
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/areaStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__("./node_modules/echarts/lib/model/mixin/makeStyleMapper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var getAreaStyle = makeStyleMapper([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]);
var _default = {
  getAreaStyle: function (excludes, includes) {
    return getAreaStyle(this, excludes, includes);
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/boxLayout.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = {
  getBoxLayoutParams: function () {
    return {
      left: this.get('left'),
      top: this.get('top'),
      right: this.get('right'),
      bottom: this.get('bottom'),
      width: this.get('width'),
      height: this.get('height')
    };
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/colorPalette.js":
/***/ (function(module, exports, __webpack_require__) {

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var makeInner = _model.makeInner;
var normalizeToArray = _model.normalizeToArray;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var inner = makeInner();

function getNearestColorPalette(colors, requestColorNum) {
  var paletteNum = colors.length; // TODO colors must be in order

  for (var i = 0; i < paletteNum; i++) {
    if (colors[i].length > requestColorNum) {
      return colors[i];
    }
  }

  return colors[paletteNum - 1];
}

var _default = {
  clearColorPalette: function () {
    inner(this).colorIdx = 0;
    inner(this).colorNameMap = {};
  },

  /**
   * @param {string} name MUST NOT be null/undefined. Otherwise call this function
   *                 twise with the same parameters will get different result.
   * @param {Object} [scope=this]
   * @param {Object} [requestColorNum]
   * @return {string} color string.
   */
  getColorFromPalette: function (name, scope, requestColorNum) {
    scope = scope || this;
    var scopeFields = inner(scope);
    var colorIdx = scopeFields.colorIdx || 0;
    var colorNameMap = scopeFields.colorNameMap = scopeFields.colorNameMap || {}; // Use `hasOwnProperty` to avoid conflict with Object.prototype.

    if (colorNameMap.hasOwnProperty(name)) {
      return colorNameMap[name];
    }

    var defaultColorPalette = normalizeToArray(this.get('color', true));
    var layeredColorPalette = this.get('colorLayer', true);
    var colorPalette = requestColorNum == null || !layeredColorPalette ? defaultColorPalette : getNearestColorPalette(layeredColorPalette, requestColorNum); // In case can't find in layered color palette.

    colorPalette = colorPalette || defaultColorPalette;

    if (!colorPalette || !colorPalette.length) {
      return;
    }

    var color = colorPalette[colorIdx];

    if (name) {
      colorNameMap[name] = color;
    }

    scopeFields.colorIdx = (colorIdx + 1) % colorPalette.length;
    return color;
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/dataFormat.js":
/***/ (function(module, exports, __webpack_require__) {

var _dataProvider = __webpack_require__("./node_modules/echarts/lib/data/helper/dataProvider.js");

var retrieveRawValue = _dataProvider.retrieveRawValue;

var _format = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var getTooltipMarker = _format.getTooltipMarker;
var formatTpl = _format.formatTpl;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g; // PENDING A little ugly

var _default = {
  /**
   * Get params for formatter
   * @param {number} dataIndex
   * @param {string} [dataType]
   * @return {Object}
   */
  getDataParams: function (dataIndex, dataType) {
    var data = this.getData(dataType);
    var rawValue = this.getRawValue(dataIndex, dataType);
    var rawDataIndex = data.getRawIndex(dataIndex);
    var name = data.getName(dataIndex);
    var itemOpt = data.getRawDataItem(dataIndex);
    var color = data.getItemVisual(dataIndex, 'color');
    return {
      componentType: this.mainType,
      componentSubType: this.subType,
      seriesType: this.mainType === 'series' ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: this.id,
      seriesName: this.name,
      name: name,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType: dataType,
      value: rawValue,
      color: color,
      marker: getTooltipMarker(color),
      // Param name list for mapping `a`, `b`, `c`, `d`, `e`
      $vars: ['seriesName', 'name', 'value']
    };
  },

  /**
   * Format label
   * @param {number} dataIndex
   * @param {string} [status='normal'] 'normal' or 'emphasis'
   * @param {string} [dataType]
   * @param {number} [dimIndex]
   * @param {string} [labelProp='label']
   * @return {string} If not formatter, return null/undefined
   */
  getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {
    status = status || 'normal';
    var data = this.getData(dataType);
    var itemModel = data.getItemModel(dataIndex);
    var params = this.getDataParams(dataIndex, dataType);

    if (dimIndex != null && params.value instanceof Array) {
      params.value = params.value[dimIndex];
    }

    var formatter = itemModel.get(status === 'normal' ? [labelProp || 'label', 'formatter'] : [status, labelProp || 'label', 'formatter']);

    if (typeof formatter === 'function') {
      params.status = status;
      return formatter(params);
    } else if (typeof formatter === 'string') {
      var str = formatTpl(formatter, params); // Support 'aaa{@[3]}bbb{@product}ccc'.
      // Do not support '}' in dim name util have to.

      return str.replace(DIMENSION_LABEL_REG, function (origin, dim) {
        var len = dim.length;

        if (dim.charAt(0) === '[' && dim.charAt(len - 1) === ']') {
          dim = +dim.slice(1, len - 1); // Also: '[]' => 0
        }

        return retrieveRawValue(data, dataIndex, dim);
      });
    }
  },

  /**
   * Get raw value in option
   * @param {number} idx
   * @param {string} [dataType]
   * @return {Array|number|string}
   */
  getRawValue: function (idx, dataType) {
    return retrieveRawValue(this.getData(dataType), idx);
  },

  /**
   * Should be implemented.
   * @param {number} dataIndex
   * @param {boolean} [multipleSeries=false]
   * @param {number} [dataType]
   * @return {string} tooltip string
   */
  formatTooltip: function () {// Empty function
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/itemStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__("./node_modules/echarts/lib/model/mixin/makeStyleMapper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var getItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]);
var _default = {
  getItemStyle: function (excludes, includes) {
    var style = getItemStyle(this, excludes, includes);
    var lineDash = this.getBorderLineDash();
    lineDash && (style.lineDash = lineDash);
    return style;
  },
  getBorderLineDash: function () {
    var lineType = this.get('borderType');
    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [5, 5] : [1, 1];
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/lineStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__("./node_modules/echarts/lib/model/mixin/makeStyleMapper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var getLineStyle = makeStyleMapper([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
var _default = {
  getLineStyle: function (excludes) {
    var style = getLineStyle(this, excludes);
    var lineDash = this.getLineDash(style.lineWidth);
    lineDash && (style.lineDash = lineDash);
    return style;
  },
  getLineDash: function (lineWidth) {
    if (lineWidth == null) {
      lineWidth = 1;
    }

    var lineType = this.get('type');
    var dotSize = Math.max(lineWidth, 2);
    var dashSize = lineWidth * 4;
    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize];
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/makeStyleMapper.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// TODO Parse shadow style
// TODO Only shallow path support
function _default(properties) {
  // Normalize
  for (var i = 0; i < properties.length; i++) {
    if (!properties[i][1]) {
      properties[i][1] = properties[i][0];
    }
  }

  return function (model, excludes, includes) {
    var style = {};

    for (var i = 0; i < properties.length; i++) {
      var propName = properties[i][1];

      if (excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0) {
        continue;
      }

      var val = model.getShallow(propName);

      if (val != null) {
        style[properties[i][0]] = val;
      }
    }

    return style;
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/mixin/textStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var graphicUtil = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var PATH_COLOR = ['textStyle', 'color'];
var _default = {
  /**
   * Get color property or get color from option.textStyle.color
   * @param {boolean} [isEmphasis]
   * @return {string}
   */
  getTextColor: function (isEmphasis) {
    var ecModel = this.ecModel;
    return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  },

  /**
   * Create font string from fontStyle, fontWeight, fontSize, fontFamily
   * @return {string}
   */
  getFont: function () {
    return graphicUtil.getFont({
      fontStyle: this.getShallow('fontStyle'),
      fontWeight: this.getShallow('fontWeight'),
      fontSize: this.getShallow('fontSize'),
      fontFamily: this.getShallow('fontFamily')
    }, this.ecModel);
  },
  getTextRect: function (text) {
    return textContain.getBoundingRect(text, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('rich'), this.getShallow('truncateText'));
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/model/referHelper.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var createHashMap = _util.createHashMap;
var retrieve = _util.retrieve;
var each = _util.each;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Helper for model references.
 * There are many manners to refer axis/coordSys.
 */
// TODO
// merge relevant logic to this file?
// check: "modelHelper" of tooltip and "BrushTargetManager".

/**
 * @return {Object} For example:
 * {
 *     coordSysName: 'cartesian2d',
 *     coordSysDims: ['x', 'y', ...],
 *     axisMap: HashMap({
 *         x: xAxisModel,
 *         y: yAxisModel
 *     }),
 *     categoryAxisMap: HashMap({
 *         x: xAxisModel,
 *         y: undefined
 *     }),
 *     // It also indicate that whether there is category axis.
 *     firstCategoryDimIndex: 1,
 *     // To replace user specified encode.
 * }
 */
function getCoordSysDefineBySeries(seriesModel) {
  var coordSysName = seriesModel.get('coordinateSystem');
  var result = {
    coordSysName: coordSysName,
    coordSysDims: [],
    axisMap: createHashMap(),
    categoryAxisMap: createHashMap()
  };
  var fetch = fetchers[coordSysName];

  if (fetch) {
    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
    return result;
  }
}

var fetchers = {
  cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {
    var xAxisModel = seriesModel.getReferringComponents('xAxis')[0];
    var yAxisModel = seriesModel.getReferringComponents('yAxis')[0];
    result.coordSysDims = ['x', 'y'];
    axisMap.set('x', xAxisModel);
    axisMap.set('y', yAxisModel);

    if (isCategory(xAxisModel)) {
      categoryAxisMap.set('x', xAxisModel);
      result.firstCategoryDimIndex = 0;
    }

    if (isCategory(yAxisModel)) {
      categoryAxisMap.set('y', yAxisModel);
      result.firstCategoryDimIndex = 1;
    }
  },
  singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {
    var singleAxisModel = seriesModel.getReferringComponents('singleAxis')[0];
    result.coordSysDims = ['single'];
    axisMap.set('single', singleAxisModel);

    if (isCategory(singleAxisModel)) {
      categoryAxisMap.set('single', singleAxisModel);
      result.firstCategoryDimIndex = 0;
    }
  },
  polar: function (seriesModel, result, axisMap, categoryAxisMap) {
    var polarModel = seriesModel.getReferringComponents('polar')[0];
    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
    var angleAxisModel = polarModel.findAxisModel('angleAxis');
    result.coordSysDims = ['radius', 'angle'];
    axisMap.set('radius', radiusAxisModel);
    axisMap.set('angle', angleAxisModel);

    if (isCategory(radiusAxisModel)) {
      categoryAxisMap.set('radius', radiusAxisModel);
      result.firstCategoryDimIndex = 0;
    }

    if (isCategory(angleAxisModel)) {
      categoryAxisMap.set('angle', angleAxisModel);
      result.firstCategoryDimIndex = 1;
    }
  },
  geo: function (seriesModel, result, axisMap, categoryAxisMap) {
    result.coordSysDims = ['lng', 'lat'];
  },
  parallel: function (seriesModel, result, axisMap, categoryAxisMap) {
    var ecModel = seriesModel.ecModel;
    var parallelModel = ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));
    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
    each(parallelModel.parallelAxisIndex, function (axisIndex, index) {
      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);
      var axisDim = coordSysDims[index];
      axisMap.set(axisDim, axisModel);

      if (isCategory(axisModel) && result.firstCategoryDimIndex == null) {
        categoryAxisMap.set(axisDim, axisModel);
        result.firstCategoryDimIndex = index;
      }
    });
  }
};

function isCategory(axisModel) {
  return axisModel.get('type') === 'category';
}

exports.getCoordSysDefineBySeries = getCoordSysDefineBySeries;

/***/ }),

/***/ "./node_modules/echarts/lib/preprocessor/backwardCompat.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var each = _util.each;
var isArray = _util.isArray;
var isObject = _util.isObject;

var compatStyle = __webpack_require__("./node_modules/echarts/lib/preprocessor/helper/compatStyle.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var normalizeToArray = _model.normalizeToArray;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Compatitable with 2.0
function get(opt, path) {
  path = path.split(',');
  var obj = opt;

  for (var i = 0; i < path.length; i++) {
    obj = obj && obj[path[i]];

    if (obj == null) {
      break;
    }
  }

  return obj;
}

function set(opt, path, val, overwrite) {
  path = path.split(',');
  var obj = opt;
  var key;

  for (var i = 0; i < path.length - 1; i++) {
    key = path[i];

    if (obj[key] == null) {
      obj[key] = {};
    }

    obj = obj[key];
  }

  if (overwrite || obj[path[i]] == null) {
    obj[path[i]] = val;
  }
}

function compatLayoutProperties(option) {
  each(LAYOUT_PROPERTIES, function (prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}

var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];
var COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];

function _default(option, isTheme) {
  compatStyle(option, isTheme); // Make sure series array for model initialization.

  option.series = normalizeToArray(option.series);
  each(option.series, function (seriesOpt) {
    if (!isObject(seriesOpt)) {
      return;
    }

    var seriesType = seriesOpt.type;

    if (seriesType === 'pie' || seriesType === 'gauge') {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
      }
    }

    if (seriesType === 'gauge') {
      var pointerColor = get(seriesOpt, 'pointer.color');
      pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);
    }

    compatLayoutProperties(seriesOpt);
  }); // dataRange has changed to visualMap

  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }

  each(COMPATITABLE_COMPONENTS, function (componentName) {
    var options = option[componentName];

    if (options) {
      if (!isArray(options)) {
        options = [options];
      }

      each(options, function (option) {
        compatLayoutProperties(option);
      });
    }
  });
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/preprocessor/helper/compatStyle.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var each = zrUtil.each;
var isObject = zrUtil.isObject;
var POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];

function compatEC2ItemStyle(opt) {
  var itemStyleOpt = opt && opt.itemStyle;

  if (!itemStyleOpt) {
    return;
  }

  for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
    var styleName = POSSIBLE_STYLES[i];
    var normalItemStyleOpt = itemStyleOpt.normal;
    var emphasisItemStyleOpt = itemStyleOpt.emphasis;

    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};

      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }

      normalItemStyleOpt[styleName] = null;
    }

    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};

      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }

      emphasisItemStyleOpt[styleName] = null;
    }
  }
}

function convertNormalEmphasis(opt, optType, useExtend) {
  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
    var normalOpt = opt[optType].normal;
    var emphasisOpt = opt[optType].emphasis;

    if (normalOpt) {
      // Timeline controlStyle has other properties besides normal and emphasis
      if (useExtend) {
        opt[optType].normal = opt[optType].emphasis = null;
        zrUtil.defaults(opt[optType], normalOpt);
      } else {
        opt[optType] = normalOpt;
      }
    }

    if (emphasisOpt) {
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[optType] = emphasisOpt;
    }
  }
}

function removeEC3NormalStatus(opt) {
  convertNormalEmphasis(opt, 'itemStyle');
  convertNormalEmphasis(opt, 'lineStyle');
  convertNormalEmphasis(opt, 'areaStyle');
  convertNormalEmphasis(opt, 'label');
  convertNormalEmphasis(opt, 'labelLine'); // treemap

  convertNormalEmphasis(opt, 'upperLabel'); // graph

  convertNormalEmphasis(opt, 'edgeLabel');
}

function compatTextStyle(opt, propName) {
  // Check whether is not object (string\null\undefined ...)
  var labelOptSingle = isObject(opt) && opt[propName];
  var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;

  if (textStyle) {
    for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {
      var propName = modelUtil.TEXT_STYLE_OPTIONS[i];

      if (textStyle.hasOwnProperty(propName)) {
        labelOptSingle[propName] = textStyle[propName];
      }
    }
  }
}

function compatEC3CommonStyles(opt) {
  if (opt) {
    removeEC3NormalStatus(opt);
    compatTextStyle(opt, 'label');
    opt.emphasis && compatTextStyle(opt.emphasis, 'label');
  }
}

function processSeries(seriesOpt) {
  if (!isObject(seriesOpt)) {
    return;
  }

  compatEC2ItemStyle(seriesOpt);
  removeEC3NormalStatus(seriesOpt);
  compatTextStyle(seriesOpt, 'label'); // treemap

  compatTextStyle(seriesOpt, 'upperLabel'); // graph

  compatTextStyle(seriesOpt, 'edgeLabel');

  if (seriesOpt.emphasis) {
    compatTextStyle(seriesOpt.emphasis, 'label'); // treemap

    compatTextStyle(seriesOpt.emphasis, 'upperLabel'); // graph

    compatTextStyle(seriesOpt.emphasis, 'edgeLabel');
  }

  var markPoint = seriesOpt.markPoint;

  if (markPoint) {
    compatEC2ItemStyle(markPoint);
    compatEC3CommonStyles(markPoint);
  }

  var markLine = seriesOpt.markLine;

  if (markLine) {
    compatEC2ItemStyle(markLine);
    compatEC3CommonStyles(markLine);
  }

  var markArea = seriesOpt.markArea;

  if (markArea) {
    compatEC3CommonStyles(markArea);
  }

  var data = seriesOpt.data; // Break with ec3: if `setOption` again, there may be no `type` in option,
  // then the backward compat based on option type will not be performed.

  if (seriesOpt.type === 'graph') {
    data = data || seriesOpt.nodes;
    var edgeData = seriesOpt.links || seriesOpt.edges;

    if (edgeData && !zrUtil.isTypedArray(edgeData)) {
      for (var i = 0; i < edgeData.length; i++) {
        compatEC3CommonStyles(edgeData[i]);
      }
    }

    zrUtil.each(seriesOpt.categories, function (opt) {
      removeEC3NormalStatus(opt);
    });
  }

  if (data && !zrUtil.isTypedArray(data)) {
    for (var i = 0; i < data.length; i++) {
      compatEC3CommonStyles(data[i]);
    }
  } // mark point data


  var markPoint = seriesOpt.markPoint;

  if (markPoint && markPoint.data) {
    var mpData = markPoint.data;

    for (var i = 0; i < mpData.length; i++) {
      compatEC3CommonStyles(mpData[i]);
    }
  } // mark line data


  var markLine = seriesOpt.markLine;

  if (markLine && markLine.data) {
    var mlData = markLine.data;

    for (var i = 0; i < mlData.length; i++) {
      if (zrUtil.isArray(mlData[i])) {
        compatEC3CommonStyles(mlData[i][0]);
        compatEC3CommonStyles(mlData[i][1]);
      } else {
        compatEC3CommonStyles(mlData[i]);
      }
    }
  } // Series


  if (seriesOpt.type === 'gauge') {
    compatTextStyle(seriesOpt, 'axisLabel');
    compatTextStyle(seriesOpt, 'title');
    compatTextStyle(seriesOpt, 'detail');
  } else if (seriesOpt.type === 'treemap') {
    convertNormalEmphasis(seriesOpt.breadcrumb, 'itemStyle');
    zrUtil.each(seriesOpt.levels, function (opt) {
      removeEC3NormalStatus(opt);
    });
  } else if (seriesOpt.type === 'tree') {
    removeEC3NormalStatus(seriesOpt.leaves);
  } // sunburst starts from ec4, so it does not need to compat levels.

}

function toArr(o) {
  return zrUtil.isArray(o) ? o : o ? [o] : [];
}

function toObj(o) {
  return (zrUtil.isArray(o) ? o[0] : o) || {};
}

function _default(option, isTheme) {
  each(toArr(option.series), function (seriesOpt) {
    isObject(seriesOpt) && processSeries(seriesOpt);
  });
  var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];
  isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');
  each(axes, function (axisName) {
    each(toArr(option[axisName]), function (axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, 'axisLabel');
        compatTextStyle(axisOpt.axisPointer, 'label');
      }
    });
  });
  each(toArr(option.parallel), function (parallelOpt) {
    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, 'axisLabel');
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');
  });
  each(toArr(option.calendar), function (calendarOpt) {
    convertNormalEmphasis(calendarOpt, 'itemStyle');
    compatTextStyle(calendarOpt, 'dayLabel');
    compatTextStyle(calendarOpt, 'monthLabel');
    compatTextStyle(calendarOpt, 'yearLabel');
  }); // radar.name.textStyle

  each(toArr(option.radar), function (radarOpt) {
    compatTextStyle(radarOpt, 'name');
  });
  each(toArr(option.geo), function (geoOpt) {
    if (isObject(geoOpt)) {
      compatEC3CommonStyles(geoOpt);
      each(toArr(geoOpt.regions), function (regionObj) {
        compatEC3CommonStyles(regionObj);
      });
    }
  });
  each(toArr(option.timeline), function (timelineOpt) {
    compatEC3CommonStyles(timelineOpt);
    convertNormalEmphasis(timelineOpt, 'label');
    convertNormalEmphasis(timelineOpt, 'itemStyle');
    convertNormalEmphasis(timelineOpt, 'controlStyle', true);
    var data = timelineOpt.data;
    zrUtil.isArray(data) && zrUtil.each(data, function (item) {
      if (zrUtil.isObject(item)) {
        convertNormalEmphasis(item, 'label');
        convertNormalEmphasis(item, 'itemStyle');
      }
    });
  });
  each(toArr(option.toolbox), function (toolboxOpt) {
    convertNormalEmphasis(toolboxOpt, 'iconStyle');
    each(toolboxOpt.feature, function (featureOpt) {
      convertNormalEmphasis(featureOpt, 'iconStyle');
    });
  });
  compatTextStyle(toObj(option.axisPointer), 'label');
  compatTextStyle(toObj(option.tooltip).axisPointer, 'label');
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/processor/dataSample.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var samplers = {
  average: function (frame) {
    var sum = 0;
    var count = 0;

    for (var i = 0; i < frame.length; i++) {
      if (!isNaN(frame[i])) {
        sum += frame[i];
        count++;
      }
    } // Return NaN if count is 0


    return count === 0 ? NaN : sum / count;
  },
  sum: function (frame) {
    var sum = 0;

    for (var i = 0; i < frame.length; i++) {
      // Ignore NaN
      sum += frame[i] || 0;
    }

    return sum;
  },
  max: function (frame) {
    var max = -Infinity;

    for (var i = 0; i < frame.length; i++) {
      frame[i] > max && (max = frame[i]);
    } // NaN will cause illegal axis extent.


    return isFinite(max) ? max : NaN;
  },
  min: function (frame) {
    var min = Infinity;

    for (var i = 0; i < frame.length; i++) {
      frame[i] < min && (min = frame[i]);
    } // NaN will cause illegal axis extent.


    return isFinite(min) ? min : NaN;
  },
  // TODO
  // Median
  nearest: function (frame) {
    return frame[0];
  }
};

var indexSampler = function (frame, value) {
  return Math.round(frame.length / 2);
};

function _default(seriesType) {
  return {
    seriesType: seriesType,
    modifyOutputEnd: true,
    reset: function (seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var sampling = seriesModel.get('sampling');
      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling

      if (coordSys.type === 'cartesian2d' && sampling) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis = coordSys.getOtherAxis(baseAxis);
        var extent = baseAxis.getExtent(); // Coordinste system has been resized

        var size = extent[1] - extent[0];
        var rate = Math.round(data.count() / size);

        if (rate > 1) {
          var sampler;

          if (typeof sampling === 'string') {
            sampler = samplers[sampling];
          } else if (typeof sampling === 'function') {
            sampler = sampling;
          }

          if (sampler) {
            // Only support sample the first dim mapped from value axis.
            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
          }
        }
      }
    }
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/processor/dataStack.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var createHashMap = _util.createHashMap;
var each = _util.each;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// (1) [Caution]: the logic is correct based on the premises:
//     data processing stage is blocked in stream.
//     See <module:echarts/stream/Scheduler#performDataProcessorTasks>
// (2) Only register once when import repeatly.
//     Should be executed before after series filtered and before stack calculation.
function _default(ecModel) {
  var stackInfoMap = createHashMap();
  ecModel.eachSeries(function (seriesModel) {
    var stack = seriesModel.get('stack'); // Compatibal: when `stack` is set as '', do not stack.

    if (stack) {
      var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
      var data = seriesModel.getData();
      var stackInfo = {
        // Used for calculate axis extent automatically.
        stackResultDimension: data.getCalculationInfo('stackResultDimension'),
        stackedOverDimension: data.getCalculationInfo('stackedOverDimension'),
        stackedDimension: data.getCalculationInfo('stackedDimension'),
        stackedByDimension: data.getCalculationInfo('stackedByDimension'),
        isStackedByIndex: data.getCalculationInfo('isStackedByIndex'),
        data: data,
        seriesModel: seriesModel
      }; // If stacked on axis that do not support data stack.

      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
        return;
      }

      stackInfoList.length && data.setCalculationInfo('stackedOnSeries', stackInfoList[stackInfoList.length - 1].seriesModel);
      stackInfoList.push(stackInfo);
    }
  });
  stackInfoMap.each(calculateStack);
}

function calculateStack(stackInfoList) {
  each(stackInfoList, function (targetStackInfo, idxInStack) {
    var resultVal = [];
    var resultNaN = [NaN, NaN];
    var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
    var targetData = targetStackInfo.data;
    var isStackedByIndex = targetStackInfo.isStackedByIndex; // Should not write on raw data, because stack series model list changes
    // depending on legend selection.

    var newData = targetData.map(dims, function (v0, v1, dataIndex) {
      var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex); // Consider `connectNulls` of line area, if value is NaN, stackedOver
      // should also be NaN, to draw a appropriate belt area.

      if (isNaN(sum)) {
        return resultNaN;
      }

      var byValue;
      var stackedDataRawIndex;

      if (isStackedByIndex) {
        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
      } else {
        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
      } // If stackOver is NaN, chart view will render point on value start.


      var stackedOver = NaN;

      for (var j = idxInStack - 1; j >= 0; j--) {
        var stackInfo = stackInfoList[j]; // Has been optimized by inverted indices on `stackedByDimension`.

        if (!isStackedByIndex) {
          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
        }

        if (stackedDataRawIndex >= 0) {
          var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex); // Considering positive stack, negative stack and empty data

          if (sum >= 0 && val > 0 || // Positive stack
          sum <= 0 && val < 0 // Negative stack
          ) {
              sum += val;
              stackedOver = val;
              break;
            }
        }
      }

      resultVal[0] = sum;
      resultVal[1] = stackedOver;
      return resultVal;
    });
    targetData.hostModel.setData(newData); // Update for consequent calculation

    targetStackInfo.data = newData;
  });
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/Interval.js":
/***/ (function(module, exports, __webpack_require__) {

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var Scale = __webpack_require__("./node_modules/echarts/lib/scale/Scale.js");

var helper = __webpack_require__("./node_modules/echarts/lib/scale/helper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Interval scale
 * @module echarts/scale/Interval
 */
var roundNumber = numberUtil.round;
/**
 * @alias module:echarts/coord/scale/Interval
 * @constructor
 */

var IntervalScale = Scale.extend({
  type: 'interval',
  _interval: 0,
  _intervalPrecision: 2,
  setExtent: function (start, end) {
    var thisExtent = this._extent; //start,end may be a Number like '25',so...

    if (!isNaN(start)) {
      thisExtent[0] = parseFloat(start);
    }

    if (!isNaN(end)) {
      thisExtent[1] = parseFloat(end);
    }
  },
  unionExtent: function (other) {
    var extent = this._extent;
    other[0] < extent[0] && (extent[0] = other[0]);
    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes

    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
  },

  /**
   * Get interval
   */
  getInterval: function () {
    return this._interval;
  },

  /**
   * Set interval
   */
  setInterval: function (interval) {
    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent
    // We assume user wan't to set both interval, min, max to get a better result

    this._niceExtent = this._extent.slice();
    this._intervalPrecision = helper.getIntervalPrecision(interval);
  },

  /**
   * @return {Array.<number>}
   */
  getTicks: function () {
    return helper.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);
  },

  /**
   * @param {number} data
   * @param {Object} [opt]
   * @param {number|string} [opt.precision] If 'auto', use nice presision.
   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.
   * @return {string}
   */
  getLabel: function (data, opt) {
    if (data == null) {
      return '';
    }

    var precision = opt && opt.precision;

    if (precision == null) {
      precision = numberUtil.getPrecisionSafe(data) || 0;
    } else if (precision === 'auto') {
      // Should be more precise then tick.
      precision = this._intervalPrecision;
    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.
    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.


    data = roundNumber(data, precision, true);
    return formatUtil.addCommas(data);
  },

  /**
   * Update interval and extent of intervals for nice ticks
   *
   * @param {number} [splitNumber = 5] Desired number of ticks
   * @param {number} [minInterval]
   * @param {number} [maxInterval]
   */
  niceTicks: function (splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    var extent = this._extent;
    var span = extent[1] - extent[0];

    if (!isFinite(span)) {
      return;
    } // User may set axis min 0 and data are all negative
    // FIXME If it needs to reverse ?


    if (span < 0) {
      span = -span;
      extent.reverse();
    }

    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  },

  /**
   * Nice extent.
   * @param {Object} opt
   * @param {number} [opt.splitNumber = 5] Given approx tick number
   * @param {boolean} [opt.fixMin=false]
   * @param {boolean} [opt.fixMax=false]
   * @param {boolean} [opt.minInterval]
   * @param {boolean} [opt.maxInterval]
   */
  niceExtent: function (opt) {
    var extent = this._extent; // If extent start and end are same, expand them

    if (extent[0] === extent[1]) {
      if (extent[0] !== 0) {
        // Expand extent
        var expandSize = extent[0]; // In the fowllowing case
        //      Axis has been fixed max 100
        //      Plus data are all 100 and axis extent are [100, 100].
        // Extend to the both side will cause expanded max is larger than fixed max.
        // So only expand to the smaller side.

        if (!opt.fixMax) {
          extent[1] += expandSize / 2;
          extent[0] -= expandSize / 2;
        } else {
          extent[0] -= expandSize / 2;
        }
      } else {
        extent[1] = 1;
      }
    }

    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]

    if (!isFinite(span)) {
      extent[0] = 0;
      extent[1] = 1;
    }

    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;

    var interval = this._interval;

    if (!opt.fixMin) {
      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);
    }

    if (!opt.fixMax) {
      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);
    }
  }
});
/**
 * @return {module:echarts/scale/Time}
 */

IntervalScale.create = function () {
  return new IntervalScale();
};

var _default = IntervalScale;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/Log.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Scale = __webpack_require__("./node_modules/echarts/lib/scale/Scale.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var IntervalScale = __webpack_require__("./node_modules/echarts/lib/scale/Interval.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Log scale
 * @module echarts/scale/Log
 */
// Use some method of IntervalScale
var scaleProto = Scale.prototype;
var intervalScaleProto = IntervalScale.prototype;
var getPrecisionSafe = numberUtil.getPrecisionSafe;
var roundingErrorFix = numberUtil.round;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var mathPow = Math.pow;
var mathLog = Math.log;
var LogScale = Scale.extend({
  type: 'log',
  base: 10,
  $constructor: function () {
    Scale.apply(this, arguments);
    this._originalScale = new IntervalScale();
  },

  /**
   * @return {Array.<number>}
   */
  getTicks: function () {
    var originalScale = this._originalScale;
    var extent = this._extent;
    var originalExtent = originalScale.getExtent();
    return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {
      var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158

      powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
      powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
      return powVal;
    }, this);
  },

  /**
   * @param {number} val
   * @return {string}
   */
  getLabel: intervalScaleProto.getLabel,

  /**
   * @param  {number} val
   * @return {number}
   */
  scale: function (val) {
    val = scaleProto.scale.call(this, val);
    return mathPow(this.base, val);
  },

  /**
   * @param {number} start
   * @param {number} end
   */
  setExtent: function (start, end) {
    var base = this.base;
    start = mathLog(start) / mathLog(base);
    end = mathLog(end) / mathLog(base);
    intervalScaleProto.setExtent.call(this, start, end);
  },

  /**
   * @return {number} end
   */
  getExtent: function () {
    var base = this.base;
    var extent = scaleProto.getExtent.call(this);
    extent[0] = mathPow(base, extent[0]);
    extent[1] = mathPow(base, extent[1]); // Fix #4158

    var originalScale = this._originalScale;
    var originalExtent = originalScale.getExtent();
    originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
    originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
    return extent;
  },

  /**
   * @param  {Array.<number>} extent
   */
  unionExtent: function (extent) {
    this._originalScale.unionExtent(extent);

    var base = this.base;
    extent[0] = mathLog(extent[0]) / mathLog(base);
    extent[1] = mathLog(extent[1]) / mathLog(base);
    scaleProto.unionExtent.call(this, extent);
  },

  /**
   * @override
   */
  unionExtentFromData: function (data, dim) {
    // TODO
    // filter value that <= 0
    this.unionExtent(data.getApproximateExtent(dim));
  },

  /**
   * Update interval and extent of intervals for nice ticks
   * @param  {number} [approxTickNum = 10] Given approx tick number
   */
  niceTicks: function (approxTickNum) {
    approxTickNum = approxTickNum || 10;
    var extent = this._extent;
    var span = extent[1] - extent[0];

    if (span === Infinity || span <= 0) {
      return;
    }

    var interval = numberUtil.quantity(span);
    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.

    if (err <= 0.5) {
      interval *= 10;
    } // Interval should be integer


    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }

    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];
    this._interval = interval;
    this._niceExtent = niceExtent;
  },

  /**
   * Nice extent.
   * @override
   */
  niceExtent: function (opt) {
    intervalScaleProto.niceExtent.call(this, opt);
    var originalScale = this._originalScale;
    originalScale.__fixMin = opt.fixMin;
    originalScale.__fixMax = opt.fixMax;
  }
});
zrUtil.each(['contain', 'normalize'], function (methodName) {
  LogScale.prototype[methodName] = function (val) {
    val = mathLog(val) / mathLog(this.base);
    return scaleProto[methodName].call(this, val);
  };
});

LogScale.create = function () {
  return new LogScale();
};

function fixRoundingError(val, originalVal) {
  return roundingErrorFix(val, getPrecisionSafe(originalVal));
}

var _default = LogScale;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/Ordinal.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Scale = __webpack_require__("./node_modules/echarts/lib/scale/Scale.js");

var OrdinalMeta = __webpack_require__("./node_modules/echarts/lib/data/OrdinalMeta.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Linear continuous scale
 * @module echarts/coord/scale/Ordinal
 *
 * http://en.wikipedia.org/wiki/Level_of_measurement
 */
// FIXME only one data
var scaleProto = Scale.prototype;
var OrdinalScale = Scale.extend({
  type: 'ordinal',

  /**
   * @param {module:echarts/data/OrdianlMeta|Array.<string>} ordinalMeta
   */
  init: function (ordinalMeta, extent) {
    // Caution: Should not use instanceof, consider ec-extensions using
    // import approach to get OrdinalMeta class.
    if (!ordinalMeta || zrUtil.isArray(ordinalMeta)) {
      ordinalMeta = new OrdinalMeta({
        categories: ordinalMeta
      });
    }

    this._ordinalMeta = ordinalMeta;
    this._extent = extent || [0, ordinalMeta.categories.length - 1];
  },
  parse: function (val) {
    return typeof val === 'string' ? this._ordinalMeta.getOrdinal(val) // val might be float.
    : Math.round(val);
  },
  contain: function (rank) {
    rank = this.parse(rank);
    return scaleProto.contain.call(this, rank) && this._ordinalMeta.categories[rank] != null;
  },

  /**
   * Normalize given rank or name to linear [0, 1]
   * @param {number|string} [val]
   * @return {number}
   */
  normalize: function (val) {
    return scaleProto.normalize.call(this, this.parse(val));
  },
  scale: function (val) {
    return Math.round(scaleProto.scale.call(this, val));
  },

  /**
   * @return {Array}
   */
  getTicks: function () {
    var ticks = [];
    var extent = this._extent;
    var rank = extent[0];

    while (rank <= extent[1]) {
      ticks.push(rank);
      rank++;
    }

    return ticks;
  },

  /**
   * Get item on rank n
   * @param {number} n
   * @return {string}
   */
  getLabel: function (n) {
    if (!this.isBlank()) {
      // Note that if no data, ordinalMeta.categories is an empty array.
      return this._ordinalMeta.categories[n];
    }
  },

  /**
   * @return {number}
   */
  count: function () {
    return this._extent[1] - this._extent[0] + 1;
  },

  /**
   * @override
   */
  unionExtentFromData: function (data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  },
  getOrdinalMeta: function () {
    return this._ordinalMeta;
  },
  niceTicks: zrUtil.noop,
  niceExtent: zrUtil.noop
});
/**
 * @return {module:echarts/scale/Time}
 */

OrdinalScale.create = function () {
  return new OrdinalScale();
};

var _default = OrdinalScale;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/Scale.js":
/***/ (function(module, exports, __webpack_require__) {

var clazzUtil = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * // Scale class management
 * @module echarts/scale/Scale
 */

/**
 * @param {Object} [setting]
 */
function Scale(setting) {
  this._setting = setting || {};
  /**
   * Extent
   * @type {Array.<number>}
   * @protected
   */

  this._extent = [Infinity, -Infinity];
  /**
   * Step is calculated in adjustExtent
   * @type {Array.<number>}
   * @protected
   */

  this._interval = 0;
  this.init && this.init.apply(this, arguments);
}
/**
 * Parse input val to valid inner number.
 * @param {*} val
 * @return {number}
 */


Scale.prototype.parse = function (val) {
  // Notice: This would be a trap here, If the implementation
  // of this method depends on extent, and this method is used
  // before extent set (like in dataZoom), it would be wrong.
  // Nevertheless, parse does not depend on extent generally.
  return val;
};

Scale.prototype.getSetting = function (name) {
  return this._setting[name];
};

Scale.prototype.contain = function (val) {
  var extent = this._extent;
  return val >= extent[0] && val <= extent[1];
};
/**
 * Normalize value to linear [0, 1], return 0.5 if extent span is 0
 * @param {number} val
 * @return {number}
 */


Scale.prototype.normalize = function (val) {
  var extent = this._extent;

  if (extent[1] === extent[0]) {
    return 0.5;
  }

  return (val - extent[0]) / (extent[1] - extent[0]);
};
/**
 * Scale normalized value
 * @param {number} val
 * @return {number}
 */


Scale.prototype.scale = function (val) {
  var extent = this._extent;
  return val * (extent[1] - extent[0]) + extent[0];
};
/**
 * Set extent from data
 * @param {Array.<number>} other
 */


Scale.prototype.unionExtent = function (other) {
  var extent = this._extent;
  other[0] < extent[0] && (extent[0] = other[0]);
  other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power
  // this.setExtent(extent[0], extent[1]);
};
/**
 * Set extent from data
 * @param {module:echarts/data/List} data
 * @param {string} dim
 */


Scale.prototype.unionExtentFromData = function (data, dim) {
  this.unionExtent(data.getApproximateExtent(dim));
};
/**
 * Get extent
 * @return {Array.<number>}
 */


Scale.prototype.getExtent = function () {
  return this._extent.slice();
};
/**
 * Set extent
 * @param {number} start
 * @param {number} end
 */


Scale.prototype.setExtent = function (start, end) {
  var thisExtent = this._extent;

  if (!isNaN(start)) {
    thisExtent[0] = start;
  }

  if (!isNaN(end)) {
    thisExtent[1] = end;
  }
};
/**
 * When axis extent depends on data and no data exists,
 * axis ticks should not be drawn, which is named 'blank'.
 */


Scale.prototype.isBlank = function () {
  return this._isBlank;
},
/**
 * When axis extent depends on data and no data exists,
 * axis ticks should not be drawn, which is named 'blank'.
 */
Scale.prototype.setBlank = function (isBlank) {
  this._isBlank = isBlank;
};
/**
 * @abstract
 * @param {*} tick
 * @return {string} label of the tick.
 */

Scale.prototype.getLabel = null;
clazzUtil.enableClassExtend(Scale);
clazzUtil.enableClassManagement(Scale, {
  registerWhenExtend: true
});
var _default = Scale;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/Time.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

var scaleHelper = __webpack_require__("./node_modules/echarts/lib/scale/helper.js");

var IntervalScale = __webpack_require__("./node_modules/echarts/lib/scale/Interval.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// [About UTC and local time zone]:
// In most cases, `number.parseDate` will treat input data string as local time
// (except time zone is specified in time string). And `format.formateTime` returns
// local time by default. option.useUTC is false by default. This design have
// concidered these common case:
// (1) Time that is persistent in server is in UTC, but it is needed to be diplayed
// in local time by default.
// (2) By default, the input data string (e.g., '2011-01-02') should be displayed
// as its original time, without any time difference.
var intervalScaleProto = IntervalScale.prototype;
var mathCeil = Math.ceil;
var mathFloor = Math.floor;
var ONE_SECOND = 1000;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24; // FIXME 公用？

var bisect = function (a, x, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;

    if (a[mid][1] < x) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }

  return lo;
};
/**
 * @alias module:echarts/coord/scale/Time
 * @constructor
 */


var TimeScale = IntervalScale.extend({
  type: 'time',

  /**
   * @override
   */
  getLabel: function (val) {
    var stepLvl = this._stepLvl;
    var date = new Date(val);
    return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));
  },

  /**
   * @override
   */
  niceExtent: function (opt) {
    var extent = this._extent; // If extent start and end are same, expand them

    if (extent[0] === extent[1]) {
      // Expand extent
      extent[0] -= ONE_DAY;
      extent[1] += ONE_DAY;
    } // If there are no data and extent are [Infinity, -Infinity]


    if (extent[1] === -Infinity && extent[0] === Infinity) {
      var d = new Date();
      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
      extent[0] = extent[1] - ONE_DAY;
    }

    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;

    var interval = this._interval;

    if (!opt.fixMin) {
      extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
    }

    if (!opt.fixMax) {
      extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
    }
  },

  /**
   * @override
   */
  niceTicks: function (approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    var extent = this._extent;
    var span = extent[1] - extent[0];
    var approxInterval = span / approxTickNum;

    if (minInterval != null && approxInterval < minInterval) {
      approxInterval = minInterval;
    }

    if (maxInterval != null && approxInterval > maxInterval) {
      approxInterval = maxInterval;
    }

    var scaleLevelsLen = scaleLevels.length;
    var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
    var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
    var interval = level[1]; // Same with interval scale if span is much larger than 1 year

    if (level[0] === 'year') {
      var yearSpan = span / interval; // From "Nice Numbers for Graph Labels" of Graphic Gems
      // var niceYearSpan = numberUtil.nice(yearSpan, false);

      var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);
      interval *= yearStep;
    }

    var timezoneOffset = this.getSetting('useUTC') ? 0 : new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 60 * 1000;
    var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];
    scaleHelper.fixExtent(niceExtent, extent);
    this._stepLvl = level; // Interval will be used in getTicks

    this._interval = interval;
    this._niceExtent = niceExtent;
  },
  parse: function (val) {
    // val might be float.
    return +numberUtil.parseDate(val);
  }
});
zrUtil.each(['contain', 'normalize'], function (methodName) {
  TimeScale.prototype[methodName] = function (val) {
    return intervalScaleProto[methodName].call(this, this.parse(val));
  };
}); // Steps from d3

var scaleLevels = [// Format              interval
['hh:mm:ss', ONE_SECOND], // 1s
['hh:mm:ss', ONE_SECOND * 5], // 5s
['hh:mm:ss', ONE_SECOND * 10], // 10s
['hh:mm:ss', ONE_SECOND * 15], // 15s
['hh:mm:ss', ONE_SECOND * 30], // 30s
['hh:mm\nMM-dd', ONE_MINUTE], // 1m
['hh:mm\nMM-dd', ONE_MINUTE * 5], // 5m
['hh:mm\nMM-dd', ONE_MINUTE * 10], // 10m
['hh:mm\nMM-dd', ONE_MINUTE * 15], // 15m
['hh:mm\nMM-dd', ONE_MINUTE * 30], // 30m
['hh:mm\nMM-dd', ONE_HOUR], // 1h
['hh:mm\nMM-dd', ONE_HOUR * 2], // 2h
['hh:mm\nMM-dd', ONE_HOUR * 6], // 6h
['hh:mm\nMM-dd', ONE_HOUR * 12], // 12h
['MM-dd\nyyyy', ONE_DAY], // 1d
['MM-dd\nyyyy', ONE_DAY * 2], // 2d
['MM-dd\nyyyy', ONE_DAY * 3], // 3d
['MM-dd\nyyyy', ONE_DAY * 4], // 4d
['MM-dd\nyyyy', ONE_DAY * 5], // 5d
['MM-dd\nyyyy', ONE_DAY * 6], // 6d
['week', ONE_DAY * 7], // 7d
['MM-dd\nyyyy', ONE_DAY * 10], // 10d
['week', ONE_DAY * 14], // 2w
['week', ONE_DAY * 21], // 3w
['month', ONE_DAY * 31], // 1M
['week', ONE_DAY * 42], // 6w
['month', ONE_DAY * 62], // 2M
['week', ONE_DAY * 42], // 10w
['quarter', ONE_DAY * 380 / 4], // 3M
['month', ONE_DAY * 31 * 4], // 4M
['month', ONE_DAY * 31 * 5], // 5M
['half-year', ONE_DAY * 380 / 2], // 6M
['month', ONE_DAY * 31 * 8], // 8M
['month', ONE_DAY * 31 * 10], // 10M
['year', ONE_DAY * 380] // 1Y
];
/**
 * @param {module:echarts/model/Model}
 * @return {module:echarts/scale/Time}
 */

TimeScale.create = function (model) {
  return new TimeScale({
    useUTC: model.ecModel.get('useUTC')
  });
};

var _default = TimeScale;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/scale/helper.js":
/***/ (function(module, exports, __webpack_require__) {

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * For testable.
 */
var roundNumber = numberUtil.round;
/**
 * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.
 *                                Should be extent[0] < extent[1].
 * @param {number} splitNumber splitNumber should be >= 1.
 * @param {number} [minInterval]
 * @param {number} [maxInterval]
 * @return {Object} {interval, intervalPrecision, niceTickExtent}
 */

function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
  var result = {};
  var span = extent[1] - extent[0];
  var interval = result.interval = numberUtil.nice(span / splitNumber, true);

  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }

  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  } // Tow more digital for tick.


  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent

  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];
  fixExtent(niceTickExtent, extent);
  return result;
}
/**
 * @param {number} interval
 * @return {number} interval precision
 */


function getIntervalPrecision(interval) {
  // Tow more digital for tick.
  return numberUtil.getPrecisionSafe(interval) + 2;
}

function clamp(niceTickExtent, idx, extent) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.


function fixExtent(niceTickExtent, extent) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
  clamp(niceTickExtent, 0, extent);
  clamp(niceTickExtent, 1, extent);

  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}

function intervalScaleGetTicks(interval, extent, niceTickExtent, intervalPrecision) {
  var ticks = []; // If interval is 0, return [];

  if (!interval) {
    return ticks;
  } // Consider this case: using dataZoom toolbox, zoom and zoom.


  var safeLimit = 10000;

  if (extent[0] < niceTickExtent[0]) {
    ticks.push(extent[0]);
  }

  var tick = niceTickExtent[0];

  while (tick <= niceTickExtent[1]) {
    ticks.push(tick); // Avoid rounding error

    tick = roundNumber(tick + interval, intervalPrecision);

    if (tick === ticks[ticks.length - 1]) {
      // Consider out of safe float point, e.g.,
      // -3711126.9907707 + 2e-10 === -3711126.9907707
      break;
    }

    if (ticks.length > safeLimit) {
      return [];
    }
  } // Consider this case: the last item of ticks is smaller
  // than niceTickExtent[1] and niceTickExtent[1] === extent[1].


  if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {
    ticks.push(extent[1]);
  }

  return ticks;
}

exports.intervalScaleNiceTicks = intervalScaleNiceTicks;
exports.getIntervalPrecision = getIntervalPrecision;
exports.fixExtent = fixExtent;
exports.intervalScaleGetTicks = intervalScaleGetTicks;

/***/ }),

/***/ "./node_modules/echarts/lib/stream/Scheduler.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var each = _util.each;
var map = _util.map;
var isArray = _util.isArray;
var isFunction = _util.isFunction;
var createHashMap = _util.createHashMap;
var noop = _util.noop;

var _task = __webpack_require__("./node_modules/echarts/lib/stream/task.js");

var createTask = _task.createTask;

var _component = __webpack_require__("./node_modules/echarts/lib/util/component.js");

var getUID = _component.getUID;

var GlobalModel = __webpack_require__("./node_modules/echarts/lib/model/Global.js");

var ExtensionAPI = __webpack_require__("./node_modules/echarts/lib/ExtensionAPI.js");

var _model = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var normalizeToArray = _model.normalizeToArray;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @module echarts/stream/Scheduler
 */

/**
 * @constructor
 */
function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {
  this.ecInstance = ecInstance;
  this.api = api;
  this.unfinished; // Fix current processors in case that in some rear cases that
  // processors might be registered after echarts instance created.
  // Register processors incrementally for a echarts instance is
  // not supported by this stream architecture.

  var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
  var visualHandlers = this._visualHandlers = visualHandlers.slice();
  this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
  /**
   * @private
   * @type {
   *     [handlerUID: string]: {
   *         seriesTaskMap?: {
   *             [seriesUID: string]: Task
   *         },
   *         overallTask?: Task
   *     }
   * }
   */

  this._stageTaskMap = createHashMap();
}

var proto = Scheduler.prototype;
/**
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} payload
 */

proto.restoreData = function (ecModel, payload) {
  // TODO: Only restroe needed series and components, but not all components.
  // Currently `restoreData` of all of the series and component will be called.
  // But some independent components like `title`, `legend`, `graphic`, `toolbox`,
  // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,
  // and some components like coordinate system, axes, dataZoom, visualMap only
  // need their target series refresh.
  // (1) If we are implementing this feature some day, we should consider these cases:
  // if a data processor depends on a component (e.g., dataZoomProcessor depends
  // on the settings of `dataZoom`), it should be re-performed if the component
  // is modified by `setOption`.
  // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,
  // it should be re-performed when the result array of `getTargetSeries` changed.
  // We use `dependencies` to cover these issues.
  // (3) How to update target series when coordinate system related components modified.
  // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,
  // and this case all of the tasks will be set as dirty.
  ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also
  // depends on all of the series.
  // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks
  // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure
  // that the overall task is set as dirty and to be performed, otherwise it probably cause
  // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it
  // probably cause state chaos (consider `dataZoomProcessor`).

  this._stageTaskMap.each(function (taskRecord) {
    var overallTask = taskRecord.overallTask;
    overallTask && overallTask.dirty();
  });
}; // If seriesModel provided, incremental threshold is check by series data.


proto.getPerformArgs = function (task, isBlock) {
  // For overall task
  if (!task.__pipeline) {
    return;
  }

  var pipeline = this._pipelineMap.get(task.__pipeline.id);

  var pCtx = pipeline.context;
  var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
  var step = incremental ? pipeline.step : null;
  var modDataCount = pCtx && pCtx.modDataCount;
  var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
  return {
    step: step,
    modBy: modBy,
    modDataCount: modDataCount
  };
};

proto.getPipeline = function (pipelineId) {
  return this._pipelineMap.get(pipelineId);
};
/**
 * Current, progressive rendering starts from visual and layout.
 * Always detect render mode in the same stage, avoiding that incorrect
 * detection caused by data filtering.
 * Caution:
 * `updateStreamModes` use `seriesModel.getData()`.
 */


proto.updateStreamModes = function (seriesModel, view) {
  var pipeline = this._pipelineMap.get(seriesModel.uid);

  var data = seriesModel.getData();
  var dataLen = data.count(); // `progressiveRender` means that can render progressively in each
  // animation frame. Note that some types of series do not provide
  // `view.incrementalPrepareRender` but support `chart.appendData`. We
  // use the term `incremental` but not `progressive` to describe the
  // case that `chart.appendData`.

  var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
  var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.
  // see `test/candlestick-large3.html`

  var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;
  seriesModel.pipelineContext = pipeline.context = {
    progressiveRender: progressiveRender,
    modDataCount: modDataCount,
    large: large
  };
};

proto.restorePipelines = function (ecModel) {
  var scheduler = this;
  var pipelineMap = scheduler._pipelineMap = createHashMap();
  ecModel.eachSeries(function (seriesModel) {
    var progressive = seriesModel.getProgressive();
    var pipelineId = seriesModel.uid;
    pipelineMap.set(pipelineId, {
      id: pipelineId,
      head: null,
      tail: null,
      threshold: seriesModel.getProgressiveThreshold(),
      progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
      blockIndex: -1,
      step: Math.round(progressive || 700),
      count: 0
    });
    pipe(scheduler, seriesModel, seriesModel.dataTask);
  });
};

proto.prepareStageTasks = function () {
  var stageTaskMap = this._stageTaskMap;
  var ecModel = this.ecInstance.getModel();
  var api = this.api;
  each(this._allHandlers, function (handler) {
    var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);
    handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);
    handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);
  }, this);
};

proto.prepareView = function (view, model, ecModel, api) {
  var renderTask = view.renderTask;
  var context = renderTask.context;
  context.model = model;
  context.ecModel = ecModel;
  context.api = api;
  renderTask.__block = !view.incrementalPrepareRender;
  pipe(this, model, renderTask);
};

proto.performDataProcessorTasks = function (ecModel, payload) {
  // If we do not use `block` here, it should be considered when to update modes.
  performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {
    block: true
  });
}; // opt
// opt.visualType: 'visual' or 'layout'
// opt.setDirty


proto.performVisualTasks = function (ecModel, payload, opt) {
  performStageTasks(this, this._visualHandlers, ecModel, payload, opt);
};

function performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {
  opt = opt || {};
  var unfinished;
  each(stageHandlers, function (stageHandler, idx) {
    if (opt.visualType && opt.visualType !== stageHandler.visualType) {
      return;
    }

    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);

    var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
    var overallTask = stageHandlerRecord.overallTask;

    if (overallTask) {
      var overallNeedDirty;
      var agentStubMap = overallTask.agentStubMap;
      agentStubMap.each(function (stub) {
        if (needSetDirty(opt, stub)) {
          stub.dirty();
          overallNeedDirty = true;
        }
      });
      overallNeedDirty && overallTask.dirty();
      updatePayload(overallTask, payload);
      var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,
      // then execute the overall task. And stub will call seriesModel.setData,
      // which ensures that in the overallTask seriesModel.getData() will not
      // return incorrect data.

      agentStubMap.each(function (stub) {
        stub.perform(performArgs);
      });
      unfinished |= overallTask.perform(performArgs);
    } else if (seriesTaskMap) {
      seriesTaskMap.each(function (task, pipelineId) {
        if (needSetDirty(opt, task)) {
          task.dirty();
        }

        var performArgs = scheduler.getPerformArgs(task, opt.block);
        performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
        updatePayload(task, payload);
        unfinished |= task.perform(performArgs);
      });
    }
  });

  function needSetDirty(opt, task) {
    return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));
  }

  scheduler.unfinished |= unfinished;
}

proto.performSeriesTasks = function (ecModel) {
  var unfinished;
  ecModel.eachSeries(function (seriesModel) {
    // Progress to the end for dataInit and dataRestore.
    unfinished |= seriesModel.dataTask.perform();
  });
  this.unfinished |= unfinished;
};

proto.plan = function () {
  // Travel pipelines, check block.
  this._pipelineMap.each(function (pipeline) {
    var task = pipeline.tail;

    do {
      if (task.__block) {
        pipeline.blockIndex = task.__idxInPipeline;
        break;
      }

      task = task.getUpstream();
    } while (task);
  });
};

var updatePayload = proto.updatePayload = function (task, payload) {
  payload !== 'remain' && (task.context.payload = payload);
};

function createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
  var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());
  var seriesType = stageHandler.seriesType;
  var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,
  // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,
  // it works but it may cause other irrelevant charts blocked.

  if (stageHandler.createOnAllSeries) {
    ecModel.eachRawSeries(create);
  } else if (seriesType) {
    ecModel.eachRawSeriesByType(seriesType, create);
  } else if (getTargetSeries) {
    getTargetSeries(ecModel, api).each(create);
  }

  function create(seriesModel) {
    var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.
    // Reuse original task instance.

    var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({
      plan: seriesTaskPlan,
      reset: seriesTaskReset,
      count: seriesTaskCount
    }));
    task.context = {
      model: seriesModel,
      ecModel: ecModel,
      api: api,
      useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
      plan: stageHandler.plan,
      reset: stageHandler.reset,
      scheduler: scheduler
    };
    pipe(scheduler, seriesModel, task);
  } // Clear unused series tasks.


  var pipelineMap = scheduler._pipelineMap;
  seriesTaskMap.each(function (task, pipelineId) {
    if (!pipelineMap.get(pipelineId)) {
      task.dispose();
      seriesTaskMap.removeKey(pipelineId);
    }
  });
}

function createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
  var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.
  || createTask({
    reset: overallTaskReset
  });
  overallTask.context = {
    ecModel: ecModel,
    api: api,
    overallReset: stageHandler.overallReset,
    scheduler: scheduler
  }; // Reuse orignal stubs.

  var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();
  var seriesType = stageHandler.seriesType;
  var getTargetSeries = stageHandler.getTargetSeries;
  var overallProgress = true;
  var modifyOutputEnd = stageHandler.modifyOutputEnd; // An overall task with seriesType detected or has `getTargetSeries`, we add
  // stub in each pipelines, it will set the overall task dirty when the pipeline
  // progress. Moreover, to avoid call the overall task each frame (too frequent),
  // we set the pipeline block.

  if (seriesType) {
    ecModel.eachRawSeriesByType(seriesType, createStub);
  } else if (getTargetSeries) {
    getTargetSeries(ecModel, api).each(createStub);
  } // Otherwise, (usually it is legancy case), the overall task will only be
  // executed when upstream dirty. Otherwise the progressive rendering of all
  // pipelines will be disabled unexpectedly. But it still needs stubs to receive
  // dirty info from upsteam.
  else {
      overallProgress = false;
      each(ecModel.getSeries(), createStub);
    }

  function createStub(seriesModel) {
    var pipelineId = seriesModel.uid;
    var stub = agentStubMap.get(pipelineId);

    if (!stub) {
      stub = agentStubMap.set(pipelineId, createTask({
        reset: stubReset,
        onDirty: stubOnDirty
      })); // When the result of `getTargetSeries` changed, the overallTask
      // should be set as dirty and re-performed.

      overallTask.dirty();
    }

    stub.context = {
      model: seriesModel,
      overallProgress: overallProgress,
      modifyOutputEnd: modifyOutputEnd
    };
    stub.agent = overallTask;
    stub.__block = overallProgress;
    pipe(scheduler, seriesModel, stub);
  } // Clear unused stubs.


  var pipelineMap = scheduler._pipelineMap;
  agentStubMap.each(function (stub, pipelineId) {
    if (!pipelineMap.get(pipelineId)) {
      stub.dispose(); // When the result of `getTargetSeries` changed, the overallTask
      // should be set as dirty and re-performed.

      overallTask.dirty();
      agentStubMap.removeKey(pipelineId);
    }
  });
}

function overallTaskReset(context) {
  context.overallReset(context.ecModel, context.api, context.payload);
}

function stubReset(context, upstreamContext) {
  return context.overallProgress && stubProgress;
}

function stubProgress() {
  this.agent.dirty();
  this.getDownstream().dirty();
}

function stubOnDirty() {
  this.agent && this.agent.dirty();
}

function seriesTaskPlan(context) {
  return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);
}

function seriesTaskReset(context) {
  if (context.useClearVisual) {
    context.data.clearAllVisual();
  }

  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
  return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {
    return makeSeriesTaskProgress(idx);
  }) : singleSeriesTaskProgress;
}

var singleSeriesTaskProgress = makeSeriesTaskProgress(0);

function makeSeriesTaskProgress(resetDefineIdx) {
  return function (params, context) {
    var data = context.data;
    var resetDefine = context.resetDefines[resetDefineIdx];

    if (resetDefine && resetDefine.dataEach) {
      for (var i = params.start; i < params.end; i++) {
        resetDefine.dataEach(data, i);
      }
    } else if (resetDefine && resetDefine.progress) {
      resetDefine.progress(params, data);
    }
  };
}

function seriesTaskCount(context) {
  return context.data.count();
}

function pipe(scheduler, seriesModel, task) {
  var pipelineId = seriesModel.uid;

  var pipeline = scheduler._pipelineMap.get(pipelineId);

  !pipeline.head && (pipeline.head = task);
  pipeline.tail && pipeline.tail.pipe(task);
  pipeline.tail = task;
  task.__idxInPipeline = pipeline.count++;
  task.__pipeline = pipeline;
}

Scheduler.wrapStageHandler = function (stageHandler, visualType) {
  if (isFunction(stageHandler)) {
    stageHandler = {
      overallReset: stageHandler,
      seriesType: detectSeriseType(stageHandler)
    };
  }

  stageHandler.uid = getUID('stageHandler');
  visualType && (stageHandler.visualType = visualType);
  return stageHandler;
};
/**
 * Only some legacy stage handlers (usually in echarts extensions) are pure function.
 * To ensure that they can work normally, they should work in block mode, that is,
 * they should not be started util the previous tasks finished. So they cause the
 * progressive rendering disabled. We try to detect the series type, to narrow down
 * the block range to only the series type they concern, but not all series.
 */


function detectSeriseType(legacyFunc) {
  seriesType = null;

  try {
    // Assume there is no async when calling `eachSeriesByType`.
    legacyFunc(ecModelMock, apiMock);
  } catch (e) {}

  return seriesType;
}

var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, GlobalModel);
mockMethods(apiMock, ExtensionAPI);

ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {
  seriesType = type;
};

ecModelMock.eachComponent = function (cond) {
  if (cond.mainType === 'series' && cond.subType) {
    seriesType = cond.subType;
  }
};

function mockMethods(target, Clz) {
  for (var name in Clz.prototype) {
    // Do not use hasOwnProperty
    target[name] = noop;
  }
}

var _default = Scheduler;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/stream/task.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var assert = _util.assert;
var isArray = _util.isArray;

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @param {Object} define
 * @return See the return of `createTask`.
 */
function createTask(define) {
  return new Task(define);
}
/**
 * @constructor
 * @param {Object} define
 * @param {Function} define.reset Custom reset
 * @param {Function} [define.plan] Returns 'reset' indicate reset immediately.
 * @param {Function} [define.count] count is used to determin data task.
 * @param {Function} [define.onDirty] count is used to determin data task.
 */


function Task(define) {
  define = define || {};
  this._reset = define.reset;
  this._plan = define.plan;
  this._count = define.count;
  this._onDirty = define.onDirty;
  this._dirty = true; // Context must be specified implicitly, to
  // avoid miss update context when model changed.

  this.context;
}

var taskProto = Task.prototype;
/**
 * @param {Object} performArgs
 * @param {number} [performArgs.step] Specified step.
 * @param {number} [performArgs.skip] Skip customer perform call.
 * @param {number} [performArgs.modBy] Sampling window size.
 * @param {number} [performArgs.modDataCount] Sampling count.
 */

taskProto.perform = function (performArgs) {
  var upTask = this._upstream;
  var skip = performArgs && performArgs.skip; // TODO some refactor.
  // Pull data. Must pull data each time, because context.data
  // may be updated by Series.setData.

  if (this._dirty && upTask) {
    var context = this.context;
    context.data = context.outputData = upTask.context.outputData;
  }

  if (this.__pipeline) {
    this.__pipeline.currentTask = this;
  }

  var planResult;

  if (this._plan && !skip) {
    planResult = this._plan(this.context);
  } // Support sharding by mod, which changes the render sequence and makes the rendered graphic
  // elements uniformed distributed when progress, especially when moving or zooming.


  var lastModBy = normalizeModBy(this._modBy);
  var lastModDataCount = this._modDataCount || 0;
  var modBy = normalizeModBy(performArgs && performArgs.modBy);
  var modDataCount = performArgs && performArgs.modDataCount || 0;

  if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
    planResult = 'reset';
  }

  function normalizeModBy(val) {
    !(val >= 1) && (val = 1); // jshint ignore:line

    return val;
  }

  var forceFirstProgress;

  if (this._dirty || planResult === 'reset') {
    this._dirty = false;
    forceFirstProgress = reset(this, skip);
  }

  this._modBy = modBy;
  this._modDataCount = modDataCount;
  var step = performArgs && performArgs.step;

  if (upTask) {
    this._dueEnd = upTask._outputDueEnd;
  } // DataTask or overallTask
  else {
      this._dueEnd = this._count ? this._count(this.context) : Infinity;
    } // Note: Stubs, that its host overall task let it has progress, has progress.
  // If no progress, pass index from upstream to downstream each time plan called.


  if (this._progress) {
    var start = this._dueIndex;
    var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);

    if (!skip && (forceFirstProgress || start < end)) {
      var progress = this._progress;

      if (isArray(progress)) {
        for (var i = 0; i < progress.length; i++) {
          doProgress(this, progress[i], start, end, modBy, modDataCount);
        }
      } else {
        doProgress(this, progress, start, end, modBy, modDataCount);
      }
    }

    this._dueIndex = end; // If no `outputDueEnd`, assume that output data and
    // input data is the same, so use `dueIndex` as `outputDueEnd`.

    var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;
    this._outputDueEnd = outputDueEnd;
  } else {
    // (1) Some overall task has no progress.
    // (2) Stubs, that its host overall task do not let it has progress, has no progress.
    // This should always be performed so it can be passed to downstream.
    this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
  }

  return this.unfinished();
};

var iterator = function () {
  var end;
  var current;
  var modBy;
  var modDataCount;
  var winCount;
  var it = {
    reset: function (s, e, sStep, sCount) {
      current = s;
      end = e;
      modBy = sStep;
      modDataCount = sCount;
      winCount = Math.ceil(modDataCount / modBy);
      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
    }
  };
  return it;

  function sequentialNext() {
    return current < end ? current++ : null;
  }

  function modNext() {
    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
    var result = current >= end ? null : dataIndex < modDataCount ? dataIndex // If modDataCount is smaller than data.count() (consider `appendData` case),
    // Use normal linear rendering mode.
    : current;
    current++;
    return result;
  }
}();

taskProto.dirty = function () {
  this._dirty = true;
  this._onDirty && this._onDirty(this.context);
};

function doProgress(taskIns, progress, start, end, modBy, modDataCount) {
  iterator.reset(start, end, modBy, modDataCount);
  taskIns._callingProgress = progress;

  taskIns._callingProgress({
    start: start,
    end: end,
    count: end - start,
    next: iterator.next
  }, taskIns.context);
}

function reset(taskIns, skip) {
  taskIns._dueIndex = taskIns._outputDueEnd = taskIns._dueEnd = 0;
  taskIns._settedOutputEnd = null;
  var progress;
  var forceFirstProgress;

  if (!skip && taskIns._reset) {
    progress = taskIns._reset(taskIns.context);

    if (progress && progress.progress) {
      forceFirstProgress = progress.forceFirstProgress;
      progress = progress.progress;
    } // To simplify no progress checking, array must has item.


    if (isArray(progress) && !progress.length) {
      progress = null;
    }
  }

  taskIns._progress = progress;
  taskIns._modBy = taskIns._modDataCount = null;
  var downstream = taskIns._downstream;
  downstream && downstream.dirty();
  return forceFirstProgress;
}
/**
 * @return {boolean}
 */


taskProto.unfinished = function () {
  return this._progress && this._dueIndex < this._dueEnd;
};
/**
 * @param {Object} downTask The downstream task.
 * @return {Object} The downstream task.
 */


taskProto.pipe = function (downTask) {
  // If already downstream, do not dirty downTask.
  if (this._downstream !== downTask || this._dirty) {
    this._downstream = downTask;
    downTask._upstream = this;
    downTask.dirty();
  }
};

taskProto.dispose = function () {
  if (this._disposed) {
    return;
  }

  this._upstream && (this._upstream._downstream = null);
  this._downstream && (this._downstream._upstream = null);
  this._dirty = false;
  this._disposed = true;
};

taskProto.getUpstream = function () {
  return this._upstream;
};

taskProto.getDownstream = function () {
  return this._downstream;
};

taskProto.setOutputEnd = function (end) {
  // This only happend in dataTask, dataZoom, map, currently.
  // where dataZoom do not set end each time, but only set
  // when reset. So we should record the setted end, in case
  // that the stub of dataZoom perform again and earse the
  // setted end by upstream.
  this._outputDueEnd = this._settedOutputEnd = end;
}; ///////////////////////////////////////////////////////////
// For stream debug (Should be commented out after used!)
// Usage: printTask(this, 'begin');
// Usage: printTask(this, null, {someExtraProp});
// function printTask(task, prefix, extra) {
//     window.ecTaskUID == null && (window.ecTaskUID = 0);
//     task.uidDebug == null && (task.uidDebug = `task_${window.ecTaskUID++}`);
//     task.agent && task.agent.uidDebug == null && (task.agent.uidDebug = `task_${window.ecTaskUID++}`);
//     var props = [];
//     if (task.__pipeline) {
//         var val = `${task.__idxInPipeline}/${task.__pipeline.tail.__idxInPipeline} ${task.agent ? '(stub)' : ''}`;
//         props.push({text: 'idx', value: val});
//     } else {
//         var stubCount = 0;
//         task.agentStubMap.each(() => stubCount++);
//         props.push({text: 'idx', value: `overall (stubs: ${stubCount})`});
//     }
//     props.push({text: 'uid', value: task.uidDebug});
//     if (task.__pipeline) {
//         props.push({text: 'pid', value: task.__pipeline.id});
//         task.agent && props.push(
//             {text: 'stubFor', value: task.agent.uidDebug}
//         );
//     }
//     props.push(
//         {text: 'dirty', value: task._dirty},
//         {text: 'dueIndex', value: task._dueIndex},
//         {text: 'dueEnd', value: task._dueEnd},
//         {text: 'outputDueEnd', value: task._outputDueEnd}
//     );
//     if (extra) {
//         Object.keys(extra).forEach(key => {
//             props.push({text: key, value: extra[key]});
//         });
//     }
//     var args = ['color: blue'];
//     var msg = `%c[${prefix || 'T'}] %c` + props.map(item => (
//         args.push('color: black', 'color: red'),
//         `${item.text}: %c${item.value}`
//     )).join('%c, ');
//     console.log.apply(console, [msg].concat(args));
//     // console.log(this);
// }


exports.createTask = createTask;

/***/ }),

/***/ "./node_modules/echarts/lib/theme/dark.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var contrastColor = '#eee';

var axisCommon = function () {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    axisTick: {
      lineStyle: {
        color: contrastColor
      }
    },
    axisLabel: {
      textStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        type: 'dashed',
        color: '#aaa'
      }
    },
    splitArea: {
      areaStyle: {
        color: contrastColor
      }
    }
  };
};

var colorPalette = ['#dd6b66', '#759aa0', '#e69d87', '#8dc1a9', '#ea7e53', '#eedd78', '#73a373', '#73b9bc', '#7289ab', '#91ca8c', '#f49f42'];
var theme = {
  color: colorPalette,
  backgroundColor: '#333',
  tooltip: {
    axisPointer: {
      lineStyle: {
        color: contrastColor
      },
      crossStyle: {
        color: contrastColor
      }
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: contrastColor
    }
  },
  toolbox: {
    iconStyle: {
      normal: {
        borderColor: contrastColor
      }
    }
  },
  dataZoom: {
    textStyle: {
      color: contrastColor
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    itemStyle: {
      normal: {
        color: colorPalette[1]
      }
    },
    label: {
      normal: {
        textStyle: {
          color: contrastColor
        }
      }
    },
    controlStyle: {
      normal: {
        color: contrastColor,
        borderColor: contrastColor
      }
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: 'circle'
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      textStyle: {
        color: contrastColor
      }
    }
  },
  candlestick: {
    itemStyle: {
      normal: {
        color: '#FD1050',
        color0: '#0CF49B',
        borderColor: '#FD1050',
        borderColor0: '#0CF49B'
      }
    }
  }
};
theme.categoryAxis.splitLine.show = false;
var _default = theme;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/theme/light.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var colorAll = ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF'];
var _default = {
  color: colorAll,
  colorLayer: [['#37A2DA', '#ffd85c', '#fd7b5f'], ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'], ['#37A2DA', '#32C5E9', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#e7bcf3', '#8378EA', '#96BFFF'], colorAll]
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/util/clazz.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/echarts/lib/config.js");

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var TYPE_DELIMITER = '.';
var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
/**
 * Notice, parseClassType('') should returns {main: '', sub: ''}
 * @public
 */

function parseClassType(componentType) {
  var ret = {
    main: '',
    sub: ''
  };

  if (componentType) {
    componentType = componentType.split(TYPE_DELIMITER);
    ret.main = componentType[0] || '';
    ret.sub = componentType[1] || '';
  }

  return ret;
}
/**
 * @public
 */


function checkClassType(componentType) {
  zrUtil.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
/**
 * @public
 */


function enableClassExtend(RootClass, mandatoryMethods) {
  RootClass.$constructor = RootClass;

  RootClass.extend = function (proto) {
    var superClass = this;

    var ExtendedClass = function () {
      if (!proto.$constructor) {
        superClass.apply(this, arguments);
      } else {
        proto.$constructor.apply(this, arguments);
      }
    };

    zrUtil.extend(ExtendedClass.prototype, proto);
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    zrUtil.inherits(ExtendedClass, this);
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
}

var classBase = 0;
/**
 * Can not use instanceof, consider different scope by
 * cross domain or es module import in ec extensions.
 * Mount a method "isInstance()" to Clz.
 */

function enableClassCheck(Clz) {
  var classAttr = ['__\0is_clz', classBase++, Math.random().toFixed(3)].join('_');
  Clz.prototype[classAttr] = true;

  Clz.isInstance = function (obj) {
    return !!(obj && obj[classAttr]);
  };
} // superCall should have class info, which can not be fetch from 'this'.
// Consider this case:
// class A has method f,
// class B inherits class A, overrides method f, f call superApply('f'),
// class C inherits class B, do not overrides method f,
// then when method of class C is called, dead loop occured.


function superCall(context, methodName) {
  var args = zrUtil.slice(arguments, 2);
  return this.superClass.prototype[methodName].apply(context, args);
}

function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
/**
 * @param {Object} entity
 * @param {Object} options
 * @param {boolean} [options.registerWhenExtend]
 * @public
 */


function enableClassManagement(entity, options) {
  options = options || {};
  /**
   * Component model classes
   * key: componentType,
   * value:
   *     componentClass, when componentType is 'xxx'
   *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
   * @type {Object}
   */

  var storage = {};

  entity.registerClass = function (Clazz, componentType) {
    if (componentType) {
      checkClassType(componentType);
      componentType = parseClassType(componentType);

      if (!componentType.sub) {
        storage[componentType.main] = Clazz;
      } else if (componentType.sub !== IS_CONTAINER) {
        var container = makeContainer(componentType);
        container[componentType.sub] = Clazz;
      }
    }

    return Clazz;
  };

  entity.getClass = function (componentMainType, subType, throwWhenNotFound) {
    var Clazz = storage[componentMainType];

    if (Clazz && Clazz[IS_CONTAINER]) {
      Clazz = subType ? Clazz[subType] : null;
    }

    if (throwWhenNotFound && !Clazz) {
      throw new Error(!subType ? componentMainType + '.' + 'type should be specified.' : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.');
    }

    return Clazz;
  };

  entity.getClassesByMainType = function (componentType) {
    componentType = parseClassType(componentType);
    var result = [];
    var obj = storage[componentType.main];

    if (obj && obj[IS_CONTAINER]) {
      zrUtil.each(obj, function (o, type) {
        type !== IS_CONTAINER && result.push(o);
      });
    } else {
      result.push(obj);
    }

    return result;
  };

  entity.hasClass = function (componentType) {
    // Just consider componentType.main.
    componentType = parseClassType(componentType);
    return !!storage[componentType.main];
  };
  /**
   * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
   */


  entity.getAllClassMainTypes = function () {
    var types = [];
    zrUtil.each(storage, function (obj, type) {
      types.push(type);
    });
    return types;
  };
  /**
   * If a main type is container and has sub types
   * @param  {string}  mainType
   * @return {boolean}
   */


  entity.hasSubTypes = function (componentType) {
    componentType = parseClassType(componentType);
    var obj = storage[componentType.main];
    return obj && obj[IS_CONTAINER];
  };

  entity.parseClassType = parseClassType;

  function makeContainer(componentType) {
    var container = storage[componentType.main];

    if (!container || !container[IS_CONTAINER]) {
      container = storage[componentType.main] = {};
      container[IS_CONTAINER] = true;
    }

    return container;
  }

  if (options.registerWhenExtend) {
    var originalExtend = entity.extend;

    if (originalExtend) {
      entity.extend = function (proto) {
        var ExtendedClass = originalExtend.call(this, proto);
        return entity.registerClass(ExtendedClass, proto.type);
      };
    }
  }

  return entity;
}
/**
 * @param {string|Array.<string>} properties
 */


function setReadOnly(obj, properties) {// FIXME It seems broken in IE8 simulation of IE11
  // if (!zrUtil.isArray(properties)) {
  //     properties = properties != null ? [properties] : [];
  // }
  // zrUtil.each(properties, function (prop) {
  //     var value = obj[prop];
  //     Object.defineProperty
  //         && Object.defineProperty(obj, prop, {
  //             value: value, writable: false
  //         });
  //     zrUtil.isArray(obj[prop])
  //         && Object.freeze
  //         && Object.freeze(obj[prop]);
  // });
}

exports.parseClassType = parseClassType;
exports.enableClassExtend = enableClassExtend;
exports.enableClassCheck = enableClassCheck;
exports.enableClassManagement = enableClassManagement;
exports.setReadOnly = setReadOnly;

/***/ }),

/***/ "./node_modules/echarts/lib/util/component.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _clazz = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var parseClassType = _clazz.parseClassType;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var base = 0;
/**
 * @public
 * @param {string} type
 * @return {string}
 */

function getUID(type) {
  // Considering the case of crossing js context,
  // use Math.random to make id as unique as possible.
  return [type || '', base++, Math.random().toFixed(5)].join('_');
}
/**
 * @inner
 */


function enableSubTypeDefaulter(entity) {
  var subTypeDefaulters = {};

  entity.registerSubTypeDefaulter = function (componentType, defaulter) {
    componentType = parseClassType(componentType);
    subTypeDefaulters[componentType.main] = defaulter;
  };

  entity.determineSubType = function (componentType, option) {
    var type = option.type;

    if (!type) {
      var componentTypeMain = parseClassType(componentType).main;

      if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }

    return type;
  };

  return entity;
}
/**
 * Topological travel on Activity Network (Activity On Vertices).
 * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
 *
 * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
 *
 * If there is circle dependencey, Error will be thrown.
 *
 */


function enableTopologicalTravel(entity, dependencyGetter) {
  /**
   * @public
   * @param {Array.<string>} targetNameList Target Component type list.
   *                                           Can be ['aa', 'bb', 'aa.xx']
   * @param {Array.<string>} fullNameList By which we can build dependency graph.
   * @param {Function} callback Params: componentType, dependencies.
   * @param {Object} context Scope of callback.
   */
  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }

    var result = makeDepndencyGraph(fullNameList);
    var graph = result.graph;
    var stack = result.noEntryList;
    var targetNameSet = {};
    zrUtil.each(targetNameList, function (name) {
      targetNameSet[name] = true;
    });

    while (stack.length) {
      var currComponentType = stack.pop();
      var currVertex = graph[currComponentType];
      var isInTargetNameSet = !!targetNameSet[currComponentType];

      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }

      zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }

    zrUtil.each(targetNameSet, function () {
      throw new Error('Circle dependency may exists');
    });

    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;

      if (graph[succComponentType].entryCount === 0) {
        stack.push(succComponentType);
      }
    } // Consider this case: legend depends on series, and we call
    // chart.setOption({series: [...]}), where only series is in option.
    // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
    // not be called, but only sereis.mergeOption is called. Thus legend
    // have no chance to update its local record about series (like which
    // name of series is available in legend).


    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  /**
   * DepndencyGraph: {Object}
   * key: conponentType,
   * value: {
   *     successor: [conponentTypes...],
   *     originalDeps: [conponentTypes...],
   *     entryCount: {number}
   * }
   */


  function makeDepndencyGraph(fullNameList) {
    var graph = {};
    var noEntryList = [];
    zrUtil.each(fullNameList, function (name) {
      var thisItem = createDependencyGraphItem(graph, name);
      var originalDeps = thisItem.originalDeps = dependencyGetter(name);
      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;

      if (thisItem.entryCount === 0) {
        noEntryList.push(name);
      }

      zrUtil.each(availableDeps, function (dependentName) {
        if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }

        var thatItem = createDependencyGraphItem(graph, dependentName);

        if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name);
        }
      });
    });
    return {
      graph: graph,
      noEntryList: noEntryList
    };
  }

  function createDependencyGraphItem(graph, name) {
    if (!graph[name]) {
      graph[name] = {
        predecessor: [],
        successor: []
      };
    }

    return graph[name];
  }

  function getAvailableDependencies(originalDeps, fullNameList) {
    var availableDeps = [];
    zrUtil.each(originalDeps, function (dep) {
      zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}

exports.getUID = getUID;
exports.enableSubTypeDefaulter = enableSubTypeDefaulter;
exports.enableTopologicalTravel = enableTopologicalTravel;

/***/ }),

/***/ "./node_modules/echarts/lib/util/format.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var numberUtil = __webpack_require__("./node_modules/echarts/lib/util/number.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * 每三位默认加,格式化
 * @param {string|number} x
 * @return {string}
 */
function addCommas(x) {
  if (isNaN(x)) {
    return '-';
  }

  x = (x + '').split('.');
  return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');
}
/**
 * @param {string} str
 * @param {boolean} [upperCaseFirst=false]
 * @return {string} str
 */


function toCamelCase(str, upperCaseFirst) {
  str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
    return group1.toUpperCase();
  });

  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }

  return str;
}

var normalizeCssArray = zrUtil.normalizeCssArray;
var replaceReg = /([&<>"'])/g;
var replaceMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  '\'': '&#39;'
};

function encodeHTML(source) {
  return source == null ? '' : (source + '').replace(replaceReg, function (str, c) {
    return replaceMap[c];
  });
}

var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

var wrapVar = function (varName, seriesIdx) {
  return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
};
/**
 * Template formatter
 * @param {string} tpl
 * @param {Array.<Object>|Object} paramsList
 * @param {boolean} [encode=false]
 * @return {string}
 */


function formatTpl(tpl, paramsList, encode) {
  if (!zrUtil.isArray(paramsList)) {
    paramsList = [paramsList];
  }

  var seriesLen = paramsList.length;

  if (!seriesLen) {
    return '';
  }

  var $vars = paramsList[0].$vars || [];

  for (var i = 0; i < $vars.length; i++) {
    var alias = TPL_VAR_ALIAS[i];
    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
  }

  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
    for (var k = 0; k < $vars.length; k++) {
      var val = paramsList[seriesIdx][$vars[k]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
    }
  }

  return tpl;
}
/**
 * simple Template formatter
 *
 * @param {string} tpl
 * @param {Object} param
 * @param {boolean} [encode=false]
 * @return {string}
 */


function formatTplSimple(tpl, param, encode) {
  zrUtil.each(param, function (value, key) {
    tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);
  });
  return tpl;
}
/**
 * @param {Object|string} [opt] If string, means color.
 * @param {string} [opt.color]
 * @param {string} [opt.extraCssText]
 * @param {string} [opt.type='item'] 'item' or 'subItem'
 * @return {string}
 */


function getTooltipMarker(opt, extraCssText) {
  opt = zrUtil.isString(opt) ? {
    color: opt,
    extraCssText: extraCssText
  } : opt || {};
  var color = opt.color;
  var type = opt.type;
  var extraCssText = opt.extraCssText;

  if (!color) {
    return '';
  }

  return type === 'subItem' ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;' + 'border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>' : '<span style="display:inline-block;margin-right:5px;' + 'border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>';
}

function pad(str, len) {
  str += '';
  return '0000'.substr(0, len - str.length) + str;
}
/**
 * ISO Date format
 * @param {string} tpl
 * @param {number} value
 * @param {boolean} [isUTC=false] Default in local time.
 *           see `module:echarts/scale/Time`
 *           and `module:echarts/util/number#parseDate`.
 * @inner
 */


function formatTime(tpl, value, isUTC) {
  if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
    tpl = 'MM-dd\nyyyy';
  }

  var date = numberUtil.parseDate(value);
  var utc = isUTC ? 'UTC' : '';
  var y = date['get' + utc + 'FullYear']();
  var M = date['get' + utc + 'Month']() + 1;
  var d = date['get' + utc + 'Date']();
  var h = date['get' + utc + 'Hours']();
  var m = date['get' + utc + 'Minutes']();
  var s = date['get' + utc + 'Seconds']();
  var S = date['get' + utc + 'Milliseconds']();
  tpl = tpl.replace('MM', pad(M, 2)).replace('M', M).replace('yyyy', y).replace('yy', y % 100).replace('dd', pad(d, 2)).replace('d', d).replace('hh', pad(h, 2)).replace('h', h).replace('mm', pad(m, 2)).replace('m', m).replace('ss', pad(s, 2)).replace('s', s).replace('SSS', pad(S, 3));
  return tpl;
}
/**
 * Capital first
 * @param {string} str
 * @return {string}
 */


function capitalFirst(str) {
  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}

var truncateText = textContain.truncateText;
var getTextRect = textContain.getBoundingRect;
exports.addCommas = addCommas;
exports.toCamelCase = toCamelCase;
exports.normalizeCssArray = normalizeCssArray;
exports.encodeHTML = encodeHTML;
exports.formatTpl = formatTpl;
exports.formatTplSimple = formatTplSimple;
exports.getTooltipMarker = getTooltipMarker;
exports.formatTime = formatTime;
exports.capitalFirst = capitalFirst;
exports.truncateText = truncateText;
exports.getTextRect = getTextRect;

/***/ }),

/***/ "./node_modules/echarts/lib/util/graphic.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var pathTool = __webpack_require__("./node_modules/zrender/lib/tool/path.js");

var colorTool = __webpack_require__("./node_modules/zrender/lib/tool/color.js");

var matrix = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

var vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var Transformable = __webpack_require__("./node_modules/zrender/lib/mixin/Transformable.js");

var ZImage = __webpack_require__("./node_modules/zrender/lib/graphic/Image.js");

exports.Image = ZImage;

var Group = __webpack_require__("./node_modules/zrender/lib/container/Group.js");

exports.Group = Group;

var Text = __webpack_require__("./node_modules/zrender/lib/graphic/Text.js");

exports.Text = Text;

var Circle = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Circle.js");

exports.Circle = Circle;

var Sector = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Sector.js");

exports.Sector = Sector;

var Ring = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Ring.js");

exports.Ring = Ring;

var Polygon = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Polygon.js");

exports.Polygon = Polygon;

var Polyline = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Polyline.js");

exports.Polyline = Polyline;

var Rect = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Rect.js");

exports.Rect = Rect;

var Line = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Line.js");

exports.Line = Line;

var BezierCurve = __webpack_require__("./node_modules/zrender/lib/graphic/shape/BezierCurve.js");

exports.BezierCurve = BezierCurve;

var Arc = __webpack_require__("./node_modules/zrender/lib/graphic/shape/Arc.js");

exports.Arc = Arc;

var CompoundPath = __webpack_require__("./node_modules/zrender/lib/graphic/CompoundPath.js");

exports.CompoundPath = CompoundPath;

var LinearGradient = __webpack_require__("./node_modules/zrender/lib/graphic/LinearGradient.js");

exports.LinearGradient = LinearGradient;

var RadialGradient = __webpack_require__("./node_modules/zrender/lib/graphic/RadialGradient.js");

exports.RadialGradient = RadialGradient;

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

exports.BoundingRect = BoundingRect;

var IncrementalDisplayable = __webpack_require__("./node_modules/zrender/lib/graphic/IncrementalDisplayable.js");

exports.IncrementalDisplayable = IncrementalDisplayable;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var round = Math.round;
var mathMax = Math.max;
var mathMin = Math.min;
var EMPTY_OBJ = {};
/**
 * Extend shape with parameters
 */

function extendShape(opts) {
  return Path.extend(opts);
}
/**
 * Extend path
 */


function extendPath(pathData, opts) {
  return pathTool.extendFromString(pathData, opts);
}
/**
 * Create a path element from path data string
 * @param {string} pathData
 * @param {Object} opts
 * @param {module:zrender/core/BoundingRect} rect
 * @param {string} [layout=cover] 'center' or 'cover'
 */


function makePath(pathData, opts, rect, layout) {
  var path = pathTool.createFromString(pathData, opts);
  var boundingRect = path.getBoundingRect();

  if (rect) {
    if (layout === 'center') {
      rect = centerGraphic(rect, boundingRect);
    }

    resizePath(path, rect);
  }

  return path;
}
/**
 * Create a image element from image url
 * @param {string} imageUrl image url
 * @param {Object} opts options
 * @param {module:zrender/core/BoundingRect} rect constrain rect
 * @param {string} [layout=cover] 'center' or 'cover'
 */


function makeImage(imageUrl, rect, layout) {
  var path = new ZImage({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload: function (img) {
      if (layout === 'center') {
        var boundingRect = {
          width: img.width,
          height: img.height
        };
        path.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return path;
}
/**
 * Get position of centered element in bounding box.
 *
 * @param  {Object} rect         element local bounding box
 * @param  {Object} boundingRect constraint bounding box
 * @return {Object} element position containing x, y, width, and height
 */


function centerGraphic(rect, boundingRect) {
  // Set rect to center, keep width / height ratio.
  var aspect = boundingRect.width / boundingRect.height;
  var width = rect.height * aspect;
  var height;

  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }

  var cx = rect.x + rect.width / 2;
  var cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width: width,
    height: height
  };
}

var mergePath = pathTool.mergePath;
/**
 * Resize a path to fit the rect
 * @param {module:zrender/graphic/Path} path
 * @param {Object} rect
 */

function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }

  var pathRect = path.getBoundingRect();
  var m = pathRect.calculateTransform(rect);
  path.applyTransform(m);
}
/**
 * Sub pixel optimize line for canvas
 *
 * @param {Object} param
 * @param {Object} [param.shape]
 * @param {number} [param.shape.x1]
 * @param {number} [param.shape.y1]
 * @param {number} [param.shape.x2]
 * @param {number} [param.shape.y2]
 * @param {Object} [param.style]
 * @param {number} [param.style.lineWidth]
 * @return {Object} Modified param
 */


function subPixelOptimizeLine(param) {
  var shape = param.shape;
  var lineWidth = param.style.lineWidth;

  if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
    shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
  }

  if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
    shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
  }

  return param;
}
/**
 * Sub pixel optimize rect for canvas
 *
 * @param {Object} param
 * @param {Object} [param.shape]
 * @param {number} [param.shape.x]
 * @param {number} [param.shape.y]
 * @param {number} [param.shape.width]
 * @param {number} [param.shape.height]
 * @param {Object} [param.style]
 * @param {number} [param.style.lineWidth]
 * @return {Object} Modified param
 */


function subPixelOptimizeRect(param) {
  var shape = param.shape;
  var lineWidth = param.style.lineWidth;
  var originX = shape.x;
  var originY = shape.y;
  var originWidth = shape.width;
  var originHeight = shape.height;
  shape.x = subPixelOptimize(shape.x, lineWidth, true);
  shape.y = subPixelOptimize(shape.y, lineWidth, true);
  shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);
  shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);
  return param;
}
/**
 * Sub pixel optimize for canvas
 *
 * @param {number} position Coordinate, such as x, y
 * @param {number} lineWidth Should be nonnegative integer.
 * @param {boolean=} positiveOrNegative Default false (negative).
 * @return {number} Optimized position.
 */


function subPixelOptimize(position, lineWidth, positiveOrNegative) {
  // Assure that (position + lineWidth / 2) is near integer edge,
  // otherwise line will be fuzzy in canvas.
  var doubledPosition = round(position * 2);
  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}

function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke != 'none';
}

function liftColor(color) {
  return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;
}
/**
 * @private
 */


function cacheElementStl(el) {
  if (el.__hoverStlDirty) {
    var stroke = el.style.stroke;
    var fill = el.style.fill; // Create hoverStyle on mouseover

    var hoverStyle = el.__hoverStl;
    hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);
    hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);
    var normalStyle = {};

    for (var name in hoverStyle) {
      // See comment in `doSingleEnterHover`.
      if (hoverStyle[name] != null) {
        normalStyle[name] = el.style[name];
      }
    }

    el.__normalStl = normalStyle;
    el.__hoverStlDirty = false;
  }
}
/**
 * @private
 */


function doSingleEnterHover(el) {
  if (el.__isHover) {
    return;
  }

  cacheElementStl(el);

  if (el.useHoverLayer) {
    el.__zr && el.__zr.addHover(el, el.__hoverStl);
  } else {
    var style = el.style;
    var insideRollbackOpt = style.insideRollbackOpt; // Consider case: only `position: 'top'` is set on emphasis, then text
    // color should be returned to `autoColor`, rather than remain '#fff'.
    // So we should rollback then apply again after style merging.

    insideRollbackOpt && rollbackInsideStyle(style); // styles can be:
    // {
    //    label: {
    //        show: false,
    //        position: 'outside',
    //        fontSize: 18
    //    },
    //    emphasis: {
    //        label: {
    //            show: true
    //        }
    //    }
    // },
    // where properties of `emphasis` may not appear in `normal`. We previously use
    // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.
    // But consider rich text and setOption in merge mode, it is impossible to cover
    // all properties in merge. So we use merge mode when setting style here, where
    // only properties that is not `null/undefined` can be set. The disadventage:
    // null/undefined can not be used to remove style any more in `emphasis`.

    style.extendFrom(el.__hoverStl); // Do not save `insideRollback`.

    if (insideRollbackOpt) {
      applyInsideStyle(style, style.insideOriginalTextPosition, insideRollbackOpt); // textFill may be rollbacked to null.

      if (style.textFill == null) {
        style.textFill = insideRollbackOpt.autoColor;
      }
    }

    el.dirty(false);
    el.z2 += 1;
  }

  el.__isHover = true;
}
/**
 * @inner
 */


function doSingleLeaveHover(el) {
  if (!el.__isHover) {
    return;
  }

  var normalStl = el.__normalStl;

  if (el.useHoverLayer) {
    el.__zr && el.__zr.removeHover(el);
  } else {
    // Consider null/undefined value, should use
    // `setStyle` but not `extendFrom(stl, true)`.
    normalStl && el.setStyle(normalStl);
    el.z2 -= 1;
  }

  el.__isHover = false;
}
/**
 * @inner
 */


function doEnterHover(el) {
  el.type === 'group' ? el.traverse(function (child) {
    if (child.type !== 'group') {
      doSingleEnterHover(child);
    }
  }) : doSingleEnterHover(el);
}

function doLeaveHover(el) {
  el.type === 'group' ? el.traverse(function (child) {
    if (child.type !== 'group') {
      doSingleLeaveHover(child);
    }
  }) : doSingleLeaveHover(el);
}
/**
 * @inner
 */


function setElementHoverStl(el, hoverStl) {
  // If element has sepcified hoverStyle, then use it instead of given hoverStyle
  // Often used when item group has a label element and it's hoverStyle is different
  el.__hoverStl = el.hoverStyle || hoverStl || {};
  el.__hoverStlDirty = true;

  if (el.__isHover) {
    cacheElementStl(el);
  }
}
/**
 * @inner
 */


function onElementMouseOver(e) {
  if (this.__hoverSilentOnTouch && e.zrByTouch) {
    return;
  } // Only if element is not in emphasis status


  !this.__isEmphasis && doEnterHover(this);
}
/**
 * @inner
 */


function onElementMouseOut(e) {
  if (this.__hoverSilentOnTouch && e.zrByTouch) {
    return;
  } // Only if element is not in emphasis status


  !this.__isEmphasis && doLeaveHover(this);
}
/**
 * @inner
 */


function enterEmphasis() {
  this.__isEmphasis = true;
  doEnterHover(this);
}
/**
 * @inner
 */


function leaveEmphasis() {
  this.__isEmphasis = false;
  doLeaveHover(this);
}
/**
 * Set hover style of element.
 * This method can be called repeatly without side-effects.
 * @param {module:zrender/Element} el
 * @param {Object} [hoverStyle]
 * @param {Object} [opt]
 * @param {boolean} [opt.hoverSilentOnTouch=false]
 *        In touch device, mouseover event will be trigger on touchstart event
 *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
 *        conviniently use hoverStyle when tap on touch screen without additional
 *        code for compatibility.
 *        But if the chart/component has select feature, which usually also use
 *        hoverStyle, there might be conflict between 'select-highlight' and
 *        'hover-highlight' especially when roam is enabled (see geo for example).
 *        In this case, hoverSilentOnTouch should be used to disable hover-highlight
 *        on touch device.
 */


function setHoverStyle(el, hoverStyle, opt) {
  el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;
  el.type === 'group' ? el.traverse(function (child) {
    if (child.type !== 'group') {
      setElementHoverStl(child, hoverStyle);
    }
  }) : setElementHoverStl(el, hoverStyle); // Duplicated function will be auto-ignored, see Eventful.js.

  el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut); // Emphasis, normal can be triggered manually

  el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);
}
/**
 * @param {Object|module:zrender/graphic/Style} normalStyle
 * @param {Object} emphasisStyle
 * @param {module:echarts/model/Model} normalModel
 * @param {module:echarts/model/Model} emphasisModel
 * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.
 * @param {string|Function} [opt.defaultText]
 * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by
 *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by
 *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by
 *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {Object} [normalSpecified]
 * @param {Object} [emphasisSpecified]
 */


function setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {
  opt = opt || EMPTY_OBJ;
  var labelFetcher = opt.labelFetcher;
  var labelDataIndex = opt.labelDataIndex;
  var labelDimIndex = opt.labelDimIndex; // This scenario, `label.normal.show = true; label.emphasis.show = false`,
  // is not supported util someone requests.

  var showNormal = normalModel.getShallow('show');
  var showEmphasis = emphasisModel.getShallow('show'); // Consider performance, only fetch label when necessary.
  // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,
  // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.

  var baseText;

  if (showNormal || showEmphasis) {
    if (labelFetcher) {
      baseText = labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex);
    }

    if (baseText == null) {
      baseText = zrUtil.isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt) : opt.defaultText;
    }
  }

  var normalStyleText = showNormal ? baseText : null;
  var emphasisStyleText = showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex) : null, baseText) : null; // Optimize: If style.text is null, text will not be drawn.

  if (normalStyleText != null || emphasisStyleText != null) {
    // Always set `textStyle` even if `normalStyle.text` is null, because default
    // values have to be set on `normalStyle`.
    // If we set default values on `emphasisStyle`, consider case:
    // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`
    // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`
    // Then the 'red' will not work on emphasis.
    setTextStyle(normalStyle, normalModel, normalSpecified, opt);
    setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);
  }

  normalStyle.text = normalStyleText;
  emphasisStyle.text = emphasisStyleText;
}
/**
 * Set basic textStyle properties.
 * @param {Object|module:zrender/graphic/Style} textStyle
 * @param {module:echarts/model/Model} model
 * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.
 * @param {Object} [opt] See `opt` of `setTextStyleCommon`.
 * @param {boolean} [isEmphasis]
 */


function setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {
  setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);
  specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle);
  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);
  return textStyle;
}
/**
 * Set text option in the style.
 * @deprecated
 * @param {Object} textStyle
 * @param {module:echarts/model/Model} labelModel
 * @param {string|boolean} defaultColor Default text color.
 *        If set as false, it will be processed as a emphasis style.
 */


function setText(textStyle, labelModel, defaultColor) {
  var opt = {
    isRectText: true
  };
  var isEmphasis;

  if (defaultColor === false) {
    isEmphasis = true;
  } else {
    // Support setting color as 'auto' to get visual color.
    opt.autoColor = defaultColor;
  }

  setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);
  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);
}
/**
 * {
 *      disableBox: boolean, Whether diable drawing box of block (outer most).
 *      isRectText: boolean,
 *      autoColor: string, specify a color when color is 'auto',
 *              for textFill, textStroke, textBackgroundColor, and textBorderColor.
 *              If autoColor specified, it is used as default textFill.
 *      useInsideStyle:
 *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)
 *                  if `textFill` is not specified.
 *              `false`: Do not use inside style.
 *              `null/undefined`: use inside style if `isRectText` is true and
 *                  `textFill` is not specified and textPosition contains `'inside'`.
 *      forceRich: boolean
 * }
 */


function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {
  // Consider there will be abnormal when merge hover style to normal style if given default value.
  opt = opt || EMPTY_OBJ;

  if (opt.isRectText) {
    var textPosition = textStyleModel.getShallow('position') || (isEmphasis ? null : 'inside'); // 'outside' is not a valid zr textPostion value, but used
    // in bar series, and magric type should be considered.

    textPosition === 'outside' && (textPosition = 'top');
    textStyle.textPosition = textPosition;
    textStyle.textOffset = textStyleModel.getShallow('offset');
    var labelRotate = textStyleModel.getShallow('rotate');
    labelRotate != null && (labelRotate *= Math.PI / 180);
    textStyle.textRotation = labelRotate;
    textStyle.textDistance = zrUtil.retrieve2(textStyleModel.getShallow('distance'), isEmphasis ? null : 5);
  }

  var ecModel = textStyleModel.ecModel;
  var globalTextStyle = ecModel && ecModel.option.textStyle; // Consider case:
  // {
  //     data: [{
  //         value: 12,
  //         label: {
  //             rich: {
  //                 // no 'a' here but using parent 'a'.
  //             }
  //         }
  //     }],
  //     rich: {
  //         a: { ... }
  //     }
  // }

  var richItemNames = getRichItemNames(textStyleModel);
  var richResult;

  if (richItemNames) {
    richResult = {};

    for (var name in richItemNames) {
      if (richItemNames.hasOwnProperty(name)) {
        // Cascade is supported in rich.
        var richTextStyle = textStyleModel.getModel(['rich', name]); // In rich, never `disableBox`.

        setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);
      }
    }
  }

  textStyle.rich = richResult;
  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);

  if (opt.forceRich && !opt.textStyle) {
    opt.textStyle = {};
  }

  return textStyle;
} // Consider case:
// {
//     data: [{
//         value: 12,
//         label: {
//             rich: {
//                 // no 'a' here but using parent 'a'.
//             }
//         }
//     }],
//     rich: {
//         a: { ... }
//     }
// }


function getRichItemNames(textStyleModel) {
  // Use object to remove duplicated names.
  var richItemNameMap;

  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    var rich = (textStyleModel.option || EMPTY_OBJ).rich;

    if (rich) {
      richItemNameMap = richItemNameMap || {};

      for (var name in rich) {
        if (rich.hasOwnProperty(name)) {
          richItemNameMap[name] = 1;
        }
      }
    }

    textStyleModel = textStyleModel.parentModel;
  }

  return richItemNameMap;
}

function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {
  // In merge mode, default value should not be given.
  globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;
  textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt) || globalTextStyle.color;
  textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt) || globalTextStyle.textBorderColor;
  textStyle.textStrokeWidth = zrUtil.retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);

  if (!isEmphasis) {
    if (isBlock) {
      // Always set `insideRollback`, for clearing previous.
      var originalTextPosition = textStyle.textPosition;
      textStyle.insideRollback = applyInsideStyle(textStyle, originalTextPosition, opt); // Save original textPosition, because style.textPosition will be repalced by
      // real location (like [10, 30]) in zrender.

      textStyle.insideOriginalTextPosition = originalTextPosition;
      textStyle.insideRollbackOpt = opt;
    } // Set default finally.


    if (textStyle.textFill == null) {
      textStyle.textFill = opt.autoColor;
    }
  } // Do not use `getFont` here, because merge should be supported, where
  // part of these properties may be changed in emphasis style, and the
  // others should remain their original value got from normal style.


  textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;
  textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;
  textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;
  textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;
  textStyle.textAlign = textStyleModel.getShallow('align');
  textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign') || textStyleModel.getShallow('baseline');
  textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');
  textStyle.textWidth = textStyleModel.getShallow('width');
  textStyle.textHeight = textStyleModel.getShallow('height');
  textStyle.textTag = textStyleModel.getShallow('tag');

  if (!isBlock || !opt.disableBox) {
    textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);
    textStyle.textPadding = textStyleModel.getShallow('padding');
    textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);
    textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');
    textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');
    textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');
    textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');
    textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');
    textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');
  }

  textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor') || globalTextStyle.textShadowColor;
  textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur') || globalTextStyle.textShadowBlur;
  textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX') || globalTextStyle.textShadowOffsetX;
  textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY') || globalTextStyle.textShadowOffsetY;
}

function getAutoColor(color, opt) {
  return color !== 'auto' ? color : opt && opt.autoColor ? opt.autoColor : null;
}

function applyInsideStyle(textStyle, textPosition, opt) {
  var useInsideStyle = opt.useInsideStyle;
  var insideRollback;

  if (textStyle.textFill == null && useInsideStyle !== false && (useInsideStyle === true || opt.isRectText && textPosition // textPosition can be [10, 30]
  && typeof textPosition === 'string' && textPosition.indexOf('inside') >= 0)) {
    insideRollback = {
      textFill: null,
      textStroke: textStyle.textStroke,
      textStrokeWidth: textStyle.textStrokeWidth
    };
    textStyle.textFill = '#fff'; // Consider text with #fff overflow its container.

    if (textStyle.textStroke == null) {
      textStyle.textStroke = opt.autoColor;
      textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);
    }
  }

  return insideRollback;
}

function rollbackInsideStyle(style) {
  var insideRollback = style.insideRollback;

  if (insideRollback) {
    style.textFill = insideRollback.textFill;
    style.textStroke = insideRollback.textStroke;
    style.textStrokeWidth = insideRollback.textStrokeWidth;
  }
}

function getFont(opt, ecModel) {
  // ecModel or default text style model.
  var gTextStyleModel = ecModel || ecModel.getModel('textStyle');
  return zrUtil.trim([// FIXME in node-canvas fontWeight is before fontStyle
  opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' '));
}

function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
  if (typeof dataIndex === 'function') {
    cb = dataIndex;
    dataIndex = null;
  } // Do not check 'animation' property directly here. Consider this case:
  // animation model is an `itemModel`, whose does not have `isAnimationEnabled`
  // but its parent model (`seriesModel`) does.


  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();

  if (animationEnabled) {
    var postfix = isUpdate ? 'Update' : '';
    var duration = animatableModel.getShallow('animationDuration' + postfix);
    var animationEasing = animatableModel.getShallow('animationEasing' + postfix);
    var animationDelay = animatableModel.getShallow('animationDelay' + postfix);

    if (typeof animationDelay === 'function') {
      animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
    }

    if (typeof duration === 'function') {
      duration = duration(dataIndex);
    }

    duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());
  } else {
    el.stopAnimation();
    el.attr(props);
    cb && cb();
  }
}
/**
 * Update graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So if do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 *
 * @param {module:zrender/Element} el
 * @param {Object} props
 * @param {module:echarts/model/Model} [animatableModel]
 * @param {number} [dataIndex]
 * @param {Function} [cb]
 * @example
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
 *     // Or
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, function () { console.log('Animation done!'); });
 */


function updateProps(el, props, animatableModel, dataIndex, cb) {
  animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
}
/**
 * Init graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So if do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 *
 * @param {module:zrender/Element} el
 * @param {Object} props
 * @param {module:echarts/model/Model} [animatableModel]
 * @param {number} [dataIndex]
 * @param {Function} cb
 */


function initProps(el, props, animatableModel, dataIndex, cb) {
  animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
}
/**
 * Get transform matrix of target (param target),
 * in coordinate of its ancestor (param ancestor)
 *
 * @param {module:zrender/mixin/Transformable} target
 * @param {module:zrender/mixin/Transformable} [ancestor]
 */


function getTransform(target, ancestor) {
  var mat = matrix.identity([]);

  while (target && target !== ancestor) {
    matrix.mul(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }

  return mat;
}
/**
 * Apply transform to an vertex.
 * @param {Array.<number>} target [x, y]
 * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:
 *      + Transform matrix: like [1, 0, 0, 1, 0, 0]
 *      + {position, rotation, scale}, the same as `zrender/Transformable`.
 * @param {boolean=} invert Whether use invert matrix.
 * @return {Array.<number>} [x, y]
 */


function applyTransform(target, transform, invert) {
  if (transform && !zrUtil.isArrayLike(transform)) {
    transform = Transformable.getLocalTransform(transform);
  }

  if (invert) {
    transform = matrix.invert([], transform);
  }

  return vector.applyTransform([], target, transform);
}
/**
 * @param {string} direction 'left' 'right' 'top' 'bottom'
 * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
 * @param {boolean=} invert Whether use invert matrix.
 * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
 */


function transformDirection(direction, transform, invert) {
  // Pick a base, ensure that transform result will not be (0, 0).
  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];
  vertex = applyTransform(vertex, transform, invert);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';
}
/**
 * Apply group transition animation from g1 to g2.
 * If no animatableModel, no animation.
 */


function groupTransition(g1, g2, animatableModel, cb) {
  if (!g1 || !g2) {
    return;
  }

  function getElMap(g) {
    var elMap = {};
    g.traverse(function (el) {
      if (!el.isGroup && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }

  function getAnimatableProps(el) {
    var obj = {
      position: vector.clone(el.position),
      rotation: el.rotation
    };

    if (el.shape) {
      obj.shape = zrUtil.extend({}, el.shape);
    }

    return obj;
  }

  var elMap1 = getElMap(g1);
  g2.traverse(function (el) {
    if (!el.isGroup && el.anid) {
      var oldEl = elMap1[el.anid];

      if (oldEl) {
        var newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps(el, newProp, animatableModel, el.dataIndex);
      } // else {
      //     if (el.previousProps) {
      //         graphic.updateProps
      //     }
      // }

    }
  });
}
/**
 * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]
 * @param {Object} rect {x, y, width, height}
 * @return {Array.<Array.<number>>} A new clipped points.
 */


function clipPointsByRect(points, rect) {
  return zrUtil.map(points, function (point) {
    var x = point[0];
    x = mathMax(x, rect.x);
    x = mathMin(x, rect.x + rect.width);
    var y = point[1];
    y = mathMax(y, rect.y);
    y = mathMin(y, rect.y + rect.height);
    return [x, y];
  });
}
/**
 * @param {Object} targetRect {x, y, width, height}
 * @param {Object} rect {x, y, width, height}
 * @return {Object} A new clipped rect. If rect size are negative, return undefined.
 */


function clipRectByRect(targetRect, rect) {
  var x = mathMax(targetRect.x, rect.x);
  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);
  var y = mathMax(targetRect.y, rect.y);
  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);

  if (x2 >= x && y2 >= y) {
    return {
      x: x,
      y: y,
      width: x2 - x,
      height: y2 - y
    };
  }
}
/**
 * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.
 * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.
 * @param {Object} [rect] {x, y, width, height}
 * @return {module:zrender/Element} Icon path or image element.
 */


function createIcon(iconStr, opt, rect) {
  opt = zrUtil.extend({
    rectHover: true
  }, opt);
  var style = opt.style = {
    strokeNoScale: true
  };
  rect = rect || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  };

  if (iconStr) {
    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), zrUtil.defaults(style, rect), new ZImage(opt)) : makePath(iconStr.replace('path://', ''), opt, rect, 'center');
  }
}

exports.extendShape = extendShape;
exports.extendPath = extendPath;
exports.makePath = makePath;
exports.makeImage = makeImage;
exports.mergePath = mergePath;
exports.resizePath = resizePath;
exports.subPixelOptimizeLine = subPixelOptimizeLine;
exports.subPixelOptimizeRect = subPixelOptimizeRect;
exports.subPixelOptimize = subPixelOptimize;
exports.setHoverStyle = setHoverStyle;
exports.setLabelStyle = setLabelStyle;
exports.setTextStyle = setTextStyle;
exports.setText = setText;
exports.getFont = getFont;
exports.updateProps = updateProps;
exports.initProps = initProps;
exports.getTransform = getTransform;
exports.applyTransform = applyTransform;
exports.transformDirection = transformDirection;
exports.groupTransition = groupTransition;
exports.clipPointsByRect = clipPointsByRect;
exports.clipRectByRect = clipRectByRect;
exports.createIcon = createIcon;

/***/ }),

/***/ "./node_modules/echarts/lib/util/layout.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var _number = __webpack_require__("./node_modules/echarts/lib/util/number.js");

var parsePercent = _number.parsePercent;

var formatUtil = __webpack_require__("./node_modules/echarts/lib/util/format.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Layout helpers for each component positioning
var each = zrUtil.each;
/**
 * @public
 */

var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];
/**
 * @public
 */

var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];

function boxLayout(orient, group, gap, maxWidth, maxHeight) {
  var x = 0;
  var y = 0;

  if (maxWidth == null) {
    maxWidth = Infinity;
  }

  if (maxHeight == null) {
    maxHeight = Infinity;
  }

  var currentLineMaxSize = 0;
  group.eachChild(function (child, idx) {
    var position = child.position;
    var rect = child.getBoundingRect();
    var nextChild = group.childAt(idx + 1);
    var nextChildRect = nextChild && nextChild.getBoundingRect();
    var nextX;
    var nextY;

    if (orient === 'horizontal') {
      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group
      // FIXME compare before adding gap?

      if (nextX > maxWidth || child.newline) {
        x = 0;
        nextX = moveX;
        y += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        // FIXME: consider rect.y is not `0`?
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group

      if (nextY > maxHeight || child.newline) {
        x += currentLineMaxSize + gap;
        y = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }

    if (child.newline) {
      return;
    }

    position[0] = x;
    position[1] = y;
    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;
  });
}
/**
 * VBox or HBox layouting
 * @param {string} orient
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */


var box = boxLayout;
/**
 * VBox layouting
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */

var vbox = zrUtil.curry(boxLayout, 'vertical');
/**
 * HBox layouting
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */

var hbox = zrUtil.curry(boxLayout, 'horizontal');
/**
 * If x or x2 is not specified or 'center' 'left' 'right',
 * the width would be as long as possible.
 * If y or y2 is not specified or 'middle' 'top' 'bottom',
 * the height would be as long as possible.
 *
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.x]
 * @param {number|string} [positionInfo.y]
 * @param {number|string} [positionInfo.x2]
 * @param {number|string} [positionInfo.y2]
 * @param {Object} containerRect {width, height}
 * @param {string|number} margin
 * @return {Object} {width, height}
 */

function getAvailableSize(positionInfo, containerRect, margin) {
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var x = parsePercent(positionInfo.x, containerWidth);
  var y = parsePercent(positionInfo.y, containerHeight);
  var x2 = parsePercent(positionInfo.x2, containerWidth);
  var y2 = parsePercent(positionInfo.y2, containerHeight);
  (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
  (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
  (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
  (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
  margin = formatUtil.normalizeCssArray(margin || 0);
  return {
    width: Math.max(x2 - x - margin[1] - margin[3], 0),
    height: Math.max(y2 - y - margin[0] - margin[2], 0)
  };
}
/**
 * Parse position info.
 *
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.left]
 * @param {number|string} [positionInfo.top]
 * @param {number|string} [positionInfo.right]
 * @param {number|string} [positionInfo.bottom]
 * @param {number|string} [positionInfo.width]
 * @param {number|string} [positionInfo.height]
 * @param {number|string} [positionInfo.aspect] Aspect is width / height
 * @param {Object} containerRect
 * @param {string|number} [margin]
 *
 * @return {module:zrender/core/BoundingRect}
 */


function getLayoutRect(positionInfo, containerRect, margin) {
  margin = formatUtil.normalizeCssArray(margin || 0);
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var left = parsePercent(positionInfo.left, containerWidth);
  var top = parsePercent(positionInfo.top, containerHeight);
  var right = parsePercent(positionInfo.right, containerWidth);
  var bottom = parsePercent(positionInfo.bottom, containerHeight);
  var width = parsePercent(positionInfo.width, containerWidth);
  var height = parsePercent(positionInfo.height, containerHeight);
  var verticalMargin = margin[2] + margin[0];
  var horizontalMargin = margin[1] + margin[3];
  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right

  if (isNaN(width)) {
    width = containerWidth - right - horizontalMargin - left;
  }

  if (isNaN(height)) {
    height = containerHeight - bottom - verticalMargin - top;
  }

  if (aspect != null) {
    // If width and height are not given
    // 1. Graph should not exceeds the container
    // 2. Aspect must be keeped
    // 3. Graph should take the space as more as possible
    // FIXME
    // Margin is not considered, because there is no case that both
    // using margin and aspect so far.
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    } // Calculate width or height with given aspect


    if (isNaN(width)) {
      width = aspect * height;
    }

    if (isNaN(height)) {
      height = width / aspect;
    }
  } // If left is not specified, calculate left from right and width


  if (isNaN(left)) {
    left = containerWidth - right - width - horizontalMargin;
  }

  if (isNaN(top)) {
    top = containerHeight - bottom - height - verticalMargin;
  } // Align left and top


  switch (positionInfo.left || positionInfo.right) {
    case 'center':
      left = containerWidth / 2 - width / 2 - margin[3];
      break;

    case 'right':
      left = containerWidth - width - horizontalMargin;
      break;
  }

  switch (positionInfo.top || positionInfo.bottom) {
    case 'middle':
    case 'center':
      top = containerHeight / 2 - height / 2 - margin[0];
      break;

    case 'bottom':
      top = containerHeight - height - verticalMargin;
      break;
  } // If something is wrong and left, top, width, height are calculated as NaN


  left = left || 0;
  top = top || 0;

  if (isNaN(width)) {
    // Width may be NaN if only one value is given except width
    width = containerWidth - horizontalMargin - left - (right || 0);
  }

  if (isNaN(height)) {
    // Height may be NaN if only one value is given except height
    height = containerHeight - verticalMargin - top - (bottom || 0);
  }

  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
/**
 * Position a zr element in viewport
 *  Group position is specified by either
 *  {left, top}, {right, bottom}
 *  If all properties exists, right and bottom will be igonred.
 *
 * Logic:
 *     1. Scale (against origin point in parent coord)
 *     2. Rotate (against origin point in parent coord)
 *     3. Traslate (with el.position by this method)
 * So this method only fixes the last step 'Traslate', which does not affect
 * scaling and rotating.
 *
 * If be called repeatly with the same input el, the same result will be gotten.
 *
 * @param {module:zrender/Element} el Should have `getBoundingRect` method.
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.left]
 * @param {number|string} [positionInfo.top]
 * @param {number|string} [positionInfo.right]
 * @param {number|string} [positionInfo.bottom]
 * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'
 * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'
 * @param {Object} containerRect
 * @param {string|number} margin
 * @param {Object} [opt]
 * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.
 * @param {Array.<number>} [opt.boundingMode='all']
 *        Specify how to calculate boundingRect when locating.
 *        'all': Position the boundingRect that is transformed and uioned
 *               both itself and its descendants.
 *               This mode simplies confine the elements in the bounding
 *               of their container (e.g., using 'right: 0').
 *        'raw': Position the boundingRect that is not transformed and only itself.
 *               This mode is useful when you want a element can overflow its
 *               container. (Consider a rotated circle needs to be located in a corner.)
 *               In this mode positionInfo.width/height can only be number.
 */


function positionElement(el, positionInfo, containerRect, margin, opt) {
  var h = !opt || !opt.hv || opt.hv[0];
  var v = !opt || !opt.hv || opt.hv[1];
  var boundingMode = opt && opt.boundingMode || 'all';

  if (!h && !v) {
    return;
  }

  var rect;

  if (boundingMode === 'raw') {
    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
  } else {
    rect = el.getBoundingRect();

    if (el.needLocalTransform()) {
      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,
      // which should not be modified.

      rect = rect.clone();
      rect.applyTransform(transform);
    }
  } // The real width and height can not be specified but calculated by the given el.


  positionInfo = getLayoutRect(zrUtil.defaults({
    width: rect.width,
    height: rect.height
  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform
  // (see zrender/core/Transformable#getLocalTransform),
  // we can just only modify el.position to get final result.

  var elPos = el.position;
  var dx = h ? positionInfo.x - rect.x : 0;
  var dy = v ? positionInfo.y - rect.y : 0;
  el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
}
/**
 * @param {Object} option Contains some of the properties in HV_NAMES.
 * @param {number} hvIdx 0: horizontal; 1: vertical.
 */


function sizeCalculable(option, hvIdx) {
  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
/**
 * Consider Case:
 * When defulat option has {left: 0, width: 100}, and we set {right: 0}
 * through setOption or media query, using normal zrUtil.merge will cause
 * {right: 0} does not take effect.
 *
 * @example
 * ComponentModel.extend({
 *     init: function () {
 *         ...
 *         var inputPositionParams = layout.getLayoutParams(option);
 *         this.mergeOption(inputPositionParams);
 *     },
 *     mergeOption: function (newOption) {
 *         newOption && zrUtil.merge(thisOption, newOption, true);
 *         layout.mergeLayoutParam(thisOption, newOption);
 *     }
 * });
 *
 * @param {Object} targetOption
 * @param {Object} newOption
 * @param {Object|string} [opt]
 * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components
 *  that width (or height) should not be calculated by left and right (or top and bottom).
 */


function mergeLayoutParam(targetOption, newOption, opt) {
  !zrUtil.isObject(opt) && (opt = {});
  var ignoreSize = opt.ignoreSize;
  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  var hResult = merge(HV_NAMES[0], 0);
  var vResult = merge(HV_NAMES[1], 1);
  copy(HV_NAMES[0], targetOption, hResult);
  copy(HV_NAMES[1], targetOption, vResult);

  function merge(names, hvIdx) {
    var newParams = {};
    var newValueCount = 0;
    var merged = {};
    var mergedValueCount = 0;
    var enoughParamNumber = 2;
    each(names, function (name) {
      merged[name] = targetOption[name];
    });
    each(names, function (name) {
      // Consider case: newOption.width is null, which is
      // set by user for removing width setting.
      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
      hasValue(newParams, name) && newValueCount++;
      hasValue(merged, name) && mergedValueCount++;
    });

    if (ignoreSize[hvIdx]) {
      // Only one of left/right is premitted to exist.
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }

      return merged;
    } // Case: newOption: {width: ..., right: ...},
    // or targetOption: {right: ...} and newOption: {width: ...},
    // There is no conflict when merged only has params count
    // little than enoughParamNumber.


    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } // Case: newOption: {width: ..., right: ...},
    // Than we can make sure user only want those two, and ignore
    // all origin params in targetOption.
    else if (newValueCount >= enoughParamNumber) {
        return newParams;
      } else {
        // Chose another param from targetOption by priority.
        for (var i = 0; i < names.length; i++) {
          var name = names[i];

          if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
            newParams[name] = targetOption[name];
            break;
          }
        }

        return newParams;
      }
  }

  function hasProp(obj, name) {
    return obj.hasOwnProperty(name);
  }

  function hasValue(obj, name) {
    return obj[name] != null && obj[name] !== 'auto';
  }

  function copy(names, target, source) {
    each(names, function (name) {
      target[name] = source[name];
    });
  }
}
/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 * @param {Object} source
 * @return {Object} Result contains those props.
 */


function getLayoutParams(source) {
  return copyLayoutParams({}, source);
}
/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 * @param {Object} source
 * @return {Object} Result contains those props.
 */


function copyLayoutParams(target, source) {
  source && target && each(LOCATION_PARAMS, function (name) {
    source.hasOwnProperty(name) && (target[name] = source[name]);
  });
  return target;
}

exports.LOCATION_PARAMS = LOCATION_PARAMS;
exports.HV_NAMES = HV_NAMES;
exports.box = box;
exports.vbox = vbox;
exports.hbox = hbox;
exports.getAvailableSize = getAvailableSize;
exports.getLayoutRect = getLayoutRect;
exports.positionElement = positionElement;
exports.sizeCalculable = sizeCalculable;
exports.mergeLayoutParam = mergeLayoutParam;
exports.getLayoutParams = getLayoutParams;
exports.copyLayoutParams = copyLayoutParams;

/***/ }),

/***/ "./node_modules/echarts/lib/util/model.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var each = zrUtil.each;
var isObject = zrUtil.isObject;
var isArray = zrUtil.isArray;
/**
 * Make the name displayable. But we should
 * make sure it is not duplicated with user
 * specified name, so use '\0';
 */

var DUMMY_COMPONENT_NAME_PREFIX = 'series\0';
/**
 * If value is not array, then translate it to array.
 * @param  {*} value
 * @return {Array} [value] or value
 */

function normalizeToArray(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
/**
 * Sync default option between normal and emphasis like `position` and `show`
 * In case some one will write code like
 *     label: {
 *          show: false,
 *          position: 'outside',
 *          fontSize: 18
 *     },
 *     emphasis: {
 *          label: { show: true }
 *     }
 * @param {Object} opt
 * @param {string} key
 * @param {Array.<string>} subOpts
 */


function defaultEmphasis(opt, key, subOpts) {
  // Caution: performance sensitive.
  if (opt) {
    opt[key] = opt[key] || {};
    opt.emphasis = opt.emphasis || {};
    opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal

    for (var i = 0, len = subOpts.length; i < len; i++) {
      var subOptName = subOpts[i];

      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
        opt.emphasis[key][subOptName] = opt[key][subOptName];
      }
    }
  }
}

var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([
//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',
//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',
//     // FIXME: deprecated, check and remove it.
//     'textStyle'
// ]);

/**
 * The method do not ensure performance.
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method retieves value from data.
 * @param {string|number|Date|Array|Object} dataItem
 * @return {number|string|Date|Array.<number|string|Date>}
 */

function getDataItemValue(dataItem) {
  return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
/**
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method determine if dataItem has extra option besides value
 * @param {string|number|Date|Array|Object} dataItem
 */


function isDataItemOption(dataItem) {
  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array
  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
}
/**
 * Mapping to exists for merge.
 *
 * @public
 * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists
 * @param {Object|Array.<Object>} newCptOptions
 * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
 *                          index of which is the same as exists.
 */


function mappingToExists(exists, newCptOptions) {
  // Mapping by the order by original option (but not order of
  // new option) in merge mode. Because we should ensure
  // some specified index (like xAxisIndex) is consistent with
  // original option, which is easy to understand, espatially in
  // media query. And in most case, merge option is used to
  // update partial option but not be expected to change order.
  newCptOptions = (newCptOptions || []).slice();
  var result = zrUtil.map(exists || [], function (obj, index) {
    return {
      exist: obj
    };
  }); // Mapping by id or name if specified.

  each(newCptOptions, function (cptOption, index) {
    if (!isObject(cptOption)) {
      return;
    } // id has highest priority.


    for (var i = 0; i < result.length; i++) {
      if (!result[i].option // Consider name: two map to one.
      && cptOption.id != null && result[i].exist.id === cptOption.id + '') {
        result[i].option = cptOption;
        newCptOptions[index] = null;
        return;
      }
    }

    for (var i = 0; i < result.length; i++) {
      var exist = result[i].exist;

      if (!result[i].option // Consider name: two map to one.
      // Can not match when both ids exist but different.
      && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {
        result[i].option = cptOption;
        newCptOptions[index] = null;
        return;
      }
    }
  }); // Otherwise mapping by index.

  each(newCptOptions, function (cptOption, index) {
    if (!isObject(cptOption)) {
      return;
    }

    var i = 0;

    for (; i < result.length; i++) {
      var exist = result[i].exist;

      if (!result[i].option // Existing model that already has id should be able to
      // mapped to (because after mapping performed model may
      // be assigned with a id, whish should not affect next
      // mapping), except those has inner id.
      && !isIdInner(exist) // Caution:
      // Do not overwrite id. But name can be overwritten,
      // because axis use name as 'show label text'.
      // 'exist' always has id and name and we dont
      // need to check it.
      && cptOption.id == null) {
        result[i].option = cptOption;
        break;
      }
    }

    if (i >= result.length) {
      result.push({
        option: cptOption
      });
    }
  });
  return result;
}
/**
 * Make id and name for mapping result (result of mappingToExists)
 * into `keyInfo` field.
 *
 * @public
 * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
 *                          which order is the same as exists.
 * @return {Array.<Object>} The input.
 */


function makeIdAndName(mapResult) {
  // We use this id to hash component models and view instances
  // in echarts. id can be specified by user, or auto generated.
  // The id generation rule ensures new view instance are able
  // to mapped to old instance when setOption are called in
  // no-merge mode. So we generate model id by name and plus
  // type in view id.
  // name can be duplicated among components, which is convenient
  // to specify multi components (like series) by one name.
  // Ensure that each id is distinct.
  var idMap = zrUtil.createHashMap();
  each(mapResult, function (item, index) {
    var existCpt = item.exist;
    existCpt && idMap.set(existCpt.id, item);
  });
  each(mapResult, function (item, index) {
    var opt = item.option;
    zrUtil.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  }); // Make name and id.

  each(mapResult, function (item, index) {
    var existCpt = item.exist;
    var opt = item.option;
    var keyInfo = item.keyInfo;

    if (!isObject(opt)) {
      return;
    } // name can be overwitten. Consider case: axis.name = '20km'.
    // But id generated by name will not be changed, which affect
    // only in that case: setOption with 'not merge mode' and view
    // instance will be recreated, which can be accepted.


    keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name // Avoid diffferent series has the same name,
    // because name may be used like in color pallet.
    : DUMMY_COMPONENT_NAME_PREFIX + index;

    if (existCpt) {
      keyInfo.id = existCpt.id;
    } else if (opt.id != null) {
      keyInfo.id = opt.id + '';
    } else {
      // Consider this situatoin:
      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]
      //  optionB [{..}, {name: 'a'}, {name: 'a'}]
      // Series with the same name between optionA and optionB
      // should be mapped.
      var idNum = 0;

      do {
        keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
      } while (idMap.get(keyInfo.id));
    }

    idMap.set(keyInfo.id, item);
  });
}

function isNameSpecified(componentModel) {
  var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.

  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
/**
 * @public
 * @param {Object} cptOption
 * @return {boolean}
 */


function isIdInner(cptOption) {
  return isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\0_ec_\0') === 0;
}
/**
 * A helper for removing duplicate items between batchA and batchB,
 * and in themselves, and categorize by series.
 *
 * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]
 */


function compressBatches(batchA, batchB) {
  var mapA = {};
  var mapB = {};
  makeMap(batchA || [], mapA);
  makeMap(batchB || [], mapB, mapA);
  return [mapToArray(mapA), mapToArray(mapB)];

  function makeMap(sourceBatch, map, otherMap) {
    for (var i = 0, len = sourceBatch.length; i < len; i++) {
      var seriesId = sourceBatch[i].seriesId;
      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
      var otherDataIndices = otherMap && otherMap[seriesId];

      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
        var dataIndex = dataIndices[j];

        if (otherDataIndices && otherDataIndices[dataIndex]) {
          otherDataIndices[dataIndex] = null;
        } else {
          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
        }
      }
    }
  }

  function mapToArray(map, isData) {
    var result = [];

    for (var i in map) {
      if (map.hasOwnProperty(i) && map[i] != null) {
        if (isData) {
          result.push(+i);
        } else {
          var dataIndices = mapToArray(map[i], true);
          dataIndices.length && result.push({
            seriesId: i,
            dataIndex: dataIndices
          });
        }
      }
    }

    return result;
  }
}
/**
 * @param {module:echarts/data/List} data
 * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name
 *                         each of which can be Array or primary type.
 * @return {number|Array.<number>} dataIndex If not found, return undefined/null.
 */


function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function (value) {
      return data.indexOfRawIndex(value);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function (value) {
      return data.indexOfName(value);
    }) : data.indexOfName(payload.name);
  }
}
/**
 * Enable property storage to any host object.
 * Notice: Serialization is not supported.
 *
 * For example:
 * var inner = zrUitl.makeInner();
 *
 * function some1(hostObj) {
 *      inner(hostObj).someProperty = 1212;
 *      ...
 * }
 * function some2() {
 *      var fields = inner(this);
 *      fields.someProperty1 = 1212;
 *      fields.someProperty2 = 'xx';
 *      ...
 * }
 *
 * @return {Function}
 */


function makeInner() {
  // Consider different scope by es module import.
  var key = '__\0ec_inner_' + innerUniqueIndex++ + '_' + Math.random().toFixed(5);
  return function (hostObj) {
    return hostObj[key] || (hostObj[key] = {});
  };
}

var innerUniqueIndex = 0;
/**
 * @param {module:echarts/model/Global} ecModel
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex, seriesId, seriesName,
 *            geoIndex, geoId, geoName,
 *            bmapIndex, bmapId, bmapName,
 *            xAxisIndex, xAxisId, xAxisName,
 *            yAxisIndex, yAxisId, yAxisName,
 *            gridIndex, gridId, gridName,
 *            ... (can be extended)
 *        }
 *        Each properties can be number|string|Array.<number>|Array.<string>
 *        For example, a finder could be
 *        {
 *            seriesIndex: 3,
 *            geoId: ['aa', 'cc'],
 *            gridName: ['xx', 'rr']
 *        }
 *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)
 *        If nothing or null/undefined specified, return nothing.
 * @param {Object} [opt]
 * @param {string} [opt.defaultMainType]
 * @param {Array.<string>} [opt.includeMainTypes]
 * @return {Object} result like:
 *        {
 *            seriesModels: [seriesModel1, seriesModel2],
 *            seriesModel: seriesModel1, // The first model
 *            geoModels: [geoModel1, geoModel2],
 *            geoModel: geoModel1, // The first model
 *            ...
 *        }
 */

function parseFinder(ecModel, finder, opt) {
  if (zrUtil.isString(finder)) {
    var obj = {};
    obj[finder + 'Index'] = 0;
    finder = obj;
  }

  var defaultMainType = opt && opt.defaultMainType;

  if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name')) {
    finder[defaultMainType + 'Index'] = 0;
  }

  var result = {};
  each(finder, function (value, key) {
    var value = finder[key]; // Exclude 'dataIndex' and other illgal keys.

    if (key === 'dataIndex' || key === 'dataIndexInside') {
      result[key] = value;
      return;
    }

    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    var mainType = parsedKey[1];
    var queryType = (parsedKey[2] || '').toLowerCase();

    if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) {
      return;
    }

    var queryParam = {
      mainType: mainType
    };

    if (queryType !== 'index' || value !== 'all') {
      queryParam[queryType] = value;
    }

    var models = ecModel.queryComponents(queryParam);
    result[mainType + 'Models'] = models;
    result[mainType + 'Model'] = models[0];
  });
  return result;
}

function has(obj, prop) {
  return obj && obj.hasOwnProperty(prop);
}

function setAttribute(dom, key, value) {
  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
}

function getAttribute(dom, key) {
  return dom.getAttribute ? dom.getAttribute(key) : dom[key];
}

exports.normalizeToArray = normalizeToArray;
exports.defaultEmphasis = defaultEmphasis;
exports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;
exports.getDataItemValue = getDataItemValue;
exports.isDataItemOption = isDataItemOption;
exports.mappingToExists = mappingToExists;
exports.makeIdAndName = makeIdAndName;
exports.isNameSpecified = isNameSpecified;
exports.isIdInner = isIdInner;
exports.compressBatches = compressBatches;
exports.queryDataIndex = queryDataIndex;
exports.makeInner = makeInner;
exports.parseFinder = parseFinder;
exports.setAttribute = setAttribute;
exports.getAttribute = getAttribute;

/***/ }),

/***/ "./node_modules/echarts/lib/util/number.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var RADIAN_EPSILON = 1e-4;

function _trim(str) {
  return str.replace(/^\s+/, '').replace(/\s+$/, '');
}
/**
 * Linear mapping a value from domain to range
 * @memberOf module:echarts/util/number
 * @param  {(number|Array.<number>)} val
 * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]
 * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]
 * @param  {boolean} clamp
 * @return {(number|Array.<number>}
 */


function linearMap(val, domain, range, clamp) {
  var subDomain = domain[1] - domain[0];
  var subRange = range[1] - range[0];

  if (subDomain === 0) {
    return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
  } // Avoid accuracy problem in edge, such as
  // 146.39 - 62.83 === 83.55999999999999.
  // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
  // It is a little verbose for efficiency considering this method
  // is a hotspot.


  if (clamp) {
    if (subDomain > 0) {
      if (val <= domain[0]) {
        return range[0];
      } else if (val >= domain[1]) {
        return range[1];
      }
    } else {
      if (val >= domain[0]) {
        return range[0];
      } else if (val <= domain[1]) {
        return range[1];
      }
    }
  } else {
    if (val === domain[0]) {
      return range[0];
    }

    if (val === domain[1]) {
      return range[1];
    }
  }

  return (val - domain[0]) / subDomain * subRange + range[0];
}
/**
 * Convert a percent string to absolute number.
 * Returns NaN if percent is not a valid string or number
 * @memberOf module:echarts/util/number
 * @param {string|number} percent
 * @param {number} all
 * @return {number}
 */


function parsePercent(percent, all) {
  switch (percent) {
    case 'center':
    case 'middle':
      percent = '50%';
      break;

    case 'left':
    case 'top':
      percent = '0%';
      break;

    case 'right':
    case 'bottom':
      percent = '100%';
      break;
  }

  if (typeof percent === 'string') {
    if (_trim(percent).match(/%$/)) {
      return parseFloat(percent) / 100 * all;
    }

    return parseFloat(percent);
  }

  return percent == null ? NaN : +percent;
}
/**
 * (1) Fix rounding error of float numbers.
 * (2) Support return string to avoid scientific notation like '3.5e-7'.
 *
 * @param {number} x
 * @param {number} [precision]
 * @param {boolean} [returnStr]
 * @return {number|string}
 */


function round(x, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  } // Avoid range error


  precision = Math.min(Math.max(0, precision), 20);
  x = (+x).toFixed(precision);
  return returnStr ? x : +x;
}

function asc(arr) {
  arr.sort(function (a, b) {
    return a - b;
  });
  return arr;
}
/**
 * Get precision
 * @param {number} val
 */


function getPrecision(val) {
  val = +val;

  if (isNaN(val)) {
    return 0;
  } // It is much faster than methods converting number to string as follows
  //      var tmp = val.toString();
  //      return tmp.length - 1 - tmp.indexOf('.');
  // especially when precision is low


  var e = 1;
  var count = 0;

  while (Math.round(val * e) / e !== val) {
    e *= 10;
    count++;
  }

  return count;
}
/**
 * @param {string|number} val
 * @return {number}
 */


function getPrecisionSafe(val) {
  var str = val.toString(); // Consider scientific notation: '3.4e-12' '3.4e+12'

  var eIndex = str.indexOf('e');

  if (eIndex > 0) {
    var precision = +str.slice(eIndex + 1);
    return precision < 0 ? -precision : 0;
  } else {
    var dotIndex = str.indexOf('.');
    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
  }
}
/**
 * Minimal dicernible data precisioin according to a single pixel.
 *
 * @param {Array.<number>} dataExtent
 * @param {Array.<number>} pixelExtent
 * @return {number} precision
 */


function getPixelPrecision(dataExtent, pixelExtent) {
  var log = Math.log;
  var LN10 = Math.LN10;
  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20.

  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
/**
 * Get a data of given precision, assuring the sum of percentages
 * in valueList is 1.
 * The largest remainer method is used.
 * https://en.wikipedia.org/wiki/Largest_remainder_method
 *
 * @param {Array.<number>} valueList a list of all data
 * @param {number} idx index of the data to be processed in valueList
 * @param {number} precision integer number showing digits of precision
 * @return {number} percent ranging from 0 to 100
 */


function getPercentWithPrecision(valueList, idx, precision) {
  if (!valueList[idx]) {
    return 0;
  }

  var sum = zrUtil.reduce(valueList, function (acc, val) {
    return acc + (isNaN(val) ? 0 : val);
  }, 0);

  if (sum === 0) {
    return 0;
  }

  var digits = Math.pow(10, precision);
  var votesPerQuota = zrUtil.map(valueList, function (val) {
    return (isNaN(val) ? 0 : val) / sum * digits * 100;
  });
  var targetSeats = digits * 100;
  var seats = zrUtil.map(votesPerQuota, function (votes) {
    // Assign automatic seats.
    return Math.floor(votes);
  });
  var currentSum = zrUtil.reduce(seats, function (acc, val) {
    return acc + val;
  }, 0);
  var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {
    return votes - seats[idx];
  }); // Has remainding votes.

  while (currentSum < targetSeats) {
    // Find next largest remainder.
    var max = Number.NEGATIVE_INFINITY;
    var maxId = null;

    for (var i = 0, len = remainder.length; i < len; ++i) {
      if (remainder[i] > max) {
        max = remainder[i];
        maxId = i;
      }
    } // Add a vote to max remainder.


    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }

  return seats[idx] / digits;
} // Number.MAX_SAFE_INTEGER, ie do not support.


var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * To 0 - 2 * PI, considering negative radian.
 * @param {number} radian
 * @return {number}
 */

function remRadian(radian) {
  var pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
/**
 * @param {type} radian
 * @return {boolean}
 */


function isRadianAroundZero(val) {
  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}

var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; // jshint ignore:line

/**
 * @param {string|Date|number} value These values can be accepted:
 *   + An instance of Date, represent a time in its own time zone.
 *   + Or string in a subset of ISO 8601, only including:
 *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
 *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
 *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
 *     all of which will be treated as local time if time zone is not specified
 *     (see <https://momentjs.com/>).
 *   + Or other string format, including (all of which will be treated as loacal time):
 *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
 *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
 *   + a timestamp, which represent a time in UTC.
 * @return {Date} date
 */

function parseDate(value) {
  if (value instanceof Date) {
    return value;
  } else if (typeof value === 'string') {
    // Different browsers parse date in different way, so we parse it manually.
    // Some other issues:
    // new Date('1970-01-01') is UTC,
    // new Date('1970/01/01') and new Date('1970-1-01') is local.
    // See issue #3623
    var match = TIME_REG.exec(value);

    if (!match) {
      // return Invalid Date.
      return new Date(NaN);
    } // Use local time when no timezone offset specifed.


    if (!match[8]) {
      // match[n] can only be string or undefined.
      // But take care of '12' + 1 => '121'.
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
    } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,
    // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).
    // For example, system timezone is set as "Time Zone: America/Toronto",
    // then these code will get different result:
    // `new Date(1478411999999).getTimezoneOffset();  // get 240`
    // `new Date(1478412000000).getTimezoneOffset();  // get 300`
    // So we should not use `new Date`, but use `Date.UTC`.
    else {
        var hour = +match[4] || 0;

        if (match[8].toUpperCase() !== 'Z') {
          hour -= match[8].slice(0, 3);
        }

        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
      }
  } else if (value == null) {
    return new Date(NaN);
  }

  return new Date(Math.round(value));
}
/**
 * Quantity of a number. e.g. 0.1, 1, 10, 100
 *
 * @param  {number} val
 * @return {number}
 */


function quantity(val) {
  return Math.pow(10, quantityExponent(val));
}

function quantityExponent(val) {
  return Math.floor(Math.log(val) / Math.LN10);
}
/**
 * find a “nice” number approximately equal to x. Round the number if round = true,
 * take ceiling if round = false. The primary observation is that the “nicest”
 * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
 *
 * See "Nice Numbers for Graph Labels" of Graphic Gems.
 *
 * @param  {number} val Non-negative value.
 * @param  {boolean} round
 * @return {number}
 */


function nice(val, round) {
  var exponent = quantityExponent(val);
  var exp10 = Math.pow(10, exponent);
  var f = val / exp10; // 1 <= f < 10

  var nf;

  if (round) {
    if (f < 1.5) {
      nf = 1;
    } else if (f < 2.5) {
      nf = 2;
    } else if (f < 4) {
      nf = 3;
    } else if (f < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f < 1) {
      nf = 1;
    } else if (f < 2) {
      nf = 2;
    } else if (f < 3) {
      nf = 3;
    } else if (f < 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }

  val = nf * exp10; // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).
  // 20 is the uppper bound of toFixed.

  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
/**
 * Order intervals asc, and split them when overlap.
 * expect(numberUtil.reformIntervals([
 *     {interval: [18, 62], close: [1, 1]},
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [1, 1]},
 *     {interval: [62, 150], close: [1, 1]},
 *     {interval: [106, 150], close: [1, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ])).toEqual([
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [0, 1]},
 *     {interval: [18, 62], close: [0, 1]},
 *     {interval: [62, 150], close: [0, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ]);
 * @param {Array.<Object>} list, where `close` mean open or close
 *        of the interval, and Infinity can be used.
 * @return {Array.<Object>} The origin list, which has been reformed.
 */


function reformIntervals(list) {
  list.sort(function (a, b) {
    return littleThan(a, b, 0) ? -1 : 1;
  });
  var curr = -Infinity;
  var currClose = 1;

  for (var i = 0; i < list.length;) {
    var interval = list[i].interval;
    var close = list[i].close;

    for (var lg = 0; lg < 2; lg++) {
      if (interval[lg] <= curr) {
        interval[lg] = curr;
        close[lg] = !lg ? 1 - currClose : 1;
      }

      curr = interval[lg];
      currClose = close[lg];
    }

    if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
      list.splice(i, 1);
    } else {
      i++;
    }
  }

  return list;

  function littleThan(a, b, lg) {
    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));
  }
}
/**
 * parseFloat NaNs numeric-cast false positives (null|true|false|"")
 * ...but misinterprets leading-number strings, particularly hex literals ("0x...")
 * subtraction forces infinities to NaN
 *
 * @param {*} v
 * @return {boolean}
 */


function isNumeric(v) {
  return v - parseFloat(v) >= 0;
}

exports.linearMap = linearMap;
exports.parsePercent = parsePercent;
exports.round = round;
exports.asc = asc;
exports.getPrecision = getPrecision;
exports.getPrecisionSafe = getPrecisionSafe;
exports.getPixelPrecision = getPixelPrecision;
exports.getPercentWithPrecision = getPercentWithPrecision;
exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
exports.remRadian = remRadian;
exports.isRadianAroundZero = isRadianAroundZero;
exports.parseDate = parseDate;
exports.quantity = quantity;
exports.nice = nice;
exports.reformIntervals = reformIntervals;
exports.isNumeric = isNumeric;

/***/ }),

/***/ "./node_modules/echarts/lib/util/symbol.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var graphic = __webpack_require__("./node_modules/echarts/lib/util/graphic.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Symbol factory

/**
 * Triangle shape
 * @inner
 */
var Triangle = graphic.extendShape({
  type: 'triangle',
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy + height);
    path.lineTo(cx - width, cy + height);
    path.closePath();
  }
});
/**
 * Diamond shape
 * @inner
 */

var Diamond = graphic.extendShape({
  type: 'diamond',
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy);
    path.lineTo(cx, cy + height);
    path.lineTo(cx - width, cy);
    path.closePath();
  }
});
/**
 * Pin shape
 * @inner
 */

var Pin = graphic.extendShape({
  type: 'pin',
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var x = shape.x;
    var y = shape.y;
    var w = shape.width / 5 * 3; // Height must be larger than width

    var h = Math.max(w, shape.height);
    var r = w / 2; // Dist on y with tangent point and circle center

    var dy = r * r / (h - r);
    var cy = y - h + r + dy;
    var angle = Math.asin(dy / r); // Dist on x with tangent point and circle center

    var dx = Math.cos(angle) * r;
    var tanX = Math.sin(angle);
    var tanY = Math.cos(angle);
    var cpLen = r * 0.6;
    var cpLen2 = r * 0.7;
    path.moveTo(x - dx, cy + dy);
    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
    path.closePath();
  }
});
/**
 * Arrow shape
 * @inner
 */

var Arrow = graphic.extendShape({
  type: 'arrow',
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (ctx, shape) {
    var height = shape.height;
    var width = shape.width;
    var x = shape.x;
    var y = shape.y;
    var dx = width / 3 * 2;
    ctx.moveTo(x, y);
    ctx.lineTo(x + dx, y + height);
    ctx.lineTo(x, y + height / 4 * 3);
    ctx.lineTo(x - dx, y + height);
    ctx.lineTo(x, y);
    ctx.closePath();
  }
});
/**
 * Map of path contructors
 * @type {Object.<string, module:zrender/graphic/Path>}
 */

var symbolCtors = {
  line: graphic.Line,
  rect: graphic.Rect,
  roundRect: graphic.Rect,
  square: graphic.Rect,
  circle: graphic.Circle,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
};
var symbolShapeMakers = {
  line: function (x, y, w, h, shape) {
    // FIXME
    shape.x1 = x;
    shape.y1 = y + h / 2;
    shape.x2 = x + w;
    shape.y2 = y + h / 2;
  },
  rect: function (x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
  },
  roundRect: function (x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
    shape.r = Math.min(w, h) / 4;
  },
  square: function (x, y, w, h, shape) {
    var size = Math.min(w, h);
    shape.x = x;
    shape.y = y;
    shape.width = size;
    shape.height = size;
  },
  circle: function (x, y, w, h, shape) {
    // Put circle in the center of square
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.r = Math.min(w, h) / 2;
  },
  diamond: function (x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  pin: function (x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  arrow: function (x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  triangle: function (x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  }
};
var symbolBuildProxies = {};
zrUtil.each(symbolCtors, function (Ctor, name) {
  symbolBuildProxies[name] = new Ctor();
});
var SymbolClz = graphic.extendShape({
  type: 'symbol',
  shape: {
    symbolType: '',
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  beforeBrush: function () {
    var style = this.style;
    var shape = this.shape; // FIXME

    if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
      style.textPosition = ['50%', '40%'];
      style.textAlign = 'center';
      style.textVerticalAlign = 'middle';
    }
  },
  buildPath: function (ctx, shape, inBundle) {
    var symbolType = shape.symbolType;
    var proxySymbol = symbolBuildProxies[symbolType];

    if (shape.symbolType !== 'none') {
      if (!proxySymbol) {
        // Default rect
        symbolType = 'rect';
        proxySymbol = symbolBuildProxies[symbolType];
      }

      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
}); // Provide setColor helper method to avoid determine if set the fill or stroke outside

function symbolPathSetColor(color, innerColor) {
  if (this.type !== 'image') {
    var symbolStyle = this.style;
    var symbolShape = this.shape;

    if (symbolShape && symbolShape.symbolType === 'line') {
      symbolStyle.stroke = color;
    } else if (this.__isEmptyBrush) {
      symbolStyle.stroke = color;
      symbolStyle.fill = innerColor || '#fff';
    } else {
      // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
      symbolStyle.fill && (symbolStyle.fill = color);
      symbolStyle.stroke && (symbolStyle.stroke = color);
    }

    this.dirty(false);
  }
}
/**
 * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
 * @param {string} symbolType
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {string} color
 * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,
 *                            for path and image only.
 */


function createSymbol(symbolType, x, y, w, h, color, keepAspect) {
  // TODO Support image object, DynamicImage.
  var isEmpty = symbolType.indexOf('empty') === 0;

  if (isEmpty) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }

  var symbolPath;

  if (symbolType.indexOf('image://') === 0) {
    symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');
  } else if (symbolType.indexOf('path://') === 0) {
    symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');
  } else {
    symbolPath = new SymbolClz({
      shape: {
        symbolType: symbolType,
        x: x,
        y: y,
        width: w,
        height: h
      }
    });
  }

  symbolPath.__isEmptyBrush = isEmpty;
  symbolPath.setColor = symbolPathSetColor;
  symbolPath.setColor(color);
  return symbolPath;
}

exports.createSymbol = createSymbol;

/***/ }),

/***/ "./node_modules/echarts/lib/util/throttle.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var ORIGIN_METHOD = '\0__throttleOriginMethod';
var RATE = '\0__throttleRate';
var THROTTLE_TYPE = '\0__throttleType';
/**
 * @public
 * @param {(Function)} fn
 * @param {number} [delay=0] Unit: ms.
 * @param {boolean} [debounce=false]
 *        true: If call interval less than `delay`, only the last call works.
 *        false: If call interval less than `delay, call works on fixed rate.
 * @return {(Function)} throttled fn.
 */

function throttle(fn, delay, debounce) {
  var currCall;
  var lastCall = 0;
  var lastExec = 0;
  var timer = null;
  var diff;
  var scope;
  var args;
  var debounceNextCall;
  delay = delay || 0;

  function exec() {
    lastExec = new Date().getTime();
    timer = null;
    fn.apply(scope, args || []);
  }

  var cb = function () {
    currCall = new Date().getTime();
    scope = this;
    args = arguments;
    var thisDelay = debounceNextCall || delay;
    var thisDebounce = debounceNextCall || debounce;
    debounceNextCall = null;
    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer); // Here we should make sure that: the `exec` SHOULD NOT be called later
    // than a new call of `cb`, that is, preserving the command order. Consider
    // calculating "scale rate" when roaming as an example. When a call of `cb`
    // happens, either the `exec` is called dierectly, or the call is delayed.
    // But the delayed call should never be later than next call of `cb`. Under
    // this assurance, we can simply update view state each time `dispatchAction`
    // triggered by user roaming, but not need to add extra code to avoid the
    // state being "rolled-back".

    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff);
      }
    }

    lastCall = currCall;
  };
  /**
   * Clear throttle.
   * @public
   */


  cb.clear = function () {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  /**
   * Enable debounce once.
   */


  cb.debounceNextCall = function (debounceDelay) {
    debounceNextCall = debounceDelay;
  };

  return cb;
}
/**
 * Create throttle method or update throttle rate.
 *
 * @example
 * ComponentView.prototype.render = function () {
 *     ...
 *     throttle.createOrUpdate(
 *         this,
 *         '_dispatchAction',
 *         this.model.get('throttle'),
 *         'fixRate'
 *     );
 * };
 * ComponentView.prototype.remove = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 * ComponentView.prototype.dispose = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 *
 * @public
 * @param {Object} obj
 * @param {string} fnAttr
 * @param {number} [rate]
 * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'
 * @return {Function} throttled function.
 */


function createOrUpdate(obj, fnAttr, rate, throttleType) {
  var fn = obj[fnAttr];

  if (!fn) {
    return;
  }

  var originFn = fn[ORIGIN_METHOD] || fn;
  var lastThrottleType = fn[THROTTLE_TYPE];
  var lastRate = fn[RATE];

  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }

    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');
    fn[ORIGIN_METHOD] = originFn;
    fn[THROTTLE_TYPE] = throttleType;
    fn[RATE] = rate;
  }

  return fn;
}
/**
 * Clear throttle. Example see throttle.createOrUpdate.
 *
 * @public
 * @param {Object} obj
 * @param {string} fnAttr
 */


function clear(obj, fnAttr) {
  var fn = obj[fnAttr];

  if (fn && fn[ORIGIN_METHOD]) {
    obj[fnAttr] = fn[ORIGIN_METHOD];
  }
}

exports.throttle = throttle;
exports.createOrUpdate = createOrUpdate;
exports.clear = clear;

/***/ }),

/***/ "./node_modules/echarts/lib/view/Chart.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var each = _util.each;

var Group = __webpack_require__("./node_modules/zrender/lib/container/Group.js");

var componentUtil = __webpack_require__("./node_modules/echarts/lib/util/component.js");

var clazzUtil = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

var modelUtil = __webpack_require__("./node_modules/echarts/lib/util/model.js");

var _task = __webpack_require__("./node_modules/echarts/lib/stream/task.js");

var createTask = _task.createTask;

var createRenderPlanner = __webpack_require__("./node_modules/echarts/lib/chart/helper/createRenderPlanner.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var inner = modelUtil.makeInner();
var renderPlanner = createRenderPlanner();

function Chart() {
  /**
   * @type {module:zrender/container/Group}
   * @readOnly
   */
  this.group = new Group();
  /**
   * @type {string}
   * @readOnly
   */

  this.uid = componentUtil.getUID('viewChart');
  this.renderTask = createTask({
    plan: renderTaskPlan,
    reset: renderTaskReset
  });
  this.renderTask.context = {
    view: this
  };
}

Chart.prototype = {
  type: 'chart',

  /**
   * Init the chart.
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  init: function (ecModel, api) {},

  /**
   * Render the chart.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  render: function (seriesModel, ecModel, api, payload) {},

  /**
   * Highlight series or specified data item.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  highlight: function (seriesModel, ecModel, api, payload) {
    toggleHighlight(seriesModel.getData(), payload, 'emphasis');
  },

  /**
   * Downplay series or specified data item.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  downplay: function (seriesModel, ecModel, api, payload) {
    toggleHighlight(seriesModel.getData(), payload, 'normal');
  },

  /**
   * Remove self.
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  remove: function (ecModel, api) {
    this.group.removeAll();
  },

  /**
   * Dispose self.
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  dispose: function () {},

  /**
   * Rendering preparation in progressive mode.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  incrementalPrepareRender: null,

  /**
   * Render in progressive mode.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  incrementalRender: null,

  /**
   * Update transform directly.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   * @return {Object} {update: true}
   */
  updateTransform: null
  /**
   * The view contains the given point.
   * @interface
   * @param {Array.<number>} point
   * @return {boolean}
   */
  // containPoint: function () {}

};
var chartProto = Chart.prototype;

chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {
  this.render(seriesModel, ecModel, api, payload);
};
/**
 * Set state of single element
 * @param  {module:zrender/Element} el
 * @param  {string} state
 */


function elSetState(el, state) {
  if (el) {
    el.trigger(state);

    if (el.type === 'group') {
      for (var i = 0; i < el.childCount(); i++) {
        elSetState(el.childAt(i), state);
      }
    }
  }
}
/**
 * @param  {module:echarts/data/List} data
 * @param  {Object} payload
 * @param  {string} state 'normal'|'emphasis'
 */


function toggleHighlight(data, payload, state) {
  var dataIndex = modelUtil.queryDataIndex(data, payload);

  if (dataIndex != null) {
    each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state);
    });
  } else {
    data.eachItemGraphicEl(function (el) {
      elSetState(el, state);
    });
  }
} // Enable Chart.extend.


clazzUtil.enableClassExtend(Chart, ['dispose']); // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

clazzUtil.enableClassManagement(Chart, {
  registerWhenExtend: true
});

Chart.markUpdateMethod = function (payload, methodName) {
  inner(payload).updateMethod = methodName;
};

function renderTaskPlan(context) {
  return renderPlanner(context.model);
}

function renderTaskReset(context) {
  var seriesModel = context.model;
  var ecModel = context.ecModel;
  var api = context.api;
  var payload = context.payload; // ???! remove updateView updateVisual

  var progressiveRender = seriesModel.pipelineContext.progressiveRender;
  var view = context.view;
  var updateMethod = payload && inner(payload).updateMethod;
  var methodName = progressiveRender ? 'incrementalPrepareRender' : updateMethod && view[updateMethod] ? updateMethod // `appendData` is also supported when data amount
  // is less than progressive threshold.
  : 'render';

  if (methodName !== 'render') {
    view[methodName](seriesModel, ecModel, api, payload);
  }

  return progressMethodMap[methodName];
}

var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function (params, context) {
      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: true,
    progress: function (params, context) {
      context.view.render(context.model, context.ecModel, context.api, context.payload);
    }
  }
};
var _default = Chart;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/view/Component.js":
/***/ (function(module, exports, __webpack_require__) {

var Group = __webpack_require__("./node_modules/zrender/lib/container/Group.js");

var componentUtil = __webpack_require__("./node_modules/echarts/lib/util/component.js");

var clazzUtil = __webpack_require__("./node_modules/echarts/lib/util/clazz.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var Component = function () {
  /**
   * @type {module:zrender/container/Group}
   * @readOnly
   */
  this.group = new Group();
  /**
   * @type {string}
   * @readOnly
   */

  this.uid = componentUtil.getUID('viewComponent');
};

Component.prototype = {
  constructor: Component,
  init: function (ecModel, api) {},
  render: function (componentModel, ecModel, api, payload) {},
  dispose: function () {}
};
var componentProto = Component.prototype;

componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {// Do nothing;
}; // Enable Component.extend.


clazzUtil.enableClassExtend(Component); // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

clazzUtil.enableClassManagement(Component, {
  registerWhenExtend: true
});
var _default = Component;
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/visual/aria.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var lang = __webpack_require__("./node_modules/echarts/lib/lang.js");

var _dataProvider = __webpack_require__("./node_modules/echarts/lib/data/helper/dataProvider.js");

var retrieveRawValue = _dataProvider.retrieveRawValue;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function _default(dom, ecModel) {
  var ariaModel = ecModel.getModel('aria');

  if (!ariaModel.get('show')) {
    return;
  } else if (ariaModel.get('description')) {
    dom.setAttribute('aria-label', ariaModel.get('description'));
    return;
  }

  var seriesCnt = 0;
  ecModel.eachSeries(function (seriesModel, idx) {
    ++seriesCnt;
  }, this);
  var maxDataCnt = ariaModel.get('data.maxCount') || 10;
  var maxSeriesCnt = ariaModel.get('series.maxCount') || 10;
  var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
  var ariaLabel;

  if (seriesCnt < 1) {
    // No series, no aria label
    return;
  } else {
    var title = getTitle();

    if (title) {
      ariaLabel = replace(getConfig('general.withTitle'), {
        title: title
      });
    } else {
      ariaLabel = getConfig('general.withoutTitle');
    }

    var seriesLabels = [];
    var prefix = seriesCnt > 1 ? 'series.multiple.prefix' : 'series.single.prefix';
    ariaLabel += replace(getConfig(prefix), {
      seriesCount: seriesCnt
    });
    ecModel.eachSeries(function (seriesModel, idx) {
      if (idx < displaySeriesCnt) {
        var seriesLabel;
        var seriesName = seriesModel.get('name');
        var seriesTpl = 'series.' + (seriesCnt > 1 ? 'multiple' : 'single') + '.';
        seriesLabel = getConfig(seriesName ? seriesTpl + 'withName' : seriesTpl + 'withoutName');
        seriesLabel = replace(seriesLabel, {
          seriesId: seriesModel.seriesIndex,
          seriesName: seriesModel.get('name'),
          seriesType: getSeriesTypeName(seriesModel.subType)
        });
        var data = seriesModel.getData();
        window.data = data;

        if (data.count() > maxDataCnt) {
          // Show part of data
          seriesLabel += replace(getConfig('data.partialData'), {
            displayCnt: maxDataCnt
          });
        } else {
          seriesLabel += getConfig('data.allData');
        }

        var dataLabels = [];

        for (var i = 0; i < data.count(); i++) {
          if (i < maxDataCnt) {
            var name = data.getName(i);
            var value = retrieveRawValue(data, i);
            dataLabels.push(replace(name ? getConfig('data.withName') : getConfig('data.withoutName'), {
              name: name,
              value: value
            }));
          }
        }

        seriesLabel += dataLabels.join(getConfig('data.separator.middle')) + getConfig('data.separator.end');
        seriesLabels.push(seriesLabel);
      }
    });
    ariaLabel += seriesLabels.join(getConfig('series.multiple.separator.middle')) + getConfig('series.multiple.separator.end');
    dom.setAttribute('aria-label', ariaLabel);
  }

  function replace(str, keyValues) {
    if (typeof str !== 'string') {
      return str;
    }

    var result = str;
    zrUtil.each(keyValues, function (value, key) {
      result = result.replace(new RegExp('\\{\\s*' + key + '\\s*\\}', 'g'), value);
    });
    return result;
  }

  function getConfig(path) {
    var userConfig = ariaModel.get(path);

    if (userConfig == null) {
      var pathArr = path.split('.');
      var result = lang.aria;

      for (var i = 0; i < pathArr.length; ++i) {
        result = result[pathArr[i]];
      }

      return result;
    } else {
      return userConfig;
    }
  }

  function getTitle() {
    var title = ecModel.getModel('title').option;

    if (title && title.length) {
      title = title[0];
    }

    return title && title.text;
  }

  function getSeriesTypeName(type) {
    return lang.series.typeNames[type] || '自定义图';
  }
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/visual/seriesColor.js":
/***/ (function(module, exports, __webpack_require__) {

var Gradient = __webpack_require__("./node_modules/zrender/lib/graphic/Gradient.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _default = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function (seriesModel, ecModel) {
    var data = seriesModel.getData();
    var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.color').split('.');
    var color = seriesModel.get(colorAccessPath) // Set in itemStyle
    || seriesModel.getColorFromPalette( // TODO series count changed.
    seriesModel.name, null, ecModel.getSeriesCount()); // Default color
    // FIXME Set color function or use the platte color

    data.setVisual('color', color); // Only visible series has each data be visual encoded

    if (!ecModel.isSeriesFiltered(seriesModel)) {
      if (typeof color === 'function' && !(color instanceof Gradient)) {
        data.each(function (idx) {
          data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));
        });
      } // itemStyle in each data item


      var dataEach = function (data, idx) {
        var itemModel = data.getItemModel(idx);
        var color = itemModel.get(colorAccessPath, true);

        if (color != null) {
          data.setItemVisual(idx, 'color', color);
        }
      };

      return {
        dataEach: data.hasItemOption ? dataEach : null
      };
    }
  }
};
module.exports = _default;

/***/ }),

/***/ "./node_modules/echarts/lib/visual/symbol.js":
/***/ (function(module, exports) {

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function _default(seriesType, defaultSymbolType, legendSymbol) {
  // Encoding visual for all series include which is filtered for legend drawing
  return {
    seriesType: seriesType,
    // For legend.
    performRawSeries: true,
    reset: function (seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var symbolType = seriesModel.get('symbol') || defaultSymbolType;
      var symbolSize = seriesModel.get('symbolSize');
      var keepAspect = seriesModel.get('symbolKeepAspect');
      data.setVisual({
        legendSymbol: legendSymbol || symbolType,
        symbol: symbolType,
        symbolSize: symbolSize,
        symbolKeepAspect: keepAspect
      }); // Only visible series has each data be visual encoded

      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }

      var hasCallback = typeof symbolSize === 'function';

      function dataEach(data, idx) {
        if (typeof symbolSize === 'function') {
          var rawValue = seriesModel.getRawValue(idx); // FIXME

          var params = seriesModel.getDataParams(idx);
          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
        }

        if (data.hasItemOption) {
          var itemModel = data.getItemModel(idx);
          var itemSymbolType = itemModel.getShallow('symbol', true);
          var itemSymbolSize = itemModel.getShallow('symbolSize', true);
          var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol

          if (itemSymbolType != null) {
            data.setItemVisual(idx, 'symbol', itemSymbolType);
          }

          if (itemSymbolSize != null) {
            // PENDING Transform symbolSize ?
            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
          }

          if (itemSymbolKeepAspect != null) {
            data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);
          }
        }
      }

      return {
        dataEach: data.hasItemOption || hasCallback ? dataEach : null
      };
    }
  };
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-7111f11b\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/index/user_transfer.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "user_transfer" }, [
      _c("div", {
        staticStyle: { width: "100%", height: "500px" },
        attrs: { id: "user_transfer" }
      })
    ])
  }
]
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7111f11b", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/zrender/lib/Element.js":
/***/ (function(module, exports, __webpack_require__) {

var guid = __webpack_require__("./node_modules/zrender/lib/core/guid.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var Transformable = __webpack_require__("./node_modules/zrender/lib/mixin/Transformable.js");

var Animatable = __webpack_require__("./node_modules/zrender/lib/mixin/Animatable.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

/**
 * @alias module:zrender/Element
 * @constructor
 * @extends {module:zrender/mixin/Animatable}
 * @extends {module:zrender/mixin/Transformable}
 * @extends {module:zrender/mixin/Eventful}
 */
var Element = function (opts) {
  // jshint ignore:line
  Transformable.call(this, opts);
  Eventful.call(this, opts);
  Animatable.call(this, opts);
  /**
   * 画布元素ID
   * @type {string}
   */

  this.id = opts.id || guid();
};

Element.prototype = {
  /**
   * 元素类型
   * Element type
   * @type {string}
   */
  type: 'element',

  /**
   * 元素名字
   * Element name
   * @type {string}
   */
  name: '',

  /**
   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
   * ZRender instance will be assigned when element is associated with zrender
   * @name module:/zrender/Element#__zr
   * @type {module:zrender/ZRender}
   */
  __zr: null,

  /**
   * 图形是否忽略，为true时忽略图形的绘制以及事件触发
   * If ignore drawing and events of the element object
   * @name module:/zrender/Element#ignore
   * @type {boolean}
   * @default false
   */
  ignore: false,

  /**
   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
   * 该路径会继承被裁减对象的变换
   * @type {module:zrender/graphic/Path}
   * @see http://www.w3.org/TR/2dcontext/#clipping-region
   * @readOnly
   */
  clipPath: null,

  /**
   * 是否是 Group
   * @type {boolean}
   */
  isGroup: false,

  /**
   * Drift element
   * @param  {number} dx dx on the global space
   * @param  {number} dy dy on the global space
   */
  drift: function (dx, dy) {
    switch (this.draggable) {
      case 'horizontal':
        dy = 0;
        break;

      case 'vertical':
        dx = 0;
        break;
    }

    var m = this.transform;

    if (!m) {
      m = this.transform = [1, 0, 0, 1, 0, 0];
    }

    m[4] += dx;
    m[5] += dy;
    this.decomposeTransform();
    this.dirty(false);
  },

  /**
   * Hook before update
   */
  beforeUpdate: function () {},

  /**
   * Hook after update
   */
  afterUpdate: function () {},

  /**
   * Update each frame
   */
  update: function () {
    this.updateTransform();
  },

  /**
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {},

  /**
   * @protected
   */
  attrKV: function (key, value) {
    if (key === 'position' || key === 'scale' || key === 'origin') {
      // Copy the array
      if (value) {
        var target = this[key];

        if (!target) {
          target = this[key] = [];
        }

        target[0] = value[0];
        target[1] = value[1];
      }
    } else {
      this[key] = value;
    }
  },

  /**
   * Hide the element
   */
  hide: function () {
    this.ignore = true;
    this.__zr && this.__zr.refresh();
  },

  /**
   * Show the element
   */
  show: function () {
    this.ignore = false;
    this.__zr && this.__zr.refresh();
  },

  /**
   * @param {string|Object} key
   * @param {*} value
   */
  attr: function (key, value) {
    if (typeof key === 'string') {
      this.attrKV(key, value);
    } else if (zrUtil.isObject(key)) {
      for (var name in key) {
        if (key.hasOwnProperty(name)) {
          this.attrKV(name, key[name]);
        }
      }
    }

    this.dirty(false);
    return this;
  },

  /**
   * @param {module:zrender/graphic/Path} clipPath
   */
  setClipPath: function (clipPath) {
    var zr = this.__zr;

    if (zr) {
      clipPath.addSelfToZr(zr);
    } // Remove previous clip path


    if (this.clipPath && this.clipPath !== clipPath) {
      this.removeClipPath();
    }

    this.clipPath = clipPath;
    clipPath.__zr = zr;
    clipPath.__clipTarget = this;
    this.dirty(false);
  },

  /**
   */
  removeClipPath: function () {
    var clipPath = this.clipPath;

    if (clipPath) {
      if (clipPath.__zr) {
        clipPath.removeSelfFromZr(clipPath.__zr);
      }

      clipPath.__zr = null;
      clipPath.__clipTarget = null;
      this.clipPath = null;
      this.dirty(false);
    }
  },

  /**
   * Add self from zrender instance.
   * Not recursively because it will be invoked when element added to storage.
   * @param {module:zrender/ZRender} zr
   */
  addSelfToZr: function (zr) {
    this.__zr = zr; // 添加动画

    var animators = this.animators;

    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.addAnimator(animators[i]);
      }
    }

    if (this.clipPath) {
      this.clipPath.addSelfToZr(zr);
    }
  },

  /**
   * Remove self from zrender instance.
   * Not recursively because it will be invoked when element added to storage.
   * @param {module:zrender/ZRender} zr
   */
  removeSelfFromZr: function (zr) {
    this.__zr = null; // 移除动画

    var animators = this.animators;

    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.removeAnimator(animators[i]);
      }
    }

    if (this.clipPath) {
      this.clipPath.removeSelfFromZr(zr);
    }
  }
};
zrUtil.mixin(Element, Animatable);
zrUtil.mixin(Element, Transformable);
zrUtil.mixin(Element, Eventful);
var _default = Element;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/Handler.js":
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var Draggable = __webpack_require__("./node_modules/zrender/lib/mixin/Draggable.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var SILENT = 'silent';

function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event: event,
    // target can only be an element that is not silent.
    target: targetInfo.target,
    // topTarget can be a silent element.
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which
  };
}

function EmptyProxy() {}

EmptyProxy.prototype.dispose = function () {};

var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
/**
 * @alias module:zrender/Handler
 * @constructor
 * @extends module:zrender/mixin/Eventful
 * @param {module:zrender/Storage} storage Storage instance.
 * @param {module:zrender/Painter} painter Painter instance.
 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
 */

var Handler = function (storage, painter, proxy, painterRoot) {
  Eventful.call(this);
  this.storage = storage;
  this.painter = painter;
  this.painterRoot = painterRoot;
  proxy = proxy || new EmptyProxy();
  /**
   * Proxy of event. can be Dom, WebGLSurface, etc.
   */

  this.proxy = null;
  /**
   * {target, topTarget, x, y}
   * @private
   * @type {Object}
   */

  this._hovered = {};
  /**
   * @private
   * @type {Date}
   */

  this._lastTouchMoment;
  /**
   * @private
   * @type {number}
   */

  this._lastX;
  /**
   * @private
   * @type {number}
   */

  this._lastY;
  Draggable.call(this);
  this.setHandlerProxy(proxy);
};

Handler.prototype = {
  constructor: Handler,
  setHandlerProxy: function (proxy) {
    if (this.proxy) {
      this.proxy.dispose();
    }

    if (proxy) {
      util.each(handlerNames, function (name) {
        proxy.on && proxy.on(name, this[name], this);
      }, this); // Attach handler

      proxy.handler = this;
    }

    this.proxy = proxy;
  },
  mousemove: function (event) {
    var x = event.zrX;
    var y = event.zrY;
    var lastHovered = this._hovered;
    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
    // (like 'setOption' or 'dispatchAction') in event handlers, we should find
    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
    // See #6198.

    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }

    var hovered = this._hovered = this.findHover(x, y);
    var hoveredTarget = hovered.target;
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element

    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, 'mouseout', event);
    } // Mouse moving on one element


    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element

    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, 'mouseover', event);
    }
  },
  mouseout: function (event) {
    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application
    // at the same level of painter.getViewportRoot() (e.g., tooltip
    // dom created by echarts), where 'globalout' event should not
    // be triggered when mouse enters these doms. (But 'mouseout'
    // should be triggered at the original hovered element as usual).

    var element = event.toElement || event.relatedTarget;
    var innerDom;

    do {
      element = element && element.parentNode;
    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));

    !innerDom && this.trigger('globalout', {
      event: event
    });
  },

  /**
   * Resize
   */
  resize: function (event) {
    this._hovered = {};
  },

  /**
   * Dispatch event
   * @param {string} eventName
   * @param {event=} eventArgs
   */
  dispatch: function (eventName, eventArgs) {
    var handler = this[eventName];
    handler && handler.call(this, eventArgs);
  },

  /**
   * Dispose
   */
  dispose: function () {
    this.proxy.dispose();
    this.storage = this.proxy = this.painter = null;
  },

  /**
   * 设置默认的cursor style
   * @param {string} [cursorStyle='default'] 例如 crosshair
   */
  setCursorStyle: function (cursorStyle) {
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  },

  /**
   * 事件分发代理
   *
   * @private
   * @param {Object} targetInfo {target, topTarget} 目标图形元素
   * @param {string} eventName 事件名称
   * @param {Object} event 事件对象
   */
  dispatchToElement: function (targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    var el = targetInfo.target;

    if (el && el.silent) {
      return;
    }

    var eventHandler = 'on' + eventName;
    var eventPacket = makeEventPacket(eventName, targetInfo, event);

    while (el) {
      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.parent;

      if (eventPacket.cancelBubble) {
        break;
      }
    }

    if (!eventPacket.cancelBubble) {
      // 冒泡到顶级 zrender 对象
      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在

      this.painter && this.painter.eachOtherLayer(function (layer) {
        if (typeof layer[eventHandler] == 'function') {
          layer[eventHandler].call(layer, eventPacket);
        }

        if (layer.trigger) {
          layer.trigger(eventName, eventPacket);
        }
      });
    }
  },

  /**
   * @private
   * @param {number} x
   * @param {number} y
   * @param {module:zrender/graphic/Displayable} exclude
   * @return {model:zrender/Element}
   * @method
   */
  findHover: function (x, y, exclude) {
    var list = this.storage.getDisplayList();
    var out = {
      x: x,
      y: y
    };

    for (var i = list.length - 1; i >= 0; i--) {
      var hoverCheckResult;

      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
        !out.topTarget && (out.topTarget = list[i]);

        if (hoverCheckResult !== SILENT) {
          out.target = list[i];
          break;
        }
      }
    }

    return out;
  }
}; // Common handlers

util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
  Handler.prototype[name] = function (event) {
    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
    var hovered = this.findHover(event.zrX, event.zrY);
    var hoveredTarget = hovered.target;

    if (name === 'mousedown') {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup

      this._upEl = hoveredTarget;
    } else if (name === 'mouseup') {
      this._upEl = hoveredTarget;
    } else if (name === 'click') {
      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
      // including the case that `mousedown` - `mousemove` - `mouseup`,
      // which should be filtered, otherwise it will bring trouble to
      // pan and zoom.
      || !this._downPoint // Arbitrary value
      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }

      this._downPoint = null;
    }

    this.dispatchToElement(hovered, name, event);
  };
});

function isHover(displayable, x, y) {
  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
    var el = displayable;
    var isSilent;

    while (el) {
      // If clipped by ancestor.
      // FIXME: If clipPath has neither stroke nor fill,
      // el.clipPath.contain(x, y) will always return false.
      if (el.clipPath && !el.clipPath.contain(x, y)) {
        return false;
      }

      if (el.silent) {
        isSilent = true;
      }

      el = el.parent;
    }

    return isSilent ? SILENT : true;
  }

  return false;
}

util.mixin(Handler, Eventful);
util.mixin(Handler, Draggable);
var _default = Handler;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/Layer.js":
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _config = __webpack_require__("./node_modules/zrender/lib/config.js");

var devicePixelRatio = _config.devicePixelRatio;

var Style = __webpack_require__("./node_modules/zrender/lib/graphic/Style.js");

var Pattern = __webpack_require__("./node_modules/zrender/lib/graphic/Pattern.js");

/**
 * @module zrender/Layer
 * @author pissang(https://www.github.com/pissang)
 */
function returnFalse() {
  return false;
}
/**
 * 创建dom
 *
 * @inner
 * @param {string} id dom id 待用
 * @param {Painter} painter painter instance
 * @param {number} number
 */


function createDom(id, painter, dpr) {
  var newDom = util.createCanvas();
  var width = painter.getWidth();
  var height = painter.getHeight();
  var newDomStyle = newDom.style;

  if (newDomStyle) {
    // In node or some other non-browser environment
    newDomStyle.position = 'absolute';
    newDomStyle.left = 0;
    newDomStyle.top = 0;
    newDomStyle.width = width + 'px';
    newDomStyle.height = height + 'px';
    newDom.setAttribute('data-zr-dom-id', id);
  }

  newDom.width = width * dpr;
  newDom.height = height * dpr;
  return newDom;
}
/**
 * @alias module:zrender/Layer
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @param {string} id
 * @param {module:zrender/Painter} painter
 * @param {number} [dpr]
 */


var Layer = function (id, painter, dpr) {
  var dom;
  dpr = dpr || devicePixelRatio;

  if (typeof id === 'string') {
    dom = createDom(id, painter, dpr);
  } // Not using isDom because in node it will return false
  else if (util.isObject(id)) {
      dom = id;
      id = dom.id;
    }

  this.id = id;
  this.dom = dom;
  var domStyle = dom.style;

  if (domStyle) {
    // Not in node
    dom.onselectstart = returnFalse; // 避免页面选中的尴尬

    domStyle['-webkit-user-select'] = 'none';
    domStyle['user-select'] = 'none';
    domStyle['-webkit-touch-callout'] = 'none';
    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
    domStyle['padding'] = 0;
    domStyle['margin'] = 0;
    domStyle['border-width'] = 0;
  }

  this.domBack = null;
  this.ctxBack = null;
  this.painter = painter;
  this.config = null; // Configs

  /**
   * 每次清空画布的颜色
   * @type {string}
   * @default 0
   */

  this.clearColor = 0;
  /**
   * 是否开启动态模糊
   * @type {boolean}
   * @default false
   */

  this.motionBlur = false;
  /**
   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
   * @type {number}
   * @default 0.7
   */

  this.lastFrameAlpha = 0.7;
  /**
   * Layer dpr
   * @type {number}
   */

  this.dpr = dpr;
};

Layer.prototype = {
  constructor: Layer,
  __dirty: true,
  __used: false,
  __drawIndex: 0,
  __startIndex: 0,
  __endIndex: 0,
  incremental: false,
  getElementCount: function () {
    return this.__endIndex - this.__startIndex;
  },
  initContext: function () {
    this.ctx = this.dom.getContext('2d');
    this.ctx.dpr = this.dpr;
  },
  createBackBuffer: function () {
    var dpr = this.dpr;
    this.domBack = createDom('back-' + this.id, this.painter, dpr);
    this.ctxBack = this.domBack.getContext('2d');

    if (dpr != 1) {
      this.ctxBack.scale(dpr, dpr);
    }
  },

  /**
   * @param  {number} width
   * @param  {number} height
   */
  resize: function (width, height) {
    var dpr = this.dpr;
    var dom = this.dom;
    var domStyle = dom.style;
    var domBack = this.domBack;

    if (domStyle) {
      domStyle.width = width + 'px';
      domStyle.height = height + 'px';
    }

    dom.width = width * dpr;
    dom.height = height * dpr;

    if (domBack) {
      domBack.width = width * dpr;
      domBack.height = height * dpr;

      if (dpr != 1) {
        this.ctxBack.scale(dpr, dpr);
      }
    }
  },

  /**
   * 清空该层画布
   * @param {boolean} [clearAll]=false Clear all with out motion blur
   * @param {Color} [clearColor]
   */
  clear: function (clearAll, clearColor) {
    var dom = this.dom;
    var ctx = this.ctx;
    var width = dom.width;
    var height = dom.height;
    var clearColor = clearColor || this.clearColor;
    var haveMotionBLur = this.motionBlur && !clearAll;
    var lastFrameAlpha = this.lastFrameAlpha;
    var dpr = this.dpr;

    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }

      this.ctxBack.globalCompositeOperation = 'copy';
      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
    }

    ctx.clearRect(0, 0, width, height);

    if (clearColor && clearColor !== 'transparent') {
      var clearColorGradientOrPattern; // Gradient

      if (clearColor.colorStops) {
        // Cache canvas gradient
        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
          x: 0,
          y: 0,
          width: width,
          height: height
        });
        clearColor.__canvasGradient = clearColorGradientOrPattern;
      } // Pattern
      else if (clearColor.image) {
          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
        }

      ctx.save();
      ctx.fillStyle = clearColorGradientOrPattern || clearColor;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    }

    if (haveMotionBLur) {
      var domBack = this.domBack;
      ctx.save();
      ctx.globalAlpha = lastFrameAlpha;
      ctx.drawImage(domBack, 0, 0, width, height);
      ctx.restore();
    }
  }
};
var _default = Layer;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/Painter.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/zrender/lib/config.js");

var devicePixelRatio = _config.devicePixelRatio;

var util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var log = __webpack_require__("./node_modules/zrender/lib/core/log.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var timsort = __webpack_require__("./node_modules/zrender/lib/core/timsort.js");

var Layer = __webpack_require__("./node_modules/zrender/lib/Layer.js");

var requestAnimationFrame = __webpack_require__("./node_modules/zrender/lib/animation/requestAnimationFrame.js");

var Image = __webpack_require__("./node_modules/zrender/lib/graphic/Image.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 0.001;

function parseInt10(val) {
  return parseInt(val, 10);
}

function isLayerValid(layer) {
  if (!layer) {
    return false;
  }

  if (layer.__builtin__) {
    return true;
  }

  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
    return false;
  }

  return true;
}

var tmpRect = new BoundingRect(0, 0, 0, 0);
var viewRect = new BoundingRect(0, 0, 0, 0);

function isDisplayableCulled(el, width, height) {
  tmpRect.copy(el.getBoundingRect());

  if (el.transform) {
    tmpRect.applyTransform(el.transform);
  }

  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect.intersect(viewRect);
}

function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths == prevClipPaths) {
    // Can both be null or undefined
    return false;
  }

  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }

  for (var i = 0; i < clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }
}

function doClip(clipPaths, ctx) {
  for (var i = 0; i < clipPaths.length; i++) {
    var clipPath = clipPaths[i];
    clipPath.setTransform(ctx);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip(); // Transform back

    clipPath.restoreTransform(ctx);
  }
}

function createRoot(width, height) {
  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬

  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
  return domRoot;
}
/**
 * @alias module:zrender/Painter
 * @constructor
 * @param {HTMLElement} root 绘图容器
 * @param {module:zrender/Storage} storage
 * @param {Object} opts
 */


var Painter = function (root, storage, opts) {
  this.type = 'canvas'; // In node environment using node-canvas

  var singleCanvas = !root.nodeName // In node ?
  || root.nodeName.toUpperCase() === 'CANVAS';
  this._opts = opts = util.extend({}, opts || {});
  /**
   * @type {number}
   */

  this.dpr = opts.devicePixelRatio || devicePixelRatio;
  /**
   * @type {boolean}
   * @private
   */

  this._singleCanvas = singleCanvas;
  /**
   * 绘图容器
   * @type {HTMLElement}
   */

  this.root = root;
  var rootStyle = root.style;

  if (rootStyle) {
    rootStyle['-webkit-tap-highlight-color'] = 'transparent';
    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
    root.innerHTML = '';
  }
  /**
   * @type {module:zrender/Storage}
   */


  this.storage = storage;
  /**
   * @type {Array.<number>}
   * @private
   */

  var zlevelList = this._zlevelList = [];
  /**
   * @type {Object.<string, module:zrender/Layer>}
   * @private
   */

  var layers = this._layers = {};
  /**
   * @type {Object.<string, Object>}
   * @private
   */

  this._layerConfig = {};
  /**
   * zrender will do compositing when root is a canvas and have multiple zlevels.
   */

  this._needsManuallyCompositing = false;

  if (!singleCanvas) {
    this._width = this._getSize(0);
    this._height = this._getSize(1);
    var domRoot = this._domRoot = createRoot(this._width, this._height);
    root.appendChild(domRoot);
  } else {
    var width = root.width;
    var height = root.height;

    if (opts.width != null) {
      width = opts.width;
    }

    if (opts.height != null) {
      height = opts.height;
    }

    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly

    root.width = width * this.dpr;
    root.height = height * this.dpr;
    this._width = width;
    this._height = height; // Create layer if only one given canvas
    // Device can be specified to create a high dpi image.

    var mainLayer = new Layer(root, this, this.dpr);
    mainLayer.__builtin__ = true;
    mainLayer.initContext(); // FIXME Use canvas width and height
    // mainLayer.resize(width, height);

    layers[CANVAS_ZLEVEL] = mainLayer;
    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.

    zlevelList.push(CANVAS_ZLEVEL);
    this._domRoot = root;
  }
  /**
   * @type {module:zrender/Layer}
   * @private
   */


  this._hoverlayer = null;
  this._hoverElements = [];
};

Painter.prototype = {
  constructor: Painter,
  getType: function () {
    return 'canvas';
  },

  /**
   * If painter use a single canvas
   * @return {boolean}
   */
  isSingleCanvas: function () {
    return this._singleCanvas;
  },

  /**
   * @return {HTMLDivElement}
   */
  getViewportRoot: function () {
    return this._domRoot;
  },
  getViewportRootOffset: function () {
    var viewportRoot = this.getViewportRoot();

    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  },

  /**
   * 刷新
   * @param {boolean} [paintAll=false] 强制绘制所有displayable
   */
  refresh: function (paintAll) {
    var list = this.storage.getDisplayList(true);
    var zlevelList = this._zlevelList;
    this._redrawId = Math.random();

    this._paintList(list, paintAll, this._redrawId); // Paint custum layers


    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];

      if (!layer.__builtin__ && layer.refresh) {
        var clearColor = i === 0 ? this._backgroundColor : null;
        layer.refresh(clearColor);
      }
    }

    this.refreshHover();
    return this;
  },
  addHover: function (el, hoverStyle) {
    if (el.__hoverMir) {
      return;
    }

    var elMirror = new el.constructor({
      style: el.style,
      shape: el.shape
    });
    elMirror.__from = el;
    el.__hoverMir = elMirror;
    elMirror.setStyle(hoverStyle);

    this._hoverElements.push(elMirror);
  },
  removeHover: function (el) {
    var elMirror = el.__hoverMir;
    var hoverElements = this._hoverElements;
    var idx = util.indexOf(hoverElements, elMirror);

    if (idx >= 0) {
      hoverElements.splice(idx, 1);
    }

    el.__hoverMir = null;
  },
  clearHover: function (el) {
    var hoverElements = this._hoverElements;

    for (var i = 0; i < hoverElements.length; i++) {
      var from = hoverElements[i].__from;

      if (from) {
        from.__hoverMir = null;
      }
    }

    hoverElements.length = 0;
  },
  refreshHover: function () {
    var hoverElements = this._hoverElements;
    var len = hoverElements.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();

    if (!len) {
      return;
    }

    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
    // FIXME?

    if (!hoverLayer) {
      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
    }

    var scope = {};
    hoverLayer.ctx.save();

    for (var i = 0; i < len;) {
      var el = hoverElements[i];
      var originalEl = el.__from; // Original el is removed
      // PENDING

      if (!(originalEl && originalEl.__zr)) {
        hoverElements.splice(i, 1);
        originalEl.__hoverMir = null;
        len--;
        continue;
      }

      i++; // Use transform
      // FIXME style and shape ?

      if (!originalEl.invisible) {
        el.transform = originalEl.transform;
        el.invTransform = originalEl.invTransform;
        el.__clipPaths = originalEl.__clipPaths; // el.

        this._doPaintEl(el, hoverLayer, true, scope);
      }
    }

    hoverLayer.ctx.restore();
  },
  getHoverLayer: function () {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  },
  _paintList: function (list, paintAll, redrawId) {
    if (this._redrawId !== redrawId) {
      return;
    }

    paintAll = paintAll || false;

    this._updateLayerStatus(list);

    var finished = this._doPaintList(list, paintAll);

    if (this._needsManuallyCompositing) {
      this._compositeManually();
    }

    if (!finished) {
      var self = this;
      requestAnimationFrame(function () {
        self._paintList(list, paintAll, redrawId);
      });
    }
  },
  _compositeManually: function () {
    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
    var width = this._domRoot.width;
    var height = this._domRoot.height;
    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?

    this.eachBuiltinLayer(function (layer) {
      if (layer.virtual) {
        ctx.drawImage(layer.dom, 0, 0, width, height);
      }
    });
  },
  _doPaintList: function (list, paintAll) {
    var layerList = [];

    for (var zi = 0; zi < this._zlevelList.length; zi++) {
      var zlevel = this._zlevelList[zi];
      var layer = this._layers[zlevel];

      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
        layerList.push(layer);
      }
    }

    var finished = true;

    for (var k = 0; k < layerList.length; k++) {
      var layer = layerList[k];
      var ctx = layer.ctx;
      var scope = {};
      ctx.save();
      var start = paintAll ? layer.__startIndex : layer.__drawIndex;
      var useTimer = !paintAll && layer.incremental && Date.now;
      var startTime = useTimer && Date.now();
      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.

      if (layer.__startIndex === layer.__endIndex) {
        layer.clear(false, clearColor);
      } else if (start === layer.__startIndex) {
        var firstEl = list[start];

        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          layer.clear(false, clearColor);
        }
      }

      if (start === -1) {
        console.error('For some unknown reason. drawIndex is -1');
        start = layer.__startIndex;
      }

      for (var i = start; i < layer.__endIndex; i++) {
        var el = list[i];

        this._doPaintEl(el, layer, paintAll, scope);

        el.__dirty = false;

        if (useTimer) {
          // Date.now can be executed in 13,025,305 ops/second.
          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.
          // The rest elements will be drawn in the next frame.

          if (dTime > 15) {
            break;
          }
        }
      }

      layer.__drawIndex = i;

      if (layer.__drawIndex < layer.__endIndex) {
        finished = false;
      }

      if (scope.prevElClipPaths) {
        // Needs restore the state. If last drawn element is in the clipping area.
        ctx.restore();
      }

      ctx.restore();
    }

    if (env.wxa) {
      // Flush for weixin application
      util.each(this._layers, function (layer) {
        if (layer && layer.ctx && layer.ctx.draw) {
          layer.ctx.draw();
        }
      });
    }

    return finished;
  },
  _doPaintEl: function (el, currentLayer, forcePaint, scope) {
    var ctx = currentLayer.ctx;
    var m = el.transform;

    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
    !el.invisible // Ignore transparent element
    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
    // Draw a scale 0 element can cause all following draw wrong
    // And setTransform with scale 0 will cause set back transform failed.
    && !(m && !m[0] && !m[3]) // Ignore culled element
    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements

      if (!scope.prevElClipPaths || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
        // If has previous clipping state, restore from it
        if (scope.prevElClipPaths) {
          currentLayer.ctx.restore();
          scope.prevElClipPaths = null; // Reset prevEl since context has been restored

          scope.prevEl = null;
        } // New clipping state


        if (clipPaths) {
          ctx.save();
          doClip(clipPaths, ctx);
          scope.prevElClipPaths = clipPaths;
        }
      }

      el.beforeBrush && el.beforeBrush(ctx);
      el.brush(ctx, scope.prevEl || null);
      scope.prevEl = el;
      el.afterBrush && el.afterBrush(ctx);
    }
  },

  /**
   * 获取 zlevel 所在层，如果不存在则会创建一个新的层
   * @param {number} zlevel
   * @param {boolean} virtual Virtual layer will not be inserted into dom.
   * @return {module:zrender/Layer}
   */
  getLayer: function (zlevel, virtual) {
    if (this._singleCanvas && !this._needsManuallyCompositing) {
      zlevel = CANVAS_ZLEVEL;
    }

    var layer = this._layers[zlevel];

    if (!layer) {
      // Create a new layer
      layer = new Layer('zr_' + zlevel, this, this.dpr);
      layer.zlevel = zlevel;
      layer.__builtin__ = true;

      if (this._layerConfig[zlevel]) {
        util.merge(layer, this._layerConfig[zlevel], true);
      }

      if (virtual) {
        layer.virtual = virtual;
      }

      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
      // Or excanvas will get 0px clientWidth and clientHeight

      layer.initContext();
    }

    return layer;
  },
  insertLayer: function (zlevel, layer) {
    var layersMap = this._layers;
    var zlevelList = this._zlevelList;
    var len = zlevelList.length;
    var prevLayer = null;
    var i = -1;
    var domRoot = this._domRoot;

    if (layersMap[zlevel]) {
      log('ZLevel ' + zlevel + ' has been used already');
      return;
    } // Check if is a valid layer


    if (!isLayerValid(layer)) {
      log('Layer of zlevel ' + zlevel + ' is not valid');
      return;
    }

    if (len > 0 && zlevel > zlevelList[0]) {
      for (i = 0; i < len - 1; i++) {
        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
          break;
        }
      }

      prevLayer = layersMap[zlevelList[i]];
    }

    zlevelList.splice(i + 1, 0, zlevel);
    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
    // (It can be a WebGL layer and assigned to a ZImage element)
    // But it still under management of zrender.

    if (!layer.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;

        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
  },
  // Iterate each layer
  eachLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  },
  // Iterate each buildin layer
  eachBuiltinLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var layer;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      layer = this._layers[z];

      if (layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },
  // Iterate each other layer except buildin layer
  eachOtherLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var layer;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      layer = this._layers[z];

      if (!layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },

  /**
   * 获取所有已创建的层
   * @param {Array.<module:zrender/Layer>} [prevLayer]
   */
  getLayers: function () {
    return this._layers;
  },
  _updateLayerStatus: function (list) {
    this.eachBuiltinLayer(function (layer, z) {
      layer.__dirty = layer.__used = false;
    });

    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }

        prevLayer.__endIndex = idx;
      }
    }

    if (this._singleCanvas) {
      for (var i = 1; i < list.length; i++) {
        var el = list[i];

        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }

    var prevLayer = null;
    var incrementalLayerCount = 0;

    for (var i = 0; i < list.length; i++) {
      var el = list[i];
      var zlevel = el.zlevel;
      var layer; // PENDING If change one incremental element style ?
      // TODO Where there are non-incremental elements between incremental elements.

      if (el.incremental) {
        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }

      if (!layer.__builtin__) {
        log('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);
      }

      if (layer !== prevLayer) {
        layer.__used = true;

        if (layer.__startIndex !== i) {
          layer.__dirty = true;
        }

        layer.__startIndex = i;

        if (!layer.incremental) {
          layer.__drawIndex = i;
        } else {
          // Mark layer draw index needs to update.
          layer.__drawIndex = -1;
        }

        updatePrevLayer(i);
        prevLayer = layer;
      }

      if (el.__dirty) {
        layer.__dirty = true;

        if (layer.incremental && layer.__drawIndex < 0) {
          // Start draw from the first dirty element.
          layer.__drawIndex = i;
        }
      }
    }

    updatePrevLayer(i);
    this.eachBuiltinLayer(function (layer, z) {
      // Used in last frame but not in this frame. Needs clear
      if (!layer.__used && layer.getElementCount() > 0) {
        layer.__dirty = true;
        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;
      } // For incremental layer. In case start index changed and no elements are dirty.


      if (layer.__dirty && layer.__drawIndex < 0) {
        layer.__drawIndex = layer.__startIndex;
      }
    });
  },

  /**
   * 清除hover层外所有内容
   */
  clear: function () {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  },
  _clearLayer: function (layer) {
    layer.clear();
  },
  setBackgroundColor: function (backgroundColor) {
    this._backgroundColor = backgroundColor;
  },

  /**
   * 修改指定zlevel的绘制参数
   *
   * @param {string} zlevel
   * @param {Object} config 配置对象
   * @param {string} [config.clearColor=0] 每次清空画布的颜色
   * @param {string} [config.motionBlur=false] 是否开启动态模糊
   * @param {number} [config.lastFrameAlpha=0.7]
   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
   */
  configLayer: function (zlevel, config) {
    if (config) {
      var layerConfig = this._layerConfig;

      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config;
      } else {
        util.merge(layerConfig[zlevel], config, true);
      }

      for (var i = 0; i < this._zlevelList.length; i++) {
        var _zlevel = this._zlevelList[i];

        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
          var layer = this._layers[_zlevel];
          util.merge(layer, layerConfig[zlevel], true);
        }
      }
    }
  },

  /**
   * 删除指定层
   * @param {number} zlevel 层所在的zlevel
   */
  delLayer: function (zlevel) {
    var layers = this._layers;
    var zlevelList = this._zlevelList;
    var layer = layers[zlevel];

    if (!layer) {
      return;
    }

    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
  },

  /**
   * 区域大小变化后重绘
   */
  resize: function (width, height) {
    if (!this._domRoot.style) {
      // Maybe in node or worker
      if (width == null || height == null) {
        return;
      }

      this._width = width;
      this._height = height;
      this.getLayer(CANVAS_ZLEVEL).resize(width, height);
    } else {
      var domRoot = this._domRoot; // FIXME Why ?

      domRoot.style.display = 'none'; // Save input w/h

      var opts = this._opts;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      width = this._getSize(0);
      height = this._getSize(1);
      domRoot.style.display = ''; // 优化没有实际改变的resize

      if (this._width != width || height != this._height) {
        domRoot.style.width = width + 'px';
        domRoot.style.height = height + 'px';

        for (var id in this._layers) {
          if (this._layers.hasOwnProperty(id)) {
            this._layers[id].resize(width, height);
          }
        }

        util.each(this._progressiveLayers, function (layer) {
          layer.resize(width, height);
        });
        this.refresh(true);
      }

      this._width = width;
      this._height = height;
    }

    return this;
  },

  /**
   * 清除单独的一个层
   * @param {number} zlevel
   */
  clearLayer: function (zlevel) {
    var layer = this._layers[zlevel];

    if (layer) {
      layer.clear();
    }
  },

  /**
   * 释放
   */
  dispose: function () {
    this.root.innerHTML = '';
    this.root = this.storage = this._domRoot = this._layers = null;
  },

  /**
   * Get canvas which has all thing rendered
   * @param {Object} opts
   * @param {string} [opts.backgroundColor]
   * @param {number} [opts.pixelRatio]
   */
  getRenderedCanvas: function (opts) {
    opts = opts || {};

    if (this._singleCanvas && !this._compositeManually) {
      return this._layers[CANVAS_ZLEVEL].dom;
    }

    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);

    if (opts.pixelRatio <= this.dpr) {
      this.refresh();
      var width = imageLayer.dom.width;
      var height = imageLayer.dom.height;
      var ctx = imageLayer.ctx;
      this.eachLayer(function (layer) {
        if (layer.__builtin__) {
          ctx.drawImage(layer.dom, 0, 0, width, height);
        } else if (layer.renderToCanvas) {
          imageLayer.ctx.save();
          layer.renderToCanvas(imageLayer.ctx);
          imageLayer.ctx.restore();
        }
      });
    } else {
      // PENDING, echarts-gl and incremental rendering.
      var scope = {};
      var displayList = this.storage.getDisplayList(true);

      for (var i = 0; i < displayList.length; i++) {
        var el = displayList[i];

        this._doPaintEl(el, imageLayer, true, scope);
      }
    }

    return imageLayer.dom;
  },

  /**
   * 获取绘图区域宽度
   */
  getWidth: function () {
    return this._width;
  },

  /**
   * 获取绘图区域高度
   */
  getHeight: function () {
    return this._height;
  },
  _getSize: function (whIdx) {
    var opts = this._opts;
    var wh = ['width', 'height'][whIdx];
    var cwh = ['clientWidth', 'clientHeight'][whIdx];
    var plt = ['paddingLeft', 'paddingTop'][whIdx];
    var prb = ['paddingRight', 'paddingBottom'][whIdx];

    if (opts[wh] != null && opts[wh] !== 'auto') {
      return parseFloat(opts[wh]);
    }

    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.

    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
  },
  pathToImage: function (path, dpr) {
    dpr = dpr || this.dpr;
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var rect = path.getBoundingRect();
    var style = path.style;
    var shadowBlurSize = style.shadowBlur * dpr;
    var shadowOffsetX = style.shadowOffsetX * dpr;
    var shadowOffsetY = style.shadowOffsetY * dpr;
    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
    var width = rect.width + leftMargin + rightMargin;
    var height = rect.height + topMargin + bottomMargin;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, width, height);
    ctx.dpr = dpr;
    var pathTransform = {
      position: path.position,
      rotation: path.rotation,
      scale: path.scale
    };
    path.position = [leftMargin - rect.x, topMargin - rect.y];
    path.rotation = 0;
    path.scale = [1, 1];
    path.updateTransform();

    if (path) {
      path.brush(ctx);
    }

    var ImageShape = Image;
    var imgShape = new ImageShape({
      style: {
        x: 0,
        y: 0,
        image: canvas
      }
    });

    if (pathTransform.position != null) {
      imgShape.position = path.position = pathTransform.position;
    }

    if (pathTransform.rotation != null) {
      imgShape.rotation = path.rotation = pathTransform.rotation;
    }

    if (pathTransform.scale != null) {
      imgShape.scale = path.scale = pathTransform.scale;
    }

    return imgShape;
  }
};
var _default = Painter;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/Storage.js":
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var Group = __webpack_require__("./node_modules/zrender/lib/container/Group.js");

var timsort = __webpack_require__("./node_modules/zrender/lib/core/timsort.js");

// Use timsort because in most case elements are partially sorted
// https://jsfiddle.net/pissang/jr4x7mdm/8/
function shapeCompareFunc(a, b) {
  if (a.zlevel === b.zlevel) {
    if (a.z === b.z) {
      // if (a.z2 === b.z2) {
      //     // FIXME Slow has renderidx compare
      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
      //     return a.__renderidx - b.__renderidx;
      // }
      return a.z2 - b.z2;
    }

    return a.z - b.z;
  }

  return a.zlevel - b.zlevel;
}
/**
 * 内容仓库 (M)
 * @alias module:zrender/Storage
 * @constructor
 */


var Storage = function () {
  // jshint ignore:line
  this._roots = [];
  this._displayList = [];
  this._displayListLen = 0;
};

Storage.prototype = {
  constructor: Storage,

  /**
   * @param  {Function} cb
   *
   */
  traverse: function (cb, context) {
    for (var i = 0; i < this._roots.length; i++) {
      this._roots[i].traverse(cb, context);
    }
  },

  /**
   * 返回所有图形的绘制队列
   * @param {boolean} [update=false] 是否在返回前更新该数组
   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
   *
   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
   * @return {Array.<module:zrender/graphic/Displayable>}
   */
  getDisplayList: function (update, includeIgnore) {
    includeIgnore = includeIgnore || false;

    if (update) {
      this.updateDisplayList(includeIgnore);
    }

    return this._displayList;
  },

  /**
   * 更新图形的绘制队列。
   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
   */
  updateDisplayList: function (includeIgnore) {
    this._displayListLen = 0;
    var roots = this._roots;
    var displayList = this._displayList;

    for (var i = 0, len = roots.length; i < len; i++) {
      this._updateAndAddDisplayable(roots[i], null, includeIgnore);
    }

    displayList.length = this._displayListLen;
    env.canvasSupported && timsort(displayList, shapeCompareFunc);
  },
  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }

    el.beforeUpdate();

    if (el.__dirty) {
      el.update();
    }

    el.afterUpdate();
    var userSetClipPath = el.clipPath;

    if (userSetClipPath) {
      // FIXME 效率影响
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }

      var currentClipPath = userSetClipPath;
      var parentClipPath = el; // Recursively add clip path

      while (currentClipPath) {
        // clipPath 的变换是基于使用这个 clipPath 的元素
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.clipPath;
      }
    }

    if (el.isGroup) {
      var children = el._children;

      for (var i = 0; i < children.length; i++) {
        var child = children[i]; // Force to mark as dirty if group is dirty
        // FIXME __dirtyPath ?

        if (el.__dirty) {
          child.__dirty = true;
        }

        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      } // Mark group clean here


      el.__dirty = false;
    } else {
      el.__clipPaths = clipPaths;
      this._displayList[this._displayListLen++] = el;
    }
  },

  /**
   * 添加图形(Shape)或者组(Group)到根节点
   * @param {module:zrender/Element} el
   */
  addRoot: function (el) {
    if (el.__storage === this) {
      return;
    }

    if (el instanceof Group) {
      el.addChildrenToStorage(this);
    }

    this.addToStorage(el);

    this._roots.push(el);
  },

  /**
   * 删除指定的图形(Shape)或者组(Group)
   * @param {string|Array.<string>} [el] 如果为空清空整个Storage
   */
  delRoot: function (el) {
    if (el == null) {
      // 不指定el清空
      for (var i = 0; i < this._roots.length; i++) {
        var root = this._roots[i];

        if (root instanceof Group) {
          root.delChildrenFromStorage(this);
        }
      }

      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      return;
    }

    if (el instanceof Array) {
      for (var i = 0, l = el.length; i < l; i++) {
        this.delRoot(el[i]);
      }

      return;
    }

    var idx = util.indexOf(this._roots, el);

    if (idx >= 0) {
      this.delFromStorage(el);

      this._roots.splice(idx, 1);

      if (el instanceof Group) {
        el.delChildrenFromStorage(this);
      }
    }
  },
  addToStorage: function (el) {
    if (el) {
      el.__storage = this;
      el.dirty(false);
    }

    return this;
  },
  delFromStorage: function (el) {
    if (el) {
      el.__storage = null;
    }

    return this;
  },

  /**
   * 清空并且释放Storage
   */
  dispose: function () {
    this._renderList = this._roots = null;
  },
  displayableSortFunc: shapeCompareFunc
};
var _default = Storage;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/animation/Animation.js":
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var _event = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var Dispatcher = _event.Dispatcher;

var requestAnimationFrame = __webpack_require__("./node_modules/zrender/lib/animation/requestAnimationFrame.js");

var Animator = __webpack_require__("./node_modules/zrender/lib/animation/Animator.js");

/**
 * 动画主类, 调度和管理所有动画控制器
 *
 * @module zrender/animation/Animation
 * @author pissang(https://github.com/pissang)
 */
// TODO Additive animation
// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
// https://developer.apple.com/videos/wwdc2014/#236

/**
 * @typedef {Object} IZRenderStage
 * @property {Function} update
 */

/**
 * @alias module:zrender/animation/Animation
 * @constructor
 * @param {Object} [options]
 * @param {Function} [options.onframe]
 * @param {IZRenderStage} [options.stage]
 * @example
 *     var animation = new Animation();
 *     var obj = {
 *         x: 100,
 *         y: 100
 *     };
 *     animation.animate(node.position)
 *         .when(1000, {
 *             x: 500,
 *             y: 500
 *         })
 *         .when(2000, {
 *             x: 100,
 *             y: 100
 *         })
 *         .start('spline');
 */
var Animation = function (options) {
  options = options || {};
  this.stage = options.stage || {};

  this.onframe = options.onframe || function () {}; // private properties


  this._clips = [];
  this._running = false;
  this._time;
  this._pausedTime;
  this._pauseStart;
  this._paused = false;
  Dispatcher.call(this);
};

Animation.prototype = {
  constructor: Animation,

  /**
   * 添加 clip
   * @param {module:zrender/animation/Clip} clip
   */
  addClip: function (clip) {
    this._clips.push(clip);
  },

  /**
   * 添加 animator
   * @param {module:zrender/animation/Animator} animator
   */
  addAnimator: function (animator) {
    animator.animation = this;
    var clips = animator.getClips();

    for (var i = 0; i < clips.length; i++) {
      this.addClip(clips[i]);
    }
  },

  /**
   * 删除动画片段
   * @param {module:zrender/animation/Clip} clip
   */
  removeClip: function (clip) {
    var idx = util.indexOf(this._clips, clip);

    if (idx >= 0) {
      this._clips.splice(idx, 1);
    }
  },

  /**
   * 删除动画片段
   * @param {module:zrender/animation/Animator} animator
   */
  removeAnimator: function (animator) {
    var clips = animator.getClips();

    for (var i = 0; i < clips.length; i++) {
      this.removeClip(clips[i]);
    }

    animator.animation = null;
  },
  _update: function () {
    var time = new Date().getTime() - this._pausedTime;

    var delta = time - this._time;
    var clips = this._clips;
    var len = clips.length;
    var deferredEvents = [];
    var deferredClips = [];

    for (var i = 0; i < len; i++) {
      var clip = clips[i];
      var e = clip.step(time, delta); // Throw out the events need to be called after
      // stage.update, like destroy

      if (e) {
        deferredEvents.push(e);
        deferredClips.push(clip);
      }
    } // Remove the finished clip


    for (var i = 0; i < len;) {
      if (clips[i]._needsRemove) {
        clips[i] = clips[len - 1];
        clips.pop();
        len--;
      } else {
        i++;
      }
    }

    len = deferredEvents.length;

    for (var i = 0; i < len; i++) {
      deferredClips[i].fire(deferredEvents[i]);
    }

    this._time = time;
    this.onframe(delta); // 'frame' should be triggered before stage, because upper application
    // depends on the sequence (e.g., echarts-stream and finish
    // event judge)

    this.trigger('frame', delta);

    if (this.stage.update) {
      this.stage.update();
    }
  },
  _startLoop: function () {
    var self = this;
    this._running = true;

    function step() {
      if (self._running) {
        requestAnimationFrame(step);
        !self._paused && self._update();
      }
    }

    requestAnimationFrame(step);
  },

  /**
   * Start animation.
   */
  start: function () {
    this._time = new Date().getTime();
    this._pausedTime = 0;

    this._startLoop();
  },

  /**
   * Stop animation.
   */
  stop: function () {
    this._running = false;
  },

  /**
   * Pause animation.
   */
  pause: function () {
    if (!this._paused) {
      this._pauseStart = new Date().getTime();
      this._paused = true;
    }
  },

  /**
   * Resume animation.
   */
  resume: function () {
    if (this._paused) {
      this._pausedTime += new Date().getTime() - this._pauseStart;
      this._paused = false;
    }
  },

  /**
   * Clear animation.
   */
  clear: function () {
    this._clips = [];
  },

  /**
   * Whether animation finished.
   */
  isFinished: function () {
    return !this._clips.length;
  },

  /**
   * Creat animator for a target, whose props can be animated.
   *
   * @param  {Object} target
   * @param  {Object} options
   * @param  {boolean} [options.loop=false] Whether loop animation.
   * @param  {Function} [options.getter=null] Get value from target.
   * @param  {Function} [options.setter=null] Set value to target.
   * @return {module:zrender/animation/Animation~Animator}
   */
  // TODO Gap
  animate: function (target, options) {
    options = options || {};
    var animator = new Animator(target, options.loop, options.getter, options.setter);
    this.addAnimator(animator);
    return animator;
  }
};
util.mixin(Animation, Dispatcher);
var _default = Animation;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/animation/Animator.js":
/***/ (function(module, exports, __webpack_require__) {

var Clip = __webpack_require__("./node_modules/zrender/lib/animation/Clip.js");

var color = __webpack_require__("./node_modules/zrender/lib/tool/color.js");

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var isArrayLike = _util.isArrayLike;

/**
 * @module echarts/animation/Animator
 */
var arraySlice = Array.prototype.slice;

function defaultGetter(target, key) {
  return target[key];
}

function defaultSetter(target, key, value) {
  target[key] = value;
}
/**
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} percent
 * @return {number}
 */


function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
/**
 * @param  {string} p0
 * @param  {string} p1
 * @param  {number} percent
 * @return {string}
 */


function interpolateString(p0, p1, percent) {
  return percent > 0.5 ? p1 : p0;
}
/**
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {number} percent
 * @param  {Array} out
 * @param  {number} arrDim
 */


function interpolateArray(p0, p1, percent, out, arrDim) {
  var len = p0.length;

  if (arrDim == 1) {
    for (var i = 0; i < len; i++) {
      out[i] = interpolateNumber(p0[i], p1[i], percent);
    }
  } else {
    var len2 = len && p0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
      }
    }
  }
} // arr0 is source array, arr1 is target array.
// Do some preprocess to avoid error happened when interpolating from arr0 to arr1


function fillArr(arr0, arr1, arrDim) {
  var arr0Len = arr0.length;
  var arr1Len = arr1.length;

  if (arr0Len !== arr1Len) {
    // FIXME Not work for TypedArray
    var isPreviousLarger = arr0Len > arr1Len;

    if (isPreviousLarger) {
      // Cut the previous
      arr0.length = arr1Len;
    } else {
      // Fill the previous
      for (var i = arr0Len; i < arr1Len; i++) {
        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
      }
    }
  } // Handling NaN value


  var len2 = arr0[0] && arr0[0].length;

  for (var i = 0; i < arr0.length; i++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i])) {
        arr0[i] = arr1[i];
      }
    } else {
      for (var j = 0; j < len2; j++) {
        if (isNaN(arr0[i][j])) {
          arr0[i][j] = arr1[i][j];
        }
      }
    }
  }
}
/**
 * @param  {Array} arr0
 * @param  {Array} arr1
 * @param  {number} arrDim
 * @return {boolean}
 */


function isArraySame(arr0, arr1, arrDim) {
  if (arr0 === arr1) {
    return true;
  }

  var len = arr0.length;

  if (len !== arr1.length) {
    return false;
  }

  if (arrDim === 1) {
    for (var i = 0; i < len; i++) {
      if (arr0[i] !== arr1[i]) {
        return false;
      }
    }
  } else {
    var len2 = arr0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        if (arr0[i][j] !== arr1[i][j]) {
          return false;
        }
      }
    }
  }

  return true;
}
/**
 * Catmull Rom interpolate array
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @param  {Array} out
 * @param  {number} arrDim
 */


function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
  var len = p0.length;

  if (arrDim == 1) {
    for (var i = 0; i < len; i++) {
      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
    }
  } else {
    var len2 = p0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
      }
    }
  }
}
/**
 * Catmull Rom interpolate number
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @return {number}
 */


function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}

function cloneValue(value) {
  if (isArrayLike(value)) {
    var len = value.length;

    if (isArrayLike(value[0])) {
      var ret = [];

      for (var i = 0; i < len; i++) {
        ret.push(arraySlice.call(value[i]));
      }

      return ret;
    }

    return arraySlice.call(value);
  }

  return value;
}

function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]);
  rgba[1] = Math.floor(rgba[1]);
  rgba[2] = Math.floor(rgba[2]);
  return 'rgba(' + rgba.join(',') + ')';
}

function getArrayDim(keyframes) {
  var lastValue = keyframes[keyframes.length - 1].value;
  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
}

function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
  var getter = animator._getter;
  var setter = animator._setter;
  var useSpline = easing === 'spline';
  var trackLen = keyframes.length;

  if (!trackLen) {
    return;
  } // Guess data type


  var firstVal = keyframes[0].value;
  var isValueArray = isArrayLike(firstVal);
  var isValueColor = false;
  var isValueString = false; // For vertices morphing

  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
  var trackMaxTime; // Sort keyframe as ascending

  keyframes.sort(function (a, b) {
    return a.time - b.time;
  });
  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe

  var kfPercents = []; // Value of each keyframe

  var kfValues = [];
  var prevValue = keyframes[0].value;
  var isAllValueEqual = true;

  for (var i = 0; i < trackLen; i++) {
    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string

    var value = keyframes[i].value; // Check if value is equal, deep check if value is array

    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
      isAllValueEqual = false;
    }

    prevValue = value; // Try converting a string to a color array

    if (typeof value == 'string') {
      var colorArray = color.parse(value);

      if (colorArray) {
        value = colorArray;
        isValueColor = true;
      } else {
        isValueString = true;
      }
    }

    kfValues.push(value);
  }

  if (!forceAnimate && isAllValueEqual) {
    return;
  }

  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value

  for (var i = 0; i < trackLen - 1; i++) {
    if (isValueArray) {
      fillArr(kfValues[i], lastValue, arrDim);
    } else {
      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
        kfValues[i] = lastValue;
      }
    }
  }

  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
  // animation playback is sequency

  var lastFrame = 0;
  var lastFramePercent = 0;
  var start;
  var w;
  var p0;
  var p1;
  var p2;
  var p3;

  if (isValueColor) {
    var rgba = [0, 0, 0, 0];
  }

  var onframe = function (target, percent) {
    // Find the range keyframes
    // kf1-----kf2---------current--------kf3
    // find kf2 and kf3 and do interpolation
    var frame; // In the easing function like elasticOut, percent may less than 0

    if (percent < 0) {
      frame = 0;
    } else if (percent < lastFramePercent) {
      // Start from next key
      // PENDING start from lastFrame ?
      start = Math.min(lastFrame + 1, trackLen - 1);

      for (frame = start; frame >= 0; frame--) {
        if (kfPercents[frame] <= percent) {
          break;
        }
      } // PENDING really need to do this ?


      frame = Math.min(frame, trackLen - 2);
    } else {
      for (frame = lastFrame; frame < trackLen; frame++) {
        if (kfPercents[frame] > percent) {
          break;
        }
      }

      frame = Math.min(frame - 1, trackLen - 2);
    }

    lastFrame = frame;
    lastFramePercent = percent;
    var range = kfPercents[frame + 1] - kfPercents[frame];

    if (range === 0) {
      return;
    } else {
      w = (percent - kfPercents[frame]) / range;
    }

    if (useSpline) {
      p1 = kfValues[frame];
      p0 = kfValues[frame === 0 ? frame : frame - 1];
      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];

      if (isValueArray) {
        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
      } else {
        var value;

        if (isValueColor) {
          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
          value = rgba2String(rgba);
        } else if (isValueString) {
          // String is step(0.5)
          return interpolateString(p1, p2, w);
        } else {
          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
        }

        setter(target, propName, value);
      }
    } else {
      if (isValueArray) {
        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
      } else {
        var value;

        if (isValueColor) {
          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
          value = rgba2String(rgba);
        } else if (isValueString) {
          // String is step(0.5)
          return interpolateString(kfValues[frame], kfValues[frame + 1], w);
        } else {
          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
        }

        setter(target, propName, value);
      }
    }
  };

  var clip = new Clip({
    target: animator._target,
    life: trackMaxTime,
    loop: animator._loop,
    delay: animator._delay,
    onframe: onframe,
    ondestroy: oneTrackDone
  });

  if (easing && easing !== 'spline') {
    clip.easing = easing;
  }

  return clip;
}
/**
 * @alias module:zrender/animation/Animator
 * @constructor
 * @param {Object} target
 * @param {boolean} loop
 * @param {Function} getter
 * @param {Function} setter
 */


var Animator = function (target, loop, getter, setter) {
  this._tracks = {};
  this._target = target;
  this._loop = loop || false;
  this._getter = getter || defaultGetter;
  this._setter = setter || defaultSetter;
  this._clipCount = 0;
  this._delay = 0;
  this._doneList = [];
  this._onframeList = [];
  this._clipList = [];
};

Animator.prototype = {
  /**
   * 设置动画关键帧
   * @param  {number} time 关键帧时间，单位是ms
   * @param  {Object} props 关键帧的属性值，key-value表示
   * @return {module:zrender/animation/Animator}
   */
  when: function (time
  /* ms */
  , props) {
    var tracks = this._tracks;

    for (var propName in props) {
      if (!props.hasOwnProperty(propName)) {
        continue;
      }

      if (!tracks[propName]) {
        tracks[propName] = []; // Invalid value

        var value = this._getter(this._target, propName);

        if (value == null) {
          // zrLog('Invalid property ' + propName);
          continue;
        } // If time is 0
        //  Then props is given initialize value
        // Else
        //  Initialize value from current prop value


        if (time !== 0) {
          tracks[propName].push({
            time: 0,
            value: cloneValue(value)
          });
        }
      }

      tracks[propName].push({
        time: time,
        value: props[propName]
      });
    }

    return this;
  },

  /**
   * 添加动画每一帧的回调函数
   * @param  {Function} callback
   * @return {module:zrender/animation/Animator}
   */
  during: function (callback) {
    this._onframeList.push(callback);

    return this;
  },
  pause: function () {
    for (var i = 0; i < this._clipList.length; i++) {
      this._clipList[i].pause();
    }

    this._paused = true;
  },
  resume: function () {
    for (var i = 0; i < this._clipList.length; i++) {
      this._clipList[i].resume();
    }

    this._paused = false;
  },
  isPaused: function () {
    return !!this._paused;
  },
  _doneCallback: function () {
    // Clear all tracks
    this._tracks = {}; // Clear all clips

    this._clipList.length = 0;
    var doneList = this._doneList;
    var len = doneList.length;

    for (var i = 0; i < len; i++) {
      doneList[i].call(this);
    }
  },

  /**
   * 开始执行动画
   * @param  {string|Function} [easing]
   *         动画缓动函数，详见{@link module:zrender/animation/easing}
   * @param  {boolean} forceAnimate
   * @return {module:zrender/animation/Animator}
   */
  start: function (easing, forceAnimate) {
    var self = this;
    var clipCount = 0;

    var oneTrackDone = function () {
      clipCount--;

      if (!clipCount) {
        self._doneCallback();
      }
    };

    var lastClip;

    for (var propName in this._tracks) {
      if (!this._tracks.hasOwnProperty(propName)) {
        continue;
      }

      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);

      if (clip) {
        this._clipList.push(clip);

        clipCount++; // If start after added to animation

        if (this.animation) {
          this.animation.addClip(clip);
        }

        lastClip = clip;
      }
    } // Add during callback on the last clip


    if (lastClip) {
      var oldOnFrame = lastClip.onframe;

      lastClip.onframe = function (target, percent) {
        oldOnFrame(target, percent);

        for (var i = 0; i < self._onframeList.length; i++) {
          self._onframeList[i](target, percent);
        }
      };
    } // This optimization will help the case that in the upper application
    // the view may be refreshed frequently, where animation will be
    // called repeatly but nothing changed.


    if (!clipCount) {
      this._doneCallback();
    }

    return this;
  },

  /**
   * 停止动画
   * @param {boolean} forwardToLast If move to last frame before stop
   */
  stop: function (forwardToLast) {
    var clipList = this._clipList;
    var animation = this.animation;

    for (var i = 0; i < clipList.length; i++) {
      var clip = clipList[i];

      if (forwardToLast) {
        // Move to last frame before stop
        clip.onframe(this._target, 1);
      }

      animation && animation.removeClip(clip);
    }

    clipList.length = 0;
  },

  /**
   * 设置动画延迟开始的时间
   * @param  {number} time 单位ms
   * @return {module:zrender/animation/Animator}
   */
  delay: function (time) {
    this._delay = time;
    return this;
  },

  /**
   * 添加动画结束的回调
   * @param  {Function} cb
   * @return {module:zrender/animation/Animator}
   */
  done: function (cb) {
    if (cb) {
      this._doneList.push(cb);
    }

    return this;
  },

  /**
   * @return {Array.<module:zrender/animation/Clip>}
   */
  getClips: function () {
    return this._clipList;
  }
};
var _default = Animator;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/animation/Clip.js":
/***/ (function(module, exports, __webpack_require__) {

var easingFuncs = __webpack_require__("./node_modules/zrender/lib/animation/easing.js");

/**
 * 动画主控制器
 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
 * @config life(1000) 动画时长
 * @config delay(0) 动画延迟时间
 * @config loop(true)
 * @config gap(0) 循环的间隔时间
 * @config onframe
 * @config easing(optional)
 * @config ondestroy(optional)
 * @config onrestart(optional)
 *
 * TODO pause
 */
function Clip(options) {
  this._target = options.target; // 生命周期

  this._life = options.life || 1000; // 延时

  this._delay = options.delay || 0; // 开始时间
  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒

  this._initialized = false; // 是否循环

  this.loop = options.loop == null ? false : options.loop;
  this.gap = options.gap || 0;
  this.easing = options.easing || 'Linear';
  this.onframe = options.onframe;
  this.ondestroy = options.ondestroy;
  this.onrestart = options.onrestart;
  this._pausedTime = 0;
  this._paused = false;
}

Clip.prototype = {
  constructor: Clip,
  step: function (globalTime, deltaTime) {
    // Set startTime on first step, or _startTime may has milleseconds different between clips
    // PENDING
    if (!this._initialized) {
      this._startTime = globalTime + this._delay;
      this._initialized = true;
    }

    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }

    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始

    if (percent < 0) {
      return;
    }

    percent = Math.min(percent, 1);
    var easing = this.easing;
    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
    this.fire('frame', schedule); // 结束

    if (percent == 1) {
      if (this.loop) {
        this.restart(globalTime); // 重新开始周期
        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件

        return 'restart';
      } // 动画完成将这个控制器标识为待删除
      // 在Animation.update中进行批量删除


      this._needsRemove = true;
      return 'destroy';
    }

    return null;
  },
  restart: function (globalTime) {
    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
    this._startTime = globalTime - remainder + this.gap;
    this._pausedTime = 0;
    this._needsRemove = false;
  },
  fire: function (eventType, arg) {
    eventType = 'on' + eventType;

    if (this[eventType]) {
      this[eventType](this._target, arg);
    }
  },
  pause: function () {
    this._paused = true;
  },
  resume: function () {
    this._paused = false;
  }
};
var _default = Clip;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/animation/easing.js":
/***/ (function(module, exports) {

/**
 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
 * @see http://sole.github.io/tween.js/examples/03_graphs.html
 * @exports zrender/animation/easing
 */
var easing = {
  /**
  * @param {number} k
  * @return {number}
  */
  linear: function (k) {
    return k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticIn: function (k) {
    return k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticOut: function (k) {
    return k * (2 - k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }

    return -0.5 * (--k * (k - 2) - 1);
  },
  // 三次方的缓动（t^3）

  /**
  * @param {number} k
  * @return {number}
  */
  cubicIn: function (k) {
    return k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  cubicOut: function (k) {
    return --k * k * k + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  cubicInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k;
    }

    return 0.5 * ((k -= 2) * k * k + 2);
  },
  // 四次方的缓动（t^4）

  /**
  * @param {number} k
  * @return {number}
  */
  quarticIn: function (k) {
    return k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quarticOut: function (k) {
    return 1 - --k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quarticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k;
    }

    return -0.5 * ((k -= 2) * k * k * k - 2);
  },
  // 五次方的缓动（t^5）

  /**
  * @param {number} k
  * @return {number}
  */
  quinticIn: function (k) {
    return k * k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quinticOut: function (k) {
    return --k * k * k * k * k + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quinticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k * k;
    }

    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  },
  // 正弦曲线的缓动（sin(t)）

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalIn: function (k) {
    return 1 - Math.cos(k * Math.PI / 2);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalOut: function (k) {
    return Math.sin(k * Math.PI / 2);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalInOut: function (k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  },
  // 指数曲线的缓动（2^t）

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialIn: function (k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialOut: function (k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialInOut: function (k) {
    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if ((k *= 2) < 1) {
      return 0.5 * Math.pow(1024, k - 1);
    }

    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  },
  // 圆形曲线的缓动（sqrt(1-t^2)）

  /**
  * @param {number} k
  * @return {number}
  */
  circularIn: function (k) {
    return 1 - Math.sqrt(1 - k * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  circularOut: function (k) {
    return Math.sqrt(1 - --k * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  circularInOut: function (k) {
    if ((k *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k * k) - 1);
    }

    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  },
  // 创建类似于弹簧在停止前来回振荡的动画

  /**
  * @param {number} k
  * @return {number}
  */
  elasticIn: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
  },

  /**
  * @param {number} k
  * @return {number}
  */
  elasticOut: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  elasticInOut: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    if ((k *= 2) < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    }

    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
  },
  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动

  /**
  * @param {number} k
  * @return {number}
  */
  backIn: function (k) {
    var s = 1.70158;
    return k * k * ((s + 1) * k - s);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  backOut: function (k) {
    var s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  backInOut: function (k) {
    var s = 1.70158 * 1.525;

    if ((k *= 2) < 1) {
      return 0.5 * (k * k * ((s + 1) * k - s));
    }

    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
  },
  // 创建弹跳效果

  /**
  * @param {number} k
  * @return {number}
  */
  bounceIn: function (k) {
    return 1 - easing.bounceOut(1 - k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  bounceOut: function (k) {
    if (k < 1 / 2.75) {
      return 7.5625 * k * k;
    } else if (k < 2 / 2.75) {
      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
    } else if (k < 2.5 / 2.75) {
      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
    }
  },

  /**
  * @param {number} k
  * @return {number}
  */
  bounceInOut: function (k) {
    if (k < 0.5) {
      return easing.bounceIn(k * 2) * 0.5;
    }

    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }
};
var _default = easing;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/animation/requestAnimationFrame.js":
/***/ (function(module, exports) {

var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
  setTimeout(func, 16);
};

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/config.js":
/***/ (function(module, exports) {

var dpr = 1; // If in browser environment

if (typeof window !== 'undefined') {
  dpr = Math.max(window.devicePixelRatio || 1, 1);
}
/**
 * config默认配置项
 * @exports zrender/config
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */

/**
 * debug日志选项：catchBrushException为true下有效
 * 0 : 不生成debug数据，发布用
 * 1 : 异常抛出，调试用
 * 2 : 控制台输出，调试用
 */


var debugMode = 0; // retina 屏幕优化

var devicePixelRatio = dpr;
exports.debugMode = debugMode;
exports.devicePixelRatio = devicePixelRatio;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/arc.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/contain/util.js");

var normalizeRadian = _util.normalizeRadian;
var PI2 = Math.PI * 2;
/**
 * 圆弧描边包含判断
 * @param  {number}  cx
 * @param  {number}  cy
 * @param  {number}  r
 * @param  {number}  startAngle
 * @param  {number}  endAngle
 * @param  {boolean}  anticlockwise
 * @param  {number} lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {Boolean}
 */

function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth;
  x -= cx;
  y -= cy;
  var d = Math.sqrt(x * x + y * y);

  if (d - _l > r || d + _l < r) {
    return false;
  }

  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
    // Is a circle
    return true;
  }

  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }

  if (startAngle > endAngle) {
    endAngle += PI2;
  }

  var angle = Math.atan2(y, x);

  if (angle < 0) {
    angle += PI2;
  }

  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/cubic.js":
/***/ (function(module, exports, __webpack_require__) {

var curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

/**
 * 三次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  x3
 * @param  {number}  y3
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth; // Quick reject

  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
    return false;
  }

  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
  return d <= _l / 2;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/line.js":
/***/ (function(module, exports) {

/**
 * 线段包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth;
  var _a = 0;
  var _b = x0; // Quick reject

  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
    return false;
  }

  if (x0 !== x1) {
    _a = (y0 - y1) / (x0 - x1);
    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x - x0) <= _l / 2;
  }

  var tmp = _a * x - y + _b;

  var _s = tmp * tmp / (_a * _a + 1);

  return _s <= _l / 2 * _l / 2;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/path.js":
/***/ (function(module, exports, __webpack_require__) {

var PathProxy = __webpack_require__("./node_modules/zrender/lib/core/PathProxy.js");

var line = __webpack_require__("./node_modules/zrender/lib/contain/line.js");

var cubic = __webpack_require__("./node_modules/zrender/lib/contain/cubic.js");

var quadratic = __webpack_require__("./node_modules/zrender/lib/contain/quadratic.js");

var arc = __webpack_require__("./node_modules/zrender/lib/contain/arc.js");

var _util = __webpack_require__("./node_modules/zrender/lib/contain/util.js");

var normalizeRadian = _util.normalizeRadian;

var curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

var windingLine = __webpack_require__("./node_modules/zrender/lib/contain/windingLine.js");

var CMD = PathProxy.CMD;
var PI2 = Math.PI * 2;
var EPSILON = 1e-4;

function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
} // 临时数组


var roots = [-1, -1, -1];
var extrema = [-1, -1];

function swapExtrema() {
  var tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}

function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  // Quick reject
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
    return 0;
  }

  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);

  if (nRoots === 0) {
    return 0;
  } else {
    var w = 0;
    var nExtrema = -1;
    var y0_, y1_;

    for (var i = 0; i < nRoots; i++) {
      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon

      var unit = t === 0 || t === 1 ? 0.5 : 1;
      var x_ = curve.cubicAt(x0, x1, x2, x3, t);

      if (x_ < x) {
        // Quick reject
        continue;
      }

      if (nExtrema < 0) {
        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);

        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }

        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);

        if (nExtrema > 1) {
          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
        }
      }

      if (nExtrema == 2) {
        // 分成三段单调函数
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else if (t < extrema[1]) {
          w += y1_ < y0_ ? unit : -unit;
        } else {
          w += y3 < y1_ ? unit : -unit;
        }
      } else {
        // 分成两段单调函数
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else {
          w += y3 < y0_ ? unit : -unit;
        }
      }
    }

    return w;
  }
}

function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  // Quick reject
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
    return 0;
  }

  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);

  if (nRoots === 0) {
    return 0;
  } else {
    var t = curve.quadraticExtremum(y0, y1, y2);

    if (t >= 0 && t <= 1) {
      var w = 0;
      var y_ = curve.quadraticAt(y0, y1, y2, t);

      for (var i = 0; i < nRoots; i++) {
        // Remove one endpoint.
        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);

        if (x_ < x) {
          // Quick reject
          continue;
        }

        if (roots[i] < t) {
          w += y_ < y0 ? unit : -unit;
        } else {
          w += y2 < y_ ? unit : -unit;
        }
      }

      return w;
    } else {
      // Remove one endpoint.
      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);

      if (x_ < x) {
        // Quick reject
        return 0;
      }

      return y2 < y0 ? unit : -unit;
    }
  }
} // TODO
// Arc 旋转


function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  y -= cy;

  if (y > r || y < -r) {
    return 0;
  }

  var tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp;
  roots[1] = tmp;
  var diff = Math.abs(startAngle - endAngle);

  if (diff < 1e-4) {
    return 0;
  }

  if (diff % PI2 < 1e-4) {
    // Is a circle
    startAngle = 0;
    endAngle = PI2;
    var dir = anticlockwise ? 1 : -1;

    if (x >= roots[0] + cx && x <= roots[1] + cx) {
      return dir;
    } else {
      return 0;
    }
  }

  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }

  if (startAngle > endAngle) {
    endAngle += PI2;
  }

  var w = 0;

  for (var i = 0; i < 2; i++) {
    var x_ = roots[i];

    if (x_ + cx > x) {
      var angle = Math.atan2(y, x_);
      var dir = anticlockwise ? 1 : -1;

      if (angle < 0) {
        angle = PI2 + angle;
      }

      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir = -dir;
        }

        w += dir;
      }
    }
  }

  return w;
}

function containPath(data, lineWidth, isStroke, x, y) {
  var w = 0;
  var xi = 0;
  var yi = 0;
  var x0 = 0;
  var y0 = 0;

  for (var i = 0; i < data.length;) {
    var cmd = data[i++]; // Begin a new subpath

    if (cmd === CMD.M && i > 1) {
      // Close previous subpath
      if (!isStroke) {
        w += windingLine(xi, yi, x0, y0, x, y);
      } // 如果被任何一个 subpath 包含
      // if (w !== 0) {
      //     return true;
      // }

    }

    if (i == 1) {
      // 如果第一个命令是 L, C, Q
      // 则 previous point 同绘制命令的第一个 point
      //
      // 第一个命令为 Arc 的情况下会在后面特殊处理
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }

    switch (cmd) {
      case CMD.M:
        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
        // 在 closePath 的时候使用
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;

      case CMD.L:
        if (isStroke) {
          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.C:
        if (isStroke) {
          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.Q:
        if (isStroke) {
          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.A:
        // TODO Arc 判断的开销比较大
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++]; // TODO Arc 旋转

        var psi = data[i++];
        var anticlockwise = 1 - data[i++];
        var x1 = Math.cos(theta) * rx + cx;
        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令

        if (i > 1) {
          w += windingLine(xi, yi, x1, y1, x, y);
        } else {
          // 第一个命令起点还未定义
          x0 = x1;
          y0 = y1;
        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放


        var _x = (x - cx) * ry / rx + cx;

        if (isStroke) {
          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
            return true;
          }
        } else {
          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
        }

        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;

      case CMD.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        var width = data[i++];
        var height = data[i++];
        var x1 = x0 + width;
        var y1 = y0 + height;

        if (isStroke) {
          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          // FIXME Clockwise ?
          w += windingLine(x1, y0, x1, y1, x, y);
          w += windingLine(x0, y1, x0, y0, x, y);
        }

        break;

      case CMD.Z:
        if (isStroke) {
          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          // Close a subpath
          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
          // FIXME subpaths may overlap
          // if (w !== 0) {
          //     return true;
          // }
        }

        xi = x0;
        yi = y0;
        break;
    }
  }

  if (!isStroke && !isAroundEqual(yi, y0)) {
    w += windingLine(xi, yi, x0, y0, x, y) || 0;
  }

  return w !== 0;
}

function contain(pathData, x, y) {
  return containPath(pathData, 0, false, x, y);
}

function containStroke(pathData, lineWidth, x, y) {
  return containPath(pathData, lineWidth, true, x, y);
}

exports.contain = contain;
exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/polygon.js":
/***/ (function(module, exports, __webpack_require__) {

var windingLine = __webpack_require__("./node_modules/zrender/lib/contain/windingLine.js");

var EPSILON = 1e-8;

function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}

function contain(points, x, y) {
  var w = 0;
  var p = points[0];

  if (!p) {
    return false;
  }

  for (var i = 1; i < points.length; i++) {
    var p2 = points[i];
    w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
    p = p2;
  } // Close polygon


  var p0 = points[0];

  if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {
    w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
  }

  return w !== 0;
}

exports.contain = contain;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/quadratic.js":
/***/ (function(module, exports, __webpack_require__) {

var _curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

var quadraticProjectPoint = _curve.quadraticProjectPoint;

/**
 * 二次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth; // Quick reject

  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
    return false;
  }

  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
  return d <= _l / 2;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/text.js":
/***/ (function(module, exports, __webpack_require__) {

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var imageHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/image.js");

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var getContext = _util.getContext;
var extend = _util.extend;
var retrieve2 = _util.retrieve2;
var retrieve3 = _util.retrieve3;
var trim = _util.trim;
var textWidthCache = {};
var textWidthCacheCounter = 0;
var TEXT_CACHE_MAX = 5000;
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.

var methods = {};

function $override(name, fn) {
  methods[name] = fn;
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {number} width
 */


function getWidth(text, font) {
  font = font || DEFAULT_FONT;
  var key = text + ':' + font;

  if (textWidthCache[key]) {
    return textWidthCache[key];
  }

  var textLines = (text + '').split('\n');
  var width = 0;

  for (var i = 0, l = textLines.length; i < l; i++) {
    // textContain.measureText may be overrided in SVG or VML
    width = Math.max(measureText(textLines[i], font).width, width);
  }

  if (textWidthCacheCounter > TEXT_CACHE_MAX) {
    textWidthCacheCounter = 0;
    textWidthCache = {};
  }

  textWidthCacheCounter++;
  textWidthCache[key] = width;
  return width;
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {string} [textAlign='left']
 * @param {string} [textVerticalAlign='top']
 * @param {Array.<number>} [textPadding]
 * @param {Object} [rich]
 * @param {Object} [truncate]
 * @return {Object} {x, y, width, height, lineHeight}
 */


function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
}

function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
  var contentBlock = parsePlainText(text, font, textPadding, truncate);
  var outerWidth = getWidth(text, font);

  if (textPadding) {
    outerWidth += textPadding[1] + textPadding[3];
  }

  var outerHeight = contentBlock.outerHeight;
  var x = adjustTextX(0, outerWidth, textAlign);
  var y = adjustTextY(0, outerHeight, textVerticalAlign);
  var rect = new BoundingRect(x, y, outerWidth, outerHeight);
  rect.lineHeight = contentBlock.lineHeight;
  return rect;
}

function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
  var contentBlock = parseRichText(text, {
    rich: rich,
    truncate: truncate,
    font: font,
    textAlign: textAlign,
    textPadding: textPadding
  });
  var outerWidth = contentBlock.outerWidth;
  var outerHeight = contentBlock.outerHeight;
  var x = adjustTextX(0, outerWidth, textAlign);
  var y = adjustTextY(0, outerHeight, textVerticalAlign);
  return new BoundingRect(x, y, outerWidth, outerHeight);
}
/**
 * @public
 * @param {number} x
 * @param {number} width
 * @param {string} [textAlign='left']
 * @return {number} Adjusted x.
 */


function adjustTextX(x, width, textAlign) {
  // FIXME Right to left language
  if (textAlign === 'right') {
    x -= width;
  } else if (textAlign === 'center') {
    x -= width / 2;
  }

  return x;
}
/**
 * @public
 * @param {number} y
 * @param {number} height
 * @param {string} [textVerticalAlign='top']
 * @return {number} Adjusted y.
 */


function adjustTextY(y, height, textVerticalAlign) {
  if (textVerticalAlign === 'middle') {
    y -= height / 2;
  } else if (textVerticalAlign === 'bottom') {
    y -= height;
  }

  return y;
}
/**
 * @public
 * @param {stirng} textPosition
 * @param {Object} rect {x, y, width, height}
 * @param {number} distance
 * @return {Object} {x, y, textAlign, textVerticalAlign}
 */


function adjustTextPositionOnRect(textPosition, rect, distance) {
  var x = rect.x;
  var y = rect.y;
  var height = rect.height;
  var width = rect.width;
  var halfHeight = height / 2;
  var textAlign = 'left';
  var textVerticalAlign = 'top';

  switch (textPosition) {
    case 'left':
      x -= distance;
      y += halfHeight;
      textAlign = 'right';
      textVerticalAlign = 'middle';
      break;

    case 'right':
      x += distance + width;
      y += halfHeight;
      textVerticalAlign = 'middle';
      break;

    case 'top':
      x += width / 2;
      y -= distance;
      textAlign = 'center';
      textVerticalAlign = 'bottom';
      break;

    case 'bottom':
      x += width / 2;
      y += height + distance;
      textAlign = 'center';
      break;

    case 'inside':
      x += width / 2;
      y += halfHeight;
      textAlign = 'center';
      textVerticalAlign = 'middle';
      break;

    case 'insideLeft':
      x += distance;
      y += halfHeight;
      textVerticalAlign = 'middle';
      break;

    case 'insideRight':
      x += width - distance;
      y += halfHeight;
      textAlign = 'right';
      textVerticalAlign = 'middle';
      break;

    case 'insideTop':
      x += width / 2;
      y += distance;
      textAlign = 'center';
      break;

    case 'insideBottom':
      x += width / 2;
      y += height - distance;
      textAlign = 'center';
      textVerticalAlign = 'bottom';
      break;

    case 'insideTopLeft':
      x += distance;
      y += distance;
      break;

    case 'insideTopRight':
      x += width - distance;
      y += distance;
      textAlign = 'right';
      break;

    case 'insideBottomLeft':
      x += distance;
      y += height - distance;
      textVerticalAlign = 'bottom';
      break;

    case 'insideBottomRight':
      x += width - distance;
      y += height - distance;
      textAlign = 'right';
      textVerticalAlign = 'bottom';
      break;
  }

  return {
    x: x,
    y: y,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}
/**
 * Show ellipsis if overflow.
 *
 * @public
 * @param  {string} text
 * @param  {string} containerWidth
 * @param  {string} font
 * @param  {number} [ellipsis='...']
 * @param  {Object} [options]
 * @param  {number} [options.maxIterations=3]
 * @param  {number} [options.minChar=0] If truncate result are less
 *                  then minChar, ellipsis will not show, which is
 *                  better for user hint in some cases.
 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
 * @return {string}
 */


function truncateText(text, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    return '';
  }

  var textLines = (text + '').split('\n');
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
  // It is not appropriate that every line has '...' when truncate multiple lines.

  for (var i = 0, len = textLines.length; i < len; i++) {
    textLines[i] = truncateSingleLine(textLines[i], options);
  }

  return textLines.join('\n');
}

function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = extend({}, options);
  options.font = font;
  var ellipsis = retrieve2(ellipsis, '...');
  options.maxIterations = retrieve2(options.maxIterations, 2);
  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME
  // Other languages?

  options.cnCharWidth = getWidth('国', font); // FIXME
  // Consider proportional font?

  var ascCharWidth = options.ascCharWidth = getWidth('a', font);
  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.

  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.

  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
    contentWidth -= ascCharWidth;
  }

  var ellipsisWidth = getWidth(ellipsis);

  if (ellipsisWidth > contentWidth) {
    ellipsis = '';
    ellipsisWidth = 0;
  }

  contentWidth = containerWidth - ellipsisWidth;
  options.ellipsis = ellipsis;
  options.ellipsisWidth = ellipsisWidth;
  options.contentWidth = contentWidth;
  options.containerWidth = containerWidth;
  return options;
}

function truncateSingleLine(textLine, options) {
  var containerWidth = options.containerWidth;
  var font = options.font;
  var contentWidth = options.contentWidth;

  if (!containerWidth) {
    return '';
  }

  var lineWidth = getWidth(textLine, font);

  if (lineWidth <= containerWidth) {
    return textLine;
  }

  for (var j = 0;; j++) {
    if (lineWidth <= contentWidth || j >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }

    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth(textLine, font);
  }

  if (textLine === '') {
    textLine = options.placeholder;
  }

  return textLine;
}

function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
  var width = 0;
  var i = 0;

  for (var len = text.length; i < len && width < contentWidth; i++) {
    var charCode = text.charCodeAt(i);
    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }

  return i;
}
/**
 * @public
 * @param {string} font
 * @return {number} line height
 */


function getLineHeight(font) {
  // FIXME A rough approach.
  return getWidth('国', font);
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {Object} width
 */


function measureText(text, font) {
  return methods.measureText(text, font);
} // Avoid assign to an exported variable, for transforming to cjs.


methods.measureText = function (text, font) {
  var ctx = getContext();
  ctx.font = font || DEFAULT_FONT;
  return ctx.measureText(text);
};
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {Object} [truncate]
 * @return {Object} block: {lineHeight, lines, height, outerHeight}
 *  Notice: for performance, do not calculate outerWidth util needed.
 */


function parsePlainText(text, font, padding, truncate) {
  text != null && (text += '');
  var lineHeight = getLineHeight(font);
  var lines = text ? text.split('\n') : [];
  var height = lines.length * lineHeight;
  var outerHeight = height;

  if (padding) {
    outerHeight += padding[0] + padding[2];
  }

  if (text && truncate) {
    var truncOuterHeight = truncate.outerHeight;
    var truncOuterWidth = truncate.outerWidth;

    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
      text = '';
      lines = [];
    } else if (truncOuterWidth != null) {
      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
        minChar: truncate.minChar,
        placeholder: truncate.placeholder
      }); // FIXME
      // It is not appropriate that every line has '...' when truncate multiple lines.

      for (var i = 0, len = lines.length; i < len; i++) {
        lines[i] = truncateSingleLine(lines[i], options);
      }
    }
  }

  return {
    lines: lines,
    height: height,
    outerHeight: outerHeight,
    lineHeight: lineHeight
  };
}
/**
 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
 *
 * @public
 * @param {string} text
 * @param {Object} style
 * @return {Object} block
 * {
 *      width,
 *      height,
 *      lines: [{
 *          lineHeight,
 *          width,
 *          tokens: [[{
 *              styleName,
 *              text,
 *              width,      // include textPadding
 *              height,     // include textPadding
 *              textWidth, // pure text width
 *              textHeight, // pure text height
 *              lineHeihgt,
 *              font,
 *              textAlign,
 *              textVerticalAlign
 *          }], [...], ...]
 *      }, ...]
 * }
 * If styleName is undefined, it is plain text.
 */


function parseRichText(text, style) {
  var contentBlock = {
    lines: [],
    width: 0,
    height: 0
  };
  text != null && (text += '');

  if (!text) {
    return contentBlock;
  }

  var lastIndex = STYLE_REG.lastIndex = 0;
  var result;

  while ((result = STYLE_REG.exec(text)) != null) {
    var matchedIndex = result.index;

    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
    }

    pushTokens(contentBlock, result[2], result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }

  if (lastIndex < text.length) {
    pushTokens(contentBlock, text.substring(lastIndex, text.length));
  }

  var lines = contentBlock.lines;
  var contentHeight = 0;
  var contentWidth = 0; // For `textWidth: 100%`

  var pendingList = [];
  var stlPadding = style.textPadding;
  var truncate = style.truncate;
  var truncateWidth = truncate && truncate.outerWidth;
  var truncateHeight = truncate && truncate.outerHeight;

  if (stlPadding) {
    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
  } // Calculate layout info of tokens.


  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var lineHeight = 0;
    var lineWidth = 0;

    for (var j = 0; j < line.tokens.length; j++) {
      var token = line.tokens[j];
      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.

      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.

      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.

      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified
      // as box height of the block.
      tokenStyle.textHeight, getLineHeight(font));
      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
      token.height = tokenHeight;
      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';

      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
        return {
          lines: [],
          width: 0,
          height: 0
        };
      }

      token.textWidth = getWidth(token.text, font);
      var tokenWidth = tokenStyle.textWidth;
      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
      // line when box width is needed to be auto.

      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
        token.percentWidth = tokenWidth;
        pendingList.push(token);
        tokenWidth = 0; // Do not truncate in this case, because there is no user case
        // and it is too complicated.
      } else {
        if (tokenWidthNotSpecified) {
          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
          // `getBoundingRect()` will not get correct result.

          var textBackgroundColor = tokenStyle.textBackgroundColor;
          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
          // (1) If image is not loaded, it will be loaded at render phase and call
          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
          // image, and then the right size will be calculated here at the next tick.
          // See `graphic/helper/text.js`.
          // (2) If image loaded, and `textBackgroundColor.image` is image src string,
          // use `imageHelper.findExistImage` to find cached image.
          // `imageHelper.findExistImage` will always be called here before
          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
          // which ensures that image will not be rendered before correct size calcualted.

          if (bgImg) {
            bgImg = imageHelper.findExistImage(bgImg);

            if (imageHelper.isImageReady(bgImg)) {
              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
            }
          }
        }

        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
        tokenWidth += paddingW;
        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;

        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
            token.text = '';
            token.textWidth = tokenWidth = 0;
          } else {
            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
              minChar: truncate.minChar
            });
            token.textWidth = getWidth(token.text, font);
            tokenWidth = token.textWidth + paddingW;
          }
        }
      }

      lineWidth += token.width = tokenWidth;
      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
    }

    line.width = lineWidth;
    line.lineHeight = lineHeight;
    contentHeight += lineHeight;
    contentWidth = Math.max(contentWidth, lineWidth);
  }

  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);

  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }

  for (var i = 0; i < pendingList.length; i++) {
    var token = pendingList[i];
    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.

    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
  }

  return contentBlock;
}

function pushTokens(block, str, styleName) {
  var isEmptyStr = str === '';
  var strs = str.split('\n');
  var lines = block.lines;

  for (var i = 0; i < strs.length; i++) {
    var text = strs[i];
    var token = {
      styleName: styleName,
      text: text,
      isLineHolder: !text && !isEmptyStr
    }; // The first token should be appended to the last line.

    if (!i) {
      var tokens = (lines[lines.length - 1] || (lines[0] = {
        tokens: []
      })).tokens; // Consider cases:
      // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
      // (which is a placeholder) should be replaced by new token.
      // (2) A image backage, where token likes {a|}.
      // (3) A redundant '' will affect textAlign in line.
      // (4) tokens with the same tplName should not be merged, because
      // they should be displayed in different box (with border and padding).

      var tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
      // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
      (text || !tokensLen || isEmptyStr) && tokens.push(token);
    } // Other tokens always start a new line.
    else {
        // If there is '', insert it as a placeholder.
        lines.push({
          tokens: [token]
        });
      }
  }
}

function makeFont(style) {
  // FIXME in node-canvas fontWeight is before fontStyle
  // Use `fontSize` `fontFamily` to check whether font properties are defined.
  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
  style.fontFamily || 'sans-serif'].join(' ');
  return font && trim(font) || style.textFont || style.font;
}

exports.DEFAULT_FONT = DEFAULT_FONT;
exports.$override = $override;
exports.getWidth = getWidth;
exports.getBoundingRect = getBoundingRect;
exports.adjustTextX = adjustTextX;
exports.adjustTextY = adjustTextY;
exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
exports.truncateText = truncateText;
exports.getLineHeight = getLineHeight;
exports.measureText = measureText;
exports.parsePlainText = parsePlainText;
exports.parseRichText = parseRichText;
exports.makeFont = makeFont;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/util.js":
/***/ (function(module, exports) {

var PI2 = Math.PI * 2;

function normalizeRadian(angle) {
  angle %= PI2;

  if (angle < 0) {
    angle += PI2;
  }

  return angle;
}

exports.normalizeRadian = normalizeRadian;

/***/ }),

/***/ "./node_modules/zrender/lib/contain/windingLine.js":
/***/ (function(module, exports) {

function windingLine(x0, y0, x1, y1, x, y) {
  if (y > y0 && y > y1 || y < y0 && y < y1) {
    return 0;
  } // Ignore horizontal line


  if (y1 === y0) {
    return 0;
  }

  var dir = y1 < y0 ? 1 : -1;
  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon

  if (t === 1 || t === 0) {
    dir = y1 < y0 ? 0.5 : -0.5;
  }

  var x_ = t * (x1 - x0) + x0; // If (x, y) on the line, considered as "contain".

  return x_ === x ? Infinity : x_ > x ? dir : 0;
}

module.exports = windingLine;

/***/ }),

/***/ "./node_modules/zrender/lib/container/Group.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Element = __webpack_require__("./node_modules/zrender/lib/Element.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

/**
 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
 * @module zrender/graphic/Group
 * @example
 *     var Group = require('zrender/container/Group');
 *     var Circle = require('zrender/graphic/shape/Circle');
 *     var g = new Group();
 *     g.position[0] = 100;
 *     g.position[1] = 100;
 *     g.add(new Circle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 20,
 *         }
 *     }));
 *     zr.add(g);
 */

/**
 * @alias module:zrender/graphic/Group
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @extends module:zrender/mixin/Eventful
 */
var Group = function (opts) {
  opts = opts || {};
  Element.call(this, opts);

  for (var key in opts) {
    if (opts.hasOwnProperty(key)) {
      this[key] = opts[key];
    }
  }

  this._children = [];
  this.__storage = null;
  this.__dirty = true;
};

Group.prototype = {
  constructor: Group,
  isGroup: true,

  /**
   * @type {string}
   */
  type: 'group',

  /**
   * 所有子孙元素是否响应鼠标事件
   * @name module:/zrender/container/Group#silent
   * @type {boolean}
   * @default false
   */
  silent: false,

  /**
   * @return {Array.<module:zrender/Element>}
   */
  children: function () {
    return this._children.slice();
  },

  /**
   * 获取指定 index 的儿子节点
   * @param  {number} idx
   * @return {module:zrender/Element}
   */
  childAt: function (idx) {
    return this._children[idx];
  },

  /**
   * 获取指定名字的儿子节点
   * @param  {string} name
   * @return {module:zrender/Element}
   */
  childOfName: function (name) {
    var children = this._children;

    for (var i = 0; i < children.length; i++) {
      if (children[i].name === name) {
        return children[i];
      }
    }
  },

  /**
   * @return {number}
   */
  childCount: function () {
    return this._children.length;
  },

  /**
   * 添加子节点到最后
   * @param {module:zrender/Element} child
   */
  add: function (child) {
    if (child && child !== this && child.parent !== this) {
      this._children.push(child);

      this._doAdd(child);
    }

    return this;
  },

  /**
   * 添加子节点在 nextSibling 之前
   * @param {module:zrender/Element} child
   * @param {module:zrender/Element} nextSibling
   */
  addBefore: function (child, nextSibling) {
    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
      var children = this._children;
      var idx = children.indexOf(nextSibling);

      if (idx >= 0) {
        children.splice(idx, 0, child);

        this._doAdd(child);
      }
    }

    return this;
  },
  _doAdd: function (child) {
    if (child.parent) {
      child.parent.remove(child);
    }

    child.parent = this;
    var storage = this.__storage;
    var zr = this.__zr;

    if (storage && storage !== child.__storage) {
      storage.addToStorage(child);

      if (child instanceof Group) {
        child.addChildrenToStorage(storage);
      }
    }

    zr && zr.refresh();
  },

  /**
   * 移除子节点
   * @param {module:zrender/Element} child
   */
  remove: function (child) {
    var zr = this.__zr;
    var storage = this.__storage;
    var children = this._children;
    var idx = zrUtil.indexOf(children, child);

    if (idx < 0) {
      return this;
    }

    children.splice(idx, 1);
    child.parent = null;

    if (storage) {
      storage.delFromStorage(child);

      if (child instanceof Group) {
        child.delChildrenFromStorage(storage);
      }
    }

    zr && zr.refresh();
    return this;
  },

  /**
   * 移除所有子节点
   */
  removeAll: function () {
    var children = this._children;
    var storage = this.__storage;
    var child;
    var i;

    for (i = 0; i < children.length; i++) {
      child = children[i];

      if (storage) {
        storage.delFromStorage(child);

        if (child instanceof Group) {
          child.delChildrenFromStorage(storage);
        }
      }

      child.parent = null;
    }

    children.length = 0;
    return this;
  },

  /**
   * 遍历所有子节点
   * @param  {Function} cb
   * @param  {}   context
   */
  eachChild: function (cb, context) {
    var children = this._children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      cb.call(context, child, i);
    }

    return this;
  },

  /**
   * 深度优先遍历所有子孙节点
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      cb.call(context, child);

      if (child.type === 'group') {
        child.traverse(cb, context);
      }
    }

    return this;
  },
  addChildrenToStorage: function (storage) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      storage.addToStorage(child);

      if (child instanceof Group) {
        child.addChildrenToStorage(storage);
      }
    }
  },
  delChildrenFromStorage: function (storage) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      storage.delFromStorage(child);

      if (child instanceof Group) {
        child.delChildrenFromStorage(storage);
      }
    }
  },
  dirty: function () {
    this.__dirty = true;
    this.__zr && this.__zr.refresh();
    return this;
  },

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function (includeChildren) {
    // TODO Caching
    var rect = null;
    var tmpRect = new BoundingRect(0, 0, 0, 0);
    var children = includeChildren || this._children;
    var tmpMat = [];

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (child.ignore || child.invisible) {
        continue;
      }

      var childRect = child.getBoundingRect();
      var transform = child.getLocalTransform(tmpMat); // TODO
      // The boundingRect cacluated by transforming original
      // rect may be bigger than the actual bundingRect when rotation
      // is used. (Consider a circle rotated aginst its center, where
      // the actual boundingRect should be the same as that not be
      // rotated.) But we can not find better approach to calculate
      // actual boundingRect yet, considering performance.

      if (transform) {
        tmpRect.copy(childRect);
        tmpRect.applyTransform(transform);
        rect = rect || tmpRect.clone();
        rect.union(tmpRect);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }

    return rect || tmpRect;
  }
};
zrUtil.inherits(Group, Element);
var _default = Group;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/BoundingRect.js":
/***/ (function(module, exports, __webpack_require__) {

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var matrix = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

/**
 * @module echarts/core/BoundingRect
 */
var v2ApplyTransform = vec2.applyTransform;
var mathMin = Math.min;
var mathMax = Math.max;
/**
 * @alias module:echarts/core/BoundingRect
 */

function BoundingRect(x, y, width, height) {
  if (width < 0) {
    x = x + width;
    width = -width;
  }

  if (height < 0) {
    y = y + height;
    height = -height;
  }
  /**
   * @type {number}
   */


  this.x = x;
  /**
   * @type {number}
   */

  this.y = y;
  /**
   * @type {number}
   */

  this.width = width;
  /**
   * @type {number}
   */

  this.height = height;
}

BoundingRect.prototype = {
  constructor: BoundingRect,

  /**
   * @param {module:echarts/core/BoundingRect} other
   */
  union: function (other) {
    var x = mathMin(other.x, this.x);
    var y = mathMin(other.y, this.y);
    this.width = mathMax(other.x + other.width, this.x + this.width) - x;
    this.height = mathMax(other.y + other.height, this.y + this.height) - y;
    this.x = x;
    this.y = y;
  },

  /**
   * @param {Array.<number>} m
   * @methods
   */
  applyTransform: function () {
    var lt = [];
    var rb = [];
    var lb = [];
    var rt = [];
    return function (m) {
      // In case usage like this
      // el.getBoundingRect().applyTransform(el.transform)
      // And element has no transform
      if (!m) {
        return;
      }

      lt[0] = lb[0] = this.x;
      lt[1] = rt[1] = this.y;
      rb[0] = rt[0] = this.x + this.width;
      rb[1] = lb[1] = this.y + this.height;
      v2ApplyTransform(lt, lt, m);
      v2ApplyTransform(rb, rb, m);
      v2ApplyTransform(lb, lb, m);
      v2ApplyTransform(rt, rt, m);
      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
      this.width = maxX - this.x;
      this.height = maxY - this.y;
    };
  }(),

  /**
   * Calculate matrix of transforming from self to target rect
   * @param  {module:zrender/core/BoundingRect} b
   * @return {Array.<number>}
   */
  calculateTransform: function (b) {
    var a = this;
    var sx = b.width / a.width;
    var sy = b.height / a.height;
    var m = matrix.create(); // 矩阵右乘

    matrix.translate(m, m, [-a.x, -a.y]);
    matrix.scale(m, m, [sx, sy]);
    matrix.translate(m, m, [b.x, b.y]);
    return m;
  },

  /**
   * @param {(module:echarts/core/BoundingRect|Object)} b
   * @return {boolean}
   */
  intersect: function (b) {
    if (!b) {
      return false;
    }

    if (!(b instanceof BoundingRect)) {
      // Normalize negative width/height.
      b = BoundingRect.create(b);
    }

    var a = this;
    var ax0 = a.x;
    var ax1 = a.x + a.width;
    var ay0 = a.y;
    var ay1 = a.y + a.height;
    var bx0 = b.x;
    var bx1 = b.x + b.width;
    var by0 = b.y;
    var by1 = b.y + b.height;
    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
  },
  contain: function (x, y) {
    var rect = this;
    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
  },

  /**
   * @return {module:echarts/core/BoundingRect}
   */
  clone: function () {
    return new BoundingRect(this.x, this.y, this.width, this.height);
  },

  /**
   * Copy from another rect
   */
  copy: function (other) {
    this.x = other.x;
    this.y = other.y;
    this.width = other.width;
    this.height = other.height;
  },
  plain: function () {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }
};
/**
 * @param {Object|module:zrender/core/BoundingRect} rect
 * @param {number} rect.x
 * @param {number} rect.y
 * @param {number} rect.width
 * @param {number} rect.height
 * @return {module:zrender/core/BoundingRect}
 */

BoundingRect.create = function (rect) {
  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
};

var _default = BoundingRect;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/GestureMgr.js":
/***/ (function(module, exports, __webpack_require__) {

var eventUtil = __webpack_require__("./node_modules/zrender/lib/core/event.js");

/**
 * Only implements needed gestures for mobile.
 */
var GestureMgr = function () {
  /**
   * @private
   * @type {Array.<Object>}
   */
  this._track = [];
};

GestureMgr.prototype = {
  constructor: GestureMgr,
  recognize: function (event, target, root) {
    this._doTrack(event, target, root);

    return this._recognize(event);
  },
  clear: function () {
    this._track.length = 0;
    return this;
  },
  _doTrack: function (event, target, root) {
    var touches = event.touches;

    if (!touches) {
      return;
    }

    var trackItem = {
      points: [],
      touches: [],
      target: target,
      event: event
    };

    for (var i = 0, len = touches.length; i < len; i++) {
      var touch = touches[i];
      var pos = eventUtil.clientToLocal(root, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }

    this._track.push(trackItem);
  },
  _recognize: function (event) {
    for (var eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        var gestureInfo = recognizers[eventName](this._track, event);

        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  }
};

function dist(pointPair) {
  var dx = pointPair[1][0] - pointPair[0][0];
  var dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}

function center(pointPair) {
  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
}

var recognizers = {
  pinch: function (track, event) {
    var trackLen = track.length;

    if (!trackLen) {
      return;
    }

    var pinchEnd = (track[trackLen - 1] || {}).points;
    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;

    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      var pinchScale = dist(pinchEnd) / dist(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      var pinchCenter = center(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: 'pinch',
        target: track[0].target,
        event: event
      };
    }
  } // Only pinch currently.

};
var _default = GestureMgr;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/LRU.js":
/***/ (function(module, exports) {

// Simple LRU cache use doubly linked list
// @module zrender/core/LRU

/**
 * Simple double linked list. Compared with array, it has O(1) remove operation.
 * @constructor
 */
var LinkedList = function () {
  /**
   * @type {module:zrender/core/LRU~Entry}
   */
  this.head = null;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.tail = null;
  this._len = 0;
};

var linkedListProto = LinkedList.prototype;
/**
 * Insert a new value at the tail
 * @param  {} val
 * @return {module:zrender/core/LRU~Entry}
 */

linkedListProto.insert = function (val) {
  var entry = new Entry(val);
  this.insertEntry(entry);
  return entry;
};
/**
 * Insert an entry at the tail
 * @param  {module:zrender/core/LRU~Entry} entry
 */


linkedListProto.insertEntry = function (entry) {
  if (!this.head) {
    this.head = this.tail = entry;
  } else {
    this.tail.next = entry;
    entry.prev = this.tail;
    entry.next = null;
    this.tail = entry;
  }

  this._len++;
};
/**
 * Remove entry.
 * @param  {module:zrender/core/LRU~Entry} entry
 */


linkedListProto.remove = function (entry) {
  var prev = entry.prev;
  var next = entry.next;

  if (prev) {
    prev.next = next;
  } else {
    // Is head
    this.head = next;
  }

  if (next) {
    next.prev = prev;
  } else {
    // Is tail
    this.tail = prev;
  }

  entry.next = entry.prev = null;
  this._len--;
};
/**
 * @return {number}
 */


linkedListProto.len = function () {
  return this._len;
};
/**
 * Clear list
 */


linkedListProto.clear = function () {
  this.head = this.tail = null;
  this._len = 0;
};
/**
 * @constructor
 * @param {} val
 */


var Entry = function (val) {
  /**
   * @type {}
   */
  this.value = val;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.next;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.prev;
};
/**
 * LRU Cache
 * @constructor
 * @alias module:zrender/core/LRU
 */


var LRU = function (maxSize) {
  this._list = new LinkedList();
  this._map = {};
  this._maxSize = maxSize || 10;
  this._lastRemovedEntry = null;
};

var LRUProto = LRU.prototype;
/**
 * @param  {string} key
 * @param  {} value
 * @return {} Removed value
 */

LRUProto.put = function (key, value) {
  var list = this._list;
  var map = this._map;
  var removed = null;

  if (map[key] == null) {
    var len = list.len(); // Reuse last removed entry

    var entry = this._lastRemovedEntry;

    if (len >= this._maxSize && len > 0) {
      // Remove the least recently used
      var leastUsedEntry = list.head;
      list.remove(leastUsedEntry);
      delete map[leastUsedEntry.key];
      removed = leastUsedEntry.value;
      this._lastRemovedEntry = leastUsedEntry;
    }

    if (entry) {
      entry.value = value;
    } else {
      entry = new Entry(value);
    }

    entry.key = key;
    list.insertEntry(entry);
    map[key] = entry;
  }

  return removed;
};
/**
 * @param  {string} key
 * @return {}
 */


LRUProto.get = function (key) {
  var entry = this._map[key];
  var list = this._list;

  if (entry != null) {
    // Put the latest used entry in the tail
    if (entry !== list.tail) {
      list.remove(entry);
      list.insertEntry(entry);
    }

    return entry.value;
  }
};
/**
 * Clear the cache
 */


LRUProto.clear = function () {
  this._list.clear();

  this._map = {};
};

var _default = LRU;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/PathProxy.js":
/***/ (function(module, exports, __webpack_require__) {

var curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var bbox = __webpack_require__("./node_modules/zrender/lib/core/bbox.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var _config = __webpack_require__("./node_modules/zrender/lib/config.js");

var dpr = _config.devicePixelRatio;

/**
 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
 * 可以用于 isInsidePath 判断以及获取boundingRect
 *
 * @module zrender/core/PathProxy
 * @author Yi Shen (http://www.github.com/pissang)
 */
// TODO getTotalLength, getPointAtLength
var CMD = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  // Rect
  R: 7
}; // var CMD_MEM_SIZE = {
//     M: 3,
//     L: 3,
//     C: 7,
//     Q: 5,
//     A: 9,
//     R: 5,
//     Z: 1
// };

var min = [];
var max = [];
var min2 = [];
var max2 = [];
var mathMin = Math.min;
var mathMax = Math.max;
var mathCos = Math.cos;
var mathSin = Math.sin;
var mathSqrt = Math.sqrt;
var mathAbs = Math.abs;
var hasTypedArray = typeof Float32Array != 'undefined';
/**
 * @alias module:zrender/core/PathProxy
 * @constructor
 */

var PathProxy = function (notSaveData) {
  this._saveData = !(notSaveData || false);

  if (this._saveData) {
    /**
     * Path data. Stored as flat array
     * @type {Array.<Object>}
     */
    this.data = [];
  }

  this._ctx = null;
};
/**
 * 快速计算Path包围盒（并不是最小包围盒）
 * @return {Object}
 */


PathProxy.prototype = {
  constructor: PathProxy,
  _xi: 0,
  _yi: 0,
  _x0: 0,
  _y0: 0,
  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
  _ux: 0,
  _uy: 0,
  _len: 0,
  _lineDash: null,
  _dashOffset: 0,
  _dashIdx: 0,
  _dashSum: 0,

  /**
   * @readOnly
   */
  setScale: function (sx, sy) {
    this._ux = mathAbs(1 / dpr / sx) || 0;
    this._uy = mathAbs(1 / dpr / sy) || 0;
  },
  getContext: function () {
    return this._ctx;
  },

  /**
   * @param  {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  beginPath: function (ctx) {
    this._ctx = ctx;
    ctx && ctx.beginPath();
    ctx && (this.dpr = ctx.dpr); // Reset

    if (this._saveData) {
      this._len = 0;
    }

    if (this._lineDash) {
      this._lineDash = null;
      this._dashOffset = 0;
    }

    return this;
  },

  /**
   * @param  {number} x
   * @param  {number} y
   * @return {module:zrender/core/PathProxy}
   */
  moveTo: function (x, y) {
    this.addData(CMD.M, x, y);
    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持

    this._x0 = x;
    this._y0 = y;
    this._xi = x;
    this._yi = y;
    return this;
  },

  /**
   * @param  {number} x
   * @param  {number} y
   * @return {module:zrender/core/PathProxy}
   */
  lineTo: function (x, y) {
    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
    || this._len < 5;
    this.addData(CMD.L, x, y);

    if (this._ctx && exceedUnit) {
      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
    }

    if (exceedUnit) {
      this._xi = x;
      this._yi = y;
    }

    return this;
  },

  /**
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @param  {number} x3
   * @param  {number} y3
   * @return {module:zrender/core/PathProxy}
   */
  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);

    if (this._ctx) {
      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
    }

    this._xi = x3;
    this._yi = y3;
    return this;
  },

  /**
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @return {module:zrender/core/PathProxy}
   */
  quadraticCurveTo: function (x1, y1, x2, y2) {
    this.addData(CMD.Q, x1, y1, x2, y2);

    if (this._ctx) {
      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
    }

    this._xi = x2;
    this._yi = y2;
    return this;
  },

  /**
   * @param  {number} cx
   * @param  {number} cy
   * @param  {number} r
   * @param  {number} startAngle
   * @param  {number} endAngle
   * @param  {boolean} anticlockwise
   * @return {module:zrender/core/PathProxy}
   */
  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
    this._xi = mathCos(endAngle) * r + cx;
    this._yi = mathSin(endAngle) * r + cx;
    return this;
  },
  // TODO
  arcTo: function (x1, y1, x2, y2, radius) {
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x2, y2, radius);
    }

    return this;
  },
  // TODO
  rect: function (x, y, w, h) {
    this._ctx && this._ctx.rect(x, y, w, h);
    this.addData(CMD.R, x, y, w, h);
    return this;
  },

  /**
   * @return {module:zrender/core/PathProxy}
   */
  closePath: function () {
    this.addData(CMD.Z);
    var ctx = this._ctx;
    var x0 = this._x0;
    var y0 = this._y0;

    if (ctx) {
      this._needsDash() && this._dashedLineTo(x0, y0);
      ctx.closePath();
    }

    this._xi = x0;
    this._yi = y0;
    return this;
  },

  /**
   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
   * stroke 同样
   * @param {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  fill: function (ctx) {
    ctx && ctx.fill();
    this.toStatic();
  },

  /**
   * @param {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  stroke: function (ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  },

  /**
   * 必须在其它绘制命令前调用
   * Must be invoked before all other path drawing methods
   * @return {module:zrender/core/PathProxy}
   */
  setLineDash: function (lineDash) {
    if (lineDash instanceof Array) {
      this._lineDash = lineDash;
      this._dashIdx = 0;
      var lineDashSum = 0;

      for (var i = 0; i < lineDash.length; i++) {
        lineDashSum += lineDash[i];
      }

      this._dashSum = lineDashSum;
    }

    return this;
  },

  /**
   * 必须在其它绘制命令前调用
   * Must be invoked before all other path drawing methods
   * @return {module:zrender/core/PathProxy}
   */
  setLineDashOffset: function (offset) {
    this._dashOffset = offset;
    return this;
  },

  /**
   *
   * @return {boolean}
   */
  len: function () {
    return this._len;
  },

  /**
   * 直接设置 Path 数据
   */
  setData: function (data) {
    var len = data.length;

    if (!(this.data && this.data.length == len) && hasTypedArray) {
      this.data = new Float32Array(len);
    }

    for (var i = 0; i < len; i++) {
      this.data[i] = data[i];
    }

    this._len = len;
  },

  /**
   * 添加子路径
   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
   */
  appendPath: function (path) {
    if (!(path instanceof Array)) {
      path = [path];
    }

    var len = path.length;
    var appendSize = 0;
    var offset = this._len;

    for (var i = 0; i < len; i++) {
      appendSize += path[i].len();
    }

    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset + appendSize);
    }

    for (var i = 0; i < len; i++) {
      var appendPathData = path[i].data;

      for (var k = 0; k < appendPathData.length; k++) {
        this.data[offset++] = appendPathData[k];
      }
    }

    this._len = offset;
  },

  /**
   * 填充 Path 数据。
   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
   */
  addData: function (cmd) {
    if (!this._saveData) {
      return;
    }

    var data = this.data;

    if (this._len + arguments.length > data.length) {
      // 因为之前的数组已经转换成静态的 Float32Array
      // 所以不够用时需要扩展一个新的动态数组
      this._expandData();

      data = this.data;
    }

    for (var i = 0; i < arguments.length; i++) {
      data[this._len++] = arguments[i];
    }

    this._prevCmd = cmd;
  },
  _expandData: function () {
    // Only if data is Float32Array
    if (!(this.data instanceof Array)) {
      var newData = [];

      for (var i = 0; i < this._len; i++) {
        newData[i] = this.data[i];
      }

      this.data = newData;
    }
  },

  /**
   * If needs js implemented dashed line
   * @return {boolean}
   * @private
   */
  _needsDash: function () {
    return this._lineDash;
  },
  _dashedLineTo: function (x1, y1) {
    var dashSum = this._dashSum;
    var offset = this._dashOffset;
    var lineDash = this._lineDash;
    var ctx = this._ctx;
    var x0 = this._xi;
    var y0 = this._yi;
    var dx = x1 - x0;
    var dy = y1 - y0;
    var dist = mathSqrt(dx * dx + dy * dy);
    var x = x0;
    var y = y0;
    var dash;
    var nDash = lineDash.length;
    var idx;
    dx /= dist;
    dy /= dist;

    if (offset < 0) {
      // Convert to positive offset
      offset = dashSum + offset;
    }

    offset %= dashSum;
    x -= offset * dx;
    y -= offset * dy;

    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
      idx = this._dashIdx;
      dash = lineDash[idx];
      x += dx * dash;
      y += dy * dash;
      this._dashIdx = (idx + 1) % nDash; // Skip positive offset

      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
        continue;
      }

      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
    } // Offset for next lineTo


    dx = x - x1;
    dy = y - y1;
    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
  },
  // Not accurate dashed line to
  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
    var dashSum = this._dashSum;
    var offset = this._dashOffset;
    var lineDash = this._lineDash;
    var ctx = this._ctx;
    var x0 = this._xi;
    var y0 = this._yi;
    var t;
    var dx;
    var dy;
    var cubicAt = curve.cubicAt;
    var bezierLen = 0;
    var idx = this._dashIdx;
    var nDash = lineDash.length;
    var x;
    var y;
    var tmpLen = 0;

    if (offset < 0) {
      // Convert to positive offset
      offset = dashSum + offset;
    }

    offset %= dashSum; // Bezier approx length

    for (t = 0; t < 1; t += 0.1) {
      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
      bezierLen += mathSqrt(dx * dx + dy * dy);
    } // Find idx after add offset


    for (; idx < nDash; idx++) {
      tmpLen += lineDash[idx];

      if (tmpLen > offset) {
        break;
      }
    }

    t = (tmpLen - offset) / bezierLen;

    while (t <= 1) {
      x = cubicAt(x0, x1, x2, x3, t);
      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
      // Bad result if dash is long

      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      t += lineDash[idx] / bezierLen;
      idx = (idx + 1) % nDash;
    } // Finish the last segment and calculate the new offset


    idx % 2 !== 0 && ctx.lineTo(x3, y3);
    dx = x3 - x;
    dy = y3 - y;
    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
  },
  _dashedQuadraticTo: function (x1, y1, x2, y2) {
    // Convert quadratic to cubic using degree elevation
    var x3 = x2;
    var y3 = y2;
    x2 = (x2 + 2 * x1) / 3;
    y2 = (y2 + 2 * y1) / 3;
    x1 = (this._xi + 2 * x1) / 3;
    y1 = (this._yi + 2 * y1) / 3;

    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
  },

  /**
   * 转成静态的 Float32Array 减少堆内存占用
   * Convert dynamic array to static Float32Array
   */
  toStatic: function () {
    var data = this.data;

    if (data instanceof Array) {
      data.length = this._len;

      if (hasTypedArray) {
        this.data = new Float32Array(data);
      }
    }
  },

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function () {
    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
    var data = this.data;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;

    for (var i = 0; i < data.length;) {
      var cmd = data[i++];

      if (i == 1) {
        // 如果第一个命令是 L, C, Q
        // 则 previous point 同绘制命令的第一个 point
        //
        // 第一个命令为 Arc 的情况下会在后面特殊处理
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }

      switch (cmd) {
        case CMD.M:
          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
          // 在 closePath 的时候使用
          x0 = data[i++];
          y0 = data[i++];
          xi = x0;
          yi = y0;
          min2[0] = x0;
          min2[1] = y0;
          max2[0] = x0;
          max2[1] = y0;
          break;

        case CMD.L:
          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.C:
          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.Q:
          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.A:
          // TODO Arc 判断的开销比较大
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var endAngle = data[i++] + startAngle; // TODO Arc 旋转

          var psi = data[i++];
          var anticlockwise = 1 - data[i++];

          if (i == 1) {
            // 直接使用 arc 命令
            // 第一个命令起点还未定义
            x0 = mathCos(startAngle) * rx + cx;
            y0 = mathSin(startAngle) * ry + cy;
          }

          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
          xi = mathCos(endAngle) * rx + cx;
          yi = mathSin(endAngle) * ry + cy;
          break;

        case CMD.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++]; // Use fromLine

          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
          break;

        case CMD.Z:
          xi = x0;
          yi = y0;
          break;
      } // Union


      vec2.min(min, min, min2);
      vec2.max(max, max, max2);
    } // No data


    if (i === 0) {
      min[0] = min[1] = max[0] = max[1] = 0;
    }

    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
  },

  /**
   * Rebuild path from current data
   * Rebuild path will not consider javascript implemented line dash.
   * @param {CanvasRenderingContext2D} ctx
   */
  rebuildPath: function (ctx) {
    var d = this.data;
    var x0, y0;
    var xi, yi;
    var x, y;
    var ux = this._ux;
    var uy = this._uy;
    var len = this._len;

    for (var i = 0; i < len;) {
      var cmd = d[i++];

      if (i == 1) {
        // 如果第一个命令是 L, C, Q
        // 则 previous point 同绘制命令的第一个 point
        //
        // 第一个命令为 Arc 的情况下会在后面特殊处理
        xi = d[i];
        yi = d[i + 1];
        x0 = xi;
        y0 = yi;
      }

      switch (cmd) {
        case CMD.M:
          x0 = xi = d[i++];
          y0 = yi = d[i++];
          ctx.moveTo(xi, yi);
          break;

        case CMD.L:
          x = d[i++];
          y = d[i++]; // Not draw too small seg between

          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
            ctx.lineTo(x, y);
            xi = x;
            yi = y;
          }

          break;

        case CMD.C:
          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
          xi = d[i - 2];
          yi = d[i - 1];
          break;

        case CMD.Q:
          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
          xi = d[i - 2];
          yi = d[i - 1];
          break;

        case CMD.A:
          var cx = d[i++];
          var cy = d[i++];
          var rx = d[i++];
          var ry = d[i++];
          var theta = d[i++];
          var dTheta = d[i++];
          var psi = d[i++];
          var fs = d[i++];
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          var isEllipse = Math.abs(rx - ry) > 1e-3;
          var endAngle = theta + dTheta;

          if (isEllipse) {
            ctx.translate(cx, cy);
            ctx.rotate(psi);
            ctx.scale(scaleX, scaleY);
            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
            ctx.scale(1 / scaleX, 1 / scaleY);
            ctx.rotate(-psi);
            ctx.translate(-cx, -cy);
          } else {
            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
          }

          if (i == 1) {
            // 直接使用 arc 命令
            // 第一个命令起点还未定义
            x0 = mathCos(theta) * rx + cx;
            y0 = mathSin(theta) * ry + cy;
          }

          xi = mathCos(endAngle) * rx + cx;
          yi = mathSin(endAngle) * ry + cy;
          break;

        case CMD.R:
          x0 = xi = d[i];
          y0 = yi = d[i + 1];
          ctx.rect(d[i++], d[i++], d[i++], d[i++]);
          break;

        case CMD.Z:
          ctx.closePath();
          xi = x0;
          yi = y0;
      }
    }
  }
};
PathProxy.CMD = CMD;
var _default = PathProxy;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/bbox.js":
/***/ (function(module, exports, __webpack_require__) {

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

/**
 * @author Yi Shen(https://github.com/pissang)
 */
var mathMin = Math.min;
var mathMax = Math.max;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI2 = Math.PI * 2;
var start = vec2.create();
var end = vec2.create();
var extremity = vec2.create();
/**
 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
 * @module zrender/core/bbox
 * @param {Array<Object>} points 顶点数组
 * @param {number} min
 * @param {number} max
 */

function fromPoints(points, min, max) {
  if (points.length === 0) {
    return;
  }

  var p = points[0];
  var left = p[0];
  var right = p[0];
  var top = p[1];
  var bottom = p[1];
  var i;

  for (i = 1; i < points.length; i++) {
    p = points[i];
    left = mathMin(left, p[0]);
    right = mathMax(right, p[0]);
    top = mathMin(top, p[1]);
    bottom = mathMax(bottom, p[1]);
  }

  min[0] = left;
  min[1] = top;
  max[0] = right;
  max[1] = bottom;
}
/**
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromLine(x0, y0, x1, y1, min, max) {
  min[0] = mathMin(x0, x1);
  min[1] = mathMin(y0, y1);
  max[0] = mathMax(x0, x1);
  max[1] = mathMax(y0, y1);
}

var xDim = [];
var yDim = [];
/**
 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */

function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
  var cubicExtrema = curve.cubicExtrema;
  var cubicAt = curve.cubicAt;
  var i;
  var n = cubicExtrema(x0, x1, x2, x3, xDim);
  min[0] = Infinity;
  min[1] = Infinity;
  max[0] = -Infinity;
  max[1] = -Infinity;

  for (i = 0; i < n; i++) {
    var x = cubicAt(x0, x1, x2, x3, xDim[i]);
    min[0] = mathMin(x, min[0]);
    max[0] = mathMax(x, max[0]);
  }

  n = cubicExtrema(y0, y1, y2, y3, yDim);

  for (i = 0; i < n; i++) {
    var y = cubicAt(y0, y1, y2, y3, yDim[i]);
    min[1] = mathMin(y, min[1]);
    max[1] = mathMax(y, max[1]);
  }

  min[0] = mathMin(x0, min[0]);
  max[0] = mathMax(x0, max[0]);
  min[0] = mathMin(x3, min[0]);
  max[0] = mathMax(x3, max[0]);
  min[1] = mathMin(y0, min[1]);
  max[1] = mathMax(y0, max[1]);
  min[1] = mathMin(y3, min[1]);
  max[1] = mathMax(y3, max[1]);
}
/**
 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
  var quadraticExtremum = curve.quadraticExtremum;
  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero

  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
  var x = quadraticAt(x0, x1, x2, tx);
  var y = quadraticAt(y0, y1, y2, ty);
  min[0] = mathMin(x0, x2, x);
  min[1] = mathMin(y0, y2, y);
  max[0] = mathMax(x0, x2, x);
  max[1] = mathMax(y0, y2, y);
}
/**
 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
 * @method
 * @memberOf module:zrender/core/bbox
 * @param {number} x
 * @param {number} y
 * @param {number} rx
 * @param {number} ry
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} anticlockwise
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
  var vec2Min = vec2.min;
  var vec2Max = vec2.max;
  var diff = Math.abs(startAngle - endAngle);

  if (diff % PI2 < 1e-4 && diff > 1e-4) {
    // Is a circle
    min[0] = x - rx;
    min[1] = y - ry;
    max[0] = x + rx;
    max[1] = y + ry;
    return;
  }

  start[0] = mathCos(startAngle) * rx + x;
  start[1] = mathSin(startAngle) * ry + y;
  end[0] = mathCos(endAngle) * rx + x;
  end[1] = mathSin(endAngle) * ry + y;
  vec2Min(min, start, end);
  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]

  startAngle = startAngle % PI2;

  if (startAngle < 0) {
    startAngle = startAngle + PI2;
  }

  endAngle = endAngle % PI2;

  if (endAngle < 0) {
    endAngle = endAngle + PI2;
  }

  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2;
  }

  if (anticlockwise) {
    var tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  } // var number = 0;
  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;


  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
    if (angle > startAngle) {
      extremity[0] = mathCos(angle) * rx + x;
      extremity[1] = mathSin(angle) * ry + y;
      vec2Min(min, extremity, min);
      vec2Max(max, extremity, max);
    }
  }
}

exports.fromPoints = fromPoints;
exports.fromLine = fromLine;
exports.fromCubic = fromCubic;
exports.fromQuadratic = fromQuadratic;
exports.fromArc = fromArc;

/***/ }),

/***/ "./node_modules/zrender/lib/core/curve.js":
/***/ (function(module, exports, __webpack_require__) {

var _vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var v2Create = _vector.create;
var v2DistSquare = _vector.distSquare;

/**
 * 曲线辅助模块
 * @module zrender/core/curve
 * @author pissang(https://www.github.com/pissang)
 */
var mathPow = Math.pow;
var mathSqrt = Math.sqrt;
var EPSILON = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt(3);
var ONE_THIRD = 1 / 3; // 临时变量

var _v0 = v2Create();

var _v1 = v2Create();

var _v2 = v2Create();

function isAroundZero(val) {
  return val > -EPSILON && val < EPSILON;
}

function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
/**
 * 计算三次贝塞尔值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */


function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
/**
 * 计算三次贝塞尔导数值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */


function cubicDerivativeAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}
/**
 * 计算三次贝塞尔方程根，使用盛金公式
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} val
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */


function cubicRootAt(p0, p1, p2, p3, val, roots) {
  // Evaluate roots of cubic functions
  var a = p3 + 3 * (p1 - p2) - p0;
  var b = 3 * (p2 - p1 * 2 + p0);
  var c = 3 * (p1 - p0);
  var d = p0 - val;
  var A = b * b - 3 * a * c;
  var B = b * c - 9 * a * d;
  var C = c * c - 3 * b * d;
  var n = 0;

  if (isAroundZero(A) && isAroundZero(B)) {
    if (isAroundZero(b)) {
      roots[0] = 0;
    } else {
      var t1 = -c / b; //t1, t2, t3, b is not zero

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    }
  } else {
    var disc = B * B - 4 * A * C;

    if (isAroundZero(disc)) {
      var K = B / A;
      var t1 = -b / a + K; // t1, a is not zero

      var t2 = -K / 2; // t2, t3

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
      var Y2 = A * b + 1.5 * a * (-B - discSqrt);

      if (Y1 < 0) {
        Y1 = -mathPow(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow(Y1, ONE_THIRD);
      }

      if (Y2 < 0) {
        Y2 = -mathPow(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow(Y2, ONE_THIRD);
      }

      var t1 = (-b - (Y1 + Y2)) / (3 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    } else {
      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
      var theta = Math.acos(T) / 3;
      var ASqrt = mathSqrt(A);
      var tmp = Math.cos(theta);
      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }

      if (t3 >= 0 && t3 <= 1) {
        roots[n++] = t3;
      }
    }
  }

  return n;
}
/**
 * 计算三次贝塞尔方程极限值的位置
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {Array.<number>} extrema
 * @return {number} 有效数目
 */


function cubicExtrema(p0, p1, p2, p3, extrema) {
  var b = 6 * p2 - 12 * p1 + 6 * p0;
  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
  var c = 3 * p1 - 3 * p0;
  var n = 0;

  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      var t1 = -c / b;

      if (t1 >= 0 && t1 <= 1) {
        extrema[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;

    if (isAroundZero(disc)) {
      extrema[0] = -b / (2 * a);
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        extrema[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        extrema[n++] = t2;
      }
    }
  }

  return n;
}
/**
 * 细分三次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {Array.<number>} out
 */


function cubicSubdivide(p0, p1, p2, p3, t, out) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p23 = (p3 - p2) * t + p2;
  var p012 = (p12 - p01) * t + p01;
  var p123 = (p23 - p12) * t + p12;
  var p0123 = (p123 - p012) * t + p012; // Seg0

  out[0] = p0;
  out[1] = p01;
  out[2] = p012;
  out[3] = p0123; // Seg1

  out[4] = p0123;
  out[5] = p123;
  out[6] = p23;
  out[7] = p3;
}
/**
 * 投射点到三次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} [out] 投射点
 * @return {number}
 */


function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
  // http://pomax.github.io/bezierinfo/#projections
  var t;
  var interval = 0.005;
  var d = Infinity;
  var prev;
  var next;
  var d1;
  var d2;
  _v0[0] = x;
  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
  // PENDING

  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
    d1 = v2DistSquare(_v0, _v1);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }

  d = Infinity; // At most 32 iteration

  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }

    prev = t - interval;
    next = t + interval; // t - interval

    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
    d1 = v2DistSquare(_v1, _v0);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      // t + interval
      _v2[0] = cubicAt(x0, x1, x2, x3, next);
      _v2[1] = cubicAt(y0, y1, y2, y3, next);
      d2 = v2DistSquare(_v2, _v0);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  } // t


  if (out) {
    out[0] = cubicAt(x0, x1, x2, x3, t);
    out[1] = cubicAt(y0, y1, y2, y3, t);
  } // console.log(interval, i);


  return mathSqrt(d);
}
/**
 * 计算二次方贝塞尔值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */


function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
/**
 * 计算二次方贝塞尔导数值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */


function quadraticDerivativeAt(p0, p1, p2, t) {
  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}
/**
 * 计算二次方贝塞尔方程根
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */


function quadraticRootAt(p0, p1, p2, val, roots) {
  var a = p0 - 2 * p1 + p2;
  var b = 2 * (p1 - p0);
  var c = p0 - val;
  var n = 0;

  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      var t1 = -c / b;

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;

    if (isAroundZero(disc)) {
      var t1 = -b / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }
    }
  }

  return n;
}
/**
 * 计算二次贝塞尔方程极限值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @return {number}
 */


function quadraticExtremum(p0, p1, p2) {
  var divider = p0 + p2 - 2 * p1;

  if (divider === 0) {
    // p1 is center of p0 and p2
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
/**
 * 细分二次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} out
 */


function quadraticSubdivide(p0, p1, p2, t, out) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p012 = (p12 - p01) * t + p01; // Seg0

  out[0] = p0;
  out[1] = p01;
  out[2] = p012; // Seg1

  out[3] = p012;
  out[4] = p12;
  out[5] = p2;
}
/**
 * 投射点到二次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} out 投射点
 * @return {number}
 */


function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
  // http://pomax.github.io/bezierinfo/#projections
  var t;
  var interval = 0.005;
  var d = Infinity;
  _v0[0] = x;
  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
  // PENDING

  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t);
    _v1[1] = quadraticAt(y0, y1, y2, _t);
    var d1 = v2DistSquare(_v0, _v1);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }

  d = Infinity; // At most 32 iteration

  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }

    var prev = t - interval;
    var next = t + interval; // t - interval

    _v1[0] = quadraticAt(x0, x1, x2, prev);
    _v1[1] = quadraticAt(y0, y1, y2, prev);
    var d1 = v2DistSquare(_v1, _v0);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      // t + interval
      _v2[0] = quadraticAt(x0, x1, x2, next);
      _v2[1] = quadraticAt(y0, y1, y2, next);
      var d2 = v2DistSquare(_v2, _v0);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  } // t


  if (out) {
    out[0] = quadraticAt(x0, x1, x2, t);
    out[1] = quadraticAt(y0, y1, y2, t);
  } // console.log(interval, i);


  return mathSqrt(d);
}

exports.cubicAt = cubicAt;
exports.cubicDerivativeAt = cubicDerivativeAt;
exports.cubicRootAt = cubicRootAt;
exports.cubicExtrema = cubicExtrema;
exports.cubicSubdivide = cubicSubdivide;
exports.cubicProjectPoint = cubicProjectPoint;
exports.quadraticAt = quadraticAt;
exports.quadraticDerivativeAt = quadraticDerivativeAt;
exports.quadraticRootAt = quadraticRootAt;
exports.quadraticExtremum = quadraticExtremum;
exports.quadraticSubdivide = quadraticSubdivide;
exports.quadraticProjectPoint = quadraticProjectPoint;

/***/ }),

/***/ "./node_modules/zrender/lib/core/env.js":
/***/ (function(module, exports) {

/**
 * echarts设备环境识别
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author firede[firede@firede.us]
 * @desc thanks zepto.
 */
var env = {};

if (typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function') {
  // In Weixin Application
  env = {
    browser: {},
    os: {},
    node: false,
    wxa: true,
    // Weixin Application
    canvasSupported: true,
    svgSupported: false,
    touchEventsSupported: true
  };
} else if (typeof document === 'undefined' && typeof self !== 'undefined') {
  // In worker
  env = {
    browser: {},
    os: {},
    node: false,
    worker: true,
    canvasSupported: true
  };
} else if (typeof navigator === 'undefined') {
  // In node
  env = {
    browser: {},
    os: {},
    node: true,
    worker: false,
    // Assume canvas is supported
    canvasSupported: true,
    svgSupported: true
  };
} else {
  env = detect(navigator.userAgent);
}

var _default = env; // Zepto.js
// (c) 2010-2013 Thomas Fuchs
// Zepto.js may be freely distributed under the MIT license.

function detect(ua) {
  var os = {};
  var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
  // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
  // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
  // var touchpad = webos && ua.match(/TouchPad/);
  // var kindle = ua.match(/Kindle\/([\d.]+)/);
  // var silk = ua.match(/Silk\/([\d._]+)/);
  // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
  // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
  // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
  // var playbook = ua.match(/PlayBook/);
  // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);

  var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;

  var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
  || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+

  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
  // - discern (more) between multiple browsers on android
  // - decide if kindle fire in silk mode is android or not
  // - Firefox on Android doesn't specify the Android version
  // - possibly devide in os, device and browser hashes
  // if (browser.webkit = !!webkit) browser.version = webkit[1];
  // if (android) os.android = true, os.version = android[2];
  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
  // if (webos) os.webos = true, os.version = webos[2];
  // if (touchpad) os.touchpad = true;
  // if (blackberry) os.blackberry = true, os.version = blackberry[2];
  // if (bb10) os.bb10 = true, os.version = bb10[2];
  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
  // if (playbook) browser.playbook = true;
  // if (kindle) os.kindle = true, os.version = kindle[1];
  // if (silk) browser.silk = true, browser.version = silk[1];
  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
  // if (chrome) browser.chrome = true, browser.version = chrome[1];

  if (firefox) {
    browser.firefox = true;
    browser.version = firefox[1];
  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
  // if (webview) browser.webview = true;


  if (ie) {
    browser.ie = true;
    browser.version = ie[1];
  }

  if (edge) {
    browser.edge = true;
    browser.version = edge[1];
  } // It is difficult to detect WeChat in Win Phone precisely, because ua can
  // not be set on win phone. So we do not consider Win Phone.


  if (weChat) {
    browser.weChat = true;
  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));


  return {
    browser: browser,
    os: os,
    node: false,
    // 原生canvas支持，改极端点了
    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
    canvasSupported: !!document.createElement('canvas').getContext,
    svgSupported: typeof SVGRect !== 'undefined',
    // works on most browsers
    // IE10/11 does not support touch event, and MS Edge supports them but not by
    // default, so we dont check navigator.maxTouchPoints for them here.
    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
    // <http://caniuse.com/#search=pointer%20event>.
    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
    // events currently. So we dont use that on other browsers unless tested sufficiently.
    // Although IE 10 supports pointer event, it use old style and is different from the
    // standard. So we exclude that. (IE 10 is hardly used on touch device)
    && (browser.edge || browser.ie && browser.version >= 11) // passiveSupported: detectPassiveSupport()

  };
} // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
// function detectPassiveSupport() {
//     // Test via a getter in the options object to see if the passive property is accessed
//     var supportsPassive = false;
//     try {
//         var opts = Object.defineProperty({}, 'passive', {
//             get: function() {
//                 supportsPassive = true;
//             }
//         });
//         window.addEventListener('testPassive', function() {}, opts);
//     } catch (e) {
//     }
//     return supportsPassive;
// }


module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/event.js":
/***/ (function(module, exports, __webpack_require__) {

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

exports.Dispatcher = Eventful;

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

/**
 * 事件辅助类
 * @module zrender/core/event
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */
var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;

function getBoundingClientRect(el) {
  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
  return el.getBoundingClientRect ? el.getBoundingClientRect() : {
    left: 0,
    top: 0
  };
} // `calculate` is optional, default false


function clientToLocal(el, e, out, calculate) {
  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
  // to the padding edge of the target element. The only browser using this convention
  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
  // not support the properties.
  // (see http://www.jacklmoore.com/notes/mouse-position/)
  // In zr painter.dom, padding edge equals to border edge.
  // FIXME
  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
  // is too complex. So css-transfrom dont support in this case temporarily.

  if (calculate || !env.canvasSupported) {
    defaultGetZrXY(el, e, out);
  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
  // ancestor element, so we should make sure el is positioned (e.g., not position:static).
  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
  // zoom-factor, overflow / opacity layers, transforms ...)
  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
  // <https://bugs.jquery.com/ticket/8523#comment:14>
  // BTW3, In ff, offsetX/offsetY is always 0.
  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
      out.zrX = e.layerX;
      out.zrY = e.layerY;
    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
    else if (e.offsetX != null) {
        out.zrX = e.offsetX;
        out.zrY = e.offsetY;
      } // For some other device, e.g., IOS safari.
      else {
          defaultGetZrXY(el, e, out);
        }

  return out;
}

function defaultGetZrXY(el, e, out) {
  // This well-known method below does not support css transform.
  var box = getBoundingClientRect(el);
  out.zrX = e.clientX - box.left;
  out.zrY = e.clientY - box.top;
}
/**
 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
 * `calculate` is optional, default false.
 */


function normalizeEvent(el, e, calculate) {
  e = e || window.event;

  if (e.zrX != null) {
    return e;
  }

  var eventType = e.type;
  var isTouch = eventType && eventType.indexOf('touch') >= 0;

  if (!isTouch) {
    clientToLocal(el, e, e, calculate);
    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
  } else {
    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
    touch && clientToLocal(el, touch, e, calculate);
  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
  // If e.which has been defined, if may be readonly,
  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which


  var button = e.button;

  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }

  return e;
}
/**
 * @param {HTMLElement} el
 * @param {string} name
 * @param {Function} handler
 */


function addEventListener(el, name, handler) {
  if (isDomLevel2) {
    // Reproduct the console warning:
    // [Violation] Added non-passive event listener to a scroll-blocking <some> event.
    // Consider marking event handler as 'passive' to make the page more responsive.
    // Just set console log level: verbose in chrome dev tool.
    // then the warning log will be printed when addEventListener called.
    // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
    // We have not yet found a neat way to using passive. Because in zrender the dom event
    // listener delegate all of the upper events of element. Some of those events need
    // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.
    // Before passive can be adopted, these issues should be considered:
    // (1) Whether and how a zrender user specifies an event listener passive. And by default,
    // passive or not.
    // (2) How to tread that some zrender event listener is passive, and some is not. If
    // we use other way but not preventDefault of mousewheel and touchmove, browser
    // compatibility should be handled.
    // var opts = (env.passiveSupported && name === 'mousewheel')
    //     ? {passive: true}
    //     // By default, the third param of el.addEventListener is `capture: false`.
    //     : void 0;
    // el.addEventListener(name, handler /* , opts */);
    el.addEventListener(name, handler);
  } else {
    el.attachEvent('on' + name, handler);
  }
}

function removeEventListener(el, name, handler) {
  if (isDomLevel2) {
    el.removeEventListener(name, handler);
  } else {
    el.detachEvent('on' + name, handler);
  }
}
/**
 * preventDefault and stopPropagation.
 * Notice: do not do that in zrender. Upper application
 * do that if necessary.
 *
 * @memberOf module:zrender/core/event
 * @method
 * @param {Event} e : event对象
 */


var stop = isDomLevel2 ? function (e) {
  e.preventDefault();
  e.stopPropagation();
  e.cancelBubble = true;
} : function (e) {
  e.returnValue = false;
  e.cancelBubble = true;
};

function notLeftMouse(e) {
  // If e.which is undefined, considered as left mouse event.
  return e.which > 1;
} // 做向上兼容


exports.clientToLocal = clientToLocal;
exports.normalizeEvent = normalizeEvent;
exports.addEventListener = addEventListener;
exports.removeEventListener = removeEventListener;
exports.stop = stop;
exports.notLeftMouse = notLeftMouse;

/***/ }),

/***/ "./node_modules/zrender/lib/core/guid.js":
/***/ (function(module, exports) {

/**
 * zrender: 生成唯一id
 *
 * @author errorrik (errorrik@gmail.com)
 */
var idStart = 0x0907;

function _default() {
  return idStart++;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/log.js":
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__("./node_modules/zrender/lib/config.js");

var debugMode = _config.debugMode;

var log = function () {};

if (debugMode === 1) {
  log = function () {
    for (var k in arguments) {
      throw new Error(arguments[k]);
    }
  };
} else if (debugMode > 1) {
  log = function () {
    for (var k in arguments) {
      console.log(arguments[k]);
    }
  };
}

var _default = log;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/core/matrix.js":
/***/ (function(module, exports) {

/**
 * 3x2矩阵操作类
 * @exports zrender/tool/matrix
 */
var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
/**
 * Create a identity matrix.
 * @return {Float32Array|Array.<number>}
 */

function create() {
  var out = new ArrayCtor(6);
  identity(out);
  return out;
}
/**
 * 设置矩阵为单位矩阵
 * @param {Float32Array|Array.<number>} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * 复制矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m
 */


function copy(out, m) {
  out[0] = m[0];
  out[1] = m[1];
  out[2] = m[2];
  out[3] = m[3];
  out[4] = m[4];
  out[5] = m[5];
  return out;
}
/**
 * 矩阵相乘
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m1
 * @param {Float32Array|Array.<number>} m2
 */


function mul(out, m1, m2) {
  // Consider matrix.mul(m, m2, m);
  // where out is the same as m2.
  // So use temp variable to escape error.
  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
  var out2 = m1[0] * m2[2] + m1[2] * m2[3];
  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = out3;
  out[4] = out4;
  out[5] = out5;
  return out;
}
/**
 * 平移变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */


function translate(out, a, v) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4] + v[0];
  out[5] = a[5] + v[1];
  return out;
}
/**
 * 旋转变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {number} rad
 */


function rotate(out, a, rad) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var st = Math.sin(rad);
  var ct = Math.cos(rad);
  out[0] = aa * ct + ab * st;
  out[1] = -aa * st + ab * ct;
  out[2] = ac * ct + ad * st;
  out[3] = -ac * st + ct * ad;
  out[4] = ct * atx + st * aty;
  out[5] = ct * aty - st * atx;
  return out;
}
/**
 * 缩放变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */


function scale(out, a, v) {
  var vx = v[0];
  var vy = v[1];
  out[0] = a[0] * vx;
  out[1] = a[1] * vy;
  out[2] = a[2] * vx;
  out[3] = a[3] * vy;
  out[4] = a[4] * vx;
  out[5] = a[5] * vy;
  return out;
}
/**
 * 求逆矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 */


function invert(out, a) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Clone a new matrix.
 * @param {Float32Array|Array.<number>} a
 */


function clone(a) {
  var b = create();
  copy(b, a);
  return b;
}

exports.create = create;
exports.identity = identity;
exports.copy = copy;
exports.mul = mul;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.invert = invert;
exports.clone = clone;

/***/ }),

/***/ "./node_modules/zrender/lib/core/timsort.js":
/***/ (function(module, exports) {

// https://github.com/mziccard/node-timsort
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
var DEFAULT_TMP_STORAGE_LENGTH = 256;

function minRunLength(n) {
  var r = 0;

  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }

  return n + r;
}

function makeAscendingRun(array, lo, hi, compare) {
  var runHi = lo + 1;

  if (runHi === hi) {
    return 1;
  }

  if (compare(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }

    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }

  return runHi - lo;
}

function reverseRun(array, lo, hi) {
  hi--;

  while (lo < hi) {
    var t = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t;
  }
}

function binaryInsertionSort(array, lo, hi, start, compare) {
  if (start === lo) {
    start++;
  }

  for (; start < hi; start++) {
    var pivot = array[start];
    var left = lo;
    var right = start;
    var mid;

    while (left < right) {
      mid = left + right >>> 1;

      if (compare(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }

    var n = start - left;

    switch (n) {
      case 3:
        array[left + 3] = array[left + 2];

      case 2:
        array[left + 2] = array[left + 1];

      case 1:
        array[left + 1] = array[left];
        break;

      default:
        while (n > 0) {
          array[left + n] = array[left + n - 1];
          n--;
        }

    }

    array[left] = pivot;
  }
}

function gallopLeft(value, array, start, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;

  if (compare(value, array[start + hint]) > 0) {
    maxOffset = length - hint;

    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;

    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }

  lastOffset++;

  while (lastOffset < offset) {
    var m = lastOffset + (offset - lastOffset >>> 1);

    if (compare(value, array[start + m]) > 0) {
      lastOffset = m + 1;
    } else {
      offset = m;
    }
  }

  return offset;
}

function gallopRight(value, array, start, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;

  if (compare(value, array[start + hint]) < 0) {
    maxOffset = hint + 1;

    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length - hint;

    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    lastOffset += hint;
    offset += hint;
  }

  lastOffset++;

  while (lastOffset < offset) {
    var m = lastOffset + (offset - lastOffset >>> 1);

    if (compare(value, array[start + m]) < 0) {
      offset = m;
    } else {
      lastOffset = m + 1;
    }
  }

  return offset;
}

function TimSort(array, compare) {
  var minGallop = DEFAULT_MIN_GALLOPING;
  var length = 0;
  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
  var stackLength = 0;
  var runStart;
  var runLength;
  var stackSize = 0;
  length = array.length;

  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
    tmpStorageLength = length >>> 1;
  }

  var tmp = [];
  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
  runStart = [];
  runLength = [];

  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }

  function mergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;

      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
        if (runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
      } else if (runLength[n] > runLength[n + 1]) {
        break;
      }

      mergeAt(n);
    }
  }

  function forceMergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;

      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
        n--;
      }

      mergeAt(n);
    }
  }

  function mergeAt(i) {
    var start1 = runStart[i];
    var length1 = runLength[i];
    var start2 = runStart[i + 1];
    var length2 = runLength[i + 1];
    runLength[i] = length1 + length2;

    if (i === stackSize - 3) {
      runStart[i + 1] = runStart[i + 2];
      runLength[i + 1] = runLength[i + 2];
    }

    stackSize--;
    var k = gallopRight(array[start2], array, start1, length1, 0, compare);
    start1 += k;
    length1 -= k;

    if (length1 === 0) {
      return;
    }

    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

    if (length2 === 0) {
      return;
    }

    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }

  function mergeLow(start1, length1, start2, length2) {
    var i = 0;

    for (i = 0; i < length1; i++) {
      tmp[i] = array[start1 + i];
    }

    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];

    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }

      return;
    }

    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }

      array[dest + length2] = tmp[cursor1];
      return;
    }

    var _minGallop = minGallop;
    var count1, count2, exit;

    while (1) {
      count1 = 0;
      count2 = 0;
      exit = false;

      do {
        if (compare(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count2++;
          count1 = 0;

          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;

          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);

      if (exit) {
        break;
      }

      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }

          dest += count1;
          cursor1 += count1;
          length1 -= count1;

          if (length1 <= 1) {
            exit = true;
            break;
          }
        }

        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
          exit = true;
          break;
        }

        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          dest += count2;
          cursor2 += count2;
          length2 -= count2;

          if (length2 === 0) {
            exit = true;
            break;
          }
        }

        array[dest++] = tmp[cursor1++];

        if (--length1 === 1) {
          exit = true;
          break;
        }

        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

      if (exit) {
        break;
      }

      if (_minGallop < 0) {
        _minGallop = 0;
      }

      _minGallop += 2;
    }

    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);

    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }

      array[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error(); // throw new Error('mergeLow preconditions were not respected');
    } else {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
    }
  }

  function mergeHigh(start1, length1, start2, length2) {
    var i = 0;

    for (i = 0; i < length2; i++) {
      tmp[i] = array[start2 + i];
    }

    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];

    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);

      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }

      return;
    }

    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;

      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }

      array[dest] = tmp[cursor2];
      return;
    }

    var _minGallop = minGallop;

    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;

      do {
        if (compare(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count2 = 0;

          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;

          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);

      if (exit) {
        break;
      }

      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = count1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          if (length1 === 0) {
            exit = true;
            break;
          }
        }

        array[dest--] = tmp[cursor2--];

        if (--length2 === 1) {
          exit = true;
          break;
        }

        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;

          for (i = 0; i < count2; i++) {
            array[customDest + i] = tmp[customCursor + i];
          }

          if (length2 <= 1) {
            exit = true;
            break;
          }
        }

        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
          exit = true;
          break;
        }

        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

      if (exit) {
        break;
      }

      if (_minGallop < 0) {
        _minGallop = 0;
      }

      _minGallop += 2;
    }

    minGallop = _minGallop;

    if (minGallop < 1) {
      minGallop = 1;
    }

    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;

      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }

      array[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
    } else {
      customCursor = dest - (length2 - 1);

      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
    }
  }

  this.mergeRuns = mergeRuns;
  this.forceMergeRuns = forceMergeRuns;
  this.pushRun = pushRun;
}

function sort(array, compare, lo, hi) {
  if (!lo) {
    lo = 0;
  }

  if (!hi) {
    hi = array.length;
  }

  var remaining = hi - lo;

  if (remaining < 2) {
    return;
  }

  var runLength = 0;

  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
    return;
  }

  var ts = new TimSort(array, compare);
  var minRun = minRunLength(remaining);

  do {
    runLength = makeAscendingRun(array, lo, hi, compare);

    if (runLength < minRun) {
      var force = remaining;

      if (force > minRun) {
        force = minRun;
      }

      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
      runLength = force;
    }

    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);

  ts.forceMergeRuns();
}

module.exports = sort;

/***/ }),

/***/ "./node_modules/zrender/lib/core/util.js":
/***/ (function(module, exports) {

/**
 * @module zrender/core/util
 */
// 用于处理merge时无法遍历Date等对象的问题
var BUILTIN_OBJECT = {
  '[object Function]': 1,
  '[object RegExp]': 1,
  '[object Date]': 1,
  '[object Error]': 1,
  '[object CanvasGradient]': 1,
  '[object CanvasPattern]': 1,
  // For node-canvas
  '[object Image]': 1,
  '[object Canvas]': 1
};
var TYPED_ARRAY = {
  '[object Int8Array]': 1,
  '[object Uint8Array]': 1,
  '[object Uint8ClampedArray]': 1,
  '[object Int16Array]': 1,
  '[object Uint16Array]': 1,
  '[object Int32Array]': 1,
  '[object Uint32Array]': 1,
  '[object Float32Array]': 1,
  '[object Float64Array]': 1
};
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.

var methods = {};

function $override(name, fn) {
  // Clear ctx instance for different environment
  if (name === 'createCanvas') {
    _ctx = null;
  }

  methods[name] = fn;
}
/**
 * Those data types can be cloned:
 *     Plain object, Array, TypedArray, number, string, null, undefined.
 * Those data types will be assgined using the orginal data:
 *     BUILTIN_OBJECT
 * Instance of user defined class will be cloned to a plain object, without
 * properties in prototype.
 * Other data types is not supported (not sure what will happen).
 *
 * Caution: do not support clone Date, for performance consideration.
 * (There might be a large number of date in `series.data`).
 * So date should not be modified in and out of echarts.
 *
 * @param {*} source
 * @return {*} new
 */


function clone(source) {
  if (source == null || typeof source != 'object') {
    return source;
  }

  var result = source;
  var typeStr = objToString.call(source);

  if (typeStr === '[object Array]') {
    if (!isPrimitive(source)) {
      result = [];

      for (var i = 0, len = source.length; i < len; i++) {
        result[i] = clone(source[i]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source)) {
      var Ctor = source.constructor;

      if (source.constructor.from) {
        result = Ctor.from(source);
      } else {
        result = new Ctor(source.length);

        for (var i = 0, len = source.length; i < len; i++) {
          result[i] = clone(source[i]);
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};

    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        result[key] = clone(source[key]);
      }
    }
  }

  return result;
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overwrite=false]
 */


function merge(target, source, overwrite) {
  // We should escapse that source is string
  // and enter for ... in ...
  if (!isObject(source) || !isObject(target)) {
    return overwrite ? clone(source) : target;
  }

  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      var targetProp = target[key];
      var sourceProp = source[key];

      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        // 如果需要递归覆盖，就递归调用merge
        merge(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
        // NOTE，在 target[key] 不存在的时候也是直接覆盖
        target[key] = clone(source[key], true);
      }
    }
  }

  return target;
}
/**
 * @param {Array} targetAndSources The first item is target, and the rests are source.
 * @param {boolean} [overwrite=false]
 * @return {*} target
 */


function mergeAll(targetAndSources, overwrite) {
  var result = targetAndSources[0];

  for (var i = 1, len = targetAndSources.length; i < len; i++) {
    result = merge(result, targetAndSources[i], overwrite);
  }

  return result;
}
/**
 * @param {*} target
 * @param {*} source
 * @memberOf module:zrender/core/util
 */


function extend(target, source) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }

  return target;
}
/**
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overlay=false]
 * @memberOf module:zrender/core/util
 */


function defaults(target, source, overlay) {
  for (var key in source) {
    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
      target[key] = source[key];
    }
  }

  return target;
}

var createCanvas = function () {
  return methods.createCanvas();
};

methods.createCanvas = function () {
  return document.createElement('canvas');
}; // FIXME


var _ctx;

function getContext() {
  if (!_ctx) {
    // Use util.createCanvas instead of createCanvas
    // because createCanvas may be overwritten in different environment
    _ctx = createCanvas().getContext('2d');
  }

  return _ctx;
}
/**
 * 查询数组中元素的index
 * @memberOf module:zrender/core/util
 */


function indexOf(array, value) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value);
    }

    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
  }

  return -1;
}
/**
 * 构造类继承关系
 *
 * @memberOf module:zrender/core/util
 * @param {Function} clazz 源类
 * @param {Function} baseClazz 基类
 */


function inherits(clazz, baseClazz) {
  var clazzPrototype = clazz.prototype;

  function F() {}

  F.prototype = baseClazz.prototype;
  clazz.prototype = new F();

  for (var prop in clazzPrototype) {
    clazz.prototype[prop] = clazzPrototype[prop];
  }

  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
/**
 * @memberOf module:zrender/core/util
 * @param {Object|Function} target
 * @param {Object|Function} sorce
 * @param {boolean} overlay
 */


function mixin(target, source, overlay) {
  target = 'prototype' in target ? target.prototype : target;
  source = 'prototype' in source ? source.prototype : source;
  defaults(target, source, overlay);
}
/**
 * Consider typed array.
 * @param {Array|TypedArray} data
 */


function isArrayLike(data) {
  if (!data) {
    return;
  }

  if (typeof data == 'string') {
    return false;
  }

  return typeof data.length == 'number';
}
/**
 * 数组或对象遍历
 * @memberOf module:zrender/core/util
 * @param {Object|Array} obj
 * @param {Function} cb
 * @param {*} [context]
 */


function each(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.forEach && obj.forEach === nativeForEach) {
    obj.forEach(cb, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, len = obj.length; i < len; i++) {
      cb.call(context, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        cb.call(context, obj[key], key, obj);
      }
    }
  }
}
/**
 * 数组映射
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */


function map(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.map && obj.map === nativeMap) {
    return obj.map(cb, context);
  } else {
    var result = [];

    for (var i = 0, len = obj.length; i < len; i++) {
      result.push(cb.call(context, obj[i], i, obj));
    }

    return result;
  }
}
/**
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {Object} [memo]
 * @param {*} [context]
 * @return {Array}
 */


function reduce(obj, cb, memo, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.reduce && obj.reduce === nativeReduce) {
    return obj.reduce(cb, memo, context);
  } else {
    for (var i = 0, len = obj.length; i < len; i++) {
      memo = cb.call(context, memo, obj[i], i, obj);
    }

    return memo;
  }
}
/**
 * 数组过滤
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */


function filter(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.filter && obj.filter === nativeFilter) {
    return obj.filter(cb, context);
  } else {
    var result = [];

    for (var i = 0, len = obj.length; i < len; i++) {
      if (cb.call(context, obj[i], i, obj)) {
        result.push(obj[i]);
      }
    }

    return result;
  }
}
/**
 * 数组项查找
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {*}
 */


function find(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  for (var i = 0, len = obj.length; i < len; i++) {
    if (cb.call(context, obj[i], i, obj)) {
      return obj[i];
    }
  }
}
/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @param {*} context
 * @return {Function}
 */


function bind(func, context) {
  var args = nativeSlice.call(arguments, 2);
  return function () {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @return {Function}
 */


function curry(func) {
  var args = nativeSlice.call(arguments, 1);
  return function () {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isArray(value) {
  return objToString.call(value) === '[object Array]';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isFunction(value) {
  return typeof value === 'function';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isString(value) {
  return objToString.call(value) === '[object String]';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type === 'function' || !!value && type == 'object';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isTypedArray(value) {
  return !!TYPED_ARRAY[objToString.call(value)];
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isDom(value) {
  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
}
/**
 * Whether is exactly NaN. Notice isNaN('a') returns true.
 * @param {*} value
 * @return {boolean}
 */


function eqNaN(value) {
  return value !== value;
}
/**
 * If value1 is not null, then return value1, otherwise judget rest of values.
 * Low performance.
 * @memberOf module:zrender/core/util
 * @return {*} Final value
 */


function retrieve(values) {
  for (var i = 0, len = arguments.length; i < len; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }
}

function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}

function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
/**
 * @memberOf module:zrender/core/util
 * @param {Array} arr
 * @param {number} startIndex
 * @param {number} endIndex
 * @return {Array}
 */


function slice() {
  return Function.call.apply(nativeSlice, arguments);
}
/**
 * Normalize css liked array configuration
 * e.g.
 *  3 => [3, 3, 3, 3]
 *  [4, 2] => [4, 2, 4, 2]
 *  [4, 3, 2] => [4, 3, 2, 3]
 * @param {number|Array.<number>} val
 * @return {Array.<number>}
 */


function normalizeCssArray(val) {
  if (typeof val === 'number') {
    return [val, val, val, val];
  }

  var len = val.length;

  if (len === 2) {
    // vertical | horizontal
    return [val[0], val[1], val[0], val[1]];
  } else if (len === 3) {
    // top | horizontal | bottom
    return [val[0], val[1], val[2], val[1]];
  }

  return val;
}
/**
 * @memberOf module:zrender/core/util
 * @param {boolean} condition
 * @param {string} message
 */


function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
/**
 * @memberOf module:zrender/core/util
 * @param {string} str string to be trimed
 * @return {string} trimed string
 */


function trim(str) {
  if (str == null) {
    return null;
  } else if (typeof str.trim === 'function') {
    return str.trim();
  } else {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  }
}

var primitiveKey = '__ec_primitive__';
/**
 * Set an object as primitive to be ignored traversing children in clone or merge
 */

function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}

function isPrimitive(obj) {
  return obj[primitiveKey];
}
/**
 * @constructor
 * @param {Object} obj Only apply `ownProperty`.
 */


function HashMap(obj) {
  var isArr = isArray(obj);
  var thisMap = this;
  obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);

  function visit(value, key) {
    isArr ? thisMap.set(value, key) : thisMap.set(key, value);
  }
} // Add prefix to avoid conflict with Object.prototype.


HashMap.prototype = {
  constructor: HashMap,
  // Do not provide `has` method to avoid defining what is `has`.
  // (We usually treat `null` and `undefined` as the same, different
  // from ES6 Map).
  get: function (key) {
    return this.hasOwnProperty(key) ? this[key] : null;
  },
  set: function (key, value) {
    // Comparing with invocation chaining, `return value` is more commonly
    // used in this case: `var someVal = map.set('a', genVal());`
    return this[key] = value;
  },
  // Although util.each can be performed on this hashMap directly, user
  // should not use the exposed keys, who are prefixed.
  each: function (cb, context) {
    context !== void 0 && (cb = bind(cb, context));

    for (var key in this) {
      this.hasOwnProperty(key) && cb(this[key], key);
    }
  },
  // Do not use this method if performance sensitive.
  removeKey: function (key) {
    delete this[key];
  }
};

function createHashMap(obj) {
  return new HashMap(obj);
}

function concatArray(a, b) {
  var newArray = new a.constructor(a.length + b.length);

  for (var i = 0; i < a.length; i++) {
    newArray[i] = a[i];
  }

  var offset = a.length;

  for (i = 0; i < b.length; i++) {
    newArray[i + offset] = b[i];
  }

  return newArray;
}

function noop() {}

exports.$override = $override;
exports.clone = clone;
exports.merge = merge;
exports.mergeAll = mergeAll;
exports.extend = extend;
exports.defaults = defaults;
exports.createCanvas = createCanvas;
exports.getContext = getContext;
exports.indexOf = indexOf;
exports.inherits = inherits;
exports.mixin = mixin;
exports.isArrayLike = isArrayLike;
exports.each = each;
exports.map = map;
exports.reduce = reduce;
exports.filter = filter;
exports.find = find;
exports.bind = bind;
exports.curry = curry;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isString = isString;
exports.isObject = isObject;
exports.isBuiltInObject = isBuiltInObject;
exports.isTypedArray = isTypedArray;
exports.isDom = isDom;
exports.eqNaN = eqNaN;
exports.retrieve = retrieve;
exports.retrieve2 = retrieve2;
exports.retrieve3 = retrieve3;
exports.slice = slice;
exports.normalizeCssArray = normalizeCssArray;
exports.assert = assert;
exports.trim = trim;
exports.setAsPrimitive = setAsPrimitive;
exports.isPrimitive = isPrimitive;
exports.createHashMap = createHashMap;
exports.concatArray = concatArray;
exports.noop = noop;

/***/ }),

/***/ "./node_modules/zrender/lib/core/vector.js":
/***/ (function(module, exports) {

var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
/**
 * 创建一个向量
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @return {Vector2}
 */

function create(x, y) {
  var out = new ArrayCtor(2);

  if (x == null) {
    x = 0;
  }

  if (y == null) {
    y = 0;
  }

  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * 复制向量数据
 * @param {Vector2} out
 * @param {Vector2} v
 * @return {Vector2}
 */


function copy(out, v) {
  out[0] = v[0];
  out[1] = v[1];
  return out;
}
/**
 * 克隆一个向量
 * @param {Vector2} v
 * @return {Vector2}
 */


function clone(v) {
  var out = new ArrayCtor(2);
  out[0] = v[0];
  out[1] = v[1];
  return out;
}
/**
 * 设置向量的两个项
 * @param {Vector2} out
 * @param {number} a
 * @param {number} b
 * @return {Vector2} 结果
 */


function set(out, a, b) {
  out[0] = a;
  out[1] = b;
  return out;
}
/**
 * 向量相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function add(out, v1, v2) {
  out[0] = v1[0] + v2[0];
  out[1] = v1[1] + v2[1];
  return out;
}
/**
 * 向量缩放后相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} a
 */


function scaleAndAdd(out, v1, v2, a) {
  out[0] = v1[0] + v2[0] * a;
  out[1] = v1[1] + v2[1] * a;
  return out;
}
/**
 * 向量相减
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function sub(out, v1, v2) {
  out[0] = v1[0] - v2[0];
  out[1] = v1[1] - v2[1];
  return out;
}
/**
 * 向量长度
 * @param {Vector2} v
 * @return {number}
 */


function len(v) {
  return Math.sqrt(lenSquare(v));
}

var length = len; // jshint ignore:line

/**
 * 向量长度平方
 * @param {Vector2} v
 * @return {number}
 */

function lenSquare(v) {
  return v[0] * v[0] + v[1] * v[1];
}

var lengthSquare = lenSquare;
/**
 * 向量乘法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */

function mul(out, v1, v2) {
  out[0] = v1[0] * v2[0];
  out[1] = v1[1] * v2[1];
  return out;
}
/**
 * 向量除法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function div(out, v1, v2) {
  out[0] = v1[0] / v2[0];
  out[1] = v1[1] / v2[1];
  return out;
}
/**
 * 向量点乘
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */


function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
/**
 * 向量缩放
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {number} s
 */


function scale(out, v, s) {
  out[0] = v[0] * s;
  out[1] = v[1] * s;
  return out;
}
/**
 * 向量归一化
 * @param {Vector2} out
 * @param {Vector2} v
 */


function normalize(out, v) {
  var d = len(v);

  if (d === 0) {
    out[0] = 0;
    out[1] = 0;
  } else {
    out[0] = v[0] / d;
    out[1] = v[1] / d;
  }

  return out;
}
/**
 * 计算向量间距离
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */


function distance(v1, v2) {
  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
}

var dist = distance;
/**
 * 向量距离平方
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */

function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}

var distSquare = distanceSquare;
/**
 * 求负向量
 * @param {Vector2} out
 * @param {Vector2} v
 */

function negate(out, v) {
  out[0] = -v[0];
  out[1] = -v[1];
  return out;
}
/**
 * 插值两个点
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} t
 */


function lerp(out, v1, v2, t) {
  out[0] = v1[0] + t * (v2[0] - v1[0]);
  out[1] = v1[1] + t * (v2[1] - v1[1]);
  return out;
}
/**
 * 矩阵左乘向量
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {Vector2} m
 */


function applyTransform(out, v, m) {
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * 求两个向量最小值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */


function min(out, v1, v2) {
  out[0] = Math.min(v1[0], v2[0]);
  out[1] = Math.min(v1[1], v2[1]);
  return out;
}
/**
 * 求两个向量最大值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */


function max(out, v1, v2) {
  out[0] = Math.max(v1[0], v2[0]);
  out[1] = Math.max(v1[1], v2[1]);
  return out;
}

exports.create = create;
exports.copy = copy;
exports.clone = clone;
exports.set = set;
exports.add = add;
exports.scaleAndAdd = scaleAndAdd;
exports.sub = sub;
exports.len = len;
exports.length = length;
exports.lenSquare = lenSquare;
exports.lengthSquare = lengthSquare;
exports.mul = mul;
exports.div = div;
exports.dot = dot;
exports.scale = scale;
exports.normalize = normalize;
exports.distance = distance;
exports.dist = dist;
exports.distanceSquare = distanceSquare;
exports.distSquare = distSquare;
exports.negate = negate;
exports.lerp = lerp;
exports.applyTransform = applyTransform;
exports.min = min;
exports.max = max;

/***/ }),

/***/ "./node_modules/zrender/lib/dom/HandlerProxy.js":
/***/ (function(module, exports, __webpack_require__) {

var _event = __webpack_require__("./node_modules/zrender/lib/core/event.js");

var addEventListener = _event.addEventListener;
var removeEventListener = _event.removeEventListener;
var normalizeEvent = _event.normalizeEvent;

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Eventful = __webpack_require__("./node_modules/zrender/lib/mixin/Eventful.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var GestureMgr = __webpack_require__("./node_modules/zrender/lib/core/GestureMgr.js");

var TOUCH_CLICK_DELAY = 300;
var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
var pointerEventNames = {
  pointerdown: 1,
  pointerup: 1,
  pointermove: 1,
  pointerout: 1
};
var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
  var nm = name.replace('mouse', 'pointer');
  return pointerEventNames[nm] ? nm : name;
});

function eventNameFix(name) {
  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;
}

function processGesture(proxy, event, stage) {
  var gestureMgr = proxy._gestureMgr;
  stage === 'start' && gestureMgr.clear();
  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);
  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.

  if (gestureInfo) {
    var type = gestureInfo.type;
    event.gestureEvent = type;
    proxy.handler.dispatchToElement({
      target: gestureInfo.target
    }, type, gestureInfo.event);
  }
} // function onMSGestureChange(proxy, event) {
//     if (event.translationX || event.translationY) {
//         // mousemove is carried by MSGesture to reduce the sensitivity.
//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
//     }
//     if (event.scale !== 1) {
//         event.pinchX = event.offsetX;
//         event.pinchY = event.offsetY;
//         event.pinchScale = event.scale;
//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
//     }
// }

/**
 * Prevent mouse event from being dispatched after Touch Events action
 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
 * Result: Blocking Mouse Events for 700ms.
 */


function setTouchTimer(instance) {
  instance._touching = true;
  clearTimeout(instance._touchTimer);
  instance._touchTimer = setTimeout(function () {
    instance._touching = false;
  }, 700);
}

var domHandlers = {
  /**
   * Mouse move handler
   * @inner
   * @param {Event} event
   */
  mousemove: function (event) {
    event = normalizeEvent(this.dom, event);
    this.trigger('mousemove', event);
  },

  /**
   * Mouse out handler
   * @inner
   * @param {Event} event
   */
  mouseout: function (event) {
    event = normalizeEvent(this.dom, event);
    var element = event.toElement || event.relatedTarget;

    if (element != this.dom) {
      while (element && element.nodeType != 9) {
        // 忽略包含在root中的dom引起的mouseOut
        if (element === this.dom) {
          return;
        }

        element = element.parentNode;
      }
    }

    this.trigger('mouseout', event);
  },

  /**
   * Touch开始响应函数
   * @inner
   * @param {Event} event
   */
  touchstart: function (event) {
    // Default mouse behaviour should not be disabled here.
    // For example, page may needs to be slided.
    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
    // mouse event in upper applicatoin.

    event.zrByTouch = true;
    this._lastTouchMoment = new Date();
    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should
    // be triggered, and must before `mousedown` triggered.

    domHandlers.mousemove.call(this, event);
    domHandlers.mousedown.call(this, event);
    setTouchTimer(this);
  },

  /**
   * Touch移动响应函数
   * @inner
   * @param {Event} event
   */
  touchmove: function (event) {
    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
    // mouse event in upper applicatoin.

    event.zrByTouch = true;
    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether
    // there is gestrue event, because mouse move and pinch may
    // be used at the same time.

    domHandlers.mousemove.call(this, event);
    setTouchTimer(this);
  },

  /**
   * Touch结束响应函数
   * @inner
   * @param {Event} event
   */
  touchend: function (event) {
    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
    // mouse event in upper applicatoin.

    event.zrByTouch = true;
    processGesture(this, event, 'end');
    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
    // we can conveniently implement "hover style" in both PC and touch device just
    // by listening to `mouseover` to add "hover style" and listening to `mouseout`
    // to remove "hover style" on an element, without any additional code for
    // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
    // style" will remain for user view)
    // click event should always be triggered no matter whether
    // there is gestrue event. System click can not be prevented.

    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
      domHandlers.click.call(this, event);
    }

    setTouchTimer(this);
  },
  pointerdown: function (event) {
    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
    //     this._msGesture.addPointer(event.pointerId);
    // }
  },
  pointermove: function (event) {
    // FIXME
    // pointermove is so sensitive that it always triggered when
    // tap(click) on touch screen, which affect some judgement in
    // upper application. So, we dont support mousemove on MS touch
    // device yet.
    if (!isPointerFromTouch(event)) {
      domHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function (event) {
    domHandlers.mouseup.call(this, event);
  },
  pointerout: function (event) {
    // pointerout will be triggered when tap on touch screen
    // (IE11+/Edge on MS Surface) after click event triggered,
    // which is inconsistent with the mousout behavior we defined
    // in touchend. So we unify them.
    // (check domHandlers.touchend for detailed explanation)
    if (!isPointerFromTouch(event)) {
      domHandlers.mouseout.call(this, event);
    }
  }
};

function isPointerFromTouch(event) {
  var pointerType = event.pointerType;
  return pointerType === 'pen' || pointerType === 'touch';
} // function useMSGuesture(handlerProxy, event) {
//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
// }
// Common handlers


zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
  domHandlers[name] = function (event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name, event);
  };
});
/**
 * 为控制类实例初始化dom 事件处理函数
 *
 * @inner
 * @param {module:zrender/Handler} instance 控制类实例
 */

function initDomHandler(instance) {
  zrUtil.each(touchHandlerNames, function (name) {
    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
  });
  zrUtil.each(pointerHandlerNames, function (name) {
    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
  });
  zrUtil.each(mouseHandlerNames, function (name) {
    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
  });

  function makeMouseHandler(fn, instance) {
    return function () {
      if (instance._touching) {
        return;
      }

      return fn.apply(instance, arguments);
    };
  }
}

function HandlerDomProxy(dom) {
  Eventful.call(this);
  this.dom = dom;
  /**
   * @private
   * @type {boolean}
   */

  this._touching = false;
  /**
   * @private
   * @type {number}
   */

  this._touchTimer;
  /**
   * @private
   * @type {module:zrender/core/GestureMgr}
   */

  this._gestureMgr = new GestureMgr();
  this._handlers = {};
  initDomHandler(this);

  if (env.pointerEventsSupported) {
    // Only IE11+/Edge
    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
    // at the same time.
    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
    // screen, which do not occurs in pointer event.
    // So we use pointer event to both detect touch gesture and mouse behavior.
    mountHandlers(pointerHandlerNames, this); // FIXME
    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
    // which does not prevent defuault behavior occasionally (which may cause view port
    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
    // So we have to not to use MSGesture and not to support touchmove and pinch on MS
    // touch screen. And we only support click behavior on MS touch screen now.
    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
    // We dont support touch on IE on win7.
    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
    // if (typeof MSGesture === 'function') {
    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
    //     dom.addEventListener('MSGestureChange', onMSGestureChange);
    // }
  } else {
    if (env.touchEventsSupported) {
      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
      // addEventListener(root, 'mouseout', this._mouseoutHandler);
    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
    // mouse event can not be handle in those devices.
    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
    // mouseevent after touch event triggered, see `setTouchTimer`.


    mountHandlers(mouseHandlerNames, this);
  }

  function mountHandlers(handlerNames, instance) {
    zrUtil.each(handlerNames, function (name) {
      addEventListener(dom, eventNameFix(name), instance._handlers[name]);
    }, instance);
  }
}

var handlerDomProxyProto = HandlerDomProxy.prototype;

handlerDomProxyProto.dispose = function () {
  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);

  for (var i = 0; i < handlerNames.length; i++) {
    var name = handlerNames[i];
    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
  }
};

handlerDomProxyProto.setCursor = function (cursorStyle) {
  this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');
};

zrUtil.mixin(HandlerDomProxy, Eventful);
var _default = HandlerDomProxy;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/CompoundPath.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

// CompoundPath to improve performance
var _default = Path.extend({
  type: 'compound',
  shape: {
    paths: null
  },
  _updatePathDirty: function () {
    var dirtyPath = this.__dirtyPath;
    var paths = this.shape.paths;

    for (var i = 0; i < paths.length; i++) {
      // Mark as dirty if any subpath is dirty
      dirtyPath = dirtyPath || paths[i].__dirtyPath;
    }

    this.__dirtyPath = dirtyPath;
    this.__dirty = this.__dirty || dirtyPath;
  },
  beforeBrush: function () {
    this._updatePathDirty();

    var paths = this.shape.paths || [];
    var scale = this.getGlobalScale(); // Update path scale

    for (var i = 0; i < paths.length; i++) {
      if (!paths[i].path) {
        paths[i].createPathProxy();
      }

      paths[i].path.setScale(scale[0], scale[1]);
    }
  },
  buildPath: function (ctx, shape) {
    var paths = shape.paths || [];

    for (var i = 0; i < paths.length; i++) {
      paths[i].buildPath(ctx, paths[i].shape, true);
    }
  },
  afterBrush: function () {
    var paths = this.shape.paths || [];

    for (var i = 0; i < paths.length; i++) {
      paths[i].__dirtyPath = false;
    }
  },
  getBoundingRect: function () {
    this._updatePathDirty();

    return Path.prototype.getBoundingRect.call(this);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Displayable.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Style = __webpack_require__("./node_modules/zrender/lib/graphic/Style.js");

var Element = __webpack_require__("./node_modules/zrender/lib/Element.js");

var RectText = __webpack_require__("./node_modules/zrender/lib/graphic/mixin/RectText.js");

/**
 * 可绘制的图形基类
 * Base class of all displayable graphic objects
 * @module zrender/graphic/Displayable
 */

/**
 * @alias module:zrender/graphic/Displayable
 * @extends module:zrender/Element
 * @extends module:zrender/graphic/mixin/RectText
 */
function Displayable(opts) {
  opts = opts || {};
  Element.call(this, opts); // Extend properties

  for (var name in opts) {
    if (opts.hasOwnProperty(name) && name !== 'style') {
      this[name] = opts[name];
    }
  }
  /**
   * @type {module:zrender/graphic/Style}
   */


  this.style = new Style(opts.style, this);
  this._rect = null; // Shapes for cascade clipping.

  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted
  // Stateful.call(this, opts);
}

Displayable.prototype = {
  constructor: Displayable,
  type: 'displayable',

  /**
   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
   * Dirty flag. From which painter will determine if this displayable object needs brush
   * @name module:zrender/graphic/Displayable#__dirty
   * @type {boolean}
   */
  __dirty: true,

  /**
   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
   * If ignore drawing of the displayable object. Mouse event will still be triggered
   * @name module:/zrender/graphic/Displayable#invisible
   * @type {boolean}
   * @default false
   */
  invisible: false,

  /**
   * @name module:/zrender/graphic/Displayable#z
   * @type {number}
   * @default 0
   */
  z: 0,

  /**
   * @name module:/zrender/graphic/Displayable#z
   * @type {number}
   * @default 0
   */
  z2: 0,

  /**
   * z层level，决定绘画在哪层canvas中
   * @name module:/zrender/graphic/Displayable#zlevel
   * @type {number}
   * @default 0
   */
  zlevel: 0,

  /**
   * 是否可拖拽
   * @name module:/zrender/graphic/Displayable#draggable
   * @type {boolean}
   * @default false
   */
  draggable: false,

  /**
   * 是否正在拖拽
   * @name module:/zrender/graphic/Displayable#draggable
   * @type {boolean}
   * @default false
   */
  dragging: false,

  /**
   * 是否相应鼠标事件
   * @name module:/zrender/graphic/Displayable#silent
   * @type {boolean}
   * @default false
   */
  silent: false,

  /**
   * If enable culling
   * @type {boolean}
   * @default false
   */
  culling: false,

  /**
   * Mouse cursor when hovered
   * @name module:/zrender/graphic/Displayable#cursor
   * @type {string}
   */
  cursor: 'pointer',

  /**
   * If hover area is bounding rect
   * @name module:/zrender/graphic/Displayable#rectHover
   * @type {string}
   */
  rectHover: false,

  /**
   * Render the element progressively when the value >= 0,
   * usefull for large data.
   * @type {boolean}
   */
  progressive: false,

  /**
   * @type {boolean}
   */
  incremental: false,
  // inplace is used with incremental
  inplace: false,
  beforeBrush: function (ctx) {},
  afterBrush: function (ctx) {},

  /**
   * 图形绘制方法
   * @param {CanvasRenderingContext2D} ctx
   */
  // Interface
  brush: function (ctx, prevEl) {},

  /**
   * 获取最小包围盒
   * @return {module:zrender/core/BoundingRect}
   */
  // Interface
  getBoundingRect: function () {},

  /**
   * 判断坐标 x, y 是否在图形上
   * If displayable element contain coord x, y
   * @param  {number} x
   * @param  {number} y
   * @return {boolean}
   */
  contain: function (x, y) {
    return this.rectContain(x, y);
  },

  /**
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {
    cb.call(context, this);
  },

  /**
   * 判断坐标 x, y 是否在图形的包围盒上
   * If bounding rect of element contain coord x, y
   * @param  {number} x
   * @param  {number} y
   * @return {boolean}
   */
  rectContain: function (x, y) {
    var coord = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  },

  /**
   * 标记图形元素为脏，并且在下一帧重绘
   * Mark displayable element dirty and refresh next frame
   */
  dirty: function () {
    this.__dirty = true;
    this._rect = null;
    this.__zr && this.__zr.refresh();
  },

  /**
   * 图形是否会触发事件
   * If displayable object binded any event
   * @return {boolean}
   */
  // TODO, 通过 bind 绑定的事件
  // isSilent: function () {
  //     return !(
  //         this.hoverable || this.draggable
  //         || this.onmousemove || this.onmouseover || this.onmouseout
  //         || this.onmousedown || this.onmouseup || this.onclick
  //         || this.ondragenter || this.ondragover || this.ondragleave
  //         || this.ondrop
  //     );
  // },

  /**
   * Alias for animate('style')
   * @param {boolean} loop
   */
  animateStyle: function (loop) {
    return this.animate('style', loop);
  },
  attrKV: function (key, value) {
    if (key !== 'style') {
      Element.prototype.attrKV.call(this, key, value);
    } else {
      this.style.set(value);
    }
  },

  /**
   * @param {Object|string} key
   * @param {*} value
   */
  setStyle: function (key, value) {
    this.style.set(key, value);
    this.dirty(false);
    return this;
  },

  /**
   * Use given style object
   * @param  {Object} obj
   */
  useStyle: function (obj) {
    this.style = new Style(obj, this);
    this.dirty(false);
    return this;
  }
};
zrUtil.inherits(Displayable, Element);
zrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);

var _default = Displayable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Gradient.js":
/***/ (function(module, exports) {

/**
 * @param {Array.<Object>} colorStops
 */
var Gradient = function (colorStops) {
  this.colorStops = colorStops || [];
};

Gradient.prototype = {
  constructor: Gradient,
  addColorStop: function (offset, color) {
    this.colorStops.push({
      offset: offset,
      color: color
    });
  }
};
var _default = Gradient;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Image.js":
/***/ (function(module, exports, __webpack_require__) {

var Displayable = __webpack_require__("./node_modules/zrender/lib/graphic/Displayable.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var imageHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/image.js");

/**
 * @alias zrender/graphic/Image
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
function ZImage(opts) {
  Displayable.call(this, opts);
}

ZImage.prototype = {
  constructor: ZImage,
  type: 'image',
  brush: function (ctx, prevEl) {
    var style = this.style;
    var src = style.image; // Must bind each time

    style.bind(ctx, this, prevEl);
    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);

    if (!image || !imageHelper.isImageReady(image)) {
      return;
    } // 图片已经加载完成
    // if (image.nodeName.toUpperCase() == 'IMG') {
    //     if (!image.complete) {
    //         return;
    //     }
    // }
    // Else is canvas


    var x = style.x || 0;
    var y = style.y || 0;
    var width = style.width;
    var height = style.height;
    var aspect = image.width / image.height;

    if (width == null && height != null) {
      // Keep image/height ratio
      width = height * aspect;
    } else if (height == null && width != null) {
      height = width / aspect;
    } else if (width == null && height == null) {
      width = image.width;
      height = image.height;
    } // 设置transform


    this.setTransform(ctx);

    if (style.sWidth && style.sHeight) {
      var sx = style.sx || 0;
      var sy = style.sy || 0;
      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
    } else if (style.sx && style.sy) {
      var sx = style.sx;
      var sy = style.sy;
      var sWidth = width - sx;
      var sHeight = height - sy;
      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
    } else {
      ctx.drawImage(image, x, y, width, height);
    } // Draw rect text


    if (style.text != null) {
      // Only restore transform when needs draw text.
      this.restoreTransform(ctx);
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },
  getBoundingRect: function () {
    var style = this.style;

    if (!this._rect) {
      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
    }

    return this._rect;
  }
};
zrUtil.inherits(ZImage, Displayable);
var _default = ZImage;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/IncrementalDisplayable.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var inherits = _util.inherits;

var Displayble = __webpack_require__("./node_modules/zrender/lib/graphic/Displayable.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

/**
 * Displayable for incremental rendering. It will be rendered in a separate layer
 * IncrementalDisplay have too main methods. `clearDisplayables` and `addDisplayables`
 * addDisplayables will render the added displayables incremetally.
 *
 * It use a not clearFlag to tell the painter don't clear the layer if it's the first element.
 */
// TODO Style override ?
function IncrementalDisplayble(opts) {
  Displayble.call(this, opts);
  this._displayables = [];
  this._temporaryDisplayables = [];
  this._cursor = 0;
  this.notClear = true;
}

IncrementalDisplayble.prototype.incremental = true;

IncrementalDisplayble.prototype.clearDisplaybles = function () {
  this._displayables = [];
  this._temporaryDisplayables = [];
  this._cursor = 0;
  this.dirty();
  this.notClear = false;
};

IncrementalDisplayble.prototype.addDisplayable = function (displayable, notPersistent) {
  if (notPersistent) {
    this._temporaryDisplayables.push(displayable);
  } else {
    this._displayables.push(displayable);
  }

  this.dirty();
};

IncrementalDisplayble.prototype.addDisplayables = function (displayables, notPersistent) {
  notPersistent = notPersistent || false;

  for (var i = 0; i < displayables.length; i++) {
    this.addDisplayable(displayables[i], notPersistent);
  }
};

IncrementalDisplayble.prototype.eachPendingDisplayable = function (cb) {
  for (var i = this._cursor; i < this._displayables.length; i++) {
    cb && cb(this._displayables[i]);
  }

  for (var i = 0; i < this._temporaryDisplayables.length; i++) {
    cb && cb(this._temporaryDisplayables[i]);
  }
};

IncrementalDisplayble.prototype.update = function () {
  this.updateTransform();

  for (var i = this._cursor; i < this._displayables.length; i++) {
    var displayable = this._displayables[i]; // PENDING

    displayable.parent = this;
    displayable.update();
    displayable.parent = null;
  }

  for (var i = 0; i < this._temporaryDisplayables.length; i++) {
    var displayable = this._temporaryDisplayables[i]; // PENDING

    displayable.parent = this;
    displayable.update();
    displayable.parent = null;
  }
};

IncrementalDisplayble.prototype.brush = function (ctx, prevEl) {
  // Render persistant displayables.
  for (var i = this._cursor; i < this._displayables.length; i++) {
    var displayable = this._displayables[i];
    displayable.beforeBrush && displayable.beforeBrush(ctx);
    displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]);
    displayable.afterBrush && displayable.afterBrush(ctx);
  }

  this._cursor = i; // Render temporary displayables.

  for (var i = 0; i < this._temporaryDisplayables.length; i++) {
    var displayable = this._temporaryDisplayables[i];
    displayable.beforeBrush && displayable.beforeBrush(ctx);
    displayable.brush(ctx, i === 0 ? null : this._temporaryDisplayables[i - 1]);
    displayable.afterBrush && displayable.afterBrush(ctx);
  }

  this._temporaryDisplayables = [];
  this.notClear = true;
};

var m = [];

IncrementalDisplayble.prototype.getBoundingRect = function () {
  if (!this._rect) {
    var rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity);

    for (var i = 0; i < this._displayables.length; i++) {
      var displayable = this._displayables[i];
      var childRect = displayable.getBoundingRect().clone();

      if (displayable.needLocalTransform()) {
        childRect.applyTransform(displayable.getLocalTransform(m));
      }

      rect.union(childRect);
    }

    this._rect = rect;
  }

  return this._rect;
};

IncrementalDisplayble.prototype.contain = function (x, y) {
  var localPos = this.transformCoordToLocal(x, y);
  var rect = this.getBoundingRect();

  if (rect.contain(localPos[0], localPos[1])) {
    for (var i = 0; i < this._displayables.length; i++) {
      var displayable = this._displayables[i];

      if (displayable.contain(x, y)) {
        return true;
      }
    }
  }

  return false;
};

inherits(IncrementalDisplayble, Displayble);
var _default = IncrementalDisplayble;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/LinearGradient.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Gradient = __webpack_require__("./node_modules/zrender/lib/graphic/Gradient.js");

/**
 * x, y, x2, y2 are all percent from 0 to 1
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @param {number} [x2=1]
 * @param {number} [y2=0]
 * @param {Array.<Object>} colorStops
 * @param {boolean} [globalCoord=false]
 */
var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {type: 'linear', colorStops: ...}`, where
  // this constructor will not be called.
  this.x = x == null ? 0 : x;
  this.y = y == null ? 0 : y;
  this.x2 = x2 == null ? 1 : x2;
  this.y2 = y2 == null ? 0 : y2; // Can be cloned

  this.type = 'linear'; // If use global coord

  this.global = globalCoord || false;
  Gradient.call(this, colorStops);
};

LinearGradient.prototype = {
  constructor: LinearGradient
};
zrUtil.inherits(LinearGradient, Gradient);
var _default = LinearGradient;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Path.js":
/***/ (function(module, exports, __webpack_require__) {

var Displayable = __webpack_require__("./node_modules/zrender/lib/graphic/Displayable.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var PathProxy = __webpack_require__("./node_modules/zrender/lib/core/PathProxy.js");

var pathContain = __webpack_require__("./node_modules/zrender/lib/contain/path.js");

var Pattern = __webpack_require__("./node_modules/zrender/lib/graphic/Pattern.js");

var getCanvasPattern = Pattern.prototype.getCanvasPattern;
var abs = Math.abs;
var pathProxyForDraw = new PathProxy(true);
/**
 * @alias module:zrender/graphic/Path
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */

function Path(opts) {
  Displayable.call(this, opts);
  /**
   * @type {module:zrender/core/PathProxy}
   * @readOnly
   */

  this.path = null;
}

Path.prototype = {
  constructor: Path,
  type: 'path',
  __dirtyPath: true,
  strokeContainThreshold: 5,
  brush: function (ctx, prevEl) {
    var style = this.style;
    var path = this.path || pathProxyForDraw;
    var hasStroke = style.hasStroke();
    var hasFill = style.hasFill();
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill && !!fill.colorStops;
    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
    var hasFillPattern = hasFill && !!fill.image;
    var hasStrokePattern = hasStroke && !!stroke.image;
    style.bind(ctx, this, prevEl);
    this.setTransform(ctx);

    if (this.__dirty) {
      var rect; // Update gradient because bounding rect may changed

      if (hasFillGradient) {
        rect = rect || this.getBoundingRect();
        this._fillGradient = style.getGradient(ctx, fill, rect);
      }

      if (hasStrokeGradient) {
        rect = rect || this.getBoundingRect();
        this._strokeGradient = style.getGradient(ctx, stroke, rect);
      }
    } // Use the gradient or pattern


    if (hasFillGradient) {
      // PENDING If may have affect the state
      ctx.fillStyle = this._fillGradient;
    } else if (hasFillPattern) {
      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
    }

    if (hasStrokeGradient) {
      ctx.strokeStyle = this._strokeGradient;
    } else if (hasStrokePattern) {
      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
    }

    var lineDash = style.lineDash;
    var lineDashOffset = style.lineDashOffset;
    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy

    var scale = this.getGlobalScale();
    path.setScale(scale[0], scale[1]); // Proxy context
    // Rebuild path in following 2 cases
    // 1. Path is dirty
    // 2. Path needs javascript implemented lineDash stroking.
    //    In this case, lineDash information will not be saved in PathProxy

    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
      path.beginPath(ctx); // Setting line dash before build path

      if (lineDash && !ctxLineDash) {
        path.setLineDash(lineDash);
        path.setLineDashOffset(lineDashOffset);
      }

      this.buildPath(path, this.shape, false); // Clear path dirty flag

      if (this.path) {
        this.__dirtyPath = false;
      }
    } else {
      // Replay path building
      ctx.beginPath();
      this.path.rebuildPath(ctx);
    }

    hasFill && path.fill(ctx);

    if (lineDash && ctxLineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }

    hasStroke && path.stroke(ctx);

    if (lineDash && ctxLineDash) {
      // PENDING
      // Remove lineDash
      ctx.setLineDash([]);
    } // Draw rect text


    if (style.text != null) {
      // Only restore transform when needs draw text.
      this.restoreTransform(ctx);
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },
  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
  // Like in circle
  buildPath: function (ctx, shapeCfg, inBundle) {},
  createPathProxy: function () {
    this.path = new PathProxy();
  },
  getBoundingRect: function () {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;

    if (needsUpdateRect) {
      var path = this.path;

      if (!path) {
        // Create path on demand.
        path = this.path = new PathProxy();
      }

      if (this.__dirtyPath) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
      }

      rect = path.getBoundingRect();
    }

    this._rect = rect;

    if (style.hasStroke()) {
      // Needs update rect with stroke lineWidth when
      // 1. Element changes scale or lineWidth
      // 2. Shape is changed
      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());

      if (this.__dirty || needsUpdateRect) {
        rectWithStroke.copy(rect); // FIXME Must after updateTransform

        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical

        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill

        if (!style.hasFill()) {
          w = Math.max(w, this.strokeContainThreshold || 4);
        } // Consider line width
        // Line scale can't be 0;


        if (lineScale > 1e-10) {
          rectWithStroke.width += w / lineScale;
          rectWithStroke.height += w / lineScale;
          rectWithStroke.x -= w / lineScale / 2;
          rectWithStroke.y -= w / lineScale / 2;
        }
      } // Return rect with stroke


      return rectWithStroke;
    }

    return rect;
  },
  contain: function (x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    var style = this.style;
    x = localPos[0];
    y = localPos[1];

    if (rect.contain(x, y)) {
      var pathData = this.path.data;

      if (style.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;

        if (lineScale > 1e-10) {
          // Only add extra hover lineWidth when there are no fill
          if (!style.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }

          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
            return true;
          }
        }
      }

      if (style.hasFill()) {
        return pathContain.contain(pathData, x, y);
      }
    }

    return false;
  },

  /**
   * @param  {boolean} dirtyPath
   */
  dirty: function (dirtyPath) {
    if (dirtyPath == null) {
      dirtyPath = true;
    } // Only mark dirty, not mark clean


    if (dirtyPath) {
      this.__dirtyPath = dirtyPath;
      this._rect = null;
    }

    this.__dirty = true;
    this.__zr && this.__zr.refresh(); // Used as a clipping path

    if (this.__clipTarget) {
      this.__clipTarget.dirty();
    }
  },

  /**
   * Alias for animate('shape')
   * @param {boolean} loop
   */
  animateShape: function (loop) {
    return this.animate('shape', loop);
  },
  // Overwrite attrKV
  attrKV: function (key, value) {
    // FIXME
    if (key === 'shape') {
      this.setShape(value);
      this.__dirtyPath = true;
      this._rect = null;
    } else {
      Displayable.prototype.attrKV.call(this, key, value);
    }
  },

  /**
   * @param {Object|string} key
   * @param {*} value
   */
  setShape: function (key, value) {
    var shape = this.shape; // Path from string may not have shape

    if (shape) {
      if (zrUtil.isObject(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            shape[name] = key[name];
          }
        }
      } else {
        shape[key] = value;
      }

      this.dirty(true);
    }

    return this;
  },
  getLineScale: function () {
    var m = this.transform; // Get the line scale.
    // Determinant of `m` means how much the area is enlarged by the
    // transformation. So its square root can be used as a scale factor
    // for width.

    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
  }
};
/**
 * 扩展一个 Path element, 比如星形，圆等。
 * Extend a path element
 * @param {Object} props
 * @param {string} props.type Path type
 * @param {Function} props.init Initialize
 * @param {Function} props.buildPath Overwrite buildPath method
 * @param {Object} [props.style] Extended default style config
 * @param {Object} [props.shape] Extended default shape config
 */

Path.extend = function (defaults) {
  var Sub = function (opts) {
    Path.call(this, opts);

    if (defaults.style) {
      // Extend default style
      this.style.extendFrom(defaults.style, false);
    } // Extend default shape


    var defaultShape = defaults.shape;

    if (defaultShape) {
      this.shape = this.shape || {};
      var thisShape = this.shape;

      for (var name in defaultShape) {
        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
          thisShape[name] = defaultShape[name];
        }
      }
    }

    defaults.init && defaults.init.call(this, opts);
  };

  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象

  for (var name in defaults) {
    // Extending prototype values and methods
    if (name !== 'style' && name !== 'shape') {
      Sub.prototype[name] = defaults[name];
    }
  }

  return Sub;
};

zrUtil.inherits(Path, Displayable);
var _default = Path;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Pattern.js":
/***/ (function(module, exports) {

var Pattern = function (image, repeat) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {image: ...}`, where this constructor will not be called.
  this.image = image;
  this.repeat = repeat; // Can be cloned

  this.type = 'pattern';
};

Pattern.prototype.getCanvasPattern = function (ctx) {
  return ctx.createPattern(this.image, this.repeat || 'repeat');
};

var _default = Pattern;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/RadialGradient.js":
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Gradient = __webpack_require__("./node_modules/zrender/lib/graphic/Gradient.js");

/**
 * x, y, r are all percent from 0 to 1
 * @param {number} [x=0.5]
 * @param {number} [y=0.5]
 * @param {number} [r=0.5]
 * @param {Array.<Object>} [colorStops]
 * @param {boolean} [globalCoord=false]
 */
var RadialGradient = function (x, y, r, colorStops, globalCoord) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {type: 'radial', colorStops: ...}`, where
  // this constructor will not be called.
  this.x = x == null ? 0.5 : x;
  this.y = y == null ? 0.5 : y;
  this.r = r == null ? 0.5 : r; // Can be cloned

  this.type = 'radial'; // If use global coord

  this.global = globalCoord || false;
  Gradient.call(this, colorStops);
};

RadialGradient.prototype = {
  constructor: RadialGradient
};
zrUtil.inherits(RadialGradient, Gradient);
var _default = RadialGradient;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Style.js":
/***/ (function(module, exports, __webpack_require__) {

var fixShadow = __webpack_require__("./node_modules/zrender/lib/graphic/helper/fixShadow.js");

var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);

var Style = function (opts, host) {
  this.extendFrom(opts, false);
  this.host = host;
};

function createLinearGradient(ctx, obj, rect) {
  var x = obj.x == null ? 0 : obj.x;
  var x2 = obj.x2 == null ? 1 : obj.x2;
  var y = obj.y == null ? 0 : obj.y;
  var y2 = obj.y2 == null ? 0 : obj.y2;

  if (!obj.global) {
    x = x * rect.width + rect.x;
    x2 = x2 * rect.width + rect.x;
    y = y * rect.height + rect.y;
    y2 = y2 * rect.height + rect.y;
  } // Fix NaN when rect is Infinity


  x = isNaN(x) ? 0 : x;
  x2 = isNaN(x2) ? 1 : x2;
  y = isNaN(y) ? 0 : y;
  y2 = isNaN(y2) ? 0 : y2;
  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
  return canvasGradient;
}

function createRadialGradient(ctx, obj, rect) {
  var width = rect.width;
  var height = rect.height;
  var min = Math.min(width, height);
  var x = obj.x == null ? 0.5 : obj.x;
  var y = obj.y == null ? 0.5 : obj.y;
  var r = obj.r == null ? 0.5 : obj.r;

  if (!obj.global) {
    x = x * width + rect.x;
    y = y * height + rect.y;
    r = r * min;
  }

  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
  return canvasGradient;
}

Style.prototype = {
  constructor: Style,

  /**
   * @type {module:zrender/graphic/Displayable}
   */
  host: null,

  /**
   * @type {string}
   */
  fill: '#000',

  /**
   * @type {string}
   */
  stroke: null,

  /**
   * @type {number}
   */
  opacity: 1,

  /**
   * @type {Array.<number>}
   */
  lineDash: null,

  /**
   * @type {number}
   */
  lineDashOffset: 0,

  /**
   * @type {number}
   */
  shadowBlur: 0,

  /**
   * @type {number}
   */
  shadowOffsetX: 0,

  /**
   * @type {number}
   */
  shadowOffsetY: 0,

  /**
   * @type {number}
   */
  lineWidth: 1,

  /**
   * If stroke ignore scale
   * @type {Boolean}
   */
  strokeNoScale: false,
  // Bounding rect text configuration
  // Not affected by element transform

  /**
   * @type {string}
   */
  text: null,

  /**
   * If `fontSize` or `fontFamily` exists, `font` will be reset by
   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
   * So do not visit it directly in upper application (like echarts),
   * but use `contain/text#makeFont` instead.
   * @type {string}
   */
  font: null,

  /**
   * The same as font. Use font please.
   * @deprecated
   * @type {string}
   */
  textFont: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontStyle: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontWeight: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * Should be 12 but not '12px'.
   * @type {number}
   */
  fontSize: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontFamily: null,

  /**
   * Reserved for special functinality, like 'hr'.
   * @type {string}
   */
  textTag: null,

  /**
   * @type {string}
   */
  textFill: '#000',

  /**
   * @type {string}
   */
  textStroke: null,

  /**
   * @type {number}
   */
  textWidth: null,

  /**
   * Only for textBackground.
   * @type {number}
   */
  textHeight: null,

  /**
   * textStroke may be set as some color as a default
   * value in upper applicaion, where the default value
   * of textStrokeWidth should be 0 to make sure that
   * user can choose to do not use text stroke.
   * @type {number}
   */
  textStrokeWidth: 0,

  /**
   * @type {number}
   */
  textLineHeight: null,

  /**
   * 'inside', 'left', 'right', 'top', 'bottom'
   * [x, y]
   * Based on x, y of rect.
   * @type {string|Array.<number>}
   * @default 'inside'
   */
  textPosition: 'inside',

  /**
   * If not specified, use the boundingRect of a `displayable`.
   * @type {Object}
   */
  textRect: null,

  /**
   * [x, y]
   * @type {Array.<number>}
   */
  textOffset: null,

  /**
   * @type {string}
   */
  textAlign: null,

  /**
   * @type {string}
   */
  textVerticalAlign: null,

  /**
   * @type {number}
   */
  textDistance: 5,

  /**
   * @type {string}
   */
  textShadowColor: 'transparent',

  /**
   * @type {number}
   */
  textShadowBlur: 0,

  /**
   * @type {number}
   */
  textShadowOffsetX: 0,

  /**
   * @type {number}
   */
  textShadowOffsetY: 0,

  /**
   * @type {string}
   */
  textBoxShadowColor: 'transparent',

  /**
   * @type {number}
   */
  textBoxShadowBlur: 0,

  /**
   * @type {number}
   */
  textBoxShadowOffsetX: 0,

  /**
   * @type {number}
   */
  textBoxShadowOffsetY: 0,

  /**
   * Whether transform text.
   * Only useful in Path and Image element
   * @type {boolean}
   */
  transformText: false,

  /**
   * Text rotate around position of Path or Image
   * Only useful in Path and Image element and transformText is false.
   */
  textRotation: 0,

  /**
   * Text origin of text rotation, like [10, 40].
   * Based on x, y of rect.
   * Useful in label rotation of circular symbol.
   * By default, this origin is textPosition.
   * Can be 'center'.
   * @type {string|Array.<number>}
   */
  textOrigin: null,

  /**
   * @type {string}
   */
  textBackgroundColor: null,

  /**
   * @type {string}
   */
  textBorderColor: null,

  /**
   * @type {number}
   */
  textBorderWidth: 0,

  /**
   * @type {number}
   */
  textBorderRadius: 0,

  /**
   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
   * @type {number|Array.<number>}
   */
  textPadding: null,

  /**
   * Text styles for rich text.
   * @type {Object}
   */
  rich: null,

  /**
   * {outerWidth, outerHeight, ellipsis, placeholder}
   * @type {Object}
   */
  truncate: null,

  /**
   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
   * @type {string}
   */
  blend: null,

  /**
   * @param {CanvasRenderingContext2D} ctx
   */
  bind: function (ctx, el, prevEl) {
    var style = this;
    var prevStyle = prevEl && prevEl.style;
    var firstDraw = !prevStyle;

    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
      var prop = STYLE_COMMON_PROPS[i];
      var styleName = prop[0];

      if (firstDraw || style[styleName] !== prevStyle[styleName]) {
        // FIXME Invalid property value will cause style leak from previous element.
        ctx[styleName] = fixShadow(ctx, styleName, style[styleName] || prop[1]);
      }
    }

    if (firstDraw || style.fill !== prevStyle.fill) {
      ctx.fillStyle = style.fill;
    }

    if (firstDraw || style.stroke !== prevStyle.stroke) {
      ctx.strokeStyle = style.stroke;
    }

    if (firstDraw || style.opacity !== prevStyle.opacity) {
      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
    }

    if (firstDraw || style.blend !== prevStyle.blend) {
      ctx.globalCompositeOperation = style.blend || 'source-over';
    }

    if (this.hasStroke()) {
      var lineWidth = style.lineWidth;
      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
    }
  },
  hasFill: function () {
    var fill = this.fill;
    return fill != null && fill !== 'none';
  },
  hasStroke: function () {
    var stroke = this.stroke;
    return stroke != null && stroke !== 'none' && this.lineWidth > 0;
  },

  /**
   * Extend from other style
   * @param {zrender/graphic/Style} otherStyle
   * @param {boolean} overwrite true: overwrirte any way.
   *                            false: overwrite only when !target.hasOwnProperty
   *                            others: overwrite when property is not null/undefined.
   */
  extendFrom: function (otherStyle, overwrite) {
    if (otherStyle) {
      for (var name in otherStyle) {
        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
          this[name] = otherStyle[name];
        }
      }
    }
  },

  /**
   * Batch setting style with a given object
   * @param {Object|string} obj
   * @param {*} [obj]
   */
  set: function (obj, value) {
    if (typeof obj === 'string') {
      this[obj] = value;
    } else {
      this.extendFrom(obj, true);
    }
  },

  /**
   * Clone
   * @return {zrender/graphic/Style} [description]
   */
  clone: function () {
    var newStyle = new this.constructor();
    newStyle.extendFrom(this, true);
    return newStyle;
  },
  getGradient: function (ctx, obj, rect) {
    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
    var canvasGradient = method(ctx, obj, rect);
    var colorStops = obj.colorStops;

    for (var i = 0; i < colorStops.length; i++) {
      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
    }

    return canvasGradient;
  }
};
var styleProto = Style.prototype;

for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
  var prop = STYLE_COMMON_PROPS[i];

  if (!(prop[0] in styleProto)) {
    styleProto[prop[0]] = prop[1];
  }
} // Provide for others


Style.getGradient = styleProto.getGradient;
var _default = Style;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Text.js":
/***/ (function(module, exports, __webpack_require__) {

var Displayable = __webpack_require__("./node_modules/zrender/lib/graphic/Displayable.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var textHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/text.js");

/**
 * @alias zrender/graphic/Text
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
var Text = function (opts) {
  // jshint ignore:line
  Displayable.call(this, opts);
};

Text.prototype = {
  constructor: Text,
  type: 'text',
  brush: function (ctx, prevEl) {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.

    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
    var text = style.text; // Convert to string

    text != null && (text += ''); // Always bind style

    style.bind(ctx, this, prevEl);

    if (!textHelper.needDrawText(text, style)) {
      return;
    }

    this.setTransform(ctx);
    textHelper.renderText(this, ctx, text, style);
    this.restoreTransform(ctx);
  },
  getBoundingRect: function () {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true);

    if (!this._rect) {
      var text = style.text;
      text != null ? text += '' : text = '';
      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);
      rect.x += style.x || 0;
      rect.y += style.y || 0;

      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
        var w = style.textStrokeWidth;
        rect.x -= w / 2;
        rect.y -= w / 2;
        rect.width += w;
        rect.height += w;
      }

      this._rect = rect;
    }

    return this._rect;
  }
};
zrUtil.inherits(Text, Displayable);
var _default = Text;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js":
/***/ (function(module, exports, __webpack_require__) {

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

// Fix weird bug in some version of IE11 (like 11.0.9600.178**),
// where exception "unexpected call to method or property access"
// might be thrown when calling ctx.fill or ctx.stroke after a path
// whose area size is zero is drawn and ctx.clip() is called and
// shadowBlur is set. See #4572, #3112, #5777.
// (e.g.,
//  ctx.moveTo(10, 10);
//  ctx.lineTo(20, 10);
//  ctx.closePath();
//  ctx.clip();
//  ctx.shadowBlur = 10;
//  ...
//  ctx.fill();
// )
var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];

function _default(orignalBrush) {
  // version string can be: '11.0'
  return env.browser.ie && env.browser.version >= 11 ? function () {
    var clipPaths = this.__clipPaths;
    var style = this.style;
    var modified;

    if (clipPaths) {
      for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];
        var shape = clipPath && clipPath.shape;
        var type = clipPath && clipPath.type;

        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
          for (var j = 0; j < shadowTemp.length; j++) {
            // It is save to put shadowTemp static, because shadowTemp
            // will be all modified each item brush called.
            shadowTemp[j][2] = style[shadowTemp[j][0]];
            style[shadowTemp[j][0]] = shadowTemp[j][1];
          }

          modified = true;
          break;
        }
      }
    }

    orignalBrush.apply(this, arguments);

    if (modified) {
      for (var j = 0; j < shadowTemp.length; j++) {
        style[shadowTemp[j][0]] = shadowTemp[j][2];
      }
    }
  } : orignalBrush;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/fixShadow.js":
/***/ (function(module, exports) {

var SHADOW_PROPS = {
  'shadowBlur': 1,
  'shadowOffsetX': 1,
  'shadowOffsetY': 1,
  'textShadowBlur': 1,
  'textShadowOffsetX': 1,
  'textShadowOffsetY': 1,
  'textBoxShadowBlur': 1,
  'textBoxShadowOffsetX': 1,
  'textBoxShadowOffsetY': 1
};

function _default(ctx, propName, value) {
  if (SHADOW_PROPS.hasOwnProperty(propName)) {
    return value *= ctx.dpr;
  }

  return value;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/image.js":
/***/ (function(module, exports, __webpack_require__) {

var LRU = __webpack_require__("./node_modules/zrender/lib/core/LRU.js");

var globalImageCache = new LRU(50);
/**
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */

function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === 'string') {
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
/**
 * Caution: User should cache loaded images, but not just count on LRU.
 * Consider if required images more than LRU size, will dead loop occur?
 *
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
 * @param {Function} [cb] params: (image, cbPayload)
 * @param {Object} [cbPayload] Payload on cb calling.
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */


function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === 'string') {
    // Image should not be loaded repeatly.
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    } // Only when there is no existent image or existent image src
    // is different, this method is responsible for load.


    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    var pendingWrap = {
      hostEl: hostEl,
      cb: cb,
      cbPayload: cbPayload
    };

    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      !image && (image = new Image());
      image.onload = imageOnLoad;
      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
        image: image,
        pending: [pendingWrap]
      });
      image.src = image.__zrImageSrc = newImageOrSrc;
    }

    return image;
  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
  else {
      return newImageOrSrc;
    }
}

function imageOnLoad() {
  var cachedImgObj = this.__cachedImgObj;
  this.onload = this.__cachedImgObj = null;

  for (var i = 0; i < cachedImgObj.pending.length; i++) {
    var pendingWrap = cachedImgObj.pending[i];
    var cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }

  cachedImgObj.pending.length = 0;
}

function isImageReady(image) {
  return image && image.width && image.height;
}

exports.findExistImage = findExistImage;
exports.createOrUpdateImage = createOrUpdateImage;
exports.isImageReady = isImageReady;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/poly.js":
/***/ (function(module, exports, __webpack_require__) {

var smoothSpline = __webpack_require__("./node_modules/zrender/lib/graphic/helper/smoothSpline.js");

var smoothBezier = __webpack_require__("./node_modules/zrender/lib/graphic/helper/smoothBezier.js");

function buildPath(ctx, shape, closePath) {
  var points = shape.points;
  var smooth = shape.smooth;

  if (points && points.length >= 2) {
    if (smooth && smooth !== 'spline') {
      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points[0][0], points[0][1]);
      var len = points.length;

      for (var i = 0; i < (closePath ? len : len - 1); i++) {
        var cp1 = controlPoints[i * 2];
        var cp2 = controlPoints[i * 2 + 1];
        var p = points[(i + 1) % len];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
      }
    } else {
      if (smooth === 'spline') {
        points = smoothSpline(points, closePath);
      }

      ctx.moveTo(points[0][0], points[0][1]);

      for (var i = 1, l = points.length; i < l; i++) {
        ctx.lineTo(points[i][0], points[i][1]);
      }
    }

    closePath && ctx.closePath();
  }
}

exports.buildPath = buildPath;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/roundRect.js":
/***/ (function(module, exports) {

function buildPath(ctx, shape) {
  var x = shape.x;
  var y = shape.y;
  var width = shape.width;
  var height = shape.height;
  var r = shape.r;
  var r1;
  var r2;
  var r3;
  var r4; // Convert width and height to positive for better borderRadius

  if (width < 0) {
    x = x + width;
    width = -width;
  }

  if (height < 0) {
    y = y + height;
    height = -height;
  }

  if (typeof r === 'number') {
    r1 = r2 = r3 = r4 = r;
  } else if (r instanceof Array) {
    if (r.length === 1) {
      r1 = r2 = r3 = r4 = r[0];
    } else if (r.length === 2) {
      r1 = r3 = r[0];
      r2 = r4 = r[1];
    } else if (r.length === 3) {
      r1 = r[0];
      r2 = r4 = r[1];
      r3 = r[2];
    } else {
      r1 = r[0];
      r2 = r[1];
      r3 = r[2];
      r4 = r[3];
    }
  } else {
    r1 = r2 = r3 = r4 = 0;
  }

  var total;

  if (r1 + r2 > width) {
    total = r1 + r2;
    r1 *= width / total;
    r2 *= width / total;
  }

  if (r3 + r4 > width) {
    total = r3 + r4;
    r3 *= width / total;
    r4 *= width / total;
  }

  if (r2 + r3 > height) {
    total = r2 + r3;
    r2 *= height / total;
    r3 *= height / total;
  }

  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }

  ctx.moveTo(x + r1, y);
  ctx.lineTo(x + width - r2, y);
  r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
  ctx.lineTo(x + width, y + height - r3);
  r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
  ctx.lineTo(x + r4, y + height);
  r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
  ctx.lineTo(x, y + r1);
  r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
}

exports.buildPath = buildPath;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/smoothBezier.js":
/***/ (function(module, exports, __webpack_require__) {

var _vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var v2Min = _vector.min;
var v2Max = _vector.max;
var v2Scale = _vector.scale;
var v2Distance = _vector.distance;
var v2Add = _vector.add;
var v2Clone = _vector.clone;
var v2Sub = _vector.sub;

/**
 * 贝塞尔平滑曲线
 * @module zrender/shape/util/smoothBezier
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 */

/**
 * 贝塞尔平滑曲线
 * @alias module:zrender/shape/util/smoothBezier
 * @param {Array} points 线段顶点数组
 * @param {number} smooth 平滑等级, 0-1
 * @param {boolean} isLoop
 * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
 *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
 *                           整个折线的包围盒做一个并集用来约束控制点。
 * @param {Array} 计算出来的控制点数组
 */
function _default(points, smooth, isLoop, constraint) {
  var cps = [];
  var v = [];
  var v1 = [];
  var v2 = [];
  var prevPoint;
  var nextPoint;
  var min, max;

  if (constraint) {
    min = [Infinity, Infinity];
    max = [-Infinity, -Infinity];

    for (var i = 0, len = points.length; i < len; i++) {
      v2Min(min, min, points[i]);
      v2Max(max, max, points[i]);
    } // 与指定的包围盒做并集


    v2Min(min, min, constraint[0]);
    v2Max(max, max, constraint[1]);
  }

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (isLoop) {
      prevPoint = points[i ? i - 1 : len - 1];
      nextPoint = points[(i + 1) % len];
    } else {
      if (i === 0 || i === len - 1) {
        cps.push(v2Clone(points[i]));
        continue;
      } else {
        prevPoint = points[i - 1];
        nextPoint = points[i + 1];
      }
    }

    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length

    v2Scale(v, v, smooth);
    var d0 = v2Distance(point, prevPoint);
    var d1 = v2Distance(point, nextPoint);
    var sum = d0 + d1;

    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }

    v2Scale(v1, v, -d0);
    v2Scale(v2, v, d1);
    var cp0 = v2Add([], point, v1);
    var cp1 = v2Add([], point, v2);

    if (constraint) {
      v2Max(cp0, cp0, min);
      v2Min(cp0, cp0, max);
      v2Max(cp1, cp1, min);
      v2Min(cp1, cp1, max);
    }

    cps.push(cp0);
    cps.push(cp1);
  }

  if (isLoop) {
    cps.push(cps.shift());
  }

  return cps;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/smoothSpline.js":
/***/ (function(module, exports, __webpack_require__) {

var _vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var v2Distance = _vector.distance;

/**
 * Catmull-Rom spline 插值折线
 * @module zrender/shape/util/smoothSpline
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 */

/**
 * @inner
 */
function interpolate(p0, p1, p2, p3, t, t2, t3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}
/**
 * @alias module:zrender/shape/util/smoothSpline
 * @param {Array} points 线段顶点数组
 * @param {boolean} isLoop
 * @return {Array}
 */


function _default(points, isLoop) {
  var len = points.length;
  var ret = [];
  var distance = 0;

  for (var i = 1; i < len; i++) {
    distance += v2Distance(points[i - 1], points[i]);
  }

  var segs = distance / 2;
  segs = segs < len ? len : segs;

  for (var i = 0; i < segs; i++) {
    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
    var idx = Math.floor(pos);
    var w = pos - idx;
    var p0;
    var p1 = points[idx % len];
    var p2;
    var p3;

    if (!isLoop) {
      p0 = points[idx === 0 ? idx : idx - 1];
      p2 = points[idx > len - 2 ? len - 1 : idx + 1];
      p3 = points[idx > len - 3 ? len - 1 : idx + 2];
    } else {
      p0 = points[(idx - 1 + len) % len];
      p2 = points[(idx + 1) % len];
      p3 = points[(idx + 2) % len];
    }

    var w2 = w * w;
    var w3 = w * w2;
    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
  }

  return ret;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/text.js":
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var retrieve2 = _util.retrieve2;
var retrieve3 = _util.retrieve3;
var each = _util.each;
var normalizeCssArray = _util.normalizeCssArray;
var isString = _util.isString;
var isObject = _util.isObject;

var textContain = __webpack_require__("./node_modules/zrender/lib/contain/text.js");

var roundRectHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/roundRect.js");

var imageHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/image.js");

var fixShadow = __webpack_require__("./node_modules/zrender/lib/graphic/helper/fixShadow.js");

// TODO: Have not support 'start', 'end' yet.
var VALID_TEXT_ALIGN = {
  left: 1,
  right: 1,
  center: 1
};
var VALID_TEXT_VERTICAL_ALIGN = {
  top: 1,
  bottom: 1,
  middle: 1
};
/**
 * @param {module:zrender/graphic/Style} style
 * @return {module:zrender/graphic/Style} The input style.
 */

function normalizeTextStyle(style) {
  normalizeStyle(style);
  each(style.rich, normalizeStyle);
  return style;
}

function normalizeStyle(style) {
  if (style) {
    style.font = textContain.makeFont(style);
    var textAlign = style.textAlign;
    textAlign === 'middle' && (textAlign = 'center');
    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.

    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
    var textPadding = style.textPadding;

    if (textPadding) {
      style.textPadding = normalizeCssArray(style.textPadding);
    }
  }
}
/**
 * @param {CanvasRenderingContext2D} ctx
 * @param {string} text
 * @param {module:zrender/graphic/Style} style
 * @param {Object|boolean} [rect] {x, y, width, height}
 *                  If set false, rect text is not used.
 */


function renderText(hostEl, ctx, text, style, rect) {
  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);
}

function renderPlainText(hostEl, ctx, text, style, rect) {
  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);
  var textPadding = style.textPadding;
  var contentBlock = hostEl.__textCotentBlock;

  if (!contentBlock || hostEl.__dirty) {
    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);
  }

  var outerHeight = contentBlock.outerHeight;
  var textLines = contentBlock.lines;
  var lineHeight = contentBlock.lineHeight;
  var boxPos = getBoxPosition(outerHeight, style, rect);
  var baseX = boxPos.baseX;
  var baseY = boxPos.baseY;
  var textAlign = boxPos.textAlign;
  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

  applyTextRotation(ctx, style, rect, baseX, baseY);
  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var textX = baseX;
  var textY = boxY;
  var needDrawBg = needDrawBackground(style);

  if (needDrawBg || textPadding) {
    // Consider performance, do not call getTextWidth util necessary.
    var textWidth = textContain.getWidth(text, font);
    var outerWidth = textWidth;
    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      textY += textPadding[0];
    }
  }

  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be "middle". Otherwise, if using "top", the
  // text will offset downward a little bit in font "Microsoft YaHei".

  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.

  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.

  textY += lineHeight / 2;
  var textStrokeWidth = style.textStrokeWidth;
  var textStroke = getStroke(style.textStroke, textStrokeWidth);
  var textFill = getFill(style.textFill);

  if (textStroke) {
    setCtx(ctx, 'lineWidth', textStrokeWidth);
    setCtx(ctx, 'strokeStyle', textStroke);
  }

  if (textFill) {
    setCtx(ctx, 'fillStyle', textFill);
  }

  for (var i = 0; i < textLines.length; i++) {
    // Fill after stroke so the outline will not cover the main part.
    textStroke && ctx.strokeText(textLines[i], textX, textY);
    textFill && ctx.fillText(textLines[i], textX, textY);
    textY += lineHeight;
  }
}

function renderRichText(hostEl, ctx, text, style, rect) {
  var contentBlock = hostEl.__textCotentBlock;

  if (!contentBlock || hostEl.__dirty) {
    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
  }

  drawRichText(hostEl, ctx, contentBlock, style, rect);
}

function drawRichText(hostEl, ctx, contentBlock, style, rect) {
  var contentWidth = contentBlock.width;
  var outerWidth = contentBlock.outerWidth;
  var outerHeight = contentBlock.outerHeight;
  var textPadding = style.textPadding;
  var boxPos = getBoxPosition(outerHeight, style, rect);
  var baseX = boxPos.baseX;
  var baseY = boxPos.baseY;
  var textAlign = boxPos.textAlign;
  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

  applyTextRotation(ctx, style, rect, baseX, baseY);
  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var xLeft = boxX;
  var lineTop = boxY;

  if (textPadding) {
    xLeft += textPadding[3];
    lineTop += textPadding[0];
  }

  var xRight = xLeft + contentWidth;
  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

  for (var i = 0; i < contentBlock.lines.length; i++) {
    var line = contentBlock.lines[i];
    var tokens = line.tokens;
    var tokenCount = tokens.length;
    var lineHeight = line.lineHeight;
    var usedWidth = line.width;
    var leftIndex = 0;
    var lineXLeft = xLeft;
    var lineXRight = xRight;
    var rightIndex = tokenCount - 1;
    var token;

    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
      usedWidth -= token.width;
      lineXLeft += token.width;
      leftIndex++;
    }

    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
      usedWidth -= token.width;
      lineXRight -= token.width;
      rightIndex--;
    } // The other tokens are placed as textAlign 'center' if there is enough space.


    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;

    while (leftIndex <= rightIndex) {
      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.

      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
      lineXLeft += token.width;
      leftIndex++;
    }

    lineTop += lineHeight;
  }
}

function applyTextRotation(ctx, style, rect, x, y) {
  // textRotation only apply in RectText.
  if (rect && style.textRotation) {
    var origin = style.textOrigin;

    if (origin === 'center') {
      x = rect.width / 2 + rect.x;
      y = rect.height / 2 + rect.y;
    } else if (origin) {
      x = origin[0] + rect.x;
      y = origin[1] + rect.y;
    }

    ctx.translate(x, y); // Positive: anticlockwise

    ctx.rotate(-style.textRotation);
    ctx.translate(-x, -y);
  }
}

function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of
  // the bias of "Microsoft YaHei".

  var textVerticalAlign = token.textVerticalAlign;
  var y = lineTop + lineHeight / 2;

  if (textVerticalAlign === 'top') {
    y = lineTop + token.height / 2;
  } else if (textVerticalAlign === 'bottom') {
    y = lineTop + lineHeight - token.height / 2;
  }

  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
  var textPadding = token.textPadding;

  if (textPadding) {
    x = getTextXForPadding(x, textAlign, textPadding);
    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
  }

  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
  // text will offset downward a little bit in font "Microsoft YaHei".

  setCtx(ctx, 'textBaseline', 'middle');
  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);
  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
  var textFill = getFill(tokenStyle.textFill || style.textFill);
  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.

  if (textStroke) {
    setCtx(ctx, 'lineWidth', textStrokeWidth);
    setCtx(ctx, 'strokeStyle', textStroke);
    ctx.strokeText(token.text, x, y);
  }

  if (textFill) {
    setCtx(ctx, 'fillStyle', textFill);
    ctx.fillText(token.text, x, y);
  }
}

function needDrawBackground(style) {
  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;
} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
// shape: {x, y, width, height}


function drawBackground(hostEl, ctx, style, x, y, width, height) {
  var textBackgroundColor = style.textBackgroundColor;
  var textBorderWidth = style.textBorderWidth;
  var textBorderColor = style.textBorderColor;
  var isPlainBg = isString(textBackgroundColor);
  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);

  if (isPlainBg || textBorderWidth && textBorderColor) {
    ctx.beginPath();
    var textBorderRadius = style.textBorderRadius;

    if (!textBorderRadius) {
      ctx.rect(x, y, width, height);
    } else {
      roundRectHelper.buildPath(ctx, {
        x: x,
        y: y,
        width: width,
        height: height,
        r: textBorderRadius
      });
    }

    ctx.closePath();
  }

  if (isPlainBg) {
    setCtx(ctx, 'fillStyle', textBackgroundColor);
    ctx.fill();
  } else if (isObject(textBackgroundColor)) {
    var image = textBackgroundColor.image;
    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);

    if (image && imageHelper.isImageReady(image)) {
      ctx.drawImage(image, x, y, width, height);
    }
  }

  if (textBorderWidth && textBorderColor) {
    setCtx(ctx, 'lineWidth', textBorderWidth);
    setCtx(ctx, 'strokeStyle', textBorderColor);
    ctx.stroke();
  }
}

function onBgImageLoaded(image, textBackgroundColor) {
  // Replace image, so that `contain/text.js#parseRichText`
  // will get correct result in next tick.
  textBackgroundColor.image = image;
}

function getBoxPosition(blockHeiht, style, rect) {
  var baseX = style.x || 0;
  var baseY = style.y || 0;
  var textAlign = style.textAlign;
  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord

  if (rect) {
    var textPosition = style.textPosition;

    if (textPosition instanceof Array) {
      // Percent
      baseX = rect.x + parsePercent(textPosition[0], rect.width);
      baseY = rect.y + parsePercent(textPosition[1], rect.height);
    } else {
      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);
      baseX = res.x;
      baseY = res.y; // Default align and baseline when has textPosition

      textAlign = textAlign || res.textAlign;
      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
    } // textOffset is only support in RectText, otherwise
    // we have to adjust boundingRect for textOffset.


    var textOffset = style.textOffset;

    if (textOffset) {
      baseX += textOffset[0];
      baseY += textOffset[1];
    }
  }

  return {
    baseX: baseX,
    baseY: baseY,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}

function setCtx(ctx, prop, value) {
  ctx[prop] = fixShadow(ctx, prop, value);
  return ctx[prop];
}
/**
 * @param {string} [stroke] If specified, do not check style.textStroke.
 * @param {string} [lineWidth] If specified, do not check style.textStroke.
 * @param {number} style
 */


function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
  : stroke.image || stroke.colorStops ? '#000' : stroke;
}

function getFill(fill) {
  return fill == null || fill === 'none' ? null // TODO pattern and gradient?
  : fill.image || fill.colorStops ? '#000' : fill;
}

function parsePercent(value, maxValue) {
  if (typeof value === 'string') {
    if (value.lastIndexOf('%') >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }

    return parseFloat(value);
  }

  return value;
}

function getTextXForPadding(x, textAlign, textPadding) {
  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}
/**
 * @param {string} text
 * @param {module:zrender/Style} style
 * @return {boolean}
 */


function needDrawText(text, style) {
  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
}

exports.normalizeTextStyle = normalizeTextStyle;
exports.renderText = renderText;
exports.getStroke = getStroke;
exports.getFill = getFill;
exports.needDrawText = needDrawText;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/mixin/RectText.js":
/***/ (function(module, exports, __webpack_require__) {

var textHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/text.js");

var BoundingRect = __webpack_require__("./node_modules/zrender/lib/core/BoundingRect.js");

/**
 * Mixin for drawing text in a element bounding rect
 * @module zrender/mixin/RectText
 */
var tmpRect = new BoundingRect();

var RectText = function () {};

RectText.prototype = {
  constructor: RectText,

  /**
   * Draw text in a rect with specified position.
   * @param  {CanvasRenderingContext2D} ctx
   * @param  {Object} rect Displayable rect
   */
  drawRectText: function (ctx, rect) {
    var style = this.style;
    rect = style.textRect || rect; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true);
    var text = style.text; // Convert to string

    text != null && (text += '');

    if (!textHelper.needDrawText(text, style)) {
      return;
    } // FIXME


    ctx.save(); // Transform rect to view space

    var transform = this.transform;

    if (!style.transformText) {
      if (transform) {
        tmpRect.copy(rect);
        tmpRect.applyTransform(transform);
        rect = tmpRect;
      }
    } else {
      this.setTransform(ctx);
    } // transformText and textRotation can not be used at the same time.


    textHelper.renderText(this, ctx, text, style, rect);
    ctx.restore();
  }
};
var _default = RectText;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Arc.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

/**
 * 圆弧
 * @module zrender/graphic/shape/Arc
 */
var _default = Path.extend({
  type: 'arc',
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    startAngle: 0,
    endAngle: Math.PI * 2,
    clockwise: true
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/BezierCurve.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var vec2 = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var _curve = __webpack_require__("./node_modules/zrender/lib/core/curve.js");

var quadraticSubdivide = _curve.quadraticSubdivide;
var cubicSubdivide = _curve.cubicSubdivide;
var quadraticAt = _curve.quadraticAt;
var cubicAt = _curve.cubicAt;
var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
var cubicDerivativeAt = _curve.cubicDerivativeAt;

/**
 * 贝塞尔曲线
 * @module zrender/shape/BezierCurve
 */
var out = [];

function someVectorAt(shape, t, isTangent) {
  var cpx2 = shape.cpx2;
  var cpy2 = shape.cpy2;

  if (cpx2 === null || cpy2 === null) {
    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
  } else {
    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
  }
}

var _default = Path.extend({
  type: 'bezier-curve',
  shape: {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    cpx1: 0,
    cpy1: 0,
    // cpx2: 0,
    // cpy2: 0
    // Curve show percent, for animating
    percent: 1
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var cpx1 = shape.cpx1;
    var cpy1 = shape.cpy1;
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    var percent = shape.percent;

    if (percent === 0) {
      return;
    }

    ctx.moveTo(x1, y1);

    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y1, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }

      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }

      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  },

  /**
   * Get point at percent
   * @param  {number} t
   * @return {Array.<number>}
   */
  pointAt: function (t) {
    return someVectorAt(this.shape, t, false);
  },

  /**
   * Get tangent at percent
   * @param  {number} t
   * @return {Array.<number>}
   */
  tangentAt: function (t) {
    var p = someVectorAt(this.shape, t, true);
    return vec2.normalize(p, p);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Circle.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

/**
 * 圆形
 * @module zrender/shape/Circle
 */
var _default = Path.extend({
  type: 'circle',
  shape: {
    cx: 0,
    cy: 0,
    r: 0
  },
  buildPath: function (ctx, shape, inBundle) {
    // Better stroking in ShapeBundle
    // Always do it may have performence issue ( fill may be 2x more cost)
    if (inBundle) {
      ctx.moveTo(shape.cx + shape.r, shape.cy);
    } // else {
    //     if (ctx.allocate && !ctx.data.length) {
    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
    //     }
    // }
    // Better stroking in ShapeBundle
    // ctx.moveTo(shape.cx + shape.r, shape.cy);


    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Line.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

/**
 * 直线
 * @module zrender/graphic/shape/Line
 */
var _default = Path.extend({
  type: 'line',
  shape: {
    // Start point
    x1: 0,
    y1: 0,
    // End point
    x2: 0,
    y2: 0,
    percent: 1
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var percent = shape.percent;

    if (percent === 0) {
      return;
    }

    ctx.moveTo(x1, y1);

    if (percent < 1) {
      x2 = x1 * (1 - percent) + x2 * percent;
      y2 = y1 * (1 - percent) + y2 * percent;
    }

    ctx.lineTo(x2, y2);
  },

  /**
   * Get point at percent
   * @param  {number} percent
   * @return {Array.<number>}
   */
  pointAt: function (p) {
    var shape = this.shape;
    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Polygon.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var polyHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/poly.js");

/**
 * 多边形
 * @module zrender/shape/Polygon
 */
var _default = Path.extend({
  type: 'polygon',
  shape: {
    points: null,
    smooth: false,
    smoothConstraint: null
  },
  buildPath: function (ctx, shape) {
    polyHelper.buildPath(ctx, shape, true);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Polyline.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var polyHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/poly.js");

/**
 * @module zrender/graphic/shape/Polyline
 */
var _default = Path.extend({
  type: 'polyline',
  shape: {
    points: null,
    smooth: false,
    smoothConstraint: null
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    polyHelper.buildPath(ctx, shape, false);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Rect.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var roundRectHelper = __webpack_require__("./node_modules/zrender/lib/graphic/helper/roundRect.js");

/**
 * 矩形
 * @module zrender/graphic/shape/Rect
 */
var _default = Path.extend({
  type: 'rect',
  shape: {
    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
    // r缩写为1         相当于 [1, 1, 1, 1]
    // r缩写为[1]       相当于 [1, 1, 1, 1]
    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
    r: 0,
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (ctx, shape) {
    var x = shape.x;
    var y = shape.y;
    var width = shape.width;
    var height = shape.height;

    if (!shape.r) {
      ctx.rect(x, y, width, height);
    } else {
      roundRectHelper.buildPath(ctx, shape);
    }

    ctx.closePath();
    return;
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Ring.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

/**
 * 圆环
 * @module zrender/graphic/shape/Ring
 */
var _default = Path.extend({
  type: 'ring',
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    r0: 0
  },
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var PI2 = Math.PI * 2;
    ctx.moveTo(x + shape.r, y);
    ctx.arc(x, y, shape.r, 0, PI2, false);
    ctx.moveTo(x + shape.r0, y);
    ctx.arc(x, y, shape.r0, 0, PI2, true);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Sector.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var fixClipWithShadow = __webpack_require__("./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js");

/**
 * 扇形
 * @module zrender/graphic/shape/Sector
 */
var _default = Path.extend({
  type: 'sector',
  shape: {
    cx: 0,
    cy: 0,
    r0: 0,
    r: 0,
    startAngle: 0,
    endAngle: Math.PI * 2,
    clockwise: true
  },
  brush: fixClipWithShadow(Path.prototype.brush),
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
    ctx.lineTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);

    if (r0 !== 0) {
      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
    }

    ctx.closePath();
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Animatable.js":
/***/ (function(module, exports, __webpack_require__) {

var Animator = __webpack_require__("./node_modules/zrender/lib/animation/Animator.js");

var log = __webpack_require__("./node_modules/zrender/lib/core/log.js");

var _util = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var isString = _util.isString;
var isFunction = _util.isFunction;
var isObject = _util.isObject;
var isArrayLike = _util.isArrayLike;
var indexOf = _util.indexOf;

/**
 * @alias modue:zrender/mixin/Animatable
 * @constructor
 */
var Animatable = function () {
  /**
   * @type {Array.<module:zrender/animation/Animator>}
   * @readOnly
   */
  this.animators = [];
};

Animatable.prototype = {
  constructor: Animatable,

  /**
   * 动画
   *
   * @param {string} path The path to fetch value from object, like 'a.b.c'.
   * @param {boolean} [loop] Whether to loop animation.
   * @return {module:zrender/animation/Animator}
   * @example:
   *     el.animate('style', false)
   *         .when(1000, {x: 10} )
   *         .done(function(){ // Animation done })
   *         .start()
   */
  animate: function (path, loop) {
    var target;
    var animatingShape = false;
    var el = this;
    var zr = this.__zr;

    if (path) {
      var pathSplitted = path.split('.');
      var prop = el; // If animating shape

      animatingShape = pathSplitted[0] === 'shape';

      for (var i = 0, l = pathSplitted.length; i < l; i++) {
        if (!prop) {
          continue;
        }

        prop = prop[pathSplitted[i]];
      }

      if (prop) {
        target = prop;
      }
    } else {
      target = el;
    }

    if (!target) {
      log('Property "' + path + '" is not existed in element ' + el.id);
      return;
    }

    var animators = el.animators;
    var animator = new Animator(target, loop);
    animator.during(function (target) {
      el.dirty(animatingShape);
    }).done(function () {
      // FIXME Animator will not be removed if use `Animator#stop` to stop animation
      animators.splice(indexOf(animators, animator), 1);
    });
    animators.push(animator); // If animate after added to the zrender

    if (zr) {
      zr.animation.addAnimator(animator);
    }

    return animator;
  },

  /**
   * 停止动画
   * @param {boolean} forwardToLast If move to last frame before stop
   */
  stopAnimation: function (forwardToLast) {
    var animators = this.animators;
    var len = animators.length;

    for (var i = 0; i < len; i++) {
      animators[i].stop(forwardToLast);
    }

    animators.length = 0;
    return this;
  },

  /**
   * Caution: this method will stop previous animation.
   * So do not use this method to one element twice before
   * animation starts, unless you know what you are doing.
   * @param {Object} target
   * @param {number} [time=500] Time in ms
   * @param {string} [easing='linear']
   * @param {number} [delay=0]
   * @param {Function} [callback]
   * @param {Function} [forceAnimate] Prevent stop animation and callback
   *        immediently when target values are the same as current values.
   *
   * @example
   *  // Animate position
   *  el.animateTo({
   *      position: [10, 10]
   *  }, function () { // done })
   *
   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
   *  el.animateTo({
   *      shape: {
   *          width: 500
   *      },
   *      style: {
   *          fill: 'red'
   *      }
   *      position: [10, 10]
   *  }, 100, 100, 'cubicOut', function () { // done })
   */
  // TODO Return animation key
  animateTo: function (target, time, delay, easing, callback, forceAnimate) {
    // animateTo(target, time, easing, callback);
    if (isString(delay)) {
      callback = easing;
      easing = delay;
      delay = 0;
    } // animateTo(target, time, delay, callback);
    else if (isFunction(easing)) {
        callback = easing;
        easing = 'linear';
        delay = 0;
      } // animateTo(target, time, callback);
      else if (isFunction(delay)) {
          callback = delay;
          delay = 0;
        } // animateTo(target, callback)
        else if (isFunction(time)) {
            callback = time;
            time = 500;
          } // animateTo(target)
          else if (!time) {
              time = 500;
            } // Stop all previous animations


    this.stopAnimation();

    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start
    // if there is nothing to animate


    var animators = this.animators.slice();
    var count = animators.length;

    function done() {
      count--;

      if (!count) {
        callback && callback();
      }
    } // No animators. This should be checked before animators[i].start(),
    // because 'done' may be executed immediately if no need to animate.


    if (!count) {
      callback && callback();
    } // Start after all animators created
    // Incase any animator is done immediately when all animation properties are not changed


    for (var i = 0; i < animators.length; i++) {
      animators[i].done(done).start(easing, forceAnimate);
    }
  },

  /**
   * @private
   * @param {string} path=''
   * @param {Object} source=this
   * @param {Object} target
   * @param {number} [time=500]
   * @param {number} [delay=0]
   *
   * @example
   *  // Animate position
   *  el._animateToShallow({
   *      position: [10, 10]
   *  })
   *
   *  // Animate shape, style and position in 100ms, delayed 100ms
   *  el._animateToShallow({
   *      shape: {
   *          width: 500
   *      },
   *      style: {
   *          fill: 'red'
   *      }
   *      position: [10, 10]
   *  }, 100, 100)
   */
  _animateToShallow: function (path, source, target, time, delay) {
    var objShallow = {};
    var propertyCount = 0;

    for (var name in target) {
      if (!target.hasOwnProperty(name)) {
        continue;
      }

      if (source[name] != null) {
        if (isObject(target[name]) && !isArrayLike(target[name])) {
          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
        } else {
          objShallow[name] = target[name];
          propertyCount++;
        }
      } else if (target[name] != null) {
        // Attr directly if not has property
        // FIXME, if some property not needed for element ?
        if (!path) {
          this.attr(name, target[name]);
        } else {
          // Shape or style
          var props = {};
          props[path] = {};
          props[path][name] = target[name];
          this.attr(props);
        }
      }
    }

    if (propertyCount > 0) {
      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
    }

    return this;
  }
};
var _default = Animatable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Draggable.js":
/***/ (function(module, exports) {

// TODO Draggable for group
// FIXME Draggable on element which has parent rotation or scale
function Draggable() {
  this.on('mousedown', this._dragStart, this);
  this.on('mousemove', this._drag, this);
  this.on('mouseup', this._dragEnd, this);
  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;
  // this._draggingTarget = null;
  // this._x = 0;
  // this._y = 0;
}

Draggable.prototype = {
  constructor: Draggable,
  _dragStart: function (e) {
    var draggingTarget = e.target;

    if (draggingTarget && draggingTarget.draggable) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e.offsetX;
      this._y = e.offsetY;
      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
    }
  },
  _drag: function (e) {
    var draggingTarget = this._draggingTarget;

    if (draggingTarget) {
      var x = e.offsetX;
      var y = e.offsetY;
      var dx = x - this._x;
      var dy = y - this._y;
      this._x = x;
      this._y = y;
      draggingTarget.drift(dx, dy, e);
      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
      var dropTarget = this.findHover(x, y, draggingTarget).target;
      var lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;

      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
        }

        if (dropTarget && dropTarget !== lastDropTarget) {
          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
        }
      }
    }
  },
  _dragEnd: function (e) {
    var draggingTarget = this._draggingTarget;

    if (draggingTarget) {
      draggingTarget.dragging = false;
    }

    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);

    if (this._dropTarget) {
      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
    }

    this._draggingTarget = null;
    this._dropTarget = null;
  }
};

function param(target, e) {
  return {
    target: target,
    topTarget: e && e.topTarget
  };
}

var _default = Draggable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Eventful.js":
/***/ (function(module, exports) {

/**
 * 事件扩展
 * @module zrender/mixin/Eventful
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */
var arrySlice = Array.prototype.slice;
/**
 * 事件分发器
 * @alias module:zrender/mixin/Eventful
 * @constructor
 */

var Eventful = function () {
  this._$handlers = {};
};

Eventful.prototype = {
  constructor: Eventful,

  /**
   * 单次触发绑定，trigger后销毁
   *
   * @param {string} event 事件名
   * @param {Function} handler 响应函数
   * @param {Object} context
   */
  one: function (event, handler, context) {
    var _h = this._$handlers;

    if (!handler || !event) {
      return this;
    }

    if (!_h[event]) {
      _h[event] = [];
    }

    for (var i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }

    _h[event].push({
      h: handler,
      one: true,
      ctx: context || this
    });

    return this;
  },

  /**
   * 绑定事件
   * @param {string} event 事件名
   * @param {Function} handler 事件处理函数
   * @param {Object} [context]
   */
  on: function (event, handler, context) {
    var _h = this._$handlers;

    if (!handler || !event) {
      return this;
    }

    if (!_h[event]) {
      _h[event] = [];
    }

    for (var i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }

    _h[event].push({
      h: handler,
      one: false,
      ctx: context || this
    });

    return this;
  },

  /**
   * 是否绑定了事件
   * @param  {string}  event
   * @return {boolean}
   */
  isSilent: function (event) {
    var _h = this._$handlers;
    return _h[event] && _h[event].length;
  },

  /**
   * 解绑事件
   * @param {string} event 事件名
   * @param {Function} [handler] 事件处理函数
   */
  off: function (event, handler) {
    var _h = this._$handlers;

    if (!event) {
      this._$handlers = {};
      return this;
    }

    if (handler) {
      if (_h[event]) {
        var newList = [];

        for (var i = 0, l = _h[event].length; i < l; i++) {
          if (_h[event][i]['h'] != handler) {
            newList.push(_h[event][i]);
          }
        }

        _h[event] = newList;
      }

      if (_h[event] && _h[event].length === 0) {
        delete _h[event];
      }
    } else {
      delete _h[event];
    }

    return this;
  },

  /**
   * 事件分发
   *
   * @param {string} type 事件类型
   */
  trigger: function (type) {
    if (this._$handlers[type]) {
      var args = arguments;
      var argLen = args.length;

      if (argLen > 3) {
        args = arrySlice.call(args, 1);
      }

      var _h = this._$handlers[type];
      var len = _h.length;

      for (var i = 0; i < len;) {
        // Optimize advise from backbone
        switch (argLen) {
          case 1:
            _h[i]['h'].call(_h[i]['ctx']);

            break;

          case 2:
            _h[i]['h'].call(_h[i]['ctx'], args[1]);

            break;

          case 3:
            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);

            break;

          default:
            // have more than 2 given arguments
            _h[i]['h'].apply(_h[i]['ctx'], args);

            break;
        }

        if (_h[i]['one']) {
          _h.splice(i, 1);

          len--;
        } else {
          i++;
        }
      }
    }

    return this;
  },

  /**
   * 带有context的事件分发, 最后一个参数是事件回调的context
   * @param {string} type 事件类型
   */
  triggerWithContext: function (type) {
    if (this._$handlers[type]) {
      var args = arguments;
      var argLen = args.length;

      if (argLen > 4) {
        args = arrySlice.call(args, 1, args.length - 1);
      }

      var ctx = args[args.length - 1];
      var _h = this._$handlers[type];
      var len = _h.length;

      for (var i = 0; i < len;) {
        // Optimize advise from backbone
        switch (argLen) {
          case 1:
            _h[i]['h'].call(ctx);

            break;

          case 2:
            _h[i]['h'].call(ctx, args[1]);

            break;

          case 3:
            _h[i]['h'].call(ctx, args[1], args[2]);

            break;

          default:
            // have more than 2 given arguments
            _h[i]['h'].apply(ctx, args);

            break;
        }

        if (_h[i]['one']) {
          _h.splice(i, 1);

          len--;
        } else {
          i++;
        }
      }
    }

    return this;
  }
}; // 对象可以通过 onxxxx 绑定事件

/**
 * @event module:zrender/mixin/Eventful#onclick
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseover
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseout
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousemove
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousewheel
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousedown
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseup
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondrag
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragstart
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragend
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragenter
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragleave
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragover
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondrop
 * @type {Function}
 * @default null
 */

var _default = Eventful;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Transformable.js":
/***/ (function(module, exports, __webpack_require__) {

var matrix = __webpack_require__("./node_modules/zrender/lib/core/matrix.js");

var vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

/**
 * 提供变换扩展
 * @module zrender/mixin/Transformable
 * @author pissang (https://www.github.com/pissang)
 */
var mIdentity = matrix.identity;
var EPSILON = 5e-5;

function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
/**
 * @alias module:zrender/mixin/Transformable
 * @constructor
 */


var Transformable = function (opts) {
  opts = opts || {}; // If there are no given position, rotation, scale

  if (!opts.position) {
    /**
     * 平移
     * @type {Array.<number>}
     * @default [0, 0]
     */
    this.position = [0, 0];
  }

  if (opts.rotation == null) {
    /**
     * 旋转
     * @type {Array.<number>}
     * @default 0
     */
    this.rotation = 0;
  }

  if (!opts.scale) {
    /**
     * 缩放
     * @type {Array.<number>}
     * @default [1, 1]
     */
    this.scale = [1, 1];
  }
  /**
   * 旋转和缩放的原点
   * @type {Array.<number>}
   * @default null
   */


  this.origin = this.origin || null;
};

var transformableProto = Transformable.prototype;
transformableProto.transform = null;
/**
 * 判断是否需要有坐标变换
 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
 */

transformableProto.needLocalTransform = function () {
  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
};

transformableProto.updateTransform = function () {
  var parent = this.parent;
  var parentHasTransform = parent && parent.transform;
  var needLocalTransform = this.needLocalTransform();
  var m = this.transform;

  if (!(needLocalTransform || parentHasTransform)) {
    m && mIdentity(m);
    return;
  }

  m = m || matrix.create();

  if (needLocalTransform) {
    this.getLocalTransform(m);
  } else {
    mIdentity(m);
  } // 应用父节点变换


  if (parentHasTransform) {
    if (needLocalTransform) {
      matrix.mul(m, parent.transform, m);
    } else {
      matrix.copy(m, parent.transform);
    }
  } // 保存这个变换矩阵


  this.transform = m;
  this.invTransform = this.invTransform || matrix.create();
  matrix.invert(this.invTransform, m);
};

transformableProto.getLocalTransform = function (m) {
  return Transformable.getLocalTransform(this, m);
};
/**
 * 将自己的transform应用到context上
 * @param {CanvasRenderingContext2D} ctx
 */


transformableProto.setTransform = function (ctx) {
  var m = this.transform;
  var dpr = ctx.dpr || 1;

  if (m) {
    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
  } else {
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
};

transformableProto.restoreTransform = function (ctx) {
  var dpr = ctx.dpr || 1;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
};

var tmpTransform = [];
/**
 * 分解`transform`矩阵到`position`, `rotation`, `scale`
 */

transformableProto.decomposeTransform = function () {
  if (!this.transform) {
    return;
  }

  var parent = this.parent;
  var m = this.transform;

  if (parent && parent.transform) {
    // Get local transform and decompose them to position, scale, rotation
    matrix.mul(tmpTransform, parent.invTransform, m);
    m = tmpTransform;
  }

  var sx = m[0] * m[0] + m[1] * m[1];
  var sy = m[2] * m[2] + m[3] * m[3];
  var position = this.position;
  var scale = this.scale;

  if (isNotAroundZero(sx - 1)) {
    sx = Math.sqrt(sx);
  }

  if (isNotAroundZero(sy - 1)) {
    sy = Math.sqrt(sy);
  }

  if (m[0] < 0) {
    sx = -sx;
  }

  if (m[3] < 0) {
    sy = -sy;
  }

  position[0] = m[4];
  position[1] = m[5];
  scale[0] = sx;
  scale[1] = sy;
  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
};
/**
 * Get global scale
 * @return {Array.<number>}
 */


transformableProto.getGlobalScale = function () {
  var m = this.transform;

  if (!m) {
    return [1, 1];
  }

  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);

  if (m[0] < 0) {
    sx = -sx;
  }

  if (m[3] < 0) {
    sy = -sy;
  }

  return [sx, sy];
};
/**
 * 变换坐标位置到 shape 的局部坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */


transformableProto.transformCoordToLocal = function (x, y) {
  var v2 = [x, y];
  var invTransform = this.invTransform;

  if (invTransform) {
    vector.applyTransform(v2, v2, invTransform);
  }

  return v2;
};
/**
 * 变换局部坐标位置到全局坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */


transformableProto.transformCoordToGlobal = function (x, y) {
  var v2 = [x, y];
  var transform = this.transform;

  if (transform) {
    vector.applyTransform(v2, v2, transform);
  }

  return v2;
};
/**
 * @static
 * @param {Object} target
 * @param {Array.<number>} target.origin
 * @param {number} target.rotation
 * @param {Array.<number>} target.position
 * @param {Array.<number>} [m]
 */


Transformable.getLocalTransform = function (target, m) {
  m = m || [];
  mIdentity(m);
  var origin = target.origin;
  var scale = target.scale || [1, 1];
  var rotation = target.rotation || 0;
  var position = target.position || [0, 0];

  if (origin) {
    // Translate to origin
    m[4] -= origin[0];
    m[5] -= origin[1];
  }

  matrix.scale(m, m, scale);

  if (rotation) {
    matrix.rotate(m, m, rotation);
  }

  if (origin) {
    // Translate back from origin
    m[4] += origin[0];
    m[5] += origin[1];
  }

  m[4] += position[0];
  m[5] += position[1];
  return m;
};

var _default = Transformable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/tool/color.js":
/***/ (function(module, exports, __webpack_require__) {

var LRU = __webpack_require__("./node_modules/zrender/lib/core/LRU.js");

var kCSSColorTable = {
  'transparent': [0, 0, 0, 0],
  'aliceblue': [240, 248, 255, 1],
  'antiquewhite': [250, 235, 215, 1],
  'aqua': [0, 255, 255, 1],
  'aquamarine': [127, 255, 212, 1],
  'azure': [240, 255, 255, 1],
  'beige': [245, 245, 220, 1],
  'bisque': [255, 228, 196, 1],
  'black': [0, 0, 0, 1],
  'blanchedalmond': [255, 235, 205, 1],
  'blue': [0, 0, 255, 1],
  'blueviolet': [138, 43, 226, 1],
  'brown': [165, 42, 42, 1],
  'burlywood': [222, 184, 135, 1],
  'cadetblue': [95, 158, 160, 1],
  'chartreuse': [127, 255, 0, 1],
  'chocolate': [210, 105, 30, 1],
  'coral': [255, 127, 80, 1],
  'cornflowerblue': [100, 149, 237, 1],
  'cornsilk': [255, 248, 220, 1],
  'crimson': [220, 20, 60, 1],
  'cyan': [0, 255, 255, 1],
  'darkblue': [0, 0, 139, 1],
  'darkcyan': [0, 139, 139, 1],
  'darkgoldenrod': [184, 134, 11, 1],
  'darkgray': [169, 169, 169, 1],
  'darkgreen': [0, 100, 0, 1],
  'darkgrey': [169, 169, 169, 1],
  'darkkhaki': [189, 183, 107, 1],
  'darkmagenta': [139, 0, 139, 1],
  'darkolivegreen': [85, 107, 47, 1],
  'darkorange': [255, 140, 0, 1],
  'darkorchid': [153, 50, 204, 1],
  'darkred': [139, 0, 0, 1],
  'darksalmon': [233, 150, 122, 1],
  'darkseagreen': [143, 188, 143, 1],
  'darkslateblue': [72, 61, 139, 1],
  'darkslategray': [47, 79, 79, 1],
  'darkslategrey': [47, 79, 79, 1],
  'darkturquoise': [0, 206, 209, 1],
  'darkviolet': [148, 0, 211, 1],
  'deeppink': [255, 20, 147, 1],
  'deepskyblue': [0, 191, 255, 1],
  'dimgray': [105, 105, 105, 1],
  'dimgrey': [105, 105, 105, 1],
  'dodgerblue': [30, 144, 255, 1],
  'firebrick': [178, 34, 34, 1],
  'floralwhite': [255, 250, 240, 1],
  'forestgreen': [34, 139, 34, 1],
  'fuchsia': [255, 0, 255, 1],
  'gainsboro': [220, 220, 220, 1],
  'ghostwhite': [248, 248, 255, 1],
  'gold': [255, 215, 0, 1],
  'goldenrod': [218, 165, 32, 1],
  'gray': [128, 128, 128, 1],
  'green': [0, 128, 0, 1],
  'greenyellow': [173, 255, 47, 1],
  'grey': [128, 128, 128, 1],
  'honeydew': [240, 255, 240, 1],
  'hotpink': [255, 105, 180, 1],
  'indianred': [205, 92, 92, 1],
  'indigo': [75, 0, 130, 1],
  'ivory': [255, 255, 240, 1],
  'khaki': [240, 230, 140, 1],
  'lavender': [230, 230, 250, 1],
  'lavenderblush': [255, 240, 245, 1],
  'lawngreen': [124, 252, 0, 1],
  'lemonchiffon': [255, 250, 205, 1],
  'lightblue': [173, 216, 230, 1],
  'lightcoral': [240, 128, 128, 1],
  'lightcyan': [224, 255, 255, 1],
  'lightgoldenrodyellow': [250, 250, 210, 1],
  'lightgray': [211, 211, 211, 1],
  'lightgreen': [144, 238, 144, 1],
  'lightgrey': [211, 211, 211, 1],
  'lightpink': [255, 182, 193, 1],
  'lightsalmon': [255, 160, 122, 1],
  'lightseagreen': [32, 178, 170, 1],
  'lightskyblue': [135, 206, 250, 1],
  'lightslategray': [119, 136, 153, 1],
  'lightslategrey': [119, 136, 153, 1],
  'lightsteelblue': [176, 196, 222, 1],
  'lightyellow': [255, 255, 224, 1],
  'lime': [0, 255, 0, 1],
  'limegreen': [50, 205, 50, 1],
  'linen': [250, 240, 230, 1],
  'magenta': [255, 0, 255, 1],
  'maroon': [128, 0, 0, 1],
  'mediumaquamarine': [102, 205, 170, 1],
  'mediumblue': [0, 0, 205, 1],
  'mediumorchid': [186, 85, 211, 1],
  'mediumpurple': [147, 112, 219, 1],
  'mediumseagreen': [60, 179, 113, 1],
  'mediumslateblue': [123, 104, 238, 1],
  'mediumspringgreen': [0, 250, 154, 1],
  'mediumturquoise': [72, 209, 204, 1],
  'mediumvioletred': [199, 21, 133, 1],
  'midnightblue': [25, 25, 112, 1],
  'mintcream': [245, 255, 250, 1],
  'mistyrose': [255, 228, 225, 1],
  'moccasin': [255, 228, 181, 1],
  'navajowhite': [255, 222, 173, 1],
  'navy': [0, 0, 128, 1],
  'oldlace': [253, 245, 230, 1],
  'olive': [128, 128, 0, 1],
  'olivedrab': [107, 142, 35, 1],
  'orange': [255, 165, 0, 1],
  'orangered': [255, 69, 0, 1],
  'orchid': [218, 112, 214, 1],
  'palegoldenrod': [238, 232, 170, 1],
  'palegreen': [152, 251, 152, 1],
  'paleturquoise': [175, 238, 238, 1],
  'palevioletred': [219, 112, 147, 1],
  'papayawhip': [255, 239, 213, 1],
  'peachpuff': [255, 218, 185, 1],
  'peru': [205, 133, 63, 1],
  'pink': [255, 192, 203, 1],
  'plum': [221, 160, 221, 1],
  'powderblue': [176, 224, 230, 1],
  'purple': [128, 0, 128, 1],
  'red': [255, 0, 0, 1],
  'rosybrown': [188, 143, 143, 1],
  'royalblue': [65, 105, 225, 1],
  'saddlebrown': [139, 69, 19, 1],
  'salmon': [250, 128, 114, 1],
  'sandybrown': [244, 164, 96, 1],
  'seagreen': [46, 139, 87, 1],
  'seashell': [255, 245, 238, 1],
  'sienna': [160, 82, 45, 1],
  'silver': [192, 192, 192, 1],
  'skyblue': [135, 206, 235, 1],
  'slateblue': [106, 90, 205, 1],
  'slategray': [112, 128, 144, 1],
  'slategrey': [112, 128, 144, 1],
  'snow': [255, 250, 250, 1],
  'springgreen': [0, 255, 127, 1],
  'steelblue': [70, 130, 180, 1],
  'tan': [210, 180, 140, 1],
  'teal': [0, 128, 128, 1],
  'thistle': [216, 191, 216, 1],
  'tomato': [255, 99, 71, 1],
  'turquoise': [64, 224, 208, 1],
  'violet': [238, 130, 238, 1],
  'wheat': [245, 222, 179, 1],
  'white': [255, 255, 255, 1],
  'whitesmoke': [245, 245, 245, 1],
  'yellow': [255, 255, 0, 1],
  'yellowgreen': [154, 205, 50, 1]
};

function clampCssByte(i) {
  // Clamp to integer 0 .. 255.
  i = Math.round(i); // Seems to be what Chrome does (vs truncation).

  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clampCssAngle(i) {
  // Clamp to integer 0 .. 360.
  i = Math.round(i); // Seems to be what Chrome does (vs truncation).

  return i < 0 ? 0 : i > 360 ? 360 : i;
}

function clampCssFloat(f) {
  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parseCssInt(str) {
  // int or percentage.
  if (str.length && str.charAt(str.length - 1) === '%') {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }

  return clampCssByte(parseInt(str, 10));
}

function parseCssFloat(str) {
  // float or percentage.
  if (str.length && str.charAt(str.length - 1) === '%') {
    return clampCssFloat(parseFloat(str) / 100);
  }

  return clampCssFloat(parseFloat(str));
}

function cssHueToRgb(m1, m2, h) {
  if (h < 0) {
    h += 1;
  } else if (h > 1) {
    h -= 1;
  }

  if (h * 6 < 1) {
    return m1 + (m2 - m1) * h * 6;
  }

  if (h * 2 < 1) {
    return m2;
  }

  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }

  return m1;
}

function lerpNumber(a, b, p) {
  return a + (b - a) * p;
}

function setRgba(out, r, g, b, a) {
  out[0] = r;
  out[1] = g;
  out[2] = b;
  out[3] = a;
  return out;
}

function copyRgba(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

var colorCache = new LRU(20);
var lastRemovedArr = null;

function putToCache(colorStr, rgbaArr) {
  // Reuse removed array
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }

  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
/**
 * @param {string} colorStr
 * @param {Array.<number>} out
 * @return {Array.<number>}
 * @memberOf module:zrender/util/color
 */


function parse(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }

  rgbaArr = rgbaArr || [];
  var cached = colorCache.get(colorStr);

  if (cached) {
    return copyRgba(rgbaArr, cached);
  } // colorStr may be not string


  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.

  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  } // #abc and #abc123 syntax.


  if (str.charAt(0) === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

      if (!(iv >= 0 && iv <= 0xfff)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return; // Covers NaN.
      }

      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

      if (!(iv >= 0 && iv <= 0xffffff)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return; // Covers NaN.
      }

      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }

    return;
  }

  var op = str.indexOf('('),
      ep = str.indexOf(')');

  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op + 1, ep - (op + 1)).split(',');
    var alpha = 1; // To allow case fallthrough.

    switch (fname) {
      case 'rgba':
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        alpha = parseCssFloat(params.pop());
      // jshint ignore:line
      // Fall through.

      case 'rgb':
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      case 'hsla':
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      case 'hsl':
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      default:
        return;
    }
  }

  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
/**
 * @param {Array.<number>} hsla
 * @param {Array.<number>} rgba
 * @return {Array.<number>} rgba
 */


function hsla2rgba(hsla, rgba) {
  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
  // NOTE(deanm): According to the CSS spec s/l should only be
  // percentages, but we don't bother and let float or percentage.

  var s = parseCssFloat(hsla[1]);
  var l = parseCssFloat(hsla[2]);
  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  var m1 = l * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);

  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }

  return rgba;
}
/**
 * @param {Array.<number>} rgba
 * @return {Array.<number>} hsla
 */


function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  } // RGB from 0 to 255


  var R = rgba[0] / 255;
  var G = rgba[1] / 255;
  var B = rgba[2] / 255;
  var vMin = Math.min(R, G, B); // Min. value of RGB

  var vMax = Math.max(R, G, B); // Max. value of RGB

  var delta = vMax - vMin; // Delta RGB value

  var L = (vMax + vMin) / 2;
  var H;
  var S; // HSL results from 0 to 1

  if (delta === 0) {
    H = 0;
    S = 0;
  } else {
    if (L < 0.5) {
      S = delta / (vMax + vMin);
    } else {
      S = delta / (2 - vMax - vMin);
    }

    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;

    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }

    if (H < 0) {
      H += 1;
    }

    if (H > 1) {
      H -= 1;
    }
  }

  var hsla = [H * 360, S, L];

  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }

  return hsla;
}
/**
 * @param {string} color
 * @param {number} level
 * @return {string}
 * @memberOf module:zrender/util/color
 */


function lift(color, level) {
  var colorArr = parse(color);

  if (colorArr) {
    for (var i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }

      if (colorArr[i] > 255) {
        colorArr[i] = 255;
      } else if (color[i] < 0) {
        colorArr[i] = 0;
      }
    }

    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
  }
}
/**
 * @param {string} color
 * @return {string}
 * @memberOf module:zrender/util/color
 */


function toHex(color) {
  var colorArr = parse(color);

  if (colorArr) {
    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
  }
}
/**
 * Map value to color. Faster than lerp methods because color is represented by rgba array.
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<Array.<number>>} colors List of rgba color array
 * @param {Array.<number>} [out] Mapped gba color array
 * @return {Array.<number>} will be null/undefined if input illegal.
 */


function fastLerp(normalizedValue, colors, out) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }

  out = out || [];
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colors[leftIndex];
  var rightColor = colors[rightIndex];
  var dv = value - leftIndex;
  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out;
}
/**
 * @deprecated
 */


var fastMapToColor = fastLerp;
/**
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<string>} colors Color list.
 * @param {boolean=} fullOutput Default false.
 * @return {(string|Object)} Result color. If fullOutput,
 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
 * @memberOf module:zrender/util/color
 */

function lerp(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }

  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = parse(colors[leftIndex]);
  var rightColor = parse(colors[rightIndex]);
  var dv = value - leftIndex;
  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
  return fullOutput ? {
    color: color,
    leftIndex: leftIndex,
    rightIndex: rightIndex,
    value: value
  } : color;
}
/**
 * @deprecated
 */


var mapToColor = lerp;
/**
 * @param {string} color
 * @param {number=} h 0 ~ 360, ignore when null.
 * @param {number=} s 0 ~ 1, ignore when null.
 * @param {number=} l 0 ~ 1, ignore when null.
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */

function modifyHSL(color, h, s, l) {
  color = parse(color);

  if (color) {
    color = rgba2hsla(color);
    h != null && (color[0] = clampCssAngle(h));
    s != null && (color[1] = parseCssFloat(s));
    l != null && (color[2] = parseCssFloat(l));
    return stringify(hsla2rgba(color), 'rgba');
  }
}
/**
 * @param {string} color
 * @param {number=} alpha 0 ~ 1
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */


function modifyAlpha(color, alpha) {
  color = parse(color);

  if (color && alpha != null) {
    color[3] = clampCssFloat(alpha);
    return stringify(color, 'rgba');
  }
}
/**
 * @param {Array.<number>} arrColor like [12,33,44,0.4]
 * @param {string} type 'rgba', 'hsva', ...
 * @return {string} Result color. (If input illegal, return undefined).
 */


function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }

  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];

  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
    colorStr += ',' + arrColor[3];
  }

  return type + '(' + colorStr + ')';
}

exports.parse = parse;
exports.lift = lift;
exports.toHex = toHex;
exports.fastLerp = fastLerp;
exports.fastMapToColor = fastMapToColor;
exports.lerp = lerp;
exports.mapToColor = mapToColor;
exports.modifyHSL = modifyHSL;
exports.modifyAlpha = modifyAlpha;
exports.stringify = stringify;

/***/ }),

/***/ "./node_modules/zrender/lib/tool/path.js":
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__("./node_modules/zrender/lib/graphic/Path.js");

var PathProxy = __webpack_require__("./node_modules/zrender/lib/core/PathProxy.js");

var transformPath = __webpack_require__("./node_modules/zrender/lib/tool/transformPath.js");

// command chars
var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
var mathSqrt = Math.sqrt;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI = Math.PI;

var vMag = function (v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
};

var vRatio = function (u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
};

var vAngle = function (u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
};

function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
  var psi = psiDeg * (PI / 180.0);
  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

  if (lambda > 1) {
    rx *= mathSqrt(lambda);
    ry *= mathSqrt(lambda);
  }

  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  var cxp = f * rx * yp / ry;
  var cyp = f * -ry * xp / rx;
  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;
  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var dTheta = vAngle(u, v);

  if (vRatio(u, v) <= -1) {
    dTheta = PI;
  }

  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }

  if (fs === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * PI;
  }

  if (fs === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * PI;
  }

  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}

function createPathProxyFromString(data) {
  if (!data) {
    return [];
  } // command string


  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');
  var n; // create pipes so that we can split the data

  for (n = 0; n < cc.length; n++) {
    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
  } // create array


  var arr = cs.split('|'); // init context point

  var cpx = 0;
  var cpy = 0;
  var path = new PathProxy();
  var CMD = PathProxy.CMD;
  var prevCmd;

  for (n = 1; n < arr.length; n++) {
    var str = arr[n];
    var c = str.charAt(0);
    var off = 0;
    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
    var cmd;

    if (p.length > 0 && p[0] === '') {
      p.shift();
    }

    for (var i = 0; i < p.length; i++) {
      p[i] = parseFloat(p[i]);
    }

    while (off < p.length && !isNaN(p[off])) {
      if (isNaN(p[0])) {
        break;
      }

      var ctlPtx;
      var ctlPty;
      var rx;
      var ry;
      var psi;
      var fa;
      var fs;
      var x1 = cpx;
      var y1 = cpy; // convert l, H, h, V, and v to L

      switch (c) {
        case 'l':
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'L':
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'm':
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.M;
          path.addData(cmd, cpx, cpy);
          c = 'l';
          break;

        case 'M':
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.M;
          path.addData(cmd, cpx, cpy);
          c = 'L';
          break;

        case 'h':
          cpx += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'H':
          cpx = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'v':
          cpy += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'V':
          cpy = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'C':
          cmd = CMD.C;
          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
          cpx = p[off - 2];
          cpy = p[off - 1];
          break;

        case 'c':
          cmd = CMD.C;
          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
          cpx += p[off - 2];
          cpy += p[off - 1];
          break;

        case 'S':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.C) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cmd = CMD.C;
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;

        case 's':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.C) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cmd = CMD.C;
          x1 = cpx + p[off++];
          y1 = cpy + p[off++];
          cpx += p[off++];
          cpy += p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;

        case 'Q':
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;

        case 'q':
          x1 = p[off++] + cpx;
          y1 = p[off++] + cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;

        case 'T':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.Q) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;

        case 't':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.Q) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;

        case 'A':
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;

        case 'a':
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
      }
    }

    if (c === 'z' || c === 'Z') {
      cmd = CMD.Z;
      path.addData(cmd);
    }

    prevCmd = cmd;
  }

  path.toStatic();
  return path;
} // TODO Optimize double memory cost problem


function createPathOptions(str, opts) {
  var pathProxy = createPathProxyFromString(str);
  opts = opts || {};

  opts.buildPath = function (path) {
    if (path.setData) {
      path.setData(pathProxy.data); // Svg and vml renderer don't have context

      var ctx = path.getContext();

      if (ctx) {
        path.rebuildPath(ctx);
      }
    } else {
      var ctx = path;
      pathProxy.rebuildPath(ctx);
    }
  };

  opts.applyTransform = function (m) {
    transformPath(pathProxy, m);
    this.dirty(true);
  };

  return opts;
}
/**
 * Create a Path object from path string data
 * http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {Object} opts Other options
 */


function createFromString(str, opts) {
  return new Path(createPathOptions(str, opts));
}
/**
 * Create a Path class from path string data
 * @param  {string} str
 * @param  {Object} opts Other options
 */


function extendFromString(str, opts) {
  return Path.extend(createPathOptions(str, opts));
}
/**
 * Merge multiple paths
 */
// TODO Apply transform
// TODO stroke dash
// TODO Optimize double memory cost problem


function mergePath(pathEls, opts) {
  var pathList = [];
  var len = pathEls.length;

  for (var i = 0; i < len; i++) {
    var pathEl = pathEls[i];

    if (!pathEl.path) {
      pathEl.createPathProxy();
    }

    if (pathEl.__dirtyPath) {
      pathEl.buildPath(pathEl.path, pathEl.shape, true);
    }

    pathList.push(pathEl.path);
  }

  var pathBundle = new Path(opts); // Need path proxy.

  pathBundle.createPathProxy();

  pathBundle.buildPath = function (path) {
    path.appendPath(pathList); // Svg and vml renderer don't have context

    var ctx = path.getContext();

    if (ctx) {
      path.rebuildPath(ctx);
    }
  };

  return pathBundle;
}

exports.createFromString = createFromString;
exports.extendFromString = extendFromString;
exports.mergePath = mergePath;

/***/ }),

/***/ "./node_modules/zrender/lib/tool/transformPath.js":
/***/ (function(module, exports, __webpack_require__) {

var PathProxy = __webpack_require__("./node_modules/zrender/lib/core/PathProxy.js");

var _vector = __webpack_require__("./node_modules/zrender/lib/core/vector.js");

var v2ApplyTransform = _vector.applyTransform;
var CMD = PathProxy.CMD;
var points = [[], [], []];
var mathSqrt = Math.sqrt;
var mathAtan2 = Math.atan2;

function _default(path, m) {
  var data = path.data;
  var cmd;
  var nPoint;
  var i;
  var j;
  var k;
  var p;
  var M = CMD.M;
  var C = CMD.C;
  var L = CMD.L;
  var R = CMD.R;
  var A = CMD.A;
  var Q = CMD.Q;

  for (i = 0, j = 0; i < data.length;) {
    cmd = data[i++];
    j = i;
    nPoint = 0;

    switch (cmd) {
      case M:
        nPoint = 1;
        break;

      case L:
        nPoint = 1;
        break;

      case C:
        nPoint = 3;
        break;

      case Q:
        nPoint = 2;
        break;

      case A:
        var x = m[4];
        var y = m[5];
        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx

        data[i] *= sx;
        data[i++] += x; // cy

        data[i] *= sy;
        data[i++] += y; // Scale rx and ry
        // FIXME Assume psi is 0 here

        data[i++] *= sx;
        data[i++] *= sy; // Start angle

        data[i++] += angle; // end angle

        data[i++] += angle; // FIXME psi

        i += 2;
        j = i;
        break;

      case R:
        // x0, y0
        p[0] = data[i++];
        p[1] = data[i++];
        v2ApplyTransform(p, p, m);
        data[j++] = p[0];
        data[j++] = p[1]; // x1, y1

        p[0] += data[i++];
        p[1] += data[i++];
        v2ApplyTransform(p, p, m);
        data[j++] = p[0];
        data[j++] = p[1];
    }

    for (k = 0; k < nPoint; k++) {
      var p = points[k];
      p[0] = data[i++];
      p[1] = data[i++];
      v2ApplyTransform(p, p, m); // Write back

      data[j++] = p[0];
      data[j++] = p[1];
    }
  }
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/zrender/lib/zrender.js":
/***/ (function(module, exports, __webpack_require__) {

var guid = __webpack_require__("./node_modules/zrender/lib/core/guid.js");

var env = __webpack_require__("./node_modules/zrender/lib/core/env.js");

var zrUtil = __webpack_require__("./node_modules/zrender/lib/core/util.js");

var Handler = __webpack_require__("./node_modules/zrender/lib/Handler.js");

var Storage = __webpack_require__("./node_modules/zrender/lib/Storage.js");

var Painter = __webpack_require__("./node_modules/zrender/lib/Painter.js");

var Animation = __webpack_require__("./node_modules/zrender/lib/animation/Animation.js");

var HandlerProxy = __webpack_require__("./node_modules/zrender/lib/dom/HandlerProxy.js");

/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var useVML = !env.canvasSupported;
var painterCtors = {
  canvas: Painter
};
var instances = {}; // ZRender实例map索引

/**
 * @type {string}
 */

var version = '4.0.4';
/**
 * Initializing a zrender instance
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
 * @return {module:zrender/ZRender}
 */

function init(dom, opts) {
  var zr = new ZRender(guid(), dom, opts);
  instances[zr.id] = zr;
  return zr;
}
/**
 * Dispose zrender instance
 * @param {module:zrender/ZRender} zr
 */


function dispose(zr) {
  if (zr) {
    zr.dispose();
  } else {
    for (var key in instances) {
      if (instances.hasOwnProperty(key)) {
        instances[key].dispose();
      }
    }

    instances = {};
  }

  return this;
}
/**
 * Get zrender instance by id
 * @param {string} id zrender instance id
 * @return {module:zrender/ZRender}
 */


function getInstance(id) {
  return instances[id];
}

function registerPainter(name, Ctor) {
  painterCtors[name] = Ctor;
}

function delInstance(id) {
  delete instances[id];
}
/**
 * @module zrender/ZRender
 */

/**
 * @constructor
 * @alias module:zrender/ZRender
 * @param {string} id
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 */


var ZRender = function (id, dom, opts) {
  opts = opts || {};
  /**
   * @type {HTMLDomElement}
   */

  this.dom = dom;
  /**
   * @type {string}
   */

  this.id = id;
  var self = this;
  var storage = new Storage();
  var rendererType = opts.renderer; // TODO WebGL

  if (useVML) {
    if (!painterCtors.vml) {
      throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
    }

    rendererType = 'vml';
  } else if (!rendererType || !painterCtors[rendererType]) {
    rendererType = 'canvas';
  }

  var painter = new painterCtors[rendererType](dom, storage, opts, id);
  this.storage = storage;
  this.painter = painter;
  var handerProxy = !env.node && !env.worker ? new HandlerProxy(painter.getViewportRoot()) : null;
  this.handler = new Handler(storage, painter, handerProxy, painter.root);
  /**
   * @type {module:zrender/animation/Animation}
   */

  this.animation = new Animation({
    stage: {
      update: zrUtil.bind(this.flush, this)
    }
  });
  this.animation.start();
  /**
   * @type {boolean}
   * @private
   */

  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
  // FIXME 有点ugly

  var oldDelFromStorage = storage.delFromStorage;
  var oldAddToStorage = storage.addToStorage;

  storage.delFromStorage = function (el) {
    oldDelFromStorage.call(storage, el);
    el && el.removeSelfFromZr(self);
  };

  storage.addToStorage = function (el) {
    oldAddToStorage.call(storage, el);
    el.addSelfToZr(self);
  };
};

ZRender.prototype = {
  constructor: ZRender,

  /**
   * 获取实例唯一标识
   * @return {string}
   */
  getId: function () {
    return this.id;
  },

  /**
   * 添加元素
   * @param  {module:zrender/Element} el
   */
  add: function (el) {
    this.storage.addRoot(el);
    this._needsRefresh = true;
  },

  /**
   * 删除元素
   * @param  {module:zrender/Element} el
   */
  remove: function (el) {
    this.storage.delRoot(el);
    this._needsRefresh = true;
  },

  /**
   * Change configuration of layer
   * @param {string} zLevel
   * @param {Object} config
   * @param {string} [config.clearColor=0] Clear color
   * @param {string} [config.motionBlur=false] If enable motion blur
   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
  */
  configLayer: function (zLevel, config) {
    if (this.painter.configLayer) {
      this.painter.configLayer(zLevel, config);
    }

    this._needsRefresh = true;
  },

  /**
   * Set background color
   * @param {string} backgroundColor
   */
  setBackgroundColor: function (backgroundColor) {
    if (this.painter.setBackgroundColor) {
      this.painter.setBackgroundColor(backgroundColor);
    }

    this._needsRefresh = true;
  },

  /**
   * Repaint the canvas immediately
   */
  refreshImmediately: function () {
    // var start = new Date();
    // Clear needsRefresh ahead to avoid something wrong happens in refresh
    // Or it will cause zrender refreshes again and again.
    this._needsRefresh = false;
    this.painter.refresh();
    /**
     * Avoid trigger zr.refresh in Element#beforeUpdate hook
     */

    this._needsRefresh = false; // var end = new Date();
    // var log = document.getElementById('log');
    // if (log) {
    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
    // }
  },

  /**
   * Mark and repaint the canvas in the next frame of browser
   */
  refresh: function () {
    this._needsRefresh = true;
  },

  /**
   * Perform all refresh
   */
  flush: function () {
    var triggerRendered;

    if (this._needsRefresh) {
      triggerRendered = true;
      this.refreshImmediately();
    }

    if (this._needsRefreshHover) {
      triggerRendered = true;
      this.refreshHoverImmediately();
    }

    triggerRendered && this.trigger('rendered');
  },

  /**
   * Add element to hover layer
   * @param  {module:zrender/Element} el
   * @param {Object} style
   */
  addHover: function (el, style) {
    if (this.painter.addHover) {
      this.painter.addHover(el, style);
      this.refreshHover();
    }
  },

  /**
   * Add element from hover layer
   * @param  {module:zrender/Element} el
   */
  removeHover: function (el) {
    if (this.painter.removeHover) {
      this.painter.removeHover(el);
      this.refreshHover();
    }
  },

  /**
   * Clear all hover elements in hover layer
   * @param  {module:zrender/Element} el
   */
  clearHover: function () {
    if (this.painter.clearHover) {
      this.painter.clearHover();
      this.refreshHover();
    }
  },

  /**
   * Refresh hover in next frame
   */
  refreshHover: function () {
    this._needsRefreshHover = true;
  },

  /**
   * Refresh hover immediately
   */
  refreshHoverImmediately: function () {
    this._needsRefreshHover = false;
    this.painter.refreshHover && this.painter.refreshHover();
  },

  /**
   * Resize the canvas.
   * Should be invoked when container size is changed
   * @param {Object} [opts]
   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
   */
  resize: function (opts) {
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  },

  /**
   * Stop and clear all animation immediately
   */
  clearAnimation: function () {
    this.animation.clear();
  },

  /**
   * Get container width
   */
  getWidth: function () {
    return this.painter.getWidth();
  },

  /**
   * Get container height
   */
  getHeight: function () {
    return this.painter.getHeight();
  },

  /**
   * Export the canvas as Base64 URL
   * @param {string} type
   * @param {string} [backgroundColor='#fff']
   * @return {string} Base64 URL
   */
  // toDataURL: function(type, backgroundColor) {
  //     return this.painter.getRenderedCanvas({
  //         backgroundColor: backgroundColor
  //     }).toDataURL(type);
  // },

  /**
   * Converting a path to image.
   * It has much better performance of drawing image rather than drawing a vector path.
   * @param {module:zrender/graphic/Path} e
   * @param {number} width
   * @param {number} height
   */
  pathToImage: function (e, dpr) {
    return this.painter.pathToImage(e, dpr);
  },

  /**
   * Set default cursor
   * @param {string} [cursorStyle='default'] 例如 crosshair
   */
  setCursorStyle: function (cursorStyle) {
    this.handler.setCursorStyle(cursorStyle);
  },

  /**
   * Find hovered element
   * @param {number} x
   * @param {number} y
   * @return {Object} {target, topTarget}
   */
  findHover: function (x, y) {
    return this.handler.findHover(x, y);
  },

  /**
   * Bind event
   *
   * @param {string} eventName Event name
   * @param {Function} eventHandler Handler function
   * @param {Object} [context] Context object
   */
  on: function (eventName, eventHandler, context) {
    this.handler.on(eventName, eventHandler, context);
  },

  /**
   * Unbind event
   * @param {string} eventName Event name
   * @param {Function} [eventHandler] Handler function
   */
  off: function (eventName, eventHandler) {
    this.handler.off(eventName, eventHandler);
  },

  /**
   * Trigger event manually
   *
   * @param {string} eventName Event name
   * @param {event=} event Event object
   */
  trigger: function (eventName, event) {
    this.handler.trigger(eventName, event);
  },

  /**
   * Clear all objects and the canvas.
   */
  clear: function () {
    this.storage.delRoot();
    this.painter.clear();
  },

  /**
   * Dispose self.
   */
  dispose: function () {
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    delInstance(this.id);
  }
};
exports.version = version;
exports.init = init;
exports.dispose = dispose;
exports.getInstance = getInstance;
exports.registerPainter = registerPainter;

/***/ }),

/***/ "./resources/assets/js/components/index/user_transfer.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./resources/assets/js/components/index/user_transfer.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-7111f11b\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./resources/assets/js/components/index/user_transfer.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/components/index/user_transfer.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7111f11b", Component.options)
  } else {
    hotAPI.reload("data-v-7111f11b", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL2luZGV4L3VzZXJfdHJhbnNmZXIudnVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9Db29yZGluYXRlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9FeHRlbnNpb25BUEkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclNlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXNlQmFyU2VyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvYmFySXRlbVN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvaGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xpbmVEcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2NyZWF0ZVJlbmRlclBsYW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9sYWJlbEhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lU2VyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL0xpbmVWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL2hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9saW5lQW5pbWF0aW9uRGlmZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9wb2x5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc0J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0F4aXNWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9DYXJ0ZXNpYW5BeGlzVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0Jhc2VBeGlzUG9pbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0NhcnRlc2lhbkF4aXNQb2ludGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvYXhpc1RyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9maW5kUG9pbnRGcm9tU2VyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9tb2RlbEhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL3ZpZXdIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0F4aXNQcm94eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9JbnNpZGVab29tTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9JbnNpZGVab29tVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NlbGVjdFpvb21Nb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NlbGVjdFpvb21WaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2xpZGVyWm9vbU1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2xpZGVyWm9vbVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbUFjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2RhdGFab29tUHJvY2Vzc29yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL3JvYW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vdHlwZURlZmF1bHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tU2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YXNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyaWRTaW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL0JydXNoVGFyZ2V0TWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9icnVzaEhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9jdXJzb3JIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvaW50ZXJhY3Rpb25NdXRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9saXN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL3NsaWRlck1vdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9zY3JvbGxhYmxlTGVnZW5kQWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kU2Nyb2xsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya0xpbmVNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrTGluZVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50TW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50Vmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL21hcmtlckhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpdGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveE1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9Ub29sYm94Vmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9NYWdpY1R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvUmVzdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9TYXZlQXNJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9BeGlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc0hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNUaWNrTGFiZWxCdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQXhpczJELmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuMkQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vY2FydGVzaWFuQXhpc0hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL1JlZ2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL3BhcnNlR2VvSnNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9EYXRhRGlmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL0xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvT3JkaW5hbE1ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvU291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL2NyZWF0ZURpbWVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL2RhdGFQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvZGF0YVN0YWNrSGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9kaW1lbnNpb25IZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL3NvdXJjZUhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvc291cmNlVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZWNoYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xhbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xheW91dC9iYXJHcmlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYXlvdXQvcG9pbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sb2FkaW5nL2RlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvR2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9Nb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvT3B0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvU2VyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9nbG9iYWxEZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9hcmVhU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2JveExheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vY29sb3JQYWxldHRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9kYXRhRm9ybWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9pdGVtU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2xpbmVTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi90ZXh0U3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL3JlZmVySGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9oZWxwZXIvY29tcGF0U3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcm9jZXNzb3IvZGF0YVN0YWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9JbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvTG9nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9PcmRpbmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9TY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvaGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zdHJlYW0vU2NoZWR1bGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zdHJlYW0vdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdGhlbWUvZGFyay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdGhlbWUvbGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvY2xhenouanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9ncmFwaGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2xheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvc3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3Rocm90dGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aWV3L0NoYXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aWV3L0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlzdWFsL2FyaWEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Zpc3VhbC9zZXJpZXNDb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlzdWFsL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvaW5kZXgvdXNlcl90cmFuc2Zlci52dWU/NTg5OSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL1BhaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL1N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9hcmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0xSVS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvYmJveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9jdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvQ29tcG91bmRQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0luY3JlbWVudGFsRGlzcGxheWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhTaGFkb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ltYWdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci90ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi96cmVuZGVyLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9pbmRleC91c2VyX3RyYW5zZmVyLnZ1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FEQSxrQkFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBLEVBTEE7O0FBTUE7QUFDQSxRQURBLG9C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O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7QUFDTDtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRzs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJJQUEySTs7QUFFM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FB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QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFOztBQUVYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTCw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUZBQXVGO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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O0FBRUg7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlB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QUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPLEVBQUU7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTyxPQUFPO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU8sRUFBRTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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Q0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtB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NEI7QUFDdkMsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyxPQUFPO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCOzs7Ozs7O0FDdExBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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Q0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlB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QUVBO0FBQ0EsMEI7Ozs7Ozs7QUMxUkEsVUFBVSxtQkFBTyxDQUFDLHdDQUFhOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdILDJCQUEyQjs7QUFFM0IscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxl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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFVLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cblx0PGRpdiBjbGFzcz1cInVzZXJfdHJhbnNmZXJcIj5cblx0XHQ8ZGl2IGlkPVwidXNlcl90cmFuc2ZlclwiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAwcHhcIj48L2Rpdj5cblx0PC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cblx0bGV0IGVjaGFydHMgPSByZXF1aXJlKCdlY2hhcnRzL2xpYi9lY2hhcnRzJyk7XG5cdC8vIOW8leWFpeafseeKtuWbvlxuXHRyZXF1aXJlKCdlY2hhcnRzL2xpYi9jaGFydC9iYXInKTtcblx0cmVxdWlyZSgnZWNoYXJ0cy9saWIvY2hhcnQvbGluZScpO1xuXHQvLyDlvJXlhaXmj5DnpLrmoYblkozmoIfpopjnu4Tku7Zcblx0cmVxdWlyZSgnZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAnKTtcblx0cmVxdWlyZSgnZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpdGxlJyk7XG5cdHJlcXVpcmUoXCJlY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kU2Nyb2xsXCIpO1xuXHRyZXF1aXJlKFwiZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tXCIpO1xuXHRyZXF1aXJlKFwiZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtQb2ludFwiKTtcblx0cmVxdWlyZShcImVjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrTGluZVwiKTtcblx0cmVxdWlyZShcImVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94XCIpO1xuXHRcblx0ZXhwb3J0IGRlZmF1bHQge1xuXHRcdGRhdGEoKXtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNoYXJ0IDogJycsXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0bWV0aG9kcyA6IHtcblx0XHRcdHJlc2l6ZSgpe1xuXHRcdFx0XHR0aGlzLmNoYXJ0LnJlc2l6ZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bW91bnRlZCgpe1xuXHRcdFx0bGV0IHQgPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHR0LmNoYXJ0ID0gZWNoYXJ0cy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1c2VyX3RyYW5zZmVyJykpO1xuXHRcdFx0bGV0IG9yZGVyX29wdGlvbnMgPSB7XG5cdFx0XHRcdHRpdGxlIDoge1xuXHRcdFx0XHRcdGxlZnQ6ICdjZW50ZXInLFxuXHRcdFx0XHRcdHRleHQ6ICcnLFxuXHRcdFx0XHRcdHN1YnRleHQ6ICfljIXmi6zmiYDmnInpkrHljIXvvIzmjInml6XliJLliIbvvIzph5Hpop3ljZXkvY3vvJrliIYnXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRvb2x0aXAgOiB7XG5cdFx0XHRcdFx0dHJpZ2dlcjogJ2F4aXMnXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxlZ2VuZDoge1xuXHRcdFx0XHRcdC8vIHR5cGU6ICdzY3JvbGwnLFxuXHRcdFx0XHRcdHRvcCA6ICc2MHB4Jyxcblx0XHRcdFx0XHQvLyBvcmllbnQ6ICd2ZXJ0aWNhbCcsXG5cdFx0XHRcdFx0Ly8gcmlnaHQ6JzAnLFxuXHRcdFx0XHRcdC8vIGJvdHRvbTonMTBweCcsXG5cdFx0XHRcdFx0ZGF0YTogW11cblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gY29sb3IgOiBbJyM3MDc5REYnLCcjRDE1QjdGJywnI0ZCNkU2QycsJyNGRjlGNjknLCcjRkVCNjREJywnI0ZGREE0MycsJyNGRkU4OEUnXSxcblx0XHRcdFx0dG9vbGJveDoge1xuXHRcdFx0XHRcdHNob3cgOiB0cnVlLFxuXHRcdFx0XHRcdGZlYXR1cmUgOiB7XG5cdFx0XHRcdFx0XHRtYWdpY1R5cGUgOiB7c2hvdzogdHJ1ZSwgdHlwZTogWydsaW5lJywgJ2JhciddfSxcblx0XHRcdFx0XHRcdHNhdmVBc0ltYWdlIDoge3Nob3c6IHRydWV9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRncmlkIDoge1xuXHRcdFx0XHRcdHRvcCA6ICcxNTBweCcsXG5cdFx0XHRcdFx0Ly8gcmlnaHQgOiAnMjAwcHgnLFxuXHRcdFx0XHRcdGNvbnRhaW5MYWJlbDogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjYWxjdWxhYmxlIDogdHJ1ZSxcblx0XHRcdFx0ZGF0YVpvb206IFtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzaG93OiB0cnVlLFxuXHRcdFx0XHRcdFx0dHlwZTogJ2luc2lkZScsXG5cdFx0XHRcdFx0XHRyZWFsdGltZTogdHJ1ZSxcblx0XHRcdFx0XHRcdHN0YXJ0OiA4MCxcblx0XHRcdFx0XHRcdGVuZDogMTAwLFxuXHRcdFx0XHRcdFx0em9vbU9uTW91c2VXaGVlbCA6IGZhbHNlLFxuXHRcdFx0XHRcdH0se31cblx0XHRcdFx0XSxcblx0XHRcdFx0eEF4aXMgOiBbXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dHlwZSA6ICdjYXRlZ29yeScsXG5cdFx0XHRcdFx0XHRuYW1lR2FwIDogJzYwJyxcblx0XHRcdFx0XHRcdGRhdGEgOiBbXVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XSxcblx0XHRcdFx0eUF4aXMgOiBbXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dHlwZSA6ICd2YWx1ZSdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdF0sXG5cdFx0XHRcdHNlcmllcyA6IFtdXG5cdFx0XHR9O1xuXHRcdFx0dC4kQVBJLmdldCgnL2luZGV4L3VzZXJfdHJhbnNmZXInKS50aGVuKGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRsZXQgZGF0ZXMgPSBkYXRhLmRhdGVzO1xuXHRcdFx0XHRsZXQgcHVyc2VfdHlwZXMgPSBkYXRhLnB1cnNlX3R5cGVzO1xuXHRcdFx0XHRsZXQgb3V0ID0gZGF0YS5vdXQ7XG5cdFx0XHRcdGxldCBpbnRvID0gZGF0YS5pbnRvO1xuXHRcdFx0XHRsZXQgYW1vdW50cyA9IGRhdGEuYW1vdW50cztcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFgg6L205pWw5o2u5bGV56S6XG5cdFx0XHRcdG9yZGVyX29wdGlvbnMueEF4aXNbMF0uZGF0YSA9IGRhdGVzO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8g5Z+65pys5L+h5oGv5Y+Y6YePXG5cdFx0XHRcdGxldCBzZXJpZXNfdGVtcGxhdGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRuYW1lOicnLFxuXHRcdFx0XHRcdFx0dHlwZTonYmFyJyxcblx0XHRcdFx0XHRcdHN0YWNrOicnLFx0Ly8g5q2j6LSf6L2055u45ZCM55qE5YC85Lya5LiK5LiL6aG25Zyo5LiA6LW3XG5cdFx0XHRcdFx0XHRkYXRhOltdLFxuXHRcdFx0XHRcdFx0Ly8gbWFya1BvaW50IDoge1xuXHRcdFx0XHRcdFx0Ly8gXHRzeW1ib2wgOiAncGluJyxcblx0XHRcdFx0XHRcdC8vIFx0ZGF0YSA6IFtcblx0XHRcdFx0XHRcdC8vIFx0XHR7dHlwZSA6ICdtYXgnLCBuYW1lOiAn5pyA5aSn5YC8J30sXG5cdFx0XHRcdFx0XHQvLyBcdFx0e3R5cGUgOiAnbWluJywgbmFtZTogJ+acgOWwj+WAvCd9XG5cdFx0XHRcdFx0XHQvLyBcdF1cblx0XHRcdFx0XHRcdC8vIH0sXG5cdFx0XHRcdFx0XHRtYXJrTGluZSA6IHtcblx0XHRcdFx0XHRcdFx0ZGF0YSA6IFtcblx0XHRcdFx0XHRcdFx0XHR7dHlwZSA6ICdhdmVyYWdlJywgbmFtZTogJ+W5s+Wdh+WAvCd9XG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRsYWJlbDoge1xuXHRcdFx0XHRcdFx0XHRzaG93OiB0cnVlLFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0Zm9yKGxldCB0eXBlIGluIGFtb3VudHMpe1xuXHRcdFx0XHRcdGxldCBzZXJpZXMgPSBzZXJpZXNfdGVtcGxhdGUoKTtcblx0XHRcdFx0XHRzZXJpZXMubmFtZSA9IHB1cnNlX3R5cGVzW3R5cGVdO1xuXHRcdFx0XHRcdG9yZGVyX29wdGlvbnMubGVnZW5kLmRhdGEucHVzaChzZXJpZXMubmFtZSk7XG5cdFx0XHRcdFx0c2VyaWVzLnN0YWNrID0gdHlwZS5zdWJzdHIoMCwxKSA9PSAnLScgPyB0eXBlLnN1YnN0cigxKSA6IHR5cGU7XG5cdFx0XHRcdFx0Zm9yKGxldCBkYXRlIGluIGFtb3VudHNbdHlwZV0pe1xuXHRcdFx0XHRcdFx0bGV0IGRhdGVfdmFsID0gYW1vdW50c1t0eXBlXVtkYXRlXTtcblx0XHRcdFx0XHRcdHNlcmllcy5kYXRhLnB1c2goe1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA6IGRhdGVfdmFsLFxuXHRcdFx0XHRcdFx0XHQvLyDlnKjmn7HnirbmnaHkuIrmmL7npLrmlbDlgLxcblx0XHRcdFx0XHRcdFx0bGFiZWwgOiB7XG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzaG93OiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0cm90YXRlOiA5MCxcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdC8vIGlmKGRhdGVfdmFsIDwgMCl7XG5cdFx0XHRcdFx0XHQvLyBcdHNlcmllcy5tYXJrUG9pbnQuc3ltYm9sUm90YXRlID0gMTgwO1xuXHRcdFx0XHRcdFx0Ly8gfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvcmRlcl9vcHRpb25zLnNlcmllcy5wdXNoKHNlcmllcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3JkZXJfb3B0aW9ucy50aXRsZS50ZXh0ID0gJ+i/keacnyAnK2RhdGEuZGF5cysnIOWkqeavj+aXpeeUqOaIt+i6q+S7veaUtuWFpeOAgeaUr+WHuumHkeminee7n+iuoSc7XG5cdFx0XHRcdHQuY2hhcnQuc2V0T3B0aW9uKG9yZGVyX29wdGlvbnMpO1xuXHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24obXNnKXtcblx0XHRcdFx0XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0d2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHQuY2hhcnQucmVzaXplKCk7XG5cdFx0XHRcdH0sMjAwKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG48L3NjcmlwdD5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL2luZGV4L3VzZXJfdHJhbnNmZXIudnVlIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnMgPSB7fTtcblxuZnVuY3Rpb24gQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIoKSB7XG4gIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zID0gW107XG59XG5cbkNvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLFxuICBjcmVhdGU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbXMgPSBbXTtcbiAgICB6clV0aWwuZWFjaChjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnMsIGZ1bmN0aW9uIChjcmVhdGVyLCB0eXBlKSB7XG4gICAgICB2YXIgbGlzdCA9IGNyZWF0ZXIuY3JlYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgICBjb29yZGluYXRlU3lzdGVtcyA9IGNvb3JkaW5hdGVTeXN0ZW1zLmNvbmNhdChsaXN0IHx8IFtdKTtcbiAgICB9KTtcbiAgICB0aGlzLl9jb29yZGluYXRlU3lzdGVtcyA9IGNvb3JkaW5hdGVTeXN0ZW1zO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB6clV0aWwuZWFjaCh0aGlzLl9jb29yZGluYXRlU3lzdGVtcywgZnVuY3Rpb24gKGNvb3JkU3lzKSB7XG4gICAgICBjb29yZFN5cy51cGRhdGUgJiYgY29vcmRTeXMudXBkYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgfSk7XG4gIH0sXG4gIGdldENvb3JkaW5hdGVTeXN0ZW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zLnNsaWNlKCk7XG4gIH1cbn07XG5cbkNvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHR5cGUsIGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9yKSB7XG4gIGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9yc1t0eXBlXSA9IGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9yO1xufTtcblxuQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIuZ2V0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgcmV0dXJuIGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9yc1t0eXBlXTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9Db29yZGluYXRlU3lzdGVtLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9Db29yZGluYXRlU3lzdGVtLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBlY2hhcnRzQVBJTGlzdCA9IFsnZ2V0RG9tJywgJ2dldFpyJywgJ2dldFdpZHRoJywgJ2dldEhlaWdodCcsICdnZXREZXZpY2VQaXhlbFJhdGlvJywgJ2Rpc3BhdGNoQWN0aW9uJywgJ2lzRGlzcG9zZWQnLCAnb24nLCAnb2ZmJywgJ2dldERhdGFVUkwnLCAnZ2V0Q29ubmVjdGVkRGF0YVVSTCcsICdnZXRNb2RlbCcsICdnZXRPcHRpb24nLCAnZ2V0Vmlld09mQ29tcG9uZW50TW9kZWwnLCAnZ2V0Vmlld09mU2VyaWVzTW9kZWwnXTsgLy8gQW5kIGBnZXRDb29yZGluYXRlU3lzdGVtc2AgYW5kIGBnZXRDb21wb25lbnRCeUVsZW1lbnRgIHdpbGwgYmUgaW5qZWN0ZWQgaW4gZWNoYXJ0cy5qc1xuXG5mdW5jdGlvbiBFeHRlbnNpb25BUEkoY2hhcnRJbnN0YW5jZSkge1xuICB6clV0aWwuZWFjaChlY2hhcnRzQVBJTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aGlzW25hbWVdID0genJVdGlsLmJpbmQoY2hhcnRJbnN0YW5jZVtuYW1lXSwgY2hhcnRJbnN0YW5jZSk7XG4gIH0sIHRoaXMpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBFeHRlbnNpb25BUEk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL0V4dGVuc2lvbkFQSS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvRXh0ZW5zaW9uQVBJLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBfYmFyR3JpZCA9IHJlcXVpcmUoXCIuLi9sYXlvdXQvYmFyR3JpZFwiKTtcblxudmFyIGxheW91dCA9IF9iYXJHcmlkLmxheW91dDtcbnZhciBsYXJnZUxheW91dCA9IF9iYXJHcmlkLmxhcmdlTGF5b3V0O1xuXG5yZXF1aXJlKFwiLi4vY29vcmQvY2FydGVzaWFuL0dyaWRcIik7XG5cbnJlcXVpcmUoXCIuL2Jhci9CYXJTZXJpZXNcIik7XG5cbnJlcXVpcmUoXCIuL2Jhci9CYXJWaWV3XCIpO1xuXG5yZXF1aXJlKFwiLi4vY29tcG9uZW50L2dyaWRTaW1wbGVcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIEluIGNhc2UgZGV2ZWxvcGVyIGZvcmdldCB0byBpbmNsdWRlIGdyaWQgY29tcG9uZW50XG5lY2hhcnRzLnJlZ2lzdGVyTGF5b3V0KHpyVXRpbC5jdXJyeShsYXlvdXQsICdiYXInKSk7IC8vIFNob3VsZCBhZnRlciBub3JtYWwgYmFyIGxheW91dCwgb3RoZXJ3aXNlIGl0IGlzIGJsb2NrZWQgYnkgbm9ybWFsIGJhciBsYXlvdXQuXG5cbmVjaGFydHMucmVnaXN0ZXJMYXlvdXQobGFyZ2VMYXlvdXQpO1xuZWNoYXJ0cy5yZWdpc3RlclZpc3VhbCh7XG4gIHNlcmllc1R5cGU6ICdiYXInLFxuICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgLy8gVmlzdWFsIGNvZGluZyBmb3IgbGVnZW5kXG4gICAgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLnNldFZpc3VhbCgnbGVnZW5kU3ltYm9sJywgJ3JvdW5kUmVjdCcpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBCYXNlQmFyU2VyaWVzID0gcmVxdWlyZShcIi4vQmFzZUJhclNlcmllc1wiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9kZWZhdWx0ID0gQmFzZUJhclNlcmllcy5leHRlbmQoe1xuICB0eXBlOiAnc2VyaWVzLmJhcicsXG4gIGRlcGVuZGVuY2llczogWydncmlkJywgJ3BvbGFyJ10sXG4gIGJydXNoU2VsZWN0b3I6ICdyZWN0JyxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRQcm9ncmVzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIERvIG5vdCBzdXBwb3J0IHByb2dyZXNzaXZlIGluIG5vcm1hbCBtb2RlLlxuICAgIHJldHVybiB0aGlzLmdldCgnbGFyZ2UnKSA/IHRoaXMuZ2V0KCdwcm9ncmVzc2l2ZScpIDogZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0UHJvZ3Jlc3NpdmVUaHJlc2hvbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEbyBub3Qgc3VwcG9ydCBwcm9ncmVzc2l2ZSBpbiBub3JtYWwgbW9kZS5cbiAgICB2YXIgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPSB0aGlzLmdldCgncHJvZ3Jlc3NpdmVUaHJlc2hvbGQnKTtcbiAgICB2YXIgbGFyZ2VUaHJlc2hvbGQgPSB0aGlzLmdldCgnbGFyZ2VUaHJlc2hvbGQnKTtcblxuICAgIGlmIChsYXJnZVRocmVzaG9sZCA+IHByb2dyZXNzaXZlVGhyZXNob2xkKSB7XG4gICAgICBwcm9ncmVzc2l2ZVRocmVzaG9sZCA9IGxhcmdlVGhyZXNob2xkO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmVzc2l2ZVRocmVzaG9sZDtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclNlcmllcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBfaGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuXG52YXIgc2V0TGFiZWwgPSBfaGVscGVyLnNldExhYmVsO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTW9kZWxcIik7XG5cbnZhciBiYXJJdGVtU3R5bGUgPSByZXF1aXJlKFwiLi9iYXJJdGVtU3R5bGVcIik7XG5cbnZhciBQYXRoID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvUGF0aFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIEJBUl9CT1JERVJfV0lEVEhfUVVFUlkgPSBbJ2l0ZW1TdHlsZScsICdiYXJCb3JkZXJXaWR0aCddOyAvLyBGSVhNRVxuLy8gSnVzdCBmb3IgY29tcGF0aWJsZSB3aXRoIGVjMi5cblxuenJVdGlsLmV4dGVuZChNb2RlbC5wcm90b3R5cGUsIGJhckl0ZW1TdHlsZSk7XG5cbnZhciBfZGVmYXVsdCA9IGVjaGFydHMuZXh0ZW5kQ2hhcnRWaWV3KHtcbiAgdHlwZTogJ2JhcicsXG4gIHJlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl91cGRhdGVEcmF3TW9kZShzZXJpZXNNb2RlbCk7XG5cbiAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbVR5cGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcblxuICAgIGlmIChjb29yZGluYXRlU3lzdGVtVHlwZSA9PT0gJ2NhcnRlc2lhbjJkJyB8fCBjb29yZGluYXRlU3lzdGVtVHlwZSA9PT0gJ3BvbGFyJykge1xuICAgICAgdGhpcy5faXNMYXJnZURyYXcgPyB0aGlzLl9yZW5kZXJMYXJnZShzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSA6IHRoaXMuX3JlbmRlck5vcm1hbChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICB9IGVsc2Uge31cblxuICAgIHJldHVybiB0aGlzLmdyb3VwO1xuICB9LFxuICBpbmNyZW1lbnRhbFByZXBhcmVSZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fY2xlYXIoKTtcblxuICAgIHRoaXMuX3VwZGF0ZURyYXdNb2RlKHNlcmllc01vZGVsKTtcbiAgfSxcbiAgaW5jcmVtZW50YWxSZW5kZXI6IGZ1bmN0aW9uIChwYXJhbXMsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAvLyBEbyBub3Qgc3VwcG9ydCBwcm9ncmVzc2l2ZSBpbiBub3JtYWwgbW9kZS5cbiAgICB0aGlzLl9pbmNyZW1lbnRhbFJlbmRlckxhcmdlKHBhcmFtcywgc2VyaWVzTW9kZWwpO1xuICB9LFxuICBfdXBkYXRlRHJhd01vZGU6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBpc0xhcmdlRHJhdyA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dC5sYXJnZTtcblxuICAgIGlmICh0aGlzLl9pc0xhcmdlRHJhdyA9PSBudWxsIHx8IGlzTGFyZ2VEcmF3IF4gdGhpcy5faXNMYXJnZURyYXcpIHtcbiAgICAgIHRoaXMuX2lzTGFyZ2VEcmF3ID0gaXNMYXJnZURyYXc7XG5cbiAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgfVxuICB9LFxuICBfcmVuZGVyTm9ybWFsOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBjb29yZCA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGJhc2VBeGlzID0gY29vcmQuZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgaXNIb3Jpem9udGFsT3JSYWRpYWw7XG5cbiAgICBpZiAoY29vcmQudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgaXNIb3Jpem9udGFsT3JSYWRpYWwgPSBiYXNlQXhpcy5pc0hvcml6b250YWwoKTtcbiAgICB9IGVsc2UgaWYgKGNvb3JkLnR5cGUgPT09ICdwb2xhcicpIHtcbiAgICAgIGlzSG9yaXpvbnRhbE9yUmFkaWFsID0gYmFzZUF4aXMuZGltID09PSAnYW5nbGUnO1xuICAgIH1cblxuICAgIHZhciBhbmltYXRpb25Nb2RlbCA9IHNlcmllc01vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpID8gc2VyaWVzTW9kZWwgOiBudWxsO1xuICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgaWYgKCFkYXRhLmhhc1ZhbHVlKGRhdGFJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgICAgIHZhciBsYXlvdXQgPSBnZXRMYXlvdXRbY29vcmQudHlwZV0oZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwpO1xuICAgICAgdmFyIGVsID0gZWxlbWVudENyZWF0b3JbY29vcmQudHlwZV0oZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGFuaW1hdGlvbk1vZGVsKTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIGVsKTtcbiAgICAgIGdyb3VwLmFkZChlbCk7XG4gICAgICB1cGRhdGVTdHlsZShlbCwgZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgc2VyaWVzTW9kZWwsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBjb29yZC50eXBlID09PSAncG9sYXInKTtcbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0luZGV4LCBvbGRJbmRleCkge1xuICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZEluZGV4KTtcblxuICAgICAgaWYgKCFkYXRhLmhhc1ZhbHVlKG5ld0luZGV4KSkge1xuICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChuZXdJbmRleCk7XG4gICAgICB2YXIgbGF5b3V0ID0gZ2V0TGF5b3V0W2Nvb3JkLnR5cGVdKGRhdGEsIG5ld0luZGV4LCBpdGVtTW9kZWwpO1xuXG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgICAgICAgIHNoYXBlOiBsYXlvdXRcbiAgICAgICAgfSwgYW5pbWF0aW9uTW9kZWwsIG5ld0luZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gZWxlbWVudENyZWF0b3JbY29vcmQudHlwZV0oZGF0YSwgbmV3SW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc0hvcml6b250YWxPclJhZGlhbCwgYW5pbWF0aW9uTW9kZWwsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SW5kZXgsIGVsKTsgLy8gQWRkIGJhY2tcblxuICAgICAgZ3JvdXAuYWRkKGVsKTtcbiAgICAgIHVwZGF0ZVN0eWxlKGVsLCBkYXRhLCBuZXdJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIHNlcmllc01vZGVsLCBpc0hvcml6b250YWxPclJhZGlhbCwgY29vcmQudHlwZSA9PT0gJ3BvbGFyJyk7XG4gICAgfSkucmVtb3ZlKGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgIHZhciBlbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuXG4gICAgICBpZiAoY29vcmQudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICBlbCAmJiByZW1vdmVSZWN0KGRhdGFJbmRleCwgYW5pbWF0aW9uTW9kZWwsIGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsICYmIHJlbW92ZVNlY3RvcihkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCk7XG4gICAgICB9XG4gICAgfSkuZXhlY3V0ZSgpO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9LFxuICBfcmVuZGVyTGFyZ2U6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fY2xlYXIoKTtcblxuICAgIGNyZWF0ZUxhcmdlKHNlcmllc01vZGVsLCB0aGlzLmdyb3VwKTtcbiAgfSxcbiAgX2luY3JlbWVudGFsUmVuZGVyTGFyZ2U6IGZ1bmN0aW9uIChwYXJhbXMsIHNlcmllc01vZGVsKSB7XG4gICAgY3JlYXRlTGFyZ2Uoc2VyaWVzTW9kZWwsIHRoaXMuZ3JvdXAsIHRydWUpO1xuICB9LFxuICBkaXNwb3NlOiB6clV0aWwubm9vcCxcbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHRoaXMuX2NsZWFyKGVjTW9kZWwpO1xuICB9LFxuICBfY2xlYXI6IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICBpZiAoZWNNb2RlbCAmJiBlY01vZGVsLmdldCgnYW5pbWF0aW9uJykgJiYgZGF0YSAmJiAhdGhpcy5faXNMYXJnZURyYXcpIHtcbiAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChlbC50eXBlID09PSAnc2VjdG9yJykge1xuICAgICAgICAgIHJlbW92ZVNlY3RvcihlbC5kYXRhSW5kZXgsIGVjTW9kZWwsIGVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVSZWN0KGVsLmRhdGFJbmRleCwgZWNNb2RlbCwgZWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gIH1cbn0pO1xuXG52YXIgZWxlbWVudENyZWF0b3IgPSB7XG4gIGNhcnRlc2lhbjJkOiBmdW5jdGlvbiAoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNIb3Jpem9udGFsLCBhbmltYXRpb25Nb2RlbCwgaXNVcGRhdGUpIHtcbiAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgc2hhcGU6IHpyVXRpbC5leHRlbmQoe30sIGxheW91dClcbiAgICB9KTsgLy8gQW5pbWF0aW9uXG5cbiAgICBpZiAoYW5pbWF0aW9uTW9kZWwpIHtcbiAgICAgIHZhciByZWN0U2hhcGUgPSByZWN0LnNoYXBlO1xuICAgICAgdmFyIGFuaW1hdGVQcm9wZXJ0eSA9IGlzSG9yaXpvbnRhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgIHZhciBhbmltYXRlVGFyZ2V0ID0ge307XG4gICAgICByZWN0U2hhcGVbYW5pbWF0ZVByb3BlcnR5XSA9IDA7XG4gICAgICBhbmltYXRlVGFyZ2V0W2FuaW1hdGVQcm9wZXJ0eV0gPSBsYXlvdXRbYW5pbWF0ZVByb3BlcnR5XTtcbiAgICAgIGdyYXBoaWNbaXNVcGRhdGUgPyAndXBkYXRlUHJvcHMnIDogJ2luaXRQcm9wcyddKHJlY3QsIHtcbiAgICAgICAgc2hhcGU6IGFuaW1hdGVUYXJnZXRcbiAgICAgIH0sIGFuaW1hdGlvbk1vZGVsLCBkYXRhSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiByZWN0O1xuICB9LFxuICBwb2xhcjogZnVuY3Rpb24gKGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIGlzUmFkaWFsLCBhbmltYXRpb25Nb2RlbCwgaXNVcGRhdGUpIHtcbiAgICAvLyBLZWVwIHRoZSBzYW1lIGxvZ2ljIHdpdGggYmFyIGluIGNhdGVzaW9uOiB1c2UgZW5kIHZhbHVlIHRvIGNvbnRyb2xcbiAgICAvLyBkaXJlY3Rpb24uIE5vdGljZSB0aGF0IGlmIGNsb2Nrd2lzZSBpcyB0cnVlIChieSBkZWZhdWx0KSwgdGhlIHNlY3RvclxuICAgIC8vIHdpbGwgYWx3YXlzIGRyYXcgY2xvY2t3aXNlbHksIG5vIG1hdHRlciB3aGV0aGVyIGVuZEFuZ2xlIGlzIGdyZWF0ZXJcbiAgICAvLyBvciBsZXNzIHRoYW4gc3RhcnRBbmdsZS5cbiAgICB2YXIgY2xvY2t3aXNlID0gbGF5b3V0LnN0YXJ0QW5nbGUgPCBsYXlvdXQuZW5kQW5nbGU7XG4gICAgdmFyIHNlY3RvciA9IG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgICBzaGFwZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgY2xvY2t3aXNlOiBjbG9ja3dpc2VcbiAgICAgIH0sIGxheW91dClcbiAgICB9KTsgLy8gQW5pbWF0aW9uXG5cbiAgICBpZiAoYW5pbWF0aW9uTW9kZWwpIHtcbiAgICAgIHZhciBzZWN0b3JTaGFwZSA9IHNlY3Rvci5zaGFwZTtcbiAgICAgIHZhciBhbmltYXRlUHJvcGVydHkgPSBpc1JhZGlhbCA/ICdyJyA6ICdlbmRBbmdsZSc7XG4gICAgICB2YXIgYW5pbWF0ZVRhcmdldCA9IHt9O1xuICAgICAgc2VjdG9yU2hhcGVbYW5pbWF0ZVByb3BlcnR5XSA9IGlzUmFkaWFsID8gMCA6IGxheW91dC5zdGFydEFuZ2xlO1xuICAgICAgYW5pbWF0ZVRhcmdldFthbmltYXRlUHJvcGVydHldID0gbGF5b3V0W2FuaW1hdGVQcm9wZXJ0eV07XG4gICAgICBncmFwaGljW2lzVXBkYXRlID8gJ3VwZGF0ZVByb3BzJyA6ICdpbml0UHJvcHMnXShzZWN0b3IsIHtcbiAgICAgICAgc2hhcGU6IGFuaW1hdGVUYXJnZXRcbiAgICAgIH0sIGFuaW1hdGlvbk1vZGVsLCBkYXRhSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0b3I7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlbW92ZVJlY3QoZGF0YUluZGV4LCBhbmltYXRpb25Nb2RlbCwgZWwpIHtcbiAgLy8gTm90IHNob3cgdGV4dCB3aGVuIGFuaW1hdGluZ1xuICBlbC5zdHlsZS50ZXh0ID0gbnVsbDtcbiAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgIHNoYXBlOiB7XG4gICAgICB3aWR0aDogMFxuICAgIH1cbiAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCwgZnVuY3Rpb24gKCkge1xuICAgIGVsLnBhcmVudCAmJiBlbC5wYXJlbnQucmVtb3ZlKGVsKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNlY3RvcihkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCkge1xuICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gIGVsLnN0eWxlLnRleHQgPSBudWxsO1xuICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgc2hhcGU6IHtcbiAgICAgIHI6IGVsLnNoYXBlLnIwXG4gICAgfVxuICB9LCBhbmltYXRpb25Nb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgZWwucGFyZW50ICYmIGVsLnBhcmVudC5yZW1vdmUoZWwpO1xuICB9KTtcbn1cblxudmFyIGdldExheW91dCA9IHtcbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCkge1xuICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgICB2YXIgZml4ZWRMaW5lV2lkdGggPSBnZXRMaW5lV2lkdGgoaXRlbU1vZGVsLCBsYXlvdXQpOyAvLyBmaXggbGF5b3V0IHdpdGggbGluZVdpZHRoXG5cbiAgICB2YXIgc2lnblggPSBsYXlvdXQud2lkdGggPiAwID8gMSA6IC0xO1xuICAgIHZhciBzaWduWSA9IGxheW91dC5oZWlnaHQgPiAwID8gMSA6IC0xO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBsYXlvdXQueCArIHNpZ25YICogZml4ZWRMaW5lV2lkdGggLyAyLFxuICAgICAgeTogbGF5b3V0LnkgKyBzaWduWSAqIGZpeGVkTGluZVdpZHRoIC8gMixcbiAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGggLSBzaWduWCAqIGZpeGVkTGluZVdpZHRoLFxuICAgICAgaGVpZ2h0OiBsYXlvdXQuaGVpZ2h0IC0gc2lnblkgKiBmaXhlZExpbmVXaWR0aFxuICAgIH07XG4gIH0sXG4gIHBvbGFyOiBmdW5jdGlvbiAoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwpIHtcbiAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN4OiBsYXlvdXQuY3gsXG4gICAgICBjeTogbGF5b3V0LmN5LFxuICAgICAgcjA6IGxheW91dC5yMCxcbiAgICAgIHI6IGxheW91dC5yLFxuICAgICAgc3RhcnRBbmdsZTogbGF5b3V0LnN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZTogbGF5b3V0LmVuZEFuZ2xlXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWwsIGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIHNlcmllc01vZGVsLCBpc0hvcml6b250YWwsIGlzUG9sYXIpIHtcbiAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ2NvbG9yJyk7XG4gIHZhciBvcGFjaXR5ID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ29wYWNpdHknKTtcbiAgdmFyIGl0ZW1TdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKTtcbiAgdmFyIGhvdmVyU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzLml0ZW1TdHlsZScpLmdldEJhckl0ZW1TdHlsZSgpO1xuXG4gIGlmICghaXNQb2xhcikge1xuICAgIGVsLnNldFNoYXBlKCdyJywgaXRlbVN0eWxlTW9kZWwuZ2V0KCdiYXJCb3JkZXJSYWRpdXMnKSB8fCAwKTtcbiAgfVxuXG4gIGVsLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgZmlsbDogY29sb3IsXG4gICAgb3BhY2l0eTogb3BhY2l0eVxuICB9LCBpdGVtU3R5bGVNb2RlbC5nZXRCYXJJdGVtU3R5bGUoKSkpO1xuICB2YXIgY3Vyc29yU3R5bGUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnY3Vyc29yJyk7XG4gIGN1cnNvclN0eWxlICYmIGVsLmF0dHIoJ2N1cnNvcicsIGN1cnNvclN0eWxlKTtcbiAgdmFyIGxhYmVsUG9zaXRpb25PdXRzaWRlID0gaXNIb3Jpem9udGFsID8gbGF5b3V0LmhlaWdodCA+IDAgPyAnYm90dG9tJyA6ICd0b3AnIDogbGF5b3V0LndpZHRoID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgaWYgKCFpc1BvbGFyKSB7XG4gICAgc2V0TGFiZWwoZWwuc3R5bGUsIGhvdmVyU3R5bGUsIGl0ZW1Nb2RlbCwgY29sb3IsIHNlcmllc01vZGVsLCBkYXRhSW5kZXgsIGxhYmVsUG9zaXRpb25PdXRzaWRlKTtcbiAgfVxuXG4gIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShlbCwgaG92ZXJTdHlsZSk7XG59IC8vIEluIGNhc2Ugd2lkdGggb3IgaGVpZ2h0IGFyZSB0b28gc21hbGwuXG5cblxuZnVuY3Rpb24gZ2V0TGluZVdpZHRoKGl0ZW1Nb2RlbCwgcmF3TGF5b3V0KSB7XG4gIHZhciBsaW5lV2lkdGggPSBpdGVtTW9kZWwuZ2V0KEJBUl9CT1JERVJfV0lEVEhfUVVFUlkpIHx8IDA7XG4gIHJldHVybiBNYXRoLm1pbihsaW5lV2lkdGgsIE1hdGguYWJzKHJhd0xheW91dC53aWR0aCksIE1hdGguYWJzKHJhd0xheW91dC5oZWlnaHQpKTtcbn1cblxudmFyIExhcmdlUGF0aCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2xhcmdlQmFyJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IFtdXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAvLyBEcmF3aW5nIGxpbmVzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gZHJhd2luZ1xuICAgIC8vIGEgd2hvbGUgbGluZSBvciBkcmF3aW5nIHJlY3RzLlxuICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgdmFyIHN0YXJ0UG9pbnQgPSB0aGlzLl9fc3RhcnRQb2ludDtcbiAgICB2YXIgdmFsdWVJZHggPSB0aGlzLl9fdmFsdWVJZHg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgc3RhcnRQb2ludFt0aGlzLl9fdmFsdWVJZHhdID0gcG9pbnRzW2kgKyB2YWx1ZUlkeF07XG4gICAgICBjdHgubW92ZVRvKHN0YXJ0UG9pbnRbMF0sIHN0YXJ0UG9pbnRbMV0pO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxhcmdlKHNlcmllc01vZGVsLCBncm91cCwgaW5jcmVtZW50YWwpIHtcbiAgLy8gVE9ETyBzdXBwb3J0IHBvbGFyXG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB2YXIgc3RhcnRQb2ludCA9IFtdO1xuICB2YXIgdmFsdWVJZHggPSBkYXRhLmdldExheW91dCgndmFsdWVBeGlzSG9yaXpvbnRhbCcpID8gMSA6IDA7XG4gIHN0YXJ0UG9pbnRbMSAtIHZhbHVlSWR4XSA9IGRhdGEuZ2V0TGF5b3V0KCd2YWx1ZUF4aXNTdGFydCcpO1xuICB2YXIgZWwgPSBuZXcgTGFyZ2VQYXRoKHtcbiAgICBzaGFwZToge1xuICAgICAgcG9pbnRzOiBkYXRhLmdldExheW91dCgnbGFyZ2VQb2ludHMnKVxuICAgIH0sXG4gICAgaW5jcmVtZW50YWw6ICEhaW5jcmVtZW50YWwsXG4gICAgX19zdGFydFBvaW50OiBzdGFydFBvaW50LFxuICAgIF9fdmFsdWVJZHg6IHZhbHVlSWR4XG4gIH0pO1xuICBncm91cC5hZGQoZWwpO1xuICBzZXRMYXJnZVN0eWxlKGVsLCBzZXJpZXNNb2RlbCwgZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHNldExhcmdlU3R5bGUoZWwsIHNlcmllc01vZGVsLCBkYXRhKSB7XG4gIHZhciBib3JkZXJDb2xvciA9IGRhdGEuZ2V0VmlzdWFsKCdib3JkZXJDb2xvcicpIHx8IGRhdGEuZ2V0VmlzdWFsKCdjb2xvcicpO1xuICB2YXIgaXRlbVN0eWxlID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZShbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJ10pO1xuICBlbC51c2VTdHlsZShpdGVtU3R5bGUpO1xuICBlbC5zdHlsZS5maWxsID0gbnVsbDtcbiAgZWwuc3R5bGUuc3Ryb2tlID0gYm9yZGVyQ29sb3I7XG4gIGVsLnN0eWxlLmxpbmVXaWR0aCA9IGRhdGEuZ2V0TGF5b3V0KCdiYXJXaWR0aCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXJWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFyVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBTZXJpZXNNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9TZXJpZXNcIik7XG5cbnZhciBjcmVhdGVMaXN0RnJvbUFycmF5ID0gcmVxdWlyZShcIi4uL2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgX2RlZmF1bHQgPSBTZXJpZXNNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnc2VyaWVzLl9fYmFzZV9iYXJfXycsXG4gIGdldEluaXRpYWxEYXRhOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkodGhpcy5nZXRTb3VyY2UoKSwgdGhpcyk7XG4gIH0sXG4gIGdldE1hcmtlclBvc2l0aW9uOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgIC8vIFBFTkRJTkcgaWYgY2xhbXAgP1xuICAgICAgdmFyIHB0ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoY29vcmRTeXMuY2xhbXBEYXRhKHZhbHVlKSk7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgdmFyIG9mZnNldCA9IGRhdGEuZ2V0TGF5b3V0KCdvZmZzZXQnKTtcbiAgICAgIHZhciBzaXplID0gZGF0YS5nZXRMYXlvdXQoJ3NpemUnKTtcbiAgICAgIHZhciBvZmZzZXRJbmRleCA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCkgPyAwIDogMTtcbiAgICAgIHB0W29mZnNldEluZGV4XSArPSBvZmZzZXQgKyBzaXplIC8gMjtcbiAgICAgIHJldHVybiBwdDtcbiAgICB9XG5cbiAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuIDnuqflsYLlj6BcbiAgICB6OiAyLFxuICAgIC8vIOS6jOe6p+WxguWPoFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIC8vIHN0YWNrOiBudWxsXG4gICAgLy8gQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAvLyB5QXhpc0luZGV4OiAwLFxuICAgIC8vIOacgOWwj+mrmOW6puaUueS4ujBcbiAgICBiYXJNaW5IZWlnaHQ6IDAsXG4gICAgLy8g5pyA5bCP6KeS5bqm5Li6MO+8jOS7heWvueaegeWdkOagh+ezu+S4i+eahOafseeKtuWbvuacieaViFxuICAgIGJhck1pbkFuZ2xlOiAwLFxuICAgIC8vIGN1cnNvcjogbnVsbCxcbiAgICBsYXJnZTogZmFsc2UsXG4gICAgbGFyZ2VUaHJlc2hvbGQ6IDQwMCxcbiAgICBwcm9ncmVzc2l2ZTogNWUzLFxuICAgIHByb2dyZXNzaXZlQ2h1bmtNb2RlOiAnbW9kJyxcbiAgICAvLyBiYXJNYXhXaWR0aDogbnVsbCxcbiAgICAvLyDpu5jorqToh6rpgILlupRcbiAgICAvLyBiYXJXaWR0aDogbnVsbCxcbiAgICAvLyDmn7Hpl7Tot53nprvvvIzpu5jorqTkuLrmn7HlvaLlrr3luqbnmoQzMCXvvIzlj6/orr7lm7rlrprlgLxcbiAgICAvLyBiYXJHYXA6ICczMCUnLFxuICAgIC8vIOexu+ebrumXtOafseW9oui3neemu++8jOm7mOiupOS4uuexu+ebrumXtOi3neeahDIwJe+8jOWPr+iuvuWbuuWumuWAvFxuICAgIC8vIGJhckNhdGVnb3J5R2FwOiAnMjAlJyxcbiAgICAvLyBsYWJlbDoge1xuICAgIC8vICAgICAgc2hvdzogZmFsc2VcbiAgICAvLyB9LFxuICAgIGl0ZW1TdHlsZToge30sXG4gICAgZW1waGFzaXM6IHt9XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXNlQmFyU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFzZUJhclNlcmllcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBtYWtlU3R5bGVNYXBwZXIgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgZ2V0QmFySXRlbVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2ZpbGwnLCAnY29sb3InXSwgWydzdHJva2UnLCAnYm9yZGVyQ29sb3InXSwgWydsaW5lV2lkdGgnLCAnYm9yZGVyV2lkdGgnXSwgLy8gQ29tcGF0aXRhYmxlIHdpdGggMlxuWydzdHJva2UnLCAnYmFyQm9yZGVyQ29sb3InXSwgWydsaW5lV2lkdGgnLCAnYmFyQm9yZGVyV2lkdGgnXSwgWydvcGFjaXR5J10sIFsnc2hhZG93Qmx1ciddLCBbJ3NoYWRvd09mZnNldFgnXSwgWydzaGFkb3dPZmZzZXRZJ10sIFsnc2hhZG93Q29sb3InXV0pO1xudmFyIF9kZWZhdWx0ID0ge1xuICBnZXRCYXJJdGVtU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcykge1xuICAgIHZhciBzdHlsZSA9IGdldEJhckl0ZW1TdHlsZSh0aGlzLCBleGNsdWRlcyk7XG5cbiAgICBpZiAodGhpcy5nZXRCb3JkZXJMaW5lRGFzaCkge1xuICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRCb3JkZXJMaW5lRGFzaCgpO1xuICAgICAgbGluZURhc2ggJiYgKHN0eWxlLmxpbmVEYXNoID0gbGluZURhc2gpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2Jhckl0ZW1TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2Jhckl0ZW1TdHlsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIF9sYWJlbEhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvbGFiZWxIZWxwZXJcIik7XG5cbnZhciBnZXREZWZhdWx0TGFiZWwgPSBfbGFiZWxIZWxwZXIuZ2V0RGVmYXVsdExhYmVsO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5mdW5jdGlvbiBzZXRMYWJlbChub3JtYWxTdHlsZSwgaG92ZXJTdHlsZSwgaXRlbU1vZGVsLCBjb2xvciwgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCwgbGFiZWxQb3NpdGlvbk91dHNpZGUpIHtcbiAgdmFyIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsJyk7XG4gIHZhciBob3ZlckxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzLmxhYmVsJyk7XG4gIGdyYXBoaWMuc2V0TGFiZWxTdHlsZShub3JtYWxTdHlsZSwgaG92ZXJTdHlsZSwgbGFiZWxNb2RlbCwgaG92ZXJMYWJlbE1vZGVsLCB7XG4gICAgbGFiZWxGZXRjaGVyOiBzZXJpZXNNb2RlbCxcbiAgICBsYWJlbERhdGFJbmRleDogZGF0YUluZGV4LFxuICAgIGRlZmF1bHRUZXh0OiBnZXREZWZhdWx0TGFiZWwoc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBkYXRhSW5kZXgpLFxuICAgIGlzUmVjdFRleHQ6IHRydWUsXG4gICAgYXV0b0NvbG9yOiBjb2xvclxuICB9KTtcbiAgZml4UG9zaXRpb24obm9ybWFsU3R5bGUpO1xuICBmaXhQb3NpdGlvbihob3ZlclN0eWxlKTtcbn1cblxuZnVuY3Rpb24gZml4UG9zaXRpb24oc3R5bGUsIGxhYmVsUG9zaXRpb25PdXRzaWRlKSB7XG4gIGlmIChzdHlsZS50ZXh0UG9zaXRpb24gPT09ICdvdXRzaWRlJykge1xuICAgIHN0eWxlLnRleHRQb3NpdGlvbiA9IGxhYmVsUG9zaXRpb25PdXRzaWRlO1xuICB9XG59XG5cbmV4cG9ydHMuc2V0TGFiZWwgPSBzZXRMYWJlbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvaGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvaGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciB2ZWN0b3IgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS92ZWN0b3JcIik7XG5cbnZhciBzeW1ib2xVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvc3ltYm9sXCIpO1xuXG52YXIgTGluZVBhdGggPSByZXF1aXJlKFwiLi9MaW5lUGF0aFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIHJvdW5kID0gX251bWJlci5yb3VuZDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvTGluZVxuICovXG52YXIgU1lNQk9MX0NBVEVHT1JJRVMgPSBbJ2Zyb21TeW1ib2wnLCAndG9TeW1ib2wnXTtcblxuZnVuY3Rpb24gbWFrZVN5bWJvbFR5cGVLZXkoc3ltYm9sQ2F0ZWdvcnkpIHtcbiAgcmV0dXJuICdfJyArIHN5bWJvbENhdGVnb3J5ICsgJ1R5cGUnO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWJvbChuYW1lLCBsaW5lRGF0YSwgaWR4KSB7XG4gIHZhciBjb2xvciA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTtcbiAgdmFyIHN5bWJvbFR5cGUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgbmFtZSk7XG4gIHZhciBzeW1ib2xTaXplID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsIG5hbWUgKyAnU2l6ZScpO1xuXG4gIGlmICghc3ltYm9sVHlwZSB8fCBzeW1ib2xUeXBlID09PSAnbm9uZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpKSB7XG4gICAgc3ltYm9sU2l6ZSA9IFtzeW1ib2xTaXplLCBzeW1ib2xTaXplXTtcbiAgfVxuXG4gIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgLXN5bWJvbFNpemVbMF0gLyAyLCAtc3ltYm9sU2l6ZVsxXSAvIDIsIHN5bWJvbFNpemVbMF0sIHN5bWJvbFNpemVbMV0sIGNvbG9yKTtcbiAgc3ltYm9sUGF0aC5uYW1lID0gbmFtZTtcbiAgcmV0dXJuIHN5bWJvbFBhdGg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmUocG9pbnRzKSB7XG4gIHZhciBsaW5lID0gbmV3IExpbmVQYXRoKHtcbiAgICBuYW1lOiAnbGluZSdcbiAgfSk7XG4gIHNldExpbmVQb2ludHMobGluZS5zaGFwZSwgcG9pbnRzKTtcbiAgcmV0dXJuIGxpbmU7XG59XG5cbmZ1bmN0aW9uIHNldExpbmVQb2ludHModGFyZ2V0U2hhcGUsIHBvaW50cykge1xuICB2YXIgcDEgPSBwb2ludHNbMF07XG4gIHZhciBwMiA9IHBvaW50c1sxXTtcbiAgdmFyIGNwMSA9IHBvaW50c1syXTtcbiAgdGFyZ2V0U2hhcGUueDEgPSBwMVswXTtcbiAgdGFyZ2V0U2hhcGUueTEgPSBwMVsxXTtcbiAgdGFyZ2V0U2hhcGUueDIgPSBwMlswXTtcbiAgdGFyZ2V0U2hhcGUueTIgPSBwMlsxXTtcbiAgdGFyZ2V0U2hhcGUucGVyY2VudCA9IDE7XG5cbiAgaWYgKGNwMSkge1xuICAgIHRhcmdldFNoYXBlLmNweDEgPSBjcDFbMF07XG4gICAgdGFyZ2V0U2hhcGUuY3B5MSA9IGNwMVsxXTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRTaGFwZS5jcHgxID0gTmFOO1xuICAgIHRhcmdldFNoYXBlLmNweTEgPSBOYU47XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlU3ltYm9sQW5kTGFiZWxCZWZvcmVMaW5lVXBkYXRlKCkge1xuICB2YXIgbGluZUdyb3VwID0gdGhpcztcbiAgdmFyIHN5bWJvbEZyb20gPSBsaW5lR3JvdXAuY2hpbGRPZk5hbWUoJ2Zyb21TeW1ib2wnKTtcbiAgdmFyIHN5bWJvbFRvID0gbGluZUdyb3VwLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xuICB2YXIgbGFiZWwgPSBsaW5lR3JvdXAuY2hpbGRPZk5hbWUoJ2xhYmVsJyk7IC8vIFF1aWNrIHJlamVjdFxuXG4gIGlmICghc3ltYm9sRnJvbSAmJiAhc3ltYm9sVG8gJiYgbGFiZWwuaWdub3JlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGludlNjYWxlID0gMTtcbiAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudDtcblxuICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgIGlmIChwYXJlbnROb2RlLnNjYWxlKSB7XG4gICAgICBpbnZTY2FsZSAvPSBwYXJlbnROb2RlLnNjYWxlWzBdO1xuICAgIH1cblxuICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudDtcbiAgfVxuXG4gIHZhciBsaW5lID0gbGluZUdyb3VwLmNoaWxkT2ZOYW1lKCdsaW5lJyk7IC8vIElmIGxpbmUgbm90IGNoYW5nZWRcbiAgLy8gRklYTUUgUGFyZW50IHNjYWxlIGNoYW5nZWRcblxuICBpZiAoIXRoaXMuX19kaXJ0eSAmJiAhbGluZS5fX2RpcnR5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBlcmNlbnQgPSBsaW5lLnNoYXBlLnBlcmNlbnQ7XG4gIHZhciBmcm9tUG9zID0gbGluZS5wb2ludEF0KDApO1xuICB2YXIgdG9Qb3MgPSBsaW5lLnBvaW50QXQocGVyY2VudCk7XG4gIHZhciBkID0gdmVjdG9yLnN1YihbXSwgdG9Qb3MsIGZyb21Qb3MpO1xuICB2ZWN0b3Iubm9ybWFsaXplKGQsIGQpO1xuXG4gIGlmIChzeW1ib2xGcm9tKSB7XG4gICAgc3ltYm9sRnJvbS5hdHRyKCdwb3NpdGlvbicsIGZyb21Qb3MpO1xuICAgIHZhciB0YW5nZW50ID0gbGluZS50YW5nZW50QXQoMCk7XG4gICAgc3ltYm9sRnJvbS5hdHRyKCdyb3RhdGlvbicsIE1hdGguUEkgLyAyIC0gTWF0aC5hdGFuMih0YW5nZW50WzFdLCB0YW5nZW50WzBdKSk7XG4gICAgc3ltYm9sRnJvbS5hdHRyKCdzY2FsZScsIFtpbnZTY2FsZSAqIHBlcmNlbnQsIGludlNjYWxlICogcGVyY2VudF0pO1xuICB9XG5cbiAgaWYgKHN5bWJvbFRvKSB7XG4gICAgc3ltYm9sVG8uYXR0cigncG9zaXRpb24nLCB0b1Bvcyk7XG4gICAgdmFyIHRhbmdlbnQgPSBsaW5lLnRhbmdlbnRBdCgxKTtcbiAgICBzeW1ib2xUby5hdHRyKCdyb3RhdGlvbicsIC1NYXRoLlBJIC8gMiAtIE1hdGguYXRhbjIodGFuZ2VudFsxXSwgdGFuZ2VudFswXSkpO1xuICAgIHN5bWJvbFRvLmF0dHIoJ3NjYWxlJywgW2ludlNjYWxlICogcGVyY2VudCwgaW52U2NhbGUgKiBwZXJjZW50XSk7XG4gIH1cblxuICBpZiAoIWxhYmVsLmlnbm9yZSkge1xuICAgIGxhYmVsLmF0dHIoJ3Bvc2l0aW9uJywgdG9Qb3MpO1xuICAgIHZhciB0ZXh0UG9zaXRpb247XG4gICAgdmFyIHRleHRBbGlnbjtcbiAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ247XG4gICAgdmFyIGRpc3RhbmNlID0gNSAqIGludlNjYWxlOyAvLyBFbmRcblxuICAgIGlmIChsYWJlbC5fX3Bvc2l0aW9uID09PSAnZW5kJykge1xuICAgICAgdGV4dFBvc2l0aW9uID0gW2RbMF0gKiBkaXN0YW5jZSArIHRvUG9zWzBdLCBkWzFdICogZGlzdGFuY2UgKyB0b1Bvc1sxXV07XG4gICAgICB0ZXh0QWxpZ24gPSBkWzBdID4gMC44ID8gJ2xlZnQnIDogZFswXSA8IC0wLjggPyAncmlnaHQnIDogJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRbMV0gPiAwLjggPyAndG9wJyA6IGRbMV0gPCAtMC44ID8gJ2JvdHRvbScgOiAnbWlkZGxlJztcbiAgICB9IC8vIE1pZGRsZVxuICAgIGVsc2UgaWYgKGxhYmVsLl9fcG9zaXRpb24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIHZhciBoYWxmUGVyY2VudCA9IHBlcmNlbnQgLyAyO1xuICAgICAgICB2YXIgdGFuZ2VudCA9IGxpbmUudGFuZ2VudEF0KGhhbGZQZXJjZW50KTtcbiAgICAgICAgdmFyIG4gPSBbdGFuZ2VudFsxXSwgLXRhbmdlbnRbMF1dO1xuICAgICAgICB2YXIgY3AgPSBsaW5lLnBvaW50QXQoaGFsZlBlcmNlbnQpO1xuXG4gICAgICAgIGlmIChuWzFdID4gMCkge1xuICAgICAgICAgIG5bMF0gPSAtblswXTtcbiAgICAgICAgICBuWzFdID0gLW5bMV07XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0UG9zaXRpb24gPSBbY3BbMF0gKyBuWzBdICogZGlzdGFuY2UsIGNwWzFdICsgblsxXSAqIGRpc3RhbmNlXTtcbiAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1NYXRoLmF0YW4yKHRhbmdlbnRbMV0sIHRhbmdlbnRbMF0pO1xuXG4gICAgICAgIGlmICh0b1Bvc1swXSA8IGZyb21Qb3NbMF0pIHtcbiAgICAgICAgICByb3RhdGlvbiA9IE1hdGguUEkgKyByb3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVsLmF0dHIoJ3JvdGF0aW9uJywgcm90YXRpb24pO1xuICAgICAgfSAvLyBTdGFydFxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdGV4dFBvc2l0aW9uID0gWy1kWzBdICogZGlzdGFuY2UgKyBmcm9tUG9zWzBdLCAtZFsxXSAqIGRpc3RhbmNlICsgZnJvbVBvc1sxXV07XG4gICAgICAgICAgdGV4dEFsaWduID0gZFswXSA+IDAuOCA/ICdyaWdodCcgOiBkWzBdIDwgLTAuOCA/ICdsZWZ0JyA6ICdjZW50ZXInO1xuICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gZFsxXSA+IDAuOCA/ICdib3R0b20nIDogZFsxXSA8IC0wLjggPyAndG9wJyA6ICdtaWRkbGUnO1xuICAgICAgICB9XG5cbiAgICBsYWJlbC5hdHRyKHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIC8vIFVzZSB0aGUgdXNlciBzcGVjaWZpZWQgdGV4dCBhbGlnbiBhbmQgYmFzZWxpbmUgZmlyc3RcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IGxhYmVsLl9fdmVydGljYWxBbGlnbiB8fCB0ZXh0VmVydGljYWxBbGlnbixcbiAgICAgICAgdGV4dEFsaWduOiBsYWJlbC5fX3RleHRBbGlnbiB8fCB0ZXh0QWxpZ25cbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbjogdGV4dFBvc2l0aW9uLFxuICAgICAgc2NhbGU6IFtpbnZTY2FsZSwgaW52U2NhbGVdXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cH1cbiAqIEBhbGlhcyB7bW9kdWxlOmVjaGFydHMvY2hhcnQvaGVscGVyL0xpbmV9XG4gKi9cblxuXG5mdW5jdGlvbiBMaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcblxuICB0aGlzLl9jcmVhdGVMaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbn1cblxudmFyIGxpbmVQcm90byA9IExpbmUucHJvdG90eXBlOyAvLyBVcGRhdGUgc3ltYm9sIHBvc2l0aW9uIGFuZCByb3RhdGlvblxuXG5saW5lUHJvdG8uYmVmb3JlVXBkYXRlID0gdXBkYXRlU3ltYm9sQW5kTGFiZWxCZWZvcmVMaW5lVXBkYXRlO1xuXG5saW5lUHJvdG8uX2NyZWF0ZUxpbmUgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgdmFyIHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICB2YXIgbGluZVBvaW50cyA9IGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgdmFyIGxpbmUgPSBjcmVhdGVMaW5lKGxpbmVQb2ludHMpO1xuICBsaW5lLnNoYXBlLnBlcmNlbnQgPSAwO1xuICBncmFwaGljLmluaXRQcm9wcyhsaW5lLCB7XG4gICAgc2hhcGU6IHtcbiAgICAgIHBlcmNlbnQ6IDFcbiAgICB9XG4gIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICB0aGlzLmFkZChsaW5lKTtcbiAgdmFyIGxhYmVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgbmFtZTogJ2xhYmVsJ1xuICB9KTtcbiAgdGhpcy5hZGQobGFiZWwpO1xuICB6clV0aWwuZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgdmFyIHN5bWJvbCA9IGNyZWF0ZVN5bWJvbChzeW1ib2xDYXRlZ29yeSwgbGluZURhdGEsIGlkeCk7IC8vIHN5bWJvbHMgbXVzdCBhZGRlZCBhZnRlciBsaW5lIHRvIG1ha2Ugc3VyZVxuICAgIC8vIGl0IHdpbGwgYmUgdXBkYXRlZCBhZnRlciBsaW5lI3VwZGF0ZS5cbiAgICAvLyBPciBzeW1ib2wgcG9zaXRpb24gYW5kIHJvdGF0aW9uIHVwZGF0ZSBpbiBsaW5lI2JlZm9yZVVwZGF0ZSB3aWxsIGJlIG9uZSBmcmFtZSBzbG93XG5cbiAgICB0aGlzLmFkZChzeW1ib2wpO1xuICAgIHRoaXNbbWFrZVN5bWJvbFR5cGVLZXkoc3ltYm9sQ2F0ZWdvcnkpXSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBzeW1ib2xDYXRlZ29yeSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX3VwZGF0ZUNvbW1vblN0bChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG59O1xuXG5saW5lUHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICB2YXIgc2VyaWVzTW9kZWwgPSBsaW5lRGF0YS5ob3N0TW9kZWw7XG4gIHZhciBsaW5lID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZScpO1xuICB2YXIgbGluZVBvaW50cyA9IGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgdmFyIHRhcmdldCA9IHtcbiAgICBzaGFwZToge31cbiAgfTtcbiAgc2V0TGluZVBvaW50cyh0YXJnZXQuc2hhcGUsIGxpbmVQb2ludHMpO1xuICBncmFwaGljLnVwZGF0ZVByb3BzKGxpbmUsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gIHpyVXRpbC5lYWNoKFNZTUJPTF9DQVRFR09SSUVTLCBmdW5jdGlvbiAoc3ltYm9sQ2F0ZWdvcnkpIHtcbiAgICB2YXIgc3ltYm9sVHlwZSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBzeW1ib2xDYXRlZ29yeSk7XG4gICAgdmFyIGtleSA9IG1ha2VTeW1ib2xUeXBlS2V5KHN5bWJvbENhdGVnb3J5KTsgLy8gU3ltYm9sIGNoYW5nZWRcblxuICAgIGlmICh0aGlzW2tleV0gIT09IHN5bWJvbFR5cGUpIHtcbiAgICAgIHRoaXMucmVtb3ZlKHRoaXMuY2hpbGRPZk5hbWUoc3ltYm9sQ2F0ZWdvcnkpKTtcbiAgICAgIHZhciBzeW1ib2wgPSBjcmVhdGVTeW1ib2woc3ltYm9sQ2F0ZWdvcnksIGxpbmVEYXRhLCBpZHgpO1xuICAgICAgdGhpcy5hZGQoc3ltYm9sKTtcbiAgICB9XG5cbiAgICB0aGlzW2tleV0gPSBzeW1ib2xUeXBlO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl91cGRhdGVDb21tb25TdGwobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xufTtcblxubGluZVByb3RvLl91cGRhdGVDb21tb25TdGwgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgdmFyIHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICB2YXIgbGluZSA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmUnKTtcbiAgdmFyIGxpbmVTdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmxpbmVTdHlsZTtcbiAgdmFyIGhvdmVyTGluZVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaG92ZXJMaW5lU3R5bGU7XG4gIHZhciBsYWJlbE1vZGVsID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUubGFiZWxNb2RlbDtcbiAgdmFyIGhvdmVyTGFiZWxNb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVyTGFiZWxNb2RlbDsgLy8gT3B0aW1pemF0aW9uIGZvciBsYXJnZSBkYXRhc2V0XG5cbiAgaWYgKCFzZXJpZXNTY29wZSB8fCBsaW5lRGF0YS5oYXNJdGVtT3B0aW9uKSB7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IGxpbmVEYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIGxpbmVTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCk7XG4gICAgaG92ZXJMaW5lU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzLmxpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuICAgIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsJyk7XG4gICAgaG92ZXJMYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcy5sYWJlbCcpO1xuICB9XG5cbiAgdmFyIHZpc3VhbENvbG9yID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuICB2YXIgdmlzdWFsT3BhY2l0eSA9IHpyVXRpbC5yZXRyaWV2ZTMobGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdvcGFjaXR5JyksIGxpbmVTdHlsZS5vcGFjaXR5LCAxKTtcbiAgbGluZS51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoe1xuICAgIHN0cm9rZU5vU2NhbGU6IHRydWUsXG4gICAgZmlsbDogJ25vbmUnLFxuICAgIHN0cm9rZTogdmlzdWFsQ29sb3IsXG4gICAgb3BhY2l0eTogdmlzdWFsT3BhY2l0eVxuICB9LCBsaW5lU3R5bGUpKTtcbiAgbGluZS5ob3ZlclN0eWxlID0gaG92ZXJMaW5lU3R5bGU7IC8vIFVwZGF0ZSBzeW1ib2xcblxuICB6clV0aWwuZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgdmFyIHN5bWJvbCA9IHRoaXMuY2hpbGRPZk5hbWUoc3ltYm9sQ2F0ZWdvcnkpO1xuXG4gICAgaWYgKHN5bWJvbCkge1xuICAgICAgc3ltYm9sLnNldENvbG9yKHZpc3VhbENvbG9yKTtcbiAgICAgIHN5bWJvbC5zZXRTdHlsZSh7XG4gICAgICAgIG9wYWNpdHk6IHZpc3VhbE9wYWNpdHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgdGhpcyk7XG4gIHZhciBzaG93TGFiZWwgPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTtcbiAgdmFyIGhvdmVyU2hvd0xhYmVsID0gaG92ZXJMYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTtcbiAgdmFyIGxhYmVsID0gdGhpcy5jaGlsZE9mTmFtZSgnbGFiZWwnKTtcbiAgdmFyIGRlZmF1bHRMYWJlbENvbG9yO1xuICB2YXIgYmFzZVRleHQ7IC8vIEZJWE1FOiB0aGUgbG9naWMgYmVsb3cgcHJvYmFibHkgc2hvdWxkIGJlIG1lcmdlZCB0byBgZ3JhcGhpYy5zZXRMYWJlbFN0eWxlYC5cblxuICBpZiAoc2hvd0xhYmVsIHx8IGhvdmVyU2hvd0xhYmVsKSB7XG4gICAgZGVmYXVsdExhYmVsQ29sb3IgPSB2aXN1YWxDb2xvciB8fCAnIzAwMCc7XG4gICAgYmFzZVRleHQgPSBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdub3JtYWwnLCBsaW5lRGF0YS5kYXRhVHlwZSk7XG5cbiAgICBpZiAoYmFzZVRleHQgPT0gbnVsbCkge1xuICAgICAgdmFyIHJhd1ZhbCA9IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGlkeCk7XG4gICAgICBiYXNlVGV4dCA9IHJhd1ZhbCA9PSBudWxsID8gbGluZURhdGEuZ2V0TmFtZShpZHgpIDogaXNGaW5pdGUocmF3VmFsKSA/IHJvdW5kKHJhd1ZhbCkgOiByYXdWYWw7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vcm1hbFRleHQgPSBzaG93TGFiZWwgPyBiYXNlVGV4dCA6IG51bGw7XG4gIHZhciBlbXBoYXNpc1RleHQgPSBob3ZlclNob3dMYWJlbCA/IHpyVXRpbC5yZXRyaWV2ZTIoc2VyaWVzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoaWR4LCAnZW1waGFzaXMnLCBsaW5lRGF0YS5kYXRhVHlwZSksIGJhc2VUZXh0KSA6IG51bGw7XG4gIHZhciBsYWJlbFN0eWxlID0gbGFiZWwuc3R5bGU7IC8vIEFsd2F5cyBzZXQgYHRleHRTdHlsZWAgZXZlbiBpZiBgbm9ybWFsU3R5bGUudGV4dGAgaXMgbnVsbCwgYmVjYXVzZSBkZWZhdWx0XG4gIC8vIHZhbHVlcyBoYXZlIHRvIGJlIHNldCBvbiBgbm9ybWFsU3R5bGVgLlxuXG4gIGlmIChub3JtYWxUZXh0ICE9IG51bGwgfHwgZW1waGFzaXNUZXh0ICE9IG51bGwpIHtcbiAgICBncmFwaGljLnNldFRleHRTdHlsZShsYWJlbC5zdHlsZSwgbGFiZWxNb2RlbCwge1xuICAgICAgdGV4dDogbm9ybWFsVGV4dFxuICAgIH0sIHtcbiAgICAgIGF1dG9Db2xvcjogZGVmYXVsdExhYmVsQ29sb3JcbiAgICB9KTtcbiAgICBsYWJlbC5fX3RleHRBbGlnbiA9IGxhYmVsU3R5bGUudGV4dEFsaWduO1xuICAgIGxhYmVsLl9fdmVydGljYWxBbGlnbiA9IGxhYmVsU3R5bGUudGV4dFZlcnRpY2FsQWxpZ247IC8vICdzdGFydCcsICdtaWRkbGUnLCAnZW5kJ1xuXG4gICAgbGFiZWwuX19wb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpIHx8ICdtaWRkbGUnO1xuICB9XG5cbiAgaWYgKGVtcGhhc2lzVGV4dCAhPSBudWxsKSB7XG4gICAgLy8gT25seSB0aGVzZSBwcm9wZXJ0aWVzIHN1cHBvcnRlZCBpbiB0aGlzIGVtcGhhc2lzIHN0eWxlIGhlcmUuXG4gICAgbGFiZWwuaG92ZXJTdHlsZSA9IHtcbiAgICAgIHRleHQ6IGVtcGhhc2lzVGV4dCxcbiAgICAgIHRleHRGaWxsOiBob3ZlckxhYmVsTW9kZWwuZ2V0VGV4dENvbG9yKHRydWUpLFxuICAgICAgLy8gRm9yIG1lcmdpbmcgaG92ZXIgc3R5bGUgdG8gbm9ybWFsIHN0eWxlLCBkbyBub3QgdXNlXG4gICAgICAvLyBgaG92ZXJMYWJlbE1vZGVsLmdldEZvbnQoKWAgaGVyZS5cbiAgICAgIGZvbnRTdHlsZTogaG92ZXJMYWJlbE1vZGVsLmdldFNoYWxsb3coJ2ZvbnRTdHlsZScpLFxuICAgICAgZm9udFdlaWdodDogaG92ZXJMYWJlbE1vZGVsLmdldFNoYWxsb3coJ2ZvbnRXZWlnaHQnKSxcbiAgICAgIGZvbnRTaXplOiBob3ZlckxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZm9udFNpemUnKSxcbiAgICAgIGZvbnRGYW1pbHk6IGhvdmVyTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdmb250RmFtaWx5JylcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGxhYmVsLmhvdmVyU3R5bGUgPSB7XG4gICAgICB0ZXh0OiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGxhYmVsLmlnbm9yZSA9ICFzaG93TGFiZWwgJiYgIWhvdmVyU2hvd0xhYmVsO1xuICBncmFwaGljLnNldEhvdmVyU3R5bGUodGhpcyk7XG59O1xuXG5saW5lUHJvdG8uaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnRyaWdnZXIoJ2VtcGhhc2lzJyk7XG59O1xuXG5saW5lUHJvdG8uZG93bnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudHJpZ2dlcignbm9ybWFsJyk7XG59O1xuXG5saW5lUHJvdG8udXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgpIHtcbiAgdGhpcy5zZXRMaW5lUG9pbnRzKGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSk7XG59O1xuXG5saW5lUHJvdG8uc2V0TGluZVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgdmFyIGxpbmVQYXRoID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZScpO1xuICBzZXRMaW5lUG9pbnRzKGxpbmVQYXRoLnNoYXBlLCBwb2ludHMpO1xuICBsaW5lUGF0aC5kaXJ0eSgpO1xufTtcblxuenJVdGlsLmluaGVyaXRzKExpbmUsIGdyYXBoaWMuR3JvdXApO1xudmFyIF9kZWZhdWx0ID0gTGluZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9MaW5lLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgTGluZUdyb3VwID0gcmVxdWlyZShcIi4vTGluZVwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvTGluZURyYXdcbiAqL1xuLy8gaW1wb3J0IEluY3JlbWVudGFsRGlzcGxheWFibGUgZnJvbSAnenJlbmRlci9zcmMvZ3JhcGhpYy9JbmNyZW1lbnRhbERpc3BsYXlhYmxlJztcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29tcG9uZW50L21hcmtlci9MaW5lRHJhd1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExpbmVEcmF3KGN0b3IpIHtcbiAgdGhpcy5fY3RvciA9IGN0b3IgfHwgTGluZUdyb3VwO1xuICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbn1cblxudmFyIGxpbmVEcmF3UHJvdG8gPSBMaW5lRHJhdy5wcm90b3R5cGU7XG5cbmxpbmVEcmF3UHJvdG8uaXNQZXJzaXN0ZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBsaW5lRGF0YVxuICovXG5cblxubGluZURyYXdQcm90by51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGxpbmVEYXRhKSB7XG4gIHZhciBsaW5lRHJhdyA9IHRoaXM7XG4gIHZhciBncm91cCA9IGxpbmVEcmF3Lmdyb3VwO1xuICB2YXIgb2xkTGluZURhdGEgPSBsaW5lRHJhdy5fbGluZURhdGE7XG4gIGxpbmVEcmF3Ll9saW5lRGF0YSA9IGxpbmVEYXRhOyAvLyBUaGVyZSBpcyBubyBvbGRMaW5lRGF0YSBvbmx5IHdoZW4gZmlyc3QgcmVuZGVyaW5nIG9yIHN3aXRjaGluZyBmcm9tXG4gIC8vIHN0cmVhbSBtb2RlIHRvIG5vcm1hbCBtb2RlLCB3aGVyZSBwcmV2aW91cyBlbGVtZW50cyBzaG91bGQgYmUgcmVtb3ZlZC5cblxuICBpZiAoIW9sZExpbmVEYXRhKSB7XG4gICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH1cblxuICB2YXIgc2VyaWVzU2NvcGUgPSBtYWtlU2VyaWVzU2NvcGUobGluZURhdGEpO1xuICBsaW5lRGF0YS5kaWZmKG9sZExpbmVEYXRhKS5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgIGRvQWRkKGxpbmVEcmF3LCBsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG4gIH0pLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICBkb1VwZGF0ZShsaW5lRHJhdywgb2xkTGluZURhdGEsIGxpbmVEYXRhLCBvbGRJZHgsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICB9KS5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgIGdyb3VwLnJlbW92ZShvbGRMaW5lRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCkpO1xuICB9KS5leGVjdXRlKCk7XG59O1xuXG5mdW5jdGlvbiBkb0FkZChsaW5lRHJhdywgbGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgdmFyIGl0ZW1MYXlvdXQgPSBsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG5cbiAgaWYgKCFsaW5lTmVlZHNEcmF3KGl0ZW1MYXlvdXQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVsID0gbmV3IGxpbmVEcmF3Ll9jdG9yKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgbGluZURhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIGVsKTtcbiAgbGluZURyYXcuZ3JvdXAuYWRkKGVsKTtcbn1cblxuZnVuY3Rpb24gZG9VcGRhdGUobGluZURyYXcsIG9sZExpbmVEYXRhLCBuZXdMaW5lRGF0YSwgb2xkSWR4LCBuZXdJZHgsIHNlcmllc1Njb3BlKSB7XG4gIHZhciBpdGVtRWwgPSBvbGRMaW5lRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG5cbiAgaWYgKCFsaW5lTmVlZHNEcmF3KG5ld0xpbmVEYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KSkpIHtcbiAgICBsaW5lRHJhdy5ncm91cC5yZW1vdmUoaXRlbUVsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWl0ZW1FbCkge1xuICAgIGl0ZW1FbCA9IG5ldyBsaW5lRHJhdy5fY3RvcihuZXdMaW5lRGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbUVsLnVwZGF0ZURhdGEobmV3TGluZURhdGEsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICB9XG5cbiAgbmV3TGluZURhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIGl0ZW1FbCk7XG4gIGxpbmVEcmF3Lmdyb3VwLmFkZChpdGVtRWwpO1xufVxuXG5saW5lRHJhd1Byb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxpbmVEYXRhID0gdGhpcy5fbGluZURhdGE7IC8vIERvIG5vdCBzdXBwb3J0IHVwZGF0ZSBsYXlvdXQgaW4gaW5jcmVtZW50YWwgbW9kZS5cblxuICBpZiAoIWxpbmVEYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGluZURhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICBlbC51cGRhdGVMYXlvdXQobGluZURhdGEsIGlkeCk7XG4gIH0sIHRoaXMpO1xufTtcblxubGluZURyYXdQcm90by5pbmNyZW1lbnRhbFByZXBhcmVVcGRhdGUgPSBmdW5jdGlvbiAobGluZURhdGEpIHtcbiAgdGhpcy5fc2VyaWVzU2NvcGUgPSBtYWtlU2VyaWVzU2NvcGUobGluZURhdGEpO1xuICB0aGlzLl9saW5lRGF0YSA9IG51bGw7XG4gIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG59O1xuXG5saW5lRHJhd1Byb3RvLmluY3JlbWVudGFsVXBkYXRlID0gZnVuY3Rpb24gKHRhc2tQYXJhbXMsIGxpbmVEYXRhKSB7XG4gIGZ1bmN0aW9uIHVwZGF0ZUluY3JlbWVudGFsQW5kSG92ZXIoZWwpIHtcbiAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgIGVsLmluY3JlbWVudGFsID0gZWwudXNlSG92ZXJMYXllciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaWR4ID0gdGFza1BhcmFtcy5zdGFydDsgaWR4IDwgdGFza1BhcmFtcy5lbmQ7IGlkeCsrKSB7XG4gICAgdmFyIGl0ZW1MYXlvdXQgPSBsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG5cbiAgICBpZiAobGluZU5lZWRzRHJhdyhpdGVtTGF5b3V0KSkge1xuICAgICAgdmFyIGVsID0gbmV3IHRoaXMuX2N0b3IobGluZURhdGEsIGlkeCwgdGhpcy5fc2VyaWVzU2NvcGUpO1xuICAgICAgZWwudHJhdmVyc2UodXBkYXRlSW5jcmVtZW50YWxBbmRIb3Zlcik7XG4gICAgICB0aGlzLmdyb3VwLmFkZChlbCk7XG4gICAgICBsaW5lRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgZWwpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gbWFrZVNlcmllc1Njb3BlKGxpbmVEYXRhKSB7XG4gIHZhciBob3N0TW9kZWwgPSBsaW5lRGF0YS5ob3N0TW9kZWw7XG4gIHJldHVybiB7XG4gICAgbGluZVN0eWxlOiBob3N0TW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpLFxuICAgIGhvdmVyTGluZVN0eWxlOiBob3N0TW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzLmxpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpLFxuICAgIGxhYmVsTW9kZWw6IGhvc3RNb2RlbC5nZXRNb2RlbCgnbGFiZWwnKSxcbiAgICBob3ZlckxhYmVsTW9kZWw6IGhvc3RNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMubGFiZWwnKVxuICB9O1xufVxuXG5saW5lRHJhd1Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fY2xlYXJJbmNyZW1lbnRhbCgpO1xuXG4gIHRoaXMuX2luY3JlbWVudGFsID0gbnVsbDtcbiAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbn07XG5cbmxpbmVEcmF3UHJvdG8uX2NsZWFySW5jcmVtZW50YWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbmNyZW1lbnRhbCA9IHRoaXMuX2luY3JlbWVudGFsO1xuXG4gIGlmIChpbmNyZW1lbnRhbCkge1xuICAgIGluY3JlbWVudGFsLmNsZWFyRGlzcGxheWJsZXMoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQb2ludE5hTihwdCkge1xuICByZXR1cm4gaXNOYU4ocHRbMF0pIHx8IGlzTmFOKHB0WzFdKTtcbn1cblxuZnVuY3Rpb24gbGluZU5lZWRzRHJhdyhwdHMpIHtcbiAgcmV0dXJuICFpc1BvaW50TmFOKHB0c1swXSkgJiYgIWlzUG9pbnROYU4ocHRzWzFdKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gTGluZURyYXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9MaW5lRHJhdy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xpbmVEcmF3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvclwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIExpbmUgcGF0aCBmb3IgYmV6aWVyIGFuZCBzdHJhaWdodCBsaW5lIGRyYXdcbiAqL1xudmFyIHN0cmFpZ2h0TGluZVByb3RvID0gZ3JhcGhpYy5MaW5lLnByb3RvdHlwZTtcbnZhciBiZXppZXJDdXJ2ZVByb3RvID0gZ3JhcGhpYy5CZXppZXJDdXJ2ZS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGlzTGluZShzaGFwZSkge1xuICByZXR1cm4gaXNOYU4oK3NoYXBlLmNweDEpIHx8IGlzTmFOKCtzaGFwZS5jcHkxKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gIHR5cGU6ICdlYy1saW5lJyxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIHNoYXBlOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgeDI6IDAsXG4gICAgeTI6IDAsXG4gICAgcGVyY2VudDogMSxcbiAgICBjcHgxOiBudWxsLFxuICAgIGNweTE6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIChpc0xpbmUoc2hhcGUpID8gc3RyYWlnaHRMaW5lUHJvdG8gOiBiZXppZXJDdXJ2ZVByb3RvKS5idWlsZFBhdGgoY3R4LCBzaGFwZSk7XG4gIH0sXG4gIHBvaW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIGlzTGluZSh0aGlzLnNoYXBlKSA/IHN0cmFpZ2h0TGluZVByb3RvLnBvaW50QXQuY2FsbCh0aGlzLCB0KSA6IGJlemllckN1cnZlUHJvdG8ucG9pbnRBdC5jYWxsKHRoaXMsIHQpO1xuICB9LFxuICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICB2YXIgcCA9IGlzTGluZShzaGFwZSkgPyBbc2hhcGUueDIgLSBzaGFwZS54MSwgc2hhcGUueTIgLSBzaGFwZS55MV0gOiBiZXppZXJDdXJ2ZVByb3RvLnRhbmdlbnRBdC5jYWxsKHRoaXMsIHQpO1xuICAgIHJldHVybiB2ZWMyLm5vcm1hbGl6ZShwLCBwKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xpbmVQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZVBhdGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9zeW1ib2xcIik7XG5cbnZhciBjcmVhdGVTeW1ib2wgPSBfc3ltYm9sLmNyZWF0ZVN5bWJvbDtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIHBhcnNlUGVyY2VudCA9IF9udW1iZXIucGFyc2VQZXJjZW50O1xuXG52YXIgX2xhYmVsSGVscGVyID0gcmVxdWlyZShcIi4vbGFiZWxIZWxwZXJcIik7XG5cbnZhciBnZXREZWZhdWx0TGFiZWwgPSBfbGFiZWxIZWxwZXIuZ2V0RGVmYXVsdExhYmVsO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2xcbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIHttb2R1bGU6ZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sfVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwfVxuICovXG5mdW5jdGlvbiBTeW1ib2xDbHooZGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICBncmFwaGljLkdyb3VwLmNhbGwodGhpcyk7XG4gIHRoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbn1cblxudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sQ2x6LnByb3RvdHlwZTtcbi8qKlxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbd2lkdGgsIGhlaWdodF1cbiAqL1xuXG52YXIgZ2V0U3ltYm9sU2l6ZSA9IFN5bWJvbENsei5nZXRTeW1ib2xTaXplID0gZnVuY3Rpb24gKGRhdGEsIGlkeCkge1xuICB2YXIgc3ltYm9sU2l6ZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJyk7XG4gIHJldHVybiBzeW1ib2xTaXplIGluc3RhbmNlb2YgQXJyYXkgPyBzeW1ib2xTaXplLnNsaWNlKCkgOiBbK3N5bWJvbFNpemUsICtzeW1ib2xTaXplXTtcbn07XG5cbmZ1bmN0aW9uIGdldFNjYWxlKHN5bWJvbFNpemUpIHtcbiAgcmV0dXJuIFtzeW1ib2xTaXplWzBdIC8gMiwgc3ltYm9sU2l6ZVsxXSAvIDJdO1xufVxuXG5mdW5jdGlvbiBkcmlmdFN5bWJvbChkeCwgZHkpIHtcbiAgdGhpcy5wYXJlbnQuZHJpZnQoZHgsIGR5KTtcbn1cblxuc3ltYm9sUHJvdG8uX2NyZWF0ZVN5bWJvbCA9IGZ1bmN0aW9uIChzeW1ib2xUeXBlLCBkYXRhLCBpZHgsIHN5bWJvbFNpemUsIGtlZXBBc3BlY3QpIHtcbiAgLy8gUmVtb3ZlIHBhdGhzIGNyZWF0ZWQgYmVmb3JlXG4gIHRoaXMucmVtb3ZlQWxsKCk7XG4gIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpOyAvLyB2YXIgc3ltYm9sUGF0aCA9IGNyZWF0ZVN5bWJvbChcbiAgLy8gICAgIHN5bWJvbFR5cGUsIC0wLjUsIC0wLjUsIDEsIDEsIGNvbG9yXG4gIC8vICk7XG4gIC8vIElmIHdpZHRoL2hlaWdodCBhcmUgc2V0IHRvbyBzbWFsbCAoZS5nLiwgc2V0IHRvIDEpIG9uIGlvczEwXG4gIC8vIGFuZCBtYWNPUyBTaWVycmEsIGEgY2lyY2xlIHN0cm9rZSBiZWNvbWUgYSByZWN0LCBubyBtYXR0ZXIgd2hhdFxuICAvLyB0aGUgc2NhbGUgaXMgc2V0LiBTbyB3ZSBzZXQgd2lkdGgvaGVpZ2h0IGFzIDIuIFNlZSAjNDE1MC5cblxuICB2YXIgc3ltYm9sUGF0aCA9IGNyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCAtMSwgLTEsIDIsIDIsIGNvbG9yLCBrZWVwQXNwZWN0KTtcbiAgc3ltYm9sUGF0aC5hdHRyKHtcbiAgICB6MjogMTAwLFxuICAgIGN1bGxpbmc6IHRydWUsXG4gICAgc2NhbGU6IGdldFNjYWxlKHN5bWJvbFNpemUpXG4gIH0pOyAvLyBSZXdyaXRlIGRyaWZ0IG1ldGhvZFxuXG4gIHN5bWJvbFBhdGguZHJpZnQgPSBkcmlmdFN5bWJvbDtcbiAgdGhpcy5fc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGU7XG4gIHRoaXMuYWRkKHN5bWJvbFBhdGgpO1xufTtcbi8qKlxuICogU3RvcCBhbmltYXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9MYXN0RnJhbWVcbiAqL1xuXG5cbnN5bWJvbFByb3RvLnN0b3BTeW1ib2xBbmltYXRpb24gPSBmdW5jdGlvbiAodG9MYXN0RnJhbWUpIHtcbiAgdGhpcy5jaGlsZEF0KDApLnN0b3BBbmltYXRpb24odG9MYXN0RnJhbWUpO1xufTtcbi8qKlxuICogRklYTUU6XG4gKiBDYXV0aW9uOiBUaGlzIG1ldGhvZCBicmVha3MgdGhlIGVuY2Fwc3VsYXRpb24gb2YgdGhpcyBtb2R1bGUsXG4gKiBidXQgaXQgaW5kZWVkIGJyaW5ncyBjb252ZW5pZW5jZS4gU28gZG8gbm90IHVzZSB0aGUgbWV0aG9kXG4gKiB1bmxlc3MgeW91IGRldGFpbGVkbHkga25vdyBhbGwgdGhlIGltcGxlbWVudHMgb2YgYFN5bWJvbGAsXG4gKiBlc3BlY2lhbGx5IGFuaW1hdGlvbi5cbiAqXG4gKiBHZXQgc3ltYm9sIHBhdGggZWxlbWVudC5cbiAqL1xuXG5cbnN5bWJvbFByb3RvLmdldFN5bWJvbFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNoaWxkQXQoMCk7XG59O1xuLyoqXG4gKiBHZXQgc2NhbGUoYWthLCBjdXJyZW50IHN5bWJvbCBzaXplKS5cbiAqIEluY2x1ZGluZyB0aGUgY2hhbmdlIGNhdXNlZCBieSBhbmltYXRpb25cbiAqL1xuXG5cbnN5bWJvbFByb3RvLmdldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jaGlsZEF0KDApLnNjYWxlO1xufTtcbi8qKlxuICogSGlnaGxpZ2h0IHN5bWJvbFxuICovXG5cblxuc3ltYm9sUHJvdG8uaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNoaWxkQXQoMCkudHJpZ2dlcignZW1waGFzaXMnKTtcbn07XG4vKipcbiAqIERvd25wbGF5IHN5bWJvbFxuICovXG5cblxuc3ltYm9sUHJvdG8uZG93bnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hpbGRBdCgwKS50cmlnZ2VyKCdub3JtYWwnKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gKi9cblxuXG5zeW1ib2xQcm90by5zZXRaID0gZnVuY3Rpb24gKHpsZXZlbCwgeikge1xuICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgc3ltYm9sUGF0aC56bGV2ZWwgPSB6bGV2ZWw7XG4gIHN5bWJvbFBhdGgueiA9IHo7XG59O1xuXG5zeW1ib2xQcm90by5zZXREcmFnZ2FibGUgPSBmdW5jdGlvbiAoZHJhZ2dhYmxlKSB7XG4gIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICBzeW1ib2xQYXRoLmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgc3ltYm9sUGF0aC5jdXJzb3IgPSBkcmFnZ2FibGUgPyAnbW92ZScgOiAncG9pbnRlcic7XG59O1xuLyoqXG4gKiBVcGRhdGUgc3ltYm9sIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlXVxuICogQHBhcmFtIHtPYmplY3R9IFtzZXJpZXNTY29wZS5pdGVtU3R5bGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlLmhvdmVySXRlbVN0eWxlXVxuICogQHBhcmFtIHtPYmplY3R9IFtzZXJpZXNTY29wZS5zeW1ib2xSb3RhdGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlLnN5bWJvbE9mZnNldF1cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtzZXJpZXNTY29wZS5sYWJlbE1vZGVsXVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3Nlcmllc1Njb3BlLmhvdmVyTGFiZWxNb2RlbF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nlcmllc1Njb3BlLmhvdmVyQW5pbWF0aW9uXVxuICogQHBhcmFtIHtPYmplY3R9IFtzZXJpZXNTY29wZS5jdXJzb3JTdHlsZV1cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtzZXJpZXNTY29wZS5pdGVtTW9kZWxdXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Nlcmllc1Njb3BlLnN5bWJvbElubmVyQ29sb3JdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlLmZhZGVJbj1mYWxzZV1cbiAqL1xuXG5cbnN5bWJvbFByb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICB0aGlzLnNpbGVudCA9IGZhbHNlO1xuICB2YXIgc3ltYm9sVHlwZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSB8fCAnY2lyY2xlJztcbiAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gIHZhciBzeW1ib2xTaXplID0gZ2V0U3ltYm9sU2l6ZShkYXRhLCBpZHgpO1xuICB2YXIgaXNJbml0ID0gc3ltYm9sVHlwZSAhPT0gdGhpcy5fc3ltYm9sVHlwZTtcblxuICBpZiAoaXNJbml0KSB7XG4gICAgdmFyIGtlZXBBc3BlY3QgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sS2VlcEFzcGVjdCcpO1xuXG4gICAgdGhpcy5fY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwga2VlcEFzcGVjdCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgc3ltYm9sUGF0aC5zaWxlbnQgPSBmYWxzZTtcbiAgICBncmFwaGljLnVwZGF0ZVByb3BzKHN5bWJvbFBhdGgsIHtcbiAgICAgIHNjYWxlOiBnZXRTY2FsZShzeW1ib2xTaXplKVxuICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlQ29tbW9uKGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwgc2VyaWVzU2NvcGUpO1xuXG4gIGlmIChpc0luaXQpIHtcbiAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICB2YXIgZmFkZUluID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuZmFkZUluO1xuICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICBzY2FsZTogc3ltYm9sUGF0aC5zY2FsZS5zbGljZSgpXG4gICAgfTtcbiAgICBmYWRlSW4gJiYgKHRhcmdldC5zdHlsZSA9IHtcbiAgICAgIG9wYWNpdHk6IHN5bWJvbFBhdGguc3R5bGUub3BhY2l0eVxuICAgIH0pO1xuICAgIHN5bWJvbFBhdGguc2NhbGUgPSBbMCwgMF07XG4gICAgZmFkZUluICYmIChzeW1ib2xQYXRoLnN0eWxlLm9wYWNpdHkgPSAwKTtcbiAgICBncmFwaGljLmluaXRQcm9wcyhzeW1ib2xQYXRoLCB0YXJnZXQsIHNlcmllc01vZGVsLCBpZHgpO1xuICB9XG5cbiAgdGhpcy5fc2VyaWVzTW9kZWwgPSBzZXJpZXNNb2RlbDtcbn07IC8vIFVwZGF0ZSBjb21tb24gcHJvcGVydGllc1xuXG5cbnZhciBub3JtYWxTdHlsZUFjY2Vzc1BhdGggPSBbJ2l0ZW1TdHlsZSddO1xudmFyIGVtcGhhc2lzU3R5bGVBY2Nlc3NQYXRoID0gWydlbXBoYXNpcycsICdpdGVtU3R5bGUnXTtcbnZhciBub3JtYWxMYWJlbEFjY2Vzc1BhdGggPSBbJ2xhYmVsJ107XG52YXIgZW1waGFzaXNMYWJlbEFjY2Vzc1BhdGggPSBbJ2VtcGhhc2lzJywgJ2xhYmVsJ107XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBzeW1ib2xTaXplXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlXVxuICovXG5cbnN5bWJvbFByb3RvLl91cGRhdGVDb21tb24gPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBzZXJpZXNTY29wZSkge1xuICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpOyAvLyBSZXNldCBzdHlsZVxuXG4gIGlmIChzeW1ib2xQYXRoLnR5cGUgIT09ICdpbWFnZScpIHtcbiAgICBzeW1ib2xQYXRoLnVzZVN0eWxlKHtcbiAgICAgIHN0cm9rZU5vU2NhbGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBpdGVtU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5pdGVtU3R5bGU7XG4gIHZhciBob3Zlckl0ZW1TdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVySXRlbVN0eWxlO1xuICB2YXIgc3ltYm9sUm90YXRlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuc3ltYm9sUm90YXRlO1xuICB2YXIgc3ltYm9sT2Zmc2V0ID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuc3ltYm9sT2Zmc2V0O1xuICB2YXIgbGFiZWxNb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmxhYmVsTW9kZWw7XG4gIHZhciBob3ZlckxhYmVsTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5ob3ZlckxhYmVsTW9kZWw7XG4gIHZhciBob3ZlckFuaW1hdGlvbiA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVyQW5pbWF0aW9uO1xuICB2YXIgY3Vyc29yU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5jdXJzb3JTdHlsZTtcblxuICBpZiAoIXNlcmllc1Njb3BlIHx8IGRhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgIHZhciBpdGVtTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5pdGVtTW9kZWwgPyBzZXJpZXNTY29wZS5pdGVtTW9kZWwgOiBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpOyAvLyBDb2xvciBtdXN0IGJlIGV4Y2x1ZGVkLlxuICAgIC8vIEJlY2F1c2Ugc3ltYm9sIHByb3ZpZGUgc2V0Q29sb3IgaW5kaXZpZHVhbGx5IHRvIHNldCBmaWxsIGFuZCBzdHJva2VcblxuICAgIGl0ZW1TdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChub3JtYWxTdHlsZUFjY2Vzc1BhdGgpLmdldEl0ZW1TdHlsZShbJ2NvbG9yJ10pO1xuICAgIGhvdmVySXRlbVN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKGVtcGhhc2lzU3R5bGVBY2Nlc3NQYXRoKS5nZXRJdGVtU3R5bGUoKTtcbiAgICBzeW1ib2xSb3RhdGUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sUm90YXRlJyk7XG4gICAgc3ltYm9sT2Zmc2V0ID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbE9mZnNldCcpO1xuICAgIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwobm9ybWFsTGFiZWxBY2Nlc3NQYXRoKTtcbiAgICBob3ZlckxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoZW1waGFzaXNMYWJlbEFjY2Vzc1BhdGgpO1xuICAgIGhvdmVyQW5pbWF0aW9uID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2hvdmVyQW5pbWF0aW9uJyk7XG4gICAgY3Vyc29yU3R5bGUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnY3Vyc29yJyk7XG4gIH0gZWxzZSB7XG4gICAgaG92ZXJJdGVtU3R5bGUgPSB6clV0aWwuZXh0ZW5kKHt9LCBob3Zlckl0ZW1TdHlsZSk7XG4gIH1cblxuICB2YXIgZWxTdHlsZSA9IHN5bWJvbFBhdGguc3R5bGU7XG4gIHN5bWJvbFBhdGguYXR0cigncm90YXRpb24nLCAoc3ltYm9sUm90YXRlIHx8IDApICogTWF0aC5QSSAvIDE4MCB8fCAwKTtcblxuICBpZiAoc3ltYm9sT2Zmc2V0KSB7XG4gICAgc3ltYm9sUGF0aC5hdHRyKCdwb3NpdGlvbicsIFtwYXJzZVBlcmNlbnQoc3ltYm9sT2Zmc2V0WzBdLCBzeW1ib2xTaXplWzBdKSwgcGFyc2VQZXJjZW50KHN5bWJvbE9mZnNldFsxXSwgc3ltYm9sU2l6ZVsxXSldKTtcbiAgfVxuXG4gIGN1cnNvclN0eWxlICYmIHN5bWJvbFBhdGguYXR0cignY3Vyc29yJywgY3Vyc29yU3R5bGUpOyAvLyBQRU5ESU5HIHNldENvbG9yIGJlZm9yZSBzZXRTdHlsZSEhIVxuXG4gIHN5bWJvbFBhdGguc2V0Q29sb3IoY29sb3IsIHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLnN5bWJvbElubmVyQ29sb3IpO1xuICBzeW1ib2xQYXRoLnNldFN0eWxlKGl0ZW1TdHlsZSk7XG4gIHZhciBvcGFjaXR5ID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ29wYWNpdHknKTtcblxuICBpZiAob3BhY2l0eSAhPSBudWxsKSB7XG4gICAgZWxTdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgfVxuXG4gIHZhciBsaWZ0WiA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdsaWZ0WicpO1xuICB2YXIgejJPcmlnaW4gPSBzeW1ib2xQYXRoLl9fejJPcmlnaW47XG5cbiAgaWYgKGxpZnRaICE9IG51bGwpIHtcbiAgICBpZiAoejJPcmlnaW4gPT0gbnVsbCkge1xuICAgICAgc3ltYm9sUGF0aC5fX3oyT3JpZ2luID0gc3ltYm9sUGF0aC56MjtcbiAgICAgIHN5bWJvbFBhdGguejIgKz0gbGlmdFo7XG4gICAgfVxuICB9IGVsc2UgaWYgKHoyT3JpZ2luICE9IG51bGwpIHtcbiAgICBzeW1ib2xQYXRoLnoyID0gejJPcmlnaW47XG4gICAgc3ltYm9sUGF0aC5fX3oyT3JpZ2luID0gbnVsbDtcbiAgfVxuXG4gIHZhciB1c2VOYW1lTGFiZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS51c2VOYW1lTGFiZWw7XG4gIGdyYXBoaWMuc2V0TGFiZWxTdHlsZShlbFN0eWxlLCBob3Zlckl0ZW1TdHlsZSwgbGFiZWxNb2RlbCwgaG92ZXJMYWJlbE1vZGVsLCB7XG4gICAgbGFiZWxGZXRjaGVyOiBzZXJpZXNNb2RlbCxcbiAgICBsYWJlbERhdGFJbmRleDogaWR4LFxuICAgIGRlZmF1bHRUZXh0OiBnZXRMYWJlbERlZmF1bHRUZXh0LFxuICAgIGlzUmVjdFRleHQ6IHRydWUsXG4gICAgYXV0b0NvbG9yOiBjb2xvclxuICB9KTsgLy8gRG8gbm90IGV4ZWN1dGUgdXRpbCBuZWVkZWQuXG5cbiAgZnVuY3Rpb24gZ2V0TGFiZWxEZWZhdWx0VGV4dChpZHgsIG9wdCkge1xuICAgIHJldHVybiB1c2VOYW1lTGFiZWwgPyBkYXRhLmdldE5hbWUoaWR4KSA6IGdldERlZmF1bHRMYWJlbChkYXRhLCBpZHgpO1xuICB9XG5cbiAgc3ltYm9sUGF0aC5vZmYoJ21vdXNlb3ZlcicpLm9mZignbW91c2VvdXQnKS5vZmYoJ2VtcGhhc2lzJykub2ZmKCdub3JtYWwnKTtcbiAgc3ltYm9sUGF0aC5ob3ZlclN0eWxlID0gaG92ZXJJdGVtU3R5bGU7IC8vIEZJWE1FXG4gIC8vIERvIG5vdCB1c2Ugc3ltYm9sLnRyaWdnZXIoJ2VtcGhhc2lzJyksIGJ1dCB1c2Ugc3ltYm9sLmhpZ2hsaWdodCgpIGluc3RlYWQuXG5cbiAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHN5bWJvbFBhdGgpO1xuICB2YXIgc2NhbGUgPSBnZXRTY2FsZShzeW1ib2xTaXplKTtcblxuICBpZiAoaG92ZXJBbmltYXRpb24gJiYgc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCkpIHtcbiAgICB2YXIgb25FbXBoYXNpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIERvIG5vdCBzdXBwb3J0IHRoaXMgaG92ZXIgYW5pbWF0aW9uIHV0aWwgc29tZSBzY2VuYXJpbyByZXF1aXJlZC5cbiAgICAgIC8vIEFuaW1hdGlvbiBjYW4gb25seSBiZSBzdXBwb3J0ZWQgaW4gaG92ZXIgbGF5ZXIgd2hlbiB1c2luZyBgZWwuaW5jcmVtZXRhbGAuXG4gICAgICBpZiAodGhpcy5pbmNyZW1lbnRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByYXRpbyA9IHNjYWxlWzFdIC8gc2NhbGVbMF07XG4gICAgICB0aGlzLmFuaW1hdGVUbyh7XG4gICAgICAgIHNjYWxlOiBbTWF0aC5tYXgoc2NhbGVbMF0gKiAxLjEsIHNjYWxlWzBdICsgMyksIE1hdGgubWF4KHNjYWxlWzFdICogMS4xLCBzY2FsZVsxXSArIDMgKiByYXRpbyldXG4gICAgICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XG4gICAgfTtcblxuICAgIHZhciBvbk5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hbmltYXRlVG8oe1xuICAgICAgICBzY2FsZTogc2NhbGVcbiAgICAgIH0sIDQwMCwgJ2VsYXN0aWNPdXQnKTtcbiAgICB9O1xuXG4gICAgc3ltYm9sUGF0aC5vbignbW91c2VvdmVyJywgb25FbXBoYXNpcykub24oJ21vdXNlb3V0Jywgb25Ob3JtYWwpLm9uKCdlbXBoYXNpcycsIG9uRW1waGFzaXMpLm9uKCdub3JtYWwnLCBvbk5vcm1hbCk7XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0LmtlZXBMYWJlbD10cnVlXVxuICovXG5cblxuc3ltYm9sUHJvdG8uZmFkZU91dCA9IGZ1bmN0aW9uIChjYiwgb3B0KSB7XG4gIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApOyAvLyBBdm9pZCBtaXN0YWtlbiBob3ZlciB3aGVuIGZhZGluZyBvdXRcblxuICB0aGlzLnNpbGVudCA9IHN5bWJvbFBhdGguc2lsZW50ID0gdHJ1ZTsgLy8gTm90IHNob3cgdGV4dCB3aGVuIGFuaW1hdGluZ1xuXG4gICEob3B0ICYmIG9wdC5rZWVwTGFiZWwpICYmIChzeW1ib2xQYXRoLnN0eWxlLnRleHQgPSBudWxsKTtcbiAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xQYXRoLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LFxuICAgIHNjYWxlOiBbMCwgMF1cbiAgfSwgdGhpcy5fc2VyaWVzTW9kZWwsIHRoaXMuZGF0YUluZGV4LCBjYik7XG59O1xuXG56clV0aWwuaW5oZXJpdHMoU3ltYm9sQ2x6LCBncmFwaGljLkdyb3VwKTtcbnZhciBfZGVmYXVsdCA9IFN5bWJvbENsejtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL1N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL1N5bWJvbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIFN5bWJvbENseiA9IHJlcXVpcmUoXCIuL1N5bWJvbFwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGlzT2JqZWN0ID0gX3V0aWwuaXNPYmplY3Q7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbERyYXdcbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9IFtzeW1ib2xDdG9yXVxuICovXG5mdW5jdGlvbiBTeW1ib2xEcmF3KHN5bWJvbEN0b3IpIHtcbiAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gIHRoaXMuX3N5bWJvbEN0b3IgPSBzeW1ib2xDdG9yIHx8IFN5bWJvbENsejtcbn1cblxudmFyIHN5bWJvbERyYXdQcm90byA9IFN5bWJvbERyYXcucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBzeW1ib2xOZWVkc0RyYXcoZGF0YSwgcG9pbnQsIGlkeCwgb3B0KSB7XG4gIHJldHVybiBwb2ludCAmJiAhaXNOYU4ocG9pbnRbMF0pICYmICFpc05hTihwb2ludFsxXSkgJiYgIShvcHQuaXNJZ25vcmUgJiYgb3B0LmlzSWdub3JlKGlkeCkpIC8vIFdlIGRvIG5vdCBzZXQgY2xpcFNoYXBlIG9uIGdyb3VwLCBiZWNhdXNlIGl0IHdpbGwgY3V0IHBhcnQgb2ZcbiAgLy8gdGhlIHN5bWJvbCBlbGVtZW50IHNoYXBlLiBXZSB1c2UgdGhlIHNhbWUgY2xpcCBzaGFwZSBoZXJlIGFzXG4gIC8vIHRoZSBsaW5lIGNsaXAuXG4gICYmICEob3B0LmNsaXBTaGFwZSAmJiAhb3B0LmNsaXBTaGFwZS5jb250YWluKHBvaW50WzBdLCBwb2ludFsxXSkpICYmIGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSAhPT0gJ25vbmUnO1xufVxuLyoqXG4gKiBVcGRhdGUgc3ltYm9scyBkcmF3IGJ5IG5ldyBkYXRhXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRdIE9yIGlzSWdub3JlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0LmlzSWdub3JlXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQuY2xpcFNoYXBlXVxuICovXG5cblxuc3ltYm9sRHJhd1Byb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgb3B0KSB7XG4gIG9wdCA9IG5vcm1hbGl6ZVVwZGF0ZU9wdChvcHQpO1xuICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICB2YXIgU3ltYm9sQ3RvciA9IHRoaXMuX3N5bWJvbEN0b3I7XG4gIHZhciBzZXJpZXNTY29wZSA9IG1ha2VTZXJpZXNTY29wZShkYXRhKTsgLy8gVGhlcmUgaXMgbm8gb2xkTGluZURhdGEgb25seSB3aGVuIGZpcnN0IHJlbmRlcmluZyBvciBzd2l0Y2hpbmcgZnJvbVxuICAvLyBzdHJlYW0gbW9kZSB0byBub3JtYWwgbW9kZSwgd2hlcmUgcHJldmlvdXMgZWxlbWVudHMgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbiAgaWYgKCFvbGREYXRhKSB7XG4gICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH1cblxuICBkYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChuZXdJZHgpIHtcbiAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcblxuICAgIGlmIChzeW1ib2xOZWVkc0RyYXcoZGF0YSwgcG9pbnQsIG5ld0lkeCwgb3B0KSkge1xuICAgICAgdmFyIHN5bWJvbEVsID0gbmV3IFN5bWJvbEN0b3IoZGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgICBzeW1ib2xFbC5hdHRyKCdwb3NpdGlvbicsIHBvaW50KTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHN5bWJvbEVsKTtcbiAgICAgIGdyb3VwLmFkZChzeW1ib2xFbCk7XG4gICAgfVxuICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgdmFyIHN5bWJvbEVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgdmFyIHBvaW50ID0gZGF0YS5nZXRJdGVtTGF5b3V0KG5ld0lkeCk7XG5cbiAgICBpZiAoIXN5bWJvbE5lZWRzRHJhdyhkYXRhLCBwb2ludCwgbmV3SWR4LCBvcHQpKSB7XG4gICAgICBncm91cC5yZW1vdmUoc3ltYm9sRWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghc3ltYm9sRWwpIHtcbiAgICAgIHN5bWJvbEVsID0gbmV3IFN5bWJvbEN0b3IoZGF0YSwgbmV3SWR4KTtcbiAgICAgIHN5bWJvbEVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzeW1ib2xFbC51cGRhdGVEYXRhKGRhdGEsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xFbCwge1xuICAgICAgICBwb3NpdGlvbjogcG9pbnRcbiAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICB9IC8vIEFkZCBiYWNrXG5cblxuICAgIGdyb3VwLmFkZChzeW1ib2xFbCk7XG4gICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgc3ltYm9sRWwpO1xuICB9KS5yZW1vdmUoZnVuY3Rpb24gKG9sZElkeCkge1xuICAgIHZhciBlbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgIGVsICYmIGVsLmZhZGVPdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICB9KTtcbiAgfSkuZXhlY3V0ZSgpO1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbn07XG5cbnN5bWJvbERyYXdQcm90by5pc1BlcnNpc3RlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxuc3ltYm9sRHJhd1Byb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gIGlmIChkYXRhKSB7XG4gICAgLy8gTm90IHVzZSBhbmltYXRpb25cbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgIGVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9pbnQpO1xuICAgIH0pO1xuICB9XG59O1xuXG5zeW1ib2xEcmF3UHJvdG8uaW5jcmVtZW50YWxQcmVwYXJlVXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fc2VyaWVzU2NvcGUgPSBtYWtlU2VyaWVzU2NvcGUoZGF0YSk7XG4gIHRoaXMuX2RhdGEgPSBudWxsO1xuICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xufTtcbi8qKlxuICogVXBkYXRlIHN5bWJvbHMgZHJhdyBieSBuZXcgZGF0YVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XSBPciBpc0lnbm9yZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdC5pc0lnbm9yZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0LmNsaXBTaGFwZV1cbiAqL1xuXG5cbnN5bWJvbERyYXdQcm90by5pbmNyZW1lbnRhbFVwZGF0ZSA9IGZ1bmN0aW9uICh0YXNrUGFyYW1zLCBkYXRhLCBvcHQpIHtcbiAgb3B0ID0gbm9ybWFsaXplVXBkYXRlT3B0KG9wdCk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlSW5jcmVtZW50YWxBbmRIb3ZlcihlbCkge1xuICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgZWwuaW5jcmVtZW50YWwgPSBlbC51c2VIb3ZlckxheWVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpZHggPSB0YXNrUGFyYW1zLnN0YXJ0OyBpZHggPCB0YXNrUGFyYW1zLmVuZDsgaWR4KyspIHtcbiAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcblxuICAgIGlmIChzeW1ib2xOZWVkc0RyYXcoZGF0YSwgcG9pbnQsIGlkeCwgb3B0KSkge1xuICAgICAgdmFyIGVsID0gbmV3IHRoaXMuX3N5bWJvbEN0b3IoZGF0YSwgaWR4LCB0aGlzLl9zZXJpZXNTY29wZSk7XG4gICAgICBlbC50cmF2ZXJzZSh1cGRhdGVJbmNyZW1lbnRhbEFuZEhvdmVyKTtcbiAgICAgIGVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9pbnQpO1xuICAgICAgdGhpcy5ncm91cC5hZGQoZWwpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgZWwpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplVXBkYXRlT3B0KG9wdCkge1xuICBpZiAob3B0ICE9IG51bGwgJiYgIWlzT2JqZWN0KG9wdCkpIHtcbiAgICBvcHQgPSB7XG4gICAgICBpc0lnbm9yZTogb3B0XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBvcHQgfHwge307XG59XG5cbnN5bWJvbERyYXdQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZW5hYmxlQW5pbWF0aW9uKSB7XG4gIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YTsgLy8gSW5jcmVtZW50YWwgbW9kZWwgZG8gbm90IGhhdmUgdGhpcy5fZGF0YS5cblxuICBpZiAoZGF0YSAmJiBlbmFibGVBbmltYXRpb24pIHtcbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwuZmFkZU91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gbWFrZVNlcmllc1Njb3BlKGRhdGEpIHtcbiAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gIHJldHVybiB7XG4gICAgaXRlbVN0eWxlOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJykuZ2V0SXRlbVN0eWxlKFsnY29sb3InXSksXG4gICAgaG92ZXJJdGVtU3R5bGU6IHNlcmllc01vZGVsLmdldE1vZGVsKCdlbXBoYXNpcy5pdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKSxcbiAgICBzeW1ib2xSb3RhdGU6IHNlcmllc01vZGVsLmdldCgnc3ltYm9sUm90YXRlJyksXG4gICAgc3ltYm9sT2Zmc2V0OiBzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbE9mZnNldCcpLFxuICAgIGhvdmVyQW5pbWF0aW9uOiBzZXJpZXNNb2RlbC5nZXQoJ2hvdmVyQW5pbWF0aW9uJyksXG4gICAgbGFiZWxNb2RlbDogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsJyksXG4gICAgaG92ZXJMYWJlbE1vZGVsOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMubGFiZWwnKSxcbiAgICBjdXJzb3JTdHlsZTogc2VyaWVzTW9kZWwuZ2V0KCdjdXJzb3InKVxuICB9O1xufVxuXG52YXIgX2RlZmF1bHQgPSBTeW1ib2xEcmF3O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvU3ltYm9sRHJhdy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL1N5bWJvbERyYXcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIExpc3QgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9MaXN0XCIpO1xuXG52YXIgY3JlYXRlRGltZW5zaW9ucyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL2hlbHBlci9jcmVhdGVEaW1lbnNpb25zXCIpO1xuXG52YXIgX3NvdXJjZVR5cGUgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9oZWxwZXIvc291cmNlVHlwZVwiKTtcblxudmFyIFNPVVJDRV9GT1JNQVRfT1JJR0lOQUwgPSBfc291cmNlVHlwZS5TT1VSQ0VfRk9STUFUX09SSUdJTkFMO1xuXG52YXIgX2RpbWVuc2lvbkhlbHBlciA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL2hlbHBlci9kaW1lbnNpb25IZWxwZXJcIik7XG5cbnZhciBnZXREaW1lbnNpb25UeXBlQnlBeGlzID0gX2RpbWVuc2lvbkhlbHBlci5nZXREaW1lbnNpb25UeXBlQnlBeGlzO1xuXG52YXIgX21vZGVsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBnZXREYXRhSXRlbVZhbHVlID0gX21vZGVsLmdldERhdGFJdGVtVmFsdWU7XG5cbnZhciBDb29yZGluYXRlU3lzdGVtID0gcmVxdWlyZShcIi4uLy4uL0Nvb3JkaW5hdGVTeXN0ZW1cIik7XG5cbnZhciBfcmVmZXJIZWxwZXIgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvcmVmZXJIZWxwZXJcIik7XG5cbnZhciBnZXRDb29yZFN5c0RlZmluZUJ5U2VyaWVzID0gX3JlZmVySGVscGVyLmdldENvb3JkU3lzRGVmaW5lQnlTZXJpZXM7XG5cbnZhciBTb3VyY2UgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9Tb3VyY2VcIik7XG5cbnZhciBfZGF0YVN0YWNrSGVscGVyID0gcmVxdWlyZShcIi4uLy4uL2RhdGEvaGVscGVyL2RhdGFTdGFja0hlbHBlclwiKTtcblxudmFyIGVuYWJsZURhdGFTdGFjayA9IF9kYXRhU3RhY2tIZWxwZXIuZW5hYmxlRGF0YVN0YWNrO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL1NvdXJjZXxBcnJheX0gc291cmNlIE9yIHJhdyBkYXRhLlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmdlbmVyYXRlQ29vcmRdXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RGcm9tQXJyYXkoc291cmNlLCBzZXJpZXNNb2RlbCwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICBpZiAoIVNvdXJjZS5pc0luc3RhbmNlKHNvdXJjZSkpIHtcbiAgICBzb3VyY2UgPSBTb3VyY2Uuc2VyaWVzRGF0YVRvU291cmNlKHNvdXJjZSk7XG4gIH1cblxuICB2YXIgY29vcmRTeXNOYW1lID0gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJyk7XG4gIHZhciByZWdpc3RlcmVkQ29vcmRTeXMgPSBDb29yZGluYXRlU3lzdGVtLmdldChjb29yZFN5c05hbWUpO1xuICB2YXIgY29vcmRTeXNEZWZpbmUgPSBnZXRDb29yZFN5c0RlZmluZUJ5U2VyaWVzKHNlcmllc01vZGVsKTtcbiAgdmFyIGNvb3JkU3lzRGltRGVmcztcblxuICBpZiAoY29vcmRTeXNEZWZpbmUpIHtcbiAgICBjb29yZFN5c0RpbURlZnMgPSB6clV0aWwubWFwKGNvb3JkU3lzRGVmaW5lLmNvb3JkU3lzRGltcywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgdmFyIGRpbUluZm8gPSB7XG4gICAgICAgIG5hbWU6IGRpbVxuICAgICAgfTtcbiAgICAgIHZhciBheGlzTW9kZWwgPSBjb29yZFN5c0RlZmluZS5heGlzTWFwLmdldChkaW0pO1xuXG4gICAgICBpZiAoYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciBheGlzVHlwZSA9IGF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgZGltSW5mby50eXBlID0gZ2V0RGltZW5zaW9uVHlwZUJ5QXhpcyhheGlzVHlwZSk7IC8vIGRpbUluZm8uc3RhY2thYmxlID0gaXNTdGFja2FibGUoYXhpc1R5cGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGltSW5mbztcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghY29vcmRTeXNEaW1EZWZzKSB7XG4gICAgLy8gR2V0IGRpbWVuc2lvbnMgZnJvbSByZWdpc3RlcmVkIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgY29vcmRTeXNEaW1EZWZzID0gcmVnaXN0ZXJlZENvb3JkU3lzICYmIChyZWdpc3RlcmVkQ29vcmRTeXMuZ2V0RGltZW5zaW9uc0luZm8gPyByZWdpc3RlcmVkQ29vcmRTeXMuZ2V0RGltZW5zaW9uc0luZm8oKSA6IHJlZ2lzdGVyZWRDb29yZFN5cy5kaW1lbnNpb25zLnNsaWNlKCkpIHx8IFsneCcsICd5J107XG4gIH1cblxuICB2YXIgZGltSW5mb0xpc3QgPSBjcmVhdGVEaW1lbnNpb25zKHNvdXJjZSwge1xuICAgIGNvb3JkRGltZW5zaW9uczogY29vcmRTeXNEaW1EZWZzLFxuICAgIGdlbmVyYXRlQ29vcmQ6IG9wdC5nZW5lcmF0ZUNvb3JkXG4gIH0pO1xuICB2YXIgZmlyc3RDYXRlZ29yeURpbUluZGV4O1xuICB2YXIgaGFzTmFtZUVuY29kZTtcbiAgY29vcmRTeXNEZWZpbmUgJiYgenJVdGlsLmVhY2goZGltSW5mb0xpc3QsIGZ1bmN0aW9uIChkaW1JbmZvLCBkaW1JbmRleCkge1xuICAgIHZhciBjb29yZERpbSA9IGRpbUluZm8uY29vcmREaW07XG4gICAgdmFyIGNhdGVnb3J5QXhpc01vZGVsID0gY29vcmRTeXNEZWZpbmUuY2F0ZWdvcnlBeGlzTWFwLmdldChjb29yZERpbSk7XG5cbiAgICBpZiAoY2F0ZWdvcnlBeGlzTW9kZWwpIHtcbiAgICAgIGlmIChmaXJzdENhdGVnb3J5RGltSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBmaXJzdENhdGVnb3J5RGltSW5kZXggPSBkaW1JbmRleDtcbiAgICAgIH1cblxuICAgICAgZGltSW5mby5vcmRpbmFsTWV0YSA9IGNhdGVnb3J5QXhpc01vZGVsLmdldE9yZGluYWxNZXRhKCk7XG4gICAgfVxuXG4gICAgaWYgKGRpbUluZm8ub3RoZXJEaW1zLml0ZW1OYW1lICE9IG51bGwpIHtcbiAgICAgIGhhc05hbWVFbmNvZGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCFoYXNOYW1lRW5jb2RlICYmIGZpcnN0Q2F0ZWdvcnlEaW1JbmRleCAhPSBudWxsKSB7XG4gICAgZGltSW5mb0xpc3RbZmlyc3RDYXRlZ29yeURpbUluZGV4XS5vdGhlckRpbXMuaXRlbU5hbWUgPSAwO1xuICB9XG5cbiAgdmFyIHN0YWNrQ2FsY3VsYXRpb25JbmZvID0gZW5hYmxlRGF0YVN0YWNrKHNlcmllc01vZGVsLCBkaW1JbmZvTGlzdCk7XG4gIHZhciBsaXN0ID0gbmV3IExpc3QoZGltSW5mb0xpc3QsIHNlcmllc01vZGVsKTtcbiAgbGlzdC5zZXRDYWxjdWxhdGlvbkluZm8oc3RhY2tDYWxjdWxhdGlvbkluZm8pO1xuICB2YXIgZGltVmFsdWVHZXR0ZXIgPSBmaXJzdENhdGVnb3J5RGltSW5kZXggIT0gbnVsbCAmJiBpc05lZWRDb21wbGV0ZU9yZGluYWxEYXRhKHNvdXJjZSkgPyBmdW5jdGlvbiAoaXRlbU9wdCwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgIC8vIFVzZSBkYXRhSW5kZXggYXMgb3JkaW5hbCB2YWx1ZSBpbiBjYXRlZ29yeUF4aXNcbiAgICByZXR1cm4gZGltSW5kZXggPT09IGZpcnN0Q2F0ZWdvcnlEaW1JbmRleCA/IGRhdGFJbmRleCA6IHRoaXMuZGVmYXVsdERpbVZhbHVlR2V0dGVyKGl0ZW1PcHQsIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpO1xuICB9IDogbnVsbDtcbiAgbGlzdC5oYXNJdGVtT3B0aW9uID0gZmFsc2U7XG4gIGxpc3QuaW5pdERhdGEoc291cmNlLCBudWxsLCBkaW1WYWx1ZUdldHRlcik7XG4gIHJldHVybiBsaXN0O1xufVxuXG5mdW5jdGlvbiBpc05lZWRDb21wbGV0ZU9yZGluYWxEYXRhKHNvdXJjZSkge1xuICBpZiAoc291cmNlLnNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9PUklHSU5BTCkge1xuICAgIHZhciBzYW1wbGVJdGVtID0gZmlyc3REYXRhTm90TnVsbChzb3VyY2UuZGF0YSB8fCBbXSk7XG4gICAgcmV0dXJuIHNhbXBsZUl0ZW0gIT0gbnVsbCAmJiAhenJVdGlsLmlzQXJyYXkoZ2V0RGF0YUl0ZW1WYWx1ZShzYW1wbGVJdGVtKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlyc3REYXRhTm90TnVsbChkYXRhKSB7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoICYmIGRhdGFbaV0gPT0gbnVsbCkge1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBkYXRhW2ldO1xufVxuXG52YXIgX2RlZmF1bHQgPSBjcmVhdGVMaXN0RnJvbUFycmF5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX21vZGVsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBtYWtlSW5uZXIgPSBfbW9kZWwubWFrZUlubmVyO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBJZiBsYXJnZSBtb2RlIGNoYW5nZWQsIHJldHVybiBzdHJpbmcgJ3Jlc2V0JztcbiAqL1xuZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gIHZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xuICByZXR1cm4gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGZpZWxkcyA9IGlubmVyKHNlcmllc01vZGVsKTtcbiAgICB2YXIgcGlwZWxpbmVDb250ZXh0ID0gc2VyaWVzTW9kZWwucGlwZWxpbmVDb250ZXh0O1xuICAgIHZhciBvcmlnaW5hbExhcmdlID0gZmllbGRzLmxhcmdlO1xuICAgIHZhciBvcmlnaW5hbFByb2dyZXNzaXZlID0gZmllbGRzLnByb2dyZXNzaXZlUmVuZGVyO1xuICAgIHZhciBsYXJnZSA9IGZpZWxkcy5sYXJnZSA9IHBpcGVsaW5lQ29udGV4dC5sYXJnZTtcbiAgICB2YXIgcHJvZ3Jlc3NpdmUgPSBmaWVsZHMucHJvZ3Jlc3NpdmVSZW5kZXIgPSBwaXBlbGluZUNvbnRleHQucHJvZ3Jlc3NpdmVSZW5kZXI7XG4gICAgcmV0dXJuICEhKG9yaWdpbmFsTGFyZ2UgXiBsYXJnZSB8fCBvcmlnaW5hbFByb2dyZXNzaXZlIF4gcHJvZ3Jlc3NpdmUpICYmICdyZXNldCc7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2NyZWF0ZVJlbmRlclBsYW5uZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9jcmVhdGVSZW5kZXJQbGFubmVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9kYXRhUHJvdmlkZXIgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9oZWxwZXIvZGF0YVByb3ZpZGVyXCIpO1xuXG52YXIgcmV0cmlldmVSYXdWYWx1ZSA9IF9kYXRhUHJvdmlkZXIucmV0cmlldmVSYXdWYWx1ZTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gKiBAcmV0dXJuIHtzdHJpbmd9IGxhYmVsIHN0cmluZy4gTm90IG51bGwvdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRMYWJlbChkYXRhLCBkYXRhSW5kZXgpIHtcbiAgdmFyIGxhYmVsRGltcyA9IGRhdGEubWFwRGltZW5zaW9uKCdkZWZhdWx0ZWRMYWJlbCcsIHRydWUpO1xuICB2YXIgbGVuID0gbGFiZWxEaW1zLmxlbmd0aDsgLy8gU2ltcGxlIG9wdGltaXphdGlvbiAoaW4gbG90cyBvZiBjYXNlcywgbGFiZWwgZGltcyBsZW5ndGggaXMgMSlcblxuICBpZiAobGVuID09PSAxKSB7XG4gICAgcmV0dXJuIHJldHJpZXZlUmF3VmFsdWUoZGF0YSwgZGF0YUluZGV4LCBsYWJlbERpbXNbMF0pO1xuICB9IGVsc2UgaWYgKGxlbikge1xuICAgIHZhciB2YWxzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsRGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbCA9IHJldHJpZXZlUmF3VmFsdWUoZGF0YSwgZGF0YUluZGV4LCBsYWJlbERpbXNbaV0pO1xuICAgICAgdmFscy5wdXNoKHZhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHMuam9pbignICcpO1xuICB9XG59XG5cbmV4cG9ydHMuZ2V0RGVmYXVsdExhYmVsID0gZ2V0RGVmYXVsdExhYmVsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9sYWJlbEhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2xhYmVsSGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxucmVxdWlyZShcIi4vbGluZS9MaW5lU2VyaWVzXCIpO1xuXG5yZXF1aXJlKFwiLi9saW5lL0xpbmVWaWV3XCIpO1xuXG52YXIgdmlzdWFsU3ltYm9sID0gcmVxdWlyZShcIi4uL3Zpc3VhbC9zeW1ib2xcIik7XG5cbnZhciBsYXlvdXRQb2ludHMgPSByZXF1aXJlKFwiLi4vbGF5b3V0L3BvaW50c1wiKTtcblxudmFyIGRhdGFTYW1wbGUgPSByZXF1aXJlKFwiLi4vcHJvY2Vzc29yL2RhdGFTYW1wbGVcIik7XG5cbnJlcXVpcmUoXCIuLi9jb21wb25lbnQvZ3JpZFNpbXBsZVwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gSW4gY2FzZSBkZXZlbG9wZXIgZm9yZ2V0IHRvIGluY2x1ZGUgZ3JpZCBjb21wb25lbnRcbmVjaGFydHMucmVnaXN0ZXJWaXN1YWwodmlzdWFsU3ltYm9sKCdsaW5lJywgJ2NpcmNsZScsICdsaW5lJykpO1xuZWNoYXJ0cy5yZWdpc3RlckxheW91dChsYXlvdXRQb2ludHMoJ2xpbmUnKSk7IC8vIERvd24gc2FtcGxlIGFmdGVyIGZpbHRlclxuXG5lY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKGVjaGFydHMuUFJJT1JJVFkuUFJPQ0VTU09SLlNUQVRJU1RJQywgZGF0YVNhbXBsZSgnbGluZScpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKFwiLi4vaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXlcIik7XG5cbnZhciBTZXJpZXNNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9TZXJpZXNcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBfZGVmYXVsdCA9IFNlcmllc01vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdzZXJpZXMubGluZScsXG4gIGRlcGVuZGVuY2llczogWydncmlkJywgJ3BvbGFyJ10sXG4gIGdldEluaXRpYWxEYXRhOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkodGhpcy5nZXRTb3VyY2UoKSwgdGhpcyk7XG4gIH0sXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBjb29yZGluYXRlU3lzdGVtOiAnY2FydGVzaWFuMmQnLFxuICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICBob3ZlckFuaW1hdGlvbjogdHJ1ZSxcbiAgICAvLyBzdGFjazogbnVsbFxuICAgIC8vIHhBeGlzSW5kZXg6IDAsXG4gICAgLy8geUF4aXNJbmRleDogMCxcbiAgICAvLyBwb2xhckluZGV4OiAwLFxuICAgIC8vIElmIGNsaXAgdGhlIG92ZXJmbG93IHZhbHVlXG4gICAgY2xpcE92ZXJmbG93OiB0cnVlLFxuICAgIC8vIGN1cnNvcjogbnVsbCxcbiAgICBsYWJlbDoge1xuICAgICAgcG9zaXRpb246ICd0b3AnXG4gICAgfSxcbiAgICAvLyBpdGVtU3R5bGU6IHtcbiAgICAvLyB9LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgd2lkdGg6IDIsXG4gICAgICB0eXBlOiAnc29saWQnXG4gICAgfSxcbiAgICAvLyBhcmVhU3R5bGU6IHtcbiAgICAvLyBvcmlnaW4gb2YgYXJlYVN0eWxlLiBWYWxpZCB2YWx1ZXM6XG4gICAgLy8gYCdhdXRvJy9udWxsL3VuZGVmaW5lZGA6IGZyb20gYXhpc0xpbmUgdG8gZGF0YVxuICAgIC8vIGAnc3RhcnQnYDogZnJvbSBtaW4gdG8gZGF0YVxuICAgIC8vIGAnZW5kJ2A6IGZyb20gZGF0YSB0byBtYXhcbiAgICAvLyBvcmlnaW46ICdhdXRvJ1xuICAgIC8vIH0sXG4gICAgLy8gZmFsc2UsICdzdGFydCcsICdlbmQnLCAnbWlkZGxlJ1xuICAgIHN0ZXA6IGZhbHNlLFxuICAgIC8vIERpc2FibGVkIGlmIHN0ZXAgaXMgdHJ1ZVxuICAgIHNtb290aDogZmFsc2UsXG4gICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG4gICAgc3ltYm9sOiAnZW1wdHlDaXJjbGUnLFxuICAgIHN5bWJvbFNpemU6IDQsXG4gICAgc3ltYm9sUm90YXRlOiBudWxsLFxuICAgIHNob3dTeW1ib2w6IHRydWUsXG4gICAgLy8gYGZhbHNlYDogZm9sbG93IHRoZSBsYWJlbCBpbnRlcnZhbCBzdHJhdGVneS5cbiAgICAvLyBgdHJ1ZWA6IHNob3cgYWxsIHN5bWJvbHMuXG4gICAgLy8gYCdhdXRvJ2A6IElmIHBvc3NpYmxlLCBzaG93IGFsbCBzeW1ib2xzLCBvdGhlcndpc2VcbiAgICAvLyAgICAgICAgICAgZm9sbG93IHRoZSBsYWJlbCBpbnRlcnZhbCBzdHJhdGVneS5cbiAgICBzaG93QWxsU3ltYm9sOiAnYXV0bycsXG4gICAgLy8gV2hldGhlciB0byBjb25uZWN0IGJyZWFrIHBvaW50LlxuICAgIGNvbm5lY3ROdWxsczogZmFsc2UsXG4gICAgLy8gU2FtcGxpbmcgZm9yIGxhcmdlIGRhdGEuIENhbiBiZTogJ2F2ZXJhZ2UnLCAnbWF4JywgJ21pbicsICdzdW0nLlxuICAgIHNhbXBsaW5nOiAnbm9uZScsXG4gICAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJyxcbiAgICAvLyBEaXNhYmxlIHByb2dyZXNzaXZlXG4gICAgcHJvZ3Jlc3NpdmU6IDAsXG4gICAgaG92ZXJMYXllclRocmVzaG9sZDogSW5maW5pdHlcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL0xpbmVTZXJpZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFN5bWJvbERyYXcgPSByZXF1aXJlKFwiLi4vaGVscGVyL1N5bWJvbERyYXdcIik7XG5cbnZhciBTeW1ib2xDbHogPSByZXF1aXJlKFwiLi4vaGVscGVyL1N5bWJvbFwiKTtcblxudmFyIGxpbmVBbmltYXRpb25EaWZmID0gcmVxdWlyZShcIi4vbGluZUFuaW1hdGlvbkRpZmZcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG52YXIgX3BvbHkgPSByZXF1aXJlKFwiLi9wb2x5XCIpO1xuXG52YXIgUG9seWxpbmUgPSBfcG9seS5Qb2x5bGluZTtcbnZhciBQb2x5Z29uID0gX3BvbHkuUG9seWdvbjtcblxudmFyIENoYXJ0VmlldyA9IHJlcXVpcmUoXCIuLi8uLi92aWV3L0NoYXJ0XCIpO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIHJvdW5kID0gX251bWJlci5yb3VuZDtcblxudmFyIF9oZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5cbnZhciBwcmVwYXJlRGF0YUNvb3JkSW5mbyA9IF9oZWxwZXIucHJlcGFyZURhdGFDb29yZEluZm87XG52YXIgZ2V0U3RhY2tlZE9uUG9pbnQgPSBfaGVscGVyLmdldFN0YWNrZWRPblBvaW50O1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBGSVhNRSBzdGVwIG5vdCBzdXBwb3J0IHBvbGFyXG5mdW5jdGlvbiBpc1BvaW50c1NhbWUocG9pbnRzMSwgcG9pbnRzMikge1xuICBpZiAocG9pbnRzMS5sZW5ndGggIT09IHBvaW50czIubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAxID0gcG9pbnRzMVtpXTtcbiAgICB2YXIgcDIgPSBwb2ludHMyW2ldO1xuXG4gICAgaWYgKHAxWzBdICE9PSBwMlswXSB8fCBwMVsxXSAhPT0gcDJbMV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U21vb3RoKHNtb290aCkge1xuICByZXR1cm4gdHlwZW9mIHNtb290aCA9PT0gJ251bWJlcicgPyBzbW9vdGggOiBzbW9vdGggPyAwLjUgOiAwO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRXh0ZW50V2l0aEdhcChheGlzKSB7XG4gIHZhciBleHRlbnQgPSBheGlzLmdldEdsb2JhbEV4dGVudCgpO1xuXG4gIGlmIChheGlzLm9uQmFuZCkge1xuICAgIC8vIFJlbW92ZSBleHRyYSAxcHggdG8gYXZvaWQgbGluZSBtaXRlciBpbiBjbGlwcGVkIGVkZ2VcbiAgICB2YXIgaGFsZkJhbmRXaWR0aCA9IGF4aXMuZ2V0QmFuZFdpZHRoKCkgLyAyIC0gMTtcbiAgICB2YXIgZGlyID0gZXh0ZW50WzFdID4gZXh0ZW50WzBdID8gMSA6IC0xO1xuICAgIGV4dGVudFswXSArPSBkaXIgKiBoYWxmQmFuZFdpZHRoO1xuICAgIGV4dGVudFsxXSAtPSBkaXIgKiBoYWxmQmFuZFdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGV4dGVudDtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuMkR8bW9kdWxlOmVjaGFydHMvY29vcmQvcG9sYXIvUG9sYXJ9IGNvb3JkU3lzXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFDb29yZEluZm9cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcG9pbnRzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTdGFja2VkT25Qb2ludHMoY29vcmRTeXMsIGRhdGEsIGRhdGFDb29yZEluZm8pIHtcbiAgaWYgKCFkYXRhQ29vcmRJbmZvLnZhbHVlRGltKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHBvaW50cyA9IFtdO1xuXG4gIGZvciAodmFyIGlkeCA9IDAsIGxlbiA9IGRhdGEuY291bnQoKTsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgIHBvaW50cy5wdXNoKGdldFN0YWNrZWRPblBvaW50KGRhdGFDb29yZEluZm8sIGNvb3JkU3lzLCBkYXRhLCBpZHgpKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdyaWRDbGlwU2hhcGUoY2FydGVzaWFuLCBoYXNBbmltYXRpb24sIGZvclN5bWJvbCwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIHhFeHRlbnQgPSBnZXRBeGlzRXh0ZW50V2l0aEdhcChjYXJ0ZXNpYW4uZ2V0QXhpcygneCcpKTtcbiAgdmFyIHlFeHRlbnQgPSBnZXRBeGlzRXh0ZW50V2l0aEdhcChjYXJ0ZXNpYW4uZ2V0QXhpcygneScpKTtcbiAgdmFyIGlzSG9yaXpvbnRhbCA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpLmlzSG9yaXpvbnRhbCgpO1xuICB2YXIgeCA9IE1hdGgubWluKHhFeHRlbnRbMF0sIHhFeHRlbnRbMV0pO1xuICB2YXIgeSA9IE1hdGgubWluKHlFeHRlbnRbMF0sIHlFeHRlbnRbMV0pO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heCh4RXh0ZW50WzBdLCB4RXh0ZW50WzFdKSAtIHg7XG4gIHZhciBoZWlnaHQgPSBNYXRoLm1heCh5RXh0ZW50WzBdLCB5RXh0ZW50WzFdKSAtIHk7IC8vIEF2b2lkIGZsb2F0IG51bWJlciByb3VuZGluZyBlcnJvciBmb3Igc3ltYm9sIG9uIHRoZSBlZGdlIG9mIGF4aXMgZXh0ZW50LlxuICAvLyBTZWUgIzc5MTMgYW5kIGB0ZXN0L2RhdGFab29tLWNsaXAuaHRtbGAuXG5cbiAgaWYgKGZvclN5bWJvbCkge1xuICAgIHggLT0gMC41O1xuICAgIHdpZHRoICs9IDAuNTtcbiAgICB5IC09IDAuNTtcbiAgICBoZWlnaHQgKz0gMC41O1xuICB9IGVsc2Uge1xuICAgIHZhciBsaW5lV2lkdGggPSBzZXJpZXNNb2RlbC5nZXQoJ2xpbmVTdHlsZS53aWR0aCcpIHx8IDI7IC8vIEV4cGFuZCBjbGlwIHNoYXBlIHRvIGF2b2lkIGNsaXBwaW5nIHdoZW4gbGluZSB2YWx1ZSBleGNlZWRzIGF4aXNcblxuICAgIHZhciBleHBhbmRTaXplID0gc2VyaWVzTW9kZWwuZ2V0KCdjbGlwT3ZlcmZsb3cnKSA/IGxpbmVXaWR0aCAvIDIgOiBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHkgLT0gZXhwYW5kU2l6ZTtcbiAgICAgIGhlaWdodCArPSBleHBhbmRTaXplICogMjtcbiAgICB9IGVsc2Uge1xuICAgICAgeCAtPSBleHBhbmRTaXplO1xuICAgICAgd2lkdGggKz0gZXhwYW5kU2l6ZSAqIDI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChoYXNBbmltYXRpb24pIHtcbiAgICBjbGlwUGF0aC5zaGFwZVtpc0hvcml6b250YWwgPyAnd2lkdGgnIDogJ2hlaWdodCddID0gMDtcbiAgICBncmFwaGljLmluaXRQcm9wcyhjbGlwUGF0aCwge1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfVxuICAgIH0sIHNlcmllc01vZGVsKTtcbiAgfVxuXG4gIHJldHVybiBjbGlwUGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9sYXJDbGlwU2hhcGUocG9sYXIsIGhhc0FuaW1hdGlvbiwgZm9yU3ltYm9sLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgYW5nbGVBeGlzID0gcG9sYXIuZ2V0QW5nbGVBeGlzKCk7XG4gIHZhciByYWRpdXNBeGlzID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpO1xuICB2YXIgcmFkaXVzRXh0ZW50ID0gcmFkaXVzQXhpcy5nZXRFeHRlbnQoKS5zbGljZSgpO1xuICByYWRpdXNFeHRlbnRbMF0gPiByYWRpdXNFeHRlbnRbMV0gJiYgcmFkaXVzRXh0ZW50LnJldmVyc2UoKTtcbiAgdmFyIGFuZ2xlRXh0ZW50ID0gYW5nbGVBeGlzLmdldEV4dGVudCgpO1xuICB2YXIgUkFESUFOID0gTWF0aC5QSSAvIDE4MDsgLy8gQXZvaWQgZmxvYXQgbnVtYmVyIHJvdW5kaW5nIGVycm9yIGZvciBzeW1ib2wgb24gdGhlIGVkZ2Ugb2YgYXhpcyBleHRlbnQuXG5cbiAgaWYgKGZvclN5bWJvbCkge1xuICAgIHJhZGl1c0V4dGVudFswXSAtPSAwLjU7XG4gICAgcmFkaXVzRXh0ZW50WzFdICs9IDAuNTtcbiAgfVxuXG4gIHZhciBjbGlwUGF0aCA9IG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgc2hhcGU6IHtcbiAgICAgIGN4OiByb3VuZChwb2xhci5jeCwgMSksXG4gICAgICBjeTogcm91bmQocG9sYXIuY3ksIDEpLFxuICAgICAgcjA6IHJvdW5kKHJhZGl1c0V4dGVudFswXSwgMSksXG4gICAgICByOiByb3VuZChyYWRpdXNFeHRlbnRbMV0sIDEpLFxuICAgICAgc3RhcnRBbmdsZTogLWFuZ2xlRXh0ZW50WzBdICogUkFESUFOLFxuICAgICAgZW5kQW5nbGU6IC1hbmdsZUV4dGVudFsxXSAqIFJBRElBTixcbiAgICAgIGNsb2Nrd2lzZTogYW5nbGVBeGlzLmludmVyc2VcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChoYXNBbmltYXRpb24pIHtcbiAgICBjbGlwUGF0aC5zaGFwZS5lbmRBbmdsZSA9IC1hbmdsZUV4dGVudFswXSAqIFJBRElBTjtcbiAgICBncmFwaGljLmluaXRQcm9wcyhjbGlwUGF0aCwge1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgZW5kQW5nbGU6IC1hbmdsZUV4dGVudFsxXSAqIFJBRElBTlxuICAgICAgfVxuICAgIH0sIHNlcmllc01vZGVsKTtcbiAgfVxuXG4gIHJldHVybiBjbGlwUGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xpcFNoYXBlKGNvb3JkU3lzLCBoYXNBbmltYXRpb24sIGZvclN5bWJvbCwgc2VyaWVzTW9kZWwpIHtcbiAgcmV0dXJuIGNvb3JkU3lzLnR5cGUgPT09ICdwb2xhcicgPyBjcmVhdGVQb2xhckNsaXBTaGFwZShjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBmb3JTeW1ib2wsIHNlcmllc01vZGVsKSA6IGNyZWF0ZUdyaWRDbGlwU2hhcGUoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgZm9yU3ltYm9sLCBzZXJpZXNNb2RlbCk7XG59XG5cbmZ1bmN0aW9uIHR1cm5Qb2ludHNJbnRvU3RlcChwb2ludHMsIGNvb3JkU3lzLCBzdGVwVHVybkF0KSB7XG4gIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gIHZhciBiYXNlSW5kZXggPSBiYXNlQXhpcy5kaW0gPT09ICd4JyB8fCBiYXNlQXhpcy5kaW0gPT09ICdyYWRpdXMnID8gMCA6IDE7XG4gIHZhciBzdGVwUG9pbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIG5leHRQdCA9IHBvaW50c1tpICsgMV07XG4gICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgIHN0ZXBQb2ludHMucHVzaChwdCk7XG4gICAgdmFyIHN0ZXBQdCA9IFtdO1xuXG4gICAgc3dpdGNoIChzdGVwVHVybkF0KSB7XG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICBzdGVwUHRbYmFzZUluZGV4XSA9IG5leHRQdFtiYXNlSW5kZXhdO1xuICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBwdFsxIC0gYmFzZUluZGV4XTsgLy8gZGVmYXVsdCBpcyBzdGFydFxuXG4gICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgLy8gZGVmYXVsdCBpcyBzdGFydFxuICAgICAgICB2YXIgbWlkZGxlID0gKHB0W2Jhc2VJbmRleF0gKyBuZXh0UHRbYmFzZUluZGV4XSkgLyAyO1xuICAgICAgICB2YXIgc3RlcFB0MiA9IFtdO1xuICAgICAgICBzdGVwUHRbYmFzZUluZGV4XSA9IHN0ZXBQdDJbYmFzZUluZGV4XSA9IG1pZGRsZTtcbiAgICAgICAgc3RlcFB0WzEgLSBiYXNlSW5kZXhdID0gcHRbMSAtIGJhc2VJbmRleF07XG4gICAgICAgIHN0ZXBQdDJbMSAtIGJhc2VJbmRleF0gPSBuZXh0UHRbMSAtIGJhc2VJbmRleF07XG4gICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQpO1xuICAgICAgICBzdGVwUG9pbnRzLnB1c2goc3RlcFB0Mik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdGVwUHRbYmFzZUluZGV4XSA9IHB0W2Jhc2VJbmRleF07XG4gICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IG5leHRQdFsxIC0gYmFzZUluZGV4XTsgLy8gZGVmYXVsdCBpcyBzdGFydFxuXG4gICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQpO1xuICAgIH1cbiAgfSAvLyBMYXN0IHBvaW50c1xuXG5cbiAgcG9pbnRzW2ldICYmIHN0ZXBQb2ludHMucHVzaChwb2ludHNbaV0pO1xuICByZXR1cm4gc3RlcFBvaW50cztcbn1cblxuZnVuY3Rpb24gZ2V0VmlzdWFsR3JhZGllbnQoZGF0YSwgY29vcmRTeXMpIHtcbiAgdmFyIHZpc3VhbE1ldGFMaXN0ID0gZGF0YS5nZXRWaXN1YWwoJ3Zpc3VhbE1ldGEnKTtcblxuICBpZiAoIXZpc3VhbE1ldGFMaXN0IHx8ICF2aXN1YWxNZXRhTGlzdC5sZW5ndGggfHwgIWRhdGEuY291bnQoKSkge1xuICAgIC8vIFdoZW4gZGF0YS5jb3VudCgpIGlzIDAsIGdyYWRpZW50IHJhbmdlIGNhbiBub3QgYmUgY2FsY3VsYXRlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29vcmRTeXMudHlwZSAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb29yZERpbTtcbiAgdmFyIHZpc3VhbE1ldGE7XG5cbiAgZm9yICh2YXIgaSA9IHZpc3VhbE1ldGFMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGRpbUluZGV4ID0gdmlzdWFsTWV0YUxpc3RbaV0uZGltZW5zaW9uO1xuICAgIHZhciBkaW1OYW1lID0gZGF0YS5kaW1lbnNpb25zW2RpbUluZGV4XTtcbiAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1OYW1lKTtcbiAgICBjb29yZERpbSA9IGRpbUluZm8gJiYgZGltSW5mby5jb29yZERpbTsgLy8gQ2FuIG9ubHkgYmUgeCBvciB5XG5cbiAgICBpZiAoY29vcmREaW0gPT09ICd4JyB8fCBjb29yZERpbSA9PT0gJ3knKSB7XG4gICAgICB2aXN1YWxNZXRhID0gdmlzdWFsTWV0YUxpc3RbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIXZpc3VhbE1ldGEpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gSWYgdGhlIGFyZWEgdG8gYmUgcmVuZGVyZWQgaXMgYmlnZ2VyIHRoYW4gYXJlYSBkZWZpbmVkIGJ5IExpbmVhckdyYWRpZW50LFxuICAvLyB0aGUgY2FudmFzIHNwZWMgcHJlc2NyaWJlcyB0aGF0IHRoZSBjb2xvciBvZiB0aGUgZmlyc3Qgc3RvcCBhbmQgdGhlIGxhc3RcbiAgLy8gc3RvcCBzaG91bGQgYmUgdXNlZC4gQnV0IGlmIHR3byBzdG9wcyBhcmUgYWRkZWQgYXQgb2Zmc2V0IDAsIGluIGVmZmVjdFxuICAvLyBicm93c2VycyB1c2UgdGhlIGNvbG9yIG9mIHRoZSBzZWNvbmQgc3RvcCB0byByZW5kZXIgYXJlYSBvdXRzaWRlXG4gIC8vIExpbmVhckdyYWRpZW50LiBTbyB3ZSBjYW4gb25seSBpbmZpbml0ZXNpbWFsbHkgZXh0ZW5kIGFyZWEgZGVmaW5lZCBpblxuICAvLyBMaW5lYXJHcmFkaWVudCB0byByZW5kZXIgYG91dGVyQ29sb3JzYC5cblxuXG4gIHZhciBheGlzID0gY29vcmRTeXMuZ2V0QXhpcyhjb29yZERpbSk7IC8vIGRhdGFUb0Nvb3IgbWFwcGluZyBtYXkgbm90IGJlIGxpbmVhciwgYnV0IG11c3QgYmUgbW9ub3RvbmljLlxuXG4gIHZhciBjb2xvclN0b3BzID0genJVdGlsLm1hcCh2aXN1YWxNZXRhLnN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb29yZDogYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQoc3RvcC52YWx1ZSkpLFxuICAgICAgY29sb3I6IHN0b3AuY29sb3JcbiAgICB9O1xuICB9KTtcbiAgdmFyIHN0b3BMZW4gPSBjb2xvclN0b3BzLmxlbmd0aDtcbiAgdmFyIG91dGVyQ29sb3JzID0gdmlzdWFsTWV0YS5vdXRlckNvbG9ycy5zbGljZSgpO1xuXG4gIGlmIChzdG9wTGVuICYmIGNvbG9yU3RvcHNbMF0uY29vcmQgPiBjb2xvclN0b3BzW3N0b3BMZW4gLSAxXS5jb29yZCkge1xuICAgIGNvbG9yU3RvcHMucmV2ZXJzZSgpO1xuICAgIG91dGVyQ29sb3JzLnJldmVyc2UoKTtcbiAgfVxuXG4gIHZhciB0aW55RXh0ZW50ID0gMTA7IC8vIEFyYml0cmFyeSB2YWx1ZTogMTBweFxuXG4gIHZhciBtaW5Db29yZCA9IGNvbG9yU3RvcHNbMF0uY29vcmQgLSB0aW55RXh0ZW50O1xuICB2YXIgbWF4Q29vcmQgPSBjb2xvclN0b3BzW3N0b3BMZW4gLSAxXS5jb29yZCArIHRpbnlFeHRlbnQ7XG4gIHZhciBjb29yZFNwYW4gPSBtYXhDb29yZCAtIG1pbkNvb3JkO1xuXG4gIGlmIChjb29yZFNwYW4gPCAxZS0zKSB7XG4gICAgcmV0dXJuICd0cmFuc3BhcmVudCc7XG4gIH1cblxuICB6clV0aWwuZWFjaChjb2xvclN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuICAgIHN0b3Aub2Zmc2V0ID0gKHN0b3AuY29vcmQgLSBtaW5Db29yZCkgLyBjb29yZFNwYW47XG4gIH0pO1xuICBjb2xvclN0b3BzLnB1c2goe1xuICAgIG9mZnNldDogc3RvcExlbiA/IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLm9mZnNldCA6IDAuNSxcbiAgICBjb2xvcjogb3V0ZXJDb2xvcnNbMV0gfHwgJ3RyYW5zcGFyZW50J1xuICB9KTtcbiAgY29sb3JTdG9wcy51bnNoaWZ0KHtcbiAgICAvLyBub3RpY2UgY29sb3JTdG9wcy5sZW5ndGggaGF2ZSBiZWVuIGNoYW5nZWQuXG4gICAgb2Zmc2V0OiBzdG9wTGVuID8gY29sb3JTdG9wc1swXS5vZmZzZXQgOiAwLjUsXG4gICAgY29sb3I6IG91dGVyQ29sb3JzWzBdIHx8ICd0cmFuc3BhcmVudCdcbiAgfSk7IC8vIHpyVXRpbC5lYWNoKGNvbG9yU3RvcHMsIGZ1bmN0aW9uIChjb2xvclN0b3ApIHtcbiAgLy8gICAgIC8vIE1ha2Ugc3VyZSBlYWNoIG9mZnNldCBoYXMgcm91bmRlZCBweCB0byBhdm9pZCBub3Qgc2hhcnAgZWRnZVxuICAvLyAgICAgY29sb3JTdG9wLm9mZnNldCA9IChNYXRoLnJvdW5kKGNvbG9yU3RvcC5vZmZzZXQgKiAoZW5kIC0gc3RhcnQpICsgc3RhcnQpIC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KTtcbiAgLy8gfSk7XG5cbiAgdmFyIGdyYWRpZW50ID0gbmV3IGdyYXBoaWMuTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgMCwgY29sb3JTdG9wcywgdHJ1ZSk7XG4gIGdyYWRpZW50W2Nvb3JkRGltXSA9IG1pbkNvb3JkO1xuICBncmFkaWVudFtjb29yZERpbSArICcyJ10gPSBtYXhDb29yZDtcbiAgcmV0dXJuIGdyYWRpZW50O1xufVxuXG5mdW5jdGlvbiBnZXRJc0lnbm9yZUZ1bmMoc2VyaWVzTW9kZWwsIGRhdGEsIGNvb3JkU3lzKSB7XG4gIHZhciBzaG93QWxsU3ltYm9sID0gc2VyaWVzTW9kZWwuZ2V0KCdzaG93QWxsU3ltYm9sJyk7XG4gIHZhciBpc0F1dG8gPSBzaG93QWxsU3ltYm9sID09PSAnYXV0byc7XG5cbiAgaWYgKHNob3dBbGxTeW1ib2wgJiYgIWlzQXV0bykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjYXRlZ29yeUF4aXMgPSBjb29yZFN5cy5nZXRBeGVzQnlTY2FsZSgnb3JkaW5hbCcpWzBdO1xuXG4gIGlmICghY2F0ZWdvcnlBeGlzKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE5vdGUgdGhhdCBjYXRlZ29yeSBsYWJlbCBpbnRlcnZhbCBzdHJhdGVneSBtaWdodCBicmluZyBzb21lIHdlaXJkIGVmZmVjdFxuICAvLyBpbiBzb21lIHNjZW5hcmlvOiB1c2VycyBtYXkgd29uZGVyIHdoeSBzb21lIG9mIHRoZSBzeW1ib2xzIGFyZSBub3RcbiAgLy8gZGlzcGxheWVkLiBTbyB3ZSBzaG93IGFsbCBzeW1ib2xzIGFzIHBvc3NpYmxlIGFzIHdlIGNhbi5cblxuXG4gIGlmIChpc0F1dG8gLy8gU2ltcGxpZnkgdGhlIGxvZ2ljLCBkbyBub3QgZGV0ZXJtaW5lIGxhYmVsIG92ZXJsYXAgaGVyZS5cbiAgJiYgY2FuU2hvd0FsbFN5bWJvbEZvckNhdGVnb3J5KGNhdGVnb3J5QXhpcywgZGF0YSkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gT3RoZXJ3aXNlIGZvbGxvdyB0aGUgbGFiZWwgaW50ZXJ2YWwgc3RyYXRlZ3kgb24gY2F0ZWdvcnkgYXhpcy5cblxuXG4gIHZhciBjYXRlZ29yeURhdGFEaW0gPSBkYXRhLm1hcERpbWVuc2lvbihjYXRlZ29yeUF4aXMuZGltKTtcbiAgdmFyIGxhYmVsTWFwID0ge307XG4gIHpyVXRpbC5lYWNoKGNhdGVnb3J5QXhpcy5nZXRWaWV3TGFiZWxzKCksIGZ1bmN0aW9uIChsYWJlbEl0ZW0pIHtcbiAgICBsYWJlbE1hcFtsYWJlbEl0ZW0udGlja1ZhbHVlXSA9IDE7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgIHJldHVybiAhbGFiZWxNYXAuaGFzT3duUHJvcGVydHkoZGF0YS5nZXQoY2F0ZWdvcnlEYXRhRGltLCBkYXRhSW5kZXgpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FuU2hvd0FsbFN5bWJvbEZvckNhdGVnb3J5KGNhdGVnb3J5QXhpcywgZGF0YSkge1xuICAvLyBJbiBtb3NlIGNhc2VzLCBsaW5lIGlzIG1vbm90b25vdXMgb24gY2F0ZWdvcnkgYXhpcywgYW5kIHRoZSBsYWJlbCBzaXplXG4gIC8vIGlzIGNsb3NlIHdpdGggZWFjaCBvdGhlci4gU28gd2UgY2hlY2sgdGhlIHN5bWJvbCBzaXplIGFuZCBzb21lIG9mIHRoZVxuICAvLyBsYWJlbCBzaXplIGFsb25lIHdpdGggdGhlIGNhdGVnb3J5IGF4aXMgdG8gZXN0aW1hdGUgd2hldGhlciBhbGwgc3ltYm9sXG4gIC8vIGNhbiBiZSBzaG93biB3aXRob3V0IG92ZXJsYXAuXG4gIHZhciBheGlzRXh0ZW50ID0gY2F0ZWdvcnlBeGlzLmdldEV4dGVudCgpO1xuICB2YXIgYXZhaWxTaXplID0gTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pIC8gY2F0ZWdvcnlBeGlzLnNjYWxlLmNvdW50KCk7XG4gIGlzTmFOKGF2YWlsU2l6ZSkgJiYgKGF2YWlsU2l6ZSA9IDApOyAvLyAwLzAgaXMgTmFOLlxuICAvLyBTYW1wbGluZyBzb21lIHBvaW50cywgbWF4IDUuXG5cbiAgdmFyIGRhdGFMZW4gPSBkYXRhLmNvdW50KCk7XG4gIHZhciBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChkYXRhTGVuIC8gNSkpO1xuXG4gIGZvciAodmFyIGRhdGFJbmRleCA9IDA7IGRhdGFJbmRleCA8IGRhdGFMZW47IGRhdGFJbmRleCArPSBzdGVwKSB7XG4gICAgaWYgKFN5bWJvbENsei5nZXRTeW1ib2xTaXplKGRhdGEsIGRhdGFJbmRleCAvLyBPbmx5IGZvciBjYXJ0ZXNpYW4sIHdoZXJlIGBpc0hvcml6b250YWxgIGV4aXN0cy5cbiAgICApW2NhdGVnb3J5QXhpcy5pc0hvcml6b250YWwoKSA/IDEgOiAwXSAvLyBFbXBpcmljYWwgbnVtYmVyXG4gICAgKiAxLjUgPiBhdmFpbFNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIF9kZWZhdWx0ID0gQ2hhcnRWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdsaW5lJyxcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaW5lR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHZhciBzeW1ib2xEcmF3ID0gbmV3IFN5bWJvbERyYXcoKTtcbiAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2xEcmF3Lmdyb3VwKTtcbiAgICB0aGlzLl9zeW1ib2xEcmF3ID0gc3ltYm9sRHJhdztcbiAgICB0aGlzLl9saW5lR3JvdXAgPSBsaW5lR3JvdXA7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUnKTtcbiAgICB2YXIgcG9pbnRzID0gZGF0YS5tYXBBcnJheShkYXRhLmdldEl0ZW1MYXlvdXQpO1xuICAgIHZhciBpc0Nvb3JkU3lzUG9sYXIgPSBjb29yZFN5cy50eXBlID09PSAncG9sYXInO1xuICAgIHZhciBwcmV2Q29vcmRTeXMgPSB0aGlzLl9jb29yZFN5cztcbiAgICB2YXIgc3ltYm9sRHJhdyA9IHRoaXMuX3N5bWJvbERyYXc7XG4gICAgdmFyIHBvbHlsaW5lID0gdGhpcy5fcG9seWxpbmU7XG4gICAgdmFyIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uO1xuICAgIHZhciBsaW5lR3JvdXAgPSB0aGlzLl9saW5lR3JvdXA7XG4gICAgdmFyIGhhc0FuaW1hdGlvbiA9IHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uJyk7XG4gICAgdmFyIGlzQXJlYUNoYXJ0ID0gIWFyZWFTdHlsZU1vZGVsLmlzRW1wdHkoKTtcbiAgICB2YXIgdmFsdWVPcmlnaW4gPSBhcmVhU3R5bGVNb2RlbC5nZXQoJ29yaWdpbicpO1xuICAgIHZhciBkYXRhQ29vcmRJbmZvID0gcHJlcGFyZURhdGFDb29yZEluZm8oY29vcmRTeXMsIGRhdGEsIHZhbHVlT3JpZ2luKTtcbiAgICB2YXIgc3RhY2tlZE9uUG9pbnRzID0gZ2V0U3RhY2tlZE9uUG9pbnRzKGNvb3JkU3lzLCBkYXRhLCBkYXRhQ29vcmRJbmZvKTtcbiAgICB2YXIgc2hvd1N5bWJvbCA9IHNlcmllc01vZGVsLmdldCgnc2hvd1N5bWJvbCcpO1xuICAgIHZhciBpc0lnbm9yZUZ1bmMgPSBzaG93U3ltYm9sICYmICFpc0Nvb3JkU3lzUG9sYXIgJiYgZ2V0SXNJZ25vcmVGdW5jKHNlcmllc01vZGVsLCBkYXRhLCBjb29yZFN5cyk7IC8vIFJlbW92ZSB0ZW1wb3Jhcnkgc3ltYm9sc1xuXG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIG9sZERhdGEgJiYgb2xkRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgaWYgKGVsLl9fdGVtcCkge1xuICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICBvbGREYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBudWxsKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gUmVtb3ZlIHByZXZpb3VzIGNyZWF0ZWQgc3ltYm9scyBpZiBzaG93U3ltYm9sIGNoYW5nZWQgdG8gZmFsc2VcblxuICAgIGlmICghc2hvd1N5bWJvbCkge1xuICAgICAgc3ltYm9sRHJhdy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBncm91cC5hZGQobGluZUdyb3VwKTsgLy8gRklYTUUgc3RlcCBub3Qgc3VwcG9ydCBwb2xhclxuXG4gICAgdmFyIHN0ZXAgPSAhaXNDb29yZFN5c1BvbGFyICYmIHNlcmllc01vZGVsLmdldCgnc3RlcCcpOyAvLyBJbml0aWFsaXphdGlvbiBhbmltYXRpb24gb3IgY29vcmRpbmF0ZSBzeXN0ZW0gY2hhbmdlZFxuXG4gICAgaWYgKCEocG9seWxpbmUgJiYgcHJldkNvb3JkU3lzLnR5cGUgPT09IGNvb3JkU3lzLnR5cGUgJiYgc3RlcCA9PT0gdGhpcy5fc3RlcCkpIHtcbiAgICAgIHNob3dTeW1ib2wgJiYgc3ltYm9sRHJhdy51cGRhdGVEYXRhKGRhdGEsIHtcbiAgICAgICAgaXNJZ25vcmU6IGlzSWdub3JlRnVuYyxcbiAgICAgICAgY2xpcFNoYXBlOiBjcmVhdGVDbGlwU2hhcGUoY29vcmRTeXMsIGZhbHNlLCB0cnVlLCBzZXJpZXNNb2RlbClcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3RlcCkge1xuICAgICAgICAvLyBUT0RPIElmIHN0YWNrZWQgc2VyaWVzIGlzIG5vdCBzdGVwXG4gICAgICAgIHBvaW50cyA9IHR1cm5Qb2ludHNJbnRvU3RlcChwb2ludHMsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgc3RhY2tlZE9uUG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgfVxuXG4gICAgICBwb2x5bGluZSA9IHRoaXMuX25ld1BvbHlsaW5lKHBvaW50cywgY29vcmRTeXMsIGhhc0FuaW1hdGlvbik7XG5cbiAgICAgIGlmIChpc0FyZWFDaGFydCkge1xuICAgICAgICBwb2x5Z29uID0gdGhpcy5fbmV3UG9seWdvbihwb2ludHMsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGhhc0FuaW1hdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGxpbmVHcm91cC5zZXRDbGlwUGF0aChjcmVhdGVDbGlwU2hhcGUoY29vcmRTeXMsIHRydWUsIGZhbHNlLCBzZXJpZXNNb2RlbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcmVhQ2hhcnQgJiYgIXBvbHlnb24pIHtcbiAgICAgICAgLy8gSWYgYXJlYVN0eWxlIGlzIGFkZGVkXG4gICAgICAgIHBvbHlnb24gPSB0aGlzLl9uZXdQb2x5Z29uKHBvaW50cywgc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgaGFzQW5pbWF0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAocG9seWdvbiAmJiAhaXNBcmVhQ2hhcnQpIHtcbiAgICAgICAgLy8gSWYgYXJlYVN0eWxlIGlzIHJlbW92ZWRcbiAgICAgICAgbGluZUdyb3VwLnJlbW92ZShwb2x5Z29uKTtcbiAgICAgICAgcG9seWdvbiA9IHRoaXMuX3BvbHlnb24gPSBudWxsO1xuICAgICAgfSAvLyBVcGRhdGUgY2xpcFBhdGhcblxuXG4gICAgICBsaW5lR3JvdXAuc2V0Q2xpcFBhdGgoY3JlYXRlQ2xpcFNoYXBlKGNvb3JkU3lzLCBmYWxzZSwgZmFsc2UsIHNlcmllc01vZGVsKSk7IC8vIEFsd2F5cyB1cGRhdGUsIG9yIGl0IGlzIHdyb25nIGluIHRoZSBjYXNlIHR1cm5pbmcgb24gbGVnZW5kXG4gICAgICAvLyBiZWNhdXNlIHBvaW50cyBhcmUgbm90IGNoYW5nZWRcblxuICAgICAgc2hvd1N5bWJvbCAmJiBzeW1ib2xEcmF3LnVwZGF0ZURhdGEoZGF0YSwge1xuICAgICAgICBpc0lnbm9yZTogaXNJZ25vcmVGdW5jLFxuICAgICAgICBjbGlwU2hhcGU6IGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgZmFsc2UsIHRydWUsIHNlcmllc01vZGVsKVxuICAgICAgfSk7IC8vIFN0b3Agc3ltYm9sIGFuaW1hdGlvbiBhbmQgc3luYyB3aXRoIGxpbmUgcG9pbnRzXG4gICAgICAvLyBGSVhNRSBwZXJmb3JtYW5jZT9cblxuICAgICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgICAgIH0pOyAvLyBJbiB0aGUgY2FzZSBkYXRhIHpvb20gdHJpZ2dlcnJlZCByZWZyZXNoaW5nIGZyZXF1ZW50bHlcbiAgICAgIC8vIERhdGEgbWF5IG5vdCBjaGFuZ2UgaWYgbGluZSBoYXMgYSBjYXRlZ29yeSBheGlzLiBTbyBpdCBzaG91bGQgYW5pbWF0ZSBub3RoaW5nXG5cbiAgICAgIGlmICghaXNQb2ludHNTYW1lKHRoaXMuX3N0YWNrZWRPblBvaW50cywgc3RhY2tlZE9uUG9pbnRzKSB8fCAhaXNQb2ludHNTYW1lKHRoaXMuX3BvaW50cywgcG9pbnRzKSkge1xuICAgICAgICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uKGRhdGEsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGFwaSwgc3RlcCwgdmFsdWVPcmlnaW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vdCBkbyBpdCBpbiB1cGRhdGUgd2l0aCBhbmltYXRpb25cbiAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgLy8gVE9ETyBJZiBzdGFja2VkIHNlcmllcyBpcyBub3Qgc3RlcFxuICAgICAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvbHlsaW5lLnNldFNoYXBlKHtcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9seWdvbiAmJiBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25Qb2ludHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2aXN1YWxDb2xvciA9IGdldFZpc3VhbEdyYWRpZW50KGRhdGEsIGNvb3JkU3lzKSB8fCBkYXRhLmdldFZpc3VhbCgnY29sb3InKTtcbiAgICBwb2x5bGluZS51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoIC8vIFVzZSBjb2xvciBpbiBsaW5lU3R5bGUgZmlyc3RcbiAgICBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKSwge1xuICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgc3Ryb2tlOiB2aXN1YWxDb2xvcixcbiAgICAgIGxpbmVKb2luOiAnYmV2ZWwnXG4gICAgfSkpO1xuICAgIHZhciBzbW9vdGggPSBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aCcpO1xuICAgIHNtb290aCA9IGdldFNtb290aChzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aCcpKTtcbiAgICBwb2x5bGluZS5zZXRTaGFwZSh7XG4gICAgICBzbW9vdGg6IHNtb290aCxcbiAgICAgIHNtb290aE1vbm90b25lOiBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aE1vbm90b25lJyksXG4gICAgICBjb25uZWN0TnVsbHM6IHNlcmllc01vZGVsLmdldCgnY29ubmVjdE51bGxzJylcbiAgICB9KTtcblxuICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICB2YXIgc3RhY2tlZE9uU2VyaWVzID0gZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrZWRPblNlcmllcycpO1xuICAgICAgdmFyIHN0YWNrZWRPblNtb290aCA9IDA7XG4gICAgICBwb2x5Z29uLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyhhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKSwge1xuICAgICAgICBmaWxsOiB2aXN1YWxDb2xvcixcbiAgICAgICAgb3BhY2l0eTogMC43LFxuICAgICAgICBsaW5lSm9pbjogJ2JldmVsJ1xuICAgICAgfSkpO1xuXG4gICAgICBpZiAoc3RhY2tlZE9uU2VyaWVzKSB7XG4gICAgICAgIHN0YWNrZWRPblNtb290aCA9IGdldFNtb290aChzdGFja2VkT25TZXJpZXMuZ2V0KCdzbW9vdGgnKSk7XG4gICAgICB9XG5cbiAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICBzbW9vdGg6IHNtb290aCxcbiAgICAgICAgc3RhY2tlZE9uU21vb3RoOiBzdGFja2VkT25TbW9vdGgsXG4gICAgICAgIHNtb290aE1vbm90b25lOiBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aE1vbm90b25lJyksXG4gICAgICAgIGNvbm5lY3ROdWxsczogc2VyaWVzTW9kZWwuZ2V0KCdjb25uZWN0TnVsbHMnKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7IC8vIFNhdmUgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGZvciB0cmFuc2l0aW9uIGFuaW1hdGlvbiB3aGVuIGRhdGEgY2hhbmdlZFxuXG4gICAgdGhpcy5fY29vcmRTeXMgPSBjb29yZFN5cztcbiAgICB0aGlzLl9zdGFja2VkT25Qb2ludHMgPSBzdGFja2VkT25Qb2ludHM7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIHRoaXMuX3ZhbHVlT3JpZ2luID0gdmFsdWVPcmlnaW47XG4gIH0sXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHt9LFxuICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcblxuICAgIGlmICghKGRhdGFJbmRleCBpbnN0YW5jZW9mIEFycmF5KSAmJiBkYXRhSW5kZXggIT0gbnVsbCAmJiBkYXRhSW5kZXggPj0gMCkge1xuICAgICAgdmFyIHN5bWJvbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuXG4gICAgICBpZiAoIXN5bWJvbCkge1xuICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgc3ltYm9sIGlmIGl0IGlzIG5vdCBleGlzdHNcbiAgICAgICAgdmFyIHB0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCk7XG5cbiAgICAgICAgaWYgKCFwdCkge1xuICAgICAgICAgIC8vIE51bGwgZGF0YVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2xDbHooZGF0YSwgZGF0YUluZGV4KTtcbiAgICAgICAgc3ltYm9sLnBvc2l0aW9uID0gcHQ7XG4gICAgICAgIHN5bWJvbC5zZXRaKHNlcmllc01vZGVsLmdldCgnemxldmVsJyksIHNlcmllc01vZGVsLmdldCgneicpKTtcbiAgICAgICAgc3ltYm9sLmlnbm9yZSA9IGlzTmFOKHB0WzBdKSB8fCBpc05hTihwdFsxXSk7XG4gICAgICAgIHN5bWJvbC5fX3RlbXAgPSB0cnVlO1xuICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4LCBzeW1ib2wpOyAvLyBTdG9wIHNjYWxlIGFuaW1hdGlvblxuXG4gICAgICAgIHN5bWJvbC5zdG9wU3ltYm9sQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2wpO1xuICAgICAgfVxuXG4gICAgICBzeW1ib2wuaGlnaGxpZ2h0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhpZ2hsaWdodCB3aG9sZSBzZXJpZXNcbiAgICAgIENoYXJ0Vmlldy5wcm90b3R5cGUuaGlnaGxpZ2h0LmNhbGwodGhpcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgfVxuICB9LFxuICBkb3ducGxheTogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgZGF0YUluZGV4ID0gbW9kZWxVdGlsLnF1ZXJ5RGF0YUluZGV4KGRhdGEsIHBheWxvYWQpO1xuXG4gICAgaWYgKGRhdGFJbmRleCAhPSBudWxsICYmIGRhdGFJbmRleCA+PSAwKSB7XG4gICAgICB2YXIgc3ltYm9sID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG5cbiAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgaWYgKHN5bWJvbC5fX3RlbXApIHtcbiAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4LCBudWxsKTtcbiAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZShzeW1ib2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN5bWJvbC5kb3ducGxheSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyBjYW4gbm90IGRvd25wbGF5IGNvbXBsZXRlbHkuXG4gICAgICAvLyBEb3ducGxheSB3aG9sZSBzZXJpZXNcbiAgICAgIENoYXJ0Vmlldy5wcm90b3R5cGUuZG93bnBsYXkuY2FsbCh0aGlzLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBvaW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25ld1BvbHlsaW5lOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgdmFyIHBvbHlsaW5lID0gdGhpcy5fcG9seWxpbmU7IC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHBvbHlsaW5lXG5cbiAgICBpZiAocG9seWxpbmUpIHtcbiAgICAgIHRoaXMuX2xpbmVHcm91cC5yZW1vdmUocG9seWxpbmUpO1xuICAgIH1cblxuICAgIHBvbHlsaW5lID0gbmV3IFBvbHlsaW5lKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICB9LFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgejI6IDEwXG4gICAgfSk7XG5cbiAgICB0aGlzLl9saW5lR3JvdXAuYWRkKHBvbHlsaW5lKTtcblxuICAgIHRoaXMuX3BvbHlsaW5lID0gcG9seWxpbmU7XG4gICAgcmV0dXJuIHBvbHlsaW5lO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBzdGFja2VkT25Qb2ludHNcbiAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9uZXdQb2x5Z29uOiBmdW5jdGlvbiAocG9pbnRzLCBzdGFja2VkT25Qb2ludHMpIHtcbiAgICB2YXIgcG9seWdvbiA9IHRoaXMuX3BvbHlnb247IC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHBvbHlnb25cblxuICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICB0aGlzLl9saW5lR3JvdXAucmVtb3ZlKHBvbHlnb24pO1xuICAgIH1cblxuICAgIHBvbHlnb24gPSBuZXcgUG9seWdvbih7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25Qb2ludHNcbiAgICAgIH0sXG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuX2xpbmVHcm91cC5hZGQocG9seWdvbik7XG5cbiAgICB0aGlzLl9wb2x5Z29uID0gcG9seWdvbjtcbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8vIEZJWE1FIFR3byB2YWx1ZSBheGlzXG4gIF91cGRhdGVBbmltYXRpb246IGZ1bmN0aW9uIChkYXRhLCBzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBhcGksIHN0ZXAsIHZhbHVlT3JpZ2luKSB7XG4gICAgdmFyIHBvbHlsaW5lID0gdGhpcy5fcG9seWxpbmU7XG4gICAgdmFyIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uO1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBkaWZmID0gbGluZUFuaW1hdGlvbkRpZmYodGhpcy5fZGF0YSwgZGF0YSwgdGhpcy5fc3RhY2tlZE9uUG9pbnRzLCBzdGFja2VkT25Qb2ludHMsIHRoaXMuX2Nvb3JkU3lzLCBjb29yZFN5cywgdGhpcy5fdmFsdWVPcmlnaW4sIHZhbHVlT3JpZ2luKTtcbiAgICB2YXIgY3VycmVudCA9IGRpZmYuY3VycmVudDtcbiAgICB2YXIgc3RhY2tlZE9uQ3VycmVudCA9IGRpZmYuc3RhY2tlZE9uQ3VycmVudDtcbiAgICB2YXIgbmV4dCA9IGRpZmYubmV4dDtcbiAgICB2YXIgc3RhY2tlZE9uTmV4dCA9IGRpZmYuc3RhY2tlZE9uTmV4dDtcblxuICAgIGlmIChzdGVwKSB7XG4gICAgICAvLyBUT0RPIElmIHN0YWNrZWQgc2VyaWVzIGlzIG5vdCBzdGVwXG4gICAgICBjdXJyZW50ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYuY3VycmVudCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgc3RhY2tlZE9uQ3VycmVudCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLnN0YWNrZWRPbkN1cnJlbnQsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgIG5leHQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5uZXh0LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICBzdGFja2VkT25OZXh0ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYuc3RhY2tlZE9uTmV4dCwgY29vcmRTeXMsIHN0ZXApO1xuICAgIH0gLy8gYGRpZmYuY3VycmVudGAgaXMgc3Vic2V0IG9mIGBjdXJyZW50YCAod2hpY2ggc2hvdWxkIGJlIGVuc3VyZWQgYnlcbiAgICAvLyB0dXJuUG9pbnRzSW50b1N0ZXApLCBzbyBwb2ludHMgaW4gYF9fcG9pbnRzYCBjYW4gYmUgdXBkYXRlZCB3aGVuXG4gICAgLy8gcG9pbnRzIGluIGBjdXJyZW50YCBhcmUgdXBkYXRlIGR1cmluZyBhbmltYXRpb24uXG5cblxuICAgIHBvbHlsaW5lLnNoYXBlLl9fcG9pbnRzID0gZGlmZi5jdXJyZW50O1xuICAgIHBvbHlsaW5lLnNoYXBlLnBvaW50cyA9IGN1cnJlbnQ7XG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5bGluZSwge1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBuZXh0XG4gICAgICB9XG4gICAgfSwgc2VyaWVzTW9kZWwpO1xuXG4gICAgaWYgKHBvbHlnb24pIHtcbiAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICBwb2ludHM6IGN1cnJlbnQsXG4gICAgICAgIHN0YWNrZWRPblBvaW50czogc3RhY2tlZE9uQ3VycmVudFxuICAgICAgfSk7XG4gICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlnb24sIHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBwb2ludHM6IG5leHQsXG4gICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25OZXh0XG4gICAgICAgIH1cbiAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlZERhdGFJbmZvID0gW107XG4gICAgdmFyIGRpZmZTdGF0dXMgPSBkaWZmLnN0YXR1cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZlN0YXR1cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNtZCA9IGRpZmZTdGF0dXNbaV0uY21kO1xuXG4gICAgICBpZiAoY21kID09PSAnPScpIHtcbiAgICAgICAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRpZmZTdGF0dXNbaV0uaWR4MSk7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgdXBkYXRlZERhdGFJbmZvLnB1c2goe1xuICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgcHRJZHg6IGkgLy8gSW5kZXggb2YgcG9pbnRzXG5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb2x5bGluZS5hbmltYXRvcnMgJiYgcG9seWxpbmUuYW5pbWF0b3JzLmxlbmd0aCkge1xuICAgICAgcG9seWxpbmUuYW5pbWF0b3JzWzBdLmR1cmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlZERhdGFJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsID0gdXBkYXRlZERhdGFJbmZvW2ldLmVsO1xuICAgICAgICAgIGVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9seWxpbmUuc2hhcGUuX19wb2ludHNbdXBkYXRlZERhdGFJbmZvW2ldLnB0SWR4XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgdGhpcy5fc3ltYm9sRHJhdy5yZW1vdmUodHJ1ZSk7IC8vIFJlbW92ZSB0ZW1wb3JhcnkgY3JlYXRlZCBlbGVtZW50cyB3aGVuIGhpZ2hsaWdodGluZ1xuXG5cbiAgICBvbGREYXRhICYmIG9sZERhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgIGlmIChlbC5fX3RlbXApIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgb2xkRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9seWxpbmUgPSB0aGlzLl9wb2x5Z29uID0gdGhpcy5fY29vcmRTeXMgPSB0aGlzLl9wb2ludHMgPSB0aGlzLl9zdGFja2VkT25Qb2ludHMgPSB0aGlzLl9kYXRhID0gbnVsbDtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfZGF0YVN0YWNrSGVscGVyID0gcmVxdWlyZShcIi4uLy4uL2RhdGEvaGVscGVyL2RhdGFTdGFja0hlbHBlclwiKTtcblxudmFyIGlzRGltZW5zaW9uU3RhY2tlZCA9IF9kYXRhU3RhY2tIZWxwZXIuaXNEaW1lbnNpb25TdGFja2VkO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbWFwID0gX3V0aWwubWFwO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGNvb3JkU3lzXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlT3JpZ2luIGxpbmVTZXJpZXMub3B0aW9uLmFyZWFTdHlsZS5vcmlnaW5cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZURhdGFDb29yZEluZm8oY29vcmRTeXMsIGRhdGEsIHZhbHVlT3JpZ2luKSB7XG4gIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gIHZhciB2YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICB2YXIgdmFsdWVTdGFydCA9IGdldFZhbHVlU3RhcnQodmFsdWVBeGlzLCB2YWx1ZU9yaWdpbik7XG4gIHZhciBiYXNlQXhpc0RpbSA9IGJhc2VBeGlzLmRpbTtcbiAgdmFyIHZhbHVlQXhpc0RpbSA9IHZhbHVlQXhpcy5kaW07XG4gIHZhciB2YWx1ZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpc0RpbSk7XG4gIHZhciBiYXNlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oYmFzZUF4aXNEaW0pO1xuICB2YXIgYmFzZURhdGFPZmZzZXQgPSB2YWx1ZUF4aXNEaW0gPT09ICd4JyB8fCB2YWx1ZUF4aXNEaW0gPT09ICdyYWRpdXMnID8gMSA6IDA7XG4gIHZhciBkaW1zID0gbWFwKGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgIHJldHVybiBkYXRhLm1hcERpbWVuc2lvbihjb29yZERpbSk7XG4gIH0pO1xuICB2YXIgc3RhY2tlZDtcbiAgdmFyIHN0YWNrUmVzdWx0RGltID0gZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrUmVzdWx0RGltZW5zaW9uJyk7XG5cbiAgaWYgKHN0YWNrZWQgfD0gaXNEaW1lbnNpb25TdGFja2VkKGRhdGEsIGRpbXNbMF1cbiAgLyosIGRpbXNbMV0qL1xuICApKSB7XG4gICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgZGltc1swXSA9IHN0YWNrUmVzdWx0RGltO1xuICB9XG5cbiAgaWYgKHN0YWNrZWQgfD0gaXNEaW1lbnNpb25TdGFja2VkKGRhdGEsIGRpbXNbMV1cbiAgLyosIGRpbXNbMF0qL1xuICApKSB7XG4gICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgZGltc1sxXSA9IHN0YWNrUmVzdWx0RGltO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhRGltc0ZvclBvaW50OiBkaW1zLFxuICAgIHZhbHVlU3RhcnQ6IHZhbHVlU3RhcnQsXG4gICAgdmFsdWVBeGlzRGltOiB2YWx1ZUF4aXNEaW0sXG4gICAgYmFzZUF4aXNEaW06IGJhc2VBeGlzRGltLFxuICAgIHN0YWNrZWQ6ICEhc3RhY2tlZCxcbiAgICB2YWx1ZURpbTogdmFsdWVEaW0sXG4gICAgYmFzZURpbTogYmFzZURpbSxcbiAgICBiYXNlRGF0YU9mZnNldDogYmFzZURhdGFPZmZzZXQsXG4gICAgc3RhY2tlZE92ZXJEaW1lbnNpb246IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkT3ZlckRpbWVuc2lvbicpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlU3RhcnQodmFsdWVBeGlzLCB2YWx1ZU9yaWdpbikge1xuICB2YXIgdmFsdWVTdGFydCA9IDA7XG4gIHZhciBleHRlbnQgPSB2YWx1ZUF4aXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG5cbiAgaWYgKHZhbHVlT3JpZ2luID09PSAnc3RhcnQnKSB7XG4gICAgdmFsdWVTdGFydCA9IGV4dGVudFswXTtcbiAgfSBlbHNlIGlmICh2YWx1ZU9yaWdpbiA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZVN0YXJ0ID0gZXh0ZW50WzFdO1xuICB9IC8vIGF1dG9cbiAgZWxzZSB7XG4gICAgICAvLyBCb3RoIHBvc2l0aXZlXG4gICAgICBpZiAoZXh0ZW50WzBdID4gMCkge1xuICAgICAgICB2YWx1ZVN0YXJ0ID0gZXh0ZW50WzBdO1xuICAgICAgfSAvLyBCb3RoIG5lZ2F0aXZlXG4gICAgICBlbHNlIGlmIChleHRlbnRbMV0gPCAwKSB7XG4gICAgICAgICAgdmFsdWVTdGFydCA9IGV4dGVudFsxXTtcbiAgICAgICAgfSAvLyBJZiBpcyBvbmUgcG9zaXRpdmUsIGFuZCBvbmUgbmVnYXRpdmUsIG9uWmVybyBzaGFsbCBiZSB0cnVlXG5cbiAgICB9XG5cbiAgcmV0dXJuIHZhbHVlU3RhcnQ7XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrZWRPblBvaW50KGRhdGFDb29yZEluZm8sIGNvb3JkU3lzLCBkYXRhLCBpZHgpIHtcbiAgdmFyIHZhbHVlID0gTmFOO1xuXG4gIGlmIChkYXRhQ29vcmRJbmZvLnN0YWNrZWQpIHtcbiAgICB2YWx1ZSA9IGRhdGEuZ2V0KGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkT3ZlckRpbWVuc2lvbicpLCBpZHgpO1xuICB9XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgIHZhbHVlID0gZGF0YUNvb3JkSW5mby52YWx1ZVN0YXJ0O1xuICB9XG5cbiAgdmFyIGJhc2VEYXRhT2Zmc2V0ID0gZGF0YUNvb3JkSW5mby5iYXNlRGF0YU9mZnNldDtcbiAgdmFyIHN0YWNrZWREYXRhID0gW107XG4gIHN0YWNrZWREYXRhW2Jhc2VEYXRhT2Zmc2V0XSA9IGRhdGEuZ2V0KGRhdGFDb29yZEluZm8uYmFzZURpbSwgaWR4KTtcbiAgc3RhY2tlZERhdGFbMSAtIGJhc2VEYXRhT2Zmc2V0XSA9IHZhbHVlO1xuICByZXR1cm4gY29vcmRTeXMuZGF0YVRvUG9pbnQoc3RhY2tlZERhdGEpO1xufVxuXG5leHBvcnRzLnByZXBhcmVEYXRhQ29vcmRJbmZvID0gcHJlcGFyZURhdGFDb29yZEluZm87XG5leHBvcnRzLmdldFN0YWNrZWRPblBvaW50ID0gZ2V0U3RhY2tlZE9uUG9pbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9oZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvaGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9oZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5cbnZhciBwcmVwYXJlRGF0YUNvb3JkSW5mbyA9IF9oZWxwZXIucHJlcGFyZURhdGFDb29yZEluZm87XG52YXIgZ2V0U3RhY2tlZE9uUG9pbnQgPSBfaGVscGVyLmdldFN0YWNrZWRPblBvaW50O1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyB2YXIgYXJyYXlEaWZmID0gcmVxdWlyZSgnenJlbmRlci9zcmMvY29yZS9hcnJheURpZmYnKTtcbi8vICd6cmVuZGVyL3NyYy9jb3JlL2FycmF5RGlmZicgaGFzIGJlZW4gdXNlZCBiZWZvcmUsIGJ1dCBpdCBkaWRcbi8vIG5vdCBkbyB3ZWxsIGluIHBlcmZvcm1hbmNlIHdoZW4gcm9hbSB3aXRoIGZpeGVkIGRhdGFab29tIHdpbmRvdy5cbi8vIGZ1bmN0aW9uIGNvbnZlcnRUb0ludElkKG5ld0lkTGlzdCwgb2xkSWRMaXN0KSB7XG4vLyAgICAgLy8gR2VuZXJhdGUgaW50IGlkIGluc3RlYWQgb2Ygc3RyaW5nIGlkLlxuLy8gICAgIC8vIENvbXBhcmUgc3RyaW5nIG1heWJlIHNsb3cgaW4gc2NvcmUgZnVuY3Rpb24gb2YgYXJyRGlmZlxuLy8gICAgIC8vIEFzc3VtZSBpZCBpbiBpZExpc3QgYXJlIGFsbCB1bmlxdWVcbi8vICAgICB2YXIgaWRJbmRpY2VzTWFwID0ge307XG4vLyAgICAgdmFyIGlkeCA9IDA7XG4vLyAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJZExpc3QubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgaWRJbmRpY2VzTWFwW25ld0lkTGlzdFtpXV0gPSBpZHg7XG4vLyAgICAgICAgIG5ld0lkTGlzdFtpXSA9IGlkeCsrO1xuLy8gICAgIH1cbi8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZElkTGlzdC5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICB2YXIgb2xkSWQgPSBvbGRJZExpc3RbaV07XG4vLyAgICAgICAgIC8vIFNhbWUgd2l0aCBuZXdJZExpc3Rcbi8vICAgICAgICAgaWYgKGlkSW5kaWNlc01hcFtvbGRJZF0pIHtcbi8vICAgICAgICAgICAgIG9sZElkTGlzdFtpXSA9IGlkSW5kaWNlc01hcFtvbGRJZF07XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICBvbGRJZExpc3RbaV0gPSBpZHgrKztcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vIH1cbmZ1bmN0aW9uIGRpZmZEYXRhKG9sZERhdGEsIG5ld0RhdGEpIHtcbiAgdmFyIGRpZmZSZXN1bHQgPSBbXTtcbiAgbmV3RGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgZGlmZlJlc3VsdC5wdXNoKHtcbiAgICAgIGNtZDogJysnLFxuICAgICAgaWR4OiBpZHhcbiAgICB9KTtcbiAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgIGRpZmZSZXN1bHQucHVzaCh7XG4gICAgICBjbWQ6ICc9JyxcbiAgICAgIGlkeDogb2xkSWR4LFxuICAgICAgaWR4MTogbmV3SWR4XG4gICAgfSk7XG4gIH0pLnJlbW92ZShmdW5jdGlvbiAoaWR4KSB7XG4gICAgZGlmZlJlc3VsdC5wdXNoKHtcbiAgICAgIGNtZDogJy0nLFxuICAgICAgaWR4OiBpZHhcbiAgICB9KTtcbiAgfSkuZXhlY3V0ZSgpO1xuICByZXR1cm4gZGlmZlJlc3VsdDtcbn1cblxuZnVuY3Rpb24gX2RlZmF1bHQob2xkRGF0YSwgbmV3RGF0YSwgb2xkU3RhY2tlZE9uUG9pbnRzLCBuZXdTdGFja2VkT25Qb2ludHMsIG9sZENvb3JkU3lzLCBuZXdDb29yZFN5cywgb2xkVmFsdWVPcmlnaW4sIG5ld1ZhbHVlT3JpZ2luKSB7XG4gIHZhciBkaWZmID0gZGlmZkRhdGEob2xkRGF0YSwgbmV3RGF0YSk7IC8vIHZhciBuZXdJZExpc3QgPSBuZXdEYXRhLm1hcEFycmF5KG5ld0RhdGEuZ2V0SWQpO1xuICAvLyB2YXIgb2xkSWRMaXN0ID0gb2xkRGF0YS5tYXBBcnJheShvbGREYXRhLmdldElkKTtcbiAgLy8gY29udmVydFRvSW50SWQobmV3SWRMaXN0LCBvbGRJZExpc3QpO1xuICAvLyAvLyBGSVhNRSBPbmUgZGF0YSA/XG4gIC8vIGRpZmYgPSBhcnJheURpZmYob2xkSWRMaXN0LCBuZXdJZExpc3QpO1xuXG4gIHZhciBjdXJyUG9pbnRzID0gW107XG4gIHZhciBuZXh0UG9pbnRzID0gW107IC8vIFBvaW50cyBmb3Igc3RhY2tpbmcgYmFzZSBsaW5lXG5cbiAgdmFyIGN1cnJTdGFja2VkUG9pbnRzID0gW107XG4gIHZhciBuZXh0U3RhY2tlZFBvaW50cyA9IFtdO1xuICB2YXIgc3RhdHVzID0gW107XG4gIHZhciBzb3J0ZWRJbmRpY2VzID0gW107XG4gIHZhciByYXdJbmRpY2VzID0gW107XG4gIHZhciBuZXdEYXRhT2xkQ29vcmRJbmZvID0gcHJlcGFyZURhdGFDb29yZEluZm8ob2xkQ29vcmRTeXMsIG5ld0RhdGEsIG9sZFZhbHVlT3JpZ2luKTtcbiAgdmFyIG9sZERhdGFOZXdDb29yZEluZm8gPSBwcmVwYXJlRGF0YUNvb3JkSW5mbyhuZXdDb29yZFN5cywgb2xkRGF0YSwgbmV3VmFsdWVPcmlnaW4pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaWZmSXRlbSA9IGRpZmZbaV07XG4gICAgdmFyIHBvaW50QWRkZWQgPSB0cnVlOyAvLyBGSVhNRSwgYW5pbWF0aW9uIGlzIG5vdCBzbyBwZXJmZWN0IHdoZW4gZGF0YVpvb20gd2luZG93IG1vdmVzIGZhc3RcbiAgICAvLyBXaGljaCBpcyBpbiBjYXNlIHJlbXZvaW5nIG9yIGFkZCBtb3JlIHRoYW4gb25lIGRhdGEgaW4gdGhlIHRhaWwgb3IgaGVhZFxuXG4gICAgc3dpdGNoIChkaWZmSXRlbS5jbWQpIHtcbiAgICAgIGNhc2UgJz0nOlxuICAgICAgICB2YXIgY3VycmVudFB0ID0gb2xkRGF0YS5nZXRJdGVtTGF5b3V0KGRpZmZJdGVtLmlkeCk7XG4gICAgICAgIHZhciBuZXh0UHQgPSBuZXdEYXRhLmdldEl0ZW1MYXlvdXQoZGlmZkl0ZW0uaWR4MSk7IC8vIElmIHByZXZpb3VzIGRhdGEgaXMgTmFOLCB1c2UgbmV4dCBwb2ludCBkaXJlY3RseVxuXG4gICAgICAgIGlmIChpc05hTihjdXJyZW50UHRbMF0pIHx8IGlzTmFOKGN1cnJlbnRQdFsxXSkpIHtcbiAgICAgICAgICBjdXJyZW50UHQgPSBuZXh0UHQuc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJQb2ludHMucHVzaChjdXJyZW50UHQpO1xuICAgICAgICBuZXh0UG9pbnRzLnB1c2gobmV4dFB0KTtcbiAgICAgICAgY3VyclN0YWNrZWRQb2ludHMucHVzaChvbGRTdGFja2VkT25Qb2ludHNbZGlmZkl0ZW0uaWR4XSk7XG4gICAgICAgIG5leHRTdGFja2VkUG9pbnRzLnB1c2gobmV3U3RhY2tlZE9uUG9pbnRzW2RpZmZJdGVtLmlkeDFdKTtcbiAgICAgICAgcmF3SW5kaWNlcy5wdXNoKG5ld0RhdGEuZ2V0UmF3SW5kZXgoZGlmZkl0ZW0uaWR4MSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKyc6XG4gICAgICAgIHZhciBpZHggPSBkaWZmSXRlbS5pZHg7XG4gICAgICAgIGN1cnJQb2ludHMucHVzaChvbGRDb29yZFN5cy5kYXRhVG9Qb2ludChbbmV3RGF0YS5nZXQobmV3RGF0YU9sZENvb3JkSW5mby5kYXRhRGltc0ZvclBvaW50WzBdLCBpZHgpLCBuZXdEYXRhLmdldChuZXdEYXRhT2xkQ29vcmRJbmZvLmRhdGFEaW1zRm9yUG9pbnRbMV0sIGlkeCldKSk7XG4gICAgICAgIG5leHRQb2ludHMucHVzaChuZXdEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KS5zbGljZSgpKTtcbiAgICAgICAgY3VyclN0YWNrZWRQb2ludHMucHVzaChnZXRTdGFja2VkT25Qb2ludChuZXdEYXRhT2xkQ29vcmRJbmZvLCBvbGRDb29yZFN5cywgbmV3RGF0YSwgaWR4KSk7XG4gICAgICAgIG5leHRTdGFja2VkUG9pbnRzLnB1c2gobmV3U3RhY2tlZE9uUG9pbnRzW2lkeF0pO1xuICAgICAgICByYXdJbmRpY2VzLnB1c2gobmV3RGF0YS5nZXRSYXdJbmRleChpZHgpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJy0nOlxuICAgICAgICB2YXIgaWR4ID0gZGlmZkl0ZW0uaWR4O1xuICAgICAgICB2YXIgcmF3SW5kZXggPSBvbGREYXRhLmdldFJhd0luZGV4KGlkeCk7IC8vIERhdGEgaXMgcmVwbGFjZWQuIEluIHRoZSBjYXNlIG9mIGR5bmFtaWMgZGF0YSBxdWV1ZVxuICAgICAgICAvLyBGSVhNRSBGSVhNRSBGSVhNRVxuXG4gICAgICAgIGlmIChyYXdJbmRleCAhPT0gaWR4KSB7XG4gICAgICAgICAgY3VyclBvaW50cy5wdXNoKG9sZERhdGEuZ2V0SXRlbUxheW91dChpZHgpKTtcbiAgICAgICAgICBuZXh0UG9pbnRzLnB1c2gobmV3Q29vcmRTeXMuZGF0YVRvUG9pbnQoW29sZERhdGEuZ2V0KG9sZERhdGFOZXdDb29yZEluZm8uZGF0YURpbXNGb3JQb2ludFswXSwgaWR4KSwgb2xkRGF0YS5nZXQob2xkRGF0YU5ld0Nvb3JkSW5mby5kYXRhRGltc0ZvclBvaW50WzFdLCBpZHgpXSkpO1xuICAgICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2gob2xkU3RhY2tlZE9uUG9pbnRzW2lkeF0pO1xuICAgICAgICAgIG5leHRTdGFja2VkUG9pbnRzLnB1c2goZ2V0U3RhY2tlZE9uUG9pbnQob2xkRGF0YU5ld0Nvb3JkSW5mbywgbmV3Q29vcmRTeXMsIG9sZERhdGEsIGlkeCkpO1xuICAgICAgICAgIHJhd0luZGljZXMucHVzaChyYXdJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRBZGRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICB9IC8vIE9yaWdpbmFsIGluZGljZXNcblxuXG4gICAgaWYgKHBvaW50QWRkZWQpIHtcbiAgICAgIHN0YXR1cy5wdXNoKGRpZmZJdGVtKTtcbiAgICAgIHNvcnRlZEluZGljZXMucHVzaChzb3J0ZWRJbmRpY2VzLmxlbmd0aCk7XG4gICAgfVxuICB9IC8vIERpZmYgcmVzdWx0IG1heSBiZSBjcm9zc2VkIGlmIGFsbCBpdGVtcyBhcmUgY2hhbmdlZFxuICAvLyBTb3J0IGJ5IGRhdGEgaW5kZXhcblxuXG4gIHNvcnRlZEluZGljZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiByYXdJbmRpY2VzW2FdIC0gcmF3SW5kaWNlc1tiXTtcbiAgfSk7XG4gIHZhciBzb3J0ZWRDdXJyUG9pbnRzID0gW107XG4gIHZhciBzb3J0ZWROZXh0UG9pbnRzID0gW107XG4gIHZhciBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50cyA9IFtdO1xuICB2YXIgc29ydGVkTmV4dFN0YWNrZWRQb2ludHMgPSBbXTtcbiAgdmFyIHNvcnRlZFN0YXR1cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc29ydGVkSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZHggPSBzb3J0ZWRJbmRpY2VzW2ldO1xuICAgIHNvcnRlZEN1cnJQb2ludHNbaV0gPSBjdXJyUG9pbnRzW2lkeF07XG4gICAgc29ydGVkTmV4dFBvaW50c1tpXSA9IG5leHRQb2ludHNbaWR4XTtcbiAgICBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50c1tpXSA9IGN1cnJTdGFja2VkUG9pbnRzW2lkeF07XG4gICAgc29ydGVkTmV4dFN0YWNrZWRQb2ludHNbaV0gPSBuZXh0U3RhY2tlZFBvaW50c1tpZHhdO1xuICAgIHNvcnRlZFN0YXR1c1tpXSA9IHN0YXR1c1tpZHhdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBzb3J0ZWRDdXJyUG9pbnRzLFxuICAgIG5leHQ6IHNvcnRlZE5leHRQb2ludHMsXG4gICAgc3RhY2tlZE9uQ3VycmVudDogc29ydGVkQ3VyclN0YWNrZWRQb2ludHMsXG4gICAgc3RhY2tlZE9uTmV4dDogc29ydGVkTmV4dFN0YWNrZWRQb2ludHMsXG4gICAgc3RhdHVzOiBzb3J0ZWRTdGF0dXNcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL2xpbmVBbmltYXRpb25EaWZmLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL2xpbmVBbmltYXRpb25EaWZmLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9QYXRoXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIGZpeENsaXBXaXRoU2hhZG93ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBQb2x5IHBhdGggc3VwcG9ydCBOYU4gcG9pbnRcbnZhciB2ZWMyTWluID0gdmVjMi5taW47XG52YXIgdmVjMk1heCA9IHZlYzIubWF4O1xudmFyIHNjYWxlQW5kQWRkID0gdmVjMi5zY2FsZUFuZEFkZDtcbnZhciB2MkNvcHkgPSB2ZWMyLmNvcHk7IC8vIFRlbXBvcmFyeSB2YXJpYWJsZVxuXG52YXIgdiA9IFtdO1xudmFyIGNwMCA9IFtdO1xudmFyIGNwMSA9IFtdO1xuXG5mdW5jdGlvbiBpc1BvaW50TnVsbChwKSB7XG4gIHJldHVybiBpc05hTihwWzBdKSB8fCBpc05hTihwWzFdKTtcbn1cblxuZnVuY3Rpb24gZHJhd1NlZ21lbnQoY3R4LCBwb2ludHMsIHN0YXJ0LCBzZWdMZW4sIGFsbExlbiwgZGlyLCBzbW9vdGhNaW4sIHNtb290aE1heCwgc21vb3RoLCBzbW9vdGhNb25vdG9uZSwgY29ubmVjdE51bGxzKSB7XG4gIC8vIGlmIChzbW9vdGhNb25vdG9uZSA9PSBudWxsKSB7XG4gIC8vICAgICBpZiAoaXNNb25vKHBvaW50cywgJ3gnKSkge1xuICAvLyAgICAgICAgIHJldHVybiBkcmF3TW9ubyhjdHgsIHBvaW50cywgc3RhcnQsIHNlZ0xlbiwgYWxsTGVuLFxuICAvLyAgICAgICAgICAgICBkaXIsIHNtb290aE1pbiwgc21vb3RoTWF4LCBzbW9vdGgsICd4JywgY29ubmVjdE51bGxzKTtcbiAgLy8gICAgIH1cbiAgLy8gICAgIGVsc2UgaWYgKGlzTW9ubyhwb2ludHMsICd5JykpIHtcbiAgLy8gICAgICAgICByZXR1cm4gZHJhd01vbm8oY3R4LCBwb2ludHMsIHN0YXJ0LCBzZWdMZW4sIGFsbExlbixcbiAgLy8gICAgICAgICAgICAgZGlyLCBzbW9vdGhNaW4sIHNtb290aE1heCwgc21vb3RoLCAneScsIGNvbm5lY3ROdWxscyk7XG4gIC8vICAgICB9XG4gIC8vICAgICBlbHNlIHtcbiAgLy8gICAgICAgICByZXR1cm4gZHJhd05vbk1vbm8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgLy8gICAgIH1cbiAgLy8gfVxuICAvLyBlbHNlIGlmIChzbW9vdGhNb25vdG9uZSAhPT0gJ25vbmUnICYmIGlzTW9ubyhwb2ludHMsIHNtb290aE1vbm90b25lKSkge1xuICAvLyAgICAgcmV0dXJuIGRyYXdNb25vLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIC8vIH1cbiAgLy8gZWxzZSB7XG4gIC8vICAgICByZXR1cm4gZHJhd05vbk1vbm8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgLy8gfVxuICBpZiAoc21vb3RoTW9ub3RvbmUgPT09ICdub25lJyB8fCAhc21vb3RoTW9ub3RvbmUpIHtcbiAgICByZXR1cm4gZHJhd05vbk1vbm8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZHJhd01vbm8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiBwb2ludHMgaXMgaW4gbW9ub3RvbmUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXVtdfSBwb2ludHMgICAgICAgICBBcnJheSBvZiBwb2ludHMgd2hpY2ggaXMgaW4gW3gsIHldIGZvcm1cbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgc21vb3RoTW9ub3RvbmUgJ3gnLCAneScsIG9yICdub25lJywgc3RhdGluZyBmb3Igd2hpY2hcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uIHRoYXQgaXMgY2hlY2tpbmcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGlzICdub25lJywgYGRyYXdOb25Nb25vYCBzaG91bGQgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBpcyB1bmRlZmluZWQsIGVpdGhlciBiZWluZyBtb25vdG9uZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiAneCcgb3IgJ3knIHdpbGwgY2FsbCBgZHJhd01vbm9gLlxuICovXG4vLyBmdW5jdGlvbiBpc01vbm8ocG9pbnRzLCBzbW9vdGhNb25vdG9uZSkge1xuLy8gICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDEpIHtcbi8vICAgICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICAgfVxuLy8gICAgIHZhciBkaW0gPSBzbW9vdGhNb25vdG9uZSA9PT0gJ3gnID8gMCA6IDE7XG4vLyAgICAgdmFyIGxhc3QgPSBwb2ludHNbMF1bZGltXTtcbi8vICAgICB2YXIgbGFzdERpZmYgPSAwO1xuLy8gICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4vLyAgICAgICAgIHZhciBkaWZmID0gcG9pbnRzW2ldW2RpbV0gLSBsYXN0O1xuLy8gICAgICAgICBpZiAoIWlzTmFOKGRpZmYpICYmICFpc05hTihsYXN0RGlmZilcbi8vICAgICAgICAgICAgICYmIGRpZmYgIT09IDAgJiYgbGFzdERpZmYgIT09IDBcbi8vICAgICAgICAgICAgICYmICgoZGlmZiA+PSAwKSAhPT0gKGxhc3REaWZmID49IDApKVxuLy8gICAgICAgICApIHtcbi8vICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBpZiAoIWlzTmFOKGRpZmYpICYmIGRpZmYgIT09IDApIHtcbi8vICAgICAgICAgICAgIGxhc3REaWZmID0gZGlmZjtcbi8vICAgICAgICAgICAgIGxhc3QgPSBwb2ludHNbaV1bZGltXTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICByZXR1cm4gdHJ1ZTtcbi8vIH1cblxuLyoqXG4gKiBEcmF3IHNtb290aGVkIGxpbmUgaW4gbW9ub3RvbmUsIGluIHdoaWNoIG9ubHkgdmVydGljYWwgb3IgaG9yaXpvbnRhbCBiZXppZXJcbiAqIGNvbnRyb2wgcG9pbnRzIHdpbGwgYmUgdXNlZC4gVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIHBvaW50cyBhcmUgbW9ub3RvbmVcbiAqIGVpdGhlciBpbiB4IG9yIHkgZGltZW5zaW9uLlxuICovXG5cblxuZnVuY3Rpb24gZHJhd01vbm8oY3R4LCBwb2ludHMsIHN0YXJ0LCBzZWdMZW4sIGFsbExlbiwgZGlyLCBzbW9vdGhNaW4sIHNtb290aE1heCwgc21vb3RoLCBzbW9vdGhNb25vdG9uZSwgY29ubmVjdE51bGxzKSB7XG4gIHZhciBwcmV2SWR4ID0gMDtcbiAgdmFyIGlkeCA9IHN0YXJ0O1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc2VnTGVuOyBrKyspIHtcbiAgICB2YXIgcCA9IHBvaW50c1tpZHhdO1xuXG4gICAgaWYgKGlkeCA+PSBhbGxMZW4gfHwgaWR4IDwgMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlzUG9pbnROdWxsKHApKSB7XG4gICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaWR4ID09PSBzdGFydCkge1xuICAgICAgY3R4W2RpciA+IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShwWzBdLCBwWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNtb290aCA+IDApIHtcbiAgICAgICAgdmFyIHByZXZQID0gcG9pbnRzW3ByZXZJZHhdO1xuICAgICAgICB2YXIgZGltID0gc21vb3RoTW9ub3RvbmUgPT09ICd5JyA/IDEgOiAwOyAvLyBMZW5ndGggb2YgY29udHJvbCBwb2ludCB0byBwLCBlaXRoZXIgaW4geCBvciB5LCBidXQgbm90IGJvdGhcblxuICAgICAgICB2YXIgY3RybExlbiA9IChwW2RpbV0gLSBwcmV2UFtkaW1dKSAqIHNtb290aDtcbiAgICAgICAgdjJDb3B5KGNwMCwgcHJldlApO1xuICAgICAgICBjcDBbZGltXSA9IHByZXZQW2RpbV0gKyBjdHJsTGVuO1xuICAgICAgICB2MkNvcHkoY3AxLCBwKTtcbiAgICAgICAgY3AxW2RpbV0gPSBwW2RpbV0gLSBjdHJsTGVuO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcDBbMF0sIGNwMFsxXSwgY3AxWzBdLCBjcDFbMV0sIHBbMF0sIHBbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2SWR4ID0gaWR4O1xuICAgIGlkeCArPSBkaXI7XG4gIH1cblxuICByZXR1cm4gaztcbn1cbi8qKlxuICogRHJhdyBzbW9vdGhlZCBsaW5lIGluIG5vbi1tb25vdG9uZSwgaW4gbWF5IGNhdXNlIHVuZGVzaXJlZCBjdXJ2ZSBpbiBleHRyZW1lXG4gKiBzaXR1YXRpb25zLiBUaGlzIHNob3VsZCBiZSB1c2VkIHdoZW4gcG9pbnRzIGFyZSBub24tbW9ub3RvbmUgbmVpdGhlciBpbiB4IG9yXG4gKiB5IGRpbWVuc2lvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRyYXdOb25Nb25vKGN0eCwgcG9pbnRzLCBzdGFydCwgc2VnTGVuLCBhbGxMZW4sIGRpciwgc21vb3RoTWluLCBzbW9vdGhNYXgsIHNtb290aCwgc21vb3RoTW9ub3RvbmUsIGNvbm5lY3ROdWxscykge1xuICB2YXIgcHJldklkeCA9IDA7XG4gIHZhciBpZHggPSBzdGFydDtcblxuICBmb3IgKHZhciBrID0gMDsgayA8IHNlZ0xlbjsgaysrKSB7XG4gICAgdmFyIHAgPSBwb2ludHNbaWR4XTtcblxuICAgIGlmIChpZHggPj0gYWxsTGVuIHx8IGlkeCA8IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpc1BvaW50TnVsbChwKSkge1xuICAgICAgaWYgKGNvbm5lY3ROdWxscykge1xuICAgICAgICBpZHggKz0gZGlyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlkeCA9PT0gc3RhcnQpIHtcbiAgICAgIGN0eFtkaXIgPiAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10ocFswXSwgcFsxXSk7XG4gICAgICB2MkNvcHkoY3AwLCBwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNtb290aCA+IDApIHtcbiAgICAgICAgdmFyIG5leHRJZHggPSBpZHggKyBkaXI7XG4gICAgICAgIHZhciBuZXh0UCA9IHBvaW50c1tuZXh0SWR4XTtcblxuICAgICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgLy8gRmluZCBuZXh0IHBvaW50IG5vdCBudWxsXG4gICAgICAgICAgd2hpbGUgKG5leHRQICYmIGlzUG9pbnROdWxsKHBvaW50c1tuZXh0SWR4XSkpIHtcbiAgICAgICAgICAgIG5leHRJZHggKz0gZGlyO1xuICAgICAgICAgICAgbmV4dFAgPSBwb2ludHNbbmV4dElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhdGlvTmV4dFNlZyA9IDAuNTtcbiAgICAgICAgdmFyIHByZXZQID0gcG9pbnRzW3ByZXZJZHhdO1xuICAgICAgICB2YXIgbmV4dFAgPSBwb2ludHNbbmV4dElkeF07IC8vIExhc3QgcG9pbnRcblxuICAgICAgICBpZiAoIW5leHRQIHx8IGlzUG9pbnROdWxsKG5leHRQKSkge1xuICAgICAgICAgIHYyQ29weShjcDEsIHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5leHQgZGF0YSBpcyBudWxsIGluIG5vdCBjb25uZWN0IGNhc2VcbiAgICAgICAgICBpZiAoaXNQb2ludE51bGwobmV4dFApICYmICFjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAgIG5leHRQID0gcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2ZWMyLnN1Yih2LCBuZXh0UCwgcHJldlApO1xuICAgICAgICAgIHZhciBsZW5QcmV2U2VnO1xuICAgICAgICAgIHZhciBsZW5OZXh0U2VnO1xuXG4gICAgICAgICAgaWYgKHNtb290aE1vbm90b25lID09PSAneCcgfHwgc21vb3RoTW9ub3RvbmUgPT09ICd5Jykge1xuICAgICAgICAgICAgdmFyIGRpbSA9IHNtb290aE1vbm90b25lID09PSAneCcgPyAwIDogMTtcbiAgICAgICAgICAgIGxlblByZXZTZWcgPSBNYXRoLmFicyhwW2RpbV0gLSBwcmV2UFtkaW1dKTtcbiAgICAgICAgICAgIGxlbk5leHRTZWcgPSBNYXRoLmFicyhwW2RpbV0gLSBuZXh0UFtkaW1dKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuUHJldlNlZyA9IHZlYzIuZGlzdChwLCBwcmV2UCk7XG4gICAgICAgICAgICBsZW5OZXh0U2VnID0gdmVjMi5kaXN0KHAsIG5leHRQKTtcbiAgICAgICAgICB9IC8vIFVzZSByYXRpbyBvZiBzZWcgbGVuZ3RoXG5cblxuICAgICAgICAgIHJhdGlvTmV4dFNlZyA9IGxlbk5leHRTZWcgLyAobGVuTmV4dFNlZyArIGxlblByZXZTZWcpO1xuICAgICAgICAgIHNjYWxlQW5kQWRkKGNwMSwgcCwgdiwgLXNtb290aCAqICgxIC0gcmF0aW9OZXh0U2VnKSk7XG4gICAgICAgIH0gLy8gU21vb3RoIGNvbnN0cmFpbnRcblxuXG4gICAgICAgIHZlYzJNaW4oY3AwLCBjcDAsIHNtb290aE1heCk7XG4gICAgICAgIHZlYzJNYXgoY3AwLCBjcDAsIHNtb290aE1pbik7XG4gICAgICAgIHZlYzJNaW4oY3AxLCBjcDEsIHNtb290aE1heCk7XG4gICAgICAgIHZlYzJNYXgoY3AxLCBjcDEsIHNtb290aE1pbik7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNwMFswXSwgY3AwWzFdLCBjcDFbMF0sIGNwMVsxXSwgcFswXSwgcFsxXSk7IC8vIGNwMCBvZiBuZXh0IHNlZ21lbnRcblxuICAgICAgICBzY2FsZUFuZEFkZChjcDAsIHAsIHYsIHNtb290aCAqIHJhdGlvTmV4dFNlZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZJZHggPSBpZHg7XG4gICAgaWR4ICs9IGRpcjtcbiAgfVxuXG4gIHJldHVybiBrO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0JveChwb2ludHMsIHNtb290aENvbnN0cmFpbnQpIHtcbiAgdmFyIHB0TWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gIHZhciBwdE1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgaWYgKHNtb290aENvbnN0cmFpbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuXG4gICAgICBpZiAocHRbMF0gPCBwdE1pblswXSkge1xuICAgICAgICBwdE1pblswXSA9IHB0WzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHRbMV0gPCBwdE1pblsxXSkge1xuICAgICAgICBwdE1pblsxXSA9IHB0WzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHRbMF0gPiBwdE1heFswXSkge1xuICAgICAgICBwdE1heFswXSA9IHB0WzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHRbMV0gPiBwdE1heFsxXSkge1xuICAgICAgICBwdE1heFsxXSA9IHB0WzFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiBzbW9vdGhDb25zdHJhaW50ID8gcHRNaW4gOiBwdE1heCxcbiAgICBtYXg6IHNtb290aENvbnN0cmFpbnQgPyBwdE1heCA6IHB0TWluXG4gIH07XG59XG5cbnZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2VjLXBvbHlsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IFtdLFxuICAgIHNtb290aDogMCxcbiAgICBzbW9vdGhDb25zdHJhaW50OiB0cnVlLFxuICAgIHNtb290aE1vbm90b25lOiBudWxsLFxuICAgIGNvbm5lY3ROdWxsczogZmFsc2VcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBmaWxsOiBudWxsLFxuICAgIHN0cm9rZTogJyMwMDAnXG4gIH0sXG4gIGJydXNoOiBmaXhDbGlwV2l0aFNoYWRvdyhQYXRoLnByb3RvdHlwZS5icnVzaCksXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gZ2V0Qm91bmRpbmdCb3gocG9pbnRzLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcblxuICAgIGlmIChzaGFwZS5jb25uZWN0TnVsbHMpIHtcbiAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgZm9yICg7IGxlbiA+IDA7IGxlbi0tKSB7XG4gICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAtIDFdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc1BvaW50TnVsbChwb2ludHNbaV0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaSArPSBkcmF3U2VnbWVudChjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sIDEsIHJlc3VsdC5taW4sIHJlc3VsdC5tYXgsIHNoYXBlLnNtb290aCwgc2hhcGUuc21vb3RoTW9ub3RvbmUsIHNoYXBlLmNvbm5lY3ROdWxscykgKyAxO1xuICAgIH1cbiAgfVxufSk7XG52YXIgUG9seWdvbiA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2VjLXBvbHlnb24nLFxuICBzaGFwZToge1xuICAgIHBvaW50czogW10sXG4gICAgLy8gT2Zmc2V0IGJldHdlZW4gc3RhY2tlZCBiYXNlIHBvaW50cyBhbmQgcG9pbnRzXG4gICAgc3RhY2tlZE9uUG9pbnRzOiBbXSxcbiAgICBzbW9vdGg6IDAsXG4gICAgc3RhY2tlZE9uU21vb3RoOiAwLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IHRydWUsXG4gICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG4gICAgY29ubmVjdE51bGxzOiBmYWxzZVxuICB9LFxuICBicnVzaDogZml4Q2xpcFdpdGhTaGFkb3coUGF0aC5wcm90b3R5cGUuYnJ1c2gpLFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICB2YXIgc3RhY2tlZE9uUG9pbnRzID0gc2hhcGUuc3RhY2tlZE9uUG9pbnRzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgc21vb3RoTW9ub3RvbmUgPSBzaGFwZS5zbW9vdGhNb25vdG9uZTtcbiAgICB2YXIgYmJveCA9IGdldEJvdW5kaW5nQm94KHBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG4gICAgdmFyIHN0YWNrZWRPbkJCb3ggPSBnZXRCb3VuZGluZ0JveChzdGFja2VkT25Qb2ludHMsIHNoYXBlLnNtb290aENvbnN0cmFpbnQpO1xuXG4gICAgaWYgKHNoYXBlLmNvbm5lY3ROdWxscykge1xuICAgICAgLy8gTXVzdCByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbnVsbCB2YWx1ZXMgYXZvaWQgZHJhdyBlcnJvciBpbiBwb2x5Z29uXG4gICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgaWYgKCFpc1BvaW50TnVsbChwb2ludHNbbGVuIC0gMV0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWlzUG9pbnROdWxsKHBvaW50c1tpXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YXIgayA9IGRyYXdTZWdtZW50KGN0eCwgcG9pbnRzLCBpLCBsZW4sIGxlbiwgMSwgYmJveC5taW4sIGJib3gubWF4LCBzaGFwZS5zbW9vdGgsIHNtb290aE1vbm90b25lLCBzaGFwZS5jb25uZWN0TnVsbHMpO1xuICAgICAgZHJhd1NlZ21lbnQoY3R4LCBzdGFja2VkT25Qb2ludHMsIGkgKyBrIC0gMSwgaywgbGVuLCAtMSwgc3RhY2tlZE9uQkJveC5taW4sIHN0YWNrZWRPbkJCb3gubWF4LCBzaGFwZS5zdGFja2VkT25TbW9vdGgsIHNtb290aE1vbm90b25lLCBzaGFwZS5jb25uZWN0TnVsbHMpO1xuICAgICAgaSArPSBrICsgMTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbn0pO1xuZXhwb3J0cy5Qb2x5bGluZSA9IFBvbHlsaW5lO1xuZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL3BvbHkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvcG9seS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInJlcXVpcmUoXCIuLi9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9heGlzL0NhcnRlc2lhbkF4aXNWaWV3XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciByZXRyaWV2ZSA9IF91dGlsLnJldHJpZXZlO1xudmFyIGRlZmF1bHRzID0gX3V0aWwuZGVmYXVsdHM7XG52YXIgZXh0ZW5kID0gX3V0aWwuZXh0ZW5kO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTW9kZWxcIik7XG5cbnZhciBfbnVtYmVyID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgaXNSYWRpYW5Bcm91bmRaZXJvID0gX251bWJlci5pc1JhZGlhbkFyb3VuZFplcm87XG52YXIgcmVtUmFkaWFuID0gX251bWJlci5yZW1SYWRpYW47XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvc3ltYm9sXCIpO1xuXG52YXIgY3JlYXRlU3ltYm9sID0gX3N5bWJvbC5jcmVhdGVTeW1ib2w7XG5cbnZhciBtYXRyaXhVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSBfdmVjdG9yLmFwcGx5VHJhbnNmb3JtO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgUEkgPSBNYXRoLlBJO1xuXG5mdW5jdGlvbiBtYWtlQXhpc0V2ZW50RGF0YUJhc2UoYXhpc01vZGVsKSB7XG4gIHZhciBldmVudERhdGEgPSB7XG4gICAgY29tcG9uZW50VHlwZTogYXhpc01vZGVsLm1haW5UeXBlXG4gIH07XG4gIGV2ZW50RGF0YVtheGlzTW9kZWwubWFpblR5cGUgKyAnSW5kZXgnXSA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcbiAgcmV0dXJuIGV2ZW50RGF0YTtcbn1cbi8qKlxuICogQSBmaW5hbCBheGlzIGlzIHRyYW5zbGF0ZWQgYW5kIHJvdGF0ZWQgZnJvbSBhIFwic3RhbmRhcmQgYXhpc1wiLlxuICogU28gb3B0LnBvc2l0aW9uIGFuZCBvcHQucm90YXRpb24gaXMgcmVxdWlyZWQuXG4gKlxuICogQSBzdGFuZGFyZCBheGlzIGlzIGFuZCBheGlzIGZyb20gWzAsIDBdIHRvIFswLCBheGlzRXh0ZW50WzFdXSxcbiAqIGZvciBleGFtcGxlOiAoMCwgMCkgLS0tLS0tLS0tLS0tPiAoMCwgNTApXG4gKlxuICogbmFtZURpcmVjdGlvbiBvciB0aWNrRGlyZWN0aW9uIG9yIGxhYmVsRGlyZWN0aW9uIGlzIDEgbWVhbnMgdGlja1xuICogb3IgbGFiZWwgaXMgYmVsb3cgdGhlIHN0YW5kYXJkIGF4aXMsIHdoZXJlYXMgaXMgLTEgbWVhbnMgYWJvdmVcbiAqIHRoZSBzdGFuZGFyZCBheGlzLiBsYWJlbE9mZnNldCBtZWFucyBvZmZzZXQgYmV0d2VlbiBsYWJlbCBhbmQgYXhpcyxcbiAqIHdoaWNoIGlzIHVzZWZ1bCB3aGVuICdvblplcm8nLCB3aGVyZSBheGlzTGFiZWwgaXMgaW4gdGhlIGdyaWQgYW5kXG4gKiBsYWJlbCBpbiBvdXRzaWRlIGdyaWQuXG4gKlxuICogVGlwczogbGlrZSBhbHdheXMsXG4gKiBwb3NpdGl2ZSByb3RhdGlvbiByZXByZXNlbnRzIGFudGljbG9ja3dpc2UsIGFuZCBuZWdhdGl2ZSByb3RhdGlvblxuICogcmVwcmVzZW50cyBjbG9ja3dpc2UuXG4gKiBUaGUgZGlyZWN0aW9uIG9mIHBvc2l0aW9uIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIGRpcmVjdGlvblxuICogb2Ygc2NyZWVuIGNvb3JkaW5hdGUuXG4gKlxuICogRG8gbm90IG5lZWQgdG8gY29uc2lkZXIgYXhpcyAnaW52ZXJzZScsIHdoaWNoIGlzIGF1dG8gcHJvY2Vzc2VkIGJ5XG4gKiBheGlzIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBheGlzTW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgU3RhbmRhcmQgYXhpcyBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3B0LnBvc2l0aW9uIFt4LCB5XVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdC5yb3RhdGlvbiBieSByYWRpYW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0Lm5hbWVEaXJlY3Rpb249MV0gMSBvciAtMSBVc2VkIHdoZW4gbmFtZUxvY2F0aW9uIGlzICdtaWRkbGUnIG9yICdjZW50ZXInLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQudGlja0RpcmVjdGlvbj0xXSAxIG9yIC0xXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbERpcmVjdGlvbj0xXSAxIG9yIC0xXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbE9mZnNldD0wXSBVc2VmdWxsIHdoZW4gb25aZXJvLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuYXhpc0xhYmVsU2hvd10gZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdC5heGlzTmFtZV0gZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5heGlzTmFtZUF2YWlsYWJsZVdpZHRoXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxSb3RhdGVdIGJ5IGRlZ3JlZSwgZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdHJva2VDb250YWluVGhyZXNob2xkXSBEZWZhdWx0IGxhYmVsIGludGVydmFsIHdoZW4gbGFiZWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0Lm5hbWVUcnVuY2F0ZU1heFdpZHRoXVxuICovXG5cblxudmFyIEF4aXNCdWlsZGVyID0gZnVuY3Rpb24gKGF4aXNNb2RlbCwgb3B0KSB7XG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHRoaXMub3B0ID0gb3B0O1xuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqL1xuXG4gIHRoaXMuYXhpc01vZGVsID0gYXhpc01vZGVsOyAvLyBEZWZhdWx0IHZhbHVlXG5cbiAgZGVmYXVsdHMob3B0LCB7XG4gICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgbmFtZURpcmVjdGlvbjogMSxcbiAgICB0aWNrRGlyZWN0aW9uOiAxLFxuICAgIGxhYmVsRGlyZWN0aW9uOiAxLFxuICAgIHNpbGVudDogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTsgLy8gRklYTUUgTm90IHVzZSBhIHNlcGVyYXRlIHRleHQgZ3JvdXA/XG5cbiAgdmFyIGR1bWJHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKHtcbiAgICBwb3NpdGlvbjogb3B0LnBvc2l0aW9uLnNsaWNlKCksXG4gICAgcm90YXRpb246IG9wdC5yb3RhdGlvblxuICB9KTsgLy8gdGhpcy5ncm91cC5hZGQoZHVtYkdyb3VwKTtcbiAgLy8gdGhpcy5fZHVtYkdyb3VwID0gZHVtYkdyb3VwO1xuXG4gIGR1bWJHcm91cC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgdGhpcy5fdHJhbnNmb3JtID0gZHVtYkdyb3VwLnRyYW5zZm9ybTtcbiAgdGhpcy5fZHVtYkdyb3VwID0gZHVtYkdyb3VwO1xufTtcblxuQXhpc0J1aWxkZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQXhpc0J1aWxkZXIsXG4gIGhhc0J1aWxkZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhYnVpbGRlcnNbbmFtZV07XG4gIH0sXG4gIGFkZDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBidWlsZGVyc1tuYW1lXS5jYWxsKHRoaXMpO1xuICB9LFxuICBnZXRHcm91cDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdyb3VwO1xuICB9XG59O1xudmFyIGJ1aWxkZXJzID0ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF4aXNMaW5lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcblxuICAgIGlmICghYXhpc01vZGVsLmdldCgnYXhpc0xpbmUuc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV4dGVudCA9IHRoaXMuYXhpc01vZGVsLmF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIG1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB2YXIgcHQxID0gW2V4dGVudFswXSwgMF07XG4gICAgdmFyIHB0MiA9IFtleHRlbnRbMV0sIDBdO1xuXG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDEsIHB0MSwgbWF0cml4KTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQyLCBwdDIsIG1hdHJpeCk7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVTdHlsZSA9IGV4dGVuZCh7XG4gICAgICBsaW5lQ2FwOiAncm91bmQnXG4gICAgfSwgYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGluZS5saW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSk7XG4gICAgdGhpcy5ncm91cC5hZGQobmV3IGdyYXBoaWMuTGluZShncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKHtcbiAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgIGFuaWQ6ICdsaW5lJyxcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHgxOiBwdDFbMF0sXG4gICAgICAgIHkxOiBwdDFbMV0sXG4gICAgICAgIHgyOiBwdDJbMF0sXG4gICAgICAgIHkyOiBwdDJbMV1cbiAgICAgIH0sXG4gICAgICBzdHlsZTogbGluZVN0eWxlLFxuICAgICAgc3Ryb2tlQ29udGFpblRocmVzaG9sZDogb3B0LnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQgfHwgNSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIHoyOiAxXG4gICAgfSkpKTtcbiAgICB2YXIgYXJyb3dzID0gYXhpc01vZGVsLmdldCgnYXhpc0xpbmUuc3ltYm9sJyk7XG4gICAgdmFyIGFycm93U2l6ZSA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLnN5bWJvbFNpemUnKTtcbiAgICB2YXIgYXJyb3dPZmZzZXQgPSBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5zeW1ib2xPZmZzZXQnKSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiBhcnJvd09mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFycm93T2Zmc2V0ID0gW2Fycm93T2Zmc2V0LCBhcnJvd09mZnNldF07XG4gICAgfVxuXG4gICAgaWYgKGFycm93cyAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGFycm93cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGFycm93IGZvciBzdGFydCBhbmQgZW5kIHBvaW50XG4gICAgICAgIGFycm93cyA9IFthcnJvd3MsIGFycm93c107XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYXJyb3dTaXplID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJyb3dTaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBVc2UgdGhlIHNhbWUgc2l6ZSBmb3Igd2lkdGggYW5kIGhlaWdodFxuICAgICAgICBhcnJvd1NpemUgPSBbYXJyb3dTaXplLCBhcnJvd1NpemVdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3ltYm9sV2lkdGggPSBhcnJvd1NpemVbMF07XG4gICAgICB2YXIgc3ltYm9sSGVpZ2h0ID0gYXJyb3dTaXplWzFdO1xuICAgICAgZWFjaChbe1xuICAgICAgICByb3RhdGU6IG9wdC5yb3RhdGlvbiArIE1hdGguUEkgLyAyLFxuICAgICAgICBvZmZzZXQ6IGFycm93T2Zmc2V0WzBdLFxuICAgICAgICByOiAwXG4gICAgICB9LCB7XG4gICAgICAgIHJvdGF0ZTogb3B0LnJvdGF0aW9uIC0gTWF0aC5QSSAvIDIsXG4gICAgICAgIG9mZnNldDogYXJyb3dPZmZzZXRbMV0sXG4gICAgICAgIHI6IE1hdGguc3FydCgocHQxWzBdIC0gcHQyWzBdKSAqIChwdDFbMF0gLSBwdDJbMF0pICsgKHB0MVsxXSAtIHB0MlsxXSkgKiAocHQxWzFdIC0gcHQyWzFdKSlcbiAgICAgIH1dLCBmdW5jdGlvbiAocG9pbnQsIGluZGV4KSB7XG4gICAgICAgIGlmIChhcnJvd3NbaW5kZXhdICE9PSAnbm9uZScgJiYgYXJyb3dzW2luZGV4XSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZVN5bWJvbChhcnJvd3NbaW5kZXhdLCAtc3ltYm9sV2lkdGggLyAyLCAtc3ltYm9sSGVpZ2h0IC8gMiwgc3ltYm9sV2lkdGgsIHN5bWJvbEhlaWdodCwgbGluZVN0eWxlLnN0cm9rZSwgdHJ1ZSk7IC8vIENhbGN1bGF0ZSBhcnJvdyBwb3NpdGlvbiB3aXRoIG9mZnNldFxuXG4gICAgICAgICAgdmFyIHIgPSBwb2ludC5yICsgcG9pbnQub2Zmc2V0O1xuICAgICAgICAgIHZhciBwb3MgPSBbcHQxWzBdICsgciAqIE1hdGguY29zKG9wdC5yb3RhdGlvbiksIHB0MVsxXSAtIHIgKiBNYXRoLnNpbihvcHQucm90YXRpb24pXTtcbiAgICAgICAgICBzeW1ib2wuYXR0cih7XG4gICAgICAgICAgICByb3RhdGlvbjogcG9pbnQucm90YXRlLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF4aXNUaWNrTGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG4gICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuICAgIHZhciB0aWNrRWxzID0gYnVpbGRBeGlzVGljayh0aGlzLCBheGlzTW9kZWwsIG9wdCk7XG4gICAgdmFyIGxhYmVsRWxzID0gYnVpbGRBeGlzTGFiZWwodGhpcywgYXhpc01vZGVsLCBvcHQpO1xuICAgIGZpeE1pbk1heExhYmVsU2hvdyhheGlzTW9kZWwsIGxhYmVsRWxzLCB0aWNrRWxzKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF4aXNOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcbiAgICB2YXIgbmFtZSA9IHJldHJpZXZlKG9wdC5heGlzTmFtZSwgYXhpc01vZGVsLmdldCgnbmFtZScpKTtcblxuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuYW1lTG9jYXRpb24gPSBheGlzTW9kZWwuZ2V0KCduYW1lTG9jYXRpb24nKTtcbiAgICB2YXIgbmFtZURpcmVjdGlvbiA9IG9wdC5uYW1lRGlyZWN0aW9uO1xuICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnbmFtZVRleHRTdHlsZScpO1xuICAgIHZhciBnYXAgPSBheGlzTW9kZWwuZ2V0KCduYW1lR2FwJykgfHwgMDtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5heGlzTW9kZWwuYXhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgZ2FwU2lnbmFsID0gZXh0ZW50WzBdID4gZXh0ZW50WzFdID8gLTEgOiAxO1xuICAgIHZhciBwb3MgPSBbbmFtZUxvY2F0aW9uID09PSAnc3RhcnQnID8gZXh0ZW50WzBdIC0gZ2FwU2lnbmFsICogZ2FwIDogbmFtZUxvY2F0aW9uID09PSAnZW5kJyA/IGV4dGVudFsxXSArIGdhcFNpZ25hbCAqIGdhcCA6IChleHRlbnRbMF0gKyBleHRlbnRbMV0pIC8gMiwgLy8gJ21pZGRsZSdcbiAgICAvLyBSZXVzZSBsYWJlbE9mZnNldC5cbiAgICBpc05hbWVMb2NhdGlvbkNlbnRlcihuYW1lTG9jYXRpb24pID8gb3B0LmxhYmVsT2Zmc2V0ICsgbmFtZURpcmVjdGlvbiAqIGdhcCA6IDBdO1xuICAgIHZhciBsYWJlbExheW91dDtcbiAgICB2YXIgbmFtZVJvdGF0aW9uID0gYXhpc01vZGVsLmdldCgnbmFtZVJvdGF0ZScpO1xuXG4gICAgaWYgKG5hbWVSb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICBuYW1lUm90YXRpb24gPSBuYW1lUm90YXRpb24gKiBQSSAvIDE4MDsgLy8gVG8gcmFkaWFuLlxuICAgIH1cblxuICAgIHZhciBheGlzTmFtZUF2YWlsYWJsZVdpZHRoO1xuXG4gICAgaWYgKGlzTmFtZUxvY2F0aW9uQ2VudGVyKG5hbWVMb2NhdGlvbikpIHtcbiAgICAgIGxhYmVsTGF5b3V0ID0gaW5uZXJUZXh0TGF5b3V0KG9wdC5yb3RhdGlvbiwgbmFtZVJvdGF0aW9uICE9IG51bGwgPyBuYW1lUm90YXRpb24gOiBvcHQucm90YXRpb24sIC8vIEFkYXB0IHRvIGF4aXMuXG4gICAgICBuYW1lRGlyZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWxMYXlvdXQgPSBlbmRUZXh0TGF5b3V0KG9wdCwgbmFtZUxvY2F0aW9uLCBuYW1lUm90YXRpb24gfHwgMCwgZXh0ZW50KTtcbiAgICAgIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggPSBvcHQuYXhpc05hbWVBdmFpbGFibGVXaWR0aDtcblxuICAgICAgaWYgKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggIT0gbnVsbCkge1xuICAgICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gTWF0aC5hYnMoYXhpc05hbWVBdmFpbGFibGVXaWR0aCAvIE1hdGguc2luKGxhYmVsTGF5b3V0LnJvdGF0aW9uKSk7XG4gICAgICAgICFpc0Zpbml0ZShheGlzTmFtZUF2YWlsYWJsZVdpZHRoKSAmJiAoYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXh0Rm9udCA9IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKTtcbiAgICB2YXIgdHJ1bmNhdGVPcHQgPSBheGlzTW9kZWwuZ2V0KCduYW1lVHJ1bmNhdGUnLCB0cnVlKSB8fCB7fTtcbiAgICB2YXIgZWxsaXBzaXMgPSB0cnVuY2F0ZU9wdC5lbGxpcHNpcztcbiAgICB2YXIgbWF4V2lkdGggPSByZXRyaWV2ZShvcHQubmFtZVRydW5jYXRlTWF4V2lkdGgsIHRydW5jYXRlT3B0Lm1heFdpZHRoLCBheGlzTmFtZUF2YWlsYWJsZVdpZHRoKTsgLy8gRklYTUVcbiAgICAvLyB0cnVuY2F0ZSByaWNoIHRleHQ/IChjb25zaWRlciBwZXJmb3JtYW5jZSlcblxuICAgIHZhciB0cnVuY2F0ZWRUZXh0ID0gZWxsaXBzaXMgIT0gbnVsbCAmJiBtYXhXaWR0aCAhPSBudWxsID8gZm9ybWF0VXRpbC50cnVuY2F0ZVRleHQobmFtZSwgbWF4V2lkdGgsIHRleHRGb250LCBlbGxpcHNpcywge1xuICAgICAgbWluQ2hhcjogMixcbiAgICAgIHBsYWNlaG9sZGVyOiB0cnVuY2F0ZU9wdC5wbGFjZWhvbGRlclxuICAgIH0pIDogbmFtZTtcbiAgICB2YXIgdG9vbHRpcE9wdCA9IGF4aXNNb2RlbC5nZXQoJ3Rvb2x0aXAnLCB0cnVlKTtcbiAgICB2YXIgbWFpblR5cGUgPSBheGlzTW9kZWwubWFpblR5cGU7XG4gICAgdmFyIGZvcm1hdHRlclBhcmFtcyA9IHtcbiAgICAgIGNvbXBvbmVudFR5cGU6IG1haW5UeXBlLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgICR2YXJzOiBbJ25hbWUnXVxuICAgIH07XG4gICAgZm9ybWF0dGVyUGFyYW1zW21haW5UeXBlICsgJ0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgICAgYW5pZDogJ25hbWUnLFxuICAgICAgX19mdWxsVGV4dDogbmFtZSxcbiAgICAgIF9fdHJ1bmNhdGVkVGV4dDogdHJ1bmNhdGVkVGV4dCxcbiAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgICBzaWxlbnQ6IGlzU2lsZW50KGF4aXNNb2RlbCksXG4gICAgICB6MjogMSxcbiAgICAgIHRvb2x0aXA6IHRvb2x0aXBPcHQgJiYgdG9vbHRpcE9wdC5zaG93ID8gZXh0ZW5kKHtcbiAgICAgICAgY29udGVudDogbmFtZSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlclBhcmFtczogZm9ybWF0dGVyUGFyYW1zXG4gICAgICB9LCB0b29sdGlwT3B0KSA6IG51bGxcbiAgICB9KTtcbiAgICBncmFwaGljLnNldFRleHRTdHlsZSh0ZXh0RWwuc3R5bGUsIHRleHRTdHlsZU1vZGVsLCB7XG4gICAgICB0ZXh0OiB0cnVuY2F0ZWRUZXh0LFxuICAgICAgdGV4dEZvbnQ6IHRleHRGb250LFxuICAgICAgdGV4dEZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpIHx8IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpLFxuICAgICAgdGV4dEFsaWduOiBsYWJlbExheW91dC50ZXh0QWxpZ24sXG4gICAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWxMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ25cbiAgICB9KTtcblxuICAgIGlmIChheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKSkge1xuICAgICAgdGV4dEVsLmV2ZW50RGF0YSA9IG1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgdGV4dEVsLmV2ZW50RGF0YS50YXJnZXRUeXBlID0gJ2F4aXNOYW1lJztcbiAgICAgIHRleHRFbC5ldmVudERhdGEubmFtZSA9IG5hbWU7XG4gICAgfSAvLyBGSVhNRVxuXG5cbiAgICB0aGlzLl9kdW1iR3JvdXAuYWRkKHRleHRFbCk7XG5cbiAgICB0ZXh0RWwudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5ncm91cC5hZGQodGV4dEVsKTtcbiAgICB0ZXh0RWwuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gIH1cbn07XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzUm90YXRpb24gaW4gcmFkaWFuXG4gKiBAcGFyYW0ge251bWJlcn0gdGV4dFJvdGF0aW9uIGluIHJhZGlhblxuICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvblxuICogQHJldHVybiB7T2JqZWN0fSB7XG4gKiAgcm90YXRpb24sIC8vIGFjY29yZGluZyB0byBheGlzXG4gKiAgdGV4dEFsaWduLFxuICogIHRleHRWZXJ0aWNhbEFsaWduXG4gKiB9XG4gKi9cblxudmFyIGlubmVyVGV4dExheW91dCA9IEF4aXNCdWlsZGVyLmlubmVyVGV4dExheW91dCA9IGZ1bmN0aW9uIChheGlzUm90YXRpb24sIHRleHRSb3RhdGlvbiwgZGlyZWN0aW9uKSB7XG4gIHZhciByb3RhdGlvbkRpZmYgPSByZW1SYWRpYW4odGV4dFJvdGF0aW9uIC0gYXhpc1JvdGF0aW9uKTtcbiAgdmFyIHRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduO1xuXG4gIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmKSkge1xuICAgIC8vIExhYmVsIGlzIHBhcmFsbGVsIHdpdGggYXhpcyBsaW5lLlxuICAgIHRleHRWZXJ0aWNhbEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJKSkge1xuICAgIC8vIExhYmVsIGlzIGludmVyc2UgcGFyYWxsZWwgd2l0aCBheGlzIGxpbmUuXG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgfSBlbHNlIHtcbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuXG4gICAgaWYgKHJvdGF0aW9uRGlmZiA+IDAgJiYgcm90YXRpb25EaWZmIDwgUEkpIHtcbiAgICAgIHRleHRBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdGF0aW9uOiByb3RhdGlvbkRpZmYsXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59O1xuXG5mdW5jdGlvbiBlbmRUZXh0TGF5b3V0KG9wdCwgdGV4dFBvc2l0aW9uLCB0ZXh0Um90YXRlLCBleHRlbnQpIHtcbiAgdmFyIHJvdGF0aW9uRGlmZiA9IHJlbVJhZGlhbih0ZXh0Um90YXRlIC0gb3B0LnJvdGF0aW9uKTtcbiAgdmFyIHRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduO1xuICB2YXIgaW52ZXJzZSA9IGV4dGVudFswXSA+IGV4dGVudFsxXTtcbiAgdmFyIG9uTGVmdCA9IHRleHRQb3NpdGlvbiA9PT0gJ3N0YXJ0JyAmJiAhaW52ZXJzZSB8fCB0ZXh0UG9zaXRpb24gIT09ICdzdGFydCcgJiYgaW52ZXJzZTtcblxuICBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJIC8gMikpIHtcbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9IG9uTGVmdCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJICogMS41KSkge1xuICAgIHRleHRWZXJ0aWNhbEFsaWduID0gb25MZWZ0ID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgfSBlbHNlIHtcbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuXG4gICAgaWYgKHJvdGF0aW9uRGlmZiA8IFBJICogMS41ICYmIHJvdGF0aW9uRGlmZiA+IFBJIC8gMikge1xuICAgICAgdGV4dEFsaWduID0gb25MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gb25MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdGF0aW9uOiByb3RhdGlvbkRpZmYsXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU2lsZW50KGF4aXNNb2RlbCkge1xuICB2YXIgdG9vbHRpcE9wdCA9IGF4aXNNb2RlbC5nZXQoJ3Rvb2x0aXAnKTtcbiAgcmV0dXJuIGF4aXNNb2RlbC5nZXQoJ3NpbGVudCcpIC8vIENvbnNpZGVyIG1vdXNlIGN1cnNvciwgYWRkIHRoZXNlIHJlc3RyaWN0aW9ucy5cbiAgfHwgIShheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKSB8fCB0b29sdGlwT3B0ICYmIHRvb2x0aXBPcHQuc2hvdyk7XG59XG5cbmZ1bmN0aW9uIGZpeE1pbk1heExhYmVsU2hvdyhheGlzTW9kZWwsIGxhYmVsRWxzLCB0aWNrRWxzKSB7XG4gIC8vIElmIG1pbiBvciBtYXggYXJlIHVzZXIgc2V0LCB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIElmIHRoZSB0aWNrIG9uIG1pbihtYXgpIGFyZSBvdmVybGFwIG9uIHRoZWlyIG5laWdoYm91ciB0aWNrXG4gIC8vIElmIHRoZXkgYXJlIG92ZXJsYXBwZWQsIHdlIG5lZWQgdG8gaGlkZSB0aGUgbWluKG1heCkgdGljayBsYWJlbFxuICB2YXIgc2hvd01pbkxhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNaW5MYWJlbCcpO1xuICB2YXIgc2hvd01heExhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNYXhMYWJlbCcpOyAvLyBGSVhNRVxuICAvLyBIYXZlIG5vdCBjb25zaWRlciBvbkJhbmQgeWV0LCB3aGVyZSB0aWNrIGVscyBpcyBtb3JlIHRoYW4gbGFiZWwgZWxzLlxuXG4gIGxhYmVsRWxzID0gbGFiZWxFbHMgfHwgW107XG4gIHRpY2tFbHMgPSB0aWNrRWxzIHx8IFtdO1xuICB2YXIgZmlyc3RMYWJlbCA9IGxhYmVsRWxzWzBdO1xuICB2YXIgbmV4dExhYmVsID0gbGFiZWxFbHNbMV07XG4gIHZhciBsYXN0TGFiZWwgPSBsYWJlbEVsc1tsYWJlbEVscy5sZW5ndGggLSAxXTtcbiAgdmFyIHByZXZMYWJlbCA9IGxhYmVsRWxzW2xhYmVsRWxzLmxlbmd0aCAtIDJdO1xuICB2YXIgZmlyc3RUaWNrID0gdGlja0Vsc1swXTtcbiAgdmFyIG5leHRUaWNrID0gdGlja0Vsc1sxXTtcbiAgdmFyIGxhc3RUaWNrID0gdGlja0Vsc1t0aWNrRWxzLmxlbmd0aCAtIDFdO1xuICB2YXIgcHJldlRpY2sgPSB0aWNrRWxzW3RpY2tFbHMubGVuZ3RoIC0gMl07XG5cbiAgaWYgKHNob3dNaW5MYWJlbCA9PT0gZmFsc2UpIHtcbiAgICBpZ25vcmVFbChmaXJzdExhYmVsKTtcbiAgICBpZ25vcmVFbChmaXJzdFRpY2spO1xuICB9IGVsc2UgaWYgKGlzVHdvTGFiZWxPdmVybGFwcGVkKGZpcnN0TGFiZWwsIG5leHRMYWJlbCkpIHtcbiAgICBpZiAoc2hvd01pbkxhYmVsKSB7XG4gICAgICBpZ25vcmVFbChuZXh0TGFiZWwpO1xuICAgICAgaWdub3JlRWwobmV4dFRpY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZ25vcmVFbChmaXJzdExhYmVsKTtcbiAgICAgIGlnbm9yZUVsKGZpcnN0VGljayk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNob3dNYXhMYWJlbCA9PT0gZmFsc2UpIHtcbiAgICBpZ25vcmVFbChsYXN0TGFiZWwpO1xuICAgIGlnbm9yZUVsKGxhc3RUaWNrKTtcbiAgfSBlbHNlIGlmIChpc1R3b0xhYmVsT3ZlcmxhcHBlZChwcmV2TGFiZWwsIGxhc3RMYWJlbCkpIHtcbiAgICBpZiAoc2hvd01heExhYmVsKSB7XG4gICAgICBpZ25vcmVFbChwcmV2TGFiZWwpO1xuICAgICAgaWdub3JlRWwocHJldlRpY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZ25vcmVFbChsYXN0TGFiZWwpO1xuICAgICAgaWdub3JlRWwobGFzdFRpY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpZ25vcmVFbChlbCkge1xuICBlbCAmJiAoZWwuaWdub3JlID0gdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGlzVHdvTGFiZWxPdmVybGFwcGVkKGN1cnJlbnQsIG5leHQsIGxhYmVsTGF5b3V0KSB7XG4gIC8vIGN1cnJlbnQgYW5kIG5leHQgaGFzIHRoZSBzYW1lIHJvdGF0aW9uLlxuICB2YXIgZmlyc3RSZWN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gIHZhciBuZXh0UmVjdCA9IG5leHQgJiYgbmV4dC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuXG4gIGlmICghZmlyc3RSZWN0IHx8ICFuZXh0UmVjdCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBXaGVuIGNoZWNraW5nIGludGVyc2VjdCBvZiB0d28gcm90YXRlZCBsYWJlbHMsIHdlIHVzZSBtUm90YXRpb25CYWNrXG4gIC8vIHRvIGF2b2lkIHRoYXQgYm91bmRpbmdSZWN0IGlzIGVubGFyZ2Ugd2hlbiB1c2luZyBgYm91bmRpbmdSZWN0LmFwcGx5VHJhbnNmb3JtYC5cblxuXG4gIHZhciBtUm90YXRpb25CYWNrID0gbWF0cml4VXRpbC5pZGVudGl0eShbXSk7XG4gIG1hdHJpeFV0aWwucm90YXRlKG1Sb3RhdGlvbkJhY2ssIG1Sb3RhdGlvbkJhY2ssIC1jdXJyZW50LnJvdGF0aW9uKTtcbiAgZmlyc3RSZWN0LmFwcGx5VHJhbnNmb3JtKG1hdHJpeFV0aWwubXVsKFtdLCBtUm90YXRpb25CYWNrLCBjdXJyZW50LmdldExvY2FsVHJhbnNmb3JtKCkpKTtcbiAgbmV4dFJlY3QuYXBwbHlUcmFuc2Zvcm0obWF0cml4VXRpbC5tdWwoW10sIG1Sb3RhdGlvbkJhY2ssIG5leHQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSkpO1xuICByZXR1cm4gZmlyc3RSZWN0LmludGVyc2VjdChuZXh0UmVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzTmFtZUxvY2F0aW9uQ2VudGVyKG5hbWVMb2NhdGlvbikge1xuICByZXR1cm4gbmFtZUxvY2F0aW9uID09PSAnbWlkZGxlJyB8fCBuYW1lTG9jYXRpb24gPT09ICdjZW50ZXInO1xufVxuXG5mdW5jdGlvbiBidWlsZEF4aXNUaWNrKGF4aXNCdWlsZGVyLCBheGlzTW9kZWwsIG9wdCkge1xuICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuXG4gIGlmICghYXhpc01vZGVsLmdldCgnYXhpc1RpY2suc2hvdycpIHx8IGF4aXMuc2NhbGUuaXNCbGFuaygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRpY2tNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc1RpY2snKTtcbiAgdmFyIGxpbmVTdHlsZU1vZGVsID0gdGlja01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgdmFyIHRpY2tMZW4gPSB0aWNrTW9kZWwuZ2V0KCdsZW5ndGgnKTtcbiAgdmFyIHRpY2tzQ29vcmRzID0gYXhpcy5nZXRUaWNrc0Nvb3JkcygpO1xuICB2YXIgcHQxID0gW107XG4gIHZhciBwdDIgPSBbXTtcbiAgdmFyIG1hdHJpeCA9IGF4aXNCdWlsZGVyLl90cmFuc2Zvcm07XG4gIHZhciB0aWNrRWxzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0aWNrQ29vcmQgPSB0aWNrc0Nvb3Jkc1tpXS5jb29yZDtcbiAgICBwdDFbMF0gPSB0aWNrQ29vcmQ7XG4gICAgcHQxWzFdID0gMDtcbiAgICBwdDJbMF0gPSB0aWNrQ29vcmQ7XG4gICAgcHQyWzFdID0gb3B0LnRpY2tEaXJlY3Rpb24gKiB0aWNrTGVuO1xuXG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDEsIHB0MSwgbWF0cml4KTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQyLCBwdDIsIG1hdHJpeCk7XG4gICAgfSAvLyBUaWNrIGxpbmUsIE5vdCB1c2UgZ3JvdXAgdHJhbnNmb3JtIHRvIGhhdmUgYmV0dGVyIGxpbmUgZHJhd1xuXG5cbiAgICB2YXIgdGlja0VsID0gbmV3IGdyYXBoaWMuTGluZShncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKHtcbiAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgIGFuaWQ6ICd0aWNrXycgKyB0aWNrc0Nvb3Jkc1tpXS50aWNrVmFsdWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4MTogcHQxWzBdLFxuICAgICAgICB5MTogcHQxWzFdLFxuICAgICAgICB4MjogcHQyWzBdLFxuICAgICAgICB5MjogcHQyWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IGRlZmF1bHRzKGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpLCB7XG4gICAgICAgIHN0cm9rZTogYXhpc01vZGVsLmdldCgnYXhpc0xpbmUubGluZVN0eWxlLmNvbG9yJylcbiAgICAgIH0pLFxuICAgICAgejI6IDIsXG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KSk7XG4gICAgYXhpc0J1aWxkZXIuZ3JvdXAuYWRkKHRpY2tFbCk7XG4gICAgdGlja0Vscy5wdXNoKHRpY2tFbCk7XG4gIH1cblxuICByZXR1cm4gdGlja0Vscztcbn1cblxuZnVuY3Rpb24gYnVpbGRBeGlzTGFiZWwoYXhpc0J1aWxkZXIsIGF4aXNNb2RlbCwgb3B0KSB7XG4gIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gIHZhciBzaG93ID0gcmV0cmlldmUob3B0LmF4aXNMYWJlbFNob3csIGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93JykpO1xuXG4gIGlmICghc2hvdyB8fCBheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYWJlbE1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcbiAgdmFyIGxhYmVsTWFyZ2luID0gbGFiZWxNb2RlbC5nZXQoJ21hcmdpbicpO1xuICB2YXIgbGFiZWxzID0gYXhpcy5nZXRWaWV3TGFiZWxzKCk7IC8vIFNwZWNpYWwgbGFiZWwgcm90YXRlLlxuXG4gIHZhciBsYWJlbFJvdGF0aW9uID0gKHJldHJpZXZlKG9wdC5sYWJlbFJvdGF0ZSwgbGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpKSB8fCAwKSAqIFBJIC8gMTgwO1xuICB2YXIgbGFiZWxMYXlvdXQgPSBpbm5lclRleHRMYXlvdXQob3B0LnJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uLCBvcHQubGFiZWxEaXJlY3Rpb24pO1xuICB2YXIgcmF3Q2F0ZWdvcnlEYXRhID0gYXhpc01vZGVsLmdldENhdGVnb3JpZXModHJ1ZSk7XG4gIHZhciBsYWJlbEVscyA9IFtdO1xuICB2YXIgc2lsZW50ID0gaXNTaWxlbnQoYXhpc01vZGVsKTtcbiAgdmFyIHRyaWdnZXJFdmVudCA9IGF4aXNNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcpO1xuICBlYWNoKGxhYmVscywgZnVuY3Rpb24gKGxhYmVsSXRlbSwgaW5kZXgpIHtcbiAgICB2YXIgdGlja1ZhbHVlID0gbGFiZWxJdGVtLnRpY2tWYWx1ZTtcbiAgICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBsYWJlbEl0ZW0uZm9ybWF0dGVkTGFiZWw7XG4gICAgdmFyIHJhd0xhYmVsID0gbGFiZWxJdGVtLnJhd0xhYmVsO1xuICAgIHZhciBpdGVtTGFiZWxNb2RlbCA9IGxhYmVsTW9kZWw7XG5cbiAgICBpZiAocmF3Q2F0ZWdvcnlEYXRhICYmIHJhd0NhdGVnb3J5RGF0YVt0aWNrVmFsdWVdICYmIHJhd0NhdGVnb3J5RGF0YVt0aWNrVmFsdWVdLnRleHRTdHlsZSkge1xuICAgICAgaXRlbUxhYmVsTW9kZWwgPSBuZXcgTW9kZWwocmF3Q2F0ZWdvcnlEYXRhW3RpY2tWYWx1ZV0udGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBheGlzTW9kZWwuZWNNb2RlbCk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb2xvciA9IGl0ZW1MYWJlbE1vZGVsLmdldFRleHRDb2xvcigpIHx8IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpO1xuICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKHRpY2tWYWx1ZSk7XG4gICAgdmFyIHBvcyA9IFt0aWNrQ29vcmQsIG9wdC5sYWJlbE9mZnNldCArIG9wdC5sYWJlbERpcmVjdGlvbiAqIGxhYmVsTWFyZ2luXTtcbiAgICB2YXIgdGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICBhbmlkOiAnbGFiZWxfJyArIHRpY2tWYWx1ZSxcbiAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgICBzaWxlbnQ6IHNpbGVudCxcbiAgICAgIHoyOiAxMFxuICAgIH0pO1xuICAgIGdyYXBoaWMuc2V0VGV4dFN0eWxlKHRleHRFbC5zdHlsZSwgaXRlbUxhYmVsTW9kZWwsIHtcbiAgICAgIHRleHQ6IGZvcm1hdHRlZExhYmVsLFxuICAgICAgdGV4dEFsaWduOiBpdGVtTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdhbGlnbicsIHRydWUpIHx8IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiBpdGVtTGFiZWxNb2RlbC5nZXRTaGFsbG93KCd2ZXJ0aWNhbEFsaWduJywgdHJ1ZSkgfHwgaXRlbUxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnYmFzZWxpbmUnLCB0cnVlKSB8fCBsYWJlbExheW91dC50ZXh0VmVydGljYWxBbGlnbixcbiAgICAgIHRleHRGaWxsOiB0eXBlb2YgdGV4dENvbG9yID09PSAnZnVuY3Rpb24nID8gdGV4dENvbG9yKCAvLyAoMSkgSW4gY2F0ZWdvcnkgYXhpcyB3aXRoIGRhdGEgem9vbSwgdGljayBpcyBub3QgdGhlIG9yaWdpbmFsXG4gICAgICAvLyBpbmRleCBvZiBheGlzLmRhdGEuIFNvIHRpY2sgc2hvdWxkIG5vdCBiZSBleHBvc2VkIHRvIHVzZXJcbiAgICAgIC8vIGluIGNhdGVnb3J5IGF4aXMuXG4gICAgICAvLyAoMikgQ29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIHZlcnNpb24sIHdoaWNoIGFsd2F5cyB1c2UgZm9ybWF0dGVkIGxhYmVsIGFzXG4gICAgICAvLyBpbnB1dC4gQnV0IGluIGludGVydmFsIHNjYWxlIHRoZSBmb3JtYXR0ZWQgbGFiZWwgaXMgbGlrZSAnMjIzLDQ0NScsIHdoaWNoXG4gICAgICAvLyBtYWtlZCB1c2VyIHJlcGFsY2UgJywnLiBTbyB3ZSBtb2RpZnkgaXQgdG8gcmV0dXJuIG9yaWdpbmFsIHZhbCBidXQgcmVtYWluXG4gICAgICAvLyBpdCBhcyAnc3RyaW5nJyB0byBhdm9pZCBlcnJvciBpbiByZXBsYWNpbmcuXG4gICAgICBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyByYXdMYWJlbCA6IGF4aXMudHlwZSA9PT0gJ3ZhbHVlJyA/IHRpY2tWYWx1ZSArICcnIDogdGlja1ZhbHVlLCBpbmRleCkgOiB0ZXh0Q29sb3JcbiAgICB9KTsgLy8gUGFjayBkYXRhIGZvciBtb3VzZSBldmVudFxuXG4gICAgaWYgKHRyaWdnZXJFdmVudCkge1xuICAgICAgdGV4dEVsLmV2ZW50RGF0YSA9IG1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgdGV4dEVsLmV2ZW50RGF0YS50YXJnZXRUeXBlID0gJ2F4aXNMYWJlbCc7XG4gICAgICB0ZXh0RWwuZXZlbnREYXRhLnZhbHVlID0gcmF3TGFiZWw7XG4gICAgfSAvLyBGSVhNRVxuXG5cbiAgICBheGlzQnVpbGRlci5fZHVtYkdyb3VwLmFkZCh0ZXh0RWwpO1xuXG4gICAgdGV4dEVsLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIGxhYmVsRWxzLnB1c2godGV4dEVsKTtcbiAgICBheGlzQnVpbGRlci5ncm91cC5hZGQodGV4dEVsKTtcbiAgICB0ZXh0RWwuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gIH0pO1xuICByZXR1cm4gbGFiZWxFbHM7XG59XG5cbnZhciBfZGVmYXVsdCA9IEF4aXNCdWlsZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9BeGlzQnVpbGRlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc0J1aWxkZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgYXhpc1BvaW50ZXJNb2RlbEhlbHBlciA9IHJlcXVpcmUoXCIuLi9heGlzUG9pbnRlci9tb2RlbEhlbHBlclwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEJhc2UgY2xhc3Mgb2YgQXhpc1ZpZXcuXG4gKi9cbnZhciBBeGlzVmlldyA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG4gIHR5cGU6ICdheGlzJyxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9heGlzUG9pbnRlcjogbnVsbCxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgYXhpc1BvaW50ZXJDbGFzczogbnVsbCxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIC8vIEZJWE1FXG4gICAgLy8gVGhpcyBwcm9jZXNzIHNob3VsZCBwcm9mb3JtZWQgYWZ0ZXIgY29vcmRpbmF0ZSBzeXN0ZW1zIHVwZGF0ZWRcbiAgICAvLyAoYXhpcyBzY2FsZSB1cGRhdGVkKSwgYW5kIHNob3VsZCBiZSBwZXJmb3JtZWQgZWFjaCB0aW1lIHVwZGF0ZS5cbiAgICAvLyBTbyBwdXQgaXQgaGVyZSB0ZW1wb3JhcmlseSwgYWx0aG91Z2ggaXQgaXMgbm90IGFwcHJvcHJpYXRlIHRvXG4gICAgLy8gcHV0IGEgbW9kZWwtd3JpdGluZyBwcm9jZWR1cmUgaW4gYHZpZXdgLlxuICAgIHRoaXMuYXhpc1BvaW50ZXJDbGFzcyAmJiBheGlzUG9pbnRlck1vZGVsSGVscGVyLmZpeFZhbHVlKGF4aXNNb2RlbCk7XG4gICAgQXhpc1ZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVuZGVyJywgYXJndW1lbnRzKTtcbiAgICB1cGRhdGVBeGlzUG9pbnRlcih0aGlzLCBheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH0gYXhpc01vZGVsXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICovXG4gIHVwZGF0ZUF4aXNQb2ludGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIGZvcmNlKSB7XG4gICAgdXBkYXRlQXhpc1BvaW50ZXIodGhpcywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgYXhpc1BvaW50ZXIgPSB0aGlzLl9heGlzUG9pbnRlcjtcbiAgICBheGlzUG9pbnRlciAmJiBheGlzUG9pbnRlci5yZW1vdmUoYXBpKTtcbiAgICBBeGlzVmlldy5zdXBlckFwcGx5KHRoaXMsICdyZW1vdmUnLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBkaXNwb3NlQXhpc1BvaW50ZXIodGhpcywgYXBpKTtcbiAgICBBeGlzVmlldy5zdXBlckFwcGx5KHRoaXMsICdkaXNwb3NlJywgYXJndW1lbnRzKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZUF4aXNQb2ludGVyKGF4aXNWaWV3LCBheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgZm9yY2VSZW5kZXIpIHtcbiAgdmFyIENsYXp6ID0gQXhpc1ZpZXcuZ2V0QXhpc1BvaW50ZXJDbGFzcyhheGlzVmlldy5heGlzUG9pbnRlckNsYXNzKTtcblxuICBpZiAoIUNsYXp6KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmdldEF4aXNQb2ludGVyTW9kZWwoYXhpc01vZGVsKTtcbiAgYXhpc1BvaW50ZXJNb2RlbCA/IChheGlzVmlldy5fYXhpc1BvaW50ZXIgfHwgKGF4aXNWaWV3Ll9heGlzUG9pbnRlciA9IG5ldyBDbGF6eigpKSkucmVuZGVyKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpLCBmb3JjZVJlbmRlcikgOiBkaXNwb3NlQXhpc1BvaW50ZXIoYXhpc1ZpZXcsIGFwaSk7XG59XG5cbmZ1bmN0aW9uIGRpc3Bvc2VBeGlzUG9pbnRlcihheGlzVmlldywgZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBheGlzUG9pbnRlciA9IGF4aXNWaWV3Ll9heGlzUG9pbnRlcjtcbiAgYXhpc1BvaW50ZXIgJiYgYXhpc1BvaW50ZXIuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICBheGlzVmlldy5fYXhpc1BvaW50ZXIgPSBudWxsO1xufVxuXG52YXIgYXhpc1BvaW50ZXJDbGF6eiA9IFtdO1xuXG5BeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MgPSBmdW5jdGlvbiAodHlwZSwgY2xhenopIHtcbiAgYXhpc1BvaW50ZXJDbGF6elt0eXBlXSA9IGNsYXp6O1xufTtcblxuQXhpc1ZpZXcuZ2V0QXhpc1BvaW50ZXJDbGFzcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiB0eXBlICYmIGF4aXNQb2ludGVyQ2xhenpbdHlwZV07XG59O1xuXG52YXIgX2RlZmF1bHQgPSBBeGlzVmlldztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc1ZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0F4aXNWaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIEF4aXNCdWlsZGVyID0gcmVxdWlyZShcIi4vQXhpc0J1aWxkZXJcIik7XG5cbnZhciBBeGlzVmlldyA9IHJlcXVpcmUoXCIuL0F4aXNWaWV3XCIpO1xuXG52YXIgY2FydGVzaWFuQXhpc0hlbHBlciA9IHJlcXVpcmUoXCIuLi8uLi9jb29yZC9jYXJ0ZXNpYW4vY2FydGVzaWFuQXhpc0hlbHBlclwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGF4aXNCdWlsZGVyQXR0cnMgPSBbJ2F4aXNMaW5lJywgJ2F4aXNUaWNrTGFiZWwnLCAnYXhpc05hbWUnXTtcbnZhciBzZWxmQnVpbGRlckF0dHJzID0gWydzcGxpdEFyZWEnLCAnc3BsaXRMaW5lJ107IC8vIGZ1bmN0aW9uIGdldEFsaWduV2l0aExhYmVsKG1vZGVsLCBheGlzTW9kZWwpIHtcbi8vICAgICB2YXIgYWxpZ25XaXRoTGFiZWwgPSBtb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJyk7XG4vLyAgICAgaWYgKGFsaWduV2l0aExhYmVsID09PSAnYXV0bycpIHtcbi8vICAgICAgICAgYWxpZ25XaXRoTGFiZWwgPSBheGlzTW9kZWwuZ2V0KCdheGlzVGljay5hbGlnbldpdGhMYWJlbCcpO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gYWxpZ25XaXRoTGFiZWw7XG4vLyB9XG5cbnZhciBDYXJ0ZXNpYW5BeGlzVmlldyA9IEF4aXNWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdjYXJ0ZXNpYW5BeGlzJyxcbiAgYXhpc1BvaW50ZXJDbGFzczogJ0NhcnRlc2lhbkF4aXNQb2ludGVyJyxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdmFyIG9sZEF4aXNHcm91cCA9IHRoaXMuX2F4aXNHcm91cDtcbiAgICB0aGlzLl9heGlzR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2F4aXNHcm91cCk7XG5cbiAgICBpZiAoIWF4aXNNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpO1xuICAgIHZhciBsYXlvdXQgPSBjYXJ0ZXNpYW5BeGlzSGVscGVyLmxheW91dChncmlkTW9kZWwsIGF4aXNNb2RlbCk7XG4gICAgdmFyIGF4aXNCdWlsZGVyID0gbmV3IEF4aXNCdWlsZGVyKGF4aXNNb2RlbCwgbGF5b3V0KTtcbiAgICB6clV0aWwuZWFjaChheGlzQnVpbGRlckF0dHJzLCBheGlzQnVpbGRlci5hZGQsIGF4aXNCdWlsZGVyKTtcblxuICAgIHRoaXMuX2F4aXNHcm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG5cbiAgICB6clV0aWwuZWFjaChzZWxmQnVpbGRlckF0dHJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKGF4aXNNb2RlbC5nZXQobmFtZSArICcuc2hvdycpKSB7XG4gICAgICAgIHRoaXNbJ18nICsgbmFtZV0oYXhpc01vZGVsLCBncmlkTW9kZWwpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIGdyYXBoaWMuZ3JvdXBUcmFuc2l0aW9uKG9sZEF4aXNHcm91cCwgdGhpcy5fYXhpc0dyb3VwLCBheGlzTW9kZWwpO1xuICAgIENhcnRlc2lhbkF4aXNWaWV3LnN1cGVyQ2FsbCh0aGlzLCAncmVuZGVyJywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zcGxpdEFyZWFDb2xvcnMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NwbGl0TGluZTogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZ3JpZE1vZGVsKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcblxuICAgIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzcGxpdExpbmVNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBsaW5lQ29sb3JzID0gbGluZVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIGxpbmVDb2xvcnMgPSB6clV0aWwuaXNBcnJheShsaW5lQ29sb3JzKSA/IGxpbmVDb2xvcnMgOiBbbGluZUNvbG9yc107XG4gICAgdmFyIGdyaWRSZWN0ID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoe1xuICAgICAgdGlja01vZGVsOiBzcGxpdExpbmVNb2RlbFxuICAgIH0pO1xuICAgIHZhciBwMSA9IFtdO1xuICAgIHZhciBwMiA9IFtdOyAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgLy8gQmF0Y2hpbmcgdGhlIGxpbmVzIGlmIGNvbG9yIGFyZSB0aGUgc2FtZVxuXG4gICAgdmFyIGxpbmVTdHlsZSA9IGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRpY2tDb29yZCA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1tpXS5jb29yZCk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgcDFbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgIHAxWzFdID0gZ3JpZFJlY3QueTtcbiAgICAgICAgcDJbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgIHAyWzFdID0gZ3JpZFJlY3QueSArIGdyaWRSZWN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAxWzBdID0gZ3JpZFJlY3QueDtcbiAgICAgICAgcDFbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICAgIHAyWzBdID0gZ3JpZFJlY3QueCArIGdyaWRSZWN0LndpZHRoO1xuICAgICAgICBwMlsxXSA9IHRpY2tDb29yZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9ySW5kZXggPSBsaW5lQ291bnQrKyAlIGxpbmVDb2xvcnMubGVuZ3RoO1xuICAgICAgdmFyIHRpY2tWYWx1ZSA9IHRpY2tzQ29vcmRzW2ldLnRpY2tWYWx1ZTtcblxuICAgICAgdGhpcy5fYXhpc0dyb3VwLmFkZChuZXcgZ3JhcGhpYy5MaW5lKGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUoe1xuICAgICAgICBhbmlkOiB0aWNrVmFsdWUgIT0gbnVsbCA/ICdsaW5lXycgKyB0aWNrc0Nvb3Jkc1tpXS50aWNrVmFsdWUgOiBudWxsLFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHgxOiBwMVswXSxcbiAgICAgICAgICB5MTogcDFbMV0sXG4gICAgICAgICAgeDI6IHAyWzBdLFxuICAgICAgICAgIHkyOiBwMlsxXVxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICBzdHJva2U6IGxpbmVDb2xvcnNbY29sb3JJbmRleF1cbiAgICAgICAgfSwgbGluZVN0eWxlKSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KSkpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsfSBheGlzTW9kZWxcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsfSBncmlkTW9kZWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zcGxpdEFyZWE6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGdyaWRNb2RlbCkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG5cbiAgICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3BsaXRBcmVhTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0QXJlYScpO1xuICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNwbGl0QXJlYU1vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUnKTtcbiAgICB2YXIgYXJlYUNvbG9ycyA9IGFyZWFTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcbiAgICB2YXIgZ3JpZFJlY3QgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgdmFyIHRpY2tzQ29vcmRzID0gYXhpcy5nZXRUaWNrc0Nvb3Jkcyh7XG4gICAgICB0aWNrTW9kZWw6IHNwbGl0QXJlYU1vZGVsLFxuICAgICAgY2xhbXA6IHRydWVcbiAgICB9KTtcblxuICAgIGlmICghdGlja3NDb29yZHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGb3IgTWFraW5nIGFwcHJvcHJpYXRlIHNwbGl0QXJlYSBhbmltYXRpb24sIHRoZSBjb2xvciBhbmQgYW5pZFxuICAgIC8vIHNob3VsZCBiZSBjb3JyZXNwb25kaW5nIHRvIHByZXZpb3VzIG9uZSBpZiBwb3NzaWJsZS5cblxuXG4gICAgdmFyIGFyZWFDb2xvcnNMZW4gPSBhcmVhQ29sb3JzLmxlbmd0aDtcbiAgICB2YXIgbGFzdFNwbGl0QXJlYUNvbG9ycyA9IHRoaXMuX3NwbGl0QXJlYUNvbG9ycztcbiAgICB2YXIgbmV3U3BsaXRBcmVhQ29sb3JzID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgY29sb3JJbmRleCA9IDA7XG5cbiAgICBpZiAobGFzdFNwbGl0QXJlYUNvbG9ycykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY0luZGV4ID0gbGFzdFNwbGl0QXJlYUNvbG9ycy5nZXQodGlja3NDb29yZHNbaV0udGlja1ZhbHVlKTtcblxuICAgICAgICBpZiAoY0luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBjb2xvckluZGV4ID0gKGNJbmRleCArIChhcmVhQ29sb3JzTGVuIC0gMSkgKiBpKSAlIGFyZWFDb2xvcnNMZW47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1swXS5jb29yZCk7XG4gICAgdmFyIGFyZWFTdHlsZSA9IGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuICAgIGFyZWFDb2xvcnMgPSB6clV0aWwuaXNBcnJheShhcmVhQ29sb3JzKSA/IGFyZWFDb2xvcnMgOiBbYXJlYUNvbG9yc107XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzW2ldLmNvb3JkKTtcbiAgICAgIHZhciB4O1xuICAgICAgdmFyIHk7XG4gICAgICB2YXIgd2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0O1xuXG4gICAgICBpZiAoYXhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICB4ID0gcHJldjtcbiAgICAgICAgeSA9IGdyaWRSZWN0Lnk7XG4gICAgICAgIHdpZHRoID0gdGlja0Nvb3JkIC0geDtcbiAgICAgICAgaGVpZ2h0ID0gZ3JpZFJlY3QuaGVpZ2h0O1xuICAgICAgICBwcmV2ID0geCArIHdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGdyaWRSZWN0Lng7XG4gICAgICAgIHkgPSBwcmV2O1xuICAgICAgICB3aWR0aCA9IGdyaWRSZWN0LndpZHRoO1xuICAgICAgICBoZWlnaHQgPSB0aWNrQ29vcmQgLSB5O1xuICAgICAgICBwcmV2ID0geSArIGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpY2tWYWx1ZSA9IHRpY2tzQ29vcmRzW2kgLSAxXS50aWNrVmFsdWU7XG4gICAgICB0aWNrVmFsdWUgIT0gbnVsbCAmJiBuZXdTcGxpdEFyZWFDb2xvcnMuc2V0KHRpY2tWYWx1ZSwgY29sb3JJbmRleCk7XG5cbiAgICAgIHRoaXMuX2F4aXNHcm91cC5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgIGFuaWQ6IHRpY2tWYWx1ZSAhPSBudWxsID8gJ2FyZWFfJyArIHRpY2tWYWx1ZSA6IG51bGwsXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICBmaWxsOiBhcmVhQ29sb3JzW2NvbG9ySW5kZXhdXG4gICAgICAgIH0sIGFyZWFTdHlsZSksXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSkpO1xuXG4gICAgICBjb2xvckluZGV4ID0gKGNvbG9ySW5kZXggKyAxKSAlIGFyZWFDb2xvcnNMZW47XG4gICAgfVxuXG4gICAgdGhpcy5fc3BsaXRBcmVhQ29sb3JzID0gbmV3U3BsaXRBcmVhQ29sb3JzO1xuICB9XG59KTtcbkNhcnRlc2lhbkF4aXNWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICd4QXhpcydcbn0pO1xuQ2FydGVzaWFuQXhpc1ZpZXcuZXh0ZW5kKHtcbiAgdHlwZTogJ3lBeGlzJ1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQ2FydGVzaWFuQXhpc1ZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0NhcnRlc2lhbkF4aXNWaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBheGlzUG9pbnRlck1vZGVsSGVscGVyID0gcmVxdWlyZShcIi4vYXhpc1BvaW50ZXIvbW9kZWxIZWxwZXJcIik7XG5cbnZhciBheGlzVHJpZ2dlciA9IHJlcXVpcmUoXCIuL2F4aXNQb2ludGVyL2F4aXNUcmlnZ2VyXCIpO1xuXG5yZXF1aXJlKFwiLi9heGlzUG9pbnRlci9BeGlzUG9pbnRlck1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL2F4aXNQb2ludGVyL0NhcnRlc2lhbkF4aXNQb2ludGVyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBDYXJ0ZXNpYW5BeGlzUG9pbnRlciBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgcmVxdWlyZWQgaGVyZS4gQnV0IGNvbnNpZGVyXG4vLyBlY2hhcnRzLnNpbXBsZS5qcyBhbmQgb25saW5lIGJ1aWxkIHRvb2x0aXAsIHdoaWNoIG9ubHkgcmVxdWlyZSBncmlkU2ltcGxlLFxuLy8gQ2FydGVzaWFuQXhpc1BvaW50ZXIgc2hvdWxkIGJlIGFibGUgdG8gcmVxdWlyZWQgc29tZXdoZXJlLlxuZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gIC8vIEFsd2F5cyBoYXMgYSBnbG9iYWwgYXhpc1BvaW50ZXJNb2RlbCBmb3IgZGVmYXVsdCBzZXR0aW5nLlxuICBpZiAob3B0aW9uKSB7XG4gICAgKCFvcHRpb24uYXhpc1BvaW50ZXIgfHwgb3B0aW9uLmF4aXNQb2ludGVyLmxlbmd0aCA9PT0gMCkgJiYgKG9wdGlvbi5heGlzUG9pbnRlciA9IHt9KTtcbiAgICB2YXIgbGluayA9IG9wdGlvbi5heGlzUG9pbnRlci5saW5rOyAvLyBOb3JtYWxpemUgdG8gYXJyYXkgdG8gYXZvaWQgb2JqZWN0IG1lcmdpbi4gQnV0IGlmIGxpbmtcbiAgICAvLyBpcyBub3Qgc2V0LCByZW1haW4gbnVsbC91bmRlZmluZWQsIG90aGVyd2lzZSBpdCB3aWxsXG4gICAgLy8gb3ZlcnJpZGUgZXhpc3RlbnQgbGluayBzZXR0aW5nLlxuXG4gICAgaWYgKGxpbmsgJiYgIXpyVXRpbC5pc0FycmF5KGxpbmspKSB7XG4gICAgICBvcHRpb24uYXhpc1BvaW50ZXIubGluayA9IFtsaW5rXTtcbiAgICB9XG4gIH1cbn0pOyAvLyBUaGlzIHByb2Nlc3Mgc2hvdWxkIHByb2Zvcm1lZCBhZnRlciBjb29yZGluYXRlIHN5c3RlbXMgY3JlYXRlZFxuLy8gYW5kIHNlcmllcyBkYXRhIHByb2Nlc3NlZC4gU28gcHV0IGl0IG9uIHN0YXRpc3RpYyBwcm9jZXNzaW5nIHN0YWdlLlxuXG5lY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKGVjaGFydHMuUFJJT1JJVFkuUFJPQ0VTU09SLlNUQVRJU1RJQywgZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAvLyBCdWlsZCBheGlzUG9pbnRlck1vZGVsLCBtZXJnaW4gdG9vbHRpcC5heGlzUG9pbnRlciBtb2RlbCBmb3IgZWFjaCBheGlzLlxuICAvLyBhbGxBeGVzSW5mbyBzaG91bGQgYmUgdXBkYXRlZCB3aGVuIHNldE9wdGlvbiBwZXJmb3JtZWQuXG4gIGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpLmNvb3JkU3lzQXhlc0luZm8gPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmNvbGxlY3QoZWNNb2RlbCwgYXBpKTtcbn0pOyAvLyBCcm9hZGNhc3QgdG8gYWxsIHZpZXdzLlxuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgZXZlbnQ6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gIHVwZGF0ZTogJzp1cGRhdGVBeGlzUG9pbnRlcidcbn0sIGF4aXNUcmlnZ2VyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBBeGlzUG9pbnRlck1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdheGlzUG9pbnRlcicsXG4gIGNvb3JkU3lzQXhlc0luZm86IG51bGwsXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICAvLyAnYXV0bycgbWVhbnMgdGhhdCBzaG93IHdoZW4gdHJpZ2dlcmVkIGJ5IHRvb2x0aXAgb3IgaGFuZGxlLlxuICAgIHNob3c6ICdhdXRvJyxcbiAgICAvLyAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZSdcbiAgICB0cmlnZ2VyT246IG51bGwsXG4gICAgLy8gc2V0IGRlZmF1bHQgaW4gQXhpc1BvbnRlclZpZXcuanNcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogNTAsXG4gICAgdHlwZTogJ2xpbmUnLFxuICAgIC8vIGF4aXNwb2ludGVyIHRyaWdnZXJlZCBieSB0b290aXAgZGV0ZXJtaW5lIHNuYXAgYXV0b21hdGljYWxseSxcbiAgICAvLyBzZWUgYG1vZGVsSGVscGVyYC5cbiAgICBzbmFwOiBmYWxzZSxcbiAgICB0cmlnZ2VyVG9vbHRpcDogdHJ1ZSxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBzdGF0dXM6IG51bGwsXG4gICAgLy8gSW5pdCB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgaGFuZGxlIGlzIHVzZWQuXG4gICAgLy8gW2dyb3VwMCwgZ3JvdXAxLCAuLi5dXG4gICAgLy8gRWFjaCBncm91cCBjYW4gYmU6IHtcbiAgICAvLyAgICAgIG1hcHBlcjogZnVuY3Rpb24gKCkge30sXG4gICAgLy8gICAgICBzaW5nbGVUb29sdGlwOiAnbXVsdGlwbGUnLCAgLy8gJ211bHRpcGxlJyBvciAnc2luZ2xlJ1xuICAgIC8vICAgICAgeEF4aXNJZDogLi4uLFxuICAgIC8vICAgICAgeUF4aXNOYW1lOiAuLi4sXG4gICAgLy8gICAgICBhbmdsZUF4aXNJbmRleDogLi4uXG4gICAgLy8gfVxuICAgIC8vIG1hcHBlcjogY2FuIGJlIGlnbm9yZWQuXG4gICAgLy8gICAgICBpbnB1dDoge2F4aXNJbmZvLCB2YWx1ZX1cbiAgICAvLyAgICAgIG91dHB1dDoge2F4aXNJbmZvLCB2YWx1ZX1cbiAgICBsaW5rOiBbXSxcbiAgICAvLyBEbyBub3Qgc2V0ICdhdXRvJyBoZXJlLCBvdGhlcndpc2UgZ2xvYmFsIGFuaW1hdGlvbjogZmFsc2VcbiAgICAvLyB3aWxsIG5vdCBlZmZlY3QgYXQgdGhpcyBheGlzcG9pbnRlci5cbiAgICBhbmltYXRpb246IG51bGwsXG4gICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDIwMCxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2FhYScsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICB9LFxuICAgIHNoYWRvd1N0eWxlOiB7XG4gICAgICBjb2xvcjogJ3JnYmEoMTUwLDE1MCwxNTAsMC4zKSdcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgZm9ybWF0dGVyOiBudWxsLFxuICAgICAgLy8gc3RyaW5nIHwgRnVuY3Rpb25cbiAgICAgIHByZWNpc2lvbjogJ2F1dG8nLFxuICAgICAgLy8gT3IgYSBudW1iZXIgbGlrZSAwLCAxLCAyIC4uLlxuICAgICAgbWFyZ2luOiAzLFxuICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgIHBhZGRpbmc6IFs1LCA3LCA1LCA3XSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ2F1dG8nLFxuICAgICAgLy8gZGVmYXVsdDogYXhpcyBsaW5lIGNvbG9yXG4gICAgICBib3JkZXJDb2xvcjogbnVsbCxcbiAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgc2hhZG93Qmx1cjogMyxcbiAgICAgIHNoYWRvd0NvbG9yOiAnI2FhYScgLy8gQ29uc2lkZXJpbmcgYXBwbGljYWJpbGl0eSwgY29tbW9uIHN0eWxlIHNob3VsZFxuICAgICAgLy8gYmV0dGVyIG5vdCBoYXZlIHNoYWRvd09mZnNldC5cbiAgICAgIC8vIHNoYWRvd09mZnNldFg6IDAsXG4gICAgICAvLyBzaGFkb3dPZmZzZXRZOiAyXG5cbiAgICB9LFxuICAgIGhhbmRsZToge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBpY29uOiAnTTEwLjcsMTEuOXYtMS4zSDkuM3YxLjNjLTQuOSwwLjMtOC44LDQuNC04LjgsOS40YzAsNSwzLjksOS4xLDguOCw5LjRoMS4zYzQuOS0wLjMsOC44LTQuNCw4LjgtOS40QzE5LjUsMTYuMywxNS42LDEyLjIsMTAuNywxMS45eiBNMTMuMywyNC40SDYuN3YtMS4yaDYuNnogTTEzLjMsMjJINi43di0xLjJoNi42eiBNMTMuMywxOS42SDYuN3YtMS4yaDYuNnonLFxuICAgICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICBzaXplOiA0NSxcbiAgICAgIC8vIGhhbmRsZSBtYXJnaW4gaXMgZnJvbSBzeW1ib2wgY2VudGVyIHRvIGF4aXMsIHdoaWNoIGlzIHN0YWJsZSB3aGVuIGNpcmN1bGFyIG1vdmUuXG4gICAgICBtYXJnaW46IDUwLFxuICAgICAgLy8gY29sb3I6ICcjMWI4YmJkJ1xuICAgICAgLy8gY29sb3I6ICcjMmY0NTU0J1xuICAgICAgY29sb3I6ICcjMzMzJyxcbiAgICAgIHNoYWRvd0JsdXI6IDMsXG4gICAgICBzaGFkb3dDb2xvcjogJyNhYWEnLFxuICAgICAgc2hhZG93T2Zmc2V0WDogMCxcbiAgICAgIHNoYWRvd09mZnNldFk6IDIsXG4gICAgICAvLyBGb3IgbW9iaWxlIHBlcmZvcm1hbmNlXG4gICAgICB0aHJvdHRsZTogNDBcbiAgICB9XG4gIH1cbn0pO1xudmFyIF9kZWZhdWx0ID0gQXhpc1BvaW50ZXJNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlck1vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIGdsb2JhbExpc3RlbmVyID0gcmVxdWlyZShcIi4vZ2xvYmFsTGlzdGVuZXJcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBBeGlzUG9pbnRlclZpZXcgPSBlY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuICB0eXBlOiAnYXhpc1BvaW50ZXInLFxuICByZW5kZXI6IGZ1bmN0aW9uIChnbG9iYWxBeGlzUG9pbnRlck1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZ2xvYmFsVG9vbHRpcE1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3Rvb2x0aXAnKTtcbiAgICB2YXIgdHJpZ2dlck9uID0gZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3RyaWdnZXJPbicpIHx8IGdsb2JhbFRvb2x0aXBNb2RlbCAmJiBnbG9iYWxUb29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKSB8fCAnbW91c2Vtb3ZlfGNsaWNrJzsgLy8gUmVnaXN0ZXIgZ2xvYmFsIGxpc3RlbmVyIGluIEF4aXNQb2ludGVyVmlldyB0byBlbmFibGVcbiAgICAvLyBBeGlzUG9pbnRlclZpZXcgdG8gYmUgaW5kZXBlbmRlbnQgdG8gVG9vbHRpcC5cblxuICAgIGdsb2JhbExpc3RlbmVyLnJlZ2lzdGVyKCdheGlzUG9pbnRlcicsIGFwaSwgZnVuY3Rpb24gKGN1cnJUcmlnZ2VyLCBlLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgLy8gSWYgJ25vbmUnLCBpdCBpcyBub3QgY29udHJvbGxlZCBieSBtb3VzZSB0b3RhbGx5LlxuICAgICAgaWYgKHRyaWdnZXJPbiAhPT0gJ25vbmUnICYmIChjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJyB8fCB0cmlnZ2VyT24uaW5kZXhPZihjdXJyVHJpZ2dlcikgPj0gMCkpIHtcbiAgICAgICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgIHR5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gICAgICAgICAgY3VyclRyaWdnZXI6IGN1cnJUcmlnZ2VyLFxuICAgICAgICAgIHg6IGUgJiYgZS5vZmZzZXRYLFxuICAgICAgICAgIHk6IGUgJiYgZS5vZmZzZXRZXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIoYXBpLmdldFpyKCksICdheGlzUG9pbnRlcicpO1xuICAgIEF4aXNQb2ludGVyVmlldy5zdXBlckFwcGx5KHRoaXMuX21vZGVsLCAncmVtb3ZlJywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgZ2xvYmFsTGlzdGVuZXIudW5yZWdpc3RlcignYXhpc1BvaW50ZXInLCBhcGkpO1xuICAgIEF4aXNQb2ludGVyVmlldy5zdXBlckFwcGx5KHRoaXMuX21vZGVsLCAnZGlzcG9zZScsIGFyZ3VtZW50cyk7XG4gIH1cbn0pO1xudmFyIF9kZWZhdWx0ID0gQXhpc1BvaW50ZXJWaWV3O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJWaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBjbGF6elV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9jbGF6elwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgYXhpc1BvaW50ZXJNb2RlbEhlbHBlciA9IHJlcXVpcmUoXCIuL21vZGVsSGVscGVyXCIpO1xuXG52YXIgZXZlbnRUb29sID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZXZlbnRcIik7XG5cbnZhciB0aHJvdHRsZVV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC90aHJvdHRsZVwiKTtcblxudmFyIF9tb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG52YXIgbWFrZUlubmVyID0gX21vZGVsLm1ha2VJbm5lcjtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGlubmVyID0gbWFrZUlubmVyKCk7XG52YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG52YXIgYmluZCA9IHpyVXRpbC5iaW5kO1xuLyoqXG4gKiBCYXNlIGF4aXMgcG9pbnRlciBjbGFzcyBpbiAyRC5cbiAqIEltcGxlbWVuZW50cyB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2F4aXMvSUF4aXNQb2ludGVyfS5cbiAqL1xuXG5mdW5jdGlvbiBCYXNlQXhpc1BvaW50ZXIoKSB7fVxuXG5CYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ncm91cDogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sYXN0R3JhcGhpY0tleTogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZHJhZ2dpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2xhc3RWYWx1ZTogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sYXN0U3RhdHVzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BheWxvYWRJbmZvOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJbiBweCwgYXJiaXRyYXJ5IHZhbHVlLiBEbyBub3Qgc2V0IHRvbyBzbWFsbCxcbiAgICogbm8gYW5pbWF0aW9uIGlzIG9rIGZvciBtb3N0IGNhc2VzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBhbmltYXRpb25UaHJlc2hvbGQ6IDE1LFxuXG4gIC8qKlxuICAgKiBAaW1wbGVtZW50XG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwgZm9yY2VSZW5kZXIpIHtcbiAgICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgICB2YXIgc3RhdHVzID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3N0YXR1cycpOyAvLyBCaW5kIHRoZW0gdG8gYHRoaXNgLCBub3QgaW4gY2xvc3VyZSwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBub3RcbiAgICAvLyBiZSByZXBsYWNlZCB3aGVuIHVzZXIgY2FsbGluZyBzZXRPcHRpb24gaW4gbm90IG1lcmdlIG1vZGUuXG5cbiAgICB0aGlzLl9heGlzTW9kZWwgPSBheGlzTW9kZWw7XG4gICAgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWw7XG4gICAgdGhpcy5fYXBpID0gYXBpOyAvLyBPcHRpbWl6ZTogYHJlbmRlcmAgd2lsbCBiZSBjYWxsZWQgcmVwZWF0bHkgZHVyaW5nIG1vdXNlIG1vdmUuXG4gICAgLy8gU28gaXQgaXMgcG93ZXIgY29uc3VtaW5nIGlmIHBlcmZvcm1pbmcgYHJlbmRlcmAgZWFjaCB0aW1lLFxuICAgIC8vIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZS5cblxuICAgIGlmICghZm9yY2VSZW5kZXIgJiYgdGhpcy5fbGFzdFZhbHVlID09PSB2YWx1ZSAmJiB0aGlzLl9sYXN0U3RhdHVzID09PSBzdGF0dXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9sYXN0U3RhdHVzID0gc3RhdHVzO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3VwO1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG5cbiAgICBpZiAoIXN0YXR1cyB8fCBzdGF0dXMgPT09ICdoaWRlJykge1xuICAgICAgLy8gRG8gbm90IGNsZWFyIGhlcmUsIGZvciBhbmltYXRpb24gYmV0dGVyLlxuICAgICAgZ3JvdXAgJiYgZ3JvdXAuaGlkZSgpO1xuICAgICAgaGFuZGxlICYmIGhhbmRsZS5oaWRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ3JvdXAgJiYgZ3JvdXAuc2hvdygpO1xuICAgIGhhbmRsZSAmJiBoYW5kbGUuc2hvdygpOyAvLyBPdGhlcndpc2Ugc3RhdHVzIGlzICdzaG93J1xuXG4gICAgdmFyIGVsT3B0aW9uID0ge307XG4gICAgdGhpcy5tYWtlRWxPcHRpb24oZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSk7IC8vIEVuYWJsZSBjaGFuZ2UgYXhpcyBwb2ludGVyIHR5cGUuXG5cbiAgICB2YXIgZ3JhcGhpY0tleSA9IGVsT3B0aW9uLmdyYXBoaWNLZXk7XG5cbiAgICBpZiAoZ3JhcGhpY0tleSAhPT0gdGhpcy5fbGFzdEdyYXBoaWNLZXkpIHtcbiAgICAgIHRoaXMuY2xlYXIoYXBpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0R3JhcGhpY0tleSA9IGdyYXBoaWNLZXk7XG4gICAgdmFyIG1vdmVBbmltYXRpb24gPSB0aGlzLl9tb3ZlQW5pbWF0aW9uID0gdGhpcy5kZXRlcm1pbmVBbmltYXRpb24oYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIGdyb3VwID0gdGhpcy5fZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgdGhpcy5jcmVhdGVQb2ludGVyRWwoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgdGhpcy5jcmVhdGVMYWJlbEVsKGdyb3VwLCBlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKTtcbiAgICAgIGFwaS5nZXRacigpLmFkZChncm91cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb1VwZGF0ZVByb3BzID0genJVdGlsLmN1cnJ5KHVwZGF0ZVByb3BzLCBheGlzUG9pbnRlck1vZGVsLCBtb3ZlQW5pbWF0aW9uKTtcbiAgICAgIHRoaXMudXBkYXRlUG9pbnRlckVsKGdyb3VwLCBlbE9wdGlvbiwgZG9VcGRhdGVQcm9wcywgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsRWwoZ3JvdXAsIGVsT3B0aW9uLCBkb1VwZGF0ZVByb3BzLCBheGlzUG9pbnRlck1vZGVsKTtcbiAgICB9XG5cbiAgICB1cGRhdGVNYW5kYXRvcnlQcm9wcyhncm91cCwgYXhpc1BvaW50ZXJNb2RlbCwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9yZW5kZXJIYW5kbGUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAaW1wbGVtZW50XG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLmNsZWFyKGFwaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBpbXBsZW1lbnRcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLmNsZWFyKGFwaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRldGVybWluZUFuaW1hdGlvbjogZnVuY3Rpb24gKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBhbmltYXRpb24gPSBheGlzUG9pbnRlck1vZGVsLmdldCgnYW5pbWF0aW9uJyk7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgaXNDYXRlZ29yeUF4aXMgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgdmFyIHVzZVNuYXAgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc25hcCcpOyAvLyBWYWx1ZSBheGlzIHdpdGhvdXQgc25hcCBhbHdheXMgZG8gbm90IHNuYXAuXG5cbiAgICBpZiAoIXVzZVNuYXAgJiYgIWlzQ2F0ZWdvcnlBeGlzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGlvbiA9PT0gJ2F1dG8nIHx8IGFuaW1hdGlvbiA9PSBudWxsKSB7XG4gICAgICB2YXIgYW5pbWF0aW9uVGhyZXNob2xkID0gdGhpcy5hbmltYXRpb25UaHJlc2hvbGQ7XG5cbiAgICAgIGlmIChpc0NhdGVnb3J5QXhpcyAmJiBheGlzLmdldEJhbmRXaWR0aCgpID4gYW5pbWF0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gYXV0byBhbmltYXRpb24gd2hlbiBzbmFwIHVzZWQuIENvbnNpZGVyIGlmIHRoZXJlIGlzXG4gICAgICAvLyBhIGRhdGFab29tLCBhbmltYXRpb24gd2lsbCBiZSBkaXNhYmxlZCB3aGVuIHRvbyBtYW55IHBvaW50cyBleGlzdCwgd2hpbGVcbiAgICAgIC8vIGl0IHdpbGwgYmUgZW5hYmxlZCBmb3IgYmV0dGVyIHZpc3VhbCBlZmZlY3Qgd2hlbiBsaXR0bGUgcG9pbnRzIGV4aXN0LlxuXG5cbiAgICAgIGlmICh1c2VTbmFwKSB7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhQ291bnQgPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmdldEF4aXNJbmZvKGF4aXNNb2RlbCkuc2VyaWVzRGF0YUNvdW50O1xuICAgICAgICB2YXIgYXhpc0V4dGVudCA9IGF4aXMuZ2V0RXh0ZW50KCk7IC8vIEFwcHJveGltYXRlIGJhbmQgd2lkdGhcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXhpc0V4dGVudFswXSAtIGF4aXNFeHRlbnRbMV0pIC8gc2VyaWVzRGF0YUNvdW50ID4gYW5pbWF0aW9uVGhyZXNob2xkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbiA9PT0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYWRkIHtwb2ludGVyLCBsYWJlbCwgZ3JhcGhpY0tleX0gdG8gZWxPcHRpb25cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbWFrZUVsT3B0aW9uOiBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkgey8vIFNob3VsZSBiZSBpbXBsZW1lbmVudGVkIGJ5IHN1Yi1jbGFzcy5cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY3JlYXRlUG9pbnRlckVsOiBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgcG9pbnRlck9wdGlvbiA9IGVsT3B0aW9uLnBvaW50ZXI7XG5cbiAgICBpZiAocG9pbnRlck9wdGlvbikge1xuICAgICAgdmFyIHBvaW50ZXJFbCA9IGlubmVyKGdyb3VwKS5wb2ludGVyRWwgPSBuZXcgZ3JhcGhpY1twb2ludGVyT3B0aW9uLnR5cGVdKGNsb25lKGVsT3B0aW9uLnBvaW50ZXIpKTtcbiAgICAgIGdyb3VwLmFkZChwb2ludGVyRWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY3JlYXRlTGFiZWxFbDogZnVuY3Rpb24gKGdyb3VwLCBlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKSB7XG4gICAgaWYgKGVsT3B0aW9uLmxhYmVsKSB7XG4gICAgICB2YXIgbGFiZWxFbCA9IGlubmVyKGdyb3VwKS5sYWJlbEVsID0gbmV3IGdyYXBoaWMuUmVjdChjbG9uZShlbE9wdGlvbi5sYWJlbCkpO1xuICAgICAgZ3JvdXAuYWRkKGxhYmVsRWwpO1xuICAgICAgdXBkYXRlTGFiZWxTaG93SGlkZShsYWJlbEVsLCBheGlzUG9pbnRlck1vZGVsKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHVwZGF0ZVBvaW50ZXJFbDogZnVuY3Rpb24gKGdyb3VwLCBlbE9wdGlvbiwgdXBkYXRlUHJvcHMpIHtcbiAgICB2YXIgcG9pbnRlckVsID0gaW5uZXIoZ3JvdXApLnBvaW50ZXJFbDtcblxuICAgIGlmIChwb2ludGVyRWwpIHtcbiAgICAgIHBvaW50ZXJFbC5zZXRTdHlsZShlbE9wdGlvbi5wb2ludGVyLnN0eWxlKTtcbiAgICAgIHVwZGF0ZVByb3BzKHBvaW50ZXJFbCwge1xuICAgICAgICBzaGFwZTogZWxPcHRpb24ucG9pbnRlci5zaGFwZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB1cGRhdGVMYWJlbEVsOiBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCB1cGRhdGVQcm9wcywgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBsYWJlbEVsID0gaW5uZXIoZ3JvdXApLmxhYmVsRWw7XG5cbiAgICBpZiAobGFiZWxFbCkge1xuICAgICAgbGFiZWxFbC5zZXRTdHlsZShlbE9wdGlvbi5sYWJlbC5zdHlsZSk7XG4gICAgICB1cGRhdGVQcm9wcyhsYWJlbEVsLCB7XG4gICAgICAgIC8vIENvbnNpZGVyIHRleHQgbGVuZ3RoIGNoYW5nZSBpbiB2ZXJ0aWNhbCBheGlzLCBhbmltYXRpb24gc2hvdWxkXG4gICAgICAgIC8vIGJlIHVzZWQgb24gc2hhcGUsIG90aGVyd2lzZSB0aGUgZWZmZWN0IHdpbGwgYmUgd2VpcmQuXG4gICAgICAgIHNoYXBlOiBlbE9wdGlvbi5sYWJlbC5zaGFwZSxcbiAgICAgICAgcG9zaXRpb246IGVsT3B0aW9uLmxhYmVsLnBvc2l0aW9uXG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZUxhYmVsU2hvd0hpZGUobGFiZWxFbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckhhbmRsZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2RyYWdnaW5nIHx8ICF0aGlzLnVwZGF0ZUhhbmRsZVRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gdGhpcy5fYXhpc1BvaW50ZXJNb2RlbDtcblxuICAgIHZhciB6ciA9IHRoaXMuX2FwaS5nZXRacigpO1xuXG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcbiAgICB2YXIgaGFuZGxlTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldE1vZGVsKCdoYW5kbGUnKTtcbiAgICB2YXIgc3RhdHVzID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3N0YXR1cycpO1xuXG4gICAgaWYgKCFoYW5kbGVNb2RlbC5nZXQoJ3Nob3cnKSB8fCAhc3RhdHVzIHx8IHN0YXR1cyA9PT0gJ2hpZGUnKSB7XG4gICAgICBoYW5kbGUgJiYgenIucmVtb3ZlKGhhbmRsZSk7XG4gICAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc0luaXQ7XG5cbiAgICBpZiAoIXRoaXMuX2hhbmRsZSkge1xuICAgICAgaXNJbml0ID0gdHJ1ZTtcbiAgICAgIGhhbmRsZSA9IHRoaXMuX2hhbmRsZSA9IGdyYXBoaWMuY3JlYXRlSWNvbihoYW5kbGVNb2RlbC5nZXQoJ2ljb24nKSwge1xuICAgICAgICBjdXJzb3I6ICdtb3ZlJyxcbiAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICBvbm1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBGb3QgbW9iaWxlIGRldmljZW0sIHByZXZlbnQgc2NyZWVuIHNsaWRlciBvbiB0aGUgYnV0dG9uLlxuICAgICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbm1vdXNlZG93bjogYmluZCh0aGlzLl9vbkhhbmRsZURyYWdNb3ZlLCB0aGlzLCAwLCAwKSxcbiAgICAgICAgZHJpZnQ6IGJpbmQodGhpcy5fb25IYW5kbGVEcmFnTW92ZSwgdGhpcyksXG4gICAgICAgIG9uZHJhZ2VuZDogYmluZCh0aGlzLl9vbkhhbmRsZURyYWdFbmQsIHRoaXMpXG4gICAgICB9KTtcbiAgICAgIHpyLmFkZChoYW5kbGUpO1xuICAgIH1cblxuICAgIHVwZGF0ZU1hbmRhdG9yeVByb3BzKGhhbmRsZSwgYXhpc1BvaW50ZXJNb2RlbCwgZmFsc2UpOyAvLyB1cGRhdGUgc3R5bGVcblxuICAgIHZhciBpbmNsdWRlU3R5bGVzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdib3JkZXJXaWR0aCcsICdvcGFjaXR5JywgJ3NoYWRvd0NvbG9yJywgJ3NoYWRvd0JsdXInLCAnc2hhZG93T2Zmc2V0WCcsICdzaGFkb3dPZmZzZXRZJ107XG4gICAgaGFuZGxlLnNldFN0eWxlKGhhbmRsZU1vZGVsLmdldEl0ZW1TdHlsZShudWxsLCBpbmNsdWRlU3R5bGVzKSk7IC8vIHVwZGF0ZSBwb3NpdGlvblxuXG4gICAgdmFyIGhhbmRsZVNpemUgPSBoYW5kbGVNb2RlbC5nZXQoJ3NpemUnKTtcblxuICAgIGlmICghenJVdGlsLmlzQXJyYXkoaGFuZGxlU2l6ZSkpIHtcbiAgICAgIGhhbmRsZVNpemUgPSBbaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZV07XG4gICAgfVxuXG4gICAgaGFuZGxlLmF0dHIoJ3NjYWxlJywgW2hhbmRsZVNpemVbMF0gLyAyLCBoYW5kbGVTaXplWzFdIC8gMl0pO1xuICAgIHRocm90dGxlVXRpbC5jcmVhdGVPclVwZGF0ZSh0aGlzLCAnX2RvRGlzcGF0Y2hBeGlzUG9pbnRlcicsIGhhbmRsZU1vZGVsLmdldCgndGhyb3R0bGUnKSB8fCAwLCAnZml4UmF0ZScpO1xuXG4gICAgdGhpcy5fbW92ZUhhbmRsZVRvVmFsdWUodmFsdWUsIGlzSW5pdCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZUhhbmRsZVRvVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaXNJbml0KSB7XG4gICAgdXBkYXRlUHJvcHModGhpcy5fYXhpc1BvaW50ZXJNb2RlbCwgIWlzSW5pdCAmJiB0aGlzLl9tb3ZlQW5pbWF0aW9uLCB0aGlzLl9oYW5kbGUsIGdldEhhbmRsZVRyYW5zUHJvcHModGhpcy5nZXRIYW5kbGVUcmFuc2Zvcm0odmFsdWUsIHRoaXMuX2F4aXNNb2RlbCwgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCkpKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkhhbmRsZURyYWdNb3ZlOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcblxuICAgIGlmICghaGFuZGxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZHJhZ2dpbmcgPSB0cnVlOyAvLyBQZXJzaXN0ZW50IGZvciB0aHJvdHRsZS5cblxuICAgIHZhciB0cmFucyA9IHRoaXMudXBkYXRlSGFuZGxlVHJhbnNmb3JtKGdldEhhbmRsZVRyYW5zUHJvcHMoaGFuZGxlKSwgW2R4LCBkeV0sIHRoaXMuX2F4aXNNb2RlbCwgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgdGhpcy5fcGF5bG9hZEluZm8gPSB0cmFucztcbiAgICBoYW5kbGUuc3RvcEFuaW1hdGlvbigpO1xuICAgIGhhbmRsZS5hdHRyKGdldEhhbmRsZVRyYW5zUHJvcHModHJhbnMpKTtcbiAgICBpbm5lcihoYW5kbGUpLmxhc3RQcm9wID0gbnVsbDtcblxuICAgIHRoaXMuX2RvRGlzcGF0Y2hBeGlzUG9pbnRlcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaHJvdHRsZWQgbWV0aG9kLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RvRGlzcGF0Y2hBeGlzUG9pbnRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG5cbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXlsb2FkSW5mbyA9IHRoaXMuX3BheWxvYWRJbmZvO1xuICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLl9heGlzTW9kZWw7XG5cbiAgICB0aGlzLl9hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgIHg6IHBheWxvYWRJbmZvLmN1cnNvclBvaW50WzBdLFxuICAgICAgeTogcGF5bG9hZEluZm8uY3Vyc29yUG9pbnRbMV0sXG4gICAgICB0b29sdGlwT3B0aW9uOiBwYXlsb2FkSW5mby50b29sdGlwT3B0aW9uLFxuICAgICAgYXhlc0luZm86IFt7XG4gICAgICAgIGF4aXNEaW06IGF4aXNNb2RlbC5heGlzLmRpbSxcbiAgICAgICAgYXhpc0luZGV4OiBheGlzTW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25IYW5kbGVEcmFnRW5kOiBmdW5jdGlvbiAobW92ZUFuaW1hdGlvbikge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcblxuICAgIGlmICghaGFuZGxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5fYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3ZhbHVlJyk7IC8vIENvbnNpZGVyIHNuYXAgb3IgY2F0ZWdyb3kgYXhpcywgaGFuZGxlIG1heSBiZSBub3QgY29uc2lzdGVudCB3aXRoXG4gICAgLy8gYXhpc1BvaW50ZXIuIFNvIG1vdmUgaGFuZGxlIHRvIGFsaWduIHRoZSBleGFjdCB2YWx1ZSBwb3NpdGlvbiB3aGVuXG4gICAgLy8gZHJhZyBlbmRlZC5cblxuXG4gICAgdGhpcy5fbW92ZUhhbmRsZVRvVmFsdWUodmFsdWUpOyAvLyBGb3IgdGhlIGVmZmVjdDogdG9vbHRpcCB3aWxsIGJlIHNob3duIHdoZW4gZmluZ2VyIGhvbGRpbmcgb24gaGFuZGxlXG4gICAgLy8gYnV0dG9uLCBhbmQgd2lsbCBiZSBoaWRkZW4gYWZ0ZXIgZmluZ2VyIGxlZnQgaGFuZGxlIGJ1dHRvbi5cblxuXG4gICAgdGhpcy5fYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdoaWRlVGlwJ1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaG91bGQgYmUgaW1wbGVtZW5lbnRlZCBieSBzdWItY2xhc3MgaWYgc3VwcG9ydCBgaGFuZGxlYC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc01vZGVsXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGF4aXNQb2ludGVyTW9kZWxcbiAgICogQHJldHVybiB7T2JqZWN0fSB7cG9zaXRpb246IFt4LCB5XSwgcm90YXRpb246IDB9XG4gICAqL1xuICBnZXRIYW5kbGVUcmFuc2Zvcm06IG51bGwsXG5cbiAgLyoqXG4gICAqICogU2hvdWxkIGJlIGltcGxlbWVuZW50ZWQgYnkgc3ViLWNsYXNzIGlmIHN1cHBvcnQgYGhhbmRsZWAuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSB7cG9zaXRpb24sIHJvdGF0aW9ufVxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkZWx0YSBbZHgsIGR5XVxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzTW9kZWxcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc1BvaW50ZXJNb2RlbFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHtwb3NpdGlvbjogW3gsIHldLCByb3RhdGlvbjogMCwgY3Vyc29yUG9pbnQ6IFt4LCB5XX1cbiAgICovXG4gIHVwZGF0ZUhhbmRsZVRyYW5zZm9ybTogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoYXBpKSB7XG4gICAgdGhpcy5fbGFzdFZhbHVlID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0U3RhdHVzID0gbnVsbDtcbiAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cDtcbiAgICB2YXIgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuXG4gICAgaWYgKHpyICYmIGdyb3VwKSB7XG4gICAgICB0aGlzLl9sYXN0R3JhcGhpY0tleSA9IG51bGw7XG4gICAgICBncm91cCAmJiB6ci5yZW1vdmUoZ3JvdXApO1xuICAgICAgaGFuZGxlICYmIHpyLnJlbW92ZShoYW5kbGUpO1xuICAgICAgdGhpcy5fZ3JvdXAgPSBudWxsO1xuICAgICAgdGhpcy5faGFuZGxlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BheWxvYWRJbmZvID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRvQ2xlYXI6IGZ1bmN0aW9uICgpIHsvLyBJbXBsZW1lbnRlZCBieSBzdWItY2xhc3MgaWYgbmVjZXNzYXJ5LlxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHh5XG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHdoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeERpbUluZGV4PTBdIG9yIDFcbiAgICovXG4gIGJ1aWxkTGFiZWw6IGZ1bmN0aW9uICh4eSwgd2gsIHhEaW1JbmRleCkge1xuICAgIHhEaW1JbmRleCA9IHhEaW1JbmRleCB8fCAwO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4eVt4RGltSW5kZXhdLFxuICAgICAgeTogeHlbMSAtIHhEaW1JbmRleF0sXG4gICAgICB3aWR0aDogd2hbeERpbUluZGV4XSxcbiAgICAgIGhlaWdodDogd2hbMSAtIHhEaW1JbmRleF1cbiAgICB9O1xuICB9XG59O1xuQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhc2VBeGlzUG9pbnRlcjtcblxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoYW5pbWF0aW9uTW9kZWwsIG1vdmVBbmltYXRpb24sIGVsLCBwcm9wcykge1xuICAvLyBBbmltYXRpb24gb3B0aW1pemUuXG4gIGlmICghcHJvcHNFcXVhbChpbm5lcihlbCkubGFzdFByb3AsIHByb3BzKSkge1xuICAgIGlubmVyKGVsKS5sYXN0UHJvcCA9IHByb3BzO1xuICAgIG1vdmVBbmltYXRpb24gPyBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCBwcm9wcywgYW5pbWF0aW9uTW9kZWwpIDogKGVsLnN0b3BBbmltYXRpb24oKSwgZWwuYXR0cihwcm9wcykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb3BzRXF1YWwobGFzdFByb3BzLCBuZXdQcm9wcykge1xuICBpZiAoenJVdGlsLmlzT2JqZWN0KGxhc3RQcm9wcykgJiYgenJVdGlsLmlzT2JqZWN0KG5ld1Byb3BzKSkge1xuICAgIHZhciBlcXVhbHMgPSB0cnVlO1xuICAgIHpyVXRpbC5lYWNoKG5ld1Byb3BzLCBmdW5jdGlvbiAoaXRlbSwga2V5KSB7XG4gICAgICBlcXVhbHMgPSBlcXVhbHMgJiYgcHJvcHNFcXVhbChsYXN0UHJvcHNba2V5XSwgaXRlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhZXF1YWxzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXN0UHJvcHMgPT09IG5ld1Byb3BzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxhYmVsU2hvd0hpZGUobGFiZWxFbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICBsYWJlbEVsW2F4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5zaG93JykgPyAnc2hvdycgOiAnaGlkZSddKCk7XG59XG5cbmZ1bmN0aW9uIGdldEhhbmRsZVRyYW5zUHJvcHModHJhbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogdHJhbnMucG9zaXRpb24uc2xpY2UoKSxcbiAgICByb3RhdGlvbjogdHJhbnMucm90YXRpb24gfHwgMFxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYW5kYXRvcnlQcm9wcyhncm91cCwgYXhpc1BvaW50ZXJNb2RlbCwgc2lsZW50KSB7XG4gIHZhciB6ID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3onKTtcbiAgdmFyIHpsZXZlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd6bGV2ZWwnKTtcbiAgZ3JvdXAgJiYgZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLnR5cGUgIT09ICdncm91cCcpIHtcbiAgICAgIHogIT0gbnVsbCAmJiAoZWwueiA9IHopO1xuICAgICAgemxldmVsICE9IG51bGwgJiYgKGVsLnpsZXZlbCA9IHpsZXZlbCk7XG4gICAgICBlbC5zaWxlbnQgPSBzaWxlbnQ7XG4gICAgfVxuICB9KTtcbn1cblxuY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKEJhc2VBeGlzUG9pbnRlcik7XG52YXIgX2RlZmF1bHQgPSBCYXNlQXhpc1BvaW50ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9CYXNlQXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9CYXNlQXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBCYXNlQXhpc1BvaW50ZXIgPSByZXF1aXJlKFwiLi9CYXNlQXhpc1BvaW50ZXJcIik7XG5cbnZhciB2aWV3SGVscGVyID0gcmVxdWlyZShcIi4vdmlld0hlbHBlclwiKTtcblxudmFyIGNhcnRlc2lhbkF4aXNIZWxwZXIgPSByZXF1aXJlKFwiLi4vLi4vY29vcmQvY2FydGVzaWFuL2NhcnRlc2lhbkF4aXNIZWxwZXJcIik7XG5cbnZhciBBeGlzVmlldyA9IHJlcXVpcmUoXCIuLi9heGlzL0F4aXNWaWV3XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgQ2FydGVzaWFuQXhpc1BvaW50ZXIgPSBCYXNlQXhpc1BvaW50ZXIuZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbWFrZUVsT3B0aW9uOiBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIGdyaWQgPSBheGlzLmdyaWQ7XG4gICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgdmFyIG90aGVyRXh0ZW50ID0gZ2V0Q2FydGVzaWFuKGdyaWQsIGF4aXMpLmdldE90aGVyQXhpcyhheGlzKS5nZXRHbG9iYWxFeHRlbnQoKTtcbiAgICB2YXIgcGl4ZWxWYWx1ZSA9IGF4aXMudG9HbG9iYWxDb29yZChheGlzLmRhdGFUb0Nvb3JkKHZhbHVlLCB0cnVlKSk7XG5cbiAgICBpZiAoYXhpc1BvaW50ZXJUeXBlICYmIGF4aXNQb2ludGVyVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICB2YXIgZWxTdHlsZSA9IHZpZXdIZWxwZXIuYnVpbGRFbFN0eWxlKGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgdmFyIHBvaW50ZXJPcHRpb24gPSBwb2ludGVyU2hhcGVCdWlsZGVyW2F4aXNQb2ludGVyVHlwZV0oYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQsIGVsU3R5bGUpO1xuICAgICAgcG9pbnRlck9wdGlvbi5zdHlsZSA9IGVsU3R5bGU7XG4gICAgICBlbE9wdGlvbi5ncmFwaGljS2V5ID0gcG9pbnRlck9wdGlvbi50eXBlO1xuICAgICAgZWxPcHRpb24ucG9pbnRlciA9IHBvaW50ZXJPcHRpb247XG4gICAgfVxuXG4gICAgdmFyIGxheW91dEluZm8gPSBjYXJ0ZXNpYW5BeGlzSGVscGVyLmxheW91dChncmlkLm1vZGVsLCBheGlzTW9kZWwpO1xuICAgIHZpZXdIZWxwZXIuYnVpbGRDYXJ0ZXNpYW5TaW5nbGVMYWJlbEVsT3B0aW9uKHZhbHVlLCBlbE9wdGlvbiwgbGF5b3V0SW5mbywgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEhhbmRsZVRyYW5zZm9ybTogZnVuY3Rpb24gKHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgbGF5b3V0SW5mbyA9IGNhcnRlc2lhbkF4aXNIZWxwZXIubGF5b3V0KGF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWwsIGF4aXNNb2RlbCwge1xuICAgICAgbGFiZWxJbnNpZGU6IGZhbHNlXG4gICAgfSk7XG4gICAgbGF5b3V0SW5mby5sYWJlbE1hcmdpbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdoYW5kbGUubWFyZ2luJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiB2aWV3SGVscGVyLmdldFRyYW5zZm9ybWVkUG9zaXRpb24oYXhpc01vZGVsLmF4aXMsIHZhbHVlLCBsYXlvdXRJbmZvKSxcbiAgICAgIHJvdGF0aW9uOiBsYXlvdXRJbmZvLnJvdGF0aW9uICsgKGxheW91dEluZm8ubGFiZWxEaXJlY3Rpb24gPCAwID8gTWF0aC5QSSA6IDApXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB1cGRhdGVIYW5kbGVUcmFuc2Zvcm06IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIGRlbHRhLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciBncmlkID0gYXhpcy5ncmlkO1xuICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRHbG9iYWxFeHRlbnQodHJ1ZSk7XG4gICAgdmFyIG90aGVyRXh0ZW50ID0gZ2V0Q2FydGVzaWFuKGdyaWQsIGF4aXMpLmdldE90aGVyQXhpcyhheGlzKS5nZXRHbG9iYWxFeHRlbnQoKTtcbiAgICB2YXIgZGltSW5kZXggPSBheGlzLmRpbSA9PT0gJ3gnID8gMCA6IDE7XG4gICAgdmFyIGN1cnJQb3NpdGlvbiA9IHRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdICs9IGRlbHRhW2RpbUluZGV4XTtcbiAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5taW4oYXhpc0V4dGVudFsxXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG4gICAgY3VyclBvc2l0aW9uW2RpbUluZGV4XSA9IE1hdGgubWF4KGF4aXNFeHRlbnRbMF0sIGN1cnJQb3NpdGlvbltkaW1JbmRleF0pO1xuICAgIHZhciBjdXJzb3JPdGhlclZhbHVlID0gKG90aGVyRXh0ZW50WzFdICsgb3RoZXJFeHRlbnRbMF0pIC8gMjtcbiAgICB2YXIgY3Vyc29yUG9pbnQgPSBbY3Vyc29yT3RoZXJWYWx1ZSwgY3Vyc29yT3RoZXJWYWx1ZV07XG4gICAgY3Vyc29yUG9pbnRbZGltSW5kZXhdID0gY3VyclBvc2l0aW9uW2RpbUluZGV4XTsgLy8gTWFrZSB0b29sdGlwIGRvIG5vdCBvdmVybGFwIGF4aXNQb2ludGVyIGFuZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBncmlkLlxuXG4gICAgdmFyIHRvb2x0aXBPcHRpb25zID0gW3tcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgfSwge1xuICAgICAgYWxpZ246ICdjZW50ZXInXG4gICAgfV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiBjdXJyUG9zaXRpb24sXG4gICAgICByb3RhdGlvbjogdHJhbnNmb3JtLnJvdGF0aW9uLFxuICAgICAgY3Vyc29yUG9pbnQ6IGN1cnNvclBvaW50LFxuICAgICAgdG9vbHRpcE9wdGlvbjogdG9vbHRpcE9wdGlvbnNbZGltSW5kZXhdXG4gICAgfTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldENhcnRlc2lhbihncmlkLCBheGlzKSB7XG4gIHZhciBvcHQgPSB7fTtcbiAgb3B0W2F4aXMuZGltICsgJ0F4aXNJbmRleCddID0gYXhpcy5pbmRleDtcbiAgcmV0dXJuIGdyaWQuZ2V0Q2FydGVzaWFuKG9wdCk7XG59XG5cbnZhciBwb2ludGVyU2hhcGVCdWlsZGVyID0ge1xuICBsaW5lOiBmdW5jdGlvbiAoYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQsIGVsU3R5bGUpIHtcbiAgICB2YXIgdGFyZ2V0U2hhcGUgPSB2aWV3SGVscGVyLm1ha2VMaW5lU2hhcGUoW3BpeGVsVmFsdWUsIG90aGVyRXh0ZW50WzBdXSwgW3BpeGVsVmFsdWUsIG90aGVyRXh0ZW50WzFdXSwgZ2V0QXhpc0RpbUluZGV4KGF4aXMpKTtcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKHtcbiAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZSxcbiAgICAgIHN0eWxlOiBlbFN0eWxlXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdMaW5lJyxcbiAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgIH07XG4gIH0sXG4gIHNoYWRvdzogZnVuY3Rpb24gKGF4aXMsIHBpeGVsVmFsdWUsIG90aGVyRXh0ZW50LCBlbFN0eWxlKSB7XG4gICAgdmFyIGJhbmRXaWR0aCA9IE1hdGgubWF4KDEsIGF4aXMuZ2V0QmFuZFdpZHRoKCkpO1xuICAgIHZhciBzcGFuID0gb3RoZXJFeHRlbnRbMV0gLSBvdGhlckV4dGVudFswXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1JlY3QnLFxuICAgICAgc2hhcGU6IHZpZXdIZWxwZXIubWFrZVJlY3RTaGFwZShbcGl4ZWxWYWx1ZSAtIGJhbmRXaWR0aCAvIDIsIG90aGVyRXh0ZW50WzBdXSwgW2JhbmRXaWR0aCwgc3Bhbl0sIGdldEF4aXNEaW1JbmRleChheGlzKSlcbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRBeGlzRGltSW5kZXgoYXhpcykge1xuICByZXR1cm4gYXhpcy5kaW0gPT09ICd4JyA/IDAgOiAxO1xufVxuXG5BeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MoJ0NhcnRlc2lhbkF4aXNQb2ludGVyJywgQ2FydGVzaWFuQXhpc1BvaW50ZXIpO1xudmFyIF9kZWZhdWx0ID0gQ2FydGVzaWFuQXhpc1BvaW50ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0NhcnRlc2lhbkF4aXNQb2ludGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBfbW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIG1ha2VJbm5lciA9IF9tb2RlbC5tYWtlSW5uZXI7XG5cbnZhciBtb2RlbEhlbHBlciA9IHJlcXVpcmUoXCIuL21vZGVsSGVscGVyXCIpO1xuXG52YXIgZmluZFBvaW50RnJvbVNlcmllcyA9IHJlcXVpcmUoXCIuL2ZpbmRQb2ludEZyb21TZXJpZXNcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbi8qKlxuICogQmFzaWMgbG9naWM6IGNoZWNrIGFsbCBheGlzLCBpZiB0aGV5IGRvIG5vdCBkZW1hbmQgc2hvdy9oaWdobGlnaHQsXG4gKiB0aGVuIGhpZGUvZG93bnBsYXkgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29vcmRTeXNBeGVzSW5mb1xuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bG9hZC5jdXJyVHJpZ2dlcl0gJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ2xlYXZlJ1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3BheWxvYWQueF0geCBhbmQgeSwgd2hpY2ggYXJlIG1hbmRhdG9yeSwgc3BlY2lmeSBhIHBvaW50IHRvXG4gKiAgICAgICAgICAgICAgdHJpZ2dlciBheGlzUG9pbnRlciBhbmQgdG9vbHRpcC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtwYXlsb2FkLnldIHggYW5kIHksIHdoaWNoIGFyZSBtYW5kYXRvcnksIHNwZWNpZnkgYSBwb2ludCB0b1xuICogICAgICAgICAgICAgIHRyaWdnZXIgYXhpc1BvaW50ZXIgYW5kIHRvb2x0aXAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3BheWxvYWQuc2VyaWVzSW5kZXhdIGZpbmRlciwgb3B0aW9uYWwsIHJlc3RyaWN0IHRhcmdldCBheGVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXlsb2FkLmRhdGFJbmRleF0gZmluZGVyLCByZXN0cmljdCB0YXJnZXQgYXhlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGF5bG9hZC5heGVzSW5mb10gZmluZGVyLCByZXN0cmljdCB0YXJnZXQgYXhlcy5cbiAqICAgICAgICBbe1xuICogICAgICAgICAgYXhpc0RpbTogJ3gnfCd5J3wnYW5nbGUnfC4uLixcbiAqICAgICAgICAgIGF4aXNJbmRleDogLi4uLFxuICogICAgICAgICAgdmFsdWU6IC4uLlxuICogICAgICAgIH0sIC4uLl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXlsb2FkLmRpc3BhdGNoQWN0aW9uXVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXlsb2FkLnRvb2x0aXBPcHRpb25dXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheS48bnVtYmVyPnxGdW5jdGlvbn0gW3BheWxvYWQucG9zaXRpb25dIFRvb2x0aXAgcG9zaXRpb24sXG4gKiAgICAgICAgd2hpY2ggY2FuIGJlIHNwZWNpZmllZCBpbiBkaXNwYXRjaEFjdGlvblxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqIEByZXR1cm4ge09iamVjdH0gY29udGVudCBvZiBldmVudCBvYmogZm9yIGVjaGFydHMuY29ubmVjdC5cbiAqL1xuXG5mdW5jdGlvbiBfZGVmYXVsdChwYXlsb2FkLCBlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGN1cnJUcmlnZ2VyID0gcGF5bG9hZC5jdXJyVHJpZ2dlcjtcbiAgdmFyIHBvaW50ID0gW3BheWxvYWQueCwgcGF5bG9hZC55XTtcbiAgdmFyIGZpbmRlciA9IHBheWxvYWQ7XG4gIHZhciBkaXNwYXRjaEFjdGlvbiA9IHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gfHwgenJVdGlsLmJpbmQoYXBpLmRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICB2YXIgY29vcmRTeXNBeGVzSW5mbyA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpLmNvb3JkU3lzQXhlc0luZm87IC8vIFBlbmRpbmdcbiAgLy8gU2VlICM2MTIxLiBCdXQgd2UgYXJlIG5vdCBhYmxlIHRvIHJlcHJvZHVjZSBpdCB5ZXQuXG5cbiAgaWYgKCFjb29yZFN5c0F4ZXNJbmZvKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlsbGVnYWxQb2ludChwb2ludCkpIHtcbiAgICAvLyBVc2VkIGluIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGBjb25uZWN0aW9uYDogdXNlIHRoZSBzYW1wbGUgc2VyaWVzSW5kZXhcbiAgICAvLyBhbmQgZGF0YUluZGV4LiBBbmQgYWxzbyB1c2VkIGluIHRoZSB0b29sdGlwVmlldyB0cmlnZ2VyLlxuICAgIHBvaW50ID0gZmluZFBvaW50RnJvbVNlcmllcyh7XG4gICAgICBzZXJpZXNJbmRleDogZmluZGVyLnNlcmllc0luZGV4LFxuICAgICAgLy8gRG8gbm90IHVzZSBkYXRhSW5kZXhJbnNpZGUgZnJvbSBvdGhlciBlYyBpbnN0YW5jZS5cbiAgICAgIC8vIEZJWE1FOiBhdXRvIGRldGVjdCBpdD9cbiAgICAgIGRhdGFJbmRleDogZmluZGVyLmRhdGFJbmRleFxuICAgIH0sIGVjTW9kZWwpLnBvaW50O1xuICB9XG5cbiAgdmFyIGlzSWxsZWdhbFBvaW50ID0gaWxsZWdhbFBvaW50KHBvaW50KTsgLy8gQXhpcyBhbmQgdmFsdWUgY2FuIGJlIHNwZWNpZmllZCB3aGVuIGNhbGxpbmcgZGlzcGF0Y2hBY3Rpb24oe3R5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcid9KS5cbiAgLy8gTm90aWNlOiBJbiB0aGlzIGNhc2UsIGl0IGlzIGRpZmZpY3VsdCB0byBnZXQgdGhlIGBwb2ludGAgKHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBzaG93XG4gIC8vIHRvb2x0aXAsIHNvIGlmIHBvaW50IGlzIG5vdCBnaXZlbiwgd2UganVzdCB1c2UgdGhlIHBvaW50IGZvdW5kIGJ5IHNhbXBsZSBzZXJpZXNJbmRleFxuICAvLyBhbmQgZGF0YUluZGV4LlxuXG4gIHZhciBpbnB1dEF4ZXNJbmZvID0gZmluZGVyLmF4ZXNJbmZvO1xuICB2YXIgYXhlc0luZm8gPSBjb29yZFN5c0F4ZXNJbmZvLmF4ZXNJbmZvO1xuICB2YXIgc2hvdWxkSGlkZSA9IGN1cnJUcmlnZ2VyID09PSAnbGVhdmUnIHx8IGlsbGVnYWxQb2ludChwb2ludCk7XG4gIHZhciBvdXRwdXRGaW5kZXIgPSB7fTtcbiAgdmFyIHNob3dWYWx1ZU1hcCA9IHt9O1xuICB2YXIgZGF0YUJ5Q29vcmRTeXMgPSB7XG4gICAgbGlzdDogW10sXG4gICAgbWFwOiB7fVxuICB9O1xuICB2YXIgdXBkYXRlcnMgPSB7XG4gICAgc2hvd1BvaW50ZXI6IGN1cnJ5KHNob3dQb2ludGVyLCBzaG93VmFsdWVNYXApLFxuICAgIHNob3dUb29sdGlwOiBjdXJyeShzaG93VG9vbHRpcCwgZGF0YUJ5Q29vcmRTeXMpXG4gIH07IC8vIFByb2Nlc3MgZm9yIHRyaWdnZXJlZCBheGVzLlxuXG4gIGVhY2goY29vcmRTeXNBeGVzSW5mby5jb29yZFN5c01hcCwgZnVuY3Rpb24gKGNvb3JkU3lzLCBjb29yZFN5c0tleSkge1xuICAgIC8vIElmIGEgcG9pbnQgZ2l2ZW4sIGl0IG11c3QgYmUgY29udGFpbmVkIGJ5IHRoZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICB2YXIgY29vcmRTeXNDb250YWluc1BvaW50ID0gaXNJbGxlZ2FsUG9pbnQgfHwgY29vcmRTeXMuY29udGFpblBvaW50KHBvaW50KTtcbiAgICBlYWNoKGNvb3JkU3lzQXhlc0luZm8uY29vcmRTeXNBeGVzSW5mb1tjb29yZFN5c0tleV0sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgICB2YXIgYXhpcyA9IGF4aXNJbmZvLmF4aXM7XG4gICAgICB2YXIgaW5wdXRBeGlzSW5mbyA9IGZpbmRJbnB1dEF4aXNJbmZvKGlucHV0QXhlc0luZm8sIGF4aXNJbmZvKTsgLy8gSWYgbm8gaW5wdXRBeGVzSW5mbywgbm8gYXhpcyBpcyByZXN0cmljdGVkLlxuXG4gICAgICBpZiAoIXNob3VsZEhpZGUgJiYgY29vcmRTeXNDb250YWluc1BvaW50ICYmICghaW5wdXRBeGVzSW5mbyB8fCBpbnB1dEF4aXNJbmZvKSkge1xuICAgICAgICB2YXIgdmFsID0gaW5wdXRBeGlzSW5mbyAmJiBpbnB1dEF4aXNJbmZvLnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCAmJiAhaXNJbGxlZ2FsUG9pbnQpIHtcbiAgICAgICAgICB2YWwgPSBheGlzLnBvaW50VG9EYXRhKHBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbCAhPSBudWxsICYmIHByb2Nlc3NPbkF4aXMoYXhpc0luZm8sIHZhbCwgdXBkYXRlcnMsIGZhbHNlLCBvdXRwdXRGaW5kZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTsgLy8gUHJvY2VzcyBmb3IgbGlua2VkIGF4ZXMuXG5cbiAgdmFyIGxpbmtUcmlnZ2VycyA9IHt9O1xuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAodGFyQXhpc0luZm8sIHRhcktleSkge1xuICAgIHZhciBsaW5rR3JvdXAgPSB0YXJBeGlzSW5mby5saW5rR3JvdXA7IC8vIElmIGF4aXMgaGFzIGJlZW4gdHJpZ2dlcmVkIGluIHRoZSBwcmV2aW91cyBzdGFnZSwgaXQgc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgYnkgbGluay5cblxuICAgIGlmIChsaW5rR3JvdXAgJiYgIXNob3dWYWx1ZU1hcFt0YXJLZXldKSB7XG4gICAgICBlYWNoKGxpbmtHcm91cC5heGVzSW5mbywgZnVuY3Rpb24gKHNyY0F4aXNJbmZvLCBzcmNLZXkpIHtcbiAgICAgICAgdmFyIHNyY1ZhbEl0ZW0gPSBzaG93VmFsdWVNYXBbc3JjS2V5XTsgLy8gSWYgc3JjVmFsSXRlbSBleGlzdCwgc291cmNlIGF4aXMgaXMgdHJpZ2dlcmVkLCBzbyBsaW5rIHRvIHRhcmdldCBheGlzLlxuXG4gICAgICAgIGlmIChzcmNBeGlzSW5mbyAhPT0gdGFyQXhpc0luZm8gJiYgc3JjVmFsSXRlbSkge1xuICAgICAgICAgIHZhciB2YWwgPSBzcmNWYWxJdGVtLnZhbHVlO1xuICAgICAgICAgIGxpbmtHcm91cC5tYXBwZXIgJiYgKHZhbCA9IHRhckF4aXNJbmZvLmF4aXMuc2NhbGUucGFyc2UobGlua0dyb3VwLm1hcHBlcih2YWwsIG1ha2VNYXBwZXJQYXJhbShzcmNBeGlzSW5mbyksIG1ha2VNYXBwZXJQYXJhbSh0YXJBeGlzSW5mbykpKSk7XG4gICAgICAgICAgbGlua1RyaWdnZXJzW3RhckF4aXNJbmZvLmtleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGVhY2gobGlua1RyaWdnZXJzLCBmdW5jdGlvbiAodmFsLCB0YXJLZXkpIHtcbiAgICBwcm9jZXNzT25BeGlzKGF4ZXNJbmZvW3RhcktleV0sIHZhbCwgdXBkYXRlcnMsIHRydWUsIG91dHB1dEZpbmRlcik7XG4gIH0pO1xuICB1cGRhdGVNb2RlbEFjdHVhbGx5KHNob3dWYWx1ZU1hcCwgYXhlc0luZm8sIG91dHB1dEZpbmRlcik7XG4gIGRpc3BhdGNoVG9vbHRpcEFjdHVhbGx5KGRhdGFCeUNvb3JkU3lzLCBwb2ludCwgcGF5bG9hZCwgZGlzcGF0Y2hBY3Rpb24pO1xuICBkaXNwYXRjaEhpZ2hEb3duQWN0dWFsbHkoYXhlc0luZm8sIGRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICByZXR1cm4gb3V0cHV0RmluZGVyO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25BeGlzKGF4aXNJbmZvLCBuZXdWYWx1ZSwgdXBkYXRlcnMsIGRvbnRTbmFwLCBvdXRwdXRGaW5kZXIpIHtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuXG4gIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSB8fCAhYXhpcy5jb250YWluRGF0YShuZXdWYWx1ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWF4aXNJbmZvLmludm9sdmVTZXJpZXMpIHtcbiAgICB1cGRhdGVycy5zaG93UG9pbnRlcihheGlzSW5mbywgbmV3VmFsdWUpO1xuICAgIHJldHVybjtcbiAgfSAvLyBIZWF2eSBjYWxjdWxhdGlvbi4gU28gcHV0IGl0IGFmdGVyIGF4aXMuY29udGFpbkRhdGEgY2hlY2tpbmcuXG5cblxuICB2YXIgcGF5bG9hZEluZm8gPSBidWlsZFBheWxvYWRzQnlTZXJpZXMobmV3VmFsdWUsIGF4aXNJbmZvKTtcbiAgdmFyIHBheWxvYWRCYXRjaCA9IHBheWxvYWRJbmZvLnBheWxvYWRCYXRjaDtcbiAgdmFyIHNuYXBUb1ZhbHVlID0gcGF5bG9hZEluZm8uc25hcFRvVmFsdWU7IC8vIEZpbGwgY29udGVudCBvZiBldmVudCBvYmogZm9yIGVjaGFydHMuY29ubmVjdC5cbiAgLy8gQnkgZGVmdWFsdCB1c2UgdGhlIGZpcnN0IGludm9sdmVkIHNlcmllcyBkYXRhIGFzIGEgc2FtcGxlIHRvIGNvbm5lY3QuXG5cbiAgaWYgKHBheWxvYWRCYXRjaFswXSAmJiBvdXRwdXRGaW5kZXIuc2VyaWVzSW5kZXggPT0gbnVsbCkge1xuICAgIHpyVXRpbC5leHRlbmQob3V0cHV0RmluZGVyLCBwYXlsb2FkQmF0Y2hbMF0pO1xuICB9IC8vIElmIG5vIGxpbmtTb3VyY2UgaW5wdXQsIHRoaXMgcHJvY2VzcyBpcyBmb3IgY29sbGVjdGluZyBsaW5rXG4gIC8vIHRhcmdldCwgd2hlcmUgc25hcCBzaG91bGQgbm90IGJlIGFjY2VwdGVkLlxuXG5cbiAgaWYgKCFkb250U25hcCAmJiBheGlzSW5mby5zbmFwKSB7XG4gICAgaWYgKGF4aXMuY29udGFpbkRhdGEoc25hcFRvVmFsdWUpICYmIHNuYXBUb1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5ld1ZhbHVlID0gc25hcFRvVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlcnMuc2hvd1BvaW50ZXIoYXhpc0luZm8sIG5ld1ZhbHVlLCBwYXlsb2FkQmF0Y2gsIG91dHB1dEZpbmRlcik7IC8vIFRvb2x0aXAgc2hvdWxkIGFsd2F5cyBiZSBzbmFwVG9WYWx1ZSwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IFwiYXhpcyB2YWx1ZSB+IHNlcmllcyB2YWx1ZVwiIG1hcHBpbmcgZGlzcGxheWVkIGluIHRvb2x0aXAuXG5cbiAgdXBkYXRlcnMuc2hvd1Rvb2x0aXAoYXhpc0luZm8sIHBheWxvYWRJbmZvLCBzbmFwVG9WYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF5bG9hZHNCeVNlcmllcyh2YWx1ZSwgYXhpc0luZm8pIHtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICB2YXIgZGltID0gYXhpcy5kaW07XG4gIHZhciBzbmFwVG9WYWx1ZSA9IHZhbHVlO1xuICB2YXIgcGF5bG9hZEJhdGNoID0gW107XG4gIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgdmFyIG1pbkRpZmYgPSAtMTtcbiAgZWFjaChheGlzSW5mby5zZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXMsIGlkeCkge1xuICAgIHZhciBkYXRhRGltID0gc2VyaWVzLmdldERhdGEoKS5tYXBEaW1lbnNpb24oZGltLCB0cnVlKTtcbiAgICB2YXIgc2VyaWVzTmVzdGVzdFZhbHVlO1xuICAgIHZhciBkYXRhSW5kaWNlcztcblxuICAgIGlmIChzZXJpZXMuZ2V0QXhpc1Rvb2x0aXBEYXRhKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gc2VyaWVzLmdldEF4aXNUb29sdGlwRGF0YShkYXRhRGltLCB2YWx1ZSwgYXhpcyk7XG4gICAgICBkYXRhSW5kaWNlcyA9IHJlc3VsdC5kYXRhSW5kaWNlcztcbiAgICAgIHNlcmllc05lc3Rlc3RWYWx1ZSA9IHJlc3VsdC5uZXN0ZXN0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFJbmRpY2VzID0gc2VyaWVzLmdldERhdGEoKS5pbmRpY2VzT2ZOZWFyZXN0KGRhdGFEaW1bMF0sIHZhbHVlLCAvLyBBZGQgYSB0aHJlc2hvbGQgdG8gYXZvaWQgZmluZCB0aGUgd3JvbmcgZGF0YUluZGV4XG4gICAgICAvLyB3aGVuIGRhdGEgbGVuZ3RoIGlzIG5vdCBzYW1lLlxuICAgICAgLy8gZmFsc2UsXG4gICAgICBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyAwLjUgOiBudWxsKTtcblxuICAgICAgaWYgKCFkYXRhSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXJpZXNOZXN0ZXN0VmFsdWUgPSBzZXJpZXMuZ2V0RGF0YSgpLmdldChkYXRhRGltWzBdLCBkYXRhSW5kaWNlc1swXSk7XG4gICAgfVxuXG4gICAgaWYgKHNlcmllc05lc3Rlc3RWYWx1ZSA9PSBudWxsIHx8ICFpc0Zpbml0ZShzZXJpZXNOZXN0ZXN0VmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRpZmYpOyAvLyBDb25zaWRlciBjYXRlZ29yeSBjYXNlXG5cbiAgICBpZiAoZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QgfHwgZGlmZiA+PSAwICYmIG1pbkRpZmYgPCAwKSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBtaW5EaWZmID0gZGlmZjtcbiAgICAgICAgc25hcFRvVmFsdWUgPSBzZXJpZXNOZXN0ZXN0VmFsdWU7XG4gICAgICAgIHBheWxvYWRCYXRjaC5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICBlYWNoKGRhdGFJbmRpY2VzLCBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHBheWxvYWRCYXRjaC5wdXNoKHtcbiAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzLnNlcmllc0luZGV4LFxuICAgICAgICAgIGRhdGFJbmRleEluc2lkZTogZGF0YUluZGV4LFxuICAgICAgICAgIGRhdGFJbmRleDogc2VyaWVzLmdldERhdGEoKS5nZXRSYXdJbmRleChkYXRhSW5kZXgpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwYXlsb2FkQmF0Y2g6IHBheWxvYWRCYXRjaCxcbiAgICBzbmFwVG9WYWx1ZTogc25hcFRvVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hvd1BvaW50ZXIoc2hvd1ZhbHVlTWFwLCBheGlzSW5mbywgdmFsdWUsIHBheWxvYWRCYXRjaCkge1xuICBzaG93VmFsdWVNYXBbYXhpc0luZm8ua2V5XSA9IHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcGF5bG9hZEJhdGNoOiBwYXlsb2FkQmF0Y2hcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZGF0YUJ5Q29vcmRTeXMsIGF4aXNJbmZvLCBwYXlsb2FkSW5mbywgdmFsdWUpIHtcbiAgdmFyIHBheWxvYWRCYXRjaCA9IHBheWxvYWRJbmZvLnBheWxvYWRCYXRjaDtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsOyAvLyBJZiBubyBkYXRhLCBkbyBub3QgY3JlYXRlIGFueXRoaW5nIGluIGRhdGFCeUNvb3JkU3lzLFxuICAvLyB3aG9zZSBsZW5ndGggd2lsbCBiZSB1c2VkIHRvIGp1ZGdlIHdoZXRoZXIgZGlzcGF0Y2ggYWN0aW9uLlxuXG4gIGlmICghYXhpc0luZm8udHJpZ2dlclRvb2x0aXAgfHwgIXBheWxvYWRCYXRjaC5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29vcmRTeXNNb2RlbCA9IGF4aXNJbmZvLmNvb3JkU3lzLm1vZGVsO1xuICB2YXIgY29vcmRTeXNLZXkgPSBtb2RlbEhlbHBlci5tYWtlS2V5KGNvb3JkU3lzTW9kZWwpO1xuICB2YXIgY29vcmRTeXNJdGVtID0gZGF0YUJ5Q29vcmRTeXMubWFwW2Nvb3JkU3lzS2V5XTtcblxuICBpZiAoIWNvb3JkU3lzSXRlbSkge1xuICAgIGNvb3JkU3lzSXRlbSA9IGRhdGFCeUNvb3JkU3lzLm1hcFtjb29yZFN5c0tleV0gPSB7XG4gICAgICBjb29yZFN5c0lkOiBjb29yZFN5c01vZGVsLmlkLFxuICAgICAgY29vcmRTeXNJbmRleDogY29vcmRTeXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIGNvb3JkU3lzVHlwZTogY29vcmRTeXNNb2RlbC50eXBlLFxuICAgICAgY29vcmRTeXNNYWluVHlwZTogY29vcmRTeXNNb2RlbC5tYWluVHlwZSxcbiAgICAgIGRhdGFCeUF4aXM6IFtdXG4gICAgfTtcbiAgICBkYXRhQnlDb29yZFN5cy5saXN0LnB1c2goY29vcmRTeXNJdGVtKTtcbiAgfVxuXG4gIGNvb3JkU3lzSXRlbS5kYXRhQnlBeGlzLnB1c2goe1xuICAgIGF4aXNEaW06IGF4aXMuZGltLFxuICAgIGF4aXNJbmRleDogYXhpc01vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgIGF4aXNUeXBlOiBheGlzTW9kZWwudHlwZSxcbiAgICBheGlzSWQ6IGF4aXNNb2RlbC5pZCxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgLy8gQ2F1c3Rpb246IHZpZXdIZWxwZXIuZ2V0VmFsdWVMYWJlbCBpcyBhY3R1YWxseSBvbiBcInZpZXcgc3RhZ2VcIiwgd2hpY2hcbiAgICAvLyBkZXBlbmRzIHRoYXQgYWxsIG1vZGVscyBoYXZlIGJlZW4gdXBkYXRlZC4gU28gaXQgc2hvdWxkIG5vdCBiZSBwZXJmb3JtZWRcbiAgICAvLyBoZXJlLiBDb25zaWRlcmluZyBheGlzUG9pbnRlck1vZGVsIHVzZWQgaGVyZSBpcyB2b2xhdGlsZSwgd2hpY2ggaXMgaGFyZFxuICAgIC8vIHRvIGJlIHJldHJpZXZlIGluIFRvb2x0aXBWaWV3LCB3ZSBwcmVwYXJlIHBhcmFtZXRlcnMgaGVyZS5cbiAgICB2YWx1ZUxhYmVsT3B0OiB7XG4gICAgICBwcmVjaXNpb246IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5wcmVjaXNpb24nKSxcbiAgICAgIGZvcm1hdHRlcjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLmZvcm1hdHRlcicpXG4gICAgfSxcbiAgICBzZXJpZXNEYXRhSW5kaWNlczogcGF5bG9hZEJhdGNoLnNsaWNlKClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQWN0dWFsbHkoc2hvd1ZhbHVlTWFwLCBheGVzSW5mbywgb3V0cHV0RmluZGVyKSB7XG4gIHZhciBvdXRwdXRBeGVzSW5mbyA9IG91dHB1dEZpbmRlci5heGVzSW5mbyA9IFtdOyAvLyBCYXNpYyBsb2dpYzogSWYgbm8gJ3Nob3cnIHJlcXVpcmVkLCAnaGlkZScgdGhpcyBheGlzUG9pbnRlci5cblxuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAoYXhpc0luZm8sIGtleSkge1xuICAgIHZhciBvcHRpb24gPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgICB2YXIgdmFsSXRlbSA9IHNob3dWYWx1ZU1hcFtrZXldO1xuXG4gICAgaWYgKHZhbEl0ZW0pIHtcbiAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnc2hvdycpO1xuICAgICAgb3B0aW9uLnZhbHVlID0gdmFsSXRlbS52YWx1ZTsgLy8gRm9yIGxhYmVsIGZvcm1hdHRlciBwYXJhbSBhbmQgaGlnaGxpZ2h0LlxuXG4gICAgICBvcHRpb24uc2VyaWVzRGF0YUluZGljZXMgPSAodmFsSXRlbS5wYXlsb2FkQmF0Y2ggfHwgW10pLnNsaWNlKCk7XG4gICAgfSAvLyBXaGVuIGFsd2F5cyBzaG93IChlLmcuLCBoYW5kbGUgdXNlZCksIHJlbWFpblxuICAgIC8vIG9yaWdpbmFsIHZhbHVlIGFuZCBzdGF0dXMuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIGhpZGUsIHZhbHVlIHN0aWxsIG5lZWQgdG8gYmUgc2V0LCBjb25zaWRlclxuICAgICAgICAvLyBjbGljayBsZWdlbmQgdG8gdG9nZ2xlIGF4aXMgYmxhbmsuXG4gICAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnaGlkZScpO1xuICAgICAgfSAvLyBJZiBzdGF0dXMgaXMgJ2hpZGUnLCBzaG91bGQgYmUgbm8gaW5mbyBpbiBwYXlsb2FkLlxuXG5cbiAgICBvcHRpb24uc3RhdHVzID09PSAnc2hvdycgJiYgb3V0cHV0QXhlc0luZm8ucHVzaCh7XG4gICAgICBheGlzRGltOiBheGlzSW5mby5heGlzLmRpbSxcbiAgICAgIGF4aXNJbmRleDogYXhpc0luZm8uYXhpcy5tb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIHZhbHVlOiBvcHRpb24udmFsdWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoVG9vbHRpcEFjdHVhbGx5KGRhdGFCeUNvb3JkU3lzLCBwb2ludCwgcGF5bG9hZCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgLy8gQmFzaWMgbG9naWM6IElmIG5vIHNob3dUaXAgcmVxdWlyZWQsIGhpZGVUaXAgd2lsbCBiZSBkaXNwYXRjaGVkLlxuICBpZiAoaWxsZWdhbFBvaW50KHBvaW50KSB8fCAhZGF0YUJ5Q29vcmRTeXMubGlzdC5sZW5ndGgpIHtcbiAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnaGlkZVRpcCdcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gSW4gbW9zdCBjYXNlIG9ubHkgb25lIGF4aXMgKG9yIGV2ZW50IG9uZSBzZXJpZXMgaXMgdXNlZCkuIEl0IGlzXG4gIC8vIGNvbnZpbmllbnQgdG8gZmV0Y2ggcGF5bG9hZC5zZXJpZXNJbmRleCBhbmQgcGF5bG9hZC5kYXRhSW5kZXhcbiAgLy8gZGlydGVjdGx5LiBTbyBwdXQgdGhlIGZpcnN0IHNlcmllc0luZGV4IGFuZCBkYXRhSW5kZXggb2YgdGhlIGZpcnN0XG4gIC8vIGF4aXMgb24gdGhlIHBheWxvYWQuXG5cblxuICB2YXIgc2FtcGxlSXRlbSA9ICgoZGF0YUJ5Q29vcmRTeXMubGlzdFswXS5kYXRhQnlBeGlzWzBdIHx8IHt9KS5zZXJpZXNEYXRhSW5kaWNlcyB8fCBbXSlbMF0gfHwge307XG4gIGRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgZXNjYXBlQ29ubmVjdDogdHJ1ZSxcbiAgICB4OiBwb2ludFswXSxcbiAgICB5OiBwb2ludFsxXSxcbiAgICB0b29sdGlwT3B0aW9uOiBwYXlsb2FkLnRvb2x0aXBPcHRpb24sXG4gICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgZGF0YUluZGV4SW5zaWRlOiBzYW1wbGVJdGVtLmRhdGFJbmRleEluc2lkZSxcbiAgICBkYXRhSW5kZXg6IHNhbXBsZUl0ZW0uZGF0YUluZGV4LFxuICAgIHNlcmllc0luZGV4OiBzYW1wbGVJdGVtLnNlcmllc0luZGV4LFxuICAgIGRhdGFCeUNvb3JkU3lzOiBkYXRhQnlDb29yZFN5cy5saXN0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEhpZ2hEb3duQWN0dWFsbHkoYXhlc0luZm8sIGRpc3BhdGNoQWN0aW9uLCBhcGkpIHtcbiAgLy8gRklYTUVcbiAgLy8gaGlnaGxpZ2h0IHN0YXR1cyBtb2RpZmljYXRpb24gc2hvdWxlIGJlIGEgc3RhZ2Ugb2YgbWFpbiBwcm9jZXNzP1xuICAvLyAoQ29uc2lkZXIgY29uZmlsY3QgKGUuZy4sIGxlZ2VuZCBhbmQgYXhpc1BvaW50ZXIpIGFuZCBzZXRPcHRpb24pXG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICB2YXIgaGlnaERvd25LZXkgPSAnYXhpc1BvaW50ZXJMYXN0SGlnaGxpZ2h0cyc7XG4gIHZhciBsYXN0SGlnaGxpZ2h0cyA9IGlubmVyKHpyKVtoaWdoRG93bktleV0gfHwge307XG4gIHZhciBuZXdIaWdobGlnaHRzID0gaW5uZXIoenIpW2hpZ2hEb3duS2V5XSA9IHt9OyAvLyBVcGRhdGUgaGlnaGxpZ2h0L2Rvd25wbGF5IHN0YXR1cyBhY2NvcmRpbmcgdG8gYXhpc1BvaW50ZXIgbW9kZWwuXG4gIC8vIEJ1aWxkIGhhc2ggbWFwIGFuZCByZW1vdmUgZHVwbGljYXRlIGluY2lkZW50YWxseS5cblxuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAoYXhpc0luZm8sIGtleSkge1xuICAgIHZhciBvcHRpb24gPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgICBvcHRpb24uc3RhdHVzID09PSAnc2hvdycgJiYgZWFjaChvcHRpb24uc2VyaWVzRGF0YUluZGljZXMsIGZ1bmN0aW9uIChiYXRjaEl0ZW0pIHtcbiAgICAgIHZhciBrZXkgPSBiYXRjaEl0ZW0uc2VyaWVzSW5kZXggKyAnIHwgJyArIGJhdGNoSXRlbS5kYXRhSW5kZXg7XG4gICAgICBuZXdIaWdobGlnaHRzW2tleV0gPSBiYXRjaEl0ZW07XG4gICAgfSk7XG4gIH0pOyAvLyBEaWZmLlxuXG4gIHZhciB0b0hpZ2hsaWdodCA9IFtdO1xuICB2YXIgdG9Eb3ducGxheSA9IFtdO1xuICB6clV0aWwuZWFjaChsYXN0SGlnaGxpZ2h0cywgZnVuY3Rpb24gKGJhdGNoSXRlbSwga2V5KSB7XG4gICAgIW5ld0hpZ2hsaWdodHNba2V5XSAmJiB0b0Rvd25wbGF5LnB1c2goYmF0Y2hJdGVtKTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKG5ld0hpZ2hsaWdodHMsIGZ1bmN0aW9uIChiYXRjaEl0ZW0sIGtleSkge1xuICAgICFsYXN0SGlnaGxpZ2h0c1trZXldICYmIHRvSGlnaGxpZ2h0LnB1c2goYmF0Y2hJdGVtKTtcbiAgfSk7XG4gIHRvRG93bnBsYXkubGVuZ3RoICYmIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgdHlwZTogJ2Rvd25wbGF5JyxcbiAgICBlc2NhcGVDb25uZWN0OiB0cnVlLFxuICAgIGJhdGNoOiB0b0Rvd25wbGF5XG4gIH0pO1xuICB0b0hpZ2hsaWdodC5sZW5ndGggJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnaGlnaGxpZ2h0JyxcbiAgICBlc2NhcGVDb25uZWN0OiB0cnVlLFxuICAgIGJhdGNoOiB0b0hpZ2hsaWdodFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZmluZElucHV0QXhpc0luZm8oaW5wdXRBeGVzSW5mbywgYXhpc0luZm8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAoaW5wdXRBeGVzSW5mbyB8fCBbXSkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5wdXRBeGlzSW5mbyA9IGlucHV0QXhlc0luZm9baV07XG5cbiAgICBpZiAoYXhpc0luZm8uYXhpcy5kaW0gPT09IGlucHV0QXhpc0luZm8uYXhpc0RpbSAmJiBheGlzSW5mby5heGlzLm1vZGVsLmNvbXBvbmVudEluZGV4ID09PSBpbnB1dEF4aXNJbmZvLmF4aXNJbmRleCkge1xuICAgICAgcmV0dXJuIGlucHV0QXhpc0luZm87XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VNYXBwZXJQYXJhbShheGlzSW5mbykge1xuICB2YXIgYXhpc01vZGVsID0gYXhpc0luZm8uYXhpcy5tb2RlbDtcbiAgdmFyIGl0ZW0gPSB7fTtcbiAgdmFyIGRpbSA9IGl0ZW0uYXhpc0RpbSA9IGF4aXNJbmZvLmF4aXMuZGltO1xuICBpdGVtLmF4aXNJbmRleCA9IGl0ZW1bZGltICsgJ0F4aXNJbmRleCddID0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4O1xuICBpdGVtLmF4aXNOYW1lID0gaXRlbVtkaW0gKyAnQXhpc05hbWUnXSA9IGF4aXNNb2RlbC5uYW1lO1xuICBpdGVtLmF4aXNJZCA9IGl0ZW1bZGltICsgJ0F4aXNJZCddID0gYXhpc01vZGVsLmlkO1xuICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gaWxsZWdhbFBvaW50KHBvaW50KSB7XG4gIHJldHVybiAhcG9pbnQgfHwgcG9pbnRbMF0gPT0gbnVsbCB8fCBpc05hTihwb2ludFswXSkgfHwgcG9pbnRbMV0gPT0gbnVsbCB8fCBpc05hTihwb2ludFsxXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2F4aXNUcmlnZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvYXhpc1RyaWdnZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbmRlciBjb250YWlucyB7c2VyaWVzSW5kZXgsIGRhdGFJbmRleCwgZGF0YUluZGV4SW5zaWRlfVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEByZXR1cm4ge09iamVjdH0ge3BvaW50OiBbeCwgeV0sIGVsOiAuLi59IHBvaW50IFdpbGwgbm90IGJlIG51bGwuXG4gKi9cbmZ1bmN0aW9uIF9kZWZhdWx0KGZpbmRlciwgZWNNb2RlbCkge1xuICB2YXIgcG9pbnQgPSBbXTtcbiAgdmFyIHNlcmllc0luZGV4ID0gZmluZGVyLnNlcmllc0luZGV4O1xuICB2YXIgc2VyaWVzTW9kZWw7XG5cbiAgaWYgKHNlcmllc0luZGV4ID09IG51bGwgfHwgIShzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCkpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBbXVxuICAgIH07XG4gIH1cblxuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBmaW5kZXIpO1xuXG4gIGlmIChkYXRhSW5kZXggPT0gbnVsbCB8fCBkYXRhSW5kZXggPCAwIHx8IHpyVXRpbC5pc0FycmF5KGRhdGFJbmRleCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IFtdXG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gIGlmIChzZXJpZXNNb2RlbC5nZXRUb29sdGlwUG9zaXRpb24pIHtcbiAgICBwb2ludCA9IHNlcmllc01vZGVsLmdldFRvb2x0aXBQb3NpdGlvbihkYXRhSW5kZXgpIHx8IFtdO1xuICB9IGVsc2UgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLmRhdGFUb1BvaW50KSB7XG4gICAgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludChkYXRhLmdldFZhbHVlcyh6clV0aWwubWFwKGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgIHJldHVybiBkYXRhLm1hcERpbWVuc2lvbihkaW0pO1xuICAgIH0pLCBkYXRhSW5kZXgsIHRydWUpKSB8fCBbXTtcbiAgfSBlbHNlIGlmIChlbCkge1xuICAgIC8vIFVzZSBncmFwaGljIGJvdW5kaW5nIHJlY3RcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgcmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgIHBvaW50ID0gW3JlY3QueCArIHJlY3Qud2lkdGggLyAyLCByZWN0LnkgKyByZWN0LmhlaWdodCAvIDJdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb2ludDogcG9pbnQsXG4gICAgZWw6IGVsXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2ZpbmRQb2ludEZyb21TZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9maW5kUG9pbnRGcm9tU2VyaWVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBfbW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIG1ha2VJbm5lciA9IF9tb2RlbC5tYWtlSW5uZXI7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICogICAgICBwYXJhbToge3N0cmluZ30gY3VyclRyaWdnZXJcbiAqICAgICAgcGFyYW06IHtBcnJheS48bnVtYmVyPn0gcG9pbnRcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlcihrZXksIGFwaSwgaGFuZGxlcikge1xuICBpZiAoZW52Lm5vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgaW5uZXIoenIpLnJlY29yZHMgfHwgKGlubmVyKHpyKS5yZWNvcmRzID0ge30pO1xuICBpbml0R2xvYmFsTGlzdGVuZXJzKHpyLCBhcGkpO1xuICB2YXIgcmVjb3JkID0gaW5uZXIoenIpLnJlY29yZHNba2V5XSB8fCAoaW5uZXIoenIpLnJlY29yZHNba2V5XSA9IHt9KTtcbiAgcmVjb3JkLmhhbmRsZXIgPSBoYW5kbGVyO1xufVxuXG5mdW5jdGlvbiBpbml0R2xvYmFsTGlzdGVuZXJzKHpyLCBhcGkpIHtcbiAgaWYgKGlubmVyKHpyKS5pbml0aWFsaXplZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlubmVyKHpyKS5pbml0aWFsaXplZCA9IHRydWU7XG4gIHVzZUhhbmRsZXIoJ2NsaWNrJywgenJVdGlsLmN1cnJ5KGRvRW50ZXIsICdjbGljaycpKTtcbiAgdXNlSGFuZGxlcignbW91c2Vtb3ZlJywgenJVdGlsLmN1cnJ5KGRvRW50ZXIsICdtb3VzZW1vdmUnKSk7IC8vIHVzZUhhbmRsZXIoJ21vdXNlb3V0Jywgb25MZWF2ZSk7XG5cbiAgdXNlSGFuZGxlcignZ2xvYmFsb3V0Jywgb25MZWF2ZSk7XG5cbiAgZnVuY3Rpb24gdXNlSGFuZGxlcihldmVudFR5cGUsIGNiKSB7XG4gICAgenIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGRpcyA9IG1ha2VEaXNwYXRjaEFjdGlvbihhcGkpO1xuICAgICAgZWFjaChpbm5lcih6cikucmVjb3JkcywgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICByZWNvcmQgJiYgY2IocmVjb3JkLCBlLCBkaXMuZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICBkaXNwYXRjaFRvb2x0aXBGaW5hbGx5KGRpcy5wZW5kaW5ncywgYXBpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFRvb2x0aXBGaW5hbGx5KHBlbmRpbmdzLCBhcGkpIHtcbiAgdmFyIHNob3dMZW4gPSBwZW5kaW5ncy5zaG93VGlwLmxlbmd0aDtcbiAgdmFyIGhpZGVMZW4gPSBwZW5kaW5ncy5oaWRlVGlwLmxlbmd0aDtcbiAgdmFyIGFjdHVhbGx5UGF5bG9hZDtcblxuICBpZiAoc2hvd0xlbikge1xuICAgIGFjdHVhbGx5UGF5bG9hZCA9IHBlbmRpbmdzLnNob3dUaXBbc2hvd0xlbiAtIDFdO1xuICB9IGVsc2UgaWYgKGhpZGVMZW4pIHtcbiAgICBhY3R1YWxseVBheWxvYWQgPSBwZW5kaW5ncy5oaWRlVGlwW2hpZGVMZW4gLSAxXTtcbiAgfVxuXG4gIGlmIChhY3R1YWxseVBheWxvYWQpIHtcbiAgICBhY3R1YWxseVBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gPSBudWxsO1xuICAgIGFwaS5kaXNwYXRjaEFjdGlvbihhY3R1YWxseVBheWxvYWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uTGVhdmUocmVjb3JkLCBlLCBkaXNwYXRjaEFjdGlvbikge1xuICByZWNvcmQuaGFuZGxlcignbGVhdmUnLCBudWxsLCBkaXNwYXRjaEFjdGlvbik7XG59XG5cbmZ1bmN0aW9uIGRvRW50ZXIoY3VyclRyaWdnZXIsIHJlY29yZCwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgcmVjb3JkLmhhbmRsZXIoY3VyclRyaWdnZXIsIGUsIGRpc3BhdGNoQWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gbWFrZURpc3BhdGNoQWN0aW9uKGFwaSkge1xuICB2YXIgcGVuZGluZ3MgPSB7XG4gICAgc2hvd1RpcDogW10sXG4gICAgaGlkZVRpcDogW11cbiAgfTsgLy8gRklYTUVcbiAgLy8gYmV0dGVyIGFwcHJvYWNoP1xuICAvLyAnc2hvd1RpcCcgYW5kICdoaWRlVGlwJyBjYW4gYmUgdHJpZ2dlcmVkIGJ5IGF4aXNQb2ludGVyIGFuZCB0b29sdGlwLFxuICAvLyB3aGljaCBtYXkgYmUgY29uZmxpY3QsIChheGlzUG9pbnRlciBjYWxsIHNob3dUaXAgYnV0IHRvb2x0aXAgY2FsbCBoaWRlVGlwKTtcbiAgLy8gU28gd2UgaGF2ZSB0byBhZGQgXCJmaW5hbCBzdGFnZVwiIHRvIG1lcmdlIHRob3NlIGRpc3BhdGNoZWQgYWN0aW9ucy5cblxuICB2YXIgZGlzcGF0Y2hBY3Rpb24gPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIHZhciBwZW5kaW5nTGlzdCA9IHBlbmRpbmdzW3BheWxvYWQudHlwZV07XG5cbiAgICBpZiAocGVuZGluZ0xpc3QpIHtcbiAgICAgIHBlbmRpbmdMaXN0LnB1c2gocGF5bG9hZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gPSBkaXNwYXRjaEFjdGlvbjtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbihwYXlsb2FkKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBkaXNwYXRjaEFjdGlvbjogZGlzcGF0Y2hBY3Rpb24sXG4gICAgcGVuZGluZ3M6IHBlbmRpbmdzXG4gIH07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqL1xuXG5cbmZ1bmN0aW9uIHVucmVnaXN0ZXIoa2V5LCBhcGkpIHtcbiAgaWYgKGVudi5ub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gIHZhciByZWNvcmQgPSAoaW5uZXIoenIpLnJlY29yZHMgfHwge30pW2tleV07XG5cbiAgaWYgKHJlY29yZCkge1xuICAgIGlubmVyKHpyKS5yZWNvcmRzW2tleV0gPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMucmVnaXN0ZXIgPSByZWdpc3RlcjtcbmV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL01vZGVsXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5OyAvLyBCdWlsZCBheGlzUG9pbnRlck1vZGVsLCBtZXJnaW4gdG9vbHRpcC5heGlzUG9pbnRlciBtb2RlbCBmb3IgZWFjaCBheGlzLlxuLy8gYWxsQXhlc0luZm8gc2hvdWxkIGJlIHVwZGF0ZWQgd2hlbiBzZXRPcHRpb24gcGVyZm9ybWVkLlxuXG5mdW5jdGlvbiBjb2xsZWN0KGVjTW9kZWwsIGFwaSkge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIGtleTogbWFrZUtleShheGlzLm1vZGVsKVxuICAgICAqIHZhbHVlOiB7XG4gICAgICogICAgICBheGlzLFxuICAgICAqICAgICAgY29vcmRTeXMsXG4gICAgICogICAgICBheGlzUG9pbnRlck1vZGVsLFxuICAgICAqICAgICAgdHJpZ2dlclRvb2x0aXAsXG4gICAgICogICAgICBpbnZvbHZlU2VyaWVzLFxuICAgICAqICAgICAgc25hcCxcbiAgICAgKiAgICAgIHNlcmllc01vZGVscyxcbiAgICAgKiAgICAgIHNlcmllc0RhdGFDb3VudFxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGVzSW5mbzoge30sXG4gICAgc2VyaWVzSW52b2x2ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICoga2V5OiBtYWtlS2V5KGNvb3JkU3lzLm1vZGVsKVxuICAgICAqIHZhbHVlOiBPYmplY3Q6IGtleSBtYWtlS2V5KGF4aXMubW9kZWwpLCB2YWx1ZTogYXhpc0luZm9cbiAgICAgKi9cbiAgICBjb29yZFN5c0F4ZXNJbmZvOiB7fSxcbiAgICBjb29yZFN5c01hcDoge31cbiAgfTtcbiAgY29sbGVjdEF4ZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCwgYXBpKTsgLy8gQ2hlY2sgc2VyaWVzSW52b2x2ZWQgZm9yIHBlcmZvcm1hbmNlLCBpbiBjYXNlIHRvbyBtYW55IHNlcmllcyBpbiBzb21lIGNoYXJ0LlxuXG4gIHJlc3VsdC5zZXJpZXNJbnZvbHZlZCAmJiBjb2xsZWN0U2VyaWVzSW5mbyhyZXN1bHQsIGVjTW9kZWwpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0QXhlc0luZm8ocmVzdWx0LCBlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGdsb2JhbFRvb2x0aXBNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sdGlwJyk7XG4gIHZhciBnbG9iYWxBeGlzUG9pbnRlck1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ2F4aXNQb2ludGVyJyk7IC8vIGxpbmtzIGNhbiBvbmx5IGJlIHNldCBvbiBnbG9iYWwuXG5cbiAgdmFyIGxpbmtzT3B0aW9uID0gZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xpbmsnLCB0cnVlKSB8fCBbXTtcbiAgdmFyIGxpbmtHcm91cHMgPSBbXTsgLy8gQ29sbGVjdCBheGVzIGluZm8uXG5cbiAgZWFjaChhcGkuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKSwgZnVuY3Rpb24gKGNvb3JkU3lzKSB7XG4gICAgLy8gU29tZSBjb29yZGluYXRlIHN5c3RlbSBkbyBub3Qgc3VwcG9ydCBheGVzLCBsaWtlIGdlby5cbiAgICBpZiAoIWNvb3JkU3lzLmF4aXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb29yZFN5c0tleSA9IG1ha2VLZXkoY29vcmRTeXMubW9kZWwpO1xuICAgIHZhciBheGVzSW5mb0luQ29vcmRTeXMgPSByZXN1bHQuY29vcmRTeXNBeGVzSW5mb1tjb29yZFN5c0tleV0gPSB7fTtcbiAgICByZXN1bHQuY29vcmRTeXNNYXBbY29vcmRTeXNLZXldID0gY29vcmRTeXM7IC8vIFNldCB0b29sdGlwIChsaWtlICdjcm9zcycpIGlzIGEgY29udmllbmVudCB3YXkgdG8gc2hvdyBheGlzUG9pbnRlclxuICAgIC8vIGZvciB1c2VyLiBTbyB3ZSBlbmFibGUgc2V0aW5nIHRvb2x0aXAgb24gY29vcmRTeXMgbW9kZWwuXG5cbiAgICB2YXIgY29vcmRTeXNNb2RlbCA9IGNvb3JkU3lzLm1vZGVsO1xuICAgIHZhciBiYXNlVG9vbHRpcE1vZGVsID0gY29vcmRTeXNNb2RlbC5nZXRNb2RlbCgndG9vbHRpcCcsIGdsb2JhbFRvb2x0aXBNb2RlbCk7XG4gICAgZWFjaChjb29yZFN5cy5nZXRBeGVzKCksIGN1cnJ5KHNhdmVUb29sdGlwQXhpc0luZm8sIGZhbHNlLCBudWxsKSk7IC8vIElmIGF4aXMgdG9vbHRpcCB1c2VkLCBjaG9vc2UgdG9vbHRpcCBheGlzIGZvciBlYWNoIGNvb3JkU3lzLlxuICAgIC8vIE5vdGljZSB0aGlzIGNhc2U6IGNvb3JkU3lzIGlzIGBncmlkYCBidXQgbm90IGBjYXJ0ZXNpYW4yRGAgaGVyZS5cblxuICAgIGlmIChjb29yZFN5cy5nZXRUb29sdGlwQXhlcyAmJiBnbG9iYWxUb29sdGlwTW9kZWwgLy8gSWYgdG9vbHRpcC5zaG93Q29udGVudCBpcyBzZXQgYXMgZmFsc2UsIHRvb2x0aXAgd2lsbCBub3RcbiAgICAvLyBzaG93IGJ1dCBheGlzUG9pbnRlciB3aWxsIHNob3cgYXMgbm9ybWFsLlxuICAgICYmIGJhc2VUb29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBsb2dpYy4gQnV0IHNlcmllcy50b29sdGlwLnRyaWdnZXI6ICdheGlzJ1xuICAgICAgLy8gb3Igc2VyaWVzLmRhdGFbbl0udG9vbHRpcC50cmlnZ2VyOiAnYXhpcycgYXJlIG5vdCBzdXBwb3J0IGFueSBtb3JlLlxuICAgICAgdmFyIHRyaWdnZXJBeGlzID0gYmFzZVRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKSA9PT0gJ2F4aXMnO1xuICAgICAgdmFyIGNyb3NzID0gYmFzZVRvb2x0aXBNb2RlbC5nZXQoJ2F4aXNQb2ludGVyLnR5cGUnKSA9PT0gJ2Nyb3NzJztcbiAgICAgIHZhciB0b29sdGlwQXhlcyA9IGNvb3JkU3lzLmdldFRvb2x0aXBBeGVzKGJhc2VUb29sdGlwTW9kZWwuZ2V0KCdheGlzUG9pbnRlci5heGlzJykpO1xuXG4gICAgICBpZiAodHJpZ2dlckF4aXMgfHwgY3Jvc3MpIHtcbiAgICAgICAgZWFjaCh0b29sdGlwQXhlcy5iYXNlQXhlcywgY3Vycnkoc2F2ZVRvb2x0aXBBeGlzSW5mbywgY3Jvc3MgPyAnY3Jvc3MnIDogdHJ1ZSwgdHJpZ2dlckF4aXMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNyb3NzKSB7XG4gICAgICAgIGVhY2godG9vbHRpcEF4ZXMub3RoZXJBeGVzLCBjdXJyeShzYXZlVG9vbHRpcEF4aXNJbmZvLCAnY3Jvc3MnLCBmYWxzZSkpO1xuICAgICAgfVxuICAgIH0gLy8gZnJvbVRvb2x0aXA6IHRydWUgfCBmYWxzZSB8ICdjcm9zcydcbiAgICAvLyB0cmlnZ2VyVG9vbHRpcDogdHJ1ZSB8IGZhbHNlIHwgbnVsbFxuXG5cbiAgICBmdW5jdGlvbiBzYXZlVG9vbHRpcEF4aXNJbmZvKGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcCwgYXhpcykge1xuICAgICAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzLm1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicsIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgdmFyIGF4aXNQb2ludGVyU2hvdyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzaG93Jyk7XG5cbiAgICAgIGlmICghYXhpc1BvaW50ZXJTaG93IHx8IGF4aXNQb2ludGVyU2hvdyA9PT0gJ2F1dG8nICYmICFmcm9tVG9vbHRpcCAmJiAhaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyaWdnZXJUb29sdGlwID09IG51bGwpIHtcbiAgICAgICAgdHJpZ2dlclRvb2x0aXAgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndHJpZ2dlclRvb2x0aXAnKTtcbiAgICAgIH1cblxuICAgICAgYXhpc1BvaW50ZXJNb2RlbCA9IGZyb21Ub29sdGlwID8gbWFrZUF4aXNQb2ludGVyTW9kZWwoYXhpcywgYmFzZVRvb2x0aXBNb2RlbCwgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCwgZnJvbVRvb2x0aXAsIHRyaWdnZXJUb29sdGlwKSA6IGF4aXNQb2ludGVyTW9kZWw7XG4gICAgICB2YXIgc25hcCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzbmFwJyk7XG4gICAgICB2YXIga2V5ID0gbWFrZUtleShheGlzLm1vZGVsKTtcbiAgICAgIHZhciBpbnZvbHZlU2VyaWVzID0gdHJpZ2dlclRvb2x0aXAgfHwgc25hcCB8fCBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7IC8vIElmIHJlc3VsdC5heGVzSW5mb1trZXldIGV4aXN0LCBvdmVycmlkZSBpdCAodG9vbHRpcCBoYXMgaGlnaGVyIHByaW9yaXR5KS5cblxuICAgICAgdmFyIGF4aXNJbmZvID0gcmVzdWx0LmF4ZXNJbmZvW2tleV0gPSB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBheGlzOiBheGlzLFxuICAgICAgICBjb29yZFN5czogY29vcmRTeXMsXG4gICAgICAgIGF4aXNQb2ludGVyTW9kZWw6IGF4aXNQb2ludGVyTW9kZWwsXG4gICAgICAgIHRyaWdnZXJUb29sdGlwOiB0cmlnZ2VyVG9vbHRpcCxcbiAgICAgICAgaW52b2x2ZVNlcmllczogaW52b2x2ZVNlcmllcyxcbiAgICAgICAgc25hcDogc25hcCxcbiAgICAgICAgdXNlSGFuZGxlOiBpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbCksXG4gICAgICAgIHNlcmllc01vZGVsczogW11cbiAgICAgIH07XG4gICAgICBheGVzSW5mb0luQ29vcmRTeXNba2V5XSA9IGF4aXNJbmZvO1xuICAgICAgcmVzdWx0LnNlcmllc0ludm9sdmVkIHw9IGludm9sdmVTZXJpZXM7XG4gICAgICB2YXIgZ3JvdXBJbmRleCA9IGdldExpbmtHcm91cEluZGV4KGxpbmtzT3B0aW9uLCBheGlzKTtcblxuICAgICAgaWYgKGdyb3VwSW5kZXggIT0gbnVsbCkge1xuICAgICAgICB2YXIgbGlua0dyb3VwID0gbGlua0dyb3Vwc1tncm91cEluZGV4XSB8fCAobGlua0dyb3Vwc1tncm91cEluZGV4XSA9IHtcbiAgICAgICAgICBheGVzSW5mbzoge31cbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmtHcm91cC5heGVzSW5mb1trZXldID0gYXhpc0luZm87XG4gICAgICAgIGxpbmtHcm91cC5tYXBwZXIgPSBsaW5rc09wdGlvbltncm91cEluZGV4XS5tYXBwZXI7XG4gICAgICAgIGF4aXNJbmZvLmxpbmtHcm91cCA9IGxpbmtHcm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQXhpc1BvaW50ZXJNb2RlbChheGlzLCBiYXNlVG9vbHRpcE1vZGVsLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsLCBlY01vZGVsLCBmcm9tVG9vbHRpcCwgdHJpZ2dlclRvb2x0aXApIHtcbiAgdmFyIHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsID0gYmFzZVRvb2x0aXBNb2RlbC5nZXRNb2RlbCgnYXhpc1BvaW50ZXInKTtcbiAgdmFyIHZvbGF0aWxlT3B0aW9uID0ge307XG4gIGVhY2goWyd0eXBlJywgJ3NuYXAnLCAnbGluZVN0eWxlJywgJ3NoYWRvd1N0eWxlJywgJ2xhYmVsJywgJ2FuaW1hdGlvbicsICdhbmltYXRpb25EdXJhdGlvblVwZGF0ZScsICdhbmltYXRpb25FYXNpbmdVcGRhdGUnLCAneiddLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2b2xhdGlsZU9wdGlvbltmaWVsZF0gPSB6clV0aWwuY2xvbmUodG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KGZpZWxkKSk7XG4gIH0pOyAvLyBjYXRlZ29yeSBheGlzIGRvIG5vdCBhdXRvIHNuYXAsIG90aGVyd2lzZSBzb21lIHRpY2sgdGhhdCBkbyBub3RcbiAgLy8gaGFzIHZhbHVlIGNhbiBub3QgYmUgaG92ZXJlZC4gdmFsdWUvdGltZS9sb2cgYXhpcyBkZWZhdWx0IHNuYXAgaWZcbiAgLy8gdHJpZ2dlcmVkIGZyb20gdG9vbHRpcCBhbmQgdHJpZ2dlciB0b29sdGlwLlxuXG4gIHZvbGF0aWxlT3B0aW9uLnNuYXAgPSBheGlzLnR5cGUgIT09ICdjYXRlZ29yeScgJiYgISF0cmlnZ2VyVG9vbHRpcDsgLy8gQ29tcGF0aWJlbCB3aXRoIHByZXZpb3VzIGJlaGF2aW9yLCB0b29sdGlwIGF4aXMgZG8gbm90IHNob3cgbGFiZWwgYnkgZGVmYXVsdC5cbiAgLy8gT25seSB0aGVzZSBwcm9wZXJ0aWVzIGNhbiBiZSBvdmVycmlkZWQgZnJvbSB0b29sdGlwIHRvIGF4aXNQb2ludGVyLlxuXG4gIGlmICh0b29sdGlwQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2Nyb3NzJykge1xuICAgIHZvbGF0aWxlT3B0aW9uLnR5cGUgPSAnbGluZSc7XG4gIH1cblxuICB2YXIgbGFiZWxPcHRpb24gPSB2b2xhdGlsZU9wdGlvbi5sYWJlbCB8fCAodm9sYXRpbGVPcHRpb24ubGFiZWwgPSB7fSk7IC8vIEZvbGxvdyB0aGUgY29udmVudGlvbiwgZG8gbm90IHNob3cgbGFiZWwgd2hlbiB0cmlnZ2VyZWQgYnkgdG9vbHRpcCBieSBkZWZhdWx0LlxuXG4gIGxhYmVsT3B0aW9uLnNob3cgPT0gbnVsbCAmJiAobGFiZWxPcHRpb24uc2hvdyA9IGZhbHNlKTtcblxuICBpZiAoZnJvbVRvb2x0aXAgPT09ICdjcm9zcycpIHtcbiAgICAvLyBXaGVuICdjcm9zcycsIGJvdGggYXhlcyBzaG93IGxhYmVscy5cbiAgICB2YXIgdG9vbHRpcEF4aXNQb2ludGVyTGFiZWxTaG93ID0gdG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5zaG93Jyk7XG4gICAgbGFiZWxPcHRpb24uc2hvdyA9IHRvb2x0aXBBeGlzUG9pbnRlckxhYmVsU2hvdyAhPSBudWxsID8gdG9vbHRpcEF4aXNQb2ludGVyTGFiZWxTaG93IDogdHJ1ZTsgLy8gSWYgdHJpZ2dlclRvb2x0aXAsIHRoaXMgaXMgYSBiYXNlIGF4aXMsIHdoaWNoIHNob3VsZCBiZXR0ZXIgbm90IHVzZSBjcm9zcyBzdHlsZVxuICAgIC8vIChjcm9zcyBzdHlsZSBpcyBkYXNoZWQgYnkgZGVmYXVsdClcblxuICAgIGlmICghdHJpZ2dlclRvb2x0aXApIHtcbiAgICAgIHZhciBjcm9zc1N0eWxlID0gdm9sYXRpbGVPcHRpb24ubGluZVN0eWxlID0gdG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCdjcm9zc1N0eWxlJyk7XG4gICAgICBjcm9zc1N0eWxlICYmIHpyVXRpbC5kZWZhdWx0cyhsYWJlbE9wdGlvbiwgY3Jvc3NTdHlsZS50ZXh0U3R5bGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBheGlzLm1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicsIG5ldyBNb2RlbCh2b2xhdGlsZU9wdGlvbiwgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCkpO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0U2VyaWVzSW5mbyhyZXN1bHQsIGVjTW9kZWwpIHtcbiAgLy8gUHJlcGFyZSBkYXRhIGZvciBheGlzIHRyaWdnZXJcbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIC8vIE5vdGljZSB0aGlzIGNhc2U6IHRoaXMgY29vcmRTeXMgaXMgYGNhcnRlc2lhbjJEYCBidXQgbm90IGBncmlkYC5cbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBzZXJpZXNUb29sdGlwVHJpZ2dlciA9IHNlcmllc01vZGVsLmdldCgndG9vbHRpcC50cmlnZ2VyJywgdHJ1ZSk7XG4gICAgdmFyIHNlcmllc1Rvb2x0aXBTaG93ID0gc2VyaWVzTW9kZWwuZ2V0KCd0b29sdGlwLnNob3cnLCB0cnVlKTtcblxuICAgIGlmICghY29vcmRTeXMgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09ICdub25lJyB8fCBzZXJpZXNUb29sdGlwVHJpZ2dlciA9PT0gZmFsc2UgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09ICdpdGVtJyB8fCBzZXJpZXNUb29sdGlwU2hvdyA9PT0gZmFsc2UgfHwgc2VyaWVzTW9kZWwuZ2V0KCdheGlzUG9pbnRlci5zaG93JywgdHJ1ZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaChyZXN1bHQuY29vcmRTeXNBeGVzSW5mb1ttYWtlS2V5KGNvb3JkU3lzLm1vZGVsKV0sIGZ1bmN0aW9uIChheGlzSW5mbykge1xuICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuXG4gICAgICBpZiAoY29vcmRTeXMuZ2V0QXhpcyhheGlzLmRpbSkgPT09IGF4aXMpIHtcbiAgICAgICAgYXhpc0luZm8uc2VyaWVzTW9kZWxzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgICBheGlzSW5mby5zZXJpZXNEYXRhQ291bnQgPT0gbnVsbCAmJiAoYXhpc0luZm8uc2VyaWVzRGF0YUNvdW50ID0gMCk7XG4gICAgICAgIGF4aXNJbmZvLnNlcmllc0RhdGFDb3VudCArPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY291bnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgdGhpcyk7XG59XG4vKipcbiAqIEZvciBleGFtcGxlOlxuICoge1xuICogICAgIGF4aXNQb2ludGVyOiB7XG4gKiAgICAgICAgIGxpbmtzOiBbe1xuICogICAgICAgICAgICAgeEF4aXNJbmRleDogWzIsIDRdLFxuICogICAgICAgICAgICAgeUF4aXNJbmRleDogJ2FsbCdcbiAqICAgICAgICAgfSwge1xuICogICAgICAgICAgICAgeEF4aXNJZDogWydhNScsICdhNyddLFxuICogICAgICAgICAgICAgeEF4aXNOYW1lOiAneHh4J1xuICogICAgICAgICB9XVxuICogICAgIH1cbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpbmtHcm91cEluZGV4KGxpbmtzT3B0aW9uLCBheGlzKSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzLm1vZGVsO1xuICB2YXIgZGltID0gYXhpcy5kaW07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rc09wdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5rT3B0aW9uID0gbGlua3NPcHRpb25baV0gfHwge307XG5cbiAgICBpZiAoY2hlY2tQcm9wSW5MaW5rKGxpbmtPcHRpb25bZGltICsgJ0F4aXNJZCddLCBheGlzTW9kZWwuaWQpIHx8IGNoZWNrUHJvcEluTGluayhsaW5rT3B0aW9uW2RpbSArICdBeGlzSW5kZXgnXSwgYXhpc01vZGVsLmNvbXBvbmVudEluZGV4KSB8fCBjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc05hbWUnXSwgYXhpc01vZGVsLm5hbWUpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wSW5MaW5rKGxpbmtQcm9wVmFsdWUsIGF4aXNQcm9wVmFsdWUpIHtcbiAgcmV0dXJuIGxpbmtQcm9wVmFsdWUgPT09ICdhbGwnIHx8IHpyVXRpbC5pc0FycmF5KGxpbmtQcm9wVmFsdWUpICYmIHpyVXRpbC5pbmRleE9mKGxpbmtQcm9wVmFsdWUsIGF4aXNQcm9wVmFsdWUpID49IDAgfHwgbGlua1Byb3BWYWx1ZSA9PT0gYXhpc1Byb3BWYWx1ZTtcbn1cblxuZnVuY3Rpb24gZml4VmFsdWUoYXhpc01vZGVsKSB7XG4gIHZhciBheGlzSW5mbyA9IGdldEF4aXNJbmZvKGF4aXNNb2RlbCk7XG5cbiAgaWYgKCFheGlzSW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbDtcbiAgdmFyIHNjYWxlID0gYXhpc0luZm8uYXhpcy5zY2FsZTtcbiAgdmFyIG9wdGlvbiA9IGF4aXNQb2ludGVyTW9kZWwub3B0aW9uO1xuICB2YXIgc3RhdHVzID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3N0YXR1cycpO1xuICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTsgLy8gUGFyc2UgaW5pdCB2YWx1ZSBmb3IgY2F0ZWdvcnkgYW5kIHRpbWUgYXhpcy5cblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHZhbHVlID0gc2NhbGUucGFyc2UodmFsdWUpO1xuICB9XG5cbiAgdmFyIHVzZUhhbmRsZSA9IGlzSGFuZGxlVHJpZ2dlcihheGlzUG9pbnRlck1vZGVsKTsgLy8gSWYgYGhhbmRsZWAgdXNlZCwgYGF4aXNQb2ludGVyYCB3aWxsIGFsd2F5cyBiZSBkaXNwbGF5ZWQsIHNvIHZhbHVlXG4gIC8vIGFuZCBzdGF0dXMgc2hvdWxkIGJlIGluaXRpYWxpemVkLlxuXG4gIGlmIChzdGF0dXMgPT0gbnVsbCkge1xuICAgIG9wdGlvbi5zdGF0dXMgPSB1c2VIYW5kbGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gIH1cblxuICB2YXIgZXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCkuc2xpY2UoKTtcbiAgZXh0ZW50WzBdID4gZXh0ZW50WzFdICYmIGV4dGVudC5yZXZlcnNlKCk7XG5cbiAgaWYgKCAvLyBQaWNrIGEgdmFsdWUgb24gYXhpcyB3aGVuIGluaXRpYWxpemluZy5cbiAgdmFsdWUgPT0gbnVsbCAvLyBJZiBib3RoIGBoYW5kbGVgIGFuZCBgZGF0YVpvb21gIGFyZSB1c2VkLCB2YWx1ZSBtYXkgYmUgb3V0IG9mIGF4aXMgZXh0ZW50LFxuICAvLyB3aGVyZSB3ZSBzaG91bGQgcmUtcGljayBhIHZhbHVlIHRvIGtlZXAgYGhhbmRsZWAgZGlzcGxheWluZyBub3JtYWxseS5cbiAgfHwgdmFsdWUgPiBleHRlbnRbMV0pIHtcbiAgICAvLyBNYWtlIGhhbmRsZSBkaXNwbGF5ZWQgb24gdGhlIGVuZCBvZiB0aGUgYXhpcyB3aGVuIGluaXQsIHdoaWNoIGxvb2tzIGJldHRlci5cbiAgICB2YWx1ZSA9IGV4dGVudFsxXTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA8IGV4dGVudFswXSkge1xuICAgIHZhbHVlID0gZXh0ZW50WzBdO1xuICB9XG5cbiAgb3B0aW9uLnZhbHVlID0gdmFsdWU7XG5cbiAgaWYgKHVzZUhhbmRsZSkge1xuICAgIG9wdGlvbi5zdGF0dXMgPSBheGlzSW5mby5heGlzLnNjYWxlLmlzQmxhbmsoKSA/ICdoaWRlJyA6ICdzaG93JztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBeGlzSW5mbyhheGlzTW9kZWwpIHtcbiAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSAoYXhpc01vZGVsLmVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpIHx8IHt9KS5jb29yZFN5c0F4ZXNJbmZvO1xuICByZXR1cm4gY29vcmRTeXNBeGVzSW5mbyAmJiBjb29yZFN5c0F4ZXNJbmZvLmF4ZXNJbmZvW21ha2VLZXkoYXhpc01vZGVsKV07XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNQb2ludGVyTW9kZWwoYXhpc01vZGVsKSB7XG4gIHZhciBheGlzSW5mbyA9IGdldEF4aXNJbmZvKGF4aXNNb2RlbCk7XG4gIHJldHVybiBheGlzSW5mbyAmJiBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsO1xufVxuXG5mdW5jdGlvbiBpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbCkge1xuICByZXR1cm4gISFheGlzUG9pbnRlck1vZGVsLmdldCgnaGFuZGxlLnNob3cnKTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcbiAqIEByZXR1cm4ge3N0cmluZ30gdW5pcXVlIGtleVxuICovXG5cblxuZnVuY3Rpb24gbWFrZUtleShtb2RlbCkge1xuICByZXR1cm4gbW9kZWwudHlwZSArICd8fCcgKyBtb2RlbC5pZDtcbn1cblxuZXhwb3J0cy5jb2xsZWN0ID0gY29sbGVjdDtcbmV4cG9ydHMuZml4VmFsdWUgPSBmaXhWYWx1ZTtcbmV4cG9ydHMuZ2V0QXhpc0luZm8gPSBnZXRBeGlzSW5mbztcbmV4cG9ydHMuZ2V0QXhpc1BvaW50ZXJNb2RlbCA9IGdldEF4aXNQb2ludGVyTW9kZWw7XG5leHBvcnRzLm1ha2VLZXkgPSBtYWtlS2V5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9tb2RlbEhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL21vZGVsSGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBtYXRyaXggPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9tYXRyaXhcIik7XG5cbnZhciBheGlzSGVscGVyID0gcmVxdWlyZShcIi4uLy4uL2Nvb3JkL2F4aXNIZWxwZXJcIik7XG5cbnZhciBBeGlzQnVpbGRlciA9IHJlcXVpcmUoXCIuLi9heGlzL0F4aXNCdWlsZGVyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc1BvaW50ZXJNb2RlbFxuICovXG5mdW5jdGlvbiBidWlsZEVsU3R5bGUoYXhpc1BvaW50ZXJNb2RlbCkge1xuICB2YXIgYXhpc1BvaW50ZXJUeXBlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgdmFyIHN0eWxlTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldE1vZGVsKGF4aXNQb2ludGVyVHlwZSArICdTdHlsZScpO1xuICB2YXIgc3R5bGU7XG5cbiAgaWYgKGF4aXNQb2ludGVyVHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgc3R5bGUgPSBzdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpO1xuICAgIHN0eWxlLmZpbGwgPSBudWxsO1xuICB9IGVsc2UgaWYgKGF4aXNQb2ludGVyVHlwZSA9PT0gJ3NoYWRvdycpIHtcbiAgICBzdHlsZSA9IHN0eWxlTW9kZWwuZ2V0QXJlYVN0eWxlKCk7XG4gICAgc3R5bGUuc3Ryb2tlID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGFiZWxQb3Mge2FsaWduLCB2ZXJ0aWNhbEFsaWduLCBwb3NpdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ1aWxkTGFiZWxFbE9wdGlvbihlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIGxhYmVsUG9zKSB7XG4gIHZhciB2YWx1ZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd2YWx1ZScpO1xuICB2YXIgdGV4dCA9IGdldFZhbHVlTGFiZWwodmFsdWUsIGF4aXNNb2RlbC5heGlzLCBheGlzTW9kZWwuZWNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3Nlcmllc0RhdGFJbmRpY2VzJyksIHtcbiAgICBwcmVjaXNpb246IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5wcmVjaXNpb24nKSxcbiAgICBmb3JtYXR0ZXI6IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5mb3JtYXR0ZXInKVxuICB9KTtcbiAgdmFyIGxhYmVsTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldE1vZGVsKCdsYWJlbCcpO1xuICB2YXIgcGFkZGluZ3MgPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KGxhYmVsTW9kZWwuZ2V0KCdwYWRkaW5nJykgfHwgMCk7XG4gIHZhciBmb250ID0gbGFiZWxNb2RlbC5nZXRGb250KCk7XG4gIHZhciB0ZXh0UmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0ZXh0LCBmb250KTtcbiAgdmFyIHBvc2l0aW9uID0gbGFiZWxQb3MucG9zaXRpb247XG4gIHZhciB3aWR0aCA9IHRleHRSZWN0LndpZHRoICsgcGFkZGluZ3NbMV0gKyBwYWRkaW5nc1szXTtcbiAgdmFyIGhlaWdodCA9IHRleHRSZWN0LmhlaWdodCArIHBhZGRpbmdzWzBdICsgcGFkZGluZ3NbMl07IC8vIEFkanVzdCBieSBhbGlnbi5cblxuICB2YXIgYWxpZ24gPSBsYWJlbFBvcy5hbGlnbjtcbiAgYWxpZ24gPT09ICdyaWdodCcgJiYgKHBvc2l0aW9uWzBdIC09IHdpZHRoKTtcbiAgYWxpZ24gPT09ICdjZW50ZXInICYmIChwb3NpdGlvblswXSAtPSB3aWR0aCAvIDIpO1xuICB2YXIgdmVydGljYWxBbGlnbiA9IGxhYmVsUG9zLnZlcnRpY2FsQWxpZ247XG4gIHZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nICYmIChwb3NpdGlvblsxXSAtPSBoZWlnaHQpO1xuICB2ZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJyAmJiAocG9zaXRpb25bMV0gLT0gaGVpZ2h0IC8gMik7IC8vIE5vdCBvdmVyZmxvdyBlYyBjb250YWluZXJcblxuICBjb25maW5lSW5Db250YWluZXIocG9zaXRpb24sIHdpZHRoLCBoZWlnaHQsIGFwaSk7XG4gIHZhciBiZ0NvbG9yID0gbGFiZWxNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuXG4gIGlmICghYmdDb2xvciB8fCBiZ0NvbG9yID09PSAnYXV0bycpIHtcbiAgICBiZ0NvbG9yID0gYXhpc01vZGVsLmdldCgnYXhpc0xpbmUubGluZVN0eWxlLmNvbG9yJyk7XG4gIH1cblxuICBlbE9wdGlvbi5sYWJlbCA9IHtcbiAgICBzaGFwZToge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHI6IGxhYmVsTW9kZWwuZ2V0KCdib3JkZXJSYWRpdXMnKVxuICAgIH0sXG4gICAgcG9zaXRpb246IHBvc2l0aW9uLnNsaWNlKCksXG4gICAgLy8gVE9ETzogcmljaFxuICAgIHN0eWxlOiB7XG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgdGV4dEZvbnQ6IGZvbnQsXG4gICAgICB0ZXh0RmlsbDogbGFiZWxNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG4gICAgICBmaWxsOiBiZ0NvbG9yLFxuICAgICAgc3Ryb2tlOiBsYWJlbE1vZGVsLmdldCgnYm9yZGVyQ29sb3InKSB8fCAndHJhbnNwYXJlbnQnLFxuICAgICAgbGluZVdpZHRoOiBsYWJlbE1vZGVsLmdldCgnYm9yZGVyV2lkdGgnKSB8fCAwLFxuICAgICAgc2hhZG93Qmx1cjogbGFiZWxNb2RlbC5nZXQoJ3NoYWRvd0JsdXInKSxcbiAgICAgIHNoYWRvd0NvbG9yOiBsYWJlbE1vZGVsLmdldCgnc2hhZG93Q29sb3InKSxcbiAgICAgIHNoYWRvd09mZnNldFg6IGxhYmVsTW9kZWwuZ2V0KCdzaGFkb3dPZmZzZXRYJyksXG4gICAgICBzaGFkb3dPZmZzZXRZOiBsYWJlbE1vZGVsLmdldCgnc2hhZG93T2Zmc2V0WScpXG4gICAgfSxcbiAgICAvLyBMYWJsZSBzaG91bGQgYmUgb3ZlciBheGlzUG9pbnRlci5cbiAgICB6MjogMTBcbiAgfTtcbn0gLy8gRG8gbm90IG92ZXJmbG93IGVjIGNvbnRhaW5lclxuXG5cbmZ1bmN0aW9uIGNvbmZpbmVJbkNvbnRhaW5lcihwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCwgYXBpKSB7XG4gIHZhciB2aWV3V2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgdmFyIHZpZXdIZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gIHBvc2l0aW9uWzBdID0gTWF0aC5taW4ocG9zaXRpb25bMF0gKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xuICBwb3NpdGlvblsxXSA9IE1hdGgubWluKHBvc2l0aW9uWzFdICsgaGVpZ2h0LCB2aWV3SGVpZ2h0KSAtIGhlaWdodDtcbiAgcG9zaXRpb25bMF0gPSBNYXRoLm1heChwb3NpdGlvblswXSwgMCk7XG4gIHBvc2l0aW9uWzFdID0gTWF0aC5tYXgocG9zaXRpb25bMV0sIDApO1xufVxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvQXhpc30gYXhpc1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHNlcmllc0RhdGFJbmRpY2VzXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG9wdC5wcmVjaXNpb24gJ2F1dG8nIG9yIGEgbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gb3B0LmZvcm1hdHRlciBsYWJlbCBmb3JtYXR0ZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFZhbHVlTGFiZWwodmFsdWUsIGF4aXMsIGVjTW9kZWwsIHNlcmllc0RhdGFJbmRpY2VzLCBvcHQpIHtcbiAgdmFsdWUgPSBheGlzLnNjYWxlLnBhcnNlKHZhbHVlKTtcbiAgdmFyIHRleHQgPSBheGlzLnNjYWxlLmdldExhYmVsKCAvLyBJZiBgcHJlY2lzaW9uYCBpcyBzZXQsIHdpZHRoIGNhbiBiZSBmaXhlZCAobGlrZSAnMTIuMDA1MDAnKSwgd2hpY2hcbiAgLy8gaGVscHMgdG8gZGVib3VuY2Ugd2hlbiB3aGVuIG1vdmluZyBsYWJlbC5cbiAgdmFsdWUsIHtcbiAgICBwcmVjaXNpb246IG9wdC5wcmVjaXNpb25cbiAgfSk7XG4gIHZhciBmb3JtYXR0ZXIgPSBvcHQuZm9ybWF0dGVyO1xuXG4gIGlmIChmb3JtYXR0ZXIpIHtcbiAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgdmFsdWU6IGF4aXNIZWxwZXIuZ2V0QXhpc1Jhd1ZhbHVlKGF4aXMsIHZhbHVlKSxcbiAgICAgIHNlcmllc0RhdGE6IFtdXG4gICAgfTtcbiAgICB6clV0aWwuZWFjaChzZXJpZXNEYXRhSW5kaWNlcywgZnVuY3Rpb24gKGlkeEl0ZW0pIHtcbiAgICAgIHZhciBzZXJpZXMgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoaWR4SXRlbS5zZXJpZXNJbmRleCk7XG4gICAgICB2YXIgZGF0YUluZGV4ID0gaWR4SXRlbS5kYXRhSW5kZXhJbnNpZGU7XG4gICAgICB2YXIgZGF0YVBhcmFtcyA9IHNlcmllcyAmJiBzZXJpZXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgpO1xuICAgICAgZGF0YVBhcmFtcyAmJiBwYXJhbXMuc2VyaWVzRGF0YS5wdXNoKGRhdGFQYXJhbXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKHpyVXRpbC5pc1N0cmluZyhmb3JtYXR0ZXIpKSB7XG4gICAgICB0ZXh0ID0gZm9ybWF0dGVyLnJlcGxhY2UoJ3t2YWx1ZX0nLCB0ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgIHRleHQgPSBmb3JtYXR0ZXIocGFyYW1zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGV4dDtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBheGlzXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXRJbmZvIHtcbiAqICByb3RhdGlvbiwgcG9zaXRpb24sIGxhYmVsT2Zmc2V0LCBsYWJlbERpcmVjdGlvbiwgbGFiZWxNYXJnaW5cbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybWVkUG9zaXRpb24oYXhpcywgdmFsdWUsIGxheW91dEluZm8pIHtcbiAgdmFyIHRyYW5zZm9ybSA9IG1hdHJpeC5jcmVhdGUoKTtcbiAgbWF0cml4LnJvdGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgbGF5b3V0SW5mby5yb3RhdGlvbik7XG4gIG1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIGxheW91dEluZm8ucG9zaXRpb24pO1xuICByZXR1cm4gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybShbYXhpcy5kYXRhVG9Db29yZCh2YWx1ZSksIChsYXlvdXRJbmZvLmxhYmVsT2Zmc2V0IHx8IDApICsgKGxheW91dEluZm8ubGFiZWxEaXJlY3Rpb24gfHwgMSkgKiAobGF5b3V0SW5mby5sYWJlbE1hcmdpbiB8fCAwKV0sIHRyYW5zZm9ybSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ2FydGVzaWFuU2luZ2xlTGFiZWxFbE9wdGlvbih2YWx1ZSwgZWxPcHRpb24sIGxheW91dEluZm8sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKSB7XG4gIHZhciB0ZXh0TGF5b3V0ID0gQXhpc0J1aWxkZXIuaW5uZXJUZXh0TGF5b3V0KGxheW91dEluZm8ucm90YXRpb24sIDAsIGxheW91dEluZm8ubGFiZWxEaXJlY3Rpb24pO1xuICBsYXlvdXRJbmZvLmxhYmVsTWFyZ2luID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLm1hcmdpbicpO1xuICBidWlsZExhYmVsRWxPcHRpb24oZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpLCB7XG4gICAgcG9zaXRpb246IGdldFRyYW5zZm9ybWVkUG9zaXRpb24oYXhpc01vZGVsLmF4aXMsIHZhbHVlLCBsYXlvdXRJbmZvKSxcbiAgICBhbGlnbjogdGV4dExheW91dC50ZXh0QWxpZ24sXG4gICAgdmVydGljYWxBbGlnbjogdGV4dExheW91dC50ZXh0VmVydGljYWxBbGlnblxuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcDFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAyXG4gKiBAcGFyYW0ge251bWJlcn0gW3hEaW1JbmRleD0wXSBvciAxXG4gKi9cblxuXG5mdW5jdGlvbiBtYWtlTGluZVNoYXBlKHAxLCBwMiwgeERpbUluZGV4KSB7XG4gIHhEaW1JbmRleCA9IHhEaW1JbmRleCB8fCAwO1xuICByZXR1cm4ge1xuICAgIHgxOiBwMVt4RGltSW5kZXhdLFxuICAgIHkxOiBwMVsxIC0geERpbUluZGV4XSxcbiAgICB4MjogcDJbeERpbUluZGV4XSxcbiAgICB5MjogcDJbMSAtIHhEaW1JbmRleF1cbiAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0geHlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHdoXG4gKiBAcGFyYW0ge251bWJlcn0gW3hEaW1JbmRleD0wXSBvciAxXG4gKi9cblxuXG5mdW5jdGlvbiBtYWtlUmVjdFNoYXBlKHh5LCB3aCwgeERpbUluZGV4KSB7XG4gIHhEaW1JbmRleCA9IHhEaW1JbmRleCB8fCAwO1xuICByZXR1cm4ge1xuICAgIHg6IHh5W3hEaW1JbmRleF0sXG4gICAgeTogeHlbMSAtIHhEaW1JbmRleF0sXG4gICAgd2lkdGg6IHdoW3hEaW1JbmRleF0sXG4gICAgaGVpZ2h0OiB3aFsxIC0geERpbUluZGV4XVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlU2VjdG9yU2hhcGUoY3gsIGN5LCByMCwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjeDogY3gsXG4gICAgY3k6IGN5LFxuICAgIHIwOiByMCxcbiAgICByOiByLFxuICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9O1xufVxuXG5leHBvcnRzLmJ1aWxkRWxTdHlsZSA9IGJ1aWxkRWxTdHlsZTtcbmV4cG9ydHMuYnVpbGRMYWJlbEVsT3B0aW9uID0gYnVpbGRMYWJlbEVsT3B0aW9uO1xuZXhwb3J0cy5nZXRWYWx1ZUxhYmVsID0gZ2V0VmFsdWVMYWJlbDtcbmV4cG9ydHMuZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbiA9IGdldFRyYW5zZm9ybWVkUG9zaXRpb247XG5leHBvcnRzLmJ1aWxkQ2FydGVzaWFuU2luZ2xlTGFiZWxFbE9wdGlvbiA9IGJ1aWxkQ2FydGVzaWFuU2luZ2xlTGFiZWxFbE9wdGlvbjtcbmV4cG9ydHMubWFrZUxpbmVTaGFwZSA9IG1ha2VMaW5lU2hhcGU7XG5leHBvcnRzLm1ha2VSZWN0U2hhcGUgPSBtYWtlUmVjdFNoYXBlO1xuZXhwb3J0cy5tYWtlU2VjdG9yU2hhcGUgPSBtYWtlU2VjdG9yU2hhcGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL3ZpZXdIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci92aWV3SGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZShcIi4vZGF0YVpvb20vdHlwZURlZmF1bHRlclwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vRGF0YVpvb21Nb2RlbFwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vRGF0YVpvb21WaWV3XCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9TbGlkZXJab29tTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL1NsaWRlclpvb21WaWV3XCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9JbnNpZGVab29tTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL0luc2lkZVpvb21WaWV3XCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3NvclwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vZGF0YVpvb21BY3Rpb25cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBoZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgYXNjID0gbnVtYmVyVXRpbC5hc2M7XG4vKipcbiAqIE9wZXJhdGUgc2luZ2xlIGF4aXMuXG4gKiBPbmUgYXhpcyBjYW4gb25seSBvcGVyYXRlZCBieSBvbmUgYXhpcyBvcGVyYXRvci5cbiAqIERpZmZlcmVudCBkYXRhWm9vbU1vZGVscyBtYXkgYmUgZGVmaW5lZCB0byBvcGVyYXRlIHRoZSBzYW1lIGF4aXMuXG4gKiAoaS5lLiAnaW5zaWRlJyBkYXRhIHpvb20gYW5kICdzbGlkZXInIGRhdGEgem9vbSBjb21wb25lbnRzKVxuICogU28gZGF0YVpvb21Nb2RlbHMgc2hhcmUgb25lIGF4aXNQcm94eSBpbiB0aGF0IGNhc2UuXG4gKlxuICogQGNsYXNzXG4gKi9cblxudmFyIEF4aXNQcm94eSA9IGZ1bmN0aW9uIChkaW1OYW1lLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwsIGVjTW9kZWwpIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLl9kaW1OYW1lID0gZGltTmFtZTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2F4aXNJbmRleCA9IGF4aXNJbmRleDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cbiAgdGhpcy5fdmFsdWVXaW5kb3c7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuXG4gIHRoaXMuX3BlcmNlbnRXaW5kb3c7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuXG4gIHRoaXMuX2RhdGFFeHRlbnQ7XG4gIC8qKlxuICAgKiB7bWluU3BhbiwgbWF4U3BhbiwgbWluVmFsdWVTcGFuLCBtYXhWYWx1ZVNwYW59XG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX21pbk1heFNwYW47XG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICogQHR5cGUge21vZHVsZTogZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAqL1xuXG4gIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfVxuICAgKi9cblxuICB0aGlzLl9kYXRhWm9vbU1vZGVsID0gZGF0YVpvb21Nb2RlbDsgLy8gLyoqXG4gIC8vICAqIEByZWFkT25seVxuICAvLyAgKiBAcHJpdmF0ZVxuICAvLyAgKi9cbiAgLy8gdGhpcy5oYXNTZXJpZXNTdGFja2VkO1xufTtcblxuQXhpc1Byb3h5LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEF4aXNQcm94eSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgYXhpc1Byb3h5IGlzIGhvc3RlZCBieSBkYXRhWm9vbU1vZGVsLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfSBkYXRhWm9vbU1vZGVsXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBob3N0ZWRCeTogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVpvb21Nb2RlbCA9PT0gZGF0YVpvb21Nb2RlbDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFZhbHVlIGNhbiBvbmx5IGJlIE5hTiBvciBmaW5pdGUgdmFsdWUuXG4gICAqL1xuICBnZXREYXRhVmFsdWVXaW5kb3c6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVXaW5kb3cuc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBnZXREYXRhUGVyY2VudFdpbmRvdzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wZXJjZW50V2luZG93LnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNJbmRleFxuICAgKiBAcmV0dXJuIHtBcnJheX0gc2VyaWVzTW9kZWxzXG4gICAqL1xuICBnZXRUYXJnZXRTZXJpZXNNb2RlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VyaWVzTW9kZWxzID0gW107XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaWYgKGhlbHBlci5pc0Nvb3JkU3VwcG9ydGVkKHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpKSkge1xuICAgICAgICB2YXIgZGltTmFtZSA9IHRoaXMuX2RpbU5hbWU7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgbWFpblR5cGU6IGRpbU5hbWUgKyAnQXhpcycsXG4gICAgICAgICAgaW5kZXg6IHNlcmllc01vZGVsLmdldChkaW1OYW1lICsgJ0F4aXNJbmRleCcpLFxuICAgICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZSArICdBeGlzSWQnKVxuICAgICAgICB9KVswXTtcblxuICAgICAgICBpZiAodGhpcy5fYXhpc0luZGV4ID09PSAoYXhpc01vZGVsICYmIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCkpIHtcbiAgICAgICAgICBzZXJpZXNNb2RlbHMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gc2VyaWVzTW9kZWxzO1xuICB9LFxuICBnZXRBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lY01vZGVsLmdldENvbXBvbmVudCh0aGlzLl9kaW1OYW1lICsgJ0F4aXMnLCB0aGlzLl9heGlzSW5kZXgpO1xuICB9LFxuICBnZXRPdGhlckF4aXNNb2RlbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzRGltID0gdGhpcy5fZGltTmFtZTtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5nZXRBeGlzTW9kZWwoKTtcbiAgICB2YXIgaXNDYXJ0ZXNpYW4gPSBheGlzRGltID09PSAneCcgfHwgYXhpc0RpbSA9PT0gJ3knO1xuICAgIHZhciBvdGhlckF4aXNEaW07XG4gICAgdmFyIGNvb3JkU3lzSW5kZXhOYW1lO1xuXG4gICAgaWYgKGlzQ2FydGVzaWFuKSB7XG4gICAgICBjb29yZFN5c0luZGV4TmFtZSA9ICdncmlkSW5kZXgnO1xuICAgICAgb3RoZXJBeGlzRGltID0gYXhpc0RpbSA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZFN5c0luZGV4TmFtZSA9ICdwb2xhckluZGV4JztcbiAgICAgIG90aGVyQXhpc0RpbSA9IGF4aXNEaW0gPT09ICdhbmdsZScgPyAncmFkaXVzJyA6ICdhbmdsZSc7XG4gICAgfVxuXG4gICAgdmFyIGZvdW5kT3RoZXJBeGlzTW9kZWw7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KG90aGVyQXhpc0RpbSArICdBeGlzJywgZnVuY3Rpb24gKG90aGVyQXhpc01vZGVsKSB7XG4gICAgICBpZiAoKG90aGVyQXhpc01vZGVsLmdldChjb29yZFN5c0luZGV4TmFtZSkgfHwgMCkgPT09IChheGlzTW9kZWwuZ2V0KGNvb3JkU3lzSW5kZXhOYW1lKSB8fCAwKSkge1xuICAgICAgICBmb3VuZE90aGVyQXhpc01vZGVsID0gb3RoZXJBeGlzTW9kZWw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kT3RoZXJBeGlzTW9kZWw7XG4gIH0sXG4gIGdldE1pbk1heFNwYW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4genJVdGlsLmNsb25lKHRoaXMuX21pbk1heFNwYW4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPbmx5IGNhbGN1bGF0ZSBieSBnaXZlbiByYW5nZSBhbmQgdGhpcy5fZGF0YUV4dGVudCwgZG8gbm90IGNoYW5nZSBhbnl0aGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdGFydFZhbHVlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5lbmRWYWx1ZV1cbiAgICovXG4gIGNhbGN1bGF0ZURhdGFXaW5kb3c6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuX2RhdGFFeHRlbnQ7XG4gICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZ2V0QXhpc01vZGVsKCk7XG4gICAgdmFyIHNjYWxlID0gYXhpc01vZGVsLmF4aXMuc2NhbGU7XG5cbiAgICB2YXIgcmFuZ2VQcm9wTW9kZSA9IHRoaXMuX2RhdGFab29tTW9kZWwuZ2V0UmFuZ2VQcm9wTW9kZSgpO1xuXG4gICAgdmFyIHBlcmNlbnRFeHRlbnQgPSBbMCwgMTAwXTtcbiAgICB2YXIgcGVyY2VudFdpbmRvdyA9IFtvcHQuc3RhcnQsIG9wdC5lbmRdO1xuICAgIHZhciB2YWx1ZVdpbmRvdyA9IFtdO1xuICAgIGVhY2goWydzdGFydFZhbHVlJywgJ2VuZFZhbHVlJ10sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICB2YWx1ZVdpbmRvdy5wdXNoKG9wdFtwcm9wXSAhPSBudWxsID8gc2NhbGUucGFyc2Uob3B0W3Byb3BdKSA6IG51bGwpO1xuICAgIH0pOyAvLyBOb3JtYWxpemUgYm91bmQuXG5cbiAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIGJvdW5kVmFsdWUgPSB2YWx1ZVdpbmRvd1tpZHhdO1xuICAgICAgdmFyIGJvdW5kUGVyY2VudCA9IHBlcmNlbnRXaW5kb3dbaWR4XTsgLy8gTm90aWNlOiBkYXRhWm9vbSBpcyBiYXNlZCBlaXRoZXIgb24gYHBlcmNlbnRQcm9wYCAoJ3N0YXJ0JywgJ2VuZCcpIG9yXG4gICAgICAvLyBvbiBgdmFsdWVQcm9wYCAoJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnKS4gVGhlIGZvcm1lciBvbmUgaXMgc3VpdGFibGVcbiAgICAgIC8vIGZvciBjYXNlcyB0aGF0IGEgZGF0YVpvb20gY29tcG9uZW50IGNvbnRyb2xzIG11bHRpcGxlIGF4ZXMgd2l0aCBkaWZmZXJlbnRcbiAgICAgIC8vIHVuaXQgb3IgZXh0ZW50LCBhbmQgdGhlIGxhdHRlciBvbmUgaXMgc3VpdGFibGUgZm9yIGFjY3VyYXRlIHpvb20gYnkgcGl4ZWxcbiAgICAgIC8vIChlLmcuLCBpbiBkYXRhWm9vbVNlbGVjdCkuIGB2YWx1ZVByb3BgIGNhbiBiZSBjYWxjdWxhdGVkIGZyb20gYHBlcmNlbnRQcm9wYCxcbiAgICAgIC8vIGJ1dCBpdCBpcyBhd2t3YXJkIHRoYXQgYHBlcmNlbnRQcm9wYCBjYW4gbm90IGJlIG9idGFpbmVkIGZyb20gYHZhbHVlUHJvcGBcbiAgICAgIC8vIGFjY3VyYXRlbHkgKGJlY2F1c2UgYWxsIG9mIHZhbHVlcyB0aGF0IGFyZSBvdmVyZmxvdyB0aGUgYGRhdGFFeHRlbnRgIHdpbGxcbiAgICAgIC8vIGJlIGNhbGN1bGF0ZWQgdG8gcGVyY2VudCAnMTAwJScpLiBTbyB3ZSBoYXZlIHRvIHVzZVxuICAgICAgLy8gYGRhdGFab29tLmdldFJhbmdlUHJvcE1vZGUoKWAgdG8gbWFyayB3aGljaCBwcm9wIGlzIHVzZWQuXG4gICAgICAvLyBgcmFuZ2VQcm9wTW9kZWAgaXMgdXBkYXRlZCBvbmx5IHdoZW4gc2V0T3B0aW9uIG9yIGRpc3BhdGNoQWN0aW9uLCBvdGhlcndpc2VcbiAgICAgIC8vIGl0IHJlbWFpbnMgaXRzIG9yaWdpbmFsIHZhbHVlLlxuXG4gICAgICBpZiAocmFuZ2VQcm9wTW9kZVtpZHhdID09PSAncGVyY2VudCcpIHtcbiAgICAgICAgaWYgKGJvdW5kUGVyY2VudCA9PSBudWxsKSB7XG4gICAgICAgICAgYm91bmRQZXJjZW50ID0gcGVyY2VudEV4dGVudFtpZHhdO1xuICAgICAgICB9IC8vIFVzZSBzY2FsZS5wYXJzZSB0byBtYXRoIHJvdW5kIGZvciBjYXRlZ29yeSBvciB0aW1lIGF4aXMuXG5cblxuICAgICAgICBib3VuZFZhbHVlID0gc2NhbGUucGFyc2UobnVtYmVyVXRpbC5saW5lYXJNYXAoYm91bmRQZXJjZW50LCBwZXJjZW50RXh0ZW50LCBkYXRhRXh0ZW50LCB0cnVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDYWxjdWxhdGluZyBgcGVyY2VudGAgZnJvbSBgdmFsdWVgIG1heSBiZSBub3QgYWNjdXJhdGUsIGJlY2F1c2VcbiAgICAgICAgLy8gVGhpcyBjYWxjdWxhdGlvbiBjYW4gbm90IGJlIGludmVyc2VkLCBiZWNhdXNlIGFsbCBvZiB2YWx1ZXMgdGhhdFxuICAgICAgICAvLyBhcmUgb3ZlcmZsb3cgdGhlIGBkYXRhRXh0ZW50YCB3aWxsIGJlIGNhbGN1bGF0ZWQgdG8gcGVyY2VudCAnMTAwJSdcbiAgICAgICAgYm91bmRQZXJjZW50ID0gbnVtYmVyVXRpbC5saW5lYXJNYXAoYm91bmRWYWx1ZSwgZGF0YUV4dGVudCwgcGVyY2VudEV4dGVudCwgdHJ1ZSk7XG4gICAgICB9IC8vIHZhbHVlV2luZG93W2lkeF0gPSByb3VuZChib3VuZFZhbHVlKTtcbiAgICAgIC8vIHBlcmNlbnRXaW5kb3dbaWR4XSA9IHJvdW5kKGJvdW5kUGVyY2VudCk7XG5cblxuICAgICAgdmFsdWVXaW5kb3dbaWR4XSA9IGJvdW5kVmFsdWU7XG4gICAgICBwZXJjZW50V2luZG93W2lkeF0gPSBib3VuZFBlcmNlbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlV2luZG93OiBhc2ModmFsdWVXaW5kb3cpLFxuICAgICAgcGVyY2VudFdpbmRvdzogYXNjKHBlcmNlbnRXaW5kb3cpXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogTm90aWNlOiByZXNldCBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUgc2VyaWVzLnJlc3RvcmVEYXRhKCkgY2FsbGVkLFxuICAgKiBzbyBpdCBpcyByZWNvbW1hbmRlZCB0byBiZSBjYWxsZWQgaW4gXCJwcm9jZXNzIHN0YWdlXCIgYnV0IG5vdCBcIm1vZGVsIGluaXRcbiAgICogc3RhZ2VcIi5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgIGlmIChkYXRhWm9vbU1vZGVsICE9PSB0aGlzLl9kYXRhWm9vbU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFNlcmllcyA9IHRoaXMuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCk7IC8vIEN1bGN1bGF0ZSBkYXRhIHdpbmRvdyBhbmQgZGF0YSBleHRlbnQsIGFuZCByZWNvcmQgdGhlbS5cblxuICAgIHRoaXMuX2RhdGFFeHRlbnQgPSBjYWxjdWxhdGVEYXRhRXh0ZW50KHRoaXMsIHRoaXMuX2RpbU5hbWUsIHRhcmdldFNlcmllcyk7IC8vIHRoaXMuaGFzU2VyaWVzU3RhY2tlZCA9IGZhbHNlO1xuICAgIC8vIGVhY2godGFyZ2V0U2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgLy8gdmFyIGRhdGEgPSBzZXJpZXMuZ2V0RGF0YSgpO1xuICAgIC8vIHZhciBkYXRhRGltID0gZGF0YS5tYXBEaW1lbnNpb24odGhpcy5fZGltTmFtZSk7XG4gICAgLy8gdmFyIHN0YWNrZWREaW1lbnNpb24gPSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZERpbWVuc2lvbicpO1xuICAgIC8vIGlmIChzdGFja2VkRGltZW5zaW9uICYmIHN0YWNrZWREaW1lbnNpb24gPT09IGRhdGFEaW0pIHtcbiAgICAvLyB0aGlzLmhhc1Nlcmllc1N0YWNrZWQgPSB0cnVlO1xuICAgIC8vIH1cbiAgICAvLyB9LCB0aGlzKTtcblxuICAgIHZhciBkYXRhV2luZG93ID0gdGhpcy5jYWxjdWxhdGVEYXRhV2luZG93KGRhdGFab29tTW9kZWwub3B0aW9uKTtcbiAgICB0aGlzLl92YWx1ZVdpbmRvdyA9IGRhdGFXaW5kb3cudmFsdWVXaW5kb3c7XG4gICAgdGhpcy5fcGVyY2VudFdpbmRvdyA9IGRhdGFXaW5kb3cucGVyY2VudFdpbmRvdztcbiAgICBzZXRNaW5NYXhTcGFuKHRoaXMpOyAvLyBVcGRhdGUgYXhpcyBzZXR0aW5nIHRoZW4uXG5cbiAgICBzZXRBeGlzTW9kZWwodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfSBkYXRhWm9vbU1vZGVsXG4gICAqL1xuICByZXN0b3JlOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgIGlmIChkYXRhWm9vbU1vZGVsICE9PSB0aGlzLl9kYXRhWm9vbU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWVXaW5kb3cgPSB0aGlzLl9wZXJjZW50V2luZG93ID0gbnVsbDtcbiAgICBzZXRBeGlzTW9kZWwodGhpcywgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfSBkYXRhWm9vbU1vZGVsXG4gICAqL1xuICBmaWx0ZXJEYXRhOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgYXBpKSB7XG4gICAgaWYgKGRhdGFab29tTW9kZWwgIT09IHRoaXMuX2RhdGFab29tTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXhpc0RpbSA9IHRoaXMuX2RpbU5hbWU7XG4gICAgdmFyIHNlcmllc01vZGVscyA9IHRoaXMuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCk7XG4gICAgdmFyIGZpbHRlck1vZGUgPSBkYXRhWm9vbU1vZGVsLmdldCgnZmlsdGVyTW9kZScpO1xuICAgIHZhciB2YWx1ZVdpbmRvdyA9IHRoaXMuX3ZhbHVlV2luZG93O1xuXG4gICAgaWYgKGZpbHRlck1vZGUgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRklYTUVcbiAgICAvLyBUb29sYm94IG1heSBoYXMgZGF0YVpvb20gaW5qZWN0ZWQuIEFuZCBpZiB0aGVyZSBhcmUgc3RhY2tlZCBiYXIgY2hhcnRcbiAgICAvLyB3aXRoIE5hTiBkYXRhLCBOYU4gd2lsbCBiZSBmaWx0ZXJlZCBhbmQgc3RhY2sgd2lsbCBiZSB3cm9uZy5cbiAgICAvLyBTbyB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBtb2RlIHRvIGJlIHNldCBlbXB0eS5cbiAgICAvLyBJbiBmZWN0LCBpdCBpcyBub3QgYSBiaWcgZGVhbCB0aGF0IGRvIG5vdCBzdXBwb3J0IGZpbHRlck1vZGUtJ2ZpbHRlcidcbiAgICAvLyB3aGVuIHVzaW5nIHRvb2xib3gjZGF0YVpvb20sIHV0aWxsIHRvb2x0aXAjZGF0YVpvb20gc3VwcG9ydCBcInNpbmdsZSBheGlzXG4gICAgLy8gc2VsZWN0aW9uXCIgc29tZSBkYXksIHdoaWNoIG1pZ2h0IG5lZWQgXCJhZGFwdCB0byBkYXRhIGV4dGVudCBvbiB0aGVcbiAgICAvLyBvdGhlckF4aXNcIiwgd2hpY2ggaXMgZGlzYWJsZWQgYnkgZmlsdGVyTW9kZS0nZW1wdHknLlxuICAgIC8vIEJ1dCBjdXJyZW50bHksIHN0YWNrIGhhcyBiZWVuIGZpeGVkIHRvIGJhc2VkIG9uIHZhbHVlIGJ1dCBub3QgaW5kZXgsXG4gICAgLy8gc28gdGhpcyBpcyBub3QgYW4gaXNzdWUgYW55IG1vcmUuXG4gICAgLy8gdmFyIG90aGVyQXhpc01vZGVsID0gdGhpcy5nZXRPdGhlckF4aXNNb2RlbCgpO1xuICAgIC8vIGlmIChkYXRhWm9vbU1vZGVsLmdldCgnJGZyb21Ub29sYm94JylcbiAgICAvLyAgICAgJiYgb3RoZXJBeGlzTW9kZWxcbiAgICAvLyAgICAgJiYgb3RoZXJBeGlzTW9kZWwuaGFzU2VyaWVzU3RhY2tlZFxuICAgIC8vICkge1xuICAgIC8vICAgICBmaWx0ZXJNb2RlID0gJ2VtcHR5JztcbiAgICAvLyB9XG4gICAgLy8gVE9ET1xuICAgIC8vIGZpbHRlck1vZGUgJ3dlYWtGaWx0ZXInIGFuZCAnZW1wdHknIGlzIG5vdCBvcHRpbWl6ZWQgZm9yIGh1Z2UgZGF0YSB5ZXQuXG4gICAgLy8gUHJvY2VzcyBzZXJpZXMgZGF0YVxuXG5cbiAgICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgIHZhciBkYXRhRGltcyA9IHNlcmllc0RhdGEubWFwRGltZW5zaW9uKGF4aXNEaW0sIHRydWUpO1xuXG4gICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ3dlYWtGaWx0ZXInKSB7XG4gICAgICAgIHNlcmllc0RhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgdmFyIGxlZnRPdXQ7XG4gICAgICAgICAgdmFyIHJpZ2h0T3V0O1xuICAgICAgICAgIHZhciBoYXNWYWx1ZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YURpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlcmllc0RhdGEuZ2V0KGRhdGFEaW1zW2ldLCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHRoaXNIYXNWYWx1ZSA9ICFpc05hTih2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgdGhpc0xlZnRPdXQgPSB2YWx1ZSA8IHZhbHVlV2luZG93WzBdO1xuICAgICAgICAgICAgdmFyIHRoaXNSaWdodE91dCA9IHZhbHVlID4gdmFsdWVXaW5kb3dbMV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzSGFzVmFsdWUgJiYgIXRoaXNMZWZ0T3V0ICYmICF0aGlzUmlnaHRPdXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNIYXNWYWx1ZSAmJiAoaGFzVmFsdWUgPSB0cnVlKTtcbiAgICAgICAgICAgIHRoaXNMZWZ0T3V0ICYmIChsZWZ0T3V0ID0gdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzUmlnaHRPdXQgJiYgKHJpZ2h0T3V0ID0gdHJ1ZSk7XG4gICAgICAgICAgfSAvLyBJZiBib3RoIGxlZnQgb3V0IGFuZCByaWdodCBvdXQsIGRvIG5vdCBmaWx0ZXIuXG5cblxuICAgICAgICAgIHJldHVybiBoYXNWYWx1ZSAmJiBsZWZ0T3V0ICYmIHJpZ2h0T3V0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goZGF0YURpbXMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwuc2V0RGF0YShzZXJpZXNEYXRhLm1hcChkaW0sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gIWlzSW5XaW5kb3codmFsdWUpID8gTmFOIDogdmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHt9O1xuICAgICAgICAgICAgcmFuZ2VbZGltXSA9IHZhbHVlV2luZG93OyAvLyBjb25zb2xlLnRpbWUoJ3NlbGVjdCcpO1xuXG4gICAgICAgICAgICBzZXJpZXNEYXRhLnNlbGVjdFJhbmdlKHJhbmdlKTsgLy8gY29uc29sZS50aW1lRW5kKCdzZWxlY3QnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBlYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHNlcmllc0RhdGEuc2V0QXBwcm94aW1hdGVFeHRlbnQodmFsdWVXaW5kb3csIGRpbSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzSW5XaW5kb3codmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSB2YWx1ZVdpbmRvd1swXSAmJiB2YWx1ZSA8PSB2YWx1ZVdpbmRvd1sxXTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURhdGFFeHRlbnQoYXhpc1Byb3h5LCBheGlzRGltLCBzZXJpZXNNb2RlbHMpIHtcbiAgdmFyIGRhdGFFeHRlbnQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIGVhY2goc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgIGlmIChzZXJpZXNEYXRhKSB7XG4gICAgICBlYWNoKHNlcmllc0RhdGEubWFwRGltZW5zaW9uKGF4aXNEaW0sIHRydWUpLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHZhciBzZXJpZXNFeHRlbnQgPSBzZXJpZXNEYXRhLmdldEFwcHJveGltYXRlRXh0ZW50KGRpbSk7XG4gICAgICAgIHNlcmllc0V4dGVudFswXSA8IGRhdGFFeHRlbnRbMF0gJiYgKGRhdGFFeHRlbnRbMF0gPSBzZXJpZXNFeHRlbnRbMF0pO1xuICAgICAgICBzZXJpZXNFeHRlbnRbMV0gPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhRXh0ZW50WzFdID0gc2VyaWVzRXh0ZW50WzFdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRhdGFFeHRlbnRbMV0gPCBkYXRhRXh0ZW50WzBdKSB7XG4gICAgZGF0YUV4dGVudCA9IFtOYU4sIE5hTl07XG4gIH0gLy8gSXQgaXMgaW1wb3J0YW50IHRvIGdldCBcImNvbnNpc3RlbnRcIiBleHRlbnQgd2hlbiBtb3JlIHRoZW4gb25lIGF4ZXMgaXNcbiAgLy8gY29udHJvbGxlZCBieSBhIGBkYXRhWm9vbWAsIG90aGVyd2lzZSB0aG9zZSBheGVzIHdpbGwgbm90IGJlIHN5bmNocm9uaXplZFxuICAvLyB3aGVuIHpvb21pbmcuIEJ1dCBpdCBpcyBkaWZmaWN1bHQgdG8ga25vdyB3aGF0IGlzIFwiY29uc2lzdGVudFwiLCBjb25zaWRlcmluZ1xuICAvLyBheGVzIGhhdmUgZGlmZmVyZW50IHR5cGUgb3IgZXZlbiBkaWZmZXJlbnQgbWVhbmluZ3MgKEZvciBleGFtcGxlLCB0d29cbiAgLy8gdGltZSBheGVzIGFyZSB1c2VkIHRvIGNvbXBhcmUgZGF0YSBvZiB0aGUgc2FtZSBkYXRlIGluIGRpZmZlcmVudCB5ZWFycykuXG4gIC8vIFNvIGJhc2ljYWxseSBkYXRhWm9vbSBqdXN0IG9idGFpbnMgZXh0ZW50IGJ5IHNlcmllcy5kYXRhIChpbiBjYXRlZ29yeSBheGlzXG4gIC8vIGV4dGVudCBjYW4gYmUgb2J0YWluZWQgZnJvbSBheGlzLmRhdGEpLlxuICAvLyBOZXZlcnRoZWxlc3MsIHVzZXIgY2FuIHNldCBtaW4vbWF4L3NjYWxlIG9uIGF4ZXMgdG8gbWFrZSBleHRlbnQgb2YgYXhlc1xuICAvLyBjb25zaXN0ZW50LlxuXG5cbiAgZml4RXh0ZW50QnlBeGlzKGF4aXNQcm94eSwgZGF0YUV4dGVudCk7XG4gIHJldHVybiBkYXRhRXh0ZW50O1xufVxuXG5mdW5jdGlvbiBmaXhFeHRlbnRCeUF4aXMoYXhpc1Byb3h5LCBkYXRhRXh0ZW50KSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzUHJveHkuZ2V0QXhpc01vZGVsKCk7XG4gIHZhciBtaW4gPSBheGlzTW9kZWwuZ2V0TWluKHRydWUpOyAvLyBGb3IgY2F0ZWdvcnkgYXhpcywgaWYgbWluL21heC9zY2FsZSBhcmUgbm90IHNldCwgZXh0ZW50IGlzIGRldGVybWluZWRcbiAgLy8gYnkgYXhpcy5kYXRhIGJ5IGRlZmF1bHQuXG5cbiAgdmFyIGlzQ2F0ZWdvcnlBeGlzID0gYXhpc01vZGVsLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknO1xuICB2YXIgYXhpc0RhdGFMZW4gPSBpc0NhdGVnb3J5QXhpcyAmJiBheGlzTW9kZWwuZ2V0Q2F0ZWdvcmllcygpLmxlbmd0aDtcblxuICBpZiAobWluICE9IG51bGwgJiYgbWluICE9PSAnZGF0YU1pbicgJiYgdHlwZW9mIG1pbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGFFeHRlbnRbMF0gPSBtaW47XG4gIH0gZWxzZSBpZiAoaXNDYXRlZ29yeUF4aXMpIHtcbiAgICBkYXRhRXh0ZW50WzBdID0gYXhpc0RhdGFMZW4gPiAwID8gMCA6IE5hTjtcbiAgfVxuXG4gIHZhciBtYXggPSBheGlzTW9kZWwuZ2V0TWF4KHRydWUpO1xuXG4gIGlmIChtYXggIT0gbnVsbCAmJiBtYXggIT09ICdkYXRhTWF4JyAmJiB0eXBlb2YgbWF4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YUV4dGVudFsxXSA9IG1heDtcbiAgfSBlbHNlIGlmIChpc0NhdGVnb3J5QXhpcykge1xuICAgIGRhdGFFeHRlbnRbMV0gPSBheGlzRGF0YUxlbiA+IDAgPyBheGlzRGF0YUxlbiAtIDEgOiBOYU47XG4gIH1cblxuICBpZiAoIWF4aXNNb2RlbC5nZXQoJ3NjYWxlJywgdHJ1ZSkpIHtcbiAgICBkYXRhRXh0ZW50WzBdID4gMCAmJiAoZGF0YUV4dGVudFswXSA9IDApO1xuICAgIGRhdGFFeHRlbnRbMV0gPCAwICYmIChkYXRhRXh0ZW50WzFdID0gMCk7XG4gIH0gLy8gRm9yIHZhbHVlIGF4aXMsIGlmIG1pbi9tYXgvc2NhbGUgYXJlIG5vdCBzZXQsIHdlIGp1c3QgdXNlIHRoZSBleHRlbnQgb2J0YWluZWRcbiAgLy8gYnkgc2VyaWVzIGRhdGEsIHdoaWNoIG1heSBiZSBhIGxpdHRsZSBkaWZmZXJlbnQgZnJvbSB0aGUgZXh0ZW50IGNhbGN1bGF0ZWQgYnlcbiAgLy8gYGF4aXNIZWxwZXIuZ2V0U2NhbGVFeHRlbnRgLiBCdXQgdGhlIGRpZmZlcmVudCBqdXN0IGFmZmVjdHMgdGhlIGV4cGVyaWVuY2UgYVxuICAvLyBsaXR0bGUgd2hlbiB6b29taW5nLiBTbyBpdCB3aWxsIG5vdCBiZSBmaXhlZCB1bnRpbCBzb21lIHVzZXJzIHJlcXVpcmUgaXQgc3Ryb25nbHkuXG5cblxuICByZXR1cm4gZGF0YUV4dGVudDtcbn1cblxuZnVuY3Rpb24gc2V0QXhpc01vZGVsKGF4aXNQcm94eSwgaXNSZXN0b3JlKSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzUHJveHkuZ2V0QXhpc01vZGVsKCk7XG4gIHZhciBwZXJjZW50V2luZG93ID0gYXhpc1Byb3h5Ll9wZXJjZW50V2luZG93O1xuICB2YXIgdmFsdWVXaW5kb3cgPSBheGlzUHJveHkuX3ZhbHVlV2luZG93O1xuXG4gIGlmICghcGVyY2VudFdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfSAvLyBbMCwgNTAwXTogYXJiaXRyYXJ5IHZhbHVlLCBndWVzcyBheGlzIGV4dGVudC5cblxuXG4gIHZhciBwcmVjaXNpb24gPSBudW1iZXJVdGlsLmdldFBpeGVsUHJlY2lzaW9uKHZhbHVlV2luZG93LCBbMCwgNTAwXSk7XG4gIHByZWNpc2lvbiA9IE1hdGgubWluKHByZWNpc2lvbiwgMjApOyAvLyBpc1Jlc3RvcmUgb3IgaXNGdWxsXG5cbiAgdmFyIHVzZU9yaWdpbiA9IGlzUmVzdG9yZSB8fCBwZXJjZW50V2luZG93WzBdID09PSAwICYmIHBlcmNlbnRXaW5kb3dbMV0gPT09IDEwMDtcbiAgYXhpc01vZGVsLnNldFJhbmdlKHVzZU9yaWdpbiA/IG51bGwgOiArdmFsdWVXaW5kb3dbMF0udG9GaXhlZChwcmVjaXNpb24pLCB1c2VPcmlnaW4gPyBudWxsIDogK3ZhbHVlV2luZG93WzFdLnRvRml4ZWQocHJlY2lzaW9uKSk7XG59XG5cbmZ1bmN0aW9uIHNldE1pbk1heFNwYW4oYXhpc1Byb3h5KSB7XG4gIHZhciBtaW5NYXhTcGFuID0gYXhpc1Byb3h5Ll9taW5NYXhTcGFuID0ge307XG4gIHZhciBkYXRhWm9vbU1vZGVsID0gYXhpc1Byb3h5Ll9kYXRhWm9vbU1vZGVsO1xuICBlYWNoKFsnbWluJywgJ21heCddLCBmdW5jdGlvbiAobWluTWF4KSB7XG4gICAgbWluTWF4U3BhblttaW5NYXggKyAnU3BhbiddID0gZGF0YVpvb21Nb2RlbC5nZXQobWluTWF4ICsgJ1NwYW4nKTsgLy8gbWluVmFsdWVTcGFuIGFuZCBtYXhWYWx1ZVNwYW4gaGFzIGhpZ2hlciBwcmlvcml0eSB0aGFuIG1pblNwYW4gYW5kIG1heFNwYW5cblxuICAgIHZhciB2YWx1ZVNwYW4gPSBkYXRhWm9vbU1vZGVsLmdldChtaW5NYXggKyAnVmFsdWVTcGFuJyk7XG5cbiAgICBpZiAodmFsdWVTcGFuICE9IG51bGwpIHtcbiAgICAgIG1pbk1heFNwYW5bbWluTWF4ICsgJ1ZhbHVlU3BhbiddID0gdmFsdWVTcGFuO1xuICAgICAgdmFsdWVTcGFuID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpLmF4aXMuc2NhbGUucGFyc2UodmFsdWVTcGFuKTtcblxuICAgICAgaWYgKHZhbHVlU3BhbiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkYXRhRXh0ZW50ID0gYXhpc1Byb3h5Ll9kYXRhRXh0ZW50O1xuICAgICAgICBtaW5NYXhTcGFuW21pbk1heCArICdTcGFuJ10gPSBudW1iZXJVdGlsLmxpbmVhck1hcChkYXRhRXh0ZW50WzBdICsgdmFsdWVTcGFuLCBkYXRhRXh0ZW50LCBbMCwgMTAwXSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gQXhpc1Byb3h5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vQXhpc1Byb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vQXhpc1Byb3h5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxudmFyIEF4aXNQcm94eSA9IHJlcXVpcmUoXCIuL0F4aXNQcm94eVwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBlYWNoQXhpc0RpbSA9IGhlbHBlci5lYWNoQXhpc0RpbTtcbnZhciBEYXRhWm9vbU1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdkYXRhWm9vbScsXG4gIGRlcGVuZGVuY2llczogWyd4QXhpcycsICd5QXhpcycsICd6QXhpcycsICdyYWRpdXNBeGlzJywgJ2FuZ2xlQXhpcycsICdzaW5nbGVBeGlzJywgJ3NlcmllcyddLFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDQsXG4gICAgLy8gSGlnaGVyIHRoYW4gbm9ybWFsIGNvbXBvbmVudCAoejogMikuXG4gICAgb3JpZW50OiBudWxsLFxuICAgIC8vIERlZmF1bHQgYXV0byBieSBheGlzSW5kZXguIFBvc3NpYmxlIHZhbHVlOiAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcuXG4gICAgeEF4aXNJbmRleDogbnVsbCxcbiAgICAvLyBEZWZhdWx0IHRoZSBmaXJzdCBob3Jpem9udGFsIGNhdGVnb3J5IGF4aXMuXG4gICAgeUF4aXNJbmRleDogbnVsbCxcbiAgICAvLyBEZWZhdWx0IHRoZSBmaXJzdCB2ZXJ0aWNhbCBjYXRlZ29yeSBheGlzLlxuICAgIGZpbHRlck1vZGU6ICdmaWx0ZXInLFxuICAgIC8vIFBvc3NpYmxlIHZhbHVlczogJ2ZpbHRlcicgb3IgJ2VtcHR5JyBvciAnd2Vha0ZpbHRlcicuXG4gICAgLy8gJ2ZpbHRlcic6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSByZW1vdmVkLiBUaGlzIG9wdGlvbiBpc1xuICAgIC8vICAgICAgICAgIGFwcGxpY2FibGUgd2hlbiBmaWx0ZXJpbmcgb3V0bGllcnMuIEZvciBlYWNoIGRhdGEgaXRlbSwgaXQgd2lsbCBiZVxuICAgIC8vICAgICAgICAgIGZpbHRlcmVkIGlmIG9uZSBvZiB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBpcyBvdXQgb2YgdGhlIHdpbmRvdy5cbiAgICAvLyAnd2Vha0ZpbHRlcic6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSByZW1vdmVkLiBUaGlzIG9wdGlvblxuICAgIC8vICAgICAgICAgIGlzIGFwcGxpY2FibGUgd2hlbiBmaWx0ZXJpbmcgb3V0bGllcnMuIEZvciBlYWNoIGRhdGEgaXRlbSwgaXQgd2lsbCBiZVxuICAgIC8vICAgICAgICAgIGZpbHRlcmVkIG9ubHkgaWYgYWxsICBvZiB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgb3V0IG9mIHRoZSBzYW1lXG4gICAgLy8gICAgICAgICAgc2lkZSBvZiB0aGUgd2luZG93LlxuICAgIC8vICdlbXB0eSc6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSBzZXQgdG8gZW1wdHkuXG4gICAgLy8gICAgICAgICAgVGhpcyBvcHRpb24gaXMgYXBwbGljYWJsZSB3aGVuIHVzZXIgc2hvdWxkIG5vdCBuZWdsZWN0XG4gICAgLy8gICAgICAgICAgdGhhdCB0aGVyZSBhcmUgc29tZSBkYXRhIGl0ZW1zIG91dCBvZiB3aW5kb3cuXG4gICAgLy8gJ25vbmUnOiBEbyBub3QgZmlsdGVyLlxuICAgIC8vIFRha2luZyBsaW5lIGNoYXJ0IGFzIGFuIGV4YW1wbGUsIGxpbmUgd2lsbCBiZSBicm9rZW4gaW5cbiAgICAvLyB0aGUgZmlsdGVyZWQgcG9pbnRzIHdoZW4gZmlsdGVyTW9kZWwgaXMgc2V0IHRvICdlbXB0eScsIGJ1dFxuICAgIC8vIGJlIGNvbm5lY3RlZCB3aGVuIHNldCB0byAnZmlsdGVyJy5cbiAgICB0aHJvdHRsZTogbnVsbCxcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gYnkgdGhlIGZpeGVkIHJhdGUsIGF2b2lkIGZyZXF1ZW5jeS5cbiAgICAvLyBkZWZhdWx0IDEwMC4gRG8gbm90IHRocm90dGxlIHdoZW4gdXNlIG51bGwvdW5kZWZpbmVkLlxuICAgIC8vIElmIGFuaW1hdGlvbiA9PT0gdHJ1ZSBhbmQgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGUgPiAwLFxuICAgIC8vIGRlZmF1bHQgdmFsdWUgaXMgMTAwLCBvdGhlcndpc2UgMjAuXG4gICAgc3RhcnQ6IDAsXG4gICAgLy8gU3RhcnQgcGVyY2VudC4gMCB+IDEwMFxuICAgIGVuZDogMTAwLFxuICAgIC8vIEVuZCBwZXJjZW50LiAwIH4gMTAwXG4gICAgc3RhcnRWYWx1ZTogbnVsbCxcbiAgICAvLyBTdGFydCB2YWx1ZS4gSWYgc3RhcnRWYWx1ZSBzcGVjaWZpZWQsIHN0YXJ0IGlzIGlnbm9yZWQuXG4gICAgZW5kVmFsdWU6IG51bGwsXG4gICAgLy8gRW5kIHZhbHVlLiBJZiBlbmRWYWx1ZSBzcGVjaWZpZWQsIGVuZCBpcyBpZ25vcmVkLlxuICAgIG1pblNwYW46IG51bGwsXG4gICAgLy8gMCB+IDEwMFxuICAgIG1heFNwYW46IG51bGwsXG4gICAgLy8gMCB+IDEwMFxuICAgIG1pblZhbHVlU3BhbjogbnVsbCxcbiAgICAvLyBUaGUgcmFuZ2Ugb2YgZGF0YVpvb20gY2FuIG5vdCBiZSBzbWFsbGVyIHRoYW4gdGhhdC5cbiAgICBtYXhWYWx1ZVNwYW46IG51bGwsXG4gICAgLy8gVGhlIHJhbmdlIG9mIGRhdGFab29tIGNhbiBub3QgYmUgbGFyZ2VyIHRoYW4gdGhhdC5cbiAgICByYW5nZU1vZGU6IG51bGwgLy8gQXJyYXksIGNhbiBiZSAndmFsdWUnIG9yICdwZXJjZW50Jy5cblxuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgLyoqXG4gICAgICoga2V5IGxpa2UgeF8wLCB5XzFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZGF0YUludGVydmFsQnlBeGlzID0ge307XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2RhdGFJbmZvID0ge307XG4gICAgLyoqXG4gICAgICoga2V5IGxpa2UgeF8wLCB5XzFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fYXhpc1Byb3hpZXMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIHRoaXMudGV4dFN0eWxlTW9kZWw7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2F1dG9UaHJvdHRsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogJ3BlcmNlbnQnIG9yICd2YWx1ZSdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fcmFuZ2VQcm9wTW9kZSA9IFsncGVyY2VudCcsICdwZXJjZW50J107XG4gICAgdmFyIHJhd09wdGlvbiA9IHJldHJpZXZlUmF3KG9wdGlvbik7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIHRoaXMuZG9Jbml0KHJhd09wdGlvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICB2YXIgcmF3T3B0aW9uID0gcmV0cmlldmVSYXcobmV3T3B0aW9uKTsgLy9GSVggIzI1OTFcblxuICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgbmV3T3B0aW9uLCB0cnVlKTtcbiAgICB0aGlzLmRvSW5pdChyYXdPcHRpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkb0luaXQ6IGZ1bmN0aW9uIChyYXdPcHRpb24pIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uOyAvLyBEaXNhYmxlIHJlYWx0aW1lIHZpZXcgdXBkYXRlIGlmIGNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkLlxuXG4gICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzT3B0aW9uLnJlYWx0aW1lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0RGVmYXVsdFRocm90dGxlKHJhd09wdGlvbik7XG5cbiAgICB1cGRhdGVSYW5nZVVzZSh0aGlzLCByYXdPcHRpb24pO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgICAgLy8gc3RhcnQvZW5kIGhhcyBoaWdoZXIgcHJpb3JpdHkgb3ZlciBzdGFydFZhbHVlL2VuZFZhbHVlIGlmIHRoZXlcbiAgICAgIC8vIGJvdGggc2V0LCBidXQgd2Ugc2hvdWxkIG1ha2UgY2hhcnQuc2V0T3B0aW9uKHtlbmRWYWx1ZTogMTAwMH0pXG4gICAgICAvLyBlZmZlY3RpdmUsIHJhdGhlciB0aGFuIGNoYXJ0LnNldE9wdGlvbih7ZW5kVmFsdWU6IDEwMDAsIGVuZDogbnVsbH0pLlxuICAgICAgaWYgKHRoaXMuX3JhbmdlUHJvcE1vZGVbaW5kZXhdID09PSAndmFsdWUnKSB7XG4gICAgICAgIHRoaXNPcHRpb25bbmFtZXNbMF1dID0gbnVsbDtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIGRvIG5vdGhpbmcgYW5kIHVzZSB0aGUgbWVyZ2UgcmVzdWx0LlxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy50ZXh0U3R5bGVNb2RlbCA9IHRoaXMuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuXG4gICAgdGhpcy5fcmVzZXRUYXJnZXQoKTtcblxuICAgIHRoaXMuX2dpdmVBeGlzUHJveGllcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dpdmVBeGlzUHJveGllczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzUHJveGllcyA9IHRoaXMuX2F4aXNQcm94aWVzO1xuICAgIHRoaXMuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGRpbU5hbWVzLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtheGlzSW5kZXhdOyAvLyBJZiBleGlzdHMsIHNoYXJlIGF4aXNQcm94eSB3aXRoIG90aGVyIGRhdGFab29tTW9kZWxzLlxuXG4gICAgICB2YXIgYXhpc1Byb3h5ID0gYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgfHwgKCAvLyBVc2UgdGhlIGZpcnN0IGRhdGFab29tTW9kZWwgYXMgdGhlIG1haW4gbW9kZWwgb2YgYXhpc1Byb3h5LlxuICAgICAgYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgPSBuZXcgQXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCwgdGhpcywgZWNNb2RlbCkpOyAvLyBGSVhNRVxuICAgICAgLy8gZGlzcG9zZSBfX2R6QXhpc1Byb3h5XG5cbiAgICAgIGF4aXNQcm94aWVzW2RpbU5hbWVzLm5hbWUgKyAnXycgKyBheGlzSW5kZXhdID0gYXhpc1Byb3h5O1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0VGFyZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcblxuICAgIHZhciBhdXRvTW9kZSA9IHRoaXMuX2p1ZGdlQXV0b01vZGUoKTtcblxuICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgdmFyIGF4aXNJbmRleE5hbWUgPSBkaW1OYW1lcy5heGlzSW5kZXg7XG4gICAgICB0aGlzT3B0aW9uW2F4aXNJbmRleE5hbWVdID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkodGhpc09wdGlvbltheGlzSW5kZXhOYW1lXSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoYXV0b01vZGUgPT09ICdheGlzSW5kZXgnKSB7XG4gICAgICB0aGlzLl9hdXRvU2V0QXhpc0luZGV4KCk7XG4gICAgfSBlbHNlIGlmIChhdXRvTW9kZSA9PT0gJ29yaWVudCcpIHtcbiAgICAgIHRoaXMuX2F1dG9TZXRPcmllbnQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfanVkZ2VBdXRvTW9kZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIEF1dG8gc2V0IG9ubHkgd29ya3MgZm9yIHNldE9wdGlvbiBhdCB0aGUgZmlyc3QgdGltZS5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIHVzZXIncyByZXBvbnNpYmlsaXR5LiBTbyB1c2luZyBtZXJnZWRcbiAgICAvLyBvcHRpb24gaXMgT0suXG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgaGFzSW5kZXhTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgIC8vIFdoZW4gdXNlciBzZXQgYXhpc0luZGV4IGFzIGEgZW1wdHkgYXJyYXksIHdlIHRoaW5rIHRoYXQgdXNlciBzcGVjaWZ5IGF4aXNJbmRleFxuICAgICAgLy8gYnV0IGRvIG5vdCB3YW50IHVzZSBhdXRvIG1vZGUuIEJlY2F1c2UgZW1wdHkgYXJyYXkgbWF5IGJlIGVuY291bnRlcmVkIHdoZW5cbiAgICAgIC8vIHNvbWUgZXJyb3Igb2NjdXJlZC5cbiAgICAgIGlmICh0aGlzT3B0aW9uW2RpbU5hbWVzLmF4aXNJbmRleF0gIT0gbnVsbCkge1xuICAgICAgICBoYXNJbmRleFNwZWNpZmllZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdmFyIG9yaWVudCA9IHRoaXNPcHRpb24ub3JpZW50O1xuXG4gICAgaWYgKG9yaWVudCA9PSBudWxsICYmIGhhc0luZGV4U3BlY2lmaWVkKSB7XG4gICAgICByZXR1cm4gJ29yaWVudCc7XG4gICAgfSBlbHNlIGlmICghaGFzSW5kZXhTcGVjaWZpZWQpIHtcbiAgICAgIGlmIChvcmllbnQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzT3B0aW9uLm9yaWVudCA9ICdob3Jpem9udGFsJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdheGlzSW5kZXgnO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hdXRvU2V0QXhpc0luZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF1dG9BeGlzSW5kZXggPSB0cnVlO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLmdldCgnb3JpZW50JywgdHJ1ZSk7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgZGVwZW5kZW50TW9kZWxzID0gdGhpcy5kZXBlbmRlbnRNb2RlbHM7XG5cbiAgICBpZiAoYXV0b0F4aXNJbmRleCkge1xuICAgICAgLy8gRmluZCBheGlzIHRoYXQgcGFyYWxsZWwgdG8gZGF0YVpvb20gYXMgZGVmYXVsdC5cbiAgICAgIHZhciBkaW1OYW1lID0gb3JpZW50ID09PSAndmVydGljYWwnID8gJ3knIDogJ3gnO1xuXG4gICAgICBpZiAoZGVwZW5kZW50TW9kZWxzW2RpbU5hbWUgKyAnQXhpcyddLmxlbmd0aCkge1xuICAgICAgICB0aGlzT3B0aW9uW2RpbU5hbWUgKyAnQXhpc0luZGV4J10gPSBbMF07XG4gICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goZGVwZW5kZW50TW9kZWxzLnNpbmdsZUF4aXMsIGZ1bmN0aW9uIChzaW5nbGVBeGlzTW9kZWwpIHtcbiAgICAgICAgICBpZiAoYXV0b0F4aXNJbmRleCAmJiBzaW5nbGVBeGlzTW9kZWwuZ2V0KCdvcmllbnQnLCB0cnVlKSA9PT0gb3JpZW50KSB7XG4gICAgICAgICAgICB0aGlzT3B0aW9uLnNpbmdsZUF4aXNJbmRleCA9IFtzaW5nbGVBeGlzTW9kZWwuY29tcG9uZW50SW5kZXhdO1xuICAgICAgICAgICAgYXV0b0F4aXNJbmRleCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGNhdGVnb3J5IGF4aXMgYXMgZGVmYXVsdC4gKGNvbnNpZGVyIHBvbGFyKVxuICAgICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICAgIGlmICghYXV0b0F4aXNJbmRleCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGlzSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgYXhpc01vZGVscyA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdO1xuXG4gICAgICAgIGlmIChheGlzTW9kZWxzLmxlbmd0aCAmJiAhYXhpc0luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF4aXNNb2RlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChheGlzTW9kZWxzW2ldLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgICAgIGF4aXNJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpc09wdGlvbltkaW1OYW1lcy5heGlzSW5kZXhdID0gYXhpc0luZGljZXM7XG5cbiAgICAgICAgaWYgKGF4aXNJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyDov5nph4zmmK/lhbzlrrllYzLnmoTlhpnms5XvvIjmsqHmjIflrpp4QXhpc0luZGV45ZKMeUF4aXNJbmRleOaXtuaKinNjYXR0ZXLlkozlj4zmlbDlgLzovbTmipjmn7HnurPlhaVkYXRhWm9vbeaOp+WItu+8ie+8jFxuICAgICAgLy8g5L2G5piv5a6e6ZmF5piv5ZCm6ZyA6KaBR3JpZC5qcyNnZXRTY2FsZUJ5T3B0aW9u5p2l5Yik5pat77yI6ICD6JmRdGltZe+8jGxvZ+etiWF4aXMgdHlwZe+8ie+8n1xuICAgICAgLy8gSWYgYm90aCBkYXRhWm9vbS54QXhpc0luZGV4IGFuZCBkYXRhWm9vbS55QXhpc0luZGV4IGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICAvLyBkYXRhWm9vbSBjb21wb25lbnQgYXV0byBhZG9wdHMgc2VyaWVzIHRoYXQgcmVmZXJlbmNlIHRvXG4gICAgICAvLyBib3RoIHhBeGlzIGFuZCB5QXhpcyB3aGljaCB0eXBlIGlzICd2YWx1ZScuXG4gICAgICB0aGlzLmVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VyaWVzSGFzQWxsQXhlc1R5cGVPZihzZXJpZXNNb2RlbCwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBheGlzSW5kaWNlcyA9IHRoaXNPcHRpb25bZGltTmFtZXMuYXhpc0luZGV4XTtcbiAgICAgICAgICAgIHZhciBheGlzSW5kZXggPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0luZGV4KTtcbiAgICAgICAgICAgIHZhciBheGlzSWQgPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0lkKTtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5lY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgIG1haW5UeXBlOiBkaW1OYW1lcy5heGlzLFxuICAgICAgICAgICAgICBpbmRleDogYXhpc0luZGV4LFxuICAgICAgICAgICAgICBpZDogYXhpc0lkXG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIGF4aXNJbmRleCA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcblxuICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKGF4aXNJbmRpY2VzLCBheGlzSW5kZXgpIDwgMCkge1xuICAgICAgICAgICAgICBheGlzSW5kaWNlcy5wdXNoKGF4aXNJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hdXRvU2V0T3JpZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRpbTsgLy8gRmluZCB0aGUgZmlyc3QgYXhpc1xuXG4gICAgdGhpcy5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICFkaW0gJiYgKGRpbSA9IGRpbU5hbWVzLm5hbWUpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMub3B0aW9uLm9yaWVudCA9IGRpbSA9PT0gJ3knID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc1Nlcmllc0hhc0FsbEF4ZXNUeXBlT2Y6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgYXhpc1R5cGUpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIOmcgOimgXNlcmllc+eahHhBeGlzSW5kZXjlkox5QXhpc0luZGV46YO96aaW5YWI6Ieq5Yqo6K6+572u5LiK44CCXG4gICAgLy8g5L6L5aaCc2VyaWVzLnR5cGUgPT09IHNjYXR0ZXLml7bjgIJcbiAgICB2YXIgaXMgPSB0cnVlO1xuICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgdmFyIHNlcmllc0F4aXNJbmRleCA9IHNlcmllc01vZGVsLmdldChkaW1OYW1lcy5heGlzSW5kZXgpO1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdW3Nlcmllc0F4aXNJbmRleF07XG5cbiAgICAgIGlmICghYXhpc01vZGVsIHx8IGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSAhPT0gYXhpc1R5cGUpIHtcbiAgICAgICAgaXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0RGVmYXVsdFRocm90dGxlOiBmdW5jdGlvbiAocmF3T3B0aW9uKSB7XG4gICAgLy8gV2hlbiBmaXJzdCB0aW1lIHVzZXIgc2V0IHRocm90dGxlLCBhdXRvIHRocm90dGxlIGVuZHMuXG4gICAgaWYgKHJhd09wdGlvbi5oYXNPd25Qcm9wZXJ0eSgndGhyb3R0bGUnKSkge1xuICAgICAgdGhpcy5fYXV0b1Rocm90dGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2F1dG9UaHJvdHRsZSkge1xuICAgICAgdmFyIGdsb2JhbE9wdGlvbiA9IHRoaXMuZWNNb2RlbC5vcHRpb247XG4gICAgICB0aGlzLm9wdGlvbi50aHJvdHRsZSA9IGdsb2JhbE9wdGlvbi5hbmltYXRpb24gJiYgZ2xvYmFsT3B0aW9uLmFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlID4gMCA/IDEwMCA6IDIwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0Rmlyc3RUYXJnZXRBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlyc3RBeGlzTW9kZWw7XG4gICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICBpZiAoZmlyc3RBeGlzTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCk7XG5cbiAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZmlyc3RBeGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtpbmRpY2VzWzBdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBmaXJzdEF4aXNNb2RlbDtcbiAgfSxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBwYXJhbTogYXhpc01vZGVsLCBkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsLCBlY01vZGVsXG4gICAqL1xuICBlYWNoVGFyZ2V0QXhpczogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICBlYWNoKHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCksIGZ1bmN0aW9uIChheGlzSW5kZXgpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBkaW1OYW1lcywgYXhpc0luZGV4LCB0aGlzLCBlY01vZGVsKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltTmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHl9IElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0QXhpc1Byb3h5OiBmdW5jdGlvbiAoZGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2F4aXNQcm94aWVzW2RpbU5hbWUgKyAnXycgKyBheGlzSW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltTmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBJZiBub3QgZm91bmQsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAgICovXG4gIGdldEF4aXNNb2RlbDogZnVuY3Rpb24gKGRpbU5hbWUsIGF4aXNJbmRleCkge1xuICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmdldEF4aXNQcm94eShkaW1OYW1lLCBheGlzSW5kZXgpO1xuICAgIHJldHVybiBheGlzUHJveHkgJiYgYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBzZXQgdG8gdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuZF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRWYWx1ZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kVmFsdWVdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVVwZGF0ZVJhbmdlVXNnPWZhbHNlXVxuICAgKi9cbiAgc2V0UmF3UmFuZ2U6IGZ1bmN0aW9uIChvcHQsIGlnbm9yZVVwZGF0ZVJhbmdlVXNnKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAvLyBJZiBvbmx5IG9uZSBvZiAnc3RhcnQnIGFuZCAnc3RhcnRWYWx1ZScgaXMgbm90IG51bGwvdW5kZWZpbmVkLCB0aGUgb3RoZXJcbiAgICAgIC8vIHNob3VsZCBiZSBjbGVhcmVkLCB3aGljaCBlbmFibGUgY2xlYXIgdGhlIG9wdGlvbi5cbiAgICAgIC8vIElmIGJvdGggb2YgdGhlbSBhcmUgbm90IHNldCwga2VlcCBvcHRpb24gd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUsIHdoaWNoXG4gICAgICAvLyBlbmFibGUgdXNlIG9ubHkgc2V0IHN0YXJ0IGJ1dCBub3Qgc2V0IGVuZCB3aGVuIGNhbGxpbmcgYGRpc3BhdGNoQWN0aW9uYC5cbiAgICAgIC8vIFRoZSBzYW1lIGFzICdlbmQnIGFuZCAnZW5kVmFsdWUnLlxuICAgICAgaWYgKG9wdFtuYW1lc1swXV0gIT0gbnVsbCB8fCBvcHRbbmFtZXNbMV1dICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9uW25hbWVzWzBdXSA9IG9wdFtuYW1lc1swXV07XG4gICAgICAgIG9wdGlvbltuYW1lc1sxXV0gPSBvcHRbbmFtZXNbMV1dO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgICFpZ25vcmVVcGRhdGVSYW5nZVVzZyAmJiB1cGRhdGVSYW5nZVVzZSh0aGlzLCBvcHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbc3RhcnRQZXJjZW50LCBlbmRQZXJjZW50XVxuICAgKi9cbiAgZ2V0UGVyY2VudFJhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF4aXNQcm94eSA9IHRoaXMuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG5cbiAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICByZXR1cm4gYXhpc1Byb3h5LmdldERhdGFQZXJjZW50V2luZG93KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEZvciBleGFtcGxlLCBjaGFydC5nZXRNb2RlbCgpLmdldENvbXBvbmVudCgnZGF0YVpvb20nKS5nZXRWYWx1ZVJhbmdlKCd5JywgMCk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXhpc0RpbU5hbWVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXhpc0luZGV4XVxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3N0YXJ0VmFsdWUsIGVuZFZhbHVlXSB2YWx1ZSBjYW4gb25seSBiZSAnLScgb3IgZmluaXRlIG51bWJlci5cbiAgICovXG4gIGdldFZhbHVlUmFuZ2U6IGZ1bmN0aW9uIChheGlzRGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgaWYgKGF4aXNEaW1OYW1lID09IG51bGwgJiYgYXhpc0luZGV4ID09IG51bGwpIHtcbiAgICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuXG4gICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF4aXNQcm94eShheGlzRGltTmFtZSwgYXhpc0luZGV4KS5nZXREYXRhVmFsdWVXaW5kb3coKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2F4aXNNb2RlbF0gSWYgYXhpc01vZGVsIGdpdmVuLCBmaW5kIGF4aXNQcm94eVxuICAgKiAgICAgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGF4aXNNb2RlbFxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vQXhpc1Byb3h5fVxuICAgKi9cbiAgZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5OiBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgaWYgKGF4aXNNb2RlbCkge1xuICAgICAgcmV0dXJuIGF4aXNNb2RlbC5fX2R6QXhpc1Byb3h5O1xuICAgIH0gLy8gRmluZCB0aGUgZmlyc3QgaG9zdGVkIGF4aXNQcm94eVxuXG5cbiAgICB2YXIgYXhpc1Byb3hpZXMgPSB0aGlzLl9heGlzUHJveGllcztcblxuICAgIGZvciAodmFyIGtleSBpbiBheGlzUHJveGllcykge1xuICAgICAgaWYgKGF4aXNQcm94aWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5vIGhvc3RlZCBheGlzIGZpbmQgbm90IGhvc3RlZCBheGlzUHJveHkuXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiBkYXRhWm9vbU1vZGVsMSBhbmQgZGF0YVpvb21Nb2RlbDIgY29udHJvbCB0aGUgc2FtZSBheGlzLFxuICAgIC8vIGFuZCB0aGUgb3B0aW9uLnN0YXJ0IG9yIG9wdGlvbi5lbmQgc2V0dGluZ3MgYXJlIGRpZmZlcmVudC4gVGhlIHBlcmNlbnRSYW5nZVxuICAgIC8vIHNob3VsZCBmb2xsb3cgYXhpc1Byb3h5LlxuICAgIC8vIChXZSBlbmNvdW50ZXIgdGhpcyBwcm9ibGVtIGluIHRvb2xib3ggZGF0YSB6b29tLilcblxuXG4gICAgZm9yICh2YXIga2V5IGluIGF4aXNQcm94aWVzKSB7XG4gICAgICBpZiAoYXhpc1Byb3hpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0UmFuZ2VQcm9wTW9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5nZVByb3BNb2RlLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiByZXRyaWV2ZVJhdyhvcHRpb24pIHtcbiAgdmFyIHJldCA9IHt9O1xuICBlYWNoKFsnc3RhcnQnLCAnZW5kJywgJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnLCAndGhyb3R0bGUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBvcHRpb24uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKHJldFtuYW1lXSA9IG9wdGlvbltuYW1lXSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSYW5nZVVzZShkYXRhWm9vbU1vZGVsLCByYXdPcHRpb24pIHtcbiAgdmFyIHJhbmdlUHJvcE1vZGUgPSBkYXRhWm9vbU1vZGVsLl9yYW5nZVByb3BNb2RlO1xuICB2YXIgcmFuZ2VNb2RlSW5PcHRpb24gPSBkYXRhWm9vbU1vZGVsLmdldCgncmFuZ2VNb2RlJyk7XG4gIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgIHZhciBwZXJjZW50U3BlY2lmaWVkID0gcmF3T3B0aW9uW25hbWVzWzBdXSAhPSBudWxsO1xuICAgIHZhciB2YWx1ZVNwZWNpZmllZCA9IHJhd09wdGlvbltuYW1lc1sxXV0gIT0gbnVsbDtcblxuICAgIGlmIChwZXJjZW50U3BlY2lmaWVkICYmICF2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAncGVyY2VudCc7XG4gICAgfSBlbHNlIGlmICghcGVyY2VudFNwZWNpZmllZCAmJiB2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAndmFsdWUnO1xuICAgIH0gZWxzZSBpZiAocmFuZ2VNb2RlSW5PcHRpb24pIHtcbiAgICAgIHJhbmdlUHJvcE1vZGVbaW5kZXhdID0gcmFuZ2VNb2RlSW5PcHRpb25baW5kZXhdO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudFNwZWNpZmllZCkge1xuICAgICAgLy8gcGVyY2VudFNwZWNpZmllZCAmJiB2YWx1ZVNwZWNpZmllZFxuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAncGVyY2VudCc7XG4gICAgfSAvLyBlbHNlIHJlbWFpbiBpdHMgb3JpZ2luYWwgc2V0dGluZy5cblxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gRGF0YVpvb21Nb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIENvbXBvbmVudFZpZXcgPSByZXF1aXJlKFwiLi4vLi4vdmlldy9Db21wb25lbnRcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBfZGVmYXVsdCA9IENvbXBvbmVudFZpZXcuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFab29tJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdGhpcy5kYXRhWm9vbU1vZGVsID0gZGF0YVpvb21Nb2RlbDtcbiAgICB0aGlzLmVjTW9kZWwgPSBlY01vZGVsO1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBmaXJzdCB0YXJnZXQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSB7XG4gICAqICAgICAgICAgICAgICAgICAgIGdyaWQ6IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQwLCBheGlzTW9kZWxzOiBbYXhpczEsIGF4aXMzXSwgY29vcmRJbmRleDogMX0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB7bW9kZWw6IGNvb3JkMSwgYXhpc01vZGVsczogW2F4aXMwLCBheGlzMl0sIGNvb3JkSW5kZXg6IDB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAqICAgICAgICAgICAgICAgICAgIF0sICAvLyBjYXJ0ZXNpYW5zIG11c3Qgbm90IGJlIG51bGwvdW5kZWZpbmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICBwb2xhcjogW1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtheGlzNF0sIGNvb3JkSW5kZXg6IDB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAqICAgICAgICAgICAgICAgICAgIF0sICAvLyBwb2xhcnMgbXVzdCBub3QgYmUgbnVsbC91bmRlZmluZWQuXG4gICAqICAgICAgICAgICAgICAgICAgIHNpbmdsZUF4aXM6IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQwLCBheGlzTW9kZWxzOiBbXSwgY29vcmRJbmRleDogMH1cbiAgICogICAgICAgICAgICAgICAgICAgXVxuICAgKi9cbiAgZ2V0VGFyZ2V0Q29vcmRJbmZvOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgdmFyIGNvb3JkU3lzTGlzdHMgPSB7fTtcbiAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcywgYXhpc0luZGV4KSB7XG4gICAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoZGltTmFtZXMuYXhpcywgYXhpc0luZGV4KTtcblxuICAgICAgaWYgKGF4aXNNb2RlbCkge1xuICAgICAgICB2YXIgY29vcmRNb2RlbCA9IGF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCk7XG4gICAgICAgIGNvb3JkTW9kZWwgJiYgc2F2ZShjb29yZE1vZGVsLCBheGlzTW9kZWwsIGNvb3JkU3lzTGlzdHNbY29vcmRNb2RlbC5tYWluVHlwZV0gfHwgKGNvb3JkU3lzTGlzdHNbY29vcmRNb2RlbC5tYWluVHlwZV0gPSBbXSksIGNvb3JkTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgZnVuY3Rpb24gc2F2ZShjb29yZE1vZGVsLCBheGlzTW9kZWwsIHN0b3JlLCBjb29yZEluZGV4KSB7XG4gICAgICB2YXIgaXRlbTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RvcmVbaV0ubW9kZWwgPT09IGNvb3JkTW9kZWwpIHtcbiAgICAgICAgICBpdGVtID0gc3RvcmVbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHN0b3JlLnB1c2goaXRlbSA9IHtcbiAgICAgICAgICBtb2RlbDogY29vcmRNb2RlbCxcbiAgICAgICAgICBheGlzTW9kZWxzOiBbXSxcbiAgICAgICAgICBjb29yZEluZGV4OiBjb29yZEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpdGVtLmF4aXNNb2RlbHMucHVzaChheGlzTW9kZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBjb29yZFN5c0xpc3RzO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21WaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21WaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIERhdGFab29tTW9kZWwgPSByZXF1aXJlKFwiLi9EYXRhWm9vbU1vZGVsXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgX2RlZmF1bHQgPSBEYXRhWm9vbU1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhWm9vbS5pbnNpZGUnLFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIC8vIFdoZXRoZXIgZGlzYWJsZSB0aGlzIGluc2lkZSB6b29tLlxuICAgIHpvb21Mb2NrOiBmYWxzZSxcbiAgICAvLyBXaGV0aGVyIGRpc2FibGUgem9vbSBidXQgb25seSBwYW4uXG4gICAgem9vbU9uTW91c2VXaGVlbDogdHJ1ZSxcbiAgICAvLyBDYW4gYmU6IHRydWUgLyBmYWxzZSAvICdzaGlmdCcgLyAnY3RybCcgLyAnYWx0Jy5cbiAgICBtb3ZlT25Nb3VzZU1vdmU6IHRydWUsXG4gICAgLy8gQ2FuIGJlOiB0cnVlIC8gZmFsc2UgLyAnc2hpZnQnIC8gJ2N0cmwnIC8gJ2FsdCcuXG4gICAgcHJldmVudERlZmF1bHRNb3VzZU1vdmU6IHRydWVcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21Nb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21Nb2RlbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgRGF0YVpvb21WaWV3ID0gcmVxdWlyZShcIi4vRGF0YVpvb21WaWV3XCIpO1xuXG52YXIgc2xpZGVyTW92ZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvc2xpZGVyTW92ZVwiKTtcblxudmFyIHJvYW1zID0gcmVxdWlyZShcIi4vcm9hbXNcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBiaW5kID0genJVdGlsLmJpbmQ7XG52YXIgSW5zaWRlWm9vbVZpZXcgPSBEYXRhWm9vbVZpZXcuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFab29tLmluc2lkZScsXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIC8qKlxuICAgICAqICd0aHJvdHRsZScgaXMgdXNlZCBpbiB0aGlzLmRpc3BhdGNoQWN0aW9uLCBzbyB3ZSBzYXZlIHJhbmdlXG4gICAgICogdG8gYXZvaWQgbWlzc2luZyBzb21lICdwYW4nIGluZm8uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5fcmFuZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgSW5zaWRlWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVuZGVyJywgYXJndW1lbnRzKTsgLy8gSGFuY2UgdGhlIGB0aHJvdHRsZWAgdXRpbCBlbnN1cmVzIHRvIHByZXNlcnZlIGNvbW1hbmQgb3JkZXIsXG4gICAgLy8gaGVyZSBzaW1wbHkgdXBkYXRpbmcgcmFuZ2UgYWxsIHRoZSB0aW1lIHdpbGwgbm90IGNhdXNlIG1pc3NpbmdcbiAgICAvLyBhbnkgb2YgdGhlIHRoZSByb2FtIGNoYW5nZS5cblxuICAgIHRoaXMuX3JhbmdlID0gZGF0YVpvb21Nb2RlbC5nZXRQZXJjZW50UmFuZ2UoKTsgLy8gUmVzZXQgY29udHJvbGxlcnMuXG5cbiAgICB6clV0aWwuZWFjaCh0aGlzLmdldFRhcmdldENvb3JkSW5mbygpLCBmdW5jdGlvbiAoY29vcmRJbmZvTGlzdCwgY29vcmRTeXNOYW1lKSB7XG4gICAgICB2YXIgYWxsQ29vcmRJZHMgPSB6clV0aWwubWFwKGNvb3JkSW5mb0xpc3QsIGZ1bmN0aW9uIChjb29yZEluZm8pIHtcbiAgICAgICAgcmV0dXJuIHJvYW1zLmdlbmVyYXRlQ29vcmRJZChjb29yZEluZm8ubW9kZWwpO1xuICAgICAgfSk7XG4gICAgICB6clV0aWwuZWFjaChjb29yZEluZm9MaXN0LCBmdW5jdGlvbiAoY29vcmRJbmZvKSB7XG4gICAgICAgIHZhciBjb29yZE1vZGVsID0gY29vcmRJbmZvLm1vZGVsO1xuICAgICAgICB2YXIgZGF0YVpvb21PcHRpb24gPSBkYXRhWm9vbU1vZGVsLm9wdGlvbjtcbiAgICAgICAgcm9hbXMucmVnaXN0ZXIoYXBpLCB7XG4gICAgICAgICAgY29vcmRJZDogcm9hbXMuZ2VuZXJhdGVDb29yZElkKGNvb3JkTW9kZWwpLFxuICAgICAgICAgIGFsbENvb3JkSWRzOiBhbGxDb29yZElkcyxcbiAgICAgICAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoZSwgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5jb250YWluUG9pbnQoW3gsIHldKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGFab29tSWQ6IGRhdGFab29tTW9kZWwuaWQsXG4gICAgICAgICAgdGhyb3R0bGVSYXRlOiBkYXRhWm9vbU1vZGVsLmdldCgndGhyb3R0bGUnLCB0cnVlKSxcbiAgICAgICAgICBwYW5HZXRSYW5nZTogYmluZCh0aGlzLl9vblBhbiwgdGhpcywgY29vcmRJbmZvLCBjb29yZFN5c05hbWUpLFxuICAgICAgICAgIHpvb21HZXRSYW5nZTogYmluZCh0aGlzLl9vblpvb20sIHRoaXMsIGNvb3JkSW5mbywgY29vcmRTeXNOYW1lKSxcbiAgICAgICAgICB6b29tTG9jazogZGF0YVpvb21PcHRpb24uem9vbUxvY2ssXG4gICAgICAgICAgZGlzYWJsZWQ6IGRhdGFab29tT3B0aW9uLmRpc2FibGVkLFxuICAgICAgICAgIHJvYW1Db250cm9sbGVyT3B0OiB7XG4gICAgICAgICAgICB6b29tT25Nb3VzZVdoZWVsOiBkYXRhWm9vbU9wdGlvbi56b29tT25Nb3VzZVdoZWVsLFxuICAgICAgICAgICAgbW92ZU9uTW91c2VNb3ZlOiBkYXRhWm9vbU9wdGlvbi5tb3ZlT25Nb3VzZU1vdmUsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZTogZGF0YVpvb21PcHRpb24ucHJldmVudERlZmF1bHRNb3VzZU1vdmVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHJvYW1zLnVucmVnaXN0ZXIodGhpcy5hcGksIHRoaXMuZGF0YVpvb21Nb2RlbC5pZCk7XG4gICAgSW5zaWRlWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAnZGlzcG9zZScsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fcmFuZ2UgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUGFuOiBmdW5jdGlvbiAoY29vcmRJbmZvLCBjb29yZFN5c05hbWUsIGNvbnRyb2xsZXIsIGR4LCBkeSwgb2xkWCwgb2xkWSwgbmV3WCwgbmV3WSkge1xuICAgIHZhciBsYXN0UmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICB2YXIgcmFuZ2UgPSBsYXN0UmFuZ2Uuc2xpY2UoKTsgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybSBieSB0aGUgZmlyc3QgYXhpcy5cblxuICAgIHZhciBheGlzTW9kZWwgPSBjb29yZEluZm8uYXhpc01vZGVsc1swXTtcblxuICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpcmVjdGlvbkluZm8gPSBnZXREaXJlY3Rpb25JbmZvW2Nvb3JkU3lzTmFtZV0oW29sZFgsIG9sZFldLCBbbmV3WCwgbmV3WV0sIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKTtcbiAgICB2YXIgcGVyY2VudERlbHRhID0gZGlyZWN0aW9uSW5mby5zaWduYWwgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkgKiBkaXJlY3Rpb25JbmZvLnBpeGVsIC8gZGlyZWN0aW9uSW5mby5waXhlbExlbmd0aDtcbiAgICBzbGlkZXJNb3ZlKHBlcmNlbnREZWx0YSwgcmFuZ2UsIFswLCAxMDBdLCAnYWxsJyk7XG4gICAgdGhpcy5fcmFuZ2UgPSByYW5nZTtcblxuICAgIGlmIChsYXN0UmFuZ2VbMF0gIT09IHJhbmdlWzBdIHx8IGxhc3RSYW5nZVsxXSAhPT0gcmFuZ2VbMV0pIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25ab29tOiBmdW5jdGlvbiAoY29vcmRJbmZvLCBjb29yZFN5c05hbWUsIGNvbnRyb2xsZXIsIHNjYWxlLCBtb3VzZVgsIG1vdXNlWSkge1xuICAgIHZhciBsYXN0UmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICB2YXIgcmFuZ2UgPSBsYXN0UmFuZ2Uuc2xpY2UoKTsgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybSBieSB0aGUgZmlyc3QgYXhpcy5cblxuICAgIHZhciBheGlzTW9kZWwgPSBjb29yZEluZm8uYXhpc01vZGVsc1swXTtcblxuICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpcmVjdGlvbkluZm8gPSBnZXREaXJlY3Rpb25JbmZvW2Nvb3JkU3lzTmFtZV0obnVsbCwgW21vdXNlWCwgbW91c2VZXSwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZEluZm8pO1xuICAgIHZhciBwZXJjZW50UG9pbnQgPSAoZGlyZWN0aW9uSW5mby5zaWduYWwgPiAwID8gZGlyZWN0aW9uSW5mby5waXhlbFN0YXJ0ICsgZGlyZWN0aW9uSW5mby5waXhlbExlbmd0aCAtIGRpcmVjdGlvbkluZm8ucGl4ZWwgOiBkaXJlY3Rpb25JbmZvLnBpeGVsIC0gZGlyZWN0aW9uSW5mby5waXhlbFN0YXJ0KSAvIGRpcmVjdGlvbkluZm8ucGl4ZWxMZW5ndGggKiAocmFuZ2VbMV0gLSByYW5nZVswXSkgKyByYW5nZVswXTtcbiAgICBzY2FsZSA9IE1hdGgubWF4KDEgLyBzY2FsZSwgMCk7XG4gICAgcmFuZ2VbMF0gPSAocmFuZ2VbMF0gLSBwZXJjZW50UG9pbnQpICogc2NhbGUgKyBwZXJjZW50UG9pbnQ7XG4gICAgcmFuZ2VbMV0gPSAocmFuZ2VbMV0gLSBwZXJjZW50UG9pbnQpICogc2NhbGUgKyBwZXJjZW50UG9pbnQ7IC8vIFJlc3RyaWN0IHJhbmdlLlxuXG4gICAgdmFyIG1pbk1heFNwYW4gPSB0aGlzLmRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCkuZ2V0TWluTWF4U3BhbigpO1xuICAgIHNsaWRlck1vdmUoMCwgcmFuZ2UsIFswLCAxMDBdLCAwLCBtaW5NYXhTcGFuLm1pblNwYW4sIG1pbk1heFNwYW4ubWF4U3Bhbik7XG4gICAgdGhpcy5fcmFuZ2UgPSByYW5nZTtcblxuICAgIGlmIChsYXN0UmFuZ2VbMF0gIT09IHJhbmdlWzBdIHx8IGxhc3RSYW5nZVsxXSAhPT0gcmFuZ2VbMV0pIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH1cbn0pO1xudmFyIGdldERpcmVjdGlvbkluZm8gPSB7XG4gIGdyaWQ6IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgcmV0ID0ge307XG4gICAgdmFyIHJlY3QgPSBjb29yZEluZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgb2xkUG9pbnQgPSBvbGRQb2ludCB8fCBbMCwgMF07XG5cbiAgICBpZiAoYXhpcy5kaW0gPT09ICd4Jykge1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMF0gLSBvbGRQb2ludFswXTtcbiAgICAgIHJldC5waXhlbExlbmd0aCA9IHJlY3Qud2lkdGg7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueDtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAxIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF4aXMuZGltID09PSAneSdcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzFdIC0gb2xkUG9pbnRbMV07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LmhlaWdodDtcbiAgICAgIHJldC5waXhlbFN0YXJ0ID0gcmVjdC55O1xuICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBwb2xhcjogZnVuY3Rpb24gKG9sZFBvaW50LCBuZXdQb2ludCwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZEluZm8pIHtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciByZXQgPSB7fTtcbiAgICB2YXIgcG9sYXIgPSBjb29yZEluZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgcmFkaXVzRXh0ZW50ID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpLmdldEV4dGVudCgpO1xuICAgIHZhciBhbmdsZUV4dGVudCA9IHBvbGFyLmdldEFuZ2xlQXhpcygpLmdldEV4dGVudCgpO1xuICAgIG9sZFBvaW50ID0gb2xkUG9pbnQgPyBwb2xhci5wb2ludFRvQ29vcmQob2xkUG9pbnQpIDogWzAsIDBdO1xuICAgIG5ld1BvaW50ID0gcG9sYXIucG9pbnRUb0Nvb3JkKG5ld1BvaW50KTtcblxuICAgIGlmIChheGlzTW9kZWwubWFpblR5cGUgPT09ICdyYWRpdXNBeGlzJykge1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMF0gLSBvbGRQb2ludFswXTsgLy8gcmV0LnBpeGVsTGVuZ3RoID0gTWF0aC5hYnMocmFkaXVzRXh0ZW50WzFdIC0gcmFkaXVzRXh0ZW50WzBdKTtcbiAgICAgIC8vIHJldC5waXhlbFN0YXJ0ID0gTWF0aC5taW4ocmFkaXVzRXh0ZW50WzBdLCByYWRpdXNFeHRlbnRbMV0pO1xuXG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByYWRpdXNFeHRlbnRbMV0gLSByYWRpdXNFeHRlbnRbMF07XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJhZGl1c0V4dGVudFswXTtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAxIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICdhbmdsZUF4aXMnXG4gICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFsxXSAtIG9sZFBvaW50WzFdOyAvLyByZXQucGl4ZWxMZW5ndGggPSBNYXRoLmFicyhhbmdsZUV4dGVudFsxXSAtIGFuZ2xlRXh0ZW50WzBdKTtcbiAgICAgIC8vIHJldC5waXhlbFN0YXJ0ID0gTWF0aC5taW4oYW5nbGVFeHRlbnRbMF0sIGFuZ2xlRXh0ZW50WzFdKTtcblxuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gYW5nbGVFeHRlbnRbMV0gLSBhbmdsZUV4dGVudFswXTtcbiAgICAgIHJldC5waXhlbFN0YXJ0ID0gYW5nbGVFeHRlbnRbMF07XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gLTEgOiAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIHNpbmdsZUF4aXM6IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgcmVjdCA9IGNvb3JkSW5mby5tb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgb2xkUG9pbnQgPSBvbGRQb2ludCB8fCBbMCwgMF07XG5cbiAgICBpZiAoYXhpcy5vcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMF0gLSBvbGRQb2ludFswXTtcbiAgICAgIHJldC5waXhlbExlbmd0aCA9IHJlY3Qud2lkdGg7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueDtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAxIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICd2ZXJ0aWNhbCdcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzFdIC0gb2xkUG9pbnRbMV07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LmhlaWdodDtcbiAgICAgIHJldC5waXhlbFN0YXJ0ID0gcmVjdC55O1xuICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gSW5zaWRlWm9vbVZpZXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9JbnNpZGVab29tVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21WaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIERhdGFab29tTW9kZWwgPSByZXF1aXJlKFwiLi9EYXRhWm9vbU1vZGVsXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgX2RlZmF1bHQgPSBEYXRhWm9vbU1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhWm9vbS5zZWxlY3QnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2VsZWN0Wm9vbU1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2VsZWN0Wm9vbU1vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIERhdGFab29tVmlldyA9IHJlcXVpcmUoXCIuL0RhdGFab29tVmlld1wiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9kZWZhdWx0ID0gRGF0YVpvb21WaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhWm9vbS5zZWxlY3QnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2VsZWN0Wm9vbVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBEYXRhWm9vbU1vZGVsID0gcmVxdWlyZShcIi4vRGF0YVpvb21Nb2RlbFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIFNsaWRlclpvb21Nb2RlbCA9IERhdGFab29tTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFab29tLnNsaWRlcicsXG4gIGxheW91dE1vZGU6ICdib3gnLFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgc2hvdzogdHJ1ZSxcbiAgICAvLyBwaCA9PiBwbGFjZWhvbGRlci4gVXNpbmcgcGxhY2Vob2RlciBoZXJlIGJlY2F1c2VcbiAgICAvLyBkZWF1bHQgdmFsdWUgY2FuIG9ubHkgYmUgZHJpdmVkIGluIHZpZXcgc3RhZ2UuXG4gICAgcmlnaHQ6ICdwaCcsXG4gICAgLy8gRGVmYXVsdCBhbGlnbiB0byBncmlkIHJlY3QuXG4gICAgdG9wOiAncGgnLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIHdpZHRoOiAncGgnLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIGhlaWdodDogJ3BoJyxcbiAgICAvLyBEZWZhdWx0IGFsaWduIHRvIGdyaWQgcmVjdC5cbiAgICBsZWZ0OiBudWxsLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIGJvdHRvbTogbnVsbCxcbiAgICAvLyBEZWZhdWx0IGFsaWduIHRvIGdyaWQgcmVjdC5cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDQ3LDY5LDg0LDApJyxcbiAgICAvLyBCYWNrZ3JvdW5kIG9mIHNsaWRlciB6b29tIGNvbXBvbmVudC5cbiAgICAvLyBkYXRhQmFja2dyb3VuZENvbG9yOiAnI2RkZCcsICAgICAgICAgLy8gQmFja2dyb3VuZCBjb29yIG9mIGRhdGEgc2hhZG93IGFuZCBib3JkZXIgb2YgYm94LFxuICAgIC8vIGhpZ2hlc3QgcHJpb3JpdHksIHJlbWFpbiBmb3IgY29tcGF0aWJpbGl0eSBvZlxuICAgIC8vIHByZXZpb3VzIHZlcnNpb24sIGJ1dCBub3QgcmVjb21tZW5kZWQgYW55IG1vcmUuXG4gICAgZGF0YUJhY2tncm91bmQ6IHtcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogJyMyZjQ1NTQnLFxuICAgICAgICB3aWR0aDogMC41LFxuICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgIH0sXG4gICAgICBhcmVhU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICdyZ2JhKDQ3LDY5LDg0LDAuMyknLFxuICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgIH1cbiAgICB9LFxuICAgIGJvcmRlckNvbG9yOiAnI2RkZCcsXG4gICAgLy8gYm9yZGVyIGNvbG9yIG9mIHRoZSBib3guIEZvciBjb21wYXRpYmlsaXR5LFxuICAgIC8vIGlmIGRhdGFCYWNrZ3JvdW5kQ29sb3IgaXMgc2V0LCBib3JkZXJDb2xvclxuICAgIC8vIGlzIGlnbm9yZWQuXG4gICAgZmlsbGVyQ29sb3I6ICdyZ2JhKDE2NywxODMsMjA0LDAuNCknLFxuICAgIC8vIENvbG9yIG9mIHNlbGVjdGVkIGFyZWEuXG4gICAgLy8gaGFuZGxlQ29sb3I6ICdyZ2JhKDg5LDE3MCwyMTYsMC45NSknLCAgICAgLy8gQ29sb3Igb2YgaGFuZGxlLlxuICAgIC8vIGhhbmRsZUljb246ICdwYXRoOi8vTTQuOSwxNy44YzAtMS40LDQuNS0xMC41LDUuNS0xMi40YzAtMC4xLDAuNi0xLjEsMC45LTEuMWMwLjQsMCwwLjksMSwwLjksMS4xYzEuMSwyLjIsNS40LDExLDUuNCwxMi40djE3LjhjMCwxLjUtMC42LDIuMS0xLjMsMi4xSDYuMWMtMC43LDAtMS4zLTAuNi0xLjMtMi4xVjE3Ljh6JyxcbiAgICBoYW5kbGVJY29uOiAnTTguMiwxMy42VjMuOUg2LjN2OS43SDMuMXYxNC45aDMuM3Y5LjdoMS44di05LjdoMy4zVjEzLjZIOC4yeiBNOS43LDI0LjRINC44di0xLjRoNC45VjI0LjR6IE05LjcsMTkuMUg0Ljh2LTEuNGg0LjlWMTkuMXonLFxuICAgIC8vIFBlcmNlbnQgb2YgdGhlIHNsaWRlciBoZWlnaHRcbiAgICBoYW5kbGVTaXplOiAnMTAwJScsXG4gICAgaGFuZGxlU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2E3YjdjYydcbiAgICB9LFxuICAgIGxhYmVsUHJlY2lzaW9uOiBudWxsLFxuICAgIGxhYmVsRm9ybWF0dGVyOiBudWxsLFxuICAgIHNob3dEZXRhaWw6IHRydWUsXG4gICAgc2hvd0RhdGFTaGFkb3c6ICdhdXRvJyxcbiAgICAvLyBEZWZhdWx0IGF1dG8gZGVjaXNpb24uXG4gICAgcmVhbHRpbWU6IHRydWUsXG4gICAgem9vbUxvY2s6IGZhbHNlLFxuICAgIC8vIFdoZXRoZXIgZGlzYWJsZSB6b29tLlxuICAgIHRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH1cbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBTbGlkZXJab29tTW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tTW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciB0aHJvdHRsZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3Rocm90dGxlXCIpO1xuXG52YXIgRGF0YVpvb21WaWV3ID0gcmVxdWlyZShcIi4vRGF0YVpvb21WaWV3XCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIGxheW91dCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xheW91dFwiKTtcblxudmFyIHNsaWRlck1vdmUgPSByZXF1aXJlKFwiLi4vaGVscGVyL3NsaWRlck1vdmVcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBSZWN0ID0gZ3JhcGhpYy5SZWN0O1xudmFyIGxpbmVhck1hcCA9IG51bWJlclV0aWwubGluZWFyTWFwO1xudmFyIGFzYyA9IG51bWJlclV0aWwuYXNjO1xudmFyIGJpbmQgPSB6clV0aWwuYmluZDtcbnZhciBlYWNoID0genJVdGlsLmVhY2g7IC8vIENvbnN0YW50c1xuXG52YXIgREVGQVVMVF9MT0NBVElPTl9FREdFX0dBUCA9IDc7XG52YXIgREVGQVVMVF9GUkFNRV9CT1JERVJfV0lEVEggPSAxO1xudmFyIERFRkFVTFRfRklMTEVSX1NJWkUgPSAzMDtcbnZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xudmFyIFZFUlRJQ0FMID0gJ3ZlcnRpY2FsJztcbnZhciBMQUJFTF9HQVAgPSA1O1xudmFyIFNIT1dfREFUQV9TSEFET1dfU0VSSUVTX1RZUEUgPSBbJ2xpbmUnLCAnYmFyJywgJ2NhbmRsZXN0aWNrJywgJ3NjYXR0ZXInXTtcbnZhciBTbGlkZXJab29tVmlldyA9IERhdGFab29tVmlldy5leHRlbmQoe1xuICB0eXBlOiAnZGF0YVpvb20uc2xpZGVyJyxcbiAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9kaXNwbGF5YWJsZXMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgICB0aGlzLl9vcmllbnQ7XG4gICAgLyoqXG4gICAgICogWzAsIDEwMF1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fcmFuZ2U7XG4gICAgLyoqXG4gICAgICogW2Nvb3JkIG9mIHRoZSBmaXJzdCBoYW5kbGUsIGNvb3JkIG9mIHRoZSBzZWNvbmQgaGFuZGxlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIC8qKlxuICAgICAqIFtsZW5ndGgsIHRoaWNrXVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuXG4gICAgdGhpcy5fc2l6ZTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLl9oYW5kbGVXaWR0aDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLl9oYW5kbGVIZWlnaHQ7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2xvY2F0aW9uO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLl9kcmFnZ2luZztcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fZGF0YVNoYWRvd0luZm87XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgU2xpZGVyWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVuZGVyJywgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsZS5jcmVhdGVPclVwZGF0ZSh0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicsIHRoaXMuZGF0YVpvb21Nb2RlbC5nZXQoJ3Rocm90dGxlJyksICdmaXhSYXRlJyk7XG4gICAgdGhpcy5fb3JpZW50ID0gZGF0YVpvb21Nb2RlbC5nZXQoJ29yaWVudCcpO1xuXG4gICAgaWYgKHRoaXMuZGF0YVpvb21Nb2RlbC5nZXQoJ3Nob3cnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBOb3RpY2U6IHRoaXMuX3Jlc2V0SW50ZXJ2YWwoKSBzaG91bGQgbm90IGJlIGV4ZWN1dGVkIHdoZW4gcGF5bG9hZC50eXBlXG4gICAgLy8gaXMgJ2RhdGFab29tJywgb3JpZ2luIHRoaXMuX3JhbmdlIHNob3VsZCBiZSBtYWludGFpbmVkLCBvdGhlcndpc2UgJ3BhbidcbiAgICAvLyBvciAnem9vbScgaW5mbyB3aWxsIGJlIG1pc3NlZCBiZWNhdXNlIG9mICd0aHJvdHRsZScgb2YgdGhpcy5kaXNwYXRjaEFjdGlvbixcblxuXG4gICAgaWYgKCFwYXlsb2FkIHx8IHBheWxvYWQudHlwZSAhPT0gJ2RhdGFab29tJyB8fCBwYXlsb2FkLmZyb20gIT09IHRoaXMudWlkKSB7XG4gICAgICB0aGlzLl9idWlsZFZpZXcoKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgU2xpZGVyWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVtb3ZlJywgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBTbGlkZXJab29tVmlldy5zdXBlckFwcGx5KHRoaXMsICdkaXNwb3NlJywgYXJndW1lbnRzKTtcbiAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicpO1xuICB9LFxuICBfYnVpbGRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdGhpc0dyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgdGhpcy5fcmVzZXRMb2NhdGlvbigpO1xuXG4gICAgdGhpcy5fcmVzZXRJbnRlcnZhbCgpO1xuXG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoKTtcblxuICAgIHRoaXMuX3JlbmRlckhhbmRsZSgpO1xuXG4gICAgdGhpcy5fcmVuZGVyRGF0YVNoYWRvdygpO1xuXG4gICAgdGhpc0dyb3VwLmFkZChiYXJHcm91cCk7XG5cbiAgICB0aGlzLl9wb3NpdGlvbkdyb3VwKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRMb2NhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBhcGkgPSB0aGlzLmFwaTsgLy8gSWYgc29tZSBvZiB4L3kvd2lkdGgvaGVpZ2h0IGFyZSBub3Qgc3BlY2lmaWVkLFxuICAgIC8vIGF1dG8tYWRhcHQgYWNjb3JkaW5nIHRvIHRhcmdldCBncmlkLlxuXG4gICAgdmFyIGNvb3JkUmVjdCA9IHRoaXMuX2ZpbmRDb29yZFJlY3QoKTtcblxuICAgIHZhciBlY1NpemUgPSB7XG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH07IC8vIERlZmF1bHQgYWxpZ24gYnkgY29vcmRpbmF0ZSBzeXN0ZW0gcmVjdC5cblxuICAgIHZhciBwb3NpdGlvbkluZm8gPSB0aGlzLl9vcmllbnQgPT09IEhPUklaT05UQUwgPyB7XG4gICAgICAvLyBXaHkgdXNpbmcgJ3JpZ2h0JywgYmVjYXVzZSByaWdodCBzaG91bGQgYmUgdXNlZCBpbiB2ZXJ0aWNhbCxcbiAgICAgIC8vIGFuZCBpdCBpcyBiZXR0ZXIgdG8gYmUgY29uc2lzdGVudCBmb3IgZGVhbGluZyB3aXRoIHBvc2l0aW9uIHBhcmFtIG1lcmdlLlxuICAgICAgcmlnaHQ6IGVjU2l6ZS53aWR0aCAtIGNvb3JkUmVjdC54IC0gY29vcmRSZWN0LndpZHRoLFxuICAgICAgdG9wOiBlY1NpemUuaGVpZ2h0IC0gREVGQVVMVF9GSUxMRVJfU0laRSAtIERFRkFVTFRfTE9DQVRJT05fRURHRV9HQVAsXG4gICAgICB3aWR0aDogY29vcmRSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBERUZBVUxUX0ZJTExFUl9TSVpFXG4gICAgfSA6IHtcbiAgICAgIC8vIHZlcnRpY2FsXG4gICAgICByaWdodDogREVGQVVMVF9MT0NBVElPTl9FREdFX0dBUCxcbiAgICAgIHRvcDogY29vcmRSZWN0LnksXG4gICAgICB3aWR0aDogREVGQVVMVF9GSUxMRVJfU0laRSxcbiAgICAgIGhlaWdodDogY29vcmRSZWN0LmhlaWdodFxuICAgIH07IC8vIERvIG5vdCB3cml0ZSBiYWNrIHRvIG9wdGlvbiBhbmQgcmVwbGFjZSB2YWx1ZSAncGgnLCBiZWNhdXNlXG4gICAgLy8gdGhlICdwaCcgdmFsdWUgc2hvdWxkIGJlIHJlY2FsY3VsYXRlZCB3aGVuIHJlc2l6ZS5cblxuICAgIHZhciBsYXlvdXRQYXJhbXMgPSBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKGRhdGFab29tTW9kZWwub3B0aW9uKTsgLy8gUmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG5cbiAgICB6clV0aWwuZWFjaChbJ3JpZ2h0JywgJ3RvcCcsICd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChsYXlvdXRQYXJhbXNbbmFtZV0gPT09ICdwaCcpIHtcbiAgICAgICAgbGF5b3V0UGFyYW1zW25hbWVdID0gcG9zaXRpb25JbmZvW25hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBsYXlvdXRSZWN0ID0gbGF5b3V0LmdldExheW91dFJlY3QobGF5b3V0UGFyYW1zLCBlY1NpemUsIGRhdGFab29tTW9kZWwucGFkZGluZyk7XG4gICAgdGhpcy5fbG9jYXRpb24gPSB7XG4gICAgICB4OiBsYXlvdXRSZWN0LngsXG4gICAgICB5OiBsYXlvdXRSZWN0LnlcbiAgICB9O1xuICAgIHRoaXMuX3NpemUgPSBbbGF5b3V0UmVjdC53aWR0aCwgbGF5b3V0UmVjdC5oZWlnaHRdO1xuICAgIHRoaXMuX29yaWVudCA9PT0gVkVSVElDQUwgJiYgdGhpcy5fc2l6ZS5yZXZlcnNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcG9zaXRpb25Hcm91cDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2xvY2F0aW9uO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLl9vcmllbnQ7IC8vIEp1c3QgdXNlIHRoZSBmaXJzdCBheGlzIHRvIGRldGVybWluZSBtYXBwaW5nLlxuXG4gICAgdmFyIHRhcmdldEF4aXNNb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXRGaXJzdFRhcmdldEF4aXNNb2RlbCgpO1xuICAgIHZhciBpbnZlcnNlID0gdGFyZ2V0QXhpc01vZGVsICYmIHRhcmdldEF4aXNNb2RlbC5nZXQoJ2ludmVyc2UnKTtcbiAgICB2YXIgYmFyR3JvdXAgPSB0aGlzLl9kaXNwbGF5YWJsZXMuYmFyR3JvdXA7XG4gICAgdmFyIG90aGVyQXhpc0ludmVyc2UgPSAodGhpcy5fZGF0YVNoYWRvd0luZm8gfHwge30pLm90aGVyQXhpc0ludmVyc2U7IC8vIFRyYW5zZm9ybSBiYXJHcm91cC5cblxuICAgIGJhckdyb3VwLmF0dHIob3JpZW50ID09PSBIT1JJWk9OVEFMICYmICFpbnZlcnNlID8ge1xuICAgICAgc2NhbGU6IG90aGVyQXhpc0ludmVyc2UgPyBbMSwgMV0gOiBbMSwgLTFdXG4gICAgfSA6IG9yaWVudCA9PT0gSE9SSVpPTlRBTCAmJiBpbnZlcnNlID8ge1xuICAgICAgc2NhbGU6IG90aGVyQXhpc0ludmVyc2UgPyBbLTEsIDFdIDogWy0xLCAtMV1cbiAgICB9IDogb3JpZW50ID09PSBWRVJUSUNBTCAmJiAhaW52ZXJzZSA/IHtcbiAgICAgIHNjYWxlOiBvdGhlckF4aXNJbnZlcnNlID8gWzEsIC0xXSA6IFsxLCAxXSxcbiAgICAgIHJvdGF0aW9uOiBNYXRoLlBJIC8gMiAvLyBEb250IHVzZSBNYXRoLlBJLCBjb25zaWRlcmluZyBzaGFkb3cgZGlyZWN0aW9uLlxuXG4gICAgfSA6IHtcbiAgICAgIHNjYWxlOiBvdGhlckF4aXNJbnZlcnNlID8gWy0xLCAtMV0gOiBbLTEsIDFdLFxuICAgICAgcm90YXRpb246IE1hdGguUEkgLyAyXG4gICAgfSk7IC8vIFBvc2l0aW9uIGJhckdyb3VwXG5cbiAgICB2YXIgcmVjdCA9IHRoaXNHcm91cC5nZXRCb3VuZGluZ1JlY3QoW2Jhckdyb3VwXSk7XG4gICAgdGhpc0dyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgW2xvY2F0aW9uLnggLSByZWN0LngsIGxvY2F0aW9uLnkgLSByZWN0LnldKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRWaWV3RXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFswLCB0aGlzLl9zaXplWzBdXTtcbiAgfSxcbiAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwO1xuICAgIGJhckdyb3VwLmFkZChuZXcgUmVjdCh7XG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogZGF0YVpvb21Nb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpXG4gICAgICB9LFxuICAgICAgejI6IC00MFxuICAgIH0pKTsgLy8gQ2xpY2sgcGFuZWwsIG92ZXIgc2hhZG93LCBiZWxvdyBoYW5kbGVzLlxuXG4gICAgYmFyR3JvdXAuYWRkKG5ldyBSZWN0KHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiBzaXplWzBdLFxuICAgICAgICBoZWlnaHQ6IHNpemVbMV1cbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgejI6IDAsXG4gICAgICBvbmNsaWNrOiB6clV0aWwuYmluZCh0aGlzLl9vbkNsaWNrUGFuZWxDbGljaywgdGhpcylcbiAgICB9KSk7XG4gIH0sXG4gIF9yZW5kZXJEYXRhU2hhZG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLl9kYXRhU2hhZG93SW5mbyA9IHRoaXMuX3ByZXBhcmVEYXRhU2hhZG93SW5mbygpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGluZm8uc2VyaWVzO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0UmF3RGF0YSgpO1xuICAgIHZhciBvdGhlckRpbSA9IHNlcmllc01vZGVsLmdldFNoYWRvd0RpbSA/IHNlcmllc01vZGVsLmdldFNoYWRvd0RpbSgpIC8vIEBzZWUgY2FuZGxlc3RpY2tcbiAgICA6IGluZm8ub3RoZXJEaW07XG5cbiAgICBpZiAob3RoZXJEaW0gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdGhlckRhdGFFeHRlbnQgPSBkYXRhLmdldERhdGFFeHRlbnQob3RoZXJEaW0pOyAvLyBOaWNlIGV4dGVudC5cblxuICAgIHZhciBvdGhlck9mZnNldCA9IChvdGhlckRhdGFFeHRlbnRbMV0gLSBvdGhlckRhdGFFeHRlbnRbMF0pICogMC4zO1xuICAgIG90aGVyRGF0YUV4dGVudCA9IFtvdGhlckRhdGFFeHRlbnRbMF0gLSBvdGhlck9mZnNldCwgb3RoZXJEYXRhRXh0ZW50WzFdICsgb3RoZXJPZmZzZXRdO1xuICAgIHZhciBvdGhlclNoYWRvd0V4dGVudCA9IFswLCBzaXplWzFdXTtcbiAgICB2YXIgdGhpc1NoYWRvd0V4dGVudCA9IFswLCBzaXplWzBdXTtcbiAgICB2YXIgYXJlYVBvaW50cyA9IFtbc2l6ZVswXSwgMF0sIFswLCAwXV07XG4gICAgdmFyIGxpbmVQb2ludHMgPSBbXTtcbiAgICB2YXIgc3RlcCA9IHRoaXNTaGFkb3dFeHRlbnRbMV0gLyAoZGF0YS5jb3VudCgpIC0gMSk7XG4gICAgdmFyIHRoaXNDb29yZCA9IDA7IC8vIE9wdGltaXplIGZvciBsYXJnZSBkYXRhIHNoYWRvd1xuXG4gICAgdmFyIHN0cmlkZSA9IE1hdGgucm91bmQoZGF0YS5jb3VudCgpIC8gc2l6ZVswXSk7XG4gICAgdmFyIGxhc3RJc0VtcHR5O1xuICAgIGRhdGEuZWFjaChbb3RoZXJEaW1dLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICBpZiAoc3RyaWRlID4gMCAmJiBpbmRleCAlIHN0cmlkZSkge1xuICAgICAgICB0aGlzQ29vcmQgKz0gc3RlcDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGSVhNRVxuICAgICAgLy8gU2hvdWxkIGNvbnNpZGVyIGF4aXMubWluL2F4aXMubWF4IHdoZW4gZHJhd2luZyBkYXRhU2hhZG93LlxuICAgICAgLy8gRklYTUVcbiAgICAgIC8vIOW6lOivpeS9v+eUqOe7n+S4gOeahOepuuWIpOaWre+8n+i/mOaYr+WcqGxpc3Tph4zov5vooYznqbrliKTmlq3vvJ9cblxuXG4gICAgICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSAnJzsgLy8gU2VlICM0MjM1LlxuXG4gICAgICB2YXIgb3RoZXJDb29yZCA9IGlzRW1wdHkgPyAwIDogbGluZWFyTWFwKHZhbHVlLCBvdGhlckRhdGFFeHRlbnQsIG90aGVyU2hhZG93RXh0ZW50LCB0cnVlKTsgLy8gQXR0ZW1wdCB0byBkcmF3IGRhdGEgc2hhZG93IHByZWNpc2VseSB3aGVuIHRoZXJlIGFyZSBlbXB0eSB2YWx1ZS5cblxuICAgICAgaWYgKGlzRW1wdHkgJiYgIWxhc3RJc0VtcHR5ICYmIGluZGV4KSB7XG4gICAgICAgIGFyZWFQb2ludHMucHVzaChbYXJlYVBvaW50c1thcmVhUG9pbnRzLmxlbmd0aCAtIDFdWzBdLCAwXSk7XG4gICAgICAgIGxpbmVQb2ludHMucHVzaChbbGluZVBvaW50c1tsaW5lUG9pbnRzLmxlbmd0aCAtIDFdWzBdLCAwXSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtcHR5ICYmIGxhc3RJc0VtcHR5KSB7XG4gICAgICAgIGFyZWFQb2ludHMucHVzaChbdGhpc0Nvb3JkLCAwXSk7XG4gICAgICAgIGxpbmVQb2ludHMucHVzaChbdGhpc0Nvb3JkLCAwXSk7XG4gICAgICB9XG5cbiAgICAgIGFyZWFQb2ludHMucHVzaChbdGhpc0Nvb3JkLCBvdGhlckNvb3JkXSk7XG4gICAgICBsaW5lUG9pbnRzLnB1c2goW3RoaXNDb29yZCwgb3RoZXJDb29yZF0pO1xuICAgICAgdGhpc0Nvb3JkICs9IHN0ZXA7XG4gICAgICBsYXN0SXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgfSk7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7IC8vIHZhciBkYXRhQmFja2dyb3VuZE1vZGVsID0gZGF0YVpvb21Nb2RlbC5nZXRNb2RlbCgnZGF0YUJhY2tncm91bmQnKTtcblxuICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5hZGQobmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IGFyZWFQb2ludHNcbiAgICAgIH0sXG4gICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgZmlsbDogZGF0YVpvb21Nb2RlbC5nZXQoJ2RhdGFCYWNrZ3JvdW5kQ29sb3InKVxuICAgICAgfSwgZGF0YVpvb21Nb2RlbC5nZXRNb2RlbCgnZGF0YUJhY2tncm91bmQuYXJlYVN0eWxlJykuZ2V0QXJlYVN0eWxlKCkpLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgejI6IC0yMFxuICAgIH0pKTtcblxuICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5hZGQobmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBsaW5lUG9pbnRzXG4gICAgICB9LFxuICAgICAgc3R5bGU6IGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2RhdGFCYWNrZ3JvdW5kLmxpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgejI6IC0xOVxuICAgIH0pKTtcbiAgfSxcbiAgX3ByZXBhcmVEYXRhU2hhZG93SW5mbzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBzaG93RGF0YVNoYWRvdyA9IGRhdGFab29tTW9kZWwuZ2V0KCdzaG93RGF0YVNoYWRvdycpO1xuXG4gICAgaWYgKHNob3dEYXRhU2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmluZCBhIHJlcHJlc2VudGF0aXZlIHNlcmllcy5cblxuXG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcywgYXhpc0luZGV4KSB7XG4gICAgICB2YXIgc2VyaWVzTW9kZWxzID0gZGF0YVpvb21Nb2RlbC5nZXRBeGlzUHJveHkoZGltTmFtZXMubmFtZSwgYXhpc0luZGV4KS5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKTtcbiAgICAgIHpyVXRpbC5lYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvd0RhdGFTaGFkb3cgIT09IHRydWUgJiYgenJVdGlsLmluZGV4T2YoU0hPV19EQVRBX1NIQURPV19TRVJJRVNfVFlQRSwgc2VyaWVzTW9kZWwuZ2V0KCd0eXBlJykpIDwgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGlzQXhpcyA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGRpbU5hbWVzLmF4aXMsIGF4aXNJbmRleCkuYXhpcztcbiAgICAgICAgdmFyIG90aGVyRGltID0gZ2V0T3RoZXJEaW0oZGltTmFtZXMubmFtZSk7XG4gICAgICAgIHZhciBvdGhlckF4aXNJbnZlcnNlO1xuICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICAgIGlmIChvdGhlckRpbSAhPSBudWxsICYmIGNvb3JkU3lzLmdldE90aGVyQXhpcykge1xuICAgICAgICAgIG90aGVyQXhpc0ludmVyc2UgPSBjb29yZFN5cy5nZXRPdGhlckF4aXModGhpc0F4aXMpLmludmVyc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlckRpbSA9IHNlcmllc01vZGVsLmdldERhdGEoKS5tYXBEaW1lbnNpb24ob3RoZXJEaW0pO1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgdGhpc0F4aXM6IHRoaXNBeGlzLFxuICAgICAgICAgIHNlcmllczogc2VyaWVzTW9kZWwsXG4gICAgICAgICAgdGhpc0RpbTogZGltTmFtZXMubmFtZSxcbiAgICAgICAgICBvdGhlckRpbTogb3RoZXJEaW0sXG4gICAgICAgICAgb3RoZXJBeGlzSW52ZXJzZTogb3RoZXJBeGlzSW52ZXJzZVxuICAgICAgICB9O1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgX3JlbmRlckhhbmRsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXNwbGF5YmxlcyA9IHRoaXMuX2Rpc3BsYXlhYmxlcztcbiAgICB2YXIgaGFuZGxlcyA9IGRpc3BsYXlibGVzLmhhbmRsZXMgPSBbXTtcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gZGlzcGxheWJsZXMuaGFuZGxlTGFiZWxzID0gW107XG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwO1xuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICBiYXJHcm91cC5hZGQoZGlzcGxheWJsZXMuZmlsbGVyID0gbmV3IFJlY3Qoe1xuICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpcy5fb3JpZW50KSxcbiAgICAgIGRyaWZ0OiBiaW5kKHRoaXMuX29uRHJhZ01vdmUsIHRoaXMsICdhbGwnKSxcbiAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBGb3QgbW9iaWxlIGRldmljZW0sIHByZXZlbnQgc2NyZWVuIHNsaWRlciBvbiB0aGUgYnV0dG9uLlxuICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBvbmRyYWdzdGFydDogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgb25kcmFnZW5kOiBiaW5kKHRoaXMuX29uRHJhZ0VuZCwgdGhpcyksXG4gICAgICBvbm1vdXNlb3ZlcjogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgb25tb3VzZW91dDogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIGZhbHNlKSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGZpbGw6IGRhdGFab29tTW9kZWwuZ2V0KCdmaWxsZXJDb2xvcicpLFxuICAgICAgICB0ZXh0UG9zaXRpb246ICdpbnNpZGUnXG4gICAgICB9XG4gICAgfSkpOyAvLyBGcmFtZSBib3JkZXIuXG5cbiAgICBiYXJHcm91cC5hZGQobmV3IFJlY3QoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdCh7XG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgc3Ryb2tlOiBkYXRhWm9vbU1vZGVsLmdldCgnZGF0YUJhY2tncm91bmRDb2xvcicpIHx8IGRhdGFab29tTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpLFxuICAgICAgICBsaW5lV2lkdGg6IERFRkFVTFRfRlJBTUVfQk9SREVSX1dJRFRILFxuICAgICAgICBmaWxsOiAncmdiYSgwLDAsMCwwKSdcbiAgICAgIH1cbiAgICB9KSkpO1xuICAgIGVhY2goWzAsIDFdLCBmdW5jdGlvbiAoaGFuZGxlSW5kZXgpIHtcbiAgICAgIHZhciBwYXRoID0gZ3JhcGhpYy5jcmVhdGVJY29uKGRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVJY29uJyksIHtcbiAgICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpcy5fb3JpZW50KSxcbiAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICBkcmlmdDogYmluZCh0aGlzLl9vbkRyYWdNb3ZlLCB0aGlzLCBoYW5kbGVJbmRleCksXG4gICAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIEZvdCBtb2JpbGUgZGV2aWNlbSwgcHJldmVudCBzY3JlZW4gc2xpZGVyIG9uIHRoZSBidXR0b24uXG4gICAgICAgICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZHJhZ2VuZDogYmluZCh0aGlzLl9vbkRyYWdFbmQsIHRoaXMpLFxuICAgICAgICBvbm1vdXNlb3ZlcjogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgICBvbm1vdXNlb3V0OiBiaW5kKHRoaXMuX3Nob3dEYXRhSW5mbywgdGhpcywgZmFsc2UpXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMixcbiAgICAgICAgaGVpZ2h0OiAyXG4gICAgICB9KTtcbiAgICAgIHZhciBiUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICB0aGlzLl9oYW5kbGVIZWlnaHQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChkYXRhWm9vbU1vZGVsLmdldCgnaGFuZGxlU2l6ZScpLCB0aGlzLl9zaXplWzFdKTtcbiAgICAgIHRoaXMuX2hhbmRsZVdpZHRoID0gYlJlY3Qud2lkdGggLyBiUmVjdC5oZWlnaHQgKiB0aGlzLl9oYW5kbGVIZWlnaHQ7XG4gICAgICBwYXRoLnNldFN0eWxlKGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2hhbmRsZVN0eWxlJykuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgdmFyIGhhbmRsZUNvbG9yID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2hhbmRsZUNvbG9yJyk7IC8vIENvbXBhdGl0YWJsZSB3aXRoIHByZXZpb3VzIHZlcnNpb25cblxuICAgICAgaWYgKGhhbmRsZUNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgcGF0aC5zdHlsZS5maWxsID0gaGFuZGxlQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGJhckdyb3VwLmFkZChoYW5kbGVzW2hhbmRsZUluZGV4XSA9IHBhdGgpO1xuICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gZGF0YVpvb21Nb2RlbC50ZXh0U3R5bGVNb2RlbDtcbiAgICAgIHRoaXMuZ3JvdXAuYWRkKGhhbmRsZUxhYmVsc1toYW5kbGVJbmRleF0gPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICBpbnZpc2libGU6IHRydWUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpXG4gICAgICAgIH0sXG4gICAgICAgIHoyOiAxMFxuICAgICAgfSkpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0SW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZSA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXRQZXJjZW50UmFuZ2UoKTtcblxuICAgIHZhciB2aWV3RXh0ZW50ID0gdGhpcy5fZ2V0Vmlld0V4dGVudCgpO1xuXG4gICAgdGhpcy5faGFuZGxlRW5kcyA9IFtsaW5lYXJNYXAocmFuZ2VbMF0sIFswLCAxMDBdLCB2aWV3RXh0ZW50LCB0cnVlKSwgbGluZWFyTWFwKHJhbmdlWzFdLCBbMCwgMTAwXSwgdmlld0V4dGVudCwgdHJ1ZSldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gaGFuZGxlSW5kZXggMCBvciAxIG9yICdhbGwnXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBjaGFuZ2VkXG4gICAqL1xuICBfdXBkYXRlSW50ZXJ2YWw6IGZ1bmN0aW9uIChoYW5kbGVJbmRleCwgZGVsdGEpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgaGFuZGxlRW5kcyA9IHRoaXMuX2hhbmRsZUVuZHM7XG5cbiAgICB2YXIgdmlld0V4dGVuZCA9IHRoaXMuX2dldFZpZXdFeHRlbnQoKTtcblxuICAgIHZhciBtaW5NYXhTcGFuID0gZGF0YVpvb21Nb2RlbC5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoKS5nZXRNaW5NYXhTcGFuKCk7XG4gICAgdmFyIHBlcmNlbnRFeHRlbnQgPSBbMCwgMTAwXTtcbiAgICBzbGlkZXJNb3ZlKGRlbHRhLCBoYW5kbGVFbmRzLCB2aWV3RXh0ZW5kLCBkYXRhWm9vbU1vZGVsLmdldCgnem9vbUxvY2snKSA/ICdhbGwnIDogaGFuZGxlSW5kZXgsIG1pbk1heFNwYW4ubWluU3BhbiAhPSBudWxsID8gbGluZWFyTWFwKG1pbk1heFNwYW4ubWluU3BhbiwgcGVyY2VudEV4dGVudCwgdmlld0V4dGVuZCwgdHJ1ZSkgOiBudWxsLCBtaW5NYXhTcGFuLm1heFNwYW4gIT0gbnVsbCA/IGxpbmVhck1hcChtaW5NYXhTcGFuLm1heFNwYW4sIHBlcmNlbnRFeHRlbnQsIHZpZXdFeHRlbmQsIHRydWUpIDogbnVsbCk7XG4gICAgdmFyIGxhc3RSYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlID0gYXNjKFtsaW5lYXJNYXAoaGFuZGxlRW5kc1swXSwgdmlld0V4dGVuZCwgcGVyY2VudEV4dGVudCwgdHJ1ZSksIGxpbmVhck1hcChoYW5kbGVFbmRzWzFdLCB2aWV3RXh0ZW5kLCBwZXJjZW50RXh0ZW50LCB0cnVlKV0pO1xuICAgIHJldHVybiAhbGFzdFJhbmdlIHx8IGxhc3RSYW5nZVswXSAhPT0gcmFuZ2VbMF0gfHwgbGFzdFJhbmdlWzFdICE9PSByYW5nZVsxXTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVWaWV3OiBmdW5jdGlvbiAobm9uUmVhbHRpbWUpIHtcbiAgICB2YXIgZGlzcGxheWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIHZhciBoYW5kbGVJbnRlcnZhbCA9IGFzYyhoYW5kbGVFbmRzLnNsaWNlKCkpO1xuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGhhbmRsZUluZGV4KSB7XG4gICAgICAvLyBIYW5kbGVzXG4gICAgICB2YXIgaGFuZGxlID0gZGlzcGxheWJsZXMuaGFuZGxlc1toYW5kbGVJbmRleF07XG4gICAgICB2YXIgaGFuZGxlSGVpZ2h0ID0gdGhpcy5faGFuZGxlSGVpZ2h0O1xuICAgICAgaGFuZGxlLmF0dHIoe1xuICAgICAgICBzY2FsZTogW2hhbmRsZUhlaWdodCAvIDIsIGhhbmRsZUhlaWdodCAvIDJdLFxuICAgICAgICBwb3NpdGlvbjogW2hhbmRsZUVuZHNbaGFuZGxlSW5kZXhdLCBzaXplWzFdIC8gMiAtIGhhbmRsZUhlaWdodCAvIDJdXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTsgLy8gRmlsbGVyXG5cbiAgICBkaXNwbGF5Ymxlcy5maWxsZXIuc2V0U2hhcGUoe1xuICAgICAgeDogaGFuZGxlSW50ZXJ2YWxbMF0sXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGhhbmRsZUludGVydmFsWzFdIC0gaGFuZGxlSW50ZXJ2YWxbMF0sXG4gICAgICBoZWlnaHQ6IHNpemVbMV1cbiAgICB9KTtcblxuICAgIHRoaXMuX3VwZGF0ZURhdGFJbmZvKG5vblJlYWx0aW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVEYXRhSW5mbzogZnVuY3Rpb24gKG5vblJlYWx0aW1lKSB7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGRpc3BsYXlibGVzID0gdGhpcy5fZGlzcGxheWFibGVzO1xuICAgIHZhciBoYW5kbGVMYWJlbHMgPSBkaXNwbGF5Ymxlcy5oYW5kbGVMYWJlbHM7XG4gICAgdmFyIG9yaWVudCA9IHRoaXMuX29yaWVudDtcbiAgICB2YXIgbGFiZWxUZXh0cyA9IFsnJywgJyddOyAvLyBGSVhNRVxuICAgIC8vIGRhdGXlnovvvIzmlK/mjIFmb3JtYXR0ZXLvvIxhdXRvZm9ybWF0dGVy77yIZWMyIGRhdGUuZ2V0QXV0b0Zvcm1hdHRlcu+8iVxuXG4gICAgaWYgKGRhdGFab29tTW9kZWwuZ2V0KCdzaG93RGV0YWlsJykpIHtcbiAgICAgIHZhciBheGlzUHJveHkgPSBkYXRhWm9vbU1vZGVsLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuXG4gICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgIHZhciBheGlzID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpLmF4aXM7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgICAgICB2YXIgZGF0YUludGVydmFsID0gbm9uUmVhbHRpbWUgLy8gU2VlICM0NDM0LCBkYXRhIGFuZCBheGlzIGFyZSBub3QgcHJvY2Vzc2VkIGFuZCByZXNldCB5ZXQgaW4gbm9uLXJlYWx0aW1lIG1vZGUuXG4gICAgICAgID8gYXhpc1Byb3h5LmNhbGN1bGF0ZURhdGFXaW5kb3coe1xuICAgICAgICAgIHN0YXJ0OiByYW5nZVswXSxcbiAgICAgICAgICBlbmQ6IHJhbmdlWzFdXG4gICAgICAgIH0pLnZhbHVlV2luZG93IDogYXhpc1Byb3h5LmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgICAgICBsYWJlbFRleHRzID0gW3RoaXMuX2Zvcm1hdExhYmVsKGRhdGFJbnRlcnZhbFswXSwgYXhpcyksIHRoaXMuX2Zvcm1hdExhYmVsKGRhdGFJbnRlcnZhbFsxXSwgYXhpcyldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvcmRlcmVkSGFuZGxlRW5kcyA9IGFzYyh0aGlzLl9oYW5kbGVFbmRzLnNsaWNlKCkpO1xuICAgIHNldExhYmVsLmNhbGwodGhpcywgMCk7XG4gICAgc2V0TGFiZWwuY2FsbCh0aGlzLCAxKTtcblxuICAgIGZ1bmN0aW9uIHNldExhYmVsKGhhbmRsZUluZGV4KSB7XG4gICAgICAvLyBMYWJlbFxuICAgICAgLy8gVGV4dCBzaG91bGQgbm90IHRyYW5zZm9ybSBieSBiYXJHcm91cC5cbiAgICAgIC8vIElnbm9yZSBoYW5kbGVycyB0cmFuc2Zvcm1cbiAgICAgIHZhciBiYXJUcmFuc2Zvcm0gPSBncmFwaGljLmdldFRyYW5zZm9ybShkaXNwbGF5Ymxlcy5oYW5kbGVzW2hhbmRsZUluZGV4XS5wYXJlbnQsIHRoaXMuZ3JvdXApO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uKGhhbmRsZUluZGV4ID09PSAwID8gJ3JpZ2h0JyA6ICdsZWZ0JywgYmFyVHJhbnNmb3JtKTtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9oYW5kbGVXaWR0aCAvIDIgKyBMQUJFTF9HQVA7XG4gICAgICB2YXIgdGV4dFBvaW50ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybShbb3JkZXJlZEhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICsgKGhhbmRsZUluZGV4ID09PSAwID8gLW9mZnNldCA6IG9mZnNldCksIHRoaXMuX3NpemVbMV0gLyAyXSwgYmFyVHJhbnNmb3JtKTtcbiAgICAgIGhhbmRsZUxhYmVsc1toYW5kbGVJbmRleF0uc2V0U3R5bGUoe1xuICAgICAgICB4OiB0ZXh0UG9pbnRbMF0sXG4gICAgICAgIHk6IHRleHRQb2ludFsxXSxcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IG9yaWVudCA9PT0gSE9SSVpPTlRBTCA/ICdtaWRkbGUnIDogZGlyZWN0aW9uLFxuICAgICAgICB0ZXh0QWxpZ246IG9yaWVudCA9PT0gSE9SSVpPTlRBTCA/IGRpcmVjdGlvbiA6ICdjZW50ZXInLFxuICAgICAgICB0ZXh0OiBsYWJlbFRleHRzW2hhbmRsZUluZGV4XVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Zvcm1hdExhYmVsOiBmdW5jdGlvbiAodmFsdWUsIGF4aXMpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBkYXRhWm9vbU1vZGVsLmdldCgnbGFiZWxGb3JtYXR0ZXInKTtcbiAgICB2YXIgbGFiZWxQcmVjaXNpb24gPSBkYXRhWm9vbU1vZGVsLmdldCgnbGFiZWxQcmVjaXNpb24nKTtcblxuICAgIGlmIChsYWJlbFByZWNpc2lvbiA9PSBudWxsIHx8IGxhYmVsUHJlY2lzaW9uID09PSAnYXV0bycpIHtcbiAgICAgIGxhYmVsUHJlY2lzaW9uID0gYXhpcy5nZXRQaXhlbFByZWNpc2lvbigpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZVN0ciA9IHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpID8gJycgLy8gRklYTUUgR2x1ZSBjb2RlXG4gICAgOiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgfHwgYXhpcy50eXBlID09PSAndGltZScgPyBheGlzLnNjYWxlLmdldExhYmVsKE1hdGgucm91bmQodmFsdWUpKSAvLyBwYXJhbSBvZiB0b0ZpeGVkIHNob3VsZCBsZXNzIHRoZW4gMjAuXG4gICAgOiB2YWx1ZS50b0ZpeGVkKE1hdGgubWluKGxhYmVsUHJlY2lzaW9uLCAyMCkpO1xuICAgIHJldHVybiB6clV0aWwuaXNGdW5jdGlvbihsYWJlbEZvcm1hdHRlcikgPyBsYWJlbEZvcm1hdHRlcih2YWx1ZSwgdmFsdWVTdHIpIDogenJVdGlsLmlzU3RyaW5nKGxhYmVsRm9ybWF0dGVyKSA/IGxhYmVsRm9ybWF0dGVyLnJlcGxhY2UoJ3t2YWx1ZX0nLCB2YWx1ZVN0cikgOiB2YWx1ZVN0cjtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG93T3JIaWRlIHRydWU6IHNob3csIGZhbHNlOiBoaWRlXG4gICAqL1xuICBfc2hvd0RhdGFJbmZvOiBmdW5jdGlvbiAoc2hvd09ySGlkZSkge1xuICAgIC8vIEFsd2F5cyBzaG93IHdoZW4gZHJnZ2luZy5cbiAgICBzaG93T3JIaWRlID0gdGhpcy5fZHJhZ2dpbmcgfHwgc2hvd09ySGlkZTtcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gdGhpcy5fZGlzcGxheWFibGVzLmhhbmRsZUxhYmVscztcbiAgICBoYW5kbGVMYWJlbHNbMF0uYXR0cignaW52aXNpYmxlJywgIXNob3dPckhpZGUpO1xuICAgIGhhbmRsZUxhYmVsc1sxXS5hdHRyKCdpbnZpc2libGUnLCAhc2hvd09ySGlkZSk7XG4gIH0sXG4gIF9vbkRyYWdNb3ZlOiBmdW5jdGlvbiAoaGFuZGxlSW5kZXgsIGR4LCBkeSkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTsgLy8gVHJhbnNmb3JtIGR4LCBkeSB0byBiYXIgY29vcmRpbmF0aW9uLlxuXG4gICAgdmFyIGJhclRyYW5zZm9ybSA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgdmFyIHZlcnRleCA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW2R4LCBkeV0sIGJhclRyYW5zZm9ybSwgdHJ1ZSk7XG5cbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX3VwZGF0ZUludGVydmFsKGhhbmRsZUluZGV4LCB2ZXJ0ZXhbMF0pO1xuXG4gICAgdmFyIHJlYWx0aW1lID0gdGhpcy5kYXRhWm9vbU1vZGVsLmdldCgncmVhbHRpbWUnKTtcblxuICAgIHRoaXMuX3VwZGF0ZVZpZXcoIXJlYWx0aW1lKTsgLy8gQXZvaWQgZGlzcGF0Y2ggZGF0YVpvb20gcmVwZWF0bHkgYnV0IHJhbmdlIG5vdCBjaGFuZ2VkLFxuICAgIC8vIHdoaWNoIGNhdXNlIGJhZCB2aXN1YWwgZWZmZWN0IHdoZW4gcHJvZ3Jlc3NpdmUgZW5hYmxlZC5cblxuXG4gICAgY2hhbmdlZCAmJiByZWFsdGltZSAmJiB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oKTtcbiAgfSxcbiAgX29uRHJhZ0VuZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLl9zaG93RGF0YUluZm8oZmFsc2UpOyAvLyBXaGlsZSBpbiByZWFsdGltZSBtb2RlIGFuZCBzdHJlYW0gbW9kZSwgZGlzcGF0Y2ggYWN0aW9uIHdoZW5cbiAgICAvLyBkcmFnIGVuZCB3aWxsIGNhdXNlIHRoZSB3aG9sZSB2aWV3IHJlcmVuZGVyLCB3aGljaCBpcyB1bm5lY2Vzc2FyeS5cblxuXG4gICAgdmFyIHJlYWx0aW1lID0gdGhpcy5kYXRhWm9vbU1vZGVsLmdldCgncmVhbHRpbWUnKTtcbiAgICAhcmVhbHRpbWUgJiYgdGhpcy5fZGlzcGF0Y2hab29tQWN0aW9uKCk7XG4gIH0sXG4gIF9vbkNsaWNrUGFuZWxDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cbiAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xuXG4gICAgaWYgKGxvY2FsUG9pbnRbMF0gPCAwIHx8IGxvY2FsUG9pbnRbMF0gPiBzaXplWzBdIHx8IGxvY2FsUG9pbnRbMV0gPCAwIHx8IGxvY2FsUG9pbnRbMV0gPiBzaXplWzFdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIHZhciBjZW50ZXIgPSAoaGFuZGxlRW5kc1swXSArIGhhbmRsZUVuZHNbMV0pIC8gMjtcblxuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fdXBkYXRlSW50ZXJ2YWwoJ2FsbCcsIGxvY2FsUG9pbnRbMF0gLSBjZW50ZXIpO1xuXG4gICAgdGhpcy5fdXBkYXRlVmlldygpO1xuXG4gICAgY2hhbmdlZCAmJiB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBhY3Rpb24gd2lsbCBiZSB0aHJvdHRsZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGlzcGF0Y2hab29tQWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2U7XG4gICAgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2RhdGFab29tJyxcbiAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgZGF0YVpvb21JZDogdGhpcy5kYXRhWm9vbU1vZGVsLmlkLFxuICAgICAgc3RhcnQ6IHJhbmdlWzBdLFxuICAgICAgZW5kOiByYW5nZVsxXVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZpbmRDb29yZFJlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBGaW5kIHRoZSBncmlkIGNvcmVzcG9uZGluZyB0byB0aGUgZmlyc3QgYXhpcyByZWZlcnJlZCBieSBkYXRhWm9vbS5cbiAgICB2YXIgcmVjdDtcbiAgICBlYWNoKHRoaXMuZ2V0VGFyZ2V0Q29vcmRJbmZvKCksIGZ1bmN0aW9uIChjb29yZEluZm9MaXN0KSB7XG4gICAgICBpZiAoIXJlY3QgJiYgY29vcmRJbmZvTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNvb3JkU3lzID0gY29vcmRJbmZvTGlzdFswXS5tb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICByZWN0ID0gY29vcmRTeXMuZ2V0UmVjdCAmJiBjb29yZFN5cy5nZXRSZWN0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuYXBpLmdldFdpZHRoKCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5hcGkuZ2V0SGVpZ2h0KCk7XG4gICAgICByZWN0ID0ge1xuICAgICAgICB4OiB3aWR0aCAqIDAuMixcbiAgICAgICAgeTogaGVpZ2h0ICogMC4yLFxuICAgICAgICB3aWR0aDogd2lkdGggKiAwLjYsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICogMC42XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiByZWN0O1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0T3RoZXJEaW0odGhpc0RpbSkge1xuICAvLyBGSVhNRVxuICAvLyDov5nkuKrpgLvovpHlkoxnZXRPdGhlckF4aXPph4zkuIDoh7TvvIzkvYbmmK/lhpnlnKjov5nph4zmmK/lkKbkuI3lpb1cbiAgdmFyIG1hcCA9IHtcbiAgICB4OiAneScsXG4gICAgeTogJ3gnLFxuICAgIHJhZGl1czogJ2FuZ2xlJyxcbiAgICBhbmdsZTogJ3JhZGl1cydcbiAgfTtcbiAgcmV0dXJuIG1hcFt0aGlzRGltXTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3Vyc29yKG9yaWVudCkge1xuICByZXR1cm4gb3JpZW50ID09PSAndmVydGljYWwnID8gJ25zLXJlc2l6ZScgOiAnZXctcmVzaXplJztcbn1cblxudmFyIF9kZWZhdWx0ID0gU2xpZGVyWm9vbVZpZXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NsaWRlclpvb21WaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBoZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oJ2RhdGFab29tJywgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgdmFyIGxpbmtlZE5vZGVzRmluZGVyID0gaGVscGVyLmNyZWF0ZUxpbmtlZE5vZGVzRmluZGVyKHpyVXRpbC5iaW5kKGVjTW9kZWwuZWFjaENvbXBvbmVudCwgZWNNb2RlbCwgJ2RhdGFab29tJyksIGhlbHBlci5lYWNoQXhpc0RpbSwgZnVuY3Rpb24gKG1vZGVsLCBkaW1OYW1lcykge1xuICAgIHJldHVybiBtb2RlbC5nZXQoZGltTmFtZXMuYXhpc0luZGV4KTtcbiAgfSk7XG4gIHZhciBlZmZlY3RlZE1vZGVscyA9IFtdO1xuICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgIG1haW5UeXBlOiAnZGF0YVpvb20nLFxuICAgIHF1ZXJ5OiBwYXlsb2FkXG4gIH0sIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHtcbiAgICBlZmZlY3RlZE1vZGVscy5wdXNoLmFwcGx5KGVmZmVjdGVkTW9kZWxzLCBsaW5rZWROb2Rlc0ZpbmRlcihtb2RlbCkubm9kZXMpO1xuICB9KTtcbiAgenJVdGlsLmVhY2goZWZmZWN0ZWRNb2RlbHMsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsLCBpbmRleCkge1xuICAgIGRhdGFab29tTW9kZWwuc2V0UmF3UmFuZ2Uoe1xuICAgICAgc3RhcnQ6IHBheWxvYWQuc3RhcnQsXG4gICAgICBlbmQ6IHBheWxvYWQuZW5kLFxuICAgICAgc3RhcnRWYWx1ZTogcGF5bG9hZC5zdGFydFZhbHVlLFxuICAgICAgZW5kVmFsdWU6IHBheWxvYWQuZW5kVmFsdWVcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vZGF0YVpvb21BY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbUFjdGlvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBjcmVhdGVIYXNoTWFwID0gX3V0aWwuY3JlYXRlSGFzaE1hcDtcbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3Nvcih7XG4gIC8vIGBkYXRhWm9vbVByb2Nlc3NvcmAgd2lsbCBvbmx5IGJlIHBlcmZvcm1lZCBpbiBuZWVkZWQgc2VyaWVzLiBDb25zaWRlciBpZlxuICAvLyB0aGVyZSBpcyBhIGxpbmUgc2VyaWVzIGFuZCBhIHBpZSBzZXJpZXMsIGl0IGlzIGJldHRlciBub3QgdG8gdXBkYXRlIHRoZVxuICAvLyBsaW5lIHNlcmllcyBpZiBvbmx5IHBpZSBzZXJpZXMgaXMgbmVlZGVkIHRvIGJlIHVwZGF0ZWQuXG4gIGdldFRhcmdldFNlcmllczogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgc2VyaWVzTW9kZWxNYXAgPSBjcmVhdGVIYXNoTWFwKCk7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdkYXRhWm9vbScsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgIHZhciBheGlzUHJveHkgPSBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShkaW1OYW1lcy5uYW1lLCBheGlzSW5kZXgpO1xuICAgICAgICBlYWNoKGF4aXNQcm94eS5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgc2VyaWVzTW9kZWxNYXAuc2V0KHNlcmllc01vZGVsLnVpZCwgc2VyaWVzTW9kZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZXJpZXNNb2RlbE1hcDtcbiAgfSxcbiAgbW9kaWZ5T3V0cHV0RW5kOiB0cnVlLFxuICAvLyBDb25zaWRlciBhcHBlbmREYXRhLCB3aGVyZSBmaWx0ZXIgc2hvdWxkIGJlIHBlcmZvcm1lZC4gQmVjYXVzZSBkYXRhIHByb2Nlc3MgaXNcbiAgLy8gaW4gYmxvY2sgbW9kZSBjdXJyZW50bHksIGl0IGlzIG5vdCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQgdGhlIG92ZXJhbGxQcm9ncmVzc1xuICAvLyBleGVjdXRlIGV2ZXJ5IGZyYW1lLlxuICBvdmVyYWxsUmVzZXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2RhdGFab29tJywgZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgIC8vIFdlIGNhbGN1bGF0ZSB3aW5kb3cgYW5kIHJlc2V0IGF4aXMgaGVyZSBidXQgbm90IGluIG1vZGVsXG4gICAgICAvLyBpbml0IHN0YWdlIGFuZCBub3QgYWZ0ZXIgYWN0aW9uIGRpc3BhdGNoIGhhbmRsZXIsIGJlY2F1c2VcbiAgICAgIC8vIHJlc2V0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc2VyaWVzRGF0YS5yZXN0b3JlRGF0YS5cbiAgICAgIGRhdGFab29tTW9kZWwuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGRpbU5hbWVzLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgZGF0YVpvb21Nb2RlbC5nZXRBeGlzUHJveHkoZGltTmFtZXMubmFtZSwgYXhpc0luZGV4KS5yZXNldChkYXRhWm9vbU1vZGVsLCBhcGkpO1xuICAgICAgfSk7IC8vIENhdXRpb246IGRhdGEgem9vbSBmaWx0ZXJpbmcgaXMgb3JkZXIgc2Vuc2l0aXZlIHdoZW4gdXNpbmdcbiAgICAgIC8vIHBlcmNlbnQgcmFuZ2UgYW5kIG5vIG1pbi9tYXgvc2NhbGUgc2V0IG9uIGF4aXMuXG4gICAgICAvLyBGb3IgZXhhbXBsZSwgd2UgaGF2ZSBkYXRhWm9vbSBkZWZpbml0aW9uOlxuICAgICAgLy8gW1xuICAgICAgLy8gICAgICB7eEF4aXNJbmRleDogMCwgc3RhcnQ6IDMwLCBlbmQ6IDcwfSxcbiAgICAgIC8vICAgICAge3lBeGlzSW5kZXg6IDAsIHN0YXJ0OiAyMCwgZW5kOiA4MH1cbiAgICAgIC8vIF1cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgWzIwLCA4MF0gb2YgeS1kYXRhWm9vbSBzaG91bGQgYmUgYmFzZWQgb24gZGF0YVxuICAgICAgLy8gdGhhdCBoYXZlIGZpbHRlcmVkIGJ5IHgtZGF0YVpvb20gdXNpbmcgcmFuZ2Ugb2YgWzMwLCA3MF0sXG4gICAgICAvLyBidXQgc2hvdWxkIG5vdCBiZSBiYXNlZCBvbiBmdWxsIHJhdyBkYXRhLiBUaHVzIHNsaWRpbmdcbiAgICAgIC8vIHgtZGF0YVpvb20gd2lsbCBjaGFuZ2UgYm90aCByYW5nZXMgb2YgeEF4aXMgYW5kIHlBeGlzLFxuICAgICAgLy8gd2hpbGUgc2xpZGluZyB5LWRhdGFab29tIHdpbGwgb25seSBjaGFuZ2UgdGhlIHJhbmdlIG9mIHlBeGlzLlxuICAgICAgLy8gU28gd2Ugc2hvdWxkIGZpbHRlciB4LWF4aXMgYWZ0ZXIgcmVzZXQgeC1heGlzIGltbWVkaWF0ZWx5LFxuICAgICAgLy8gYW5kIHRoZW4gcmVzZXQgeS1heGlzIGFuZCBmaWx0ZXIgeS1heGlzLlxuXG4gICAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgIGRhdGFab29tTW9kZWwuZ2V0QXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCkuZmlsdGVyRGF0YShkYXRhWm9vbU1vZGVsLCBhcGkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdkYXRhWm9vbScsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAvLyBGdWxsZmlsbCBhbGwgb2YgdGhlIHJhbmdlIHByb3BzIHNvIHRoYXQgdXNlclxuICAgICAgLy8gaXMgYWJsZSB0byBnZXQgdGhlbSBmcm9tIGNoYXJ0LmdldE9wdGlvbigpLlxuICAgICAgdmFyIGF4aXNQcm94eSA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG4gICAgICB2YXIgcGVyY2VudFJhbmdlID0gYXhpc1Byb3h5LmdldERhdGFQZXJjZW50V2luZG93KCk7XG4gICAgICB2YXIgdmFsdWVSYW5nZSA9IGF4aXNQcm94eS5nZXREYXRhVmFsdWVXaW5kb3coKTtcbiAgICAgIGRhdGFab29tTW9kZWwuc2V0UmF3UmFuZ2Uoe1xuICAgICAgICBzdGFydDogcGVyY2VudFJhbmdlWzBdLFxuICAgICAgICBlbmQ6IHBlcmNlbnRSYW5nZVsxXSxcbiAgICAgICAgc3RhcnRWYWx1ZTogdmFsdWVSYW5nZVswXSxcbiAgICAgICAgZW5kVmFsdWU6IHZhbHVlUmFuZ2VbMV1cbiAgICAgIH0sIHRydWUpO1xuICAgIH0pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vZGF0YVpvb21Qcm9jZXNzb3IuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3Nvci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2Zvcm1hdFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIEFYSVNfRElNUyA9IFsneCcsICd5JywgJ3onLCAncmFkaXVzJywgJ2FuZ2xlJywgJ3NpbmdsZSddOyAvLyBTdXBwb3J0ZWQgY29vcmRzLlxuXG52YXIgQ09PUkRTID0gWydjYXJ0ZXNpYW4yZCcsICdwb2xhcicsICdzaW5nbGVBeGlzJ107XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZFR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNDb29yZFN1cHBvcnRlZChjb29yZFR5cGUpIHtcbiAgcmV0dXJuIHpyVXRpbC5pbmRleE9mKENPT1JEUywgY29vcmRUeXBlKSA+PSAwO1xufVxuLyoqXG4gKiBDcmVhdGUgXCJlYWNoXCIgbWV0aG9kIHRvIGl0ZXJhdGUgbmFtZXMuXG4gKlxuICogQHB1YmlsY1xuICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz59IG5hbWVzXG4gKiBAcGFyYW0gIHtBcnJheS48c3RyaW5nPj19IGF0dHJzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU5hbWVFYWNoKG5hbWVzLCBhdHRycykge1xuICBuYW1lcyA9IG5hbWVzLnNsaWNlKCk7XG4gIHZhciBjYXBpdGFsTmFtZXMgPSB6clV0aWwubWFwKG5hbWVzLCBmb3JtYXRVdGlsLmNhcGl0YWxGaXJzdCk7XG4gIGF0dHJzID0gKGF0dHJzIHx8IFtdKS5zbGljZSgpO1xuICB2YXIgY2FwaXRhbEF0dHJzID0genJVdGlsLm1hcChhdHRycywgZm9ybWF0VXRpbC5jYXBpdGFsRmlyc3QpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgenJVdGlsLmVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICAgICAgdmFyIG5hbWVPYmogPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGNhcGl0YWw6IGNhcGl0YWxOYW1lc1tpbmRleF1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0cnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbmFtZU9ialthdHRyc1tqXV0gPSBuYW1lICsgY2FwaXRhbEF0dHJzW2pdO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG5hbWVPYmopO1xuICAgIH0pO1xuICB9O1xufVxuLyoqXG4gKiBJdGVyYXRlIGVhY2ggZGltZW5zaW9uIG5hbWUuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIHBhcmFtZXRlciBpcyBsaWtlOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbmdsZScsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwaXRhbDogJ0FuZ2xlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzOiAnYW5nbGVBeGlzJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzSW5kZXg6ICdhbmdsZUFpeHMnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAnYW5nbGVJbmRleCdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cblxuXG52YXIgZWFjaEF4aXNEaW0gPSBjcmVhdGVOYW1lRWFjaChBWElTX0RJTVMsIFsnYXhpc0luZGV4JywgJ2F4aXMnLCAnaW5kZXgnLCAnaWQnXSk7XG4vKipcbiAqIElmIHRvdyBkYXRhWm9vbU1vZGVscyBoYXMgdGhlIHNhbWUgYXhpcyBjb250cm9sbGVkLCB3ZSBzYXkgdGhhdCB0aGV5IGFyZSAnbGlua2VkJy5cbiAqIGRhdGFab29tTW9kZWxzIGFuZCAnbGlua3MnIG1ha2UgdXAgb25lIG9yIG1vcmUgZ3JhcGhpY3MuXG4gKiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBncmFwaGljIHdoZXJlIHRoZSBzb3VyY2UgZGF0YVpvb21Nb2RlbCBpcyBpbi5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmb3JFYWNoTm9kZSBOb2RlIGl0ZXJhdG9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm9yRWFjaEVkZ2VUeXBlIGVkZ2VUeXBlIGl0ZXJhdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlZGdlSWRHZXR0ZXIgR2l2aW5nIG5vZGUgYW5kIGVkZ2VUeXBlLCByZXR1cm4gYW4gYXJyYXkgb2YgZWRnZSBpZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBJbnB1dDogc291cmNlTm9kZSwgT3V0cHV0OiBMaWtlIHtub2RlczogW10sIGRpbXM6IHt9fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtlZE5vZGVzRmluZGVyKGZvckVhY2hOb2RlLCBmb3JFYWNoRWRnZVR5cGUsIGVkZ2VJZEdldHRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZU5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgbm9kZXM6IFtdLFxuICAgICAgcmVjb3Jkczoge30gLy8ga2V5OiBlZGdlVHlwZS5uYW1lLCB2YWx1ZTogT2JqZWN0IChrZXk6IGVkZ2UgaWQsIHZhbHVlOiBib29sZWFuKS5cblxuICAgIH07XG4gICAgZm9yRWFjaEVkZ2VUeXBlKGZ1bmN0aW9uIChlZGdlVHlwZSkge1xuICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV0gPSB7fTtcbiAgICB9KTtcblxuICAgIGlmICghc291cmNlTm9kZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhYnNvcmIoc291cmNlTm9kZSwgcmVzdWx0KTtcbiAgICB2YXIgZXhpc3RzTGluaztcblxuICAgIGRvIHtcbiAgICAgIGV4aXN0c0xpbmsgPSBmYWxzZTtcbiAgICAgIGZvckVhY2hOb2RlKHByb2Nlc3NTaW5nbGVOb2RlKTtcbiAgICB9IHdoaWxlIChleGlzdHNMaW5rKTtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTaW5nbGVOb2RlKG5vZGUpIHtcbiAgICAgIGlmICghaXNOb2RlQWJzb3JkZWQobm9kZSwgcmVzdWx0KSAmJiBpc0xpbmtlZChub2RlLCByZXN1bHQpKSB7XG4gICAgICAgIGFic29yYihub2RlLCByZXN1bHQpO1xuICAgICAgICBleGlzdHNMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzTm9kZUFic29yZGVkKG5vZGUsIHJlc3VsdCkge1xuICAgIHJldHVybiB6clV0aWwuaW5kZXhPZihyZXN1bHQubm9kZXMsIG5vZGUpID49IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xpbmtlZChub2RlLCByZXN1bHQpIHtcbiAgICB2YXIgaGFzTGluayA9IGZhbHNlO1xuICAgIGZvckVhY2hFZGdlVHlwZShmdW5jdGlvbiAoZWRnZVR5cGUpIHtcbiAgICAgIHpyVXRpbC5lYWNoKGVkZ2VJZEdldHRlcihub2RlLCBlZGdlVHlwZSkgfHwgW10sIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV1bZWRnZUlkXSAmJiAoaGFzTGluayA9IHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhhc0xpbms7XG4gIH1cblxuICBmdW5jdGlvbiBhYnNvcmIobm9kZSwgcmVzdWx0KSB7XG4gICAgcmVzdWx0Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgZm9yRWFjaEVkZ2VUeXBlKGZ1bmN0aW9uIChlZGdlVHlwZSkge1xuICAgICAgenJVdGlsLmVhY2goZWRnZUlkR2V0dGVyKG5vZGUsIGVkZ2VUeXBlKSB8fCBbXSwgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICByZXN1bHQucmVjb3Jkc1tlZGdlVHlwZS5uYW1lXVtlZGdlSWRdID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydHMuaXNDb29yZFN1cHBvcnRlZCA9IGlzQ29vcmRTdXBwb3J0ZWQ7XG5leHBvcnRzLmNyZWF0ZU5hbWVFYWNoID0gY3JlYXRlTmFtZUVhY2g7XG5leHBvcnRzLmVhY2hBeGlzRGltID0gZWFjaEF4aXNEaW07XG5leHBvcnRzLmNyZWF0ZUxpbmtlZE5vZGVzRmluZGVyID0gY3JlYXRlTGlua2VkTm9kZXNGaW5kZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2hlbHBlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIEFUVFIgPSAnXFwwX2VjX2hpc3Rfc3RvcmUnO1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHBhcmFtIHtPYmplY3R9IG5ld1NuYXBzaG90IHtkYXRhWm9vbUlkLCBiYXRjaDogW3BheWxvYWRJbmZvLCAuLi5dfVxuICovXG5cbmZ1bmN0aW9uIHB1c2goZWNNb2RlbCwgbmV3U25hcHNob3QpIHtcbiAgdmFyIHN0b3JlID0gZ2l2ZVN0b3JlKGVjTW9kZWwpOyAvLyBJZiBwcmV2aW91cyBkYXRhWm9vbSBjYW4gbm90IGJlIGZvdW5kLFxuICAvLyBjb21wbGV0ZSBhbiByYW5nZSB3aXRoIGN1cnJlbnQgcmFuZ2UuXG5cbiAgZWFjaChuZXdTbmFwc2hvdCwgZnVuY3Rpb24gKGJhdGNoSXRlbSwgZGF0YVpvb21JZCkge1xuICAgIHZhciBpID0gc3RvcmUubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHNuYXBzaG90ID0gc3RvcmVbaV07XG5cbiAgICAgIGlmIChzbmFwc2hvdFtkYXRhWm9vbUlkXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIC8vIE5vIG9yaWdpbiByYW5nZSBzZXQsIGNyZWF0ZSBvbmUgYnkgY3VycmVudCByYW5nZS5cbiAgICAgIHZhciBkYXRhWm9vbU1vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICBtYWluVHlwZTogJ2RhdGFab29tJyxcbiAgICAgICAgc3ViVHlwZTogJ3NlbGVjdCcsXG4gICAgICAgIGlkOiBkYXRhWm9vbUlkXG4gICAgICB9KVswXTtcblxuICAgICAgaWYgKGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgdmFyIHBlcmNlbnRSYW5nZSA9IGRhdGFab29tTW9kZWwuZ2V0UGVyY2VudFJhbmdlKCk7XG4gICAgICAgIHN0b3JlWzBdW2RhdGFab29tSWRdID0ge1xuICAgICAgICAgIGRhdGFab29tSWQ6IGRhdGFab29tSWQsXG4gICAgICAgICAgc3RhcnQ6IHBlcmNlbnRSYW5nZVswXSxcbiAgICAgICAgICBlbmQ6IHBlcmNlbnRSYW5nZVsxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHN0b3JlLnB1c2gobmV3U25hcHNob3QpO1xufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHJldHVybiB7T2JqZWN0fSBzbmFwc2hvdFxuICovXG5cblxuZnVuY3Rpb24gcG9wKGVjTW9kZWwpIHtcbiAgdmFyIHN0b3JlID0gZ2l2ZVN0b3JlKGVjTW9kZWwpO1xuICB2YXIgaGVhZCA9IHN0b3JlW3N0b3JlLmxlbmd0aCAtIDFdO1xuICBzdG9yZS5sZW5ndGggPiAxICYmIHN0b3JlLnBvcCgpOyAvLyBGaW5kIHRvcCBmb3IgYWxsIGRhdGFab29tLlxuXG4gIHZhciBzbmFwc2hvdCA9IHt9O1xuICBlYWNoKGhlYWQsIGZ1bmN0aW9uIChiYXRjaEl0ZW0sIGRhdGFab29tSWQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RvcmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBiYXRjaEl0ZW0gPSBzdG9yZVtpXVtkYXRhWm9vbUlkXTtcblxuICAgICAgaWYgKGJhdGNoSXRlbSkge1xuICAgICAgICBzbmFwc2hvdFtkYXRhWm9vbUlkXSA9IGJhdGNoSXRlbTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNuYXBzaG90O1xufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICovXG5cblxuZnVuY3Rpb24gY2xlYXIoZWNNb2RlbCkge1xuICBlY01vZGVsW0FUVFJdID0gbnVsbDtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEByZXR1cm4ge251bWJlcn0gcmVjb3Jkcy4gYWx3YXlzID49IDEuXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudChlY01vZGVsKSB7XG4gIHJldHVybiBnaXZlU3RvcmUoZWNNb2RlbCkubGVuZ3RoO1xufVxuLyoqXG4gKiBbe2tleTogZGF0YVpvb21JZCwgdmFsdWU6IHtkYXRhWm9vbUlkLCByYW5nZX19LCAuLi5dXG4gKiBIaXN0b3J5IGxlbmd0aCBvZiBlYWNoIGRhdGFab29tIG1heSBiZSBkaWZmZXJlbnQuXG4gKiB0aGlzLl9oaXN0b3J5WzBdIGlzIHVzZWQgdG8gc3RvcmUgb3JpZ2luIHJhbmdlLlxuICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICovXG5cblxuZnVuY3Rpb24gZ2l2ZVN0b3JlKGVjTW9kZWwpIHtcbiAgdmFyIHN0b3JlID0gZWNNb2RlbFtBVFRSXTtcblxuICBpZiAoIXN0b3JlKSB7XG4gICAgc3RvcmUgPSBlY01vZGVsW0FUVFJdID0gW3t9XTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZTtcbn1cblxuZXhwb3J0cy5wdXNoID0gcHVzaDtcbmV4cG9ydHMucG9wID0gcG9wO1xuZXhwb3J0cy5jbGVhciA9IGNsZWFyO1xuZXhwb3J0cy5jb3VudCA9IGNvdW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9oaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGlzdG9yeS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgUm9hbUNvbnRyb2xsZXIgPSByZXF1aXJlKFwiLi4vLi4vY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlclwiKTtcblxudmFyIHRocm90dGxlVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3Rocm90dGxlXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBPbmx5IGNyZWF0ZSBvbmUgcm9hbSBjb250cm9sbGVyIGZvciBlYWNoIGNvb3JkaW5hdGUgc3lzdGVtLlxuLy8gb25lIHJvYW0gY29udHJvbGxlciBtaWdodCBiZSByZWZlcmVkIGJ5IHR3byBpbnNpZGUgZGF0YSB6b29tXG4vLyBjb21wb25lbnRzIChmb3IgZXhhbXBsZSwgb25lIGZvciB4IGFuZCBvbmUgZm9yIHkpLiBXaGVuIHVzZXJcbi8vIHBhbiBvciB6b29tLCBvbmx5IGRpc3BhdGNoIG9uZSBhY3Rpb24gZm9yIHRob3NlIGRhdGEgem9vbVxuLy8gY29tcG9uZW50cy5cbnZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbnZhciBBVFRSID0gJ1xcMF9lY19kYXRhWm9vbV9yb2Ftcyc7XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhWm9vbUluZm9cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhWm9vbUluZm8uY29vcmRJZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YVpvb21JbmZvLmNvbnRhaW5zUG9pbnRcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGRhdGFab29tSW5mby5hbGxDb29yZElkc1xuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFab29tSW5mby5kYXRhWm9vbUlkXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0YVpvb21JbmZvLnRocm90dGxlUmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YVpvb21JbmZvLnBhbkdldFJhbmdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkYXRhWm9vbUluZm8uem9vbUdldFJhbmdlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXRhWm9vbUluZm8uem9vbUxvY2tdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXRhWm9vbUluZm8uZGlzYWJsZWRdXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXIoYXBpLCBkYXRhWm9vbUluZm8pIHtcbiAgdmFyIHN0b3JlID0gZ2l2ZVN0b3JlKGFwaSk7XG4gIHZhciB0aGVEYXRhWm9vbUlkID0gZGF0YVpvb21JbmZvLmRhdGFab29tSWQ7XG4gIHZhciB0aGVDb29yZElkID0gZGF0YVpvb21JbmZvLmNvb3JkSWQ7IC8vIERvIGNsZWFuIHdoZW4gYSBkYXRhWm9vbSBjaGFuZ2VzIGl0cyB0YXJnZXQgY29vcmRuYXRlIHN5c3RlbS5cbiAgLy8gQXZvaWQgbWVtb3J5IGxlYWssIGRpc3Bvc2UgYWxsIG5vdC11c2VkLXJlZ2lzdGVyZWQuXG5cbiAgenJVdGlsLmVhY2goc3RvcmUsIGZ1bmN0aW9uIChyZWNvcmQsIGNvb3JkSWQpIHtcbiAgICB2YXIgZGF0YVpvb21JbmZvcyA9IHJlY29yZC5kYXRhWm9vbUluZm9zO1xuXG4gICAgaWYgKGRhdGFab29tSW5mb3NbdGhlRGF0YVpvb21JZF0gJiYgenJVdGlsLmluZGV4T2YoZGF0YVpvb21JbmZvLmFsbENvb3JkSWRzLCB0aGVDb29yZElkKSA8IDApIHtcbiAgICAgIGRlbGV0ZSBkYXRhWm9vbUluZm9zW3RoZURhdGFab29tSWRdO1xuICAgICAgcmVjb3JkLmNvdW50LS07XG4gICAgfVxuICB9KTtcbiAgY2xlYW5TdG9yZShzdG9yZSk7XG4gIHZhciByZWNvcmQgPSBzdG9yZVt0aGVDb29yZElkXTsgLy8gQ3JlYXRlIGlmIG5lZWRlZC5cblxuICBpZiAoIXJlY29yZCkge1xuICAgIHJlY29yZCA9IHN0b3JlW3RoZUNvb3JkSWRdID0ge1xuICAgICAgY29vcmRJZDogdGhlQ29vcmRJZCxcbiAgICAgIGRhdGFab29tSW5mb3M6IHt9LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICAgIHJlY29yZC5jb250cm9sbGVyID0gY3JlYXRlQ29udHJvbGxlcihhcGksIHJlY29yZCk7XG4gICAgcmVjb3JkLmRpc3BhdGNoQWN0aW9uID0genJVdGlsLmN1cnJ5KGRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICB9IC8vIFVwZGF0ZSByZWZlcmVuY2Ugb2YgZGF0YVpvb20uXG5cblxuICAhcmVjb3JkLmRhdGFab29tSW5mb3NbdGhlRGF0YVpvb21JZF0gJiYgcmVjb3JkLmNvdW50Kys7XG4gIHJlY29yZC5kYXRhWm9vbUluZm9zW3RoZURhdGFab29tSWRdID0gZGF0YVpvb21JbmZvO1xuICB2YXIgY29udHJvbGxlclBhcmFtcyA9IG1lcmdlQ29udHJvbGxlclBhcmFtcyhyZWNvcmQuZGF0YVpvb21JbmZvcyk7XG4gIHJlY29yZC5jb250cm9sbGVyLmVuYWJsZShjb250cm9sbGVyUGFyYW1zLmNvbnRyb2xUeXBlLCBjb250cm9sbGVyUGFyYW1zLm9wdCk7IC8vIENvbnNpZGVyIHJlc2l6ZSwgYXJlYSBzaG91bGQgYmUgYWx3YXlzIHVwZGF0ZWQuXG5cbiAgcmVjb3JkLmNvbnRyb2xsZXIuc2V0UG9pbnRlckNoZWNrZXIoZGF0YVpvb21JbmZvLmNvbnRhaW5zUG9pbnQpOyAvLyBVcGRhdGUgdGhyb3R0bGUuXG5cbiAgdGhyb3R0bGVVdGlsLmNyZWF0ZU9yVXBkYXRlKHJlY29yZCwgJ2Rpc3BhdGNoQWN0aW9uJywgZGF0YVpvb21JbmZvLnRocm90dGxlUmF0ZSwgJ2ZpeFJhdGUnKTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFab29tSWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHVucmVnaXN0ZXIoYXBpLCBkYXRhWm9vbUlkKSB7XG4gIHZhciBzdG9yZSA9IGdpdmVTdG9yZShhcGkpO1xuICB6clV0aWwuZWFjaChzdG9yZSwgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgIHJlY29yZC5jb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgICB2YXIgZGF0YVpvb21JbmZvcyA9IHJlY29yZC5kYXRhWm9vbUluZm9zO1xuXG4gICAgaWYgKGRhdGFab29tSW5mb3NbZGF0YVpvb21JZF0pIHtcbiAgICAgIGRlbGV0ZSBkYXRhWm9vbUluZm9zW2RhdGFab29tSWRdO1xuICAgICAgcmVjb3JkLmNvdW50LS07XG4gICAgfVxuICB9KTtcbiAgY2xlYW5TdG9yZShzdG9yZSk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29vcmRJZChjb29yZE1vZGVsKSB7XG4gIHJldHVybiBjb29yZE1vZGVsLnR5cGUgKyAnXFwwXycgKyBjb29yZE1vZGVsLmlkO1xufVxuLyoqXG4gKiBLZXk6IGNvb3JkSWQsIHZhbHVlOiB7ZGF0YVpvb21JbmZvczogW10sIGNvdW50LCBjb250cm9sbGVyfVxuICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICovXG5cblxuZnVuY3Rpb24gZ2l2ZVN0b3JlKGFwaSkge1xuICAvLyBNb3VudCBzdG9yZSBvbiB6cmVuZGVyIGluc3RhbmNlLCBzbyB0aGF0IHdlIGRvIG5vdFxuICAvLyBuZWVkIHRvIHdvcnJ5IGFib3V0IGRpc3Bvc2UuXG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICByZXR1cm4genJbQVRUUl0gfHwgKHpyW0FUVFJdID0ge30pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250cm9sbGVyKGFwaSwgbmV3UmVjb3JkKSB7XG4gIHZhciBjb250cm9sbGVyID0gbmV3IFJvYW1Db250cm9sbGVyKGFwaS5nZXRacigpKTtcbiAgY29udHJvbGxlci5vbigncGFuJywgY3Vycnkob25QYW4sIG5ld1JlY29yZCkpO1xuICBjb250cm9sbGVyLm9uKCd6b29tJywgY3Vycnkob25ab29tLCBuZXdSZWNvcmQpKTtcbiAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG5cbmZ1bmN0aW9uIGNsZWFuU3RvcmUoc3RvcmUpIHtcbiAgenJVdGlsLmVhY2goc3RvcmUsIGZ1bmN0aW9uIChyZWNvcmQsIGNvb3JkSWQpIHtcbiAgICBpZiAoIXJlY29yZC5jb3VudCkge1xuICAgICAgcmVjb3JkLmNvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgICAgZGVsZXRlIHN0b3JlW2Nvb3JkSWRdO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUGFuKHJlY29yZCwgZHgsIGR5LCBvbGRYLCBvbGRZLCBuZXdYLCBuZXdZKSB7XG4gIHdyYXBBbmREaXNwYXRjaChyZWNvcmQsIGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ucGFuR2V0UmFuZ2UocmVjb3JkLmNvbnRyb2xsZXIsIGR4LCBkeSwgb2xkWCwgb2xkWSwgbmV3WCwgbmV3WSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblpvb20ocmVjb3JkLCBzY2FsZSwgbW91c2VYLCBtb3VzZVkpIHtcbiAgd3JhcEFuZERpc3BhdGNoKHJlY29yZCwgZnVuY3Rpb24gKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby56b29tR2V0UmFuZ2UocmVjb3JkLmNvbnRyb2xsZXIsIHNjYWxlLCBtb3VzZVgsIG1vdXNlWSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwQW5kRGlzcGF0Y2gocmVjb3JkLCBnZXRSYW5nZSkge1xuICB2YXIgYmF0Y2ggPSBbXTtcbiAgenJVdGlsLmVhY2gocmVjb3JkLmRhdGFab29tSW5mb3MsIGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgdmFyIHJhbmdlID0gZ2V0UmFuZ2UoaW5mbyk7XG4gICAgIWluZm8uZGlzYWJsZWQgJiYgcmFuZ2UgJiYgYmF0Y2gucHVzaCh7XG4gICAgICBkYXRhWm9vbUlkOiBpbmZvLmRhdGFab29tSWQsXG4gICAgICBzdGFydDogcmFuZ2VbMF0sXG4gICAgICBlbmQ6IHJhbmdlWzFdXG4gICAgfSk7XG4gIH0pO1xuICBiYXRjaC5sZW5ndGggJiYgcmVjb3JkLmRpc3BhdGNoQWN0aW9uKGJhdGNoKTtcbn1cbi8qKlxuICogVGhpcyBhY3Rpb24gd2lsbCBiZSB0aHJvdHRsZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihhcGksIGJhdGNoKSB7XG4gIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgdHlwZTogJ2RhdGFab29tJyxcbiAgICBiYXRjaDogYmF0Y2hcbiAgfSk7XG59XG4vKipcbiAqIE1lcmdlIHJvYW1Db250cm9sbGVyIHNldHRpbmdzIHdoZW4gbXVsdGlwbGUgZGF0YVpvb21zIHNoYXJlIG9uZSByb2FtQ29udHJvbGxlci5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlQ29udHJvbGxlclBhcmFtcyhkYXRhWm9vbUluZm9zKSB7XG4gIHZhciBjb250cm9sVHlwZTtcbiAgdmFyIG9wdCA9IHt9OyAvLyBETyBOT1QgdXNlIHJlc2VydmVkIHdvcmQgKHRydWUsIGZhbHNlLCB1bmRlZmluZWQpIGFzIGtleSBsaXRlcmFsbHkuIEV2ZW4gaWYgZW5jYXBzdWxhdGVkXG4gIC8vIGFzIHN0cmluZywgaXQgaXMgcHJvYmFibHkgcmV2ZXJ0IHRvIHJlc2VydmVkIHdvcmQgYnkgY29tcHJlc3MgdG9vbC4gU2VlICM3NDExLlxuXG4gIHZhciBwcmVmaXggPSAndHlwZV8nO1xuICB2YXIgdHlwZVByaW9yaXR5ID0ge1xuICAgICd0eXBlX3RydWUnOiAyLFxuICAgICd0eXBlX21vdmUnOiAxLFxuICAgICd0eXBlX2ZhbHNlJzogMCxcbiAgICAndHlwZV91bmRlZmluZWQnOiAtMVxuICB9O1xuICB6clV0aWwuZWFjaChkYXRhWm9vbUluZm9zLCBmdW5jdGlvbiAoZGF0YVpvb21JbmZvKSB7XG4gICAgdmFyIG9uZVR5cGUgPSBkYXRhWm9vbUluZm8uZGlzYWJsZWQgPyBmYWxzZSA6IGRhdGFab29tSW5mby56b29tTG9jayA/ICdtb3ZlJyA6IHRydWU7XG5cbiAgICBpZiAodHlwZVByaW9yaXR5W3ByZWZpeCArIG9uZVR5cGVdID4gdHlwZVByaW9yaXR5W3ByZWZpeCArIGNvbnRyb2xUeXBlXSkge1xuICAgICAgY29udHJvbFR5cGUgPSBvbmVUeXBlO1xuICAgIH0gLy8gRG8gbm90IHN1cHBvcnQgdGhhdCBkaWZmZXJlbnQgJ3NoaWZ0Jy8nY3RybCcvJ2FsdCcgc2V0dGluZyB1c2VkIGluIG9uZSBjb29yZCBzeXMuXG5cblxuICAgIHpyVXRpbC5leHRlbmQob3B0LCBkYXRhWm9vbUluZm8ucm9hbUNvbnRyb2xsZXJPcHQpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjb250cm9sVHlwZTogY29udHJvbFR5cGUsXG4gICAgb3B0OiBvcHRcbiAgfTtcbn1cblxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZXhwb3J0cy51bnJlZ2lzdGVyID0gdW5yZWdpc3RlcjtcbmV4cG9ydHMuZ2VuZXJhdGVDb29yZElkID0gZ2VuZXJhdGVDb29yZElkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9yb2Ftcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL3JvYW1zLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Db21wb25lbnRcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbkNvbXBvbmVudC5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoJ2RhdGFab29tJywgZnVuY3Rpb24gKCkge1xuICAvLyBEZWZhdWx0ICdzbGlkZXInIHdoZW4gbm8gdHlwZSBzcGVjaWZpZWQuXG4gIHJldHVybiAnc2xpZGVyJztcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS90eXBlRGVmYXVsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vdHlwZURlZmF1bHRlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInJlcXVpcmUoXCIuL2RhdGFab29tL3R5cGVEZWZhdWx0ZXJcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL0RhdGFab29tTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL0RhdGFab29tVmlld1wiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vU2VsZWN0Wm9vbU1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9TZWxlY3Rab29tVmlld1wiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vZGF0YVpvb21Qcm9jZXNzb3JcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL2RhdGFab29tQWN0aW9uXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbVNlbGVjdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tU2VsZWN0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZShcIi4uL21vZGVsL0NvbXBvbmVudFwiKTtcblxudmFyIENvbXBvbmVudFZpZXcgPSByZXF1aXJlKFwiLi4vdmlldy9Db21wb25lbnRcIik7XG5cbnZhciBfc291cmNlSGVscGVyID0gcmVxdWlyZShcIi4uL2RhdGEvaGVscGVyL3NvdXJjZUhlbHBlclwiKTtcblxudmFyIGRldGVjdFNvdXJjZUZvcm1hdCA9IF9zb3VyY2VIZWxwZXIuZGV0ZWN0U291cmNlRm9ybWF0O1xuXG52YXIgX3NvdXJjZVR5cGUgPSByZXF1aXJlKFwiLi4vZGF0YS9oZWxwZXIvc291cmNlVHlwZVwiKTtcblxudmFyIFNFUklFU19MQVlPVVRfQllfQ09MVU1OID0gX3NvdXJjZVR5cGUuU0VSSUVTX0xBWU9VVF9CWV9DT0xVTU47XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBpcyBpbXBvcnRlZCBieSBlY2hhcnRzIGRpcmVjdGx5LlxuICpcbiAqIE5vdGljZTpcbiAqIEFsd2F5cyBrZWVwIHRoaXMgZmlsZSBleGlzdHMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKiBCZWNhdXNlIGJlZm9yZSA0LjEuMCwgZGF0YXNldCBpcyBhbiBvcHRpb25hbCBjb21wb25lbnQsXG4gKiBzb21lIHVzZXJzIG1heSBpbXBvcnQgdGhpcyBtb2R1bGUgbWFudWFsbHkuXG4gKi9cbkNvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhc2V0JyxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIC8vICdyb3cnLCAnY29sdW1uJ1xuICAgIHNlcmllc0xheW91dEJ5OiBTRVJJRVNfTEFZT1VUX0JZX0NPTFVNTixcbiAgICAvLyBudWxsLydhdXRvJzogYXV0byBkZXRlY3QgaGVhZGVyLCBzZWUgXCJtb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9zb3VyY2VIZWxwZXJcIlxuICAgIHNvdXJjZUhlYWRlcjogbnVsbCxcbiAgICBkaW1lbnNpb25zOiBudWxsLFxuICAgIHNvdXJjZTogbnVsbFxuICB9LFxuICBvcHRpb25VcGRhdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgZGV0ZWN0U291cmNlRm9ybWF0KHRoaXMpO1xuICB9XG59KTtcbkNvbXBvbmVudFZpZXcuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFzZXQnXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YXNldC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFzZXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vdXRpbC9ncmFwaGljXCIpO1xuXG5yZXF1aXJlKFwiLi4vY29vcmQvY2FydGVzaWFuL0dyaWRcIik7XG5cbnJlcXVpcmUoXCIuL2F4aXNcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIEdyaWQgdmlld1xuZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ2dyaWQnLFxuICByZW5kZXI6IGZ1bmN0aW9uIChncmlkTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKGdyaWRNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgdGhpcy5ncm91cC5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgIHNoYXBlOiBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCksXG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIGZpbGw6IGdyaWRNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpXG4gICAgICAgIH0sIGdyaWRNb2RlbC5nZXRJdGVtU3R5bGUoKSksXG4gICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgejI6IC0xXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG59KTtcbmVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdGlvbikge1xuICAvLyBPbmx5IGNyZWF0ZSBncmlkIHdoZW4gbmVlZFxuICBpZiAob3B0aW9uLnhBeGlzICYmIG9wdGlvbi55QXhpcyAmJiAhb3B0aW9uLmdyaWQpIHtcbiAgICBvcHRpb24uZ3JpZCA9IHt9O1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZ3JpZFNpbXBsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyaWRTaW1wbGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBpbnRlcmFjdGlvbk11dGV4ID0gcmVxdWlyZShcIi4vaW50ZXJhY3Rpb25NdXRleFwiKTtcblxudmFyIERhdGFEaWZmZXIgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9EYXRhRGlmZmVyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIG1hcCA9IHpyVXRpbC5tYXA7XG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbnZhciBtYXRoUG93ID0gTWF0aC5wb3c7XG52YXIgQ09WRVJfWiA9IDEwMDAwO1xudmFyIFVOU0VMRUNUX1RIUkVTSE9MRCA9IDY7XG52YXIgTUlOX1JFU0laRV9MSU5FX1dJRFRIID0gNjtcbnZhciBNVVRFWF9SRVNPVVJDRV9LRVkgPSAnZ2xvYmFsUGFuJztcbnZhciBESVJFQ1RJT05fTUFQID0ge1xuICB3OiBbMCwgMF0sXG4gIGU6IFswLCAxXSxcbiAgbjogWzEsIDBdLFxuICBzOiBbMSwgMV1cbn07XG52YXIgQ1VSU09SX01BUCA9IHtcbiAgdzogJ2V3JyxcbiAgZTogJ2V3JyxcbiAgbjogJ25zJyxcbiAgczogJ25zJyxcbiAgbmU6ICduZXN3JyxcbiAgc3c6ICduZXN3JyxcbiAgbnc6ICdud3NlJyxcbiAgc2U6ICdud3NlJ1xufTtcbnZhciBERUZBVUxUX0JSVVNIX09QVCA9IHtcbiAgYnJ1c2hTdHlsZToge1xuICAgIGxpbmVXaWR0aDogMixcbiAgICBzdHJva2U6ICdyZ2JhKDAsMCwwLDAuMyknLFxuICAgIGZpbGw6ICdyZ2JhKDAsMCwwLDAuMSknXG4gIH0sXG4gIHRyYW5zZm9ybWFibGU6IHRydWUsXG4gIGJydXNoTW9kZTogJ3NpbmdsZScsXG4gIHJlbW92ZU9uQ2xpY2s6IGZhbHNlXG59O1xudmFyIGJhc2VVSUQgPSAwO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2hlbHBlci9CcnVzaENvbnRyb2xsZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQG1peGluIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAqIEBldmVudCBtb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlciNicnVzaFxuICogICAgICAgIHBhcmFtczpcbiAqICAgICAgICAgICAgYXJlYXM6IEFycmF5LjxBcnJheT4sIGNvb3JkIHJlbGF0ZXMgdG8gY29udGFpbmVyIGdyb3VwLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBubyBjb250YWluZXIgc3BlY2lmaWVkLCB0byBnbG9iYWwuXG4gKiAgICAgICAgICAgIG9wdCB7XG4gKiAgICAgICAgICAgICAgICBpc0VuZDogYm9vbGVhbixcbiAqICAgICAgICAgICAgICAgIHJlbW92ZU9uQ2xpY2s6IGJvb2xlYW5cbiAqICAgICAgICAgICAgfVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvenJlbmRlcn5aUmVuZGVyfSB6clxuICovXG5cbmZ1bmN0aW9uIEJydXNoQ29udHJvbGxlcih6cikge1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL3pyZW5kZXJ+WlJlbmRlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fenIgPSB6cjtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgLyoqXG4gICAqIE9ubHkgZm9yIGRyYXdpbmcgKGFmdGVyIGVuYWJsZWRCcnVzaCkuXG4gICAqICAgICAnbGluZScsICdyZWN0JywgJ3BvbHlnb24nIG9yIGZhbHNlXG4gICAqICAgICBJZiBwYXNzaW5nIGZhbHNlL251bGwvdW5kZWZpbmVkLCBkaXNhYmxlIGJydXNoLlxuICAgKiAgICAgSWYgcGFzc2luZyAnYXV0bycsIGRldGVybWluZWQgYnkgcGFuZWwuZGVmYXVsdEJydXNoVHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLl9icnVzaFR5cGU7XG4gIC8qKlxuICAgKiBPbmx5IGZvciBkcmF3aW5nIChhZnRlciBlbmFibGVkQnJ1c2gpLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9icnVzaE9wdGlvbjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX3BhbmVscztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVibWVyPn1cbiAgICovXG5cbiAgdGhpcy5fdHJhY2sgPSBbXTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuICB0aGlzLl9kcmFnZ2luZztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG5cbiAgdGhpcy5fY292ZXJzID0gW107XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW91ZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICovXG5cbiAgdGhpcy5fY3JlYXRpbmdDb3ZlcjtcbiAgLyoqXG4gICAqIGB0cnVlYCBtZWFucyBnbG9iYWwgcGFuZWxcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cHxib29sZWFufVxuICAgKi9cblxuICB0aGlzLl9jcmVhdGluZ1BhbmVsO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMuX2VuYWJsZUdsb2JhbFBhbjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuX3VpZCA9ICdicnVzaENvbnRyb2xsZXJfJyArIGJhc2VVSUQrKztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGVhY2gobW91c2VIYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSB6clV0aWwuYmluZChoYW5kbGVyLCB0aGlzKTtcbiAgfSwgdGhpcyk7XG59XG5cbkJydXNoQ29udHJvbGxlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBCcnVzaENvbnRyb2xsZXIsXG5cbiAgLyoqXG4gICAqIElmIHNldCB0byBudWxsL3VuZGVmaW5lZC9mYWxzZSwgc2VsZWN0IGRpc2FibGVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYnJ1c2hPcHRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gYnJ1c2hPcHRpb24uYnJ1c2hUeXBlICdsaW5lJywgJ3JlY3QnLCAncG9seWdvbicgb3IgZmFsc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIElmIHBhc3NpbmcgZmFsc2UvbnVsbC91bmRlZmluZWQsIGRpc2FibGUgYnJ1c2guXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBwYXNzaW5nICdhdXRvJywgZGV0ZXJtaW5lZCBieSBwYW5lbC5kZWZhdWx0QnJ1c2hUeXBlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgnYXV0bycgY2FuIG5vdCBiZSB1c2VkIGluIGdsb2JhbCBwYW5lbClcbiAgICogQHBhcmFtIHtudW1iZXJ9IFticnVzaE9wdGlvbi5icnVzaE1vZGU9J3NpbmdsZSddICdzaW5nbGUnIG9yICdtdWx0aXBsZSdcbiAgICogQHBhcmFtIHtib29sZWFufSBbYnJ1c2hPcHRpb24udHJhbnNmb3JtYWJsZT10cnVlXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFticnVzaE9wdGlvbi5yZW1vdmVPbkNsaWNrPWZhbHNlXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2JydXNoT3B0aW9uLmJydXNoU3R5bGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYnJ1c2hPcHRpb24uYnJ1c2hTdHlsZS53aWR0aF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLmxpbmVXaWR0aF1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLnN0cm9rZV1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLmZpbGxdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYnJ1c2hPcHRpb24uel1cbiAgICovXG4gIGVuYWJsZUJydXNoOiBmdW5jdGlvbiAoYnJ1c2hPcHRpb24pIHtcbiAgICB0aGlzLl9icnVzaFR5cGUgJiYgZG9EaXNhYmxlQnJ1c2godGhpcyk7XG4gICAgYnJ1c2hPcHRpb24uYnJ1c2hUeXBlICYmIGRvRW5hYmxlQnJ1c2godGhpcywgYnJ1c2hPcHRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBwYW5lbE9wdHMgSWYgbm90IHBhc3MsIGl0IGlzIGdsb2JhbCBicnVzaC5cbiAgICogICAgICAgIEVhY2ggaXRlbXM6IHtcbiAgICogICAgICAgICAgICBwYW5lbElkLCAvLyBtYW5kYXRvcnkuXG4gICAqICAgICAgICAgICAgY2xpcFBhdGgsIC8vIG1hbmRhdG9yeS4gZnVuY3Rpb24uXG4gICAqICAgICAgICAgICAgaXNUYXJnZXRCeUN1cnNvciwgLy8gbWFuZGF0b3J5LiBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICBkZWZhdWx0QnJ1c2hUeXBlLCAvLyBvcHRpb25hbCwgb25seSB1c2VkIHdoZW4gYnJ1c2hUeXBlIGlzICdhdXRvJy5cbiAgICogICAgICAgICAgICBnZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50LCAvLyBvcHRpb25hbC4gZnVuY3Rpb24uXG4gICAqICAgICAgICB9XG4gICAqL1xuICBzZXRQYW5lbHM6IGZ1bmN0aW9uIChwYW5lbE9wdHMpIHtcbiAgICBpZiAocGFuZWxPcHRzICYmIHBhbmVsT3B0cy5sZW5ndGgpIHtcbiAgICAgIHZhciBwYW5lbHMgPSB0aGlzLl9wYW5lbHMgPSB7fTtcbiAgICAgIHpyVXRpbC5lYWNoKHBhbmVsT3B0cywgZnVuY3Rpb24gKHBhbmVsT3B0cykge1xuICAgICAgICBwYW5lbHNbcGFuZWxPcHRzLnBhbmVsSWRdID0genJVdGlsLmNsb25lKHBhbmVsT3B0cyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFuZWxzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFtvcHQuZW5hYmxlR2xvYmFsUGFuPWZhbHNlXVxuICAgKi9cbiAgbW91bnQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdGhpcy5fZW5hYmxlR2xvYmFsUGFuID0gb3B0LmVuYWJsZUdsb2JhbFBhbjtcbiAgICB2YXIgdGhpc0dyb3VwID0gdGhpcy5ncm91cDtcblxuICAgIHRoaXMuX3pyLmFkZCh0aGlzR3JvdXApO1xuXG4gICAgdGhpc0dyb3VwLmF0dHIoe1xuICAgICAgcG9zaXRpb246IG9wdC5wb3NpdGlvbiB8fCBbMCwgMF0sXG4gICAgICByb3RhdGlvbjogb3B0LnJvdGF0aW9uIHx8IDAsXG4gICAgICBzY2FsZTogb3B0LnNjYWxlIHx8IFsxLCAxXVxuICAgIH0pO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRoaXNHcm91cC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlYWNoQ292ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGVhY2godGhpcy5fY292ZXJzLCBjYiwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjb3ZlcnMuXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGJydXNoT3B0aW9uTGlzdCBMaWtlOlxuICAgKiAgICAgICAgW1xuICAgKiAgICAgICAgICAgIHtpZDogJ3h4JywgYnJ1c2hUeXBlOiAnbGluZScsIHJhbmdlOiBbMjMsIDQ0XSwgYnJ1c2hTdHlsZSwgdHJhbnNmb3JtYWJsZX0sXG4gICAqICAgICAgICAgICAge2lkOiAneXknLCBicnVzaFR5cGU6ICdyZWN0JywgcmFuZ2U6IFtbMjMsIDQ0XSwgWzIzLCA1NF1dfSxcbiAgICogICAgICAgICAgICAuLi5cbiAgICogICAgICAgIF1cbiAgICogICAgICAgIGBicnVzaFR5cGVgIGlzIHJlcXVpcmVkIGluIGVhY2ggY292ZXIgaW5mby4gKGNhbiBub3QgYmUgJ2F1dG8nKVxuICAgKiAgICAgICAgYGlkYCBpcyBub3QgbWFuZGF0b3J5LlxuICAgKiAgICAgICAgYGJydXNoU3R5bGVgLCBgdHJhbnNmb3JtYWJsZWAgaXMgbm90IG1hbmRhdG9yeSwgdXNlIERFRkFVTFRfQlJVU0hfT1BUIGJ5IGRlZmF1bHQuXG4gICAqICAgICAgICBJZiBicnVzaE9wdGlvbkxpc3QgaXMgbnVsbC91bmRlZmluZWQsIGFsbCBjb3ZlcnMgcmVtb3ZlZC5cbiAgICovXG4gIHVwZGF0ZUNvdmVyczogZnVuY3Rpb24gKGJydXNoT3B0aW9uTGlzdCkge1xuICAgIGJydXNoT3B0aW9uTGlzdCA9IHpyVXRpbC5tYXAoYnJ1c2hPcHRpb25MaXN0LCBmdW5jdGlvbiAoYnJ1c2hPcHRpb24pIHtcbiAgICAgIHJldHVybiB6clV0aWwubWVyZ2UoenJVdGlsLmNsb25lKERFRkFVTFRfQlJVU0hfT1BUKSwgYnJ1c2hPcHRpb24sIHRydWUpO1xuICAgIH0pO1xuICAgIHZhciB0bXBJZFByZWZpeCA9ICdcXDAtYnJ1c2gtaW5kZXgtJztcbiAgICB2YXIgb2xkQ292ZXJzID0gdGhpcy5fY292ZXJzO1xuICAgIHZhciBuZXdDb3ZlcnMgPSB0aGlzLl9jb3ZlcnMgPSBbXTtcbiAgICB2YXIgY29udHJvbGxlciA9IHRoaXM7XG4gICAgdmFyIGNyZWF0aW5nQ292ZXIgPSB0aGlzLl9jcmVhdGluZ0NvdmVyO1xuICAgIG5ldyBEYXRhRGlmZmVyKG9sZENvdmVycywgYnJ1c2hPcHRpb25MaXN0LCBvbGRHZXRLZXksIGdldEtleSkuYWRkKGFkZE9yVXBkYXRlKS51cGRhdGUoYWRkT3JVcGRhdGUpLnJlbW92ZShyZW1vdmUpLmV4ZWN1dGUoKTtcbiAgICByZXR1cm4gdGhpcztcblxuICAgIGZ1bmN0aW9uIGdldEtleShicnVzaE9wdGlvbiwgaW5kZXgpIHtcbiAgICAgIHJldHVybiAoYnJ1c2hPcHRpb24uaWQgIT0gbnVsbCA/IGJydXNoT3B0aW9uLmlkIDogdG1wSWRQcmVmaXggKyBpbmRleCkgKyAnLScgKyBicnVzaE9wdGlvbi5icnVzaFR5cGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2xkR2V0S2V5KGNvdmVyLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGdldEtleShjb3Zlci5fX2JydXNoT3B0aW9uLCBpbmRleCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkT3JVcGRhdGUobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICB2YXIgbmV3QnJ1c2hPcHRpb24gPSBicnVzaE9wdGlvbkxpc3RbbmV3SW5kZXhdOyAvLyBDb25zaWRlciBzZXRPcHRpb24gaW4gZXZlbnQgbGlzdGVuZXIgb2YgYnJ1c2hTZWxlY3QsXG4gICAgICAvLyB3aGVyZSB1cGRhdGluZyBjb3ZlciB3aGVuIGNyZWF0aW5nIHNob3VsZCBiZSBmb3JiaWRlbi5cblxuICAgICAgaWYgKG9sZEluZGV4ICE9IG51bGwgJiYgb2xkQ292ZXJzW29sZEluZGV4XSA9PT0gY3JlYXRpbmdDb3Zlcikge1xuICAgICAgICBuZXdDb3ZlcnNbbmV3SW5kZXhdID0gb2xkQ292ZXJzW29sZEluZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb3ZlciA9IG5ld0NvdmVyc1tuZXdJbmRleF0gPSBvbGRJbmRleCAhPSBudWxsID8gKG9sZENvdmVyc1tvbGRJbmRleF0uX19icnVzaE9wdGlvbiA9IG5ld0JydXNoT3B0aW9uLCBvbGRDb3ZlcnNbb2xkSW5kZXhdKSA6IGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIG5ld0JydXNoT3B0aW9uKSk7XG4gICAgICAgIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKG9sZEluZGV4KSB7XG4gICAgICBpZiAob2xkQ292ZXJzW29sZEluZGV4XSAhPT0gY3JlYXRpbmdDb3Zlcikge1xuICAgICAgICBjb250cm9sbGVyLmdyb3VwLnJlbW92ZShvbGRDb3ZlcnNbb2xkSW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuYWJsZUJydXNoKGZhbHNlKTsgLy8gY29udGFpbmVyIG1heSAncmVtb3ZlQWxsJyBvdXRzaWRlLlxuXG4gICAgY2xlYXJDb3ZlcnModGhpcyk7XG5cbiAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5ncm91cCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudW5tb3VudCgpO1xuICAgIHRoaXMub2ZmKCk7XG4gIH1cbn07XG56clV0aWwubWl4aW4oQnJ1c2hDb250cm9sbGVyLCBFdmVudGZ1bCk7XG5cbmZ1bmN0aW9uIGRvRW5hYmxlQnJ1c2goY29udHJvbGxlciwgYnJ1c2hPcHRpb24pIHtcbiAgdmFyIHpyID0gY29udHJvbGxlci5fenI7IC8vIENvbnNpZGVyIHJvYW0sIHdoaWNoIHRha2VzIGdsb2JhbFBhbiB0b28uXG5cbiAgaWYgKCFjb250cm9sbGVyLl9lbmFibGVHbG9iYWxQYW4pIHtcbiAgICBpbnRlcmFjdGlvbk11dGV4LnRha2UoenIsIE1VVEVYX1JFU09VUkNFX0tFWSwgY29udHJvbGxlci5fdWlkKTtcbiAgfVxuXG4gIGVhY2goY29udHJvbGxlci5faGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyLCBldmVudE5hbWUpIHtcbiAgICB6ci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICB9KTtcbiAgY29udHJvbGxlci5fYnJ1c2hUeXBlID0gYnJ1c2hPcHRpb24uYnJ1c2hUeXBlO1xuICBjb250cm9sbGVyLl9icnVzaE9wdGlvbiA9IHpyVXRpbC5tZXJnZSh6clV0aWwuY2xvbmUoREVGQVVMVF9CUlVTSF9PUFQpLCBicnVzaE9wdGlvbiwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGRvRGlzYWJsZUJydXNoKGNvbnRyb2xsZXIpIHtcbiAgdmFyIHpyID0gY29udHJvbGxlci5fenI7XG4gIGludGVyYWN0aW9uTXV0ZXgucmVsZWFzZSh6ciwgTVVURVhfUkVTT1VSQ0VfS0VZLCBjb250cm9sbGVyLl91aWQpO1xuICBlYWNoKGNvbnRyb2xsZXIuX2hhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlciwgZXZlbnROYW1lKSB7XG4gICAgenIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gIH0pO1xuICBjb250cm9sbGVyLl9icnVzaFR5cGUgPSBjb250cm9sbGVyLl9icnVzaE9wdGlvbiA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKSB7XG4gIHZhciBjb3ZlciA9IGNvdmVyUmVuZGVyZXJzW2JydXNoT3B0aW9uLmJydXNoVHlwZV0uY3JlYXRlQ292ZXIoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pO1xuICBjb3Zlci5fX2JydXNoT3B0aW9uID0gYnJ1c2hPcHRpb247XG4gIHVwZGF0ZVooY292ZXIsIGJydXNoT3B0aW9uKTtcbiAgY29udHJvbGxlci5ncm91cC5hZGQoY292ZXIpO1xuICByZXR1cm4gY292ZXI7XG59XG5cbmZ1bmN0aW9uIGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpIHtcbiAgdmFyIGNvdmVyUmVuZGVyZXIgPSBnZXRDb3ZlclJlbmRlcmVyKGNyZWF0aW5nQ292ZXIpO1xuXG4gIGlmIChjb3ZlclJlbmRlcmVyLmVuZENyZWF0aW5nKSB7XG4gICAgY292ZXJSZW5kZXJlci5lbmRDcmVhdGluZyhjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKTtcbiAgICB1cGRhdGVaKGNyZWF0aW5nQ292ZXIsIGNyZWF0aW5nQ292ZXIuX19icnVzaE9wdGlvbik7XG4gIH1cblxuICByZXR1cm4gY3JlYXRpbmdDb3Zlcjtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ292ZXJTaGFwZShjb250cm9sbGVyLCBjb3Zlcikge1xuICB2YXIgYnJ1c2hPcHRpb24gPSBjb3Zlci5fX2JydXNoT3B0aW9uO1xuICBnZXRDb3ZlclJlbmRlcmVyKGNvdmVyKS51cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCBicnVzaE9wdGlvbi5yYW5nZSwgYnJ1c2hPcHRpb24pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVaKGNvdmVyLCBicnVzaE9wdGlvbikge1xuICB2YXIgeiA9IGJydXNoT3B0aW9uLno7XG4gIHogPT0gbnVsbCAmJiAoeiA9IENPVkVSX1opO1xuICBjb3Zlci50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC56ID0gejtcbiAgICBlbC56MiA9IHo7IC8vIENvbnNpZGVyIGluIGdpdmVuIGNvbnRhaW5lci5cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcikge1xuICBnZXRDb3ZlclJlbmRlcmVyKGNvdmVyKS51cGRhdGVDb21tb24oY29udHJvbGxlciwgY292ZXIpO1xuICB1cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q292ZXJSZW5kZXJlcihjb3Zlcikge1xuICByZXR1cm4gY292ZXJSZW5kZXJlcnNbY292ZXIuX19icnVzaE9wdGlvbi5icnVzaFR5cGVdO1xufSAvLyByZXR1cm4gdGFyZ2V0IHBhbmVsIG9yIGB0cnVlYCAobWVhbnMgZ2xvYmFsIHBhbmVsKVxuXG5cbmZ1bmN0aW9uIGdldFBhbmVsQnlQb2ludChjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50KSB7XG4gIHZhciBwYW5lbHMgPSBjb250cm9sbGVyLl9wYW5lbHM7XG5cbiAgaWYgKCFwYW5lbHMpIHtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gR2xvYmFsIHBhbmVsXG4gIH1cblxuICB2YXIgcGFuZWw7XG4gIHZhciB0cmFuc2Zvcm0gPSBjb250cm9sbGVyLl90cmFuc2Zvcm07XG4gIGVhY2gocGFuZWxzLCBmdW5jdGlvbiAocG4pIHtcbiAgICBwbi5pc1RhcmdldEJ5Q3Vyc29yKGUsIGxvY2FsQ3Vyc29yUG9pbnQsIHRyYW5zZm9ybSkgJiYgKHBhbmVsID0gcG4pO1xuICB9KTtcbiAgcmV0dXJuIHBhbmVsO1xufSAvLyBSZXR1cm4gYSBwYW5lbCBvciB0cnVlXG5cblxuZnVuY3Rpb24gZ2V0UGFuZWxCeUNvdmVyKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gIHZhciBwYW5lbHMgPSBjb250cm9sbGVyLl9wYW5lbHM7XG5cbiAgaWYgKCFwYW5lbHMpIHtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gR2xvYmFsIHBhbmVsXG4gIH1cblxuICB2YXIgcGFuZWxJZCA9IGNvdmVyLl9fYnJ1c2hPcHRpb24ucGFuZWxJZDsgLy8gVXNlciBtYXkgZ2l2ZSBjb3ZlciB3aXRob3V0IGNvb3JkIHN5cyBpbmZvLFxuICAvLyB3aGljaCBpcyB0aGVuIHRyZWF0ZWQgYXMgZ2xvYmFsIHBhbmVsLlxuXG4gIHJldHVybiBwYW5lbElkICE9IG51bGwgPyBwYW5lbHNbcGFuZWxJZF0gOiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjbGVhckNvdmVycyhjb250cm9sbGVyKSB7XG4gIHZhciBjb3ZlcnMgPSBjb250cm9sbGVyLl9jb3ZlcnM7XG4gIHZhciBvcmlnaW5hbExlbmd0aCA9IGNvdmVycy5sZW5ndGg7XG4gIGVhY2goY292ZXJzLCBmdW5jdGlvbiAoY292ZXIpIHtcbiAgICBjb250cm9sbGVyLmdyb3VwLnJlbW92ZShjb3Zlcik7XG4gIH0sIGNvbnRyb2xsZXIpO1xuICBjb3ZlcnMubGVuZ3RoID0gMDtcbiAgcmV0dXJuICEhb3JpZ2luYWxMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIoY29udHJvbGxlciwgb3B0KSB7XG4gIHZhciBhcmVhcyA9IG1hcChjb250cm9sbGVyLl9jb3ZlcnMsIGZ1bmN0aW9uIChjb3Zlcikge1xuICAgIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gICAgdmFyIHJhbmdlID0genJVdGlsLmNsb25lKGJydXNoT3B0aW9uLnJhbmdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgYnJ1c2hUeXBlOiBicnVzaE9wdGlvbi5icnVzaFR5cGUsXG4gICAgICBwYW5lbElkOiBicnVzaE9wdGlvbi5wYW5lbElkLFxuICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgfTtcbiAgfSk7XG4gIGNvbnRyb2xsZXIudHJpZ2dlcignYnJ1c2gnLCBhcmVhcywge1xuICAgIGlzRW5kOiAhIW9wdC5pc0VuZCxcbiAgICByZW1vdmVPbkNsaWNrOiAhIW9wdC5yZW1vdmVPbkNsaWNrXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzaG91bGRTaG93Q292ZXIoY29udHJvbGxlcikge1xuICB2YXIgdHJhY2sgPSBjb250cm9sbGVyLl90cmFjaztcblxuICBpZiAoIXRyYWNrLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwMiA9IHRyYWNrW3RyYWNrLmxlbmd0aCAtIDFdO1xuICB2YXIgcDEgPSB0cmFja1swXTtcbiAgdmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcbiAgdmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcbiAgdmFyIGRpc3QgPSBtYXRoUG93KGR4ICogZHggKyBkeSAqIGR5LCAwLjUpO1xuICByZXR1cm4gZGlzdCA+IFVOU0VMRUNUX1RIUkVTSE9MRDtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2tFbmRzKHRyYWNrKSB7XG4gIHZhciB0YWlsID0gdHJhY2subGVuZ3RoIC0gMTtcbiAgdGFpbCA8IDAgJiYgKHRhaWwgPSAwKTtcbiAgcmV0dXJuIFt0cmFja1swXSwgdHJhY2tbdGFpbF1dO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCYXNlUmVjdENvdmVyKGRvRHJpZnQsIGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uLCBlZGdlTmFtZXMpIHtcbiAgdmFyIGNvdmVyID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgY292ZXIuYWRkKG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIG5hbWU6ICdtYWluJyxcbiAgICBzdHlsZTogbWFrZVN0eWxlKGJydXNoT3B0aW9uKSxcbiAgICBzaWxlbnQ6IHRydWUsXG4gICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgIGN1cnNvcjogJ21vdmUnLFxuICAgIGRyaWZ0OiBjdXJyeShkb0RyaWZ0LCBjb250cm9sbGVyLCBjb3ZlciwgJ25zd2UnKSxcbiAgICBvbmRyYWdlbmQ6IGN1cnJ5KHRyaWdnZXIsIGNvbnRyb2xsZXIsIHtcbiAgICAgIGlzRW5kOiB0cnVlXG4gICAgfSlcbiAgfSkpO1xuICBlYWNoKGVkZ2VOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSxcbiAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgIGRyaWZ0OiBjdXJyeShkb0RyaWZ0LCBjb250cm9sbGVyLCBjb3ZlciwgbmFtZSksXG4gICAgICBvbmRyYWdlbmQ6IGN1cnJ5KHRyaWdnZXIsIGNvbnRyb2xsZXIsIHtcbiAgICAgICAgaXNFbmQ6IHRydWVcbiAgICAgIH0pXG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIGNvdmVyO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVCYXNlUmVjdChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgdmFyIGxpbmVXaWR0aCA9IGJydXNoT3B0aW9uLmJydXNoU3R5bGUubGluZVdpZHRoIHx8IDA7XG4gIHZhciBoYW5kbGVTaXplID0gbWF0aE1heChsaW5lV2lkdGgsIE1JTl9SRVNJWkVfTElORV9XSURUSCk7XG4gIHZhciB4ID0gbG9jYWxSYW5nZVswXVswXTtcbiAgdmFyIHkgPSBsb2NhbFJhbmdlWzFdWzBdO1xuICB2YXIgeGEgPSB4IC0gbGluZVdpZHRoIC8gMjtcbiAgdmFyIHlhID0geSAtIGxpbmVXaWR0aCAvIDI7XG4gIHZhciB4MiA9IGxvY2FsUmFuZ2VbMF1bMV07XG4gIHZhciB5MiA9IGxvY2FsUmFuZ2VbMV1bMV07XG4gIHZhciB4MmEgPSB4MiAtIGhhbmRsZVNpemUgKyBsaW5lV2lkdGggLyAyO1xuICB2YXIgeTJhID0geTIgLSBoYW5kbGVTaXplICsgbGluZVdpZHRoIC8gMjtcbiAgdmFyIHdpZHRoID0geDIgLSB4O1xuICB2YXIgaGVpZ2h0ID0geTIgLSB5O1xuICB2YXIgd2lkdGhhID0gd2lkdGggKyBsaW5lV2lkdGg7XG4gIHZhciBoZWlnaHRhID0gaGVpZ2h0ICsgbGluZVdpZHRoO1xuICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdtYWluJywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgaWYgKGJydXNoT3B0aW9uLnRyYW5zZm9ybWFibGUpIHtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICd3JywgeGEsIHlhLCBoYW5kbGVTaXplLCBoZWlnaHRhKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdlJywgeDJhLCB5YSwgaGFuZGxlU2l6ZSwgaGVpZ2h0YSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnbicsIHhhLCB5YSwgd2lkdGhhLCBoYW5kbGVTaXplKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdzJywgeGEsIHkyYSwgd2lkdGhhLCBoYW5kbGVTaXplKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdudycsIHhhLCB5YSwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnbmUnLCB4MmEsIHlhLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdzdycsIHhhLCB5MmEsIGhhbmRsZVNpemUsIGhhbmRsZVNpemUpO1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ3NlJywgeDJhLCB5MmEsIGhhbmRsZVNpemUsIGhhbmRsZVNpemUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbW1vbihjb250cm9sbGVyLCBjb3Zlcikge1xuICB2YXIgYnJ1c2hPcHRpb24gPSBjb3Zlci5fX2JydXNoT3B0aW9uO1xuICB2YXIgdHJhbnNmb3JtYWJsZSA9IGJydXNoT3B0aW9uLnRyYW5zZm9ybWFibGU7XG4gIHZhciBtYWluRWwgPSBjb3Zlci5jaGlsZEF0KDApO1xuICBtYWluRWwudXNlU3R5bGUobWFrZVN0eWxlKGJydXNoT3B0aW9uKSk7XG4gIG1haW5FbC5hdHRyKHtcbiAgICBzaWxlbnQ6ICF0cmFuc2Zvcm1hYmxlLFxuICAgIGN1cnNvcjogdHJhbnNmb3JtYWJsZSA/ICdtb3ZlJyA6ICdkZWZhdWx0J1xuICB9KTtcbiAgZWFjaChbJ3cnLCAnZScsICduJywgJ3MnLCAnc2UnLCAnc3cnLCAnbmUnLCAnbncnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZWwgPSBjb3Zlci5jaGlsZE9mTmFtZShuYW1lKTtcbiAgICB2YXIgZ2xvYmFsRGlyID0gZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIG5hbWUpO1xuICAgIGVsICYmIGVsLmF0dHIoe1xuICAgICAgc2lsZW50OiAhdHJhbnNmb3JtYWJsZSxcbiAgICAgIGludmlzaWJsZTogIXRyYW5zZm9ybWFibGUsXG4gICAgICBjdXJzb3I6IHRyYW5zZm9ybWFibGUgPyBDVVJTT1JfTUFQW2dsb2JhbERpcl0gKyAnLXJlc2l6ZScgOiBudWxsXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsIG5hbWUsIHgsIHksIHcsIGgpIHtcbiAgdmFyIGVsID0gY292ZXIuY2hpbGRPZk5hbWUobmFtZSk7XG4gIGVsICYmIGVsLnNldFNoYXBlKHBvaW50c1RvUmVjdChjbGlwQnlQYW5lbChjb250cm9sbGVyLCBjb3ZlciwgW1t4LCB5XSwgW3ggKyB3LCB5ICsgaF1dKSkpO1xufVxuXG5mdW5jdGlvbiBtYWtlU3R5bGUoYnJ1c2hPcHRpb24pIHtcbiAgcmV0dXJuIHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICB9LCBicnVzaE9wdGlvbi5icnVzaFN0eWxlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UmVjdFJhbmdlKHgsIHksIHgyLCB5Mikge1xuICB2YXIgbWluID0gW21hdGhNaW4oeCwgeDIpLCBtYXRoTWluKHksIHkyKV07XG4gIHZhciBtYXggPSBbbWF0aE1heCh4LCB4MiksIG1hdGhNYXgoeSwgeTIpXTtcbiAgcmV0dXJuIFtbbWluWzBdLCBtYXhbMF1dLCAvLyB4IHJhbmdlXG4gIFttaW5bMV0sIG1heFsxXV0gLy8geSByYW5nZVxuICBdO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm0oY29udHJvbGxlcikge1xuICByZXR1cm4gZ3JhcGhpYy5nZXRUcmFuc2Zvcm0oY29udHJvbGxlci5ncm91cCk7XG59XG5cbmZ1bmN0aW9uIGdldEdsb2JhbERpcmVjdGlvbihjb250cm9sbGVyLCBsb2NhbERpcmVjdGlvbikge1xuICBpZiAobG9jYWxEaXJlY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgIGxvY2FsRGlyZWN0aW9uID0gbG9jYWxEaXJlY3Rpb24uc3BsaXQoJycpO1xuICAgIHZhciBnbG9iYWxEaXIgPSBbZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIGxvY2FsRGlyZWN0aW9uWzBdKSwgZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIGxvY2FsRGlyZWN0aW9uWzFdKV07XG4gICAgKGdsb2JhbERpclswXSA9PT0gJ2UnIHx8IGdsb2JhbERpclswXSA9PT0gJ3cnKSAmJiBnbG9iYWxEaXIucmV2ZXJzZSgpO1xuICAgIHJldHVybiBnbG9iYWxEaXIuam9pbignJyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHc6ICdsZWZ0JyxcbiAgICAgIGU6ICdyaWdodCcsXG4gICAgICBuOiAndG9wJyxcbiAgICAgIHM6ICdib3R0b20nXG4gICAgfTtcbiAgICB2YXIgaW52ZXJzZU1hcCA9IHtcbiAgICAgIGxlZnQ6ICd3JyxcbiAgICAgIHJpZ2h0OiAnZScsXG4gICAgICB0b3A6ICduJyxcbiAgICAgIGJvdHRvbTogJ3MnXG4gICAgfTtcbiAgICB2YXIgZ2xvYmFsRGlyID0gZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24obWFwW2xvY2FsRGlyZWN0aW9uXSwgZ2V0VHJhbnNmb3JtKGNvbnRyb2xsZXIpKTtcbiAgICByZXR1cm4gaW52ZXJzZU1hcFtnbG9iYWxEaXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyaWZ0UmVjdCh0b1JlY3RSYW5nZSwgZnJvbVJlY3RSYW5nZSwgY29udHJvbGxlciwgY292ZXIsIG5hbWUsIGR4LCBkeSwgZSkge1xuICB2YXIgYnJ1c2hPcHRpb24gPSBjb3Zlci5fX2JydXNoT3B0aW9uO1xuICB2YXIgcmVjdFJhbmdlID0gdG9SZWN0UmFuZ2UoYnJ1c2hPcHRpb24ucmFuZ2UpO1xuICB2YXIgbG9jYWxEZWx0YSA9IHRvTG9jYWxEZWx0YShjb250cm9sbGVyLCBkeCwgZHkpO1xuICBlYWNoKG5hbWUuc3BsaXQoJycpLCBmdW5jdGlvbiAobmFtZVBhcnQpIHtcbiAgICB2YXIgaW5kID0gRElSRUNUSU9OX01BUFtuYW1lUGFydF07XG4gICAgcmVjdFJhbmdlW2luZFswXV1baW5kWzFdXSArPSBsb2NhbERlbHRhW2luZFswXV07XG4gIH0pO1xuICBicnVzaE9wdGlvbi5yYW5nZSA9IGZyb21SZWN0UmFuZ2UoZm9ybWF0UmVjdFJhbmdlKHJlY3RSYW5nZVswXVswXSwgcmVjdFJhbmdlWzFdWzBdLCByZWN0UmFuZ2VbMF1bMV0sIHJlY3RSYW5nZVsxXVsxXSkpO1xuICB1cGRhdGVDb3ZlckFmdGVyQ3JlYXRpb24oY29udHJvbGxlciwgY292ZXIpO1xuICB0cmlnZ2VyKGNvbnRyb2xsZXIsIHtcbiAgICBpc0VuZDogZmFsc2VcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRyaWZ0UG9seWdvbihjb250cm9sbGVyLCBjb3ZlciwgZHgsIGR5LCBlKSB7XG4gIHZhciByYW5nZSA9IGNvdmVyLl9fYnJ1c2hPcHRpb24ucmFuZ2U7XG4gIHZhciBsb2NhbERlbHRhID0gdG9Mb2NhbERlbHRhKGNvbnRyb2xsZXIsIGR4LCBkeSk7XG4gIGVhY2gocmFuZ2UsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHBvaW50WzBdICs9IGxvY2FsRGVsdGFbMF07XG4gICAgcG9pbnRbMV0gKz0gbG9jYWxEZWx0YVsxXTtcbiAgfSk7XG4gIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcik7XG4gIHRyaWdnZXIoY29udHJvbGxlciwge1xuICAgIGlzRW5kOiBmYWxzZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdG9Mb2NhbERlbHRhKGNvbnRyb2xsZXIsIGR4LCBkeSkge1xuICB2YXIgdGhpc0dyb3VwID0gY29udHJvbGxlci5ncm91cDtcbiAgdmFyIGxvY2FsRCA9IHRoaXNHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoZHgsIGR5KTtcbiAgdmFyIGxvY2FsWmVybyA9IHRoaXNHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoMCwgMCk7XG4gIHJldHVybiBbbG9jYWxEWzBdIC0gbG9jYWxaZXJvWzBdLCBsb2NhbERbMV0gLSBsb2NhbFplcm9bMV1dO1xufVxuXG5mdW5jdGlvbiBjbGlwQnlQYW5lbChjb250cm9sbGVyLCBjb3ZlciwgZGF0YSkge1xuICB2YXIgcGFuZWwgPSBnZXRQYW5lbEJ5Q292ZXIoY29udHJvbGxlciwgY292ZXIpO1xuICByZXR1cm4gcGFuZWwgJiYgcGFuZWwgIT09IHRydWUgPyBwYW5lbC5jbGlwUGF0aChkYXRhLCBjb250cm9sbGVyLl90cmFuc2Zvcm0pIDogenJVdGlsLmNsb25lKGRhdGEpO1xufVxuXG5mdW5jdGlvbiBwb2ludHNUb1JlY3QocG9pbnRzKSB7XG4gIHZhciB4bWluID0gbWF0aE1pbihwb2ludHNbMF1bMF0sIHBvaW50c1sxXVswXSk7XG4gIHZhciB5bWluID0gbWF0aE1pbihwb2ludHNbMF1bMV0sIHBvaW50c1sxXVsxXSk7XG4gIHZhciB4bWF4ID0gbWF0aE1heChwb2ludHNbMF1bMF0sIHBvaW50c1sxXVswXSk7XG4gIHZhciB5bWF4ID0gbWF0aE1heChwb2ludHNbMF1bMV0sIHBvaW50c1sxXVsxXSk7XG4gIHJldHVybiB7XG4gICAgeDogeG1pbixcbiAgICB5OiB5bWluLFxuICAgIHdpZHRoOiB4bWF4IC0geG1pbixcbiAgICBoZWlnaHQ6IHltYXggLSB5bWluXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3Vyc29yKGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpIHtcbiAgLy8gQ2hlY2sgYWN0aXZlXG4gIGlmICghY29udHJvbGxlci5fYnJ1c2hUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHpyID0gY29udHJvbGxlci5fenI7XG4gIHZhciBjb3ZlcnMgPSBjb250cm9sbGVyLl9jb3ZlcnM7XG4gIHZhciBjdXJyUGFuZWwgPSBnZXRQYW5lbEJ5UG9pbnQoY29udHJvbGxlciwgZSwgbG9jYWxDdXJzb3JQb2ludCk7IC8vIENoZWNrIHdoZXRoZXIgaW4gY292ZXJzLlxuXG4gIGlmICghY29udHJvbGxlci5fZHJhZ2dpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJydXNoT3B0aW9uID0gY292ZXJzW2ldLl9fYnJ1c2hPcHRpb247XG5cbiAgICAgIGlmIChjdXJyUGFuZWwgJiYgKGN1cnJQYW5lbCA9PT0gdHJ1ZSB8fCBicnVzaE9wdGlvbi5wYW5lbElkID09PSBjdXJyUGFuZWwucGFuZWxJZCkgJiYgY292ZXJSZW5kZXJlcnNbYnJ1c2hPcHRpb24uYnJ1c2hUeXBlXS5jb250YWluKGNvdmVyc1tpXSwgbG9jYWxDdXJzb3JQb2ludFswXSwgbG9jYWxDdXJzb3JQb2ludFsxXSkpIHtcbiAgICAgICAgLy8gVXNlIGN1cnNvciBzdHlsZSBzZXQgb24gY292ZXIuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdXJyUGFuZWwgJiYgenIuc2V0Q3Vyc29yU3R5bGUoJ2Nyb3NzaGFpcicpO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XG4gIHZhciByYXdFID0gZS5ldmVudDtcbiAgcmF3RS5wcmV2ZW50RGVmYXVsdCAmJiByYXdFLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIG1haW5TaGFwZUNvbnRhaW4oY292ZXIsIHgsIHkpIHtcbiAgcmV0dXJuIGNvdmVyLmNoaWxkT2ZOYW1lKCdtYWluJykuY29udGFpbih4LCB5KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ292ZXJCeU1vdXNlKGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQsIGlzRW5kKSB7XG4gIHZhciBjcmVhdGluZ0NvdmVyID0gY29udHJvbGxlci5fY3JlYXRpbmdDb3ZlcjtcbiAgdmFyIHBhbmVsID0gY29udHJvbGxlci5fY3JlYXRpbmdQYW5lbDtcbiAgdmFyIHRoaXNCcnVzaE9wdGlvbiA9IGNvbnRyb2xsZXIuX2JydXNoT3B0aW9uO1xuICB2YXIgZXZlbnRQYXJhbXM7XG5cbiAgY29udHJvbGxlci5fdHJhY2sucHVzaChsb2NhbEN1cnNvclBvaW50LnNsaWNlKCkpO1xuXG4gIGlmIChzaG91bGRTaG93Q292ZXIoY29udHJvbGxlcikgfHwgY3JlYXRpbmdDb3Zlcikge1xuICAgIGlmIChwYW5lbCAmJiAhY3JlYXRpbmdDb3Zlcikge1xuICAgICAgdGhpc0JydXNoT3B0aW9uLmJydXNoTW9kZSA9PT0gJ3NpbmdsZScgJiYgY2xlYXJDb3ZlcnMoY29udHJvbGxlcik7XG4gICAgICB2YXIgYnJ1c2hPcHRpb24gPSB6clV0aWwuY2xvbmUodGhpc0JydXNoT3B0aW9uKTtcbiAgICAgIGJydXNoT3B0aW9uLmJydXNoVHlwZSA9IGRldGVybWluZUJydXNoVHlwZShicnVzaE9wdGlvbi5icnVzaFR5cGUsIHBhbmVsKTtcbiAgICAgIGJydXNoT3B0aW9uLnBhbmVsSWQgPSBwYW5lbCA9PT0gdHJ1ZSA/IG51bGwgOiBwYW5lbC5wYW5lbElkO1xuICAgICAgY3JlYXRpbmdDb3ZlciA9IGNvbnRyb2xsZXIuX2NyZWF0aW5nQ292ZXIgPSBjcmVhdGVDb3Zlcihjb250cm9sbGVyLCBicnVzaE9wdGlvbik7XG5cbiAgICAgIGNvbnRyb2xsZXIuX2NvdmVycy5wdXNoKGNyZWF0aW5nQ292ZXIpO1xuICAgIH1cblxuICAgIGlmIChjcmVhdGluZ0NvdmVyKSB7XG4gICAgICB2YXIgY292ZXJSZW5kZXJlciA9IGNvdmVyUmVuZGVyZXJzW2RldGVybWluZUJydXNoVHlwZShjb250cm9sbGVyLl9icnVzaFR5cGUsIHBhbmVsKV07XG4gICAgICB2YXIgY292ZXJCcnVzaE9wdGlvbiA9IGNyZWF0aW5nQ292ZXIuX19icnVzaE9wdGlvbjtcbiAgICAgIGNvdmVyQnJ1c2hPcHRpb24ucmFuZ2UgPSBjb3ZlclJlbmRlcmVyLmdldENyZWF0aW5nUmFuZ2UoY2xpcEJ5UGFuZWwoY29udHJvbGxlciwgY3JlYXRpbmdDb3ZlciwgY29udHJvbGxlci5fdHJhY2spKTtcblxuICAgICAgaWYgKGlzRW5kKSB7XG4gICAgICAgIGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgICAgICBjb3ZlclJlbmRlcmVyLnVwZGF0ZUNvbW1vbihjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlQ292ZXJTaGFwZShjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKTtcbiAgICAgIGV2ZW50UGFyYW1zID0ge1xuICAgICAgICBpc0VuZDogaXNFbmRcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW5kICYmIHRoaXNCcnVzaE9wdGlvbi5icnVzaE1vZGUgPT09ICdzaW5nbGUnICYmIHRoaXNCcnVzaE9wdGlvbi5yZW1vdmVPbkNsaWNrKSB7XG4gICAgLy8gSGVscCB1c2VyIHRvIHJlbW92ZSBjb3ZlcnMgZWFzaWx5LCBvbmx5IGJ5IGEgdGlueSBkcmFnLCBpbiAnc2luZ2xlJyBtb2RlLlxuICAgIC8vIEJ1dCBhIHNpbmdsZSBjbGljayBkbyBub3QgY2xlYXIgY292ZXJzLCBiZWNhdXNlIHVzZXIgbWF5IGhhdmUgY2FzdWFsXG4gICAgLy8gY2xpY2tzIChmb3IgZXhhbXBsZSwgY2xpY2sgb24gb3RoZXIgY29tcG9uZW50IGFuZCBkbyBub3QgZXhwZWN0IGNvdmVyc1xuICAgIC8vIGRpc2FwcGVhcikuXG4gICAgLy8gT25seSBzb21lIGNvdmVyIHJlbW92ZWQsIHRyaWdnZXIgYWN0aW9uLCBidXQgbm90IGV2ZXJ5IGNsaWNrIHRyaWdnZXIgYWN0aW9uLlxuICAgIGlmIChnZXRQYW5lbEJ5UG9pbnQoY29udHJvbGxlciwgZSwgbG9jYWxDdXJzb3JQb2ludCkgJiYgY2xlYXJDb3ZlcnMoY29udHJvbGxlcikpIHtcbiAgICAgIGV2ZW50UGFyYW1zID0ge1xuICAgICAgICBpc0VuZDogaXNFbmQsXG4gICAgICAgIHJlbW92ZU9uQ2xpY2s6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50UGFyYW1zO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVCcnVzaFR5cGUoYnJ1c2hUeXBlLCBwYW5lbCkge1xuICBpZiAoYnJ1c2hUeXBlID09PSAnYXV0bycpIHtcbiAgICByZXR1cm4gcGFuZWwuZGVmYXVsdEJydXNoVHlwZTtcbiAgfVxuXG4gIHJldHVybiBicnVzaFR5cGU7XG59XG5cbnZhciBtb3VzZUhhbmRsZXJzID0ge1xuICBtb3VzZWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuX2RyYWdnaW5nKSB7XG4gICAgICAvLyBJbiBjYXNlIHNvbWUgYnJvd3NlciBkbyBub3Qgc3VwcG9ydCBnbG9iYWxPdXQsXG4gICAgICAvLyBhbmQgcmVsZWFzZSBtb3NlIG91dCBzaWRlIHRoZSBicm93c2VyLlxuICAgICAgaGFuZGxlRHJhZ0VuZC5jYWxsKHRoaXMsIGUpO1xuICAgIH0gZWxzZSBpZiAoIWUudGFyZ2V0IHx8ICFlLnRhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgdmFyIGxvY2FsQ3Vyc29yUG9pbnQgPSB0aGlzLmdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgICB0aGlzLl9jcmVhdGluZ0NvdmVyID0gbnVsbDtcbiAgICAgIHZhciBwYW5lbCA9IHRoaXMuX2NyZWF0aW5nUGFuZWwgPSBnZXRQYW5lbEJ5UG9pbnQodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCk7XG5cbiAgICAgIGlmIChwYW5lbCkge1xuICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3RyYWNrID0gW2xvY2FsQ3Vyc29yUG9pbnQuc2xpY2UoKV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGxvY2FsQ3Vyc29yUG9pbnQgPSB0aGlzLmdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgcmVzZXRDdXJzb3IodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCk7XG5cbiAgICBpZiAodGhpcy5fZHJhZ2dpbmcpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgdmFyIGV2ZW50UGFyYW1zID0gdXBkYXRlQ292ZXJCeU1vdXNlKHRoaXMsIGUsIGxvY2FsQ3Vyc29yUG9pbnQsIGZhbHNlKTtcbiAgICAgIGV2ZW50UGFyYW1zICYmIHRyaWdnZXIodGhpcywgZXZlbnRQYXJhbXMpO1xuICAgIH1cbiAgfSxcbiAgbW91c2V1cDogaGFuZGxlRHJhZ0VuZCAvLyxcbiAgLy8gRklYTUVcbiAgLy8gaW4gdG9vbHRpcCwgZ2xvYmFsb3V0IHNob3VsZCBub3QgYmUgdHJpZ2dlcmVkLlxuICAvLyBnbG9iYWxvdXQ6IGhhbmRsZURyYWdFbmRcblxufTtcblxuZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZChlKSB7XG4gIGlmICh0aGlzLl9kcmFnZ2luZykge1xuICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgIHZhciBsb2NhbEN1cnNvclBvaW50ID0gdGhpcy5ncm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xuICAgIHZhciBldmVudFBhcmFtcyA9IHVwZGF0ZUNvdmVyQnlNb3VzZSh0aGlzLCBlLCBsb2NhbEN1cnNvclBvaW50LCB0cnVlKTtcbiAgICB0aGlzLl9kcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX3RyYWNrID0gW107XG4gICAgdGhpcy5fY3JlYXRpbmdDb3ZlciA9IG51bGw7IC8vIHRyaWdnZXIgZXZlbnQgc2hvdWxlIGJlIGF0IGZpbmFsLCBhZnRlciBwcm9jZWR1cmUgd2lsbCBiZSBuZXN0ZWQuXG5cbiAgICBldmVudFBhcmFtcyAmJiB0cmlnZ2VyKHRoaXMsIGV2ZW50UGFyYW1zKTtcbiAgfVxufVxuLyoqXG4gKiBrZXk6IGJydXNoVHlwZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5cbnZhciBjb3ZlclJlbmRlcmVycyA9IHtcbiAgbGluZVg6IGdldExpbmVSZW5kZXJlcigwKSxcbiAgbGluZVk6IGdldExpbmVSZW5kZXJlcigxKSxcbiAgcmVjdDoge1xuICAgIGNyZWF0ZUNvdmVyOiBmdW5jdGlvbiAoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pIHtcbiAgICAgIHJldHVybiBjcmVhdGVCYXNlUmVjdENvdmVyKGN1cnJ5KGRyaWZ0UmVjdCwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICB9KSwgY29udHJvbGxlciwgYnJ1c2hPcHRpb24sIFsndycsICdlJywgJ24nLCAncycsICdzZScsICdzdycsICduZScsICdudyddKTtcbiAgICB9LFxuICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICB2YXIgZW5kcyA9IGdldFRyYWNrRW5kcyhsb2NhbFRyYWNrKTtcbiAgICAgIHJldHVybiBmb3JtYXRSZWN0UmFuZ2UoZW5kc1sxXVswXSwgZW5kc1sxXVsxXSwgZW5kc1swXVswXSwgZW5kc1swXVsxXSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb3ZlclNoYXBlOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gICAgICB1cGRhdGVCYXNlUmVjdChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pO1xuICAgIH0sXG4gICAgdXBkYXRlQ29tbW9uOiB1cGRhdGVDb21tb24sXG4gICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICB9LFxuICBwb2x5Z29uOiB7XG4gICAgY3JlYXRlQ292ZXI6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgdmFyIGNvdmVyID0gbmV3IGdyYXBoaWMuR3JvdXAoKTsgLy8gRG8gbm90IHVzZSBncmFwaGljLlBvbHlnb24gYmVjYXVzZSBncmFwaGljLlBvbHlsaW5lIGRvIG5vdCBjbG9zZSB0aGVcbiAgICAgIC8vIGJvcmRlciBvZiB0aGUgc2hhcGUgd2hlbiBkcmF3aW5nLCB3aGljaCBpcyBhIGJldHRlciBleHBlcmllbmNlIGZvciB1c2VyLlxuXG4gICAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgIHN0eWxlOiBtYWtlU3R5bGUoYnJ1c2hPcHRpb24pLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjb3ZlcjtcbiAgICB9LFxuICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICByZXR1cm4gbG9jYWxUcmFjaztcbiAgICB9LFxuICAgIGVuZENyZWF0aW5nOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIpIHtcbiAgICAgIGNvdmVyLnJlbW92ZShjb3Zlci5jaGlsZEF0KDApKTsgLy8gVXNlIGdyYXBoaWMuUG9seWdvbiBjbG9zZSB0aGUgc2hhcGUuXG5cbiAgICAgIGNvdmVyLmFkZChuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcbiAgICAgICAgbmFtZTogJ21haW4nLFxuICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIGRyaWZ0OiBjdXJyeShkcmlmdFBvbHlnb24sIGNvbnRyb2xsZXIsIGNvdmVyKSxcbiAgICAgICAgb25kcmFnZW5kOiBjdXJyeSh0cmlnZ2VyLCBjb250cm9sbGVyLCB7XG4gICAgICAgICAgaXNFbmQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvdmVyU2hhcGU6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgICAgIGNvdmVyLmNoaWxkQXQoMCkuc2V0U2hhcGUoe1xuICAgICAgICBwb2ludHM6IGNsaXBCeVBhbmVsKGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb21tb246IHVwZGF0ZUNvbW1vbixcbiAgICBjb250YWluOiBtYWluU2hhcGVDb250YWluXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldExpbmVSZW5kZXJlcih4eUluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ292ZXI6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJhc2VSZWN0Q292ZXIoY3VycnkoZHJpZnRSZWN0LCBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIHJlY3RSYW5nZSA9IFtyYW5nZSwgWzAsIDEwMF1dO1xuICAgICAgICB4eUluZGV4ICYmIHJlY3RSYW5nZS5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiByZWN0UmFuZ2U7XG4gICAgICB9LCBmdW5jdGlvbiAocmVjdFJhbmdlKSB7XG4gICAgICAgIHJldHVybiByZWN0UmFuZ2VbeHlJbmRleF07XG4gICAgICB9KSwgY29udHJvbGxlciwgYnJ1c2hPcHRpb24sIFtbJ3cnLCAnZSddLCBbJ24nLCAncyddXVt4eUluZGV4XSk7XG4gICAgfSxcbiAgICBnZXRDcmVhdGluZ1JhbmdlOiBmdW5jdGlvbiAobG9jYWxUcmFjaykge1xuICAgICAgdmFyIGVuZHMgPSBnZXRUcmFja0VuZHMobG9jYWxUcmFjayk7XG4gICAgICB2YXIgbWluID0gbWF0aE1pbihlbmRzWzBdW3h5SW5kZXhdLCBlbmRzWzFdW3h5SW5kZXhdKTtcbiAgICAgIHZhciBtYXggPSBtYXRoTWF4KGVuZHNbMF1beHlJbmRleF0sIGVuZHNbMV1beHlJbmRleF0pO1xuICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfSxcbiAgICB1cGRhdGVDb3ZlclNoYXBlOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gICAgICB2YXIgb3RoZXJFeHRlbnQ7IC8vIElmIGJydXNoV2lkdGggbm90IHNwZWNpZmllZCwgZml0IHRoZSBwYW5lbC5cblxuICAgICAgdmFyIHBhbmVsID0gZ2V0UGFuZWxCeUNvdmVyKGNvbnRyb2xsZXIsIGNvdmVyKTtcblxuICAgICAgaWYgKHBhbmVsICE9PSB0cnVlICYmIHBhbmVsLmdldExpbmVhckJydXNoT3RoZXJFeHRlbnQpIHtcbiAgICAgICAgb3RoZXJFeHRlbnQgPSBwYW5lbC5nZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50KHh5SW5kZXgsIGNvbnRyb2xsZXIuX3RyYW5zZm9ybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgenIgPSBjb250cm9sbGVyLl96cjtcbiAgICAgICAgb3RoZXJFeHRlbnQgPSBbMCwgW3pyLmdldFdpZHRoKCksIHpyLmdldEhlaWdodCgpXVsxIC0geHlJbmRleF1dO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjdFJhbmdlID0gW2xvY2FsUmFuZ2UsIG90aGVyRXh0ZW50XTtcbiAgICAgIHh5SW5kZXggJiYgcmVjdFJhbmdlLnJldmVyc2UoKTtcbiAgICAgIHVwZGF0ZUJhc2VSZWN0KGNvbnRyb2xsZXIsIGNvdmVyLCByZWN0UmFuZ2UsIGJydXNoT3B0aW9uKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbW1vbjogdXBkYXRlQ29tbW9uLFxuICAgIGNvbnRhaW46IG1haW5TaGFwZUNvbnRhaW5cbiAgfTtcbn1cblxudmFyIF9kZWZhdWx0ID0gQnJ1c2hDb250cm9sbGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaENvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBicnVzaEhlbHBlciA9IHJlcXVpcmUoXCIuL2JydXNoSGVscGVyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcbnZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbnZhciBDT09SRF9DT05WRVJUUyA9IFsnZGF0YVRvUG9pbnQnLCAncG9pbnRUb0RhdGEnXTsgLy8gRklYTUVcbi8vIGhvdyB0byBnZW5hcmlhbGl6ZSB0byBtb3JlIGNvb3JkaW5hdGUgc3lzdGVtcy5cblxudmFyIElOQ0xVREVfRklOREVSX01BSU5fVFlQRVMgPSBbJ2dyaWQnLCAneEF4aXMnLCAneUF4aXMnLCAnZ2VvJywgJ2dyYXBoJywgJ3BvbGFyJywgJ3JhZGl1c0F4aXMnLCAnYW5nbGVBeGlzJywgJ2JtYXAnXTtcbi8qKlxuICogW29wdGlvbiBpbiBjb25zdHJ1Y3Rvcl06XG4gKiB7XG4gKiAgICAgSW5kZXgvSWQvTmFtZSBvZiBnZW8sIHhBeGlzLCB5QXhpcywgZ3JpZDogU2VlIHV0aWwvbW9kZWwjcGFyc2VGaW5kZXIuXG4gKiB9XG4gKlxuICpcbiAqIFt0YXJnZXRJbmZvXTpcbiAqXG4gKiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgYXhlcyBpbiBhIHNpbmdsZSB0YXJnZXRJbmZvLiBDb25zaWRlciB0aGUgY2FzZVxuICogb2YgYGdyaWRgIGNvbXBvbmVudCwgYSB0YXJnZXRJbmZvIHJlcHJlc2VudHMgYSBncmlkIHdoaWNoIGNvbnRhaW5zIG9uZSBvciBtb3JlXG4gKiBjYXJ0ZXNpYW4gYW5kIG9uZSBvciBtb3JlIGF4ZXMuIEFuZCBjb25zaWRlciB0aGUgY2FzZSBvZiBwYXJhbGxlbCBzeXN0ZW0sXG4gKiB3aGljaCBoYXMgbXVsdGlwbGUgYXhlcyBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtLlxuICogQ2FuIGJlIHtcbiAqICAgICBwYW5lbElkOiAuLi4sXG4gKiAgICAgY29vcmRTeXM6IDxhIHJlcHJlc2VudGl0aXZlIGNhcnRlc2lhbiBpbiBncmlkIChmaXJzdCBjYXJ0ZXNpYW4gYnkgZGVmYXVsdCk+LFxuICogICAgIGNvb3JkU3lzZXM6IGFsbCBjYXJ0ZXNpYW5zLlxuICogICAgIGdyaWRNb2RlbDogPGdyaWQgY29tcG9uZW50PlxuICogICAgIHhBeGVzOiBjb3JyZXNwb25kIHRvIGNvb3JkU3lzZXMgb24gaW5kZXhcbiAqICAgICB5QXhlczogY29ycmVzcG9uZCB0byBjb29yZFN5c2VzIG9uIGluZGV4XG4gKiB9XG4gKiBvciB7XG4gKiAgICAgcGFuZWxJZDogLi4uLFxuICogICAgIGNvb3JkU3lzOiA8Z2VvIGNvb3JkIHN5cz5cbiAqICAgICBjb29yZFN5c2VzOiBbPGdlbyBjb29yZCBzeXM+XVxuICogICAgIGdlb01vZGVsOiA8Z2VvIGNvbXBvbmVudD5cbiAqIH1cbiAqXG4gKlxuICogW3BhbmVsT3B0XTpcbiAqXG4gKiBNYWtlIGZyb20gdGFyZ2V0SW5mby4gSW5wdXQgdG8gQnJ1c2hDb250cm9sbGVyLlxuICoge1xuICogICAgIHBhbmVsSWQ6IC4uLixcbiAqICAgICByZWN0OiAuLi5cbiAqIH1cbiAqXG4gKlxuICogW2FyZWFdOlxuICpcbiAqIEdlbmVyYXRlZCBieSBCcnVzaENvbnRyb2xsZXIgb3IgdXNlciBpbnB1dC5cbiAqIHtcbiAqICAgICBwYW5lbElkOiBVc2VkIHRvIGxvY2F0ZSBjb29yZEluZm8gZGlyZWN0bHkuIElmIHVzZXIgaW5wcHV0LCBubyBwYW5lbElkLlxuICogICAgIGJydXNoVHlwZTogZGV0ZXJtaW5lIGhvdyB0byBjb252ZXJ0IHRvL2Zyb20gY29vcmQoJ3JlY3QnIG9yICdwb2x5Z29uJyBvciAnbGluZVgvWScpLlxuICogICAgIEluZGV4L0lkL05hbWUgb2YgZ2VvLCB4QXhpcywgeUF4aXMsIGdyaWQ6IFNlZSB1dGlsL21vZGVsI3BhcnNlRmluZGVyLlxuICogICAgIHJhbmdlOiBwaXhlbCByYW5nZS5cbiAqICAgICBjb29yZFJhbmdlOiByZXByZXNlbnRpdGl2ZSBjb29yZCByYW5nZSAodGhlIGZpcnN0IG9uZSBvZiBjb29yZFJhbmdlcykuXG4gKiAgICAgY29vcmRSYW5nZXM6IDxBcnJheT4gY29vcmQgcmFuZ2VzLCB1c2VkIGluIG11bHRpcGxlIGNhcnRlc2lhbiBpbiBvbmUgZ3JpZC5cbiAqIH1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24gY29udGFpbnMgSW5kZXgvSWQvTmFtZSBvZiB4QXhpcy95QXhpcy9nZW8vZ3JpZFxuICogICAgICAgIEVhY2ggY2FuIGJlIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59LiBsaWtlOiB7eEF4aXNJbmRleDogWzMsIDRdfVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW29wdC5pbmNsdWRlXSBpbmNsdWRlIGNvb3JkaW5hdGUgc3lzdGVtIHR5cGVzLlxuICovXG5cbmZ1bmN0aW9uIEJydXNoVGFyZ2V0TWFuYWdlcihvcHRpb24sIGVjTW9kZWwsIG9wdCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgKi9cbiAgdmFyIHRhcmdldEluZm9MaXN0ID0gdGhpcy5fdGFyZ2V0SW5mb0xpc3QgPSBbXTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgdmFyIGZvdW5kQ3B0cyA9IHBhcnNlRmluZGVyKGVjTW9kZWwsIG9wdGlvbik7XG4gIGVhY2godGFyZ2V0SW5mb0J1aWxkZXJzLCBmdW5jdGlvbiAoYnVpbGRlciwgdHlwZSkge1xuICAgIGlmICghb3B0IHx8ICFvcHQuaW5jbHVkZSB8fCBpbmRleE9mKG9wdC5pbmNsdWRlLCB0eXBlKSA+PSAwKSB7XG4gICAgICBidWlsZGVyKGZvdW5kQ3B0cywgdGFyZ2V0SW5mb0xpc3QsIGluZm8pO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBwcm90byA9IEJydXNoVGFyZ2V0TWFuYWdlci5wcm90b3R5cGU7XG5cbnByb3RvLnNldE91dHB1dFJhbmdlcyA9IGZ1bmN0aW9uIChhcmVhcywgZWNNb2RlbCkge1xuICB0aGlzLm1hdGNoT3V0cHV0UmFuZ2VzKGFyZWFzLCBlY01vZGVsLCBmdW5jdGlvbiAoYXJlYSwgY29vcmRSYW5nZSwgY29vcmRTeXMpIHtcbiAgICAoYXJlYS5jb29yZFJhbmdlcyB8fCAoYXJlYS5jb29yZFJhbmdlcyA9IFtdKSkucHVzaChjb29yZFJhbmdlKTsgLy8gYXJlYS5jb29yZFJhbmdlIGlzIHRoZSBmaXJzdCBvZiBhcmVhLmNvb3JkUmFuZ2VzXG5cbiAgICBpZiAoIWFyZWEuY29vcmRSYW5nZSkge1xuICAgICAgYXJlYS5jb29yZFJhbmdlID0gY29vcmRSYW5nZTsgLy8gSW4gJ2NhdGVnb3J5JyBheGlzLCBjb29yZCB0byBwaXhlbCBpcyBub3QgcmV2ZXJzaWJsZSwgc28gd2UgY2FuIG5vdFxuICAgICAgLy8gcmVidWlsZCByYW5nZSBieSBjb29yZFJhbmdlIGFjY3JhdGVseSwgd2hpY2ggbWF5IGJyaW5nIHRyb3VibGUgd2hlblxuICAgICAgLy8gYnJ1c2hpbmcgb25seSBvbmUgaXRlbS4gU28gd2UgdXNlIF9fcmFuZ2VPZmZzZXQgdG8gcmVidWlsZGluZyByYW5nZVxuICAgICAgLy8gYnkgY29vcmRSYW5nZS4gQW5kIHRoaXMgaXQgb25seSB1c2VkIGluIGJydXNoIGNvbXBvbmVudCBzbyBpdCBpcyBub1xuICAgICAgLy8gbmVlZCB0byBiZSBhZGFwdGVkIHRvIGNvb3JkUmFuZ2VzLlxuXG4gICAgICB2YXIgcmVzdWx0ID0gY29vcmRDb252ZXJ0W2FyZWEuYnJ1c2hUeXBlXSgwLCBjb29yZFN5cywgY29vcmRSYW5nZSk7XG4gICAgICBhcmVhLl9fcmFuZ2VPZmZzZXQgPSB7XG4gICAgICAgIG9mZnNldDogZGlmZlByb2Nlc3NvclthcmVhLmJydXNoVHlwZV0ocmVzdWx0LnZhbHVlcywgYXJlYS5yYW5nZSwgWzEsIDFdKSxcbiAgICAgICAgeHlNaW5NYXg6IHJlc3VsdC54eU1pbk1heFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufTtcblxucHJvdG8ubWF0Y2hPdXRwdXRSYW5nZXMgPSBmdW5jdGlvbiAoYXJlYXMsIGVjTW9kZWwsIGNiKSB7XG4gIGVhY2goYXJlYXMsIGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuXG4gICAgaWYgKHRhcmdldEluZm8gJiYgdGFyZ2V0SW5mbyAhPT0gdHJ1ZSkge1xuICAgICAgenJVdGlsLmVhY2godGFyZ2V0SW5mby5jb29yZFN5c2VzLCBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvb3JkQ29udmVydFthcmVhLmJydXNoVHlwZV0oMSwgY29vcmRTeXMsIGFyZWEucmFuZ2UpO1xuICAgICAgICBjYihhcmVhLCByZXN1bHQudmFsdWVzLCBjb29yZFN5cywgZWNNb2RlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHRoaXMpO1xufTtcblxucHJvdG8uc2V0SW5wdXRSYW5nZXMgPSBmdW5jdGlvbiAoYXJlYXMsIGVjTW9kZWwpIHtcbiAgZWFjaChhcmVhcywgZnVuY3Rpb24gKGFyZWEpIHtcbiAgICB2YXIgdGFyZ2V0SW5mbyA9IHRoaXMuZmluZFRhcmdldEluZm8oYXJlYSwgZWNNb2RlbCk7XG4gICAgYXJlYS5yYW5nZSA9IGFyZWEucmFuZ2UgfHwgW107IC8vIGNvbnZlcnQgY29vcmRSYW5nZSB0byBnbG9iYWwgcmFuZ2UgYW5kIHNldCBwYW5lbElkLlxuXG4gICAgaWYgKHRhcmdldEluZm8gJiYgdGFyZ2V0SW5mbyAhPT0gdHJ1ZSkge1xuICAgICAgYXJlYS5wYW5lbElkID0gdGFyZ2V0SW5mby5wYW5lbElkOyAvLyAoMSkgYXJlYS5yYW5nZSBzaG91bGUgYWx3YXlzIGJlIGNhbGN1bGF0ZSBmcm9tIGNvb3JkUmFuZ2UgYnV0IGRvZXNcbiAgICAgIC8vIG5vdCBrZWVwIGl0cyBvcmlnaW5hbCB2YWx1ZSwgZm9yIHRoZSBzYWtlIG9mIHRoZSBkYXRhWm9vbSBzY2VuYXJpbyxcbiAgICAgIC8vIHdoZXJlIGFyZWEuY29vcmRSYW5nZSByZW1haW5zIHVuY2hhbmdlZCBidXQgYXJlYS5yYW5nZSBtYXkgYmUgY2hhbmdlZC5cbiAgICAgIC8vICgyKSBPbmx5IHN1cHBvcnQgY29udmVydGluZyBvbmUgY29vcmRSYW5nZSB0byBwaXhlbCByYW5nZSBpbiBicnVzaFxuICAgICAgLy8gY29tcG9uZW50LiBTbyBkbyBub3QgY29uc2lkZXIgYGNvb3JkUmFuZ2VzYC5cbiAgICAgIC8vICgzKSBBYm91dCBfX3JhbmdlT2Zmc2V0LCBzZWUgY29tbWVudCBhYm92ZS5cblxuICAgICAgdmFyIHJlc3VsdCA9IGNvb3JkQ29udmVydFthcmVhLmJydXNoVHlwZV0oMCwgdGFyZ2V0SW5mby5jb29yZFN5cywgYXJlYS5jb29yZFJhbmdlKTtcbiAgICAgIHZhciByYW5nZU9mZnNldCA9IGFyZWEuX19yYW5nZU9mZnNldDtcbiAgICAgIGFyZWEucmFuZ2UgPSByYW5nZU9mZnNldCA/IGRpZmZQcm9jZXNzb3JbYXJlYS5icnVzaFR5cGVdKHJlc3VsdC52YWx1ZXMsIHJhbmdlT2Zmc2V0Lm9mZnNldCwgZ2V0U2NhbGVzKHJlc3VsdC54eU1pbk1heCwgcmFuZ2VPZmZzZXQueHlNaW5NYXgpKSA6IHJlc3VsdC52YWx1ZXM7XG4gICAgfVxuICB9LCB0aGlzKTtcbn07XG5cbnByb3RvLm1ha2VQYW5lbE9wdHMgPSBmdW5jdGlvbiAoYXBpLCBnZXREZWZhdWx0QnJ1c2hUeXBlKSB7XG4gIHJldHVybiB6clV0aWwubWFwKHRoaXMuX3RhcmdldEluZm9MaXN0LCBmdW5jdGlvbiAodGFyZ2V0SW5mbykge1xuICAgIHZhciByZWN0ID0gdGFyZ2V0SW5mby5nZXRQYW5lbFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFuZWxJZDogdGFyZ2V0SW5mby5wYW5lbElkLFxuICAgICAgZGVmYXVsdEJydXNoVHlwZTogZ2V0RGVmYXVsdEJydXNoVHlwZSAmJiBnZXREZWZhdWx0QnJ1c2hUeXBlKHRhcmdldEluZm8pLFxuICAgICAgY2xpcFBhdGg6IGJydXNoSGVscGVyLm1ha2VSZWN0UGFuZWxDbGlwUGF0aChyZWN0KSxcbiAgICAgIGlzVGFyZ2V0QnlDdXJzb3I6IGJydXNoSGVscGVyLm1ha2VSZWN0SXNUYXJnZXRCeUN1cnNvcihyZWN0LCBhcGksIHRhcmdldEluZm8uY29vcmRTeXNNb2RlbCksXG4gICAgICBnZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50OiBicnVzaEhlbHBlci5tYWtlTGluZWFyQnJ1c2hPdGhlckV4dGVudChyZWN0KVxuICAgIH07XG4gIH0pO1xufTtcblxucHJvdG8uY29udHJvbFNlcmllcyA9IGZ1bmN0aW9uIChhcmVhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAvLyBDaGVjayB3aGV0aGVyIGFyZWEgaXMgYm91bmQgaW4gY29vcmQsIGFuZCBzZXJpZXMgZG8gbm90IGJlbG9uZyB0byB0aGF0IGNvb3JkLlxuICAvLyBJZiBkbyBub3QgZG8gdGhpcyBjaGVjaywgc29tZSBicnVzaCAobGlrZSBsaW5lWCkgd2lsbCBjb250cm9sbCBhbGwgYXhlcy5cbiAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuICByZXR1cm4gdGFyZ2V0SW5mbyA9PT0gdHJ1ZSB8fCB0YXJnZXRJbmZvICYmIGluZGV4T2YodGFyZ2V0SW5mby5jb29yZFN5c2VzLCBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtKSA+PSAwO1xufTtcbi8qKlxuICogSWYgcmV0dXJuIE9iamVjdCwgYSBjb29yZCBmb3VuZC5cbiAqIElmIHJldXRybiB0cnVlLCBnbG9iYWwgZm91bmQuXG4gKiBPdGhlcndpc2Ugbm90aGluZyBmb3VuZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJlYVxuICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SW5mb0xpc3RcbiAqIEByZXR1cm4ge09iamVjdHxib29sZWFufVxuICovXG5cblxucHJvdG8uZmluZFRhcmdldEluZm8gPSBmdW5jdGlvbiAoYXJlYSwgZWNNb2RlbCkge1xuICB2YXIgdGFyZ2V0SW5mb0xpc3QgPSB0aGlzLl90YXJnZXRJbmZvTGlzdDtcbiAgdmFyIGZvdW5kQ3B0cyA9IHBhcnNlRmluZGVyKGVjTW9kZWwsIGFyZWEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0SW5mb0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGFyZ2V0SW5mbyA9IHRhcmdldEluZm9MaXN0W2ldO1xuICAgIHZhciBhcmVhUGFuZWxJZCA9IGFyZWEucGFuZWxJZDtcblxuICAgIGlmIChhcmVhUGFuZWxJZCkge1xuICAgICAgaWYgKHRhcmdldEluZm8ucGFuZWxJZCA9PT0gYXJlYVBhbmVsSWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEluZm87XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0SW5mb01hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0YXJnZXRJbmZvTWF0Y2hlcnNbaV0oZm91bmRDcHRzLCB0YXJnZXRJbmZvKSkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRNaW5NYXgobWluTWF4KSB7XG4gIG1pbk1heFswXSA+IG1pbk1heFsxXSAmJiBtaW5NYXgucmV2ZXJzZSgpO1xuICByZXR1cm4gbWluTWF4O1xufVxuXG5mdW5jdGlvbiBwYXJzZUZpbmRlcihlY01vZGVsLCBvcHRpb24pIHtcbiAgcmV0dXJuIG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBvcHRpb24sIHtcbiAgICBpbmNsdWRlTWFpblR5cGVzOiBJTkNMVURFX0ZJTkRFUl9NQUlOX1RZUEVTXG4gIH0pO1xufVxuXG52YXIgdGFyZ2V0SW5mb0J1aWxkZXJzID0ge1xuICBncmlkOiBmdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvTGlzdCkge1xuICAgIHZhciB4QXhpc01vZGVscyA9IGZvdW5kQ3B0cy54QXhpc01vZGVscztcbiAgICB2YXIgeUF4aXNNb2RlbHMgPSBmb3VuZENwdHMueUF4aXNNb2RlbHM7XG4gICAgdmFyIGdyaWRNb2RlbHMgPSBmb3VuZENwdHMuZ3JpZE1vZGVsczsgLy8gUmVtb3ZlIGR1cGxpY2F0ZWQuXG5cbiAgICB2YXIgZ3JpZE1vZGVsTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgeEF4ZXNIYXMgPSB7fTtcbiAgICB2YXIgeUF4ZXNIYXMgPSB7fTtcblxuICAgIGlmICgheEF4aXNNb2RlbHMgJiYgIXlBeGlzTW9kZWxzICYmICFncmlkTW9kZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaCh4QXhpc01vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgdmFyIGdyaWRNb2RlbCA9IGF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWw7XG4gICAgICBncmlkTW9kZWxNYXAuc2V0KGdyaWRNb2RlbC5pZCwgZ3JpZE1vZGVsKTtcbiAgICAgIHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIGVhY2goeUF4aXNNb2RlbHMsIGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsO1xuICAgICAgZ3JpZE1vZGVsTWFwLnNldChncmlkTW9kZWwuaWQsIGdyaWRNb2RlbCk7XG4gICAgICB5QXhlc0hhc1tncmlkTW9kZWwuaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBlYWNoKGdyaWRNb2RlbHMsIGZ1bmN0aW9uIChncmlkTW9kZWwpIHtcbiAgICAgIGdyaWRNb2RlbE1hcC5zZXQoZ3JpZE1vZGVsLmlkLCBncmlkTW9kZWwpO1xuICAgICAgeEF4ZXNIYXNbZ3JpZE1vZGVsLmlkXSA9IHRydWU7XG4gICAgICB5QXhlc0hhc1tncmlkTW9kZWwuaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBncmlkTW9kZWxNYXAuZWFjaChmdW5jdGlvbiAoZ3JpZE1vZGVsKSB7XG4gICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIGNhcnRlc2lhbnMgPSBbXTtcbiAgICAgIGVhY2goZ3JpZC5nZXRDYXJ0ZXNpYW5zKCksIGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleE9mKHhBeGlzTW9kZWxzLCBjYXJ0ZXNpYW4uZ2V0QXhpcygneCcpLm1vZGVsKSA+PSAwIHx8IGluZGV4T2YoeUF4aXNNb2RlbHMsIGNhcnRlc2lhbi5nZXRBeGlzKCd5JykubW9kZWwpID49IDApIHtcbiAgICAgICAgICBjYXJ0ZXNpYW5zLnB1c2goY2FydGVzaWFuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0YXJnZXRJbmZvTGlzdC5wdXNoKHtcbiAgICAgICAgcGFuZWxJZDogJ2dyaWQtLScgKyBncmlkTW9kZWwuaWQsXG4gICAgICAgIGdyaWRNb2RlbDogZ3JpZE1vZGVsLFxuICAgICAgICBjb29yZFN5c01vZGVsOiBncmlkTW9kZWwsXG4gICAgICAgIC8vIFVzZSB0aGUgZmlyc3Qgb25lIGFzIHRoZSByZXByZXNlbnRpdGl2ZSBjb29yZFN5cy5cbiAgICAgICAgY29vcmRTeXM6IGNhcnRlc2lhbnNbMF0sXG4gICAgICAgIGNvb3JkU3lzZXM6IGNhcnRlc2lhbnMsXG4gICAgICAgIGdldFBhbmVsUmVjdDogcGFuZWxSZWN0QnVpbGRlci5ncmlkLFxuICAgICAgICB4QXhpc0RlY2xhcmVkOiB4QXhlc0hhc1tncmlkTW9kZWwuaWRdLFxuICAgICAgICB5QXhpc0RlY2xhcmVkOiB5QXhlc0hhc1tncmlkTW9kZWwuaWRdXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZ2VvOiBmdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvTGlzdCkge1xuICAgIGVhY2goZm91bmRDcHRzLmdlb01vZGVscywgZnVuY3Rpb24gKGdlb01vZGVsKSB7XG4gICAgICB2YXIgY29vcmRTeXMgPSBnZW9Nb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdGFyZ2V0SW5mb0xpc3QucHVzaCh7XG4gICAgICAgIHBhbmVsSWQ6ICdnZW8tLScgKyBnZW9Nb2RlbC5pZCxcbiAgICAgICAgZ2VvTW9kZWw6IGdlb01vZGVsLFxuICAgICAgICBjb29yZFN5c01vZGVsOiBnZW9Nb2RlbCxcbiAgICAgICAgY29vcmRTeXM6IGNvb3JkU3lzLFxuICAgICAgICBjb29yZFN5c2VzOiBbY29vcmRTeXNdLFxuICAgICAgICBnZXRQYW5lbFJlY3Q6IHBhbmVsUmVjdEJ1aWxkZXIuZ2VvXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciB0YXJnZXRJbmZvTWF0Y2hlcnMgPSBbLy8gZ3JpZFxuZnVuY3Rpb24gKGZvdW5kQ3B0cywgdGFyZ2V0SW5mbykge1xuICB2YXIgeEF4aXNNb2RlbCA9IGZvdW5kQ3B0cy54QXhpc01vZGVsO1xuICB2YXIgeUF4aXNNb2RlbCA9IGZvdW5kQ3B0cy55QXhpc01vZGVsO1xuICB2YXIgZ3JpZE1vZGVsID0gZm91bmRDcHRzLmdyaWRNb2RlbDtcbiAgIWdyaWRNb2RlbCAmJiB4QXhpc01vZGVsICYmIChncmlkTW9kZWwgPSB4QXhpc01vZGVsLmF4aXMuZ3JpZC5tb2RlbCk7XG4gICFncmlkTW9kZWwgJiYgeUF4aXNNb2RlbCAmJiAoZ3JpZE1vZGVsID0geUF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWwpO1xuICByZXR1cm4gZ3JpZE1vZGVsICYmIGdyaWRNb2RlbCA9PT0gdGFyZ2V0SW5mby5ncmlkTW9kZWw7XG59LCAvLyBnZW9cbmZ1bmN0aW9uIChmb3VuZENwdHMsIHRhcmdldEluZm8pIHtcbiAgdmFyIGdlb01vZGVsID0gZm91bmRDcHRzLmdlb01vZGVsO1xuICByZXR1cm4gZ2VvTW9kZWwgJiYgZ2VvTW9kZWwgPT09IHRhcmdldEluZm8uZ2VvTW9kZWw7XG59XTtcbnZhciBwYW5lbFJlY3RCdWlsZGVyID0ge1xuICBncmlkOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZ3JpZCBpcyBub3QgVHJhbnNmb3JtYWJsZS5cbiAgICByZXR1cm4gdGhpcy5jb29yZFN5cy5ncmlkLmdldFJlY3QoKS5jbG9uZSgpO1xuICB9LFxuICBnZW86IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkU3lzO1xuICAgIHZhciByZWN0ID0gY29vcmRTeXMuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTsgLy8gZ2VvIHJvYW0gYW5kIHpvb20gdHJhbnNmb3JtXG5cbiAgICByZWN0LmFwcGx5VHJhbnNmb3JtKGdyYXBoaWMuZ2V0VHJhbnNmb3JtKGNvb3JkU3lzKSk7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbn07XG52YXIgY29vcmRDb252ZXJ0ID0ge1xuICBsaW5lWDogY3VycnkoYXhpc0NvbnZlcnQsIDApLFxuICBsaW5lWTogY3VycnkoYXhpc0NvbnZlcnQsIDEpLFxuICByZWN0OiBmdW5jdGlvbiAodG8sIGNvb3JkU3lzLCByYW5nZU9yQ29vcmRSYW5nZSkge1xuICAgIHZhciB4bWlueW1pbiA9IGNvb3JkU3lzW0NPT1JEX0NPTlZFUlRTW3RvXV0oW3JhbmdlT3JDb29yZFJhbmdlWzBdWzBdLCByYW5nZU9yQ29vcmRSYW5nZVsxXVswXV0pO1xuICAgIHZhciB4bWF4eW1heCA9IGNvb3JkU3lzW0NPT1JEX0NPTlZFUlRTW3RvXV0oW3JhbmdlT3JDb29yZFJhbmdlWzBdWzFdLCByYW5nZU9yQ29vcmRSYW5nZVsxXVsxXV0pO1xuICAgIHZhciB2YWx1ZXMgPSBbZm9ybWF0TWluTWF4KFt4bWlueW1pblswXSwgeG1heHltYXhbMF1dKSwgZm9ybWF0TWluTWF4KFt4bWlueW1pblsxXSwgeG1heHltYXhbMV1dKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgeHlNaW5NYXg6IHZhbHVlc1xuICAgIH07XG4gIH0sXG4gIHBvbHlnb246IGZ1bmN0aW9uICh0bywgY29vcmRTeXMsIHJhbmdlT3JDb29yZFJhbmdlKSB7XG4gICAgdmFyIHh5TWluTWF4ID0gW1tJbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCAtSW5maW5pdHldXTtcbiAgICB2YXIgdmFsdWVzID0genJVdGlsLm1hcChyYW5nZU9yQ29vcmRSYW5nZSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBwID0gY29vcmRTeXNbQ09PUkRfQ09OVkVSVFNbdG9dXShpdGVtKTtcbiAgICAgIHh5TWluTWF4WzBdWzBdID0gTWF0aC5taW4oeHlNaW5NYXhbMF1bMF0sIHBbMF0pO1xuICAgICAgeHlNaW5NYXhbMV1bMF0gPSBNYXRoLm1pbih4eU1pbk1heFsxXVswXSwgcFsxXSk7XG4gICAgICB4eU1pbk1heFswXVsxXSA9IE1hdGgubWF4KHh5TWluTWF4WzBdWzFdLCBwWzBdKTtcbiAgICAgIHh5TWluTWF4WzFdWzFdID0gTWF0aC5tYXgoeHlNaW5NYXhbMV1bMV0sIHBbMV0pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgeHlNaW5NYXg6IHh5TWluTWF4XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXhpc0NvbnZlcnQoYXhpc05hbWVJbmRleCwgdG8sIGNvb3JkU3lzLCByYW5nZU9yQ29vcmRSYW5nZSkge1xuICB2YXIgYXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoWyd4JywgJ3knXVtheGlzTmFtZUluZGV4XSk7XG4gIHZhciB2YWx1ZXMgPSBmb3JtYXRNaW5NYXgoenJVdGlsLm1hcChbMCwgMV0sIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIHRvID8gYXhpcy5jb29yZFRvRGF0YShheGlzLnRvTG9jYWxDb29yZChyYW5nZU9yQ29vcmRSYW5nZVtpXSkpIDogYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQocmFuZ2VPckNvb3JkUmFuZ2VbaV0pKTtcbiAgfSkpO1xuICB2YXIgeHlNaW5NYXggPSBbXTtcbiAgeHlNaW5NYXhbYXhpc05hbWVJbmRleF0gPSB2YWx1ZXM7XG4gIHh5TWluTWF4WzEgLSBheGlzTmFtZUluZGV4XSA9IFtOYU4sIE5hTl07XG4gIHJldHVybiB7XG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgeHlNaW5NYXg6IHh5TWluTWF4XG4gIH07XG59XG5cbnZhciBkaWZmUHJvY2Vzc29yID0ge1xuICBsaW5lWDogY3VycnkoYXhpc0RpZmZQcm9jZXNzb3IsIDApLFxuICBsaW5lWTogY3VycnkoYXhpc0RpZmZQcm9jZXNzb3IsIDEpLFxuICByZWN0OiBmdW5jdGlvbiAodmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gICAgcmV0dXJuIFtbdmFsdWVzWzBdWzBdIC0gc2NhbGVzWzBdICogcmVmZXJbMF1bMF0sIHZhbHVlc1swXVsxXSAtIHNjYWxlc1swXSAqIHJlZmVyWzBdWzFdXSwgW3ZhbHVlc1sxXVswXSAtIHNjYWxlc1sxXSAqIHJlZmVyWzFdWzBdLCB2YWx1ZXNbMV1bMV0gLSBzY2FsZXNbMV0gKiByZWZlclsxXVsxXV1dO1xuICB9LFxuICBwb2x5Z29uOiBmdW5jdGlvbiAodmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbiAoaXRlbSwgaWR4KSB7XG4gICAgICByZXR1cm4gW2l0ZW1bMF0gLSBzY2FsZXNbMF0gKiByZWZlcltpZHhdWzBdLCBpdGVtWzFdIC0gc2NhbGVzWzFdICogcmVmZXJbaWR4XVsxXV07XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGF4aXNEaWZmUHJvY2Vzc29yKGF4aXNOYW1lSW5kZXgsIHZhbHVlcywgcmVmZXIsIHNjYWxlcykge1xuICByZXR1cm4gW3ZhbHVlc1swXSAtIHNjYWxlc1theGlzTmFtZUluZGV4XSAqIHJlZmVyWzBdLCB2YWx1ZXNbMV0gLSBzY2FsZXNbYXhpc05hbWVJbmRleF0gKiByZWZlclsxXV07XG59IC8vIFdlIGhhdmUgdG8gcHJvY2VzcyBzY2FsZSBjYXVzZWQgYnkgZGF0YVpvb20gbWFudWFsbHksXG4vLyBhbHRob3VnaCBpdCBtaWdodCBiZSBub3QgYWNjdXJhdGUuXG5cblxuZnVuY3Rpb24gZ2V0U2NhbGVzKHh5TWluTWF4Q3VyciwgeHlNaW5NYXhPcmlnaW4pIHtcbiAgdmFyIHNpemVDdXJyID0gZ2V0U2l6ZSh4eU1pbk1heEN1cnIpO1xuICB2YXIgc2l6ZU9yaWdpbiA9IGdldFNpemUoeHlNaW5NYXhPcmlnaW4pO1xuICB2YXIgc2NhbGVzID0gW3NpemVDdXJyWzBdIC8gc2l6ZU9yaWdpblswXSwgc2l6ZUN1cnJbMV0gLyBzaXplT3JpZ2luWzFdXTtcbiAgaXNOYU4oc2NhbGVzWzBdKSAmJiAoc2NhbGVzWzBdID0gMSk7XG4gIGlzTmFOKHNjYWxlc1sxXSkgJiYgKHNjYWxlc1sxXSA9IDEpO1xuICByZXR1cm4gc2NhbGVzO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKHh5TWluTWF4KSB7XG4gIHJldHVybiB4eU1pbk1heCA/IFt4eU1pbk1heFswXVsxXSAtIHh5TWluTWF4WzBdWzBdLCB4eU1pbk1heFsxXVsxXSAtIHh5TWluTWF4WzFdWzBdXSA6IFtOYU4sIE5hTl07XG59XG5cbnZhciBfZGVmYXVsdCA9IEJydXNoVGFyZ2V0TWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaFRhcmdldE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hUYXJnZXRNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bFwiKTtcblxudmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgaW50ZXJhY3Rpb25NdXRleCA9IHJlcXVpcmUoXCIuL2ludGVyYWN0aW9uTXV0ZXhcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWl4aW4ge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvenJlbmRlcn5aUmVuZGVyfSB6clxuICovXG5mdW5jdGlvbiBSb2FtQ29udHJvbGxlcih6cikge1xuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgdGhpcy5wb2ludGVyQ2hlY2tlcjtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlcn1cbiAgICovXG5cbiAgdGhpcy5fenIgPSB6cjtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX29wdCA9IHt9OyAvLyBBdm9pZCB0d28gcm9hbUNvbnRyb2xsZXIgYmluZCB0aGUgc2FtZSBoYW5kbGVyXG5cbiAgdmFyIGJpbmQgPSB6clV0aWwuYmluZDtcbiAgdmFyIG1vdXNlZG93bkhhbmRsZXIgPSBiaW5kKG1vdXNlZG93biwgdGhpcyk7XG4gIHZhciBtb3VzZW1vdmVIYW5kbGVyID0gYmluZChtb3VzZW1vdmUsIHRoaXMpO1xuICB2YXIgbW91c2V1cEhhbmRsZXIgPSBiaW5kKG1vdXNldXAsIHRoaXMpO1xuICB2YXIgbW91c2V3aGVlbEhhbmRsZXIgPSBiaW5kKG1vdXNld2hlZWwsIHRoaXMpO1xuICB2YXIgcGluY2hIYW5kbGVyID0gYmluZChwaW5jaCwgdGhpcyk7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb2ludGVyQ2hlY2tlclxuICAgKiAgICAgICAgICAgICAgICAgICBpbnB1dDogeCwgeVxuICAgKiAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGJvb2xlYW5cbiAgICovXG5cbiAgdGhpcy5zZXRQb2ludGVyQ2hlY2tlciA9IGZ1bmN0aW9uIChwb2ludGVyQ2hlY2tlcikge1xuICAgIHRoaXMucG9pbnRlckNoZWNrZXIgPSBwb2ludGVyQ2hlY2tlcjtcbiAgfTtcbiAgLyoqXG4gICAqIE5vdGljZTogb25seSBlbmFibGUgbmVlZGVkIHR5cGVzLiBGb3IgZXhhbXBsZSwgaWYgJ3pvb20nXG4gICAqIGlzIG5vdCBuZWVkZWQsICd6b29tJyBzaG91bGQgbm90IGJlIGVuYWJsZWQsIG90aGVyd2lzZVxuICAgKiBkZWZhdWx0IG1vdXNld2hlZWwgYmVoYXZpb3VyIChzY3JvbGwgcGFnZSkgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbnxzdHJpbmd9IFtjb250cm9sVHlwZT10cnVlXSBTcGVjaWZ5IHRoZSBjb250cm9sIHR5cGUsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBjYW4gYmUgbnVsbC91bmRlZmluZWQgb3IgdHJ1ZS9mYWxzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgJ3Bhbi9tb3ZlJyBvciAnem9vbScvJ3NjYWxlJ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHQuem9vbU9uTW91c2VXaGVlbD10cnVlXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5tb3ZlT25Nb3VzZU1vdmU9dHJ1ZV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHQucHJldmVudERlZmF1bHRNb3VzZU1vdmU9dHJ1ZV0gV2hlbiBwYW4uXG4gICAqL1xuXG5cbiAgdGhpcy5lbmFibGUgPSBmdW5jdGlvbiAoY29udHJvbFR5cGUsIG9wdCkge1xuICAgIC8vIERpc2FibGUgcHJldmlvdXMgZmlyc3RcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB0aGlzLl9vcHQgPSB6clV0aWwuZGVmYXVsdHMoenJVdGlsLmNsb25lKG9wdCkgfHwge30sIHtcbiAgICAgIHpvb21Pbk1vdXNlV2hlZWw6IHRydWUsXG4gICAgICBtb3ZlT25Nb3VzZU1vdmU6IHRydWUsXG4gICAgICBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKGNvbnRyb2xUeXBlID09IG51bGwpIHtcbiAgICAgIGNvbnRyb2xUeXBlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY29udHJvbFR5cGUgPT09IHRydWUgfHwgY29udHJvbFR5cGUgPT09ICdtb3ZlJyB8fCBjb250cm9sVHlwZSA9PT0gJ3BhbicpIHtcbiAgICAgIHpyLm9uKCdtb3VzZWRvd24nLCBtb3VzZWRvd25IYW5kbGVyKTtcbiAgICAgIHpyLm9uKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmVIYW5kbGVyKTtcbiAgICAgIHpyLm9uKCdtb3VzZXVwJywgbW91c2V1cEhhbmRsZXIpO1xuICAgIH1cblxuICAgIGlmIChjb250cm9sVHlwZSA9PT0gdHJ1ZSB8fCBjb250cm9sVHlwZSA9PT0gJ3NjYWxlJyB8fCBjb250cm9sVHlwZSA9PT0gJ3pvb20nKSB7XG4gICAgICB6ci5vbignbW91c2V3aGVlbCcsIG1vdXNld2hlZWxIYW5kbGVyKTtcbiAgICAgIHpyLm9uKCdwaW5jaCcsIHBpbmNoSGFuZGxlcik7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB6ci5vZmYoJ21vdXNlZG93bicsIG1vdXNlZG93bkhhbmRsZXIpO1xuICAgIHpyLm9mZignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlSGFuZGxlcik7XG4gICAgenIub2ZmKCdtb3VzZXVwJywgbW91c2V1cEhhbmRsZXIpO1xuICAgIHpyLm9mZignbW91c2V3aGVlbCcsIG1vdXNld2hlZWxIYW5kbGVyKTtcbiAgICB6ci5vZmYoJ3BpbmNoJywgcGluY2hIYW5kbGVyKTtcbiAgfTtcblxuICB0aGlzLmRpc3Bvc2UgPSB0aGlzLmRpc2FibGU7XG5cbiAgdGhpcy5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kcmFnZ2luZztcbiAgfTtcblxuICB0aGlzLmlzUGluY2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BpbmNoaW5nO1xuICB9O1xufVxuXG56clV0aWwubWl4aW4oUm9hbUNvbnRyb2xsZXIsIEV2ZW50ZnVsKTtcblxuZnVuY3Rpb24gbW91c2Vkb3duKGUpIHtcbiAgaWYgKGV2ZW50VG9vbC5ub3RMZWZ0TW91c2UoZSkgfHwgZS50YXJnZXQgJiYgZS50YXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHggPSBlLm9mZnNldFg7XG4gIHZhciB5ID0gZS5vZmZzZXRZOyAvLyBPbmx5IGNoZWNrIG9uIG1vc2Vkb3duLCBidXQgbm90IG1vdXNlbW92ZS5cbiAgLy8gTW91c2UgY2FuIGJlIG91dCBvZiB0YXJnZXQgd2hlbiBtb3VzZSBtb3ZpbmcuXG5cbiAgaWYgKHRoaXMucG9pbnRlckNoZWNrZXIgJiYgdGhpcy5wb2ludGVyQ2hlY2tlcihlLCB4LCB5KSkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xuICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VzZW1vdmUoZSkge1xuICBpZiAoZXZlbnRUb29sLm5vdExlZnRNb3VzZShlKSB8fCAhY2hlY2tLZXlCaW5kaW5nKHRoaXMsICdtb3ZlT25Nb3VzZU1vdmUnLCBlKSB8fCAhdGhpcy5fZHJhZ2dpbmcgfHwgZS5nZXN0dXJlRXZlbnQgPT09ICdwaW5jaCcgfHwgaW50ZXJhY3Rpb25NdXRleC5pc1Rha2VuKHRoaXMuX3pyLCAnZ2xvYmFsUGFuJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgdmFyIHkgPSBlLm9mZnNldFk7XG4gIHZhciBvbGRYID0gdGhpcy5feDtcbiAgdmFyIG9sZFkgPSB0aGlzLl95O1xuICB2YXIgZHggPSB4IC0gb2xkWDtcbiAgdmFyIGR5ID0geSAtIG9sZFk7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl95ID0geTtcbiAgdGhpcy5fb3B0LnByZXZlbnREZWZhdWx0TW91c2VNb3ZlICYmIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICB0aGlzLnRyaWdnZXIoJ3BhbicsIGR4LCBkeSwgb2xkWCwgb2xkWSwgeCwgeSk7XG59XG5cbmZ1bmN0aW9uIG1vdXNldXAoZSkge1xuICBpZiAoIWV2ZW50VG9vbC5ub3RMZWZ0TW91c2UoZSkpIHtcbiAgICB0aGlzLl9kcmFnZ2luZyA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdXNld2hlZWwoZSkge1xuICAvLyB3aGVlbERlbHRhIG1heWJlIC0wIGluIGNocm9tZSBtYWMuXG4gIGlmICghY2hlY2tLZXlCaW5kaW5nKHRoaXMsICd6b29tT25Nb3VzZVdoZWVsJywgZSkgfHwgZS53aGVlbERlbHRhID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENvbnZlbmllbmNlOlxuICAvLyBNYWMgYW5kIFZNIFdpbmRvd3Mgb24gTWFjOiBzY3JvbGwgdXA6IHpvb20gb3V0LlxuICAvLyBXaW5kb3dzOiBzY3JvbGwgdXA6IHpvb20gaW4uXG5cblxuICB2YXIgem9vbURlbHRhID0gZS53aGVlbERlbHRhID4gMCA/IDEuMSA6IDEgLyAxLjE7XG4gIHpvb20uY2FsbCh0aGlzLCBlLCB6b29tRGVsdGEsIGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcbn1cblxuZnVuY3Rpb24gcGluY2goZSkge1xuICBpZiAoaW50ZXJhY3Rpb25NdXRleC5pc1Rha2VuKHRoaXMuX3pyLCAnZ2xvYmFsUGFuJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgem9vbURlbHRhID0gZS5waW5jaFNjYWxlID4gMSA/IDEuMSA6IDEgLyAxLjE7XG4gIHpvb20uY2FsbCh0aGlzLCBlLCB6b29tRGVsdGEsIGUucGluY2hYLCBlLnBpbmNoWSk7XG59XG5cbmZ1bmN0aW9uIHpvb20oZSwgem9vbURlbHRhLCB6b29tWCwgem9vbVkpIHtcbiAgaWYgKHRoaXMucG9pbnRlckNoZWNrZXIgJiYgdGhpcy5wb2ludGVyQ2hlY2tlcihlLCB6b29tWCwgem9vbVkpKSB7XG4gICAgLy8gV2hlbiBtb3VzZSBpcyBvdXQgb2Ygcm9hbUNvbnRyb2xsZXIgcmVjdCxcbiAgICAvLyBkZWZhdWx0IGJlZmF2b2l1cyBzaG91bGQgbm90IGJlIGJlIGRpc2FibGVkLCBvdGhlcndpc2VcbiAgICAvLyBwYWdlIHNsaWRpbmcgaXMgZGlzYWJsZWQsIGNvbnRyYXJ5IHRvIGV4cGVjdGF0aW9uLlxuICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICAgIHRoaXMudHJpZ2dlcignem9vbScsIHpvb21EZWx0YSwgem9vbVgsIHpvb21ZKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0tleUJpbmRpbmcocm9hbUNvbnRyb2xsZXIsIHByb3AsIGUpIHtcbiAgdmFyIHNldHRpbmcgPSByb2FtQ29udHJvbGxlci5fb3B0W3Byb3BdO1xuICByZXR1cm4gc2V0dGluZyAmJiAoIXpyVXRpbC5pc1N0cmluZyhzZXR0aW5nKSB8fCBlLmV2ZW50W3NldHRpbmcgKyAnS2V5J10pO1xufVxuXG52YXIgX2RlZmF1bHQgPSBSb2FtQ29udHJvbGxlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBfY3Vyc29ySGVscGVyID0gcmVxdWlyZShcIi4vY3Vyc29ySGVscGVyXCIpO1xuXG52YXIgb25JcnJlbGV2YW50RWxlbWVudCA9IF9jdXJzb3JIZWxwZXIub25JcnJlbGV2YW50RWxlbWVudDtcblxudmFyIGdyYXBoaWNVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuZnVuY3Rpb24gbWFrZVJlY3RQYW5lbENsaXBQYXRoKHJlY3QpIHtcbiAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gIHJldHVybiBmdW5jdGlvbiAobG9jYWxQb2ludHMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBncmFwaGljVXRpbC5jbGlwUG9pbnRzQnlSZWN0KGxvY2FsUG9pbnRzLCByZWN0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZUxpbmVhckJydXNoT3RoZXJFeHRlbnQocmVjdCwgc3BlY2lmaWVkWFlJbmRleCkge1xuICByZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4eUluZGV4KSB7XG4gICAgdmFyIGlkeCA9IHNwZWNpZmllZFhZSW5kZXggIT0gbnVsbCA/IHNwZWNpZmllZFhZSW5kZXggOiB4eUluZGV4O1xuICAgIHZhciBicnVzaFdpZHRoID0gaWR4ID8gcmVjdC53aWR0aCA6IHJlY3QuaGVpZ2h0O1xuICAgIHZhciBiYXNlID0gaWR4ID8gcmVjdC54IDogcmVjdC55O1xuICAgIHJldHVybiBbYmFzZSwgYmFzZSArIChicnVzaFdpZHRoIHx8IDApXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZVJlY3RJc1RhcmdldEJ5Q3Vyc29yKHJlY3QsIGFwaSwgdGFyZ2V0TW9kZWwpIHtcbiAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gIHJldHVybiBmdW5jdGlvbiAoZSwgbG9jYWxDdXJzb3JQb2ludCwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHJlY3QuY29udGFpbihsb2NhbEN1cnNvclBvaW50WzBdLCBsb2NhbEN1cnNvclBvaW50WzFdKSAmJiAhb25JcnJlbGV2YW50RWxlbWVudChlLCBhcGksIHRhcmdldE1vZGVsKTtcbiAgfTtcbn0gLy8gQ29uc2lkZXIgd2lkdGgvaGVpZ2h0IGlzIG5lZ2F0aXZlLlxuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICByZXR1cm4gQm91bmRpbmdSZWN0LmNyZWF0ZShyZWN0KTtcbn1cblxuZXhwb3J0cy5tYWtlUmVjdFBhbmVsQ2xpcFBhdGggPSBtYWtlUmVjdFBhbmVsQ2xpcFBhdGg7XG5leHBvcnRzLm1ha2VMaW5lYXJCcnVzaE90aGVyRXh0ZW50ID0gbWFrZUxpbmVhckJydXNoT3RoZXJFeHRlbnQ7XG5leHBvcnRzLm1ha2VSZWN0SXNUYXJnZXRCeUN1cnNvciA9IG1ha2VSZWN0SXNUYXJnZXRCeUN1cnNvcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2JydXNoSGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2JydXNoSGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIElSUkVMRVZBTlRfRVhDTFVERVMgPSB7XG4gICdheGlzUG9pbnRlcic6IDEsXG4gICd0b29sdGlwJzogMSxcbiAgJ2JydXNoJzogMVxufTtcbi8qKlxuICogQXZvaWQgdGhhdDogbW91c2UgY2xpY2sgb24gYSBlbGVtZW50cyB0aGF0IGlzIG92ZXIgZ2VvIG9yIGdyYXBoLFxuICogYnV0IHJvYW0gaXMgdHJpZ2dlcmVkLlxuICovXG5cbmZ1bmN0aW9uIG9uSXJyZWxldmFudEVsZW1lbnQoZSwgYXBpLCB0YXJnZXRDb29yZFN5c01vZGVsKSB7XG4gIHZhciBtb2RlbCA9IGFwaS5nZXRDb21wb25lbnRCeUVsZW1lbnQoZS50b3BUYXJnZXQpOyAvLyBJZiBtb2RlbCBpcyBheGlzTW9kZWwsIGl0IHdvcmtzIG9ubHkgaWYgaXQgaXMgaW5qZWN0ZWQgd2l0aCBjb29yZGluYXRlU3lzdGVtLlxuXG4gIHZhciBjb29yZFN5cyA9IG1vZGVsICYmIG1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIHJldHVybiBtb2RlbCAmJiBtb2RlbCAhPT0gdGFyZ2V0Q29vcmRTeXNNb2RlbCAmJiAhSVJSRUxFVkFOVF9FWENMVURFU1ttb2RlbC5tYWluVHlwZV0gJiYgY29vcmRTeXMgJiYgY29vcmRTeXMubW9kZWwgIT09IHRhcmdldENvb3JkU3lzTW9kZWw7XG59XG5cbmV4cG9ydHMub25JcnJlbGV2YW50RWxlbWVudCA9IG9uSXJyZWxldmFudEVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9jdXJzb3JIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvY3Vyc29ySGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIEFUVFIgPSAnXFwwX2VjX2ludGVyYWN0aW9uX211dGV4JztcblxuZnVuY3Rpb24gdGFrZSh6ciwgcmVzb3VyY2VLZXksIHVzZXJLZXkpIHtcbiAgdmFyIHN0b3JlID0gZ2V0U3RvcmUoenIpO1xuICBzdG9yZVtyZXNvdXJjZUtleV0gPSB1c2VyS2V5O1xufVxuXG5mdW5jdGlvbiByZWxlYXNlKHpyLCByZXNvdXJjZUtleSwgdXNlcktleSkge1xuICB2YXIgc3RvcmUgPSBnZXRTdG9yZSh6cik7XG4gIHZhciB1S2V5ID0gc3RvcmVbcmVzb3VyY2VLZXldO1xuXG4gIGlmICh1S2V5ID09PSB1c2VyS2V5KSB7XG4gICAgc3RvcmVbcmVzb3VyY2VLZXldID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1Rha2VuKHpyLCByZXNvdXJjZUtleSkge1xuICByZXR1cm4gISFnZXRTdG9yZSh6cilbcmVzb3VyY2VLZXldO1xufVxuXG5mdW5jdGlvbiBnZXRTdG9yZSh6cikge1xuICByZXR1cm4genJbQVRUUl0gfHwgKHpyW0FUVFJdID0ge30pO1xufVxuLyoqXG4gKiBwYXlsb2FkOiB7XG4gKiAgICAgdHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLFxuICogICAgIGtleTogJ2RhdGFab29tU2VsZWN0Jywgb3IgJ2JydXNoJywgb3IgLi4uLFxuICogICAgICAgICBJZiBubyB1c2VyS2V5LCByZWxlYXNlIGdsb2JhbCBjdXJzb3IuXG4gKiB9XG4gKi9cblxuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLFxuICBldmVudDogJ2dsb2JhbEN1cnNvclRha2VuJyxcbiAgdXBkYXRlOiAndXBkYXRlJ1xufSwgZnVuY3Rpb24gKCkge30pO1xuZXhwb3J0cy50YWtlID0gdGFrZTtcbmV4cG9ydHMucmVsZWFzZSA9IHJlbGVhc2U7XG5leHBvcnRzLmlzVGFrZW4gPSBpc1Rha2VuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvaW50ZXJhY3Rpb25NdXRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9pbnRlcmFjdGlvbk11dGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9sYXlvdXQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBnZXRMYXlvdXRSZWN0ID0gX2xheW91dC5nZXRMYXlvdXRSZWN0O1xudmFyIGxheW91dEJveCA9IF9sYXlvdXQuYm94O1xudmFyIHBvc2l0aW9uRWxlbWVudCA9IF9sYXlvdXQucG9zaXRpb25FbGVtZW50O1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogTGF5b3V0IGxpc3QgbGlrZSBjb21wb25lbnQuXG4gKiBJdCB3aWxsIGJveCBsYXlvdXQgZWFjaCBpdGVtcyBpbiBncm91cCBvZiBjb21wb25lbnQgYW5kIHRoZW4gcG9zaXRpb24gdGhlIHdob2xlIGdyb3VwIGluIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncm91cC9Hcm91cH0gZ3JvdXBcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBjb21wb25lbnRNb2RlbFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gKi9cbmZ1bmN0aW9uIGxheW91dChncm91cCwgY29tcG9uZW50TW9kZWwsIGFwaSkge1xuICB2YXIgYm94TGF5b3V0UGFyYW1zID0gY29tcG9uZW50TW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCk7XG4gIHZhciBwYWRkaW5nID0gY29tcG9uZW50TW9kZWwuZ2V0KCdwYWRkaW5nJyk7XG4gIHZhciB2aWV3cG9ydFNpemUgPSB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH07XG4gIHZhciByZWN0ID0gZ2V0TGF5b3V0UmVjdChib3hMYXlvdXRQYXJhbXMsIHZpZXdwb3J0U2l6ZSwgcGFkZGluZyk7XG4gIGxheW91dEJveChjb21wb25lbnRNb2RlbC5nZXQoJ29yaWVudCcpLCBncm91cCwgY29tcG9uZW50TW9kZWwuZ2V0KCdpdGVtR2FwJyksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgcG9zaXRpb25FbGVtZW50KGdyb3VwLCBib3hMYXlvdXRQYXJhbXMsIHZpZXdwb3J0U2l6ZSwgcGFkZGluZyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VCYWNrZ3JvdW5kKHJlY3QsIGNvbXBvbmVudE1vZGVsKSB7XG4gIHZhciBwYWRkaW5nID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShjb21wb25lbnRNb2RlbC5nZXQoJ3BhZGRpbmcnKSk7XG4gIHZhciBzdHlsZSA9IGNvbXBvbmVudE1vZGVsLmdldEl0ZW1TdHlsZShbJ2NvbG9yJywgJ29wYWNpdHknXSk7XG4gIHN0eWxlLmZpbGwgPSBjb21wb25lbnRNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHNoYXBlOiB7XG4gICAgICB4OiByZWN0LnggLSBwYWRkaW5nWzNdLFxuICAgICAgeTogcmVjdC55IC0gcGFkZGluZ1swXSxcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoICsgcGFkZGluZ1sxXSArIHBhZGRpbmdbM10sXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl0sXG4gICAgICByOiBjb21wb25lbnRNb2RlbC5nZXQoJ2JvcmRlclJhZGl1cycpXG4gICAgfSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgc2lsZW50OiB0cnVlLFxuICAgIHoyOiAtMVxuICB9KTsgLy8gRklYTUVcbiAgLy8gYHN1YlBpeGVsT3B0aW1pemVSZWN0YCBtYXkgYnJpbmcgc29tZSBnYXAgYmV0d2VlbiBlZGdlIG9mIHZpZXdwYXJ0XG4gIC8vIGFuZCBiYWNrZ3JvdW5kIHJlY3Qgd2hlbiBzZXR0aW5nIGxpa2UgYGxlZnQ6IDBgLCBgdG9wOiAwYC5cbiAgLy8gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdChyZWN0KTtcblxuICByZXR1cm4gcmVjdDtcbn1cblxuZXhwb3J0cy5sYXlvdXQgPSBsYXlvdXQ7XG5leHBvcnRzLm1ha2VCYWNrZ3JvdW5kID0gbWFrZUJhY2tncm91bmQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9saXN0Q29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2xpc3RDb21wb25lbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQ2FsY3VsYXRlIHNsaWRlciBtb3ZlIHJlc3VsdC5cbiAqIFVzYWdlOlxuICogKDEpIElmIGJvdGggaGFuZGxlMCBhbmQgaGFuZGxlMSBhcmUgbmVlZGVkIHRvIGJlIG1vdmVkLCBzZXQgbWluU3BhbiB0aGUgc2FtZSBhc1xuICogbWF4U3BhbiBhbmQgdGhlIHNhbWUgYXMgYE1hdGguYWJzKGhhbmRsZUVuZFsxXSAtIGhhbmRsZUVuZHNbMF0pYC5cbiAqICgyKSBJZiBoYW5kbGUwIGlzIGZvcmJpZGRlbiB0byBjcm9zcyBoYW5kbGUxLCBzZXQgbWluU3BhbiBhcyBgMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIE1vdmUgbGVuZ3RoLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaGFuZGxlRW5kcyBoYW5kbGVFbmRzWzBdIGNhbiBiZSBiaWdnZXIgdGhlbiBoYW5kbGVFbmRzWzFdLlxuICogICAgICAgICAgICAgIGhhbmRsZUVuZHMgd2lsbCBiZSBtb2RpZmllZCBpbiB0aGlzIG1ldGhvZC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGV4dGVudCBoYW5kbGVFbmRzIGlzIHJlc3RyaWN0ZWQgYnkgZXh0ZW50LlxuICogICAgICAgICAgICAgIGV4dGVudFswXSBzaG91bGQgbGVzcyBvciBlcXVhbHMgdGhhbiBleHRlbnRbMV0uXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGhhbmRsZUluZGV4IENhbiBiZSAnYWxsJywgbWVhbnMgdGhhdCBib3RoIG1vdmUgdGhlIHR3byBoYW5kbGVFbmRzLFxuICogICAgICAgICAgICAgIHdoZXJlIHRoZSBpbnB1dCBtaW5TcGFuIGFuZCBtYXhTcGFuIHdpbGwgbm90IHdvcmsuXG4gKiBAcGFyYW0ge251bWJlcn0gW21pblNwYW5dIFRoZSByYW5nZSBvZiBkYXRhWm9vbSBjYW4gbm90IGJlIHNtYWxsZXIgdGhhbiB0aGF0LlxuICogICAgICAgICAgICAgIElmIG5vdCBzZXQsIGhhbmRsZTAgYW5kIGNyb3NzIGhhbmRsZTEuIElmIHNldCBhcyBhIG5vbi1uZWdhdGl2ZVxuICogICAgICAgICAgICAgIG51bWJlciAoaW5jbHVkaW5nIGAwYCksIGhhbmRsZXMgd2lsbCBwdXNoIGVhY2ggb3RoZXIgd2hlbiByZWFjaGluZ1xuICogICAgICAgICAgICAgIHRoZSBtaW5TcGFuLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhTcGFuXSBUaGUgcmFuZ2Ugb2YgZGF0YVpvb20gY2FuIG5vdCBiZSBsYXJnZXIgdGhhbiB0aGF0LlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFRoZSBpbnB1dCBoYW5kbGVFbmRzLlxuICovXG5mdW5jdGlvbiBfZGVmYXVsdChkZWx0YSwgaGFuZGxlRW5kcywgZXh0ZW50LCBoYW5kbGVJbmRleCwgbWluU3BhbiwgbWF4U3Bhbikge1xuICAvLyBOb3JtYWxpemUgZmlyc3RseS5cbiAgaGFuZGxlRW5kc1swXSA9IHJlc3RyaWN0KGhhbmRsZUVuZHNbMF0sIGV4dGVudCk7XG4gIGhhbmRsZUVuZHNbMV0gPSByZXN0cmljdChoYW5kbGVFbmRzWzFdLCBleHRlbnQpO1xuICBkZWx0YSA9IGRlbHRhIHx8IDA7XG4gIHZhciBleHRlbnRTcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdOyAvLyBOb3RpY2UgbWF4U3BhbiBhbmQgbWluU3BhbiBjYW4gYmUgbnVsbC91bmRlZmluZWQuXG5cbiAgaWYgKG1pblNwYW4gIT0gbnVsbCkge1xuICAgIG1pblNwYW4gPSByZXN0cmljdChtaW5TcGFuLCBbMCwgZXh0ZW50U3Bhbl0pO1xuICB9XG5cbiAgaWYgKG1heFNwYW4gIT0gbnVsbCkge1xuICAgIG1heFNwYW4gPSBNYXRoLm1heChtYXhTcGFuLCBtaW5TcGFuICE9IG51bGwgPyBtaW5TcGFuIDogMCk7XG4gIH1cblxuICBpZiAoaGFuZGxlSW5kZXggPT09ICdhbGwnKSB7XG4gICAgbWluU3BhbiA9IG1heFNwYW4gPSBNYXRoLmFicyhoYW5kbGVFbmRzWzFdIC0gaGFuZGxlRW5kc1swXSk7XG4gICAgaGFuZGxlSW5kZXggPSAwO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsRGlzdFNpZ24gPSBnZXRTcGFuU2lnbihoYW5kbGVFbmRzLCBoYW5kbGVJbmRleCk7XG4gIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICs9IGRlbHRhOyAvLyBSZXN0cmljdCBpbiBleHRlbnQuXG5cbiAgdmFyIGV4dGVudE1pblNwYW4gPSBtaW5TcGFuIHx8IDA7XG4gIHZhciByZWFsRXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gIG9yaWdpbmFsRGlzdFNpZ24uc2lnbiA8IDAgPyByZWFsRXh0ZW50WzBdICs9IGV4dGVudE1pblNwYW4gOiByZWFsRXh0ZW50WzFdIC09IGV4dGVudE1pblNwYW47XG4gIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdID0gcmVzdHJpY3QoaGFuZGxlRW5kc1toYW5kbGVJbmRleF0sIHJlYWxFeHRlbnQpOyAvLyBFeHBhbmQgc3Bhbi5cblxuICB2YXIgY3VyckRpc3RTaWduID0gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpO1xuXG4gIGlmIChtaW5TcGFuICE9IG51bGwgJiYgKGN1cnJEaXN0U2lnbi5zaWduICE9PSBvcmlnaW5hbERpc3RTaWduLnNpZ24gfHwgY3VyckRpc3RTaWduLnNwYW4gPCBtaW5TcGFuKSkge1xuICAgIC8vIElmIG1pblNwYW4gZXhpc3RzLCAnY3Jvc3MnIGlzIGZvcmJpbmRlbi5cbiAgICBoYW5kbGVFbmRzWzEgLSBoYW5kbGVJbmRleF0gPSBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSArIG9yaWdpbmFsRGlzdFNpZ24uc2lnbiAqIG1pblNwYW47XG4gIH0gLy8gU2hyaW5rIHNwYW4uXG5cblxuICB2YXIgY3VyckRpc3RTaWduID0gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpO1xuXG4gIGlmIChtYXhTcGFuICE9IG51bGwgJiYgY3VyckRpc3RTaWduLnNwYW4gPiBtYXhTcGFuKSB7XG4gICAgaGFuZGxlRW5kc1sxIC0gaGFuZGxlSW5kZXhdID0gaGFuZGxlRW5kc1toYW5kbGVJbmRleF0gKyBjdXJyRGlzdFNpZ24uc2lnbiAqIG1heFNwYW47XG4gIH1cblxuICByZXR1cm4gaGFuZGxlRW5kcztcbn1cblxuZnVuY3Rpb24gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpIHtcbiAgdmFyIGRpc3QgPSBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSAtIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XTsgLy8gSWYgYGhhbmRsZUVuZHNbMF0gPT09IGhhbmRsZUVuZHNbMV1gLCBhbHdheXMgYmVsaWV2ZSB0aGF0IGhhbmRsZUVuZFswXVxuICAvLyBpcyBhdCBsZWZ0IG9mIGhhbmRsZUVuZHNbMV0gZm9yIG5vbi1jcm9zcyBjYXNlLlxuXG4gIHJldHVybiB7XG4gICAgc3BhbjogTWF0aC5hYnMoZGlzdCksXG4gICAgc2lnbjogZGlzdCA+IDAgPyAtMSA6IGRpc3QgPCAwID8gMSA6IGhhbmRsZUluZGV4ID8gLTEgOiAxXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc3RyaWN0KHZhbHVlLCBleHRlbmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKGV4dGVuZFsxXSwgTWF0aC5tYXgoZXh0ZW5kWzBdLCB2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvc2xpZGVyTW92ZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9zbGlkZXJNb3ZlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxucmVxdWlyZShcIi4vbGVnZW5kL0xlZ2VuZE1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9sZWdlbmQvbGVnZW5kQWN0aW9uXCIpO1xuXG5yZXF1aXJlKFwiLi9sZWdlbmQvTGVnZW5kVmlld1wiKTtcblxudmFyIGxlZ2VuZEZpbHRlciA9IHJlcXVpcmUoXCIuL2xlZ2VuZC9sZWdlbmRGaWx0ZXJcIik7XG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiLi4vbW9kZWwvQ29tcG9uZW50XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBEbyBub3QgY29udGFpbiBzY3JvbGxhYmxlIGxlZ2VuZCwgZm9yIHNha2Ugb2YgZmlsZSBzaXplLlxuLy8gU2VyaWVzIEZpbHRlclxuZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihsZWdlbmRGaWx0ZXIpO1xuQ29tcG9uZW50LnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcignbGVnZW5kJywgZnVuY3Rpb24gKCkge1xuICAvLyBEZWZhdWx0ICdwbGFpbicgd2hlbiBubyB0eXBlIHNwZWNpZmllZC5cbiAgcmV0dXJuICdwbGFpbic7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIF9tb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG52YXIgaXNOYW1lU3BlY2lmaWVkID0gX21vZGVsLmlzTmFtZVNwZWNpZmllZDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIExlZ2VuZE1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdsZWdlbmQucGxhaW4nLFxuICBkZXBlbmRlbmNpZXM6IFsnc2VyaWVzJ10sXG4gIGxheW91dE1vZGU6IHtcbiAgICB0eXBlOiAnYm94JyxcbiAgICAvLyBsZWdlbmQud2lkdGgvaGVpZ2h0IGFyZSBtYXhXaWR0aC9tYXhIZWlnaHQgYWN0dWFsbHksXG4gICAgLy8gd2hlcmVhcyByZWFseSB3aWR0aC9oZWlnaHQgaXMgY2FsY3VsYXRlZCBieSBpdHMgY29udGVudC5cbiAgICAvLyAoU2V0dGluZyB7bGVmdDogMTAsIHJpZ2h0OiAxMH0gZG9lcyBub3QgbWFrZSBzZW5zZSkuXG4gICAgLy8gU28gY29uc2lkZXIgdGhlIGNhc2U6XG4gICAgLy8gYHNldE9wdGlvbih7bGVnZW5kOiB7bGVmdDogMTB9KTtgXG4gICAgLy8gdGhlbiBgc2V0T3B0aW9uKHtsZWdlbmQ6IHtyaWdodDogMTB9KTtgXG4gICAgLy8gVGhlIHByZXZpb3VzIGBsZWZ0YCBzaG91bGQgYmUgY2xlYXJlZCBieSBzZXR0aW5nIGBpZ25vcmVTaXplYC5cbiAgICBpZ25vcmVTaXplOiB0cnVlXG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvbi5zZWxlY3RlZCB8fCB7fTtcbiAgfSxcbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBMZWdlbmRNb2RlbC5zdXBlckNhbGwodGhpcywgJ21lcmdlT3B0aW9uJywgb3B0aW9uKTtcbiAgfSxcbiAgb3B0aW9uVXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZURhdGEodGhpcy5lY01vZGVsKTtcblxuICAgIHZhciBsZWdlbmREYXRhID0gdGhpcy5fZGF0YTsgLy8gSWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZSwgdHJ5IHRvIHNlbGVjdCBvbmVcblxuICAgIGlmIChsZWdlbmREYXRhWzBdICYmIHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHZhciBoYXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBJZiBoYXMgYW55IHNlbGVjdGVkIGluIG9wdGlvbi5zZWxlY3RlZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsZWdlbmREYXRhW2ldLmdldCgnbmFtZScpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQobmFtZSkpIHtcbiAgICAgICAgICAvLyBGb3JjZSB0byB1bnNlbGVjdCBvdGhlcnNcbiAgICAgICAgICB0aGlzLnNlbGVjdChuYW1lKTtcbiAgICAgICAgICBoYXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVHJ5IHNlbGVjdCB0aGUgZmlyc3QgaWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZVxuXG5cbiAgICAgICFoYXNTZWxlY3RlZCAmJiB0aGlzLnNlbGVjdChsZWdlbmREYXRhWzBdLmdldCgnbmFtZScpKTtcbiAgICB9XG4gIH0sXG4gIF91cGRhdGVEYXRhOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBwb3RlbnRpYWxEYXRhID0gW107XG4gICAgdmFyIGF2YWlsYWJsZU5hbWVzID0gW107XG4gICAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIHNlcmllc05hbWUgPSBzZXJpZXNNb2RlbC5uYW1lO1xuICAgICAgYXZhaWxhYmxlTmFtZXMucHVzaChzZXJpZXNOYW1lKTtcbiAgICAgIHZhciBpc1BvdGVudGlhbDtcblxuICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcigpO1xuICAgICAgICB2YXIgbmFtZXMgPSBkYXRhLm1hcEFycmF5KGRhdGEuZ2V0TmFtZSk7XG5cbiAgICAgICAgaWYgKCFlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgICAgYXZhaWxhYmxlTmFtZXMgPSBhdmFpbGFibGVOYW1lcy5jb25jYXQobmFtZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgIHBvdGVudGlhbERhdGEgPSBwb3RlbnRpYWxEYXRhLmNvbmNhdChuYW1lcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNQb3RlbnRpYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1BvdGVudGlhbCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1BvdGVudGlhbCAmJiBpc05hbWVTcGVjaWZpZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgIHBvdGVudGlhbERhdGEucHVzaChzZXJpZXNNb2RlbC5uYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2F2YWlsYWJsZU5hbWVzID0gYXZhaWxhYmxlTmFtZXM7IC8vIElmIGxlZ2VuZC5kYXRhIG5vdCBzcGVjaWZpZWQgaW4gb3B0aW9uLCB1c2UgYXZhaWxhYmxlTmFtZXMgYXMgZGF0YSxcbiAgICAvLyB3aGljaCBpcyBjb252aW5pZW50IGZvciB1c2VyIHByZXBhcmluZyBvcHRpb24uXG5cbiAgICB2YXIgcmF3RGF0YSA9IHRoaXMuZ2V0KCdkYXRhJykgfHwgcG90ZW50aWFsRGF0YTtcbiAgICB2YXIgbGVnZW5kRGF0YSA9IHpyVXRpbC5tYXAocmF3RGF0YSwgZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICAvLyBDYW4gYmUgc3RyaW5nIG9yIG51bWJlclxuICAgICAgaWYgKHR5cGVvZiBkYXRhSXRlbSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGFJdGVtID09PSAnbnVtYmVyJykge1xuICAgICAgICBkYXRhSXRlbSA9IHtcbiAgICAgICAgICBuYW1lOiBkYXRhSXRlbVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IE1vZGVsKGRhdGFJdGVtLCB0aGlzLCB0aGlzLmVjTW9kZWwpO1xuICAgIH0sIHRoaXMpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLl9kYXRhID0gbGVnZW5kRGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPn1cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICB2YXIgc2VsZWN0ZWRNb2RlID0gdGhpcy5nZXQoJ3NlbGVjdGVkTW9kZScpO1xuXG4gICAgaWYgKHNlbGVjdGVkTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgIHpyVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICBzZWxlY3RlZFtkYXRhSXRlbS5nZXQoJ25hbWUnKV0gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHVuU2VsZWN0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJykgIT09ICdzaW5nbGUnKSB7XG4gICAgICB0aGlzLm9wdGlvbi5zZWxlY3RlZFtuYW1lXSA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHRvZ2dsZVNlbGVjdGVkOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkOyAvLyBEZWZhdWx0IGlzIHRydWVcblxuICAgIGlmICghc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzW3NlbGVjdGVkW25hbWVdID8gJ3VuU2VsZWN0JyA6ICdzZWxlY3QnXShuYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICEoc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIXNlbGVjdGVkW25hbWVdKSAmJiB6clV0aWwuaW5kZXhPZih0aGlzLl9hdmFpbGFibGVOYW1lcywgbmFtZSkgPj0gMDtcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIC8vIOS4gOe6p+WxguWPoFxuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICB6OiA0LFxuICAgIHNob3c6IHRydWUsXG4gICAgLy8g5biD5bGA5pa55byP77yM6buY6K6k5Li65rC05bmz5biD5bGA77yM5Y+v6YCJ5Li677yaXG4gICAgLy8gJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJ1xuICAgIG9yaWVudDogJ2hvcml6b250YWwnLFxuICAgIGxlZnQ6ICdjZW50ZXInLFxuICAgIC8vIHJpZ2h0OiAnY2VudGVyJyxcbiAgICB0b3A6IDAsXG4gICAgLy8gYm90dG9tOiBudWxsLFxuICAgIC8vIOawtOW5s+Wvuem9kFxuICAgIC8vICdhdXRvJyB8ICdsZWZ0JyB8ICdyaWdodCdcbiAgICAvLyDpu5jorqTkuLogJ2F1dG8nLCDmoLnmja4geCDnmoTkvY3nva7liKTmlq3mmK/lt6blr7npvZDov5jmmK/lj7Plr7npvZBcbiAgICBhbGlnbjogJ2F1dG8nLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIC8vIOWbvuS+i+i+ueahhuminOiJslxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIC8vIOWbvuS+i+i+ueahhue6v+Wuve+8jOWNleS9jXB477yM6buY6K6k5Li6MO+8iOaXoOi+ueahhu+8iVxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIC8vIOWbvuS+i+WGhei+uei3ne+8jOWNleS9jXB477yM6buY6K6k5ZCE5pa55ZCR5YaF6L656Led5Li6Ne+8jFxuICAgIC8vIOaOpeWPl+aVsOe7hOWIhuWIq+iuvuWumuS4iuWPs+S4i+W3pui+uei3ne+8jOWQjGNzc1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLy8g5ZCE5LiqaXRlbeS5i+mXtOeahOmXtOmalO+8jOWNleS9jXB477yM6buY6K6k5Li6MTDvvIxcbiAgICAvLyDmqKrlkJHluIPlsYDml7bkuLrmsLTlubPpl7TpmpTvvIznurXlkJHluIPlsYDml7bkuLrnurXlkJHpl7TpmpRcbiAgICBpdGVtR2FwOiAxMCxcbiAgICAvLyDlm77kvovlm77lvaLlrr3luqZcbiAgICBpdGVtV2lkdGg6IDI1LFxuICAgIC8vIOWbvuS+i+WbvuW9oumrmOW6plxuICAgIGl0ZW1IZWlnaHQ6IDE0LFxuICAgIC8vIOWbvuS+i+WFs+mXreaXtuWAmeeahOminOiJslxuICAgIGluYWN0aXZlQ29sb3I6ICcjY2NjJyxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIC8vIOWbvuS+i+aWh+Wtl+minOiJslxuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgLy8gZm9ybWF0dGVyOiAnJyxcbiAgICAvLyDpgInmi6nmqKHlvI/vvIzpu5jorqTlvIDlkK/lm77kvovlvIDlhbNcbiAgICBzZWxlY3RlZE1vZGU6IHRydWUsXG4gICAgLy8g6YWN572u6buY6K6k6YCJ5Lit54q25oCB77yM5Y+v6YWN5ZCITEVHRU5ELlNFTEVDVEVE5LqL5Lu25YGa5Yqo5oCB5pWw5o2u6L295YWlXG4gICAgLy8gc2VsZWN0ZWQ6IG51bGwsXG4gICAgLy8g5Zu+5L6L5YaF5a6577yI6K+m6KeBbGVnZW5kLmRhdGHvvIzmlbDnu4TkuK3mr4/kuIDpobnku6PooajkuIDkuKppdGVtXG4gICAgLy8gZGF0YTogW10sXG4gICAgLy8gVG9vbHRpcCDnm7jlhbPphY3nva5cbiAgICB0b29sdGlwOiB7XG4gICAgICBzaG93OiBmYWxzZVxuICAgIH1cbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBMZWdlbmRNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRNb2RlbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3N5bWJvbFwiKTtcblxudmFyIGNyZWF0ZVN5bWJvbCA9IF9zeW1ib2wuY3JlYXRlU3ltYm9sO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBfbGlzdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvbGlzdENvbXBvbmVudFwiKTtcblxudmFyIG1ha2VCYWNrZ3JvdW5kID0gX2xpc3RDb21wb25lbnQubWFrZUJhY2tncm91bmQ7XG5cbnZhciBsYXlvdXRVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbGF5b3V0XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIEdyb3VwID0gZ3JhcGhpYy5Hcm91cDtcblxudmFyIF9kZWZhdWx0ID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ2xlZ2VuZC5wbGFpbicsXG4gIG5ld2xpbmVEaXNhYmxlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgKi9cbiAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLl9jb250ZW50R3JvdXAgPSBuZXcgR3JvdXAoKSk7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgKi9cblxuICAgIHRoaXMuX2JhY2tncm91bmRFbDtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0Q29udGVudEdyb3VwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRHcm91cDtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5yZXNldElubmVyKCk7XG5cbiAgICBpZiAoIWxlZ2VuZE1vZGVsLmdldCgnc2hvdycsIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGl0ZW1BbGlnbiA9IGxlZ2VuZE1vZGVsLmdldCgnYWxpZ24nKTtcblxuICAgIGlmICghaXRlbUFsaWduIHx8IGl0ZW1BbGlnbiA9PT0gJ2F1dG8nKSB7XG4gICAgICBpdGVtQWxpZ24gPSBsZWdlbmRNb2RlbC5nZXQoJ2xlZnQnKSA9PT0gJ3JpZ2h0JyAmJiBsZWdlbmRNb2RlbC5nZXQoJ29yaWVudCcpID09PSAndmVydGljYWwnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcklubmVyKGl0ZW1BbGlnbiwgbGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSk7IC8vIFBlcmZvcm0gbGF5b3V0LlxuXG4gICAgdmFyIHBvc2l0aW9uSW5mbyA9IGxlZ2VuZE1vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuICAgIHZhciB2aWV3cG9ydFNpemUgPSB7XG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH07XG4gICAgdmFyIHBhZGRpbmcgPSBsZWdlbmRNb2RlbC5nZXQoJ3BhZGRpbmcnKTtcbiAgICB2YXIgbWF4U2l6ZSA9IGxheW91dFV0aWwuZ2V0TGF5b3V0UmVjdChwb3NpdGlvbkluZm8sIHZpZXdwb3J0U2l6ZSwgcGFkZGluZyk7XG4gICAgdmFyIG1haW5SZWN0ID0gdGhpcy5sYXlvdXRJbm5lcihsZWdlbmRNb2RlbCwgaXRlbUFsaWduLCBtYXhTaXplKTsgLy8gUGxhY2UgbWFpbkdyb3VwLCBiYXNlZCBvbiB0aGUgY2FsY3VsYXRlZCBgbWFpblJlY3RgLlxuXG4gICAgdmFyIGxheW91dFJlY3QgPSBsYXlvdXRVdGlsLmdldExheW91dFJlY3QoenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgIHdpZHRoOiBtYWluUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogbWFpblJlY3QuaGVpZ2h0XG4gICAgfSwgcG9zaXRpb25JbmZvKSwgdmlld3BvcnRTaXplLCBwYWRkaW5nKTtcbiAgICB0aGlzLmdyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgW2xheW91dFJlY3QueCAtIG1haW5SZWN0LngsIGxheW91dFJlY3QueSAtIG1haW5SZWN0LnldKTsgLy8gUmVuZGVyIGJhY2tncm91bmQgYWZ0ZXIgZ3JvdXAgaXMgbGF5b3V0LlxuXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5fYmFja2dyb3VuZEVsID0gbWFrZUJhY2tncm91bmQobWFpblJlY3QsIGxlZ2VuZE1vZGVsKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlc2V0SW5uZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdldENvbnRlbnRHcm91cCgpLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX2JhY2tncm91bmRFbCAmJiB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLl9iYWNrZ3JvdW5kRWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICByZW5kZXJJbm5lcjogZnVuY3Rpb24gKGl0ZW1BbGlnbiwgbGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb250ZW50R3JvdXAgPSB0aGlzLmdldENvbnRlbnRHcm91cCgpO1xuICAgIHZhciBsZWdlbmREcmF3bk1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgdmFyIHNlbGVjdE1vZGUgPSBsZWdlbmRNb2RlbC5nZXQoJ3NlbGVjdGVkTW9kZScpO1xuICAgIHZhciBleGNsdWRlU2VyaWVzSWQgPSBbXTtcbiAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAhc2VyaWVzTW9kZWwuZ2V0KCdsZWdlbmRIb3ZlckxpbmsnKSAmJiBleGNsdWRlU2VyaWVzSWQucHVzaChzZXJpZXNNb2RlbC5pZCk7XG4gICAgfSk7XG4gICAgZWFjaChsZWdlbmRNb2RlbC5nZXREYXRhKCksIGZ1bmN0aW9uIChpdGVtTW9kZWwsIGRhdGFJbmRleCkge1xuICAgICAgdmFyIG5hbWUgPSBpdGVtTW9kZWwuZ2V0KCduYW1lJyk7IC8vIFVzZSBlbXB0eSBzdHJpbmcgb3IgXFxuIGFzIGEgbmV3bGluZSBzdHJpbmdcblxuICAgICAgaWYgKCF0aGlzLm5ld2xpbmVEaXNhYmxlZCAmJiAobmFtZSA9PT0gJycgfHwgbmFtZSA9PT0gJ1xcbicpKSB7XG4gICAgICAgIGNvbnRlbnRHcm91cC5hZGQobmV3IEdyb3VwKHtcbiAgICAgICAgICBuZXdsaW5lOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBSZXByZXNlbnRpdGl2ZSBzZXJpZXMuXG5cblxuICAgICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeU5hbWUobmFtZSlbMF07XG5cbiAgICAgIGlmIChsZWdlbmREcmF3bk1hcC5nZXQobmFtZSkpIHtcbiAgICAgICAgLy8gSGF2ZSBiZWVuIGRyYXdlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFNlcmllcyBsZWdlbmRcblxuXG4gICAgICBpZiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0VmlzdWFsKCdjb2xvcicpOyAvLyBJZiBjb2xvciBpcyBhIGNhbGxiYWNrIGZ1bmN0aW9uXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZmlyc3QgZGF0YVxuICAgICAgICAgIGNvbG9yID0gY29sb3Ioc2VyaWVzTW9kZWwuZ2V0RGF0YVBhcmFtcygwKSk7XG4gICAgICAgIH0gLy8gVXNpbmcgcmVjdCBzeW1ib2wgZGVmYXVsdGx5XG5cblxuICAgICAgICB2YXIgbGVnZW5kU3ltYm9sVHlwZSA9IGRhdGEuZ2V0VmlzdWFsKCdsZWdlbmRTeW1ib2wnKSB8fCAncm91bmRSZWN0JztcbiAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBkYXRhLmdldFZpc3VhbCgnc3ltYm9sJyk7XG5cbiAgICAgICAgdmFyIGl0ZW1Hcm91cCA9IHRoaXMuX2NyZWF0ZUl0ZW0obmFtZSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLCBsZWdlbmRTeW1ib2xUeXBlLCBzeW1ib2xUeXBlLCBpdGVtQWxpZ24sIGNvbG9yLCBzZWxlY3RNb2RlKTtcblxuICAgICAgICBpdGVtR3JvdXAub24oJ2NsaWNrJywgY3VycnkoZGlzcGF0Y2hTZWxlY3RBY3Rpb24sIG5hbWUsIGFwaSkpLm9uKCdtb3VzZW92ZXInLCBjdXJyeShkaXNwYXRjaEhpZ2hsaWdodEFjdGlvbiwgc2VyaWVzTW9kZWwsIG51bGwsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSkub24oJ21vdXNlb3V0JywgY3VycnkoZGlzcGF0Y2hEb3ducGxheUFjdGlvbiwgc2VyaWVzTW9kZWwsIG51bGwsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSk7XG4gICAgICAgIGxlZ2VuZERyYXduTWFwLnNldChuYW1lLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERhdGEgbGVnZW5kIG9mIHBpZSwgZnVubmVsXG4gICAgICAgIGVjTW9kZWwuZWFjaFJhd1NlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAvLyBJbiBjYXNlIG11bHRpcGxlIHNlcmllcyBoYXMgc2FtZSBkYXRhIG5hbWVcbiAgICAgICAgICBpZiAobGVnZW5kRHJhd25NYXAuZ2V0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5sZWdlbmREYXRhUHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBkYXRhLmluZGV4T2ZOYW1lKG5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuICAgICAgICAgICAgdmFyIGxlZ2VuZFN5bWJvbFR5cGUgPSAncm91bmRSZWN0JztcblxuICAgICAgICAgICAgdmFyIGl0ZW1Hcm91cCA9IHRoaXMuX2NyZWF0ZUl0ZW0obmFtZSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLCBsZWdlbmRTeW1ib2xUeXBlLCBudWxsLCBpdGVtQWxpZ24sIGNvbG9yLCBzZWxlY3RNb2RlKTsgLy8gRklYTUU6IGNvbnNpZGVyIGRpZmZlcmVudCBzZXJpZXMgaGFzIGl0ZW1zIHdpdGggdGhlIHNhbWUgbmFtZS5cblxuXG4gICAgICAgICAgICBpdGVtR3JvdXAub24oJ2NsaWNrJywgY3VycnkoZGlzcGF0Y2hTZWxlY3RBY3Rpb24sIG5hbWUsIGFwaSkpIC8vIEZJWE1FIFNob3VsZCBub3Qgc3BlY2lmeSB0aGUgc2VyaWVzIG5hbWVcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgY3VycnkoZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24sIHNlcmllc01vZGVsLCBuYW1lLCBhcGksIGV4Y2x1ZGVTZXJpZXNJZCkpLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIHNlcmllc01vZGVsLCBuYW1lLCBhcGksIGV4Y2x1ZGVTZXJpZXNJZCkpO1xuICAgICAgICAgICAgbGVnZW5kRHJhd25NYXAuc2V0KG5hbWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIF9jcmVhdGVJdGVtOiBmdW5jdGlvbiAobmFtZSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLCBsZWdlbmRTeW1ib2xUeXBlLCBzeW1ib2xUeXBlLCBpdGVtQWxpZ24sIGNvbG9yLCBzZWxlY3RNb2RlKSB7XG4gICAgdmFyIGl0ZW1XaWR0aCA9IGxlZ2VuZE1vZGVsLmdldCgnaXRlbVdpZHRoJyk7XG4gICAgdmFyIGl0ZW1IZWlnaHQgPSBsZWdlbmRNb2RlbC5nZXQoJ2l0ZW1IZWlnaHQnKTtcbiAgICB2YXIgaW5hY3RpdmVDb2xvciA9IGxlZ2VuZE1vZGVsLmdldCgnaW5hY3RpdmVDb2xvcicpO1xuICAgIHZhciBzeW1ib2xLZWVwQXNwZWN0ID0gbGVnZW5kTW9kZWwuZ2V0KCdzeW1ib2xLZWVwQXNwZWN0Jyk7XG4gICAgdmFyIGlzU2VsZWN0ZWQgPSBsZWdlbmRNb2RlbC5pc1NlbGVjdGVkKG5hbWUpO1xuICAgIHZhciBpdGVtR3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgIHZhciBpdGVtSWNvbiA9IGl0ZW1Nb2RlbC5nZXQoJ2ljb24nKTtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCd0b29sdGlwJyk7XG4gICAgdmFyIGxlZ2VuZEdsb2JhbFRvb2x0aXBNb2RlbCA9IHRvb2x0aXBNb2RlbC5wYXJlbnRNb2RlbDsgLy8gVXNlIHVzZXIgZ2l2ZW4gaWNvbiBmaXJzdFxuXG4gICAgbGVnZW5kU3ltYm9sVHlwZSA9IGl0ZW1JY29uIHx8IGxlZ2VuZFN5bWJvbFR5cGU7XG4gICAgaXRlbUdyb3VwLmFkZChjcmVhdGVTeW1ib2wobGVnZW5kU3ltYm9sVHlwZSwgMCwgMCwgaXRlbVdpZHRoLCBpdGVtSGVpZ2h0LCBpc1NlbGVjdGVkID8gY29sb3IgOiBpbmFjdGl2ZUNvbG9yLCAvLyBzeW1ib2xLZWVwQXNwZWN0IGRlZmF1bHQgdHJ1ZSBmb3IgbGVnZW5kXG4gICAgc3ltYm9sS2VlcEFzcGVjdCA9PSBudWxsID8gdHJ1ZSA6IHN5bWJvbEtlZXBBc3BlY3QpKTsgLy8gQ29tcG9zZSBzeW1ib2xzXG4gICAgLy8gUEVORElOR1xuXG4gICAgaWYgKCFpdGVtSWNvbiAmJiBzeW1ib2xUeXBlIC8vIEF0IGxlYXN0IHNob3cgb25lIHN5bWJvbCwgY2FuJ3QgYmUgYWxsIG5vbmVcbiAgICAmJiAoc3ltYm9sVHlwZSAhPT0gbGVnZW5kU3ltYm9sVHlwZSB8fCBzeW1ib2xUeXBlID09ICdub25lJykpIHtcbiAgICAgIHZhciBzaXplID0gaXRlbUhlaWdodCAqIDAuODtcblxuICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgICAgICBzeW1ib2xUeXBlID0gJ2NpcmNsZSc7XG4gICAgICB9IC8vIFB1dCBzeW1ib2wgaW4gdGhlIGNlbnRlclxuXG5cbiAgICAgIGl0ZW1Hcm91cC5hZGQoY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIChpdGVtV2lkdGggLSBzaXplKSAvIDIsIChpdGVtSGVpZ2h0IC0gc2l6ZSkgLyAyLCBzaXplLCBzaXplLCBpc1NlbGVjdGVkID8gY29sb3IgOiBpbmFjdGl2ZUNvbG9yLCAvLyBzeW1ib2xLZWVwQXNwZWN0IGRlZmF1bHQgdHJ1ZSBmb3IgbGVnZW5kXG4gICAgICBzeW1ib2xLZWVwQXNwZWN0ID09IG51bGwgPyB0cnVlIDogc3ltYm9sS2VlcEFzcGVjdCkpO1xuICAgIH1cblxuICAgIHZhciB0ZXh0WCA9IGl0ZW1BbGlnbiA9PT0gJ2xlZnQnID8gaXRlbVdpZHRoICsgNSA6IC01O1xuICAgIHZhciB0ZXh0QWxpZ24gPSBpdGVtQWxpZ247XG4gICAgdmFyIGZvcm1hdHRlciA9IGxlZ2VuZE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgdmFyIGNvbnRlbnQgPSBuYW1lO1xuXG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnICYmIGZvcm1hdHRlcikge1xuICAgICAgY29udGVudCA9IGZvcm1hdHRlci5yZXBsYWNlKCd7bmFtZX0nLCBuYW1lICE9IG51bGwgPyBuYW1lIDogJycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGVudCA9IGZvcm1hdHRlcihuYW1lKTtcbiAgICB9XG5cbiAgICBpdGVtR3JvdXAuYWRkKG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgc3R5bGU6IGdyYXBoaWMuc2V0VGV4dFN0eWxlKHt9LCB0ZXh0U3R5bGVNb2RlbCwge1xuICAgICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgICB4OiB0ZXh0WCxcbiAgICAgICAgeTogaXRlbUhlaWdodCAvIDIsXG4gICAgICAgIHRleHRGaWxsOiBpc1NlbGVjdGVkID8gdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgOiBpbmFjdGl2ZUNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgICB9KVxuICAgIH0pKTsgLy8gQWRkIGEgaW52aXNpYmxlIHJlY3QgdG8gaW5jcmVhc2UgdGhlIGFyZWEgb2YgbW91c2UgaG92ZXJcblxuICAgIHZhciBoaXRSZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBzaGFwZTogaXRlbUdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLFxuICAgICAgaW52aXNpYmxlOiB0cnVlLFxuICAgICAgdG9vbHRpcDogdG9vbHRpcE1vZGVsLmdldCgnc2hvdycpID8genJVdGlsLmV4dGVuZCh7XG4gICAgICAgIGNvbnRlbnQ6IG5hbWUsXG4gICAgICAgIC8vIERlZmF1bCBmb3JtYXR0ZXJcbiAgICAgICAgZm9ybWF0dGVyOiBsZWdlbmRHbG9iYWxUb29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXInLCB0cnVlKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlclBhcmFtczoge1xuICAgICAgICAgIGNvbXBvbmVudFR5cGU6ICdsZWdlbmQnLFxuICAgICAgICAgIGxlZ2VuZEluZGV4OiBsZWdlbmRNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICR2YXJzOiBbJ25hbWUnXVxuICAgICAgICB9XG4gICAgICB9LCB0b29sdGlwTW9kZWwub3B0aW9uKSA6IG51bGxcbiAgICB9KTtcbiAgICBpdGVtR3JvdXAuYWRkKGhpdFJlY3QpO1xuICAgIGl0ZW1Hcm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBjaGlsZC5zaWxlbnQgPSB0cnVlO1xuICAgIH0pO1xuICAgIGhpdFJlY3Quc2lsZW50ID0gIXNlbGVjdE1vZGU7XG4gICAgdGhpcy5nZXRDb250ZW50R3JvdXAoKS5hZGQoaXRlbUdyb3VwKTtcbiAgICBncmFwaGljLnNldEhvdmVyU3R5bGUoaXRlbUdyb3VwKTtcbiAgICBpdGVtR3JvdXAuX19sZWdlbmREYXRhSW5kZXggPSBkYXRhSW5kZXg7XG4gICAgcmV0dXJuIGl0ZW1Hcm91cDtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbGF5b3V0SW5uZXI6IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaXRlbUFsaWduLCBtYXhTaXplKSB7XG4gICAgdmFyIGNvbnRlbnRHcm91cCA9IHRoaXMuZ2V0Q29udGVudEdyb3VwKCk7IC8vIFBsYWNlIGl0ZW1zIGluIGNvbnRlbnRHcm91cC5cblxuICAgIGxheW91dFV0aWwuYm94KGxlZ2VuZE1vZGVsLmdldCgnb3JpZW50JyksIGNvbnRlbnRHcm91cCwgbGVnZW5kTW9kZWwuZ2V0KCdpdGVtR2FwJyksIG1heFNpemUud2lkdGgsIG1heFNpemUuaGVpZ2h0KTtcbiAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50R3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgY29udGVudEdyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgWy1jb250ZW50UmVjdC54LCAtY29udGVudFJlY3QueV0pO1xuICAgIHJldHVybiB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGlzcGF0Y2hTZWxlY3RBY3Rpb24obmFtZSwgYXBpKSB7XG4gIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgdHlwZTogJ2xlZ2VuZFRvZ2dsZVNlbGVjdCcsXG4gICAgbmFtZTogbmFtZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24oc2VyaWVzTW9kZWwsIGRhdGFOYW1lLCBhcGksIGV4Y2x1ZGVTZXJpZXNJZCkge1xuICAvLyBJZiBlbGVtZW50IGhvdmVyIHdpbGwgbW92ZSB0byBhIGhvdmVyTGF5ZXIuXG4gIHZhciBlbCA9IGFwaS5nZXRacigpLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKVswXTtcblxuICBpZiAoIShlbCAmJiBlbC51c2VIb3ZlckxheWVyKSkge1xuICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnaGlnaGxpZ2h0JyxcbiAgICAgIHNlcmllc05hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICBuYW1lOiBkYXRhTmFtZSxcbiAgICAgIGV4Y2x1ZGVTZXJpZXNJZDogZXhjbHVkZVNlcmllc0lkXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hEb3ducGxheUFjdGlvbihzZXJpZXNNb2RlbCwgZGF0YU5hbWUsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSB7XG4gIC8vIElmIGVsZW1lbnQgaG92ZXIgd2lsbCBtb3ZlIHRvIGEgaG92ZXJMYXllci5cbiAgdmFyIGVsID0gYXBpLmdldFpyKCkuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpWzBdO1xuXG4gIGlmICghKGVsICYmIGVsLnVzZUhvdmVyTGF5ZXIpKSB7XG4gICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdkb3ducGxheScsXG4gICAgICBzZXJpZXNOYW1lOiBzZXJpZXNNb2RlbC5uYW1lLFxuICAgICAgbmFtZTogZGF0YU5hbWUsXG4gICAgICBleGNsdWRlU2VyaWVzSWQ6IGV4Y2x1ZGVTZXJpZXNJZFxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL0xlZ2VuZFZpZXcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgTGVnZW5kTW9kZWwgPSByZXF1aXJlKFwiLi9MZWdlbmRNb2RlbFwiKTtcblxudmFyIF9sYXlvdXQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBtZXJnZUxheW91dFBhcmFtID0gX2xheW91dC5tZXJnZUxheW91dFBhcmFtO1xudmFyIGdldExheW91dFBhcmFtcyA9IF9sYXlvdXQuZ2V0TGF5b3V0UGFyYW1zO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsID0gTGVnZW5kTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ2xlZ2VuZC5zY3JvbGwnLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsRGF0YUluZGV4XG4gICAqL1xuICBzZXRTY3JvbGxEYXRhSW5kZXg6IGZ1bmN0aW9uIChzY3JvbGxEYXRhSW5kZXgpIHtcbiAgICB0aGlzLm9wdGlvbi5zY3JvbGxEYXRhSW5kZXggPSBzY3JvbGxEYXRhSW5kZXg7XG4gIH0sXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICBzY3JvbGxEYXRhSW5kZXg6IDAsXG4gICAgcGFnZUJ1dHRvbkl0ZW1HYXA6IDUsXG4gICAgcGFnZUJ1dHRvbkdhcDogbnVsbCxcbiAgICBwYWdlQnV0dG9uUG9zaXRpb246ICdlbmQnLFxuICAgIC8vICdzdGFydCcgb3IgJ2VuZCdcbiAgICBwYWdlRm9ybWF0dGVyOiAne2N1cnJlbnR9L3t0b3RhbH0nLFxuICAgIC8vIElmIG51bGwvdW5kZWZpbmVkLCBkbyBub3Qgc2hvdyBwYWdlLlxuICAgIHBhZ2VJY29uczoge1xuICAgICAgaG9yaXpvbnRhbDogWydNMCwwTDEyLC0xMEwxMiwxMHonLCAnTTAsMEwtMTIsLTEwTC0xMiwxMHonXSxcbiAgICAgIHZlcnRpY2FsOiBbJ00wLDBMMjAsMEwxMCwtMjB6JywgJ00wLDBMMjAsMEwxMCwyMHonXVxuICAgIH0sXG4gICAgcGFnZUljb25Db2xvcjogJyMyZjQ1NTQnLFxuICAgIHBhZ2VJY29uSW5hY3RpdmVDb2xvcjogJyNhYWEnLFxuICAgIHBhZ2VJY29uU2l6ZTogMTUsXG4gICAgLy8gQ2FuIGJlIFsxMCwgM10sIHdoaWNoIHJlcHJlc2VudHMgW3dpZHRoLCBoZWlnaHRdXG4gICAgcGFnZVRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDgwMFxuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbik7XG4gICAgU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsLnN1cGVyQ2FsbCh0aGlzLCAnaW5pdCcsIG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KTtcbiAgICBtZXJnZUFuZE5vcm1hbGl6ZUxheW91dFBhcmFtcyh0aGlzLCBvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uLCBleHRyYU9wdCkge1xuICAgIFNjcm9sbGFibGVMZWdlbmRNb2RlbC5zdXBlckNhbGwodGhpcywgJ21lcmdlT3B0aW9uJywgb3B0aW9uLCBleHRyYU9wdCk7XG4gICAgbWVyZ2VBbmROb3JtYWxpemVMYXlvdXRQYXJhbXModGhpcywgdGhpcy5vcHRpb24sIG9wdGlvbik7XG4gIH0sXG4gIGdldE9yaWVudDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnb3JpZW50JykgPT09ICd2ZXJ0aWNhbCcgPyB7XG4gICAgICBpbmRleDogMSxcbiAgICAgIG5hbWU6ICd2ZXJ0aWNhbCdcbiAgICB9IDoge1xuICAgICAgaW5kZXg6IDAsXG4gICAgICBuYW1lOiAnaG9yaXpvbnRhbCdcbiAgICB9O1xuICB9XG59KTsgLy8gRG8gbm90IGBpZ25vcmVTaXplYCB0byBlbmFibGUgc2V0dGluZyB7bGVmdDogMTAsIHJpZ2h0OiAxMH0uXG5cbmZ1bmN0aW9uIG1lcmdlQW5kTm9ybWFsaXplTGF5b3V0UGFyYW1zKGxlZ2VuZE1vZGVsLCB0YXJnZXQsIHJhdykge1xuICB2YXIgb3JpZW50ID0gbGVnZW5kTW9kZWwuZ2V0T3JpZW50KCk7XG4gIHZhciBpZ25vcmVTaXplID0gWzEsIDFdO1xuICBpZ25vcmVTaXplW29yaWVudC5pbmRleF0gPSAwO1xuICBtZXJnZUxheW91dFBhcmFtKHRhcmdldCwgcmF3LCB7XG4gICAgdHlwZTogJ2JveCcsXG4gICAgaWdub3JlU2l6ZTogaWdub3JlU2l6ZVxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL1Njcm9sbGFibGVMZWdlbmRNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kTW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgbGF5b3V0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xheW91dFwiKTtcblxudmFyIExlZ2VuZFZpZXcgPSByZXF1aXJlKFwiLi9MZWdlbmRWaWV3XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogU2VwYXJhdGUgbGVnZW5kIGFuZCBzY3JvbGxhYmxlIGxlZ2VuZCB0byByZWR1Y2UgcGFja2FnZSBzaXplLlxuICovXG52YXIgR3JvdXAgPSBncmFwaGljLkdyb3VwO1xudmFyIFdIID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbnZhciBYWSA9IFsneCcsICd5J107XG52YXIgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcgPSBMZWdlbmRWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdsZWdlbmQuc2Nyb2xsJyxcbiAgbmV3bGluZURpc2FibGVkOiB0cnVlLFxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuc3VwZXJDYWxsKHRoaXMsICdpbml0Jyk7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBGb3IgYHNjcm9sbGAuXG4gICAgICovXG5cbiAgICB0aGlzLl9jdXJyZW50SW5kZXggPSAwO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgKi9cblxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2NvbnRhaW5lckdyb3VwID0gbmV3IEdyb3VwKCkpO1xuXG4gICAgdGhpcy5fY29udGFpbmVyR3JvdXAuYWRkKHRoaXMuZ2V0Q29udGVudEdyb3VwKCkpO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgKi9cblxuXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5fY29udHJvbGxlckdyb3VwID0gbmV3IEdyb3VwKCkpO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX3Nob3dDb250cm9sbGVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlc2V0SW5uZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBTY3JvbGxhYmxlTGVnZW5kVmlldy5zdXBlckNhbGwodGhpcywgJ3Jlc2V0SW5uZXInKTtcblxuICAgIHRoaXMuX2NvbnRyb2xsZXJHcm91cC5yZW1vdmVBbGwoKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lckdyb3VwLnJlbW92ZUNsaXBQYXRoKCk7XG5cbiAgICB0aGlzLl9jb250YWluZXJHcm91cC5fX3JlY3RTaXplID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXJJbm5lcjogZnVuY3Rpb24gKGl0ZW1BbGlnbiwgbGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBtZSA9IHRoaXM7IC8vIFJlbmRlciBjb250ZW50IGl0ZW1zLlxuXG4gICAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuc3VwZXJDYWxsKHRoaXMsICdyZW5kZXJJbm5lcicsIGl0ZW1BbGlnbiwgbGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgdmFyIGNvbnRyb2xsZXJHcm91cCA9IHRoaXMuX2NvbnRyb2xsZXJHcm91cDtcbiAgICB2YXIgcGFnZUljb25TaXplID0gbGVnZW5kTW9kZWwuZ2V0KCdwYWdlSWNvblNpemUnLCB0cnVlKTtcblxuICAgIGlmICghenJVdGlsLmlzQXJyYXkocGFnZUljb25TaXplKSkge1xuICAgICAgcGFnZUljb25TaXplID0gW3BhZ2VJY29uU2l6ZSwgcGFnZUljb25TaXplXTtcbiAgICB9XG5cbiAgICBjcmVhdGVQYWdlQnV0dG9uKCdwYWdlUHJldicsIDApO1xuICAgIHZhciBwYWdlVGV4dFN0eWxlTW9kZWwgPSBsZWdlbmRNb2RlbC5nZXRNb2RlbCgncGFnZVRleHRTdHlsZScpO1xuICAgIGNvbnRyb2xsZXJHcm91cC5hZGQobmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICBuYW1lOiAncGFnZVRleHQnLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdGV4dEZpbGw6IHBhZ2VUZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgZm9udDogcGFnZVRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXG4gICAgICB9LFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSkpO1xuICAgIGNyZWF0ZVBhZ2VCdXR0b24oJ3BhZ2VOZXh0JywgMSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWdlQnV0dG9uKG5hbWUsIGljb25JZHgpIHtcbiAgICAgIHZhciBwYWdlRGF0YUluZGV4TmFtZSA9IG5hbWUgKyAnRGF0YUluZGV4JztcbiAgICAgIHZhciBpY29uID0gZ3JhcGhpYy5jcmVhdGVJY29uKGxlZ2VuZE1vZGVsLmdldCgncGFnZUljb25zJywgdHJ1ZSlbbGVnZW5kTW9kZWwuZ2V0T3JpZW50KCkubmFtZV1baWNvbklkeF0sIHtcbiAgICAgICAgLy8gQnV0dG9ucyB3aWxsIGJlIGNyZWF0ZWQgaW4gZWFjaCByZW5kZXIsIHNvIHdlIGRvIG5vdCBuZWVkXG4gICAgICAgIC8vIHRvIHdvcnJ5IGFib3V0IGF2b2lkaW5nIHVzaW5nIGxlZ2VuZE1vZGVsIGtlcHQgaW4gc2NvcGUuXG4gICAgICAgIG9uY2xpY2s6IHpyVXRpbC5iaW5kKG1lLl9wYWdlR28sIG1lLCBwYWdlRGF0YUluZGV4TmFtZSwgbGVnZW5kTW9kZWwsIGFwaSlcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLXBhZ2VJY29uU2l6ZVswXSAvIDIsXG4gICAgICAgIHk6IC1wYWdlSWNvblNpemVbMV0gLyAyLFxuICAgICAgICB3aWR0aDogcGFnZUljb25TaXplWzBdLFxuICAgICAgICBoZWlnaHQ6IHBhZ2VJY29uU2l6ZVsxXVxuICAgICAgfSk7XG4gICAgICBpY29uLm5hbWUgPSBuYW1lO1xuICAgICAgY29udHJvbGxlckdyb3VwLmFkZChpY29uKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbGF5b3V0SW5uZXI6IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaXRlbUFsaWduLCBtYXhTaXplKSB7XG4gICAgdmFyIGNvbnRlbnRHcm91cCA9IHRoaXMuZ2V0Q29udGVudEdyb3VwKCk7XG4gICAgdmFyIGNvbnRhaW5lckdyb3VwID0gdGhpcy5fY29udGFpbmVyR3JvdXA7XG4gICAgdmFyIGNvbnRyb2xsZXJHcm91cCA9IHRoaXMuX2NvbnRyb2xsZXJHcm91cDtcbiAgICB2YXIgb3JpZW50SWR4ID0gbGVnZW5kTW9kZWwuZ2V0T3JpZW50KCkuaW5kZXg7XG4gICAgdmFyIHdoID0gV0hbb3JpZW50SWR4XTtcbiAgICB2YXIgaHcgPSBXSFsxIC0gb3JpZW50SWR4XTtcbiAgICB2YXIgeXggPSBYWVsxIC0gb3JpZW50SWR4XTsgLy8gUGxhY2UgaXRlbXMgaW4gY29udGVudEdyb3VwLlxuXG4gICAgbGF5b3V0VXRpbC5ib3gobGVnZW5kTW9kZWwuZ2V0KCdvcmllbnQnKSwgY29udGVudEdyb3VwLCBsZWdlbmRNb2RlbC5nZXQoJ2l0ZW1HYXAnKSwgIW9yaWVudElkeCA/IG51bGwgOiBtYXhTaXplLndpZHRoLCBvcmllbnRJZHggPyBudWxsIDogbWF4U2l6ZS5oZWlnaHQpO1xuICAgIGxheW91dFV0aWwuYm94KCAvLyBCdXR0b25zIGluIGNvbnRyb2xsZXIgYXJlIGxheW91dCBhbHdheXMgaG9yaXpvbnRhbGx5LlxuICAgICdob3Jpem9udGFsJywgY29udHJvbGxlckdyb3VwLCBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VCdXR0b25JdGVtR2FwJywgdHJ1ZSkpO1xuICAgIHZhciBjb250ZW50UmVjdCA9IGNvbnRlbnRHcm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgY29udHJvbGxlclJlY3QgPSBjb250cm9sbGVyR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIHNob3dDb250cm9sbGVyID0gdGhpcy5fc2hvd0NvbnRyb2xsZXIgPSBjb250ZW50UmVjdFt3aF0gPiBtYXhTaXplW3doXTtcbiAgICB2YXIgY29udGVudFBvcyA9IFstY29udGVudFJlY3QueCwgLWNvbnRlbnRSZWN0LnldOyAvLyBSZW1haW4gY29udGVudFBvcyB3aGVuIHNjcm9sbCBhbmltYXRpb24gcGVyZnJvbWluZy5cblxuICAgIGNvbnRlbnRQb3Nbb3JpZW50SWR4XSA9IGNvbnRlbnRHcm91cC5wb3NpdGlvbltvcmllbnRJZHhdOyAvLyBMYXlvdXQgY29udGFpbmVyIGdyb3VwIGJhc2VkIG9uIDAuXG5cbiAgICB2YXIgY29udGFpbmVyUG9zID0gWzAsIDBdO1xuICAgIHZhciBjb250cm9sbGVyUG9zID0gWy1jb250cm9sbGVyUmVjdC54LCAtY29udHJvbGxlclJlY3QueV07XG4gICAgdmFyIHBhZ2VCdXR0b25HYXAgPSB6clV0aWwucmV0cmlldmUyKGxlZ2VuZE1vZGVsLmdldCgncGFnZUJ1dHRvbkdhcCcsIHRydWUpLCBsZWdlbmRNb2RlbC5nZXQoJ2l0ZW1HYXAnLCB0cnVlKSk7IC8vIFBsYWNlIGNvbnRhaW5lckdyb3VwIGFuZCBjb250cm9sbGVyR3JvdXAgYW5kIGNvbnRlbnRHcm91cC5cblxuICAgIGlmIChzaG93Q29udHJvbGxlcikge1xuICAgICAgdmFyIHBhZ2VCdXR0b25Qb3NpdGlvbiA9IGxlZ2VuZE1vZGVsLmdldCgncGFnZUJ1dHRvblBvc2l0aW9uJywgdHJ1ZSk7IC8vIGNvbnRyb2xsZXIgaXMgb24gdGhlIHJpZ2h0IC8gYm90dG9tLlxuXG4gICAgICBpZiAocGFnZUJ1dHRvblBvc2l0aW9uID09PSAnZW5kJykge1xuICAgICAgICBjb250cm9sbGVyUG9zW29yaWVudElkeF0gKz0gbWF4U2l6ZVt3aF0gLSBjb250cm9sbGVyUmVjdFt3aF07XG4gICAgICB9IC8vIGNvbnRyb2xsZXIgaXMgb24gdGhlIGxlZnQgLyB0b3AuXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXJQb3Nbb3JpZW50SWR4XSArPSBjb250cm9sbGVyUmVjdFt3aF0gKyBwYWdlQnV0dG9uR2FwO1xuICAgICAgICB9XG4gICAgfSAvLyBBbHdheXMgYWxpZ24gY29udHJvbGxlciB0byBjb250ZW50IGFzICdtaWRkbGUnLlxuXG5cbiAgICBjb250cm9sbGVyUG9zWzEgLSBvcmllbnRJZHhdICs9IGNvbnRlbnRSZWN0W2h3XSAvIDIgLSBjb250cm9sbGVyUmVjdFtod10gLyAyO1xuICAgIGNvbnRlbnRHcm91cC5hdHRyKCdwb3NpdGlvbicsIGNvbnRlbnRQb3MpO1xuICAgIGNvbnRhaW5lckdyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgY29udGFpbmVyUG9zKTtcbiAgICBjb250cm9sbGVyR3JvdXAuYXR0cigncG9zaXRpb24nLCBjb250cm9sbGVyUG9zKTsgLy8gQ2FsY3VsYXRlIGBtYWluUmVjdGAgYW5kIHNldCBgY2xpcFBhdGhgLlxuICAgIC8vIG1haW5SZWN0IHNob3VsZCBub3QgYmUgY2FsY3VsYXRlZCBieSBgdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKWBcbiAgICAvLyBmb3Igc2FrZSBvZiB0aGUgb3ZlcmZsb3cuXG5cbiAgICB2YXIgbWFpblJlY3QgPSB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBtYWluUmVjdCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTsgLy8gQ29uc2lkZXIgY29udGVudCBtYXkgYmUgb3ZlcmZsb3cgKHNob3VsZCBiZSBjbGlwcGVkKS5cblxuICAgIG1haW5SZWN0W3doXSA9IHNob3dDb250cm9sbGVyID8gbWF4U2l6ZVt3aF0gOiBjb250ZW50UmVjdFt3aF07XG4gICAgbWFpblJlY3RbaHddID0gTWF0aC5tYXgoY29udGVudFJlY3RbaHddLCBjb250cm9sbGVyUmVjdFtod10pOyAvLyBgY29udGFpbmVyUmVjdFt5eF0gKyBjb250YWluZXJQb3NbMSAtIG9yaWVudElkeF1gIGlzIDAuXG5cbiAgICBtYWluUmVjdFt5eF0gPSBNYXRoLm1pbigwLCBjb250cm9sbGVyUmVjdFt5eF0gKyBjb250cm9sbGVyUG9zWzEgLSBvcmllbnRJZHhdKTtcbiAgICBjb250YWluZXJHcm91cC5fX3JlY3RTaXplID0gbWF4U2l6ZVt3aF07XG5cbiAgICBpZiAoc2hvd0NvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBjbGlwU2hhcGUgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBjbGlwU2hhcGVbd2hdID0gTWF0aC5tYXgobWF4U2l6ZVt3aF0gLSBjb250cm9sbGVyUmVjdFt3aF0gLSBwYWdlQnV0dG9uR2FwLCAwKTtcbiAgICAgIGNsaXBTaGFwZVtod10gPSBtYWluUmVjdFtod107XG4gICAgICBjb250YWluZXJHcm91cC5zZXRDbGlwUGF0aChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgc2hhcGU6IGNsaXBTaGFwZVxuICAgICAgfSkpOyAvLyBDb25zaWRlciBjb250ZW50IG1heSBiZSBsYXJnZXIgdGhhbiBjb250YWluZXIsIGNvbnRhaW5lciByZWN0XG4gICAgICAvLyBjYW4gbm90IGJlIG9idGFpbmVkIGZyb20gYGNvbnRhaW5lckdyb3VwLmdldEJvdW5kaW5nUmVjdCgpYC5cblxuICAgICAgY29udGFpbmVyR3JvdXAuX19yZWN0U2l6ZSA9IGNsaXBTaGFwZVt3aF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERvIG5vdCByZW1vdmUgb3IgaWdub3JlIGNvbnRyb2xsZXIuIEtlZXAgdGhlbSBzZXQgYXMgcGxhY2UgaG9sZGVycy5cbiAgICAgIGNvbnRyb2xsZXJHcm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLmF0dHIoe1xuICAgICAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIENvbnRlbnQgdHJhbnNsYXRlIGFuaW1hdGlvbi5cblxuXG4gICAgdmFyIHBhZ2VJbmZvID0gdGhpcy5fZ2V0UGFnZUluZm8obGVnZW5kTW9kZWwpO1xuXG4gICAgcGFnZUluZm8ucGFnZUluZGV4ICE9IG51bGwgJiYgZ3JhcGhpYy51cGRhdGVQcm9wcyhjb250ZW50R3JvdXAsIHtcbiAgICAgIHBvc2l0aW9uOiBwYWdlSW5mby5jb250ZW50UG9zaXRpb25cbiAgICB9LCAvLyBXaGVuIHN3aXRjaCBmcm9tIFwic2hvdyBjb250cm9sbGVyXCIgdG8gXCJub3Qgc2hvdyBjb250cm9sbGVyXCIsIHZpZXcgc2hvdWxkIGJlXG4gICAgLy8gdXBkYXRlZCBpbW1lZGlhdGVseSB3aXRob3V0IGFuaW1hdGlvbiwgb3RoZXJ3aXNlIGNhdXNlcyB3ZWlyZCBlZmZmZWN0LlxuICAgIHNob3dDb250cm9sbGVyID8gbGVnZW5kTW9kZWwgOiBmYWxzZSk7XG5cbiAgICB0aGlzLl91cGRhdGVQYWdlSW5mb1ZpZXcobGVnZW5kTW9kZWwsIHBhZ2VJbmZvKTtcblxuICAgIHJldHVybiBtYWluUmVjdDtcbiAgfSxcbiAgX3BhZ2VHbzogZnVuY3Rpb24gKHRvLCBsZWdlbmRNb2RlbCwgYXBpKSB7XG4gICAgdmFyIHNjcm9sbERhdGFJbmRleCA9IHRoaXMuX2dldFBhZ2VJbmZvKGxlZ2VuZE1vZGVsKVt0b107XG5cbiAgICBzY3JvbGxEYXRhSW5kZXggIT0gbnVsbCAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2xlZ2VuZFNjcm9sbCcsXG4gICAgICBzY3JvbGxEYXRhSW5kZXg6IHNjcm9sbERhdGFJbmRleCxcbiAgICAgIGxlZ2VuZElkOiBsZWdlbmRNb2RlbC5pZFxuICAgIH0pO1xuICB9LFxuICBfdXBkYXRlUGFnZUluZm9WaWV3OiBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIHBhZ2VJbmZvKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJHcm91cCA9IHRoaXMuX2NvbnRyb2xsZXJHcm91cDtcbiAgICB6clV0aWwuZWFjaChbJ3BhZ2VQcmV2JywgJ3BhZ2VOZXh0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgY2FuSnVtcCA9IHBhZ2VJbmZvW25hbWUgKyAnRGF0YUluZGV4J10gIT0gbnVsbDtcbiAgICAgIHZhciBpY29uID0gY29udHJvbGxlckdyb3VwLmNoaWxkT2ZOYW1lKG5hbWUpO1xuXG4gICAgICBpZiAoaWNvbikge1xuICAgICAgICBpY29uLnNldFN0eWxlKCdmaWxsJywgY2FuSnVtcCA/IGxlZ2VuZE1vZGVsLmdldCgncGFnZUljb25Db2xvcicsIHRydWUpIDogbGVnZW5kTW9kZWwuZ2V0KCdwYWdlSWNvbkluYWN0aXZlQ29sb3InLCB0cnVlKSk7XG4gICAgICAgIGljb24uY3Vyc29yID0gY2FuSnVtcCA/ICdwb2ludGVyJyA6ICdkZWZhdWx0JztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgcGFnZVRleHQgPSBjb250cm9sbGVyR3JvdXAuY2hpbGRPZk5hbWUoJ3BhZ2VUZXh0Jyk7XG4gICAgdmFyIHBhZ2VGb3JtYXR0ZXIgPSBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VGb3JtYXR0ZXInKTtcbiAgICB2YXIgcGFnZUluZGV4ID0gcGFnZUluZm8ucGFnZUluZGV4O1xuICAgIHZhciBjdXJyZW50ID0gcGFnZUluZGV4ICE9IG51bGwgPyBwYWdlSW5kZXggKyAxIDogMDtcbiAgICB2YXIgdG90YWwgPSBwYWdlSW5mby5wYWdlQ291bnQ7XG4gICAgcGFnZVRleHQgJiYgcGFnZUZvcm1hdHRlciAmJiBwYWdlVGV4dC5zZXRTdHlsZSgndGV4dCcsIHpyVXRpbC5pc1N0cmluZyhwYWdlRm9ybWF0dGVyKSA/IHBhZ2VGb3JtYXR0ZXIucmVwbGFjZSgne2N1cnJlbnR9JywgY3VycmVudCkucmVwbGFjZSgne3RvdGFsfScsIHRvdGFsKSA6IHBhZ2VGb3JtYXR0ZXIoe1xuICAgICAgY3VycmVudDogY3VycmVudCxcbiAgICAgIHRvdGFsOiB0b3RhbFxuICAgIH0pKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbGVnZW5kTW9kZWxcbiAgICogQHJldHVybiB7T2JqZWN0fSB7XG4gICAqICBjb250ZW50UG9zaXRpb246IEFycmF5LjxudW1iZXI+LCBudWxsIHdoZW4gZGF0YSBpdGVtIG5vdCBmb3VuZC5cbiAgICogIHBhZ2VJbmRleDogbnVtYmVyLCBudWxsIHdoZW4gZGF0YSBpdGVtIG5vdCBmb3VuZC5cbiAgICogIHBhZ2VDb3VudDogbnVtYmVyLCBhbHdheXMgYmUgYSBudW1iZXIsIGNhbiBiZSAwLlxuICAgKiAgcGFnZVByZXZEYXRhSW5kZXg6IG51bWJlciwgbnVsbCB3aGVuIG5vIG5leHQgcGFnZS5cbiAgICogIHBhZ2VOZXh0RGF0YUluZGV4OiBudW1iZXIsIG51bGwgd2hlbiBubyBwcmV2aW91cyBwYWdlLlxuICAgKiB9XG4gICAqL1xuICBfZ2V0UGFnZUluZm86IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCkge1xuICAgIC8vIEFsaWduIGxlZnQgb3IgdG9wIGJ5IHRoZSBjdXJyZW50IGRhdGFJbmRleC5cbiAgICB2YXIgY3VyckRhdGFJbmRleCA9IGxlZ2VuZE1vZGVsLmdldCgnc2Nyb2xsRGF0YUluZGV4JywgdHJ1ZSk7XG4gICAgdmFyIGNvbnRlbnRHcm91cCA9IHRoaXMuZ2V0Q29udGVudEdyb3VwKCk7XG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudEdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBjb250YWluZXJSZWN0U2l6ZSA9IHRoaXMuX2NvbnRhaW5lckdyb3VwLl9fcmVjdFNpemU7XG4gICAgdmFyIG9yaWVudElkeCA9IGxlZ2VuZE1vZGVsLmdldE9yaWVudCgpLmluZGV4O1xuICAgIHZhciB3aCA9IFdIW29yaWVudElkeF07XG4gICAgdmFyIGh3ID0gV0hbMSAtIG9yaWVudElkeF07XG4gICAgdmFyIHh5ID0gWFlbb3JpZW50SWR4XTtcbiAgICB2YXIgY29udGVudFBvcyA9IGNvbnRlbnRHcm91cC5wb3NpdGlvbi5zbGljZSgpO1xuICAgIHZhciBwYWdlSW5kZXg7XG4gICAgdmFyIHBhZ2VQcmV2RGF0YUluZGV4O1xuICAgIHZhciBwYWdlTmV4dERhdGFJbmRleDtcbiAgICB2YXIgdGFyZ2V0SXRlbUdyb3VwO1xuXG4gICAgaWYgKHRoaXMuX3Nob3dDb250cm9sbGVyKSB7XG4gICAgICBjb250ZW50R3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuX19sZWdlbmREYXRhSW5kZXggPT09IGN1cnJEYXRhSW5kZXgpIHtcbiAgICAgICAgICB0YXJnZXRJdGVtR3JvdXAgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEl0ZW1Hcm91cCA9IGNvbnRlbnRHcm91cC5jaGlsZEF0KDApO1xuICAgIH1cblxuICAgIHZhciBwYWdlQ291bnQgPSBjb250YWluZXJSZWN0U2l6ZSA/IE1hdGguY2VpbChjb250ZW50UmVjdFt3aF0gLyBjb250YWluZXJSZWN0U2l6ZSkgOiAwO1xuXG4gICAgaWYgKHRhcmdldEl0ZW1Hcm91cCkge1xuICAgICAgdmFyIGl0ZW1SZWN0ID0gdGFyZ2V0SXRlbUdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgdmFyIGl0ZW1Mb2MgPSB0YXJnZXRJdGVtR3JvdXAucG9zaXRpb25bb3JpZW50SWR4XSArIGl0ZW1SZWN0W3h5XTtcbiAgICAgIGNvbnRlbnRQb3Nbb3JpZW50SWR4XSA9IC1pdGVtTG9jIC0gY29udGVudFJlY3RbeHldO1xuICAgICAgcGFnZUluZGV4ID0gTWF0aC5mbG9vcihwYWdlQ291bnQgKiAoaXRlbUxvYyArIGl0ZW1SZWN0W3h5XSArIGNvbnRhaW5lclJlY3RTaXplIC8gMikgLyBjb250ZW50UmVjdFt3aF0pO1xuICAgICAgcGFnZUluZGV4ID0gY29udGVudFJlY3Rbd2hdICYmIHBhZ2VDb3VudCA/IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VDb3VudCAtIDEsIHBhZ2VJbmRleCkpIDogLTE7XG4gICAgICB2YXIgd2luUmVjdCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIHdpblJlY3Rbd2hdID0gY29udGFpbmVyUmVjdFNpemU7XG4gICAgICB3aW5SZWN0W2h3XSA9IGNvbnRlbnRSZWN0W2h3XTtcbiAgICAgIHdpblJlY3RbeHldID0gLWNvbnRlbnRQb3Nbb3JpZW50SWR4XSAtIGNvbnRlbnRSZWN0W3h5XTtcbiAgICAgIHZhciBzdGFydElkeDtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbnRlbnRHcm91cC5jaGlsZHJlbigpO1xuICAgICAgY29udGVudEdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIHZhciBpdGVtUmVjdCA9IGdldEl0ZW1SZWN0KGNoaWxkKTtcblxuICAgICAgICBpZiAoaXRlbVJlY3QuaW50ZXJzZWN0KHdpblJlY3QpKSB7XG4gICAgICAgICAgc3RhcnRJZHggPT0gbnVsbCAmJiAoc3RhcnRJZHggPSBpbmRleCk7IC8vIEl0IGlzIHVzZXItZnJpZW5kbHkgdGhhdCB0aGUgbGFzdCBpdGVtIHNob3duIGluIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgd2luZG93IGlzIHNob3duIGF0IHRoZSBiZWdpbmluZyBvZiBuZXh0IHdpbmRvdy5cblxuICAgICAgICAgIHBhZ2VOZXh0RGF0YUluZGV4ID0gY2hpbGQuX19sZWdlbmREYXRhSW5kZXg7XG4gICAgICAgIH0gLy8gSWYgdGhlIGxhc3QgaXRlbSBpcyBzaG93biBlbnRpcmVseSwgbm8gbmV4dCBwYWdlLlxuXG5cbiAgICAgICAgaWYgKGluZGV4ID09PSBjaGlsZHJlbi5sZW5ndGggLSAxICYmIGl0ZW1SZWN0W3h5XSArIGl0ZW1SZWN0W3doXSA8PSB3aW5SZWN0W3h5XSArIHdpblJlY3Rbd2hdKSB7XG4gICAgICAgICAgcGFnZU5leHREYXRhSW5kZXggPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQWx3YXlzIGFsaWduIGJhc2VkIG9uIHRoZSBsZWZ0L3RvcCBtb3N0IGl0ZW0sIHNvIHRoZSBsZWZ0L3RvcCBtb3N0XG4gICAgICAvLyBpdGVtIGluIHRoZSBwcmV2aW91cyB3aW5kb3cgaXMgbmVlZGVkIHRvIGJlIGZvdW5kIGhlcmUuXG5cbiAgICAgIGlmIChzdGFydElkeCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBzdGFydEl0ZW0gPSBjaGlsZHJlbltzdGFydElkeF07XG4gICAgICAgIHZhciBzdGFydFJlY3QgPSBnZXRJdGVtUmVjdChzdGFydEl0ZW0pO1xuICAgICAgICB3aW5SZWN0W3h5XSA9IHN0YXJ0UmVjdFt4eV0gKyBzdGFydFJlY3Rbd2hdIC0gd2luUmVjdFt3aF07IC8vIElmIHRoZSBmaXJzdCBpdGVtIGlzIHNob3duIGVudGlyZWx5LCBubyBwcmV2aW91cyBwYWdlLlxuXG4gICAgICAgIGlmIChzdGFydElkeCA8PSAwICYmIHN0YXJ0UmVjdFt4eV0gPj0gd2luUmVjdFt4eV0pIHtcbiAgICAgICAgICBwYWdlUHJldkRhdGFJbmRleCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hpbGUgKHN0YXJ0SWR4ID4gMCAmJiBnZXRJdGVtUmVjdChjaGlsZHJlbltzdGFydElkeCAtIDFdKS5pbnRlcnNlY3Qod2luUmVjdCkpIHtcbiAgICAgICAgICAgIHN0YXJ0SWR4LS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFnZVByZXZEYXRhSW5kZXggPSBjaGlsZHJlbltzdGFydElkeF0uX19sZWdlbmREYXRhSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudFBvc2l0aW9uOiBjb250ZW50UG9zLFxuICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICBwYWdlQ291bnQ6IHBhZ2VDb3VudCxcbiAgICAgIHBhZ2VQcmV2RGF0YUluZGV4OiBwYWdlUHJldkRhdGFJbmRleCxcbiAgICAgIHBhZ2VOZXh0RGF0YUluZGV4OiBwYWdlTmV4dERhdGFJbmRleFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRJdGVtUmVjdChlbCkge1xuICAgICAgdmFyIGl0ZW1SZWN0ID0gZWwuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAgIGl0ZW1SZWN0W3h5XSArPSBlbC5wb3NpdGlvbltvcmllbnRJZHhdO1xuICAgICAgcmV0dXJuIGl0ZW1SZWN0O1xuICAgIH1cbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBTY3JvbGxhYmxlTGVnZW5kVmlldztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5mdW5jdGlvbiBsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyKG1ldGhvZE5hbWUsIHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgdmFyIHNlbGVjdGVkTWFwID0ge307XG4gIHZhciBpc1RvZ2dsZVNlbGVjdCA9IG1ldGhvZE5hbWUgPT09ICd0b2dnbGVTZWxlY3RlZCc7XG4gIHZhciBpc1NlbGVjdGVkOyAvLyBVcGRhdGUgYWxsIGxlZ2VuZCBjb21wb25lbnRzXG5cbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdsZWdlbmQnLCBmdW5jdGlvbiAobGVnZW5kTW9kZWwpIHtcbiAgICBpZiAoaXNUb2dnbGVTZWxlY3QgJiYgaXNTZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICAvLyBGb3JjZSBvdGhlciBsZWdlbmQgaGFzIHNhbWUgc2VsZWN0ZWQgc3RhdHVzXG4gICAgICAvLyBPciB0aGUgZmlyc3QgaXMgdG9nZ2xlZCB0byB0cnVlIGFuZCBvdGhlciBhcmUgdG9nZ2xlZCB0byBmYWxzZVxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb25lIGxlZ2VuZCBoYXMgc29tZSBpdGVtIHVuU2VsZWN0ZWQgaW4gb3B0aW9uLiBBbmQgaWYgb3RoZXIgbGVnZW5kXG4gICAgICAvLyBkb2Vzbid0IGhhcyB0aGUgaXRlbSwgdGhleSB3aWxsIGFzc3VtZSBpdCBpcyBzZWxlY3RlZC5cbiAgICAgIGxlZ2VuZE1vZGVsW2lzU2VsZWN0ZWQgPyAnc2VsZWN0JyA6ICd1blNlbGVjdCddKHBheWxvYWQubmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZ2VuZE1vZGVsW21ldGhvZE5hbWVdKHBheWxvYWQubmFtZSk7XG4gICAgICBpc1NlbGVjdGVkID0gbGVnZW5kTW9kZWwuaXNTZWxlY3RlZChwYXlsb2FkLm5hbWUpO1xuICAgIH1cblxuICAgIHZhciBsZWdlbmREYXRhID0gbGVnZW5kTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHpyVXRpbC5lYWNoKGxlZ2VuZERhdGEsIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgdmFyIG5hbWUgPSBtb2RlbC5nZXQoJ25hbWUnKTsgLy8gV3JhcCBlbGVtZW50XG5cbiAgICAgIGlmIChuYW1lID09PSAnXFxuJyB8fCBuYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0l0ZW1TZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQobmFtZSk7XG5cbiAgICAgIGlmIChzZWxlY3RlZE1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAvLyBVbnNlbGVjdGVkIGlmIGFueSBsZWdlbmQgaXMgdW5zZWxlY3RlZFxuICAgICAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IHNlbGVjdGVkTWFwW25hbWVdICYmIGlzSXRlbVNlbGVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWRNYXBbbmFtZV0gPSBpc0l0ZW1TZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIFJldHVybiB0aGUgZXZlbnQgZXhwbGljaXRseVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogcGF5bG9hZC5uYW1lLFxuICAgIHNlbGVjdGVkOiBzZWxlY3RlZE1hcFxuICB9O1xufVxuLyoqXG4gKiBAZXZlbnQgbGVnZW5kVG9nZ2xlU2VsZWN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFRvZ2dsZVNlbGVjdCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZnJvbV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFNlcmllcyBuYW1lIG9yIGRhdGEgaXRlbSBuYW1lXG4gKi9cblxuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRUb2dnbGVTZWxlY3QnLCAnbGVnZW5kc2VsZWN0Y2hhbmdlZCcsIHpyVXRpbC5jdXJyeShsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyLCAndG9nZ2xlU2VsZWN0ZWQnKSk7XG4vKipcbiAqIEBldmVudCBsZWdlbmRTZWxlY3RcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAnbGVnZW5kU2VsZWN0J1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAqL1xuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRTZWxlY3QnLCAnbGVnZW5kc2VsZWN0ZWQnLCB6clV0aWwuY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3NlbGVjdCcpKTtcbi8qKlxuICogQGV2ZW50IGxlZ2VuZFVuU2VsZWN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFVuU2VsZWN0J1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAqL1xuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRVblNlbGVjdCcsICdsZWdlbmR1bnNlbGVjdGVkJywgenJVdGlsLmN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICd1blNlbGVjdCcpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEFjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9sZWdlbmRBY3Rpb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5mdW5jdGlvbiBfZGVmYXVsdChlY01vZGVsKSB7XG4gIHZhciBsZWdlbmRNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICBtYWluVHlwZTogJ2xlZ2VuZCdcbiAgfSk7XG5cbiAgaWYgKGxlZ2VuZE1vZGVscyAmJiBsZWdlbmRNb2RlbHMubGVuZ3RoKSB7XG4gICAgZWNNb2RlbC5maWx0ZXJTZXJpZXMoZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgLy8gSWYgaW4gYW55IGxlZ2VuZCBjb21wb25lbnQgdGhlIHN0YXR1cyBpcyBub3Qgc2VsZWN0ZWQuXG4gICAgICAvLyBCZWNhdXNlIGluIGxlZ2VuZCBzZXJpZXMgaXMgYXNzdW1lZCBzZWxlY3RlZCB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgbGVnZW5kIGRhdGEuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZE1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWxlZ2VuZE1vZGVsc1tpXS5pc1NlbGVjdGVkKHNlcmllcy5uYW1lKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEZpbHRlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBAZXZlbnQgbGVnZW5kU2Nyb2xsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFNjcm9sbCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzY3JvbGxEYXRhSW5kZXhcbiAqL1xuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbignbGVnZW5kU2Nyb2xsJywgJ2xlZ2VuZHNjcm9sbCcsIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gIHZhciBzY3JvbGxEYXRhSW5kZXggPSBwYXlsb2FkLnNjcm9sbERhdGFJbmRleDtcbiAgc2Nyb2xsRGF0YUluZGV4ICE9IG51bGwgJiYgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICBtYWluVHlwZTogJ2xlZ2VuZCcsXG4gICAgc3ViVHlwZTogJ3Njcm9sbCcsXG4gICAgcXVlcnk6IHBheWxvYWRcbiAgfSwgZnVuY3Rpb24gKGxlZ2VuZE1vZGVsKSB7XG4gICAgbGVnZW5kTW9kZWwuc2V0U2Nyb2xsRGF0YUluZGV4KHNjcm9sbERhdGFJbmRleCk7XG4gIH0pO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9zY3JvbGxhYmxlTGVnZW5kQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL3Njcm9sbGFibGVMZWdlbmRBY3Rpb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKFwiLi9sZWdlbmRcIik7XG5cbnJlcXVpcmUoXCIuL2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kVmlld1wiKTtcblxucmVxdWlyZShcIi4vbGVnZW5kL3Njcm9sbGFibGVMZWdlbmRBY3Rpb25cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZFNjcm9sbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZFNjcm9sbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uL2VjaGFydHNcIik7XG5cbnJlcXVpcmUoXCIuL21hcmtlci9NYXJrTGluZU1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9tYXJrZXIvTWFya0xpbmVWaWV3XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5lY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHQpIHtcbiAgLy8gTWFrZSBzdXJlIG1hcmtMaW5lIGNvbXBvbmVudCBpcyBlbmFibGVkXG4gIG9wdC5tYXJrTGluZSA9IG9wdC5tYXJrTGluZSB8fCB7fTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtMaW5lLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxucmVxdWlyZShcIi4vbWFya2VyL01hcmtQb2ludE1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9tYXJrZXIvTWFya1BvaW50Vmlld1wiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gSElOVCBNYXJrcG9pbnQgY2FuJ3QgYmUgdXNlZCB0b28gbXVjaFxuZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0KSB7XG4gIC8vIE1ha2Ugc3VyZSBtYXJrUG9pbnQgY29tcG9uZW50IGlzIGVuYWJsZWRcbiAgb3B0Lm1hcmtQb2ludCA9IG9wdC5tYXJrUG9pbnQgfHwge307XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya1BvaW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIE1hcmtlck1vZGVsID0gcmVxdWlyZShcIi4vTWFya2VyTW9kZWxcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBfZGVmYXVsdCA9IE1hcmtlck1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdtYXJrTGluZScsXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogNSxcbiAgICBzeW1ib2w6IFsnY2lyY2xlJywgJ2Fycm93J10sXG4gICAgc3ltYm9sU2l6ZTogWzgsIDE2XSxcbiAgICAvL3N5bWJvbFJvdGF0ZTogMCxcbiAgICBwcmVjaXNpb246IDIsXG4gICAgdG9vbHRpcDoge1xuICAgICAgdHJpZ2dlcjogJ2l0ZW0nXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHBvc2l0aW9uOiAnZW5kJ1xuICAgIH0sXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICB0eXBlOiAnZGFzaGVkJ1xuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHNob3c6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgd2lkdGg6IDNcbiAgICAgIH1cbiAgICB9LFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcidcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrTGluZU1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtMaW5lTW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIExpc3QgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9MaXN0XCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIG1hcmtlckhlbHBlciA9IHJlcXVpcmUoXCIuL21hcmtlckhlbHBlclwiKTtcblxudmFyIExpbmVEcmF3ID0gcmVxdWlyZShcIi4uLy4uL2NoYXJ0L2hlbHBlci9MaW5lRHJhd1wiKTtcblxudmFyIE1hcmtlclZpZXcgPSByZXF1aXJlKFwiLi9NYXJrZXJWaWV3XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgbWFya0xpbmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBtbE1vZGVsLCBpdGVtKSB7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpOyAvLyBTcGVjaWFsIHR5cGUgbWFya0xpbmUgbGlrZSAnbWluJywgJ21heCcsICdhdmVyYWdlJywgJ21lZGlhbidcblxuICB2YXIgbWxUeXBlID0gaXRlbS50eXBlO1xuXG4gIGlmICghenJVdGlsLmlzQXJyYXkoaXRlbSkgJiYgKG1sVHlwZSA9PT0gJ21pbicgfHwgbWxUeXBlID09PSAnbWF4JyB8fCBtbFR5cGUgPT09ICdhdmVyYWdlJyB8fCBtbFR5cGUgPT09ICdtZWRpYW4nIC8vIEluIGNhc2VcbiAgLy8gZGF0YTogW3tcbiAgLy8gICB5QXhpczogMTBcbiAgLy8gfV1cbiAgfHwgaXRlbS54QXhpcyAhPSBudWxsIHx8IGl0ZW0ueUF4aXMgIT0gbnVsbCkpIHtcbiAgICB2YXIgdmFsdWVBeGlzO1xuICAgIHZhciB2YWx1ZURhdGFEaW07XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgaWYgKGl0ZW0ueUF4aXMgIT0gbnVsbCB8fCBpdGVtLnhBeGlzICE9IG51bGwpIHtcbiAgICAgIHZhbHVlRGF0YURpbSA9IGl0ZW0ueUF4aXMgIT0gbnVsbCA/ICd5JyA6ICd4JztcbiAgICAgIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldEF4aXModmFsdWVEYXRhRGltKTtcbiAgICAgIHZhbHVlID0genJVdGlsLnJldHJpZXZlKGl0ZW0ueUF4aXMsIGl0ZW0ueEF4aXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXhpc0luZm8gPSBtYXJrZXJIZWxwZXIuZ2V0QXhpc0luZm8oaXRlbSwgZGF0YSwgY29vcmRTeXMsIHNlcmllc01vZGVsKTtcbiAgICAgIHZhbHVlRGF0YURpbSA9IGF4aXNJbmZvLnZhbHVlRGF0YURpbTtcbiAgICAgIHZhbHVlQXhpcyA9IGF4aXNJbmZvLnZhbHVlQXhpcztcbiAgICAgIHZhbHVlID0gbWFya2VySGVscGVyLm51bUNhbGN1bGF0ZShkYXRhLCB2YWx1ZURhdGFEaW0sIG1sVHlwZSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlSW5kZXggPSB2YWx1ZURhdGFEaW0gPT09ICd4JyA/IDAgOiAxO1xuICAgIHZhciBiYXNlSW5kZXggPSAxIC0gdmFsdWVJbmRleDtcbiAgICB2YXIgbWxGcm9tID0genJVdGlsLmNsb25lKGl0ZW0pO1xuICAgIHZhciBtbFRvID0ge307XG4gICAgbWxGcm9tLnR5cGUgPSBudWxsO1xuICAgIG1sRnJvbS5jb29yZCA9IFtdO1xuICAgIG1sVG8uY29vcmQgPSBbXTtcbiAgICBtbEZyb20uY29vcmRbYmFzZUluZGV4XSA9IC1JbmZpbml0eTtcbiAgICBtbFRvLmNvb3JkW2Jhc2VJbmRleF0gPSBJbmZpbml0eTtcbiAgICB2YXIgcHJlY2lzaW9uID0gbWxNb2RlbC5nZXQoJ3ByZWNpc2lvbicpO1xuXG4gICAgaWYgKHByZWNpc2lvbiA+PSAwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlLnRvRml4ZWQoTWF0aC5taW4ocHJlY2lzaW9uLCAyMCkpO1xuICAgIH1cblxuICAgIG1sRnJvbS5jb29yZFt2YWx1ZUluZGV4XSA9IG1sVG8uY29vcmRbdmFsdWVJbmRleF0gPSB2YWx1ZTtcbiAgICBpdGVtID0gW21sRnJvbSwgbWxUbywge1xuICAgICAgLy8gRXh0cmEgb3B0aW9uIGZvciB0b29sdGlwIGFuZCBsYWJlbFxuICAgICAgdHlwZTogbWxUeXBlLFxuICAgICAgdmFsdWVJbmRleDogaXRlbS52YWx1ZUluZGV4LFxuICAgICAgLy8gRm9yY2UgdG8gdXNlIHRoZSB2YWx1ZSBvZiBjYWxjdWxhdGVkIHZhbHVlLlxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfV07XG4gIH1cblxuICBpdGVtID0gW21hcmtlckhlbHBlci5kYXRhVHJhbnNmb3JtKHNlcmllc01vZGVsLCBpdGVtWzBdKSwgbWFya2VySGVscGVyLmRhdGFUcmFuc2Zvcm0oc2VyaWVzTW9kZWwsIGl0ZW1bMV0pLCB6clV0aWwuZXh0ZW5kKHt9LCBpdGVtWzJdKV07IC8vIEF2b2lkIGxpbmUgZGF0YSB0eXBlIGlzIGV4dGVuZGVkIGJ5IGZyb20odG8pIGRhdGEgdHlwZVxuXG4gIGl0ZW1bMl0udHlwZSA9IGl0ZW1bMl0udHlwZSB8fCAnJzsgLy8gTWVyZ2UgZnJvbSBvcHRpb24gYW5kIHRvIG9wdGlvbiBpbnRvIGxpbmUgb3B0aW9uXG5cbiAgenJVdGlsLm1lcmdlKGl0ZW1bMl0sIGl0ZW1bMF0pO1xuICB6clV0aWwubWVyZ2UoaXRlbVsyXSwgaXRlbVsxXSk7XG4gIHJldHVybiBpdGVtO1xufTtcblxuZnVuY3Rpb24gaXNJbmlmaW5pdHkodmFsKSB7XG4gIHJldHVybiAhaXNOYU4odmFsKSAmJiAhaXNGaW5pdGUodmFsKTtcbn0gLy8gSWYgYSBtYXJrTGluZSBoYXMgb25lIGRpbVxuXG5cbmZ1bmN0aW9uIGlmTWFya0xpbmVIYXNPbmx5RGltKGRpbUluZGV4LCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSB7XG4gIHZhciBvdGhlckRpbUluZGV4ID0gMSAtIGRpbUluZGV4O1xuICB2YXIgZGltTmFtZSA9IGNvb3JkU3lzLmRpbWVuc2lvbnNbZGltSW5kZXhdO1xuICByZXR1cm4gaXNJbmlmaW5pdHkoZnJvbUNvb3JkW290aGVyRGltSW5kZXhdKSAmJiBpc0luaWZpbml0eSh0b0Nvb3JkW290aGVyRGltSW5kZXhdKSAmJiBmcm9tQ29vcmRbZGltSW5kZXhdID09PSB0b0Nvb3JkW2RpbUluZGV4XSAmJiBjb29yZFN5cy5nZXRBeGlzKGRpbU5hbWUpLmNvbnRhaW5EYXRhKGZyb21Db29yZFtkaW1JbmRleF0pO1xufVxuXG5mdW5jdGlvbiBtYXJrTGluZUZpbHRlcihjb29yZFN5cywgaXRlbSkge1xuICBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgIHZhciBmcm9tQ29vcmQgPSBpdGVtWzBdLmNvb3JkO1xuICAgIHZhciB0b0Nvb3JkID0gaXRlbVsxXS5jb29yZDsgLy8gSW4gY2FzZVxuICAgIC8vIHtcbiAgICAvLyAgbWFya0xpbmU6IHtcbiAgICAvLyAgICBkYXRhOiBbeyB5QXhpczogMiB9XVxuICAgIC8vICB9XG4gICAgLy8gfVxuXG4gICAgaWYgKGZyb21Db29yZCAmJiB0b0Nvb3JkICYmIChpZk1hcmtMaW5lSGFzT25seURpbSgxLCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSB8fCBpZk1hcmtMaW5lSGFzT25seURpbSgwLCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXJrZXJIZWxwZXIuZGF0YUZpbHRlcihjb29yZFN5cywgaXRlbVswXSkgJiYgbWFya2VySGVscGVyLmRhdGFGaWx0ZXIoY29vcmRTeXMsIGl0ZW1bMV0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQoZGF0YSwgaWR4LCBpc0Zyb20sIHNlcmllc01vZGVsLCBhcGkpIHtcbiAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gIHZhciBwb2ludDtcbiAgdmFyIHhQeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGl0ZW1Nb2RlbC5nZXQoJ3gnKSwgYXBpLmdldFdpZHRoKCkpO1xuICB2YXIgeVB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneScpLCBhcGkuZ2V0SGVpZ2h0KCkpO1xuXG4gIGlmICghaXNOYU4oeFB4KSAmJiAhaXNOYU4oeVB4KSkge1xuICAgIHBvaW50ID0gW3hQeCwgeVB4XTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDaGFydCBsaWtlIGJhciBtYXkgaGF2ZSB0aGVyZSBvd24gbWFya2VyIHBvc2l0aW9uaW5nIGxvZ2ljXG4gICAgaWYgKHNlcmllc01vZGVsLmdldE1hcmtlclBvc2l0aW9uKSB7XG4gICAgICAvLyBVc2UgdGhlIGdldE1hcmtlclBvaXNpdGlvblxuICAgICAgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbihkYXRhLmdldFZhbHVlcyhkYXRhLmRpbWVuc2lvbnMsIGlkeCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICB2YXIgeCA9IGRhdGEuZ2V0KGRpbXNbMF0sIGlkeCk7XG4gICAgICB2YXIgeSA9IGRhdGEuZ2V0KGRpbXNbMV0sIGlkeCk7XG4gICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSk7XG4gICAgfSAvLyBFeHBhbmQgbGluZSB0byB0aGUgZWRnZSBvZiBncmlkIGlmIHZhbHVlIG9uIG9uZSBheGlzIGlzIEluaWZuaXR5XG4gICAgLy8gSW4gY2FzZVxuICAgIC8vICBtYXJrTGluZToge1xuICAgIC8vICAgIGRhdGE6IFt7XG4gICAgLy8gICAgICB5QXhpczogMlxuICAgIC8vICAgICAgLy8gb3JcbiAgICAvLyAgICAgIHR5cGU6ICdhdmVyYWdlJ1xuICAgIC8vICAgIH1dXG4gICAgLy8gIH1cblxuXG4gICAgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgIHZhciB4QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3gnKTtcbiAgICAgIHZhciB5QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3knKTtcbiAgICAgIHZhciBkaW1zID0gY29vcmRTeXMuZGltZW5zaW9ucztcblxuICAgICAgaWYgKGlzSW5pZmluaXR5KGRhdGEuZ2V0KGRpbXNbMF0sIGlkeCkpKSB7XG4gICAgICAgIHBvaW50WzBdID0geEF4aXMudG9HbG9iYWxDb29yZCh4QXhpcy5nZXRFeHRlbnQoKVtpc0Zyb20gPyAwIDogMV0pO1xuICAgICAgfSBlbHNlIGlmIChpc0luaWZpbml0eShkYXRhLmdldChkaW1zWzFdLCBpZHgpKSkge1xuICAgICAgICBwb2ludFsxXSA9IHlBeGlzLnRvR2xvYmFsQ29vcmQoeUF4aXMuZ2V0RXh0ZW50KClbaXNGcm9tID8gMCA6IDFdKTtcbiAgICAgIH1cbiAgICB9IC8vIFVzZSB4LCB5IGlmIGhhcyBhbnlcblxuXG4gICAgaWYgKCFpc05hTih4UHgpKSB7XG4gICAgICBwb2ludFswXSA9IHhQeDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKHlQeCkpIHtcbiAgICAgIHBvaW50WzFdID0geVB4O1xuICAgIH1cbiAgfVxuXG4gIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHBvaW50KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gTWFya2VyVmlldy5leHRlbmQoe1xuICB0eXBlOiAnbWFya0xpbmUnLFxuICAvLyB1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uIChtYXJrTGluZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgLy8gICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgLy8gICAgICAgICB2YXIgbWxNb2RlbCA9IHNlcmllc01vZGVsLm1hcmtMaW5lTW9kZWw7XG4gIC8vICAgICAgICAgaWYgKG1sTW9kZWwpIHtcbiAgLy8gICAgICAgICAgICAgdmFyIG1sRGF0YSA9IG1sTW9kZWwuZ2V0RGF0YSgpO1xuICAvLyAgICAgICAgICAgICB2YXIgZnJvbURhdGEgPSBtbE1vZGVsLl9fZnJvbTtcbiAgLy8gICAgICAgICAgICAgdmFyIHRvRGF0YSA9IG1sTW9kZWwuX190bztcbiAgLy8gICAgICAgICAgICAgLy8gVXBkYXRlIHZpc3VhbCBhbmQgbGF5b3V0IG9mIGZyb20gc3ltYm9sIGFuZCB0byBzeW1ib2xcbiAgLy8gICAgICAgICAgICAgZnJvbURhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gIC8vICAgICAgICAgICAgICAgICB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQoZnJvbURhdGEsIGlkeCwgdHJ1ZSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gIC8vICAgICAgICAgICAgICAgICB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQodG9EYXRhLCBpZHgsIGZhbHNlLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgLy8gICAgICAgICAgICAgfSk7XG4gIC8vICAgICAgICAgICAgIC8vIFVwZGF0ZSBsYXlvdXQgb2YgbGluZVxuICAvLyAgICAgICAgICAgICBtbERhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gIC8vICAgICAgICAgICAgICAgICBtbERhdGEuc2V0SXRlbUxheW91dChpZHgsIFtcbiAgLy8gICAgICAgICAgICAgICAgICAgICBmcm9tRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCksXG4gIC8vICAgICAgICAgICAgICAgICAgICAgdG9EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KVxuICAvLyAgICAgICAgICAgICAgICAgXSk7XG4gIC8vICAgICAgICAgICAgIH0pO1xuICAvLyAgICAgICAgICAgICB0aGlzLm1hcmtlckdyb3VwTWFwLmdldChzZXJpZXNNb2RlbC5pZCkudXBkYXRlTGF5b3V0KCk7XG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgfSwgdGhpcyk7XG4gIC8vIH0sXG4gIHVwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKG1hcmtMaW5lTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBtbE1vZGVsID0gc2VyaWVzTW9kZWwubWFya0xpbmVNb2RlbDtcblxuICAgICAgaWYgKG1sTW9kZWwpIHtcbiAgICAgICAgdmFyIG1sRGF0YSA9IG1sTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgZnJvbURhdGEgPSBtbE1vZGVsLl9fZnJvbTtcbiAgICAgICAgdmFyIHRvRGF0YSA9IG1sTW9kZWwuX190bzsgLy8gVXBkYXRlIHZpc3VhbCBhbmQgbGF5b3V0IG9mIGZyb20gc3ltYm9sIGFuZCB0byBzeW1ib2xcblxuICAgICAgICBmcm9tRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQoZnJvbURhdGEsIGlkeCwgdHJ1ZSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgICAgdXBkYXRlU2luZ2xlTWFya2VyRW5kTGF5b3V0KHRvRGF0YSwgaWR4LCBmYWxzZSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgIH0pOyAvLyBVcGRhdGUgbGF5b3V0IG9mIGxpbmVcblxuICAgICAgICBtbERhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgbWxEYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBbZnJvbURhdGEuZ2V0SXRlbUxheW91dChpZHgpLCB0b0RhdGEuZ2V0SXRlbUxheW91dChpZHgpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcmtlckdyb3VwTWFwLmdldChzZXJpZXNNb2RlbC5pZCkudXBkYXRlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIHJlbmRlclNlcmllczogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBtbE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBzZXJpZXNJZCA9IHNlcmllc01vZGVsLmlkO1xuICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBsaW5lRHJhd01hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgdmFyIGxpbmVEcmF3ID0gbGluZURyYXdNYXAuZ2V0KHNlcmllc0lkKSB8fCBsaW5lRHJhd01hcC5zZXQoc2VyaWVzSWQsIG5ldyBMaW5lRHJhdygpKTtcbiAgICB0aGlzLmdyb3VwLmFkZChsaW5lRHJhdy5ncm91cCk7XG4gICAgdmFyIG1sRGF0YSA9IGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtbE1vZGVsKTtcbiAgICB2YXIgZnJvbURhdGEgPSBtbERhdGEuZnJvbTtcbiAgICB2YXIgdG9EYXRhID0gbWxEYXRhLnRvO1xuICAgIHZhciBsaW5lRGF0YSA9IG1sRGF0YS5saW5lO1xuICAgIG1sTW9kZWwuX19mcm9tID0gZnJvbURhdGE7XG4gICAgbWxNb2RlbC5fX3RvID0gdG9EYXRhOyAvLyBMaW5lIGRhdGEgZm9yIHRvb2x0aXAgYW5kIGZvcm1hdHRlclxuXG4gICAgbWxNb2RlbC5zZXREYXRhKGxpbmVEYXRhKTtcbiAgICB2YXIgc3ltYm9sVHlwZSA9IG1sTW9kZWwuZ2V0KCdzeW1ib2wnKTtcbiAgICB2YXIgc3ltYm9sU2l6ZSA9IG1sTW9kZWwuZ2V0KCdzeW1ib2xTaXplJyk7XG5cbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFR5cGUpKSB7XG4gICAgICBzeW1ib2xUeXBlID0gW3N5bWJvbFR5cGUsIHN5bWJvbFR5cGVdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3ltYm9sU2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XG4gICAgfSAvLyBVcGRhdGUgdmlzdWFsIGFuZCBsYXlvdXQgb2YgZnJvbSBzeW1ib2wgYW5kIHRvIHN5bWJvbFxuXG5cbiAgICBtbERhdGEuZnJvbS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHVwZGF0ZURhdGFWaXN1YWxBbmRMYXlvdXQoZnJvbURhdGEsIGlkeCwgdHJ1ZSk7XG4gICAgICB1cGRhdGVEYXRhVmlzdWFsQW5kTGF5b3V0KHRvRGF0YSwgaWR4LCBmYWxzZSk7XG4gICAgfSk7IC8vIFVwZGF0ZSB2aXN1YWwgYW5kIGxheW91dCBvZiBsaW5lXG5cbiAgICBsaW5lRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBsaW5lQ29sb3IgPSBsaW5lRGF0YS5nZXRJdGVtTW9kZWwoaWR4KS5nZXQoJ2xpbmVTdHlsZS5jb2xvcicpO1xuICAgICAgbGluZURhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvciB8fCBmcm9tRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJylcbiAgICAgIH0pO1xuICAgICAgbGluZURhdGEuc2V0SXRlbUxheW91dChpZHgsIFtmcm9tRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCksIHRvRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCldKTtcbiAgICAgIGxpbmVEYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCB7XG4gICAgICAgICdmcm9tU3ltYm9sU2l6ZSc6IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScpLFxuICAgICAgICAnZnJvbVN5bWJvbCc6IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJyksXG4gICAgICAgICd0b1N5bWJvbFNpemUnOiB0b0RhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJyksXG4gICAgICAgICd0b1N5bWJvbCc6IHRvRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBsaW5lRHJhdy51cGRhdGVEYXRhKGxpbmVEYXRhKTsgLy8gU2V0IGhvc3QgbW9kZWwgZm9yIHRvb2x0aXBcbiAgICAvLyBGSVhNRVxuXG4gICAgbWxEYXRhLmxpbmUuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgIGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5kYXRhTW9kZWwgPSBtbE1vZGVsO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVEYXRhVmlzdWFsQW5kTGF5b3V0KGRhdGEsIGlkeCwgaXNGcm9tKSB7XG4gICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dChkYXRhLCBpZHgsIGlzRnJvbSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCB7XG4gICAgICAgIHN5bWJvbFNpemU6IGl0ZW1Nb2RlbC5nZXQoJ3N5bWJvbFNpemUnKSB8fCBzeW1ib2xTaXplW2lzRnJvbSA/IDAgOiAxXSxcbiAgICAgICAgc3ltYm9sOiBpdGVtTW9kZWwuZ2V0KCdzeW1ib2wnLCB0cnVlKSB8fCBzeW1ib2xUeXBlW2lzRnJvbSA/IDAgOiAxXSxcbiAgICAgICAgY29sb3I6IGl0ZW1Nb2RlbC5nZXQoJ2l0ZW1TdHlsZS5jb2xvcicpIHx8IHNlcmllc0RhdGEuZ2V0VmlzdWFsKCdjb2xvcicpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsaW5lRHJhdy5fX2tlZXAgPSB0cnVlO1xuICAgIGxpbmVEcmF3Lmdyb3VwLnNpbGVudCA9IG1sTW9kZWwuZ2V0KCdzaWxlbnQnKSB8fCBzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuICB9XG59KTtcbi8qKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IGNvb3JkU3lzXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG1wTW9kZWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtbE1vZGVsKSB7XG4gIHZhciBjb29yZERpbXNJbmZvcztcblxuICBpZiAoY29vcmRTeXMpIHtcbiAgICBjb29yZERpbXNJbmZvcyA9IHpyVXRpbC5tYXAoY29vcmRTeXMgJiYgY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgICB2YXIgaW5mbyA9IHNlcmllc01vZGVsLmdldERhdGEoKS5nZXREaW1lbnNpb25JbmZvKHNlcmllc01vZGVsLmdldERhdGEoKS5tYXBEaW1lbnNpb24oY29vcmREaW0pKSB8fCB7fTsgLy8gSW4gbWFwIHNlcmllcyBkYXRhIGRvbid0IGhhdmUgbG5nIGFuZCBsYXQgZGltZW5zaW9uLiBGYWxsYmFjayB0byBzYW1lIHdpdGggY29vcmRTeXNcblxuICAgICAgcmV0dXJuIHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgIG5hbWU6IGNvb3JkRGltXG4gICAgICB9LCBpbmZvKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb29yZERpbXNJbmZvcyA9IFt7XG4gICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgdHlwZTogJ2Zsb2F0J1xuICAgIH1dO1xuICB9XG5cbiAgdmFyIGZyb21EYXRhID0gbmV3IExpc3QoY29vcmREaW1zSW5mb3MsIG1sTW9kZWwpO1xuICB2YXIgdG9EYXRhID0gbmV3IExpc3QoY29vcmREaW1zSW5mb3MsIG1sTW9kZWwpOyAvLyBObyBkaW1lbnNpb25zXG5cbiAgdmFyIGxpbmVEYXRhID0gbmV3IExpc3QoW10sIG1sTW9kZWwpO1xuICB2YXIgb3B0RGF0YSA9IHpyVXRpbC5tYXAobWxNb2RlbC5nZXQoJ2RhdGEnKSwgenJVdGlsLmN1cnJ5KG1hcmtMaW5lVHJhbnNmb3JtLCBzZXJpZXNNb2RlbCwgY29vcmRTeXMsIG1sTW9kZWwpKTtcblxuICBpZiAoY29vcmRTeXMpIHtcbiAgICBvcHREYXRhID0genJVdGlsLmZpbHRlcihvcHREYXRhLCB6clV0aWwuY3VycnkobWFya0xpbmVGaWx0ZXIsIGNvb3JkU3lzKSk7XG4gIH1cblxuICB2YXIgZGltVmFsdWVHZXR0ZXIgPSBjb29yZFN5cyA/IG1hcmtlckhlbHBlci5kaW1WYWx1ZUdldHRlciA6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gIH07XG4gIGZyb21EYXRhLmluaXREYXRhKHpyVXRpbC5tYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVswXTtcbiAgfSksIG51bGwsIGRpbVZhbHVlR2V0dGVyKTtcbiAgdG9EYXRhLmluaXREYXRhKHpyVXRpbC5tYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVsxXTtcbiAgfSksIG51bGwsIGRpbVZhbHVlR2V0dGVyKTtcbiAgbGluZURhdGEuaW5pdERhdGEoenJVdGlsLm1hcChvcHREYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtWzJdO1xuICB9KSk7XG4gIGxpbmVEYXRhLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICByZXR1cm4ge1xuICAgIGZyb206IGZyb21EYXRhLFxuICAgIHRvOiB0b0RhdGEsXG4gICAgbGluZTogbGluZURhdGFcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtMaW5lVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrTGluZVZpZXcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgTWFya2VyTW9kZWwgPSByZXF1aXJlKFwiLi9NYXJrZXJNb2RlbFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9kZWZhdWx0ID0gTWFya2VyTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ21hcmtQb2ludCcsXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogNSxcbiAgICBzeW1ib2w6ICdwaW4nLFxuICAgIHN5bWJvbFNpemU6IDUwLFxuICAgIC8vc3ltYm9sUm90YXRlOiAwLFxuICAgIC8vc3ltYm9sT2Zmc2V0OiBbMCwgMF1cbiAgICB0b29sdGlwOiB7XG4gICAgICB0cmlnZ2VyOiAnaXRlbSdcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgcG9zaXRpb246ICdpbnNpZGUnXG4gICAgfSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIGJvcmRlcldpZHRoOiAyXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrUG9pbnRNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrUG9pbnRNb2RlbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgU3ltYm9sRHJhdyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFydC9oZWxwZXIvU3ltYm9sRHJhd1wiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBMaXN0ID0gcmVxdWlyZShcIi4uLy4uL2RhdGEvTGlzdFwiKTtcblxudmFyIG1hcmtlckhlbHBlciA9IHJlcXVpcmUoXCIuL21hcmtlckhlbHBlclwiKTtcblxudmFyIE1hcmtlclZpZXcgPSByZXF1aXJlKFwiLi9NYXJrZXJWaWV3XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5mdW5jdGlvbiB1cGRhdGVNYXJrZXJMYXlvdXQobXBEYXRhLCBzZXJpZXNNb2RlbCwgYXBpKSB7XG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIG1wRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICB2YXIgaXRlbU1vZGVsID0gbXBEYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIHZhciBwb2ludDtcbiAgICB2YXIgeFB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneCcpLCBhcGkuZ2V0V2lkdGgoKSk7XG4gICAgdmFyIHlQeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGl0ZW1Nb2RlbC5nZXQoJ3knKSwgYXBpLmdldEhlaWdodCgpKTtcblxuICAgIGlmICghaXNOYU4oeFB4KSAmJiAhaXNOYU4oeVB4KSkge1xuICAgICAgcG9pbnQgPSBbeFB4LCB5UHhdO1xuICAgIH0gLy8gQ2hhcnQgbGlrZSBiYXIgbWF5IGhhdmUgdGhlcmUgb3duIG1hcmtlciBwb3NpdGlvbmluZyBsb2dpY1xuICAgIGVsc2UgaWYgKHNlcmllc01vZGVsLmdldE1hcmtlclBvc2l0aW9uKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgZ2V0TWFya2VyUG9pc2l0aW9uXG4gICAgICAgIHBvaW50ID0gc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24obXBEYXRhLmdldFZhbHVlcyhtcERhdGEuZGltZW5zaW9ucywgaWR4KSk7XG4gICAgICB9IGVsc2UgaWYgKGNvb3JkU3lzKSB7XG4gICAgICAgIHZhciB4ID0gbXBEYXRhLmdldChjb29yZFN5cy5kaW1lbnNpb25zWzBdLCBpZHgpO1xuICAgICAgICB2YXIgeSA9IG1wRGF0YS5nZXQoY29vcmRTeXMuZGltZW5zaW9uc1sxXSwgaWR4KTtcbiAgICAgICAgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludChbeCwgeV0pO1xuICAgICAgfSAvLyBVc2UgeCwgeSBpZiBoYXMgYW55XG5cblxuICAgIGlmICghaXNOYU4oeFB4KSkge1xuICAgICAgcG9pbnRbMF0gPSB4UHg7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTih5UHgpKSB7XG4gICAgICBwb2ludFsxXSA9IHlQeDtcbiAgICB9XG5cbiAgICBtcERhdGEuc2V0SXRlbUxheW91dChpZHgsIHBvaW50KTtcbiAgfSk7XG59XG5cbnZhciBfZGVmYXVsdCA9IE1hcmtlclZpZXcuZXh0ZW5kKHtcbiAgdHlwZTogJ21hcmtQb2ludCcsXG4gIC8vIHVwZGF0ZUxheW91dDogZnVuY3Rpb24gKG1hcmtQb2ludE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgLy8gICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgLy8gICAgICAgICB2YXIgbXBNb2RlbCA9IHNlcmllc01vZGVsLm1hcmtQb2ludE1vZGVsO1xuICAvLyAgICAgICAgIGlmIChtcE1vZGVsKSB7XG4gIC8vICAgICAgICAgICAgIHVwZGF0ZU1hcmtlckxheW91dChtcE1vZGVsLmdldERhdGEoKSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gIC8vICAgICAgICAgICAgIHRoaXMubWFya2VyR3JvdXBNYXAuZ2V0KHNlcmllc01vZGVsLmlkKS51cGRhdGVMYXlvdXQobXBNb2RlbCk7XG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgfSwgdGhpcyk7XG4gIC8vIH0sXG4gIHVwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKG1hcmtQb2ludE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgbXBNb2RlbCA9IHNlcmllc01vZGVsLm1hcmtQb2ludE1vZGVsO1xuXG4gICAgICBpZiAobXBNb2RlbCkge1xuICAgICAgICB1cGRhdGVNYXJrZXJMYXlvdXQobXBNb2RlbC5nZXREYXRhKCksIHNlcmllc01vZGVsLCBhcGkpO1xuICAgICAgICB0aGlzLm1hcmtlckdyb3VwTWFwLmdldChzZXJpZXNNb2RlbC5pZCkudXBkYXRlTGF5b3V0KG1wTW9kZWwpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuICByZW5kZXJTZXJpZXM6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgbXBNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgc2VyaWVzSWQgPSBzZXJpZXNNb2RlbC5pZDtcbiAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgc3ltYm9sRHJhd01hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgdmFyIHN5bWJvbERyYXcgPSBzeW1ib2xEcmF3TWFwLmdldChzZXJpZXNJZCkgfHwgc3ltYm9sRHJhd01hcC5zZXQoc2VyaWVzSWQsIG5ldyBTeW1ib2xEcmF3KCkpO1xuICAgIHZhciBtcERhdGEgPSBjcmVhdGVMaXN0KGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgbXBNb2RlbCk7IC8vIEZJWE1FXG5cbiAgICBtcE1vZGVsLnNldERhdGEobXBEYXRhKTtcbiAgICB1cGRhdGVNYXJrZXJMYXlvdXQobXBNb2RlbC5nZXREYXRhKCksIHNlcmllc01vZGVsLCBhcGkpO1xuICAgIG1wRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBtcERhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICB2YXIgc3ltYm9sU2l6ZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xTaXplJyk7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3ltYm9sU2l6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBGSVhNRSDov5nph4zkuI3lhbzlrrkgRUNoYXJ0cyAyLnjvvIwyLngg6LKM5Ly85Y+C5pWw5piv5pW05Liq5pWw5o2u77yfXG4gICAgICAgIHN5bWJvbFNpemUgPSBzeW1ib2xTaXplKG1wTW9kZWwuZ2V0UmF3VmFsdWUoaWR4KSwgbXBNb2RlbC5nZXREYXRhUGFyYW1zKGlkeCkpO1xuICAgICAgfVxuXG4gICAgICBtcERhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgICAgc3ltYm9sU2l6ZTogc3ltYm9sU2l6ZSxcbiAgICAgICAgY29sb3I6IGl0ZW1Nb2RlbC5nZXQoJ2l0ZW1TdHlsZS5jb2xvcicpIHx8IHNlcmllc0RhdGEuZ2V0VmlzdWFsKCdjb2xvcicpLFxuICAgICAgICBzeW1ib2w6IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2wnKVxuICAgICAgfSk7XG4gICAgfSk7IC8vIFRPRE8gVGV4dCBhcmUgd3JvbmdcblxuICAgIHN5bWJvbERyYXcudXBkYXRlRGF0YShtcERhdGEpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbERyYXcuZ3JvdXApOyAvLyBTZXQgaG9zdCBtb2RlbCBmb3IgdG9vbHRpcFxuICAgIC8vIEZJWE1FXG5cbiAgICBtcERhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuZGF0YU1vZGVsID0gbXBNb2RlbDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHN5bWJvbERyYXcuX19rZWVwID0gdHJ1ZTtcbiAgICBzeW1ib2xEcmF3Lmdyb3VwLnNpbGVudCA9IG1wTW9kZWwuZ2V0KCdzaWxlbnQnKSB8fCBzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuICB9XG59KTtcbi8qKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IFtjb29yZFN5c11cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbXBNb2RlbFxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTGlzdChjb29yZFN5cywgc2VyaWVzTW9kZWwsIG1wTW9kZWwpIHtcbiAgdmFyIGNvb3JkRGltc0luZm9zO1xuXG4gIGlmIChjb29yZFN5cykge1xuICAgIGNvb3JkRGltc0luZm9zID0genJVdGlsLm1hcChjb29yZFN5cyAmJiBjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICAgIHZhciBpbmZvID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmdldERpbWVuc2lvbkluZm8oc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLm1hcERpbWVuc2lvbihjb29yZERpbSkpIHx8IHt9OyAvLyBJbiBtYXAgc2VyaWVzIGRhdGEgZG9uJ3QgaGF2ZSBsbmcgYW5kIGxhdCBkaW1lbnNpb24uIEZhbGxiYWNrIHRvIHNhbWUgd2l0aCBjb29yZFN5c1xuXG4gICAgICByZXR1cm4genJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgbmFtZTogY29vcmREaW1cbiAgICAgIH0sIGluZm8pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvb3JkRGltc0luZm9zID0gW3tcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICB0eXBlOiAnZmxvYXQnXG4gICAgfV07XG4gIH1cblxuICB2YXIgbXBEYXRhID0gbmV3IExpc3QoY29vcmREaW1zSW5mb3MsIG1wTW9kZWwpO1xuICB2YXIgZGF0YU9wdCA9IHpyVXRpbC5tYXAobXBNb2RlbC5nZXQoJ2RhdGEnKSwgenJVdGlsLmN1cnJ5KG1hcmtlckhlbHBlci5kYXRhVHJhbnNmb3JtLCBzZXJpZXNNb2RlbCkpO1xuXG4gIGlmIChjb29yZFN5cykge1xuICAgIGRhdGFPcHQgPSB6clV0aWwuZmlsdGVyKGRhdGFPcHQsIHpyVXRpbC5jdXJyeShtYXJrZXJIZWxwZXIuZGF0YUZpbHRlciwgY29vcmRTeXMpKTtcbiAgfVxuXG4gIG1wRGF0YS5pbml0RGF0YShkYXRhT3B0LCBudWxsLCBjb29yZFN5cyA/IG1hcmtlckhlbHBlci5kaW1WYWx1ZUdldHRlciA6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gIH0pO1xuICByZXR1cm4gbXBEYXRhO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50Vmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrUG9pbnRWaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBkYXRhRm9ybWF0TWl4aW4gPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvbWl4aW4vZGF0YUZvcm1hdFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGFkZENvbW1hcyA9IGZvcm1hdFV0aWwuYWRkQ29tbWFzO1xudmFyIGVuY29kZUhUTUwgPSBmb3JtYXRVdGlsLmVuY29kZUhUTUw7XG5cbmZ1bmN0aW9uIGZpbGxMYWJlbChvcHQpIHtcbiAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhvcHQsICdsYWJlbCcsIFsnc2hvdyddKTtcbn1cblxudmFyIE1hcmtlck1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdtYXJrZXInLFxuICBkZXBlbmRlbmNpZXM6IFsnc2VyaWVzJywgJ2dyaWQnLCAncG9sYXInLCAnZ2VvJ10sXG5cbiAgLyoqXG4gICAqIEBvdmVycml0ZVxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIHRoaXMubWVyZ2VPcHRpb24ob3B0aW9uLCBlY01vZGVsLCBleHRyYU9wdC5jcmVhdGVkQnlTZWxmLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQW5pbWF0aW9uRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBob3N0U2VyaWVzID0gdGhpcy5fX2hvc3RTZXJpZXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uJykgJiYgaG9zdFNlcmllcyAmJiBob3N0U2VyaWVzLmlzQW5pbWF0aW9uRW5hYmxlZCgpO1xuICB9LFxuICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdCwgZWNNb2RlbCwgY3JlYXRlZEJ5U2VsZiwgaXNJbml0KSB7XG4gICAgdmFyIE1hcmtlck1vZGVsID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgbW9kZWxQcm9wTmFtZSA9IHRoaXMubWFpblR5cGUgKyAnTW9kZWwnO1xuXG4gICAgaWYgKCFjcmVhdGVkQnlTZWxmKSB7XG4gICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIHZhciBtYXJrZXJPcHQgPSBzZXJpZXNNb2RlbC5nZXQodGhpcy5tYWluVHlwZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBtYXJrZXJNb2RlbCA9IHNlcmllc01vZGVsW21vZGVsUHJvcE5hbWVdO1xuXG4gICAgICAgIGlmICghbWFya2VyT3B0IHx8ICFtYXJrZXJPcHQuZGF0YSkge1xuICAgICAgICAgIHNlcmllc01vZGVsW21vZGVsUHJvcE5hbWVdID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hcmtlck1vZGVsKSB7XG4gICAgICAgICAgaWYgKGlzSW5pdCkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBsYWJlbCBlbXBoYXNpcyBgcG9zaXRpb25gIGFuZCBgc2hvd2BcbiAgICAgICAgICAgIGZpbGxMYWJlbChtYXJrZXJPcHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHpyVXRpbC5lYWNoKG1hcmtlck9wdC5kYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgLy8gRklYTUUgT3ZlcndyaXRlIGZpbGxMYWJlbCBtZXRob2QgP1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICBmaWxsTGFiZWwoaXRlbVswXSk7XG4gICAgICAgICAgICAgIGZpbGxMYWJlbChpdGVtWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbGxMYWJlbChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrZXJNb2RlbCA9IG5ldyBNYXJrZXJNb2RlbChtYXJrZXJPcHQsIHRoaXMsIGVjTW9kZWwpO1xuICAgICAgICAgIHpyVXRpbC5leHRlbmQobWFya2VyTW9kZWwsIHtcbiAgICAgICAgICAgIG1haW5UeXBlOiB0aGlzLm1haW5UeXBlLFxuICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIHNlcmllcyBpbmRleCBhbmQgbmFtZVxuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc01vZGVsLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgbmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICAgICAgICAgIGNyZWF0ZWRCeVNlbGY6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrZXJNb2RlbC5fX2hvc3RTZXJpZXMgPSBzZXJpZXNNb2RlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrZXJNb2RlbC5tZXJnZU9wdGlvbihtYXJrZXJPcHQsIGVjTW9kZWwsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWVzTW9kZWxbbW9kZWxQcm9wTmFtZV0gPSBtYXJrZXJNb2RlbDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSxcbiAgZm9ybWF0VG9vbHRpcDogZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpO1xuICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHpyVXRpbC5pc0FycmF5KHZhbHVlKSA/IHpyVXRpbC5tYXAodmFsdWUsIGFkZENvbW1hcykuam9pbignLCAnKSA6IGFkZENvbW1hcyh2YWx1ZSk7XG4gICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICB2YXIgaHRtbCA9IGVuY29kZUhUTUwodGhpcy5uYW1lKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsIHx8IG5hbWUpIHtcbiAgICAgIGh0bWwgKz0gJzxiciAvPic7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGh0bWwgKz0gZW5jb2RlSFRNTChuYW1lKTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSAnIDogJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaHRtbCArPSBlbmNvZGVIVE1MKGZvcm1hdHRlZFZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfSxcbiAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9LFxuICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG59KTtcbnpyVXRpbC5taXhpbihNYXJrZXJNb2RlbCwgZGF0YUZvcm1hdE1peGluKTtcbnZhciBfZGVmYXVsdCA9IE1hcmtlck1vZGVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtlck1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtlck1vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBfZGVmYXVsdCA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG4gIHR5cGU6ICdtYXJrZXInLFxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogTWFya2xpbmUgZ3JvdXBlZCBieSBzZXJpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL3V0aWwuSGFzaE1hcH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcmtlckdyb3VwTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAobWFya2VyTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBtYXJrZXJHcm91cE1hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgbWFya2VyR3JvdXBNYXAuZWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaXRlbS5fX2tlZXAgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB2YXIgbWFya2VyTW9kZWxLZXkgPSB0aGlzLnR5cGUgKyAnTW9kZWwnO1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBtYXJrZXJNb2RlbCA9IHNlcmllc01vZGVsW21hcmtlck1vZGVsS2V5XTtcbiAgICAgIG1hcmtlck1vZGVsICYmIHRoaXMucmVuZGVyU2VyaWVzKHNlcmllc01vZGVsLCBtYXJrZXJNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICB9LCB0aGlzKTtcbiAgICBtYXJrZXJHcm91cE1hcC5lYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAhaXRlbS5fX2tlZXAgJiYgdGhpcy5ncm91cC5yZW1vdmUoaXRlbS5ncm91cCk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIHJlbmRlclNlcmllczogZnVuY3Rpb24gKCkge31cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya2VyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJWaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgX2RhdGFTdGFja0hlbHBlciA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXJcIik7XG5cbnZhciBpc0RpbWVuc2lvblN0YWNrZWQgPSBfZGF0YVN0YWNrSGVscGVyLmlzRGltZW5zaW9uU3RhY2tlZDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcblxuZnVuY3Rpb24gaGFzWE9yWShpdGVtKSB7XG4gIHJldHVybiAhKGlzTmFOKHBhcnNlRmxvYXQoaXRlbS54KSkgJiYgaXNOYU4ocGFyc2VGbG9hdChpdGVtLnkpKSk7XG59XG5cbmZ1bmN0aW9uIGhhc1hBbmRZKGl0ZW0pIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KGl0ZW0ueCkpICYmICFpc05hTihwYXJzZUZsb2F0KGl0ZW0ueSkpO1xufSAvLyBNYWtlIGl0IHNpbXBsZSwgZG8gbm90IHZpc2l0IGFsbCBzdGFja2VkIHZhbHVlIHRvIGNvdW50IHByZWNpc2lvbi5cbi8vIGZ1bmN0aW9uIGdldFByZWNpc2lvbihkYXRhLCB2YWx1ZUF4aXNEaW0sIGRhdGFJbmRleCkge1xuLy8gICAgIHZhciBwcmVjaXNpb24gPSAtMTtcbi8vICAgICB2YXIgc3RhY2tlZERpbSA9IGRhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpc0RpbSk7XG4vLyAgICAgZG8ge1xuLy8gICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1heChcbi8vICAgICAgICAgICAgIG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uKGRhdGEuZ2V0KHN0YWNrZWREaW0sIGRhdGFJbmRleCkpLFxuLy8gICAgICAgICAgICAgcHJlY2lzaW9uXG4vLyAgICAgICAgICk7XG4vLyAgICAgICAgIHZhciBzdGFja2VkT25TZXJpZXMgPSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZE9uU2VyaWVzJyk7XG4vLyAgICAgICAgIGlmIChzdGFja2VkT25TZXJpZXMpIHtcbi8vICAgICAgICAgICAgIHZhciBieVZhbHVlID0gZGF0YS5nZXQoZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrZWRCeURpbWVuc2lvbicpLCBkYXRhSW5kZXgpO1xuLy8gICAgICAgICAgICAgZGF0YSA9IHN0YWNrZWRPblNlcmllcy5nZXREYXRhKCk7XG4vLyAgICAgICAgICAgICBkYXRhSW5kZXggPSBkYXRhLmluZGV4T2YoZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrZWRCeURpbWVuc2lvbicpLCBieVZhbHVlKTtcbi8vICAgICAgICAgICAgIHN0YWNrZWREaW0gPSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZERpbWVuc2lvbicpO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4vLyAgICAgICAgIH1cbi8vICAgICB9IHdoaWxlIChkYXRhKTtcbi8vICAgICByZXR1cm4gcHJlY2lzaW9uO1xuLy8gfVxuXG5cbmZ1bmN0aW9uIG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudChtbFR5cGUsIGRhdGEsIG90aGVyRGF0YURpbSwgdGFyZ2V0RGF0YURpbSwgb3RoZXJDb29yZEluZGV4LCB0YXJnZXRDb29yZEluZGV4KSB7XG4gIHZhciBjb29yZEFyciA9IFtdO1xuICB2YXIgc3RhY2tlZCA9IGlzRGltZW5zaW9uU3RhY2tlZChkYXRhLCB0YXJnZXREYXRhRGltXG4gIC8qLCBvdGhlckRhdGFEaW0qL1xuICApO1xuICB2YXIgY2FsY0RhdGFEaW0gPSBzdGFja2VkID8gZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrUmVzdWx0RGltZW5zaW9uJykgOiB0YXJnZXREYXRhRGltO1xuICB2YXIgdmFsdWUgPSBudW1DYWxjdWxhdGUoZGF0YSwgY2FsY0RhdGFEaW0sIG1sVHlwZSk7XG4gIHZhciBkYXRhSW5kZXggPSBkYXRhLmluZGljZXNPZk5lYXJlc3QoY2FsY0RhdGFEaW0sIHZhbHVlKVswXTtcbiAgY29vcmRBcnJbb3RoZXJDb29yZEluZGV4XSA9IGRhdGEuZ2V0KG90aGVyRGF0YURpbSwgZGF0YUluZGV4KTtcbiAgY29vcmRBcnJbdGFyZ2V0Q29vcmRJbmRleF0gPSBkYXRhLmdldCh0YXJnZXREYXRhRGltLCBkYXRhSW5kZXgpOyAvLyBNYWtlIGl0IHNpbXBsZSwgZG8gbm90IHZpc2l0IGFsbCBzdGFja2VkIHZhbHVlIHRvIGNvdW50IHByZWNpc2lvbi5cblxuICB2YXIgcHJlY2lzaW9uID0gbnVtYmVyVXRpbC5nZXRQcmVjaXNpb24oZGF0YS5nZXQodGFyZ2V0RGF0YURpbSwgZGF0YUluZGV4KSk7XG4gIHByZWNpc2lvbiA9IE1hdGgubWluKHByZWNpc2lvbiwgMjApO1xuXG4gIGlmIChwcmVjaXNpb24gPj0gMCkge1xuICAgIGNvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdID0gK2Nvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgfVxuXG4gIHJldHVybiBjb29yZEFycjtcbn1cblxudmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5OyAvLyBUT0RPIFNwZWNpZmllZCBwZXJjZW50XG5cbnZhciBtYXJrZXJUeXBlQ2FsY3VsYXRvciA9IHtcbiAgLyoqXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VBeGlzRGltXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUF4aXNEaW1cbiAgICovXG4gIG1pbjogY3VycnkobWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50LCAnbWluJyksXG5cbiAgLyoqXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VBeGlzRGltXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUF4aXNEaW1cbiAgICovXG4gIG1heDogY3VycnkobWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50LCAnbWF4JyksXG5cbiAgLyoqXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VBeGlzRGltXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUF4aXNEaW1cbiAgICovXG4gIGF2ZXJhZ2U6IGN1cnJ5KG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudCwgJ2F2ZXJhZ2UnKVxufTtcbi8qKlxuICogVHJhbnNmb3JtIG1hcmtQb2ludCBkYXRhIGl0ZW0gdG8gZm9ybWF0IHVzZWQgaW4gTGlzdCBieSBkbyB0aGUgZm9sbG93aW5nXG4gKiAxLiBDYWxjdWxhdGUgc3RhdGlzdGljIGxpa2UgYG1heGAsIGBtaW5gLCBgYXZlcmFnZWBcbiAqIDIuIENvbnZlcnQgYGl0ZW0ueEF4aXNgLCBgaXRlbS55QXhpc2AgdG8gYGl0ZW0uY29vcmRgIGFycmF5XG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC8qfSBbY29vcmRTeXNdXG4gKiBAcGFyYW0gIHtPYmplY3R9IGl0ZW1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBkYXRhVHJhbnNmb3JtKHNlcmllc01vZGVsLCBpdGVtKSB7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtOyAvLyAxLiBJZiBub3Qgc3BlY2lmeSB0aGUgcG9zaXRpb24gd2l0aCBwaXhlbCBkaXJlY3RseVxuICAvLyAyLiBJZiBgY29vcmRgIGlzIG5vdCBhIGRhdGEgYXJyYXkuIFdoaWNoIHVzZXMgYHhBeGlzYCxcbiAgLy8gYHlBeGlzYCB0byBzcGVjaWZ5IHRoZSBjb29yZCBvbiBlYWNoIGRpbWVuc2lvblxuICAvLyBwYXJzZUZsb2F0IGZpcnN0IGJlY2F1c2UgaXRlbS54IGFuZCBpdGVtLnkgY2FuIGJlIHBlcmNlbnQgc3RyaW5nIGxpa2UgJzIwJSdcblxuICBpZiAoaXRlbSAmJiAhaGFzWEFuZFkoaXRlbSkgJiYgIXpyVXRpbC5pc0FycmF5KGl0ZW0uY29vcmQpICYmIGNvb3JkU3lzKSB7XG4gICAgdmFyIGRpbXMgPSBjb29yZFN5cy5kaW1lbnNpb25zO1xuICAgIHZhciBheGlzSW5mbyA9IGdldEF4aXNJbmZvKGl0ZW0sIGRhdGEsIGNvb3JkU3lzLCBzZXJpZXNNb2RlbCk7IC8vIENsb25lIHRoZSBvcHRpb25cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgeEF4aXMsIHlBeGlzLCByYWRpdXNBeGlzLCBhbmdsZUF4aXMsIGdlb0Nvb3JkIHRvIHZhbHVlXG5cbiAgICBpdGVtID0genJVdGlsLmNsb25lKGl0ZW0pO1xuXG4gICAgaWYgKGl0ZW0udHlwZSAmJiBtYXJrZXJUeXBlQ2FsY3VsYXRvcltpdGVtLnR5cGVdICYmIGF4aXNJbmZvLmJhc2VBeGlzICYmIGF4aXNJbmZvLnZhbHVlQXhpcykge1xuICAgICAgdmFyIG90aGVyQ29vcmRJbmRleCA9IGluZGV4T2YoZGltcywgYXhpc0luZm8uYmFzZUF4aXMuZGltKTtcbiAgICAgIHZhciB0YXJnZXRDb29yZEluZGV4ID0gaW5kZXhPZihkaW1zLCBheGlzSW5mby52YWx1ZUF4aXMuZGltKTtcbiAgICAgIGl0ZW0uY29vcmQgPSBtYXJrZXJUeXBlQ2FsY3VsYXRvcltpdGVtLnR5cGVdKGRhdGEsIGF4aXNJbmZvLmJhc2VEYXRhRGltLCBheGlzSW5mby52YWx1ZURhdGFEaW0sIG90aGVyQ29vcmRJbmRleCwgdGFyZ2V0Q29vcmRJbmRleCk7IC8vIEZvcmNlIHRvIHVzZSB0aGUgdmFsdWUgb2YgY2FsY3VsYXRlZCB2YWx1ZS5cblxuICAgICAgaXRlbS52YWx1ZSA9IGl0ZW0uY29vcmRbdGFyZ2V0Q29vcmRJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZJWE1FIE9ubHkgaGFzIG9uZSBvZiB4QXhpcyBhbmQgeUF4aXMuXG4gICAgICB2YXIgY29vcmQgPSBbaXRlbS54QXhpcyAhPSBudWxsID8gaXRlbS54QXhpcyA6IGl0ZW0ucmFkaXVzQXhpcywgaXRlbS55QXhpcyAhPSBudWxsID8gaXRlbS55QXhpcyA6IGl0ZW0uYW5nbGVBeGlzXTsgLy8gRWFjaCBjb29yZCBzdXBwb3J0IG1heCwgbWluLCBhdmVyYWdlXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIGlmIChtYXJrZXJUeXBlQ2FsY3VsYXRvcltjb29yZFtpXV0pIHtcbiAgICAgICAgICBjb29yZFtpXSA9IG51bUNhbGN1bGF0ZShkYXRhLCBkYXRhLm1hcERpbWVuc2lvbihkaW1zW2ldKSwgY29vcmRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGl0ZW0uY29vcmQgPSBjb29yZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0luZm8oaXRlbSwgZGF0YSwgY29vcmRTeXMsIHNlcmllc01vZGVsKSB7XG4gIHZhciByZXQgPSB7fTtcblxuICBpZiAoaXRlbS52YWx1ZUluZGV4ICE9IG51bGwgfHwgaXRlbS52YWx1ZURpbSAhPSBudWxsKSB7XG4gICAgcmV0LnZhbHVlRGF0YURpbSA9IGl0ZW0udmFsdWVJbmRleCAhPSBudWxsID8gZGF0YS5nZXREaW1lbnNpb24oaXRlbS52YWx1ZUluZGV4KSA6IGl0ZW0udmFsdWVEaW07XG4gICAgcmV0LnZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoZGF0YURpbVRvQ29vcmREaW0oc2VyaWVzTW9kZWwsIHJldC52YWx1ZURhdGFEaW0pKTtcbiAgICByZXQuYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMocmV0LnZhbHVlQXhpcyk7XG4gICAgcmV0LmJhc2VEYXRhRGltID0gZGF0YS5tYXBEaW1lbnNpb24ocmV0LmJhc2VBeGlzLmRpbSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0LmJhc2VBeGlzID0gc2VyaWVzTW9kZWwuZ2V0QmFzZUF4aXMoKTtcbiAgICByZXQudmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKHJldC5iYXNlQXhpcyk7XG4gICAgcmV0LmJhc2VEYXRhRGltID0gZGF0YS5tYXBEaW1lbnNpb24ocmV0LmJhc2VBeGlzLmRpbSk7XG4gICAgcmV0LnZhbHVlRGF0YURpbSA9IGRhdGEubWFwRGltZW5zaW9uKHJldC52YWx1ZUF4aXMuZGltKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRhdGFEaW1Ub0Nvb3JkRGltKHNlcmllc01vZGVsLCBkYXRhRGltKSB7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB2YXIgZGltZW5zaW9ucyA9IGRhdGEuZGltZW5zaW9ucztcbiAgZGF0YURpbSA9IGRhdGEuZ2V0RGltZW5zaW9uKGRhdGFEaW0pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaW1JdGVtID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbWVuc2lvbnNbaV0pO1xuXG4gICAgaWYgKGRpbUl0ZW0ubmFtZSA9PT0gZGF0YURpbSkge1xuICAgICAgcmV0dXJuIGRpbUl0ZW0uY29vcmREaW07XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZpbHRlciBkYXRhIHdoaWNoIGlzIG91dCBvZiBjb29yZGluYXRlU3lzdGVtIHJhbmdlXG4gKiBbZGF0YUZpbHRlciBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IFtjb29yZFN5c11cbiAqIEBwYXJhbSAge09iamVjdH0gaXRlbVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRhdGFGaWx0ZXIoY29vcmRTeXMsIGl0ZW0pIHtcbiAgLy8gQWx3YWx5cyByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBubyBjb29yZFN5c1xuICByZXR1cm4gY29vcmRTeXMgJiYgY29vcmRTeXMuY29udGFpbkRhdGEgJiYgaXRlbS5jb29yZCAmJiAhaGFzWE9yWShpdGVtKSA/IGNvb3JkU3lzLmNvbnRhaW5EYXRhKGl0ZW0uY29vcmQpIDogdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGltVmFsdWVHZXR0ZXIoaXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAvLyB4LCB5LCByYWRpdXMsIGFuZ2xlXG4gIGlmIChkaW1JbmRleCA8IDIpIHtcbiAgICByZXR1cm4gaXRlbS5jb29yZCAmJiBpdGVtLmNvb3JkW2RpbUluZGV4XTtcbiAgfVxuXG4gIHJldHVybiBpdGVtLnZhbHVlO1xufVxuXG5mdW5jdGlvbiBudW1DYWxjdWxhdGUoZGF0YSwgdmFsdWVEYXRhRGltLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnYXZlcmFnZScpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIGRhdGEuZWFjaCh2YWx1ZURhdGFEaW0sIGZ1bmN0aW9uICh2YWwsIGlkeCkge1xuICAgICAgaWYgKCFpc05hTih2YWwpKSB7XG4gICAgICAgIHN1bSArPSB2YWw7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1bSAvIGNvdW50O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtZWRpYW4nKSB7XG4gICAgcmV0dXJuIGRhdGEuZ2V0TWVkaWFuKHZhbHVlRGF0YURpbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWF4ICYgbWluXG4gICAgcmV0dXJuIGRhdGEuZ2V0RGF0YUV4dGVudCh2YWx1ZURhdGFEaW0sIHRydWUpW3R5cGUgPT09ICdtYXgnID8gMSA6IDBdO1xuICB9XG59XG5cbmV4cG9ydHMuZGF0YVRyYW5zZm9ybSA9IGRhdGFUcmFuc2Zvcm07XG5leHBvcnRzLmdldEF4aXNJbmZvID0gZ2V0QXhpc0luZm87XG5leHBvcnRzLmRhdGFGaWx0ZXIgPSBkYXRhRmlsdGVyO1xuZXhwb3J0cy5kaW1WYWx1ZUdldHRlciA9IGRpbVZhbHVlR2V0dGVyO1xuZXhwb3J0cy5udW1DYWxjdWxhdGUgPSBudW1DYWxjdWxhdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9tYXJrZXJIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvbWFya2VySGVscGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgX2xheW91dCA9IHJlcXVpcmUoXCIuLi91dGlsL2xheW91dFwiKTtcblxudmFyIGdldExheW91dFJlY3QgPSBfbGF5b3V0LmdldExheW91dFJlY3Q7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIE1vZGVsXG5lY2hhcnRzLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcbiAgdHlwZTogJ3RpdGxlJyxcbiAgbGF5b3V0TW9kZToge1xuICAgIHR5cGU6ICdib3gnLFxuICAgIGlnbm9yZVNpemU6IHRydWVcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIC8vIOS4gOe6p+WxguWPoFxuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICB6OiA2LFxuICAgIHNob3c6IHRydWUsXG4gICAgdGV4dDogJycsXG4gICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgLy8gbGluazogbnVsbCxcbiAgICAvLyDku4XmlK/mjIFzZWxmIHwgYmxhbmtcbiAgICB0YXJnZXQ6ICdibGFuaycsXG4gICAgc3VidGV4dDogJycsXG4gICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgLy8gc3VibGluazogbnVsbCxcbiAgICAvLyDku4XmlK/mjIFzZWxmIHwgYmxhbmtcbiAgICBzdWJ0YXJnZXQ6ICdibGFuaycsXG4gICAgLy8gJ2NlbnRlcicgwqYgJ2xlZnQnIMKmICdyaWdodCdcbiAgICAvLyDCpiB7bnVtYmVyfe+8iHjlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgIGxlZnQ6IDAsXG4gICAgLy8gJ3RvcCcgwqYgJ2JvdHRvbScgwqYgJ2NlbnRlcidcbiAgICAvLyDCpiB7bnVtYmVyfe+8iHnlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgIHRvcDogMCxcbiAgICAvLyDmsLTlubPlr7npvZBcbiAgICAvLyAnYXV0bycgfCAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcidcbiAgICAvLyDpu5jorqTmoLnmja4gbGVmdCDnmoTkvY3nva7liKTmlq3mmK/lt6blr7npvZDov5jmmK/lj7Plr7npvZBcbiAgICAvLyB0ZXh0QWxpZ246IG51bGxcbiAgICAvL1xuICAgIC8vIOWeguebtOWvuem9kFxuICAgIC8vICdhdXRvJyB8ICd0b3AnIHwgJ2JvdHRvbScgfCAnbWlkZGxlJ1xuICAgIC8vIOm7mOiupOagueaNriB0b3Ag5L2N572u5Yik5pat5piv5LiK5a+56b2Q6L+Y5piv5LiL5a+56b2QXG4gICAgLy8gdGV4dEJhc2VsaW5lOiBudWxsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgLy8g5qCH6aKY6L655qGG6aKc6ImyXG4gICAgYm9yZGVyQ29sb3I6ICcjY2NjJyxcbiAgICAvLyDmoIfpopjovrnmoYbnur/lrr3vvIzljZXkvY1weO+8jOm7mOiupOS4ujDvvIjml6DovrnmoYbvvIlcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICAvLyDmoIfpopjlhoXovrnot53vvIzljZXkvY1weO+8jOm7mOiupOWQhOaWueWQkeWGhei+uei3neS4ujXvvIxcbiAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcbiAgICBwYWRkaW5nOiA1LFxuICAgIC8vIOS4u+WJr+agh+mimOe6teWQkemXtOmalO+8jOWNleS9jXB477yM6buY6K6k5Li6MTDvvIxcbiAgICBpdGVtR2FwOiAxMCxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGZvbnRTaXplOiAxOCxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkZXInLFxuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgc3VidGV4dFN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNhYWEnXG4gICAgfVxuICB9XG59KTsgLy8gVmlld1xuXG5lY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuICB0eXBlOiAndGl0bGUnLFxuICByZW5kZXI6IGZ1bmN0aW9uICh0aXRsZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKCF0aXRsZU1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICB2YXIgc3VidGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCdzdWJ0ZXh0U3R5bGUnKTtcbiAgICB2YXIgdGV4dEFsaWduID0gdGl0bGVNb2RlbC5nZXQoJ3RleHRBbGlnbicpO1xuICAgIHZhciB0ZXh0QmFzZWxpbmUgPSB0aXRsZU1vZGVsLmdldCgndGV4dEJhc2VsaW5lJyk7XG4gICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgc3R5bGU6IGdyYXBoaWMuc2V0VGV4dFN0eWxlKHt9LCB0ZXh0U3R5bGVNb2RlbCwge1xuICAgICAgICB0ZXh0OiB0aXRsZU1vZGVsLmdldCgndGV4dCcpLFxuICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKClcbiAgICAgIH0sIHtcbiAgICAgICAgZGlzYWJsZUJveDogdHJ1ZVxuICAgICAgfSksXG4gICAgICB6MjogMTBcbiAgICB9KTtcbiAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0RWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIHN1YlRleHQgPSB0aXRsZU1vZGVsLmdldCgnc3VidGV4dCcpO1xuICAgIHZhciBzdWJUZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHN0eWxlOiBncmFwaGljLnNldFRleHRTdHlsZSh7fSwgc3VidGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgdGV4dDogc3ViVGV4dCxcbiAgICAgICAgdGV4dEZpbGw6IHN1YnRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgICB5OiB0ZXh0UmVjdC5oZWlnaHQgKyB0aXRsZU1vZGVsLmdldCgnaXRlbUdhcCcpLFxuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogJ3RvcCdcbiAgICAgIH0sIHtcbiAgICAgICAgZGlzYWJsZUJveDogdHJ1ZVxuICAgICAgfSksXG4gICAgICB6MjogMTBcbiAgICB9KTtcbiAgICB2YXIgbGluayA9IHRpdGxlTW9kZWwuZ2V0KCdsaW5rJyk7XG4gICAgdmFyIHN1YmxpbmsgPSB0aXRsZU1vZGVsLmdldCgnc3VibGluaycpO1xuICAgIHRleHRFbC5zaWxlbnQgPSAhbGluaztcbiAgICBzdWJUZXh0RWwuc2lsZW50ID0gIXN1Ymxpbms7XG5cbiAgICBpZiAobGluaykge1xuICAgICAgdGV4dEVsLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Lm9wZW4obGluaywgJ18nICsgdGl0bGVNb2RlbC5nZXQoJ3RhcmdldCcpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzdWJsaW5rKSB7XG4gICAgICBzdWJUZXh0RWwub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cub3BlbihzdWJsaW5rLCAnXycgKyB0aXRsZU1vZGVsLmdldCgnc3VidGFyZ2V0JykpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgc3ViVGV4dCAmJiBncm91cC5hZGQoc3ViVGV4dEVsKTsgLy8gSWYgbm8gc3ViVGV4dCwgYnV0IGFkZCBzdWJUZXh0RWwsIHRoZXJlIHdpbGwgYmUgYW4gZW1wdHkgbGluZS5cblxuICAgIHZhciBncm91cFJlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgbGF5b3V0T3B0aW9uID0gdGl0bGVNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKTtcbiAgICBsYXlvdXRPcHRpb24ud2lkdGggPSBncm91cFJlY3Qud2lkdGg7XG4gICAgbGF5b3V0T3B0aW9uLmhlaWdodCA9IGdyb3VwUmVjdC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFJlY3QgPSBnZXRMYXlvdXRSZWN0KGxheW91dE9wdGlvbiwge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9LCB0aXRsZU1vZGVsLmdldCgncGFkZGluZycpKTsgLy8gQWRqdXN0IHRleHQgYWxpZ24gYmFzZWQgb24gcG9zaXRpb25cblxuICAgIGlmICghdGV4dEFsaWduKSB7XG4gICAgICAvLyBBbGlnbiBsZWZ0IGlmIHRpdGxlIGlzIG9uIHRoZSBsZWZ0LiBjZW50ZXIgYW5kIHJpZ2h0IGlzIHNhbWVcbiAgICAgIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCdsZWZ0JykgfHwgdGl0bGVNb2RlbC5nZXQoJ3JpZ2h0Jyk7XG5cbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfSAvLyBBZGp1c3QgbGF5b3V0IGJ5IHRleHQgYWxpZ25cblxuXG4gICAgICBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIGxheW91dFJlY3QueCArPSBsYXlvdXRSZWN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGxheW91dFJlY3QueCArPSBsYXlvdXRSZWN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRleHRCYXNlbGluZSkge1xuICAgICAgdGV4dEJhc2VsaW5lID0gdGl0bGVNb2RlbC5nZXQoJ3RvcCcpIHx8IHRpdGxlTW9kZWwuZ2V0KCdib3R0b20nKTtcblxuICAgICAgaWYgKHRleHRCYXNlbGluZSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGxheW91dFJlY3QueSArPSBsYXlvdXRSZWN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAodGV4dEJhc2VsaW5lID09PSAnbWlkZGxlJykge1xuICAgICAgICBsYXlvdXRSZWN0LnkgKz0gbGF5b3V0UmVjdC5oZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICB0ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmUgfHwgJ3RvcCc7XG4gICAgfVxuXG4gICAgZ3JvdXAuYXR0cigncG9zaXRpb24nLCBbbGF5b3V0UmVjdC54LCBsYXlvdXRSZWN0LnldKTtcbiAgICB2YXIgYWxpZ25TdHlsZSA9IHtcbiAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRCYXNlbGluZVxuICAgIH07XG4gICAgdGV4dEVsLnNldFN0eWxlKGFsaWduU3R5bGUpO1xuICAgIHN1YlRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTsgLy8gUmVuZGVyIGJhY2tncm91bmRcbiAgICAvLyBHZXQgZ3JvdXBSZWN0IGFnYWluIGJlY2F1c2UgdGV4dEFsaWduIGhhcyBiZWVuIGNoYW5nZWRcblxuICAgIGdyb3VwUmVjdCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBwYWRkaW5nID0gbGF5b3V0UmVjdC5tYXJnaW47XG4gICAgdmFyIHN0eWxlID0gdGl0bGVNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvcicsICdvcGFjaXR5J10pO1xuICAgIHN0eWxlLmZpbGwgPSB0aXRsZU1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IGdyb3VwUmVjdC54IC0gcGFkZGluZ1szXSxcbiAgICAgICAgeTogZ3JvdXBSZWN0LnkgLSBwYWRkaW5nWzBdLFxuICAgICAgICB3aWR0aDogZ3JvdXBSZWN0LndpZHRoICsgcGFkZGluZ1sxXSArIHBhZGRpbmdbM10sXG4gICAgICAgIGhlaWdodDogZ3JvdXBSZWN0LmhlaWdodCArIHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdLFxuICAgICAgICByOiB0aXRsZU1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJylcbiAgICAgIH0sXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KTtcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVSZWN0KHJlY3QpO1xuICAgIGdyb3VwLmFkZChyZWN0KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpdGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdGl0bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKFwiLi90b29sYm94L1Rvb2xib3hNb2RlbFwiKTtcblxucmVxdWlyZShcIi4vdG9vbGJveC9Ub29sYm94Vmlld1wiKTtcblxucmVxdWlyZShcIi4vdG9vbGJveC9mZWF0dXJlL1NhdmVBc0ltYWdlXCIpO1xuXG5yZXF1aXJlKFwiLi90b29sYm94L2ZlYXR1cmUvTWFnaWNUeXBlXCIpO1xuXG5yZXF1aXJlKFwiLi90b29sYm94L2ZlYXR1cmUvRGF0YVZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL3Rvb2xib3gvZmVhdHVyZS9EYXRhWm9vbVwiKTtcblxucmVxdWlyZShcIi4vdG9vbGJveC9mZWF0dXJlL1Jlc3RvcmVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3guanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBmZWF0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCIuL2ZlYXR1cmVNYW5hZ2VyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgVG9vbGJveE1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICd0b29sYm94JyxcbiAgbGF5b3V0TW9kZToge1xuICAgIHR5cGU6ICdib3gnLFxuICAgIGlnbm9yZVNpemU6IHRydWVcbiAgfSxcbiAgb3B0aW9uVXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgIFRvb2xib3hNb2RlbC5zdXBlckFwcGx5KHRoaXMsICdvcHRpb25VcGRhdGVkJywgYXJndW1lbnRzKTtcbiAgICB6clV0aWwuZWFjaCh0aGlzLm9wdGlvbi5mZWF0dXJlLCBmdW5jdGlvbiAoZmVhdHVyZU9wdCwgZmVhdHVyZU5hbWUpIHtcbiAgICAgIHZhciBGZWF0dXJlID0gZmVhdHVyZU1hbmFnZXIuZ2V0KGZlYXR1cmVOYW1lKTtcbiAgICAgIEZlYXR1cmUgJiYgenJVdGlsLm1lcmdlKGZlYXR1cmVPcHQsIEZlYXR1cmUuZGVmYXVsdE9wdGlvbik7XG4gICAgfSk7XG4gIH0sXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICBzaG93OiB0cnVlLFxuICAgIHo6IDYsXG4gICAgemxldmVsOiAwLFxuICAgIG9yaWVudDogJ2hvcml6b250YWwnLFxuICAgIGxlZnQ6ICdyaWdodCcsXG4gICAgdG9wOiAndG9wJyxcbiAgICAvLyByaWdodFxuICAgIC8vIGJvdHRvbVxuICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxuICAgIGJvcmRlclJhZGl1czogMCxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBwYWRkaW5nOiA1LFxuICAgIGl0ZW1TaXplOiAxNSxcbiAgICBpdGVtR2FwOiA4LFxuICAgIHNob3dUaXRsZTogdHJ1ZSxcbiAgICBpY29uU3R5bGU6IHtcbiAgICAgIGJvcmRlckNvbG9yOiAnIzY2NicsXG4gICAgICBjb2xvcjogJ25vbmUnXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgaWNvblN0eWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzNFOThDNSdcbiAgICAgIH0gLy8gdGV4dFN0eWxlOiB7fSxcbiAgICAgIC8vIGZlYXR1cmVcblxuICAgIH1cbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBUb29sYm94TW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveE1vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluL3RleHRcIik7XG5cbnZhciBmZWF0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCIuL2ZlYXR1cmVNYW5hZ2VyXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIERhdGFEaWZmZXIgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9EYXRhRGlmZmVyXCIpO1xuXG52YXIgbGlzdENvbXBvbmVudEhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvbGlzdENvbXBvbmVudFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9kZWZhdWx0ID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ3Rvb2xib3gnLFxuICByZW5kZXI6IGZ1bmN0aW9uICh0b29sYm94TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICBpZiAoIXRvb2xib3hNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpdGVtU2l6ZSA9ICt0b29sYm94TW9kZWwuZ2V0KCdpdGVtU2l6ZScpO1xuICAgIHZhciBmZWF0dXJlT3B0cyA9IHRvb2xib3hNb2RlbC5nZXQoJ2ZlYXR1cmUnKSB8fCB7fTtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9mZWF0dXJlcyB8fCAodGhpcy5fZmVhdHVyZXMgPSB7fSk7XG4gICAgdmFyIGZlYXR1cmVOYW1lcyA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKGZlYXR1cmVPcHRzLCBmdW5jdGlvbiAob3B0LCBuYW1lKSB7XG4gICAgICBmZWF0dXJlTmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICBuZXcgRGF0YURpZmZlcih0aGlzLl9mZWF0dXJlTmFtZXMgfHwgW10sIGZlYXR1cmVOYW1lcykuYWRkKHByb2Nlc3NGZWF0dXJlKS51cGRhdGUocHJvY2Vzc0ZlYXR1cmUpLnJlbW92ZSh6clV0aWwuY3VycnkocHJvY2Vzc0ZlYXR1cmUsIG51bGwpKS5leGVjdXRlKCk7IC8vIEtlZXAgZm9yIGRpZmYuXG5cbiAgICB0aGlzLl9mZWF0dXJlTmFtZXMgPSBmZWF0dXJlTmFtZXM7XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzRmVhdHVyZShuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgIHZhciBmZWF0dXJlTmFtZSA9IGZlYXR1cmVOYW1lc1tuZXdJbmRleF07XG4gICAgICB2YXIgb2xkTmFtZSA9IGZlYXR1cmVOYW1lc1tvbGRJbmRleF07XG4gICAgICB2YXIgZmVhdHVyZU9wdCA9IGZlYXR1cmVPcHRzW2ZlYXR1cmVOYW1lXTtcbiAgICAgIHZhciBmZWF0dXJlTW9kZWwgPSBuZXcgTW9kZWwoZmVhdHVyZU9wdCwgdG9vbGJveE1vZGVsLCB0b29sYm94TW9kZWwuZWNNb2RlbCk7XG4gICAgICB2YXIgZmVhdHVyZTtcblxuICAgICAgaWYgKGZlYXR1cmVOYW1lICYmICFvbGROYW1lKSB7XG4gICAgICAgIC8vIENyZWF0ZVxuICAgICAgICBpZiAoaXNVc2VyRmVhdHVyZU5hbWUoZmVhdHVyZU5hbWUpKSB7XG4gICAgICAgICAgZmVhdHVyZSA9IHtcbiAgICAgICAgICAgIG1vZGVsOiBmZWF0dXJlTW9kZWwsXG4gICAgICAgICAgICBvbmNsaWNrOiBmZWF0dXJlTW9kZWwub3B0aW9uLm9uY2xpY2ssXG4gICAgICAgICAgICBmZWF0dXJlTmFtZTogZmVhdHVyZU5hbWVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBGZWF0dXJlID0gZmVhdHVyZU1hbmFnZXIuZ2V0KGZlYXR1cmVOYW1lKTtcblxuICAgICAgICAgIGlmICghRmVhdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZlYXR1cmUgPSBuZXcgRmVhdHVyZShmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIH1cblxuICAgICAgICBmZWF0dXJlc1tmZWF0dXJlTmFtZV0gPSBmZWF0dXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmVhdHVyZSA9IGZlYXR1cmVzW29sZE5hbWVdOyAvLyBJZiBmZWF0dXJlIGRvZXMgbm90IGV4c2l0LlxuXG4gICAgICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZlYXR1cmUubW9kZWwgPSBmZWF0dXJlTW9kZWw7XG4gICAgICAgIGZlYXR1cmUuZWNNb2RlbCA9IGVjTW9kZWw7XG4gICAgICAgIGZlYXR1cmUuYXBpID0gYXBpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZlYXR1cmVOYW1lICYmIG9sZE5hbWUpIHtcbiAgICAgICAgZmVhdHVyZS5kaXNwb3NlICYmIGZlYXR1cmUuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZmVhdHVyZU1vZGVsLmdldCgnc2hvdycpIHx8IGZlYXR1cmUudW51c2FibGUpIHtcbiAgICAgICAgZmVhdHVyZS5yZW1vdmUgJiYgZmVhdHVyZS5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVJY29uUGF0aHMoZmVhdHVyZU1vZGVsLCBmZWF0dXJlLCBmZWF0dXJlTmFtZSk7XG5cbiAgICAgIGZlYXR1cmVNb2RlbC5zZXRJY29uU3RhdHVzID0gZnVuY3Rpb24gKGljb25OYW1lLCBzdGF0dXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgICAgICB2YXIgaWNvblBhdGhzID0gdGhpcy5pY29uUGF0aHM7XG4gICAgICAgIG9wdGlvbi5pY29uU3RhdHVzID0gb3B0aW9uLmljb25TdGF0dXMgfHwge307XG4gICAgICAgIG9wdGlvbi5pY29uU3RhdHVzW2ljb25OYW1lXSA9IHN0YXR1czsgLy8gRklYTUVcblxuICAgICAgICBpY29uUGF0aHNbaWNvbk5hbWVdICYmIGljb25QYXRoc1tpY29uTmFtZV0udHJpZ2dlcihzdGF0dXMpO1xuICAgICAgfTtcblxuICAgICAgaWYgKGZlYXR1cmUucmVuZGVyKSB7XG4gICAgICAgIGZlYXR1cmUucmVuZGVyKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJY29uUGF0aHMoZmVhdHVyZU1vZGVsLCBmZWF0dXJlLCBmZWF0dXJlTmFtZSkge1xuICAgICAgdmFyIGljb25TdHlsZU1vZGVsID0gZmVhdHVyZU1vZGVsLmdldE1vZGVsKCdpY29uU3R5bGUnKTtcbiAgICAgIHZhciBpY29uU3R5bGVFbXBoYXNpc01vZGVsID0gZmVhdHVyZU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcy5pY29uU3R5bGUnKTsgLy8gSWYgb25lIGZlYXR1cmUgaGFzIG11dGlwbGUgaWNvbi4gdGhleSBhcmUgb3JnaW5haXplZCBhc1xuICAgICAgLy8ge1xuICAgICAgLy8gICAgIGljb246IHtcbiAgICAgIC8vICAgICAgICAgZm9vOiAnJyxcbiAgICAgIC8vICAgICAgICAgYmFyOiAnJ1xuICAgICAgLy8gICAgIH0sXG4gICAgICAvLyAgICAgdGl0bGU6IHtcbiAgICAgIC8vICAgICAgICAgZm9vOiAnJyxcbiAgICAgIC8vICAgICAgICAgYmFyOiAnJ1xuICAgICAgLy8gICAgIH1cbiAgICAgIC8vIH1cblxuICAgICAgdmFyIGljb25zID0gZmVhdHVyZS5nZXRJY29ucyA/IGZlYXR1cmUuZ2V0SWNvbnMoKSA6IGZlYXR1cmVNb2RlbC5nZXQoJ2ljb24nKTtcbiAgICAgIHZhciB0aXRsZXMgPSBmZWF0dXJlTW9kZWwuZ2V0KCd0aXRsZScpIHx8IHt9O1xuXG4gICAgICBpZiAodHlwZW9mIGljb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgaWNvbiA9IGljb25zO1xuICAgICAgICB2YXIgdGl0bGUgPSB0aXRsZXM7XG4gICAgICAgIGljb25zID0ge307XG4gICAgICAgIHRpdGxlcyA9IHt9O1xuICAgICAgICBpY29uc1tmZWF0dXJlTmFtZV0gPSBpY29uO1xuICAgICAgICB0aXRsZXNbZmVhdHVyZU5hbWVdID0gdGl0bGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpY29uUGF0aHMgPSBmZWF0dXJlTW9kZWwuaWNvblBhdGhzID0ge307XG4gICAgICB6clV0aWwuZWFjaChpY29ucywgZnVuY3Rpb24gKGljb25TdHIsIGljb25OYW1lKSB7XG4gICAgICAgIHZhciBwYXRoID0gZ3JhcGhpYy5jcmVhdGVJY29uKGljb25TdHIsIHt9LCB7XG4gICAgICAgICAgeDogLWl0ZW1TaXplIC8gMixcbiAgICAgICAgICB5OiAtaXRlbVNpemUgLyAyLFxuICAgICAgICAgIHdpZHRoOiBpdGVtU2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGl0ZW1TaXplXG4gICAgICAgIH0pO1xuICAgICAgICBwYXRoLnNldFN0eWxlKGljb25TdHlsZU1vZGVsLmdldEl0ZW1TdHlsZSgpKTtcbiAgICAgICAgcGF0aC5ob3ZlclN0eWxlID0gaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHBhdGgpO1xuXG4gICAgICAgIGlmICh0b29sYm94TW9kZWwuZ2V0KCdzaG93VGl0bGUnKSkge1xuICAgICAgICAgIHBhdGguX190aXRsZSA9IHRpdGxlc1tpY29uTmFtZV07XG4gICAgICAgICAgcGF0aC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCByZXVzZSBhYm92ZSBob3ZlclN0eWxlLCB3aGljaCBtaWdodCBiZSBtb2RpZmllZC5cbiAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgICAgIHBhdGguc2V0U3R5bGUoe1xuICAgICAgICAgICAgICB0ZXh0OiB0aXRsZXNbaWNvbk5hbWVdLFxuICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246IGhvdmVyU3R5bGUudGV4dFBvc2l0aW9uIHx8ICdib3R0b20nLFxuICAgICAgICAgICAgICB0ZXh0RmlsbDogaG92ZXJTdHlsZS5maWxsIHx8IGhvdmVyU3R5bGUuc3Ryb2tlIHx8ICcjMDAwJyxcbiAgICAgICAgICAgICAgdGV4dEFsaWduOiBob3ZlclN0eWxlLnRleHRBbGlnbiB8fCAnY2VudGVyJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGF0aC5zZXRTdHlsZSh7XG4gICAgICAgICAgICAgIHRleHRGaWxsOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGgudHJpZ2dlcihmZWF0dXJlTW9kZWwuZ2V0KCdpY29uU3RhdHVzLicgKyBpY29uTmFtZSkgfHwgJ25vcm1hbCcpO1xuICAgICAgICBncm91cC5hZGQocGF0aCk7XG4gICAgICAgIHBhdGgub24oJ2NsaWNrJywgenJVdGlsLmJpbmQoZmVhdHVyZS5vbmNsaWNrLCBmZWF0dXJlLCBlY01vZGVsLCBhcGksIGljb25OYW1lKSk7XG4gICAgICAgIGljb25QYXRoc1tpY29uTmFtZV0gPSBwYXRoO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGlzdENvbXBvbmVudEhlbHBlci5sYXlvdXQoZ3JvdXAsIHRvb2xib3hNb2RlbCwgYXBpKTsgLy8gUmVuZGVyIGJhY2tncm91bmQgYWZ0ZXIgZ3JvdXAgaXMgbGF5b3V0XG4gICAgLy8gRklYTUVcblxuICAgIGdyb3VwLmFkZChsaXN0Q29tcG9uZW50SGVscGVyLm1ha2VCYWNrZ3JvdW5kKGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLCB0b29sYm94TW9kZWwpKTsgLy8gQWRqdXN0IGljb24gdGl0bGUgcG9zaXRpb25zIHRvIGF2b2lkIHRoZW0gb3V0IG9mIHNjcmVlblxuXG4gICAgZ3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChpY29uKSB7XG4gICAgICB2YXIgdGl0bGVUZXh0ID0gaWNvbi5fX3RpdGxlO1xuICAgICAgdmFyIGhvdmVyU3R5bGUgPSBpY29uLmhvdmVyU3R5bGU7IC8vIE1heSBiZSBiYWNrZ3JvdW5kIGVsZW1lbnRcblxuICAgICAgaWYgKGhvdmVyU3R5bGUgJiYgdGl0bGVUZXh0KSB7XG4gICAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRpdGxlVGV4dCwgdGV4dENvbnRhaW4ubWFrZUZvbnQoaG92ZXJTdHlsZSkpO1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IGljb24ucG9zaXRpb25bMF0gKyBncm91cC5wb3NpdGlvblswXTtcbiAgICAgICAgdmFyIG9mZnNldFkgPSBpY29uLnBvc2l0aW9uWzFdICsgZ3JvdXAucG9zaXRpb25bMV0gKyBpdGVtU2l6ZTtcbiAgICAgICAgdmFyIG5lZWRQdXRPblRvcCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvZmZzZXRZICsgcmVjdC5oZWlnaHQgPiBhcGkuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICBob3ZlclN0eWxlLnRleHRQb3NpdGlvbiA9ICd0b3AnO1xuICAgICAgICAgIG5lZWRQdXRPblRvcCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9wT2Zmc2V0ID0gbmVlZFB1dE9uVG9wID8gLTUgLSByZWN0LmhlaWdodCA6IGl0ZW1TaXplICsgODtcblxuICAgICAgICBpZiAob2Zmc2V0WCArIHJlY3Qud2lkdGggLyAyID4gYXBpLmdldFdpZHRoKCkpIHtcbiAgICAgICAgICBob3ZlclN0eWxlLnRleHRQb3NpdGlvbiA9IFsnMTAwJScsIHRvcE9mZnNldF07XG4gICAgICAgICAgaG92ZXJTdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldFggLSByZWN0LndpZHRoIC8gMiA8IDApIHtcbiAgICAgICAgICBob3ZlclN0eWxlLnRleHRQb3NpdGlvbiA9IFswLCB0b3BPZmZzZXRdO1xuICAgICAgICAgIGhvdmVyU3R5bGUudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHVwZGF0ZVZpZXc6IGZ1bmN0aW9uICh0b29sYm94TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgZmVhdHVyZS51cGRhdGVWaWV3ICYmIGZlYXR1cmUudXBkYXRlVmlldyhmZWF0dXJlLm1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIH0pO1xuICB9LFxuICAvLyB1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICh0b29sYm94TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAvLyAgICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gIC8vICAgICAgICAgZmVhdHVyZS51cGRhdGVMYXlvdXQgJiYgZmVhdHVyZS51cGRhdGVMYXlvdXQoZmVhdHVyZS5tb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgLy8gICAgIH0pO1xuICAvLyB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB6clV0aWwuZWFjaCh0aGlzLl9mZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgIGZlYXR1cmUucmVtb3ZlICYmIGZlYXR1cmUucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgfSk7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgfSxcbiAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgZmVhdHVyZS5kaXNwb3NlICYmIGZlYXR1cmUuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICAgIH0pO1xuICB9XG59KTtcblxuZnVuY3Rpb24gaXNVc2VyRmVhdHVyZU5hbWUoZmVhdHVyZU5hbWUpIHtcbiAgcmV0dXJuIGZlYXR1cmVOYW1lLmluZGV4T2YoJ215JykgPT09IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hWaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBldmVudFRvb2wgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9ldmVudFwiKTtcblxudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGFuZ1wiKTtcblxudmFyIGZlYXR1cmVNYW5hZ2VyID0gcmVxdWlyZShcIi4uL2ZlYXR1cmVNYW5hZ2VyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgZGF0YVZpZXdMYW5nID0gbGFuZy50b29sYm94LmRhdGFWaWV3O1xudmFyIEJMT0NLX1NQTElURVIgPSBuZXcgQXJyYXkoNjApLmpvaW4oJy0nKTtcbnZhciBJVEVNX1NQTElURVIgPSAnXFx0Jztcbi8qKlxuICogR3JvdXAgc2VyaWVzIGludG8gdHdvIHR5cGVzXG4gKiAgMS4gb24gY2F0ZWdvcnkgYXhpcywgbGlrZSBsaW5lLCBiYXJcbiAqICAyLiBvdGhlcnMsIGxpa2Ugc2NhdHRlciwgcGllXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGlubmVyXG4gKi9cblxuZnVuY3Rpb24gZ3JvdXBTZXJpZXMoZWNNb2RlbCkge1xuICB2YXIgc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpcyA9IHt9O1xuICB2YXIgb3RoZXJTZXJpZXMgPSBbXTtcbiAgdmFyIG1ldGEgPSBbXTtcbiAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICBpZiAoY29vcmRTeXMgJiYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgfHwgY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJykpIHtcbiAgICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG5cbiAgICAgIGlmIChiYXNlQXhpcy50eXBlID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgIHZhciBrZXkgPSBiYXNlQXhpcy5kaW0gKyAnXycgKyBiYXNlQXhpcy5pbmRleDtcblxuICAgICAgICBpZiAoIXNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXNba2V5XSkge1xuICAgICAgICAgIHNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXNba2V5XSA9IHtcbiAgICAgICAgICAgIGNhdGVnb3J5QXhpczogYmFzZUF4aXMsXG4gICAgICAgICAgICB2YWx1ZUF4aXM6IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyksXG4gICAgICAgICAgICBzZXJpZXM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBtZXRhLnB1c2goe1xuICAgICAgICAgICAgYXhpc0RpbTogYmFzZUF4aXMuZGltLFxuICAgICAgICAgICAgYXhpc0luZGV4OiBiYXNlQXhpcy5pbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpc1trZXldLnNlcmllcy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG90aGVyU2VyaWVzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlclNlcmllcy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXM6IHNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXMsXG4gICAgb3RoZXI6IG90aGVyU2VyaWVzLFxuICAgIG1ldGE6IG1ldGFcbiAgfTtcbn1cbi8qKlxuICogQXNzZW1ibGUgY29udGVudCBvZiBzZXJpZXMgb24gY2F0ZW9nb3J5IGF4aXNcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59IHNlcmllc1xuICogQHJldHVybiB7c3RyaW5nfVxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlbWJsZVNlcmllc1dpdGhDYXRlZ29yeUF4aXMoc2VyaWVzKSB7XG4gIHZhciB0YWJsZXMgPSBbXTtcbiAgenJVdGlsLmVhY2goc2VyaWVzLCBmdW5jdGlvbiAoZ3JvdXAsIGtleSkge1xuICAgIHZhciBjYXRlZ29yeUF4aXMgPSBncm91cC5jYXRlZ29yeUF4aXM7XG4gICAgdmFyIHZhbHVlQXhpcyA9IGdyb3VwLnZhbHVlQXhpcztcbiAgICB2YXIgdmFsdWVBeGlzRGltID0gdmFsdWVBeGlzLmRpbTtcbiAgICB2YXIgaGVhZGVycyA9IFsnICddLmNvbmNhdCh6clV0aWwubWFwKGdyb3VwLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgcmV0dXJuIHNlcmllcy5uYW1lO1xuICAgIH0pKTtcbiAgICB2YXIgY29sdW1ucyA9IFtjYXRlZ29yeUF4aXMubW9kZWwuZ2V0Q2F0ZWdvcmllcygpXTtcbiAgICB6clV0aWwuZWFjaChncm91cC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgIGNvbHVtbnMucHVzaChzZXJpZXMuZ2V0UmF3RGF0YSgpLm1hcEFycmF5KHZhbHVlQXhpc0RpbSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSkpO1xuICAgIH0pOyAvLyBBc3NlbWJsZSB0YWJsZSBjb250ZW50XG5cbiAgICB2YXIgbGluZXMgPSBbaGVhZGVycy5qb2luKElURU1fU1BMSVRFUildO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goY29sdW1uc1tqXVtpXSk7XG4gICAgICB9XG5cbiAgICAgIGxpbmVzLnB1c2goaXRlbXMuam9pbihJVEVNX1NQTElURVIpKTtcbiAgICB9XG5cbiAgICB0YWJsZXMucHVzaChsaW5lcy5qb2luKCdcXG4nKSk7XG4gIH0pO1xuICByZXR1cm4gdGFibGVzLmpvaW4oJ1xcblxcbicgKyBCTE9DS19TUExJVEVSICsgJ1xcblxcbicpO1xufVxuLyoqXG4gKiBBc3NlbWJsZSBjb250ZW50IG9mIG90aGVyIHNlcmllc1xuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn0gc2VyaWVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VtYmxlT3RoZXJTZXJpZXMoc2VyaWVzKSB7XG4gIHJldHVybiB6clV0aWwubWFwKHNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgIHZhciBkYXRhID0gc2VyaWVzLmdldFJhd0RhdGEoKTtcbiAgICB2YXIgbGluZXMgPSBbc2VyaWVzLm5hbWVdO1xuICAgIHZhciB2YWxzID0gW107XG4gICAgZGF0YS5lYWNoKGRhdGEuZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgZGF0YUluZGV4ID0gYXJndW1lbnRzW2FyZ0xlbiAtIDFdO1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgdmFsc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cblxuICAgICAgbGluZXMucHVzaCgobmFtZSA/IG5hbWUgKyBJVEVNX1NQTElURVIgOiAnJykgKyB2YWxzLmpvaW4oSVRFTV9TUExJVEVSKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICB9KS5qb2luKCdcXG5cXG4nICsgQkxPQ0tfU1BMSVRFUiArICdcXG5cXG4nKTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbnRlbnRGcm9tTW9kZWwoZWNNb2RlbCkge1xuICB2YXIgcmVzdWx0ID0gZ3JvdXBTZXJpZXMoZWNNb2RlbCk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHpyVXRpbC5maWx0ZXIoW2Fzc2VtYmxlU2VyaWVzV2l0aENhdGVnb3J5QXhpcyhyZXN1bHQuc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpcyksIGFzc2VtYmxlT3RoZXJTZXJpZXMocmVzdWx0Lm90aGVyKV0sIGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcblxcdFxcc10vZywgJycpO1xuICAgIH0pLmpvaW4oJ1xcblxcbicgKyBCTE9DS19TUExJVEVSICsgJ1xcblxcbicpLFxuICAgIG1ldGE6IHJlc3VsdC5tZXRhXG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG59XG4vKipcbiAqIElmIGEgYmxvY2sgaXMgdHN2IGZvcm1hdFxuICovXG5cblxuZnVuY3Rpb24gaXNUU1ZGb3JtYXQoYmxvY2spIHtcbiAgLy8gU2ltcGxlIG1ldGhvZCB0byBmaW5kIG91dCBpZiBhIGJsb2NrIGlzIHRzdiBmb3JtYXRcbiAgdmFyIGZpcnN0TGluZSA9IGJsb2NrLnNsaWNlKDAsIGJsb2NrLmluZGV4T2YoJ1xcbicpKTtcblxuICBpZiAoZmlyc3RMaW5lLmluZGV4T2YoSVRFTV9TUExJVEVSKSA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIGl0ZW1TcGxpdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnWycgKyBJVEVNX1NQTElURVIgKyAnXSsnLCAnZycpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHN2XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUU1ZDb250ZW50cyh0c3YpIHtcbiAgdmFyIHRzdkxpbmVzID0gdHN2LnNwbGl0KC9cXG4rL2cpO1xuICB2YXIgaGVhZGVycyA9IHRyaW0odHN2TGluZXMuc2hpZnQoKSkuc3BsaXQoaXRlbVNwbGl0UmVnZXgpO1xuICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICB2YXIgc2VyaWVzID0genJVdGlsLm1hcChoZWFkZXJzLCBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGhlYWRlcixcbiAgICAgIGRhdGE6IFtdXG4gICAgfTtcbiAgfSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0c3ZMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtcyA9IHRyaW0odHN2TGluZXNbaV0pLnNwbGl0KGl0ZW1TcGxpdFJlZ2V4KTtcbiAgICBjYXRlZ29yaWVzLnB1c2goaXRlbXMuc2hpZnQoKSk7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICBzZXJpZXNbal0gJiYgKHNlcmllc1tqXS5kYXRhW2ldID0gaXRlbXNbal0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgY2F0ZWdvcmllczogY2F0ZWdvcmllc1xuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn1cbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VMaXN0Q29udGVudHMoc3RyKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgvXFxuKy9nKTtcbiAgdmFyIHNlcmllc05hbWUgPSB0cmltKGxpbmVzLnNoaWZ0KCkpO1xuICB2YXIgZGF0YSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbXMgPSB0cmltKGxpbmVzW2ldKS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG4gICAgdmFyIG5hbWUgPSAnJztcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGhhc05hbWUgPSBmYWxzZTtcblxuICAgIGlmIChpc05hTihpdGVtc1swXSkpIHtcbiAgICAgIC8vIEZpcnN0IGl0ZW0gaXMgbmFtZVxuICAgICAgaGFzTmFtZSA9IHRydWU7XG4gICAgICBuYW1lID0gaXRlbXNbMF07XG4gICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDEpO1xuICAgICAgZGF0YVtpXSA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IFtdXG4gICAgICB9O1xuICAgICAgdmFsdWUgPSBkYXRhW2ldLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGRhdGFbaV0gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YWx1ZS5wdXNoKCtpdGVtc1tqXSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaGFzTmFtZSA/IGRhdGFbaV0udmFsdWUgPSB2YWx1ZVswXSA6IGRhdGFbaV0gPSB2YWx1ZVswXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IHNlcmllc05hbWUsXG4gICAgZGF0YTogZGF0YVxuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBibG9ja01ldGFMaXN0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlQ29udGVudHMoc3RyLCBibG9ja01ldGFMaXN0KSB7XG4gIHZhciBibG9ja3MgPSBzdHIuc3BsaXQobmV3IFJlZ0V4cCgnXFxuKicgKyBCTE9DS19TUExJVEVSICsgJ1xcbionLCAnZycpKTtcbiAgdmFyIG5ld09wdGlvbiA9IHtcbiAgICBzZXJpZXM6IFtdXG4gIH07XG4gIHpyVXRpbC5lYWNoKGJsb2NrcywgZnVuY3Rpb24gKGJsb2NrLCBpZHgpIHtcbiAgICBpZiAoaXNUU1ZGb3JtYXQoYmxvY2spKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VUU1ZDb250ZW50cyhibG9jayk7XG4gICAgICB2YXIgYmxvY2tNZXRhID0gYmxvY2tNZXRhTGlzdFtpZHhdO1xuICAgICAgdmFyIGF4aXNLZXkgPSBibG9ja01ldGEuYXhpc0RpbSArICdBeGlzJztcblxuICAgICAgaWYgKGJsb2NrTWV0YSkge1xuICAgICAgICBuZXdPcHRpb25bYXhpc0tleV0gPSBuZXdPcHRpb25bYXhpc0tleV0gfHwgW107XG4gICAgICAgIG5ld09wdGlvbltheGlzS2V5XVtibG9ja01ldGEuYXhpc0luZGV4XSA9IHtcbiAgICAgICAgICBkYXRhOiByZXN1bHQuY2F0ZWdvcmllc1xuICAgICAgICB9O1xuICAgICAgICBuZXdPcHRpb24uc2VyaWVzID0gbmV3T3B0aW9uLnNlcmllcy5jb25jYXQocmVzdWx0LnNlcmllcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQgPSBwYXJzZUxpc3RDb250ZW50cyhibG9jayk7XG4gICAgICBuZXdPcHRpb24uc2VyaWVzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3T3B0aW9uO1xufVxuLyoqXG4gKiBAYWxpYXMge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVZpZXd9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG1vZGVsXG4gKi9cblxuXG5mdW5jdGlvbiBEYXRhVmlldyhtb2RlbCkge1xuICB0aGlzLl9kb20gPSBudWxsO1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG59XG5cbkRhdGFWaWV3LmRlZmF1bHRPcHRpb24gPSB7XG4gIHNob3c6IHRydWUsXG4gIHJlYWRPbmx5OiBmYWxzZSxcbiAgb3B0aW9uVG9Db250ZW50OiBudWxsLFxuICBjb250ZW50VG9PcHRpb246IG51bGwsXG4gIGljb246ICdNMTcuNSwxNy4zSDMzIE0xNy41LDE3LjNIMzMgTTQ1LjQsMjkuNWgtMjggTTExLjUsMnY1Nkg1MVYxNC44TDM4LjQsMkgxMS41eiBNMzguNCwyLjJ2MTIuN0g1MSBNNDUuNCw0MS43aC0yOCcsXG4gIHRpdGxlOiB6clV0aWwuY2xvbmUoZGF0YVZpZXdMYW5nLnRpdGxlKSxcbiAgbGFuZzogenJVdGlsLmNsb25lKGRhdGFWaWV3TGFuZy5sYW5nKSxcbiAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXG4gIHRleHRDb2xvcjogJyMwMDAnLFxuICB0ZXh0YXJlYUNvbG9yOiAnI2ZmZicsXG4gIHRleHRhcmVhQm9yZGVyQ29sb3I6ICcjMzMzJyxcbiAgYnV0dG9uQ29sb3I6ICcjYzIzNTMxJyxcbiAgYnV0dG9uVGV4dENvbG9yOiAnI2ZmZidcbn07XG5cbkRhdGFWaWV3LnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICB2YXIgY29udGFpbmVyID0gYXBpLmdldERvbSgpO1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuXG4gIGlmICh0aGlzLl9kb20pIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZG9tKTtcbiAgfVxuXG4gIHZhciByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHJvb3Quc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjVweDt0b3A6NXB4O2JvdHRvbTo1cHg7cmlnaHQ6NXB4Oyc7XG4gIHJvb3Quc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKSB8fCAnI2ZmZic7IC8vIENyZWF0ZSBlbGVtZW50c1xuXG4gIHZhciBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoNCcpO1xuICB2YXIgbGFuZyA9IG1vZGVsLmdldCgnbGFuZycpIHx8IFtdO1xuICBoZWFkZXIuaW5uZXJIVE1MID0gbGFuZ1swXSB8fCBtb2RlbC5nZXQoJ3RpdGxlJyk7XG4gIGhlYWRlci5zdHlsZS5jc3NUZXh0ID0gJ21hcmdpbjogMTBweCAyMHB4Oyc7XG4gIGhlYWRlci5zdHlsZS5jb2xvciA9IG1vZGVsLmdldCgndGV4dENvbG9yJyk7XG4gIHZhciB2aWV3TWFpbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICB2aWV3TWFpbi5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtvdmVyZmxvdzphdXRvOyc7XG4gIHZhciBvcHRpb25Ub0NvbnRlbnQgPSBtb2RlbC5nZXQoJ29wdGlvblRvQ29udGVudCcpO1xuICB2YXIgY29udGVudFRvT3B0aW9uID0gbW9kZWwuZ2V0KCdjb250ZW50VG9PcHRpb24nKTtcbiAgdmFyIHJlc3VsdCA9IGdldENvbnRlbnRGcm9tTW9kZWwoZWNNb2RlbCk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25Ub0NvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgaHRtbE9yRG9tID0gb3B0aW9uVG9Db250ZW50KGFwaS5nZXRPcHRpb24oKSk7XG5cbiAgICBpZiAodHlwZW9mIGh0bWxPckRvbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZpZXdNYWluLmlubmVySFRNTCA9IGh0bWxPckRvbTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc0RvbShodG1sT3JEb20pKSB7XG4gICAgICB2aWV3TWFpbi5hcHBlbmRDaGlsZChodG1sT3JEb20pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBVc2UgZGVmYXVsdCB0ZXh0YXJlYVxuICAgIHZpZXdNYWluLmFwcGVuZENoaWxkKHRleHRhcmVhKTtcbiAgICB0ZXh0YXJlYS5yZWFkT25seSA9IG1vZGVsLmdldCgncmVhZE9ubHknKTtcbiAgICB0ZXh0YXJlYS5zdHlsZS5jc3NUZXh0ID0gJ3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuNnJlbTsnO1xuICAgIHRleHRhcmVhLnN0eWxlLmNvbG9yID0gbW9kZWwuZ2V0KCd0ZXh0Q29sb3InKTtcbiAgICB0ZXh0YXJlYS5zdHlsZS5ib3JkZXJDb2xvciA9IG1vZGVsLmdldCgndGV4dGFyZWFCb3JkZXJDb2xvcicpO1xuICAgIHRleHRhcmVhLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1vZGVsLmdldCgndGV4dGFyZWFDb2xvcicpO1xuICAgIHRleHRhcmVhLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICB9XG5cbiAgdmFyIGJsb2NrTWV0YUxpc3QgPSByZXN1bHQubWV0YTtcbiAgdmFyIGJ1dHRvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBidXR0b25Db250YWluZXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtsZWZ0OjA7cmlnaHQ6MDsnO1xuICB2YXIgYnV0dG9uU3R5bGUgPSAnZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjIwcHg7Ym9yZGVyOm5vbmU7JyArICdjdXJzb3I6cG9pbnRlcjtwYWRkaW5nOjJweCA1cHg7Zm9udC1zaXplOjEycHg7Ym9yZGVyLXJhZGl1czozcHgnO1xuICB2YXIgY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHJlZnJlc2hCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYnV0dG9uU3R5bGUgKz0gJztiYWNrZ3JvdW5kLWNvbG9yOicgKyBtb2RlbC5nZXQoJ2J1dHRvbkNvbG9yJyk7XG4gIGJ1dHRvblN0eWxlICs9ICc7Y29sb3I6JyArIG1vZGVsLmdldCgnYnV0dG9uVGV4dENvbG9yJyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdCk7XG4gICAgc2VsZi5fZG9tID0gbnVsbDtcbiAgfVxuXG4gIGV2ZW50VG9vbC5hZGRFdmVudExpc3RlbmVyKGNsb3NlQnV0dG9uLCAnY2xpY2snLCBjbG9zZSk7XG4gIGV2ZW50VG9vbC5hZGRFdmVudExpc3RlbmVyKHJlZnJlc2hCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3T3B0aW9uO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgY29udGVudFRvT3B0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5ld09wdGlvbiA9IGNvbnRlbnRUb09wdGlvbih2aWV3TWFpbiwgYXBpLmdldE9wdGlvbigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09wdGlvbiA9IHBhcnNlQ29udGVudHModGV4dGFyZWEudmFsdWUsIGJsb2NrTWV0YUxpc3QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgdmlldyBmb3JtYXQgZXJyb3IgJyArIGUpO1xuICAgIH1cblxuICAgIGlmIChuZXdPcHRpb24pIHtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6ICdjaGFuZ2VEYXRhVmlldycsXG4gICAgICAgIG5ld09wdGlvbjogbmV3T3B0aW9uXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjbG9zZSgpO1xuICB9KTtcbiAgY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gbGFuZ1sxXTtcbiAgcmVmcmVzaEJ1dHRvbi5pbm5lckhUTUwgPSBsYW5nWzJdO1xuICByZWZyZXNoQnV0dG9uLnN0eWxlLmNzc1RleHQgPSBidXR0b25TdHlsZTtcbiAgY2xvc2VCdXR0b24uc3R5bGUuY3NzVGV4dCA9IGJ1dHRvblN0eWxlO1xuICAhbW9kZWwuZ2V0KCdyZWFkT25seScpICYmIGJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChyZWZyZXNoQnV0dG9uKTtcbiAgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGNsb3NlQnV0dG9uKTsgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NjM3MzQxL3VzZS10YWItdG8taW5kZW50LWluLXRleHRhcmVhXG5cbiAgZXZlbnRUb29sLmFkZEV2ZW50TGlzdGVuZXIodGV4dGFyZWEsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoKGUua2V5Q29kZSB8fCBlLndoaWNoKSA9PT0gOSkge1xuICAgICAgLy8gZ2V0IGNhcmV0IHBvc2l0aW9uL3NlbGVjdGlvblxuICAgICAgdmFyIHZhbCA9IHRoaXMudmFsdWU7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdmFyIGVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kOyAvLyBzZXQgdGV4dGFyZWEgdmFsdWUgdG86IHRleHQgYmVmb3JlIGNhcmV0ICsgdGFiICsgdGV4dCBhZnRlciBjYXJldFxuXG4gICAgICB0aGlzLnZhbHVlID0gdmFsLnN1YnN0cmluZygwLCBzdGFydCkgKyBJVEVNX1NQTElURVIgKyB2YWwuc3Vic3RyaW5nKGVuZCk7IC8vIHB1dCBjYXJldCBhdCByaWdodCBwb3NpdGlvbiBhZ2FpblxuXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQgPSBzdGFydCArIDE7IC8vIHByZXZlbnQgdGhlIGZvY3VzIGxvc2VcblxuICAgICAgZXZlbnRUb29sLnN0b3AoZSk7XG4gICAgfVxuICB9KTtcbiAgcm9vdC5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICByb290LmFwcGVuZENoaWxkKHZpZXdNYWluKTtcbiAgcm9vdC5hcHBlbmRDaGlsZChidXR0b25Db250YWluZXIpO1xuICB2aWV3TWFpbi5zdHlsZS5oZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0IC0gODAgKyAncHgnO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQocm9vdCk7XG4gIHRoaXMuX2RvbSA9IHJvb3Q7XG59O1xuXG5EYXRhVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICB0aGlzLl9kb20gJiYgYXBpLmdldERvbSgpLnJlbW92ZUNoaWxkKHRoaXMuX2RvbSk7XG59O1xuXG5EYXRhVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgdGhpcy5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbn07XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gdHJ5TWVyZ2VEYXRhT3B0aW9uKG5ld0RhdGEsIG9yaWdpbmFsRGF0YSkge1xuICByZXR1cm4genJVdGlsLm1hcChuZXdEYXRhLCBmdW5jdGlvbiAobmV3VmFsLCBpZHgpIHtcbiAgICB2YXIgb3JpZ2luYWwgPSBvcmlnaW5hbERhdGEgJiYgb3JpZ2luYWxEYXRhW2lkeF07XG5cbiAgICBpZiAoenJVdGlsLmlzT2JqZWN0KG9yaWdpbmFsKSAmJiAhenJVdGlsLmlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KG5ld1ZhbCkgJiYgIXpyVXRpbC5pc0FycmF5KG5ld1ZhbCkpIHtcbiAgICAgICAgbmV3VmFsID0gbmV3VmFsLnZhbHVlO1xuICAgICAgfSAvLyBPcmlnaW5hbCBkYXRhIGhhcyBvcHRpb25cblxuXG4gICAgICByZXR1cm4genJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgdmFsdWU6IG5ld1ZhbFxuICAgICAgfSwgb3JpZ2luYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3VmFsO1xuICAgIH1cbiAgfSk7XG59XG5cbmZlYXR1cmVNYW5hZ2VyLnJlZ2lzdGVyKCdkYXRhVmlldycsIERhdGFWaWV3KTtcbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiAnY2hhbmdlRGF0YVZpZXcnLFxuICBldmVudDogJ2RhdGFWaWV3Q2hhbmdlZCcsXG4gIHVwZGF0ZTogJ3ByZXBhcmVBbmRVcGRhdGUnXG59LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICB2YXIgbmV3U2VyaWVzT3B0TGlzdCA9IFtdO1xuICB6clV0aWwuZWFjaChwYXlsb2FkLm5ld09wdGlvbi5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBlY01vZGVsLmdldFNlcmllc0J5TmFtZShzZXJpZXNPcHQubmFtZSlbMF07XG5cbiAgICBpZiAoIXNlcmllc01vZGVsKSB7XG4gICAgICAvLyBOZXcgY3JlYXRlZCBzZXJpZXNcbiAgICAgIC8vIEdldXNzIHRoZSBzZXJpZXMgdHlwZVxuICAgICAgbmV3U2VyaWVzT3B0TGlzdC5wdXNoKHpyVXRpbC5leHRlbmQoe1xuICAgICAgICAvLyBEZWZhdWx0IGlzIHNjYXR0ZXJcbiAgICAgICAgdHlwZTogJ3NjYXR0ZXInXG4gICAgICB9LCBzZXJpZXNPcHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9yaWdpbmFsRGF0YSA9IHNlcmllc01vZGVsLmdldCgnZGF0YScpO1xuICAgICAgbmV3U2VyaWVzT3B0TGlzdC5wdXNoKHtcbiAgICAgICAgbmFtZTogc2VyaWVzT3B0Lm5hbWUsXG4gICAgICAgIGRhdGE6IHRyeU1lcmdlRGF0YU9wdGlvbihzZXJpZXNPcHQuZGF0YSwgb3JpZ2luYWxEYXRhKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZWNNb2RlbC5tZXJnZU9wdGlvbih6clV0aWwuZGVmYXVsdHMoe1xuICAgIHNlcmllczogbmV3U2VyaWVzT3B0TGlzdFxuICB9LCBwYXlsb2FkLm5ld09wdGlvbikpO1xufSk7XG52YXIgX2RlZmF1bHQgPSBEYXRhVmlldztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhVmlldy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgQnJ1c2hDb250cm9sbGVyID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlci9CcnVzaENvbnRyb2xsZXJcIik7XG5cbnZhciBCcnVzaFRhcmdldE1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVyL0JydXNoVGFyZ2V0TWFuYWdlclwiKTtcblxudmFyIGhpc3RvcnkgPSByZXF1aXJlKFwiLi4vLi4vZGF0YVpvb20vaGlzdG9yeVwiKTtcblxudmFyIHNsaWRlck1vdmUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVyL3NsaWRlck1vdmVcIik7XG5cbnZhciBsYW5nID0gcmVxdWlyZShcIi4uLy4uLy4uL2xhbmdcIik7XG5cbnZhciBmZWF0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9mZWF0dXJlTWFuYWdlclwiKTtcblxucmVxdWlyZShcIi4uLy4uL2RhdGFab29tU2VsZWN0XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBVc2UgZGF0YVpvb21TZWxlY3RcbnZhciBkYXRhWm9vbUxhbmcgPSBsYW5nLnRvb2xib3guZGF0YVpvb207XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoOyAvLyBTcGVjdGlhbCBjb21wb25lbnQgaWQgc3RhcnQgd2l0aCBcXDBlY1xcMCwgc2VlIGVjaGFydHMvbW9kZWwvR2xvYmFsLmpzfmhhc0lubmVySWRcblxudmFyIERBVEFfWk9PTV9JRF9CQVNFID0gJ1xcMF9lY19cXDB0b29sYm94LWRhdGFab29tXyc7XG5cbmZ1bmN0aW9uIERhdGFab29tKG1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlcn1cbiAgICovXG4gICh0aGlzLl9icnVzaENvbnRyb2xsZXIgPSBuZXcgQnJ1c2hDb250cm9sbGVyKGFwaS5nZXRacigpKSkub24oJ2JydXNoJywgenJVdGlsLmJpbmQodGhpcy5fb25CcnVzaCwgdGhpcykpLm1vdW50KCk7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cbiAgdGhpcy5faXNab29tQWN0aXZlO1xufVxuXG5EYXRhWm9vbS5kZWZhdWx0T3B0aW9uID0ge1xuICBzaG93OiB0cnVlLFxuICAvLyBJY29uIGdyb3VwXG4gIGljb246IHtcbiAgICB6b29tOiAnTTAsMTMuNWgyNi45IE0xMy41LDI2LjlWMCBNMzIuMSwxMy41SDU4VjU4SDEzLjUgVjMyLjEnLFxuICAgIGJhY2s6ICdNMjIsMS40TDkuOSwxMy41bDEyLjMsMTIuMyBNMTAuMywxMy41SDU0Ljl2NDQuNiBIMTAuM3YtMjYnXG4gIH0sXG4gIC8vIGB6b29tYCwgYGJhY2tgXG4gIHRpdGxlOiB6clV0aWwuY2xvbmUoZGF0YVpvb21MYW5nLnRpdGxlKVxufTtcbnZhciBwcm90byA9IERhdGFab29tLnByb3RvdHlwZTtcblxucHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gIHRoaXMubW9kZWwgPSBmZWF0dXJlTW9kZWw7XG4gIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gIHRoaXMuYXBpID0gYXBpO1xuICB1cGRhdGVab29tQnRuU3RhdHVzKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgdGhpcywgcGF5bG9hZCwgYXBpKTtcbiAgdXBkYXRlQmFja0J0blN0YXR1cyhmZWF0dXJlTW9kZWwsIGVjTW9kZWwpO1xufTtcblxucHJvdG8ub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGksIHR5cGUpIHtcbiAgaGFuZGxlcnNbdHlwZV0uY2FsbCh0aGlzKTtcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgdGhpcy5fYnJ1c2hDb250cm9sbGVyLnVubW91bnQoKTtcbn07XG5cbnByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gIHRoaXMuX2JydXNoQ29udHJvbGxlci5kaXNwb3NlKCk7XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIGhhbmRsZXJzID0ge1xuICB6b29tOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRBY3RpdmUgPSAhdGhpcy5faXNab29tQWN0aXZlO1xuICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICd0YWtlR2xvYmFsQ3Vyc29yJyxcbiAgICAgIGtleTogJ2RhdGFab29tU2VsZWN0JyxcbiAgICAgIGRhdGFab29tU2VsZWN0QWN0aXZlOiBuZXh0QWN0aXZlXG4gICAgfSk7XG4gIH0sXG4gIGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oaGlzdG9yeS5wb3AodGhpcy5lY01vZGVsKSk7XG4gIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxucHJvdG8uX29uQnJ1c2ggPSBmdW5jdGlvbiAoYXJlYXMsIG9wdCkge1xuICBpZiAoIW9wdC5pc0VuZCB8fCAhYXJlYXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNuYXBzaG90ID0ge307XG4gIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuXG4gIHRoaXMuX2JydXNoQ29udHJvbGxlci51cGRhdGVDb3ZlcnMoW10pOyAvLyByZW1vdmUgY292ZXJcblxuXG4gIHZhciBicnVzaFRhcmdldE1hbmFnZXIgPSBuZXcgQnJ1c2hUYXJnZXRNYW5hZ2VyKHJldHJpZXZlQXhpc1NldHRpbmcodGhpcy5tb2RlbC5vcHRpb24pLCBlY01vZGVsLCB7XG4gICAgaW5jbHVkZTogWydncmlkJ11cbiAgfSk7XG4gIGJydXNoVGFyZ2V0TWFuYWdlci5tYXRjaE91dHB1dFJhbmdlcyhhcmVhcywgZWNNb2RlbCwgZnVuY3Rpb24gKGFyZWEsIGNvb3JkUmFuZ2UsIGNvb3JkU3lzKSB7XG4gICAgaWYgKGNvb3JkU3lzLnR5cGUgIT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYnJ1c2hUeXBlID0gYXJlYS5icnVzaFR5cGU7XG5cbiAgICBpZiAoYnJ1c2hUeXBlID09PSAncmVjdCcpIHtcbiAgICAgIHNldEJhdGNoKCd4JywgY29vcmRTeXMsIGNvb3JkUmFuZ2VbMF0pO1xuICAgICAgc2V0QmF0Y2goJ3knLCBjb29yZFN5cywgY29vcmRSYW5nZVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEJhdGNoKHtcbiAgICAgICAgbGluZVg6ICd4JyxcbiAgICAgICAgbGluZVk6ICd5J1xuICAgICAgfVticnVzaFR5cGVdLCBjb29yZFN5cywgY29vcmRSYW5nZSk7XG4gICAgfVxuICB9KTtcbiAgaGlzdG9yeS5wdXNoKGVjTW9kZWwsIHNuYXBzaG90KTtcblxuICB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oc25hcHNob3QpO1xuXG4gIGZ1bmN0aW9uIHNldEJhdGNoKGRpbU5hbWUsIGNvb3JkU3lzLCBtaW5NYXgpIHtcbiAgICB2YXIgYXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoZGltTmFtZSk7XG4gICAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSBmaW5kRGF0YVpvb20oZGltTmFtZSwgYXhpc01vZGVsLCBlY01vZGVsKTsgLy8gUmVzdHJpY3QgcmFuZ2UuXG5cbiAgICB2YXIgbWluTWF4U3BhbiA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KGF4aXNNb2RlbCkuZ2V0TWluTWF4U3BhbigpO1xuXG4gICAgaWYgKG1pbk1heFNwYW4ubWluVmFsdWVTcGFuICE9IG51bGwgfHwgbWluTWF4U3Bhbi5tYXhWYWx1ZVNwYW4gIT0gbnVsbCkge1xuICAgICAgbWluTWF4ID0gc2xpZGVyTW92ZSgwLCBtaW5NYXguc2xpY2UoKSwgYXhpcy5zY2FsZS5nZXRFeHRlbnQoKSwgMCwgbWluTWF4U3Bhbi5taW5WYWx1ZVNwYW4sIG1pbk1heFNwYW4ubWF4VmFsdWVTcGFuKTtcbiAgICB9XG5cbiAgICBkYXRhWm9vbU1vZGVsICYmIChzbmFwc2hvdFtkYXRhWm9vbU1vZGVsLmlkXSA9IHtcbiAgICAgIGRhdGFab29tSWQ6IGRhdGFab29tTW9kZWwuaWQsXG4gICAgICBzdGFydFZhbHVlOiBtaW5NYXhbMF0sXG4gICAgICBlbmRWYWx1ZTogbWluTWF4WzFdXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRGF0YVpvb20oZGltTmFtZSwgYXhpc01vZGVsLCBlY01vZGVsKSB7XG4gICAgdmFyIGZvdW5kO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogJ2RhdGFab29tJyxcbiAgICAgIHN1YlR5cGU6ICdzZWxlY3QnXG4gICAgfSwgZnVuY3Rpb24gKGR6TW9kZWwpIHtcbiAgICAgIHZhciBoYXMgPSBkek1vZGVsLmdldEF4aXNNb2RlbChkaW1OYW1lLCBheGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgaGFzICYmIChmb3VuZCA9IGR6TW9kZWwpO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbiAgfVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbnByb3RvLl9kaXNwYXRjaFpvb21BY3Rpb24gPSBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgdmFyIGJhdGNoID0gW107IC8vIENvbnZlcnQgZnJvbSBoYXNoIG1hcCB0byBhcnJheS5cblxuICBlYWNoKHNuYXBzaG90LCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBkYXRhWm9vbUlkKSB7XG4gICAgYmF0Y2gucHVzaCh6clV0aWwuY2xvbmUoYmF0Y2hJdGVtKSk7XG4gIH0pO1xuICBiYXRjaC5sZW5ndGggJiYgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdkYXRhWm9vbScsXG4gICAgZnJvbTogdGhpcy51aWQsXG4gICAgYmF0Y2g6IGJhdGNoXG4gIH0pO1xufTtcblxuZnVuY3Rpb24gcmV0cmlldmVBeGlzU2V0dGluZyhvcHRpb24pIHtcbiAgdmFyIHNldHRpbmcgPSB7fTsgLy8gQ29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIHNldHRpbmc6IG51bGwgPT4gYWxsIGF4aXMsIGZhbHNlID0+IG5vIGF4aXMuXG5cbiAgenJVdGlsLmVhY2goWyd4QXhpc0luZGV4JywgJ3lBeGlzSW5kZXgnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBzZXR0aW5nW25hbWVdID0gb3B0aW9uW25hbWVdO1xuICAgIHNldHRpbmdbbmFtZV0gPT0gbnVsbCAmJiAoc2V0dGluZ1tuYW1lXSA9ICdhbGwnKTtcbiAgICAoc2V0dGluZ1tuYW1lXSA9PT0gZmFsc2UgfHwgc2V0dGluZ1tuYW1lXSA9PT0gJ25vbmUnKSAmJiAoc2V0dGluZ1tuYW1lXSA9IFtdKTtcbiAgfSk7XG4gIHJldHVybiBzZXR0aW5nO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVCYWNrQnRuU3RhdHVzKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCkge1xuICBmZWF0dXJlTW9kZWwuc2V0SWNvblN0YXR1cygnYmFjaycsIGhpc3RvcnkuY291bnQoZWNNb2RlbCkgPiAxID8gJ2VtcGhhc2lzJyA6ICdub3JtYWwnKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlWm9vbUJ0blN0YXR1cyhmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIHZpZXcsIHBheWxvYWQsIGFwaSkge1xuICB2YXIgem9vbUFjdGl2ZSA9IHZpZXcuX2lzWm9vbUFjdGl2ZTtcblxuICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLnR5cGUgPT09ICd0YWtlR2xvYmFsQ3Vyc29yJykge1xuICAgIHpvb21BY3RpdmUgPSBwYXlsb2FkLmtleSA9PT0gJ2RhdGFab29tU2VsZWN0JyA/IHBheWxvYWQuZGF0YVpvb21TZWxlY3RBY3RpdmUgOiBmYWxzZTtcbiAgfVxuXG4gIHZpZXcuX2lzWm9vbUFjdGl2ZSA9IHpvb21BY3RpdmU7XG4gIGZlYXR1cmVNb2RlbC5zZXRJY29uU3RhdHVzKCd6b29tJywgem9vbUFjdGl2ZSA/ICdlbXBoYXNpcycgOiAnbm9ybWFsJyk7XG4gIHZhciBicnVzaFRhcmdldE1hbmFnZXIgPSBuZXcgQnJ1c2hUYXJnZXRNYW5hZ2VyKHJldHJpZXZlQXhpc1NldHRpbmcoZmVhdHVyZU1vZGVsLm9wdGlvbiksIGVjTW9kZWwsIHtcbiAgICBpbmNsdWRlOiBbJ2dyaWQnXVxuICB9KTtcblxuICB2aWV3Ll9icnVzaENvbnRyb2xsZXIuc2V0UGFuZWxzKGJydXNoVGFyZ2V0TWFuYWdlci5tYWtlUGFuZWxPcHRzKGFwaSwgZnVuY3Rpb24gKHRhcmdldEluZm8pIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5mby54QXhpc0RlY2xhcmVkICYmICF0YXJnZXRJbmZvLnlBeGlzRGVjbGFyZWQgPyAnbGluZVgnIDogIXRhcmdldEluZm8ueEF4aXNEZWNsYXJlZCAmJiB0YXJnZXRJbmZvLnlBeGlzRGVjbGFyZWQgPyAnbGluZVknIDogJ3JlY3QnO1xuICB9KSkuZW5hYmxlQnJ1c2goem9vbUFjdGl2ZSA/IHtcbiAgICBicnVzaFR5cGU6ICdhdXRvJyxcbiAgICBicnVzaFN0eWxlOiB7XG4gICAgICAvLyBGSVhNRSB1c2VyIGN1c3RvbWl6ZWQ/XG4gICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICBmaWxsOiAncmdiYSgwLDAsMCwwLjIpJ1xuICAgIH1cbiAgfSA6IGZhbHNlKTtcbn1cblxuZmVhdHVyZU1hbmFnZXIucmVnaXN0ZXIoJ2RhdGFab29tJywgRGF0YVpvb20pOyAvLyBDcmVhdGUgc3BlY2lhbCBkYXRhWm9vbSBvcHRpb24gZm9yIHNlbGVjdFxuLy8gRklYTUUgY29uc2lkZXIgdGhlIGNhc2Ugb2YgbWVyZ2Ugb3B0aW9uLCB3aGVyZSBheGVzIG9wdGlvbnMgYXJlIG5vdCBleGlzdHMuXG5cbmVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdGlvbikge1xuICBpZiAoIW9wdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhWm9vbU9wdHMgPSBvcHRpb24uZGF0YVpvb20gfHwgKG9wdGlvbi5kYXRhWm9vbSA9IFtdKTtcblxuICBpZiAoIXpyVXRpbC5pc0FycmF5KGRhdGFab29tT3B0cykpIHtcbiAgICBvcHRpb24uZGF0YVpvb20gPSBkYXRhWm9vbU9wdHMgPSBbZGF0YVpvb21PcHRzXTtcbiAgfVxuXG4gIHZhciB0b29sYm94T3B0ID0gb3B0aW9uLnRvb2xib3g7XG5cbiAgaWYgKHRvb2xib3hPcHQpIHtcbiAgICAvLyBBc3N1bWUgdGhlcmUgaXMgb25seSBvbmUgdG9vbGJveFxuICAgIGlmICh6clV0aWwuaXNBcnJheSh0b29sYm94T3B0KSkge1xuICAgICAgdG9vbGJveE9wdCA9IHRvb2xib3hPcHRbMF07XG4gICAgfVxuXG4gICAgaWYgKHRvb2xib3hPcHQgJiYgdG9vbGJveE9wdC5mZWF0dXJlKSB7XG4gICAgICB2YXIgZGF0YVpvb21PcHQgPSB0b29sYm94T3B0LmZlYXR1cmUuZGF0YVpvb207IC8vIEZJWE1FOiBJZiBhZGQgZGF0YVpvb20gd2hlbiBzZXRPcHRpb24gaW4gbWVyZ2UgbW9kZSxcbiAgICAgIC8vIG5vIGF4aXMgaW5mbyB0byBiZSBhZGRlZC4gU2VlIGB0ZXN0L2RhdGFab29tLWV4dHJlbWUuaHRtbGBcblxuICAgICAgYWRkRm9yQXhpcygneEF4aXMnLCBkYXRhWm9vbU9wdCk7XG4gICAgICBhZGRGb3JBeGlzKCd5QXhpcycsIGRhdGFab29tT3B0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRGb3JBeGlzKGF4aXNOYW1lLCBkYXRhWm9vbU9wdCkge1xuICAgIGlmICghZGF0YVpvb21PcHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRyeSBub3QgdG8gbW9kaWZ5IG1vZGVsLCBiZWNhdXNlIGl0IGlzIG5vdCBtZXJnZWQgeWV0LlxuXG5cbiAgICB2YXIgYXhpc0luZGljZXNOYW1lID0gYXhpc05hbWUgKyAnSW5kZXgnO1xuICAgIHZhciBnaXZlbkF4aXNJbmRpY2VzID0gZGF0YVpvb21PcHRbYXhpc0luZGljZXNOYW1lXTtcblxuICAgIGlmIChnaXZlbkF4aXNJbmRpY2VzICE9IG51bGwgJiYgZ2l2ZW5BeGlzSW5kaWNlcyAhPSAnYWxsJyAmJiAhenJVdGlsLmlzQXJyYXkoZ2l2ZW5BeGlzSW5kaWNlcykpIHtcbiAgICAgIGdpdmVuQXhpc0luZGljZXMgPSBnaXZlbkF4aXNJbmRpY2VzID09PSBmYWxzZSB8fCBnaXZlbkF4aXNJbmRpY2VzID09PSAnbm9uZScgPyBbXSA6IFtnaXZlbkF4aXNJbmRpY2VzXTtcbiAgICB9XG5cbiAgICBmb3JFYWNoQ29tcG9uZW50KGF4aXNOYW1lLCBmdW5jdGlvbiAoYXhpc09wdCwgYXhpc0luZGV4KSB7XG4gICAgICBpZiAoZ2l2ZW5BeGlzSW5kaWNlcyAhPSBudWxsICYmIGdpdmVuQXhpc0luZGljZXMgIT0gJ2FsbCcgJiYgenJVdGlsLmluZGV4T2YoZ2l2ZW5BeGlzSW5kaWNlcywgYXhpc0luZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3T3B0ID0ge1xuICAgICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgICAgJGZyb21Ub29sYm94OiB0cnVlLFxuICAgICAgICAvLyBJZCBmb3IgbWVyZ2UgbWFwcGluZy5cbiAgICAgICAgaWQ6IERBVEFfWk9PTV9JRF9CQVNFICsgYXhpc05hbWUgKyBheGlzSW5kZXhcbiAgICAgIH07IC8vIEZJWE1FXG4gICAgICAvLyBPbmx5IHN1cHBvcnQgb25lIGF4aXMgbm93LlxuXG4gICAgICBuZXdPcHRbYXhpc0luZGljZXNOYW1lXSA9IGF4aXNJbmRleDtcbiAgICAgIGRhdGFab29tT3B0cy5wdXNoKG5ld09wdCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoQ29tcG9uZW50KG1haW5UeXBlLCBjYikge1xuICAgIHZhciBvcHRzID0gb3B0aW9uW21haW5UeXBlXTtcblxuICAgIGlmICghenJVdGlsLmlzQXJyYXkob3B0cykpIHtcbiAgICAgIG9wdHMgPSBvcHRzID8gW29wdHNdIDogW107XG4gICAgfVxuXG4gICAgZWFjaChvcHRzLCBjYik7XG4gIH1cbn0pO1xudmFyIF9kZWZhdWx0ID0gRGF0YVpvb207XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVpvb20uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVpvb20uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGFuZ1wiKTtcblxudmFyIGZlYXR1cmVNYW5hZ2VyID0gcmVxdWlyZShcIi4uL2ZlYXR1cmVNYW5hZ2VyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgbWFnaWNUeXBlTGFuZyA9IGxhbmcudG9vbGJveC5tYWdpY1R5cGU7XG5cbmZ1bmN0aW9uIE1hZ2ljVHlwZShtb2RlbCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG59XG5cbk1hZ2ljVHlwZS5kZWZhdWx0T3B0aW9uID0ge1xuICBzaG93OiB0cnVlLFxuICB0eXBlOiBbXSxcbiAgLy8gSWNvbiBncm91cFxuICBpY29uOiB7XG4gICAgbGluZTogJ000LjEsMjguOWg3LjFsOS4zLTIybDcuNCwzOGw5LjctMTkuN2wzLDEyLjhoMTQuOU00LjEsNThoNTEuNCcsXG4gICAgYmFyOiAnTTYuNywyMi45aDEwVjQ4aC0xMFYyMi45ek0yNC45LDEzaDEwdjM1aC0xMFYxM3pNNDMuMiwyaDEwdjQ2aC0xMFYyek0zLjEsNThoNTMuNycsXG4gICAgc3RhY2s6ICdNOC4yLDM4LjRsLTguNCw0LjFsMzAuNiwxNS4zTDYwLDQyLjVsLTguMS00LjFsLTIxLjUsMTFMOC4yLDM4LjR6IE01MS45LDMwbC04LjEsNC4ybC0xMy40LDYuOWwtMTMuOS02LjlMOC4yLDMwbC04LjQsNC4ybDguNCw0LjJsMjIuMiwxMWwyMS41LTExbDguMS00LjJMNTEuOSwzMHogTTUxLjksMjEuN2wtOC4xLDQuMkwzNS43LDMwbC01LjMsMi44TDI0LjksMzBsLTguNC00LjFsLTguMy00LjJsLTguNCw0LjJMOC4yLDMwbDguMyw0LjJsMTMuOSw2LjlsMTMuNC02LjlsOC4xLTQuMmw4LjEtNC4xTDUxLjksMjEuN3pNMzAuNCwyLjJMLTAuMiwxNy41bDguNCw0LjFsOC4zLDQuMmw4LjQsNC4ybDUuNSwyLjdsNS4zLTIuN2w4LjEtNC4ybDguMS00LjJsOC4xLTQuMUwzMC40LDIuMnonLFxuICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHRpbGVkOiAnTTIuMywyLjJoMjIuOFYyNUgyLjNWMi4yeiBNMzUsMi4yaDIyLjhWMjVIMzVWMi4yek0yLjMsMzVoMjIuOHYyMi44SDIuM1YzNXogTTM1LDM1aDIyLjh2MjIuOEgzNVYzNXonXG4gIH0sXG4gIC8vIGBsaW5lYCwgYGJhcmAsIGBzdGFja2AsIGB0aWxlZGBcbiAgdGl0bGU6IHpyVXRpbC5jbG9uZShtYWdpY1R5cGVMYW5nLnRpdGxlKSxcbiAgb3B0aW9uOiB7fSxcbiAgc2VyaWVzSW5kZXg6IHt9XG59O1xudmFyIHByb3RvID0gTWFnaWNUeXBlLnByb3RvdHlwZTtcblxucHJvdG8uZ2V0SWNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIHZhciBhdmFpbGFibGVJY29ucyA9IG1vZGVsLmdldCgnaWNvbicpO1xuICB2YXIgaWNvbnMgPSB7fTtcbiAgenJVdGlsLmVhY2gobW9kZWwuZ2V0KCd0eXBlJyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKGF2YWlsYWJsZUljb25zW3R5cGVdKSB7XG4gICAgICBpY29uc1t0eXBlXSA9IGF2YWlsYWJsZUljb25zW3R5cGVdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpY29ucztcbn07XG5cbnZhciBzZXJpZXNPcHRHZW5yZWF0b3IgPSB7XG4gICdsaW5lJzogZnVuY3Rpb24gKHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWwpIHtcbiAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgIHJldHVybiB6clV0aWwubWVyZ2Uoe1xuICAgICAgICBpZDogc2VyaWVzSWQsXG4gICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgLy8gUHJlc2VydmUgZGF0YSByZWxhdGVkIG9wdGlvblxuICAgICAgICBkYXRhOiBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKSxcbiAgICAgICAgc3RhY2s6IHNlcmllc01vZGVsLmdldCgnc3RhY2snKSxcbiAgICAgICAgbWFya1BvaW50OiBzZXJpZXNNb2RlbC5nZXQoJ21hcmtQb2ludCcpLFxuICAgICAgICBtYXJrTGluZTogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrTGluZScpXG4gICAgICB9LCBtb2RlbC5nZXQoJ29wdGlvbi5saW5lJykgfHwge30sIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgJ2Jhcic6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdsaW5lJykge1xuICAgICAgcmV0dXJuIHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgdHlwZTogJ2JhcicsXG4gICAgICAgIC8vIFByZXNlcnZlIGRhdGEgcmVsYXRlZCBvcHRpb25cbiAgICAgICAgZGF0YTogc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJyksXG4gICAgICAgIHN0YWNrOiBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJyksXG4gICAgICAgIG1hcmtQb2ludDogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrUG9pbnQnKSxcbiAgICAgICAgbWFya0xpbmU6IHNlcmllc01vZGVsLmdldCgnbWFya0xpbmUnKVxuICAgICAgfSwgbW9kZWwuZ2V0KCdvcHRpb24uYmFyJykgfHwge30sIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgJ3N0YWNrJzogZnVuY3Rpb24gKHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWwpIHtcbiAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2xpbmUnIHx8IHNlcmllc1R5cGUgPT09ICdiYXInKSB7XG4gICAgICByZXR1cm4genJVdGlsLm1lcmdlKHtcbiAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICBzdGFjazogJ19fZWNfbWFnaWNUeXBlX3N0YWNrX18nXG4gICAgICB9LCBtb2RlbC5nZXQoJ29wdGlvbi5zdGFjaycpIHx8IHt9LCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gICd0aWxlZCc6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdsaW5lJyB8fCBzZXJpZXNUeXBlID09PSAnYmFyJykge1xuICAgICAgcmV0dXJuIHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgc3RhY2s6ICcnXG4gICAgICB9LCBtb2RlbC5nZXQoJ29wdGlvbi50aWxlZCcpIHx8IHt9LCB0cnVlKTtcbiAgICB9XG4gIH1cbn07XG52YXIgcmFkaW9UeXBlcyA9IFtbJ2xpbmUnLCAnYmFyJ10sIFsnc3RhY2snLCAndGlsZWQnXV07XG5cbnByb3RvLm9uY2xpY2sgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpLCB0eXBlKSB7XG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIHZhciBzZXJpZXNJbmRleCA9IG1vZGVsLmdldCgnc2VyaWVzSW5kZXguJyArIHR5cGUpOyAvLyBOb3Qgc3VwcG9ydGVkIG1hZ2ljVHlwZVxuXG4gIGlmICghc2VyaWVzT3B0R2VucmVhdG9yW3R5cGVdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5ld09wdGlvbiA9IHtcbiAgICBzZXJpZXM6IFtdXG4gIH07XG5cbiAgdmFyIGdlbmVyYXRlTmV3U2VyaWVzVHlwZXMgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgc2VyaWVzVHlwZSA9IHNlcmllc01vZGVsLnN1YlR5cGU7XG4gICAgdmFyIHNlcmllc0lkID0gc2VyaWVzTW9kZWwuaWQ7XG4gICAgdmFyIG5ld1Nlcmllc09wdCA9IHNlcmllc09wdEdlbnJlYXRvclt0eXBlXShzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKTtcblxuICAgIGlmIChuZXdTZXJpZXNPcHQpIHtcbiAgICAgIC8vIFBFTkRJTkcgSWYgbWVyZ2Ugb3JpZ2luYWwgb3B0aW9uP1xuICAgICAgenJVdGlsLmRlZmF1bHRzKG5ld1Nlcmllc09wdCwgc2VyaWVzTW9kZWwub3B0aW9uKTtcbiAgICAgIG5ld09wdGlvbi5zZXJpZXMucHVzaChuZXdTZXJpZXNPcHQpO1xuICAgIH0gLy8gTW9kaWZ5IGJvdW5kYXJ5R2FwXG5cblxuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJyAmJiAodHlwZSA9PT0gJ2xpbmUnIHx8IHR5cGUgPT09ICdiYXInKSkge1xuICAgICAgdmFyIGNhdGVnb3J5QXhpcyA9IGNvb3JkU3lzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF07XG5cbiAgICAgIGlmIChjYXRlZ29yeUF4aXMpIHtcbiAgICAgICAgdmFyIGF4aXNEaW0gPSBjYXRlZ29yeUF4aXMuZGltO1xuICAgICAgICB2YXIgYXhpc1R5cGUgPSBheGlzRGltICsgJ0F4aXMnO1xuICAgICAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgIG1haW5UeXBlOiBheGlzVHlwZSxcbiAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KG5hbWUgKyAnSW5kZXgnKSxcbiAgICAgICAgICBpZDogc2VyaWVzTW9kZWwuZ2V0KG5hbWUgKyAnSWQnKVxuICAgICAgICB9KVswXTtcbiAgICAgICAgdmFyIGF4aXNJbmRleCA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcbiAgICAgICAgbmV3T3B0aW9uW2F4aXNUeXBlXSA9IG5ld09wdGlvbltheGlzVHlwZV0gfHwgW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gYXhpc0luZGV4OyBpKyspIHtcbiAgICAgICAgICBuZXdPcHRpb25bYXhpc1R5cGVdW2F4aXNJbmRleF0gPSBuZXdPcHRpb25bYXhpc1R5cGVdW2F4aXNJbmRleF0gfHwge307XG4gICAgICAgIH1cblxuICAgICAgICBuZXdPcHRpb25bYXhpc1R5cGVdW2F4aXNJbmRleF0uYm91bmRhcnlHYXAgPSB0eXBlID09PSAnYmFyJyA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgenJVdGlsLmVhY2gocmFkaW9UeXBlcywgZnVuY3Rpb24gKHJhZGlvKSB7XG4gICAgaWYgKHpyVXRpbC5pbmRleE9mKHJhZGlvLCB0eXBlKSA+PSAwKSB7XG4gICAgICB6clV0aWwuZWFjaChyYWRpbywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgbW9kZWwuc2V0SWNvblN0YXR1cyhpdGVtLCAnbm9ybWFsJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBtb2RlbC5zZXRJY29uU3RhdHVzKHR5cGUsICdlbXBoYXNpcycpO1xuICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICBxdWVyeTogc2VyaWVzSW5kZXggPT0gbnVsbCA/IG51bGwgOiB7XG4gICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXhcbiAgICB9XG4gIH0sIGdlbmVyYXRlTmV3U2VyaWVzVHlwZXMpO1xuICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdjaGFuZ2VNYWdpY1R5cGUnLFxuICAgIGN1cnJlbnRUeXBlOiB0eXBlLFxuICAgIG5ld09wdGlvbjogbmV3T3B0aW9uXG4gIH0pO1xufTtcblxuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICdjaGFuZ2VNYWdpY1R5cGUnLFxuICBldmVudDogJ21hZ2ljVHlwZUNoYW5nZWQnLFxuICB1cGRhdGU6ICdwcmVwYXJlQW5kVXBkYXRlJ1xufSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5tZXJnZU9wdGlvbihwYXlsb2FkLm5ld09wdGlvbik7XG59KTtcbmZlYXR1cmVNYW5hZ2VyLnJlZ2lzdGVyKCdtYWdpY1R5cGUnLCBNYWdpY1R5cGUpO1xudmFyIF9kZWZhdWx0ID0gTWFnaWNUeXBlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL01hZ2ljVHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9NYWdpY1R5cGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgaGlzdG9yeSA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhWm9vbS9oaXN0b3J5XCIpO1xuXG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9sYW5nXCIpO1xuXG52YXIgZmVhdHVyZU1hbmFnZXIgPSByZXF1aXJlKFwiLi4vZmVhdHVyZU1hbmFnZXJcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciByZXN0b3JlTGFuZyA9IGxhbmcudG9vbGJveC5yZXN0b3JlO1xuXG5mdW5jdGlvbiBSZXN0b3JlKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbn1cblxuUmVzdG9yZS5kZWZhdWx0T3B0aW9uID0ge1xuICBzaG93OiB0cnVlLFxuICBpY29uOiAnTTMuOCwzMy40IE00NywxOC45aDkuOFY4LjcgTTU2LjMsMjAuMSBDNTIuMSw5LDQwLjUsMC42LDI2LjgsMi4xQzEyLjYsMy43LDEuNiwxNi4yLDIuMSwzMC42IE0xMyw0MS4xSDMuMXYxMC4yIE0zLjcsMzkuOWM0LjIsMTEuMSwxNS44LDE5LjUsMjkuNSwxOCBjMTQuMi0xLjYsMjUuMi0xNC4xLDI0LjctMjguNScsXG4gIHRpdGxlOiByZXN0b3JlTGFuZy50aXRsZVxufTtcbnZhciBwcm90byA9IFJlc3RvcmUucHJvdG90eXBlO1xuXG5wcm90by5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgdHlwZSkge1xuICBoaXN0b3J5LmNsZWFyKGVjTW9kZWwpO1xuICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdyZXN0b3JlJyxcbiAgICBmcm9tOiB0aGlzLnVpZFxuICB9KTtcbn07XG5cbmZlYXR1cmVNYW5hZ2VyLnJlZ2lzdGVyKCdyZXN0b3JlJywgUmVzdG9yZSk7XG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ3Jlc3RvcmUnLFxuICBldmVudDogJ3Jlc3RvcmUnLFxuICB1cGRhdGU6ICdwcmVwYXJlQW5kVXBkYXRlJ1xufSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5yZXNldE9wdGlvbigncmVjcmVhdGUnKTtcbn0pO1xudmFyIF9kZWZhdWx0ID0gUmVzdG9yZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9SZXN0b3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL1Jlc3RvcmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZW52ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZW52XCIpO1xuXG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9sYW5nXCIpO1xuXG52YXIgZmVhdHVyZU1hbmFnZXIgPSByZXF1aXJlKFwiLi4vZmVhdHVyZU1hbmFnZXJcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBzYXZlQXNJbWFnZUxhbmcgPSBsYW5nLnRvb2xib3guc2F2ZUFzSW1hZ2U7XG5cbmZ1bmN0aW9uIFNhdmVBc0ltYWdlKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbn1cblxuU2F2ZUFzSW1hZ2UuZGVmYXVsdE9wdGlvbiA9IHtcbiAgc2hvdzogdHJ1ZSxcbiAgaWNvbjogJ000LjcsMjIuOUwyOS4zLDQ1LjVMNTQuNywyMy40TTQuNiw0My42TDQuNiw1OEw1My44LDU4TDUzLjgsNDMuNk0yOS4yLDQ1LjFMMjkuMiwwJyxcbiAgdGl0bGU6IHNhdmVBc0ltYWdlTGFuZy50aXRsZSxcbiAgdHlwZTogJ3BuZycsXG4gIC8vIERlZmF1bHQgdXNlIG9wdGlvbi5iYWNrZ3JvdW5kQ29sb3JcbiAgLy8gYmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXG4gIG5hbWU6ICcnLFxuICBleGNsdWRlQ29tcG9uZW50czogWyd0b29sYm94J10sXG4gIHBpeGVsUmF0aW86IDEsXG4gIGxhbmc6IHNhdmVBc0ltYWdlTGFuZy5sYW5nLnNsaWNlKClcbn07XG5TYXZlQXNJbWFnZS5wcm90b3R5cGUudW51c2FibGUgPSAhZW52LmNhbnZhc1N1cHBvcnRlZDtcbnZhciBwcm90byA9IFNhdmVBc0ltYWdlLnByb3RvdHlwZTtcblxucHJvdG8ub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgdmFyIHRpdGxlID0gbW9kZWwuZ2V0KCduYW1lJykgfHwgZWNNb2RlbC5nZXQoJ3RpdGxlLjAudGV4dCcpIHx8ICdlY2hhcnRzJztcbiAgdmFyICRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICB2YXIgdHlwZSA9IG1vZGVsLmdldCgndHlwZScsIHRydWUpIHx8ICdwbmcnO1xuICAkYS5kb3dubG9hZCA9IHRpdGxlICsgJy4nICsgdHlwZTtcbiAgJGEudGFyZ2V0ID0gJ19ibGFuayc7XG4gIHZhciB1cmwgPSBhcGkuZ2V0Q29ubmVjdGVkRGF0YVVSTCh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJywgdHJ1ZSkgfHwgZWNNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpIHx8ICcjZmZmJyxcbiAgICBleGNsdWRlQ29tcG9uZW50czogbW9kZWwuZ2V0KCdleGNsdWRlQ29tcG9uZW50cycpLFxuICAgIHBpeGVsUmF0aW86IG1vZGVsLmdldCgncGl4ZWxSYXRpbycpXG4gIH0pO1xuICAkYS5ocmVmID0gdXJsOyAvLyBDaHJvbWUgYW5kIEZpcmVmb3hcblxuICBpZiAodHlwZW9mIE1vdXNlRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgIWVudi5icm93c2VyLmllICYmICFlbnYuYnJvd3Nlci5lZGdlKSB7XG4gICAgdmFyIGV2dCA9IG5ldyBNb3VzZUV2ZW50KCdjbGljaycsIHtcbiAgICAgIHZpZXc6IHdpbmRvdyxcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgICRhLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfSAvLyBJRVxuICBlbHNlIHtcbiAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHtcbiAgICAgICAgdmFyIGJzdHIgPSBhdG9iKHVybC5zcGxpdCgnLCcpWzFdKTtcbiAgICAgICAgdmFyIG4gPSBic3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHU4YXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XG5cbiAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgIHU4YXJyW25dID0gYnN0ci5jaGFyQ29kZUF0KG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbdThhcnJdKTtcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJsb2IsIHRpdGxlICsgJy4nICsgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGFuZyA9IG1vZGVsLmdldCgnbGFuZycpO1xuICAgICAgICB2YXIgaHRtbCA9ICcnICsgJzxib2R5IHN0eWxlPVwibWFyZ2luOjA7XCI+JyArICc8aW1nIHNyYz1cIicgKyB1cmwgKyAnXCIgc3R5bGU9XCJtYXgtd2lkdGg6MTAwJTtcIiB0aXRsZT1cIicgKyAobGFuZyAmJiBsYW5nWzBdIHx8ICcnKSArICdcIiAvPicgKyAnPC9ib2R5Pic7XG4gICAgICAgIHZhciB0YWIgPSB3aW5kb3cub3BlbigpO1xuICAgICAgICB0YWIuZG9jdW1lbnQud3JpdGUoaHRtbCk7XG4gICAgICB9XG4gICAgfVxufTtcblxuZmVhdHVyZU1hbmFnZXIucmVnaXN0ZXIoJ3NhdmVBc0ltYWdlJywgU2F2ZUFzSW1hZ2UpO1xudmFyIF9kZWZhdWx0ID0gU2F2ZUFzSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvU2F2ZUFzSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvU2F2ZUFzSW1hZ2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgZmVhdHVyZXMgPSB7fTtcblxuZnVuY3Rpb24gcmVnaXN0ZXIobmFtZSwgY3Rvcikge1xuICBmZWF0dXJlc1tuYW1lXSA9IGN0b3I7XG59XG5cbmZ1bmN0aW9uIGdldChuYW1lKSB7XG4gIHJldHVybiBmZWF0dXJlc1tuYW1lXTtcbn1cblxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZXhwb3J0cy5nZXQgPSBnZXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxucmVxdWlyZShcIi4vYXhpc1BvaW50ZXJcIik7XG5cbnJlcXVpcmUoXCIuL3Rvb2x0aXAvVG9vbHRpcE1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi90b29sdGlwL1Rvb2x0aXBWaWV3XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBGSVhNRSBCZXR0ZXIgd2F5IHRvIHBhY2sgZGF0YSBpbiBncmFwaGljIGVsZW1lbnRcblxuLyoqXG4gKiBAYWN0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNlcmllc0luZGV4XG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YUluZGV4XG4gKiBAcHJvcGVydHkge251bWJlcn0gW3hdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ldXG4gKi9cbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiAnc2hvd1RpcCcsXG4gIGV2ZW50OiAnc2hvd1RpcCcsXG4gIHVwZGF0ZTogJ3Rvb2x0aXA6bWFudWFsbHlTaG93VGlwJ1xufSwgLy8gbm9vcFxuZnVuY3Rpb24gKCkge30pO1xuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICdoaWRlVGlwJyxcbiAgZXZlbnQ6ICdoaWRlVGlwJyxcbiAgdXBkYXRlOiAndG9vbHRpcDptYW51YWxseUhpZGVUaXAnXG59LCAvLyBub29wXG5mdW5jdGlvbiAoKSB7fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciB6ckNvbG9yID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3Rvb2wvY29sb3JcIik7XG5cbnZhciBldmVudFV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9ldmVudFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2VudlwiKTtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgdG9DYW1lbENhc2UgPSBmb3JtYXRVdGlsLnRvQ2FtZWxDYXNlO1xudmFyIHZlbmRvcnMgPSBbJycsICctd2Via2l0LScsICctbW96LScsICctby0nXTtcbnZhciBnQ3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO2JvcmRlci1zdHlsZTpzb2xpZDt3aGl0ZS1zcGFjZTpub3dyYXA7ei1pbmRleDo5OTk5OTk5Oyc7XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfVxuICogQGlubmVyXG4gKi9cblxuZnVuY3Rpb24gYXNzZW1ibGVUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gIHZhciB0cmFuc2l0aW9uQ3VydmUgPSAnY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpJztcbiAgdmFyIHRyYW5zaXRpb25UZXh0ID0gJ2xlZnQgJyArIGR1cmF0aW9uICsgJ3MgJyArIHRyYW5zaXRpb25DdXJ2ZSArICcsJyArICd0b3AgJyArIGR1cmF0aW9uICsgJ3MgJyArIHRyYW5zaXRpb25DdXJ2ZTtcbiAgcmV0dXJuIHpyVXRpbC5tYXAodmVuZG9ycywgZnVuY3Rpb24gKHZlbmRvclByZWZpeCkge1xuICAgIHJldHVybiB2ZW5kb3JQcmVmaXggKyAndHJhbnNpdGlvbjonICsgdHJhbnNpdGlvblRleHQ7XG4gIH0pLmpvaW4oJzsnKTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxuICogQHJldHVybiB7c3RyaW5nfVxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlbWJsZUZvbnQodGV4dFN0eWxlTW9kZWwpIHtcbiAgdmFyIGNzc1RleHQgPSBbXTtcbiAgdmFyIGZvbnRTaXplID0gdGV4dFN0eWxlTW9kZWwuZ2V0KCdmb250U2l6ZScpO1xuICB2YXIgY29sb3IgPSB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKTtcbiAgY29sb3IgJiYgY3NzVGV4dC5wdXNoKCdjb2xvcjonICsgY29sb3IpO1xuICBjc3NUZXh0LnB1c2goJ2ZvbnQ6JyArIHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSk7XG4gIGZvbnRTaXplICYmIGNzc1RleHQucHVzaCgnbGluZS1oZWlnaHQ6JyArIE1hdGgucm91bmQoZm9udFNpemUgKiAzIC8gMikgKyAncHgnKTtcbiAgZWFjaChbJ2RlY29yYXRpb24nLCAnYWxpZ24nXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsID0gdGV4dFN0eWxlTW9kZWwuZ2V0KG5hbWUpO1xuICAgIHZhbCAmJiBjc3NUZXh0LnB1c2goJ3RleHQtJyArIG5hbWUgKyAnOicgKyB2YWwpO1xuICB9KTtcbiAgcmV0dXJuIGNzc1RleHQuam9pbignOycpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9vbHRpcE1vZGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VtYmxlQ3NzVGV4dCh0b29sdGlwTW9kZWwpIHtcbiAgdmFyIGNzc1RleHQgPSBbXTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyYW5zaXRpb25EdXJhdGlvbicpO1xuICB2YXIgYmFja2dyb3VuZENvbG9yID0gdG9vbHRpcE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gIHZhciB0ZXh0U3R5bGVNb2RlbCA9IHRvb2x0aXBNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gIHZhciBwYWRkaW5nID0gdG9vbHRpcE1vZGVsLmdldCgncGFkZGluZycpOyAvLyBBbmltYXRpb24gdHJhbnNpdGlvbi4gRG8gbm90IGFuaW1hdGUgd2hlbiB0cmFuc2l0aW9uRHVyYXRpb24gaXMgMC5cblxuICB0cmFuc2l0aW9uRHVyYXRpb24gJiYgY3NzVGV4dC5wdXNoKGFzc2VtYmxlVHJhbnNpdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pKTtcblxuICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgaWYgKGVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICAgIGNzc1RleHQucHVzaCgnYmFja2dyb3VuZC1Db2xvcjonICsgYmFja2dyb3VuZENvbG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGllXG4gICAgICBjc3NUZXh0LnB1c2goJ2JhY2tncm91bmQtQ29sb3I6IycgKyB6ckNvbG9yLnRvSGV4KGJhY2tncm91bmRDb2xvcikpO1xuICAgICAgY3NzVGV4dC5wdXNoKCdmaWx0ZXI6YWxwaGEob3BhY2l0eT03MCknKTtcbiAgICB9XG4gIH0gLy8gQm9yZGVyIHN0eWxlXG5cblxuICBlYWNoKFsnd2lkdGgnLCAnY29sb3InLCAncmFkaXVzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGJvcmRlck5hbWUgPSAnYm9yZGVyLScgKyBuYW1lO1xuICAgIHZhciBjYW1lbENhc2UgPSB0b0NhbWVsQ2FzZShib3JkZXJOYW1lKTtcbiAgICB2YXIgdmFsID0gdG9vbHRpcE1vZGVsLmdldChjYW1lbENhc2UpO1xuICAgIHZhbCAhPSBudWxsICYmIGNzc1RleHQucHVzaChib3JkZXJOYW1lICsgJzonICsgdmFsICsgKG5hbWUgPT09ICdjb2xvcicgPyAnJyA6ICdweCcpKTtcbiAgfSk7IC8vIFRleHQgc3R5bGVcblxuICBjc3NUZXh0LnB1c2goYXNzZW1ibGVGb250KHRleHRTdHlsZU1vZGVsKSk7IC8vIFBhZGRpbmdcblxuICBpZiAocGFkZGluZyAhPSBudWxsKSB7XG4gICAgY3NzVGV4dC5wdXNoKCdwYWRkaW5nOicgKyBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KHBhZGRpbmcpLmpvaW4oJ3B4ICcpICsgJ3B4Jyk7XG4gIH1cblxuICByZXR1cm4gY3NzVGV4dC5qb2luKCc7JykgKyAnOyc7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG5mdW5jdGlvbiBUb29sdGlwQ29udGVudChjb250YWluZXIsIGFwaSkge1xuICBpZiAoZW52Lnd4YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciB6ciA9IHRoaXMuX3pyID0gYXBpLmdldFpyKCk7XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5feCA9IGFwaS5nZXRXaWR0aCgpIC8gMjtcbiAgdGhpcy5feSA9IGFwaS5nZXRIZWlnaHQoKSAvIDI7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5faGlkZVRpbWVvdXQ7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBlbC5vbm1vdXNlZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2xlYXIgdGhlIHRpbWVvdXQgaW4gaGlkZUxhdGVyIGFuZCBrZWVwIHNob3dpbmcgdG9vbHRpcFxuICAgIGlmIChzZWxmLl9lbnRlcmFibGUpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl9oaWRlVGltZW91dCk7XG4gICAgICBzZWxmLl9zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzZWxmLl9pbkNvbnRlbnQgPSB0cnVlO1xuICB9O1xuXG4gIGVsLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICBpZiAoIXNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgLy8gVHJ5IHRyaWdnZXIgenJlbmRlciBldmVudCB0byBhdm9pZCBtb3VzZVxuICAgICAgLy8gaW4gYW5kIG91dCBzaGFwZSB0b28gZnJlcXVlbnRseVxuICAgICAgdmFyIGhhbmRsZXIgPSB6ci5oYW5kbGVyO1xuICAgICAgZXZlbnRVdGlsLm5vcm1hbGl6ZUV2ZW50KGNvbnRhaW5lciwgZSwgdHJ1ZSk7XG4gICAgICBoYW5kbGVyLmRpc3BhdGNoKCdtb3VzZW1vdmUnLCBlKTtcbiAgICB9XG4gIH07XG5cbiAgZWwub25tb3VzZWxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9lbnRlcmFibGUpIHtcbiAgICAgIGlmIChzZWxmLl9zaG93KSB7XG4gICAgICAgIHNlbGYuaGlkZUxhdGVyKHNlbGYuX2hpZGVEZWxheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5faW5Db250ZW50ID0gZmFsc2U7XG4gIH07XG59XG5cblRvb2x0aXBDb250ZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRvb2x0aXBDb250ZW50LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIF9lbnRlcmFibGU6IHRydWUsXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB3aGVuIHRvb2x0aXAgaXMgcmVuZGVyZWRcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIEZJWE1FXG4gICAgLy8gTW92ZSB0aGlzIGxvZ2ljIHRvIGVjIG1haW4/XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICB2YXIgc3RsID0gY29udGFpbmVyLmN1cnJlbnRTdHlsZSB8fCBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgdmFyIGRvbVN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuXG4gICAgaWYgKGRvbVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0bC5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xuICAgICAgZG9tU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH0gLy8gSGlkZSB0aGUgdG9vbHRpcFxuICAgIC8vIFBFTkRJTkdcbiAgICAvLyB0aGlzLmhpZGUoKTtcblxuICB9LFxuICBzaG93OiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hpZGVUaW1lb3V0KTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGVsLnN0eWxlLmNzc1RleHQgPSBnQ3NzVGV4dCArIGFzc2VtYmxlQ3NzVGV4dCh0b29sdGlwTW9kZWwpIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjExMjU1ODcvY3NzMy10cmFuc2l0aW9uLW5vdC13b3JraW5nLWluLWNocm9tZS1hbnltb3JlXG4gICAgKyAnO2xlZnQ6JyArIHRoaXMuX3ggKyAncHg7dG9wOicgKyB0aGlzLl95ICsgJ3B4OycgKyAodG9vbHRpcE1vZGVsLmdldCgnZXh0cmFDc3NUZXh0JykgfHwgJycpO1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5pbm5lckhUTUwgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgIHRoaXMuX3Nob3cgPSB0cnVlO1xuICB9LFxuICBzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gY29udGVudCA9PSBudWxsID8gJycgOiBjb250ZW50O1xuICB9LFxuICBzZXRFbnRlcmFibGU6IGZ1bmN0aW9uIChlbnRlcmFibGUpIHtcbiAgICB0aGlzLl9lbnRlcmFibGUgPSBlbnRlcmFibGU7XG4gIH0sXG4gIGdldFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHJldHVybiBbZWwuY2xpZW50V2lkdGgsIGVsLmNsaWVudEhlaWdodF07XG4gIH0sXG4gIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAvLyB4eSBzaG91bGQgYmUgYmFzZWQgb24gY2FudmFzIHJvb3QuIEJ1dCB0b29sdGlwQ29udGVudCBpc1xuICAgIC8vIHRoZSBzaWJsaW5nIG9mIGNhbnZhcyByb290LiBTbyBwYWRkaW5nIG9mIGVjIGNvbnRhaW5lclxuICAgIC8vIHNob3VsZCBiZSBjb25zaWRlcmVkIGhlcmUuXG4gICAgdmFyIHpyID0gdGhpcy5fenI7XG4gICAgdmFyIHZpZXdwb3J0Um9vdE9mZnNldDtcblxuICAgIGlmICh6ciAmJiB6ci5wYWludGVyICYmICh2aWV3cG9ydFJvb3RPZmZzZXQgPSB6ci5wYWludGVyLmdldFZpZXdwb3J0Um9vdE9mZnNldCgpKSkge1xuICAgICAgeCArPSB2aWV3cG9ydFJvb3RPZmZzZXQub2Zmc2V0TGVmdDtcbiAgICAgIHkgKz0gdmlld3BvcnRSb290T2Zmc2V0Lm9mZnNldFRvcDtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xuICAgIHN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICBzdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgfSxcbiAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gIH0sXG4gIGhpZGVMYXRlcjogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICBpZiAodGhpcy5fc2hvdyAmJiAhKHRoaXMuX2luQ29udGVudCAmJiB0aGlzLl9lbnRlcmFibGUpKSB7XG4gICAgICBpZiAodGltZSkge1xuICAgICAgICB0aGlzLl9oaWRlRGVsYXkgPSB0aW1lOyAvLyBTZXQgc2hvdyBmYWxzZSB0byBhdm9pZCBpbnZva2UgaGlkZUxhdGVyIG11dGlwbGUgdGltZXNcblxuICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0ID0gc2V0VGltZW91dCh6clV0aWwuYmluZCh0aGlzLmhpZGUsIHRoaXMpLCB0aW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaXNTaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nob3c7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBUb29sdGlwQ29udGVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcENvbnRlbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9kZWZhdWx0ID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICd0b29sdGlwJyxcbiAgZGVwZW5kZW5jaWVzOiBbJ2F4aXNQb2ludGVyJ10sXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogOCxcbiAgICBzaG93OiB0cnVlLFxuICAgIC8vIHRvb2x0aXDkuLvkvZPlhoXlrrlcbiAgICBzaG93Q29udGVudDogdHJ1ZSxcbiAgICAvLyAndHJpZ2dlcicgb25seSB3b3JrcyBvbiBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAvLyAnaXRlbScgfCAnYXhpcycgfCAnbm9uZSdcbiAgICB0cmlnZ2VyOiAnaXRlbScsXG4gICAgLy8gJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ25vbmUnXG4gICAgdHJpZ2dlck9uOiAnbW91c2Vtb3ZlfGNsaWNrJyxcbiAgICBhbHdheXNTaG93Q29udGVudDogZmFsc2UsXG4gICAgZGlzcGxheU1vZGU6ICdzaW5nbGUnLFxuICAgIC8vICdzaW5nbGUnIHwgJ211bHRpcGxlQnlDb29yZFN5cydcbiAgICAvLyDkvY3nva4ge0FycmF5fSB8IHtGdW5jdGlvbn1cbiAgICAvLyBwb3NpdGlvbjogbnVsbFxuICAgIC8vIENvbnNpZGVyIHRyaWdnZXJlZCBmcm9tIGF4aXNQb2ludGVyIGhhbmRsZSwgdmVydGljYWxBbGlnbiBzaG91bGQgYmUgJ21pZGRsZSdcbiAgICAvLyBhbGlnbjogbnVsbCxcbiAgICAvLyB2ZXJ0aWNhbEFsaWduOiBudWxsLFxuICAgIC8vIOaYr+WQpue6puadnyBjb250ZW50IOWcqCB2aWV3UmVjdCDkuK3jgILpu5jorqQgZmFsc2Ug5piv5Li65LqG5YW85a655Lul5YmN54mI5pys44CCXG4gICAgY29uZmluZTogZmFsc2UsXG4gICAgLy8g5YaF5a655qC85byP5Zmo77yae3N0cmluZ33vvIhUZW1wbGF0Ze+8iSDCpiB7RnVuY3Rpb259XG4gICAgLy8gZm9ybWF0dGVyOiBudWxsXG4gICAgc2hvd0RlbGF5OiAwLFxuICAgIC8vIOmakOiXj+W7tui/n++8jOWNleS9jW1zXG4gICAgaGlkZURlbGF5OiAxMDAsXG4gICAgLy8g5Yqo55S75Y+Y5o2i5pe26Ze077yM5Y2V5L2Nc1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMC40LFxuICAgIGVudGVyYWJsZTogZmFsc2UsXG4gICAgLy8g5o+Q56S66IOM5pmv6aKc6Imy77yM6buY6K6k5Li66YCP5piO5bqm5Li6MC4355qE6buR6ImyXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg1MCw1MCw1MCwwLjcpJyxcbiAgICAvLyDmj5DnpLrovrnmoYbpopzoibJcbiAgICBib3JkZXJDb2xvcjogJyMzMzMnLFxuICAgIC8vIOaPkOekuui+ueahhuWchuinku+8jOWNleS9jXB477yM6buY6K6k5Li6NFxuICAgIGJvcmRlclJhZGl1czogNCxcbiAgICAvLyDmj5DnpLrovrnmoYbnur/lrr3vvIzljZXkvY1weO+8jOm7mOiupOS4ujDvvIjml6DovrnmoYbvvIlcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICAvLyDmj5DnpLrlhoXovrnot53vvIzljZXkvY1weO+8jOm7mOiupOWQhOaWueWQkeWGhei+uei3neS4ujXvvIxcbiAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcbiAgICBwYWRkaW5nOiA1LFxuICAgIC8vIEV4dHJhIGNzcyB0ZXh0XG4gICAgZXh0cmFDc3NUZXh0OiAnJyxcbiAgICAvLyDlnZDmoIfovbTmjIfnpLrlmajvvIzlnZDmoIfovbTop6blj5HmnInmlYhcbiAgICBheGlzUG9pbnRlcjoge1xuICAgICAgLy8g6buY6K6k5Li655u057q/XG4gICAgICAvLyDlj6/pgInkuLrvvJonbGluZScgfCAnc2hhZG93JyB8ICdjcm9zcydcbiAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgIC8vIHR5cGUg5Li6IGxpbmUg55qE5pe25YCZ5pyJ5pWI77yM5oyH5a6aIHRvb2x0aXAgbGluZSDmiYDlnKjnmoTovbTvvIzlj6/pgIlcbiAgICAgIC8vIOWPr+mAiSAneCcgfCAneScgfCAnYW5nbGUnIHwgJ3JhZGl1cycgfCAnYXV0bydcbiAgICAgIC8vIOm7mOiupCAnYXV0byfvvIzkvJrpgInmi6nnsbvlnovkuLogY2F0ZWdvcnkg55qE6L2077yM5a+55LqO5Y+M5pWw5YC86L2077yM56yb5Y2h5bCU5Z2Q5qCH57O75Lya6buY6K6k6YCJ5oupIHgg6L20XG4gICAgICAvLyDmnoHlnZDmoIfns7vkvJrpu5jorqTpgInmi6kgYW5nbGUg6L20XG4gICAgICBheGlzOiAnYXV0bycsXG4gICAgICBhbmltYXRpb246ICdhdXRvJyxcbiAgICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAyMDAsXG4gICAgICBhbmltYXRpb25FYXNpbmdVcGRhdGU6ICdleHBvbmVudGlhbE91dCcsXG4gICAgICBjcm9zc1N0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzk5OScsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICB0eXBlOiAnZGFzaGVkJyxcbiAgICAgICAgLy8gVE9ETyBmb3JtYXR0ZXJcbiAgICAgICAgdGV4dFN0eWxlOiB7fSAvLyBsaW5lU3R5bGUgYW5kIHNoYWRvd1N0eWxlIHNob3VsZCBub3QgYmUgc3BlY2lmaWVkIGhlcmUsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCB3aWxsIGFsd2F5cyBvdmVycmlkZSB0aG9zZSBzdHlsZXMgb24gb3B0aW9uLmF4aXNQb2ludGVyLlxuXG4gICAgICB9XG4gICAgfSxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBmb250U2l6ZTogMTRcbiAgICB9XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBUb29sdGlwQ29udGVudCA9IHJlcXVpcmUoXCIuL1Rvb2x0aXBDb250ZW50XCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIGZpbmRQb2ludEZyb21TZXJpZXMgPSByZXF1aXJlKFwiLi4vYXhpc1BvaW50ZXIvZmluZFBvaW50RnJvbVNlcmllc1wiKTtcblxudmFyIGxheW91dFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIGdsb2JhbExpc3RlbmVyID0gcmVxdWlyZShcIi4uL2F4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyXCIpO1xuXG52YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoXCIuLi8uLi9jb29yZC9heGlzSGVscGVyXCIpO1xuXG52YXIgYXhpc1BvaW50ZXJWaWV3SGVscGVyID0gcmVxdWlyZShcIi4uL2F4aXNQb2ludGVyL3ZpZXdIZWxwZXJcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBiaW5kID0genJVdGlsLmJpbmQ7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIHBhcnNlUGVyY2VudCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50O1xudmFyIHByb3h5UmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICBzaGFwZToge1xuICAgIHg6IC0xLFxuICAgIHk6IC0xLFxuICAgIHdpZHRoOiAyLFxuICAgIGhlaWdodDogMlxuICB9XG59KTtcblxudmFyIF9kZWZhdWx0ID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ3Rvb2x0aXAnLFxuICBpbml0OiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvb2x0aXBDb250ZW50ID0gbmV3IFRvb2x0aXBDb250ZW50KGFwaS5nZXREb20oKSwgYXBpKTtcbiAgICB0aGlzLl90b29sdGlwQ29udGVudCA9IHRvb2x0aXBDb250ZW50O1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIGlmIChlbnYubm9kZSB8fCBlbnYud3hhKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBSZXNldFxuXG5cbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbH1cbiAgICAgKi9cblxuICAgIHRoaXMuX3Rvb2x0aXBNb2RlbCA9IHRvb2x0aXBNb2RlbDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICovXG5cbiAgICB0aGlzLl9lY01vZGVsID0gZWNNb2RlbDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gICAgICovXG5cbiAgICB0aGlzLl9hcGkgPSBhcGk7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIGJlIGNsZWFuZWQgd2hlbiByZW5kZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5LjxPYmplY3Q+Pn1cbiAgICAgKi9cblxuICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICAgIHRoaXMuX2Fsd2F5c1Nob3dDb250ZW50ID0gdG9vbHRpcE1vZGVsLmdldCgnYWx3YXlzU2hvd0NvbnRlbnQnKTtcbiAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcbiAgICB0b29sdGlwQ29udGVudC51cGRhdGUoKTtcbiAgICB0b29sdGlwQ29udGVudC5zZXRFbnRlcmFibGUodG9vbHRpcE1vZGVsLmdldCgnZW50ZXJhYmxlJykpO1xuXG4gICAgdGhpcy5faW5pdEdsb2JhbExpc3RlbmVyKCk7XG5cbiAgICB0aGlzLl9rZWVwU2hvdygpO1xuICB9LFxuICBfaW5pdEdsb2JhbExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcbiAgICB2YXIgdHJpZ2dlck9uID0gdG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlck9uJyk7XG4gICAgZ2xvYmFsTGlzdGVuZXIucmVnaXN0ZXIoJ2l0ZW1Ub29sdGlwJywgdGhpcy5fYXBpLCBiaW5kKGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgIC8vIElmICdub25lJywgaXQgaXMgbm90IGNvbnRyb2xsZWQgYnkgbW91c2UgdG90YWxseS5cbiAgICAgIGlmICh0cmlnZ2VyT24gIT09ICdub25lJykge1xuICAgICAgICBpZiAodHJpZ2dlck9uLmluZGV4T2YoY3VyclRyaWdnZXIpID49IDApIHtcbiAgICAgICAgICB0aGlzLl90cnlTaG93KGUsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJykge1xuICAgICAgICAgIHRoaXMuX2hpZGUoZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcykpO1xuICB9LFxuICBfa2VlcFNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICB2YXIgYXBpID0gdGhpcy5fYXBpOyAvLyBUcnkgdG8ga2VlcCB0aGUgdG9vbHRpcCBzaG93IHdoZW4gcmVmcmVzaGluZ1xuXG4gICAgaWYgKHRoaXMuX2xhc3RYICE9IG51bGwgJiYgdGhpcy5fbGFzdFkgIT0gbnVsbCAvLyBXaGVuIHVzZXIgaXMgd2lsbGluZyB0byBjb250cm9sIHRvb2x0aXAgdG90YWxseSB1c2luZyBBUEksXG4gICAgLy8gc2VsZi5tYW51YWxseVNob3dUaXAoe3gsIHl9KSBtaWdodCBjYXVzZSB0b29sdGlwIGhpZGUsXG4gICAgLy8gd2hpY2ggaXMgbm90IGV4cGVjdGVkLlxuICAgICYmIHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXJPbicpICE9PSAnbm9uZScpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoVXBkYXRlVGltZW91dCk7XG4gICAgICB0aGlzLl9yZWZyZXNoVXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTaG93IHRpcCBuZXh0IHRpY2sgYWZ0ZXIgb3RoZXIgY2hhcnRzIGFyZSByZW5kZXJlZFxuICAgICAgICAvLyBJbiBjYXNlIGhpZ2hsaWdodCBhY3Rpb24gaGFzIHdyb25nIHJlc3VsdFxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICBzZWxmLm1hbnVhbGx5U2hvd1RpcCh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwge1xuICAgICAgICAgIHg6IHNlbGYuX2xhc3RYLFxuICAgICAgICAgIHk6IHNlbGYuX2xhc3RZXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaG93IHRpcCBtYW51YWxseSBieVxuICAgKiBkaXNwYXRjaEFjdGlvbih7XG4gICAqICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAqICAgICB4OiAxMCxcbiAgICogICAgIHk6IDEwXG4gICAqIH0pO1xuICAgKiBPclxuICAgKiBkaXNwYXRjaEFjdGlvbih7XG4gICAqICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgKiAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgKiAgICAgIGRhdGFJbmRleCBvciBkYXRhSW5kZXhJbnNpZGUgb3IgbmFtZVxuICAgKiB9KTtcbiAgICpcbiAgICogIFRPRE8gQmF0Y2hcbiAgICovXG4gIG1hbnVhbGx5U2hvd1RpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgaWYgKHBheWxvYWQuZnJvbSA9PT0gdGhpcy51aWQgfHwgZW52Lm5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGlzcGF0Y2hBY3Rpb24gPSBtYWtlRGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCwgYXBpKTsgLy8gUmVzZXQgdGlja2V0XG5cbiAgICB0aGlzLl90aWNrZXQgPSAnJzsgLy8gV2hlbiB0cmlnZ2VyZWQgZnJvbSBheGlzUG9pbnRlci5cblxuICAgIHZhciBkYXRhQnlDb29yZFN5cyA9IHBheWxvYWQuZGF0YUJ5Q29vcmRTeXM7XG5cbiAgICBpZiAocGF5bG9hZC50b29sdGlwICYmIHBheWxvYWQueCAhPSBudWxsICYmIHBheWxvYWQueSAhPSBudWxsKSB7XG4gICAgICB2YXIgZWwgPSBwcm94eVJlY3Q7XG4gICAgICBlbC5wb3NpdGlvbiA9IFtwYXlsb2FkLngsIHBheWxvYWQueV07XG4gICAgICBlbC51cGRhdGUoKTtcbiAgICAgIGVsLnRvb2x0aXAgPSBwYXlsb2FkLnRvb2x0aXA7IC8vIE1hbnVhbGx5IHNob3cgdG9vbHRpcCB3aGlsZSB2aWV3IGlzIG5vdCB1c2luZyB6cmVuZGVyIGVsZW1lbnRzLlxuXG4gICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgb2Zmc2V0WDogcGF5bG9hZC54LFxuICAgICAgICBvZmZzZXRZOiBwYXlsb2FkLnksXG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGRhdGFCeUNvb3JkU3lzKSB7XG4gICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgb2Zmc2V0WDogcGF5bG9hZC54LFxuICAgICAgICBvZmZzZXRZOiBwYXlsb2FkLnksXG4gICAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uLFxuICAgICAgICBldmVudDoge30sXG4gICAgICAgIGRhdGFCeUNvb3JkU3lzOiBwYXlsb2FkLmRhdGFCeUNvb3JkU3lzLFxuICAgICAgICB0b29sdGlwT3B0aW9uOiBwYXlsb2FkLnRvb2x0aXBPcHRpb25cbiAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWQuc2VyaWVzSW5kZXggIT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuX21hbnVhbGx5QXhpc1Nob3dUaXAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50SW5mbyA9IGZpbmRQb2ludEZyb21TZXJpZXMocGF5bG9hZCwgZWNNb2RlbCk7XG4gICAgICB2YXIgY3ggPSBwb2ludEluZm8ucG9pbnRbMF07XG4gICAgICB2YXIgY3kgPSBwb2ludEluZm8ucG9pbnRbMV07XG5cbiAgICAgIGlmIChjeCAhPSBudWxsICYmIGN5ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgb2Zmc2V0WDogY3gsXG4gICAgICAgICAgb2Zmc2V0WTogY3ksXG4gICAgICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgICAgICAgdGFyZ2V0OiBwb2ludEluZm8uZWwsXG4gICAgICAgICAgZXZlbnQ6IHt9XG4gICAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBheWxvYWQueCAhPSBudWxsICYmIHBheWxvYWQueSAhPSBudWxsKSB7XG4gICAgICAvLyBGSVhNRVxuICAgICAgLy8gc2hvdWxkIHdyYXAgZGlzcGF0Y2hBY3Rpb24gbGlrZSBgYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXJgID9cbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gICAgICAgIHg6IHBheWxvYWQueCxcbiAgICAgICAgeTogcGF5bG9hZC55XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgIG9mZnNldFg6IHBheWxvYWQueCxcbiAgICAgICAgb2Zmc2V0WTogcGF5bG9hZC55LFxuICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiBhcGkuZ2V0WnIoKS5maW5kSG92ZXIocGF5bG9hZC54LCBwYXlsb2FkLnkpLnRhcmdldCxcbiAgICAgICAgZXZlbnQ6IHt9XG4gICAgICB9LCBkaXNwYXRjaEFjdGlvbik7XG4gICAgfVxuICB9LFxuICBtYW51YWxseUhpZGVUaXA6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xuXG4gICAgaWYgKCF0aGlzLl9hbHdheXNTaG93Q29udGVudCAmJiB0aGlzLl90b29sdGlwTW9kZWwpIHtcbiAgICAgIHRvb2x0aXBDb250ZW50LmhpZGVMYXRlcih0aGlzLl90b29sdGlwTW9kZWwuZ2V0KCdoaWRlRGVsYXknKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdFggPSB0aGlzLl9sYXN0WSA9IG51bGw7XG5cbiAgICBpZiAocGF5bG9hZC5mcm9tICE9PSB0aGlzLnVpZCkge1xuICAgICAgdGhpcy5faGlkZShtYWtlRGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCwgYXBpKSk7XG4gICAgfVxuICB9LFxuICAvLyBCZSBjb21wYXRpYmxlIHdpdGggcHJldmlvdXMgZGVzaWduLCB0aGF0IGlzLCB3aGVuIHRvb2x0aXAudHlwZSBpcyAnYXhpcycgYW5kXG4gIC8vIGRpc3BhdGNoQWN0aW9uICdzaG93VGlwJyB3aXRoIHNlcmllc0luZGV4IGFuZCBkYXRhSW5kZXggd2lsbCB0cmlnZ2VyIGF4aXMgcG9pbnRlclxuICAvLyBhbmQgdG9vbHRpcC5cbiAgX21hbnVhbGx5QXhpc1Nob3dUaXA6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBzZXJpZXNJbmRleCA9IHBheWxvYWQuc2VyaWVzSW5kZXg7XG4gICAgdmFyIGRhdGFJbmRleCA9IHBheWxvYWQuZGF0YUluZGV4O1xuICAgIHZhciBjb29yZFN5c0F4ZXNJbmZvID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ2F4aXNQb2ludGVyJykuY29vcmRTeXNBeGVzSW5mbztcblxuICAgIGlmIChzZXJpZXNJbmRleCA9PSBudWxsIHx8IGRhdGFJbmRleCA9PSBudWxsIHx8IGNvb3JkU3lzQXhlc0luZm8gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCk7XG5cbiAgICBpZiAoIXNlcmllc01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpLCBzZXJpZXNNb2RlbCwgKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gfHwge30pLm1vZGVsLCB0b29sdGlwTW9kZWxdKTtcblxuICAgIGlmICh0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJykgIT09ICdheGlzJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvblxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBfdHJ5U2hvdzogZnVuY3Rpb24gKGUsIGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcblxuICAgIGlmICghdG9vbHRpcE1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTYXZlIG1vdXNlIHgsIG1vdXNlIHkuIFNvIHdlIGNhbiB0cnkgdG8ga2VlcCBzaG93aW5nIHRoZSB0aXAgaWYgY2hhcnQgaXMgcmVmcmVzaGVkXG5cblxuICAgIHRoaXMuX2xhc3RYID0gZS5vZmZzZXRYO1xuICAgIHRoaXMuX2xhc3RZID0gZS5vZmZzZXRZO1xuICAgIHZhciBkYXRhQnlDb29yZFN5cyA9IGUuZGF0YUJ5Q29vcmRTeXM7XG5cbiAgICBpZiAoZGF0YUJ5Q29vcmRTeXMgJiYgZGF0YUJ5Q29vcmRTeXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zaG93QXhpc1Rvb2x0aXAoZGF0YUJ5Q29vcmRTeXMsIGUpO1xuICAgIH0gLy8gQWx3YXlzIHNob3cgaXRlbSB0b29sdGlwIGlmIG1vdXNlIGlzIG9uIHRoZSBlbGVtZW50IHdpdGggZGF0YUluZGV4XG4gICAgZWxzZSBpZiAoZWwgJiYgZWwuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zaG93U2VyaWVzSXRlbVRvb2x0aXAoZSwgZWwsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgIH0gLy8gVG9vbHRpcCBwcm92aWRlZCBkaXJlY3RseS4gTGlrZSBsZWdlbmQuXG4gICAgICBlbHNlIGlmIChlbCAmJiBlbC50b29sdGlwKSB7XG4gICAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcblxuICAgICAgICAgIHRoaXMuX3Nob3dDb21wb25lbnRJdGVtVG9vbHRpcChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG5cbiAgICAgICAgICB0aGlzLl9oaWRlKGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgfVxuICB9LFxuICBfc2hvd09yTW92ZTogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgY2IpIHtcbiAgICAvLyBzaG93RGVsYXkgaXMgdXNlZCBpbiB0aGlzIGNhc2U6IHRvb2x0aXAuZW50ZXJhYmxlIGlzIHNldFxuICAgIC8vIGFzIHRydWUuIFVzZXIgaW50ZW50IHRvIG1vdmUgbW91c2UgaW50byB0b29sdGlwIGFuZCBjbGlja1xuICAgIC8vIHNvbWV0aGluZy4gYHNob3dEZWxheWAgbWFrZXMgaXQgZWFzeWVyIHRvIGVudGVyIHRoZSBjb250ZW50XG4gICAgLy8gYnV0IHRvb2x0aXAgZG8gbm90IG1vdmUgaW1tZWRpYXRlbHkuXG4gICAgdmFyIGRlbGF5ID0gdG9vbHRpcE1vZGVsLmdldCgnc2hvd0RlbGF5Jyk7XG4gICAgY2IgPSB6clV0aWwuYmluZChjYiwgdGhpcyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1vdXQpO1xuICAgIGRlbGF5ID4gMCA/IHRoaXMuX3Nob3dUaW1vdXQgPSBzZXRUaW1lb3V0KGNiLCBkZWxheSkgOiBjYigpO1xuICB9LFxuICBfc2hvd0F4aXNUb29sdGlwOiBmdW5jdGlvbiAoZGF0YUJ5Q29vcmRTeXMsIGUpIHtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX2VjTW9kZWw7XG4gICAgdmFyIGdsb2JhbFRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcbiAgICB2YXIgcG9pbnQgPSBbZS5vZmZzZXRYLCBlLm9mZnNldFldO1xuICAgIHZhciBzaW5nbGVEZWZhdWx0SFRNTCA9IFtdO1xuICAgIHZhciBzaW5nbGVQYXJhbXNMaXN0ID0gW107XG4gICAgdmFyIHNpbmdsZVRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtlLnRvb2x0aXBPcHRpb24sIGdsb2JhbFRvb2x0aXBNb2RlbF0pO1xuICAgIGVhY2goZGF0YUJ5Q29vcmRTeXMsIGZ1bmN0aW9uIChpdGVtQ29vcmRTeXMpIHtcbiAgICAgIC8vIHZhciBjb29yZFBhcmFtTGlzdCA9IFtdO1xuICAgICAgLy8gdmFyIGNvb3JkRGVmYXVsdEhUTUwgPSBbXTtcbiAgICAgIC8vIHZhciBjb29yZFRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtcbiAgICAgIC8vICAgICBlLnRvb2x0aXBPcHRpb24sXG4gICAgICAvLyAgICAgaXRlbUNvb3JkU3lzLnRvb2x0aXBPcHRpb24sXG4gICAgICAvLyAgICAgZWNNb2RlbC5nZXRDb21wb25lbnQoaXRlbUNvb3JkU3lzLmNvb3JkU3lzTWFpblR5cGUsIGl0ZW1Db29yZFN5cy5jb29yZFN5c0luZGV4KSxcbiAgICAgIC8vICAgICBnbG9iYWxUb29sdGlwTW9kZWxcbiAgICAgIC8vIF0pO1xuICAgICAgLy8gdmFyIGRpc3BsYXlNb2RlID0gY29vcmRUb29sdGlwTW9kZWwuZ2V0KCdkaXNwbGF5TW9kZScpO1xuICAgICAgLy8gdmFyIHBhcmFtc0xpc3QgPSBkaXNwbGF5TW9kZSA9PT0gJ3NpbmdsZScgPyBzaW5nbGVQYXJhbXNMaXN0IDogW107XG4gICAgICBlYWNoKGl0ZW1Db29yZFN5cy5kYXRhQnlBeGlzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoaXRlbS5heGlzRGltICsgJ0F4aXMnLCBpdGVtLmF4aXNJbmRleCk7XG4gICAgICAgIHZhciBheGlzVmFsdWUgPSBpdGVtLnZhbHVlO1xuICAgICAgICB2YXIgc2VyaWVzRGVmYXVsdEhUTUwgPSBbXTtcblxuICAgICAgICBpZiAoIWF4aXNNb2RlbCB8fCBheGlzVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZUxhYmVsID0gYXhpc1BvaW50ZXJWaWV3SGVscGVyLmdldFZhbHVlTGFiZWwoYXhpc1ZhbHVlLCBheGlzTW9kZWwuYXhpcywgZWNNb2RlbCwgaXRlbS5zZXJpZXNEYXRhSW5kaWNlcywgaXRlbS52YWx1ZUxhYmVsT3B0KTtcbiAgICAgICAgenJVdGlsLmVhY2goaXRlbS5zZXJpZXNEYXRhSW5kaWNlcywgZnVuY3Rpb24gKGlkeEl0ZW0pIHtcbiAgICAgICAgICB2YXIgc2VyaWVzID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KGlkeEl0ZW0uc2VyaWVzSW5kZXgpO1xuICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBpZHhJdGVtLmRhdGFJbmRleEluc2lkZTtcbiAgICAgICAgICB2YXIgZGF0YVBhcmFtcyA9IHNlcmllcyAmJiBzZXJpZXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgpO1xuICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc0RpbSA9IGl0ZW0uYXhpc0RpbTtcbiAgICAgICAgICBkYXRhUGFyYW1zLmF4aXNJbmRleCA9IGl0ZW0uYXhpc0luZGV4O1xuICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc1R5cGUgPSBpdGVtLmF4aXNUeXBlO1xuICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc0lkID0gaXRlbS5heGlzSWQ7XG4gICAgICAgICAgZGF0YVBhcmFtcy5heGlzVmFsdWUgPSBheGlzSGVscGVyLmdldEF4aXNSYXdWYWx1ZShheGlzTW9kZWwuYXhpcywgYXhpc1ZhbHVlKTtcbiAgICAgICAgICBkYXRhUGFyYW1zLmF4aXNWYWx1ZUxhYmVsID0gdmFsdWVMYWJlbDtcblxuICAgICAgICAgIGlmIChkYXRhUGFyYW1zKSB7XG4gICAgICAgICAgICBzaW5nbGVQYXJhbXNMaXN0LnB1c2goZGF0YVBhcmFtcyk7XG4gICAgICAgICAgICBzZXJpZXNEZWZhdWx0SFRNTC5wdXNoKHNlcmllcy5mb3JtYXRUb29sdGlwKGRhdGFJbmRleCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIERlZmF1bHQgdG9vbHRpcCBjb250ZW50XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vICgxKSBzaG9sZCBiZSB0aGUgZmlyc3QgZGF0YSB3aGljaCBoYXMgbmFtZT9cbiAgICAgICAgLy8gKDIpIHRoZW1lUml2ZXIsIGZpcnN0RGF0YUluZGV4IGlzIGFycmF5LCBhbmQgZmlyc3QgbGluZSBpcyB1bm5lY2Vzc2FyeS5cblxuICAgICAgICB2YXIgZmlyc3RMaW5lID0gdmFsdWVMYWJlbDtcbiAgICAgICAgc2luZ2xlRGVmYXVsdEhUTUwucHVzaCgoZmlyc3RMaW5lID8gZm9ybWF0VXRpbC5lbmNvZGVIVE1MKGZpcnN0TGluZSkgKyAnPGJyIC8+JyA6ICcnKSArIHNlcmllc0RlZmF1bHRIVE1MLmpvaW4oJzxiciAvPicpKTtcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpOyAvLyBJbiBtb3N0IGNhc2UsIHRoZSBzZWNvbmQgYXhpcyBpcyBzaG93biB1cHBlciB0aGFuIHRoZSBmaXJzdCBvbmUuXG5cbiAgICBzaW5nbGVEZWZhdWx0SFRNTC5yZXZlcnNlKCk7XG4gICAgc2luZ2xlRGVmYXVsdEhUTUwgPSBzaW5nbGVEZWZhdWx0SFRNTC5qb2luKCc8YnIgLz48YnIgLz4nKTtcbiAgICB2YXIgcG9zaXRpb25FeHByID0gZS5wb3NpdGlvbjtcblxuICAgIHRoaXMuX3Nob3dPck1vdmUoc2luZ2xlVG9vbHRpcE1vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fdXBkYXRlQ29udGVudE5vdENoYW5nZWRPbkF4aXMoZGF0YUJ5Q29vcmRTeXMpKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHNpbmdsZVRvb2x0aXBNb2RlbCwgcG9zaXRpb25FeHByLCBwb2ludFswXSwgcG9pbnRbMV0sIHRoaXMuX3Rvb2x0aXBDb250ZW50LCBzaW5nbGVQYXJhbXNMaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudChzaW5nbGVUb29sdGlwTW9kZWwsIHNpbmdsZURlZmF1bHRIVE1MLCBzaW5nbGVQYXJhbXNMaXN0LCBNYXRoLnJhbmRvbSgpLCBwb2ludFswXSwgcG9pbnRbMV0sIHBvc2l0aW9uRXhwcik7XG4gICAgICB9XG4gICAgfSk7IC8vIERvIG5vdCB0cmlnZ2VyIGV2ZW50cyBoZXJlLCBiZWNhdXNlIHRoaXMgYnJhbmNoIG9ubHkgYmUgZW50ZXJlZFxuICAgIC8vIGZyb20gZGlzcGF0Y2hBY3Rpb24uXG5cbiAgfSxcbiAgX3Nob3dTZXJpZXNJdGVtVG9vbHRpcDogZnVuY3Rpb24gKGUsIGVsLCBkaXNwYXRjaEFjdGlvbikge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDsgLy8gVXNlIGRhdGFNb2RlbCBpbiBlbGVtZW50IGlmIHBvc3NpYmxlXG4gICAgLy8gVXNlZCB3aGVuIG1vdXNlb3ZlciBvbiBhIGVsZW1lbnQgbGlrZSBtYXJrUG9pbnQgb3IgZWRnZVxuICAgIC8vIEluIHdoaWNoIGNhc2UsIHRoZSBkYXRhIGlzIG5vdCBtYWluIGRhdGEgaW4gc2VyaWVzLlxuXG4gICAgdmFyIHNlcmllc0luZGV4ID0gZWwuc2VyaWVzSW5kZXg7XG4gICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KHNlcmllc0luZGV4KTsgLy8gRm9yIGV4YW1wbGUsIGdyYXBoIGxpbmsuXG5cbiAgICB2YXIgZGF0YU1vZGVsID0gZWwuZGF0YU1vZGVsIHx8IHNlcmllc01vZGVsO1xuICAgIHZhciBkYXRhSW5kZXggPSBlbC5kYXRhSW5kZXg7XG4gICAgdmFyIGRhdGFUeXBlID0gZWwuZGF0YVR5cGU7XG4gICAgdmFyIGRhdGEgPSBkYXRhTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciB0b29sdGlwTW9kZWwgPSBidWlsZFRvb2x0aXBNb2RlbChbZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KSwgZGF0YU1vZGVsLCBzZXJpZXNNb2RlbCAmJiAoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSB8fCB7fSkubW9kZWwsIHRoaXMuX3Rvb2x0aXBNb2RlbF0pO1xuICAgIHZhciB0b29sdGlwVHJpZ2dlciA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKTtcblxuICAgIGlmICh0b29sdGlwVHJpZ2dlciAhPSBudWxsICYmIHRvb2x0aXBUcmlnZ2VyICE9PSAnaXRlbScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gZGF0YU1vZGVsLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgdmFyIGRlZmF1bHRIdG1sID0gZGF0YU1vZGVsLmZvcm1hdFRvb2x0aXAoZGF0YUluZGV4LCBmYWxzZSwgZGF0YVR5cGUpO1xuICAgIHZhciBhc3luY1RpY2tldCA9ICdpdGVtXycgKyBkYXRhTW9kZWwubmFtZSArICdfJyArIGRhdGFJbmRleDtcblxuICAgIHRoaXMuX3Nob3dPck1vdmUodG9vbHRpcE1vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zaG93VG9vbHRpcENvbnRlbnQodG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgcGFyYW1zLCBhc3luY1RpY2tldCwgZS5vZmZzZXRYLCBlLm9mZnNldFksIGUucG9zaXRpb24sIGUudGFyZ2V0KTtcbiAgICB9KTsgLy8gRklYTUVcbiAgICAvLyBkdXBsaWNhdGVkIHNob3d0aXAgaWYgbWFudWFsbHlTaG93VGlwIGlzIGNhbGxlZCBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuXG5cbiAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICBkYXRhSW5kZXhJbnNpZGU6IGRhdGFJbmRleCxcbiAgICAgIGRhdGFJbmRleDogZGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpLFxuICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgZnJvbTogdGhpcy51aWRcbiAgICB9KTtcbiAgfSxcbiAgX3Nob3dDb21wb25lbnRJdGVtVG9vbHRpcDogZnVuY3Rpb24gKGUsIGVsLCBkaXNwYXRjaEFjdGlvbikge1xuICAgIHZhciB0b29sdGlwT3B0ID0gZWwudG9vbHRpcDtcblxuICAgIGlmICh0eXBlb2YgdG9vbHRpcE9wdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBjb250ZW50ID0gdG9vbHRpcE9wdDtcbiAgICAgIHRvb2x0aXBPcHQgPSB7XG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgIC8vIEZpeGVkIGZvcm1hdHRlclxuICAgICAgICBmb3JtYXR0ZXI6IGNvbnRlbnRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHN1YlRvb2x0aXBNb2RlbCA9IG5ldyBNb2RlbCh0b29sdGlwT3B0LCB0aGlzLl90b29sdGlwTW9kZWwsIHRoaXMuX2VjTW9kZWwpO1xuICAgIHZhciBkZWZhdWx0SHRtbCA9IHN1YlRvb2x0aXBNb2RlbC5nZXQoJ2NvbnRlbnQnKTtcbiAgICB2YXIgYXN5bmNUaWNrZXQgPSBNYXRoLnJhbmRvbSgpOyAvLyBEbyBub3QgY2hlY2sgd2hldGhlciBgdHJpZ2dlcmAgaXMgJ25vbmUnIGhlcmUsIGJlY2F1c2UgYHRyaWdnZXJgXG4gICAgLy8gb25seSB3b3JrcyBvbiBjb29yaWRpbmF0ZSBzeXN0ZW0uIEluIGZhY3QsIHdlIGhhdmUgbm90IGZvdW5kIGNhc2VcbiAgICAvLyB0aGF0IHJlcXVpcmVzIHNldHRpbmcgYHRyaWdnZXJgIG5vdGhpbmcgb24gY29tcG9uZW50IHlldC5cblxuICAgIHRoaXMuX3Nob3dPck1vdmUoc3ViVG9vbHRpcE1vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zaG93VG9vbHRpcENvbnRlbnQoc3ViVG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgc3ViVG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyUGFyYW1zJykgfHwge30sIGFzeW5jVGlja2V0LCBlLm9mZnNldFgsIGUub2Zmc2V0WSwgZS5wb3NpdGlvbiwgZWwpO1xuICAgIH0pOyAvLyBJZiBub3QgZGlzcGF0Y2ggc2hvd1RpcCwgdGlwIG1heSBiZSBoaWRlIHRyaWdnZXJlZCBieSBheGlzLlxuXG5cbiAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICBmcm9tOiB0aGlzLnVpZFxuICAgIH0pO1xuICB9LFxuICBfc2hvd1Rvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgcGFyYW1zLCBhc3luY1RpY2tldCwgeCwgeSwgcG9zaXRpb25FeHByLCBlbCkge1xuICAgIC8vIFJlc2V0IHRpY2tldFxuICAgIHRoaXMuX3RpY2tldCA9ICcnO1xuXG4gICAgaWYgKCF0b29sdGlwTW9kZWwuZ2V0KCdzaG93Q29udGVudCcpIHx8ICF0b29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcbiAgICB2YXIgZm9ybWF0dGVyID0gdG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByIHx8IHRvb2x0aXBNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgdmFyIGh0bWwgPSBkZWZhdWx0SHRtbDtcblxuICAgIGlmIChmb3JtYXR0ZXIgJiYgdHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGh0bWwgPSBmb3JtYXRVdGlsLmZvcm1hdFRwbChmb3JtYXR0ZXIsIHBhcmFtcywgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBiaW5kKGZ1bmN0aW9uIChjYlRpY2tldCwgaHRtbCkge1xuICAgICAgICBpZiAoY2JUaWNrZXQgPT09IHRoaXMuX3RpY2tldCkge1xuICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCk7XG5cbiAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbih0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgdG9vbHRpcENvbnRlbnQsIHBhcmFtcywgZWwpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMuX3RpY2tldCA9IGFzeW5jVGlja2V0O1xuICAgICAgaHRtbCA9IGZvcm1hdHRlcihwYXJhbXMsIGFzeW5jVGlja2V0LCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdG9vbHRpcENvbnRlbnQuc2V0Q29udGVudChodG1sKTtcbiAgICB0b29sdGlwQ29udGVudC5zaG93KHRvb2x0aXBNb2RlbCk7XG5cbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbih0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgdG9vbHRpcENvbnRlbnQsIHBhcmFtcywgZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb258QXJyYXkuPG51bWJlcj58T2JqZWN0fSBwb3NpdGlvbkV4cHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IE1vdXNlIHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IE1vdXNlIHlcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gY29uZmluZSBXaGV0aGVyIGNvbmZpbmUgdG9vbHRpcCBjb250ZW50IGluIHZpZXcgcmVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fDxBcnJheS48T2JqZWN0Pn0gcGFyYW1zXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgX3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIGNvbnRlbnQsIHBhcmFtcywgZWwpIHtcbiAgICB2YXIgdmlld1dpZHRoID0gdGhpcy5fYXBpLmdldFdpZHRoKCk7XG5cbiAgICB2YXIgdmlld0hlaWdodCA9IHRoaXMuX2FwaS5nZXRIZWlnaHQoKTtcblxuICAgIHBvc2l0aW9uRXhwciA9IHBvc2l0aW9uRXhwciB8fCB0b29sdGlwTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgIHZhciBjb250ZW50U2l6ZSA9IGNvbnRlbnQuZ2V0U2l6ZSgpO1xuICAgIHZhciBhbGlnbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ2FsaWduJyk7XG4gICAgdmFyIHZBbGlnbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3ZlcnRpY2FsQWxpZ24nKTtcbiAgICB2YXIgcmVjdCA9IGVsICYmIGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgZWwgJiYgcmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuXG4gICAgaWYgKHR5cGVvZiBwb3NpdGlvbkV4cHIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIENhbGxiYWNrIG9mIHBvc2l0aW9uIGNhbiBiZSBhbiBhcnJheSBvciBhIHN0cmluZyBzcGVjaWZ5IHRoZSBwb3NpdGlvblxuICAgICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByKFt4LCB5XSwgcGFyYW1zLCBjb250ZW50LmVsLCByZWN0LCB7XG4gICAgICAgIHZpZXdTaXplOiBbdmlld1dpZHRoLCB2aWV3SGVpZ2h0XSxcbiAgICAgICAgY29udGVudFNpemU6IGNvbnRlbnRTaXplLnNsaWNlKClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh6clV0aWwuaXNBcnJheShwb3NpdGlvbkV4cHIpKSB7XG4gICAgICB4ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uRXhwclswXSwgdmlld1dpZHRoKTtcbiAgICAgIHkgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzFdLCB2aWV3SGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChwb3NpdGlvbkV4cHIpKSB7XG4gICAgICBwb3NpdGlvbkV4cHIud2lkdGggPSBjb250ZW50U2l6ZVswXTtcbiAgICAgIHBvc2l0aW9uRXhwci5oZWlnaHQgPSBjb250ZW50U2l6ZVsxXTtcbiAgICAgIHZhciBsYXlvdXRSZWN0ID0gbGF5b3V0VXRpbC5nZXRMYXlvdXRSZWN0KHBvc2l0aW9uRXhwciwge1xuICAgICAgICB3aWR0aDogdmlld1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHZpZXdIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgeCA9IGxheW91dFJlY3QueDtcbiAgICAgIHkgPSBsYXlvdXRSZWN0Lnk7XG4gICAgICBhbGlnbiA9IG51bGw7IC8vIFdoZW4gcG9zaXRpb25FeHByIGlzIGxlZnQvdG9wL3JpZ2h0L2JvdHRvbSxcbiAgICAgIC8vIGFsaWduIGFuZCB2ZXJ0aWNhbEFsaWduIHdpbGwgbm90IHdvcmsuXG5cbiAgICAgIHZBbGlnbiA9IG51bGw7XG4gICAgfSAvLyBTcGVjaWZ5IHRvb2x0aXAgcG9zaXRpb24gYnkgc3RyaW5nICd0b3AnICdib3R0b20nICdsZWZ0JyAncmlnaHQnIGFyb3VuZCBncmFwaGljIGVsZW1lbnRcbiAgICBlbHNlIGlmICh0eXBlb2YgcG9zaXRpb25FeHByID09PSAnc3RyaW5nJyAmJiBlbCkge1xuICAgICAgICB2YXIgcG9zID0gY2FsY1Rvb2x0aXBQb3NpdGlvbihwb3NpdGlvbkV4cHIsIHJlY3QsIGNvbnRlbnRTaXplKTtcbiAgICAgICAgeCA9IHBvc1swXTtcbiAgICAgICAgeSA9IHBvc1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwb3MgPSByZWZpeFRvb2x0aXBQb3NpdGlvbih4LCB5LCBjb250ZW50LmVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIGFsaWduID8gbnVsbCA6IDIwLCB2QWxpZ24gPyBudWxsIDogMjApO1xuICAgICAgICB4ID0gcG9zWzBdO1xuICAgICAgICB5ID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgYWxpZ24gJiYgKHggLT0gaXNDZW50ZXJBbGlnbihhbGlnbikgPyBjb250ZW50U2l6ZVswXSAvIDIgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/IGNvbnRlbnRTaXplWzBdIDogMCk7XG4gICAgdkFsaWduICYmICh5IC09IGlzQ2VudGVyQWxpZ24odkFsaWduKSA/IGNvbnRlbnRTaXplWzFdIC8gMiA6IHZBbGlnbiA9PT0gJ2JvdHRvbScgPyBjb250ZW50U2l6ZVsxXSA6IDApO1xuXG4gICAgaWYgKHRvb2x0aXBNb2RlbC5nZXQoJ2NvbmZpbmUnKSkge1xuICAgICAgdmFyIHBvcyA9IGNvbmZpbmVUb29sdGlwUG9zaXRpb24oeCwgeSwgY29udGVudC5lbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcbiAgICAgIHggPSBwb3NbMF07XG4gICAgICB5ID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGNvbnRlbnQubW92ZVRvKHgsIHkpO1xuICB9LFxuICAvLyBGSVhNRVxuICAvLyBTaG91bGQgd2UgcmVtb3ZlIHRoaXMgYnV0IGxlYXZlIHRoaXMgdG8gdXNlcj9cbiAgX3VwZGF0ZUNvbnRlbnROb3RDaGFuZ2VkT25BeGlzOiBmdW5jdGlvbiAoZGF0YUJ5Q29vcmRTeXMpIHtcbiAgICB2YXIgbGFzdENvb3JkU3lzID0gdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzO1xuICAgIHZhciBjb250ZW50Tm90Q2hhbmdlZCA9ICEhbGFzdENvb3JkU3lzICYmIGxhc3RDb29yZFN5cy5sZW5ndGggPT09IGRhdGFCeUNvb3JkU3lzLmxlbmd0aDtcbiAgICBjb250ZW50Tm90Q2hhbmdlZCAmJiBlYWNoKGxhc3RDb29yZFN5cywgZnVuY3Rpb24gKGxhc3RJdGVtQ29vcmRTeXMsIGluZGV4Q29vcmRTeXMpIHtcbiAgICAgIHZhciBsYXN0RGF0YUJ5QXhpcyA9IGxhc3RJdGVtQ29vcmRTeXMuZGF0YUJ5QXhpcyB8fCB7fTtcbiAgICAgIHZhciB0aGlzSXRlbUNvb3JkU3lzID0gZGF0YUJ5Q29vcmRTeXNbaW5kZXhDb29yZFN5c10gfHwge307XG4gICAgICB2YXIgdGhpc0RhdGFCeUF4aXMgPSB0aGlzSXRlbUNvb3JkU3lzLmRhdGFCeUF4aXMgfHwgW107XG4gICAgICBjb250ZW50Tm90Q2hhbmdlZCAmPSBsYXN0RGF0YUJ5QXhpcy5sZW5ndGggPT09IHRoaXNEYXRhQnlBeGlzLmxlbmd0aDtcbiAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICYmIGVhY2gobGFzdERhdGFCeUF4aXMsIGZ1bmN0aW9uIChsYXN0SXRlbSwgaW5kZXhBeGlzKSB7XG4gICAgICAgIHZhciB0aGlzSXRlbSA9IHRoaXNEYXRhQnlBeGlzW2luZGV4QXhpc10gfHwge307XG4gICAgICAgIHZhciBsYXN0SW5kaWNlcyA9IGxhc3RJdGVtLnNlcmllc0RhdGFJbmRpY2VzIHx8IFtdO1xuICAgICAgICB2YXIgbmV3SW5kaWNlcyA9IHRoaXNJdGVtLnNlcmllc0RhdGFJbmRpY2VzIHx8IFtdO1xuICAgICAgICBjb250ZW50Tm90Q2hhbmdlZCAmPSBsYXN0SXRlbS52YWx1ZSA9PT0gdGhpc0l0ZW0udmFsdWUgJiYgbGFzdEl0ZW0uYXhpc1R5cGUgPT09IHRoaXNJdGVtLmF4aXNUeXBlICYmIGxhc3RJdGVtLmF4aXNJZCA9PT0gdGhpc0l0ZW0uYXhpc0lkICYmIGxhc3RJbmRpY2VzLmxlbmd0aCA9PT0gbmV3SW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICYmIGVhY2gobGFzdEluZGljZXMsIGZ1bmN0aW9uIChsYXN0SWR4SXRlbSwgaikge1xuICAgICAgICAgIHZhciBuZXdJZHhJdGVtID0gbmV3SW5kaWNlc1tqXTtcbiAgICAgICAgICBjb250ZW50Tm90Q2hhbmdlZCAmPSBsYXN0SWR4SXRlbS5zZXJpZXNJbmRleCA9PT0gbmV3SWR4SXRlbS5zZXJpZXNJbmRleCAmJiBsYXN0SWR4SXRlbS5kYXRhSW5kZXggPT09IG5ld0lkeEl0ZW0uZGF0YUluZGV4O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IGRhdGFCeUNvb3JkU3lzO1xuICAgIHJldHVybiAhIWNvbnRlbnROb3RDaGFuZ2VkO1xuICB9LFxuICBfaGlkZTogZnVuY3Rpb24gKGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgLy8gRG8gbm90IGRpcmVjdGx5IGhpZGVMYXRlciBoZXJlLCBiZWNhdXNlIHRoaXMgYmVoYXZpb3IgbWF5IGJlIHByZXZlbnRlZFxuICAgIC8vIGluIGRpc3BhdGNoQWN0aW9uIHdoZW4gc2hvd1RpcCBpcyBkaXNwYXRjaGVkLlxuICAgIC8vIEZJWE1FXG4gICAgLy8gZHVwbGljYXRlZCBoaWRlVGlwIGlmIG1hbnVhbGx5SGlkZVRpcCBpcyBjYWxsZWQgZnJvbSBkaXNwYXRjaEFjdGlvbi5cbiAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdoaWRlVGlwJyxcbiAgICAgIGZyb206IHRoaXMudWlkXG4gICAgfSk7XG4gIH0sXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBpZiAoZW52Lm5vZGUgfHwgZW52Lnd4YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3Rvb2x0aXBDb250ZW50LmhpZGUoKTtcblxuICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIoJ2l0ZW1Ub29sdGlwJywgYXBpKTtcbiAgfVxufSk7XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdHxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD59IG1vZGVsQ2FzY2FkZVxuICogRnJvbSB0b3AgdG8gYm90dG9tLiAodGhlIGxhc3Qgb25lIHNob3VsZCBiZSBnbG9iYWxUb29sdGlwTW9kZWwpO1xuICovXG5cblxuZnVuY3Rpb24gYnVpbGRUb29sdGlwTW9kZWwobW9kZWxDYXNjYWRlKSB7XG4gIHZhciByZXN1bHRNb2RlbCA9IG1vZGVsQ2FzY2FkZS5wb3AoKTtcblxuICB3aGlsZSAobW9kZWxDYXNjYWRlLmxlbmd0aCkge1xuICAgIHZhciB0b29sdGlwT3B0ID0gbW9kZWxDYXNjYWRlLnBvcCgpO1xuXG4gICAgaWYgKHRvb2x0aXBPcHQpIHtcbiAgICAgIGlmIChNb2RlbC5pc0luc3RhbmNlKHRvb2x0aXBPcHQpKSB7XG4gICAgICAgIHRvb2x0aXBPcHQgPSB0b29sdGlwT3B0LmdldCgndG9vbHRpcCcsIHRydWUpO1xuICAgICAgfSAvLyBJbiBlYWNoIGRhdGEgaXRlbSB0b29sdGlwIGNhbiBiZSBzaW1wbHkgd3JpdGU6XG4gICAgICAvLyB7XG4gICAgICAvLyAgdmFsdWU6IDEwLFxuICAgICAgLy8gIHRvb2x0aXA6ICdTb21ldGhpbmcgeW91IG5lZWQgdG8ga25vdydcbiAgICAgIC8vIH1cblxuXG4gICAgICBpZiAodHlwZW9mIHRvb2x0aXBPcHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRvb2x0aXBPcHQgPSB7XG4gICAgICAgICAgZm9ybWF0dGVyOiB0b29sdGlwT3B0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdE1vZGVsID0gbmV3IE1vZGVsKHRvb2x0aXBPcHQsIHJlc3VsdE1vZGVsLCByZXN1bHRNb2RlbC5lY01vZGVsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0TW9kZWw7XG59XG5cbmZ1bmN0aW9uIG1ha2VEaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBhcGkpIHtcbiAgcmV0dXJuIHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gfHwgenJVdGlsLmJpbmQoYXBpLmRpc3BhdGNoQWN0aW9uLCBhcGkpO1xufVxuXG5mdW5jdGlvbiByZWZpeFRvb2x0aXBQb3NpdGlvbih4LCB5LCBlbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0LCBnYXBILCBnYXBWKSB7XG4gIHZhciBzaXplID0gZ2V0T3V0ZXJTaXplKGVsKTtcbiAgdmFyIHdpZHRoID0gc2l6ZS53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG4gIGlmIChnYXBIICE9IG51bGwpIHtcbiAgICBpZiAoeCArIHdpZHRoICsgZ2FwSCA+IHZpZXdXaWR0aCkge1xuICAgICAgeCAtPSB3aWR0aCArIGdhcEg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0gZ2FwSDtcbiAgICB9XG4gIH1cblxuICBpZiAoZ2FwViAhPSBudWxsKSB7XG4gICAgaWYgKHkgKyBoZWlnaHQgKyBnYXBWID4gdmlld0hlaWdodCkge1xuICAgICAgeSAtPSBoZWlnaHQgKyBnYXBWO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ICs9IGdhcFY7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuZnVuY3Rpb24gY29uZmluZVRvb2x0aXBQb3NpdGlvbih4LCB5LCBlbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KSB7XG4gIHZhciBzaXplID0gZ2V0T3V0ZXJTaXplKGVsKTtcbiAgdmFyIHdpZHRoID0gc2l6ZS53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICB4ID0gTWF0aC5taW4oeCArIHdpZHRoLCB2aWV3V2lkdGgpIC0gd2lkdGg7XG4gIHkgPSBNYXRoLm1pbih5ICsgaGVpZ2h0LCB2aWV3SGVpZ2h0KSAtIGhlaWdodDtcbiAgeCA9IE1hdGgubWF4KHgsIDApO1xuICB5ID0gTWF0aC5tYXgoeSwgMCk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZShlbCkge1xuICB2YXIgd2lkdGggPSBlbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsLmNsaWVudEhlaWdodDsgLy8gQ29uc2lkZXIgYnJvd3NlciBjb21wYXRpYmlsaXR5LlxuICAvLyBJRTggZG9lcyBub3Qgc3VwcG9ydCBnZXRDb21wdXRlZFN0eWxlLlxuXG4gIGlmIChkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuXG4gICAgaWYgKHN0bCkge1xuICAgICAgd2lkdGggKz0gcGFyc2VJbnQoc3RsLnBhZGRpbmdMZWZ0LCAxMCkgKyBwYXJzZUludChzdGwucGFkZGluZ1JpZ2h0LCAxMCkgKyBwYXJzZUludChzdGwuYm9yZGVyTGVmdFdpZHRoLCAxMCkgKyBwYXJzZUludChzdGwuYm9yZGVyUmlnaHRXaWR0aCwgMTApO1xuICAgICAgaGVpZ2h0ICs9IHBhcnNlSW50KHN0bC5wYWRkaW5nVG9wLCAxMCkgKyBwYXJzZUludChzdGwucGFkZGluZ0JvdHRvbSwgMTApICsgcGFyc2VJbnQoc3RsLmJvcmRlclRvcFdpZHRoLCAxMCkgKyBwYXJzZUludChzdGwuYm9yZGVyQm90dG9tV2lkdGgsIDEwKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxjVG9vbHRpcFBvc2l0aW9uKHBvc2l0aW9uLCByZWN0LCBjb250ZW50U2l6ZSkge1xuICB2YXIgZG9tV2lkdGggPSBjb250ZW50U2l6ZVswXTtcbiAgdmFyIGRvbUhlaWdodCA9IGNvbnRlbnRTaXplWzFdO1xuICB2YXIgZ2FwID0gNTtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG4gIHZhciByZWN0V2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgcmVjdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXG4gIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XG4gICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0b3AnOlxuICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XG4gICAgICB5ID0gcmVjdC55IC0gZG9tSGVpZ2h0IC0gZ2FwO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XG4gICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCArIGdhcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB4ID0gcmVjdC54IC0gZG9tV2lkdGggLSBnYXA7XG4gICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoICsgZ2FwO1xuICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcbiAgfVxuXG4gIHJldHVybiBbeCwgeV07XG59XG5cbmZ1bmN0aW9uIGlzQ2VudGVyQWxpZ24oYWxpZ24pIHtcbiAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJyB8fCBhbGlnbiA9PT0gJ21pZGRsZSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBWaWV3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gKDEpIFRoZSBjb2RlIGBpZiAoX19ERVZfXykgLi4uYCBjYW4gYmUgcmVtb3ZlZCBieSBidWlsZCB0b29sLlxuLy8gKDIpIElmIGludGVuZCB0byB1c2UgYF9fREVWX19gLCB0aGlzIG1vZHVsZSBzaG91bGQgYmUgaW1wb3J0ZWQuIFVzZSBhIGdsb2JhbFxuLy8gdmFyaWFibGUgYF9fREVWX19gIG1heSBjYXVzZSB0aGF0IG1pc3MgdGhlIGRlY2xhcmF0aW9uIChzZWUgIzY1MzUpLCBvciB0aGVcbi8vIGRlY2xhcmF0aW9uIGlzIGJlaGluZCBvZiB0aGUgdXNpbmcgcG9zaXRpb24gKGZvciBleGFtcGxlIGluIGBNb2RlbC5leHRlbnRgLFxuLy8gQW5kIHRvb2xzIGxpa2Ugcm9sbHVwIGNhbiBub3QgYW5hbHlzaXMgdGhlIGRlcGVuZGVuY3kgaWYgbm90IGltcG9ydCkuXG52YXIgZGV2OyAvLyBJbiBicm93c2VyXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBkZXYgPSB3aW5kb3cuX19ERVZfXztcbn0gLy8gSW4gbm9kZVxuZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkZXYgPSBnbG9iYWwuX19ERVZfXztcbiAgfVxuXG5pZiAodHlwZW9mIGRldiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgZGV2ID0gdHJ1ZTtcbn1cblxudmFyIF9fREVWX18gPSBkZXY7XG5leHBvcnRzLl9fREVWX18gPSBfX0RFVl9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29uZmlnLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF91dGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIG1hcCA9IF91dGlsLm1hcDtcblxudmFyIF9udW1iZXIgPSByZXF1aXJlKFwiLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBsaW5lYXJNYXAgPSBfbnVtYmVyLmxpbmVhck1hcDtcbnZhciBnZXRQaXhlbFByZWNpc2lvbiA9IF9udW1iZXIuZ2V0UGl4ZWxQcmVjaXNpb247XG5cbnZhciBfYXhpc1RpY2tMYWJlbEJ1aWxkZXIgPSByZXF1aXJlKFwiLi9heGlzVGlja0xhYmVsQnVpbGRlclwiKTtcblxudmFyIGNyZWF0ZUF4aXNUaWNrcyA9IF9heGlzVGlja0xhYmVsQnVpbGRlci5jcmVhdGVBeGlzVGlja3M7XG52YXIgY3JlYXRlQXhpc0xhYmVscyA9IF9heGlzVGlja0xhYmVsQnVpbGRlci5jcmVhdGVBeGlzTGFiZWxzO1xudmFyIGNhbGN1bGF0ZUNhdGVnb3J5SW50ZXJ2YWwgPSBfYXhpc1RpY2tMYWJlbEJ1aWxkZXIuY2FsY3VsYXRlQ2F0ZWdvcnlJbnRlcnZhbDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIE5PUk1BTElaRURfRVhURU5UID0gWzAsIDFdO1xuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIEF4aXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgQXhpcyA9IGZ1bmN0aW9uIChkaW0sIHNjYWxlLCBleHRlbnQpIHtcbiAgLyoqXG4gICAqIEF4aXMgZGltZW5zaW9uLiBTdWNoIGFzICd4JywgJ3knLCAneicsICdhbmdsZScsICdyYWRpdXMnLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5kaW0gPSBkaW07XG4gIC8qKlxuICAgKiBBeGlzIHNjYWxlXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9zY2FsZS8qfVxuICAgKi9cblxuICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2V4dGVudCA9IGV4dGVudCB8fCBbMCwgMF07XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cbiAgdGhpcy5pbnZlcnNlID0gZmFsc2U7XG4gIC8qKlxuICAgKiBVc3VhbGx5IHRydWUgd2hlbiBheGlzIGhhcyBhIG9yZGluYWwgc2NhbGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMub25CYW5kID0gZmFsc2U7XG59O1xuXG5BeGlzLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEF4aXMsXG5cbiAgLyoqXG4gICAqIElmIGF4aXMgZXh0ZW50IGNvbnRhaW4gZ2l2ZW4gY29vcmRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICByZXR1cm4gY29vcmQgPj0gbWluICYmIGNvb3JkIDw9IG1heDtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYXhpcyBleHRlbnQgY29udGFpbiBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluKHRoaXMuZGF0YVRvQ29vcmQoZGF0YSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY29vcmQgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGdldEV4dGVudDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHByZWNpc2lvbiB1c2VkIGZvciBmb3JtYXR0aW5nXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtkYXRhRXh0ZW50XVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRQaXhlbFByZWNpc2lvbjogZnVuY3Rpb24gKGRhdGFFeHRlbnQpIHtcbiAgICByZXR1cm4gZ2V0UGl4ZWxQcmVjaXNpb24oZGF0YUV4dGVudCB8fCB0aGlzLnNjYWxlLmdldEV4dGVudCgpLCB0aGlzLl9leHRlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgY29vcmQgZXh0ZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAqL1xuICBzZXRFeHRlbnQ6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICBleHRlbnRbMF0gPSBzdGFydDtcbiAgICBleHRlbnRbMV0gPSBlbmQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgZGF0YSB0byBjb29yZC4gRGF0YSBpcyB0aGUgcmFuayBpZiBpdCBoYXMgYW4gb3JkaW5hbCBzY2FsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkYXRhVG9Db29yZDogZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIGRhdGEgPSBzY2FsZS5ub3JtYWxpemUoZGF0YSk7XG5cbiAgICBpZiAodGhpcy5vbkJhbmQgJiYgc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICBleHRlbnQgPSBleHRlbnQuc2xpY2UoKTtcbiAgICAgIGZpeEV4dGVudFdpdGhCYW5kcyhleHRlbnQsIHNjYWxlLmNvdW50KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lYXJNYXAoZGF0YSwgTk9STUFMSVpFRF9FWFRFTlQsIGV4dGVudCwgY2xhbXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGNvb3JkIHRvIGRhdGEuIERhdGEgaXMgdGhlIHJhbmsgaWYgaXQgaGFzIGFuIG9yZGluYWwgc2NhbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvb3JkVG9EYXRhOiBmdW5jdGlvbiAoY29vcmQsIGNsYW1wKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gICAgaWYgKHRoaXMub25CYW5kICYmIHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgZXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gICAgICBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBzY2FsZS5jb3VudCgpKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGxpbmVhck1hcChjb29yZCwgZXh0ZW50LCBOT1JNQUxJWkVEX0VYVEVOVCwgY2xhbXApO1xuICAgIHJldHVybiB0aGlzLnNjYWxlLnNjYWxlKHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHBpeGVsIHBvaW50IHRvIGRhdGEgaW4gYXhpc1xuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGRhdGFcbiAgICovXG4gIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7Ly8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGRlcml2ZWQgY2xhc3MgaWYgbmVjZXNzYXJ5LlxuICB9LFxuXG4gIC8qKlxuICAgKiBEaWZmZXJlbnQgZnJvbSBgenJVdGlsLm1hcChheGlzLmdldFRpY2tzKCksIGF4aXMuZGF0YVRvQ29vcmQsIGF4aXMpYCxcbiAgICogYGF4aXMuZ2V0VGlja3NDb29yZHNgIGNvbnNpZGVycyBgb25CYW5kYCwgd2hpY2ggaXMgdXNlZCBieVxuICAgKiBgYm91bmRhcnlHYXA6dHJ1ZWAgb2YgY2F0ZWdvcnkgYXhpcyBhbmQgc3BsaXRMaW5lIGFuZCBzcGxpdEFyZWEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC50aWNrTW9kZWw9YXhpcy5tb2RlbC5nZXRNb2RlbCgnYXhpc1RpY2snKV1cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LmNsYW1wXSBJZiBgdHJ1ZWAsIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3RcbiAgICogICAgICAgIHRpY2sgbXVzdCBiZSBhdCB0aGUgYXhpcyBlbmQgcG9pbnRzLiBPdGhlcndpc2UsIGNsaXAgdGlja3NcbiAgICogICAgICAgIHRoYXQgb3V0c2lkZSB0aGUgYXhpcyBleHRlbnQuXG4gICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBbe1xuICAgKiAgICAgY29vcmQ6IC4uLixcbiAgICogICAgIHRpY2tWYWx1ZTogLi4uXG4gICAqIH0sIC4uLl1cbiAgICovXG4gIGdldFRpY2tzQ29vcmRzOiBmdW5jdGlvbiAob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHZhciB0aWNrTW9kZWwgPSBvcHQudGlja01vZGVsIHx8IHRoaXMuZ2V0VGlja01vZGVsKCk7XG4gICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUF4aXNUaWNrcyh0aGlzLCB0aWNrTW9kZWwpO1xuICAgIHZhciB0aWNrcyA9IHJlc3VsdC50aWNrcztcbiAgICB2YXIgdGlja3NDb29yZHMgPSBtYXAodGlja3MsIGZ1bmN0aW9uICh0aWNrVmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvb3JkOiB0aGlzLmRhdGFUb0Nvb3JkKHRpY2tWYWx1ZSksXG4gICAgICAgIHRpY2tWYWx1ZTogdGlja1ZhbHVlXG4gICAgICB9O1xuICAgIH0sIHRoaXMpO1xuICAgIHZhciBhbGlnbldpdGhMYWJlbCA9IHRpY2tNb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJyk7XG4gICAgZml4T25CYW5kVGlja3NDb29yZHModGhpcywgdGlja3NDb29yZHMsIHJlc3VsdC50aWNrQ2F0ZWdvcnlJbnRlcnZhbCwgYWxpZ25XaXRoTGFiZWwsIG9wdC5jbGFtcCk7XG4gICAgcmV0dXJuIHRpY2tzQ29vcmRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gW3tcbiAgICogICAgIGZvcm1hdHRlZExhYmVsOiBzdHJpbmcsXG4gICAqICAgICByYXdMYWJlbDogYXhpcy5zY2FsZS5nZXRMYWJlbCh0aWNrVmFsdWUpXG4gICAqICAgICB0aWNrVmFsdWU6IG51bWJlclxuICAgKiB9LCAuLi5dXG4gICAqL1xuICBnZXRWaWV3TGFiZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUF4aXNMYWJlbHModGhpcykubGFiZWxzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9tb2RlbC9Nb2RlbH1cbiAgICovXG4gIGdldExhYmVsTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5vdGljZSBoZXJlIHdlIG9ubHkgZ2V0IHRoZSBkZWZhdWx0IHRpY2sgbW9kZWwuIEZvciBzcGxpdExpbmVcbiAgICogb3Igc3BsaXRBcmVhLCB3ZSBzaG91bGQgcGFzcyB0aGUgc3BsaXRMaW5lTW9kZWwgb3Igc3BsaXRBcmVhTW9kZWxcbiAgICogbWFudWFsbHkgd2hlbiBjYWxsaW5nIGBnZXRUaWNrc0Nvb3Jkc2AuXG4gICAqIEluIEdMLCB0aGlzIG1ldGhvZCBtYXkgYmUgb3ZlcnJpZGVkIHRvOlxuICAgKiBgYXhpc01vZGVsLmdldE1vZGVsKCdheGlzVGljaycsIGdyaWQzRE1vZGVsLmdldE1vZGVsKCdheGlzVGljaycpKTtgXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2Nvb3JkL21vZGVsL01vZGVsfVxuICAgKi9cbiAgZ2V0VGlja01vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0TW9kZWwoJ2F4aXNUaWNrJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB3aWR0aCBvZiBiYW5kXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEJhbmRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdGhpcy5zY2FsZS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgbGVuID0gZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0gKyAodGhpcy5vbkJhbmQgPyAxIDogMCk7IC8vIEZpeCAjMjcyOCwgYXZvaWQgTmFOIHdoZW4gb25seSBvbmUgZGF0YS5cblxuICAgIGxlbiA9PT0gMCAmJiAobGVuID0gMSk7XG4gICAgdmFyIHNpemUgPSBNYXRoLmFicyhheGlzRXh0ZW50WzFdIC0gYXhpc0V4dGVudFswXSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHNpemUpIC8gbGVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgaG9yaXpvbnRhbFxuICAgKi9cbiAgaXNIb3Jpem9udGFsOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7bnVtYmVyfSBHZXQgYXhpcyByb3RhdGUsIGJ5IGRlZ3JlZS5cbiAgICovXG4gIGdldFJvdGF0ZTogbnVsbCxcblxuICAvKipcbiAgICogT25seSBiZSBjYWxsZWQgaW4gY2F0ZWdvcnkgYXhpcy5cbiAgICogQ2FuIGJlIG92ZXJyaWRlZCwgY29uc2lkZXIgb3RoZXIgYXhlcyBsaWtlIGluIDNELlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEF1dG8gaW50ZXJ2YWwgZm9yIGNhdGVvZ3J5IGF4aXMgdGljayBhbmQgbGFiZWxcbiAgICovXG4gIGNhbGN1bGF0ZUNhdGVnb3J5SW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlQ2F0ZWdvcnlJbnRlcnZhbCh0aGlzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZml4RXh0ZW50V2l0aEJhbmRzKGV4dGVudCwgblRpY2spIHtcbiAgdmFyIHNpemUgPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gIHZhciBsZW4gPSBuVGljaztcbiAgdmFyIG1hcmdpbiA9IHNpemUgLyBsZW4gLyAyO1xuICBleHRlbnRbMF0gKz0gbWFyZ2luO1xuICBleHRlbnRbMV0gLT0gbWFyZ2luO1xufSAvLyBJZiBheGlzIGhhcyBsYWJlbHMgWzEsIDIsIDMsIDRdLiBCYW5kcyBvbiB0aGUgYXhpcyBhcmVcbi8vIHwtLS0xLS0tfC0tLTItLS18LS0tMy0tLXwtLS00LS0tfC5cbi8vIFNvIHRoZSBkaXNwbGF5ZWQgdGlja3MgYW5kIHNwbGl0TGluZS9zcGxpdEFyZWEgc2hvdWxkIGJldHdlZW5cbi8vIGVhY2ggZGF0YSBpdGVtLCBvdGhlcndpc2UgY2F1c2UgbWlzbGVhZGluZyAoZS5nLiwgc3BsaXQgdG93IGJhcnNcbi8vIG9mIGEgc2luZ2xlIGRhdGEgaXRlbSB3aGVuIHRoZXJlIGFyZSB0d28gYmFyIHNlcmllcykuXG4vLyBBbHNvIGNvbnNpZGVyIGlmIHRpY2tDYXRlZ29yeUludGVydmFsID4gMCBhbmQgb25CYW5kLCB0aWNrcyBhbmRcbi8vIHNwbGl0TGluZS9zcGxpdGVBcmVhIHNob3VsZCBsYXlvdXQgYXBwcm9wcmlhdGVseSBjb3JyZXNwb25kaW5nXG4vLyB0byBkaXNwbGF5ZWQgbGFiZWxzLiAoU28gd2Ugc2hvdWxkIG5vdCB1c2UgYGdldEJhbmRXaWR0aGAgaW4gdGhpc1xuLy8gY2FzZSkuXG5cblxuZnVuY3Rpb24gZml4T25CYW5kVGlja3NDb29yZHMoYXhpcywgdGlja3NDb29yZHMsIHRpY2tDYXRlZ29yeUludGVydmFsLCBhbGlnbldpdGhMYWJlbCwgY2xhbXApIHtcbiAgdmFyIHRpY2tzTGVuID0gdGlja3NDb29yZHMubGVuZ3RoO1xuXG4gIGlmICghYXhpcy5vbkJhbmQgfHwgYWxpZ25XaXRoTGFiZWwgfHwgIXRpY2tzTGVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEV4dGVudCgpO1xuICB2YXIgbGFzdDtcblxuICBpZiAodGlja3NMZW4gPT09IDEpIHtcbiAgICB0aWNrc0Nvb3Jkc1swXS5jb29yZCA9IGF4aXNFeHRlbnRbMF07XG4gICAgbGFzdCA9IHRpY2tzQ29vcmRzWzFdID0ge1xuICAgICAgY29vcmQ6IGF4aXNFeHRlbnRbMF1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBzaGlmdCA9IHRpY2tzQ29vcmRzWzFdLmNvb3JkIC0gdGlja3NDb29yZHNbMF0uY29vcmQ7XG4gICAgZWFjaCh0aWNrc0Nvb3JkcywgZnVuY3Rpb24gKHRpY2tzSXRlbSkge1xuICAgICAgdGlja3NJdGVtLmNvb3JkIC09IHNoaWZ0IC8gMjtcbiAgICAgIHZhciB0aWNrQ2F0ZWdvcnlJbnRlcnZhbCA9IHRpY2tDYXRlZ29yeUludGVydmFsIHx8IDA7IC8vIEF2b2lkIHNwbGl0IGEgc2luZ2xlIGRhdGEgaXRlbSB3aGVuIG9kZCBpbnRlcnZhbC5cblxuICAgICAgaWYgKHRpY2tDYXRlZ29yeUludGVydmFsICUgMiA+IDApIHtcbiAgICAgICAgdGlja3NJdGVtLmNvb3JkIC09IHNoaWZ0IC8gKCh0aWNrQ2F0ZWdvcnlJbnRlcnZhbCArIDEpICogMik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGFzdCA9IHtcbiAgICAgIGNvb3JkOiB0aWNrc0Nvb3Jkc1t0aWNrc0xlbiAtIDFdLmNvb3JkICsgc2hpZnRcbiAgICB9O1xuICAgIHRpY2tzQ29vcmRzLnB1c2gobGFzdCk7XG4gIH1cblxuICB2YXIgaW52ZXJzZSA9IGF4aXNFeHRlbnRbMF0gPiBheGlzRXh0ZW50WzFdO1xuXG4gIGlmIChsaXR0bGVUaGFuKHRpY2tzQ29vcmRzWzBdLmNvb3JkLCBheGlzRXh0ZW50WzBdKSkge1xuICAgIGNsYW1wID8gdGlja3NDb29yZHNbMF0uY29vcmQgPSBheGlzRXh0ZW50WzBdIDogdGlja3NDb29yZHMuc2hpZnQoKTtcbiAgfVxuXG4gIGlmIChjbGFtcCAmJiBsaXR0bGVUaGFuKGF4aXNFeHRlbnRbMF0sIHRpY2tzQ29vcmRzWzBdLmNvb3JkKSkge1xuICAgIHRpY2tzQ29vcmRzLnVuc2hpZnQoe1xuICAgICAgY29vcmQ6IGF4aXNFeHRlbnRbMF1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChsaXR0bGVUaGFuKGF4aXNFeHRlbnRbMV0sIGxhc3QuY29vcmQpKSB7XG4gICAgY2xhbXAgPyBsYXN0LmNvb3JkID0gYXhpc0V4dGVudFsxXSA6IHRpY2tzQ29vcmRzLnBvcCgpO1xuICB9XG5cbiAgaWYgKGNsYW1wICYmIGxpdHRsZVRoYW4obGFzdC5jb29yZCwgYXhpc0V4dGVudFsxXSkpIHtcbiAgICB0aWNrc0Nvb3Jkcy5wdXNoKHtcbiAgICAgIGNvb3JkOiBheGlzRXh0ZW50WzFdXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXR0bGVUaGFuKGEsIGIpIHtcbiAgICByZXR1cm4gaW52ZXJzZSA/IGEgPiBiIDogYSA8IGI7XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0gQXhpcztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvQXhpcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvQXhpcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgZGVmYXVsdE9wdGlvbiA9IHtcbiAgc2hvdzogdHJ1ZSxcbiAgemxldmVsOiAwLFxuICB6OiAwLFxuICAvLyBJbnZlcnNlIHRoZSBheGlzLlxuICBpbnZlcnNlOiBmYWxzZSxcbiAgLy8gQXhpcyBuYW1lIGRpc3BsYXllZC5cbiAgbmFtZTogJycsXG4gIC8vICdzdGFydCcgfCAnbWlkZGxlJyB8ICdlbmQnXG4gIG5hbWVMb2NhdGlvbjogJ2VuZCcsXG4gIC8vIEJ5IGRlZ3JlZS4gQnkgZGVmdWFsdCBhdXRvIHJvdGF0ZSBieSBuYW1lTG9jYXRpb24uXG4gIG5hbWVSb3RhdGU6IG51bGwsXG4gIG5hbWVUcnVuY2F0ZToge1xuICAgIG1heFdpZHRoOiBudWxsLFxuICAgIGVsbGlwc2lzOiAnLi4uJyxcbiAgICBwbGFjZWhvbGRlcjogJy4nXG4gIH0sXG4gIC8vIFVzZSBnbG9iYWwgdGV4dCBzdHlsZSBieSBkZWZhdWx0LlxuICBuYW1lVGV4dFN0eWxlOiB7fSxcbiAgLy8gVGhlIGdhcCBiZXR3ZWVuIGF4aXNOYW1lIGFuZCBheGlzTGluZS5cbiAgbmFtZUdhcDogMTUsXG4gIC8vIERlZmF1bHQgYGZhbHNlYCB0byBzdXBwb3J0IHRvb2x0aXAuXG4gIHNpbGVudDogZmFsc2UsXG4gIC8vIERlZmF1bHQgYGZhbHNlYCB0byBhdm9pZCBsZWdhY3kgdXNlciBldmVudCBsaXN0ZW5lciBmYWlsLlxuICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLFxuICB0b29sdGlwOiB7XG4gICAgc2hvdzogZmFsc2VcbiAgfSxcbiAgYXhpc1BvaW50ZXI6IHt9LFxuICBheGlzTGluZToge1xuICAgIHNob3c6IHRydWUsXG4gICAgb25aZXJvOiB0cnVlLFxuICAgIG9uWmVyb0F4aXNJbmRleDogbnVsbCxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnIzMzMycsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICB9LFxuICAgIC8vIFRoZSBhcnJvdyBhdCBib3RoIGVuZHMgdGhlIHRoZSBheGlzLlxuICAgIHN5bWJvbDogWydub25lJywgJ25vbmUnXSxcbiAgICBzeW1ib2xTaXplOiBbMTAsIDE1XVxuICB9LFxuICBheGlzVGljazoge1xuICAgIHNob3c6IHRydWUsXG4gICAgLy8gV2hldGhlciBheGlzVGljayBpcyBpbnNpZGUgdGhlIGdyaWQgb3Igb3V0c2lkZSB0aGUgZ3JpZC5cbiAgICBpbnNpZGU6IGZhbHNlLFxuICAgIC8vIFRoZSBsZW5ndGggb2YgYXhpc1RpY2suXG4gICAgbGVuZ3RoOiA1LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgd2lkdGg6IDFcbiAgICB9XG4gIH0sXG4gIGF4aXNMYWJlbDoge1xuICAgIHNob3c6IHRydWUsXG4gICAgLy8gV2hldGhlciBheGlzTGFiZWwgaXMgaW5zaWRlIHRoZSBncmlkIG9yIG91dHNpZGUgdGhlIGdyaWQuXG4gICAgaW5zaWRlOiBmYWxzZSxcbiAgICByb3RhdGU6IDAsXG4gICAgLy8gdHJ1ZSB8IGZhbHNlIHwgbnVsbC91bmRlZmluZWQgKGF1dG8pXG4gICAgc2hvd01pbkxhYmVsOiBudWxsLFxuICAgIC8vIHRydWUgfCBmYWxzZSB8IG51bGwvdW5kZWZpbmVkIChhdXRvKVxuICAgIHNob3dNYXhMYWJlbDogbnVsbCxcbiAgICBtYXJnaW46IDgsXG4gICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgIGZvbnRTaXplOiAxMlxuICB9LFxuICBzcGxpdExpbmU6IHtcbiAgICBzaG93OiB0cnVlLFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgY29sb3I6IFsnI2NjYyddLFxuICAgICAgd2lkdGg6IDEsXG4gICAgICB0eXBlOiAnc29saWQnXG4gICAgfVxuICB9LFxuICBzcGxpdEFyZWE6IHtcbiAgICBzaG93OiBmYWxzZSxcbiAgICBhcmVhU3R5bGU6IHtcbiAgICAgIGNvbG9yOiBbJ3JnYmEoMjUwLDI1MCwyNTAsMC4zKScsICdyZ2JhKDIwMCwyMDAsMjAwLDAuMyknXVxuICAgIH1cbiAgfVxufTtcbnZhciBheGlzRGVmYXVsdCA9IHt9O1xuYXhpc0RlZmF1bHQuY2F0ZWdvcnlBeGlzID0genJVdGlsLm1lcmdlKHtcbiAgLy8gVGhlIGdhcCBhdCBib3RoIGVuZHMgb2YgdGhlIGF4aXMuIEZvciBjYXRlZ29yeUF4aXMsIGJvb2xlYW4uXG4gIGJvdW5kYXJ5R2FwOiB0cnVlLFxuICAvLyBTZXQgZmFsc2UgdG8gZmFzdGVyIGNhdGVnb3J5IGNvbGxlY3Rpb24uXG4gIC8vIE9ubHkgdXNlZnVsbCBpbiB0aGUgY2FzZSBsaWtlOiBjYXRlZ29yeSBpc1xuICAvLyBbJzIwMTItMDEtMDEnLCAnMjAxMi0wMS0wMicsIC4uLl0sIHdoZXJlIHRoZSBpbnB1dFxuICAvLyBkYXRhIGhhcyBiZWVuIGVuc3VyZWQgbm90IGR1cGxpY2F0ZSBhbmQgaXMgbGFyZ2UgZGF0YS5cbiAgLy8gbnVsbCBtZWFucyBcImF1dG9cIjpcbiAgLy8gaWYgYXhpcy5kYXRhIHByb3ZpZGVkLCBkbyBub3QgZGVkdXBsaWNhdGlvbixcbiAgLy8gZWxzZSBkbyBkZWR1cGxpY2F0aW9uLlxuICBkZWR1cGxpY2F0aW9uOiBudWxsLFxuICAvLyBzcGxpdEFyZWE6IHtcbiAgLy8gc2hvdzogZmFsc2VcbiAgLy8gfSxcbiAgc3BsaXRMaW5lOiB7XG4gICAgc2hvdzogZmFsc2VcbiAgfSxcbiAgYXhpc1RpY2s6IHtcbiAgICAvLyBJZiB0aWNrIGlzIGFsaWduIHdpdGggbGFiZWwgd2hlbiBib3VuZGFyeUdhcCBpcyB0cnVlXG4gICAgYWxpZ25XaXRoTGFiZWw6IGZhbHNlLFxuICAgIGludGVydmFsOiAnYXV0bydcbiAgfSxcbiAgYXhpc0xhYmVsOiB7XG4gICAgaW50ZXJ2YWw6ICdhdXRvJ1xuICB9XG59LCBkZWZhdWx0T3B0aW9uKTtcbmF4aXNEZWZhdWx0LnZhbHVlQXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gIC8vIFRoZSBnYXAgYXQgYm90aCBlbmRzIG9mIHRoZSBheGlzLiBGb3IgdmFsdWUgYXhpcywgW0dBUCwgR0FQXSwgd2hlcmVcbiAgLy8gYEdBUGAgY2FuIGJlIGFuIGFic29sdXRlIHBpeGVsIG51bWJlciAobGlrZSBgMzVgKSwgb3IgcGVyY2VudCAobGlrZSBgJzMwJSdgKVxuICBib3VuZGFyeUdhcDogWzAsIDBdLFxuICAvLyBUT0RPXG4gIC8vIG1pbi9tYXg6IFszMCwgZGF0YW1pbiwgNjBdIG9yIFsyMCwgZGF0YW1pbl0gb3IgW2RhdGFtaW4sIDYwXVxuICAvLyBNaW4gdmFsdWUgb2YgdGhlIGF4aXMuIGNhbiBiZTpcbiAgLy8gKyBhIG51bWJlclxuICAvLyArICdkYXRhTWluJzogdXNlIHRoZSBtaW4gdmFsdWUgaW4gZGF0YS5cbiAgLy8gKyBudWxsL3VuZGVmaW5lZDogYXV0byBkZWNpZGUgbWluIHZhbHVlIChjb25zaWRlciBwcmV0dHkgbG9vayBhbmQgYm91bmRhcnlHYXApLlxuICAvLyBtaW46IG51bGwsXG4gIC8vIE1heCB2YWx1ZSBvZiB0aGUgYXhpcy4gY2FuIGJlOlxuICAvLyArIGEgbnVtYmVyXG4gIC8vICsgJ2RhdGFNYXgnOiB1c2UgdGhlIG1heCB2YWx1ZSBpbiBkYXRhLlxuICAvLyArIG51bGwvdW5kZWZpbmVkOiBhdXRvIGRlY2lkZSBtYXggdmFsdWUgKGNvbnNpZGVyIHByZXR0eSBsb29rIGFuZCBib3VuZGFyeUdhcCkuXG4gIC8vIG1heDogbnVsbCxcbiAgLy8gUmVhZG9ubHkgcHJvcCwgc3BlY2lmaWVzIHN0YXJ0IHZhbHVlIG9mIHRoZSByYW5nZSB3aGVuIHVzaW5nIGRhdGEgem9vbS5cbiAgLy8gcmFuZ2VTdGFydDogbnVsbFxuICAvLyBSZWFkb25seSBwcm9wLCBzcGVjaWZpZXMgZW5kIHZhbHVlIG9mIHRoZSByYW5nZSB3aGVuIHVzaW5nIGRhdGEgem9vbS5cbiAgLy8gcmFuZ2VFbmQ6IG51bGxcbiAgLy8gT3B0aW9uYWwgdmFsdWUgY2FuIGJlOlxuICAvLyArIGBmYWxzZWA6IGFsd2F5cyBpbmNsdWRlIHZhbHVlIDAuXG4gIC8vICsgYHRydWVgOiB0aGUgZXh0ZW50IGRvIG5vdCBjb25zaWRlciB2YWx1ZSAwLlxuICAvLyBzY2FsZTogZmFsc2UsXG4gIC8vIEF4aXNUaWNrIGFuZCBheGlzTGFiZWwgYW5kIHNwbGl0TGluZSBhcmUgY2FjdWxhdGVkIGJhc2VkIG9uIHNwbGl0TnVtYmVyLlxuICBzcGxpdE51bWJlcjogNSAvLyBJbnRlcnZhbCBzcGVjaWZpZXMgdGhlIHNwYW4gb2YgdGhlIHRpY2tzIGlzIG1hbmRhdG9yaWx5LlxuICAvLyBpbnRlcnZhbDogbnVsbFxuICAvLyBTcGVjaWZ5IG1pbiBpbnRlcnZhbCB3aGVuIGF1dG8gY2FsY3VsYXRlIHRpY2sgaW50ZXJ2YWwuXG4gIC8vIG1pbkludGVydmFsOiBudWxsXG4gIC8vIFNwZWNpZnkgbWF4IGludGVydmFsIHdoZW4gYXV0byBjYWxjdWxhdGUgdGljayBpbnRlcnZhbC5cbiAgLy8gbWF4SW50ZXJ2YWw6IG51bGxcblxufSwgZGVmYXVsdE9wdGlvbik7XG5heGlzRGVmYXVsdC50aW1lQXhpcyA9IHpyVXRpbC5kZWZhdWx0cyh7XG4gIHNjYWxlOiB0cnVlLFxuICBtaW46ICdkYXRhTWluJyxcbiAgbWF4OiAnZGF0YU1heCdcbn0sIGF4aXNEZWZhdWx0LnZhbHVlQXhpcyk7XG5heGlzRGVmYXVsdC5sb2dBeGlzID0genJVdGlsLmRlZmF1bHRzKHtcbiAgc2NhbGU6IHRydWUsXG4gIGxvZ0Jhc2U6IDEwXG59LCBheGlzRGVmYXVsdC52YWx1ZUF4aXMpO1xudmFyIF9kZWZhdWx0ID0gYXhpc0RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNEZWZhdWx0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzRGVmYXVsdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgT3JkaW5hbFNjYWxlID0gcmVxdWlyZShcIi4uL3NjYWxlL09yZGluYWxcIik7XG5cbnZhciBJbnRlcnZhbFNjYWxlID0gcmVxdWlyZShcIi4uL3NjYWxlL0ludGVydmFsXCIpO1xuXG52YXIgU2NhbGUgPSByZXF1aXJlKFwiLi4vc2NhbGUvU2NhbGVcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgX2JhckdyaWQgPSByZXF1aXJlKFwiLi4vbGF5b3V0L2JhckdyaWRcIik7XG5cbnZhciBwcmVwYXJlTGF5b3V0QmFyU2VyaWVzID0gX2JhckdyaWQucHJlcGFyZUxheW91dEJhclNlcmllcztcbnZhciBtYWtlQ29sdW1uTGF5b3V0ID0gX2JhckdyaWQubWFrZUNvbHVtbkxheW91dDtcbnZhciByZXRyaWV2ZUNvbHVtbkxheW91dCA9IF9iYXJHcmlkLnJldHJpZXZlQ29sdW1uTGF5b3V0O1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG5yZXF1aXJlKFwiLi4vc2NhbGUvVGltZVwiKTtcblxucmVxdWlyZShcIi4uL3NjYWxlL0xvZ1wiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEdldCBheGlzIHNjYWxlIGV4dGVudCBiZWZvcmUgbmljZWQuXG4gKiBJdGVtIG9mIHJldHVybmVkIGFycmF5IGNhbiBvbmx5IGJlIG51bWJlciAoaW5jbHVkaW5nIEluZmluaXR5IGFuZCBOYU4pLlxuICovXG5mdW5jdGlvbiBnZXRTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpIHtcbiAgdmFyIHNjYWxlVHlwZSA9IHNjYWxlLnR5cGU7XG4gIHZhciBtaW4gPSBtb2RlbC5nZXRNaW4oKTtcbiAgdmFyIG1heCA9IG1vZGVsLmdldE1heCgpO1xuICB2YXIgZml4TWluID0gbWluICE9IG51bGw7XG4gIHZhciBmaXhNYXggPSBtYXggIT0gbnVsbDtcbiAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCk7XG4gIHZhciBheGlzRGF0YUxlbjtcbiAgdmFyIGJvdW5kYXJ5R2FwO1xuICB2YXIgc3BhbjtcblxuICBpZiAoc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICBheGlzRGF0YUxlbiA9IG1vZGVsLmdldENhdGVnb3JpZXMoKS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnlHYXAgPSBtb2RlbC5nZXQoJ2JvdW5kYXJ5R2FwJyk7XG5cbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGJvdW5kYXJ5R2FwKSkge1xuICAgICAgYm91bmRhcnlHYXAgPSBbYm91bmRhcnlHYXAgfHwgMCwgYm91bmRhcnlHYXAgfHwgMF07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBib3VuZGFyeUdhcFswXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBib3VuZGFyeUdhcCA9IFswLCAwXTtcbiAgICB9XG5cbiAgICBib3VuZGFyeUdhcFswXSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGJvdW5kYXJ5R2FwWzBdLCAxKTtcbiAgICBib3VuZGFyeUdhcFsxXSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGJvdW5kYXJ5R2FwWzFdLCAxKTtcbiAgICBzcGFuID0gb3JpZ2luYWxFeHRlbnRbMV0gLSBvcmlnaW5hbEV4dGVudFswXSB8fCBNYXRoLmFicyhvcmlnaW5hbEV4dGVudFswXSk7XG4gIH0gLy8gTm90aWNlOiBXaGVuIG1pbi9tYXggaXMgbm90IHNldCAodGhhdCBpcywgd2hlbiB0aGVyZSBhcmUgbnVsbC91bmRlZmluZWQsXG4gIC8vIHdoaWNoIGlzIHRoZSBtb3N0IGNvbW1vbiBjYXNlKSwgdGhlc2UgY2FzZXMgc2hvdWxkIGJlIGVuc3VyZWQ6XG4gIC8vICgxKSBGb3IgJ29yZGluYWwnLCBzaG93IGFsbCBheGlzLmRhdGEuXG4gIC8vICgyKSBGb3Igb3RoZXJzOlxuICAvLyAgICAgICsgYGJvdW5kYXJ5R2FwYCBpcyBhcHBsaWVkIChpZiBtaW4vbWF4IHNldCwgYm91bmRhcnlHYXAgaXNcbiAgLy8gICAgICBkaXNhYmxlZCkuXG4gIC8vICAgICAgKyBJZiBgbmVlZENyb3NzWmVyb2AsIG1pbi9tYXggc2hvdWxkIGJlIHplcm8sIG90aGVyd2lzZSwgbWluL21heCBzaG91bGRcbiAgLy8gICAgICBiZSB0aGUgcmVzdWx0IHRoYXQgb3JpZ2luYWxFeHRlbnQgZW5sYXJnZWQgYnkgYm91bmRhcnlHYXAuXG4gIC8vICgzKSBJZiBubyBkYXRhLCBpdCBzaG91bGQgYmUgZW5zdXJlZCB0aGF0IGBzY2FsZS5zZXRCbGFua2AgaXMgc2V0LlxuICAvLyBGSVhNRVxuICAvLyAoMSkgV2hlbiBtaW4vbWF4IGlzICdkYXRhTWluJyBvciAnZGF0YU1heCcsIHNob3VsZCBib3VuZGFyeUdhcCBiZSBhYmxlIHRvIHVzZWQ/XG4gIC8vICgyKSBXaGVuIGBuZWVkQ3Jvc3NaZXJvYCBhbmQgYWxsIGRhdGEgaXMgcG9zaXRpdmUvbmVnYXRpdmUsIHNob3VsZCBpdCBiZSBlbnN1cmVkXG4gIC8vIHRoYXQgdGhlIHJlc3VsdHMgcHJvY2Vzc2VkIGJ5IGJvdW5kYXJ5R2FwIGFyZSBwb3NpdGl2ZS9uZWdhdGl2ZT9cblxuXG4gIGlmIChtaW4gPT0gbnVsbCkge1xuICAgIG1pbiA9IHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnID8gYXhpc0RhdGFMZW4gPyAwIDogTmFOIDogb3JpZ2luYWxFeHRlbnRbMF0gLSBib3VuZGFyeUdhcFswXSAqIHNwYW47XG4gIH1cblxuICBpZiAobWF4ID09IG51bGwpIHtcbiAgICBtYXggPSBzY2FsZVR5cGUgPT09ICdvcmRpbmFsJyA/IGF4aXNEYXRhTGVuID8gYXhpc0RhdGFMZW4gLSAxIDogTmFOIDogb3JpZ2luYWxFeHRlbnRbMV0gKyBib3VuZGFyeUdhcFsxXSAqIHNwYW47XG4gIH1cblxuICBpZiAobWluID09PSAnZGF0YU1pbicpIHtcbiAgICBtaW4gPSBvcmlnaW5hbEV4dGVudFswXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWluID0gbWluKHtcbiAgICAgIG1pbjogb3JpZ2luYWxFeHRlbnRbMF0sXG4gICAgICBtYXg6IG9yaWdpbmFsRXh0ZW50WzFdXG4gICAgfSk7XG4gIH1cblxuICBpZiAobWF4ID09PSAnZGF0YU1heCcpIHtcbiAgICBtYXggPSBvcmlnaW5hbEV4dGVudFsxXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWF4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWF4ID0gbWF4KHtcbiAgICAgIG1pbjogb3JpZ2luYWxFeHRlbnRbMF0sXG4gICAgICBtYXg6IG9yaWdpbmFsRXh0ZW50WzFdXG4gICAgfSk7XG4gIH1cblxuICAobWluID09IG51bGwgfHwgIWlzRmluaXRlKG1pbikpICYmIChtaW4gPSBOYU4pO1xuICAobWF4ID09IG51bGwgfHwgIWlzRmluaXRlKG1heCkpICYmIChtYXggPSBOYU4pO1xuICBzY2FsZS5zZXRCbGFuayh6clV0aWwuZXFOYU4obWluKSB8fCB6clV0aWwuZXFOYU4obWF4KSB8fCBzY2FsZVR5cGUgPT09ICdvcmRpbmFsJyAmJiAhc2NhbGUuZ2V0T3JkaW5hbE1ldGEoKS5jYXRlZ29yaWVzLmxlbmd0aCk7IC8vIEV2YWx1YXRlIGlmIGF4aXMgbmVlZHMgY3Jvc3MgemVyb1xuXG4gIGlmIChtb2RlbC5nZXROZWVkQ3Jvc3NaZXJvKCkpIHtcbiAgICAvLyBBeGlzIGlzIG92ZXIgemVybyBhbmQgbWluIGlzIG5vdCBzZXRcbiAgICBpZiAobWluID4gMCAmJiBtYXggPiAwICYmICFmaXhNaW4pIHtcbiAgICAgIG1pbiA9IDA7XG4gICAgfSAvLyBBeGlzIGlzIHVuZGVyIHplcm8gYW5kIG1heCBpcyBub3Qgc2V0XG5cblxuICAgIGlmIChtaW4gPCAwICYmIG1heCA8IDAgJiYgIWZpeE1heCkge1xuICAgICAgbWF4ID0gMDtcbiAgICB9XG4gIH0gLy8gSWYgYmFycyBhcmUgcGxhY2VkIG9uIGEgYmFzZSBheGlzIG9mIHR5cGUgdGltZSBvciBpbnRlcnZhbCBhY2NvdW50IGZvciBheGlzIGJvdW5kYXJ5IG92ZXJmbG93IGFuZCBjdXJyZW50IGF4aXNcbiAgLy8gaXMgYmFzZSBheGlzXG4gIC8vIEZJWE1FXG4gIC8vICgxKSBDb25zaWRlciBzdXBwb3J0IHZhbHVlIGF4aXMsIHdoZXJlIGJlbG93IHplcm8gYW5kIGF4aXMgYG9uWmVyb2Agc2hvdWxkIGJlIGhhbmRsZWQgcHJvcGVybHkuXG4gIC8vICgyKSBSZWZhY3RvciB0aGUgbG9naWMgd2l0aCBgYmFyR3JpZGAuIElzIGl0IG5vdCBuZWVkIHRvIGBtYWtlQmFyV2lkdGhBbmRPZmZzZXRJbmZvYCB0d2ljZSB3aXRoIGRpZmZlcmVudCBleHRlbnQ/XG4gIC8vICAgICBTaG91bGQgbm90IGRlcGVuZCBvbiBzZXJpZXMgdHlwZSBgYmFyYD9cbiAgLy8gKDMpIEZpeCB0aGF0IG1pZ2h0IG92ZXJsYXAgd2hlbiB1c2luZyBkYXRhWm9vbS5cbiAgLy8gKDQpIENvbnNpZGVyIG90aGVyIGNoYXJ0IHR5cGVzIHVzaW5nIGBiYXJHcmlkYD9cbiAgLy8gU2VlICM2NzI4LCAjNDg2MiwgYHRlc3QvYmFyLW92ZXJmbG93LXRpbWUtcGxvdC5odG1sYFxuXG5cbiAgdmFyIGVjTW9kZWwgPSBtb2RlbC5lY01vZGVsO1xuXG4gIGlmIChlY01vZGVsICYmIHNjYWxlVHlwZSA9PT0gJ3RpbWUnXG4gIC8qfHwgc2NhbGVUeXBlID09PSAnaW50ZXJ2YWwnICovXG4gICkge1xuICAgIHZhciBiYXJTZXJpZXNNb2RlbHMgPSBwcmVwYXJlTGF5b3V0QmFyU2VyaWVzKCdiYXInLCBlY01vZGVsKTtcbiAgICB2YXIgaXNCYXNlQXhpc0FuZEhhc0JhclNlcmllcztcbiAgICB6clV0aWwuZWFjaChiYXJTZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaXNCYXNlQXhpc0FuZEhhc0JhclNlcmllcyB8PSBzZXJpZXNNb2RlbC5nZXRCYXNlQXhpcygpID09PSBtb2RlbC5heGlzO1xuICAgIH0pO1xuXG4gICAgaWYgKGlzQmFzZUF4aXNBbmRIYXNCYXJTZXJpZXMpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBwbGFjZW1lbnQgb2YgYmFycyBvbiBheGlzXG4gICAgICB2YXIgYmFyV2lkdGhBbmRPZmZzZXQgPSBtYWtlQ29sdW1uTGF5b3V0KGJhclNlcmllc01vZGVscyk7IC8vIEFkanVzdCBheGlzIG1pbiBhbmQgbWF4IHRvIGFjY291bnQgZm9yIG92ZXJmbG93XG5cbiAgICAgIHZhciBhZGp1c3RlZFNjYWxlID0gYWRqdXN0U2NhbGVGb3JPdmVyZmxvdyhtaW4sIG1heCwgbW9kZWwsIGJhcldpZHRoQW5kT2Zmc2V0KTtcbiAgICAgIG1pbiA9IGFkanVzdGVkU2NhbGUubWluO1xuICAgICAgbWF4ID0gYWRqdXN0ZWRTY2FsZS5tYXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbmZ1bmN0aW9uIGFkanVzdFNjYWxlRm9yT3ZlcmZsb3cobWluLCBtYXgsIG1vZGVsLCBiYXJXaWR0aEFuZE9mZnNldCkge1xuICAvLyBHZXQgQXhpcyBMZW5ndGhcbiAgdmFyIGF4aXNFeHRlbnQgPSBtb2RlbC5heGlzLmdldEV4dGVudCgpO1xuICB2YXIgYXhpc0xlbmd0aCA9IGF4aXNFeHRlbnRbMV0gLSBheGlzRXh0ZW50WzBdOyAvLyBHZXQgYmFycyBvbiBjdXJyZW50IGJhc2UgYXhpcyBhbmQgY2FsY3VsYXRlIG1pbiBhbmQgbWF4IG92ZXJmbG93XG5cbiAgdmFyIGJhcnNPbkN1cnJlbnRBeGlzID0gcmV0cmlldmVDb2x1bW5MYXlvdXQoYmFyV2lkdGhBbmRPZmZzZXQsIG1vZGVsLmF4aXMpO1xuXG4gIGlmIChiYXJzT25DdXJyZW50QXhpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXhcbiAgICB9O1xuICB9XG5cbiAgdmFyIG1pbk92ZXJmbG93ID0gSW5maW5pdHk7XG4gIHpyVXRpbC5lYWNoKGJhcnNPbkN1cnJlbnRBeGlzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIG1pbk92ZXJmbG93ID0gTWF0aC5taW4oaXRlbS5vZmZzZXQsIG1pbk92ZXJmbG93KTtcbiAgfSk7XG4gIHZhciBtYXhPdmVyZmxvdyA9IC1JbmZpbml0eTtcbiAgenJVdGlsLmVhY2goYmFyc09uQ3VycmVudEF4aXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgbWF4T3ZlcmZsb3cgPSBNYXRoLm1heChpdGVtLm9mZnNldCArIGl0ZW0ud2lkdGgsIG1heE92ZXJmbG93KTtcbiAgfSk7XG4gIG1pbk92ZXJmbG93ID0gTWF0aC5hYnMobWluT3ZlcmZsb3cpO1xuICBtYXhPdmVyZmxvdyA9IE1hdGguYWJzKG1heE92ZXJmbG93KTtcbiAgdmFyIHRvdGFsT3ZlckZsb3cgPSBtaW5PdmVyZmxvdyArIG1heE92ZXJmbG93OyAvLyBDYWx1bGF0ZSByZXF1aXJlZCBidWZmZXIgYmFzZWQgb24gb2xkIHJhbmdlIGFuZCBvdmVyZmxvd1xuXG4gIHZhciBvbGRSYW5nZSA9IG1heCAtIG1pbjtcbiAgdmFyIG9sZFJhbmdlUGVyY2VudE9mTmV3ID0gMSAtIChtaW5PdmVyZmxvdyArIG1heE92ZXJmbG93KSAvIGF4aXNMZW5ndGg7XG4gIHZhciBvdmVyZmxvd0J1ZmZlciA9IG9sZFJhbmdlIC8gb2xkUmFuZ2VQZXJjZW50T2ZOZXcgLSBvbGRSYW5nZTtcbiAgbWF4ICs9IG92ZXJmbG93QnVmZmVyICogKG1heE92ZXJmbG93IC8gdG90YWxPdmVyRmxvdyk7XG4gIG1pbiAtPSBvdmVyZmxvd0J1ZmZlciAqIChtaW5PdmVyZmxvdyAvIHRvdGFsT3ZlckZsb3cpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5pY2VTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpIHtcbiAgdmFyIGV4dGVudCA9IGdldFNjYWxlRXh0ZW50KHNjYWxlLCBtb2RlbCk7XG4gIHZhciBmaXhNaW4gPSBtb2RlbC5nZXRNaW4oKSAhPSBudWxsO1xuICB2YXIgZml4TWF4ID0gbW9kZWwuZ2V0TWF4KCkgIT0gbnVsbDtcbiAgdmFyIHNwbGl0TnVtYmVyID0gbW9kZWwuZ2V0KCdzcGxpdE51bWJlcicpO1xuXG4gIGlmIChzY2FsZS50eXBlID09PSAnbG9nJykge1xuICAgIHNjYWxlLmJhc2UgPSBtb2RlbC5nZXQoJ2xvZ0Jhc2UnKTtcbiAgfVxuXG4gIHZhciBzY2FsZVR5cGUgPSBzY2FsZS50eXBlO1xuICBzY2FsZS5zZXRFeHRlbnQoZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICBzY2FsZS5uaWNlRXh0ZW50KHtcbiAgICBzcGxpdE51bWJlcjogc3BsaXROdW1iZXIsXG4gICAgZml4TWluOiBmaXhNaW4sXG4gICAgZml4TWF4OiBmaXhNYXgsXG4gICAgbWluSW50ZXJ2YWw6IHNjYWxlVHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyA/IG1vZGVsLmdldCgnbWluSW50ZXJ2YWwnKSA6IG51bGwsXG4gICAgbWF4SW50ZXJ2YWw6IHNjYWxlVHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyA/IG1vZGVsLmdldCgnbWF4SW50ZXJ2YWwnKSA6IG51bGxcbiAgfSk7IC8vIElmIHNvbWUgb25lIHNwZWNpZmllZCB0aGUgbWluLCBtYXguIEFuZCB0aGUgZGVmYXVsdCBjYWxjdWxhdGVkIGludGVydmFsXG4gIC8vIGlzIG5vdCBnb29kIGVub3VnaC4gSGUgY2FuIHNwZWNpZnkgdGhlIGludGVydmFsLiBJdCBpcyBvZnRlbiBhcHBlYXJlZFxuICAvLyBpbiBhbmdsZSBheGlzIHdpdGggYW5nbGUgMCAtIDM2MC4gSW50ZXJ2YWwgY2FsY3VsYXRlZCBpbiBpbnRlcnZhbCBzY2FsZSBpcyBoYXJkXG4gIC8vIHRvIGJlIDYwLlxuICAvLyBGSVhNRVxuXG4gIHZhciBpbnRlcnZhbCA9IG1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcblxuICBpZiAoaW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgIHNjYWxlLnNldEludGVydmFsICYmIHNjYWxlLnNldEludGVydmFsKGludGVydmFsKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtzdHJpbmd9IFtheGlzVHlwZV0gRGVmYXVsdCByZXRyaWV2ZSBmcm9tIG1vZGVsLnR5cGVcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlLyp9XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZUJ5TW9kZWwobW9kZWwsIGF4aXNUeXBlKSB7XG4gIGF4aXNUeXBlID0gYXhpc1R5cGUgfHwgbW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgaWYgKGF4aXNUeXBlKSB7XG4gICAgc3dpdGNoIChheGlzVHlwZSkge1xuICAgICAgLy8gQnVpbGRpbiBzY2FsZVxuICAgICAgY2FzZSAnY2F0ZWdvcnknOlxuICAgICAgICByZXR1cm4gbmV3IE9yZGluYWxTY2FsZShtb2RlbC5nZXRPcmRpbmFsTWV0YSA/IG1vZGVsLmdldE9yZGluYWxNZXRhKCkgOiBtb2RlbC5nZXRDYXRlZ29yaWVzKCksIFtJbmZpbml0eSwgLUluZmluaXR5XSk7XG5cbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgICAvLyBFeHRlbmRlZCBzY2FsZSwgbGlrZSB0aW1lIGFuZCBsb2dcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIChTY2FsZS5nZXRDbGFzcyhheGlzVHlwZSkgfHwgSW50ZXJ2YWxTY2FsZSkuY3JlYXRlKG1vZGVsKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGF4aXMgY29yc3MgMFxuICovXG5cblxuZnVuY3Rpb24gaWZBeGlzQ3Jvc3NaZXJvKGF4aXMpIHtcbiAgdmFyIGRhdGFFeHRlbnQgPSBheGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICB2YXIgbWluID0gZGF0YUV4dGVudFswXTtcbiAgdmFyIG1heCA9IGRhdGFFeHRlbnRbMV07XG4gIHJldHVybiAhKG1pbiA+IDAgJiYgbWF4ID4gMCB8fCBtaW4gPCAwICYmIG1heCA8IDApO1xufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0F4aXN9IGF4aXNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBMYWJlbCBmb3JtYXR0ZXIgZnVuY3Rpb24uXG4gKiAgICAgICAgIHBhcmFtOiB7bnVtYmVyfSB0aWNrVmFsdWUsXG4gKiAgICAgICAgIHBhcmFtOiB7bnVtYmVyfSBpZHgsIHRoZSBpbmRleCBpbiBhbGwgdGlja3MuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBjYXRlZ29yeSBheGlzLCB0aGlzIHBhcmFtIGlzIG5vdCByZXF1aWVkLlxuICogICAgICAgICByZXR1cm46IHtzdHJpbmd9IGxhYmVsIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1ha2VMYWJlbEZvcm1hdHRlcihheGlzKSB7XG4gIHZhciBsYWJlbEZvcm1hdHRlciA9IGF4aXMuZ2V0TGFiZWxNb2RlbCgpLmdldCgnZm9ybWF0dGVyJyk7XG4gIHZhciBjYXRlZ29yeVRpY2tTdGFydCA9IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IGF4aXMuc2NhbGUuZ2V0RXh0ZW50KClbMF0gOiBudWxsO1xuXG4gIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgbGFiZWxGb3JtYXR0ZXIgPSBmdW5jdGlvbiAodHBsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdHBsLnJlcGxhY2UoJ3t2YWx1ZX0nLCB2YWwgIT0gbnVsbCA/IHZhbCA6ICcnKTtcbiAgICAgIH07XG4gICAgfShsYWJlbEZvcm1hdHRlcik7IC8vIENvbnNpZGVyIGVtcHR5IGFycmF5XG5cblxuICAgIHJldHVybiBsYWJlbEZvcm1hdHRlcjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRpY2tWYWx1ZSwgaWR4KSB7XG4gICAgICAvLyBUaGUgb3JpZ2luYWwgaW50ZW50aW9uIG9mIGBpZHhgIGlzIFwidGhlIGluZGV4IG9mIHRoZSB0aWNrIGluIGFsbCB0aWNrc1wiLlxuICAgICAgLy8gQnV0IHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbiBvZiBjYXRlZ29yeSBheGlzIGRvIG5vdCBjb25zaWRlciB0aGVcbiAgICAgIC8vIGBheGlzTGFiZWwuaW50ZXJ2YWxgLCB3aGljaCBjYXVzZSB0aGF0LCBmb3IgZXhhbXBsZSwgdGhlIGBpbnRlcnZhbGAgaXNcbiAgICAgIC8vIGAxYCwgdGhlbiB0aGUgdGlja3MgXCJuYW1lNVwiLCBcIm5hbWU3XCIsIFwibmFtZTlcIiBhcmUgZGlzcGxheWVkLCB3aGVyZSB0aGVcbiAgICAgIC8vIGNvcnJlc3BvbmRpbmcgYGlkeGAgYXJlIGAwYCwgYDJgLCBgNGAsIGJ1dCBub3QgYDBgLCBgMWAsIGAyYC4gU28gd2Uga2VlcFxuICAgICAgLy8gdGhlIGRlZmluaXRpb24gaGVyZSBmb3IgYmFjayBjb21wYXRpYmlsaXR5LlxuICAgICAgaWYgKGNhdGVnb3J5VGlja1N0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgaWR4ID0gdGlja1ZhbHVlIC0gY2F0ZWdvcnlUaWNrU3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYWJlbEZvcm1hdHRlcihnZXRBeGlzUmF3VmFsdWUoYXhpcywgdGlja1ZhbHVlKSwgaWR4KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGljaykge1xuICAgICAgcmV0dXJuIGF4aXMuc2NhbGUuZ2V0TGFiZWwodGljayk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBeGlzUmF3VmFsdWUoYXhpcywgdmFsdWUpIHtcbiAgLy8gSW4gY2F0ZWdvcnkgYXhpcyB3aXRoIGRhdGEgem9vbSwgdGljayBpcyBub3QgdGhlIG9yaWdpbmFsXG4gIC8vIGluZGV4IG9mIGF4aXMuZGF0YS4gU28gdGljayBzaG91bGQgbm90IGJlIGV4cG9zZWQgdG8gdXNlclxuICAvLyBpbiBjYXRlZ29yeSBheGlzLlxuICByZXR1cm4gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gYXhpcy5zY2FsZS5nZXRMYWJlbCh2YWx1ZSkgOiB2YWx1ZTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBheGlzXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gQmUgbnVsbC91bmRlZmluZWQgaWYgbm8gbGFiZWxzLlxuICovXG5cblxuZnVuY3Rpb24gZXN0aW1hdGVMYWJlbFVuaW9uUmVjdChheGlzKSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzLm1vZGVsO1xuICB2YXIgc2NhbGUgPSBheGlzLnNjYWxlO1xuXG4gIGlmICghYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3cnKSB8fCBzY2FsZS5pc0JsYW5rKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaXNDYXRlZ29yeSA9IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgdmFyIHJlYWxOdW1iZXJTY2FsZVRpY2tzO1xuICB2YXIgdGlja0NvdW50O1xuICB2YXIgY2F0ZWdvcnlTY2FsZUV4dGVudCA9IHNjYWxlLmdldEV4dGVudCgpOyAvLyBPcHRpbWl6ZSBmb3IgbGFyZ2UgY2F0ZWdvcnkgZGF0YSwgYXZvaWQgY2FsbCBgZ2V0VGlja3MoKWAuXG5cbiAgaWYgKGlzQ2F0ZWdvcnkpIHtcbiAgICB0aWNrQ291bnQgPSBzY2FsZS5jb3VudCgpO1xuICB9IGVsc2Uge1xuICAgIHJlYWxOdW1iZXJTY2FsZVRpY2tzID0gc2NhbGUuZ2V0VGlja3MoKTtcbiAgICB0aWNrQ291bnQgPSByZWFsTnVtYmVyU2NhbGVUaWNrcy5sZW5ndGg7XG4gIH1cblxuICB2YXIgYXhpc0xhYmVsTW9kZWwgPSBheGlzLmdldExhYmVsTW9kZWwoKTtcbiAgdmFyIGxhYmVsRm9ybWF0dGVyID0gbWFrZUxhYmVsRm9ybWF0dGVyKGF4aXMpO1xuICB2YXIgcmVjdDtcbiAgdmFyIHN0ZXAgPSAxOyAvLyBTaW1wbGUgb3B0aW1pemF0aW9uIGZvciBsYXJnZSBhbW91bnQgb2YgbGFiZWxzXG5cbiAgaWYgKHRpY2tDb3VudCA+IDQwKSB7XG4gICAgc3RlcCA9IE1hdGguY2VpbCh0aWNrQ291bnQgLyA0MCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tDb3VudDsgaSArPSBzdGVwKSB7XG4gICAgdmFyIHRpY2tWYWx1ZSA9IHJlYWxOdW1iZXJTY2FsZVRpY2tzID8gcmVhbE51bWJlclNjYWxlVGlja3NbaV0gOiBjYXRlZ29yeVNjYWxlRXh0ZW50WzBdICsgaTtcbiAgICB2YXIgbGFiZWwgPSBsYWJlbEZvcm1hdHRlcih0aWNrVmFsdWUpO1xuICAgIHZhciB1bnJvdGF0ZWRTaW5nbGVSZWN0ID0gYXhpc0xhYmVsTW9kZWwuZ2V0VGV4dFJlY3QobGFiZWwpO1xuICAgIHZhciBzaW5nbGVSZWN0ID0gcm90YXRlVGV4dFJlY3QodW5yb3RhdGVkU2luZ2xlUmVjdCwgYXhpc0xhYmVsTW9kZWwuZ2V0KCdyb3RhdGUnKSB8fCAwKTtcbiAgICByZWN0ID8gcmVjdC51bmlvbihzaW5nbGVSZWN0KSA6IHJlY3QgPSBzaW5nbGVSZWN0O1xuICB9XG5cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIHJvdGF0ZVRleHRSZWN0KHRleHRSZWN0LCByb3RhdGUpIHtcbiAgdmFyIHJvdGF0ZVJhZGlhbnMgPSByb3RhdGUgKiBNYXRoLlBJIC8gMTgwO1xuICB2YXIgYm91bmRpbmdCb3ggPSB0ZXh0UmVjdC5wbGFpbigpO1xuICB2YXIgYmVmb3JlV2lkdGggPSBib3VuZGluZ0JveC53aWR0aDtcbiAgdmFyIGJlZm9yZUhlaWdodCA9IGJvdW5kaW5nQm94LmhlaWdodDtcbiAgdmFyIGFmdGVyV2lkdGggPSBiZWZvcmVXaWR0aCAqIE1hdGguY29zKHJvdGF0ZVJhZGlhbnMpICsgYmVmb3JlSGVpZ2h0ICogTWF0aC5zaW4ocm90YXRlUmFkaWFucyk7XG4gIHZhciBhZnRlckhlaWdodCA9IGJlZm9yZVdpZHRoICogTWF0aC5zaW4ocm90YXRlUmFkaWFucykgKyBiZWZvcmVIZWlnaHQgKiBNYXRoLmNvcyhyb3RhdGVSYWRpYW5zKTtcbiAgdmFyIHJvdGF0ZWRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChib3VuZGluZ0JveC54LCBib3VuZGluZ0JveC55LCBhZnRlcldpZHRoLCBhZnRlckhlaWdodCk7XG4gIHJldHVybiByb3RhdGVkUmVjdDtcbn1cblxuZXhwb3J0cy5nZXRTY2FsZUV4dGVudCA9IGdldFNjYWxlRXh0ZW50O1xuZXhwb3J0cy5uaWNlU2NhbGVFeHRlbnQgPSBuaWNlU2NhbGVFeHRlbnQ7XG5leHBvcnRzLmNyZWF0ZVNjYWxlQnlNb2RlbCA9IGNyZWF0ZVNjYWxlQnlNb2RlbDtcbmV4cG9ydHMuaWZBeGlzQ3Jvc3NaZXJvID0gaWZBeGlzQ3Jvc3NaZXJvO1xuZXhwb3J0cy5tYWtlTGFiZWxGb3JtYXR0ZXIgPSBtYWtlTGFiZWxGb3JtYXR0ZXI7XG5leHBvcnRzLmdldEF4aXNSYXdWYWx1ZSA9IGdldEF4aXNSYXdWYWx1ZTtcbmV4cG9ydHMuZXN0aW1hdGVMYWJlbFVuaW9uUmVjdCA9IGVzdGltYXRlTGFiZWxVbmlvblJlY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc0hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc0hlbHBlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoXCIuL2F4aXNIZWxwZXJcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBfZGVmYXVsdCA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3JpZ2luXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9IG1pbiB2YWx1ZSBvciAnZGF0YU1pbicgb3IgbnVsbC91bmRlZmluZWQgKG1lYW5zIGF1dG8pIG9yIE5hTlxuICAgKi9cbiAgZ2V0TWluOiBmdW5jdGlvbiAob3JpZ2luKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBtaW4gPSAhb3JpZ2luICYmIG9wdGlvbi5yYW5nZVN0YXJ0ICE9IG51bGwgPyBvcHRpb24ucmFuZ2VTdGFydCA6IG9wdGlvbi5taW47XG5cbiAgICBpZiAodGhpcy5heGlzICYmIG1pbiAhPSBudWxsICYmIG1pbiAhPT0gJ2RhdGFNaW4nICYmIHR5cGVvZiBtaW4gIT09ICdmdW5jdGlvbicgJiYgIXpyVXRpbC5lcU5hTihtaW4pKSB7XG4gICAgICBtaW4gPSB0aGlzLmF4aXMuc2NhbGUucGFyc2UobWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9yaWdpblxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfSBtYXggdmFsdWUgb3IgJ2RhdGFNYXgnIG9yIG51bGwvdW5kZWZpbmVkIChtZWFucyBhdXRvKSBvciBOYU5cbiAgICovXG4gIGdldE1heDogZnVuY3Rpb24gKG9yaWdpbikge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgbWF4ID0gIW9yaWdpbiAmJiBvcHRpb24ucmFuZ2VFbmQgIT0gbnVsbCA/IG9wdGlvbi5yYW5nZUVuZCA6IG9wdGlvbi5tYXg7XG5cbiAgICBpZiAodGhpcy5heGlzICYmIG1heCAhPSBudWxsICYmIG1heCAhPT0gJ2RhdGFNYXgnICYmIHR5cGVvZiBtYXggIT09ICdmdW5jdGlvbicgJiYgIXpyVXRpbC5lcU5hTihtYXgpKSB7XG4gICAgICBtYXggPSB0aGlzLmF4aXMuc2NhbGUucGFyc2UobWF4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZ2V0TmVlZENyb3NzWmVybzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICByZXR1cm4gb3B0aW9uLnJhbmdlU3RhcnQgIT0gbnVsbCB8fCBvcHRpb24ucmFuZ2VFbmQgIT0gbnVsbCA/IGZhbHNlIDogIW9wdGlvbi5zY2FsZTtcbiAgfSxcblxuICAvKipcbiAgICogU2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggYXhpcyBtb2RlbCBpZiBuZWNlc3NhcnkuXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29vcmRpbmF0ZSBzeXN0ZW0gbW9kZWxcbiAgICovXG4gIGdldENvb3JkU3lzTW9kZWw6IHpyVXRpbC5ub29wLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFuZ2VTdGFydCBDYW4gb25seSBiZSBmaW5pdGUgbnVtYmVyIG9yIG51bGwvdW5kZWZpbmVkIG9yIE5hTi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlRW5kIENhbiBvbmx5IGJlIGZpbml0ZSBudW1iZXIgb3IgbnVsbC91bmRlZmluZWQgb3IgTmFOLlxuICAgKi9cbiAgc2V0UmFuZ2U6IGZ1bmN0aW9uIChyYW5nZVN0YXJ0LCByYW5nZUVuZCkge1xuICAgIHRoaXMub3B0aW9uLnJhbmdlU3RhcnQgPSByYW5nZVN0YXJ0O1xuICAgIHRoaXMub3B0aW9uLnJhbmdlRW5kID0gcmFuZ2VFbmQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0IHJhbmdlXG4gICAqL1xuICByZXNldFJhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmFuZ2VTdGFydCBhbmQgcmFuZ2VFbmQgaXMgcmVhZG9ubHkuXG4gICAgdGhpcy5vcHRpb24ucmFuZ2VTdGFydCA9IHRoaXMub3B0aW9uLnJhbmdlRW5kID0gbnVsbDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENvbW1vbk1peGluLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBheGlzRGVmYXVsdCA9IHJlcXVpcmUoXCIuL2F4aXNEZWZhdWx0XCIpO1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKFwiLi4vbW9kZWwvQ29tcG9uZW50XCIpO1xuXG52YXIgX2xheW91dCA9IHJlcXVpcmUoXCIuLi91dGlsL2xheW91dFwiKTtcblxudmFyIGdldExheW91dFBhcmFtcyA9IF9sYXlvdXQuZ2V0TGF5b3V0UGFyYW1zO1xudmFyIG1lcmdlTGF5b3V0UGFyYW0gPSBfbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW07XG5cbnZhciBPcmRpbmFsTWV0YSA9IHJlcXVpcmUoXCIuLi9kYXRhL09yZGluYWxNZXRhXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBGSVhNRSBheGlzVHlwZSBpcyBmaXhlZCA/XG52YXIgQVhJU19UWVBFUyA9IFsndmFsdWUnLCAnY2F0ZWdvcnknLCAndGltZScsICdsb2cnXTtcbi8qKlxuICogR2VuZXJhdGUgc3ViIGF4aXMgbW9kZWwgY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzTmFtZSAneCcgJ3knICdyYWRpdXMnICdhbmdsZScgJ3BhcmFsbGVsJ1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IEJhc2VBeGlzTW9kZWxDbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gYXhpc1R5cGVEZWZhdWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFEZWZhdWx0T3B0aW9uXVxuICovXG5cbmZ1bmN0aW9uIF9kZWZhdWx0KGF4aXNOYW1lLCBCYXNlQXhpc01vZGVsQ2xhc3MsIGF4aXNUeXBlRGVmYXVsdGVyLCBleHRyYURlZmF1bHRPcHRpb24pIHtcbiAgenJVdGlsLmVhY2goQVhJU19UWVBFUywgZnVuY3Rpb24gKGF4aXNUeXBlKSB7XG4gICAgQmFzZUF4aXNNb2RlbENsYXNzLmV4dGVuZCh7XG4gICAgICAvKipcbiAgICAgICAqIEByZWFkT25seVxuICAgICAgICovXG4gICAgICB0eXBlOiBheGlzTmFtZSArICdBeGlzLicgKyBheGlzVHlwZSxcbiAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGUgPyBnZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9O1xuICAgICAgICB2YXIgdGhlbWVNb2RlbCA9IGVjTW9kZWwuZ2V0VGhlbWUoKTtcbiAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhlbWVNb2RlbC5nZXQoYXhpc1R5cGUgKyAnQXhpcycpKTtcbiAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpO1xuICAgICAgICBvcHRpb24udHlwZSA9IGF4aXNUeXBlRGVmYXVsdGVyKGF4aXNOYW1lLCBvcHRpb24pO1xuXG4gICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgbWVyZ2VMYXlvdXRQYXJhbShvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMsIGxheW91dE1vZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBvcHRpb25VcGRhdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG5cbiAgICAgICAgaWYgKHRoaXNPcHRpb24udHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgIHRoaXMuX19vcmRpbmFsTWV0YSA9IE9yZGluYWxNZXRhLmNyZWF0ZUJ5QXhpc01vZGVsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNob3VsZCBub3QgYmUgY2FsbGVkIGJlZm9yZSBhbGwgb2YgJ2dldEluaXRhaWxEYXRhJyBmaW5pc2hlZC5cbiAgICAgICAqIEJlY2F1c2UgY2F0ZWdvcmllcyBhcmUgY29sbGVjdGVkIGR1cmluZyBpbml0aWFsaXppbmcgZGF0YS5cbiAgICAgICAqL1xuICAgICAgZ2V0Q2F0ZWdvcmllczogZnVuY3Rpb24gKHJhd0RhdGEpIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uOyAvLyBGSVhNRVxuICAgICAgICAvLyB3YXJuaW5nIGlmIGNhbGxlZCBiZWZvcmUgYWxsIG9mICdnZXRJbml0YWlsRGF0YScgZmluaXNoZWQuXG5cbiAgICAgICAgaWYgKG9wdGlvbi50eXBlID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgaWYgKHJhd0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uZGF0YTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5fX29yZGluYWxNZXRhLmNhdGVnb3JpZXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRPcmRpbmFsTWV0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29yZGluYWxNZXRhO1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHRPcHRpb246IHpyVXRpbC5tZXJnZUFsbChbe30sIGF4aXNEZWZhdWx0W2F4aXNUeXBlICsgJ0F4aXMnXSwgZXh0cmFEZWZhdWx0T3B0aW9uXSwgdHJ1ZSlcbiAgICB9KTtcbiAgfSk7XG4gIENvbXBvbmVudE1vZGVsLnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcihheGlzTmFtZSArICdBeGlzJywgenJVdGlsLmN1cnJ5KGF4aXNUeXBlRGVmYXVsdGVyLCBheGlzTmFtZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3IuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIF9tb2RlbCA9IHJlcXVpcmUoXCIuLi91dGlsL21vZGVsXCIpO1xuXG52YXIgbWFrZUlubmVyID0gX21vZGVsLm1ha2VJbm5lcjtcblxudmFyIF9heGlzSGVscGVyID0gcmVxdWlyZShcIi4vYXhpc0hlbHBlclwiKTtcblxudmFyIG1ha2VMYWJlbEZvcm1hdHRlciA9IF9heGlzSGVscGVyLm1ha2VMYWJlbEZvcm1hdHRlcjtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGlubmVyID0gbWFrZUlubmVyKCk7XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGF0cy9jb29yZC9BeGlzfSBheGlzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHtcbiAqICAgICBsYWJlbHM6IFt7XG4gKiAgICAgICAgIGZvcm1hdHRlZExhYmVsOiBzdHJpbmcsXG4gKiAgICAgICAgIHJhd0xhYmVsOiBzdHJpbmcsXG4gKiAgICAgICAgIHRpY2tWYWx1ZTogbnVtYmVyXG4gKiAgICAgfSwgLi4uXSxcbiAqICAgICBsYWJlbENhdGVnb3J5SW50ZXJ2YWw6IG51bWJlclxuICogfVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUF4aXNMYWJlbHMoYXhpcykge1xuICAvLyBPbmx5IG9yZGluYWwgc2NhbGUgc3VwcG9ydCB0aWNrIGludGVydmFsXG4gIHJldHVybiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBtYWtlQ2F0ZWdvcnlMYWJlbHMoYXhpcykgOiBtYWtlUmVhbE51bWJlckxhYmVscyhheGlzKTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXRzL2Nvb3JkL0F4aXN9IGF4aXNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHRpY2tNb2RlbCBGb3IgZXhhbXBsZSwgY2FuIGJlIGF4aXNUaWNrLCBzcGxpdExpbmUsIHNwbGl0QXJlYS5cbiAqIEByZXR1cm4ge09iamVjdH0ge1xuICogICAgIHRpY2tzOiBBcnJheS48bnVtYmVyPlxuICogICAgIHRpY2tDYXRlZ29yeUludGVydmFsOiBudW1iZXJcbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUF4aXNUaWNrcyhheGlzLCB0aWNrTW9kZWwpIHtcbiAgLy8gT25seSBvcmRpbmFsIHNjYWxlIHN1cHBvcnQgdGljayBpbnRlcnZhbFxuICByZXR1cm4gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gbWFrZUNhdGVnb3J5VGlja3MoYXhpcywgdGlja01vZGVsKSA6IHtcbiAgICB0aWNrczogYXhpcy5zY2FsZS5nZXRUaWNrcygpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VDYXRlZ29yeUxhYmVscyhheGlzKSB7XG4gIHZhciBsYWJlbE1vZGVsID0gYXhpcy5nZXRMYWJlbE1vZGVsKCk7XG4gIHZhciByZXN1bHQgPSBtYWtlQ2F0ZWdvcnlMYWJlbHNBY3R1YWxseShheGlzLCBsYWJlbE1vZGVsKTtcbiAgcmV0dXJuICFsYWJlbE1vZGVsLmdldCgnc2hvdycpIHx8IGF4aXMuc2NhbGUuaXNCbGFuaygpID8ge1xuICAgIGxhYmVsczogW10sXG4gICAgbGFiZWxDYXRlZ29yeUludGVydmFsOiByZXN1bHQubGFiZWxDYXRlZ29yeUludGVydmFsXG4gIH0gOiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VDYXRlZ29yeUxhYmVsc0FjdHVhbGx5KGF4aXMsIGxhYmVsTW9kZWwpIHtcbiAgdmFyIGxhYmVsc0NhY2hlID0gZ2V0TGlzdENhY2hlKGF4aXMsICdsYWJlbHMnKTtcbiAgdmFyIG9wdGlvbkxhYmVsSW50ZXJ2YWwgPSBnZXRPcHRpb25DYXRlZ29yeUludGVydmFsKGxhYmVsTW9kZWwpO1xuICB2YXIgcmVzdWx0ID0gbGlzdENhY2hlR2V0KGxhYmVsc0NhY2hlLCBvcHRpb25MYWJlbEludGVydmFsKTtcblxuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBsYWJlbHM7XG4gIHZhciBudW1lcmljTGFiZWxJbnRlcnZhbDtcblxuICBpZiAoenJVdGlsLmlzRnVuY3Rpb24ob3B0aW9uTGFiZWxJbnRlcnZhbCkpIHtcbiAgICBsYWJlbHMgPSBtYWtlTGFiZWxzQnlDdXN0b21pemVkQ2F0ZWdvcnlJbnRlcnZhbChheGlzLCBvcHRpb25MYWJlbEludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBudW1lcmljTGFiZWxJbnRlcnZhbCA9IG9wdGlvbkxhYmVsSW50ZXJ2YWwgPT09ICdhdXRvJyA/IG1ha2VBdXRvQ2F0ZWdvcnlJbnRlcnZhbChheGlzKSA6IG9wdGlvbkxhYmVsSW50ZXJ2YWw7XG4gICAgbGFiZWxzID0gbWFrZUxhYmVsc0J5TnVtZXJpY0NhdGVnb3J5SW50ZXJ2YWwoYXhpcywgbnVtZXJpY0xhYmVsSW50ZXJ2YWwpO1xuICB9IC8vIENhY2hlIHRvIGF2b2lkIGNhbGxpbmcgaW50ZXJ2YWwgZnVuY3Rpb24gcmVwZWF0bHkuXG5cblxuICByZXR1cm4gbGlzdENhY2hlU2V0KGxhYmVsc0NhY2hlLCBvcHRpb25MYWJlbEludGVydmFsLCB7XG4gICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgbGFiZWxDYXRlZ29yeUludGVydmFsOiBudW1lcmljTGFiZWxJbnRlcnZhbFxuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZUNhdGVnb3J5VGlja3MoYXhpcywgdGlja01vZGVsKSB7XG4gIHZhciB0aWNrc0NhY2hlID0gZ2V0TGlzdENhY2hlKGF4aXMsICd0aWNrcycpO1xuICB2YXIgb3B0aW9uVGlja0ludGVydmFsID0gZ2V0T3B0aW9uQ2F0ZWdvcnlJbnRlcnZhbCh0aWNrTW9kZWwpO1xuICB2YXIgcmVzdWx0ID0gbGlzdENhY2hlR2V0KHRpY2tzQ2FjaGUsIG9wdGlvblRpY2tJbnRlcnZhbCk7XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgdGlja3M7XG4gIHZhciB0aWNrQ2F0ZWdvcnlJbnRlcnZhbDsgLy8gT3B0aW1pemUgZm9yIHRoZSBjYXNlIHRoYXQgbGFyZ2UgY2F0ZWdvcnkgZGF0YSBhbmQgbm8gbGFiZWwgZGlzcGxheWVkLFxuICAvLyB3ZSBzaG91bGQgbm90IHJldHVybiBhbGwgdGlja3MuXG5cbiAgaWYgKCF0aWNrTW9kZWwuZ2V0KCdzaG93JykgfHwgYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICB0aWNrcyA9IFtdO1xuICB9XG5cbiAgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKG9wdGlvblRpY2tJbnRlcnZhbCkpIHtcbiAgICB0aWNrcyA9IG1ha2VMYWJlbHNCeUN1c3RvbWl6ZWRDYXRlZ29yeUludGVydmFsKGF4aXMsIG9wdGlvblRpY2tJbnRlcnZhbCwgdHJ1ZSk7XG4gIH0gLy8gQWx3YXlzIHVzZSBsYWJlbCBpbnRlcnZhbCBieSBkZWZhdWx0IGRlc3BpdGUgbGFiZWwgc2hvdy4gQ29uc2lkZXIgdGhpc1xuICAvLyBzY2VuYXJpbywgVXNlIG11bHRpcGxlIGdyaWQgd2l0aCB0aGUgeEF4aXMgc3luYywgYW5kIG9ubHkgb25lIHhBeGlzIHNob3dzXG4gIC8vIGxhYmVscy4gYHNwbGl0TGluZWAgYW5kIGBheGlzVGlja2Agc2hvdWxkIGJlIGNvbnNpc3RlbnQgaW4gdGhpcyBjYXNlLlxuICBlbHNlIGlmIChvcHRpb25UaWNrSW50ZXJ2YWwgPT09ICdhdXRvJykge1xuICAgICAgdmFyIGxhYmVsc1Jlc3VsdCA9IG1ha2VDYXRlZ29yeUxhYmVsc0FjdHVhbGx5KGF4aXMsIGF4aXMuZ2V0TGFiZWxNb2RlbCgpKTtcbiAgICAgIHRpY2tDYXRlZ29yeUludGVydmFsID0gbGFiZWxzUmVzdWx0LmxhYmVsQ2F0ZWdvcnlJbnRlcnZhbDtcbiAgICAgIHRpY2tzID0genJVdGlsLm1hcChsYWJlbHNSZXN1bHQubGFiZWxzLCBmdW5jdGlvbiAobGFiZWxJdGVtKSB7XG4gICAgICAgIHJldHVybiBsYWJlbEl0ZW0udGlja1ZhbHVlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tDYXRlZ29yeUludGVydmFsID0gb3B0aW9uVGlja0ludGVydmFsO1xuICAgICAgdGlja3MgPSBtYWtlTGFiZWxzQnlOdW1lcmljQ2F0ZWdvcnlJbnRlcnZhbChheGlzLCB0aWNrQ2F0ZWdvcnlJbnRlcnZhbCwgdHJ1ZSk7XG4gICAgfSAvLyBDYWNoZSB0byBhdm9pZCBjYWxsaW5nIGludGVydmFsIGZ1bmN0aW9uIHJlcGVhdGx5LlxuXG5cbiAgcmV0dXJuIGxpc3RDYWNoZVNldCh0aWNrc0NhY2hlLCBvcHRpb25UaWNrSW50ZXJ2YWwsIHtcbiAgICB0aWNrczogdGlja3MsXG4gICAgdGlja0NhdGVnb3J5SW50ZXJ2YWw6IHRpY2tDYXRlZ29yeUludGVydmFsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlUmVhbE51bWJlckxhYmVscyhheGlzKSB7XG4gIHZhciB0aWNrcyA9IGF4aXMuc2NhbGUuZ2V0VGlja3MoKTtcbiAgdmFyIGxhYmVsRm9ybWF0dGVyID0gbWFrZUxhYmVsRm9ybWF0dGVyKGF4aXMpO1xuICByZXR1cm4ge1xuICAgIGxhYmVsczogenJVdGlsLm1hcCh0aWNrcywgZnVuY3Rpb24gKHRpY2tWYWx1ZSwgaWR4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXR0ZWRMYWJlbDogbGFiZWxGb3JtYXR0ZXIodGlja1ZhbHVlLCBpZHgpLFxuICAgICAgICByYXdMYWJlbDogYXhpcy5zY2FsZS5nZXRMYWJlbCh0aWNrVmFsdWUpLFxuICAgICAgICB0aWNrVmFsdWU6IHRpY2tWYWx1ZVxuICAgICAgfTtcbiAgICB9KVxuICB9O1xufSAvLyBMYXJnZSBjYXRlZ29yeSBkYXRhIGNhbGN1bGF0aW9uIGlzIHBlcmZvcm1lbmNlIHNlbnNpdGl2ZSwgYW5kIHRpY2tzIGFuZCBsYWJlbFxuLy8gcHJvYmFibHkgYmUgZmV0Y2hlZCBieSBtdWx0aXBsZSB0aW1lcy4gU28gd2UgY2FjaGUgdGhlIHJlc3VsdC5cbi8vIGF4aXMgaXMgY3JlYXRlZCBlYWNoIHRpbWUgZHVyaW5nIGEgZWMgcHJvY2Vzcywgc28gd2UgZG8gbm90IG5lZWQgdG8gY2xlYXIgY2FjaGUuXG5cblxuZnVuY3Rpb24gZ2V0TGlzdENhY2hlKGF4aXMsIHByb3ApIHtcbiAgLy8gQmVjYXVzZSBrZXkgY2FuIGJlIGZ1bmNpdG9uLCBhbmQgY2FjaGUgc2l6ZSBhbHdheXMgYmUgc21hbGwsIHdlIHVzZSBhcnJheSBjYWNoZS5cbiAgcmV0dXJuIGlubmVyKGF4aXMpW3Byb3BdIHx8IChpbm5lcihheGlzKVtwcm9wXSA9IFtdKTtcbn1cblxuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGNhY2hlLCBrZXkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjYWNoZVtpXS5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2ldLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoY2FjaGUsIGtleSwgdmFsdWUpIHtcbiAgY2FjaGUucHVzaCh7XG4gICAga2V5OiBrZXksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIG1ha2VBdXRvQ2F0ZWdvcnlJbnRlcnZhbChheGlzKSB7XG4gIHZhciByZXN1bHQgPSBpbm5lcihheGlzKS5hdXRvSW50ZXJ2YWw7XG4gIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGlubmVyKGF4aXMpLmF1dG9JbnRlcnZhbCA9IGF4aXMuY2FsY3VsYXRlQ2F0ZWdvcnlJbnRlcnZhbCgpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgaW50ZXJ2YWwgZm9yIGNhdGVnb3J5IGF4aXMgdGlja3MgYW5kIGxhYmVscy5cbiAqIFRvIGdldCBwcmVjaXNlIHJlc3VsdCwgYXQgbGVhc3Qgb25lIG9mIGBnZXRSb3RhdGVgIGFuZCBgaXNIb3Jpem9udGFsYFxuICogc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGF4aXMuXG4gKi9cblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVDYXRlZ29yeUludGVydmFsKGF4aXMpIHtcbiAgdmFyIHBhcmFtcyA9IGZldGNoQXV0b0NhdGVnb3J5SW50ZXJ2YWxDYWxjdWxhdGlvblBhcmFtcyhheGlzKTtcbiAgdmFyIGxhYmVsRm9ybWF0dGVyID0gbWFrZUxhYmVsRm9ybWF0dGVyKGF4aXMpO1xuICB2YXIgcm90YXRpb24gPSAocGFyYW1zLmF4aXNSb3RhdGUgLSBwYXJhbXMubGFiZWxSb3RhdGUpIC8gMTgwICogTWF0aC5QSTtcbiAgdmFyIG9yZGluYWxTY2FsZSA9IGF4aXMuc2NhbGU7XG4gIHZhciBvcmRpbmFsRXh0ZW50ID0gb3JkaW5hbFNjYWxlLmdldEV4dGVudCgpOyAvLyBQcm92aWRpbmcgdGhpcyBtZXRob2QgaXMgZm9yIG9wdGltaXphdGlvbjpcbiAgLy8gYXZvaWQgZ2VuZXJhdGluZyBhIGxvbmcgYXJyYXkgYnkgYGdldFRpY2tzYFxuICAvLyBpbiBsYXJnZSBjYXRlZ29yeSBkYXRhIGNhc2UuXG5cbiAgdmFyIHRpY2tDb3VudCA9IG9yZGluYWxTY2FsZS5jb3VudCgpO1xuXG4gIGlmIChvcmRpbmFsRXh0ZW50WzFdIC0gb3JkaW5hbEV4dGVudFswXSA8IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzdGVwID0gMTsgLy8gU2ltcGxlIG9wdGltaXphdGlvbi4gRW1waXJpY2FsIHZhbHVlOiB0aWNrIGNvdW50IHNob3VsZCBsZXNzIHRoYW4gNDAuXG5cbiAgaWYgKHRpY2tDb3VudCA+IDQwKSB7XG4gICAgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodGlja0NvdW50IC8gNDApKTtcbiAgfVxuXG4gIHZhciB0aWNrVmFsdWUgPSBvcmRpbmFsRXh0ZW50WzBdO1xuICB2YXIgdW5pdFNwYW4gPSBheGlzLmRhdGFUb0Nvb3JkKHRpY2tWYWx1ZSArIDEpIC0gYXhpcy5kYXRhVG9Db29yZCh0aWNrVmFsdWUpO1xuICB2YXIgdW5pdFcgPSBNYXRoLmFicyh1bml0U3BhbiAqIE1hdGguY29zKHJvdGF0aW9uKSk7XG4gIHZhciB1bml0SCA9IE1hdGguYWJzKHVuaXRTcGFuICogTWF0aC5zaW4ocm90YXRpb24pKTtcbiAgdmFyIG1heFcgPSAwO1xuICB2YXIgbWF4SCA9IDA7IC8vIENhdXRpb246IFBlcmZvcm1hbmNlIHNlbnNpdGl2ZSBmb3IgbGFyZ2UgY2F0ZWdvcnkgZGF0YS5cbiAgLy8gQ29uc2lkZXIgZGF0YVpvb20sIHdlIHNob3VsZCBtYWtlIGFwcHJvcHJpYXRlIHN0ZXAgdG8gYXZvaWQgTyhuKSBsb29wLlxuXG4gIGZvciAoOyB0aWNrVmFsdWUgPD0gb3JkaW5hbEV4dGVudFsxXTsgdGlja1ZhbHVlICs9IHN0ZXApIHtcbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIHZhciBoZWlnaHQgPSAwOyAvLyBQb2xhciBpcyBhbHNvIGNhbGN1bGF0ZWQgaW4gYXNzdW1wdGl2ZSBsaW5lYXIgbGF5b3V0IGhlcmUuXG4gICAgLy8gTm90IHByZWNpc2UsIGRvIG5vdCBjb25zaWRlciBhbGlnbiBhbmQgdmVydGljYWwgYWxpZ25cbiAgICAvLyBhbmQgZWFjaCBkaXN0YW5jZSBmcm9tIGF4aXMgbGluZSB5ZXQuXG5cbiAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChsYWJlbEZvcm1hdHRlcih0aWNrVmFsdWUpLCBwYXJhbXMuZm9udCwgJ2NlbnRlcicsICd0b3AnKTsgLy8gTWFnaWMgbnVtYmVyXG5cbiAgICB3aWR0aCA9IHJlY3Qud2lkdGggKiAxLjM7XG4gICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKiAxLjM7IC8vIE1pbiBzaXplLCB2b2lkIGxvbmcgbG9vcC5cblxuICAgIG1heFcgPSBNYXRoLm1heChtYXhXLCB3aWR0aCwgNyk7XG4gICAgbWF4SCA9IE1hdGgubWF4KG1heEgsIGhlaWdodCwgNyk7XG4gIH1cblxuICB2YXIgZHcgPSBtYXhXIC8gdW5pdFc7XG4gIHZhciBkaCA9IG1heEggLyB1bml0SDsgLy8gMC8wIGlzIE5hTiwgMS8wIGlzIEluZmluaXR5LlxuXG4gIGlzTmFOKGR3KSAmJiAoZHcgPSBJbmZpbml0eSk7XG4gIGlzTmFOKGRoKSAmJiAoZGggPSBJbmZpbml0eSk7XG4gIHZhciBpbnRlcnZhbCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoTWF0aC5taW4oZHcsIGRoKSkpO1xuICB2YXIgY2FjaGUgPSBpbm5lcihheGlzLm1vZGVsKTtcbiAgdmFyIGxhc3RBdXRvSW50ZXJ2YWwgPSBjYWNoZS5sYXN0QXV0b0ludGVydmFsO1xuICB2YXIgbGFzdFRpY2tDb3VudCA9IGNhY2hlLmxhc3RUaWNrQ291bnQ7IC8vIFVzZSBjYWNoZSB0byBrZWVwIGludGVydmFsIHN0YWJsZSB3aGlsZSBtb3Zpbmcgem9vbSB3aW5kb3csXG4gIC8vIG90aGVyd2lzZSB0aGUgY2FsY3VsYXRlZCBpbnRlcnZhbCBtaWdodCBqaXR0ZXIgd2hlbiB0aGUgem9vbVxuICAvLyB3aW5kb3cgc2l6ZSBpcyBjbG9zZSB0byB0aGUgaW50ZXJ2YWwtY2hhbmdpbmcgc2l6ZS5cblxuICBpZiAobGFzdEF1dG9JbnRlcnZhbCAhPSBudWxsICYmIGxhc3RUaWNrQ291bnQgIT0gbnVsbCAmJiBNYXRoLmFicyhsYXN0QXV0b0ludGVydmFsIC0gaW50ZXJ2YWwpIDw9IDEgJiYgTWF0aC5hYnMobGFzdFRpY2tDb3VudCAtIHRpY2tDb3VudCkgPD0gMSAvLyBBbHdheXMgY2hvb3NlIHRoZSBiaWdnZXIgb25lLCBvdGhlcndpc2UgdGhlIGNyaXRpY2FsXG4gIC8vIHBvaW50IGlzIG5vdCB0aGUgc2FtZSB3aGVuIHpvb21pbmcgaW4gb3Igem9vbWluZyBvdXQuXG4gICYmIGxhc3RBdXRvSW50ZXJ2YWwgPiBpbnRlcnZhbCkge1xuICAgIGludGVydmFsID0gbGFzdEF1dG9JbnRlcnZhbDtcbiAgfSAvLyBPbmx5IHVwZGF0ZSBjYWNoZSBpZiBjYWNoZSBub3QgdXNlZCwgb3RoZXJ3aXNlIHRoZVxuICAvLyBjaGFuZ2luZyBvZiBpbnRlcnZhbCBpcyB0b28gaW5zZW5zaXRpdmUuXG4gIGVsc2Uge1xuICAgICAgY2FjaGUubGFzdFRpY2tDb3VudCA9IHRpY2tDb3VudDtcbiAgICAgIGNhY2hlLmxhc3RBdXRvSW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICB9XG5cbiAgcmV0dXJuIGludGVydmFsO1xufVxuXG5mdW5jdGlvbiBmZXRjaEF1dG9DYXRlZ29yeUludGVydmFsQ2FsY3VsYXRpb25QYXJhbXMoYXhpcykge1xuICB2YXIgbGFiZWxNb2RlbCA9IGF4aXMuZ2V0TGFiZWxNb2RlbCgpO1xuICByZXR1cm4ge1xuICAgIGF4aXNSb3RhdGU6IGF4aXMuZ2V0Um90YXRlID8gYXhpcy5nZXRSb3RhdGUoKSA6IGF4aXMuaXNIb3Jpem9udGFsICYmICFheGlzLmlzSG9yaXpvbnRhbCgpID8gOTAgOiAwLFxuICAgIGxhYmVsUm90YXRlOiBsYWJlbE1vZGVsLmdldCgncm90YXRlJykgfHwgMCxcbiAgICBmb250OiBsYWJlbE1vZGVsLmdldEZvbnQoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlTGFiZWxzQnlOdW1lcmljQ2F0ZWdvcnlJbnRlcnZhbChheGlzLCBjYXRlZ29yeUludGVydmFsLCBvbmx5VGljaykge1xuICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBtYWtlTGFiZWxGb3JtYXR0ZXIoYXhpcyk7XG4gIHZhciBvcmRpbmFsU2NhbGUgPSBheGlzLnNjYWxlO1xuICB2YXIgb3JkaW5hbEV4dGVudCA9IG9yZGluYWxTY2FsZS5nZXRFeHRlbnQoKTtcbiAgdmFyIGxhYmVsTW9kZWwgPSBheGlzLmdldExhYmVsTW9kZWwoKTtcbiAgdmFyIHJlc3VsdCA9IFtdOyAvLyBUT0RPOiBheGlzVHlwZTogb3JkaW5hbFRpbWUsIHBpY2sgdGhlIHRpY2sgZnJvbSBlYWNoIG1vbnRoL2RheS95ZWFyLy4uLlxuXG4gIHZhciBzdGVwID0gTWF0aC5tYXgoKGNhdGVnb3J5SW50ZXJ2YWwgfHwgMCkgKyAxLCAxKTtcbiAgdmFyIHN0YXJ0VGljayA9IG9yZGluYWxFeHRlbnRbMF07XG4gIHZhciB0aWNrQ291bnQgPSBvcmRpbmFsU2NhbGUuY291bnQoKTsgLy8gQ2FsY3VsYXRlIHN0YXJ0IHRpY2sgYmFzZWQgb24gemVybyBpZiBwb3NzaWJsZSB0byBrZWVwIGxhYmVsIGNvbnNpc3RlbnRcbiAgLy8gd2hpbGUgem9vbWluZyBhbmQgbW92aW5nIHdoaWxlIGludGVydmFsID4gMC4gT3RoZXJ3aXNlIHRoZSBzZWxlY3Rpb25cbiAgLy8gb2YgZGlzcGxheWFibGUgdGlja3MgYW5kIHN5bWJvbHMgcHJvYmFibHkga2VlcCBjaGFuZ2luZy5cbiAgLy8gMyBpcyBlbXBpcmljYWwgdmFsdWUuXG5cbiAgaWYgKHN0YXJ0VGljayAhPT0gMCAmJiBzdGVwID4gMSAmJiB0aWNrQ291bnQgLyBzdGVwID4gMikge1xuICAgIHN0YXJ0VGljayA9IE1hdGgucm91bmQoTWF0aC5jZWlsKHN0YXJ0VGljayAvIHN0ZXApICogc3RlcCk7XG4gIH0gLy8gKDEpIE9ubHkgYWRkIG1pbiBtYXggbGFiZWwgaGVyZSBidXQgbGVhdmUgb3ZlcmxhcCBjaGVja2luZ1xuICAvLyB0byByZW5kZXIgc3RhZ2UsIHdoaWNoIGFsc28gZW5zdXJlIHRoZSByZXR1cm5lZCBsaXN0XG4gIC8vIHN1aXRhYmxlIGZvciBzcGxpdExpbmUgYW5kIHNwbGl0QXJlYSByZW5kZXJpbmcuXG4gIC8vICgyKSBTY2FsZXMgZXhjZXB0IGNhdGVnb3J5IGFsd2F5cyBjb250YWluIG1pbiBtYXggbGFiZWwgc29cbiAgLy8gZG8gbm90IG5lZWQgdG8gcGVyZm9ybSB0aGlzIHByb2Nlc3MuXG5cblxuICB2YXIgc2hvd01pbk1heCA9IHtcbiAgICBtaW46IGxhYmVsTW9kZWwuZ2V0KCdzaG93TWluTGFiZWwnKSxcbiAgICBtYXg6IGxhYmVsTW9kZWwuZ2V0KCdzaG93TWF4TGFiZWwnKVxuICB9O1xuXG4gIGlmIChzaG93TWluTWF4Lm1pbiAmJiBzdGFydFRpY2sgIT09IG9yZGluYWxFeHRlbnRbMF0pIHtcbiAgICBhZGRJdGVtKG9yZGluYWxFeHRlbnRbMF0pO1xuICB9IC8vIE9wdGltaXplOiBhdm9pZCBnZW5lcmF0aW5nIGxhcmdlIGFycmF5IGJ5IGBvcmRpbmFsU2NhbGUuZ2V0VGlja3MoKWAuXG5cblxuICB2YXIgdGlja1ZhbHVlID0gc3RhcnRUaWNrO1xuXG4gIGZvciAoOyB0aWNrVmFsdWUgPD0gb3JkaW5hbEV4dGVudFsxXTsgdGlja1ZhbHVlICs9IHN0ZXApIHtcbiAgICBhZGRJdGVtKHRpY2tWYWx1ZSk7XG4gIH1cblxuICBpZiAoc2hvd01pbk1heC5tYXggJiYgdGlja1ZhbHVlICE9PSBvcmRpbmFsRXh0ZW50WzFdKSB7XG4gICAgYWRkSXRlbShvcmRpbmFsRXh0ZW50WzFdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEl0ZW0odFZhbCkge1xuICAgIHJlc3VsdC5wdXNoKG9ubHlUaWNrID8gdFZhbCA6IHtcbiAgICAgIGZvcm1hdHRlZExhYmVsOiBsYWJlbEZvcm1hdHRlcih0VmFsKSxcbiAgICAgIHJhd0xhYmVsOiBvcmRpbmFsU2NhbGUuZ2V0TGFiZWwodFZhbCksXG4gICAgICB0aWNrVmFsdWU6IHRWYWxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59IC8vIFdoZW4gaW50ZXJ2YWwgaXMgZnVuY3Rpb24sIHRoZSByZXN1bHQgYGZhbHNlYCBtZWFucyBpZ25vcmUgdGhlIHRpY2suXG4vLyBJdCBpcyB0aW1lIGNvbnN1bWluZyBmb3IgbGFyZ2UgY2F0ZWdvcnkgZGF0YS5cblxuXG5mdW5jdGlvbiBtYWtlTGFiZWxzQnlDdXN0b21pemVkQ2F0ZWdvcnlJbnRlcnZhbChheGlzLCBjYXRlZ29yeUludGVydmFsLCBvbmx5VGljaykge1xuICB2YXIgb3JkaW5hbFNjYWxlID0gYXhpcy5zY2FsZTtcbiAgdmFyIGxhYmVsRm9ybWF0dGVyID0gbWFrZUxhYmVsRm9ybWF0dGVyKGF4aXMpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHpyVXRpbC5lYWNoKG9yZGluYWxTY2FsZS5nZXRUaWNrcygpLCBmdW5jdGlvbiAodGlja1ZhbHVlKSB7XG4gICAgdmFyIHJhd0xhYmVsID0gb3JkaW5hbFNjYWxlLmdldExhYmVsKHRpY2tWYWx1ZSk7XG5cbiAgICBpZiAoY2F0ZWdvcnlJbnRlcnZhbCh0aWNrVmFsdWUsIHJhd0xhYmVsKSkge1xuICAgICAgcmVzdWx0LnB1c2gob25seVRpY2sgPyB0aWNrVmFsdWUgOiB7XG4gICAgICAgIGZvcm1hdHRlZExhYmVsOiBsYWJlbEZvcm1hdHRlcih0aWNrVmFsdWUpLFxuICAgICAgICByYXdMYWJlbDogcmF3TGFiZWwsXG4gICAgICAgIHRpY2tWYWx1ZTogdGlja1ZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSAvLyBDYW4gYmUgbnVsbHwnYXV0byd8bnVtYmVyfGZ1bmN0aW9uXG5cblxuZnVuY3Rpb24gZ2V0T3B0aW9uQ2F0ZWdvcnlJbnRlcnZhbChtb2RlbCkge1xuICB2YXIgaW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ2ludGVydmFsJyk7XG4gIHJldHVybiBpbnRlcnZhbCA9PSBudWxsID8gJ2F1dG8nIDogaW50ZXJ2YWw7XG59XG5cbmV4cG9ydHMuY3JlYXRlQXhpc0xhYmVscyA9IGNyZWF0ZUF4aXNMYWJlbHM7XG5leHBvcnRzLmNyZWF0ZUF4aXNUaWNrcyA9IGNyZWF0ZUF4aXNUaWNrcztcbmV4cG9ydHMuY2FsY3VsYXRlQ2F0ZWdvcnlJbnRlcnZhbCA9IGNhbGN1bGF0ZUNhdGVnb3J5SW50ZXJ2YWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc1RpY2tMYWJlbEJ1aWxkZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNUaWNrTGFiZWxCdWlsZGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBBeGlzID0gcmVxdWlyZShcIi4uL0F4aXNcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBFeHRlbmQgYXhpcyAyZFxuICogQGNvbnN0cnVjdG9yIG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkRcbiAqIEBleHRlbmRzIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc31cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAqIEBwYXJhbSB7Kn0gc2NhbGVcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGNvb3JkRXh0ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpc1R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvblxuICovXG52YXIgQXhpczJEID0gZnVuY3Rpb24gKGRpbSwgc2NhbGUsIGNvb3JkRXh0ZW50LCBheGlzVHlwZSwgcG9zaXRpb24pIHtcbiAgQXhpcy5jYWxsKHRoaXMsIGRpbSwgc2NhbGUsIGNvb3JkRXh0ZW50KTtcbiAgLyoqXG4gICAqIEF4aXMgdHlwZVxuICAgKiAgLSAnY2F0ZWdvcnknXG4gICAqICAtICd2YWx1ZSdcbiAgICogIC0gJ3RpbWUnXG4gICAqICAtICdsb2cnXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMudHlwZSA9IGF4aXNUeXBlIHx8ICd2YWx1ZSc7XG4gIC8qKlxuICAgKiBBeGlzIHBvc2l0aW9uXG4gICAqICAtICd0b3AnXG4gICAqICAtICdib3R0b20nXG4gICAqICAtICdsZWZ0J1xuICAgKiAgLSAncmlnaHQnXG4gICAqL1xuXG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnYm90dG9tJztcbn07XG5cbkF4aXMyRC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBeGlzMkQsXG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIGF4aXMsIGNhbiBiZSB1c2VkIGFzIGtleVxuICAgKi9cbiAgaW5kZXg6IDAsXG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGVkIGluIDxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZD4uXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEPn1cbiAgICogICAgICAgICBJZiBub3Qgb24gemVybyBvZiBvdGhlciBheGlzLCByZXR1cm4gbnVsbC91bmRlZmluZWQuXG4gICAqICAgICAgICAgSWYgbm8gYXhlcywgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICAgKi9cbiAgZ2V0QXhlc09uWmVyb09mOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBeGlzIG1vZGVsXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH1cbiAgICovXG4gIG1vZGVsOiBudWxsLFxuICBpc0hvcml6b250YWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFYWNoIGl0ZW0gY29vcmVzcG9uZHMgdG8gdGhpcy5nZXRFeHRlbnQoKSwgd2hpY2hcbiAgICogbWVhbnMgZ2xvYmFsRXh0ZW50WzBdIG1heSBncmVhdGVyIHRoYW4gZ2xvYmFsRXh0ZW50WzFdLFxuICAgKiB1bmxlc3MgYGFzY2AgaXMgaW5wdXQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzY11cbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBnZXRHbG9iYWxFeHRlbnQ6IGZ1bmN0aW9uIChhc2MpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICByZXRbMF0gPSB0aGlzLnRvR2xvYmFsQ29vcmQocmV0WzBdKTtcbiAgICByZXRbMV0gPSB0aGlzLnRvR2xvYmFsQ29vcmQocmV0WzFdKTtcbiAgICBhc2MgJiYgcmV0WzBdID4gcmV0WzFdICYmIHJldC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgZ2V0T3RoZXJBeGlzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncmlkLmdldE90aGVyQXhpcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7XG4gICAgcmV0dXJuIHRoaXMuY29vcmRUb0RhdGEodGhpcy50b0xvY2FsQ29vcmQocG9pbnRbdGhpcy5kaW0gPT09ICd4JyA/IDAgOiAxXSksIGNsYW1wKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhbnNmb3JtIGdsb2JhbCBjb29yZCB0byBsb2NhbCBjb29yZCxcbiAgICogaS5lLiB2YXIgbG9jYWxDb29yZCA9IGF4aXMudG9Mb2NhbENvb3JkKDgwKTtcbiAgICogZGVzaWduYXRlIGJ5IG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICB0b0xvY2FsQ29vcmQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBnbG9iYWwgY29vcmQgdG8gbG9jYWwgY29vcmQsXG4gICAqIGkuZS4gdmFyIGdsb2JhbENvb3JkID0gYXhpcy50b0xvY2FsQ29vcmQoNDApO1xuICAgKiBkZXNpZ25hdGUgYnkgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWQuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHRvR2xvYmFsQ29vcmQ6IG51bGxcbn07XG56clV0aWwuaW5oZXJpdHMoQXhpczJELCBBeGlzKTtcbnZhciBfZGVmYXVsdCA9IEF4aXMyRDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0F4aXMyRC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0F4aXMyRC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvQ29tcG9uZW50XCIpO1xuXG52YXIgYXhpc01vZGVsQ3JlYXRvciA9IHJlcXVpcmUoXCIuLi9heGlzTW9kZWxDcmVhdG9yXCIpO1xuXG52YXIgYXhpc01vZGVsQ29tbW9uTWl4aW4gPSByZXF1aXJlKFwiLi4vYXhpc01vZGVsQ29tbW9uTWl4aW5cIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBBeGlzTW9kZWwgPSBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnY2FydGVzaWFuMmRBeGlzJyxcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9XG4gICAqL1xuICBheGlzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBBeGlzTW9kZWwuc3VwZXJBcHBseSh0aGlzLCAnaW5pdCcsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZXNldFJhbmdlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICBBeGlzTW9kZWwuc3VwZXJBcHBseSh0aGlzLCAnbWVyZ2VPcHRpb24nLCBhcmd1bWVudHMpO1xuICAgIHRoaXMucmVzZXRSYW5nZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgQXhpc01vZGVsLnN1cGVyQXBwbHkodGhpcywgJ3Jlc3RvcmVEYXRhJywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnJlc2V0UmFuZ2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH1cbiAgICovXG4gIGdldENvb3JkU3lzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICBtYWluVHlwZTogJ2dyaWQnLFxuICAgICAgaW5kZXg6IHRoaXMub3B0aW9uLmdyaWRJbmRleCxcbiAgICAgIGlkOiB0aGlzLm9wdGlvbi5ncmlkSWRcbiAgICB9KVswXTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldEF4aXNUeXBlKGF4aXNEaW0sIG9wdGlvbikge1xuICAvLyBEZWZhdWx0IGF4aXMgd2l0aCBkYXRhIGlzIGNhdGVnb3J5IGF4aXNcbiAgcmV0dXJuIG9wdGlvbi50eXBlIHx8IChvcHRpb24uZGF0YSA/ICdjYXRlZ29yeScgOiAndmFsdWUnKTtcbn1cblxuenJVdGlsLm1lcmdlKEF4aXNNb2RlbC5wcm90b3R5cGUsIGF4aXNNb2RlbENvbW1vbk1peGluKTtcbnZhciBleHRyYU9wdGlvbiA9IHtcbiAgLy8gZ3JpZEluZGV4OiAwLFxuICAvLyBncmlkSWQ6ICcnLFxuICAvLyBPZmZzZXQgaXMgZm9yIG11bHRpcGxlIGF4aXMgb24gdGhlIHNhbWUgcG9zaXRpb25cbiAgb2Zmc2V0OiAwXG59O1xuYXhpc01vZGVsQ3JlYXRvcigneCcsIEF4aXNNb2RlbCwgZ2V0QXhpc1R5cGUsIGV4dHJhT3B0aW9uKTtcbmF4aXNNb2RlbENyZWF0b3IoJ3knLCBBeGlzTW9kZWwsIGdldEF4aXNUeXBlLCBleHRyYU9wdGlvbik7XG52YXIgX2RlZmF1bHQgPSBBeGlzTW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICogQG1vZHVsZSAgZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5cbiAqXG4gKi9cbmZ1bmN0aW9uIGRpbUF4aXNNYXBwZXIoZGltKSB7XG4gIHJldHVybiB0aGlzLl9heGVzW2RpbV07XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIENhcnRlc2lhbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHRoaXMuX2F4ZXMgPSB7fTtcbiAgdGhpcy5fZGltTGlzdCA9IFtdO1xuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5uYW1lID0gbmFtZSB8fCAnJztcbn07XG5cbkNhcnRlc2lhbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBDYXJ0ZXNpYW4sXG4gIHR5cGU6ICdjYXJ0ZXNpYW4nLFxuXG4gIC8qKlxuICAgKiBHZXQgYXhpc1xuICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfSBkaW1cbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFufkF4aXN9XG4gICAqL1xuICBnZXRBeGlzOiBmdW5jdGlvbiAoZGltKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F4ZXNbZGltXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGF4ZXMgbGlzdFxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFufkF4aXM+fVxuICAgKi9cbiAgZ2V0QXhlczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB6clV0aWwubWFwKHRoaXMuX2RpbUxpc3QsIGRpbUF4aXNNYXBwZXIsIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYXhlcyBsaXN0IGJ5IGdpdmVuIHNjYWxlIHR5cGVcbiAgICovXG4gIGdldEF4ZXNCeVNjYWxlOiBmdW5jdGlvbiAoc2NhbGVUeXBlKSB7XG4gICAgc2NhbGVUeXBlID0gc2NhbGVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHpyVXRpbC5maWx0ZXIodGhpcy5nZXRBeGVzKCksIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICByZXR1cm4gYXhpcy5zY2FsZS50eXBlID09PSBzY2FsZVR5cGU7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBheGlzXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFuLkF4aXN9XG4gICAqL1xuICBhZGRBeGlzOiBmdW5jdGlvbiAoYXhpcykge1xuICAgIHZhciBkaW0gPSBheGlzLmRpbTtcbiAgICB0aGlzLl9heGVzW2RpbV0gPSBheGlzO1xuXG4gICAgdGhpcy5fZGltTGlzdC5wdXNoKGRpbSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgZGF0YSB0byBjb29yZCBpbiBuZCBzcGFjZVxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fE9iamVjdC48c3RyaW5nLCBudW1iZXI+fSB2YWxcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gICAqL1xuICBkYXRhVG9Db29yZDogZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhQ29vcmRDb252ZXJ0KHZhbCwgJ2RhdGFUb0Nvb3JkJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgY29vcmQgaW4gbmQgc3BhY2UgdG8gZGF0YVxuICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gdmFsXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fE9iamVjdC48c3RyaW5nLCBudW1iZXI+fVxuICAgKi9cbiAgY29vcmRUb0RhdGE6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkQ29udmVydCh2YWwsICdjb29yZFRvRGF0YScpO1xuICB9LFxuICBfZGF0YUNvb3JkQ29udmVydDogZnVuY3Rpb24gKGlucHV0LCBtZXRob2QpIHtcbiAgICB2YXIgZGltTGlzdCA9IHRoaXMuX2RpbUxpc3Q7XG4gICAgdmFyIG91dHB1dCA9IGlucHV0IGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGltID0gZGltTGlzdFtpXTtcbiAgICAgIHZhciBheGlzID0gdGhpcy5fYXhlc1tkaW1dO1xuICAgICAgb3V0cHV0W2RpbV0gPSBheGlzW21ldGhvZF0oaW5wdXRbZGltXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IENhcnRlc2lhbjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgQ2FydGVzaWFuID0gcmVxdWlyZShcIi4vQ2FydGVzaWFuXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5mdW5jdGlvbiBDYXJ0ZXNpYW4yRChuYW1lKSB7XG4gIENhcnRlc2lhbi5jYWxsKHRoaXMsIG5hbWUpO1xufVxuXG5DYXJ0ZXNpYW4yRC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBDYXJ0ZXNpYW4yRCxcbiAgdHlwZTogJ2NhcnRlc2lhbjJkJyxcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGRpbWVuc2lvbnM6IFsneCcsICd5J10sXG5cbiAgLyoqXG4gICAqIEJhc2UgYXhpcyB3aWxsIGJlIHVzZWQgb24gc3RhY2tpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9XG4gICAqL1xuICBnZXRCYXNlQXhpczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF0gfHwgdGhpcy5nZXRBeGVzQnlTY2FsZSgndGltZScpWzBdIHx8IHRoaXMuZ2V0QXhpcygneCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBjb250YWluIHBvaW50XG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBheGlzWCA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgIHZhciBheGlzWSA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgIHJldHVybiBheGlzWC5jb250YWluKGF4aXNYLnRvTG9jYWxDb29yZChwb2ludFswXSkpICYmIGF4aXNZLmNvbnRhaW4oYXhpc1kudG9Mb2NhbENvb3JkKHBvaW50WzFdKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGNvbnRhaW4gZGF0YVxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGlzKCd4JykuY29udGFpbkRhdGEoZGF0YVswXSkgJiYgdGhpcy5nZXRBeGlzKCd5JykuY29udGFpbkRhdGEoZGF0YVsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGFcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZGF0YVRvUG9pbnQ6IGZ1bmN0aW9uIChkYXRhLCByZXNlcnZlZCwgb3V0KSB7XG4gICAgdmFyIHhBeGlzID0gdGhpcy5nZXRBeGlzKCd4Jyk7XG4gICAgdmFyIHlBeGlzID0gdGhpcy5nZXRBeGlzKCd5Jyk7XG4gICAgb3V0ID0gb3V0IHx8IFtdO1xuICAgIG91dFswXSA9IHhBeGlzLnRvR2xvYmFsQ29vcmQoeEF4aXMuZGF0YVRvQ29vcmQoZGF0YVswXSkpO1xuICAgIG91dFsxXSA9IHlBeGlzLnRvR2xvYmFsQ29vcmQoeUF4aXMuZGF0YVRvQ29vcmQoZGF0YVsxXSkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGFcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgY2xhbXBEYXRhOiBmdW5jdGlvbiAoZGF0YSwgb3V0KSB7XG4gICAgdmFyIHhTY2FsZSA9IHRoaXMuZ2V0QXhpcygneCcpLnNjYWxlO1xuICAgIHZhciB5U2NhbGUgPSB0aGlzLmdldEF4aXMoJ3knKS5zY2FsZTtcbiAgICB2YXIgeEF4aXNFeHRlbnQgPSB4U2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIHlBeGlzRXh0ZW50ID0geVNjYWxlLmdldEV4dGVudCgpO1xuICAgIHZhciB4ID0geFNjYWxlLnBhcnNlKGRhdGFbMF0pO1xuICAgIHZhciB5ID0geVNjYWxlLnBhcnNlKGRhdGFbMV0pO1xuICAgIG91dCA9IG91dCB8fCBbXTtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLm1pbih4QXhpc0V4dGVudFswXSwgeEF4aXNFeHRlbnRbMV0pLCB4KSwgTWF0aC5tYXgoeEF4aXNFeHRlbnRbMF0sIHhBeGlzRXh0ZW50WzFdKSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5taW4oeUF4aXNFeHRlbnRbMF0sIHlBeGlzRXh0ZW50WzFdKSwgeSksIE1hdGgubWF4KHlBeGlzRXh0ZW50WzBdLCB5QXhpc0V4dGVudFsxXSkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG91dFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIG91dCkge1xuICAgIHZhciB4QXhpcyA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgIG91dCA9IG91dCB8fCBbXTtcbiAgICBvdXRbMF0gPSB4QXhpcy5jb29yZFRvRGF0YSh4QXhpcy50b0xvY2FsQ29vcmQocG9pbnRbMF0pKTtcbiAgICBvdXRbMV0gPSB5QXhpcy5jb29yZFRvRGF0YSh5QXhpcy50b0xvY2FsQ29vcmQocG9pbnRbMV0pKTtcbiAgICByZXR1cm4gb3V0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgb3RoZXIgYXhpc1xuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9IGF4aXNcbiAgICovXG4gIGdldE90aGVyQXhpczogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGlzKGF4aXMuZGltID09PSAneCcgPyAneScgOiAneCcpO1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKENhcnRlc2lhbjJELCBDYXJ0ZXNpYW4pO1xudmFyIF9kZWZhdWx0ID0gQ2FydGVzaWFuMkQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbjJELmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIF91dGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGlzT2JqZWN0ID0gX3V0aWwuaXNPYmplY3Q7XG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG52YXIgbWFwID0gX3V0aWwubWFwO1xudmFyIGluZGV4T2YgPSBfdXRpbC5pbmRleE9mO1xudmFyIHJldHJpZXZlID0gX3V0aWwucmV0cmlldmU7XG5cbnZhciBfbGF5b3V0ID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgZ2V0TGF5b3V0UmVjdCA9IF9sYXlvdXQuZ2V0TGF5b3V0UmVjdDtcblxudmFyIF9heGlzSGVscGVyID0gcmVxdWlyZShcIi4uLy4uL2Nvb3JkL2F4aXNIZWxwZXJcIik7XG5cbnZhciBjcmVhdGVTY2FsZUJ5TW9kZWwgPSBfYXhpc0hlbHBlci5jcmVhdGVTY2FsZUJ5TW9kZWw7XG52YXIgaWZBeGlzQ3Jvc3NaZXJvID0gX2F4aXNIZWxwZXIuaWZBeGlzQ3Jvc3NaZXJvO1xudmFyIG5pY2VTY2FsZUV4dGVudCA9IF9heGlzSGVscGVyLm5pY2VTY2FsZUV4dGVudDtcbnZhciBlc3RpbWF0ZUxhYmVsVW5pb25SZWN0ID0gX2F4aXNIZWxwZXIuZXN0aW1hdGVMYWJlbFVuaW9uUmVjdDtcblxudmFyIENhcnRlc2lhbjJEID0gcmVxdWlyZShcIi4vQ2FydGVzaWFuMkRcIik7XG5cbnZhciBBeGlzMkQgPSByZXF1aXJlKFwiLi9BeGlzMkRcIik7XG5cbnZhciBDb29yZGluYXRlU3lzdGVtID0gcmVxdWlyZShcIi4uLy4uL0Nvb3JkaW5hdGVTeXN0ZW1cIik7XG5cbnZhciBfZGF0YVN0YWNrSGVscGVyID0gcmVxdWlyZShcIi4uLy4uL2RhdGEvaGVscGVyL2RhdGFTdGFja0hlbHBlclwiKTtcblxudmFyIGdldFN0YWNrZWREaW1lbnNpb24gPSBfZGF0YVN0YWNrSGVscGVyLmdldFN0YWNrZWREaW1lbnNpb247XG5cbnJlcXVpcmUoXCIuL0dyaWRNb2RlbFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEdyaWQgaXMgYSByZWdpb24gd2hpY2ggY29udGFpbnMgYXQgbW9zdCA0IGNhcnRlc2lhbiBzeXN0ZW1zXG4gKlxuICogVE9ETyBEZWZhdWx0IGNhcnRlc2lhblxuICovXG4vLyBEZXBlbmRzIG9uIEdyaWRNb2RlbCwgQXhpc01vZGVsLCB3aGljaCBwZXJmb3JtcyBwcmVwcm9jZXNzLlxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBheGlzIGlzIHVzZWQgaW4gdGhlIHNwZWNpZmllZCBncmlkXG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gaXNBeGlzVXNlZEluVGhlR3JpZChheGlzTW9kZWwsIGdyaWRNb2RlbCwgZWNNb2RlbCkge1xuICByZXR1cm4gYXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKSA9PT0gZ3JpZE1vZGVsO1xufVxuXG5mdW5jdGlvbiBHcmlkKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLl9jb29yZHNNYXAgPSB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2Nvb3Jkc0xpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2F4ZXNNYXAgPSB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2F4ZXNMaXN0ID0gW107XG5cbiAgdGhpcy5faW5pdENhcnRlc2lhbihncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG5cbiAgdGhpcy5tb2RlbCA9IGdyaWRNb2RlbDtcbn1cblxudmFyIGdyaWRQcm90byA9IEdyaWQucHJvdG90eXBlO1xuZ3JpZFByb3RvLnR5cGUgPSAnZ3JpZCc7XG5ncmlkUHJvdG8uYXhpc1BvaW50ZXJFbmFibGVkID0gdHJ1ZTtcblxuZ3JpZFByb3RvLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWN0O1xufTtcblxuZ3JpZFByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGF4ZXNNYXAgPSB0aGlzLl9heGVzTWFwO1xuXG4gIHRoaXMuX3VwZGF0ZVNjYWxlKGVjTW9kZWwsIHRoaXMubW9kZWwpO1xuXG4gIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMpIHtcbiAgICBuaWNlU2NhbGVFeHRlbnQoeEF4aXMuc2NhbGUsIHhBeGlzLm1vZGVsKTtcbiAgfSk7XG4gIGVhY2goYXhlc01hcC55LCBmdW5jdGlvbiAoeUF4aXMpIHtcbiAgICBuaWNlU2NhbGVFeHRlbnQoeUF4aXMuc2NhbGUsIHlBeGlzLm1vZGVsKTtcbiAgfSk7XG4gIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMpIHtcbiAgICBmaXhBeGlzT25aZXJvKGF4ZXNNYXAsICd5JywgeEF4aXMpO1xuICB9KTtcbiAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcykge1xuICAgIGZpeEF4aXNPblplcm8oYXhlc01hcCwgJ3gnLCB5QXhpcyk7XG4gIH0pOyAvLyBSZXNpemUgYWdhaW4gaWYgY29udGFpbkxhYmVsIGlzIGVuYWJsZWRcbiAgLy8gRklYTUUgSXQgbWF5IGNhdXNlIGdldHRpbmcgd3JvbmcgZ3JpZCBzaXplIGluIGRhdGEgcHJvY2Vzc2luZyBzdGFnZVxuXG4gIHRoaXMucmVzaXplKHRoaXMubW9kZWwsIGFwaSk7XG59O1xuXG5mdW5jdGlvbiBmaXhBeGlzT25aZXJvKGF4ZXNNYXAsIG90aGVyQXhpc0RpbSwgYXhpcykge1xuICBheGlzLmdldEF4ZXNPblplcm9PZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBvblplcm8gb2YgbXVsdGlwbGUgYXhlcy5cbiAgICByZXR1cm4gb3RoZXJBeGlzID8gW290aGVyQXhpc10gOiBbXTtcbiAgfTsgLy8gb25aZXJvIGNhbiBub3QgYmUgZW5hYmxlZCBpbiB0aGVzZSB0d28gc2l0dWF0aW9uczpcbiAgLy8gMS4gV2hlbiBhbnkgb3RoZXIgYXhpcyBpcyBhIGNhdGVnb3J5IGF4aXMuXG4gIC8vIDIuIFdoZW4gbm8gYXhpcyBpcyBjcm9zcyAwIHBvaW50LlxuXG5cbiAgdmFyIG90aGVyQXhlcyA9IGF4ZXNNYXBbb3RoZXJBeGlzRGltXTtcbiAgdmFyIG90aGVyQXhpcztcbiAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gIHZhciBvblplcm8gPSBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5vblplcm8nKTtcbiAgdmFyIG9uWmVyb0F4aXNJbmRleCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLm9uWmVyb0F4aXNJbmRleCcpO1xuXG4gIGlmICghb25aZXJvKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIElmIHRhcmdldCBheGlzIGlzIHNwZWNpZmllZC5cblxuXG4gIGlmIChvblplcm9BeGlzSW5kZXggIT0gbnVsbCkge1xuICAgIGlmIChjYW5Pblplcm9Ub0F4aXMob3RoZXJBeGVzW29uWmVyb0F4aXNJbmRleF0pKSB7XG4gICAgICBvdGhlckF4aXMgPSBvdGhlckF4ZXNbb25aZXJvQXhpc0luZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gRmluZCB0aGUgZmlyc3QgYXZhaWxhYmxlIG90aGVyIGF4aXMuXG5cblxuICBmb3IgKHZhciBpZHggaW4gb3RoZXJBeGVzKSB7XG4gICAgaWYgKG90aGVyQXhlcy5oYXNPd25Qcm9wZXJ0eShpZHgpICYmIGNhbk9uWmVyb1RvQXhpcyhvdGhlckF4ZXNbaWR4XSkpIHtcbiAgICAgIG90aGVyQXhpcyA9IG90aGVyQXhlc1tpZHhdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbk9uWmVyb1RvQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzICYmIGF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5JyAmJiBheGlzLnR5cGUgIT09ICd0aW1lJyAmJiBpZkF4aXNDcm9zc1plcm8oYXhpcyk7XG59XG4vKipcbiAqIFJlc2l6ZSB0aGUgZ3JpZFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsfSBncmlkTW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqL1xuXG5cbmdyaWRQcm90by5yZXNpemUgPSBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBhcGksIGlnbm9yZUNvbnRhaW5MYWJlbCkge1xuICB2YXIgZ3JpZFJlY3QgPSBnZXRMYXlvdXRSZWN0KGdyaWRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICB9KTtcbiAgdGhpcy5fcmVjdCA9IGdyaWRSZWN0O1xuICB2YXIgYXhlc0xpc3QgPSB0aGlzLl9heGVzTGlzdDtcbiAgYWRqdXN0QXhlcygpOyAvLyBNaW51cyBsYWJlbCBzaXplXG5cbiAgaWYgKCFpZ25vcmVDb250YWluTGFiZWwgJiYgZ3JpZE1vZGVsLmdldCgnY29udGFpbkxhYmVsJykpIHtcbiAgICBlYWNoKGF4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgaWYgKCFheGlzLm1vZGVsLmdldCgnYXhpc0xhYmVsLmluc2lkZScpKSB7XG4gICAgICAgIHZhciBsYWJlbFVuaW9uUmVjdCA9IGVzdGltYXRlTGFiZWxVbmlvblJlY3QoYXhpcyk7XG5cbiAgICAgICAgaWYgKGxhYmVsVW5pb25SZWN0KSB7XG4gICAgICAgICAgdmFyIGRpbSA9IGF4aXMuaXNIb3Jpem9udGFsKCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgICAgdmFyIG1hcmdpbiA9IGF4aXMubW9kZWwuZ2V0KCdheGlzTGFiZWwubWFyZ2luJyk7XG4gICAgICAgICAgZ3JpZFJlY3RbZGltXSAtPSBsYWJlbFVuaW9uUmVjdFtkaW1dICsgbWFyZ2luO1xuXG4gICAgICAgICAgaWYgKGF4aXMucG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICBncmlkUmVjdC55ICs9IGxhYmVsVW5pb25SZWN0LmhlaWdodCArIG1hcmdpbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF4aXMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgZ3JpZFJlY3QueCArPSBsYWJlbFVuaW9uUmVjdC53aWR0aCArIG1hcmdpbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBhZGp1c3RBeGVzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGp1c3RBeGVzKCkge1xuICAgIGVhY2goYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICB2YXIgaXNIb3Jpem9udGFsID0gYXhpcy5pc0hvcml6b250YWwoKTtcbiAgICAgIHZhciBleHRlbnQgPSBpc0hvcml6b250YWwgPyBbMCwgZ3JpZFJlY3Qud2lkdGhdIDogWzAsIGdyaWRSZWN0LmhlaWdodF07XG4gICAgICB2YXIgaWR4ID0gYXhpcy5pbnZlcnNlID8gMSA6IDA7XG4gICAgICBheGlzLnNldEV4dGVudChleHRlbnRbaWR4XSwgZXh0ZW50WzEgLSBpZHhdKTtcbiAgICAgIHVwZGF0ZUF4aXNUcmFuc2Zvcm0oYXhpcywgaXNIb3Jpem9udGFsID8gZ3JpZFJlY3QueCA6IGdyaWRSZWN0LnkpO1xuICAgIH0pO1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpc1R5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXhpc0luZGV4XVxuICovXG5cblxuZ3JpZFByb3RvLmdldEF4aXMgPSBmdW5jdGlvbiAoYXhpc1R5cGUsIGF4aXNJbmRleCkge1xuICB2YXIgYXhlc01hcE9uRGltID0gdGhpcy5fYXhlc01hcFtheGlzVHlwZV07XG5cbiAgaWYgKGF4ZXNNYXBPbkRpbSAhPSBudWxsKSB7XG4gICAgaWYgKGF4aXNJbmRleCA9PSBudWxsKSB7XG4gICAgICAvLyBGaW5kIGZpcnN0IGF4aXNcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gYXhlc01hcE9uRGltKSB7XG4gICAgICAgIGlmIChheGVzTWFwT25EaW0uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gYXhlc01hcE9uRGltW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF4ZXNNYXBPbkRpbVtheGlzSW5kZXhdO1xuICB9XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvQXhpcz59XG4gKi9cblxuXG5ncmlkUHJvdG8uZ2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2F4ZXNMaXN0LnNsaWNlKCk7XG59O1xuLyoqXG4gKiBVc2FnZTpcbiAqICAgICAgZ3JpZC5nZXRDYXJ0ZXNpYW4oeEF4aXNJbmRleCwgeUF4aXNJbmRleCk7XG4gKiAgICAgIGdyaWQuZ2V0Q2FydGVzaWFuKHhBeGlzSW5kZXgpO1xuICogICAgICBncmlkLmdldENhcnRlc2lhbihudWxsLCB5QXhpc0luZGV4KTtcbiAqICAgICAgZ3JpZC5nZXRDYXJ0ZXNpYW4oe3hBeGlzSW5kZXg6IC4uLiwgeUF4aXNJbmRleDogLi4ufSk7XG4gKlxuICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBbeEF4aXNJbmRleF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeUF4aXNJbmRleF1cbiAqL1xuXG5cbmdyaWRQcm90by5nZXRDYXJ0ZXNpYW4gPSBmdW5jdGlvbiAoeEF4aXNJbmRleCwgeUF4aXNJbmRleCkge1xuICBpZiAoeEF4aXNJbmRleCAhPSBudWxsICYmIHlBeGlzSW5kZXggIT0gbnVsbCkge1xuICAgIHZhciBrZXkgPSAneCcgKyB4QXhpc0luZGV4ICsgJ3knICsgeUF4aXNJbmRleDtcbiAgICByZXR1cm4gdGhpcy5fY29vcmRzTWFwW2tleV07XG4gIH1cblxuICBpZiAoaXNPYmplY3QoeEF4aXNJbmRleCkpIHtcbiAgICB5QXhpc0luZGV4ID0geEF4aXNJbmRleC55QXhpc0luZGV4O1xuICAgIHhBeGlzSW5kZXggPSB4QXhpc0luZGV4LnhBeGlzSW5kZXg7XG4gIH0gLy8gV2hlbiBvbmx5IHhBeGlzSW5kZXggb3IgeUF4aXNJbmRleCBnaXZlbiwgZmluZCBpdHMgZmlyc3QgY2FydGVzaWFuLlxuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGNvb3JkTGlzdCA9IHRoaXMuX2Nvb3Jkc0xpc3Q7IGkgPCBjb29yZExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY29vcmRMaXN0W2ldLmdldEF4aXMoJ3gnKS5pbmRleCA9PT0geEF4aXNJbmRleCB8fCBjb29yZExpc3RbaV0uZ2V0QXhpcygneScpLmluZGV4ID09PSB5QXhpc0luZGV4KSB7XG4gICAgICByZXR1cm4gY29vcmRMaXN0W2ldO1xuICAgIH1cbiAgfVxufTtcblxuZ3JpZFByb3RvLmdldENhcnRlc2lhbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9jb29yZHNMaXN0LnNsaWNlKCk7XG59O1xuLyoqXG4gKiBAaW1wbGVtZW50c1xuICogc2VlIHttb2R1bGU6ZWNoYXJ0cy9Db29kaW5hdGVTeXN0ZW19XG4gKi9cblxuXG5ncmlkUHJvdG8uY29udmVydFRvUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICB2YXIgdGFyZ2V0ID0gdGhpcy5fZmluZENvbnZlcnRUYXJnZXQoZWNNb2RlbCwgZmluZGVyKTtcblxuICByZXR1cm4gdGFyZ2V0LmNhcnRlc2lhbiA/IHRhcmdldC5jYXJ0ZXNpYW4uZGF0YVRvUG9pbnQodmFsdWUpIDogdGFyZ2V0LmF4aXMgPyB0YXJnZXQuYXhpcy50b0dsb2JhbENvb3JkKHRhcmdldC5heGlzLmRhdGFUb0Nvb3JkKHZhbHVlKSkgOiBudWxsO1xufTtcbi8qKlxuICogQGltcGxlbWVudHNcbiAqIHNlZSB7bW9kdWxlOmVjaGFydHMvQ29vZGluYXRlU3lzdGVtfVxuICovXG5cblxuZ3JpZFByb3RvLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICB2YXIgdGFyZ2V0ID0gdGhpcy5fZmluZENvbnZlcnRUYXJnZXQoZWNNb2RlbCwgZmluZGVyKTtcblxuICByZXR1cm4gdGFyZ2V0LmNhcnRlc2lhbiA/IHRhcmdldC5jYXJ0ZXNpYW4ucG9pbnRUb0RhdGEodmFsdWUpIDogdGFyZ2V0LmF4aXMgPyB0YXJnZXQuYXhpcy5jb29yZFRvRGF0YSh0YXJnZXQuYXhpcy50b0xvY2FsQ29vcmQodmFsdWUpKSA6IG51bGw7XG59O1xuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmdyaWRQcm90by5fZmluZENvbnZlcnRUYXJnZXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyKSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGZpbmRlci5zZXJpZXNNb2RlbDtcbiAgdmFyIHhBeGlzTW9kZWwgPSBmaW5kZXIueEF4aXNNb2RlbCB8fCBzZXJpZXNNb2RlbCAmJiBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCd4QXhpcycpWzBdO1xuICB2YXIgeUF4aXNNb2RlbCA9IGZpbmRlci55QXhpc01vZGVsIHx8IHNlcmllc01vZGVsICYmIHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3lBeGlzJylbMF07XG4gIHZhciBncmlkTW9kZWwgPSBmaW5kZXIuZ3JpZE1vZGVsO1xuICB2YXIgY29vcmRzTGlzdCA9IHRoaXMuX2Nvb3Jkc0xpc3Q7XG4gIHZhciBjYXJ0ZXNpYW47XG4gIHZhciBheGlzO1xuXG4gIGlmIChzZXJpZXNNb2RlbCkge1xuICAgIGNhcnRlc2lhbiA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgaW5kZXhPZihjb29yZHNMaXN0LCBjYXJ0ZXNpYW4pIDwgMCAmJiAoY2FydGVzaWFuID0gbnVsbCk7XG4gIH0gZWxzZSBpZiAoeEF4aXNNb2RlbCAmJiB5QXhpc01vZGVsKSB7XG4gICAgY2FydGVzaWFuID0gdGhpcy5nZXRDYXJ0ZXNpYW4oeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gIH0gZWxzZSBpZiAoeEF4aXNNb2RlbCkge1xuICAgIGF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnLCB4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgfSBlbHNlIGlmICh5QXhpc01vZGVsKSB7XG4gICAgYXhpcyA9IHRoaXMuZ2V0QXhpcygneScsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICB9IC8vIExvd2VzdCBwcmlvcml0eS5cbiAgZWxzZSBpZiAoZ3JpZE1vZGVsKSB7XG4gICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICBpZiAoZ3JpZCA9PT0gdGhpcykge1xuICAgICAgICBjYXJ0ZXNpYW4gPSB0aGlzLl9jb29yZHNMaXN0WzBdO1xuICAgICAgfVxuICAgIH1cblxuICByZXR1cm4ge1xuICAgIGNhcnRlc2lhbjogY2FydGVzaWFuLFxuICAgIGF4aXM6IGF4aXNcbiAgfTtcbn07XG4vKipcbiAqIEBpbXBsZW1lbnRzXG4gKiBzZWUge21vZHVsZTplY2hhcnRzL0Nvb2RpbmF0ZVN5c3RlbX1cbiAqL1xuXG5cbmdyaWRQcm90by5jb250YWluUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgdmFyIGNvb3JkID0gdGhpcy5fY29vcmRzTGlzdFswXTtcblxuICBpZiAoY29vcmQpIHtcbiAgICByZXR1cm4gY29vcmQuY29udGFpblBvaW50KHBvaW50KTtcbiAgfVxufTtcbi8qKlxuICogSW5pdGlhbGl6ZSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1zXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZ3JpZFByb3RvLl9pbml0Q2FydGVzaWFuID0gZnVuY3Rpb24gKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBheGlzUG9zaXRpb25Vc2VkID0ge1xuICAgIGxlZnQ6IGZhbHNlLFxuICAgIHJpZ2h0OiBmYWxzZSxcbiAgICB0b3A6IGZhbHNlLFxuICAgIGJvdHRvbTogZmFsc2VcbiAgfTtcbiAgdmFyIGF4ZXNNYXAgPSB7XG4gICAgeDoge30sXG4gICAgeToge31cbiAgfTtcbiAgdmFyIGF4ZXNDb3VudCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTsgLy8vIENyZWF0ZSBheGlzXG5cbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCd4QXhpcycsIGNyZWF0ZUF4aXNDcmVhdG9yKCd4JyksIHRoaXMpO1xuICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3lBeGlzJywgY3JlYXRlQXhpc0NyZWF0b3IoJ3knKSwgdGhpcyk7XG5cbiAgaWYgKCFheGVzQ291bnQueCB8fCAhYXhlc0NvdW50LnkpIHtcbiAgICAvLyBSb2xsIGJhY2sgd2hlbiB0aGVyZSBubyBlaXRoZXIgeCBvciB5IGF4aXNcbiAgICB0aGlzLl9heGVzTWFwID0ge307XG4gICAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9heGVzTWFwID0gYXhlc01hcDsgLy8vIENyZWF0ZSBjYXJ0ZXNpYW4yZFxuXG4gIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMsIHhBeGlzSW5kZXgpIHtcbiAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzLCB5QXhpc0luZGV4KSB7XG4gICAgICB2YXIga2V5ID0gJ3gnICsgeEF4aXNJbmRleCArICd5JyArIHlBeGlzSW5kZXg7XG4gICAgICB2YXIgY2FydGVzaWFuID0gbmV3IENhcnRlc2lhbjJEKGtleSk7XG4gICAgICBjYXJ0ZXNpYW4uZ3JpZCA9IHRoaXM7XG4gICAgICBjYXJ0ZXNpYW4ubW9kZWwgPSBncmlkTW9kZWw7XG4gICAgICB0aGlzLl9jb29yZHNNYXBba2V5XSA9IGNhcnRlc2lhbjtcblxuICAgICAgdGhpcy5fY29vcmRzTGlzdC5wdXNoKGNhcnRlc2lhbik7XG5cbiAgICAgIGNhcnRlc2lhbi5hZGRBeGlzKHhBeGlzKTtcbiAgICAgIGNhcnRlc2lhbi5hZGRBeGlzKHlBeGlzKTtcbiAgICB9LCB0aGlzKTtcbiAgfSwgdGhpcyk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXhpc0NyZWF0b3IoYXhpc1R5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGF4aXNNb2RlbCwgaWR4KSB7XG4gICAgICBpZiAoIWlzQXhpc1VzZWRJblRoZUdyaWQoYXhpc01vZGVsLCBncmlkTW9kZWwsIGVjTW9kZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNQb3NpdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG5cbiAgICAgIGlmIChheGlzVHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgIC8vIEZpeCBwb3NpdGlvblxuICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uICE9PSAndG9wJyAmJiBheGlzUG9zaXRpb24gIT09ICdib3R0b20nKSB7XG4gICAgICAgICAgLy8gRGVmYXVsdCBib3R0b20gb2YgWFxuICAgICAgICAgIGF4aXNQb3NpdGlvbiA9ICdib3R0b20nO1xuXG4gICAgICAgICAgaWYgKGF4aXNQb3NpdGlvblVzZWRbYXhpc1Bvc2l0aW9uXSkge1xuICAgICAgICAgICAgYXhpc1Bvc2l0aW9uID0gYXhpc1Bvc2l0aW9uID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaXggcG9zaXRpb25cbiAgICAgICAgaWYgKGF4aXNQb3NpdGlvbiAhPT0gJ2xlZnQnICYmIGF4aXNQb3NpdGlvbiAhPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIC8vIERlZmF1bHQgbGVmdCBvZiBZXG4gICAgICAgICAgYXhpc1Bvc2l0aW9uID0gJ2xlZnQnO1xuXG4gICAgICAgICAgaWYgKGF4aXNQb3NpdGlvblVzZWRbYXhpc1Bvc2l0aW9uXSkge1xuICAgICAgICAgICAgYXhpc1Bvc2l0aW9uID0gYXhpc1Bvc2l0aW9uID09PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBheGlzUG9zaXRpb25Vc2VkW2F4aXNQb3NpdGlvbl0gPSB0cnVlO1xuICAgICAgdmFyIGF4aXMgPSBuZXcgQXhpczJEKGF4aXNUeXBlLCBjcmVhdGVTY2FsZUJ5TW9kZWwoYXhpc01vZGVsKSwgWzAsIDBdLCBheGlzTW9kZWwuZ2V0KCd0eXBlJyksIGF4aXNQb3NpdGlvbik7XG4gICAgICB2YXIgaXNDYXRlZ29yeSA9IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICAgIGF4aXMub25CYW5kID0gaXNDYXRlZ29yeSAmJiBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgYXhpcy5pbnZlcnNlID0gYXhpc01vZGVsLmdldCgnaW52ZXJzZScpOyAvLyBJbmplY3QgYXhpcyBpbnRvIGF4aXNNb2RlbFxuXG4gICAgICBheGlzTW9kZWwuYXhpcyA9IGF4aXM7IC8vIEluamVjdCBheGlzTW9kZWwgaW50byBheGlzXG5cbiAgICAgIGF4aXMubW9kZWwgPSBheGlzTW9kZWw7IC8vIEluamVjdCBncmlkIGluZm8gYXhpc1xuXG4gICAgICBheGlzLmdyaWQgPSB0aGlzOyAvLyBJbmRleCBvZiBheGlzLCBjYW4gYmUgdXNlZCBhcyBrZXlcblxuICAgICAgYXhpcy5pbmRleCA9IGlkeDtcblxuICAgICAgdGhpcy5fYXhlc0xpc3QucHVzaChheGlzKTtcblxuICAgICAgYXhlc01hcFtheGlzVHlwZV1baWR4XSA9IGF4aXM7XG4gICAgICBheGVzQ291bnRbYXhpc1R5cGVdKys7XG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogVXBkYXRlIGNhcnRlc2lhbiBwcm9wZXJ0aWVzIGZyb20gc2VyaWVzXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb259IG9wdGlvblxuICogQHByaXZhdGVcbiAqL1xuXG5cbmdyaWRQcm90by5fdXBkYXRlU2NhbGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZ3JpZE1vZGVsKSB7XG4gIC8vIFJlc2V0IHNjYWxlXG4gIGVhY2godGhpcy5fYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgYXhpcy5zY2FsZS5zZXRFeHRlbnQoSW5maW5pdHksIC1JbmZpbml0eSk7XG4gIH0pO1xuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgaWYgKGlzQ2FydGVzaWFuMkQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICB2YXIgYXhlc01vZGVscyA9IGZpbmRBeGVzTW9kZWxzKHNlcmllc01vZGVsLCBlY01vZGVsKTtcbiAgICAgIHZhciB4QXhpc01vZGVsID0gYXhlc01vZGVsc1swXTtcbiAgICAgIHZhciB5QXhpc01vZGVsID0gYXhlc01vZGVsc1sxXTtcblxuICAgICAgaWYgKCFpc0F4aXNVc2VkSW5UaGVHcmlkKHhBeGlzTW9kZWwsIGdyaWRNb2RlbCwgZWNNb2RlbCkgfHwgIWlzQXhpc1VzZWRJblRoZUdyaWQoeUF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXJ0ZXNpYW4gPSB0aGlzLmdldENhcnRlc2lhbih4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIHhBeGlzID0gY2FydGVzaWFuLmdldEF4aXMoJ3gnKTtcbiAgICAgIHZhciB5QXhpcyA9IGNhcnRlc2lhbi5nZXRBeGlzKCd5Jyk7XG5cbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICB1bmlvbkV4dGVudChkYXRhLCB4QXhpcywgc2VyaWVzTW9kZWwpO1xuICAgICAgICB1bmlvbkV4dGVudChkYXRhLCB5QXhpcywgc2VyaWVzTW9kZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgZnVuY3Rpb24gdW5pb25FeHRlbnQoZGF0YSwgYXhpcywgc2VyaWVzTW9kZWwpIHtcbiAgICBlYWNoKGRhdGEubWFwRGltZW5zaW9uKGF4aXMuZGltLCB0cnVlKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgYXhpcy5zY2FsZS51bmlvbkV4dGVudEZyb21EYXRhKCAvLyBGb3IgZXhhbXBsZSwgdGhlIGV4dGVudCBvZiB0aGUgb3JnaW5hbCBkaW1lbnNpb25cbiAgICAgIC8vIGlzIFswLjEsIDAuNV0sIHRoZSBleHRlbnQgb2YgdGhlIGBzdGFja1Jlc3VsdERpbWVuc2lvbmBcbiAgICAgIC8vIGlzIFs3LCA5XSwgdGhlIGZpbmFsIGV4dGVudCBzaG91bGQgbm90IGluY2x1ZGUgWzAuMSwgMC41XS5cbiAgICAgIGRhdGEsIGdldFN0YWNrZWREaW1lbnNpb24oZGF0YSwgZGltKSk7XG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZGltXSAneCcgb3IgJ3knIG9yICdhdXRvJyBvciBudWxsL3VuZGVmaW5lZFxuICogQHJldHVybiB7T2JqZWN0fSB7YmFzZUF4ZXM6IFtdLCBvdGhlckF4ZXM6IFtdfVxuICovXG5cblxuZ3JpZFByb3RvLmdldFRvb2x0aXBBeGVzID0gZnVuY3Rpb24gKGRpbSkge1xuICB2YXIgYmFzZUF4ZXMgPSBbXTtcbiAgdmFyIG90aGVyQXhlcyA9IFtdO1xuICBlYWNoKHRoaXMuZ2V0Q2FydGVzaWFucygpLCBmdW5jdGlvbiAoY2FydGVzaWFuKSB7XG4gICAgdmFyIGJhc2VBeGlzID0gZGltICE9IG51bGwgJiYgZGltICE9PSAnYXV0bycgPyBjYXJ0ZXNpYW4uZ2V0QXhpcyhkaW0pIDogY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgdmFyIG90aGVyQXhpcyA9IGNhcnRlc2lhbi5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICAgIGluZGV4T2YoYmFzZUF4ZXMsIGJhc2VBeGlzKSA8IDAgJiYgYmFzZUF4ZXMucHVzaChiYXNlQXhpcyk7XG4gICAgaW5kZXhPZihvdGhlckF4ZXMsIG90aGVyQXhpcykgPCAwICYmIG90aGVyQXhlcy5wdXNoKG90aGVyQXhpcyk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGJhc2VBeGVzOiBiYXNlQXhlcyxcbiAgICBvdGhlckF4ZXM6IG90aGVyQXhlc1xuICB9O1xufTtcbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiB1cGRhdGVBeGlzVHJhbnNmb3JtKGF4aXMsIGNvb3JkQmFzZSkge1xuICB2YXIgYXhpc0V4dGVudCA9IGF4aXMuZ2V0RXh0ZW50KCk7XG4gIHZhciBheGlzRXh0ZW50U3VtID0gYXhpc0V4dGVudFswXSArIGF4aXNFeHRlbnRbMV07IC8vIEZhc3QgdHJhbnNmb3JtXG5cbiAgYXhpcy50b0dsb2JhbENvb3JkID0gYXhpcy5kaW0gPT09ICd4JyA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHJldHVybiBjb29yZCArIGNvb3JkQmFzZTtcbiAgfSA6IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHJldHVybiBheGlzRXh0ZW50U3VtIC0gY29vcmQgKyBjb29yZEJhc2U7XG4gIH07XG4gIGF4aXMudG9Mb2NhbENvb3JkID0gYXhpcy5kaW0gPT09ICd4JyA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHJldHVybiBjb29yZCAtIGNvb3JkQmFzZTtcbiAgfSA6IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHJldHVybiBheGlzRXh0ZW50U3VtIC0gY29vcmQgKyBjb29yZEJhc2U7XG4gIH07XG59XG5cbnZhciBheGVzVHlwZXMgPSBbJ3hBeGlzJywgJ3lBeGlzJ107XG4vKipcbiAqIEBpbm5lclxuICovXG5cbmZ1bmN0aW9uIGZpbmRBeGVzTW9kZWxzKHNlcmllc01vZGVsLCBlY01vZGVsKSB7XG4gIHJldHVybiBtYXAoYXhlc1R5cGVzLCBmdW5jdGlvbiAoYXhpc1R5cGUpIHtcbiAgICB2YXIgYXhpc01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cyhheGlzVHlwZSlbMF07XG4gICAgcmV0dXJuIGF4aXNNb2RlbDtcbiAgfSk7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gaXNDYXJ0ZXNpYW4yRChzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykgPT09ICdjYXJ0ZXNpYW4yZCc7XG59XG5cbkdyaWQuY3JlYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICB2YXIgZ3JpZHMgPSBbXTtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdncmlkJywgZnVuY3Rpb24gKGdyaWRNb2RlbCwgaWR4KSB7XG4gICAgdmFyIGdyaWQgPSBuZXcgR3JpZChncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgZ3JpZC5uYW1lID0gJ2dyaWRfJyArIGlkeDsgLy8gZGF0YVNhbXBsaW5nIHJlcXVpcmVzIGF4aXMgZXh0ZW50LCBzbyByZXNpemVcbiAgICAvLyBzaG91bGQgYmUgcGVyZm9ybWVkIGluIGNyZWF0ZSBzdGFnZS5cblxuICAgIGdyaWQucmVzaXplKGdyaWRNb2RlbCwgYXBpLCB0cnVlKTtcbiAgICBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IGdyaWQ7XG4gICAgZ3JpZHMucHVzaChncmlkKTtcbiAgfSk7IC8vIEluamVjdCB0aGUgY29vcmRpbmF0ZVN5c3RlbXMgaW50byBzZXJpZXNNb2RlbFxuXG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBpZiAoIWlzQ2FydGVzaWFuMkQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF4ZXNNb2RlbHMgPSBmaW5kQXhlc01vZGVscyhzZXJpZXNNb2RlbCwgZWNNb2RlbCk7XG4gICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzBdO1xuICAgIHZhciB5QXhpc01vZGVsID0gYXhlc01vZGVsc1sxXTtcbiAgICB2YXIgZ3JpZE1vZGVsID0geEF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCk7XG4gICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gZ3JpZC5nZXRDYXJ0ZXNpYW4oeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gIH0pO1xuICByZXR1cm4gZ3JpZHM7XG59OyAvLyBGb3IgZGVjaWRpbmcgd2hpY2ggZGltZW5zaW9ucyB0byB1c2Ugd2hlbiBjcmVhdGluZyBsaXN0IGRhdGFcblxuXG5HcmlkLmRpbWVuc2lvbnMgPSBHcmlkLnByb3RvdHlwZS5kaW1lbnNpb25zID0gQ2FydGVzaWFuMkQucHJvdG90eXBlLmRpbWVuc2lvbnM7XG5Db29yZGluYXRlU3lzdGVtLnJlZ2lzdGVyKCdjYXJ0ZXNpYW4yZCcsIEdyaWQpO1xudmFyIF9kZWZhdWx0ID0gR3JpZDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZShcIi4vQXhpc01vZGVsXCIpO1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvQ29tcG9uZW50XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBHcmlkIOaYr+WcqOacieebtOinkuWdkOagh+ezu+eahOaXtuWAmeW/hemhu+imgeWtmOWcqOeahFxuLy8g5omA5Lul6L+Z6YeM5Lmf6KaB6KKrIENhcnRlc2lhbjJEIOS+nei1llxudmFyIF9kZWZhdWx0ID0gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ2dyaWQnLFxuICBkZXBlbmRlbmNpZXM6IFsneEF4aXMnLCAneUF4aXMnXSxcbiAgbGF5b3V0TW9kZTogJ2JveCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZH1cbiAgICovXG4gIGNvb3JkaW5hdGVTeXN0ZW06IG51bGwsXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICBzaG93OiBmYWxzZSxcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMCxcbiAgICBsZWZ0OiAnMTAlJyxcbiAgICB0b3A6IDYwLFxuICAgIHJpZ2h0OiAnMTAlJyxcbiAgICBib3R0b206IDYwLFxuICAgIC8vIElmIGdyaWQgc2l6ZSBjb250YWluIGxhYmVsXG4gICAgY29udGFpbkxhYmVsOiBmYWxzZSxcbiAgICAvLyB3aWR0aDoge3RvdGFsV2lkdGh9IC0gbGVmdCAtIHJpZ2h0LFxuICAgIC8vIGhlaWdodDoge3RvdGFsSGVpZ2h0fSAtIHRvcCAtIGJvdHRvbSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJXaWR0aDogMSxcbiAgICBib3JkZXJDb2xvcjogJyNjY2MnXG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIENhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciBjb29yZGluYXRlIHN5c3RlbSBjcmVhdGlvbiBzdGFnZS5cbiAqIChDYW4gYmUgY2FsbGVkIGJlZm9yZSBjb29yZGluYXRlIHN5c3RlbSB1cGRhdGUgc3RhZ2UpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQge2xhYmVsSW5zaWRlfVxuICogQHJldHVybiB7T2JqZWN0fSB7XG4gKiAgcG9zaXRpb24sIHJvdGF0aW9uLCBsYWJlbERpcmVjdGlvbiwgbGFiZWxPZmZzZXQsXG4gKiAgdGlja0RpcmVjdGlvbiwgbGFiZWxSb3RhdGUsIHoyXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGxheW91dChncmlkTW9kZWwsIGF4aXNNb2RlbCwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgdmFyIGxheW91dCA9IHt9O1xuICB2YXIgb3RoZXJBeGlzT25aZXJvT2YgPSBheGlzLmdldEF4ZXNPblplcm9PZigpWzBdO1xuICB2YXIgcmF3QXhpc1Bvc2l0aW9uID0gYXhpcy5wb3NpdGlvbjtcbiAgdmFyIGF4aXNQb3NpdGlvbiA9IG90aGVyQXhpc09uWmVyb09mID8gJ29uWmVybycgOiByYXdBeGlzUG9zaXRpb247XG4gIHZhciBheGlzRGltID0gYXhpcy5kaW07XG4gIHZhciByZWN0ID0gZ3JpZC5nZXRSZWN0KCk7XG4gIHZhciByZWN0Qm91bmQgPSBbcmVjdC54LCByZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnksIHJlY3QueSArIHJlY3QuaGVpZ2h0XTtcbiAgdmFyIGlkeCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAxLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDEsXG4gICAgb25aZXJvOiAyXG4gIH07XG4gIHZhciBheGlzT2Zmc2V0ID0gYXhpc01vZGVsLmdldCgnb2Zmc2V0JykgfHwgMDtcbiAgdmFyIHBvc0JvdW5kID0gYXhpc0RpbSA9PT0gJ3gnID8gW3JlY3RCb3VuZFsyXSAtIGF4aXNPZmZzZXQsIHJlY3RCb3VuZFszXSArIGF4aXNPZmZzZXRdIDogW3JlY3RCb3VuZFswXSAtIGF4aXNPZmZzZXQsIHJlY3RCb3VuZFsxXSArIGF4aXNPZmZzZXRdO1xuXG4gIGlmIChvdGhlckF4aXNPblplcm9PZikge1xuICAgIHZhciBvblplcm9Db29yZCA9IG90aGVyQXhpc09uWmVyb09mLnRvR2xvYmFsQ29vcmQob3RoZXJBeGlzT25aZXJvT2YuZGF0YVRvQ29vcmQoMCkpO1xuICAgIHBvc0JvdW5kW2lkeFsnb25aZXJvJ11dID0gTWF0aC5tYXgoTWF0aC5taW4ob25aZXJvQ29vcmQsIHBvc0JvdW5kWzFdKSwgcG9zQm91bmRbMF0pO1xuICB9IC8vIEF4aXMgcG9zaXRpb25cblxuXG4gIGxheW91dC5wb3NpdGlvbiA9IFtheGlzRGltID09PSAneScgPyBwb3NCb3VuZFtpZHhbYXhpc1Bvc2l0aW9uXV0gOiByZWN0Qm91bmRbMF0sIGF4aXNEaW0gPT09ICd4JyA/IHBvc0JvdW5kW2lkeFtheGlzUG9zaXRpb25dXSA6IHJlY3RCb3VuZFszXV07IC8vIEF4aXMgcm90YXRpb25cblxuICBsYXlvdXQucm90YXRpb24gPSBNYXRoLlBJIC8gMiAqIChheGlzRGltID09PSAneCcgPyAwIDogMSk7IC8vIFRpY2sgYW5kIGxhYmVsIGRpcmVjdGlvbiwgeCB5IGlzIGF4aXNEaW1cblxuICB2YXIgZGlyTWFwID0ge1xuICAgIHRvcDogLTEsXG4gICAgYm90dG9tOiAxLFxuICAgIGxlZnQ6IC0xLFxuICAgIHJpZ2h0OiAxXG4gIH07XG4gIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IGxheW91dC50aWNrRGlyZWN0aW9uID0gbGF5b3V0Lm5hbWVEaXJlY3Rpb24gPSBkaXJNYXBbcmF3QXhpc1Bvc2l0aW9uXTtcbiAgbGF5b3V0LmxhYmVsT2Zmc2V0ID0gb3RoZXJBeGlzT25aZXJvT2YgPyBwb3NCb3VuZFtpZHhbcmF3QXhpc1Bvc2l0aW9uXV0gLSBwb3NCb3VuZFtpZHhbJ29uWmVybyddXSA6IDA7XG5cbiAgaWYgKGF4aXNNb2RlbC5nZXQoJ2F4aXNUaWNrLmluc2lkZScpKSB7XG4gICAgbGF5b3V0LnRpY2tEaXJlY3Rpb24gPSAtbGF5b3V0LnRpY2tEaXJlY3Rpb247XG4gIH1cblxuICBpZiAoenJVdGlsLnJldHJpZXZlKG9wdC5sYWJlbEluc2lkZSwgYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLmluc2lkZScpKSkge1xuICAgIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IC1sYXlvdXQubGFiZWxEaXJlY3Rpb247XG4gIH0gLy8gU3BlY2lhbCBsYWJlbCByb3RhdGlvblxuXG5cbiAgdmFyIGxhYmVsUm90YXRlID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnJvdGF0ZScpO1xuICBsYXlvdXQubGFiZWxSb3RhdGUgPSBheGlzUG9zaXRpb24gPT09ICd0b3AnID8gLWxhYmVsUm90YXRlIDogbGFiZWxSb3RhdGU7IC8vIE92ZXIgc3BsaXRMaW5lIGFuZCBzcGxpdEFyZWFcblxuICBsYXlvdXQuejIgPSAxO1xuICByZXR1cm4gbGF5b3V0O1xufVxuXG5leHBvcnRzLmxheW91dCA9IGxheW91dDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vY2FydGVzaWFuQXhpc0hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL2NhcnRlc2lhbkF4aXNIZWxwZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgYmJveCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2Jib3hcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgcG9seWdvbkNvbnRhaW4gPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbi9wb2x5Z29uXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2Nvb3JkL2dlby9SZWdpb25cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBnZW9tZXRyaWVzXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjcFxuICovXG5mdW5jdGlvbiBSZWdpb24obmFtZSwgZ2VvbWV0cmllcywgY3ApIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48QXJyYXk+fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcblxuICBpZiAoIWNwKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIGNwID0gW3JlY3QueCArIHJlY3Qud2lkdGggLyAyLCByZWN0LnkgKyByZWN0LmhlaWdodCAvIDJdO1xuICB9IGVsc2Uge1xuICAgIGNwID0gW2NwWzBdLCBjcFsxXV07XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cblxuICB0aGlzLmNlbnRlciA9IGNwO1xufVxuXG5SZWdpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmVnaW9uLFxuICBwcm9wZXJ0aWVzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcblxuICAgIGlmIChyZWN0KSB7XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICB2YXIgTUFYX05VTUJFUiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIG1pbiA9IFtNQVhfTlVNQkVSLCBNQVhfTlVNQkVSXTtcbiAgICB2YXIgbWF4ID0gWy1NQVhfTlVNQkVSLCAtTUFYX05VTUJFUl07XG4gICAgdmFyIG1pbjIgPSBbXTtcbiAgICB2YXIgbWF4MiA9IFtdO1xuICAgIHZhciBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBPbmx5IHN1cHBvcnQgcG9seWdvblxuICAgICAgaWYgKGdlb21ldHJpZXNbaV0udHlwZSAhPT0gJ3BvbHlnb24nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBEb2Vzbid0IGNvbnNpZGVyIGhvbGVcblxuXG4gICAgICB2YXIgZXh0ZXJpb3IgPSBnZW9tZXRyaWVzW2ldLmV4dGVyaW9yO1xuICAgICAgYmJveC5mcm9tUG9pbnRzKGV4dGVyaW9yLCBtaW4yLCBtYXgyKTtcbiAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgIHZlYzIubWF4KG1heCwgbWF4LCBtYXgyKTtcbiAgICB9IC8vIE5vIGRhdGFcblxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIG1pblswXSA9IG1pblsxXSA9IG1heFswXSA9IG1heFsxXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7PEFycmF5LjxudW1iZXI+fSBjb29yZFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbjogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzO1xuXG4gICAgaWYgKCFyZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxvb3BHZW86IGZvciAodmFyIGkgPSAwLCBsZW4gPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBPbmx5IHN1cHBvcnQgcG9seWdvbi5cbiAgICAgIGlmIChnZW9tZXRyaWVzW2ldLnR5cGUgIT09ICdwb2x5Z29uJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4dGVyaW9yID0gZ2VvbWV0cmllc1tpXS5leHRlcmlvcjtcbiAgICAgIHZhciBpbnRlcmlvcnMgPSBnZW9tZXRyaWVzW2ldLmludGVyaW9ycztcblxuICAgICAgaWYgKHBvbHlnb25Db250YWluLmNvbnRhaW4oZXh0ZXJpb3IsIGNvb3JkWzBdLCBjb29yZFsxXSkpIHtcbiAgICAgICAgLy8gTm90IGluIHRoZSByZWdpb24gaWYgcG9pbnQgaXMgaW4gdGhlIGhvbGUuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgKGludGVyaW9ycyA/IGludGVyaW9ycy5sZW5ndGggOiAwKTsgaysrKSB7XG4gICAgICAgICAgaWYgKHBvbHlnb25Db250YWluLmNvbnRhaW4oaW50ZXJpb3JzW2tdKSkge1xuICAgICAgICAgICAgY29udGludWUgbG9vcEdlbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHRyYW5zZm9ybVRvOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgYXNwZWN0ID0gcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0O1xuXG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgd2lkdGggPSBhc3BlY3QgKiBoZWlnaHQ7XG4gICAgfSBlbHNlIGlmICghaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgdHJhbnNmb3JtID0gcmVjdC5jYWxjdWxhdGVUcmFuc2Zvcm0odGFyZ2V0KTtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IHRoaXMuZ2VvbWV0cmllcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gT25seSBzdXBwb3J0IHBvbHlnb24uXG4gICAgICBpZiAoZ2VvbWV0cmllc1tpXS50eXBlICE9PSAncG9seWdvbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBleHRlcmlvciA9IGdlb21ldHJpZXNbaV0uZXh0ZXJpb3I7XG4gICAgICB2YXIgaW50ZXJpb3JzID0gZ2VvbWV0cmllc1tpXS5pbnRlcmlvcnM7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgZXh0ZXJpb3IubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgdmVjMi5hcHBseVRyYW5zZm9ybShleHRlcmlvcltwXSwgZXh0ZXJpb3JbcF0sIHRyYW5zZm9ybSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgKGludGVyaW9ycyA/IGludGVyaW9ycy5sZW5ndGggOiAwKTsgaCsrKSB7XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgaW50ZXJpb3JzW2hdLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmVjMi5hcHBseVRyYW5zZm9ybShpbnRlcmlvcnNbaF1bcF0sIGludGVyaW9yc1toXVtwXSwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgIHJlY3QuY29weSh0YXJnZXQpOyAvLyBVcGRhdGUgY2VudGVyXG5cbiAgICB0aGlzLmNlbnRlciA9IFtyZWN0LnggKyByZWN0LndpZHRoIC8gMiwgcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyXTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFJlZ2lvbjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL1JlZ2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL1JlZ2lvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgUmVnaW9uID0gcmVxdWlyZShcIi4vUmVnaW9uXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogUGFyc2UgYW5kIGRlY29kZSBnZW8ganNvblxuICogQG1vZHVsZSBlY2hhcnRzL2Nvb3JkL2dlby9wYXJzZUdlb0pzb25cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGpzb24pIHtcbiAgaWYgKCFqc29uLlVURjhFbmNvZGluZykge1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgdmFyIGVuY29kZVNjYWxlID0ganNvbi5VVEY4U2NhbGU7XG5cbiAgaWYgKGVuY29kZVNjYWxlID09IG51bGwpIHtcbiAgICBlbmNvZGVTY2FsZSA9IDEwMjQ7XG4gIH1cblxuICB2YXIgZmVhdHVyZXMgPSBqc29uLmZlYXR1cmVzO1xuXG4gIGZvciAodmFyIGYgPSAwOyBmIDwgZmVhdHVyZXMubGVuZ3RoOyBmKyspIHtcbiAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ZdO1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgdmFyIGVuY29kZU9mZnNldHMgPSBnZW9tZXRyeS5lbmNvZGVPZmZzZXRzO1xuXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb29yZGluYXRlcy5sZW5ndGg7IGMrKykge1xuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tjXTtcblxuICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICBjb29yZGluYXRlc1tjXSA9IGRlY29kZVBvbHlnb24oY29vcmRpbmF0ZSwgZW5jb2RlT2Zmc2V0c1tjXSwgZW5jb2RlU2NhbGUpO1xuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBmb3IgKHZhciBjMiA9IDA7IGMyIDwgY29vcmRpbmF0ZS5sZW5ndGg7IGMyKyspIHtcbiAgICAgICAgICB2YXIgcG9seWdvbiA9IGNvb3JkaW5hdGVbYzJdO1xuICAgICAgICAgIGNvb3JkaW5hdGVbYzJdID0gZGVjb2RlUG9seWdvbihwb2x5Z29uLCBlbmNvZGVPZmZzZXRzW2NdW2MyXSwgZW5jb2RlU2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEhhcyBiZWVuIGRlY29kZWRcblxuXG4gIGpzb24uVVRGOEVuY29kaW5nID0gZmFsc2U7XG4gIHJldHVybiBqc29uO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVQb2x5Z29uKGNvb3JkaW5hdGUsIGVuY29kZU9mZnNldHMsIGVuY29kZVNjYWxlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHByZXZYID0gZW5jb2RlT2Zmc2V0c1swXTtcbiAgdmFyIHByZXZZID0gZW5jb2RlT2Zmc2V0c1sxXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgeCA9IGNvb3JkaW5hdGUuY2hhckNvZGVBdChpKSAtIDY0O1xuICAgIHZhciB5ID0gY29vcmRpbmF0ZS5jaGFyQ29kZUF0KGkgKyAxKSAtIDY0OyAvLyBaaWdaYWcgZGVjb2RpbmdcblxuICAgIHggPSB4ID4+IDEgXiAtKHggJiAxKTtcbiAgICB5ID0geSA+PiAxIF4gLSh5ICYgMSk7IC8vIERlbHRhIGRlb2NkaW5nXG5cbiAgICB4ICs9IHByZXZYO1xuICAgIHkgKz0gcHJldlk7XG4gICAgcHJldlggPSB4O1xuICAgIHByZXZZID0geTsgLy8gRGVxdWFudGl6ZVxuXG4gICAgcmVzdWx0LnB1c2goW3ggLyBlbmNvZGVTY2FsZSwgeSAvIGVuY29kZVNjYWxlXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29vcmQvZ2VvL3BhcnNlR2VvSnNvblxuICogQHBhcmFtIHtPYmplY3R9IGdlb0pzb25cbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAqL1xuXG5cbmZ1bmN0aW9uIF9kZWZhdWx0KGdlb0pzb24pIHtcbiAgZGVjb2RlKGdlb0pzb24pO1xuICByZXR1cm4genJVdGlsLm1hcCh6clV0aWwuZmlsdGVyKGdlb0pzb24uZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlT2JqKSB7XG4gICAgLy8gT3V0cHV0IG9mIG1hcHNoYXBlciBtYXkgaGF2ZSBnZW9tZXRyeSBudWxsXG4gICAgcmV0dXJuIGZlYXR1cmVPYmouZ2VvbWV0cnkgJiYgZmVhdHVyZU9iai5wcm9wZXJ0aWVzICYmIGZlYXR1cmVPYmouZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoID4gMDtcbiAgfSksIGZ1bmN0aW9uIChmZWF0dXJlT2JqKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBmZWF0dXJlT2JqLnByb3BlcnRpZXM7XG4gICAgdmFyIGdlbyA9IGZlYXR1cmVPYmouZ2VvbWV0cnk7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gZ2VvLmNvb3JkaW5hdGVzO1xuICAgIHZhciBnZW9tZXRyaWVzID0gW107XG5cbiAgICBpZiAoZ2VvLnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgZ2VvbWV0cmllcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BvbHlnb24nLFxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIEdlb0pTT04gc3BlY2lmaWNhdGlvbi5cbiAgICAgICAgLy8gRmlyc3QgbXVzdCBiZSBleHRlcmlvciwgYW5kIHRoZSByZXN0IGFyZSBhbGwgaW50ZXJpb3IoaG9sZXMpLlxuICAgICAgICBleHRlcmlvcjogY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgIGludGVyaW9yczogY29vcmRpbmF0ZXMuc2xpY2UoMSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChnZW8udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgIHpyVXRpbC5lYWNoKGNvb3JkaW5hdGVzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbVswXSkge1xuICAgICAgICAgIGdlb21ldHJpZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAncG9seWdvbicsXG4gICAgICAgICAgICBleHRlcmlvcjogaXRlbVswXSxcbiAgICAgICAgICAgIGludGVyaW9yczogaXRlbS5zbGljZSgxKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVnaW9uID0gbmV3IFJlZ2lvbihwcm9wZXJ0aWVzLm5hbWUsIGdlb21ldHJpZXMsIHByb3BlcnRpZXMuY3ApO1xuICAgIHJlZ2lvbi5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICByZXR1cm4gcmVnaW9uO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vcGFyc2VHZW9Kc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vcGFyc2VHZW9Kc29uLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuZnVuY3Rpb24gZGVmYXVsdEtleUdldHRlcihpdGVtKSB7XG4gIHJldHVybiBpdGVtO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBvbGRBcnJcbiAqIEBwYXJhbSB7QXJyYXl9IG5ld0FyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gb2xkS2V5R2V0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdLZXlHZXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ2FuIGJlIHZpc2l0ZWQgYnkgdGhpcy5jb250ZXh0IGluIGNhbGxiYWNrLlxuICovXG5cblxuZnVuY3Rpb24gRGF0YURpZmZlcihvbGRBcnIsIG5ld0Fyciwgb2xkS2V5R2V0dGVyLCBuZXdLZXlHZXR0ZXIsIGNvbnRleHQpIHtcbiAgdGhpcy5fb2xkID0gb2xkQXJyO1xuICB0aGlzLl9uZXcgPSBuZXdBcnI7XG4gIHRoaXMuX29sZEtleUdldHRlciA9IG9sZEtleUdldHRlciB8fCBkZWZhdWx0S2V5R2V0dGVyO1xuICB0aGlzLl9uZXdLZXlHZXR0ZXIgPSBuZXdLZXlHZXR0ZXIgfHwgZGVmYXVsdEtleUdldHRlcjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuRGF0YURpZmZlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEYXRhRGlmZmVyLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIGFkZCBhIGRhdGFcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB0aGlzLl9hZGQgPSBmdW5jO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIHVwZGF0ZSBhIGRhdGFcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB0aGlzLl91cGRhdGUgPSBmdW5jO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIHJlbW92ZSBhIGRhdGFcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB0aGlzLl9yZW1vdmUgPSBmdW5jO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBleGVjdXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9sZEFyciA9IHRoaXMuX29sZDtcbiAgICB2YXIgbmV3QXJyID0gdGhpcy5fbmV3O1xuICAgIHZhciBvbGREYXRhSW5kZXhNYXAgPSB7fTtcbiAgICB2YXIgbmV3RGF0YUluZGV4TWFwID0ge307XG4gICAgdmFyIG9sZERhdGFLZXlBcnIgPSBbXTtcbiAgICB2YXIgbmV3RGF0YUtleUFyciA9IFtdO1xuICAgIHZhciBpO1xuICAgIGluaXRJbmRleE1hcChvbGRBcnIsIG9sZERhdGFJbmRleE1hcCwgb2xkRGF0YUtleUFyciwgJ19vbGRLZXlHZXR0ZXInLCB0aGlzKTtcbiAgICBpbml0SW5kZXhNYXAobmV3QXJyLCBuZXdEYXRhSW5kZXhNYXAsIG5ld0RhdGFLZXlBcnIsICdfbmV3S2V5R2V0dGVyJywgdGhpcyk7IC8vIFRyYXZlbCBieSBpbnZlcnRlZCBvcmRlciB0byBtYWtlIHN1cmUgb3JkZXIgY29uc2lzdGVuY3lcbiAgICAvLyB3aGVuIGR1cGxpY2F0ZSBrZXlzIGV4aXN0cyAoY29uc2lkZXIgbmV3RGF0YUluZGV4LnBvcCgpIGJlbG93KS5cbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbiwgdGhlc2UgY29kZSBiZWxvdyBkbyBub3QgbG9vayBuZWF0LlxuXG4gICAgZm9yIChpID0gMDsgaSA8IG9sZEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IG9sZERhdGFLZXlBcnJbaV07XG4gICAgICB2YXIgaWR4ID0gbmV3RGF0YUluZGV4TWFwW2tleV07IC8vIGlkeCBjYW4gbmV2ZXIgYmUgZW1wdHkgYXJyYXkgaGVyZS4gc2VlICdzZXQgbnVsbCcgbG9naWMgYmVsb3cuXG5cbiAgICAgIGlmIChpZHggIT0gbnVsbCkge1xuICAgICAgICAvLyBDb25zaWRlciB0aGVyZSBpcyBkdXBsaWNhdGUga2V5IChmb3IgZXhhbXBsZSwgdXNlIGRhdGFJdGVtLm5hbWUgYXMga2V5KS5cbiAgICAgICAgLy8gV2Ugc2hvdWxkIG1ha2Ugc3VyZSBldmVyeSBpdGVtIGluIG5ld0FyciBhbmQgb2xkQXJyIGNhbiBiZSB2aXNpdGVkLlxuICAgICAgICB2YXIgbGVuID0gaWR4Lmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgbGVuID09PSAxICYmIChuZXdEYXRhSW5kZXhNYXBba2V5XSA9IG51bGwpO1xuICAgICAgICAgIGlkeCA9IGlkeC51bnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3RGF0YUluZGV4TWFwW2tleV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlICYmIHRoaXMuX3VwZGF0ZShpZHgsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlICYmIHRoaXMuX3JlbW92ZShpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGFLZXlBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBuZXdEYXRhS2V5QXJyW2ldO1xuXG4gICAgICBpZiAobmV3RGF0YUluZGV4TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIGlkeCA9IG5ld0RhdGFJbmRleE1hcFtrZXldO1xuXG4gICAgICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGlkeCBjYW4gbmV2ZXIgYmUgZW1wdHkgYXJyYXkgaGVyZS4gc2VlICdzZXQgbnVsbCcgbG9naWMgYWJvdmUuXG5cblxuICAgICAgICBpZiAoIWlkeC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9hZGQgJiYgdGhpcy5fYWRkKGlkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGlkeC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgdGhpcy5fYWRkICYmIHRoaXMuX2FkZChpZHhbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaW5pdEluZGV4TWFwKGFyciwgbWFwLCBrZXlBcnIsIGtleUdldHRlck5hbWUsIGRhdGFEaWZmZXIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cbiAgICB2YXIga2V5ID0gJ19lY18nICsgZGF0YURpZmZlcltrZXlHZXR0ZXJOYW1lXShhcnJbaV0sIGkpO1xuICAgIHZhciBleGlzdGVuY2UgPSBtYXBba2V5XTtcblxuICAgIGlmIChleGlzdGVuY2UgPT0gbnVsbCkge1xuICAgICAga2V5QXJyLnB1c2goa2V5KTtcbiAgICAgIG1hcFtrZXldID0gaTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFleGlzdGVuY2UubGVuZ3RoKSB7XG4gICAgICAgIG1hcFtrZXldID0gZXhpc3RlbmNlID0gW2V4aXN0ZW5jZV07XG4gICAgICB9XG5cbiAgICAgIGV4aXN0ZW5jZS5wdXNoKGkpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBEYXRhRGlmZmVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL0RhdGFEaWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvRGF0YURpZmZlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vbW9kZWwvTW9kZWxcIik7XG5cbnZhciBEYXRhRGlmZmVyID0gcmVxdWlyZShcIi4vRGF0YURpZmZlclwiKTtcblxudmFyIFNvdXJjZSA9IHJlcXVpcmUoXCIuL1NvdXJjZVwiKTtcblxudmFyIF9kYXRhUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvZGF0YVByb3ZpZGVyXCIpO1xuXG52YXIgZGVmYXVsdERpbVZhbHVlR2V0dGVycyA9IF9kYXRhUHJvdmlkZXIuZGVmYXVsdERpbVZhbHVlR2V0dGVycztcbnZhciBEZWZhdWx0RGF0YVByb3ZpZGVyID0gX2RhdGFQcm92aWRlci5EZWZhdWx0RGF0YVByb3ZpZGVyO1xuXG52YXIgX2RpbWVuc2lvbkhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlci9kaW1lbnNpb25IZWxwZXJcIik7XG5cbnZhciBzdW1tYXJpemVEaW1lbnNpb25zID0gX2RpbWVuc2lvbkhlbHBlci5zdW1tYXJpemVEaW1lbnNpb25zO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogTGlzdCBmb3IgZGF0YSBzdG9yYWdlXG4gKiBAbW9kdWxlIGVjaGFydHMvZGF0YS9MaXN0XG4gKi9cbnZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcbnZhciBVTkRFRklORUQgPSAndW5kZWZpbmVkJzsgLy8gVXNlIHByZWZpeCB0byBhdm9pZCBpbmRleCB0byBiZSB0aGUgc2FtZSBhcyBvdGhlcklkTGlzdFtpZHhdLFxuLy8gd2hpY2ggd2lsbCBjYXVzZSB3ZWlyZCB1ZHBhdGUgYW5pbWF0aW9uLlxuXG52YXIgSURfUFJFRklYID0gJ2VcXDBcXDAnO1xudmFyIGRhdGFDdG9ycyA9IHtcbiAgJ2Zsb2F0JzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gVU5ERUZJTkVEID8gQXJyYXkgOiBGbG9hdDY0QXJyYXksXG4gICdpbnQnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gVU5ERUZJTkVEID8gQXJyYXkgOiBJbnQzMkFycmF5LFxuICAvLyBPcmRpbmFsIGRhdGEgdHlwZSBjYW4gYmUgc3RyaW5nIG9yIGludFxuICAnb3JkaW5hbCc6IEFycmF5LFxuICAnbnVtYmVyJzogQXJyYXksXG4gICd0aW1lJzogQXJyYXlcbn07IC8vIENhdXRpb246IE1VU1Qgbm90IHVzZSBgbmV3IEN0b3JVaW50MzJBcnJheShhcnIsIDAsIGxlbilgLCBiZWNhdXNlIHRoZSBDdG9yIG9mIGFycmF5IGlzXG4vLyBkaWZmZXJlbnQgZnJvbSB0aGUgQ3RvciBvZiB0eXBlZCBhcnJheS5cblxudmFyIEN0b3JVaW50MzJBcnJheSA9IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gVU5ERUZJTkVEID8gQXJyYXkgOiBVaW50MzJBcnJheTtcbnZhciBDdG9yVWludDE2QXJyYXkgPSB0eXBlb2YgVWludDE2QXJyYXkgPT09IFVOREVGSU5FRCA/IEFycmF5IDogVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGdldEluZGljZXNDdG9yKGxpc3QpIHtcbiAgLy8gVGhlIHBvc3NpYmxlIG1heCB2YWx1ZSBpbiB0aGlzLl9pbmRpY2llcyBpcyBhbHdheXMgdGhpcy5fcmF3Q291bnQgZGVzcGl0ZSBvZiBmaWx0ZXJpbmcuXG4gIHJldHVybiBsaXN0Ll9yYXdDb3VudCA+IDY1NTM1ID8gQ3RvclVpbnQzMkFycmF5IDogQ3RvclVpbnQxNkFycmF5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUNodW5rKG9yaWdpbmFsQ2h1bmspIHtcbiAgdmFyIEN0b3IgPSBvcmlnaW5hbENodW5rLmNvbnN0cnVjdG9yOyAvLyBPbmx5IHNoYWxsb3cgY2xvbmUgaXMgZW5vdWdoIHdoZW4gQXJyYXkuXG5cbiAgcmV0dXJuIEN0b3IgPT09IEFycmF5ID8gb3JpZ2luYWxDaHVuay5zbGljZSgpIDogbmV3IEN0b3Iob3JpZ2luYWxDaHVuayk7XG59XG5cbnZhciBUUkFOU0ZFUkFCTEVfUFJPUEVSVElFUyA9IFsnaGFzSXRlbU9wdGlvbicsICdfbmFtZUxpc3QnLCAnX2lkTGlzdCcsICdfaW52ZXJ0ZWRJbmRpY2VzTWFwJywgJ19yYXdEYXRhJywgJ19jaHVua1NpemUnLCAnX2NodW5rQ291bnQnLCAnX2RpbVZhbHVlR2V0dGVyJywgJ19jb3VudCcsICdfcmF3Q291bnQnLCAnX25hbWVEaW1JZHgnLCAnX2lkRGltSWR4J107XG52YXIgQ0xPTkVfUFJPUEVSVElFUyA9IFsnX2V4dGVudCcsICdfYXBwcm94aW1hdGVFeHRlbnQnLCAnX3Jhd0V4dGVudCddO1xuXG5mdW5jdGlvbiB0cmFuc2ZlclByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgenJVdGlsLmVhY2goVFJBTlNGRVJBQkxFX1BST1BFUlRJRVMuY29uY2F0KHNvdXJjZS5fX3dyYXBwZWRNZXRob2RzIHx8IFtdKSwgZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIHRhcmdldFtwcm9wTmFtZV0gPSBzb3VyY2VbcHJvcE5hbWVdO1xuICAgIH1cbiAgfSk7XG4gIHRhcmdldC5fX3dyYXBwZWRNZXRob2RzID0gc291cmNlLl9fd3JhcHBlZE1ldGhvZHM7XG4gIHpyVXRpbC5lYWNoKENMT05FX1BST1BFUlRJRVMsIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgIHRhcmdldFtwcm9wTmFtZV0gPSB6clV0aWwuY2xvbmUoc291cmNlW3Byb3BOYW1lXSk7XG4gIH0pO1xuICB0YXJnZXQuX2NhbGN1bGF0aW9uSW5mbyA9IHpyVXRpbC5leHRlbmQoc291cmNlLl9jYWxjdWxhdGlvbkluZm8pO1xufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3RcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmd8T2JqZWN0Pn0gZGltZW5zaW9uc1xuICogICAgICBGb3IgZXhhbXBsZSwgWydzb21lRGltTmFtZScsIHtuYW1lOiAnc29tZURpbU5hbWUnLCB0eXBlOiAnc29tZURpbVR5cGUnfSwgLi4uXS5cbiAqICAgICAgRGltZW5zaW9ucyBzaG91bGQgYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xuICogICAgICBTcGV0aWFsIGZpZWxkczoge1xuICogICAgICAgICAgb3JkaW5hbE1ldGE6IDxtb2R1bGU6ZWNoYXJ0cy9kYXRhL09yZGluYWxNZXRhPlxuICogICAgICAgICAgY3JlYXRlSW52ZXJ0ZWRJbmRpY2VzOiA8Ym9vbGVhbj5cbiAqICAgICAgfVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gaG9zdE1vZGVsXG4gKi9cblxuXG52YXIgTGlzdCA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBob3N0TW9kZWwpIHtcbiAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMgfHwgWyd4JywgJ3knXTtcbiAgdmFyIGRpbWVuc2lvbkluZm9zID0ge307XG4gIHZhciBkaW1lbnNpb25OYW1lcyA9IFtdO1xuICB2YXIgaW52ZXJ0ZWRJbmRpY2VzTWFwID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gVXNlIHRoZSBvcmlnaW5hbCBkaW1lbnNpb25zW2ldLCB3aGVyZSBvdGhlciBmbGFnIHByb3BzIG1heSBleGlzdHMuXG4gICAgdmFyIGRpbWVuc2lvbkluZm8gPSBkaW1lbnNpb25zW2ldO1xuXG4gICAgaWYgKHpyVXRpbC5pc1N0cmluZyhkaW1lbnNpb25JbmZvKSkge1xuICAgICAgZGltZW5zaW9uSW5mbyA9IHtcbiAgICAgICAgbmFtZTogZGltZW5zaW9uSW5mb1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGltZW5zaW9uTmFtZSA9IGRpbWVuc2lvbkluZm8ubmFtZTtcbiAgICBkaW1lbnNpb25JbmZvLnR5cGUgPSBkaW1lbnNpb25JbmZvLnR5cGUgfHwgJ2Zsb2F0JztcblxuICAgIGlmICghZGltZW5zaW9uSW5mby5jb29yZERpbSkge1xuICAgICAgZGltZW5zaW9uSW5mby5jb29yZERpbSA9IGRpbWVuc2lvbk5hbWU7XG4gICAgICBkaW1lbnNpb25JbmZvLmNvb3JkRGltSW5kZXggPSAwO1xuICAgIH1cblxuICAgIGRpbWVuc2lvbkluZm8ub3RoZXJEaW1zID0gZGltZW5zaW9uSW5mby5vdGhlckRpbXMgfHwge307XG4gICAgZGltZW5zaW9uTmFtZXMucHVzaChkaW1lbnNpb25OYW1lKTtcbiAgICBkaW1lbnNpb25JbmZvc1tkaW1lbnNpb25OYW1lXSA9IGRpbWVuc2lvbkluZm87XG4gICAgZGltZW5zaW9uSW5mby5pbmRleCA9IGk7XG5cbiAgICBpZiAoZGltZW5zaW9uSW5mby5jcmVhdGVJbnZlcnRlZEluZGljZXMpIHtcbiAgICAgIGludmVydGVkSW5kaWNlc01hcFtkaW1lbnNpb25OYW1lXSA9IFtdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICovXG5cblxuICB0aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25OYW1lcztcbiAgLyoqXG4gICAqIEluZm9tYXRpb24gb2YgZWFjaCBkYXRhIGRpbWVuc2lvbiwgbGlrZSBkYXRhIHR5cGUuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX2RpbWVuc2lvbkluZm9zID0gZGltZW5zaW9uSW5mb3M7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAqL1xuXG4gIHRoaXMuaG9zdE1vZGVsID0gaG9zdE1vZGVsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgKi9cblxuICB0aGlzLmRhdGFUeXBlO1xuICAvKipcbiAgICogSW5kaWNlcyBzdG9yZXMgdGhlIGluZGljZXMgb2YgZGF0YSBzdWJzZXQgYWZ0ZXIgZmlsdGVyZWQuXG4gICAqIFRoaXMgZGF0YSBzdWJzZXQgd2lsbCBiZSB1c2VkIGluIGNoYXJ0LlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLl9pbmRpY2VzID0gbnVsbDtcbiAgdGhpcy5fY291bnQgPSAwO1xuICB0aGlzLl9yYXdDb3VudCA9IDA7XG4gIC8qKlxuICAgKiBEYXRhIHN0b3JhZ2VcbiAgICogQHR5cGUge09iamVjdC48a2V5LCBBcnJheS48VHlwZWRBcnJheXxBcnJheT4+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9zdG9yYWdlID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuXG4gIHRoaXMuX25hbWVMaXN0ID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuXG4gIHRoaXMuX2lkTGlzdCA9IFtdO1xuICAvKipcbiAgICogTW9kZWxzIG9mIGRhdGEgb3B0aW9uIGlzIHN0b3JlZCBzcGFyc2UgZm9yIG9wdGltaXppbmcgbWVtb3J5IGNvc3RcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX29wdGlvbk1vZGVscyA9IFtdO1xuICAvKipcbiAgICogR2xvYmFsIHZpc3VhbCBwcm9wZXJ0aWVzIGFmdGVyIHZpc3VhbCBjb2RpbmdcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fdmlzdWFsID0ge307XG4gIC8qKlxuICAgKiBHbG9iZWwgbGF5b3V0IHByb3BlcnRpZXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2xheW91dCA9IHt9O1xuICAvKipcbiAgICogSXRlbSB2aXN1YWwgcHJvcGVydGllcyBhZnRlciB2aXN1YWwgY29kaW5nXG4gICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5faXRlbVZpc3VhbHMgPSBbXTtcbiAgLyoqXG4gICAqIEtleTogdmlzdWFsIHR5cGUsIFZhbHVlOiBib29sZWFuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLmhhc0l0ZW1WaXN1YWwgPSB7fTtcbiAgLyoqXG4gICAqIEl0ZW0gbGF5b3V0IHByb3BlcnRpZXMgYWZ0ZXIgbGF5b3V0XG4gICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5faXRlbUxheW91dHMgPSBbXTtcbiAgLyoqXG4gICAqIEdyYXBoaWMgZWxlbW5lbnRzXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2dyYXBoaWNFbHMgPSBbXTtcbiAgLyoqXG4gICAqIE1heCBzaXplIG9mIGVhY2ggY2h1bmsuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2NodW5rU2l6ZSA9IDFlNTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2NodW5rQ291bnQgPSAwO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxBcnJheXxPYmplY3Q+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9yYXdEYXRhO1xuICAvKipcbiAgICogUmF3IGV4dGVudCB3aWxsIG5vdCBiZSBjbG9uZWQsIGJ1dCBvbmx5IHRyYW5zZmVyZWQuXG4gICAqIEl0IHdpbGwgbm90IGJlIGNhbGN1bGF0ZWQgdXRpbCBuZWVkZWQuXG4gICAqIGtleTogZGltLFxuICAgKiB2YWx1ZToge2VuZDogbnVtYmVyLCBleHRlbnQ6IEFycmF5LjxudW1iZXI+fVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9yYXdFeHRlbnQgPSB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2V4dGVudCA9IHt9O1xuICAvKipcbiAgICoga2V5OiBkaW1cbiAgICogdmFsdWU6IGV4dGVudFxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9hcHByb3hpbWF0ZUV4dGVudCA9IHt9O1xuICAvKipcbiAgICogQ2FjaGUgc3VtbWFyeSBpbmZvIGZvciBmYXN0IHZpc2l0LiBTZWUgXCJkaW1lbnNpb25IZWxwZXJcIi5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fZGltZW5zaW9uc1N1bW1hcnkgPSBzdW1tYXJpemVEaW1lbnNpb25zKHRoaXMpO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdC48QXJyYXl8VHlwZWRBcnJheT59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2ludmVydGVkSW5kaWNlc01hcCA9IGludmVydGVkSW5kaWNlc01hcDtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2NhbGN1bGF0aW9uSW5mbyA9IHt9O1xufTtcblxudmFyIGxpc3RQcm90byA9IExpc3QucHJvdG90eXBlO1xubGlzdFByb3RvLnR5cGUgPSAnbGlzdCc7XG4vKipcbiAqIElmIGVhY2ggZGF0YSBpdGVtIGhhcyBpdCdzIG93biBvcHRpb25cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5cbmxpc3RQcm90by5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbi8qKlxuICogR2V0IGRpbWVuc2lvbiBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRpbVxuICogICAgICAgIERpbWVuc2lvbiBjYW4gYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xuICogICAgICAgIE9yIGEgb3JkaW5hbCBudW1iZXIuIEZvciBleGFtcGxlIGdldERpbWVuc2lvbkluZm8oMCkgd2lsbCByZXR1cm4gJ3gnIG9yICdsbmcnIG9yICdyYWRpdXMnXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNyZXRlIGRpbSBuYW1lLlxuICovXG5cbmxpc3RQcm90by5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiAoZGltKSB7XG4gIGlmICghaXNOYU4oZGltKSkge1xuICAgIGRpbSA9IHRoaXMuZGltZW5zaW9uc1tkaW1dIHx8IGRpbTtcbiAgfVxuXG4gIHJldHVybiBkaW07XG59O1xuLyoqXG4gKiBHZXQgdHlwZSBhbmQgY2FsY3VsYXRpb24gaW5mbyBvZiBwYXJ0aWN1bGFyIGRpbWVuc2lvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkaW1cbiAqICAgICAgICBEaW1lbnNpb24gY2FuIGJlIGNvbmNyZXRlIG5hbWVzIGxpa2UgeCwgeSwgeiwgbG5nLCBsYXQsIGFuZ2xlLCByYWRpdXNcbiAqICAgICAgICBPciBhIG9yZGluYWwgbnVtYmVyLiBGb3IgZXhhbXBsZSBnZXREaW1lbnNpb25JbmZvKDApIHdpbGwgcmV0dXJuICd4JyBvciAnbG5nJyBvciAncmFkaXVzJ1xuICovXG5cblxubGlzdFByb3RvLmdldERpbWVuc2lvbkluZm8gPSBmdW5jdGlvbiAoZGltKSB7XG4gIC8vIERvIG5vdCBjbG9uZSwgYmVjYXVzZSB0aGVyZSBtYXkgYmUgY2F0ZWdvcmllcyBpbiBkaW1JbmZvLlxuICByZXR1cm4gdGhpcy5fZGltZW5zaW9uSW5mb3NbdGhpcy5nZXREaW1lbnNpb24oZGltKV07XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gY29uY3JldGUgZGltZW5zaW9uIG5hbWUgbGlzdCBvbiBjb29yZC5cbiAqL1xuXG5cbmxpc3RQcm90by5nZXREaW1lbnNpb25zT25Db29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RpbWVuc2lvbnNTdW1tYXJ5LmRhdGFEaW1zT25Db29yZC5zbGljZSgpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkRGltXG4gKiBAcGFyYW0ge251bWJlcn0gW2lkeF0gQSBjb29yZERpbSBtYXkgbWFwIHRvIG1vcmUgdGhhbiBvbmUgZGF0YSBkaW0uXG4gKiAgICAgICAgSWYgaWR4IGlzIGB0cnVlYCwgcmV0dXJuIGEgYXJyYXkgb2YgYWxsIG1hcHBlZCBkaW1zLlxuICogICAgICAgIElmIGlkeCBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGZpcnN0IGRpbSBub3QgZXh0cmEuXG4gKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IGNvbmNyZXRlIGRhdGEgZGltLlxuICogICAgICAgIElmIGlkeCBpcyBudW1iZXIsIGFuZCBub3QgZm91bmQsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAqICAgICAgICBJZiBpZHggaXMgYHRydWVgLCBhbmQgbm90IGZvdW5kLCByZXR1cm4gZW1wdHkgYXJyYXkgKGFsd2F5cyByZXR1cm4gYXJyYXkpLlxuICovXG5cblxubGlzdFByb3RvLm1hcERpbWVuc2lvbiA9IGZ1bmN0aW9uIChjb29yZERpbSwgaWR4KSB7XG4gIHZhciBkaW1lbnNpb25zU3VtbWFyeSA9IHRoaXMuX2RpbWVuc2lvbnNTdW1tYXJ5O1xuXG4gIGlmIChpZHggPT0gbnVsbCkge1xuICAgIHJldHVybiBkaW1lbnNpb25zU3VtbWFyeS5lbmNvZGVGaXJzdERpbU5vdEV4dHJhW2Nvb3JkRGltXTtcbiAgfVxuXG4gIHZhciBkaW1zID0gZGltZW5zaW9uc1N1bW1hcnkuZW5jb2RlW2Nvb3JkRGltXTtcbiAgcmV0dXJuIGlkeCA9PT0gdHJ1ZSAvLyBhbHdheXMgcmV0dXJuIGFycmF5IGlmIGlkeCBpcyBgdHJ1ZWBcbiAgPyAoZGltcyB8fCBbXSkuc2xpY2UoKSA6IGRpbXMgJiYgZGltc1tpZHhdO1xufTtcbi8qKlxuICogSW5pdGlhbGl6ZSBmcm9tIGRhdGFcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdHxudW1iZXJ8QXJyYXk+fSBkYXRhIHNvdXJjZSBvciBkYXRhIG9yIGRhdGEgcHJvdmlkZXIuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbbmFtZUxJc3RdIFRoZSBuYW1lIG9mIGEgZGF0dW0gaXMgdXNlZCBvbiBkYXRhIGRpZmYgYW5kXG4gKiAgICAgICAgZGVmdWFsdCBsYWJlbC90b29sdGlwLlxuICogICAgICAgIEEgbmFtZSBjYW4gYmUgc3BlY2lmaWVkIGluIGVuY29kZS5pdGVtTmFtZSxcbiAqICAgICAgICBvciBkYXRhSXRlbS5uYW1lIChvbmx5IGZvciBzZXJpZXMgb3B0aW9uIGRhdGEpLFxuICogICAgICAgIG9yIHByb3ZpZGVkIGluIG5hbWVMaXN0IGZyb20gb3V0c2lkZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtkaW1WYWx1ZUdldHRlcl0gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSA9PiBudW1iZXJcbiAqL1xuXG5cbmxpc3RQcm90by5pbml0RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBuYW1lTGlzdCwgZGltVmFsdWVHZXR0ZXIpIHtcbiAgdmFyIG5vdFByb3ZpZGVyID0gU291cmNlLmlzSW5zdGFuY2UoZGF0YSkgfHwgenJVdGlsLmlzQXJyYXlMaWtlKGRhdGEpO1xuXG4gIGlmIChub3RQcm92aWRlcikge1xuICAgIGRhdGEgPSBuZXcgRGVmYXVsdERhdGFQcm92aWRlcihkYXRhLCB0aGlzLmRpbWVuc2lvbnMubGVuZ3RoKTtcbiAgfVxuXG4gIHRoaXMuX3Jhd0RhdGEgPSBkYXRhOyAvLyBDbGVhclxuXG4gIHRoaXMuX3N0b3JhZ2UgPSB7fTtcbiAgdGhpcy5faW5kaWNlcyA9IG51bGw7XG4gIHRoaXMuX25hbWVMaXN0ID0gbmFtZUxpc3QgfHwgW107XG4gIHRoaXMuX2lkTGlzdCA9IFtdO1xuICB0aGlzLl9uYW1lUmVwZWF0Q291bnQgPSB7fTtcblxuICBpZiAoIWRpbVZhbHVlR2V0dGVyKSB7XG4gICAgdGhpcy5oYXNJdGVtT3B0aW9uID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cblxuXG4gIHRoaXMuZGVmYXVsdERpbVZhbHVlR2V0dGVyID0gZGVmYXVsdERpbVZhbHVlR2V0dGVyc1t0aGlzLl9yYXdEYXRhLmdldFNvdXJjZSgpLnNvdXJjZUZvcm1hdF07IC8vIERlZmF1bHQgZGltIHZhbHVlIGdldHRlclxuXG4gIHRoaXMuX2RpbVZhbHVlR2V0dGVyID0gZGltVmFsdWVHZXR0ZXIgPSBkaW1WYWx1ZUdldHRlciB8fCB0aGlzLmRlZmF1bHREaW1WYWx1ZUdldHRlcjsgLy8gUmVzZXQgcmF3IGV4dGVudC5cblxuICB0aGlzLl9yYXdFeHRlbnQgPSB7fTtcblxuICB0aGlzLl9pbml0RGF0YUZyb21Qcm92aWRlcigwLCBkYXRhLmNvdW50KCkpOyAvLyBJZiBkYXRhIGhhcyBubyBpdGVtIG9wdGlvbi5cblxuXG4gIGlmIChkYXRhLnB1cmUpIHtcbiAgICB0aGlzLmhhc0l0ZW1PcHRpb24gPSBmYWxzZTtcbiAgfVxufTtcblxubGlzdFByb3RvLmdldFByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmF3RGF0YTtcbn07XG5cbmxpc3RQcm90by5hcHBlbmREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHJhd0RhdGEgPSB0aGlzLl9yYXdEYXRhO1xuICB2YXIgc3RhcnQgPSB0aGlzLmNvdW50KCk7XG4gIHJhd0RhdGEuYXBwZW5kRGF0YShkYXRhKTtcbiAgdmFyIGVuZCA9IHJhd0RhdGEuY291bnQoKTtcblxuICBpZiAoIXJhd0RhdGEucGVyc2lzdGVudCkge1xuICAgIGVuZCArPSBzdGFydDtcbiAgfVxuXG4gIHRoaXMuX2luaXREYXRhRnJvbVByb3ZpZGVyKHN0YXJ0LCBlbmQpO1xufTtcblxubGlzdFByb3RvLl9pbml0RGF0YUZyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIC8vIE9wdGltaXplLlxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMuX2NodW5rU2l6ZTtcbiAgdmFyIHJhd0RhdGEgPSB0aGlzLl9yYXdEYXRhO1xuICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICB2YXIgZGltTGVuID0gZGltZW5zaW9ucy5sZW5ndGg7XG4gIHZhciBkaW1lbnNpb25JbmZvTWFwID0gdGhpcy5fZGltZW5zaW9uSW5mb3M7XG4gIHZhciBuYW1lTGlzdCA9IHRoaXMuX25hbWVMaXN0O1xuICB2YXIgaWRMaXN0ID0gdGhpcy5faWRMaXN0O1xuICB2YXIgcmF3RXh0ZW50ID0gdGhpcy5fcmF3RXh0ZW50O1xuICB2YXIgbmFtZVJlcGVhdENvdW50ID0gdGhpcy5fbmFtZVJlcGVhdENvdW50ID0ge307XG4gIHZhciBuYW1lRGltSWR4O1xuICB2YXIgY2h1bmtDb3VudCA9IHRoaXMuX2NodW5rQ291bnQ7XG4gIHZhciBsYXN0Q2h1bmtJbmRleCA9IGNodW5rQ291bnQgLSAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGltTGVuOyBpKyspIHtcbiAgICB2YXIgZGltID0gZGltZW5zaW9uc1tpXTtcblxuICAgIGlmICghcmF3RXh0ZW50W2RpbV0pIHtcbiAgICAgIHJhd0V4dGVudFtkaW1dID0gZ2V0SW5pdGlhbEV4dGVudCgpO1xuICAgIH1cblxuICAgIHZhciBkaW1JbmZvID0gZGltZW5zaW9uSW5mb01hcFtkaW1dO1xuXG4gICAgaWYgKGRpbUluZm8ub3RoZXJEaW1zLml0ZW1OYW1lID09PSAwKSB7XG4gICAgICBuYW1lRGltSWR4ID0gdGhpcy5fbmFtZURpbUlkeCA9IGk7XG4gICAgfVxuXG4gICAgaWYgKGRpbUluZm8ub3RoZXJEaW1zLml0ZW1JZCA9PT0gMCkge1xuICAgICAgdGhpcy5faWREaW1JZHggPSBpO1xuICAgIH1cblxuICAgIHZhciBEYXRhQ3RvciA9IGRhdGFDdG9yc1tkaW1JbmZvLnR5cGVdO1xuXG4gICAgaWYgKCFzdG9yYWdlW2RpbV0pIHtcbiAgICAgIHN0b3JhZ2VbZGltXSA9IFtdO1xuICAgIH1cblxuICAgIHZhciByZXNpemVDaHVua0FycmF5ID0gc3RvcmFnZVtkaW1dW2xhc3RDaHVua0luZGV4XTtcblxuICAgIGlmIChyZXNpemVDaHVua0FycmF5ICYmIHJlc2l6ZUNodW5rQXJyYXkubGVuZ3RoIDwgY2h1bmtTaXplKSB7XG4gICAgICB2YXIgbmV3U3RvcmUgPSBuZXcgRGF0YUN0b3IoTWF0aC5taW4oZW5kIC0gbGFzdENodW5rSW5kZXggKiBjaHVua1NpemUsIGNodW5rU2l6ZSkpOyAvLyBUaGUgY29zdCBvZiB0aGUgY29weSBpcyBwcm9iYWJseSBpbmNvbnNpZGVyYWJsZVxuICAgICAgLy8gd2l0aGluIHRoZSBpbml0aWFsIGNodW5rU2l6ZS5cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXNpemVDaHVua0FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG5ld1N0b3JlW2pdID0gcmVzaXplQ2h1bmtBcnJheVtqXTtcbiAgICAgIH1cblxuICAgICAgc3RvcmFnZVtkaW1dW2xhc3RDaHVua0luZGV4XSA9IG5ld1N0b3JlO1xuICAgIH0gLy8gQ3JlYXRlIG5ldyBjaHVua3MuXG5cblxuICAgIGZvciAodmFyIGsgPSBjaHVua0NvdW50ICogY2h1bmtTaXplOyBrIDwgZW5kOyBrICs9IGNodW5rU2l6ZSkge1xuICAgICAgc3RvcmFnZVtkaW1dLnB1c2gobmV3IERhdGFDdG9yKE1hdGgubWluKGVuZCAtIGssIGNodW5rU2l6ZSkpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaHVua0NvdW50ID0gc3RvcmFnZVtkaW1dLmxlbmd0aDtcbiAgfVxuXG4gIHZhciBkYXRhSXRlbSA9IG5ldyBBcnJheShkaW1MZW4pO1xuXG4gIGZvciAodmFyIGlkeCA9IHN0YXJ0OyBpZHggPCBlbmQ7IGlkeCsrKSB7XG4gICAgLy8gTk9USUNFOiBUcnkgbm90IHRvIHdyaXRlIHRoaW5ncyBpbnRvIGRhdGFJdGVtXG4gICAgZGF0YUl0ZW0gPSByYXdEYXRhLmdldEl0ZW0oaWR4LCBkYXRhSXRlbSk7IC8vIEVhY2ggZGF0YSBpdGVtIGlzIHZhbHVlXG4gICAgLy8gWzEsIDJdXG4gICAgLy8gMlxuICAgIC8vIEJhciBjaGFydCwgbGluZSBjaGFydCB3aGljaCB1c2VzIGNhdGVnb3J5IGF4aXNcbiAgICAvLyBvbmx5IGdpdmVzIHRoZSAneScgdmFsdWUuICd4JyB2YWx1ZSBpcyB0aGUgaW5kaWNlcyBvZiBjYXRlZ29yeVxuICAgIC8vIFVzZSBhIHRlbXBWYWx1ZSB0byBub3JtYWxpemUgdGhlIHZhbHVlIHRvIGJlIGEgKHgsIHkpIHZhbHVlXG5cbiAgICB2YXIgY2h1bmtJbmRleCA9IE1hdGguZmxvb3IoaWR4IC8gY2h1bmtTaXplKTtcbiAgICB2YXIgY2h1bmtPZmZzZXQgPSBpZHggJSBjaHVua1NpemU7IC8vIFN0b3JlIHRoZSBkYXRhIGJ5IGRpbWVuc2lvbnNcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltTGVuOyBrKyspIHtcbiAgICAgIHZhciBkaW0gPSBkaW1lbnNpb25zW2tdO1xuICAgICAgdmFyIGRpbVN0b3JhZ2UgPSBzdG9yYWdlW2RpbV1bY2h1bmtJbmRleF07IC8vIFBFTkRJTkcgTlVMTCBpcyBlbXB0eSBvciB6ZXJvXG5cbiAgICAgIHZhciB2YWwgPSB0aGlzLl9kaW1WYWx1ZUdldHRlcihkYXRhSXRlbSwgZGltLCBpZHgsIGspO1xuXG4gICAgICBkaW1TdG9yYWdlW2NodW5rT2Zmc2V0XSA9IHZhbDtcbiAgICAgIHZhciBkaW1SYXdFeHRlbnQgPSByYXdFeHRlbnRbZGltXTtcblxuICAgICAgaWYgKHZhbCA8IGRpbVJhd0V4dGVudFswXSkge1xuICAgICAgICBkaW1SYXdFeHRlbnRbMF0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWwgPiBkaW1SYXdFeHRlbnRbMV0pIHtcbiAgICAgICAgZGltUmF3RXh0ZW50WzFdID0gdmFsO1xuICAgICAgfVxuICAgIH0gLy8gPz8/IEZJWE1FIG5vdCBjaGVjayBieSBwdXJlIGJ1dCBzb3VyY2VGb3JtYXQ/XG4gICAgLy8gVE9ETyByZWZhY3RvciB0aGVzZSBsb2dpYy5cblxuXG4gICAgaWYgKCFyYXdEYXRhLnB1cmUpIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZUxpc3RbaWR4XTtcblxuICAgICAgaWYgKGRhdGFJdGVtICYmIG5hbWUgPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiBkYXRhSXRlbSBpcyB7bmFtZTogLi4ufSwgaXQgaGFzIGhpZ2hlc3QgcHJpb3JpdHkuXG4gICAgICAgIC8vIFRoYXQgaXMgYXBwcm9wcmlhdGUgZm9yIG1hbnkgY29tbW9uIGNhc2VzLlxuICAgICAgICBpZiAoZGF0YUl0ZW0ubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gb3RoZXIgcGxhY2UgdG8gcGVyc2lzdGVudCBkYXRhSXRlbS5uYW1lLFxuICAgICAgICAgIC8vIHNvIHNhdmUgaXQgdG8gbmFtZUxpc3QuXG4gICAgICAgICAgbmFtZUxpc3RbaWR4XSA9IG5hbWUgPSBkYXRhSXRlbS5uYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWVEaW1JZHggIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBuYW1lRGltID0gZGltZW5zaW9uc1tuYW1lRGltSWR4XTtcbiAgICAgICAgICB2YXIgbmFtZURpbUNodW5rID0gc3RvcmFnZVtuYW1lRGltXVtjaHVua0luZGV4XTtcblxuICAgICAgICAgIGlmIChuYW1lRGltQ2h1bmspIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lRGltQ2h1bmtbY2h1bmtPZmZzZXRdO1xuICAgICAgICAgICAgdmFyIG9yZGluYWxNZXRhID0gZGltZW5zaW9uSW5mb01hcFtuYW1lRGltXS5vcmRpbmFsTWV0YTtcblxuICAgICAgICAgICAgaWYgKG9yZGluYWxNZXRhICYmIG9yZGluYWxNZXRhLmNhdGVnb3JpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBvcmRpbmFsTWV0YS5jYXRlZ29yaWVzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBUcnkgdXNpbmcgdGhlIGlkIGluIG9wdGlvblxuICAgICAgLy8gaWQgb3IgbmFtZSBpcyB1c2VkIG9uIGR5bmFtaWNhbCBkYXRhLCBtYXBwaW5nIG9sZCBhbmQgbmV3IGl0ZW1zLlxuXG5cbiAgICAgIHZhciBpZCA9IGRhdGFJdGVtID09IG51bGwgPyBudWxsIDogZGF0YUl0ZW0uaWQ7XG5cbiAgICAgIGlmIChpZCA9PSBudWxsICYmIG5hbWUgIT0gbnVsbCkge1xuICAgICAgICAvLyBVc2UgbmFtZSBhcyBpZCBhbmQgYWRkIGNvdW50ZXIgdG8gYXZvaWQgc2FtZSBuYW1lXG4gICAgICAgIG5hbWVSZXBlYXRDb3VudFtuYW1lXSA9IG5hbWVSZXBlYXRDb3VudFtuYW1lXSB8fCAwO1xuICAgICAgICBpZCA9IG5hbWU7XG5cbiAgICAgICAgaWYgKG5hbWVSZXBlYXRDb3VudFtuYW1lXSA+IDApIHtcbiAgICAgICAgICBpZCArPSAnX19lY19fJyArIG5hbWVSZXBlYXRDb3VudFtuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVSZXBlYXRDb3VudFtuYW1lXSsrO1xuICAgICAgfVxuXG4gICAgICBpZCAhPSBudWxsICYmIChpZExpc3RbaWR4XSA9IGlkKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXJhd0RhdGEucGVyc2lzdGVudCAmJiByYXdEYXRhLmNsZWFuKSB7XG4gICAgLy8gQ2xlYW4gdW51c2VkIGRhdGEgaWYgZGF0YSBzb3VyY2UgaXMgdHlwZWQgYXJyYXkuXG4gICAgcmF3RGF0YS5jbGVhbigpO1xuICB9XG5cbiAgdGhpcy5fcmF3Q291bnQgPSB0aGlzLl9jb3VudCA9IGVuZDsgLy8gUmVzZXQgZGF0YSBleHRlbnRcblxuICB0aGlzLl9leHRlbnQgPSB7fTtcbiAgcHJlcGFyZUludmVydGVkSW5kZXgodGhpcyk7XG59O1xuXG5mdW5jdGlvbiBwcmVwYXJlSW52ZXJ0ZWRJbmRleChsaXN0KSB7XG4gIHZhciBpbnZlcnRlZEluZGljZXNNYXAgPSBsaXN0Ll9pbnZlcnRlZEluZGljZXNNYXA7XG4gIHpyVXRpbC5lYWNoKGludmVydGVkSW5kaWNlc01hcCwgZnVuY3Rpb24gKGludmVydGVkSW5kaWNlcywgZGltKSB7XG4gICAgdmFyIGRpbUluZm8gPSBsaXN0Ll9kaW1lbnNpb25JbmZvc1tkaW1dOyAvLyBDdXJyZW50bHksIG9ubHkgZGltZW5zaW9ucyB0aGF0IGhhcyBvcmRpbmFsTWV0YSBjYW4gY3JlYXRlIGludmVydGVkIGluZGljZXMuXG5cbiAgICB2YXIgb3JkaW5hbE1ldGEgPSBkaW1JbmZvLm9yZGluYWxNZXRhO1xuXG4gICAgaWYgKG9yZGluYWxNZXRhKSB7XG4gICAgICBpbnZlcnRlZEluZGljZXMgPSBpbnZlcnRlZEluZGljZXNNYXBbZGltXSA9IG5ldyBDdG9yVWludDMyQXJyYXkob3JkaW5hbE1ldGEuY2F0ZWdvcmllcy5sZW5ndGgpOyAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBUeXBlZEFycmF5IGlzIDAuIFRvIGF2b2lkIG1pc3NcbiAgICAgIC8vIG1hcHBpbmcgdG8gMCwgd2Ugc2hvdWxkIHNldCBpdCBhcyBOYU4uXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW52ZXJ0ZWRJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludmVydGVkSW5kaWNlc1tpXSA9IE5hTjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Ll9jb3VudDsgaSsrKSB7XG4gICAgICAgIC8vIE9ubHkgc3VwcG9ydCB0aGUgY2FzZSB0aGF0IGFsbCB2YWx1ZXMgYXJlIGRpc3RpbmN0LlxuICAgICAgICBpbnZlcnRlZEluZGljZXNbbGlzdC5nZXQoZGltLCBpKV0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFJhd1ZhbHVlRnJvbVN0b3JlKGxpc3QsIGRpbUluZGV4LCByYXdJbmRleCkge1xuICB2YXIgdmFsO1xuXG4gIGlmIChkaW1JbmRleCAhPSBudWxsKSB7XG4gICAgdmFyIGNodW5rU2l6ZSA9IGxpc3QuX2NodW5rU2l6ZTtcbiAgICB2YXIgY2h1bmtJbmRleCA9IE1hdGguZmxvb3IocmF3SW5kZXggLyBjaHVua1NpemUpO1xuICAgIHZhciBjaHVua09mZnNldCA9IHJhd0luZGV4ICUgY2h1bmtTaXplO1xuICAgIHZhciBkaW0gPSBsaXN0LmRpbWVuc2lvbnNbZGltSW5kZXhdO1xuICAgIHZhciBjaHVuayA9IGxpc3QuX3N0b3JhZ2VbZGltXVtjaHVua0luZGV4XTtcblxuICAgIGlmIChjaHVuaykge1xuICAgICAgdmFsID0gY2h1bmtbY2h1bmtPZmZzZXRdO1xuICAgICAgdmFyIG9yZGluYWxNZXRhID0gbGlzdC5fZGltZW5zaW9uSW5mb3NbZGltXS5vcmRpbmFsTWV0YTtcblxuICAgICAgaWYgKG9yZGluYWxNZXRhICYmIG9yZGluYWxNZXRhLmNhdGVnb3JpZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbCA9IG9yZGluYWxNZXRhLmNhdGVnb3JpZXNbdmFsXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9jb3VudDtcbn07XG5cbmxpc3RQcm90by5nZXRJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmV3SW5kaWNlcztcbiAgdmFyIGluZGljZXMgPSB0aGlzLl9pbmRpY2VzO1xuXG4gIGlmIChpbmRpY2VzKSB7XG4gICAgdmFyIEN0b3IgPSBpbmRpY2VzLmNvbnN0cnVjdG9yO1xuICAgIHZhciB0aGlzQ291bnQgPSB0aGlzLl9jb3VudDsgLy8gYG5ldyBBcnJheShhLCBiLCBjKWAgaXMgZGlmZmVyZW50IGZyb20gYG5ldyBVaW50MzJBcnJheShhLCBiLCBjKWAuXG5cbiAgICBpZiAoQ3RvciA9PT0gQXJyYXkpIHtcbiAgICAgIG5ld0luZGljZXMgPSBuZXcgQ3Rvcih0aGlzQ291bnQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXNDb3VudDsgaSsrKSB7XG4gICAgICAgIG5ld0luZGljZXNbaV0gPSBpbmRpY2VzW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdJbmRpY2VzID0gbmV3IEN0b3IoaW5kaWNlcy5idWZmZXIsIDAsIHRoaXNDb3VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBDdG9yID0gZ2V0SW5kaWNlc0N0b3IodGhpcyk7XG4gICAgdmFyIG5ld0luZGljZXMgPSBuZXcgQ3Rvcih0aGlzLmNvdW50KCkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdJbmRpY2VzW2ldID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3SW5kaWNlcztcbn07XG4vKipcbiAqIEdldCB2YWx1ZS4gUmV0dXJuIE5hTiBpZiBpZHggaXMgb3V0IG9mIHJhbmdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGRpbSBEaW0gbXVzdCBiZSBjb25jcmV0ZSBuYW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmdldCA9IGZ1bmN0aW9uIChkaW0sIGlkeFxuLyosIHN0YWNrICovXG4pIHtcbiAgaWYgKCEoaWR4ID49IDAgJiYgaWR4IDwgdGhpcy5fY291bnQpKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcblxuICBpZiAoIXN0b3JhZ2VbZGltXSkge1xuICAgIC8vIFRPRE8gV2FybiA/XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIGlkeCA9IHRoaXMuZ2V0UmF3SW5kZXgoaWR4KTtcbiAgdmFyIGNodW5rSW5kZXggPSBNYXRoLmZsb29yKGlkeCAvIHRoaXMuX2NodW5rU2l6ZSk7XG4gIHZhciBjaHVua09mZnNldCA9IGlkeCAlIHRoaXMuX2NodW5rU2l6ZTtcbiAgdmFyIGNodW5rU3RvcmUgPSBzdG9yYWdlW2RpbV1bY2h1bmtJbmRleF07XG4gIHZhciB2YWx1ZSA9IGNodW5rU3RvcmVbY2h1bmtPZmZzZXRdOyAvLyBGSVhNRSBvcmRpbmFsIGRhdGEgdHlwZSBpcyBub3Qgc3RhY2thYmxlXG4gIC8vIGlmIChzdGFjaykge1xuICAvLyAgICAgdmFyIGRpbWVuc2lvbkluZm8gPSB0aGlzLl9kaW1lbnNpb25JbmZvc1tkaW1dO1xuICAvLyAgICAgaWYgKGRpbWVuc2lvbkluZm8gJiYgZGltZW5zaW9uSW5mby5zdGFja2FibGUpIHtcbiAgLy8gICAgICAgICB2YXIgc3RhY2tlZE9uID0gdGhpcy5zdGFja2VkT247XG4gIC8vICAgICAgICAgd2hpbGUgKHN0YWNrZWRPbikge1xuICAvLyAgICAgICAgICAgICAvLyBHZXQgbm8gc3RhY2tlZCBkYXRhIG9mIHN0YWNrZWQgb25cbiAgLy8gICAgICAgICAgICAgdmFyIHN0YWNrZWRWYWx1ZSA9IHN0YWNrZWRPbi5nZXQoZGltLCBpZHgpO1xuICAvLyAgICAgICAgICAgICAvLyBDb25zaWRlcmluZyBwb3NpdGl2ZSBzdGFjaywgbmVnYXRpdmUgc3RhY2sgYW5kIGVtcHR5IGRhdGFcbiAgLy8gICAgICAgICAgICAgaWYgKCh2YWx1ZSA+PSAwICYmIHN0YWNrZWRWYWx1ZSA+IDApICAvLyBQb3NpdGl2ZSBzdGFja1xuICAvLyAgICAgICAgICAgICAgICAgfHwgKHZhbHVlIDw9IDAgJiYgc3RhY2tlZFZhbHVlIDwgMCkgLy8gTmVnYXRpdmUgc3RhY2tcbiAgLy8gICAgICAgICAgICAgKSB7XG4gIC8vICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzdGFja2VkVmFsdWU7XG4gIC8vICAgICAgICAgICAgIH1cbiAgLy8gICAgICAgICAgICAgc3RhY2tlZE9uID0gc3RhY2tlZE9uLnN0YWNrZWRPbjtcbiAgLy8gICAgICAgICB9XG4gIC8vICAgICB9XG4gIC8vIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltIGNvbmNyZXRlIGRpbVxuICogQHBhcmFtIHtudW1iZXJ9IHJhd0luZGV4XG4gKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfVxuICovXG5cblxubGlzdFByb3RvLmdldEJ5UmF3SW5kZXggPSBmdW5jdGlvbiAoZGltLCByYXdJZHgpIHtcbiAgaWYgKCEocmF3SWR4ID49IDAgJiYgcmF3SWR4IDwgdGhpcy5fcmF3Q291bnQpKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHZhciBkaW1TdG9yZSA9IHRoaXMuX3N0b3JhZ2VbZGltXTtcblxuICBpZiAoIWRpbVN0b3JlKSB7XG4gICAgLy8gVE9ETyBXYXJuID9cbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgdmFyIGNodW5rSW5kZXggPSBNYXRoLmZsb29yKHJhd0lkeCAvIHRoaXMuX2NodW5rU2l6ZSk7XG4gIHZhciBjaHVua09mZnNldCA9IHJhd0lkeCAlIHRoaXMuX2NodW5rU2l6ZTtcbiAgdmFyIGNodW5rU3RvcmUgPSBkaW1TdG9yZVtjaHVua0luZGV4XTtcbiAgcmV0dXJuIGNodW5rU3RvcmVbY2h1bmtPZmZzZXRdO1xufTtcbi8qKlxuICogRklYTUUgVXNlIGBnZXRgIG9uIGNocm9tZSBtYXliZSBzbG93KGluIGZpbHRlclNlbGYgYW5kIHNlbGVjdFJhbmdlKS5cbiAqIEhhY2sgYSBtdWNoIHNpbXBsZXIgX2dldEZhc3RcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5saXN0UHJvdG8uX2dldEZhc3QgPSBmdW5jdGlvbiAoZGltLCByYXdJZHgpIHtcbiAgdmFyIGNodW5rSW5kZXggPSBNYXRoLmZsb29yKHJhd0lkeCAvIHRoaXMuX2NodW5rU2l6ZSk7XG4gIHZhciBjaHVua09mZnNldCA9IHJhd0lkeCAlIHRoaXMuX2NodW5rU2l6ZTtcbiAgdmFyIGNodW5rU3RvcmUgPSB0aGlzLl9zdG9yYWdlW2RpbV1bY2h1bmtJbmRleF07XG4gIHJldHVybiBjaHVua1N0b3JlW2NodW5rT2Zmc2V0XTtcbn07XG4vKipcbiAqIEdldCB2YWx1ZSBmb3IgbXVsdGkgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtkaW1lbnNpb25zXSBJZiBpZ25vcmVkLCB1c2luZyBhbGwgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgaWR4XG4vKiwgc3RhY2sgKi9cbikge1xuICB2YXIgdmFsdWVzID0gW107XG5cbiAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkge1xuICAgIC8vIHN0YWNrID0gaWR4O1xuICAgIGlkeCA9IGRpbWVuc2lvbnM7XG4gICAgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFsdWVzLnB1c2godGhpcy5nZXQoZGltZW5zaW9uc1tpXSwgaWR4XG4gICAgLyosIHN0YWNrICovXG4gICAgKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufTtcbi8qKlxuICogSWYgdmFsdWUgaXMgTmFOLiBJbmxjdWRpbmcgJy0nXG4gKiBPbmx5IGNoZWNrIHRoZSBjb29yZCBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmhhc1ZhbHVlID0gZnVuY3Rpb24gKGlkeCkge1xuICB2YXIgZGF0YURpbXNPbkNvb3JkID0gdGhpcy5fZGltZW5zaW9uc1N1bW1hcnkuZGF0YURpbXNPbkNvb3JkO1xuICB2YXIgZGltZW5zaW9uSW5mb3MgPSB0aGlzLl9kaW1lbnNpb25JbmZvcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YURpbXNPbkNvb3JkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCAvLyBPcmRpbmFsIHR5cGUgY2FuIGJlIHN0cmluZyBvciBudW1iZXJcbiAgICBkaW1lbnNpb25JbmZvc1tkYXRhRGltc09uQ29vcmRbaV1dLnR5cGUgIT09ICdvcmRpbmFsJyAvLyBGSVhNRSBjaGVjayBvcmRpbmFsIHdoZW4gdXNpbmcgaW5kZXg/XG4gICAgJiYgaXNOYU4odGhpcy5nZXQoZGF0YURpbXNPbkNvb3JkW2ldLCBpZHgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogR2V0IGV4dGVudCBvZiBkYXRhIGluIG9uZSBkaW1lbnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tcbiAqL1xuXG5cbmxpc3RQcm90by5nZXREYXRhRXh0ZW50ID0gZnVuY3Rpb24gKGRpbVxuLyosIHN0YWNrICovXG4pIHtcbiAgLy8gTWFrZSBzdXJlIHVzZSBjb25jcmV0ZSBkaW0gYXMgY2FjaGUgbmFtZS5cbiAgZGltID0gdGhpcy5nZXREaW1lbnNpb24oZGltKTtcbiAgdmFyIGRpbURhdGEgPSB0aGlzLl9zdG9yYWdlW2RpbV07XG4gIHZhciBpbml0aWFsRXh0ZW50ID0gZ2V0SW5pdGlhbEV4dGVudCgpOyAvLyBzdGFjayA9ICEhKChzdGFjayB8fCBmYWxzZSkgJiYgdGhpcy5nZXRDYWxjdWxhdGlvbkluZm8oZGltKSk7XG5cbiAgaWYgKCFkaW1EYXRhKSB7XG4gICAgcmV0dXJuIGluaXRpYWxFeHRlbnQ7XG4gIH0gLy8gTWFrZSBtb3JlIHN0cmljdCBjaGVja2luZ3MgdG8gZW5zdXJlIGhpdHRpbmcgY2FjaGUuXG5cblxuICB2YXIgY3VyckVuZCA9IHRoaXMuY291bnQoKTsgLy8gdmFyIGNhY2hlTmFtZSA9IFtkaW0sICEhc3RhY2tdLmpvaW4oJ18nKTtcbiAgLy8gdmFyIGNhY2hlTmFtZSA9IGRpbTtcbiAgLy8gQ29uc2lkZXIgdGhlIG1vc3QgY2FzZXMgd2hlbiB1c2luZyBkYXRhIHpvb20sIGBnZXREYXRhRXh0ZW50YFxuICAvLyBoYXBwZW5lZCBiZWZvcmUgZmlsdGVyaW5nLiBXZSBjYWNoZSByYXcgZXh0ZW50LCB3aGljaCBpcyBub3RcbiAgLy8gbmVjZXNzYXJ5IHRvIGJlIGNsZWFyZWQgYW5kIHJlY2FsY3VsYXRlZCB3aGVuIHJlc3RvcmUgZGF0YS5cblxuICB2YXIgdXNlUmF3ID0gIXRoaXMuX2luZGljZXM7IC8vICYmICFzdGFjaztcblxuICB2YXIgZGltRXh0ZW50O1xuXG4gIGlmICh1c2VSYXcpIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3RXh0ZW50W2RpbV0uc2xpY2UoKTtcbiAgfVxuXG4gIGRpbUV4dGVudCA9IHRoaXMuX2V4dGVudFtkaW1dO1xuXG4gIGlmIChkaW1FeHRlbnQpIHtcbiAgICByZXR1cm4gZGltRXh0ZW50LnNsaWNlKCk7XG4gIH1cblxuICBkaW1FeHRlbnQgPSBpbml0aWFsRXh0ZW50O1xuICB2YXIgbWluID0gZGltRXh0ZW50WzBdO1xuICB2YXIgbWF4ID0gZGltRXh0ZW50WzFdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyckVuZDsgaSsrKSB7XG4gICAgLy8gdmFyIHZhbHVlID0gc3RhY2sgPyB0aGlzLmdldChkaW0sIGksIHRydWUpIDogdGhpcy5fZ2V0RmFzdChkaW0sIHRoaXMuZ2V0UmF3SW5kZXgoaSkpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldEZhc3QoZGltLCB0aGlzLmdldFJhd0luZGV4KGkpKTtcblxuICAgIHZhbHVlIDwgbWluICYmIChtaW4gPSB2YWx1ZSk7XG4gICAgdmFsdWUgPiBtYXggJiYgKG1heCA9IHZhbHVlKTtcbiAgfVxuXG4gIGRpbUV4dGVudCA9IFttaW4sIG1heF07XG4gIHRoaXMuX2V4dGVudFtkaW1dID0gZGltRXh0ZW50O1xuICByZXR1cm4gZGltRXh0ZW50O1xufTtcbi8qKlxuICogT3B0aW1pemUgZm9yIHRoZSBzY2VuYXJpbyB0aGF0IGRhdGEgaXMgZmlsdGVyZWQgYnkgYSBnaXZlbiBleHRlbnQuXG4gKiBDb25zaWRlciB0aGF0IGlmIGRhdGEgYW1vdW50IGlzIG1vcmUgdGhhbiBodW5kcmVkcyBvZiB0aG91c2FuZCxcbiAqIGV4dGVudCBjYWxjdWxhdGlvbiB3aWxsIGNvc3QgbW9yZSB0aGFuIDEwbXMgYW5kIHRoZSBjYWNoZSB3aWxsXG4gKiBiZSBlcmFzZWQgYmVjYXVzZSBvZiB0aGUgZmlsdGVyaW5nLlxuICovXG5cblxubGlzdFByb3RvLmdldEFwcHJveGltYXRlRXh0ZW50ID0gZnVuY3Rpb24gKGRpbVxuLyosIHN0YWNrICovXG4pIHtcbiAgZGltID0gdGhpcy5nZXREaW1lbnNpb24oZGltKTtcbiAgcmV0dXJuIHRoaXMuX2FwcHJveGltYXRlRXh0ZW50W2RpbV0gfHwgdGhpcy5nZXREYXRhRXh0ZW50KGRpbVxuICAvKiwgc3RhY2sgKi9cbiAgKTtcbn07XG5cbmxpc3RQcm90by5zZXRBcHByb3hpbWF0ZUV4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIGRpbVxuLyosIHN0YWNrICovXG4pIHtcbiAgZGltID0gdGhpcy5nZXREaW1lbnNpb24oZGltKTtcbiAgdGhpcy5fYXBwcm94aW1hdGVFeHRlbnRbZGltXSA9IGV4dGVudC5zbGljZSgpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRDYWxjdWxhdGlvbkluZm8gPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jYWxjdWxhdGlvbkluZm9ba2V5XTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5IG9yIGstdiBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxuICovXG5cblxubGlzdFByb3RvLnNldENhbGN1bGF0aW9uSW5mbyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIGlzT2JqZWN0KGtleSkgPyB6clV0aWwuZXh0ZW5kKHRoaXMuX2NhbGN1bGF0aW9uSW5mbywga2V5KSA6IHRoaXMuX2NhbGN1bGF0aW9uSW5mb1trZXldID0gdmFsdWU7XG59O1xuLyoqXG4gKiBHZXQgc3VtIG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICovXG5cblxubGlzdFByb3RvLmdldFN1bSA9IGZ1bmN0aW9uIChkaW1cbi8qLCBzdGFjayAqL1xuKSB7XG4gIHZhciBkaW1EYXRhID0gdGhpcy5fc3RvcmFnZVtkaW1dO1xuICB2YXIgc3VtID0gMDtcblxuICBpZiAoZGltRGF0YSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoZGltLCBpXG4gICAgICAvKiwgc3RhY2sgKi9cbiAgICAgICk7XG5cbiAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VtO1xufTtcbi8qKlxuICogR2V0IG1lZGlhbiBvZiBkYXRhIGluIG9uZSBkaW1lbnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRNZWRpYW4gPSBmdW5jdGlvbiAoZGltXG4vKiwgc3RhY2sgKi9cbikge1xuICB2YXIgZGltRGF0YUFycmF5ID0gW107IC8vIG1hcCBhbGwgZGF0YSBvZiBvbmUgZGltZW5zaW9uXG5cbiAgdGhpcy5lYWNoKGRpbSwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7XG4gICAgaWYgKCFpc05hTih2YWwpKSB7XG4gICAgICBkaW1EYXRhQXJyYXkucHVzaCh2YWwpO1xuICAgIH1cbiAgfSk7IC8vIFRPRE9cbiAgLy8gVXNlIHF1aWNrIHNlbGVjdD9cbiAgLy8gaW1tdXRhYmlsaXR5ICYgc29ydFxuXG4gIHZhciBzb3J0ZWREaW1EYXRhQXJyYXkgPSBbXS5jb25jYXQoZGltRGF0YUFycmF5KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9KTtcbiAgdmFyIGxlbiA9IHRoaXMuY291bnQoKTsgLy8gY2FsY3VsYXRlIG1lZGlhblxuXG4gIHJldHVybiBsZW4gPT09IDAgPyAwIDogbGVuICUgMiA9PT0gMSA/IHNvcnRlZERpbURhdGFBcnJheVsobGVuIC0gMSkgLyAyXSA6IChzb3J0ZWREaW1EYXRhQXJyYXlbbGVuIC8gMl0gKyBzb3J0ZWREaW1EYXRhQXJyYXlbbGVuIC8gMiAtIDFdKSAvIDI7XG59OyAvLyAvKipcbi8vICAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIHZhbHVlXG4vLyAgKiBAcGFyYW0ge3N0cmluZ30gZGltIENvbmNyZXRlIGRpbWVuc2lvbi5cbi8vICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuLy8gICogQHJldHVybiB7bnVtYmVyfVxuLy8gICovXG4vLyBDdXJyZW50bHkgaW5jb3JyZWN0OiBzaG91bGQgcmV0dXJuIGRhdGFJbmRleCBidXQgbm90IHJhd0luZGV4LlxuLy8gRG8gbm90IGZpeCBpdCB1bnRpbCB0aGlzIG1ldGhvZCBpcyB0byBiZSB1c2VkIHNvbWV3aGVyZS5cbi8vIEZJWE1FIFByZWNpc2lvbiBvZiBmbG9hdCB2YWx1ZVxuLy8gbGlzdFByb3RvLmluZGV4T2YgPSBmdW5jdGlvbiAoZGltLCB2YWx1ZSkge1xuLy8gICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbi8vICAgICB2YXIgZGltRGF0YSA9IHN0b3JhZ2VbZGltXTtcbi8vICAgICB2YXIgY2h1bmtTaXplID0gdGhpcy5fY2h1bmtTaXplO1xuLy8gICAgIGlmIChkaW1EYXRhKSB7XG4vLyAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuLy8gICAgICAgICAgICAgdmFyIGNodW5rSW5kZXggPSBNYXRoLmZsb29yKGkgLyBjaHVua1NpemUpO1xuLy8gICAgICAgICAgICAgdmFyIGNodW5rT2Zmc2V0ID0gaSAlIGNodW5rU2l6ZTtcbi8vICAgICAgICAgICAgIGlmIChkaW1EYXRhW2NodW5rSW5kZXhdW2NodW5rT2Zmc2V0XSA9PT0gdmFsdWUpIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICByZXR1cm4gLTE7XG4vLyB9O1xuXG4vKipcbiAqIE9ubHkgc3VwcG9ydCB0aGUgZGltZW5zaW9uIHdoaWNoIGludmVydGVkIGluZGV4IGNyZWF0ZWQuXG4gKiBEbyBub3Qgc3VwcG9ydCBvdGhlciBjYXNlcyB1bnRpbCByZXF1aXJlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25jcmV0ZSBkaW1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn0gcmF3SW5kZXhcbiAqL1xuXG5cbmxpc3RQcm90by5yYXdJbmRleE9mID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUpIHtcbiAgdmFyIGludmVydGVkSW5kaWNlcyA9IGRpbSAmJiB0aGlzLl9pbnZlcnRlZEluZGljZXNNYXBbZGltXTtcbiAgdmFyIHJhd0luZGV4ID0gaW52ZXJ0ZWRJbmRpY2VzW3ZhbHVlXTtcblxuICBpZiAocmF3SW5kZXggPT0gbnVsbCB8fCBpc05hTihyYXdJbmRleCkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gcmF3SW5kZXg7XG59O1xuLyoqXG4gKiBSZXRyZWl2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge251bWJlcn0gbmFtZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmluZGV4T2ZOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHRoaXMuZ2V0TmFtZShpKSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogUmV0cmVpdmUgdGhlIGluZGV4IHdpdGggZ2l2ZW4gcmF3IGRhdGEgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBuYW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uaW5kZXhPZlJhd0luZGV4ID0gZnVuY3Rpb24gKHJhd0luZGV4KSB7XG4gIGlmICghdGhpcy5faW5kaWNlcykge1xuICAgIHJldHVybiByYXdJbmRleDtcbiAgfVxuXG4gIGlmIChyYXdJbmRleCA+PSB0aGlzLl9yYXdDb3VudCB8fCByYXdJbmRleCA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gLy8gSW5kaWNlcyBhcmUgYXNjZW5kaW5nXG5cblxuICB2YXIgaW5kaWNlcyA9IHRoaXMuX2luZGljZXM7IC8vIElmIHJhd0luZGV4ID09PSBkYXRhSW5kZXhcblxuICB2YXIgcmF3RGF0YUluZGV4ID0gaW5kaWNlc1tyYXdJbmRleF07XG5cbiAgaWYgKHJhd0RhdGFJbmRleCAhPSBudWxsICYmIHJhd0RhdGFJbmRleCA8IHRoaXMuX2NvdW50ICYmIHJhd0RhdGFJbmRleCA9PT0gcmF3SW5kZXgpIHtcbiAgICByZXR1cm4gcmF3SW5kZXg7XG4gIH1cblxuICB2YXIgbGVmdCA9IDA7XG4gIHZhciByaWdodCA9IHRoaXMuX2NvdW50IC0gMTtcblxuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIHZhciBtaWQgPSAobGVmdCArIHJpZ2h0KSAvIDIgfCAwO1xuXG4gICAgaWYgKGluZGljZXNbbWlkXSA8IHJhd0luZGV4KSB7XG4gICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICB9IGVsc2UgaWYgKGluZGljZXNbbWlkXSA+IHJhd0luZGV4KSB7XG4gICAgICByaWdodCA9IG1pZCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogUmV0cmVpdmUgdGhlIGluZGV4IG9mIG5lYXJlc3QgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhEaXN0YW5jZT1JbmZpbml0eV1cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBDb25zaWRlcmUgbXVsdGlwbGUgcG9pbnRzIGhhcyB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xuXG5cbmxpc3RQcm90by5pbmRpY2VzT2ZOZWFyZXN0ID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUsIG1heERpc3RhbmNlKSB7XG4gIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgdmFyIGRpbURhdGEgPSBzdG9yYWdlW2RpbV07XG4gIHZhciBuZWFyZXN0SW5kaWNlcyA9IFtdO1xuXG4gIGlmICghZGltRGF0YSkge1xuICAgIHJldHVybiBuZWFyZXN0SW5kaWNlcztcbiAgfVxuXG4gIGlmIChtYXhEaXN0YW5jZSA9PSBudWxsKSB7XG4gICAgbWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgfVxuXG4gIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgdmFyIG1pbkRpZmYgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZGlmZiA9IHZhbHVlIC0gdGhpcy5nZXQoZGltLCBpXG4gICAgLyosIHN0YWNrICovXG4gICAgKTtcbiAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRpZmYpO1xuXG4gICAgaWYgKGRpZmYgPD0gbWF4RGlzdGFuY2UgJiYgZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICAvLyBGb3IgdGhlIGNhc2Ugb2YgdHdvIGRhdGEgYXJlIHNhbWUgb24geEF4aXMsIHdoaWNoIGhhcyBzZXF1ZW5jZSBkYXRhLlxuICAgICAgLy8gU2hvdyB0aGUgbmVhcmVzdCBpbmRleFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS9lY2hhcnRzL2lzc3Vlcy8yODY5XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QgfHwgZGlmZiA+PSAwICYmIG1pbkRpZmYgPCAwKSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBtaW5EaWZmID0gZGlmZjtcbiAgICAgICAgbmVhcmVzdEluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgICAgbmVhcmVzdEluZGljZXMucHVzaChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcmVzdEluZGljZXM7XG59O1xuLyoqXG4gKiBHZXQgcmF3IGRhdGEgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRSYXdJbmRleCA9IGdldFJhd0luZGV4V2l0aG91dEluZGljZXM7XG5cbmZ1bmN0aW9uIGdldFJhd0luZGV4V2l0aG91dEluZGljZXMoaWR4KSB7XG4gIHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIGdldFJhd0luZGV4V2l0aEluZGljZXMoaWR4KSB7XG4gIGlmIChpZHggPCB0aGlzLl9jb3VudCAmJiBpZHggPj0gMCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRpY2VzW2lkeF07XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG4vKipcbiAqIEdldCByYXcgZGF0YSBpdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0UmF3RGF0YUl0ZW0gPSBmdW5jdGlvbiAoaWR4KSB7XG4gIGlmICghdGhpcy5fcmF3RGF0YS5wZXJzaXN0ZW50KSB7XG4gICAgdmFyIHZhbCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaW0gPSB0aGlzLmRpbWVuc2lvbnNbaV07XG4gICAgICB2YWwucHVzaCh0aGlzLmdldChkaW0sIGlkeCkpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhd0RhdGEuZ2V0SXRlbSh0aGlzLmdldFJhd0luZGV4KGlkeCkpO1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtub3REZWZhdWx0SWR4PWZhbHNlXVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxubGlzdFByb3RvLmdldE5hbWUgPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHZhciByYXdJbmRleCA9IHRoaXMuZ2V0UmF3SW5kZXgoaWR4KTtcbiAgcmV0dXJuIHRoaXMuX25hbWVMaXN0W3Jhd0luZGV4XSB8fCBnZXRSYXdWYWx1ZUZyb21TdG9yZSh0aGlzLCB0aGlzLl9uYW1lRGltSWR4LCByYXdJbmRleCkgfHwgJyc7XG59O1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtub3REZWZhdWx0SWR4PWZhbHNlXVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxubGlzdFByb3RvLmdldElkID0gZnVuY3Rpb24gKGlkeCkge1xuICByZXR1cm4gZ2V0SWQodGhpcywgdGhpcy5nZXRSYXdJbmRleChpZHgpKTtcbn07XG5cbmZ1bmN0aW9uIGdldElkKGxpc3QsIHJhd0luZGV4KSB7XG4gIHZhciBpZCA9IGxpc3QuX2lkTGlzdFtyYXdJbmRleF07XG5cbiAgaWYgKGlkID09IG51bGwpIHtcbiAgICBpZCA9IGdldFJhd1ZhbHVlRnJvbVN0b3JlKGxpc3QsIGxpc3QuX2lkRGltSWR4LCByYXdJbmRleCk7XG4gIH1cblxuICBpZiAoaWQgPT0gbnVsbCkge1xuICAgIC8vIEZJWE1FIENoZWNrIHRoZSB1c2FnZSBpbiBncmFwaCwgc2hvdWxkIG5vdCB1c2UgcHJlZml4LlxuICAgIGlkID0gSURfUFJFRklYICsgcmF3SW5kZXg7XG4gIH1cblxuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICBpZiAoIXpyVXRpbC5pc0FycmF5KGRpbWVuc2lvbnMpKSB7XG4gICAgZGltZW5zaW9ucyA9IFtkaW1lbnNpb25zXTtcbiAgfVxuXG4gIHJldHVybiBkaW1lbnNpb25zO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURpbWVuc2lvbnMobGlzdCwgZGltcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBzdHJvYWdlIG1heSBiZSBlbXB0eSB3aGVuIG5vIGRhdGEsIHNvIHVzZVxuICAgIC8vIGRpbWVuc2lvbkluZm9zIHRvIGNoZWNrLlxuICAgIGlmICghbGlzdC5fZGltZW5zaW9uSW5mb3NbZGltc1tpXV0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vua293biBkaW1lbnNpb24gJyArIGRpbXNbaV0pO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBEYXRhIGl0ZXJhdGlvblxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICpcbiAqIEBleGFtcGxlXG4gKiAgbGlzdC5lYWNoKCd4JywgZnVuY3Rpb24gKHgsIGlkeCkge30pO1xuICogIGxpc3QuZWFjaChbJ3gnLCAneSddLCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7fSk7XG4gKiAgbGlzdC5lYWNoKGZ1bmN0aW9uIChpZHgpIHt9KVxuICovXG5cblxubGlzdFByb3RvLmVhY2ggPSBmdW5jdGlvbiAoZGltcywgY2IsIGNvbnRleHQsIGNvbnRleHRDb21wYXQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICghdGhpcy5fY291bnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGRpbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb250ZXh0Q29tcGF0ID0gY29udGV4dDtcbiAgICBjb250ZXh0ID0gY2I7XG4gICAgY2IgPSBkaW1zO1xuICAgIGRpbXMgPSBbXTtcbiAgfSAvLyBjb250ZXh0Q29tcGF0IGp1c3QgZm9yIGNvbXBhdCBlY2hhcnRzM1xuXG5cbiAgY29udGV4dCA9IGNvbnRleHQgfHwgY29udGV4dENvbXBhdCB8fCB0aGlzO1xuICBkaW1zID0genJVdGlsLm1hcChub3JtYWxpemVEaW1lbnNpb25zKGRpbXMpLCB0aGlzLmdldERpbWVuc2lvbiwgdGhpcyk7XG4gIHZhciBkaW1TaXplID0gZGltcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvdW50KCk7IGkrKykge1xuICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICBzd2l0Y2ggKGRpbVNpemUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLmdldChkaW1zWzBdLCBpKSwgaSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5nZXQoZGltc1swXSwgaSksIHRoaXMuZ2V0KGRpbXNbMV0sIGkpLCBpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgdmFyIHZhbHVlID0gW107XG5cbiAgICAgICAgZm9yICg7IGsgPCBkaW1TaXplOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZVtrXSA9IHRoaXMuZ2V0KGRpbXNba10sIGkpO1xuICAgICAgICB9IC8vIEluZGV4XG5cblxuICAgICAgICB2YWx1ZVtrXSA9IGk7XG4gICAgICAgIGNiLmFwcGx5KGNvbnRleHQsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIERhdGEgZmlsdGVyXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gKi9cblxuXG5saXN0UHJvdG8uZmlsdGVyU2VsZiA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgY29udGV4dCwgY29udGV4dENvbXBhdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKCF0aGlzLl9jb3VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGltZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRleHRDb21wYXQgPSBjb250ZXh0O1xuICAgIGNvbnRleHQgPSBjYjtcbiAgICBjYiA9IGRpbWVuc2lvbnM7XG4gICAgZGltZW5zaW9ucyA9IFtdO1xuICB9IC8vIGNvbnRleHRDb21wYXQganVzdCBmb3IgY29tcGF0IGVjaGFydHMzXG5cblxuICBjb250ZXh0ID0gY29udGV4dCB8fCBjb250ZXh0Q29tcGF0IHx8IHRoaXM7XG4gIGRpbWVuc2lvbnMgPSB6clV0aWwubWFwKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzKTtcbiAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xuICB2YXIgQ3RvciA9IGdldEluZGljZXNDdG9yKHRoaXMpO1xuICB2YXIgbmV3SW5kaWNlcyA9IG5ldyBDdG9yKGNvdW50KTtcbiAgdmFyIHZhbHVlID0gW107XG4gIHZhciBkaW1TaXplID0gZGltZW5zaW9ucy5sZW5ndGg7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgZGltMCA9IGRpbWVuc2lvbnNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgdmFyIGtlZXA7XG4gICAgdmFyIHJhd0lkeCA9IHRoaXMuZ2V0UmF3SW5kZXgoaSk7IC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cblxuICAgIGlmIChkaW1TaXplID09PSAwKSB7XG4gICAgICBrZWVwID0gY2IuY2FsbChjb250ZXh0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGRpbVNpemUgPT09IDEpIHtcbiAgICAgIHZhciB2YWwgPSB0aGlzLl9nZXRGYXN0KGRpbTAsIHJhd0lkeCk7XG5cbiAgICAgIGtlZXAgPSBjYi5jYWxsKGNvbnRleHQsIHZhbCwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgIHZhbHVlW2tdID0gdGhpcy5fZ2V0RmFzdChkaW0wLCByYXdJZHgpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZVtrXSA9IGk7XG4gICAgICBrZWVwID0gY2IuYXBwbHkoY29udGV4dCwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChrZWVwKSB7XG4gICAgICBuZXdJbmRpY2VzW29mZnNldCsrXSA9IHJhd0lkeDtcbiAgICB9XG4gIH0gLy8gU2V0IGluZGljZXMgYWZ0ZXIgZmlsdGVyZWQuXG5cblxuICBpZiAob2Zmc2V0IDwgY291bnQpIHtcbiAgICB0aGlzLl9pbmRpY2VzID0gbmV3SW5kaWNlcztcbiAgfVxuXG4gIHRoaXMuX2NvdW50ID0gb2Zmc2V0OyAvLyBSZXNldCBkYXRhIGV4dGVudFxuXG4gIHRoaXMuX2V4dGVudCA9IHt9O1xuICB0aGlzLmdldFJhd0luZGV4ID0gdGhpcy5faW5kaWNlcyA/IGdldFJhd0luZGV4V2l0aEluZGljZXMgOiBnZXRSYXdJbmRleFdpdGhvdXRJbmRpY2VzO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNlbGVjdCBkYXRhIGluIHJhbmdlLiAoRm9yIG9wdGltaXphdGlvbiBvZiBmaWx0ZXIpXG4gKiAoTWFudWFsbHkgaW5saW5lIGNvZGUsIHN1cHBvcnQgNSBtaWxsaW9uIGRhdGEgZmlsdGVyaW5nIGluIGRhdGEgem9vbS4pXG4gKi9cblxuXG5saXN0UHJvdG8uc2VsZWN0UmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICghdGhpcy5fY291bnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGltZW5zaW9ucyA9IFtdO1xuXG4gIGZvciAodmFyIGRpbSBpbiByYW5nZSkge1xuICAgIGlmIChyYW5nZS5oYXNPd25Qcm9wZXJ0eShkaW0pKSB7XG4gICAgICBkaW1lbnNpb25zLnB1c2goZGltKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGltU2l6ZSA9IGRpbWVuc2lvbnMubGVuZ3RoO1xuXG4gIGlmICghZGltU2l6ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbENvdW50ID0gdGhpcy5jb3VudCgpO1xuICB2YXIgQ3RvciA9IGdldEluZGljZXNDdG9yKHRoaXMpO1xuICB2YXIgbmV3SW5kaWNlcyA9IG5ldyBDdG9yKG9yaWdpbmFsQ291bnQpO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIGRpbTAgPSBkaW1lbnNpb25zWzBdO1xuICB2YXIgbWluID0gcmFuZ2VbZGltMF1bMF07XG4gIHZhciBtYXggPSByYW5nZVtkaW0wXVsxXTtcbiAgdmFyIHF1aWNrRmluaXNoZWQgPSBmYWxzZTtcblxuICBpZiAoIXRoaXMuX2luZGljZXMpIHtcbiAgICAvLyBFeHRyZW1lIG9wdGltaXphdGlvbiBmb3IgY29tbW9uIGNhc2UuIEFib3V0IDJ4IGZhc3RlciBpbiBjaHJvbWUuXG4gICAgdmFyIGlkeCA9IDA7XG5cbiAgICBpZiAoZGltU2l6ZSA9PT0gMSkge1xuICAgICAgdmFyIGRpbVN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlW2RpbWVuc2lvbnNbMF1dO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuX2NodW5rQ291bnQ7IGsrKykge1xuICAgICAgICB2YXIgY2h1bmtTdG9yYWdlID0gZGltU3RvcmFnZVtrXTtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHRoaXMuX2NvdW50IC0gayAqIHRoaXMuX2NodW5rU2l6ZSwgdGhpcy5fY2h1bmtTaXplKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGNodW5rU3RvcmFnZVtpXTsgLy8gTmFOIHdpbGwgbm90IGJlIGZpbHRlcmVkLiBDb25zaWRlciB0aGUgY2FzZSwgaW4gbGluZSBjaGFydCwgZW1wdHlcbiAgICAgICAgICAvLyB2YWx1ZSBpbmRpY2F0ZXMgdGhlIGxpbmUgc2hvdWxkIGJlIGJyb2tlbi4gQnV0IGZvciB0aGUgY2FzZSBsaWtlXG4gICAgICAgICAgLy8gc2NhdHRlciBwbG90LCBhIGRhdGEgaXRlbSB3aXRoIGVtcHR5IHZhbHVlIHdpbGwgbm90IGJlIHJlbmRlcmVkLFxuICAgICAgICAgIC8vIGJ1dCB0aGUgYXhpcyBleHRlbnQgbWF5IGJlIGVmZmVjdGVkIGlmIHNvbWUgb3RoZXIgZGltIG9mIHRoZSBkYXRhXG4gICAgICAgICAgLy8gaXRlbSBoYXMgdmFsdWUuIEZvcnR1bmF0ZWx5IGl0IGlzIG5vdCBhIHNpZ25pZmljYW50IG5lZ2F0aXZlIGVmZmVjdC5cblxuICAgICAgICAgIGlmICh2YWwgPj0gbWluICYmIHZhbCA8PSBtYXggfHwgaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgbmV3SW5kaWNlc1tvZmZzZXQrK10gPSBpZHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcXVpY2tGaW5pc2hlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkaW1TaXplID09PSAyKSB7XG4gICAgICB2YXIgZGltU3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2VbZGltMF07XG4gICAgICB2YXIgZGltU3RvcmFnZTIgPSB0aGlzLl9zdG9yYWdlW2RpbWVuc2lvbnNbMV1dO1xuICAgICAgdmFyIG1pbjIgPSByYW5nZVtkaW1lbnNpb25zWzFdXVswXTtcbiAgICAgIHZhciBtYXgyID0gcmFuZ2VbZGltZW5zaW9uc1sxXV1bMV07XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5fY2h1bmtDb3VudDsgaysrKSB7XG4gICAgICAgIHZhciBjaHVua1N0b3JhZ2UgPSBkaW1TdG9yYWdlW2tdO1xuICAgICAgICB2YXIgY2h1bmtTdG9yYWdlMiA9IGRpbVN0b3JhZ2UyW2tdO1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4odGhpcy5fY291bnQgLSBrICogdGhpcy5fY2h1bmtTaXplLCB0aGlzLl9jaHVua1NpemUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsID0gY2h1bmtTdG9yYWdlW2ldO1xuICAgICAgICAgIHZhciB2YWwyID0gY2h1bmtTdG9yYWdlMltpXTsgLy8gRG8gbm90IGZpbHRlciBOYU4sIHNlZSBjb21tZW50IGFib3ZlLlxuXG4gICAgICAgICAgaWYgKCh2YWwgPj0gbWluICYmIHZhbCA8PSBtYXggfHwgaXNOYU4odmFsKSkgJiYgKHZhbDIgPj0gbWluMiAmJiB2YWwyIDw9IG1heDIgfHwgaXNOYU4odmFsMikpKSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzW29mZnNldCsrXSA9IGlkeDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZHgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxdWlja0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXF1aWNrRmluaXNoZWQpIHtcbiAgICBpZiAoZGltU2l6ZSA9PT0gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmlnaW5hbENvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHJhd0luZGV4ID0gdGhpcy5nZXRSYXdJbmRleChpKTtcblxuICAgICAgICB2YXIgdmFsID0gdGhpcy5fZ2V0RmFzdChkaW0wLCByYXdJbmRleCk7IC8vIERvIG5vdCBmaWx0ZXIgTmFOLCBzZWUgY29tbWVudCBhYm92ZS5cblxuXG4gICAgICAgIGlmICh2YWwgPj0gbWluICYmIHZhbCA8PSBtYXggfHwgaXNOYU4odmFsKSkge1xuICAgICAgICAgIG5ld0luZGljZXNbb2Zmc2V0KytdID0gcmF3SW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmlnaW5hbENvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIGtlZXAgPSB0cnVlO1xuICAgICAgICB2YXIgcmF3SW5kZXggPSB0aGlzLmdldFJhd0luZGV4KGkpO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgICAgdmFyIGRpbWsgPSBkaW1lbnNpb25zW2tdO1xuXG4gICAgICAgICAgdmFyIHZhbCA9IHRoaXMuX2dldEZhc3QoZGltLCByYXdJbmRleCk7IC8vIERvIG5vdCBmaWx0ZXIgTmFOLCBzZWUgY29tbWVudCBhYm92ZS5cblxuXG4gICAgICAgICAgaWYgKHZhbCA8IHJhbmdlW2RpbWtdWzBdIHx8IHZhbCA+IHJhbmdlW2RpbWtdWzFdKSB7XG4gICAgICAgICAgICBrZWVwID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtlZXApIHtcbiAgICAgICAgICBuZXdJbmRpY2VzW29mZnNldCsrXSA9IHRoaXMuZ2V0UmF3SW5kZXgoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU2V0IGluZGljZXMgYWZ0ZXIgZmlsdGVyZWQuXG5cblxuICBpZiAob2Zmc2V0IDwgb3JpZ2luYWxDb3VudCkge1xuICAgIHRoaXMuX2luZGljZXMgPSBuZXdJbmRpY2VzO1xuICB9XG5cbiAgdGhpcy5fY291bnQgPSBvZmZzZXQ7IC8vIFJlc2V0IGRhdGEgZXh0ZW50XG5cbiAgdGhpcy5fZXh0ZW50ID0ge307XG4gIHRoaXMuZ2V0UmF3SW5kZXggPSB0aGlzLl9pbmRpY2VzID8gZ2V0UmF3SW5kZXhXaXRoSW5kaWNlcyA6IGdldFJhd0luZGV4V2l0aG91dEluZGljZXM7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogRGF0YSBtYXBwaW5nIHRvIGEgcGxhaW4gYXJyYXlcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbZGltZW5zaW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmxpc3RQcm90by5tYXBBcnJheSA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgY29udGV4dCwgY29udGV4dENvbXBhdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBkaW1lbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGV4dENvbXBhdCA9IGNvbnRleHQ7XG4gICAgY29udGV4dCA9IGNiO1xuICAgIGNiID0gZGltZW5zaW9ucztcbiAgICBkaW1lbnNpb25zID0gW107XG4gIH0gLy8gY29udGV4dENvbXBhdCBqdXN0IGZvciBjb21wYXQgZWNoYXJ0czNcblxuXG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IGNvbnRleHRDb21wYXQgfHwgdGhpcztcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB0aGlzLmVhY2goZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgIHJlc3VsdC5wdXNoKGNiICYmIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9LCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07IC8vIERhdGEgaW4gZXhjbHVkZURpbWVuc2lvbnMgaXMgY29waWVkLCBvdGhlcndpc2UgdHJhbnNmZXJlZC5cblxuXG5mdW5jdGlvbiBjbG9uZUxpc3RGb3JNYXBBbmRTYW1wbGUob3JpZ2luYWwsIGV4Y2x1ZGVEaW1lbnNpb25zKSB7XG4gIHZhciBhbGxEaW1lbnNpb25zID0gb3JpZ2luYWwuZGltZW5zaW9ucztcbiAgdmFyIGxpc3QgPSBuZXcgTGlzdCh6clV0aWwubWFwKGFsbERpbWVuc2lvbnMsIG9yaWdpbmFsLmdldERpbWVuc2lvbkluZm8sIG9yaWdpbmFsKSwgb3JpZ2luYWwuaG9zdE1vZGVsKTsgLy8gRklYTUUgSWYgbmVlZHMgc3RhY2tlZE9uLCB2YWx1ZSBtYXkgYWxyZWFkeSBiZWVuIHN0YWNrZWRcblxuICB0cmFuc2ZlclByb3BlcnRpZXMobGlzdCwgb3JpZ2luYWwpO1xuICB2YXIgc3RvcmFnZSA9IGxpc3QuX3N0b3JhZ2UgPSB7fTtcbiAgdmFyIG9yaWdpbmFsU3RvcmFnZSA9IG9yaWdpbmFsLl9zdG9yYWdlOyAvLyBJbml0IHN0b3JhZ2VcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbERpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltID0gYWxsRGltZW5zaW9uc1tpXTtcblxuICAgIGlmIChvcmlnaW5hbFN0b3JhZ2VbZGltXSkge1xuICAgICAgLy8gTm90aWNlIHRoYXQgd2UgZG8gbm90IHJlc2V0IGludmVydGVkSW5kaWNlc01hcCBoZXJlLCBiZWN1YXNlXG4gICAgICAvLyB0aGVyZSBpcyBubyBzY2VuYXJpbyBvZiBtYXBwaW5nIG9yIHNhbXBsaW5nIG9yZGluYWwgZGltZW5zaW9uLlxuICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKGV4Y2x1ZGVEaW1lbnNpb25zLCBkaW0pID49IDApIHtcbiAgICAgICAgc3RvcmFnZVtkaW1dID0gY2xvbmVEaW1TdG9yZShvcmlnaW5hbFN0b3JhZ2VbZGltXSk7XG4gICAgICAgIGxpc3QuX3Jhd0V4dGVudFtkaW1dID0gZ2V0SW5pdGlhbEV4dGVudCgpO1xuICAgICAgICBsaXN0Ll9leHRlbnRbZGltXSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEaXJlY3QgcmVmZXJlbmNlIGZvciBvdGhlciBkaW1lbnNpb25zXG4gICAgICAgIHN0b3JhZ2VbZGltXSA9IG9yaWdpbmFsU3RvcmFnZVtkaW1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufVxuXG5mdW5jdGlvbiBjbG9uZURpbVN0b3JlKG9yaWdpbmFsRGltU3RvcmUpIHtcbiAgdmFyIG5ld0RpbVN0b3JlID0gbmV3IEFycmF5KG9yaWdpbmFsRGltU3RvcmUubGVuZ3RoKTtcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IG9yaWdpbmFsRGltU3RvcmUubGVuZ3RoOyBqKyspIHtcbiAgICBuZXdEaW1TdG9yZVtqXSA9IGNsb25lQ2h1bmsob3JpZ2luYWxEaW1TdG9yZVtqXSk7XG4gIH1cblxuICByZXR1cm4gbmV3RGltU3RvcmU7XG59XG5cbmZ1bmN0aW9uIGdldEluaXRpYWxFeHRlbnQoKSB7XG4gIHJldHVybiBbSW5maW5pdHksIC1JbmZpbml0eV07XG59XG4vKipcbiAqIERhdGEgbWFwcGluZyB0byBhIG5ldyBMaXN0IHdpdGggZ2l2ZW4gZGltZW5zaW9uc1xuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmxpc3RQcm90by5tYXAgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIGNvbnRleHQsIGNvbnRleHRDb21wYXQpIHtcbiAgJ3VzZSBzdHJpY3QnOyAvLyBjb250ZXh0Q29tcGF0IGp1c3QgZm9yIGNvbXBhdCBlY2hhcnRzM1xuXG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IGNvbnRleHRDb21wYXQgfHwgdGhpcztcbiAgZGltZW5zaW9ucyA9IHpyVXRpbC5tYXAobm9ybWFsaXplRGltZW5zaW9ucyhkaW1lbnNpb25zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXMpO1xuICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzLCBkaW1lbnNpb25zKTsgLy8gRm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGFsbCBpbW11dGFibGUuXG4gIC8vIFNvIHdlIGNhbiByZWZlcmVuY2UgdG8gdGhlIHNhbWUgdmFsdWVcblxuICBsaXN0Ll9pbmRpY2VzID0gdGhpcy5faW5kaWNlcztcbiAgbGlzdC5nZXRSYXdJbmRleCA9IGxpc3QuX2luZGljZXMgPyBnZXRSYXdJbmRleFdpdGhJbmRpY2VzIDogZ2V0UmF3SW5kZXhXaXRob3V0SW5kaWNlcztcbiAgdmFyIHN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlO1xuICB2YXIgdG1wUmV0VmFsdWUgPSBbXTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMuX2NodW5rU2l6ZTtcbiAgdmFyIGRpbVNpemUgPSBkaW1lbnNpb25zLmxlbmd0aDtcbiAgdmFyIGRhdGFDb3VudCA9IHRoaXMuY291bnQoKTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgcmF3RXh0ZW50ID0gbGlzdC5fcmF3RXh0ZW50O1xuXG4gIGZvciAodmFyIGRhdGFJbmRleCA9IDA7IGRhdGFJbmRleCA8IGRhdGFDb3VudDsgZGF0YUluZGV4KyspIHtcbiAgICBmb3IgKHZhciBkaW1JbmRleCA9IDA7IGRpbUluZGV4IDwgZGltU2l6ZTsgZGltSW5kZXgrKykge1xuICAgICAgdmFsdWVzW2RpbUluZGV4XSA9IHRoaXMuZ2V0KGRpbWVuc2lvbnNbZGltSW5kZXhdLCBkYXRhSW5kZXhcbiAgICAgIC8qLCBzdGFjayAqL1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YWx1ZXNbZGltU2l6ZV0gPSBkYXRhSW5kZXg7XG4gICAgdmFyIHJldFZhbHVlID0gY2IgJiYgY2IuYXBwbHkoY29udGV4dCwgdmFsdWVzKTtcblxuICAgIGlmIChyZXRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBhIG51bWJlciBvciBzdHJpbmcgKGluIG9yaWRpbmFsIGRpbWVuc2lvbik/XG4gICAgICBpZiAodHlwZW9mIHJldFZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0bXBSZXRWYWx1ZVswXSA9IHJldFZhbHVlO1xuICAgICAgICByZXRWYWx1ZSA9IHRtcFJldFZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmF3SW5kZXggPSB0aGlzLmdldFJhd0luZGV4KGRhdGFJbmRleCk7XG4gICAgICB2YXIgY2h1bmtJbmRleCA9IE1hdGguZmxvb3IocmF3SW5kZXggLyBjaHVua1NpemUpO1xuICAgICAgdmFyIGNodW5rT2Zmc2V0ID0gcmF3SW5kZXggJSBjaHVua1NpemU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNbaV07XG4gICAgICAgIHZhciB2YWwgPSByZXRWYWx1ZVtpXTtcbiAgICAgICAgdmFyIHJhd0V4dGVudE9uRGltID0gcmF3RXh0ZW50W2RpbV07XG4gICAgICAgIHZhciBkaW1TdG9yZSA9IHN0b3JhZ2VbZGltXTtcblxuICAgICAgICBpZiAoZGltU3RvcmUpIHtcbiAgICAgICAgICBkaW1TdG9yZVtjaHVua0luZGV4XVtjaHVua09mZnNldF0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsIDwgcmF3RXh0ZW50T25EaW1bMF0pIHtcbiAgICAgICAgICByYXdFeHRlbnRPbkRpbVswXSA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPiByYXdFeHRlbnRPbkRpbVsxXSkge1xuICAgICAgICAgIHJhd0V4dGVudE9uRGltWzFdID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuLyoqXG4gKiBMYXJnZSBkYXRhIGRvd24gc2FtcGxpbmcgb24gZ2l2ZW4gZGltZW5zaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2FtcGxlVmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNhbXBsZUluZGV4IFNhbXBsZSBpbmRleCBmb3IgbmFtZSBhbmQgaWRcbiAqL1xuXG5cbmxpc3RQcm90by5kb3duU2FtcGxlID0gZnVuY3Rpb24gKGRpbWVuc2lvbiwgcmF0ZSwgc2FtcGxlVmFsdWUsIHNhbXBsZUluZGV4KSB7XG4gIHZhciBsaXN0ID0gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKHRoaXMsIFtkaW1lbnNpb25dKTtcbiAgdmFyIHRhcmdldFN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlO1xuICB2YXIgZnJhbWVWYWx1ZXMgPSBbXTtcbiAgdmFyIGZyYW1lU2l6ZSA9IE1hdGguZmxvb3IoMSAvIHJhdGUpO1xuICB2YXIgZGltU3RvcmUgPSB0YXJnZXRTdG9yYWdlW2RpbWVuc2lvbl07XG4gIHZhciBsZW4gPSB0aGlzLmNvdW50KCk7XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLl9jaHVua1NpemU7XG4gIHZhciByYXdFeHRlbnRPbkRpbSA9IGxpc3QuX3Jhd0V4dGVudFtkaW1lbnNpb25dO1xuICB2YXIgbmV3SW5kaWNlcyA9IG5ldyAoZ2V0SW5kaWNlc0N0b3IodGhpcykpKGxlbik7XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IGZyYW1lU2l6ZSkge1xuICAgIC8vIExhc3QgZnJhbWVcbiAgICBpZiAoZnJhbWVTaXplID4gbGVuIC0gaSkge1xuICAgICAgZnJhbWVTaXplID0gbGVuIC0gaTtcbiAgICAgIGZyYW1lVmFsdWVzLmxlbmd0aCA9IGZyYW1lU2l6ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGZyYW1lU2l6ZTsgaysrKSB7XG4gICAgICB2YXIgZGF0YUlkeCA9IHRoaXMuZ2V0UmF3SW5kZXgoaSArIGspO1xuICAgICAgdmFyIG9yaWdpbmFsQ2h1bmtJbmRleCA9IE1hdGguZmxvb3IoZGF0YUlkeCAvIGNodW5rU2l6ZSk7XG4gICAgICB2YXIgb3JpZ2luYWxDaHVua09mZnNldCA9IGRhdGFJZHggJSBjaHVua1NpemU7XG4gICAgICBmcmFtZVZhbHVlc1trXSA9IGRpbVN0b3JlW29yaWdpbmFsQ2h1bmtJbmRleF1bb3JpZ2luYWxDaHVua09mZnNldF07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gc2FtcGxlVmFsdWUoZnJhbWVWYWx1ZXMpO1xuICAgIHZhciBzYW1wbGVGcmFtZUlkeCA9IHRoaXMuZ2V0UmF3SW5kZXgoTWF0aC5taW4oaSArIHNhbXBsZUluZGV4KGZyYW1lVmFsdWVzLCB2YWx1ZSkgfHwgMCwgbGVuIC0gMSkpO1xuICAgIHZhciBzYW1wbGVDaHVua0luZGV4ID0gTWF0aC5mbG9vcihzYW1wbGVGcmFtZUlkeCAvIGNodW5rU2l6ZSk7XG4gICAgdmFyIHNhbXBsZUNodW5rT2Zmc2V0ID0gc2FtcGxlRnJhbWVJZHggJSBjaHVua1NpemU7IC8vIE9ubHkgd3JpdGUgdmFsdWUgb24gdGhlIGZpbHRlcmVkIGRhdGFcblxuICAgIGRpbVN0b3JlW3NhbXBsZUNodW5rSW5kZXhdW3NhbXBsZUNodW5rT2Zmc2V0XSA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlIDwgcmF3RXh0ZW50T25EaW1bMF0pIHtcbiAgICAgIHJhd0V4dGVudE9uRGltWzBdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID4gcmF3RXh0ZW50T25EaW1bMV0pIHtcbiAgICAgIHJhd0V4dGVudE9uRGltWzFdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgbmV3SW5kaWNlc1tvZmZzZXQrK10gPSBzYW1wbGVGcmFtZUlkeDtcbiAgfVxuXG4gIGxpc3QuX2NvdW50ID0gb2Zmc2V0O1xuICBsaXN0Ll9pbmRpY2VzID0gbmV3SW5kaWNlcztcbiAgbGlzdC5nZXRSYXdJbmRleCA9IGdldFJhd0luZGV4V2l0aEluZGljZXM7XG4gIHJldHVybiBsaXN0O1xufTtcbi8qKlxuICogR2V0IG1vZGVsIG9mIG9uZSBkYXRhIGl0ZW0uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICovXG4vLyBGSVhNRSBNb2RlbCBwcm94eSA/XG5cblxubGlzdFByb3RvLmdldEl0ZW1Nb2RlbCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgdmFyIGhvc3RNb2RlbCA9IHRoaXMuaG9zdE1vZGVsO1xuICByZXR1cm4gbmV3IE1vZGVsKHRoaXMuZ2V0UmF3RGF0YUl0ZW0oaWR4KSwgaG9zdE1vZGVsLCBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLmVjTW9kZWwpO1xufTtcbi8qKlxuICogQ3JlYXRlIGEgZGF0YSBkaWZmZXJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBvdGhlckxpc3RcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvRGF0YURpZmZlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5kaWZmID0gZnVuY3Rpb24gKG90aGVyTGlzdCkge1xuICB2YXIgdGhpc0xpc3QgPSB0aGlzO1xuICByZXR1cm4gbmV3IERhdGFEaWZmZXIob3RoZXJMaXN0ID8gb3RoZXJMaXN0LmdldEluZGljZXMoKSA6IFtdLCB0aGlzLmdldEluZGljZXMoKSwgZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiBnZXRJZChvdGhlckxpc3QsIGlkeCk7XG4gIH0sIGZ1bmN0aW9uIChpZHgpIHtcbiAgICByZXR1cm4gZ2V0SWQodGhpc0xpc3QsIGlkeCk7XG4gIH0pO1xufTtcbi8qKlxuICogR2V0IHZpc3VhbCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5cbmxpc3RQcm90by5nZXRWaXN1YWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB2aXN1YWwgPSB0aGlzLl92aXN1YWw7XG4gIHJldHVybiB2aXN1YWwgJiYgdmlzdWFsW2tleV07XG59O1xuLyoqXG4gKiBTZXQgdmlzdWFsIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gKlxuICogQGV4YW1wbGVcbiAqICBzZXRWaXN1YWwoJ2NvbG9yJywgY29sb3IpO1xuICogIHNldFZpc3VhbCh7XG4gKiAgICAgICdjb2xvcic6IGNvbG9yXG4gKiAgfSk7XG4gKi9cblxuXG5saXN0UHJvdG8uc2V0VmlzdWFsID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdGhpcy5zZXRWaXN1YWwobmFtZSwga2V5W25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl92aXN1YWwgPSB0aGlzLl92aXN1YWwgfHwge307XG4gIHRoaXMuX3Zpc3VhbFtrZXldID0gdmFsO1xufTtcbi8qKlxuICogU2V0IGxheW91dCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gKiBAcGFyYW0geyp9IFt2YWxdXG4gKi9cblxuXG5saXN0UHJvdG8uc2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdGhpcy5zZXRMYXlvdXQobmFtZSwga2V5W25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9sYXlvdXRba2V5XSA9IHZhbDtcbn07XG4vKipcbiAqIEdldCBsYXlvdXQgcHJvcGVydHkuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleS5cbiAqIEByZXR1cm4geyp9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gdGhpcy5fbGF5b3V0W2tleV07XG59O1xuLyoqXG4gKiBHZXQgbGF5b3V0IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqL1xuXG5cbmxpc3RQcm90by5nZXRJdGVtTGF5b3V0ID0gZnVuY3Rpb24gKGlkeCkge1xuICByZXR1cm4gdGhpcy5faXRlbUxheW91dHNbaWR4XTtcbn07XG4vKipcbiAqIFNldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtPYmplY3R9IGxheW91dFxuICogQHBhcmFtIHtib29sZWFuPX0gW21lcmdlPWZhbHNlXVxuICovXG5cblxubGlzdFByb3RvLnNldEl0ZW1MYXlvdXQgPSBmdW5jdGlvbiAoaWR4LCBsYXlvdXQsIG1lcmdlKSB7XG4gIHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF0gPSBtZXJnZSA/IHpyVXRpbC5leHRlbmQodGhpcy5faXRlbUxheW91dHNbaWR4XSB8fCB7fSwgbGF5b3V0KSA6IGxheW91dDtcbn07XG4vKipcbiAqIENsZWFyIGFsbCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICovXG5cblxubGlzdFByb3RvLmNsZWFySXRlbUxheW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2l0ZW1MYXlvdXRzLmxlbmd0aCA9IDA7XG59O1xuLyoqXG4gKiBHZXQgdmlzdWFsIHByb3BlcnR5IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVBhcmVudD1mYWxzZV1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRJdGVtVmlzdWFsID0gZnVuY3Rpb24gKGlkeCwga2V5LCBpZ25vcmVQYXJlbnQpIHtcbiAgdmFyIGl0ZW1WaXN1YWwgPSB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdO1xuICB2YXIgdmFsID0gaXRlbVZpc3VhbCAmJiBpdGVtVmlzdWFsW2tleV07XG5cbiAgaWYgKHZhbCA9PSBudWxsICYmICFpZ25vcmVQYXJlbnQpIHtcbiAgICAvLyBVc2UgZ2xvYmFsIHZpc3VhbCBwcm9wZXJ0eVxuICAgIHJldHVybiB0aGlzLmdldFZpc3VhbChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG4vKipcbiAqIFNldCB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gKiBAcGFyYW0geyp9IFt2YWx1ZV1cbiAqXG4gKiBAZXhhbXBsZVxuICogIHNldEl0ZW1WaXN1YWwoMCwgJ2NvbG9yJywgY29sb3IpO1xuICogIHNldEl0ZW1WaXN1YWwoMCwge1xuICogICAgICAnY29sb3InOiBjb2xvclxuICogIH0pO1xuICovXG5cblxubGlzdFByb3RvLnNldEl0ZW1WaXN1YWwgPSBmdW5jdGlvbiAoaWR4LCBrZXksIHZhbHVlKSB7XG4gIHZhciBpdGVtVmlzdWFsID0gdGhpcy5faXRlbVZpc3VhbHNbaWR4XSB8fCB7fTtcbiAgdmFyIGhhc0l0ZW1WaXN1YWwgPSB0aGlzLmhhc0l0ZW1WaXN1YWw7XG4gIHRoaXMuX2l0ZW1WaXN1YWxzW2lkeF0gPSBpdGVtVmlzdWFsO1xuXG4gIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgaXRlbVZpc3VhbFtuYW1lXSA9IGtleVtuYW1lXTtcbiAgICAgICAgaGFzSXRlbVZpc3VhbFtuYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaXRlbVZpc3VhbFtrZXldID0gdmFsdWU7XG4gIGhhc0l0ZW1WaXN1YWxba2V5XSA9IHRydWU7XG59O1xuLyoqXG4gKiBDbGVhciBpdGVtVmlzdWFscyBhbmQgbGlzdCB2aXN1YWwuXG4gKi9cblxuXG5saXN0UHJvdG8uY2xlYXJBbGxWaXN1YWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3Zpc3VhbCA9IHt9O1xuICB0aGlzLl9pdGVtVmlzdWFscyA9IFtdO1xuICB0aGlzLmhhc0l0ZW1WaXN1YWwgPSB7fTtcbn07XG5cbnZhciBzZXRJdGVtRGF0YUFuZFNlcmllc0luZGV4ID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gIGNoaWxkLnNlcmllc0luZGV4ID0gdGhpcy5zZXJpZXNJbmRleDtcbiAgY2hpbGQuZGF0YUluZGV4ID0gdGhpcy5kYXRhSW5kZXg7XG4gIGNoaWxkLmRhdGFUeXBlID0gdGhpcy5kYXRhVHlwZTtcbn07XG4vKipcbiAqIFNldCBncmFwaGljIGVsZW1lbnQgcmVsYXRpdmUgdG8gZGF0YS4gSXQgY2FuIGJlIHNldCBhcyBudWxsXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IFtlbF1cbiAqL1xuXG5cbmxpc3RQcm90by5zZXRJdGVtR3JhcGhpY0VsID0gZnVuY3Rpb24gKGlkeCwgZWwpIHtcbiAgdmFyIGhvc3RNb2RlbCA9IHRoaXMuaG9zdE1vZGVsO1xuXG4gIGlmIChlbCkge1xuICAgIC8vIEFkZCBkYXRhIGluZGV4IGFuZCBzZXJpZXMgaW5kZXggZm9yIGluZGV4aW5nIHRoZSBkYXRhIGJ5IGVsZW1lbnRcbiAgICAvLyBVc2VmdWwgaW4gdG9vbHRpcFxuICAgIGVsLmRhdGFJbmRleCA9IGlkeDtcbiAgICBlbC5kYXRhVHlwZSA9IHRoaXMuZGF0YVR5cGU7XG4gICAgZWwuc2VyaWVzSW5kZXggPSBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLnNlcmllc0luZGV4O1xuXG4gICAgaWYgKGVsLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgIGVsLnRyYXZlcnNlKHNldEl0ZW1EYXRhQW5kU2VyaWVzSW5kZXgsIGVsKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9ncmFwaGljRWxzW2lkeF0gPSBlbDtcbn07XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0SXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgcmV0dXJuIHRoaXMuX2dyYXBoaWNFbHNbaWR4XTtcbn07XG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqL1xuXG5cbmxpc3RQcm90by5lYWNoSXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICB6clV0aWwuZWFjaCh0aGlzLl9ncmFwaGljRWxzLCBmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgIGlmIChlbCkge1xuICAgICAgY2IgJiYgY2IuY2FsbChjb250ZXh0LCBlbCwgaWR4KTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogU2hhbGxvdyBjbG9uZSBhIG5ldyBsaXN0IGV4Y2VwdCB2aXN1YWwgYW5kIGxheW91dCBwcm9wZXJ0aWVzLCBhbmQgZ3JhcGggZWxlbWVudHMuXG4gKiBOZXcgbGlzdCBvbmx5IGNoYW5nZSB0aGUgaW5kaWNlcy5cbiAqL1xuXG5cbmxpc3RQcm90by5jbG9uZVNoYWxsb3cgPSBmdW5jdGlvbiAobGlzdCkge1xuICBpZiAoIWxpc3QpIHtcbiAgICB2YXIgZGltZW5zaW9uSW5mb0xpc3QgPSB6clV0aWwubWFwKHRoaXMuZGltZW5zaW9ucywgdGhpcy5nZXREaW1lbnNpb25JbmZvLCB0aGlzKTtcbiAgICBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9uSW5mb0xpc3QsIHRoaXMuaG9zdE1vZGVsKTtcbiAgfSAvLyBGSVhNRVxuXG5cbiAgbGlzdC5fc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gIHRyYW5zZmVyUHJvcGVydGllcyhsaXN0LCB0aGlzKTsgLy8gQ2xvbmUgd2lsbCBub3QgY2hhbmdlIHRoZSBkYXRhIGV4dGVudCBhbmQgaW5kaWNlc1xuXG4gIGlmICh0aGlzLl9pbmRpY2VzKSB7XG4gICAgdmFyIEN0b3IgPSB0aGlzLl9pbmRpY2VzLmNvbnN0cnVjdG9yO1xuICAgIGxpc3QuX2luZGljZXMgPSBuZXcgQ3Rvcih0aGlzLl9pbmRpY2VzKTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0Ll9pbmRpY2VzID0gbnVsbDtcbiAgfVxuXG4gIGxpc3QuZ2V0UmF3SW5kZXggPSBsaXN0Ll9pbmRpY2VzID8gZ2V0UmF3SW5kZXhXaXRoSW5kaWNlcyA6IGdldFJhd0luZGV4V2l0aG91dEluZGljZXM7XG4gIHJldHVybiBsaXN0O1xufTtcbi8qKlxuICogV3JhcCBzb21lIG1ldGhvZCB0byBhZGQgbW9yZSBmZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaW5qZWN0RnVuY3Rpb25cbiAqL1xuXG5cbmxpc3RQcm90by53cmFwTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluamVjdEZ1bmN0aW9uKSB7XG4gIHZhciBvcmlnaW5hbE1ldGhvZCA9IHRoaXNbbWV0aG9kTmFtZV07XG5cbiAgaWYgKHR5cGVvZiBvcmlnaW5hbE1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX193cmFwcGVkTWV0aG9kcyA9IHRoaXMuX193cmFwcGVkTWV0aG9kcyB8fCBbXTtcblxuICB0aGlzLl9fd3JhcHBlZE1ldGhvZHMucHVzaChtZXRob2ROYW1lKTtcblxuICB0aGlzW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBpbmplY3RGdW5jdGlvbi5hcHBseSh0aGlzLCBbcmVzXS5jb25jYXQoenJVdGlsLnNsaWNlKGFyZ3VtZW50cykpKTtcbiAgfTtcbn07IC8vIE1ldGhvZHMgdGhhdCBjcmVhdGUgYSBuZXcgbGlzdCBiYXNlZCBvbiB0aGlzIGxpc3Qgc2hvdWxkIGJlIGxpc3RlZCBoZXJlLlxuLy8gTm90aWNlIHRoYXQgdGhvc2UgbWV0aG9kIHNob3VsZCBgUkVUVVJOYCB0aGUgbmV3IGxpc3QuXG5cblxubGlzdFByb3RvLlRSQU5TRkVSQUJMRV9NRVRIT0RTID0gWydjbG9uZVNoYWxsb3cnLCAnZG93blNhbXBsZScsICdtYXAnXTsgLy8gTWV0aG9kcyB0aGF0IGNoYW5nZSBpbmRpY2VzIG9mIHRoaXMgbGlzdCBzaG91bGQgYmUgbGlzdGVkIGhlcmUuXG5cbmxpc3RQcm90by5DSEFOR0FCTEVfTUVUSE9EUyA9IFsnZmlsdGVyU2VsZicsICdzZWxlY3RSYW5nZSddO1xudmFyIF9kZWZhdWx0ID0gTGlzdDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9MaXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL0xpc3QuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX3V0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgY3JlYXRlSGFzaE1hcCA9IF91dGlsLmNyZWF0ZUhhc2hNYXA7XG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcbnZhciBtYXAgPSBfdXRpbC5tYXA7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQuY2F0ZWdvcmllcz1bXV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0Lm5lZWRDb2xsZWN0PWZhbHNlXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQuZGVkdXBsaWNhdGlvbj1mYWxzZV1cbiAqL1xuZnVuY3Rpb24gT3JkaW5hbE1ldGEob3B0KSB7XG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgdGhpcy5jYXRlZ29yaWVzID0gb3B0LmNhdGVnb3JpZXMgfHwgW107XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cbiAgdGhpcy5fbmVlZENvbGxlY3QgPSBvcHQubmVlZENvbGxlY3Q7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cbiAgdGhpcy5fZGVkdXBsaWNhdGlvbiA9IG9wdC5kZWR1cGxpY2F0aW9uO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMuX21hcDtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc01vZGVsXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL09yZGluYWxNZXRhfVxuICovXG5cblxuT3JkaW5hbE1ldGEuY3JlYXRlQnlBeGlzTW9kZWwgPSBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gIHZhciBvcHRpb24gPSBheGlzTW9kZWwub3B0aW9uO1xuICB2YXIgZGF0YSA9IG9wdGlvbi5kYXRhO1xuICB2YXIgY2F0ZWdvcmllcyA9IGRhdGEgJiYgbWFwKGRhdGEsIGdldE5hbWUpO1xuICByZXR1cm4gbmV3IE9yZGluYWxNZXRhKHtcbiAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzLFxuICAgIG5lZWRDb2xsZWN0OiAhY2F0ZWdvcmllcyxcbiAgICAvLyBkZWR1cGxpY2F0aW9uIGlzIGRlZmF1bHQgaW4gYXhpcy5cbiAgICBkZWR1cGxpY2F0aW9uOiBvcHRpb24uZGVkcGxpY2F0aW9uICE9PSBmYWxzZVxuICB9KTtcbn07XG5cbnZhciBwcm90byA9IE9yZGluYWxNZXRhLnByb3RvdHlwZTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5XG4gKiBAcmV0dXJuIHtudW1iZXJ9IG9yZGluYWxcbiAqL1xuXG5wcm90by5nZXRPcmRpbmFsID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gIHJldHVybiBnZXRPckNyZWF0ZU1hcCh0aGlzKS5nZXQoY2F0ZWdvcnkpO1xufTtcbi8qKlxuICogQHBhcmFtIHsqfSBjYXRlZ29yeVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgb3JkaW5hbC4gSWYgbm90IGZvdW5kLCByZXR1cm4gTmFOLlxuICovXG5cblxucHJvdG8ucGFyc2VBbmRDb2xsZWN0ID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gIHZhciBpbmRleDtcbiAgdmFyIG5lZWRDb2xsZWN0ID0gdGhpcy5fbmVlZENvbGxlY3Q7IC8vIFRoZSB2YWx1ZSBvZiBjYXRlZ29yeSBkaW0gY2FuIGJlIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gY2F0ZWdvcnkgc2V0LlxuICAvLyBUaGlzIGZlYXR1cmUgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiAhbmVlZENvbGxlY3QsIGJlY2F1c2Ugd2Ugc2hvdWxkXG4gIC8vIGNvbnNpZGVyIGEgY29tbW9uIGNhc2U6IGEgdmFsdWUgaXMgMjAxNywgd2hpY2ggaXMgYSBudW1iZXIgYnV0IGlzXG4gIC8vIGV4cGVjdGVkIHRvIGJlIHRyZWFkIGFzIGEgY2F0ZWdvcnkuIFRoaXMgY2FzZSB1c3VhbGx5IGhhcHBlbiBpbiBkYXRhc2V0LFxuICAvLyB3aGVyZSBpdCBoYXBwZW50IHRvIGJlIG5vIG5lZWQgb2YgdGhlIGluZGV4IGZlYXR1cmUuXG5cbiAgaWYgKHR5cGVvZiBjYXRlZ29yeSAhPT0gJ3N0cmluZycgJiYgIW5lZWRDb2xsZWN0KSB7XG4gICAgcmV0dXJuIGNhdGVnb3J5O1xuICB9IC8vIE9wdGltaXplIGZvciB0aGUgc2NlbmFyaW86XG4gIC8vIGNhdGVnb3J5IGlzIFsnMjAxMi0wMS0wMScsICcyMDEyLTAxLTAyJywgLi4uXSwgd2hlcmUgdGhlIGlucHV0XG4gIC8vIGRhdGEgaGFzIGJlZW4gZW5zdXJlZCBub3QgZHVwbGljYXRlIGFuZCBpcyBsYXJnZSBkYXRhLlxuICAvLyBOb3RpY2UsIGlmIGEgZGF0YXNldCBkaW1lbnNpb24gcHJvdmlkZSBjYXRlZ3JvaWVzLCB1c3VhbGx5IGVjaGFydHNcbiAgLy8gc2hvdWxkIHJlbW92ZSBkdXBsaWNhdGlvbiBleGNlcHQgdXNlciB0ZWxsIGVjaGFydHMgZG9udCBkbyB0aGF0XG4gIC8vIChzZXQgYXhpcy5kZWR1cGxpY2F0aW9uID0gZmFsc2UpLCBiZWNhdXNlIGVjaGFydHMgZG8gbm90IGtub3cgd2hldGhlclxuICAvLyB0aGUgdmFsdWVzIGluIHRoZSBjYXRlZ29yeSBkaW1lbnNpb24gaGFzIGR1cGxpY2F0aW9uIChjb25zaWRlciB0aGVcbiAgLy8gcGFyYWxsZWwtYXFpIGV4YW1wbGUpXG5cblxuICBpZiAobmVlZENvbGxlY3QgJiYgIXRoaXMuX2RlZHVwbGljYXRpb24pIHtcbiAgICBpbmRleCA9IHRoaXMuY2F0ZWdvcmllcy5sZW5ndGg7XG4gICAgdGhpcy5jYXRlZ29yaWVzW2luZGV4XSA9IGNhdGVnb3J5O1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIHZhciBtYXAgPSBnZXRPckNyZWF0ZU1hcCh0aGlzKTtcbiAgaW5kZXggPSBtYXAuZ2V0KGNhdGVnb3J5KTtcblxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGlmIChuZWVkQ29sbGVjdCkge1xuICAgICAgaW5kZXggPSB0aGlzLmNhdGVnb3JpZXMubGVuZ3RoO1xuICAgICAgdGhpcy5jYXRlZ29yaWVzW2luZGV4XSA9IGNhdGVnb3J5O1xuICAgICAgbWFwLnNldChjYXRlZ29yeSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IE5hTjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59OyAvLyBDb25zaWRlciBiaWcgZGF0YSwgZG8gbm90IGNyZWF0ZSBtYXAgdW50aWwgbmVlZGVkLlxuXG5cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlTWFwKG9yZGluYWxNZXRhKSB7XG4gIHJldHVybiBvcmRpbmFsTWV0YS5fbWFwIHx8IChvcmRpbmFsTWV0YS5fbWFwID0gY3JlYXRlSGFzaE1hcChvcmRpbmFsTWV0YS5jYXRlZ29yaWVzKSk7XG59XG5cbmZ1bmN0aW9uIGdldE5hbWUob2JqKSB7XG4gIGlmIChpc09iamVjdChvYmopICYmIG9iai52YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG9iai52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqICsgJyc7XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0gT3JkaW5hbE1ldGE7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvT3JkaW5hbE1ldGEuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvT3JkaW5hbE1ldGEuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX3V0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgY3JlYXRlSGFzaE1hcCA9IF91dGlsLmNyZWF0ZUhhc2hNYXA7XG52YXIgaXNUeXBlZEFycmF5ID0gX3V0aWwuaXNUeXBlZEFycmF5O1xuXG52YXIgX2NsYXp6ID0gcmVxdWlyZShcIi4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBlbmFibGVDbGFzc0NoZWNrID0gX2NsYXp6LmVuYWJsZUNsYXNzQ2hlY2s7XG5cbnZhciBfc291cmNlVHlwZSA9IHJlcXVpcmUoXCIuL2hlbHBlci9zb3VyY2VUeXBlXCIpO1xuXG52YXIgU09VUkNFX0ZPUk1BVF9PUklHSU5BTCA9IF9zb3VyY2VUeXBlLlNPVVJDRV9GT1JNQVRfT1JJR0lOQUw7XG52YXIgU0VSSUVTX0xBWU9VVF9CWV9DT0xVTU4gPSBfc291cmNlVHlwZS5TRVJJRVNfTEFZT1VUX0JZX0NPTFVNTjtcbnZhciBTT1VSQ0VfRk9STUFUX1VOS05PV04gPSBfc291cmNlVHlwZS5TT1VSQ0VfRk9STUFUX1VOS05PV047XG52YXIgU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWSA9IF9zb3VyY2VUeXBlLlNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVk7XG52YXIgU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TID0gX3NvdXJjZVR5cGUuU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogW3NvdXJjZUZvcm1hdF1cbiAqXG4gKiArIFwib3JpZ2luYWxcIjpcbiAqIFRoaXMgZm9ybWF0IGlzIG9ubHkgdXNlZCBpbiBzZXJpZXMuZGF0YSwgd2hlcmVcbiAqIGl0ZW1TdHlsZSBjYW4gYmUgc3BlY2lmaWVkIGluIGRhdGEgaXRlbS5cbiAqXG4gKiArIFwiYXJyYXlSb3dzXCI6XG4gKiBbXG4gKiAgICAgWydwcm9kdWN0JywgJ3Njb3JlJywgJ2Ftb3VudCddLFxuICogICAgIFsnTWF0Y2hhIExhdHRlJywgODkuMywgOTUuOF0sXG4gKiAgICAgWydNaWxrIFRlYScsIDkyLjEsIDg5LjRdLFxuICogICAgIFsnQ2hlZXNlIENvY29hJywgOTQuNCwgOTEuMl0sXG4gKiAgICAgWydXYWxudXQgQnJvd25pZScsIDg1LjQsIDc2LjldXG4gKiBdXG4gKlxuICogKyBcIm9iamVjdFJvd3NcIjpcbiAqIFtcbiAqICAgICB7cHJvZHVjdDogJ01hdGNoYSBMYXR0ZScsIHNjb3JlOiA4OS4zLCBhbW91bnQ6IDk1Ljh9LFxuICogICAgIHtwcm9kdWN0OiAnTWlsayBUZWEnLCBzY29yZTogOTIuMSwgYW1vdW50OiA4OS40fSxcbiAqICAgICB7cHJvZHVjdDogJ0NoZWVzZSBDb2NvYScsIHNjb3JlOiA5NC40LCBhbW91bnQ6IDkxLjJ9LFxuICogICAgIHtwcm9kdWN0OiAnV2FsbnV0IEJyb3duaWUnLCBzY29yZTogODUuNCwgYW1vdW50OiA3Ni45fVxuICogXVxuICpcbiAqICsgXCJrZXllZENvbHVtbnNcIjpcbiAqIHtcbiAqICAgICAncHJvZHVjdCc6IFsnTWF0Y2hhIExhdHRlJywgJ01pbGsgVGVhJywgJ0NoZWVzZSBDb2NvYScsICdXYWxudXQgQnJvd25pZSddLFxuICogICAgICdjb3VudCc6IFs4MjMsIDIzNSwgMTA0MiwgOTg4XSxcbiAqICAgICAnc2NvcmUnOiBbOTUuOCwgODEuNCwgOTEuMiwgNzYuOV1cbiAqIH1cbiAqXG4gKiArIFwidHlwZWRBcnJheVwiXG4gKlxuICogKyBcInVua25vd25cIlxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGRzLnNvdXJjZUZvcm1hdFxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGZpZWxkcy5mcm9tRGF0YXNldFxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IFtmaWVsZHMuZGF0YV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2VyaWVzTGF5b3V0Qnk9J2NvbHVtbiddXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3R8c3RyaW5nPn0gW2RpbWVuc2lvbnNEZWZpbmVdXG4gKiBAcGFyYW0ge09iamV0fEhhc2hNYXB9IFtlbmNvZGVEZWZpbmVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0SW5kZXg9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uc0RldGVjdENvdW50XVxuICovXG5mdW5jdGlvbiBTb3VyY2UoZmllbGRzKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuZnJvbURhdGFzZXQgPSBmaWVsZHMuZnJvbURhdGFzZXQ7XG4gIC8qKlxuICAgKiBOb3QgbnVsbC91bmRlZmluZWQuXG4gICAqIEB0eXBlIHtBcnJheXxPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuZGF0YSA9IGZpZWxkcy5kYXRhIHx8IChmaWVsZHMuc291cmNlRm9ybWF0ID09PSBTT1VSQ0VfRk9STUFUX0tFWUVEX0NPTFVNTlMgPyB7fSA6IFtdKTtcbiAgLyoqXG4gICAqIFNlZSBhbHNvIFwiZGV0ZWN0U291cmNlRm9ybWF0XCIuXG4gICAqIE5vdCBudWxsL3VuZGVmaW5lZC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5zb3VyY2VGb3JtYXQgPSBmaWVsZHMuc291cmNlRm9ybWF0IHx8IFNPVVJDRV9GT1JNQVRfVU5LTk9XTjtcbiAgLyoqXG4gICAqICdyb3cnIG9yICdjb2x1bW4nXG4gICAqIE5vdCBudWxsL3VuZGVmaW5lZC5cbiAgICogQHR5cGUge3N0cmluZ30gc2VyaWVzTGF5b3V0QnlcbiAgICovXG5cbiAgdGhpcy5zZXJpZXNMYXlvdXRCeSA9IGZpZWxkcy5zZXJpZXNMYXlvdXRCeSB8fCBTRVJJRVNfTEFZT1VUX0JZX0NPTFVNTjtcbiAgLyoqXG4gICAqIGRpbWVuc2lvbnMgZGVmaW5pdGlvbiBpbiBvcHRpb24uXG4gICAqIGNhbiBiZSBudWxsL3VuZGVmaW5lZC5cbiAgICogQHR5cGUge0FycmF5LjxPYmplY3R8c3RyaW5nPn1cbiAgICovXG5cbiAgdGhpcy5kaW1lbnNpb25zRGVmaW5lID0gZmllbGRzLmRpbWVuc2lvbnNEZWZpbmU7XG4gIC8qKlxuICAgKiBlbmNvZGUgZGVmaW5pdGlvbiBpbiBvcHRpb24uXG4gICAqIGNhbiBiZSBudWxsL3VuZGVmaW5lZC5cbiAgICogQHR5cGUge09iamV0fEhhc2hNYXB9XG4gICAqL1xuXG4gIHRoaXMuZW5jb2RlRGVmaW5lID0gZmllbGRzLmVuY29kZURlZmluZSAmJiBjcmVhdGVIYXNoTWFwKGZpZWxkcy5lbmNvZGVEZWZpbmUpO1xuICAvKipcbiAgICogTm90IG51bGwvdW5kZWZpbmVkLCB1aW50LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLnN0YXJ0SW5kZXggPSBmaWVsZHMuc3RhcnRJbmRleCB8fCAwO1xuICAvKipcbiAgICogQ2FuIGJlIG51bGwvdW5kZWZpbmVkICh3aGVuIHVua25vd24pLCB1aW50LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLmRpbWVuc2lvbnNEZXRlY3RDb3VudCA9IGZpZWxkcy5kaW1lbnNpb25zRGV0ZWN0Q291bnQ7XG59XG4vKipcbiAqIFdyYXAgb3JpZ2luYWwgc2VyaWVzIGRhdGEgZm9yIHNvbWUgY29tcGF0aWJpbGl0eSBjYXNlcy5cbiAqL1xuXG5cblNvdXJjZS5zZXJpZXNEYXRhVG9Tb3VyY2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gbmV3IFNvdXJjZSh7XG4gICAgZGF0YTogZGF0YSxcbiAgICBzb3VyY2VGb3JtYXQ6IGlzVHlwZWRBcnJheShkYXRhKSA/IFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVkgOiBTT1VSQ0VfRk9STUFUX09SSUdJTkFMLFxuICAgIGZyb21EYXRhc2V0OiBmYWxzZVxuICB9KTtcbn07XG5cbmVuYWJsZUNsYXNzQ2hlY2soU291cmNlKTtcbnZhciBfZGVmYXVsdCA9IFNvdXJjZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9Tb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvU291cmNlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF91dGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGNyZWF0ZUhhc2hNYXAgPSBfdXRpbC5jcmVhdGVIYXNoTWFwO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIGlzU3RyaW5nID0gX3V0aWwuaXNTdHJpbmc7XG52YXIgZGVmYXVsdHMgPSBfdXRpbC5kZWZhdWx0cztcbnZhciBleHRlbmQgPSBfdXRpbC5leHRlbmQ7XG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcbnZhciBjbG9uZSA9IF91dGlsLmNsb25lO1xuXG52YXIgX21vZGVsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBub3JtYWxpemVUb0FycmF5ID0gX21vZGVsLm5vcm1hbGl6ZVRvQXJyYXk7XG5cbnZhciBfc291cmNlSGVscGVyID0gcmVxdWlyZShcIi4vc291cmNlSGVscGVyXCIpO1xuXG52YXIgZ3Vlc3NPcmRpbmFsID0gX3NvdXJjZUhlbHBlci5ndWVzc09yZGluYWw7XG5cbnZhciBTb3VyY2UgPSByZXF1aXJlKFwiLi4vU291cmNlXCIpO1xuXG52YXIgX2RpbWVuc2lvbkhlbHBlciA9IHJlcXVpcmUoXCIuL2RpbWVuc2lvbkhlbHBlclwiKTtcblxudmFyIE9USEVSX0RJTUVOU0lPTlMgPSBfZGltZW5zaW9uSGVscGVyLk9USEVSX0RJTUVOU0lPTlM7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVXNlIGBlY2hhcnRzL2RhdGEvaGVscGVyL2NyZWF0ZURpbWVuc2lvbnNgIGluc3RlYWQuXG4gKi9cblxuLyoqXG4gKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy90ZXN0L3V0L3NwZWMvZGF0YS9jb21wbGV0ZURpbWVuc2lvbnN9XG4gKlxuICogQ29tcGxldGUgdGhlIGRpbWVuc2lvbnMgYXJyYXksIGJ5IHVzZXIgZGVmaW5lZCBgZGltZW5zaW9uYCBhbmQgYGVuY29kZWAsXG4gKiBhbmQgZ3Vlc3NpbmcgZnJvbSB0aGUgZGF0YSBzdHJ1Y3R1cmUuXG4gKiBJZiBubyAndmFsdWUnIGRpbWVuc2lvbiBzcGVjaWZpZWQsIHRoZSBmaXJzdCBuby1uYW1lZCBkaW1lbnNpb24gd2lsbCBiZVxuICogbmFtZWQgYXMgJ3ZhbHVlJy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzeXNEaW1zIE5lY2Vzc2FyeSBkaW1lbnNpb25zLCBsaWtlIFsneCcsICd5J10sIHdoaWNoXG4gKiAgICAgIHByb3ZpZGVzIG5vdCBvbmx5IGRpbSB0ZW1wbGF0ZSwgYnV0IGFsc28gZGVmYXVsdCBvcmRlci5cbiAqICAgICAgcHJvcGVydGllczogJ25hbWUnLCAndHlwZScsICdkaXNwbGF5TmFtZScuXG4gKiAgICAgIGBuYW1lYCBvZiBlYWNoIGl0ZW0gcHJvdmlkZXMgZGVmYXVsdCBjb29yZCBuYW1lLlxuICogICAgICBbe2RpbXNEZWY6IFtzdHJpbmd8T2JqZWN0LCAuLi5dfSwgLi4uXSBkaW1zRGVmIG9mIHN5c0RpbSBpdGVtIHByb3ZpZGVzIGRlZmF1bHQgZGltIG5hbWUsIGFuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlIGRpbXMgY291bnQgdGhhdCB0aGUgc3lzRGltIHJlcXVpcmVkLlxuICogICAgICBbe29yZGluYWxNZXRhfV0gY2FuIGJlIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9Tb3VyY2V8QXJyYXl8T2JqZWN0fSBzb3VyY2Ugb3IgZGF0YSAoZm9yIGNvbXBhdGliYWwgd2l0aCBwZXJ2aW91cylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0fHN0cmluZz59IFtvcHQuZGltc0RlZl0gb3B0aW9uLnNlcmllcy5kaW1lbnNpb25zIFVzZXIgZGVmaW5lZCBkaW1lbnNpb25zXG4gKiAgICAgIEZvciBleGFtcGxlOiBbJ2FzZGYnLCB7bmFtZSwgdHlwZX0sIC4uLl0uXG4gKiBAcGFyYW0ge09iamVjdHxIYXNoTWFwfSBbb3B0LmVuY29kZURlZl0gb3B0aW9uLnNlcmllcy5lbmNvZGUge3g6IDIsIHk6IFszLCAxXSwgdG9vbHRpcDogWzEsIDJdLCBsYWJlbDogM31cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmdlbmVyYXRlQ29vcmRdIEdlbmVyYXRlIGNvb3JkIGRpbSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICogICAgICAgICAgICAgICAgIElmIG5vdCBzcGVjaWZpZWQsIGV4dHJhIGRpbSBuYW1lcyB3aWxsIGJlOlxuICogICAgICAgICAgICAgICAgICd2YWx1ZScsICd2YWx1ZTAnLCAndmFsdWUxJywgLi4uXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5nZW5lcmF0ZUNvb3JkQ291bnRdIEJ5IGRlZmF1bHQsIHRoZSBnZW5lcmF0ZWQgZGltIG5hbWUgaXMgYGdlbmVyYXRlQ29vcmRgLlxuICogICAgICAgICAgICAgICAgIElmIGBnZW5lcmF0ZUNvb3JkQ291bnRgIHNwZWNpZmllZCwgdGhlIGdlbmVyYXRlZCBkaW0gbmFtZXMgd2lsbCBiZTpcbiAqICAgICAgICAgICAgICAgICBgZ2VuZXJhdGVDb29yZGAgKyAwLCBgZ2VuZXJhdGVDb29yZGAgKyAxLCAuLi5cbiAqICAgICAgICAgICAgICAgICBjYW4gYmUgSW5maW5pdHksIGluZGljYXRlIHRoYXQgdXNlIGFsbCBvZiB0aGUgcmVtYWluIGNvbHVtbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5kaW1Db3VudF0gSWYgbm90IHNwZWNpZmllZCwgZ3Vlc3MgYnkgdGhlIGZpcnN0IGRhdGEgaXRlbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuY29kZURlZmF1bHRlcl0gSWYgbm90IHNwZWNpZmllZCwgYXV0byBmaW5kIHRoZSBuZXh0IGF2YWlsYWJsZSBkYXRhIGRpbS5cbiAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBbe1xuICogICAgICBuYW1lOiBzdHJpbmcgbWFuZGF0b3J5LFxuICogICAgICBkaXNwbGF5TmFtZTogc3RyaW5nLCB0aGUgb3JpZ2luIG5hbWUgaW4gZGltc0RlZiwgc2VlIHNvdXJjZSBoZWxwZXIuXG4gKiAgICAgICAgICAgICAgICAgSWYgZGlzcGxheU5hbWUgZ2l2ZW4sIHRoZSB0b29sdGlwIHdpbGwgZGlzcGxheWVkIHZlcnRpY2FsbHkuXG4gKiAgICAgIGNvb3JkRGltOiBzdHJpbmcgbWFuZGF0b3J5LFxuICogICAgICBjb29yZERpbUluZGV4OiBudW1iZXIgbWFuZGF0b3J5LFxuICogICAgICB0eXBlOiBzdHJpbmcgb3B0aW9uYWwsXG4gKiAgICAgIG90aGVyRGltczogeyBuZXZlciBudWxsL3VuZGVmaW5lZFxuICogICAgICAgICAgdG9vbHRpcDogbnVtYmVyIG9wdGlvbmFsLFxuICogICAgICAgICAgbGFiZWw6IG51bWJlciBvcHRpb25hbCxcbiAqICAgICAgICAgIGl0ZW1OYW1lOiBudW1iZXIgb3B0aW9uYWwsXG4gKiAgICAgICAgICBzZXJpZXNOYW1lOiBudW1iZXIgb3B0aW9uYWwsXG4gKiAgICAgIH0sXG4gKiAgICAgIGlzRXh0cmFDb29yZDogYm9vbGVhbiB0cnVlIGlmIGNvb3JkIGlzIGdlbmVyYXRlZFxuICogICAgICAgICAgKG5vdCBzcGVjaWZpZWQgaW4gZW5jb2RlIGFuZCBub3Qgc2VyaWVzIHNwZWNpZmllZClcbiAqICAgICAgb3RoZXIgcHJvcHMgLi4uXG4gKiB9XVxuICovXG5mdW5jdGlvbiBjb21wbGV0ZURpbWVuc2lvbnMoc3lzRGltcywgc291cmNlLCBvcHQpIHtcbiAgaWYgKCFTb3VyY2UuaXNJbnN0YW5jZShzb3VyY2UpKSB7XG4gICAgc291cmNlID0gU291cmNlLnNlcmllc0RhdGFUb1NvdXJjZShzb3VyY2UpO1xuICB9XG5cbiAgb3B0ID0gb3B0IHx8IHt9O1xuICBzeXNEaW1zID0gKHN5c0RpbXMgfHwgW10pLnNsaWNlKCk7XG4gIHZhciBkaW1zRGVmID0gKG9wdC5kaW1zRGVmIHx8IFtdKS5zbGljZSgpO1xuICB2YXIgZW5jb2RlRGVmID0gY3JlYXRlSGFzaE1hcChvcHQuZW5jb2RlRGVmKTtcbiAgdmFyIGRhdGFEaW1OYW1lTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICB2YXIgY29vcmREaW1OYW1lTWFwID0gY3JlYXRlSGFzaE1hcCgpOyAvLyB2YXIgdmFsdWVDYW5kaWRhdGU7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgZGltQ291bnQgPSBnZXREaW1Db3VudChzb3VyY2UsIHN5c0RpbXMsIGRpbXNEZWYsIG9wdC5kaW1Db3VudCk7IC8vIEFwcGx5IHVzZXIgZGVmaW5lZCBkaW1zIChgbmFtZWAgYW5kIGB0eXBlYCkgYW5kIGluaXQgcmVzdWx0LlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGltQ291bnQ7IGkrKykge1xuICAgIHZhciBkaW1EZWZJdGVtID0gZGltc0RlZltpXSA9IGV4dGVuZCh7fSwgaXNPYmplY3QoZGltc0RlZltpXSkgPyBkaW1zRGVmW2ldIDoge1xuICAgICAgbmFtZTogZGltc0RlZltpXVxuICAgIH0pO1xuICAgIHZhciB1c2VyRGltTmFtZSA9IGRpbURlZkl0ZW0ubmFtZTtcbiAgICB2YXIgcmVzdWx0SXRlbSA9IHJlc3VsdFtpXSA9IHtcbiAgICAgIG90aGVyRGltczoge31cbiAgICB9OyAvLyBOYW1lIHdpbGwgYmUgYXBwbGllZCBsYXRlciBmb3IgYXZvaWRpbmcgZHVwbGljYXRpb24uXG5cbiAgICBpZiAodXNlckRpbU5hbWUgIT0gbnVsbCAmJiBkYXRhRGltTmFtZU1hcC5nZXQodXNlckRpbU5hbWUpID09IG51bGwpIHtcbiAgICAgIC8vIE9ubHkgaWYgYHNlcmllcy5kaW1lbnNpb25zYCBpcyBkZWZpbmVkIGluIG9wdGlvblxuICAgICAgLy8gZGlzcGxheU5hbWUsIHdpbGwgYmUgc2V0LCBhbmQgZGltZW5zaW9uIHdpbGwgYmUgZGlwbGF5ZWQgdmVydGljYWxseSBpblxuICAgICAgLy8gdG9vbHRpcCBieSBkZWZhdWx0LlxuICAgICAgcmVzdWx0SXRlbS5uYW1lID0gcmVzdWx0SXRlbS5kaXNwbGF5TmFtZSA9IHVzZXJEaW1OYW1lO1xuICAgICAgZGF0YURpbU5hbWVNYXAuc2V0KHVzZXJEaW1OYW1lLCBpKTtcbiAgICB9XG5cbiAgICBkaW1EZWZJdGVtLnR5cGUgIT0gbnVsbCAmJiAocmVzdWx0SXRlbS50eXBlID0gZGltRGVmSXRlbS50eXBlKTtcbiAgICBkaW1EZWZJdGVtLmRpc3BsYXlOYW1lICE9IG51bGwgJiYgKHJlc3VsdEl0ZW0uZGlzcGxheU5hbWUgPSBkaW1EZWZJdGVtLmRpc3BsYXlOYW1lKTtcbiAgfSAvLyBTZXQgYGNvb3JkRGltYCBhbmQgYGNvb3JkRGltSW5kZXhgIGJ5IGBlbmNvZGVEZWZgIGFuZCBub3JtYWxpemUgYGVuY29kZURlZmAuXG5cblxuICBlbmNvZGVEZWYuZWFjaChmdW5jdGlvbiAoZGF0YURpbXMsIGNvb3JkRGltKSB7XG4gICAgZGF0YURpbXMgPSBub3JtYWxpemVUb0FycmF5KGRhdGFEaW1zKS5zbGljZSgpO1xuICAgIHZhciB2YWxpZERhdGFEaW1zID0gZW5jb2RlRGVmLnNldChjb29yZERpbSwgW10pO1xuICAgIGVhY2goZGF0YURpbXMsIGZ1bmN0aW9uIChyZXN1bHREaW1JZHgsIGlkeCkge1xuICAgICAgLy8gVGhlIGlucHV0IHJlc3VsdERpbUlkeCBjYW4gYmUgZGltIG5hbWUgb3IgaW5kZXguXG4gICAgICBpc1N0cmluZyhyZXN1bHREaW1JZHgpICYmIChyZXN1bHREaW1JZHggPSBkYXRhRGltTmFtZU1hcC5nZXQocmVzdWx0RGltSWR4KSk7XG5cbiAgICAgIGlmIChyZXN1bHREaW1JZHggIT0gbnVsbCAmJiByZXN1bHREaW1JZHggPCBkaW1Db3VudCkge1xuICAgICAgICB2YWxpZERhdGFEaW1zW2lkeF0gPSByZXN1bHREaW1JZHg7XG4gICAgICAgIGFwcGx5RGltKHJlc3VsdFtyZXN1bHREaW1JZHhdLCBjb29yZERpbSwgaWR4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIEFwcGx5IHRlbXBsZXRlcyBhbmQgZGVmYXVsdCBvcmRlciBmcm9tIGBzeXNEaW1zYC5cblxuICB2YXIgYXZhaWxEaW1JZHggPSAwO1xuICBlYWNoKHN5c0RpbXMsIGZ1bmN0aW9uIChzeXNEaW1JdGVtLCBzeXNEaW1JbmRleCkge1xuICAgIHZhciBjb29yZERpbTtcbiAgICB2YXIgc3lzRGltSXRlbTtcbiAgICB2YXIgc3lzRGltSXRlbURpbXNEZWY7XG4gICAgdmFyIHN5c0RpbUl0ZW1PdGhlckRpbXM7XG5cbiAgICBpZiAoaXNTdHJpbmcoc3lzRGltSXRlbSkpIHtcbiAgICAgIGNvb3JkRGltID0gc3lzRGltSXRlbTtcbiAgICAgIHN5c0RpbUl0ZW0gPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmREaW0gPSBzeXNEaW1JdGVtLm5hbWU7XG4gICAgICB2YXIgb3JkaW5hbE1ldGEgPSBzeXNEaW1JdGVtLm9yZGluYWxNZXRhO1xuICAgICAgc3lzRGltSXRlbS5vcmRpbmFsTWV0YSA9IG51bGw7XG4gICAgICBzeXNEaW1JdGVtID0gY2xvbmUoc3lzRGltSXRlbSk7XG4gICAgICBzeXNEaW1JdGVtLm9yZGluYWxNZXRhID0gb3JkaW5hbE1ldGE7IC8vIGBjb29yZERpbUluZGV4YCBzaG91bGQgbm90IGJlIHNldCBkaXJlY3RseS5cblxuICAgICAgc3lzRGltSXRlbURpbXNEZWYgPSBzeXNEaW1JdGVtLmRpbXNEZWY7XG4gICAgICBzeXNEaW1JdGVtT3RoZXJEaW1zID0gc3lzRGltSXRlbS5vdGhlckRpbXM7XG4gICAgICBzeXNEaW1JdGVtLm5hbWUgPSBzeXNEaW1JdGVtLmNvb3JkRGltID0gc3lzRGltSXRlbS5jb29yZERpbUluZGV4ID0gc3lzRGltSXRlbS5kaW1zRGVmID0gc3lzRGltSXRlbS5vdGhlckRpbXMgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBkYXRhRGltcyA9IG5vcm1hbGl6ZVRvQXJyYXkoZW5jb2RlRGVmLmdldChjb29yZERpbSkpOyAvLyBkaW1lbnNpb25zIHByb3ZpZGVzIGRlZmF1bHQgZGltIHNlcXVlbmNlcy5cblxuICAgIGlmICghZGF0YURpbXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChzeXNEaW1JdGVtRGltc0RlZiAmJiBzeXNEaW1JdGVtRGltc0RlZi5sZW5ndGggfHwgMSk7IGkrKykge1xuICAgICAgICB3aGlsZSAoYXZhaWxEaW1JZHggPCByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFthdmFpbERpbUlkeF0uY29vcmREaW0gIT0gbnVsbCkge1xuICAgICAgICAgIGF2YWlsRGltSWR4Kys7XG4gICAgICAgIH1cblxuICAgICAgICBhdmFpbERpbUlkeCA8IHJlc3VsdC5sZW5ndGggJiYgZGF0YURpbXMucHVzaChhdmFpbERpbUlkeCsrKTtcbiAgICAgIH1cbiAgICB9IC8vIEFwcGx5IHRlbXBsYXRlcy5cblxuXG4gICAgZWFjaChkYXRhRGltcywgZnVuY3Rpb24gKHJlc3VsdERpbUlkeCwgY29vcmREaW1JbmRleCkge1xuICAgICAgdmFyIHJlc3VsdEl0ZW0gPSByZXN1bHRbcmVzdWx0RGltSWR4XTtcbiAgICAgIGFwcGx5RGltKGRlZmF1bHRzKHJlc3VsdEl0ZW0sIHN5c0RpbUl0ZW0pLCBjb29yZERpbSwgY29vcmREaW1JbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHRJdGVtLm5hbWUgPT0gbnVsbCAmJiBzeXNEaW1JdGVtRGltc0RlZikge1xuICAgICAgICB2YXIgc3lzRGltSXRlbURpbXNEZWZJdGVtID0gc3lzRGltSXRlbURpbXNEZWZbY29vcmREaW1JbmRleF07XG4gICAgICAgICFpc09iamVjdChzeXNEaW1JdGVtRGltc0RlZkl0ZW0pICYmIChzeXNEaW1JdGVtRGltc0RlZkl0ZW0gPSB7XG4gICAgICAgICAgbmFtZTogc3lzRGltSXRlbURpbXNEZWZJdGVtXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHRJdGVtLm5hbWUgPSByZXN1bHRJdGVtLmRpc3BsYXlOYW1lID0gc3lzRGltSXRlbURpbXNEZWZJdGVtLm5hbWU7XG4gICAgICAgIHJlc3VsdEl0ZW0uZGVmYXVsdFRvb2x0aXAgPSBzeXNEaW1JdGVtRGltc0RlZkl0ZW0uZGVmYXVsdFRvb2x0aXA7XG4gICAgICB9IC8vIEZJWE1FIHJlZmFjdG9yLCBjdXJyZW50bHkgb25seSB1c2VkIGluIGNhc2U6IHtvdGhlckRpbXM6IHt0b29sdGlwOiBmYWxzZX19XG5cblxuICAgICAgc3lzRGltSXRlbU90aGVyRGltcyAmJiBkZWZhdWx0cyhyZXN1bHRJdGVtLm90aGVyRGltcywgc3lzRGltSXRlbU90aGVyRGltcyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFwcGx5RGltKHJlc3VsdEl0ZW0sIGNvb3JkRGltLCBjb29yZERpbUluZGV4KSB7XG4gICAgaWYgKE9USEVSX0RJTUVOU0lPTlMuZ2V0KGNvb3JkRGltKSAhPSBudWxsKSB7XG4gICAgICByZXN1bHRJdGVtLm90aGVyRGltc1tjb29yZERpbV0gPSBjb29yZERpbUluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRJdGVtLmNvb3JkRGltID0gY29vcmREaW07XG4gICAgICByZXN1bHRJdGVtLmNvb3JkRGltSW5kZXggPSBjb29yZERpbUluZGV4O1xuICAgICAgY29vcmREaW1OYW1lTWFwLnNldChjb29yZERpbSwgdHJ1ZSk7XG4gICAgfVxuICB9IC8vIE1ha2Ugc3VyZSB0aGUgZmlyc3QgZXh0cmEgZGltIGlzICd2YWx1ZScuXG5cblxuICB2YXIgZ2VuZXJhdGVDb29yZCA9IG9wdC5nZW5lcmF0ZUNvb3JkO1xuICB2YXIgZ2VuZXJhdGVDb29yZENvdW50ID0gb3B0LmdlbmVyYXRlQ29vcmRDb3VudDtcbiAgdmFyIGZyb21aZXJvID0gZ2VuZXJhdGVDb29yZENvdW50ICE9IG51bGw7XG4gIGdlbmVyYXRlQ29vcmRDb3VudCA9IGdlbmVyYXRlQ29vcmQgPyBnZW5lcmF0ZUNvb3JkQ291bnQgfHwgMSA6IDA7XG4gIHZhciBleHRyYSA9IGdlbmVyYXRlQ29vcmQgfHwgJ3ZhbHVlJzsgLy8gU2V0IGRpbSBgbmFtZWAgYW5kIG90aGVyIGBjb29yZERpbWAgYW5kIG90aGVyIHByb3BzLlxuXG4gIGZvciAodmFyIHJlc3VsdERpbUlkeCA9IDA7IHJlc3VsdERpbUlkeCA8IGRpbUNvdW50OyByZXN1bHREaW1JZHgrKykge1xuICAgIHZhciByZXN1bHRJdGVtID0gcmVzdWx0W3Jlc3VsdERpbUlkeF0gPSByZXN1bHRbcmVzdWx0RGltSWR4XSB8fCB7fTtcbiAgICB2YXIgY29vcmREaW0gPSByZXN1bHRJdGVtLmNvb3JkRGltO1xuXG4gICAgaWYgKGNvb3JkRGltID09IG51bGwpIHtcbiAgICAgIHJlc3VsdEl0ZW0uY29vcmREaW0gPSBnZW5OYW1lKGV4dHJhLCBjb29yZERpbU5hbWVNYXAsIGZyb21aZXJvKTtcbiAgICAgIHJlc3VsdEl0ZW0uY29vcmREaW1JbmRleCA9IDA7XG5cbiAgICAgIGlmICghZ2VuZXJhdGVDb29yZCB8fCBnZW5lcmF0ZUNvb3JkQ291bnQgPD0gMCkge1xuICAgICAgICByZXN1bHRJdGVtLmlzRXh0cmFDb29yZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRlQ29vcmRDb3VudC0tO1xuICAgIH1cblxuICAgIHJlc3VsdEl0ZW0ubmFtZSA9PSBudWxsICYmIChyZXN1bHRJdGVtLm5hbWUgPSBnZW5OYW1lKHJlc3VsdEl0ZW0uY29vcmREaW0sIGRhdGFEaW1OYW1lTWFwKSk7XG5cbiAgICBpZiAocmVzdWx0SXRlbS50eXBlID09IG51bGwgJiYgZ3Vlc3NPcmRpbmFsKHNvdXJjZSwgcmVzdWx0RGltSWR4LCByZXN1bHRJdGVtLm5hbWUpKSB7XG4gICAgICByZXN1bHRJdGVtLnR5cGUgPSAnb3JkaW5hbCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0gLy8gPz8/IFRPRE9cbi8vIE9yaWdpbmFsbHkgZGV0ZWN0IGRpbUNvdW50IGJ5IGRhdGFbMF0uIFNob3VsZCB3ZVxuLy8gb3B0aW1pemUgaXQgdG8gb25seSBieSBzeXNEaW1zIGFuZCBkaW1lbnNpb25zIGFuZCBlbmNvZGUuXG4vLyBTbyBvbmx5IG5lY2Vzc2FyeSBkaW1zIHdpbGwgYmUgaW5pdGlhbGl6ZWQuXG4vLyBCdXRcbi8vICgxKSBjdXN0b20gc2VyaWVzIHNob3VsZCBiZSBjb25zaWRlcmVkLiB3aGVyZSBvdGhlciBkaW1zXG4vLyBtYXkgYmUgdmlzaXRlZC5cbi8vICgyKSBzb21ldGltZXMgdXNlciBuZWVkIHRvIGNhbGN1YWx0ZSBidWJibGUgc2l6ZSBvciB1c2UgdmlzdWFsTWFwXG4vLyBvbiBvdGhlciBkaW1lbnNpb25zIGJlc2lkZXMgY29vcmRTeXMgbmVlZGVkLlxuLy8gU28sIGRpbXMgdGhhdCBpcyBub3QgdXNlZCBieSBzeXN0ZW0sIHNob3VsZCBiZSBzaGFyZWQgaW4gc3RvcmFnZT9cblxuXG5mdW5jdGlvbiBnZXREaW1Db3VudChzb3VyY2UsIHN5c0RpbXMsIGRpbXNEZWYsIG9wdERpbUNvdW50KSB7XG4gIC8vIE5vdGUgdGhhdCB0aGUgcmVzdWx0IGRpbUNvdW50IHNob3VsZCBub3Qgc21hbGwgdGhhbiBjb2x1bW5zIGNvdW50XG4gIC8vIG9mIGRhdGEsIG90aGVyd2lzZSBgZGF0YURpbU5hbWVNYXBgIGNoZWNraW5nIHdpbGwgYmUgaW5jb3JyZWN0LlxuICB2YXIgZGltQ291bnQgPSBNYXRoLm1heChzb3VyY2UuZGltZW5zaW9uc0RldGVjdENvdW50IHx8IDEsIHN5c0RpbXMubGVuZ3RoLCBkaW1zRGVmLmxlbmd0aCwgb3B0RGltQ291bnQgfHwgMCk7XG4gIGVhY2goc3lzRGltcywgZnVuY3Rpb24gKHN5c0RpbUl0ZW0pIHtcbiAgICB2YXIgc3lzRGltSXRlbURpbXNEZWYgPSBzeXNEaW1JdGVtLmRpbXNEZWY7XG4gICAgc3lzRGltSXRlbURpbXNEZWYgJiYgKGRpbUNvdW50ID0gTWF0aC5tYXgoZGltQ291bnQsIHN5c0RpbUl0ZW1EaW1zRGVmLmxlbmd0aCkpO1xuICB9KTtcbiAgcmV0dXJuIGRpbUNvdW50O1xufVxuXG5mdW5jdGlvbiBnZW5OYW1lKG5hbWUsIG1hcCwgZnJvbVplcm8pIHtcbiAgaWYgKGZyb21aZXJvIHx8IG1hcC5nZXQobmFtZSkgIT0gbnVsbCkge1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChtYXAuZ2V0KG5hbWUgKyBpKSAhPSBudWxsKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgbmFtZSArPSBpO1xuICB9XG5cbiAgbWFwLnNldChuYW1lLCB0cnVlKTtcbiAgcmV0dXJuIG5hbWU7XG59XG5cbnZhciBfZGVmYXVsdCA9IGNvbXBsZXRlRGltZW5zaW9ucztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY29tcGxldGVEaW1lbnNpb25zID0gcmVxdWlyZShcIi4vY29tcGxldGVEaW1lbnNpb25zXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogU3Vic3RpdHV0ZSBgY29tcGxldGVEaW1lbnNpb25zYC5cbiAqIGBjb21wbGV0ZURpbWVuc2lvbnNgIGlzIHRvIGJlIGRlcHJlY2F0ZWQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvU291cmNlfG1vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gc291cmNlIG9yIGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gW29wdF1cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3xPYmplY3Q+fSBbb3B0LmNvb3JkRGltZW5zaW9ucz1bXV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmRpbWVuc2lvbnNDb3VudF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmdlbmVyYXRlQ29vcmRdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdC5nZW5lcmF0ZUNvb3JkQ291bnRdXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmd8T2JqZWN0Pn0gW29wdC5kaW1lbnNpb25zRGVmaW5lPXNvdXJjZS5kaW1lbnNpb25zRGVmaW5lXSBPdmVyd3JpdGUgc291cmNlIGRlZmluZS5cbiAqIEBwYXJhbSB7T2JqZWN0fEhhc2hNYXB9IFtvcHQuZW5jb2RlRGVmaW5lPXNvdXJjZS5lbmNvZGVEZWZpbmVdIE92ZXJ3cml0ZSBzb3VyY2UgZGVmaW5lLlxuICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59IGRpbWVuc2lvbnNJbmZvXG4gKi9cbmZ1bmN0aW9uIF9kZWZhdWx0KHNvdXJjZSwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgcmV0dXJuIGNvbXBsZXRlRGltZW5zaW9ucyhvcHQuY29vcmREaW1lbnNpb25zIHx8IFtdLCBzb3VyY2UsIHtcbiAgICBkaW1zRGVmOiBvcHQuZGltZW5zaW9uc0RlZmluZSB8fCBzb3VyY2UuZGltZW5zaW9uc0RlZmluZSxcbiAgICBlbmNvZGVEZWY6IG9wdC5lbmNvZGVEZWZpbmUgfHwgc291cmNlLmVuY29kZURlZmluZSxcbiAgICBkaW1Db3VudDogb3B0LmRpbWVuc2lvbnNDb3VudCxcbiAgICBnZW5lcmF0ZUNvb3JkOiBvcHQuZ2VuZXJhdGVDb29yZCxcbiAgICBnZW5lcmF0ZUNvb3JkQ291bnQ6IG9wdC5nZW5lcmF0ZUNvb3JkQ291bnRcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvY3JlYXRlRGltZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvY3JlYXRlRGltZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc1R5cGVkQXJyYXkgPSBfdXRpbC5pc1R5cGVkQXJyYXk7XG52YXIgZXh0ZW5kID0gX3V0aWwuZXh0ZW5kO1xudmFyIGFzc2VydCA9IF91dGlsLmFzc2VydDtcbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xuXG52YXIgX21vZGVsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBnZXREYXRhSXRlbVZhbHVlID0gX21vZGVsLmdldERhdGFJdGVtVmFsdWU7XG52YXIgaXNEYXRhSXRlbU9wdGlvbiA9IF9tb2RlbC5pc0RhdGFJdGVtT3B0aW9uO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIHBhcnNlRGF0ZSA9IF9udW1iZXIucGFyc2VEYXRlO1xuXG52YXIgU291cmNlID0gcmVxdWlyZShcIi4uL1NvdXJjZVwiKTtcblxudmFyIF9zb3VyY2VUeXBlID0gcmVxdWlyZShcIi4vc291cmNlVHlwZVwiKTtcblxudmFyIFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVkgPSBfc291cmNlVHlwZS5TT1VSQ0VfRk9STUFUX1RZUEVEX0FSUkFZO1xudmFyIFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUyA9IF9zb3VyY2VUeXBlLlNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUztcbnZhciBTT1VSQ0VfRk9STUFUX09SSUdJTkFMID0gX3NvdXJjZVR5cGUuU09VUkNFX0ZPUk1BVF9PUklHSU5BTDtcbnZhciBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTID0gX3NvdXJjZVR5cGUuU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUztcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gVE9ET1xuLy8gPz8/IHJlZmFjdG9yPyBjaGVjayB0aGUgb3V0ZXIgdXNhZ2Ugb2YgZGF0YSBwcm92aWRlci5cbi8vIG1lcmdlIHdpdGggZGVmYXVsdERpbVZhbHVlR2V0dGVyP1xuXG4vKipcbiAqIElmIG5vcm1hbCBhcnJheSB1c2VkLCBtdXRhYmxlIGNodW5rIHNpemUgaXMgc3VwcG9ydGVkLlxuICogSWYgdHlwZWQgYXJyYXkgdXNlZCwgY2h1bmsgc2l6ZSBtdXN0IGJlIGZpeGVkLlxuICovXG5mdW5jdGlvbiBEZWZhdWx0RGF0YVByb3ZpZGVyKHNvdXJjZSwgZGltU2l6ZSkge1xuICBpZiAoIVNvdXJjZS5pc0luc3RhbmNlKHNvdXJjZSkpIHtcbiAgICBzb3VyY2UgPSBTb3VyY2Uuc2VyaWVzRGF0YVRvU291cmNlKHNvdXJjZSk7XG4gIH1cblxuICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YSA9IHNvdXJjZS5kYXRhO1xuICB2YXIgc291cmNlRm9ybWF0ID0gc291cmNlLnNvdXJjZUZvcm1hdDsgLy8gVHlwZWQgYXJyYXkuIFRPRE8gSUUxMCs/XG5cbiAgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWSkge1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgdGhpcy5fZGltU2l6ZSA9IGRpbVNpemU7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICB2YXIgbWV0aG9kcyA9IHByb3ZpZGVyTWV0aG9kc1tzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUyA/IHNvdXJjZUZvcm1hdCArICdfJyArIHNvdXJjZS5zZXJpZXNMYXlvdXRCeSA6IHNvdXJjZUZvcm1hdF07XG4gIGV4dGVuZCh0aGlzLCBtZXRob2RzKTtcbn1cblxudmFyIHByb3ZpZGVyUHJvdG8gPSBEZWZhdWx0RGF0YVByb3ZpZGVyLnByb3RvdHlwZTsgLy8gSWYgZGF0YSBpcyBwdXJlIHdpdGhvdXQgc3R5bGUgY29uZmlndXJhdGlvblxuXG5wcm92aWRlclByb3RvLnB1cmUgPSBmYWxzZTsgLy8gSWYgZGF0YSBpcyBwZXJzaXN0ZW50IGFuZCB3aWxsIG5vdCBiZSByZWxlYXNlZCBhZnRlciB1c2UuXG5cbnByb3ZpZGVyUHJvdG8ucGVyc2lzdGVudCA9IHRydWU7IC8vID8/PyEgRklYTUUgbGVnYWN5IGRhdGEgcHJvdmlkZXIgZG8gbm90IGhhcyBtZXRob2QgZ2V0U291cmNlXG5cbnByb3ZpZGVyUHJvdG8uZ2V0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fc291cmNlO1xufTtcblxudmFyIHByb3ZpZGVyTWV0aG9kcyA9IHtcbiAgJ2FycmF5Um93c19jb2x1bW4nOiB7XG4gICAgcHVyZTogdHJ1ZSxcbiAgICBjb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIHRoaXMuX2RhdGEubGVuZ3RoIC0gdGhpcy5fc291cmNlLnN0YXJ0SW5kZXgpO1xuICAgIH0sXG4gICAgZ2V0SXRlbTogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbaWR4ICsgdGhpcy5fc291cmNlLnN0YXJ0SW5kZXhdO1xuICAgIH0sXG4gICAgYXBwZW5kRGF0YTogYXBwZW5kRGF0YVNpbXBseVxuICB9LFxuICAnYXJyYXlSb3dzX3Jvdyc6IHtcbiAgICBwdXJlOiB0cnVlLFxuICAgIGNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcm93ID0gdGhpcy5fZGF0YVswXTtcbiAgICAgIHJldHVybiByb3cgPyBNYXRoLm1heCgwLCByb3cubGVuZ3RoIC0gdGhpcy5fc291cmNlLnN0YXJ0SW5kZXgpIDogMDtcbiAgICB9LFxuICAgIGdldEl0ZW06IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIGlkeCArPSB0aGlzLl9zb3VyY2Uuc3RhcnRJbmRleDtcbiAgICAgIHZhciBpdGVtID0gW107XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcm93ID0gZGF0YVtpXTtcbiAgICAgICAgaXRlbS5wdXNoKHJvdyA/IHJvd1tpZHhdIDogbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0sXG4gICAgYXBwZW5kRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEbyBub3Qgc3VwcG9ydCBhcHBlbmREYXRhIHdoZW4gc2V0IHNlcmllc0xheW91dEJ5OiBcInJvd1wiLicpO1xuICAgIH1cbiAgfSxcbiAgJ29iamVjdFJvd3MnOiB7XG4gICAgcHVyZTogdHJ1ZSxcbiAgICBjb3VudDogY291bnRTaW1wbHksXG4gICAgZ2V0SXRlbTogZ2V0SXRlbVNpbXBseSxcbiAgICBhcHBlbmREYXRhOiBhcHBlbmREYXRhU2ltcGx5XG4gIH0sXG4gICdrZXllZENvbHVtbnMnOiB7XG4gICAgcHVyZTogdHJ1ZSxcbiAgICBjb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRpbU5hbWUgPSB0aGlzLl9zb3VyY2UuZGltZW5zaW9uc0RlZmluZVswXS5uYW1lO1xuICAgICAgdmFyIGNvbCA9IHRoaXMuX2RhdGFbZGltTmFtZV07XG4gICAgICByZXR1cm4gY29sID8gY29sLmxlbmd0aCA6IDA7XG4gICAgfSxcbiAgICBnZXRJdGVtOiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgaXRlbSA9IFtdO1xuICAgICAgdmFyIGRpbXMgPSB0aGlzLl9zb3VyY2UuZGltZW5zaW9uc0RlZmluZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLl9kYXRhW2RpbXNbaV0ubmFtZV07XG4gICAgICAgIGl0ZW0ucHVzaChjb2wgPyBjb2xbaWR4XSA6IG51bGwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9LFxuICAgIGFwcGVuZERhdGE6IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICBlYWNoKG5ld0RhdGEsIGZ1bmN0aW9uIChuZXdDb2wsIGtleSkge1xuICAgICAgICB2YXIgb2xkQ29sID0gZGF0YVtrZXldIHx8IChkYXRhW2tleV0gPSBbXSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAobmV3Q29sIHx8IFtdKS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9sZENvbC5wdXNoKG5ld0NvbFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgJ29yaWdpbmFsJzoge1xuICAgIGNvdW50OiBjb3VudFNpbXBseSxcbiAgICBnZXRJdGVtOiBnZXRJdGVtU2ltcGx5LFxuICAgIGFwcGVuZERhdGE6IGFwcGVuZERhdGFTaW1wbHlcbiAgfSxcbiAgJ3R5cGVkQXJyYXknOiB7XG4gICAgcGVyc2lzdGVudDogZmFsc2UsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBjb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgPyB0aGlzLl9kYXRhLmxlbmd0aCAvIHRoaXMuX2RpbVNpemUgOiAwO1xuICAgIH0sXG4gICAgZ2V0SXRlbTogZnVuY3Rpb24gKGlkeCwgb3V0KSB7XG4gICAgICBpZHggPSBpZHggLSB0aGlzLl9vZmZzZXQ7XG4gICAgICBvdXQgPSBvdXQgfHwgW107XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGltU2l6ZSAqIGlkeDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kaW1TaXplOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gdGhpcy5fZGF0YVtvZmZzZXQgKyBpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9LFxuICAgIGFwcGVuZERhdGE6IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gbmV3RGF0YTtcbiAgICB9LFxuICAgIC8vIENsZWFuIHNlbGYgaWYgZGF0YSBpcyBhbHJlYWR5IHVzZWQuXG4gICAgY2xlYW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIHRoaXMuX29mZnNldCArPSB0aGlzLmNvdW50KCk7XG4gICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNvdW50U2ltcGx5KCkge1xuICByZXR1cm4gdGhpcy5fZGF0YS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZW1TaW1wbHkoaWR4KSB7XG4gIHJldHVybiB0aGlzLl9kYXRhW2lkeF07XG59XG5cbmZ1bmN0aW9uIGFwcGVuZERhdGFTaW1wbHkobmV3RGF0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9kYXRhLnB1c2gobmV3RGF0YVtpXSk7XG4gIH1cbn1cblxudmFyIHJhd1ZhbHVlR2V0dGVycyA9IHtcbiAgYXJyYXlSb3dzOiBnZXRSYXdWYWx1ZVNpbXBseSxcbiAgb2JqZWN0Um93czogZnVuY3Rpb24gKGRhdGFJdGVtLCBkYXRhSW5kZXgsIGRpbUluZGV4LCBkaW1OYW1lKSB7XG4gICAgcmV0dXJuIGRpbUluZGV4ICE9IG51bGwgPyBkYXRhSXRlbVtkaW1OYW1lXSA6IGRhdGFJdGVtO1xuICB9LFxuICBrZXllZENvbHVtbnM6IGdldFJhd1ZhbHVlU2ltcGx5LFxuICBvcmlnaW5hbDogZnVuY3Rpb24gKGRhdGFJdGVtLCBkYXRhSW5kZXgsIGRpbUluZGV4LCBkaW1OYW1lKSB7XG4gICAgLy8gRklYTUVcbiAgICAvLyBJbiBzb21lIGNhc2UgKG1hcmtwb2ludCBpbiBnZW8gKGdlby1tYXAuaHRtbCkpLCBkYXRhSXRlbVxuICAgIC8vIGlzIHtjb29yZDogWy4uLl19XG4gICAgdmFyIHZhbHVlID0gZ2V0RGF0YUl0ZW1WYWx1ZShkYXRhSXRlbSk7XG4gICAgcmV0dXJuIGRpbUluZGV4ID09IG51bGwgfHwgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbHVlIDogdmFsdWVbZGltSW5kZXhdO1xuICB9LFxuICB0eXBlZEFycmF5OiBnZXRSYXdWYWx1ZVNpbXBseVxufTtcblxuZnVuY3Rpb24gZ2V0UmF3VmFsdWVTaW1wbHkoZGF0YUl0ZW0sIGRhdGFJbmRleCwgZGltSW5kZXgsIGRpbU5hbWUpIHtcbiAgcmV0dXJuIGRpbUluZGV4ICE9IG51bGwgPyBkYXRhSXRlbVtkaW1JbmRleF0gOiBkYXRhSXRlbTtcbn1cblxudmFyIGRlZmF1bHREaW1WYWx1ZUdldHRlcnMgPSB7XG4gIGFycmF5Um93czogZ2V0RGltVmFsdWVTaW1wbHksXG4gIG9iamVjdFJvd3M6IGZ1bmN0aW9uIChkYXRhSXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgIHJldHVybiBjb252ZXJEYXRhVmFsdWUoZGF0YUl0ZW1bZGltTmFtZV0sIHRoaXMuX2RpbWVuc2lvbkluZm9zW2RpbU5hbWVdKTtcbiAgfSxcbiAga2V5ZWRDb2x1bW5zOiBnZXREaW1WYWx1ZVNpbXBseSxcbiAgb3JpZ2luYWw6IGZ1bmN0aW9uIChkYXRhSXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgIC8vIFBlcmZvcm1hbmNlIHNlbnNpdGl2ZSwgZG8gbm90IHVzZSBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZS5cbiAgICAvLyBJZiBkYXRhSXRlbSBpcyBhbiBwbGFpbiBvYmplY3Qgd2l0aCBubyB2YWx1ZSBmaWVsZCwgdGhlIHZhciBgdmFsdWVgXG4gICAgLy8gd2lsbCBiZSBhc3NpZ25lZCB3aXRoIHRoZSBvYmplY3QsIGJ1dCBpdCB3aWxsIGJlIHRyZWFkIGNvcnJlY3RseVxuICAgIC8vIGluIHRoZSBgY29udmVydERhdGFWYWx1ZWAuXG4gICAgdmFyIHZhbHVlID0gZGF0YUl0ZW0gJiYgKGRhdGFJdGVtLnZhbHVlID09IG51bGwgPyBkYXRhSXRlbSA6IGRhdGFJdGVtLnZhbHVlKTsgLy8gSWYgYW55IGRhdGFJdGVtIGlzIGxpa2UgeyB2YWx1ZTogMTAgfVxuXG4gICAgaWYgKCF0aGlzLl9yYXdEYXRhLnB1cmUgJiYgaXNEYXRhSXRlbU9wdGlvbihkYXRhSXRlbSkpIHtcbiAgICAgIHRoaXMuaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlckRhdGFWYWx1ZSh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWVbZGltSW5kZXhdIC8vIElmIHZhbHVlIGlzIGEgc2luZ2xlIG51bWJlciBvciBzb21ldGhpbmcgZWxzZSBub3QgYXJyYXkuXG4gICAgOiB2YWx1ZSwgdGhpcy5fZGltZW5zaW9uSW5mb3NbZGltTmFtZV0pO1xuICB9LFxuICB0eXBlZEFycmF5OiBmdW5jdGlvbiAoZGF0YUl0ZW0sIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICByZXR1cm4gZGF0YUl0ZW1bZGltSW5kZXhdO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXREaW1WYWx1ZVNpbXBseShkYXRhSXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICByZXR1cm4gY29udmVyRGF0YVZhbHVlKGRhdGFJdGVtW2RpbUluZGV4XSwgdGhpcy5fZGltZW5zaW9uSW5mb3NbZGltTmFtZV0pO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciBtZXRob2QgY29udmVydCB2YWx1ZSBpbiBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtkaW1JbmZvXSBJZiBzdHJpbmcgKGxpa2UgJ3gnKSwgZGltVHlwZSBkZWZhdWx0cyAnbnVtYmVyJy5cbiAqICAgICAgICBJZiBcImRpbUluZm8ub3JkaW5hbFBhcnNlQW5kU2F2ZVwiLCBvcmRpbmFsIHZhbHVlIGNhbiBiZSBwYXJzZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBjb252ZXJEYXRhVmFsdWUodmFsdWUsIGRpbUluZm8pIHtcbiAgLy8gUGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICB2YXIgZGltVHlwZSA9IGRpbUluZm8gJiYgZGltSW5mby50eXBlO1xuXG4gIGlmIChkaW1UeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAvLyBJZiBnaXZlbiB2YWx1ZSBpcyBhIGNhdGVnb3J5IHN0cmluZ1xuICAgIHZhciBvcmRpbmFsTWV0YSA9IGRpbUluZm8gJiYgZGltSW5mby5vcmRpbmFsTWV0YTtcbiAgICByZXR1cm4gb3JkaW5hbE1ldGEgPyBvcmRpbmFsTWV0YS5wYXJzZUFuZENvbGxlY3QodmFsdWUpIDogdmFsdWU7XG4gIH1cblxuICBpZiAoZGltVHlwZSA9PT0gJ3RpbWUnIC8vIHNwZWFkIHVwIHdoZW4gdXNpbmcgdGltZXN0YW1wXG4gICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gJy0nKSB7XG4gICAgdmFsdWUgPSArcGFyc2VEYXRlKHZhbHVlKTtcbiAgfSAvLyBkaW1UeXBlIGRlZmF1bHRzICdudW1iZXInLlxuICAvLyBJZiBkaW1UeXBlIGlzIG5vdCBvcmRpbmFsIGFuZCB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBOYU4gb3IgJy0nLFxuICAvLyBwYXJzZSB0byBOYU4uXG5cblxuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycgPyBOYU4gLy8gSWYgc3RyaW5nIChsaWtlICctJyksIHVzaW5nICcrJyBwYXJzZSB0byBOYU5cbiAgLy8gSWYgb2JqZWN0LCBhbHNvIHBhcnNlIHRvIE5hTlxuICA6ICt2YWx1ZTtcbn0gLy8gPz8/IEZJWE1FIGNhbiB0aGVzZSBsb2dpYyBiZSBtb3JlIG5lYXQ6IGdldFJhd1ZhbHVlLCBnZXRSYXdEYXRhSXRlbSxcbi8vIENvbnNpZGVyIHBlcnNpc3RlbnQuXG4vLyBDYXV0aW9uOiB3aHkgdXNlIHJhdyB2YWx1ZSB0byBkaXNwbGF5IG9uIGxhYmVsIG9yIHRvb2x0aXA/XG4vLyBBIHJlYXNvbiBpcyB0byBhdm9pZCBmb3JtYXQuIEZvciBleGFtcGxlIHRpbWUgdmFsdWUgd2UgZG8gbm90IGtub3dcbi8vIGhvdyB0byBmb3JtYXQgaXMgZXhwZWN0ZWQuIE1vcmUgb3ZlciwgaWYgc3RhY2sgaXMgdXNlZCwgY2FsY3VsYXRlZFxuLy8gdmFsdWUgbWF5IGJlIDAuOTEwMDAwMDAwMDEsIHdoaWNoIGhhdmUgYnJpbmdzIHRyb3VibGUgdG8gZGlzcGxheS5cbi8vIFRPRE86IGNvbnNpZGVyIGhvdyB0byB0cmVhdCBudWxsL3VuZGVmaW5lZC9OYU4gd2hlbiBkaXNwbGF5P1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtkaW1dIGRpbU5hbWUgb3IgZGltSW5kZXhcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fHN0cmluZ3xudW1iZXJ9IGNhbiBiZSBudWxsL3VuZGVmaW5lZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJldHJpZXZlUmF3VmFsdWUoZGF0YSwgZGF0YUluZGV4LCBkaW0pIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENvbnNpZGVyIGRhdGEgbWF5IGJlIG5vdCBwZXJzaXN0ZW50LlxuXG5cbiAgdmFyIGRhdGFJdGVtID0gZGF0YS5nZXRSYXdEYXRhSXRlbShkYXRhSW5kZXgpO1xuXG4gIGlmIChkYXRhSXRlbSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNvdXJjZUZvcm1hdCA9IGRhdGEuZ2V0UHJvdmlkZXIoKS5nZXRTb3VyY2UoKS5zb3VyY2VGb3JtYXQ7XG4gIHZhciBkaW1OYW1lO1xuICB2YXIgZGltSW5kZXg7XG4gIHZhciBkaW1JbmZvID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbSk7XG5cbiAgaWYgKGRpbUluZm8pIHtcbiAgICBkaW1OYW1lID0gZGltSW5mby5uYW1lO1xuICAgIGRpbUluZGV4ID0gZGltSW5mby5pbmRleDtcbiAgfVxuXG4gIHJldHVybiByYXdWYWx1ZUdldHRlcnNbc291cmNlRm9ybWF0XShkYXRhSXRlbSwgZGF0YUluZGV4LCBkaW1JbmRleCwgZGltTmFtZSk7XG59XG4vKipcbiAqIENvbXBhdGlibGUgd2l0aCBzb21lIGNhc2VzIChpbiBwaWUsIG1hcCkgbGlrZTpcbiAqIGRhdGE6IFt7bmFtZTogJ3h4JywgdmFsdWU6IDUsIHNlbGVjdGVkOiB0cnVlfSwgLi4uXVxuICogd2hlcmUgb25seSBzb3VyY2VGb3JtYXQgaXMgJ29yaWdpbmFsJyBhbmQgJ29iamVjdFJvd3MnIHN1cHBvcnRlZC5cbiAqXG4gKiA/Pz8gVE9ET1xuICogU3VwcG9ydGVkIGRldGFpbCBvcHRpb25zIGluIGRhdGEgaXRlbSB3aGVuIHVzaW5nICdhcnJheVJvd3MnLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0ciBsaWtlICdzZWxlY3RlZCdcbiAqL1xuXG5cbmZ1bmN0aW9uIHJldHJpZXZlUmF3QXR0cihkYXRhLCBkYXRhSW5kZXgsIGF0dHIpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNvdXJjZUZvcm1hdCA9IGRhdGEuZ2V0UHJvdmlkZXIoKS5nZXRTb3VyY2UoKS5zb3VyY2VGb3JtYXQ7XG5cbiAgaWYgKHNvdXJjZUZvcm1hdCAhPT0gU09VUkNFX0ZPUk1BVF9PUklHSU5BTCAmJiBzb3VyY2VGb3JtYXQgIT09IFNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1MpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YUl0ZW0gPSBkYXRhLmdldFJhd0RhdGFJdGVtKGRhdGFJbmRleCk7XG5cbiAgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9PUklHSU5BTCAmJiAhaXNPYmplY3QoZGF0YUl0ZW0pKSB7XG4gICAgZGF0YUl0ZW0gPSBudWxsO1xuICB9XG5cbiAgaWYgKGRhdGFJdGVtKSB7XG4gICAgcmV0dXJuIGRhdGFJdGVtW2F0dHJdO1xuICB9XG59XG5cbmV4cG9ydHMuRGVmYXVsdERhdGFQcm92aWRlciA9IERlZmF1bHREYXRhUHJvdmlkZXI7XG5leHBvcnRzLmRlZmF1bHREaW1WYWx1ZUdldHRlcnMgPSBkZWZhdWx0RGltVmFsdWVHZXR0ZXJzO1xuZXhwb3J0cy5yZXRyaWV2ZVJhd1ZhbHVlID0gcmV0cmlldmVSYXdWYWx1ZTtcbmV4cG9ydHMucmV0cmlldmVSYXdBdHRyID0gcmV0cmlldmVSYXdBdHRyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL2RhdGFQcm92aWRlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvZGF0YVByb3ZpZGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF91dGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIGlzU3RyaW5nID0gX3V0aWwuaXNTdHJpbmc7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBOb3RlIHRoYXQgaXQgaXMgdG9vIGNvbXBsaWNhdGVkIHRvIHN1cHBvcnQgM2Qgc3RhY2sgYnkgdmFsdWVcbiAqIChoYXZlIHRvIGNyZWF0ZSB0d28tZGltZW5zaW9uIGludmVydGVkIGluZGV4KSwgc28gaW4gM2QgY2FzZVxuICogd2UganVzdCBzdXBwb3J0IHRoYXQgc3RhY2tlZCBieSBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3xPYmplY3Q+fSBkaW1lbnNpb25JbmZvTGlzdCBUaGUgc2FtZSBhcyB0aGUgaW5wdXQgb2YgPG1vZHVsZTplY2hhcnRzL2RhdGEvTGlzdD4uXG4gKiAgICAgICAgVGhlIGlucHV0IGRpbWVuc2lvbkluZm9MaXN0IHdpbGwgYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5zdGFja2VkQ29vcmREaW1lbnNpb249JyddIFNwZWNpZnkgYSBjb29yZCBkaW1lbnNpb24gaWYgbmVlZGVkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0LmJ5SW5kZXg9ZmFsc2VdXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNhbGN1bGF0aW9uSW5mb1xuICoge1xuICogICAgIHN0YWNrZWREaW1lbnNpb246IHN0cmluZ1xuICogICAgIHN0YWNrZWRCeURpbWVuc2lvbjogc3RyaW5nXG4gKiAgICAgaXNTdGFja2VkQnlJbmRleDogYm9vbGVhblxuICogICAgIHN0YWNrZWRPdmVyRGltZW5zaW9uOiBzdHJpbmdcbiAqICAgICBzdGFja1Jlc3VsdERpbWVuc2lvbjogc3RyaW5nXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZURhdGFTdGFjayhzZXJpZXNNb2RlbCwgZGltZW5zaW9uSW5mb0xpc3QsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciBieUluZGV4ID0gb3B0LmJ5SW5kZXg7XG4gIHZhciBzdGFja2VkQ29vcmREaW1lbnNpb24gPSBvcHQuc3RhY2tlZENvb3JkRGltZW5zaW9uOyAvLyBDb21wYXRpYmFsOiB3aGVuIGBzdGFja2AgaXMgc2V0IGFzICcnLCBkbyBub3Qgc3RhY2suXG5cbiAgdmFyIG1heVN0YWNrID0gISEoc2VyaWVzTW9kZWwgJiYgc2VyaWVzTW9kZWwuZ2V0KCdzdGFjaycpKTtcbiAgdmFyIHN0YWNrZWRCeURpbUluZm87XG4gIHZhciBzdGFja2VkRGltSW5mbztcbiAgdmFyIHN0YWNrUmVzdWx0RGltZW5zaW9uO1xuICB2YXIgc3RhY2tlZE92ZXJEaW1lbnNpb247XG4gIGVhY2goZGltZW5zaW9uSW5mb0xpc3QsIGZ1bmN0aW9uIChkaW1lbnNpb25JbmZvLCBpbmRleCkge1xuICAgIGlmIChpc1N0cmluZyhkaW1lbnNpb25JbmZvKSkge1xuICAgICAgZGltZW5zaW9uSW5mb0xpc3RbaW5kZXhdID0gZGltZW5zaW9uSW5mbyA9IHtcbiAgICAgICAgbmFtZTogZGltZW5zaW9uSW5mb1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAobWF5U3RhY2sgJiYgIWRpbWVuc2lvbkluZm8uaXNFeHRyYUNvb3JkKSB7XG4gICAgICAvLyBGaW5kIHRoZSBmaXJzdCBvcmRpbmFsIGRpbWVuc2lvbiBhcyB0aGUgc3RhY2tlZEJ5RGltSW5mby5cbiAgICAgIGlmICghYnlJbmRleCAmJiAhc3RhY2tlZEJ5RGltSW5mbyAmJiBkaW1lbnNpb25JbmZvLm9yZGluYWxNZXRhKSB7XG4gICAgICAgIHN0YWNrZWRCeURpbUluZm8gPSBkaW1lbnNpb25JbmZvO1xuICAgICAgfSAvLyBGaW5kIHRoZSBmaXJzdCBzdGFja2FibGUgZGltZW5zaW9uIGFzIHRoZSBzdGFja2VkRGltSW5mby5cblxuXG4gICAgICBpZiAoIXN0YWNrZWREaW1JbmZvICYmIGRpbWVuc2lvbkluZm8udHlwZSAhPT0gJ29yZGluYWwnICYmIGRpbWVuc2lvbkluZm8udHlwZSAhPT0gJ3RpbWUnICYmICghc3RhY2tlZENvb3JkRGltZW5zaW9uIHx8IHN0YWNrZWRDb29yZERpbWVuc2lvbiA9PT0gZGltZW5zaW9uSW5mby5jb29yZERpbSkpIHtcbiAgICAgICAgc3RhY2tlZERpbUluZm8gPSBkaW1lbnNpb25JbmZvO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHN0YWNrZWREaW1JbmZvICYmICFieUluZGV4ICYmICFzdGFja2VkQnlEaW1JbmZvKSB7XG4gICAgLy8gQ29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIGRlc2lnbiwgdmFsdWUgYXhpcyAodGltZSBheGlzKSBvbmx5IHN0YWNrIGJ5IGluZGV4LlxuICAgIC8vIEl0IG1heSBtYWtlIHNlbnNlIGlmIHRoZSB1c2VyIHByb3ZpZGVzIGVsYWJvcmF0ZWx5IGNvbnN0cnVjdGVkIGRhdGEuXG4gICAgYnlJbmRleCA9IHRydWU7XG4gIH0gLy8gQWRkIHN0YWNrIGRpbWVuc2lvbiwgdGhleSBjYW4gYmUgYm90aCBjYWxjdWxhdGVkIGJ5IGNvb3JkaW5hdGUgc3lzdGVtIGluIGB1bmlvbkV4dGVudGAuXG4gIC8vIFRoYXQgcHV0IHN0YWNrIGxvZ2ljIGluIExpc3QgaXMgZm9yIHVzaW5nIGNvbnZlbmllbnRseSBpbiBlY2hhcnRzIGV4dGVuc2lvbnMsIGJ1dCBpdFxuICAvLyBtaWdodCBub3QgYmUgYSBnb29kIHdheS5cblxuXG4gIGlmIChzdGFja2VkRGltSW5mbykge1xuICAgIC8vIFVzZSBhIHdlaXJkIG5hbWUgdGhhdCBub3QgZHVwbGljYXRlZCB3aXRoIG90aGVyIG5hbWVzLlxuICAgIHN0YWNrUmVzdWx0RGltZW5zaW9uID0gJ19fXFwwZWNzdGFja3Jlc3VsdCc7XG4gICAgc3RhY2tlZE92ZXJEaW1lbnNpb24gPSAnX19cXDBlY3N0YWNrZWRvdmVyJzsgLy8gQ3JlYXRlIGludmVydGVkIGluZGV4IHRvIGZhc3QgcXVlcnkgaW5kZXggYnkgdmFsdWUuXG5cbiAgICBpZiAoc3RhY2tlZEJ5RGltSW5mbykge1xuICAgICAgc3RhY2tlZEJ5RGltSW5mby5jcmVhdGVJbnZlcnRlZEluZGljZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdGFja2VkRGltQ29vcmREaW0gPSBzdGFja2VkRGltSW5mby5jb29yZERpbTtcbiAgICB2YXIgc3RhY2tlZERpbVR5cGUgPSBzdGFja2VkRGltSW5mby50eXBlO1xuICAgIHZhciBzdGFja2VkRGltQ29vcmRJbmRleCA9IDA7XG4gICAgZWFjaChkaW1lbnNpb25JbmZvTGlzdCwgZnVuY3Rpb24gKGRpbWVuc2lvbkluZm8pIHtcbiAgICAgIGlmIChkaW1lbnNpb25JbmZvLmNvb3JkRGltID09PSBzdGFja2VkRGltQ29vcmREaW0pIHtcbiAgICAgICAgc3RhY2tlZERpbUNvb3JkSW5kZXgrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkaW1lbnNpb25JbmZvTGlzdC5wdXNoKHtcbiAgICAgIG5hbWU6IHN0YWNrUmVzdWx0RGltZW5zaW9uLFxuICAgICAgY29vcmREaW06IHN0YWNrZWREaW1Db29yZERpbSxcbiAgICAgIGNvb3JkRGltSW5kZXg6IHN0YWNrZWREaW1Db29yZEluZGV4LFxuICAgICAgdHlwZTogc3RhY2tlZERpbVR5cGUsXG4gICAgICBpc0V4dHJhQ29vcmQ6IHRydWUsXG4gICAgICBpc0NhbGN1bGF0aW9uQ29vcmQ6IHRydWVcbiAgICB9KTtcbiAgICBzdGFja2VkRGltQ29vcmRJbmRleCsrO1xuICAgIGRpbWVuc2lvbkluZm9MaXN0LnB1c2goe1xuICAgICAgbmFtZTogc3RhY2tlZE92ZXJEaW1lbnNpb24sXG4gICAgICAvLyBUaGlzIGRpbWVuc2lvbiBjb250YWlucyBzdGFjayBiYXNlIChnZW5lcmFsbHksIDApLCBzbyBkbyBub3Qgc2V0IGl0IGFzXG4gICAgICAvLyBgc3RhY2tlZERpbUNvb3JkRGltYCB0byBhdm9pZCBleHRlbnQgY2FsY3VsYXRpb24sIGNvbnNpZGVyIGxvZyBzY2FsZS5cbiAgICAgIGNvb3JkRGltOiBzdGFja2VkT3ZlckRpbWVuc2lvbixcbiAgICAgIGNvb3JkRGltSW5kZXg6IHN0YWNrZWREaW1Db29yZEluZGV4LFxuICAgICAgdHlwZTogc3RhY2tlZERpbVR5cGUsXG4gICAgICBpc0V4dHJhQ29vcmQ6IHRydWUsXG4gICAgICBpc0NhbGN1bGF0aW9uQ29vcmQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhY2tlZERpbWVuc2lvbjogc3RhY2tlZERpbUluZm8gJiYgc3RhY2tlZERpbUluZm8ubmFtZSxcbiAgICBzdGFja2VkQnlEaW1lbnNpb246IHN0YWNrZWRCeURpbUluZm8gJiYgc3RhY2tlZEJ5RGltSW5mby5uYW1lLFxuICAgIGlzU3RhY2tlZEJ5SW5kZXg6IGJ5SW5kZXgsXG4gICAgc3RhY2tlZE92ZXJEaW1lbnNpb246IHN0YWNrZWRPdmVyRGltZW5zaW9uLFxuICAgIHN0YWNrUmVzdWx0RGltZW5zaW9uOiBzdGFja1Jlc3VsdERpbWVuc2lvblxuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IHN0YWNrZWREaW1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRGltZW5zaW9uU3RhY2tlZChkYXRhLCBzdGFja2VkRGltXG4vKiwgc3RhY2tlZEJ5RGltKi9cbikge1xuICAvLyBFYWNoIHNpbmdsZSBzZXJpZXMgb25seSBtYXBzIHRvIG9uZSBwYWlyIG9mIGF4aXMuIFNvIHdlIGRvIG5vdCBuZWVkIHRvXG4gIC8vIGNoZWNrIHN0YWNrQnlEaW0sIHdoYXRldmVyIHN0YWNrZWQgYnkgYSBkaW1lbnNpb24gb3Igc3RhY2tlZCBieSBpbmRleC5cbiAgcmV0dXJuICEhc3RhY2tlZERpbSAmJiBzdGFja2VkRGltID09PSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZERpbWVuc2lvbicpOyAvLyAmJiAoXG4gIC8vICAgICBzdGFja2VkQnlEaW0gIT0gbnVsbFxuICAvLyAgICAgICAgID8gc3RhY2tlZEJ5RGltID09PSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZEJ5RGltZW5zaW9uJylcbiAgLy8gICAgICAgICA6IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdpc1N0YWNrZWRCeUluZGV4JylcbiAgLy8gKTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXREaW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RhY2tlZEJ5RGltXSBJZiBub3QgaW5wdXQgdGhpcyBwYXJhbWV0ZXIsIGNoZWNrIHdoZXRoZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkIGJ5IGluZGV4LlxuICogQHJldHVybiB7c3RyaW5nfSBkaW1lbnNpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFN0YWNrZWREaW1lbnNpb24oZGF0YSwgdGFyZ2V0RGltKSB7XG4gIHJldHVybiBpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgdGFyZ2V0RGltKSA/IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja1Jlc3VsdERpbWVuc2lvbicpIDogdGFyZ2V0RGltO1xufVxuXG5leHBvcnRzLmVuYWJsZURhdGFTdGFjayA9IGVuYWJsZURhdGFTdGFjaztcbmV4cG9ydHMuaXNEaW1lbnNpb25TdGFja2VkID0gaXNEaW1lbnNpb25TdGFja2VkO1xuZXhwb3J0cy5nZXRTdGFja2VkRGltZW5zaW9uID0gZ2V0U3RhY2tlZERpbWVuc2lvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL2RhdGFTdGFja0hlbHBlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcbnZhciBjcmVhdGVIYXNoTWFwID0gX3V0aWwuY3JlYXRlSGFzaE1hcDtcbnZhciBhc3NlcnQgPSBfdXRpbC5hc3NlcnQ7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBPVEhFUl9ESU1FTlNJT05TID0gY3JlYXRlSGFzaE1hcChbJ3Rvb2x0aXAnLCAnbGFiZWwnLCAnaXRlbU5hbWUnLCAnaXRlbUlkJywgJ3Nlcmllc05hbWUnXSk7XG5cbmZ1bmN0aW9uIHN1bW1hcml6ZURpbWVuc2lvbnMoZGF0YSkge1xuICB2YXIgc3VtbWFyeSA9IHt9O1xuICB2YXIgZW5jb2RlID0gc3VtbWFyeS5lbmNvZGUgPSB7fTtcbiAgdmFyIG5vdEV4dHJhQ29vcmREaW1NYXAgPSBjcmVhdGVIYXNoTWFwKCk7XG4gIHZhciBkZWZhdWx0ZWRMYWJlbCA9IFtdO1xuICB2YXIgZGVmYXVsdGVkVG9vbHRpcCA9IFtdO1xuICBlYWNoKGRhdGEuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbU5hbWUpIHtcbiAgICB2YXIgZGltSXRlbSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1OYW1lKTtcbiAgICB2YXIgY29vcmREaW0gPSBkaW1JdGVtLmNvb3JkRGltO1xuXG4gICAgaWYgKGNvb3JkRGltKSB7XG4gICAgICB2YXIgY29vcmREaW1BcnIgPSBlbmNvZGVbY29vcmREaW1dO1xuXG4gICAgICBpZiAoIWVuY29kZS5oYXNPd25Qcm9wZXJ0eShjb29yZERpbSkpIHtcbiAgICAgICAgY29vcmREaW1BcnIgPSBlbmNvZGVbY29vcmREaW1dID0gW107XG4gICAgICB9XG5cbiAgICAgIGNvb3JkRGltQXJyW2RpbUl0ZW0uY29vcmREaW1JbmRleF0gPSBkaW1OYW1lO1xuXG4gICAgICBpZiAoIWRpbUl0ZW0uaXNFeHRyYUNvb3JkKSB7XG4gICAgICAgIG5vdEV4dHJhQ29vcmREaW1NYXAuc2V0KGNvb3JkRGltLCAxKTsgLy8gVXNlIHRoZSBsYXN0IGNvb3JkIGRpbSAoYW5kIGxhYmVsIGZyaWVuZGx5KSBhcyBkZWZhdWx0IGxhYmVsLFxuICAgICAgICAvLyBiZWNhdXNlIHdoZW4gZGF0YXNldCBpcyB1c2VkLCBpdCBpcyBoYXJkIHRvIGd1ZXNzIHdoaWNoIGRpbWVuc2lvblxuICAgICAgICAvLyBjYW4gYmUgdmFsdWUgZGltZW5zaW9uLiBJZiBib3RoIHNob3cgeCwgeSBvbiBsYWJlbCBpcyBub3QgbG9vayBnb29kLFxuICAgICAgICAvLyBhbmQgY29udmVudGlvbmFsbHkgeSBheGlzIGlzIGZvY3VzZWQgbW9yZS5cblxuICAgICAgICBpZiAobWF5TGFiZWxEaW1UeXBlKGRpbUl0ZW0udHlwZSkpIHtcbiAgICAgICAgICBkZWZhdWx0ZWRMYWJlbFswXSA9IGRpbU5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpbUl0ZW0uZGVmYXVsdFRvb2x0aXApIHtcbiAgICAgICAgZGVmYXVsdGVkVG9vbHRpcC5wdXNoKGRpbU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9USEVSX0RJTUVOU0lPTlMuZWFjaChmdW5jdGlvbiAodiwgb3RoZXJEaW0pIHtcbiAgICAgIHZhciBvdGhlckRpbUFyciA9IGVuY29kZVtvdGhlckRpbV07XG5cbiAgICAgIGlmICghZW5jb2RlLmhhc093blByb3BlcnR5KG90aGVyRGltKSkge1xuICAgICAgICBvdGhlckRpbUFyciA9IGVuY29kZVtvdGhlckRpbV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpbUluZGV4ID0gZGltSXRlbS5vdGhlckRpbXNbb3RoZXJEaW1dO1xuXG4gICAgICBpZiAoZGltSW5kZXggIT0gbnVsbCAmJiBkaW1JbmRleCAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3RoZXJEaW1BcnJbZGltSW5kZXhdID0gZGltSXRlbS5uYW1lO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgdmFyIGRhdGFEaW1zT25Db29yZCA9IFtdO1xuICB2YXIgZW5jb2RlRmlyc3REaW1Ob3RFeHRyYSA9IHt9O1xuICBub3RFeHRyYUNvb3JkRGltTWFwLmVhY2goZnVuY3Rpb24gKHYsIGNvb3JkRGltKSB7XG4gICAgdmFyIGRpbUFyciA9IGVuY29kZVtjb29yZERpbV07IC8vID8/PyBGSVhNRSBleHRyYSBjb29yZCBzaG91bGQgbm90IGJlIHNldCBpbiBkYXRhRGltc09uQ29vcmQuXG4gICAgLy8gQnV0IHNob3VsZCBmaXggdGhlIGNhc2UgdGhhdCByYWRhciBheGVzOiBzaW1wbGlmeSB0aGUgbG9naWNcbiAgICAvLyBvZiBgY29tcGxldGVEaW1lbnNpb25gLCByZW1vdmUgYGV4dHJhUHJlZml4YC5cblxuICAgIGVuY29kZUZpcnN0RGltTm90RXh0cmFbY29vcmREaW1dID0gZGltQXJyWzBdOyAvLyBOb3QgbmVjZXNzYXJ5IHRvIHJlbW92ZSBkdXBsaWNhdGUsIGJlY2F1c2UgYSBkYXRhXG4gICAgLy8gZGltIGNhbm90IG9uIG1vcmUgdGhhbiBvbmUgY29vcmREaW0uXG5cbiAgICBkYXRhRGltc09uQ29vcmQgPSBkYXRhRGltc09uQ29vcmQuY29uY2F0KGRpbUFycik7XG4gIH0pO1xuICBzdW1tYXJ5LmRhdGFEaW1zT25Db29yZCA9IGRhdGFEaW1zT25Db29yZDtcbiAgc3VtbWFyeS5lbmNvZGVGaXJzdERpbU5vdEV4dHJhID0gZW5jb2RlRmlyc3REaW1Ob3RFeHRyYTtcbiAgdmFyIGVuY29kZUxhYmVsID0gZW5jb2RlLmxhYmVsOyAvLyBGSVhNRSBgZW5jb2RlLmxhYmVsYCBpcyBub3QgcmVjb21tYW5kZWQsIGJlY2F1c2UgZm9ybWF0dGVyIGNhbiBub3QgYmUgc2V0XG4gIC8vIGluIHRoaXMgd2F5LiBVc2UgbGFiZWwuZm9ybWF0dGVyIGluc3RlYWQuIE1heSBiZSByZW1vdmUgdGhpcyBhcHByb2FjaCBzb21lZGF5LlxuXG4gIGlmIChlbmNvZGVMYWJlbCAmJiBlbmNvZGVMYWJlbC5sZW5ndGgpIHtcbiAgICBkZWZhdWx0ZWRMYWJlbCA9IGVuY29kZUxhYmVsLnNsaWNlKCk7XG4gIH1cblxuICB2YXIgZW5jb2RlVG9vbHRpcCA9IGVuY29kZS50b29sdGlwO1xuXG4gIGlmIChlbmNvZGVUb29sdGlwICYmIGVuY29kZVRvb2x0aXAubGVuZ3RoKSB7XG4gICAgZGVmYXVsdGVkVG9vbHRpcCA9IGVuY29kZVRvb2x0aXAuc2xpY2UoKTtcbiAgfSBlbHNlIGlmICghZGVmYXVsdGVkVG9vbHRpcC5sZW5ndGgpIHtcbiAgICBkZWZhdWx0ZWRUb29sdGlwID0gZGVmYXVsdGVkTGFiZWwuc2xpY2UoKTtcbiAgfVxuXG4gIGVuY29kZS5kZWZhdWx0ZWRMYWJlbCA9IGRlZmF1bHRlZExhYmVsO1xuICBlbmNvZGUuZGVmYXVsdGVkVG9vbHRpcCA9IGRlZmF1bHRlZFRvb2x0aXA7XG4gIHJldHVybiBzdW1tYXJ5O1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25UeXBlQnlBeGlzKGF4aXNUeXBlKSB7XG4gIHJldHVybiBheGlzVHlwZSA9PT0gJ2NhdGVnb3J5JyA/ICdvcmRpbmFsJyA6IGF4aXNUeXBlID09PSAndGltZScgPyAndGltZScgOiAnZmxvYXQnO1xufVxuXG5mdW5jdGlvbiBtYXlMYWJlbERpbVR5cGUoZGltVHlwZSkge1xuICAvLyBJbiBtb3N0IGNhc2VzLCBvcmRpbmFsIGFuZCB0aW1lIGRvIG5vdCBzdWl0YWJsZSBmb3IgbGFiZWwuXG4gIC8vIE9yZGluYWwgaW5mbyBjYW4gYmUgZGlzcGxheWVkIG9uIGF4aXMuIFRpbWUgaXMgdG9vIGxvbmcuXG4gIHJldHVybiAhKGRpbVR5cGUgPT09ICdvcmRpbmFsJyB8fCBkaW1UeXBlID09PSAndGltZScpO1xufSAvLyBmdW5jdGlvbiBmaW5kVGhlTGFzdERpbU1heUxhYmVsKGRhdGEpIHtcbi8vICAgICAvLyBHZXQgbGFzdCB2YWx1ZSBkaW1cbi8vICAgICB2YXIgZGltZW5zaW9ucyA9IGRhdGEuZGltZW5zaW9ucy5zbGljZSgpO1xuLy8gICAgIHZhciB2YWx1ZVR5cGU7XG4vLyAgICAgdmFyIHZhbHVlRGltO1xuLy8gICAgIHdoaWxlIChkaW1lbnNpb25zLmxlbmd0aCAmJiAoXG4vLyAgICAgICAgIHZhbHVlRGltID0gZGltZW5zaW9ucy5wb3AoKSxcbi8vICAgICAgICAgdmFsdWVUeXBlID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKHZhbHVlRGltKS50eXBlLFxuLy8gICAgICAgICB2YWx1ZVR5cGUgPT09ICdvcmRpbmFsJyB8fCB2YWx1ZVR5cGUgPT09ICd0aW1lJ1xuLy8gICAgICkpIHt9IC8vIGpzaGludCBpZ25vcmU6bGluZVxuLy8gICAgIHJldHVybiB2YWx1ZURpbTtcbi8vIH1cblxuXG5leHBvcnRzLk9USEVSX0RJTUVOU0lPTlMgPSBPVEhFUl9ESU1FTlNJT05TO1xuZXhwb3J0cy5zdW1tYXJpemVEaW1lbnNpb25zID0gc3VtbWFyaXplRGltZW5zaW9ucztcbmV4cG9ydHMuZ2V0RGltZW5zaW9uVHlwZUJ5QXhpcyA9IGdldERpbWVuc2lvblR5cGVCeUF4aXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvZGltZW5zaW9uSGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9kaW1lbnNpb25IZWxwZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgX21vZGVsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBtYWtlSW5uZXIgPSBfbW9kZWwubWFrZUlubmVyO1xudmFyIGdldERhdGFJdGVtVmFsdWUgPSBfbW9kZWwuZ2V0RGF0YUl0ZW1WYWx1ZTtcblxudmFyIF9yZWZlckhlbHBlciA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9yZWZlckhlbHBlclwiKTtcblxudmFyIGdldENvb3JkU3lzRGVmaW5lQnlTZXJpZXMgPSBfcmVmZXJIZWxwZXIuZ2V0Q29vcmRTeXNEZWZpbmVCeVNlcmllcztcblxudmFyIF91dGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGNyZWF0ZUhhc2hNYXAgPSBfdXRpbC5jcmVhdGVIYXNoTWFwO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIG1hcCA9IF91dGlsLm1hcDtcbnZhciBpc0FycmF5ID0gX3V0aWwuaXNBcnJheTtcbnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nO1xudmFyIGlzT2JqZWN0ID0gX3V0aWwuaXNPYmplY3Q7XG52YXIgaXNUeXBlZEFycmF5ID0gX3V0aWwuaXNUeXBlZEFycmF5O1xudmFyIGlzQXJyYXlMaWtlID0gX3V0aWwuaXNBcnJheUxpa2U7XG52YXIgZXh0ZW5kID0gX3V0aWwuZXh0ZW5kO1xudmFyIGFzc2VydCA9IF91dGlsLmFzc2VydDtcblxudmFyIFNvdXJjZSA9IHJlcXVpcmUoXCIuLi9Tb3VyY2VcIik7XG5cbnZhciBfc291cmNlVHlwZSA9IHJlcXVpcmUoXCIuL3NvdXJjZVR5cGVcIik7XG5cbnZhciBTT1VSQ0VfRk9STUFUX09SSUdJTkFMID0gX3NvdXJjZVR5cGUuU09VUkNFX0ZPUk1BVF9PUklHSU5BTDtcbnZhciBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MgPSBfc291cmNlVHlwZS5TT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1M7XG52YXIgU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUyA9IF9zb3VyY2VUeXBlLlNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1M7XG52YXIgU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TID0gX3NvdXJjZVR5cGUuU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TO1xudmFyIFNPVVJDRV9GT1JNQVRfVU5LTk9XTiA9IF9zb3VyY2VUeXBlLlNPVVJDRV9GT1JNQVRfVU5LTk9XTjtcbnZhciBTT1VSQ0VfRk9STUFUX1RZUEVEX0FSUkFZID0gX3NvdXJjZVR5cGUuU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWTtcbnZhciBTRVJJRVNfTEFZT1VUX0JZX1JPVyA9IF9zb3VyY2VUeXBlLlNFUklFU19MQVlPVVRfQllfUk9XO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbi8qKlxuICogQHNlZSB7bW9kdWxlOmVjaGFydHMvZGF0YS9Tb3VyY2V9XG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9kYXRhc2V0L0RhdGFzZXRNb2RlbH0gZGF0YXNldE1vZGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHNvdXJjZUZvcm1hdFxuICovXG5cbmZ1bmN0aW9uIGRldGVjdFNvdXJjZUZvcm1hdChkYXRhc2V0TW9kZWwpIHtcbiAgdmFyIGRhdGEgPSBkYXRhc2V0TW9kZWwub3B0aW9uLnNvdXJjZTtcbiAgdmFyIHNvdXJjZUZvcm1hdCA9IFNPVVJDRV9GT1JNQVRfVU5LTk9XTjtcblxuICBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgc291cmNlRm9ybWF0ID0gU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgLy8gRklYTUUgV2hldGhlciB0b2xlcmF0ZSBudWxsIGluIHRvcCBsZXZlbCBhcnJheT9cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2ldO1xuXG4gICAgICBpZiAoaXRlbSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIHNvdXJjZUZvcm1hdCA9IFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIHNvdXJjZUZvcm1hdCA9IFNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGlzQXJyYXlMaWtlKGRhdGFba2V5XSkpIHtcbiAgICAgICAgc291cmNlRm9ybWF0ID0gU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEnKTtcbiAgfVxuXG4gIGlubmVyKGRhdGFzZXRNb2RlbCkuc291cmNlRm9ybWF0ID0gc291cmNlRm9ybWF0O1xufVxuLyoqXG4gKiBbU2NlbmFyaW9zXTpcbiAqICgxKSBQcm92aWRlIHNvdXJjZSBkYXRhIGRpcmVjdGx5OlxuICogICAgIHNlcmllczoge1xuICogICAgICAgICBlbmNvZGU6IHsuLi59LFxuICogICAgICAgICBkaW1lbnNpb25zOiBbLi4uXVxuICogICAgICAgICBzZXJpZXNMYXlvdXRCeTogJ3JvdycsXG4gKiAgICAgICAgIGRhdGE6IFtbLi4uXV1cbiAqICAgICB9XG4gKiAoMikgUmVmZXIgdG8gZGF0YXNldE1vZGVsLlxuICogICAgIHNlcmllczogW3tcbiAqICAgICAgICAgZW5jb2RlOiB7Li4ufVxuICogICAgICAgICAvLyBJZ25vcmUgZGF0YXNldEluZGV4IG1lYW5zIGBkYXRhc2V0SW5kZXg6IDBgXG4gKiAgICAgICAgIC8vIGFuZCB0aGUgZGltZW5zaW9ucyBkZWZpbmF0aW9uIGluIGRhdGFzZXQgaXMgdXNlZFxuICogICAgIH0sIHtcbiAqICAgICAgICAgZW5jb2RlOiB7Li4ufSxcbiAqICAgICAgICAgc2VyaWVzTGF5b3V0Qnk6ICdjb2x1bW4nLFxuICogICAgICAgICBkYXRhc2V0SW5kZXg6IDFcbiAqICAgICB9XVxuICpcbiAqIEdldCBkYXRhIGZyb20gc2VyaWVzIGl0c2VsZiBvciBkYXRzZXQuXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL1NvdXJjZX0gc291cmNlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTb3VyY2Uoc2VyaWVzTW9kZWwpIHtcbiAgcmV0dXJuIGlubmVyKHNlcmllc01vZGVsKS5zb3VyY2U7XG59XG4vKipcbiAqIE1VU1QgYmUgY2FsbGVkIGJlZm9yZSBtZXJnZU9wdGlvbiBvZiBhbGwgc2VyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc2V0U291cmNlRGVmYXVsdGVyKGVjTW9kZWwpIHtcbiAgLy8gYGRhdGFzZXRNYXBgIGlzIHVzZWQgdG8gbWFrZSBkZWZhdWx0IGVuY29kZS5cbiAgaW5uZXIoZWNNb2RlbCkuZGF0YXNldE1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbn1cbi8qKlxuICogW0NhdXRpb25dOlxuICogTVVTVCBiZSBjYWxsZWQgYWZ0ZXIgc2VyaWVzIG9wdGlvbiBtZXJnZWQgYW5kXG4gKiBiZWZvcmUgXCJzZXJpZXMuZ2V0SW5pdGFpbERhdGEoKVwiIGNhbGxlZC5cbiAqXG4gKiBbVGhlIHJ1bGUgb2YgbWFraW5nIGRlZmF1bHQgZW5jb2RlXTpcbiAqIENhdGVnb3J5IGF4aXMgKGlmIGV4aXN0cykgYWx3YXkgbWFwIHRvIHRoZSBmaXJzdCBkaW1lbnNpb24uXG4gKiBFYWNoIG90aGVyIGF4aXMgb2NjdXBpZXMgYSBzdWJzZXF1ZW50IGRpbWVuc2lvbi5cbiAqXG4gKiBbV2h5IG1ha2UgZGVmYXVsdCBlbmNvZGVdOlxuICogU2ltcGxpZnkgdGhlIHR5cGluZyBvZiBlbmNvZGUgaW4gb3B0aW9uLCBhdm9pZGluZyB0aGUgY2FzZSBsaWtlIHRoYXQ6XG4gKiBzZXJpZXM6IFt7ZW5jb2RlOiB7eDogMCwgeTogMX19LCB7ZW5jb2RlOiB7eDogMCwgeTogMn19LCB7ZW5jb2RlOiB7eDogMCwgeTogM319XSxcbiAqIHdoZXJlIHRoZSBcInlcIiBoYXZlIHRvIGJlIG1hbnVhbGx5IHR5cGVkIGFzIFwiMSwgMiwgMywgLi4uXCIuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlU291cmNlKHNlcmllc01vZGVsKSB7XG4gIHZhciBzZXJpZXNPcHRpb24gPSBzZXJpZXNNb2RlbC5vcHRpb247XG4gIHZhciBkYXRhID0gc2VyaWVzT3B0aW9uLmRhdGE7XG4gIHZhciBzb3VyY2VGb3JtYXQgPSBpc1R5cGVkQXJyYXkoZGF0YSkgPyBTT1VSQ0VfRk9STUFUX1RZUEVEX0FSUkFZIDogU09VUkNFX0ZPUk1BVF9PUklHSU5BTDtcbiAgdmFyIGZyb21EYXRhc2V0ID0gZmFsc2U7XG4gIHZhciBzZXJpZXNMYXlvdXRCeSA9IHNlcmllc09wdGlvbi5zZXJpZXNMYXlvdXRCeTtcbiAgdmFyIHNvdXJjZUhlYWRlciA9IHNlcmllc09wdGlvbi5zb3VyY2VIZWFkZXI7XG4gIHZhciBkaW1lbnNpb25zRGVmaW5lID0gc2VyaWVzT3B0aW9uLmRpbWVuc2lvbnM7XG4gIHZhciBkYXRhc2V0TW9kZWwgPSBnZXREYXRhc2V0TW9kZWwoc2VyaWVzTW9kZWwpO1xuXG4gIGlmIChkYXRhc2V0TW9kZWwpIHtcbiAgICB2YXIgZGF0YXNldE9wdGlvbiA9IGRhdGFzZXRNb2RlbC5vcHRpb247XG4gICAgZGF0YSA9IGRhdGFzZXRPcHRpb24uc291cmNlO1xuICAgIHNvdXJjZUZvcm1hdCA9IGlubmVyKGRhdGFzZXRNb2RlbCkuc291cmNlRm9ybWF0O1xuICAgIGZyb21EYXRhc2V0ID0gdHJ1ZTsgLy8gVGhlc2Ugc2V0dGluZ3MgZnJvbSBzZXJpZXMgaGFzIGhpZ2hlciBwcmlvcml0eS5cblxuICAgIHNlcmllc0xheW91dEJ5ID0gc2VyaWVzTGF5b3V0QnkgfHwgZGF0YXNldE9wdGlvbi5zZXJpZXNMYXlvdXRCeTtcbiAgICBzb3VyY2VIZWFkZXIgPT0gbnVsbCAmJiAoc291cmNlSGVhZGVyID0gZGF0YXNldE9wdGlvbi5zb3VyY2VIZWFkZXIpO1xuICAgIGRpbWVuc2lvbnNEZWZpbmUgPSBkaW1lbnNpb25zRGVmaW5lIHx8IGRhdGFzZXRPcHRpb24uZGltZW5zaW9ucztcbiAgfVxuXG4gIHZhciBjb21wbGV0ZVJlc3VsdCA9IGNvbXBsZXRlQnlTb3VyY2VEYXRhKGRhdGEsIHNvdXJjZUZvcm1hdCwgc2VyaWVzTGF5b3V0QnksIHNvdXJjZUhlYWRlciwgZGltZW5zaW9uc0RlZmluZSk7IC8vIE5vdGU6IGRhdGFzZXQgb3B0aW9uIGRvZXMgbm90IGhhdmUgYGVuY29kZWAuXG5cbiAgdmFyIGVuY29kZURlZmluZSA9IHNlcmllc09wdGlvbi5lbmNvZGU7XG5cbiAgaWYgKCFlbmNvZGVEZWZpbmUgJiYgZGF0YXNldE1vZGVsKSB7XG4gICAgZW5jb2RlRGVmaW5lID0gbWFrZURlZmF1bHRFbmNvZGUoc2VyaWVzTW9kZWwsIGRhdGFzZXRNb2RlbCwgZGF0YSwgc291cmNlRm9ybWF0LCBzZXJpZXNMYXlvdXRCeSwgY29tcGxldGVSZXN1bHQpO1xuICB9XG5cbiAgaW5uZXIoc2VyaWVzTW9kZWwpLnNvdXJjZSA9IG5ldyBTb3VyY2Uoe1xuICAgIGRhdGE6IGRhdGEsXG4gICAgZnJvbURhdGFzZXQ6IGZyb21EYXRhc2V0LFxuICAgIHNlcmllc0xheW91dEJ5OiBzZXJpZXNMYXlvdXRCeSxcbiAgICBzb3VyY2VGb3JtYXQ6IHNvdXJjZUZvcm1hdCxcbiAgICBkaW1lbnNpb25zRGVmaW5lOiBjb21wbGV0ZVJlc3VsdC5kaW1lbnNpb25zRGVmaW5lLFxuICAgIHN0YXJ0SW5kZXg6IGNvbXBsZXRlUmVzdWx0LnN0YXJ0SW5kZXgsXG4gICAgZGltZW5zaW9uc0RldGVjdENvdW50OiBjb21wbGV0ZVJlc3VsdC5kaW1lbnNpb25zRGV0ZWN0Q291bnQsXG4gICAgZW5jb2RlRGVmaW5lOiBlbmNvZGVEZWZpbmVcbiAgfSk7XG59IC8vIHJldHVybiB7c3RhcnRJbmRleCwgZGltZW5zaW9uc0RlZmluZSwgZGltZW5zaW9uc0NvdW50fVxuXG5cbmZ1bmN0aW9uIGNvbXBsZXRlQnlTb3VyY2VEYXRhKGRhdGEsIHNvdXJjZUZvcm1hdCwgc2VyaWVzTGF5b3V0QnksIHNvdXJjZUhlYWRlciwgZGltZW5zaW9uc0RlZmluZSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGltZW5zaW9uc0RlZmluZTogbm9ybWFsaXplRGltZW5zaW9uc0RlZmluZShkaW1lbnNpb25zRGVmaW5lKVxuICAgIH07XG4gIH1cblxuICB2YXIgZGltZW5zaW9uc0RldGVjdENvdW50O1xuICB2YXIgc3RhcnRJbmRleDtcbiAgdmFyIGZpbmRQb3RlbnRpYWxOYW1lO1xuXG4gIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUykge1xuICAgIC8vIFJ1bGU6IE1vc3Qgb2YgdGhlIGZpcnN0IGxpbmUgYXJlIHN0cmluZzogaXQgaXMgaGVhZGVyLlxuICAgIC8vIENhdXRpb246IGNvbnNpZGVyIGEgbGluZSB3aXRoIDUgc3RyaW5nIGFuZCAxIG51bWJlcixcbiAgICAvLyBpdCBzdGlsbCBjYW4gbm90IGJlIHN1cmUgaXQgaXMgYSBoZWFkLCBiZWNhdXNlIHRoZVxuICAgIC8vIDUgc3RyaW5nIG1heSBiZSA1IHZhbHVlcyBvZiBjYXRlZ29yeSBjb2x1bW5zLlxuICAgIGlmIChzb3VyY2VIZWFkZXIgPT09ICdhdXRvJyB8fCBzb3VyY2VIZWFkZXIgPT0gbnVsbCkge1xuICAgICAgYXJyYXlSb3dzVHJhdmVsRmlyc3QoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAvLyAnLScgaXMgcmVnYXJkZWQgYXMgbnVsbC91bmRlZmluZWQuXG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwgIT09ICctJykge1xuICAgICAgICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID09IG51bGwgJiYgKHN0YXJ0SW5kZXggPSAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIDEwIGlzIGFuIGV4cGVyaWVuY2UgbnVtYmVyLCBhdm9pZCBsb25nIGxvb3AuXG5cbiAgICAgIH0sIHNlcmllc0xheW91dEJ5LCBkYXRhLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5kZXggPSBzb3VyY2VIZWFkZXIgPyAxIDogMDtcbiAgICB9XG5cbiAgICBpZiAoIWRpbWVuc2lvbnNEZWZpbmUgJiYgc3RhcnRJbmRleCA9PT0gMSkge1xuICAgICAgZGltZW5zaW9uc0RlZmluZSA9IFtdO1xuICAgICAgYXJyYXlSb3dzVHJhdmVsRmlyc3QoZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICAgICAgZGltZW5zaW9uc0RlZmluZVtpbmRleF0gPSB2YWwgIT0gbnVsbCA/IHZhbCA6ICcnO1xuICAgICAgfSwgc2VyaWVzTGF5b3V0QnksIGRhdGEpO1xuICAgIH1cblxuICAgIGRpbWVuc2lvbnNEZXRlY3RDb3VudCA9IGRpbWVuc2lvbnNEZWZpbmUgPyBkaW1lbnNpb25zRGVmaW5lLmxlbmd0aCA6IHNlcmllc0xheW91dEJ5ID09PSBTRVJJRVNfTEFZT1VUX0JZX1JPVyA/IGRhdGEubGVuZ3RoIDogZGF0YVswXSA/IGRhdGFbMF0ubGVuZ3RoIDogbnVsbDtcbiAgfSBlbHNlIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1MpIHtcbiAgICBpZiAoIWRpbWVuc2lvbnNEZWZpbmUpIHtcbiAgICAgIGRpbWVuc2lvbnNEZWZpbmUgPSBvYmplY3RSb3dzQ29sbGVjdERpbWVuc2lvbnMoZGF0YSk7XG4gICAgICBmaW5kUG90ZW50aWFsTmFtZSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TKSB7XG4gICAgaWYgKCFkaW1lbnNpb25zRGVmaW5lKSB7XG4gICAgICBkaW1lbnNpb25zRGVmaW5lID0gW107XG4gICAgICBmaW5kUG90ZW50aWFsTmFtZSA9IHRydWU7XG4gICAgICBlYWNoKGRhdGEsIGZ1bmN0aW9uIChjb2xBcnIsIGtleSkge1xuICAgICAgICBkaW1lbnNpb25zRGVmaW5lLnB1c2goa2V5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT1JJR0lOQUwpIHtcbiAgICB2YXIgdmFsdWUwID0gZ2V0RGF0YUl0ZW1WYWx1ZShkYXRhWzBdKTtcbiAgICBkaW1lbnNpb25zRGV0ZWN0Q291bnQgPSBpc0FycmF5KHZhbHVlMCkgJiYgdmFsdWUwLmxlbmd0aCB8fCAxO1xuICB9IGVsc2UgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWSkge31cblxuICB2YXIgcG90ZW50aWFsTmFtZURpbUluZGV4O1xuXG4gIGlmIChmaW5kUG90ZW50aWFsTmFtZSkge1xuICAgIGVhY2goZGltZW5zaW9uc0RlZmluZSwgZnVuY3Rpb24gKGRpbSwgaWR4KSB7XG4gICAgICBpZiAoKGlzT2JqZWN0KGRpbSkgPyBkaW0ubmFtZSA6IGRpbSkgPT09ICduYW1lJykge1xuICAgICAgICBwb3RlbnRpYWxOYW1lRGltSW5kZXggPSBpZHg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgZGltZW5zaW9uc0RlZmluZTogbm9ybWFsaXplRGltZW5zaW9uc0RlZmluZShkaW1lbnNpb25zRGVmaW5lKSxcbiAgICBkaW1lbnNpb25zRGV0ZWN0Q291bnQ6IGRpbWVuc2lvbnNEZXRlY3RDb3VudCxcbiAgICBwb3RlbnRpYWxOYW1lRGltSW5kZXg6IHBvdGVudGlhbE5hbWVEaW1JbmRleCAvLyBUT0RPOiBwb3RlbnRpYWxJZERpbUlkeFxuXG4gIH07XG59IC8vIENvbnNpZGVyIGRpbWVuc2lvbnMgZGVmaW5lZCBsaWtlIFsnQScsICdwcmljZScsICdCJywgJ3ByaWNlJywgJ0MnLCAncHJpY2UnXSxcbi8vIHdoaWNoIGlzIHJlYXNvbmFibGUuIEJ1dCBkaW1lbnNpb24gbmFtZSBpcyBkdXBsaWNhdGVkLlxuLy8gUmV0dXJucyB1bmRlZmluZWQgb3IgYW4gYXJyYXkgY29udGFpbnMgb25seSBvYmplY3Qgd2l0aG91dCBudWxsL3VuZGVmaWVuZCBvciBzdHJpbmcuXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplRGltZW5zaW9uc0RlZmluZShkaW1lbnNpb25zRGVmaW5lKSB7XG4gIGlmICghZGltZW5zaW9uc0RlZmluZSkge1xuICAgIC8vIFRoZSBtZWFuaW5nIG9mIG51bGwvdW5kZWZpbmVkIGlzIGRpZmZlcmVudCBmcm9tIGVtcHR5IGFycmF5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuYW1lTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICByZXR1cm4gbWFwKGRpbWVuc2lvbnNEZWZpbmUsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIGl0ZW0gPSBleHRlbmQoe30sIGlzT2JqZWN0KGl0ZW0pID8gaXRlbSA6IHtcbiAgICAgIG5hbWU6IGl0ZW1cbiAgICB9KTsgLy8gVXNlciBjYW4gc2V0IG51bGwgaW4gZGltZW5zaW9ucy5cbiAgICAvLyBXZSBkb250IGF1dG8gc3BlY2lmeSBuYW1lLCBvdGhld2lzZSBhIGdpdmVuIG5hbWUgbWF5XG4gICAgLy8gY2F1c2UgaXQgYmUgcmVmZXJlZCB1bmV4cGVjdGVkbHkuXG5cbiAgICBpZiAoaXRlbS5uYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0gLy8gQWxzbyBjb25zaWRlciBudW1iZXIgZm9ybSBsaWtlIDIwMTIuXG5cblxuICAgIGl0ZW0ubmFtZSArPSAnJzsgLy8gVXNlciBtYXkgYWxzbyBzcGVjaWZ5IGRpc3BsYXlOYW1lLlxuICAgIC8vIGRpc3BsYXlOYW1lIHdpbGwgYWx3YXlzIGV4aXN0cyBleGNlcHQgdXNlciBub3RcbiAgICAvLyBzcGVjaWZpZWQgb3IgZGltIG5hbWUgaXMgbm90IHNwZWNpZmllZCBvciBkZXRlY3RlZC5cbiAgICAvLyAoQSBhdXRvIGdlbmVyYXRlZCBkaW0gbmFtZSB3aWxsIG5vdCBiZSB1c2VkIGFzXG4gICAgLy8gZGlzcGxheU5hbWUpLlxuXG4gICAgaWYgKGl0ZW0uZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgaXRlbS5kaXNwbGF5TmFtZSA9IGl0ZW0ubmFtZTtcbiAgICB9XG5cbiAgICB2YXIgZXhpc3QgPSBuYW1lTWFwLmdldChpdGVtLm5hbWUpO1xuXG4gICAgaWYgKCFleGlzdCkge1xuICAgICAgbmFtZU1hcC5zZXQoaXRlbS5uYW1lLCB7XG4gICAgICAgIGNvdW50OiAxXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbS5uYW1lICs9ICctJyArIGV4aXN0LmNvdW50Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhcnJheVJvd3NUcmF2ZWxGaXJzdChjYiwgc2VyaWVzTGF5b3V0QnksIGRhdGEsIG1heExvb3ApIHtcbiAgbWF4TG9vcCA9PSBudWxsICYmIChtYXhMb29wID0gSW5maW5pdHkpO1xuXG4gIGlmIChzZXJpZXNMYXlvdXRCeSA9PT0gU0VSSUVTX0xBWU9VVF9CWV9ST1cpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoICYmIGkgPCBtYXhMb29wOyBpKyspIHtcbiAgICAgIGNiKGRhdGFbaV0gPyBkYXRhW2ldWzBdIDogbnVsbCwgaSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB2YWx1ZTAgPSBkYXRhWzBdIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZTAubGVuZ3RoICYmIGkgPCBtYXhMb29wOyBpKyspIHtcbiAgICAgIGNiKHZhbHVlMFtpXSwgaSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9iamVjdFJvd3NDb2xsZWN0RGltZW5zaW9ucyhkYXRhKSB7XG4gIHZhciBmaXJzdEluZGV4ID0gMDtcbiAgdmFyIG9iajtcblxuICB3aGlsZSAoZmlyc3RJbmRleCA8IGRhdGEubGVuZ3RoICYmICEob2JqID0gZGF0YVtmaXJzdEluZGV4KytdKSkge30gLy8ganNoaW50IGlnbm9yZTogbGluZVxuXG5cbiAgaWYgKG9iaikge1xuICAgIHZhciBkaW1lbnNpb25zID0gW107XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBkaW1lbnNpb25zLnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgfVxufSAvLyA/Pz8gVE9ETyBtZXJnZSB0byBjb21wbGV0ZWRpbWVuc2lvbnMsIHdoZXJlIGFsc28gaGFzXG4vLyBkZWZhdWx0IGVuY29kZSBtYWtpbmcgbG9naWMuIEFuZCB0aGUgZGVmYXVsdCBydWxlXG4vLyBzaG91bGQgZGVwZW5kcyBvbiBzZXJpZXM/IGNvbnNpZGVyICdtYXAnLlxuXG5cbmZ1bmN0aW9uIG1ha2VEZWZhdWx0RW5jb2RlKHNlcmllc01vZGVsLCBkYXRhc2V0TW9kZWwsIGRhdGEsIHNvdXJjZUZvcm1hdCwgc2VyaWVzTGF5b3V0QnksIGNvbXBsZXRlUmVzdWx0KSB7XG4gIHZhciBjb29yZFN5c0RlZmluZSA9IGdldENvb3JkU3lzRGVmaW5lQnlTZXJpZXMoc2VyaWVzTW9kZWwpO1xuICB2YXIgZW5jb2RlID0ge307IC8vIHZhciBlbmNvZGVUb29sdGlwID0gW107XG4gIC8vIHZhciBlbmNvZGVMYWJlbCA9IFtdO1xuXG4gIHZhciBlbmNvZGVJdGVtTmFtZSA9IFtdO1xuICB2YXIgZW5jb2RlU2VyaWVzTmFtZSA9IFtdO1xuICB2YXIgc2VyaWVzVHlwZSA9IHNlcmllc01vZGVsLnN1YlR5cGU7IC8vID8/PyBUT0RPIHJlZmFjdG9yOiBwcm92aWRlIGJ5IHNlcmllcyBpdHNlbGYuXG4gIC8vIENvbnNpZGVyIHRoZSBjYXNlOiAnbWFwJyBzZXJpZXMgaXMgYmFzZWQgb24gZ2VvIGNvb3JkU3lzLFxuICAvLyAnZ3JhcGgnLCAnaGVhdG1hcCcgY2FuIGJlIGJhc2VkIG9uIGNhcnRlc2lhbi4gQnV0IGNhbiBub3RcbiAgLy8gZ2l2ZSBkZWZhdWx0IHJ1bGUgc2ltcGx5IGhlcmUuXG5cbiAgdmFyIG5TZXJpZXNNYXAgPSBjcmVhdGVIYXNoTWFwKFsncGllJywgJ21hcCcsICdmdW5uZWwnXSk7XG4gIHZhciBjU2VyaWVzTWFwID0gY3JlYXRlSGFzaE1hcChbJ2xpbmUnLCAnYmFyJywgJ3BpY3RvcmlhbEJhcicsICdzY2F0dGVyJywgJ2VmZmVjdFNjYXR0ZXInLCAnY2FuZGxlc3RpY2snLCAnYm94cGxvdCddKTsgLy8gVXN1YWxseSBpbiB0aGlzIGNhc2Ugc2VyaWVzIHdpbGwgdXNlIHRoZSBmaXJzdCBkYXRhXG4gIC8vIGRpbWVuc2lvbiBhcyB0aGUgXCJ2YWx1ZVwiIGRpbWVuc2lvbiwgb3Igb3RoZXIgZGVmYXVsdFxuICAvLyBwcm9jZXNzZXMgcmVzcGVjdGl2ZWx5LlxuXG4gIGlmIChjb29yZFN5c0RlZmluZSAmJiBjU2VyaWVzTWFwLmdldChzZXJpZXNUeXBlKSAhPSBudWxsKSB7XG4gICAgdmFyIGVjTW9kZWwgPSBzZXJpZXNNb2RlbC5lY01vZGVsO1xuICAgIHZhciBkYXRhc2V0TWFwID0gaW5uZXIoZWNNb2RlbCkuZGF0YXNldE1hcDtcbiAgICB2YXIga2V5ID0gZGF0YXNldE1vZGVsLnVpZCArICdfJyArIHNlcmllc0xheW91dEJ5O1xuICAgIHZhciBkYXRhc2V0UmVjb3JkID0gZGF0YXNldE1hcC5nZXQoa2V5KSB8fCBkYXRhc2V0TWFwLnNldChrZXksIHtcbiAgICAgIGNhdGVnb3J5V2F5RGltOiAxLFxuICAgICAgdmFsdWVXYXlEaW06IDBcbiAgICB9KTsgLy8gVE9ET1xuICAgIC8vIEF1dG8gZGV0ZWN0IGZpcnN0IHRpbWUgYXhpcyBhbmQgZG8gYXJyYW5nZW1lbnQuXG5cbiAgICBlYWNoKGNvb3JkU3lzRGVmaW5lLmNvb3JkU3lzRGltcywgZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgICAvLyBJbiB2YWx1ZSB3YXkuXG4gICAgICBpZiAoY29vcmRTeXNEZWZpbmUuZmlyc3RDYXRlZ29yeURpbUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgdmFyIGRhdGFEaW0gPSBkYXRhc2V0UmVjb3JkLnZhbHVlV2F5RGltKys7XG4gICAgICAgIGVuY29kZVtjb29yZERpbV0gPSBkYXRhRGltOyAvLyA/Pz8gVE9ETyBnaXZlIGEgYmV0dGVyIGRlZmF1bHQgc2VyaWVzIG5hbWUgcnVsZT9cbiAgICAgICAgLy8gZXNwZWNpYWxseSB3aGVuIGVuY29kZSB4IHkgc3BlY2lmaWVkLlxuICAgICAgICAvLyBjb25zaWRlcjogd2hlbiBtdXRpcGxlIHNlcmllcyBzaGFyZSBvbmUgZGltZW5zaW9uXG4gICAgICAgIC8vIGNhdGVnb3J5IGF4aXMsIHNlcmllcyBuYW1lIHNob3VsZCBiZXR0ZXIgdXNlXG4gICAgICAgIC8vIHRoZSBvdGhlciBkaW1zaW9uIG5hbWUuIE9uIHRoZSBvdGhlciBoYW5kLCB1c2VcbiAgICAgICAgLy8gYm90aCBkaW1lbnNpb25zIG5hbWUuXG5cbiAgICAgICAgZW5jb2RlU2VyaWVzTmFtZS5wdXNoKGRhdGFEaW0pOyAvLyBlbmNvZGVUb29sdGlwLnB1c2goZGF0YURpbSk7XG4gICAgICAgIC8vIGVuY29kZUxhYmVsLnB1c2goZGF0YURpbSk7XG4gICAgICB9IC8vIEluIGNhdGVnb3J5IHdheSwgY2F0ZWdvcnkgYXhpcy5cbiAgICAgIGVsc2UgaWYgKGNvb3JkU3lzRGVmaW5lLmNhdGVnb3J5QXhpc01hcC5nZXQoY29vcmREaW0pKSB7XG4gICAgICAgICAgZW5jb2RlW2Nvb3JkRGltXSA9IDA7XG4gICAgICAgICAgZW5jb2RlSXRlbU5hbWUucHVzaCgwKTtcbiAgICAgICAgfSAvLyBJbiBjYXRlZ29yeSB3YXksIG5vbi1jYXRlZ29yeSBheGlzLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkYXRhRGltID0gZGF0YXNldFJlY29yZC5jYXRlZ29yeVdheURpbSsrO1xuICAgICAgICAgICAgZW5jb2RlW2Nvb3JkRGltXSA9IGRhdGFEaW07IC8vIGVuY29kZVRvb2x0aXAucHVzaChkYXRhRGltKTtcbiAgICAgICAgICAgIC8vIGVuY29kZUxhYmVsLnB1c2goZGF0YURpbSk7XG5cbiAgICAgICAgICAgIGVuY29kZVNlcmllc05hbWUucHVzaChkYXRhRGltKTtcbiAgICAgICAgICB9XG4gICAgfSk7XG4gIH0gLy8gRG8gbm90IG1ha2UgYSBjb21wbGV4IHJ1bGUhIEhhcmQgdG8gY29kZSBtYWludGFpbiBhbmQgbm90IG5lY2Vzc2FyeS5cbiAgLy8gPz8/IFRPRE8gcmVmYWN0b3I6IHByb3ZpZGUgYnkgc2VyaWVzIGl0c2VsZi5cbiAgLy8gW3tuYW1lOiAuLi4sIHZhbHVlOiAuLi59LCAuLi5dIGxpa2U6XG4gIGVsc2UgaWYgKG5TZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUpICE9IG51bGwpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG5vdCBvcmRpbmFsLiAoNSBpcyBhbiBleHBlcmllbmNlIHZhbHVlKVxuICAgICAgdmFyIGZpcnN0Tm90T3JkaW5hbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1ICYmIGZpcnN0Tm90T3JkaW5hbCA9PSBudWxsOyBpKyspIHtcbiAgICAgICAgaWYgKCFkb0d1ZXNzT3JkaW5hbChkYXRhLCBzb3VyY2VGb3JtYXQsIHNlcmllc0xheW91dEJ5LCBjb21wbGV0ZVJlc3VsdC5kaW1lbnNpb25zRGVmaW5lLCBjb21wbGV0ZVJlc3VsdC5zdGFydEluZGV4LCBpKSkge1xuICAgICAgICAgIGZpcnN0Tm90T3JkaW5hbCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0Tm90T3JkaW5hbCAhPSBudWxsKSB7XG4gICAgICAgIGVuY29kZS52YWx1ZSA9IGZpcnN0Tm90T3JkaW5hbDtcbiAgICAgICAgdmFyIG5hbWVEaW1JbmRleCA9IGNvbXBsZXRlUmVzdWx0LnBvdGVudGlhbE5hbWVEaW1JbmRleCB8fCBNYXRoLm1heChmaXJzdE5vdE9yZGluYWwgLSAxLCAwKTsgLy8gQnkgZGVmYXVsdCwgbGFiZWwgdXNlIGl0ZW1OYW1lIGluIGNoYXJ0cy5cbiAgICAgICAgLy8gU28gd2UgZG9udCBzZXQgZW5jb2RlTGFiZWwgaGVyZS5cblxuICAgICAgICBlbmNvZGVTZXJpZXNOYW1lLnB1c2gobmFtZURpbUluZGV4KTtcbiAgICAgICAgZW5jb2RlSXRlbU5hbWUucHVzaChuYW1lRGltSW5kZXgpOyAvLyBlbmNvZGVUb29sdGlwLnB1c2goZmlyc3ROb3RPcmRpbmFsKTtcbiAgICAgIH1cbiAgICB9IC8vIGVuY29kZVRvb2x0aXAubGVuZ3RoICYmIChlbmNvZGUudG9vbHRpcCA9IGVuY29kZVRvb2x0aXApO1xuICAvLyBlbmNvZGVMYWJlbC5sZW5ndGggJiYgKGVuY29kZS5sYWJlbCA9IGVuY29kZUxhYmVsKTtcblxuXG4gIGVuY29kZUl0ZW1OYW1lLmxlbmd0aCAmJiAoZW5jb2RlLml0ZW1OYW1lID0gZW5jb2RlSXRlbU5hbWUpO1xuICBlbmNvZGVTZXJpZXNOYW1lLmxlbmd0aCAmJiAoZW5jb2RlLnNlcmllc05hbWUgPSBlbmNvZGVTZXJpZXNOYW1lKTtcbiAgcmV0dXJuIGVuY29kZTtcbn1cbi8qKlxuICogSWYgcmV0dXJuIG51bGwvdW5kZWZpbmVkLCBpbmRpY2F0ZSB0aGF0IHNob3VsZCBub3QgdXNlIGRhdGFzZXRNb2RlbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldERhdGFzZXRNb2RlbChzZXJpZXNNb2RlbCkge1xuICB2YXIgb3B0aW9uID0gc2VyaWVzTW9kZWwub3B0aW9uOyAvLyBDYXV0aW9uOiBjb25zaWRlciB0aGUgc2NlbmFyaW86XG4gIC8vIEEgZGF0YXNldCBpcyBkZWNsYXJlZCBhbmQgYSBzZXJpZXMgaXMgbm90IGV4cGVjdGVkIHRvIHVzZSB0aGUgZGF0YXNldCxcbiAgLy8gYW5kIGF0IHRoZSBiZWdpbm5pbmcgYHNldE9wdGlvbih7c2VyaWVzOiB7IG5vRGF0YSB9KWAgKGp1c3QgcHJlcGFyZSBvdGhlclxuICAvLyBvcHRpb24gYnV0IG5vIGRhdGEpLCB0aGVuIGBzZXRPcHRpb24oe3Nlcmllczoge2RhdGE6IFsuLi5dfSk7IEluIHRoaXMgY2FzZSxcbiAgLy8gdGhlIHVzZXIgc2hvdWxkIHNldCBhbiBlbXB0eSBhcnJheSB0byBhdm9pZCB0aGF0IGRhdGFzZXQgaXMgdXNlZCBieSBkZWZhdWx0LlxuXG4gIHZhciB0aGlzRGF0YSA9IG9wdGlvbi5kYXRhO1xuXG4gIGlmICghdGhpc0RhdGEpIHtcbiAgICByZXR1cm4gc2VyaWVzTW9kZWwuZWNNb2RlbC5nZXRDb21wb25lbnQoJ2RhdGFzZXQnLCBvcHRpb24uZGF0YXNldEluZGV4IHx8IDApO1xuICB9XG59XG4vKipcbiAqIFRoZSBydWxlIHNob3VsZCBub3QgYmUgY29tcGxleCwgb3RoZXJ3aXNlIHVzZXIgbWlnaHQgbm90XG4gKiBiZSBhYmxlIHRvIGtub3duIHdoZXJlIHRoZSBkYXRhIGlzIHdyb25nLlxuICogVGhlIGNvZGUgaXMgdWdseSwgYnV0IGhvdyB0byBtYWtlIGl0IG5lYXQ/XG4gKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJzL2RhdGEvU291cmNlfSBzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW1JbmRleFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvcmRpbmFsLlxuICovXG5cblxuZnVuY3Rpb24gZ3Vlc3NPcmRpbmFsKHNvdXJjZSwgZGltSW5kZXgpIHtcbiAgcmV0dXJuIGRvR3Vlc3NPcmRpbmFsKHNvdXJjZS5kYXRhLCBzb3VyY2Uuc291cmNlRm9ybWF0LCBzb3VyY2Uuc2VyaWVzTGF5b3V0QnksIHNvdXJjZS5kaW1lbnNpb25zRGVmaW5lLCBzb3VyY2Uuc3RhcnRJbmRleCwgZGltSW5kZXgpO1xufSAvLyBkaW1JbmRleCBtYXkgYmUgb3ZlcmZsb3cgc291cmNlIGRhdGEuXG5cblxuZnVuY3Rpb24gZG9HdWVzc09yZGluYWwoZGF0YSwgc291cmNlRm9ybWF0LCBzZXJpZXNMYXlvdXRCeSwgZGltZW5zaW9uc0RlZmluZSwgc3RhcnRJbmRleCwgZGltSW5kZXgpIHtcbiAgdmFyIHJlc3VsdDsgLy8gRXhwZXJpZW5jZSB2YWx1ZS5cblxuICB2YXIgbWF4TG9vcCA9IDU7XG5cbiAgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBXaGVuIHNvdXJjZVR5cGUgaXMgJ29iamVjdFJvd3MnIG9yICdrZXllZENvbHVtbnMnLCBkaW1lbnNpb25zRGVmaW5lXG4gIC8vIGFsd2F5cyBleGlzdHMgaW4gc291cmNlLlxuXG5cbiAgdmFyIGRpbU5hbWU7XG5cbiAgaWYgKGRpbWVuc2lvbnNEZWZpbmUpIHtcbiAgICBkaW1OYW1lID0gZGltZW5zaW9uc0RlZmluZVtkaW1JbmRleF07XG4gICAgZGltTmFtZSA9IGlzT2JqZWN0KGRpbU5hbWUpID8gZGltTmFtZS5uYW1lIDogZGltTmFtZTtcbiAgfVxuXG4gIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUykge1xuICAgIGlmIChzZXJpZXNMYXlvdXRCeSA9PT0gU0VSSUVTX0xBWU9VVF9CWV9ST1cpIHtcbiAgICAgIHZhciBzYW1wbGUgPSBkYXRhW2RpbUluZGV4XTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoc2FtcGxlIHx8IFtdKS5sZW5ndGggJiYgaSA8IG1heExvb3A7IGkrKykge1xuICAgICAgICBpZiAoKHJlc3VsdCA9IGRldGVjdFZhbHVlKHNhbXBsZVtzdGFydEluZGV4ICsgaV0pKSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoICYmIGkgPCBtYXhMb29wOyBpKyspIHtcbiAgICAgICAgdmFyIHJvdyA9IGRhdGFbc3RhcnRJbmRleCArIGldO1xuXG4gICAgICAgIGlmIChyb3cgJiYgKHJlc3VsdCA9IGRldGVjdFZhbHVlKHJvd1tkaW1JbmRleF0pKSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1MpIHtcbiAgICBpZiAoIWRpbU5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoICYmIGkgPCBtYXhMb29wOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YVtpXTtcblxuICAgICAgaWYgKGl0ZW0gJiYgKHJlc3VsdCA9IGRldGVjdFZhbHVlKGl0ZW1bZGltTmFtZV0pKSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TKSB7XG4gICAgaWYgKCFkaW1OYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNhbXBsZSA9IGRhdGFbZGltTmFtZV07XG5cbiAgICBpZiAoIXNhbXBsZSB8fCBpc1R5cGVkQXJyYXkoc2FtcGxlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlLmxlbmd0aCAmJiBpIDwgbWF4TG9vcDsgaSsrKSB7XG4gICAgICBpZiAoKHJlc3VsdCA9IGRldGVjdFZhbHVlKHNhbXBsZVtpXSkpICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc291cmNlRm9ybWF0ID09PSBTT1VSQ0VfRk9STUFUX09SSUdJTkFMKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAmJiBpIDwgbWF4TG9vcDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbaV07XG4gICAgICB2YXIgdmFsID0gZ2V0RGF0YUl0ZW1WYWx1ZShpdGVtKTtcblxuICAgICAgaWYgKCFpc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHJlc3VsdCA9IGRldGVjdFZhbHVlKHZhbFtkaW1JbmRleF0pKSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZWN0VmFsdWUodmFsKSB7XG4gICAgLy8gQ29uc2lkZXIgdXNhZ2UgY29udmVuaWVuY2UsICcxJywgJzInIHdpbGwgYmUgdHJlYXRlZCBhcyBcIm51bWJlclwiLlxuICAgIC8vIGBpc0Zpbml0KCcnKWAgZ2V0IGB0cnVlYC5cbiAgICBpZiAodmFsICE9IG51bGwgJiYgaXNGaW5pdGUodmFsKSAmJiB2YWwgIT09ICcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWwpICYmIHZhbCAhPT0gJy0nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydHMuZGV0ZWN0U291cmNlRm9ybWF0ID0gZGV0ZWN0U291cmNlRm9ybWF0O1xuZXhwb3J0cy5nZXRTb3VyY2UgPSBnZXRTb3VyY2U7XG5leHBvcnRzLnJlc2V0U291cmNlRGVmYXVsdGVyID0gcmVzZXRTb3VyY2VEZWZhdWx0ZXI7XG5leHBvcnRzLnByZXBhcmVTb3VyY2UgPSBwcmVwYXJlU291cmNlO1xuZXhwb3J0cy5ndWVzc09yZGluYWwgPSBndWVzc09yZGluYWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvc291cmNlSGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9zb3VyY2VIZWxwZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBBdm9pZCB0eXBvLlxudmFyIFNPVVJDRV9GT1JNQVRfT1JJR0lOQUwgPSAnb3JpZ2luYWwnO1xudmFyIFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUyA9ICdhcnJheVJvd3MnO1xudmFyIFNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1MgPSAnb2JqZWN0Um93cyc7XG52YXIgU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TID0gJ2tleWVkQ29sdW1ucyc7XG52YXIgU09VUkNFX0ZPUk1BVF9VTktOT1dOID0gJ3Vua25vd24nOyAvLyA/Pz8gQ0hBTkdFIEEgTkFNRVxuXG52YXIgU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWSA9ICd0eXBlZEFycmF5JztcbnZhciBTRVJJRVNfTEFZT1VUX0JZX0NPTFVNTiA9ICdjb2x1bW4nO1xudmFyIFNFUklFU19MQVlPVVRfQllfUk9XID0gJ3Jvdyc7XG5leHBvcnRzLlNPVVJDRV9GT1JNQVRfT1JJR0lOQUwgPSBTT1VSQ0VfRk9STUFUX09SSUdJTkFMO1xuZXhwb3J0cy5TT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MgPSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1M7XG5leHBvcnRzLlNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1MgPSBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTO1xuZXhwb3J0cy5TT1VSQ0VfRk9STUFUX0tFWUVEX0NPTFVNTlMgPSBTT1VSQ0VfRk9STUFUX0tFWUVEX0NPTFVNTlM7XG5leHBvcnRzLlNPVVJDRV9GT1JNQVRfVU5LTk9XTiA9IFNPVVJDRV9GT1JNQVRfVU5LTk9XTjtcbmV4cG9ydHMuU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWSA9IFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVk7XG5leHBvcnRzLlNFUklFU19MQVlPVVRfQllfQ09MVU1OID0gU0VSSUVTX0xBWU9VVF9CWV9DT0xVTU47XG5leHBvcnRzLlNFUklFU19MQVlPVVRfQllfUk9XID0gU0VSSUVTX0xBWU9VVF9CWV9ST1c7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvc291cmNlVHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvc291cmNlVHlwZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyZW5kZXIgPSByZXF1aXJlKFwienJlbmRlci9saWIvenJlbmRlclwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBjb2xvclRvb2wgPSByZXF1aXJlKFwienJlbmRlci9saWIvdG9vbC9jb2xvclwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2VudlwiKTtcblxudmFyIHRpbXNvcnQgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS90aW1zb3J0XCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBHbG9iYWxNb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsL0dsb2JhbFwiKTtcblxudmFyIEV4dGVuc2lvbkFQSSA9IHJlcXVpcmUoXCIuL0V4dGVuc2lvbkFQSVwiKTtcblxudmFyIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyID0gcmVxdWlyZShcIi4vQ29vcmRpbmF0ZVN5c3RlbVwiKTtcblxudmFyIE9wdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9tb2RlbC9PcHRpb25NYW5hZ2VyXCIpO1xuXG52YXIgYmFja3dhcmRDb21wYXQgPSByZXF1aXJlKFwiLi9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXRcIik7XG5cbnZhciBkYXRhU3RhY2sgPSByZXF1aXJlKFwiLi9wcm9jZXNzb3IvZGF0YVN0YWNrXCIpO1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbC9Db21wb25lbnRcIik7XG5cbnZhciBTZXJpZXNNb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsL1Nlcmllc1wiKTtcblxudmFyIENvbXBvbmVudFZpZXcgPSByZXF1aXJlKFwiLi92aWV3L0NvbXBvbmVudFwiKTtcblxudmFyIENoYXJ0VmlldyA9IHJlcXVpcmUoXCIuL3ZpZXcvQ2hhcnRcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIF90aHJvdHRsZSA9IHJlcXVpcmUoXCIuL3V0aWwvdGhyb3R0bGVcIik7XG5cbnZhciB0aHJvdHRsZSA9IF90aHJvdHRsZS50aHJvdHRsZTtcblxudmFyIHNlcmllc0NvbG9yID0gcmVxdWlyZShcIi4vdmlzdWFsL3Nlcmllc0NvbG9yXCIpO1xuXG52YXIgYXJpYSA9IHJlcXVpcmUoXCIuL3Zpc3VhbC9hcmlhXCIpO1xuXG52YXIgbG9hZGluZ0RlZmF1bHQgPSByZXF1aXJlKFwiLi9sb2FkaW5nL2RlZmF1bHRcIik7XG5cbnZhciBTY2hlZHVsZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vU2NoZWR1bGVyXCIpO1xuXG52YXIgbGlnaHRUaGVtZSA9IHJlcXVpcmUoXCIuL3RoZW1lL2xpZ2h0XCIpO1xuXG52YXIgZGFya1RoZW1lID0gcmVxdWlyZShcIi4vdGhlbWUvZGFya1wiKTtcblxucmVxdWlyZShcIi4vY29tcG9uZW50L2RhdGFzZXRcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBhc3NlcnQgPSB6clV0aWwuYXNzZXJ0O1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBpc0Z1bmN0aW9uID0genJVdGlsLmlzRnVuY3Rpb247XG52YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG52YXIgcGFyc2VDbGFzc1R5cGUgPSBDb21wb25lbnRNb2RlbC5wYXJzZUNsYXNzVHlwZTtcbnZhciB2ZXJzaW9uID0gJzQuMS4wJztcbnZhciBkZXBlbmRlbmNpZXMgPSB7XG4gIHpyZW5kZXI6ICc0LjAuNCdcbn07XG52YXIgVEVTVF9GUkFNRV9SRU1BSU5fVElNRSA9IDE7XG52YXIgUFJJT1JJVFlfUFJPQ0VTU09SX0ZJTFRFUiA9IDEwMDA7XG52YXIgUFJJT1JJVFlfUFJPQ0VTU09SX1NUQVRJU1RJQyA9IDUwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0xBWU9VVCA9IDEwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0dMT0JBTCA9IDIwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0NIQVJUID0gMzAwMDtcbnZhciBQUklPUklUWV9WSVNVQUxfQ09NUE9ORU5UID0gNDAwMDsgLy8gRklYTUVcbi8vIG5lY2Vzc2FyeT9cblxudmFyIFBSSU9SSVRZX1ZJU1VBTF9CUlVTSCA9IDUwMDA7XG52YXIgUFJJT1JJVFkgPSB7XG4gIFBST0NFU1NPUjoge1xuICAgIEZJTFRFUjogUFJJT1JJVFlfUFJPQ0VTU09SX0ZJTFRFUixcbiAgICBTVEFUSVNUSUM6IFBSSU9SSVRZX1BST0NFU1NPUl9TVEFUSVNUSUNcbiAgfSxcbiAgVklTVUFMOiB7XG4gICAgTEFZT1VUOiBQUklPUklUWV9WSVNVQUxfTEFZT1VULFxuICAgIEdMT0JBTDogUFJJT1JJVFlfVklTVUFMX0dMT0JBTCxcbiAgICBDSEFSVDogUFJJT1JJVFlfVklTVUFMX0NIQVJULFxuICAgIENPTVBPTkVOVDogUFJJT1JJVFlfVklTVUFMX0NPTVBPTkVOVCxcbiAgICBCUlVTSDogUFJJT1JJVFlfVklTVUFMX0JSVVNIXG4gIH1cbn07IC8vIE1haW4gcHJvY2VzcyBoYXZlIHRocmVlIGVudHJpZXM6IGBzZXRPcHRpb25gLCBgZGlzcGF0Y2hBY3Rpb25gIGFuZCBgcmVzaXplYCxcbi8vIHdoZXJlIHRoZXkgbXVzdCBub3QgYmUgaW52b2tlZCBuZXN0ZWRseSwgZXhjZXB0IHRoZSBvbmx5IGNhc2U6IGludm9rZVxuLy8gZGlzcGF0Y2hBY3Rpb24gd2l0aCB1cGRhdGVNZXRob2QgXCJub25lXCIgaW4gbWFpbiBwcm9jZXNzLlxuLy8gVGhpcyBmbGFnIGlzIHVzZWQgdG8gY2Fycnkgb3V0IHRoaXMgcnVsZS5cbi8vIEFsbCBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQgb3V0IHNpZGUgbWFpbiBwcm9jZXNzIChpLmUuIHdoZW4gIXRoaXNbSU5fTUFJTl9QUk9DRVNTXSkuXG5cbnZhciBJTl9NQUlOX1BST0NFU1MgPSAnX19mbGFnSW5NYWluUHJvY2Vzcyc7XG52YXIgT1BUSU9OX1VQREFURUQgPSAnX19vcHRpb25VcGRhdGVkJztcbnZhciBBQ1RJT05fUkVHID0gL15bYS16QS1aMC05X10rJC87XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZShtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAvLyBFdmVudCBuYW1lIGlzIGFsbCBsb3dlcmNhc2VcbiAgICBldmVudE5hbWUgPSBldmVudE5hbWUgJiYgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgRXZlbnRmdWwucHJvdG90eXBlW21ldGhvZF0uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIsIGNvbnRleHQpO1xuICB9O1xufVxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHN+TWVzc2FnZUNlbnRlclxuICovXG5cblxuZnVuY3Rpb24gTWVzc2FnZUNlbnRlcigpIHtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbn1cblxuTWVzc2FnZUNlbnRlci5wcm90b3R5cGUub24gPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uJyk7XG5NZXNzYWdlQ2VudGVyLnByb3RvdHlwZS5vZmYgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29mZicpO1xuTWVzc2FnZUNlbnRlci5wcm90b3R5cGUub25lID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbmUnKTtcbnpyVXRpbC5taXhpbihNZXNzYWdlQ2VudGVyLCBFdmVudGZ1bCk7XG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0c35FQ2hhcnRzXG4gKi9cblxuZnVuY3Rpb24gRUNoYXJ0cyhkb20sIHRoZW1lLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBHZXQgdGhlbWUgYnkgbmFtZVxuXG4gIGlmICh0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhlbWUgPSB0aGVtZVN0b3JhZ2VbdGhlbWVdO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuXG4gIHRoaXMuaWQ7XG4gIC8qKlxuICAgKiBHcm91cCBpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmdyb3VwO1xuICAvKipcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9kb20gPSBkb207XG4gIHZhciBkZWZhdWx0UmVuZGVyZXIgPSAnY2FudmFzJztcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgenIgPSB0aGlzLl96ciA9IHpyZW5kZXIuaW5pdChkb20sIHtcbiAgICByZW5kZXJlcjogb3B0cy5yZW5kZXJlciB8fCBkZWZhdWx0UmVuZGVyZXIsXG4gICAgZGV2aWNlUGl4ZWxSYXRpbzogb3B0cy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgIHdpZHRoOiBvcHRzLndpZHRoLFxuICAgIGhlaWdodDogb3B0cy5oZWlnaHRcbiAgfSk7XG4gIC8qKlxuICAgKiBFeHBlY3QgNjAgcGZzLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3Rocm90dGxlZFpyRmx1c2ggPSB0aHJvdHRsZSh6clV0aWwuYmluZCh6ci5mbHVzaCwgenIpLCAxNyk7XG4gIHZhciB0aGVtZSA9IHpyVXRpbC5jbG9uZSh0aGVtZSk7XG4gIHRoZW1lICYmIGJhY2t3YXJkQ29tcGF0KHRoZW1lLCB0cnVlKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3RoZW1lID0gdGhlbWU7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9jaGFydHNWaWV3cyA9IFtdO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY2hhcnRzTWFwID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY29tcG9uZW50c1ZpZXdzID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY29tcG9uZW50c01hcCA9IHt9O1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0Nvb3JkaW5hdGVTeXN0ZW19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2Nvb3JkU3lzTWdyID0gbmV3IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyKCk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgYXBpID0gdGhpcy5fYXBpID0gY3JlYXRlRXh0ZW5zaW9uQVBJKHRoaXMpOyAvLyBTb3J0IG9uIGRlbWFuZFxuXG4gIGZ1bmN0aW9uIHByaW9yaXR5U29ydEZ1bmMoYSwgYikge1xuICAgIHJldHVybiBhLl9fcHJpbyAtIGIuX19wcmlvO1xuICB9XG5cbiAgdGltc29ydCh2aXN1YWxGdW5jcywgcHJpb3JpdHlTb3J0RnVuYyk7XG4gIHRpbXNvcnQoZGF0YVByb2Nlc3NvckZ1bmNzLCBwcmlvcml0eVNvcnRGdW5jKTtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9zdHJlYW0vU2NoZWR1bGVyfVxuICAgKi9cblxuICB0aGlzLl9zY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKHRoaXMsIGFwaSwgZGF0YVByb2Nlc3NvckZ1bmNzLCB2aXN1YWxGdW5jcyk7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHN+TWVzc2FnZUNlbnRlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fbWVzc2FnZUNlbnRlciA9IG5ldyBNZXNzYWdlQ2VudGVyKCk7IC8vIEluaXQgbW91c2UgZXZlbnRzXG5cbiAgdGhpcy5faW5pdEV2ZW50cygpOyAvLyBJbiBjYXNlIHNvbWUgcGVvcGxlIHdyaXRlIGB3aW5kb3cub25yZXNpemUgPSBjaGFydC5yZXNpemVgXG5cblxuICB0aGlzLnJlc2l6ZSA9IHpyVXRpbC5iaW5kKHRoaXMucmVzaXplLCB0aGlzKTsgLy8gQ2FuJ3QgZGlzcGF0Y2ggYWN0aW9uIGR1cmluZyByZW5kZXJpbmcgcHJvY2VkdXJlXG5cbiAgdGhpcy5fcGVuZGluZ0FjdGlvbnMgPSBbXTtcbiAgenIuYW5pbWF0aW9uLm9uKCdmcmFtZScsIHRoaXMuX29uZnJhbWUsIHRoaXMpO1xuICBiaW5kUmVuZGVyZWRFdmVudCh6ciwgdGhpcyk7IC8vIEVDaGFydHMgaW5zdGFuY2UgY2FuIGJlIHVzZWQgYXMgdmFsdWUuXG5cbiAgenJVdGlsLnNldEFzUHJpbWl0aXZlKHRoaXMpO1xufVxuXG52YXIgZWNoYXJ0c1Byb3RvID0gRUNoYXJ0cy5wcm90b3R5cGU7XG5cbmVjaGFydHNQcm90by5fb25mcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNjaGVkdWxlciA9IHRoaXMuX3NjaGVkdWxlcjsgLy8gTGF6eSB1cGRhdGVcblxuICBpZiAodGhpc1tPUFRJT05fVVBEQVRFRF0pIHtcbiAgICB2YXIgc2lsZW50ID0gdGhpc1tPUFRJT05fVVBEQVRFRF0uc2lsZW50O1xuICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG4gICAgcHJlcGFyZSh0aGlzKTtcbiAgICB1cGRhdGVNZXRob2RzLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0gZmFsc2U7XG4gICAgZmx1c2hQZW5kaW5nQWN0aW9ucy5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gIH0gLy8gQXZvaWQgZG8gYm90aCBsYXp5IHVwZGF0ZSBhbmQgcHJvZ3Jlc3MgaW4gb25lIGZyYW1lLlxuICBlbHNlIGlmIChzY2hlZHVsZXIudW5maW5pc2hlZCkge1xuICAgICAgLy8gU3RyZWFtIHByb2dyZXNzLlxuICAgICAgdmFyIHJlbWFpblRpbWUgPSBURVNUX0ZSQU1FX1JFTUFJTl9USU1FO1xuICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICBzY2hlZHVsZXIudW5maW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAgICAgc2NoZWR1bGVyLnBlcmZvcm1TZXJpZXNUYXNrcyhlY01vZGVsKTsgLy8gQ3VycmVudGx5IGRhdGFQcm9jZXNzb3JGdW5jcyBkbyBub3QgY2hlY2sgdGhyZXNob2xkLlxuXG4gICAgICAgIHNjaGVkdWxlci5wZXJmb3JtRGF0YVByb2Nlc3NvclRhc2tzKGVjTW9kZWwpO1xuICAgICAgICB1cGRhdGVTdHJlYW1Nb2Rlcyh0aGlzLCBlY01vZGVsKTsgLy8gRG8gbm90IHVwZGF0ZSBjb29yZGluYXRlIHN5c3RlbSBoZXJlLiBCZWNhdXNlIHRoYXQgY29vcmQgc3lzdGVtIHVwZGF0ZSBpblxuICAgICAgICAvLyBlYWNoIGZyYW1lIGlzIG5vdCBhIGdvb2QgdXNlciBleHBlcmllbmNlLiBTbyB3ZSBmb2xsb3cgdGhlIHJ1bGUgdGhhdFxuICAgICAgICAvLyB0aGUgZXh0ZW50IG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSBpcyBkZXRlcm1pbiBpbiB0aGUgZmlyc3QgZnJhbWUgKHRoZVxuICAgICAgICAvLyBmcmFtZSBpcyBleGVjdXRlZCBpbW1lZGlldGVseSBhZnRlciB0YXNrIHJlc2V0LlxuICAgICAgICAvLyB0aGlzLl9jb29yZFN5c01nci51cGRhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLSBlYyBmcmFtZSB2aXN1YWwgLS0tJywgcmVtYWluVGltZSk7XG5cbiAgICAgICAgc2NoZWR1bGVyLnBlcmZvcm1WaXN1YWxUYXNrcyhlY01vZGVsKTtcbiAgICAgICAgcmVuZGVyU2VyaWVzKHRoaXMsIHRoaXMuX21vZGVsLCBhcGksICdyZW1haW4nKTtcbiAgICAgICAgcmVtYWluVGltZSAtPSArbmV3IERhdGUoKSAtIHN0YXJ0VGltZTtcbiAgICAgIH0gd2hpbGUgKHJlbWFpblRpbWUgPiAwICYmIHNjaGVkdWxlci51bmZpbmlzaGVkKTsgLy8gQ2FsbCBmbHVzaCBleHBsaWNpdGx5IGZvciB0cmlnZ2VyIGZpbmlzaGVkIGV2ZW50LlxuXG5cbiAgICAgIGlmICghc2NoZWR1bGVyLnVuZmluaXNoZWQpIHtcbiAgICAgICAgdGhpcy5fenIuZmx1c2goKTtcbiAgICAgIH0gLy8gRWxzZSwgenIgZmx1c2hpbmcgYmUgZW5zdWUgd2l0aGluIHRoZSBzYW1lIGZyYW1lLFxuICAgICAgLy8gYmVjYXVzZSB6ciBmbHVzaGluZyBpcyBhZnRlciBvbmZyYW1lIGV2ZW50LlxuXG4gICAgfVxufTtcbi8qKlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0RG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZG9tO1xufTtcbi8qKlxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXJ+WlJlbmRlcn1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRaciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3pyO1xufTtcbi8qKlxuICogVXNhZ2U6XG4gKiBjaGFydC5zZXRPcHRpb24ob3B0aW9uLCBub3RNZXJnZSwgbGF6eVVwZGF0ZSk7XG4gKiBjaGFydC5zZXRPcHRpb24ob3B0aW9uLCB7XG4gKiAgICAgbm90TWVyZ2U6IC4uLixcbiAqICAgICBsYXp5VXBkYXRlOiAuLi4sXG4gKiAgICAgc2lsZW50OiAuLi5cbiAqIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtvcHRzXSBvcHRzIG9yIG5vdE1lcmdlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5ub3RNZXJnZT1mYWxzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMubGF6eVVwZGF0ZT1mYWxzZV0gVXNlZnVsIHdoZW4gc2V0T3B0aW9uIGZyZXF1ZW50bHkuXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uc2V0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbiwgbm90TWVyZ2UsIGxhenlVcGRhdGUpIHtcbiAgdmFyIHNpbGVudDtcblxuICBpZiAoaXNPYmplY3Qobm90TWVyZ2UpKSB7XG4gICAgbGF6eVVwZGF0ZSA9IG5vdE1lcmdlLmxhenlVcGRhdGU7XG4gICAgc2lsZW50ID0gbm90TWVyZ2Uuc2lsZW50O1xuICAgIG5vdE1lcmdlID0gbm90TWVyZ2Uubm90TWVyZ2U7XG4gIH1cblxuICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuXG4gIGlmICghdGhpcy5fbW9kZWwgfHwgbm90TWVyZ2UpIHtcbiAgICB2YXIgb3B0aW9uTWFuYWdlciA9IG5ldyBPcHRpb25NYW5hZ2VyKHRoaXMuX2FwaSk7XG4gICAgdmFyIHRoZW1lID0gdGhpcy5fdGhlbWU7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbCA9IG5ldyBHbG9iYWxNb2RlbChudWxsLCBudWxsLCB0aGVtZSwgb3B0aW9uTWFuYWdlcik7XG4gICAgZWNNb2RlbC5zY2hlZHVsZXIgPSB0aGlzLl9zY2hlZHVsZXI7XG4gICAgZWNNb2RlbC5pbml0KG51bGwsIG51bGwsIHRoZW1lLCBvcHRpb25NYW5hZ2VyKTtcbiAgfVxuXG4gIHRoaXMuX21vZGVsLnNldE9wdGlvbihvcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKTtcblxuICBpZiAobGF6eVVwZGF0ZSkge1xuICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0ge1xuICAgICAgc2lsZW50OiBzaWxlbnRcbiAgICB9O1xuICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHByZXBhcmUodGhpcyk7XG4gICAgdXBkYXRlTWV0aG9kcy51cGRhdGUuY2FsbCh0aGlzKTsgLy8gRW5zdXJlIHpyIHJlZnJlc2ggc3ljaHJvbm91c2x5LCBhbmQgdGhlbiBwaXhlbCBpbiBjYW52YXMgY2FuIGJlXG4gICAgLy8gZmV0Y2hlZCBhZnRlciBgc2V0T3B0aW9uYC5cblxuICAgIHRoaXMuX3pyLmZsdXNoKCk7XG5cbiAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IGZhbHNlO1xuICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICAgIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICB9XG59O1xuLyoqXG4gKiBAREVQUkVDQVRFRFxuICovXG5cblxuZWNoYXJ0c1Byb3RvLnNldFRoZW1lID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLmxvZygnRUNoYXJ0cyNzZXRUaGVtZSgpIGlzIERFUFJFQ0FURUQgaW4gRUNoYXJ0cyAzLjAnKTtcbn07XG4vKipcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX21vZGVsO1xufTtcbi8qKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldE9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLmdldE9wdGlvbigpO1xufTtcbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fenIuZ2V0V2lkdGgoKTtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl96ci5nZXRIZWlnaHQoKTtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXREZXZpY2VQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fenIucGFpbnRlci5kcHIgfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn07XG4vKipcbiAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0UmVuZGVyZWRDYW52YXMgPSBmdW5jdGlvbiAob3B0cykge1xuICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy5waXhlbFJhdGlvID0gb3B0cy5waXhlbFJhdGlvIHx8IDE7XG4gIG9wdHMuYmFja2dyb3VuZENvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy5fbW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgdmFyIHpyID0gdGhpcy5fenI7IC8vIHZhciBsaXN0ID0genIuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAvLyBTdG9wIGFuaW1hdGlvbnNcbiAgLy8gTmV2ZXIgd29ya3MgYmVmb3JlIGluIGluaXQgYW5pbWF0aW9uLCBzbyByZW1vdmUgaXQuXG4gIC8vIHpyVXRpbC5lYWNoKGxpc3QsIGZ1bmN0aW9uIChlbCkge1xuICAvLyAgICAgZWwuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgLy8gfSk7XG5cbiAgcmV0dXJuIHpyLnBhaW50ZXIuZ2V0UmVuZGVyZWRDYW52YXMob3B0cyk7XG59O1xuLyoqXG4gKiBHZXQgc3ZnIGRhdGEgdXJsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0U3ZnRGF0YVVybCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCFlbnYuc3ZnU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHpyID0gdGhpcy5fenI7XG4gIHZhciBsaXN0ID0genIuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpOyAvLyBTdG9wIGFuaW1hdGlvbnNcblxuICB6clV0aWwuZWFjaChsaXN0LCBmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICB9KTtcbiAgcmV0dXJuIHpyLnBhaW50ZXIucGF0aFRvRGF0YVVybCgpO1xufTtcbi8qKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50eXBlPSdwbmcnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnBpeGVsUmF0aW89MV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZXhjbHVkZUNvbXBvbmVudHNdXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0RGF0YVVSTCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgZXhjbHVkZUNvbXBvbmVudHMgPSBvcHRzLmV4Y2x1ZGVDb21wb25lbnRzO1xuICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICB2YXIgZXhjbHVkZXNDb21wb25lbnRWaWV3cyA9IFtdO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGVhY2goZXhjbHVkZUNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiBjb21wb25lbnRUeXBlXG4gICAgfSwgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgdmFyIHZpZXcgPSBzZWxmLl9jb21wb25lbnRzTWFwW2NvbXBvbmVudC5fX3ZpZXdJZF07XG5cbiAgICAgIGlmICghdmlldy5ncm91cC5pZ25vcmUpIHtcbiAgICAgICAgZXhjbHVkZXNDb21wb25lbnRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICB2aWV3Lmdyb3VwLmlnbm9yZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgdXJsID0gdGhpcy5fenIucGFpbnRlci5nZXRUeXBlKCkgPT09ICdzdmcnID8gdGhpcy5nZXRTdmdEYXRhVXJsKCkgOiB0aGlzLmdldFJlbmRlcmVkQ2FudmFzKG9wdHMpLnRvRGF0YVVSTCgnaW1hZ2UvJyArIChvcHRzICYmIG9wdHMudHlwZSB8fCAncG5nJykpO1xuICBlYWNoKGV4Y2x1ZGVzQ29tcG9uZW50Vmlld3MsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgdmlldy5ncm91cC5pZ25vcmUgPSBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiB1cmw7XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnR5cGU9J3BuZyddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucGl4ZWxSYXRpbz0xXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRDb25uZWN0ZWREYXRhVVJMID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdyb3VwSWQgPSB0aGlzLmdyb3VwO1xuICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICB2YXIgTUFYX05VTUJFUiA9IEluZmluaXR5O1xuXG4gIGlmIChjb25uZWN0ZWRHcm91cHNbZ3JvdXBJZF0pIHtcbiAgICB2YXIgbGVmdCA9IE1BWF9OVU1CRVI7XG4gICAgdmFyIHRvcCA9IE1BWF9OVU1CRVI7XG4gICAgdmFyIHJpZ2h0ID0gLU1BWF9OVU1CRVI7XG4gICAgdmFyIGJvdHRvbSA9IC1NQVhfTlVNQkVSO1xuICAgIHZhciBjYW52YXNMaXN0ID0gW107XG4gICAgdmFyIGRwciA9IG9wdHMgJiYgb3B0cy5waXhlbFJhdGlvIHx8IDE7XG4gICAgenJVdGlsLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbiAoY2hhcnQsIGlkKSB7XG4gICAgICBpZiAoY2hhcnQuZ3JvdXAgPT09IGdyb3VwSWQpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGNoYXJ0LmdldFJlbmRlcmVkQ2FudmFzKHpyVXRpbC5jbG9uZShvcHRzKSk7XG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBjaGFydC5nZXREb20oKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGVmdCA9IG1hdGhNaW4oYm91bmRpbmdSZWN0LmxlZnQsIGxlZnQpO1xuICAgICAgICB0b3AgPSBtYXRoTWluKGJvdW5kaW5nUmVjdC50b3AsIHRvcCk7XG4gICAgICAgIHJpZ2h0ID0gbWF0aE1heChib3VuZGluZ1JlY3QucmlnaHQsIHJpZ2h0KTtcbiAgICAgICAgYm90dG9tID0gbWF0aE1heChib3VuZGluZ1JlY3QuYm90dG9tLCBib3R0b20pO1xuICAgICAgICBjYW52YXNMaXN0LnB1c2goe1xuICAgICAgICAgIGRvbTogY2FudmFzLFxuICAgICAgICAgIGxlZnQ6IGJvdW5kaW5nUmVjdC5sZWZ0LFxuICAgICAgICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZWZ0ICo9IGRwcjtcbiAgICB0b3AgKj0gZHByO1xuICAgIHJpZ2h0ICo9IGRwcjtcbiAgICBib3R0b20gKj0gZHByO1xuICAgIHZhciB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgIHZhciB0YXJnZXRDYW52YXMgPSB6clV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgenIgPSB6cmVuZGVyLmluaXQodGFyZ2V0Q2FudmFzKTtcbiAgICBlYWNoKGNhbnZhc0xpc3QsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgaW1nID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHg6IGl0ZW0ubGVmdCAqIGRwciAtIGxlZnQsXG4gICAgICAgICAgeTogaXRlbS50b3AgKiBkcHIgLSB0b3AsXG4gICAgICAgICAgaW1hZ2U6IGl0ZW0uZG9tXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgenIuYWRkKGltZyk7XG4gICAgfSk7XG4gICAgenIucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgcmV0dXJuIHRhcmdldENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlLycgKyAob3B0cyAmJiBvcHRzLnR5cGUgfHwgJ3BuZycpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRhVVJMKG9wdHMpO1xuICB9XG59O1xuLyoqXG4gKiBDb252ZXJ0IGZyb20gbG9naWNhbCBjb29yZGluYXRlIHN5c3RlbSB0byBwaXhlbCBjb29yZGluYXRlIHN5c3RlbS5cbiAqIFNlZSBDb29yZGluYXRlU3lzdGVtI2NvbnZlcnRUb1BpeGVsLlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdnZW8nLCBtZWFucyB7Z2VvSW5kZXg6IDB9LlxuICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gKiAgICAgICAge1xuICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcbiAqICAgICAgICAgICAgZ2VvSW5kZXggLyBnZW9JZCwgZ2VvTmFtZSxcbiAqICAgICAgICAgICAgYm1hcEluZGV4IC8gYm1hcElkIC8gYm1hcE5hbWUsXG4gKiAgICAgICAgICAgIHhBeGlzSW5kZXggLyB4QXhpc0lkIC8geEF4aXNOYW1lLFxuICogICAgICAgICAgICB5QXhpc0luZGV4IC8geUF4aXNJZCAvIHlBeGlzTmFtZSxcbiAqICAgICAgICAgICAgZ3JpZEluZGV4IC8gZ3JpZElkIC8gZ3JpZE5hbWUsXG4gKiAgICAgICAgICAgIC4uLiAoY2FuIGJlIGV4dGVuZGVkKVxuICogICAgICAgIH1cbiAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7QXJyYXl8bnVtYmVyfSByZXN1bHRcbiAqL1xuXG5cbmVjaGFydHNQcm90by5jb252ZXJ0VG9QaXhlbCA9IHpyVXRpbC5jdXJyeShkb0NvbnZlcnRQaXhlbCwgJ2NvbnZlcnRUb1BpeGVsJyk7XG4vKipcbiAqIENvbnZlcnQgZnJvbSBwaXhlbCBjb29yZGluYXRlIHN5c3RlbSB0byBsb2dpY2FsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICogU2VlIENvb3JkaW5hdGVTeXN0ZW0jY29udmVydEZyb21QaXhlbC5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gKiAgICAgICAgICAgIGdlb0luZGV4IC8gZ2VvSWQgLyBnZW9OYW1lLFxuICogICAgICAgICAgICBibWFwSW5kZXggLyBibWFwSWQgLyBibWFwTmFtZSxcbiAqICAgICAgICAgICAgeEF4aXNJbmRleCAvIHhBeGlzSWQgLyB4QXhpc05hbWUsXG4gKiAgICAgICAgICAgIHlBeGlzSW5kZXggLyB5QXhpc0lkIC8geUF4aXNOYW1lXG4gKiAgICAgICAgICAgIGdyaWRJbmRleCAvIGdyaWRJZCAvIGdyaWROYW1lLFxuICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAqICAgICAgICB9XG4gKiBAcGFyYW0ge0FycmF5fG51bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fG51bWJlcn0gcmVzdWx0XG4gKi9cblxuZWNoYXJ0c1Byb3RvLmNvbnZlcnRGcm9tUGl4ZWwgPSB6clV0aWwuY3VycnkoZG9Db252ZXJ0UGl4ZWwsICdjb252ZXJ0RnJvbVBpeGVsJyk7XG5cbmZ1bmN0aW9uIGRvQ29udmVydFBpeGVsKG1ldGhvZE5hbWUsIGZpbmRlciwgdmFsdWUpIHtcbiAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICB2YXIgY29vcmRTeXNMaXN0ID0gdGhpcy5fY29vcmRTeXNNZ3IuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKTtcblxuICB2YXIgcmVzdWx0O1xuICBmaW5kZXIgPSBtb2RlbFV0aWwucGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkU3lzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb29yZFN5cyA9IGNvb3JkU3lzTGlzdFtpXTtcblxuICAgIGlmIChjb29yZFN5c1ttZXRob2ROYW1lXSAmJiAocmVzdWx0ID0gY29vcmRTeXNbbWV0aG9kTmFtZV0oZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkpICE9IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIElzIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZSBzeXN0ZW1zIG9yIGNvbXBvbmVudHMgY29udGFpbiB0aGUgZ2l2ZW4gcGl4ZWwgcG9pbnQuXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICogICAgICAgICAgICBnZW9JbmRleCAvIGdlb0lkIC8gZ2VvTmFtZSxcbiAqICAgICAgICAgICAgYm1hcEluZGV4IC8gYm1hcElkIC8gYm1hcE5hbWUsXG4gKiAgICAgICAgICAgIHhBeGlzSW5kZXggLyB4QXhpc0lkIC8geEF4aXNOYW1lLFxuICogICAgICAgICAgICB5QXhpc0luZGV4IC8geUF4aXNJZCAvIHlBeGlzTmFtZSxcbiAqICAgICAgICAgICAgZ3JpZEluZGV4IC8gZ3JpZElkIC8gZ3JpZE5hbWUsXG4gKiAgICAgICAgICAgIC4uLiAoY2FuIGJlIGV4dGVuZGVkKVxuICogICAgICAgIH1cbiAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gcmVzdWx0XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uY29udGFpblBpeGVsID0gZnVuY3Rpb24gKGZpbmRlciwgdmFsdWUpIHtcbiAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgdmFyIHJlc3VsdDtcbiAgZmluZGVyID0gbW9kZWxVdGlsLnBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlcik7XG4gIHpyVXRpbC5lYWNoKGZpbmRlciwgZnVuY3Rpb24gKG1vZGVscywga2V5KSB7XG4gICAga2V5LmluZGV4T2YoJ01vZGVscycpID49IDAgJiYgenJVdGlsLmVhY2gobW9kZWxzLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgIHZhciBjb29yZFN5cyA9IG1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy5jb250YWluUG9pbnQpIHtcbiAgICAgICAgcmVzdWx0IHw9ICEhY29vcmRTeXMuY29udGFpblBvaW50KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VyaWVzTW9kZWxzJykge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2NoYXJ0c01hcFttb2RlbC5fX3ZpZXdJZF07XG5cbiAgICAgICAgaWYgKHZpZXcgJiYgdmlldy5jb250YWluUG9pbnQpIHtcbiAgICAgICAgICByZXN1bHQgfD0gdmlldy5jb250YWluUG9pbnQodmFsdWUsIG1vZGVsKTtcbiAgICAgICAgfSBlbHNlIHt9XG4gICAgICB9IGVsc2Uge31cbiAgICB9LCB0aGlzKTtcbiAgfSwgdGhpcyk7XG4gIHJldHVybiAhIXJlc3VsdDtcbn07XG4vKipcbiAqIEdldCB2aXN1YWwgZnJvbSBzZXJpZXMgb3IgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnc2VyaWVzJywgbWVhbnMge3Nlcmllc0luZGV4OiAwfS5cbiAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gKiAgICAgICAgICAgIGRhdGFJbmRleCAvIGRhdGFJbmRleEluc2lkZVxuICogICAgICAgIH1cbiAqICAgICAgICBJZiBkYXRhSW5kZXggaXMgbm90IHNwZWNpZmllZCwgc2VyaWVzIHZpc3VhbCB3aWxsIGJlIGZldGNoZWQsXG4gKiAgICAgICAgYnV0IG5vdCBkYXRhIGl0ZW0gdmlzdWFsLlxuICogICAgICAgIElmIGFsbCBvZiBzZXJpZXNJbmRleCwgc2VyaWVzSWQsIHNlcmllc05hbWUgYXJlIG5vdCBzcGVjaWZpZWQsXG4gKiAgICAgICAgdmlzdWFsIHdpbGwgYmUgZmV0Y2hlZCBmcm9tIGZpcnN0IHNlcmllcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aXN1YWxUeXBlICdjb2xvcicsICdzeW1ib2wnLCAnc3ltYm9sU2l6ZSdcbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRWaXN1YWwgPSBmdW5jdGlvbiAoZmluZGVyLCB2aXN1YWxUeXBlKSB7XG4gIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gIGZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIsIHtcbiAgICBkZWZhdWx0TWFpblR5cGU6ICdzZXJpZXMnXG4gIH0pO1xuICB2YXIgc2VyaWVzTW9kZWwgPSBmaW5kZXIuc2VyaWVzTW9kZWw7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB2YXIgZGF0YUluZGV4SW5zaWRlID0gZmluZGVyLmhhc093blByb3BlcnR5KCdkYXRhSW5kZXhJbnNpZGUnKSA/IGZpbmRlci5kYXRhSW5kZXhJbnNpZGUgOiBmaW5kZXIuaGFzT3duUHJvcGVydHkoJ2RhdGFJbmRleCcpID8gZGF0YS5pbmRleE9mUmF3SW5kZXgoZmluZGVyLmRhdGFJbmRleCkgOiBudWxsO1xuICByZXR1cm4gZGF0YUluZGV4SW5zaWRlICE9IG51bGwgPyBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4SW5zaWRlLCB2aXN1YWxUeXBlKSA6IGRhdGEuZ2V0VmlzdWFsKHZpc3VhbFR5cGUpO1xufTtcbi8qKlxuICogR2V0IHZpZXcgb2YgY29ycmVzcG9uZGluZyBjb21wb25lbnQgbW9kZWxcbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29tcG9uZW50TW9kZWxcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldFZpZXdPZkNvbXBvbmVudE1vZGVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE1vZGVsKSB7XG4gIHJldHVybiB0aGlzLl9jb21wb25lbnRzTWFwW2NvbXBvbmVudE1vZGVsLl9fdmlld0lkXTtcbn07XG4vKipcbiAqIEdldCB2aWV3IG9mIGNvcnJlc3BvbmRpbmcgc2VyaWVzIG1vZGVsXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0fVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldFZpZXdPZlNlcmllc01vZGVsID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gIHJldHVybiB0aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xufTtcblxudmFyIHVwZGF0ZU1ldGhvZHMgPSB7XG4gIHByZXBhcmVBbmRVcGRhdGU6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgcHJlcGFyZSh0aGlzKTtcbiAgICB1cGRhdGVNZXRob2RzLnVwZGF0ZS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIC8vIGNvbnNvbGUucHJvZmlsZSAmJiBjb25zb2xlLnByb2ZpbGUoJ3VwZGF0ZScpO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICB2YXIgY29vcmRTeXNNZ3IgPSB0aGlzLl9jb29yZFN5c01ncjtcbiAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5fc2NoZWR1bGVyOyAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuXG4gICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZWR1bGVyLnJlc3RvcmVEYXRhKGVjTW9kZWwsIHBheWxvYWQpO1xuICAgIHNjaGVkdWxlci5wZXJmb3JtU2VyaWVzVGFza3MoZWNNb2RlbCk7IC8vIFRPRE9cbiAgICAvLyBTYXZlIHRvdGFsIGVjTW9kZWwgaGVyZSBmb3IgdW5kby9yZWRvIChhZnRlciByZXN0b3JpbmcgZGF0YSBhbmQgYmVmb3JlIHByb2Nlc3NpbmcgZGF0YSkuXG4gICAgLy8gVW5kbyAocmVzdG9yYXRpb24gb2YgdG90YWwgZWNNb2RlbCkgY2FuIGJlIGNhcnJpZWQgb3V0IGluICdhY3Rpb24nIG9yIG91dHNpZGUgQVBJIGNhbGwuXG4gICAgLy8gQ3JlYXRlIG5ldyBjb29yZGluYXRlIHN5c3RlbSBlYWNoIHVwZGF0ZVxuICAgIC8vIEluIExpbmVWaWV3IG1heSBzYXZlIHRoZSBvbGQgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIHVzZSBpdCB0byBnZXQgdGhlIG9yaWduYWwgcG9pbnRcblxuICAgIGNvb3JkU3lzTWdyLmNyZWF0ZShlY01vZGVsLCBhcGkpO1xuICAgIHNjaGVkdWxlci5wZXJmb3JtRGF0YVByb2Nlc3NvclRhc2tzKGVjTW9kZWwsIHBheWxvYWQpOyAvLyBDdXJyZW50IHN0cmVhbSByZW5kZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBkYXRhIHByb2Nlc3MuIFNvIHdlIGNhbiB1cGRhdGVcbiAgICAvLyBzdHJlYW0gbW9kZXMgYWZ0ZXIgZGF0YSBwcm9jZXNzaW5nLCB3aGVyZSB0aGUgZmlsdGVyZWQgZGF0YSBpcyB1c2VkIHRvXG4gICAgLy8gZGV0ZW1pbmcgd2hldGhlciB1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nLlxuXG4gICAgdXBkYXRlU3RyZWFtTW9kZXModGhpcywgZWNNb2RlbCk7IC8vIFdlIHVwZGF0ZSBzdHJlYW0gbW9kZXMgYmVmb3JlIGNvb3JkaW5hdGUgc3lzdGVtIHVwZGF0ZWQsIHRoZW4gdGhlIG1vZGVzIGluZm9cbiAgICAvLyBjYW4gYmUgZmV0Y2hlZCB3aGVuIGNvb3JkIHN5cyB1cGRhdGluZyAoY29uc2lkZXIgdGhlIGJhckdyaWQgZXh0ZW50IGZpeCkuIEJ1dFxuICAgIC8vIHRoZSBkcmF3YmFjayBpcyB0aGUgZnVsbCBjb29yZCBpbmZvIGNhbiBub3QgYmUgZmV0Y2hlZC4gRm9ydHVuYXRlbHkgdGhpcyBmdWxsXG4gICAgLy8gY29vcmQgaXMgbm90IHJlcXVpZWQgaW4gc3RyZWFtIG1vZGUgdXBkYXRlciBjdXJyZW50bHkuXG5cbiAgICBjb29yZFN5c01nci51cGRhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICBjbGVhckNvbG9yUGFsZXR0ZShlY01vZGVsKTtcbiAgICBzY2hlZHVsZXIucGVyZm9ybVZpc3VhbFRhc2tzKGVjTW9kZWwsIHBheWxvYWQpO1xuICAgIHJlbmRlcih0aGlzLCBlY01vZGVsLCBhcGksIHBheWxvYWQpOyAvLyBTZXQgYmFja2dyb3VuZFxuXG4gICAgdmFyIGJhY2tncm91bmRDb2xvciA9IGVjTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKSB8fCAndHJhbnNwYXJlbnQnOyAvLyBJbiBJRThcblxuICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGJhY2tncm91bmRDb2xvcik7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvclRvb2wuc3RyaW5naWZ5KGNvbG9yQXJyLCAncmdiJyk7XG5cbiAgICAgIGlmIChjb2xvckFyclszXSA9PT0gMCkge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB6ci5zZXRCYWNrZ3JvdW5kQ29sb3IoYmFja2dyb3VuZENvbG9yKTtcbiAgICB9XG5cbiAgICBwZXJmb3JtUG9zdFVwZGF0ZUZ1bmNzKGVjTW9kZWwsIGFwaSk7IC8vIGNvbnNvbGUucHJvZmlsZSAmJiBjb25zb2xlLnByb2ZpbGVFbmQoJ3VwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgdmFyIGVjSW5zID0gdGhpcztcbiAgICB2YXIgYXBpID0gdGhpcy5fYXBpOyAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuXG4gICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDaGFydFZpZXcubWFya1VwZGF0ZU1ldGhvZChwYXlsb2FkLCAndXBkYXRlVHJhbnNmb3JtJyk7XG5cblxuICAgIHZhciBjb21wb25lbnREaXJ0eUxpc3QgPSBbXTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIGNvbXBvbmVudE1vZGVsKSB7XG4gICAgICB2YXIgY29tcG9uZW50VmlldyA9IGVjSW5zLmdldFZpZXdPZkNvbXBvbmVudE1vZGVsKGNvbXBvbmVudE1vZGVsKTtcblxuICAgICAgaWYgKGNvbXBvbmVudFZpZXcgJiYgY29tcG9uZW50Vmlldy5fX2FsaXZlKSB7XG4gICAgICAgIGlmIChjb21wb25lbnRWaWV3LnVwZGF0ZVRyYW5zZm9ybSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb21wb25lbnRWaWV3LnVwZGF0ZVRyYW5zZm9ybShjb21wb25lbnRNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICAgICAgICByZXN1bHQgJiYgcmVzdWx0LnVwZGF0ZSAmJiBjb21wb25lbnREaXJ0eUxpc3QucHVzaChjb21wb25lbnRWaWV3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wb25lbnREaXJ0eUxpc3QucHVzaChjb21wb25lbnRWaWV3KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBzZXJpZXNEaXJ0eU1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIGNoYXJ0VmlldyA9IGVjSW5zLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuXG4gICAgICBpZiAoY2hhcnRWaWV3LnVwZGF0ZVRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2hhcnRWaWV3LnVwZGF0ZVRyYW5zZm9ybShzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICAgICAgcmVzdWx0ICYmIHJlc3VsdC51cGRhdGUgJiYgc2VyaWVzRGlydHlNYXAuc2V0KHNlcmllc01vZGVsLnVpZCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpZXNEaXJ0eU1hcC5zZXQoc2VyaWVzTW9kZWwudWlkLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjbGVhckNvbG9yUGFsZXR0ZShlY01vZGVsKTsgLy8gS2VlcCBwaXBlIHRvIHRoZSBleGlzdCBwaXBlbGluZSBiZWNhdXNlIGl0IGRlcGVuZHMgb24gdGhlIHJlbmRlciB0YXNrIG9mIHRoZSBmdWxsIHBpcGVsaW5lLlxuICAgIC8vIHRoaXMuX3NjaGVkdWxlci5wZXJmb3JtVmlzdWFsVGFza3MoZWNNb2RlbCwgcGF5bG9hZCwgJ2xheW91dCcsIHRydWUpO1xuXG4gICAgdGhpcy5fc2NoZWR1bGVyLnBlcmZvcm1WaXN1YWxUYXNrcyhlY01vZGVsLCBwYXlsb2FkLCB7XG4gICAgICBzZXREaXJ0eTogdHJ1ZSxcbiAgICAgIGRpcnR5TWFwOiBzZXJpZXNEaXJ0eU1hcFxuICAgIH0pOyAvLyBDdXJyZW50bHksIG5vdCBjYWxsIHJlbmRlciBvZiBjb21wb25lbnRzLiBHZW8gcmVuZGVyIGNvc3QgYSBsb3QuXG4gICAgLy8gcmVuZGVyQ29tcG9uZW50cyhlY0lucywgZWNNb2RlbCwgYXBpLCBwYXlsb2FkLCBjb21wb25lbnREaXJ0eUxpc3QpO1xuXG5cbiAgICByZW5kZXJTZXJpZXMoZWNJbnMsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgc2VyaWVzRGlydHlNYXApO1xuICAgIHBlcmZvcm1Qb3N0VXBkYXRlRnVuY3MoZWNNb2RlbCwgdGhpcy5fYXBpKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVZpZXc6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDsgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cblxuICAgIGlmICghZWNNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIENoYXJ0Vmlldy5tYXJrVXBkYXRlTWV0aG9kKHBheWxvYWQsICd1cGRhdGVWaWV3Jyk7XG4gICAgY2xlYXJDb2xvclBhbGV0dGUoZWNNb2RlbCk7IC8vIEtlZXAgcGlwZSB0byB0aGUgZXhpc3QgcGlwZWxpbmUgYmVjYXVzZSBpdCBkZXBlbmRzIG9uIHRoZSByZW5kZXIgdGFzayBvZiB0aGUgZnVsbCBwaXBlbGluZS5cblxuICAgIHRoaXMuX3NjaGVkdWxlci5wZXJmb3JtVmlzdWFsVGFza3MoZWNNb2RlbCwgcGF5bG9hZCwge1xuICAgICAgc2V0RGlydHk6IHRydWVcbiAgICB9KTtcblxuICAgIHJlbmRlcih0aGlzLCB0aGlzLl9tb2RlbCwgdGhpcy5fYXBpLCBwYXlsb2FkKTtcbiAgICBwZXJmb3JtUG9zdFVwZGF0ZUZ1bmNzKGVjTW9kZWwsIHRoaXMuX2FwaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVWaXN1YWw6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgdXBkYXRlTWV0aG9kcy51cGRhdGUuY2FsbCh0aGlzLCBwYXlsb2FkKTsgLy8gdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICAvLyAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuICAgIC8vIGlmICghZWNNb2RlbCkge1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuICAgIC8vIENoYXJ0Vmlldy5tYXJrVXBkYXRlTWV0aG9kKHBheWxvYWQsICd1cGRhdGVWaXN1YWwnKTtcbiAgICAvLyBjbGVhckNvbG9yUGFsZXR0ZShlY01vZGVsKTtcbiAgICAvLyAvLyBLZWVwIHBpcGUgdG8gdGhlIGV4aXN0IHBpcGVsaW5lIGJlY2F1c2UgaXQgZGVwZW5kcyBvbiB0aGUgcmVuZGVyIHRhc2sgb2YgdGhlIGZ1bGwgcGlwZWxpbmUuXG4gICAgLy8gdGhpcy5fc2NoZWR1bGVyLnBlcmZvcm1WaXN1YWxUYXNrcyhlY01vZGVsLCBwYXlsb2FkLCB7dmlzdWFsVHlwZTogJ3Zpc3VhbCcsIHNldERpcnR5OiB0cnVlfSk7XG4gICAgLy8gcmVuZGVyKHRoaXMsIHRoaXMuX21vZGVsLCB0aGlzLl9hcGksIHBheWxvYWQpO1xuICAgIC8vIHBlcmZvcm1Qb3N0VXBkYXRlRnVuY3MoZWNNb2RlbCwgdGhpcy5fYXBpKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUxheW91dDogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICB1cGRhdGVNZXRob2RzLnVwZGF0ZS5jYWxsKHRoaXMsIHBheWxvYWQpOyAvLyB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgIC8vIC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG4gICAgLy8gaWYgKCFlY01vZGVsKSB7XG4gICAgLy8gICAgIHJldHVybjtcbiAgICAvLyB9XG4gICAgLy8gQ2hhcnRWaWV3Lm1hcmtVcGRhdGVNZXRob2QocGF5bG9hZCwgJ3VwZGF0ZUxheW91dCcpO1xuICAgIC8vIC8vIEtlZXAgcGlwZSB0byB0aGUgZXhpc3QgcGlwZWxpbmUgYmVjYXVzZSBpdCBkZXBlbmRzIG9uIHRoZSByZW5kZXIgdGFzayBvZiB0aGUgZnVsbCBwaXBlbGluZS5cbiAgICAvLyAvLyB0aGlzLl9zY2hlZHVsZXIucGVyZm9ybVZpc3VhbFRhc2tzKGVjTW9kZWwsIHBheWxvYWQsICdsYXlvdXQnLCB0cnVlKTtcbiAgICAvLyB0aGlzLl9zY2hlZHVsZXIucGVyZm9ybVZpc3VhbFRhc2tzKGVjTW9kZWwsIHBheWxvYWQsIHtzZXREaXJ0eTogdHJ1ZX0pO1xuICAgIC8vIHJlbmRlcih0aGlzLCB0aGlzLl9tb2RlbCwgdGhpcy5fYXBpLCBwYXlsb2FkKTtcbiAgICAvLyBwZXJmb3JtUG9zdFVwZGF0ZUZ1bmNzKGVjTW9kZWwsIHRoaXMuX2FwaSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHByZXBhcmUoZWNJbnMpIHtcbiAgdmFyIGVjTW9kZWwgPSBlY0lucy5fbW9kZWw7XG4gIHZhciBzY2hlZHVsZXIgPSBlY0lucy5fc2NoZWR1bGVyO1xuICBzY2hlZHVsZXIucmVzdG9yZVBpcGVsaW5lcyhlY01vZGVsKTtcbiAgc2NoZWR1bGVyLnByZXBhcmVTdGFnZVRhc2tzKCk7XG4gIHByZXBhcmVWaWV3KGVjSW5zLCAnY29tcG9uZW50JywgZWNNb2RlbCwgc2NoZWR1bGVyKTtcbiAgcHJlcGFyZVZpZXcoZWNJbnMsICdjaGFydCcsIGVjTW9kZWwsIHNjaGVkdWxlcik7XG4gIHNjaGVkdWxlci5wbGFuKCk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RseShlY0lucywgbWV0aG9kLCBwYXlsb2FkLCBtYWluVHlwZSwgc3ViVHlwZSkge1xuICB2YXIgZWNNb2RlbCA9IGVjSW5zLl9tb2RlbDsgLy8gYnJvYWRjYXN0XG5cbiAgaWYgKCFtYWluVHlwZSkge1xuICAgIC8vIEZJWE1FXG4gICAgLy8gQ2hhcnQgd2lsbCBub3QgYmUgdXBkYXRlIGRpcmVjdGx5IGhlcmUsIGV4Y2VwdCBzZXQgZGlydHkuXG4gICAgLy8gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggc2NlbmFyaW8gbm93LlxuICAgIGVhY2goZWNJbnMuX2NvbXBvbmVudHNWaWV3cy5jb25jYXQoZWNJbnMuX2NoYXJ0c1ZpZXdzKSwgY2FsbFZpZXcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBxdWVyeSA9IHt9O1xuICBxdWVyeVttYWluVHlwZSArICdJZCddID0gcGF5bG9hZFttYWluVHlwZSArICdJZCddO1xuICBxdWVyeVttYWluVHlwZSArICdJbmRleCddID0gcGF5bG9hZFttYWluVHlwZSArICdJbmRleCddO1xuICBxdWVyeVttYWluVHlwZSArICdOYW1lJ10gPSBwYXlsb2FkW21haW5UeXBlICsgJ05hbWUnXTtcbiAgdmFyIGNvbmRpdGlvbiA9IHtcbiAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgcXVlcnk6IHF1ZXJ5XG4gIH07XG4gIHN1YlR5cGUgJiYgKGNvbmRpdGlvbi5zdWJUeXBlID0gc3ViVHlwZSk7IC8vIHN1YlR5cGUgbWF5IGJlICcnIGJ5IHBhcnNlQ2xhc3NUeXBlO1xuXG4gIHZhciBleGNsdWRlU2VyaWVzSWQgPSBwYXlsb2FkLmV4Y2x1ZGVTZXJpZXNJZDtcblxuICBpZiAoZXhjbHVkZVNlcmllc0lkICE9IG51bGwpIHtcbiAgICBleGNsdWRlU2VyaWVzSWQgPSB6clV0aWwuY3JlYXRlSGFzaE1hcChtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShleGNsdWRlU2VyaWVzSWQpKTtcbiAgfSAvLyBJZiBkaXNwYXRjaEFjdGlvbiBiZWZvcmUgc2V0T3B0aW9uLCBkbyBub3RoaW5nLlxuXG5cbiAgZWNNb2RlbCAmJiBlY01vZGVsLmVhY2hDb21wb25lbnQoY29uZGl0aW9uLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICBpZiAoIWV4Y2x1ZGVTZXJpZXNJZCB8fCBleGNsdWRlU2VyaWVzSWQuZ2V0KG1vZGVsLmlkKSA9PSBudWxsKSB7XG4gICAgICBjYWxsVmlldyhlY0luc1ttYWluVHlwZSA9PT0gJ3NlcmllcycgPyAnX2NoYXJ0c01hcCcgOiAnX2NvbXBvbmVudHNNYXAnXVttb2RlbC5fX3ZpZXdJZF0pO1xuICAgIH1cbiAgfSwgZWNJbnMpO1xuXG4gIGZ1bmN0aW9uIGNhbGxWaWV3KHZpZXcpIHtcbiAgICB2aWV3ICYmIHZpZXcuX19hbGl2ZSAmJiB2aWV3W21ldGhvZF0gJiYgdmlld1ttZXRob2RdKHZpZXcuX19tb2RlbCwgZWNNb2RlbCwgZWNJbnMuX2FwaSwgcGF5bG9hZCk7XG4gIH1cbn1cbi8qKlxuICogUmVzaXplIHRoZSBjaGFydFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2lsZW50PWZhbHNlXVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHRoaXMuX3pyLnJlc2l6ZShvcHRzKTtcblxuICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsOyAvLyBSZXNpemUgbG9hZGluZyBlZmZlY3RcblxuICB0aGlzLl9sb2FkaW5nRlggJiYgdGhpcy5fbG9hZGluZ0ZYLnJlc2l6ZSgpO1xuXG4gIGlmICghZWNNb2RlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvcHRpb25DaGFuZ2VkID0gZWNNb2RlbC5yZXNldE9wdGlvbignbWVkaWEnKTtcbiAgdmFyIHNpbGVudCA9IG9wdHMgJiYgb3B0cy5zaWxlbnQ7XG4gIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG4gIG9wdGlvbkNoYW5nZWQgJiYgcHJlcGFyZSh0aGlzKTtcbiAgdXBkYXRlTWV0aG9kcy51cGRhdGUuY2FsbCh0aGlzKTtcbiAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG4gIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICB0cmlnZ2VyVXBkYXRlZEV2ZW50LmNhbGwodGhpcywgc2lsZW50KTtcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0cmVhbU1vZGVzKGVjSW5zLCBlY01vZGVsKSB7XG4gIHZhciBjaGFydHNNYXAgPSBlY0lucy5fY2hhcnRzTWFwO1xuICB2YXIgc2NoZWR1bGVyID0gZWNJbnMuX3NjaGVkdWxlcjtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHNjaGVkdWxlci51cGRhdGVTdHJlYW1Nb2RlcyhzZXJpZXNNb2RlbCwgY2hhcnRzTWFwW3Nlcmllc01vZGVsLl9fdmlld0lkXSk7XG4gIH0pO1xufVxuLyoqXG4gKiBTaG93IGxvYWRpbmcgZWZmZWN0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtuYW1lPSdkZWZhdWx0J11cbiAqIEBwYXJhbSAge09iamVjdH0gW2NmZ11cbiAqL1xuXG5cbmVjaGFydHNQcm90by5zaG93TG9hZGluZyA9IGZ1bmN0aW9uIChuYW1lLCBjZmcpIHtcbiAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgY2ZnID0gbmFtZTtcbiAgICBuYW1lID0gJyc7XG4gIH1cblxuICBuYW1lID0gbmFtZSB8fCAnZGVmYXVsdCc7XG4gIHRoaXMuaGlkZUxvYWRpbmcoKTtcblxuICBpZiAoIWxvYWRpbmdFZmZlY3RzW25hbWVdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVsID0gbG9hZGluZ0VmZmVjdHNbbmFtZV0odGhpcy5fYXBpLCBjZmcpO1xuICB2YXIgenIgPSB0aGlzLl96cjtcbiAgdGhpcy5fbG9hZGluZ0ZYID0gZWw7XG4gIHpyLmFkZChlbCk7XG59O1xuLyoqXG4gKiBIaWRlIGxvYWRpbmcgZWZmZWN0XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uaGlkZUxvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2xvYWRpbmdGWCAmJiB0aGlzLl96ci5yZW1vdmUodGhpcy5fbG9hZGluZ0ZYKTtcbiAgdGhpcy5fbG9hZGluZ0ZYID0gbnVsbDtcbn07XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudE9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLm1ha2VBY3Rpb25Gcm9tRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRPYmopIHtcbiAgdmFyIHBheWxvYWQgPSB6clV0aWwuZXh0ZW5kKHt9LCBldmVudE9iaik7XG4gIHBheWxvYWQudHlwZSA9IGV2ZW50QWN0aW9uTWFwW2V2ZW50T2JqLnR5cGVdO1xuICByZXR1cm4gcGF5bG9hZDtcbn07XG4vKipcbiAqIEBwdWJpbGNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BheWxvYWQudHlwZV0gQWN0aW9uIHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtvcHRdIElmIHBhc3MgYm9vbGVhbiwgbWVhbnMgb3B0LnNpbGVudFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0LnNpbGVudD1mYWxzZV0gV2hldGhlciB0cmlnZ2VyIGV2ZW50cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5mbHVzaD11bmRlZmluZWRdXG4gKiAgICAgICAgICAgICAgICAgIHRydWU6IEZsdXNoIGltbWVkaWF0ZWx5LCBhbmQgdGhlbiBwaXhlbCBpbiBjYW52YXMgY2FuIGJlIGZldGNoZWRcbiAqICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5LiBDYXV0aW9uOiBpdCBtaWdodCBhZmZlY3QgcGVyZm9ybWFuY2UuXG4gKiAgICAgICAgICAgICAgICAgIGZhbHNlOiBOb3Qgbm90IGZsdXNoLlxuICogICAgICAgICAgICAgICAgICB1bmRlZmluZWQ6IEF1dG8gZGVjaWRlIHdoZXRoZXIgcGVyZm9ybSBmbHVzaC5cbiAqL1xuXG5cbmVjaGFydHNQcm90by5kaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkLCBvcHQpIHtcbiAgaWYgKCFpc09iamVjdChvcHQpKSB7XG4gICAgb3B0ID0ge1xuICAgICAgc2lsZW50OiAhIW9wdFxuICAgIH07XG4gIH1cblxuICBpZiAoIWFjdGlvbnNbcGF5bG9hZC50eXBlXSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBBdm9pZCBkaXNwYXRjaCBhY3Rpb24gYmVmb3JlIHNldE9wdGlvbi4gRXNwZWNpYWxseSBpbiBgY29ubmVjdGAuXG5cblxuICBpZiAoIXRoaXMuX21vZGVsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE1heSBkaXNwYXRjaEFjdGlvbiBpbiByZW5kZXJpbmcgcHJvY2VkdXJlXG5cblxuICBpZiAodGhpc1tJTl9NQUlOX1BST0NFU1NdKSB7XG4gICAgdGhpcy5fcGVuZGluZ0FjdGlvbnMucHVzaChwYXlsb2FkKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGRvRGlzcGF0Y2hBY3Rpb24uY2FsbCh0aGlzLCBwYXlsb2FkLCBvcHQuc2lsZW50KTtcblxuICBpZiAob3B0LmZsdXNoKSB7XG4gICAgdGhpcy5fenIuZmx1c2godHJ1ZSk7XG4gIH0gZWxzZSBpZiAob3B0LmZsdXNoICE9PSBmYWxzZSAmJiBlbnYuYnJvd3Nlci53ZUNoYXQpIHtcbiAgICAvLyBJbiBXZUNoYXQgZW1iZWRlZCBicm93c2VyLCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhbmQgYHNldEludGVydmFsYFxuICAgIC8vIGhhbmcgd2hlbiBzbGlkaW5nIHBhZ2UgKG9uIHRvdWNoIGV2ZW50KSwgd2hpY2ggY2F1c2UgdGhhdCB6ciBkb2VzIG5vdFxuICAgIC8vIHJlZnJlc2ggdXRpbCB1c2VyIGludGVyYWN0aW9uIGZpbmlzaGVkLCB3aGljaCBpcyBub3QgZXhwZWN0ZWQuXG4gICAgLy8gQnV0IGBkaXNwYXRjaEFjdGlvbmAgbWF5IGJlIGNhbGxlZCB0b28gZnJlcXVlbnRseSB3aGVuIHBhbiBvbiB0b3VjaFxuICAgIC8vIHNjcmVlbiwgd2hpY2ggaW1wYWN0cyBwZXJmb3JtYW5jZSBpZiBkbyBub3QgdGhyb3R0bGUgdGhlbS5cbiAgICB0aGlzLl90aHJvdHRsZWRackZsdXNoKCk7XG4gIH1cblxuICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgb3B0LnNpbGVudCk7XG4gIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBvcHQuc2lsZW50KTtcbn07XG5cbmZ1bmN0aW9uIGRvRGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCwgc2lsZW50KSB7XG4gIHZhciBwYXlsb2FkVHlwZSA9IHBheWxvYWQudHlwZTtcbiAgdmFyIGVzY2FwZUNvbm5lY3QgPSBwYXlsb2FkLmVzY2FwZUNvbm5lY3Q7XG4gIHZhciBhY3Rpb25XcmFwID0gYWN0aW9uc1twYXlsb2FkVHlwZV07XG4gIHZhciBhY3Rpb25JbmZvID0gYWN0aW9uV3JhcC5hY3Rpb25JbmZvO1xuICB2YXIgY3B0VHlwZSA9IChhY3Rpb25JbmZvLnVwZGF0ZSB8fCAndXBkYXRlJykuc3BsaXQoJzonKTtcbiAgdmFyIHVwZGF0ZU1ldGhvZCA9IGNwdFR5cGUucG9wKCk7XG4gIGNwdFR5cGUgPSBjcHRUeXBlWzBdICE9IG51bGwgJiYgcGFyc2VDbGFzc1R5cGUoY3B0VHlwZVswXSk7XG4gIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG4gIHZhciBwYXlsb2FkcyA9IFtwYXlsb2FkXTtcbiAgdmFyIGJhdGNoZWQgPSBmYWxzZTsgLy8gQmF0Y2ggYWN0aW9uXG5cbiAgaWYgKHBheWxvYWQuYmF0Y2gpIHtcbiAgICBiYXRjaGVkID0gdHJ1ZTtcbiAgICBwYXlsb2FkcyA9IHpyVXRpbC5tYXAocGF5bG9hZC5iYXRjaCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGl0ZW0gPSB6clV0aWwuZGVmYXVsdHMoenJVdGlsLmV4dGVuZCh7fSwgaXRlbSksIHBheWxvYWQpO1xuICAgICAgaXRlbS5iYXRjaCA9IG51bGw7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBldmVudE9iakJhdGNoID0gW107XG4gIHZhciBldmVudE9iajtcbiAgdmFyIGlzSGlnaERvd24gPSBwYXlsb2FkVHlwZSA9PT0gJ2hpZ2hsaWdodCcgfHwgcGF5bG9hZFR5cGUgPT09ICdkb3ducGxheSc7XG4gIGVhY2gocGF5bG9hZHMsIGZ1bmN0aW9uIChiYXRjaEl0ZW0pIHtcbiAgICAvLyBBY3Rpb24gY2FuIHNwZWNpZnkgdGhlIGV2ZW50IGJ5IHJldHVybiBpdC5cbiAgICBldmVudE9iaiA9IGFjdGlvbldyYXAuYWN0aW9uKGJhdGNoSXRlbSwgdGhpcy5fbW9kZWwsIHRoaXMuX2FwaSk7IC8vIEVtaXQgZXZlbnQgb3V0c2lkZVxuXG4gICAgZXZlbnRPYmogPSBldmVudE9iaiB8fCB6clV0aWwuZXh0ZW5kKHt9LCBiYXRjaEl0ZW0pOyAvLyBDb252ZXJ0IHR5cGUgdG8gZXZlbnRUeXBlXG5cbiAgICBldmVudE9iai50eXBlID0gYWN0aW9uSW5mby5ldmVudCB8fCBldmVudE9iai50eXBlO1xuICAgIGV2ZW50T2JqQmF0Y2gucHVzaChldmVudE9iaik7IC8vIGxpZ2h0IHVwZGF0ZSBkb2VzIG5vdCBwZXJmb3JtIGRhdGEgcHJvY2VzcywgbGF5b3V0IGFuZCB2aXN1YWwuXG5cbiAgICBpZiAoaXNIaWdoRG93bikge1xuICAgICAgLy8gbWV0aG9kLCBwYXlsb2FkLCBtYWluVHlwZSwgc3ViVHlwZVxuICAgICAgdXBkYXRlRGlyZWN0bHkodGhpcywgdXBkYXRlTWV0aG9kLCBiYXRjaEl0ZW0sICdzZXJpZXMnKTtcbiAgICB9IGVsc2UgaWYgKGNwdFR5cGUpIHtcbiAgICAgIHVwZGF0ZURpcmVjdGx5KHRoaXMsIHVwZGF0ZU1ldGhvZCwgYmF0Y2hJdGVtLCBjcHRUeXBlLm1haW4sIGNwdFR5cGUuc3ViKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIGlmICh1cGRhdGVNZXRob2QgIT09ICdub25lJyAmJiAhaXNIaWdoRG93biAmJiAhY3B0VHlwZSkge1xuICAgIC8vIFN0aWxsIGRpcnR5XG4gICAgaWYgKHRoaXNbT1BUSU9OX1VQREFURURdKSB7XG4gICAgICAvLyBGSVhNRSBQYXNzIHBheWxvYWQgP1xuICAgICAgcHJlcGFyZSh0aGlzKTtcbiAgICAgIHVwZGF0ZU1ldGhvZHMudXBkYXRlLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVNZXRob2RzW3VwZGF0ZU1ldGhvZF0uY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICB9XG4gIH0gLy8gRm9sbG93IHRoZSBydWxlIG9mIGFjdGlvbiBiYXRjaFxuXG5cbiAgaWYgKGJhdGNoZWQpIHtcbiAgICBldmVudE9iaiA9IHtcbiAgICAgIHR5cGU6IGFjdGlvbkluZm8uZXZlbnQgfHwgcGF5bG9hZFR5cGUsXG4gICAgICBlc2NhcGVDb25uZWN0OiBlc2NhcGVDb25uZWN0LFxuICAgICAgYmF0Y2g6IGV2ZW50T2JqQmF0Y2hcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGV2ZW50T2JqID0gZXZlbnRPYmpCYXRjaFswXTtcbiAgfVxuXG4gIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICAhc2lsZW50ICYmIHRoaXMuX21lc3NhZ2VDZW50ZXIudHJpZ2dlcihldmVudE9iai50eXBlLCBldmVudE9iaik7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGVuZGluZ0FjdGlvbnMoc2lsZW50KSB7XG4gIHZhciBwZW5kaW5nQWN0aW9ucyA9IHRoaXMuX3BlbmRpbmdBY3Rpb25zO1xuXG4gIHdoaWxlIChwZW5kaW5nQWN0aW9ucy5sZW5ndGgpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHBlbmRpbmdBY3Rpb25zLnNoaWZ0KCk7XG4gICAgZG9EaXNwYXRjaEFjdGlvbi5jYWxsKHRoaXMsIHBheWxvYWQsIHNpbGVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZWRFdmVudChzaWxlbnQpIHtcbiAgIXNpbGVudCAmJiB0aGlzLnRyaWdnZXIoJ3VwZGF0ZWQnKTtcbn1cbi8qKlxuICogRXZlbnQgYHJlbmRlcmVkYCBpcyB0cmlnZ2VyZWQgd2hlbiB6clxuICogcmVuZGVyZWQuIEl0IGlzIHVzZWZ1bCBmb3IgcmVhbHRpbWVcbiAqIHNuYXBzaG90IChyZWZsZWN0IGFuaW1hdGlvbikuXG4gKlxuICogRXZlbnQgYGZpbmlzaGVkYCBpcyB0cmlnZ2VyZWQgd2hlbjpcbiAqICgxKSB6cmVuZGVyIHJlbmRlcmluZyBmaW5pc2hlZC5cbiAqICgyKSBpbml0aWFsIGFuaW1hdGlvbiBmaW5pc2hlZC5cbiAqICgzKSBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgZmluaXNoZWQuXG4gKiAoNCkgbm8gcGVuZGluZyBhY3Rpb24uXG4gKiAoNSkgbm8gZGVsYXllZCBzZXRPcHRpb24gbmVlZHMgdG8gYmUgcHJvY2Vzc2VkLlxuICovXG5cblxuZnVuY3Rpb24gYmluZFJlbmRlcmVkRXZlbnQoenIsIGVjSW5zKSB7XG4gIHpyLm9uKCdyZW5kZXJlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBlY0lucy50cmlnZ2VyKCdyZW5kZXJlZCcpOyAvLyBUaGUgYGZpbmlzaGVkYCBldmVudCBzaG91bGQgbm90IGJlIHRyaWdnZXJlZCByZXBlYXRseSxcbiAgICAvLyBzbyBpdCBzaG91bGQgb25seSBiZSB0cmlnZ2VyZWQgd2hlbiByZW5kZXJpbmcgaW5kZWVkIGhhcHBlbmRcbiAgICAvLyBpbiB6cmVuZGVyLiAoQ29uc2lkZXIgdGhlIGNhc2UgdGhhdCBkaXBhdGNoQWN0aW9uIGlzIGtlZXBcbiAgICAvLyB0cmlnZ2VyaW5nIHdoZW4gbW91c2UgbW92ZSkuXG5cbiAgICBpZiAoIC8vIEFsdGhvdWdoIHpyIGlzIGRpcnR5IGlmIGluaXRpYWwgYW5pbWF0aW9uIGlzIG5vdCBmaW5pc2hlZFxuICAgIC8vIGFuZCB0aGlzIGNoZWNraW5nIGlzIGNhbGxlZCBvbiBmcmFtZSwgd2UgYWxzbyBjaGVja1xuICAgIC8vIGFuaW1hdGlvbiBmaW5pc2hlZCBmb3Igcm9idXN0bmVzcy5cbiAgICB6ci5hbmltYXRpb24uaXNGaW5pc2hlZCgpICYmICFlY0luc1tPUFRJT05fVVBEQVRFRF0gJiYgIWVjSW5zLl9zY2hlZHVsZXIudW5maW5pc2hlZCAmJiAhZWNJbnMuX3BlbmRpbmdBY3Rpb25zLmxlbmd0aCkge1xuICAgICAgZWNJbnMudHJpZ2dlcignZmluaXNoZWQnKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnNlcmllc0luZGV4XG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IHBhcmFtcy5kYXRhXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uYXBwZW5kRGF0YSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgdmFyIHNlcmllc0luZGV4ID0gcGFyYW1zLnNlcmllc0luZGV4O1xuICB2YXIgZWNNb2RlbCA9IHRoaXMuZ2V0TW9kZWwoKTtcbiAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KHNlcmllc0luZGV4KTtcbiAgc2VyaWVzTW9kZWwuYXBwZW5kRGF0YShwYXJhbXMpOyAvLyBOb3RlOiBgYXBwZW5kRGF0YWAgZG9lcyBub3Qgc3VwcG9ydCB0aGF0IHVwZGF0ZSBleHRlbnQgb2YgY29vcmRpbmF0ZVxuICAvLyBzeXN0ZW0sIHV0aWwgc29tZSBzY2VuYXJpbyByZXF1aXJlIHRoYXQuIEluIHRoZSBleHBlY3RlZCB1c2FnZSBvZlxuICAvLyBgYXBwZW5kRGF0YWAsIHRoZSBpbml0aWFsIGV4dGVudCBvZiBjb29yZGluYXRlIHN5c3RlbSBzaG91bGQgYmV0dGVyXG4gIC8vIGJlIGZpeGVkIGJ5IGF4aXMgYG1pbmAvYG1heGAgc2V0dGluZyBvciBpbml0aWFsIGRhdGEsIG90aGVyd2lzZSBpZlxuICAvLyB0aGUgZXh0ZW50IGNoYW5nZWQgd2hpbGUgYGFwcGVuZERhdGFgLCB0aGUgbG9jYXRpb24gb2YgdGhlIHBhaW50ZWRcbiAgLy8gZ3JhcGhpYyBlbGVtZW50cyBoYXZlIHRvIGJlIGNoYW5nZWQsIHdoaWNoIG1ha2UgdGhlIHVzYWdlIG9mXG4gIC8vIGBhcHBlbmREYXRhYCBtZWFuaW5nbGVzcy5cblxuICB0aGlzLl9zY2hlZHVsZXIudW5maW5pc2hlZCA9IHRydWU7XG59O1xuLyoqXG4gKiBSZWdpc3RlciBldmVudFxuICogQG1ldGhvZFxuICovXG5cblxuZWNoYXJ0c1Byb3RvLm9uID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbicpO1xuZWNoYXJ0c1Byb3RvLm9mZiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb2ZmJyk7XG5lY2hhcnRzUHJvdG8ub25lID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbmUnKTtcbi8qKlxuICogUHJlcGFyZSB2aWV3IGluc3RhbmNlcyBvZiBjaGFydHMgYW5kIGNvbXBvbmVudHNcbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwcmVwYXJlVmlldyhlY0lucywgdHlwZSwgZWNNb2RlbCwgc2NoZWR1bGVyKSB7XG4gIHZhciBpc0NvbXBvbmVudCA9IHR5cGUgPT09ICdjb21wb25lbnQnO1xuICB2YXIgdmlld0xpc3QgPSBpc0NvbXBvbmVudCA/IGVjSW5zLl9jb21wb25lbnRzVmlld3MgOiBlY0lucy5fY2hhcnRzVmlld3M7XG4gIHZhciB2aWV3TWFwID0gaXNDb21wb25lbnQgPyBlY0lucy5fY29tcG9uZW50c01hcCA6IGVjSW5zLl9jaGFydHNNYXA7XG4gIHZhciB6ciA9IGVjSW5zLl96cjtcbiAgdmFyIGFwaSA9IGVjSW5zLl9hcGk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZpZXdMaXN0W2ldLl9fYWxpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIGlzQ29tcG9uZW50ID8gZWNNb2RlbC5lYWNoQ29tcG9uZW50KGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBtb2RlbCkge1xuICAgIGNvbXBvbmVudFR5cGUgIT09ICdzZXJpZXMnICYmIGRvUHJlcGFyZShtb2RlbCk7XG4gIH0pIDogZWNNb2RlbC5lYWNoU2VyaWVzKGRvUHJlcGFyZSk7XG5cbiAgZnVuY3Rpb24gZG9QcmVwYXJlKG1vZGVsKSB7XG4gICAgLy8gQ29uc2lkZXI6IGlkIHNhbWUgYW5kIHR5cGUgY2hhbmdlZC5cbiAgICB2YXIgdmlld0lkID0gJ19lY18nICsgbW9kZWwuaWQgKyAnXycgKyBtb2RlbC50eXBlO1xuICAgIHZhciB2aWV3ID0gdmlld01hcFt2aWV3SWRdO1xuXG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUobW9kZWwudHlwZSk7XG4gICAgICB2YXIgQ2xhenogPSBpc0NvbXBvbmVudCA/IENvbXBvbmVudFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIpIDogQ2hhcnRWaWV3LmdldENsYXNzKGNsYXNzVHlwZS5zdWIpO1xuICAgICAgdmlldyA9IG5ldyBDbGF6eigpO1xuICAgICAgdmlldy5pbml0KGVjTW9kZWwsIGFwaSk7XG4gICAgICB2aWV3TWFwW3ZpZXdJZF0gPSB2aWV3O1xuICAgICAgdmlld0xpc3QucHVzaCh2aWV3KTtcbiAgICAgIHpyLmFkZCh2aWV3Lmdyb3VwKTtcbiAgICB9XG5cbiAgICBtb2RlbC5fX3ZpZXdJZCA9IHZpZXcuX19pZCA9IHZpZXdJZDtcbiAgICB2aWV3Ll9fYWxpdmUgPSB0cnVlO1xuICAgIHZpZXcuX19tb2RlbCA9IG1vZGVsO1xuICAgIHZpZXcuZ3JvdXAuX19lY0NvbXBvbmVudEluZm8gPSB7XG4gICAgICBtYWluVHlwZTogbW9kZWwubWFpblR5cGUsXG4gICAgICBpbmRleDogbW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICB9O1xuICAgICFpc0NvbXBvbmVudCAmJiBzY2hlZHVsZXIucHJlcGFyZVZpZXcodmlldywgbW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDspIHtcbiAgICB2YXIgdmlldyA9IHZpZXdMaXN0W2ldO1xuXG4gICAgaWYgKCF2aWV3Ll9fYWxpdmUpIHtcbiAgICAgICFpc0NvbXBvbmVudCAmJiB2aWV3LnJlbmRlclRhc2suZGlzcG9zZSgpO1xuICAgICAgenIucmVtb3ZlKHZpZXcuZ3JvdXApO1xuICAgICAgdmlldy5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgICB2aWV3TGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICBkZWxldGUgdmlld01hcFt2aWV3Ll9faWRdO1xuICAgICAgdmlldy5fX2lkID0gdmlldy5ncm91cC5fX2VjQ29tcG9uZW50SW5mbyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbn0gLy8gLyoqXG4vLyAgKiBFbmNvZGUgdmlzdWFsIGluZm9tYXRpb24gZnJvbSBkYXRhIGFmdGVyIGRhdGEgcHJvY2Vzc2luZ1xuLy8gICpcbi8vICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4vLyAgKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0XG4vLyAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsYXlvdXRGaWx0ZXJdIGB0cnVlYDogb25seSBsYXlvdXQsXG4vLyAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBmYWxzZWA6IG9ubHkgbm90IGxheW91dCxcbi8vICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYG51bGxgL2B1bmRlZmluZWRgOiBhbGwuXG4vLyAgKiBAcGFyYW0ge3N0cmluZ30gdGFza0Jhc2VUYWdcbi8vICAqIEBwcml2YXRlXG4vLyAgKi9cbi8vIGZ1bmN0aW9uIHN0YXJ0VmlzdWFsRW5jb2RpbmcoZWNJbnMsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgbGF5b3V0RmlsdGVyKSB7XG4vLyAgICAgZWFjaCh2aXN1YWxGdW5jcywgZnVuY3Rpb24gKHZpc3VhbCwgaW5kZXgpIHtcbi8vICAgICAgICAgdmFyIGlzTGF5b3V0ID0gdmlzdWFsLmlzTGF5b3V0O1xuLy8gICAgICAgICBpZiAobGF5b3V0RmlsdGVyID09IG51bGxcbi8vICAgICAgICAgICAgIHx8IChsYXlvdXRGaWx0ZXIgPT09IGZhbHNlICYmICFpc0xheW91dClcbi8vICAgICAgICAgICAgIHx8IChsYXlvdXRGaWx0ZXIgPT09IHRydWUgJiYgaXNMYXlvdXQpXG4vLyAgICAgICAgICkge1xuLy8gICAgICAgICAgICAgdmlzdWFsLmZ1bmMoZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH0pO1xuLy8gfVxuXG5cbmZ1bmN0aW9uIGNsZWFyQ29sb3JQYWxldHRlKGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5jbGVhckNvbG9yUGFsZXR0ZSgpO1xuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgc2VyaWVzTW9kZWwuY2xlYXJDb2xvclBhbGV0dGUoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcihlY0lucywgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gIHJlbmRlckNvbXBvbmVudHMoZWNJbnMsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIGVhY2goZWNJbnMuX2NoYXJ0c1ZpZXdzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICBjaGFydC5fX2FsaXZlID0gZmFsc2U7XG4gIH0pO1xuICByZW5kZXJTZXJpZXMoZWNJbnMsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7IC8vIFJlbW92ZSBncm91cHMgb2YgdW5yZW5kZXJlZCBjaGFydHNcblxuICBlYWNoKGVjSW5zLl9jaGFydHNWaWV3cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgaWYgKCFjaGFydC5fX2FsaXZlKSB7XG4gICAgICBjaGFydC5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRzKGVjSW5zLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIGRpcnR5TGlzdCkge1xuICBlYWNoKGRpcnR5TGlzdCB8fCBlY0lucy5fY29tcG9uZW50c1ZpZXdzLCBmdW5jdGlvbiAoY29tcG9uZW50Vmlldykge1xuICAgIHZhciBjb21wb25lbnRNb2RlbCA9IGNvbXBvbmVudFZpZXcuX19tb2RlbDtcbiAgICBjb21wb25lbnRWaWV3LnJlbmRlcihjb21wb25lbnRNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB1cGRhdGVaKGNvbXBvbmVudE1vZGVsLCBjb21wb25lbnRWaWV3KTtcbiAgfSk7XG59XG4vKipcbiAqIFJlbmRlciBlYWNoIGNoYXJ0IGFuZCBjb21wb25lbnRcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiByZW5kZXJTZXJpZXMoZWNJbnMsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgZGlydHlNYXApIHtcbiAgLy8gUmVuZGVyIGFsbCBjaGFydHNcbiAgdmFyIHNjaGVkdWxlciA9IGVjSW5zLl9zY2hlZHVsZXI7XG4gIHZhciB1bmZpbmlzaGVkO1xuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGNoYXJ0VmlldyA9IGVjSW5zLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgIGNoYXJ0Vmlldy5fX2FsaXZlID0gdHJ1ZTtcbiAgICB2YXIgcmVuZGVyVGFzayA9IGNoYXJ0Vmlldy5yZW5kZXJUYXNrO1xuICAgIHNjaGVkdWxlci51cGRhdGVQYXlsb2FkKHJlbmRlclRhc2ssIHBheWxvYWQpO1xuXG4gICAgaWYgKGRpcnR5TWFwICYmIGRpcnR5TWFwLmdldChzZXJpZXNNb2RlbC51aWQpKSB7XG4gICAgICByZW5kZXJUYXNrLmRpcnR5KCk7XG4gICAgfVxuXG4gICAgdW5maW5pc2hlZCB8PSByZW5kZXJUYXNrLnBlcmZvcm0oc2NoZWR1bGVyLmdldFBlcmZvcm1BcmdzKHJlbmRlclRhc2spKTtcbiAgICBjaGFydFZpZXcuZ3JvdXAuc2lsZW50ID0gISFzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuICAgIHVwZGF0ZVooc2VyaWVzTW9kZWwsIGNoYXJ0Vmlldyk7XG4gICAgdXBkYXRlQmxlbmQoc2VyaWVzTW9kZWwsIGNoYXJ0Vmlldyk7XG4gIH0pO1xuICBzY2hlZHVsZXIudW5maW5pc2hlZCB8PSB1bmZpbmlzaGVkOyAvLyBJZiB1c2UgaG92ZXIgbGF5ZXJcblxuICB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKGVjSW5zLl96ciwgZWNNb2RlbCk7IC8vIEFkZCBhcmlhXG5cbiAgYXJpYShlY0lucy5fenIuZG9tLCBlY01vZGVsKTtcbn1cblxuZnVuY3Rpb24gcGVyZm9ybVBvc3RVcGRhdGVGdW5jcyhlY01vZGVsLCBhcGkpIHtcbiAgZWFjaChwb3N0VXBkYXRlRnVuY3MsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyhlY01vZGVsLCBhcGkpO1xuICB9KTtcbn1cblxudmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ2dsb2JhbG91dCcsICdjb250ZXh0bWVudSddO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmVjaGFydHNQcm90by5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcbiAgICB0aGlzLl96ci5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmdldE1vZGVsKCk7XG4gICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgIHZhciBwYXJhbXM7IC8vIG5vIGUudGFyZ2V0IHdoZW4gJ2dsb2JhbG91dCcuXG5cbiAgICAgIGlmIChldmVOYW1lID09PSAnZ2xvYmFsb3V0Jykge1xuICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgIH0gZWxzZSBpZiAoZWwgJiYgZWwuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRhdGFNb2RlbCA9IGVsLmRhdGFNb2RlbCB8fCBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoZWwuc2VyaWVzSW5kZXgpO1xuICAgICAgICBwYXJhbXMgPSBkYXRhTW9kZWwgJiYgZGF0YU1vZGVsLmdldERhdGFQYXJhbXMoZWwuZGF0YUluZGV4LCBlbC5kYXRhVHlwZSkgfHwge307XG4gICAgICB9IC8vIElmIGVsZW1lbnQgaGFzIGN1c3RvbSBldmVudERhdGEgb2YgY29tcG9uZW50c1xuICAgICAgZWxzZSBpZiAoZWwgJiYgZWwuZXZlbnREYXRhKSB7XG4gICAgICAgICAgcGFyYW1zID0genJVdGlsLmV4dGVuZCh7fSwgZWwuZXZlbnREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XG4gICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sIHRoaXMpO1xuICBlYWNoKGV2ZW50QWN0aW9uTWFwLCBmdW5jdGlvbiAoYWN0aW9uVHlwZSwgZXZlbnRUeXBlKSB7XG4gICAgdGhpcy5fbWVzc2FnZUNlbnRlci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgIH0sIHRoaXMpO1xuICB9LCB0aGlzKTtcbn07XG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uaXNEaXNwb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xufTtcbi8qKlxuICogQ2xlYXJcbiAqL1xuXG5cbmVjaGFydHNQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXRPcHRpb24oe1xuICAgIHNlcmllczogW11cbiAgfSwgdHJ1ZSk7XG59O1xuLyoqXG4gKiBEaXNwb3NlIGluc3RhbmNlXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuICBtb2RlbFV0aWwuc2V0QXR0cmlidXRlKHRoaXMuZ2V0RG9tKCksIERPTV9BVFRSSUJVVEVfS0VZLCAnJyk7XG4gIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gIGVhY2godGhpcy5fY29tcG9uZW50c1ZpZXdzLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50LmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgfSk7XG4gIGVhY2godGhpcy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgIGNoYXJ0LmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgfSk7IC8vIERpc3Bvc2UgYWZ0ZXIgYWxsIHZpZXdzIGRpc3Bvc2VkXG5cbiAgdGhpcy5fenIuZGlzcG9zZSgpO1xuXG4gIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG59O1xuXG56clV0aWwubWl4aW4oRUNoYXJ0cywgRXZlbnRmdWwpO1xuXG5mdW5jdGlvbiB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHpyLCBlY01vZGVsKSB7XG4gIHZhciBzdG9yYWdlID0genIuc3RvcmFnZTtcbiAgdmFyIGVsQ291bnQgPSAwO1xuICBzdG9yYWdlLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgZWxDb3VudCsrO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGVsQ291bnQgPiBlY01vZGVsLmdldCgnaG92ZXJMYXllclRocmVzaG9sZCcpICYmICFlbnYubm9kZSkge1xuICAgIHN0b3JhZ2UudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgICAgLy8gRG9uJ3Qgc3dpdGNoIGJhY2suXG4gICAgICAgIGVsLnVzZUhvdmVyTGF5ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIFVwZGF0ZSBjaGFydCBwcm9ncmVzc2l2ZSBhbmQgYmxlbmQuXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc3xtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IG1vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9IHZpZXdcbiAqL1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZUJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpIHtcbiAgdmFyIGJsZW5kTW9kZSA9IHNlcmllc01vZGVsLmdldCgnYmxlbmRNb2RlJykgfHwgbnVsbDtcbiAgY2hhcnRWaWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIC8vIEZJWE1FIG1hcmtlciBhbmQgb3RoZXIgY29tcG9uZW50c1xuICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgLy8gT25seSBzZXQgaWYgYmxlbmRNb2RlIGlzIGNoYW5nZWQuIEluIGNhc2UgZWxlbWVudCBpcyBpbmNyZW1lbnRhbCBhbmQgZG9uJ3Qgd2FuJ3QgdG8gcmVyZW5kZXIuXG4gICAgICBpZiAoZWwuc3R5bGUuYmxlbmQgIT09IGJsZW5kTW9kZSkge1xuICAgICAgICBlbC5zZXRTdHlsZSgnYmxlbmQnLCBibGVuZE1vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbC5lYWNoUGVuZGluZ0Rpc3BsYXlhYmxlKSB7XG4gICAgICBlbC5lYWNoUGVuZGluZ0Rpc3BsYXlhYmxlKGZ1bmN0aW9uIChkaXNwbGF5YWJsZSkge1xuICAgICAgICBkaXNwbGF5YWJsZS5zZXRTdHlsZSgnYmxlbmQnLCBibGVuZE1vZGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN8bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBtb2RlbFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudHxtb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0fSB2aWV3XG4gKi9cblxuXG5mdW5jdGlvbiB1cGRhdGVaKG1vZGVsLCB2aWV3KSB7XG4gIHZhciB6ID0gbW9kZWwuZ2V0KCd6Jyk7XG4gIHZhciB6bGV2ZWwgPSBtb2RlbC5nZXQoJ3psZXZlbCcpOyAvLyBTZXQgeiBhbmQgemxldmVsXG5cbiAgdmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgeiAhPSBudWxsICYmIChlbC56ID0geik7XG4gICAgICB6bGV2ZWwgIT0gbnVsbCAmJiAoZWwuemxldmVsID0gemxldmVsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFeHRlbnNpb25BUEkoZWNJbnN0YW5jZSkge1xuICB2YXIgY29vcmRTeXNNZ3IgPSBlY0luc3RhbmNlLl9jb29yZFN5c01ncjtcbiAgcmV0dXJuIHpyVXRpbC5leHRlbmQobmV3IEV4dGVuc2lvbkFQSShlY0luc3RhbmNlKSwge1xuICAgIC8vIEluamVjdCBtZXRob2RzXG4gICAgZ2V0Q29vcmRpbmF0ZVN5c3RlbXM6IHpyVXRpbC5iaW5kKGNvb3JkU3lzTWdyLmdldENvb3JkaW5hdGVTeXN0ZW1zLCBjb29yZFN5c01nciksXG4gICAgZ2V0Q29tcG9uZW50QnlFbGVtZW50OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICB2YXIgbW9kZWxJbmZvID0gZWwuX19lY0NvbXBvbmVudEluZm87XG5cbiAgICAgICAgaWYgKG1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGVjSW5zdGFuY2UuX21vZGVsLmdldENvbXBvbmVudChtb2RlbEluZm8ubWFpblR5cGUsIG1vZGVsSW5mby5pbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0fSBrZXk6IGFjdGlvblR5cGUuXG4gKiBAaW5uZXJcbiAqL1xuXG5cbnZhciBhY3Rpb25zID0ge307XG4vKipcbiAqIE1hcCBldmVudFR5cGUgdG8gYWN0aW9uVHlwZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG52YXIgZXZlbnRBY3Rpb25NYXAgPSB7fTtcbi8qKlxuICogRGF0YSBwcm9jZXNzb3IgZnVuY3Rpb25zIG9mIGVhY2ggc3RhZ2VcbiAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsIEZ1bmN0aW9uPj59XG4gKiBAaW5uZXJcbiAqL1xuXG52YXIgZGF0YVByb2Nlc3NvckZ1bmNzID0gW107XG4vKipcbiAqIEB0eXBlIHtBcnJheS48RnVuY3Rpb24+fVxuICogQGlubmVyXG4gKi9cblxudmFyIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzID0gW107XG4vKipcbiAqIEB0eXBlIHtBcnJheS48RnVuY3Rpb24+fVxuICogQGlubmVyXG4gKi9cblxudmFyIHBvc3RVcGRhdGVGdW5jcyA9IFtdO1xuLyoqXG4gKiBWaXN1YWwgZW5jb2RpbmcgZnVuY3Rpb25zIG9mIGVhY2ggc3RhZ2VcbiAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsIEZ1bmN0aW9uPj59XG4gKi9cblxudmFyIHZpc3VhbEZ1bmNzID0gW107XG4vKipcbiAqIFRoZW1lIHN0b3JhZ2VcbiAqIEB0eXBlIHtPYmplY3QuPGtleSwgT2JqZWN0Pn1cbiAqL1xuXG52YXIgdGhlbWVTdG9yYWdlID0ge307XG4vKipcbiAqIExvYWRpbmcgZWZmZWN0c1xuICovXG5cbnZhciBsb2FkaW5nRWZmZWN0cyA9IHt9O1xudmFyIGluc3RhbmNlcyA9IHt9O1xudmFyIGNvbm5lY3RlZEdyb3VwcyA9IHt9O1xudmFyIGlkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xudmFyIGdyb3VwSWRCYXNlID0gbmV3IERhdGUoKSAtIDA7XG52YXIgRE9NX0FUVFJJQlVURV9LRVkgPSAnX2VjaGFydHNfaW5zdGFuY2VfJztcbnZhciBtYXBEYXRhU3RvcmVzID0ge307XG5cbmZ1bmN0aW9uIGVuYWJsZUNvbm5lY3QoY2hhcnQpIHtcbiAgdmFyIFNUQVRVU19QRU5ESU5HID0gMDtcbiAgdmFyIFNUQVRVU19VUERBVElORyA9IDE7XG4gIHZhciBTVEFUVVNfVVBEQVRFRCA9IDI7XG4gIHZhciBTVEFUVVNfS0VZID0gJ19fY29ubmVjdFVwZGF0ZVN0YXR1cyc7XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKGNoYXJ0cywgc3RhdHVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlckNoYXJ0ID0gY2hhcnRzW2ldO1xuICAgICAgb3RoZXJDaGFydFtTVEFUVVNfS0VZXSA9IHN0YXR1cztcbiAgICB9XG4gIH1cblxuICBlYWNoKGV2ZW50QWN0aW9uTWFwLCBmdW5jdGlvbiAoYWN0aW9uVHlwZSwgZXZlbnRUeXBlKSB7XG4gICAgY2hhcnQuX21lc3NhZ2VDZW50ZXIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChjb25uZWN0ZWRHcm91cHNbY2hhcnQuZ3JvdXBdICYmIGNoYXJ0W1NUQVRVU19LRVldICE9PSBTVEFUVVNfUEVORElORykge1xuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuZXNjYXBlQ29ubmVjdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb24gPSBjaGFydC5tYWtlQWN0aW9uRnJvbUV2ZW50KGV2ZW50KTtcbiAgICAgICAgdmFyIG90aGVyQ2hhcnRzID0gW107XG4gICAgICAgIGVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbiAob3RoZXJDaGFydCkge1xuICAgICAgICAgIGlmIChvdGhlckNoYXJ0ICE9PSBjaGFydCAmJiBvdGhlckNoYXJ0Lmdyb3VwID09PSBjaGFydC5ncm91cCkge1xuICAgICAgICAgICAgb3RoZXJDaGFydHMucHVzaChvdGhlckNoYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVDb25uZWN0ZWRDaGFydHNTdGF0dXMob3RoZXJDaGFydHMsIFNUQVRVU19QRU5ESU5HKTtcbiAgICAgICAgZWFjaChvdGhlckNoYXJ0cywgZnVuY3Rpb24gKG90aGVyQ2hhcnQpIHtcbiAgICAgICAgICBpZiAob3RoZXJDaGFydFtTVEFUVVNfS0VZXSAhPT0gU1RBVFVTX1VQREFUSU5HKSB7XG4gICAgICAgICAgICBvdGhlckNoYXJ0LmRpc3BhdGNoQWN0aW9uKGFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKG90aGVyQ2hhcnRzLCBTVEFUVVNfVVBEQVRFRCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhlbWVdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dIFVzZSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyBieSBkZWZhdWx0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXJdIEN1cnJlbnRseSBvbmx5ICdjYW52YXMnIGlzIHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gVXNlIGNsaWVudFdpZHRoIG9mIHRoZSBpbnB1dCBgZG9tYCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIFVzZSBjbGllbnRIZWlnaHQgb2YgdGhlIGlucHV0IGBkb21gIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaXQoZG9tLCB0aGVtZSwgb3B0cykge1xuICB2YXIgZXhpc3RJbnN0YW5jZSA9IGdldEluc3RhbmNlQnlEb20oZG9tKTtcblxuICBpZiAoZXhpc3RJbnN0YW5jZSkge1xuICAgIHJldHVybiBleGlzdEluc3RhbmNlO1xuICB9XG5cbiAgdmFyIGNoYXJ0ID0gbmV3IEVDaGFydHMoZG9tLCB0aGVtZSwgb3B0cyk7XG4gIGNoYXJ0LmlkID0gJ2VjXycgKyBpZEJhc2UrKztcbiAgaW5zdGFuY2VzW2NoYXJ0LmlkXSA9IGNoYXJ0O1xuICBtb2RlbFV0aWwuc2V0QXR0cmlidXRlKGRvbSwgRE9NX0FUVFJJQlVURV9LRVksIGNoYXJ0LmlkKTtcbiAgZW5hYmxlQ29ubmVjdChjaGFydCk7XG4gIHJldHVybiBjaGFydDtcbn1cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfEFycmF5Ljxtb2R1bGU6ZWNoYXJ0c35FQ2hhcnRzPn0gZ3JvdXBJZFxuICovXG5cblxuZnVuY3Rpb24gY29ubmVjdChncm91cElkKSB7XG4gIC8vIElzIGFycmF5IG9mIGNoYXJ0c1xuICBpZiAoenJVdGlsLmlzQXJyYXkoZ3JvdXBJZCkpIHtcbiAgICB2YXIgY2hhcnRzID0gZ3JvdXBJZDtcbiAgICBncm91cElkID0gbnVsbDsgLy8gSWYgYW55IGNoYXJ0IGhhcyBncm91cFxuXG4gICAgZWFjaChjaGFydHMsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgaWYgKGNoYXJ0Lmdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgZ3JvdXBJZCA9IGNoYXJ0Lmdyb3VwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGdyb3VwSWQgPSBncm91cElkIHx8ICdnXycgKyBncm91cElkQmFzZSsrO1xuICAgIGVhY2goY2hhcnRzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgIGNoYXJ0Lmdyb3VwID0gZ3JvdXBJZDtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZEdyb3Vwc1tncm91cElkXSA9IHRydWU7XG4gIHJldHVybiBncm91cElkO1xufVxuLyoqXG4gKiBAREVQUkVDQVRFRFxuICogQHJldHVybiB7c3RyaW5nfSBncm91cElkXG4gKi9cblxuXG5mdW5jdGlvbiBkaXNDb25uZWN0KGdyb3VwSWQpIHtcbiAgY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdID0gZmFsc2U7XG59XG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gZ3JvdXBJZFxuICovXG5cblxudmFyIGRpc2Nvbm5lY3QgPSBkaXNDb25uZWN0O1xuLyoqXG4gKiBEaXNwb3NlIGEgY2hhcnQgaW5zdGFuY2VcbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzfkVDaGFydHN8SFRNTERvbUVsZW1lbnR8c3RyaW5nfSBjaGFydFxuICovXG5cbmZ1bmN0aW9uIGRpc3Bvc2UoY2hhcnQpIHtcbiAgaWYgKHR5cGVvZiBjaGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGFydCA9IGluc3RhbmNlc1tjaGFydF07XG4gIH0gZWxzZSBpZiAoIShjaGFydCBpbnN0YW5jZW9mIEVDaGFydHMpKSB7XG4gICAgLy8gVHJ5IHRvIHRyZWF0IGFzIGRvbVxuICAgIGNoYXJ0ID0gZ2V0SW5zdGFuY2VCeURvbShjaGFydCk7XG4gIH1cblxuICBpZiAoY2hhcnQgaW5zdGFuY2VvZiBFQ2hhcnRzICYmICFjaGFydC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICBjaGFydC5kaXNwb3NlKCk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHJldHVybiB7ZWNoYXJ0c35FQ2hhcnRzfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VCeURvbShkb20pIHtcbiAgcmV0dXJuIGluc3RhbmNlc1ttb2RlbFV0aWwuZ2V0QXR0cmlidXRlKGRvbSwgRE9NX0FUVFJJQlVURV9LRVkpXTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7ZWNoYXJ0c35FQ2hhcnRzfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VCeUlkKGtleSkge1xuICByZXR1cm4gaW5zdGFuY2VzW2tleV07XG59XG4vKipcbiAqIFJlZ2lzdGVyIHRoZW1lXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlclRoZW1lKG5hbWUsIHRoZW1lKSB7XG4gIHRoZW1lU3RvcmFnZVtuYW1lXSA9IHRoZW1lO1xufVxuLyoqXG4gKiBSZWdpc3RlciBvcHRpb24gcHJlcHJvY2Vzc29yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVwcm9jZXNzb3JGdW5jXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlclByZXByb2Nlc3NvcihwcmVwcm9jZXNzb3JGdW5jKSB7XG4gIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLnB1c2gocHJlcHJvY2Vzc29yRnVuYyk7XG59XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MTAwMF1cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBwcm9jZXNzb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUHJvY2Vzc29yKHByaW9yaXR5LCBwcm9jZXNzb3IpIHtcbiAgbm9ybWFsaXplUmVnaXN0ZXIoZGF0YVByb2Nlc3NvckZ1bmNzLCBwcmlvcml0eSwgcHJvY2Vzc29yLCBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSKTtcbn1cbi8qKlxuICogUmVnaXN0ZXIgcG9zdFVwZGF0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvc3RVcGRhdGVGdW5jXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlclBvc3RVcGRhdGUocG9zdFVwZGF0ZUZ1bmMpIHtcbiAgcG9zdFVwZGF0ZUZ1bmNzLnB1c2gocG9zdFVwZGF0ZUZ1bmMpO1xufVxuLyoqXG4gKiBVc2FnZTpcbiAqIHJlZ2lzdGVyQWN0aW9uKCdzb21lQWN0aW9uJywgJ3NvbWVFdmVudCcsIGZ1bmN0aW9uICgpIHsgLi4uIH0pO1xuICogcmVnaXN0ZXJBY3Rpb24oJ3NvbWVBY3Rpb24nLCBmdW5jdGlvbiAoKSB7IC4uLiB9KTtcbiAqIHJlZ2lzdGVyQWN0aW9uKFxuICogICAgIHt0eXBlOiAnc29tZUFjdGlvbicsIGV2ZW50OiAnc29tZUV2ZW50JywgdXBkYXRlOiAndXBkYXRlVmlldyd9LFxuICogICAgIGZ1bmN0aW9uICgpIHsgLi4uIH1cbiAqICk7XG4gKlxuICogQHBhcmFtIHsoc3RyaW5nfE9iamVjdCl9IGFjdGlvbkluZm9cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25JbmZvLnR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYWN0aW9uSW5mby5ldmVudF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYWN0aW9uSW5mby51cGRhdGVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V2ZW50TmFtZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvblxuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24oYWN0aW9uSW5mbywgZXZlbnROYW1lLCBhY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhY3Rpb24gPSBldmVudE5hbWU7XG4gICAgZXZlbnROYW1lID0gJyc7XG4gIH1cblxuICB2YXIgYWN0aW9uVHlwZSA9IGlzT2JqZWN0KGFjdGlvbkluZm8pID8gYWN0aW9uSW5mby50eXBlIDogW2FjdGlvbkluZm8sIGFjdGlvbkluZm8gPSB7XG4gICAgZXZlbnQ6IGV2ZW50TmFtZVxuICB9XVswXTsgLy8gRXZlbnQgbmFtZSBpcyBhbGwgbG93ZXJjYXNlXG5cbiAgYWN0aW9uSW5mby5ldmVudCA9IChhY3Rpb25JbmZvLmV2ZW50IHx8IGFjdGlvblR5cGUpLnRvTG93ZXJDYXNlKCk7XG4gIGV2ZW50TmFtZSA9IGFjdGlvbkluZm8uZXZlbnQ7IC8vIFZhbGlkYXRlIGFjdGlvbiB0eXBlIGFuZCBldmVudCBuYW1lLlxuXG4gIGFzc2VydChBQ1RJT05fUkVHLnRlc3QoYWN0aW9uVHlwZSkgJiYgQUNUSU9OX1JFRy50ZXN0KGV2ZW50TmFtZSkpO1xuXG4gIGlmICghYWN0aW9uc1thY3Rpb25UeXBlXSkge1xuICAgIGFjdGlvbnNbYWN0aW9uVHlwZV0gPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGFjdGlvbkluZm86IGFjdGlvbkluZm9cbiAgICB9O1xuICB9XG5cbiAgZXZlbnRBY3Rpb25NYXBbZXZlbnROYW1lXSA9IGFjdGlvblR5cGU7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0geyp9IENvb3JkaW5hdGVTeXN0ZW1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSh0eXBlLCBDb29yZGluYXRlU3lzdGVtKSB7XG4gIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLnJlZ2lzdGVyKHR5cGUsIENvb3JkaW5hdGVTeXN0ZW0pO1xufVxuLyoqXG4gKiBHZXQgZGltZW5zaW9ucyBvZiBzcGVjaWZpZWQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZ3xPYmplY3Q+fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZVN5c3RlbURpbWVuc2lvbnModHlwZSkge1xuICB2YXIgY29vcmRTeXNDcmVhdG9yID0gQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIuZ2V0KHR5cGUpO1xuXG4gIGlmIChjb29yZFN5c0NyZWF0b3IpIHtcbiAgICByZXR1cm4gY29vcmRTeXNDcmVhdG9yLmdldERpbWVuc2lvbnNJbmZvID8gY29vcmRTeXNDcmVhdG9yLmdldERpbWVuc2lvbnNJbmZvKCkgOiBjb29yZFN5c0NyZWF0b3IuZGltZW5zaW9ucy5zbGljZSgpO1xuICB9XG59XG4vKipcbiAqIExheW91dCBpcyBhIHNwZWNpYWwgc3RhZ2Ugb2YgdmlzdWFsIGVuY29kaW5nXG4gKiBNb3N0IHZpc3VhbCBlbmNvZGluZyBsaWtlIGNvbG9yIGFyZSBjb21tb24gZm9yIGRpZmZlcmVudCBjaGFydFxuICogQnV0IGVhY2ggY2hhcnQgaGFzIGl0J3Mgb3duIGxheW91dCBhbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsYXlvdXRUYXNrXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlckxheW91dChwcmlvcml0eSwgbGF5b3V0VGFzaykge1xuICBub3JtYWxpemVSZWdpc3Rlcih2aXN1YWxGdW5jcywgcHJpb3JpdHksIGxheW91dFRhc2ssIFBSSU9SSVRZX1ZJU1VBTF9MQVlPVVQsICdsYXlvdXQnKTtcbn1cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0zMDAwXVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9zdHJlYW0vVGFza30gdmlzdWFsVGFza1xuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJWaXN1YWwocHJpb3JpdHksIHZpc3VhbFRhc2spIHtcbiAgbm9ybWFsaXplUmVnaXN0ZXIodmlzdWFsRnVuY3MsIHByaW9yaXR5LCB2aXN1YWxUYXNrLCBQUklPUklUWV9WSVNVQUxfQ0hBUlQsICd2aXN1YWwnKTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGZuOiB7c2VyaWVzVHlwZSwgY3JlYXRlT25BbGxTZXJpZXMsIHBlcmZvcm1SYXdTZXJpZXMsIHJlc2V0fVxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplUmVnaXN0ZXIodGFyZ2V0TGlzdCwgcHJpb3JpdHksIGZuLCBkZWZhdWx0UHJpb3JpdHksIHZpc3VhbFR5cGUpIHtcbiAgaWYgKGlzRnVuY3Rpb24ocHJpb3JpdHkpIHx8IGlzT2JqZWN0KHByaW9yaXR5KSkge1xuICAgIGZuID0gcHJpb3JpdHk7XG4gICAgcHJpb3JpdHkgPSBkZWZhdWx0UHJpb3JpdHk7XG4gIH1cblxuICB2YXIgc3RhZ2VIYW5kbGVyID0gU2NoZWR1bGVyLndyYXBTdGFnZUhhbmRsZXIoZm4sIHZpc3VhbFR5cGUpO1xuICBzdGFnZUhhbmRsZXIuX19wcmlvID0gcHJpb3JpdHk7XG4gIHN0YWdlSGFuZGxlci5fX3JhdyA9IGZuO1xuICB0YXJnZXRMaXN0LnB1c2goc3RhZ2VIYW5kbGVyKTtcbiAgcmV0dXJuIHN0YWdlSGFuZGxlcjtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTG9hZGluZyhuYW1lLCBsb2FkaW5nRngpIHtcbiAgbG9hZGluZ0VmZmVjdHNbbmFtZV0gPSBsb2FkaW5nRng7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRDb21wb25lbnRNb2RlbChvcHRzXG4vKiwgc3VwZXJDbGFzcyovXG4pIHtcbiAgLy8gdmFyIENsYXp6ID0gQ29tcG9uZW50TW9kZWw7XG4gIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gIC8vICAgICBDbGF6eiA9IENvbXBvbmVudE1vZGVsLmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViLCB0cnVlKTtcbiAgLy8gfVxuICByZXR1cm4gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKG9wdHMpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdXBlckNsYXNzXVxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kQ29tcG9uZW50VmlldyhvcHRzXG4vKiwgc3VwZXJDbGFzcyovXG4pIHtcbiAgLy8gdmFyIENsYXp6ID0gQ29tcG9uZW50VmlldztcbiAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgLy8gICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShzdXBlckNsYXNzKTtcbiAgLy8gICAgIENsYXp6ID0gQ29tcG9uZW50Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YiwgdHJ1ZSk7XG4gIC8vIH1cbiAgcmV0dXJuIENvbXBvbmVudFZpZXcuZXh0ZW5kKG9wdHMpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdXBlckNsYXNzXVxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kU2VyaWVzTW9kZWwob3B0c1xuLyosIHN1cGVyQ2xhc3MqL1xuKSB7XG4gIC8vIHZhciBDbGF6eiA9IFNlcmllc01vZGVsO1xuICAvLyBpZiAoc3VwZXJDbGFzcykge1xuICAvLyAgICAgc3VwZXJDbGFzcyA9ICdzZXJpZXMuJyArIHN1cGVyQ2xhc3MucmVwbGFjZSgnc2VyaWVzLicsICcnKTtcbiAgLy8gICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShzdXBlckNsYXNzKTtcbiAgLy8gICAgIENsYXp6ID0gQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIsIHRydWUpO1xuICAvLyB9XG4gIHJldHVybiBTZXJpZXNNb2RlbC5leHRlbmQob3B0cyk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRDaGFydFZpZXcob3B0c1xuLyosIHN1cGVyQ2xhc3MqL1xuKSB7XG4gIC8vIHZhciBDbGF6eiA9IENoYXJ0VmlldztcbiAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgLy8gICAgIHN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzLnJlcGxhY2UoJ3Nlcmllcy4nLCAnJyk7XG4gIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gIC8vICAgICBDbGF6eiA9IENoYXJ0Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgdHJ1ZSk7XG4gIC8vIH1cbiAgcmV0dXJuIENoYXJ0Vmlldy5leHRlbmQob3B0cyk7XG59XG4vKipcbiAqIFpSZW5kZXIgbmVlZCBhIGNhbnZhcyBjb250ZXh0IHRvIGRvIG1lYXN1cmVUZXh0LlxuICogQnV0IGluIG5vZGUgZW52aXJvbm1lbnQgY2FudmFzIG1heSBiZSBjcmVhdGVkIGJ5IG5vZGUtY2FudmFzLlxuICogU28gd2UgbmVlZCB0byBzcGVjaWZ5IGhvdyB0byBjcmVhdGUgYSBjYW52YXMgaW5zdGVhZCBvZiB1c2luZyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICpcbiAqIEJlIGNhcmVmdWwgb2YgdXNpbmcgaXQgaW4gdGhlIGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3JlYXRvclxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgQ2FudmFzID0gcmVxdWlyZSgnY2FudmFzJyk7XG4gKiAgICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCdlY2hhcnRzJyk7XG4gKiAgICAgZWNoYXJ0cy5zZXRDYW52YXNDcmVhdG9yKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgLy8gU21hbGwgc2l6ZSBpcyBlbm91Z2guXG4gKiAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzKDMyLCAzMik7XG4gKiAgICAgfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBzZXRDYW52YXNDcmVhdG9yKGNyZWF0b3IpIHtcbiAgenJVdGlsLiRvdmVycmlkZSgnY3JlYXRlQ2FudmFzJywgY3JlYXRvcik7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGdlb0pzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3BlY2lhbEFyZWFzXVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgJC5nZXQoJ1VTQS5qc29uJywgZnVuY3Rpb24gKGdlb0pzb24pIHtcbiAqICAgICAgICAgZWNoYXJ0cy5yZWdpc3Rlck1hcCgnVVNBJywgZ2VvSnNvbik7XG4gKiAgICAgICAgIC8vIE9yXG4gKiAgICAgICAgIGVjaGFydHMucmVnaXN0ZXJNYXAoJ1VTQScsIHtcbiAqICAgICAgICAgICAgIGdlb0pzb246IGdlb0pzb24sXG4gKiAgICAgICAgICAgICBzcGVjaWFsQXJlYXM6IHt9XG4gKiAgICAgICAgIH0pXG4gKiAgICAgfSk7XG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3Rlck1hcChtYXBOYW1lLCBnZW9Kc29uLCBzcGVjaWFsQXJlYXMpIHtcbiAgaWYgKGdlb0pzb24uZ2VvSnNvbiAmJiAhZ2VvSnNvbi5mZWF0dXJlcykge1xuICAgIHNwZWNpYWxBcmVhcyA9IGdlb0pzb24uc3BlY2lhbEFyZWFzO1xuICAgIGdlb0pzb24gPSBnZW9Kc29uLmdlb0pzb247XG4gIH1cblxuICBpZiAodHlwZW9mIGdlb0pzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgZ2VvSnNvbiA9IHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyAmJiBKU09OLnBhcnNlID8gSlNPTi5wYXJzZShnZW9Kc29uKSA6IG5ldyBGdW5jdGlvbigncmV0dXJuICgnICsgZ2VvSnNvbiArICcpOycpKCk7XG4gIH1cblxuICBtYXBEYXRhU3RvcmVzW21hcE5hbWVdID0ge1xuICAgIGdlb0pzb246IGdlb0pzb24sXG4gICAgc3BlY2lhbEFyZWFzOiBzcGVjaWFsQXJlYXNcbiAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE1hcChtYXBOYW1lKSB7XG4gIHJldHVybiBtYXBEYXRhU3RvcmVzW21hcE5hbWVdO1xufVxuXG5yZWdpc3RlclZpc3VhbChQUklPUklUWV9WSVNVQUxfR0xPQkFMLCBzZXJpZXNDb2xvcik7XG5yZWdpc3RlclByZXByb2Nlc3NvcihiYWNrd2FyZENvbXBhdCk7XG5yZWdpc3RlclByb2Nlc3NvcihQUklPUklUWV9QUk9DRVNTT1JfU1RBVElTVElDLCBkYXRhU3RhY2spO1xucmVnaXN0ZXJMb2FkaW5nKCdkZWZhdWx0JywgbG9hZGluZ0RlZmF1bHQpOyAvLyBEZWZhdWx0IGFjdGlvbnNcblxucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiAnaGlnaGxpZ2h0JyxcbiAgZXZlbnQ6ICdoaWdobGlnaHQnLFxuICB1cGRhdGU6ICdoaWdobGlnaHQnXG59LCB6clV0aWwubm9vcCk7XG5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICdkb3ducGxheScsXG4gIGV2ZW50OiAnZG93bnBsYXknLFxuICB1cGRhdGU6ICdkb3ducGxheSdcbn0sIHpyVXRpbC5ub29wKTsgLy8gRGVmYXVsdCB0aGVtZVxuXG5yZWdpc3RlclRoZW1lKCdsaWdodCcsIGxpZ2h0VGhlbWUpO1xucmVnaXN0ZXJUaGVtZSgnZGFyaycsIGRhcmtUaGVtZSk7IC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3aGVyZSB0aGUgbmFtZXNwYWNlIGBkYXRhVG9vbGAgd2lsbFxuLy8gYmUgbW91bnRlZCBvbiBgZWNoYXJ0c2AgaXMgdGhlIGV4dGVuc2lvbiBgZGF0YVRvb2xgIGlzIGltcG9ydGVkLlxuXG52YXIgZGF0YVRvb2wgPSB7fTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbmV4cG9ydHMuUFJJT1JJVFkgPSBQUklPUklUWTtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmNvbm5lY3QgPSBjb25uZWN0O1xuZXhwb3J0cy5kaXNDb25uZWN0ID0gZGlzQ29ubmVjdDtcbmV4cG9ydHMuZGlzY29ubmVjdCA9IGRpc2Nvbm5lY3Q7XG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuZXhwb3J0cy5nZXRJbnN0YW5jZUJ5RG9tID0gZ2V0SW5zdGFuY2VCeURvbTtcbmV4cG9ydHMuZ2V0SW5zdGFuY2VCeUlkID0gZ2V0SW5zdGFuY2VCeUlkO1xuZXhwb3J0cy5yZWdpc3RlclRoZW1lID0gcmVnaXN0ZXJUaGVtZTtcbmV4cG9ydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IgPSByZWdpc3RlclByZXByb2Nlc3NvcjtcbmV4cG9ydHMucmVnaXN0ZXJQcm9jZXNzb3IgPSByZWdpc3RlclByb2Nlc3NvcjtcbmV4cG9ydHMucmVnaXN0ZXJQb3N0VXBkYXRlID0gcmVnaXN0ZXJQb3N0VXBkYXRlO1xuZXhwb3J0cy5yZWdpc3RlckFjdGlvbiA9IHJlZ2lzdGVyQWN0aW9uO1xuZXhwb3J0cy5yZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW0gPSByZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW07XG5leHBvcnRzLmdldENvb3JkaW5hdGVTeXN0ZW1EaW1lbnNpb25zID0gZ2V0Q29vcmRpbmF0ZVN5c3RlbURpbWVuc2lvbnM7XG5leHBvcnRzLnJlZ2lzdGVyTGF5b3V0ID0gcmVnaXN0ZXJMYXlvdXQ7XG5leHBvcnRzLnJlZ2lzdGVyVmlzdWFsID0gcmVnaXN0ZXJWaXN1YWw7XG5leHBvcnRzLnJlZ2lzdGVyTG9hZGluZyA9IHJlZ2lzdGVyTG9hZGluZztcbmV4cG9ydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwgPSBleHRlbmRDb21wb25lbnRNb2RlbDtcbmV4cG9ydHMuZXh0ZW5kQ29tcG9uZW50VmlldyA9IGV4dGVuZENvbXBvbmVudFZpZXc7XG5leHBvcnRzLmV4dGVuZFNlcmllc01vZGVsID0gZXh0ZW5kU2VyaWVzTW9kZWw7XG5leHBvcnRzLmV4dGVuZENoYXJ0VmlldyA9IGV4dGVuZENoYXJ0VmlldztcbmV4cG9ydHMuc2V0Q2FudmFzQ3JlYXRvciA9IHNldENhbnZhc0NyZWF0b3I7XG5leHBvcnRzLnJlZ2lzdGVyTWFwID0gcmVnaXN0ZXJNYXA7XG5leHBvcnRzLmdldE1hcCA9IGdldE1hcDtcbmV4cG9ydHMuZGF0YVRvb2wgPSBkYXRhVG9vbDtcbnZhciBfX19lY19leHBvcnQgPSByZXF1aXJlKFwiLi9leHBvcnRcIik7XG4oZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGtleSBpbiBfX19lY19leHBvcnQpIHtcbiAgICAgICAgaWYgKF9fX2VjX2V4cG9ydC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBleHBvcnRzW2tleV0gPSBfX19lY19leHBvcnRba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn0pKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZWNoYXJ0cy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZWNoYXJ0cy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6cmVuZGVyID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3pyZW5kZXJcIik7XG5cbmV4cG9ydHMuenJlbmRlciA9IHpyZW5kZXI7XG5cbnZhciBtYXRyaXggPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9tYXRyaXhcIik7XG5cbmV4cG9ydHMubWF0cml4ID0gbWF0cml4O1xuXG52YXIgdmVjdG9yID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdmVjdG9yXCIpO1xuXG5leHBvcnRzLnZlY3RvciA9IHZlY3RvcjtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBjb2xvclRvb2wgPSByZXF1aXJlKFwienJlbmRlci9saWIvdG9vbC9jb2xvclwiKTtcblxuZXhwb3J0cy5jb2xvciA9IGNvbG9yVG9vbDtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi91dGlsL2dyYXBoaWNcIik7XG5cbmV4cG9ydHMuZ3JhcGhpYyA9IGdyYXBoaWM7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4vdXRpbC9udW1iZXJcIik7XG5cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyVXRpbDtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi91dGlsL2Zvcm1hdFwiKTtcblxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXRVdGlsO1xuXG52YXIgX3Rocm90dGxlID0gcmVxdWlyZShcIi4vdXRpbC90aHJvdHRsZVwiKTtcblxudmFyIHRocm90dGxlID0gX3Rocm90dGxlLnRocm90dGxlO1xuZXhwb3J0cy50aHJvdHRsZSA9IF90aHJvdHRsZS50aHJvdHRsZTtcblxudmFyIGVjSGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuXG5leHBvcnRzLmhlbHBlciA9IGVjSGVscGVyO1xuXG52YXIgcGFyc2VHZW9KU09OID0gcmVxdWlyZShcIi4vY29vcmQvZ2VvL3BhcnNlR2VvSnNvblwiKTtcblxuZXhwb3J0cy5wYXJzZUdlb0pTT04gPSBwYXJzZUdlb0pTT047XG5cbnZhciBfTGlzdCA9IHJlcXVpcmUoXCIuL2RhdGEvTGlzdFwiKTtcblxuZXhwb3J0cy5MaXN0ID0gX0xpc3Q7XG5cbnZhciBfTW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbC9Nb2RlbFwiKTtcblxuZXhwb3J0cy5Nb2RlbCA9IF9Nb2RlbDtcblxudmFyIF9BeGlzID0gcmVxdWlyZShcIi4vY29vcmQvQXhpc1wiKTtcblxuZXhwb3J0cy5BeGlzID0gX0F4aXM7XG5cbnZhciBfZW52ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZW52XCIpO1xuXG5leHBvcnRzLmVudiA9IF9lbnY7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBEbyBub3QgbW91bnQgdGhvc2UgbW9kdWxlcyBvbiAnc3JjL2VjaGFydHMnIGZvciBiZXR0ZXIgdHJlZSBzaGFraW5nLlxuICovXG52YXIgcGFyc2VHZW9Kc29uID0gcGFyc2VHZW9KU09OO1xudmFyIGVjVXRpbCA9IHt9O1xuenJVdGlsLmVhY2goWydtYXAnLCAnZWFjaCcsICdmaWx0ZXInLCAnaW5kZXhPZicsICdpbmhlcml0cycsICdyZWR1Y2UnLCAnZmlsdGVyJywgJ2JpbmQnLCAnY3VycnknLCAnaXNBcnJheScsICdpc1N0cmluZycsICdpc09iamVjdCcsICdpc0Z1bmN0aW9uJywgJ2V4dGVuZCcsICdkZWZhdWx0cycsICdjbG9uZScsICdtZXJnZSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBlY1V0aWxbbmFtZV0gPSB6clV0aWxbbmFtZV07XG59KTtcbmV4cG9ydHMucGFyc2VHZW9Kc29uID0gcGFyc2VHZW9Kc29uO1xuZXhwb3J0cy51dGlsID0gZWNVdGlsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZXhwb3J0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBjcmVhdGVMaXN0RnJvbUFycmF5ID0gcmVxdWlyZShcIi4vY2hhcnQvaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXlcIik7XG5cbnZhciBheGlzSGVscGVyID0gcmVxdWlyZShcIi4vY29vcmQvYXhpc0hlbHBlclwiKTtcblxudmFyIGF4aXNNb2RlbENvbW1vbk1peGluID0gcmVxdWlyZShcIi4vY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW5cIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsL01vZGVsXCIpO1xuXG52YXIgX2xheW91dCA9IHJlcXVpcmUoXCIuL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgZ2V0TGF5b3V0UmVjdCA9IF9sYXlvdXQuZ2V0TGF5b3V0UmVjdDtcbmV4cG9ydHMuZ2V0TGF5b3V0UmVjdCA9IF9sYXlvdXQuZ2V0TGF5b3V0UmVjdDtcblxudmFyIF9kYXRhU3RhY2tIZWxwZXIgPSByZXF1aXJlKFwiLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXJcIik7XG5cbnZhciBlbmFibGVEYXRhU3RhY2sgPSBfZGF0YVN0YWNrSGVscGVyLmVuYWJsZURhdGFTdGFjaztcbnZhciBpc0RpbWVuc2lvblN0YWNrZWQgPSBfZGF0YVN0YWNrSGVscGVyLmlzRGltZW5zaW9uU3RhY2tlZDtcbnZhciBnZXRTdGFja2VkRGltZW5zaW9uID0gX2RhdGFTdGFja0hlbHBlci5nZXRTdGFja2VkRGltZW5zaW9uO1xuXG52YXIgX2NvbXBsZXRlRGltZW5zaW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9uc1wiKTtcblxuZXhwb3J0cy5jb21wbGV0ZURpbWVuc2lvbnMgPSBfY29tcGxldGVEaW1lbnNpb25zO1xuXG52YXIgX2NyZWF0ZURpbWVuc2lvbnMgPSByZXF1aXJlKFwiLi9kYXRhL2hlbHBlci9jcmVhdGVEaW1lbnNpb25zXCIpO1xuXG5leHBvcnRzLmNyZWF0ZURpbWVuc2lvbnMgPSBfY3JlYXRlRGltZW5zaW9ucztcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi91dGlsL3N5bWJvbFwiKTtcblxuZXhwb3J0cy5jcmVhdGVTeW1ib2wgPSBfc3ltYm9sLmNyZWF0ZVN5bWJvbDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gaW1wb3J0IGNyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlIGZyb20gJy4vY2hhcnQvaGVscGVyL2NyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlJztcblxuLyoqXG4gKiBDcmVhdGUgYSBtdXRpIGRpbWVuc2lvbiBMaXN0IHN0cnVjdHVyZSBmcm9tIHNlcmllc01vZGVsLlxuICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHNlcmllc01vZGVsXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGxpc3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGlzdChzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheShzZXJpZXNNb2RlbC5nZXRTb3VyY2UoKSwgc2VyaWVzTW9kZWwpO1xufSAvLyBleHBvcnQgZnVuY3Rpb24gY3JlYXRlR3JhcGgoc2VyaWVzTW9kZWwpIHtcbi8vICAgICB2YXIgbm9kZXMgPSBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKTtcbi8vICAgICB2YXIgbGlua3MgPSBzZXJpZXNNb2RlbC5nZXQoJ2xpbmtzJyk7XG4vLyAgICAgcmV0dXJuIGNyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlKG5vZGVzLCBsaW5rcywgc2VyaWVzTW9kZWwpO1xuLy8gfVxuXG5cbnZhciBkYXRhU3RhY2sgPSB7XG4gIGlzRGltZW5zaW9uU3RhY2tlZDogaXNEaW1lbnNpb25TdGFja2VkLFxuICBlbmFibGVEYXRhU3RhY2s6IGVuYWJsZURhdGFTdGFjayxcbiAgZ2V0U3RhY2tlZERpbWVuc2lvbjogZ2V0U3RhY2tlZERpbWVuc2lvblxufTtcbi8qKlxuICogQ3JlYXRlIGEgc3ltYm9sIGVsZW1lbnQgd2l0aCBnaXZlbiBzeW1ib2wgY29uZmlndXJhdGlvbjogc2hhcGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yXG4gKiBAc2VlIGh0dHA6Ly9lY2hhcnRzLmJhaWR1LmNvbS9vcHRpb24uaHRtbCNzZXJpZXMtc2NhdHRlci5zeW1ib2xcbiAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xEZXNjXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gKiBAcGFyYW0ge251bWJlcn0gaFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgc2NhbGVcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGFFeHRlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTplY2hhcnRzL01vZGVsfSBvcHRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2NhbGUoZGF0YUV4dGVudCwgb3B0aW9uKSB7XG4gIHZhciBheGlzTW9kZWwgPSBvcHRpb247XG5cbiAgaWYgKCFNb2RlbC5pc0luc3RhbmNlKG9wdGlvbikpIHtcbiAgICBheGlzTW9kZWwgPSBuZXcgTW9kZWwob3B0aW9uKTtcbiAgICB6clV0aWwubWl4aW4oYXhpc01vZGVsLCBheGlzTW9kZWxDb21tb25NaXhpbik7XG4gIH1cblxuICB2YXIgc2NhbGUgPSBheGlzSGVscGVyLmNyZWF0ZVNjYWxlQnlNb2RlbChheGlzTW9kZWwpO1xuICBzY2FsZS5zZXRFeHRlbnQoZGF0YUV4dGVudFswXSwgZGF0YUV4dGVudFsxXSk7XG4gIGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50KHNjYWxlLCBheGlzTW9kZWwpO1xuICByZXR1cm4gc2NhbGU7XG59XG4vKipcbiAqIE1peGluIGNvbW1vbiBtZXRob2RzIHRvIGF4aXMgbW9kZWwsXG4gKlxuICogSW5sY3VkZSBtZXRob2RzXG4gKiBgZ2V0Rm9ybWF0dGVkTGFiZWxzKCkgPT4gQXJyYXkuPHN0cmluZz5gXG4gKiBgZ2V0Q2F0ZWdvcmllcygpID0+IEFycmF5LjxzdHJpbmc+YFxuICogYGdldE1pbihvcmlnaW46IGJvb2xlYW4pID0+IG51bWJlcmBcbiAqIGBnZXRNYXgob3JpZ2luOiBib29sZWFuKSA9PiBudW1iZXJgXG4gKiBgZ2V0TmVlZENyb3NzWmVybygpID0+IGJvb2xlYW5gXG4gKiBgc2V0UmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpYFxuICogYHJlc2V0UmFuZ2UoKWBcbiAqL1xuXG5cbmZ1bmN0aW9uIG1peGluQXhpc01vZGVsQ29tbW9uTWV0aG9kcyhNb2RlbCkge1xuICB6clV0aWwubWl4aW4oTW9kZWwsIGF4aXNNb2RlbENvbW1vbk1peGluKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVMaXN0ID0gY3JlYXRlTGlzdDtcbmV4cG9ydHMuZGF0YVN0YWNrID0gZGF0YVN0YWNrO1xuZXhwb3J0cy5jcmVhdGVTY2FsZSA9IGNyZWF0ZVNjYWxlO1xuZXhwb3J0cy5taXhpbkF4aXNNb2RlbENvbW1vbk1ldGhvZHMgPSBtaXhpbkF4aXNNb2RlbENvbW1vbk1ldGhvZHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvaGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9oZWxwZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgX2RlZmF1bHQgPSB7XG4gIHRvb2xib3g6IHtcbiAgICBicnVzaDoge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgcmVjdDogJ+efqeW9oumAieaLqScsXG4gICAgICAgIHBvbHlnb246ICflnIjpgIknLFxuICAgICAgICBsaW5lWDogJ+aoquWQkemAieaLqScsXG4gICAgICAgIGxpbmVZOiAn57q15ZCR6YCJ5oupJyxcbiAgICAgICAga2VlcDogJ+S/neaMgemAieaLqScsXG4gICAgICAgIGNsZWFyOiAn5riF6Zmk6YCJ5oupJ1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YVZpZXc6IHtcbiAgICAgIHRpdGxlOiAn5pWw5o2u6KeG5Zu+JyxcbiAgICAgIGxhbmc6IFsn5pWw5o2u6KeG5Zu+JywgJ+WFs+mXrScsICfliLfmlrAnXVxuICAgIH0sXG4gICAgZGF0YVpvb206IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHpvb206ICfljLrln5/nvKnmlL4nLFxuICAgICAgICBiYWNrOiAn5Yy65Z+f57yp5pS+6L+Y5Y6fJ1xuICAgICAgfVxuICAgIH0sXG4gICAgbWFnaWNUeXBlOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBsaW5lOiAn5YiH5o2i5Li65oqY57q/5Zu+JyxcbiAgICAgICAgYmFyOiAn5YiH5o2i5Li65p+x54q25Zu+JyxcbiAgICAgICAgc3RhY2s6ICfliIfmjaLkuLrloIblj6AnLFxuICAgICAgICB0aWxlZDogJ+WIh+aNouS4uuW5s+mTuidcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc3RvcmU6IHtcbiAgICAgIHRpdGxlOiAn6L+Y5Y6fJ1xuICAgIH0sXG4gICAgc2F2ZUFzSW1hZ2U6IHtcbiAgICAgIHRpdGxlOiAn5L+d5a2Y5Li65Zu+54mHJyxcbiAgICAgIGxhbmc6IFsn5Y+z6ZSu5Y+m5a2Y5Li65Zu+54mHJ11cbiAgICB9XG4gIH0sXG4gIHNlcmllczoge1xuICAgIHR5cGVOYW1lczoge1xuICAgICAgcGllOiAn6aW85Zu+JyxcbiAgICAgIGJhcjogJ+afseeKtuWbvicsXG4gICAgICBsaW5lOiAn5oqY57q/5Zu+JyxcbiAgICAgIHNjYXR0ZXI6ICfmlaPngrnlm74nLFxuICAgICAgZWZmZWN0U2NhdHRlcjogJ+a2n+a8quaVo+eCueWbvicsXG4gICAgICByYWRhcjogJ+mbt+i+vuWbvicsXG4gICAgICB0cmVlOiAn5qCR5Zu+JyxcbiAgICAgIHRyZWVtYXA6ICfnn6nlvaLmoJHlm74nLFxuICAgICAgYm94cGxvdDogJ+euseWei+WbvicsXG4gICAgICBjYW5kbGVzdGljazogJ0vnur/lm74nLFxuICAgICAgazogJ0vnur/lm74nLFxuICAgICAgaGVhdG1hcDogJ+eDreWKm+WbvicsXG4gICAgICBtYXA6ICflnLDlm74nLFxuICAgICAgcGFyYWxsZWw6ICflubPooYzlnZDmoIflm74nLFxuICAgICAgbGluZXM6ICfnur/lm74nLFxuICAgICAgZ3JhcGg6ICflhbPns7vlm74nLFxuICAgICAgc2Fua2V5OiAn5qGR5Z+65Zu+JyxcbiAgICAgIGZ1bm5lbDogJ+a8j+aWl+WbvicsXG4gICAgICBnYXVnZTogJ+S7quihqOebmOWbvicsXG4gICAgICBwaWN0b3JpYWxCYXI6ICfosaHlvaLmn7Hlm74nLFxuICAgICAgdGhlbWVSaXZlcjogJ+S4u+mimOays+a1geWbvicsXG4gICAgICBzdW5idXJzdDogJ+aXreaXpeWbvidcbiAgICB9XG4gIH0sXG4gIGFyaWE6IHtcbiAgICBnZW5lcmFsOiB7XG4gICAgICB3aXRoVGl0bGU6ICfov5nmmK/kuIDkuKrlhbPkuo7igJx7dGl0bGV94oCd55qE5Zu+6KGo44CCJyxcbiAgICAgIHdpdGhvdXRUaXRsZTogJ+i/meaYr+S4gOS4quWbvuihqO+8jCdcbiAgICB9LFxuICAgIHNlcmllczoge1xuICAgICAgc2luZ2xlOiB7XG4gICAgICAgIHByZWZpeDogJycsXG4gICAgICAgIHdpdGhOYW1lOiAn5Zu+6KGo57G75Z6L5pive3Nlcmllc1R5cGV977yM6KGo56S6e3Nlcmllc05hbWV944CCJyxcbiAgICAgICAgd2l0aG91dE5hbWU6ICflm77ooajnsbvlnovmmK97c2VyaWVzVHlwZX3jgIInXG4gICAgICB9LFxuICAgICAgbXVsdGlwbGU6IHtcbiAgICAgICAgcHJlZml4OiAn5a6D55Sxe3Nlcmllc0NvdW50feS4quWbvuihqOezu+WIl+e7hOaIkOOAgicsXG4gICAgICAgIHdpdGhOYW1lOiAn56yse3Nlcmllc0lkfeS4quezu+WIl+aYr+S4gOS4quihqOekuntzZXJpZXNOYW1lfeeahHtzZXJpZXNUeXBlfe+8jCcsXG4gICAgICAgIHdpdGhvdXROYW1lOiAn56yse3Nlcmllc0lkfeS4quezu+WIl+aYr+S4gOS4qntzZXJpZXNUeXBlfe+8jCcsXG4gICAgICAgIHNlcGFyYXRvcjoge1xuICAgICAgICAgIG1pZGRsZTogJ++8mycsXG4gICAgICAgICAgZW5kOiAn44CCJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICBhbGxEYXRhOiAn5YW25pWw5o2u5piv4oCU4oCUJyxcbiAgICAgIHBhcnRpYWxEYXRhOiAn5YW25Lit77yM5YmNe2Rpc3BsYXlDbnR96aG55piv4oCU4oCUJyxcbiAgICAgIHdpdGhOYW1lOiAne25hbWV955qE5pWw5o2u5pive3ZhbHVlfScsXG4gICAgICB3aXRob3V0TmFtZTogJ3t2YWx1ZX0nLFxuICAgICAgc2VwYXJhdG9yOiB7XG4gICAgICAgIG1pZGRsZTogJ++8jCcsXG4gICAgICAgIGVuZDogJydcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xhbmcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xhbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIF9udW1iZXIgPSByZXF1aXJlKFwiLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBwYXJzZVBlcmNlbnQgPSBfbnVtYmVyLnBhcnNlUGVyY2VudDtcblxudmFyIF9kYXRhU3RhY2tIZWxwZXIgPSByZXF1aXJlKFwiLi4vZGF0YS9oZWxwZXIvZGF0YVN0YWNrSGVscGVyXCIpO1xuXG52YXIgaXNEaW1lbnNpb25TdGFja2VkID0gX2RhdGFTdGFja0hlbHBlci5pc0RpbWVuc2lvblN0YWNrZWQ7XG5cbnZhciBjcmVhdGVSZW5kZXJQbGFubmVyID0gcmVxdWlyZShcIi4uL2NoYXJ0L2hlbHBlci9jcmVhdGVSZW5kZXJQbGFubmVyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgU1RBQ0tfUFJFRklYID0gJ19fZWNfc3RhY2tfJztcbnZhciBMQVJHRV9CQVJfTUlOX1dJRFRIID0gMC41O1xudmFyIExhcmdlQXJyID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcblxuZnVuY3Rpb24gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0KCdzdGFjaycpIHx8IFNUQUNLX1BSRUZJWCArIHNlcmllc01vZGVsLnNlcmllc0luZGV4O1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzS2V5KGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMuZGltICsgYXhpcy5pbmRleDtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBvcHQuYXhpcyBPbmx5IHN1cHBvcnQgY2F0ZWdvcnkgYXhpcyBjdXJyZW50bHkuXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0LmNvdW50IFBvc2l0aXZlIGludGVyZ2VyLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuYmFyV2lkdGhdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJNYXhXaWR0aF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmJhckdhcF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmJhckNhdGVnb3J5R2FwXVxuICogQHJldHVybiB7T2JqZWN0fSB7d2lkdGgsIG9mZnNldCwgb2Zmc2V0Q2VudGVyfSBJZiBheGlzLnR5cGUgaXMgbm90ICdjYXRlZ29yeScsIHJldHVybiB1bmRlZmluZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMYXlvdXRPbkF4aXMob3B0KSB7XG4gIHZhciBwYXJhbXMgPSBbXTtcbiAgdmFyIGJhc2VBeGlzID0gb3B0LmF4aXM7XG4gIHZhciBheGlzS2V5ID0gJ2F4aXMwJztcblxuICBpZiAoYmFzZUF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBiYW5kV2lkdGggPSBiYXNlQXhpcy5nZXRCYW5kV2lkdGgoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdC5jb3VudCB8fCAwOyBpKyspIHtcbiAgICBwYXJhbXMucHVzaCh6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICBheGlzS2V5OiBheGlzS2V5LFxuICAgICAgc3RhY2tJZDogU1RBQ0tfUFJFRklYICsgaVxuICAgIH0sIG9wdCkpO1xuICB9XG5cbiAgdmFyIHdpZHRoQW5kT2Zmc2V0cyA9IGRvQ2FsQmFyV2lkdGhBbmRPZmZzZXQocGFyYW1zKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0LmNvdW50OyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHdpZHRoQW5kT2Zmc2V0c1theGlzS2V5XVtTVEFDS19QUkVGSVggKyBpXTtcbiAgICBpdGVtLm9mZnNldENlbnRlciA9IGl0ZW0ub2Zmc2V0ICsgaXRlbS53aWR0aCAvIDI7XG4gICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlTGF5b3V0QmFyU2VyaWVzKHNlcmllc1R5cGUsIGVjTW9kZWwpIHtcbiAgdmFyIHNlcmllc01vZGVscyA9IFtdO1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgLy8gQ2hlY2sgc2VyaWVzIGNvb3JkaW5hdGUsIGRvIGxheW91dCBmb3IgY2FydGVzaWFuMmQgb25seVxuICAgIGlmIChpc09uQ2FydGVzaWFuKHNlcmllc01vZGVsKSAmJiAhaXNJbkxhcmdlTW9kZShzZXJpZXNNb2RlbCkpIHtcbiAgICAgIHNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VyaWVzTW9kZWxzO1xufVxuXG5mdW5jdGlvbiBtYWtlQ29sdW1uTGF5b3V0KGJhclNlcmllcykge1xuICB2YXIgc2VyaWVzSW5mb0xpc3QgPSBbXTtcbiAgenJVdGlsLmVhY2goYmFyU2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgYmFzZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgYXhpc0V4dGVudCA9IGJhc2VBeGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBiYW5kV2lkdGggPSBiYXNlQXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gYmFzZUF4aXMuZ2V0QmFuZFdpZHRoKCkgOiBNYXRoLmFicyhheGlzRXh0ZW50WzFdIC0gYXhpc0V4dGVudFswXSkgLyBkYXRhLmNvdW50KCk7XG4gICAgdmFyIGJhcldpZHRoID0gcGFyc2VQZXJjZW50KHNlcmllc01vZGVsLmdldCgnYmFyV2lkdGgnKSwgYmFuZFdpZHRoKTtcbiAgICB2YXIgYmFyTWF4V2lkdGggPSBwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdiYXJNYXhXaWR0aCcpLCBiYW5kV2lkdGgpO1xuICAgIHZhciBiYXJHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2JhckdhcCcpO1xuICAgIHZhciBiYXJDYXRlZ29yeUdhcCA9IHNlcmllc01vZGVsLmdldCgnYmFyQ2F0ZWdvcnlHYXAnKTtcbiAgICBzZXJpZXNJbmZvTGlzdC5wdXNoKHtcbiAgICAgIGJhbmRXaWR0aDogYmFuZFdpZHRoLFxuICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgYmFyTWF4V2lkdGg6IGJhck1heFdpZHRoLFxuICAgICAgYmFyR2FwOiBiYXJHYXAsXG4gICAgICBiYXJDYXRlZ29yeUdhcDogYmFyQ2F0ZWdvcnlHYXAsXG4gICAgICBheGlzS2V5OiBnZXRBeGlzS2V5KGJhc2VBeGlzKSxcbiAgICAgIHN0YWNrSWQ6IGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZG9DYWxCYXJXaWR0aEFuZE9mZnNldChzZXJpZXNJbmZvTGlzdCk7XG59XG5cbmZ1bmN0aW9uIGRvQ2FsQmFyV2lkdGhBbmRPZmZzZXQoc2VyaWVzSW5mb0xpc3QpIHtcbiAgLy8gQ29sdW1ucyBpbmZvIG9uIGVhY2ggY2F0ZWdvcnkgYXhpcy4gS2V5IGlzIGNhcnRlc2lhbiBuYW1lXG4gIHZhciBjb2x1bW5zTWFwID0ge307XG4gIHpyVXRpbC5lYWNoKHNlcmllc0luZm9MaXN0LCBmdW5jdGlvbiAoc2VyaWVzSW5mbywgaWR4KSB7XG4gICAgdmFyIGF4aXNLZXkgPSBzZXJpZXNJbmZvLmF4aXNLZXk7XG4gICAgdmFyIGJhbmRXaWR0aCA9IHNlcmllc0luZm8uYmFuZFdpZHRoO1xuICAgIHZhciBjb2x1bW5zT25BeGlzID0gY29sdW1uc01hcFtheGlzS2V5XSB8fCB7XG4gICAgICBiYW5kV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgIHJlbWFpbmVkV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgIGF1dG9XaWR0aENvdW50OiAwLFxuICAgICAgY2F0ZWdvcnlHYXA6ICcyMCUnLFxuICAgICAgZ2FwOiAnMzAlJyxcbiAgICAgIHN0YWNrczoge31cbiAgICB9O1xuICAgIHZhciBzdGFja3MgPSBjb2x1bW5zT25BeGlzLnN0YWNrcztcbiAgICBjb2x1bW5zTWFwW2F4aXNLZXldID0gY29sdW1uc09uQXhpcztcbiAgICB2YXIgc3RhY2tJZCA9IHNlcmllc0luZm8uc3RhY2tJZDtcblxuICAgIGlmICghc3RhY2tzW3N0YWNrSWRdKSB7XG4gICAgICBjb2x1bW5zT25BeGlzLmF1dG9XaWR0aENvdW50Kys7XG4gICAgfVxuXG4gICAgc3RhY2tzW3N0YWNrSWRdID0gc3RhY2tzW3N0YWNrSWRdIHx8IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgbWF4V2lkdGg6IDBcbiAgICB9OyAvLyBDYXV0aW9uOiBJbiBhIHNpbmdsZSBjb29yZGluYXRlIHN5c3RlbSwgdGhlc2UgYmFyR3JpZCBhdHRyaWJ1dGVzXG4gICAgLy8gd2lsbCBiZSBzaGFyZWQgYnkgc2VyaWVzLiBDb25zaWRlciB0aGF0IHRoZXkgaGF2ZSBkZWZhdWx0IHZhbHVlcyxcbiAgICAvLyBvbmx5IHRoZSBhdHRyaWJ1dGVzIHNldCBvbiB0aGUgbGFzdCBzZXJpZXMgd2lsbCB3b3JrLlxuICAgIC8vIERvIG5vdCBjaGFuZ2UgdGhpcyBmYWN0IHVubGVzcyB0aGVyZSB3aWxsIGJlIGEgYnJlYWsgY2hhbmdlLlxuICAgIC8vIFRPRE9cblxuICAgIHZhciBiYXJXaWR0aCA9IHNlcmllc0luZm8uYmFyV2lkdGg7XG5cbiAgICBpZiAoYmFyV2lkdGggJiYgIXN0YWNrc1tzdGFja0lkXS53aWR0aCkge1xuICAgICAgLy8gU2VlICM2MzEyLCBkbyBub3QgcmVzdHJpY3Qgd2lkdGguXG4gICAgICBzdGFja3Nbc3RhY2tJZF0ud2lkdGggPSBiYXJXaWR0aDtcbiAgICAgIGJhcldpZHRoID0gTWF0aC5taW4oY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoLCBiYXJXaWR0aCk7XG4gICAgICBjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGggLT0gYmFyV2lkdGg7XG4gICAgfVxuXG4gICAgdmFyIGJhck1heFdpZHRoID0gc2VyaWVzSW5mby5iYXJNYXhXaWR0aDtcbiAgICBiYXJNYXhXaWR0aCAmJiAoc3RhY2tzW3N0YWNrSWRdLm1heFdpZHRoID0gYmFyTWF4V2lkdGgpO1xuICAgIHZhciBiYXJHYXAgPSBzZXJpZXNJbmZvLmJhckdhcDtcbiAgICBiYXJHYXAgIT0gbnVsbCAmJiAoY29sdW1uc09uQXhpcy5nYXAgPSBiYXJHYXApO1xuICAgIHZhciBiYXJDYXRlZ29yeUdhcCA9IHNlcmllc0luZm8uYmFyQ2F0ZWdvcnlHYXA7XG4gICAgYmFyQ2F0ZWdvcnlHYXAgIT0gbnVsbCAmJiAoY29sdW1uc09uQXhpcy5jYXRlZ29yeUdhcCA9IGJhckNhdGVnb3J5R2FwKTtcbiAgfSk7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgenJVdGlsLmVhY2goY29sdW1uc01hcCwgZnVuY3Rpb24gKGNvbHVtbnNPbkF4aXMsIGNvb3JkU3lzTmFtZSkge1xuICAgIHJlc3VsdFtjb29yZFN5c05hbWVdID0ge307XG4gICAgdmFyIHN0YWNrcyA9IGNvbHVtbnNPbkF4aXMuc3RhY2tzO1xuICAgIHZhciBiYW5kV2lkdGggPSBjb2x1bW5zT25BeGlzLmJhbmRXaWR0aDtcbiAgICB2YXIgY2F0ZWdvcnlHYXAgPSBwYXJzZVBlcmNlbnQoY29sdW1uc09uQXhpcy5jYXRlZ29yeUdhcCwgYmFuZFdpZHRoKTtcbiAgICB2YXIgYmFyR2FwUGVyY2VudCA9IHBhcnNlUGVyY2VudChjb2x1bW5zT25BeGlzLmdhcCwgMSk7XG4gICAgdmFyIHJlbWFpbmVkV2lkdGggPSBjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGg7XG4gICAgdmFyIGF1dG9XaWR0aENvdW50ID0gY29sdW1uc09uQXhpcy5hdXRvV2lkdGhDb3VudDtcbiAgICB2YXIgYXV0b1dpZHRoID0gKHJlbWFpbmVkV2lkdGggLSBjYXRlZ29yeUdhcCkgLyAoYXV0b1dpZHRoQ291bnQgKyAoYXV0b1dpZHRoQ291bnQgLSAxKSAqIGJhckdhcFBlcmNlbnQpO1xuICAgIGF1dG9XaWR0aCA9IE1hdGgubWF4KGF1dG9XaWR0aCwgMCk7IC8vIEZpbmQgaWYgYW55IGF1dG8gY2FsY3VsYXRlZCBiYXIgZXhjZWVkZWQgbWF4QmFyV2lkdGhcblxuICAgIHpyVXRpbC5lYWNoKHN0YWNrcywgZnVuY3Rpb24gKGNvbHVtbiwgc3RhY2spIHtcbiAgICAgIHZhciBtYXhXaWR0aCA9IGNvbHVtbi5tYXhXaWR0aDtcblxuICAgICAgaWYgKG1heFdpZHRoICYmIG1heFdpZHRoIDwgYXV0b1dpZHRoKSB7XG4gICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIHJlbWFpbmVkV2lkdGgpO1xuXG4gICAgICAgIGlmIChjb2x1bW4ud2lkdGgpIHtcbiAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKG1heFdpZHRoLCBjb2x1bW4ud2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtYWluZWRXaWR0aCAtPSBtYXhXaWR0aDtcbiAgICAgICAgY29sdW1uLndpZHRoID0gbWF4V2lkdGg7XG4gICAgICAgIGF1dG9XaWR0aENvdW50LS07XG4gICAgICB9XG4gICAgfSk7IC8vIFJlY2FsY3VsYXRlIHdpZHRoIGFnYWluXG5cbiAgICBhdXRvV2lkdGggPSAocmVtYWluZWRXaWR0aCAtIGNhdGVnb3J5R2FwKSAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7XG4gICAgYXV0b1dpZHRoID0gTWF0aC5tYXgoYXV0b1dpZHRoLCAwKTtcbiAgICB2YXIgd2lkdGhTdW0gPSAwO1xuICAgIHZhciBsYXN0Q29sdW1uO1xuICAgIHpyVXRpbC5lYWNoKHN0YWNrcywgZnVuY3Rpb24gKGNvbHVtbiwgaWR4KSB7XG4gICAgICBpZiAoIWNvbHVtbi53aWR0aCkge1xuICAgICAgICBjb2x1bW4ud2lkdGggPSBhdXRvV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGxhc3RDb2x1bW4gPSBjb2x1bW47XG4gICAgICB3aWR0aFN1bSArPSBjb2x1bW4ud2lkdGggKiAoMSArIGJhckdhcFBlcmNlbnQpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxhc3RDb2x1bW4pIHtcbiAgICAgIHdpZHRoU3VtIC09IGxhc3RDb2x1bW4ud2lkdGggKiBiYXJHYXBQZXJjZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXQgPSAtd2lkdGhTdW0gLyAyO1xuICAgIHpyVXRpbC5lYWNoKHN0YWNrcywgZnVuY3Rpb24gKGNvbHVtbiwgc3RhY2tJZCkge1xuICAgICAgcmVzdWx0W2Nvb3JkU3lzTmFtZV1bc3RhY2tJZF0gPSByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSB8fCB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICB3aWR0aDogY29sdW1uLndpZHRoXG4gICAgICB9O1xuICAgICAgb2Zmc2V0ICs9IGNvbHVtbi53aWR0aCAqICgxICsgYmFyR2FwUGVyY2VudCk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYmFyV2lkdGhBbmRPZmZzZXQgVGhlIHJlc3VsdCBvZiBtYWtlQ29sdW1uTGF5b3V0XG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0F4aXN9IGF4aXNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBbc2VyaWVzTW9kZWxdIElmIG5vdCBwcm92aWRlZCwgcmV0dXJuIGFsbC5cbiAqIEByZXR1cm4ge09iamVjdH0ge3N0YWNrSWQ6IHtvZmZzZXQsIHdpZHRofX0gb3Ige29mZnNldCwgd2lkdGh9IGlmIHNlcmllc01vZGVsIHByb3ZpZGVkLlxuICovXG5cblxuZnVuY3Rpb24gcmV0cmlldmVDb2x1bW5MYXlvdXQoYmFyV2lkdGhBbmRPZmZzZXQsIGF4aXMsIHNlcmllc01vZGVsKSB7XG4gIGlmIChiYXJXaWR0aEFuZE9mZnNldCAmJiBheGlzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhcldpZHRoQW5kT2Zmc2V0W2dldEF4aXNLZXkoYXhpcyldO1xuXG4gICAgaWYgKHJlc3VsdCAhPSBudWxsICYmIHNlcmllc01vZGVsICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdFtnZXRTZXJpZXNTdGFja0lkKHNlcmllc01vZGVsKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzVHlwZVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGxheW91dChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gIHZhciBzZXJpZXNNb2RlbHMgPSBwcmVwYXJlTGF5b3V0QmFyU2VyaWVzKHNlcmllc1R5cGUsIGVjTW9kZWwpO1xuICB2YXIgYmFyV2lkdGhBbmRPZmZzZXQgPSBtYWtlQ29sdW1uTGF5b3V0KHNlcmllc01vZGVscyk7XG4gIHZhciBsYXN0U3RhY2tDb29yZHMgPSB7fTtcbiAgdmFyIGxhc3RTdGFja0Nvb3Jkc09yaWdpbiA9IHt9O1xuICB6clV0aWwuZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBiYXNlQXhpcyA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpO1xuICAgIHZhciBzdGFja0lkID0gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCk7XG4gICAgdmFyIGNvbHVtbkxheW91dEluZm8gPSBiYXJXaWR0aEFuZE9mZnNldFtnZXRBeGlzS2V5KGJhc2VBeGlzKV1bc3RhY2tJZF07XG4gICAgdmFyIGNvbHVtbk9mZnNldCA9IGNvbHVtbkxheW91dEluZm8ub2Zmc2V0O1xuICAgIHZhciBjb2x1bW5XaWR0aCA9IGNvbHVtbkxheW91dEluZm8ud2lkdGg7XG4gICAgdmFyIHZhbHVlQXhpcyA9IGNhcnRlc2lhbi5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICAgIHZhciBiYXJNaW5IZWlnaHQgPSBzZXJpZXNNb2RlbC5nZXQoJ2Jhck1pbkhlaWdodCcpIHx8IDA7XG4gICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdID0gbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdIHx8IFtdO1xuICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSB8fCBbXTsgLy8gRml4ICM0MjQzXG5cbiAgICBkYXRhLnNldExheW91dCh7XG4gICAgICBvZmZzZXQ6IGNvbHVtbk9mZnNldCxcbiAgICAgIHNpemU6IGNvbHVtbldpZHRoXG4gICAgfSk7XG4gICAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24odmFsdWVBeGlzLmRpbSk7XG4gICAgdmFyIGJhc2VEaW0gPSBkYXRhLm1hcERpbWVuc2lvbihiYXNlQXhpcy5kaW0pO1xuICAgIHZhciBzdGFja2VkID0gaXNEaW1lbnNpb25TdGFja2VkKGRhdGEsIHZhbHVlRGltXG4gICAgLyosIGJhc2VEaW0qL1xuICAgICk7XG4gICAgdmFyIGlzVmFsdWVBeGlzSCA9IHZhbHVlQXhpcy5pc0hvcml6b250YWwoKTtcbiAgICB2YXIgdmFsdWVBeGlzU3RhcnQgPSBnZXRWYWx1ZUF4aXNTdGFydChiYXNlQXhpcywgdmFsdWVBeGlzLCBzdGFja2VkKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbiA9IGRhdGEuY291bnQoKTsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgdmFyIHZhbHVlID0gZGF0YS5nZXQodmFsdWVEaW0sIGlkeCk7XG4gICAgICB2YXIgYmFzZVZhbHVlID0gZGF0YS5nZXQoYmFzZURpbSwgaWR4KTtcblxuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpZ24gPSB2YWx1ZSA+PSAwID8gJ3AnIDogJ24nO1xuICAgICAgdmFyIGJhc2VDb29yZCA9IHZhbHVlQXhpc1N0YXJ0OyAvLyBCZWNhdXNlIG9mIHRoZSBiYXJNaW5IZWlnaHQsIHdlIGNhbiBub3QgdXNlIHRoZSB2YWx1ZSBpblxuICAgICAgLy8gc3RhY2tSZXN1bHREaW1lbnNpb24gZGlyZWN0bHkuXG5cbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIC8vIE9ubHkgb3JkaW5hbCBheGlzIGNhbiBiZSBzdGFja2VkLlxuICAgICAgICBpZiAoIWxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtiYXNlVmFsdWVdKSB7XG4gICAgICAgICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2Jhc2VWYWx1ZV0gPSB7XG4gICAgICAgICAgICBwOiB2YWx1ZUF4aXNTdGFydCxcbiAgICAgICAgICAgIC8vIFBvc2l0aXZlIHN0YWNrXG4gICAgICAgICAgICBuOiB2YWx1ZUF4aXNTdGFydCAvLyBOZWdhdGl2ZSBzdGFja1xuXG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBTaG91bGQgYWxzbyBjb25zaWRlciAjNDI0M1xuXG5cbiAgICAgICAgYmFzZUNvb3JkID0gbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2Jhc2VWYWx1ZV1bc2lnbl07XG4gICAgICB9XG5cbiAgICAgIHZhciB4O1xuICAgICAgdmFyIHk7XG4gICAgICB2YXIgd2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0O1xuXG4gICAgICBpZiAoaXNWYWx1ZUF4aXNIKSB7XG4gICAgICAgIHZhciBjb29yZCA9IGNhcnRlc2lhbi5kYXRhVG9Qb2ludChbdmFsdWUsIGJhc2VWYWx1ZV0pO1xuICAgICAgICB4ID0gYmFzZUNvb3JkO1xuICAgICAgICB5ID0gY29vcmRbMV0gKyBjb2x1bW5PZmZzZXQ7XG4gICAgICAgIHdpZHRoID0gY29vcmRbMF0gLSB2YWx1ZUF4aXNTdGFydDtcbiAgICAgICAgaGVpZ2h0ID0gY29sdW1uV2lkdGg7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHdpZHRoKSA8IGJhck1pbkhlaWdodCkge1xuICAgICAgICAgIHdpZHRoID0gKHdpZHRoIDwgMCA/IC0xIDogMSkgKiBiYXJNaW5IZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFja2VkICYmIChsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1bYmFzZVZhbHVlXVtzaWduXSArPSB3aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29vcmQgPSBjYXJ0ZXNpYW4uZGF0YVRvUG9pbnQoW2Jhc2VWYWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgeCA9IGNvb3JkWzBdICsgY29sdW1uT2Zmc2V0O1xuICAgICAgICB5ID0gYmFzZUNvb3JkO1xuICAgICAgICB3aWR0aCA9IGNvbHVtbldpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjb29yZFsxXSAtIHZhbHVlQXhpc1N0YXJ0O1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgLy8gSW5jbHVkZSB6ZXJvIHRvIGhhcyBhIHBvc2l0aXZlIGJhclxuICAgICAgICAgIGhlaWdodCA9IChoZWlnaHQgPD0gMCA/IC0xIDogMSkgKiBiYXJNaW5IZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFja2VkICYmIChsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1bYmFzZVZhbHVlXVtzaWduXSArPSBoZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgdGhpcyk7XG59IC8vIFRPRE86IERvIG5vdCBzdXBwb3J0IHN0YWNrIGluIGxhcmdlIG1vZGUgeWV0LlxuXG5cbnZhciBsYXJnZUxheW91dCA9IHtcbiAgc2VyaWVzVHlwZTogJ2JhcicsXG4gIHBsYW46IGNyZWF0ZVJlbmRlclBsYW5uZXIoKSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIGlmICghaXNPbkNhcnRlc2lhbihzZXJpZXNNb2RlbCkgfHwgIWlzSW5MYXJnZU1vZGUoc2VyaWVzTW9kZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGNhcnRlc2lhbiA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgdmFyIHZhbHVlQXhpcyA9IGNhcnRlc2lhbi5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICAgIHZhciB2YWx1ZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpcy5kaW0pO1xuICAgIHZhciBiYXNlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oYmFzZUF4aXMuZGltKTtcbiAgICB2YXIgdmFsdWVBeGlzSG9yaXpvbnRhbCA9IHZhbHVlQXhpcy5pc0hvcml6b250YWwoKTtcbiAgICB2YXIgdmFsdWVEaW1JZHggPSB2YWx1ZUF4aXNIb3Jpem9udGFsID8gMCA6IDE7XG4gICAgdmFyIGJhcldpZHRoID0gcmV0cmlldmVDb2x1bW5MYXlvdXQobWFrZUNvbHVtbkxheW91dChbc2VyaWVzTW9kZWxdKSwgYmFzZUF4aXMsIHNlcmllc01vZGVsKS53aWR0aDtcblxuICAgIGlmICghKGJhcldpZHRoID4gTEFSR0VfQkFSX01JTl9XSURUSCkpIHtcbiAgICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgYmFyV2lkdGggPSBMQVJHRV9CQVJfTUlOX1dJRFRIO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwcm9ncmVzczogcHJvZ3Jlc3NcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHJvZ3Jlc3MocGFyYW1zLCBkYXRhKSB7XG4gICAgICB2YXIgbGFyZ2VQb2ludHMgPSBuZXcgTGFyZ2VBcnIocGFyYW1zLmNvdW50ICogMik7XG4gICAgICB2YXIgZGF0YUluZGV4O1xuICAgICAgdmFyIGNvb3JkID0gW107XG4gICAgICB2YXIgdmFsdWVQYWlyID0gW107XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgd2hpbGUgKChkYXRhSW5kZXggPSBwYXJhbXMubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlUGFpclt2YWx1ZURpbUlkeF0gPSBkYXRhLmdldCh2YWx1ZURpbSwgZGF0YUluZGV4KTtcbiAgICAgICAgdmFsdWVQYWlyWzEgLSB2YWx1ZURpbUlkeF0gPSBkYXRhLmdldChiYXNlRGltLCBkYXRhSW5kZXgpO1xuICAgICAgICBjb29yZCA9IGNhcnRlc2lhbi5kYXRhVG9Qb2ludCh2YWx1ZVBhaXIsIG51bGwsIGNvb3JkKTtcbiAgICAgICAgbGFyZ2VQb2ludHNbb2Zmc2V0KytdID0gY29vcmRbMF07XG4gICAgICAgIGxhcmdlUG9pbnRzW29mZnNldCsrXSA9IGNvb3JkWzFdO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnNldExheW91dCh7XG4gICAgICAgIGxhcmdlUG9pbnRzOiBsYXJnZVBvaW50cyxcbiAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICB2YWx1ZUF4aXNTdGFydDogZ2V0VmFsdWVBeGlzU3RhcnQoYmFzZUF4aXMsIHZhbHVlQXhpcywgZmFsc2UpLFxuICAgICAgICB2YWx1ZUF4aXNIb3Jpem9udGFsOiB2YWx1ZUF4aXNIb3Jpem9udGFsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzT25DYXJ0ZXNpYW4oc2VyaWVzTW9kZWwpIHtcbiAgcmV0dXJuIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gJiYgc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS50eXBlID09PSAnY2FydGVzaWFuMmQnO1xufVxuXG5mdW5jdGlvbiBpc0luTGFyZ2VNb2RlKHNlcmllc01vZGVsKSB7XG4gIHJldHVybiBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQgJiYgc2VyaWVzTW9kZWwucGlwZWxpbmVDb250ZXh0LmxhcmdlO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUF4aXNTdGFydChiYXNlQXhpcywgdmFsdWVBeGlzLCBzdGFja2VkKSB7XG4gIHJldHVybiB6clV0aWwuaW5kZXhPZihiYXNlQXhpcy5nZXRBeGVzT25aZXJvT2YoKSwgdmFsdWVBeGlzKSA+PSAwIHx8IHN0YWNrZWQgPyB2YWx1ZUF4aXMudG9HbG9iYWxDb29yZCh2YWx1ZUF4aXMuZGF0YVRvQ29vcmQoMCkpIDogdmFsdWVBeGlzLmdldEdsb2JhbEV4dGVudCgpWzBdO1xufVxuXG5leHBvcnRzLmdldExheW91dE9uQXhpcyA9IGdldExheW91dE9uQXhpcztcbmV4cG9ydHMucHJlcGFyZUxheW91dEJhclNlcmllcyA9IHByZXBhcmVMYXlvdXRCYXJTZXJpZXM7XG5leHBvcnRzLm1ha2VDb2x1bW5MYXlvdXQgPSBtYWtlQ29sdW1uTGF5b3V0O1xuZXhwb3J0cy5yZXRyaWV2ZUNvbHVtbkxheW91dCA9IHJldHJpZXZlQ29sdW1uTGF5b3V0O1xuZXhwb3J0cy5sYXlvdXQgPSBsYXlvdXQ7XG5leHBvcnRzLmxhcmdlTGF5b3V0ID0gbGFyZ2VMYXlvdXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L2JhckdyaWQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xheW91dC9iYXJHcmlkLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF91dGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIG1hcCA9IF91dGlsLm1hcDtcblxudmFyIGNyZWF0ZVJlbmRlclBsYW5uZXIgPSByZXF1aXJlKFwiLi4vY2hhcnQvaGVscGVyL2NyZWF0ZVJlbmRlclBsYW5uZXJcIik7XG5cbnZhciBfZGF0YVN0YWNrSGVscGVyID0gcmVxdWlyZShcIi4uL2RhdGEvaGVscGVyL2RhdGFTdGFja0hlbHBlclwiKTtcblxudmFyIGlzRGltZW5zaW9uU3RhY2tlZCA9IF9kYXRhU3RhY2tIZWxwZXIuaXNEaW1lbnNpb25TdGFja2VkO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5mdW5jdGlvbiBfZGVmYXVsdChzZXJpZXNUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgc2VyaWVzVHlwZTogc2VyaWVzVHlwZSxcbiAgICBwbGFuOiBjcmVhdGVSZW5kZXJQbGFubmVyKCksXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIHBpcGVsaW5lQ29udGV4dCA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dDtcbiAgICAgIHZhciBpc0xhcmdlUmVuZGVyID0gcGlwZWxpbmVDb250ZXh0LmxhcmdlO1xuXG4gICAgICBpZiAoIWNvb3JkU3lzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpbXMgPSBtYXAoY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICByZXR1cm4gZGF0YS5tYXBEaW1lbnNpb24oZGltKTtcbiAgICAgIH0pLnNsaWNlKDAsIDIpO1xuICAgICAgdmFyIGRpbUxlbiA9IGRpbXMubGVuZ3RoO1xuICAgICAgdmFyIHN0YWNrUmVzdWx0RGltID0gZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrUmVzdWx0RGltZW5zaW9uJyk7XG5cbiAgICAgIGlmIChpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgZGltc1swXVxuICAgICAgLyosIGRpbXNbMV0qL1xuICAgICAgKSkge1xuICAgICAgICBkaW1zWzBdID0gc3RhY2tSZXN1bHREaW07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgZGltc1sxXVxuICAgICAgLyosIGRpbXNbMF0qL1xuICAgICAgKSkge1xuICAgICAgICBkaW1zWzFdID0gc3RhY2tSZXN1bHREaW07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByb2dyZXNzKHBhcmFtcywgZGF0YSkge1xuICAgICAgICB2YXIgc2VnQ291bnQgPSBwYXJhbXMuZW5kIC0gcGFyYW1zLnN0YXJ0O1xuICAgICAgICB2YXIgcG9pbnRzID0gaXNMYXJnZVJlbmRlciAmJiBuZXcgRmxvYXQzMkFycmF5KHNlZ0NvdW50ICogZGltTGVuKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gcGFyYW1zLnN0YXJ0LCBvZmZzZXQgPSAwLCB0bXBJbiA9IFtdLCB0bXBPdXQgPSBbXTsgaSA8IHBhcmFtcy5lbmQ7IGkrKykge1xuICAgICAgICAgIHZhciBwb2ludDtcblxuICAgICAgICAgIGlmIChkaW1MZW4gPT09IDEpIHtcbiAgICAgICAgICAgIHZhciB4ID0gZGF0YS5nZXQoZGltc1swXSwgaSk7XG4gICAgICAgICAgICBwb2ludCA9ICFpc05hTih4KSAmJiBjb29yZFN5cy5kYXRhVG9Qb2ludCh4LCBudWxsLCB0bXBPdXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRtcEluWzBdID0gZGF0YS5nZXQoZGltc1swXSwgaSk7XG4gICAgICAgICAgICB2YXIgeSA9IHRtcEluWzFdID0gZGF0YS5nZXQoZGltc1sxXSwgaSk7IC8vIEFsc28ge0FycmF5LjxudW1iZXI+fSwgbm90IHVuZGVmaW5lZCB0byBhdm9pZCBpZi4uLmVsc2UuLi4gc3RhdGVtZW50XG5cbiAgICAgICAgICAgIHBvaW50ID0gIWlzTmFOKHgpICYmICFpc05hTih5KSAmJiBjb29yZFN5cy5kYXRhVG9Qb2ludCh0bXBJbiwgbnVsbCwgdG1wT3V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNMYXJnZVJlbmRlcikge1xuICAgICAgICAgICAgcG9pbnRzW29mZnNldCsrXSA9IHBvaW50ID8gcG9pbnRbMF0gOiBOYU47XG4gICAgICAgICAgICBwb2ludHNbb2Zmc2V0KytdID0gcG9pbnQgPyBwb2ludFsxXSA6IE5hTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGksIHBvaW50ICYmIHBvaW50LnNsaWNlKCkgfHwgW05hTiwgTmFOXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXNMYXJnZVJlbmRlciAmJiBkYXRhLnNldExheW91dCgnc3ltYm9sUG9pbnRzJywgcG9pbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbUxlbiAmJiB7XG4gICAgICAgIHByb2dyZXNzOiBwcm9ncmVzc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L3BvaW50cy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L3BvaW50cy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi91dGlsL2dyYXBoaWNcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBQSSA9IE1hdGguUEk7XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50ZXh0XVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbG9yXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRleHRDb2xvcl1cbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gKi9cblxuZnVuY3Rpb24gX2RlZmF1bHQoYXBpLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB6clV0aWwuZGVmYXVsdHMob3B0cywge1xuICAgIHRleHQ6ICdsb2FkaW5nJyxcbiAgICBjb2xvcjogJyNjMjM1MzEnLFxuICAgIHRleHRDb2xvcjogJyMwMDAnLFxuICAgIG1hc2tDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC44KScsXG4gICAgemxldmVsOiAwXG4gIH0pO1xuICB2YXIgbWFzayA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHN0eWxlOiB7XG4gICAgICBmaWxsOiBvcHRzLm1hc2tDb2xvclxuICAgIH0sXG4gICAgemxldmVsOiBvcHRzLnpsZXZlbCxcbiAgICB6OiAxMDAwMFxuICB9KTtcbiAgdmFyIGFyYyA9IG5ldyBncmFwaGljLkFyYyh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHN0YXJ0QW5nbGU6IC1QSSAvIDIsXG4gICAgICBlbmRBbmdsZTogLVBJIC8gMiArIDAuMSxcbiAgICAgIHI6IDEwXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgc3Ryb2tlOiBvcHRzLmNvbG9yLFxuICAgICAgbGluZUNhcDogJ3JvdW5kJyxcbiAgICAgIGxpbmVXaWR0aDogNVxuICAgIH0sXG4gICAgemxldmVsOiBvcHRzLnpsZXZlbCxcbiAgICB6OiAxMDAwMVxuICB9KTtcbiAgdmFyIGxhYmVsUmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHN0eWxlOiB7XG4gICAgICBmaWxsOiAnbm9uZScsXG4gICAgICB0ZXh0OiBvcHRzLnRleHQsXG4gICAgICB0ZXh0UG9zaXRpb246ICdyaWdodCcsXG4gICAgICB0ZXh0RGlzdGFuY2U6IDEwLFxuICAgICAgdGV4dEZpbGw6IG9wdHMudGV4dENvbG9yXG4gICAgfSxcbiAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgIHo6IDEwMDAxXG4gIH0pO1xuICBhcmMuYW5pbWF0ZVNoYXBlKHRydWUpLndoZW4oMTAwMCwge1xuICAgIGVuZEFuZ2xlOiBQSSAqIDMgLyAyXG4gIH0pLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG4gIGFyYy5hbmltYXRlU2hhcGUodHJ1ZSkud2hlbigxMDAwLCB7XG4gICAgc3RhcnRBbmdsZTogUEkgKiAzIC8gMlxuICB9KS5kZWxheSgzMDApLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG4gIHZhciBncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gIGdyb3VwLmFkZChhcmMpO1xuICBncm91cC5hZGQobGFiZWxSZWN0KTtcbiAgZ3JvdXAuYWRkKG1hc2spOyAvLyBJbmplY3QgcmVzaXplXG5cbiAgZ3JvdXAucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjeCA9IGFwaS5nZXRXaWR0aCgpIC8gMjtcbiAgICB2YXIgY3kgPSBhcGkuZ2V0SGVpZ2h0KCkgLyAyO1xuICAgIGFyYy5zZXRTaGFwZSh7XG4gICAgICBjeDogY3gsXG4gICAgICBjeTogY3lcbiAgICB9KTtcbiAgICB2YXIgciA9IGFyYy5zaGFwZS5yO1xuICAgIGxhYmVsUmVjdC5zZXRTaGFwZSh7XG4gICAgICB4OiBjeCAtIHIsXG4gICAgICB5OiBjeSAtIHIsXG4gICAgICB3aWR0aDogciAqIDIsXG4gICAgICBoZWlnaHQ6IHIgKiAyXG4gICAgfSk7XG4gICAgbWFzay5zZXRTaGFwZSh7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfSk7XG4gIH07XG5cbiAgZ3JvdXAucmVzaXplKCk7XG4gIHJldHVybiBncm91cDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sb2FkaW5nL2RlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xvYWRpbmcvZGVmYXVsdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi9Nb2RlbFwiKTtcblxudmFyIGNvbXBvbmVudFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9jb21wb25lbnRcIik7XG5cbnZhciBfY2xhenogPSByZXF1aXJlKFwiLi4vdXRpbC9jbGF6elwiKTtcblxudmFyIGVuYWJsZUNsYXNzTWFuYWdlbWVudCA9IF9jbGF6ei5lbmFibGVDbGFzc01hbmFnZW1lbnQ7XG52YXIgcGFyc2VDbGFzc1R5cGUgPSBfY2xhenoucGFyc2VDbGFzc1R5cGU7XG5cbnZhciBfbW9kZWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIG1ha2VJbm5lciA9IF9tb2RlbC5tYWtlSW5uZXI7XG5cbnZhciBsYXlvdXQgPSByZXF1aXJlKFwiLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBib3hMYXlvdXRNaXhpbiA9IHJlcXVpcmUoXCIuL21peGluL2JveExheW91dFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIENvbXBvbmVudCBtb2RlbFxuICpcbiAqIEBtb2R1bGUgZWNoYXJ0cy9tb2RlbC9Db21wb25lbnRcbiAqL1xudmFyIGlubmVyID0gbWFrZUlubmVyKCk7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gcGFyZW50TW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGVjTW9kZWxcbiAqL1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSBNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnY29tcG9uZW50JyxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBpZDogJycsXG5cbiAgLyoqXG4gICAqIEJlY2F1c2Ugc2ltcGxpZmllZCBjb25jZXB0IGlzIHByb2JhYmx5IGJldHRlciwgc2VyaWVzLm5hbWUgKG9yIGNvbXBvbmVudC5uYW1lKVxuICAgKiBoYXMgYmVlbiBoYXZpbmcgdG9vIG1hbnkgcmVzcG9zaWJpbGl0aWVzOlxuICAgKiAoMSkgR2VuZXJhdGluZyBpZCAod2hpY2ggcmVxdWlyZXMgbmFtZSBpbiBvcHRpb24gc2hvdWxkIG5vdCBiZSBtb2RpZmllZCkuXG4gICAqICgyKSBBcyBhbiBpbmRleCB0byBtYXBwaW5nIHNlcmllcyB3aGVuIG1lcmdpbmcgb3B0aW9uIG9yIGNhbGxpbmcgQVBJIChhIG5hbWVcbiAgICogY2FuIHJlZmVyIHRvIG1vcmUgdGhlbiBvbmUgY29tcG9uZW50cywgd2hpY2ggaXMgY29udmluaWVudCBpcyBzb21lIGNhc2UpLlxuICAgKiAoMykgRGlzcGxheS5cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBuYW1lOiAnJyxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBtYWluVHlwZTogJycsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3ViVHlwZTogJycsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgY29tcG9uZW50SW5kZXg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRlZmF1bHRPcHRpb246IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZWNNb2RlbDogbnVsbCxcblxuICAvKipcbiAgICoga2V5OiBjb21wb25lbnRUeXBlXG4gICAqIHZhbHVlOiAgQ29tcG9uZW50IG1vZGVsIGxpc3QsIGNhbiBub3QgYmUgbnVsbC5cbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+Pn1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBkZXBlbmRlbnRNb2RlbHM6IFtdLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHVpZDogbnVsbCxcblxuICAvKipcbiAgICogU3VwcG9ydCBtZXJnZSBsYXlvdXQgcGFyYW1zLlxuICAgKiBPbmx5IHN1cHBvcnQgJ2JveCcgbm93IChsZWZ0L3JpZ2h0L3RvcC9ib3R0b20vd2lkdGgvaGVpZ2h0KS5cbiAgICogQHR5cGUge3N0cmluZ3xPYmplY3R9IE9iamVjdCBjYW4gYmUge2lnbm9yZVNpemU6IHRydWV9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgbGF5b3V0TW9kZTogbnVsbCxcbiAgJGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbiAgICBNb2RlbC5jYWxsKHRoaXMsIG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KTtcbiAgICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCdlY19jcHRfbW9kZWwnKTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICB9LFxuICBtZXJnZURlZmF1bHRBbmRUaGVtZTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0TW9kZSA/IGxheW91dC5nZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9O1xuICAgIHZhciB0aGVtZU1vZGVsID0gZWNNb2RlbC5nZXRUaGVtZSgpO1xuICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoZW1lTW9kZWwuZ2V0KHRoaXMubWFpblR5cGUpKTtcbiAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XG5cbiAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0ob3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zLCBsYXlvdXRNb2RlKTtcbiAgICB9XG4gIH0sXG4gIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uLCBleHRyYU9wdCkge1xuICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgb3B0aW9uLCB0cnVlKTtcbiAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcblxuICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzLm9wdGlvbiwgb3B0aW9uLCBsYXlvdXRNb2RlKTtcbiAgICB9XG4gIH0sXG4gIC8vIEhvb2tlciBhZnRlciBpbml0IG9yIG1lcmdlT3B0aW9uXG4gIG9wdGlvblVwZGF0ZWQ6IGZ1bmN0aW9uIChuZXdDcHRPcHRpb24sIGlzSW5pdCkge30sXG4gIGdldERlZmF1bHRPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmllbGRzID0gaW5uZXIodGhpcyk7XG5cbiAgICBpZiAoIWZpZWxkcy5kZWZhdWx0T3B0aW9uKSB7XG4gICAgICB2YXIgb3B0TGlzdCA9IFtdO1xuICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgICAgd2hpbGUgKENsYXNzKSB7XG4gICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcbiAgICAgICAgb3B0ICYmIG9wdExpc3QucHVzaChvcHQpO1xuICAgICAgICBDbGFzcyA9IENsYXNzLnN1cGVyQ2xhc3M7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSBvcHRMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZpZWxkcy5kZWZhdWx0T3B0aW9uID0gZGVmYXVsdE9wdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzLmRlZmF1bHRPcHRpb247XG4gIH0sXG4gIGdldFJlZmVycmluZ0NvbXBvbmVudHM6IGZ1bmN0aW9uIChtYWluVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgIG1haW5UeXBlOiBtYWluVHlwZSxcbiAgICAgIGluZGV4OiB0aGlzLmdldChtYWluVHlwZSArICdJbmRleCcsIHRydWUpLFxuICAgICAgaWQ6IHRoaXMuZ2V0KG1haW5UeXBlICsgJ0lkJywgdHJ1ZSlcbiAgICB9KTtcbiAgfVxufSk7IC8vIFJlc2V0IENvbXBvbmVudE1vZGVsLmV4dGVuZCwgYWRkIHByZUNvbnN0cnVjdC5cbi8vIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChcbi8vICAgICBDb21wb25lbnRNb2RlbCxcbi8vICAgICBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbi8vICAgICAgICAgLy8gU2V0IGRlcGVuZGVudE1vZGVscywgY29tcG9uZW50SW5kZXgsIG5hbWUsIGlkLCBtYWluVHlwZSwgc3ViVHlwZS5cbi8vICAgICAgICAgenJVdGlsLmV4dGVuZCh0aGlzLCBleHRyYU9wdCk7XG4vLyAgICAgICAgIHRoaXMudWlkID0gY29tcG9uZW50VXRpbC5nZXRVSUQoJ2NvbXBvbmVudE1vZGVsJyk7XG4vLyAgICAgICAgIC8vIHRoaXMuc2V0UmVhZE9ubHkoW1xuLy8gICAgICAgICAvLyAgICAgJ3R5cGUnLCAnaWQnLCAndWlkJywgJ25hbWUnLCAnbWFpblR5cGUnLCAnc3ViVHlwZScsXG4vLyAgICAgICAgIC8vICAgICAnZGVwZW5kZW50TW9kZWxzJywgJ2NvbXBvbmVudEluZGV4J1xuLy8gICAgICAgICAvLyBdKTtcbi8vICAgICB9XG4vLyApO1xuLy8gQWRkIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuXG5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ29tcG9uZW50TW9kZWwsIHtcbiAgcmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlXG59KTtcbmNvbXBvbmVudFV0aWwuZW5hYmxlU3ViVHlwZURlZmF1bHRlcihDb21wb25lbnRNb2RlbCk7IC8vIEFkZCBjYXBhYmlsaXR5IG9mIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsLlxuXG5jb21wb25lbnRVdGlsLmVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsKENvbXBvbmVudE1vZGVsLCBnZXREZXBlbmRlbmNpZXMpO1xuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoY29tcG9uZW50VHlwZSkge1xuICB2YXIgZGVwcyA9IFtdO1xuICB6clV0aWwuZWFjaChDb21wb25lbnRNb2RlbC5nZXRDbGFzc2VzQnlNYWluVHlwZShjb21wb25lbnRUeXBlKSwgZnVuY3Rpb24gKENsYXp6KSB7XG4gICAgZGVwcyA9IGRlcHMuY29uY2F0KENsYXp6LnByb3RvdHlwZS5kZXBlbmRlbmNpZXMgfHwgW10pO1xuICB9KTsgLy8gRW5zdXJlIG1haW4gdHlwZS5cblxuICBkZXBzID0genJVdGlsLm1hcChkZXBzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiBwYXJzZUNsYXNzVHlwZSh0eXBlKS5tYWluO1xuICB9KTsgLy8gSGFjayBkYXRhc2V0IGZvciBjb252ZW5pZW5jZS5cblxuICBpZiAoY29tcG9uZW50VHlwZSAhPT0gJ2RhdGFzZXQnICYmIHpyVXRpbC5pbmRleE9mKGRlcHMsICdkYXRhc2V0JykgPD0gMCkge1xuICAgIGRlcHMudW5zaGlmdCgnZGF0YXNldCcpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHM7XG59XG5cbnpyVXRpbC5taXhpbihDb21wb25lbnRNb2RlbCwgYm94TGF5b3V0TWl4aW4pO1xudmFyIF9kZWZhdWx0ID0gQ29tcG9uZW50TW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIF91dGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIGZpbHRlciA9IF91dGlsLmZpbHRlcjtcbnZhciBtYXAgPSBfdXRpbC5tYXA7XG52YXIgaXNBcnJheSA9IF91dGlsLmlzQXJyYXk7XG52YXIgaW5kZXhPZiA9IF91dGlsLmluZGV4T2Y7XG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcbnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nO1xudmFyIGNyZWF0ZUhhc2hNYXAgPSBfdXRpbC5jcmVhdGVIYXNoTWFwO1xudmFyIGFzc2VydCA9IF91dGlsLmFzc2VydDtcbnZhciBjbG9uZSA9IF91dGlsLmNsb25lO1xudmFyIG1lcmdlID0gX3V0aWwubWVyZ2U7XG52YXIgZXh0ZW5kID0gX3V0aWwuZXh0ZW5kO1xudmFyIG1peGluID0gX3V0aWwubWl4aW47XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4vTW9kZWxcIik7XG5cbnZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoXCIuL0NvbXBvbmVudFwiKTtcblxudmFyIGdsb2JhbERlZmF1bHQgPSByZXF1aXJlKFwiLi9nbG9iYWxEZWZhdWx0XCIpO1xuXG52YXIgY29sb3JQYWxldHRlTWl4aW4gPSByZXF1aXJlKFwiLi9taXhpbi9jb2xvclBhbGV0dGVcIik7XG5cbnZhciBfc291cmNlSGVscGVyID0gcmVxdWlyZShcIi4uL2RhdGEvaGVscGVyL3NvdXJjZUhlbHBlclwiKTtcblxudmFyIHJlc2V0U291cmNlRGVmYXVsdGVyID0gX3NvdXJjZUhlbHBlci5yZXNldFNvdXJjZURlZmF1bHRlcjtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEVDaGFydHMgZ2xvYmFsIG1vZGVsXG4gKlxuICogQG1vZHVsZSB7ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gKi9cblxuLyoqXG4gKiBDYXV0aW9uOiBJZiB0aGUgbWVjaGFuaXNtIHNob3VsZCBiZSBjaGFuZ2VkIHNvbWUgZGF5LCB0aGVzZSBjYXNlc1xuICogc2hvdWxkIGJlIGNvbnNpZGVyZWQ6XG4gKlxuICogKDEpIEluIGBtZXJnZSBvcHRpb25gIG1vZGUsIGlmIHVzaW5nIHRoZSBzYW1lIG9wdGlvbiB0byBjYWxsIGBzZXRPcHRpb25gXG4gKiBtYW55IHRpbWVzLCB0aGUgcmVzdWx0IHNob3VsZCBiZSB0aGUgc2FtZSAodHJ5IG91ciBiZXN0IHRvIGVuc3VyZSB0aGF0KS5cbiAqICgyKSBJbiBgbWVyZ2Ugb3B0aW9uYCBtb2RlLCBpZiBhIGNvbXBvbmVudCBoYXMgbm8gaWQvbmFtZSBzcGVjaWZpZWQsIGl0XG4gKiB3aWxsIGJlIG1lcmdlZCBieSBpbmRleCwgYW5kIHRoZSByZXN1bHQgc2VxdWVuY2Ugb2YgdGhlIGNvbXBvbmVudHMgaXNcbiAqIGNvbnNpc3RlbnQgdG8gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxuICogKDMpIGByZXNldGAgZmVhdHVyZSAoaW4gdG9vbGJveCkuIEZpbmQgZGV0YWlsZWQgaW5mbyBpbiBjb21tZW50cyBhYm91dFxuICogYG1lcmdlT3B0aW9uYCBpbiBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb25NYW5hZ2VyLlxuICovXG52YXIgT1BUSU9OX0lOTkVSX0tFWSA9ICdcXDBfZWNfaW5uZXInO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gcGFyZW50TW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGVtZVxuICovXG5cbnZhciBHbG9iYWxNb2RlbCA9IE1vZGVsLmV4dGVuZCh7XG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCB0aGVtZSwgb3B0aW9uTWFuYWdlcikge1xuICAgIHRoZW1lID0gdGhlbWUgfHwge307XG4gICAgdGhpcy5vcHRpb24gPSBudWxsOyAvLyBNYXJrIGFzIG5vdCBpbml0aWFsaXplZC5cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fdGhlbWUgPSBuZXcgTW9kZWwodGhlbWUpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb25NYW5hZ2VyfVxuICAgICAqL1xuXG4gICAgdGhpcy5fb3B0aW9uTWFuYWdlciA9IG9wdGlvbk1hbmFnZXI7XG4gIH0sXG4gIHNldE9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpIHtcbiAgICBhc3NlcnQoIShPUFRJT05fSU5ORVJfS0VZIGluIG9wdGlvbiksICdwbGVhc2UgdXNlIGNoYXJ0LmdldE9wdGlvbigpJyk7XG5cbiAgICB0aGlzLl9vcHRpb25NYW5hZ2VyLnNldE9wdGlvbihvcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKTtcblxuICAgIHRoaXMucmVzZXRPcHRpb24obnVsbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIG51bGwvdW5kZWZpbmVkOiByZXNldCBhbGwuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICdyZWNyZWF0ZSc6IGZvcmNlIHJlY3JlYXRlIGFsbC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgJ3RpbWVsaW5lJzogb25seSByZXNldCB0aW1lbGluZSBvcHRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgJ21lZGlhJzogb25seSByZXNldCBtZWRpYSBxdWVyeSBvcHRpb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvcHRpb24gY2hhbmdlZC5cbiAgICovXG4gIHJlc2V0T3B0aW9uOiBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBvcHRpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG9wdGlvbk1hbmFnZXIgPSB0aGlzLl9vcHRpb25NYW5hZ2VyO1xuXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScpIHtcbiAgICAgIHZhciBiYXNlT3B0aW9uID0gb3B0aW9uTWFuYWdlci5tb3VudE9wdGlvbih0eXBlID09PSAncmVjcmVhdGUnKTtcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbiB8fCB0eXBlID09PSAncmVjcmVhdGUnKSB7XG4gICAgICAgIGluaXRCYXNlLmNhbGwodGhpcywgYmFzZU9wdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc3RvcmVEYXRhKCk7XG4gICAgICAgIHRoaXMubWVyZ2VPcHRpb24oYmFzZU9wdGlvbik7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAndGltZWxpbmUnIHx8IHR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAgIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJyB8fCB0eXBlID09PSAndGltZWxpbmUnKSB7XG4gICAgICB2YXIgdGltZWxpbmVPcHRpb24gPSBvcHRpb25NYW5hZ2VyLmdldFRpbWVsaW5lT3B0aW9uKHRoaXMpO1xuICAgICAgdGltZWxpbmVPcHRpb24gJiYgKHRoaXMubWVyZ2VPcHRpb24odGltZWxpbmVPcHRpb24pLCBvcHRpb25DaGFuZ2VkID0gdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScgfHwgdHlwZSA9PT0gJ21lZGlhJykge1xuICAgICAgdmFyIG1lZGlhT3B0aW9ucyA9IG9wdGlvbk1hbmFnZXIuZ2V0TWVkaWFPcHRpb24odGhpcywgdGhpcy5fYXBpKTtcblxuICAgICAgaWYgKG1lZGlhT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgZWFjaChtZWRpYU9wdGlvbnMsIGZ1bmN0aW9uIChtZWRpYU9wdGlvbikge1xuICAgICAgICAgIHRoaXMubWVyZ2VPcHRpb24obWVkaWFPcHRpb24sIG9wdGlvbkNoYW5nZWQgPSB0cnVlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbkNoYW5nZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAobmV3T3B0aW9uKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBjb21wb25lbnRzTWFwID0gdGhpcy5fY29tcG9uZW50c01hcDtcbiAgICB2YXIgbmV3Q3B0VHlwZXMgPSBbXTtcbiAgICByZXNldFNvdXJjZURlZmF1bHRlcih0aGlzKTsgLy8gSWYgbm8gY29tcG9uZW50IGNsYXNzLCBtZXJnZSBkaXJlY3RseS5cbiAgICAvLyBGb3IgZXhhbXBsZTogY29sb3IsIGFuaW1haXRvbiBvcHRpb25zLCBldGMuXG5cbiAgICBlYWNoKG5ld09wdGlvbiwgZnVuY3Rpb24gKGNvbXBvbmVudE9wdGlvbiwgbWFpblR5cGUpIHtcbiAgICAgIGlmIChjb21wb25lbnRPcHRpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICAgIC8vIGdsb2JhbFNldHRpbmdUYXNrLmRpcnR5KCk7XG4gICAgICAgIG9wdGlvblttYWluVHlwZV0gPSBvcHRpb25bbWFpblR5cGVdID09IG51bGwgPyBjbG9uZShjb21wb25lbnRPcHRpb24pIDogbWVyZ2Uob3B0aW9uW21haW5UeXBlXSwgY29tcG9uZW50T3B0aW9uLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAobWFpblR5cGUpIHtcbiAgICAgICAgbmV3Q3B0VHlwZXMucHVzaChtYWluVHlwZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgQ29tcG9uZW50TW9kZWwudG9wb2xvZ2ljYWxUcmF2ZWwobmV3Q3B0VHlwZXMsIENvbXBvbmVudE1vZGVsLmdldEFsbENsYXNzTWFpblR5cGVzKCksIHZpc2l0Q29tcG9uZW50LCB0aGlzKTtcblxuICAgIGZ1bmN0aW9uIHZpc2l0Q29tcG9uZW50KG1haW5UeXBlLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgIHZhciBuZXdDcHRPcHRpb25MaXN0ID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkobmV3T3B0aW9uW21haW5UeXBlXSk7XG4gICAgICB2YXIgbWFwUmVzdWx0ID0gbW9kZWxVdGlsLm1hcHBpbmdUb0V4aXN0cyhjb21wb25lbnRzTWFwLmdldChtYWluVHlwZSksIG5ld0NwdE9wdGlvbkxpc3QpO1xuICAgICAgbW9kZWxVdGlsLm1ha2VJZEFuZE5hbWUobWFwUmVzdWx0KTsgLy8gU2V0IG1haW5UeXBlIGFuZCBjb21wbGV0ZSBzdWJUeXBlLlxuXG4gICAgICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBvcHQgPSBpdGVtLm9wdGlvbjtcblxuICAgICAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgICAgIGl0ZW0ua2V5SW5mby5tYWluVHlwZSA9IG1haW5UeXBlO1xuICAgICAgICAgIGl0ZW0ua2V5SW5mby5zdWJUeXBlID0gZGV0ZXJtaW5lU3ViVHlwZShtYWluVHlwZSwgb3B0LCBpdGVtLmV4aXN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgZGVwZW5kZW50TW9kZWxzID0gZ2V0Q29tcG9uZW50c0J5VHlwZXMoY29tcG9uZW50c01hcCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIG9wdGlvblttYWluVHlwZV0gPSBbXTtcbiAgICAgIGNvbXBvbmVudHNNYXAuc2V0KG1haW5UeXBlLCBbXSk7XG4gICAgICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKHJlc3VsdEl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBjb21wb25lbnRNb2RlbCA9IHJlc3VsdEl0ZW0uZXhpc3Q7XG4gICAgICAgIHZhciBuZXdDcHRPcHRpb24gPSByZXN1bHRJdGVtLm9wdGlvbjtcbiAgICAgICAgYXNzZXJ0KGlzT2JqZWN0KG5ld0NwdE9wdGlvbikgfHwgY29tcG9uZW50TW9kZWwsICdFbXB0eSBjb21wb25lbnQgZGVmaW5pdGlvbicpOyAvLyBDb25zaWRlciB3aGVyZSBpcyBubyBuZXcgb3B0aW9uIGFuZCBzaG91bGQgYmUgbWVyZ2VkIHVzaW5nIHt9LFxuICAgICAgICAvLyBzZWUgcmVtb3ZlRWRnZUFuZEFkZCBpbiB0b3BvbG9naWNhbFRyYXZlbCBhbmRcbiAgICAgICAgLy8gQ29tcG9uZW50TW9kZWwuZ2V0QWxsQ2xhc3NNYWluVHlwZXMuXG5cbiAgICAgICAgaWYgKCFuZXdDcHRPcHRpb24pIHtcbiAgICAgICAgICBjb21wb25lbnRNb2RlbC5tZXJnZU9wdGlvbih7fSwgdGhpcyk7XG4gICAgICAgICAgY29tcG9uZW50TW9kZWwub3B0aW9uVXBkYXRlZCh7fSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBDb21wb25lbnRNb2RlbENsYXNzID0gQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3MobWFpblR5cGUsIHJlc3VsdEl0ZW0ua2V5SW5mby5zdWJUeXBlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChjb21wb25lbnRNb2RlbCAmJiBjb21wb25lbnRNb2RlbCBpbnN0YW5jZW9mIENvbXBvbmVudE1vZGVsQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm5hbWUgPSByZXN1bHRJdGVtLmtleUluZm8ubmFtZTsgLy8gY29tcG9uZW50TW9kZWwuc2V0dGluZ1Rhc2sgJiYgY29tcG9uZW50TW9kZWwuc2V0dGluZ1Rhc2suZGlydHkoKTtcblxuICAgICAgICAgICAgY29tcG9uZW50TW9kZWwubWVyZ2VPcHRpb24obmV3Q3B0T3B0aW9uLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm9wdGlvblVwZGF0ZWQobmV3Q3B0T3B0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgR2xvYmFsIGFzIHBhcmVudCA/XG4gICAgICAgICAgICB2YXIgZXh0cmFPcHQgPSBleHRlbmQoe1xuICAgICAgICAgICAgICBkZXBlbmRlbnRNb2RlbHM6IGRlcGVuZGVudE1vZGVscyxcbiAgICAgICAgICAgICAgY29tcG9uZW50SW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9LCByZXN1bHRJdGVtLmtleUluZm8pO1xuICAgICAgICAgICAgY29tcG9uZW50TW9kZWwgPSBuZXcgQ29tcG9uZW50TW9kZWxDbGFzcyhuZXdDcHRPcHRpb24sIHRoaXMsIHRoaXMsIGV4dHJhT3B0KTtcbiAgICAgICAgICAgIGV4dGVuZChjb21wb25lbnRNb2RlbCwgZXh0cmFPcHQpO1xuICAgICAgICAgICAgY29tcG9uZW50TW9kZWwuaW5pdChuZXdDcHRPcHRpb24sIHRoaXMsIHRoaXMsIGV4dHJhT3B0KTsgLy8gQ2FsbCBvcHRpb25VcGRhdGVkIGFmdGVyIGluaXQuXG4gICAgICAgICAgICAvLyBuZXdDcHRPcHRpb24gaGFzIGJlZW4gdXNlZCBhcyBjb21wb25lbnRNb2RlbC5vcHRpb25cbiAgICAgICAgICAgIC8vIGFuZCBtYXkgYmUgbWVyZ2VkIHdpdGggdGhlbWUgYW5kIGRlZmF1bHQsIHNvIHBhc3MgbnVsbFxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgY29uZnVzaW9uLlxuXG4gICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKG51bGwsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKVtpbmRleF0gPSBjb21wb25lbnRNb2RlbDtcbiAgICAgICAgb3B0aW9uW21haW5UeXBlXVtpbmRleF0gPSBjb21wb25lbnRNb2RlbC5vcHRpb247XG4gICAgICB9LCB0aGlzKTsgLy8gQmFja3VwIHNlcmllcyBmb3IgZmlsdGVyaW5nLlxuXG4gICAgICBpZiAobWFpblR5cGUgPT09ICdzZXJpZXMnKSB7XG4gICAgICAgIGNyZWF0ZVNlcmllc0luZGljZXModGhpcywgY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zZXJpZXNJbmRpY2VzTWFwID0gY3JlYXRlSGFzaE1hcCh0aGlzLl9zZXJpZXNJbmRpY2VzID0gdGhpcy5fc2VyaWVzSW5kaWNlcyB8fCBbXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBvcHRpb24gZm9yIG91dHB1dCAoY2xvbmVkIG9wdGlvbiBhbmQgaW5uZXIgaW5mbyByZW1vdmVkKVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE9wdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb24gPSBjbG9uZSh0aGlzLm9wdGlvbik7XG4gICAgZWFjaChvcHRpb24sIGZ1bmN0aW9uIChvcHRzLCBtYWluVHlwZSkge1xuICAgICAgaWYgKENvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgICB2YXIgb3B0cyA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG9wdHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBvcHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIG9wdGlvbnMgd2l0aCBpbm5lciBpZC5cbiAgICAgICAgICBpZiAobW9kZWxVdGlsLmlzSWRJbm5lcihvcHRzW2ldKSkge1xuICAgICAgICAgICAgb3B0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9uW21haW5UeXBlXSA9IG9wdHM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVsZXRlIG9wdGlvbltPUFRJT05fSU5ORVJfS0VZXTtcbiAgICByZXR1cm4gb3B0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICovXG4gIGdldFRoZW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW1lO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFpblR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpZHg9MF1cbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fVxuICAgKi9cbiAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiAobWFpblR5cGUsIGlkeCkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpO1xuXG4gICAgaWYgKGxpc3QpIHtcbiAgICAgIHJldHVybiBsaXN0W2lkeCB8fCAwXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG5vbmUgb2YgaW5kZXggYW5kIGlkIGFuZCBuYW1lIHVzZWQsIHJldHVybiBhbGwgY29tcG9uZW50cyB3aXRoIG1haW5UeXBlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb25kaXRpb24ubWFpblR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25kaXRpb24uc3ViVHlwZV0gSWYgaWdub3JlLCBvbmx5IHF1ZXJ5IGJ5IG1haW5UeXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbY29uZGl0aW9uLmluZGV4XSBFaXRoZXIgaW5wdXQgaW5kZXggb3IgaWQgb3IgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtjb25kaXRpb24uaWRdIEVpdGhlciBpbnB1dCBpbmRleCBvciBpZCBvciBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2NvbmRpdGlvbi5uYW1lXSBFaXRoZXIgaW5wdXQgaW5kZXggb3IgaWQgb3IgbmFtZS5cbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59XG4gICAqL1xuICBxdWVyeUNvbXBvbmVudHM6IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICB2YXIgbWFpblR5cGUgPSBjb25kaXRpb24ubWFpblR5cGU7XG5cbiAgICBpZiAoIW1haW5UeXBlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gY29uZGl0aW9uLmluZGV4O1xuICAgIHZhciBpZCA9IGNvbmRpdGlvbi5pZDtcbiAgICB2YXIgbmFtZSA9IGNvbmRpdGlvbi5uYW1lO1xuXG4gICAgdmFyIGNwdHMgPSB0aGlzLl9jb21wb25lbnRzTWFwLmdldChtYWluVHlwZSk7XG5cbiAgICBpZiAoIWNwdHMgfHwgIWNwdHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICBpZiAoIWlzQXJyYXkoaW5kZXgpKSB7XG4gICAgICAgIGluZGV4ID0gW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gZmlsdGVyKG1hcChpbmRleCwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gY3B0c1tpZHhdO1xuICAgICAgfSksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuICEhdmFsO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICB2YXIgaXNJZEFycmF5ID0gaXNBcnJheShpZCk7XG4gICAgICByZXN1bHQgPSBmaWx0ZXIoY3B0cywgZnVuY3Rpb24gKGNwdCkge1xuICAgICAgICByZXR1cm4gaXNJZEFycmF5ICYmIGluZGV4T2YoaWQsIGNwdC5pZCkgPj0gMCB8fCAhaXNJZEFycmF5ICYmIGNwdC5pZCA9PT0gaWQ7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgdmFyIGlzTmFtZUFycmF5ID0gaXNBcnJheShuYW1lKTtcbiAgICAgIHJlc3VsdCA9IGZpbHRlcihjcHRzLCBmdW5jdGlvbiAoY3B0KSB7XG4gICAgICAgIHJldHVybiBpc05hbWVBcnJheSAmJiBpbmRleE9mKG5hbWUsIGNwdC5uYW1lKSA+PSAwIHx8ICFpc05hbWVBcnJheSAmJiBjcHQubmFtZSA9PT0gbmFtZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXR1cm4gYWxsIGNvbXBvbmVudHMgd2l0aCBtYWluVHlwZVxuICAgICAgcmVzdWx0ID0gY3B0cy5zbGljZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWx0ZXJCeVN1YlR5cGUocmVzdWx0LCBjb25kaXRpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgaW50ZXJmYWNlIGlzIGRpZmZlcmVudCBmcm9tIHF1ZXJ5Q29tcG9uZW50cyxcbiAgICogd2hpY2ggaXMgY29udmVuaWVudCBmb3IgaW5uZXIgdXNhZ2UuXG4gICAqXG4gICAqIEB1c2FnZVxuICAgKiB2YXIgcmVzdWx0ID0gZmluZENvbXBvbmVudHMoXG4gICAqICAgICB7bWFpblR5cGU6ICdkYXRhWm9vbScsIHF1ZXJ5OiB7ZGF0YVpvb21JZDogJ2FiYyd9fVxuICAgKiApO1xuICAgKiB2YXIgcmVzdWx0ID0gZmluZENvbXBvbmVudHMoXG4gICAqICAgICB7bWFpblR5cGU6ICdzZXJpZXMnLCBzdWJUeXBlOiAncGllJywgcXVlcnk6IHtzZXJpZXNOYW1lOiAndWlvJ319XG4gICAqICk7XG4gICAqIHZhciByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcbiAgICogICAgIHttYWluVHlwZTogJ3Nlcmllcyd9LFxuICAgKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkgey4uLn1cbiAgICogKTtcbiAgICogLy8gcmVzdWx0IGxpa2UgW2NvbXBvbmVudDAsIGNvbXBvbm5ldDEsIC4uLl1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmRpdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZGl0aW9uLm1haW5UeXBlIE1hbmRhdG9yeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25kaXRpb24uc3ViVHlwZV0gT3B0aW9uYWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uLnF1ZXJ5XSBsaWtlIHt4eHhJbmRleCwgeHh4SWQsIHh4eE5hbWV9LFxuICAgKiAgICAgICAgd2hlcmUgeHh4IGlzIG1haW5UeXBlLlxuICAgKiAgICAgICAgSWYgcXVlcnkgYXR0cmlidXRlIGlzIG51bGwvdW5kZWZpbmVkIG9yIGhhcyBubyBpbmRleC9pZC9uYW1lLFxuICAgKiAgICAgICAgZG8gbm90IGZpbHRlcmluZyBieSBxdWVyeSBjb25kaXRpb25zLCB3aGljaCBpcyBjb252ZW5pZW50IGZvclxuICAgKiAgICAgICAgbm8tcGF5bG9hZCBzaXR1YXRpb25zIG9yIHdoZW4gdGFyZ2V0IG9mIGFjdGlvbiBpcyBnbG9iYWwuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25kaXRpb24uZmlsdGVyXSBwYXJhbWV0ZXI6IGNvbXBvbmVudCwgcmV0dXJuIGJvb2xlYW4uXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnQ+fVxuICAgKi9cbiAgZmluZENvbXBvbmVudHM6IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICB2YXIgcXVlcnkgPSBjb25kaXRpb24ucXVlcnk7XG4gICAgdmFyIG1haW5UeXBlID0gY29uZGl0aW9uLm1haW5UeXBlO1xuICAgIHZhciBxdWVyeUNvbmQgPSBnZXRRdWVyeUNvbmQocXVlcnkpO1xuICAgIHZhciByZXN1bHQgPSBxdWVyeUNvbmQgPyB0aGlzLnF1ZXJ5Q29tcG9uZW50cyhxdWVyeUNvbmQpIDogdGhpcy5fY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpO1xuICAgIHJldHVybiBkb0ZpbHRlcihmaWx0ZXJCeVN1YlR5cGUocmVzdWx0LCBjb25kaXRpb24pKTtcblxuICAgIGZ1bmN0aW9uIGdldFF1ZXJ5Q29uZChxKSB7XG4gICAgICB2YXIgaW5kZXhBdHRyID0gbWFpblR5cGUgKyAnSW5kZXgnO1xuICAgICAgdmFyIGlkQXR0ciA9IG1haW5UeXBlICsgJ0lkJztcbiAgICAgIHZhciBuYW1lQXR0ciA9IG1haW5UeXBlICsgJ05hbWUnO1xuICAgICAgcmV0dXJuIHEgJiYgKHFbaW5kZXhBdHRyXSAhPSBudWxsIHx8IHFbaWRBdHRyXSAhPSBudWxsIHx8IHFbbmFtZUF0dHJdICE9IG51bGwpID8ge1xuICAgICAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgICAgIC8vIHN1YlR5cGUgd2lsbCBiZSBmaWx0ZXJlZCBmaW5hbGx5LlxuICAgICAgICBpbmRleDogcVtpbmRleEF0dHJdLFxuICAgICAgICBpZDogcVtpZEF0dHJdLFxuICAgICAgICBuYW1lOiBxW25hbWVBdHRyXVxuICAgICAgfSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9GaWx0ZXIocmVzKSB7XG4gICAgICByZXR1cm4gY29uZGl0aW9uLmZpbHRlciA/IGZpbHRlcihyZXMsIGNvbmRpdGlvbi5maWx0ZXIpIDogcmVzO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHVzYWdlXG4gICAqIGVhY2hDb21wb25lbnQoJ2xlZ2VuZCcsIGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaW5kZXgpIHtcbiAgICogICAgIC4uLlxuICAgKiB9KTtcbiAgICogZWFjaENvbXBvbmVudChmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgbW9kZWwsIGluZGV4KSB7XG4gICAqICAgICAvLyBjb21wb25lbnRUeXBlIGRvZXMgbm90IGluY2x1ZGUgc3ViVHlwZVxuICAgKiAgICAgLy8gKGNvbXBvbmVudFR5cGUgaXMgJ3h4eCcgYnV0IG5vdCAneHh4LmFhJylcbiAgICogfSk7XG4gICAqIGVhY2hDb21wb25lbnQoXG4gICAqICAgICB7bWFpblR5cGU6ICdkYXRhWm9vbScsIHF1ZXJ5OiB7ZGF0YVpvb21JZDogJ2FiYyd9fSxcbiAgICogICAgIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHsuLi59XG4gICAqICk7XG4gICAqIGVhY2hDb21wb25lbnQoXG4gICAqICAgICB7bWFpblR5cGU6ICdzZXJpZXMnLCBzdWJUeXBlOiAncGllJywgcXVlcnk6IHtzZXJpZXNOYW1lOiAndWlvJ319LFxuICAgKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkgey4uLn1cbiAgICogKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0PX0gbWFpblR5cGUgV2hlbiBtYWluVHlwZSBpcyBvYmplY3QsIHRoZSBkZWZpbml0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRoZSBzYW1lIGFzIHRoZSBtZXRob2QgJ2ZpbmRDb21wb25lbnRzJy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBlYWNoQ29tcG9uZW50OiBmdW5jdGlvbiAobWFpblR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIGNvbXBvbmVudHNNYXAgPSB0aGlzLl9jb21wb25lbnRzTWFwO1xuXG4gICAgaWYgKHR5cGVvZiBtYWluVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGV4dCA9IGNiO1xuICAgICAgY2IgPSBtYWluVHlwZTtcbiAgICAgIGNvbXBvbmVudHNNYXAuZWFjaChmdW5jdGlvbiAoY29tcG9uZW50cywgY29tcG9uZW50VHlwZSkge1xuICAgICAgICBlYWNoKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBjb21wb25lbnRUeXBlLCBjb21wb25lbnQsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKG1haW5UeXBlKSkge1xuICAgICAgZWFjaChjb21wb25lbnRzTWFwLmdldChtYWluVHlwZSksIGNiLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG1haW5UeXBlKSkge1xuICAgICAgdmFyIHF1ZXJ5UmVzdWx0ID0gdGhpcy5maW5kQ29tcG9uZW50cyhtYWluVHlwZSk7XG4gICAgICBlYWNoKHF1ZXJ5UmVzdWx0LCBjYiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICovXG4gIGdldFNlcmllc0J5TmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpO1xuXG4gICAgcmV0dXJuIGZpbHRlcihzZXJpZXMsIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgIHJldHVybiBvbmVTZXJpZXMubmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc31cbiAgICovXG4gIGdldFNlcmllc0J5SW5kZXg6IGZ1bmN0aW9uIChzZXJpZXNJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJylbc2VyaWVzSW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgc2VyaWVzIGxpc3QgYmVmb3JlIGZpbHRlcmVkIGJ5IHR5cGUuXG4gICAqIEZJWE1FOiByZW5hbWUgdG8gZ2V0UmF3U2VyaWVzQnlUeXBlP1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViVHlwZVxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICovXG4gIGdldFNlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUpIHtcbiAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpO1xuXG4gICAgcmV0dXJuIGZpbHRlcihzZXJpZXMsIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgIHJldHVybiBvbmVTZXJpZXMuc3ViVHlwZSA9PT0gc3ViVHlwZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59XG4gICAqL1xuICBnZXRTZXJpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpLnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNlcmllc0NvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKS5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFmdGVyIGZpbHRlcmluZywgc2VyaWVzIG1heSBiZSBkaWZmZXJlbnRcbiAgICogZnJvbWUgcmF3IHNlcmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBlYWNoU2VyaWVzOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKVtyYXdTZXJpZXNJbmRleF07XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgc2VyaWVzLCByYXdTZXJpZXNJbmRleCk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgcmF3IHNlcmllcyBiZWZvcmUgZmlsdGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgKi9cbiAgZWFjaFJhd1NlcmllczogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZWFjaCh0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyksIGNiLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgZmlsdGVyaW5nLCBzZXJpZXMgbWF5IGJlIGRpZmZlcmVudC5cbiAgICogZnJvbWUgcmF3IHNlcmllcy5cbiAgICpcbiAgICogQHBhcm1hIHtzdHJpbmd9IHN1YlR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBlYWNoU2VyaWVzQnlUeXBlOiBmdW5jdGlvbiAoc3ViVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKVtyYXdTZXJpZXNJbmRleF07XG5cbiAgICAgIGlmIChzZXJpZXMuc3ViVHlwZSA9PT0gc3ViVHlwZSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHNlcmllcywgcmF3U2VyaWVzSW5kZXgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHJhdyBzZXJpZXMgYmVmb3JlIGZpbHRlcmVkIG9mIGdpdmVuIHR5cGUuXG4gICAqXG4gICAqIEBwYXJtYSB7c3RyaW5nfSBzdWJUeXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgKi9cbiAgZWFjaFJhd1Nlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGVhY2godGhpcy5nZXRTZXJpZXNCeVR5cGUoc3ViVHlwZSksIGNiLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAqL1xuICBpc1Nlcmllc0ZpbHRlcmVkOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fc2VyaWVzSW5kaWNlc01hcC5nZXQoc2VyaWVzTW9kZWwuY29tcG9uZW50SW5kZXgpID09IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZ2V0Q3VycmVudFNlcmllc0luZGljZXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX3Nlcmllc0luZGljZXMgfHwgW10pLnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgKi9cbiAgZmlsdGVyU2VyaWVzOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICB2YXIgZmlsdGVyZWRTZXJpZXMgPSBmaWx0ZXIodGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpLCBjYiwgY29udGV4dCk7XG4gICAgY3JlYXRlU2VyaWVzSW5kaWNlcyh0aGlzLCBmaWx0ZXJlZFNlcmllcyk7XG4gIH0sXG4gIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIHZhciBjb21wb25lbnRzTWFwID0gdGhpcy5fY29tcG9uZW50c01hcDtcbiAgICBjcmVhdGVTZXJpZXNJbmRpY2VzKHRoaXMsIGNvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSk7XG4gICAgdmFyIGNvbXBvbmVudFR5cGVzID0gW107XG4gICAgY29tcG9uZW50c01hcC5lYWNoKGZ1bmN0aW9uIChjb21wb25lbnRzLCBjb21wb25lbnRUeXBlKSB7XG4gICAgICBjb21wb25lbnRUeXBlcy5wdXNoKGNvbXBvbmVudFR5cGUpO1xuICAgIH0pO1xuICAgIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsKGNvbXBvbmVudFR5cGVzLCBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcygpLCBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICBlYWNoKGNvbXBvbmVudHNNYXAuZ2V0KGNvbXBvbmVudFR5cGUpLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIChjb21wb25lbnRUeXBlICE9PSAnc2VyaWVzJyB8fCAhaXNOb3RUYXJnZXRTZXJpZXMoY29tcG9uZW50LCBwYXlsb2FkKSkgJiYgY29tcG9uZW50LnJlc3RvcmVEYXRhKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGlzTm90VGFyZ2V0U2VyaWVzKHNlcmllc01vZGVsLCBwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgdmFyIGluZGV4ID0gcGF5bG9hZC5zZWlyZXNJbmRleDtcbiAgICB2YXIgaWQgPSBwYXlsb2FkLnNlcmllc0lkO1xuICAgIHZhciBuYW1lID0gcGF5bG9hZC5zZXJpZXNOYW1lO1xuICAgIHJldHVybiBpbmRleCAhPSBudWxsICYmIHNlcmllc01vZGVsLmNvbXBvbmVudEluZGV4ICE9PSBpbmRleCB8fCBpZCAhPSBudWxsICYmIHNlcmllc01vZGVsLmlkICE9PSBpZCB8fCBuYW1lICE9IG51bGwgJiYgc2VyaWVzTW9kZWwubmFtZSAhPT0gbmFtZTtcbiAgfVxufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlVGhlbWUob3B0aW9uLCB0aGVtZSkge1xuICAvLyBQRU5ESU5HXG4gIC8vIE5PVCB1c2UgYGNvbG9yTGF5ZXJgIGluIHRoZW1lIGlmIG9wdGlvbiBoYXMgYGNvbG9yYFxuICB2YXIgbm90TWVyZ2VDb2xvckxheWVyID0gb3B0aW9uLmNvbG9yICYmICFvcHRpb24uY29sb3JMYXllcjtcbiAgZWFjaCh0aGVtZSwgZnVuY3Rpb24gKHRoZW1lSXRlbSwgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSAnY29sb3JMYXllcicgJiYgbm90TWVyZ2VDb2xvckxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlpoLmnpzmnIkgY29tcG9uZW50IG1vZGVsIOWImeaKiuWFt+S9k+eahCBtZXJnZSDpgLvovpHkuqTnu5nor6UgbW9kZWwg5aSE55CGXG5cblxuICAgIGlmICghQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhlbWVJdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25bbmFtZV0gPSAhb3B0aW9uW25hbWVdID8gY2xvbmUodGhlbWVJdGVtKSA6IG1lcmdlKG9wdGlvbltuYW1lXSwgdGhlbWVJdGVtLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9uW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25bbmFtZV0gPSB0aGVtZUl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0QmFzZShiYXNlT3B0aW9uKSB7XG4gIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uOyAvLyBVc2luZyBPUFRJT05fSU5ORVJfS0VZIHRvIG1hcmsgdGhhdCB0aGlzIG9wdGlvbiBjYW4gbm90IGJlIHVzZWQgb3V0c2lkZSxcbiAgLy8gaS5lLiBgY2hhcnQuc2V0T3B0aW9uKGNoYXJ0LmdldE1vZGVsKCkub3B0aW9uKTtgIGlzIGZvcmJpZGVuLlxuXG4gIHRoaXMub3B0aW9uID0ge307XG4gIHRoaXMub3B0aW9uW09QVElPTl9JTk5FUl9LRVldID0gMTtcbiAgLyoqXG4gICAqIEluaXQgd2l0aCBzZXJpZXM6IFtdLCBpbiBjYXNlIG9mIGNhbGxpbmcgZmluZFNlcmllcyBtZXRob2RcbiAgICogYmVmb3JlIHNlcmllcyBpbml0aWFsaXplZC5cbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY29tcG9uZW50c01hcCA9IGNyZWF0ZUhhc2hNYXAoe1xuICAgIHNlcmllczogW11cbiAgfSk7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGJldHdlZW4gZmlsdGVyZWQgc2VyaWVzIGxpc3QgYW5kIHJhdyBzZXJpZXMgbGlzdC5cbiAgICoga2V5OiBmaWx0ZXJlZCBzZXJpZXMgaW5kaWNlcywgdmFsdWU6IHJhdyBzZXJpZXMgaW5kaWNlcy5cbiAgICogQHR5cGUge0FycmF5LjxudWJtZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9zZXJpZXNJbmRpY2VzO1xuICB0aGlzLl9zZXJpZXNJbmRpY2VzTWFwO1xuICBtZXJnZVRoZW1lKGJhc2VPcHRpb24sIHRoaXMuX3RoZW1lLm9wdGlvbik7IC8vIFRPRE8gTmVlZHMgY2xvbmUgd2hlbiBtZXJnaW5nIHRvIHRoZSB1bmV4aXN0ZWQgcHJvcGVydHlcblxuICBtZXJnZShiYXNlT3B0aW9uLCBnbG9iYWxEZWZhdWx0LCBmYWxzZSk7XG4gIHRoaXMubWVyZ2VPcHRpb24oYmFzZU9wdGlvbik7XG59XG4vKipcbiAqIEBpbm5lclxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPnxzdHJpbmd9IHR5cGVzIG1vZGVsIHR5cGVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IGtleToge3N0cmluZ30gdHlwZSwgdmFsdWU6IHtBcnJheS48T2JqZWN0Pn0gbW9kZWxzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzQnlUeXBlcyhjb21wb25lbnRzTWFwLCB0eXBlcykge1xuICBpZiAoIWlzQXJyYXkodHlwZXMpKSB7XG4gICAgdHlwZXMgPSB0eXBlcyA/IFt0eXBlc10gOiBbXTtcbiAgfVxuXG4gIHZhciByZXQgPSB7fTtcbiAgZWFjaCh0eXBlcywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXRbdHlwZV0gPSAoY29tcG9uZW50c01hcC5nZXQodHlwZSkgfHwgW10pLnNsaWNlKCk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbiwgZXhpc3RDb21wb25lbnQpIHtcbiAgdmFyIHN1YlR5cGUgPSBuZXdDcHRPcHRpb24udHlwZSA/IG5ld0NwdE9wdGlvbi50eXBlIDogZXhpc3RDb21wb25lbnQgPyBleGlzdENvbXBvbmVudC5zdWJUeXBlIC8vIFVzZSBkZXRlcm1pbmVTdWJUeXBlIG9ubHkgd2hlbiB0aGVyZSBpcyBubyBleGlzdENvbXBvbmVudC5cbiAgOiBDb21wb25lbnRNb2RlbC5kZXRlcm1pbmVTdWJUeXBlKG1haW5UeXBlLCBuZXdDcHRPcHRpb24pOyAvLyB0b29sdGlwLCBtYXJrbGluZSwgbWFya3BvaW50IG1heSBhbHdheXMgaGFzIG5vIHN1YlR5cGVcblxuICByZXR1cm4gc3ViVHlwZTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVTZXJpZXNJbmRpY2VzKGVjTW9kZWwsIHNlcmllc01vZGVscykge1xuICBlY01vZGVsLl9zZXJpZXNJbmRpY2VzTWFwID0gY3JlYXRlSGFzaE1hcChlY01vZGVsLl9zZXJpZXNJbmRpY2VzID0gbWFwKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgIHJldHVybiBzZXJpZXMuY29tcG9uZW50SW5kZXg7XG4gIH0pIHx8IFtdKTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBmaWx0ZXJCeVN1YlR5cGUoY29tcG9uZW50cywgY29uZGl0aW9uKSB7XG4gIC8vIFVzaW5nIGhhc093blByb3BlcnR5IGZvciByZXN0cmljdC4gQ29uc2lkZXJcbiAgLy8gc3ViVHlwZSBpcyB1bmRlZmluZWQgaW4gdXNlciBwYXlsb2FkLlxuICByZXR1cm4gY29uZGl0aW9uLmhhc093blByb3BlcnR5KCdzdWJUeXBlJykgPyBmaWx0ZXIoY29tcG9uZW50cywgZnVuY3Rpb24gKGNwdCkge1xuICAgIHJldHVybiBjcHQuc3ViVHlwZSA9PT0gY29uZGl0aW9uLnN1YlR5cGU7XG4gIH0pIDogY29tcG9uZW50cztcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRTZXJpZXNJbml0aWFsaXplZChlY01vZGVsKSB7fVxuXG5taXhpbihHbG9iYWxNb2RlbCwgY29sb3JQYWxldHRlTWl4aW4pO1xudmFyIF9kZWZhdWx0ID0gR2xvYmFsTW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL0dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvR2xvYmFsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBfbW9kZWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIG1ha2VJbm5lciA9IF9tb2RlbC5tYWtlSW5uZXI7XG5cbnZhciBfY2xhenogPSByZXF1aXJlKFwiLi4vdXRpbC9jbGF6elwiKTtcblxudmFyIGVuYWJsZUNsYXNzRXh0ZW5kID0gX2NsYXp6LmVuYWJsZUNsYXNzRXh0ZW5kO1xudmFyIGVuYWJsZUNsYXNzQ2hlY2sgPSBfY2xhenouZW5hYmxlQ2xhc3NDaGVjaztcblxudmFyIGxpbmVTdHlsZU1peGluID0gcmVxdWlyZShcIi4vbWl4aW4vbGluZVN0eWxlXCIpO1xuXG52YXIgYXJlYVN0eWxlTWl4aW4gPSByZXF1aXJlKFwiLi9taXhpbi9hcmVhU3R5bGVcIik7XG5cbnZhciB0ZXh0U3R5bGVNaXhpbiA9IHJlcXVpcmUoXCIuL21peGluL3RleHRTdHlsZVwiKTtcblxudmFyIGl0ZW1TdHlsZU1peGluID0gcmVxdWlyZShcIi4vbWl4aW4vaXRlbVN0eWxlXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL21vZGVsL01vZGVsXG4gKi9cbnZhciBtaXhpbiA9IHpyVXRpbC5taXhpbjtcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3BhcmVudE1vZGVsXVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IFtlY01vZGVsXVxuICovXG5cbmZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLnBhcmVudE1vZGVsID0gcGFyZW50TW9kZWw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgdGhpcy5vcHRpb24gPSBvcHRpb247IC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgLy8gaWYgKHRoaXMuaW5pdCkge1xuICAvLyAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gNCkge1xuICAvLyAgICAgICAgIHRoaXMuaW5pdChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCk7XG4gIC8vICAgICB9XG4gIC8vICAgICBlbHNlIHtcbiAgLy8gICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgLy8gICAgIH1cbiAgLy8gfVxufVxuXG5Nb2RlbC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBNb2RlbCxcblxuICAvKipcbiAgICogTW9kZWwg55qE5Yid5aeL5YyW5Ye95pWwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAgICovXG4gIGluaXQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIOS7juaWsOeahCBPcHRpb24gbWVyZ2VcbiAgICovXG4gIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBvcHRpb24sIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcGF0aFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVQYXJlbnQ9ZmFsc2VdXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBpZ25vcmVQYXJlbnQpIHtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvR2V0KHRoaXMub3B0aW9uLCB0aGlzLnBhcnNlUGF0aChwYXRoKSwgIWlnbm9yZVBhcmVudCAmJiBnZXRQYXJlbnQodGhpcywgcGF0aCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVBhcmVudD1mYWxzZV1cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldFNoYWxsb3c6IGZ1bmN0aW9uIChrZXksIGlnbm9yZVBhcmVudCkge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgdmFsID0gb3B0aW9uID09IG51bGwgPyBvcHRpb24gOiBvcHRpb25ba2V5XTtcbiAgICB2YXIgcGFyZW50TW9kZWwgPSAhaWdub3JlUGFyZW50ICYmIGdldFBhcmVudCh0aGlzLCBrZXkpO1xuXG4gICAgaWYgKHZhbCA9PSBudWxsICYmIHBhcmVudE1vZGVsKSB7XG4gICAgICB2YWwgPSBwYXJlbnRNb2RlbC5nZXRTaGFsbG93KGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtwYXRoXVxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbcGFyZW50TW9kZWxdXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgKi9cbiAgZ2V0TW9kZWw6IGZ1bmN0aW9uIChwYXRoLCBwYXJlbnRNb2RlbCkge1xuICAgIHZhciBvYmogPSBwYXRoID09IG51bGwgPyB0aGlzLm9wdGlvbiA6IGRvR2V0KHRoaXMub3B0aW9uLCBwYXRoID0gdGhpcy5wYXJzZVBhdGgocGF0aCkpO1xuICAgIHZhciB0aGlzUGFyZW50TW9kZWw7XG4gICAgcGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbCB8fCAodGhpc1BhcmVudE1vZGVsID0gZ2V0UGFyZW50KHRoaXMsIHBhdGgpKSAmJiB0aGlzUGFyZW50TW9kZWwuZ2V0TW9kZWwocGF0aCk7XG4gICAgcmV0dXJuIG5ldyBNb2RlbChvYmosIHBhcmVudE1vZGVsLCB0aGlzLmVjTW9kZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBtb2RlbCBoYXMgb3B0aW9uXG4gICAqL1xuICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uID09IG51bGw7XG4gIH0sXG4gIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7fSxcbiAgLy8gUGVuZGluZ1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBDdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gbmV3IEN0b3IoenJVdGlsLmNsb25lKHRoaXMub3B0aW9uKSk7XG4gIH0sXG4gIHNldFJlYWRPbmx5OiBmdW5jdGlvbiAocHJvcGVydGllcykgey8vIGNsYXp6VXRpbC5zZXRSZWFkT25seSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgfSxcbiAgLy8gSWYgcGF0aCBpcyBudWxsL3VuZGVmaW5lZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICBwYXJzZVBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0UGFyZW50TWV0aG9kXG4gICAqICAgICAgICBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBwYXRoXG4gICAqICAgICAgICByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgKi9cbiAgY3VzdG9taXplR2V0UGFyZW50OiBmdW5jdGlvbiAoZ2V0UGFyZW50TWV0aG9kKSB7XG4gICAgaW5uZXIodGhpcykuZ2V0UGFyZW50ID0gZ2V0UGFyZW50TWV0aG9kO1xuICB9LFxuICBpc0FuaW1hdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWVudi5ub2RlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb24uYW5pbWF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5vcHRpb24uYW5pbWF0aW9uO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudE1vZGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudE1vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZG9HZXQob2JqLCBwYXRoQXJyLCBwYXJlbnRNb2RlbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBJZ25vcmUgZW1wdHlcbiAgICBpZiAoIXBhdGhBcnJbaV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gb2JqIGNvdWxkIGJlIG51bWJlci9zdHJpbmcvLi4uIChsaWtlIDApXG5cblxuICAgIG9iaiA9IG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyA/IG9ialtwYXRoQXJyW2ldXSA6IG51bGw7XG5cbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvYmogPT0gbnVsbCAmJiBwYXJlbnRNb2RlbCkge1xuICAgIG9iaiA9IHBhcmVudE1vZGVsLmdldChwYXRoQXJyKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59IC8vIGBwYXRoYCBjYW4gYmUgbnVsbC91bmRlZmluZWRcblxuXG5mdW5jdGlvbiBnZXRQYXJlbnQobW9kZWwsIHBhdGgpIHtcbiAgdmFyIGdldFBhcmVudE1ldGhvZCA9IGlubmVyKG1vZGVsKS5nZXRQYXJlbnQ7XG4gIHJldHVybiBnZXRQYXJlbnRNZXRob2QgPyBnZXRQYXJlbnRNZXRob2QuY2FsbChtb2RlbCwgcGF0aCkgOiBtb2RlbC5wYXJlbnRNb2RlbDtcbn0gLy8gRW5hYmxlIE1vZGVsLmV4dGVuZC5cblxuXG5lbmFibGVDbGFzc0V4dGVuZChNb2RlbCk7XG5lbmFibGVDbGFzc0NoZWNrKE1vZGVsKTtcbm1peGluKE1vZGVsLCBsaW5lU3R5bGVNaXhpbik7XG5taXhpbihNb2RlbCwgYXJlYVN0eWxlTWl4aW4pO1xubWl4aW4oTW9kZWwsIHRleHRTdHlsZU1peGluKTtcbm1peGluKE1vZGVsLCBpdGVtU3R5bGVNaXhpbik7XG52YXIgX2RlZmF1bHQgPSBNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL01vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZShcIi4vQ29tcG9uZW50XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogRUNoYXJ0cyBvcHRpb24gbWFuYWdlclxuICpcbiAqIEBtb2R1bGUge2VjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlcn1cbiAqL1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBjbG9uZSA9IHpyVXRpbC5jbG9uZTtcbnZhciBtYXAgPSB6clV0aWwubWFwO1xudmFyIG1lcmdlID0genJVdGlsLm1lcmdlO1xudmFyIFFVRVJZX1JFRyA9IC9eKG1pbnxtYXgpPyguKykkLztcbi8qKlxuICogVEVSTSBFWFBMQU5BVElPTlM6XG4gKlxuICogW29wdGlvbl06XG4gKlxuICogICAgIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGRlZmluaXRpb25zIG9mIGNvbXBvbmVudHMuIEZvciBleGFtcGxlOlxuICogICAgIHZhciBvcHRpb24gPSB7XG4gKiAgICAgICAgIHRpdGxlOiB7Li4ufSxcbiAqICAgICAgICAgbGVnZW5kOiB7Li4ufSxcbiAqICAgICAgICAgdmlzdWFsTWFwOiB7Li4ufSxcbiAqICAgICAgICAgc2VyaWVzOiBbXG4gKiAgICAgICAgICAgICB7ZGF0YTogWy4uLl19LFxuICogICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAqICAgICAgICAgICAgIC4uLlxuICogICAgICAgICBdXG4gKiAgICAgfTtcbiAqXG4gKiBbcmF3T3B0aW9uXTpcbiAqXG4gKiAgICAgQW4gb2JqZWN0IGlucHV0IHRvIGVjaGFydHMuc2V0T3B0aW9uLiAncmF3T3B0aW9uJyBtYXkgYmUgYW5cbiAqICAgICAnb3B0aW9uJywgb3IgbWF5IGJlIGFuIG9iamVjdCBjb250YWlucyBtdWx0aS1vcHRpb25zLiBGb3IgZXhhbXBsZTpcbiAqICAgICB2YXIgb3B0aW9uID0ge1xuICogICAgICAgICBiYXNlT3B0aW9uOiB7XG4gKiAgICAgICAgICAgICB0aXRsZTogey4uLn0sXG4gKiAgICAgICAgICAgICBsZWdlbmQ6IHsuLi59LFxuICogICAgICAgICAgICAgc2VyaWVzOiBbXG4gKiAgICAgICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAqICAgICAgICAgICAgICAgICB7ZGF0YTogWy4uLl19LFxuICogICAgICAgICAgICAgICAgIC4uLlxuICogICAgICAgICAgICAgXVxuICogICAgICAgICB9LFxuICogICAgICAgICB0aW1lbGluZTogey4uLn0sXG4gKiAgICAgICAgIG9wdGlvbnM6IFtcbiAqICAgICAgICAgICAgIHt0aXRsZTogey4uLn0sIHNlcmllczoge2RhdGE6IFsuLi5dfX0sXG4gKiAgICAgICAgICAgICB7dGl0bGU6IHsuLi59LCBzZXJpZXM6IHtkYXRhOiBbLi4uXX19LFxuICogICAgICAgICAgICAgLi4uXG4gKiAgICAgICAgIF0sXG4gKiAgICAgICAgIG1lZGlhOiBbXG4gKiAgICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgICAgcXVlcnk6IHttYXhXaWR0aDogMzIwfSxcbiAqICAgICAgICAgICAgICAgICBvcHRpb246IHtzZXJpZXM6IHt4OiAyMH0sIHZpc3VhbE1hcDoge3Nob3c6IGZhbHNlfX1cbiAqICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgICAgcXVlcnk6IHttaW5XaWR0aDogMzIwLCBtYXhXaWR0aDogNzIwfSxcbiAqICAgICAgICAgICAgICAgICBvcHRpb246IHtzZXJpZXM6IHt4OiA1MDB9LCB2aXN1YWxNYXA6IHtzaG93OiB0cnVlfX1cbiAqICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogMTIwMH0sIHZpc3VhbE1hcDoge3Nob3c6IHRydWV9fVxuICogICAgICAgICAgICAgfVxuICogICAgICAgICBdXG4gKiAgICAgfTtcbiAqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlclxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICovXG5cbmZ1bmN0aW9uIE9wdGlvbk1hbmFnZXIoYXBpKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgKi9cbiAgdGhpcy5fYXBpID0gYXBpO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cblxuICB0aGlzLl90aW1lbGluZU9wdGlvbnMgPSBbXTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICovXG5cbiAgdGhpcy5fbWVkaWFMaXN0ID0gW107XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9tZWRpYURlZmF1bHQ7XG4gIC8qKlxuICAgKiAtMSwgbWVhbnMgZGVmYXVsdC5cbiAgICogZW1wdHkgbWVhbnMgbm8gbWVkaWEuXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cbiAgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcyA9IFtdO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5fb3B0aW9uQmFja3VwO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5fbmV3QmFzZU9wdGlvbjtcbn0gLy8gdGltZWxpbmUubm90TWVyZ2UgaXMgbm90IHN1cHBvcnRlZCBpbiBlYzMuIEZpcnN0bHkgdGhlcmUgaXMgcmVhcmx5XG4vLyBjYXNlIHRoYXQgbm90TWVyZ2UgaXMgbmVlZGVkLiBTZWNvbmRseSBzdXBwb3J0aW5nICdub3RNZXJnZScgcmVxdWlyZXNcbi8vIHJhd09wdGlvbiBjbG9uZWQgYW5kIGJhY2t1cGVkIHdoZW4gdGltZWxpbmUgY2hhbmdlZCwgd2hpY2ggZG9lcyBub1xuLy8gZ29vZCB0byBwZXJmb3JtYW5jZS4gV2hhdCdzIG1vcmUsIHRoYXQgYm90aCB0aW1lbGluZSBhbmQgc2V0T3B0aW9uXG4vLyBtZXRob2Qgc3VwcGx5ICdub3RNZXJnZScgYnJpbmdzIGNvbXBsZXggYW5kIHNvbWUgcHJvYmxlbXMuXG4vLyBDb25zaWRlciB0aGlzIGNhc2U6XG4vLyAoc3RlcDEpIGNoYXJ0LnNldE9wdGlvbih7dGltZWxpbmU6IHtub3RNZXJnZTogZmFsc2V9LCAuLi59LCBmYWxzZSk7XG4vLyAoc3RlcDIpIGNoYXJ0LnNldE9wdGlvbih7dGltZWxpbmU6IHtub3RNZXJnZTogdHJ1ZX0sIC4uLn0sIGZhbHNlKTtcblxuXG5PcHRpb25NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE9wdGlvbk1hbmFnZXIsXG5cbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtPYmplY3R9IHJhd09wdGlvbiBSYXcgb3B0aW9uLlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0ge0FycmF5LjxGdW5jdGlvbj59IG9wdGlvblByZXByb2Nlc3NvckZ1bmNzXG4gICAqIEByZXR1cm4ge09iamVjdH0gSW5pdCBvcHRpb25cbiAgICovXG4gIHNldE9wdGlvbjogZnVuY3Rpb24gKHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpIHtcbiAgICBpZiAocmF3T3B0aW9uKSB7XG4gICAgICAvLyBUaGF0IHNldCBkYXQgcHJpbWl0aXZlIGlzIGRhbmdlcm91cyBpZiB1c2VyIHJldXNlIHRoZSBkYXRhIHdoZW4gc2V0T3B0aW9uIGFnYWluLlxuICAgICAgenJVdGlsLmVhY2gobW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkocmF3T3B0aW9uLnNlcmllcyksIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgICAgc2VyaWVzICYmIHNlcmllcy5kYXRhICYmIHpyVXRpbC5pc1R5cGVkQXJyYXkoc2VyaWVzLmRhdGEpICYmIHpyVXRpbC5zZXRBc1ByaW1pdGl2ZShzZXJpZXMuZGF0YSk7XG4gICAgICB9KTtcbiAgICB9IC8vIENhdXRpb246IHNvbWUgc2VyaWVzIG1vZGlmeSBvcHRpb24gZGF0YSwgaWYgZG8gbm90IGNsb25lLFxuICAgIC8vIGl0IHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgcmVwZWF0IG1vZGlmeSBjb3JyZWN0bHlcbiAgICAvLyAoY3JlYXRlIGEgbmV3IG9iamVjdCB3aGVuIG1vZGlmeSBpdHNlbGYpLlxuXG5cbiAgICByYXdPcHRpb24gPSBjbG9uZShyYXdPcHRpb24sIHRydWUpOyAvLyBGSVhNRVxuICAgIC8vIOWmguaenCB0aW1lbGluZSBvcHRpb25zIOaIluiAhSBtZWRpYSDkuK3orr7nva7kuobmn5DkuKrlsZ7mgKfvvIzogIxiYXNlT3B0aW9u5Lit5rKh5pyJ6K6+572u77yM5YiZ6L+b6KGM6K2m5ZGK44CCXG5cbiAgICB2YXIgb2xkT3B0aW9uQmFja3VwID0gdGhpcy5fb3B0aW9uQmFja3VwO1xuICAgIHZhciBuZXdQYXJzZWRPcHRpb24gPSBwYXJzZVJhd09wdGlvbi5jYWxsKHRoaXMsIHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsICFvbGRPcHRpb25CYWNrdXApO1xuICAgIHRoaXMuX25ld0Jhc2VPcHRpb24gPSBuZXdQYXJzZWRPcHRpb24uYmFzZU9wdGlvbjsgLy8gRm9yIHNldE9wdGlvbiBhdCBzZWNvbmQgdGltZSAodXNpbmcgbWVyZ2UgbW9kZSk7XG5cbiAgICBpZiAob2xkT3B0aW9uQmFja3VwKSB7XG4gICAgICAvLyBPbmx5IGJhc2VPcHRpb24gY2FuIGJlIG1lcmdlZC5cbiAgICAgIG1lcmdlT3B0aW9uKG9sZE9wdGlvbkJhY2t1cC5iYXNlT3B0aW9uLCBuZXdQYXJzZWRPcHRpb24uYmFzZU9wdGlvbik7IC8vIEZvciBzaW1wbGljaXR5LCB0aW1lbGluZSBvcHRpb25zIGFuZCBtZWRpYSBvcHRpb25zIGRvIG5vdCBzdXBwb3J0IG1lcmdlLFxuICAgICAgLy8gdGhhdCBpcywgaWYgeW91IGBzZXRPcHRpb25gIHR3aWNlIGFuZCBib3RoIGhhcyB0aW1lbGluZSBvcHRpb25zLCB0aGUgbGF0dGVyXG4gICAgICAvLyB0aW1lbGluZSBvcGl0b25zIHdpbGwgbm90IGJlIG1lcmdlZCB0byB0aGUgZm9ybWVycywgYnV0IGp1c3Qgc3Vic3RpdHVkZSB0aGVtLlxuXG4gICAgICBpZiAobmV3UGFyc2VkT3B0aW9uLnRpbWVsaW5lT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgb2xkT3B0aW9uQmFja3VwLnRpbWVsaW5lT3B0aW9ucyA9IG5ld1BhcnNlZE9wdGlvbi50aW1lbGluZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24ubWVkaWFMaXN0Lmxlbmd0aCkge1xuICAgICAgICBvbGRPcHRpb25CYWNrdXAubWVkaWFMaXN0ID0gbmV3UGFyc2VkT3B0aW9uLm1lZGlhTGlzdDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1BhcnNlZE9wdGlvbi5tZWRpYURlZmF1bHQpIHtcbiAgICAgICAgb2xkT3B0aW9uQmFja3VwLm1lZGlhRGVmYXVsdCA9IG5ld1BhcnNlZE9wdGlvbi5tZWRpYURlZmF1bHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbkJhY2t1cCA9IG5ld1BhcnNlZE9wdGlvbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSZWNyZWF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBtb3VudE9wdGlvbjogZnVuY3Rpb24gKGlzUmVjcmVhdGUpIHtcbiAgICB2YXIgb3B0aW9uQmFja3VwID0gdGhpcy5fb3B0aW9uQmFja3VwOyAvLyBUT0RPXG4gICAgLy8g5aaC5p6c5rKh5pyJcmVzZXTlip/og73liJnkuI1jbG9uZeOAglxuXG4gICAgdGhpcy5fdGltZWxpbmVPcHRpb25zID0gbWFwKG9wdGlvbkJhY2t1cC50aW1lbGluZU9wdGlvbnMsIGNsb25lKTtcbiAgICB0aGlzLl9tZWRpYUxpc3QgPSBtYXAob3B0aW9uQmFja3VwLm1lZGlhTGlzdCwgY2xvbmUpO1xuICAgIHRoaXMuX21lZGlhRGVmYXVsdCA9IGNsb25lKG9wdGlvbkJhY2t1cC5tZWRpYURlZmF1bHQpO1xuICAgIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBbXTtcbiAgICByZXR1cm4gY2xvbmUoaXNSZWNyZWF0ZSAvLyB0aGlzLl9vcHRpb25CYWNrdXAuYmFzZU9wdGlvbiwgd2hpY2ggaXMgY3JlYXRlZCBhdCB0aGUgZmlyc3QgYHNldE9wdGlvbmBcbiAgICAvLyBjYWxsZWQsIGFuZCBpcyBtZXJnZWQgaW50byBldmVyeSBuZXcgb3B0aW9uIGJ5IGlubmVyIG1ldGhvZCBgbWVyZ2VPcHRpb25gXG4gICAgLy8gZWFjaCB0aW1lIGBzZXRPcHRpb25gIGNhbGxlZCwgY2FuIGJlIG9ubHkgdXNlZCBpbiBgaXNSZWNyZWF0ZWAsIGJlY2F1c2VcbiAgICAvLyBpdHMgcmVsaWFiaWxpdHkgaXMgdW5kZXIgc3VzcGljaW9uLiBJbiBvdGhlciBjYXNlcyBvcHRpb24gbWVyZ2UgaXNcbiAgICAvLyBwZXJmb3JtZWQgYnkgYG1vZGVsLm1lcmdlT3B0aW9uYC5cbiAgICA/IG9wdGlvbkJhY2t1cC5iYXNlT3B0aW9uIDogdGhpcy5fbmV3QmFzZU9wdGlvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFRpbWVsaW5lT3B0aW9uOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBvcHRpb247XG4gICAgdmFyIHRpbWVsaW5lT3B0aW9ucyA9IHRoaXMuX3RpbWVsaW5lT3B0aW9ucztcblxuICAgIGlmICh0aW1lbGluZU9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAvLyBnZXRUaW1lbGluZU9wdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgZWNNb2RlbCBpbml0ZWQsXG4gICAgICAvLyBzbyB3ZSBjYW4gZ2V0IGN1cnJlbnRJbmRleCBmcm9tIHRpbWVsaW5lTW9kZWwuXG4gICAgICB2YXIgdGltZWxpbmVNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0aW1lbGluZScpO1xuXG4gICAgICBpZiAodGltZWxpbmVNb2RlbCkge1xuICAgICAgICBvcHRpb24gPSBjbG9uZSh0aW1lbGluZU9wdGlvbnNbdGltZWxpbmVNb2RlbC5nZXRDdXJyZW50SW5kZXgoKV0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fVxuICAgKi9cbiAgZ2V0TWVkaWFPcHRpb246IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGVjV2lkdGggPSB0aGlzLl9hcGkuZ2V0V2lkdGgoKTtcblxuICAgIHZhciBlY0hlaWdodCA9IHRoaXMuX2FwaS5nZXRIZWlnaHQoKTtcblxuICAgIHZhciBtZWRpYUxpc3QgPSB0aGlzLl9tZWRpYUxpc3Q7XG4gICAgdmFyIG1lZGlhRGVmYXVsdCA9IHRoaXMuX21lZGlhRGVmYXVsdDtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTsgLy8gTm8gbWVkaWEgZGVmaW5lZC5cblxuICAgIGlmICghbWVkaWFMaXN0Lmxlbmd0aCAmJiAhbWVkaWFEZWZhdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gLy8gTXVsdGkgbWVkaWEgbWF5IGJlIGFwcGxpZWQsIHRoZSBsYXR0ZXIgZGVmaW5lZCBtZWRpYSBoYXMgaGlnaGVyIHByaW9yaXR5LlxuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWVkaWFMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXBwbHlNZWRpYVF1ZXJ5KG1lZGlhTGlzdFtpXS5xdWVyeSwgZWNXaWR0aCwgZWNIZWlnaHQpKSB7XG4gICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9IC8vIEZJWE1FXG4gICAgLy8g5piv5ZCmbWVkaWFEZWZhdWx05bqU6K+l5by65Yi255So5oi36K6+572u77yM5ZCm5YiZ5Y+v6IO95L+u5pS55LiN6IO95Zue5b2S44CCXG5cblxuICAgIGlmICghaW5kaWNlcy5sZW5ndGggJiYgbWVkaWFEZWZhdWx0KSB7XG4gICAgICBpbmRpY2VzID0gWy0xXTtcbiAgICB9XG5cbiAgICBpZiAoaW5kaWNlcy5sZW5ndGggJiYgIWluZGljZXNFcXVhbHMoaW5kaWNlcywgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcykpIHtcbiAgICAgIHJlc3VsdCA9IG1hcChpbmRpY2VzLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKGluZGV4ID09PSAtMSA/IG1lZGlhRGVmYXVsdC5vcHRpb24gOiBtZWRpYUxpc3RbaW5kZXhdLm9wdGlvbik7XG4gICAgICB9KTtcbiAgICB9IC8vIE90aGVyd2lzZSByZXR1cm4gbm90aGluZy5cblxuXG4gICAgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcyA9IGluZGljZXM7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyc2VSYXdPcHRpb24ocmF3T3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgaXNOZXcpIHtcbiAgdmFyIHRpbWVsaW5lT3B0aW9ucyA9IFtdO1xuICB2YXIgbWVkaWFMaXN0ID0gW107XG4gIHZhciBtZWRpYURlZmF1bHQ7XG4gIHZhciBiYXNlT3B0aW9uOyAvLyBDb21wYXRpYmxlIHdpdGggZWMyLlxuXG4gIHZhciB0aW1lbGluZU9wdCA9IHJhd09wdGlvbi50aW1lbGluZTtcblxuICBpZiAocmF3T3B0aW9uLmJhc2VPcHRpb24pIHtcbiAgICBiYXNlT3B0aW9uID0gcmF3T3B0aW9uLmJhc2VPcHRpb247XG4gIH0gLy8gRm9yIHRpbWVsaW5lXG5cblxuICBpZiAodGltZWxpbmVPcHQgfHwgcmF3T3B0aW9uLm9wdGlvbnMpIHtcbiAgICBiYXNlT3B0aW9uID0gYmFzZU9wdGlvbiB8fCB7fTtcbiAgICB0aW1lbGluZU9wdGlvbnMgPSAocmF3T3B0aW9uLm9wdGlvbnMgfHwgW10pLnNsaWNlKCk7XG4gIH0gLy8gRm9yIG1lZGlhIHF1ZXJ5XG5cblxuICBpZiAocmF3T3B0aW9uLm1lZGlhKSB7XG4gICAgYmFzZU9wdGlvbiA9IGJhc2VPcHRpb24gfHwge307XG4gICAgdmFyIG1lZGlhID0gcmF3T3B0aW9uLm1lZGlhO1xuICAgIGVhY2gobWVkaWEsIGZ1bmN0aW9uIChzaW5nbGVNZWRpYSkge1xuICAgICAgaWYgKHNpbmdsZU1lZGlhICYmIHNpbmdsZU1lZGlhLm9wdGlvbikge1xuICAgICAgICBpZiAoc2luZ2xlTWVkaWEucXVlcnkpIHtcbiAgICAgICAgICBtZWRpYUxpc3QucHVzaChzaW5nbGVNZWRpYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW1lZGlhRGVmYXVsdCkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZmlyc3QgbWVkaWEgZGVmYXVsdC5cbiAgICAgICAgICBtZWRpYURlZmF1bHQgPSBzaW5nbGVNZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIEZvciBub3JtYWwgb3B0aW9uXG5cblxuICBpZiAoIWJhc2VPcHRpb24pIHtcbiAgICBiYXNlT3B0aW9uID0gcmF3T3B0aW9uO1xuICB9IC8vIFNldCB0aW1lbGluZU9wdCB0byBiYXNlT3B0aW9uIGluIGVjMyxcbiAgLy8gd2hpY2ggaXMgY29udmVuaWVudCBmb3IgbWVyZ2Ugb3B0aW9uLlxuXG5cbiAgaWYgKCFiYXNlT3B0aW9uLnRpbWVsaW5lKSB7XG4gICAgYmFzZU9wdGlvbi50aW1lbGluZSA9IHRpbWVsaW5lT3B0O1xuICB9IC8vIFByZXByb2Nlc3MuXG5cblxuICBlYWNoKFtiYXNlT3B0aW9uXS5jb25jYXQodGltZWxpbmVPcHRpb25zKS5jb25jYXQoenJVdGlsLm1hcChtZWRpYUxpc3QsIGZ1bmN0aW9uIChtZWRpYSkge1xuICAgIHJldHVybiBtZWRpYS5vcHRpb247XG4gIH0pKSwgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIGVhY2gob3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsIGZ1bmN0aW9uIChwcmVQcm9jZXNzKSB7XG4gICAgICBwcmVQcm9jZXNzKG9wdGlvbiwgaXNOZXcpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBiYXNlT3B0aW9uOiBiYXNlT3B0aW9uLFxuICAgIHRpbWVsaW5lT3B0aW9uczogdGltZWxpbmVPcHRpb25zLFxuICAgIG1lZGlhRGVmYXVsdDogbWVkaWFEZWZhdWx0LFxuICAgIG1lZGlhTGlzdDogbWVkaWFMaXN0XG4gIH07XG59XG4vKipcbiAqIEBzZWUgPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtbWVkaWFxdWVyaWVzLyNtZWRpYTE+XG4gKiBTdXBwb3J0OiB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpb1xuICogQ2FuIHVzZSBtYXggb3IgbWluIGFzIHByZWZpeC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFwcGx5TWVkaWFRdWVyeShxdWVyeSwgZWNXaWR0aCwgZWNIZWlnaHQpIHtcbiAgdmFyIHJlYWxNYXAgPSB7XG4gICAgd2lkdGg6IGVjV2lkdGgsXG4gICAgaGVpZ2h0OiBlY0hlaWdodCxcbiAgICBhc3BlY3RyYXRpbzogZWNXaWR0aCAvIGVjSGVpZ2h0IC8vIGxvd3NlciBjYXNlIGZvciBjb252ZW5pZW50Y2UuXG5cbiAgfTtcbiAgdmFyIGFwcGxpY2F0YWJsZSA9IHRydWU7XG4gIHpyVXRpbC5lYWNoKHF1ZXJ5LCBmdW5jdGlvbiAodmFsdWUsIGF0dHIpIHtcbiAgICB2YXIgbWF0Y2hlZCA9IGF0dHIubWF0Y2goUVVFUllfUkVHKTtcblxuICAgIGlmICghbWF0Y2hlZCB8fCAhbWF0Y2hlZFsxXSB8fCAhbWF0Y2hlZFsyXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcGVyYXRvciA9IG1hdGNoZWRbMV07XG4gICAgdmFyIHJlYWxBdHRyID0gbWF0Y2hlZFsyXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKCFjb21wYXJlKHJlYWxNYXBbcmVhbEF0dHJdLCB2YWx1ZSwgb3BlcmF0b3IpKSB7XG4gICAgICBhcHBsaWNhdGFibGUgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXBwbGljYXRhYmxlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlKHJlYWwsIGV4cGVjdCwgb3BlcmF0b3IpIHtcbiAgaWYgKG9wZXJhdG9yID09PSAnbWluJykge1xuICAgIHJldHVybiByZWFsID49IGV4cGVjdDtcbiAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ21heCcpIHtcbiAgICByZXR1cm4gcmVhbCA8PSBleHBlY3Q7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXF1YWxzXG4gICAgcmV0dXJuIHJlYWwgPT09IGV4cGVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRpY2VzRXF1YWxzKGluZGljZXMxLCBpbmRpY2VzMikge1xuICAvLyBpbmRpY2VzIGlzIGFsd2F5cyBvcmRlciBieSBhc2MgYW5kIGhhcyBvbmx5IGZpbml0ZSBudW1iZXIuXG4gIHJldHVybiBpbmRpY2VzMS5qb2luKCcsJykgPT09IGluZGljZXMyLmpvaW4oJywnKTtcbn1cbi8qKlxuICogQ29uc2lkZXIgY2FzZTpcbiAqIGBjaGFydC5zZXRPcHRpb24ob3B0MSk7YFxuICogVGhlbiB1c2VyIGRvIHNvbWUgaW50ZXJhY3Rpb24gbGlrZSBkYXRhWm9vbSwgZGF0YVZpZXcgY2hhbmdpbmcuXG4gKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2BcbiAqIFRoZW4gdXNlciBwcmVzcyAncmVzZXQgYnV0dG9uJyBpbiB0b29sYm94LlxuICpcbiAqIEFmdGVyIGRvaW5nIHRoYXQgYWxsIG9mIHRoZSBpbnRlcmFjdGlvbiBlZmZlY3RzIHNob3VsZCBiZSByZXNldCwgdGhlXG4gKiBjaGFydCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhlIHJlc3VsdCBvZiBpbnZva2VcbiAqIGBjaGFydC5zZXRPcHRpb24ob3B0MSk7IGNoYXJ0LnNldE9wdGlvbihvcHQyKTtgLlxuICpcbiAqIEFsdGhvdWdoIGl0IGlzIG5vdCBhYmxlIGVuc3VyZSB0aGF0XG4gKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpOyBjaGFydC5zZXRPcHRpb24ob3B0Mik7YCBpcyBlcXVpdmFsZW50cyB0b1xuICogYGNoYXJ0LnNldE9wdGlvbihtZXJnZShvcHQxLCBvcHQyKSk7YCBleGFjdGx5LFxuICogdGhpcyBtaWdodCBiZSB0aGUgb25seSBzaW1wbGUgd2F5IHRvIGltcGxlbWVudCB0aGF0IGZlYXR1cmUuXG4gKlxuICogTUVNTzogV2UndmUgY29uc2lkZXJlZCBzb21lIG90aGVyIGFwcHJvYWNoZXM6XG4gKiAxLiBFYWNoIG1vZGVsIGhhbmRsZSBpdHMgc2VsZiByZXN0b3JhdGlvbiBidXQgbm90IHVuaWZvcm0gdHJlYXRtZW50LlxuICogICAgIChUb28gY29tcGxleCBpbiBsb2dpYyBhbmQgZXJyb3ItcHJvbmUpXG4gKiAyLiBVc2UgYSBzaGFkb3cgZWNNb2RlbC4gKFBlcmZvcm1hY2UgZXhwZW5zaXZlKVxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb24ob2xkT3B0aW9uLCBuZXdPcHRpb24pIHtcbiAgbmV3T3B0aW9uID0gbmV3T3B0aW9uIHx8IHt9O1xuICBlYWNoKG5ld09wdGlvbiwgZnVuY3Rpb24gKG5ld0NwdE9wdCwgbWFpblR5cGUpIHtcbiAgICBpZiAobmV3Q3B0T3B0ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ3B0T3B0ID0gb2xkT3B0aW9uW21haW5UeXBlXTtcblxuICAgIGlmICghQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICBvbGRPcHRpb25bbWFpblR5cGVdID0gbWVyZ2Uob2xkQ3B0T3B0LCBuZXdDcHRPcHQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdDcHRPcHQgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShuZXdDcHRPcHQpO1xuICAgICAgb2xkQ3B0T3B0ID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkob2xkQ3B0T3B0KTtcbiAgICAgIHZhciBtYXBSZXN1bHQgPSBtb2RlbFV0aWwubWFwcGluZ1RvRXhpc3RzKG9sZENwdE9wdCwgbmV3Q3B0T3B0KTtcbiAgICAgIG9sZE9wdGlvblttYWluVHlwZV0gPSBtYXAobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5vcHRpb24gJiYgaXRlbS5leGlzdCA/IG1lcmdlKGl0ZW0uZXhpc3QsIGl0ZW0ub3B0aW9uLCB0cnVlKSA6IGl0ZW0uZXhpc3QgfHwgaXRlbS5vcHRpb247XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgX2RlZmF1bHQgPSBPcHRpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9PcHRpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9PcHRpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBfZm9ybWF0ID0gcmVxdWlyZShcIi4uL3V0aWwvZm9ybWF0XCIpO1xuXG52YXIgZm9ybWF0VGltZSA9IF9mb3JtYXQuZm9ybWF0VGltZTtcbnZhciBlbmNvZGVIVE1MID0gX2Zvcm1hdC5lbmNvZGVIVE1MO1xudmFyIGFkZENvbW1hcyA9IF9mb3JtYXQuYWRkQ29tbWFzO1xudmFyIGdldFRvb2x0aXBNYXJrZXIgPSBfZm9ybWF0LmdldFRvb2x0aXBNYXJrZXI7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZShcIi4vQ29tcG9uZW50XCIpO1xuXG52YXIgY29sb3JQYWxldHRlTWl4aW4gPSByZXF1aXJlKFwiLi9taXhpbi9jb2xvclBhbGV0dGVcIik7XG5cbnZhciBkYXRhRm9ybWF0TWl4aW4gPSByZXF1aXJlKFwiLi4vbW9kZWwvbWl4aW4vZGF0YUZvcm1hdFwiKTtcblxudmFyIF9sYXlvdXQgPSByZXF1aXJlKFwiLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBnZXRMYXlvdXRQYXJhbXMgPSBfbGF5b3V0LmdldExheW91dFBhcmFtcztcbnZhciBtZXJnZUxheW91dFBhcmFtID0gX2xheW91dC5tZXJnZUxheW91dFBhcmFtO1xuXG52YXIgX3Rhc2sgPSByZXF1aXJlKFwiLi4vc3RyZWFtL3Rhc2tcIik7XG5cbnZhciBjcmVhdGVUYXNrID0gX3Rhc2suY3JlYXRlVGFzaztcblxudmFyIF9zb3VyY2VIZWxwZXIgPSByZXF1aXJlKFwiLi4vZGF0YS9oZWxwZXIvc291cmNlSGVscGVyXCIpO1xuXG52YXIgcHJlcGFyZVNvdXJjZSA9IF9zb3VyY2VIZWxwZXIucHJlcGFyZVNvdXJjZTtcbnZhciBnZXRTb3VyY2UgPSBfc291cmNlSGVscGVyLmdldFNvdXJjZTtcblxudmFyIF9kYXRhUHJvdmlkZXIgPSByZXF1aXJlKFwiLi4vZGF0YS9oZWxwZXIvZGF0YVByb3ZpZGVyXCIpO1xuXG52YXIgcmV0cmlldmVSYXdWYWx1ZSA9IF9kYXRhUHJvdmlkZXIucmV0cmlldmVSYXdWYWx1ZTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGlubmVyID0gbW9kZWxVdGlsLm1ha2VJbm5lcigpO1xudmFyIFNlcmllc01vZGVsID0gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ3Nlcmllcy5fX2Jhc2VfXycsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgc2VyaWVzSW5kZXg6IDAsXG4gIC8vIGNvb2RpbmF0ZVN5c3RlbSB3aWxsIGJlIGluamVjdGVkIGluIHRoZSBlY2hhcnRzL0Nvb3JkaW5hdGVTeXN0ZW1cbiAgY29vcmRpbmF0ZVN5c3RlbTogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZGVmYXVsdE9wdGlvbjogbnVsbCxcblxuICAvKipcbiAgICogRGF0YSBwcm92aWRlZCBmb3IgbGVnZW5kXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8vIFBFTkRJTkdcbiAgbGVnZW5kRGF0YVByb3ZpZGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBY2Nlc3MgcGF0aCBvZiBjb2xvciBmb3IgdmlzdWFsXG4gICAqL1xuICB2aXN1YWxDb2xvckFjY2Vzc1BhdGg6ICdpdGVtU3R5bGUuY29sb3InLFxuXG4gIC8qKlxuICAgKiBTdXBwb3J0IG1lcmdlIGxheW91dCBwYXJhbXMuXG4gICAqIE9ubHkgc3VwcG9ydCAnYm94JyBub3cgKGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQpLlxuICAgKiBAdHlwZSB7c3RyaW5nfE9iamVjdH0gT2JqZWN0IGNhbiBiZSB7aWdub3JlU2l6ZTogdHJ1ZX1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBsYXlvdXRNb2RlOiBudWxsLFxuICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuc2VyaWVzSW5kZXggPSB0aGlzLmNvbXBvbmVudEluZGV4O1xuICAgIHRoaXMuZGF0YVRhc2sgPSBjcmVhdGVUYXNrKHtcbiAgICAgIGNvdW50OiBkYXRhVGFza0NvdW50LFxuICAgICAgcmVzZXQ6IGRhdGFUYXNrUmVzZXRcbiAgICB9KTtcbiAgICB0aGlzLmRhdGFUYXNrLmNvbnRleHQgPSB7XG4gICAgICBtb2RlbDogdGhpc1xuICAgIH07XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIHByZXBhcmVTb3VyY2UodGhpcyk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldEluaXRpYWxEYXRhKG9wdGlvbiwgZWNNb2RlbCk7XG4gICAgd3JhcERhdGEoZGF0YSwgdGhpcyk7XG4gICAgdGhpcy5kYXRhVGFzay5jb250ZXh0LmRhdGEgPSBkYXRhO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdHxtb2R1bGU6ZWNoYXJ0cy9kYXRhL1RyZWV8bW9kdWxlOmVjaGFydHMvZGF0YS9HcmFwaH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlubmVyKHRoaXMpLmRhdGFCZWZvcmVQcm9jZXNzZWQgPSBkYXRhOyAvLyBJZiB3ZSByZXZlcnNlIHRoZSBvcmRlciAobWFrZSBkYXRhIGZpcnN0bHksIGFuZCB0aGVuIG1ha2VcbiAgICAvLyBkYXRhQmVmb3JlUHJvY2Vzc2VkIGJ5IGNsb25lU2hhbGxvdyksIGNsb25lU2hhbGxvdyB3aWxsXG4gICAgLy8gY2F1c2UgZGF0YS5ncmFwaC5kYXRhICE9PSBkYXRhIHdoZW4gdXNpbmdcbiAgICAvLyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL0dyYXBoIG9yIG1vZHVsZTplY2hhcnRzL2RhdGEvVHJlZS5cbiAgICAvLyBTZWUgbW9kdWxlOmVjaGFydHMvZGF0YS9oZWxwZXIvbGlua0xpc3RcbiAgICAvLyBUaGVvcmV0aWNhbGx5LCBpdCBpcyB1bnJlYXNvbmFibGUgdG8gY2FsbCBgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpYCBpbiB0aGUgbW9kZWxcbiAgICAvLyBpbml0IG9yIG1lcmdlIHN0YWdlLCBiZWNhdXNlIHRoZSBkYXRhIGNhbiBiZSByZXN0b3JlZC4gU28gd2UgZG8gbm90IGByZXN0b3JlRGF0YWBcbiAgICAvLyBhbmQgYHNldERhdGFgIGhlcmUsIHdoaWNoIGZvcmJpZHMgY2FsbGluZyBgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpYCBpbiB0aGlzIHN0YWdlLlxuICAgIC8vIENhbGwgYHNlcmllc01vZGVsLmdldFJhd0RhdGEoKWAgaW5zdGVhZC5cbiAgICAvLyB0aGlzLnJlc3RvcmVEYXRhKCk7XG5cbiAgICBhdXRvU2VyaWVzTmFtZSh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogVXRpbCBmb3IgbWVyZ2UgZGVmYXVsdCBhbmQgdGhlbWUgdG8gb3B0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKi9cbiAgbWVyZ2VEZWZhdWx0QW5kVGhlbWU6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcbiAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGUgPyBnZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9OyAvLyBCYWNrd2FyZCBjb21wYXQ6IHVzaW5nIHN1YlR5cGUgb24gdGhlbWUuXG4gICAgLy8gQnV0IGlmIG5hbWUgZHVwbGljYXRlIGJldHdlZW4gc2VyaWVzIHN1YlR5cGVcbiAgICAvLyAoZm9yIGV4YW1wbGU6IHBhcmFsbGVsKSBhZGQgY29tcG9uZW50IG1haW5UeXBlLFxuICAgIC8vIGFkZCBzdWZmaXggJ1NlcmllcycuXG5cbiAgICB2YXIgdGhlbWVTdWJUeXBlID0gdGhpcy5zdWJUeXBlO1xuXG4gICAgaWYgKENvbXBvbmVudE1vZGVsLmhhc0NsYXNzKHRoZW1lU3ViVHlwZSkpIHtcbiAgICAgIHRoZW1lU3ViVHlwZSArPSAnU2VyaWVzJztcbiAgICB9XG5cbiAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCBlY01vZGVsLmdldFRoZW1lKCkuZ2V0KHRoaXMuc3ViVHlwZSkpO1xuICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTsgLy8gRGVmYXVsdCBsYWJlbCBlbXBoYXNpcyBgc2hvd2BcblxuICAgIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMob3B0aW9uLCAnbGFiZWwnLCBbJ3Nob3cnXSk7XG4gICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShvcHRpb24uZGF0YSk7XG5cbiAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgbWVyZ2VMYXlvdXRQYXJhbShvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMsIGxheW91dE1vZGUpO1xuICAgIH1cbiAgfSxcbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdTZXJpZXNPcHRpb24sIGVjTW9kZWwpIHtcbiAgICAvLyB0aGlzLnNldHRpbmdUYXNrLmRpcnR5KCk7XG4gICAgbmV3U2VyaWVzT3B0aW9uID0genJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBuZXdTZXJpZXNPcHRpb24sIHRydWUpO1xuICAgIHRoaXMuZmlsbERhdGFUZXh0U3R5bGUobmV3U2VyaWVzT3B0aW9uLmRhdGEpO1xuICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuXG4gICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgIG1lcmdlTGF5b3V0UGFyYW0odGhpcy5vcHRpb24sIG5ld1Nlcmllc09wdGlvbiwgbGF5b3V0TW9kZSk7XG4gICAgfVxuXG4gICAgcHJlcGFyZVNvdXJjZSh0aGlzKTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0SW5pdGlhbERhdGEobmV3U2VyaWVzT3B0aW9uLCBlY01vZGVsKTtcbiAgICB3cmFwRGF0YShkYXRhLCB0aGlzKTtcbiAgICB0aGlzLmRhdGFUYXNrLmRpcnR5KCk7XG4gICAgdGhpcy5kYXRhVGFzay5jb250ZXh0LmRhdGEgPSBkYXRhO1xuICAgIGlubmVyKHRoaXMpLmRhdGFCZWZvcmVQcm9jZXNzZWQgPSBkYXRhO1xuICAgIGF1dG9TZXJpZXNOYW1lKHRoaXMpO1xuICB9LFxuICBmaWxsRGF0YVRleHRTdHlsZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyBEZWZhdWx0IGRhdGEgbGFiZWwgZW1waGFzaXMgYHNob3dgXG4gICAgLy8gRklYTUUgVHJlZSBzdHJ1Y3R1cmUgZGF0YSA/XG4gICAgLy8gRklYTUUgUGVyZm9ybWFuY2UgP1xuICAgIGlmIChkYXRhICYmICF6clV0aWwuaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICB2YXIgcHJvcHMgPSBbJ3Nob3cnXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2ldICYmIGRhdGFbaV0ubGFiZWwpIHtcbiAgICAgICAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzKGRhdGFbaV0sICdsYWJlbCcsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdCBhIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSByZWxhdGVkIG9wdGlvbiBpbiBzZXJpZXNcbiAgICogTXVzdCBiZSBvdmVyd3JpdHRlblxuICAgKi9cbiAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiBBcHBlbmQgZGF0YSB0byBsaXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBwYXJhbXMuZGF0YVxuICAgKi9cbiAgYXBwZW5kRGF0YTogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIC8vIEZJWE1FID8/P1xuICAgIC8vICgxKSBJZiBkYXRhIGZyb20gZGF0YXNldCwgZm9yYmlkZGVuIGFwcGVuZC5cbiAgICAvLyAoMikgc3VwcG9ydCBhcHBlbmQgZGF0YSBvZiBkYXRhc2V0LlxuICAgIHZhciBkYXRhID0gdGhpcy5nZXRSYXdEYXRhKCk7XG4gICAgZGF0YS5hcHBlbmREYXRhKHBhcmFtcy5kYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29uc2lkZXIgc29tZSBtZXRob2QgbGlrZSBgZmlsdGVyYCwgYG1hcGAgbmVlZCBtYWtlIG5ldyBkYXRhLFxuICAgKiBXZSBzaG91bGQgbWFrZSBzdXJlIHRoYXQgYHNlcmllc01vZGVsLmdldERhdGEoKWAgZ2V0IGNvcnJlY3RcbiAgICogZGF0YSBpbiB0aGUgc3RyZWFtIHByb2NlZHVyZS4gU28gd2UgZmV0Y2ggZGF0YSBmcm9tIHVwc3RyZWFtXG4gICAqIGVhY2ggdGltZSBgdGFzay5wZXJmb3JtYCBjYWxsZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH1cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uIChkYXRhVHlwZSkge1xuICAgIHZhciB0YXNrID0gZ2V0Q3VycmVudFRhc2sodGhpcyk7XG5cbiAgICBpZiAodGFzaykge1xuICAgICAgdmFyIGRhdGEgPSB0YXNrLmNvbnRleHQuZGF0YTtcbiAgICAgIHJldHVybiBkYXRhVHlwZSA9PSBudWxsID8gZGF0YSA6IGRhdGEuZ2V0TGlua2VkRGF0YShkYXRhVHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gc2VyaWVzIGlzIG5vdCBhbGl2ZSAodGhhdCBtYXkgaGFwcGVuIHdoZW4gY2xpY2sgdG9vbGJveFxuICAgICAgLy8gcmVzdG9yZSBvciBzZXRPcHRpb24gd2l0aCBub3QgbWVyZ2UgbW9kZSksIHNlcmllcyBkYXRhIG1heVxuICAgICAgLy8gYmUgc3RpbGwgbmVlZCB0byBqdWRnZSBhbmltYXRpb24gb3Igc29tZXRoaW5nIHdoZW4gZ3JhcGhpY1xuICAgICAgLy8gZWxlbWVudHMgd2FudCB0byBrbm93IHdoZXRoZXIgZmFkZSBvdXQuXG4gICAgICByZXR1cm4gaW5uZXIodGhpcykuZGF0YTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAqL1xuICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0YXNrID0gZ2V0Q3VycmVudFRhc2sodGhpcyk7XG5cbiAgICBpZiAodGFzaykge1xuICAgICAgdmFyIGNvbnRleHQgPSB0YXNrLmNvbnRleHQ7IC8vIENvbnNpZGVyIGNhc2U6IGZpbHRlciwgZGF0YSBzYW1wbGUuXG5cbiAgICAgIGlmIChjb250ZXh0LmRhdGEgIT09IGRhdGEgJiYgdGFzay5tb2RpZnlPdXRwdXRFbmQpIHtcbiAgICAgICAgdGFzay5zZXRPdXRwdXRFbmQoZGF0YS5jb3VudCgpKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5vdXRwdXREYXRhID0gZGF0YTsgLy8gQ2F1dGlvbjogc2V0RGF0YSBzaG91bGQgdXBkYXRlIGNvbnRleHQuZGF0YSxcbiAgICAgIC8vIEJlY2F1c2UgZ2V0RGF0YSBtYXkgYmUgY2FsbGVkIG11bHRpcGx5IGluIGFcbiAgICAgIC8vIHNpbmdsZSBzdGFnZSBhbmQgZXhwZWN0IHRvIGdldCB0aGUgZGF0YSBqdXN0XG4gICAgICAvLyBzZXQuIChGb3IgZXhhbXBsZSwgQXhpc1Byb3h5LCB4IHkgYm90aCBjYWxsXG4gICAgICAvLyBnZXREYXRhIGFuZCBzZXREYXRlIHNlcXVlbnRpYWxseSkuXG4gICAgICAvLyBTbyB0aGUgY29udGV4dC5kYXRhIHNob3VsZCBiZSBmZXRjaGVkIGZyb21cbiAgICAgIC8vIHVwc3RyZWFtIGVhY2ggdGltZSB3aGVuIGEgc3RhZ2Ugc3RhcnRzIHRvIGJlXG4gICAgICAvLyBwZXJmb3JtZWQuXG5cbiAgICAgIGlmICh0YXNrICE9PSB0aGlzLmRhdGFUYXNrKSB7XG4gICAgICAgIGNvbnRleHQuZGF0YSA9IGRhdGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5uZXIodGhpcykuZGF0YSA9IGRhdGE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZWUge21vZHVsZTplY2hhcnRzL2RhdGEvaGVscGVyL3NvdXJjZUhlbHBlciNnZXRTb3VyY2V9XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvU291cmNlfSBzb3VyY2VcbiAgICovXG4gIGdldFNvdXJjZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRTb3VyY2UodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBkYXRhIGJlZm9yZSBwcm9jZXNzZWRcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fVxuICAgKi9cbiAgZ2V0UmF3RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbm5lcih0aGlzKS5kYXRhQmVmb3JlUHJvY2Vzc2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYmFzZSBheGlzIGlmIGhhcyBjb29yZGluYXRlIHN5c3RlbSBhbmQgaGFzIGF4aXMuXG4gICAqIEJ5IGRlZmF1bHQgdXNlIGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAqIENhbiBiZSBvdmVycmlkZWQgZm9yIHNvbWUgY2hhcnQuXG4gICAqIEByZXR1cm4ge3R5cGV9IGRlc2NyaXB0aW9uXG4gICAqL1xuICBnZXRCYXNlQXhpczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICByZXR1cm4gY29vcmRTeXMgJiYgY29vcmRTeXMuZ2V0QmFzZUF4aXMgJiYgY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgfSxcbiAgLy8gRklYTUVcblxuICAvKipcbiAgICogRGVmYXVsdCB0b29sdGlwIGZvcm1hdHRlclxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211bHRpcGxlU2VyaWVzPWZhbHNlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFUeXBlXVxuICAgKi9cbiAgZm9ybWF0VG9vbHRpcDogZnVuY3Rpb24gKGRhdGFJbmRleCwgbXVsdGlwbGVTZXJpZXMsIGRhdGFUeXBlKSB7XG4gICAgZnVuY3Rpb24gZm9ybWF0QXJyYXlWYWx1ZSh2YWx1ZSkge1xuICAgICAgLy8gPz8/IFRPRE8gcmVmYWN0b3IgdGhlc2UgbG9naWMuXG4gICAgICAvLyBjaGVjazogY2F0ZWdvcnktbm8tZW5jb2RlLWhhcy1heGlzLWRhdGEgaW4gZGF0YXNldC5odG1sXG4gICAgICB2YXIgdmVydGlhbGx5ID0genJVdGlsLnJlZHVjZSh2YWx1ZSwgZnVuY3Rpb24gKHZlcnRpYWxseSwgdmFsLCBpZHgpIHtcbiAgICAgICAgdmFyIGRpbUl0ZW0gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oaWR4KTtcbiAgICAgICAgcmV0dXJuIHZlcnRpYWxseSB8PSBkaW1JdGVtICYmIGRpbUl0ZW0udG9vbHRpcCAhPT0gZmFsc2UgJiYgZGltSXRlbS5kaXNwbGF5TmFtZSAhPSBudWxsO1xuICAgICAgfSwgMCk7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB0b29sdGlwRGltcy5sZW5ndGggPyB6clV0aWwuZWFjaCh0b29sdGlwRGltcywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICBzZXRFYWNoSXRlbShyZXRyaWV2ZVJhd1ZhbHVlKGRhdGEsIGRhdGFJbmRleCwgZGltKSwgZGltKTtcbiAgICAgIH0pIC8vIEJ5IGRlZmF1bHQsIGFsbCBkaW1zIGlzIHVzZWQgb24gdG9vbHRpcC5cbiAgICAgIDogenJVdGlsLmVhY2godmFsdWUsIHNldEVhY2hJdGVtKTtcblxuICAgICAgZnVuY3Rpb24gc2V0RWFjaEl0ZW0odmFsLCBkaW0pIHtcbiAgICAgICAgdmFyIGRpbUluZm8gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oZGltKTsgLy8gSWYgYGRpbUluZm8udG9vbHRpcGAgaXMgbm90IHNldCwgc2hvdyB0b29sdGlwLlxuXG4gICAgICAgIGlmICghZGltSW5mbyB8fCBkaW1JbmZvLm90aGVyRGltcy50b29sdGlwID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaW1UeXBlID0gZGltSW5mby50eXBlO1xuICAgICAgICB2YXIgZGltSGVhZCA9IGdldFRvb2x0aXBNYXJrZXIoe1xuICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICB0eXBlOiAnc3ViSXRlbSdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB2YWxTdHIgPSAodmVydGlhbGx5ID8gZGltSGVhZCArIGVuY29kZUhUTUwoZGltSW5mby5kaXNwbGF5TmFtZSB8fCAnLScpICsgJzogJyA6ICcnKSArIC8vIEZJWE1FIHNob3VsZCBub3QgZm9ybWF0IHRpbWUgZm9yIHJhdyBkYXRhP1xuICAgICAgICBlbmNvZGVIVE1MKGRpbVR5cGUgPT09ICdvcmRpbmFsJyA/IHZhbCArICcnIDogZGltVHlwZSA9PT0gJ3RpbWUnID8gbXVsdGlwbGVTZXJpZXMgPyAnJyA6IGZvcm1hdFRpbWUoJ3l5eXkvTU0vZGQgaGg6bW06c3MnLCB2YWwpIDogYWRkQ29tbWFzKHZhbCkpO1xuICAgICAgICB2YWxTdHIgJiYgcmVzdWx0LnB1c2godmFsU3RyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICh2ZXJ0aWFsbHkgPyAnPGJyLz4nIDogJycpICsgcmVzdWx0LmpvaW4odmVydGlhbGx5ID8gJzxici8+JyA6ICcsICcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFNpbmdsZVZhbHVlKHZhbCkge1xuICAgICAgcmV0dXJuIGVuY29kZUhUTUwoYWRkQ29tbWFzKHZhbCkpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgdmFyIHRvb2x0aXBEaW1zID0gZGF0YS5tYXBEaW1lbnNpb24oJ2RlZmF1bHRlZFRvb2x0aXAnLCB0cnVlKTtcbiAgICB2YXIgdG9vbHRpcERpbUxlbiA9IHRvb2x0aXBEaW1zLmxlbmd0aDtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCk7XG4gICAgdmFyIGlzVmFsdWVBcnIgPSB6clV0aWwuaXNBcnJheSh2YWx1ZSk7XG4gICAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ2NvbG9yJyk7XG5cbiAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGNvbG9yKSAmJiBjb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICBjb2xvciA9IChjb2xvci5jb2xvclN0b3BzWzBdIHx8IHt9KS5jb2xvcjtcbiAgICB9XG5cbiAgICBjb2xvciA9IGNvbG9yIHx8ICd0cmFuc3BhcmVudCc7IC8vIENvbXBsaWNhdGVkIHJ1bGUgZm9yIHByZXR0eSB0b29sdGlwLlxuXG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gdG9vbHRpcERpbUxlbiA+IDEgfHwgaXNWYWx1ZUFyciAmJiAhdG9vbHRpcERpbUxlbiA/IGZvcm1hdEFycmF5VmFsdWUodmFsdWUpIDogdG9vbHRpcERpbUxlbiA/IGZvcm1hdFNpbmdsZVZhbHVlKHJldHJpZXZlUmF3VmFsdWUoZGF0YSwgZGF0YUluZGV4LCB0b29sdGlwRGltc1swXSkpIDogZm9ybWF0U2luZ2xlVmFsdWUoaXNWYWx1ZUFyciA/IHZhbHVlWzBdIDogdmFsdWUpO1xuICAgIHZhciBjb2xvckVsID0gZ2V0VG9vbHRpcE1hcmtlcihjb2xvcik7XG4gICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICB2YXIgc2VyaWVzTmFtZSA9IHRoaXMubmFtZTtcblxuICAgIGlmICghbW9kZWxVdGlsLmlzTmFtZVNwZWNpZmllZCh0aGlzKSkge1xuICAgICAgc2VyaWVzTmFtZSA9ICcnO1xuICAgIH1cblxuICAgIHNlcmllc05hbWUgPSBzZXJpZXNOYW1lID8gZW5jb2RlSFRNTChzZXJpZXNOYW1lKSArICghbXVsdGlwbGVTZXJpZXMgPyAnPGJyLz4nIDogJzogJykgOiAnJztcbiAgICByZXR1cm4gIW11bHRpcGxlU2VyaWVzID8gc2VyaWVzTmFtZSArIGNvbG9yRWwgKyAobmFtZSA/IGVuY29kZUhUTUwobmFtZSkgKyAnOiAnICsgZm9ybWF0dGVkVmFsdWUgOiBmb3JtYXR0ZWRWYWx1ZSkgOiBjb2xvckVsICsgc2VyaWVzTmFtZSArIGZvcm1hdHRlZFZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBbmltYXRpb25FbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdGlvbkVuYWJsZWQgPSB0aGlzLmdldFNoYWxsb3coJ2FuaW1hdGlvbicpO1xuXG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgIGlmICh0aGlzLmdldERhdGEoKS5jb3VudCgpID4gdGhpcy5nZXRTaGFsbG93KCdhbmltYXRpb25UaHJlc2hvbGQnKSkge1xuICAgICAgICBhbmltYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbkVuYWJsZWQ7XG4gIH0sXG4gIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kYXRhVGFzay5kaXJ0eSgpO1xuICB9LFxuICBnZXRDb2xvckZyb21QYWxldHRlOiBmdW5jdGlvbiAobmFtZSwgc2NvcGUsIHJlcXVlc3RDb2xvck51bSkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsOyAvLyBQRU5ESU5HXG5cbiAgICB2YXIgY29sb3IgPSBjb2xvclBhbGV0dGVNaXhpbi5nZXRDb2xvckZyb21QYWxldHRlLmNhbGwodGhpcywgbmFtZSwgc2NvcGUsIHJlcXVlc3RDb2xvck51bSk7XG5cbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICBjb2xvciA9IGVjTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShuYW1lLCBzY29wZSwgcmVxdWVzdENvbG9yTnVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZSBgZGF0YS5tYXBEaW1lbnNpb24oY29vcmREaW0sIHRydWUpYCBpbnN0ZWFkLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgY29vcmREaW1Ub0RhdGFEaW06IGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgIHJldHVybiB0aGlzLmdldFJhd0RhdGEoKS5tYXBEaW1lbnNpb24oY29vcmREaW0sIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGNvdW50IGVhY2ggc3RlcFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRQcm9ncmVzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgncHJvZ3Jlc3NpdmUnKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHByb2dyZXNzaXZlIHJlbmRlcmluZyBjb3VudCBlYWNoIHN0ZXBcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UHJvZ3Jlc3NpdmVUaHJlc2hvbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3Byb2dyZXNzaXZlVGhyZXNob2xkJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBkYXRhIGluZGljZXMgZm9yIHNob3cgdG9vbHRpcCBjb250ZW50LiBTZWUgdG9vbHRpcC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBkaW1cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9zaW5nbGUvU2luZ2xlQXhpc30gYmFzZUF4aXNcbiAgICogQHJldHVybiB7T2JqZWN0fSB7ZGF0YUluZGljZXMsIG5lc3Rlc3RWYWx1ZX0uXG4gICAqL1xuICBnZXRBeGlzVG9vbHRpcERhdGE6IG51bGwsXG5cbiAgLyoqXG4gICAqIFNlZSB0b29sdGlwLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gUG9pbnQgb2YgdG9vbHRpcC4gbnVsbC91bmRlZmluZWQgY2FuIGJlIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0VG9vbHRpcFBvc2l0aW9uOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9zdHJlYW0vU2NoZWR1bGVyfVxuICAgKi9cbiAgcGlwZVRhc2s6IG51bGwsXG5cbiAgLyoqXG4gICAqIENvbnZpbmllbnQgZm9yIG92ZXJyaWRlIGluIGV4dGVuZGVkIGNsYXNzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHByZXZlbnRJbmNyZW1lbnRhbDogbnVsbCxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcmVhZE9ubHlcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHBpcGVsaW5lQ29udGV4dDogbnVsbFxufSk7XG56clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIGRhdGFGb3JtYXRNaXhpbik7XG56clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIGNvbG9yUGFsZXR0ZU1peGluKTtcbi8qKlxuICogTVVTVCBiZSBjYWxsZWQgYWZ0ZXIgYHByZXBhcmVTb3VyY2VgIGNhbGxlZFxuICogSGVyZSB3ZSBuZWVkIHRvIG1ha2UgYXV0byBzZXJpZXMsIGVzcGVjaWFsbHkgZm9yIGF1dG8gbGVnZW5kLiBCdXQgd2VcbiAqIGRvIG5vdCBtb2RpZnkgc2VyaWVzLm5hbWUgaW4gb3B0aW9uIHRvIGF2b2lkIHNpZGUgZWZmZWN0cy5cbiAqL1xuXG5mdW5jdGlvbiBhdXRvU2VyaWVzTmFtZShzZXJpZXNNb2RlbCkge1xuICAvLyBVc2VyIHNwZWNpZmllZCBuYW1lIGhhcyBoaWdoZXIgcHJpb3JpdHksIG90aGVyd2lzZSBpdCBtYXkgY2F1c2VcbiAgLy8gc2VyaWVzIGNhbiBub3QgYmUgcXVlcmllZCB1bmV4cGVjdGVkbHkuXG4gIHZhciBuYW1lID0gc2VyaWVzTW9kZWwubmFtZTtcblxuICBpZiAoIW1vZGVsVXRpbC5pc05hbWVTcGVjaWZpZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgc2VyaWVzTW9kZWwubmFtZSA9IGdldFNlcmllc0F1dG9OYW1lKHNlcmllc01vZGVsKSB8fCBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNlcmllc0F1dG9OYW1lKHNlcmllc01vZGVsKSB7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0UmF3RGF0YSgpO1xuICB2YXIgZGF0YURpbXMgPSBkYXRhLm1hcERpbWVuc2lvbignc2VyaWVzTmFtZScsIHRydWUpO1xuICB2YXIgbmFtZUFyciA9IFtdO1xuICB6clV0aWwuZWFjaChkYXRhRGltcywgZnVuY3Rpb24gKGRhdGFEaW0pIHtcbiAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkYXRhRGltKTtcbiAgICBkaW1JbmZvLmRpc3BsYXlOYW1lICYmIG5hbWVBcnIucHVzaChkaW1JbmZvLmRpc3BsYXlOYW1lKTtcbiAgfSk7XG4gIHJldHVybiBuYW1lQXJyLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gZGF0YVRhc2tDb3VudChjb250ZXh0KSB7XG4gIHJldHVybiBjb250ZXh0Lm1vZGVsLmdldFJhd0RhdGEoKS5jb3VudCgpO1xufVxuXG5mdW5jdGlvbiBkYXRhVGFza1Jlc2V0KGNvbnRleHQpIHtcbiAgdmFyIHNlcmllc01vZGVsID0gY29udGV4dC5tb2RlbDtcbiAgc2VyaWVzTW9kZWwuc2V0RGF0YShzZXJpZXNNb2RlbC5nZXRSYXdEYXRhKCkuY2xvbmVTaGFsbG93KCkpO1xuICByZXR1cm4gZGF0YVRhc2tQcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gZGF0YVRhc2tQcm9ncmVzcyhwYXJhbSwgY29udGV4dCkge1xuICAvLyBBdm9pZCByZXBlYWQgY2xvbmVTaGFsbG93IHdoZW4gZGF0YSBqdXN0IGNyZWF0ZWQgaW4gcmVzZXQuXG4gIGlmIChwYXJhbS5lbmQgPiBjb250ZXh0Lm91dHB1dERhdGEuY291bnQoKSkge1xuICAgIGNvbnRleHQubW9kZWwuZ2V0UmF3RGF0YSgpLmNsb25lU2hhbGxvdyhjb250ZXh0Lm91dHB1dERhdGEpO1xuICB9XG59IC8vIFRPRE8gcmVmYWN0b3JcblxuXG5mdW5jdGlvbiB3cmFwRGF0YShkYXRhLCBzZXJpZXNNb2RlbCkge1xuICB6clV0aWwuZWFjaChkYXRhLkNIQU5HQUJMRV9NRVRIT0RTLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIGRhdGEud3JhcE1ldGhvZChtZXRob2ROYW1lLCB6clV0aWwuY3Vycnkob25EYXRhU2VsZkNoYW5nZSwgc2VyaWVzTW9kZWwpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRGF0YVNlbGZDaGFuZ2Uoc2VyaWVzTW9kZWwpIHtcbiAgdmFyIHRhc2sgPSBnZXRDdXJyZW50VGFzayhzZXJpZXNNb2RlbCk7XG5cbiAgaWYgKHRhc2spIHtcbiAgICAvLyBDb25zaWRlciBjYXNlOiBmaWx0ZXIsIHNlbGVjdFJhbmdlXG4gICAgdGFzay5zZXRPdXRwdXRFbmQodGhpcy5jb3VudCgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50VGFzayhzZXJpZXNNb2RlbCkge1xuICB2YXIgc2NoZWR1bGVyID0gKHNlcmllc01vZGVsLmVjTW9kZWwgfHwge30pLnNjaGVkdWxlcjtcbiAgdmFyIHBpcGVsaW5lID0gc2NoZWR1bGVyICYmIHNjaGVkdWxlci5nZXRQaXBlbGluZShzZXJpZXNNb2RlbC51aWQpO1xuXG4gIGlmIChwaXBlbGluZSkge1xuICAgIC8vIFdoZW4gcGlwbGluZSBmaW5pc2hlZCwgdGhlIGN1cnJyZW50VGFzayBrZWVwIHRoZSBsYXN0XG4gICAgLy8gdGFzayAocmVuZGVyVGFzaykuXG4gICAgdmFyIHRhc2sgPSBwaXBlbGluZS5jdXJyZW50VGFzaztcblxuICAgIGlmICh0YXNrKSB7XG4gICAgICB2YXIgYWdlbnRTdHViTWFwID0gdGFzay5hZ2VudFN0dWJNYXA7XG5cbiAgICAgIGlmIChhZ2VudFN0dWJNYXApIHtcbiAgICAgICAgdGFzayA9IGFnZW50U3R1Yk1hcC5nZXQoc2VyaWVzTW9kZWwudWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFzaztcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBTZXJpZXNNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9TZXJpZXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgcGxhdGZvcm0gPSAnJzsgLy8gTmF2aWdhdG9yIG5vdCBleGlzdHMgaW4gbm9kZVxuXG5pZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm0gfHwgJyc7XG59XG5cbnZhciBfZGVmYXVsdCA9IHtcbiAgLy8gYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gIC8vIGh0dHBzOi8vZHJpYmJibGUuY29tL3Nob3RzLzEwNjU5NjAtSW5mb2dyYXBoaWMtUGllLWNoYXJ0LXZpc3VhbGl6YXRpb25cbiAgLy8gY29sb3I6IFsnIzU3OTNmMycsICcjZDE0YTYxJywgJyNmZDljMzUnLCAnIzY3NWJiYScsICcjZmVjNDJjJywgJyNkZDQ0NDQnLCAnI2Q0ZGY1YScsICcjY2Q0ODcwJ10sXG4gIC8vIExpZ2h0IGNvbG9yczpcbiAgLy8gY29sb3I6IFsnI2JjZDNiYicsICcjZTg4ZjcwJywgJyNlZGMxYTUnLCAnIzlkYzVjOCcsICcjZTFlOGM4JywgJyM3YjdjNjgnLCAnI2U1YjViNScsICcjZjBiNDg5JywgJyM5MjhlYTgnLCAnI2JkYTI5YSddLFxuICAvLyBjb2xvcjogWycjY2M1NjY0JywgJyM5YmQ2ZWMnLCAnI2VhOTQ2ZScsICcjOGFjYWFhJywgJyNmMWVjNjQnLCAnI2VlODY4NicsICcjYTQ4ZGMxJywgJyM1ZGE2YmMnLCAnI2I5ZGNhZSddLFxuICAvLyBEYXJrIGNvbG9yczpcbiAgY29sb3I6IFsnI2MyMzUzMScsICcjMmY0NTU0JywgJyM2MWEwYTgnLCAnI2Q0ODI2NScsICcjOTFjN2FlJywgJyM3NDlmODMnLCAnI2NhODYyMicsICcjYmRhMjlhJywgJyM2ZTcwNzQnLCAnIzU0NjU3MCcsICcjYzRjY2QzJ10sXG4gIGdyYWRpZW50Q29sb3I6IFsnI2Y2ZWZhNicsICcjZDg4MjczJywgJyNiZjQ0NGMnXSxcbiAgLy8gSWYgeEF4aXMgYW5kIHlBeGlzIGRlY2xhcmVkLCBncmlkIGlzIGNyZWF0ZWQgYnkgZGVmYXVsdC5cbiAgLy8gZ3JpZDoge30sXG4gIHRleHRTdHlsZToge1xuICAgIC8vIGNvbG9yOiAnIzAwMCcsXG4gICAgLy8gZGVjb3JhdGlvbjogJ25vbmUnLFxuICAgIC8vIFBFTkRJTkdcbiAgICBmb250RmFtaWx5OiBwbGF0Zm9ybS5tYXRjaCgvXldpbi8pID8gJ01pY3Jvc29mdCBZYUhlaScgOiAnc2Fucy1zZXJpZicsXG4gICAgLy8gZm9udEZhbWlseTogJ0FyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJyxcbiAgICBmb250U2l6ZTogMTIsXG4gICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcbiAgICBmb250V2VpZ2h0OiAnbm9ybWFsJ1xuICB9LFxuICAvLyBodHRwOi8vYmxvZ3MuYWRvYmUuY29tL3dlYnBsYXRmb3JtLzIwMTQvMDIvMjQvdXNpbmctYmxlbmQtbW9kZXMtaW4taHRtbC1jYW52YXMvXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gIC8vIERlZmF1bHQgaXMgc291cmNlLW92ZXJcbiAgYmxlbmRNb2RlOiBudWxsLFxuICBhbmltYXRpb246ICdhdXRvJyxcbiAgYW5pbWF0aW9uRHVyYXRpb246IDEwMDAsXG4gIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAzMDAsXG4gIGFuaW1hdGlvbkVhc2luZzogJ2V4cG9uZW50aWFsT3V0JyxcbiAgYW5pbWF0aW9uRWFzaW5nVXBkYXRlOiAnY3ViaWNPdXQnLFxuICBhbmltYXRpb25UaHJlc2hvbGQ6IDIwMDAsXG4gIC8vIENvbmZpZ3VyYXRpb24gZm9yIHByb2dyZXNzaXZlL2luY3JlbWVudGFsIHJlbmRlcmluZ1xuICBwcm9ncmVzc2l2ZVRocmVzaG9sZDogMzAwMCxcbiAgcHJvZ3Jlc3NpdmU6IDQwMCxcbiAgLy8gVGhyZXNob2xkIG9mIGlmIHVzZSBzaW5nbGUgaG92ZXIgbGF5ZXIgdG8gb3B0aW1pemUuXG4gIC8vIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgYGhvdmVyTGF5ZXJUaHJlc2hvbGRgIGlzIGVxdWl2YWxlbnQgdG8gb3IgbGVzcyB0aGFuXG4gIC8vIGBwcm9ncmVzc2l2ZVRocmVzaG9sZGAsIG90aGVyd2lzZSBob3ZlciB3aWxsIGNhdXNlIHJlc3RhcnQgb2YgcHJvZ3Jlc3NpdmUsXG4gIC8vIHdoaWNoIGlzIHVuZXhwZWN0ZWQuXG4gIC8vIHNlZSBleGFtcGxlIDxlY2hhcnRzL3Rlc3QvaGVhdG1hcC1sYXJnZS5odG1sPi5cbiAgaG92ZXJMYXllclRocmVzaG9sZDogMzAwMCxcbiAgLy8gU2VlOiBtb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lXG4gIHVzZVVUQzogZmFsc2Vcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL2dsb2JhbERlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL2dsb2JhbERlZmF1bHQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbWFrZVN0eWxlTWFwcGVyID0gcmVxdWlyZShcIi4vbWFrZVN0eWxlTWFwcGVyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgZ2V0QXJlYVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2ZpbGwnLCAnY29sb3InXSwgWydzaGFkb3dCbHVyJ10sIFsnc2hhZG93T2Zmc2V0WCddLCBbJ3NoYWRvd09mZnNldFknXSwgWydvcGFjaXR5J10sIFsnc2hhZG93Q29sb3InXV0pO1xudmFyIF9kZWZhdWx0ID0ge1xuICBnZXRBcmVhU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcywgaW5jbHVkZXMpIHtcbiAgICByZXR1cm4gZ2V0QXJlYVN0eWxlKHRoaXMsIGV4Y2x1ZGVzLCBpbmNsdWRlcyk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2FyZWFTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vYXJlYVN0eWxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9kZWZhdWx0ID0ge1xuICBnZXRCb3hMYXlvdXRQYXJhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5nZXQoJ2xlZnQnKSxcbiAgICAgIHRvcDogdGhpcy5nZXQoJ3RvcCcpLFxuICAgICAgcmlnaHQ6IHRoaXMuZ2V0KCdyaWdodCcpLFxuICAgICAgYm90dG9tOiB0aGlzLmdldCgnYm90dG9tJyksXG4gICAgICB3aWR0aDogdGhpcy5nZXQoJ3dpZHRoJyksXG4gICAgICBoZWlnaHQ6IHRoaXMuZ2V0KCdoZWlnaHQnKVxuICAgIH07XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2JveExheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vYm94TGF5b3V0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9tb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG52YXIgbWFrZUlubmVyID0gX21vZGVsLm1ha2VJbm5lcjtcbnZhciBub3JtYWxpemVUb0FycmF5ID0gX21vZGVsLm5vcm1hbGl6ZVRvQXJyYXk7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xuXG5mdW5jdGlvbiBnZXROZWFyZXN0Q29sb3JQYWxldHRlKGNvbG9ycywgcmVxdWVzdENvbG9yTnVtKSB7XG4gIHZhciBwYWxldHRlTnVtID0gY29sb3JzLmxlbmd0aDsgLy8gVE9ETyBjb2xvcnMgbXVzdCBiZSBpbiBvcmRlclxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFsZXR0ZU51bTsgaSsrKSB7XG4gICAgaWYgKGNvbG9yc1tpXS5sZW5ndGggPiByZXF1ZXN0Q29sb3JOdW0pIHtcbiAgICAgIHJldHVybiBjb2xvcnNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbG9yc1twYWxldHRlTnVtIC0gMV07XG59XG5cbnZhciBfZGVmYXVsdCA9IHtcbiAgY2xlYXJDb2xvclBhbGV0dGU6IGZ1bmN0aW9uICgpIHtcbiAgICBpbm5lcih0aGlzKS5jb2xvcklkeCA9IDA7XG4gICAgaW5uZXIodGhpcykuY29sb3JOYW1lTWFwID0ge307XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1VU1QgTk9UIGJlIG51bGwvdW5kZWZpbmVkLiBPdGhlcndpc2UgY2FsbCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgICAgICAgICAgICAgICB0d2lzZSB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgd2lsbCBnZXQgZGlmZmVyZW50IHJlc3VsdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZT10aGlzXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RDb2xvck51bV1cbiAgICogQHJldHVybiB7c3RyaW5nfSBjb2xvciBzdHJpbmcuXG4gICAqL1xuICBnZXRDb2xvckZyb21QYWxldHRlOiBmdW5jdGlvbiAobmFtZSwgc2NvcGUsIHJlcXVlc3RDb2xvck51bSkge1xuICAgIHNjb3BlID0gc2NvcGUgfHwgdGhpcztcbiAgICB2YXIgc2NvcGVGaWVsZHMgPSBpbm5lcihzY29wZSk7XG4gICAgdmFyIGNvbG9ySWR4ID0gc2NvcGVGaWVsZHMuY29sb3JJZHggfHwgMDtcbiAgICB2YXIgY29sb3JOYW1lTWFwID0gc2NvcGVGaWVsZHMuY29sb3JOYW1lTWFwID0gc2NvcGVGaWVsZHMuY29sb3JOYW1lTWFwIHx8IHt9OyAvLyBVc2UgYGhhc093blByb3BlcnR5YCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG5cbiAgICBpZiAoY29sb3JOYW1lTWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gY29sb3JOYW1lTWFwW25hbWVdO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q29sb3JQYWxldHRlID0gbm9ybWFsaXplVG9BcnJheSh0aGlzLmdldCgnY29sb3InLCB0cnVlKSk7XG4gICAgdmFyIGxheWVyZWRDb2xvclBhbGV0dGUgPSB0aGlzLmdldCgnY29sb3JMYXllcicsIHRydWUpO1xuICAgIHZhciBjb2xvclBhbGV0dGUgPSByZXF1ZXN0Q29sb3JOdW0gPT0gbnVsbCB8fCAhbGF5ZXJlZENvbG9yUGFsZXR0ZSA/IGRlZmF1bHRDb2xvclBhbGV0dGUgOiBnZXROZWFyZXN0Q29sb3JQYWxldHRlKGxheWVyZWRDb2xvclBhbGV0dGUsIHJlcXVlc3RDb2xvck51bSk7IC8vIEluIGNhc2UgY2FuJ3QgZmluZCBpbiBsYXllcmVkIGNvbG9yIHBhbGV0dGUuXG5cbiAgICBjb2xvclBhbGV0dGUgPSBjb2xvclBhbGV0dGUgfHwgZGVmYXVsdENvbG9yUGFsZXR0ZTtcblxuICAgIGlmICghY29sb3JQYWxldHRlIHx8ICFjb2xvclBhbGV0dGUubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gY29sb3JQYWxldHRlW2NvbG9ySWR4XTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBjb2xvck5hbWVNYXBbbmFtZV0gPSBjb2xvcjtcbiAgICB9XG5cbiAgICBzY29wZUZpZWxkcy5jb2xvcklkeCA9IChjb2xvcklkeCArIDEpICUgY29sb3JQYWxldHRlLmxlbmd0aDtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2NvbG9yUGFsZXR0ZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vY29sb3JQYWxldHRlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9kYXRhUHJvdmlkZXIgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9oZWxwZXIvZGF0YVByb3ZpZGVyXCIpO1xuXG52YXIgcmV0cmlldmVSYXdWYWx1ZSA9IF9kYXRhUHJvdmlkZXIucmV0cmlldmVSYXdWYWx1ZTtcblxudmFyIF9mb3JtYXQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBnZXRUb29sdGlwTWFya2VyID0gX2Zvcm1hdC5nZXRUb29sdGlwTWFya2VyO1xudmFyIGZvcm1hdFRwbCA9IF9mb3JtYXQuZm9ybWF0VHBsO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgRElNRU5TSU9OX0xBQkVMX1JFRyA9IC9cXHtAKC4rPylcXH0vZzsgLy8gUEVORElORyBBIGxpdHRsZSB1Z2x5XG5cbnZhciBfZGVmYXVsdCA9IHtcbiAgLyoqXG4gICAqIEdldCBwYXJhbXMgZm9yIGZvcm1hdHRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldERhdGFQYXJhbXM6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGFUeXBlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgIHZhciByYXdWYWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgdmFyIHJhd0RhdGFJbmRleCA9IGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KTtcbiAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgpO1xuICAgIHZhciBpdGVtT3B0ID0gZGF0YS5nZXRSYXdEYXRhSXRlbShkYXRhSW5kZXgpO1xuICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdjb2xvcicpO1xuICAgIHJldHVybiB7XG4gICAgICBjb21wb25lbnRUeXBlOiB0aGlzLm1haW5UeXBlLFxuICAgICAgY29tcG9uZW50U3ViVHlwZTogdGhpcy5zdWJUeXBlLFxuICAgICAgc2VyaWVzVHlwZTogdGhpcy5tYWluVHlwZSA9PT0gJ3NlcmllcycgPyB0aGlzLnN1YlR5cGUgOiBudWxsLFxuICAgICAgc2VyaWVzSW5kZXg6IHRoaXMuc2VyaWVzSW5kZXgsXG4gICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgIHNlcmllc05hbWU6IHRoaXMubmFtZSxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkYXRhSW5kZXg6IHJhd0RhdGFJbmRleCxcbiAgICAgIGRhdGE6IGl0ZW1PcHQsXG4gICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXG4gICAgICB2YWx1ZTogcmF3VmFsdWUsXG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICBtYXJrZXI6IGdldFRvb2x0aXBNYXJrZXIoY29sb3IpLFxuICAgICAgLy8gUGFyYW0gbmFtZSBsaXN0IGZvciBtYXBwaW5nIGBhYCwgYGJgLCBgY2AsIGBkYCwgYGVgXG4gICAgICAkdmFyczogWydzZXJpZXNOYW1lJywgJ25hbWUnLCAndmFsdWUnXVxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcm1hdCBsYWJlbFxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RhdHVzPSdub3JtYWwnXSAnbm9ybWFsJyBvciAnZW1waGFzaXMnXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGltSW5kZXhdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxQcm9wPSdsYWJlbCddXG4gICAqIEByZXR1cm4ge3N0cmluZ30gSWYgbm90IGZvcm1hdHRlciwgcmV0dXJuIG51bGwvdW5kZWZpbmVkXG4gICAqL1xuICBnZXRGb3JtYXR0ZWRMYWJlbDogZnVuY3Rpb24gKGRhdGFJbmRleCwgc3RhdHVzLCBkYXRhVHlwZSwgZGltSW5kZXgsIGxhYmVsUHJvcCkge1xuICAgIHN0YXR1cyA9IHN0YXR1cyB8fCAnbm9ybWFsJztcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgsIGRhdGFUeXBlKTtcblxuICAgIGlmIChkaW1JbmRleCAhPSBudWxsICYmIHBhcmFtcy52YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBwYXJhbXMudmFsdWUgPSBwYXJhbXMudmFsdWVbZGltSW5kZXhdO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0ZXIgPSBpdGVtTW9kZWwuZ2V0KHN0YXR1cyA9PT0gJ25vcm1hbCcgPyBbbGFiZWxQcm9wIHx8ICdsYWJlbCcsICdmb3JtYXR0ZXInXSA6IFtzdGF0dXMsIGxhYmVsUHJvcCB8fCAnbGFiZWwnLCAnZm9ybWF0dGVyJ10pO1xuXG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcmFtcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyKHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHN0ciA9IGZvcm1hdFRwbChmb3JtYXR0ZXIsIHBhcmFtcyk7IC8vIFN1cHBvcnQgJ2FhYXtAWzNdfWJiYntAcHJvZHVjdH1jY2MnLlxuICAgICAgLy8gRG8gbm90IHN1cHBvcnQgJ30nIGluIGRpbSBuYW1lIHV0aWwgaGF2ZSB0by5cblxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKERJTUVOU0lPTl9MQUJFTF9SRUcsIGZ1bmN0aW9uIChvcmlnaW4sIGRpbSkge1xuICAgICAgICB2YXIgbGVuID0gZGltLmxlbmd0aDtcblxuICAgICAgICBpZiAoZGltLmNoYXJBdCgwKSA9PT0gJ1snICYmIGRpbS5jaGFyQXQobGVuIC0gMSkgPT09ICddJykge1xuICAgICAgICAgIGRpbSA9ICtkaW0uc2xpY2UoMSwgbGVuIC0gMSk7IC8vIEFsc286ICdbXScgPT4gMFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHJpZXZlUmF3VmFsdWUoZGF0YSwgZGF0YUluZGV4LCBkaW0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcmF3IHZhbHVlIGluIG9wdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAqIEByZXR1cm4ge0FycmF5fG51bWJlcnxzdHJpbmd9XG4gICAqL1xuICBnZXRSYXdWYWx1ZTogZnVuY3Rpb24gKGlkeCwgZGF0YVR5cGUpIHtcbiAgICByZXR1cm4gcmV0cmlldmVSYXdWYWx1ZSh0aGlzLmdldERhdGEoZGF0YVR5cGUpLCBpZHgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaG91bGQgYmUgaW1wbGVtZW50ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlwbGVTZXJpZXM9ZmFsc2VdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YVR5cGVdXG4gICAqIEByZXR1cm4ge3N0cmluZ30gdG9vbHRpcCBzdHJpbmdcbiAgICovXG4gIGZvcm1hdFRvb2x0aXA6IGZ1bmN0aW9uICgpIHsvLyBFbXB0eSBmdW5jdGlvblxuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9kYXRhRm9ybWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9kYXRhRm9ybWF0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG1ha2VTdHlsZU1hcHBlciA9IHJlcXVpcmUoXCIuL21ha2VTdHlsZU1hcHBlclwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGdldEl0ZW1TdHlsZSA9IG1ha2VTdHlsZU1hcHBlcihbWydmaWxsJywgJ2NvbG9yJ10sIFsnc3Ryb2tlJywgJ2JvcmRlckNvbG9yJ10sIFsnbGluZVdpZHRoJywgJ2JvcmRlcldpZHRoJ10sIFsnb3BhY2l0eSddLCBbJ3NoYWRvd0JsdXInXSwgWydzaGFkb3dPZmZzZXRYJ10sIFsnc2hhZG93T2Zmc2V0WSddLCBbJ3NoYWRvd0NvbG9yJ10sIFsndGV4dFBvc2l0aW9uJ10sIFsndGV4dEFsaWduJ11dKTtcbnZhciBfZGVmYXVsdCA9IHtcbiAgZ2V0SXRlbVN0eWxlOiBmdW5jdGlvbiAoZXhjbHVkZXMsIGluY2x1ZGVzKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0SXRlbVN0eWxlKHRoaXMsIGV4Y2x1ZGVzLCBpbmNsdWRlcyk7XG4gICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRCb3JkZXJMaW5lRGFzaCgpO1xuICAgIGxpbmVEYXNoICYmIChzdHlsZS5saW5lRGFzaCA9IGxpbmVEYXNoKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG4gIGdldEJvcmRlckxpbmVEYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpbmVUeXBlID0gdGhpcy5nZXQoJ2JvcmRlclR5cGUnKTtcbiAgICByZXR1cm4gbGluZVR5cGUgPT09ICdzb2xpZCcgfHwgbGluZVR5cGUgPT0gbnVsbCA/IG51bGwgOiBsaW5lVHlwZSA9PT0gJ2Rhc2hlZCcgPyBbNSwgNV0gOiBbMSwgMV07XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2l0ZW1TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vaXRlbVN0eWxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG1ha2VTdHlsZU1hcHBlciA9IHJlcXVpcmUoXCIuL21ha2VTdHlsZU1hcHBlclwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGdldExpbmVTdHlsZSA9IG1ha2VTdHlsZU1hcHBlcihbWydsaW5lV2lkdGgnLCAnd2lkdGgnXSwgWydzdHJva2UnLCAnY29sb3InXSwgWydvcGFjaXR5J10sIFsnc2hhZG93Qmx1ciddLCBbJ3NoYWRvd09mZnNldFgnXSwgWydzaGFkb3dPZmZzZXRZJ10sIFsnc2hhZG93Q29sb3InXV0pO1xudmFyIF9kZWZhdWx0ID0ge1xuICBnZXRMaW5lU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcykge1xuICAgIHZhciBzdHlsZSA9IGdldExpbmVTdHlsZSh0aGlzLCBleGNsdWRlcyk7XG4gICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRMaW5lRGFzaChzdHlsZS5saW5lV2lkdGgpO1xuICAgIGxpbmVEYXNoICYmIChzdHlsZS5saW5lRGFzaCA9IGxpbmVEYXNoKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG4gIGdldExpbmVEYXNoOiBmdW5jdGlvbiAobGluZVdpZHRoKSB7XG4gICAgaWYgKGxpbmVXaWR0aCA9PSBudWxsKSB7XG4gICAgICBsaW5lV2lkdGggPSAxO1xuICAgIH1cblxuICAgIHZhciBsaW5lVHlwZSA9IHRoaXMuZ2V0KCd0eXBlJyk7XG4gICAgdmFyIGRvdFNpemUgPSBNYXRoLm1heChsaW5lV2lkdGgsIDIpO1xuICAgIHZhciBkYXNoU2l6ZSA9IGxpbmVXaWR0aCAqIDQ7XG4gICAgcmV0dXJuIGxpbmVUeXBlID09PSAnc29saWQnIHx8IGxpbmVUeXBlID09IG51bGwgPyBudWxsIDogbGluZVR5cGUgPT09ICdkYXNoZWQnID8gW2Rhc2hTaXplLCBkYXNoU2l6ZV0gOiBbZG90U2l6ZSwgZG90U2l6ZV07XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2xpbmVTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vbGluZVN0eWxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIFRPRE8gUGFyc2Ugc2hhZG93IHN0eWxlXG4vLyBUT0RPIE9ubHkgc2hhbGxvdyBwYXRoIHN1cHBvcnRcbmZ1bmN0aW9uIF9kZWZhdWx0KHByb3BlcnRpZXMpIHtcbiAgLy8gTm9ybWFsaXplXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghcHJvcGVydGllc1tpXVsxXSkge1xuICAgICAgcHJvcGVydGllc1tpXVsxXSA9IHByb3BlcnRpZXNbaV1bMF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChtb2RlbCwgZXhjbHVkZXMsIGluY2x1ZGVzKSB7XG4gICAgdmFyIHN0eWxlID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnRpZXNbaV1bMV07XG5cbiAgICAgIGlmIChleGNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihleGNsdWRlcywgcHJvcE5hbWUpID49IDAgfHwgaW5jbHVkZXMgJiYgenJVdGlsLmluZGV4T2YoaW5jbHVkZXMsIHByb3BOYW1lKSA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWwgPSBtb2RlbC5nZXRTaGFsbG93KHByb3BOYW1lKTtcblxuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnRpZXNbaV1bMF1dID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9tYWtlU3R5bGVNYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluL3RleHRcIik7XG5cbnZhciBncmFwaGljVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBQQVRIX0NPTE9SID0gWyd0ZXh0U3R5bGUnLCAnY29sb3InXTtcbnZhciBfZGVmYXVsdCA9IHtcbiAgLyoqXG4gICAqIEdldCBjb2xvciBwcm9wZXJ0eSBvciBnZXQgY29sb3IgZnJvbSBvcHRpb24udGV4dFN0eWxlLmNvbG9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRW1waGFzaXNdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRleHRDb2xvcjogZnVuY3Rpb24gKGlzRW1waGFzaXMpIHtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICByZXR1cm4gdGhpcy5nZXRTaGFsbG93KCdjb2xvcicpIHx8ICghaXNFbXBoYXNpcyAmJiBlY01vZGVsID8gZWNNb2RlbC5nZXQoUEFUSF9DT0xPUikgOiBudWxsKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGZvbnQgc3RyaW5nIGZyb20gZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRGb250OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdyYXBoaWNVdGlsLmdldEZvbnQoe1xuICAgICAgZm9udFN0eWxlOiB0aGlzLmdldFNoYWxsb3coJ2ZvbnRTdHlsZScpLFxuICAgICAgZm9udFdlaWdodDogdGhpcy5nZXRTaGFsbG93KCdmb250V2VpZ2h0JyksXG4gICAgICBmb250U2l6ZTogdGhpcy5nZXRTaGFsbG93KCdmb250U2l6ZScpLFxuICAgICAgZm9udEZhbWlseTogdGhpcy5nZXRTaGFsbG93KCdmb250RmFtaWx5JylcbiAgICB9LCB0aGlzLmVjTW9kZWwpO1xuICB9LFxuICBnZXRUZXh0UmVjdDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIHRoaXMuZ2V0Rm9udCgpLCB0aGlzLmdldFNoYWxsb3coJ2FsaWduJyksIHRoaXMuZ2V0U2hhbGxvdygndmVydGljYWxBbGlnbicpIHx8IHRoaXMuZ2V0U2hhbGxvdygnYmFzZWxpbmUnKSwgdGhpcy5nZXRTaGFsbG93KCdwYWRkaW5nJyksIHRoaXMuZ2V0U2hhbGxvdygncmljaCcpLCB0aGlzLmdldFNoYWxsb3coJ3RydW5jYXRlVGV4dCcpKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vdGV4dFN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi90ZXh0U3R5bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgY3JlYXRlSGFzaE1hcCA9IF91dGlsLmNyZWF0ZUhhc2hNYXA7XG52YXIgcmV0cmlldmUgPSBfdXRpbC5yZXRyaWV2ZTtcbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEhlbHBlciBmb3IgbW9kZWwgcmVmZXJlbmNlcy5cbiAqIFRoZXJlIGFyZSBtYW55IG1hbm5lcnMgdG8gcmVmZXIgYXhpcy9jb29yZFN5cy5cbiAqL1xuLy8gVE9ET1xuLy8gbWVyZ2UgcmVsZXZhbnQgbG9naWMgdG8gdGhpcyBmaWxlP1xuLy8gY2hlY2s6IFwibW9kZWxIZWxwZXJcIiBvZiB0b29sdGlwIGFuZCBcIkJydXNoVGFyZ2V0TWFuYWdlclwiLlxuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdH0gRm9yIGV4YW1wbGU6XG4gKiB7XG4gKiAgICAgY29vcmRTeXNOYW1lOiAnY2FydGVzaWFuMmQnLFxuICogICAgIGNvb3JkU3lzRGltczogWyd4JywgJ3knLCAuLi5dLFxuICogICAgIGF4aXNNYXA6IEhhc2hNYXAoe1xuICogICAgICAgICB4OiB4QXhpc01vZGVsLFxuICogICAgICAgICB5OiB5QXhpc01vZGVsXG4gKiAgICAgfSksXG4gKiAgICAgY2F0ZWdvcnlBeGlzTWFwOiBIYXNoTWFwKHtcbiAqICAgICAgICAgeDogeEF4aXNNb2RlbCxcbiAqICAgICAgICAgeTogdW5kZWZpbmVkXG4gKiAgICAgfSksXG4gKiAgICAgLy8gSXQgYWxzbyBpbmRpY2F0ZSB0aGF0IHdoZXRoZXIgdGhlcmUgaXMgY2F0ZWdvcnkgYXhpcy5cbiAqICAgICBmaXJzdENhdGVnb3J5RGltSW5kZXg6IDEsXG4gKiAgICAgLy8gVG8gcmVwbGFjZSB1c2VyIHNwZWNpZmllZCBlbmNvZGUuXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGdldENvb3JkU3lzRGVmaW5lQnlTZXJpZXMoc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGNvb3JkU3lzTmFtZSA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIGNvb3JkU3lzTmFtZTogY29vcmRTeXNOYW1lLFxuICAgIGNvb3JkU3lzRGltczogW10sXG4gICAgYXhpc01hcDogY3JlYXRlSGFzaE1hcCgpLFxuICAgIGNhdGVnb3J5QXhpc01hcDogY3JlYXRlSGFzaE1hcCgpXG4gIH07XG4gIHZhciBmZXRjaCA9IGZldGNoZXJzW2Nvb3JkU3lzTmFtZV07XG5cbiAgaWYgKGZldGNoKSB7XG4gICAgZmV0Y2goc2VyaWVzTW9kZWwsIHJlc3VsdCwgcmVzdWx0LmF4aXNNYXAsIHJlc3VsdC5jYXRlZ29yeUF4aXNNYXApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxudmFyIGZldGNoZXJzID0ge1xuICBjYXJ0ZXNpYW4yZDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCByZXN1bHQsIGF4aXNNYXAsIGNhdGVnb3J5QXhpc01hcCkge1xuICAgIHZhciB4QXhpc01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cygneEF4aXMnKVswXTtcbiAgICB2YXIgeUF4aXNNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3lBeGlzJylbMF07XG4gICAgcmVzdWx0LmNvb3JkU3lzRGltcyA9IFsneCcsICd5J107XG4gICAgYXhpc01hcC5zZXQoJ3gnLCB4QXhpc01vZGVsKTtcbiAgICBheGlzTWFwLnNldCgneScsIHlBeGlzTW9kZWwpO1xuXG4gICAgaWYgKGlzQ2F0ZWdvcnkoeEF4aXNNb2RlbCkpIHtcbiAgICAgIGNhdGVnb3J5QXhpc01hcC5zZXQoJ3gnLCB4QXhpc01vZGVsKTtcbiAgICAgIHJlc3VsdC5maXJzdENhdGVnb3J5RGltSW5kZXggPSAwO1xuICAgIH1cblxuICAgIGlmIChpc0NhdGVnb3J5KHlBeGlzTW9kZWwpKSB7XG4gICAgICBjYXRlZ29yeUF4aXNNYXAuc2V0KCd5JywgeUF4aXNNb2RlbCk7XG4gICAgICByZXN1bHQuZmlyc3RDYXRlZ29yeURpbUluZGV4ID0gMTtcbiAgICB9XG4gIH0sXG4gIHNpbmdsZUF4aXM6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgcmVzdWx0LCBheGlzTWFwLCBjYXRlZ29yeUF4aXNNYXApIHtcbiAgICB2YXIgc2luZ2xlQXhpc01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cygnc2luZ2xlQXhpcycpWzBdO1xuICAgIHJlc3VsdC5jb29yZFN5c0RpbXMgPSBbJ3NpbmdsZSddO1xuICAgIGF4aXNNYXAuc2V0KCdzaW5nbGUnLCBzaW5nbGVBeGlzTW9kZWwpO1xuXG4gICAgaWYgKGlzQ2F0ZWdvcnkoc2luZ2xlQXhpc01vZGVsKSkge1xuICAgICAgY2F0ZWdvcnlBeGlzTWFwLnNldCgnc2luZ2xlJywgc2luZ2xlQXhpc01vZGVsKTtcbiAgICAgIHJlc3VsdC5maXJzdENhdGVnb3J5RGltSW5kZXggPSAwO1xuICAgIH1cbiAgfSxcbiAgcG9sYXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgcmVzdWx0LCBheGlzTWFwLCBjYXRlZ29yeUF4aXNNYXApIHtcbiAgICB2YXIgcG9sYXJNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3BvbGFyJylbMF07XG4gICAgdmFyIHJhZGl1c0F4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgncmFkaXVzQXhpcycpO1xuICAgIHZhciBhbmdsZUF4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgnYW5nbGVBeGlzJyk7XG4gICAgcmVzdWx0LmNvb3JkU3lzRGltcyA9IFsncmFkaXVzJywgJ2FuZ2xlJ107XG4gICAgYXhpc01hcC5zZXQoJ3JhZGl1cycsIHJhZGl1c0F4aXNNb2RlbCk7XG4gICAgYXhpc01hcC5zZXQoJ2FuZ2xlJywgYW5nbGVBeGlzTW9kZWwpO1xuXG4gICAgaWYgKGlzQ2F0ZWdvcnkocmFkaXVzQXhpc01vZGVsKSkge1xuICAgICAgY2F0ZWdvcnlBeGlzTWFwLnNldCgncmFkaXVzJywgcmFkaXVzQXhpc01vZGVsKTtcbiAgICAgIHJlc3VsdC5maXJzdENhdGVnb3J5RGltSW5kZXggPSAwO1xuICAgIH1cblxuICAgIGlmIChpc0NhdGVnb3J5KGFuZ2xlQXhpc01vZGVsKSkge1xuICAgICAgY2F0ZWdvcnlBeGlzTWFwLnNldCgnYW5nbGUnLCBhbmdsZUF4aXNNb2RlbCk7XG4gICAgICByZXN1bHQuZmlyc3RDYXRlZ29yeURpbUluZGV4ID0gMTtcbiAgICB9XG4gIH0sXG4gIGdlbzogZnVuY3Rpb24gKHNlcmllc01vZGVsLCByZXN1bHQsIGF4aXNNYXAsIGNhdGVnb3J5QXhpc01hcCkge1xuICAgIHJlc3VsdC5jb29yZFN5c0RpbXMgPSBbJ2xuZycsICdsYXQnXTtcbiAgfSxcbiAgcGFyYWxsZWw6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgcmVzdWx0LCBheGlzTWFwLCBjYXRlZ29yeUF4aXNNYXApIHtcbiAgICB2YXIgZWNNb2RlbCA9IHNlcmllc01vZGVsLmVjTW9kZWw7XG4gICAgdmFyIHBhcmFsbGVsTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgncGFyYWxsZWwnLCBzZXJpZXNNb2RlbC5nZXQoJ3BhcmFsbGVsSW5kZXgnKSk7XG4gICAgdmFyIGNvb3JkU3lzRGltcyA9IHJlc3VsdC5jb29yZFN5c0RpbXMgPSBwYXJhbGxlbE1vZGVsLmRpbWVuc2lvbnMuc2xpY2UoKTtcbiAgICBlYWNoKHBhcmFsbGVsTW9kZWwucGFyYWxsZWxBeGlzSW5kZXgsIGZ1bmN0aW9uIChheGlzSW5kZXgsIGluZGV4KSB7XG4gICAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3BhcmFsbGVsQXhpcycsIGF4aXNJbmRleCk7XG4gICAgICB2YXIgYXhpc0RpbSA9IGNvb3JkU3lzRGltc1tpbmRleF07XG4gICAgICBheGlzTWFwLnNldChheGlzRGltLCBheGlzTW9kZWwpO1xuXG4gICAgICBpZiAoaXNDYXRlZ29yeShheGlzTW9kZWwpICYmIHJlc3VsdC5maXJzdENhdGVnb3J5RGltSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBjYXRlZ29yeUF4aXNNYXAuc2V0KGF4aXNEaW0sIGF4aXNNb2RlbCk7XG4gICAgICAgIHJlc3VsdC5maXJzdENhdGVnb3J5RGltSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNDYXRlZ29yeShheGlzTW9kZWwpIHtcbiAgcmV0dXJuIGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2NhdGVnb3J5Jztcbn1cblxuZXhwb3J0cy5nZXRDb29yZFN5c0RlZmluZUJ5U2VyaWVzID0gZ2V0Q29vcmRTeXNEZWZpbmVCeVNlcmllcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9yZWZlckhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvcmVmZXJIZWxwZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX3V0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG52YXIgaXNBcnJheSA9IF91dGlsLmlzQXJyYXk7XG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcblxudmFyIGNvbXBhdFN0eWxlID0gcmVxdWlyZShcIi4vaGVscGVyL2NvbXBhdFN0eWxlXCIpO1xuXG52YXIgX21vZGVsID0gcmVxdWlyZShcIi4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBub3JtYWxpemVUb0FycmF5ID0gX21vZGVsLm5vcm1hbGl6ZVRvQXJyYXk7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIENvbXBhdGl0YWJsZSB3aXRoIDIuMFxuZnVuY3Rpb24gZ2V0KG9wdCwgcGF0aCkge1xuICBwYXRoID0gcGF0aC5zcGxpdCgnLCcpO1xuICB2YXIgb2JqID0gb3B0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIG9iaiA9IG9iaiAmJiBvYmpbcGF0aFtpXV07XG5cbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHNldChvcHQsIHBhdGgsIHZhbCwgb3ZlcndyaXRlKSB7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcsJyk7XG4gIHZhciBvYmogPSBvcHQ7XG4gIHZhciBrZXk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGtleSA9IHBhdGhbaV07XG5cbiAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICB9XG5cbiAgICBvYmogPSBvYmpba2V5XTtcbiAgfVxuXG4gIGlmIChvdmVyd3JpdGUgfHwgb2JqW3BhdGhbaV1dID09IG51bGwpIHtcbiAgICBvYmpbcGF0aFtpXV0gPSB2YWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGF0TGF5b3V0UHJvcGVydGllcyhvcHRpb24pIHtcbiAgZWFjaChMQVlPVVRfUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICBpZiAocHJvcFswXSBpbiBvcHRpb24gJiYgIShwcm9wWzFdIGluIG9wdGlvbikpIHtcbiAgICAgIG9wdGlvbltwcm9wWzFdXSA9IG9wdGlvbltwcm9wWzBdXTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgTEFZT1VUX1BST1BFUlRJRVMgPSBbWyd4JywgJ2xlZnQnXSwgWyd5JywgJ3RvcCddLCBbJ3gyJywgJ3JpZ2h0J10sIFsneTInLCAnYm90dG9tJ11dO1xudmFyIENPTVBBVElUQUJMRV9DT01QT05FTlRTID0gWydncmlkJywgJ2dlbycsICdwYXJhbGxlbCcsICdsZWdlbmQnLCAndG9vbGJveCcsICd0aXRsZScsICd2aXN1YWxNYXAnLCAnZGF0YVpvb20nLCAndGltZWxpbmUnXTtcblxuZnVuY3Rpb24gX2RlZmF1bHQob3B0aW9uLCBpc1RoZW1lKSB7XG4gIGNvbXBhdFN0eWxlKG9wdGlvbiwgaXNUaGVtZSk7IC8vIE1ha2Ugc3VyZSBzZXJpZXMgYXJyYXkgZm9yIG1vZGVsIGluaXRpYWxpemF0aW9uLlxuXG4gIG9wdGlvbi5zZXJpZXMgPSBub3JtYWxpemVUb0FycmF5KG9wdGlvbi5zZXJpZXMpO1xuICBlYWNoKG9wdGlvbi5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHNlcmllc09wdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VyaWVzVHlwZSA9IHNlcmllc09wdC50eXBlO1xuXG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdwaWUnIHx8IHNlcmllc1R5cGUgPT09ICdnYXVnZScpIHtcbiAgICAgIGlmIChzZXJpZXNPcHQuY2xvY2tXaXNlICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWVzT3B0LmNsb2Nrd2lzZSA9IHNlcmllc09wdC5jbG9ja1dpc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdnYXVnZScpIHtcbiAgICAgIHZhciBwb2ludGVyQ29sb3IgPSBnZXQoc2VyaWVzT3B0LCAncG9pbnRlci5jb2xvcicpO1xuICAgICAgcG9pbnRlckNvbG9yICE9IG51bGwgJiYgc2V0KHNlcmllc09wdCwgJ2l0ZW1TdHlsZS5ub3JtYWwuY29sb3InLCBwb2ludGVyQ29sb3IpO1xuICAgIH1cblxuICAgIGNvbXBhdExheW91dFByb3BlcnRpZXMoc2VyaWVzT3B0KTtcbiAgfSk7IC8vIGRhdGFSYW5nZSBoYXMgY2hhbmdlZCB0byB2aXN1YWxNYXBcblxuICBpZiAob3B0aW9uLmRhdGFSYW5nZSkge1xuICAgIG9wdGlvbi52aXN1YWxNYXAgPSBvcHRpb24uZGF0YVJhbmdlO1xuICB9XG5cbiAgZWFjaChDT01QQVRJVEFCTEVfQ09NUE9ORU5UUywgZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbltjb21wb25lbnROYW1lXTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAoIWlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IFtvcHRpb25zXTtcbiAgICAgIH1cblxuICAgICAgZWFjaChvcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIGNvbXBhdExheW91dFByb3BlcnRpZXMob3B0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJlcHJvY2Vzc29yL2JhY2t3YXJkQ29tcGF0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xudmFyIFBPU1NJQkxFX1NUWUxFUyA9IFsnYXJlYVN0eWxlJywgJ2xpbmVTdHlsZScsICdub2RlU3R5bGUnLCAnbGlua1N0eWxlJywgJ2Nob3JkU3R5bGUnLCAnbGFiZWwnLCAnbGFiZWxMaW5lJ107XG5cbmZ1bmN0aW9uIGNvbXBhdEVDMkl0ZW1TdHlsZShvcHQpIHtcbiAgdmFyIGl0ZW1TdHlsZU9wdCA9IG9wdCAmJiBvcHQuaXRlbVN0eWxlO1xuXG4gIGlmICghaXRlbVN0eWxlT3B0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IFBPU1NJQkxFX1NUWUxFUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzdHlsZU5hbWUgPSBQT1NTSUJMRV9TVFlMRVNbaV07XG4gICAgdmFyIG5vcm1hbEl0ZW1TdHlsZU9wdCA9IGl0ZW1TdHlsZU9wdC5ub3JtYWw7XG4gICAgdmFyIGVtcGhhc2lzSXRlbVN0eWxlT3B0ID0gaXRlbVN0eWxlT3B0LmVtcGhhc2lzO1xuXG4gICAgaWYgKG5vcm1hbEl0ZW1TdHlsZU9wdCAmJiBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSkge1xuICAgICAgb3B0W3N0eWxlTmFtZV0gPSBvcHRbc3R5bGVOYW1lXSB8fCB7fTtcblxuICAgICAgaWYgKCFvcHRbc3R5bGVOYW1lXS5ub3JtYWwpIHtcbiAgICAgICAgb3B0W3N0eWxlTmFtZV0ubm9ybWFsID0gbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6clV0aWwubWVyZ2Uob3B0W3N0eWxlTmFtZV0ubm9ybWFsLCBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIG5vcm1hbEl0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZW1waGFzaXNJdGVtU3R5bGVPcHQgJiYgZW1waGFzaXNJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSkge1xuICAgICAgb3B0W3N0eWxlTmFtZV0gPSBvcHRbc3R5bGVOYW1lXSB8fCB7fTtcblxuICAgICAgaWYgKCFvcHRbc3R5bGVOYW1lXS5lbXBoYXNpcykge1xuICAgICAgICBvcHRbc3R5bGVOYW1lXS5lbXBoYXNpcyA9IGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6clV0aWwubWVyZ2Uob3B0W3N0eWxlTmFtZV0uZW1waGFzaXMsIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29udmVydE5vcm1hbEVtcGhhc2lzKG9wdCwgb3B0VHlwZSwgdXNlRXh0ZW5kKSB7XG4gIGlmIChvcHQgJiYgb3B0W29wdFR5cGVdICYmIChvcHRbb3B0VHlwZV0ubm9ybWFsIHx8IG9wdFtvcHRUeXBlXS5lbXBoYXNpcykpIHtcbiAgICB2YXIgbm9ybWFsT3B0ID0gb3B0W29wdFR5cGVdLm5vcm1hbDtcbiAgICB2YXIgZW1waGFzaXNPcHQgPSBvcHRbb3B0VHlwZV0uZW1waGFzaXM7XG5cbiAgICBpZiAobm9ybWFsT3B0KSB7XG4gICAgICAvLyBUaW1lbGluZSBjb250cm9sU3R5bGUgaGFzIG90aGVyIHByb3BlcnRpZXMgYmVzaWRlcyBub3JtYWwgYW5kIGVtcGhhc2lzXG4gICAgICBpZiAodXNlRXh0ZW5kKSB7XG4gICAgICAgIG9wdFtvcHRUeXBlXS5ub3JtYWwgPSBvcHRbb3B0VHlwZV0uZW1waGFzaXMgPSBudWxsO1xuICAgICAgICB6clV0aWwuZGVmYXVsdHMob3B0W29wdFR5cGVdLCBub3JtYWxPcHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0W29wdFR5cGVdID0gbm9ybWFsT3B0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbXBoYXNpc09wdCkge1xuICAgICAgb3B0LmVtcGhhc2lzID0gb3B0LmVtcGhhc2lzIHx8IHt9O1xuICAgICAgb3B0LmVtcGhhc2lzW29wdFR5cGVdID0gZW1waGFzaXNPcHQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVDM05vcm1hbFN0YXR1cyhvcHQpIHtcbiAgY29udmVydE5vcm1hbEVtcGhhc2lzKG9wdCwgJ2l0ZW1TdHlsZScpO1xuICBjb252ZXJ0Tm9ybWFsRW1waGFzaXMob3B0LCAnbGluZVN0eWxlJyk7XG4gIGNvbnZlcnROb3JtYWxFbXBoYXNpcyhvcHQsICdhcmVhU3R5bGUnKTtcbiAgY29udmVydE5vcm1hbEVtcGhhc2lzKG9wdCwgJ2xhYmVsJyk7XG4gIGNvbnZlcnROb3JtYWxFbXBoYXNpcyhvcHQsICdsYWJlbExpbmUnKTsgLy8gdHJlZW1hcFxuXG4gIGNvbnZlcnROb3JtYWxFbXBoYXNpcyhvcHQsICd1cHBlckxhYmVsJyk7IC8vIGdyYXBoXG5cbiAgY29udmVydE5vcm1hbEVtcGhhc2lzKG9wdCwgJ2VkZ2VMYWJlbCcpO1xufVxuXG5mdW5jdGlvbiBjb21wYXRUZXh0U3R5bGUob3B0LCBwcm9wTmFtZSkge1xuICAvLyBDaGVjayB3aGV0aGVyIGlzIG5vdCBvYmplY3QgKHN0cmluZ1xcbnVsbFxcdW5kZWZpbmVkIC4uLilcbiAgdmFyIGxhYmVsT3B0U2luZ2xlID0gaXNPYmplY3Qob3B0KSAmJiBvcHRbcHJvcE5hbWVdO1xuICB2YXIgdGV4dFN0eWxlID0gaXNPYmplY3QobGFiZWxPcHRTaW5nbGUpICYmIGxhYmVsT3B0U2luZ2xlLnRleHRTdHlsZTtcblxuICBpZiAodGV4dFN0eWxlKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1vZGVsVXRpbC5URVhUX1NUWUxFX09QVElPTlMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwcm9wTmFtZSA9IG1vZGVsVXRpbC5URVhUX1NUWUxFX09QVElPTlNbaV07XG5cbiAgICAgIGlmICh0ZXh0U3R5bGUuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGxhYmVsT3B0U2luZ2xlW3Byb3BOYW1lXSA9IHRleHRTdHlsZVtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhdEVDM0NvbW1vblN0eWxlcyhvcHQpIHtcbiAgaWYgKG9wdCkge1xuICAgIHJlbW92ZUVDM05vcm1hbFN0YXR1cyhvcHQpO1xuICAgIGNvbXBhdFRleHRTdHlsZShvcHQsICdsYWJlbCcpO1xuICAgIG9wdC5lbXBoYXNpcyAmJiBjb21wYXRUZXh0U3R5bGUob3B0LmVtcGhhc2lzLCAnbGFiZWwnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2VyaWVzKHNlcmllc09wdCkge1xuICBpZiAoIWlzT2JqZWN0KHNlcmllc09wdCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb21wYXRFQzJJdGVtU3R5bGUoc2VyaWVzT3B0KTtcbiAgcmVtb3ZlRUMzTm9ybWFsU3RhdHVzKHNlcmllc09wdCk7XG4gIGNvbXBhdFRleHRTdHlsZShzZXJpZXNPcHQsICdsYWJlbCcpOyAvLyB0cmVlbWFwXG5cbiAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ3VwcGVyTGFiZWwnKTsgLy8gZ3JhcGhcblxuICBjb21wYXRUZXh0U3R5bGUoc2VyaWVzT3B0LCAnZWRnZUxhYmVsJyk7XG5cbiAgaWYgKHNlcmllc09wdC5lbXBoYXNpcykge1xuICAgIGNvbXBhdFRleHRTdHlsZShzZXJpZXNPcHQuZW1waGFzaXMsICdsYWJlbCcpOyAvLyB0cmVlbWFwXG5cbiAgICBjb21wYXRUZXh0U3R5bGUoc2VyaWVzT3B0LmVtcGhhc2lzLCAndXBwZXJMYWJlbCcpOyAvLyBncmFwaFxuXG4gICAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdC5lbXBoYXNpcywgJ2VkZ2VMYWJlbCcpO1xuICB9XG5cbiAgdmFyIG1hcmtQb2ludCA9IHNlcmllc09wdC5tYXJrUG9pbnQ7XG5cbiAgaWYgKG1hcmtQb2ludCkge1xuICAgIGNvbXBhdEVDMkl0ZW1TdHlsZShtYXJrUG9pbnQpO1xuICAgIGNvbXBhdEVDM0NvbW1vblN0eWxlcyhtYXJrUG9pbnQpO1xuICB9XG5cbiAgdmFyIG1hcmtMaW5lID0gc2VyaWVzT3B0Lm1hcmtMaW5lO1xuXG4gIGlmIChtYXJrTGluZSkge1xuICAgIGNvbXBhdEVDMkl0ZW1TdHlsZShtYXJrTGluZSk7XG4gICAgY29tcGF0RUMzQ29tbW9uU3R5bGVzKG1hcmtMaW5lKTtcbiAgfVxuXG4gIHZhciBtYXJrQXJlYSA9IHNlcmllc09wdC5tYXJrQXJlYTtcblxuICBpZiAobWFya0FyZWEpIHtcbiAgICBjb21wYXRFQzNDb21tb25TdHlsZXMobWFya0FyZWEpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBzZXJpZXNPcHQuZGF0YTsgLy8gQnJlYWsgd2l0aCBlYzM6IGlmIGBzZXRPcHRpb25gIGFnYWluLCB0aGVyZSBtYXkgYmUgbm8gYHR5cGVgIGluIG9wdGlvbixcbiAgLy8gdGhlbiB0aGUgYmFja3dhcmQgY29tcGF0IGJhc2VkIG9uIG9wdGlvbiB0eXBlIHdpbGwgbm90IGJlIHBlcmZvcm1lZC5cblxuICBpZiAoc2VyaWVzT3B0LnR5cGUgPT09ICdncmFwaCcpIHtcbiAgICBkYXRhID0gZGF0YSB8fCBzZXJpZXNPcHQubm9kZXM7XG4gICAgdmFyIGVkZ2VEYXRhID0gc2VyaWVzT3B0LmxpbmtzIHx8IHNlcmllc09wdC5lZGdlcztcblxuICAgIGlmIChlZGdlRGF0YSAmJiAhenJVdGlsLmlzVHlwZWRBcnJheShlZGdlRGF0YSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29tcGF0RUMzQ29tbW9uU3R5bGVzKGVkZ2VEYXRhW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB6clV0aWwuZWFjaChzZXJpZXNPcHQuY2F0ZWdvcmllcywgZnVuY3Rpb24gKG9wdCkge1xuICAgICAgcmVtb3ZlRUMzTm9ybWFsU3RhdHVzKG9wdCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGF0YSAmJiAhenJVdGlsLmlzVHlwZWRBcnJheShkYXRhKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29tcGF0RUMzQ29tbW9uU3R5bGVzKGRhdGFbaV0pO1xuICAgIH1cbiAgfSAvLyBtYXJrIHBvaW50IGRhdGFcblxuXG4gIHZhciBtYXJrUG9pbnQgPSBzZXJpZXNPcHQubWFya1BvaW50O1xuXG4gIGlmIChtYXJrUG9pbnQgJiYgbWFya1BvaW50LmRhdGEpIHtcbiAgICB2YXIgbXBEYXRhID0gbWFya1BvaW50LmRhdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1wRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29tcGF0RUMzQ29tbW9uU3R5bGVzKG1wRGF0YVtpXSk7XG4gICAgfVxuICB9IC8vIG1hcmsgbGluZSBkYXRhXG5cblxuICB2YXIgbWFya0xpbmUgPSBzZXJpZXNPcHQubWFya0xpbmU7XG5cbiAgaWYgKG1hcmtMaW5lICYmIG1hcmtMaW5lLmRhdGEpIHtcbiAgICB2YXIgbWxEYXRhID0gbWFya0xpbmUuZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoenJVdGlsLmlzQXJyYXkobWxEYXRhW2ldKSkge1xuICAgICAgICBjb21wYXRFQzNDb21tb25TdHlsZXMobWxEYXRhW2ldWzBdKTtcbiAgICAgICAgY29tcGF0RUMzQ29tbW9uU3R5bGVzKG1sRGF0YVtpXVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wYXRFQzNDb21tb25TdHlsZXMobWxEYXRhW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU2VyaWVzXG5cblxuICBpZiAoc2VyaWVzT3B0LnR5cGUgPT09ICdnYXVnZScpIHtcbiAgICBjb21wYXRUZXh0U3R5bGUoc2VyaWVzT3B0LCAnYXhpc0xhYmVsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ3RpdGxlJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ2RldGFpbCcpO1xuICB9IGVsc2UgaWYgKHNlcmllc09wdC50eXBlID09PSAndHJlZW1hcCcpIHtcbiAgICBjb252ZXJ0Tm9ybWFsRW1waGFzaXMoc2VyaWVzT3B0LmJyZWFkY3J1bWIsICdpdGVtU3R5bGUnKTtcbiAgICB6clV0aWwuZWFjaChzZXJpZXNPcHQubGV2ZWxzLCBmdW5jdGlvbiAob3B0KSB7XG4gICAgICByZW1vdmVFQzNOb3JtYWxTdGF0dXMob3B0KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzZXJpZXNPcHQudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgcmVtb3ZlRUMzTm9ybWFsU3RhdHVzKHNlcmllc09wdC5sZWF2ZXMpO1xuICB9IC8vIHN1bmJ1cnN0IHN0YXJ0cyBmcm9tIGVjNCwgc28gaXQgZG9lcyBub3QgbmVlZCB0byBjb21wYXQgbGV2ZWxzLlxuXG59XG5cbmZ1bmN0aW9uIHRvQXJyKG8pIHtcbiAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KG8pID8gbyA6IG8gPyBbb10gOiBbXTtcbn1cblxuZnVuY3Rpb24gdG9PYmoobykge1xuICByZXR1cm4gKHpyVXRpbC5pc0FycmF5KG8pID8gb1swXSA6IG8pIHx8IHt9O1xufVxuXG5mdW5jdGlvbiBfZGVmYXVsdChvcHRpb24sIGlzVGhlbWUpIHtcbiAgZWFjaCh0b0FycihvcHRpb24uc2VyaWVzKSwgZnVuY3Rpb24gKHNlcmllc09wdCkge1xuICAgIGlzT2JqZWN0KHNlcmllc09wdCkgJiYgcHJvY2Vzc1NlcmllcyhzZXJpZXNPcHQpO1xuICB9KTtcbiAgdmFyIGF4ZXMgPSBbJ3hBeGlzJywgJ3lBeGlzJywgJ3JhZGl1c0F4aXMnLCAnYW5nbGVBeGlzJywgJ3NpbmdsZUF4aXMnLCAncGFyYWxsZWxBeGlzJywgJ3JhZGFyJ107XG4gIGlzVGhlbWUgJiYgYXhlcy5wdXNoKCd2YWx1ZUF4aXMnLCAnY2F0ZWdvcnlBeGlzJywgJ2xvZ0F4aXMnLCAndGltZUF4aXMnKTtcbiAgZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpc05hbWUpIHtcbiAgICBlYWNoKHRvQXJyKG9wdGlvbltheGlzTmFtZV0pLCBmdW5jdGlvbiAoYXhpc09wdCkge1xuICAgICAgaWYgKGF4aXNPcHQpIHtcbiAgICAgICAgY29tcGF0VGV4dFN0eWxlKGF4aXNPcHQsICdheGlzTGFiZWwnKTtcbiAgICAgICAgY29tcGF0VGV4dFN0eWxlKGF4aXNPcHQuYXhpc1BvaW50ZXIsICdsYWJlbCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgZWFjaCh0b0FycihvcHRpb24ucGFyYWxsZWwpLCBmdW5jdGlvbiAocGFyYWxsZWxPcHQpIHtcbiAgICB2YXIgcGFyYWxsZWxBeGlzRGVmYXVsdCA9IHBhcmFsbGVsT3B0ICYmIHBhcmFsbGVsT3B0LnBhcmFsbGVsQXhpc0RlZmF1bHQ7XG4gICAgY29tcGF0VGV4dFN0eWxlKHBhcmFsbGVsQXhpc0RlZmF1bHQsICdheGlzTGFiZWwnKTtcbiAgICBjb21wYXRUZXh0U3R5bGUocGFyYWxsZWxBeGlzRGVmYXVsdCAmJiBwYXJhbGxlbEF4aXNEZWZhdWx0LmF4aXNQb2ludGVyLCAnbGFiZWwnKTtcbiAgfSk7XG4gIGVhY2godG9BcnIob3B0aW9uLmNhbGVuZGFyKSwgZnVuY3Rpb24gKGNhbGVuZGFyT3B0KSB7XG4gICAgY29udmVydE5vcm1hbEVtcGhhc2lzKGNhbGVuZGFyT3B0LCAnaXRlbVN0eWxlJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKGNhbGVuZGFyT3B0LCAnZGF5TGFiZWwnKTtcbiAgICBjb21wYXRUZXh0U3R5bGUoY2FsZW5kYXJPcHQsICdtb250aExhYmVsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKGNhbGVuZGFyT3B0LCAneWVhckxhYmVsJyk7XG4gIH0pOyAvLyByYWRhci5uYW1lLnRleHRTdHlsZVxuXG4gIGVhY2godG9BcnIob3B0aW9uLnJhZGFyKSwgZnVuY3Rpb24gKHJhZGFyT3B0KSB7XG4gICAgY29tcGF0VGV4dFN0eWxlKHJhZGFyT3B0LCAnbmFtZScpO1xuICB9KTtcbiAgZWFjaCh0b0FycihvcHRpb24uZ2VvKSwgZnVuY3Rpb24gKGdlb09wdCkge1xuICAgIGlmIChpc09iamVjdChnZW9PcHQpKSB7XG4gICAgICBjb21wYXRFQzNDb21tb25TdHlsZXMoZ2VvT3B0KTtcbiAgICAgIGVhY2godG9BcnIoZ2VvT3B0LnJlZ2lvbnMpLCBmdW5jdGlvbiAocmVnaW9uT2JqKSB7XG4gICAgICAgIGNvbXBhdEVDM0NvbW1vblN0eWxlcyhyZWdpb25PYmopO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZWFjaCh0b0FycihvcHRpb24udGltZWxpbmUpLCBmdW5jdGlvbiAodGltZWxpbmVPcHQpIHtcbiAgICBjb21wYXRFQzNDb21tb25TdHlsZXModGltZWxpbmVPcHQpO1xuICAgIGNvbnZlcnROb3JtYWxFbXBoYXNpcyh0aW1lbGluZU9wdCwgJ2xhYmVsJyk7XG4gICAgY29udmVydE5vcm1hbEVtcGhhc2lzKHRpbWVsaW5lT3B0LCAnaXRlbVN0eWxlJyk7XG4gICAgY29udmVydE5vcm1hbEVtcGhhc2lzKHRpbWVsaW5lT3B0LCAnY29udHJvbFN0eWxlJywgdHJ1ZSk7XG4gICAgdmFyIGRhdGEgPSB0aW1lbGluZU9wdC5kYXRhO1xuICAgIHpyVXRpbC5pc0FycmF5KGRhdGEpICYmIHpyVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGNvbnZlcnROb3JtYWxFbXBoYXNpcyhpdGVtLCAnbGFiZWwnKTtcbiAgICAgICAgY29udmVydE5vcm1hbEVtcGhhc2lzKGl0ZW0sICdpdGVtU3R5bGUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGVhY2godG9BcnIob3B0aW9uLnRvb2xib3gpLCBmdW5jdGlvbiAodG9vbGJveE9wdCkge1xuICAgIGNvbnZlcnROb3JtYWxFbXBoYXNpcyh0b29sYm94T3B0LCAnaWNvblN0eWxlJyk7XG4gICAgZWFjaCh0b29sYm94T3B0LmZlYXR1cmUsIGZ1bmN0aW9uIChmZWF0dXJlT3B0KSB7XG4gICAgICBjb252ZXJ0Tm9ybWFsRW1waGFzaXMoZmVhdHVyZU9wdCwgJ2ljb25TdHlsZScpO1xuICAgIH0pO1xuICB9KTtcbiAgY29tcGF0VGV4dFN0eWxlKHRvT2JqKG9wdGlvbi5heGlzUG9pbnRlciksICdsYWJlbCcpO1xuICBjb21wYXRUZXh0U3R5bGUodG9PYmoob3B0aW9uLnRvb2x0aXApLmF4aXNQb2ludGVyLCAnbGFiZWwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvaGVscGVyL2NvbXBhdFN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvaGVscGVyL2NvbXBhdFN0eWxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIHNhbXBsZXJzID0ge1xuICBhdmVyYWdlOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc05hTihmcmFtZVtpXSkpIHtcbiAgICAgICAgc3VtICs9IGZyYW1lW2ldO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0gLy8gUmV0dXJuIE5hTiBpZiBjb3VudCBpcyAwXG5cblxuICAgIHJldHVybiBjb3VudCA9PT0gMCA/IE5hTiA6IHN1bSAvIGNvdW50O1xuICB9LFxuICBzdW06IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHZhciBzdW0gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gSWdub3JlIE5hTlxuICAgICAgc3VtICs9IGZyYW1lW2ldIHx8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bTtcbiAgfSxcbiAgbWF4OiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhbWVbaV0gPiBtYXggJiYgKG1heCA9IGZyYW1lW2ldKTtcbiAgICB9IC8vIE5hTiB3aWxsIGNhdXNlIGlsbGVnYWwgYXhpcyBleHRlbnQuXG5cblxuICAgIHJldHVybiBpc0Zpbml0ZShtYXgpID8gbWF4IDogTmFOO1xuICB9LFxuICBtaW46IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYW1lW2ldIDwgbWluICYmIChtaW4gPSBmcmFtZVtpXSk7XG4gICAgfSAvLyBOYU4gd2lsbCBjYXVzZSBpbGxlZ2FsIGF4aXMgZXh0ZW50LlxuXG5cbiAgICByZXR1cm4gaXNGaW5pdGUobWluKSA/IG1pbiA6IE5hTjtcbiAgfSxcbiAgLy8gVE9ET1xuICAvLyBNZWRpYW5cbiAgbmVhcmVzdDogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgcmV0dXJuIGZyYW1lWzBdO1xuICB9XG59O1xuXG52YXIgaW5kZXhTYW1wbGVyID0gZnVuY3Rpb24gKGZyYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChmcmFtZS5sZW5ndGggLyAyKTtcbn07XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHNlcmllc1R5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICBzZXJpZXNUeXBlOiBzZXJpZXNUeXBlLFxuICAgIG1vZGlmeU91dHB1dEVuZDogdHJ1ZSxcbiAgICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIHNhbXBsaW5nID0gc2VyaWVzTW9kZWwuZ2V0KCdzYW1wbGluZycpO1xuICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTsgLy8gT25seSBjYXJ0ZXNpYW4yZCBzdXBwb3J0IGRvd24gc2FtcGxpbmdcblxuICAgICAgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgJiYgc2FtcGxpbmcpIHtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICAgIHZhciBleHRlbnQgPSBiYXNlQXhpcy5nZXRFeHRlbnQoKTsgLy8gQ29vcmRpbnN0ZSBzeXN0ZW0gaGFzIGJlZW4gcmVzaXplZFxuXG4gICAgICAgIHZhciBzaXplID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgICAgICB2YXIgcmF0ZSA9IE1hdGgucm91bmQoZGF0YS5jb3VudCgpIC8gc2l6ZSk7XG5cbiAgICAgICAgaWYgKHJhdGUgPiAxKSB7XG4gICAgICAgICAgdmFyIHNhbXBsZXI7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNhbXBsaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2FtcGxlciA9IHNhbXBsZXJzW3NhbXBsaW5nXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzYW1wbGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FtcGxlciA9IHNhbXBsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzYW1wbGVyKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHN1cHBvcnQgc2FtcGxlIHRoZSBmaXJzdCBkaW0gbWFwcGVkIGZyb20gdmFsdWUgYXhpcy5cbiAgICAgICAgICAgIHNlcmllc01vZGVsLnNldERhdGEoZGF0YS5kb3duU2FtcGxlKGRhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpcy5kaW0pLCAxIC8gcmF0ZSwgc2FtcGxlciwgaW5kZXhTYW1wbGVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcm9jZXNzb3IvZGF0YVNhbXBsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBjcmVhdGVIYXNoTWFwID0gX3V0aWwuY3JlYXRlSGFzaE1hcDtcbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gKDEpIFtDYXV0aW9uXTogdGhlIGxvZ2ljIGlzIGNvcnJlY3QgYmFzZWQgb24gdGhlIHByZW1pc2VzOlxuLy8gICAgIGRhdGEgcHJvY2Vzc2luZyBzdGFnZSBpcyBibG9ja2VkIGluIHN0cmVhbS5cbi8vICAgICBTZWUgPG1vZHVsZTplY2hhcnRzL3N0cmVhbS9TY2hlZHVsZXIjcGVyZm9ybURhdGFQcm9jZXNzb3JUYXNrcz5cbi8vICgyKSBPbmx5IHJlZ2lzdGVyIG9uY2Ugd2hlbiBpbXBvcnQgcmVwZWF0bHkuXG4vLyAgICAgU2hvdWxkIGJlIGV4ZWN1dGVkIGJlZm9yZSBhZnRlciBzZXJpZXMgZmlsdGVyZWQgYW5kIGJlZm9yZSBzdGFjayBjYWxjdWxhdGlvbi5cbmZ1bmN0aW9uIF9kZWZhdWx0KGVjTW9kZWwpIHtcbiAgdmFyIHN0YWNrSW5mb01hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBzdGFjayA9IHNlcmllc01vZGVsLmdldCgnc3RhY2snKTsgLy8gQ29tcGF0aWJhbDogd2hlbiBgc3RhY2tgIGlzIHNldCBhcyAnJywgZG8gbm90IHN0YWNrLlxuXG4gICAgaWYgKHN0YWNrKSB7XG4gICAgICB2YXIgc3RhY2tJbmZvTGlzdCA9IHN0YWNrSW5mb01hcC5nZXQoc3RhY2spIHx8IHN0YWNrSW5mb01hcC5zZXQoc3RhY2ssIFtdKTtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIHN0YWNrSW5mbyA9IHtcbiAgICAgICAgLy8gVXNlZCBmb3IgY2FsY3VsYXRlIGF4aXMgZXh0ZW50IGF1dG9tYXRpY2FsbHkuXG4gICAgICAgIHN0YWNrUmVzdWx0RGltZW5zaW9uOiBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tSZXN1bHREaW1lbnNpb24nKSxcbiAgICAgICAgc3RhY2tlZE92ZXJEaW1lbnNpb246IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkT3ZlckRpbWVuc2lvbicpLFxuICAgICAgICBzdGFja2VkRGltZW5zaW9uOiBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZERpbWVuc2lvbicpLFxuICAgICAgICBzdGFja2VkQnlEaW1lbnNpb246IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkQnlEaW1lbnNpb24nKSxcbiAgICAgICAgaXNTdGFja2VkQnlJbmRleDogZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ2lzU3RhY2tlZEJ5SW5kZXgnKSxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgc2VyaWVzTW9kZWw6IHNlcmllc01vZGVsXG4gICAgICB9OyAvLyBJZiBzdGFja2VkIG9uIGF4aXMgdGhhdCBkbyBub3Qgc3VwcG9ydCBkYXRhIHN0YWNrLlxuXG4gICAgICBpZiAoIXN0YWNrSW5mby5zdGFja2VkRGltZW5zaW9uIHx8ICEoc3RhY2tJbmZvLmlzU3RhY2tlZEJ5SW5kZXggfHwgc3RhY2tJbmZvLnN0YWNrZWRCeURpbWVuc2lvbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzdGFja0luZm9MaXN0Lmxlbmd0aCAmJiBkYXRhLnNldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZE9uU2VyaWVzJywgc3RhY2tJbmZvTGlzdFtzdGFja0luZm9MaXN0Lmxlbmd0aCAtIDFdLnNlcmllc01vZGVsKTtcbiAgICAgIHN0YWNrSW5mb0xpc3QucHVzaChzdGFja0luZm8pO1xuICAgIH1cbiAgfSk7XG4gIHN0YWNrSW5mb01hcC5lYWNoKGNhbGN1bGF0ZVN0YWNrKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU3RhY2soc3RhY2tJbmZvTGlzdCkge1xuICBlYWNoKHN0YWNrSW5mb0xpc3QsIGZ1bmN0aW9uICh0YXJnZXRTdGFja0luZm8sIGlkeEluU3RhY2spIHtcbiAgICB2YXIgcmVzdWx0VmFsID0gW107XG4gICAgdmFyIHJlc3VsdE5hTiA9IFtOYU4sIE5hTl07XG4gICAgdmFyIGRpbXMgPSBbdGFyZ2V0U3RhY2tJbmZvLnN0YWNrUmVzdWx0RGltZW5zaW9uLCB0YXJnZXRTdGFja0luZm8uc3RhY2tlZE92ZXJEaW1lbnNpb25dO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0U3RhY2tJbmZvLmRhdGE7XG4gICAgdmFyIGlzU3RhY2tlZEJ5SW5kZXggPSB0YXJnZXRTdGFja0luZm8uaXNTdGFja2VkQnlJbmRleDsgLy8gU2hvdWxkIG5vdCB3cml0ZSBvbiByYXcgZGF0YSwgYmVjYXVzZSBzdGFjayBzZXJpZXMgbW9kZWwgbGlzdCBjaGFuZ2VzXG4gICAgLy8gZGVwZW5kaW5nIG9uIGxlZ2VuZCBzZWxlY3Rpb24uXG5cbiAgICB2YXIgbmV3RGF0YSA9IHRhcmdldERhdGEubWFwKGRpbXMsIGZ1bmN0aW9uICh2MCwgdjEsIGRhdGFJbmRleCkge1xuICAgICAgdmFyIHN1bSA9IHRhcmdldERhdGEuZ2V0KHRhcmdldFN0YWNrSW5mby5zdGFja2VkRGltZW5zaW9uLCBkYXRhSW5kZXgpOyAvLyBDb25zaWRlciBgY29ubmVjdE51bGxzYCBvZiBsaW5lIGFyZWEsIGlmIHZhbHVlIGlzIE5hTiwgc3RhY2tlZE92ZXJcbiAgICAgIC8vIHNob3VsZCBhbHNvIGJlIE5hTiwgdG8gZHJhdyBhIGFwcHJvcHJpYXRlIGJlbHQgYXJlYS5cblxuICAgICAgaWYgKGlzTmFOKHN1bSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdE5hTjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ5VmFsdWU7XG4gICAgICB2YXIgc3RhY2tlZERhdGFSYXdJbmRleDtcblxuICAgICAgaWYgKGlzU3RhY2tlZEJ5SW5kZXgpIHtcbiAgICAgICAgc3RhY2tlZERhdGFSYXdJbmRleCA9IHRhcmdldERhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ5VmFsdWUgPSB0YXJnZXREYXRhLmdldCh0YXJnZXRTdGFja0luZm8uc3RhY2tlZEJ5RGltZW5zaW9uLCBkYXRhSW5kZXgpO1xuICAgICAgfSAvLyBJZiBzdGFja092ZXIgaXMgTmFOLCBjaGFydCB2aWV3IHdpbGwgcmVuZGVyIHBvaW50IG9uIHZhbHVlIHN0YXJ0LlxuXG5cbiAgICAgIHZhciBzdGFja2VkT3ZlciA9IE5hTjtcblxuICAgICAgZm9yICh2YXIgaiA9IGlkeEluU3RhY2sgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgc3RhY2tJbmZvID0gc3RhY2tJbmZvTGlzdFtqXTsgLy8gSGFzIGJlZW4gb3B0aW1pemVkIGJ5IGludmVydGVkIGluZGljZXMgb24gYHN0YWNrZWRCeURpbWVuc2lvbmAuXG5cbiAgICAgICAgaWYgKCFpc1N0YWNrZWRCeUluZGV4KSB7XG4gICAgICAgICAgc3RhY2tlZERhdGFSYXdJbmRleCA9IHN0YWNrSW5mby5kYXRhLnJhd0luZGV4T2Yoc3RhY2tJbmZvLnN0YWNrZWRCeURpbWVuc2lvbiwgYnlWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhY2tlZERhdGFSYXdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IHN0YWNrSW5mby5kYXRhLmdldEJ5UmF3SW5kZXgoc3RhY2tJbmZvLnN0YWNrUmVzdWx0RGltZW5zaW9uLCBzdGFja2VkRGF0YVJhd0luZGV4KTsgLy8gQ29uc2lkZXJpbmcgcG9zaXRpdmUgc3RhY2ssIG5lZ2F0aXZlIHN0YWNrIGFuZCBlbXB0eSBkYXRhXG5cbiAgICAgICAgICBpZiAoc3VtID49IDAgJiYgdmFsID4gMCB8fCAvLyBQb3NpdGl2ZSBzdGFja1xuICAgICAgICAgIHN1bSA8PSAwICYmIHZhbCA8IDAgLy8gTmVnYXRpdmUgc3RhY2tcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgc3VtICs9IHZhbDtcbiAgICAgICAgICAgICAgc3RhY2tlZE92ZXIgPSB2YWw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFZhbFswXSA9IHN1bTtcbiAgICAgIHJlc3VsdFZhbFsxXSA9IHN0YWNrZWRPdmVyO1xuICAgICAgcmV0dXJuIHJlc3VsdFZhbDtcbiAgICB9KTtcbiAgICB0YXJnZXREYXRhLmhvc3RNb2RlbC5zZXREYXRhKG5ld0RhdGEpOyAvLyBVcGRhdGUgZm9yIGNvbnNlcXVlbnQgY2FsY3VsYXRpb25cblxuICAgIHRhcmdldFN0YWNrSW5mby5kYXRhID0gbmV3RGF0YTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJvY2Vzc29yL2RhdGFTdGFjay5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJvY2Vzc29yL2RhdGFTdGFjay5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIFNjYWxlID0gcmVxdWlyZShcIi4vU2NhbGVcIik7XG5cbnZhciBoZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBJbnRlcnZhbCBzY2FsZVxuICogQG1vZHVsZSBlY2hhcnRzL3NjYWxlL0ludGVydmFsXG4gKi9cbnZhciByb3VuZE51bWJlciA9IG51bWJlclV0aWwucm91bmQ7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9zY2FsZS9JbnRlcnZhbFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIEludGVydmFsU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuICB0eXBlOiAnaW50ZXJ2YWwnLFxuICBfaW50ZXJ2YWw6IDAsXG4gIF9pbnRlcnZhbFByZWNpc2lvbjogMixcbiAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciB0aGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50OyAvL3N0YXJ0LGVuZCBtYXkgYmUgYSBOdW1iZXIgbGlrZSAnMjUnLHNvLi4uXG5cbiAgICBpZiAoIWlzTmFOKHN0YXJ0KSkge1xuICAgICAgdGhpc0V4dGVudFswXSA9IHBhcnNlRmxvYXQoc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICghaXNOYU4oZW5kKSkge1xuICAgICAgdGhpc0V4dGVudFsxXSA9IHBhcnNlRmxvYXQoZW5kKTtcbiAgICB9XG4gIH0sXG4gIHVuaW9uRXh0ZW50OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIG90aGVyWzBdIDwgZXh0ZW50WzBdICYmIChleHRlbnRbMF0gPSBvdGhlclswXSk7XG4gICAgb3RoZXJbMV0gPiBleHRlbnRbMV0gJiYgKGV4dGVudFsxXSA9IG90aGVyWzFdKTsgLy8gdW5pb25FeHRlbnQgbWF5IGNhbGxlZCBieSBpdCdzIHN1YiBjbGFzc2VzXG5cbiAgICBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZS5zZXRFeHRlbnQuY2FsbCh0aGlzLCBleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBpbnRlcnZhbFxuICAgKi9cbiAgZ2V0SW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBpbnRlcnZhbFxuICAgKi9cbiAgc2V0SW50ZXJ2YWw6IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWw7IC8vIERyb3BwZWQgYXV0byBjYWxjdWxhdGVkIG5pY2VFeHRlbnQgYW5kIHVzZSB1c2VyIHNldHRlZCBleHRlbnRcbiAgICAvLyBXZSBhc3N1bWUgdXNlciB3YW4ndCB0byBzZXQgYm90aCBpbnRlcnZhbCwgbWluLCBtYXggdG8gZ2V0IGEgYmV0dGVyIHJlc3VsdFxuXG4gICAgdGhpcy5fbmljZUV4dGVudCA9IHRoaXMuX2V4dGVudC5zbGljZSgpO1xuICAgIHRoaXMuX2ludGVydmFsUHJlY2lzaW9uID0gaGVscGVyLmdldEludGVydmFsUHJlY2lzaW9uKGludGVydmFsKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBnZXRUaWNrczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoZWxwZXIuaW50ZXJ2YWxTY2FsZUdldFRpY2tzKHRoaXMuX2ludGVydmFsLCB0aGlzLl9leHRlbnQsIHRoaXMuX25pY2VFeHRlbnQsIHRoaXMuX2ludGVydmFsUHJlY2lzaW9uKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdC5wcmVjaXNpb25dIElmICdhdXRvJywgdXNlIG5pY2UgcHJlc2lzaW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQucGFkXSByZXR1cm5zIDEuNTAgYnV0IG5vdCAxLjUgaWYgcHJlY2lzaW9uIGlzIDIuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldExhYmVsOiBmdW5jdGlvbiAoZGF0YSwgb3B0KSB7XG4gICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBwcmVjaXNpb24gPSBvcHQgJiYgb3B0LnByZWNpc2lvbjtcblxuICAgIGlmIChwcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgcHJlY2lzaW9uID0gbnVtYmVyVXRpbC5nZXRQcmVjaXNpb25TYWZlKGRhdGEpIHx8IDA7XG4gICAgfSBlbHNlIGlmIChwcmVjaXNpb24gPT09ICdhdXRvJykge1xuICAgICAgLy8gU2hvdWxkIGJlIG1vcmUgcHJlY2lzZSB0aGVuIHRpY2suXG4gICAgICBwcmVjaXNpb24gPSB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbjtcbiAgICB9IC8vICgxKSBJZiBgcHJlY2lzaW9uYCBpcyBzZXQsIDEyLjAwNSBzaG91bGQgYmUgZGlzcGxheSBhcyAnMTIuMDA1MDAnLlxuICAgIC8vICgyKSBVc2Ugcm91bmROdW1iZXIgKHRvRml4ZWQpIHRvIGF2b2lkIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAnMy41ZS03Jy5cblxuXG4gICAgZGF0YSA9IHJvdW5kTnVtYmVyKGRhdGEsIHByZWNpc2lvbiwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZvcm1hdFV0aWwuYWRkQ29tbWFzKGRhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgaW50ZXJ2YWwgYW5kIGV4dGVudCBvZiBpbnRlcnZhbHMgZm9yIG5pY2UgdGlja3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzcGxpdE51bWJlciA9IDVdIERlc2lyZWQgbnVtYmVyIG9mIHRpY2tzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluSW50ZXJ2YWxdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4SW50ZXJ2YWxdXG4gICAqL1xuICBuaWNlVGlja3M6IGZ1bmN0aW9uIChzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwsIG1heEludGVydmFsKSB7XG4gICAgc3BsaXROdW1iZXIgPSBzcGxpdE51bWJlciB8fCA1O1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG5cbiAgICBpZiAoIWlzRmluaXRlKHNwYW4pKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBVc2VyIG1heSBzZXQgYXhpcyBtaW4gMCBhbmQgZGF0YSBhcmUgYWxsIG5lZ2F0aXZlXG4gICAgLy8gRklYTUUgSWYgaXQgbmVlZHMgdG8gcmV2ZXJzZSA/XG5cblxuICAgIGlmIChzcGFuIDwgMCkge1xuICAgICAgc3BhbiA9IC1zcGFuO1xuICAgICAgZXh0ZW50LnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gaGVscGVyLmludGVydmFsU2NhbGVOaWNlVGlja3MoZXh0ZW50LCBzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwsIG1heEludGVydmFsKTtcbiAgICB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbiA9IHJlc3VsdC5pbnRlcnZhbFByZWNpc2lvbjtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbDtcbiAgICB0aGlzLl9uaWNlRXh0ZW50ID0gcmVzdWx0Lm5pY2VUaWNrRXh0ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBOaWNlIGV4dGVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zcGxpdE51bWJlciA9IDVdIEdpdmVuIGFwcHJveCB0aWNrIG51bWJlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuZml4TWluPWZhbHNlXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuZml4TWF4PWZhbHNlXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQubWluSW50ZXJ2YWxdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5tYXhJbnRlcnZhbF1cbiAgICovXG4gIG5pY2VFeHRlbnQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50OyAvLyBJZiBleHRlbnQgc3RhcnQgYW5kIGVuZCBhcmUgc2FtZSwgZXhwYW5kIHRoZW1cblxuICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgaWYgKGV4dGVudFswXSAhPT0gMCkge1xuICAgICAgICAvLyBFeHBhbmQgZXh0ZW50XG4gICAgICAgIHZhciBleHBhbmRTaXplID0gZXh0ZW50WzBdOyAvLyBJbiB0aGUgZm93bGxvd2luZyBjYXNlXG4gICAgICAgIC8vICAgICAgQXhpcyBoYXMgYmVlbiBmaXhlZCBtYXggMTAwXG4gICAgICAgIC8vICAgICAgUGx1cyBkYXRhIGFyZSBhbGwgMTAwIGFuZCBheGlzIGV4dGVudCBhcmUgWzEwMCwgMTAwXS5cbiAgICAgICAgLy8gRXh0ZW5kIHRvIHRoZSBib3RoIHNpZGUgd2lsbCBjYXVzZSBleHBhbmRlZCBtYXggaXMgbGFyZ2VyIHRoYW4gZml4ZWQgbWF4LlxuICAgICAgICAvLyBTbyBvbmx5IGV4cGFuZCB0byB0aGUgc21hbGxlciBzaWRlLlxuXG4gICAgICAgIGlmICghb3B0LmZpeE1heCkge1xuICAgICAgICAgIGV4dGVudFsxXSArPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgICBleHRlbnRbMF0gLT0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0ZW50WzBdIC09IGV4cGFuZFNpemUgLyAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlbnRbMV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdOyAvLyBJZiB0aGVyZSBhcmUgbm8gZGF0YSBhbmQgZXh0ZW50IGFyZSBbSW5maW5pdHksIC1JbmZpbml0eV1cblxuICAgIGlmICghaXNGaW5pdGUoc3BhbikpIHtcbiAgICAgIGV4dGVudFswXSA9IDA7XG4gICAgICBleHRlbnRbMV0gPSAxO1xuICAgIH1cblxuICAgIHRoaXMubmljZVRpY2tzKG9wdC5zcGxpdE51bWJlciwgb3B0Lm1pbkludGVydmFsLCBvcHQubWF4SW50ZXJ2YWwpOyAvLyB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuXG4gICAgdmFyIGludGVydmFsID0gdGhpcy5faW50ZXJ2YWw7XG5cbiAgICBpZiAoIW9wdC5maXhNaW4pIHtcbiAgICAgIGV4dGVudFswXSA9IHJvdW5kTnVtYmVyKE1hdGguZmxvb3IoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIGlmICghb3B0LmZpeE1heCkge1xuICAgICAgZXh0ZW50WzFdID0gcm91bmROdW1iZXIoTWF0aC5jZWlsKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICB9XG4gIH1cbn0pO1xuLyoqXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lfVxuICovXG5cbkludGVydmFsU2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IEludGVydmFsU2NhbGUoKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IEludGVydmFsU2NhbGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL0ludGVydmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9JbnRlcnZhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgU2NhbGUgPSByZXF1aXJlKFwiLi9TY2FsZVwiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBJbnRlcnZhbFNjYWxlID0gcmVxdWlyZShcIi4vSW50ZXJ2YWxcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBMb2cgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9Mb2dcbiAqL1xuLy8gVXNlIHNvbWUgbWV0aG9kIG9mIEludGVydmFsU2NhbGVcbnZhciBzY2FsZVByb3RvID0gU2NhbGUucHJvdG90eXBlO1xudmFyIGludGVydmFsU2NhbGVQcm90byA9IEludGVydmFsU2NhbGUucHJvdG90eXBlO1xudmFyIGdldFByZWNpc2lvblNhZmUgPSBudW1iZXJVdGlsLmdldFByZWNpc2lvblNhZmU7XG52YXIgcm91bmRpbmdFcnJvckZpeCA9IG51bWJlclV0aWwucm91bmQ7XG52YXIgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBtYXRoQ2VpbCA9IE1hdGguY2VpbDtcbnZhciBtYXRoUG93ID0gTWF0aC5wb3c7XG52YXIgbWF0aExvZyA9IE1hdGgubG9nO1xudmFyIExvZ1NjYWxlID0gU2NhbGUuZXh0ZW5kKHtcbiAgdHlwZTogJ2xvZycsXG4gIGJhc2U6IDEwLFxuICAkY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICBTY2FsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuX29yaWdpbmFsU2NhbGUgPSBuZXcgSW50ZXJ2YWxTY2FsZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGdldFRpY2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yaWdpbmFsU2NhbGUgPSB0aGlzLl9vcmlnaW5hbFNjYWxlO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gb3JpZ2luYWxTY2FsZS5nZXRFeHRlbnQoKTtcbiAgICByZXR1cm4genJVdGlsLm1hcChpbnRlcnZhbFNjYWxlUHJvdG8uZ2V0VGlja3MuY2FsbCh0aGlzKSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdmFyIHBvd1ZhbCA9IG51bWJlclV0aWwucm91bmQobWF0aFBvdyh0aGlzLmJhc2UsIHZhbCkpOyAvLyBGaXggIzQxNThcblxuICAgICAgcG93VmFsID0gdmFsID09PSBleHRlbnRbMF0gJiYgb3JpZ2luYWxTY2FsZS5fX2ZpeE1pbiA/IGZpeFJvdW5kaW5nRXJyb3IocG93VmFsLCBvcmlnaW5hbEV4dGVudFswXSkgOiBwb3dWYWw7XG4gICAgICBwb3dWYWwgPSB2YWwgPT09IGV4dGVudFsxXSAmJiBvcmlnaW5hbFNjYWxlLl9fZml4TWF4ID8gZml4Um91bmRpbmdFcnJvcihwb3dWYWwsIG9yaWdpbmFsRXh0ZW50WzFdKSA6IHBvd1ZhbDtcbiAgICAgIHJldHVybiBwb3dWYWw7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0TGFiZWw6IGludGVydmFsU2NhbGVQcm90by5nZXRMYWJlbCxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgc2NhbGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSBzY2FsZVByb3RvLnNjYWxlLmNhbGwodGhpcywgdmFsKTtcbiAgICByZXR1cm4gbWF0aFBvdyh0aGlzLmJhc2UsIHZhbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAqL1xuICBzZXRFeHRlbnQ6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgc3RhcnQgPSBtYXRoTG9nKHN0YXJ0KSAvIG1hdGhMb2coYmFzZSk7XG4gICAgZW5kID0gbWF0aExvZyhlbmQpIC8gbWF0aExvZyhiYXNlKTtcbiAgICBpbnRlcnZhbFNjYWxlUHJvdG8uc2V0RXh0ZW50LmNhbGwodGhpcywgc3RhcnQsIGVuZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gZW5kXG4gICAqL1xuICBnZXRFeHRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmFzZSA9IHRoaXMuYmFzZTtcbiAgICB2YXIgZXh0ZW50ID0gc2NhbGVQcm90by5nZXRFeHRlbnQuY2FsbCh0aGlzKTtcbiAgICBleHRlbnRbMF0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFswXSk7XG4gICAgZXh0ZW50WzFdID0gbWF0aFBvdyhiYXNlLCBleHRlbnRbMV0pOyAvLyBGaXggIzQxNThcblxuICAgIHZhciBvcmlnaW5hbFNjYWxlID0gdGhpcy5fb3JpZ2luYWxTY2FsZTtcbiAgICB2YXIgb3JpZ2luYWxFeHRlbnQgPSBvcmlnaW5hbFNjYWxlLmdldEV4dGVudCgpO1xuICAgIG9yaWdpbmFsU2NhbGUuX19maXhNaW4gJiYgKGV4dGVudFswXSA9IGZpeFJvdW5kaW5nRXJyb3IoZXh0ZW50WzBdLCBvcmlnaW5hbEV4dGVudFswXSkpO1xuICAgIG9yaWdpbmFsU2NhbGUuX19maXhNYXggJiYgKGV4dGVudFsxXSA9IGZpeFJvdW5kaW5nRXJyb3IoZXh0ZW50WzFdLCBvcmlnaW5hbEV4dGVudFsxXSkpO1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRlbnRcbiAgICovXG4gIHVuaW9uRXh0ZW50OiBmdW5jdGlvbiAoZXh0ZW50KSB7XG4gICAgdGhpcy5fb3JpZ2luYWxTY2FsZS51bmlvbkV4dGVudChleHRlbnQpO1xuXG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgZXh0ZW50WzBdID0gbWF0aExvZyhleHRlbnRbMF0pIC8gbWF0aExvZyhiYXNlKTtcbiAgICBleHRlbnRbMV0gPSBtYXRoTG9nKGV4dGVudFsxXSkgLyBtYXRoTG9nKGJhc2UpO1xuICAgIHNjYWxlUHJvdG8udW5pb25FeHRlbnQuY2FsbCh0aGlzLCBleHRlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHVuaW9uRXh0ZW50RnJvbURhdGE6IGZ1bmN0aW9uIChkYXRhLCBkaW0pIHtcbiAgICAvLyBUT0RPXG4gICAgLy8gZmlsdGVyIHZhbHVlIHRoYXQgPD0gMFxuICAgIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXRBcHByb3hpbWF0ZUV4dGVudChkaW0pKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGludGVydmFsIGFuZCBleHRlbnQgb2YgaW50ZXJ2YWxzIGZvciBuaWNlIHRpY2tzXG4gICAqIEBwYXJhbSAge251bWJlcn0gW2FwcHJveFRpY2tOdW0gPSAxMF0gR2l2ZW4gYXBwcm94IHRpY2sgbnVtYmVyXG4gICAqL1xuICBuaWNlVGlja3M6IGZ1bmN0aW9uIChhcHByb3hUaWNrTnVtKSB7XG4gICAgYXBwcm94VGlja051bSA9IGFwcHJveFRpY2tOdW0gfHwgMTA7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcblxuICAgIGlmIChzcGFuID09PSBJbmZpbml0eSB8fCBzcGFuIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJ2YWwgPSBudW1iZXJVdGlsLnF1YW50aXR5KHNwYW4pO1xuICAgIHZhciBlcnIgPSBhcHByb3hUaWNrTnVtIC8gc3BhbiAqIGludGVydmFsOyAvLyBGaWx0ZXIgdGlja3MgdG8gZ2V0IGNsb3NlciB0byB0aGUgZGVzaXJlZCBjb3VudC5cblxuICAgIGlmIChlcnIgPD0gMC41KSB7XG4gICAgICBpbnRlcnZhbCAqPSAxMDtcbiAgICB9IC8vIEludGVydmFsIHNob3VsZCBiZSBpbnRlZ2VyXG5cblxuICAgIHdoaWxlICghaXNOYU4oaW50ZXJ2YWwpICYmIE1hdGguYWJzKGludGVydmFsKSA8IDEgJiYgTWF0aC5hYnMoaW50ZXJ2YWwpID4gMCkge1xuICAgICAgaW50ZXJ2YWwgKj0gMTA7XG4gICAgfVxuXG4gICAgdmFyIG5pY2VFeHRlbnQgPSBbbnVtYmVyVXRpbC5yb3VuZChtYXRoQ2VpbChleHRlbnRbMF0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCksIG51bWJlclV0aWwucm91bmQobWF0aEZsb29yKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsKV07XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICB0aGlzLl9uaWNlRXh0ZW50ID0gbmljZUV4dGVudDtcbiAgfSxcblxuICAvKipcbiAgICogTmljZSBleHRlbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbmljZUV4dGVudDogZnVuY3Rpb24gKG9wdCkge1xuICAgIGludGVydmFsU2NhbGVQcm90by5uaWNlRXh0ZW50LmNhbGwodGhpcywgb3B0KTtcbiAgICB2YXIgb3JpZ2luYWxTY2FsZSA9IHRoaXMuX29yaWdpbmFsU2NhbGU7XG4gICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1pbiA9IG9wdC5maXhNaW47XG4gICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1heCA9IG9wdC5maXhNYXg7XG4gIH1cbn0pO1xuenJVdGlsLmVhY2goWydjb250YWluJywgJ25vcm1hbGl6ZSddLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBMb2dTY2FsZS5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gbWF0aExvZyh2YWwpIC8gbWF0aExvZyh0aGlzLmJhc2UpO1xuICAgIHJldHVybiBzY2FsZVByb3RvW21ldGhvZE5hbWVdLmNhbGwodGhpcywgdmFsKTtcbiAgfTtcbn0pO1xuXG5Mb2dTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgTG9nU2NhbGUoKTtcbn07XG5cbmZ1bmN0aW9uIGZpeFJvdW5kaW5nRXJyb3IodmFsLCBvcmlnaW5hbFZhbCkge1xuICByZXR1cm4gcm91bmRpbmdFcnJvckZpeCh2YWwsIGdldFByZWNpc2lvblNhZmUob3JpZ2luYWxWYWwpKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gTG9nU2NhbGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL0xvZy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvTG9nLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBTY2FsZSA9IHJlcXVpcmUoXCIuL1NjYWxlXCIpO1xuXG52YXIgT3JkaW5hbE1ldGEgPSByZXF1aXJlKFwiLi4vZGF0YS9PcmRpbmFsTWV0YVwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIExpbmVhciBjb250aW51b3VzIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvY29vcmQvc2NhbGUvT3JkaW5hbFxuICpcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV2ZWxfb2ZfbWVhc3VyZW1lbnRcbiAqL1xuLy8gRklYTUUgb25seSBvbmUgZGF0YVxudmFyIHNjYWxlUHJvdG8gPSBTY2FsZS5wcm90b3R5cGU7XG52YXIgT3JkaW5hbFNjYWxlID0gU2NhbGUuZXh0ZW5kKHtcbiAgdHlwZTogJ29yZGluYWwnLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvT3JkaWFubE1ldGF8QXJyYXkuPHN0cmluZz59IG9yZGluYWxNZXRhXG4gICAqL1xuICBpbml0OiBmdW5jdGlvbiAob3JkaW5hbE1ldGEsIGV4dGVudCkge1xuICAgIC8vIENhdXRpb246IFNob3VsZCBub3QgdXNlIGluc3RhbmNlb2YsIGNvbnNpZGVyIGVjLWV4dGVuc2lvbnMgdXNpbmdcbiAgICAvLyBpbXBvcnQgYXBwcm9hY2ggdG8gZ2V0IE9yZGluYWxNZXRhIGNsYXNzLlxuICAgIGlmICghb3JkaW5hbE1ldGEgfHwgenJVdGlsLmlzQXJyYXkob3JkaW5hbE1ldGEpKSB7XG4gICAgICBvcmRpbmFsTWV0YSA9IG5ldyBPcmRpbmFsTWV0YSh7XG4gICAgICAgIGNhdGVnb3JpZXM6IG9yZGluYWxNZXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9vcmRpbmFsTWV0YSA9IG9yZGluYWxNZXRhO1xuICAgIHRoaXMuX2V4dGVudCA9IGV4dGVudCB8fCBbMCwgb3JkaW5hbE1ldGEuY2F0ZWdvcmllcy5sZW5ndGggLSAxXTtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyB0aGlzLl9vcmRpbmFsTWV0YS5nZXRPcmRpbmFsKHZhbCkgLy8gdmFsIG1pZ2h0IGJlIGZsb2F0LlxuICAgIDogTWF0aC5yb3VuZCh2YWwpO1xuICB9LFxuICBjb250YWluOiBmdW5jdGlvbiAocmFuaykge1xuICAgIHJhbmsgPSB0aGlzLnBhcnNlKHJhbmspO1xuICAgIHJldHVybiBzY2FsZVByb3RvLmNvbnRhaW4uY2FsbCh0aGlzLCByYW5rKSAmJiB0aGlzLl9vcmRpbmFsTWV0YS5jYXRlZ29yaWVzW3JhbmtdICE9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBnaXZlbiByYW5rIG9yIG5hbWUgdG8gbGluZWFyIFswLCAxXVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFt2YWxdXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBzY2FsZVByb3RvLm5vcm1hbGl6ZS5jYWxsKHRoaXMsIHRoaXMucGFyc2UodmFsKSk7XG4gIH0sXG4gIHNjYWxlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoc2NhbGVQcm90by5zY2FsZS5jYWxsKHRoaXMsIHZhbCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldFRpY2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpY2tzID0gW107XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgcmFuayA9IGV4dGVudFswXTtcblxuICAgIHdoaWxlIChyYW5rIDw9IGV4dGVudFsxXSkge1xuICAgICAgdGlja3MucHVzaChyYW5rKTtcbiAgICAgIHJhbmsrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBpdGVtIG9uIHJhbmsgblxuICAgKiBAcGFyYW0ge251bWJlcn0gblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRMYWJlbDogZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAoIXRoaXMuaXNCbGFuaygpKSB7XG4gICAgICAvLyBOb3RlIHRoYXQgaWYgbm8gZGF0YSwgb3JkaW5hbE1ldGEuY2F0ZWdvcmllcyBpcyBhbiBlbXB0eSBhcnJheS5cbiAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsTWV0YS5jYXRlZ29yaWVzW25dO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0ZW50WzFdIC0gdGhpcy5fZXh0ZW50WzBdICsgMTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB1bmlvbkV4dGVudEZyb21EYXRhOiBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gICAgdGhpcy51bmlvbkV4dGVudChkYXRhLmdldEFwcHJveGltYXRlRXh0ZW50KGRpbSkpO1xuICB9LFxuICBnZXRPcmRpbmFsTWV0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsTWV0YTtcbiAgfSxcbiAgbmljZVRpY2tzOiB6clV0aWwubm9vcCxcbiAgbmljZUV4dGVudDogenJVdGlsLm5vb3Bcbn0pO1xuLyoqXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lfVxuICovXG5cbk9yZGluYWxTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgT3JkaW5hbFNjYWxlKCk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBPcmRpbmFsU2NhbGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY2xhenpVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY2xhenpcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiAvLyBTY2FsZSBjbGFzcyBtYW5hZ2VtZW50XG4gKiBAbW9kdWxlIGVjaGFydHMvc2NhbGUvU2NhbGVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2V0dGluZ11cbiAqL1xuZnVuY3Rpb24gU2NhbGUoc2V0dGluZykge1xuICB0aGlzLl9zZXR0aW5nID0gc2V0dGluZyB8fCB7fTtcbiAgLyoqXG4gICAqIEV4dGVudFxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgdGhpcy5fZXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAvKipcbiAgICogU3RlcCBpcyBjYWxjdWxhdGVkIGluIGFkanVzdEV4dGVudFxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgdGhpcy5faW50ZXJ2YWwgPSAwO1xuICB0aGlzLmluaXQgJiYgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFBhcnNlIGlucHV0IHZhbCB0byB2YWxpZCBpbm5lciBudW1iZXIuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHZhbCkge1xuICAvLyBOb3RpY2U6IFRoaXMgd291bGQgYmUgYSB0cmFwIGhlcmUsIElmIHRoZSBpbXBsZW1lbnRhdGlvblxuICAvLyBvZiB0aGlzIG1ldGhvZCBkZXBlbmRzIG9uIGV4dGVudCwgYW5kIHRoaXMgbWV0aG9kIGlzIHVzZWRcbiAgLy8gYmVmb3JlIGV4dGVudCBzZXQgKGxpa2UgaW4gZGF0YVpvb20pLCBpdCB3b3VsZCBiZSB3cm9uZy5cbiAgLy8gTmV2ZXJ0aGVsZXNzLCBwYXJzZSBkb2VzIG5vdCBkZXBlbmQgb24gZXh0ZW50IGdlbmVyYWxseS5cbiAgcmV0dXJuIHZhbDtcbn07XG5cblNjYWxlLnByb3RvdHlwZS5nZXRTZXR0aW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX3NldHRpbmdbbmFtZV07XG59O1xuXG5TY2FsZS5wcm90b3R5cGUuY29udGFpbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgcmV0dXJuIHZhbCA+PSBleHRlbnRbMF0gJiYgdmFsIDw9IGV4dGVudFsxXTtcbn07XG4vKipcbiAqIE5vcm1hbGl6ZSB2YWx1ZSB0byBsaW5lYXIgWzAsIDFdLCByZXR1cm4gMC41IGlmIGV4dGVudCBzcGFuIGlzIDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG5cbiAgaWYgKGV4dGVudFsxXSA9PT0gZXh0ZW50WzBdKSB7XG4gICAgcmV0dXJuIDAuNTtcbiAgfVxuXG4gIHJldHVybiAodmFsIC0gZXh0ZW50WzBdKSAvIChleHRlbnRbMV0gLSBleHRlbnRbMF0pO1xufTtcbi8qKlxuICogU2NhbGUgbm9ybWFsaXplZCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHZhbCkge1xuICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICByZXR1cm4gdmFsICogKGV4dGVudFsxXSAtIGV4dGVudFswXSkgKyBleHRlbnRbMF07XG59O1xuLyoqXG4gKiBTZXQgZXh0ZW50IGZyb20gZGF0YVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3RoZXJcbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS51bmlvbkV4dGVudCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICBvdGhlclsxXSA+IGV4dGVudFsxXSAmJiAoZXh0ZW50WzFdID0gb3RoZXJbMV0pOyAvLyBub3Qgc2V0RXh0ZW50IGJlY2F1c2UgaW4gbG9nIGF4aXMgaXQgbWF5IHRyYW5zZm9ybWVkIHRvIHBvd2VyXG4gIC8vIHRoaXMuc2V0RXh0ZW50KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbn07XG4vKipcbiAqIFNldCBleHRlbnQgZnJvbSBkYXRhXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLnVuaW9uRXh0ZW50RnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXRBcHByb3hpbWF0ZUV4dGVudChkaW0pKTtcbn07XG4vKipcbiAqIEdldCBleHRlbnRcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2V4dGVudC5zbGljZSgpO1xufTtcbi8qKlxuICogU2V0IGV4dGVudFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKi9cblxuXG5TY2FsZS5wcm90b3R5cGUuc2V0RXh0ZW50ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRoaXNFeHRlbnQgPSB0aGlzLl9leHRlbnQ7XG5cbiAgaWYgKCFpc05hTihzdGFydCkpIHtcbiAgICB0aGlzRXh0ZW50WzBdID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoIWlzTmFOKGVuZCkpIHtcbiAgICB0aGlzRXh0ZW50WzFdID0gZW5kO1xuICB9XG59O1xuLyoqXG4gKiBXaGVuIGF4aXMgZXh0ZW50IGRlcGVuZHMgb24gZGF0YSBhbmQgbm8gZGF0YSBleGlzdHMsXG4gKiBheGlzIHRpY2tzIHNob3VsZCBub3QgYmUgZHJhd24sIHdoaWNoIGlzIG5hbWVkICdibGFuaycuXG4gKi9cblxuXG5TY2FsZS5wcm90b3R5cGUuaXNCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzQmxhbms7XG59LFxuLyoqXG4gKiBXaGVuIGF4aXMgZXh0ZW50IGRlcGVuZHMgb24gZGF0YSBhbmQgbm8gZGF0YSBleGlzdHMsXG4gKiBheGlzIHRpY2tzIHNob3VsZCBub3QgYmUgZHJhd24sIHdoaWNoIGlzIG5hbWVkICdibGFuaycuXG4gKi9cblNjYWxlLnByb3RvdHlwZS5zZXRCbGFuayA9IGZ1bmN0aW9uIChpc0JsYW5rKSB7XG4gIHRoaXMuX2lzQmxhbmsgPSBpc0JsYW5rO1xufTtcbi8qKlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0geyp9IHRpY2tcbiAqIEByZXR1cm4ge3N0cmluZ30gbGFiZWwgb2YgdGhlIHRpY2suXG4gKi9cblxuU2NhbGUucHJvdG90eXBlLmdldExhYmVsID0gbnVsbDtcbmNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChTY2FsZSk7XG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KFNjYWxlLCB7XG4gIHJlZ2lzdGVyV2hlbkV4dGVuZDogdHJ1ZVxufSk7XG52YXIgX2RlZmF1bHQgPSBTY2FsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvU2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL1NjYWxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIHNjYWxlSGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuXG52YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoXCIuL0ludGVydmFsXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBbQWJvdXQgVVRDIGFuZCBsb2NhbCB0aW1lIHpvbmVdOlxuLy8gSW4gbW9zdCBjYXNlcywgYG51bWJlci5wYXJzZURhdGVgIHdpbGwgdHJlYXQgaW5wdXQgZGF0YSBzdHJpbmcgYXMgbG9jYWwgdGltZVxuLy8gKGV4Y2VwdCB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkIGluIHRpbWUgc3RyaW5nKS4gQW5kIGBmb3JtYXQuZm9ybWF0ZVRpbWVgIHJldHVybnNcbi8vIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC4gb3B0aW9uLnVzZVVUQyBpcyBmYWxzZSBieSBkZWZhdWx0LiBUaGlzIGRlc2lnbiBoYXZlXG4vLyBjb25jaWRlcmVkIHRoZXNlIGNvbW1vbiBjYXNlOlxuLy8gKDEpIFRpbWUgdGhhdCBpcyBwZXJzaXN0ZW50IGluIHNlcnZlciBpcyBpbiBVVEMsIGJ1dCBpdCBpcyBuZWVkZWQgdG8gYmUgZGlwbGF5ZWRcbi8vIGluIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC5cbi8vICgyKSBCeSBkZWZhdWx0LCB0aGUgaW5wdXQgZGF0YSBzdHJpbmcgKGUuZy4sICcyMDExLTAxLTAyJykgc2hvdWxkIGJlIGRpc3BsYXllZFxuLy8gYXMgaXRzIG9yaWdpbmFsIHRpbWUsIHdpdGhvdXQgYW55IHRpbWUgZGlmZmVyZW5jZS5cbnZhciBpbnRlcnZhbFNjYWxlUHJvdG8gPSBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZTtcbnZhciBtYXRoQ2VpbCA9IE1hdGguY2VpbDtcbnZhciBtYXRoRmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIE9ORV9TRUNPTkQgPSAxMDAwO1xudmFyIE9ORV9NSU5VVEUgPSBPTkVfU0VDT05EICogNjA7XG52YXIgT05FX0hPVVIgPSBPTkVfTUlOVVRFICogNjA7XG52YXIgT05FX0RBWSA9IE9ORV9IT1VSICogMjQ7IC8vIEZJWE1FIOWFrOeUqO+8n1xuXG52YXIgYmlzZWN0ID0gZnVuY3Rpb24gKGEsIHgsIGxvLCBoaSkge1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuXG4gICAgaWYgKGFbbWlkXVsxXSA8IHgpIHtcbiAgICAgIGxvID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvO1xufTtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlL1RpbWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFRpbWVTY2FsZSA9IEludGVydmFsU2NhbGUuZXh0ZW5kKHtcbiAgdHlwZTogJ3RpbWUnLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldExhYmVsOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIHN0ZXBMdmwgPSB0aGlzLl9zdGVwTHZsO1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUodmFsKTtcbiAgICByZXR1cm4gZm9ybWF0VXRpbC5mb3JtYXRUaW1lKHN0ZXBMdmxbMF0sIGRhdGUsIHRoaXMuZ2V0U2V0dGluZygndXNlVVRDJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG5pY2VFeHRlbnQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50OyAvLyBJZiBleHRlbnQgc3RhcnQgYW5kIGVuZCBhcmUgc2FtZSwgZXhwYW5kIHRoZW1cblxuICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgLy8gRXhwYW5kIGV4dGVudFxuICAgICAgZXh0ZW50WzBdIC09IE9ORV9EQVk7XG4gICAgICBleHRlbnRbMV0gKz0gT05FX0RBWTtcbiAgICB9IC8vIElmIHRoZXJlIGFyZSBubyBkYXRhIGFuZCBleHRlbnQgYXJlIFtJbmZpbml0eSwgLUluZmluaXR5XVxuXG5cbiAgICBpZiAoZXh0ZW50WzFdID09PSAtSW5maW5pdHkgJiYgZXh0ZW50WzBdID09PSBJbmZpbml0eSkge1xuICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgZXh0ZW50WzFdID0gK25ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG4gICAgICBleHRlbnRbMF0gPSBleHRlbnRbMV0gLSBPTkVfREFZO1xuICAgIH1cblxuICAgIHRoaXMubmljZVRpY2tzKG9wdC5zcGxpdE51bWJlciwgb3B0Lm1pbkludGVydmFsLCBvcHQubWF4SW50ZXJ2YWwpOyAvLyB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuXG4gICAgdmFyIGludGVydmFsID0gdGhpcy5faW50ZXJ2YWw7XG5cbiAgICBpZiAoIW9wdC5maXhNaW4pIHtcbiAgICAgIGV4dGVudFswXSA9IG51bWJlclV0aWwucm91bmQobWF0aEZsb29yKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdC5maXhNYXgpIHtcbiAgICAgIGV4dGVudFsxXSA9IG51bWJlclV0aWwucm91bmQobWF0aENlaWwoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBuaWNlVGlja3M6IGZ1bmN0aW9uIChhcHByb3hUaWNrTnVtLCBtaW5JbnRlcnZhbCwgbWF4SW50ZXJ2YWwpIHtcbiAgICBhcHByb3hUaWNrTnVtID0gYXBwcm94VGlja051bSB8fCAxMDtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgIHZhciBhcHByb3hJbnRlcnZhbCA9IHNwYW4gLyBhcHByb3hUaWNrTnVtO1xuXG4gICAgaWYgKG1pbkludGVydmFsICE9IG51bGwgJiYgYXBwcm94SW50ZXJ2YWwgPCBtaW5JbnRlcnZhbCkge1xuICAgICAgYXBwcm94SW50ZXJ2YWwgPSBtaW5JbnRlcnZhbDtcbiAgICB9XG5cbiAgICBpZiAobWF4SW50ZXJ2YWwgIT0gbnVsbCAmJiBhcHByb3hJbnRlcnZhbCA+IG1heEludGVydmFsKSB7XG4gICAgICBhcHByb3hJbnRlcnZhbCA9IG1heEludGVydmFsO1xuICAgIH1cblxuICAgIHZhciBzY2FsZUxldmVsc0xlbiA9IHNjYWxlTGV2ZWxzLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gYmlzZWN0KHNjYWxlTGV2ZWxzLCBhcHByb3hJbnRlcnZhbCwgMCwgc2NhbGVMZXZlbHNMZW4pO1xuICAgIHZhciBsZXZlbCA9IHNjYWxlTGV2ZWxzW01hdGgubWluKGlkeCwgc2NhbGVMZXZlbHNMZW4gLSAxKV07XG4gICAgdmFyIGludGVydmFsID0gbGV2ZWxbMV07IC8vIFNhbWUgd2l0aCBpbnRlcnZhbCBzY2FsZSBpZiBzcGFuIGlzIG11Y2ggbGFyZ2VyIHRoYW4gMSB5ZWFyXG5cbiAgICBpZiAobGV2ZWxbMF0gPT09ICd5ZWFyJykge1xuICAgICAgdmFyIHllYXJTcGFuID0gc3BhbiAvIGludGVydmFsOyAvLyBGcm9tIFwiTmljZSBOdW1iZXJzIGZvciBHcmFwaCBMYWJlbHNcIiBvZiBHcmFwaGljIEdlbXNcbiAgICAgIC8vIHZhciBuaWNlWWVhclNwYW4gPSBudW1iZXJVdGlsLm5pY2UoeWVhclNwYW4sIGZhbHNlKTtcblxuICAgICAgdmFyIHllYXJTdGVwID0gbnVtYmVyVXRpbC5uaWNlKHllYXJTcGFuIC8gYXBwcm94VGlja051bSwgdHJ1ZSk7XG4gICAgICBpbnRlcnZhbCAqPSB5ZWFyU3RlcDtcbiAgICB9XG5cbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSB0aGlzLmdldFNldHRpbmcoJ3VzZVVUQycpID8gMCA6IG5ldyBEYXRlKCtleHRlbnRbMF0gfHwgK2V4dGVudFsxXSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMDtcbiAgICB2YXIgbmljZUV4dGVudCA9IFtNYXRoLnJvdW5kKG1hdGhDZWlsKChleHRlbnRbMF0gLSB0aW1lem9uZU9mZnNldCkgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCArIHRpbWV6b25lT2Zmc2V0KSwgTWF0aC5yb3VuZChtYXRoRmxvb3IoKGV4dGVudFsxXSAtIHRpbWV6b25lT2Zmc2V0KSAvIGludGVydmFsKSAqIGludGVydmFsICsgdGltZXpvbmVPZmZzZXQpXTtcbiAgICBzY2FsZUhlbHBlci5maXhFeHRlbnQobmljZUV4dGVudCwgZXh0ZW50KTtcbiAgICB0aGlzLl9zdGVwTHZsID0gbGV2ZWw7IC8vIEludGVydmFsIHdpbGwgYmUgdXNlZCBpbiBnZXRUaWNrc1xuXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICB0aGlzLl9uaWNlRXh0ZW50ID0gbmljZUV4dGVudDtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyB2YWwgbWlnaHQgYmUgZmxvYXQuXG4gICAgcmV0dXJuICtudW1iZXJVdGlsLnBhcnNlRGF0ZSh2YWwpO1xuICB9XG59KTtcbnpyVXRpbC5lYWNoKFsnY29udGFpbicsICdub3JtYWxpemUnXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgVGltZVNjYWxlLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gaW50ZXJ2YWxTY2FsZVByb3RvW21ldGhvZE5hbWVdLmNhbGwodGhpcywgdGhpcy5wYXJzZSh2YWwpKTtcbiAgfTtcbn0pOyAvLyBTdGVwcyBmcm9tIGQzXG5cbnZhciBzY2FsZUxldmVscyA9IFsvLyBGb3JtYXQgICAgICAgICAgICAgIGludGVydmFsXG5bJ2hoOm1tOnNzJywgT05FX1NFQ09ORF0sIC8vIDFzXG5bJ2hoOm1tOnNzJywgT05FX1NFQ09ORCAqIDVdLCAvLyA1c1xuWydoaDptbTpzcycsIE9ORV9TRUNPTkQgKiAxMF0sIC8vIDEwc1xuWydoaDptbTpzcycsIE9ORV9TRUNPTkQgKiAxNV0sIC8vIDE1c1xuWydoaDptbTpzcycsIE9ORV9TRUNPTkQgKiAzMF0sIC8vIDMwc1xuWydoaDptbVxcbk1NLWRkJywgT05FX01JTlVURV0sIC8vIDFtXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfTUlOVVRFICogNV0sIC8vIDVtXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfTUlOVVRFICogMTBdLCAvLyAxMG1cblsnaGg6bW1cXG5NTS1kZCcsIE9ORV9NSU5VVEUgKiAxNV0sIC8vIDE1bVxuWydoaDptbVxcbk1NLWRkJywgT05FX01JTlVURSAqIDMwXSwgLy8gMzBtXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfSE9VUl0sIC8vIDFoXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfSE9VUiAqIDJdLCAvLyAyaFxuWydoaDptbVxcbk1NLWRkJywgT05FX0hPVVIgKiA2XSwgLy8gNmhcblsnaGg6bW1cXG5NTS1kZCcsIE9ORV9IT1VSICogMTJdLCAvLyAxMmhcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWV0sIC8vIDFkXG5bJ01NLWRkXFxueXl5eScsIE9ORV9EQVkgKiAyXSwgLy8gMmRcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWSAqIDNdLCAvLyAzZFxuWydNTS1kZFxcbnl5eXknLCBPTkVfREFZICogNF0sIC8vIDRkXG5bJ01NLWRkXFxueXl5eScsIE9ORV9EQVkgKiA1XSwgLy8gNWRcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWSAqIDZdLCAvLyA2ZFxuWyd3ZWVrJywgT05FX0RBWSAqIDddLCAvLyA3ZFxuWydNTS1kZFxcbnl5eXknLCBPTkVfREFZICogMTBdLCAvLyAxMGRcblsnd2VlaycsIE9ORV9EQVkgKiAxNF0sIC8vIDJ3XG5bJ3dlZWsnLCBPTkVfREFZICogMjFdLCAvLyAzd1xuWydtb250aCcsIE9ORV9EQVkgKiAzMV0sIC8vIDFNXG5bJ3dlZWsnLCBPTkVfREFZICogNDJdLCAvLyA2d1xuWydtb250aCcsIE9ORV9EQVkgKiA2Ml0sIC8vIDJNXG5bJ3dlZWsnLCBPTkVfREFZICogNDJdLCAvLyAxMHdcblsncXVhcnRlcicsIE9ORV9EQVkgKiAzODAgLyA0XSwgLy8gM01cblsnbW9udGgnLCBPTkVfREFZICogMzEgKiA0XSwgLy8gNE1cblsnbW9udGgnLCBPTkVfREFZICogMzEgKiA1XSwgLy8gNU1cblsnaGFsZi15ZWFyJywgT05FX0RBWSAqIDM4MCAvIDJdLCAvLyA2TVxuWydtb250aCcsIE9ORV9EQVkgKiAzMSAqIDhdLCAvLyA4TVxuWydtb250aCcsIE9ORV9EQVkgKiAzMSAqIDEwXSwgLy8gMTBNXG5bJ3llYXInLCBPTkVfREFZICogMzgwXSAvLyAxWVxuXTtcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWV9XG4gKi9cblxuVGltZVNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICByZXR1cm4gbmV3IFRpbWVTY2FsZSh7XG4gICAgdXNlVVRDOiBtb2RlbC5lY01vZGVsLmdldCgndXNlVVRDJylcbiAgfSk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBUaW1lU2NhbGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL1RpbWUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL1RpbWUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL251bWJlclwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEZvciB0ZXN0YWJsZS5cbiAqL1xudmFyIHJvdW5kTnVtYmVyID0gbnVtYmVyVXRpbC5yb3VuZDtcbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZXh0ZW50IEJvdGggZXh0ZW50WzBdIGFuZCBleHRlbnRbMV0gc2hvdWxkIGJlIHZhbGlkIG51bWJlci5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaG91bGQgYmUgZXh0ZW50WzBdIDwgZXh0ZW50WzFdLlxuICogQHBhcmFtIHtudW1iZXJ9IHNwbGl0TnVtYmVyIHNwbGl0TnVtYmVyIHNob3VsZCBiZSA+PSAxLlxuICogQHBhcmFtIHtudW1iZXJ9IFttaW5JbnRlcnZhbF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4SW50ZXJ2YWxdXG4gKiBAcmV0dXJuIHtPYmplY3R9IHtpbnRlcnZhbCwgaW50ZXJ2YWxQcmVjaXNpb24sIG5pY2VUaWNrRXh0ZW50fVxuICovXG5cbmZ1bmN0aW9uIGludGVydmFsU2NhbGVOaWNlVGlja3MoZXh0ZW50LCBzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwsIG1heEludGVydmFsKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gIHZhciBpbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbCA9IG51bWJlclV0aWwubmljZShzcGFuIC8gc3BsaXROdW1iZXIsIHRydWUpO1xuXG4gIGlmIChtaW5JbnRlcnZhbCAhPSBudWxsICYmIGludGVydmFsIDwgbWluSW50ZXJ2YWwpIHtcbiAgICBpbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbCA9IG1pbkludGVydmFsO1xuICB9XG5cbiAgaWYgKG1heEludGVydmFsICE9IG51bGwgJiYgaW50ZXJ2YWwgPiBtYXhJbnRlcnZhbCkge1xuICAgIGludGVydmFsID0gcmVzdWx0LmludGVydmFsID0gbWF4SW50ZXJ2YWw7XG4gIH0gLy8gVG93IG1vcmUgZGlnaXRhbCBmb3IgdGljay5cblxuXG4gIHZhciBwcmVjaXNpb24gPSByZXN1bHQuaW50ZXJ2YWxQcmVjaXNpb24gPSBnZXRJbnRlcnZhbFByZWNpc2lvbihpbnRlcnZhbCk7IC8vIE5pY2VkIGV4dGVudCBpbnNpZGUgb3JpZ2luYWwgZXh0ZW50XG5cbiAgdmFyIG5pY2VUaWNrRXh0ZW50ID0gcmVzdWx0Lm5pY2VUaWNrRXh0ZW50ID0gW3JvdW5kTnVtYmVyKE1hdGguY2VpbChleHRlbnRbMF0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCwgcHJlY2lzaW9uKSwgcm91bmROdW1iZXIoTWF0aC5mbG9vcihleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCwgcHJlY2lzaW9uKV07XG4gIGZpeEV4dGVudChuaWNlVGlja0V4dGVudCwgZXh0ZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGludGVydmFsIHByZWNpc2lvblxuICovXG5cblxuZnVuY3Rpb24gZ2V0SW50ZXJ2YWxQcmVjaXNpb24oaW50ZXJ2YWwpIHtcbiAgLy8gVG93IG1vcmUgZGlnaXRhbCBmb3IgdGljay5cbiAgcmV0dXJuIG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZShpbnRlcnZhbCkgKyAyO1xufVxuXG5mdW5jdGlvbiBjbGFtcChuaWNlVGlja0V4dGVudCwgaWR4LCBleHRlbnQpIHtcbiAgbmljZVRpY2tFeHRlbnRbaWR4XSA9IE1hdGgubWF4KE1hdGgubWluKG5pY2VUaWNrRXh0ZW50W2lkeF0sIGV4dGVudFsxXSksIGV4dGVudFswXSk7XG59IC8vIEluIHNvbWUgY2FzZXMgKGUuZy4sIHNwbGl0TnVtYmVyIGlzIDEpLCBuaWNlVGlja0V4dGVudCBtYXkgYmUgb3V0IG9mIGV4dGVudC5cblxuXG5mdW5jdGlvbiBmaXhFeHRlbnQobmljZVRpY2tFeHRlbnQsIGV4dGVudCkge1xuICAhaXNGaW5pdGUobmljZVRpY2tFeHRlbnRbMF0pICYmIChuaWNlVGlja0V4dGVudFswXSA9IGV4dGVudFswXSk7XG4gICFpc0Zpbml0ZShuaWNlVGlja0V4dGVudFsxXSkgJiYgKG5pY2VUaWNrRXh0ZW50WzFdID0gZXh0ZW50WzFdKTtcbiAgY2xhbXAobmljZVRpY2tFeHRlbnQsIDAsIGV4dGVudCk7XG4gIGNsYW1wKG5pY2VUaWNrRXh0ZW50LCAxLCBleHRlbnQpO1xuXG4gIGlmIChuaWNlVGlja0V4dGVudFswXSA+IG5pY2VUaWNrRXh0ZW50WzFdKSB7XG4gICAgbmljZVRpY2tFeHRlbnRbMF0gPSBuaWNlVGlja0V4dGVudFsxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnZhbFNjYWxlR2V0VGlja3MoaW50ZXJ2YWwsIGV4dGVudCwgbmljZVRpY2tFeHRlbnQsIGludGVydmFsUHJlY2lzaW9uKSB7XG4gIHZhciB0aWNrcyA9IFtdOyAvLyBJZiBpbnRlcnZhbCBpcyAwLCByZXR1cm4gW107XG5cbiAgaWYgKCFpbnRlcnZhbCkge1xuICAgIHJldHVybiB0aWNrcztcbiAgfSAvLyBDb25zaWRlciB0aGlzIGNhc2U6IHVzaW5nIGRhdGFab29tIHRvb2xib3gsIHpvb20gYW5kIHpvb20uXG5cblxuICB2YXIgc2FmZUxpbWl0ID0gMTAwMDA7XG5cbiAgaWYgKGV4dGVudFswXSA8IG5pY2VUaWNrRXh0ZW50WzBdKSB7XG4gICAgdGlja3MucHVzaChleHRlbnRbMF0pO1xuICB9XG5cbiAgdmFyIHRpY2sgPSBuaWNlVGlja0V4dGVudFswXTtcblxuICB3aGlsZSAodGljayA8PSBuaWNlVGlja0V4dGVudFsxXSkge1xuICAgIHRpY2tzLnB1c2godGljayk7IC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yXG5cbiAgICB0aWNrID0gcm91bmROdW1iZXIodGljayArIGludGVydmFsLCBpbnRlcnZhbFByZWNpc2lvbik7XG5cbiAgICBpZiAodGljayA9PT0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0pIHtcbiAgICAgIC8vIENvbnNpZGVyIG91dCBvZiBzYWZlIGZsb2F0IHBvaW50LCBlLmcuLFxuICAgICAgLy8gLTM3MTExMjYuOTkwNzcwNyArIDJlLTEwID09PSAtMzcxMTEyNi45OTA3NzA3XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGlja3MubGVuZ3RoID4gc2FmZUxpbWl0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9IC8vIENvbnNpZGVyIHRoaXMgY2FzZTogdGhlIGxhc3QgaXRlbSBvZiB0aWNrcyBpcyBzbWFsbGVyXG4gIC8vIHRoYW4gbmljZVRpY2tFeHRlbnRbMV0gYW5kIG5pY2VUaWNrRXh0ZW50WzFdID09PSBleHRlbnRbMV0uXG5cblxuICBpZiAoZXh0ZW50WzFdID4gKHRpY2tzLmxlbmd0aCA/IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdIDogbmljZVRpY2tFeHRlbnRbMV0pKSB7XG4gICAgdGlja3MucHVzaChleHRlbnRbMV0pO1xuICB9XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnRzLmludGVydmFsU2NhbGVOaWNlVGlja3MgPSBpbnRlcnZhbFNjYWxlTmljZVRpY2tzO1xuZXhwb3J0cy5nZXRJbnRlcnZhbFByZWNpc2lvbiA9IGdldEludGVydmFsUHJlY2lzaW9uO1xuZXhwb3J0cy5maXhFeHRlbnQgPSBmaXhFeHRlbnQ7XG5leHBvcnRzLmludGVydmFsU2NhbGVHZXRUaWNrcyA9IGludGVydmFsU2NhbGVHZXRUaWNrcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9oZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL2hlbHBlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcbnZhciBtYXAgPSBfdXRpbC5tYXA7XG52YXIgaXNBcnJheSA9IF91dGlsLmlzQXJyYXk7XG52YXIgaXNGdW5jdGlvbiA9IF91dGlsLmlzRnVuY3Rpb247XG52YXIgY3JlYXRlSGFzaE1hcCA9IF91dGlsLmNyZWF0ZUhhc2hNYXA7XG52YXIgbm9vcCA9IF91dGlsLm5vb3A7XG5cbnZhciBfdGFzayA9IHJlcXVpcmUoXCIuL3Rhc2tcIik7XG5cbnZhciBjcmVhdGVUYXNrID0gX3Rhc2suY3JlYXRlVGFzaztcblxudmFyIF9jb21wb25lbnQgPSByZXF1aXJlKFwiLi4vdXRpbC9jb21wb25lbnRcIik7XG5cbnZhciBnZXRVSUQgPSBfY29tcG9uZW50LmdldFVJRDtcblxudmFyIEdsb2JhbE1vZGVsID0gcmVxdWlyZShcIi4uL21vZGVsL0dsb2JhbFwiKTtcblxudmFyIEV4dGVuc2lvbkFQSSA9IHJlcXVpcmUoXCIuLi9FeHRlbnNpb25BUElcIik7XG5cbnZhciBfbW9kZWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIG5vcm1hbGl6ZVRvQXJyYXkgPSBfbW9kZWwubm9ybWFsaXplVG9BcnJheTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zdHJlYW0vU2NoZWR1bGVyXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU2NoZWR1bGVyKGVjSW5zdGFuY2UsIGFwaSwgZGF0YVByb2Nlc3NvckhhbmRsZXJzLCB2aXN1YWxIYW5kbGVycykge1xuICB0aGlzLmVjSW5zdGFuY2UgPSBlY0luc3RhbmNlO1xuICB0aGlzLmFwaSA9IGFwaTtcbiAgdGhpcy51bmZpbmlzaGVkOyAvLyBGaXggY3VycmVudCBwcm9jZXNzb3JzIGluIGNhc2UgdGhhdCBpbiBzb21lIHJlYXIgY2FzZXMgdGhhdFxuICAvLyBwcm9jZXNzb3JzIG1pZ2h0IGJlIHJlZ2lzdGVyZWQgYWZ0ZXIgZWNoYXJ0cyBpbnN0YW5jZSBjcmVhdGVkLlxuICAvLyBSZWdpc3RlciBwcm9jZXNzb3JzIGluY3JlbWVudGFsbHkgZm9yIGEgZWNoYXJ0cyBpbnN0YW5jZSBpc1xuICAvLyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgc3RyZWFtIGFyY2hpdGVjdHVyZS5cblxuICB2YXIgZGF0YVByb2Nlc3NvckhhbmRsZXJzID0gdGhpcy5fZGF0YVByb2Nlc3NvckhhbmRsZXJzID0gZGF0YVByb2Nlc3NvckhhbmRsZXJzLnNsaWNlKCk7XG4gIHZhciB2aXN1YWxIYW5kbGVycyA9IHRoaXMuX3Zpc3VhbEhhbmRsZXJzID0gdmlzdWFsSGFuZGxlcnMuc2xpY2UoKTtcbiAgdGhpcy5fYWxsSGFuZGxlcnMgPSBkYXRhUHJvY2Vzc29ySGFuZGxlcnMuY29uY2F0KHZpc3VhbEhhbmRsZXJzKTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtcbiAgICogICAgIFtoYW5kbGVyVUlEOiBzdHJpbmddOiB7XG4gICAqICAgICAgICAgc2VyaWVzVGFza01hcD86IHtcbiAgICogICAgICAgICAgICAgW3Nlcmllc1VJRDogc3RyaW5nXTogVGFza1xuICAgKiAgICAgICAgIH0sXG4gICAqICAgICAgICAgb3ZlcmFsbFRhc2s/OiBUYXNrXG4gICAqICAgICB9XG4gICAqIH1cbiAgICovXG5cbiAgdGhpcy5fc3RhZ2VUYXNrTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xufVxuXG52YXIgcHJvdG8gPSBTY2hlZHVsZXIucHJvdG90eXBlO1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqL1xuXG5wcm90by5yZXN0b3JlRGF0YSA9IGZ1bmN0aW9uIChlY01vZGVsLCBwYXlsb2FkKSB7XG4gIC8vIFRPRE86IE9ubHkgcmVzdHJvZSBuZWVkZWQgc2VyaWVzIGFuZCBjb21wb25lbnRzLCBidXQgbm90IGFsbCBjb21wb25lbnRzLlxuICAvLyBDdXJyZW50bHkgYHJlc3RvcmVEYXRhYCBvZiBhbGwgb2YgdGhlIHNlcmllcyBhbmQgY29tcG9uZW50IHdpbGwgYmUgY2FsbGVkLlxuICAvLyBCdXQgc29tZSBpbmRlcGVuZGVudCBjb21wb25lbnRzIGxpa2UgYHRpdGxlYCwgYGxlZ2VuZGAsIGBncmFwaGljYCwgYHRvb2xib3hgLFxuICAvLyBgdG9vbHRpcGAsIGBheGlzUG9pbnRlcmAsIGV0YywgZG8gbm90IG5lZWQgc2VyaWVzIHJlZnJlc2ggd2hlbiBgc2V0T3B0aW9uYCxcbiAgLy8gYW5kIHNvbWUgY29tcG9uZW50cyBsaWtlIGNvb3JkaW5hdGUgc3lzdGVtLCBheGVzLCBkYXRhWm9vbSwgdmlzdWFsTWFwIG9ubHlcbiAgLy8gbmVlZCB0aGVpciB0YXJnZXQgc2VyaWVzIHJlZnJlc2guXG4gIC8vICgxKSBJZiB3ZSBhcmUgaW1wbGVtZW50aW5nIHRoaXMgZmVhdHVyZSBzb21lIGRheSwgd2Ugc2hvdWxkIGNvbnNpZGVyIHRoZXNlIGNhc2VzOlxuICAvLyBpZiBhIGRhdGEgcHJvY2Vzc29yIGRlcGVuZHMgb24gYSBjb21wb25lbnQgKGUuZy4sIGRhdGFab29tUHJvY2Vzc29yIGRlcGVuZHNcbiAgLy8gb24gdGhlIHNldHRpbmdzIG9mIGBkYXRhWm9vbWApLCBpdCBzaG91bGQgYmUgcmUtcGVyZm9ybWVkIGlmIHRoZSBjb21wb25lbnRcbiAgLy8gaXMgbW9kaWZpZWQgYnkgYHNldE9wdGlvbmAuXG4gIC8vICgyKSBJZiBhIHByb2Nlc3NvciBkZXBlbmRzIG9uIHNldnJhbCBzZXJpZXMsIHNwZWljaWZpZWQgYnkgaXRzIGBnZXRUYXJnZXRTZXJpZXNgLFxuICAvLyBpdCBzaG91bGQgYmUgcmUtcGVyZm9ybWVkIHdoZW4gdGhlIHJlc3VsdCBhcnJheSBvZiBgZ2V0VGFyZ2V0U2VyaWVzYCBjaGFuZ2VkLlxuICAvLyBXZSB1c2UgYGRlcGVuZGVuY2llc2AgdG8gY292ZXIgdGhlc2UgaXNzdWVzLlxuICAvLyAoMykgSG93IHRvIHVwZGF0ZSB0YXJnZXQgc2VyaWVzIHdoZW4gY29vcmRpbmF0ZSBzeXN0ZW0gcmVsYXRlZCBjb21wb25lbnRzIG1vZGlmaWVkLlxuICAvLyBUT0RPOiBzaW1wbHkgdGhlIGRpcnR5IG1lY2hhbmlzbT8gQ2hlY2sgd2hldGhlciBvbmx5IHRoZSBjYXNlIGhlcmUgY2FuIHNldCB0YXNrcyBkaXJ0eSxcbiAgLy8gYW5kIHRoaXMgY2FzZSBhbGwgb2YgdGhlIHRhc2tzIHdpbGwgYmUgc2V0IGFzIGRpcnR5LlxuICBlY01vZGVsLnJlc3RvcmVEYXRhKHBheWxvYWQpOyAvLyBUaGVvcmV0aWNhbGx5IGFuIG92ZXJhbGwgdGFzayBub3Qgb25seSBkZXBlbmRzIG9uIGVhY2ggb2YgaXRzIHRhcmdldCBzZXJpZXMsIGJ1dCBhbHNvXG4gIC8vIGRlcGVuZHMgb24gYWxsIG9mIHRoZSBzZXJpZXMuXG4gIC8vIFRoZSBvdmVyYWxsIHRhc2sgaXMgbm90IGluIHBpcGVsaW5lLCBhbmQgYGVjTW9kZWwucmVzdG9yZURhdGFgIG9ubHkgc2V0IHBpcGVsaW5lIHRhc2tzXG4gIC8vIGRpcnR5LiBJZiBgZ2V0VGFyZ2V0U2VyaWVzYCBvZiBhbiBvdmVyYWxsIHRhc2sgcmV0dXJucyBub3RoaW5nLCB3ZSBzaG91bGQgYWxzbyBlbnN1cmVcbiAgLy8gdGhhdCB0aGUgb3ZlcmFsbCB0YXNrIGlzIHNldCBhcyBkaXJ0eSBhbmQgdG8gYmUgcGVyZm9ybWVkLCBvdGhlcndpc2UgaXQgcHJvYmFibHkgY2F1c2VcbiAgLy8gc3RhdGUgY2hhb3MuIFNvIHdlIGhhdmUgdG8gc2V0IGRpcnR5IG9mIGFsbCBvZiB0aGUgb3ZlcmFsbCB0YXNrcyBtYW51YWxseSwgb3RoZXJ3aXNlIGl0XG4gIC8vIHByb2JhYmx5IGNhdXNlIHN0YXRlIGNoYW9zIChjb25zaWRlciBgZGF0YVpvb21Qcm9jZXNzb3JgKS5cblxuICB0aGlzLl9zdGFnZVRhc2tNYXAuZWFjaChmdW5jdGlvbiAodGFza1JlY29yZCkge1xuICAgIHZhciBvdmVyYWxsVGFzayA9IHRhc2tSZWNvcmQub3ZlcmFsbFRhc2s7XG4gICAgb3ZlcmFsbFRhc2sgJiYgb3ZlcmFsbFRhc2suZGlydHkoKTtcbiAgfSk7XG59OyAvLyBJZiBzZXJpZXNNb2RlbCBwcm92aWRlZCwgaW5jcmVtZW50YWwgdGhyZXNob2xkIGlzIGNoZWNrIGJ5IHNlcmllcyBkYXRhLlxuXG5cbnByb3RvLmdldFBlcmZvcm1BcmdzID0gZnVuY3Rpb24gKHRhc2ssIGlzQmxvY2spIHtcbiAgLy8gRm9yIG92ZXJhbGwgdGFza1xuICBpZiAoIXRhc2suX19waXBlbGluZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwaXBlbGluZSA9IHRoaXMuX3BpcGVsaW5lTWFwLmdldCh0YXNrLl9fcGlwZWxpbmUuaWQpO1xuXG4gIHZhciBwQ3R4ID0gcGlwZWxpbmUuY29udGV4dDtcbiAgdmFyIGluY3JlbWVudGFsID0gIWlzQmxvY2sgJiYgcGlwZWxpbmUucHJvZ3Jlc3NpdmVFbmFibGVkICYmICghcEN0eCB8fCBwQ3R4LnByb2dyZXNzaXZlUmVuZGVyKSAmJiB0YXNrLl9faWR4SW5QaXBlbGluZSA+IHBpcGVsaW5lLmJsb2NrSW5kZXg7XG4gIHZhciBzdGVwID0gaW5jcmVtZW50YWwgPyBwaXBlbGluZS5zdGVwIDogbnVsbDtcbiAgdmFyIG1vZERhdGFDb3VudCA9IHBDdHggJiYgcEN0eC5tb2REYXRhQ291bnQ7XG4gIHZhciBtb2RCeSA9IG1vZERhdGFDb3VudCAhPSBudWxsID8gTWF0aC5jZWlsKG1vZERhdGFDb3VudCAvIHN0ZXApIDogbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBzdGVwOiBzdGVwLFxuICAgIG1vZEJ5OiBtb2RCeSxcbiAgICBtb2REYXRhQ291bnQ6IG1vZERhdGFDb3VudFxuICB9O1xufTtcblxucHJvdG8uZ2V0UGlwZWxpbmUgPSBmdW5jdGlvbiAocGlwZWxpbmVJZCkge1xuICByZXR1cm4gdGhpcy5fcGlwZWxpbmVNYXAuZ2V0KHBpcGVsaW5lSWQpO1xufTtcbi8qKlxuICogQ3VycmVudCwgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIHN0YXJ0cyBmcm9tIHZpc3VhbCBhbmQgbGF5b3V0LlxuICogQWx3YXlzIGRldGVjdCByZW5kZXIgbW9kZSBpbiB0aGUgc2FtZSBzdGFnZSwgYXZvaWRpbmcgdGhhdCBpbmNvcnJlY3RcbiAqIGRldGVjdGlvbiBjYXVzZWQgYnkgZGF0YSBmaWx0ZXJpbmcuXG4gKiBDYXV0aW9uOlxuICogYHVwZGF0ZVN0cmVhbU1vZGVzYCB1c2UgYHNlcmllc01vZGVsLmdldERhdGEoKWAuXG4gKi9cblxuXG5wcm90by51cGRhdGVTdHJlYW1Nb2RlcyA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgdmlldykge1xuICB2YXIgcGlwZWxpbmUgPSB0aGlzLl9waXBlbGluZU1hcC5nZXQoc2VyaWVzTW9kZWwudWlkKTtcblxuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGRhdGFMZW4gPSBkYXRhLmNvdW50KCk7IC8vIGBwcm9ncmVzc2l2ZVJlbmRlcmAgbWVhbnMgdGhhdCBjYW4gcmVuZGVyIHByb2dyZXNzaXZlbHkgaW4gZWFjaFxuICAvLyBhbmltYXRpb24gZnJhbWUuIE5vdGUgdGhhdCBzb21lIHR5cGVzIG9mIHNlcmllcyBkbyBub3QgcHJvdmlkZVxuICAvLyBgdmlldy5pbmNyZW1lbnRhbFByZXBhcmVSZW5kZXJgIGJ1dCBzdXBwb3J0IGBjaGFydC5hcHBlbmREYXRhYC4gV2VcbiAgLy8gdXNlIHRoZSB0ZXJtIGBpbmNyZW1lbnRhbGAgYnV0IG5vdCBgcHJvZ3Jlc3NpdmVgIHRvIGRlc2NyaWJlIHRoZVxuICAvLyBjYXNlIHRoYXQgYGNoYXJ0LmFwcGVuZERhdGFgLlxuXG4gIHZhciBwcm9ncmVzc2l2ZVJlbmRlciA9IHBpcGVsaW5lLnByb2dyZXNzaXZlRW5hYmxlZCAmJiB2aWV3LmluY3JlbWVudGFsUHJlcGFyZVJlbmRlciAmJiBkYXRhTGVuID49IHBpcGVsaW5lLnRocmVzaG9sZDtcbiAgdmFyIGxhcmdlID0gc2VyaWVzTW9kZWwuZ2V0KCdsYXJnZScpICYmIGRhdGFMZW4gPj0gc2VyaWVzTW9kZWwuZ2V0KCdsYXJnZVRocmVzaG9sZCcpOyAvLyBUT0RPOiBtb2REYXRhQ291bnQgc2hvdWxkIG5vdCB1cGRhdGVkIGlmIGBhcHBlbmREYXRhYCwgb3RoZXJ3aXNlIGNhdXNlIHdob2xlIHJlcGFpbnQuXG4gIC8vIHNlZSBgdGVzdC9jYW5kbGVzdGljay1sYXJnZTMuaHRtbGBcblxuICB2YXIgbW9kRGF0YUNvdW50ID0gc2VyaWVzTW9kZWwuZ2V0KCdwcm9ncmVzc2l2ZUNodW5rTW9kZScpID09PSAnbW9kJyA/IGRhdGFMZW4gOiBudWxsO1xuICBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQgPSBwaXBlbGluZS5jb250ZXh0ID0ge1xuICAgIHByb2dyZXNzaXZlUmVuZGVyOiBwcm9ncmVzc2l2ZVJlbmRlcixcbiAgICBtb2REYXRhQ291bnQ6IG1vZERhdGFDb3VudCxcbiAgICBsYXJnZTogbGFyZ2VcbiAgfTtcbn07XG5cbnByb3RvLnJlc3RvcmVQaXBlbGluZXMgPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICB2YXIgc2NoZWR1bGVyID0gdGhpcztcbiAgdmFyIHBpcGVsaW5lTWFwID0gc2NoZWR1bGVyLl9waXBlbGluZU1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBwcm9ncmVzc2l2ZSA9IHNlcmllc01vZGVsLmdldFByb2dyZXNzaXZlKCk7XG4gICAgdmFyIHBpcGVsaW5lSWQgPSBzZXJpZXNNb2RlbC51aWQ7XG4gICAgcGlwZWxpbmVNYXAuc2V0KHBpcGVsaW5lSWQsIHtcbiAgICAgIGlkOiBwaXBlbGluZUlkLFxuICAgICAgaGVhZDogbnVsbCxcbiAgICAgIHRhaWw6IG51bGwsXG4gICAgICB0aHJlc2hvbGQ6IHNlcmllc01vZGVsLmdldFByb2dyZXNzaXZlVGhyZXNob2xkKCksXG4gICAgICBwcm9ncmVzc2l2ZUVuYWJsZWQ6IHByb2dyZXNzaXZlICYmICEoc2VyaWVzTW9kZWwucHJldmVudEluY3JlbWVudGFsICYmIHNlcmllc01vZGVsLnByZXZlbnRJbmNyZW1lbnRhbCgpKSxcbiAgICAgIGJsb2NrSW5kZXg6IC0xLFxuICAgICAgc3RlcDogTWF0aC5yb3VuZChwcm9ncmVzc2l2ZSB8fCA3MDApLFxuICAgICAgY291bnQ6IDBcbiAgICB9KTtcbiAgICBwaXBlKHNjaGVkdWxlciwgc2VyaWVzTW9kZWwsIHNlcmllc01vZGVsLmRhdGFUYXNrKTtcbiAgfSk7XG59O1xuXG5wcm90by5wcmVwYXJlU3RhZ2VUYXNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YWdlVGFza01hcCA9IHRoaXMuX3N0YWdlVGFza01hcDtcbiAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjSW5zdGFuY2UuZ2V0TW9kZWwoKTtcbiAgdmFyIGFwaSA9IHRoaXMuYXBpO1xuICBlYWNoKHRoaXMuX2FsbEhhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHZhciByZWNvcmQgPSBzdGFnZVRhc2tNYXAuZ2V0KGhhbmRsZXIudWlkKSB8fCBzdGFnZVRhc2tNYXAuc2V0KGhhbmRsZXIudWlkLCBbXSk7XG4gICAgaGFuZGxlci5yZXNldCAmJiBjcmVhdGVTZXJpZXNTdGFnZVRhc2sodGhpcywgaGFuZGxlciwgcmVjb3JkLCBlY01vZGVsLCBhcGkpO1xuICAgIGhhbmRsZXIub3ZlcmFsbFJlc2V0ICYmIGNyZWF0ZU92ZXJhbGxTdGFnZVRhc2sodGhpcywgaGFuZGxlciwgcmVjb3JkLCBlY01vZGVsLCBhcGkpO1xuICB9LCB0aGlzKTtcbn07XG5cbnByb3RvLnByZXBhcmVWaWV3ID0gZnVuY3Rpb24gKHZpZXcsIG1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgdmFyIHJlbmRlclRhc2sgPSB2aWV3LnJlbmRlclRhc2s7XG4gIHZhciBjb250ZXh0ID0gcmVuZGVyVGFzay5jb250ZXh0O1xuICBjb250ZXh0Lm1vZGVsID0gbW9kZWw7XG4gIGNvbnRleHQuZWNNb2RlbCA9IGVjTW9kZWw7XG4gIGNvbnRleHQuYXBpID0gYXBpO1xuICByZW5kZXJUYXNrLl9fYmxvY2sgPSAhdmlldy5pbmNyZW1lbnRhbFByZXBhcmVSZW5kZXI7XG4gIHBpcGUodGhpcywgbW9kZWwsIHJlbmRlclRhc2spO1xufTtcblxucHJvdG8ucGVyZm9ybURhdGFQcm9jZXNzb3JUYXNrcyA9IGZ1bmN0aW9uIChlY01vZGVsLCBwYXlsb2FkKSB7XG4gIC8vIElmIHdlIGRvIG5vdCB1c2UgYGJsb2NrYCBoZXJlLCBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCB3aGVuIHRvIHVwZGF0ZSBtb2Rlcy5cbiAgcGVyZm9ybVN0YWdlVGFza3ModGhpcywgdGhpcy5fZGF0YVByb2Nlc3NvckhhbmRsZXJzLCBlY01vZGVsLCBwYXlsb2FkLCB7XG4gICAgYmxvY2s6IHRydWVcbiAgfSk7XG59OyAvLyBvcHRcbi8vIG9wdC52aXN1YWxUeXBlOiAndmlzdWFsJyBvciAnbGF5b3V0J1xuLy8gb3B0LnNldERpcnR5XG5cblxucHJvdG8ucGVyZm9ybVZpc3VhbFRhc2tzID0gZnVuY3Rpb24gKGVjTW9kZWwsIHBheWxvYWQsIG9wdCkge1xuICBwZXJmb3JtU3RhZ2VUYXNrcyh0aGlzLCB0aGlzLl92aXN1YWxIYW5kbGVycywgZWNNb2RlbCwgcGF5bG9hZCwgb3B0KTtcbn07XG5cbmZ1bmN0aW9uIHBlcmZvcm1TdGFnZVRhc2tzKHNjaGVkdWxlciwgc3RhZ2VIYW5kbGVycywgZWNNb2RlbCwgcGF5bG9hZCwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIHVuZmluaXNoZWQ7XG4gIGVhY2goc3RhZ2VIYW5kbGVycywgZnVuY3Rpb24gKHN0YWdlSGFuZGxlciwgaWR4KSB7XG4gICAgaWYgKG9wdC52aXN1YWxUeXBlICYmIG9wdC52aXN1YWxUeXBlICE9PSBzdGFnZUhhbmRsZXIudmlzdWFsVHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGFnZUhhbmRsZXJSZWNvcmQgPSBzY2hlZHVsZXIuX3N0YWdlVGFza01hcC5nZXQoc3RhZ2VIYW5kbGVyLnVpZCk7XG5cbiAgICB2YXIgc2VyaWVzVGFza01hcCA9IHN0YWdlSGFuZGxlclJlY29yZC5zZXJpZXNUYXNrTWFwO1xuICAgIHZhciBvdmVyYWxsVGFzayA9IHN0YWdlSGFuZGxlclJlY29yZC5vdmVyYWxsVGFzaztcblxuICAgIGlmIChvdmVyYWxsVGFzaykge1xuICAgICAgdmFyIG92ZXJhbGxOZWVkRGlydHk7XG4gICAgICB2YXIgYWdlbnRTdHViTWFwID0gb3ZlcmFsbFRhc2suYWdlbnRTdHViTWFwO1xuICAgICAgYWdlbnRTdHViTWFwLmVhY2goZnVuY3Rpb24gKHN0dWIpIHtcbiAgICAgICAgaWYgKG5lZWRTZXREaXJ0eShvcHQsIHN0dWIpKSB7XG4gICAgICAgICAgc3R1Yi5kaXJ0eSgpO1xuICAgICAgICAgIG92ZXJhbGxOZWVkRGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG92ZXJhbGxOZWVkRGlydHkgJiYgb3ZlcmFsbFRhc2suZGlydHkoKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQob3ZlcmFsbFRhc2ssIHBheWxvYWQpO1xuICAgICAgdmFyIHBlcmZvcm1BcmdzID0gc2NoZWR1bGVyLmdldFBlcmZvcm1BcmdzKG92ZXJhbGxUYXNrLCBvcHQuYmxvY2spOyAvLyBFeGVjdXRlIHN0dWJzIGZpcnN0bHksIHdoaWNoIG1heSBzZXQgdGhlIG92ZXJhbGwgdGFzayBkaXJ0eSxcbiAgICAgIC8vIHRoZW4gZXhlY3V0ZSB0aGUgb3ZlcmFsbCB0YXNrLiBBbmQgc3R1YiB3aWxsIGNhbGwgc2VyaWVzTW9kZWwuc2V0RGF0YSxcbiAgICAgIC8vIHdoaWNoIGVuc3VyZXMgdGhhdCBpbiB0aGUgb3ZlcmFsbFRhc2sgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpIHdpbGwgbm90XG4gICAgICAvLyByZXR1cm4gaW5jb3JyZWN0IGRhdGEuXG5cbiAgICAgIGFnZW50U3R1Yk1hcC5lYWNoKGZ1bmN0aW9uIChzdHViKSB7XG4gICAgICAgIHN0dWIucGVyZm9ybShwZXJmb3JtQXJncyk7XG4gICAgICB9KTtcbiAgICAgIHVuZmluaXNoZWQgfD0gb3ZlcmFsbFRhc2sucGVyZm9ybShwZXJmb3JtQXJncyk7XG4gICAgfSBlbHNlIGlmIChzZXJpZXNUYXNrTWFwKSB7XG4gICAgICBzZXJpZXNUYXNrTWFwLmVhY2goZnVuY3Rpb24gKHRhc2ssIHBpcGVsaW5lSWQpIHtcbiAgICAgICAgaWYgKG5lZWRTZXREaXJ0eShvcHQsIHRhc2spKSB7XG4gICAgICAgICAgdGFzay5kaXJ0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBlcmZvcm1BcmdzID0gc2NoZWR1bGVyLmdldFBlcmZvcm1BcmdzKHRhc2ssIG9wdC5ibG9jayk7XG4gICAgICAgIHBlcmZvcm1BcmdzLnNraXAgPSAhc3RhZ2VIYW5kbGVyLnBlcmZvcm1SYXdTZXJpZXMgJiYgZWNNb2RlbC5pc1Nlcmllc0ZpbHRlcmVkKHRhc2suY29udGV4dC5tb2RlbCk7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQodGFzaywgcGF5bG9hZCk7XG4gICAgICAgIHVuZmluaXNoZWQgfD0gdGFzay5wZXJmb3JtKHBlcmZvcm1BcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gbmVlZFNldERpcnR5KG9wdCwgdGFzaykge1xuICAgIHJldHVybiBvcHQuc2V0RGlydHkgJiYgKCFvcHQuZGlydHlNYXAgfHwgb3B0LmRpcnR5TWFwLmdldCh0YXNrLl9fcGlwZWxpbmUuaWQpKTtcbiAgfVxuXG4gIHNjaGVkdWxlci51bmZpbmlzaGVkIHw9IHVuZmluaXNoZWQ7XG59XG5cbnByb3RvLnBlcmZvcm1TZXJpZXNUYXNrcyA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gIHZhciB1bmZpbmlzaGVkO1xuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgLy8gUHJvZ3Jlc3MgdG8gdGhlIGVuZCBmb3IgZGF0YUluaXQgYW5kIGRhdGFSZXN0b3JlLlxuICAgIHVuZmluaXNoZWQgfD0gc2VyaWVzTW9kZWwuZGF0YVRhc2sucGVyZm9ybSgpO1xuICB9KTtcbiAgdGhpcy51bmZpbmlzaGVkIHw9IHVuZmluaXNoZWQ7XG59O1xuXG5wcm90by5wbGFuID0gZnVuY3Rpb24gKCkge1xuICAvLyBUcmF2ZWwgcGlwZWxpbmVzLCBjaGVjayBibG9jay5cbiAgdGhpcy5fcGlwZWxpbmVNYXAuZWFjaChmdW5jdGlvbiAocGlwZWxpbmUpIHtcbiAgICB2YXIgdGFzayA9IHBpcGVsaW5lLnRhaWw7XG5cbiAgICBkbyB7XG4gICAgICBpZiAodGFzay5fX2Jsb2NrKSB7XG4gICAgICAgIHBpcGVsaW5lLmJsb2NrSW5kZXggPSB0YXNrLl9faWR4SW5QaXBlbGluZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRhc2sgPSB0YXNrLmdldFVwc3RyZWFtKCk7XG4gICAgfSB3aGlsZSAodGFzayk7XG4gIH0pO1xufTtcblxudmFyIHVwZGF0ZVBheWxvYWQgPSBwcm90by51cGRhdGVQYXlsb2FkID0gZnVuY3Rpb24gKHRhc2ssIHBheWxvYWQpIHtcbiAgcGF5bG9hZCAhPT0gJ3JlbWFpbicgJiYgKHRhc2suY29udGV4dC5wYXlsb2FkID0gcGF5bG9hZCk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTZXJpZXNTdGFnZVRhc2soc2NoZWR1bGVyLCBzdGFnZUhhbmRsZXIsIHN0YWdlSGFuZGxlclJlY29yZCwgZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBzZXJpZXNUYXNrTWFwID0gc3RhZ2VIYW5kbGVyUmVjb3JkLnNlcmllc1Rhc2tNYXAgfHwgKHN0YWdlSGFuZGxlclJlY29yZC5zZXJpZXNUYXNrTWFwID0gY3JlYXRlSGFzaE1hcCgpKTtcbiAgdmFyIHNlcmllc1R5cGUgPSBzdGFnZUhhbmRsZXIuc2VyaWVzVHlwZTtcbiAgdmFyIGdldFRhcmdldFNlcmllcyA9IHN0YWdlSGFuZGxlci5nZXRUYXJnZXRTZXJpZXM7IC8vIElmIGEgc3RhZ2VIYW5kbGVyIHNob3VsZCBjb3ZlciBhbGwgc2VyaWVzLCBgY3JlYXRlT25BbGxTZXJpZXNgIHNob3VsZCBiZSBkZWNsYXJlZCBtYW5kYXRvcmlseSxcbiAgLy8gdG8gYXZvaWQgc29tZSB0eXBvIG9yIGFidXNlLiBPdGhlcndpc2UgaWYgYW4gZXh0ZW5zaW9uIGRvIG5vdCBzcGVjaWZ5IGEgYHNlcmllc1R5cGVgLFxuICAvLyBpdCB3b3JrcyBidXQgaXQgbWF5IGNhdXNlIG90aGVyIGlycmVsZXZhbnQgY2hhcnRzIGJsb2NrZWQuXG5cbiAgaWYgKHN0YWdlSGFuZGxlci5jcmVhdGVPbkFsbFNlcmllcykge1xuICAgIGVjTW9kZWwuZWFjaFJhd1NlcmllcyhjcmVhdGUpO1xuICB9IGVsc2UgaWYgKHNlcmllc1R5cGUpIHtcbiAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgY3JlYXRlKTtcbiAgfSBlbHNlIGlmIChnZXRUYXJnZXRTZXJpZXMpIHtcbiAgICBnZXRUYXJnZXRTZXJpZXMoZWNNb2RlbCwgYXBpKS5lYWNoKGNyZWF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGUoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgcGlwZWxpbmVJZCA9IHNlcmllc01vZGVsLnVpZDsgLy8gSW5pdCB0YXNrcyBmb3IgZWFjaCBzZXJpZXNNb2RlbCBvbmx5IG9uY2UuXG4gICAgLy8gUmV1c2Ugb3JpZ2luYWwgdGFzayBpbnN0YW5jZS5cblxuICAgIHZhciB0YXNrID0gc2VyaWVzVGFza01hcC5nZXQocGlwZWxpbmVJZCkgfHwgc2VyaWVzVGFza01hcC5zZXQocGlwZWxpbmVJZCwgY3JlYXRlVGFzayh7XG4gICAgICBwbGFuOiBzZXJpZXNUYXNrUGxhbixcbiAgICAgIHJlc2V0OiBzZXJpZXNUYXNrUmVzZXQsXG4gICAgICBjb3VudDogc2VyaWVzVGFza0NvdW50XG4gICAgfSkpO1xuICAgIHRhc2suY29udGV4dCA9IHtcbiAgICAgIG1vZGVsOiBzZXJpZXNNb2RlbCxcbiAgICAgIGVjTW9kZWw6IGVjTW9kZWwsXG4gICAgICBhcGk6IGFwaSxcbiAgICAgIHVzZUNsZWFyVmlzdWFsOiBzdGFnZUhhbmRsZXIuaXNWaXN1YWwgJiYgIXN0YWdlSGFuZGxlci5pc0xheW91dCxcbiAgICAgIHBsYW46IHN0YWdlSGFuZGxlci5wbGFuLFxuICAgICAgcmVzZXQ6IHN0YWdlSGFuZGxlci5yZXNldCxcbiAgICAgIHNjaGVkdWxlcjogc2NoZWR1bGVyXG4gICAgfTtcbiAgICBwaXBlKHNjaGVkdWxlciwgc2VyaWVzTW9kZWwsIHRhc2spO1xuICB9IC8vIENsZWFyIHVudXNlZCBzZXJpZXMgdGFza3MuXG5cblxuICB2YXIgcGlwZWxpbmVNYXAgPSBzY2hlZHVsZXIuX3BpcGVsaW5lTWFwO1xuICBzZXJpZXNUYXNrTWFwLmVhY2goZnVuY3Rpb24gKHRhc2ssIHBpcGVsaW5lSWQpIHtcbiAgICBpZiAoIXBpcGVsaW5lTWFwLmdldChwaXBlbGluZUlkKSkge1xuICAgICAgdGFzay5kaXNwb3NlKCk7XG4gICAgICBzZXJpZXNUYXNrTWFwLnJlbW92ZUtleShwaXBlbGluZUlkKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPdmVyYWxsU3RhZ2VUYXNrKHNjaGVkdWxlciwgc3RhZ2VIYW5kbGVyLCBzdGFnZUhhbmRsZXJSZWNvcmQsIGVjTW9kZWwsIGFwaSkge1xuICB2YXIgb3ZlcmFsbFRhc2sgPSBzdGFnZUhhbmRsZXJSZWNvcmQub3ZlcmFsbFRhc2sgPSBzdGFnZUhhbmRsZXJSZWNvcmQub3ZlcmFsbFRhc2sgLy8gRm9yIG92ZXJhbGwgdGFzaywgdGhlIGZ1bmN0aW9uIG9ubHkgYmUgY2FsbGVkIG9uIHJlc2V0IHN0YWdlLlxuICB8fCBjcmVhdGVUYXNrKHtcbiAgICByZXNldDogb3ZlcmFsbFRhc2tSZXNldFxuICB9KTtcbiAgb3ZlcmFsbFRhc2suY29udGV4dCA9IHtcbiAgICBlY01vZGVsOiBlY01vZGVsLFxuICAgIGFwaTogYXBpLFxuICAgIG92ZXJhbGxSZXNldDogc3RhZ2VIYW5kbGVyLm92ZXJhbGxSZXNldCxcbiAgICBzY2hlZHVsZXI6IHNjaGVkdWxlclxuICB9OyAvLyBSZXVzZSBvcmlnbmFsIHN0dWJzLlxuXG4gIHZhciBhZ2VudFN0dWJNYXAgPSBvdmVyYWxsVGFzay5hZ2VudFN0dWJNYXAgPSBvdmVyYWxsVGFzay5hZ2VudFN0dWJNYXAgfHwgY3JlYXRlSGFzaE1hcCgpO1xuICB2YXIgc2VyaWVzVHlwZSA9IHN0YWdlSGFuZGxlci5zZXJpZXNUeXBlO1xuICB2YXIgZ2V0VGFyZ2V0U2VyaWVzID0gc3RhZ2VIYW5kbGVyLmdldFRhcmdldFNlcmllcztcbiAgdmFyIG92ZXJhbGxQcm9ncmVzcyA9IHRydWU7XG4gIHZhciBtb2RpZnlPdXRwdXRFbmQgPSBzdGFnZUhhbmRsZXIubW9kaWZ5T3V0cHV0RW5kOyAvLyBBbiBvdmVyYWxsIHRhc2sgd2l0aCBzZXJpZXNUeXBlIGRldGVjdGVkIG9yIGhhcyBgZ2V0VGFyZ2V0U2VyaWVzYCwgd2UgYWRkXG4gIC8vIHN0dWIgaW4gZWFjaCBwaXBlbGluZXMsIGl0IHdpbGwgc2V0IHRoZSBvdmVyYWxsIHRhc2sgZGlydHkgd2hlbiB0aGUgcGlwZWxpbmVcbiAgLy8gcHJvZ3Jlc3MuIE1vcmVvdmVyLCB0byBhdm9pZCBjYWxsIHRoZSBvdmVyYWxsIHRhc2sgZWFjaCBmcmFtZSAodG9vIGZyZXF1ZW50KSxcbiAgLy8gd2Ugc2V0IHRoZSBwaXBlbGluZSBibG9jay5cblxuICBpZiAoc2VyaWVzVHlwZSkge1xuICAgIGVjTW9kZWwuZWFjaFJhd1Nlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBjcmVhdGVTdHViKTtcbiAgfSBlbHNlIGlmIChnZXRUYXJnZXRTZXJpZXMpIHtcbiAgICBnZXRUYXJnZXRTZXJpZXMoZWNNb2RlbCwgYXBpKS5lYWNoKGNyZWF0ZVN0dWIpO1xuICB9IC8vIE90aGVyd2lzZSwgKHVzdWFsbHkgaXQgaXMgbGVnYW5jeSBjYXNlKSwgdGhlIG92ZXJhbGwgdGFzayB3aWxsIG9ubHkgYmVcbiAgLy8gZXhlY3V0ZWQgd2hlbiB1cHN0cmVhbSBkaXJ0eS4gT3RoZXJ3aXNlIHRoZSBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgb2YgYWxsXG4gIC8vIHBpcGVsaW5lcyB3aWxsIGJlIGRpc2FibGVkIHVuZXhwZWN0ZWRseS4gQnV0IGl0IHN0aWxsIG5lZWRzIHN0dWJzIHRvIHJlY2VpdmVcbiAgLy8gZGlydHkgaW5mbyBmcm9tIHVwc3RlYW0uXG4gIGVsc2Uge1xuICAgICAgb3ZlcmFsbFByb2dyZXNzID0gZmFsc2U7XG4gICAgICBlYWNoKGVjTW9kZWwuZ2V0U2VyaWVzKCksIGNyZWF0ZVN0dWIpO1xuICAgIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHViKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIHBpcGVsaW5lSWQgPSBzZXJpZXNNb2RlbC51aWQ7XG4gICAgdmFyIHN0dWIgPSBhZ2VudFN0dWJNYXAuZ2V0KHBpcGVsaW5lSWQpO1xuXG4gICAgaWYgKCFzdHViKSB7XG4gICAgICBzdHViID0gYWdlbnRTdHViTWFwLnNldChwaXBlbGluZUlkLCBjcmVhdGVUYXNrKHtcbiAgICAgICAgcmVzZXQ6IHN0dWJSZXNldCxcbiAgICAgICAgb25EaXJ0eTogc3R1Yk9uRGlydHlcbiAgICAgIH0pKTsgLy8gV2hlbiB0aGUgcmVzdWx0IG9mIGBnZXRUYXJnZXRTZXJpZXNgIGNoYW5nZWQsIHRoZSBvdmVyYWxsVGFza1xuICAgICAgLy8gc2hvdWxkIGJlIHNldCBhcyBkaXJ0eSBhbmQgcmUtcGVyZm9ybWVkLlxuXG4gICAgICBvdmVyYWxsVGFzay5kaXJ0eSgpO1xuICAgIH1cblxuICAgIHN0dWIuY29udGV4dCA9IHtcbiAgICAgIG1vZGVsOiBzZXJpZXNNb2RlbCxcbiAgICAgIG92ZXJhbGxQcm9ncmVzczogb3ZlcmFsbFByb2dyZXNzLFxuICAgICAgbW9kaWZ5T3V0cHV0RW5kOiBtb2RpZnlPdXRwdXRFbmRcbiAgICB9O1xuICAgIHN0dWIuYWdlbnQgPSBvdmVyYWxsVGFzaztcbiAgICBzdHViLl9fYmxvY2sgPSBvdmVyYWxsUHJvZ3Jlc3M7XG4gICAgcGlwZShzY2hlZHVsZXIsIHNlcmllc01vZGVsLCBzdHViKTtcbiAgfSAvLyBDbGVhciB1bnVzZWQgc3R1YnMuXG5cblxuICB2YXIgcGlwZWxpbmVNYXAgPSBzY2hlZHVsZXIuX3BpcGVsaW5lTWFwO1xuICBhZ2VudFN0dWJNYXAuZWFjaChmdW5jdGlvbiAoc3R1YiwgcGlwZWxpbmVJZCkge1xuICAgIGlmICghcGlwZWxpbmVNYXAuZ2V0KHBpcGVsaW5lSWQpKSB7XG4gICAgICBzdHViLmRpc3Bvc2UoKTsgLy8gV2hlbiB0aGUgcmVzdWx0IG9mIGBnZXRUYXJnZXRTZXJpZXNgIGNoYW5nZWQsIHRoZSBvdmVyYWxsVGFza1xuICAgICAgLy8gc2hvdWxkIGJlIHNldCBhcyBkaXJ0eSBhbmQgcmUtcGVyZm9ybWVkLlxuXG4gICAgICBvdmVyYWxsVGFzay5kaXJ0eSgpO1xuICAgICAgYWdlbnRTdHViTWFwLnJlbW92ZUtleShwaXBlbGluZUlkKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvdmVyYWxsVGFza1Jlc2V0KGNvbnRleHQpIHtcbiAgY29udGV4dC5vdmVyYWxsUmVzZXQoY29udGV4dC5lY01vZGVsLCBjb250ZXh0LmFwaSwgY29udGV4dC5wYXlsb2FkKTtcbn1cblxuZnVuY3Rpb24gc3R1YlJlc2V0KGNvbnRleHQsIHVwc3RyZWFtQ29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5vdmVyYWxsUHJvZ3Jlc3MgJiYgc3R1YlByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBzdHViUHJvZ3Jlc3MoKSB7XG4gIHRoaXMuYWdlbnQuZGlydHkoKTtcbiAgdGhpcy5nZXREb3duc3RyZWFtKCkuZGlydHkoKTtcbn1cblxuZnVuY3Rpb24gc3R1Yk9uRGlydHkoKSB7XG4gIHRoaXMuYWdlbnQgJiYgdGhpcy5hZ2VudC5kaXJ0eSgpO1xufVxuXG5mdW5jdGlvbiBzZXJpZXNUYXNrUGxhbihjb250ZXh0KSB7XG4gIHJldHVybiBjb250ZXh0LnBsYW4gJiYgY29udGV4dC5wbGFuKGNvbnRleHQubW9kZWwsIGNvbnRleHQuZWNNb2RlbCwgY29udGV4dC5hcGksIGNvbnRleHQucGF5bG9hZCk7XG59XG5cbmZ1bmN0aW9uIHNlcmllc1Rhc2tSZXNldChjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0LnVzZUNsZWFyVmlzdWFsKSB7XG4gICAgY29udGV4dC5kYXRhLmNsZWFyQWxsVmlzdWFsKCk7XG4gIH1cblxuICB2YXIgcmVzZXREZWZpbmVzID0gY29udGV4dC5yZXNldERlZmluZXMgPSBub3JtYWxpemVUb0FycmF5KGNvbnRleHQucmVzZXQoY29udGV4dC5tb2RlbCwgY29udGV4dC5lY01vZGVsLCBjb250ZXh0LmFwaSwgY29udGV4dC5wYXlsb2FkKSk7XG4gIHJldHVybiByZXNldERlZmluZXMubGVuZ3RoID4gMSA/IG1hcChyZXNldERlZmluZXMsIGZ1bmN0aW9uICh2LCBpZHgpIHtcbiAgICByZXR1cm4gbWFrZVNlcmllc1Rhc2tQcm9ncmVzcyhpZHgpO1xuICB9KSA6IHNpbmdsZVNlcmllc1Rhc2tQcm9ncmVzcztcbn1cblxudmFyIHNpbmdsZVNlcmllc1Rhc2tQcm9ncmVzcyA9IG1ha2VTZXJpZXNUYXNrUHJvZ3Jlc3MoMCk7XG5cbmZ1bmN0aW9uIG1ha2VTZXJpZXNUYXNrUHJvZ3Jlc3MocmVzZXREZWZpbmVJZHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwYXJhbXMsIGNvbnRleHQpIHtcbiAgICB2YXIgZGF0YSA9IGNvbnRleHQuZGF0YTtcbiAgICB2YXIgcmVzZXREZWZpbmUgPSBjb250ZXh0LnJlc2V0RGVmaW5lc1tyZXNldERlZmluZUlkeF07XG5cbiAgICBpZiAocmVzZXREZWZpbmUgJiYgcmVzZXREZWZpbmUuZGF0YUVhY2gpIHtcbiAgICAgIGZvciAodmFyIGkgPSBwYXJhbXMuc3RhcnQ7IGkgPCBwYXJhbXMuZW5kOyBpKyspIHtcbiAgICAgICAgcmVzZXREZWZpbmUuZGF0YUVhY2goZGF0YSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZXNldERlZmluZSAmJiByZXNldERlZmluZS5wcm9ncmVzcykge1xuICAgICAgcmVzZXREZWZpbmUucHJvZ3Jlc3MocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlcmllc1Rhc2tDb3VudChjb250ZXh0KSB7XG4gIHJldHVybiBjb250ZXh0LmRhdGEuY291bnQoKTtcbn1cblxuZnVuY3Rpb24gcGlwZShzY2hlZHVsZXIsIHNlcmllc01vZGVsLCB0YXNrKSB7XG4gIHZhciBwaXBlbGluZUlkID0gc2VyaWVzTW9kZWwudWlkO1xuXG4gIHZhciBwaXBlbGluZSA9IHNjaGVkdWxlci5fcGlwZWxpbmVNYXAuZ2V0KHBpcGVsaW5lSWQpO1xuXG4gICFwaXBlbGluZS5oZWFkICYmIChwaXBlbGluZS5oZWFkID0gdGFzayk7XG4gIHBpcGVsaW5lLnRhaWwgJiYgcGlwZWxpbmUudGFpbC5waXBlKHRhc2spO1xuICBwaXBlbGluZS50YWlsID0gdGFzaztcbiAgdGFzay5fX2lkeEluUGlwZWxpbmUgPSBwaXBlbGluZS5jb3VudCsrO1xuICB0YXNrLl9fcGlwZWxpbmUgPSBwaXBlbGluZTtcbn1cblxuU2NoZWR1bGVyLndyYXBTdGFnZUhhbmRsZXIgPSBmdW5jdGlvbiAoc3RhZ2VIYW5kbGVyLCB2aXN1YWxUeXBlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHN0YWdlSGFuZGxlcikpIHtcbiAgICBzdGFnZUhhbmRsZXIgPSB7XG4gICAgICBvdmVyYWxsUmVzZXQ6IHN0YWdlSGFuZGxlcixcbiAgICAgIHNlcmllc1R5cGU6IGRldGVjdFNlcmlzZVR5cGUoc3RhZ2VIYW5kbGVyKVxuICAgIH07XG4gIH1cblxuICBzdGFnZUhhbmRsZXIudWlkID0gZ2V0VUlEKCdzdGFnZUhhbmRsZXInKTtcbiAgdmlzdWFsVHlwZSAmJiAoc3RhZ2VIYW5kbGVyLnZpc3VhbFR5cGUgPSB2aXN1YWxUeXBlKTtcbiAgcmV0dXJuIHN0YWdlSGFuZGxlcjtcbn07XG4vKipcbiAqIE9ubHkgc29tZSBsZWdhY3kgc3RhZ2UgaGFuZGxlcnMgKHVzdWFsbHkgaW4gZWNoYXJ0cyBleHRlbnNpb25zKSBhcmUgcHVyZSBmdW5jdGlvbi5cbiAqIFRvIGVuc3VyZSB0aGF0IHRoZXkgY2FuIHdvcmsgbm9ybWFsbHksIHRoZXkgc2hvdWxkIHdvcmsgaW4gYmxvY2sgbW9kZSwgdGhhdCBpcyxcbiAqIHRoZXkgc2hvdWxkIG5vdCBiZSBzdGFydGVkIHV0aWwgdGhlIHByZXZpb3VzIHRhc2tzIGZpbmlzaGVkLiBTbyB0aGV5IGNhdXNlIHRoZVxuICogcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGRpc2FibGVkLiBXZSB0cnkgdG8gZGV0ZWN0IHRoZSBzZXJpZXMgdHlwZSwgdG8gbmFycm93IGRvd25cbiAqIHRoZSBibG9jayByYW5nZSB0byBvbmx5IHRoZSBzZXJpZXMgdHlwZSB0aGV5IGNvbmNlcm4sIGJ1dCBub3QgYWxsIHNlcmllcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRldGVjdFNlcmlzZVR5cGUobGVnYWN5RnVuYykge1xuICBzZXJpZXNUeXBlID0gbnVsbDtcblxuICB0cnkge1xuICAgIC8vIEFzc3VtZSB0aGVyZSBpcyBubyBhc3luYyB3aGVuIGNhbGxpbmcgYGVhY2hTZXJpZXNCeVR5cGVgLlxuICAgIGxlZ2FjeUZ1bmMoZWNNb2RlbE1vY2ssIGFwaU1vY2spO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHJldHVybiBzZXJpZXNUeXBlO1xufVxuXG52YXIgZWNNb2RlbE1vY2sgPSB7fTtcbnZhciBhcGlNb2NrID0ge307XG52YXIgc2VyaWVzVHlwZTtcbm1vY2tNZXRob2RzKGVjTW9kZWxNb2NrLCBHbG9iYWxNb2RlbCk7XG5tb2NrTWV0aG9kcyhhcGlNb2NrLCBFeHRlbnNpb25BUEkpO1xuXG5lY01vZGVsTW9jay5lYWNoU2VyaWVzQnlUeXBlID0gZWNNb2RlbE1vY2suZWFjaFJhd1Nlcmllc0J5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHNlcmllc1R5cGUgPSB0eXBlO1xufTtcblxuZWNNb2RlbE1vY2suZWFjaENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb25kKSB7XG4gIGlmIChjb25kLm1haW5UeXBlID09PSAnc2VyaWVzJyAmJiBjb25kLnN1YlR5cGUpIHtcbiAgICBzZXJpZXNUeXBlID0gY29uZC5zdWJUeXBlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBtb2NrTWV0aG9kcyh0YXJnZXQsIENseikge1xuICBmb3IgKHZhciBuYW1lIGluIENsei5wcm90b3R5cGUpIHtcbiAgICAvLyBEbyBub3QgdXNlIGhhc093blByb3BlcnR5XG4gICAgdGFyZ2V0W25hbWVdID0gbm9vcDtcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBTY2hlZHVsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3N0cmVhbS9TY2hlZHVsZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3N0cmVhbS9TY2hlZHVsZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX3V0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgYXNzZXJ0ID0gX3V0aWwuYXNzZXJ0O1xudmFyIGlzQXJyYXkgPSBfdXRpbC5pc0FycmF5O1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmluZVxuICogQHJldHVybiBTZWUgdGhlIHJldHVybiBvZiBgY3JlYXRlVGFza2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRhc2soZGVmaW5lKSB7XG4gIHJldHVybiBuZXcgVGFzayhkZWZpbmUpO1xufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRlZmluZS5yZXNldCBDdXN0b20gcmVzZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtkZWZpbmUucGxhbl0gUmV0dXJucyAncmVzZXQnIGluZGljYXRlIHJlc2V0IGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2RlZmluZS5jb3VudF0gY291bnQgaXMgdXNlZCB0byBkZXRlcm1pbiBkYXRhIHRhc2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZGVmaW5lLm9uRGlydHldIGNvdW50IGlzIHVzZWQgdG8gZGV0ZXJtaW4gZGF0YSB0YXNrLlxuICovXG5cblxuZnVuY3Rpb24gVGFzayhkZWZpbmUpIHtcbiAgZGVmaW5lID0gZGVmaW5lIHx8IHt9O1xuICB0aGlzLl9yZXNldCA9IGRlZmluZS5yZXNldDtcbiAgdGhpcy5fcGxhbiA9IGRlZmluZS5wbGFuO1xuICB0aGlzLl9jb3VudCA9IGRlZmluZS5jb3VudDtcbiAgdGhpcy5fb25EaXJ0eSA9IGRlZmluZS5vbkRpcnR5O1xuICB0aGlzLl9kaXJ0eSA9IHRydWU7IC8vIENvbnRleHQgbXVzdCBiZSBzcGVjaWZpZWQgaW1wbGljaXRseSwgdG9cbiAgLy8gYXZvaWQgbWlzcyB1cGRhdGUgY29udGV4dCB3aGVuIG1vZGVsIGNoYW5nZWQuXG5cbiAgdGhpcy5jb250ZXh0O1xufVxuXG52YXIgdGFza1Byb3RvID0gVGFzay5wcm90b3R5cGU7XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwZXJmb3JtQXJnc1xuICogQHBhcmFtIHtudW1iZXJ9IFtwZXJmb3JtQXJncy5zdGVwXSBTcGVjaWZpZWQgc3RlcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGVyZm9ybUFyZ3Muc2tpcF0gU2tpcCBjdXN0b21lciBwZXJmb3JtIGNhbGwuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BlcmZvcm1BcmdzLm1vZEJ5XSBTYW1wbGluZyB3aW5kb3cgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGVyZm9ybUFyZ3MubW9kRGF0YUNvdW50XSBTYW1wbGluZyBjb3VudC5cbiAqL1xuXG50YXNrUHJvdG8ucGVyZm9ybSA9IGZ1bmN0aW9uIChwZXJmb3JtQXJncykge1xuICB2YXIgdXBUYXNrID0gdGhpcy5fdXBzdHJlYW07XG4gIHZhciBza2lwID0gcGVyZm9ybUFyZ3MgJiYgcGVyZm9ybUFyZ3Muc2tpcDsgLy8gVE9ETyBzb21lIHJlZmFjdG9yLlxuICAvLyBQdWxsIGRhdGEuIE11c3QgcHVsbCBkYXRhIGVhY2ggdGltZSwgYmVjYXVzZSBjb250ZXh0LmRhdGFcbiAgLy8gbWF5IGJlIHVwZGF0ZWQgYnkgU2VyaWVzLnNldERhdGEuXG5cbiAgaWYgKHRoaXMuX2RpcnR5ICYmIHVwVGFzaykge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnRleHQuZGF0YSA9IGNvbnRleHQub3V0cHV0RGF0YSA9IHVwVGFzay5jb250ZXh0Lm91dHB1dERhdGE7XG4gIH1cblxuICBpZiAodGhpcy5fX3BpcGVsaW5lKSB7XG4gICAgdGhpcy5fX3BpcGVsaW5lLmN1cnJlbnRUYXNrID0gdGhpcztcbiAgfVxuXG4gIHZhciBwbGFuUmVzdWx0O1xuXG4gIGlmICh0aGlzLl9wbGFuICYmICFza2lwKSB7XG4gICAgcGxhblJlc3VsdCA9IHRoaXMuX3BsYW4odGhpcy5jb250ZXh0KTtcbiAgfSAvLyBTdXBwb3J0IHNoYXJkaW5nIGJ5IG1vZCwgd2hpY2ggY2hhbmdlcyB0aGUgcmVuZGVyIHNlcXVlbmNlIGFuZCBtYWtlcyB0aGUgcmVuZGVyZWQgZ3JhcGhpY1xuICAvLyBlbGVtZW50cyB1bmlmb3JtZWQgZGlzdHJpYnV0ZWQgd2hlbiBwcm9ncmVzcywgZXNwZWNpYWxseSB3aGVuIG1vdmluZyBvciB6b29taW5nLlxuXG5cbiAgdmFyIGxhc3RNb2RCeSA9IG5vcm1hbGl6ZU1vZEJ5KHRoaXMuX21vZEJ5KTtcbiAgdmFyIGxhc3RNb2REYXRhQ291bnQgPSB0aGlzLl9tb2REYXRhQ291bnQgfHwgMDtcbiAgdmFyIG1vZEJ5ID0gbm9ybWFsaXplTW9kQnkocGVyZm9ybUFyZ3MgJiYgcGVyZm9ybUFyZ3MubW9kQnkpO1xuICB2YXIgbW9kRGF0YUNvdW50ID0gcGVyZm9ybUFyZ3MgJiYgcGVyZm9ybUFyZ3MubW9kRGF0YUNvdW50IHx8IDA7XG5cbiAgaWYgKGxhc3RNb2RCeSAhPT0gbW9kQnkgfHwgbGFzdE1vZERhdGFDb3VudCAhPT0gbW9kRGF0YUNvdW50KSB7XG4gICAgcGxhblJlc3VsdCA9ICdyZXNldCc7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVNb2RCeSh2YWwpIHtcbiAgICAhKHZhbCA+PSAxKSAmJiAodmFsID0gMSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHZhciBmb3JjZUZpcnN0UHJvZ3Jlc3M7XG5cbiAgaWYgKHRoaXMuX2RpcnR5IHx8IHBsYW5SZXN1bHQgPT09ICdyZXNldCcpIHtcbiAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgIGZvcmNlRmlyc3RQcm9ncmVzcyA9IHJlc2V0KHRoaXMsIHNraXApO1xuICB9XG5cbiAgdGhpcy5fbW9kQnkgPSBtb2RCeTtcbiAgdGhpcy5fbW9kRGF0YUNvdW50ID0gbW9kRGF0YUNvdW50O1xuICB2YXIgc3RlcCA9IHBlcmZvcm1BcmdzICYmIHBlcmZvcm1BcmdzLnN0ZXA7XG5cbiAgaWYgKHVwVGFzaykge1xuICAgIHRoaXMuX2R1ZUVuZCA9IHVwVGFzay5fb3V0cHV0RHVlRW5kO1xuICB9IC8vIERhdGFUYXNrIG9yIG92ZXJhbGxUYXNrXG4gIGVsc2Uge1xuICAgICAgdGhpcy5fZHVlRW5kID0gdGhpcy5fY291bnQgPyB0aGlzLl9jb3VudCh0aGlzLmNvbnRleHQpIDogSW5maW5pdHk7XG4gICAgfSAvLyBOb3RlOiBTdHVicywgdGhhdCBpdHMgaG9zdCBvdmVyYWxsIHRhc2sgbGV0IGl0IGhhcyBwcm9ncmVzcywgaGFzIHByb2dyZXNzLlxuICAvLyBJZiBubyBwcm9ncmVzcywgcGFzcyBpbmRleCBmcm9tIHVwc3RyZWFtIHRvIGRvd25zdHJlYW0gZWFjaCB0aW1lIHBsYW4gY2FsbGVkLlxuXG5cbiAgaWYgKHRoaXMuX3Byb2dyZXNzKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fZHVlSW5kZXg7XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHN0ZXAgIT0gbnVsbCA/IHRoaXMuX2R1ZUluZGV4ICsgc3RlcCA6IEluZmluaXR5LCB0aGlzLl9kdWVFbmQpO1xuXG4gICAgaWYgKCFza2lwICYmIChmb3JjZUZpcnN0UHJvZ3Jlc3MgfHwgc3RhcnQgPCBlbmQpKSB7XG4gICAgICB2YXIgcHJvZ3Jlc3MgPSB0aGlzLl9wcm9ncmVzcztcblxuICAgICAgaWYgKGlzQXJyYXkocHJvZ3Jlc3MpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3Jlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkb1Byb2dyZXNzKHRoaXMsIHByb2dyZXNzW2ldLCBzdGFydCwgZW5kLCBtb2RCeSwgbW9kRGF0YUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9Qcm9ncmVzcyh0aGlzLCBwcm9ncmVzcywgc3RhcnQsIGVuZCwgbW9kQnksIG1vZERhdGFDb3VudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZHVlSW5kZXggPSBlbmQ7IC8vIElmIG5vIGBvdXRwdXREdWVFbmRgLCBhc3N1bWUgdGhhdCBvdXRwdXQgZGF0YSBhbmRcbiAgICAvLyBpbnB1dCBkYXRhIGlzIHRoZSBzYW1lLCBzbyB1c2UgYGR1ZUluZGV4YCBhcyBgb3V0cHV0RHVlRW5kYC5cblxuICAgIHZhciBvdXRwdXREdWVFbmQgPSB0aGlzLl9zZXR0ZWRPdXRwdXRFbmQgIT0gbnVsbCA/IHRoaXMuX3NldHRlZE91dHB1dEVuZCA6IGVuZDtcbiAgICB0aGlzLl9vdXRwdXREdWVFbmQgPSBvdXRwdXREdWVFbmQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gKDEpIFNvbWUgb3ZlcmFsbCB0YXNrIGhhcyBubyBwcm9ncmVzcy5cbiAgICAvLyAoMikgU3R1YnMsIHRoYXQgaXRzIGhvc3Qgb3ZlcmFsbCB0YXNrIGRvIG5vdCBsZXQgaXQgaGFzIHByb2dyZXNzLCBoYXMgbm8gcHJvZ3Jlc3MuXG4gICAgLy8gVGhpcyBzaG91bGQgYWx3YXlzIGJlIHBlcmZvcm1lZCBzbyBpdCBjYW4gYmUgcGFzc2VkIHRvIGRvd25zdHJlYW0uXG4gICAgdGhpcy5fZHVlSW5kZXggPSB0aGlzLl9vdXRwdXREdWVFbmQgPSB0aGlzLl9zZXR0ZWRPdXRwdXRFbmQgIT0gbnVsbCA/IHRoaXMuX3NldHRlZE91dHB1dEVuZCA6IHRoaXMuX2R1ZUVuZDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnVuZmluaXNoZWQoKTtcbn07XG5cbnZhciBpdGVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVuZDtcbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBtb2RCeTtcbiAgdmFyIG1vZERhdGFDb3VudDtcbiAgdmFyIHdpbkNvdW50O1xuICB2YXIgaXQgPSB7XG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChzLCBlLCBzU3RlcCwgc0NvdW50KSB7XG4gICAgICBjdXJyZW50ID0gcztcbiAgICAgIGVuZCA9IGU7XG4gICAgICBtb2RCeSA9IHNTdGVwO1xuICAgICAgbW9kRGF0YUNvdW50ID0gc0NvdW50O1xuICAgICAgd2luQ291bnQgPSBNYXRoLmNlaWwobW9kRGF0YUNvdW50IC8gbW9kQnkpO1xuICAgICAgaXQubmV4dCA9IG1vZEJ5ID4gMSAmJiBtb2REYXRhQ291bnQgPiAwID8gbW9kTmV4dCA6IHNlcXVlbnRpYWxOZXh0O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGl0O1xuXG4gIGZ1bmN0aW9uIHNlcXVlbnRpYWxOZXh0KCkge1xuICAgIHJldHVybiBjdXJyZW50IDwgZW5kID8gY3VycmVudCsrIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vZE5leHQoKSB7XG4gICAgdmFyIGRhdGFJbmRleCA9IGN1cnJlbnQgJSB3aW5Db3VudCAqIG1vZEJ5ICsgTWF0aC5jZWlsKGN1cnJlbnQgLyB3aW5Db3VudCk7XG4gICAgdmFyIHJlc3VsdCA9IGN1cnJlbnQgPj0gZW5kID8gbnVsbCA6IGRhdGFJbmRleCA8IG1vZERhdGFDb3VudCA/IGRhdGFJbmRleCAvLyBJZiBtb2REYXRhQ291bnQgaXMgc21hbGxlciB0aGFuIGRhdGEuY291bnQoKSAoY29uc2lkZXIgYGFwcGVuZERhdGFgIGNhc2UpLFxuICAgIC8vIFVzZSBub3JtYWwgbGluZWFyIHJlbmRlcmluZyBtb2RlLlxuICAgIDogY3VycmVudDtcbiAgICBjdXJyZW50Kys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSgpO1xuXG50YXNrUHJvdG8uZGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgdGhpcy5fb25EaXJ0eSAmJiB0aGlzLl9vbkRpcnR5KHRoaXMuY29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBkb1Byb2dyZXNzKHRhc2tJbnMsIHByb2dyZXNzLCBzdGFydCwgZW5kLCBtb2RCeSwgbW9kRGF0YUNvdW50KSB7XG4gIGl0ZXJhdG9yLnJlc2V0KHN0YXJ0LCBlbmQsIG1vZEJ5LCBtb2REYXRhQ291bnQpO1xuICB0YXNrSW5zLl9jYWxsaW5nUHJvZ3Jlc3MgPSBwcm9ncmVzcztcblxuICB0YXNrSW5zLl9jYWxsaW5nUHJvZ3Jlc3Moe1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZCxcbiAgICBjb3VudDogZW5kIC0gc3RhcnQsXG4gICAgbmV4dDogaXRlcmF0b3IubmV4dFxuICB9LCB0YXNrSW5zLmNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiByZXNldCh0YXNrSW5zLCBza2lwKSB7XG4gIHRhc2tJbnMuX2R1ZUluZGV4ID0gdGFza0lucy5fb3V0cHV0RHVlRW5kID0gdGFza0lucy5fZHVlRW5kID0gMDtcbiAgdGFza0lucy5fc2V0dGVkT3V0cHV0RW5kID0gbnVsbDtcbiAgdmFyIHByb2dyZXNzO1xuICB2YXIgZm9yY2VGaXJzdFByb2dyZXNzO1xuXG4gIGlmICghc2tpcCAmJiB0YXNrSW5zLl9yZXNldCkge1xuICAgIHByb2dyZXNzID0gdGFza0lucy5fcmVzZXQodGFza0lucy5jb250ZXh0KTtcblxuICAgIGlmIChwcm9ncmVzcyAmJiBwcm9ncmVzcy5wcm9ncmVzcykge1xuICAgICAgZm9yY2VGaXJzdFByb2dyZXNzID0gcHJvZ3Jlc3MuZm9yY2VGaXJzdFByb2dyZXNzO1xuICAgICAgcHJvZ3Jlc3MgPSBwcm9ncmVzcy5wcm9ncmVzcztcbiAgICB9IC8vIFRvIHNpbXBsaWZ5IG5vIHByb2dyZXNzIGNoZWNraW5nLCBhcnJheSBtdXN0IGhhcyBpdGVtLlxuXG5cbiAgICBpZiAoaXNBcnJheShwcm9ncmVzcykgJiYgIXByb2dyZXNzLmxlbmd0aCkge1xuICAgICAgcHJvZ3Jlc3MgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHRhc2tJbnMuX3Byb2dyZXNzID0gcHJvZ3Jlc3M7XG4gIHRhc2tJbnMuX21vZEJ5ID0gdGFza0lucy5fbW9kRGF0YUNvdW50ID0gbnVsbDtcbiAgdmFyIGRvd25zdHJlYW0gPSB0YXNrSW5zLl9kb3duc3RyZWFtO1xuICBkb3duc3RyZWFtICYmIGRvd25zdHJlYW0uZGlydHkoKTtcbiAgcmV0dXJuIGZvcmNlRmlyc3RQcm9ncmVzcztcbn1cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbnRhc2tQcm90by51bmZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcHJvZ3Jlc3MgJiYgdGhpcy5fZHVlSW5kZXggPCB0aGlzLl9kdWVFbmQ7XG59O1xuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gZG93blRhc2sgVGhlIGRvd25zdHJlYW0gdGFzay5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRvd25zdHJlYW0gdGFzay5cbiAqL1xuXG5cbnRhc2tQcm90by5waXBlID0gZnVuY3Rpb24gKGRvd25UYXNrKSB7XG4gIC8vIElmIGFscmVhZHkgZG93bnN0cmVhbSwgZG8gbm90IGRpcnR5IGRvd25UYXNrLlxuICBpZiAodGhpcy5fZG93bnN0cmVhbSAhPT0gZG93blRhc2sgfHwgdGhpcy5fZGlydHkpIHtcbiAgICB0aGlzLl9kb3duc3RyZWFtID0gZG93blRhc2s7XG4gICAgZG93blRhc2suX3Vwc3RyZWFtID0gdGhpcztcbiAgICBkb3duVGFzay5kaXJ0eSgpO1xuICB9XG59O1xuXG50YXNrUHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fdXBzdHJlYW0gJiYgKHRoaXMuX3Vwc3RyZWFtLl9kb3duc3RyZWFtID0gbnVsbCk7XG4gIHRoaXMuX2Rvd25zdHJlYW0gJiYgKHRoaXMuX2Rvd25zdHJlYW0uX3Vwc3RyZWFtID0gbnVsbCk7XG4gIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbn07XG5cbnRhc2tQcm90by5nZXRVcHN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Vwc3RyZWFtO1xufTtcblxudGFza1Byb3RvLmdldERvd25zdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9kb3duc3RyZWFtO1xufTtcblxudGFza1Byb3RvLnNldE91dHB1dEVuZCA9IGZ1bmN0aW9uIChlbmQpIHtcbiAgLy8gVGhpcyBvbmx5IGhhcHBlbmQgaW4gZGF0YVRhc2ssIGRhdGFab29tLCBtYXAsIGN1cnJlbnRseS5cbiAgLy8gd2hlcmUgZGF0YVpvb20gZG8gbm90IHNldCBlbmQgZWFjaCB0aW1lLCBidXQgb25seSBzZXRcbiAgLy8gd2hlbiByZXNldC4gU28gd2Ugc2hvdWxkIHJlY29yZCB0aGUgc2V0dGVkIGVuZCwgaW4gY2FzZVxuICAvLyB0aGF0IHRoZSBzdHViIG9mIGRhdGFab29tIHBlcmZvcm0gYWdhaW4gYW5kIGVhcnNlIHRoZVxuICAvLyBzZXR0ZWQgZW5kIGJ5IHVwc3RyZWFtLlxuICB0aGlzLl9vdXRwdXREdWVFbmQgPSB0aGlzLl9zZXR0ZWRPdXRwdXRFbmQgPSBlbmQ7XG59OyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRm9yIHN0cmVhbSBkZWJ1ZyAoU2hvdWxkIGJlIGNvbW1lbnRlZCBvdXQgYWZ0ZXIgdXNlZCEpXG4vLyBVc2FnZTogcHJpbnRUYXNrKHRoaXMsICdiZWdpbicpO1xuLy8gVXNhZ2U6IHByaW50VGFzayh0aGlzLCBudWxsLCB7c29tZUV4dHJhUHJvcH0pO1xuLy8gZnVuY3Rpb24gcHJpbnRUYXNrKHRhc2ssIHByZWZpeCwgZXh0cmEpIHtcbi8vICAgICB3aW5kb3cuZWNUYXNrVUlEID09IG51bGwgJiYgKHdpbmRvdy5lY1Rhc2tVSUQgPSAwKTtcbi8vICAgICB0YXNrLnVpZERlYnVnID09IG51bGwgJiYgKHRhc2sudWlkRGVidWcgPSBgdGFza18ke3dpbmRvdy5lY1Rhc2tVSUQrK31gKTtcbi8vICAgICB0YXNrLmFnZW50ICYmIHRhc2suYWdlbnQudWlkRGVidWcgPT0gbnVsbCAmJiAodGFzay5hZ2VudC51aWREZWJ1ZyA9IGB0YXNrXyR7d2luZG93LmVjVGFza1VJRCsrfWApO1xuLy8gICAgIHZhciBwcm9wcyA9IFtdO1xuLy8gICAgIGlmICh0YXNrLl9fcGlwZWxpbmUpIHtcbi8vICAgICAgICAgdmFyIHZhbCA9IGAke3Rhc2suX19pZHhJblBpcGVsaW5lfS8ke3Rhc2suX19waXBlbGluZS50YWlsLl9faWR4SW5QaXBlbGluZX0gJHt0YXNrLmFnZW50ID8gJyhzdHViKScgOiAnJ31gO1xuLy8gICAgICAgICBwcm9wcy5wdXNoKHt0ZXh0OiAnaWR4JywgdmFsdWU6IHZhbH0pO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIHZhciBzdHViQ291bnQgPSAwO1xuLy8gICAgICAgICB0YXNrLmFnZW50U3R1Yk1hcC5lYWNoKCgpID0+IHN0dWJDb3VudCsrKTtcbi8vICAgICAgICAgcHJvcHMucHVzaCh7dGV4dDogJ2lkeCcsIHZhbHVlOiBgb3ZlcmFsbCAoc3R1YnM6ICR7c3R1YkNvdW50fSlgfSk7XG4vLyAgICAgfVxuLy8gICAgIHByb3BzLnB1c2goe3RleHQ6ICd1aWQnLCB2YWx1ZTogdGFzay51aWREZWJ1Z30pO1xuLy8gICAgIGlmICh0YXNrLl9fcGlwZWxpbmUpIHtcbi8vICAgICAgICAgcHJvcHMucHVzaCh7dGV4dDogJ3BpZCcsIHZhbHVlOiB0YXNrLl9fcGlwZWxpbmUuaWR9KTtcbi8vICAgICAgICAgdGFzay5hZ2VudCAmJiBwcm9wcy5wdXNoKFxuLy8gICAgICAgICAgICAge3RleHQ6ICdzdHViRm9yJywgdmFsdWU6IHRhc2suYWdlbnQudWlkRGVidWd9XG4vLyAgICAgICAgICk7XG4vLyAgICAgfVxuLy8gICAgIHByb3BzLnB1c2goXG4vLyAgICAgICAgIHt0ZXh0OiAnZGlydHknLCB2YWx1ZTogdGFzay5fZGlydHl9LFxuLy8gICAgICAgICB7dGV4dDogJ2R1ZUluZGV4JywgdmFsdWU6IHRhc2suX2R1ZUluZGV4fSxcbi8vICAgICAgICAge3RleHQ6ICdkdWVFbmQnLCB2YWx1ZTogdGFzay5fZHVlRW5kfSxcbi8vICAgICAgICAge3RleHQ6ICdvdXRwdXREdWVFbmQnLCB2YWx1ZTogdGFzay5fb3V0cHV0RHVlRW5kfVxuLy8gICAgICk7XG4vLyAgICAgaWYgKGV4dHJhKSB7XG4vLyAgICAgICAgIE9iamVjdC5rZXlzKGV4dHJhKS5mb3JFYWNoKGtleSA9PiB7XG4vLyAgICAgICAgICAgICBwcm9wcy5wdXNoKHt0ZXh0OiBrZXksIHZhbHVlOiBleHRyYVtrZXldfSk7XG4vLyAgICAgICAgIH0pO1xuLy8gICAgIH1cbi8vICAgICB2YXIgYXJncyA9IFsnY29sb3I6IGJsdWUnXTtcbi8vICAgICB2YXIgbXNnID0gYCVjWyR7cHJlZml4IHx8ICdUJ31dICVjYCArIHByb3BzLm1hcChpdGVtID0+IChcbi8vICAgICAgICAgYXJncy5wdXNoKCdjb2xvcjogYmxhY2snLCAnY29sb3I6IHJlZCcpLFxuLy8gICAgICAgICBgJHtpdGVtLnRleHR9OiAlYyR7aXRlbS52YWx1ZX1gXG4vLyAgICAgKSkuam9pbignJWMsICcpO1xuLy8gICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFttc2ddLmNvbmNhdChhcmdzKSk7XG4vLyAgICAgLy8gY29uc29sZS5sb2codGhpcyk7XG4vLyB9XG5cblxuZXhwb3J0cy5jcmVhdGVUYXNrID0gY3JlYXRlVGFzaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zdHJlYW0vdGFzay5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc3RyZWFtL3Rhc2suanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgY29udHJhc3RDb2xvciA9ICcjZWVlJztcblxudmFyIGF4aXNDb21tb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgYXhpc0xpbmU6IHtcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogY29udHJhc3RDb2xvclxuICAgICAgfVxuICAgIH0sXG4gICAgYXhpc1RpY2s6IHtcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogY29udHJhc3RDb2xvclxuICAgICAgfVxuICAgIH0sXG4gICAgYXhpc0xhYmVsOiB7XG4gICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgY29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICAgIH1cbiAgICB9LFxuICAgIHNwbGl0TGluZToge1xuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIHR5cGU6ICdkYXNoZWQnLFxuICAgICAgICBjb2xvcjogJyNhYWEnXG4gICAgICB9XG4gICAgfSxcbiAgICBzcGxpdEFyZWE6IHtcbiAgICAgIGFyZWFTdHlsZToge1xuICAgICAgICBjb2xvcjogY29udHJhc3RDb2xvclxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBjb2xvclBhbGV0dGUgPSBbJyNkZDZiNjYnLCAnIzc1OWFhMCcsICcjZTY5ZDg3JywgJyM4ZGMxYTknLCAnI2VhN2U1MycsICcjZWVkZDc4JywgJyM3M2EzNzMnLCAnIzczYjliYycsICcjNzI4OWFiJywgJyM5MWNhOGMnLCAnI2Y0OWY0MiddO1xudmFyIHRoZW1lID0ge1xuICBjb2xvcjogY29sb3JQYWxldHRlLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICcjMzMzJyxcbiAgdG9vbHRpcDoge1xuICAgIGF4aXNQb2ludGVyOiB7XG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgY29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICAgIH0sXG4gICAgICBjcm9zc1N0eWxlOiB7XG4gICAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBsZWdlbmQ6IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgfVxuICB9LFxuICB0ZXh0U3R5bGU6IHtcbiAgICBjb2xvcjogY29udHJhc3RDb2xvclxuICB9LFxuICB0aXRsZToge1xuICAgIHRleHRTdHlsZToge1xuICAgICAgY29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICB9XG4gIH0sXG4gIHRvb2xib3g6IHtcbiAgICBpY29uU3R5bGU6IHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICBib3JkZXJDb2xvcjogY29udHJhc3RDb2xvclxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGF0YVpvb206IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgfVxuICB9LFxuICB2aXN1YWxNYXA6IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgfVxuICB9LFxuICB0aW1lbGluZToge1xuICAgIGxpbmVTdHlsZToge1xuICAgICAgY29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICB9LFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgbm9ybWFsOiB7XG4gICAgICAgIGNvbG9yOiBjb2xvclBhbGV0dGVbMV1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29udHJvbFN0eWxlOiB7XG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgY29sb3I6IGNvbnRyYXN0Q29sb3IsXG4gICAgICAgIGJvcmRlckNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB0aW1lQXhpczogYXhpc0NvbW1vbigpLFxuICBsb2dBeGlzOiBheGlzQ29tbW9uKCksXG4gIHZhbHVlQXhpczogYXhpc0NvbW1vbigpLFxuICBjYXRlZ29yeUF4aXM6IGF4aXNDb21tb24oKSxcbiAgbGluZToge1xuICAgIHN5bWJvbDogJ2NpcmNsZSdcbiAgfSxcbiAgZ3JhcGg6IHtcbiAgICBjb2xvcjogY29sb3JQYWxldHRlXG4gIH0sXG4gIGdhdWdlOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIHRleHRTdHlsZToge1xuICAgICAgICBjb2xvcjogY29udHJhc3RDb2xvclxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2FuZGxlc3RpY2s6IHtcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICBjb2xvcjogJyNGRDEwNTAnLFxuICAgICAgICBjb2xvcjA6ICcjMENGNDlCJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjRkQxMDUwJyxcbiAgICAgICAgYm9yZGVyQ29sb3IwOiAnIzBDRjQ5QidcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG50aGVtZS5jYXRlZ29yeUF4aXMuc3BsaXRMaW5lLnNob3cgPSBmYWxzZTtcbnZhciBfZGVmYXVsdCA9IHRoZW1lO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi90aGVtZS9kYXJrLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi90aGVtZS9kYXJrLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGNvbG9yQWxsID0gWycjMzdBMkRBJywgJyMzMkM1RTknLCAnIzY3RTBFMycsICcjOUZFNkI4JywgJyNGRkRCNUMnLCAnI2ZmOWY3ZicsICcjZmI3MjkzJywgJyNFMDYyQUUnLCAnI0U2OTBEMScsICcjZTdiY2YzJywgJyM5ZDk2ZjUnLCAnIzgzNzhFQScsICcjOTZCRkZGJ107XG52YXIgX2RlZmF1bHQgPSB7XG4gIGNvbG9yOiBjb2xvckFsbCxcbiAgY29sb3JMYXllcjogW1snIzM3QTJEQScsICcjZmZkODVjJywgJyNmZDdiNWYnXSwgWycjMzdBMkRBJywgJyM2N0UwRTMnLCAnI0ZGREI1QycsICcjZmY5ZjdmJywgJyNFMDYyQUUnLCAnIzlkOTZmNSddLCBbJyMzN0EyREEnLCAnIzMyQzVFOScsICcjOUZFNkI4JywgJyNGRkRCNUMnLCAnI2ZmOWY3ZicsICcjZmI3MjkzJywgJyNlN2JjZjMnLCAnIzgzNzhFQScsICcjOTZCRkZGJ10sIGNvbG9yQWxsXVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdGhlbWUvbGlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3RoZW1lL2xpZ2h0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBUWVBFX0RFTElNSVRFUiA9ICcuJztcbnZhciBJU19DT05UQUlORVIgPSAnX19fRUNfX0NPTVBPTkVOVF9fQ09OVEFJTkVSX19fJztcbi8qKlxuICogTm90aWNlLCBwYXJzZUNsYXNzVHlwZSgnJykgc2hvdWxkIHJldHVybnMge21haW46ICcnLCBzdWI6ICcnfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpIHtcbiAgdmFyIHJldCA9IHtcbiAgICBtYWluOiAnJyxcbiAgICBzdWI6ICcnXG4gIH07XG5cbiAgaWYgKGNvbXBvbmVudFR5cGUpIHtcbiAgICBjb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZS5zcGxpdChUWVBFX0RFTElNSVRFUik7XG4gICAgcmV0Lm1haW4gPSBjb21wb25lbnRUeXBlWzBdIHx8ICcnO1xuICAgIHJldC5zdWIgPSBjb21wb25lbnRUeXBlWzFdIHx8ICcnO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gY2hlY2tDbGFzc1R5cGUoY29tcG9uZW50VHlwZSkge1xuICB6clV0aWwuYXNzZXJ0KC9eW2EtekEtWjAtOV9dKyhbLl1bYS16QS1aMC05X10rKT8kLy50ZXN0KGNvbXBvbmVudFR5cGUpLCAnY29tcG9uZW50VHlwZSBcIicgKyBjb21wb25lbnRUeXBlICsgJ1wiIGlsbGVnYWwnKTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZW5hYmxlQ2xhc3NFeHRlbmQoUm9vdENsYXNzLCBtYW5kYXRvcnlNZXRob2RzKSB7XG4gIFJvb3RDbGFzcy4kY29uc3RydWN0b3IgPSBSb290Q2xhc3M7XG5cbiAgUm9vdENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICAgIHZhciBzdXBlckNsYXNzID0gdGhpcztcblxuICAgIHZhciBFeHRlbmRlZENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFwcm90by4kY29uc3RydWN0b3IpIHtcbiAgICAgICAgc3VwZXJDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdG8uJGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5leHRlbmQoRXh0ZW5kZWRDbGFzcy5wcm90b3R5cGUsIHByb3RvKTtcbiAgICBFeHRlbmRlZENsYXNzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kO1xuICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDYWxsID0gc3VwZXJDYWxsO1xuICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJBcHBseSA9IHN1cGVyQXBwbHk7XG4gICAgenJVdGlsLmluaGVyaXRzKEV4dGVuZGVkQ2xhc3MsIHRoaXMpO1xuICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XG4gICAgcmV0dXJuIEV4dGVuZGVkQ2xhc3M7XG4gIH07XG59XG5cbnZhciBjbGFzc0Jhc2UgPSAwO1xuLyoqXG4gKiBDYW4gbm90IHVzZSBpbnN0YW5jZW9mLCBjb25zaWRlciBkaWZmZXJlbnQgc2NvcGUgYnlcbiAqIGNyb3NzIGRvbWFpbiBvciBlcyBtb2R1bGUgaW1wb3J0IGluIGVjIGV4dGVuc2lvbnMuXG4gKiBNb3VudCBhIG1ldGhvZCBcImlzSW5zdGFuY2UoKVwiIHRvIENsei5cbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVDbGFzc0NoZWNrKENseikge1xuICB2YXIgY2xhc3NBdHRyID0gWydfX1xcMGlzX2NseicsIGNsYXNzQmFzZSsrLCBNYXRoLnJhbmRvbSgpLnRvRml4ZWQoMyldLmpvaW4oJ18nKTtcbiAgQ2x6LnByb3RvdHlwZVtjbGFzc0F0dHJdID0gdHJ1ZTtcblxuICBDbHouaXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9ialtjbGFzc0F0dHJdKTtcbiAgfTtcbn0gLy8gc3VwZXJDYWxsIHNob3VsZCBoYXZlIGNsYXNzIGluZm8sIHdoaWNoIGNhbiBub3QgYmUgZmV0Y2ggZnJvbSAndGhpcycuXG4vLyBDb25zaWRlciB0aGlzIGNhc2U6XG4vLyBjbGFzcyBBIGhhcyBtZXRob2QgZixcbi8vIGNsYXNzIEIgaW5oZXJpdHMgY2xhc3MgQSwgb3ZlcnJpZGVzIG1ldGhvZCBmLCBmIGNhbGwgc3VwZXJBcHBseSgnZicpLFxuLy8gY2xhc3MgQyBpbmhlcml0cyBjbGFzcyBCLCBkbyBub3Qgb3ZlcnJpZGVzIG1ldGhvZCBmLFxuLy8gdGhlbiB3aGVuIG1ldGhvZCBvZiBjbGFzcyBDIGlzIGNhbGxlZCwgZGVhZCBsb29wIG9jY3VyZWQuXG5cblxuZnVuY3Rpb24gc3VwZXJDYWxsKGNvbnRleHQsIG1ldGhvZE5hbWUpIHtcbiAgdmFyIGFyZ3MgPSB6clV0aWwuc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XG59XG5cbmZ1bmN0aW9uIHN1cGVyQXBwbHkoY29udGV4dCwgbWV0aG9kTmFtZSwgYXJncykge1xuICByZXR1cm4gdGhpcy5zdXBlckNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseShjb250ZXh0LCBhcmdzKTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGVudGl0eVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kXVxuICogQHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KGVudGl0eSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgLyoqXG4gICAqIENvbXBvbmVudCBtb2RlbCBjbGFzc2VzXG4gICAqIGtleTogY29tcG9uZW50VHlwZSxcbiAgICogdmFsdWU6XG4gICAqICAgICBjb21wb25lbnRDbGFzcywgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgnXG4gICAqICAgICBvciBPYmplY3QuPHN1YktleSwgY29tcG9uZW50Q2xhc3M+LCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eC55eSdcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdmFyIHN0b3JhZ2UgPSB7fTtcblxuICBlbnRpdHkucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChDbGF6eiwgY29tcG9uZW50VHlwZSkge1xuICAgIGlmIChjb21wb25lbnRUeXBlKSB7XG4gICAgICBjaGVja0NsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcblxuICAgICAgaWYgKCFjb21wb25lbnRUeXBlLnN1Yikge1xuICAgICAgICBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0gPSBDbGF6ejtcbiAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50VHlwZS5zdWIgIT09IElTX0NPTlRBSU5FUikge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKTtcbiAgICAgICAgY29udGFpbmVyW2NvbXBvbmVudFR5cGUuc3ViXSA9IENsYXp6O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDbGF6ejtcbiAgfTtcblxuICBlbnRpdHkuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50TWFpblR5cGUsIHN1YlR5cGUsIHRocm93V2hlbk5vdEZvdW5kKSB7XG4gICAgdmFyIENsYXp6ID0gc3RvcmFnZVtjb21wb25lbnRNYWluVHlwZV07XG5cbiAgICBpZiAoQ2xhenogJiYgQ2xhenpbSVNfQ09OVEFJTkVSXSkge1xuICAgICAgQ2xhenogPSBzdWJUeXBlID8gQ2xhenpbc3ViVHlwZV0gOiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aHJvd1doZW5Ob3RGb3VuZCAmJiAhQ2xhenopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcighc3ViVHlwZSA/IGNvbXBvbmVudE1haW5UeXBlICsgJy4nICsgJ3R5cGUgc2hvdWxkIGJlIHNwZWNpZmllZC4nIDogJ0NvbXBvbmVudCAnICsgY29tcG9uZW50TWFpblR5cGUgKyAnLicgKyAoc3ViVHlwZSB8fCAnJykgKyAnIG5vdCBleGlzdHMuIExvYWQgaXQgZmlyc3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENsYXp6O1xuICB9O1xuXG4gIGVudGl0eS5nZXRDbGFzc2VzQnlNYWluVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuXG4gICAgaWYgKG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXSkge1xuICAgICAgenJVdGlsLmVhY2gob2JqLCBmdW5jdGlvbiAobywgdHlwZSkge1xuICAgICAgICB0eXBlICE9PSBJU19DT05UQUlORVIgJiYgcmVzdWx0LnB1c2gobyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gob2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGVudGl0eS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgLy8gSnVzdCBjb25zaWRlciBjb21wb25lbnRUeXBlLm1haW4uXG4gICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgIHJldHVybiAhIXN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBMaWtlIFsnYWEnLCAnYmInXSwgYnV0IGNhbiBub3QgYmUgWydhYS54eCddXG4gICAqL1xuXG5cbiAgZW50aXR5LmdldEFsbENsYXNzTWFpblR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlcyA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKHN0b3JhZ2UsIGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcbiAgICAgIHR5cGVzLnB1c2godHlwZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9O1xuICAvKipcbiAgICogSWYgYSBtYWluIHR5cGUgaXMgY29udGFpbmVyIGFuZCBoYXMgc3ViIHR5cGVzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG1haW5UeXBlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgZW50aXR5Lmhhc1N1YlR5cGVzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcbiAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG4gICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcbiAgICByZXR1cm4gb2JqICYmIG9ialtJU19DT05UQUlORVJdO1xuICB9O1xuXG4gIGVudGl0eS5wYXJzZUNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlO1xuXG4gIGZ1bmN0aW9uIG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZSkge1xuICAgIHZhciBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XG5cbiAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyW0lTX0NPTlRBSU5FUl0pIHtcbiAgICAgIGNvbnRhaW5lciA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IHt9O1xuICAgICAgY29udGFpbmVyW0lTX0NPTlRBSU5FUl0gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZWdpc3RlcldoZW5FeHRlbmQpIHtcbiAgICB2YXIgb3JpZ2luYWxFeHRlbmQgPSBlbnRpdHkuZXh0ZW5kO1xuXG4gICAgaWYgKG9yaWdpbmFsRXh0ZW5kKSB7XG4gICAgICBlbnRpdHkuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XG4gICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gb3JpZ2luYWxFeHRlbmQuY2FsbCh0aGlzLCBwcm90byk7XG4gICAgICAgIHJldHVybiBlbnRpdHkucmVnaXN0ZXJDbGFzcyhFeHRlbmRlZENsYXNzLCBwcm90by50eXBlKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVudGl0eTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IHByb3BlcnRpZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFJlYWRPbmx5KG9iaiwgcHJvcGVydGllcykgey8vIEZJWE1FIEl0IHNlZW1zIGJyb2tlbiBpbiBJRTggc2ltdWxhdGlvbiBvZiBJRTExXG4gIC8vIGlmICghenJVdGlsLmlzQXJyYXkocHJvcGVydGllcykpIHtcbiAgLy8gICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzICE9IG51bGwgPyBbcHJvcGVydGllc10gOiBbXTtcbiAgLy8gfVxuICAvLyB6clV0aWwuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbiAocHJvcCkge1xuICAvLyAgICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAvLyAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gIC8vICAgICAgICAgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAvLyAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsIHdyaXRhYmxlOiBmYWxzZVxuICAvLyAgICAgICAgIH0pO1xuICAvLyAgICAgenJVdGlsLmlzQXJyYXkob2JqW3Byb3BdKVxuICAvLyAgICAgICAgICYmIE9iamVjdC5mcmVlemVcbiAgLy8gICAgICAgICAmJiBPYmplY3QuZnJlZXplKG9ialtwcm9wXSk7XG4gIC8vIH0pO1xufVxuXG5leHBvcnRzLnBhcnNlQ2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGU7XG5leHBvcnRzLmVuYWJsZUNsYXNzRXh0ZW5kID0gZW5hYmxlQ2xhc3NFeHRlbmQ7XG5leHBvcnRzLmVuYWJsZUNsYXNzQ2hlY2sgPSBlbmFibGVDbGFzc0NoZWNrO1xuZXhwb3J0cy5lbmFibGVDbGFzc01hbmFnZW1lbnQgPSBlbmFibGVDbGFzc01hbmFnZW1lbnQ7XG5leHBvcnRzLnNldFJlYWRPbmx5ID0gc2V0UmVhZE9ubHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9jbGF6ei5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9jbGF6ei5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgX2NsYXp6ID0gcmVxdWlyZShcIi4vY2xhenpcIik7XG5cbnZhciBwYXJzZUNsYXNzVHlwZSA9IF9jbGF6ei5wYXJzZUNsYXNzVHlwZTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGJhc2UgPSAwO1xuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldFVJRCh0eXBlKSB7XG4gIC8vIENvbnNpZGVyaW5nIHRoZSBjYXNlIG9mIGNyb3NzaW5nIGpzIGNvbnRleHQsXG4gIC8vIHVzZSBNYXRoLnJhbmRvbSB0byBtYWtlIGlkIGFzIHVuaXF1ZSBhcyBwb3NzaWJsZS5cbiAgcmV0dXJuIFt0eXBlIHx8ICcnLCBiYXNlKyssIE1hdGgucmFuZG9tKCkudG9GaXhlZCg1KV0uam9pbignXycpO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuYWJsZVN1YlR5cGVEZWZhdWx0ZXIoZW50aXR5KSB7XG4gIHZhciBzdWJUeXBlRGVmYXVsdGVycyA9IHt9O1xuXG4gIGVudGl0eS5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgZGVmYXVsdGVyKSB7XG4gICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgIHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGUubWFpbl0gPSBkZWZhdWx0ZXI7XG4gIH07XG5cbiAgZW50aXR5LmRldGVybWluZVN1YlR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgb3B0aW9uKSB7XG4gICAgdmFyIHR5cGUgPSBvcHRpb24udHlwZTtcblxuICAgIGlmICghdHlwZSkge1xuICAgICAgdmFyIGNvbXBvbmVudFR5cGVNYWluID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSkubWFpbjtcblxuICAgICAgaWYgKGVudGl0eS5oYXNTdWJUeXBlcyhjb21wb25lbnRUeXBlKSAmJiBzdWJUeXBlRGVmYXVsdGVyc1tjb21wb25lbnRUeXBlTWFpbl0pIHtcbiAgICAgICAgdHlwZSA9IHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGVNYWluXShvcHRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9O1xuXG4gIHJldHVybiBlbnRpdHk7XG59XG4vKipcbiAqIFRvcG9sb2dpY2FsIHRyYXZlbCBvbiBBY3Rpdml0eSBOZXR3b3JrIChBY3Rpdml0eSBPbiBWZXJ0aWNlcykuXG4gKiBEZXBlbmRlbmNpZXMgaXMgZGVmaW5lZCBpbiBNb2RlbC5wcm90b3R5cGUuZGVwZW5kZW5jaWVzLCBsaWtlIFsneEF4aXMnLCAneUF4aXMnXS5cbiAqXG4gKiBJZiAneEF4aXMnIG9yICd5QXhpcycgaXMgYWJzZW50IGluIGNvbXBvbmVudFR5cGVMaXN0LCBqdXN0IGlnbm9yZSBpdCBpbiB0b3BvbG9neS5cbiAqXG4gKiBJZiB0aGVyZSBpcyBjaXJjbGUgZGVwZW5kZW5jZXksIEVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsKGVudGl0eSwgZGVwZW5kZW5jeUdldHRlcikge1xuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB0YXJnZXROYW1lTGlzdCBUYXJnZXQgQ29tcG9uZW50IHR5cGUgbGlzdC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlIFsnYWEnLCAnYmInLCAnYWEueHgnXVxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBmdWxsTmFtZUxpc3QgQnkgd2hpY2ggd2UgY2FuIGJ1aWxkIGRlcGVuZGVuY3kgZ3JhcGguXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFBhcmFtczogY29tcG9uZW50VHlwZSwgZGVwZW5kZW5jaWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBTY29wZSBvZiBjYWxsYmFjay5cbiAgICovXG4gIGVudGl0eS50b3BvbG9naWNhbFRyYXZlbCA9IGZ1bmN0aW9uICh0YXJnZXROYW1lTGlzdCwgZnVsbE5hbWVMaXN0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmICghdGFyZ2V0TmFtZUxpc3QubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IG1ha2VEZXBuZGVuY3lHcmFwaChmdWxsTmFtZUxpc3QpO1xuICAgIHZhciBncmFwaCA9IHJlc3VsdC5ncmFwaDtcbiAgICB2YXIgc3RhY2sgPSByZXN1bHQubm9FbnRyeUxpc3Q7XG4gICAgdmFyIHRhcmdldE5hbWVTZXQgPSB7fTtcbiAgICB6clV0aWwuZWFjaCh0YXJnZXROYW1lTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRhcmdldE5hbWVTZXRbbmFtZV0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJDb21wb25lbnRUeXBlID0gc3RhY2sucG9wKCk7XG4gICAgICB2YXIgY3VyclZlcnRleCA9IGdyYXBoW2N1cnJDb21wb25lbnRUeXBlXTtcbiAgICAgIHZhciBpc0luVGFyZ2V0TmFtZVNldCA9ICEhdGFyZ2V0TmFtZVNldFtjdXJyQ29tcG9uZW50VHlwZV07XG5cbiAgICAgIGlmIChpc0luVGFyZ2V0TmFtZVNldCkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGN1cnJDb21wb25lbnRUeXBlLCBjdXJyVmVydGV4Lm9yaWdpbmFsRGVwcy5zbGljZSgpKTtcbiAgICAgICAgZGVsZXRlIHRhcmdldE5hbWVTZXRbY3VyckNvbXBvbmVudFR5cGVdO1xuICAgICAgfVxuXG4gICAgICB6clV0aWwuZWFjaChjdXJyVmVydGV4LnN1Y2Nlc3NvciwgaXNJblRhcmdldE5hbWVTZXQgPyByZW1vdmVFZGdlQW5kQWRkIDogcmVtb3ZlRWRnZSk7XG4gICAgfVxuXG4gICAgenJVdGlsLmVhY2godGFyZ2V0TmFtZVNldCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgZGVwZW5kZW5jeSBtYXkgZXhpc3RzJyk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFZGdlKHN1Y2NDb21wb25lbnRUeXBlKSB7XG4gICAgICBncmFwaFtzdWNjQ29tcG9uZW50VHlwZV0uZW50cnlDb3VudC0tO1xuXG4gICAgICBpZiAoZ3JhcGhbc3VjY0NvbXBvbmVudFR5cGVdLmVudHJ5Q291bnQgPT09IDApIHtcbiAgICAgICAgc3RhY2sucHVzaChzdWNjQ29tcG9uZW50VHlwZSk7XG4gICAgICB9XG4gICAgfSAvLyBDb25zaWRlciB0aGlzIGNhc2U6IGxlZ2VuZCBkZXBlbmRzIG9uIHNlcmllcywgYW5kIHdlIGNhbGxcbiAgICAvLyBjaGFydC5zZXRPcHRpb24oe3NlcmllczogWy4uLl19KSwgd2hlcmUgb25seSBzZXJpZXMgaXMgaW4gb3B0aW9uLlxuICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlICdyZW1vdmVFZGdlQW5kQWRkJywgbGVnZW5kTW9kZWwubWVyZ2VPcHRpb24gd2lsbFxuICAgIC8vIG5vdCBiZSBjYWxsZWQsIGJ1dCBvbmx5IHNlcmVpcy5tZXJnZU9wdGlvbiBpcyBjYWxsZWQuIFRodXMgbGVnZW5kXG4gICAgLy8gaGF2ZSBubyBjaGFuY2UgdG8gdXBkYXRlIGl0cyBsb2NhbCByZWNvcmQgYWJvdXQgc2VyaWVzIChsaWtlIHdoaWNoXG4gICAgLy8gbmFtZSBvZiBzZXJpZXMgaXMgYXZhaWxhYmxlIGluIGxlZ2VuZCkuXG5cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVkZ2VBbmRBZGQoc3VjY0NvbXBvbmVudFR5cGUpIHtcbiAgICAgIHRhcmdldE5hbWVTZXRbc3VjY0NvbXBvbmVudFR5cGVdID0gdHJ1ZTtcbiAgICAgIHJlbW92ZUVkZ2Uoc3VjY0NvbXBvbmVudFR5cGUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIERlcG5kZW5jeUdyYXBoOiB7T2JqZWN0fVxuICAgKiBrZXk6IGNvbnBvbmVudFR5cGUsXG4gICAqIHZhbHVlOiB7XG4gICAqICAgICBzdWNjZXNzb3I6IFtjb25wb25lbnRUeXBlcy4uLl0sXG4gICAqICAgICBvcmlnaW5hbERlcHM6IFtjb25wb25lbnRUeXBlcy4uLl0sXG4gICAqICAgICBlbnRyeUNvdW50OiB7bnVtYmVyfVxuICAgKiB9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbWFrZURlcG5kZW5jeUdyYXBoKGZ1bGxOYW1lTGlzdCkge1xuICAgIHZhciBncmFwaCA9IHt9O1xuICAgIHZhciBub0VudHJ5TGlzdCA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKGZ1bGxOYW1lTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB0aGlzSXRlbSA9IGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIG5hbWUpO1xuICAgICAgdmFyIG9yaWdpbmFsRGVwcyA9IHRoaXNJdGVtLm9yaWdpbmFsRGVwcyA9IGRlcGVuZGVuY3lHZXR0ZXIobmFtZSk7XG4gICAgICB2YXIgYXZhaWxhYmxlRGVwcyA9IGdldEF2YWlsYWJsZURlcGVuZGVuY2llcyhvcmlnaW5hbERlcHMsIGZ1bGxOYW1lTGlzdCk7XG4gICAgICB0aGlzSXRlbS5lbnRyeUNvdW50ID0gYXZhaWxhYmxlRGVwcy5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzSXRlbS5lbnRyeUNvdW50ID09PSAwKSB7XG4gICAgICAgIG5vRW50cnlMaXN0LnB1c2gobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHpyVXRpbC5lYWNoKGF2YWlsYWJsZURlcHMsIGZ1bmN0aW9uIChkZXBlbmRlbnROYW1lKSB7XG4gICAgICAgIGlmICh6clV0aWwuaW5kZXhPZih0aGlzSXRlbS5wcmVkZWNlc3NvciwgZGVwZW5kZW50TmFtZSkgPCAwKSB7XG4gICAgICAgICAgdGhpc0l0ZW0ucHJlZGVjZXNzb3IucHVzaChkZXBlbmRlbnROYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGF0SXRlbSA9IGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIGRlcGVuZGVudE5hbWUpO1xuXG4gICAgICAgIGlmICh6clV0aWwuaW5kZXhPZih0aGF0SXRlbS5zdWNjZXNzb3IsIGRlcGVuZGVudE5hbWUpIDwgMCkge1xuICAgICAgICAgIHRoYXRJdGVtLnN1Y2Nlc3Nvci5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZ3JhcGg6IGdyYXBoLFxuICAgICAgbm9FbnRyeUxpc3Q6IG5vRW50cnlMaXN0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIG5hbWUpIHtcbiAgICBpZiAoIWdyYXBoW25hbWVdKSB7XG4gICAgICBncmFwaFtuYW1lXSA9IHtcbiAgICAgICAgcHJlZGVjZXNzb3I6IFtdLFxuICAgICAgICBzdWNjZXNzb3I6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBncmFwaFtuYW1lXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF2YWlsYWJsZURlcGVuZGVuY2llcyhvcmlnaW5hbERlcHMsIGZ1bGxOYW1lTGlzdCkge1xuICAgIHZhciBhdmFpbGFibGVEZXBzID0gW107XG4gICAgenJVdGlsLmVhY2gob3JpZ2luYWxEZXBzLCBmdW5jdGlvbiAoZGVwKSB7XG4gICAgICB6clV0aWwuaW5kZXhPZihmdWxsTmFtZUxpc3QsIGRlcCkgPj0gMCAmJiBhdmFpbGFibGVEZXBzLnB1c2goZGVwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXZhaWxhYmxlRGVwcztcbiAgfVxufVxuXG5leHBvcnRzLmdldFVJRCA9IGdldFVJRDtcbmV4cG9ydHMuZW5hYmxlU3ViVHlwZURlZmF1bHRlciA9IGVuYWJsZVN1YlR5cGVEZWZhdWx0ZXI7XG5leHBvcnRzLmVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsID0gZW5hYmxlVG9wb2xvZ2ljYWxUcmF2ZWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9jb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvY29tcG9uZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluL3RleHRcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4vbnVtYmVyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICog5q+P5LiJ5L2N6buY6K6k5YqgLOagvOW8j+WMllxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGFkZENvbW1hcyh4KSB7XG4gIGlmIChpc05hTih4KSkge1xuICAgIHJldHVybiAnLSc7XG4gIH1cblxuICB4ID0gKHggKyAnJykuc3BsaXQoJy4nKTtcbiAgcmV0dXJuIHhbMF0ucmVwbGFjZSgvKFxcZHsxLDN9KSg/PSg/OlxcZHszfSkrKD8hXFxkKSkvZywgJyQxLCcpICsgKHgubGVuZ3RoID4gMSA/ICcuJyArIHhbMV0gOiAnJyk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwcGVyQ2FzZUZpcnN0PWZhbHNlXVxuICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0ciwgdXBwZXJDYXNlRmlyc3QpIHtcbiAgc3RyID0gKHN0ciB8fCAnJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uIChtYXRjaCwgZ3JvdXAxKSB7XG4gICAgcmV0dXJuIGdyb3VwMS50b1VwcGVyQ2FzZSgpO1xuICB9KTtcblxuICBpZiAodXBwZXJDYXNlRmlyc3QgJiYgc3RyKSB7XG4gICAgc3RyID0gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIG5vcm1hbGl6ZUNzc0FycmF5ID0genJVdGlsLm5vcm1hbGl6ZUNzc0FycmF5O1xudmFyIHJlcGxhY2VSZWcgPSAvKFsmPD5cIiddKS9nO1xudmFyIHJlcGxhY2VNYXAgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgJ1xcJyc6ICcmIzM5Oydcbn07XG5cbmZ1bmN0aW9uIGVuY29kZUhUTUwoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgPT0gbnVsbCA/ICcnIDogKHNvdXJjZSArICcnKS5yZXBsYWNlKHJlcGxhY2VSZWcsIGZ1bmN0aW9uIChzdHIsIGMpIHtcbiAgICByZXR1cm4gcmVwbGFjZU1hcFtjXTtcbiAgfSk7XG59XG5cbnZhciBUUExfVkFSX0FMSUFTID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJ107XG5cbnZhciB3cmFwVmFyID0gZnVuY3Rpb24gKHZhck5hbWUsIHNlcmllc0lkeCkge1xuICByZXR1cm4gJ3snICsgdmFyTmFtZSArIChzZXJpZXNJZHggPT0gbnVsbCA/ICcnIDogc2VyaWVzSWR4KSArICd9Jztcbn07XG4vKipcbiAqIFRlbXBsYXRlIGZvcm1hdHRlclxuICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0PnxPYmplY3R9IHBhcmFtc0xpc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuY29kZT1mYWxzZV1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdFRwbCh0cGwsIHBhcmFtc0xpc3QsIGVuY29kZSkge1xuICBpZiAoIXpyVXRpbC5pc0FycmF5KHBhcmFtc0xpc3QpKSB7XG4gICAgcGFyYW1zTGlzdCA9IFtwYXJhbXNMaXN0XTtcbiAgfVxuXG4gIHZhciBzZXJpZXNMZW4gPSBwYXJhbXNMaXN0Lmxlbmd0aDtcblxuICBpZiAoIXNlcmllc0xlbikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciAkdmFycyA9IHBhcmFtc0xpc3RbMF0uJHZhcnMgfHwgW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAkdmFycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhbGlhcyA9IFRQTF9WQVJfQUxJQVNbaV07XG4gICAgdHBsID0gdHBsLnJlcGxhY2Uod3JhcFZhcihhbGlhcyksIHdyYXBWYXIoYWxpYXMsIDApKTtcbiAgfVxuXG4gIGZvciAodmFyIHNlcmllc0lkeCA9IDA7IHNlcmllc0lkeCA8IHNlcmllc0xlbjsgc2VyaWVzSWR4KyspIHtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8ICR2YXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICB2YXIgdmFsID0gcGFyYW1zTGlzdFtzZXJpZXNJZHhdWyR2YXJzW2tdXTtcbiAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHdyYXBWYXIoVFBMX1ZBUl9BTElBU1trXSwgc2VyaWVzSWR4KSwgZW5jb2RlID8gZW5jb2RlSFRNTCh2YWwpIDogdmFsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHBsO1xufVxuLyoqXG4gKiBzaW1wbGUgVGVtcGxhdGUgZm9ybWF0dGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmNvZGU9ZmFsc2VdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRUcGxTaW1wbGUodHBsLCBwYXJhbSwgZW5jb2RlKSB7XG4gIHpyVXRpbC5lYWNoKHBhcmFtLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHRwbCA9IHRwbC5yZXBsYWNlKCd7JyArIGtleSArICd9JywgZW5jb2RlID8gZW5jb2RlSFRNTCh2YWx1ZSkgOiB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gdHBsO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRdIElmIHN0cmluZywgbWVhbnMgY29sb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdC5jb2xvcl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmV4dHJhQ3NzVGV4dF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LnR5cGU9J2l0ZW0nXSAnaXRlbScgb3IgJ3N1Ykl0ZW0nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRUb29sdGlwTWFya2VyKG9wdCwgZXh0cmFDc3NUZXh0KSB7XG4gIG9wdCA9IHpyVXRpbC5pc1N0cmluZyhvcHQpID8ge1xuICAgIGNvbG9yOiBvcHQsXG4gICAgZXh0cmFDc3NUZXh0OiBleHRyYUNzc1RleHRcbiAgfSA6IG9wdCB8fCB7fTtcbiAgdmFyIGNvbG9yID0gb3B0LmNvbG9yO1xuICB2YXIgdHlwZSA9IG9wdC50eXBlO1xuICB2YXIgZXh0cmFDc3NUZXh0ID0gb3B0LmV4dHJhQ3NzVGV4dDtcblxuICBpZiAoIWNvbG9yKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIHR5cGUgPT09ICdzdWJJdGVtJyA/ICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTttYXJnaW4tcmlnaHQ6OHB4O21hcmdpbi1sZWZ0OjNweDsnICsgJ2JvcmRlci1yYWRpdXM6NHB4O3dpZHRoOjRweDtoZWlnaHQ6NHB4O2JhY2tncm91bmQtY29sb3I6JyArIGVuY29kZUhUTUwoY29sb3IpICsgJzsnICsgKGV4dHJhQ3NzVGV4dCB8fCAnJykgKyAnXCI+PC9zcGFuPicgOiAnPHNwYW4gc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tcmlnaHQ6NXB4OycgKyAnYm9yZGVyLXJhZGl1czoxMHB4O3dpZHRoOjEwcHg7aGVpZ2h0OjEwcHg7YmFja2dyb3VuZC1jb2xvcjonICsgZW5jb2RlSFRNTChjb2xvcikgKyAnOycgKyAoZXh0cmFDc3NUZXh0IHx8ICcnKSArICdcIj48L3NwYW4+Jztcbn1cblxuZnVuY3Rpb24gcGFkKHN0ciwgbGVuKSB7XG4gIHN0ciArPSAnJztcbiAgcmV0dXJuICcwMDAwJy5zdWJzdHIoMCwgbGVuIC0gc3RyLmxlbmd0aCkgKyBzdHI7XG59XG4vKipcbiAqIElTTyBEYXRlIGZvcm1hdFxuICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1VUQz1mYWxzZV0gRGVmYXVsdCBpbiBsb2NhbCB0aW1lLlxuICogICAgICAgICAgIHNlZSBgbW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZWBcbiAqICAgICAgICAgICBhbmQgYG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyI3BhcnNlRGF0ZWAuXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWUodHBsLCB2YWx1ZSwgaXNVVEMpIHtcbiAgaWYgKHRwbCA9PT0gJ3dlZWsnIHx8IHRwbCA9PT0gJ21vbnRoJyB8fCB0cGwgPT09ICdxdWFydGVyJyB8fCB0cGwgPT09ICdoYWxmLXllYXInIHx8IHRwbCA9PT0gJ3llYXInKSB7XG4gICAgdHBsID0gJ01NLWRkXFxueXl5eSc7XG4gIH1cblxuICB2YXIgZGF0ZSA9IG51bWJlclV0aWwucGFyc2VEYXRlKHZhbHVlKTtcbiAgdmFyIHV0YyA9IGlzVVRDID8gJ1VUQycgOiAnJztcbiAgdmFyIHkgPSBkYXRlWydnZXQnICsgdXRjICsgJ0Z1bGxZZWFyJ10oKTtcbiAgdmFyIE0gPSBkYXRlWydnZXQnICsgdXRjICsgJ01vbnRoJ10oKSArIDE7XG4gIHZhciBkID0gZGF0ZVsnZ2V0JyArIHV0YyArICdEYXRlJ10oKTtcbiAgdmFyIGggPSBkYXRlWydnZXQnICsgdXRjICsgJ0hvdXJzJ10oKTtcbiAgdmFyIG0gPSBkYXRlWydnZXQnICsgdXRjICsgJ01pbnV0ZXMnXSgpO1xuICB2YXIgcyA9IGRhdGVbJ2dldCcgKyB1dGMgKyAnU2Vjb25kcyddKCk7XG4gIHZhciBTID0gZGF0ZVsnZ2V0JyArIHV0YyArICdNaWxsaXNlY29uZHMnXSgpO1xuICB0cGwgPSB0cGwucmVwbGFjZSgnTU0nLCBwYWQoTSwgMikpLnJlcGxhY2UoJ00nLCBNKS5yZXBsYWNlKCd5eXl5JywgeSkucmVwbGFjZSgneXknLCB5ICUgMTAwKS5yZXBsYWNlKCdkZCcsIHBhZChkLCAyKSkucmVwbGFjZSgnZCcsIGQpLnJlcGxhY2UoJ2hoJywgcGFkKGgsIDIpKS5yZXBsYWNlKCdoJywgaCkucmVwbGFjZSgnbW0nLCBwYWQobSwgMikpLnJlcGxhY2UoJ20nLCBtKS5yZXBsYWNlKCdzcycsIHBhZChzLCAyKSkucmVwbGFjZSgncycsIHMpLnJlcGxhY2UoJ1NTUycsIHBhZChTLCAzKSk7XG4gIHJldHVybiB0cGw7XG59XG4vKipcbiAqIENhcGl0YWwgZmlyc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhcGl0YWxGaXJzdChzdHIpIHtcbiAgcmV0dXJuIHN0ciA/IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHIoMSkgOiBzdHI7XG59XG5cbnZhciB0cnVuY2F0ZVRleHQgPSB0ZXh0Q29udGFpbi50cnVuY2F0ZVRleHQ7XG52YXIgZ2V0VGV4dFJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3Q7XG5leHBvcnRzLmFkZENvbW1hcyA9IGFkZENvbW1hcztcbmV4cG9ydHMudG9DYW1lbENhc2UgPSB0b0NhbWVsQ2FzZTtcbmV4cG9ydHMubm9ybWFsaXplQ3NzQXJyYXkgPSBub3JtYWxpemVDc3NBcnJheTtcbmV4cG9ydHMuZW5jb2RlSFRNTCA9IGVuY29kZUhUTUw7XG5leHBvcnRzLmZvcm1hdFRwbCA9IGZvcm1hdFRwbDtcbmV4cG9ydHMuZm9ybWF0VHBsU2ltcGxlID0gZm9ybWF0VHBsU2ltcGxlO1xuZXhwb3J0cy5nZXRUb29sdGlwTWFya2VyID0gZ2V0VG9vbHRpcE1hcmtlcjtcbmV4cG9ydHMuZm9ybWF0VGltZSA9IGZvcm1hdFRpbWU7XG5leHBvcnRzLmNhcGl0YWxGaXJzdCA9IGNhcGl0YWxGaXJzdDtcbmV4cG9ydHMudHJ1bmNhdGVUZXh0ID0gdHJ1bmNhdGVUZXh0O1xuZXhwb3J0cy5nZXRUZXh0UmVjdCA9IGdldFRleHRSZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvZm9ybWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2Zvcm1hdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgcGF0aFRvb2wgPSByZXF1aXJlKFwienJlbmRlci9saWIvdG9vbC9wYXRoXCIpO1xuXG52YXIgY29sb3JUb29sID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3Rvb2wvY29sb3JcIik7XG5cbnZhciBtYXRyaXggPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9tYXRyaXhcIik7XG5cbnZhciB2ZWN0b3IgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS92ZWN0b3JcIik7XG5cbnZhciBQYXRoID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKFwienJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZVwiKTtcblxudmFyIFpJbWFnZSA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlXCIpO1xuXG5leHBvcnRzLkltYWdlID0gWkltYWdlO1xuXG52YXIgR3JvdXAgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwXCIpO1xuXG5leHBvcnRzLkdyb3VwID0gR3JvdXA7XG5cbnZhciBUZXh0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvVGV4dFwiKTtcblxuZXhwb3J0cy5UZXh0ID0gVGV4dDtcblxudmFyIENpcmNsZSA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZVwiKTtcblxuZXhwb3J0cy5DaXJjbGUgPSBDaXJjbGU7XG5cbnZhciBTZWN0b3IgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcIik7XG5cbmV4cG9ydHMuU2VjdG9yID0gU2VjdG9yO1xuXG52YXIgUmluZyA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmdcIik7XG5cbmV4cG9ydHMuUmluZyA9IFJpbmc7XG5cbnZhciBQb2x5Z29uID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvblwiKTtcblxuZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcblxudmFyIFBvbHlsaW5lID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmVcIik7XG5cbmV4cG9ydHMuUG9seWxpbmUgPSBQb2x5bGluZTtcblxudmFyIFJlY3QgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0XCIpO1xuXG5leHBvcnRzLlJlY3QgPSBSZWN0O1xuXG52YXIgTGluZSA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmVcIik7XG5cbmV4cG9ydHMuTGluZSA9IExpbmU7XG5cbnZhciBCZXppZXJDdXJ2ZSA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlXCIpO1xuXG5leHBvcnRzLkJlemllckN1cnZlID0gQmV6aWVyQ3VydmU7XG5cbnZhciBBcmMgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmNcIik7XG5cbmV4cG9ydHMuQXJjID0gQXJjO1xuXG52YXIgQ29tcG91bmRQYXRoID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvQ29tcG91bmRQYXRoXCIpO1xuXG5leHBvcnRzLkNvbXBvdW5kUGF0aCA9IENvbXBvdW5kUGF0aDtcblxudmFyIExpbmVhckdyYWRpZW50ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnRcIik7XG5cbmV4cG9ydHMuTGluZWFyR3JhZGllbnQgPSBMaW5lYXJHcmFkaWVudDtcblxudmFyIFJhZGlhbEdyYWRpZW50ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnRcIik7XG5cbmV4cG9ydHMuUmFkaWFsR3JhZGllbnQgPSBSYWRpYWxHcmFkaWVudDtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxuZXhwb3J0cy5Cb3VuZGluZ1JlY3QgPSBCb3VuZGluZ1JlY3Q7XG5cbnZhciBJbmNyZW1lbnRhbERpc3BsYXlhYmxlID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvSW5jcmVtZW50YWxEaXNwbGF5YWJsZVwiKTtcblxuZXhwb3J0cy5JbmNyZW1lbnRhbERpc3BsYXlhYmxlID0gSW5jcmVtZW50YWxEaXNwbGF5YWJsZTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIEVNUFRZX09CSiA9IHt9O1xuLyoqXG4gKiBFeHRlbmQgc2hhcGUgd2l0aCBwYXJhbWV0ZXJzXG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5kU2hhcGUob3B0cykge1xuICByZXR1cm4gUGF0aC5leHRlbmQob3B0cyk7XG59XG4vKipcbiAqIEV4dGVuZCBwYXRoXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRQYXRoKHBhdGhEYXRhLCBvcHRzKSB7XG4gIHJldHVybiBwYXRoVG9vbC5leHRlbmRGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCBlbGVtZW50IGZyb20gcGF0aCBkYXRhIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhEYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQ9Y292ZXJdICdjZW50ZXInIG9yICdjb3ZlcidcbiAqL1xuXG5cbmZ1bmN0aW9uIG1ha2VQYXRoKHBhdGhEYXRhLCBvcHRzLCByZWN0LCBsYXlvdXQpIHtcbiAgdmFyIHBhdGggPSBwYXRoVG9vbC5jcmVhdGVGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcbiAgdmFyIGJvdW5kaW5nUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgaWYgKHJlY3QpIHtcbiAgICBpZiAobGF5b3V0ID09PSAnY2VudGVyJykge1xuICAgICAgcmVjdCA9IGNlbnRlckdyYXBoaWMocmVjdCwgYm91bmRpbmdSZWN0KTtcbiAgICB9XG5cbiAgICByZXNpemVQYXRoKHBhdGgsIHJlY3QpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIENyZWF0ZSBhIGltYWdlIGVsZW1lbnQgZnJvbSBpbWFnZSB1cmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVVybCBpbWFnZSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbnNcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3QgY29uc3RyYWluIHJlY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0PWNvdmVyXSAnY2VudGVyJyBvciAnY292ZXInXG4gKi9cblxuXG5mdW5jdGlvbiBtYWtlSW1hZ2UoaW1hZ2VVcmwsIHJlY3QsIGxheW91dCkge1xuICB2YXIgcGF0aCA9IG5ldyBaSW1hZ2Uoe1xuICAgIHN0eWxlOiB7XG4gICAgICBpbWFnZTogaW1hZ2VVcmwsXG4gICAgICB4OiByZWN0LngsXG4gICAgICB5OiByZWN0LnksXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICB9LFxuICAgIG9ubG9hZDogZnVuY3Rpb24gKGltZykge1xuICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHtcbiAgICAgICAgICB3aWR0aDogaW1nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaW1nLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBwYXRoLnNldFN0eWxlKGNlbnRlckdyYXBoaWMocmVjdCwgYm91bmRpbmdSZWN0KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIEdldCBwb3NpdGlvbiBvZiBjZW50ZXJlZCBlbGVtZW50IGluIGJvdW5kaW5nIGJveC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlY3QgICAgICAgICBlbGVtZW50IGxvY2FsIGJvdW5kaW5nIGJveFxuICogQHBhcmFtICB7T2JqZWN0fSBib3VuZGluZ1JlY3QgY29uc3RyYWludCBib3VuZGluZyBib3hcbiAqIEByZXR1cm4ge09iamVjdH0gZWxlbWVudCBwb3NpdGlvbiBjb250YWluaW5nIHgsIHksIHdpZHRoLCBhbmQgaGVpZ2h0XG4gKi9cblxuXG5mdW5jdGlvbiBjZW50ZXJHcmFwaGljKHJlY3QsIGJvdW5kaW5nUmVjdCkge1xuICAvLyBTZXQgcmVjdCB0byBjZW50ZXIsIGtlZXAgd2lkdGggLyBoZWlnaHQgcmF0aW8uXG4gIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xuICB2YXIgd2lkdGggPSByZWN0LmhlaWdodCAqIGFzcGVjdDtcbiAgdmFyIGhlaWdodDtcblxuICBpZiAod2lkdGggPD0gcmVjdC53aWR0aCkge1xuICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgfVxuXG4gIHZhciBjeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xuICB2YXIgY3kgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XG4gIHJldHVybiB7XG4gICAgeDogY3ggLSB3aWR0aCAvIDIsXG4gICAgeTogY3kgLSBoZWlnaHQgLyAyLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG52YXIgbWVyZ2VQYXRoID0gcGF0aFRvb2wubWVyZ2VQYXRoO1xuLyoqXG4gKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gKi9cblxuZnVuY3Rpb24gcmVzaXplUGF0aChwYXRoLCByZWN0KSB7XG4gIGlmICghcGF0aC5hcHBseVRyYW5zZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xuICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgbGluZSBmb3IgY2FudmFzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngyXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55Ml1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cbiAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YlBpeGVsT3B0aW1pemVMaW5lKHBhcmFtKSB7XG4gIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xuICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xuXG4gIGlmIChyb3VuZChzaGFwZS54MSAqIDIpID09PSByb3VuZChzaGFwZS54MiAqIDIpKSB7XG4gICAgc2hhcGUueDEgPSBzaGFwZS54MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueDEsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gIH1cblxuICBpZiAocm91bmQoc2hhcGUueTEgKiAyKSA9PT0gcm91bmQoc2hhcGUueTIgKiAyKSkge1xuICAgIHNoYXBlLnkxID0gc2hhcGUueTIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnkxLCBsaW5lV2lkdGgsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgcmVjdCBmb3IgY2FudmFzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54XVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55XVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS53aWR0aF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUuaGVpZ2h0XVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxuICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxuICovXG5cblxuZnVuY3Rpb24gc3ViUGl4ZWxPcHRpbWl6ZVJlY3QocGFyYW0pIHtcbiAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XG4gIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XG4gIHZhciBvcmlnaW5YID0gc2hhcGUueDtcbiAgdmFyIG9yaWdpblkgPSBzaGFwZS55O1xuICB2YXIgb3JpZ2luV2lkdGggPSBzaGFwZS53aWR0aDtcbiAgdmFyIG9yaWdpbkhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgc2hhcGUueCA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueCwgbGluZVdpZHRoLCB0cnVlKTtcbiAgc2hhcGUueSA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgc2hhcGUud2lkdGggPSBNYXRoLm1heChzdWJQaXhlbE9wdGltaXplKG9yaWdpblggKyBvcmlnaW5XaWR0aCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS54LCBvcmlnaW5XaWR0aCA9PT0gMCA/IDAgOiAxKTtcbiAgc2hhcGUuaGVpZ2h0ID0gTWF0aC5tYXgoc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZICsgb3JpZ2luSGVpZ2h0LCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLnksIG9yaWdpbkhlaWdodCA9PT0gMCA/IDAgOiAxKTtcbiAgcmV0dXJuIHBhcmFtO1xufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgZm9yIGNhbnZhc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBDb29yZGluYXRlLCBzdWNoIGFzIHgsIHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggU2hvdWxkIGJlIG5vbm5lZ2F0aXZlIGludGVnZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBwb3NpdGl2ZU9yTmVnYXRpdmUgRGVmYXVsdCBmYWxzZSAobmVnYXRpdmUpLlxuICogQHJldHVybiB7bnVtYmVyfSBPcHRpbWl6ZWQgcG9zaXRpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJQaXhlbE9wdGltaXplKHBvc2l0aW9uLCBsaW5lV2lkdGgsIHBvc2l0aXZlT3JOZWdhdGl2ZSkge1xuICAvLyBBc3N1cmUgdGhhdCAocG9zaXRpb24gKyBsaW5lV2lkdGggLyAyKSBpcyBuZWFyIGludGVnZXIgZWRnZSxcbiAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXG4gIHZhciBkb3VibGVkUG9zaXRpb24gPSByb3VuZChwb3NpdGlvbiAqIDIpO1xuICByZXR1cm4gKGRvdWJsZWRQb3NpdGlvbiArIHJvdW5kKGxpbmVXaWR0aCkpICUgMiA9PT0gMCA/IGRvdWJsZWRQb3NpdGlvbiAvIDIgOiAoZG91YmxlZFBvc2l0aW9uICsgKHBvc2l0aXZlT3JOZWdhdGl2ZSA/IDEgOiAtMSkpIC8gMjtcbn1cblxuZnVuY3Rpb24gaGFzRmlsbE9yU3Ryb2tlKGZpbGxPclN0cm9rZSkge1xuICByZXR1cm4gZmlsbE9yU3Ryb2tlICE9IG51bGwgJiYgZmlsbE9yU3Ryb2tlICE9ICdub25lJztcbn1cblxuZnVuY3Rpb24gbGlmdENvbG9yKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnID8gY29sb3JUb29sLmxpZnQoY29sb3IsIC0wLjEpIDogY29sb3I7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBjYWNoZUVsZW1lbnRTdGwoZWwpIHtcbiAgaWYgKGVsLl9faG92ZXJTdGxEaXJ0eSkge1xuICAgIHZhciBzdHJva2UgPSBlbC5zdHlsZS5zdHJva2U7XG4gICAgdmFyIGZpbGwgPSBlbC5zdHlsZS5maWxsOyAvLyBDcmVhdGUgaG92ZXJTdHlsZSBvbiBtb3VzZW92ZXJcblxuICAgIHZhciBob3ZlclN0eWxlID0gZWwuX19ob3ZlclN0bDtcbiAgICBob3ZlclN0eWxlLmZpbGwgPSBob3ZlclN0eWxlLmZpbGwgfHwgKGhhc0ZpbGxPclN0cm9rZShmaWxsKSA/IGxpZnRDb2xvcihmaWxsKSA6IG51bGwpO1xuICAgIGhvdmVyU3R5bGUuc3Ryb2tlID0gaG92ZXJTdHlsZS5zdHJva2UgfHwgKGhhc0ZpbGxPclN0cm9rZShzdHJva2UpID8gbGlmdENvbG9yKHN0cm9rZSkgOiBudWxsKTtcbiAgICB2YXIgbm9ybWFsU3R5bGUgPSB7fTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gaG92ZXJTdHlsZSkge1xuICAgICAgLy8gU2VlIGNvbW1lbnQgaW4gYGRvU2luZ2xlRW50ZXJIb3ZlcmAuXG4gICAgICBpZiAoaG92ZXJTdHlsZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIG5vcm1hbFN0eWxlW25hbWVdID0gZWwuc3R5bGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWwuX19ub3JtYWxTdGwgPSBub3JtYWxTdHlsZTtcbiAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSBmYWxzZTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZG9TaW5nbGVFbnRlckhvdmVyKGVsKSB7XG4gIGlmIChlbC5fX2lzSG92ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjYWNoZUVsZW1lbnRTdGwoZWwpO1xuXG4gIGlmIChlbC51c2VIb3ZlckxheWVyKSB7XG4gICAgZWwuX196ciAmJiBlbC5fX3pyLmFkZEhvdmVyKGVsLCBlbC5fX2hvdmVyU3RsKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICB2YXIgaW5zaWRlUm9sbGJhY2tPcHQgPSBzdHlsZS5pbnNpZGVSb2xsYmFja09wdDsgLy8gQ29uc2lkZXIgY2FzZTogb25seSBgcG9zaXRpb246ICd0b3AnYCBpcyBzZXQgb24gZW1waGFzaXMsIHRoZW4gdGV4dFxuICAgIC8vIGNvbG9yIHNob3VsZCBiZSByZXR1cm5lZCB0byBgYXV0b0NvbG9yYCwgcmF0aGVyIHRoYW4gcmVtYWluICcjZmZmJy5cbiAgICAvLyBTbyB3ZSBzaG91bGQgcm9sbGJhY2sgdGhlbiBhcHBseSBhZ2FpbiBhZnRlciBzdHlsZSBtZXJnaW5nLlxuXG4gICAgaW5zaWRlUm9sbGJhY2tPcHQgJiYgcm9sbGJhY2tJbnNpZGVTdHlsZShzdHlsZSk7IC8vIHN0eWxlcyBjYW4gYmU6XG4gICAgLy8ge1xuICAgIC8vICAgIGxhYmVsOiB7XG4gICAgLy8gICAgICAgIHNob3c6IGZhbHNlLFxuICAgIC8vICAgICAgICBwb3NpdGlvbjogJ291dHNpZGUnLFxuICAgIC8vICAgICAgICBmb250U2l6ZTogMThcbiAgICAvLyAgICB9LFxuICAgIC8vICAgIGVtcGhhc2lzOiB7XG4gICAgLy8gICAgICAgIGxhYmVsOiB7XG4gICAgLy8gICAgICAgICAgICBzaG93OiB0cnVlXG4gICAgLy8gICAgICAgIH1cbiAgICAvLyAgICB9XG4gICAgLy8gfSxcbiAgICAvLyB3aGVyZSBwcm9wZXJ0aWVzIG9mIGBlbXBoYXNpc2AgbWF5IG5vdCBhcHBlYXIgaW4gYG5vcm1hbGAuIFdlIHByZXZpb3VzbHkgdXNlXG4gICAgLy8gbW9kdWxlOmVjaGFydHMvdXRpbC9tb2RlbCNkZWZhdWx0RW1waGFzaXMgdG8gbWVyZ2UgYG5vcm1hbGAgdG8gYGVtcGhhc2lzYC5cbiAgICAvLyBCdXQgY29uc2lkZXIgcmljaCB0ZXh0IGFuZCBzZXRPcHRpb24gaW4gbWVyZ2UgbW9kZSwgaXQgaXMgaW1wb3NzaWJsZSB0byBjb3ZlclxuICAgIC8vIGFsbCBwcm9wZXJ0aWVzIGluIG1lcmdlLiBTbyB3ZSB1c2UgbWVyZ2UgbW9kZSB3aGVuIHNldHRpbmcgc3R5bGUgaGVyZSwgd2hlcmVcbiAgICAvLyBvbmx5IHByb3BlcnRpZXMgdGhhdCBpcyBub3QgYG51bGwvdW5kZWZpbmVkYCBjYW4gYmUgc2V0LiBUaGUgZGlzYWR2ZW50YWdlOlxuICAgIC8vIG51bGwvdW5kZWZpbmVkIGNhbiBub3QgYmUgdXNlZCB0byByZW1vdmUgc3R5bGUgYW55IG1vcmUgaW4gYGVtcGhhc2lzYC5cblxuICAgIHN0eWxlLmV4dGVuZEZyb20oZWwuX19ob3ZlclN0bCk7IC8vIERvIG5vdCBzYXZlIGBpbnNpZGVSb2xsYmFja2AuXG5cbiAgICBpZiAoaW5zaWRlUm9sbGJhY2tPcHQpIHtcbiAgICAgIGFwcGx5SW5zaWRlU3R5bGUoc3R5bGUsIHN0eWxlLmluc2lkZU9yaWdpbmFsVGV4dFBvc2l0aW9uLCBpbnNpZGVSb2xsYmFja09wdCk7IC8vIHRleHRGaWxsIG1heSBiZSByb2xsYmFja2VkIHRvIG51bGwuXG5cbiAgICAgIGlmIChzdHlsZS50ZXh0RmlsbCA9PSBudWxsKSB7XG4gICAgICAgIHN0eWxlLnRleHRGaWxsID0gaW5zaWRlUm9sbGJhY2tPcHQuYXV0b0NvbG9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsLmRpcnR5KGZhbHNlKTtcbiAgICBlbC56MiArPSAxO1xuICB9XG5cbiAgZWwuX19pc0hvdmVyID0gdHJ1ZTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpIHtcbiAgaWYgKCFlbC5fX2lzSG92ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbm9ybWFsU3RsID0gZWwuX19ub3JtYWxTdGw7XG5cbiAgaWYgKGVsLnVzZUhvdmVyTGF5ZXIpIHtcbiAgICBlbC5fX3pyICYmIGVsLl9fenIucmVtb3ZlSG92ZXIoZWwpO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnNpZGVyIG51bGwvdW5kZWZpbmVkIHZhbHVlLCBzaG91bGQgdXNlXG4gICAgLy8gYHNldFN0eWxlYCBidXQgbm90IGBleHRlbmRGcm9tKHN0bCwgdHJ1ZSlgLlxuICAgIG5vcm1hbFN0bCAmJiBlbC5zZXRTdHlsZShub3JtYWxTdGwpO1xuICAgIGVsLnoyIC09IDE7XG4gIH1cblxuICBlbC5fX2lzSG92ZXIgPSBmYWxzZTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBkb0VudGVySG92ZXIoZWwpIHtcbiAgZWwudHlwZSA9PT0gJ2dyb3VwJyA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICBkb1NpbmdsZUVudGVySG92ZXIoY2hpbGQpO1xuICAgIH1cbiAgfSkgOiBkb1NpbmdsZUVudGVySG92ZXIoZWwpO1xufVxuXG5mdW5jdGlvbiBkb0xlYXZlSG92ZXIoZWwpIHtcbiAgZWwudHlwZSA9PT0gJ2dyb3VwJyA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICBkb1NpbmdsZUxlYXZlSG92ZXIoY2hpbGQpO1xuICAgIH1cbiAgfSkgOiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdGwpIHtcbiAgLy8gSWYgZWxlbWVudCBoYXMgc2VwY2lmaWVkIGhvdmVyU3R5bGUsIHRoZW4gdXNlIGl0IGluc3RlYWQgb2YgZ2l2ZW4gaG92ZXJTdHlsZVxuICAvLyBPZnRlbiB1c2VkIHdoZW4gaXRlbSBncm91cCBoYXMgYSBsYWJlbCBlbGVtZW50IGFuZCBpdCdzIGhvdmVyU3R5bGUgaXMgZGlmZmVyZW50XG4gIGVsLl9faG92ZXJTdGwgPSBlbC5ob3ZlclN0eWxlIHx8IGhvdmVyU3RsIHx8IHt9O1xuICBlbC5fX2hvdmVyU3RsRGlydHkgPSB0cnVlO1xuXG4gIGlmIChlbC5fX2lzSG92ZXIpIHtcbiAgICBjYWNoZUVsZW1lbnRTdGwoZWwpO1xuICB9XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdmVyKGUpIHtcbiAgaWYgKHRoaXMuX19ob3ZlclNpbGVudE9uVG91Y2ggJiYgZS56ckJ5VG91Y2gpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcblxuXG4gICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0VudGVySG92ZXIodGhpcyk7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdXQoZSkge1xuICBpZiAodGhpcy5fX2hvdmVyU2lsZW50T25Ub3VjaCAmJiBlLnpyQnlUb3VjaCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xuXG5cbiAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvTGVhdmVIb3Zlcih0aGlzKTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBlbnRlckVtcGhhc2lzKCkge1xuICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XG4gIGRvRW50ZXJIb3Zlcih0aGlzKTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBsZWF2ZUVtcGhhc2lzKCkge1xuICB0aGlzLl9faXNFbXBoYXNpcyA9IGZhbHNlO1xuICBkb0xlYXZlSG92ZXIodGhpcyk7XG59XG4vKipcbiAqIFNldCBob3ZlciBzdHlsZSBvZiBlbGVtZW50LlxuICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCByZXBlYXRseSB3aXRob3V0IHNpZGUtZWZmZWN0cy5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaG92ZXJTdHlsZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0LmhvdmVyU2lsZW50T25Ub3VjaD1mYWxzZV1cbiAqICAgICAgICBJbiB0b3VjaCBkZXZpY2UsIG1vdXNlb3ZlciBldmVudCB3aWxsIGJlIHRyaWdnZXIgb24gdG91Y2hzdGFydCBldmVudFxuICogICAgICAgIChzZWUgbW9kdWxlOnpyZW5kZXIvZG9tL0hhbmRsZXJQcm94eSkuIEJ5IHRoaXMgbWVjaGFuaXNtLCB3ZSBjYW5cbiAqICAgICAgICBjb252aW5pZW50bHkgdXNlIGhvdmVyU3R5bGUgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuIHdpdGhvdXQgYWRkaXRpb25hbFxuICogICAgICAgIGNvZGUgZm9yIGNvbXBhdGliaWxpdHkuXG4gKiAgICAgICAgQnV0IGlmIHRoZSBjaGFydC9jb21wb25lbnQgaGFzIHNlbGVjdCBmZWF0dXJlLCB3aGljaCB1c3VhbGx5IGFsc28gdXNlXG4gKiAgICAgICAgaG92ZXJTdHlsZSwgdGhlcmUgbWlnaHQgYmUgY29uZmxpY3QgYmV0d2VlbiAnc2VsZWN0LWhpZ2hsaWdodCcgYW5kXG4gKiAgICAgICAgJ2hvdmVyLWhpZ2hsaWdodCcgZXNwZWNpYWxseSB3aGVuIHJvYW0gaXMgZW5hYmxlZCAoc2VlIGdlbyBmb3IgZXhhbXBsZSkuXG4gKiAgICAgICAgSW4gdGhpcyBjYXNlLCBob3ZlclNpbGVudE9uVG91Y2ggc2hvdWxkIGJlIHVzZWQgdG8gZGlzYWJsZSBob3Zlci1oaWdobGlnaHRcbiAqICAgICAgICBvbiB0b3VjaCBkZXZpY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRIb3ZlclN0eWxlKGVsLCBob3ZlclN0eWxlLCBvcHQpIHtcbiAgZWwuX19ob3ZlclNpbGVudE9uVG91Y2ggPSBvcHQgJiYgb3B0LmhvdmVyU2lsZW50T25Ub3VjaDtcbiAgZWwudHlwZSA9PT0gJ2dyb3VwJyA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICBzZXRFbGVtZW50SG92ZXJTdGwoY2hpbGQsIGhvdmVyU3R5bGUpO1xuICAgIH1cbiAgfSkgOiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3R5bGUpOyAvLyBEdXBsaWNhdGVkIGZ1bmN0aW9uIHdpbGwgYmUgYXV0by1pZ25vcmVkLCBzZWUgRXZlbnRmdWwuanMuXG5cbiAgZWwub24oJ21vdXNlb3ZlcicsIG9uRWxlbWVudE1vdXNlT3Zlcikub24oJ21vdXNlb3V0Jywgb25FbGVtZW50TW91c2VPdXQpOyAvLyBFbXBoYXNpcywgbm9ybWFsIGNhbiBiZSB0cmlnZ2VyZWQgbWFudWFsbHlcblxuICBlbC5vbignZW1waGFzaXMnLCBlbnRlckVtcGhhc2lzKS5vbignbm9ybWFsJywgbGVhdmVFbXBoYXNpcyk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IG5vcm1hbFN0eWxlXG4gKiBAcGFyYW0ge09iamVjdH0gZW1waGFzaXNTdHlsZVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbm9ybWFsTW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGVtcGhhc2lzTW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgQ2hlY2sgYG9wdGAgb2YgYHNldFRleHRTdHlsZUNvbW1vbmAgdG8gZmluZCBvdGhlciBwcm9wcy5cbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBbb3B0LmRlZmF1bHRUZXh0XVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW29wdC5sYWJlbEZldGNoZXJdIEZldGNoIHRleHQgYnlcbiAqICAgICAgYG9wdC5sYWJlbEZldGNoZXIuZ2V0Rm9ybWF0dGVkTGFiZWwob3B0LmxhYmVsRGF0YUluZGV4LCAnbm9ybWFsJy8nZW1waGFzaXMnLCBudWxsLCBvcHQubGFiZWxEaW1JbmRleClgXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbb3B0LmxhYmVsRGF0YUluZGV4XSBGZXRjaCB0ZXh0IGJ5XG4gKiAgICAgIGBvcHQudGV4dEZldGNoZXIuZ2V0Rm9ybWF0dGVkTGFiZWwob3B0LmxhYmVsRGF0YUluZGV4LCAnbm9ybWFsJy8nZW1waGFzaXMnLCBudWxsLCBvcHQubGFiZWxEaW1JbmRleClgXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbb3B0LmxhYmVsRGltSW5kZXhdIEZldGNoIHRleHQgYnlcbiAqICAgICAgYG9wdC50ZXh0RmV0Y2hlci5nZXRGb3JtYXR0ZWRMYWJlbChvcHQubGFiZWxEYXRhSW5kZXgsICdub3JtYWwnLydlbXBoYXNpcycsIG51bGwsIG9wdC5sYWJlbERpbUluZGV4KWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbbm9ybWFsU3BlY2lmaWVkXVxuICogQHBhcmFtIHtPYmplY3R9IFtlbXBoYXNpc1NwZWNpZmllZF1cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldExhYmVsU3R5bGUobm9ybWFsU3R5bGUsIGVtcGhhc2lzU3R5bGUsIG5vcm1hbE1vZGVsLCBlbXBoYXNpc01vZGVsLCBvcHQsIG5vcm1hbFNwZWNpZmllZCwgZW1waGFzaXNTcGVjaWZpZWQpIHtcbiAgb3B0ID0gb3B0IHx8IEVNUFRZX09CSjtcbiAgdmFyIGxhYmVsRmV0Y2hlciA9IG9wdC5sYWJlbEZldGNoZXI7XG4gIHZhciBsYWJlbERhdGFJbmRleCA9IG9wdC5sYWJlbERhdGFJbmRleDtcbiAgdmFyIGxhYmVsRGltSW5kZXggPSBvcHQubGFiZWxEaW1JbmRleDsgLy8gVGhpcyBzY2VuYXJpbywgYGxhYmVsLm5vcm1hbC5zaG93ID0gdHJ1ZTsgbGFiZWwuZW1waGFzaXMuc2hvdyA9IGZhbHNlYCxcbiAgLy8gaXMgbm90IHN1cHBvcnRlZCB1dGlsIHNvbWVvbmUgcmVxdWVzdHMuXG5cbiAgdmFyIHNob3dOb3JtYWwgPSBub3JtYWxNb2RlbC5nZXRTaGFsbG93KCdzaG93Jyk7XG4gIHZhciBzaG93RW1waGFzaXMgPSBlbXBoYXNpc01vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTsgLy8gQ29uc2lkZXIgcGVyZm9ybWFuY2UsIG9ubHkgZmV0Y2ggbGFiZWwgd2hlbiBuZWNlc3NhcnkuXG4gIC8vIElmIGBub3JtYWwuc2hvd2AgaXMgYGZhbHNlYCBhbmQgYGVtcGhhc2lzLnNob3dgIGlzIGB0cnVlYCBhbmQgYGVtcGhhc2lzLmZvcm1hdHRlcmAgaXMgbm90IHNldCxcbiAgLy8gbGFiZWwgc2hvdWxkIGJlIGRpc3BsYXllZCwgd2hlcmUgdGV4dCBpcyBmZXRjaGVkIGJ5IGBub3JtYWwuZm9ybWF0dGVyYCBvciBgb3B0LmRlZmF1bHRUZXh0YC5cblxuICB2YXIgYmFzZVRleHQ7XG5cbiAgaWYgKHNob3dOb3JtYWwgfHwgc2hvd0VtcGhhc2lzKSB7XG4gICAgaWYgKGxhYmVsRmV0Y2hlcikge1xuICAgICAgYmFzZVRleHQgPSBsYWJlbEZldGNoZXIuZ2V0Rm9ybWF0dGVkTGFiZWwobGFiZWxEYXRhSW5kZXgsICdub3JtYWwnLCBudWxsLCBsYWJlbERpbUluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVRleHQgPT0gbnVsbCkge1xuICAgICAgYmFzZVRleHQgPSB6clV0aWwuaXNGdW5jdGlvbihvcHQuZGVmYXVsdFRleHQpID8gb3B0LmRlZmF1bHRUZXh0KGxhYmVsRGF0YUluZGV4LCBvcHQpIDogb3B0LmRlZmF1bHRUZXh0O1xuICAgIH1cbiAgfVxuXG4gIHZhciBub3JtYWxTdHlsZVRleHQgPSBzaG93Tm9ybWFsID8gYmFzZVRleHQgOiBudWxsO1xuICB2YXIgZW1waGFzaXNTdHlsZVRleHQgPSBzaG93RW1waGFzaXMgPyB6clV0aWwucmV0cmlldmUyKGxhYmVsRmV0Y2hlciA/IGxhYmVsRmV0Y2hlci5nZXRGb3JtYXR0ZWRMYWJlbChsYWJlbERhdGFJbmRleCwgJ2VtcGhhc2lzJywgbnVsbCwgbGFiZWxEaW1JbmRleCkgOiBudWxsLCBiYXNlVGV4dCkgOiBudWxsOyAvLyBPcHRpbWl6ZTogSWYgc3R5bGUudGV4dCBpcyBudWxsLCB0ZXh0IHdpbGwgbm90IGJlIGRyYXduLlxuXG4gIGlmIChub3JtYWxTdHlsZVRleHQgIT0gbnVsbCB8fCBlbXBoYXNpc1N0eWxlVGV4dCAhPSBudWxsKSB7XG4gICAgLy8gQWx3YXlzIHNldCBgdGV4dFN0eWxlYCBldmVuIGlmIGBub3JtYWxTdHlsZS50ZXh0YCBpcyBudWxsLCBiZWNhdXNlIGRlZmF1bHRcbiAgICAvLyB2YWx1ZXMgaGF2ZSB0byBiZSBzZXQgb24gYG5vcm1hbFN0eWxlYC5cbiAgICAvLyBJZiB3ZSBzZXQgZGVmYXVsdCB2YWx1ZXMgb24gYGVtcGhhc2lzU3R5bGVgLCBjb25zaWRlciBjYXNlOlxuICAgIC8vIEZpcnN0bHksIGBzZXRPcHRpb24oLi4uIGxhYmVsOiB7bm9ybWFsOiB7dGV4dDogbnVsbH0sIGVtcGhhc2lzOiB7c2hvdzogdHJ1ZX19IC4uLik7YFxuICAgIC8vIFNlY29uZGx5LCBgc2V0T3B0aW9uKC4uLiBsYWJlbDoge25vcmFtbDoge3Nob3c6IHRydWUsIHRleHQ6ICdhYmMnLCBjb2xvcjogJ3JlZCd9IC4uLik7YFxuICAgIC8vIFRoZW4gdGhlICdyZWQnIHdpbGwgbm90IHdvcmsgb24gZW1waGFzaXMuXG4gICAgc2V0VGV4dFN0eWxlKG5vcm1hbFN0eWxlLCBub3JtYWxNb2RlbCwgbm9ybWFsU3BlY2lmaWVkLCBvcHQpO1xuICAgIHNldFRleHRTdHlsZShlbXBoYXNpc1N0eWxlLCBlbXBoYXNpc01vZGVsLCBlbXBoYXNpc1NwZWNpZmllZCwgb3B0LCB0cnVlKTtcbiAgfVxuXG4gIG5vcm1hbFN0eWxlLnRleHQgPSBub3JtYWxTdHlsZVRleHQ7XG4gIGVtcGhhc2lzU3R5bGUudGV4dCA9IGVtcGhhc2lzU3R5bGVUZXh0O1xufVxuLyoqXG4gKiBTZXQgYmFzaWMgdGV4dFN0eWxlIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSB0ZXh0U3R5bGVcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gW3NwZWNpZmllZFRleHRTdHlsZV0gQ2FuIGJlIG92ZXJyaWRlZCBieSBzZXR0aW5ncyBpbiBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XSBTZWUgYG9wdGAgb2YgYHNldFRleHRTdHlsZUNvbW1vbmAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0VtcGhhc2lzXVxuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIHNwZWNpZmllZFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzKSB7XG4gIHNldFRleHRTdHlsZUNvbW1vbih0ZXh0U3R5bGUsIHRleHRTdHlsZU1vZGVsLCBvcHQsIGlzRW1waGFzaXMpO1xuICBzcGVjaWZpZWRUZXh0U3R5bGUgJiYgenJVdGlsLmV4dGVuZCh0ZXh0U3R5bGUsIHNwZWNpZmllZFRleHRTdHlsZSk7XG4gIHRleHRTdHlsZS5ob3N0ICYmIHRleHRTdHlsZS5ob3N0LmRpcnR5ICYmIHRleHRTdHlsZS5ob3N0LmRpcnR5KGZhbHNlKTtcbiAgcmV0dXJuIHRleHRTdHlsZTtcbn1cbi8qKlxuICogU2V0IHRleHQgb3B0aW9uIGluIHRoZSBzdHlsZS5cbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXG4gKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBkZWZhdWx0Q29sb3IgRGVmYXVsdCB0ZXh0IGNvbG9yLlxuICogICAgICAgIElmIHNldCBhcyBmYWxzZSwgaXQgd2lsbCBiZSBwcm9jZXNzZWQgYXMgYSBlbXBoYXNpcyBzdHlsZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRleHQodGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBkZWZhdWx0Q29sb3IpIHtcbiAgdmFyIG9wdCA9IHtcbiAgICBpc1JlY3RUZXh0OiB0cnVlXG4gIH07XG4gIHZhciBpc0VtcGhhc2lzO1xuXG4gIGlmIChkZWZhdWx0Q29sb3IgPT09IGZhbHNlKSB7XG4gICAgaXNFbXBoYXNpcyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3VwcG9ydCBzZXR0aW5nIGNvbG9yIGFzICdhdXRvJyB0byBnZXQgdmlzdWFsIGNvbG9yLlxuICAgIG9wdC5hdXRvQ29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gIH1cblxuICBzZXRUZXh0U3R5bGVDb21tb24odGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBvcHQsIGlzRW1waGFzaXMpO1xuICB0ZXh0U3R5bGUuaG9zdCAmJiB0ZXh0U3R5bGUuaG9zdC5kaXJ0eSAmJiB0ZXh0U3R5bGUuaG9zdC5kaXJ0eShmYWxzZSk7XG59XG4vKipcbiAqIHtcbiAqICAgICAgZGlzYWJsZUJveDogYm9vbGVhbiwgV2hldGhlciBkaWFibGUgZHJhd2luZyBib3ggb2YgYmxvY2sgKG91dGVyIG1vc3QpLlxuICogICAgICBpc1JlY3RUZXh0OiBib29sZWFuLFxuICogICAgICBhdXRvQ29sb3I6IHN0cmluZywgc3BlY2lmeSBhIGNvbG9yIHdoZW4gY29sb3IgaXMgJ2F1dG8nLFxuICogICAgICAgICAgICAgIGZvciB0ZXh0RmlsbCwgdGV4dFN0cm9rZSwgdGV4dEJhY2tncm91bmRDb2xvciwgYW5kIHRleHRCb3JkZXJDb2xvci5cbiAqICAgICAgICAgICAgICBJZiBhdXRvQ29sb3Igc3BlY2lmaWVkLCBpdCBpcyB1c2VkIGFzIGRlZmF1bHQgdGV4dEZpbGwuXG4gKiAgICAgIHVzZUluc2lkZVN0eWxlOlxuICogICAgICAgICAgICAgIGB0cnVlYDogVXNlIGluc2lkZSBzdHlsZSAodGV4dEZpbGwsIHRleHRTdHJva2UsIHRleHRTdHJva2VXaWR0aClcbiAqICAgICAgICAgICAgICAgICAgaWYgYHRleHRGaWxsYCBpcyBub3Qgc3BlY2lmaWVkLlxuICogICAgICAgICAgICAgIGBmYWxzZWA6IERvIG5vdCB1c2UgaW5zaWRlIHN0eWxlLlxuICogICAgICAgICAgICAgIGBudWxsL3VuZGVmaW5lZGA6IHVzZSBpbnNpZGUgc3R5bGUgaWYgYGlzUmVjdFRleHRgIGlzIHRydWUgYW5kXG4gKiAgICAgICAgICAgICAgICAgIGB0ZXh0RmlsbGAgaXMgbm90IHNwZWNpZmllZCBhbmQgdGV4dFBvc2l0aW9uIGNvbnRhaW5zIGAnaW5zaWRlJ2AuXG4gKiAgICAgIGZvcmNlUmljaDogYm9vbGVhblxuICogfVxuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dFN0eWxlQ29tbW9uKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIG9wdCwgaXNFbXBoYXNpcykge1xuICAvLyBDb25zaWRlciB0aGVyZSB3aWxsIGJlIGFibm9ybWFsIHdoZW4gbWVyZ2UgaG92ZXIgc3R5bGUgdG8gbm9ybWFsIHN0eWxlIGlmIGdpdmVuIGRlZmF1bHQgdmFsdWUuXG4gIG9wdCA9IG9wdCB8fCBFTVBUWV9PQko7XG5cbiAgaWYgKG9wdC5pc1JlY3RUZXh0KSB7XG4gICAgdmFyIHRleHRQb3NpdGlvbiA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3Bvc2l0aW9uJykgfHwgKGlzRW1waGFzaXMgPyBudWxsIDogJ2luc2lkZScpOyAvLyAnb3V0c2lkZScgaXMgbm90IGEgdmFsaWQgenIgdGV4dFBvc3Rpb24gdmFsdWUsIGJ1dCB1c2VkXG4gICAgLy8gaW4gYmFyIHNlcmllcywgYW5kIG1hZ3JpYyB0eXBlIHNob3VsZCBiZSBjb25zaWRlcmVkLlxuXG4gICAgdGV4dFBvc2l0aW9uID09PSAnb3V0c2lkZScgJiYgKHRleHRQb3NpdGlvbiA9ICd0b3AnKTtcbiAgICB0ZXh0U3R5bGUudGV4dFBvc2l0aW9uID0gdGV4dFBvc2l0aW9uO1xuICAgIHRleHRTdHlsZS50ZXh0T2Zmc2V0ID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnb2Zmc2V0Jyk7XG4gICAgdmFyIGxhYmVsUm90YXRlID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygncm90YXRlJyk7XG4gICAgbGFiZWxSb3RhdGUgIT0gbnVsbCAmJiAobGFiZWxSb3RhdGUgKj0gTWF0aC5QSSAvIDE4MCk7XG4gICAgdGV4dFN0eWxlLnRleHRSb3RhdGlvbiA9IGxhYmVsUm90YXRlO1xuICAgIHRleHRTdHlsZS50ZXh0RGlzdGFuY2UgPSB6clV0aWwucmV0cmlldmUyKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2Rpc3RhbmNlJyksIGlzRW1waGFzaXMgPyBudWxsIDogNSk7XG4gIH1cblxuICB2YXIgZWNNb2RlbCA9IHRleHRTdHlsZU1vZGVsLmVjTW9kZWw7XG4gIHZhciBnbG9iYWxUZXh0U3R5bGUgPSBlY01vZGVsICYmIGVjTW9kZWwub3B0aW9uLnRleHRTdHlsZTsgLy8gQ29uc2lkZXIgY2FzZTpcbiAgLy8ge1xuICAvLyAgICAgZGF0YTogW3tcbiAgLy8gICAgICAgICB2YWx1ZTogMTIsXG4gIC8vICAgICAgICAgbGFiZWw6IHtcbiAgLy8gICAgICAgICAgICAgcmljaDoge1xuICAvLyAgICAgICAgICAgICAgICAgLy8gbm8gJ2EnIGhlcmUgYnV0IHVzaW5nIHBhcmVudCAnYScuXG4gIC8vICAgICAgICAgICAgIH1cbiAgLy8gICAgICAgICB9XG4gIC8vICAgICB9XSxcbiAgLy8gICAgIHJpY2g6IHtcbiAgLy8gICAgICAgICBhOiB7IC4uLiB9XG4gIC8vICAgICB9XG4gIC8vIH1cblxuICB2YXIgcmljaEl0ZW1OYW1lcyA9IGdldFJpY2hJdGVtTmFtZXModGV4dFN0eWxlTW9kZWwpO1xuICB2YXIgcmljaFJlc3VsdDtcblxuICBpZiAocmljaEl0ZW1OYW1lcykge1xuICAgIHJpY2hSZXN1bHQgPSB7fTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gcmljaEl0ZW1OYW1lcykge1xuICAgICAgaWYgKHJpY2hJdGVtTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgLy8gQ2FzY2FkZSBpcyBzdXBwb3J0ZWQgaW4gcmljaC5cbiAgICAgICAgdmFyIHJpY2hUZXh0U3R5bGUgPSB0ZXh0U3R5bGVNb2RlbC5nZXRNb2RlbChbJ3JpY2gnLCBuYW1lXSk7IC8vIEluIHJpY2gsIG5ldmVyIGBkaXNhYmxlQm94YC5cblxuICAgICAgICBzZXRUb2tlblRleHRTdHlsZShyaWNoUmVzdWx0W25hbWVdID0ge30sIHJpY2hUZXh0U3R5bGUsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0ZXh0U3R5bGUucmljaCA9IHJpY2hSZXN1bHQ7XG4gIHNldFRva2VuVGV4dFN0eWxlKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzLCB0cnVlKTtcblxuICBpZiAob3B0LmZvcmNlUmljaCAmJiAhb3B0LnRleHRTdHlsZSkge1xuICAgIG9wdC50ZXh0U3R5bGUgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0U3R5bGU7XG59IC8vIENvbnNpZGVyIGNhc2U6XG4vLyB7XG4vLyAgICAgZGF0YTogW3tcbi8vICAgICAgICAgdmFsdWU6IDEyLFxuLy8gICAgICAgICBsYWJlbDoge1xuLy8gICAgICAgICAgICAgcmljaDoge1xuLy8gICAgICAgICAgICAgICAgIC8vIG5vICdhJyBoZXJlIGJ1dCB1c2luZyBwYXJlbnQgJ2EnLlxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyAgICAgfV0sXG4vLyAgICAgcmljaDoge1xuLy8gICAgICAgICBhOiB7IC4uLiB9XG4vLyAgICAgfVxuLy8gfVxuXG5cbmZ1bmN0aW9uIGdldFJpY2hJdGVtTmFtZXModGV4dFN0eWxlTW9kZWwpIHtcbiAgLy8gVXNlIG9iamVjdCB0byByZW1vdmUgZHVwbGljYXRlZCBuYW1lcy5cbiAgdmFyIHJpY2hJdGVtTmFtZU1hcDtcblxuICB3aGlsZSAodGV4dFN0eWxlTW9kZWwgJiYgdGV4dFN0eWxlTW9kZWwgIT09IHRleHRTdHlsZU1vZGVsLmVjTW9kZWwpIHtcbiAgICB2YXIgcmljaCA9ICh0ZXh0U3R5bGVNb2RlbC5vcHRpb24gfHwgRU1QVFlfT0JKKS5yaWNoO1xuXG4gICAgaWYgKHJpY2gpIHtcbiAgICAgIHJpY2hJdGVtTmFtZU1hcCA9IHJpY2hJdGVtTmFtZU1hcCB8fCB7fTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiByaWNoKSB7XG4gICAgICAgIGlmIChyaWNoLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgcmljaEl0ZW1OYW1lTWFwW25hbWVdID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRleHRTdHlsZU1vZGVsID0gdGV4dFN0eWxlTW9kZWwucGFyZW50TW9kZWw7XG4gIH1cblxuICByZXR1cm4gcmljaEl0ZW1OYW1lTWFwO1xufVxuXG5mdW5jdGlvbiBzZXRUb2tlblRleHRTdHlsZSh0ZXh0U3R5bGUsIHRleHRTdHlsZU1vZGVsLCBnbG9iYWxUZXh0U3R5bGUsIG9wdCwgaXNFbXBoYXNpcywgaXNCbG9jaykge1xuICAvLyBJbiBtZXJnZSBtb2RlLCBkZWZhdWx0IHZhbHVlIHNob3VsZCBub3QgYmUgZ2l2ZW4uXG4gIGdsb2JhbFRleHRTdHlsZSA9ICFpc0VtcGhhc2lzICYmIGdsb2JhbFRleHRTdHlsZSB8fCBFTVBUWV9PQko7XG4gIHRleHRTdHlsZS50ZXh0RmlsbCA9IGdldEF1dG9Db2xvcih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdjb2xvcicpLCBvcHQpIHx8IGdsb2JhbFRleHRTdHlsZS5jb2xvcjtcbiAgdGV4dFN0eWxlLnRleHRTdHJva2UgPSBnZXRBdXRvQ29sb3IodGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygndGV4dEJvcmRlckNvbG9yJyksIG9wdCkgfHwgZ2xvYmFsVGV4dFN0eWxlLnRleHRCb3JkZXJDb2xvcjtcbiAgdGV4dFN0eWxlLnRleHRTdHJva2VXaWR0aCA9IHpyVXRpbC5yZXRyaWV2ZTIodGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygndGV4dEJvcmRlcldpZHRoJyksIGdsb2JhbFRleHRTdHlsZS50ZXh0Qm9yZGVyV2lkdGgpO1xuXG4gIGlmICghaXNFbXBoYXNpcykge1xuICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAvLyBBbHdheXMgc2V0IGBpbnNpZGVSb2xsYmFja2AsIGZvciBjbGVhcmluZyBwcmV2aW91cy5cbiAgICAgIHZhciBvcmlnaW5hbFRleHRQb3NpdGlvbiA9IHRleHRTdHlsZS50ZXh0UG9zaXRpb247XG4gICAgICB0ZXh0U3R5bGUuaW5zaWRlUm9sbGJhY2sgPSBhcHBseUluc2lkZVN0eWxlKHRleHRTdHlsZSwgb3JpZ2luYWxUZXh0UG9zaXRpb24sIG9wdCk7IC8vIFNhdmUgb3JpZ2luYWwgdGV4dFBvc2l0aW9uLCBiZWNhdXNlIHN0eWxlLnRleHRQb3NpdGlvbiB3aWxsIGJlIHJlcGFsY2VkIGJ5XG4gICAgICAvLyByZWFsIGxvY2F0aW9uIChsaWtlIFsxMCwgMzBdKSBpbiB6cmVuZGVyLlxuXG4gICAgICB0ZXh0U3R5bGUuaW5zaWRlT3JpZ2luYWxUZXh0UG9zaXRpb24gPSBvcmlnaW5hbFRleHRQb3NpdGlvbjtcbiAgICAgIHRleHRTdHlsZS5pbnNpZGVSb2xsYmFja09wdCA9IG9wdDtcbiAgICB9IC8vIFNldCBkZWZhdWx0IGZpbmFsbHkuXG5cblxuICAgIGlmICh0ZXh0U3R5bGUudGV4dEZpbGwgPT0gbnVsbCkge1xuICAgICAgdGV4dFN0eWxlLnRleHRGaWxsID0gb3B0LmF1dG9Db2xvcjtcbiAgICB9XG4gIH0gLy8gRG8gbm90IHVzZSBgZ2V0Rm9udGAgaGVyZSwgYmVjYXVzZSBtZXJnZSBzaG91bGQgYmUgc3VwcG9ydGVkLCB3aGVyZVxuICAvLyBwYXJ0IG9mIHRoZXNlIHByb3BlcnRpZXMgbWF5IGJlIGNoYW5nZWQgaW4gZW1waGFzaXMgc3R5bGUsIGFuZCB0aGVcbiAgLy8gb3RoZXJzIHNob3VsZCByZW1haW4gdGhlaXIgb3JpZ2luYWwgdmFsdWUgZ290IGZyb20gbm9ybWFsIHN0eWxlLlxuXG5cbiAgdGV4dFN0eWxlLmZvbnRTdHlsZSA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRTdHlsZScpIHx8IGdsb2JhbFRleHRTdHlsZS5mb250U3R5bGU7XG4gIHRleHRTdHlsZS5mb250V2VpZ2h0ID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFdlaWdodCcpIHx8IGdsb2JhbFRleHRTdHlsZS5mb250V2VpZ2h0O1xuICB0ZXh0U3R5bGUuZm9udFNpemUgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250U2l6ZScpIHx8IGdsb2JhbFRleHRTdHlsZS5mb250U2l6ZTtcbiAgdGV4dFN0eWxlLmZvbnRGYW1pbHkgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250RmFtaWx5JykgfHwgZ2xvYmFsVGV4dFN0eWxlLmZvbnRGYW1pbHk7XG4gIHRleHRTdHlsZS50ZXh0QWxpZ24gPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdhbGlnbicpO1xuICB0ZXh0U3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd2ZXJ0aWNhbEFsaWduJykgfHwgdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnYmFzZWxpbmUnKTtcbiAgdGV4dFN0eWxlLnRleHRMaW5lSGVpZ2h0ID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnbGluZUhlaWdodCcpO1xuICB0ZXh0U3R5bGUudGV4dFdpZHRoID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnd2lkdGgnKTtcbiAgdGV4dFN0eWxlLnRleHRIZWlnaHQgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdoZWlnaHQnKTtcbiAgdGV4dFN0eWxlLnRleHRUYWcgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0YWcnKTtcblxuICBpZiAoIWlzQmxvY2sgfHwgIW9wdC5kaXNhYmxlQm94KSB7XG4gICAgdGV4dFN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgPSBnZXRBdXRvQ29sb3IodGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnYmFja2dyb3VuZENvbG9yJyksIG9wdCk7XG4gICAgdGV4dFN0eWxlLnRleHRQYWRkaW5nID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygncGFkZGluZycpO1xuICAgIHRleHRTdHlsZS50ZXh0Qm9yZGVyQ29sb3IgPSBnZXRBdXRvQ29sb3IodGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnYm9yZGVyQ29sb3InKSwgb3B0KTtcbiAgICB0ZXh0U3R5bGUudGV4dEJvcmRlcldpZHRoID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnYm9yZGVyV2lkdGgnKTtcbiAgICB0ZXh0U3R5bGUudGV4dEJvcmRlclJhZGl1cyA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2JvcmRlclJhZGl1cycpO1xuICAgIHRleHRTdHlsZS50ZXh0Qm94U2hhZG93Q29sb3IgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdzaGFkb3dDb2xvcicpO1xuICAgIHRleHRTdHlsZS50ZXh0Qm94U2hhZG93Qmx1ciA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3NoYWRvd0JsdXInKTtcbiAgICB0ZXh0U3R5bGUudGV4dEJveFNoYWRvd09mZnNldFggPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdzaGFkb3dPZmZzZXRYJyk7XG4gICAgdGV4dFN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRZID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnc2hhZG93T2Zmc2V0WScpO1xuICB9XG5cbiAgdGV4dFN0eWxlLnRleHRTaGFkb3dDb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RleHRTaGFkb3dDb2xvcicpIHx8IGdsb2JhbFRleHRTdHlsZS50ZXh0U2hhZG93Q29sb3I7XG4gIHRleHRTdHlsZS50ZXh0U2hhZG93Qmx1ciA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RleHRTaGFkb3dCbHVyJykgfHwgZ2xvYmFsVGV4dFN0eWxlLnRleHRTaGFkb3dCbHVyO1xuICB0ZXh0U3R5bGUudGV4dFNoYWRvd09mZnNldFggPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0ZXh0U2hhZG93T2Zmc2V0WCcpIHx8IGdsb2JhbFRleHRTdHlsZS50ZXh0U2hhZG93T2Zmc2V0WDtcbiAgdGV4dFN0eWxlLnRleHRTaGFkb3dPZmZzZXRZID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygndGV4dFNoYWRvd09mZnNldFknKSB8fCBnbG9iYWxUZXh0U3R5bGUudGV4dFNoYWRvd09mZnNldFk7XG59XG5cbmZ1bmN0aW9uIGdldEF1dG9Db2xvcihjb2xvciwgb3B0KSB7XG4gIHJldHVybiBjb2xvciAhPT0gJ2F1dG8nID8gY29sb3IgOiBvcHQgJiYgb3B0LmF1dG9Db2xvciA/IG9wdC5hdXRvQ29sb3IgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBhcHBseUluc2lkZVN0eWxlKHRleHRTdHlsZSwgdGV4dFBvc2l0aW9uLCBvcHQpIHtcbiAgdmFyIHVzZUluc2lkZVN0eWxlID0gb3B0LnVzZUluc2lkZVN0eWxlO1xuICB2YXIgaW5zaWRlUm9sbGJhY2s7XG5cbiAgaWYgKHRleHRTdHlsZS50ZXh0RmlsbCA9PSBudWxsICYmIHVzZUluc2lkZVN0eWxlICE9PSBmYWxzZSAmJiAodXNlSW5zaWRlU3R5bGUgPT09IHRydWUgfHwgb3B0LmlzUmVjdFRleHQgJiYgdGV4dFBvc2l0aW9uIC8vIHRleHRQb3NpdGlvbiBjYW4gYmUgWzEwLCAzMF1cbiAgJiYgdHlwZW9mIHRleHRQb3NpdGlvbiA9PT0gJ3N0cmluZycgJiYgdGV4dFBvc2l0aW9uLmluZGV4T2YoJ2luc2lkZScpID49IDApKSB7XG4gICAgaW5zaWRlUm9sbGJhY2sgPSB7XG4gICAgICB0ZXh0RmlsbDogbnVsbCxcbiAgICAgIHRleHRTdHJva2U6IHRleHRTdHlsZS50ZXh0U3Ryb2tlLFxuICAgICAgdGV4dFN0cm9rZVdpZHRoOiB0ZXh0U3R5bGUudGV4dFN0cm9rZVdpZHRoXG4gICAgfTtcbiAgICB0ZXh0U3R5bGUudGV4dEZpbGwgPSAnI2ZmZic7IC8vIENvbnNpZGVyIHRleHQgd2l0aCAjZmZmIG92ZXJmbG93IGl0cyBjb250YWluZXIuXG5cbiAgICBpZiAodGV4dFN0eWxlLnRleHRTdHJva2UgPT0gbnVsbCkge1xuICAgICAgdGV4dFN0eWxlLnRleHRTdHJva2UgPSBvcHQuYXV0b0NvbG9yO1xuICAgICAgdGV4dFN0eWxlLnRleHRTdHJva2VXaWR0aCA9PSBudWxsICYmICh0ZXh0U3R5bGUudGV4dFN0cm9rZVdpZHRoID0gMik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc2lkZVJvbGxiYWNrO1xufVxuXG5mdW5jdGlvbiByb2xsYmFja0luc2lkZVN0eWxlKHN0eWxlKSB7XG4gIHZhciBpbnNpZGVSb2xsYmFjayA9IHN0eWxlLmluc2lkZVJvbGxiYWNrO1xuXG4gIGlmIChpbnNpZGVSb2xsYmFjaykge1xuICAgIHN0eWxlLnRleHRGaWxsID0gaW5zaWRlUm9sbGJhY2sudGV4dEZpbGw7XG4gICAgc3R5bGUudGV4dFN0cm9rZSA9IGluc2lkZVJvbGxiYWNrLnRleHRTdHJva2U7XG4gICAgc3R5bGUudGV4dFN0cm9rZVdpZHRoID0gaW5zaWRlUm9sbGJhY2sudGV4dFN0cm9rZVdpZHRoO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZvbnQob3B0LCBlY01vZGVsKSB7XG4gIC8vIGVjTW9kZWwgb3IgZGVmYXVsdCB0ZXh0IHN0eWxlIG1vZGVsLlxuICB2YXIgZ1RleHRTdHlsZU1vZGVsID0gZWNNb2RlbCB8fCBlY01vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgcmV0dXJuIHpyVXRpbC50cmltKFsvLyBGSVhNRSBpbiBub2RlLWNhbnZhcyBmb250V2VpZ2h0IGlzIGJlZm9yZSBmb250U3R5bGVcbiAgb3B0LmZvbnRTdHlsZSB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRTdHlsZScpIHx8ICcnLCBvcHQuZm9udFdlaWdodCB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRXZWlnaHQnKSB8fCAnJywgKG9wdC5mb250U2l6ZSB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRTaXplJykgfHwgMTIpICsgJ3B4Jywgb3B0LmZvbnRGYW1pbHkgfHwgZ1RleHRTdHlsZU1vZGVsICYmIGdUZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250RmFtaWx5JykgfHwgJ3NhbnMtc2VyaWYnXS5qb2luKCcgJykpO1xufVxuXG5mdW5jdGlvbiBhbmltYXRlT3JTZXRQcm9wcyhpc1VwZGF0ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgaWYgKHR5cGVvZiBkYXRhSW5kZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGRhdGFJbmRleDtcbiAgICBkYXRhSW5kZXggPSBudWxsO1xuICB9IC8vIERvIG5vdCBjaGVjayAnYW5pbWF0aW9uJyBwcm9wZXJ0eSBkaXJlY3RseSBoZXJlLiBDb25zaWRlciB0aGlzIGNhc2U6XG4gIC8vIGFuaW1hdGlvbiBtb2RlbCBpcyBhbiBgaXRlbU1vZGVsYCwgd2hvc2UgZG9lcyBub3QgaGF2ZSBgaXNBbmltYXRpb25FbmFibGVkYFxuICAvLyBidXQgaXRzIHBhcmVudCBtb2RlbCAoYHNlcmllc01vZGVsYCkgZG9lcy5cblxuXG4gIHZhciBhbmltYXRpb25FbmFibGVkID0gYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcblxuICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgIHZhciBwb3N0Zml4ID0gaXNVcGRhdGUgPyAnVXBkYXRlJyA6ICcnO1xuICAgIHZhciBkdXJhdGlvbiA9IGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25EdXJhdGlvbicgKyBwb3N0Zml4KTtcbiAgICB2YXIgYW5pbWF0aW9uRWFzaW5nID0gYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkVhc2luZycgKyBwb3N0Zml4KTtcbiAgICB2YXIgYW5pbWF0aW9uRGVsYXkgPSBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRGVsYXknICsgcG9zdGZpeCk7XG5cbiAgICBpZiAodHlwZW9mIGFuaW1hdGlvbkRlbGF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhbmltYXRpb25EZWxheSA9IGFuaW1hdGlvbkRlbGF5KGRhdGFJbmRleCwgYW5pbWF0YWJsZU1vZGVsLmdldEFuaW1hdGlvbkRlbGF5UGFyYW1zID8gYW5pbWF0YWJsZU1vZGVsLmdldEFuaW1hdGlvbkRlbGF5UGFyYW1zKGVsLCBkYXRhSW5kZXgpIDogbnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbihkYXRhSW5kZXgpO1xuICAgIH1cblxuICAgIGR1cmF0aW9uID4gMCA/IGVsLmFuaW1hdGVUbyhwcm9wcywgZHVyYXRpb24sIGFuaW1hdGlvbkRlbGF5IHx8IDAsIGFuaW1hdGlvbkVhc2luZywgY2IsICEhY2IpIDogKGVsLnN0b3BBbmltYXRpb24oKSwgZWwuYXR0cihwcm9wcyksIGNiICYmIGNiKCkpO1xuICB9IGVsc2Uge1xuICAgIGVsLnN0b3BBbmltYXRpb24oKTtcbiAgICBlbC5hdHRyKHByb3BzKTtcbiAgICBjYiAmJiBjYigpO1xuICB9XG59XG4vKipcbiAqIFVwZGF0ZSBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGVcbiAqIGNvbmZpZ3VyYXRpb24gaW4gc2VyaWVzLlxuICpcbiAqIENhdXRpb246IHRoaXMgbWV0aG9kIHdpbGwgc3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG4gKiBTbyBpZiBkbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIG9uZSBlbGVtZW50IHR3aWNlIGJlZm9yZVxuICogYW5pbWF0aW9uIHN0YXJ0cywgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFthbmltYXRhYmxlTW9kZWxdXG4gKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqIEBleGFtcGxlXG4gKiAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICogICAgICAgICBwb3NpdGlvbjogWzEwMCwgMTAwXVxuICogICAgIH0sIHNlcmllc01vZGVsLCBkYXRhSW5kZXgsIGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ0FuaW1hdGlvbiBkb25lIScpOyB9KTtcbiAqICAgICAvLyBPclxuICogICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHtcbiAqICAgICAgICAgcG9zaXRpb246IFsxMDAsIDEwMF1cbiAqICAgICB9LCBzZXJpZXNNb2RlbCwgZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnQW5pbWF0aW9uIGRvbmUhJyk7IH0pO1xuICovXG5cblxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgYW5pbWF0ZU9yU2V0UHJvcHModHJ1ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpO1xufVxuLyoqXG4gKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZVxuICogY29uZmlndXJhdGlvbiBpbiBzZXJpZXMuXG4gKlxuICogQ2F1dGlvbjogdGhpcyBtZXRob2Qgd2lsbCBzdG9wIHByZXZpb3VzIGFuaW1hdGlvbi5cbiAqIFNvIGlmIGRvIG5vdCB1c2UgdGhpcyBtZXRob2QgdG8gb25lIGVsZW1lbnQgdHdpY2UgYmVmb3JlXG4gKiBhbmltYXRpb24gc3RhcnRzLCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgZGF0YUluZGV4LCBjYikge1xuICBhbmltYXRlT3JTZXRQcm9wcyhmYWxzZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpO1xufVxuLyoqXG4gKiBHZXQgdHJhbnNmb3JtIG1hdHJpeCBvZiB0YXJnZXQgKHBhcmFtIHRhcmdldCksXG4gKiBpbiBjb29yZGluYXRlIG9mIGl0cyBhbmNlc3RvciAocGFyYW0gYW5jZXN0b3IpXG4gKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSB0YXJnZXRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gW2FuY2VzdG9yXVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKHRhcmdldCwgYW5jZXN0b3IpIHtcbiAgdmFyIG1hdCA9IG1hdHJpeC5pZGVudGl0eShbXSk7XG5cbiAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IGFuY2VzdG9yKSB7XG4gICAgbWF0cml4Lm11bChtYXQsIHRhcmdldC5nZXRMb2NhbFRyYW5zZm9ybSgpLCBtYXQpO1xuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gbWF0O1xufVxuLyoqXG4gKiBBcHBseSB0cmFuc2Zvcm0gdG8gYW4gdmVydGV4LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdGFyZ2V0IFt4LCB5XVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPnxUeXBlZEFycmF5LjxudW1iZXI+fE9iamVjdH0gdHJhbnNmb3JtIENhbiBiZTpcbiAqICAgICAgKyBUcmFuc2Zvcm0gbWF0cml4OiBsaWtlIFsxLCAwLCAwLCAxLCAwLCAwXVxuICogICAgICArIHtwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlfSwgdGhlIHNhbWUgYXMgYHpyZW5kZXIvVHJhbnNmb3JtYWJsZWAuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbeCwgeV1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKHRhcmdldCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcbiAgaWYgKHRyYW5zZm9ybSAmJiAhenJVdGlsLmlzQXJyYXlMaWtlKHRyYW5zZm9ybSkpIHtcbiAgICB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gIH1cblxuICBpZiAoaW52ZXJ0KSB7XG4gICAgdHJhbnNmb3JtID0gbWF0cml4LmludmVydChbXSwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHRhcmdldCwgdHJhbnNmb3JtKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVHJhbnNmb3JtZWQgZGlyZWN0aW9uLiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcbiAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxuICB2YXIgaEJhc2UgPSB0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMCA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzBdKTtcbiAgdmFyIHZCYXNlID0gdHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMl0gPT09IDAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVsyXSk7XG4gIHZhciB2ZXJ0ZXggPSBbZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXTtcbiAgdmVydGV4ID0gYXBwbHlUcmFuc2Zvcm0odmVydGV4LCB0cmFuc2Zvcm0sIGludmVydCk7XG4gIHJldHVybiBNYXRoLmFicyh2ZXJ0ZXhbMF0pID4gTWF0aC5hYnModmVydGV4WzFdKSA/IHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnIDogdmVydGV4WzFdID4gMCA/ICdib3R0b20nIDogJ3RvcCc7XG59XG4vKipcbiAqIEFwcGx5IGdyb3VwIHRyYW5zaXRpb24gYW5pbWF0aW9uIGZyb20gZzEgdG8gZzIuXG4gKiBJZiBubyBhbmltYXRhYmxlTW9kZWwsIG5vIGFuaW1hdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdyb3VwVHJhbnNpdGlvbihnMSwgZzIsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcbiAgaWYgKCFnMSB8fCAhZzIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbE1hcChnKSB7XG4gICAgdmFyIGVsTWFwID0ge307XG4gICAgZy50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGlmICghZWwuaXNHcm91cCAmJiBlbC5hbmlkKSB7XG4gICAgICAgIGVsTWFwW2VsLmFuaWRdID0gZWw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVsTWFwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZVByb3BzKGVsKSB7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHBvc2l0aW9uOiB2ZWN0b3IuY2xvbmUoZWwucG9zaXRpb24pLFxuICAgICAgcm90YXRpb246IGVsLnJvdGF0aW9uXG4gICAgfTtcblxuICAgIGlmIChlbC5zaGFwZSkge1xuICAgICAgb2JqLnNoYXBlID0genJVdGlsLmV4dGVuZCh7fSwgZWwuc2hhcGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgZWxNYXAxID0gZ2V0RWxNYXAoZzEpO1xuICBnMi50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoIWVsLmlzR3JvdXAgJiYgZWwuYW5pZCkge1xuICAgICAgdmFyIG9sZEVsID0gZWxNYXAxW2VsLmFuaWRdO1xuXG4gICAgICBpZiAob2xkRWwpIHtcbiAgICAgICAgdmFyIG5ld1Byb3AgPSBnZXRBbmltYXRhYmxlUHJvcHMoZWwpO1xuICAgICAgICBlbC5hdHRyKGdldEFuaW1hdGFibGVQcm9wcyhvbGRFbCkpO1xuICAgICAgICB1cGRhdGVQcm9wcyhlbCwgbmV3UHJvcCwgYW5pbWF0YWJsZU1vZGVsLCBlbC5kYXRhSW5kZXgpO1xuICAgICAgfSAvLyBlbHNlIHtcbiAgICAgIC8vICAgICBpZiAoZWwucHJldmlvdXNQcm9wcykge1xuICAgICAgLy8gICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gfVxuXG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHMgTGlrZTogW1syMywgNDRdLCBbNTMsIDY2XSwgLi4uXVxuICogQHBhcmFtIHtPYmplY3R9IHJlY3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBBIG5ldyBjbGlwcGVkIHBvaW50cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNsaXBQb2ludHNCeVJlY3QocG9pbnRzLCByZWN0KSB7XG4gIHJldHVybiB6clV0aWwubWFwKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIHggPSBwb2ludFswXTtcbiAgICB4ID0gbWF0aE1heCh4LCByZWN0LngpO1xuICAgIHggPSBtYXRoTWluKHgsIHJlY3QueCArIHJlY3Qud2lkdGgpO1xuICAgIHZhciB5ID0gcG9pbnRbMV07XG4gICAgeSA9IG1hdGhNYXgoeSwgcmVjdC55KTtcbiAgICB5ID0gbWF0aE1pbih5LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRSZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHBhcmFtIHtPYmplY3R9IHJlY3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IGNsaXBwZWQgcmVjdC4gSWYgcmVjdCBzaXplIGFyZSBuZWdhdGl2ZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNsaXBSZWN0QnlSZWN0KHRhcmdldFJlY3QsIHJlY3QpIHtcbiAgdmFyIHggPSBtYXRoTWF4KHRhcmdldFJlY3QueCwgcmVjdC54KTtcbiAgdmFyIHgyID0gbWF0aE1pbih0YXJnZXRSZWN0LnggKyB0YXJnZXRSZWN0LndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKTtcbiAgdmFyIHkgPSBtYXRoTWF4KHRhcmdldFJlY3QueSwgcmVjdC55KTtcbiAgdmFyIHkyID0gbWF0aE1pbih0YXJnZXRSZWN0LnkgKyB0YXJnZXRSZWN0LmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXG4gIGlmICh4MiA+PSB4ICYmIHkyID49IHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogeDIgLSB4LFxuICAgICAgaGVpZ2h0OiB5MiAtIHlcbiAgICB9O1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpY29uU3RyIFN1cHBvcnQgJ2ltYWdlOi8vJyBvciAncGF0aDovLycgb3IgZGlyZWN0IHN2ZyBwYXRoLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRdIFByb3BlcnRpZXMgb2YgYG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRgLCBleGNlcHQgYHN0eWxlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVjdF0ge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBJY29uIHBhdGggb3IgaW1hZ2UgZWxlbWVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUljb24oaWNvblN0ciwgb3B0LCByZWN0KSB7XG4gIG9wdCA9IHpyVXRpbC5leHRlbmQoe1xuICAgIHJlY3RIb3ZlcjogdHJ1ZVxuICB9LCBvcHQpO1xuICB2YXIgc3R5bGUgPSBvcHQuc3R5bGUgPSB7XG4gICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICB9O1xuICByZWN0ID0gcmVjdCB8fCB7XG4gICAgeDogLTEsXG4gICAgeTogLTEsXG4gICAgd2lkdGg6IDIsXG4gICAgaGVpZ2h0OiAyXG4gIH07XG5cbiAgaWYgKGljb25TdHIpIHtcbiAgICByZXR1cm4gaWNvblN0ci5pbmRleE9mKCdpbWFnZTovLycpID09PSAwID8gKHN0eWxlLmltYWdlID0gaWNvblN0ci5zbGljZSg4KSwgenJVdGlsLmRlZmF1bHRzKHN0eWxlLCByZWN0KSwgbmV3IFpJbWFnZShvcHQpKSA6IG1ha2VQYXRoKGljb25TdHIucmVwbGFjZSgncGF0aDovLycsICcnKSwgb3B0LCByZWN0LCAnY2VudGVyJyk7XG4gIH1cbn1cblxuZXhwb3J0cy5leHRlbmRTaGFwZSA9IGV4dGVuZFNoYXBlO1xuZXhwb3J0cy5leHRlbmRQYXRoID0gZXh0ZW5kUGF0aDtcbmV4cG9ydHMubWFrZVBhdGggPSBtYWtlUGF0aDtcbmV4cG9ydHMubWFrZUltYWdlID0gbWFrZUltYWdlO1xuZXhwb3J0cy5tZXJnZVBhdGggPSBtZXJnZVBhdGg7XG5leHBvcnRzLnJlc2l6ZVBhdGggPSByZXNpemVQYXRoO1xuZXhwb3J0cy5zdWJQaXhlbE9wdGltaXplTGluZSA9IHN1YlBpeGVsT3B0aW1pemVMaW5lO1xuZXhwb3J0cy5zdWJQaXhlbE9wdGltaXplUmVjdCA9IHN1YlBpeGVsT3B0aW1pemVSZWN0O1xuZXhwb3J0cy5zdWJQaXhlbE9wdGltaXplID0gc3ViUGl4ZWxPcHRpbWl6ZTtcbmV4cG9ydHMuc2V0SG92ZXJTdHlsZSA9IHNldEhvdmVyU3R5bGU7XG5leHBvcnRzLnNldExhYmVsU3R5bGUgPSBzZXRMYWJlbFN0eWxlO1xuZXhwb3J0cy5zZXRUZXh0U3R5bGUgPSBzZXRUZXh0U3R5bGU7XG5leHBvcnRzLnNldFRleHQgPSBzZXRUZXh0O1xuZXhwb3J0cy5nZXRGb250ID0gZ2V0Rm9udDtcbmV4cG9ydHMudXBkYXRlUHJvcHMgPSB1cGRhdGVQcm9wcztcbmV4cG9ydHMuaW5pdFByb3BzID0gaW5pdFByb3BzO1xuZXhwb3J0cy5nZXRUcmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm07XG5leHBvcnRzLmFwcGx5VHJhbnNmb3JtID0gYXBwbHlUcmFuc2Zvcm07XG5leHBvcnRzLnRyYW5zZm9ybURpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbjtcbmV4cG9ydHMuZ3JvdXBUcmFuc2l0aW9uID0gZ3JvdXBUcmFuc2l0aW9uO1xuZXhwb3J0cy5jbGlwUG9pbnRzQnlSZWN0ID0gY2xpcFBvaW50c0J5UmVjdDtcbmV4cG9ydHMuY2xpcFJlY3RCeVJlY3QgPSBjbGlwUmVjdEJ5UmVjdDtcbmV4cG9ydHMuY3JlYXRlSWNvbiA9IGNyZWF0ZUljb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9ncmFwaGljLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2dyYXBoaWMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIF9udW1iZXIgPSByZXF1aXJlKFwiLi9udW1iZXJcIik7XG5cbnZhciBwYXJzZVBlcmNlbnQgPSBfbnVtYmVyLnBhcnNlUGVyY2VudDtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIExheW91dCBoZWxwZXJzIGZvciBlYWNoIGNvbXBvbmVudCBwb3NpdGlvbmluZ1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbi8qKlxuICogQHB1YmxpY1xuICovXG5cbnZhciBMT0NBVElPTl9QQVJBTVMgPSBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnXTtcbi8qKlxuICogQHB1YmxpY1xuICovXG5cbnZhciBIVl9OQU1FUyA9IFtbJ3dpZHRoJywgJ2xlZnQnLCAncmlnaHQnXSwgWydoZWlnaHQnLCAndG9wJywgJ2JvdHRvbSddXTtcblxuZnVuY3Rpb24gYm94TGF5b3V0KG9yaWVudCwgZ3JvdXAsIGdhcCwgbWF4V2lkdGgsIG1heEhlaWdodCkge1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICBpZiAobWF4V2lkdGggPT0gbnVsbCkge1xuICAgIG1heFdpZHRoID0gSW5maW5pdHk7XG4gIH1cblxuICBpZiAobWF4SGVpZ2h0ID09IG51bGwpIHtcbiAgICBtYXhIZWlnaHQgPSBJbmZpbml0eTtcbiAgfVxuXG4gIHZhciBjdXJyZW50TGluZU1heFNpemUgPSAwO1xuICBncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBjaGlsZC5wb3NpdGlvbjtcbiAgICB2YXIgcmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBuZXh0Q2hpbGQgPSBncm91cC5jaGlsZEF0KGlkeCArIDEpO1xuICAgIHZhciBuZXh0Q2hpbGRSZWN0ID0gbmV4dENoaWxkICYmIG5leHRDaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgbmV4dFg7XG4gICAgdmFyIG5leHRZO1xuXG4gICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICB2YXIgbW92ZVggPSByZWN0LndpZHRoICsgKG5leHRDaGlsZFJlY3QgPyAtbmV4dENoaWxkUmVjdC54ICsgcmVjdC54IDogMCk7XG4gICAgICBuZXh0WCA9IHggKyBtb3ZlWDsgLy8gV3JhcCB3aGVuIHdpZHRoIGV4Y2VlZHMgbWF4V2lkdGggb3IgbWVldCBhIGBuZXdsaW5lYCBncm91cFxuICAgICAgLy8gRklYTUUgY29tcGFyZSBiZWZvcmUgYWRkaW5nIGdhcD9cblxuICAgICAgaWYgKG5leHRYID4gbWF4V2lkdGggfHwgY2hpbGQubmV3bGluZSkge1xuICAgICAgICB4ID0gMDtcbiAgICAgICAgbmV4dFggPSBtb3ZlWDtcbiAgICAgICAgeSArPSBjdXJyZW50TGluZU1heFNpemUgKyBnYXA7XG4gICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IHJlY3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRklYTUU6IGNvbnNpZGVyIHJlY3QueSBpcyBub3QgYDBgP1xuICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSBNYXRoLm1heChjdXJyZW50TGluZU1heFNpemUsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1vdmVZID0gcmVjdC5oZWlnaHQgKyAobmV4dENoaWxkUmVjdCA/IC1uZXh0Q2hpbGRSZWN0LnkgKyByZWN0LnkgOiAwKTtcbiAgICAgIG5leHRZID0geSArIG1vdmVZOyAvLyBXcmFwIHdoZW4gd2lkdGggZXhjZWVkcyBtYXhIZWlnaHQgb3IgbWVldCBhIGBuZXdsaW5lYCBncm91cFxuXG4gICAgICBpZiAobmV4dFkgPiBtYXhIZWlnaHQgfHwgY2hpbGQubmV3bGluZSkge1xuICAgICAgICB4ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgeSA9IDA7XG4gICAgICAgIG5leHRZID0gbW92ZVk7XG4gICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IHJlY3Qud2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSBNYXRoLm1heChjdXJyZW50TGluZU1heFNpemUsIHJlY3Qud2lkdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGlsZC5uZXdsaW5lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9zaXRpb25bMF0gPSB4O1xuICAgIHBvc2l0aW9uWzFdID0geTtcbiAgICBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/IHggPSBuZXh0WCArIGdhcCA6IHkgPSBuZXh0WSArIGdhcDtcbiAgfSk7XG59XG4vKipcbiAqIFZCb3ggb3IgSEJveCBsYXlvdXRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICogQHBhcmFtIHtudW1iZXJ9IGdhcFxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PUluZmluaXR5XVxuICovXG5cblxudmFyIGJveCA9IGJveExheW91dDtcbi8qKlxuICogVkJveCBsYXlvdXRpbmdcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICogQHBhcmFtIHtudW1iZXJ9IGdhcFxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PUluZmluaXR5XVxuICovXG5cbnZhciB2Ym94ID0genJVdGlsLmN1cnJ5KGJveExheW91dCwgJ3ZlcnRpY2FsJyk7XG4vKipcbiAqIEhCb3ggbGF5b3V0aW5nXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBnYXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9SW5maW5pdHldXG4gKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cbiAqL1xuXG52YXIgaGJveCA9IHpyVXRpbC5jdXJyeShib3hMYXlvdXQsICdob3Jpem9udGFsJyk7XG4vKipcbiAqIElmIHggb3IgeDIgaXMgbm90IHNwZWNpZmllZCBvciAnY2VudGVyJyAnbGVmdCcgJ3JpZ2h0JyxcbiAqIHRoZSB3aWR0aCB3b3VsZCBiZSBhcyBsb25nIGFzIHBvc3NpYmxlLlxuICogSWYgeSBvciB5MiBpcyBub3Qgc3BlY2lmaWVkIG9yICdtaWRkbGUnICd0b3AnICdib3R0b20nLFxuICogdGhlIGhlaWdodCB3b3VsZCBiZSBhcyBsb25nIGFzIHBvc3NpYmxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbkluZm9cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby54XVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnldXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueDJdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueTJdXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyUmVjdCB7d2lkdGgsIGhlaWdodH1cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbWFyZ2luXG4gKiBAcmV0dXJuIHtPYmplY3R9IHt3aWR0aCwgaGVpZ2h0fVxuICovXG5cbmZ1bmN0aW9uIGdldEF2YWlsYWJsZVNpemUocG9zaXRpb25JbmZvLCBjb250YWluZXJSZWN0LCBtYXJnaW4pIHtcbiAgdmFyIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyUmVjdC53aWR0aDtcbiAgdmFyIGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lclJlY3QuaGVpZ2h0O1xuICB2YXIgeCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueCwgY29udGFpbmVyV2lkdGgpO1xuICB2YXIgeSA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueSwgY29udGFpbmVySGVpZ2h0KTtcbiAgdmFyIHgyID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby54MiwgY29udGFpbmVyV2lkdGgpO1xuICB2YXIgeTIgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnkyLCBjb250YWluZXJIZWlnaHQpO1xuICAoaXNOYU4oeCkgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueCkpKSAmJiAoeCA9IDApO1xuICAoaXNOYU4oeDIpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLngyKSkpICYmICh4MiA9IGNvbnRhaW5lcldpZHRoKTtcbiAgKGlzTmFOKHkpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLnkpKSkgJiYgKHkgPSAwKTtcbiAgKGlzTmFOKHkyKSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby55MikpKSAmJiAoeTIgPSBjb250YWluZXJIZWlnaHQpO1xuICBtYXJnaW4gPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KG1hcmdpbiB8fCAwKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogTWF0aC5tYXgoeDIgLSB4IC0gbWFyZ2luWzFdIC0gbWFyZ2luWzNdLCAwKSxcbiAgICBoZWlnaHQ6IE1hdGgubWF4KHkyIC0geSAtIG1hcmdpblswXSAtIG1hcmdpblsyXSwgMClcbiAgfTtcbn1cbi8qKlxuICogUGFyc2UgcG9zaXRpb24gaW5mby5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25JbmZvXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ubGVmdF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby50b3BdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ucmlnaHRdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uYm90dG9tXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLndpZHRoXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmhlaWdodF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5hc3BlY3RdIEFzcGVjdCBpcyB3aWR0aCAvIGhlaWdodFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclJlY3RcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW21hcmdpbl1cbiAqXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExheW91dFJlY3QocG9zaXRpb25JbmZvLCBjb250YWluZXJSZWN0LCBtYXJnaW4pIHtcbiAgbWFyZ2luID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShtYXJnaW4gfHwgMCk7XG4gIHZhciBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lclJlY3Qud2lkdGg7XG4gIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodDtcbiAgdmFyIGxlZnQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmxlZnQsIGNvbnRhaW5lcldpZHRoKTtcbiAgdmFyIHRvcCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8udG9wLCBjb250YWluZXJIZWlnaHQpO1xuICB2YXIgcmlnaHQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnJpZ2h0LCBjb250YWluZXJXaWR0aCk7XG4gIHZhciBib3R0b20gPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmJvdHRvbSwgY29udGFpbmVySGVpZ2h0KTtcbiAgdmFyIHdpZHRoID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby53aWR0aCwgY29udGFpbmVyV2lkdGgpO1xuICB2YXIgaGVpZ2h0ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5oZWlnaHQsIGNvbnRhaW5lckhlaWdodCk7XG4gIHZhciB2ZXJ0aWNhbE1hcmdpbiA9IG1hcmdpblsyXSArIG1hcmdpblswXTtcbiAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBtYXJnaW5bMV0gKyBtYXJnaW5bM107XG4gIHZhciBhc3BlY3QgPSBwb3NpdGlvbkluZm8uYXNwZWN0OyAvLyBJZiB3aWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxjdWxhdGUgd2lkdGggZnJvbSBsZWZ0IGFuZCByaWdodFxuXG4gIGlmIChpc05hTih3aWR0aCkpIHtcbiAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gcmlnaHQgLSBob3Jpem9udGFsTWFyZ2luIC0gbGVmdDtcbiAgfVxuXG4gIGlmIChpc05hTihoZWlnaHQpKSB7XG4gICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0IC0gYm90dG9tIC0gdmVydGljYWxNYXJnaW4gLSB0b3A7XG4gIH1cblxuICBpZiAoYXNwZWN0ICE9IG51bGwpIHtcbiAgICAvLyBJZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgZ2l2ZW5cbiAgICAvLyAxLiBHcmFwaCBzaG91bGQgbm90IGV4Y2VlZHMgdGhlIGNvbnRhaW5lclxuICAgIC8vIDIuIEFzcGVjdCBtdXN0IGJlIGtlZXBlZFxuICAgIC8vIDMuIEdyYXBoIHNob3VsZCB0YWtlIHRoZSBzcGFjZSBhcyBtb3JlIGFzIHBvc3NpYmxlXG4gICAgLy8gRklYTUVcbiAgICAvLyBNYXJnaW4gaXMgbm90IGNvbnNpZGVyZWQsIGJlY2F1c2UgdGhlcmUgaXMgbm8gY2FzZSB0aGF0IGJvdGhcbiAgICAvLyB1c2luZyBtYXJnaW4gYW5kIGFzcGVjdCBzbyBmYXIuXG4gICAgaWYgKGlzTmFOKHdpZHRoKSAmJiBpc05hTihoZWlnaHQpKSB7XG4gICAgICBpZiAoYXNwZWN0ID4gY29udGFpbmVyV2lkdGggLyBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAqIDAuODtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAqIDAuODtcbiAgICAgIH1cbiAgICB9IC8vIENhbGN1bGF0ZSB3aWR0aCBvciBoZWlnaHQgd2l0aCBnaXZlbiBhc3BlY3RcblxuXG4gICAgaWYgKGlzTmFOKHdpZHRoKSkge1xuICAgICAgd2lkdGggPSBhc3BlY3QgKiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xuICAgIH1cbiAgfSAvLyBJZiBsZWZ0IGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBsZWZ0IGZyb20gcmlnaHQgYW5kIHdpZHRoXG5cblxuICBpZiAoaXNOYU4obGVmdCkpIHtcbiAgICBsZWZ0ID0gY29udGFpbmVyV2lkdGggLSByaWdodCAtIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbjtcbiAgfVxuXG4gIGlmIChpc05hTih0b3ApKSB7XG4gICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC0gYm90dG9tIC0gaGVpZ2h0IC0gdmVydGljYWxNYXJnaW47XG4gIH0gLy8gQWxpZ24gbGVmdCBhbmQgdG9wXG5cblxuICBzd2l0Y2ggKHBvc2l0aW9uSW5mby5sZWZ0IHx8IHBvc2l0aW9uSW5mby5yaWdodCkge1xuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBsZWZ0ID0gY29udGFpbmVyV2lkdGggLyAyIC0gd2lkdGggLyAyIC0gbWFyZ2luWzNdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBsZWZ0ID0gY29udGFpbmVyV2lkdGggLSB3aWR0aCAtIGhvcml6b250YWxNYXJnaW47XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN3aXRjaCAocG9zaXRpb25JbmZvLnRvcCB8fCBwb3NpdGlvbkluZm8uYm90dG9tKSB7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC8gMiAtIGhlaWdodCAvIDIgLSBtYXJnaW5bMF07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLSBoZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbjtcbiAgICAgIGJyZWFrO1xuICB9IC8vIElmIHNvbWV0aGluZyBpcyB3cm9uZyBhbmQgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IGFyZSBjYWxjdWxhdGVkIGFzIE5hTlxuXG5cbiAgbGVmdCA9IGxlZnQgfHwgMDtcbiAgdG9wID0gdG9wIHx8IDA7XG5cbiAgaWYgKGlzTmFOKHdpZHRoKSkge1xuICAgIC8vIFdpZHRoIG1heSBiZSBOYU4gaWYgb25seSBvbmUgdmFsdWUgaXMgZ2l2ZW4gZXhjZXB0IHdpZHRoXG4gICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIGhvcml6b250YWxNYXJnaW4gLSBsZWZ0IC0gKHJpZ2h0IHx8IDApO1xuICB9XG5cbiAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICAvLyBIZWlnaHQgbWF5IGJlIE5hTiBpZiBvbmx5IG9uZSB2YWx1ZSBpcyBnaXZlbiBleGNlcHQgaGVpZ2h0XG4gICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0IC0gdmVydGljYWxNYXJnaW4gLSB0b3AgLSAoYm90dG9tIHx8IDApO1xuICB9XG5cbiAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KGxlZnQgKyBtYXJnaW5bM10sIHRvcCArIG1hcmdpblswXSwgd2lkdGgsIGhlaWdodCk7XG4gIHJlY3QubWFyZ2luID0gbWFyZ2luO1xuICByZXR1cm4gcmVjdDtcbn1cbi8qKlxuICogUG9zaXRpb24gYSB6ciBlbGVtZW50IGluIHZpZXdwb3J0XG4gKiAgR3JvdXAgcG9zaXRpb24gaXMgc3BlY2lmaWVkIGJ5IGVpdGhlclxuICogIHtsZWZ0LCB0b3B9LCB7cmlnaHQsIGJvdHRvbX1cbiAqICBJZiBhbGwgcHJvcGVydGllcyBleGlzdHMsIHJpZ2h0IGFuZCBib3R0b20gd2lsbCBiZSBpZ29ucmVkLlxuICpcbiAqIExvZ2ljOlxuICogICAgIDEuIFNjYWxlIChhZ2FpbnN0IG9yaWdpbiBwb2ludCBpbiBwYXJlbnQgY29vcmQpXG4gKiAgICAgMi4gUm90YXRlIChhZ2FpbnN0IG9yaWdpbiBwb2ludCBpbiBwYXJlbnQgY29vcmQpXG4gKiAgICAgMy4gVHJhc2xhdGUgKHdpdGggZWwucG9zaXRpb24gYnkgdGhpcyBtZXRob2QpXG4gKiBTbyB0aGlzIG1ldGhvZCBvbmx5IGZpeGVzIHRoZSBsYXN0IHN0ZXAgJ1RyYXNsYXRlJywgd2hpY2ggZG9lcyBub3QgYWZmZWN0XG4gKiBzY2FsaW5nIGFuZCByb3RhdGluZy5cbiAqXG4gKiBJZiBiZSBjYWxsZWQgcmVwZWF0bHkgd2l0aCB0aGUgc2FtZSBpbnB1dCBlbCwgdGhlIHNhbWUgcmVzdWx0IHdpbGwgYmUgZ290dGVuLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWwgU2hvdWxkIGhhdmUgYGdldEJvdW5kaW5nUmVjdGAgbWV0aG9kLlxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uSW5mb1xuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmxlZnRdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8udG9wXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnJpZ2h0XVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmJvdHRvbV1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby53aWR0aF0gT25seSBmb3Igb3B0LmJvdW5kaW5nTW9kZWw6ICdyYXcnXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uaGVpZ2h0XSBPbmx5IGZvciBvcHQuYm91bmRpbmdNb2RlbDogJ3JhdydcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJSZWN0XG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG1hcmdpblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3B0Lmh2PVsxLDFdXSBPbmx5IGhvcml6b250YWwgb3Igb25seSB2ZXJ0aWNhbC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHQuYm91bmRpbmdNb2RlPSdhbGwnXVxuICogICAgICAgIFNwZWNpZnkgaG93IHRvIGNhbGN1bGF0ZSBib3VuZGluZ1JlY3Qgd2hlbiBsb2NhdGluZy5cbiAqICAgICAgICAnYWxsJzogUG9zaXRpb24gdGhlIGJvdW5kaW5nUmVjdCB0aGF0IGlzIHRyYW5zZm9ybWVkIGFuZCB1aW9uZWRcbiAqICAgICAgICAgICAgICAgYm90aCBpdHNlbGYgYW5kIGl0cyBkZXNjZW5kYW50cy5cbiAqICAgICAgICAgICAgICAgVGhpcyBtb2RlIHNpbXBsaWVzIGNvbmZpbmUgdGhlIGVsZW1lbnRzIGluIHRoZSBib3VuZGluZ1xuICogICAgICAgICAgICAgICBvZiB0aGVpciBjb250YWluZXIgKGUuZy4sIHVzaW5nICdyaWdodDogMCcpLlxuICogICAgICAgICdyYXcnOiBQb3NpdGlvbiB0aGUgYm91bmRpbmdSZWN0IHRoYXQgaXMgbm90IHRyYW5zZm9ybWVkIGFuZCBvbmx5IGl0c2VsZi5cbiAqICAgICAgICAgICAgICAgVGhpcyBtb2RlIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IGEgZWxlbWVudCBjYW4gb3ZlcmZsb3cgaXRzXG4gKiAgICAgICAgICAgICAgIGNvbnRhaW5lci4gKENvbnNpZGVyIGEgcm90YXRlZCBjaXJjbGUgbmVlZHMgdG8gYmUgbG9jYXRlZCBpbiBhIGNvcm5lci4pXG4gKiAgICAgICAgICAgICAgIEluIHRoaXMgbW9kZSBwb3NpdGlvbkluZm8ud2lkdGgvaGVpZ2h0IGNhbiBvbmx5IGJlIG51bWJlci5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBvc2l0aW9uRWxlbWVudChlbCwgcG9zaXRpb25JbmZvLCBjb250YWluZXJSZWN0LCBtYXJnaW4sIG9wdCkge1xuICB2YXIgaCA9ICFvcHQgfHwgIW9wdC5odiB8fCBvcHQuaHZbMF07XG4gIHZhciB2ID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlsxXTtcbiAgdmFyIGJvdW5kaW5nTW9kZSA9IG9wdCAmJiBvcHQuYm91bmRpbmdNb2RlIHx8ICdhbGwnO1xuXG4gIGlmICghaCAmJiAhdikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWN0O1xuXG4gIGlmIChib3VuZGluZ01vZGUgPT09ICdyYXcnKSB7XG4gICAgcmVjdCA9IGVsLnR5cGUgPT09ICdncm91cCcgPyBuZXcgQm91bmRpbmdSZWN0KDAsIDAsICtwb3NpdGlvbkluZm8ud2lkdGggfHwgMCwgK3Bvc2l0aW9uSW5mby5oZWlnaHQgfHwgMCkgOiBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgfSBlbHNlIHtcbiAgICByZWN0ID0gZWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgICBpZiAoZWwubmVlZExvY2FsVHJhbnNmb3JtKCkpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbC5nZXRMb2NhbFRyYW5zZm9ybSgpOyAvLyBOb3RpY2U6IHJhdyByZWN0IG1heSBiZSBpbm5lciBvYmplY3Qgb2YgZWwsXG4gICAgICAvLyB3aGljaCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxuXG4gICAgICByZWN0ID0gcmVjdC5jbG9uZSgpO1xuICAgICAgcmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgIH1cbiAgfSAvLyBUaGUgcmVhbCB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBub3QgYmUgc3BlY2lmaWVkIGJ1dCBjYWxjdWxhdGVkIGJ5IHRoZSBnaXZlbiBlbC5cblxuXG4gIHBvc2l0aW9uSW5mbyA9IGdldExheW91dFJlY3QoenJVdGlsLmRlZmF1bHRzKHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH0sIHBvc2l0aW9uSW5mbyksIGNvbnRhaW5lclJlY3QsIG1hcmdpbik7IC8vIEJlY2F1c2UgJ3RyYW5sYXRlJyBpcyB0aGUgbGFzdCBzdGVwIGluIHRyYW5zZm9ybVxuICAvLyAoc2VlIHpyZW5kZXIvY29yZS9UcmFuc2Zvcm1hYmxlI2dldExvY2FsVHJhbnNmb3JtKSxcbiAgLy8gd2UgY2FuIGp1c3Qgb25seSBtb2RpZnkgZWwucG9zaXRpb24gdG8gZ2V0IGZpbmFsIHJlc3VsdC5cblxuICB2YXIgZWxQb3MgPSBlbC5wb3NpdGlvbjtcbiAgdmFyIGR4ID0gaCA/IHBvc2l0aW9uSW5mby54IC0gcmVjdC54IDogMDtcbiAgdmFyIGR5ID0gdiA/IHBvc2l0aW9uSW5mby55IC0gcmVjdC55IDogMDtcbiAgZWwuYXR0cigncG9zaXRpb24nLCBib3VuZGluZ01vZGUgPT09ICdyYXcnID8gW2R4LCBkeV0gOiBbZWxQb3NbMF0gKyBkeCwgZWxQb3NbMV0gKyBkeV0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uIENvbnRhaW5zIHNvbWUgb2YgdGhlIHByb3BlcnRpZXMgaW4gSFZfTkFNRVMuXG4gKiBAcGFyYW0ge251bWJlcn0gaHZJZHggMDogaG9yaXpvbnRhbDsgMTogdmVydGljYWwuXG4gKi9cblxuXG5mdW5jdGlvbiBzaXplQ2FsY3VsYWJsZShvcHRpb24sIGh2SWR4KSB7XG4gIHJldHVybiBvcHRpb25bSFZfTkFNRVNbaHZJZHhdWzBdXSAhPSBudWxsIHx8IG9wdGlvbltIVl9OQU1FU1todklkeF1bMV1dICE9IG51bGwgJiYgb3B0aW9uW0hWX05BTUVTW2h2SWR4XVsyXV0gIT0gbnVsbDtcbn1cbi8qKlxuICogQ29uc2lkZXIgQ2FzZTpcbiAqIFdoZW4gZGVmdWxhdCBvcHRpb24gaGFzIHtsZWZ0OiAwLCB3aWR0aDogMTAwfSwgYW5kIHdlIHNldCB7cmlnaHQ6IDB9XG4gKiB0aHJvdWdoIHNldE9wdGlvbiBvciBtZWRpYSBxdWVyeSwgdXNpbmcgbm9ybWFsIHpyVXRpbC5tZXJnZSB3aWxsIGNhdXNlXG4gKiB7cmlnaHQ6IDB9IGRvZXMgbm90IHRha2UgZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuICogICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgLi4uXG4gKiAgICAgICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pO1xuICogICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKGlucHV0UG9zaXRpb25QYXJhbXMpO1xuICogICAgIH0sXG4gKiAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAqICAgICAgICAgbmV3T3B0aW9uICYmIHpyVXRpbC5tZXJnZSh0aGlzT3B0aW9uLCBuZXdPcHRpb24sIHRydWUpO1xuICogICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzT3B0aW9uLCBuZXdPcHRpb24pO1xuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRPcHRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPcHRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdF1cbiAqIEBwYXJhbSB7Ym9vbGVhbnxBcnJheS48Ym9vbGVhbj59IFtvcHQuaWdub3JlU2l6ZT1mYWxzZV0gVXNlZCBmb3IgdGhlIGNvbXBvbmVudHNcbiAqICB0aGF0IHdpZHRoIChvciBoZWlnaHQpIHNob3VsZCBub3QgYmUgY2FsY3VsYXRlZCBieSBsZWZ0IGFuZCByaWdodCAob3IgdG9wIGFuZCBib3R0b20pLlxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VMYXlvdXRQYXJhbSh0YXJnZXRPcHRpb24sIG5ld09wdGlvbiwgb3B0KSB7XG4gICF6clV0aWwuaXNPYmplY3Qob3B0KSAmJiAob3B0ID0ge30pO1xuICB2YXIgaWdub3JlU2l6ZSA9IG9wdC5pZ25vcmVTaXplO1xuICAhenJVdGlsLmlzQXJyYXkoaWdub3JlU2l6ZSkgJiYgKGlnbm9yZVNpemUgPSBbaWdub3JlU2l6ZSwgaWdub3JlU2l6ZV0pO1xuICB2YXIgaFJlc3VsdCA9IG1lcmdlKEhWX05BTUVTWzBdLCAwKTtcbiAgdmFyIHZSZXN1bHQgPSBtZXJnZShIVl9OQU1FU1sxXSwgMSk7XG4gIGNvcHkoSFZfTkFNRVNbMF0sIHRhcmdldE9wdGlvbiwgaFJlc3VsdCk7XG4gIGNvcHkoSFZfTkFNRVNbMV0sIHRhcmdldE9wdGlvbiwgdlJlc3VsdCk7XG5cbiAgZnVuY3Rpb24gbWVyZ2UobmFtZXMsIGh2SWR4KSB7XG4gICAgdmFyIG5ld1BhcmFtcyA9IHt9O1xuICAgIHZhciBuZXdWYWx1ZUNvdW50ID0gMDtcbiAgICB2YXIgbWVyZ2VkID0ge307XG4gICAgdmFyIG1lcmdlZFZhbHVlQ291bnQgPSAwO1xuICAgIHZhciBlbm91Z2hQYXJhbU51bWJlciA9IDI7XG4gICAgZWFjaChuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIG1lcmdlZFtuYW1lXSA9IHRhcmdldE9wdGlvbltuYW1lXTtcbiAgICB9KTtcbiAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgLy8gQ29uc2lkZXIgY2FzZTogbmV3T3B0aW9uLndpZHRoIGlzIG51bGwsIHdoaWNoIGlzXG4gICAgICAvLyBzZXQgYnkgdXNlciBmb3IgcmVtb3Zpbmcgd2lkdGggc2V0dGluZy5cbiAgICAgIGhhc1Byb3AobmV3T3B0aW9uLCBuYW1lKSAmJiAobmV3UGFyYW1zW25hbWVdID0gbWVyZ2VkW25hbWVdID0gbmV3T3B0aW9uW25hbWVdKTtcbiAgICAgIGhhc1ZhbHVlKG5ld1BhcmFtcywgbmFtZSkgJiYgbmV3VmFsdWVDb3VudCsrO1xuICAgICAgaGFzVmFsdWUobWVyZ2VkLCBuYW1lKSAmJiBtZXJnZWRWYWx1ZUNvdW50Kys7XG4gICAgfSk7XG5cbiAgICBpZiAoaWdub3JlU2l6ZVtodklkeF0pIHtcbiAgICAgIC8vIE9ubHkgb25lIG9mIGxlZnQvcmlnaHQgaXMgcHJlbWl0dGVkIHRvIGV4aXN0LlxuICAgICAgaWYgKGhhc1ZhbHVlKG5ld09wdGlvbiwgbmFtZXNbMV0pKSB7XG4gICAgICAgIG1lcmdlZFtuYW1lc1syXV0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChoYXNWYWx1ZShuZXdPcHRpb24sIG5hbWVzWzJdKSkge1xuICAgICAgICBtZXJnZWRbbmFtZXNbMV1dID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9IC8vIENhc2U6IG5ld09wdGlvbjoge3dpZHRoOiAuLi4sIHJpZ2h0OiAuLi59LFxuICAgIC8vIG9yIHRhcmdldE9wdGlvbjoge3JpZ2h0OiAuLi59IGFuZCBuZXdPcHRpb246IHt3aWR0aDogLi4ufSxcbiAgICAvLyBUaGVyZSBpcyBubyBjb25mbGljdCB3aGVuIG1lcmdlZCBvbmx5IGhhcyBwYXJhbXMgY291bnRcbiAgICAvLyBsaXR0bGUgdGhhbiBlbm91Z2hQYXJhbU51bWJlci5cblxuXG4gICAgaWYgKG1lcmdlZFZhbHVlQ291bnQgPT09IGVub3VnaFBhcmFtTnVtYmVyIHx8ICFuZXdWYWx1ZUNvdW50KSB7XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH0gLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgLy8gVGhhbiB3ZSBjYW4gbWFrZSBzdXJlIHVzZXIgb25seSB3YW50IHRob3NlIHR3bywgYW5kIGlnbm9yZVxuICAgIC8vIGFsbCBvcmlnaW4gcGFyYW1zIGluIHRhcmdldE9wdGlvbi5cbiAgICBlbHNlIGlmIChuZXdWYWx1ZUNvdW50ID49IGVub3VnaFBhcmFtTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDaG9zZSBhbm90aGVyIHBhcmFtIGZyb20gdGFyZ2V0T3B0aW9uIGJ5IHByaW9yaXR5LlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcblxuICAgICAgICAgIGlmICghaGFzUHJvcChuZXdQYXJhbXMsIG5hbWUpICYmIGhhc1Byb3AodGFyZ2V0T3B0aW9uLCBuYW1lKSkge1xuICAgICAgICAgICAgbmV3UGFyYW1zW25hbWVdID0gdGFyZ2V0T3B0aW9uW25hbWVdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1Byb3Aob2JqLCBuYW1lKSB7XG4gICAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1ZhbHVlKG9iaiwgbmFtZSkge1xuICAgIHJldHVybiBvYmpbbmFtZV0gIT0gbnVsbCAmJiBvYmpbbmFtZV0gIT09ICdhdXRvJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHkobmFtZXMsIHRhcmdldCwgc291cmNlKSB7XG4gICAgZWFjaChuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBSZXRyaWV2ZSAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ3dpZHRoJywgJ2hlaWdodCcgZnJvbSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJlc3VsdCBjb250YWlucyB0aG9zZSBwcm9wcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExheW91dFBhcmFtcyhzb3VyY2UpIHtcbiAgcmV0dXJuIGNvcHlMYXlvdXRQYXJhbXMoe30sIHNvdXJjZSk7XG59XG4vKipcbiAqIFJldHJpZXZlICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0JyBmcm9tIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAqIEByZXR1cm4ge09iamVjdH0gUmVzdWx0IGNvbnRhaW5zIHRob3NlIHByb3BzLlxuICovXG5cblxuZnVuY3Rpb24gY29weUxheW91dFBhcmFtcyh0YXJnZXQsIHNvdXJjZSkge1xuICBzb3VyY2UgJiYgdGFyZ2V0ICYmIGVhY2goTE9DQVRJT05fUEFSQU1TLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAodGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdKTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydHMuTE9DQVRJT05fUEFSQU1TID0gTE9DQVRJT05fUEFSQU1TO1xuZXhwb3J0cy5IVl9OQU1FUyA9IEhWX05BTUVTO1xuZXhwb3J0cy5ib3ggPSBib3g7XG5leHBvcnRzLnZib3ggPSB2Ym94O1xuZXhwb3J0cy5oYm94ID0gaGJveDtcbmV4cG9ydHMuZ2V0QXZhaWxhYmxlU2l6ZSA9IGdldEF2YWlsYWJsZVNpemU7XG5leHBvcnRzLmdldExheW91dFJlY3QgPSBnZXRMYXlvdXRSZWN0O1xuZXhwb3J0cy5wb3NpdGlvbkVsZW1lbnQgPSBwb3NpdGlvbkVsZW1lbnQ7XG5leHBvcnRzLnNpemVDYWxjdWxhYmxlID0gc2l6ZUNhbGN1bGFibGU7XG5leHBvcnRzLm1lcmdlTGF5b3V0UGFyYW0gPSBtZXJnZUxheW91dFBhcmFtO1xuZXhwb3J0cy5nZXRMYXlvdXRQYXJhbXMgPSBnZXRMYXlvdXRQYXJhbXM7XG5leHBvcnRzLmNvcHlMYXlvdXRQYXJhbXMgPSBjb3B5TGF5b3V0UGFyYW1zO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2xheW91dC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xudmFyIGlzQXJyYXkgPSB6clV0aWwuaXNBcnJheTtcbi8qKlxuICogTWFrZSB0aGUgbmFtZSBkaXNwbGF5YWJsZS4gQnV0IHdlIHNob3VsZFxuICogbWFrZSBzdXJlIGl0IGlzIG5vdCBkdXBsaWNhdGVkIHdpdGggdXNlclxuICogc3BlY2lmaWVkIG5hbWUsIHNvIHVzZSAnXFwwJztcbiAqL1xuXG52YXIgRFVNTVlfQ09NUE9ORU5UX05BTUVfUFJFRklYID0gJ3Nlcmllc1xcMCc7XG4vKipcbiAqIElmIHZhbHVlIGlzIG5vdCBhcnJheSwgdGhlbiB0cmFuc2xhdGUgaXQgdG8gYXJyYXkuXG4gKiBAcGFyYW0gIHsqfSB2YWx1ZVxuICogQHJldHVybiB7QXJyYXl9IFt2YWx1ZV0gb3IgdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWUgOiB2YWx1ZSA9PSBudWxsID8gW10gOiBbdmFsdWVdO1xufVxuLyoqXG4gKiBTeW5jIGRlZmF1bHQgb3B0aW9uIGJldHdlZW4gbm9ybWFsIGFuZCBlbXBoYXNpcyBsaWtlIGBwb3NpdGlvbmAgYW5kIGBzaG93YFxuICogSW4gY2FzZSBzb21lIG9uZSB3aWxsIHdyaXRlIGNvZGUgbGlrZVxuICogICAgIGxhYmVsOiB7XG4gKiAgICAgICAgICBzaG93OiBmYWxzZSxcbiAqICAgICAgICAgIHBvc2l0aW9uOiAnb3V0c2lkZScsXG4gKiAgICAgICAgICBmb250U2l6ZTogMThcbiAqICAgICB9LFxuICogICAgIGVtcGhhc2lzOiB7XG4gKiAgICAgICAgICBsYWJlbDogeyBzaG93OiB0cnVlIH1cbiAqICAgICB9XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzdWJPcHRzXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0RW1waGFzaXMob3B0LCBrZXksIHN1Yk9wdHMpIHtcbiAgLy8gQ2F1dGlvbjogcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICBpZiAob3B0KSB7XG4gICAgb3B0W2tleV0gPSBvcHRba2V5XSB8fCB7fTtcbiAgICBvcHQuZW1waGFzaXMgPSBvcHQuZW1waGFzaXMgfHwge307XG4gICAgb3B0LmVtcGhhc2lzW2tleV0gPSBvcHQuZW1waGFzaXNba2V5XSB8fCB7fTsgLy8gRGVmYXVsdCBlbXBoYXNpcyBvcHRpb24gZnJvbSBub3JtYWxcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJPcHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3ViT3B0TmFtZSA9IHN1Yk9wdHNbaV07XG5cbiAgICAgIGlmICghb3B0LmVtcGhhc2lzW2tleV0uaGFzT3duUHJvcGVydHkoc3ViT3B0TmFtZSkgJiYgb3B0W2tleV0uaGFzT3duUHJvcGVydHkoc3ViT3B0TmFtZSkpIHtcbiAgICAgICAgb3B0LmVtcGhhc2lzW2tleV1bc3ViT3B0TmFtZV0gPSBvcHRba2V5XVtzdWJPcHROYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFRFWFRfU1RZTEVfT1BUSU9OUyA9IFsnZm9udFN0eWxlJywgJ2ZvbnRXZWlnaHQnLCAnZm9udFNpemUnLCAnZm9udEZhbWlseScsICdyaWNoJywgJ3RhZycsICdjb2xvcicsICd0ZXh0Qm9yZGVyQ29sb3InLCAndGV4dEJvcmRlcldpZHRoJywgJ3dpZHRoJywgJ2hlaWdodCcsICdsaW5lSGVpZ2h0JywgJ2FsaWduJywgJ3ZlcnRpY2FsQWxpZ24nLCAnYmFzZWxpbmUnLCAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknLCAndGV4dFNoYWRvd0NvbG9yJywgJ3RleHRTaGFkb3dCbHVyJywgJ3RleHRTaGFkb3dPZmZzZXRYJywgJ3RleHRTaGFkb3dPZmZzZXRZJywgJ2JhY2tncm91bmRDb2xvcicsICdib3JkZXJDb2xvcicsICdib3JkZXJXaWR0aCcsICdib3JkZXJSYWRpdXMnLCAncGFkZGluZyddOyAvLyBtb2RlbFV0aWwuTEFCRUxfT1BUSU9OUyA9IG1vZGVsVXRpbC5URVhUX1NUWUxFX09QVElPTlMuY29uY2F0KFtcbi8vICAgICAncG9zaXRpb24nLCAnb2Zmc2V0JywgJ3JvdGF0ZScsICdvcmlnaW4nLCAnc2hvdycsICdkaXN0YW5jZScsICdmb3JtYXR0ZXInLFxuLy8gICAgICdmb250U3R5bGUnLCAnZm9udFdlaWdodCcsICdmb250U2l6ZScsICdmb250RmFtaWx5Jyxcbi8vICAgICAvLyBGSVhNRTogZGVwcmVjYXRlZCwgY2hlY2sgYW5kIHJlbW92ZSBpdC5cbi8vICAgICAndGV4dFN0eWxlJ1xuLy8gXSk7XG5cbi8qKlxuICogVGhlIG1ldGhvZCBkbyBub3QgZW5zdXJlIHBlcmZvcm1hbmNlLlxuICogZGF0YSBjb3VsZCBiZSBbMTIsIDIzMjMsIHt2YWx1ZTogMjIzfSwgWzEyMjEsIDIzXSwge3ZhbHVlOiBbMiwgMjNdfV1cbiAqIFRoaXMgaGVscGVyIG1ldGhvZCByZXRpZXZlcyB2YWx1ZSBmcm9tIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8RGF0ZXxBcnJheXxPYmplY3R9IGRhdGFJdGVtXG4gKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfERhdGV8QXJyYXkuPG51bWJlcnxzdHJpbmd8RGF0ZT59XG4gKi9cblxuZnVuY3Rpb24gZ2V0RGF0YUl0ZW1WYWx1ZShkYXRhSXRlbSkge1xuICByZXR1cm4gaXNPYmplY3QoZGF0YUl0ZW0pICYmICFpc0FycmF5KGRhdGFJdGVtKSAmJiAhKGRhdGFJdGVtIGluc3RhbmNlb2YgRGF0ZSkgPyBkYXRhSXRlbS52YWx1ZSA6IGRhdGFJdGVtO1xufVxuLyoqXG4gKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxuICogVGhpcyBoZWxwZXIgbWV0aG9kIGRldGVybWluZSBpZiBkYXRhSXRlbSBoYXMgZXh0cmEgb3B0aW9uIGJlc2lkZXMgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxEYXRlfEFycmF5fE9iamVjdH0gZGF0YUl0ZW1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRGF0YUl0ZW1PcHRpb24oZGF0YUl0ZW0pIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGRhdGFJdGVtKSAmJiAhKGRhdGFJdGVtIGluc3RhbmNlb2YgQXJyYXkpOyAvLyAvLyBtYXJrTGluZSBkYXRhIGNhbiBiZSBhcnJheVxuICAvLyAmJiAhKGRhdGFJdGVtWzBdICYmIGlzT2JqZWN0KGRhdGFJdGVtWzBdKSAmJiAhKGRhdGFJdGVtWzBdIGluc3RhbmNlb2YgQXJyYXkpKTtcbn1cbi8qKlxuICogTWFwcGluZyB0byBleGlzdHMgZm9yIG1lcmdlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD58QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59IGV4aXN0c1xuICogQHBhcmFtIHtPYmplY3R8QXJyYXkuPE9iamVjdD59IG5ld0NwdE9wdGlvbnNcbiAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBSZXN1bHQsIGxpa2UgW3tleGlzdDogLi4uLCBvcHRpb246IC4uLn0sIHt9XSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCBvZiB3aGljaCBpcyB0aGUgc2FtZSBhcyBleGlzdHMuXG4gKi9cblxuXG5mdW5jdGlvbiBtYXBwaW5nVG9FeGlzdHMoZXhpc3RzLCBuZXdDcHRPcHRpb25zKSB7XG4gIC8vIE1hcHBpbmcgYnkgdGhlIG9yZGVyIGJ5IG9yaWdpbmFsIG9wdGlvbiAoYnV0IG5vdCBvcmRlciBvZlxuICAvLyBuZXcgb3B0aW9uKSBpbiBtZXJnZSBtb2RlLiBCZWNhdXNlIHdlIHNob3VsZCBlbnN1cmVcbiAgLy8gc29tZSBzcGVjaWZpZWQgaW5kZXggKGxpa2UgeEF4aXNJbmRleCkgaXMgY29uc2lzdGVudCB3aXRoXG4gIC8vIG9yaWdpbmFsIG9wdGlvbiwgd2hpY2ggaXMgZWFzeSB0byB1bmRlcnN0YW5kLCBlc3BhdGlhbGx5IGluXG4gIC8vIG1lZGlhIHF1ZXJ5LiBBbmQgaW4gbW9zdCBjYXNlLCBtZXJnZSBvcHRpb24gaXMgdXNlZCB0b1xuICAvLyB1cGRhdGUgcGFydGlhbCBvcHRpb24gYnV0IG5vdCBiZSBleHBlY3RlZCB0byBjaGFuZ2Ugb3JkZXIuXG4gIG5ld0NwdE9wdGlvbnMgPSAobmV3Q3B0T3B0aW9ucyB8fCBbXSkuc2xpY2UoKTtcbiAgdmFyIHJlc3VsdCA9IHpyVXRpbC5tYXAoZXhpc3RzIHx8IFtdLCBmdW5jdGlvbiAob2JqLCBpbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICBleGlzdDogb2JqXG4gICAgfTtcbiAgfSk7IC8vIE1hcHBpbmcgYnkgaWQgb3IgbmFtZSBpZiBzcGVjaWZpZWQuXG5cbiAgZWFjaChuZXdDcHRPcHRpb25zLCBmdW5jdGlvbiAoY3B0T3B0aW9uLCBpbmRleCkge1xuICAgIGlmICghaXNPYmplY3QoY3B0T3B0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWQgaGFzIGhpZ2hlc3QgcHJpb3JpdHkuXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXJlc3VsdFtpXS5vcHRpb24gLy8gQ29uc2lkZXIgbmFtZTogdHdvIG1hcCB0byBvbmUuXG4gICAgICAmJiBjcHRPcHRpb24uaWQgIT0gbnVsbCAmJiByZXN1bHRbaV0uZXhpc3QuaWQgPT09IGNwdE9wdGlvbi5pZCArICcnKSB7XG4gICAgICAgIHJlc3VsdFtpXS5vcHRpb24gPSBjcHRPcHRpb247XG4gICAgICAgIG5ld0NwdE9wdGlvbnNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXhpc3QgPSByZXN1bHRbaV0uZXhpc3Q7XG5cbiAgICAgIGlmICghcmVzdWx0W2ldLm9wdGlvbiAvLyBDb25zaWRlciBuYW1lOiB0d28gbWFwIHRvIG9uZS5cbiAgICAgIC8vIENhbiBub3QgbWF0Y2ggd2hlbiBib3RoIGlkcyBleGlzdCBidXQgZGlmZmVyZW50LlxuICAgICAgJiYgKGV4aXN0LmlkID09IG51bGwgfHwgY3B0T3B0aW9uLmlkID09IG51bGwpICYmIGNwdE9wdGlvbi5uYW1lICE9IG51bGwgJiYgIWlzSWRJbm5lcihjcHRPcHRpb24pICYmICFpc0lkSW5uZXIoZXhpc3QpICYmIGV4aXN0Lm5hbWUgPT09IGNwdE9wdGlvbi5uYW1lICsgJycpIHtcbiAgICAgICAgcmVzdWx0W2ldLm9wdGlvbiA9IGNwdE9wdGlvbjtcbiAgICAgICAgbmV3Q3B0T3B0aW9uc1tpbmRleF0gPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9KTsgLy8gT3RoZXJ3aXNlIG1hcHBpbmcgYnkgaW5kZXguXG5cbiAgZWFjaChuZXdDcHRPcHRpb25zLCBmdW5jdGlvbiAoY3B0T3B0aW9uLCBpbmRleCkge1xuICAgIGlmICghaXNPYmplY3QoY3B0T3B0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXhpc3QgPSByZXN1bHRbaV0uZXhpc3Q7XG5cbiAgICAgIGlmICghcmVzdWx0W2ldLm9wdGlvbiAvLyBFeGlzdGluZyBtb2RlbCB0aGF0IGFscmVhZHkgaGFzIGlkIHNob3VsZCBiZSBhYmxlIHRvXG4gICAgICAvLyBtYXBwZWQgdG8gKGJlY2F1c2UgYWZ0ZXIgbWFwcGluZyBwZXJmb3JtZWQgbW9kZWwgbWF5XG4gICAgICAvLyBiZSBhc3NpZ25lZCB3aXRoIGEgaWQsIHdoaXNoIHNob3VsZCBub3QgYWZmZWN0IG5leHRcbiAgICAgIC8vIG1hcHBpbmcpLCBleGNlcHQgdGhvc2UgaGFzIGlubmVyIGlkLlxuICAgICAgJiYgIWlzSWRJbm5lcihleGlzdCkgLy8gQ2F1dGlvbjpcbiAgICAgIC8vIERvIG5vdCBvdmVyd3JpdGUgaWQuIEJ1dCBuYW1lIGNhbiBiZSBvdmVyd3JpdHRlbixcbiAgICAgIC8vIGJlY2F1c2UgYXhpcyB1c2UgbmFtZSBhcyAnc2hvdyBsYWJlbCB0ZXh0Jy5cbiAgICAgIC8vICdleGlzdCcgYWx3YXlzIGhhcyBpZCBhbmQgbmFtZSBhbmQgd2UgZG9udFxuICAgICAgLy8gbmVlZCB0byBjaGVjayBpdC5cbiAgICAgICYmIGNwdE9wdGlvbi5pZCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdFtpXS5vcHRpb24gPSBjcHRPcHRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpID49IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgb3B0aW9uOiBjcHRPcHRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIE1ha2UgaWQgYW5kIG5hbWUgZm9yIG1hcHBpbmcgcmVzdWx0IChyZXN1bHQgb2YgbWFwcGluZ1RvRXhpc3RzKVxuICogaW50byBga2V5SW5mb2AgZmllbGQuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gUmVzdWx0LCBsaWtlIFt7ZXhpc3Q6IC4uLiwgb3B0aW9uOiAuLi59LCB7fV0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggb3JkZXIgaXMgdGhlIHNhbWUgYXMgZXhpc3RzLlxuICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59IFRoZSBpbnB1dC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1ha2VJZEFuZE5hbWUobWFwUmVzdWx0KSB7XG4gIC8vIFdlIHVzZSB0aGlzIGlkIHRvIGhhc2ggY29tcG9uZW50IG1vZGVscyBhbmQgdmlldyBpbnN0YW5jZXNcbiAgLy8gaW4gZWNoYXJ0cy4gaWQgY2FuIGJlIHNwZWNpZmllZCBieSB1c2VyLCBvciBhdXRvIGdlbmVyYXRlZC5cbiAgLy8gVGhlIGlkIGdlbmVyYXRpb24gcnVsZSBlbnN1cmVzIG5ldyB2aWV3IGluc3RhbmNlIGFyZSBhYmxlXG4gIC8vIHRvIG1hcHBlZCB0byBvbGQgaW5zdGFuY2Ugd2hlbiBzZXRPcHRpb24gYXJlIGNhbGxlZCBpblxuICAvLyBuby1tZXJnZSBtb2RlLiBTbyB3ZSBnZW5lcmF0ZSBtb2RlbCBpZCBieSBuYW1lIGFuZCBwbHVzXG4gIC8vIHR5cGUgaW4gdmlldyBpZC5cbiAgLy8gbmFtZSBjYW4gYmUgZHVwbGljYXRlZCBhbW9uZyBjb21wb25lbnRzLCB3aGljaCBpcyBjb252ZW5pZW50XG4gIC8vIHRvIHNwZWNpZnkgbXVsdGkgY29tcG9uZW50cyAobGlrZSBzZXJpZXMpIGJ5IG9uZSBuYW1lLlxuICAvLyBFbnN1cmUgdGhhdCBlYWNoIGlkIGlzIGRpc3RpbmN0LlxuICB2YXIgaWRNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgdmFyIGV4aXN0Q3B0ID0gaXRlbS5leGlzdDtcbiAgICBleGlzdENwdCAmJiBpZE1hcC5zZXQoZXhpc3RDcHQuaWQsIGl0ZW0pO1xuICB9KTtcbiAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHZhciBvcHQgPSBpdGVtLm9wdGlvbjtcbiAgICB6clV0aWwuYXNzZXJ0KCFvcHQgfHwgb3B0LmlkID09IG51bGwgfHwgIWlkTWFwLmdldChvcHQuaWQpIHx8IGlkTWFwLmdldChvcHQuaWQpID09PSBpdGVtLCAnaWQgZHVwbGljYXRlczogJyArIChvcHQgJiYgb3B0LmlkKSk7XG4gICAgb3B0ICYmIG9wdC5pZCAhPSBudWxsICYmIGlkTWFwLnNldChvcHQuaWQsIGl0ZW0pO1xuICAgICFpdGVtLmtleUluZm8gJiYgKGl0ZW0ua2V5SW5mbyA9IHt9KTtcbiAgfSk7IC8vIE1ha2UgbmFtZSBhbmQgaWQuXG5cbiAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHZhciBleGlzdENwdCA9IGl0ZW0uZXhpc3Q7XG4gICAgdmFyIG9wdCA9IGl0ZW0ub3B0aW9uO1xuICAgIHZhciBrZXlJbmZvID0gaXRlbS5rZXlJbmZvO1xuXG4gICAgaWYgKCFpc09iamVjdChvcHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBuYW1lIGNhbiBiZSBvdmVyd2l0dGVuLiBDb25zaWRlciBjYXNlOiBheGlzLm5hbWUgPSAnMjBrbScuXG4gICAgLy8gQnV0IGlkIGdlbmVyYXRlZCBieSBuYW1lIHdpbGwgbm90IGJlIGNoYW5nZWQsIHdoaWNoIGFmZmVjdFxuICAgIC8vIG9ubHkgaW4gdGhhdCBjYXNlOiBzZXRPcHRpb24gd2l0aCAnbm90IG1lcmdlIG1vZGUnIGFuZCB2aWV3XG4gICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSByZWNyZWF0ZWQsIHdoaWNoIGNhbiBiZSBhY2NlcHRlZC5cblxuXG4gICAga2V5SW5mby5uYW1lID0gb3B0Lm5hbWUgIT0gbnVsbCA/IG9wdC5uYW1lICsgJycgOiBleGlzdENwdCA/IGV4aXN0Q3B0Lm5hbWUgLy8gQXZvaWQgZGlmZmZlcmVudCBzZXJpZXMgaGFzIHRoZSBzYW1lIG5hbWUsXG4gICAgLy8gYmVjYXVzZSBuYW1lIG1heSBiZSB1c2VkIGxpa2UgaW4gY29sb3IgcGFsbGV0LlxuICAgIDogRFVNTVlfQ09NUE9ORU5UX05BTUVfUFJFRklYICsgaW5kZXg7XG5cbiAgICBpZiAoZXhpc3RDcHQpIHtcbiAgICAgIGtleUluZm8uaWQgPSBleGlzdENwdC5pZDtcbiAgICB9IGVsc2UgaWYgKG9wdC5pZCAhPSBudWxsKSB7XG4gICAgICBrZXlJbmZvLmlkID0gb3B0LmlkICsgJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnNpZGVyIHRoaXMgc2l0dWF0b2luOlxuICAgICAgLy8gIG9wdGlvbkE6IFt7bmFtZTogJ2EnfSwge25hbWU6ICdhJ30sIHsuLn1dXG4gICAgICAvLyAgb3B0aW9uQiBbey4ufSwge25hbWU6ICdhJ30sIHtuYW1lOiAnYSd9XVxuICAgICAgLy8gU2VyaWVzIHdpdGggdGhlIHNhbWUgbmFtZSBiZXR3ZWVuIG9wdGlvbkEgYW5kIG9wdGlvbkJcbiAgICAgIC8vIHNob3VsZCBiZSBtYXBwZWQuXG4gICAgICB2YXIgaWROdW0gPSAwO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGtleUluZm8uaWQgPSAnXFwwJyArIGtleUluZm8ubmFtZSArICdcXDAnICsgaWROdW0rKztcbiAgICAgIH0gd2hpbGUgKGlkTWFwLmdldChrZXlJbmZvLmlkKSk7XG4gICAgfVxuXG4gICAgaWRNYXAuc2V0KGtleUluZm8uaWQsIGl0ZW0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNOYW1lU3BlY2lmaWVkKGNvbXBvbmVudE1vZGVsKSB7XG4gIHZhciBuYW1lID0gY29tcG9uZW50TW9kZWwubmFtZTsgLy8gSXMgc3BlY2lmaWVkIHdoZW4gYGluZGV4T2ZgIGdldCAtMSBvciA+IDAuXG5cbiAgcmV0dXJuICEhKG5hbWUgJiYgbmFtZS5pbmRleE9mKERVTU1ZX0NPTVBPTkVOVF9OQU1FX1BSRUZJWCkpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gY3B0T3B0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNJZElubmVyKGNwdE9wdGlvbikge1xuICByZXR1cm4gaXNPYmplY3QoY3B0T3B0aW9uKSAmJiBjcHRPcHRpb24uaWQgJiYgKGNwdE9wdGlvbi5pZCArICcnKS5pbmRleE9mKCdcXDBfZWNfXFwwJykgPT09IDA7XG59XG4vKipcbiAqIEEgaGVscGVyIGZvciByZW1vdmluZyBkdXBsaWNhdGUgaXRlbXMgYmV0d2VlbiBiYXRjaEEgYW5kIGJhdGNoQixcbiAqIGFuZCBpbiB0aGVtc2VsdmVzLCBhbmQgY2F0ZWdvcml6ZSBieSBzZXJpZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYmF0Y2hBIExpa2U6IFt7c2VyaWVzSWQ6IDIsIGRhdGFJbmRleDogWzMyLCA0LCA1XX0sIC4uLl1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGJhdGNoQiBMaWtlOiBbe3Nlcmllc0lkOiAyLCBkYXRhSW5kZXg6IFszMiwgNCwgNV19LCAuLi5dXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPE9iamVjdD4sIEFycmF5LjxPYmplY3Q+Pn0gcmVzdWx0OiBbcmVzdWx0QmF0Y2hBLCByZXN1bHRCYXRjaEJdXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wcmVzc0JhdGNoZXMoYmF0Y2hBLCBiYXRjaEIpIHtcbiAgdmFyIG1hcEEgPSB7fTtcbiAgdmFyIG1hcEIgPSB7fTtcbiAgbWFrZU1hcChiYXRjaEEgfHwgW10sIG1hcEEpO1xuICBtYWtlTWFwKGJhdGNoQiB8fCBbXSwgbWFwQiwgbWFwQSk7XG4gIHJldHVybiBbbWFwVG9BcnJheShtYXBBKSwgbWFwVG9BcnJheShtYXBCKV07XG5cbiAgZnVuY3Rpb24gbWFrZU1hcChzb3VyY2VCYXRjaCwgbWFwLCBvdGhlck1hcCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VCYXRjaC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHNlcmllc0lkID0gc291cmNlQmF0Y2hbaV0uc2VyaWVzSWQ7XG4gICAgICB2YXIgZGF0YUluZGljZXMgPSBub3JtYWxpemVUb0FycmF5KHNvdXJjZUJhdGNoW2ldLmRhdGFJbmRleCk7XG4gICAgICB2YXIgb3RoZXJEYXRhSW5kaWNlcyA9IG90aGVyTWFwICYmIG90aGVyTWFwW3Nlcmllc0lkXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBkYXRhSW5kaWNlcy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzW2pdO1xuXG4gICAgICAgIGlmIChvdGhlckRhdGFJbmRpY2VzICYmIG90aGVyRGF0YUluZGljZXNbZGF0YUluZGV4XSkge1xuICAgICAgICAgIG90aGVyRGF0YUluZGljZXNbZGF0YUluZGV4XSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKG1hcFtzZXJpZXNJZF0gfHwgKG1hcFtzZXJpZXNJZF0gPSB7fSkpW2RhdGFJbmRleF0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXAsIGlzRGF0YSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgaW4gbWFwKSB7XG4gICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KGkpICYmIG1hcFtpXSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc0RhdGEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgraSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRhdGFJbmRpY2VzID0gbWFwVG9BcnJheShtYXBbaV0sIHRydWUpO1xuICAgICAgICAgIGRhdGFJbmRpY2VzLmxlbmd0aCAmJiByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBzZXJpZXNJZDogaSxcbiAgICAgICAgICAgIGRhdGFJbmRleDogZGF0YUluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIENvbnRhaW5zIGRhdGFJbmRleCAobWVhbnMgcmF3SW5kZXgpIC8gZGF0YUluZGV4SW5zaWRlIC8gbmFtZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBvZiB3aGljaCBjYW4gYmUgQXJyYXkgb3IgcHJpbWFyeSB0eXBlLlxuICogQHJldHVybiB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBkYXRhSW5kZXggSWYgbm90IGZvdW5kLCByZXR1cm4gdW5kZWZpbmVkL251bGwuXG4gKi9cblxuXG5mdW5jdGlvbiBxdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLmRhdGFJbmRleEluc2lkZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuZGF0YUluZGV4SW5zaWRlO1xuICB9IGVsc2UgaWYgKHBheWxvYWQuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICByZXR1cm4genJVdGlsLmlzQXJyYXkocGF5bG9hZC5kYXRhSW5kZXgpID8genJVdGlsLm1hcChwYXlsb2FkLmRhdGFJbmRleCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGF0YS5pbmRleE9mUmF3SW5kZXgodmFsdWUpO1xuICAgIH0pIDogZGF0YS5pbmRleE9mUmF3SW5kZXgocGF5bG9hZC5kYXRhSW5kZXgpO1xuICB9IGVsc2UgaWYgKHBheWxvYWQubmFtZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KHBheWxvYWQubmFtZSkgPyB6clV0aWwubWFwKHBheWxvYWQubmFtZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGF0YS5pbmRleE9mTmFtZSh2YWx1ZSk7XG4gICAgfSkgOiBkYXRhLmluZGV4T2ZOYW1lKHBheWxvYWQubmFtZSk7XG4gIH1cbn1cbi8qKlxuICogRW5hYmxlIHByb3BlcnR5IHN0b3JhZ2UgdG8gYW55IGhvc3Qgb2JqZWN0LlxuICogTm90aWNlOiBTZXJpYWxpemF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKiB2YXIgaW5uZXIgPSB6clVpdGwubWFrZUlubmVyKCk7XG4gKlxuICogZnVuY3Rpb24gc29tZTEoaG9zdE9iaikge1xuICogICAgICBpbm5lcihob3N0T2JqKS5zb21lUHJvcGVydHkgPSAxMjEyO1xuICogICAgICAuLi5cbiAqIH1cbiAqIGZ1bmN0aW9uIHNvbWUyKCkge1xuICogICAgICB2YXIgZmllbGRzID0gaW5uZXIodGhpcyk7XG4gKiAgICAgIGZpZWxkcy5zb21lUHJvcGVydHkxID0gMTIxMjtcbiAqICAgICAgZmllbGRzLnNvbWVQcm9wZXJ0eTIgPSAneHgnO1xuICogICAgICAuLi5cbiAqIH1cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1ha2VJbm5lcigpIHtcbiAgLy8gQ29uc2lkZXIgZGlmZmVyZW50IHNjb3BlIGJ5IGVzIG1vZHVsZSBpbXBvcnQuXG4gIHZhciBrZXkgPSAnX19cXDBlY19pbm5lcl8nICsgaW5uZXJVbmlxdWVJbmRleCsrICsgJ18nICsgTWF0aC5yYW5kb20oKS50b0ZpeGVkKDUpO1xuICByZXR1cm4gZnVuY3Rpb24gKGhvc3RPYmopIHtcbiAgICByZXR1cm4gaG9zdE9ialtrZXldIHx8IChob3N0T2JqW2tleV0gPSB7fSk7XG4gIH07XG59XG5cbnZhciBpbm5lclVuaXF1ZUluZGV4ID0gMDtcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgc2VyaWVzSW5kZXgsIHNlcmllc0lkLCBzZXJpZXNOYW1lLFxuICogICAgICAgICAgICBnZW9JbmRleCwgZ2VvSWQsIGdlb05hbWUsXG4gKiAgICAgICAgICAgIGJtYXBJbmRleCwgYm1hcElkLCBibWFwTmFtZSxcbiAqICAgICAgICAgICAgeEF4aXNJbmRleCwgeEF4aXNJZCwgeEF4aXNOYW1lLFxuICogICAgICAgICAgICB5QXhpc0luZGV4LCB5QXhpc0lkLCB5QXhpc05hbWUsXG4gKiAgICAgICAgICAgIGdyaWRJbmRleCwgZ3JpZElkLCBncmlkTmFtZSxcbiAqICAgICAgICAgICAgLi4uIChjYW4gYmUgZXh0ZW5kZWQpXG4gKiAgICAgICAgfVxuICogICAgICAgIEVhY2ggcHJvcGVydGllcyBjYW4gYmUgbnVtYmVyfHN0cmluZ3xBcnJheS48bnVtYmVyPnxBcnJheS48c3RyaW5nPlxuICogICAgICAgIEZvciBleGFtcGxlLCBhIGZpbmRlciBjb3VsZCBiZVxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgc2VyaWVzSW5kZXg6IDMsXG4gKiAgICAgICAgICAgIGdlb0lkOiBbJ2FhJywgJ2NjJ10sXG4gKiAgICAgICAgICAgIGdyaWROYW1lOiBbJ3h4JywgJ3JyJ11cbiAqICAgICAgICB9XG4gKiAgICAgICAgeHh4SW5kZXggY2FuIGJlIHNldCBhcyAnYWxsJyAobWVhbnMgYWxsIHh4eCkgb3IgJ25vbmUnIChtZWFucyBub3Qgc3BlY2lmeSlcbiAqICAgICAgICBJZiBub3RoaW5nIG9yIG51bGwvdW5kZWZpbmVkIHNwZWNpZmllZCwgcmV0dXJuIG5vdGhpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmRlZmF1bHRNYWluVHlwZV1cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtvcHQuaW5jbHVkZU1haW5UeXBlc11cbiAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0IGxpa2U6XG4gKiAgICAgICAge1xuICogICAgICAgICAgICBzZXJpZXNNb2RlbHM6IFtzZXJpZXNNb2RlbDEsIHNlcmllc01vZGVsMl0sXG4gKiAgICAgICAgICAgIHNlcmllc01vZGVsOiBzZXJpZXNNb2RlbDEsIC8vIFRoZSBmaXJzdCBtb2RlbFxuICogICAgICAgICAgICBnZW9Nb2RlbHM6IFtnZW9Nb2RlbDEsIGdlb01vZGVsMl0sXG4gKiAgICAgICAgICAgIGdlb01vZGVsOiBnZW9Nb2RlbDEsIC8vIFRoZSBmaXJzdCBtb2RlbFxuICogICAgICAgICAgICAuLi5cbiAqICAgICAgICB9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyLCBvcHQpIHtcbiAgaWYgKHpyVXRpbC5pc1N0cmluZyhmaW5kZXIpKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIG9ialtmaW5kZXIgKyAnSW5kZXgnXSA9IDA7XG4gICAgZmluZGVyID0gb2JqO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRNYWluVHlwZSA9IG9wdCAmJiBvcHQuZGVmYXVsdE1haW5UeXBlO1xuXG4gIGlmIChkZWZhdWx0TWFpblR5cGUgJiYgIWhhcyhmaW5kZXIsIGRlZmF1bHRNYWluVHlwZSArICdJbmRleCcpICYmICFoYXMoZmluZGVyLCBkZWZhdWx0TWFpblR5cGUgKyAnSWQnKSAmJiAhaGFzKGZpbmRlciwgZGVmYXVsdE1haW5UeXBlICsgJ05hbWUnKSkge1xuICAgIGZpbmRlcltkZWZhdWx0TWFpblR5cGUgKyAnSW5kZXgnXSA9IDA7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0ge307XG4gIGVhY2goZmluZGVyLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHZhciB2YWx1ZSA9IGZpbmRlcltrZXldOyAvLyBFeGNsdWRlICdkYXRhSW5kZXgnIGFuZCBvdGhlciBpbGxnYWwga2V5cy5cblxuICAgIGlmIChrZXkgPT09ICdkYXRhSW5kZXgnIHx8IGtleSA9PT0gJ2RhdGFJbmRleEluc2lkZScpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZEtleSA9IGtleS5tYXRjaCgvXihcXHcrKShJbmRleHxJZHxOYW1lKSQvKSB8fCBbXTtcbiAgICB2YXIgbWFpblR5cGUgPSBwYXJzZWRLZXlbMV07XG4gICAgdmFyIHF1ZXJ5VHlwZSA9IChwYXJzZWRLZXlbMl0gfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIW1haW5UeXBlIHx8ICFxdWVyeVR5cGUgfHwgdmFsdWUgPT0gbnVsbCB8fCBxdWVyeVR5cGUgPT09ICdpbmRleCcgJiYgdmFsdWUgPT09ICdub25lJyB8fCBvcHQgJiYgb3B0LmluY2x1ZGVNYWluVHlwZXMgJiYgenJVdGlsLmluZGV4T2Yob3B0LmluY2x1ZGVNYWluVHlwZXMsIG1haW5UeXBlKSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcXVlcnlQYXJhbSA9IHtcbiAgICAgIG1haW5UeXBlOiBtYWluVHlwZVxuICAgIH07XG5cbiAgICBpZiAocXVlcnlUeXBlICE9PSAnaW5kZXgnIHx8IHZhbHVlICE9PSAnYWxsJykge1xuICAgICAgcXVlcnlQYXJhbVtxdWVyeVR5cGVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIG1vZGVscyA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHF1ZXJ5UGFyYW0pO1xuICAgIHJlc3VsdFttYWluVHlwZSArICdNb2RlbHMnXSA9IG1vZGVscztcbiAgICByZXN1bHRbbWFpblR5cGUgKyAnTW9kZWwnXSA9IG1vZGVsc1swXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGhhcyhvYmosIHByb3ApIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCk7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShkb20sIGtleSwgdmFsdWUpIHtcbiAgZG9tLnNldEF0dHJpYnV0ZSA/IGRvbS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkgOiBkb21ba2V5XSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZG9tLCBrZXkpIHtcbiAgcmV0dXJuIGRvbS5nZXRBdHRyaWJ1dGUgPyBkb20uZ2V0QXR0cmlidXRlKGtleSkgOiBkb21ba2V5XTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVUb0FycmF5ID0gbm9ybWFsaXplVG9BcnJheTtcbmV4cG9ydHMuZGVmYXVsdEVtcGhhc2lzID0gZGVmYXVsdEVtcGhhc2lzO1xuZXhwb3J0cy5URVhUX1NUWUxFX09QVElPTlMgPSBURVhUX1NUWUxFX09QVElPTlM7XG5leHBvcnRzLmdldERhdGFJdGVtVmFsdWUgPSBnZXREYXRhSXRlbVZhbHVlO1xuZXhwb3J0cy5pc0RhdGFJdGVtT3B0aW9uID0gaXNEYXRhSXRlbU9wdGlvbjtcbmV4cG9ydHMubWFwcGluZ1RvRXhpc3RzID0gbWFwcGluZ1RvRXhpc3RzO1xuZXhwb3J0cy5tYWtlSWRBbmROYW1lID0gbWFrZUlkQW5kTmFtZTtcbmV4cG9ydHMuaXNOYW1lU3BlY2lmaWVkID0gaXNOYW1lU3BlY2lmaWVkO1xuZXhwb3J0cy5pc0lkSW5uZXIgPSBpc0lkSW5uZXI7XG5leHBvcnRzLmNvbXByZXNzQmF0Y2hlcyA9IGNvbXByZXNzQmF0Y2hlcztcbmV4cG9ydHMucXVlcnlEYXRhSW5kZXggPSBxdWVyeURhdGFJbmRleDtcbmV4cG9ydHMubWFrZUlubmVyID0gbWFrZUlubmVyO1xuZXhwb3J0cy5wYXJzZUZpbmRlciA9IHBhcnNlRmluZGVyO1xuZXhwb3J0cy5zZXRBdHRyaWJ1dGUgPSBzZXRBdHRyaWJ1dGU7XG5leHBvcnRzLmdldEF0dHJpYnV0ZSA9IGdldEF0dHJpYnV0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL21vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL21vZGVsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBSQURJQU5fRVBTSUxPTiA9IDFlLTQ7XG5cbmZ1bmN0aW9uIF90cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xufVxuLyoqXG4gKiBMaW5lYXIgbWFwcGluZyBhIHZhbHVlIGZyb20gZG9tYWluIHRvIHJhbmdlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmVjaGFydHMvdXRpbC9udW1iZXJcbiAqIEBwYXJhbSAgeyhudW1iZXJ8QXJyYXkuPG51bWJlcj4pfSB2YWxcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBkb21haW4gRG9tYWluIGV4dGVudCBkb21haW5bMF0gY2FuIGJlIGJpZ2dlciB0aGFuIGRvbWFpblsxXVxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJhbmdlICBSYW5nZSBleHRlbnQgcmFuZ2VbMF0gY2FuIGJlIGJpZ2dlciB0aGFuIHJhbmdlWzFdXG4gKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICogQHJldHVybiB7KG51bWJlcnxBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGxpbmVhck1hcCh2YWwsIGRvbWFpbiwgcmFuZ2UsIGNsYW1wKSB7XG4gIHZhciBzdWJEb21haW4gPSBkb21haW5bMV0gLSBkb21haW5bMF07XG4gIHZhciBzdWJSYW5nZSA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG5cbiAgaWYgKHN1YkRvbWFpbiA9PT0gMCkge1xuICAgIHJldHVybiBzdWJSYW5nZSA9PT0gMCA/IHJhbmdlWzBdIDogKHJhbmdlWzBdICsgcmFuZ2VbMV0pIC8gMjtcbiAgfSAvLyBBdm9pZCBhY2N1cmFjeSBwcm9ibGVtIGluIGVkZ2UsIHN1Y2ggYXNcbiAgLy8gMTQ2LjM5IC0gNjIuODMgPT09IDgzLjU1OTk5OTk5OTk5OTk5LlxuICAvLyBTZWUgZWNoYXJ0cy90ZXN0L3V0L3NwZWMvdXRpbC9udW1iZXIuanMjbGluZWFyTWFwI2FjY3VyYWN5RXJyb3JcbiAgLy8gSXQgaXMgYSBsaXR0bGUgdmVyYm9zZSBmb3IgZWZmaWNpZW5jeSBjb25zaWRlcmluZyB0aGlzIG1ldGhvZFxuICAvLyBpcyBhIGhvdHNwb3QuXG5cblxuICBpZiAoY2xhbXApIHtcbiAgICBpZiAoc3ViRG9tYWluID4gMCkge1xuICAgICAgaWYgKHZhbCA8PSBkb21haW5bMF0pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlWzBdO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPj0gZG9tYWluWzFdKSB7XG4gICAgICAgIHJldHVybiByYW5nZVsxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbCA+PSBkb21haW5bMF0pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlWzBdO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPD0gZG9tYWluWzFdKSB7XG4gICAgICAgIHJldHVybiByYW5nZVsxXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA9PT0gZG9tYWluWzBdKSB7XG4gICAgICByZXR1cm4gcmFuZ2VbMF07XG4gICAgfVxuXG4gICAgaWYgKHZhbCA9PT0gZG9tYWluWzFdKSB7XG4gICAgICByZXR1cm4gcmFuZ2VbMV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICh2YWwgLSBkb21haW5bMF0pIC8gc3ViRG9tYWluICogc3ViUmFuZ2UgKyByYW5nZVswXTtcbn1cbi8qKlxuICogQ29udmVydCBhIHBlcmNlbnQgc3RyaW5nIHRvIGFic29sdXRlIG51bWJlci5cbiAqIFJldHVybnMgTmFOIGlmIHBlcmNlbnQgaXMgbm90IGEgdmFsaWQgc3RyaW5nIG9yIG51bWJlclxuICogQG1lbWJlck9mIG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHBlcmNlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbGxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudChwZXJjZW50LCBhbGwpIHtcbiAgc3dpdGNoIChwZXJjZW50KSB7XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgcGVyY2VudCA9ICc1MCUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICd0b3AnOlxuICAgICAgcGVyY2VudCA9ICcwJSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgcGVyY2VudCA9ICcxMDAlJztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwZXJjZW50ID09PSAnc3RyaW5nJykge1xuICAgIGlmIChfdHJpbShwZXJjZW50KS5tYXRjaCgvJSQvKSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocGVyY2VudCkgLyAxMDAgKiBhbGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocGVyY2VudCk7XG4gIH1cblxuICByZXR1cm4gcGVyY2VudCA9PSBudWxsID8gTmFOIDogK3BlcmNlbnQ7XG59XG4vKipcbiAqICgxKSBGaXggcm91bmRpbmcgZXJyb3Igb2YgZmxvYXQgbnVtYmVycy5cbiAqICgyKSBTdXBwb3J0IHJldHVybiBzdHJpbmcgdG8gYXZvaWQgc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlICczLjVlLTcnLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbl1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVyblN0cl1cbiAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiByb3VuZCh4LCBwcmVjaXNpb24sIHJldHVyblN0cikge1xuICBpZiAocHJlY2lzaW9uID09IG51bGwpIHtcbiAgICBwcmVjaXNpb24gPSAxMDtcbiAgfSAvLyBBdm9pZCByYW5nZSBlcnJvclxuXG5cbiAgcHJlY2lzaW9uID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcHJlY2lzaW9uKSwgMjApO1xuICB4ID0gKCt4KS50b0ZpeGVkKHByZWNpc2lvbik7XG4gIHJldHVybiByZXR1cm5TdHIgPyB4IDogK3g7XG59XG5cbmZ1bmN0aW9uIGFzYyhhcnIpIHtcbiAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuICByZXR1cm4gYXJyO1xufVxuLyoqXG4gKiBHZXQgcHJlY2lzaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQcmVjaXNpb24odmFsKSB7XG4gIHZhbCA9ICt2YWw7XG5cbiAgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBJdCBpcyBtdWNoIGZhc3RlciB0aGFuIG1ldGhvZHMgY29udmVydGluZyBudW1iZXIgdG8gc3RyaW5nIGFzIGZvbGxvd3NcbiAgLy8gICAgICB2YXIgdG1wID0gdmFsLnRvU3RyaW5nKCk7XG4gIC8vICAgICAgcmV0dXJuIHRtcC5sZW5ndGggLSAxIC0gdG1wLmluZGV4T2YoJy4nKTtcbiAgLy8gZXNwZWNpYWxseSB3aGVuIHByZWNpc2lvbiBpcyBsb3dcblxuXG4gIHZhciBlID0gMTtcbiAgdmFyIGNvdW50ID0gMDtcblxuICB3aGlsZSAoTWF0aC5yb3VuZCh2YWwgKiBlKSAvIGUgIT09IHZhbCkge1xuICAgIGUgKj0gMTA7XG4gICAgY291bnQrKztcbiAgfVxuXG4gIHJldHVybiBjb3VudDtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFByZWNpc2lvblNhZmUodmFsKSB7XG4gIHZhciBzdHIgPSB2YWwudG9TdHJpbmcoKTsgLy8gQ29uc2lkZXIgc2NpZW50aWZpYyBub3RhdGlvbjogJzMuNGUtMTInICczLjRlKzEyJ1xuXG4gIHZhciBlSW5kZXggPSBzdHIuaW5kZXhPZignZScpO1xuXG4gIGlmIChlSW5kZXggPiAwKSB7XG4gICAgdmFyIHByZWNpc2lvbiA9ICtzdHIuc2xpY2UoZUluZGV4ICsgMSk7XG4gICAgcmV0dXJuIHByZWNpc2lvbiA8IDAgPyAtcHJlY2lzaW9uIDogMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZG90SW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuICAgIHJldHVybiBkb3RJbmRleCA8IDAgPyAwIDogc3RyLmxlbmd0aCAtIDEgLSBkb3RJbmRleDtcbiAgfVxufVxuLyoqXG4gKiBNaW5pbWFsIGRpY2VybmlibGUgZGF0YSBwcmVjaXNpb2luIGFjY29yZGluZyB0byBhIHNpbmdsZSBwaXhlbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhRXh0ZW50XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwaXhlbEV4dGVudFxuICogQHJldHVybiB7bnVtYmVyfSBwcmVjaXNpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFBpeGVsUHJlY2lzaW9uKGRhdGFFeHRlbnQsIHBpeGVsRXh0ZW50KSB7XG4gIHZhciBsb2cgPSBNYXRoLmxvZztcbiAgdmFyIExOMTAgPSBNYXRoLkxOMTA7XG4gIHZhciBkYXRhUXVhbnRpdHkgPSBNYXRoLmZsb29yKGxvZyhkYXRhRXh0ZW50WzFdIC0gZGF0YUV4dGVudFswXSkgLyBMTjEwKTtcbiAgdmFyIHNpemVRdWFudGl0eSA9IE1hdGgucm91bmQobG9nKE1hdGguYWJzKHBpeGVsRXh0ZW50WzFdIC0gcGl4ZWxFeHRlbnRbMF0pKSAvIExOMTApOyAvLyB0b0ZpeGVkKCkgZGlnaXRzIGFyZ3VtZW50IG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyMC5cblxuICB2YXIgcHJlY2lzaW9uID0gTWF0aC5taW4oTWF0aC5tYXgoLWRhdGFRdWFudGl0eSArIHNpemVRdWFudGl0eSwgMCksIDIwKTtcbiAgcmV0dXJuICFpc0Zpbml0ZShwcmVjaXNpb24pID8gMjAgOiBwcmVjaXNpb247XG59XG4vKipcbiAqIEdldCBhIGRhdGEgb2YgZ2l2ZW4gcHJlY2lzaW9uLCBhc3N1cmluZyB0aGUgc3VtIG9mIHBlcmNlbnRhZ2VzXG4gKiBpbiB2YWx1ZUxpc3QgaXMgMS5cbiAqIFRoZSBsYXJnZXN0IHJlbWFpbmVyIG1ldGhvZCBpcyB1c2VkLlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFyZ2VzdF9yZW1haW5kZXJfbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVMaXN0IGEgbGlzdCBvZiBhbGwgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeCBpbmRleCBvZiB0aGUgZGF0YSB0byBiZSBwcm9jZXNzZWQgaW4gdmFsdWVMaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gcHJlY2lzaW9uIGludGVnZXIgbnVtYmVyIHNob3dpbmcgZGlnaXRzIG9mIHByZWNpc2lvblxuICogQHJldHVybiB7bnVtYmVyfSBwZXJjZW50IHJhbmdpbmcgZnJvbSAwIHRvIDEwMFxuICovXG5cblxuZnVuY3Rpb24gZ2V0UGVyY2VudFdpdGhQcmVjaXNpb24odmFsdWVMaXN0LCBpZHgsIHByZWNpc2lvbikge1xuICBpZiAoIXZhbHVlTGlzdFtpZHhdKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgc3VtID0genJVdGlsLnJlZHVjZSh2YWx1ZUxpc3QsIGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgIHJldHVybiBhY2MgKyAoaXNOYU4odmFsKSA/IDAgOiB2YWwpO1xuICB9LCAwKTtcblxuICBpZiAoc3VtID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgZGlnaXRzID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gIHZhciB2b3Rlc1BlclF1b3RhID0genJVdGlsLm1hcCh2YWx1ZUxpc3QsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gKGlzTmFOKHZhbCkgPyAwIDogdmFsKSAvIHN1bSAqIGRpZ2l0cyAqIDEwMDtcbiAgfSk7XG4gIHZhciB0YXJnZXRTZWF0cyA9IGRpZ2l0cyAqIDEwMDtcbiAgdmFyIHNlYXRzID0genJVdGlsLm1hcCh2b3Rlc1BlclF1b3RhLCBmdW5jdGlvbiAodm90ZXMpIHtcbiAgICAvLyBBc3NpZ24gYXV0b21hdGljIHNlYXRzLlxuICAgIHJldHVybiBNYXRoLmZsb29yKHZvdGVzKTtcbiAgfSk7XG4gIHZhciBjdXJyZW50U3VtID0genJVdGlsLnJlZHVjZShzZWF0cywgZnVuY3Rpb24gKGFjYywgdmFsKSB7XG4gICAgcmV0dXJuIGFjYyArIHZhbDtcbiAgfSwgMCk7XG4gIHZhciByZW1haW5kZXIgPSB6clV0aWwubWFwKHZvdGVzUGVyUXVvdGEsIGZ1bmN0aW9uICh2b3RlcywgaWR4KSB7XG4gICAgcmV0dXJuIHZvdGVzIC0gc2VhdHNbaWR4XTtcbiAgfSk7IC8vIEhhcyByZW1haW5kaW5nIHZvdGVzLlxuXG4gIHdoaWxlIChjdXJyZW50U3VtIDwgdGFyZ2V0U2VhdHMpIHtcbiAgICAvLyBGaW5kIG5leHQgbGFyZ2VzdCByZW1haW5kZXIuXG4gICAgdmFyIG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWF4SWQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlbWFpbmRlci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKHJlbWFpbmRlcltpXSA+IG1heCkge1xuICAgICAgICBtYXggPSByZW1haW5kZXJbaV07XG4gICAgICAgIG1heElkID0gaTtcbiAgICAgIH1cbiAgICB9IC8vIEFkZCBhIHZvdGUgdG8gbWF4IHJlbWFpbmRlci5cblxuXG4gICAgKytzZWF0c1ttYXhJZF07XG4gICAgcmVtYWluZGVyW21heElkXSA9IDA7XG4gICAgKytjdXJyZW50U3VtO1xuICB9XG5cbiAgcmV0dXJuIHNlYXRzW2lkeF0gLyBkaWdpdHM7XG59IC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBpZSBkbyBub3Qgc3VwcG9ydC5cblxuXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG4vKipcbiAqIFRvIDAgLSAyICogUEksIGNvbnNpZGVyaW5nIG5lZ2F0aXZlIHJhZGlhbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiByZW1SYWRpYW4ocmFkaWFuKSB7XG4gIHZhciBwaTIgPSBNYXRoLlBJICogMjtcbiAgcmV0dXJuIChyYWRpYW4gJSBwaTIgKyBwaTIpICUgcGkyO1xufVxuLyoqXG4gKiBAcGFyYW0ge3R5cGV9IHJhZGlhblxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzUmFkaWFuQXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IC1SQURJQU5fRVBTSUxPTiAmJiB2YWwgPCBSQURJQU5fRVBTSUxPTjtcbn1cblxudmFyIFRJTUVfUkVHID0gL14oPzooXFxkezR9KSg/OlstXFwvXShcXGR7MSwyfSkoPzpbLVxcL10oXFxkezEsMn0pKD86W1QgXShcXGR7MSwyfSkoPzo6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpbLixdKFxcZCspKT8pPyk/KFp8W1xcK1xcLV1cXGRcXGQ6P1xcZFxcZCk/KT8pPyk/KT8kLzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZXxudW1iZXJ9IHZhbHVlIFRoZXNlIHZhbHVlcyBjYW4gYmUgYWNjZXB0ZWQ6XG4gKiAgICsgQW4gaW5zdGFuY2Ugb2YgRGF0ZSwgcmVwcmVzZW50IGEgdGltZSBpbiBpdHMgb3duIHRpbWUgem9uZS5cbiAqICAgKyBPciBzdHJpbmcgaW4gYSBzdWJzZXQgb2YgSVNPIDg2MDEsIG9ubHkgaW5jbHVkaW5nOlxuICogICAgICsgb25seSB5ZWFyLCBtb250aCwgZGF0ZTogJzIwMTItMDMnLCAnMjAxMi0wMy0wMScsICcyMDEyLTAzLTAxIDA1JywgJzIwMTItMDMtMDEgMDU6MDYnLFxuICogICAgICsgc2VwYXJhdGVkIHdpdGggVCBvciBzcGFjZTogJzIwMTItMDMtMDFUMTI6MjI6MzMuMTIzJywgJzIwMTItMDMtMDEgMTI6MjI6MzMuMTIzJyxcbiAqICAgICArIHRpbWUgem9uZTogJzIwMTItMDMtMDFUMTI6MjI6MzNaJywgJzIwMTItMDMtMDFUMTI6MjI6MzMrODAwMCcsICcyMDEyLTAzLTAxVDEyOjIyOjMzLTA1OjAwJyxcbiAqICAgICBhbGwgb2Ygd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGxvY2FsIHRpbWUgaWYgdGltZSB6b25lIGlzIG5vdCBzcGVjaWZpZWRcbiAqICAgICAoc2VlIDxodHRwczovL21vbWVudGpzLmNvbS8+KS5cbiAqICAgKyBPciBvdGhlciBzdHJpbmcgZm9ybWF0LCBpbmNsdWRpbmcgKGFsbCBvZiB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgbG9hY2FsIHRpbWUpOlxuICogICAgICcyMDEyJywgJzIwMTItMy0xJywgJzIwMTIvMy8xJywgJzIwMTIvMDMvMDEnLFxuICogICAgICcyMDA5LzYvMTIgMjowMCcsICcyMDA5LzYvMTIgMjowNTowOCcsICcyMDA5LzYvMTIgMjowNTowOC4xMjMnXG4gKiAgICsgYSB0aW1lc3RhbXAsIHdoaWNoIHJlcHJlc2VudCBhIHRpbWUgaW4gVVRDLlxuICogQHJldHVybiB7RGF0ZX0gZGF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBEaWZmZXJlbnQgYnJvd3NlcnMgcGFyc2UgZGF0ZSBpbiBkaWZmZXJlbnQgd2F5LCBzbyB3ZSBwYXJzZSBpdCBtYW51YWxseS5cbiAgICAvLyBTb21lIG90aGVyIGlzc3VlczpcbiAgICAvLyBuZXcgRGF0ZSgnMTk3MC0wMS0wMScpIGlzIFVUQyxcbiAgICAvLyBuZXcgRGF0ZSgnMTk3MC8wMS8wMScpIGFuZCBuZXcgRGF0ZSgnMTk3MC0xLTAxJykgaXMgbG9jYWwuXG4gICAgLy8gU2VlIGlzc3VlICMzNjIzXG4gICAgdmFyIG1hdGNoID0gVElNRV9SRUcuZXhlYyh2YWx1ZSk7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAvLyByZXR1cm4gSW52YWxpZCBEYXRlLlxuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfSAvLyBVc2UgbG9jYWwgdGltZSB3aGVuIG5vIHRpbWV6b25lIG9mZnNldCBzcGVjaWZlZC5cblxuXG4gICAgaWYgKCFtYXRjaFs4XSkge1xuICAgICAgLy8gbWF0Y2hbbl0gY2FuIG9ubHkgYmUgc3RyaW5nIG9yIHVuZGVmaW5lZC5cbiAgICAgIC8vIEJ1dCB0YWtlIGNhcmUgb2YgJzEyJyArIDEgPT4gJzEyMScuXG4gICAgICByZXR1cm4gbmV3IERhdGUoK21hdGNoWzFdLCArKG1hdGNoWzJdIHx8IDEpIC0gMSwgK21hdGNoWzNdIHx8IDEsICttYXRjaFs0XSB8fCAwLCArKG1hdGNoWzVdIHx8IDApLCArbWF0Y2hbNl0gfHwgMCwgK21hdGNoWzddIHx8IDApO1xuICAgIH0gLy8gVGltZXpvbmVvZmZzZXQgb2YgSmF2YXNjcmlwdCBEYXRlIGhhcyBjb25zaWRlcmVkIERTVCAoRGF5bGlnaHQgU2F2aW5nIFRpbWUsXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF5bGlnaHQtc2F2aW5nLXRpbWUtYWRqdXN0bWVudCkuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHN5c3RlbSB0aW1lem9uZSBpcyBzZXQgYXMgXCJUaW1lIFpvbmU6IEFtZXJpY2EvVG9yb250b1wiLFxuICAgIC8vIHRoZW4gdGhlc2UgY29kZSB3aWxsIGdldCBkaWZmZXJlbnQgcmVzdWx0OlxuICAgIC8vIGBuZXcgRGF0ZSgxNDc4NDExOTk5OTk5KS5nZXRUaW1lem9uZU9mZnNldCgpOyAgLy8gZ2V0IDI0MGBcbiAgICAvLyBgbmV3IERhdGUoMTQ3ODQxMjAwMDAwMCkuZ2V0VGltZXpvbmVPZmZzZXQoKTsgIC8vIGdldCAzMDBgXG4gICAgLy8gU28gd2Ugc2hvdWxkIG5vdCB1c2UgYG5ldyBEYXRlYCwgYnV0IHVzZSBgRGF0ZS5VVENgLlxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgaG91ciA9ICttYXRjaFs0XSB8fCAwO1xuXG4gICAgICAgIGlmIChtYXRjaFs4XS50b1VwcGVyQ2FzZSgpICE9PSAnWicpIHtcbiAgICAgICAgICBob3VyIC09IG1hdGNoWzhdLnNsaWNlKDAsIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKCttYXRjaFsxXSwgKyhtYXRjaFsyXSB8fCAxKSAtIDEsICttYXRjaFszXSB8fCAxLCBob3VyLCArKG1hdGNoWzVdIHx8IDApLCArbWF0Y2hbNl0gfHwgMCwgK21hdGNoWzddIHx8IDApKTtcbiAgICAgIH1cbiAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoTWF0aC5yb3VuZCh2YWx1ZSkpO1xufVxuLyoqXG4gKiBRdWFudGl0eSBvZiBhIG51bWJlci4gZS5nLiAwLjEsIDEsIDEwLCAxMDBcbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhbnRpdHkodmFsKSB7XG4gIHJldHVybiBNYXRoLnBvdygxMCwgcXVhbnRpdHlFeHBvbmVudCh2YWwpKTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpdHlFeHBvbmVudCh2YWwpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4xMCk7XG59XG4vKipcbiAqIGZpbmQgYSDigJxuaWNl4oCdIG51bWJlciBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIHguIFJvdW5kIHRoZSBudW1iZXIgaWYgcm91bmQgPSB0cnVlLFxuICogdGFrZSBjZWlsaW5nIGlmIHJvdW5kID0gZmFsc2UuIFRoZSBwcmltYXJ5IG9ic2VydmF0aW9uIGlzIHRoYXQgdGhlIOKAnG5pY2VzdOKAnVxuICogbnVtYmVycyBpbiBkZWNpbWFsIGFyZSAxLCAyLCBhbmQgNSwgYW5kIGFsbCBwb3dlci1vZi10ZW4gbXVsdGlwbGVzIG9mIHRoZXNlIG51bWJlcnMuXG4gKlxuICogU2VlIFwiTmljZSBOdW1iZXJzIGZvciBHcmFwaCBMYWJlbHNcIiBvZiBHcmFwaGljIEdlbXMuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSB2YWwgTm9uLW5lZ2F0aXZlIHZhbHVlLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gcm91bmRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIG5pY2UodmFsLCByb3VuZCkge1xuICB2YXIgZXhwb25lbnQgPSBxdWFudGl0eUV4cG9uZW50KHZhbCk7XG4gIHZhciBleHAxMCA9IE1hdGgucG93KDEwLCBleHBvbmVudCk7XG4gIHZhciBmID0gdmFsIC8gZXhwMTA7IC8vIDEgPD0gZiA8IDEwXG5cbiAgdmFyIG5mO1xuXG4gIGlmIChyb3VuZCkge1xuICAgIGlmIChmIDwgMS41KSB7XG4gICAgICBuZiA9IDE7XG4gICAgfSBlbHNlIGlmIChmIDwgMi41KSB7XG4gICAgICBuZiA9IDI7XG4gICAgfSBlbHNlIGlmIChmIDwgNCkge1xuICAgICAgbmYgPSAzO1xuICAgIH0gZWxzZSBpZiAoZiA8IDcpIHtcbiAgICAgIG5mID0gNTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmYgPSAxMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGYgPCAxKSB7XG4gICAgICBuZiA9IDE7XG4gICAgfSBlbHNlIGlmIChmIDwgMikge1xuICAgICAgbmYgPSAyO1xuICAgIH0gZWxzZSBpZiAoZiA8IDMpIHtcbiAgICAgIG5mID0gMztcbiAgICB9IGVsc2UgaWYgKGYgPCA1KSB7XG4gICAgICBuZiA9IDU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5mID0gMTA7XG4gICAgfVxuICB9XG5cbiAgdmFsID0gbmYgKiBleHAxMDsgLy8gRml4IDMgKiAwLjEgPT09IDAuMzAwMDAwMDAwMDAwMDAwMDQgaXNzdWUgKHNlZSBJRUVFIDc1NCkuXG4gIC8vIDIwIGlzIHRoZSB1cHBwZXIgYm91bmQgb2YgdG9GaXhlZC5cblxuICByZXR1cm4gZXhwb25lbnQgPj0gLTIwID8gK3ZhbC50b0ZpeGVkKGV4cG9uZW50IDwgMCA/IC1leHBvbmVudCA6IDApIDogdmFsO1xufVxuLyoqXG4gKiBPcmRlciBpbnRlcnZhbHMgYXNjLCBhbmQgc3BsaXQgdGhlbSB3aGVuIG92ZXJsYXAuXG4gKiBleHBlY3QobnVtYmVyVXRpbC5yZWZvcm1JbnRlcnZhbHMoW1xuICogICAgIHtpbnRlcnZhbDogWzE4LCA2Ml0sIGNsb3NlOiBbMSwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWy1JbmZpbml0eSwgLTcwXSwgY2xvc2U6IFswLCAwXX0sXG4gKiAgICAge2ludGVydmFsOiBbLTcwLCAtMjZdLCBjbG9zZTogWzEsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFstMjYsIDE4XSwgY2xvc2U6IFsxLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbNjIsIDE1MF0sIGNsb3NlOiBbMSwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWzEwNiwgMTUwXSwgY2xvc2U6IFsxLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbMTUwLCBJbmZpbml0eV0sIGNsb3NlOiBbMCwgMF19XG4gKiBdKSkudG9FcXVhbChbXG4gKiAgICAge2ludGVydmFsOiBbLUluZmluaXR5LCAtNzBdLCBjbG9zZTogWzAsIDBdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFstNzAsIC0yNl0sIGNsb3NlOiBbMSwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWy0yNiwgMThdLCBjbG9zZTogWzAsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFsxOCwgNjJdLCBjbG9zZTogWzAsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFs2MiwgMTUwXSwgY2xvc2U6IFswLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbMTUwLCBJbmZpbml0eV0sIGNsb3NlOiBbMCwgMF19XG4gKiBdKTtcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGxpc3QsIHdoZXJlIGBjbG9zZWAgbWVhbiBvcGVuIG9yIGNsb3NlXG4gKiAgICAgICAgb2YgdGhlIGludGVydmFsLCBhbmQgSW5maW5pdHkgY2FuIGJlIHVzZWQuXG4gKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gVGhlIG9yaWdpbiBsaXN0LCB3aGljaCBoYXMgYmVlbiByZWZvcm1lZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZm9ybUludGVydmFscyhsaXN0KSB7XG4gIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBsaXR0bGVUaGFuKGEsIGIsIDApID8gLTEgOiAxO1xuICB9KTtcbiAgdmFyIGN1cnIgPSAtSW5maW5pdHk7XG4gIHZhciBjdXJyQ2xvc2UgPSAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7KSB7XG4gICAgdmFyIGludGVydmFsID0gbGlzdFtpXS5pbnRlcnZhbDtcbiAgICB2YXIgY2xvc2UgPSBsaXN0W2ldLmNsb3NlO1xuXG4gICAgZm9yICh2YXIgbGcgPSAwOyBsZyA8IDI7IGxnKyspIHtcbiAgICAgIGlmIChpbnRlcnZhbFtsZ10gPD0gY3Vycikge1xuICAgICAgICBpbnRlcnZhbFtsZ10gPSBjdXJyO1xuICAgICAgICBjbG9zZVtsZ10gPSAhbGcgPyAxIC0gY3VyckNsb3NlIDogMTtcbiAgICAgIH1cblxuICAgICAgY3VyciA9IGludGVydmFsW2xnXTtcbiAgICAgIGN1cnJDbG9zZSA9IGNsb3NlW2xnXTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJ2YWxbMF0gPT09IGludGVydmFsWzFdICYmIGNsb3NlWzBdICogY2xvc2VbMV0gIT09IDEpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG5cbiAgZnVuY3Rpb24gbGl0dGxlVGhhbihhLCBiLCBsZykge1xuICAgIHJldHVybiBhLmludGVydmFsW2xnXSA8IGIuaW50ZXJ2YWxbbGddIHx8IGEuaW50ZXJ2YWxbbGddID09PSBiLmludGVydmFsW2xnXSAmJiAoYS5jbG9zZVtsZ10gLSBiLmNsb3NlW2xnXSA9PT0gKCFsZyA/IDEgOiAtMSkgfHwgIWxnICYmIGxpdHRsZVRoYW4oYSwgYiwgMSkpO1xuICB9XG59XG4vKipcbiAqIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcbiAqIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcbiAqIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuICpcbiAqIEBwYXJhbSB7Kn0gdlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzTnVtZXJpYyh2KSB7XG4gIHJldHVybiB2IC0gcGFyc2VGbG9hdCh2KSA+PSAwO1xufVxuXG5leHBvcnRzLmxpbmVhck1hcCA9IGxpbmVhck1hcDtcbmV4cG9ydHMucGFyc2VQZXJjZW50ID0gcGFyc2VQZXJjZW50O1xuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5hc2MgPSBhc2M7XG5leHBvcnRzLmdldFByZWNpc2lvbiA9IGdldFByZWNpc2lvbjtcbmV4cG9ydHMuZ2V0UHJlY2lzaW9uU2FmZSA9IGdldFByZWNpc2lvblNhZmU7XG5leHBvcnRzLmdldFBpeGVsUHJlY2lzaW9uID0gZ2V0UGl4ZWxQcmVjaXNpb247XG5leHBvcnRzLmdldFBlcmNlbnRXaXRoUHJlY2lzaW9uID0gZ2V0UGVyY2VudFdpdGhQcmVjaXNpb247XG5leHBvcnRzLk1BWF9TQUZFX0lOVEVHRVIgPSBNQVhfU0FGRV9JTlRFR0VSO1xuZXhwb3J0cy5yZW1SYWRpYW4gPSByZW1SYWRpYW47XG5leHBvcnRzLmlzUmFkaWFuQXJvdW5kWmVybyA9IGlzUmFkaWFuQXJvdW5kWmVybztcbmV4cG9ydHMucGFyc2VEYXRlID0gcGFyc2VEYXRlO1xuZXhwb3J0cy5xdWFudGl0eSA9IHF1YW50aXR5O1xuZXhwb3J0cy5uaWNlID0gbmljZTtcbmV4cG9ydHMucmVmb3JtSW50ZXJ2YWxzID0gcmVmb3JtSW50ZXJ2YWxzO1xuZXhwb3J0cy5pc051bWVyaWMgPSBpc051bWVyaWM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9udW1iZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbnVtYmVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4vZ3JhcGhpY1wiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gU3ltYm9sIGZhY3RvcnlcblxuLyoqXG4gKiBUcmlhbmdsZSBzaGFwZVxuICogQGlubmVyXG4gKi9cbnZhciBUcmlhbmdsZSA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuICB0eXBlOiAndHJpYW5nbGUnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xuICAgIHZhciBjeCA9IHNoYXBlLmN4O1xuICAgIHZhciBjeSA9IHNoYXBlLmN5O1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcbiAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcbiAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xuICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5ICsgaGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSArIGhlaWdodCk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG4vKipcbiAqIERpYW1vbmQgc2hhcGVcbiAqIEBpbm5lclxuICovXG5cbnZhciBEaWFtb25kID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gIHR5cGU6ICdkaWFtb25kJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICB2YXIgY3ggPSBzaGFwZS5jeDtcbiAgICB2YXIgY3kgPSBzaGFwZS5jeTtcbiAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCAvIDI7XG4gICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XG4gICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjeCArIHdpZHRoLCBjeSk7XG4gICAgcGF0aC5saW5lVG8oY3gsIGN5ICsgaGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG4vKipcbiAqIFBpbiBzaGFwZVxuICogQGlubmVyXG4gKi9cblxudmFyIFBpbiA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuICB0eXBlOiAncGluJyxcbiAgc2hhcGU6IHtcbiAgICAvLyB4LCB5IG9uIHRoZSBjdXNwXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgdmFyIHcgPSBzaGFwZS53aWR0aCAvIDUgKiAzOyAvLyBIZWlnaHQgbXVzdCBiZSBsYXJnZXIgdGhhbiB3aWR0aFxuXG4gICAgdmFyIGggPSBNYXRoLm1heCh3LCBzaGFwZS5oZWlnaHQpO1xuICAgIHZhciByID0gdyAvIDI7IC8vIERpc3Qgb24geSB3aXRoIHRhbmdlbnQgcG9pbnQgYW5kIGNpcmNsZSBjZW50ZXJcblxuICAgIHZhciBkeSA9IHIgKiByIC8gKGggLSByKTtcbiAgICB2YXIgY3kgPSB5IC0gaCArIHIgKyBkeTtcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZHkgLyByKTsgLy8gRGlzdCBvbiB4IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxuXG4gICAgdmFyIGR4ID0gTWF0aC5jb3MoYW5nbGUpICogcjtcbiAgICB2YXIgdGFuWCA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgdGFuWSA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB2YXIgY3BMZW4gPSByICogMC42O1xuICAgIHZhciBjcExlbjIgPSByICogMC43O1xuICAgIHBhdGgubW92ZVRvKHggLSBkeCwgY3kgKyBkeSk7XG4gICAgcGF0aC5hcmMoeCwgY3ksIHIsIE1hdGguUEkgLSBhbmdsZSwgTWF0aC5QSSAqIDIgKyBhbmdsZSk7XG4gICAgcGF0aC5iZXppZXJDdXJ2ZVRvKHggKyBkeCAtIHRhblggKiBjcExlbiwgY3kgKyBkeSArIHRhblkgKiBjcExlbiwgeCwgeSAtIGNwTGVuMiwgeCwgeSk7XG4gICAgcGF0aC5iZXppZXJDdXJ2ZVRvKHgsIHkgLSBjcExlbjIsIHggLSBkeCArIHRhblggKiBjcExlbiwgY3kgKyBkeSArIHRhblkgKiBjcExlbiwgeCAtIGR4LCBjeSArIGR5KTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59KTtcbi8qKlxuICogQXJyb3cgc2hhcGVcbiAqIEBpbm5lclxuICovXG5cbnZhciBBcnJvdyA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuICB0eXBlOiAnYXJyb3cnLFxuICBzaGFwZToge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgdmFyIHggPSBzaGFwZS54O1xuICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICB2YXIgZHggPSB3aWR0aCAvIDMgKiAyO1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgY3R4LmxpbmVUbyh4ICsgZHgsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8oeCwgeSArIGhlaWdodCAvIDQgKiAzKTtcbiAgICBjdHgubGluZVRvKHggLSBkeCwgeSArIGhlaWdodCk7XG4gICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuLyoqXG4gKiBNYXAgb2YgcGF0aCBjb250cnVjdG9yc1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGg+fVxuICovXG5cbnZhciBzeW1ib2xDdG9ycyA9IHtcbiAgbGluZTogZ3JhcGhpYy5MaW5lLFxuICByZWN0OiBncmFwaGljLlJlY3QsXG4gIHJvdW5kUmVjdDogZ3JhcGhpYy5SZWN0LFxuICBzcXVhcmU6IGdyYXBoaWMuUmVjdCxcbiAgY2lyY2xlOiBncmFwaGljLkNpcmNsZSxcbiAgZGlhbW9uZDogRGlhbW9uZCxcbiAgcGluOiBQaW4sXG4gIGFycm93OiBBcnJvdyxcbiAgdHJpYW5nbGU6IFRyaWFuZ2xlXG59O1xudmFyIHN5bWJvbFNoYXBlTWFrZXJzID0ge1xuICBsaW5lOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAvLyBGSVhNRVxuICAgIHNoYXBlLngxID0geDtcbiAgICBzaGFwZS55MSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS54MiA9IHggKyB3O1xuICAgIHNoYXBlLnkyID0geSArIGggLyAyO1xuICB9LFxuICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS54ID0geDtcbiAgICBzaGFwZS55ID0geTtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgfSxcbiAgcm91bmRSZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS54ID0geDtcbiAgICBzaGFwZS55ID0geTtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyA0O1xuICB9LFxuICBzcXVhcmU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHZhciBzaXplID0gTWF0aC5taW4odywgaCk7XG4gICAgc2hhcGUueCA9IHg7XG4gICAgc2hhcGUueSA9IHk7XG4gICAgc2hhcGUud2lkdGggPSBzaXplO1xuICAgIHNoYXBlLmhlaWdodCA9IHNpemU7XG4gIH0sXG4gIGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgLy8gUHV0IGNpcmNsZSBpbiB0aGUgY2VudGVyIG9mIHNxdWFyZVxuICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xuICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDI7XG4gIH0sXG4gIGRpYW1vbmQ6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xuICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgIHNoYXBlLndpZHRoID0gdztcbiAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICB9LFxuICBwaW46IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XG4gICAgc2hhcGUueSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgfSxcbiAgYXJyb3c6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XG4gICAgc2hhcGUueSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgfSxcbiAgdHJpYW5nbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xuICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgIHNoYXBlLndpZHRoID0gdztcbiAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICB9XG59O1xudmFyIHN5bWJvbEJ1aWxkUHJveGllcyA9IHt9O1xuenJVdGlsLmVhY2goc3ltYm9sQ3RvcnMsIGZ1bmN0aW9uIChDdG9yLCBuYW1lKSB7XG4gIHN5bWJvbEJ1aWxkUHJveGllc1tuYW1lXSA9IG5ldyBDdG9yKCk7XG59KTtcbnZhciBTeW1ib2xDbHogPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHNoYXBlOiB7XG4gICAgc3ltYm9sVHlwZTogJycsXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTsgLy8gRklYTUVcblxuICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlID09PSAncGluJyAmJiBzdHlsZS50ZXh0UG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XG4gICAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBbJzUwJScsICc0MCUnXTtcbiAgICAgIHN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICB9XG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGluQnVuZGxlKSB7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSBzaGFwZS5zeW1ib2xUeXBlO1xuICAgIHZhciBwcm94eVN5bWJvbCA9IHN5bWJvbEJ1aWxkUHJveGllc1tzeW1ib2xUeXBlXTtcblxuICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgIGlmICghcHJveHlTeW1ib2wpIHtcbiAgICAgICAgLy8gRGVmYXVsdCByZWN0XG4gICAgICAgIHN5bWJvbFR5cGUgPSAncmVjdCc7XG4gICAgICAgIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xuICAgICAgfVxuXG4gICAgICBzeW1ib2xTaGFwZU1ha2Vyc1tzeW1ib2xUeXBlXShzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0LCBwcm94eVN5bWJvbC5zaGFwZSk7XG4gICAgICBwcm94eVN5bWJvbC5idWlsZFBhdGgoY3R4LCBwcm94eVN5bWJvbC5zaGFwZSwgaW5CdW5kbGUpO1xuICAgIH1cbiAgfVxufSk7IC8vIFByb3ZpZGUgc2V0Q29sb3IgaGVscGVyIG1ldGhvZCB0byBhdm9pZCBkZXRlcm1pbmUgaWYgc2V0IHRoZSBmaWxsIG9yIHN0cm9rZSBvdXRzaWRlXG5cbmZ1bmN0aW9uIHN5bWJvbFBhdGhTZXRDb2xvcihjb2xvciwgaW5uZXJDb2xvcikge1xuICBpZiAodGhpcy50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgdmFyIHN5bWJvbFN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgc3ltYm9sU2hhcGUgPSB0aGlzLnNoYXBlO1xuXG4gICAgaWYgKHN5bWJvbFNoYXBlICYmIHN5bWJvbFNoYXBlLnN5bWJvbFR5cGUgPT09ICdsaW5lJykge1xuICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9faXNFbXB0eUJydXNoKSB7XG4gICAgICBzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcjtcbiAgICAgIHN5bWJvbFN0eWxlLmZpbGwgPSBpbm5lckNvbG9yIHx8ICcjZmZmJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUUg5Yik5pat5Zu+5b2i6buY6K6k5piv5aGr5YWF6L+Y5piv5o+P6L6577yM5L2/55SoIG9ubHlTdHJva2UgP1xuICAgICAgc3ltYm9sU3R5bGUuZmlsbCAmJiAoc3ltYm9sU3R5bGUuZmlsbCA9IGNvbG9yKTtcbiAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSAmJiAoc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3IpO1xuICAgIH1cblxuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIHN5bWJvbCBlbGVtZW50IHdpdGggZ2l2ZW4gc3ltYm9sIGNvbmZpZ3VyYXRpb246IHNoYXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvclxuICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbFR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IHdcbiAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBBc3BlY3Q9ZmFsc2VdIHdoZXRoZXIgdG8ga2VlcCB0aGUgcmF0aW8gb2Ygdy9oLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHBhdGggYW5kIGltYWdlIG9ubHkuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgeCwgeSwgdywgaCwgY29sb3IsIGtlZXBBc3BlY3QpIHtcbiAgLy8gVE9ETyBTdXBwb3J0IGltYWdlIG9iamVjdCwgRHluYW1pY0ltYWdlLlxuICB2YXIgaXNFbXB0eSA9IHN5bWJvbFR5cGUuaW5kZXhPZignZW1wdHknKSA9PT0gMDtcblxuICBpZiAoaXNFbXB0eSkge1xuICAgIHN5bWJvbFR5cGUgPSBzeW1ib2xUeXBlLnN1YnN0cig1LCAxKS50b0xvd2VyQ2FzZSgpICsgc3ltYm9sVHlwZS5zdWJzdHIoNik7XG4gIH1cblxuICB2YXIgc3ltYm9sUGF0aDtcblxuICBpZiAoc3ltYm9sVHlwZS5pbmRleE9mKCdpbWFnZTovLycpID09PSAwKSB7XG4gICAgc3ltYm9sUGF0aCA9IGdyYXBoaWMubWFrZUltYWdlKHN5bWJvbFR5cGUuc2xpY2UoOCksIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgdywgaCksIGtlZXBBc3BlY3QgPyAnY2VudGVyJyA6ICdjb3ZlcicpO1xuICB9IGVsc2UgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZigncGF0aDovLycpID09PSAwKSB7XG4gICAgc3ltYm9sUGF0aCA9IGdyYXBoaWMubWFrZVBhdGgoc3ltYm9sVHlwZS5zbGljZSg3KSwge30sIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgdywgaCksIGtlZXBBc3BlY3QgPyAnY2VudGVyJyA6ICdjb3ZlcicpO1xuICB9IGVsc2Uge1xuICAgIHN5bWJvbFBhdGggPSBuZXcgU3ltYm9sQ2x6KHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHN5bWJvbFR5cGU6IHN5bWJvbFR5cGUsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3LFxuICAgICAgICBoZWlnaHQ6IGhcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN5bWJvbFBhdGguX19pc0VtcHR5QnJ1c2ggPSBpc0VtcHR5O1xuICBzeW1ib2xQYXRoLnNldENvbG9yID0gc3ltYm9sUGF0aFNldENvbG9yO1xuICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcbiAgcmV0dXJuIHN5bWJvbFBhdGg7XG59XG5cbmV4cG9ydHMuY3JlYXRlU3ltYm9sID0gY3JlYXRlU3ltYm9sO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBPUklHSU5fTUVUSE9EID0gJ1xcMF9fdGhyb3R0bGVPcmlnaW5NZXRob2QnO1xudmFyIFJBVEUgPSAnXFwwX190aHJvdHRsZVJhdGUnO1xudmFyIFRIUk9UVExFX1RZUEUgPSAnXFwwX190aHJvdHRsZVR5cGUnO1xuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyhGdW5jdGlvbil9IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdIFVuaXQ6IG1zLlxuICogQHBhcmFtIHtib29sZWFufSBbZGVib3VuY2U9ZmFsc2VdXG4gKiAgICAgICAgdHJ1ZTogSWYgY2FsbCBpbnRlcnZhbCBsZXNzIHRoYW4gYGRlbGF5YCwgb25seSB0aGUgbGFzdCBjYWxsIHdvcmtzLlxuICogICAgICAgIGZhbHNlOiBJZiBjYWxsIGludGVydmFsIGxlc3MgdGhhbiBgZGVsYXksIGNhbGwgd29ya3Mgb24gZml4ZWQgcmF0ZS5cbiAqIEByZXR1cm4geyhGdW5jdGlvbil9IHRocm90dGxlZCBmbi5cbiAqL1xuXG5mdW5jdGlvbiB0aHJvdHRsZShmbiwgZGVsYXksIGRlYm91bmNlKSB7XG4gIHZhciBjdXJyQ2FsbDtcbiAgdmFyIGxhc3RDYWxsID0gMDtcbiAgdmFyIGxhc3RFeGVjID0gMDtcbiAgdmFyIHRpbWVyID0gbnVsbDtcbiAgdmFyIGRpZmY7XG4gIHZhciBzY29wZTtcbiAgdmFyIGFyZ3M7XG4gIHZhciBkZWJvdW5jZU5leHRDYWxsO1xuICBkZWxheSA9IGRlbGF5IHx8IDA7XG5cbiAgZnVuY3Rpb24gZXhlYygpIHtcbiAgICBsYXN0RXhlYyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRpbWVyID0gbnVsbDtcbiAgICBmbi5hcHBseShzY29wZSwgYXJncyB8fCBbXSk7XG4gIH1cblxuICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgY3VyckNhbGwgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBzY29wZSA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgdGhpc0RlbGF5ID0gZGVib3VuY2VOZXh0Q2FsbCB8fCBkZWxheTtcbiAgICB2YXIgdGhpc0RlYm91bmNlID0gZGVib3VuY2VOZXh0Q2FsbCB8fCBkZWJvdW5jZTtcbiAgICBkZWJvdW5jZU5leHRDYWxsID0gbnVsbDtcbiAgICBkaWZmID0gY3VyckNhbGwgLSAodGhpc0RlYm91bmNlID8gbGFzdENhbGwgOiBsYXN0RXhlYykgLSB0aGlzRGVsYXk7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTsgLy8gSGVyZSB3ZSBzaG91bGQgbWFrZSBzdXJlIHRoYXQ6IHRoZSBgZXhlY2AgU0hPVUxEIE5PVCBiZSBjYWxsZWQgbGF0ZXJcbiAgICAvLyB0aGFuIGEgbmV3IGNhbGwgb2YgYGNiYCwgdGhhdCBpcywgcHJlc2VydmluZyB0aGUgY29tbWFuZCBvcmRlci4gQ29uc2lkZXJcbiAgICAvLyBjYWxjdWxhdGluZyBcInNjYWxlIHJhdGVcIiB3aGVuIHJvYW1pbmcgYXMgYW4gZXhhbXBsZS4gV2hlbiBhIGNhbGwgb2YgYGNiYFxuICAgIC8vIGhhcHBlbnMsIGVpdGhlciB0aGUgYGV4ZWNgIGlzIGNhbGxlZCBkaWVyZWN0bHksIG9yIHRoZSBjYWxsIGlzIGRlbGF5ZWQuXG4gICAgLy8gQnV0IHRoZSBkZWxheWVkIGNhbGwgc2hvdWxkIG5ldmVyIGJlIGxhdGVyIHRoYW4gbmV4dCBjYWxsIG9mIGBjYmAuIFVuZGVyXG4gICAgLy8gdGhpcyBhc3N1cmFuY2UsIHdlIGNhbiBzaW1wbHkgdXBkYXRlIHZpZXcgc3RhdGUgZWFjaCB0aW1lIGBkaXNwYXRjaEFjdGlvbmBcbiAgICAvLyB0cmlnZ2VyZWQgYnkgdXNlciByb2FtaW5nLCBidXQgbm90IG5lZWQgdG8gYWRkIGV4dHJhIGNvZGUgdG8gYXZvaWQgdGhlXG4gICAgLy8gc3RhdGUgYmVpbmcgXCJyb2xsZWQtYmFja1wiLlxuXG4gICAgaWYgKHRoaXNEZWJvdW5jZSkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIHRoaXNEZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaWZmID49IDApIHtcbiAgICAgICAgZXhlYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIC1kaWZmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0Q2FsbCA9IGN1cnJDYWxsO1xuICB9O1xuICAvKipcbiAgICogQ2xlYXIgdGhyb3R0bGUuXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICBjYi5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRW5hYmxlIGRlYm91bmNlIG9uY2UuXG4gICAqL1xuXG5cbiAgY2IuZGVib3VuY2VOZXh0Q2FsbCA9IGZ1bmN0aW9uIChkZWJvdW5jZURlbGF5KSB7XG4gICAgZGVib3VuY2VOZXh0Q2FsbCA9IGRlYm91bmNlRGVsYXk7XG4gIH07XG5cbiAgcmV0dXJuIGNiO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhyb3R0bGUgbWV0aG9kIG9yIHVwZGF0ZSB0aHJvdHRsZSByYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgLi4uXG4gKiAgICAgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUoXG4gKiAgICAgICAgIHRoaXMsXG4gKiAgICAgICAgICdfZGlzcGF0Y2hBY3Rpb24nLFxuICogICAgICAgICB0aGlzLm1vZGVsLmdldCgndGhyb3R0bGUnKSxcbiAqICAgICAgICAgJ2ZpeFJhdGUnXG4gKiAgICAgKTtcbiAqIH07XG4gKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaEFjdGlvbicpO1xuICogfTtcbiAqIENvbXBvbmVudFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaEFjdGlvbicpO1xuICogfTtcbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5BdHRyXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Rocm90dGxlVHlwZT0nZml4UmF0ZSddICdmaXhSYXRlJyBvciAnZGVib3VuY2UnXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUob2JqLCBmbkF0dHIsIHJhdGUsIHRocm90dGxlVHlwZSkge1xuICB2YXIgZm4gPSBvYmpbZm5BdHRyXTtcblxuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9yaWdpbkZuID0gZm5bT1JJR0lOX01FVEhPRF0gfHwgZm47XG4gIHZhciBsYXN0VGhyb3R0bGVUeXBlID0gZm5bVEhST1RUTEVfVFlQRV07XG4gIHZhciBsYXN0UmF0ZSA9IGZuW1JBVEVdO1xuXG4gIGlmIChsYXN0UmF0ZSAhPT0gcmF0ZSB8fCBsYXN0VGhyb3R0bGVUeXBlICE9PSB0aHJvdHRsZVR5cGUpIHtcbiAgICBpZiAocmF0ZSA9PSBudWxsIHx8ICF0aHJvdHRsZVR5cGUpIHtcbiAgICAgIHJldHVybiBvYmpbZm5BdHRyXSA9IG9yaWdpbkZuO1xuICAgIH1cblxuICAgIGZuID0gb2JqW2ZuQXR0cl0gPSB0aHJvdHRsZShvcmlnaW5GbiwgcmF0ZSwgdGhyb3R0bGVUeXBlID09PSAnZGVib3VuY2UnKTtcbiAgICBmbltPUklHSU5fTUVUSE9EXSA9IG9yaWdpbkZuO1xuICAgIGZuW1RIUk9UVExFX1RZUEVdID0gdGhyb3R0bGVUeXBlO1xuICAgIGZuW1JBVEVdID0gcmF0ZTtcbiAgfVxuXG4gIHJldHVybiBmbjtcbn1cbi8qKlxuICogQ2xlYXIgdGhyb3R0bGUuIEV4YW1wbGUgc2VlIHRocm90dGxlLmNyZWF0ZU9yVXBkYXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbkF0dHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsZWFyKG9iaiwgZm5BdHRyKSB7XG4gIHZhciBmbiA9IG9ialtmbkF0dHJdO1xuXG4gIGlmIChmbiAmJiBmbltPUklHSU5fTUVUSE9EXSkge1xuICAgIG9ialtmbkF0dHJdID0gZm5bT1JJR0lOX01FVEhPRF07XG4gIH1cbn1cblxuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xuZXhwb3J0cy5jcmVhdGVPclVwZGF0ZSA9IGNyZWF0ZU9yVXBkYXRlO1xuZXhwb3J0cy5jbGVhciA9IGNsZWFyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvdGhyb3R0bGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvdGhyb3R0bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX3V0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXBcIik7XG5cbnZhciBjb21wb25lbnRVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY29tcG9uZW50XCIpO1xuXG52YXIgY2xhenpVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIF90YXNrID0gcmVxdWlyZShcIi4uL3N0cmVhbS90YXNrXCIpO1xuXG52YXIgY3JlYXRlVGFzayA9IF90YXNrLmNyZWF0ZVRhc2s7XG5cbnZhciBjcmVhdGVSZW5kZXJQbGFubmVyID0gcmVxdWlyZShcIi4uL2NoYXJ0L2hlbHBlci9jcmVhdGVSZW5kZXJQbGFubmVyXCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgaW5uZXIgPSBtb2RlbFV0aWwubWFrZUlubmVyKCk7XG52YXIgcmVuZGVyUGxhbm5lciA9IGNyZWF0ZVJlbmRlclBsYW5uZXIoKTtcblxuZnVuY3Rpb24gQ2hhcnQoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCd2aWV3Q2hhcnQnKTtcbiAgdGhpcy5yZW5kZXJUYXNrID0gY3JlYXRlVGFzayh7XG4gICAgcGxhbjogcmVuZGVyVGFza1BsYW4sXG4gICAgcmVzZXQ6IHJlbmRlclRhc2tSZXNldFxuICB9KTtcbiAgdGhpcy5yZW5kZXJUYXNrLmNvbnRleHQgPSB7XG4gICAgdmlldzogdGhpc1xuICB9O1xufVxuXG5DaGFydC5wcm90b3R5cGUgPSB7XG4gIHR5cGU6ICdjaGFydCcsXG5cbiAgLyoqXG4gICAqIEluaXQgdGhlIGNoYXJ0LlxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHt9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGNoYXJ0LlxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWRcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHt9LFxuXG4gIC8qKlxuICAgKiBIaWdobGlnaHQgc2VyaWVzIG9yIHNwZWNpZmllZCBkYXRhIGl0ZW0uXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgKi9cbiAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRvZ2dsZUhpZ2hsaWdodChzZXJpZXNNb2RlbC5nZXREYXRhKCksIHBheWxvYWQsICdlbXBoYXNpcycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEb3ducGxheSBzZXJpZXMgb3Igc3BlY2lmaWVkIGRhdGEgaXRlbS5cbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAqL1xuICBkb3ducGxheTogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0b2dnbGVIaWdobGlnaHQoc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBwYXlsb2FkLCAnbm9ybWFsJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxmLlxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugc2VsZi5cbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICogUmVuZGVyaW5nIHByZXBhcmF0aW9uIGluIHByb2dyZXNzaXZlIG1vZGUuXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgKi9cbiAgaW5jcmVtZW50YWxQcmVwYXJlUmVuZGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgaW4gcHJvZ3Jlc3NpdmUgbW9kZS5cbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAqL1xuICBpbmNyZW1lbnRhbFJlbmRlcjogbnVsbCxcblxuICAvKipcbiAgICogVXBkYXRlIHRyYW5zZm9ybSBkaXJlY3RseS5cbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEByZXR1cm4ge09iamVjdH0ge3VwZGF0ZTogdHJ1ZX1cbiAgICovXG4gIHVwZGF0ZVRyYW5zZm9ybTogbnVsbFxuICAvKipcbiAgICogVGhlIHZpZXcgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxuICAgKiBAaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICAvLyBjb250YWluUG9pbnQ6IGZ1bmN0aW9uICgpIHt9XG5cbn07XG52YXIgY2hhcnRQcm90byA9IENoYXJ0LnByb3RvdHlwZTtcblxuY2hhcnRQcm90by51cGRhdGVWaWV3ID0gY2hhcnRQcm90by51cGRhdGVMYXlvdXQgPSBjaGFydFByb3RvLnVwZGF0ZVZpc3VhbCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gIHRoaXMucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xufTtcbi8qKlxuICogU2V0IHN0YXRlIG9mIHNpbmdsZSBlbGVtZW50XG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICogQHBhcmFtICB7c3RyaW5nfSBzdGF0ZVxuICovXG5cblxuZnVuY3Rpb24gZWxTZXRTdGF0ZShlbCwgc3RhdGUpIHtcbiAgaWYgKGVsKSB7XG4gICAgZWwudHJpZ2dlcihzdGF0ZSk7XG5cbiAgICBpZiAoZWwudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5jaGlsZENvdW50KCk7IGkrKykge1xuICAgICAgICBlbFNldFN0YXRlKGVsLmNoaWxkQXQoaSksIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RhdGUgJ25vcm1hbCd8J2VtcGhhc2lzJ1xuICovXG5cblxuZnVuY3Rpb24gdG9nZ2xlSGlnaGxpZ2h0KGRhdGEsIHBheWxvYWQsIHN0YXRlKSB7XG4gIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgaWYgKGRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgZWFjaChtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShkYXRhSW5kZXgpLCBmdW5jdGlvbiAoZGF0YUlkeCkge1xuICAgICAgZWxTZXRTdGF0ZShkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUlkeCksIHN0YXRlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWxTZXRTdGF0ZShlbCwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59IC8vIEVuYWJsZSBDaGFydC5leHRlbmQuXG5cblxuY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKENoYXJ0LCBbJ2Rpc3Bvc2UnXSk7IC8vIEFkZCBjYXBhYmlsaXR5IG9mIHJlZ2lzdGVyQ2xhc3MsIGdldENsYXNzLCBoYXNDbGFzcywgcmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyIGFuZCBzbyBvbi5cblxuY2xhenpVdGlsLmVuYWJsZUNsYXNzTWFuYWdlbWVudChDaGFydCwge1xuICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcbn0pO1xuXG5DaGFydC5tYXJrVXBkYXRlTWV0aG9kID0gZnVuY3Rpb24gKHBheWxvYWQsIG1ldGhvZE5hbWUpIHtcbiAgaW5uZXIocGF5bG9hZCkudXBkYXRlTWV0aG9kID0gbWV0aG9kTmFtZTtcbn07XG5cbmZ1bmN0aW9uIHJlbmRlclRhc2tQbGFuKGNvbnRleHQpIHtcbiAgcmV0dXJuIHJlbmRlclBsYW5uZXIoY29udGV4dC5tb2RlbCk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRhc2tSZXNldChjb250ZXh0KSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGNvbnRleHQubW9kZWw7XG4gIHZhciBlY01vZGVsID0gY29udGV4dC5lY01vZGVsO1xuICB2YXIgYXBpID0gY29udGV4dC5hcGk7XG4gIHZhciBwYXlsb2FkID0gY29udGV4dC5wYXlsb2FkOyAvLyA/Pz8hIHJlbW92ZSB1cGRhdGVWaWV3IHVwZGF0ZVZpc3VhbFxuXG4gIHZhciBwcm9ncmVzc2l2ZVJlbmRlciA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dC5wcm9ncmVzc2l2ZVJlbmRlcjtcbiAgdmFyIHZpZXcgPSBjb250ZXh0LnZpZXc7XG4gIHZhciB1cGRhdGVNZXRob2QgPSBwYXlsb2FkICYmIGlubmVyKHBheWxvYWQpLnVwZGF0ZU1ldGhvZDtcbiAgdmFyIG1ldGhvZE5hbWUgPSBwcm9ncmVzc2l2ZVJlbmRlciA/ICdpbmNyZW1lbnRhbFByZXBhcmVSZW5kZXInIDogdXBkYXRlTWV0aG9kICYmIHZpZXdbdXBkYXRlTWV0aG9kXSA/IHVwZGF0ZU1ldGhvZCAvLyBgYXBwZW5kRGF0YWAgaXMgYWxzbyBzdXBwb3J0ZWQgd2hlbiBkYXRhIGFtb3VudFxuICAvLyBpcyBsZXNzIHRoYW4gcHJvZ3Jlc3NpdmUgdGhyZXNob2xkLlxuICA6ICdyZW5kZXInO1xuXG4gIGlmIChtZXRob2ROYW1lICE9PSAncmVuZGVyJykge1xuICAgIHZpZXdbbWV0aG9kTmFtZV0oc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH1cblxuICByZXR1cm4gcHJvZ3Jlc3NNZXRob2RNYXBbbWV0aG9kTmFtZV07XG59XG5cbnZhciBwcm9ncmVzc01ldGhvZE1hcCA9IHtcbiAgaW5jcmVtZW50YWxQcmVwYXJlUmVuZGVyOiB7XG4gICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIChwYXJhbXMsIGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQudmlldy5pbmNyZW1lbnRhbFJlbmRlcihwYXJhbXMsIGNvbnRleHQubW9kZWwsIGNvbnRleHQuZWNNb2RlbCwgY29udGV4dC5hcGksIGNvbnRleHQucGF5bG9hZCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IHtcbiAgICAvLyBQdXQgdmlldy5yZW5kZXIgaW4gYHByb2dyZXNzYCB0byBzdXBwb3J0IGFwcGVuZERhdGEuIEJ1dCBpbiB0aGlzIGNhc2VcbiAgICAvLyB2aWV3LnJlbmRlciBzaG91bGQgbm90IGJlIGNhbGxlZCBpbiByZXNldCwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FsbGVkXG4gICAgLy8gdHdpc2UuIFVzZSBgZm9yY2VGaXJzdFByb2dyZXNzYCB0byBtYWtlIHN1cmUgdGhhdCB2aWV3LnJlbmRlciBpcyBjYWxsZWRcbiAgICAvLyBpbiBhbnkgY2FzZXMuXG4gICAgZm9yY2VGaXJzdFByb2dyZXNzOiB0cnVlLFxuICAgIHByb2dyZXNzOiBmdW5jdGlvbiAocGFyYW1zLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LnZpZXcucmVuZGVyKGNvbnRleHQubW9kZWwsIGNvbnRleHQuZWNNb2RlbCwgY29udGV4dC5hcGksIGNvbnRleHQucGF5bG9hZCk7XG4gICAgfVxuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQ2hhcnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ZpZXcvQ2hhcnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ZpZXcvQ2hhcnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgR3JvdXAgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwXCIpO1xuXG52YXIgY29tcG9uZW50VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbXBvbmVudFwiKTtcblxudmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2NsYXp6XCIpO1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKCk7XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgndmlld0NvbXBvbmVudCcpO1xufTtcblxuQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IENvbXBvbmVudCxcbiAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge30sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHt9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxufTtcbnZhciBjb21wb25lbnRQcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbmNvbXBvbmVudFByb3RvLnVwZGF0ZVZpZXcgPSBjb21wb25lbnRQcm90by51cGRhdGVMYXlvdXQgPSBjb21wb25lbnRQcm90by51cGRhdGVWaXN1YWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkgey8vIERvIG5vdGhpbmc7XG59OyAvLyBFbmFibGUgQ29tcG9uZW50LmV4dGVuZC5cblxuXG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoQ29tcG9uZW50KTsgLy8gRW5hYmxlIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuXG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KENvbXBvbmVudCwge1xuICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcbn0pO1xudmFyIF9kZWZhdWx0ID0gQ29tcG9uZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aWV3L0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlldy9Db21wb25lbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vbGFuZ1wiKTtcblxudmFyIF9kYXRhUHJvdmlkZXIgPSByZXF1aXJlKFwiLi4vZGF0YS9oZWxwZXIvZGF0YVByb3ZpZGVyXCIpO1xuXG52YXIgcmV0cmlldmVSYXdWYWx1ZSA9IF9kYXRhUHJvdmlkZXIucmV0cmlldmVSYXdWYWx1ZTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuZnVuY3Rpb24gX2RlZmF1bHQoZG9tLCBlY01vZGVsKSB7XG4gIHZhciBhcmlhTW9kZWwgPSBlY01vZGVsLmdldE1vZGVsKCdhcmlhJyk7XG5cbiAgaWYgKCFhcmlhTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoYXJpYU1vZGVsLmdldCgnZGVzY3JpcHRpb24nKSkge1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBhcmlhTW9kZWwuZ2V0KCdkZXNjcmlwdGlvbicpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VyaWVzQ250ID0gMDtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaWR4KSB7XG4gICAgKytzZXJpZXNDbnQ7XG4gIH0sIHRoaXMpO1xuICB2YXIgbWF4RGF0YUNudCA9IGFyaWFNb2RlbC5nZXQoJ2RhdGEubWF4Q291bnQnKSB8fCAxMDtcbiAgdmFyIG1heFNlcmllc0NudCA9IGFyaWFNb2RlbC5nZXQoJ3Nlcmllcy5tYXhDb3VudCcpIHx8IDEwO1xuICB2YXIgZGlzcGxheVNlcmllc0NudCA9IE1hdGgubWluKHNlcmllc0NudCwgbWF4U2VyaWVzQ250KTtcbiAgdmFyIGFyaWFMYWJlbDtcblxuICBpZiAoc2VyaWVzQ250IDwgMSkge1xuICAgIC8vIE5vIHNlcmllcywgbm8gYXJpYSBsYWJlbFxuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZSgpO1xuXG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBhcmlhTGFiZWwgPSByZXBsYWNlKGdldENvbmZpZygnZ2VuZXJhbC53aXRoVGl0bGUnKSwge1xuICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmlhTGFiZWwgPSBnZXRDb25maWcoJ2dlbmVyYWwud2l0aG91dFRpdGxlJyk7XG4gICAgfVxuXG4gICAgdmFyIHNlcmllc0xhYmVscyA9IFtdO1xuICAgIHZhciBwcmVmaXggPSBzZXJpZXNDbnQgPiAxID8gJ3Nlcmllcy5tdWx0aXBsZS5wcmVmaXgnIDogJ3Nlcmllcy5zaW5nbGUucHJlZml4JztcbiAgICBhcmlhTGFiZWwgKz0gcmVwbGFjZShnZXRDb25maWcocHJlZml4KSwge1xuICAgICAgc2VyaWVzQ291bnQ6IHNlcmllc0NudFxuICAgIH0pO1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgICAgaWYgKGlkeCA8IGRpc3BsYXlTZXJpZXNDbnQpIHtcbiAgICAgICAgdmFyIHNlcmllc0xhYmVsO1xuICAgICAgICB2YXIgc2VyaWVzTmFtZSA9IHNlcmllc01vZGVsLmdldCgnbmFtZScpO1xuICAgICAgICB2YXIgc2VyaWVzVHBsID0gJ3Nlcmllcy4nICsgKHNlcmllc0NudCA+IDEgPyAnbXVsdGlwbGUnIDogJ3NpbmdsZScpICsgJy4nO1xuICAgICAgICBzZXJpZXNMYWJlbCA9IGdldENvbmZpZyhzZXJpZXNOYW1lID8gc2VyaWVzVHBsICsgJ3dpdGhOYW1lJyA6IHNlcmllc1RwbCArICd3aXRob3V0TmFtZScpO1xuICAgICAgICBzZXJpZXNMYWJlbCA9IHJlcGxhY2Uoc2VyaWVzTGFiZWwsIHtcbiAgICAgICAgICBzZXJpZXNJZDogc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXgsXG4gICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTW9kZWwuZ2V0KCduYW1lJyksXG4gICAgICAgICAgc2VyaWVzVHlwZTogZ2V0U2VyaWVzVHlwZU5hbWUoc2VyaWVzTW9kZWwuc3ViVHlwZSlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB3aW5kb3cuZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgaWYgKGRhdGEuY291bnQoKSA+IG1heERhdGFDbnQpIHtcbiAgICAgICAgICAvLyBTaG93IHBhcnQgb2YgZGF0YVxuICAgICAgICAgIHNlcmllc0xhYmVsICs9IHJlcGxhY2UoZ2V0Q29uZmlnKCdkYXRhLnBhcnRpYWxEYXRhJyksIHtcbiAgICAgICAgICAgIGRpc3BsYXlDbnQ6IG1heERhdGFDbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpZXNMYWJlbCArPSBnZXRDb25maWcoJ2RhdGEuYWxsRGF0YScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFMYWJlbHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuY291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPCBtYXhEYXRhQ250KSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShpKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJldHJpZXZlUmF3VmFsdWUoZGF0YSwgaSk7XG4gICAgICAgICAgICBkYXRhTGFiZWxzLnB1c2gocmVwbGFjZShuYW1lID8gZ2V0Q29uZmlnKCdkYXRhLndpdGhOYW1lJykgOiBnZXRDb25maWcoJ2RhdGEud2l0aG91dE5hbWUnKSwge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpZXNMYWJlbCArPSBkYXRhTGFiZWxzLmpvaW4oZ2V0Q29uZmlnKCdkYXRhLnNlcGFyYXRvci5taWRkbGUnKSkgKyBnZXRDb25maWcoJ2RhdGEuc2VwYXJhdG9yLmVuZCcpO1xuICAgICAgICBzZXJpZXNMYWJlbHMucHVzaChzZXJpZXNMYWJlbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXJpYUxhYmVsICs9IHNlcmllc0xhYmVscy5qb2luKGdldENvbmZpZygnc2VyaWVzLm11bHRpcGxlLnNlcGFyYXRvci5taWRkbGUnKSkgKyBnZXRDb25maWcoJ3Nlcmllcy5tdWx0aXBsZS5zZXBhcmF0b3IuZW5kJyk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGFyaWFMYWJlbCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHN0ciwga2V5VmFsdWVzKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBzdHI7XG4gICAgenJVdGlsLmVhY2goa2V5VmFsdWVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXHtcXFxccyonICsga2V5ICsgJ1xcXFxzKlxcXFx9JywgJ2cnKSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb25maWcocGF0aCkge1xuICAgIHZhciB1c2VyQ29uZmlnID0gYXJpYU1vZGVsLmdldChwYXRoKTtcblxuICAgIGlmICh1c2VyQ29uZmlnID09IG51bGwpIHtcbiAgICAgIHZhciBwYXRoQXJyID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgdmFyIHJlc3VsdCA9IGxhbmcuYXJpYTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdFtwYXRoQXJyW2ldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVzZXJDb25maWc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgdmFyIHRpdGxlID0gZWNNb2RlbC5nZXRNb2RlbCgndGl0bGUnKS5vcHRpb247XG5cbiAgICBpZiAodGl0bGUgJiYgdGl0bGUubGVuZ3RoKSB7XG4gICAgICB0aXRsZSA9IHRpdGxlWzBdO1xuICAgIH1cblxuICAgIHJldHVybiB0aXRsZSAmJiB0aXRsZS50ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VyaWVzVHlwZU5hbWUodHlwZSkge1xuICAgIHJldHVybiBsYW5nLnNlcmllcy50eXBlTmFtZXNbdHlwZV0gfHwgJ+iHquWumuS5ieWbvic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvYXJpYS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlzdWFsL2FyaWEuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgR3JhZGllbnQgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudFwiKTtcblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9kZWZhdWx0ID0ge1xuICBjcmVhdGVPbkFsbFNlcmllczogdHJ1ZSxcbiAgcGVyZm9ybVJhd1NlcmllczogdHJ1ZSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBjb2xvckFjY2Vzc1BhdGggPSAoc2VyaWVzTW9kZWwudmlzdWFsQ29sb3JBY2Nlc3NQYXRoIHx8ICdpdGVtU3R5bGUuY29sb3InKS5zcGxpdCgnLicpO1xuICAgIHZhciBjb2xvciA9IHNlcmllc01vZGVsLmdldChjb2xvckFjY2Vzc1BhdGgpIC8vIFNldCBpbiBpdGVtU3R5bGVcbiAgICB8fCBzZXJpZXNNb2RlbC5nZXRDb2xvckZyb21QYWxldHRlKCAvLyBUT0RPIHNlcmllcyBjb3VudCBjaGFuZ2VkLlxuICAgIHNlcmllc01vZGVsLm5hbWUsIG51bGwsIGVjTW9kZWwuZ2V0U2VyaWVzQ291bnQoKSk7IC8vIERlZmF1bHQgY29sb3JcbiAgICAvLyBGSVhNRSBTZXQgY29sb3IgZnVuY3Rpb24gb3IgdXNlIHRoZSBwbGF0dGUgY29sb3JcblxuICAgIGRhdGEuc2V0VmlzdWFsKCdjb2xvcicsIGNvbG9yKTsgLy8gT25seSB2aXNpYmxlIHNlcmllcyBoYXMgZWFjaCBkYXRhIGJlIHZpc3VhbCBlbmNvZGVkXG5cbiAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdmdW5jdGlvbicgJiYgIShjb2xvciBpbnN0YW5jZW9mIEdyYWRpZW50KSkge1xuICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicsIGNvbG9yKHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoaWR4KSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gaXRlbVN0eWxlIGluIGVhY2ggZGF0YSBpdGVtXG5cblxuICAgICAgdmFyIGRhdGFFYWNoID0gZnVuY3Rpb24gKGRhdGEsIGlkeCkge1xuICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgdmFyIGNvbG9yID0gaXRlbU1vZGVsLmdldChjb2xvckFjY2Vzc1BhdGgsIHRydWUpO1xuXG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJywgY29sb3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhRWFjaDogZGF0YS5oYXNJdGVtT3B0aW9uID8gZGF0YUVhY2ggOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlzdWFsL3Nlcmllc0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvc2VyaWVzQ29sb3IuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5mdW5jdGlvbiBfZGVmYXVsdChzZXJpZXNUeXBlLCBkZWZhdWx0U3ltYm9sVHlwZSwgbGVnZW5kU3ltYm9sKSB7XG4gIC8vIEVuY29kaW5nIHZpc3VhbCBmb3IgYWxsIHNlcmllcyBpbmNsdWRlIHdoaWNoIGlzIGZpbHRlcmVkIGZvciBsZWdlbmQgZHJhd2luZ1xuICByZXR1cm4ge1xuICAgIHNlcmllc1R5cGU6IHNlcmllc1R5cGUsXG4gICAgLy8gRm9yIGxlZ2VuZC5cbiAgICBwZXJmb3JtUmF3U2VyaWVzOiB0cnVlLFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgc3ltYm9sVHlwZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sJykgfHwgZGVmYXVsdFN5bWJvbFR5cGU7XG4gICAgICB2YXIgc3ltYm9sU2l6ZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuICAgICAgdmFyIGtlZXBBc3BlY3QgPSBzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbEtlZXBBc3BlY3QnKTtcbiAgICAgIGRhdGEuc2V0VmlzdWFsKHtcbiAgICAgICAgbGVnZW5kU3ltYm9sOiBsZWdlbmRTeW1ib2wgfHwgc3ltYm9sVHlwZSxcbiAgICAgICAgc3ltYm9sOiBzeW1ib2xUeXBlLFxuICAgICAgICBzeW1ib2xTaXplOiBzeW1ib2xTaXplLFxuICAgICAgICBzeW1ib2xLZWVwQXNwZWN0OiBrZWVwQXNwZWN0XG4gICAgICB9KTsgLy8gT25seSB2aXNpYmxlIHNlcmllcyBoYXMgZWFjaCBkYXRhIGJlIHZpc3VhbCBlbmNvZGVkXG5cbiAgICAgIGlmIChlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0NhbGxiYWNrID0gdHlwZW9mIHN5bWJvbFNpemUgPT09ICdmdW5jdGlvbic7XG5cbiAgICAgIGZ1bmN0aW9uIGRhdGFFYWNoKGRhdGEsIGlkeCkge1xuICAgICAgICBpZiAodHlwZW9mIHN5bWJvbFNpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgcmF3VmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpZHgpOyAvLyBGSVhNRVxuXG4gICAgICAgICAgdmFyIHBhcmFtcyA9IHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoaWR4KTtcbiAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScsIHN5bWJvbFNpemUocmF3VmFsdWUsIHBhcmFtcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICAgIHZhciBpdGVtU3ltYm9sVHlwZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2wnLCB0cnVlKTtcbiAgICAgICAgICB2YXIgaXRlbVN5bWJvbFNpemUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sU2l6ZScsIHRydWUpO1xuICAgICAgICAgIHZhciBpdGVtU3ltYm9sS2VlcEFzcGVjdCA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xLZWVwQXNwZWN0JywgdHJ1ZSk7IC8vIElmIGhhcyBpdGVtIHN5bWJvbFxuXG4gICAgICAgICAgaWYgKGl0ZW1TeW1ib2xUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnLCBpdGVtU3ltYm9sVHlwZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGl0ZW1TeW1ib2xTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgVHJhbnNmb3JtIHN5bWJvbFNpemUgP1xuICAgICAgICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnLCBpdGVtU3ltYm9sU2l6ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGl0ZW1TeW1ib2xLZWVwQXNwZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xLZWVwQXNwZWN0JywgaXRlbVN5bWJvbEtlZXBBc3BlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhRWFjaDogZGF0YS5oYXNJdGVtT3B0aW9uIHx8IGhhc0NhbGxiYWNrID8gZGF0YUVhY2ggOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvc3ltYm9sLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uX20oMClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidXNlcl90cmFuc2ZlclwiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHtcbiAgICAgICAgc3RhdGljU3R5bGU6IHsgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiNTAwcHhcIiB9LFxuICAgICAgICBhdHRyczogeyBpZDogXCJ1c2VyX3RyYW5zZmVyXCIgfVxuICAgICAgfSlcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbm1vZHVsZS5leHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi03MTExZjExYlwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNzExMWYxMWJcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvaW5kZXgvdXNlcl90cmFuc2Zlci52dWVcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4LmpzP3tcImlkXCI6XCJkYXRhLXYtNzExMWYxMWJcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvaW5kZXgvdXNlcl90cmFuc2Zlci52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgVHJhbnNmb3JtYWJsZSA9IHJlcXVpcmUoXCIuL21peGluL1RyYW5zZm9ybWFibGVcIik7XG5cbnZhciBBbmltYXRhYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vQW5pbWF0YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfVxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICovXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBUcmFuc2Zvcm1hYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gIEFuaW1hdGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgLyoqXG4gICAqIOeUu+W4g+WFg+e0oElEXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuaWQgPSBvcHRzLmlkIHx8IGd1aWQoKTtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlID0ge1xuICAvKipcbiAgICog5YWD57Sg57G75Z6LXG4gICAqIEVsZW1lbnQgdHlwZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ2VsZW1lbnQnLFxuXG4gIC8qKlxuICAgKiDlhYPntKDlkI3lrZdcbiAgICogRWxlbWVudCBuYW1lXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBuYW1lOiAnJyxcblxuICAvKipcbiAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICogWlJlbmRlciBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHdoZW4gZWxlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGggenJlbmRlclxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNfX3pyXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgKi9cbiAgX196cjogbnVsbCxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5b+955Wl77yM5Li6dHJ1ZeaXtuW/veeVpeWbvuW9oueahOe7mOWItuS7peWPiuS6i+S7tuinpuWPkVxuICAgKiBJZiBpZ25vcmUgZHJhd2luZyBhbmQgZXZlbnRzIG9mIHRoZSBlbGVtZW50IG9iamVjdFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpZ25vcmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgKiDor6Xot6/lvoTkvJrnu6fmib/ooqvoo4Hlh4/lr7nosaHnmoTlj5jmjaJcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH1cbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGNsaXBQYXRoOiBudWxsLFxuXG4gIC8qKlxuICAgKiDmmK/lkKbmmK8gR3JvdXBcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBpc0dyb3VwOiBmYWxzZSxcblxuICAvKipcbiAgICogRHJpZnQgZWxlbWVudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IGR4IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBkeSBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAqL1xuICBkcmlmdDogZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgIHN3aXRjaCAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICBkeSA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIGR4ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICAgIGlmICghbSkge1xuICAgICAgbSA9IHRoaXMudHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIH1cblxuICAgIG1bNF0gKz0gZHg7XG4gICAgbVs1XSArPSBkeTtcbiAgICB0aGlzLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIb29rIGJlZm9yZSB1cGRhdGVcbiAgICovXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIEhvb2sgYWZ0ZXIgdXBkYXRlXG4gICAqL1xuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHt9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyB8fCBrZXkgPT09ICdzY2FsZScgfHwga2V5ID09PSAnb3JpZ2luJykge1xuICAgICAgLy8gQ29weSB0aGUgYXJyYXlcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpc1trZXldO1xuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGhpc1trZXldID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRbMF0gPSB2YWx1ZVswXTtcbiAgICAgICAgdGFyZ2V0WzFdID0gdmFsdWVbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGlkZSB0aGUgZWxlbWVudFxuICAgKi9cbiAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaWdub3JlID0gdHJ1ZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICogU2hvdyB0aGUgZWxlbWVudFxuICAgKi9cbiAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaWdub3JlID0gZmFsc2U7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIGF0dHI6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmF0dHJLVihrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5hdHRyS1YobmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gY2xpcFBhdGhcbiAgICovXG4gIHNldENsaXBQYXRoOiBmdW5jdGlvbiAoY2xpcFBhdGgpIHtcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG5cbiAgICBpZiAoenIpIHtcbiAgICAgIGNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICB9IC8vIFJlbW92ZSBwcmV2aW91cyBjbGlwIHBhdGhcblxuXG4gICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aCAhPT0gY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgY2xpcFBhdGguX196ciA9IHpyO1xuICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IHRoaXM7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqL1xuICByZW1vdmVDbGlwUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGg7XG5cbiAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgIGlmIChjbGlwUGF0aC5fX3pyKSB7XG4gICAgICAgIGNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoY2xpcFBhdGguX196cik7XG4gICAgICB9XG5cbiAgICAgIGNsaXBQYXRoLl9fenIgPSBudWxsO1xuICAgICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuY2xpcFBhdGggPSBudWxsO1xuICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgKi9cbiAgYWRkU2VsZlRvWnI6IGZ1bmN0aW9uICh6cikge1xuICAgIHRoaXMuX196ciA9IHpyOyAvLyDmt7vliqDliqjnlLtcblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcblxuICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAqL1xuICByZW1vdmVTZWxmRnJvbVpyOiBmdW5jdGlvbiAoenIpIHtcbiAgICB0aGlzLl9fenIgPSBudWxsOyAvLyDnp7vpmaTliqjnlLtcblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcblxuICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHpyLmFuaW1hdGlvbi5yZW1vdmVBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgIH1cbiAgfVxufTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBBbmltYXRhYmxlKTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBUcmFuc2Zvcm1hYmxlKTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBFdmVudGZ1bCk7XG52YXIgX2RlZmF1bHQgPSBFbGVtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9FbGVtZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcIi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBEcmFnZ2FibGUgPSByZXF1aXJlKFwiLi9taXhpbi9EcmFnZ2FibGVcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgU0lMRU5UID0gJ3NpbGVudCc7XG5cbmZ1bmN0aW9uIG1ha2VFdmVudFBhY2tldChldmVUeXBlLCB0YXJnZXRJbmZvLCBldmVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV2ZVR5cGUsXG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIC8vIHRhcmdldCBjYW4gb25seSBiZSBhbiBlbGVtZW50IHRoYXQgaXMgbm90IHNpbGVudC5cbiAgICB0YXJnZXQ6IHRhcmdldEluZm8udGFyZ2V0LFxuICAgIC8vIHRvcFRhcmdldCBjYW4gYmUgYSBzaWxlbnQgZWxlbWVudC5cbiAgICB0b3BUYXJnZXQ6IHRhcmdldEluZm8udG9wVGFyZ2V0LFxuICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgb2Zmc2V0WDogZXZlbnQuenJYLFxuICAgIG9mZnNldFk6IGV2ZW50LnpyWSxcbiAgICBnZXN0dXJlRXZlbnQ6IGV2ZW50Lmdlc3R1cmVFdmVudCxcbiAgICBwaW5jaFg6IGV2ZW50LnBpbmNoWCxcbiAgICBwaW5jaFk6IGV2ZW50LnBpbmNoWSxcbiAgICBwaW5jaFNjYWxlOiBldmVudC5waW5jaFNjYWxlLFxuICAgIHdoZWVsRGVsdGE6IGV2ZW50LnpyRGVsdGEsXG4gICAgenJCeVRvdWNoOiBldmVudC56ckJ5VG91Y2gsXG4gICAgd2hpY2g6IGV2ZW50LndoaWNoXG4gIH07XG59XG5cbmZ1bmN0aW9uIEVtcHR5UHJveHkoKSB7fVxuXG5FbXB0eVByb3h5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBoYW5kbGVyTmFtZXMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J107XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlciBQYWludGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9kb20vSGFuZGxlclByb3h5fSBwcm94eSBIYW5kbGVyUHJveHkgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYWludGVyUm9vdCBwYWludGVyLnJvb3QgKG5vdCBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKS5cbiAqL1xuXG52YXIgSGFuZGxlciA9IGZ1bmN0aW9uIChzdG9yYWdlLCBwYWludGVyLCBwcm94eSwgcGFpbnRlclJvb3QpIHtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdGhpcy5wYWludGVyUm9vdCA9IHBhaW50ZXJSb290O1xuICBwcm94eSA9IHByb3h5IHx8IG5ldyBFbXB0eVByb3h5KCk7XG4gIC8qKlxuICAgKiBQcm94eSBvZiBldmVudC4gY2FuIGJlIERvbSwgV2ViR0xTdXJmYWNlLCBldGMuXG4gICAqL1xuXG4gIHRoaXMucHJveHkgPSBudWxsO1xuICAvKipcbiAgICoge3RhcmdldCwgdG9wVGFyZ2V0LCB4LCB5fVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9ob3ZlcmVkID0ge307XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFRvdWNoTW9tZW50O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFg7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl9sYXN0WTtcbiAgRHJhZ2dhYmxlLmNhbGwodGhpcyk7XG4gIHRoaXMuc2V0SGFuZGxlclByb3h5KHByb3h5KTtcbn07XG5cbkhhbmRsZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlcixcbiAgc2V0SGFuZGxlclByb3h5OiBmdW5jdGlvbiAocHJveHkpIHtcbiAgICBpZiAodGhpcy5wcm94eSkge1xuICAgICAgdGhpcy5wcm94eS5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb3h5KSB7XG4gICAgICB1dGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBwcm94eS5vbiAmJiBwcm94eS5vbihuYW1lLCB0aGlzW25hbWVdLCB0aGlzKTtcbiAgICAgIH0sIHRoaXMpOyAvLyBBdHRhY2ggaGFuZGxlclxuXG4gICAgICBwcm94eS5oYW5kbGVyID0gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLnByb3h5ID0gcHJveHk7XG4gIH0sXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHggPSBldmVudC56clg7XG4gICAgdmFyIHkgPSBldmVudC56clk7XG4gICAgdmFyIGxhc3RIb3ZlcmVkID0gdGhpcy5faG92ZXJlZDtcbiAgICB2YXIgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7IC8vIElmIGxhc3RIb3ZlcmVkVGFyZ2V0IGlzIHJlbW92ZWQgZnJvbSB6ciAoZGV0ZWN0ZWQgYnkgJ19fenInKSBieSBzb21lIEFQSSBjYWxsXG4gICAgLy8gKGxpa2UgJ3NldE9wdGlvbicgb3IgJ2Rpc3BhdGNoQWN0aW9uJykgaW4gZXZlbnQgaGFuZGxlcnMsIHdlIHNob3VsZCBmaW5kXG4gICAgLy8gbGFzdEhvdmVyZWQgYWdhaW4gaGVyZS4gT3RoZXJ3aXNlICdtb3VzZW91dCcgY2FuIG5vdCBiZSB0cmlnZ2VyZWQgbm9ybWFsbHkuXG4gICAgLy8gU2VlICM2MTk4LlxuXG4gICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmICFsYXN0SG92ZXJlZFRhcmdldC5fX3pyKSB7XG4gICAgICBsYXN0SG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGxhc3RIb3ZlcmVkLngsIGxhc3RIb3ZlcmVkLnkpO1xuICAgICAgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoeCwgeSk7XG4gICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcbiAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoaG92ZXJlZFRhcmdldCA/IGhvdmVyZWRUYXJnZXQuY3Vyc29yIDogJ2RlZmF1bHQnKTsgLy8gTW91c2Ugb3V0IG9uIHByZXZpb3VzIGhvdmVyZWQgZWxlbWVudFxuXG4gICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGxhc3RIb3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgfSAvLyBNb3VzZSBtb3Zpbmcgb24gb25lIGVsZW1lbnRcblxuXG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2Vtb3ZlJywgZXZlbnQpOyAvLyBNb3VzZSBvdmVyIG9uIGEgbmV3IGVsZW1lbnRcblxuICAgIGlmIChob3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9ob3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7IC8vIFRoZXJlIG1pZ2h0IGJlIHNvbWUgZG9tcyBjcmVhdGVkIGJ5IHVwcGVyIGxheWVyIGFwcGxpY2F0aW9uXG4gICAgLy8gYXQgdGhlIHNhbWUgbGV2ZWwgb2YgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSAoZS5nLiwgdG9vbHRpcFxuICAgIC8vIGRvbSBjcmVhdGVkIGJ5IGVjaGFydHMpLCB3aGVyZSAnZ2xvYmFsb3V0JyBldmVudCBzaG91bGQgbm90XG4gICAgLy8gYmUgdHJpZ2dlcmVkIHdoZW4gbW91c2UgZW50ZXJzIHRoZXNlIGRvbXMuIChCdXQgJ21vdXNlb3V0J1xuICAgIC8vIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQgdGhlIG9yaWdpbmFsIGhvdmVyZWQgZWxlbWVudCBhcyB1c3VhbCkuXG5cbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIHZhciBpbm5lckRvbTtcblxuICAgIGRvIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSAmJiAhKGlubmVyRG9tID0gZWxlbWVudCA9PT0gdGhpcy5wYWludGVyUm9vdCkpO1xuXG4gICAgIWlubmVyRG9tICYmIHRoaXMudHJpZ2dlcignZ2xvYmFsb3V0Jywge1xuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9ob3ZlcmVkID0ge307XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtldmVudD19IGV2ZW50QXJnc1xuICAgKi9cbiAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJncykge1xuICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50QXJncyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3Bvc2VcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLnN0b3JhZ2UgPSB0aGlzLnByb3h5ID0gdGhpcy5wYWludGVyID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAqL1xuICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGN1cnNvclN0eWxlKTtcbiAgfSxcblxuICAvKipcbiAgICog5LqL5Lu25YiG5Y+R5Luj55CGXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRJbmZvIHt0YXJnZXQsIHRvcFRhcmdldH0g55uu5qCH5Zu+5b2i5YWD57SgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCN56ewXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAgICovXG4gIGRpc3BhdGNoVG9FbGVtZW50OiBmdW5jdGlvbiAodGFyZ2V0SW5mbywgZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRhcmdldEluZm8gPSB0YXJnZXRJbmZvIHx8IHt9O1xuICAgIHZhciBlbCA9IHRhcmdldEluZm8udGFyZ2V0O1xuXG4gICAgaWYgKGVsICYmIGVsLnNpbGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBldmVudEhhbmRsZXIgPSAnb24nICsgZXZlbnROYW1lO1xuICAgIHZhciBldmVudFBhY2tldCA9IG1ha2VFdmVudFBhY2tldChldmVudE5hbWUsIHRhcmdldEluZm8sIGV2ZW50KTtcblxuICAgIHdoaWxlIChlbCkge1xuICAgICAgZWxbZXZlbnRIYW5kbGVyXSAmJiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlID0gZWxbZXZlbnRIYW5kbGVyXS5jYWxsKGVsLCBldmVudFBhY2tldCkpO1xuICAgICAgZWwudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgIGVsID0gZWwucGFyZW50O1xuXG4gICAgICBpZiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAvLyDlhpLms6HliLDpobbnuqcgenJlbmRlciDlr7nosaFcbiAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTsgLy8g5YiG5Y+R5LqL5Lu25Yiw55So5oi36Ieq5a6a5LmJ5bGCXG4gICAgICAvLyDnlKjmiLfmnInlj6/og73lnKjlhajlsYAgY2xpY2sg5LqL5Lu25LitIGRpc3Bvc2XvvIzmiYDku6XpnIDopoHliKTmlq3kuIsgcGFpbnRlciDmmK/lkKblrZjlnKhcblxuICAgICAgdGhpcy5wYWludGVyICYmIHRoaXMucGFpbnRlci5lYWNoT3RoZXJMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsYXllcltldmVudEhhbmRsZXJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBsYXllcltldmVudEhhbmRsZXJdLmNhbGwobGF5ZXIsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9IGV4Y2x1ZGVcbiAgICogQHJldHVybiB7bW9kZWw6enJlbmRlci9FbGVtZW50fVxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBmaW5kSG92ZXI6IGZ1bmN0aW9uICh4LCB5LCBleGNsdWRlKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgICB2YXIgb3V0ID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBob3ZlckNoZWNrUmVzdWx0O1xuXG4gICAgICBpZiAobGlzdFtpXSAhPT0gZXhjbHVkZSAvLyBnZXREaXNwbGF5TGlzdCBtYXkgaW5jbHVkZSBpZ25vcmVkIGl0ZW0gaW4gVk1MIG1vZGVcbiAgICAgICYmICFsaXN0W2ldLmlnbm9yZSAmJiAoaG92ZXJDaGVja1Jlc3VsdCA9IGlzSG92ZXIobGlzdFtpXSwgeCwgeSkpKSB7XG4gICAgICAgICFvdXQudG9wVGFyZ2V0ICYmIChvdXQudG9wVGFyZ2V0ID0gbGlzdFtpXSk7XG5cbiAgICAgICAgaWYgKGhvdmVyQ2hlY2tSZXN1bHQgIT09IFNJTEVOVCkge1xuICAgICAgICAgIG91dC50YXJnZXQgPSBsaXN0W2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxufTsgLy8gQ29tbW9uIGhhbmRsZXJzXG5cbnV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBGaW5kIGhvdmVyIGFnYWluIHRvIGF2b2lkIGNsaWNrIGV2ZW50IGlzIGRpc3BhdGNoZWQgbWFudWFsbHkuIE9yIGNsaWNrIGlzIHRyaWdnZXJlZCB3aXRob3V0IG1vdXNlb3ZlclxuICAgIHZhciBob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clkpO1xuICAgIHZhciBob3ZlcmVkVGFyZ2V0ID0gaG92ZXJlZC50YXJnZXQ7XG5cbiAgICBpZiAobmFtZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgIHRoaXMuX2Rvd25FbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgICB0aGlzLl9kb3duUG9pbnQgPSBbZXZlbnQuenJYLCBldmVudC56clldOyAvLyBJbiBjYXNlIGNsaWNrIHRyaWdnZXJlZCBiZWZvcmUgbW91c2V1cFxuXG4gICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdtb3VzZXVwJykge1xuICAgICAgdGhpcy5fdXBFbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBpZiAodGhpcy5fZG93bkVsICE9PSB0aGlzLl91cEVsIC8vIE9yaWdpbmFsIGNsaWNrIGV2ZW50IGlzIHRyaWdnZXJlZCBvbiB0aGUgd2hvbGUgY2FudmFzIGVsZW1lbnQsXG4gICAgICAvLyBpbmNsdWRpbmcgdGhlIGNhc2UgdGhhdCBgbW91c2Vkb3duYCAtIGBtb3VzZW1vdmVgIC0gYG1vdXNldXBgLFxuICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIGZpbHRlcmVkLCBvdGhlcndpc2UgaXQgd2lsbCBicmluZyB0cm91YmxlIHRvXG4gICAgICAvLyBwYW4gYW5kIHpvb20uXG4gICAgICB8fCAhdGhpcy5fZG93blBvaW50IC8vIEFyYml0cmFyeSB2YWx1ZVxuICAgICAgfHwgdmVjMi5kaXN0KHRoaXMuX2Rvd25Qb2ludCwgW2V2ZW50LnpyWCwgZXZlbnQuenJZXSkgPiA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG93blBvaW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsIG5hbWUsIGV2ZW50KTtcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gIGlmIChkaXNwbGF5YWJsZVtkaXNwbGF5YWJsZS5yZWN0SG92ZXIgPyAncmVjdENvbnRhaW4nIDogJ2NvbnRhaW4nXSh4LCB5KSkge1xuICAgIHZhciBlbCA9IGRpc3BsYXlhYmxlO1xuICAgIHZhciBpc1NpbGVudDtcblxuICAgIHdoaWxlIChlbCkge1xuICAgICAgLy8gSWYgY2xpcHBlZCBieSBhbmNlc3Rvci5cbiAgICAgIC8vIEZJWE1FOiBJZiBjbGlwUGF0aCBoYXMgbmVpdGhlciBzdHJva2Ugbm9yIGZpbGwsXG4gICAgICAvLyBlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICAgIGlmIChlbC5jbGlwUGF0aCAmJiAhZWwuY2xpcFBhdGguY29udGFpbih4LCB5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5zaWxlbnQpIHtcbiAgICAgICAgaXNTaWxlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNTaWxlbnQgPyBTSUxFTlQgOiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG51dGlsLm1peGluKEhhbmRsZXIsIEV2ZW50ZnVsKTtcbnV0aWwubWl4aW4oSGFuZGxlciwgRHJhZ2dhYmxlKTtcbnZhciBfZGVmYXVsdCA9IEhhbmRsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5cbnZhciBkZXZpY2VQaXhlbFJhdGlvID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9ncmFwaGljL1N0eWxlXCIpO1xuXG52YXIgUGF0dGVybiA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvUGF0dGVyblwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvTGF5ZXJcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIOWIm+W7umRvbVxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtzdHJpbmd9IGlkIGRvbSBpZCDlvoXnlKhcbiAqIEBwYXJhbSB7UGFpbnRlcn0gcGFpbnRlciBwYWludGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVEb20oaWQsIHBhaW50ZXIsIGRwcikge1xuICB2YXIgbmV3RG9tID0gdXRpbC5jcmVhdGVDYW52YXMoKTtcbiAgdmFyIHdpZHRoID0gcGFpbnRlci5nZXRXaWR0aCgpO1xuICB2YXIgaGVpZ2h0ID0gcGFpbnRlci5nZXRIZWlnaHQoKTtcbiAgdmFyIG5ld0RvbVN0eWxlID0gbmV3RG9tLnN0eWxlO1xuXG4gIGlmIChuZXdEb21TdHlsZSkge1xuICAgIC8vIEluIG5vZGUgb3Igc29tZSBvdGhlciBub24tYnJvd3NlciBlbnZpcm9ubWVudFxuICAgIG5ld0RvbVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBuZXdEb21TdHlsZS5sZWZ0ID0gMDtcbiAgICBuZXdEb21TdHlsZS50b3AgPSAwO1xuICAgIG5ld0RvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIG5ld0RvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgbmV3RG9tLnNldEF0dHJpYnV0ZSgnZGF0YS16ci1kb20taWQnLCBpZCk7XG4gIH1cblxuICBuZXdEb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgbmV3RG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgcmV0dXJuIG5ld0RvbTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0xheWVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyXG4gKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAqL1xuXG5cbnZhciBMYXllciA9IGZ1bmN0aW9uIChpZCwgcGFpbnRlciwgZHByKSB7XG4gIHZhciBkb207XG4gIGRwciA9IGRwciB8fCBkZXZpY2VQaXhlbFJhdGlvO1xuXG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgZG9tID0gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpO1xuICB9IC8vIE5vdCB1c2luZyBpc0RvbSBiZWNhdXNlIGluIG5vZGUgaXQgd2lsbCByZXR1cm4gZmFsc2VcbiAgZWxzZSBpZiAodXRpbC5pc09iamVjdChpZCkpIHtcbiAgICAgIGRvbSA9IGlkO1xuICAgICAgaWQgPSBkb20uaWQ7XG4gICAgfVxuXG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5kb20gPSBkb207XG4gIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcblxuICBpZiAoZG9tU3R5bGUpIHtcbiAgICAvLyBOb3QgaW4gbm9kZVxuICAgIGRvbS5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuXG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgIGRvbVN0eWxlWydwYWRkaW5nJ10gPSAwO1xuICAgIGRvbVN0eWxlWydtYXJnaW4nXSA9IDA7XG4gICAgZG9tU3R5bGVbJ2JvcmRlci13aWR0aCddID0gMDtcbiAgfVxuXG4gIHRoaXMuZG9tQmFjayA9IG51bGw7XG4gIHRoaXMuY3R4QmFjayA9IG51bGw7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHRoaXMuY29uZmlnID0gbnVsbDsgLy8gQ29uZmlnc1xuXG4gIC8qKlxuICAgKiDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cblxuICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAvKipcbiAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cblxuICB0aGlzLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgLyoqXG4gICAqIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuN1xuICAgKi9cblxuICB0aGlzLmxhc3RGcmFtZUFscGhhID0gMC43O1xuICAvKipcbiAgICogTGF5ZXIgZHByXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gZHByO1xufTtcblxuTGF5ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG4gIF9fZGlydHk6IHRydWUsXG4gIF9fdXNlZDogZmFsc2UsXG4gIF9fZHJhd0luZGV4OiAwLFxuICBfX3N0YXJ0SW5kZXg6IDAsXG4gIF9fZW5kSW5kZXg6IDAsXG4gIGluY3JlbWVudGFsOiBmYWxzZSxcbiAgZ2V0RWxlbWVudENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19lbmRJbmRleCAtIHRoaXMuX19zdGFydEluZGV4O1xuICB9LFxuICBpbml0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3R4ID0gdGhpcy5kb20uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmN0eC5kcHIgPSB0aGlzLmRwcjtcbiAgfSxcbiAgY3JlYXRlQmFja0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcbiAgICB0aGlzLmRvbUJhY2sgPSBjcmVhdGVEb20oJ2JhY2stJyArIHRoaXMuaWQsIHRoaXMucGFpbnRlciwgZHByKTtcbiAgICB0aGlzLmN0eEJhY2sgPSB0aGlzLmRvbUJhY2suZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcblxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBkb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIGRvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICBpZiAoZG9tQmFjaykge1xuICAgICAgZG9tQmFjay53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgZG9tQmFjay5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5riF56m66K+l5bGC55S75biDXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsZWFyQWxsXT1mYWxzZSBDbGVhciBhbGwgd2l0aCBvdXQgbW90aW9uIGJsdXJcbiAgICogQHBhcmFtIHtDb2xvcn0gW2NsZWFyQ29sb3JdXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsLCBjbGVhckNvbG9yKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGRvbS5oZWlnaHQ7XG4gICAgdmFyIGNsZWFyQ29sb3IgPSBjbGVhckNvbG9yIHx8IHRoaXMuY2xlYXJDb2xvcjtcbiAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgIHZhciBsYXN0RnJhbWVBbHBoYSA9IHRoaXMubGFzdEZyYW1lQWxwaGE7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHhCYWNrLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoZG9tLCAwLCAwLCB3aWR0aCAvIGRwciwgaGVpZ2h0IC8gZHByKTtcbiAgICB9XG5cbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYgKGNsZWFyQ29sb3IgJiYgY2xlYXJDb2xvciAhPT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgdmFyIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjsgLy8gR3JhZGllbnRcblxuICAgICAgaWYgKGNsZWFyQ29sb3IuY29sb3JTdG9wcykge1xuICAgICAgICAvLyBDYWNoZSBjYW52YXMgZ3JhZGllbnRcbiAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50IHx8IFN0eWxlLmdldEdyYWRpZW50KGN0eCwgY2xlYXJDb2xvciwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgIH0gLy8gUGF0dGVyblxuICAgICAgZWxzZSBpZiAoY2xlYXJDb2xvci5pbWFnZSkge1xuICAgICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4uY2FsbChjbGVhckNvbG9yLCBjdHgpO1xuICAgICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuIHx8IGNsZWFyQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gbGFzdEZyYW1lQWxwaGE7XG4gICAgICBjdHguZHJhd0ltYWdlKGRvbUJhY2ssIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBMYXllcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvTGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0xheWVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5cbnZhciBkZXZpY2VQaXhlbFJhdGlvID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2NvcmUvbG9nXCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB0aW1zb3J0ID0gcmVxdWlyZShcIi4vY29yZS90aW1zb3J0XCIpO1xuXG52YXIgTGF5ZXIgPSByZXF1aXJlKFwiLi9MYXllclwiKTtcblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIik7XG5cbnZhciBJbWFnZSA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvSW1hZ2VcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIEhPVkVSX0xBWUVSX1pMRVZFTCA9IDFlNTtcbnZhciBDQU5WQVNfWkxFVkVMID0gMzE0MTU5O1xudmFyIEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQyA9IDAuMDE7XG52YXIgSU5DUkVNRU5UQUxfSU5DID0gMC4wMDE7XG5cbmZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNMYXllclZhbGlkKGxheWVyKSB7XG4gIGlmICghbGF5ZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGF5ZXIucmVzaXplICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBsYXllci5yZWZyZXNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbnZhciB2aWV3UmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG5cbmZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcblxuICBpZiAoZWwudHJhbnNmb3JtKSB7XG4gICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICB9XG5cbiAgdmlld1JlY3Qud2lkdGggPSB3aWR0aDtcbiAgdmlld1JlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICByZXR1cm4gIXRtcFJlY3QuaW50ZXJzZWN0KHZpZXdSZWN0KTtcbn1cblxuZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gIGlmIChjbGlwUGF0aHMgPT0gcHJldkNsaXBQYXRocykge1xuICAgIC8vIENhbiBib3RoIGJlIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgY2xpcFBhdGhzLmxlbmd0aCAhPT0gcHJldkNsaXBQYXRocy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNsaXBQYXRoc1tpXSAhPT0gcHJldkNsaXBQYXRoc1tpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjbGlwUGF0aCA9IGNsaXBQYXRoc1tpXTtcbiAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY2xpcFBhdGguYnVpbGRQYXRoKGN0eCwgY2xpcFBhdGguc2hhcGUpO1xuICAgIGN0eC5jbGlwKCk7IC8vIFRyYW5zZm9ybSBiYWNrXG5cbiAgICBjbGlwUGF0aC5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdCh3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBkb21Sb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vIGRvbVJvb3Qub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcblxuICBkb21Sb290LnN0eWxlLmNzc1RleHQgPSBbJ3Bvc2l0aW9uOnJlbGF0aXZlJywgJ292ZXJmbG93OmhpZGRlbicsICd3aWR0aDonICsgd2lkdGggKyAncHgnLCAnaGVpZ2h0OicgKyBoZWlnaHQgKyAncHgnLCAncGFkZGluZzowJywgJ21hcmdpbjowJywgJ2JvcmRlci13aWR0aDowJ10uam9pbignOycpICsgJzsnO1xuICByZXR1cm4gZG9tUm9vdDtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1BhaW50ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCDnu5jlm77lrrnlmahcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuXG5cbnZhciBQYWludGVyID0gZnVuY3Rpb24gKHJvb3QsIHN0b3JhZ2UsIG9wdHMpIHtcbiAgdGhpcy50eXBlID0gJ2NhbnZhcyc7IC8vIEluIG5vZGUgZW52aXJvbm1lbnQgdXNpbmcgbm9kZS1jYW52YXNcblxuICB2YXIgc2luZ2xlQ2FudmFzID0gIXJvb3Qubm9kZU5hbWUgLy8gSW4gbm9kZSA/XG4gIHx8IHJvb3Qubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUyc7XG4gIHRoaXMuX29wdHMgPSBvcHRzID0gdXRpbC5leHRlbmQoe30sIG9wdHMgfHwge30pO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5kcHIgPSBvcHRzLmRldmljZVBpeGVsUmF0aW8gfHwgZGV2aWNlUGl4ZWxSYXRpbztcbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9zaW5nbGVDYW52YXMgPSBzaW5nbGVDYW52YXM7XG4gIC8qKlxuICAgKiDnu5jlm77lrrnlmahcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKi9cblxuICB0aGlzLnJvb3QgPSByb290O1xuICB2YXIgcm9vdFN0eWxlID0gcm9vdC5zdHlsZTtcblxuICBpZiAocm9vdFN0eWxlKSB7XG4gICAgcm9vdFN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICd0cmFuc3BhcmVudCc7XG4gICAgcm9vdFN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSByb290U3R5bGVbJ3VzZXItc2VsZWN0J10gPSByb290U3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuICAgIHJvb3QuaW5uZXJIVE1MID0gJyc7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfVxuICAgKi9cblxuXG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdCA9IFtdO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6enJlbmRlci9MYXllcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnMgPSB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fbGF5ZXJDb25maWcgPSB7fTtcbiAgLyoqXG4gICAqIHpyZW5kZXIgd2lsbCBkbyBjb21wb3NpdGluZyB3aGVuIHJvb3QgaXMgYSBjYW52YXMgYW5kIGhhdmUgbXVsdGlwbGUgemxldmVscy5cbiAgICovXG5cbiAgdGhpcy5fbmVlZHNNYW51YWxseUNvbXBvc2l0aW5nID0gZmFsc2U7XG5cbiAgaWYgKCFzaW5nbGVDYW52YXMpIHtcbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcbiAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3QgPSBjcmVhdGVSb290KHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQoZG9tUm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpZHRoID0gcm9vdC53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG5cbiAgICBpZiAob3B0cy53aWR0aCAhPSBudWxsKSB7XG4gICAgICB3aWR0aCA9IG9wdHMud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIGhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgIH1cblxuICAgIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7IC8vIFVzZSBjYW52YXMgd2lkdGggYW5kIGhlaWdodCBkaXJlY3RseVxuXG4gICAgcm9vdC53aWR0aCA9IHdpZHRoICogdGhpcy5kcHI7XG4gICAgcm9vdC5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLmRwcjtcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDsgLy8gQ3JlYXRlIGxheWVyIGlmIG9ubHkgb25lIGdpdmVuIGNhbnZhc1xuICAgIC8vIERldmljZSBjYW4gYmUgc3BlY2lmaWVkIHRvIGNyZWF0ZSBhIGhpZ2ggZHBpIGltYWdlLlxuXG4gICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCB0aGlzLmRwcik7XG4gICAgbWFpbkxheWVyLl9fYnVpbHRpbl9fID0gdHJ1ZTtcbiAgICBtYWluTGF5ZXIuaW5pdENvbnRleHQoKTsgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgLy8gbWFpbkxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGxheWVyc1tDQU5WQVNfWkxFVkVMXSA9IG1haW5MYXllcjtcbiAgICBtYWluTGF5ZXIuemxldmVsID0gQ0FOVkFTX1pMRVZFTDsgLy8gTm90IHVzZSBjb21tb24gemxldmVsLlxuXG4gICAgemxldmVsTGlzdC5wdXNoKENBTlZBU19aTEVWRUwpO1xuICAgIHRoaXMuX2RvbVJvb3QgPSByb290O1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgdGhpcy5faG92ZXJsYXllciA9IG51bGw7XG4gIHRoaXMuX2hvdmVyRWxlbWVudHMgPSBbXTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnY2FudmFzJztcbiAgfSxcblxuICAvKipcbiAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbVJvb3Q7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliLfmlrBcbiAgICogQHBhcmFtIHtib29sZWFufSBbcGFpbnRBbGw9ZmFsc2VdIOW8uuWItue7mOWItuaJgOaciWRpc3BsYXlhYmxlXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAocGFpbnRBbGwpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdGhpcy5fcmVkcmF3SWQgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgdGhpcy5fcGFpbnRMaXN0KGxpc3QsIHBhaW50QWxsLCB0aGlzLl9yZWRyYXdJZCk7IC8vIFBhaW50IGN1c3R1bSBsYXllcnNcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18gJiYgbGF5ZXIucmVmcmVzaCkge1xuICAgICAgICB2YXIgY2xlYXJDb2xvciA9IGkgPT09IDAgPyB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgOiBudWxsO1xuICAgICAgICBsYXllci5yZWZyZXNoKGNsZWFyQ29sb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcbiAgICBpZiAoZWwuX19ob3Zlck1pcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbE1pcnJvciA9IG5ldyBlbC5jb25zdHJ1Y3Rvcih7XG4gICAgICBzdHlsZTogZWwuc3R5bGUsXG4gICAgICBzaGFwZTogZWwuc2hhcGVcbiAgICB9KTtcbiAgICBlbE1pcnJvci5fX2Zyb20gPSBlbDtcbiAgICBlbC5fX2hvdmVyTWlyID0gZWxNaXJyb3I7XG4gICAgZWxNaXJyb3Iuc2V0U3R5bGUoaG92ZXJTdHlsZSk7XG5cbiAgICB0aGlzLl9ob3ZlckVsZW1lbnRzLnB1c2goZWxNaXJyb3IpO1xuICB9LFxuICByZW1vdmVIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIGVsTWlycm9yID0gZWwuX19ob3Zlck1pcjtcbiAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZihob3ZlckVsZW1lbnRzLCBlbE1pcnJvcik7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuXG4gICAgZWwuX19ob3Zlck1pciA9IG51bGw7XG4gIH0sXG4gIGNsZWFySG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG92ZXJFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZyb20gPSBob3ZlckVsZW1lbnRzW2ldLl9fZnJvbTtcblxuICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgZnJvbS5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBob3ZlckVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gIH0sXG4gIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICB2YXIgbGVuID0gaG92ZXJFbGVtZW50cy5sZW5ndGg7XG4gICAgdmFyIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyO1xuICAgIGhvdmVyTGF5ZXIgJiYgaG92ZXJMYXllci5jbGVhcigpO1xuXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1zb3J0KGhvdmVyRWxlbWVudHMsIHRoaXMuc3RvcmFnZS5kaXNwbGF5YWJsZVNvcnRGdW5jKTsgLy8gVXNlIGEgZXh0cmVhbSBsYXJnZSB6bGV2ZWxcbiAgICAvLyBGSVhNRT9cblxuICAgIGlmICghaG92ZXJMYXllcikge1xuICAgICAgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXIgPSB0aGlzLmdldExheWVyKEhPVkVSX0xBWUVSX1pMRVZFTCk7XG4gICAgfVxuXG4gICAgdmFyIHNjb3BlID0ge307XG4gICAgaG92ZXJMYXllci5jdHguc2F2ZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgZWwgPSBob3ZlckVsZW1lbnRzW2ldO1xuICAgICAgdmFyIG9yaWdpbmFsRWwgPSBlbC5fX2Zyb207IC8vIE9yaWdpbmFsIGVsIGlzIHJlbW92ZWRcbiAgICAgIC8vIFBFTkRJTkdcblxuICAgICAgaWYgKCEob3JpZ2luYWxFbCAmJiBvcmlnaW5hbEVsLl9fenIpKSB7XG4gICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICBvcmlnaW5hbEVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICBsZW4tLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGkrKzsgLy8gVXNlIHRyYW5zZm9ybVxuICAgICAgLy8gRklYTUUgc3R5bGUgYW5kIHNoYXBlID9cblxuICAgICAgaWYgKCFvcmlnaW5hbEVsLmludmlzaWJsZSkge1xuICAgICAgICBlbC50cmFuc2Zvcm0gPSBvcmlnaW5hbEVsLnRyYW5zZm9ybTtcbiAgICAgICAgZWwuaW52VHJhbnNmb3JtID0gb3JpZ2luYWxFbC5pbnZUcmFuc2Zvcm07XG4gICAgICAgIGVsLl9fY2xpcFBhdGhzID0gb3JpZ2luYWxFbC5fX2NsaXBQYXRoczsgLy8gZWwuXG5cbiAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBob3ZlckxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaG92ZXJMYXllci5jdHgucmVzdG9yZSgpO1xuICB9LFxuICBnZXRIb3ZlckxheWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIoSE9WRVJfTEFZRVJfWkxFVkVMKTtcbiAgfSxcbiAgX3BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsLCByZWRyYXdJZCkge1xuICAgIGlmICh0aGlzLl9yZWRyYXdJZCAhPT0gcmVkcmF3SWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwYWludEFsbCA9IHBhaW50QWxsIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5fdXBkYXRlTGF5ZXJTdGF0dXMobGlzdCk7XG5cbiAgICB2YXIgZmluaXNoZWQgPSB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICBpZiAodGhpcy5fbmVlZHNNYW51YWxseUNvbXBvc2l0aW5nKSB7XG4gICAgICB0aGlzLl9jb21wb3NpdGVNYW51YWxseSgpO1xuICAgIH1cblxuICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCwgcmVkcmF3SWQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBfY29tcG9zaXRlTWFudWFsbHk6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5nZXRMYXllcihDQU5WQVNfWkxFVkVMKS5jdHg7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5fZG9tUm9vdC53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fZG9tUm9vdC5oZWlnaHQ7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTsgLy8gUEVORElORywgSWYgb25seSBidWlsdGluIGxheWVyP1xuXG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgaWYgKGxheWVyLnZpcnR1YWwpIHtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShsYXllci5kb20sIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBfZG9QYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgIHZhciBsYXllckxpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIHppID0gMDsgemkgPCB0aGlzLl96bGV2ZWxMaXN0Lmxlbmd0aDsgemkrKykge1xuICAgICAgdmFyIHpsZXZlbCA9IHRoaXMuX3psZXZlbExpc3RbemldO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXyAmJiBsYXllciAhPT0gdGhpcy5faG92ZXJsYXllciAmJiAobGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkpIHtcbiAgICAgICAgbGF5ZXJMaXN0LnB1c2gobGF5ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGxheWVyTGlzdC5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJMaXN0W2tdO1xuICAgICAgdmFyIGN0eCA9IGxheWVyLmN0eDtcbiAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBzdGFydCA9IHBhaW50QWxsID8gbGF5ZXIuX19zdGFydEluZGV4IDogbGF5ZXIuX19kcmF3SW5kZXg7XG4gICAgICB2YXIgdXNlVGltZXIgPSAhcGFpbnRBbGwgJiYgbGF5ZXIuaW5jcmVtZW50YWwgJiYgRGF0ZS5ub3c7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gdXNlVGltZXIgJiYgRGF0ZS5ub3coKTtcbiAgICAgIHZhciBjbGVhckNvbG9yID0gbGF5ZXIuemxldmVsID09PSB0aGlzLl96bGV2ZWxMaXN0WzBdID8gdGhpcy5fYmFja2dyb3VuZENvbG9yIDogbnVsbDsgLy8gQWxsIGVsZW1lbnRzIGluIHRoaXMgbGF5ZXIgYXJlIGNsZWFyZWQuXG5cbiAgICAgIGlmIChsYXllci5fX3N0YXJ0SW5kZXggPT09IGxheWVyLl9fZW5kSW5kZXgpIHtcbiAgICAgICAgbGF5ZXIuY2xlYXIoZmFsc2UsIGNsZWFyQ29sb3IpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCA9PT0gbGF5ZXIuX19zdGFydEluZGV4KSB7XG4gICAgICAgIHZhciBmaXJzdEVsID0gbGlzdFtzdGFydF07XG5cbiAgICAgICAgaWYgKCFmaXJzdEVsLmluY3JlbWVudGFsIHx8ICFmaXJzdEVsLm5vdENsZWFyIHx8IHBhaW50QWxsKSB7XG4gICAgICAgICAgbGF5ZXIuY2xlYXIoZmFsc2UsIGNsZWFyQ29sb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRm9yIHNvbWUgdW5rbm93biByZWFzb24uIGRyYXdJbmRleCBpcyAtMScpO1xuICAgICAgICBzdGFydCA9IGxheWVyLl9fc3RhcnRJbmRleDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGF5ZXIuX19lbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBsYXllciwgcGFpbnRBbGwsIHNjb3BlKTtcblxuICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHVzZVRpbWVyKSB7XG4gICAgICAgICAgLy8gRGF0ZS5ub3cgY2FuIGJlIGV4ZWN1dGVkIGluIDEzLDAyNSwzMDUgb3BzL3NlY29uZC5cbiAgICAgICAgICB2YXIgZFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lOyAvLyBHaXZlIDE1IG1pbGxpc2Vjb25kIHRvIGRyYXcuXG4gICAgICAgICAgLy8gVGhlIHJlc3QgZWxlbWVudHMgd2lsbCBiZSBkcmF3biBpbiB0aGUgbmV4dCBmcmFtZS5cblxuICAgICAgICAgIGlmIChkVGltZSA+IDE1KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGF5ZXIuX19kcmF3SW5kZXggPSBpO1xuXG4gICAgICBpZiAobGF5ZXIuX19kcmF3SW5kZXggPCBsYXllci5fX2VuZEluZGV4KSB7XG4gICAgICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgLy8gTmVlZHMgcmVzdG9yZSB0aGUgc3RhdGUuIElmIGxhc3QgZHJhd24gZWxlbWVudCBpcyBpbiB0aGUgY2xpcHBpbmcgYXJlYS5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpZiAoZW52Lnd4YSkge1xuICAgICAgLy8gRmx1c2ggZm9yIHdlaXhpbiBhcHBsaWNhdGlvblxuICAgICAgdXRpbC5lYWNoKHRoaXMuX2xheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmIChsYXllciAmJiBsYXllci5jdHggJiYgbGF5ZXIuY3R4LmRyYXcpIHtcbiAgICAgICAgICBsYXllci5jdHguZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluaXNoZWQ7XG4gIH0sXG4gIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgIHZhciBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuXG4gICAgaWYgKChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KSAmJiAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAhZWwuaW52aXNpYmxlIC8vIElnbm9yZSB0cmFuc3BhcmVudCBlbGVtZW50XG4gICAgJiYgZWwuc3R5bGUub3BhY2l0eSAhPT0gMCAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKSAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpKSB7XG4gICAgICB2YXIgY2xpcFBhdGhzID0gZWwuX19jbGlwUGF0aHM7IC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghc2NvcGUucHJldkVsQ2xpcFBhdGhzIHx8IGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgc2NvcGUucHJldkVsQ2xpcFBhdGhzKSkge1xuICAgICAgICAvLyBJZiBoYXMgcHJldmlvdXMgY2xpcHBpbmcgc3RhdGUsIHJlc3RvcmUgZnJvbSBpdFxuICAgICAgICBpZiAoc2NvcGUucHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgICAgY3VycmVudExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgc2NvcGUucHJldkVsQ2xpcFBhdGhzID0gbnVsbDsgLy8gUmVzZXQgcHJldkVsIHNpbmNlIGNvbnRleHQgaGFzIGJlZW4gcmVzdG9yZWRcblxuICAgICAgICAgIHNjb3BlLnByZXZFbCA9IG51bGw7XG4gICAgICAgIH0gLy8gTmV3IGNsaXBwaW5nIHN0YXRlXG5cblxuICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpO1xuICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICBzY29wZS5wcmV2RWwgPSBlbDtcbiAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaChjdHgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZpcnR1YWwgVmlydHVhbCBsYXllciB3aWxsIG5vdCBiZSBpbnNlcnRlZCBpbnRvIGRvbS5cbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAqL1xuICBnZXRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgdmlydHVhbCkge1xuICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMgJiYgIXRoaXMuX25lZWRzTWFudWFsbHlDb21wb3NpdGluZykge1xuICAgICAgemxldmVsID0gQ0FOVkFTX1pMRVZFTDtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgIGxheWVyLnpsZXZlbCA9IHpsZXZlbDtcbiAgICAgIGxheWVyLl9fYnVpbHRpbl9fID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICAgIGxheWVyLnZpcnR1YWwgPSB2aXJ0dWFsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluc2VydExheWVyKHpsZXZlbCwgbGF5ZXIpOyAvLyBDb250ZXh0IGlzIGNyZWF0ZWQgYWZ0ZXIgZG9tIGluc2VydGVkIHRvIGRvY3VtZW50XG4gICAgICAvLyBPciBleGNhbnZhcyB3aWxsIGdldCAwcHggY2xpZW50V2lkdGggYW5kIGNsaWVudEhlaWdodFxuXG4gICAgICBsYXllci5pbml0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllcjtcbiAgfSxcbiAgaW5zZXJ0TGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGxheWVyKSB7XG4gICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxlbiA9IHpsZXZlbExpc3QubGVuZ3RoO1xuICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290O1xuXG4gICAgaWYgKGxheWVyc01hcFt6bGV2ZWxdKSB7XG4gICAgICBsb2coJ1pMZXZlbCAnICsgemxldmVsICsgJyBoYXMgYmVlbiB1c2VkIGFscmVhZHknKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENoZWNrIGlmIGlzIGEgdmFsaWQgbGF5ZXJcblxuXG4gICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICBsb2coJ0xheWVyIG9mIHpsZXZlbCAnICsgemxldmVsICsgJyBpcyBub3QgdmFsaWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuID4gMCAmJiB6bGV2ZWwgPiB6bGV2ZWxMaXN0WzBdKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmICh6bGV2ZWxMaXN0W2ldIDwgemxldmVsICYmIHpsZXZlbExpc3RbaSArIDFdID4gemxldmVsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldkxheWVyID0gbGF5ZXJzTWFwW3psZXZlbExpc3RbaV1dO1xuICAgIH1cblxuICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuICAgIGxheWVyc01hcFt6bGV2ZWxdID0gbGF5ZXI7IC8vIFZpdHVhbCBsYXllciB3aWxsIG5vdCBkaXJlY3RseSBzaG93IG9uIHRoZSBzY3JlZW4uXG4gICAgLy8gKEl0IGNhbiBiZSBhIFdlYkdMIGxheWVyIGFuZCBhc3NpZ25lZCB0byBhIFpJbWFnZSBlbGVtZW50KVxuICAgIC8vIEJ1dCBpdCBzdGlsbCB1bmRlciBtYW5hZ2VtZW50IG9mIHpyZW5kZXIuXG5cbiAgICBpZiAoIWxheWVyLnZpcnR1YWwpIHtcbiAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgdmFyIHByZXZEb20gPSBwcmV2TGF5ZXIuZG9tO1xuXG4gICAgICAgIGlmIChwcmV2RG9tLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUobGF5ZXIuZG9tLCBwcmV2RG9tLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkb21Sb290LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIGRvbVJvb3QuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBJdGVyYXRlIGVhY2ggbGF5ZXJcbiAgZWFjaExheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1t6XSwgeik7XG4gICAgfVxuICB9LFxuICAvLyBJdGVyYXRlIGVhY2ggYnVpbGRpbiBsYXllclxuICBlYWNoQnVpbHRpbkxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBvdGhlciBsYXllciBleGNlcHQgYnVpbGRpbiBsYXllclxuICBlYWNoT3RoZXJMYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllcjtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W5omA5pyJ5bey5Yib5bu655qE5bGCXG4gICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0xheWVyPn0gW3ByZXZMYXllcl1cbiAgICovXG4gIGdldExheWVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXllcnM7XG4gIH0sXG4gIF91cGRhdGVMYXllclN0YXR1czogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBsYXllci5fX2RpcnR5ID0gbGF5ZXIuX191c2VkID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQcmV2TGF5ZXIoaWR4KSB7XG4gICAgICBpZiAocHJldkxheWVyKSB7XG4gICAgICAgIGlmIChwcmV2TGF5ZXIuX19lbmRJbmRleCAhPT0gaWR4KSB7XG4gICAgICAgICAgcHJldkxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkxheWVyLl9fZW5kSW5kZXggPSBpZHg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG5cbiAgICAgICAgaWYgKGVsLnpsZXZlbCAhPT0gbGlzdFtpIC0gMV0uemxldmVsIHx8IGVsLmluY3JlbWVudGFsKSB7XG4gICAgICAgICAgdGhpcy5fbmVlZHNNYW51YWxseUNvbXBvc2l0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgIHZhciBpbmNyZW1lbnRhbExheWVyQ291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuICAgICAgdmFyIHpsZXZlbCA9IGVsLnpsZXZlbDtcbiAgICAgIHZhciBsYXllcjsgLy8gUEVORElORyBJZiBjaGFuZ2Ugb25lIGluY3JlbWVudGFsIGVsZW1lbnQgc3R5bGUgP1xuICAgICAgLy8gVE9ETyBXaGVyZSB0aGVyZSBhcmUgbm9uLWluY3JlbWVudGFsIGVsZW1lbnRzIGJldHdlZW4gaW5jcmVtZW50YWwgZWxlbWVudHMuXG5cbiAgICAgIGlmIChlbC5pbmNyZW1lbnRhbCkge1xuICAgICAgICBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoemxldmVsICsgSU5DUkVNRU5UQUxfSU5DLCB0aGlzLl9uZWVkc01hbnVhbGx5Q29tcG9zaXRpbmcpO1xuICAgICAgICBsYXllci5pbmNyZW1lbnRhbCA9IHRydWU7XG4gICAgICAgIGluY3JlbWVudGFsTGF5ZXJDb3VudCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoemxldmVsICsgKGluY3JlbWVudGFsTGF5ZXJDb3VudCA+IDAgPyBFTF9BRlRFUl9JTkNSRU1FTlRBTF9JTkMgOiAwKSwgdGhpcy5fbmVlZHNNYW51YWxseUNvbXBvc2l0aW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICBsb2coJ1pMZXZlbCAnICsgemxldmVsICsgJyBoYXMgYmVlbiB1c2VkIGJ5IHVua293biBsYXllciAnICsgbGF5ZXIuaWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIgIT09IHByZXZMYXllcikge1xuICAgICAgICBsYXllci5fX3VzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChsYXllci5fX3N0YXJ0SW5kZXggIT09IGkpIHtcbiAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheWVyLl9fc3RhcnRJbmRleCA9IGk7XG5cbiAgICAgICAgaWYgKCFsYXllci5pbmNyZW1lbnRhbCkge1xuICAgICAgICAgIGxheWVyLl9fZHJhd0luZGV4ID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNYXJrIGxheWVyIGRyYXcgaW5kZXggbmVlZHMgdG8gdXBkYXRlLlxuICAgICAgICAgIGxheWVyLl9fZHJhd0luZGV4ID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVQcmV2TGF5ZXIoaSk7XG4gICAgICAgIHByZXZMYXllciA9IGxheWVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICBpZiAobGF5ZXIuaW5jcmVtZW50YWwgJiYgbGF5ZXIuX19kcmF3SW5kZXggPCAwKSB7XG4gICAgICAgICAgLy8gU3RhcnQgZHJhdyBmcm9tIHRoZSBmaXJzdCBkaXJ0eSBlbGVtZW50LlxuICAgICAgICAgIGxheWVyLl9fZHJhd0luZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVByZXZMYXllcihpKTtcbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAvLyBVc2VkIGluIGxhc3QgZnJhbWUgYnV0IG5vdCBpbiB0aGlzIGZyYW1lLiBOZWVkcyBjbGVhclxuICAgICAgaWYgKCFsYXllci5fX3VzZWQgJiYgbGF5ZXIuZ2V0RWxlbWVudENvdW50KCkgPiAwKSB7XG4gICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICBsYXllci5fX3N0YXJ0SW5kZXggPSBsYXllci5fX2VuZEluZGV4ID0gbGF5ZXIuX19kcmF3SW5kZXggPSAwO1xuICAgICAgfSAvLyBGb3IgaW5jcmVtZW50YWwgbGF5ZXIuIEluIGNhc2Ugc3RhcnQgaW5kZXggY2hhbmdlZCBhbmQgbm8gZWxlbWVudHMgYXJlIGRpcnR5LlxuXG5cbiAgICAgIGlmIChsYXllci5fX2RpcnR5ICYmIGxheWVyLl9fZHJhd0luZGV4IDwgMCkge1xuICAgICAgICBsYXllci5fX2RyYXdJbmRleCA9IGxheWVyLl9fc3RhcnRJbmRleDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICog5riF6ZmkaG92ZXLlsYLlpJbmiYDmnInlhoXlrrlcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY2xlYXJMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfSxcbiAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICB9LFxuXG4gIC8qKlxuICAgKiDkv67mlLnmjIflrpp6bGV2ZWznmoTnu5jliLblj4LmlbBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpsZXZlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIOmFjee9ruWvueixoVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XVxuICAgKiAgICAgICAgICAgICAgICAg5Zyo5byA5ZCv5Yqo5oCB5qih57OK55qE5pe25YCZ5L2/55So77yM5LiO5LiK5LiA5bin5re35ZCI55qEYWxwaGHlgLzvvIzlgLzotorlpKflsL7ov7notormmI7mmL5cbiAgICovXG4gIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoemxldmVsLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICB2YXIgbGF5ZXJDb25maWcgPSB0aGlzLl9sYXllckNvbmZpZztcblxuICAgICAgaWYgKCFsYXllckNvbmZpZ1t6bGV2ZWxdKSB7XG4gICAgICAgIGxheWVyQ29uZmlnW3psZXZlbF0gPSBjb25maWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlsLm1lcmdlKGxheWVyQ29uZmlnW3psZXZlbF0sIGNvbmZpZywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5femxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX3psZXZlbCA9IHRoaXMuX3psZXZlbExpc3RbaV07XG5cbiAgICAgICAgaWYgKF96bGV2ZWwgPT09IHpsZXZlbCB8fCBfemxldmVsID09PSB6bGV2ZWwgKyBFTF9BRlRFUl9JTkNSRU1FTlRBTF9JTkMpIHtcbiAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbX3psZXZlbF07XG4gICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOaMh+WumuWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsIOWxguaJgOWcqOeahHpsZXZlbFxuICAgKi9cbiAgZGVsTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXllci5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsYXllci5kb20pO1xuICAgIGRlbGV0ZSBsYXllcnNbemxldmVsXTtcbiAgICB6bGV2ZWxMaXN0LnNwbGljZSh1dGlsLmluZGV4T2YoemxldmVsTGlzdCwgemxldmVsKSwgMSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWMuuWfn+Wkp+Wwj+WPmOWMluWQjumHjee7mFxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghdGhpcy5fZG9tUm9vdC5zdHlsZSkge1xuICAgICAgLy8gTWF5YmUgaW4gbm9kZSBvciB3b3JrZXJcbiAgICAgIGlmICh3aWR0aCA9PSBudWxsIHx8IGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuZ2V0TGF5ZXIoQ0FOVkFTX1pMRVZFTCkucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7IC8vIEZJWE1FIFdoeSA/XG5cbiAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gU2F2ZSBpbnB1dCB3L2hcblxuICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgICAgd2lkdGggIT0gbnVsbCAmJiAob3B0cy53aWR0aCA9IHdpZHRoKTtcbiAgICAgIGhlaWdodCAhPSBudWxsICYmIChvcHRzLmhlaWdodCA9IGhlaWdodCk7XG4gICAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgICBoZWlnaHQgPSB0aGlzLl9nZXRTaXplKDEpO1xuICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJyc7IC8vIOS8mOWMluayoeacieWunumZheaUueWPmOeahHJlc2l6ZVxuXG4gICAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuICAgICAgICBkb21Sb290LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBkb21Sb290LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xheWVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgbGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXpmaTljZXni6znmoTkuIDkuKrlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgKi9cbiAgY2xlYXJMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci5jbGVhcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6YeK5pS+XG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuc3RvcmFnZSA9IHRoaXMuX2RvbVJvb3QgPSB0aGlzLl9sYXllcnMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnBpeGVsUmF0aW9dXG4gICAqL1xuICBnZXRSZW5kZXJlZENhbnZhczogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMgJiYgIXRoaXMuX2NvbXBvc2l0ZU1hbnVhbGx5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzW0NBTlZBU19aTEVWRUxdLmRvbTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VMYXllciA9IG5ldyBMYXllcignaW1hZ2UnLCB0aGlzLCBvcHRzLnBpeGVsUmF0aW8gfHwgdGhpcy5kcHIpO1xuICAgIGltYWdlTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICBpbWFnZUxheWVyLmNsZWFyKGZhbHNlLCBvcHRzLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IpO1xuXG4gICAgaWYgKG9wdHMucGl4ZWxSYXRpbyA8PSB0aGlzLmRwcikge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICB2YXIgd2lkdGggPSBpbWFnZUxheWVyLmRvbS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBpbWFnZUxheWVyLmRvbS5oZWlnaHQ7XG4gICAgICB2YXIgY3R4ID0gaW1hZ2VMYXllci5jdHg7XG4gICAgICB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShsYXllci5kb20sIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGxheWVyLnJlbmRlclRvQ2FudmFzKSB7XG4gICAgICAgICAgaW1hZ2VMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgIGxheWVyLnJlbmRlclRvQ2FudmFzKGltYWdlTGF5ZXIuY3R4KTtcbiAgICAgICAgICBpbWFnZUxheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQRU5ESU5HLCBlY2hhcnRzLWdsIGFuZCBpbmNyZW1lbnRhbCByZW5kZXJpbmcuXG4gICAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWwgPSBkaXNwbGF5TGlzdFtpXTtcblxuICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGltYWdlTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VMYXllci5kb207XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPlue7mOWbvuWMuuWfn+WuveW6plxuICAgKi9cbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPlue7mOWbvuWMuuWfn+mrmOW6plxuICAgKi9cbiAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfSxcbiAgX2dldFNpemU6IGZ1bmN0aW9uICh3aElkeCkge1xuICAgIHZhciBvcHRzID0gdGhpcy5fb3B0cztcbiAgICB2YXIgd2ggPSBbJ3dpZHRoJywgJ2hlaWdodCddW3doSWR4XTtcbiAgICB2YXIgY3doID0gWydjbGllbnRXaWR0aCcsICdjbGllbnRIZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIHBsdCA9IFsncGFkZGluZ0xlZnQnLCAncGFkZGluZ1RvcCddW3doSWR4XTtcbiAgICB2YXIgcHJiID0gWydwYWRkaW5nUmlnaHQnLCAncGFkZGluZ0JvdHRvbSddW3doSWR4XTtcblxuICAgIGlmIChvcHRzW3doXSAhPSBudWxsICYmIG9wdHNbd2hdICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KG9wdHNbd2hdKTtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDsgLy8gSUU4IGRvZXMgbm90IHN1cHBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSwgYnV0IGl0IHVzZSBWTUwuXG5cbiAgICB2YXIgc3RsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcbiAgICByZXR1cm4gKHJvb3RbY3doXSB8fCBwYXJzZUludDEwKHN0bFt3aF0pIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZVt3aF0pKSAtIChwYXJzZUludDEwKHN0bFtwbHRdKSB8fCAwKSAtIChwYXJzZUludDEwKHN0bFtwcmJdKSB8fCAwKSB8IDA7XG4gIH0sXG4gIHBhdGhUb0ltYWdlOiBmdW5jdGlvbiAocGF0aCwgZHByKSB7XG4gICAgZHByID0gZHByIHx8IHRoaXMuZHByO1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIHJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHBhdGguc3R5bGU7XG4gICAgdmFyIHNoYWRvd0JsdXJTaXplID0gc3R5bGUuc2hhZG93Qmx1ciAqIGRwcjtcbiAgICB2YXIgc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFggKiBkcHI7XG4gICAgdmFyIHNoYWRvd09mZnNldFkgPSBzdHlsZS5zaGFkb3dPZmZzZXRZICogZHByO1xuICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5oYXNTdHJva2UoKSA/IHN0eWxlLmxpbmVXaWR0aCA6IDA7XG4gICAgdmFyIGxlZnRNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCAtc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgcmlnaHRNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCBzaGFkb3dPZmZzZXRYICsgc2hhZG93Qmx1clNpemUpO1xuICAgIHZhciB0b3BNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCAtc2hhZG93T2Zmc2V0WSArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgYm90dG9tTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WSArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoICsgbGVmdE1hcmdpbiArIHJpZ2h0TWFyZ2luO1xuICAgIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodCArIHRvcE1hcmdpbiArIGJvdHRvbU1hcmdpbjtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjdHguZHByID0gZHByO1xuICAgIHZhciBwYXRoVHJhbnNmb3JtID0ge1xuICAgICAgcG9zaXRpb246IHBhdGgucG9zaXRpb24sXG4gICAgICByb3RhdGlvbjogcGF0aC5yb3RhdGlvbixcbiAgICAgIHNjYWxlOiBwYXRoLnNjYWxlXG4gICAgfTtcbiAgICBwYXRoLnBvc2l0aW9uID0gW2xlZnRNYXJnaW4gLSByZWN0LngsIHRvcE1hcmdpbiAtIHJlY3QueV07XG4gICAgcGF0aC5yb3RhdGlvbiA9IDA7XG4gICAgcGF0aC5zY2FsZSA9IFsxLCAxXTtcbiAgICBwYXRoLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhdGguYnJ1c2goY3R4KTtcbiAgICB9XG5cbiAgICB2YXIgSW1hZ2VTaGFwZSA9IEltYWdlO1xuICAgIHZhciBpbWdTaGFwZSA9IG5ldyBJbWFnZVNoYXBlKHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIGltYWdlOiBjYW52YXNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnBvc2l0aW9uID0gcGF0aC5wb3NpdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgfVxuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0ucm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUucm90YXRpb24gPSBwYXRoLnJvdGF0aW9uID0gcGF0aFRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5zY2FsZSAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5zY2FsZSA9IHBhdGguc2NhbGUgPSBwYXRoVHJhbnNmb3JtLnNjYWxlO1xuICAgIH1cblxuICAgIHJldHVybiBpbWdTaGFwZTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFBhaW50ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL1BhaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL1BhaW50ZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuL2NvcmUvZW52XCIpO1xuXG52YXIgR3JvdXAgPSByZXF1aXJlKFwiLi9jb250YWluZXIvR3JvdXBcIik7XG5cbnZhciB0aW1zb3J0ID0gcmVxdWlyZShcIi4vY29yZS90aW1zb3J0XCIpO1xuXG4vLyBVc2UgdGltc29ydCBiZWNhdXNlIGluIG1vc3QgY2FzZSBlbGVtZW50cyBhcmUgcGFydGlhbGx5IHNvcnRlZFxuLy8gaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcGlzc2FuZy9qcjR4N21kbS84L1xuZnVuY3Rpb24gc2hhcGVDb21wYXJlRnVuYyhhLCBiKSB7XG4gIGlmIChhLnpsZXZlbCA9PT0gYi56bGV2ZWwpIHtcbiAgICBpZiAoYS56ID09PSBiLnopIHtcbiAgICAgIC8vIGlmIChhLnoyID09PSBiLnoyKSB7XG4gICAgICAvLyAgICAgLy8gRklYTUUgU2xvdyBoYXMgcmVuZGVyaWR4IGNvbXBhcmVcbiAgICAgIC8vICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwODgzNDIxL3NvcnRpbmctaW4tamF2YXNjcmlwdC1zaG91bGQtZXZlcnktY29tcGFyZS1mdW5jdGlvbi1oYXZlLWEtcmV0dXJuLTAtc3RhdGVtZW50XG4gICAgICAvLyAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNDdjY2U1NDRhMzFlZDU1NzdmZmUyOTYzZjY3YWNiNDE0NGVlMDIzMi9zcmMvanMvYXJyYXkuanMjTDEwMTJcbiAgICAgIC8vICAgICByZXR1cm4gYS5fX3JlbmRlcmlkeCAtIGIuX19yZW5kZXJpZHg7XG4gICAgICAvLyB9XG4gICAgICByZXR1cm4gYS56MiAtIGIuejI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEueiAtIGIuejtcbiAgfVxuXG4gIHJldHVybiBhLnpsZXZlbCAtIGIuemxldmVsO1xufVxuLyoqXG4gKiDlhoXlrrnku5PlupMgKE0pXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvU3RvcmFnZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIHRoaXMuX3Jvb3RzID0gW107XG4gIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbn07XG5cblN0b3JhZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU3RvcmFnZSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqXG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcm9vdHNbaV0udHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6L+U5Zue5omA5pyJ5Zu+5b2i55qE57uY5Yi26Zif5YiXXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZT1mYWxzZV0g5piv5ZCm5Zyo6L+U5Zue5YmN5pu05paw6K+l5pWw57uEXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uELCDlnKggdXBkYXRlIOS4uiB0cnVlIOeahOaXtuWAmeacieaViFxuICAgKlxuICAgKiDor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5wcm90b3R5cGUudXBkYXRlRGlzcGxheUxpc3R9XG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlPn1cbiAgICovXG4gIGdldERpc3BsYXlMaXN0OiBmdW5jdGlvbiAodXBkYXRlLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZURpc3BsYXlMaXN0KGluY2x1ZGVJZ25vcmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgfSxcblxuICAvKipcbiAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAqL1xuICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgdmFyIHJvb3RzID0gdGhpcy5fcm9vdHM7XG4gICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKHJvb3RzW2ldLCBudWxsLCBpbmNsdWRlSWdub3JlKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjtcbiAgICBlbnYuY2FudmFzU3VwcG9ydGVkICYmIHRpbXNvcnQoZGlzcGxheUxpc3QsIHNoYXBlQ29tcGFyZUZ1bmMpO1xuICB9LFxuICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgaWYgKGVsLmlnbm9yZSAmJiAhaW5jbHVkZUlnbm9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgIGVsLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGVsLmFmdGVyVXBkYXRlKCk7XG4gICAgdmFyIHVzZXJTZXRDbGlwUGF0aCA9IGVsLmNsaXBQYXRoO1xuXG4gICAgaWYgKHVzZXJTZXRDbGlwUGF0aCkge1xuICAgICAgLy8gRklYTUUg5pWI546H5b2x5ZONXG4gICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpcFBhdGhzID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50Q2xpcFBhdGggPSB1c2VyU2V0Q2xpcFBhdGg7XG4gICAgICB2YXIgcGFyZW50Q2xpcFBhdGggPSBlbDsgLy8gUmVjdXJzaXZlbHkgYWRkIGNsaXAgcGF0aFxuXG4gICAgICB3aGlsZSAoY3VycmVudENsaXBQYXRoKSB7XG4gICAgICAgIC8vIGNsaXBQYXRoIOeahOWPmOaNouaYr+WfuuS6juS9v+eUqOi/meS4qiBjbGlwUGF0aCDnmoTlhYPntKBcbiAgICAgICAgY3VycmVudENsaXBQYXRoLnBhcmVudCA9IHBhcmVudENsaXBQYXRoO1xuICAgICAgICBjdXJyZW50Q2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIGNsaXBQYXRocy5wdXNoKGN1cnJlbnRDbGlwUGF0aCk7XG4gICAgICAgIHBhcmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoO1xuICAgICAgICBjdXJyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGguY2xpcFBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTsgLy8gRm9yY2UgdG8gbWFyayBhcyBkaXJ0eSBpZiBncm91cCBpcyBkaXJ0eVxuICAgICAgICAvLyBGSVhNRSBfX2RpcnR5UGF0aCA/XG5cbiAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICBjaGlsZC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKGNoaWxkLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgfSAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcblxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXAp5Yiw5qC56IqC54K5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIGFkZFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC5fX3N0b3JhZ2UgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgZWwuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2UodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRUb1N0b3JhZ2UoZWwpO1xuXG4gICAgdGhpcy5fcm9vdHMucHVzaChlbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOaMh+WumueahOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXApXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbZWxdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICovXG4gIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCA9PSBudWxsKSB7XG4gICAgICAvLyDkuI3mjIflrpplbOa4heepulxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3RzW2ldO1xuXG4gICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICByb290LmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVsUm9vdChlbFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKHRoaXMuX3Jvb3RzLCBlbCk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuZGVsRnJvbVN0b3JhZ2UoZWwpO1xuXG4gICAgICB0aGlzLl9yb290cy5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFkZFRvU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgICAgZWwuZGlydHkoZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkZWxGcm9tU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXnqbrlubbkuJTph4rmlL5TdG9yYWdlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyTGlzdCA9IHRoaXMuX3Jvb3RzID0gbnVsbDtcbiAgfSxcbiAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xufTtcbnZhciBfZGVmYXVsdCA9IFN0b3JhZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL1N0b3JhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL1N0b3JhZ2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfZXZlbnQgPSByZXF1aXJlKFwiLi4vY29yZS9ldmVudFwiKTtcblxudmFyIERpc3BhdGNoZXIgPSBfZXZlbnQuRGlzcGF0Y2hlcjtcblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RBbmltYXRpb25GcmFtZVwiKTtcblxudmFyIEFuaW1hdG9yID0gcmVxdWlyZShcIi4vQW5pbWF0b3JcIik7XG5cbi8qKlxuICog5Yqo55S75Li757G7LCDosIPluqblkoznrqHnkIbmiYDmnInliqjnlLvmjqfliLblmahcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIEFkZGl0aXZlIGFuaW1hdGlvblxuLy8gaHR0cDovL2lvc290ZXJpYy5jb20vYWRkaXRpdmUtYW5pbWF0aW9ucy1hbmltYXRld2l0aGR1cmF0aW9uLWluLWlvcy04L1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy93d2RjMjAxNC8jMjM2XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSVpSZW5kZXJTdGFnZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICogQHBhcmFtIHtJWlJlbmRlclN0YWdlfSBbb3B0aW9ucy5zdGFnZV1cbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgIHk6IDEwMFxuICogICAgIH07XG4gKiAgICAgYW5pbWF0aW9uLmFuaW1hdGUobm9kZS5wb3NpdGlvbilcbiAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICogICAgICAgICAgICAgeDogNTAwLFxuICogICAgICAgICAgICAgeTogNTAwXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC53aGVuKDIwMDAsIHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMFxuICogICAgICAgICB9KVxuICogICAgICAgICAuc3RhcnQoJ3NwbGluZScpO1xuICovXG52YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuc3RhZ2UgPSBvcHRpb25zLnN0YWdlIHx8IHt9O1xuXG4gIHRoaXMub25mcmFtZSA9IG9wdGlvbnMub25mcmFtZSB8fCBmdW5jdGlvbiAoKSB7fTsgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cblxuICB0aGlzLl9jbGlwcyA9IFtdO1xuICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gIHRoaXMuX3RpbWU7XG4gIHRoaXMuX3BhdXNlZFRpbWU7XG4gIHRoaXMuX3BhdXNlU3RhcnQ7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICBEaXNwYXRjaGVyLmNhbGwodGhpcyk7XG59O1xuXG5BbmltYXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuXG4gIC8qKlxuICAgKiDmt7vliqAgY2xpcFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAqL1xuICBhZGRDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoCBhbmltYXRvclxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICovXG4gIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICovXG4gIHJlbW92ZUNsaXA6IGZ1bmN0aW9uIChjbGlwKSB7XG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuX2NsaXBzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgKi9cbiAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgIH1cblxuICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gIH0sXG4gIF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VkVGltZTtcblxuICAgIHZhciBkZWx0YSA9IHRpbWUgLSB0aGlzLl90aW1lO1xuICAgIHZhciBjbGlwcyA9IHRoaXMuX2NsaXBzO1xuICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG4gICAgdmFyIGRlZmVycmVkRXZlbnRzID0gW107XG4gICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjbGlwID0gY2xpcHNbaV07XG4gICAgICB2YXIgZSA9IGNsaXAuc3RlcCh0aW1lLCBkZWx0YSk7IC8vIFRocm93IG91dCB0aGUgZXZlbnRzIG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyXG4gICAgICAvLyBzdGFnZS51cGRhdGUsIGxpa2UgZGVzdHJveVxuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBkZWZlcnJlZEV2ZW50cy5wdXNoKGUpO1xuICAgICAgICBkZWZlcnJlZENsaXBzLnB1c2goY2xpcCk7XG4gICAgICB9XG4gICAgfSAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGNsaXBcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgIGNsaXBzW2ldID0gY2xpcHNbbGVuIC0gMV07XG4gICAgICAgIGNsaXBzLnBvcCgpO1xuICAgICAgICBsZW4tLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSBkZWZlcnJlZEV2ZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZWZlcnJlZENsaXBzW2ldLmZpcmUoZGVmZXJyZWRFdmVudHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHRoaXMub25mcmFtZShkZWx0YSk7IC8vICdmcmFtZScgc2hvdWxkIGJlIHRyaWdnZXJlZCBiZWZvcmUgc3RhZ2UsIGJlY2F1c2UgdXBwZXIgYXBwbGljYXRpb25cbiAgICAvLyBkZXBlbmRzIG9uIHRoZSBzZXF1ZW5jZSAoZS5nLiwgZWNoYXJ0cy1zdHJlYW0gYW5kIGZpbmlzaFxuICAgIC8vIGV2ZW50IGp1ZGdlKVxuXG4gICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgIGlmICh0aGlzLnN0YWdlLnVwZGF0ZSkge1xuICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICB9XG4gIH0sXG4gIF9zdGFydExvb3A6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAhc2VsZi5fcGF1c2VkICYmIHNlbGYuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uLlxuICAgKi9cbiAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICB0aGlzLl9zdGFydExvb3AoKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBhbmltYXRpb24uXG4gICAqL1xuICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXVzZSBhbmltYXRpb24uXG4gICAqL1xuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzdW1lIGFuaW1hdGlvbi5cbiAgICovXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgIHRoaXMuX3BhdXNlZFRpbWUgKz0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9wYXVzZVN0YXJ0O1xuICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhciBhbmltYXRpb24uXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsaXBzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgYW5pbWF0aW9uIGZpbmlzaGVkLlxuICAgKi9cbiAgaXNGaW5pc2hlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5fY2xpcHMubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdCBhbmltYXRvciBmb3IgYSB0YXJnZXQsIHdob3NlIHByb3BzIGNhbiBiZSBhbmltYXRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmxvb3A9ZmFsc2VdIFdoZXRoZXIgbG9vcCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZXR0ZXI9bnVsbF0gR2V0IHZhbHVlIGZyb20gdGFyZ2V0LlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuc2V0dGVyPW51bGxdIFNldCB2YWx1ZSB0byB0YXJnZXQuXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25+QW5pbWF0b3J9XG4gICAqL1xuICAvLyBUT0RPIEdhcFxuICBhbmltYXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgb3B0aW9ucy5sb29wLCBvcHRpb25zLmdldHRlciwgb3B0aW9ucy5zZXR0ZXIpO1xuICAgIHRoaXMuYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfVxufTtcbnV0aWwubWl4aW4oQW5pbWF0aW9uLCBEaXNwYXRjaGVyKTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBDbGlwID0gcmVxdWlyZShcIi4vQ2xpcFwiKTtcblxudmFyIGNvbG9yID0gcmVxdWlyZShcIi4uL3Rvb2wvY29sb3JcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc0FycmF5TGlrZSA9IF91dGlsLmlzQXJyYXlMaWtlO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xudmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIHRhcmdldFtrZXldO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGVyKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICB0YXJnZXRba2V5XSA9IHZhbHVlO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKHAwLCBwMSwgcGVyY2VudCkge1xuICByZXR1cm4gKHAxIC0gcDApICogcGVyY2VudCArIHAwO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHAwXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlU3RyaW5nKHAwLCBwMSwgcGVyY2VudCkge1xuICByZXR1cm4gcGVyY2VudCA+IDAuNSA/IHAxIDogcDA7XG59XG4vKipcbiAqIEBwYXJhbSAge0FycmF5fSBwMFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcblxuICBpZiAoYXJyRGltID09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBpbnRlcnBvbGF0ZU51bWJlcihwMFtpXSwgcDFbaV0sIHBlcmNlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuMiA9IGxlbiAmJiBwMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBvdXRbaV1bal0gPSBpbnRlcnBvbGF0ZU51bWJlcihwMFtpXVtqXSwgcDFbaV1bal0sIHBlcmNlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBhcnIwIGlzIHNvdXJjZSBhcnJheSwgYXJyMSBpcyB0YXJnZXQgYXJyYXkuXG4vLyBEbyBzb21lIHByZXByb2Nlc3MgdG8gYXZvaWQgZXJyb3IgaGFwcGVuZWQgd2hlbiBpbnRlcnBvbGF0aW5nIGZyb20gYXJyMCB0byBhcnIxXG5cblxuZnVuY3Rpb24gZmlsbEFycihhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgdmFyIGFycjBMZW4gPSBhcnIwLmxlbmd0aDtcbiAgdmFyIGFycjFMZW4gPSBhcnIxLmxlbmd0aDtcblxuICBpZiAoYXJyMExlbiAhPT0gYXJyMUxlbikge1xuICAgIC8vIEZJWE1FIE5vdCB3b3JrIGZvciBUeXBlZEFycmF5XG4gICAgdmFyIGlzUHJldmlvdXNMYXJnZXIgPSBhcnIwTGVuID4gYXJyMUxlbjtcblxuICAgIGlmIChpc1ByZXZpb3VzTGFyZ2VyKSB7XG4gICAgICAvLyBDdXQgdGhlIHByZXZpb3VzXG4gICAgICBhcnIwLmxlbmd0aCA9IGFycjFMZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbGwgdGhlIHByZXZpb3VzXG4gICAgICBmb3IgKHZhciBpID0gYXJyMExlbjsgaSA8IGFycjFMZW47IGkrKykge1xuICAgICAgICBhcnIwLnB1c2goYXJyRGltID09PSAxID8gYXJyMVtpXSA6IGFycmF5U2xpY2UuY2FsbChhcnIxW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEhhbmRsaW5nIE5hTiB2YWx1ZVxuXG5cbiAgdmFyIGxlbjIgPSBhcnIwWzBdICYmIGFycjBbMF0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgIGlmIChpc05hTihhcnIwW2ldKSkge1xuICAgICAgICBhcnIwW2ldID0gYXJyMVtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgaWYgKGlzTmFOKGFycjBbaV1bal0pKSB7XG4gICAgICAgICAgYXJyMFtpXVtqXSA9IGFycjFbaV1bal07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtICB7QXJyYXl9IGFycjBcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlTYW1lKGFycjAsIGFycjEsIGFyckRpbSkge1xuICBpZiAoYXJyMCA9PT0gYXJyMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGxlbiA9IGFycjAubGVuZ3RoO1xuXG4gIGlmIChsZW4gIT09IGFycjEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnIwW2ldICE9PSBhcnIxW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBhcnIwWzBdLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIGlmIChhcnIwW2ldW2pdICE9PSBhcnIxW2ldW2pdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIGFycmF5XG4gKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAqIEBwYXJhbSAge0FycmF5fSBwMVxuICogQHBhcmFtICB7QXJyYXl9IHAyXG4gKiBAcGFyYW0gIHtBcnJheX0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMsIG91dCwgYXJyRGltKSB7XG4gIHZhciBsZW4gPSBwMC5sZW5ndGg7XG5cbiAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb3V0W2ldID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0LCB0MiwgdDMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuMiA9IHAwWzBdLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIG91dFtpXVtqXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMFtpXVtqXSwgcDFbaV1bal0sIHAyW2ldW2pdLCBwM1tpXVtqXSwgdCwgdDIsIHQzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgbnVtYmVyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbn1cblxuZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZVswXSkpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXQucHVzaChhcnJheVNsaWNlLmNhbGwodmFsdWVbaV0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmdiYTJTdHJpbmcocmdiYSkge1xuICByZ2JhWzBdID0gTWF0aC5mbG9vcihyZ2JhWzBdKTtcbiAgcmdiYVsxXSA9IE1hdGguZmxvb3IocmdiYVsxXSk7XG4gIHJnYmFbMl0gPSBNYXRoLmZsb29yKHJnYmFbMl0pO1xuICByZXR1cm4gJ3JnYmEoJyArIHJnYmEuam9pbignLCcpICsgJyknO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheURpbShrZXlmcmFtZXMpIHtcbiAgdmFyIGxhc3RWYWx1ZSA9IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0udmFsdWU7XG4gIHJldHVybiBpc0FycmF5TGlrZShsYXN0VmFsdWUgJiYgbGFzdFZhbHVlWzBdKSA/IDIgOiAxO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFja0NsaXAoYW5pbWF0b3IsIGVhc2luZywgb25lVHJhY2tEb25lLCBrZXlmcmFtZXMsIHByb3BOYW1lLCBmb3JjZUFuaW1hdGUpIHtcbiAgdmFyIGdldHRlciA9IGFuaW1hdG9yLl9nZXR0ZXI7XG4gIHZhciBzZXR0ZXIgPSBhbmltYXRvci5fc2V0dGVyO1xuICB2YXIgdXNlU3BsaW5lID0gZWFzaW5nID09PSAnc3BsaW5lJztcbiAgdmFyIHRyYWNrTGVuID0ga2V5ZnJhbWVzLmxlbmd0aDtcblxuICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIEd1ZXNzIGRhdGEgdHlwZVxuXG5cbiAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICB2YXIgaXNWYWx1ZUFycmF5ID0gaXNBcnJheUxpa2UoZmlyc3RWYWwpO1xuICB2YXIgaXNWYWx1ZUNvbG9yID0gZmFsc2U7XG4gIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7IC8vIEZvciB2ZXJ0aWNlcyBtb3JwaGluZ1xuXG4gIHZhciBhcnJEaW0gPSBpc1ZhbHVlQXJyYXkgPyBnZXRBcnJheURpbShrZXlmcmFtZXMpIDogMDtcbiAgdmFyIHRyYWNrTWF4VGltZTsgLy8gU29ydCBrZXlmcmFtZSBhcyBhc2NlbmRpbmdcblxuICBrZXlmcmFtZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gIH0pO1xuICB0cmFja01heFRpbWUgPSBrZXlmcmFtZXNbdHJhY2tMZW4gLSAxXS50aW1lOyAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG5cbiAgdmFyIGtmUGVyY2VudHMgPSBbXTsgLy8gVmFsdWUgb2YgZWFjaCBrZXlmcmFtZVxuXG4gIHZhciBrZlZhbHVlcyA9IFtdO1xuICB2YXIgcHJldlZhbHVlID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICB2YXIgaXNBbGxWYWx1ZUVxdWFsID0gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICBrZlBlcmNlbnRzLnB1c2goa2V5ZnJhbWVzW2ldLnRpbWUgLyB0cmFja01heFRpbWUpOyAvLyBBc3N1bWUgdmFsdWUgaXMgYSBjb2xvciB3aGVuIGl0IGlzIGEgc3RyaW5nXG5cbiAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7IC8vIENoZWNrIGlmIHZhbHVlIGlzIGVxdWFsLCBkZWVwIGNoZWNrIGlmIHZhbHVlIGlzIGFycmF5XG5cbiAgICBpZiAoIShpc1ZhbHVlQXJyYXkgJiYgaXNBcnJheVNhbWUodmFsdWUsIHByZXZWYWx1ZSwgYXJyRGltKSB8fCAhaXNWYWx1ZUFycmF5ICYmIHZhbHVlID09PSBwcmV2VmFsdWUpKSB7XG4gICAgICBpc0FsbFZhbHVlRXF1YWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTsgLy8gVHJ5IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBjb2xvciBhcnJheVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGNvbG9yQXJyYXkgPSBjb2xvci5wYXJzZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG5cbiAgaWYgKCFmb3JjZUFuaW1hdGUgJiYgaXNBbGxWYWx1ZUVxdWFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhc3RWYWx1ZSA9IGtmVmFsdWVzW3RyYWNrTGVuIC0gMV07IC8vIFBvbHlmaWxsIGFycmF5IGFuZCBOYU4gdmFsdWVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuIC0gMTsgaSsrKSB7XG4gICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgZmlsbEFycihrZlZhbHVlc1tpXSwgbGFzdFZhbHVlLCBhcnJEaW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNWYWx1ZUFycmF5ICYmIGZpbGxBcnIoZ2V0dGVyKGFuaW1hdG9yLl90YXJnZXQsIHByb3BOYW1lKSwgbGFzdFZhbHVlLCBhcnJEaW0pOyAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcblxuICB2YXIgbGFzdEZyYW1lID0gMDtcbiAgdmFyIGxhc3RGcmFtZVBlcmNlbnQgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciB3O1xuICB2YXIgcDA7XG4gIHZhciBwMTtcbiAgdmFyIHAyO1xuICB2YXIgcDM7XG5cbiAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICB9XG5cbiAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgLy8gRmluZCB0aGUgcmFuZ2Uga2V5ZnJhbWVzXG4gICAgLy8ga2YxLS0tLS1rZjItLS0tLS0tLS1jdXJyZW50LS0tLS0tLS1rZjNcbiAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgdmFyIGZyYW1lOyAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcblxuICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgZnJhbWUgPSAwO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudCA8IGxhc3RGcmFtZVBlcmNlbnQpIHtcbiAgICAgIC8vIFN0YXJ0IGZyb20gbmV4dCBrZXlcbiAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCB0cmFja0xlbiAtIDEpO1xuXG4gICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xuXG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIHRyYWNrTGVuIC0gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCB0cmFja0xlbiAtIDIpO1xuICAgIH1cblxuICAgIGxhc3RGcmFtZSA9IGZyYW1lO1xuICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuICAgIHZhciByYW5nZSA9IGtmUGVyY2VudHNbZnJhbWUgKyAxXSAtIGtmUGVyY2VudHNbZnJhbWVdO1xuXG4gICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSAocGVyY2VudCAtIGtmUGVyY2VudHNbZnJhbWVdKSAvIHJhbmdlO1xuICAgIH1cblxuICAgIGlmICh1c2VTcGxpbmUpIHtcbiAgICAgIHAxID0ga2ZWYWx1ZXNbZnJhbWVdO1xuICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgIHAyID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDIgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDFdO1xuICAgICAgcDMgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMyA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMl07XG5cbiAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSwgYXJyRGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdywgcmdiYSwgMSk7XG4gICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhwMSwgcDIsIHcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRlcih0YXJnZXQsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVBcnJheShrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSwgYXJyRGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsIHJnYmEsIDEpO1xuICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICB0YXJnZXQ6IGFuaW1hdG9yLl90YXJnZXQsXG4gICAgbGlmZTogdHJhY2tNYXhUaW1lLFxuICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgIGRlbGF5OiBhbmltYXRvci5fZGVsYXksXG4gICAgb25mcmFtZTogb25mcmFtZSxcbiAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICB9KTtcblxuICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICBjbGlwLmVhc2luZyA9IGVhc2luZztcbiAgfVxuXG4gIHJldHVybiBjbGlwO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAqL1xuXG5cbnZhciBBbmltYXRvciA9IGZ1bmN0aW9uICh0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gIHRoaXMuX3RyYWNrcyA9IHt9O1xuICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuX2xvb3AgPSBsb29wIHx8IGZhbHNlO1xuICB0aGlzLl9nZXR0ZXIgPSBnZXR0ZXIgfHwgZGVmYXVsdEdldHRlcjtcbiAgdGhpcy5fc2V0dGVyID0gc2V0dGVyIHx8IGRlZmF1bHRTZXR0ZXI7XG4gIHRoaXMuX2NsaXBDb3VudCA9IDA7XG4gIHRoaXMuX2RlbGF5ID0gMDtcbiAgdGhpcy5fZG9uZUxpc3QgPSBbXTtcbiAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcbiAgdGhpcy5fY2xpcExpc3QgPSBbXTtcbn07XG5cbkFuaW1hdG9yLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIOiuvue9ruWKqOeUu+WFs+mUruW4p1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5YWz6ZSu5bin5pe26Ze077yM5Y2V5L2N5pivbXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyDlhbPplK7luKfnmoTlsZ7mgKflgLzvvIxrZXktdmFsdWXooajnpLpcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgd2hlbjogZnVuY3Rpb24gKHRpbWVcbiAgLyogbXMgKi9cbiAgLCBwcm9wcykge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLl90cmFja3M7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHJhY2tzW3Byb3BOYW1lXSkge1xuICAgICAgICB0cmFja3NbcHJvcE5hbWVdID0gW107IC8vIEludmFsaWQgdmFsdWVcblxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXR0ZXIodGhpcy5fdGFyZ2V0LCBwcm9wTmFtZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAvLyB6ckxvZygnSW52YWxpZCBwcm9wZXJ0eSAnICsgcHJvcE5hbWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIElmIHRpbWUgaXMgMFxuICAgICAgICAvLyAgVGhlbiBwcm9wcyBpcyBnaXZlbiBpbml0aWFsaXplIHZhbHVlXG4gICAgICAgIC8vIEVsc2VcbiAgICAgICAgLy8gIEluaXRpYWxpemUgdmFsdWUgZnJvbSBjdXJyZW50IHByb3AgdmFsdWVcblxuXG4gICAgICAgIGlmICh0aW1lICE9PSAwKSB7XG4gICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICB2YWx1ZTogY2xvbmVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICB2YWx1ZTogcHJvcHNbcHJvcE5hbWVdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5Yqo55S75q+P5LiA5bin55qE5Zue6LCD5Ye95pWwXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkdXJpbmc6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuX29uZnJhbWVMaXN0LnB1c2goY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY2xpcExpc3RbaV0ucGF1c2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICB9LFxuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jbGlwTGlzdFtpXS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgfSxcbiAgaXNQYXVzZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9wYXVzZWQ7XG4gIH0sXG4gIF9kb25lQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDbGVhciBhbGwgdHJhY2tzXG4gICAgdGhpcy5fdHJhY2tzID0ge307IC8vIENsZWFyIGFsbCBjbGlwc1xuXG4gICAgdGhpcy5fY2xpcExpc3QubGVuZ3RoID0gMDtcbiAgICB2YXIgZG9uZUxpc3QgPSB0aGlzLl9kb25lTGlzdDtcbiAgICB2YXIgbGVuID0gZG9uZUxpc3QubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZG9uZUxpc3RbaV0uY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW8gOWni+aJp+ihjOWKqOeUu1xuICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb259IFtlYXNpbmddXG4gICAqICAgICAgICAg5Yqo55S757yT5Yqo5Ye95pWw77yM6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmd9XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGZvcmNlQW5pbWF0ZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gKGVhc2luZywgZm9yY2VBbmltYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjbGlwQ291bnQgPSAwO1xuXG4gICAgdmFyIG9uZVRyYWNrRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsaXBDb3VudC0tO1xuXG4gICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICBzZWxmLl9kb25lQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxhc3RDbGlwO1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICBpZiAoIXRoaXMuX3RyYWNrcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGlwID0gY3JlYXRlVHJhY2tDbGlwKHRoaXMsIGVhc2luZywgb25lVHJhY2tEb25lLCB0aGlzLl90cmFja3NbcHJvcE5hbWVdLCBwcm9wTmFtZSwgZm9yY2VBbmltYXRlKTtcblxuICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgdGhpcy5fY2xpcExpc3QucHVzaChjbGlwKTtcblxuICAgICAgICBjbGlwQ291bnQrKzsgLy8gSWYgc3RhcnQgYWZ0ZXIgYWRkZWQgdG8gYW5pbWF0aW9uXG5cbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRpb24uYWRkQ2xpcChjbGlwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RDbGlwID0gY2xpcDtcbiAgICAgIH1cbiAgICB9IC8vIEFkZCBkdXJpbmcgY2FsbGJhY2sgb24gdGhlIGxhc3QgY2xpcFxuXG5cbiAgICBpZiAobGFzdENsaXApIHtcbiAgICAgIHZhciBvbGRPbkZyYW1lID0gbGFzdENsaXAub25mcmFtZTtcblxuICAgICAgbGFzdENsaXAub25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgb2xkT25GcmFtZSh0YXJnZXQsIHBlcmNlbnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fb25mcmFtZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzZWxmLl9vbmZyYW1lTGlzdFtpXSh0YXJnZXQsIHBlcmNlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gLy8gVGhpcyBvcHRpbWl6YXRpb24gd2lsbCBoZWxwIHRoZSBjYXNlIHRoYXQgaW4gdGhlIHVwcGVyIGFwcGxpY2F0aW9uXG4gICAgLy8gdGhlIHZpZXcgbWF5IGJlIHJlZnJlc2hlZCBmcmVxdWVudGx5LCB3aGVyZSBhbmltYXRpb24gd2lsbCBiZVxuICAgIC8vIGNhbGxlZCByZXBlYXRseSBidXQgbm90aGluZyBjaGFuZ2VkLlxuXG5cbiAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgdGhpcy5fZG9uZUNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWBnOatouWKqOeUu1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAqL1xuICBzdG9wOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgIHZhciBjbGlwTGlzdCA9IHRoaXMuX2NsaXBMaXN0O1xuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjbGlwID0gY2xpcExpc3RbaV07XG5cbiAgICAgIGlmIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgIC8vIE1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICBjbGlwLm9uZnJhbWUodGhpcy5fdGFyZ2V0LCAxKTtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5yZW1vdmVDbGlwKGNsaXApO1xuICAgIH1cblxuICAgIGNsaXBMaXN0Lmxlbmd0aCA9IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiuvue9ruWKqOeUu+W7tui/n+W8gOWni+eahOaXtumXtFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5Y2V5L2NbXNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZGVsYXk6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgdGhpcy5fZGVsYXkgPSB0aW1lO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDliqjnlLvnu5PmnZ/nmoTlm57osINcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIGRvbmU6IGZ1bmN0aW9uIChjYikge1xuICAgIGlmIChjYikge1xuICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcD59XG4gICAqL1xuICBnZXRDbGlwczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGlwTGlzdDtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdG9yO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlYXNpbmdGdW5jcyA9IHJlcXVpcmUoXCIuL2Vhc2luZ1wiKTtcblxuLyoqXG4gKiDliqjnlLvkuLvmjqfliLblmahcbiAqIEBjb25maWcgdGFyZ2V0IOWKqOeUu+Wvueixoe+8jOWPr+S7peaYr+aVsOe7hO+8jOWmguaenOaYr+aVsOe7hOeahOivneS8muaJuemHj+WIhuWPkW9uZnJhbWXnrYnkuovku7ZcbiAqIEBjb25maWcgbGlmZSgxMDAwKSDliqjnlLvml7bplb9cbiAqIEBjb25maWcgZGVsYXkoMCkg5Yqo55S75bu26L+f5pe26Ze0XG4gKiBAY29uZmlnIGxvb3AodHJ1ZSlcbiAqIEBjb25maWcgZ2FwKDApIOW+queOr+eahOmXtOmalOaXtumXtFxuICogQGNvbmZpZyBvbmZyYW1lXG4gKiBAY29uZmlnIGVhc2luZyhvcHRpb25hbClcbiAqIEBjb25maWcgb25kZXN0cm95KG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbnJlc3RhcnQob3B0aW9uYWwpXG4gKlxuICogVE9ETyBwYXVzZVxuICovXG5mdW5jdGlvbiBDbGlwKG9wdGlvbnMpIHtcbiAgdGhpcy5fdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7IC8vIOeUn+WRveWRqOacn1xuXG4gIHRoaXMuX2xpZmUgPSBvcHRpb25zLmxpZmUgfHwgMTAwMDsgLy8g5bu25pe2XG5cbiAgdGhpcy5fZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7IC8vIOW8gOWni+aXtumXtFxuICAvLyB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMuX2RlbGF5Oy8vIOWNleS9jeavq+enklxuXG4gIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7IC8vIOaYr+WQpuW+queOr1xuXG4gIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG4gIHRoaXMuZ2FwID0gb3B0aW9ucy5nYXAgfHwgMDtcbiAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCAnTGluZWFyJztcbiAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcbiAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG59XG5cbkNsaXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ2xpcCxcbiAgc3RlcDogZnVuY3Rpb24gKGdsb2JhbFRpbWUsIGRlbHRhVGltZSkge1xuICAgIC8vIFNldCBzdGFydFRpbWUgb24gZmlyc3Qgc3RlcCwgb3IgX3N0YXJ0VGltZSBtYXkgaGFzIG1pbGxlc2Vjb25kcyBkaWZmZXJlbnQgYmV0d2VlbiBjbGlwc1xuICAgIC8vIFBFTkRJTkdcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lICsgdGhpcy5fZGVsYXk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBkZWx0YVRpbWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpIC8gdGhpcy5fbGlmZTsgLy8g6L+Y5rKh5byA5aeLXG5cbiAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwZXJjZW50ID0gTWF0aC5taW4ocGVyY2VudCwgMSk7XG4gICAgdmFyIGVhc2luZyA9IHRoaXMuZWFzaW5nO1xuICAgIHZhciBlYXNpbmdGdW5jID0gdHlwZW9mIGVhc2luZyA9PSAnc3RyaW5nJyA/IGVhc2luZ0Z1bmNzW2Vhc2luZ10gOiBlYXNpbmc7XG4gICAgdmFyIHNjaGVkdWxlID0gdHlwZW9mIGVhc2luZ0Z1bmMgPT09ICdmdW5jdGlvbicgPyBlYXNpbmdGdW5jKHBlcmNlbnQpIDogcGVyY2VudDtcbiAgICB0aGlzLmZpcmUoJ2ZyYW1lJywgc2NoZWR1bGUpOyAvLyDnu5PmnZ9cblxuICAgIGlmIChwZXJjZW50ID09IDEpIHtcbiAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0KGdsb2JhbFRpbWUpOyAvLyDph43mlrDlvIDlp4vlkajmnJ9cbiAgICAgICAgLy8g5oqb5Ye66ICM5LiN5piv55u05o6l6LCD55So5LqL5Lu255u05YiwIHN0YWdlLnVwZGF0ZSDlkI7lho3nu5/kuIDosIPnlKjov5nkupvkuovku7ZcblxuICAgICAgICByZXR1cm4gJ3Jlc3RhcnQnO1xuICAgICAgfSAvLyDliqjnlLvlrozmiJDlsIbov5nkuKrmjqfliLblmajmoIfor4bkuLrlvoXliKDpmaRcbiAgICAgIC8vIOWcqEFuaW1hdGlvbi51cGRhdGXkuK3ov5vooYzmibnph4/liKDpmaRcblxuXG4gICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IHRydWU7XG4gICAgICByZXR1cm4gJ2Rlc3Ryb3knO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICByZXN0YXJ0OiBmdW5jdGlvbiAoZ2xvYmFsVGltZSkge1xuICAgIHZhciByZW1haW5kZXIgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpICUgdGhpcy5fbGlmZTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lIC0gcmVtYWluZGVyICsgdGhpcy5nYXA7XG4gICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gICAgdGhpcy5fbmVlZHNSZW1vdmUgPSBmYWxzZTtcbiAgfSxcbiAgZmlyZTogZnVuY3Rpb24gKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgZXZlbnRUeXBlID0gJ29uJyArIGV2ZW50VHlwZTtcblxuICAgIGlmICh0aGlzW2V2ZW50VHlwZV0pIHtcbiAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgfVxuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH0sXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQ2xpcDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiDnvJPliqjku6PnoIHmnaXoh6ogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvYmxvYi9tYXN0ZXIvc3JjL1R3ZWVuLmpzXG4gKiBAc2VlIGh0dHA6Ly9zb2xlLmdpdGh1Yi5pby90d2Vlbi5qcy9leGFtcGxlcy8wM19ncmFwaHMuaHRtbFxuICogQGV4cG9ydHMgenJlbmRlci9hbmltYXRpb24vZWFzaW5nXG4gKi9cbnZhciBlYXNpbmcgPSB7XG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBsaW5lYXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YWRyYXRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgfSxcbiAgLy8g5LiJ5qyh5pa555qE57yT5Yqo77yIdF4z77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGN1YmljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICB9LFxuICAvLyDlm5vmrKHmlrnnmoTnvJPliqjvvIh0XjTvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhcnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gLS1rICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcbiAgfSxcbiAgLy8g5LqU5qyh5pa555qE57yT5Yqo77yIdF4177yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWludGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG4gIH0sXG4gIC8vIOato+W8puabsue6v+eahOe8k+WKqO+8iHNpbih0Ke+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgfSxcbiAgLy8g5oyH5pWw5puy57q/55qE57yT5Yqo77yIMl5077yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBleHBvbmVudGlhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XG4gIH0sXG4gIC8vIOWchuW9ouabsue6v+eahOe8k+WKqO+8iHNxcnQoMS10XjIp77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFySW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS1rICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFySW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuICB9LFxuICAvLyDliJvlu7rnsbvkvLzkuo7lvLnnsKflnKjlgZzmraLliY3mnaXlm57mjK/ojaHnmoTliqjnlLtcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogaykgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG4gIH0sXG4gIC8vIOWcqOafkOS4gOWKqOeUu+W8gOWni+ayv+aMh+ekuueahOi3r+W+hOi/m+ihjOWKqOeUu+WkhOeQhuWJjeeojeeojeaUtuWbnuivpeWKqOeUu+eahOenu+WKqFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYmFja0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG4gIH0sXG4gIC8vIOWIm+W7uuW8uei3s+aViOaenFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2VPdXQoMSAtIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPCAxIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuICAgIH0gZWxzZSBpZiAoayA8IDIgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMS41IC8gMi43NSkgKiBrICsgMC43NTtcbiAgICB9IGVsc2UgaWYgKGsgPCAyLjUgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMi4yNSAvIDIuNzUpICogayArIDAuOTM3NTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuNjI1IC8gMi43NSkgKiBrICsgMC45ODQzNzU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA8IDAuNSkge1xuICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VJbihrICogMikgKiAwLjU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVhc2luZy5ib3VuY2VPdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IGVhc2luZztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfZGVmYXVsdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9pc3N1ZXMvMTg5I2lzc3VlY29tbWVudC0yMjQ5MTk4MDlcbndpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgc2V0VGltZW91dChmdW5jLCAxNik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZHByID0gMTsgLy8gSWYgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZHByID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG59XG4vKipcbiAqIGNvbmZpZ+m7mOiupOmFjee9rumhuVxuICogQGV4cG9ydHMgenJlbmRlci9jb25maWdcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogZGVidWfml6Xlv5fpgInpobnvvJpjYXRjaEJydXNoRXhjZXB0aW9u5Li6dHJ1ZeS4i+acieaViFxuICogMCA6IOS4jeeUn+aIkGRlYnVn5pWw5o2u77yM5Y+R5biD55SoXG4gKiAxIDog5byC5bi45oqb5Ye677yM6LCD6K+V55SoXG4gKiAyIDog5o6n5Yi25Y+w6L6T5Ye677yM6LCD6K+V55SoXG4gKi9cblxuXG52YXIgZGVidWdNb2RlID0gMDsgLy8gcmV0aW5hIOWxj+W5leS8mOWMllxuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbmV4cG9ydHMuZGVidWdNb2RlID0gZGVidWdNb2RlO1xuZXhwb3J0cy5kZXZpY2VQaXhlbFJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBub3JtYWxpemVSYWRpYW4gPSBfdXRpbC5ub3JtYWxpemVSYWRpYW47XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4vKipcbiAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAqIEBwYXJhbSAge251bWJlcn0gIGN5XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRBbmdsZVxuICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHggLT0gY3g7XG4gIHkgLT0gY3k7XG4gIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gIGlmIChkIC0gX2wgPiByIHx8IGQgKyBfbCA8IHIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlIHx8IGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGU7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9hcmMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbi8qKlxuICog5LiJ5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4M1xuICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wgJiYgeSA8IHkzIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgJiYgeCA+IHgzICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiDnur/mrrXljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoO1xuICB2YXIgX2EgPSAwO1xuICB2YXIgX2IgPSB4MDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHgwICE9PSB4MSkge1xuICAgIF9hID0gKHkwIC0geTEpIC8gKHgwIC0geDEpO1xuICAgIF9iID0gKHgwICogeTEgLSB4MSAqIHkwKSAvICh4MCAtIHgxKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHgwKSA8PSBfbCAvIDI7XG4gIH1cblxuICB2YXIgdG1wID0gX2EgKiB4IC0geSArIF9iO1xuXG4gIHZhciBfcyA9IHRtcCAqIHRtcCAvIChfYSAqIF9hICsgMSk7XG5cbiAgcmV0dXJuIF9zIDw9IF9sIC8gMiAqIF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBsaW5lID0gcmVxdWlyZShcIi4vbGluZVwiKTtcblxudmFyIGN1YmljID0gcmVxdWlyZShcIi4vY3ViaWNcIik7XG5cbnZhciBxdWFkcmF0aWMgPSByZXF1aXJlKFwiLi9xdWFkcmF0aWNcIik7XG5cbnZhciBhcmMgPSByZXF1aXJlKFwiLi9hcmNcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBub3JtYWxpemVSYWRpYW4gPSBfdXRpbC5ub3JtYWxpemVSYWRpYW47XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgd2luZGluZ0xpbmUgPSByZXF1aXJlKFwiLi93aW5kaW5nTGluZVwiKTtcblxudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG52YXIgRVBTSUxPTiA9IDFlLTQ7XG5cbmZ1bmN0aW9uIGlzQXJvdW5kRXF1YWwoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgRVBTSUxPTjtcbn0gLy8g5Li05pe25pWw57uEXG5cblxudmFyIHJvb3RzID0gWy0xLCAtMSwgLTFdO1xudmFyIGV4dHJlbWEgPSBbLTEsIC0xXTtcblxuZnVuY3Rpb24gc3dhcEV4dHJlbWEoKSB7XG4gIHZhciB0bXAgPSBleHRyZW1hWzBdO1xuICBleHRyZW1hWzBdID0gZXh0cmVtYVsxXTtcbiAgZXh0cmVtYVsxXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gd2luZGluZ0N1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSkge1xuICAvLyBRdWljayByZWplY3RcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyICYmIHkgPiB5MyB8fCB5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MiAmJiB5IDwgeTMpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBuUm9vdHMgPSBjdXJ2ZS5jdWJpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5MywgeSwgcm9vdHMpO1xuXG4gIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdyA9IDA7XG4gICAgdmFyIG5FeHRyZW1hID0gLTE7XG4gICAgdmFyIHkwXywgeTFfO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgdmFyIHQgPSByb290c1tpXTsgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG5cbiAgICAgIHZhciB1bml0ID0gdCA9PT0gMCB8fCB0ID09PSAxID8gMC41IDogMTtcbiAgICAgIHZhciB4XyA9IGN1cnZlLmN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuXG4gICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5FeHRyZW1hIDwgMCkge1xuICAgICAgICBuRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYSk7XG5cbiAgICAgICAgaWYgKGV4dHJlbWFbMV0gPCBleHRyZW1hWzBdICYmIG5FeHRyZW1hID4gMSkge1xuICAgICAgICAgIHN3YXBFeHRyZW1hKCk7XG4gICAgICAgIH1cblxuICAgICAgICB5MF8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzBdKTtcblxuICAgICAgICBpZiAobkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgeTFfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5FeHRyZW1hID09IDIpIHtcbiAgICAgICAgLy8g5YiG5oiQ5LiJ5q615Y2V6LCD5Ye95pWwXG4gICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodCA8IGV4dHJlbWFbMV0pIHtcbiAgICAgICAgICB3ICs9IHkxXyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHkzIDwgeTFfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDliIbmiJDkuKTmrrXljZXosIPlh73mlbBcbiAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHkzIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2luZGluZ1F1YWRyYXRpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gIC8vIFF1aWNrIHJlamVjdFxuICBpZiAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgfHwgeSA8IHkwICYmIHkgPCB5MSAmJiB5IDwgeTIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBuUm9vdHMgPSBjdXJ2ZS5xdWFkcmF0aWNSb290QXQoeTAsIHkxLCB5MiwgeSwgcm9vdHMpO1xuXG4gIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdCA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpO1xuXG4gICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgIHZhciB3ID0gMDtcbiAgICAgIHZhciB5XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICAgIHZhciB1bml0ID0gcm9vdHNbaV0gPT09IDAgfHwgcm9vdHNbaV0gPT09IDEgPyAwLjUgOiAxO1xuICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1tpXSk7XG5cbiAgICAgICAgaWYgKHhfIDwgeCkge1xuICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvb3RzW2ldIDwgdCkge1xuICAgICAgICAgIHcgKz0geV8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHkyIDwgeV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICB2YXIgdW5pdCA9IHJvb3RzWzBdID09PSAwIHx8IHJvb3RzWzBdID09PSAxID8gMC41IDogMTtcbiAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzWzBdKTtcblxuICAgICAgaWYgKHhfIDwgeCkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB5MiA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgIH1cbiAgfVxufSAvLyBUT0RPXG4vLyBBcmMg5peL6L2sXG5cblxuZnVuY3Rpb24gd2luZGluZ0FyYyhjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCB4LCB5KSB7XG4gIHkgLT0gY3k7XG5cbiAgaWYgKHkgPiByIHx8IHkgPCAtcikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHRtcCA9IE1hdGguc3FydChyICogciAtIHkgKiB5KTtcbiAgcm9vdHNbMF0gPSAtdG1wO1xuICByb290c1sxXSA9IHRtcDtcbiAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuXG4gIGlmIChkaWZmIDwgMWUtNCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGRpZmYgJSBQSTIgPCAxZS00KSB7XG4gICAgLy8gSXMgYSBjaXJjbGVcbiAgICBzdGFydEFuZ2xlID0gMDtcbiAgICBlbmRBbmdsZSA9IFBJMjtcbiAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcblxuICAgIGlmICh4ID49IHJvb3RzWzBdICsgY3ggJiYgeCA8PSByb290c1sxXSArIGN4KSB7XG4gICAgICByZXR1cm4gZGlyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihzdGFydEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgZW5kQW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgdmFyIHcgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgdmFyIHhfID0gcm9vdHNbaV07XG5cbiAgICBpZiAoeF8gKyBjeCA+IHgpIHtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeF8pO1xuICAgICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG5cbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgYW5nbGUgPSBQSTIgKyBhbmdsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUgfHwgYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZSkge1xuICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiAmJiBhbmdsZSA8IE1hdGguUEkgKiAxLjUpIHtcbiAgICAgICAgICBkaXIgPSAtZGlyO1xuICAgICAgICB9XG5cbiAgICAgICAgdyArPSBkaXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHc7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5QYXRoKGRhdGEsIGxpbmVXaWR0aCwgaXNTdHJva2UsIHgsIHkpIHtcbiAgdmFyIHcgPSAwO1xuICB2YXIgeGkgPSAwO1xuICB2YXIgeWkgPSAwO1xuICB2YXIgeDAgPSAwO1xuICB2YXIgeTAgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgdmFyIGNtZCA9IGRhdGFbaSsrXTsgLy8gQmVnaW4gYSBuZXcgc3VicGF0aFxuXG4gICAgaWYgKGNtZCA9PT0gQ01ELk0gJiYgaSA+IDEpIHtcbiAgICAgIC8vIENsb3NlIHByZXZpb3VzIHN1YnBhdGhcbiAgICAgIGlmICghaXNTdHJva2UpIHtcbiAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7XG4gICAgICB9IC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIH1cblxuICAgIH1cblxuICAgIGlmIChpID09IDEpIHtcbiAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAvL1xuICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgIHlpID0gZGF0YVtpICsgMV07XG4gICAgICB4MCA9IHhpO1xuICAgICAgeTAgPSB5aTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgeDAgPSBkYXRhW2krK107XG4gICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICB4aSA9IHgwO1xuICAgICAgICB5aSA9IHkwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGxpbmUuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTk9URSDlnKjnrKzkuIDkuKrlkb3ku6TkuLogTCwgQywgUSDnmoTml7blgJnkvJrorqHnrpflh7ogTmFOXG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5KSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGN1YmljLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nQ3ViaWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5KSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKHF1YWRyYXRpYy5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nUXVhZHJhdGljKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5KSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgZFRoZXRhID0gZGF0YVtpKytdOyAvLyBUT0RPIEFyYyDml4vovaxcblxuICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG4gICAgICAgIHZhciB4MSA9IE1hdGguY29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgIHZhciB5MSA9IE1hdGguc2luKHRoZXRhKSAqIHJ5ICsgY3k7IC8vIOS4jeaYr+ebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG5cbiAgICAgICAgaWYgKGkgPiAxKSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgxLCB5MSwgeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgICB5MCA9IHkxO1xuICAgICAgICB9IC8vIHpyIOS9v+eUqHNjYWxl5p2l5qih5ouf5qSt5ZyGLCDov5nph4zkuZ/lr7l45YGa5LiA5a6a55qE57yp5pS+XG5cblxuICAgICAgICB2YXIgX3ggPSAoeCAtIGN4KSAqIHJ5IC8gcnggKyBjeDtcblxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAoYXJjLmNvbnRhaW5TdHJva2UoY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLCBsaW5lV2lkdGgsIF94LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0gd2luZGluZ0FyYyhjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsIF94LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gTWF0aC5jb3ModGhldGEgKyBkVGhldGEpICogcnggKyBjeDtcbiAgICAgICAgeWkgPSBNYXRoLnNpbih0aGV0YSArIGRUaGV0YSkgKiByeSArIGN5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgeDEgPSB4MCArIHdpZHRoO1xuICAgICAgICB2YXIgeTEgPSB5MCArIGhlaWdodDtcblxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkwLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MSwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDEsIHkxLCB4MCwgeTEsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgwLCB5MSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRklYTUUgQ2xvY2t3aXNlID9cbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgxLCB5MCwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgwLCB5MSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5aOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHhpLCB5aSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2xvc2UgYSBzdWJwYXRoXG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7IC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgIC8vIEZJWE1FIHN1YnBhdGhzIG1heSBvdmVybGFwXG4gICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgLy8gfVxuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc1N0cm9rZSAmJiAhaXNBcm91bmRFcXVhbCh5aSwgeTApKSB7XG4gICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSkgfHwgMDtcbiAgfVxuXG4gIHJldHVybiB3ICE9PSAwO1xufVxuXG5mdW5jdGlvbiBjb250YWluKHBhdGhEYXRhLCB4LCB5KSB7XG4gIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgMCwgZmFsc2UsIHgsIHkpO1xufVxuXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHRydWUsIHgsIHkpO1xufVxuXG5leHBvcnRzLmNvbnRhaW4gPSBjb250YWluO1xuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoXCIuL3dpbmRpbmdMaW5lXCIpO1xuXG52YXIgRVBTSUxPTiA9IDFlLTg7XG5cbmZ1bmN0aW9uIGlzQXJvdW5kRXF1YWwoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgRVBTSUxPTjtcbn1cblxuZnVuY3Rpb24gY29udGFpbihwb2ludHMsIHgsIHkpIHtcbiAgdmFyIHcgPSAwO1xuICB2YXIgcCA9IHBvaW50c1swXTtcblxuICBpZiAoIXApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwMiA9IHBvaW50c1tpXTtcbiAgICB3ICs9IHdpbmRpbmdMaW5lKHBbMF0sIHBbMV0sIHAyWzBdLCBwMlsxXSwgeCwgeSk7XG4gICAgcCA9IHAyO1xuICB9IC8vIENsb3NlIHBvbHlnb25cblxuXG4gIHZhciBwMCA9IHBvaW50c1swXTtcblxuICBpZiAoIWlzQXJvdW5kRXF1YWwocFswXSwgcDBbMF0pIHx8ICFpc0Fyb3VuZEVxdWFsKHBbMV0sIHAwWzFdKSkge1xuICAgIHcgKz0gd2luZGluZ0xpbmUocFswXSwgcFsxXSwgcDBbMF0sIHAwWzFdLCB4LCB5KTtcbiAgfVxuXG4gIHJldHVybiB3ICE9PSAwO1xufVxuXG5leHBvcnRzLmNvbnRhaW4gPSBjb250YWluO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vcG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wb2x5Z29uLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgcXVhZHJhdGljUHJvamVjdFBvaW50ID0gX2N1cnZlLnF1YWRyYXRpY1Byb2plY3RQb2ludDtcblxuLyoqXG4gKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGQgPSBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9xdWFkcmF0aWMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9oZWxwZXIvaW1hZ2VcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBnZXRDb250ZXh0ID0gX3V0aWwuZ2V0Q29udGV4dDtcbnZhciBleHRlbmQgPSBfdXRpbC5leHRlbmQ7XG52YXIgcmV0cmlldmUyID0gX3V0aWwucmV0cmlldmUyO1xudmFyIHJldHJpZXZlMyA9IF91dGlsLnJldHJpZXZlMztcbnZhciB0cmltID0gX3V0aWwudHJpbTtcbnZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xudmFyIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG52YXIgVEVYVF9DQUNIRV9NQVggPSA1MDAwO1xudmFyIFNUWUxFX1JFRyA9IC9cXHsoW2EtekEtWjAtOV9dKylcXHwoW159XSopXFx9L2c7XG52YXIgREVGQVVMVF9GT05UID0gJzEycHggc2Fucy1zZXJpZic7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0V2lkdGgodGV4dCwgZm9udCkge1xuICBmb250ID0gZm9udCB8fCBERUZBVUxUX0ZPTlQ7XG4gIHZhciBrZXkgPSB0ZXh0ICsgJzonICsgZm9udDtcblxuICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICB9XG5cbiAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIHdpZHRoID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyB0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCBtYXkgYmUgb3ZlcnJpZGVkIGluIFNWRyBvciBWTUxcbiAgICB3aWR0aCA9IE1hdGgubWF4KG1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgZm9udCkud2lkdGgsIHdpZHRoKTtcbiAgfVxuXG4gIGlmICh0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPiBURVhUX0NBQ0hFX01BWCkge1xuICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG4gIHJldHVybiB3aWR0aDtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3RleHRQYWRkaW5nXVxuICogQHBhcmFtIHtPYmplY3R9IFtyaWNoXVxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0ge3gsIHksIHdpZHRoLCBoZWlnaHQsIGxpbmVIZWlnaHR9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSB7XG4gIHJldHVybiByaWNoID8gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkgOiBnZXRQbGFpblRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCB0cnVuY2F0ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGdldFdpZHRoKHRleHQsIGZvbnQpO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIG91dGVyV2lkdGggKz0gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG4gIHJlY3QubGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkge1xuICB2YXIgY29udGVudEJsb2NrID0gcGFyc2VSaWNoVGV4dCh0ZXh0LCB7XG4gICAgcmljaDogcmljaCxcbiAgICB0cnVuY2F0ZTogdHJ1bmNhdGUsXG4gICAgZm9udDogZm9udCxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0UGFkZGluZzogdGV4dFBhZGRpbmdcbiAgfSk7XG4gIHZhciBvdXRlcldpZHRoID0gY29udGVudEJsb2NrLm91dGVyV2lkdGg7XG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0QWxpZ249J2xlZnQnXVxuICogQHJldHVybiB7bnVtYmVyfSBBZGp1c3RlZCB4LlxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFgoeCwgd2lkdGgsIHRleHRBbGlnbikge1xuICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09IHdpZHRoIC8gMjtcbiAgfVxuXG4gIHJldHVybiB4O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0VmVydGljYWxBbGlnbj0ndG9wJ11cbiAqIEByZXR1cm4ge251bWJlcn0gQWRqdXN0ZWQgeS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRZKHksIGhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJykge1xuICAgIHkgLT0gaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB5O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0aXJuZ30gdGV4dFBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIGRpc3RhbmNlKSB7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueTtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9ICd0b3AnO1xuXG4gIHN3aXRjaCAodGV4dFBvc2l0aW9uKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB4IC09IGRpc3RhbmNlO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHggKz0gZGlzdGFuY2UgKyB3aWR0aDtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgLT0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGVpZ2h0ICsgZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVMZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVSaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlVG9wJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3BMZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3BSaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbVJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG4vKipcbiAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWF4SXRlcmF0aW9ucz0zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICogICAgICAgICAgICAgICAgICB0aGVuIG1pbkNoYXIsIGVsbGlwc2lzIHdpbGwgbm90IHNob3csIHdoaWNoIGlzXG4gKiAgICAgICAgICAgICAgICAgIGJldHRlciBmb3IgdXNlciBoaW50IGluIHNvbWUgY2FzZXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiB0cnVuY2F0ZVRleHQodGV4dCwgY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICBvcHRpb25zID0gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpOyAvLyBGSVhNRVxuICAvLyBJdCBpcyBub3QgYXBwcm9wcmlhdGUgdGhhdCBldmVyeSBsaW5lIGhhcyAnLi4uJyB3aGVuIHRydW5jYXRlIG11bHRpcGxlIGxpbmVzLlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0ZXh0TGluZXNbaV0gPSB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmVzW2ldLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0TGluZXMuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUcnVuY2F0ZU9wdGlvbnMoY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBvcHRpb25zLmZvbnQgPSBmb250O1xuICB2YXIgZWxsaXBzaXMgPSByZXRyaWV2ZTIoZWxsaXBzaXMsICcuLi4nKTtcbiAgb3B0aW9ucy5tYXhJdGVyYXRpb25zID0gcmV0cmlldmUyKG9wdGlvbnMubWF4SXRlcmF0aW9ucywgMik7XG4gIHZhciBtaW5DaGFyID0gb3B0aW9ucy5taW5DaGFyID0gcmV0cmlldmUyKG9wdGlvbnMubWluQ2hhciwgMCk7IC8vIEZJWE1FXG4gIC8vIE90aGVyIGxhbmd1YWdlcz9cblxuICBvcHRpb25zLmNuQ2hhcldpZHRoID0gZ2V0V2lkdGgoJ+WbvScsIGZvbnQpOyAvLyBGSVhNRVxuICAvLyBDb25zaWRlciBwcm9wb3J0aW9uYWwgZm9udD9cblxuICB2YXIgYXNjQ2hhcldpZHRoID0gb3B0aW9ucy5hc2NDaGFyV2lkdGggPSBnZXRXaWR0aCgnYScsIGZvbnQpO1xuICBvcHRpb25zLnBsYWNlaG9sZGVyID0gcmV0cmlldmUyKG9wdGlvbnMucGxhY2Vob2xkZXIsICcnKTsgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cblxuICB2YXIgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggPSBNYXRoLm1heCgwLCBjb250YWluZXJXaWR0aCAtIDEpOyAvLyBSZXNlcnZlIHNvbWUgZ2FwLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhciAmJiBjb250ZW50V2lkdGggPj0gYXNjQ2hhcldpZHRoOyBpKyspIHtcbiAgICBjb250ZW50V2lkdGggLT0gYXNjQ2hhcldpZHRoO1xuICB9XG5cbiAgdmFyIGVsbGlwc2lzV2lkdGggPSBnZXRXaWR0aChlbGxpcHNpcyk7XG5cbiAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICBlbGxpcHNpcyA9ICcnO1xuICAgIGVsbGlwc2lzV2lkdGggPSAwO1xuICB9XG5cbiAgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggLSBlbGxpcHNpc1dpZHRoO1xuICBvcHRpb25zLmVsbGlwc2lzID0gZWxsaXBzaXM7XG4gIG9wdGlvbnMuZWxsaXBzaXNXaWR0aCA9IGVsbGlwc2lzV2lkdGg7XG4gIG9wdGlvbnMuY29udGVudFdpZHRoID0gY29udGVudFdpZHRoO1xuICBvcHRpb25zLmNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmUsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5lcldpZHRoID0gb3B0aW9ucy5jb250YWluZXJXaWR0aDtcbiAgdmFyIGZvbnQgPSBvcHRpb25zLmZvbnQ7XG4gIHZhciBjb250ZW50V2lkdGggPSBvcHRpb25zLmNvbnRlbnRXaWR0aDtcblxuICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcblxuICBpZiAobGluZVdpZHRoIDw9IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuIHRleHRMaW5lO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7OyBqKyspIHtcbiAgICBpZiAobGluZVdpZHRoIDw9IGNvbnRlbnRXaWR0aCB8fCBqID49IG9wdGlvbnMubWF4SXRlcmF0aW9ucykge1xuICAgICAgdGV4dExpbmUgKz0gb3B0aW9ucy5lbGxpcHNpcztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzdWJMZW5ndGggPSBqID09PSAwID8gZXN0aW1hdGVMZW5ndGgodGV4dExpbmUsIGNvbnRlbnRXaWR0aCwgb3B0aW9ucy5hc2NDaGFyV2lkdGgsIG9wdGlvbnMuY25DaGFyV2lkdGgpIDogbGluZVdpZHRoID4gMCA/IE1hdGguZmxvb3IodGV4dExpbmUubGVuZ3RoICogY29udGVudFdpZHRoIC8gbGluZVdpZHRoKSA6IDA7XG4gICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICBsaW5lV2lkdGggPSBnZXRXaWR0aCh0ZXh0TGluZSwgZm9udCk7XG4gIH1cblxuICBpZiAodGV4dExpbmUgPT09ICcnKSB7XG4gICAgdGV4dExpbmUgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICB9XG5cbiAgcmV0dXJuIHRleHRMaW5lO1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAodmFyIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuICYmIHdpZHRoIDwgY29udGVudFdpZHRoOyBpKyspIHtcbiAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgd2lkdGggKz0gMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcgPyBhc2NDaGFyV2lkdGggOiBjbkNoYXJXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSBsaW5lIGhlaWdodFxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGluZUhlaWdodChmb250KSB7XG4gIC8vIEZJWE1FIEEgcm91Z2ggYXBwcm9hY2guXG4gIHJldHVybiBnZXRXaWR0aCgn5Zu9JywgZm9udCk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7T2JqZWN0fSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gbWVhc3VyZVRleHQodGV4dCwgZm9udCkge1xuICByZXR1cm4gbWV0aG9kcy5tZWFzdXJlVGV4dCh0ZXh0LCBmb250KTtcbn0gLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxuXG5tZXRob2RzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGZvbnQpIHtcbiAgdmFyIGN0eCA9IGdldENvbnRleHQoKTtcbiAgY3R4LmZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbn07XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2s6IHtsaW5lSGVpZ2h0LCBsaW5lcywgaGVpZ2h0LCBvdXRlckhlaWdodH1cbiAqICBOb3RpY2U6IGZvciBwZXJmb3JtYW5jZSwgZG8gbm90IGNhbGN1bGF0ZSBvdXRlcldpZHRoIHV0aWwgbmVlZGVkLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgcGFkZGluZywgdHJ1bmNhdGUpIHtcbiAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgdmFyIGxpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0KGZvbnQpO1xuICB2YXIgbGluZXMgPSB0ZXh0ID8gdGV4dC5zcGxpdCgnXFxuJykgOiBbXTtcbiAgdmFyIGhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGxpbmVIZWlnaHQ7XG4gIHZhciBvdXRlckhlaWdodCA9IGhlaWdodDtcblxuICBpZiAocGFkZGluZykge1xuICAgIG91dGVySGVpZ2h0ICs9IHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdO1xuICB9XG5cbiAgaWYgKHRleHQgJiYgdHJ1bmNhdGUpIHtcbiAgICB2YXIgdHJ1bmNPdXRlckhlaWdodCA9IHRydW5jYXRlLm91dGVySGVpZ2h0O1xuICAgIHZhciB0cnVuY091dGVyV2lkdGggPSB0cnVuY2F0ZS5vdXRlcldpZHRoO1xuXG4gICAgaWYgKHRydW5jT3V0ZXJIZWlnaHQgIT0gbnVsbCAmJiBvdXRlckhlaWdodCA+IHRydW5jT3V0ZXJIZWlnaHQpIHtcbiAgICAgIHRleHQgPSAnJztcbiAgICAgIGxpbmVzID0gW107XG4gICAgfSBlbHNlIGlmICh0cnVuY091dGVyV2lkdGggIT0gbnVsbCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKHRydW5jT3V0ZXJXaWR0aCAtIChwYWRkaW5nID8gcGFkZGluZ1sxXSArIHBhZGRpbmdbM10gOiAwKSwgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhcixcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRydW5jYXRlLnBsYWNlaG9sZGVyXG4gICAgICB9KTsgLy8gRklYTUVcbiAgICAgIC8vIEl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0aGF0IGV2ZXJ5IGxpbmUgaGFzICcuLi4nIHdoZW4gdHJ1bmNhdGUgbXVsdGlwbGUgbGluZXMuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZShsaW5lc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lczogbGluZXMsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgb3V0ZXJIZWlnaHQ6IG91dGVySGVpZ2h0LFxuICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHRcbiAgfTtcbn1cbi8qKlxuICogRm9yIGV4YW1wbGU6ICdzb21lIHRleHQge2F8c29tZSB0ZXh0fW90aGVyIHRleHR7Ynxzb21lIHRleHR9eHh4e2N8fXh4eCdcbiAqIEFsc28gY29uc2lkZXIgJ2JiYmJ7YXx4eHhcXG56enp9eHh4eFxcbmFhYWEnLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2tcbiAqIHtcbiAqICAgICAgd2lkdGgsXG4gKiAgICAgIGhlaWdodCxcbiAqICAgICAgbGluZXM6IFt7XG4gKiAgICAgICAgICBsaW5lSGVpZ2h0LFxuICogICAgICAgICAgd2lkdGgsXG4gKiAgICAgICAgICB0b2tlbnM6IFtbe1xuICogICAgICAgICAgICAgIHN0eWxlTmFtZSxcbiAqICAgICAgICAgICAgICB0ZXh0LFxuICogICAgICAgICAgICAgIHdpZHRoLCAgICAgIC8vIGluY2x1ZGUgdGV4dFBhZGRpbmdcbiAqICAgICAgICAgICAgICBoZWlnaHQsICAgICAvLyBpbmNsdWRlIHRleHRQYWRkaW5nXG4gKiAgICAgICAgICAgICAgdGV4dFdpZHRoLCAvLyBwdXJlIHRleHQgd2lkdGhcbiAqICAgICAgICAgICAgICB0ZXh0SGVpZ2h0LCAvLyBwdXJlIHRleHQgaGVpZ2h0XG4gKiAgICAgICAgICAgICAgbGluZUhlaWhndCxcbiAqICAgICAgICAgICAgICBmb250LFxuICogICAgICAgICAgICAgIHRleHRBbGlnbixcbiAqICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnblxuICogICAgICAgICAgfV0sIFsuLi5dLCAuLi5dXG4gKiAgICAgIH0sIC4uLl1cbiAqIH1cbiAqIElmIHN0eWxlTmFtZSBpcyB1bmRlZmluZWQsIGl0IGlzIHBsYWluIHRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSB7XG4gICAgbGluZXM6IFtdLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gIGlmICghdGV4dCkge1xuICAgIHJldHVybiBjb250ZW50QmxvY2s7XG4gIH1cblxuICB2YXIgbGFzdEluZGV4ID0gU1RZTEVfUkVHLmxhc3RJbmRleCA9IDA7XG4gIHZhciByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBTVFlMRV9SRUcuZXhlYyh0ZXh0KSkgIT0gbnVsbCkge1xuICAgIHZhciBtYXRjaGVkSW5kZXggPSByZXN1bHQuaW5kZXg7XG5cbiAgICBpZiAobWF0Y2hlZEluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaGVkSW5kZXgpKTtcbiAgICB9XG5cbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgcmVzdWx0WzJdLCByZXN1bHRbMV0pO1xuICAgIGxhc3RJbmRleCA9IFNUWUxFX1JFRy5sYXN0SW5kZXg7XG4gIH1cblxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCB0ZXh0Lmxlbmd0aCkpO1xuICB9XG5cbiAgdmFyIGxpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICB2YXIgY29udGVudEhlaWdodCA9IDA7XG4gIHZhciBjb250ZW50V2lkdGggPSAwOyAvLyBGb3IgYHRleHRXaWR0aDogMTAwJWBcblxuICB2YXIgcGVuZGluZ0xpc3QgPSBbXTtcbiAgdmFyIHN0bFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIHRydW5jYXRlID0gc3R5bGUudHJ1bmNhdGU7XG4gIHZhciB0cnVuY2F0ZVdpZHRoID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJXaWR0aDtcbiAgdmFyIHRydW5jYXRlSGVpZ2h0ID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICB0cnVuY2F0ZVdpZHRoICE9IG51bGwgJiYgKHRydW5jYXRlV2lkdGggLT0gc3RsUGFkZGluZ1sxXSArIHN0bFBhZGRpbmdbM10pO1xuICAgIHRydW5jYXRlSGVpZ2h0ICE9IG51bGwgJiYgKHRydW5jYXRlSGVpZ2h0IC09IHN0bFBhZGRpbmdbMF0gKyBzdGxQYWRkaW5nWzJdKTtcbiAgfSAvLyBDYWxjdWxhdGUgbGF5b3V0IGluZm8gb2YgdG9rZW5zLlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgdmFyIGxpbmVIZWlnaHQgPSAwO1xuICAgIHZhciBsaW5lV2lkdGggPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLnRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHRva2VuID0gbGluZS50b2tlbnNbal07XG4gICAgICB2YXIgdG9rZW5TdHlsZSA9IHRva2VuLnN0eWxlTmFtZSAmJiBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307IC8vIHRleHRQYWRkaW5nIHNob3VsZCBub3QgaW5oZXJpdCBmcm9tIHN0eWxlLlxuXG4gICAgICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZyA9IHRva2VuU3R5bGUudGV4dFBhZGRpbmc7IC8vIHRleHRGb250IGhhcyBiZWVuIGFzaWduZWQgdG8gZm9udCBieSBgbm9ybWFsaXplU3R5bGVgLlxuXG4gICAgICB2YXIgZm9udCA9IHRva2VuLmZvbnQgPSB0b2tlblN0eWxlLmZvbnQgfHwgc3R5bGUuZm9udDsgLy8gdGV4dEhlaWdodCBjYW4gYmUgdXNlZCB3aGVuIHRleHRWZXJ0aWNhbEFsaWduIGlzIHNwZWNpZmllZCBpbiB0b2tlbi5cblxuICAgICAgdmFyIHRva2VuSGVpZ2h0ID0gdG9rZW4udGV4dEhlaWdodCA9IHJldHJpZXZlMiggLy8gdGV4dEhlaWdodCBzaG91bGQgbm90IGJlIGluaGVyaXRlZCwgY29uc2lkZXIgaXQgY2FuIGJlIHNwZWNpZmllZFxuICAgICAgLy8gYXMgYm94IGhlaWdodCBvZiB0aGUgYmxvY2suXG4gICAgICB0b2tlblN0eWxlLnRleHRIZWlnaHQsIGdldExpbmVIZWlnaHQoZm9udCkpO1xuICAgICAgdGV4dFBhZGRpbmcgJiYgKHRva2VuSGVpZ2h0ICs9IHRleHRQYWRkaW5nWzBdICsgdGV4dFBhZGRpbmdbMl0pO1xuICAgICAgdG9rZW4uaGVpZ2h0ID0gdG9rZW5IZWlnaHQ7XG4gICAgICB0b2tlbi5saW5lSGVpZ2h0ID0gcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dExpbmVIZWlnaHQsIHN0eWxlLnRleHRMaW5lSGVpZ2h0LCB0b2tlbkhlaWdodCk7XG4gICAgICB0b2tlbi50ZXh0QWxpZ24gPSB0b2tlblN0eWxlICYmIHRva2VuU3R5bGUudGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgIHRva2VuLnRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW5TdHlsZSAmJiB0b2tlblN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8ICdtaWRkbGUnO1xuXG4gICAgICBpZiAodHJ1bmNhdGVIZWlnaHQgIT0gbnVsbCAmJiBjb250ZW50SGVpZ2h0ICsgdG9rZW4ubGluZUhlaWdodCA+IHRydW5jYXRlSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgIHZhciB0b2tlbldpZHRoID0gdG9rZW5TdHlsZS50ZXh0V2lkdGg7XG4gICAgICB2YXIgdG9rZW5XaWR0aE5vdFNwZWNpZmllZCA9IHRva2VuV2lkdGggPT0gbnVsbCB8fCB0b2tlbldpZHRoID09PSAnYXV0byc7IC8vIFBlcmNlbnQgd2lkdGgsIGNhbiBiZSBgMTAwJWAsIGNhbiBiZSB1c2VkIGluIGRyYXdpbmcgc2VwYXJhdGVcbiAgICAgIC8vIGxpbmUgd2hlbiBib3ggd2lkdGggaXMgbmVlZGVkIHRvIGJlIGF1dG8uXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW5XaWR0aCA9PT0gJ3N0cmluZycgJiYgdG9rZW5XaWR0aC5jaGFyQXQodG9rZW5XaWR0aC5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgIHRva2VuLnBlcmNlbnRXaWR0aCA9IHRva2VuV2lkdGg7XG4gICAgICAgIHBlbmRpbmdMaXN0LnB1c2godG9rZW4pO1xuICAgICAgICB0b2tlbldpZHRoID0gMDsgLy8gRG8gbm90IHRydW5jYXRlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSB0aGVyZSBpcyBubyB1c2VyIGNhc2VcbiAgICAgICAgLy8gYW5kIGl0IGlzIHRvbyBjb21wbGljYXRlZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlbldpZHRoTm90U3BlY2lmaWVkKSB7XG4gICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aDsgLy8gRklYTUU6IElmIGltYWdlIGlzIG5vdCBsb2FkZWQgYW5kIHRleHRXaWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxsaW5nXG4gICAgICAgICAgLy8gYGdldEJvdW5kaW5nUmVjdCgpYCB3aWxsIG5vdCBnZXQgY29ycmVjdCByZXN1bHQuXG5cbiAgICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHRva2VuU3R5bGUudGV4dEJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICB2YXIgYmdJbWcgPSB0ZXh0QmFja2dyb3VuZENvbG9yICYmIHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2U7IC8vIFVzZSBjYXNlczpcbiAgICAgICAgICAvLyAoMSkgSWYgaW1hZ2UgaXMgbm90IGxvYWRlZCwgaXQgd2lsbCBiZSBsb2FkZWQgYXQgcmVuZGVyIHBoYXNlIGFuZCBjYWxsXG4gICAgICAgICAgLy8gYGRpcnR5KClgIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBsb2FkZWRcbiAgICAgICAgICAvLyBpbWFnZSwgYW5kIHRoZW4gdGhlIHJpZ2h0IHNpemUgd2lsbCBiZSBjYWxjdWxhdGVkIGhlcmUgYXQgdGhlIG5leHQgdGljay5cbiAgICAgICAgICAvLyBTZWUgYGdyYXBoaWMvaGVscGVyL3RleHQuanNgLlxuICAgICAgICAgIC8vICgyKSBJZiBpbWFnZSBsb2FkZWQsIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgaXMgaW1hZ2Ugc3JjIHN0cmluZyxcbiAgICAgICAgICAvLyB1c2UgYGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlYCB0byBmaW5kIGNhY2hlZCBpbWFnZS5cbiAgICAgICAgICAvLyBgaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2VgIHdpbGwgYWx3YXlzIGJlIGNhbGxlZCBoZXJlIGJlZm9yZVxuICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlYCBpbiBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyNyZW5kZXJSaWNoVGV4dGBcbiAgICAgICAgICAvLyB3aGljaCBlbnN1cmVzIHRoYXQgaW1hZ2Ugd2lsbCBub3QgYmUgcmVuZGVyZWQgYmVmb3JlIGNvcnJlY3Qgc2l6ZSBjYWxjdWFsdGVkLlxuXG4gICAgICAgICAgaWYgKGJnSW1nKSB7XG4gICAgICAgICAgICBiZ0ltZyA9IGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlKGJnSW1nKTtcblxuICAgICAgICAgICAgaWYgKGltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShiZ0ltZykpIHtcbiAgICAgICAgICAgICAgdG9rZW5XaWR0aCA9IE1hdGgubWF4KHRva2VuV2lkdGgsIGJnSW1nLndpZHRoICogdG9rZW5IZWlnaHQgLyBiZ0ltZy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWRkaW5nVyA9IHRleHRQYWRkaW5nID8gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXSA6IDA7XG4gICAgICAgIHRva2VuV2lkdGggKz0gcGFkZGluZ1c7XG4gICAgICAgIHZhciByZW1pYW5UcnVuY1dpZHRoID0gdHJ1bmNhdGVXaWR0aCAhPSBudWxsID8gdHJ1bmNhdGVXaWR0aCAtIGxpbmVXaWR0aCA6IG51bGw7XG5cbiAgICAgICAgaWYgKHJlbWlhblRydW5jV2lkdGggIT0gbnVsbCAmJiByZW1pYW5UcnVuY1dpZHRoIDwgdG9rZW5XaWR0aCkge1xuICAgICAgICAgIGlmICghdG9rZW5XaWR0aE5vdFNwZWNpZmllZCB8fCByZW1pYW5UcnVuY1dpZHRoIDwgcGFkZGluZ1cpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSAnJztcbiAgICAgICAgICAgIHRva2VuLnRleHRXaWR0aCA9IHRva2VuV2lkdGggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gdHJ1bmNhdGVUZXh0KHRva2VuLnRleHQsIHJlbWlhblRydW5jV2lkdGggLSBwYWRkaW5nVywgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgICAgICAgIHRva2VuV2lkdGggPSB0b2tlbi50ZXh0V2lkdGggKyBwYWRkaW5nVztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGluZVdpZHRoICs9IHRva2VuLndpZHRoID0gdG9rZW5XaWR0aDtcbiAgICAgIHRva2VuU3R5bGUgJiYgKGxpbmVIZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCB0b2tlbi5saW5lSGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgbGluZS53aWR0aCA9IGxpbmVXaWR0aDtcbiAgICBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgIGNvbnRlbnRIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICBjb250ZW50V2lkdGggPSBNYXRoLm1heChjb250ZW50V2lkdGgsIGxpbmVXaWR0aCk7XG4gIH1cblxuICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aCA9IHJldHJpZXZlMihzdHlsZS50ZXh0V2lkdGgsIGNvbnRlbnRXaWR0aCk7XG4gIGNvbnRlbnRCbG9jay5vdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5oZWlnaHQgPSByZXRyaWV2ZTIoc3R5bGUudGV4dEhlaWdodCwgY29udGVudEhlaWdodCk7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCArPSBzdGxQYWRkaW5nWzFdICsgc3RsUGFkZGluZ1szXTtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQgKz0gc3RsUGFkZGluZ1swXSArIHN0bFBhZGRpbmdbMl07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBlbmRpbmdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gcGVuZGluZ0xpc3RbaV07XG4gICAgdmFyIHBlcmNlbnRXaWR0aCA9IHRva2VuLnBlcmNlbnRXaWR0aDsgLy8gU2hvdWxkIG5vdCBiYXNlIG9uIG91dGVyV2lkdGgsIGJlY2F1c2UgdG9rZW4gY2FuIG5vdCBiZSBwbGFjZWQgb3V0IG9mIHBhZGRpbmcuXG5cbiAgICB0b2tlbi53aWR0aCA9IHBhcnNlSW50KHBlcmNlbnRXaWR0aCwgMTApIC8gMTAwICogY29udGVudFdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbn1cblxuZnVuY3Rpb24gcHVzaFRva2VucyhibG9jaywgc3RyLCBzdHlsZU5hbWUpIHtcbiAgdmFyIGlzRW1wdHlTdHIgPSBzdHIgPT09ICcnO1xuICB2YXIgc3RycyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gIHZhciBsaW5lcyA9IGJsb2NrLmxpbmVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ZXh0ID0gc3Ryc1tpXTtcbiAgICB2YXIgdG9rZW4gPSB7XG4gICAgICBzdHlsZU5hbWU6IHN0eWxlTmFtZSxcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBpc0xpbmVIb2xkZXI6ICF0ZXh0ICYmICFpc0VtcHR5U3RyXG4gICAgfTsgLy8gVGhlIGZpcnN0IHRva2VuIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCBsaW5lLlxuXG4gICAgaWYgKCFpKSB7XG4gICAgICB2YXIgdG9rZW5zID0gKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdIHx8IChsaW5lc1swXSA9IHtcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfSkpLnRva2VuczsgLy8gQ29uc2lkZXIgY2FzZXM6XG4gICAgICAvLyAoMSkgJycuc3BsaXQoJ1xcbicpID0+IFsnJywgJ1xcbicsICcnXSwgdGhlICcnIGF0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAvLyAod2hpY2ggaXMgYSBwbGFjZWhvbGRlcikgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IG5ldyB0b2tlbi5cbiAgICAgIC8vICgyKSBBIGltYWdlIGJhY2thZ2UsIHdoZXJlIHRva2VuIGxpa2VzIHthfH0uXG4gICAgICAvLyAoMykgQSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAvLyAoNCkgdG9rZW5zIHdpdGggdGhlIHNhbWUgdHBsTmFtZSBzaG91bGQgbm90IGJlIG1lcmdlZCwgYmVjYXVzZVxuICAgICAgLy8gdGhleSBzaG91bGQgYmUgZGlzcGxheWVkIGluIGRpZmZlcmVudCBib3ggKHdpdGggYm9yZGVyIGFuZCBwYWRkaW5nKS5cblxuICAgICAgdmFyIHRva2Vuc0xlbiA9IHRva2Vucy5sZW5ndGg7XG4gICAgICB0b2tlbnNMZW4gPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluZUhvbGRlciA/IHRva2Vuc1swXSA9IHRva2VuIDogLy8gQ29uc2lkZXIgdGV4dCBpcyAnJywgb25seSBpbnNlcnQgd2hlbiBpdCBpcyB0aGUgXCJsaW5lSG9sZGVyXCIgb3JcbiAgICAgIC8vIFwiZW1wdHlTdHJcIi4gT3RoZXJ3aXNlIGEgcmVkdW5kYW50ICcnIHdpbGwgYWZmZWN0IHRleHRBbGlnbiBpbiBsaW5lLlxuICAgICAgKHRleHQgfHwgIXRva2Vuc0xlbiB8fCBpc0VtcHR5U3RyKSAmJiB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfSAvLyBPdGhlciB0b2tlbnMgYWx3YXlzIHN0YXJ0IGEgbmV3IGxpbmUuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzICcnLCBpbnNlcnQgaXQgYXMgYSBwbGFjZWhvbGRlci5cbiAgICAgICAgbGluZXMucHVzaCh7XG4gICAgICAgICAgdG9rZW5zOiBbdG9rZW5dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGb250KHN0eWxlKSB7XG4gIC8vIEZJWE1FIGluIG5vZGUtY2FudmFzIGZvbnRXZWlnaHQgaXMgYmVmb3JlIGZvbnRTdHlsZVxuICAvLyBVc2UgYGZvbnRTaXplYCBgZm9udEZhbWlseWAgdG8gY2hlY2sgd2hldGhlciBmb250IHByb3BlcnRpZXMgYXJlIGRlZmluZWQuXG4gIHZhciBmb250ID0gKHN0eWxlLmZvbnRTaXplIHx8IHN0eWxlLmZvbnRGYW1pbHkpICYmIFtzdHlsZS5mb250U3R5bGUsIHN0eWxlLmZvbnRXZWlnaHQsIChzdHlsZS5mb250U2l6ZSB8fCAxMikgKyAncHgnLCAvLyBJZiBmb250IHByb3BlcnRpZXMgYXJlIGRlZmluZWQsIGBmb250RmFtaWx5YCBzaG91bGQgbm90IGJlIGlnbm9yZWQuXG4gIHN0eWxlLmZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnXS5qb2luKCcgJyk7XG4gIHJldHVybiBmb250ICYmIHRyaW0oZm9udCkgfHwgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udDtcbn1cblxuZXhwb3J0cy5ERUZBVUxUX0ZPTlQgPSBERUZBVUxUX0ZPTlQ7XG5leHBvcnRzLiRvdmVycmlkZSA9ICRvdmVycmlkZTtcbmV4cG9ydHMuZ2V0V2lkdGggPSBnZXRXaWR0aDtcbmV4cG9ydHMuZ2V0Qm91bmRpbmdSZWN0ID0gZ2V0Qm91bmRpbmdSZWN0O1xuZXhwb3J0cy5hZGp1c3RUZXh0WCA9IGFkanVzdFRleHRYO1xuZXhwb3J0cy5hZGp1c3RUZXh0WSA9IGFkanVzdFRleHRZO1xuZXhwb3J0cy5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QgPSBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3Q7XG5leHBvcnRzLnRydW5jYXRlVGV4dCA9IHRydW5jYXRlVGV4dDtcbmV4cG9ydHMuZ2V0TGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQ7XG5leHBvcnRzLm1lYXN1cmVUZXh0ID0gbWVhc3VyZVRleHQ7XG5leHBvcnRzLnBhcnNlUGxhaW5UZXh0ID0gcGFyc2VQbGFpblRleHQ7XG5leHBvcnRzLnBhcnNlUmljaFRleHQgPSBwYXJzZVJpY2hUZXh0O1xuZXhwb3J0cy5tYWtlRm9udCA9IG1ha2VGb250O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG5mdW5jdGlvbiBub3JtYWxpemVSYWRpYW4oYW5nbGUpIHtcbiAgYW5nbGUgJT0gUEkyO1xuXG4gIGlmIChhbmdsZSA8IDApIHtcbiAgICBhbmdsZSArPSBQSTI7XG4gIH1cblxuICByZXR1cm4gYW5nbGU7XG59XG5cbmV4cG9ydHMubm9ybWFsaXplUmFkaWFuID0gbm9ybWFsaXplUmFkaWFuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi91dGlsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgfHwgeSA8IHkwICYmIHkgPCB5MSkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcblxuXG4gIGlmICh5MSA9PT0geTApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkaXIgPSB5MSA8IHkwID8gMSA6IC0xO1xuICB2YXIgdCA9ICh5IC0geTApIC8gKHkxIC0geTApOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICBpZiAodCA9PT0gMSB8fCB0ID09PSAwKSB7XG4gICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gIH1cblxuICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7IC8vIElmICh4LCB5KSBvbiB0aGUgbGluZSwgY29uc2lkZXJlZCBhcyBcImNvbnRhaW5cIi5cblxuICByZXR1cm4geF8gPT09IHggPyBJbmZpbml0eSA6IHhfID4geCA/IGRpciA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luZGluZ0xpbmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoXCIuLi9FbGVtZW50XCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG4vKipcbiAqIEdyb3Vw5piv5LiA5Liq5a655Zmo77yM5Y+v5Lul5o+S5YWl5a2Q6IqC54K577yMR3JvdXDnmoTlj5jmjaLkuZ/kvJrooqvlupTnlKjliLDlrZDoioLngrnkuIpcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29udGFpbmVyL0dyb3VwJyk7XG4gKiAgICAgdmFyIENpcmNsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcbiAqICAgICB2YXIgZyA9IG5ldyBHcm91cCgpO1xuICogICAgIGcucG9zaXRpb25bMF0gPSAxMDA7XG4gKiAgICAgZy5wb3NpdGlvblsxXSA9IDEwMDtcbiAqICAgICBnLmFkZChuZXcgQ2lyY2xlKHtcbiAqICAgICAgICAgc3R5bGU6IHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMCxcbiAqICAgICAgICAgICAgIHI6IDIwLFxuICogICAgICAgICB9XG4gKiAgICAgfSkpO1xuICogICAgIHpyLmFkZChnKTtcbiAqL1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKi9cbnZhciBHcm91cCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB0aGlzW2tleV0gPSBvcHRzW2tleV07XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5fX3N0b3JhZ2UgPSBudWxsO1xuICB0aGlzLl9fZGlydHkgPSB0cnVlO1xufTtcblxuR3JvdXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogR3JvdXAsXG4gIGlzR3JvdXA6IHRydWUsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0eXBlOiAnZ3JvdXAnLFxuXG4gIC8qKlxuICAgKiDmiYDmnInlrZDlrZnlhYPntKDmmK/lkKblk43lupTpvKDmoIfkuovku7ZcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2NvbnRhaW5lci9Hcm91cCNzaWxlbnRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAqL1xuICBjaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5zbGljZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmjIflrpogaW5kZXgg55qE5YS/5a2Q6IqC54K5XG4gICAqIEBwYXJhbSAge251bWJlcn0gaWR4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAqL1xuICBjaGlsZEF0OiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2lkeF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPluaMh+WumuWQjeWtl+eahOWEv+WtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICovXG4gIGNoaWxkT2ZOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWtkOiKgueCueWIsOacgOWQjlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWtkOiKgueCueWcqCBuZXh0U2libGluZyDkuYvliY1cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IG5leHRTaWJsaW5nXG4gICAqL1xuICBhZGRCZWZvcmU6IGZ1bmN0aW9uIChjaGlsZCwgbmV4dFNpYmxpbmcpIHtcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzICYmIG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICB2YXIgaWR4ID0gY2hpbGRyZW4uaW5kZXhPZihuZXh0U2libGluZyk7XG5cbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAwLCBjaGlsZCk7XG5cbiAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZG9BZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICAgIH1cblxuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG5cbiAgICBpZiAoc3RvcmFnZSAmJiBzdG9yYWdlICE9PSBjaGlsZC5fX3N0b3JhZ2UpIHtcbiAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgenIgJiYgenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnp7vpmaTlrZDoioLngrlcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YoY2hpbGRyZW4sIGNoaWxkKTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcbiAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuXG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHpyICYmIHpyLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog56e76Zmk5omA5pyJ5a2Q6IqC54K5XG4gICAqL1xuICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciBjaGlsZDtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog6YGN5Y6G5omA5pyJ5a2Q6IqC54K5XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgZWFjaENoaWxkOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3seW6puS8mOWFiOmBjeWOhuaJgOacieWtkOWtmeiKgueCuVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICBjaGlsZC50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZENoaWxkcmVuVG9TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlbENoaWxkcmVuRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAvLyBUT0RPIENhY2hpbmdcbiAgICB2YXIgcmVjdCA9IG51bGw7XG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIHZhciBjaGlsZHJlbiA9IGluY2x1ZGVDaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbjtcbiAgICB2YXIgdG1wTWF0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNoaWxkLmlnbm9yZSB8fCBjaGlsZC5pbnZpc2libGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBjaGlsZC5nZXRMb2NhbFRyYW5zZm9ybSh0bXBNYXQpOyAvLyBUT0RPXG4gICAgICAvLyBUaGUgYm91bmRpbmdSZWN0IGNhY2x1YXRlZCBieSB0cmFuc2Zvcm1pbmcgb3JpZ2luYWxcbiAgICAgIC8vIHJlY3QgbWF5IGJlIGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgYnVuZGluZ1JlY3Qgd2hlbiByb3RhdGlvblxuICAgICAgLy8gaXMgdXNlZC4gKENvbnNpZGVyIGEgY2lyY2xlIHJvdGF0ZWQgYWdpbnN0IGl0cyBjZW50ZXIsIHdoZXJlXG4gICAgICAvLyB0aGUgYWN0dWFsIGJvdW5kaW5nUmVjdCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhhdCBub3QgYmVcbiAgICAgIC8vIHJvdGF0ZWQuKSBCdXQgd2UgY2FuIG5vdCBmaW5kIGJldHRlciBhcHByb2FjaCB0byBjYWxjdWxhdGVcbiAgICAgIC8vIGFjdHVhbCBib3VuZGluZ1JlY3QgeWV0LCBjb25zaWRlcmluZyBwZXJmb3JtYW5jZS5cblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0bXBSZWN0LmNvcHkoY2hpbGRSZWN0KTtcbiAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0bXBSZWN0LmNsb25lKCk7XG4gICAgICAgIHJlY3QudW5pb24odG1wUmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCBjaGlsZFJlY3QuY2xvbmUoKTtcbiAgICAgICAgcmVjdC51bmlvbihjaGlsZFJlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWN0IHx8IHRtcFJlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoR3JvdXAsIEVsZW1lbnQpO1xudmFyIF9kZWZhdWx0ID0gR3JvdXA7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBtYXRyaXggPSByZXF1aXJlKFwiLi9tYXRyaXhcIik7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cbnZhciB2MkFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xuXG5mdW5jdGlvbiBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAod2lkdGggPCAwKSB7XG4gICAgeCA9IHggKyB3aWR0aDtcbiAgICB3aWR0aCA9IC13aWR0aDtcbiAgfVxuXG4gIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cblxuICB0aGlzLnggPSB4O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy55ID0geTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufVxuXG5Cb3VuZGluZ1JlY3QucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQm91bmRpbmdSZWN0LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fSBvdGhlclxuICAgKi9cbiAgdW5pb246IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHZhciB4ID0gbWF0aE1pbihvdGhlci54LCB0aGlzLngpO1xuICAgIHZhciB5ID0gbWF0aE1pbihvdGhlci55LCB0aGlzLnkpO1xuICAgIHRoaXMud2lkdGggPSBtYXRoTWF4KG90aGVyLnggKyBvdGhlci53aWR0aCwgdGhpcy54ICsgdGhpcy53aWR0aCkgLSB4O1xuICAgIHRoaXMuaGVpZ2h0ID0gbWF0aE1heChvdGhlci55ICsgb3RoZXIuaGVpZ2h0LCB0aGlzLnkgKyB0aGlzLmhlaWdodCkgLSB5O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbVxuICAgKiBAbWV0aG9kc1xuICAgKi9cbiAgYXBwbHlUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbHQgPSBbXTtcbiAgICB2YXIgcmIgPSBbXTtcbiAgICB2YXIgbGIgPSBbXTtcbiAgICB2YXIgcnQgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG0pIHtcbiAgICAgIC8vIEluIGNhc2UgdXNhZ2UgbGlrZSB0aGlzXG4gICAgICAvLyBlbC5nZXRCb3VuZGluZ1JlY3QoKS5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pXG4gICAgICAvLyBBbmQgZWxlbWVudCBoYXMgbm8gdHJhbnNmb3JtXG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsdFswXSA9IGxiWzBdID0gdGhpcy54O1xuICAgICAgbHRbMV0gPSBydFsxXSA9IHRoaXMueTtcbiAgICAgIHJiWzBdID0gcnRbMF0gPSB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgICAgcmJbMV0gPSBsYlsxXSA9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShsdCwgbHQsIG0pO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShyYiwgcmIsIG0pO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShsYiwgbGIsIG0pO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShydCwgcnQsIG0pO1xuICAgICAgdGhpcy54ID0gbWF0aE1pbihsdFswXSwgcmJbMF0sIGxiWzBdLCBydFswXSk7XG4gICAgICB0aGlzLnkgPSBtYXRoTWluKGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgIHZhciBtYXhYID0gbWF0aE1heChsdFswXSwgcmJbMF0sIGxiWzBdLCBydFswXSk7XG4gICAgICB2YXIgbWF4WSA9IG1hdGhNYXgobHRbMV0sIHJiWzFdLCBsYlsxXSwgcnRbMV0pO1xuICAgICAgdGhpcy53aWR0aCA9IG1heFggLSB0aGlzLng7XG4gICAgICB0aGlzLmhlaWdodCA9IG1heFkgLSB0aGlzLnk7XG4gICAgfTtcbiAgfSgpLFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgbWF0cml4IG9mIHRyYW5zZm9ybWluZyBmcm9tIHNlbGYgdG8gdGFyZ2V0IHJlY3RcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IGJcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBjYWxjdWxhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChiKSB7XG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBzeCA9IGIud2lkdGggLyBhLndpZHRoO1xuICAgIHZhciBzeSA9IGIuaGVpZ2h0IC8gYS5oZWlnaHQ7XG4gICAgdmFyIG0gPSBtYXRyaXguY3JlYXRlKCk7IC8vIOefqemYteWPs+S5mFxuXG4gICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbLWEueCwgLWEueV0pO1xuICAgIG1hdHJpeC5zY2FsZShtLCBtLCBbc3gsIHN5XSk7XG4gICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcbiAgICByZXR1cm4gbTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHsobW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R8T2JqZWN0KX0gYlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoYikge1xuICAgIGlmICghYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghKGIgaW5zdGFuY2VvZiBCb3VuZGluZ1JlY3QpKSB7XG4gICAgICAvLyBOb3JtYWxpemUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0LlxuICAgICAgYiA9IEJvdW5kaW5nUmVjdC5jcmVhdGUoYik7XG4gICAgfVxuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBheDAgPSBhLng7XG4gICAgdmFyIGF4MSA9IGEueCArIGEud2lkdGg7XG4gICAgdmFyIGF5MCA9IGEueTtcbiAgICB2YXIgYXkxID0gYS55ICsgYS5oZWlnaHQ7XG4gICAgdmFyIGJ4MCA9IGIueDtcbiAgICB2YXIgYngxID0gYi54ICsgYi53aWR0aDtcbiAgICB2YXIgYnkwID0gYi55O1xuICAgIHZhciBieTEgPSBiLnkgKyBiLmhlaWdodDtcbiAgICByZXR1cm4gIShheDEgPCBieDAgfHwgYngxIDwgYXgwIHx8IGF5MSA8IGJ5MCB8fCBieTEgPCBheTApO1xuICB9LFxuICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciByZWN0ID0gdGhpcztcbiAgICByZXR1cm4geCA+PSByZWN0LnggJiYgeCA8PSByZWN0LnggKyByZWN0LndpZHRoICYmIHkgPj0gcmVjdC55ICYmIHkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb3B5IGZyb20gYW5vdGhlciByZWN0XG4gICAqL1xuICBjb3B5OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB0aGlzLnggPSBvdGhlci54O1xuICAgIHRoaXMueSA9IG90aGVyLnk7XG4gICAgdGhpcy53aWR0aCA9IG90aGVyLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0O1xuICB9LFxuICBwbGFpbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnksXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QueFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QueVxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3Qud2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LmhlaWdodFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gKi9cblxuQm91bmRpbmdSZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChyZWN0KSB7XG4gIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBCb3VuZGluZ1JlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBldmVudFV0aWwgPSByZXF1aXJlKFwiLi9ldmVudFwiKTtcblxuLyoqXG4gKiBPbmx5IGltcGxlbWVudHMgbmVlZGVkIGdlc3R1cmVzIGZvciBtb2JpbGUuXG4gKi9cbnZhciBHZXN0dXJlTWdyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgKi9cbiAgdGhpcy5fdHJhY2sgPSBbXTtcbn07XG5cbkdlc3R1cmVNZ3IucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogR2VzdHVyZU1ncixcbiAgcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgIHRoaXMuX2RvVHJhY2soZXZlbnQsIHRhcmdldCwgcm9vdCk7XG5cbiAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKGV2ZW50KTtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90cmFjay5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZG9UcmFjazogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG5cbiAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tJdGVtID0ge1xuICAgICAgcG9pbnRzOiBbXSxcbiAgICAgIHRvdWNoZXM6IFtdLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvdWNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgICB2YXIgcG9zID0gZXZlbnRVdGlsLmNsaWVudFRvTG9jYWwocm9vdCwgdG91Y2gsIHt9KTtcbiAgICAgIHRyYWNrSXRlbS5wb2ludHMucHVzaChbcG9zLnpyWCwgcG9zLnpyWV0pO1xuICAgICAgdHJhY2tJdGVtLnRvdWNoZXMucHVzaCh0b3VjaCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJhY2sucHVzaCh0cmFja0l0ZW0pO1xuICB9LFxuICBfcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcmVjb2duaXplcnMpIHtcbiAgICAgIGlmIChyZWNvZ25pemVycy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IHJlY29nbml6ZXJzW2V2ZW50TmFtZV0odGhpcy5fdHJhY2ssIGV2ZW50KTtcblxuICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICByZXR1cm4gZ2VzdHVyZUluZm87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRpc3QocG9pbnRQYWlyKSB7XG4gIHZhciBkeCA9IHBvaW50UGFpclsxXVswXSAtIHBvaW50UGFpclswXVswXTtcbiAgdmFyIGR5ID0gcG9pbnRQYWlyWzFdWzFdIC0gcG9pbnRQYWlyWzBdWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbn1cblxuZnVuY3Rpb24gY2VudGVyKHBvaW50UGFpcikge1xuICByZXR1cm4gWyhwb2ludFBhaXJbMF1bMF0gKyBwb2ludFBhaXJbMV1bMF0pIC8gMiwgKHBvaW50UGFpclswXVsxXSArIHBvaW50UGFpclsxXVsxXSkgLyAyXTtcbn1cblxudmFyIHJlY29nbml6ZXJzID0ge1xuICBwaW5jaDogZnVuY3Rpb24gKHRyYWNrLCBldmVudCkge1xuICAgIHZhciB0cmFja0xlbiA9IHRyYWNrLmxlbmd0aDtcblxuICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGluY2hFbmQgPSAodHJhY2tbdHJhY2tMZW4gLSAxXSB8fCB7fSkucG9pbnRzO1xuICAgIHZhciBwaW5jaFByZSA9ICh0cmFja1t0cmFja0xlbiAtIDJdIHx8IHt9KS5wb2ludHMgfHwgcGluY2hFbmQ7XG5cbiAgICBpZiAocGluY2hQcmUgJiYgcGluY2hQcmUubGVuZ3RoID4gMSAmJiBwaW5jaEVuZCAmJiBwaW5jaEVuZC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgcGluY2hTY2FsZSA9IGRpc3QocGluY2hFbmQpIC8gZGlzdChwaW5jaFByZSk7XG4gICAgICAhaXNGaW5pdGUocGluY2hTY2FsZSkgJiYgKHBpbmNoU2NhbGUgPSAxKTtcbiAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBwaW5jaFNjYWxlO1xuICAgICAgdmFyIHBpbmNoQ2VudGVyID0gY2VudGVyKHBpbmNoRW5kKTtcbiAgICAgIGV2ZW50LnBpbmNoWCA9IHBpbmNoQ2VudGVyWzBdO1xuICAgICAgZXZlbnQucGluY2hZID0gcGluY2hDZW50ZXJbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncGluY2gnLFxuICAgICAgICB0YXJnZXQ6IHRyYWNrWzBdLnRhcmdldCxcbiAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBPbmx5IHBpbmNoIGN1cnJlbnRseS5cblxufTtcbnZhciBfZGVmYXVsdCA9IEdlc3R1cmVNZ3I7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvR2VzdHVyZU1nci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gU2ltcGxlIExSVSBjYWNoZSB1c2UgZG91Ymx5IGxpbmtlZCBsaXN0XG4vLyBAbW9kdWxlIHpyZW5kZXIvY29yZS9MUlVcblxuLyoqXG4gKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5fbGVuID0gMDtcbn07XG5cbnZhciBsaW5rZWRMaXN0UHJvdG8gPSBMaW5rZWRMaXN0LnByb3RvdHlwZTtcbi8qKlxuICogSW5zZXJ0IGEgbmV3IHZhbHVlIGF0IHRoZSB0YWlsXG4gKiBAcGFyYW0gIHt9IHZhbFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gKi9cblxubGlua2VkTGlzdFByb3RvLmluc2VydCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIGVudHJ5ID0gbmV3IEVudHJ5KHZhbCk7XG4gIHRoaXMuaW5zZXJ0RW50cnkoZW50cnkpO1xuICByZXR1cm4gZW50cnk7XG59O1xuLyoqXG4gKiBJbnNlcnQgYW4gZW50cnkgYXQgdGhlIHRhaWxcbiAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gZW50cnk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICBlbnRyeS5wcmV2ID0gdGhpcy50YWlsO1xuICAgIGVudHJ5Lm5leHQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICB9XG5cbiAgdGhpcy5fbGVuKys7XG59O1xuLyoqXG4gKiBSZW1vdmUgZW50cnkuXG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgdmFyIHByZXYgPSBlbnRyeS5wcmV2O1xuICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIC8vIElzIGhlYWRcbiAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2O1xuICB9IGVsc2Uge1xuICAgIC8vIElzIHRhaWxcbiAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICB9XG5cbiAgZW50cnkubmV4dCA9IGVudHJ5LnByZXYgPSBudWxsO1xuICB0aGlzLl9sZW4tLTtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5sZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9sZW47XG59O1xuLyoqXG4gKiBDbGVhciBsaXN0XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMuX2xlbiA9IDA7XG59O1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7fSB2YWxcbiAqL1xuXG5cbnZhciBFbnRyeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHt9XG4gICAqL1xuICB0aGlzLnZhbHVlID0gdmFsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLm5leHQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMucHJldjtcbn07XG4vKipcbiAqIExSVSBDYWNoZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9MUlVcbiAqL1xuXG5cbnZhciBMUlUgPSBmdW5jdGlvbiAobWF4U2l6ZSkge1xuICB0aGlzLl9saXN0ID0gbmV3IExpbmtlZExpc3QoKTtcbiAgdGhpcy5fbWFwID0ge307XG4gIHRoaXMuX21heFNpemUgPSBtYXhTaXplIHx8IDEwO1xuICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbnVsbDtcbn07XG5cbnZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0gIHt9IHZhbHVlXG4gKiBAcmV0dXJuIHt9IFJlbW92ZWQgdmFsdWVcbiAqL1xuXG5MUlVQcm90by5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gIHZhciByZW1vdmVkID0gbnVsbDtcblxuICBpZiAobWFwW2tleV0gPT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBsaXN0LmxlbigpOyAvLyBSZXVzZSBsYXN0IHJlbW92ZWQgZW50cnlcblxuICAgIHZhciBlbnRyeSA9IHRoaXMuX2xhc3RSZW1vdmVkRW50cnk7XG5cbiAgICBpZiAobGVuID49IHRoaXMuX21heFNpemUgJiYgbGVuID4gMCkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkXG4gICAgICB2YXIgbGVhc3RVc2VkRW50cnkgPSBsaXN0LmhlYWQ7XG4gICAgICBsaXN0LnJlbW92ZShsZWFzdFVzZWRFbnRyeSk7XG4gICAgICBkZWxldGUgbWFwW2xlYXN0VXNlZEVudHJ5LmtleV07XG4gICAgICByZW1vdmVkID0gbGVhc3RVc2VkRW50cnkudmFsdWU7XG4gICAgICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbGVhc3RVc2VkRW50cnk7XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeSA9IG5ldyBFbnRyeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZW50cnkua2V5ID0ga2V5O1xuICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIG1hcFtrZXldID0gZW50cnk7XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlZDtcbn07XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHt9XG4gKi9cblxuXG5MUlVQcm90by5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX21hcFtrZXldO1xuICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG5cbiAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAvLyBQdXQgdGhlIGxhdGVzdCB1c2VkIGVudHJ5IGluIHRoZSB0YWlsXG4gICAgaWYgKGVudHJ5ICE9PSBsaXN0LnRhaWwpIHtcbiAgICAgIGxpc3QucmVtb3ZlKGVudHJ5KTtcbiAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgfVxufTtcbi8qKlxuICogQ2xlYXIgdGhlIGNhY2hlXG4gKi9cblxuXG5MUlVQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fbGlzdC5jbGVhcigpO1xuXG4gIHRoaXMuX21hcCA9IHt9O1xufTtcblxudmFyIF9kZWZhdWx0ID0gTFJVO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0xSVS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9MUlUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY3VydmUgPSByZXF1aXJlKFwiLi9jdXJ2ZVwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBiYm94ID0gcmVxdWlyZShcIi4vYmJveFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgZHByID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG4vKipcbiAqIFBhdGgg5Luj55CG77yM5Y+v5Lul5ZyoYGJ1aWxkUGF0aGDkuK3nlKjkuo7mm7/ku6NgY3R4YCwg5Lya5L+d5a2Y5q+P5LiqcGF0aOaTjeS9nOeahOWRveS7pOWIsHBhdGhDb21tYW5kc+WxnuaAp+S4rVxuICog5Y+v5Lul55So5LqOIGlzSW5zaWRlUGF0aCDliKTmlq3ku6Xlj4rojrflj5Zib3VuZGluZ1JlY3RcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBhdXRob3IgWWkgU2hlbiAoaHR0cDovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbi8vIFRPRE8gZ2V0VG90YWxMZW5ndGgsIGdldFBvaW50QXRMZW5ndGhcbnZhciBDTUQgPSB7XG4gIE06IDEsXG4gIEw6IDIsXG4gIEM6IDMsXG4gIFE6IDQsXG4gIEE6IDUsXG4gIFo6IDYsXG4gIC8vIFJlY3RcbiAgUjogN1xufTsgLy8gdmFyIENNRF9NRU1fU0laRSA9IHtcbi8vICAgICBNOiAzLFxuLy8gICAgIEw6IDMsXG4vLyAgICAgQzogNyxcbi8vICAgICBROiA1LFxuLy8gICAgIEE6IDksXG4vLyAgICAgUjogNSxcbi8vICAgICBaOiAxXG4vLyB9O1xuXG52YXIgbWluID0gW107XG52YXIgbWF4ID0gW107XG52YXIgbWluMiA9IFtdO1xudmFyIG1heDIgPSBbXTtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xudmFyIGhhc1R5cGVkQXJyYXkgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBQYXRoUHJveHkgPSBmdW5jdGlvbiAobm90U2F2ZURhdGEpIHtcbiAgdGhpcy5fc2F2ZURhdGEgPSAhKG5vdFNhdmVEYXRhIHx8IGZhbHNlKTtcblxuICBpZiAodGhpcy5fc2F2ZURhdGEpIHtcbiAgICAvKipcbiAgICAgKiBQYXRoIGRhdGEuIFN0b3JlZCBhcyBmbGF0IGFycmF5XG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG5cbiAgdGhpcy5fY3R4ID0gbnVsbDtcbn07XG4vKipcbiAqIOW/q+mAn+iuoeeul1BhdGjljIXlm7Tnm5LvvIjlubbkuI3mmK/mnIDlsI/ljIXlm7Tnm5LvvIlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cblBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoUHJveHksXG4gIF94aTogMCxcbiAgX3lpOiAwLFxuICBfeDA6IDAsXG4gIF95MDogMCxcbiAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gIF91eDogMCxcbiAgX3V5OiAwLFxuICBfbGVuOiAwLFxuICBfbGluZURhc2g6IG51bGwsXG4gIF9kYXNoT2Zmc2V0OiAwLFxuICBfZGFzaElkeDogMCxcbiAgX2Rhc2hTdW06IDAsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgc2V0U2NhbGU6IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgICB0aGlzLl91eCA9IG1hdGhBYnMoMSAvIGRwciAvIHN4KSB8fCAwO1xuICAgIHRoaXMuX3V5ID0gbWF0aEFicygxIC8gZHByIC8gc3kpIHx8IDA7XG4gIH0sXG4gIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3R4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGJlZ2luUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICBjdHggJiYgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eCAmJiAodGhpcy5kcHIgPSBjdHguZHByKTsgLy8gUmVzZXRcblxuICAgIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGluZURhc2gpIHtcbiAgICAgIHRoaXMuX2xpbmVEYXNoID0gbnVsbDtcbiAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuTSwgeCwgeSk7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7IC8vIHgwLCB5MCwgeGksIHlpIOaYr+iusOW9leWcqCBfZGFzaGVkWFhYWFRvIOaWueazleS4reS9v+eUqFxuICAgIC8vIHhpLCB5aSDorrDlvZXlvZPliY3ngrksIHgwLCB5MCDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeWbnuWIsOi1t+Wni+eCueOAglxuICAgIC8vIOacieWPr+iDveWcqCBiZWdpblBhdGgg5LmL5ZCO55u05o6l6LCD55SoIGxpbmVUb++8jOi/meaXtuWAmSB4MCwgeTAg6ZyA6KaBXG4gICAgLy8g5ZyoIGxpbmVUbyDmlrnms5XkuK3orrDlvZXvvIzov5nph4zlhYjkuI3ogIPomZHov5nnp43mg4XlhrXvvIxkYXNoZWQgbGluZSDkuZ/lj6rlnKggSUUxMC0g5Lit5LiN5pSv5oyBXG5cbiAgICB0aGlzLl94MCA9IHg7XG4gICAgdGhpcy5feTAgPSB5O1xuICAgIHRoaXMuX3hpID0geDtcbiAgICB0aGlzLl95aSA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBsaW5lVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGV4Y2VlZFVuaXQgPSBtYXRoQWJzKHggLSB0aGlzLl94aSkgPiB0aGlzLl91eCB8fCBtYXRoQWJzKHkgLSB0aGlzLl95aSkgPiB0aGlzLl91eSAvLyBGb3JjZSBkcmF3IHRoZSBmaXJzdCBzZWdtZW50XG4gICAgfHwgdGhpcy5fbGVuIDwgNTtcbiAgICB0aGlzLmFkZERhdGEoQ01ELkwsIHgsIHkpO1xuXG4gICAgaWYgKHRoaXMuX2N0eCAmJiBleGNlZWRVbml0KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZExpbmVUbyh4LCB5KSA6IHRoaXMuX2N0eC5saW5lVG8oeCwgeSk7XG4gICAgfVxuXG4gICAgaWYgKGV4Y2VlZFVuaXQpIHtcbiAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgIHRoaXMuX3lpID0geTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgzXG4gICAqIEBwYXJhbSAge251bWJlcn0geTNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuQywgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG5cbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIDogdGhpcy5fY3R4LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgfVxuXG4gICAgdGhpcy5feGkgPSB4MztcbiAgICB0aGlzLl95aSA9IHkzO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5RLCB4MSwgeTEsIHgyLCB5Mik7XG5cbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZFF1YWRyYXRpY1RvKHgxLCB5MSwgeDIsIHkyKSA6IHRoaXMuX2N0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgyO1xuICAgIHRoaXMuX3lpID0geTI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gY3hcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gICAqIEBwYXJhbSAge251bWJlcn0gZW5kQW5nbGVcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGFyYzogZnVuY3Rpb24gKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELkEsIGN4LCBjeSwgciwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlLCAwLCBhbnRpY2xvY2t3aXNlID8gMCA6IDEpO1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHguYXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuICAgIHRoaXMuX3hpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgdGhpcy5feWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVE9ET1xuICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIFRPRE9cbiAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgdGhpcy5hZGREYXRhKENNRC5SLCB4LCB5LCB3LCBoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlopO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feDA7XG4gICAgdmFyIHkwID0gdGhpcy5feTA7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSAmJiB0aGlzLl9kYXNoZWRMaW5lVG8oeDAsIHkwKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgwO1xuICAgIHRoaXMuX3lpID0geTA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAqIHN0cm9rZSDlkIzmoLdcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGZpbGw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBjdHggJiYgY3R4LmZpbGwoKTtcbiAgICB0aGlzLnRvU3RhdGljKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzdHJva2U6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBjdHggJiYgY3R4LnN0cm9rZSgpO1xuICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgfSxcblxuICAvKipcbiAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc2V0TGluZURhc2g6IGZ1bmN0aW9uIChsaW5lRGFzaCkge1xuICAgIGlmIChsaW5lRGFzaCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLl9saW5lRGFzaCA9IGxpbmVEYXNoO1xuICAgICAgdGhpcy5fZGFzaElkeCA9IDA7XG4gICAgICB2YXIgbGluZURhc2hTdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVEYXNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVEYXNoU3VtICs9IGxpbmVEYXNoW2ldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kYXNoU3VtID0gbGluZURhc2hTdW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGxlbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgKi9cbiAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAoISh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCA9PSBsZW4pICYmIGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmRhdGFbaV0gPSBkYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbiA9IGxlbjtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6Lev5b6EXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl8QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5Pn0gcGF0aFxuICAgKi9cbiAgYXBwZW5kUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBwYXRoID0gW3BhdGhdO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2xlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHlwZWRBcnJheSAmJiB0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICsgYXBwZW5kU2l6ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFwcGVuZFBhdGhEYXRhID0gcGF0aFtpXS5kYXRhO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFwcGVuZFBhdGhEYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHRoaXMuZGF0YVtvZmZzZXQrK10gPSBhcHBlbmRQYXRoRGF0YVtrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9sZW4gPSBvZmZzZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWhq+WFhSBQYXRoIOaVsOaNruOAglxuICAgKiDlsL3ph4/lpI3nlKjogIzkuI3nlLPmmI7mlrDnmoTmlbDnu4TjgILlpKfpg6jliIblm77lvaLph43nu5jnmoTmjIfku6TmlbDmja7plb/luqbpg73mmK/kuI3lj5jnmoTjgIJcbiAgICovXG4gIGFkZERhdGE6IGZ1bmN0aW9uIChjbWQpIHtcbiAgICBpZiAoIXRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAodGhpcy5fbGVuICsgYXJndW1lbnRzLmxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAvLyDmiYDku6XkuI3lpJ/nlKjml7bpnIDopoHmianlsZXkuIDkuKrmlrDnmoTliqjmgIHmlbDnu4RcbiAgICAgIHRoaXMuX2V4cGFuZERhdGEoKTtcblxuICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVt0aGlzLl9sZW4rK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldkNtZCA9IGNtZDtcbiAgfSxcbiAgX2V4cGFuZERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgaWYgKCEodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xlbjsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBuZWVkcyBqcyBpbXBsZW1lbnRlZCBkYXNoZWQgbGluZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25lZWRzRGFzaDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgfSxcbiAgX2Rhc2hlZExpbmVUbzogZnVuY3Rpb24gKHgxLCB5MSkge1xuICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICB2YXIgZGlzdCA9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB2YXIgeCA9IHgwO1xuICAgIHZhciB5ID0geTA7XG4gICAgdmFyIGRhc2g7XG4gICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgIHZhciBpZHg7XG4gICAgZHggLz0gZGlzdDtcbiAgICBkeSAvPSBkaXN0O1xuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgIHggLT0gb2Zmc2V0ICogZHg7XG4gICAgeSAtPSBvZmZzZXQgKiBkeTtcblxuICAgIHdoaWxlIChkeCA+IDAgJiYgeCA8PSB4MSB8fCBkeCA8IDAgJiYgeCA+PSB4MSB8fCBkeCA9PSAwICYmIChkeSA+IDAgJiYgeSA8PSB5MSB8fCBkeSA8IDAgJiYgeSA+PSB5MSkpIHtcbiAgICAgIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICBkYXNoID0gbGluZURhc2hbaWR4XTtcbiAgICAgIHggKz0gZHggKiBkYXNoO1xuICAgICAgeSArPSBkeSAqIGRhc2g7XG4gICAgICB0aGlzLl9kYXNoSWR4ID0gKGlkeCArIDEpICUgbkRhc2g7IC8vIFNraXAgcG9zaXRpdmUgb2Zmc2V0XG5cbiAgICAgIGlmIChkeCA+IDAgJiYgeCA8IHgwIHx8IGR4IDwgMCAmJiB4ID4geDAgfHwgZHkgPiAwICYmIHkgPCB5MCB8fCBkeSA8IDAgJiYgeSA+IHkwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjdHhbaWR4ICUgMiA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGR4ID49IDAgPyBtYXRoTWluKHgsIHgxKSA6IG1hdGhNYXgoeCwgeDEpLCBkeSA+PSAwID8gbWF0aE1pbih5LCB5MSkgOiBtYXRoTWF4KHksIHkxKSk7XG4gICAgfSAvLyBPZmZzZXQgZm9yIG5leHQgbGluZVRvXG5cblxuICAgIGR4ID0geCAtIHgxO1xuICAgIGR5ID0geSAtIHkxO1xuICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9LFxuICAvLyBOb3QgYWNjdXJhdGUgZGFzaGVkIGxpbmUgdG9cbiAgX2Rhc2hlZEJlemllclRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgIHZhciB0O1xuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG4gICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgIHZhciBiZXppZXJMZW4gPSAwO1xuICAgIHZhciBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgdG1wTGVuID0gMDtcblxuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICB9XG5cbiAgICBvZmZzZXQgJT0gZGFzaFN1bTsgLy8gQmV6aWVyIGFwcHJveCBsZW5ndGhcblxuICAgIGZvciAodCA9IDA7IHQgPCAxOyB0ICs9IDAuMSkge1xuICAgICAgZHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0ICsgMC4xKSAtIGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgZHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0ICsgMC4xKSAtIGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICAgICAgYmV6aWVyTGVuICs9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9IC8vIEZpbmQgaWR4IGFmdGVyIGFkZCBvZmZzZXRcblxuXG4gICAgZm9yICg7IGlkeCA8IG5EYXNoOyBpZHgrKykge1xuICAgICAgdG1wTGVuICs9IGxpbmVEYXNoW2lkeF07XG5cbiAgICAgIGlmICh0bXBMZW4gPiBvZmZzZXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdCA9ICh0bXBMZW4gLSBvZmZzZXQpIC8gYmV6aWVyTGVuO1xuXG4gICAgd2hpbGUgKHQgPD0gMSkge1xuICAgICAgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpOyAvLyBVc2UgbGluZSB0byBhcHByb3hpbWF0ZSBkYXNoZWQgYmV6aWVyXG4gICAgICAvLyBCYWQgcmVzdWx0IGlmIGRhc2ggaXMgbG9uZ1xuXG4gICAgICBpZHggJSAyID8gY3R4Lm1vdmVUbyh4LCB5KSA6IGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICB0ICs9IGxpbmVEYXNoW2lkeF0gLyBiZXppZXJMZW47XG4gICAgICBpZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICB9IC8vIEZpbmlzaCB0aGUgbGFzdCBzZWdtZW50IGFuZCBjYWxjdWxhdGUgdGhlIG5ldyBvZmZzZXRcblxuXG4gICAgaWR4ICUgMiAhPT0gMCAmJiBjdHgubGluZVRvKHgzLCB5Myk7XG4gICAgZHggPSB4MyAtIHg7XG4gICAgZHkgPSB5MyAtIHk7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIH0sXG4gIF9kYXNoZWRRdWFkcmF0aWNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgLy8gQ29udmVydCBxdWFkcmF0aWMgdG8gY3ViaWMgdXNpbmcgZGVncmVlIGVsZXZhdGlvblxuICAgIHZhciB4MyA9IHgyO1xuICAgIHZhciB5MyA9IHkyO1xuICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICB4MSA9ICh0aGlzLl94aSArIDIgKiB4MSkgLyAzO1xuICAgIHkxID0gKHRoaXMuX3lpICsgMiAqIHkxKSAvIDM7XG5cbiAgICB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgfSxcblxuICAvKipcbiAgICog6L2s5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheSDlh4/lsJHloIblhoXlrZjljaDnlKhcbiAgICogQ29udmVydCBkeW5hbWljIGFycmF5IHRvIHN0YXRpYyBGbG9hdDMyQXJyYXlcbiAgICovXG4gIHRvU3RhdGljOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuX2xlbjtcblxuICAgICAgaWYgKGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgbWluWzBdID0gbWluWzFdID0gbWluMlswXSA9IG1pbjJbMV0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIG1heFswXSA9IG1heFsxXSA9IG1heDJbMF0gPSBtYXgyWzFdID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIHhpID0gMDtcbiAgICB2YXIgeWkgPSAwO1xuICAgIHZhciB4MCA9IDA7XG4gICAgdmFyIHkwID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuXG4gICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuICAgICAgICB4MCA9IHhpO1xuICAgICAgICB5MCA9IHlpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgbWluMlswXSA9IHgwO1xuICAgICAgICAgIG1pbjJbMV0gPSB5MDtcbiAgICAgICAgICBtYXgyWzBdID0geDA7XG4gICAgICAgICAgbWF4MlsxXSA9IHkwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgYmJveC5mcm9tTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgIGJib3guZnJvbUN1YmljKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICBiYm94LmZyb21RdWFkcmF0aWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGU7IC8vIFRPRE8gQXJjIOaXi+i9rFxuXG4gICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG5cbiAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICB4MCA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgeTAgPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiYm94LmZyb21BcmMoY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTsgLy8gVXNlIGZyb21MaW5lXG5cbiAgICAgICAgICBiYm94LmZyb21MaW5lKHgwLCB5MCwgeDAgKyB3aWR0aCwgeTAgKyBoZWlnaHQsIG1pbjIsIG1heDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBVbmlvblxuXG5cbiAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgIHZlYzIubWF4KG1heCwgbWF4LCBtYXgyKTtcbiAgICB9IC8vIE5vIGRhdGFcblxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIG1pblswXSA9IG1pblsxXSA9IG1heFswXSA9IG1heFsxXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVidWlsZCBwYXRoIGZyb20gY3VycmVudCBkYXRhXG4gICAqIFJlYnVpbGQgcGF0aCB3aWxsIG5vdCBjb25zaWRlciBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmUgZGFzaC5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgcmVidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgICB2YXIgeDAsIHkwO1xuICAgIHZhciB4aSwgeWk7XG4gICAgdmFyIHgsIHk7XG4gICAgdmFyIHV4ID0gdGhpcy5fdXg7XG4gICAgdmFyIHV5ID0gdGhpcy5fdXk7XG4gICAgdmFyIGxlbiA9IHRoaXMuX2xlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgdmFyIGNtZCA9IGRbaSsrXTtcblxuICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgIC8vXG4gICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgIHhpID0gZFtpXTtcbiAgICAgICAgeWkgPSBkW2kgKyAxXTtcbiAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgeTAgPSB5aTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgIHkwID0geWkgPSBkW2krK107XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgeCA9IGRbaSsrXTtcbiAgICAgICAgICB5ID0gZFtpKytdOyAvLyBOb3QgZHJhdyB0b28gc21hbGwgc2VnIGJldHdlZW5cblxuICAgICAgICAgIGlmIChtYXRoQWJzKHggLSB4aSkgPiB1eCB8fCBtYXRoQWJzKHkgLSB5aSkgPiB1eSB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgeGkgPSB4O1xuICAgICAgICAgICAgeWkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZFtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgdmFyIHRoZXRhID0gZFtpKytdO1xuICAgICAgICAgIHZhciBkVGhldGEgPSBkW2krK107XG4gICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgZnMgPSBkW2krK107XG4gICAgICAgICAgdmFyIHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgdmFyIGlzRWxsaXBzZSA9IE1hdGguYWJzKHJ4IC0gcnkpID4gMWUtMztcbiAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcblxuICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICB4MCA9IG1hdGhDb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgIHkwID0gbWF0aFNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgeDAgPSB4aSA9IGRbaV07XG4gICAgICAgICAgeTAgPSB5aSA9IGRbaSArIDFdO1xuICAgICAgICAgIGN0eC5yZWN0KGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICB5aSA9IHkwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblBhdGhQcm94eS5DTUQgPSBDTUQ7XG52YXIgX2RlZmF1bHQgPSBQYXRoUHJveHk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB2ZWMyID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKFwiLi9jdXJ2ZVwiKTtcblxuLyoqXG4gKiBAYXV0aG9yIFlpIFNoZW4oaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG52YXIgc3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGVuZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZXh0cmVtaXR5ID0gdmVjMi5jcmVhdGUoKTtcbi8qKlxuICog5LuO6aG254K55pWw57uE5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb2ludHMg6aG254K55pWw57uEXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKi9cblxuZnVuY3Rpb24gZnJvbVBvaW50cyhwb2ludHMsIG1pbiwgbWF4KSB7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHAgPSBwb2ludHNbMF07XG4gIHZhciBsZWZ0ID0gcFswXTtcbiAgdmFyIHJpZ2h0ID0gcFswXTtcbiAgdmFyIHRvcCA9IHBbMV07XG4gIHZhciBib3R0b20gPSBwWzFdO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcCA9IHBvaW50c1tpXTtcbiAgICBsZWZ0ID0gbWF0aE1pbihsZWZ0LCBwWzBdKTtcbiAgICByaWdodCA9IG1hdGhNYXgocmlnaHQsIHBbMF0pO1xuICAgIHRvcCA9IG1hdGhNaW4odG9wLCBwWzFdKTtcbiAgICBib3R0b20gPSBtYXRoTWF4KGJvdHRvbSwgcFsxXSk7XG4gIH1cblxuICBtaW5bMF0gPSBsZWZ0O1xuICBtaW5bMV0gPSB0b3A7XG4gIG1heFswXSA9IHJpZ2h0O1xuICBtYXhbMV0gPSBib3R0b207XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21MaW5lKHgwLCB5MCwgeDEsIHkxLCBtaW4sIG1heCkge1xuICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkxKTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDEpO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MSk7XG59XG5cbnZhciB4RGltID0gW107XG52YXIgeURpbSA9IFtdO1xuLyoqXG4gKiDku47kuInpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMiwgcDMp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gKiBAcGFyYW0ge251bWJlcn0geTNcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuZnVuY3Rpb24gZnJvbUN1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluLCBtYXgpIHtcbiAgdmFyIGN1YmljRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYTtcbiAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICB2YXIgaTtcbiAgdmFyIG4gPSBjdWJpY0V4dHJlbWEoeDAsIHgxLCB4MiwgeDMsIHhEaW0pO1xuICBtaW5bMF0gPSBJbmZpbml0eTtcbiAgbWluWzFdID0gSW5maW5pdHk7XG4gIG1heFswXSA9IC1JbmZpbml0eTtcbiAgbWF4WzFdID0gLUluZmluaXR5O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHhEaW1baV0pO1xuICAgIG1pblswXSA9IG1hdGhNaW4oeCwgbWluWzBdKTtcbiAgICBtYXhbMF0gPSBtYXRoTWF4KHgsIG1heFswXSk7XG4gIH1cblxuICBuID0gY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCB5RGltKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB5RGltW2ldKTtcbiAgICBtaW5bMV0gPSBtYXRoTWluKHksIG1pblsxXSk7XG4gICAgbWF4WzFdID0gbWF0aE1heCh5LCBtYXhbMV0pO1xuICB9XG5cbiAgbWluWzBdID0gbWF0aE1pbih4MCwgbWluWzBdKTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MCwgbWF4WzBdKTtcbiAgbWluWzBdID0gbWF0aE1pbih4MywgbWluWzBdKTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MywgbWF4WzBdKTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgbWluWzFdKTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MCwgbWF4WzFdKTtcbiAgbWluWzFdID0gbWF0aE1pbih5MywgbWluWzFdKTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MywgbWF4WzFdKTtcbn1cbi8qKlxuICog5LuO5LqM6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21RdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbWluLCBtYXgpIHtcbiAgdmFyIHF1YWRyYXRpY0V4dHJlbXVtID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW07XG4gIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlLnF1YWRyYXRpY0F0OyAvLyBGaW5kIGV4dHJlbWl0aWVzLCB3aGVyZSBkZXJpdmF0aXZlIGluIHggZGltIG9yIHkgZGltIGlzIHplcm9cblxuICB2YXIgdHggPSBtYXRoTWF4KG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeDAsIHgxLCB4MiksIDEpLCAwKTtcbiAgdmFyIHR5ID0gbWF0aE1heChtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpLCAxKSwgMCk7XG4gIHZhciB4ID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdHgpO1xuICB2YXIgeSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHR5KTtcbiAgbWluWzBdID0gbWF0aE1pbih4MCwgeDIsIHgpO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MiwgeSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIHgyLCB4KTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTIsIHkpO1xufVxuLyoqXG4gKiDku47lnIblvKfkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSByeFxuICogQHBhcmFtIHtudW1iZXJ9IHJ5XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gYW50aWNsb2Nrd2lzZVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21BcmMoeCwgeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbWluLCBtYXgpIHtcbiAgdmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbiAgdmFyIHZlYzJNYXggPSB2ZWMyLm1heDtcbiAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuXG4gIGlmIChkaWZmICUgUEkyIDwgMWUtNCAmJiBkaWZmID4gMWUtNCkge1xuICAgIC8vIElzIGEgY2lyY2xlXG4gICAgbWluWzBdID0geCAtIHJ4O1xuICAgIG1pblsxXSA9IHkgLSByeTtcbiAgICBtYXhbMF0gPSB4ICsgcng7XG4gICAgbWF4WzFdID0geSArIHJ5O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXJ0WzBdID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgeDtcbiAgc3RhcnRbMV0gPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyB5O1xuICBlbmRbMF0gPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgeDtcbiAgZW5kWzFdID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIHk7XG4gIHZlYzJNaW4obWluLCBzdGFydCwgZW5kKTtcbiAgdmVjMk1heChtYXgsIHN0YXJ0LCBlbmQpOyAvLyBUaHJlc2ggdG8gWzAsIE1hdGguUEkgKiAyXVxuXG4gIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICUgUEkyO1xuXG4gIGlmIChzdGFydEFuZ2xlIDwgMCkge1xuICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICsgUEkyO1xuICB9XG5cbiAgZW5kQW5nbGUgPSBlbmRBbmdsZSAlIFBJMjtcblxuICBpZiAoZW5kQW5nbGUgPCAwKSB7XG4gICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIFBJMjtcbiAgfVxuXG4gIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUgJiYgIWFudGljbG9ja3dpc2UpIHtcbiAgICBlbmRBbmdsZSArPSBQSTI7XG4gIH0gZWxzZSBpZiAoc3RhcnRBbmdsZSA8IGVuZEFuZ2xlICYmIGFudGljbG9ja3dpc2UpIHtcbiAgICBzdGFydEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgdmFyIHRtcCA9IGVuZEFuZ2xlO1xuICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gdG1wO1xuICB9IC8vIHZhciBudW1iZXIgPSAwO1xuICAvLyB2YXIgc3RlcCA9IChhbnRpY2xvY2t3aXNlID8gLU1hdGguUEkgOiBNYXRoLlBJKSAvIDI7XG5cblxuICBmb3IgKHZhciBhbmdsZSA9IDA7IGFuZ2xlIDwgZW5kQW5nbGU7IGFuZ2xlICs9IE1hdGguUEkgLyAyKSB7XG4gICAgaWYgKGFuZ2xlID4gc3RhcnRBbmdsZSkge1xuICAgICAgZXh0cmVtaXR5WzBdID0gbWF0aENvcyhhbmdsZSkgKiByeCArIHg7XG4gICAgICBleHRyZW1pdHlbMV0gPSBtYXRoU2luKGFuZ2xlKSAqIHJ5ICsgeTtcbiAgICAgIHZlYzJNaW4obWluLCBleHRyZW1pdHksIG1pbik7XG4gICAgICB2ZWMyTWF4KG1heCwgZXh0cmVtaXR5LCBtYXgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmZyb21Qb2ludHMgPSBmcm9tUG9pbnRzO1xuZXhwb3J0cy5mcm9tTGluZSA9IGZyb21MaW5lO1xuZXhwb3J0cy5mcm9tQ3ViaWMgPSBmcm9tQ3ViaWM7XG5leHBvcnRzLmZyb21RdWFkcmF0aWMgPSBmcm9tUXVhZHJhdGljO1xuZXhwb3J0cy5mcm9tQXJjID0gZnJvbUFyYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2Jib3guanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgdjJDcmVhdGUgPSBfdmVjdG9yLmNyZWF0ZTtcbnZhciB2MkRpc3RTcXVhcmUgPSBfdmVjdG9yLmRpc3RTcXVhcmU7XG5cbi8qKlxuICog5puy57q/6L6F5Yqp5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBFUFNJTE9OID0gMWUtODtcbnZhciBFUFNJTE9OX05VTUVSSUMgPSAxZS00O1xudmFyIFRIUkVFX1NRUlQgPSBtYXRoU3FydCgzKTtcbnZhciBPTkVfVEhJUkQgPSAxIC8gMzsgLy8g5Li05pe25Y+Y6YePXG5cbnZhciBfdjAgPSB2MkNyZWF0ZSgpO1xuXG52YXIgX3YxID0gdjJDcmVhdGUoKTtcblxudmFyIF92MiA9IHYyQ3JlYXRlKCk7XG5cbmZ1bmN0aW9uIGlzQXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IC1FUFNJTE9OICYmIHZhbCA8IEVQU0lMT047XG59XG5cbmZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOWAvFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICB2YXIgb25ldCA9IDEgLSB0O1xuICByZXR1cm4gb25ldCAqIG9uZXQgKiAob25ldCAqIHAwICsgMyAqIHQgKiBwMSkgKyB0ICogdCAqICh0ICogcDMgKyAzICogb25ldCAqIHAyKTtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5a+85pWw5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICB2YXIgb25ldCA9IDEgLSB0O1xuICByZXR1cm4gMyAqICgoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXQgKyAocDMgLSBwMikgKiB0ICogdCk7XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+ague+8jOS9v+eUqOebm+mHkeWFrOW8j1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1Jvb3RBdChwMCwgcDEsIHAyLCBwMywgdmFsLCByb290cykge1xuICAvLyBFdmFsdWF0ZSByb290cyBvZiBjdWJpYyBmdW5jdGlvbnNcbiAgdmFyIGEgPSBwMyArIDMgKiAocDEgLSBwMikgLSBwMDtcbiAgdmFyIGIgPSAzICogKHAyIC0gcDEgKiAyICsgcDApO1xuICB2YXIgYyA9IDMgKiAocDEgLSBwMCk7XG4gIHZhciBkID0gcDAgLSB2YWw7XG4gIHZhciBBID0gYiAqIGIgLSAzICogYSAqIGM7XG4gIHZhciBCID0gYiAqIGMgLSA5ICogYSAqIGQ7XG4gIHZhciBDID0gYyAqIGMgLSAzICogYiAqIGQ7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgIGlmIChpc0Fyb3VuZFplcm8oYikpIHtcbiAgICAgIHJvb3RzWzBdID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHQxID0gLWMgLyBiOyAvL3QxLCB0MiwgdDMsIGIgaXMgbm90IHplcm9cblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICB2YXIgSyA9IEIgLyBBO1xuICAgICAgdmFyIHQxID0gLWIgLyBhICsgSzsgLy8gdDEsIGEgaXMgbm90IHplcm9cblxuICAgICAgdmFyIHQyID0gLUsgLyAyOyAvLyB0MiwgdDNcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgdmFyIFkxID0gQSAqIGIgKyAxLjUgKiBhICogKC1CICsgZGlzY1NxcnQpO1xuICAgICAgdmFyIFkyID0gQSAqIGIgKyAxLjUgKiBhICogKC1CIC0gZGlzY1NxcnQpO1xuXG4gICAgICBpZiAoWTEgPCAwKSB7XG4gICAgICAgIFkxID0gLW1hdGhQb3coLVkxLCBPTkVfVEhJUkQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWTEgPSBtYXRoUG93KFkxLCBPTkVfVEhJUkQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoWTIgPCAwKSB7XG4gICAgICAgIFkyID0gLW1hdGhQb3coLVkyLCBPTkVfVEhJUkQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWTIgPSBtYXRoUG93KFkyLCBPTkVfVEhJUkQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdDEgPSAoLWIgLSAoWTEgKyBZMikpIC8gKDMgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBUID0gKDIgKiBBICogYiAtIDMgKiBhICogQikgLyAoMiAqIG1hdGhTcXJ0KEEgKiBBICogQSkpO1xuICAgICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKFQpIC8gMztcbiAgICAgIHZhciBBU3FydCA9IG1hdGhTcXJ0KEEpO1xuICAgICAgdmFyIHRtcCA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciB0MSA9ICgtYiAtIDIgKiBBU3FydCAqIHRtcCkgLyAoMyAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgIHZhciB0MyA9ICgtYiArIEFTcXJ0ICogKHRtcCAtIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgIH1cblxuICAgICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+aegemZkOWAvOeahOS9jee9rlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRyZW1hXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNFeHRyZW1hKHAwLCBwMSwgcDIsIHAzLCBleHRyZW1hKSB7XG4gIHZhciBiID0gNiAqIHAyIC0gMTIgKiBwMSArIDYgKiBwMDtcbiAgdmFyIGEgPSA5ICogcDEgKyAzICogcDMgLSAzICogcDAgLSA5ICogcDI7XG4gIHZhciBjID0gMyAqIHAxIC0gMyAqIHAwO1xuICB2YXIgbiA9IDA7XG5cbiAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgIHZhciB0MSA9IC1jIC8gYjtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIGV4dHJlbWFbMF0gPSAtYiAvICgyICogYSk7XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog57uG5YiG5LiJ5qyh6LSd5aGe5bCU5puy57q/XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCBwMywgdCwgb3V0KSB7XG4gIHZhciBwMDEgPSAocDEgLSBwMCkgKiB0ICsgcDA7XG4gIHZhciBwMTIgPSAocDIgLSBwMSkgKiB0ICsgcDE7XG4gIHZhciBwMjMgPSAocDMgLSBwMikgKiB0ICsgcDI7XG4gIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICB2YXIgcDEyMyA9IChwMjMgLSBwMTIpICogdCArIHAxMjtcbiAgdmFyIHAwMTIzID0gKHAxMjMgLSBwMDEyKSAqIHQgKyBwMDEyOyAvLyBTZWcwXG5cbiAgb3V0WzBdID0gcDA7XG4gIG91dFsxXSA9IHAwMTtcbiAgb3V0WzJdID0gcDAxMjtcbiAgb3V0WzNdID0gcDAxMjM7IC8vIFNlZzFcblxuICBvdXRbNF0gPSBwMDEyMztcbiAgb3V0WzVdID0gcDEyMztcbiAgb3V0WzZdID0gcDIzO1xuICBvdXRbN10gPSBwMztcbn1cbi8qKlxuICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5LCBvdXQpIHtcbiAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICB2YXIgdDtcbiAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gIHZhciBkID0gSW5maW5pdHk7XG4gIHZhciBwcmV2O1xuICB2YXIgbmV4dDtcbiAgdmFyIGQxO1xuICB2YXIgZDI7XG4gIF92MFswXSA9IHg7XG4gIF92MFsxXSA9IHk7IC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAvLyBQRU5ESU5HXG5cbiAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBfdCk7XG4gICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgX3QpO1xuICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcblxuICAgIGlmIChkMSA8IGQpIHtcbiAgICAgIHQgPSBfdDtcbiAgICAgIGQgPSBkMTtcbiAgICB9XG4gIH1cblxuICBkID0gSW5maW5pdHk7IC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgIG5leHQgPSB0ICsgaW50ZXJ2YWw7IC8vIHQgLSBpbnRlcnZhbFxuXG4gICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgcHJldik7XG4gICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgIHQgPSBwcmV2O1xuICAgICAgZCA9IGQxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgX3YyWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgbmV4dCk7XG4gICAgICBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgIHQgPSBuZXh0O1xuICAgICAgICBkID0gZDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHRcblxuXG4gIGlmIChvdXQpIHtcbiAgICBvdXRbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgfSAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG5cblxuICByZXR1cm4gbWF0aFNxcnQoZCk7XG59XG4vKipcbiAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWAvFxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiBvbmV0ICogKG9uZXQgKiBwMCArIDIgKiB0ICogcDEpICsgdCAqIHQgKiBwMjtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5pa556iL5qC5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICB2YXIgYyA9IHAwIC0gdmFsO1xuICB2YXIgbiA9IDA7XG5cbiAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgIHZhciB0MSA9IC1jIC8gYjtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICB2YXIgdDEgPSAtYiAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgdmFyIHQxID0gKC1iICsgZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljRXh0cmVtdW0ocDAsIHAxLCBwMikge1xuICB2YXIgZGl2aWRlciA9IHAwICsgcDIgLSAyICogcDE7XG5cbiAgaWYgKGRpdmlkZXIgPT09IDApIHtcbiAgICAvLyBwMSBpcyBjZW50ZXIgb2YgcDAgYW5kIHAyXG4gICAgcmV0dXJuIDAuNTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHAwIC0gcDEpIC8gZGl2aWRlcjtcbiAgfVxufVxuLyoqXG4gKiDnu4bliIbkuozmrKHotJ3loZ7lsJTmm7Lnur9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCB0LCBvdXQpIHtcbiAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7IC8vIFNlZzBcblxuICBvdXRbMF0gPSBwMDtcbiAgb3V0WzFdID0gcDAxO1xuICBvdXRbMl0gPSBwMDEyOyAvLyBTZWcxXG5cbiAgb3V0WzNdID0gcDAxMjtcbiAgb3V0WzRdID0gcDEyO1xuICBvdXRbNV0gPSBwMjtcbn1cbi8qKlxuICog5oqV5bCE54K55Yiw5LqM5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IOaKleWwhOeCuVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHksIG91dCkge1xuICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gIHZhciB0O1xuICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgdmFyIGQgPSBJbmZpbml0eTtcbiAgX3YwWzBdID0geDtcbiAgX3YwWzFdID0geTsgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gIC8vIFBFTkRJTkdcblxuICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBfdCk7XG4gICAgdmFyIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcblxuICAgIGlmIChkMSA8IGQpIHtcbiAgICAgIHQgPSBfdDtcbiAgICAgIGQgPSBkMTtcbiAgICB9XG4gIH1cblxuICBkID0gSW5maW5pdHk7IC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICB2YXIgbmV4dCA9IHQgKyBpbnRlcnZhbDsgLy8gdCAtIGludGVydmFsXG5cbiAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBwcmV2KTtcbiAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBwcmV2KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgIHQgPSBwcmV2O1xuICAgICAgZCA9IGQxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgIF92MlswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIG5leHQpO1xuICAgICAgX3YyWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgbmV4dCk7XG4gICAgICB2YXIgZDIgPSB2MkRpc3RTcXVhcmUoX3YyLCBfdjApO1xuXG4gICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgZCA9IGQyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyB0XG5cblxuICBpZiAob3V0KSB7XG4gICAgb3V0WzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdCk7XG4gICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gIH0gLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuXG5cbiAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xufVxuXG5leHBvcnRzLmN1YmljQXQgPSBjdWJpY0F0O1xuZXhwb3J0cy5jdWJpY0Rlcml2YXRpdmVBdCA9IGN1YmljRGVyaXZhdGl2ZUF0O1xuZXhwb3J0cy5jdWJpY1Jvb3RBdCA9IGN1YmljUm9vdEF0O1xuZXhwb3J0cy5jdWJpY0V4dHJlbWEgPSBjdWJpY0V4dHJlbWE7XG5leHBvcnRzLmN1YmljU3ViZGl2aWRlID0gY3ViaWNTdWJkaXZpZGU7XG5leHBvcnRzLmN1YmljUHJvamVjdFBvaW50ID0gY3ViaWNQcm9qZWN0UG9pbnQ7XG5leHBvcnRzLnF1YWRyYXRpY0F0ID0gcXVhZHJhdGljQXQ7XG5leHBvcnRzLnF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IHF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbmV4cG9ydHMucXVhZHJhdGljUm9vdEF0ID0gcXVhZHJhdGljUm9vdEF0O1xuZXhwb3J0cy5xdWFkcmF0aWNFeHRyZW11bSA9IHF1YWRyYXRpY0V4dHJlbXVtO1xuZXhwb3J0cy5xdWFkcmF0aWNTdWJkaXZpZGUgPSBxdWFkcmF0aWNTdWJkaXZpZGU7XG5leHBvcnRzLnF1YWRyYXRpY1Byb2plY3RQb2ludCA9IHF1YWRyYXRpY1Byb2plY3RQb2ludDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cbnZhciBlbnYgPSB7fTtcblxuaWYgKHR5cGVvZiB3eCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHd4LmdldFN5c3RlbUluZm9TeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIEluIFdlaXhpbiBBcHBsaWNhdGlvblxuICBlbnYgPSB7XG4gICAgYnJvd3Nlcjoge30sXG4gICAgb3M6IHt9LFxuICAgIG5vZGU6IGZhbHNlLFxuICAgIHd4YTogdHJ1ZSxcbiAgICAvLyBXZWl4aW4gQXBwbGljYXRpb25cbiAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgc3ZnU3VwcG9ydGVkOiBmYWxzZSxcbiAgICB0b3VjaEV2ZW50c1N1cHBvcnRlZDogdHJ1ZVxuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBJbiB3b3JrZXJcbiAgZW52ID0ge1xuICAgIGJyb3dzZXI6IHt9LFxuICAgIG9zOiB7fSxcbiAgICBub2RlOiBmYWxzZSxcbiAgICB3b3JrZXI6IHRydWUsXG4gICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlXG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEluIG5vZGVcbiAgZW52ID0ge1xuICAgIGJyb3dzZXI6IHt9LFxuICAgIG9zOiB7fSxcbiAgICBub2RlOiB0cnVlLFxuICAgIHdvcmtlcjogZmFsc2UsXG4gICAgLy8gQXNzdW1lIGNhbnZhcyBpcyBzdXBwb3J0ZWRcbiAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgc3ZnU3VwcG9ydGVkOiB0cnVlXG4gIH07XG59IGVsc2Uge1xuICBlbnYgPSBkZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IGVudjsgLy8gWmVwdG8uanNcbi8vIChjKSAyMDEwLTIwMTMgVGhvbWFzIEZ1Y2hzXG4vLyBaZXB0by5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG4gIHZhciBvcyA9IHt9O1xuICB2YXIgYnJvd3NlciA9IHt9OyAvLyB2YXIgd2Via2l0ID0gdWEubWF0Y2goL1dlYltrS11pdFtcXC9dezAsMX0oW1xcZC5dKykvKTtcbiAgLy8gdmFyIGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7XG4gIC8vIHZhciBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgLy8gdmFyIGlwb2QgPSB1YS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pO1xuICAvLyB2YXIgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKTtcbiAgLy8gdmFyIHdlYm9zID0gdWEubWF0Y2goLyh3ZWJPU3xocHdPUylbXFxzXFwvXShbXFxkLl0rKS8pO1xuICAvLyB2YXIgdG91Y2hwYWQgPSB3ZWJvcyAmJiB1YS5tYXRjaCgvVG91Y2hQYWQvKTtcbiAgLy8gdmFyIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHNpbGsgPSB1YS5tYXRjaCgvU2lsa1xcLyhbXFxkLl9dKykvKTtcbiAgLy8gdmFyIGJsYWNrYmVycnkgPSB1YS5tYXRjaCgvKEJsYWNrQmVycnkpLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgcmltdGFibGV0b3MgPSB1YS5tYXRjaCgvKFJJTVxcc1RhYmxldFxcc09TKVxccyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgcGxheWJvb2sgPSB1YS5tYXRjaCgvUGxheUJvb2svKTtcbiAgLy8gdmFyIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKTtcblxuICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7IC8vIHZhciBzYWZhcmkgPSB3ZWJraXQgJiYgdWEubWF0Y2goL01vYmlsZVxcLy8pICYmICFjaHJvbWU7XG4gIC8vIHZhciB3ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSAmJiAhY2hyb21lO1xuXG4gIHZhciBpZSA9IHVhLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLykgLy8gSUUgMTEgVHJpZGVudC83LjA7IHJ2OjExLjBcbiAgfHwgdWEubWF0Y2goL1RyaWRlbnRcXC8uKz9ydjooKFtcXGQuXSspKS8pO1xuICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICB2YXIgd2VDaGF0ID0gL21pY3JvbWVzc2VuZ2VyL2kudGVzdCh1YSk7IC8vIFRvZG86IGNsZWFuIHRoaXMgdXAgd2l0aCBhIGJldHRlciBPUy9icm93c2VyIHNlcGVyYXRpb246XG4gIC8vIC0gZGlzY2VybiAobW9yZSkgYmV0d2VlbiBtdWx0aXBsZSBicm93c2VycyBvbiBhbmRyb2lkXG4gIC8vIC0gZGVjaWRlIGlmIGtpbmRsZSBmaXJlIGluIHNpbGsgbW9kZSBpcyBhbmRyb2lkIG9yIG5vdFxuICAvLyAtIEZpcmVmb3ggb24gQW5kcm9pZCBkb2Vzbid0IHNwZWNpZnkgdGhlIEFuZHJvaWQgdmVyc2lvblxuICAvLyAtIHBvc3NpYmx5IGRldmlkZSBpbiBvcywgZGV2aWNlIGFuZCBicm93c2VyIGhhc2hlc1xuICAvLyBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdO1xuICAvLyBpZiAoYW5kcm9pZCkgb3MuYW5kcm9pZCA9IHRydWUsIG9zLnZlcnNpb24gPSBhbmRyb2lkWzJdO1xuICAvLyBpZiAoaXBob25lICYmICFpcG9kKSBvcy5pb3MgPSBvcy5pcGhvbmUgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBob25lWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgLy8gaWYgKGlwYWQpIG9zLmlvcyA9IG9zLmlwYWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBhZFsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gIC8vIGlmIChpcG9kKSBvcy5pb3MgPSBvcy5pcG9kID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwb2RbM10gPyBpcG9kWzNdLnJlcGxhY2UoL18vZywgJy4nKSA6IG51bGw7XG4gIC8vIGlmICh3ZWJvcykgb3Mud2Vib3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gd2Vib3NbMl07XG4gIC8vIGlmICh0b3VjaHBhZCkgb3MudG91Y2hwYWQgPSB0cnVlO1xuICAvLyBpZiAoYmxhY2tiZXJyeSkgb3MuYmxhY2tiZXJyeSA9IHRydWUsIG9zLnZlcnNpb24gPSBibGFja2JlcnJ5WzJdO1xuICAvLyBpZiAoYmIxMCkgb3MuYmIxMCA9IHRydWUsIG9zLnZlcnNpb24gPSBiYjEwWzJdO1xuICAvLyBpZiAocmltdGFibGV0b3MpIG9zLnJpbXRhYmxldG9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHJpbXRhYmxldG9zWzJdO1xuICAvLyBpZiAocGxheWJvb2spIGJyb3dzZXIucGxheWJvb2sgPSB0cnVlO1xuICAvLyBpZiAoa2luZGxlKSBvcy5raW5kbGUgPSB0cnVlLCBvcy52ZXJzaW9uID0ga2luZGxlWzFdO1xuICAvLyBpZiAoc2lsaykgYnJvd3Nlci5zaWxrID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gc2lsa1sxXTtcbiAgLy8gaWYgKCFzaWxrICYmIG9zLmFuZHJvaWQgJiYgdWEubWF0Y2goL0tpbmRsZSBGaXJlLykpIGJyb3dzZXIuc2lsayA9IHRydWU7XG4gIC8vIGlmIChjaHJvbWUpIGJyb3dzZXIuY2hyb21lID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gY2hyb21lWzFdO1xuXG4gIGlmIChmaXJlZm94KSB7XG4gICAgYnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBmaXJlZm94WzFdO1xuICB9IC8vIGlmIChzYWZhcmkgJiYgKHVhLm1hdGNoKC9TYWZhcmkvKSB8fCAhIW9zLmlvcykpIGJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbiAgLy8gaWYgKHdlYnZpZXcpIGJyb3dzZXIud2VidmlldyA9IHRydWU7XG5cblxuICBpZiAoaWUpIHtcbiAgICBicm93c2VyLmllID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgfVxuXG4gIGlmIChlZGdlKSB7XG4gICAgYnJvd3Nlci5lZGdlID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICB9IC8vIEl0IGlzIGRpZmZpY3VsdCB0byBkZXRlY3QgV2VDaGF0IGluIFdpbiBQaG9uZSBwcmVjaXNlbHksIGJlY2F1c2UgdWEgY2FuXG4gIC8vIG5vdCBiZSBzZXQgb24gd2luIHBob25lLiBTbyB3ZSBkbyBub3QgY29uc2lkZXIgV2luIFBob25lLlxuXG5cbiAgaWYgKHdlQ2hhdCkge1xuICAgIGJyb3dzZXIud2VDaGF0ID0gdHJ1ZTtcbiAgfSAvLyBvcy50YWJsZXQgPSAhIShpcGFkIHx8IHBsYXlib29rIHx8IChhbmRyb2lkICYmICF1YS5tYXRjaCgvTW9iaWxlLykpIHx8XG4gIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvVGFibGV0LykpIHx8IChpZSAmJiAhdWEubWF0Y2goL1Bob25lLykgJiYgdWEubWF0Y2goL1RvdWNoLykpKTtcbiAgLy8gb3MucGhvbmUgID0gISEoIW9zLnRhYmxldCAmJiAhb3MuaXBvZCAmJiAoYW5kcm9pZCB8fCBpcGhvbmUgfHwgd2Vib3MgfHxcbiAgLy8gICAgIChjaHJvbWUgJiYgdWEubWF0Y2goL0FuZHJvaWQvKSkgfHwgKGNocm9tZSAmJiB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKSkgfHxcbiAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9Nb2JpbGUvKSkgfHwgKGllICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSkpO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIG9zOiBvcyxcbiAgICBub2RlOiBmYWxzZSxcbiAgICAvLyDljp/nlJ9jYW52YXPmlK/mjIHvvIzmlLnmnoHnq6/ngrnkuoZcbiAgICAvLyBjYW52YXNTdXBwb3J0ZWQgOiAhKGJyb3dzZXIuaWUgJiYgcGFyc2VGbG9hdChicm93c2VyLnZlcnNpb24pIDwgOSlcbiAgICBjYW52YXNTdXBwb3J0ZWQ6ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcbiAgICBzdmdTdXBwb3J0ZWQ6IHR5cGVvZiBTVkdSZWN0ICE9PSAndW5kZWZpbmVkJyxcbiAgICAvLyB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4gICAgLy8gSUUxMC8xMSBkb2VzIG5vdCBzdXBwb3J0IHRvdWNoIGV2ZW50LCBhbmQgTVMgRWRnZSBzdXBwb3J0cyB0aGVtIGJ1dCBub3QgYnlcbiAgICAvLyBkZWZhdWx0LCBzbyB3ZSBkb250IGNoZWNrIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyBmb3IgdGhlbSBoZXJlLlxuICAgIHRvdWNoRXZlbnRzU3VwcG9ydGVkOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIWJyb3dzZXIuaWUgJiYgIWJyb3dzZXIuZWRnZSxcbiAgICAvLyA8aHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cG9pbnRlciUyMGV2ZW50Pi5cbiAgICBwb2ludGVyRXZlbnRzU3VwcG9ydGVkOiAnb25wb2ludGVyZG93bicgaW4gd2luZG93IC8vIEZpcmVmb3ggc3VwcG9ydHMgcG9pbnRlciBidXQgbm90IGJ5IGRlZmF1bHQsIG9ubHkgTVMgYnJvd3NlcnMgYXJlIHJlbGlhYmxlIG9uIHBvaW50ZXJcbiAgICAvLyBldmVudHMgY3VycmVudGx5LiBTbyB3ZSBkb250IHVzZSB0aGF0IG9uIG90aGVyIGJyb3dzZXJzIHVubGVzcyB0ZXN0ZWQgc3VmZmljaWVudGx5LlxuICAgIC8vIEFsdGhvdWdoIElFIDEwIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnQsIGl0IHVzZSBvbGQgc3R5bGUgYW5kIGlzIGRpZmZlcmVudCBmcm9tIHRoZVxuICAgIC8vIHN0YW5kYXJkLiBTbyB3ZSBleGNsdWRlIHRoYXQuIChJRSAxMCBpcyBoYXJkbHkgdXNlZCBvbiB0b3VjaCBkZXZpY2UpXG4gICAgJiYgKGJyb3dzZXIuZWRnZSB8fCBicm93c2VyLmllICYmIGJyb3dzZXIudmVyc2lvbiA+PSAxMSkgLy8gcGFzc2l2ZVN1cHBvcnRlZDogZGV0ZWN0UGFzc2l2ZVN1cHBvcnQoKVxuXG4gIH07XG59IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZCNmZWF0dXJlLWRldGVjdGlvblxuLy8gZnVuY3Rpb24gZGV0ZWN0UGFzc2l2ZVN1cHBvcnQoKSB7XG4vLyAgICAgLy8gVGVzdCB2aWEgYSBnZXR0ZXIgaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIHNlZSBpZiB0aGUgcGFzc2l2ZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZFxuLy8gICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbi8vICAgICB0cnkge1xuLy8gICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4vLyAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBmdW5jdGlvbigpIHt9LCBvcHRzKTtcbi8vICAgICB9IGNhdGNoIChlKSB7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBzdXBwb3J0c1Bhc3NpdmU7XG4vLyB9XG5cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2Vudi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9lbnYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbmV4cG9ydHMuRGlzcGF0Y2hlciA9IEV2ZW50ZnVsO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vZW52XCIpO1xuXG4vKipcbiAqIOS6i+S7tui+heWKqeexu1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG52YXIgaXNEb21MZXZlbDIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xudmFyIE1PVVNFX0VWRU5UX1JFRyA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLztcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG4gIH07XG59IC8vIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlXG5cblxuZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0LCBjYWxjdWxhdGUpIHtcbiAgb3V0ID0gb3V0IHx8IHt9OyAvLyBBY2NvcmRpbmcgdG8gdGhlIFczQyBXb3JraW5nIERyYWZ0LCBvZmZzZXRYIGFuZCBvZmZzZXRZIHNob3VsZCBiZSByZWxhdGl2ZVxuICAvLyB0byB0aGUgcGFkZGluZyBlZGdlIG9mIHRoZSB0YXJnZXQgZWxlbWVudC4gVGhlIG9ubHkgYnJvd3NlciB1c2luZyB0aGlzIGNvbnZlbnRpb25cbiAgLy8gaXMgSUUuIFdlYmtpdCB1c2VzIHRoZSBib3JkZXIgZWRnZSwgT3BlcmEgdXNlcyB0aGUgY29udGVudCBlZGdlLCBhbmQgRmlyZUZveCBkb2VzXG4gIC8vIG5vdCBzdXBwb3J0IHRoZSBwcm9wZXJ0aWVzLlxuICAvLyAoc2VlIGh0dHA6Ly93d3cuamFja2xtb29yZS5jb20vbm90ZXMvbW91c2UtcG9zaXRpb24vKVxuICAvLyBJbiB6ciBwYWludGVyLmRvbSwgcGFkZGluZyBlZGdlIGVxdWFscyB0byBib3JkZXIgZWRnZS5cbiAgLy8gRklYTUVcbiAgLy8gV2hlbiBtb3VzZW1vdmUgZXZlbnQgdHJpZ2dlcmVkIG9uIGVjIHRvb2x0aXAsIHRhcmdldCBpcyBub3QgenIgcGFpbnRlci5kb20sIGFuZFxuICAvLyBvZmZzZXRYL1kgaXMgcmVsYXRpdmUgdG8gZS50YXJnZXQsIHdoZXJlIHRoZSBjYWxjdWxhdGlvbiBvZiB6clgvWSB2aWEgb2Zmc2V0WC9ZXG4gIC8vIGlzIHRvbyBjb21wbGV4LiBTbyBjc3MtdHJhbnNmcm9tIGRvbnQgc3VwcG9ydCBpbiB0aGlzIGNhc2UgdGVtcG9yYXJpbHkuXG5cbiAgaWYgKGNhbGN1bGF0ZSB8fCAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICB9IC8vIENhdXRpb246IEluIEZpcmVGb3gsIGxheWVyWC9sYXllclkgTW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGNsb3Nlc3QgcG9zaXRpb25lZFxuICAvLyBhbmNlc3RvciBlbGVtZW50LCBzbyB3ZSBzaG91bGQgbWFrZSBzdXJlIGVsIGlzIHBvc2l0aW9uZWQgKGUuZy4sIG5vdCBwb3NpdGlvbjpzdGF0aWMpLlxuICAvLyBCVFcxLCBXZWJraXQgZG9uJ3QgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgRkYgaW4gbm9uLXNpbXBsZSBjYXNlcyAobGlrZSBhZGRcbiAgLy8gem9vbS1mYWN0b3IsIG92ZXJmbG93IC8gb3BhY2l0eSBsYXllcnMsIHRyYW5zZm9ybXMgLi4uKVxuICAvLyBCVFcyLCAoZXYub2Zmc2V0WSB8fCBldi5wYWdlWSAtICQoZXYudGFyZ2V0KS5vZmZzZXQoKS50b3ApIGlzIG5vdCBjb3JyZWN0IGluIHByZXNlcnZlLTNkLlxuICAvLyA8aHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzg1MjMjY29tbWVudDoxND5cbiAgLy8gQlRXMywgSW4gZmYsIG9mZnNldFgvb2Zmc2V0WSBpcyBhbHdheXMgMC5cbiAgZWxzZSBpZiAoZW52LmJyb3dzZXIuZmlyZWZveCAmJiBlLmxheWVyWCAhPSBudWxsICYmIGUubGF5ZXJYICE9PSBlLm9mZnNldFgpIHtcbiAgICAgIG91dC56clggPSBlLmxheWVyWDtcbiAgICAgIG91dC56clkgPSBlLmxheWVyWTtcbiAgICB9IC8vIEZvciBJRTYrLCBjaHJvbWUsIHNhZmFyaSwgb3BlcmEuIChXaGVuIHdpbGwgZmYgc3VwcG9ydCBvZmZzZXRYPylcbiAgICBlbHNlIGlmIChlLm9mZnNldFggIT0gbnVsbCkge1xuICAgICAgICBvdXQuenJYID0gZS5vZmZzZXRYO1xuICAgICAgICBvdXQuenJZID0gZS5vZmZzZXRZO1xuICAgICAgfSAvLyBGb3Igc29tZSBvdGhlciBkZXZpY2UsIGUuZy4sIElPUyBzYWZhcmkuXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KTtcbiAgICAgICAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpIHtcbiAgLy8gVGhpcyB3ZWxsLWtub3duIG1ldGhvZCBiZWxvdyBkb2VzIG5vdCBzdXBwb3J0IGNzcyB0cmFuc2Zvcm0uXG4gIHZhciBib3ggPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuICBvdXQuenJYID0gZS5jbGllbnRYIC0gYm94LmxlZnQ7XG4gIG91dC56clkgPSBlLmNsaWVudFkgLSBib3gudG9wO1xufVxuLyoqXG4gKiDlpoLmnpzlrZjlnKjnrKzkuInmlrnltYzlhaXnmoTkuIDkuptkb23op6blj5HnmoTkuovku7bvvIzmiJZ0b3VjaOS6i+S7tu+8jOmcgOimgei9rOaNouS4gOS4i+S6i+S7tuWdkOaghy5cbiAqIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUsIGNhbGN1bGF0ZSkge1xuICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHZhciBldmVudFR5cGUgPSBlLnR5cGU7XG4gIHZhciBpc1RvdWNoID0gZXZlbnRUeXBlICYmIGV2ZW50VHlwZS5pbmRleE9mKCd0b3VjaCcpID49IDA7XG5cbiAgaWYgKCFpc1RvdWNoKSB7XG4gICAgY2xpZW50VG9Mb2NhbChlbCwgZSwgZSwgY2FsY3VsYXRlKTtcbiAgICBlLnpyRGVsdGEgPSBlLndoZWVsRGVsdGEgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgfSBlbHNlIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudFR5cGUgIT0gJ3RvdWNoZW5kJyA/IGUudGFyZ2V0VG91Y2hlc1swXSA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdG91Y2ggJiYgY2xpZW50VG9Mb2NhbChlbCwgdG91Y2gsIGUsIGNhbGN1bGF0ZSk7XG4gIH0gLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodDsgb3RoZXJ3aXNlOiAwO1xuICAvLyBTZWUgalF1ZXJ5OiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvZXZlbnQuanNcbiAgLy8gSWYgZS53aGljaCBoYXMgYmVlbiBkZWZpbmVkLCBpZiBtYXkgYmUgcmVhZG9ubHksXG4gIC8vIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvd2hpY2hcblxuXG4gIHZhciBidXR0b24gPSBlLmJ1dHRvbjtcblxuICBpZiAoZS53aGljaCA9PSBudWxsICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIE1PVVNFX0VWRU5UX1JFRy50ZXN0KGUudHlwZSkpIHtcbiAgICBlLndoaWNoID0gYnV0dG9uICYgMSA/IDEgOiBidXR0b24gJiAyID8gMyA6IGJ1dHRvbiAmIDQgPyAyIDogMDtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgLy8gUmVwcm9kdWN0IHRoZSBjb25zb2xlIHdhcm5pbmc6XG4gICAgLy8gW1Zpb2xhdGlvbl0gQWRkZWQgbm9uLXBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgdG8gYSBzY3JvbGwtYmxvY2tpbmcgPHNvbWU+IGV2ZW50LlxuICAgIC8vIENvbnNpZGVyIG1hcmtpbmcgZXZlbnQgaGFuZGxlciBhcyAncGFzc2l2ZScgdG8gbWFrZSB0aGUgcGFnZSBtb3JlIHJlc3BvbnNpdmUuXG4gICAgLy8gSnVzdCBzZXQgY29uc29sZSBsb2cgbGV2ZWw6IHZlcmJvc2UgaW4gY2hyb21lIGRldiB0b29sLlxuICAgIC8vIHRoZW4gdGhlIHdhcm5pbmcgbG9nIHdpbGwgYmUgcHJpbnRlZCB3aGVuIGFkZEV2ZW50TGlzdGVuZXIgY2FsbGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZFxuICAgIC8vIFdlIGhhdmUgbm90IHlldCBmb3VuZCBhIG5lYXQgd2F5IHRvIHVzaW5nIHBhc3NpdmUuIEJlY2F1c2UgaW4genJlbmRlciB0aGUgZG9tIGV2ZW50XG4gICAgLy8gbGlzdGVuZXIgZGVsZWdhdGUgYWxsIG9mIHRoZSB1cHBlciBldmVudHMgb2YgZWxlbWVudC4gU29tZSBvZiB0aG9zZSBldmVudHMgbmVlZFxuICAgIC8vIHRvIHByZXZlbnQgZGVmYXVsdC4gRm9yIGV4YW1wbGUsIHRoZSBmZWF0dXJlIGBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZWAgb2YgZWNoYXJ0cy5cbiAgICAvLyBCZWZvcmUgcGFzc2l2ZSBjYW4gYmUgYWRvcHRlZCwgdGhlc2UgaXNzdWVzIHNob3VsZCBiZSBjb25zaWRlcmVkOlxuICAgIC8vICgxKSBXaGV0aGVyIGFuZCBob3cgYSB6cmVuZGVyIHVzZXIgc3BlY2lmaWVzIGFuIGV2ZW50IGxpc3RlbmVyIHBhc3NpdmUuIEFuZCBieSBkZWZhdWx0LFxuICAgIC8vIHBhc3NpdmUgb3Igbm90LlxuICAgIC8vICgyKSBIb3cgdG8gdHJlYWQgdGhhdCBzb21lIHpyZW5kZXIgZXZlbnQgbGlzdGVuZXIgaXMgcGFzc2l2ZSwgYW5kIHNvbWUgaXMgbm90LiBJZlxuICAgIC8vIHdlIHVzZSBvdGhlciB3YXkgYnV0IG5vdCBwcmV2ZW50RGVmYXVsdCBvZiBtb3VzZXdoZWVsIGFuZCB0b3VjaG1vdmUsIGJyb3dzZXJcbiAgICAvLyBjb21wYXRpYmlsaXR5IHNob3VsZCBiZSBoYW5kbGVkLlxuICAgIC8vIHZhciBvcHRzID0gKGVudi5wYXNzaXZlU3VwcG9ydGVkICYmIG5hbWUgPT09ICdtb3VzZXdoZWVsJylcbiAgICAvLyAgICAgPyB7cGFzc2l2ZTogdHJ1ZX1cbiAgICAvLyAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIHRoaXJkIHBhcmFtIG9mIGVsLmFkZEV2ZW50TGlzdGVuZXIgaXMgYGNhcHR1cmU6IGZhbHNlYC5cbiAgICAvLyAgICAgOiB2b2lkIDA7XG4gICAgLy8gZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyIC8qICwgb3B0cyAqLyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgfVxufVxuLyoqXG4gKiBwcmV2ZW50RGVmYXVsdCBhbmQgc3RvcFByb3BhZ2F0aW9uLlxuICogTm90aWNlOiBkbyBub3QgZG8gdGhhdCBpbiB6cmVuZGVyLiBVcHBlciBhcHBsaWNhdGlvblxuICogZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7RXZlbnR9IGUgOiBldmVudOWvueixoVxuICovXG5cblxudmFyIHN0b3AgPSBpc0RvbUxldmVsMiA/IGZ1bmN0aW9uIChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xufSA6IGZ1bmN0aW9uIChlKSB7XG4gIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xufTtcblxuZnVuY3Rpb24gbm90TGVmdE1vdXNlKGUpIHtcbiAgLy8gSWYgZS53aGljaCBpcyB1bmRlZmluZWQsIGNvbnNpZGVyZWQgYXMgbGVmdCBtb3VzZSBldmVudC5cbiAgcmV0dXJuIGUud2hpY2ggPiAxO1xufSAvLyDlgZrlkJHkuIrlhbzlrrlcblxuXG5leHBvcnRzLmNsaWVudFRvTG9jYWwgPSBjbGllbnRUb0xvY2FsO1xuZXhwb3J0cy5ub3JtYWxpemVFdmVudCA9IG5vcm1hbGl6ZUV2ZW50O1xuZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnN0b3AgPSBzdG9wO1xuZXhwb3J0cy5ub3RMZWZ0TW91c2UgPSBub3RMZWZ0TW91c2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9ldmVudC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9ldmVudC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogenJlbmRlcjog55Sf5oiQ5ZSv5LiAaWRcbiAqXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cbnZhciBpZFN0YXJ0ID0gMHgwOTA3O1xuXG5mdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIGlkU3RhcnQrKztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIGRlYnVnTW9kZSA9IF9jb25maWcuZGVidWdNb2RlO1xuXG52YXIgbG9nID0gZnVuY3Rpb24gKCkge307XG5cbmlmIChkZWJ1Z01vZGUgPT09IDEpIHtcbiAgbG9nID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXJndW1lbnRzW2tdKTtcbiAgICB9XG4gIH07XG59IGVsc2UgaWYgKGRlYnVnTW9kZSA+IDEpIHtcbiAgbG9nID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHNba10pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIF9kZWZhdWx0ID0gbG9nO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2xvZy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9sb2cuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIDN4MuefqemYteaTjeS9nOexu1xuICogQGV4cG9ydHMgenJlbmRlci90b29sL21hdHJpeFxuICovXG52YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBBcnJheSA6IEZsb2F0MzJBcnJheTtcbi8qKlxuICogQ3JlYXRlIGEgaWRlbnRpdHkgbWF0cml4LlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoNik7XG4gIGlkZW50aXR5KG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuvue9ruefqemYteS4uuWNleS9jeefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWkjeWItuefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBtKSB7XG4gIG91dFswXSA9IG1bMF07XG4gIG91dFsxXSA9IG1bMV07XG4gIG91dFsyXSA9IG1bMl07XG4gIG91dFszXSA9IG1bM107XG4gIG91dFs0XSA9IG1bNF07XG4gIG91dFs1XSA9IG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOefqemYteebuOS5mFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0xXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bChvdXQsIG0xLCBtMikge1xuICAvLyBDb25zaWRlciBtYXRyaXgubXVsKG0sIG0yLCBtKTtcbiAgLy8gd2hlcmUgb3V0IGlzIHRoZSBzYW1lIGFzIG0yLlxuICAvLyBTbyB1c2UgdGVtcCB2YXJpYWJsZSB0byBlc2NhcGUgZXJyb3IuXG4gIHZhciBvdXQwID0gbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV07XG4gIHZhciBvdXQxID0gbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV07XG4gIHZhciBvdXQyID0gbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM107XG4gIHZhciBvdXQzID0gbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM107XG4gIHZhciBvdXQ0ID0gbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XTtcbiAgdmFyIG91dDUgPSBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdO1xuICBvdXRbMF0gPSBvdXQwO1xuICBvdXRbMV0gPSBvdXQxO1xuICBvdXRbMl0gPSBvdXQyO1xuICBvdXRbM10gPSBvdXQzO1xuICBvdXRbNF0gPSBvdXQ0O1xuICBvdXRbNV0gPSBvdXQ1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlubPnp7vlj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgdlswXTtcbiAgb3V0WzVdID0gYVs1XSArIHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaXi+i9rOWPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYWEgPSBhWzBdO1xuICB2YXIgYWMgPSBhWzJdO1xuICB2YXIgYXR4ID0gYVs0XTtcbiAgdmFyIGFiID0gYVsxXTtcbiAgdmFyIGFkID0gYVszXTtcbiAgdmFyIGF0eSA9IGFbNV07XG4gIHZhciBzdCA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjdCA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGFhICogY3QgKyBhYiAqIHN0O1xuICBvdXRbMV0gPSAtYWEgKiBzdCArIGFiICogY3Q7XG4gIG91dFsyXSA9IGFjICogY3QgKyBhZCAqIHN0O1xuICBvdXRbM10gPSAtYWMgKiBzdCArIGN0ICogYWQ7XG4gIG91dFs0XSA9IGN0ICogYXR4ICsgc3QgKiBhdHk7XG4gIG91dFs1XSA9IGN0ICogYXR5IC0gc3QgKiBhdHg7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOe8qeaUvuWPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHZ4ID0gdlswXTtcbiAgdmFyIHZ5ID0gdlsxXTtcbiAgb3V0WzBdID0gYVswXSAqIHZ4O1xuICBvdXRbMV0gPSBhWzFdICogdnk7XG4gIG91dFsyXSA9IGFbMl0gKiB2eDtcbiAgb3V0WzNdID0gYVszXSAqIHZ5O1xuICBvdXRbNF0gPSBhWzRdICogdng7XG4gIG91dFs1XSA9IGFbNV0gKiB2eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC6YCG55+p6Zi1XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICovXG5cblxuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYWEgPSBhWzBdO1xuICB2YXIgYWMgPSBhWzJdO1xuICB2YXIgYXR4ID0gYVs0XTtcbiAgdmFyIGFiID0gYVsxXTtcbiAgdmFyIGFkID0gYVszXTtcbiAgdmFyIGF0eSA9IGFbNV07XG4gIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgb3V0WzFdID0gLWFiICogZGV0O1xuICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gIG91dFszXSA9IGFhICogZGV0O1xuICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2xvbmUgYSBuZXcgbWF0cml4LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIGIgPSBjcmVhdGUoKTtcbiAgY29weShiLCBhKTtcbiAgcmV0dXJuIGI7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMubXVsID0gbXVsO1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9temljY2FyZC9ub2RlLXRpbXNvcnRcbnZhciBERUZBVUxUX01JTl9NRVJHRSA9IDMyO1xudmFyIERFRkFVTFRfTUlOX0dBTExPUElORyA9IDc7XG52YXIgREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEggPSAyNTY7XG5cbmZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gIHZhciByID0gMDtcblxuICB3aGlsZSAobiA+PSBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgIHIgfD0gbiAmIDE7XG4gICAgbiA+Pj0gMTtcbiAgfVxuXG4gIHJldHVybiBuICsgcjtcbn1cblxuZnVuY3Rpb24gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKSB7XG4gIHZhciBydW5IaSA9IGxvICsgMTtcblxuICBpZiAocnVuSGkgPT09IGhpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoY29tcGFyZShhcnJheVtydW5IaSsrXSwgYXJyYXlbbG9dKSA8IDApIHtcbiAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPCAwKSB7XG4gICAgICBydW5IaSsrO1xuICAgIH1cblxuICAgIHJldmVyc2VSdW4oYXJyYXksIGxvLCBydW5IaSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pID49IDApIHtcbiAgICAgIHJ1bkhpKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ1bkhpIC0gbG87XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VSdW4oYXJyYXksIGxvLCBoaSkge1xuICBoaS0tO1xuXG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIHQgPSBhcnJheVtsb107XG4gICAgYXJyYXlbbG8rK10gPSBhcnJheVtoaV07XG4gICAgYXJyYXlbaGktLV0gPSB0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgaWYgKHN0YXJ0ID09PSBsbykge1xuICAgIHN0YXJ0Kys7XG4gIH1cblxuICBmb3IgKDsgc3RhcnQgPCBoaTsgc3RhcnQrKykge1xuICAgIHZhciBwaXZvdCA9IGFycmF5W3N0YXJ0XTtcbiAgICB2YXIgbGVmdCA9IGxvO1xuICAgIHZhciByaWdodCA9IHN0YXJ0O1xuICAgIHZhciBtaWQ7XG5cbiAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICBtaWQgPSBsZWZ0ICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgY2FzZSAzOlxuICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgYXJyYXlbbGVmdCArIDJdID0gYXJyYXlbbGVmdCArIDFdO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGFycmF5W2xlZnQgKyAxXSA9IGFycmF5W2xlZnRdO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgYXJyYXlbbGVmdCArIG5dID0gYXJyYXlbbGVmdCArIG4gLSAxXTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFycmF5W2xlZnRdID0gcGl2b3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2FsbG9wTGVmdCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgdmFyIG9mZnNldCA9IDE7XG5cbiAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pID4gMCkge1xuICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID4gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgb2Zmc2V0ICs9IGhpbnQ7XG4gIH0gZWxzZSB7XG4gICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDw9IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgfVxuXG4gIGxhc3RPZmZzZXQrKztcblxuICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA+IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gbTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgdmFyIG9mZnNldCA9IDE7XG5cbiAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pIDwgMCkge1xuICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgfSBlbHNlIHtcbiAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+PSAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICBvZmZzZXQgKz0gaGludDtcbiAgfVxuXG4gIGxhc3RPZmZzZXQrKztcblxuICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA8IDApIHtcbiAgICAgIG9mZnNldCA9IG07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKSB7XG4gIHZhciBtaW5HYWxsb3AgPSBERUZBVUxUX01JTl9HQUxMT1BJTkc7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgdG1wU3RvcmFnZUxlbmd0aCA9IERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIO1xuICB2YXIgc3RhY2tMZW5ndGggPSAwO1xuICB2YXIgcnVuU3RhcnQ7XG4gIHZhciBydW5MZW5ndGg7XG4gIHZhciBzdGFja1NpemUgPSAwO1xuICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDIgKiBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCkge1xuICAgIHRtcFN0b3JhZ2VMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gIH1cblxuICB2YXIgdG1wID0gW107XG4gIHN0YWNrTGVuZ3RoID0gbGVuZ3RoIDwgMTIwID8gNSA6IGxlbmd0aCA8IDE1NDIgPyAxMCA6IGxlbmd0aCA8IDExOTE1MSA/IDE5IDogNDA7XG4gIHJ1blN0YXJ0ID0gW107XG4gIHJ1bkxlbmd0aCA9IFtdO1xuXG4gIGZ1bmN0aW9uIHB1c2hSdW4oX3J1blN0YXJ0LCBfcnVuTGVuZ3RoKSB7XG4gICAgcnVuU3RhcnRbc3RhY2tTaXplXSA9IF9ydW5TdGFydDtcbiAgICBydW5MZW5ndGhbc3RhY2tTaXplXSA9IF9ydW5MZW5ndGg7XG4gICAgc3RhY2tTaXplICs9IDE7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVJ1bnMoKSB7XG4gICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgaWYgKG4gPj0gMSAmJiBydW5MZW5ndGhbbiAtIDFdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuICsgMV0gfHwgbiA+PSAyICYmIHJ1bkxlbmd0aFtuIC0gMl0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gLSAxXSkge1xuICAgICAgICBpZiAocnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnVuTGVuZ3RoW25dID4gcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbWVyZ2VBdChuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICBpZiAobiA+IDAgJiYgcnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgbi0tO1xuICAgICAgfVxuXG4gICAgICBtZXJnZUF0KG4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQXQoaSkge1xuICAgIHZhciBzdGFydDEgPSBydW5TdGFydFtpXTtcbiAgICB2YXIgbGVuZ3RoMSA9IHJ1bkxlbmd0aFtpXTtcbiAgICB2YXIgc3RhcnQyID0gcnVuU3RhcnRbaSArIDFdO1xuICAgIHZhciBsZW5ndGgyID0gcnVuTGVuZ3RoW2kgKyAxXTtcbiAgICBydW5MZW5ndGhbaV0gPSBsZW5ndGgxICsgbGVuZ3RoMjtcblxuICAgIGlmIChpID09PSBzdGFja1NpemUgLSAzKSB7XG4gICAgICBydW5TdGFydFtpICsgMV0gPSBydW5TdGFydFtpICsgMl07XG4gICAgICBydW5MZW5ndGhbaSArIDFdID0gcnVuTGVuZ3RoW2kgKyAyXTtcbiAgICB9XG5cbiAgICBzdGFja1NpemUtLTtcbiAgICB2YXIgayA9IGdhbGxvcFJpZ2h0KGFycmF5W3N0YXJ0Ml0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuICAgIHN0YXJ0MSArPSBrO1xuICAgIGxlbmd0aDEgLT0gaztcblxuICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGVuZ3RoMiA9IGdhbGxvcExlZnQoYXJyYXlbc3RhcnQxICsgbGVuZ3RoMSAtIDFdLCBhcnJheSwgc3RhcnQyLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgxIDw9IGxlbmd0aDIpIHtcbiAgICAgIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MSArIGldO1xuICAgIH1cblxuICAgIHZhciBjdXJzb3IxID0gMDtcbiAgICB2YXIgY3Vyc29yMiA9IHN0YXJ0MjtcbiAgICB2YXIgZGVzdCA9IHN0YXJ0MTtcbiAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuICAgIHZhciBjb3VudDEsIGNvdW50MiwgZXhpdDtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICBjb3VudDEgPSAwO1xuICAgICAgY291bnQyID0gMDtcbiAgICAgIGV4aXQgPSBmYWxzZTtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29tcGFyZShhcnJheVtjdXJzb3IyXSwgdG1wW2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcbiAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgIGNvdW50MiA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY291bnQxID0gZ2FsbG9wUmlnaHQoYXJyYXlbY3Vyc29yMl0sIHRtcCwgY3Vyc29yMSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDE7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0ICs9IGNvdW50MTtcbiAgICAgICAgICBjdXJzb3IxICs9IGNvdW50MTtcbiAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcblxuICAgICAgICAgIGlmIChsZW5ndGgxIDw9IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY291bnQyID0gZ2FsbG9wTGVmdCh0bXBbY3Vyc29yMV0sIGFycmF5LCBjdXJzb3IyLCBsZW5ndGgyLCAwLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdCArPSBjb3VudDI7XG4gICAgICAgICAgY3Vyc29yMiArPSBjb3VudDI7XG4gICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgIH1cblxuICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG4gICAgbWluR2FsbG9wIDwgMSAmJiAobWluR2FsbG9wID0gMSk7XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlTG93IHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDIgKyBpXTtcbiAgICB9XG5cbiAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgIHZhciBjdXJzb3IyID0gbGVuZ3RoMiAtIDE7XG4gICAgdmFyIGRlc3QgPSBzdGFydDIgKyBsZW5ndGgyIC0gMTtcbiAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICB2YXIgY3VzdG9tRGVzdCA9IDA7XG4gICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgY291bnQxID0gMDtcbiAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29tcGFyZSh0bXBbY3Vyc29yMl0sIGFycmF5W2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcbiAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY291bnQxID0gbGVuZ3RoMSAtIGdhbGxvcFJpZ2h0KHRtcFtjdXJzb3IyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgbGVuZ3RoMSAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICBkZXN0IC09IGNvdW50MTtcbiAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSBjb3VudDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50MiA9IGxlbmd0aDIgLSBnYWxsb3BMZWZ0KGFycmF5W2N1cnNvcjFdLCB0bXAsIDAsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgZGVzdCAtPSBjb3VudDI7XG4gICAgICAgICAgY3Vyc29yMiAtPSBjb3VudDI7XG4gICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjIgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSB0bXBbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbmd0aDIgPD0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKF9taW5HYWxsb3AgPCAwKSB7XG4gICAgICAgIF9taW5HYWxsb3AgPSAwO1xuICAgICAgfVxuXG4gICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgfVxuXG4gICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcblxuICAgIGlmIChtaW5HYWxsb3AgPCAxKSB7XG4gICAgICBtaW5HYWxsb3AgPSAxO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLm1lcmdlUnVucyA9IG1lcmdlUnVucztcbiAgdGhpcy5mb3JjZU1lcmdlUnVucyA9IGZvcmNlTWVyZ2VSdW5zO1xuICB0aGlzLnB1c2hSdW4gPSBwdXNoUnVuO1xufVxuXG5mdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgaWYgKCFsbykge1xuICAgIGxvID0gMDtcbiAgfVxuXG4gIGlmICghaGkpIHtcbiAgICBoaSA9IGFycmF5Lmxlbmd0aDtcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSBoaSAtIGxvO1xuXG4gIGlmIChyZW1haW5pbmcgPCAyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJ1bkxlbmd0aCA9IDA7XG5cbiAgaWYgKHJlbWFpbmluZyA8IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHMgPSBuZXcgVGltU29ydChhcnJheSwgY29tcGFyZSk7XG4gIHZhciBtaW5SdW4gPSBtaW5SdW5MZW5ndGgocmVtYWluaW5nKTtcblxuICBkbyB7XG4gICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcblxuICAgIGlmIChydW5MZW5ndGggPCBtaW5SdW4pIHtcbiAgICAgIHZhciBmb3JjZSA9IHJlbWFpbmluZztcblxuICAgICAgaWYgKGZvcmNlID4gbWluUnVuKSB7XG4gICAgICAgIGZvcmNlID0gbWluUnVuO1xuICAgICAgfVxuXG4gICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgbG8gKyBmb3JjZSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgcnVuTGVuZ3RoID0gZm9yY2U7XG4gICAgfVxuXG4gICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICB0cy5tZXJnZVJ1bnMoKTtcbiAgICByZW1haW5pbmcgLT0gcnVuTGVuZ3RoO1xuICAgIGxvICs9IHJ1bkxlbmd0aDtcbiAgfSB3aGlsZSAocmVtYWluaW5nICE9PSAwKTtcblxuICB0cy5mb3JjZU1lcmdlUnVucygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL3V0aWxcbiAqL1xuLy8g55So5LqO5aSE55CGbWVyZ2Xml7bml6Dms5XpgY3ljoZEYXRl562J5a+56LGh55qE6Zeu6aKYXG52YXIgQlVJTFRJTl9PQkpFQ1QgPSB7XG4gICdbb2JqZWN0IEZ1bmN0aW9uXSc6IDEsXG4gICdbb2JqZWN0IFJlZ0V4cF0nOiAxLFxuICAnW29iamVjdCBEYXRlXSc6IDEsXG4gICdbb2JqZWN0IEVycm9yXSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJzogMSxcbiAgLy8gRm9yIG5vZGUtY2FudmFzXG4gICdbb2JqZWN0IEltYWdlXSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc10nOiAxXG59O1xudmFyIFRZUEVEX0FSUkFZID0ge1xuICAnW29iamVjdCBJbnQ4QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDhBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOiAxLFxuICAnW29iamVjdCBJbnQxNkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEludDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOiAxXG59O1xudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIG5hdGl2ZUZvckVhY2ggPSBhcnJheVByb3RvLmZvckVhY2g7XG52YXIgbmF0aXZlRmlsdGVyID0gYXJyYXlQcm90by5maWx0ZXI7XG52YXIgbmF0aXZlU2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xudmFyIG5hdGl2ZU1hcCA9IGFycmF5UHJvdG8ubWFwO1xudmFyIG5hdGl2ZVJlZHVjZSA9IGFycmF5UHJvdG8ucmVkdWNlOyAvLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxuXG52YXIgbWV0aG9kcyA9IHt9O1xuXG5mdW5jdGlvbiAkb3ZlcnJpZGUobmFtZSwgZm4pIHtcbiAgLy8gQ2xlYXIgY3R4IGluc3RhbmNlIGZvciBkaWZmZXJlbnQgZW52aXJvbm1lbnRcbiAgaWYgKG5hbWUgPT09ICdjcmVhdGVDYW52YXMnKSB7XG4gICAgX2N0eCA9IG51bGw7XG4gIH1cblxuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIFRob3NlIGRhdGEgdHlwZXMgY2FuIGJlIGNsb25lZDpcbiAqICAgICBQbGFpbiBvYmplY3QsIEFycmF5LCBUeXBlZEFycmF5LCBudW1iZXIsIHN0cmluZywgbnVsbCwgdW5kZWZpbmVkLlxuICogVGhvc2UgZGF0YSB0eXBlcyB3aWxsIGJlIGFzc2dpbmVkIHVzaW5nIHRoZSBvcmdpbmFsIGRhdGE6XG4gKiAgICAgQlVJTFRJTl9PQkpFQ1RcbiAqIEluc3RhbmNlIG9mIHVzZXIgZGVmaW5lZCBjbGFzcyB3aWxsIGJlIGNsb25lZCB0byBhIHBsYWluIG9iamVjdCwgd2l0aG91dFxuICogcHJvcGVydGllcyBpbiBwcm90b3R5cGUuXG4gKiBPdGhlciBkYXRhIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQgKG5vdCBzdXJlIHdoYXQgd2lsbCBoYXBwZW4pLlxuICpcbiAqIENhdXRpb246IGRvIG5vdCBzdXBwb3J0IGNsb25lIERhdGUsIGZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLlxuICogKFRoZXJlIG1pZ2h0IGJlIGEgbGFyZ2UgbnVtYmVyIG9mIGRhdGUgaW4gYHNlcmllcy5kYXRhYCkuXG4gKiBTbyBkYXRlIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgaW4gYW5kIG91dCBvZiBlY2hhcnRzLlxuICpcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcmV0dXJuIHsqfSBuZXdcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICB2YXIgdHlwZVN0ciA9IG9ialRvU3RyaW5nLmNhbGwoc291cmNlKTtcblxuICBpZiAodHlwZVN0ciA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIGlmICghaXNQcmltaXRpdmUoc291cmNlKSkge1xuICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlbdHlwZVN0cl0pIHtcbiAgICBpZiAoIWlzUHJpbWl0aXZlKHNvdXJjZSkpIHtcbiAgICAgIHZhciBDdG9yID0gc291cmNlLmNvbnN0cnVjdG9yO1xuXG4gICAgICBpZiAoc291cmNlLmNvbnN0cnVjdG9yLmZyb20pIHtcbiAgICAgICAgcmVzdWx0ID0gQ3Rvci5mcm9tKHNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgQ3Rvcihzb3VyY2UubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghQlVJTFRJTl9PQkpFQ1RbdHlwZVN0cl0gJiYgIWlzUHJpbWl0aXZlKHNvdXJjZSkgJiYgIWlzRG9tKHNvdXJjZSkpIHtcbiAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpIHtcbiAgLy8gV2Ugc2hvdWxkIGVzY2Fwc2UgdGhhdCBzb3VyY2UgaXMgc3RyaW5nXG4gIC8vIGFuZCBlbnRlciBmb3IgLi4uIGluIC4uLlxuICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkgfHwgIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gb3ZlcndyaXRlID8gY2xvbmUoc291cmNlKSA6IHRhcmdldDtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XG4gICAgICB2YXIgc291cmNlUHJvcCA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcCkgJiYgaXNPYmplY3QodGFyZ2V0UHJvcCkgJiYgIWlzQXJyYXkoc291cmNlUHJvcCkgJiYgIWlzQXJyYXkodGFyZ2V0UHJvcCkgJiYgIWlzRG9tKHNvdXJjZVByb3ApICYmICFpc0RvbSh0YXJnZXRQcm9wKSAmJiAhaXNCdWlsdEluT2JqZWN0KHNvdXJjZVByb3ApICYmICFpc0J1aWx0SW5PYmplY3QodGFyZ2V0UHJvcCkgJiYgIWlzUHJpbWl0aXZlKHNvdXJjZVByb3ApICYmICFpc1ByaW1pdGl2ZSh0YXJnZXRQcm9wKSkge1xuICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxuICAgICAgICBtZXJnZSh0YXJnZXRQcm9wLCBzb3VyY2VQcm9wLCBvdmVyd3JpdGUpO1xuICAgICAgfSBlbHNlIGlmIChvdmVyd3JpdGUgfHwgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XG4gICAgICAgIC8vIE5PVEXvvIzlnKggdGFyZ2V0W2tleV0g5LiN5a2Y5Zyo55qE5pe25YCZ5Lmf5piv55u05o6l6KaG55uWXG4gICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc291cmNlW2tleV0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldEFuZFNvdXJjZXMgVGhlIGZpcnN0IGl0ZW0gaXMgdGFyZ2V0LCBhbmQgdGhlIHJlc3RzIGFyZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gKiBAcmV0dXJuIHsqfSB0YXJnZXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlQWxsKHRhcmdldEFuZFNvdXJjZXMsIG92ZXJ3cml0ZSkge1xuICB2YXIgcmVzdWx0ID0gdGFyZ2V0QW5kU291cmNlc1swXTtcblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGFyZ2V0QW5kU291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgdGFyZ2V0QW5kU291cmNlc1tpXSwgb3ZlcndyaXRlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVybGF5PWZhbHNlXVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbWV0aG9kcy5jcmVhdGVDYW52YXMoKTtcbn07XG5cbm1ldGhvZHMuY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG59OyAvLyBGSVhNRVxuXG5cbnZhciBfY3R4O1xuXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBpZiAoIV9jdHgpIHtcbiAgICAvLyBVc2UgdXRpbC5jcmVhdGVDYW52YXMgaW5zdGVhZCBvZiBjcmVhdGVDYW52YXNcbiAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgX2N0eCA9IGNyZWF0ZUNhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG4gIH1cblxuICByZXR1cm4gX2N0eDtcbn1cbi8qKlxuICog5p+l6K+i5pWw57uE5Lit5YWD57Sg55qEaW5kZXhcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gIGlmIChhcnJheSkge1xuICAgIGlmIChhcnJheS5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbi8qKlxuICog5p6E6YCg57G757un5om/5YWz57O7XG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XG4gKi9cblxuXG5mdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XG4gIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBGKCkge31cblxuICBGLnByb3RvdHlwZSA9IGJhc2VDbGF6ei5wcm90b3R5cGU7XG4gIGNsYXp6LnByb3RvdHlwZSA9IG5ldyBGKCk7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBjbGF6elByb3RvdHlwZSkge1xuICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xuICB9XG5cbiAgY2xhenoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xheno7XG4gIGNsYXp6LnN1cGVyQ2xhc3MgPSBiYXNlQ2xheno7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBzb3JjZVxuICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gKi9cblxuXG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICB0YXJnZXQgPSAncHJvdG90eXBlJyBpbiB0YXJnZXQgPyB0YXJnZXQucHJvdG90eXBlIDogdGFyZ2V0O1xuICBzb3VyY2UgPSAncHJvdG90eXBlJyBpbiBzb3VyY2UgPyBzb3VyY2UucHJvdG90eXBlIDogc291cmNlO1xuICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG59XG4vKipcbiAqIENvbnNpZGVyIHR5cGVkIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5TGlrZShkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgZGF0YS5sZW5ndGggPT0gJ251bWJlcic7XG59XG4vKipcbiAqIOaVsOe7hOaIluWvueixoemBjeWOhlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKi9cblxuXG5mdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiDmlbDnu4TmmKDlsIRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLm1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICByZXR1cm4gb2JqLm1hcChjYiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IFttZW1vXVxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gcmVkdWNlKG9iaiwgY2IsIG1lbW8sIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmoucmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgIHJldHVybiBvYmoucmVkdWNlKGNiLCBtZW1vLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtZW1vID0gY2IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH1cbn1cbi8qKlxuICog5pWw57uE6L+H5rukXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBmaWx0ZXIob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5maWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSB7XG4gICAgcmV0dXJuIG9iai5maWx0ZXIoY2IsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICByZXN1bHQucHVzaChvYmpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8qKlxuICog5pWw57uE6aG55p+l5om+XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmQob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgcmV0dXJuIG9ialtpXTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHsqfSBjb250ZXh0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmQoZnVuYywgY29udGV4dCkge1xuICB2YXIgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuXG5mdW5jdGlvbiBjdXJyeShmdW5jKSB7XG4gIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0J1aWx0SW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICEhQlVJTFRJTl9PQkpFQ1Rbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiAhIVRZUEVEX0FSUkFZW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRG9tKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLm93bmVyRG9jdW1lbnQgPT09ICdvYmplY3QnO1xufVxuLyoqXG4gKiBXaGV0aGVyIGlzIGV4YWN0bHkgTmFOLiBOb3RpY2UgaXNOYU4oJ2EnKSByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gZXFOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cbi8qKlxuICogSWYgdmFsdWUxIGlzIG5vdCBudWxsLCB0aGVuIHJldHVybiB2YWx1ZTEsIG90aGVyd2lzZSBqdWRnZXQgcmVzdCBvZiB2YWx1ZXMuXG4gKiBMb3cgcGVyZm9ybWFuY2UuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcmV0dXJuIHsqfSBGaW5hbCB2YWx1ZVxuICovXG5cblxuZnVuY3Rpb24gcmV0cmlldmUodmFsdWVzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXJndW1lbnRzW2ldICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHNbaV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlMih2YWx1ZTAsIHZhbHVlMSkge1xuICByZXR1cm4gdmFsdWUwICE9IG51bGwgPyB2YWx1ZTAgOiB2YWx1ZTE7XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlMyh2YWx1ZTAsIHZhbHVlMSwgdmFsdWUyKSB7XG4gIHJldHVybiB2YWx1ZTAgIT0gbnVsbCA/IHZhbHVlMCA6IHZhbHVlMSAhPSBudWxsID8gdmFsdWUxIDogdmFsdWUyO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kSW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gc2xpY2UoKSB7XG4gIHJldHVybiBGdW5jdGlvbi5jYWxsLmFwcGx5KG5hdGl2ZVNsaWNlLCBhcmd1bWVudHMpO1xufVxuLyoqXG4gKiBOb3JtYWxpemUgY3NzIGxpa2VkIGFycmF5IGNvbmZpZ3VyYXRpb25cbiAqIGUuZy5cbiAqICAzID0+IFszLCAzLCAzLCAzXVxuICogIFs0LCAyXSA9PiBbNCwgMiwgNCwgMl1cbiAqICBbNCwgMywgMl0gPT4gWzQsIDMsIDIsIDNdXG4gKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gdmFsXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNzc0FycmF5KHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWwsIHZhbF07XG4gIH1cblxuICB2YXIgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gdmVydGljYWwgfCBob3Jpem9udGFsXG4gICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzBdLCB2YWxbMV1dO1xuICB9IGVsc2UgaWYgKGxlbiA9PT0gMykge1xuICAgIC8vIHRvcCB8IGhvcml6b250YWwgfCBib3R0b21cbiAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMl0sIHZhbFsxXV07XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmRpdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gYmUgdHJpbWVkXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRyaW1lZCBzdHJpbmdcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIGlmIChzdHIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdHIudHJpbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzdHIudHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcbiAgfVxufVxuXG52YXIgcHJpbWl0aXZlS2V5ID0gJ19fZWNfcHJpbWl0aXZlX18nO1xuLyoqXG4gKiBTZXQgYW4gb2JqZWN0IGFzIHByaW1pdGl2ZSB0byBiZSBpZ25vcmVkIHRyYXZlcnNpbmcgY2hpbGRyZW4gaW4gY2xvbmUgb3IgbWVyZ2VcbiAqL1xuXG5mdW5jdGlvbiBzZXRBc1ByaW1pdGl2ZShvYmopIHtcbiAgb2JqW3ByaW1pdGl2ZUtleV0gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgcmV0dXJuIG9ialtwcmltaXRpdmVLZXldO1xufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT25seSBhcHBseSBgb3duUHJvcGVydHlgLlxuICovXG5cblxuZnVuY3Rpb24gSGFzaE1hcChvYmopIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheShvYmopO1xuICB2YXIgdGhpc01hcCA9IHRoaXM7XG4gIG9iaiBpbnN0YW5jZW9mIEhhc2hNYXAgPyBvYmouZWFjaCh2aXNpdCkgOiBvYmogJiYgZWFjaChvYmosIHZpc2l0KTtcblxuICBmdW5jdGlvbiB2aXNpdCh2YWx1ZSwga2V5KSB7XG4gICAgaXNBcnIgPyB0aGlzTWFwLnNldCh2YWx1ZSwga2V5KSA6IHRoaXNNYXAuc2V0KGtleSwgdmFsdWUpO1xuICB9XG59IC8vIEFkZCBwcmVmaXggdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlLlxuXG5cbkhhc2hNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFzaE1hcCxcbiAgLy8gRG8gbm90IHByb3ZpZGUgYGhhc2AgbWV0aG9kIHRvIGF2b2lkIGRlZmluaW5nIHdoYXQgaXMgYGhhc2AuXG4gIC8vIChXZSB1c3VhbGx5IHRyZWF0IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXMgdGhlIHNhbWUsIGRpZmZlcmVudFxuICAvLyBmcm9tIEVTNiBNYXApLlxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gdGhpc1trZXldIDogbnVsbDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIC8vIENvbXBhcmluZyB3aXRoIGludm9jYXRpb24gY2hhaW5pbmcsIGByZXR1cm4gdmFsdWVgIGlzIG1vcmUgY29tbW9ubHlcbiAgICAvLyB1c2VkIGluIHRoaXMgY2FzZTogYHZhciBzb21lVmFsID0gbWFwLnNldCgnYScsIGdlblZhbCgpKTtgXG4gICAgcmV0dXJuIHRoaXNba2V5XSA9IHZhbHVlO1xuICB9LFxuICAvLyBBbHRob3VnaCB1dGlsLmVhY2ggY2FuIGJlIHBlcmZvcm1lZCBvbiB0aGlzIGhhc2hNYXAgZGlyZWN0bHksIHVzZXJcbiAgLy8gc2hvdWxkIG5vdCB1c2UgdGhlIGV4cG9zZWQga2V5cywgd2hvIGFyZSBwcmVmaXhlZC5cbiAgZWFjaDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgY29udGV4dCAhPT0gdm9pZCAwICYmIChjYiA9IGJpbmQoY2IsIGNvbnRleHQpKTtcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB7XG4gICAgICB0aGlzLmhhc093blByb3BlcnR5KGtleSkgJiYgY2IodGhpc1trZXldLCBrZXkpO1xuICAgIH1cbiAgfSxcbiAgLy8gRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpZiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIHJlbW92ZUtleTogZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hNYXAob2JqKSB7XG4gIHJldHVybiBuZXcgSGFzaE1hcChvYmopO1xufVxuXG5mdW5jdGlvbiBjb25jYXRBcnJheShhLCBiKSB7XG4gIHZhciBuZXdBcnJheSA9IG5ldyBhLmNvbnN0cnVjdG9yKGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIG5ld0FycmF5W2ldID0gYVtpXTtcbiAgfVxuXG4gIHZhciBvZmZzZXQgPSBhLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgIG5ld0FycmF5W2kgKyBvZmZzZXRdID0gYltpXTtcbiAgfVxuXG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydHMuJG92ZXJyaWRlID0gJG92ZXJyaWRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5leHBvcnRzLmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbmV4cG9ydHMuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XG5leHBvcnRzLmluZGV4T2YgPSBpbmRleE9mO1xuZXhwb3J0cy5pbmhlcml0cyA9IGluaGVyaXRzO1xuZXhwb3J0cy5taXhpbiA9IG1peGluO1xuZXhwb3J0cy5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuZXhwb3J0cy5lYWNoID0gZWFjaDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2U7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG5leHBvcnRzLmJpbmQgPSBiaW5kO1xuZXhwb3J0cy5jdXJyeSA9IGN1cnJ5O1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzQnVpbHRJbk9iamVjdCA9IGlzQnVpbHRJbk9iamVjdDtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuZXhwb3J0cy5pc0RvbSA9IGlzRG9tO1xuZXhwb3J0cy5lcU5hTiA9IGVxTmFOO1xuZXhwb3J0cy5yZXRyaWV2ZSA9IHJldHJpZXZlO1xuZXhwb3J0cy5yZXRyaWV2ZTIgPSByZXRyaWV2ZTI7XG5leHBvcnRzLnJldHJpZXZlMyA9IHJldHJpZXZlMztcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMubm9ybWFsaXplQ3NzQXJyYXkgPSBub3JtYWxpemVDc3NBcnJheTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy50cmltID0gdHJpbTtcbmV4cG9ydHMuc2V0QXNQcmltaXRpdmUgPSBzZXRBc1ByaW1pdGl2ZTtcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcbmV4cG9ydHMuY3JlYXRlSGFzaE1hcCA9IGNyZWF0ZUhhc2hNYXA7XG5leHBvcnRzLmNvbmNhdEFycmF5ID0gY29uY2F0QXJyYXk7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS91dGlsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gQXJyYXkgOiBGbG9hdDMyQXJyYXk7XG4vKipcbiAqIOWIm+W7uuS4gOS4quWQkemHj1xuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG5cbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHggPSAwO1xuICB9XG5cbiAgaWYgKHkgPT0gbnVsbCkge1xuICAgIHkgPSAwO1xuICB9XG5cbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5aSN5Yi25ZCR6YeP5pWw5o2uXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5YWL6ZqG5LiA5Liq5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZSh2KSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorr7nva7lkJHph4/nmoTkuKTkuKrpoblcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9IOe7k+aenFxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nm7jliqBcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP57yp5pS+5ZCO55u45YqgXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgdjEsIHYyLCBhKSB7XG4gIG91dFswXSA9IHYxWzBdICsgdjJbMF0gKiBhO1xuICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdICogYTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP55u45YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gc3ViKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdIC0gdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdIC0gdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+mVv+W6plxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBsZW4odikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGxlblNxdWFyZSh2KSk7XG59XG5cbnZhciBsZW5ndGggPSBsZW47IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vKipcbiAqIOWQkemHj+mVv+W6puW5s+aWuVxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gbGVuU3F1YXJlKHYpIHtcbiAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV07XG59XG5cbnZhciBsZW5ndGhTcXVhcmUgPSBsZW5TcXVhcmU7XG4vKipcbiAqIOWQkemHj+S5mOazlVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5mdW5jdGlvbiBtdWwob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gKiB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gKiB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP6Zmk5rOVXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gZGl2KG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdIC8gdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdIC8gdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+eCueS5mFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZG90KHYxLCB2Mikge1xuICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG59XG4vKipcbiAqIOWQkemHj+e8qeaUvlxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHBhcmFtIHtudW1iZXJ9IHNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgdiwgcykge1xuICBvdXRbMF0gPSB2WzBdICogcztcbiAgb3V0WzFdID0gdlsxXSAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+W9kuS4gOWMllxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgdikge1xuICB2YXIgZCA9IGxlbih2KTtcblxuICBpZiAoZCA9PT0gMCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSB2WzBdIC8gZDtcbiAgICBvdXRbMV0gPSB2WzFdIC8gZDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuoeeul+WQkemHj+mXtOi3neemu1xuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UodjEsIHYyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pKTtcbn1cblxudmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICog5ZCR6YeP6Led56a75bmz5pa5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gZGlzdGFuY2VTcXVhcmUodjEsIHYyKSB7XG4gIHJldHVybiAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSkgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSk7XG59XG5cbnZhciBkaXN0U3F1YXJlID0gZGlzdGFuY2VTcXVhcmU7XG4vKipcbiAqIOaxgui0n+WQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICovXG5cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIHYpIHtcbiAgb3V0WzBdID0gLXZbMF07XG4gIG91dFsxXSA9IC12WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmj5LlgLzkuKTkuKrngrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICovXG5cblxuZnVuY3Rpb24gbGVycChvdXQsIHYxLCB2MiwgdCkge1xuICBvdXRbMF0gPSB2MVswXSArIHQgKiAodjJbMF0gLSB2MVswXSk7XG4gIG91dFsxXSA9IHYxWzFdICsgdCAqICh2MlsxXSAtIHYxWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog55+p6Zi15bem5LmY5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKG91dCwgdiwgbSkge1xuICB2YXIgeCA9IHZbMF07XG4gIHZhciB5ID0gdlsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLkuKTkuKrlkJHph4/mnIDlsI/lgLxcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBtaW4ob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4odjFbMF0sIHYyWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4odjFbMV0sIHYyWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC5Lik5Liq5ZCR6YeP5pyA5aSn5YC8XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KHYxWzBdLCB2MlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KHYxWzFdLCB2MlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnNjYWxlQW5kQWRkID0gc2NhbGVBbmRBZGQ7XG5leHBvcnRzLnN1YiA9IHN1YjtcbmV4cG9ydHMubGVuID0gbGVuO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmxlblNxdWFyZSA9IGxlblNxdWFyZTtcbmV4cG9ydHMubGVuZ3RoU3F1YXJlID0gbGVuZ3RoU3F1YXJlO1xuZXhwb3J0cy5tdWwgPSBtdWw7XG5leHBvcnRzLmRpdiA9IGRpdjtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmRpc3QgPSBkaXN0O1xuZXhwb3J0cy5kaXN0YW5jZVNxdWFyZSA9IGRpc3RhbmNlU3F1YXJlO1xuZXhwb3J0cy5kaXN0U3F1YXJlID0gZGlzdFNxdWFyZTtcbmV4cG9ydHMubmVnYXRlID0gbmVnYXRlO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMuYXBwbHlUcmFuc2Zvcm0gPSBhcHBseVRyYW5zZm9ybTtcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS92ZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9ldmVudCA9IHJlcXVpcmUoXCIuLi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IF9ldmVudC5hZGRFdmVudExpc3RlbmVyO1xudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBfZXZlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbnZhciBub3JtYWxpemVFdmVudCA9IF9ldmVudC5ub3JtYWxpemVFdmVudDtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuLi9taXhpbi9FdmVudGZ1bFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuLi9jb3JlL2VudlwiKTtcblxudmFyIEdlc3R1cmVNZ3IgPSByZXF1aXJlKFwiLi4vY29yZS9HZXN0dXJlTWdyXCIpO1xuXG52YXIgVE9VQ0hfQ0xJQ0tfREVMQVkgPSAzMDA7XG52YXIgbW91c2VIYW5kbGVyTmFtZXMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J107XG52YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJ107XG52YXIgcG9pbnRlckV2ZW50TmFtZXMgPSB7XG4gIHBvaW50ZXJkb3duOiAxLFxuICBwb2ludGVydXA6IDEsXG4gIHBvaW50ZXJtb3ZlOiAxLFxuICBwb2ludGVyb3V0OiAxXG59O1xudmFyIHBvaW50ZXJIYW5kbGVyTmFtZXMgPSB6clV0aWwubWFwKG1vdXNlSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgbm0gPSBuYW1lLnJlcGxhY2UoJ21vdXNlJywgJ3BvaW50ZXInKTtcbiAgcmV0dXJuIHBvaW50ZXJFdmVudE5hbWVzW25tXSA/IG5tIDogbmFtZTtcbn0pO1xuXG5mdW5jdGlvbiBldmVudE5hbWVGaXgobmFtZSkge1xuICByZXR1cm4gbmFtZSA9PT0gJ21vdXNld2hlZWwnICYmIGVudi5icm93c2VyLmZpcmVmb3ggPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0dlc3R1cmUocHJveHksIGV2ZW50LCBzdGFnZSkge1xuICB2YXIgZ2VzdHVyZU1nciA9IHByb3h5Ll9nZXN0dXJlTWdyO1xuICBzdGFnZSA9PT0gJ3N0YXJ0JyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG4gIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKGV2ZW50LCBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCkudGFyZ2V0LCBwcm94eS5kb20pO1xuICBzdGFnZSA9PT0gJ2VuZCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpOyAvLyBEbyBub3QgZG8gYW55IHByZXZlbnREZWZhdWx0IGhlcmUuIFVwcGVyIGFwcGxpY2F0aW9uIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuXG4gIGlmIChnZXN0dXJlSW5mbykge1xuICAgIHZhciB0eXBlID0gZ2VzdHVyZUluZm8udHlwZTtcbiAgICBldmVudC5nZXN0dXJlRXZlbnQgPSB0eXBlO1xuICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoe1xuICAgICAgdGFyZ2V0OiBnZXN0dXJlSW5mby50YXJnZXRcbiAgICB9LCB0eXBlLCBnZXN0dXJlSW5mby5ldmVudCk7XG4gIH1cbn0gLy8gZnVuY3Rpb24gb25NU0dlc3R1cmVDaGFuZ2UocHJveHksIGV2ZW50KSB7XG4vLyAgICAgaWYgKGV2ZW50LnRyYW5zbGF0aW9uWCB8fCBldmVudC50cmFuc2xhdGlvblkpIHtcbi8vICAgICAgICAgLy8gbW91c2Vtb3ZlIGlzIGNhcnJpZWQgYnkgTVNHZXN0dXJlIHRvIHJlZHVjZSB0aGUgc2Vuc2l0aXZpdHkuXG4vLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuLy8gICAgIH1cbi8vICAgICBpZiAoZXZlbnQuc2NhbGUgIT09IDEpIHtcbi8vICAgICAgICAgZXZlbnQucGluY2hYID0gZXZlbnQub2Zmc2V0WDtcbi8vICAgICAgICAgZXZlbnQucGluY2hZID0gZXZlbnQub2Zmc2V0WTtcbi8vICAgICAgICAgZXZlbnQucGluY2hTY2FsZSA9IGV2ZW50LnNjYWxlO1xuLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ3BpbmNoJywgZXZlbnQpO1xuLy8gICAgIH1cbi8vIH1cblxuLyoqXG4gKiBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCBhZnRlciBUb3VjaCBFdmVudHMgYWN0aW9uXG4gKiBAc2VlIDxodHRwczovL2dpdGh1Yi5jb20vZGVsdGFrb3NoL2hhbmRqcy9ibG9iL21hc3Rlci9zcmMvaGFuZC5iYXNlLmpzPlxuICogMS4gTW9iaWxlIGJyb3dzZXJzIGRpc3BhdGNoIG1vdXNlIGV2ZW50cyAzMDBtcyBhZnRlciB0b3VjaGVuZC5cbiAqIDIuIENocm9tZSBmb3IgQW5kcm9pZCBkaXNwYXRjaCBtb3VzZWRvd24gZm9yIGxvbmctdG91Y2ggYWJvdXQgNjUwbXNcbiAqIFJlc3VsdDogQmxvY2tpbmcgTW91c2UgRXZlbnRzIGZvciA3MDBtcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRvdWNoVGltZXIoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UuX3RvdWNoaW5nID0gdHJ1ZTtcbiAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLl90b3VjaFRpbWVyKTtcbiAgaW5zdGFuY2UuX3RvdWNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0YW5jZS5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgfSwgNzAwKTtcbn1cblxudmFyIGRvbUhhbmRsZXJzID0ge1xuICAvKipcbiAgICogTW91c2UgbW92ZSBoYW5kbGVyXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdXNlIG91dCBoYW5kbGVyXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgaWYgKGVsZW1lbnQgIT0gdGhpcy5kb20pIHtcbiAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSkge1xuICAgICAgICAvLyDlv73nlaXljIXlkKvlnKhyb2905Lit55qEZG9t5byV6LW355qEbW91c2VPdXRcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ21vdXNlb3V0JywgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb3VjaOW8gOWni+WTjeW6lOWHveaVsFxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIERlZmF1bHQgbW91c2UgYmVoYXZpb3VyIHNob3VsZCBub3QgYmUgZGlzYWJsZWQgaGVyZS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTsgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgIC8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuXG4gICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcbiAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPSBuZXcgRGF0ZSgpO1xuICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnc3RhcnQnKTsgLy8gSW4gdG91Y2ggZGV2aWNlLCB0cmlnZ2VyIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBzaG91bGRcbiAgICAvLyBiZSB0cmlnZ2VyZWQsIGFuZCBtdXN0IGJlZm9yZSBgbW91c2Vkb3duYCB0cmlnZ2VyZWQuXG5cbiAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNo56e75Yqo5ZON5bqU5Ye95pWwXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgdG91Y2htb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7IC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cblxuICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG4gICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdjaGFuZ2UnKTsgLy8gTW91c2UgbW92ZSBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQsIGJlY2F1c2UgbW91c2UgbW92ZSBhbmQgcGluY2ggbWF5XG4gICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuXG4gICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNo57uT5p2f5ZON5bqU5Ye95pWwXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTsgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgIC8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuXG4gICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcbiAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2VuZCcpO1xuICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7IC8vIERvIG5vdCB0cmlnZ2VyIGBtb3VzZW91dGAgaGVyZSwgaW4gc3BpdGUgb2YgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIGlzXG4gICAgLy8gdHJpZ2dlcmVkIGluIGB0b3VjaHN0YXJ0YC4gVGhpcyBzZWVtcyB0byBiZSBpbGxvZ2ljYWwsIGJ1dCBieSB0aGlzIG1lY2hhbmlzbSxcbiAgICAvLyB3ZSBjYW4gY29udmVuaWVudGx5IGltcGxlbWVudCBcImhvdmVyIHN0eWxlXCIgaW4gYm90aCBQQyBhbmQgdG91Y2ggZGV2aWNlIGp1c3RcbiAgICAvLyBieSBsaXN0ZW5pbmcgdG8gYG1vdXNlb3ZlcmAgdG8gYWRkIFwiaG92ZXIgc3R5bGVcIiBhbmQgbGlzdGVuaW5nIHRvIGBtb3VzZW91dGBcbiAgICAvLyB0byByZW1vdmUgXCJob3ZlciBzdHlsZVwiIG9uIGFuIGVsZW1lbnQsIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgY29kZSBmb3JcbiAgICAvLyBjb21wYXRpYmlsaXR5LiAoYG1vdXNlb3V0YCB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgaW4gYHRvdWNoZW5kYCwgc28gXCJob3ZlclxuICAgIC8vIHN0eWxlXCIgd2lsbCByZW1haW4gZm9yIHVzZXIgdmlldylcbiAgICAvLyBjbGljayBldmVudCBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cblxuICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICBkb21IYW5kbGVycy5jbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICB9LFxuICBwb2ludGVyZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpOyAvLyBpZiAodXNlTVNHdWVzdHVyZSh0aGlzLCBldmVudCkpIHtcbiAgICAvLyAgICAgdGhpcy5fbXNHZXN0dXJlLmFkZFBvaW50ZXIoZXZlbnQucG9pbnRlcklkKTtcbiAgICAvLyB9XG4gIH0sXG4gIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIHBvaW50ZXJtb3ZlIGlzIHNvIHNlbnNpdGl2ZSB0aGF0IGl0IGFsd2F5cyB0cmlnZ2VyZWQgd2hlblxuICAgIC8vIHRhcChjbGljaykgb24gdG91Y2ggc2NyZWVuLCB3aGljaCBhZmZlY3Qgc29tZSBqdWRnZW1lbnQgaW5cbiAgICAvLyB1cHBlciBhcHBsaWNhdGlvbi4gU28sIHdlIGRvbnQgc3VwcG9ydCBtb3VzZW1vdmUgb24gTVMgdG91Y2hcbiAgICAvLyBkZXZpY2UgeWV0LlxuICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgcG9pbnRlcnVwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBkb21IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpO1xuICB9LFxuICBwb2ludGVyb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBwb2ludGVyb3V0IHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGFwIG9uIHRvdWNoIHNjcmVlblxuICAgIC8vIChJRTExKy9FZGdlIG9uIE1TIFN1cmZhY2UpIGFmdGVyIGNsaWNrIGV2ZW50IHRyaWdnZXJlZCxcbiAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgbW91c291dCBiZWhhdmlvciB3ZSBkZWZpbmVkXG4gICAgLy8gaW4gdG91Y2hlbmQuIFNvIHdlIHVuaWZ5IHRoZW0uXG4gICAgLy8gKGNoZWNrIGRvbUhhbmRsZXJzLnRvdWNoZW5kIGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbilcbiAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgIGRvbUhhbmRsZXJzLm1vdXNlb3V0LmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSB7XG4gIHZhciBwb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICByZXR1cm4gcG9pbnRlclR5cGUgPT09ICdwZW4nIHx8IHBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xufSAvLyBmdW5jdGlvbiB1c2VNU0d1ZXN0dXJlKGhhbmRsZXJQcm94eSwgZXZlbnQpIHtcbi8vICAgICByZXR1cm4gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSAmJiAhIWhhbmRsZXJQcm94eS5fbXNHZXN0dXJlO1xuLy8gfVxuLy8gQ29tbW9uIGhhbmRsZXJzXG5cblxuenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHRoaXMudHJpZ2dlcihuYW1lLCBldmVudCk7XG4gIH07XG59KTtcbi8qKlxuICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAqL1xuXG5mdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICB6clV0aWwuZWFjaCh0b3VjaEhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICB9KTtcbiAgenJVdGlsLmVhY2gocG9pbnRlckhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICB9KTtcbiAgenJVdGlsLmVhY2gobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0gbWFrZU1vdXNlSGFuZGxlcihkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICB9KTtcblxuICBmdW5jdGlvbiBtYWtlTW91c2VIYW5kbGVyKGZuLCBpbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuX3RvdWNoaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gSGFuZGxlckRvbVByb3h5KGRvbSkge1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICB0aGlzLmRvbSA9IGRvbTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuICB0aGlzLl90b3VjaGluZyA9IGZhbHNlO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fdG91Y2hUaW1lcjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0dlc3R1cmVNZ3J9XG4gICAqL1xuXG4gIHRoaXMuX2dlc3R1cmVNZ3IgPSBuZXcgR2VzdHVyZU1ncigpO1xuICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICBpbml0RG9tSGFuZGxlcih0aGlzKTtcblxuICBpZiAoZW52LnBvaW50ZXJFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAvLyBPbmx5IElFMTErL0VkZ2VcbiAgICAvLyAxLiBPbiBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIChlLmcuLCBNUyBTdXJmYWNlIGFuZCBsZW5vdm8gWDI0MCksXG4gICAgLy8gSUUxMSsvRWRnZSBkbyBub3QgdHJpZ2dlciB0b3VjaCBldmVudCwgYnV0IHRyaWdnZXIgcG9pbnRlciBldmVudCBhbmQgbW91c2UgZXZlbnRcbiAgICAvLyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIDIuIE9uIE1TIFN1cmZhY2UsIGl0IHByb2JhYmxlbHkgb25seSB0cmlnZ2VyIG1vdXNlZG93biBidXQgbm8gbW91c2V1cCB3aGVuIHRhcCBvblxuICAgIC8vIHNjcmVlbiwgd2hpY2ggZG8gbm90IG9jY3VycyBpbiBwb2ludGVyIGV2ZW50LlxuICAgIC8vIFNvIHdlIHVzZSBwb2ludGVyIGV2ZW50IHRvIGJvdGggZGV0ZWN0IHRvdWNoIGdlc3R1cmUgYW5kIG1vdXNlIGJlaGF2aW9yLlxuICAgIG1vdW50SGFuZGxlcnMocG9pbnRlckhhbmRsZXJOYW1lcywgdGhpcyk7IC8vIEZJWE1FXG4gICAgLy8gTm90ZTogTVMgR2VzdHVyZSByZXF1aXJlIENTUyB0b3VjaC1hY3Rpb24gc2V0LiBCdXQgdG91Y2gtYWN0aW9uIGlzIG5vdCByZWxpYWJsZSxcbiAgICAvLyB3aGljaCBkb2VzIG5vdCBwcmV2ZW50IGRlZnVhdWx0IGJlaGF2aW9yIG9jY2FzaW9uYWxseSAod2hpY2ggbWF5IGNhdXNlIHZpZXcgcG9ydFxuICAgIC8vIHpvb21lZCBpbiBidXQgdXNlIGNhbiBub3Qgem9vbSBpdCBiYWNrKS4gQW5kIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgZG9lcyBub3Qgd29yay5cbiAgICAvLyBTbyB3ZSBoYXZlIHRvIG5vdCB0byB1c2UgTVNHZXN0dXJlIGFuZCBub3QgdG8gc3VwcG9ydCB0b3VjaG1vdmUgYW5kIHBpbmNoIG9uIE1TXG4gICAgLy8gdG91Y2ggc2NyZWVuLiBBbmQgd2Ugb25seSBzdXBwb3J0IGNsaWNrIGJlaGF2aW9yIG9uIE1TIHRvdWNoIHNjcmVlbiBub3cuXG4gICAgLy8gTVMgR2VzdHVyZSBFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBJRTExKy9FZGdlIGFuZCBvbiBXaW5kb3dzIDgrLlxuICAgIC8vIFdlIGRvbnQgc3VwcG9ydCB0b3VjaCBvbiBJRSBvbiB3aW43LlxuICAgIC8vIFNlZSA8aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0Myh2PXZzLjg1KS5hc3B4PlxuICAgIC8vIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgICh0aGlzLl9tc0dlc3R1cmUgPSBuZXcgTVNHZXN0dXJlKCkpLnRhcmdldCA9IGRvbTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgLy8gICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCdNU0dlc3R1cmVDaGFuZ2UnLCBvbk1TR2VzdHVyZUNoYW5nZSk7XG4gICAgLy8gfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbnYudG91Y2hFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAgIG1vdW50SGFuZGxlcnModG91Y2hIYW5kbGVyTmFtZXMsIHRoaXMpOyAvLyBIYW5kbGVyIG9mICdtb3VzZW91dCcgZXZlbnQgaXMgbmVlZGVkIGluIHRvdWNoIG1vZGUsIHdoaWNoIHdpbGwgYmUgbW91bnRlZCBiZWxvdy5cbiAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICB9IC8vIDEuIENvbnNpZGVyaW5nIHNvbWUgZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSBldmVudCAobGlrZSBvbiBNUyBTdXJmYWNlXG4gICAgLy8gYW5kIGxlbm92byBYMjQwLCBAc2VlICMyMzUwKSwgd2UgbWFrZSBtb3VzZSBldmVudCBiZSBhbHdheXMgbGlzdGVuZWQsIG90aGVyd2lzZVxuICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgQ2hyb21lIHdpbGwgdHJpZ2dlciBib3RoIHRvdWNoIGV2ZW50IGFuZCBtb3VzZSBldmVudC4gSG93IHRvIHByZXZlbnRcbiAgICAvLyBtb3VzZWV2ZW50IGFmdGVyIHRvdWNoIGV2ZW50IHRyaWdnZXJlZCwgc2VlIGBzZXRUb3VjaFRpbWVyYC5cblxuXG4gICAgbW91bnRIYW5kbGVycyhtb3VzZUhhbmRsZXJOYW1lcywgdGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEhhbmRsZXJzKGhhbmRsZXJOYW1lcywgaW5zdGFuY2UpIHtcbiAgICB6clV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGRvbSwgZXZlbnROYW1lRml4KG5hbWUpLCBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0pO1xuICAgIH0sIGluc3RhbmNlKTtcbiAgfVxufVxuXG52YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuXG5oYW5kbGVyRG9tUHJveHlQcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGFuZGxlck5hbWVzID0gbW91c2VIYW5kbGVyTmFtZXMuY29uY2F0KHRvdWNoSGFuZGxlck5hbWVzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gaGFuZGxlck5hbWVzW2ldO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICB9XG59O1xuXG5oYW5kbGVyRG9tUHJveHlQcm90by5zZXRDdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgdGhpcy5kb20uc3R5bGUgJiYgKHRoaXMuZG9tLnN0eWxlLmN1cnNvciA9IGN1cnNvclN0eWxlIHx8ICdkZWZhdWx0Jyk7XG59O1xuXG56clV0aWwubWl4aW4oSGFuZGxlckRvbVByb3h5LCBFdmVudGZ1bCk7XG52YXIgX2RlZmF1bHQgPSBIYW5kbGVyRG9tUHJveHk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5cbi8vIENvbXBvdW5kUGF0aCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdjb21wb3VuZCcsXG4gIHNoYXBlOiB7XG4gICAgcGF0aHM6IG51bGxcbiAgfSxcbiAgX3VwZGF0ZVBhdGhEaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXJ0eVBhdGggPSB0aGlzLl9fZGlydHlQYXRoO1xuICAgIHZhciBwYXRocyA9IHRoaXMuc2hhcGUucGF0aHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBNYXJrIGFzIGRpcnR5IGlmIGFueSBzdWJwYXRoIGlzIGRpcnR5XG4gICAgICBkaXJ0eVBhdGggPSBkaXJ0eVBhdGggfHwgcGF0aHNbaV0uX19kaXJ0eVBhdGg7XG4gICAgfVxuXG4gICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICB0aGlzLl9fZGlydHkgPSB0aGlzLl9fZGlydHkgfHwgZGlydHlQYXRoO1xuICB9LFxuICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuXG4gICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocyB8fCBbXTtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7IC8vIFVwZGF0ZSBwYXRoIHNjYWxlXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXBhdGhzW2ldLnBhdGgpIHtcbiAgICAgICAgcGF0aHNbaV0uY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICB9XG5cbiAgICAgIHBhdGhzW2ldLnBhdGguc2V0U2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdKTtcbiAgICB9XG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgcGF0aHMgPSBzaGFwZS5wYXRocyB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhdGhzW2ldLmJ1aWxkUGF0aChjdHgsIHBhdGhzW2ldLnNoYXBlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgcGF0aHNbaV0uX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuXG4gICAgcmV0dXJuIFBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdC5jYWxsKHRoaXMpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0NvbXBvdW5kUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vU3R5bGVcIik7XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZShcIi4uL0VsZW1lbnRcIik7XG5cbnZhciBSZWN0VGV4dCA9IHJlcXVpcmUoXCIuL21peGluL1JlY3RUZXh0XCIpO1xuXG4vKipcbiAqIOWPr+e7mOWItueahOWbvuW9ouWfuuexu1xuICogQmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheWFibGUgZ3JhcGhpYyBvYmplY3RzXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcbiAqL1xuZnVuY3Rpb24gRGlzcGxheWFibGUob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpOyAvLyBFeHRlbmQgcHJvcGVydGllc1xuXG4gIGZvciAodmFyIG5hbWUgaW4gb3B0cykge1xuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUgIT09ICdzdHlsZScpIHtcbiAgICAgIHRoaXNbbmFtZV0gPSBvcHRzW25hbWVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9XG4gICAqL1xuXG5cbiAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShvcHRzLnN0eWxlLCB0aGlzKTtcbiAgdGhpcy5fcmVjdCA9IG51bGw7IC8vIFNoYXBlcyBmb3IgY2FzY2FkZSBjbGlwcGluZy5cblxuICB0aGlzLl9fY2xpcFBhdGhzID0gW107IC8vIEZJWE1FIFN0YXRlZnVsIG11c3QgYmUgbWl4aW5lZCBhZnRlciBzdHlsZSBpcyBzZXR0ZWRcbiAgLy8gU3RhdGVmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuRGlzcGxheWFibGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGxheWFibGUsXG4gIHR5cGU6ICdkaXNwbGF5YWJsZScsXG5cbiAgLyoqXG4gICAqIERpc3BsYXlhYmxlIOaYr+WQpuS4uuiEj++8jFBhaW50ZXIg5Lit5Lya5qC55o2u6K+l5qCH6K6w5Yik5pat5piv5ZCm6ZyA6KaB5piv5ZCm6ZyA6KaB6YeN5paw57uY5Yi2XG4gICAqIERpcnR5IGZsYWcuIEZyb20gd2hpY2ggcGFpbnRlciB3aWxsIGRldGVybWluZSBpZiB0aGlzIGRpc3BsYXlhYmxlIG9iamVjdCBuZWVkcyBicnVzaFxuICAgKiBAbmFtZSBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI19fZGlydHlcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBfX2RpcnR5OiB0cnVlLFxuXG4gIC8qKlxuICAgKiDlm77lvaLmmK/lkKblj6/op4HvvIzkuLp0cnVl5pe25LiN57uY5Yi25Zu+5b2i77yM5L2G5piv5LuN6IO96Kem5Y+R6byg5qCH5LqL5Lu2XG4gICAqIElmIGlnbm9yZSBkcmF3aW5nIG9mIHRoZSBkaXNwbGF5YWJsZSBvYmplY3QuIE1vdXNlIGV2ZW50IHdpbGwgc3RpbGwgYmUgdHJpZ2dlcmVkXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2ludmlzaWJsZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGludmlzaWJsZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgejogMCxcblxuICAvKipcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB6MjogMCxcblxuICAvKipcbiAgICogeuWxgmxldmVs77yM5Yaz5a6a57uY55S75Zyo5ZOq5bGCY2FudmFz5LitXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3psZXZlbFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB6bGV2ZWw6IDAsXG5cbiAgLyoqXG4gICAqIOaYr+WQpuWPr+aLluaLvVxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDmmK/lkKbmraPlnKjmi5bmi71cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDmmK/lkKbnm7jlupTpvKDmoIfkuovku7ZcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjc2lsZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogSWYgZW5hYmxlIGN1bGxpbmdcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBjdWxsaW5nOiBmYWxzZSxcblxuICAvKipcbiAgICogTW91c2UgY3Vyc29yIHdoZW4gaG92ZXJlZFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNjdXJzb3JcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuXG4gIC8qKlxuICAgKiBJZiBob3ZlciBhcmVhIGlzIGJvdW5kaW5nIHJlY3RcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjcmVjdEhvdmVyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICByZWN0SG92ZXI6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgcHJvZ3Jlc3NpdmVseSB3aGVuIHRoZSB2YWx1ZSA+PSAwLFxuICAgKiB1c2VmdWxsIGZvciBsYXJnZSBkYXRhLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHByb2dyZXNzaXZlOiBmYWxzZSxcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBpbmNyZW1lbnRhbDogZmFsc2UsXG4gIC8vIGlucGxhY2UgaXMgdXNlZCB3aXRoIGluY3JlbWVudGFsXG4gIGlucGxhY2U6IGZhbHNlLFxuICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG4gIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuXG4gIC8qKlxuICAgKiDlm77lvaLnu5jliLbmlrnms5VcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgLy8gSW50ZXJmYWNlXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHt9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmnIDlsI/ljIXlm7Tnm5JcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICAvLyBJbnRlcmZhY2VcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i5LiKXG4gICAqIElmIGRpc3BsYXlhYmxlIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMucmVjdENvbnRhaW4oeCwgeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9oueahOWMheWbtOebkuS4ilxuICAgKiBJZiBib3VuZGluZyByZWN0IG9mIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHJlY3RDb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBjb29yZCA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICByZXR1cm4gcmVjdC5jb250YWluKGNvb3JkWzBdLCBjb29yZFsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOagh+iusOWbvuW9ouWFg+e0oOS4uuiEj++8jOW5tuS4lOWcqOS4i+S4gOW4p+mHjee7mFxuICAgKiBNYXJrIGRpc3BsYXlhYmxlIGVsZW1lbnQgZGlydHkgYW5kIHJlZnJlc2ggbmV4dCBmcmFtZVxuICAgKi9cbiAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlm77lvaLmmK/lkKbkvJrop6blj5Hkuovku7ZcbiAgICogSWYgZGlzcGxheWFibGUgb2JqZWN0IGJpbmRlZCBhbnkgZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIC8vIFRPRE8sIOmAmui/hyBiaW5kIOe7keWumueahOS6i+S7tlxuICAvLyBpc1NpbGVudDogZnVuY3Rpb24gKCkge1xuICAvLyAgICAgcmV0dXJuICEoXG4gIC8vICAgICAgICAgdGhpcy5ob3ZlcmFibGUgfHwgdGhpcy5kcmFnZ2FibGVcbiAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vtb3ZlIHx8IHRoaXMub25tb3VzZW92ZXIgfHwgdGhpcy5vbm1vdXNlb3V0XG4gIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlZG93biB8fCB0aGlzLm9ubW91c2V1cCB8fCB0aGlzLm9uY2xpY2tcbiAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJhZ2VudGVyIHx8IHRoaXMub25kcmFnb3ZlciB8fCB0aGlzLm9uZHJhZ2xlYXZlXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbmRyb3BcbiAgLy8gICAgICk7XG4gIC8vIH0sXG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBhbmltYXRlKCdzdHlsZScpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgKi9cbiAgYW5pbWF0ZVN0eWxlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3N0eWxlJywgbG9vcCk7XG4gIH0sXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ICE9PSAnc3R5bGUnKSB7XG4gICAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHlsZS5zZXQodmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zdHlsZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZSBnaXZlbiBzdHlsZSBvYmplY3RcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAgICovXG4gIHVzZVN0eWxlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShvYmosIHRoaXMpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKERpc3BsYXlhYmxlLCBFbGVtZW50KTtcbnpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgUmVjdFRleHQpOyAvLyB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFN0YXRlZnVsKTtcblxudmFyIF9kZWZhdWx0ID0gRGlzcGxheWFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqL1xudmFyIEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yU3RvcHMpIHtcbiAgdGhpcy5jb2xvclN0b3BzID0gY29sb3JTdG9wcyB8fCBbXTtcbn07XG5cbkdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyYWRpZW50LFxuICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uIChvZmZzZXQsIGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvaW1hZ2VcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5mdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5aSW1hZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuICB0eXBlOiAnaW1hZ2UnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7IC8vIE11c3QgYmluZCBlYWNoIHRpbWVcblxuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShzcmMsIHRoaXMuX2ltYWdlLCB0aGlzLCB0aGlzLm9ubG9hZCk7XG5cbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlm77niYflt7Lnu4/liqDovb3lrozmiJBcbiAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gRWxzZSBpcyBjYW52YXNcblxuXG4gICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIH0gLy8g6K6+572udHJhbnNmb3JtXG5cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gLy8gRHJhdyByZWN0IHRleHRcblxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgLy8gT25seSByZXN0b3JlIHRyYW5zZm9ybSB3aGVuIG5lZWRzIGRyYXcgdGV4dC5cbiAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBaSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaW5oZXJpdHMgPSBfdXRpbC5pbmhlcml0cztcblxudmFyIERpc3BsYXlibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxuLyoqXG4gKiBEaXNwbGF5YWJsZSBmb3IgaW5jcmVtZW50YWwgcmVuZGVyaW5nLiBJdCB3aWxsIGJlIHJlbmRlcmVkIGluIGEgc2VwYXJhdGUgbGF5ZXJcbiAqIEluY3JlbWVudGFsRGlzcGxheSBoYXZlIHRvbyBtYWluIG1ldGhvZHMuIGBjbGVhckRpc3BsYXlhYmxlc2AgYW5kIGBhZGREaXNwbGF5YWJsZXNgXG4gKiBhZGREaXNwbGF5YWJsZXMgd2lsbCByZW5kZXIgdGhlIGFkZGVkIGRpc3BsYXlhYmxlcyBpbmNyZW1ldGFsbHkuXG4gKlxuICogSXQgdXNlIGEgbm90IGNsZWFyRmxhZyB0byB0ZWxsIHRoZSBwYWludGVyIGRvbid0IGNsZWFyIHRoZSBsYXllciBpZiBpdCdzIHRoZSBmaXJzdCBlbGVtZW50LlxuICovXG4vLyBUT0RPIFN0eWxlIG92ZXJyaWRlID9cbmZ1bmN0aW9uIEluY3JlbWVudGFsRGlzcGxheWJsZShvcHRzKSB7XG4gIERpc3BsYXlibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgdGhpcy5fZGlzcGxheWFibGVzID0gW107XG4gIHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlcyA9IFtdO1xuICB0aGlzLl9jdXJzb3IgPSAwO1xuICB0aGlzLm5vdENsZWFyID0gdHJ1ZTtcbn1cblxuSW5jcmVtZW50YWxEaXNwbGF5YmxlLnByb3RvdHlwZS5pbmNyZW1lbnRhbCA9IHRydWU7XG5cbkluY3JlbWVudGFsRGlzcGxheWJsZS5wcm90b3R5cGUuY2xlYXJEaXNwbGF5YmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGlzcGxheWFibGVzID0gW107XG4gIHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlcyA9IFtdO1xuICB0aGlzLl9jdXJzb3IgPSAwO1xuICB0aGlzLmRpcnR5KCk7XG4gIHRoaXMubm90Q2xlYXIgPSBmYWxzZTtcbn07XG5cbkluY3JlbWVudGFsRGlzcGxheWJsZS5wcm90b3R5cGUuYWRkRGlzcGxheWFibGUgPSBmdW5jdGlvbiAoZGlzcGxheWFibGUsIG5vdFBlcnNpc3RlbnQpIHtcbiAgaWYgKG5vdFBlcnNpc3RlbnQpIHtcbiAgICB0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXMucHVzaChkaXNwbGF5YWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGlzcGxheWFibGVzLnB1c2goZGlzcGxheWFibGUpO1xuICB9XG5cbiAgdGhpcy5kaXJ0eSgpO1xufTtcblxuSW5jcmVtZW50YWxEaXNwbGF5YmxlLnByb3RvdHlwZS5hZGREaXNwbGF5YWJsZXMgPSBmdW5jdGlvbiAoZGlzcGxheWFibGVzLCBub3RQZXJzaXN0ZW50KSB7XG4gIG5vdFBlcnNpc3RlbnQgPSBub3RQZXJzaXN0ZW50IHx8IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5hZGREaXNwbGF5YWJsZShkaXNwbGF5YWJsZXNbaV0sIG5vdFBlcnNpc3RlbnQpO1xuICB9XG59O1xuXG5JbmNyZW1lbnRhbERpc3BsYXlibGUucHJvdG90eXBlLmVhY2hQZW5kaW5nRGlzcGxheWFibGUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuX2N1cnNvcjsgaSA8IHRoaXMuX2Rpc3BsYXlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNiICYmIGNiKHRoaXMuX2Rpc3BsYXlhYmxlc1tpXSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNiICYmIGNiKHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlc1tpXSk7XG4gIH1cbn07XG5cbkluY3JlbWVudGFsRGlzcGxheWJsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gIGZvciAodmFyIGkgPSB0aGlzLl9jdXJzb3I7IGkgPCB0aGlzLl9kaXNwbGF5YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlzcGxheWFibGUgPSB0aGlzLl9kaXNwbGF5YWJsZXNbaV07IC8vIFBFTkRJTkdcblxuICAgIGRpc3BsYXlhYmxlLnBhcmVudCA9IHRoaXM7XG4gICAgZGlzcGxheWFibGUudXBkYXRlKCk7XG4gICAgZGlzcGxheWFibGUucGFyZW50ID0gbnVsbDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpc3BsYXlhYmxlID0gdGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzW2ldOyAvLyBQRU5ESU5HXG5cbiAgICBkaXNwbGF5YWJsZS5wYXJlbnQgPSB0aGlzO1xuICAgIGRpc3BsYXlhYmxlLnVwZGF0ZSgpO1xuICAgIGRpc3BsYXlhYmxlLnBhcmVudCA9IG51bGw7XG4gIH1cbn07XG5cbkluY3JlbWVudGFsRGlzcGxheWJsZS5wcm90b3R5cGUuYnJ1c2ggPSBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgLy8gUmVuZGVyIHBlcnNpc3RhbnQgZGlzcGxheWFibGVzLlxuICBmb3IgKHZhciBpID0gdGhpcy5fY3Vyc29yOyBpIDwgdGhpcy5fZGlzcGxheWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpc3BsYXlhYmxlID0gdGhpcy5fZGlzcGxheWFibGVzW2ldO1xuICAgIGRpc3BsYXlhYmxlLmJlZm9yZUJydXNoICYmIGRpc3BsYXlhYmxlLmJlZm9yZUJydXNoKGN0eCk7XG4gICAgZGlzcGxheWFibGUuYnJ1c2goY3R4LCBpID09PSB0aGlzLl9jdXJzb3IgPyBudWxsIDogdGhpcy5fZGlzcGxheWFibGVzW2kgLSAxXSk7XG4gICAgZGlzcGxheWFibGUuYWZ0ZXJCcnVzaCAmJiBkaXNwbGF5YWJsZS5hZnRlckJydXNoKGN0eCk7XG4gIH1cblxuICB0aGlzLl9jdXJzb3IgPSBpOyAvLyBSZW5kZXIgdGVtcG9yYXJ5IGRpc3BsYXlhYmxlcy5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaXNwbGF5YWJsZSA9IHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlc1tpXTtcbiAgICBkaXNwbGF5YWJsZS5iZWZvcmVCcnVzaCAmJiBkaXNwbGF5YWJsZS5iZWZvcmVCcnVzaChjdHgpO1xuICAgIGRpc3BsYXlhYmxlLmJydXNoKGN0eCwgaSA9PT0gMCA/IG51bGwgOiB0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXNbaSAtIDFdKTtcbiAgICBkaXNwbGF5YWJsZS5hZnRlckJydXNoICYmIGRpc3BsYXlhYmxlLmFmdGVyQnJ1c2goY3R4KTtcbiAgfVxuXG4gIHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlcyA9IFtdO1xuICB0aGlzLm5vdENsZWFyID0gdHJ1ZTtcbn07XG5cbnZhciBtID0gW107XG5cbkluY3JlbWVudGFsRGlzcGxheWJsZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Rpc3BsYXlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRpc3BsYXlhYmxlID0gdGhpcy5fZGlzcGxheWFibGVzW2ldO1xuICAgICAgdmFyIGNoaWxkUmVjdCA9IGRpc3BsYXlhYmxlLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG5cbiAgICAgIGlmIChkaXNwbGF5YWJsZS5uZWVkTG9jYWxUcmFuc2Zvcm0oKSkge1xuICAgICAgICBjaGlsZFJlY3QuYXBwbHlUcmFuc2Zvcm0oZGlzcGxheWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0obSkpO1xuICAgICAgfVxuXG4gICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fcmVjdDtcbn07XG5cbkluY3JlbWVudGFsRGlzcGxheWJsZS5wcm90b3R5cGUuY29udGFpbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgaWYgKHJlY3QuY29udGFpbihsb2NhbFBvc1swXSwgbG9jYWxQb3NbMV0pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kaXNwbGF5YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaXNwbGF5YWJsZSA9IHRoaXMuX2Rpc3BsYXlhYmxlc1tpXTtcblxuICAgICAgaWYgKGRpc3BsYXlhYmxlLmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuaW5oZXJpdHMoSW5jcmVtZW50YWxEaXNwbGF5YmxlLCBEaXNwbGF5YmxlKTtcbnZhciBfZGVmYXVsdCA9IEluY3JlbWVudGFsRGlzcGxheWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9JbmNyZW1lbnRhbERpc3BsYXlhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0luY3JlbWVudGFsRGlzcGxheWFibGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4vR3JhZGllbnRcIik7XG5cbi8qKlxuICogeCwgeSwgeDIsIHkyIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeDI9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeTI9MF1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICovXG52YXIgTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ2xpbmVhcicsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy54ID0geCA9PSBudWxsID8gMCA6IHg7XG4gIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAgOiB5O1xuICB0aGlzLngyID0geDIgPT0gbnVsbCA/IDEgOiB4MjtcbiAgdGhpcy55MiA9IHkyID09IG51bGwgPyAwIDogeTI7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAnbGluZWFyJzsgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuXG4gIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG4gIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG59O1xuXG5MaW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMaW5lYXJHcmFkaWVudFxufTtcbnpyVXRpbC5pbmhlcml0cyhMaW5lYXJHcmFkaWVudCwgR3JhZGllbnQpO1xudmFyIF9kZWZhdWx0ID0gTGluZWFyR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3BhdGhcIik7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZShcIi4vUGF0dGVyblwiKTtcblxudmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnBhdGggPSBudWxsO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGgsXG4gIHR5cGU6ICdwYXRoJyxcbiAgX19kaXJ0eVBhdGg6IHRydWUsXG4gIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8IHBhdGhQcm94eUZvckRyYXc7XG4gICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhZmlsbC5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISFmaWxsLmltYWdlO1xuICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhc3Ryb2tlLmltYWdlO1xuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICB2YXIgcmVjdDsgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuXG4gICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgIH1cbiAgICB9IC8vIFVzZSB0aGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuXG5cbiAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9maWxsR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgIH1cblxuICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHZhciBjdHhMaW5lRGFzaCA9ICEhY3R4LnNldExpbmVEYXNoOyAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcblxuICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7IC8vIFByb3h5IGNvbnRleHRcbiAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCB8fCBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aChjdHgpOyAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuXG4gICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpOyAvLyBDbGVhciBwYXRoIGRpcnR5IGZsYWdcblxuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG5cbiAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgfVxuXG4gICAgaGFzU3Ryb2tlICYmIHBhdGguc3Ryb2tlKGN0eCk7XG5cbiAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9IC8vIERyYXcgcmVjdCB0ZXh0XG5cblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIC8vIE9ubHkgcmVzdG9yZSB0cmFuc2Zvcm0gd2hlbiBuZWVkcyBkcmF3IHRleHQuXG4gICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9LFxuICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gIC8vIExpa2UgaW4gY2lyY2xlXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcbiAgY3JlYXRlUGF0aFByb3h5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG5cbiAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWN0ID0gcmVjdDtcblxuICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7IC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG5cbiAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7IC8vIFBFTkRJTkcsIE1pbiBsaW5lIHdpZHRoIGlzIG5lZWRlZCB3aGVuIGxpbmUgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuXG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG5cbiAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICB9IC8vIENvbnNpZGVyIGxpbmUgd2lkdGhcbiAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG5cbiAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIHJlY3Qgd2l0aCBzdHJva2VcblxuXG4gICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuXG4gICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTsgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAqL1xuICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgIGlmIChkaXJ0eVBhdGggPT0gbnVsbCkge1xuICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICB9IC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cblxuXG4gICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7IC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG5cbiAgICBpZiAodGhpcy5fX2NsaXBUYXJnZXQpIHtcbiAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzaGFwZScsIGxvb3ApO1xuICB9LFxuICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBGSVhNRVxuICAgIGlmIChrZXkgPT09ICdzaGFwZScpIHtcbiAgICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTsgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcblxuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgc2hhcGVbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGdldExpbmVTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07IC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAvLyBEZXRlcm1pbmFudCBvZiBgbWAgbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgIC8vIGZvciB3aWR0aC5cblxuICAgIHJldHVybiBtICYmIGFicyhtWzBdIC0gMSkgPiAxZS0xMCAmJiBhYnMobVszXSAtIDEpID4gMWUtMTAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKSA6IDE7XG4gIH1cbn07XG4vKipcbiAqIOaJqeWxleS4gOS4qiBQYXRoIGVsZW1lbnQsIOavlOWmguaYn+W9ou+8jOWchuetieOAglxuICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy50eXBlIFBhdGggdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5idWlsZFBhdGggT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIEV4dGVuZGVkIGRlZmF1bHQgc3R5bGUgY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICovXG5cblBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIFBhdGguY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgIGlmIChkZWZhdWx0cy5zdHlsZSkge1xuICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc3R5bGVcbiAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgIH0gLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcblxuXG4gICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuXG4gICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICB2YXIgdGhpc1NoYXBlID0gdGhpcy5zaGFwZTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgaWYgKCF0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpc1NoYXBlW25hbWVdID0gZGVmYXVsdFNoYXBlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmYXVsdHMuaW5pdCAmJiBkZWZhdWx0cy5pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gIH07XG5cbiAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7IC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIG5hbWUgIT09ICdzaGFwZScpIHtcbiAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU3ViO1xufTtcblxuenJVdGlsLmluaGVyaXRzKFBhdGgsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFBhdGg7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdHRlcm4gPSBmdW5jdGlvbiAoaW1hZ2UsIHJlcGVhdCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7aW1hZ2U6IC4uLn1gLCB3aGVyZSB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICB0aGlzLnJlcGVhdCA9IHJlcGVhdDsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGVhdCB8fCAncmVwZWF0Jyk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBQYXR0ZXJuO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgR3JhZGllbnQgPSByZXF1aXJlKFwiLi9HcmFkaWVudFwiKTtcblxuLyoqXG4gKiB4LCB5LCByIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTAuNV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wLjVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3I9MC41XVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW2NvbG9yU3RvcHNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAqL1xudmFyIFJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHt0eXBlOiAncmFkaWFsJywgY29sb3JTdG9wczogLi4ufWAsIHdoZXJlXG4gIC8vIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLnggPSB4ID09IG51bGwgPyAwLjUgOiB4O1xuICB0aGlzLnkgPSB5ID09IG51bGwgPyAwLjUgOiB5O1xuICB0aGlzLnIgPSByID09IG51bGwgPyAwLjUgOiByOyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ3JhZGlhbCc7IC8vIElmIHVzZSBnbG9iYWwgY29vcmRcblxuICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xufTtcblxuUmFkaWFsR3JhZGllbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmFkaWFsR3JhZGllbnRcbn07XG56clV0aWwuaW5oZXJpdHMoUmFkaWFsR3JhZGllbnQsIEdyYWRpZW50KTtcbnZhciBfZGVmYXVsdCA9IFJhZGlhbEdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGZpeFNoYWRvdyA9IHJlcXVpcmUoXCIuL2hlbHBlci9maXhTaGFkb3dcIik7XG5cbnZhciBTVFlMRV9DT01NT05fUFJPUFMgPSBbWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93T2Zmc2V0WCcsIDBdLCBbJ3NoYWRvd09mZnNldFknLCAwXSwgWydzaGFkb3dDb2xvcicsICcjMDAwJ10sIFsnbGluZUNhcCcsICdidXR0J10sIFsnbGluZUpvaW4nLCAnbWl0ZXInXSwgWydtaXRlckxpbWl0JywgMTBdXTsgLy8gdmFyIFNIQURPV19QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSgwLCA0KTtcbi8vIHZhciBMSU5FX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDQpO1xuXG52YXIgU3R5bGUgPSBmdW5jdGlvbiAob3B0cywgaG9zdCkge1xuICB0aGlzLmV4dGVuZEZyb20ob3B0cywgZmFsc2UpO1xuICB0aGlzLmhvc3QgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTGluZWFyR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMCA6IG9iai54O1xuICB2YXIgeDIgPSBvYmoueDIgPT0gbnVsbCA/IDEgOiBvYmoueDI7XG4gIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAgOiBvYmoueTtcbiAgdmFyIHkyID0gb2JqLnkyID09IG51bGwgPyAwIDogb2JqLnkyO1xuXG4gIGlmICghb2JqLmdsb2JhbCkge1xuICAgIHggPSB4ICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICB4MiA9IHgyICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICB5ID0geSAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICAgIHkyID0geTIgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgfSAvLyBGaXggTmFOIHdoZW4gcmVjdCBpcyBJbmZpbml0eVxuXG5cbiAgeCA9IGlzTmFOKHgpID8gMCA6IHg7XG4gIHgyID0gaXNOYU4oeDIpID8gMSA6IHgyO1xuICB5ID0gaXNOYU4oeSkgPyAwIDogeTtcbiAgeTIgPSBpc05hTih5MikgPyAwIDogeTI7XG4gIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4MiwgeTIpO1xuICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJhZGlhbEdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIG1pbiA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwLjUgOiBvYmoueDtcbiAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMC41IDogb2JqLnk7XG4gIHZhciByID0gb2JqLnIgPT0gbnVsbCA/IDAuNSA6IG9iai5yO1xuXG4gIGlmICghb2JqLmdsb2JhbCkge1xuICAgIHggPSB4ICogd2lkdGggKyByZWN0Lng7XG4gICAgeSA9IHkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgciA9IHIgKiBtaW47XG4gIH1cblxuICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeCwgeSwgMCwgeCwgeSwgcik7XG4gIHJldHVybiBjYW52YXNHcmFkaWVudDtcbn1cblxuU3R5bGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU3R5bGUsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlfVxuICAgKi9cbiAgaG9zdDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZpbGw6ICcjMDAwJyxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0cm9rZTogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG9wYWNpdHk6IDEsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGxpbmVEYXNoOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGluZURhc2hPZmZzZXQ6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dCbHVyOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd09mZnNldFk6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBsaW5lV2lkdGg6IDEsXG5cbiAgLyoqXG4gICAqIElmIHN0cm9rZSBpZ25vcmUgc2NhbGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzdHJva2VOb1NjYWxlOiBmYWxzZSxcbiAgLy8gQm91bmRpbmcgcmVjdCB0ZXh0IGNvbmZpZ3VyYXRpb25cbiAgLy8gTm90IGFmZmVjdGVkIGJ5IGVsZW1lbnQgdHJhbnNmb3JtXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZiBgZm9udFNpemVgIG9yIGBmb250RmFtaWx5YCBleGlzdHMsIGBmb250YCB3aWxsIGJlIHJlc2V0IGJ5XG4gICAqIGBmb250U2l6ZWAsIGBmb250U3R5bGVgLCBgZm9udFdlaWdodGAsIGBmb250RmFtaWx5YC5cbiAgICogU28gZG8gbm90IHZpc2l0IGl0IGRpcmVjdGx5IGluIHVwcGVyIGFwcGxpY2F0aW9uIChsaWtlIGVjaGFydHMpLFxuICAgKiBidXQgdXNlIGBjb250YWluL3RleHQjbWFrZUZvbnRgIGluc3RlYWQuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250OiBudWxsLFxuXG4gIC8qKlxuICAgKiBUaGUgc2FtZSBhcyBmb250LiBVc2UgZm9udCBwbGVhc2UuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0Rm9udDogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udFN0eWxlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250V2VpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIFNob3VsZCBiZSAxMiBidXQgbm90ICcxMnB4Jy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGZvbnRTaXplOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250RmFtaWx5OiBudWxsLFxuXG4gIC8qKlxuICAgKiBSZXNlcnZlZCBmb3Igc3BlY2lhbCBmdW5jdGluYWxpdHksIGxpa2UgJ2hyJy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRUYWc6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0RmlsbDogJyMwMDAnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFN0cm9rZTogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRXaWR0aDogbnVsbCxcblxuICAvKipcbiAgICogT25seSBmb3IgdGV4dEJhY2tncm91bmQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0SGVpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiB0ZXh0U3Ryb2tlIG1heSBiZSBzZXQgYXMgc29tZSBjb2xvciBhcyBhIGRlZmF1bHRcbiAgICogdmFsdWUgaW4gdXBwZXIgYXBwbGljYWlvbiwgd2hlcmUgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogb2YgdGV4dFN0cm9rZVdpZHRoIHNob3VsZCBiZSAwIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAqIHVzZXIgY2FuIGNob29zZSB0byBkbyBub3QgdXNlIHRleHQgc3Ryb2tlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dExpbmVIZWlnaHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqICdpbnNpZGUnLCAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ1xuICAgKiBbeCwgeV1cbiAgICogQmFzZWQgb24geCwgeSBvZiByZWN0LlxuICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgKiBAZGVmYXVsdCAnaW5zaWRlJ1xuICAgKi9cbiAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcblxuICAvKipcbiAgICogSWYgbm90IHNwZWNpZmllZCwgdXNlIHRoZSBib3VuZGluZ1JlY3Qgb2YgYSBgZGlzcGxheWFibGVgLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGV4dFJlY3Q6IG51bGwsXG5cbiAgLyoqXG4gICAqIFt4LCB5XVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0T2Zmc2V0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEFsaWduOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFZlcnRpY2FsQWxpZ246IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0RGlzdGFuY2U6IDUsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0U2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dPZmZzZXRYOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd09mZnNldFk6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dPZmZzZXRYOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd09mZnNldFk6IDAsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdHJhbnNmb3JtIHRleHQuXG4gICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0cmFuc2Zvcm1UZXh0OiBmYWxzZSxcblxuICAvKipcbiAgICogVGV4dCByb3RhdGUgYXJvdW5kIHBvc2l0aW9uIG9mIFBhdGggb3IgSW1hZ2VcbiAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudCBhbmQgdHJhbnNmb3JtVGV4dCBpcyBmYWxzZS5cbiAgICovXG4gIHRleHRSb3RhdGlvbjogMCxcblxuICAvKipcbiAgICogVGV4dCBvcmlnaW4gb2YgdGV4dCByb3RhdGlvbiwgbGlrZSBbMTAsIDQwXS5cbiAgICogQmFzZWQgb24geCwgeSBvZiByZWN0LlxuICAgKiBVc2VmdWwgaW4gbGFiZWwgcm90YXRpb24gb2YgY2lyY3VsYXIgc3ltYm9sLlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIG9yaWdpbiBpcyB0ZXh0UG9zaXRpb24uXG4gICAqIENhbiBiZSAnY2VudGVyJy5cbiAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRPcmlnaW46IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0QmFja2dyb3VuZENvbG9yOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJvcmRlckNvbG9yOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJvcmRlcldpZHRoOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJvcmRlclJhZGl1czogMCxcblxuICAvKipcbiAgICogQ2FuIGJlIGAyYCBvciBgWzIsIDRdYCBvciBgWzIsIDMsIDQsIDVdYFxuICAgKiBAdHlwZSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dFBhZGRpbmc6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRleHQgc3R5bGVzIGZvciByaWNoIHRleHQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICByaWNoOiBudWxsLFxuXG4gIC8qKlxuICAgKiB7b3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQsIGVsbGlwc2lzLCBwbGFjZWhvbGRlcn1cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRydW5jYXRlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgYmxlbmQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIGJpbmQ6IGZ1bmN0aW9uIChjdHgsIGVsLCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuICAgIHZhciBwcmV2U3R5bGUgPSBwcmV2RWwgJiYgcHJldkVsLnN0eWxlO1xuICAgIHZhciBmaXJzdERyYXcgPSAhcHJldlN0eWxlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuICAgICAgdmFyIHN0eWxlTmFtZSA9IHByb3BbMF07XG5cbiAgICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGVbc3R5bGVOYW1lXSAhPT0gcHJldlN0eWxlW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgLy8gRklYTUUgSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZSB3aWxsIGNhdXNlIHN0eWxlIGxlYWsgZnJvbSBwcmV2aW91cyBlbGVtZW50LlxuICAgICAgICBjdHhbc3R5bGVOYW1lXSA9IGZpeFNoYWRvdyhjdHgsIHN0eWxlTmFtZSwgc3R5bGVbc3R5bGVOYW1lXSB8fCBwcm9wWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLmZpbGwgIT09IHByZXZTdHlsZS5maWxsKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLnN0cm9rZSAhPT0gcHJldlN0eWxlLnN0cm9rZSkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICAgIH1cblxuICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGUub3BhY2l0eSAhPT0gcHJldlN0eWxlLm9wYWNpdHkpIHtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBzdHlsZS5vcGFjaXR5O1xuICAgIH1cblxuICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGUuYmxlbmQgIT09IHByZXZTdHlsZS5ibGVuZCkge1xuICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHN0eWxlLmJsZW5kIHx8ICdzb3VyY2Utb3Zlcic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzU3Ryb2tlKCkpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIC8gKHRoaXMuc3Ryb2tlTm9TY2FsZSAmJiBlbCAmJiBlbC5nZXRMaW5lU2NhbGUgPyBlbC5nZXRMaW5lU2NhbGUoKSA6IDEpO1xuICAgIH1cbiAgfSxcbiAgaGFzRmlsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWxsID0gdGhpcy5maWxsO1xuICAgIHJldHVybiBmaWxsICE9IG51bGwgJiYgZmlsbCAhPT0gJ25vbmUnO1xuICB9LFxuICBoYXNTdHJva2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgcmV0dXJuIHN0cm9rZSAhPSBudWxsICYmIHN0cm9rZSAhPT0gJ25vbmUnICYmIHRoaXMubGluZVdpZHRoID4gMDtcbiAgfSxcblxuICAvKipcbiAgICogRXh0ZW5kIGZyb20gb3RoZXIgc3R5bGVcbiAgICogQHBhcmFtIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IG90aGVyU3R5bGVcbiAgICogQHBhcmFtIHtib29sZWFufSBvdmVyd3JpdGUgdHJ1ZTogb3ZlcndyaXJ0ZSBhbnkgd2F5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTogb3ZlcndyaXRlIG9ubHkgd2hlbiAhdGFyZ2V0Lmhhc093blByb3BlcnR5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyczogb3ZlcndyaXRlIHdoZW4gcHJvcGVydHkgaXMgbm90IG51bGwvdW5kZWZpbmVkLlxuICAgKi9cbiAgZXh0ZW5kRnJvbTogZnVuY3Rpb24gKG90aGVyU3R5bGUsIG92ZXJ3cml0ZSkge1xuICAgIGlmIChvdGhlclN0eWxlKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyU3R5bGUpIHtcbiAgICAgICAgaWYgKG90aGVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKG92ZXJ3cml0ZSA9PT0gdHJ1ZSB8fCAob3ZlcndyaXRlID09PSBmYWxzZSA/ICF0aGlzLmhhc093blByb3BlcnR5KG5hbWUpIDogb3RoZXJTdHlsZVtuYW1lXSAhPSBudWxsKSkpIHtcbiAgICAgICAgICB0aGlzW25hbWVdID0gb3RoZXJTdHlsZVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQmF0Y2ggc2V0dGluZyBzdHlsZSB3aXRoIGEgZ2l2ZW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb2JqXG4gICAqIEBwYXJhbSB7Kn0gW29ial1cbiAgICovXG4gIHNldDogZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXNbb2JqXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4dGVuZEZyb20ob2JqLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lXG4gICAqIEByZXR1cm4ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3U3R5bGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgIG5ld1N0eWxlLmV4dGVuZEZyb20odGhpcywgdHJ1ZSk7XG4gICAgcmV0dXJuIG5ld1N0eWxlO1xuICB9LFxuICBnZXRHcmFkaWVudDogZnVuY3Rpb24gKGN0eCwgb2JqLCByZWN0KSB7XG4gICAgdmFyIG1ldGhvZCA9IG9iai50eXBlID09PSAncmFkaWFsJyA/IGNyZWF0ZVJhZGlhbEdyYWRpZW50IDogY3JlYXRlTGluZWFyR3JhZGllbnQ7XG4gICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gbWV0aG9kKGN0eCwgb2JqLCByZWN0KTtcbiAgICB2YXIgY29sb3JTdG9wcyA9IG9iai5jb2xvclN0b3BzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AoY29sb3JTdG9wc1tpXS5vZmZzZXQsIGNvbG9yU3RvcHNbaV0uY29sb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgfVxufTtcbnZhciBzdHlsZVByb3RvID0gU3R5bGUucHJvdG90eXBlO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcblxuICBpZiAoIShwcm9wWzBdIGluIHN0eWxlUHJvdG8pKSB7XG4gICAgc3R5bGVQcm90b1twcm9wWzBdXSA9IHByb3BbMV07XG4gIH1cbn0gLy8gUHJvdmlkZSBmb3Igb3RoZXJzXG5cblxuU3R5bGUuZ2V0R3JhZGllbnQgPSBzdHlsZVByb3RvLmdldEdyYWRpZW50O1xudmFyIF9kZWZhdWx0ID0gU3R5bGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3RleHRcIik7XG5cbnZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyL3RleHRcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG59O1xuXG5UZXh0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRleHQsXG4gIHR5cGU6ICd0ZXh0JyxcbiAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7IC8vIFVzZSBwcm9wcyB3aXRoIHByZWZpeCAndGV4dCcuXG5cbiAgICBzdHlsZS5maWxsID0gc3R5bGUuc3Ryb2tlID0gc3R5bGUuc2hhZG93Qmx1ciA9IHN0eWxlLnNoYWRvd0NvbG9yID0gc3R5bGUuc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFkgPSBudWxsO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7IC8vIEFsd2F5cyBiaW5kIHN0eWxlXG5cbiAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcblxuICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSk7XG4gICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgIHRleHQgIT0gbnVsbCA/IHRleHQgKz0gJycgOiB0ZXh0ID0gJyc7XG4gICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChzdHlsZS50ZXh0ICsgJycsIHN0eWxlLmZvbnQsIHN0eWxlLnRleHRBbGlnbiwgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24sIHN0eWxlLnRleHRQYWRkaW5nLCBzdHlsZS5yaWNoKTtcbiAgICAgIHJlY3QueCArPSBzdHlsZS54IHx8IDA7XG4gICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuXG4gICAgICBpZiAodGV4dEhlbHBlci5nZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKSkge1xuICAgICAgICB2YXIgdyA9IHN0eWxlLnRleHRTdHJva2VXaWR0aDtcbiAgICAgICAgcmVjdC54IC09IHcgLyAyO1xuICAgICAgICByZWN0LnkgLT0gdyAvIDI7XG4gICAgICAgIHJlY3Qud2lkdGggKz0gdztcbiAgICAgICAgcmVjdC5oZWlnaHQgKz0gdztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoVGV4dCwgRGlzcGxheWFibGUpO1xudmFyIF9kZWZhdWx0ID0gVGV4dDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZW52ID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZW52XCIpO1xuXG4vLyBGaXggd2VpcmQgYnVnIGluIHNvbWUgdmVyc2lvbiBvZiBJRTExIChsaWtlIDExLjAuOTYwMC4xNzgqKiksXG4vLyB3aGVyZSBleGNlcHRpb24gXCJ1bmV4cGVjdGVkIGNhbGwgdG8gbWV0aG9kIG9yIHByb3BlcnR5IGFjY2Vzc1wiXG4vLyBtaWdodCBiZSB0aHJvd24gd2hlbiBjYWxsaW5nIGN0eC5maWxsIG9yIGN0eC5zdHJva2UgYWZ0ZXIgYSBwYXRoXG4vLyB3aG9zZSBhcmVhIHNpemUgaXMgemVybyBpcyBkcmF3biBhbmQgY3R4LmNsaXAoKSBpcyBjYWxsZWQgYW5kXG4vLyBzaGFkb3dCbHVyIGlzIHNldC4gU2VlICM0NTcyLCAjMzExMiwgIzU3NzcuXG4vLyAoZS5nLixcbi8vICBjdHgubW92ZVRvKDEwLCAxMCk7XG4vLyAgY3R4LmxpbmVUbygyMCwgMTApO1xuLy8gIGN0eC5jbG9zZVBhdGgoKTtcbi8vICBjdHguY2xpcCgpO1xuLy8gIGN0eC5zaGFkb3dCbHVyID0gMTA7XG4vLyAgLi4uXG4vLyAgY3R4LmZpbGwoKTtcbi8vIClcbnZhciBzaGFkb3dUZW1wID0gW1snc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSwgWydzaGFkb3dPZmZzZXRYJywgMF0sIFsnc2hhZG93T2Zmc2V0WScsIDBdXTtcblxuZnVuY3Rpb24gX2RlZmF1bHQob3JpZ25hbEJydXNoKSB7XG4gIC8vIHZlcnNpb24gc3RyaW5nIGNhbiBiZTogJzExLjAnXG4gIHJldHVybiBlbnYuYnJvd3Nlci5pZSAmJiBlbnYuYnJvd3Nlci52ZXJzaW9uID49IDExID8gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGlwUGF0aHMgPSB0aGlzLl9fY2xpcFBhdGhzO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIG1vZGlmaWVkO1xuXG4gICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgICAgICB2YXIgc2hhcGUgPSBjbGlwUGF0aCAmJiBjbGlwUGF0aC5zaGFwZTtcbiAgICAgICAgdmFyIHR5cGUgPSBjbGlwUGF0aCAmJiBjbGlwUGF0aC50eXBlO1xuXG4gICAgICAgIGlmIChzaGFwZSAmJiAodHlwZSA9PT0gJ3NlY3RvcicgJiYgc2hhcGUuc3RhcnRBbmdsZSA9PT0gc2hhcGUuZW5kQW5nbGUgfHwgdHlwZSA9PT0gJ3JlY3QnICYmICghc2hhcGUud2lkdGggfHwgIXNoYXBlLmhlaWdodCkpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFkb3dUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAvLyBJdCBpcyBzYXZlIHRvIHB1dCBzaGFkb3dUZW1wIHN0YXRpYywgYmVjYXVzZSBzaGFkb3dUZW1wXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGFsbCBtb2RpZmllZCBlYWNoIGl0ZW0gYnJ1c2ggY2FsbGVkLlxuICAgICAgICAgICAgc2hhZG93VGVtcFtqXVsyXSA9IHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dO1xuICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG9yaWduYWxCcnVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzJdO1xuICAgICAgfVxuICAgIH1cbiAgfSA6IG9yaWduYWxCcnVzaDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3cuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgU0hBRE9XX1BST1BTID0ge1xuICAnc2hhZG93Qmx1cic6IDEsXG4gICdzaGFkb3dPZmZzZXRYJzogMSxcbiAgJ3NoYWRvd09mZnNldFknOiAxLFxuICAndGV4dFNoYWRvd0JsdXInOiAxLFxuICAndGV4dFNoYWRvd09mZnNldFgnOiAxLFxuICAndGV4dFNoYWRvd09mZnNldFknOiAxLFxuICAndGV4dEJveFNoYWRvd0JsdXInOiAxLFxuICAndGV4dEJveFNoYWRvd09mZnNldFgnOiAxLFxuICAndGV4dEJveFNoYWRvd09mZnNldFknOiAxXG59O1xuXG5mdW5jdGlvbiBfZGVmYXVsdChjdHgsIHByb3BOYW1lLCB2YWx1ZSkge1xuICBpZiAoU0hBRE9XX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgIHJldHVybiB2YWx1ZSAqPSBjdHguZHByO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ZpeFNoYWRvdy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4U2hhZG93LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIExSVSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL0xSVVwiKTtcblxudmFyIGdsb2JhbEltYWdlQ2FjaGUgPSBuZXcgTFJVKDUwKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IG5ld0ltYWdlT3JTcmNcbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICovXG5cbmZ1bmN0aW9uIGZpbmRFeGlzdEltYWdlKG5ld0ltYWdlT3JTcmMpIHtcbiAgaWYgKHR5cGVvZiBuZXdJbWFnZU9yU3JjID09PSAnc3RyaW5nJykge1xuICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChuZXdJbWFnZU9yU3JjKTtcbiAgICByZXR1cm4gY2FjaGVkSW1nT2JqICYmIGNhY2hlZEltZ09iai5pbWFnZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3SW1hZ2VPclNyYztcbiAgfVxufVxuLyoqXG4gKiBDYXV0aW9uOiBVc2VyIHNob3VsZCBjYWNoZSBsb2FkZWQgaW1hZ2VzLCBidXQgbm90IGp1c3QgY291bnQgb24gTFJVLlxuICogQ29uc2lkZXIgaWYgcmVxdWlyZWQgaW1hZ2VzIG1vcmUgdGhhbiBMUlUgc2l6ZSwgd2lsbCBkZWFkIGxvb3Agb2NjdXI/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IG5ld0ltYWdlT3JTcmNcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IGltYWdlIEV4aXN0ZW50IGltYWdlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBbaG9zdEVsXSBGb3IgY2FsbGluZyBgZGlydHlgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBwYXJhbXM6IChpbWFnZSwgY2JQYXlsb2FkKVxuICogQHBhcmFtIHtPYmplY3R9IFtjYlBheWxvYWRdIFBheWxvYWQgb24gY2IgY2FsbGluZy5cbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVJbWFnZShuZXdJbWFnZU9yU3JjLCBpbWFnZSwgaG9zdEVsLCBjYiwgY2JQYXlsb2FkKSB7XG4gIGlmICghbmV3SW1hZ2VPclNyYykge1xuICAgIHJldHVybiBpbWFnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV3SW1hZ2VPclNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJbWFnZSBzaG91bGQgbm90IGJlIGxvYWRlZCByZXBlYXRseS5cbiAgICBpZiAoaW1hZ2UgJiYgaW1hZ2UuX196ckltYWdlU3JjID09PSBuZXdJbWFnZU9yU3JjIHx8ICFob3N0RWwpIHtcbiAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9IC8vIE9ubHkgd2hlbiB0aGVyZSBpcyBubyBleGlzdGVudCBpbWFnZSBvciBleGlzdGVudCBpbWFnZSBzcmNcbiAgICAvLyBpcyBkaWZmZXJlbnQsIHRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkLlxuXG5cbiAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG4gICAgdmFyIHBlbmRpbmdXcmFwID0ge1xuICAgICAgaG9zdEVsOiBob3N0RWwsXG4gICAgICBjYjogY2IsXG4gICAgICBjYlBheWxvYWQ6IGNiUGF5bG9hZFxuICAgIH07XG5cbiAgICBpZiAoY2FjaGVkSW1nT2JqKSB7XG4gICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICFpc0ltYWdlUmVhZHkoaW1hZ2UpICYmIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2gocGVuZGluZ1dyYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAhaW1hZ2UgJiYgKGltYWdlID0gbmV3IEltYWdlKCkpO1xuICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2VPbkxvYWQ7XG4gICAgICBnbG9iYWxJbWFnZUNhY2hlLnB1dChuZXdJbWFnZU9yU3JjLCBpbWFnZS5fX2NhY2hlZEltZ09iaiA9IHtcbiAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICBwZW5kaW5nOiBbcGVuZGluZ1dyYXBdXG4gICAgICB9KTtcbiAgICAgIGltYWdlLnNyYyA9IGltYWdlLl9fenJJbWFnZVNyYyA9IG5ld0ltYWdlT3JTcmM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlO1xuICB9IC8vIG5ld0ltYWdlT3JTcmMgaXMgYW4gSFRNTEltYWdlRWxlbWVudCBvciBIVE1MQ2FudmFzRWxlbWVudCBvciBDYW52YXNcbiAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3SW1hZ2VPclNyYztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGltYWdlT25Mb2FkKCkge1xuICB2YXIgY2FjaGVkSW1nT2JqID0gdGhpcy5fX2NhY2hlZEltZ09iajtcbiAgdGhpcy5vbmxvYWQgPSB0aGlzLl9fY2FjaGVkSW1nT2JqID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBlbmRpbmdXcmFwID0gY2FjaGVkSW1nT2JqLnBlbmRpbmdbaV07XG4gICAgdmFyIGNiID0gcGVuZGluZ1dyYXAuY2I7XG4gICAgY2IgJiYgY2IodGhpcywgcGVuZGluZ1dyYXAuY2JQYXlsb2FkKTtcbiAgICBwZW5kaW5nV3JhcC5ob3N0RWwuZGlydHkoKTtcbiAgfVxuXG4gIGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIGlzSW1hZ2VSZWFkeShpbWFnZSkge1xuICByZXR1cm4gaW1hZ2UgJiYgaW1hZ2Uud2lkdGggJiYgaW1hZ2UuaGVpZ2h0O1xufVxuXG5leHBvcnRzLmZpbmRFeGlzdEltYWdlID0gZmluZEV4aXN0SW1hZ2U7XG5leHBvcnRzLmNyZWF0ZU9yVXBkYXRlSW1hZ2UgPSBjcmVhdGVPclVwZGF0ZUltYWdlO1xuZXhwb3J0cy5pc0ltYWdlUmVhZHkgPSBpc0ltYWdlUmVhZHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvaW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ltYWdlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHNtb290aFNwbGluZSA9IHJlcXVpcmUoXCIuL3Ntb290aFNwbGluZVwiKTtcblxudmFyIHNtb290aEJlemllciA9IHJlcXVpcmUoXCIuL3Ntb290aEJlemllclwiKTtcblxuZnVuY3Rpb24gYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGNsb3NlUGF0aCkge1xuICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICB2YXIgc21vb3RoID0gc2hhcGUuc21vb3RoO1xuXG4gIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgaWYgKHNtb290aCAmJiBzbW9vdGggIT09ICdzcGxpbmUnKSB7XG4gICAgICB2YXIgY29udHJvbFBvaW50cyA9IHNtb290aEJlemllcihwb2ludHMsIHNtb290aCwgY2xvc2VQYXRoLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGNsb3NlUGF0aCA/IGxlbiA6IGxlbiAtIDEpOyBpKyspIHtcbiAgICAgICAgdmFyIGNwMSA9IGNvbnRyb2xQb2ludHNbaSAqIDJdO1xuICAgICAgICB2YXIgY3AyID0gY29udHJvbFBvaW50c1tpICogMiArIDFdO1xuICAgICAgICB2YXIgcCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AxWzBdLCBjcDFbMV0sIGNwMlswXSwgY3AyWzFdLCBwWzBdLCBwWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNtb290aCA9PT0gJ3NwbGluZScpIHtcbiAgICAgICAgcG9pbnRzID0gc21vb3RoU3BsaW5lKHBvaW50cywgY2xvc2VQYXRoKTtcbiAgICAgIH1cblxuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZVBhdGggJiYgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG59XG5cbmV4cG9ydHMuYnVpbGRQYXRoID0gYnVpbGRQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJmdW5jdGlvbiBidWlsZFBhdGgoY3R4LCBzaGFwZSkge1xuICB2YXIgeCA9IHNoYXBlLng7XG4gIHZhciB5ID0gc2hhcGUueTtcbiAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gIHZhciByID0gc2hhcGUucjtcbiAgdmFyIHIxO1xuICB2YXIgcjI7XG4gIHZhciByMztcbiAgdmFyIHI0OyAvLyBDb252ZXJ0IHdpZHRoIGFuZCBoZWlnaHQgdG8gcG9zaXRpdmUgZm9yIGJldHRlciBib3JkZXJSYWRpdXNcblxuICBpZiAod2lkdGggPCAwKSB7XG4gICAgeCA9IHggKyB3aWR0aDtcbiAgICB3aWR0aCA9IC13aWR0aDtcbiAgfVxuXG4gIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gIH0gZWxzZSBpZiAociBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgaWYgKHIubGVuZ3RoID09PSAxKSB7XG4gICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJbMF07XG4gICAgfSBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMikge1xuICAgICAgcjEgPSByMyA9IHJbMF07XG4gICAgICByMiA9IHI0ID0gclsxXTtcbiAgICB9IGVsc2UgaWYgKHIubGVuZ3RoID09PSAzKSB7XG4gICAgICByMSA9IHJbMF07XG4gICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgIHIzID0gclsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcjEgPSByWzBdO1xuICAgICAgcjIgPSByWzFdO1xuICAgICAgcjMgPSByWzJdO1xuICAgICAgcjQgPSByWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByMSA9IHIyID0gcjMgPSByNCA9IDA7XG4gIH1cblxuICB2YXIgdG90YWw7XG5cbiAgaWYgKHIxICsgcjIgPiB3aWR0aCkge1xuICAgIHRvdGFsID0gcjEgKyByMjtcbiAgICByMSAqPSB3aWR0aCAvIHRvdGFsO1xuICAgIHIyICo9IHdpZHRoIC8gdG90YWw7XG4gIH1cblxuICBpZiAocjMgKyByNCA+IHdpZHRoKSB7XG4gICAgdG90YWwgPSByMyArIHI0O1xuICAgIHIzICo9IHdpZHRoIC8gdG90YWw7XG4gICAgcjQgKj0gd2lkdGggLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMiArIHIzID4gaGVpZ2h0KSB7XG4gICAgdG90YWwgPSByMiArIHIzO1xuICAgIHIyICo9IGhlaWdodCAvIHRvdGFsO1xuICAgIHIzICo9IGhlaWdodCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIxICsgcjQgPiBoZWlnaHQpIHtcbiAgICB0b3RhbCA9IHIxICsgcjQ7XG4gICAgcjEgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgcjQgKj0gaGVpZ2h0IC8gdG90YWw7XG4gIH1cblxuICBjdHgubW92ZVRvKHggKyByMSwgeSk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcjIsIHkpO1xuICByMiAhPT0gMCAmJiBjdHguYXJjKHggKyB3aWR0aCAtIHIyLCB5ICsgcjIsIHIyLCAtTWF0aC5QSSAvIDIsIDApO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHIzKTtcbiAgcjMgIT09IDAgJiYgY3R4LmFyYyh4ICsgd2lkdGggLSByMywgeSArIGhlaWdodCAtIHIzLCByMywgMCwgTWF0aC5QSSAvIDIpO1xuICBjdHgubGluZVRvKHggKyByNCwgeSArIGhlaWdodCk7XG4gIHI0ICE9PSAwICYmIGN0eC5hcmMoeCArIHI0LCB5ICsgaGVpZ2h0IC0gcjQsIHI0LCBNYXRoLlBJIC8gMiwgTWF0aC5QSSk7XG4gIGN0eC5saW5lVG8oeCwgeSArIHIxKTtcbiAgcjEgIT09IDAgJiYgY3R4LmFyYyh4ICsgcjEsIHkgKyByMSwgcjEsIE1hdGguUEksIE1hdGguUEkgKiAxLjUpO1xufVxuXG5leHBvcnRzLmJ1aWxkUGF0aCA9IGJ1aWxkUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJNaW4gPSBfdmVjdG9yLm1pbjtcbnZhciB2Mk1heCA9IF92ZWN0b3IubWF4O1xudmFyIHYyU2NhbGUgPSBfdmVjdG9yLnNjYWxlO1xudmFyIHYyRGlzdGFuY2UgPSBfdmVjdG9yLmRpc3RhbmNlO1xudmFyIHYyQWRkID0gX3ZlY3Rvci5hZGQ7XG52YXIgdjJDbG9uZSA9IF92ZWN0b3IuY2xvbmU7XG52YXIgdjJTdWIgPSBfdmVjdG9yLnN1YjtcblxuLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gKiBAcGFyYW0ge251bWJlcn0gc21vb3RoIOW5s+a7keetiee6pywgMC0xXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICogQHBhcmFtIHtBcnJheX0gY29uc3RyYWludCDlsIborqHnrpflh7rmnaXnmoTmjqfliLbngrnnuqbmnZ/lnKjkuIDkuKrljIXlm7Tnm5LlhoVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5q+U5aaCIFtbMCwgMF0sIFsxMDAsIDEwMF1dLCDov5nkuKrljIXlm7Tnm5LkvJrkuI5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5pW05Liq5oqY57q/55qE5YyF5Zu055uS5YGa5LiA5Liq5bm26ZuG55So5p2l57qm5p2f5o6n5Yi254K544CCXG4gKiBAcGFyYW0ge0FycmF5fSDorqHnrpflh7rmnaXnmoTmjqfliLbngrnmlbDnu4RcbiAqL1xuZnVuY3Rpb24gX2RlZmF1bHQocG9pbnRzLCBzbW9vdGgsIGlzTG9vcCwgY29uc3RyYWludCkge1xuICB2YXIgY3BzID0gW107XG4gIHZhciB2ID0gW107XG4gIHZhciB2MSA9IFtdO1xuICB2YXIgdjIgPSBbXTtcbiAgdmFyIHByZXZQb2ludDtcbiAgdmFyIG5leHRQb2ludDtcbiAgdmFyIG1pbiwgbWF4O1xuXG4gIGlmIChjb25zdHJhaW50KSB7XG4gICAgbWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgbWF4ID0gWy1JbmZpbml0eSwgLUluZmluaXR5XTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHYyTWluKG1pbiwgbWluLCBwb2ludHNbaV0pO1xuICAgICAgdjJNYXgobWF4LCBtYXgsIHBvaW50c1tpXSk7XG4gICAgfSAvLyDkuI7mjIflrprnmoTljIXlm7Tnm5LlgZrlubbpm4ZcblxuXG4gICAgdjJNaW4obWluLCBtaW4sIGNvbnN0cmFpbnRbMF0pO1xuICAgIHYyTWF4KG1heCwgbWF4LCBjb25zdHJhaW50WzFdKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICBpZiAoaXNMb29wKSB7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSA/IGkgLSAxIDogbGVuIC0gMV07XG4gICAgICBuZXh0UG9pbnQgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgY3BzLnB1c2godjJDbG9uZShwb2ludHNbaV0pKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSAtIDFdO1xuICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHYyU3ViKHYsIG5leHRQb2ludCwgcHJldlBvaW50KTsgLy8gdXNlIGRlZ3JlZSB0byBzY2FsZSB0aGUgaGFuZGxlIGxlbmd0aFxuXG4gICAgdjJTY2FsZSh2LCB2LCBzbW9vdGgpO1xuICAgIHZhciBkMCA9IHYyRGlzdGFuY2UocG9pbnQsIHByZXZQb2ludCk7XG4gICAgdmFyIGQxID0gdjJEaXN0YW5jZShwb2ludCwgbmV4dFBvaW50KTtcbiAgICB2YXIgc3VtID0gZDAgKyBkMTtcblxuICAgIGlmIChzdW0gIT09IDApIHtcbiAgICAgIGQwIC89IHN1bTtcbiAgICAgIGQxIC89IHN1bTtcbiAgICB9XG5cbiAgICB2MlNjYWxlKHYxLCB2LCAtZDApO1xuICAgIHYyU2NhbGUodjIsIHYsIGQxKTtcbiAgICB2YXIgY3AwID0gdjJBZGQoW10sIHBvaW50LCB2MSk7XG4gICAgdmFyIGNwMSA9IHYyQWRkKFtdLCBwb2ludCwgdjIpO1xuXG4gICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgIHYyTWF4KGNwMCwgY3AwLCBtaW4pO1xuICAgICAgdjJNaW4oY3AwLCBjcDAsIG1heCk7XG4gICAgICB2Mk1heChjcDEsIGNwMSwgbWluKTtcbiAgICAgIHYyTWluKGNwMSwgY3AxLCBtYXgpO1xuICAgIH1cblxuICAgIGNwcy5wdXNoKGNwMCk7XG4gICAgY3BzLnB1c2goY3AxKTtcbiAgfVxuXG4gIGlmIChpc0xvb3ApIHtcbiAgICBjcHMucHVzaChjcHMuc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gY3BzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2MkRpc3RhbmNlID0gX3ZlY3Rvci5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYXRtdWxsLVJvbSBzcGxpbmUg5o+S5YC85oqY57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gX2RlZmF1bHQocG9pbnRzLCBpc0xvb3ApIHtcbiAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gIHZhciByZXQgPSBbXTtcbiAgdmFyIGRpc3RhbmNlID0gMDtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZGlzdGFuY2UgKz0gdjJEaXN0YW5jZShwb2ludHNbaSAtIDFdLCBwb2ludHNbaV0pO1xuICB9XG5cbiAgdmFyIHNlZ3MgPSBkaXN0YW5jZSAvIDI7XG4gIHNlZ3MgPSBzZWdzIDwgbGVuID8gbGVuIDogc2VncztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3M7IGkrKykge1xuICAgIHZhciBwb3MgPSBpIC8gKHNlZ3MgLSAxKSAqIChpc0xvb3AgPyBsZW4gOiBsZW4gLSAxKTtcbiAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihwb3MpO1xuICAgIHZhciB3ID0gcG9zIC0gaWR4O1xuICAgIHZhciBwMDtcbiAgICB2YXIgcDEgPSBwb2ludHNbaWR4ICUgbGVuXTtcbiAgICB2YXIgcDI7XG4gICAgdmFyIHAzO1xuXG4gICAgaWYgKCFpc0xvb3ApIHtcbiAgICAgIHAwID0gcG9pbnRzW2lkeCA9PT0gMCA/IGlkeCA6IGlkeCAtIDFdO1xuICAgICAgcDIgPSBwb2ludHNbaWR4ID4gbGVuIC0gMiA/IGxlbiAtIDEgOiBpZHggKyAxXTtcbiAgICAgIHAzID0gcG9pbnRzW2lkeCA+IGxlbiAtIDMgPyBsZW4gLSAxIDogaWR4ICsgMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAwID0gcG9pbnRzWyhpZHggLSAxICsgbGVuKSAlIGxlbl07XG4gICAgICBwMiA9IHBvaW50c1soaWR4ICsgMSkgJSBsZW5dO1xuICAgICAgcDMgPSBwb2ludHNbKGlkeCArIDIpICUgbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgdzIgPSB3ICogdztcbiAgICB2YXIgdzMgPSB3ICogdzI7XG4gICAgcmV0LnB1c2goW2ludGVycG9sYXRlKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB3LCB3MiwgdzMpLCBpbnRlcnBvbGF0ZShwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSwgdywgdzIsIHczKV0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3V0aWxcIik7XG5cbnZhciByZXRyaWV2ZTIgPSBfdXRpbC5yZXRyaWV2ZTI7XG52YXIgcmV0cmlldmUzID0gX3V0aWwucmV0cmlldmUzO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIG5vcm1hbGl6ZUNzc0FycmF5ID0gX3V0aWwubm9ybWFsaXplQ3NzQXJyYXk7XG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4vcm91bmRSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9pbWFnZVwiKTtcblxudmFyIGZpeFNoYWRvdyA9IHJlcXVpcmUoXCIuL2ZpeFNoYWRvd1wiKTtcblxuLy8gVE9ETzogSGF2ZSBub3Qgc3VwcG9ydCAnc3RhcnQnLCAnZW5kJyB5ZXQuXG52YXIgVkFMSURfVEVYVF9BTElHTiA9IHtcbiAgbGVmdDogMSxcbiAgcmlnaHQ6IDEsXG4gIGNlbnRlcjogMVxufTtcbnZhciBWQUxJRF9URVhUX1ZFUlRJQ0FMX0FMSUdOID0ge1xuICB0b3A6IDEsXG4gIGJvdHRvbTogMSxcbiAgbWlkZGxlOiAxXG59O1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBUaGUgaW5wdXQgc3R5bGUuXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlKSB7XG4gIG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgZWFjaChzdHlsZS5yaWNoLCBub3JtYWxpemVTdHlsZSk7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlKSB7XG4gICAgc3R5bGUuZm9udCA9IHRleHRDb250YWluLm1ha2VGb250KHN0eWxlKTtcbiAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgIHRleHRBbGlnbiA9PT0gJ21pZGRsZScgJiYgKHRleHRBbGlnbiA9ICdjZW50ZXInKTtcbiAgICBzdHlsZS50ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX0FMSUdOW3RleHRBbGlnbl0gPyB0ZXh0QWxpZ24gOiAnbGVmdCc7IC8vIENvbXBhdGlibGUgd2l0aCB0ZXh0QmFzZWxpbmUuXG5cbiAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiB8fCBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPT09ICdjZW50ZXInICYmICh0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnKTtcbiAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduID09IG51bGwgfHwgVkFMSURfVEVYVF9WRVJUSUNBTF9BTElHTlt0ZXh0VmVydGljYWxBbGlnbl0gPyB0ZXh0VmVydGljYWxBbGlnbiA6ICd0b3AnO1xuICAgIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuXG4gICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICBzdHlsZS50ZXh0UGFkZGluZyA9IG5vcm1hbGl6ZUNzc0FycmF5KHN0eWxlLnRleHRQYWRkaW5nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gc3R5bGVcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtyZWN0XSB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqICAgICAgICAgICAgICAgICAgSWYgc2V0IGZhbHNlLCByZWN0IHRleHQgaXMgbm90IHVzZWQuXG4gKi9cblxuXG5mdW5jdGlvbiByZW5kZXJUZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkge1xuICBzdHlsZS5yaWNoID8gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSA6IHJlbmRlclBsYWluVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQbGFpblRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBmb250ID0gc2V0Q3R4KGN0eCwgJ2ZvbnQnLCBzdHlsZS5mb250IHx8IHRleHRDb250YWluLkRFRkFVTFRfRk9OVCk7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrO1xuXG4gIGlmICghY29udGVudEJsb2NrIHx8IGhvc3RFbC5fX2RpcnR5KSB7XG4gICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgdGV4dFBhZGRpbmcsIHN0eWxlLnRydW5jYXRlKTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHRleHRMaW5lcyA9IGNvbnRlbnRCbG9jay5saW5lcztcbiAgdmFyIGxpbmVIZWlnaHQgPSBjb250ZW50QmxvY2subGluZUhlaWdodDtcbiAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKG91dGVySGVpZ2h0LCBzdHlsZSwgcmVjdCk7XG4gIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gYm94UG9zLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBPcmlnaW4gb2YgdGV4dFJvdGF0aW9uIHNob3VsZCBiZSB0aGUgYmFzZSBwb2ludCBvZiB0ZXh0IGRyYXdpbmcuXG5cbiAgYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgYmFzZVgsIGJhc2VZKTtcbiAgdmFyIGJveFkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WShiYXNlWSwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHRleHRYID0gYmFzZVg7XG4gIHZhciB0ZXh0WSA9IGJveFk7XG4gIHZhciBuZWVkRHJhd0JnID0gbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKTtcblxuICBpZiAobmVlZERyYXdCZyB8fCB0ZXh0UGFkZGluZykge1xuICAgIC8vIENvbnNpZGVyIHBlcmZvcm1hbmNlLCBkbyBub3QgY2FsbCBnZXRUZXh0V2lkdGggdXRpbCBuZWNlc3NhcnkuXG4gICAgdmFyIHRleHRXaWR0aCA9IHRleHRDb250YWluLmdldFdpZHRoKHRleHQsIGZvbnQpO1xuICAgIHZhciBvdXRlcldpZHRoID0gdGV4dFdpZHRoO1xuICAgIHRleHRQYWRkaW5nICYmIChvdXRlcldpZHRoICs9IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM10pO1xuICAgIHZhciBib3hYID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoYmFzZVgsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gICAgbmVlZERyYXdCZyAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIGJveFgsIGJveFksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcblxuICAgIGlmICh0ZXh0UGFkZGluZykge1xuICAgICAgdGV4dFggPSBnZXRUZXh0WEZvclBhZGRpbmcoYmFzZVgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpO1xuICAgICAgdGV4dFkgKz0gdGV4dFBhZGRpbmdbMF07XG4gICAgfVxuICB9XG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRBbGlnbicsIHRleHRBbGlnbiB8fCAnbGVmdCcpOyAvLyBGb3JjZSBiYXNlbGluZSB0byBiZSBcIm1pZGRsZVwiLiBPdGhlcndpc2UsIGlmIHVzaW5nIFwidG9wXCIsIHRoZVxuICAvLyB0ZXh0IHdpbGwgb2Zmc2V0IGRvd253YXJkIGEgbGl0dGxlIGJpdCBpbiBmb250IFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRCYXNlbGluZScsICdtaWRkbGUnKTsgLy8gQWx3YXlzIHNldCBzaGFkb3dCbHVyIGFuZCBzaGFkb3dPZmZzZXQgdG8gYXZvaWQgbGVhayBmcm9tIGRpc3BsYXlhYmxlLlxuXG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgc3R5bGUudGV4dFNoYWRvd0JsdXIgfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSB8fCAwKTsgLy8gYHRleHRCYXNlbGluZWAgaXMgc2V0IGFzICdtaWRkbGUnLlxuXG4gIHRleHRZICs9IGxpbmVIZWlnaHQgLyAyO1xuICB2YXIgdGV4dFN0cm9rZVdpZHRoID0gc3R5bGUudGV4dFN0cm9rZVdpZHRoO1xuICB2YXIgdGV4dFN0cm9rZSA9IGdldFN0cm9rZShzdHlsZS50ZXh0U3Ryb2tlLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICB2YXIgdGV4dEZpbGwgPSBnZXRGaWxsKHN0eWxlLnRleHRGaWxsKTtcblxuICBpZiAodGV4dFN0cm9rZSkge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRTdHJva2UpO1xuICB9XG5cbiAgaWYgKHRleHRGaWxsKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRGaWxsKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICB0ZXh0U3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgdGV4dFgsIHRleHRZKTtcbiAgICB0ZXh0RmlsbCAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzW2ldLCB0ZXh0WCwgdGV4dFkpO1xuICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHkpIHtcbiAgICBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKTtcbiAgfVxuXG4gIGRyYXdSaWNoVGV4dChob3N0RWwsIGN0eCwgY29udGVudEJsb2NrLCBzdHlsZSwgcmVjdCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdSaWNoVGV4dChob3N0RWwsIGN0eCwgY29udGVudEJsb2NrLCBzdHlsZSwgcmVjdCkge1xuICB2YXIgY29udGVudFdpZHRoID0gY29udGVudEJsb2NrLndpZHRoO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay5vdXRlcldpZHRoO1xuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgYm94UG9zID0gZ2V0Qm94UG9zaXRpb24ob3V0ZXJIZWlnaHQsIHN0eWxlLCByZWN0KTtcbiAgdmFyIGJhc2VYID0gYm94UG9zLmJhc2VYO1xuICB2YXIgYmFzZVkgPSBib3hQb3MuYmFzZVk7XG4gIHZhciB0ZXh0QWxpZ24gPSBib3hQb3MudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBib3hQb3MudGV4dFZlcnRpY2FsQWxpZ247IC8vIE9yaWdpbiBvZiB0ZXh0Um90YXRpb24gc2hvdWxkIGJlIHRoZSBiYXNlIHBvaW50IG9mIHRleHQgZHJhd2luZy5cblxuICBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCBiYXNlWCwgYmFzZVkpO1xuICB2YXIgYm94WCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKGJhc2VYLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgYm94WSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKGJhc2VZLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICB2YXIgeExlZnQgPSBib3hYO1xuICB2YXIgbGluZVRvcCA9IGJveFk7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgeExlZnQgKz0gdGV4dFBhZGRpbmdbM107XG4gICAgbGluZVRvcCArPSB0ZXh0UGFkZGluZ1swXTtcbiAgfVxuXG4gIHZhciB4UmlnaHQgPSB4TGVmdCArIGNvbnRlbnRXaWR0aDtcbiAgbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKSAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIGJveFgsIGJveFksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRCbG9jay5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gY29udGVudEJsb2NrLmxpbmVzW2ldO1xuICAgIHZhciB0b2tlbnMgPSBsaW5lLnRva2VucztcbiAgICB2YXIgdG9rZW5Db3VudCA9IHRva2Vucy5sZW5ndGg7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBsaW5lLmxpbmVIZWlnaHQ7XG4gICAgdmFyIHVzZWRXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgdmFyIGxlZnRJbmRleCA9IDA7XG4gICAgdmFyIGxpbmVYTGVmdCA9IHhMZWZ0O1xuICAgIHZhciBsaW5lWFJpZ2h0ID0geFJpZ2h0O1xuICAgIHZhciByaWdodEluZGV4ID0gdG9rZW5Db3VudCAtIDE7XG4gICAgdmFyIHRva2VuO1xuXG4gICAgd2hpbGUgKGxlZnRJbmRleCA8IHRva2VuQ291bnQgJiYgKHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF0sICF0b2tlbi50ZXh0QWxpZ24gfHwgdG9rZW4udGV4dEFsaWduID09PSAnbGVmdCcpKSB7XG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYTGVmdCwgJ2xlZnQnKTtcbiAgICAgIHVzZWRXaWR0aCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIGxpbmVYTGVmdCArPSB0b2tlbi53aWR0aDtcbiAgICAgIGxlZnRJbmRleCsrO1xuICAgIH1cblxuICAgIHdoaWxlIChyaWdodEluZGV4ID49IDAgJiYgKHRva2VuID0gdG9rZW5zW3JpZ2h0SW5kZXhdLCB0b2tlbi50ZXh0QWxpZ24gPT09ICdyaWdodCcpKSB7XG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYUmlnaHQsICdyaWdodCcpO1xuICAgICAgdXNlZFdpZHRoIC09IHRva2VuLndpZHRoO1xuICAgICAgbGluZVhSaWdodCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIHJpZ2h0SW5kZXgtLTtcbiAgICB9IC8vIFRoZSBvdGhlciB0b2tlbnMgYXJlIHBsYWNlZCBhcyB0ZXh0QWxpZ24gJ2NlbnRlcicgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlLlxuXG5cbiAgICBsaW5lWExlZnQgKz0gKGNvbnRlbnRXaWR0aCAtIChsaW5lWExlZnQgLSB4TGVmdCkgLSAoeFJpZ2h0IC0gbGluZVhSaWdodCkgLSB1c2VkV2lkdGgpIC8gMjtcblxuICAgIHdoaWxlIChsZWZ0SW5kZXggPD0gcmlnaHRJbmRleCkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbbGVmdEluZGV4XTsgLy8gQ29uc2lkZXIgd2lkdGggc3BlY2lmaWVkIGJ5IHVzZXIsIHVzZSAnY2VudGVyJyByYXRoZXIgdGhhbiAnbGVmdCcuXG5cbiAgICAgIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgbGluZVhMZWZ0ICsgdG9rZW4ud2lkdGggLyAyLCAnY2VudGVyJyk7XG4gICAgICBsaW5lWExlZnQgKz0gdG9rZW4ud2lkdGg7XG4gICAgICBsZWZ0SW5kZXgrKztcbiAgICB9XG5cbiAgICBsaW5lVG9wICs9IGxpbmVIZWlnaHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgeCwgeSkge1xuICAvLyB0ZXh0Um90YXRpb24gb25seSBhcHBseSBpbiBSZWN0VGV4dC5cbiAgaWYgKHJlY3QgJiYgc3R5bGUudGV4dFJvdGF0aW9uKSB7XG4gICAgdmFyIG9yaWdpbiA9IHN0eWxlLnRleHRPcmlnaW47XG5cbiAgICBpZiAob3JpZ2luID09PSAnY2VudGVyJykge1xuICAgICAgeCA9IHJlY3Qud2lkdGggLyAyICsgcmVjdC54O1xuICAgICAgeSA9IHJlY3QuaGVpZ2h0IC8gMiArIHJlY3QueTtcbiAgICB9IGVsc2UgaWYgKG9yaWdpbikge1xuICAgICAgeCA9IG9yaWdpblswXSArIHJlY3QueDtcbiAgICAgIHkgPSBvcmlnaW5bMV0gKyByZWN0Lnk7XG4gICAgfVxuXG4gICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTsgLy8gUG9zaXRpdmU6IGFudGljbG9ja3dpc2VcblxuICAgIGN0eC5yb3RhdGUoLXN0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgeCwgdGV4dEFsaWduKSB7XG4gIHZhciB0b2tlblN0eWxlID0gc3R5bGUucmljaFt0b2tlbi5zdHlsZU5hbWVdIHx8IHt9OyAvLyAnY3R4LnRleHRCYXNlbGluZScgaXMgYWx3YXlzIHNldCBhcyAnbWlkZGxlJywgZm9yIHNha2Ugb2ZcbiAgLy8gdGhlIGJpYXMgb2YgXCJNaWNyb3NvZnQgWWFIZWlcIi5cblxuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSB0b2tlbi50ZXh0VmVydGljYWxBbGlnbjtcbiAgdmFyIHkgPSBsaW5lVG9wICsgbGluZUhlaWdodCAvIDI7XG5cbiAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAndG9wJykge1xuICAgIHkgPSBsaW5lVG9wICsgdG9rZW4uaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLSB0b2tlbi5oZWlnaHQgLyAyO1xuICB9XG5cbiAgIXRva2VuLmlzTGluZUhvbGRlciAmJiBuZWVkRHJhd0JhY2tncm91bmQodG9rZW5TdHlsZSkgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHRva2VuU3R5bGUsIHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyA/IHggLSB0b2tlbi53aWR0aCA6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcicgPyB4IC0gdG9rZW4ud2lkdGggLyAyIDogeCwgeSAtIHRva2VuLmhlaWdodCAvIDIsIHRva2VuLndpZHRoLCB0b2tlbi5oZWlnaHQpO1xuICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZztcblxuICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICB4ID0gZ2V0VGV4dFhGb3JQYWRkaW5nKHgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpO1xuICAgIHkgLT0gdG9rZW4uaGVpZ2h0IC8gMiAtIHRleHRQYWRkaW5nWzJdIC0gdG9rZW4udGV4dEhlaWdodCAvIDI7XG4gIH1cblxuICBzZXRDdHgoY3R4LCAnc2hhZG93Qmx1cicsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dCbHVyLCBzdHlsZS50ZXh0U2hhZG93Qmx1ciwgMCkpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93Q29sb3InLCB0b2tlblN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50Jyk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFgsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYLCAwKSk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRZJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFksIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZLCAwKSk7XG4gIHNldEN0eChjdHgsICd0ZXh0QWxpZ24nLCB0ZXh0QWxpZ24pOyAvLyBGb3JjZSBiYXNlbGluZSB0byBiZSBcIm1pZGRsZVwiLiBPdGhlcndpc2UsIGlmIHVzaW5nIFwidG9wXCIsIHRoZVxuICAvLyB0ZXh0IHdpbGwgb2Zmc2V0IGRvd253YXJkIGEgbGl0dGxlIGJpdCBpbiBmb250IFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRCYXNlbGluZScsICdtaWRkbGUnKTtcbiAgc2V0Q3R4KGN0eCwgJ2ZvbnQnLCB0b2tlbi5mb250IHx8IHRleHRDb250YWluLkRFRkFVTFRfRk9OVCk7XG4gIHZhciB0ZXh0U3Ryb2tlID0gZ2V0U3Ryb2tlKHRva2VuU3R5bGUudGV4dFN0cm9rZSB8fCBzdHlsZS50ZXh0U3Ryb2tlLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICB2YXIgdGV4dEZpbGwgPSBnZXRGaWxsKHRva2VuU3R5bGUudGV4dEZpbGwgfHwgc3R5bGUudGV4dEZpbGwpO1xuICB2YXIgdGV4dFN0cm9rZVdpZHRoID0gcmV0cmlldmUyKHRva2VuU3R5bGUudGV4dFN0cm9rZVdpZHRoLCBzdHlsZS50ZXh0U3Ryb2tlV2lkdGgpOyAvLyBGaWxsIGFmdGVyIHN0cm9rZSBzbyB0aGUgb3V0bGluZSB3aWxsIG5vdCBjb3ZlciB0aGUgbWFpbiBwYXJ0LlxuXG4gIGlmICh0ZXh0U3Ryb2tlKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRTdHJva2VXaWR0aCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dFN0cm9rZSk7XG4gICAgY3R4LnN0cm9rZVRleHQodG9rZW4udGV4dCwgeCwgeSk7XG4gIH1cblxuICBpZiAodGV4dEZpbGwpIHtcbiAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEZpbGwpO1xuICAgIGN0eC5maWxsVGV4dCh0b2tlbi50ZXh0LCB4LCB5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpIHtcbiAgcmV0dXJuIHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgc3R5bGUudGV4dEJvcmRlcldpZHRoICYmIHN0eWxlLnRleHRCb3JkZXJDb2xvcjtcbn0gLy8gc3R5bGU6IHt0ZXh0QmFja2dyb3VuZENvbG9yLCB0ZXh0Qm9yZGVyV2lkdGgsIHRleHRCb3JkZXJDb2xvciwgdGV4dEJvcmRlclJhZGl1c31cbi8vIHNoYXBlOiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cblxuXG5mdW5jdGlvbiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yO1xuICB2YXIgdGV4dEJvcmRlcldpZHRoID0gc3R5bGUudGV4dEJvcmRlcldpZHRoO1xuICB2YXIgdGV4dEJvcmRlckNvbG9yID0gc3R5bGUudGV4dEJvcmRlckNvbG9yO1xuICB2YXIgaXNQbGFpbkJnID0gaXNTdHJpbmcodGV4dEJhY2tncm91bmRDb2xvcik7XG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgc3R5bGUudGV4dEJveFNoYWRvd0JsdXIgfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHN0eWxlLnRleHRCb3hTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WSB8fCAwKTtcblxuICBpZiAoaXNQbGFpbkJnIHx8IHRleHRCb3JkZXJXaWR0aCAmJiB0ZXh0Qm9yZGVyQ29sb3IpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgdmFyIHRleHRCb3JkZXJSYWRpdXMgPSBzdHlsZS50ZXh0Qm9yZGVyUmFkaXVzO1xuXG4gICAgaWYgKCF0ZXh0Qm9yZGVyUmFkaXVzKSB7XG4gICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcjogdGV4dEJvcmRlclJhZGl1c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG5cbiAgaWYgKGlzUGxhaW5CZykge1xuICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcbiAgICBjdHguZmlsbCgpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRleHRCYWNrZ3JvdW5kQ29sb3IpKSB7XG4gICAgdmFyIGltYWdlID0gdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTtcbiAgICBpbWFnZSA9IGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2UoaW1hZ2UsIG51bGwsIGhvc3RFbCwgb25CZ0ltYWdlTG9hZGVkLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcblxuICAgIGlmIChpbWFnZSAmJiBpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0Qm9yZGVyV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRCb3JkZXJDb2xvcik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQmdJbWFnZUxvYWRlZChpbWFnZSwgdGV4dEJhY2tncm91bmRDb2xvcikge1xuICAvLyBSZXBsYWNlIGltYWdlLCBzbyB0aGF0IGBjb250YWluL3RleHQuanMjcGFyc2VSaWNoVGV4dGBcbiAgLy8gd2lsbCBnZXQgY29ycmVjdCByZXN1bHQgaW4gbmV4dCB0aWNrLlxuICB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlID0gaW1hZ2U7XG59XG5cbmZ1bmN0aW9uIGdldEJveFBvc2l0aW9uKGJsb2NrSGVpaHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBiYXNlWCA9IHN0eWxlLnggfHwgMDtcbiAgdmFyIGJhc2VZID0gc3R5bGUueSB8fCAwO1xuICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjsgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuXG4gIGlmIChyZWN0KSB7XG4gICAgdmFyIHRleHRQb3NpdGlvbiA9IHN0eWxlLnRleHRQb3NpdGlvbjtcblxuICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgLy8gUGVyY2VudFxuICAgICAgYmFzZVggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgIGJhc2VZID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgc3R5bGUudGV4dERpc3RhbmNlKTtcbiAgICAgIGJhc2VYID0gcmVzLng7XG4gICAgICBiYXNlWSA9IHJlcy55OyAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cblxuICAgICAgdGV4dEFsaWduID0gdGV4dEFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduIHx8IHJlcy50ZXh0VmVydGljYWxBbGlnbjtcbiAgICB9IC8vIHRleHRPZmZzZXQgaXMgb25seSBzdXBwb3J0IGluIFJlY3RUZXh0LCBvdGhlcndpc2VcbiAgICAvLyB3ZSBoYXZlIHRvIGFkanVzdCBib3VuZGluZ1JlY3QgZm9yIHRleHRPZmZzZXQuXG5cblxuICAgIHZhciB0ZXh0T2Zmc2V0ID0gc3R5bGUudGV4dE9mZnNldDtcblxuICAgIGlmICh0ZXh0T2Zmc2V0KSB7XG4gICAgICBiYXNlWCArPSB0ZXh0T2Zmc2V0WzBdO1xuICAgICAgYmFzZVkgKz0gdGV4dE9mZnNldFsxXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhc2VYOiBiYXNlWCxcbiAgICBiYXNlWTogYmFzZVksXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNldEN0eChjdHgsIHByb3AsIHZhbHVlKSB7XG4gIGN0eFtwcm9wXSA9IGZpeFNoYWRvdyhjdHgsIHByb3AsIHZhbHVlKTtcbiAgcmV0dXJuIGN0eFtwcm9wXTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJva2VdIElmIHNwZWNpZmllZCwgZG8gbm90IGNoZWNrIHN0eWxlLnRleHRTdHJva2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xpbmVXaWR0aF0gSWYgc3BlY2lmaWVkLCBkbyBub3QgY2hlY2sgc3R5bGUudGV4dFN0cm9rZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHlsZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0U3Ryb2tlKHN0cm9rZSwgbGluZVdpZHRoKSB7XG4gIHJldHVybiBzdHJva2UgPT0gbnVsbCB8fCBsaW5lV2lkdGggPD0gMCB8fCBzdHJva2UgPT09ICd0cmFuc3BhcmVudCcgfHwgc3Ryb2tlID09PSAnbm9uZScgPyBudWxsIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gIDogc3Ryb2tlLmltYWdlIHx8IHN0cm9rZS5jb2xvclN0b3BzID8gJyMwMDAnIDogc3Ryb2tlO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxsKGZpbGwpIHtcbiAgcmV0dXJuIGZpbGwgPT0gbnVsbCB8fCBmaWxsID09PSAnbm9uZScgPyBudWxsIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gIDogZmlsbC5pbWFnZSB8fCBmaWxsLmNvbG9yU3RvcHMgPyAnIzAwMCcgOiBmaWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBlcmNlbnQodmFsdWUsIG1heFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0WEZvclBhZGRpbmcoeCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZykge1xuICByZXR1cm4gdGV4dEFsaWduID09PSAncmlnaHQnID8geCAtIHRleHRQYWRkaW5nWzFdIDogdGV4dEFsaWduID09PSAnY2VudGVyJyA/IHggKyB0ZXh0UGFkZGluZ1szXSAvIDIgLSB0ZXh0UGFkZGluZ1sxXSAvIDIgOiB4ICsgdGV4dFBhZGRpbmdbM107XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0eWxlfSBzdHlsZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkge1xuICByZXR1cm4gdGV4dCAhPSBudWxsICYmICh0ZXh0IHx8IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgc3R5bGUudGV4dEJvcmRlcldpZHRoICYmIHN0eWxlLnRleHRCb3JkZXJDb2xvciB8fCBzdHlsZS50ZXh0UGFkZGluZyk7XG59XG5cbmV4cG9ydHMubm9ybWFsaXplVGV4dFN0eWxlID0gbm9ybWFsaXplVGV4dFN0eWxlO1xuZXhwb3J0cy5yZW5kZXJUZXh0ID0gcmVuZGVyVGV4dDtcbmV4cG9ydHMuZ2V0U3Ryb2tlID0gZ2V0U3Ryb2tlO1xuZXhwb3J0cy5nZXRGaWxsID0gZ2V0RmlsbDtcbmV4cG9ydHMubmVlZERyYXdUZXh0ID0gbmVlZERyYXdUZXh0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3RleHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3RleHQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvdGV4dFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxuLyoqXG4gKiBNaXhpbiBmb3IgZHJhd2luZyB0ZXh0IGluIGEgZWxlbWVudCBib3VuZGluZyByZWN0XG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vUmVjdFRleHRcbiAqL1xudmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbnZhciBSZWN0VGV4dCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5SZWN0VGV4dC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSZWN0VGV4dCxcblxuICAvKipcbiAgICogRHJhdyB0ZXh0IGluIGEgcmVjdCB3aXRoIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZWN0IERpc3BsYXlhYmxlIHJlY3RcbiAgICovXG4gIGRyYXdSZWN0VGV4dDogZnVuY3Rpb24gKGN0eCwgcmVjdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgcmVjdCA9IHN0eWxlLnRleHRSZWN0IHx8IHJlY3Q7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG4gICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0OyAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXG4gICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGSVhNRVxuXG5cbiAgICBjdHguc2F2ZSgpOyAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgICBpZiAoIXN0eWxlLnRyYW5zZm9ybVRleHQpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuICAgIH0gLy8gdHJhbnNmb3JtVGV4dCBhbmQgdGV4dFJvdGF0aW9uIGNhbiBub3QgYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuXG5cbiAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFJlY3RUZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDlnIblvKdcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0FyY1xuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdhcmMnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDAsXG4gICAgc3RhcnRBbmdsZTogMCxcbiAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG4gICAgY2xvY2t3aXNlOiB0cnVlXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG4gICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcbiAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBfY3VydmUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IF9jdXJ2ZS5xdWFkcmF0aWNTdWJkaXZpZGU7XG52YXIgY3ViaWNTdWJkaXZpZGUgPSBfY3VydmUuY3ViaWNTdWJkaXZpZGU7XG52YXIgcXVhZHJhdGljQXQgPSBfY3VydmUucXVhZHJhdGljQXQ7XG52YXIgY3ViaWNBdCA9IF9jdXJ2ZS5jdWJpY0F0O1xudmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IF9jdXJ2ZS5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG52YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBfY3VydmUuY3ViaWNEZXJpdmF0aXZlQXQ7XG5cbi8qKlxuICog6LSd5aGe5bCU5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQmV6aWVyQ3VydmVcbiAqL1xudmFyIG91dCA9IFtdO1xuXG5mdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xuICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcblxuICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFsoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLCAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUuY3B5Miwgc2hhcGUueTIsIHQpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWyhpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSwgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUueTIsIHQpXTtcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdiZXppZXItY3VydmUnLFxuICBzaGFwZToge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIGNweDE6IDAsXG4gICAgY3B5MTogMCxcbiAgICAvLyBjcHgyOiAwLFxuICAgIC8vIGNweTI6IDBcbiAgICAvLyBDdXJ2ZSBzaG93IHBlcmNlbnQsIGZvciBhbmltYXRpbmdcbiAgICBwZXJjZW50OiAxXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgdmFyIGNweDEgPSBzaGFwZS5jcHgxO1xuICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcbiAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICB4MiA9IG91dFsyXTtcbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgeTIgPSBvdXRbMl07XG4gICAgICB9XG5cbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNweDEsIGNweTEsIHgyLCB5Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh4MSwgY3B4MSwgY3B4MiwgeDIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgIGNweDIgPSBvdXRbMl07XG4gICAgICAgIHgyID0gb3V0WzNdO1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh5MSwgY3B5MSwgY3B5MiwgeTIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgIGNweTIgPSBvdXRbMl07XG4gICAgICAgIHkyID0gb3V0WzNdO1xuICAgICAgfVxuXG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCB4MiwgeTIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRhbmdlbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDlnIblvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9DaXJjbGVcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnY2lyY2xlJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGluQnVuZGxlKSB7XG4gICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgLy8gQWx3YXlzIGRvIGl0IG1heSBoYXZlIHBlcmZvcm1lbmNlIGlzc3VlICggZmlsbCBtYXkgYmUgMnggbW9yZSBjb3N0KVxuICAgIGlmIChpbkJ1bmRsZSkge1xuICAgICAgY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICB9IC8vIGVsc2Uge1xuICAgIC8vICAgICBpZiAoY3R4LmFsbG9jYXRlICYmICFjdHguZGF0YS5sZW5ndGgpIHtcbiAgICAvLyAgICAgICAgIGN0eC5hbGxvY2F0ZShjdHguQ01EX01FTV9TSVpFLkEpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgIC8vIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG5cblxuICAgIGN0eC5hcmMoc2hhcGUuY3gsIHNoYXBlLmN5LCBzaGFwZS5yLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog55u057q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9MaW5lXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2xpbmUnLFxuICBzaGFwZToge1xuICAgIC8vIFN0YXJ0IHBvaW50XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgLy8gRW5kIHBvaW50XG4gICAgeDI6IDAsXG4gICAgeTI6IDAsXG4gICAgcGVyY2VudDogMVxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICB4MiA9IHgxICogKDEgLSBwZXJjZW50KSArIHgyICogcGVyY2VudDtcbiAgICAgIHkyID0geTEgKiAoMSAtIHBlcmNlbnQpICsgeTIgKiBwZXJjZW50O1xuICAgIH1cblxuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgcG9pbnRBdDogZnVuY3Rpb24gKHApIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgIHJldHVybiBbc2hhcGUueDEgKiAoMSAtIHApICsgc2hhcGUueDIgKiBwLCBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBdO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBwb2x5SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9wb2x5XCIpO1xuXG4vKipcbiAqIOWkmui+ueW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL1BvbHlnb25cbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncG9seWdvbicsXG4gIHNoYXBlOiB7XG4gICAgcG9pbnRzOiBudWxsLFxuICAgIHNtb290aDogZmFsc2UsXG4gICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3BvbHlcIik7XG5cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUG9seWxpbmVcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncG9seWxpbmUnLFxuICBzaGFwZToge1xuICAgIHBvaW50czogbnVsbCxcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCBmYWxzZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9yb3VuZFJlY3RcIik7XG5cbi8qKlxuICog55+p5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SZWN0XG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3JlY3QnLFxuICBzaGFwZToge1xuICAgIC8vIOW3puS4iuOAgeWPs+S4iuOAgeWPs+S4i+OAgeW3puS4i+inkueahOWNiuW+hOS+neasoeS4unIx44CBcjLjgIFyM+OAgXI0XG4gICAgLy8gcue8qeWGmeS4ujEgICAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgLy8gcue8qeWGmeS4ulsxXSAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgLy8gcue8qeWGmeS4ulsxLCAyXSAgICDnm7jlvZPkuo4gWzEsIDIsIDEsIDJdXG4gICAgLy8gcue8qeWGmeS4ulsxLCAyLCAzXSDnm7jlvZPkuo4gWzEsIDIsIDMsIDJdXG4gICAgcjogMCxcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgdmFyIHkgPSBzaGFwZS55O1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG5cbiAgICBpZiAoIXNoYXBlLnIpIHtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm47XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDlnIbnjq9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JpbmdcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncmluZycsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMCxcbiAgICByMDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yLCB5KTtcbiAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIsIDAsIFBJMiwgZmFsc2UpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIwLCB5KTtcbiAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIwLCAwLCBQSTIsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBmaXhDbGlwV2l0aFNoYWRvdyA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3dcIik7XG5cbi8qKlxuICog5omH5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnc2VjdG9yJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByMDogMCxcbiAgICByOiAwLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9LFxuICBicnVzaDogZml4Q2xpcFdpdGhTaGFkb3coUGF0aC5wcm90b3R5cGUuYnJ1c2gpLFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG4gICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIwICsgeCwgdW5pdFkgKiByMCArIHkpO1xuICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgY3R4LmxpbmVUbyhNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeSk7XG5cbiAgICBpZiAocjAgIT09IDApIHtcbiAgICAgIGN0eC5hcmMoeCwgeSwgcjAsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFuaW1hdG9yID0gcmVxdWlyZShcIi4uL2FuaW1hdGlvbi9BbmltYXRvclwiKTtcblxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9jb3JlL2xvZ1wiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGlzU3RyaW5nID0gX3V0aWwuaXNTdHJpbmc7XG52YXIgaXNGdW5jdGlvbiA9IF91dGlsLmlzRnVuY3Rpb247XG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcbnZhciBpc0FycmF5TGlrZSA9IF91dGlsLmlzQXJyYXlMaWtlO1xudmFyIGluZGV4T2YgPSBfdXRpbC5pbmRleE9mO1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1ZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQW5pbWF0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yPn1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLmFuaW1hdG9ycyA9IFtdO1xufTtcblxuQW5pbWF0YWJsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBbmltYXRhYmxlLFxuXG4gIC8qKlxuICAgKiDliqjnlLtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gZmV0Y2ggdmFsdWUgZnJvbSBvYmplY3QsIGxpa2UgJ2EuYi5jJy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcF0gV2hldGhlciB0byBsb29wIGFuaW1hdGlvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKiBAZXhhbXBsZTpcbiAgICogICAgIGVsLmFuaW1hdGUoJ3N0eWxlJywgZmFsc2UpXG4gICAqICAgICAgICAgLndoZW4oMTAwMCwge3g6IDEwfSApXG4gICAqICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKXsgLy8gQW5pbWF0aW9uIGRvbmUgfSlcbiAgICogICAgICAgICAuc3RhcnQoKVxuICAgKi9cbiAgYW5pbWF0ZTogZnVuY3Rpb24gKHBhdGgsIGxvb3ApIHtcbiAgICB2YXIgdGFyZ2V0O1xuICAgIHZhciBhbmltYXRpbmdTaGFwZSA9IGZhbHNlO1xuICAgIHZhciBlbCA9IHRoaXM7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHZhciBwYXRoU3BsaXR0ZWQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgcHJvcCA9IGVsOyAvLyBJZiBhbmltYXRpbmcgc2hhcGVcblxuICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aFNwbGl0dGVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3AgPSBwcm9wW3BhdGhTcGxpdHRlZFtpXV07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHRhcmdldCA9IHByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldCA9IGVsO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICBsb2coJ1Byb3BlcnR5IFwiJyArIHBhdGggKyAnXCIgaXMgbm90IGV4aXN0ZWQgaW4gZWxlbWVudCAnICsgZWwuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgbG9vcCk7XG4gICAgYW5pbWF0b3IuZHVyaW5nKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGVsLmRpcnR5KGFuaW1hdGluZ1NoYXBlKTtcbiAgICB9KS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEZJWE1FIEFuaW1hdG9yIHdpbGwgbm90IGJlIHJlbW92ZWQgaWYgdXNlIGBBbmltYXRvciNzdG9wYCB0byBzdG9wIGFuaW1hdGlvblxuICAgICAgYW5pbWF0b3JzLnNwbGljZShpbmRleE9mKGFuaW1hdG9ycywgYW5pbWF0b3IpLCAxKTtcbiAgICB9KTtcbiAgICBhbmltYXRvcnMucHVzaChhbmltYXRvcik7IC8vIElmIGFuaW1hdGUgYWZ0ZXIgYWRkZWQgdG8gdGhlIHpyZW5kZXJcblxuICAgIGlmICh6cikge1xuICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWBnOatouWKqOeUu1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAqL1xuICBzdG9wQW5pbWF0aW9uOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICB2YXIgbGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFuaW1hdG9yc1tpXS5zdG9wKGZvcndhcmRUb0xhc3QpO1xuICAgIH1cblxuICAgIGFuaW1hdG9ycy5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYXV0aW9uOiB0aGlzIG1ldGhvZCB3aWxsIHN0b3AgcHJldmlvdXMgYW5pbWF0aW9uLlxuICAgKiBTbyBkbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIG9uZSBlbGVtZW50IHR3aWNlIGJlZm9yZVxuICAgKiBhbmltYXRpb24gc3RhcnRzLCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdIFRpbWUgaW4gbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlYXNpbmc9J2xpbmVhciddXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm9yY2VBbmltYXRlXSBQcmV2ZW50IHN0b3AgYW5pbWF0aW9uIGFuZCBjYWxsYmFja1xuICAgKiAgICAgICAgaW1tZWRpZW50bHkgd2hlbiB0YXJnZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSBhcyBjdXJyZW50IHZhbHVlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9LCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICpcbiAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtcywgd2l0aCBjdWJpY091dCBlYXNpbmdcbiAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAqICAgICAgc2hhcGU6IHtcbiAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgKiAgICAgIH0sXG4gICAqICAgICAgc3R5bGU6IHtcbiAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICogICAgICB9XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9LCAxMDAsIDEwMCwgJ2N1YmljT3V0JywgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAqL1xuICAvLyBUT0RPIFJldHVybiBhbmltYXRpb24ga2V5XG4gIGFuaW1hdGVUbzogZnVuY3Rpb24gKHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2ssIGZvcmNlQW5pbWF0ZSkge1xuICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGVhc2luZywgY2FsbGJhY2spO1xuICAgIGlmIChpc1N0cmluZyhkZWxheSkpIHtcbiAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgZWFzaW5nID0gZGVsYXk7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBkZWxheSwgY2FsbGJhY2spO1xuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZWFzaW5nKSkge1xuICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgZWFzaW5nID0gJ2xpbmVhcic7XG4gICAgICAgIGRlbGF5ID0gMDtcbiAgICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihkZWxheSkpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IGRlbGF5O1xuICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0LCBjYWxsYmFjaylcbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aW1lKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0aW1lO1xuICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQpXG4gICAgICAgICAgZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICAgIH0gLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuXG5cbiAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcblxuICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coJycsIHRoaXMsIHRhcmdldCwgdGltZSwgZGVsYXkpOyAvLyBBbmltYXRvcnMgbWF5IGJlIHJlbW92ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgICAvLyBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGFuaW1hdGVcblxuXG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzLnNsaWNlKCk7XG4gICAgdmFyIGNvdW50ID0gYW5pbWF0b3JzLmxlbmd0aDtcblxuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBjb3VudC0tO1xuXG4gICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSAvLyBObyBhbmltYXRvcnMuIFRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgYmVmb3JlIGFuaW1hdG9yc1tpXS5zdGFydCgpLFxuICAgIC8vIGJlY2F1c2UgJ2RvbmUnIG1heSBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSBpZiBubyBuZWVkIHRvIGFuaW1hdGUuXG5cblxuICAgIGlmICghY291bnQpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfSAvLyBTdGFydCBhZnRlciBhbGwgYW5pbWF0b3JzIGNyZWF0ZWRcbiAgICAvLyBJbmNhc2UgYW55IGFuaW1hdG9yIGlzIGRvbmUgaW1tZWRpYXRlbHkgd2hlbiBhbGwgYW5pbWF0aW9uIHByb3BlcnRpZXMgYXJlIG5vdCBjaGFuZ2VkXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmltYXRvcnNbaV0uZG9uZShkb25lKS5zdGFydChlYXNpbmcsIGZvcmNlQW5pbWF0ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aD0nJ1xuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlPXRoaXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9KVxuICAgKlxuICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zXG4gICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAqICAgICAgc2hhcGU6IHtcbiAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgKiAgICAgIH0sXG4gICAqICAgICAgc3R5bGU6IHtcbiAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICogICAgICB9XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9LCAxMDAsIDEwMClcbiAgICovXG4gIF9hbmltYXRlVG9TaGFsbG93OiBmdW5jdGlvbiAocGF0aCwgc291cmNlLCB0YXJnZXQsIHRpbWUsIGRlbGF5KSB7XG4gICAgdmFyIG9ialNoYWxsb3cgPSB7fTtcbiAgICB2YXIgcHJvcGVydHlDb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNPYmplY3QodGFyZ2V0W25hbWVdKSAmJiAhaXNBcnJheUxpa2UodGFyZ2V0W25hbWVdKSkge1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3cocGF0aCA/IHBhdGggKyAnLicgKyBuYW1lIDogbmFtZSwgc291cmNlW25hbWVdLCB0YXJnZXRbbmFtZV0sIHRpbWUsIGRlbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpTaGFsbG93W25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgIHByb3BlcnR5Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXRbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAvLyBBdHRyIGRpcmVjdGx5IGlmIG5vdCBoYXMgcHJvcGVydHlcbiAgICAgICAgLy8gRklYTUUsIGlmIHNvbWUgcHJvcGVydHkgbm90IG5lZWRlZCBmb3IgZWxlbWVudCA/XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgIHRoaXMuYXR0cihuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNoYXBlIG9yIHN0eWxlXG4gICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgcHJvcHNbcGF0aF0gPSB7fTtcbiAgICAgICAgICBwcm9wc1twYXRoXVtuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICB0aGlzLmF0dHIocHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5Q291bnQgPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGUocGF0aCwgZmFsc2UpLndoZW4odGltZSA9PSBudWxsID8gNTAwIDogdGltZSwgb2JqU2hhbGxvdykuZGVsYXkoZGVsYXkgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBBbmltYXRhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5mdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG4gIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuX2RyYWdTdGFydCwgdGhpcyk7XG4gIHRoaXMub24oJ21vdXNlbW92ZScsIHRoaXMuX2RyYWcsIHRoaXMpO1xuICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gIHRoaXMub24oJ2dsb2JhbG91dCcsIHRoaXMuX2RyYWdFbmQsIHRoaXMpOyAvLyB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgLy8gdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuICAvLyB0aGlzLl94ID0gMDtcbiAgLy8gdGhpcy5feSA9IDA7XG59XG5cbkRyYWdnYWJsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEcmFnZ2FibGUsXG4gIF9kcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgJiYgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IGRyYWdnaW5nVGFyZ2V0O1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5feCA9IGUub2Zmc2V0WDtcbiAgICAgIHRoaXMuX3kgPSBlLm9mZnNldFk7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWdzdGFydCcsIGUuZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgX2RyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcbiAgICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgICAgdmFyIHkgPSBlLm9mZnNldFk7XG4gICAgICB2YXIgZHggPSB4IC0gdGhpcy5feDtcbiAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl95O1xuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyaWZ0KGR4LCBkeSwgZSk7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWcnLCBlLmV2ZW50KTtcbiAgICAgIHZhciBkcm9wVGFyZ2V0ID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgZHJhZ2dpbmdUYXJnZXQpLnRhcmdldDtcbiAgICAgIHZhciBsYXN0RHJvcFRhcmdldCA9IHRoaXMuX2Ryb3BUYXJnZXQ7XG4gICAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcblxuICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgIGlmIChsYXN0RHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0obGFzdERyb3BUYXJnZXQsIGUpLCAnZHJhZ2xlYXZlJywgZS5ldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJvcFRhcmdldCwgZSksICdkcmFnZW50ZXInLCBlLmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2RyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcbiAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnZW5kJywgZS5ldmVudCk7XG5cbiAgICBpZiAodGhpcy5fZHJvcFRhcmdldCkge1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbSh0aGlzLl9kcm9wVGFyZ2V0LCBlKSwgJ2Ryb3AnLCBlLmV2ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fZHJvcFRhcmdldCA9IG51bGw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhcmFtKHRhcmdldCwgZSkge1xuICByZXR1cm4ge1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHRvcFRhcmdldDogZSAmJiBlLnRvcFRhcmdldFxuICB9O1xufVxuXG52YXIgX2RlZmF1bHQgPSBEcmFnZ2FibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiDkuovku7bmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIGFycnlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbi8qKlxuICog5LqL5Lu25YiG5Y+R5ZmoXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBFdmVudGZ1bCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fJGhhbmRsZXJzID0ge307XG59O1xuXG5FdmVudGZ1bC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFdmVudGZ1bCxcblxuICAvKipcbiAgICog5Y2V5qyh6Kem5Y+R57uR5a6a77yMdHJpZ2dlcuWQjumUgOavgVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5ZON5bqU5Ye95pWwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBvbmU6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICBfaFtldmVudF0gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgIGg6IGhhbmRsZXIsXG4gICAgICBvbmU6IHRydWUsXG4gICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOe7keWumuS6i+S7tlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAgICovXG4gIG9uOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICBoOiBoYW5kbGVyLFxuICAgICAgb25lOiBmYWxzZSxcbiAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5piv5ZCm57uR5a6a5LqG5LqL5Lu2XG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NpbGVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuICAgIHJldHVybiBfaFtldmVudF0gJiYgX2hbZXZlbnRdLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICog6Kej57uR5LqL5Lu2XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoX2hbZXZlbnRdKSB7XG4gICAgICAgIHZhciBuZXdMaXN0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfaFtldmVudF0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oW2V2ZW50XVtpXVsnaCddICE9IGhhbmRsZXIpIHtcbiAgICAgICAgICAgIG5ld0xpc3QucHVzaChfaFtldmVudF1baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9oW2V2ZW50XSA9IG5ld0xpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaFtldmVudF0gJiYgX2hbZXZlbnRdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDkuovku7bliIblj5FcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJnTGVuID4gMykge1xuICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShfaFtpXVsnY3R4J10sIGFyZ3MpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICBfaC5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5bim5pyJY29udGV4dOeahOS6i+S7tuWIhuWPkSwg5pyA5ZCO5LiA5Liq5Y+C5pWw5piv5LqL5Lu25Zue6LCD55qEY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICovXG4gIHRyaWdnZXJXaXRoQ29udGV4dDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgaWYgKGFyZ0xlbiA+IDQpIHtcbiAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnNbdHlwZV07XG4gICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgLy8gT3B0aW1pemUgYWR2aXNlIGZyb20gYmFja2JvbmVcbiAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoY3R4KTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoY3R4LCBhcmdzWzFdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoY3R4LCBhcmdzWzFdLCBhcmdzWzJdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gaGF2ZSBtb3JlIHRoYW4gMiBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoY3R4LCBhcmdzKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2hbaV1bJ29uZSddKSB7XG4gICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07IC8vIOWvueixoeWPr+S7pemAmui/hyBvbnh4eHgg57uR5a6a5LqL5Lu2XG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uY2xpY2tcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3ZlclxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlbW92ZVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V3aGVlbFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXVwXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbmRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbnRlclxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnb3ZlclxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJvcFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbnZhciBfZGVmYXVsdCA9IEV2ZW50ZnVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbWF0cml4ID0gcmVxdWlyZShcIi4uL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG4vKipcbiAqIOaPkOS+m+WPmOaNouaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbUlkZW50aXR5ID0gbWF0cml4LmlkZW50aXR5O1xudmFyIEVQU0lMT04gPSA1ZS01O1xuXG5mdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgVHJhbnNmb3JtYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBJZiB0aGVyZSBhcmUgbm8gZ2l2ZW4gcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZVxuXG4gIGlmICghb3B0cy5wb3NpdGlvbikge1xuICAgIC8qKlxuICAgICAqIOW5s+enu1xuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCBbMCwgMF1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDBdO1xuICB9XG5cbiAgaWYgKG9wdHMucm90YXRpb24gPT0gbnVsbCkge1xuICAgIC8qKlxuICAgICAqIOaXi+i9rFxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gIH1cblxuICBpZiAoIW9wdHMuc2NhbGUpIHtcbiAgICAvKipcbiAgICAgKiDnvKnmlL5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgWzEsIDFdXG4gICAgICovXG4gICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgfVxuICAvKipcbiAgICog5peL6L2s5ZKM57yp5pS+55qE5Y6f54K5XG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cblxuXG4gIHRoaXMub3JpZ2luID0gdGhpcy5vcmlnaW4gfHwgbnVsbDtcbn07XG5cbnZhciB0cmFuc2Zvcm1hYmxlUHJvdG8gPSBUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZTtcbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm0gPSBudWxsO1xuLyoqXG4gKiDliKTmlq3mmK/lkKbpnIDopoHmnInlnZDmoIflj5jmjaJcbiAqIOWmguaenOacieWdkOagh+WPmOaNoiwg5YiZ5LuOcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZeS7peWPiueItuiKgueCueeahHRyYW5zZm9ybeiuoeeul+WHuuiHqui6q+eahHRyYW5zZm9ybeefqemYtVxuICovXG5cbnRyYW5zZm9ybWFibGVQcm90by5uZWVkTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc05vdEFyb3VuZFplcm8odGhpcy5yb3RhdGlvbikgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMF0pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzFdKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVswXSAtIDEpIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzFdIC0gMSk7XG59O1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8udXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIHZhciBwYXJlbnRIYXNUcmFuc2Zvcm0gPSBwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybTtcbiAgdmFyIG5lZWRMb2NhbFRyYW5zZm9ybSA9IHRoaXMubmVlZExvY2FsVHJhbnNmb3JtKCk7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKCEobmVlZExvY2FsVHJhbnNmb3JtIHx8IHBhcmVudEhhc1RyYW5zZm9ybSkpIHtcbiAgICBtICYmIG1JZGVudGl0eShtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG5cbiAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgIHRoaXMuZ2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gIH0gZWxzZSB7XG4gICAgbUlkZW50aXR5KG0pO1xuICB9IC8vIOW6lOeUqOeItuiKgueCueWPmOaNolxuXG5cbiAgaWYgKHBhcmVudEhhc1RyYW5zZm9ybSkge1xuICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgIG1hdHJpeC5tdWwobSwgcGFyZW50LnRyYW5zZm9ybSwgbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdHJpeC5jb3B5KG0sIHBhcmVudC50cmFuc2Zvcm0pO1xuICAgIH1cbiAgfSAvLyDkv53lrZjov5nkuKrlj5jmjaLnn6npmLVcblxuXG4gIHRoaXMudHJhbnNmb3JtID0gbTtcbiAgdGhpcy5pbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybSB8fCBtYXRyaXguY3JlYXRlKCk7XG4gIG1hdHJpeC5pbnZlcnQodGhpcy5pbnZUcmFuc2Zvcm0sIG0pO1xufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgcmV0dXJuIFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0odGhpcywgbSk7XG59O1xuLyoqXG4gKiDlsIboh6rlt7HnmoR0cmFuc2Zvcm3lupTnlKjliLBjb250ZXh05LiKXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuXG4gIGlmIChtKSB7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgfVxufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnJlc3RvcmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xufTtcblxudmFyIHRtcFRyYW5zZm9ybSA9IFtdO1xuLyoqXG4gKiDliIbop6NgdHJhbnNmb3JtYOefqemYteWIsGBwb3NpdGlvbmAsIGByb3RhdGlvbmAsIGBzY2FsZWBcbiAqL1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZGVjb21wb3NlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybSkge1xuICAgIC8vIEdldCBsb2NhbCB0cmFuc2Zvcm0gYW5kIGRlY29tcG9zZSB0aGVtIHRvIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb25cbiAgICBtYXRyaXgubXVsKHRtcFRyYW5zZm9ybSwgcGFyZW50LmludlRyYW5zZm9ybSwgbSk7XG4gICAgbSA9IHRtcFRyYW5zZm9ybTtcbiAgfVxuXG4gIHZhciBzeCA9IG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV07XG4gIHZhciBzeSA9IG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM107XG4gIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgaWYgKGlzTm90QXJvdW5kWmVybyhzeCAtIDEpKSB7XG4gICAgc3ggPSBNYXRoLnNxcnQoc3gpO1xuICB9XG5cbiAgaWYgKGlzTm90QXJvdW5kWmVybyhzeSAtIDEpKSB7XG4gICAgc3kgPSBNYXRoLnNxcnQoc3kpO1xuICB9XG5cbiAgaWYgKG1bMF0gPCAwKSB7XG4gICAgc3ggPSAtc3g7XG4gIH1cblxuICBpZiAobVszXSA8IDApIHtcbiAgICBzeSA9IC1zeTtcbiAgfVxuXG4gIHBvc2l0aW9uWzBdID0gbVs0XTtcbiAgcG9zaXRpb25bMV0gPSBtWzVdO1xuICBzY2FsZVswXSA9IHN4O1xuICBzY2FsZVsxXSA9IHN5O1xuICB0aGlzLnJvdGF0aW9uID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xufTtcbi8qKlxuICogR2V0IGdsb2JhbCBzY2FsZVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0R2xvYmFsU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIFsxLCAxXTtcbiAgfVxuXG4gIHZhciBzeCA9IE1hdGguc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgdmFyIHN5ID0gTWF0aC5zcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuXG4gIGlmIChtWzBdIDwgMCkge1xuICAgIHN4ID0gLXN4O1xuICB9XG5cbiAgaWYgKG1bM10gPCAwKSB7XG4gICAgc3kgPSAtc3k7XG4gIH1cblxuICByZXR1cm4gW3N4LCBzeV07XG59O1xuLyoqXG4gKiDlj5jmjaLlnZDmoIfkvY3nva7liLAgc2hhcGUg55qE5bGA6YOo5Z2Q5qCH56m66Ze0XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHZhciB2MiA9IFt4LCB5XTtcbiAgdmFyIGludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtO1xuXG4gIGlmIChpbnZUcmFuc2Zvcm0pIHtcbiAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCBpbnZUcmFuc2Zvcm0pO1xuICB9XG5cbiAgcmV0dXJuIHYyO1xufTtcbi8qKlxuICog5Y+Y5o2i5bGA6YOo5Z2Q5qCH5L2N572u5Yiw5YWo5bGA5Z2Q5qCH56m66Ze0XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9HbG9iYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgdjIgPSBbeCwgeV07XG4gIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2Mjtcbn07XG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5vcmlnaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXQucm90YXRpb25cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5wb3NpdGlvblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW21dXG4gKi9cblxuXG5UcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRhcmdldCwgbSkge1xuICBtID0gbSB8fCBbXTtcbiAgbUlkZW50aXR5KG0pO1xuICB2YXIgb3JpZ2luID0gdGFyZ2V0Lm9yaWdpbjtcbiAgdmFyIHNjYWxlID0gdGFyZ2V0LnNjYWxlIHx8IFsxLCAxXTtcbiAgdmFyIHJvdGF0aW9uID0gdGFyZ2V0LnJvdGF0aW9uIHx8IDA7XG4gIHZhciBwb3NpdGlvbiA9IHRhcmdldC5wb3NpdGlvbiB8fCBbMCwgMF07XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIC8vIFRyYW5zbGF0ZSB0byBvcmlnaW5cbiAgICBtWzRdIC09IG9yaWdpblswXTtcbiAgICBtWzVdIC09IG9yaWdpblsxXTtcbiAgfVxuXG4gIG1hdHJpeC5zY2FsZShtLCBtLCBzY2FsZSk7XG5cbiAgaWYgKHJvdGF0aW9uKSB7XG4gICAgbWF0cml4LnJvdGF0ZShtLCBtLCByb3RhdGlvbik7XG4gIH1cblxuICBpZiAob3JpZ2luKSB7XG4gICAgLy8gVHJhbnNsYXRlIGJhY2sgZnJvbSBvcmlnaW5cbiAgICBtWzRdICs9IG9yaWdpblswXTtcbiAgICBtWzVdICs9IG9yaWdpblsxXTtcbiAgfVxuXG4gIG1bNF0gKz0gcG9zaXRpb25bMF07XG4gIG1bNV0gKz0gcG9zaXRpb25bMV07XG4gIHJldHVybiBtO1xufTtcblxudmFyIF9kZWZhdWx0ID0gVHJhbnNmb3JtYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBMUlUgPSByZXF1aXJlKFwiLi4vY29yZS9MUlVcIik7XG5cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgJ3RyYW5zcGFyZW50JzogWzAsIDAsIDAsIDBdLFxuICAnYWxpY2VibHVlJzogWzI0MCwgMjQ4LCAyNTUsIDFdLFxuICAnYW50aXF1ZXdoaXRlJzogWzI1MCwgMjM1LCAyMTUsIDFdLFxuICAnYXF1YSc6IFswLCAyNTUsIDI1NSwgMV0sXG4gICdhcXVhbWFyaW5lJzogWzEyNywgMjU1LCAyMTIsIDFdLFxuICAnYXp1cmUnOiBbMjQwLCAyNTUsIDI1NSwgMV0sXG4gICdiZWlnZSc6IFsyNDUsIDI0NSwgMjIwLCAxXSxcbiAgJ2Jpc3F1ZSc6IFsyNTUsIDIyOCwgMTk2LCAxXSxcbiAgJ2JsYWNrJzogWzAsIDAsIDAsIDFdLFxuICAnYmxhbmNoZWRhbG1vbmQnOiBbMjU1LCAyMzUsIDIwNSwgMV0sXG4gICdibHVlJzogWzAsIDAsIDI1NSwgMV0sXG4gICdibHVldmlvbGV0JzogWzEzOCwgNDMsIDIyNiwgMV0sXG4gICdicm93bic6IFsxNjUsIDQyLCA0MiwgMV0sXG4gICdidXJseXdvb2QnOiBbMjIyLCAxODQsIDEzNSwgMV0sXG4gICdjYWRldGJsdWUnOiBbOTUsIDE1OCwgMTYwLCAxXSxcbiAgJ2NoYXJ0cmV1c2UnOiBbMTI3LCAyNTUsIDAsIDFdLFxuICAnY2hvY29sYXRlJzogWzIxMCwgMTA1LCAzMCwgMV0sXG4gICdjb3JhbCc6IFsyNTUsIDEyNywgODAsIDFdLFxuICAnY29ybmZsb3dlcmJsdWUnOiBbMTAwLCAxNDksIDIzNywgMV0sXG4gICdjb3Juc2lsayc6IFsyNTUsIDI0OCwgMjIwLCAxXSxcbiAgJ2NyaW1zb24nOiBbMjIwLCAyMCwgNjAsIDFdLFxuICAnY3lhbic6IFswLCAyNTUsIDI1NSwgMV0sXG4gICdkYXJrYmx1ZSc6IFswLCAwLCAxMzksIDFdLFxuICAnZGFya2N5YW4nOiBbMCwgMTM5LCAxMzksIDFdLFxuICAnZGFya2dvbGRlbnJvZCc6IFsxODQsIDEzNCwgMTEsIDFdLFxuICAnZGFya2dyYXknOiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICdkYXJrZ3JlZW4nOiBbMCwgMTAwLCAwLCAxXSxcbiAgJ2RhcmtncmV5JzogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAnZGFya2toYWtpJzogWzE4OSwgMTgzLCAxMDcsIDFdLFxuICAnZGFya21hZ2VudGEnOiBbMTM5LCAwLCAxMzksIDFdLFxuICAnZGFya29saXZlZ3JlZW4nOiBbODUsIDEwNywgNDcsIDFdLFxuICAnZGFya29yYW5nZSc6IFsyNTUsIDE0MCwgMCwgMV0sXG4gICdkYXJrb3JjaGlkJzogWzE1MywgNTAsIDIwNCwgMV0sXG4gICdkYXJrcmVkJzogWzEzOSwgMCwgMCwgMV0sXG4gICdkYXJrc2FsbW9uJzogWzIzMywgMTUwLCAxMjIsIDFdLFxuICAnZGFya3NlYWdyZWVuJzogWzE0MywgMTg4LCAxNDMsIDFdLFxuICAnZGFya3NsYXRlYmx1ZSc6IFs3MiwgNjEsIDEzOSwgMV0sXG4gICdkYXJrc2xhdGVncmF5JzogWzQ3LCA3OSwgNzksIDFdLFxuICAnZGFya3NsYXRlZ3JleSc6IFs0NywgNzksIDc5LCAxXSxcbiAgJ2Rhcmt0dXJxdW9pc2UnOiBbMCwgMjA2LCAyMDksIDFdLFxuICAnZGFya3Zpb2xldCc6IFsxNDgsIDAsIDIxMSwgMV0sXG4gICdkZWVwcGluayc6IFsyNTUsIDIwLCAxNDcsIDFdLFxuICAnZGVlcHNreWJsdWUnOiBbMCwgMTkxLCAyNTUsIDFdLFxuICAnZGltZ3JheSc6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgJ2RpbWdyZXknOiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICdkb2RnZXJibHVlJzogWzMwLCAxNDQsIDI1NSwgMV0sXG4gICdmaXJlYnJpY2snOiBbMTc4LCAzNCwgMzQsIDFdLFxuICAnZmxvcmFsd2hpdGUnOiBbMjU1LCAyNTAsIDI0MCwgMV0sXG4gICdmb3Jlc3RncmVlbic6IFszNCwgMTM5LCAzNCwgMV0sXG4gICdmdWNoc2lhJzogWzI1NSwgMCwgMjU1LCAxXSxcbiAgJ2dhaW5zYm9ybyc6IFsyMjAsIDIyMCwgMjIwLCAxXSxcbiAgJ2dob3N0d2hpdGUnOiBbMjQ4LCAyNDgsIDI1NSwgMV0sXG4gICdnb2xkJzogWzI1NSwgMjE1LCAwLCAxXSxcbiAgJ2dvbGRlbnJvZCc6IFsyMTgsIDE2NSwgMzIsIDFdLFxuICAnZ3JheSc6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgJ2dyZWVuJzogWzAsIDEyOCwgMCwgMV0sXG4gICdncmVlbnllbGxvdyc6IFsxNzMsIDI1NSwgNDcsIDFdLFxuICAnZ3JleSc6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgJ2hvbmV5ZGV3JzogWzI0MCwgMjU1LCAyNDAsIDFdLFxuICAnaG90cGluayc6IFsyNTUsIDEwNSwgMTgwLCAxXSxcbiAgJ2luZGlhbnJlZCc6IFsyMDUsIDkyLCA5MiwgMV0sXG4gICdpbmRpZ28nOiBbNzUsIDAsIDEzMCwgMV0sXG4gICdpdm9yeSc6IFsyNTUsIDI1NSwgMjQwLCAxXSxcbiAgJ2toYWtpJzogWzI0MCwgMjMwLCAxNDAsIDFdLFxuICAnbGF2ZW5kZXInOiBbMjMwLCAyMzAsIDI1MCwgMV0sXG4gICdsYXZlbmRlcmJsdXNoJzogWzI1NSwgMjQwLCAyNDUsIDFdLFxuICAnbGF3bmdyZWVuJzogWzEyNCwgMjUyLCAwLCAxXSxcbiAgJ2xlbW9uY2hpZmZvbic6IFsyNTUsIDI1MCwgMjA1LCAxXSxcbiAgJ2xpZ2h0Ymx1ZSc6IFsxNzMsIDIxNiwgMjMwLCAxXSxcbiAgJ2xpZ2h0Y29yYWwnOiBbMjQwLCAxMjgsIDEyOCwgMV0sXG4gICdsaWdodGN5YW4nOiBbMjI0LCAyNTUsIDI1NSwgMV0sXG4gICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IFsyNTAsIDI1MCwgMjEwLCAxXSxcbiAgJ2xpZ2h0Z3JheSc6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgJ2xpZ2h0Z3JlZW4nOiBbMTQ0LCAyMzgsIDE0NCwgMV0sXG4gICdsaWdodGdyZXknOiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICdsaWdodHBpbmsnOiBbMjU1LCAxODIsIDE5MywgMV0sXG4gICdsaWdodHNhbG1vbic6IFsyNTUsIDE2MCwgMTIyLCAxXSxcbiAgJ2xpZ2h0c2VhZ3JlZW4nOiBbMzIsIDE3OCwgMTcwLCAxXSxcbiAgJ2xpZ2h0c2t5Ymx1ZSc6IFsxMzUsIDIwNiwgMjUwLCAxXSxcbiAgJ2xpZ2h0c2xhdGVncmF5JzogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAnbGlnaHRzbGF0ZWdyZXknOiBbMTE5LCAxMzYsIDE1MywgMV0sXG4gICdsaWdodHN0ZWVsYmx1ZSc6IFsxNzYsIDE5NiwgMjIyLCAxXSxcbiAgJ2xpZ2h0eWVsbG93JzogWzI1NSwgMjU1LCAyMjQsIDFdLFxuICAnbGltZSc6IFswLCAyNTUsIDAsIDFdLFxuICAnbGltZWdyZWVuJzogWzUwLCAyMDUsIDUwLCAxXSxcbiAgJ2xpbmVuJzogWzI1MCwgMjQwLCAyMzAsIDFdLFxuICAnbWFnZW50YSc6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICdtYXJvb24nOiBbMTI4LCAwLCAwLCAxXSxcbiAgJ21lZGl1bWFxdWFtYXJpbmUnOiBbMTAyLCAyMDUsIDE3MCwgMV0sXG4gICdtZWRpdW1ibHVlJzogWzAsIDAsIDIwNSwgMV0sXG4gICdtZWRpdW1vcmNoaWQnOiBbMTg2LCA4NSwgMjExLCAxXSxcbiAgJ21lZGl1bXB1cnBsZSc6IFsxNDcsIDExMiwgMjE5LCAxXSxcbiAgJ21lZGl1bXNlYWdyZWVuJzogWzYwLCAxNzksIDExMywgMV0sXG4gICdtZWRpdW1zbGF0ZWJsdWUnOiBbMTIzLCAxMDQsIDIzOCwgMV0sXG4gICdtZWRpdW1zcHJpbmdncmVlbic6IFswLCAyNTAsIDE1NCwgMV0sXG4gICdtZWRpdW10dXJxdW9pc2UnOiBbNzIsIDIwOSwgMjA0LCAxXSxcbiAgJ21lZGl1bXZpb2xldHJlZCc6IFsxOTksIDIxLCAxMzMsIDFdLFxuICAnbWlkbmlnaHRibHVlJzogWzI1LCAyNSwgMTEyLCAxXSxcbiAgJ21pbnRjcmVhbSc6IFsyNDUsIDI1NSwgMjUwLCAxXSxcbiAgJ21pc3R5cm9zZSc6IFsyNTUsIDIyOCwgMjI1LCAxXSxcbiAgJ21vY2Nhc2luJzogWzI1NSwgMjI4LCAxODEsIDFdLFxuICAnbmF2YWpvd2hpdGUnOiBbMjU1LCAyMjIsIDE3MywgMV0sXG4gICduYXZ5JzogWzAsIDAsIDEyOCwgMV0sXG4gICdvbGRsYWNlJzogWzI1MywgMjQ1LCAyMzAsIDFdLFxuICAnb2xpdmUnOiBbMTI4LCAxMjgsIDAsIDFdLFxuICAnb2xpdmVkcmFiJzogWzEwNywgMTQyLCAzNSwgMV0sXG4gICdvcmFuZ2UnOiBbMjU1LCAxNjUsIDAsIDFdLFxuICAnb3JhbmdlcmVkJzogWzI1NSwgNjksIDAsIDFdLFxuICAnb3JjaGlkJzogWzIxOCwgMTEyLCAyMTQsIDFdLFxuICAncGFsZWdvbGRlbnJvZCc6IFsyMzgsIDIzMiwgMTcwLCAxXSxcbiAgJ3BhbGVncmVlbic6IFsxNTIsIDI1MSwgMTUyLCAxXSxcbiAgJ3BhbGV0dXJxdW9pc2UnOiBbMTc1LCAyMzgsIDIzOCwgMV0sXG4gICdwYWxldmlvbGV0cmVkJzogWzIxOSwgMTEyLCAxNDcsIDFdLFxuICAncGFwYXlhd2hpcCc6IFsyNTUsIDIzOSwgMjEzLCAxXSxcbiAgJ3BlYWNocHVmZic6IFsyNTUsIDIxOCwgMTg1LCAxXSxcbiAgJ3BlcnUnOiBbMjA1LCAxMzMsIDYzLCAxXSxcbiAgJ3BpbmsnOiBbMjU1LCAxOTIsIDIwMywgMV0sXG4gICdwbHVtJzogWzIyMSwgMTYwLCAyMjEsIDFdLFxuICAncG93ZGVyYmx1ZSc6IFsxNzYsIDIyNCwgMjMwLCAxXSxcbiAgJ3B1cnBsZSc6IFsxMjgsIDAsIDEyOCwgMV0sXG4gICdyZWQnOiBbMjU1LCAwLCAwLCAxXSxcbiAgJ3Jvc3licm93bic6IFsxODgsIDE0MywgMTQzLCAxXSxcbiAgJ3JveWFsYmx1ZSc6IFs2NSwgMTA1LCAyMjUsIDFdLFxuICAnc2FkZGxlYnJvd24nOiBbMTM5LCA2OSwgMTksIDFdLFxuICAnc2FsbW9uJzogWzI1MCwgMTI4LCAxMTQsIDFdLFxuICAnc2FuZHlicm93bic6IFsyNDQsIDE2NCwgOTYsIDFdLFxuICAnc2VhZ3JlZW4nOiBbNDYsIDEzOSwgODcsIDFdLFxuICAnc2Vhc2hlbGwnOiBbMjU1LCAyNDUsIDIzOCwgMV0sXG4gICdzaWVubmEnOiBbMTYwLCA4MiwgNDUsIDFdLFxuICAnc2lsdmVyJzogWzE5MiwgMTkyLCAxOTIsIDFdLFxuICAnc2t5Ymx1ZSc6IFsxMzUsIDIwNiwgMjM1LCAxXSxcbiAgJ3NsYXRlYmx1ZSc6IFsxMDYsIDkwLCAyMDUsIDFdLFxuICAnc2xhdGVncmF5JzogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAnc2xhdGVncmV5JzogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAnc25vdyc6IFsyNTUsIDI1MCwgMjUwLCAxXSxcbiAgJ3NwcmluZ2dyZWVuJzogWzAsIDI1NSwgMTI3LCAxXSxcbiAgJ3N0ZWVsYmx1ZSc6IFs3MCwgMTMwLCAxODAsIDFdLFxuICAndGFuJzogWzIxMCwgMTgwLCAxNDAsIDFdLFxuICAndGVhbCc6IFswLCAxMjgsIDEyOCwgMV0sXG4gICd0aGlzdGxlJzogWzIxNiwgMTkxLCAyMTYsIDFdLFxuICAndG9tYXRvJzogWzI1NSwgOTksIDcxLCAxXSxcbiAgJ3R1cnF1b2lzZSc6IFs2NCwgMjI0LCAyMDgsIDFdLFxuICAndmlvbGV0JzogWzIzOCwgMTMwLCAyMzgsIDFdLFxuICAnd2hlYXQnOiBbMjQ1LCAyMjIsIDE3OSwgMV0sXG4gICd3aGl0ZSc6IFsyNTUsIDI1NSwgMjU1LCAxXSxcbiAgJ3doaXRlc21va2UnOiBbMjQ1LCAyNDUsIDI0NSwgMV0sXG4gICd5ZWxsb3cnOiBbMjU1LCAyNTUsIDAsIDFdLFxuICAneWVsbG93Z3JlZW4nOiBbMTU0LCAyMDUsIDUwLCAxXVxufTtcblxuZnVuY3Rpb24gY2xhbXBDc3NCeXRlKGkpIHtcbiAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgaSA9IE1hdGgucm91bmQoaSk7IC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBDc3NBbmdsZShpKSB7XG4gIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAzNjAuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cblxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDM2MCA/IDM2MCA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzRmxvYXQoZikge1xuICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VDc3NJbnQoc3RyKSB7XG4gIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICB9XG5cbiAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUludChzdHIsIDEwKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzRmxvYXQoc3RyKSB7XG4gIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICB9XG5cbiAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbn1cblxuZnVuY3Rpb24gY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSB7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMTtcbiAgfSBlbHNlIGlmIChoID4gMSkge1xuICAgIGggLT0gMTtcbiAgfVxuXG4gIGlmIChoICogNiA8IDEpIHtcbiAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgfVxuXG4gIGlmIChoICogMiA8IDEpIHtcbiAgICByZXR1cm4gbTI7XG4gIH1cblxuICBpZiAoaCAqIDMgPCAyKSB7XG4gICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2O1xuICB9XG5cbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBsZXJwTnVtYmVyKGEsIGIsIHApIHtcbiAgcmV0dXJuIGEgKyAoYiAtIGEpICogcDtcbn1cblxuZnVuY3Rpb24gc2V0UmdiYShvdXQsIHIsIGcsIGIsIGEpIHtcbiAgb3V0WzBdID0gcjtcbiAgb3V0WzFdID0gZztcbiAgb3V0WzJdID0gYjtcbiAgb3V0WzNdID0gYTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gY29weVJnYmEob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbnZhciBjb2xvckNhY2hlID0gbmV3IExSVSgyMCk7XG52YXIgbGFzdFJlbW92ZWRBcnIgPSBudWxsO1xuXG5mdW5jdGlvbiBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gIC8vIFJldXNlIHJlbW92ZWQgYXJyYXlcbiAgaWYgKGxhc3RSZW1vdmVkQXJyKSB7XG4gICAgY29weVJnYmEobGFzdFJlbW92ZWRBcnIsIHJnYmFBcnIpO1xuICB9XG5cbiAgbGFzdFJlbW92ZWRBcnIgPSBjb2xvckNhY2hlLnB1dChjb2xvclN0ciwgbGFzdFJlbW92ZWRBcnIgfHwgcmdiYUFyci5zbGljZSgpKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yU3RyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gIGlmICghY29sb3JTdHIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZ2JhQXJyID0gcmdiYUFyciB8fCBbXTtcbiAgdmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGUuZ2V0KGNvbG9yU3RyKTtcblxuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNvcHlSZ2JhKHJnYmFBcnIsIGNhY2hlZCk7XG4gIH0gLy8gY29sb3JTdHIgbWF5IGJlIG5vdCBzdHJpbmdcblxuXG4gIGNvbG9yU3RyID0gY29sb3JTdHIgKyAnJzsgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG5cbiAgdmFyIHN0ciA9IGNvbG9yU3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7IC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cblxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSB7XG4gICAgY29weVJnYmEocmdiYUFyciwga0NTU0NvbG9yVGFibGVbc3RyXSk7XG4gICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgcmV0dXJuIHJnYmFBcnI7XG4gIH0gLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG5cblxuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjsgLy8gQ292ZXJzIE5hTi5cbiAgICAgIH1cblxuICAgICAgc2V0UmdiYShyZ2JhQXJyLCAoaXYgJiAweGYwMCkgPj4gNCB8IChpdiAmIDB4ZjAwKSA+PiA4LCBpdiAmIDB4ZjAgfCAoaXYgJiAweGYwKSA+PiA0LCBpdiAmIDB4ZiB8IChpdiAmIDB4ZikgPDwgNCwgMSk7XG4gICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cblxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHtcbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuOyAvLyBDb3ZlcnMgTmFOLlxuICAgICAgfVxuXG4gICAgICBzZXRSZ2JhKHJnYmFBcnIsIChpdiAmIDB4ZmYwMDAwKSA+PiAxNiwgKGl2ICYgMHhmZjAwKSA+PiA4LCBpdiAmIDB4ZmYsIDEpO1xuICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICByZXR1cm4gcmdiYUFycjtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLFxuICAgICAgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuXG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3AgKyAxLCBlcCAtIChvcCArIDEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7IC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFscGhhID0gcGFyc2VDc3NGbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAvLyBGYWxsIHRocm91Z2guXG5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIHBhcnNlQ3NzSW50KHBhcmFtc1swXSksIHBhcnNlQ3NzSW50KHBhcmFtc1sxXSksIHBhcnNlQ3NzSW50KHBhcmFtc1syXSksIGFscGhhKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtc1szXSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zWzNdKTtcbiAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICByZXR1cm47XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKi9cblxuXG5mdW5jdGlvbiBoc2xhMnJnYmEoaHNsYSwgcmdiYSkge1xuICB2YXIgaCA9IChwYXJzZUZsb2F0KGhzbGFbMF0pICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDsgLy8gMCAuLiAxXG4gIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG5cbiAgdmFyIHMgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMV0pO1xuICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICByZ2JhID0gcmdiYSB8fCBbXTtcbiAgc2V0UmdiYShyZ2JhLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoICsgMSAvIDMpICogMjU1KSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkgKiAyNTUpLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoIC0gMSAvIDMpICogMjU1KSwgMSk7XG5cbiAgaWYgKGhzbGEubGVuZ3RoID09PSA0KSB7XG4gICAgcmdiYVszXSA9IGhzbGFbM107XG4gIH1cblxuICByZXR1cm4gcmdiYTtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHJnYmEyaHNsYShyZ2JhKSB7XG4gIGlmICghcmdiYSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBSR0IgZnJvbSAwIHRvIDI1NVxuXG5cbiAgdmFyIFIgPSByZ2JhWzBdIC8gMjU1O1xuICB2YXIgRyA9IHJnYmFbMV0gLyAyNTU7XG4gIHZhciBCID0gcmdiYVsyXSAvIDI1NTtcbiAgdmFyIHZNaW4gPSBNYXRoLm1pbihSLCBHLCBCKTsgLy8gTWluLiB2YWx1ZSBvZiBSR0JcblxuICB2YXIgdk1heCA9IE1hdGgubWF4KFIsIEcsIEIpOyAvLyBNYXguIHZhbHVlIG9mIFJHQlxuXG4gIHZhciBkZWx0YSA9IHZNYXggLSB2TWluOyAvLyBEZWx0YSBSR0IgdmFsdWVcblxuICB2YXIgTCA9ICh2TWF4ICsgdk1pbikgLyAyO1xuICB2YXIgSDtcbiAgdmFyIFM7IC8vIEhTTCByZXN1bHRzIGZyb20gMCB0byAxXG5cbiAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgSCA9IDA7XG4gICAgUyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgIFMgPSBkZWx0YSAvICh2TWF4ICsgdk1pbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFMgPSBkZWx0YSAvICgyIC0gdk1heCAtIHZNaW4pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YVIgPSAoKHZNYXggLSBSKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG4gICAgdmFyIGRlbHRhRyA9ICgodk1heCAtIEcpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcbiAgICB2YXIgZGVsdGFCID0gKCh2TWF4IC0gQikgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuXG4gICAgaWYgKFIgPT09IHZNYXgpIHtcbiAgICAgIEggPSBkZWx0YUIgLSBkZWx0YUc7XG4gICAgfSBlbHNlIGlmIChHID09PSB2TWF4KSB7XG4gICAgICBIID0gMSAvIDMgKyBkZWx0YVIgLSBkZWx0YUI7XG4gICAgfSBlbHNlIGlmIChCID09PSB2TWF4KSB7XG4gICAgICBIID0gMiAvIDMgKyBkZWx0YUcgLSBkZWx0YVI7XG4gICAgfVxuXG4gICAgaWYgKEggPCAwKSB7XG4gICAgICBIICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKEggPiAxKSB7XG4gICAgICBIIC09IDE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhzbGEgPSBbSCAqIDM2MCwgUywgTF07XG5cbiAgaWYgKHJnYmFbM10gIT0gbnVsbCkge1xuICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgfVxuXG4gIHJldHVybiBoc2xhO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIGxpZnQoY29sb3IsIGxldmVsKSB7XG4gIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3JBcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICBjb2xvckFycltpXSA9IGNvbG9yQXJyW2ldICogKDEgLSBsZXZlbCkgfCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSAoMjU1IC0gY29sb3JBcnJbaV0pICogbGV2ZWwgKyBjb2xvckFycltpXSB8IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2xvckFycltpXSA+IDI1NSkge1xuICAgICAgICBjb2xvckFycltpXSA9IDI1NTtcbiAgICAgIH0gZWxzZSBpZiAoY29sb3JbaV0gPCAwKSB7XG4gICAgICAgIGNvbG9yQXJyW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KGNvbG9yQXJyLCBjb2xvckFyci5sZW5ndGggPT09IDQgPyAncmdiYScgOiAncmdiJyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cblxuZnVuY3Rpb24gdG9IZXgoY29sb3IpIHtcbiAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvckFycikge1xuICAgIHJldHVybiAoKDEgPDwgMjQpICsgKGNvbG9yQXJyWzBdIDw8IDE2KSArIChjb2xvckFyclsxXSA8PCA4KSArICtjb2xvckFyclsyXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICB9XG59XG4vKipcbiAqIE1hcCB2YWx1ZSB0byBjb2xvci4gRmFzdGVyIHRoYW4gbGVycCBtZXRob2RzIGJlY2F1c2UgY29sb3IgaXMgcmVwcmVzZW50ZWQgYnkgcmdiYSBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGNvbG9ycyBMaXN0IG9mIHJnYmEgY29sb3IgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIE1hcHBlZCBnYmEgY29sb3IgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSB3aWxsIGJlIG51bGwvdW5kZWZpbmVkIGlmIGlucHV0IGlsbGVnYWwuXG4gKi9cblxuXG5mdW5jdGlvbiBmYXN0TGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgb3V0KSB7XG4gIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKSB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG91dCA9IG91dCB8fCBbXTtcbiAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gIHZhciBsZWZ0Q29sb3IgPSBjb2xvcnNbbGVmdEluZGV4XTtcbiAgdmFyIHJpZ2h0Q29sb3IgPSBjb2xvcnNbcmlnaHRJbmRleF07XG4gIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuICBvdXRbMF0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSk7XG4gIG91dFsxXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKTtcbiAgb3V0WzJdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpO1xuICBvdXRbM10gPSBjbGFtcENzc0Zsb2F0KGxlcnBOdW1iZXIobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblxudmFyIGZhc3RNYXBUb0NvbG9yID0gZmFzdExlcnA7XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgQ29sb3IgbGlzdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGZ1bGxPdXRwdXQgRGVmYXVsdCBmYWxzZS5cbiAqIEByZXR1cm4geyhzdHJpbmd8T2JqZWN0KX0gUmVzdWx0IGNvbG9yLiBJZiBmdWxsT3V0cHV0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbG9yOiAuLi4sIGxlZnRJbmRleDogLi4uLCByaWdodEluZGV4OiAuLi4sIHZhbHVlOiAuLi59LFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5mdW5jdGlvbiBsZXJwKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBmdWxsT3V0cHV0KSB7XG4gIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKSB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICB2YXIgbGVmdENvbG9yID0gcGFyc2UoY29sb3JzW2xlZnRJbmRleF0pO1xuICB2YXIgcmlnaHRDb2xvciA9IHBhcnNlKGNvbG9yc1tyaWdodEluZGV4XSk7XG4gIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuICB2YXIgY29sb3IgPSBzdHJpbmdpZnkoW2NsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKSwgY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzFdLCByaWdodENvbG9yWzFdLCBkdikpLCBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSksIGNsYW1wQ3NzRmxvYXQobGVycE51bWJlcihsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSldLCAncmdiYScpO1xuICByZXR1cm4gZnVsbE91dHB1dCA/IHtcbiAgICBjb2xvcjogY29sb3IsXG4gICAgbGVmdEluZGV4OiBsZWZ0SW5kZXgsXG4gICAgcmlnaHRJbmRleDogcmlnaHRJbmRleCxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSA6IGNvbG9yO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblxudmFyIG1hcFRvQ29sb3IgPSBsZXJwO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyPX0gaCAwIH4gMzYwLCBpZ25vcmUgd2hlbiBudWxsLlxuICogQHBhcmFtIHtudW1iZXI9fSBzIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICogQHBhcmFtIHtudW1iZXI9fSBsIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICogQHJldHVybiB7c3RyaW5nfSBDb2xvciBzdHJpbmcgaW4gcmdiYSBmb3JtYXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cbmZ1bmN0aW9uIG1vZGlmeUhTTChjb2xvciwgaCwgcywgbCkge1xuICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3IpIHtcbiAgICBjb2xvciA9IHJnYmEyaHNsYShjb2xvcik7XG4gICAgaCAhPSBudWxsICYmIChjb2xvclswXSA9IGNsYW1wQ3NzQW5nbGUoaCkpO1xuICAgIHMgIT0gbnVsbCAmJiAoY29sb3JbMV0gPSBwYXJzZUNzc0Zsb2F0KHMpKTtcbiAgICBsICE9IG51bGwgJiYgKGNvbG9yWzJdID0gcGFyc2VDc3NGbG9hdChsKSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXI9fSBhbHBoYSAwIH4gMVxuICogQHJldHVybiB7c3RyaW5nfSBDb2xvciBzdHJpbmcgaW4gcmdiYSBmb3JtYXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cblxuZnVuY3Rpb24gbW9kaWZ5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvciAmJiBhbHBoYSAhPSBudWxsKSB7XG4gICAgY29sb3JbM10gPSBjbGFtcENzc0Zsb2F0KGFscGhhKTtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGNvbG9yLCAncmdiYScpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyckNvbG9yIGxpa2UgWzEyLDMzLDQ0LDAuNF1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdyZ2JhJywgJ2hzdmEnLCAuLi5cbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0IGNvbG9yLiAoSWYgaW5wdXQgaWxsZWdhbCwgcmV0dXJuIHVuZGVmaW5lZCkuXG4gKi9cblxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyQ29sb3IsIHR5cGUpIHtcbiAgaWYgKCFhcnJDb2xvciB8fCAhYXJyQ29sb3IubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbG9yU3RyID0gYXJyQ29sb3JbMF0gKyAnLCcgKyBhcnJDb2xvclsxXSArICcsJyArIGFyckNvbG9yWzJdO1xuXG4gIGlmICh0eXBlID09PSAncmdiYScgfHwgdHlwZSA9PT0gJ2hzdmEnIHx8IHR5cGUgPT09ICdoc2xhJykge1xuICAgIGNvbG9yU3RyICs9ICcsJyArIGFyckNvbG9yWzNdO1xuICB9XG5cbiAgcmV0dXJuIHR5cGUgKyAnKCcgKyBjb2xvclN0ciArICcpJztcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5saWZ0ID0gbGlmdDtcbmV4cG9ydHMudG9IZXggPSB0b0hleDtcbmV4cG9ydHMuZmFzdExlcnAgPSBmYXN0TGVycDtcbmV4cG9ydHMuZmFzdE1hcFRvQ29sb3IgPSBmYXN0TWFwVG9Db2xvcjtcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLm1hcFRvQ29sb3IgPSBtYXBUb0NvbG9yO1xuZXhwb3J0cy5tb2RpZnlIU0wgPSBtb2RpZnlIU0w7XG5leHBvcnRzLm1vZGlmeUFscGhhID0gbW9kaWZ5QWxwaGE7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9QYXRoXCIpO1xuXG52YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgdHJhbnNmb3JtUGF0aCA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybVBhdGhcIik7XG5cbi8vIGNvbW1hbmQgY2hhcnNcbnZhciBjYyA9IFsnbScsICdNJywgJ2wnLCAnTCcsICd2JywgJ1YnLCAnaCcsICdIJywgJ3onLCAnWicsICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ107XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBQSSA9IE1hdGguUEk7XG5cbnZhciB2TWFnID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdKTtcbn07XG5cbnZhciB2UmF0aW8gPSBmdW5jdGlvbiAodSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKTtcbn07XG5cbnZhciB2QW5nbGUgPSBmdW5jdGlvbiAodSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHZSYXRpbyh1LCB2KSk7XG59O1xuXG5mdW5jdGlvbiBwcm9jZXNzQXJjKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgcHNpRGVnLCBjbWQsIHBhdGgpIHtcbiAgdmFyIHBzaSA9IHBzaURlZyAqIChQSSAvIDE4MC4wKTtcbiAgdmFyIHhwID0gbWF0aENvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aFNpbihwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgeXAgPSAtMSAqIG1hdGhTaW4ocHNpKSAqICh4MSAtIHgyKSAvIDIuMCArIG1hdGhDb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgdmFyIGxhbWJkYSA9IHhwICogeHAgLyAocnggKiByeCkgKyB5cCAqIHlwIC8gKHJ5ICogcnkpO1xuXG4gIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgcnggKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICByeSAqPSBtYXRoU3FydChsYW1iZGEpO1xuICB9XG5cbiAgdmFyIGYgPSAoZmEgPT09IGZzID8gLTEgOiAxKSAqIG1hdGhTcXJ0KChyeCAqIHJ4ICogKHJ5ICogcnkpIC0gcnggKiByeCAqICh5cCAqIHlwKSAtIHJ5ICogcnkgKiAoeHAgKiB4cCkpIC8gKHJ4ICogcnggKiAoeXAgKiB5cCkgKyByeSAqIHJ5ICogKHhwICogeHApKSkgfHwgMDtcbiAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XG4gIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcbiAgdmFyIGN4ID0gKHgxICsgeDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogY3hwIC0gbWF0aFNpbihwc2kpICogY3lwO1xuICB2YXIgY3kgPSAoeTEgKyB5MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiBjeHAgKyBtYXRoQ29zKHBzaSkgKiBjeXA7XG4gIHZhciB0aGV0YSA9IHZBbmdsZShbMSwgMF0sIFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV0pO1xuICB2YXIgdSA9IFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV07XG4gIHZhciB2ID0gWygtMSAqIHhwIC0gY3hwKSAvIHJ4LCAoLTEgKiB5cCAtIGN5cCkgLyByeV07XG4gIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgaWYgKHZSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgIGRUaGV0YSA9IFBJO1xuICB9XG5cbiAgaWYgKHZSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgZFRoZXRhID0gMDtcbiAgfVxuXG4gIGlmIChmcyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XG4gICAgZFRoZXRhID0gZFRoZXRhIC0gMiAqIFBJO1xuICB9XG5cbiAgaWYgKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgKyAyICogUEk7XG4gIH1cblxuICBwYXRoLmFkZERhdGEoY21kLCBjeCwgY3ksIHJ4LCByeSwgdGhldGEsIGRUaGV0YSwgcHNpLCBmcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoZGF0YSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gY29tbWFuZCBzdHJpbmdcblxuXG4gIHZhciBjcyA9IGRhdGEucmVwbGFjZSgvLS9nLCAnIC0nKS5yZXBsYWNlKC8gIC9nLCAnICcpLnJlcGxhY2UoLyAvZywgJywnKS5yZXBsYWNlKC8sLC9nLCAnLCcpO1xuICB2YXIgbjsgLy8gY3JlYXRlIHBpcGVzIHNvIHRoYXQgd2UgY2FuIHNwbGl0IHRoZSBkYXRhXG5cbiAgZm9yIChuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XG4gICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoY2Nbbl0sICdnJyksICd8JyArIGNjW25dKTtcbiAgfSAvLyBjcmVhdGUgYXJyYXlcblxuXG4gIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpOyAvLyBpbml0IGNvbnRleHQgcG9pbnRcblxuICB2YXIgY3B4ID0gMDtcbiAgdmFyIGNweSA9IDA7XG4gIHZhciBwYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB2YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbiAgdmFyIHByZXZDbWQ7XG5cbiAgZm9yIChuID0gMTsgbiA8IGFyci5sZW5ndGg7IG4rKykge1xuICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgdmFyIGMgPSBzdHIuY2hhckF0KDApO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBwID0gc3RyLnNsaWNlKDEpLnJlcGxhY2UoL2UsLS9nLCAnZS0nKS5zcGxpdCgnLCcpO1xuICAgIHZhciBjbWQ7XG5cbiAgICBpZiAocC5sZW5ndGggPiAwICYmIHBbMF0gPT09ICcnKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2ZmIDwgcC5sZW5ndGggJiYgIWlzTmFOKHBbb2ZmXSkpIHtcbiAgICAgIGlmIChpc05hTihwWzBdKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGN0bFB0eDtcbiAgICAgIHZhciBjdGxQdHk7XG4gICAgICB2YXIgcng7XG4gICAgICB2YXIgcnk7XG4gICAgICB2YXIgcHNpO1xuICAgICAgdmFyIGZhO1xuICAgICAgdmFyIGZzO1xuICAgICAgdmFyIHgxID0gY3B4O1xuICAgICAgdmFyIHkxID0gY3B5OyAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcblxuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBjID0gJ2wnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBjID0gJ0wnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10pO1xuICAgICAgICAgIGNweCA9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgY3B5ID0gcFtvZmYgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5KTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICB4MSA9IGNweCArIHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gY3B5ICsgcFtvZmYrK107XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgIHgxID0gcFtvZmYrK10gKyBjcHg7XG4gICAgICAgICAgeTEgPSBwW29mZisrXSArIGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuUSkge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICBwcm9jZXNzQXJjKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgcnggPSBwW29mZisrXTtcbiAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBzaSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZhID0gcFtvZmYrK107XG4gICAgICAgICAgZnMgPSBwW29mZisrXTtcbiAgICAgICAgICB4MSA9IGNweCwgeTEgPSBjcHk7XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICBwcm9jZXNzQXJjKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcbiAgICAgIGNtZCA9IENNRC5aO1xuICAgICAgcGF0aC5hZGREYXRhKGNtZCk7XG4gICAgfVxuXG4gICAgcHJldkNtZCA9IGNtZDtcbiAgfVxuXG4gIHBhdGgudG9TdGF0aWMoKTtcbiAgcmV0dXJuIHBhdGg7XG59IC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cblxuXG5mdW5jdGlvbiBjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpIHtcbiAgdmFyIHBhdGhQcm94eSA9IGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoc3RyKTtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNldERhdGEpIHtcbiAgICAgIHBhdGguc2V0RGF0YShwYXRoUHJveHkuZGF0YSk7IC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuXG4gICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3R4ID0gcGF0aDtcbiAgICAgIHBhdGhQcm94eS5yZWJ1aWxkUGF0aChjdHgpO1xuICAgIH1cbiAgfTtcblxuICBvcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICB0cmFuc2Zvcm1QYXRoKHBhdGhQcm94eSwgbSk7XG4gICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgfTtcblxuICByZXR1cm4gb3B0cztcbn1cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21TdHJpbmcoc3RyLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUGF0aChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBjbGFzcyBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIFBhdGguZXh0ZW5kKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBNZXJnZSBtdWx0aXBsZSBwYXRoc1xuICovXG4vLyBUT0RPIEFwcGx5IHRyYW5zZm9ybVxuLy8gVE9ETyBzdHJva2UgZGFzaFxuLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIG1lcmdlUGF0aChwYXRoRWxzLCBvcHRzKSB7XG4gIHZhciBwYXRoTGlzdCA9IFtdO1xuICB2YXIgbGVuID0gcGF0aEVscy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXRoRWwgPSBwYXRoRWxzW2ldO1xuXG4gICAgaWYgKCFwYXRoRWwucGF0aCkge1xuICAgICAgcGF0aEVsLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgIH1cblxuICAgIGlmIChwYXRoRWwuX19kaXJ0eVBhdGgpIHtcbiAgICAgIHBhdGhFbC5idWlsZFBhdGgocGF0aEVsLnBhdGgsIHBhdGhFbC5zaGFwZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcGF0aExpc3QucHVzaChwYXRoRWwucGF0aCk7XG4gIH1cblxuICB2YXIgcGF0aEJ1bmRsZSA9IG5ldyBQYXRoKG9wdHMpOyAvLyBOZWVkIHBhdGggcHJveHkuXG5cbiAgcGF0aEJ1bmRsZS5jcmVhdGVQYXRoUHJveHkoKTtcblxuICBwYXRoQnVuZGxlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcGF0aC5hcHBlbmRQYXRoKHBhdGhMaXN0KTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBwYXRoQnVuZGxlO1xufVxuXG5leHBvcnRzLmNyZWF0ZUZyb21TdHJpbmcgPSBjcmVhdGVGcm9tU3RyaW5nO1xuZXhwb3J0cy5leHRlbmRGcm9tU3RyaW5nID0gZXh0ZW5kRnJvbVN0cmluZztcbmV4cG9ydHMubWVyZ2VQYXRoID0gbWVyZ2VQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC9wYXRoLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2MkFwcGx5VHJhbnNmb3JtID0gX3ZlY3Rvci5hcHBseVRyYW5zZm9ybTtcbnZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xudmFyIHBvaW50cyA9IFtbXSwgW10sIFtdXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoQXRhbjIgPSBNYXRoLmF0YW4yO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChwYXRoLCBtKSB7XG4gIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICB2YXIgY21kO1xuICB2YXIgblBvaW50O1xuICB2YXIgaTtcbiAgdmFyIGo7XG4gIHZhciBrO1xuICB2YXIgcDtcbiAgdmFyIE0gPSBDTUQuTTtcbiAgdmFyIEMgPSBDTUQuQztcbiAgdmFyIEwgPSBDTUQuTDtcbiAgdmFyIFIgPSBDTUQuUjtcbiAgdmFyIEEgPSBDTUQuQTtcbiAgdmFyIFEgPSBDTUQuUTtcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgIGNtZCA9IGRhdGFbaSsrXTtcbiAgICBqID0gaTtcbiAgICBuUG9pbnQgPSAwO1xuXG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGNhc2UgTTpcbiAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTDpcbiAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQzpcbiAgICAgICAgblBvaW50ID0gMztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUTpcbiAgICAgICAgblBvaW50ID0gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQTpcbiAgICAgICAgdmFyIHggPSBtWzRdO1xuICAgICAgICB2YXIgeSA9IG1bNV07XG4gICAgICAgIHZhciBzeCA9IG1hdGhTcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICB2YXIgc3kgPSBtYXRoU3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gbWF0aEF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7IC8vIGN4XG5cbiAgICAgICAgZGF0YVtpXSAqPSBzeDtcbiAgICAgICAgZGF0YVtpKytdICs9IHg7IC8vIGN5XG5cbiAgICAgICAgZGF0YVtpXSAqPSBzeTtcbiAgICAgICAgZGF0YVtpKytdICs9IHk7IC8vIFNjYWxlIHJ4IGFuZCByeVxuICAgICAgICAvLyBGSVhNRSBBc3N1bWUgcHNpIGlzIDAgaGVyZVxuXG4gICAgICAgIGRhdGFbaSsrXSAqPSBzeDtcbiAgICAgICAgZGF0YVtpKytdICo9IHN5OyAvLyBTdGFydCBhbmdsZVxuXG4gICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTsgLy8gZW5kIGFuZ2xlXG5cbiAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlOyAvLyBGSVhNRSBwc2lcblxuICAgICAgICBpICs9IDI7XG4gICAgICAgIGogPSBpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSOlxuICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgZGF0YVtqKytdID0gcFsxXTsgLy8geDEsIHkxXG5cbiAgICAgICAgcFswXSArPSBkYXRhW2krK107XG4gICAgICAgIHBbMV0gKz0gZGF0YVtpKytdO1xuICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgIH1cblxuICAgIGZvciAoayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgdmFyIHAgPSBwb2ludHNba107XG4gICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7IC8vIFdyaXRlIGJhY2tcblxuICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ3VpZCA9IHJlcXVpcmUoXCIuL2NvcmUvZ3VpZFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuL2NvcmUvZW52XCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgSGFuZGxlciA9IHJlcXVpcmUoXCIuL0hhbmRsZXJcIik7XG5cbnZhciBTdG9yYWdlID0gcmVxdWlyZShcIi4vU3RvcmFnZVwiKTtcblxudmFyIFBhaW50ZXIgPSByZXF1aXJlKFwiLi9QYWludGVyXCIpO1xuXG52YXIgQW5pbWF0aW9uID0gcmVxdWlyZShcIi4vYW5pbWF0aW9uL0FuaW1hdGlvblwiKTtcblxudmFyIEhhbmRsZXJQcm94eSA9IHJlcXVpcmUoXCIuL2RvbS9IYW5kbGVyUHJveHlcIik7XG5cbi8qIVxuKiBaUmVuZGVyLCBhIGhpZ2ggcGVyZm9ybWFuY2UgMmQgZHJhd2luZyBsaWJyYXJ5LlxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJhaWR1IEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogTElDRU5TRVxuKiBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbiovXG52YXIgdXNlVk1MID0gIWVudi5jYW52YXNTdXBwb3J0ZWQ7XG52YXIgcGFpbnRlckN0b3JzID0ge1xuICBjYW52YXM6IFBhaW50ZXJcbn07XG52YXIgaW5zdGFuY2VzID0ge307IC8vIFpSZW5kZXLlrp7kvottYXDntKLlvJVcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5cbnZhciB2ZXJzaW9uID0gJzQuMC40Jztcbi8qKlxuICogSW5pdGlhbGl6aW5nIGEgenJlbmRlciBpbnN0YW5jZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gKi9cblxuZnVuY3Rpb24gaW5pdChkb20sIG9wdHMpIHtcbiAgdmFyIHpyID0gbmV3IFpSZW5kZXIoZ3VpZCgpLCBkb20sIG9wdHMpO1xuICBpbnN0YW5jZXNbenIuaWRdID0genI7XG4gIHJldHVybiB6cjtcbn1cbi8qKlxuICogRGlzcG9zZSB6cmVuZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXNwb3NlKHpyKSB7XG4gIGlmICh6cikge1xuICAgIHpyLmRpc3Bvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5zdGFuY2VzKSB7XG4gICAgICBpZiAoaW5zdGFuY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaW5zdGFuY2VzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlcyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIEdldCB6cmVuZGVyIGluc3RhbmNlIGJ5IGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgenJlbmRlciBpbnN0YW5jZSBpZFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlKGlkKSB7XG4gIHJldHVybiBpbnN0YW5jZXNbaWRdO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclBhaW50ZXIobmFtZSwgQ3Rvcikge1xuICBwYWludGVyQ3RvcnNbbmFtZV0gPSBDdG9yO1xufVxuXG5mdW5jdGlvbiBkZWxJbnN0YW5jZShpZCkge1xuICBkZWxldGUgaW5zdGFuY2VzW2lkXTtcbn1cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL1pSZW5kZXJcbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1pSZW5kZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKi9cblxuXG52YXIgWlJlbmRlciA9IGZ1bmN0aW9uIChpZCwgZG9tLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAvKipcbiAgICogQHR5cGUge0hUTUxEb21FbGVtZW50fVxuICAgKi9cblxuICB0aGlzLmRvbSA9IGRvbTtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuaWQgPSBpZDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3RvcmFnZSA9IG5ldyBTdG9yYWdlKCk7XG4gIHZhciByZW5kZXJlclR5cGUgPSBvcHRzLnJlbmRlcmVyOyAvLyBUT0RPIFdlYkdMXG5cbiAgaWYgKHVzZVZNTCkge1xuICAgIGlmICghcGFpbnRlckN0b3JzLnZtbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byByZXF1aXJlIFxcJ3pyZW5kZXIvdm1sL3ZtbFxcJyB0byBzdXBwb3J0IElFOCcpO1xuICAgIH1cblxuICAgIHJlbmRlcmVyVHlwZSA9ICd2bWwnO1xuICB9IGVsc2UgaWYgKCFyZW5kZXJlclR5cGUgfHwgIXBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKSB7XG4gICAgcmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XG4gIH1cblxuICB2YXIgcGFpbnRlciA9IG5ldyBwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXShkb20sIHN0b3JhZ2UsIG9wdHMsIGlkKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlICYmICFlbnYud29ya2VyID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb259XG4gICAqL1xuXG4gIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgc3RhZ2U6IHtcbiAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICB9XG4gIH0pO1xuICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX25lZWRzUmVmcmVzaDsgLy8g5L+u5pS5IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAvLyBGSVhNRSDmnInngrl1Z2x5XG5cbiAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgdmFyIG9sZEFkZFRvU3RvcmFnZSA9IHN0b3JhZ2UuYWRkVG9TdG9yYWdlO1xuXG4gIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBvbGREZWxGcm9tU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICB9O1xuXG4gIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkQWRkVG9TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuICAgIGVsLmFkZFNlbGZUb1pyKHNlbGYpO1xuICB9O1xufTtcblxuWlJlbmRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuXG4gIC8qKlxuICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5YWD57SgXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgIHRoaXMuc3RvcmFnZS5hZGRSb290KGVsKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTlhYPntKBcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoYW5nZSBjb25maWd1cmF0aW9uIG9mIGxheWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6TGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIENsZWFyIGNvbG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIElmIGVuYWJsZSBtb3Rpb24gYmx1clxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddIE1vdGlvbiBibHVyIGZhY3Rvci4gTGFyZ2VyIHZhbHVlIGNhdXNlIGxvbmdlciB0cmFpbGVyXG4gICovXG4gIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoekxldmVsLCBjb25maWcpIHtcbiAgICBpZiAodGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgIH1cblxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBiYWNrZ3JvdW5kIGNvbG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiYWNrZ3JvdW5kQ29sb3JcbiAgICovXG4gIHNldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24gKGJhY2tncm91bmRDb2xvcikge1xuICAgIGlmICh0aGlzLnBhaW50ZXIuc2V0QmFja2dyb3VuZENvbG9yKSB7XG4gICAgICB0aGlzLnBhaW50ZXIuc2V0QmFja2dyb3VuZENvbG9yKGJhY2tncm91bmRDb2xvcik7XG4gICAgfVxuXG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwYWludCB0aGUgY2FudmFzIGltbWVkaWF0ZWx5XG4gICAqL1xuICByZWZyZXNoSW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuICAgIC8vIENsZWFyIG5lZWRzUmVmcmVzaCBhaGVhZCB0byBhdm9pZCBzb21ldGhpbmcgd3JvbmcgaGFwcGVucyBpbiByZWZyZXNoXG4gICAgLy8gT3IgaXQgd2lsbCBjYXVzZSB6cmVuZGVyIHJlZnJlc2hlcyBhZ2FpbiBhbmQgYWdhaW4uXG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgdGhpcy5wYWludGVyLnJlZnJlc2goKTtcbiAgICAvKipcbiAgICAgKiBBdm9pZCB0cmlnZ2VyIHpyLnJlZnJlc2ggaW4gRWxlbWVudCNiZWZvcmVVcGRhdGUgaG9va1xuICAgICAqL1xuXG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7IC8vIHZhciBlbmQgPSBuZXcgRGF0ZSgpO1xuICAgIC8vIHZhciBsb2cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9nJyk7XG4gICAgLy8gaWYgKGxvZykge1xuICAgIC8vICAgICBsb2cuaW5uZXJIVE1MID0gbG9nLmlubmVySFRNTCArICc8YnI+JyArIChlbmQgLSBzdGFydCk7XG4gICAgLy8gfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNYXJrIGFuZCByZXBhaW50IHRoZSBjYW52YXMgaW4gdGhlIG5leHQgZnJhbWUgb2YgYnJvd3NlclxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYWxsIHJlZnJlc2hcbiAgICovXG4gIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyaWdnZXJSZW5kZXJlZDtcblxuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgIHRyaWdnZXJSZW5kZXJlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlZnJlc2hJbW1lZGlhdGVseSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2hIb3Zlcikge1xuICAgICAgdHJpZ2dlclJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVmcmVzaEhvdmVySW1tZWRpYXRlbHkoKTtcbiAgICB9XG5cbiAgICB0cmlnZ2VyUmVuZGVyZWQgJiYgdGhpcy50cmlnZ2VyKCdyZW5kZXJlZCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICovXG4gIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5jbGVhckhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgKi9cbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGltbWVkaWF0ZWx5XG4gICAqL1xuICByZWZyZXNoSG92ZXJJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMucGFpbnRlci5yZXNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgKi9cbiAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAqL1xuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9ydCB0aGUgY2FudmFzIGFzIEJhc2U2NCBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3I9JyNmZmYnXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBVUkxcbiAgICovXG4gIC8vIHRvRGF0YVVSTDogZnVuY3Rpb24odHlwZSwgYmFja2dyb3VuZENvbG9yKSB7XG4gIC8vICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKHtcbiAgLy8gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAvLyAgICAgfSkudG9EYXRhVVJMKHR5cGUpO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0aW5nIGEgcGF0aCB0byBpbWFnZS5cbiAgICogSXQgaGFzIG11Y2ggYmV0dGVyIHBlcmZvcm1hbmNlIG9mIGRyYXdpbmcgaW1hZ2UgcmF0aGVyIHRoYW4gZHJhd2luZyBhIHZlY3RvciBwYXRoLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gZVxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChlLCBkcHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGUsIGRwcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgKi9cbiAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgIHRoaXMuaGFuZGxlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmQgaG92ZXJlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge09iamVjdH0ge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgKi9cbiAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZmluZEhvdmVyKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRoaXMuaGFuZGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICB0aGlzLnBhaW50ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZSBzZWxmLlxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5hbmltYXRpb24gPSB0aGlzLnN0b3JhZ2UgPSB0aGlzLnBhaW50ZXIgPSB0aGlzLmhhbmRsZXIgPSBudWxsO1xuICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICB9XG59O1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuZXhwb3J0cy5nZXRJbnN0YW5jZSA9IGdldEluc3RhbmNlO1xuZXhwb3J0cy5yZWdpc3RlclBhaW50ZXIgPSByZWdpc3RlclBhaW50ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvenJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvenJlbmRlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIilcbi8qIHNjcmlwdCAqL1xudmFyIF9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3tcXFwiY2FjaGVEaXJlY3RvcnlcXFwiOnRydWUsXFxcInByZXNldHNcXFwiOltbXFxcImVudlxcXCIse1xcXCJtb2R1bGVzXFxcIjpmYWxzZSxcXFwidGFyZ2V0c1xcXCI6e1xcXCJicm93c2Vyc1xcXCI6W1xcXCI+IDIlXFxcIl0sXFxcInVnbGlmeVxcXCI6dHJ1ZX19XV0sXFxcInBsdWdpbnNcXFwiOltcXFwidHJhbnNmb3JtLW9iamVjdC1yZXN0LXNwcmVhZFxcXCIsW1xcXCJ0cmFuc2Zvcm0tcnVudGltZVxcXCIse1xcXCJwb2x5ZmlsbFxcXCI6ZmFsc2UsXFxcImhlbHBlcnNcXFwiOmZhbHNlfV1dfSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3VzZXJfdHJhbnNmZXIudnVlXCIpXG4vKiB0ZW1wbGF0ZSAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03MTExZjExYlxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3VzZXJfdHJhbnNmZXIudnVlXCIpXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInJlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9pbmRleC91c2VyX3RyYW5zZmVyLnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi03MTExZjExYlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTcxMTFmMTFiXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvaW5kZXgvdXNlcl90cmFuc2Zlci52dWVcbi8vIG1vZHVsZSBpZCA9IC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL2luZGV4L3VzZXJfdHJhbnNmZXIudnVlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=