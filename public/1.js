webpackJsonp([1],Array(69).concat([
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__(1)
/* script */
var __vue_script__ = __webpack_require__(320)
/* template */
var __vue_template__ = __webpack_require__(321)
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources\\assets\\js\\components\\index\\user_transfer.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-ae438964", Component.options)
  } else {
    hotAPI.reload("data-v-ae438964", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */
/***/ (function(module, exports) {

/**
 * @module zrender/core/util
 */
// 用于处理merge时无法遍历Date等对象的问题
var BUILTIN_OBJECT = {
  '[object Function]': 1,
  '[object RegExp]': 1,
  '[object Date]': 1,
  '[object Error]': 1,
  '[object CanvasGradient]': 1,
  '[object CanvasPattern]': 1,
  // For node-canvas
  '[object Image]': 1,
  '[object Canvas]': 1
};
var TYPED_ARRAY = {
  '[object Int8Array]': 1,
  '[object Uint8Array]': 1,
  '[object Uint8ClampedArray]': 1,
  '[object Int16Array]': 1,
  '[object Uint16Array]': 1,
  '[object Int32Array]': 1,
  '[object Uint32Array]': 1,
  '[object Float32Array]': 1,
  '[object Float64Array]': 1
};
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.

var methods = {};

function $override(name, fn) {
  methods[name] = fn;
}
/**
 * Those data types can be cloned:
 *     Plain object, Array, TypedArray, number, string, null, undefined.
 * Those data types will be assgined using the orginal data:
 *     BUILTIN_OBJECT
 * Instance of user defined class will be cloned to a plain object, without
 * properties in prototype.
 * Other data types is not supported (not sure what will happen).
 *
 * Caution: do not support clone Date, for performance consideration.
 * (There might be a large number of date in `series.data`).
 * So date should not be modified in and out of echarts.
 *
 * @param {*} source
 * @return {*} new
 */


function clone(source) {
  if (source == null || typeof source != 'object') {
    return source;
  }

  var result = source;
  var typeStr = objToString.call(source);

  if (typeStr === '[object Array]') {
    result = [];

    for (var i = 0, len = source.length; i < len; i++) {
      result[i] = clone(source[i]);
    }
  } else if (TYPED_ARRAY[typeStr]) {
    var Ctor = source.constructor;

    if (source.constructor.from) {
      result = Ctor.from(source);
    } else {
      result = new Ctor(source.length);

      for (var i = 0, len = source.length; i < len; i++) {
        result[i] = clone(source[i]);
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};

    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        result[key] = clone(source[key]);
      }
    }
  }

  return result;
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overwrite=false]
 */


function merge(target, source, overwrite) {
  // We should escapse that source is string
  // and enter for ... in ...
  if (!isObject(source) || !isObject(target)) {
    return overwrite ? clone(source) : target;
  }

  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      var targetProp = target[key];
      var sourceProp = source[key];

      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        // 如果需要递归覆盖，就递归调用merge
        merge(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
        // NOTE，在 target[key] 不存在的时候也是直接覆盖
        target[key] = clone(source[key], true);
      }
    }
  }

  return target;
}
/**
 * @param {Array} targetAndSources The first item is target, and the rests are source.
 * @param {boolean} [overwrite=false]
 * @return {*} target
 */


function mergeAll(targetAndSources, overwrite) {
  var result = targetAndSources[0];

  for (var i = 1, len = targetAndSources.length; i < len; i++) {
    result = merge(result, targetAndSources[i], overwrite);
  }

  return result;
}
/**
 * @param {*} target
 * @param {*} source
 * @memberOf module:zrender/core/util
 */


function extend(target, source) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }

  return target;
}
/**
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overlay=false]
 * @memberOf module:zrender/core/util
 */


function defaults(target, source, overlay) {
  for (var key in source) {
    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
      target[key] = source[key];
    }
  }

  return target;
}

var createCanvas = function () {
  return methods.createCanvas();
};

methods.createCanvas = function () {
  return document.createElement('canvas');
}; // FIXME


var _ctx;

function getContext() {
  if (!_ctx) {
    // Use util.createCanvas instead of createCanvas
    // because createCanvas may be overwritten in different environment
    _ctx = createCanvas().getContext('2d');
  }

  return _ctx;
}
/**
 * 查询数组中元素的index
 * @memberOf module:zrender/core/util
 */


function indexOf(array, value) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value);
    }

    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
  }

  return -1;
}
/**
 * 构造类继承关系
 *
 * @memberOf module:zrender/core/util
 * @param {Function} clazz 源类
 * @param {Function} baseClazz 基类
 */


function inherits(clazz, baseClazz) {
  var clazzPrototype = clazz.prototype;

  function F() {}

  F.prototype = baseClazz.prototype;
  clazz.prototype = new F();

  for (var prop in clazzPrototype) {
    clazz.prototype[prop] = clazzPrototype[prop];
  }

  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
/**
 * @memberOf module:zrender/core/util
 * @param {Object|Function} target
 * @param {Object|Function} sorce
 * @param {boolean} overlay
 */


function mixin(target, source, overlay) {
  target = 'prototype' in target ? target.prototype : target;
  source = 'prototype' in source ? source.prototype : source;
  defaults(target, source, overlay);
}
/**
 * Consider typed array.
 * @param {Array|TypedArray} data
 */


function isArrayLike(data) {
  if (!data) {
    return;
  }

  if (typeof data == 'string') {
    return false;
  }

  return typeof data.length == 'number';
}
/**
 * 数组或对象遍历
 * @memberOf module:zrender/core/util
 * @param {Object|Array} obj
 * @param {Function} cb
 * @param {*} [context]
 */


function each(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.forEach && obj.forEach === nativeForEach) {
    obj.forEach(cb, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, len = obj.length; i < len; i++) {
      cb.call(context, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        cb.call(context, obj[key], key, obj);
      }
    }
  }
}
/**
 * 数组映射
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */


function map(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.map && obj.map === nativeMap) {
    return obj.map(cb, context);
  } else {
    var result = [];

    for (var i = 0, len = obj.length; i < len; i++) {
      result.push(cb.call(context, obj[i], i, obj));
    }

    return result;
  }
}
/**
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {Object} [memo]
 * @param {*} [context]
 * @return {Array}
 */


function reduce(obj, cb, memo, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.reduce && obj.reduce === nativeReduce) {
    return obj.reduce(cb, memo, context);
  } else {
    for (var i = 0, len = obj.length; i < len; i++) {
      memo = cb.call(context, memo, obj[i], i, obj);
    }

    return memo;
  }
}
/**
 * 数组过滤
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */


function filter(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.filter && obj.filter === nativeFilter) {
    return obj.filter(cb, context);
  } else {
    var result = [];

    for (var i = 0, len = obj.length; i < len; i++) {
      if (cb.call(context, obj[i], i, obj)) {
        result.push(obj[i]);
      }
    }

    return result;
  }
}
/**
 * 数组项查找
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {*}
 */


function find(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  for (var i = 0, len = obj.length; i < len; i++) {
    if (cb.call(context, obj[i], i, obj)) {
      return obj[i];
    }
  }
}
/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @param {*} context
 * @return {Function}
 */


function bind(func, context) {
  var args = nativeSlice.call(arguments, 2);
  return function () {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @return {Function}
 */


function curry(func) {
  var args = nativeSlice.call(arguments, 1);
  return function () {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isArray(value) {
  return objToString.call(value) === '[object Array]';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isFunction(value) {
  return typeof value === 'function';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isString(value) {
  return objToString.call(value) === '[object String]';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type === 'function' || !!value && type == 'object';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isDom(value) {
  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
}
/**
 * Whether is exactly NaN. Notice isNaN('a') returns true.
 * @param {*} value
 * @return {boolean}
 */


function eqNaN(value) {
  return value !== value;
}
/**
 * If value1 is not null, then return value1, otherwise judget rest of values.
 * Low performance.
 * @memberOf module:zrender/core/util
 * @return {*} Final value
 */


function retrieve(values) {
  for (var i = 0, len = arguments.length; i < len; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }
}

function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}

function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
/**
 * @memberOf module:zrender/core/util
 * @param {Array} arr
 * @param {number} startIndex
 * @param {number} endIndex
 * @return {Array}
 */


function slice() {
  return Function.call.apply(nativeSlice, arguments);
}
/**
 * Normalize css liked array configuration
 * e.g.
 *  3 => [3, 3, 3, 3]
 *  [4, 2] => [4, 2, 4, 2]
 *  [4, 3, 2] => [4, 3, 2, 3]
 * @param {number|Array.<number>} val
 * @return {Array.<number>}
 */


function normalizeCssArray(val) {
  if (typeof val === 'number') {
    return [val, val, val, val];
  }

  var len = val.length;

  if (len === 2) {
    // vertical | horizontal
    return [val[0], val[1], val[0], val[1]];
  } else if (len === 3) {
    // top | horizontal | bottom
    return [val[0], val[1], val[2], val[1]];
  }

  return val;
}
/**
 * @memberOf module:zrender/core/util
 * @param {boolean} condition
 * @param {string} message
 */


function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

var primitiveKey = '__ec_primitive__';
/**
 * Set an object as primitive to be ignored traversing children in clone or merge
 */

function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}

function isPrimitive(obj) {
  return obj[primitiveKey];
}
/**
 * @constructor
 * @param {Object} obj Only apply `ownProperty`.
 */


function HashMap(obj) {
  obj && each(obj, function (value, key) {
    this.set(key, value);
  }, this);
} // Add prefix to avoid conflict with Object.prototype.


var HASH_MAP_PREFIX = '_ec_';
var HASH_MAP_PREFIX_LENGTH = 4;
HashMap.prototype = {
  constructor: HashMap,
  // Do not provide `has` method to avoid defining what is `has`.
  // (We usually treat `null` and `undefined` as the same, different
  // from ES6 Map).
  get: function (key) {
    return this[HASH_MAP_PREFIX + key];
  },
  set: function (key, value) {
    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly
    // used in this case: `var someVal = map.set('a', genVal());`

    return value;
  },
  // Although util.each can be performed on this hashMap directly, user
  // should not use the exposed keys, who are prefixed.
  each: function (cb, context) {
    context !== void 0 && (cb = bind(cb, context));

    for (var prefixedKey in this) {
      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));
    }
  },
  // Do not use this method if performance sensitive.
  removeKey: function (key) {
    delete this[HASH_MAP_PREFIX + key];
  }
};

function createHashMap(obj) {
  return new HashMap(obj);
}

function noop() {}

exports.$override = $override;
exports.clone = clone;
exports.merge = merge;
exports.mergeAll = mergeAll;
exports.extend = extend;
exports.defaults = defaults;
exports.createCanvas = createCanvas;
exports.getContext = getContext;
exports.indexOf = indexOf;
exports.inherits = inherits;
exports.mixin = mixin;
exports.isArrayLike = isArrayLike;
exports.each = each;
exports.map = map;
exports.reduce = reduce;
exports.filter = filter;
exports.find = find;
exports.bind = bind;
exports.curry = curry;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isString = isString;
exports.isObject = isObject;
exports.isBuiltInObject = isBuiltInObject;
exports.isDom = isDom;
exports.eqNaN = eqNaN;
exports.retrieve = retrieve;
exports.retrieve2 = retrieve2;
exports.retrieve3 = retrieve3;
exports.slice = slice;
exports.normalizeCssArray = normalizeCssArray;
exports.assert = assert;
exports.setAsPrimitive = setAsPrimitive;
exports.isPrimitive = isPrimitive;
exports.createHashMap = createHashMap;
exports.noop = noop;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrender = __webpack_require__(138);

var zrUtil = __webpack_require__(91);

var colorTool = __webpack_require__(113);

var env = __webpack_require__(98);

var timsort = __webpack_require__(126);

var Eventful = __webpack_require__(107);

var GlobalModel = __webpack_require__(197);

var ExtensionAPI = __webpack_require__(226);

var CoordinateSystemManager = __webpack_require__(131);

var OptionManager = __webpack_require__(227);

var backwardCompat = __webpack_require__(228);

var ComponentModel = __webpack_require__(105);

var SeriesModel = __webpack_require__(132);

var ComponentView = __webpack_require__(157);

var ChartView = __webpack_require__(158);

var graphic = __webpack_require__(93);

var modelUtil = __webpack_require__(95);

var _throttle = __webpack_require__(114);

var throttle = _throttle.throttle;

var seriesColor = __webpack_require__(230);

var loadingDefault = __webpack_require__(231);

/*!
 * ECharts, a javascript interactive chart library.
 *
 * Copyright (c) 2015, Baidu Inc.
 * All rights reserved.
 *
 * LICENSE
 * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
 */
var each = zrUtil.each;
var parseClassType = ComponentModel.parseClassType;
var version = '3.8.5';
var dependencies = {
  zrender: '3.7.4'
};
var PRIORITY_PROCESSOR_FILTER = 1000;
var PRIORITY_PROCESSOR_STATISTIC = 5000;
var PRIORITY_VISUAL_LAYOUT = 1000;
var PRIORITY_VISUAL_GLOBAL = 2000;
var PRIORITY_VISUAL_CHART = 3000;
var PRIORITY_VISUAL_COMPONENT = 4000; // FIXME
// necessary?

var PRIORITY_VISUAL_BRUSH = 5000;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH
  }
}; // Main process have three entries: `setOption`, `dispatchAction` and `resize`,
// where they must not be invoked nestedly, except the only case: invoke
// dispatchAction with updateMethod "none" in main process.
// This flag is used to carry out this rule.
// All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).

var IN_MAIN_PROCESS = '__flagInMainProcess';
var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';
var OPTION_UPDATED = '__optionUpdated';
var ACTION_REG = /^[a-zA-Z0-9_]+$/;

function createRegisterEventWithLowercaseName(method) {
  return function (eventName, handler, context) {
    // Event name is all lowercase
    eventName = eventName && eventName.toLowerCase();
    Eventful.prototype[method].call(this, eventName, handler, context);
  };
}
/**
 * @module echarts~MessageCenter
 */


function MessageCenter() {
  Eventful.call(this);
}

MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');
MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');
MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');
zrUtil.mixin(MessageCenter, Eventful);
/**
 * @module echarts~ECharts
 */

function ECharts(dom, theme, opts) {
  opts = opts || {}; // Get theme by name

  if (typeof theme === 'string') {
    theme = themeStorage[theme];
  }
  /**
   * @type {string}
   */


  this.id;
  /**
   * Group id
   * @type {string}
   */

  this.group;
  /**
   * @type {HTMLElement}
   * @private
   */

  this._dom = dom;
  var defaultRenderer = 'canvas';

  /**
   * @type {module:zrender/ZRender}
   * @private
   */
  var zr = this._zr = zrender.init(dom, {
    renderer: opts.renderer || defaultRenderer,
    devicePixelRatio: opts.devicePixelRatio,
    width: opts.width,
    height: opts.height
  });
  /**
   * Expect 60 pfs.
   * @type {Function}
   * @private
   */

  this._throttledZrFlush = throttle(zrUtil.bind(zr.flush, zr), 17);
  var theme = zrUtil.clone(theme);
  theme && backwardCompat(theme, true);
  /**
   * @type {Object}
   * @private
   */

  this._theme = theme;
  /**
   * @type {Array.<module:echarts/view/Chart>}
   * @private
   */

  this._chartsViews = [];
  /**
   * @type {Object.<string, module:echarts/view/Chart>}
   * @private
   */

  this._chartsMap = {};
  /**
   * @type {Array.<module:echarts/view/Component>}
   * @private
   */

  this._componentsViews = [];
  /**
   * @type {Object.<string, module:echarts/view/Component>}
   * @private
   */

  this._componentsMap = {};
  /**
   * @type {module:echarts/CoordinateSystem}
   * @private
   */

  this._coordSysMgr = new CoordinateSystemManager();
  /**
   * @type {module:echarts/ExtensionAPI}
   * @private
   */

  this._api = createExtensionAPI(this);
  Eventful.call(this);
  /**
   * @type {module:echarts~MessageCenter}
   * @private
   */

  this._messageCenter = new MessageCenter(); // Init mouse events

  this._initEvents(); // In case some people write `window.onresize = chart.resize`


  this.resize = zrUtil.bind(this.resize, this); // Can't dispatch action during rendering procedure

  this._pendingActions = []; // Sort on demand

  function prioritySortFunc(a, b) {
    return a.prio - b.prio;
  }

  timsort(visualFuncs, prioritySortFunc);
  timsort(dataProcessorFuncs, prioritySortFunc);
  zr.animation.on('frame', this._onframe, this); // ECharts instance can be used as value.

  zrUtil.setAsPrimitive(this);
}

var echartsProto = ECharts.prototype;

echartsProto._onframe = function () {
  // Lazy update
  if (this[OPTION_UPDATED]) {
    var silent = this[OPTION_UPDATED].silent;
    this[IN_MAIN_PROCESS] = true;
    updateMethods.prepareAndUpdate.call(this);
    this[IN_MAIN_PROCESS] = false;
    this[OPTION_UPDATED] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  }
};
/**
 * @return {HTMLElement}
 */


echartsProto.getDom = function () {
  return this._dom;
};
/**
 * @return {module:zrender~ZRender}
 */


echartsProto.getZr = function () {
  return this._zr;
};
/**
 * Usage:
 * chart.setOption(option, notMerge, lazyUpdate);
 * chart.setOption(option, {
 *     notMerge: ...,
 *     lazyUpdate: ...,
 *     silent: ...
 * });
 *
 * @param {Object} option
 * @param {Object|boolean} [opts] opts or notMerge.
 * @param {boolean} [opts.notMerge=false]
 * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.
 */


echartsProto.setOption = function (option, notMerge, lazyUpdate) {
  var silent;

  if (zrUtil.isObject(notMerge)) {
    lazyUpdate = notMerge.lazyUpdate;
    silent = notMerge.silent;
    notMerge = notMerge.notMerge;
  }

  this[IN_MAIN_PROCESS] = true;

  if (!this._model || notMerge) {
    var optionManager = new OptionManager(this._api);
    var theme = this._theme;
    var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);
    ecModel.init(null, null, theme, optionManager);
  }

  this._model.setOption(option, optionPreprocessorFuncs);

  if (lazyUpdate) {
    this[OPTION_UPDATED] = {
      silent: silent
    };
    this[IN_MAIN_PROCESS] = false;
  } else {
    updateMethods.prepareAndUpdate.call(this); // Ensure zr refresh sychronously, and then pixel in canvas can be
    // fetched after `setOption`.

    this._zr.flush();

    this[OPTION_UPDATED] = false;
    this[IN_MAIN_PROCESS] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  }
};
/**
 * @DEPRECATED
 */


echartsProto.setTheme = function () {
  console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
};
/**
 * @return {module:echarts/model/Global}
 */


echartsProto.getModel = function () {
  return this._model;
};
/**
 * @return {Object}
 */


echartsProto.getOption = function () {
  return this._model && this._model.getOption();
};
/**
 * @return {number}
 */


echartsProto.getWidth = function () {
  return this._zr.getWidth();
};
/**
 * @return {number}
 */


echartsProto.getHeight = function () {
  return this._zr.getHeight();
};
/**
 * @return {number}
 */


echartsProto.getDevicePixelRatio = function () {
  return this._zr.painter.dpr || window.devicePixelRatio || 1;
};
/**
 * Get canvas which has all thing rendered
 * @param {Object} opts
 * @param {string} [opts.backgroundColor]
 * @return {string}
 */


echartsProto.getRenderedCanvas = function (opts) {
  if (!env.canvasSupported) {
    return;
  }

  opts = opts || {};
  opts.pixelRatio = opts.pixelRatio || 1;
  opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');
  var zr = this._zr;
  var list = zr.storage.getDisplayList(); // Stop animations

  zrUtil.each(list, function (el) {
    el.stopAnimation(true);
  });
  return zr.painter.getRenderedCanvas(opts);
};
/**
 * Get svg data url
 * @return {string}
 */


echartsProto.getSvgDataUrl = function () {
  if (!env.svgSupported) {
    return;
  }

  var zr = this._zr;
  var list = zr.storage.getDisplayList(); // Stop animations

  zrUtil.each(list, function (el) {
    el.stopAnimation(true);
  });
  return zr.painter.pathToSvg();
};
/**
 * @return {string}
 * @param {Object} opts
 * @param {string} [opts.type='png']
 * @param {string} [opts.pixelRatio=1]
 * @param {string} [opts.backgroundColor]
 * @param {string} [opts.excludeComponents]
 */


echartsProto.getDataURL = function (opts) {
  opts = opts || {};
  var excludeComponents = opts.excludeComponents;
  var ecModel = this._model;
  var excludesComponentViews = [];
  var self = this;
  each(excludeComponents, function (componentType) {
    ecModel.eachComponent({
      mainType: componentType
    }, function (component) {
      var view = self._componentsMap[component.__viewId];

      if (!view.group.ignore) {
        excludesComponentViews.push(view);
        view.group.ignore = true;
      }
    });
  });
  var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataUrl() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));
  each(excludesComponentViews, function (view) {
    view.group.ignore = false;
  });
  return url;
};
/**
 * @return {string}
 * @param {Object} opts
 * @param {string} [opts.type='png']
 * @param {string} [opts.pixelRatio=1]
 * @param {string} [opts.backgroundColor]
 */


echartsProto.getConnectedDataURL = function (opts) {
  if (!env.canvasSupported) {
    return;
  }

  var groupId = this.group;
  var mathMin = Math.min;
  var mathMax = Math.max;
  var MAX_NUMBER = Infinity;

  if (connectedGroups[groupId]) {
    var left = MAX_NUMBER;
    var top = MAX_NUMBER;
    var right = -MAX_NUMBER;
    var bottom = -MAX_NUMBER;
    var canvasList = [];
    var dpr = opts && opts.pixelRatio || 1;
    zrUtil.each(instances, function (chart, id) {
      if (chart.group === groupId) {
        var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));
        var boundingRect = chart.getDom().getBoundingClientRect();
        left = mathMin(boundingRect.left, left);
        top = mathMin(boundingRect.top, top);
        right = mathMax(boundingRect.right, right);
        bottom = mathMax(boundingRect.bottom, bottom);
        canvasList.push({
          dom: canvas,
          left: boundingRect.left,
          top: boundingRect.top
        });
      }
    });
    left *= dpr;
    top *= dpr;
    right *= dpr;
    bottom *= dpr;
    var width = right - left;
    var height = bottom - top;
    var targetCanvas = zrUtil.createCanvas();
    targetCanvas.width = width;
    targetCanvas.height = height;
    var zr = zrender.init(targetCanvas);
    each(canvasList, function (item) {
      var img = new graphic.Image({
        style: {
          x: item.left * dpr - left,
          y: item.top * dpr - top,
          image: item.dom
        }
      });
      zr.add(img);
    });
    zr.refreshImmediately();
    return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
  } else {
    return this.getDataURL(opts);
  }
};
/**
 * Convert from logical coordinate system to pixel coordinate system.
 * See CoordinateSystem#convertToPixel.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId, geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName,
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {Array|number} result
 */


echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');
/**
 * Convert from pixel coordinate system to logical coordinate system.
 * See CoordinateSystem#convertFromPixel.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId / geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {Array|number} result
 */

echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');

function doConvertPixel(methodName, finder, value) {
  var ecModel = this._model;

  var coordSysList = this._coordSysMgr.getCoordinateSystems();

  var result;
  finder = modelUtil.parseFinder(ecModel, finder);

  for (var i = 0; i < coordSysList.length; i++) {
    var coordSys = coordSysList[i];

    if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {
      return result;
    }
  }
}
/**
 * Is the specified coordinate systems or components contain the given pixel point.
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            geoIndex / geoId / geoName,
 *            bmapIndex / bmapId / bmapName,
 *            xAxisIndex / xAxisId / xAxisName,
 *            yAxisIndex / yAxisId / yAxisName,
 *            gridIndex / gridId / gridName,
 *            ... (can be extended)
 *        }
 * @param {Array|number} value
 * @return {boolean} result
 */


echartsProto.containPixel = function (finder, value) {
  var ecModel = this._model;
  var result;
  finder = modelUtil.parseFinder(ecModel, finder);
  zrUtil.each(finder, function (models, key) {
    key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {
      var coordSys = model.coordinateSystem;

      if (coordSys && coordSys.containPoint) {
        result |= !!coordSys.containPoint(value);
      } else if (key === 'seriesModels') {
        var view = this._chartsMap[model.__viewId];

        if (view && view.containPoint) {
          result |= view.containPoint(value, model);
        } else {}
      } else {}
    }, this);
  }, this);
  return !!result;
};
/**
 * Get visual from series or data.
 * @param {string|Object} finder
 *        If string, e.g., 'series', means {seriesIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex / seriesId / seriesName,
 *            dataIndex / dataIndexInside
 *        }
 *        If dataIndex is not specified, series visual will be fetched,
 *        but not data item visual.
 *        If all of seriesIndex, seriesId, seriesName are not specified,
 *        visual will be fetched from first series.
 * @param {string} visualType 'color', 'symbol', 'symbolSize'
 */


echartsProto.getVisual = function (finder, visualType) {
  var ecModel = this._model;
  finder = modelUtil.parseFinder(ecModel, finder, {
    defaultMainType: 'series'
  });
  var seriesModel = finder.seriesModel;
  var data = seriesModel.getData();
  var dataIndexInside = finder.hasOwnProperty('dataIndexInside') ? finder.dataIndexInside : finder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(finder.dataIndex) : null;
  return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);
};
/**
 * Get view of corresponding component model
 * @param  {module:echarts/model/Component} componentModel
 * @return {module:echarts/view/Component}
 */


echartsProto.getViewOfComponentModel = function (componentModel) {
  return this._componentsMap[componentModel.__viewId];
};
/**
 * Get view of corresponding series model
 * @param  {module:echarts/model/Series} seriesModel
 * @return {module:echarts/view/Chart}
 */


echartsProto.getViewOfSeriesModel = function (seriesModel) {
  return this._chartsMap[seriesModel.__viewId];
};

var updateMethods = {
  /**
   * @param {Object} payload
   * @private
   */
  update: function (payload) {
    // console.profile && console.profile('update');
    var ecModel = this._model;
    var api = this._api;
    var coordSysMgr = this._coordSysMgr;
    var zr = this._zr; // update before setOption

    if (!ecModel) {
      return;
    } // Fixme First time update ?


    ecModel.restoreData(); // TODO
    // Save total ecModel here for undo/redo (after restoring data and before processing data).
    // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
    // Create new coordinate system each update
    // In LineView may save the old coordinate system and use it to get the orignal point

    coordSysMgr.create(this._model, this._api);
    processData.call(this, ecModel, api);
    stackSeriesData.call(this, ecModel);
    coordSysMgr.update(ecModel, api);
    doVisualEncoding.call(this, ecModel, payload);
    doRender.call(this, ecModel, payload); // Set background

    var backgroundColor = ecModel.get('backgroundColor') || 'transparent';
    var painter = zr.painter; // TODO all use clearColor ?

    if (painter.isSingleCanvas && painter.isSingleCanvas()) {
      zr.configLayer(0, {
        clearColor: backgroundColor
      });
    } else {
      // In IE8
      if (!env.canvasSupported) {
        var colorArr = colorTool.parse(backgroundColor);
        backgroundColor = colorTool.stringify(colorArr, 'rgb');

        if (colorArr[3] === 0) {
          backgroundColor = 'transparent';
        }
      }

      if (backgroundColor.colorStops || backgroundColor.image) {
        // Gradient background
        // FIXME Fixed layer？
        zr.configLayer(0, {
          clearColor: backgroundColor
        });
        this[HAS_GRADIENT_OR_PATTERN_BG] = true;
        this._dom.style.background = 'transparent';
      } else {
        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {
          zr.configLayer(0, {
            clearColor: null
          });
        }

        this[HAS_GRADIENT_OR_PATTERN_BG] = false;
        this._dom.style.background = backgroundColor;
      }
    }

    each(postUpdateFuncs, function (func) {
      func(ecModel, api);
    }); // console.profile && console.profileEnd('update');
  },

  /**
   * @param {Object} payload
   * @private
   */
  updateView: function (payload) {
    var ecModel = this._model; // update before setOption

    if (!ecModel) {
      return;
    }

    ecModel.eachSeries(function (seriesModel) {
      seriesModel.getData().clearAllVisual();
    });
    doVisualEncoding.call(this, ecModel, payload);
    invokeUpdateMethod.call(this, 'updateView', ecModel, payload);
  },

  /**
   * @param {Object} payload
   * @private
   */
  updateVisual: function (payload) {
    var ecModel = this._model; // update before setOption

    if (!ecModel) {
      return;
    }

    ecModel.eachSeries(function (seriesModel) {
      seriesModel.getData().clearAllVisual();
    });
    doVisualEncoding.call(this, ecModel, payload, true);
    invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);
  },

  /**
   * @param {Object} payload
   * @private
   */
  updateLayout: function (payload) {
    var ecModel = this._model; // update before setOption

    if (!ecModel) {
      return;
    }

    doLayout.call(this, ecModel, payload);
    invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);
  },

  /**
   * @param {Object} payload
   * @private
   */
  prepareAndUpdate: function (payload) {
    var ecModel = this._model;
    prepareView.call(this, 'component', ecModel);
    prepareView.call(this, 'chart', ecModel);
    updateMethods.update.call(this, payload);
  }
};
/**
 * @private
 */

function updateDirectly(ecIns, method, payload, mainType, subType) {
  var ecModel = ecIns._model; // broadcast

  if (!mainType) {
    each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);
    return;
  }

  var query = {};
  query[mainType + 'Id'] = payload[mainType + 'Id'];
  query[mainType + 'Index'] = payload[mainType + 'Index'];
  query[mainType + 'Name'] = payload[mainType + 'Name'];
  var condition = {
    mainType: mainType,
    query: query
  };
  subType && (condition.subType = subType); // subType may be '' by parseClassType;
  // If dispatchAction before setOption, do nothing.

  ecModel && ecModel.eachComponent(condition, function (model, index) {
    callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);
  }, ecIns);

  function callView(view) {
    view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
  }
}
/**
 * Resize the chart
 * @param {Object} opts
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 * @param {boolean} [opts.silent=false]
 */


echartsProto.resize = function (opts) {
  this[IN_MAIN_PROCESS] = true;

  this._zr.resize(opts);

  var optionChanged = this._model && this._model.resetOption('media');

  var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';
  updateMethods[updateMethod].call(this); // Resize loading effect

  this._loadingFX && this._loadingFX.resize();
  this[IN_MAIN_PROCESS] = false;
  var silent = opts && opts.silent;
  flushPendingActions.call(this, silent);
  triggerUpdatedEvent.call(this, silent);
};
/**
 * Show loading effect
 * @param  {string} [name='default']
 * @param  {Object} [cfg]
 */


echartsProto.showLoading = function (name, cfg) {
  if (zrUtil.isObject(name)) {
    cfg = name;
    name = '';
  }

  name = name || 'default';
  this.hideLoading();

  if (!loadingEffects[name]) {
    return;
  }

  var el = loadingEffects[name](this._api, cfg);
  var zr = this._zr;
  this._loadingFX = el;
  zr.add(el);
};
/**
 * Hide loading effect
 */


echartsProto.hideLoading = function () {
  this._loadingFX && this._zr.remove(this._loadingFX);
  this._loadingFX = null;
};
/**
 * @param {Object} eventObj
 * @return {Object}
 */


echartsProto.makeActionFromEvent = function (eventObj) {
  var payload = zrUtil.extend({}, eventObj);
  payload.type = eventActionMap[eventObj.type];
  return payload;
};
/**
 * @pubilc
 * @param {Object} payload
 * @param {string} [payload.type] Action type
 * @param {Object|boolean} [opt] If pass boolean, means opt.silent
 * @param {boolean} [opt.silent=false] Whether trigger events.
 * @param {boolean} [opt.flush=undefined]
 *                  true: Flush immediately, and then pixel in canvas can be fetched
 *                      immediately. Caution: it might affect performance.
 *                  false: Not not flush.
 *                  undefined: Auto decide whether perform flush.
 */


echartsProto.dispatchAction = function (payload, opt) {
  if (!zrUtil.isObject(opt)) {
    opt = {
      silent: !!opt
    };
  }

  if (!actions[payload.type]) {
    return;
  } // Avoid dispatch action before setOption. Especially in `connect`.


  if (!this._model) {
    return;
  } // May dispatchAction in rendering procedure


  if (this[IN_MAIN_PROCESS]) {
    this._pendingActions.push(payload);

    return;
  }

  doDispatchAction.call(this, payload, opt.silent);

  if (opt.flush) {
    this._zr.flush(true);
  } else if (opt.flush !== false && env.browser.weChat) {
    // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`
    // hang when sliding page (on touch event), which cause that zr does not
    // refresh util user interaction finished, which is not expected.
    // But `dispatchAction` may be called too frequently when pan on touch
    // screen, which impacts performance if do not throttle them.
    this._throttledZrFlush();
  }

  flushPendingActions.call(this, opt.silent);
  triggerUpdatedEvent.call(this, opt.silent);
};

function doDispatchAction(payload, silent) {
  var payloadType = payload.type;
  var escapeConnect = payload.escapeConnect;
  var actionWrap = actions[payloadType];
  var actionInfo = actionWrap.actionInfo;
  var cptType = (actionInfo.update || 'update').split(':');
  var updateMethod = cptType.pop();
  cptType = cptType[0] != null && parseClassType(cptType[0]);
  this[IN_MAIN_PROCESS] = true;
  var payloads = [payload];
  var batched = false; // Batch action

  if (payload.batch) {
    batched = true;
    payloads = zrUtil.map(payload.batch, function (item) {
      item = zrUtil.defaults(zrUtil.extend({}, item), payload);
      item.batch = null;
      return item;
    });
  }

  var eventObjBatch = [];
  var eventObj;
  var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';
  each(payloads, function (batchItem) {
    // Action can specify the event by return it.
    eventObj = actionWrap.action(batchItem, this._model, this._api); // Emit event outside

    eventObj = eventObj || zrUtil.extend({}, batchItem); // Convert type to eventType

    eventObj.type = actionInfo.event || eventObj.type;
    eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual.

    if (isHighDown) {
      // method, payload, mainType, subType
      updateDirectly(this, updateMethod, batchItem, 'series');
    } else if (cptType) {
      updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
    }
  }, this);

  if (updateMethod !== 'none' && !isHighDown && !cptType) {
    // Still dirty
    if (this[OPTION_UPDATED]) {
      // FIXME Pass payload ?
      updateMethods.prepareAndUpdate.call(this, payload);
      this[OPTION_UPDATED] = false;
    } else {
      updateMethods[updateMethod].call(this, payload);
    }
  } // Follow the rule of action batch


  if (batched) {
    eventObj = {
      type: actionInfo.event || payloadType,
      escapeConnect: escapeConnect,
      batch: eventObjBatch
    };
  } else {
    eventObj = eventObjBatch[0];
  }

  this[IN_MAIN_PROCESS] = false;
  !silent && this._messageCenter.trigger(eventObj.type, eventObj);
}

function flushPendingActions(silent) {
  var pendingActions = this._pendingActions;

  while (pendingActions.length) {
    var payload = pendingActions.shift();
    doDispatchAction.call(this, payload, silent);
  }
}

function triggerUpdatedEvent(silent) {
  !silent && this.trigger('updated');
}
/**
 * Register event
 * @method
 */


echartsProto.on = createRegisterEventWithLowercaseName('on');
echartsProto.off = createRegisterEventWithLowercaseName('off');
echartsProto.one = createRegisterEventWithLowercaseName('one');
/**
 * @param {string} methodName
 * @private
 */

function invokeUpdateMethod(methodName, ecModel, payload) {
  var api = this._api; // Update all components

  each(this._componentsViews, function (component) {
    var componentModel = component.__model;
    component[methodName](componentModel, ecModel, api, payload);
    updateZ(componentModel, component);
  }, this); // Upate all charts

  ecModel.eachSeries(function (seriesModel, idx) {
    var chart = this._chartsMap[seriesModel.__viewId];
    chart[methodName](seriesModel, ecModel, api, payload);
    updateZ(seriesModel, chart);
    updateProgressiveAndBlend(seriesModel, chart);
  }, this); // If use hover layer

  updateHoverLayerStatus(this._zr, ecModel); // Post render

  each(postUpdateFuncs, function (func) {
    func(ecModel, api);
  });
}
/**
 * Prepare view instances of charts and components
 * @param  {module:echarts/model/Global} ecModel
 * @private
 */


function prepareView(type, ecModel) {
  var isComponent = type === 'component';
  var viewList = isComponent ? this._componentsViews : this._chartsViews;
  var viewMap = isComponent ? this._componentsMap : this._chartsMap;
  var zr = this._zr;

  for (var i = 0; i < viewList.length; i++) {
    viewList[i].__alive = false;
  }

  ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {
    if (isComponent) {
      if (componentType === 'series') {
        return;
      }
    } else {
      model = componentType;
    } // Consider: id same and type changed.


    var viewId = '_ec_' + model.id + '_' + model.type;
    var view = viewMap[viewId];

    if (!view) {
      var classType = parseClassType(model.type);
      var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);

      if (Clazz) {
        view = new Clazz();
        view.init(ecModel, this._api);
        viewMap[viewId] = view;
        viewList.push(view);
        zr.add(view.group);
      } else {
        // Error
        return;
      }
    }

    model.__viewId = view.__id = viewId;
    view.__alive = true;
    view.__model = model;
    view.group.__ecComponentInfo = {
      mainType: model.mainType,
      index: model.componentIndex
    };
  }, this);

  for (var i = 0; i < viewList.length;) {
    var view = viewList[i];

    if (!view.__alive) {
      zr.remove(view.group);
      view.dispose(ecModel, this._api);
      viewList.splice(i, 1);
      delete viewMap[view.__id];
      view.__id = view.group.__ecComponentInfo = null;
    } else {
      i++;
    }
  }
}
/**
 * Processor data in each series
 *
 * @param {module:echarts/model/Global} ecModel
 * @private
 */


function processData(ecModel, api) {
  each(dataProcessorFuncs, function (process) {
    process.func(ecModel, api);
  });
}
/**
 * @private
 */


function stackSeriesData(ecModel) {
  var stackedDataMap = {};
  ecModel.eachSeries(function (series) {
    var stack = series.get('stack');
    var data = series.getData();

    if (stack && data.type === 'list') {
      var previousStack = stackedDataMap[stack]; // Avoid conflict with Object.prototype

      if (stackedDataMap.hasOwnProperty(stack) && previousStack) {
        data.stackedOn = previousStack;
      }

      stackedDataMap[stack] = data;
    }
  });
}
/**
 * Layout before each chart render there series, special visual encoding stage
 *
 * @param {module:echarts/model/Global} ecModel
 * @private
 */


function doLayout(ecModel, payload) {
  var api = this._api;
  each(visualFuncs, function (visual) {
    if (visual.isLayout) {
      visual.func(ecModel, api, payload);
    }
  });
}
/**
 * Encode visual infomation from data after data processing
 *
 * @param {module:echarts/model/Global} ecModel
 * @param {object} layout
 * @param {boolean} [excludesLayout]
 * @private
 */


function doVisualEncoding(ecModel, payload, excludesLayout) {
  var api = this._api;
  ecModel.clearColorPalette();
  ecModel.eachSeries(function (seriesModel) {
    seriesModel.clearColorPalette();
  });
  each(visualFuncs, function (visual) {
    (!excludesLayout || !visual.isLayout) && visual.func(ecModel, api, payload);
  });
}
/**
 * Render each chart and component
 * @private
 */


function doRender(ecModel, payload) {
  var api = this._api; // Render all components

  each(this._componentsViews, function (componentView) {
    var componentModel = componentView.__model;
    componentView.render(componentModel, ecModel, api, payload);
    updateZ(componentModel, componentView);
  }, this);
  each(this._chartsViews, function (chart) {
    chart.__alive = false;
  }, this); // Render all charts

  ecModel.eachSeries(function (seriesModel, idx) {
    var chartView = this._chartsMap[seriesModel.__viewId];
    chartView.__alive = true;
    chartView.render(seriesModel, ecModel, api, payload);
    chartView.group.silent = !!seriesModel.get('silent');
    updateZ(seriesModel, chartView);
    updateProgressiveAndBlend(seriesModel, chartView);
  }, this); // If use hover layer

  updateHoverLayerStatus(this._zr, ecModel); // Remove groups of unrendered charts

  each(this._chartsViews, function (chart) {
    if (!chart.__alive) {
      chart.remove(ecModel, api);
    }
  }, this);
}

var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];
/**
 * @private
 */

echartsProto._initEvents = function () {
  each(MOUSE_EVENT_NAMES, function (eveName) {
    this._zr.on(eveName, function (e) {
      var ecModel = this.getModel();
      var el = e.target;
      var params; // no e.target when 'globalout'.

      if (eveName === 'globalout') {
        params = {};
      } else if (el && el.dataIndex != null) {
        var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
        params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};
      } // If element has custom eventData of components
      else if (el && el.eventData) {
          params = zrUtil.extend({}, el.eventData);
        }

      if (params) {
        params.event = e;
        params.type = eveName;
        this.trigger(eveName, params);
      }
    }, this);
  }, this);
  each(eventActionMap, function (actionType, eventType) {
    this._messageCenter.on(eventType, function (event) {
      this.trigger(eventType, event);
    }, this);
  }, this);
};
/**
 * @return {boolean}
 */


echartsProto.isDisposed = function () {
  return this._disposed;
};
/**
 * Clear
 */


echartsProto.clear = function () {
  this.setOption({
    series: []
  }, true);
};
/**
 * Dispose instance
 */


echartsProto.dispose = function () {
  if (this._disposed) {
    return;
  }

  this._disposed = true;
  var api = this._api;
  var ecModel = this._model;
  each(this._componentsViews, function (component) {
    component.dispose(ecModel, api);
  });
  each(this._chartsViews, function (chart) {
    chart.dispose(ecModel, api);
  }); // Dispose after all views disposed

  this._zr.dispose();

  delete instances[this.id];
};

zrUtil.mixin(ECharts, Eventful);

function updateHoverLayerStatus(zr, ecModel) {
  var storage = zr.storage;
  var elCount = 0;
  storage.traverse(function (el) {
    if (!el.isGroup) {
      elCount++;
    }
  });

  if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {
    storage.traverse(function (el) {
      if (!el.isGroup) {
        el.useHoverLayer = true;
      }
    });
  }
}
/**
 * Update chart progressive and blend.
 * @param {module:echarts/model/Series|module:echarts/model/Component} model
 * @param {module:echarts/view/Component|module:echarts/view/Chart} view
 */


function updateProgressiveAndBlend(seriesModel, chartView) {
  // Progressive configuration
  var elCount = 0;
  chartView.group.traverse(function (el) {
    if (el.type !== 'group' && !el.ignore) {
      elCount++;
    }
  });
  var frameDrawNum = +seriesModel.get('progressive');
  var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;

  if (needProgressive) {
    chartView.group.traverse(function (el) {
      // FIXME marker and other components
      if (!el.isGroup) {
        el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;

        if (needProgressive) {
          el.stopAnimation(true);
        }
      }
    });
  } // Blend configration


  var blendMode = seriesModel.get('blendMode') || null;
  chartView.group.traverse(function (el) {
    // FIXME marker and other components
    if (!el.isGroup) {
      el.setStyle('blend', blendMode);
    }
  });
}
/**
 * @param {module:echarts/model/Series|module:echarts/model/Component} model
 * @param {module:echarts/view/Component|module:echarts/view/Chart} view
 */


function updateZ(model, view) {
  var z = model.get('z');
  var zlevel = model.get('zlevel'); // Set z and zlevel

  view.group.traverse(function (el) {
    if (el.type !== 'group') {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
    }
  });
}

function createExtensionAPI(ecInstance) {
  var coordSysMgr = ecInstance._coordSysMgr;
  return zrUtil.extend(new ExtensionAPI(ecInstance), {
    // Inject methods
    getCoordinateSystems: zrUtil.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),
    getComponentByElement: function (el) {
      while (el) {
        var modelInfo = el.__ecComponentInfo;

        if (modelInfo != null) {
          return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);
        }

        el = el.parent;
      }
    }
  });
}
/**
 * @type {Object} key: actionType.
 * @inner
 */


var actions = {};
/**
 * Map eventType to actionType
 * @type {Object}
 */

var eventActionMap = {};
/**
 * Data processor functions of each stage
 * @type {Array.<Object.<string, Function>>}
 * @inner
 */

var dataProcessorFuncs = [];
/**
 * @type {Array.<Function>}
 * @inner
 */

var optionPreprocessorFuncs = [];
/**
 * @type {Array.<Function>}
 * @inner
 */

var postUpdateFuncs = [];
/**
 * Visual encoding functions of each stage
 * @type {Array.<Object.<string, Function>>}
 * @inner
 */

var visualFuncs = [];
/**
 * Theme storage
 * @type {Object.<key, Object>}
 */

var themeStorage = {};
/**
 * Loading effects
 */

var loadingEffects = {};
var instances = {};
var connectedGroups = {};
var idBase = new Date() - 0;
var groupIdBase = new Date() - 0;
var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
var mapDataStores = {};

function enableConnect(chart) {
  var STATUS_PENDING = 0;
  var STATUS_UPDATING = 1;
  var STATUS_UPDATED = 2;
  var STATUS_KEY = '__connectUpdateStatus';

  function updateConnectedChartsStatus(charts, status) {
    for (var i = 0; i < charts.length; i++) {
      var otherChart = charts[i];
      otherChart[STATUS_KEY] = status;
    }
  }

  zrUtil.each(eventActionMap, function (actionType, eventType) {
    chart._messageCenter.on(eventType, function (event) {
      if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
        if (event && event.escapeConnect) {
          return;
        }

        var action = chart.makeActionFromEvent(event);
        var otherCharts = [];
        zrUtil.each(instances, function (otherChart) {
          if (otherChart !== chart && otherChart.group === chart.group) {
            otherCharts.push(otherChart);
          }
        });
        updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
        each(otherCharts, function (otherChart) {
          if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
            otherChart.dispatchAction(action);
          }
        });
        updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
      }
    });
  });
}
/**
 * @param {HTMLElement} dom
 * @param {Object} [theme]
 * @param {Object} opts
 * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default
 * @param {string} [opts.renderer] Currently only 'canvas' is supported.
 * @param {number} [opts.width] Use clientWidth of the input `dom` by default.
 *                              Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Use clientHeight of the input `dom` by default.
 *                               Can be 'auto' (the same as null/undefined)
 */


function init(dom, theme, opts) {
  var existInstance = getInstanceByDom(dom);

  if (existInstance) {
    return existInstance;
  }

  var chart = new ECharts(dom, theme, opts);
  chart.id = 'ec_' + idBase++;
  instances[chart.id] = chart;

  if (dom.setAttribute) {
    dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);
  } else {
    dom[DOM_ATTRIBUTE_KEY] = chart.id;
  }

  enableConnect(chart);
  return chart;
}
/**
 * @return {string|Array.<module:echarts~ECharts>} groupId
 */


function connect(groupId) {
  // Is array of charts
  if (zrUtil.isArray(groupId)) {
    var charts = groupId;
    groupId = null; // If any chart has group

    zrUtil.each(charts, function (chart) {
      if (chart.group != null) {
        groupId = chart.group;
      }
    });
    groupId = groupId || 'g_' + groupIdBase++;
    zrUtil.each(charts, function (chart) {
      chart.group = groupId;
    });
  }

  connectedGroups[groupId] = true;
  return groupId;
}
/**
 * @DEPRECATED
 * @return {string} groupId
 */


function disConnect(groupId) {
  connectedGroups[groupId] = false;
}
/**
 * @return {string} groupId
 */


var disconnect = disConnect;
/**
 * Dispose a chart instance
 * @param  {module:echarts~ECharts|HTMLDomElement|string} chart
 */

function dispose(chart) {
  if (typeof chart === 'string') {
    chart = instances[chart];
  } else if (!(chart instanceof ECharts)) {
    // Try to treat as dom
    chart = getInstanceByDom(chart);
  }

  if (chart instanceof ECharts && !chart.isDisposed()) {
    chart.dispose();
  }
}
/**
 * @param  {HTMLElement} dom
 * @return {echarts~ECharts}
 */


function getInstanceByDom(dom) {
  var key;

  if (dom.getAttribute) {
    key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
  } else {
    key = dom[DOM_ATTRIBUTE_KEY];
  }

  return instances[key];
}
/**
 * @param {string} key
 * @return {echarts~ECharts}
 */


function getInstanceById(key) {
  return instances[key];
}
/**
 * Register theme
 */


function registerTheme(name, theme) {
  themeStorage[name] = theme;
}
/**
 * Register option preprocessor
 * @param {Function} preprocessorFunc
 */


function registerPreprocessor(preprocessorFunc) {
  optionPreprocessorFuncs.push(preprocessorFunc);
}
/**
 * @param {number} [priority=1000]
 * @param {Function} processorFunc
 */


function registerProcessor(priority, processorFunc) {
  if (typeof priority === 'function') {
    processorFunc = priority;
    priority = PRIORITY_PROCESSOR_FILTER;
  }

  dataProcessorFuncs.push({
    prio: priority,
    func: processorFunc
  });
}
/**
 * Register postUpdater
 * @param {Function} postUpdateFunc
 */


function registerPostUpdate(postUpdateFunc) {
  postUpdateFuncs.push(postUpdateFunc);
}
/**
 * Usage:
 * registerAction('someAction', 'someEvent', function () { ... });
 * registerAction('someAction', function () { ... });
 * registerAction(
 *     {type: 'someAction', event: 'someEvent', update: 'updateView'},
 *     function () { ... }
 * );
 *
 * @param {(string|Object)} actionInfo
 * @param {string} actionInfo.type
 * @param {string} [actionInfo.event]
 * @param {string} [actionInfo.update]
 * @param {string} [eventName]
 * @param {Function} action
 */


function registerAction(actionInfo, eventName, action) {
  if (typeof eventName === 'function') {
    action = eventName;
    eventName = '';
  }

  var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
    event: eventName
  }][0]; // Event name is all lowercase

  actionInfo.event = (actionInfo.event || actionType).toLowerCase();
  eventName = actionInfo.event; // Validate action type and event name.

  zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));

  if (!actions[actionType]) {
    actions[actionType] = {
      action: action,
      actionInfo: actionInfo
    };
  }

  eventActionMap[eventName] = actionType;
}
/**
 * @param {string} type
 * @param {*} CoordinateSystem
 */


function registerCoordinateSystem(type, CoordinateSystem) {
  CoordinateSystemManager.register(type, CoordinateSystem);
}
/**
 * Get dimensions of specified coordinate system.
 * @param {string} type
 * @return {Array.<string|Object>}
 */


function getCoordinateSystemDimensions(type) {
  var coordSysCreator = CoordinateSystemManager.get(type);

  if (coordSysCreator) {
    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
  }
}
/**
 * Layout is a special stage of visual encoding
 * Most visual encoding like color are common for different chart
 * But each chart has it's own layout algorithm
 *
 * @param {number} [priority=1000]
 * @param {Function} layoutFunc
 */


function registerLayout(priority, layoutFunc) {
  if (typeof priority === 'function') {
    layoutFunc = priority;
    priority = PRIORITY_VISUAL_LAYOUT;
  }

  visualFuncs.push({
    prio: priority,
    func: layoutFunc,
    isLayout: true
  });
}
/**
 * @param {number} [priority=3000]
 * @param {Function} visualFunc
 */


function registerVisual(priority, visualFunc) {
  if (typeof priority === 'function') {
    visualFunc = priority;
    priority = PRIORITY_VISUAL_CHART;
  }

  visualFuncs.push({
    prio: priority,
    func: visualFunc
  });
}
/**
 * @param {string} name
 */


function registerLoading(name, loadingFx) {
  loadingEffects[name] = loadingFx;
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendComponentModel(opts
/*, superClass*/
) {
  // var Clazz = ComponentModel;
  // if (superClass) {
  //     var classType = parseClassType(superClass);
  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
  // }
  return ComponentModel.extend(opts);
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendComponentView(opts
/*, superClass*/
) {
  // var Clazz = ComponentView;
  // if (superClass) {
  //     var classType = parseClassType(superClass);
  //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);
  // }
  return ComponentView.extend(opts);
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendSeriesModel(opts
/*, superClass*/
) {
  // var Clazz = SeriesModel;
  // if (superClass) {
  //     superClass = 'series.' + superClass.replace('series.', '');
  //     var classType = parseClassType(superClass);
  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
  // }
  return SeriesModel.extend(opts);
}
/**
 * @param {Object} opts
 * @param {string} [superClass]
 */


function extendChartView(opts
/*, superClass*/
) {
  // var Clazz = ChartView;
  // if (superClass) {
  //     superClass = superClass.replace('series.', '');
  //     var classType = parseClassType(superClass);
  //     Clazz = ChartView.getClass(classType.main, true);
  // }
  return ChartView.extend(opts);
}
/**
 * ZRender need a canvas context to do measureText.
 * But in node environment canvas may be created by node-canvas.
 * So we need to specify how to create a canvas instead of using document.createElement('canvas')
 *
 * Be careful of using it in the browser.
 *
 * @param {Function} creator
 * @example
 *     var Canvas = require('canvas');
 *     var echarts = require('echarts');
 *     echarts.setCanvasCreator(function () {
 *         // Small size is enough.
 *         return new Canvas(32, 32);
 *     });
 */


function setCanvasCreator(creator) {
  zrUtil.$override('createCanvas', creator);
}
/**
 * @param {string} mapName
 * @param {Object|string} geoJson
 * @param {Object} [specialAreas]
 *
 * @example
 *     $.get('USA.json', function (geoJson) {
 *         echarts.registerMap('USA', geoJson);
 *         // Or
 *         echarts.registerMap('USA', {
 *             geoJson: geoJson,
 *             specialAreas: {}
 *         })
 *     });
 */


function registerMap(mapName, geoJson, specialAreas) {
  if (geoJson.geoJson && !geoJson.features) {
    specialAreas = geoJson.specialAreas;
    geoJson = geoJson.geoJson;
  }

  if (typeof geoJson === 'string') {
    geoJson = typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(geoJson) : new Function('return (' + geoJson + ');')();
  }

  mapDataStores[mapName] = {
    geoJson: geoJson,
    specialAreas: specialAreas
  };
}
/**
 * @param {string} mapName
 * @return {Object}
 */


function getMap(mapName) {
  return mapDataStores[mapName];
}

registerVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);
registerPreprocessor(backwardCompat);
registerLoading('default', loadingDefault); // Default actions

registerAction({
  type: 'highlight',
  event: 'highlight',
  update: 'highlight'
}, zrUtil.noop);
registerAction({
  type: 'downplay',
  event: 'downplay',
  update: 'downplay'
}, zrUtil.noop); // For backward compatibility, where the namespace `dataTool` will
// be mounted on `echarts` is the extension `dataTool` is imported.

var dataTool = {};
exports.version = version;
exports.dependencies = dependencies;
exports.PRIORITY = PRIORITY;
exports.init = init;
exports.connect = connect;
exports.disConnect = disConnect;
exports.disconnect = disconnect;
exports.dispose = dispose;
exports.getInstanceByDom = getInstanceByDom;
exports.getInstanceById = getInstanceById;
exports.registerTheme = registerTheme;
exports.registerPreprocessor = registerPreprocessor;
exports.registerProcessor = registerProcessor;
exports.registerPostUpdate = registerPostUpdate;
exports.registerAction = registerAction;
exports.registerCoordinateSystem = registerCoordinateSystem;
exports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;
exports.registerLayout = registerLayout;
exports.registerVisual = registerVisual;
exports.registerLoading = registerLoading;
exports.extendComponentModel = extendComponentModel;
exports.extendComponentView = extendComponentView;
exports.extendSeriesModel = extendSeriesModel;
exports.extendChartView = extendChartView;
exports.setCanvasCreator = setCanvasCreator;
exports.registerMap = registerMap;
exports.getMap = getMap;
exports.dataTool = dataTool;
var ___ec_export = __webpack_require__(232);
(function () {
    for (var key in ___ec_export) {
        if (___ec_export.hasOwnProperty(key)) {
            exports[key] = ___ec_export[key];
        }
    }
})();

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var pathTool = __webpack_require__(201);

var colorTool = __webpack_require__(113);

var matrix = __webpack_require__(110);

var vector = __webpack_require__(97);

var Path = __webpack_require__(100);

var Transformable = __webpack_require__(141);

var Image = __webpack_require__(148);

exports.Image = Image;

var Group = __webpack_require__(119);

exports.Group = Group;

var Text = __webpack_require__(208);

exports.Text = Text;

var Circle = __webpack_require__(209);

exports.Circle = Circle;

var Sector = __webpack_require__(210);

exports.Sector = Sector;

var Ring = __webpack_require__(211);

exports.Ring = Ring;

var Polygon = __webpack_require__(212);

exports.Polygon = Polygon;

var Polyline = __webpack_require__(215);

exports.Polyline = Polyline;

var Rect = __webpack_require__(216);

exports.Rect = Rect;

var Line = __webpack_require__(217);

exports.Line = Line;

var BezierCurve = __webpack_require__(218);

exports.BezierCurve = BezierCurve;

var Arc = __webpack_require__(219);

exports.Arc = Arc;

var CompoundPath = __webpack_require__(220);

exports.CompoundPath = CompoundPath;

var LinearGradient = __webpack_require__(221);

exports.LinearGradient = LinearGradient;

var RadialGradient = __webpack_require__(222);

exports.RadialGradient = RadialGradient;

var BoundingRect = __webpack_require__(101);

exports.BoundingRect = BoundingRect;
var round = Math.round;
var mathMax = Math.max;
var mathMin = Math.min;
var EMPTY_OBJ = {};
/**
 * Extend shape with parameters
 */

function extendShape(opts) {
  return Path.extend(opts);
}
/**
 * Extend path
 */


function extendPath(pathData, opts) {
  return pathTool.extendFromString(pathData, opts);
}
/**
 * Create a path element from path data string
 * @param {string} pathData
 * @param {Object} opts
 * @param {module:zrender/core/BoundingRect} rect
 * @param {string} [layout=cover] 'center' or 'cover'
 */


function makePath(pathData, opts, rect, layout) {
  var path = pathTool.createFromString(pathData, opts);
  var boundingRect = path.getBoundingRect();

  if (rect) {
    if (layout === 'center') {
      rect = centerGraphic(rect, boundingRect);
    }

    resizePath(path, rect);
  }

  return path;
}
/**
 * Create a image element from image url
 * @param {string} imageUrl image url
 * @param {Object} opts options
 * @param {module:zrender/core/BoundingRect} rect constrain rect
 * @param {string} [layout=cover] 'center' or 'cover'
 */


function makeImage(imageUrl, rect, layout) {
  var path = new Image({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload: function (img) {
      if (layout === 'center') {
        var boundingRect = {
          width: img.width,
          height: img.height
        };
        path.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return path;
}
/**
 * Get position of centered element in bounding box.
 *
 * @param  {Object} rect         element local bounding box
 * @param  {Object} boundingRect constraint bounding box
 * @return {Object} element position containing x, y, width, and height
 */


function centerGraphic(rect, boundingRect) {
  // Set rect to center, keep width / height ratio.
  var aspect = boundingRect.width / boundingRect.height;
  var width = rect.height * aspect;
  var height;

  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }

  var cx = rect.x + rect.width / 2;
  var cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width: width,
    height: height
  };
}

var mergePath = pathTool.mergePath;
/**
 * Resize a path to fit the rect
 * @param {module:zrender/graphic/Path} path
 * @param {Object} rect
 */

function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }

  var pathRect = path.getBoundingRect();
  var m = pathRect.calculateTransform(rect);
  path.applyTransform(m);
}
/**
 * Sub pixel optimize line for canvas
 *
 * @param {Object} param
 * @param {Object} [param.shape]
 * @param {number} [param.shape.x1]
 * @param {number} [param.shape.y1]
 * @param {number} [param.shape.x2]
 * @param {number} [param.shape.y2]
 * @param {Object} [param.style]
 * @param {number} [param.style.lineWidth]
 * @return {Object} Modified param
 */


function subPixelOptimizeLine(param) {
  var shape = param.shape;
  var lineWidth = param.style.lineWidth;

  if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
    shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
  }

  if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
    shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
  }

  return param;
}
/**
 * Sub pixel optimize rect for canvas
 *
 * @param {Object} param
 * @param {Object} [param.shape]
 * @param {number} [param.shape.x]
 * @param {number} [param.shape.y]
 * @param {number} [param.shape.width]
 * @param {number} [param.shape.height]
 * @param {Object} [param.style]
 * @param {number} [param.style.lineWidth]
 * @return {Object} Modified param
 */


function subPixelOptimizeRect(param) {
  var shape = param.shape;
  var lineWidth = param.style.lineWidth;
  var originX = shape.x;
  var originY = shape.y;
  var originWidth = shape.width;
  var originHeight = shape.height;
  shape.x = subPixelOptimize(shape.x, lineWidth, true);
  shape.y = subPixelOptimize(shape.y, lineWidth, true);
  shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);
  shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);
  return param;
}
/**
 * Sub pixel optimize for canvas
 *
 * @param {number} position Coordinate, such as x, y
 * @param {number} lineWidth Should be nonnegative integer.
 * @param {boolean=} positiveOrNegative Default false (negative).
 * @return {number} Optimized position.
 */


function subPixelOptimize(position, lineWidth, positiveOrNegative) {
  // Assure that (position + lineWidth / 2) is near integer edge,
  // otherwise line will be fuzzy in canvas.
  var doubledPosition = round(position * 2);
  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}

function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke != 'none';
}

function liftColor(color) {
  return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;
}
/**
 * @private
 */


function cacheElementStl(el) {
  if (el.__hoverStlDirty) {
    var stroke = el.style.stroke;
    var fill = el.style.fill; // Create hoverStyle on mouseover

    var hoverStyle = el.__hoverStl;
    hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);
    hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);
    var normalStyle = {};

    for (var name in hoverStyle) {
      // See comment in `doSingleEnterHover`.
      if (hoverStyle[name] != null) {
        normalStyle[name] = el.style[name];
      }
    }

    el.__normalStl = normalStyle;
    el.__hoverStlDirty = false;
  }
}
/**
 * @private
 */


function doSingleEnterHover(el) {
  if (el.__isHover) {
    return;
  }

  cacheElementStl(el);

  if (el.useHoverLayer) {
    el.__zr && el.__zr.addHover(el, el.__hoverStl);
  } else {
    var style = el.style;
    var insideRollbackOpt = style.insideRollbackOpt; // Consider case: only `position: 'top'` is set on emphasis, then text
    // color should be returned to `autoColor`, rather than remain '#fff'.
    // So we should rollback then apply again after style merging.

    insideRollbackOpt && rollbackInsideStyle(style); // styles can be:
    // {
    //     label: {
    //         normal: {
    //             show: false,
    //             position: 'outside',
    //             fontSize: 18
    //         },
    //         emphasis: {
    //             show: true
    //         }
    //     }
    // },
    // where properties of `emphasis` may not appear in `normal`. We previously use
    // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.
    // But consider rich text and setOption in merge mode, it is impossible to cover
    // all properties in merge. So we use merge mode when setting style here, where
    // only properties that is not `null/undefined` can be set. The disadventage:
    // null/undefined can not be used to remove style any more in `emphasis`.

    style.extendFrom(el.__hoverStl); // Do not save `insideRollback`.

    if (insideRollbackOpt) {
      applyInsideStyle(style, style.insideOriginalTextPosition, insideRollbackOpt); // textFill may be rollbacked to null.

      if (style.textFill == null) {
        style.textFill = insideRollbackOpt.autoColor;
      }
    }

    el.dirty(false);
    el.z2 += 1;
  }

  el.__isHover = true;
}
/**
 * @inner
 */


function doSingleLeaveHover(el) {
  if (!el.__isHover) {
    return;
  }

  var normalStl = el.__normalStl;

  if (el.useHoverLayer) {
    el.__zr && el.__zr.removeHover(el);
  } else {
    // Consider null/undefined value, should use
    // `setStyle` but not `extendFrom(stl, true)`.
    normalStl && el.setStyle(normalStl);
    el.z2 -= 1;
  }

  el.__isHover = false;
}
/**
 * @inner
 */


function doEnterHover(el) {
  el.type === 'group' ? el.traverse(function (child) {
    if (child.type !== 'group') {
      doSingleEnterHover(child);
    }
  }) : doSingleEnterHover(el);
}

function doLeaveHover(el) {
  el.type === 'group' ? el.traverse(function (child) {
    if (child.type !== 'group') {
      doSingleLeaveHover(child);
    }
  }) : doSingleLeaveHover(el);
}
/**
 * @inner
 */


function setElementHoverStl(el, hoverStl) {
  // If element has sepcified hoverStyle, then use it instead of given hoverStyle
  // Often used when item group has a label element and it's hoverStyle is different
  el.__hoverStl = el.hoverStyle || hoverStl || {};
  el.__hoverStlDirty = true;

  if (el.__isHover) {
    cacheElementStl(el);
  }
}
/**
 * @inner
 */


function onElementMouseOver(e) {
  if (this.__hoverSilentOnTouch && e.zrByTouch) {
    return;
  } // Only if element is not in emphasis status


  !this.__isEmphasis && doEnterHover(this);
}
/**
 * @inner
 */


function onElementMouseOut(e) {
  if (this.__hoverSilentOnTouch && e.zrByTouch) {
    return;
  } // Only if element is not in emphasis status


  !this.__isEmphasis && doLeaveHover(this);
}
/**
 * @inner
 */


function enterEmphasis() {
  this.__isEmphasis = true;
  doEnterHover(this);
}
/**
 * @inner
 */


function leaveEmphasis() {
  this.__isEmphasis = false;
  doLeaveHover(this);
}
/**
 * Set hover style of element.
 * This method can be called repeatly without side-effects.
 * @param {module:zrender/Element} el
 * @param {Object} [hoverStyle]
 * @param {Object} [opt]
 * @param {boolean} [opt.hoverSilentOnTouch=false]
 *        In touch device, mouseover event will be trigger on touchstart event
 *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
 *        conviniently use hoverStyle when tap on touch screen without additional
 *        code for compatibility.
 *        But if the chart/component has select feature, which usually also use
 *        hoverStyle, there might be conflict between 'select-highlight' and
 *        'hover-highlight' especially when roam is enabled (see geo for example).
 *        In this case, hoverSilentOnTouch should be used to disable hover-highlight
 *        on touch device.
 */


function setHoverStyle(el, hoverStyle, opt) {
  el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;
  el.type === 'group' ? el.traverse(function (child) {
    if (child.type !== 'group') {
      setElementHoverStl(child, hoverStyle);
    }
  }) : setElementHoverStl(el, hoverStyle); // Duplicated function will be auto-ignored, see Eventful.js.

  el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut); // Emphasis, normal can be triggered manually

  el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);
}
/**
 * @param {Object|module:zrender/graphic/Style} normalStyle
 * @param {Object} emphasisStyle
 * @param {module:echarts/model/Model} normalModel
 * @param {module:echarts/model/Model} emphasisModel
 * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.
 * @param {Object} [opt.defaultText]
 * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by
 *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by
 *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by
 *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`
 * @param {Object} [normalSpecified]
 * @param {Object} [emphasisSpecified]
 */


function setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {
  opt = opt || EMPTY_OBJ;
  var labelFetcher = opt.labelFetcher;
  var labelDataIndex = opt.labelDataIndex;
  var labelDimIndex = opt.labelDimIndex; // This scenario, `label.normal.show = true; label.emphasis.show = false`,
  // is not supported util someone requests.

  var showNormal = normalModel.getShallow('show');
  var showEmphasis = emphasisModel.getShallow('show'); // Consider performance, only fetch label when necessary.
  // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,
  // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.

  var baseText = showNormal || showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex) : null, opt.defaultText) : null;
  var normalStyleText = showNormal ? baseText : null;
  var emphasisStyleText = showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex) : null, baseText) : null; // Optimize: If style.text is null, text will not be drawn.

  if (normalStyleText != null || emphasisStyleText != null) {
    // Always set `textStyle` even if `normalStyle.text` is null, because default
    // values have to be set on `normalStyle`.
    // If we set default values on `emphasisStyle`, consider case:
    // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`
    // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`
    // Then the 'red' will not work on emphasis.
    setTextStyle(normalStyle, normalModel, normalSpecified, opt);
    setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);
  }

  normalStyle.text = normalStyleText;
  emphasisStyle.text = emphasisStyleText;
}
/**
 * Set basic textStyle properties.
 * @param {Object|module:zrender/graphic/Style} textStyle
 * @param {module:echarts/model/Model} model
 * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.
 * @param {Object} [opt] See `opt` of `setTextStyleCommon`.
 * @param {boolean} [isEmphasis]
 */


function setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {
  setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);
  specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle);
  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);
  return textStyle;
}
/**
 * Set text option in the style.
 * @deprecated
 * @param {Object} textStyle
 * @param {module:echarts/model/Model} labelModel
 * @param {string|boolean} defaultColor Default text color.
 *        If set as false, it will be processed as a emphasis style.
 */


function setText(textStyle, labelModel, defaultColor) {
  var opt = {
    isRectText: true
  };
  var isEmphasis;

  if (defaultColor === false) {
    isEmphasis = true;
  } else {
    // Support setting color as 'auto' to get visual color.
    opt.autoColor = defaultColor;
  }

  setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);
  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);
}
/**
 * {
 *      disableBox: boolean, Whether diable drawing box of block (outer most).
 *      isRectText: boolean,
 *      autoColor: string, specify a color when color is 'auto',
 *              for textFill, textStroke, textBackgroundColor, and textBorderColor.
 *              If autoColor specified, it is used as default textFill.
 *      useInsideStyle:
 *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)
 *                  if `textFill` is not specified.
 *              `false`: Do not use inside style.
 *              `null/undefined`: use inside style if `isRectText` is true and
 *                  `textFill` is not specified and textPosition contains `'inside'`.
 *      forceRich: boolean
 * }
 */


function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {
  // Consider there will be abnormal when merge hover style to normal style if given default value.
  opt = opt || EMPTY_OBJ;

  if (opt.isRectText) {
    var textPosition = textStyleModel.getShallow('position') || (isEmphasis ? null : 'inside'); // 'outside' is not a valid zr textPostion value, but used
    // in bar series, and magric type should be considered.

    textPosition === 'outside' && (textPosition = 'top');
    textStyle.textPosition = textPosition;
    textStyle.textOffset = textStyleModel.getShallow('offset');
    var labelRotate = textStyleModel.getShallow('rotate');
    labelRotate != null && (labelRotate *= Math.PI / 180);
    textStyle.textRotation = labelRotate;
    textStyle.textDistance = zrUtil.retrieve2(textStyleModel.getShallow('distance'), isEmphasis ? null : 5);
  }

  var ecModel = textStyleModel.ecModel;
  var globalTextStyle = ecModel && ecModel.option.textStyle; // Consider case:
  // {
  //     data: [{
  //         value: 12,
  //         label: {
  //             normal: {
  //                 rich: {
  //                     // no 'a' here but using parent 'a'.
  //                 }
  //             }
  //         }
  //     }],
  //     rich: {
  //         a: { ... }
  //     }
  // }

  var richItemNames = getRichItemNames(textStyleModel);
  var richResult;

  if (richItemNames) {
    richResult = {};

    for (var name in richItemNames) {
      if (richItemNames.hasOwnProperty(name)) {
        // Cascade is supported in rich.
        var richTextStyle = textStyleModel.getModel(['rich', name]); // In rich, never `disableBox`.

        setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);
      }
    }
  }

  textStyle.rich = richResult;
  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);

  if (opt.forceRich && !opt.textStyle) {
    opt.textStyle = {};
  }

  return textStyle;
} // Consider case:
// {
//     data: [{
//         value: 12,
//         label: {
//             normal: {
//                 rich: {
//                     // no 'a' here but using parent 'a'.
//                 }
//             }
//         }
//     }],
//     rich: {
//         a: { ... }
//     }
// }


function getRichItemNames(textStyleModel) {
  // Use object to remove duplicated names.
  var richItemNameMap;

  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    var rich = (textStyleModel.option || EMPTY_OBJ).rich;

    if (rich) {
      richItemNameMap = richItemNameMap || {};

      for (var name in rich) {
        if (rich.hasOwnProperty(name)) {
          richItemNameMap[name] = 1;
        }
      }
    }

    textStyleModel = textStyleModel.parentModel;
  }

  return richItemNameMap;
}

function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {
  // In merge mode, default value should not be given.
  globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;
  textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt) || globalTextStyle.color;
  textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt) || globalTextStyle.textBorderColor;
  textStyle.textStrokeWidth = zrUtil.retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);

  if (!isEmphasis) {
    if (isBlock) {
      // Always set `insideRollback`, for clearing previous.
      var originalTextPosition = textStyle.textPosition;
      textStyle.insideRollback = applyInsideStyle(textStyle, originalTextPosition, opt); // Save original textPosition, because style.textPosition will be repalced by
      // real location (like [10, 30]) in zrender.

      textStyle.insideOriginalTextPosition = originalTextPosition;
      textStyle.insideRollbackOpt = opt;
    } // Set default finally.


    if (textStyle.textFill == null) {
      textStyle.textFill = opt.autoColor;
    }
  } // Do not use `getFont` here, because merge should be supported, where
  // part of these properties may be changed in emphasis style, and the
  // others should remain their original value got from normal style.


  textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;
  textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;
  textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;
  textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;
  textStyle.textAlign = textStyleModel.getShallow('align');
  textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign') || textStyleModel.getShallow('baseline');
  textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');
  textStyle.textWidth = textStyleModel.getShallow('width');
  textStyle.textHeight = textStyleModel.getShallow('height');
  textStyle.textTag = textStyleModel.getShallow('tag');

  if (!isBlock || !opt.disableBox) {
    textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);
    textStyle.textPadding = textStyleModel.getShallow('padding');
    textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);
    textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');
    textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');
    textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');
    textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');
    textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');
    textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');
  }

  textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor') || globalTextStyle.textShadowColor;
  textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur') || globalTextStyle.textShadowBlur;
  textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX') || globalTextStyle.textShadowOffsetX;
  textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY') || globalTextStyle.textShadowOffsetY;
}

function getAutoColor(color, opt) {
  return color !== 'auto' ? color : opt && opt.autoColor ? opt.autoColor : null;
}

function applyInsideStyle(textStyle, textPosition, opt) {
  var useInsideStyle = opt.useInsideStyle;
  var insideRollback;

  if (textStyle.textFill == null && useInsideStyle !== false && (useInsideStyle === true || opt.isRectText && textPosition // textPosition can be [10, 30]
  && typeof textPosition === 'string' && textPosition.indexOf('inside') >= 0)) {
    insideRollback = {
      textFill: null,
      textStroke: textStyle.textStroke,
      textStrokeWidth: textStyle.textStrokeWidth
    };
    textStyle.textFill = '#fff'; // Consider text with #fff overflow its container.

    if (textStyle.textStroke == null) {
      textStyle.textStroke = opt.autoColor;
      textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);
    }
  }

  return insideRollback;
}

function rollbackInsideStyle(style) {
  var insideRollback = style.insideRollback;

  if (insideRollback) {
    style.textFill = insideRollback.textFill;
    style.textStroke = insideRollback.textStroke;
    style.textStrokeWidth = insideRollback.textStrokeWidth;
  }
}

function getFont(opt, ecModel) {
  // ecModel or default text style model.
  var gTextStyleModel = ecModel || ecModel.getModel('textStyle');
  return [// FIXME in node-canvas fontWeight is before fontStyle
  opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' ');
}

function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
  if (typeof dataIndex === 'function') {
    cb = dataIndex;
    dataIndex = null;
  } // Do not check 'animation' property directly here. Consider this case:
  // animation model is an `itemModel`, whose does not have `isAnimationEnabled`
  // but its parent model (`seriesModel`) does.


  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();

  if (animationEnabled) {
    var postfix = isUpdate ? 'Update' : '';
    var duration = animatableModel.getShallow('animationDuration' + postfix);
    var animationEasing = animatableModel.getShallow('animationEasing' + postfix);
    var animationDelay = animatableModel.getShallow('animationDelay' + postfix);

    if (typeof animationDelay === 'function') {
      animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
    }

    if (typeof duration === 'function') {
      duration = duration(dataIndex);
    }

    duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());
  } else {
    el.stopAnimation();
    el.attr(props);
    cb && cb();
  }
}
/**
 * Update graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So if do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 *
 * @param {module:zrender/Element} el
 * @param {Object} props
 * @param {module:echarts/model/Model} [animatableModel]
 * @param {number} [dataIndex]
 * @param {Function} [cb]
 * @example
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
 *     // Or
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, function () { console.log('Animation done!'); });
 */


function updateProps(el, props, animatableModel, dataIndex, cb) {
  animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
}
/**
 * Init graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So if do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 *
 * @param {module:zrender/Element} el
 * @param {Object} props
 * @param {module:echarts/model/Model} [animatableModel]
 * @param {number} [dataIndex]
 * @param {Function} cb
 */


function initProps(el, props, animatableModel, dataIndex, cb) {
  animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
}
/**
 * Get transform matrix of target (param target),
 * in coordinate of its ancestor (param ancestor)
 *
 * @param {module:zrender/mixin/Transformable} target
 * @param {module:zrender/mixin/Transformable} [ancestor]
 */


function getTransform(target, ancestor) {
  var mat = matrix.identity([]);

  while (target && target !== ancestor) {
    matrix.mul(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }

  return mat;
}
/**
 * Apply transform to an vertex.
 * @param {Array.<number>} target [x, y]
 * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:
 *      + Transform matrix: like [1, 0, 0, 1, 0, 0]
 *      + {position, rotation, scale}, the same as `zrender/Transformable`.
 * @param {boolean=} invert Whether use invert matrix.
 * @return {Array.<number>} [x, y]
 */


function applyTransform(target, transform, invert) {
  if (transform && !zrUtil.isArrayLike(transform)) {
    transform = Transformable.getLocalTransform(transform);
  }

  if (invert) {
    transform = matrix.invert([], transform);
  }

  return vector.applyTransform([], target, transform);
}
/**
 * @param {string} direction 'left' 'right' 'top' 'bottom'
 * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
 * @param {boolean=} invert Whether use invert matrix.
 * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
 */


function transformDirection(direction, transform, invert) {
  // Pick a base, ensure that transform result will not be (0, 0).
  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];
  vertex = applyTransform(vertex, transform, invert);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';
}
/**
 * Apply group transition animation from g1 to g2.
 * If no animatableModel, no animation.
 */


function groupTransition(g1, g2, animatableModel, cb) {
  if (!g1 || !g2) {
    return;
  }

  function getElMap(g) {
    var elMap = {};
    g.traverse(function (el) {
      if (!el.isGroup && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }

  function getAnimatableProps(el) {
    var obj = {
      position: vector.clone(el.position),
      rotation: el.rotation
    };

    if (el.shape) {
      obj.shape = zrUtil.extend({}, el.shape);
    }

    return obj;
  }

  var elMap1 = getElMap(g1);
  g2.traverse(function (el) {
    if (!el.isGroup && el.anid) {
      var oldEl = elMap1[el.anid];

      if (oldEl) {
        var newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps(el, newProp, animatableModel, el.dataIndex);
      } // else {
      //     if (el.previousProps) {
      //         graphic.updateProps
      //     }
      // }

    }
  });
}
/**
 * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]
 * @param {Object} rect {x, y, width, height}
 * @return {Array.<Array.<number>>} A new clipped points.
 */


function clipPointsByRect(points, rect) {
  return zrUtil.map(points, function (point) {
    var x = point[0];
    x = mathMax(x, rect.x);
    x = mathMin(x, rect.x + rect.width);
    var y = point[1];
    y = mathMax(y, rect.y);
    y = mathMin(y, rect.y + rect.height);
    return [x, y];
  });
}
/**
 * @param {Object} targetRect {x, y, width, height}
 * @param {Object} rect {x, y, width, height}
 * @return {Object} A new clipped rect. If rect size are negative, return undefined.
 */


function clipRectByRect(targetRect, rect) {
  var x = mathMax(targetRect.x, rect.x);
  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);
  var y = mathMax(targetRect.y, rect.y);
  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);

  if (x2 >= x && y2 >= y) {
    return {
      x: x,
      y: y,
      width: x2 - x,
      height: y2 - y
    };
  }
}
/**
 * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.
 * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.
 * @param {Object} [rect] {x, y, width, height}
 * @return {module:zrender/Element} Icon path or image element.
 */


function createIcon(iconStr, opt, rect) {
  opt = zrUtil.extend({
    rectHover: true
  }, opt);
  var style = opt.style = {
    strokeNoScale: true
  };
  rect = rect || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  };

  if (iconStr) {
    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), zrUtil.defaults(style, rect), new Image(opt)) : makePath(iconStr.replace('path://', ''), opt, rect, 'center');
  }
}

exports.extendShape = extendShape;
exports.extendPath = extendPath;
exports.makePath = makePath;
exports.makeImage = makeImage;
exports.mergePath = mergePath;
exports.resizePath = resizePath;
exports.subPixelOptimizeLine = subPixelOptimizeLine;
exports.subPixelOptimizeRect = subPixelOptimizeRect;
exports.subPixelOptimize = subPixelOptimize;
exports.setHoverStyle = setHoverStyle;
exports.setLabelStyle = setLabelStyle;
exports.setTextStyle = setTextStyle;
exports.setText = setText;
exports.getFont = getFont;
exports.updateProps = updateProps;
exports.initProps = initProps;
exports.getTransform = getTransform;
exports.applyTransform = applyTransform;
exports.transformDirection = transformDirection;
exports.groupTransition = groupTransition;
exports.clipPointsByRect = clipPointsByRect;
exports.clipRectByRect = clipRectByRect;
exports.createIcon = createIcon;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var RADIAN_EPSILON = 1e-4;

function _trim(str) {
  return str.replace(/^\s+/, '').replace(/\s+$/, '');
}
/**
 * Linear mapping a value from domain to range
 * @memberOf module:echarts/util/number
 * @param  {(number|Array.<number>)} val
 * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]
 * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]
 * @param  {boolean} clamp
 * @return {(number|Array.<number>}
 */


function linearMap(val, domain, range, clamp) {
  var subDomain = domain[1] - domain[0];
  var subRange = range[1] - range[0];

  if (subDomain === 0) {
    return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
  } // Avoid accuracy problem in edge, such as
  // 146.39 - 62.83 === 83.55999999999999.
  // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
  // It is a little verbose for efficiency considering this method
  // is a hotspot.


  if (clamp) {
    if (subDomain > 0) {
      if (val <= domain[0]) {
        return range[0];
      } else if (val >= domain[1]) {
        return range[1];
      }
    } else {
      if (val >= domain[0]) {
        return range[0];
      } else if (val <= domain[1]) {
        return range[1];
      }
    }
  } else {
    if (val === domain[0]) {
      return range[0];
    }

    if (val === domain[1]) {
      return range[1];
    }
  }

  return (val - domain[0]) / subDomain * subRange + range[0];
}
/**
 * Convert a percent string to absolute number.
 * Returns NaN if percent is not a valid string or number
 * @memberOf module:echarts/util/number
 * @param {string|number} percent
 * @param {number} all
 * @return {number}
 */


function parsePercent(percent, all) {
  switch (percent) {
    case 'center':
    case 'middle':
      percent = '50%';
      break;

    case 'left':
    case 'top':
      percent = '0%';
      break;

    case 'right':
    case 'bottom':
      percent = '100%';
      break;
  }

  if (typeof percent === 'string') {
    if (_trim(percent).match(/%$/)) {
      return parseFloat(percent) / 100 * all;
    }

    return parseFloat(percent);
  }

  return percent == null ? NaN : +percent;
}
/**
 * (1) Fix rounding error of float numbers.
 * (2) Support return string to avoid scientific notation like '3.5e-7'.
 *
 * @param {number} x
 * @param {number} [precision]
 * @param {boolean} [returnStr]
 * @return {number|string}
 */


function round(x, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  } // Avoid range error


  precision = Math.min(Math.max(0, precision), 20);
  x = (+x).toFixed(precision);
  return returnStr ? x : +x;
}

function asc(arr) {
  arr.sort(function (a, b) {
    return a - b;
  });
  return arr;
}
/**
 * Get precision
 * @param {number} val
 */


function getPrecision(val) {
  val = +val;

  if (isNaN(val)) {
    return 0;
  } // It is much faster than methods converting number to string as follows
  //      var tmp = val.toString();
  //      return tmp.length - 1 - tmp.indexOf('.');
  // especially when precision is low


  var e = 1;
  var count = 0;

  while (Math.round(val * e) / e !== val) {
    e *= 10;
    count++;
  }

  return count;
}
/**
 * @param {string|number} val
 * @return {number}
 */


function getPrecisionSafe(val) {
  var str = val.toString(); // Consider scientific notation: '3.4e-12' '3.4e+12'

  var eIndex = str.indexOf('e');

  if (eIndex > 0) {
    var precision = +str.slice(eIndex + 1);
    return precision < 0 ? -precision : 0;
  } else {
    var dotIndex = str.indexOf('.');
    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
  }
}
/**
 * Minimal dicernible data precisioin according to a single pixel.
 *
 * @param {Array.<number>} dataExtent
 * @param {Array.<number>} pixelExtent
 * @return {number} precision
 */


function getPixelPrecision(dataExtent, pixelExtent) {
  var log = Math.log;
  var LN10 = Math.LN10;
  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20.

  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
/**
 * Get a data of given precision, assuring the sum of percentages
 * in valueList is 1.
 * The largest remainer method is used.
 * https://en.wikipedia.org/wiki/Largest_remainder_method
 *
 * @param {Array.<number>} valueList a list of all data
 * @param {number} idx index of the data to be processed in valueList
 * @param {number} precision integer number showing digits of precision
 * @return {number} percent ranging from 0 to 100
 */


function getPercentWithPrecision(valueList, idx, precision) {
  if (!valueList[idx]) {
    return 0;
  }

  var sum = zrUtil.reduce(valueList, function (acc, val) {
    return acc + (isNaN(val) ? 0 : val);
  }, 0);

  if (sum === 0) {
    return 0;
  }

  var digits = Math.pow(10, precision);
  var votesPerQuota = zrUtil.map(valueList, function (val) {
    return (isNaN(val) ? 0 : val) / sum * digits * 100;
  });
  var targetSeats = digits * 100;
  var seats = zrUtil.map(votesPerQuota, function (votes) {
    // Assign automatic seats.
    return Math.floor(votes);
  });
  var currentSum = zrUtil.reduce(seats, function (acc, val) {
    return acc + val;
  }, 0);
  var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {
    return votes - seats[idx];
  }); // Has remainding votes.

  while (currentSum < targetSeats) {
    // Find next largest remainder.
    var max = Number.NEGATIVE_INFINITY;
    var maxId = null;

    for (var i = 0, len = remainder.length; i < len; ++i) {
      if (remainder[i] > max) {
        max = remainder[i];
        maxId = i;
      }
    } // Add a vote to max remainder.


    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }

  return seats[idx] / digits;
} // Number.MAX_SAFE_INTEGER, ie do not support.


var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * To 0 - 2 * PI, considering negative radian.
 * @param {number} radian
 * @return {number}
 */

function remRadian(radian) {
  var pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
/**
 * @param {type} radian
 * @return {boolean}
 */


function isRadianAroundZero(val) {
  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}

var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; // jshint ignore:line

/**
 * @param {string|Date|number} value These values can be accepted:
 *   + An instance of Date, represent a time in its own time zone.
 *   + Or string in a subset of ISO 8601, only including:
 *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
 *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
 *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
 *     all of which will be treated as local time if time zone is not specified
 *     (see <https://momentjs.com/>).
 *   + Or other string format, including (all of which will be treated as loacal time):
 *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
 *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
 *   + a timestamp, which represent a time in UTC.
 * @return {Date} date
 */

function parseDate(value) {
  if (value instanceof Date) {
    return value;
  } else if (typeof value === 'string') {
    // Different browsers parse date in different way, so we parse it manually.
    // Some other issues:
    // new Date('1970-01-01') is UTC,
    // new Date('1970/01/01') and new Date('1970-1-01') is local.
    // See issue #3623
    var match = TIME_REG.exec(value);

    if (!match) {
      // return Invalid Date.
      return new Date(NaN);
    } // Use local time when no timezone offset specifed.


    if (!match[8]) {
      // match[n] can only be string or undefined.
      // But take care of '12' + 1 => '121'.
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
    } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,
    // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).
    // For example, system timezone is set as "Time Zone: America/Toronto",
    // then these code will get different result:
    // `new Date(1478411999999).getTimezoneOffset();  // get 240`
    // `new Date(1478412000000).getTimezoneOffset();  // get 300`
    // So we should not use `new Date`, but use `Date.UTC`.
    else {
        var hour = +match[4] || 0;

        if (match[8].toUpperCase() !== 'Z') {
          hour -= match[8].slice(0, 3);
        }

        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
      }
  } else if (value == null) {
    return new Date(NaN);
  }

  return new Date(Math.round(value));
}
/**
 * Quantity of a number. e.g. 0.1, 1, 10, 100
 *
 * @param  {number} val
 * @return {number}
 */


function quantity(val) {
  return Math.pow(10, quantityExponent(val));
}

function quantityExponent(val) {
  return Math.floor(Math.log(val) / Math.LN10);
}
/**
 * find a “nice” number approximately equal to x. Round the number if round = true,
 * take ceiling if round = false. The primary observation is that the “nicest”
 * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
 *
 * See "Nice Numbers for Graph Labels" of Graphic Gems.
 *
 * @param  {number} val Non-negative value.
 * @param  {boolean} round
 * @return {number}
 */


function nice(val, round) {
  var exponent = quantityExponent(val);
  var exp10 = Math.pow(10, exponent);
  var f = val / exp10; // 1 <= f < 10

  var nf;

  if (round) {
    if (f < 1.5) {
      nf = 1;
    } else if (f < 2.5) {
      nf = 2;
    } else if (f < 4) {
      nf = 3;
    } else if (f < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f < 1) {
      nf = 1;
    } else if (f < 2) {
      nf = 2;
    } else if (f < 3) {
      nf = 3;
    } else if (f < 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }

  val = nf * exp10; // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).
  // 20 is the uppper bound of toFixed.

  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
/**
 * Order intervals asc, and split them when overlap.
 * expect(numberUtil.reformIntervals([
 *     {interval: [18, 62], close: [1, 1]},
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [1, 1]},
 *     {interval: [62, 150], close: [1, 1]},
 *     {interval: [106, 150], close: [1, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ])).toEqual([
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [0, 1]},
 *     {interval: [18, 62], close: [0, 1]},
 *     {interval: [62, 150], close: [0, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ]);
 * @param {Array.<Object>} list, where `close` mean open or close
 *        of the interval, and Infinity can be used.
 * @return {Array.<Object>} The origin list, which has been reformed.
 */


function reformIntervals(list) {
  list.sort(function (a, b) {
    return littleThan(a, b, 0) ? -1 : 1;
  });
  var curr = -Infinity;
  var currClose = 1;

  for (var i = 0; i < list.length;) {
    var interval = list[i].interval;
    var close = list[i].close;

    for (var lg = 0; lg < 2; lg++) {
      if (interval[lg] <= curr) {
        interval[lg] = curr;
        close[lg] = !lg ? 1 - currClose : 1;
      }

      curr = interval[lg];
      currClose = close[lg];
    }

    if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
      list.splice(i, 1);
    } else {
      i++;
    }
  }

  return list;

  function littleThan(a, b, lg) {
    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));
  }
}
/**
 * parseFloat NaNs numeric-cast false positives (null|true|false|"")
 * ...but misinterprets leading-number strings, particularly hex literals ("0x...")
 * subtraction forces infinities to NaN
 *
 * @param {*} v
 * @return {boolean}
 */


function isNumeric(v) {
  return v - parseFloat(v) >= 0;
}

exports.linearMap = linearMap;
exports.parsePercent = parsePercent;
exports.round = round;
exports.asc = asc;
exports.getPrecision = getPrecision;
exports.getPrecisionSafe = getPrecisionSafe;
exports.getPixelPrecision = getPixelPrecision;
exports.getPercentWithPrecision = getPercentWithPrecision;
exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
exports.remRadian = remRadian;
exports.isRadianAroundZero = isRadianAroundZero;
exports.parseDate = parseDate;
exports.quantity = quantity;
exports.nice = nice;
exports.reformIntervals = reformIntervals;
exports.isNumeric = isNumeric;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var formatUtil = __webpack_require__(99);

var nubmerUtil = __webpack_require__(94);

var Model = __webpack_require__(102);

var each = zrUtil.each;
var isObject = zrUtil.isObject;
/**
 * If value is not array, then translate it to array.
 * @param  {*} value
 * @return {Array} [value] or value
 */

function normalizeToArray(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
/**
 * Sync default option between normal and emphasis like `position` and `show`
 * In case some one will write code like
 *     label: {
 *         normal: {
 *             show: false,
 *             position: 'outside',
 *             fontSize: 18
 *         },
 *         emphasis: {
 *             show: true
 *         }
 *     }
 * @param {Object} opt
 * @param {Array.<string>} subOpts
 */


function defaultEmphasis(opt, subOpts) {
  if (opt) {
    var emphasisOpt = opt.emphasis = opt.emphasis || {};
    var normalOpt = opt.normal = opt.normal || {}; // Default emphasis option from normal

    for (var i = 0, len = subOpts.length; i < len; i++) {
      var subOptName = subOpts[i];

      if (!emphasisOpt.hasOwnProperty(subOptName) && normalOpt.hasOwnProperty(subOptName)) {
        emphasisOpt[subOptName] = normalOpt[subOptName];
      }
    }
  }
}

var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([
//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',
//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',
//     // FIXME: deprecated, check and remove it.
//     'textStyle'
// ]);

/**
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method retieves value from data.
 * @param {string|number|Date|Array|Object} dataItem
 * @return {number|string|Date|Array.<number|string|Date>}
 */

function getDataItemValue(dataItem) {
  // Performance sensitive.
  return dataItem && (dataItem.value == null ? dataItem : dataItem.value);
}
/**
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method determine if dataItem has extra option besides value
 * @param {string|number|Date|Array|Object} dataItem
 */


function isDataItemOption(dataItem) {
  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array
  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
}
/**
 * This helper method convert value in data.
 * @param {string|number|Date} value
 * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.
 */


function converDataValue(value, dimInfo) {
  // Performance sensitive.
  var dimType = dimInfo && dimInfo.type;

  if (dimType === 'ordinal') {
    return value;
  }

  if (dimType === 'time' // spead up when using timestamp
  && typeof value !== 'number' && value != null && value !== '-') {
    value = +nubmerUtil.parseDate(value);
  } // dimType defaults 'number'.
  // If dimType is not ordinal and value is null or undefined or NaN or '-',
  // parse to NaN.


  return value == null || value === '' ? NaN : +value; // If string (like '-'), using '+' parse to NaN
}
/**
 * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.
 * @param {module:echarts/data/List} data
 * @param {Object} opt
 * @param {string} [opt.seriesIndex]
 * @param {Object} [opt.name]
 * @param {Object} [opt.mainType]
 * @param {Object} [opt.subType]
 */


function createDataFormatModel(data, opt) {
  var model = new Model();
  zrUtil.mixin(model, dataFormatMixin);
  model.seriesIndex = opt.seriesIndex;
  model.name = opt.name || '';
  model.mainType = opt.mainType;
  model.subType = opt.subType;

  model.getData = function () {
    return data;
  };

  return model;
} // PENDING A little ugly


var dataFormatMixin = {
  /**
   * Get params for formatter
   * @param {number} dataIndex
   * @param {string} [dataType]
   * @return {Object}
   */
  getDataParams: function (dataIndex, dataType) {
    var data = this.getData(dataType);
    var rawValue = this.getRawValue(dataIndex, dataType);
    var rawDataIndex = data.getRawIndex(dataIndex);
    var name = data.getName(dataIndex, true);
    var itemOpt = data.getRawDataItem(dataIndex);
    var color = data.getItemVisual(dataIndex, 'color');
    return {
      componentType: this.mainType,
      componentSubType: this.subType,
      seriesType: this.mainType === 'series' ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: this.id,
      seriesName: this.name,
      name: name,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType: dataType,
      value: rawValue,
      color: color,
      marker: formatUtil.getTooltipMarker(color),
      // Param name list for mapping `a`, `b`, `c`, `d`, `e`
      $vars: ['seriesName', 'name', 'value']
    };
  },

  /**
   * Format label
   * @param {number} dataIndex
   * @param {string} [status='normal'] 'normal' or 'emphasis'
   * @param {string} [dataType]
   * @param {number} [dimIndex]
   * @param {string} [labelProp='label']
   * @return {string}
   */
  getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {
    status = status || 'normal';
    var data = this.getData(dataType);
    var itemModel = data.getItemModel(dataIndex);
    var params = this.getDataParams(dataIndex, dataType);

    if (dimIndex != null && params.value instanceof Array) {
      params.value = params.value[dimIndex];
    }

    var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);

    if (typeof formatter === 'function') {
      params.status = status;
      return formatter(params);
    } else if (typeof formatter === 'string') {
      return formatUtil.formatTpl(formatter, params);
    }
  },

  /**
   * Get raw value in option
   * @param {number} idx
   * @param {string} [dataType]
   * @return {Object}
   */
  getRawValue: function (idx, dataType) {
    var data = this.getData(dataType);
    var dataItem = data.getRawDataItem(idx);

    if (dataItem != null) {
      return isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;
    }
  },

  /**
   * Should be implemented.
   * @param {number} dataIndex
   * @param {boolean} [multipleSeries=false]
   * @param {number} [dataType]
   * @return {string} tooltip string
   */
  formatTooltip: zrUtil.noop
};
/**
 * Mapping to exists for merge.
 *
 * @public
 * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists
 * @param {Object|Array.<Object>} newCptOptions
 * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
 *                          index of which is the same as exists.
 */

function mappingToExists(exists, newCptOptions) {
  // Mapping by the order by original option (but not order of
  // new option) in merge mode. Because we should ensure
  // some specified index (like xAxisIndex) is consistent with
  // original option, which is easy to understand, espatially in
  // media query. And in most case, merge option is used to
  // update partial option but not be expected to change order.
  newCptOptions = (newCptOptions || []).slice();
  var result = zrUtil.map(exists || [], function (obj, index) {
    return {
      exist: obj
    };
  }); // Mapping by id or name if specified.

  each(newCptOptions, function (cptOption, index) {
    if (!isObject(cptOption)) {
      return;
    } // id has highest priority.


    for (var i = 0; i < result.length; i++) {
      if (!result[i].option // Consider name: two map to one.
      && cptOption.id != null && result[i].exist.id === cptOption.id + '') {
        result[i].option = cptOption;
        newCptOptions[index] = null;
        return;
      }
    }

    for (var i = 0; i < result.length; i++) {
      var exist = result[i].exist;

      if (!result[i].option // Consider name: two map to one.
      // Can not match when both ids exist but different.
      && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {
        result[i].option = cptOption;
        newCptOptions[index] = null;
        return;
      }
    }
  }); // Otherwise mapping by index.

  each(newCptOptions, function (cptOption, index) {
    if (!isObject(cptOption)) {
      return;
    }

    var i = 0;

    for (; i < result.length; i++) {
      var exist = result[i].exist;

      if (!result[i].option // Existing model that already has id should be able to
      // mapped to (because after mapping performed model may
      // be assigned with a id, whish should not affect next
      // mapping), except those has inner id.
      && !isIdInner(exist) // Caution:
      // Do not overwrite id. But name can be overwritten,
      // because axis use name as 'show label text'.
      // 'exist' always has id and name and we dont
      // need to check it.
      && cptOption.id == null) {
        result[i].option = cptOption;
        break;
      }
    }

    if (i >= result.length) {
      result.push({
        option: cptOption
      });
    }
  });
  return result;
}
/**
 * Make id and name for mapping result (result of mappingToExists)
 * into `keyInfo` field.
 *
 * @public
 * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
 *                          which order is the same as exists.
 * @return {Array.<Object>} The input.
 */


function makeIdAndName(mapResult) {
  // We use this id to hash component models and view instances
  // in echarts. id can be specified by user, or auto generated.
  // The id generation rule ensures new view instance are able
  // to mapped to old instance when setOption are called in
  // no-merge mode. So we generate model id by name and plus
  // type in view id.
  // name can be duplicated among components, which is convenient
  // to specify multi components (like series) by one name.
  // Ensure that each id is distinct.
  var idMap = zrUtil.createHashMap();
  each(mapResult, function (item, index) {
    var existCpt = item.exist;
    existCpt && idMap.set(existCpt.id, item);
  });
  each(mapResult, function (item, index) {
    var opt = item.option;
    zrUtil.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  }); // Make name and id.

  each(mapResult, function (item, index) {
    var existCpt = item.exist;
    var opt = item.option;
    var keyInfo = item.keyInfo;

    if (!isObject(opt)) {
      return;
    } // name can be overwitten. Consider case: axis.name = '20km'.
    // But id generated by name will not be changed, which affect
    // only in that case: setOption with 'not merge mode' and view
    // instance will be recreated, which can be accepted.


    keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\0-'; // name may be displayed on screen, so use '-'.

    if (existCpt) {
      keyInfo.id = existCpt.id;
    } else if (opt.id != null) {
      keyInfo.id = opt.id + '';
    } else {
      // Consider this situatoin:
      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]
      //  optionB [{..}, {name: 'a'}, {name: 'a'}]
      // Series with the same name between optionA and optionB
      // should be mapped.
      var idNum = 0;

      do {
        keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
      } while (idMap.get(keyInfo.id));
    }

    idMap.set(keyInfo.id, item);
  });
}
/**
 * @public
 * @param {Object} cptOption
 * @return {boolean}
 */


function isIdInner(cptOption) {
  return isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\0_ec_\0') === 0;
}
/**
 * A helper for removing duplicate items between batchA and batchB,
 * and in themselves, and categorize by series.
 *
 * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]
 */


function compressBatches(batchA, batchB) {
  var mapA = {};
  var mapB = {};
  makeMap(batchA || [], mapA);
  makeMap(batchB || [], mapB, mapA);
  return [mapToArray(mapA), mapToArray(mapB)];

  function makeMap(sourceBatch, map, otherMap) {
    for (var i = 0, len = sourceBatch.length; i < len; i++) {
      var seriesId = sourceBatch[i].seriesId;
      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
      var otherDataIndices = otherMap && otherMap[seriesId];

      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
        var dataIndex = dataIndices[j];

        if (otherDataIndices && otherDataIndices[dataIndex]) {
          otherDataIndices[dataIndex] = null;
        } else {
          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
        }
      }
    }
  }

  function mapToArray(map, isData) {
    var result = [];

    for (var i in map) {
      if (map.hasOwnProperty(i) && map[i] != null) {
        if (isData) {
          result.push(+i);
        } else {
          var dataIndices = mapToArray(map[i], true);
          dataIndices.length && result.push({
            seriesId: i,
            dataIndex: dataIndices
          });
        }
      }
    }

    return result;
  }
}
/**
 * @param {module:echarts/data/List} data
 * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name
 *                         each of which can be Array or primary type.
 * @return {number|Array.<number>} dataIndex If not found, return undefined/null.
 */


function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function (value) {
      return data.indexOfRawIndex(value);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function (value) {
      return data.indexOfName(value);
    }) : data.indexOfName(payload.name);
  }
}
/**
 * Enable property storage to any host object.
 * Notice: Serialization is not supported.
 *
 * For example:
 * var get = modelUitl.makeGetter();
 *
 * function some(hostObj) {
 *      get(hostObj)._someProperty = 1212;
 *      ...
 * }
 *
 * @return {Function}
 */


var makeGetter = function () {
  var index = 0;
  return function () {
    var key = '\0__ec_prop_getter_' + index++;
    return function (hostObj) {
      return hostObj[key] || (hostObj[key] = {});
    };
  };
}();
/**
 * @param {module:echarts/model/Global} ecModel
 * @param {string|Object} finder
 *        If string, e.g., 'geo', means {geoIndex: 0}.
 *        If Object, could contain some of these properties below:
 *        {
 *            seriesIndex, seriesId, seriesName,
 *            geoIndex, geoId, geoName,
 *            bmapIndex, bmapId, bmapName,
 *            xAxisIndex, xAxisId, xAxisName,
 *            yAxisIndex, yAxisId, yAxisName,
 *            gridIndex, gridId, gridName,
 *            ... (can be extended)
 *        }
 *        Each properties can be number|string|Array.<number>|Array.<string>
 *        For example, a finder could be
 *        {
 *            seriesIndex: 3,
 *            geoId: ['aa', 'cc'],
 *            gridName: ['xx', 'rr']
 *        }
 *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)
 *        If nothing or null/undefined specified, return nothing.
 * @param {Object} [opt]
 * @param {string} [opt.defaultMainType]
 * @param {Array.<string>} [opt.includeMainTypes]
 * @return {Object} result like:
 *        {
 *            seriesModels: [seriesModel1, seriesModel2],
 *            seriesModel: seriesModel1, // The first model
 *            geoModels: [geoModel1, geoModel2],
 *            geoModel: geoModel1, // The first model
 *            ...
 *        }
 */


function parseFinder(ecModel, finder, opt) {
  if (zrUtil.isString(finder)) {
    var obj = {};
    obj[finder + 'Index'] = 0;
    finder = obj;
  }

  var defaultMainType = opt && opt.defaultMainType;

  if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name')) {
    finder[defaultMainType + 'Index'] = 0;
  }

  var result = {};
  each(finder, function (value, key) {
    var value = finder[key]; // Exclude 'dataIndex' and other illgal keys.

    if (key === 'dataIndex' || key === 'dataIndexInside') {
      result[key] = value;
      return;
    }

    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    var mainType = parsedKey[1];
    var queryType = (parsedKey[2] || '').toLowerCase();

    if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) {
      return;
    }

    var queryParam = {
      mainType: mainType
    };

    if (queryType !== 'index' || value !== 'all') {
      queryParam[queryType] = value;
    }

    var models = ecModel.queryComponents(queryParam);
    result[mainType + 'Models'] = models;
    result[mainType + 'Model'] = models[0];
  });
  return result;
}
/**
 * @see {module:echarts/data/helper/completeDimensions}
 * @param {module:echarts/data/List} data
 * @param {string|number} dataDim
 * @return {string}
 */


function dataDimToCoordDim(data, dataDim) {
  var dimensions = data.dimensions;
  dataDim = data.getDimension(dataDim);

  for (var i = 0; i < dimensions.length; i++) {
    var dimItem = data.getDimensionInfo(dimensions[i]);

    if (dimItem.name === dataDim) {
      return dimItem.coordDim;
    }
  }
}
/**
 * @see {module:echarts/data/helper/completeDimensions}
 * @param {module:echarts/data/List} data
 * @param {string} coordDim
 * @return {Array.<string>} data dimensions on the coordDim.
 */


function coordDimToDataDim(data, coordDim) {
  var dataDim = [];
  each(data.dimensions, function (dimName) {
    var dimItem = data.getDimensionInfo(dimName);

    if (dimItem.coordDim === coordDim) {
      dataDim[dimItem.coordDimIndex] = dimItem.name;
    }
  });
  return dataDim;
}
/**
 * @see {module:echarts/data/helper/completeDimensions}
 * @param {module:echarts/data/List} data
 * @param {string} otherDim Can be `otherDims`
 *                        like 'label' or 'tooltip'.
 * @return {Array.<string>} data dimensions on the otherDim.
 */


function otherDimToDataDim(data, otherDim) {
  var dataDim = [];
  each(data.dimensions, function (dimName) {
    var dimItem = data.getDimensionInfo(dimName);
    var otherDims = dimItem.otherDims;
    var dimIndex = otherDims[otherDim];

    if (dimIndex != null && dimIndex !== false) {
      dataDim[dimIndex] = dimItem.name;
    }
  });
  return dataDim;
}

function has(obj, prop) {
  return obj && obj.hasOwnProperty(prop);
}

exports.normalizeToArray = normalizeToArray;
exports.defaultEmphasis = defaultEmphasis;
exports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;
exports.getDataItemValue = getDataItemValue;
exports.isDataItemOption = isDataItemOption;
exports.converDataValue = converDataValue;
exports.createDataFormatModel = createDataFormatModel;
exports.dataFormatMixin = dataFormatMixin;
exports.mappingToExists = mappingToExists;
exports.makeIdAndName = makeIdAndName;
exports.isIdInner = isIdInner;
exports.compressBatches = compressBatches;
exports.queryDataIndex = queryDataIndex;
exports.makeGetter = makeGetter;
exports.parseFinder = parseFinder;
exports.dataDimToCoordDim = dataDimToCoordDim;
exports.coordDimToDataDim = coordDimToDataDim;
exports.otherDimToDataDim = otherDimToDataDim;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// (1) The code `if (__DEV__) ...` can be removed by build tool.
// (2) If intend to use `__DEV__`, this module should be imported. Use a global
// variable `__DEV__` may cause that miss the declaration (see #6535), or the
// declaration is behind of the using position (for example in `Model.extent`,
// And tools like rollup can not analysis the dependency if not import).
var dev; // In browser

if (typeof window !== 'undefined') {
  dev = window.__DEV__;
} // In node
else if (typeof global !== 'undefined') {
    dev = global.__DEV__;
  }

if (typeof dev === 'undefined') {
  dev = true;
}

var __DEV__ = dev;
exports.__DEV__ = __DEV__;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 97 */
/***/ (function(module, exports) {

var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
/**
 * 创建一个向量
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @return {Vector2}
 */

function create(x, y) {
  var out = new ArrayCtor(2);

  if (x == null) {
    x = 0;
  }

  if (y == null) {
    y = 0;
  }

  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * 复制向量数据
 * @param {Vector2} out
 * @param {Vector2} v
 * @return {Vector2}
 */


function copy(out, v) {
  out[0] = v[0];
  out[1] = v[1];
  return out;
}
/**
 * 克隆一个向量
 * @param {Vector2} v
 * @return {Vector2}
 */


function clone(v) {
  var out = new ArrayCtor(2);
  out[0] = v[0];
  out[1] = v[1];
  return out;
}
/**
 * 设置向量的两个项
 * @param {Vector2} out
 * @param {number} a
 * @param {number} b
 * @return {Vector2} 结果
 */


function set(out, a, b) {
  out[0] = a;
  out[1] = b;
  return out;
}
/**
 * 向量相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function add(out, v1, v2) {
  out[0] = v1[0] + v2[0];
  out[1] = v1[1] + v2[1];
  return out;
}
/**
 * 向量缩放后相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} a
 */


function scaleAndAdd(out, v1, v2, a) {
  out[0] = v1[0] + v2[0] * a;
  out[1] = v1[1] + v2[1] * a;
  return out;
}
/**
 * 向量相减
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function sub(out, v1, v2) {
  out[0] = v1[0] - v2[0];
  out[1] = v1[1] - v2[1];
  return out;
}
/**
 * 向量长度
 * @param {Vector2} v
 * @return {number}
 */


function len(v) {
  return Math.sqrt(lenSquare(v));
}

var length = len; // jshint ignore:line

/**
 * 向量长度平方
 * @param {Vector2} v
 * @return {number}
 */

function lenSquare(v) {
  return v[0] * v[0] + v[1] * v[1];
}

var lengthSquare = lenSquare;
/**
 * 向量乘法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */

function mul(out, v1, v2) {
  out[0] = v1[0] * v2[0];
  out[1] = v1[1] * v2[1];
  return out;
}
/**
 * 向量除法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function div(out, v1, v2) {
  out[0] = v1[0] / v2[0];
  out[1] = v1[1] / v2[1];
  return out;
}
/**
 * 向量点乘
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */


function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
/**
 * 向量缩放
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {number} s
 */


function scale(out, v, s) {
  out[0] = v[0] * s;
  out[1] = v[1] * s;
  return out;
}
/**
 * 向量归一化
 * @param {Vector2} out
 * @param {Vector2} v
 */


function normalize(out, v) {
  var d = len(v);

  if (d === 0) {
    out[0] = 0;
    out[1] = 0;
  } else {
    out[0] = v[0] / d;
    out[1] = v[1] / d;
  }

  return out;
}
/**
 * 计算向量间距离
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */


function distance(v1, v2) {
  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
}

var dist = distance;
/**
 * 向量距离平方
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */

function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}

var distSquare = distanceSquare;
/**
 * 求负向量
 * @param {Vector2} out
 * @param {Vector2} v
 */

function negate(out, v) {
  out[0] = -v[0];
  out[1] = -v[1];
  return out;
}
/**
 * 插值两个点
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} t
 */


function lerp(out, v1, v2, t) {
  out[0] = v1[0] + t * (v2[0] - v1[0]);
  out[1] = v1[1] + t * (v2[1] - v1[1]);
  return out;
}
/**
 * 矩阵左乘向量
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {Vector2} m
 */


function applyTransform(out, v, m) {
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * 求两个向量最小值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */


function min(out, v1, v2) {
  out[0] = Math.min(v1[0], v2[0]);
  out[1] = Math.min(v1[1], v2[1]);
  return out;
}
/**
 * 求两个向量最大值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */


function max(out, v1, v2) {
  out[0] = Math.max(v1[0], v2[0]);
  out[1] = Math.max(v1[1], v2[1]);
  return out;
}

exports.create = create;
exports.copy = copy;
exports.clone = clone;
exports.set = set;
exports.add = add;
exports.scaleAndAdd = scaleAndAdd;
exports.sub = sub;
exports.len = len;
exports.length = length;
exports.lenSquare = lenSquare;
exports.lengthSquare = lengthSquare;
exports.mul = mul;
exports.div = div;
exports.dot = dot;
exports.scale = scale;
exports.normalize = normalize;
exports.distance = distance;
exports.dist = dist;
exports.distanceSquare = distanceSquare;
exports.distSquare = distSquare;
exports.negate = negate;
exports.lerp = lerp;
exports.applyTransform = applyTransform;
exports.min = min;
exports.max = max;

/***/ }),
/* 98 */
/***/ (function(module, exports) {

/**
 * echarts设备环境识别
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author firede[firede@firede.us]
 * @desc thanks zepto.
 */
var env = {};

if (typeof navigator === 'undefined') {
  // In node
  env = {
    browser: {},
    os: {},
    node: true,
    // Assume canvas is supported
    canvasSupported: true,
    svgSupported: true
  };
} else {
  env = detect(navigator.userAgent);
}

var _default = env; // Zepto.js
// (c) 2010-2013 Thomas Fuchs
// Zepto.js may be freely distributed under the MIT license.

function detect(ua) {
  var os = {};
  var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
  // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
  // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
  // var touchpad = webos && ua.match(/TouchPad/);
  // var kindle = ua.match(/Kindle\/([\d.]+)/);
  // var silk = ua.match(/Silk\/([\d._]+)/);
  // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
  // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
  // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
  // var playbook = ua.match(/PlayBook/);
  // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);

  var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;

  var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
  || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+

  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
  // - discern (more) between multiple browsers on android
  // - decide if kindle fire in silk mode is android or not
  // - Firefox on Android doesn't specify the Android version
  // - possibly devide in os, device and browser hashes
  // if (browser.webkit = !!webkit) browser.version = webkit[1];
  // if (android) os.android = true, os.version = android[2];
  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
  // if (webos) os.webos = true, os.version = webos[2];
  // if (touchpad) os.touchpad = true;
  // if (blackberry) os.blackberry = true, os.version = blackberry[2];
  // if (bb10) os.bb10 = true, os.version = bb10[2];
  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
  // if (playbook) browser.playbook = true;
  // if (kindle) os.kindle = true, os.version = kindle[1];
  // if (silk) browser.silk = true, browser.version = silk[1];
  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
  // if (chrome) browser.chrome = true, browser.version = chrome[1];

  if (firefox) {
    browser.firefox = true;
    browser.version = firefox[1];
  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
  // if (webview) browser.webview = true;


  if (ie) {
    browser.ie = true;
    browser.version = ie[1];
  }

  if (edge) {
    browser.edge = true;
    browser.version = edge[1];
  } // It is difficult to detect WeChat in Win Phone precisely, because ua can
  // not be set on win phone. So we do not consider Win Phone.


  if (weChat) {
    browser.weChat = true;
  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));


  return {
    browser: browser,
    os: os,
    node: false,
    // 原生canvas支持，改极端点了
    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
    canvasSupported: !!document.createElement('canvas').getContext,
    svgSupported: typeof SVGRect !== 'undefined',
    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
    // works on most browsers
    // IE10/11 does not support touch event, and MS Edge supports them but not by
    // default, so we dont check navigator.maxTouchPoints for them here.
    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
    // <http://caniuse.com/#search=pointer%20event>.
    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
    // events currently. So we dont use that on other browsers unless tested sufficiently.
    // Although IE 10 supports pointer event, it use old style and is different from the
    // standard. So we exclude that. (IE 10 is hardly used on touch device)
    && (browser.edge || browser.ie && browser.version >= 11)
  };
}

module.exports = _default;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var textContain = __webpack_require__(108);

var numberUtil = __webpack_require__(94);

/**
 * 每三位默认加,格式化
 * @param {string|number} x
 * @return {string}
 */
function addCommas(x) {
  if (isNaN(x)) {
    return '-';
  }

  x = (x + '').split('.');
  return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');
}
/**
 * @param {string} str
 * @param {boolean} [upperCaseFirst=false]
 * @return {string} str
 */


function toCamelCase(str, upperCaseFirst) {
  str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
    return group1.toUpperCase();
  });

  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }

  return str;
}

var normalizeCssArray = zrUtil.normalizeCssArray;

function encodeHTML(source) {
  return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

var wrapVar = function (varName, seriesIdx) {
  return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
};
/**
 * Template formatter
 * @param {string} tpl
 * @param {Array.<Object>|Object} paramsList
 * @param {boolean} [encode=false]
 * @return {string}
 */


function formatTpl(tpl, paramsList, encode) {
  if (!zrUtil.isArray(paramsList)) {
    paramsList = [paramsList];
  }

  var seriesLen = paramsList.length;

  if (!seriesLen) {
    return '';
  }

  var $vars = paramsList[0].$vars || [];

  for (var i = 0; i < $vars.length; i++) {
    var alias = TPL_VAR_ALIAS[i];
    var val = wrapVar(alias, 0);
    tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);
  }

  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
    for (var k = 0; k < $vars.length; k++) {
      var val = paramsList[seriesIdx][$vars[k]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
    }
  }

  return tpl;
}
/**
 * simple Template formatter
 *
 * @param {string} tpl
 * @param {Object} param
 * @param {boolean} [encode=false]
 * @return {string}
 */


function formatTplSimple(tpl, param, encode) {
  zrUtil.each(param, function (value, key) {
    tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);
  });
  return tpl;
}
/**
 * @param {string} color
 * @param {string} [extraCssText]
 * @return {string}
 */


function getTooltipMarker(color, extraCssText) {
  return color ? '<span style="display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>' : '';
}
/**
 * @param {string} str
 * @return {string}
 * @inner
 */


var s2d = function (str) {
  return str < 10 ? '0' + str : str;
};
/**
 * ISO Date format
 * @param {string} tpl
 * @param {number} value
 * @param {boolean} [isUTC=false] Default in local time.
 *           see `module:echarts/scale/Time`
 *           and `module:echarts/util/number#parseDate`.
 * @inner
 */


function formatTime(tpl, value, isUTC) {
  if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
    tpl = 'MM-dd\nyyyy';
  }

  var date = numberUtil.parseDate(value);
  var utc = isUTC ? 'UTC' : '';
  var y = date['get' + utc + 'FullYear']();
  var M = date['get' + utc + 'Month']() + 1;
  var d = date['get' + utc + 'Date']();
  var h = date['get' + utc + 'Hours']();
  var m = date['get' + utc + 'Minutes']();
  var s = date['get' + utc + 'Seconds']();
  tpl = tpl.replace('MM', s2d(M)).replace('M', M).replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);
  return tpl;
}
/**
 * Capital first
 * @param {string} str
 * @return {string}
 */


function capitalFirst(str) {
  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}

var truncateText = textContain.truncateText;
var getTextRect = textContain.getBoundingRect;
exports.addCommas = addCommas;
exports.toCamelCase = toCamelCase;
exports.normalizeCssArray = normalizeCssArray;
exports.encodeHTML = encodeHTML;
exports.formatTpl = formatTpl;
exports.formatTplSimple = formatTplSimple;
exports.getTooltipMarker = getTooltipMarker;
exports.formatTime = formatTime;
exports.capitalFirst = capitalFirst;
exports.truncateText = truncateText;
exports.getTextRect = getTextRect;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var Displayable = __webpack_require__(127);

var zrUtil = __webpack_require__(91);

var PathProxy = __webpack_require__(122);

var pathContain = __webpack_require__(202);

var Pattern = __webpack_require__(146);

var getCanvasPattern = Pattern.prototype.getCanvasPattern;
var abs = Math.abs;
var pathProxyForDraw = new PathProxy(true);
/**
 * @alias module:zrender/graphic/Path
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */

function Path(opts) {
  Displayable.call(this, opts);
  /**
   * @type {module:zrender/core/PathProxy}
   * @readOnly
   */

  this.path = null;
}

Path.prototype = {
  constructor: Path,
  type: 'path',
  __dirtyPath: true,
  strokeContainThreshold: 5,
  brush: function (ctx, prevEl) {
    var style = this.style;
    var path = this.path || pathProxyForDraw;
    var hasStroke = style.hasStroke();
    var hasFill = style.hasFill();
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill && !!fill.colorStops;
    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
    var hasFillPattern = hasFill && !!fill.image;
    var hasStrokePattern = hasStroke && !!stroke.image;
    style.bind(ctx, this, prevEl);
    this.setTransform(ctx);

    if (this.__dirty) {
      var rect; // Update gradient because bounding rect may changed

      if (hasFillGradient) {
        rect = rect || this.getBoundingRect();
        this._fillGradient = style.getGradient(ctx, fill, rect);
      }

      if (hasStrokeGradient) {
        rect = rect || this.getBoundingRect();
        this._strokeGradient = style.getGradient(ctx, stroke, rect);
      }
    } // Use the gradient or pattern


    if (hasFillGradient) {
      // PENDING If may have affect the state
      ctx.fillStyle = this._fillGradient;
    } else if (hasFillPattern) {
      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
    }

    if (hasStrokeGradient) {
      ctx.strokeStyle = this._strokeGradient;
    } else if (hasStrokePattern) {
      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
    }

    var lineDash = style.lineDash;
    var lineDashOffset = style.lineDashOffset;
    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy

    var scale = this.getGlobalScale();
    path.setScale(scale[0], scale[1]); // Proxy context
    // Rebuild path in following 2 cases
    // 1. Path is dirty
    // 2. Path needs javascript implemented lineDash stroking.
    //    In this case, lineDash information will not be saved in PathProxy

    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
      path.beginPath(ctx); // Setting line dash before build path

      if (lineDash && !ctxLineDash) {
        path.setLineDash(lineDash);
        path.setLineDashOffset(lineDashOffset);
      }

      this.buildPath(path, this.shape, false); // Clear path dirty flag

      if (this.path) {
        this.__dirtyPath = false;
      }
    } else {
      // Replay path building
      ctx.beginPath();
      this.path.rebuildPath(ctx);
    }

    hasFill && path.fill(ctx);

    if (lineDash && ctxLineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }

    hasStroke && path.stroke(ctx);

    if (lineDash && ctxLineDash) {
      // PENDING
      // Remove lineDash
      ctx.setLineDash([]);
    }

    this.restoreTransform(ctx); // Draw rect text

    if (style.text != null) {
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },
  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
  // Like in circle
  buildPath: function (ctx, shapeCfg, inBundle) {},
  createPathProxy: function () {
    this.path = new PathProxy();
  },
  getBoundingRect: function () {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;

    if (needsUpdateRect) {
      var path = this.path;

      if (!path) {
        // Create path on demand.
        path = this.path = new PathProxy();
      }

      if (this.__dirtyPath) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
      }

      rect = path.getBoundingRect();
    }

    this._rect = rect;

    if (style.hasStroke()) {
      // Needs update rect with stroke lineWidth when
      // 1. Element changes scale or lineWidth
      // 2. Shape is changed
      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());

      if (this.__dirty || needsUpdateRect) {
        rectWithStroke.copy(rect); // FIXME Must after updateTransform

        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical

        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill

        if (!style.hasFill()) {
          w = Math.max(w, this.strokeContainThreshold || 4);
        } // Consider line width
        // Line scale can't be 0;


        if (lineScale > 1e-10) {
          rectWithStroke.width += w / lineScale;
          rectWithStroke.height += w / lineScale;
          rectWithStroke.x -= w / lineScale / 2;
          rectWithStroke.y -= w / lineScale / 2;
        }
      } // Return rect with stroke


      return rectWithStroke;
    }

    return rect;
  },
  contain: function (x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    var style = this.style;
    x = localPos[0];
    y = localPos[1];

    if (rect.contain(x, y)) {
      var pathData = this.path.data;

      if (style.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;

        if (lineScale > 1e-10) {
          // Only add extra hover lineWidth when there are no fill
          if (!style.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }

          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
            return true;
          }
        }
      }

      if (style.hasFill()) {
        return pathContain.contain(pathData, x, y);
      }
    }

    return false;
  },

  /**
   * @param  {boolean} dirtyPath
   */
  dirty: function (dirtyPath) {
    if (dirtyPath == null) {
      dirtyPath = true;
    } // Only mark dirty, not mark clean


    if (dirtyPath) {
      this.__dirtyPath = dirtyPath;
      this._rect = null;
    }

    this.__dirty = true;
    this.__zr && this.__zr.refresh(); // Used as a clipping path

    if (this.__clipTarget) {
      this.__clipTarget.dirty();
    }
  },

  /**
   * Alias for animate('shape')
   * @param {boolean} loop
   */
  animateShape: function (loop) {
    return this.animate('shape', loop);
  },
  // Overwrite attrKV
  attrKV: function (key, value) {
    // FIXME
    if (key === 'shape') {
      this.setShape(value);
      this.__dirtyPath = true;
      this._rect = null;
    } else {
      Displayable.prototype.attrKV.call(this, key, value);
    }
  },

  /**
   * @param {Object|string} key
   * @param {*} value
   */
  setShape: function (key, value) {
    var shape = this.shape; // Path from string may not have shape

    if (shape) {
      if (zrUtil.isObject(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            shape[name] = key[name];
          }
        }
      } else {
        shape[key] = value;
      }

      this.dirty(true);
    }

    return this;
  },
  getLineScale: function () {
    var m = this.transform; // Get the line scale.
    // Determinant of `m` means how much the area is enlarged by the
    // transformation. So its square root can be used as a scale factor
    // for width.

    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
  }
};
/**
 * 扩展一个 Path element, 比如星形，圆等。
 * Extend a path element
 * @param {Object} props
 * @param {string} props.type Path type
 * @param {Function} props.init Initialize
 * @param {Function} props.buildPath Overwrite buildPath method
 * @param {Object} [props.style] Extended default style config
 * @param {Object} [props.shape] Extended default shape config
 */

Path.extend = function (defaults) {
  var Sub = function (opts) {
    Path.call(this, opts);

    if (defaults.style) {
      // Extend default style
      this.style.extendFrom(defaults.style, false);
    } // Extend default shape


    var defaultShape = defaults.shape;

    if (defaultShape) {
      this.shape = this.shape || {};
      var thisShape = this.shape;

      for (var name in defaultShape) {
        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
          thisShape[name] = defaultShape[name];
        }
      }
    }

    defaults.init && defaults.init.call(this, opts);
  };

  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象

  for (var name in defaults) {
    // Extending prototype values and methods
    if (name !== 'style' && name !== 'shape') {
      Sub.prototype[name] = defaults[name];
    }
  }

  return Sub;
};

zrUtil.inherits(Path, Displayable);
var _default = Path;
module.exports = _default;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var vec2 = __webpack_require__(97);

var matrix = __webpack_require__(110);

/**
 * @module echarts/core/BoundingRect
 */
var v2ApplyTransform = vec2.applyTransform;
var mathMin = Math.min;
var mathMax = Math.max;
/**
 * @alias module:echarts/core/BoundingRect
 */

function BoundingRect(x, y, width, height) {
  if (width < 0) {
    x = x + width;
    width = -width;
  }

  if (height < 0) {
    y = y + height;
    height = -height;
  }
  /**
   * @type {number}
   */


  this.x = x;
  /**
   * @type {number}
   */

  this.y = y;
  /**
   * @type {number}
   */

  this.width = width;
  /**
   * @type {number}
   */

  this.height = height;
}

BoundingRect.prototype = {
  constructor: BoundingRect,

  /**
   * @param {module:echarts/core/BoundingRect} other
   */
  union: function (other) {
    var x = mathMin(other.x, this.x);
    var y = mathMin(other.y, this.y);
    this.width = mathMax(other.x + other.width, this.x + this.width) - x;
    this.height = mathMax(other.y + other.height, this.y + this.height) - y;
    this.x = x;
    this.y = y;
  },

  /**
   * @param {Array.<number>} m
   * @methods
   */
  applyTransform: function () {
    var lt = [];
    var rb = [];
    var lb = [];
    var rt = [];
    return function (m) {
      // In case usage like this
      // el.getBoundingRect().applyTransform(el.transform)
      // And element has no transform
      if (!m) {
        return;
      }

      lt[0] = lb[0] = this.x;
      lt[1] = rt[1] = this.y;
      rb[0] = rt[0] = this.x + this.width;
      rb[1] = lb[1] = this.y + this.height;
      v2ApplyTransform(lt, lt, m);
      v2ApplyTransform(rb, rb, m);
      v2ApplyTransform(lb, lb, m);
      v2ApplyTransform(rt, rt, m);
      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
      this.width = maxX - this.x;
      this.height = maxY - this.y;
    };
  }(),

  /**
   * Calculate matrix of transforming from self to target rect
   * @param  {module:zrender/core/BoundingRect} b
   * @return {Array.<number>}
   */
  calculateTransform: function (b) {
    var a = this;
    var sx = b.width / a.width;
    var sy = b.height / a.height;
    var m = matrix.create(); // 矩阵右乘

    matrix.translate(m, m, [-a.x, -a.y]);
    matrix.scale(m, m, [sx, sy]);
    matrix.translate(m, m, [b.x, b.y]);
    return m;
  },

  /**
   * @param {(module:echarts/core/BoundingRect|Object)} b
   * @return {boolean}
   */
  intersect: function (b) {
    if (!b) {
      return false;
    }

    if (!(b instanceof BoundingRect)) {
      // Normalize negative width/height.
      b = BoundingRect.create(b);
    }

    var a = this;
    var ax0 = a.x;
    var ax1 = a.x + a.width;
    var ay0 = a.y;
    var ay1 = a.y + a.height;
    var bx0 = b.x;
    var bx1 = b.x + b.width;
    var by0 = b.y;
    var by1 = b.y + b.height;
    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
  },
  contain: function (x, y) {
    var rect = this;
    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
  },

  /**
   * @return {module:echarts/core/BoundingRect}
   */
  clone: function () {
    return new BoundingRect(this.x, this.y, this.width, this.height);
  },

  /**
   * Copy from another rect
   */
  copy: function (other) {
    this.x = other.x;
    this.y = other.y;
    this.width = other.width;
    this.height = other.height;
  },
  plain: function () {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }
};
/**
 * @param {Object|module:zrender/core/BoundingRect} rect
 * @param {number} rect.x
 * @param {number} rect.y
 * @param {number} rect.width
 * @param {number} rect.height
 * @return {module:zrender/core/BoundingRect}
 */

BoundingRect.create = function (rect) {
  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
};

var _default = BoundingRect;
module.exports = _default;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var env = __webpack_require__(98);

var clazzUtil = __webpack_require__(104);

var lineStyleMixin = __webpack_require__(198);

var areaStyleMixin = __webpack_require__(199);

var textStyleMixin = __webpack_require__(200);

var itemStyleMixin = __webpack_require__(223);

/**
 * @module echarts/model/Model
 */
var mixin = zrUtil.mixin;
/**
 * @alias module:echarts/model/Model
 * @constructor
 * @param {Object} option
 * @param {module:echarts/model/Model} [parentModel]
 * @param {module:echarts/model/Global} [ecModel]
 */

function Model(option, parentModel, ecModel) {
  /**
   * @type {module:echarts/model/Model}
   * @readOnly
   */
  this.parentModel = parentModel;
  /**
   * @type {module:echarts/model/Global}
   * @readOnly
   */

  this.ecModel = ecModel;
  /**
   * @type {Object}
   * @protected
   */

  this.option = option; // Simple optimization
  // if (this.init) {
  //     if (arguments.length <= 4) {
  //         this.init(option, parentModel, ecModel, extraOpt);
  //     }
  //     else {
  //         this.init.apply(this, arguments);
  //     }
  // }
}

Model.prototype = {
  constructor: Model,

  /**
   * Model 的初始化函数
   * @param {Object} option
   */
  init: null,

  /**
   * 从新的 Option merge
   */
  mergeOption: function (option) {
    zrUtil.merge(this.option, option, true);
  },

  /**
   * @param {string|Array.<string>} path
   * @param {boolean} [ignoreParent=false]
   * @return {*}
   */
  get: function (path, ignoreParent) {
    if (path == null) {
      return this.option;
    }

    return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));
  },

  /**
   * @param {string} key
   * @param {boolean} [ignoreParent=false]
   * @return {*}
   */
  getShallow: function (key, ignoreParent) {
    var option = this.option;
    var val = option == null ? option : option[key];
    var parentModel = !ignoreParent && getParent(this, key);

    if (val == null && parentModel) {
      val = parentModel.getShallow(key);
    }

    return val;
  },

  /**
   * @param {string|Array.<string>} [path]
   * @param {module:echarts/model/Model} [parentModel]
   * @return {module:echarts/model/Model}
   */
  getModel: function (path, parentModel) {
    var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));
    var thisParentModel;
    parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);
    return new Model(obj, parentModel, this.ecModel);
  },

  /**
   * If model has option
   */
  isEmpty: function () {
    return this.option == null;
  },
  restoreData: function () {},
  // Pending
  clone: function () {
    var Ctor = this.constructor;
    return new Ctor(zrUtil.clone(this.option));
  },
  setReadOnly: function (properties) {
    clazzUtil.setReadOnly(this, properties);
  },
  // If path is null/undefined, return null/undefined.
  parsePath: function (path) {
    if (typeof path === 'string') {
      path = path.split('.');
    }

    return path;
  },

  /**
   * @param {Function} getParentMethod
   *        param {Array.<string>|string} path
   *        return {module:echarts/model/Model}
   */
  customizeGetParent: function (getParentMethod) {
    clazzUtil.set(this, 'getParent', getParentMethod);
  },
  isAnimationEnabled: function () {
    if (!env.node) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  }
};

function doGet(obj, pathArr, parentModel) {
  for (var i = 0; i < pathArr.length; i++) {
    // Ignore empty
    if (!pathArr[i]) {
      continue;
    } // obj could be number/string/... (like 0)


    obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;

    if (obj == null) {
      break;
    }
  }

  if (obj == null && parentModel) {
    obj = parentModel.get(pathArr);
  }

  return obj;
} // `path` can be null/undefined


function getParent(model, path) {
  var getParentMethod = clazzUtil.get(model, 'getParent');
  return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;
} // Enable Model.extend.


clazzUtil.enableClassExtend(Model);
mixin(Model, lineStyleMixin);
mixin(Model, areaStyleMixin);
mixin(Model, textStyleMixin);
mixin(Model, itemStyleMixin);
var _default = Model;
module.exports = _default;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var BoundingRect = __webpack_require__(101);

var _number = __webpack_require__(94);

var parsePercent = _number.parsePercent;

var formatUtil = __webpack_require__(99);

// Layout helpers for each component positioning
var each = zrUtil.each;
/**
 * @public
 */

var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];
/**
 * @public
 */

var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];

function boxLayout(orient, group, gap, maxWidth, maxHeight) {
  var x = 0;
  var y = 0;

  if (maxWidth == null) {
    maxWidth = Infinity;
  }

  if (maxHeight == null) {
    maxHeight = Infinity;
  }

  var currentLineMaxSize = 0;
  group.eachChild(function (child, idx) {
    var position = child.position;
    var rect = child.getBoundingRect();
    var nextChild = group.childAt(idx + 1);
    var nextChildRect = nextChild && nextChild.getBoundingRect();
    var nextX;
    var nextY;

    if (orient === 'horizontal') {
      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group
      // FIXME compare before adding gap?

      if (nextX > maxWidth || child.newline) {
        x = 0;
        nextX = moveX;
        y += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        // FIXME: consider rect.y is not `0`?
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group

      if (nextY > maxHeight || child.newline) {
        x += currentLineMaxSize + gap;
        y = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }

    if (child.newline) {
      return;
    }

    position[0] = x;
    position[1] = y;
    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;
  });
}
/**
 * VBox or HBox layouting
 * @param {string} orient
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */


var box = boxLayout;
/**
 * VBox layouting
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */

var vbox = zrUtil.curry(boxLayout, 'vertical');
/**
 * HBox layouting
 * @param {module:zrender/container/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */

var hbox = zrUtil.curry(boxLayout, 'horizontal');
/**
 * If x or x2 is not specified or 'center' 'left' 'right',
 * the width would be as long as possible.
 * If y or y2 is not specified or 'middle' 'top' 'bottom',
 * the height would be as long as possible.
 *
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.x]
 * @param {number|string} [positionInfo.y]
 * @param {number|string} [positionInfo.x2]
 * @param {number|string} [positionInfo.y2]
 * @param {Object} containerRect {width, height}
 * @param {string|number} margin
 * @return {Object} {width, height}
 */

function getAvailableSize(positionInfo, containerRect, margin) {
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var x = parsePercent(positionInfo.x, containerWidth);
  var y = parsePercent(positionInfo.y, containerHeight);
  var x2 = parsePercent(positionInfo.x2, containerWidth);
  var y2 = parsePercent(positionInfo.y2, containerHeight);
  (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
  (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
  (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
  (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
  margin = formatUtil.normalizeCssArray(margin || 0);
  return {
    width: Math.max(x2 - x - margin[1] - margin[3], 0),
    height: Math.max(y2 - y - margin[0] - margin[2], 0)
  };
}
/**
 * Parse position info.
 *
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.left]
 * @param {number|string} [positionInfo.top]
 * @param {number|string} [positionInfo.right]
 * @param {number|string} [positionInfo.bottom]
 * @param {number|string} [positionInfo.width]
 * @param {number|string} [positionInfo.height]
 * @param {number|string} [positionInfo.aspect] Aspect is width / height
 * @param {Object} containerRect
 * @param {string|number} [margin]
 *
 * @return {module:zrender/core/BoundingRect}
 */


function getLayoutRect(positionInfo, containerRect, margin) {
  margin = formatUtil.normalizeCssArray(margin || 0);
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var left = parsePercent(positionInfo.left, containerWidth);
  var top = parsePercent(positionInfo.top, containerHeight);
  var right = parsePercent(positionInfo.right, containerWidth);
  var bottom = parsePercent(positionInfo.bottom, containerHeight);
  var width = parsePercent(positionInfo.width, containerWidth);
  var height = parsePercent(positionInfo.height, containerHeight);
  var verticalMargin = margin[2] + margin[0];
  var horizontalMargin = margin[1] + margin[3];
  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right

  if (isNaN(width)) {
    width = containerWidth - right - horizontalMargin - left;
  }

  if (isNaN(height)) {
    height = containerHeight - bottom - verticalMargin - top;
  }

  if (aspect != null) {
    // If width and height are not given
    // 1. Graph should not exceeds the container
    // 2. Aspect must be keeped
    // 3. Graph should take the space as more as possible
    // FIXME
    // Margin is not considered, because there is no case that both
    // using margin and aspect so far.
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    } // Calculate width or height with given aspect


    if (isNaN(width)) {
      width = aspect * height;
    }

    if (isNaN(height)) {
      height = width / aspect;
    }
  } // If left is not specified, calculate left from right and width


  if (isNaN(left)) {
    left = containerWidth - right - width - horizontalMargin;
  }

  if (isNaN(top)) {
    top = containerHeight - bottom - height - verticalMargin;
  } // Align left and top


  switch (positionInfo.left || positionInfo.right) {
    case 'center':
      left = containerWidth / 2 - width / 2 - margin[3];
      break;

    case 'right':
      left = containerWidth - width - horizontalMargin;
      break;
  }

  switch (positionInfo.top || positionInfo.bottom) {
    case 'middle':
    case 'center':
      top = containerHeight / 2 - height / 2 - margin[0];
      break;

    case 'bottom':
      top = containerHeight - height - verticalMargin;
      break;
  } // If something is wrong and left, top, width, height are calculated as NaN


  left = left || 0;
  top = top || 0;

  if (isNaN(width)) {
    // Width may be NaN if only one value is given except width
    width = containerWidth - horizontalMargin - left - (right || 0);
  }

  if (isNaN(height)) {
    // Height may be NaN if only one value is given except height
    height = containerHeight - verticalMargin - top - (bottom || 0);
  }

  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
/**
 * Position a zr element in viewport
 *  Group position is specified by either
 *  {left, top}, {right, bottom}
 *  If all properties exists, right and bottom will be igonred.
 *
 * Logic:
 *     1. Scale (against origin point in parent coord)
 *     2. Rotate (against origin point in parent coord)
 *     3. Traslate (with el.position by this method)
 * So this method only fixes the last step 'Traslate', which does not affect
 * scaling and rotating.
 *
 * If be called repeatly with the same input el, the same result will be gotten.
 *
 * @param {module:zrender/Element} el Should have `getBoundingRect` method.
 * @param {Object} positionInfo
 * @param {number|string} [positionInfo.left]
 * @param {number|string} [positionInfo.top]
 * @param {number|string} [positionInfo.right]
 * @param {number|string} [positionInfo.bottom]
 * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'
 * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'
 * @param {Object} containerRect
 * @param {string|number} margin
 * @param {Object} [opt]
 * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.
 * @param {Array.<number>} [opt.boundingMode='all']
 *        Specify how to calculate boundingRect when locating.
 *        'all': Position the boundingRect that is transformed and uioned
 *               both itself and its descendants.
 *               This mode simplies confine the elements in the bounding
 *               of their container (e.g., using 'right: 0').
 *        'raw': Position the boundingRect that is not transformed and only itself.
 *               This mode is useful when you want a element can overflow its
 *               container. (Consider a rotated circle needs to be located in a corner.)
 *               In this mode positionInfo.width/height can only be number.
 */


function positionElement(el, positionInfo, containerRect, margin, opt) {
  var h = !opt || !opt.hv || opt.hv[0];
  var v = !opt || !opt.hv || opt.hv[1];
  var boundingMode = opt && opt.boundingMode || 'all';

  if (!h && !v) {
    return;
  }

  var rect;

  if (boundingMode === 'raw') {
    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
  } else {
    rect = el.getBoundingRect();

    if (el.needLocalTransform()) {
      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,
      // which should not be modified.

      rect = rect.clone();
      rect.applyTransform(transform);
    }
  } // The real width and height can not be specified but calculated by the given el.


  positionInfo = getLayoutRect(zrUtil.defaults({
    width: rect.width,
    height: rect.height
  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform
  // (see zrender/core/Transformable#getLocalTransfrom),
  // we can just only modify el.position to get final result.

  var elPos = el.position;
  var dx = h ? positionInfo.x - rect.x : 0;
  var dy = v ? positionInfo.y - rect.y : 0;
  el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
}
/**
 * @param {Object} option Contains some of the properties in HV_NAMES.
 * @param {number} hvIdx 0: horizontal; 1: vertical.
 */


function sizeCalculable(option, hvIdx) {
  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
/**
 * Consider Case:
 * When defulat option has {left: 0, width: 100}, and we set {right: 0}
 * through setOption or media query, using normal zrUtil.merge will cause
 * {right: 0} does not take effect.
 *
 * @example
 * ComponentModel.extend({
 *     init: function () {
 *         ...
 *         var inputPositionParams = layout.getLayoutParams(option);
 *         this.mergeOption(inputPositionParams);
 *     },
 *     mergeOption: function (newOption) {
 *         newOption && zrUtil.merge(thisOption, newOption, true);
 *         layout.mergeLayoutParam(thisOption, newOption);
 *     }
 * });
 *
 * @param {Object} targetOption
 * @param {Object} newOption
 * @param {Object|string} [opt]
 * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components
 *  that width (or height) should not be calculated by left and right (or top and bottom).
 */


function mergeLayoutParam(targetOption, newOption, opt) {
  !zrUtil.isObject(opt) && (opt = {});
  var ignoreSize = opt.ignoreSize;
  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  var hResult = merge(HV_NAMES[0], 0);
  var vResult = merge(HV_NAMES[1], 1);
  copy(HV_NAMES[0], targetOption, hResult);
  copy(HV_NAMES[1], targetOption, vResult);

  function merge(names, hvIdx) {
    var newParams = {};
    var newValueCount = 0;
    var merged = {};
    var mergedValueCount = 0;
    var enoughParamNumber = 2;
    each(names, function (name) {
      merged[name] = targetOption[name];
    });
    each(names, function (name) {
      // Consider case: newOption.width is null, which is
      // set by user for removing width setting.
      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
      hasValue(newParams, name) && newValueCount++;
      hasValue(merged, name) && mergedValueCount++;
    });

    if (ignoreSize[hvIdx]) {
      // Only one of left/right is premitted to exist.
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }

      return merged;
    } // Case: newOption: {width: ..., right: ...},
    // or targetOption: {right: ...} and newOption: {width: ...},
    // There is no conflict when merged only has params count
    // little than enoughParamNumber.


    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } // Case: newOption: {width: ..., right: ...},
    // Than we can make sure user only want those two, and ignore
    // all origin params in targetOption.
    else if (newValueCount >= enoughParamNumber) {
        return newParams;
      } else {
        // Chose another param from targetOption by priority.
        for (var i = 0; i < names.length; i++) {
          var name = names[i];

          if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
            newParams[name] = targetOption[name];
            break;
          }
        }

        return newParams;
      }
  }

  function hasProp(obj, name) {
    return obj.hasOwnProperty(name);
  }

  function hasValue(obj, name) {
    return obj[name] != null && obj[name] !== 'auto';
  }

  function copy(names, target, source) {
    each(names, function (name) {
      target[name] = source[name];
    });
  }
}
/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 * @param {Object} source
 * @return {Object} Result contains those props.
 */


function getLayoutParams(source) {
  return copyLayoutParams({}, source);
}
/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 * @param {Object} source
 * @return {Object} Result contains those props.
 */


function copyLayoutParams(target, source) {
  source && target && each(LOCATION_PARAMS, function (name) {
    source.hasOwnProperty(name) && (target[name] = source[name]);
  });
  return target;
}

exports.LOCATION_PARAMS = LOCATION_PARAMS;
exports.HV_NAMES = HV_NAMES;
exports.box = box;
exports.vbox = vbox;
exports.hbox = hbox;
exports.getAvailableSize = getAvailableSize;
exports.getLayoutRect = getLayoutRect;
exports.positionElement = positionElement;
exports.sizeCalculable = sizeCalculable;
exports.mergeLayoutParam = mergeLayoutParam;
exports.getLayoutParams = getLayoutParams;
exports.copyLayoutParams = copyLayoutParams;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__(91);

var TYPE_DELIMITER = '.';
var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
var MEMBER_PRIFIX = '\0ec_\0';
/**
 * Hide private class member.
 * The same behavior as `host[name] = value;` (can be right-value)
 * @public
 */

function set(host, name, value) {
  return host[MEMBER_PRIFIX + name] = value;
}
/**
 * Hide private class member.
 * The same behavior as `host[name];`
 * @public
 */


function get(host, name) {
  return host[MEMBER_PRIFIX + name];
}
/**
 * For hidden private class member.
 * The same behavior as `host.hasOwnProperty(name);`
 * @public
 */


function hasOwn(host, name) {
  return host.hasOwnProperty(MEMBER_PRIFIX + name);
}
/**
 * Notice, parseClassType('') should returns {main: '', sub: ''}
 * @public
 */


function parseClassType(componentType) {
  var ret = {
    main: '',
    sub: ''
  };

  if (componentType) {
    componentType = componentType.split(TYPE_DELIMITER);
    ret.main = componentType[0] || '';
    ret.sub = componentType[1] || '';
  }

  return ret;
}
/**
 * @public
 */


function checkClassType(componentType) {
  zrUtil.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
/**
 * @public
 */


function enableClassExtend(RootClass, mandatoryMethods) {
  RootClass.$constructor = RootClass;

  RootClass.extend = function (proto) {
    var superClass = this;

    var ExtendedClass = function () {
      if (!proto.$constructor) {
        superClass.apply(this, arguments);
      } else {
        proto.$constructor.apply(this, arguments);
      }
    };

    zrUtil.extend(ExtendedClass.prototype, proto);
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    zrUtil.inherits(ExtendedClass, this);
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
} // superCall should have class info, which can not be fetch from 'this'.
// Consider this case:
// class A has method f,
// class B inherits class A, overrides method f, f call superApply('f'),
// class C inherits class B, do not overrides method f,
// then when method of class C is called, dead loop occured.


function superCall(context, methodName) {
  var args = zrUtil.slice(arguments, 2);
  return this.superClass.prototype[methodName].apply(context, args);
}

function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
/**
 * @param {Object} entity
 * @param {Object} options
 * @param {boolean} [options.registerWhenExtend]
 * @public
 */


function enableClassManagement(entity, options) {
  options = options || {};
  /**
   * Component model classes
   * key: componentType,
   * value:
   *     componentClass, when componentType is 'xxx'
   *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
   * @type {Object}
   */

  var storage = {};

  entity.registerClass = function (Clazz, componentType) {
    if (componentType) {
      checkClassType(componentType);
      componentType = parseClassType(componentType);

      if (!componentType.sub) {
        storage[componentType.main] = Clazz;
      } else if (componentType.sub !== IS_CONTAINER) {
        var container = makeContainer(componentType);
        container[componentType.sub] = Clazz;
      }
    }

    return Clazz;
  };

  entity.getClass = function (componentMainType, subType, throwWhenNotFound) {
    var Clazz = storage[componentMainType];

    if (Clazz && Clazz[IS_CONTAINER]) {
      Clazz = subType ? Clazz[subType] : null;
    }

    if (throwWhenNotFound && !Clazz) {
      throw new Error(!subType ? componentMainType + '.' + 'type should be specified.' : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.');
    }

    return Clazz;
  };

  entity.getClassesByMainType = function (componentType) {
    componentType = parseClassType(componentType);
    var result = [];
    var obj = storage[componentType.main];

    if (obj && obj[IS_CONTAINER]) {
      zrUtil.each(obj, function (o, type) {
        type !== IS_CONTAINER && result.push(o);
      });
    } else {
      result.push(obj);
    }

    return result;
  };

  entity.hasClass = function (componentType) {
    // Just consider componentType.main.
    componentType = parseClassType(componentType);
    return !!storage[componentType.main];
  };
  /**
   * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
   */


  entity.getAllClassMainTypes = function () {
    var types = [];
    zrUtil.each(storage, function (obj, type) {
      types.push(type);
    });
    return types;
  };
  /**
   * If a main type is container and has sub types
   * @param  {string}  mainType
   * @return {boolean}
   */


  entity.hasSubTypes = function (componentType) {
    componentType = parseClassType(componentType);
    var obj = storage[componentType.main];
    return obj && obj[IS_CONTAINER];
  };

  entity.parseClassType = parseClassType;

  function makeContainer(componentType) {
    var container = storage[componentType.main];

    if (!container || !container[IS_CONTAINER]) {
      container = storage[componentType.main] = {};
      container[IS_CONTAINER] = true;
    }

    return container;
  }

  if (options.registerWhenExtend) {
    var originalExtend = entity.extend;

    if (originalExtend) {
      entity.extend = function (proto) {
        var ExtendedClass = originalExtend.call(this, proto);
        return entity.registerClass(ExtendedClass, proto.type);
      };
    }
  }

  return entity;
}
/**
 * @param {string|Array.<string>} properties
 */


function setReadOnly(obj, properties) {// FIXME It seems broken in IE8 simulation of IE11
  // if (!zrUtil.isArray(properties)) {
  //     properties = properties != null ? [properties] : [];
  // }
  // zrUtil.each(properties, function (prop) {
  //     var value = obj[prop];
  //     Object.defineProperty
  //         && Object.defineProperty(obj, prop, {
  //             value: value, writable: false
  //         });
  //     zrUtil.isArray(obj[prop])
  //         && Object.freeze
  //         && Object.freeze(obj[prop]);
  // });
}

exports.set = set;
exports.get = get;
exports.hasOwn = hasOwn;
exports.parseClassType = parseClassType;
exports.enableClassExtend = enableClassExtend;
exports.enableClassManagement = enableClassManagement;
exports.setReadOnly = setReadOnly;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Model = __webpack_require__(102);

var componentUtil = __webpack_require__(130);

var clazzUtil = __webpack_require__(104);

var layout = __webpack_require__(103);

var boxLayoutMixin = __webpack_require__(224);

/**
 * Component model
 *
 * @module echarts/model/Component
 */
var arrayPush = Array.prototype.push;
/**
 * @alias module:echarts/model/Component
 * @constructor
 * @param {Object} option
 * @param {module:echarts/model/Model} parentModel
 * @param {module:echarts/model/Model} ecModel
 */

var ComponentModel = Model.extend({
  type: 'component',

  /**
   * @readOnly
   * @type {string}
   */
  id: '',

  /**
   * @readOnly
   */
  name: '',

  /**
   * @readOnly
   * @type {string}
   */
  mainType: '',

  /**
   * @readOnly
   * @type {string}
   */
  subType: '',

  /**
   * @readOnly
   * @type {number}
   */
  componentIndex: 0,

  /**
   * @type {Object}
   * @protected
   */
  defaultOption: null,

  /**
   * @type {module:echarts/model/Global}
   * @readOnly
   */
  ecModel: null,

  /**
   * key: componentType
   * value:  Component model list, can not be null.
   * @type {Object.<string, Array.<module:echarts/model/Model>>}
   * @readOnly
   */
  dependentModels: [],

  /**
   * @type {string}
   * @readOnly
   */
  uid: null,

  /**
   * Support merge layout params.
   * Only support 'box' now (left/right/top/bottom/width/height).
   * @type {string|Object} Object can be {ignoreSize: true}
   * @readOnly
   */
  layoutMode: null,
  $constructor: function (option, parentModel, ecModel, extraOpt) {
    Model.call(this, option, parentModel, ecModel, extraOpt);
    this.uid = componentUtil.getUID('componentModel');
  },
  init: function (option, parentModel, ecModel, extraOpt) {
    this.mergeDefaultAndTheme(option, ecModel);
  },
  mergeDefaultAndTheme: function (option, ecModel) {
    var layoutMode = this.layoutMode;
    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
    var themeModel = ecModel.getTheme();
    zrUtil.merge(option, themeModel.get(this.mainType));
    zrUtil.merge(option, this.getDefaultOption());

    if (layoutMode) {
      layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  },
  mergeOption: function (option, extraOpt) {
    zrUtil.merge(this.option, option, true);
    var layoutMode = this.layoutMode;

    if (layoutMode) {
      layout.mergeLayoutParam(this.option, option, layoutMode);
    }
  },
  // Hooker after init or mergeOption
  optionUpdated: function (newCptOption, isInit) {},
  getDefaultOption: function () {
    if (!clazzUtil.hasOwn(this, '__defaultOption')) {
      var optList = [];
      var Class = this.constructor;

      while (Class) {
        var opt = Class.prototype.defaultOption;
        opt && optList.push(opt);
        Class = Class.superClass;
      }

      var defaultOption = {};

      for (var i = optList.length - 1; i >= 0; i--) {
        defaultOption = zrUtil.merge(defaultOption, optList[i], true);
      }

      clazzUtil.set(this, '__defaultOption', defaultOption);
    }

    return clazzUtil.get(this, '__defaultOption');
  },
  getReferringComponents: function (mainType) {
    return this.ecModel.queryComponents({
      mainType: mainType,
      index: this.get(mainType + 'Index', true),
      id: this.get(mainType + 'Id', true)
    });
  }
}); // Reset ComponentModel.extend, add preConstruct.
// clazzUtil.enableClassExtend(
//     ComponentModel,
//     function (option, parentModel, ecModel, extraOpt) {
//         // Set dependentModels, componentIndex, name, id, mainType, subType.
//         zrUtil.extend(this, extraOpt);
//         this.uid = componentUtil.getUID('componentModel');
//         // this.setReadOnly([
//         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',
//         //     'dependentModels', 'componentIndex'
//         // ]);
//     }
// );
// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

clazzUtil.enableClassManagement(ComponentModel, {
  registerWhenExtend: true
});
componentUtil.enableSubTypeDefaulter(ComponentModel); // Add capability of ComponentModel.topologicalTravel.

componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);

function getDependencies(componentType) {
  var deps = [];
  zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {
    arrayPush.apply(deps, Clazz.prototype.dependencies || []);
  }); // Ensure main type

  return zrUtil.map(deps, function (type) {
    return clazzUtil.parseClassType(type).main;
  });
}

zrUtil.mixin(ComponentModel, boxLayoutMixin);
var _default = ComponentModel;
module.exports = _default;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var Eventful = __webpack_require__(107);

exports.Dispatcher = Eventful;

var env = __webpack_require__(98);

/**
 * 事件辅助类
 * @module zrender/core/event
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */
var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;

function getBoundingClientRect(el) {
  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
  return el.getBoundingClientRect ? el.getBoundingClientRect() : {
    left: 0,
    top: 0
  };
} // `calculate` is optional, default false


function clientToLocal(el, e, out, calculate) {
  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
  // to the padding edge of the target element. The only browser using this convention
  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
  // not support the properties.
  // (see http://www.jacklmoore.com/notes/mouse-position/)
  // In zr painter.dom, padding edge equals to border edge.
  // FIXME
  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
  // is too complex. So css-transfrom dont support in this case temporarily.

  if (calculate || !env.canvasSupported) {
    defaultGetZrXY(el, e, out);
  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
  // ancestor element, so we should make sure el is positioned (e.g., not position:static).
  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
  // zoom-factor, overflow / opacity layers, transforms ...)
  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
  // <https://bugs.jquery.com/ticket/8523#comment:14>
  // BTW3, In ff, offsetX/offsetY is always 0.
  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
      out.zrX = e.layerX;
      out.zrY = e.layerY;
    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
    else if (e.offsetX != null) {
        out.zrX = e.offsetX;
        out.zrY = e.offsetY;
      } // For some other device, e.g., IOS safari.
      else {
          defaultGetZrXY(el, e, out);
        }

  return out;
}

function defaultGetZrXY(el, e, out) {
  // This well-known method below does not support css transform.
  var box = getBoundingClientRect(el);
  out.zrX = e.clientX - box.left;
  out.zrY = e.clientY - box.top;
}
/**
 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
 * `calculate` is optional, default false.
 */


function normalizeEvent(el, e, calculate) {
  e = e || window.event;

  if (e.zrX != null) {
    return e;
  }

  var eventType = e.type;
  var isTouch = eventType && eventType.indexOf('touch') >= 0;

  if (!isTouch) {
    clientToLocal(el, e, e, calculate);
    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
  } else {
    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
    touch && clientToLocal(el, touch, e, calculate);
  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
  // If e.which has been defined, if may be readonly,
  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which


  var button = e.button;

  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }

  return e;
}

function addEventListener(el, name, handler) {
  if (isDomLevel2) {
    el.addEventListener(name, handler);
  } else {
    el.attachEvent('on' + name, handler);
  }
}

function removeEventListener(el, name, handler) {
  if (isDomLevel2) {
    el.removeEventListener(name, handler);
  } else {
    el.detachEvent('on' + name, handler);
  }
}
/**
 * preventDefault and stopPropagation.
 * Notice: do not do that in zrender. Upper application
 * do that if necessary.
 *
 * @memberOf module:zrender/core/event
 * @method
 * @param {Event} e : event对象
 */


var stop = isDomLevel2 ? function (e) {
  e.preventDefault();
  e.stopPropagation();
  e.cancelBubble = true;
} : function (e) {
  e.returnValue = false;
  e.cancelBubble = true;
};

function notLeftMouse(e) {
  // If e.which is undefined, considered as left mouse event.
  return e.which > 1;
} // 做向上兼容


exports.clientToLocal = clientToLocal;
exports.normalizeEvent = normalizeEvent;
exports.addEventListener = addEventListener;
exports.removeEventListener = removeEventListener;
exports.stop = stop;
exports.notLeftMouse = notLeftMouse;

/***/ }),
/* 107 */
/***/ (function(module, exports) {

/**
 * 事件扩展
 * @module zrender/mixin/Eventful
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */
var arrySlice = Array.prototype.slice;
/**
 * 事件分发器
 * @alias module:zrender/mixin/Eventful
 * @constructor
 */

var Eventful = function () {
  this._$handlers = {};
};

Eventful.prototype = {
  constructor: Eventful,

  /**
   * 单次触发绑定，trigger后销毁
   *
   * @param {string} event 事件名
   * @param {Function} handler 响应函数
   * @param {Object} context
   */
  one: function (event, handler, context) {
    var _h = this._$handlers;

    if (!handler || !event) {
      return this;
    }

    if (!_h[event]) {
      _h[event] = [];
    }

    for (var i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }

    _h[event].push({
      h: handler,
      one: true,
      ctx: context || this
    });

    return this;
  },

  /**
   * 绑定事件
   * @param {string} event 事件名
   * @param {Function} handler 事件处理函数
   * @param {Object} [context]
   */
  on: function (event, handler, context) {
    var _h = this._$handlers;

    if (!handler || !event) {
      return this;
    }

    if (!_h[event]) {
      _h[event] = [];
    }

    for (var i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }

    _h[event].push({
      h: handler,
      one: false,
      ctx: context || this
    });

    return this;
  },

  /**
   * 是否绑定了事件
   * @param  {string}  event
   * @return {boolean}
   */
  isSilent: function (event) {
    var _h = this._$handlers;
    return _h[event] && _h[event].length;
  },

  /**
   * 解绑事件
   * @param {string} event 事件名
   * @param {Function} [handler] 事件处理函数
   */
  off: function (event, handler) {
    var _h = this._$handlers;

    if (!event) {
      this._$handlers = {};
      return this;
    }

    if (handler) {
      if (_h[event]) {
        var newList = [];

        for (var i = 0, l = _h[event].length; i < l; i++) {
          if (_h[event][i]['h'] != handler) {
            newList.push(_h[event][i]);
          }
        }

        _h[event] = newList;
      }

      if (_h[event] && _h[event].length === 0) {
        delete _h[event];
      }
    } else {
      delete _h[event];
    }

    return this;
  },

  /**
   * 事件分发
   *
   * @param {string} type 事件类型
   */
  trigger: function (type) {
    if (this._$handlers[type]) {
      var args = arguments;
      var argLen = args.length;

      if (argLen > 3) {
        args = arrySlice.call(args, 1);
      }

      var _h = this._$handlers[type];
      var len = _h.length;

      for (var i = 0; i < len;) {
        // Optimize advise from backbone
        switch (argLen) {
          case 1:
            _h[i]['h'].call(_h[i]['ctx']);

            break;

          case 2:
            _h[i]['h'].call(_h[i]['ctx'], args[1]);

            break;

          case 3:
            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);

            break;

          default:
            // have more than 2 given arguments
            _h[i]['h'].apply(_h[i]['ctx'], args);

            break;
        }

        if (_h[i]['one']) {
          _h.splice(i, 1);

          len--;
        } else {
          i++;
        }
      }
    }

    return this;
  },

  /**
   * 带有context的事件分发, 最后一个参数是事件回调的context
   * @param {string} type 事件类型
   */
  triggerWithContext: function (type) {
    if (this._$handlers[type]) {
      var args = arguments;
      var argLen = args.length;

      if (argLen > 4) {
        args = arrySlice.call(args, 1, args.length - 1);
      }

      var ctx = args[args.length - 1];
      var _h = this._$handlers[type];
      var len = _h.length;

      for (var i = 0; i < len;) {
        // Optimize advise from backbone
        switch (argLen) {
          case 1:
            _h[i]['h'].call(ctx);

            break;

          case 2:
            _h[i]['h'].call(ctx, args[1]);

            break;

          case 3:
            _h[i]['h'].call(ctx, args[1], args[2]);

            break;

          default:
            // have more than 2 given arguments
            _h[i]['h'].apply(ctx, args);

            break;
        }

        if (_h[i]['one']) {
          _h.splice(i, 1);

          len--;
        } else {
          i++;
        }
      }
    }

    return this;
  }
}; // 对象可以通过 onxxxx 绑定事件

/**
 * @event module:zrender/mixin/Eventful#onclick
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseover
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseout
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousemove
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousewheel
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousedown
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseup
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondrag
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragstart
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragend
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragenter
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragleave
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragover
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondrop
 * @type {Function}
 * @default null
 */

var _default = Eventful;
module.exports = _default;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var BoundingRect = __webpack_require__(101);

var imageHelper = __webpack_require__(128);

var _util = __webpack_require__(91);

var getContext = _util.getContext;
var extend = _util.extend;
var retrieve2 = _util.retrieve2;
var retrieve3 = _util.retrieve3;
var textWidthCache = {};
var textWidthCacheCounter = 0;
var TEXT_CACHE_MAX = 5000;
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.

var methods = {};

function $override(name, fn) {
  methods[name] = fn;
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {number} width
 */


function getWidth(text, font) {
  font = font || DEFAULT_FONT;
  var key = text + ':' + font;

  if (textWidthCache[key]) {
    return textWidthCache[key];
  }

  var textLines = (text + '').split('\n');
  var width = 0;

  for (var i = 0, l = textLines.length; i < l; i++) {
    // textContain.measureText may be overrided in SVG or VML
    width = Math.max(measureText(textLines[i], font).width, width);
  }

  if (textWidthCacheCounter > TEXT_CACHE_MAX) {
    textWidthCacheCounter = 0;
    textWidthCache = {};
  }

  textWidthCacheCounter++;
  textWidthCache[key] = width;
  return width;
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {string} [textAlign='left']
 * @param {string} [textVerticalAlign='top']
 * @param {Array.<number>} [textPadding]
 * @param {Object} [rich]
 * @param {Object} [truncate]
 * @return {Object} {x, y, width, height, lineHeight}
 */


function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
}

function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
  var contentBlock = parsePlainText(text, font, textPadding, truncate);
  var outerWidth = getWidth(text, font);

  if (textPadding) {
    outerWidth += textPadding[1] + textPadding[3];
  }

  var outerHeight = contentBlock.outerHeight;
  var x = adjustTextX(0, outerWidth, textAlign);
  var y = adjustTextY(0, outerHeight, textVerticalAlign);
  var rect = new BoundingRect(x, y, outerWidth, outerHeight);
  rect.lineHeight = contentBlock.lineHeight;
  return rect;
}

function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
  var contentBlock = parseRichText(text, {
    rich: rich,
    truncate: truncate,
    font: font,
    textAlign: textAlign,
    textPadding: textPadding
  });
  var outerWidth = contentBlock.outerWidth;
  var outerHeight = contentBlock.outerHeight;
  var x = adjustTextX(0, outerWidth, textAlign);
  var y = adjustTextY(0, outerHeight, textVerticalAlign);
  return new BoundingRect(x, y, outerWidth, outerHeight);
}
/**
 * @public
 * @param {number} x
 * @param {number} width
 * @param {string} [textAlign='left']
 * @return {number} Adjusted x.
 */


function adjustTextX(x, width, textAlign) {
  // FIXME Right to left language
  if (textAlign === 'right') {
    x -= width;
  } else if (textAlign === 'center') {
    x -= width / 2;
  }

  return x;
}
/**
 * @public
 * @param {number} y
 * @param {number} height
 * @param {string} [textVerticalAlign='top']
 * @return {number} Adjusted y.
 */


function adjustTextY(y, height, textVerticalAlign) {
  if (textVerticalAlign === 'middle') {
    y -= height / 2;
  } else if (textVerticalAlign === 'bottom') {
    y -= height;
  }

  return y;
}
/**
 * @public
 * @param {stirng} textPosition
 * @param {Object} rect {x, y, width, height}
 * @param {number} distance
 * @return {Object} {x, y, textAlign, textVerticalAlign}
 */


function adjustTextPositionOnRect(textPosition, rect, distance) {
  var x = rect.x;
  var y = rect.y;
  var height = rect.height;
  var width = rect.width;
  var halfHeight = height / 2;
  var textAlign = 'left';
  var textVerticalAlign = 'top';

  switch (textPosition) {
    case 'left':
      x -= distance;
      y += halfHeight;
      textAlign = 'right';
      textVerticalAlign = 'middle';
      break;

    case 'right':
      x += distance + width;
      y += halfHeight;
      textVerticalAlign = 'middle';
      break;

    case 'top':
      x += width / 2;
      y -= distance;
      textAlign = 'center';
      textVerticalAlign = 'bottom';
      break;

    case 'bottom':
      x += width / 2;
      y += height + distance;
      textAlign = 'center';
      break;

    case 'inside':
      x += width / 2;
      y += halfHeight;
      textAlign = 'center';
      textVerticalAlign = 'middle';
      break;

    case 'insideLeft':
      x += distance;
      y += halfHeight;
      textVerticalAlign = 'middle';
      break;

    case 'insideRight':
      x += width - distance;
      y += halfHeight;
      textAlign = 'right';
      textVerticalAlign = 'middle';
      break;

    case 'insideTop':
      x += width / 2;
      y += distance;
      textAlign = 'center';
      break;

    case 'insideBottom':
      x += width / 2;
      y += height - distance;
      textAlign = 'center';
      textVerticalAlign = 'bottom';
      break;

    case 'insideTopLeft':
      x += distance;
      y += distance;
      break;

    case 'insideTopRight':
      x += width - distance;
      y += distance;
      textAlign = 'right';
      break;

    case 'insideBottomLeft':
      x += distance;
      y += height - distance;
      textVerticalAlign = 'bottom';
      break;

    case 'insideBottomRight':
      x += width - distance;
      y += height - distance;
      textAlign = 'right';
      textVerticalAlign = 'bottom';
      break;
  }

  return {
    x: x,
    y: y,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}
/**
 * Show ellipsis if overflow.
 *
 * @public
 * @param  {string} text
 * @param  {string} containerWidth
 * @param  {string} font
 * @param  {number} [ellipsis='...']
 * @param  {Object} [options]
 * @param  {number} [options.maxIterations=3]
 * @param  {number} [options.minChar=0] If truncate result are less
 *                  then minChar, ellipsis will not show, which is
 *                  better for user hint in some cases.
 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
 * @return {string}
 */


function truncateText(text, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    return '';
  }

  var textLines = (text + '').split('\n');
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
  // It is not appropriate that every line has '...' when truncate multiple lines.

  for (var i = 0, len = textLines.length; i < len; i++) {
    textLines[i] = truncateSingleLine(textLines[i], options);
  }

  return textLines.join('\n');
}

function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = extend({}, options);
  options.font = font;
  var ellipsis = retrieve2(ellipsis, '...');
  options.maxIterations = retrieve2(options.maxIterations, 2);
  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME
  // Other languages?

  options.cnCharWidth = getWidth('国', font); // FIXME
  // Consider proportional font?

  var ascCharWidth = options.ascCharWidth = getWidth('a', font);
  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.

  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.

  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
    contentWidth -= ascCharWidth;
  }

  var ellipsisWidth = getWidth(ellipsis);

  if (ellipsisWidth > contentWidth) {
    ellipsis = '';
    ellipsisWidth = 0;
  }

  contentWidth = containerWidth - ellipsisWidth;
  options.ellipsis = ellipsis;
  options.ellipsisWidth = ellipsisWidth;
  options.contentWidth = contentWidth;
  options.containerWidth = containerWidth;
  return options;
}

function truncateSingleLine(textLine, options) {
  var containerWidth = options.containerWidth;
  var font = options.font;
  var contentWidth = options.contentWidth;

  if (!containerWidth) {
    return '';
  }

  var lineWidth = getWidth(textLine, font);

  if (lineWidth <= containerWidth) {
    return textLine;
  }

  for (var j = 0;; j++) {
    if (lineWidth <= contentWidth || j >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }

    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth(textLine, font);
  }

  if (textLine === '') {
    textLine = options.placeholder;
  }

  return textLine;
}

function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
  var width = 0;
  var i = 0;

  for (var len = text.length; i < len && width < contentWidth; i++) {
    var charCode = text.charCodeAt(i);
    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }

  return i;
}
/**
 * @public
 * @param {string} font
 * @return {number} line height
 */


function getLineHeight(font) {
  // FIXME A rough approach.
  return getWidth('国', font);
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {Object} width
 */


function measureText(text, font) {
  return methods.measureText(text, font);
} // Avoid assign to an exported variable, for transforming to cjs.


methods.measureText = function (text, font) {
  var ctx = getContext();
  ctx.font = font || DEFAULT_FONT;
  return ctx.measureText(text);
};
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {Object} [truncate]
 * @return {Object} block: {lineHeight, lines, height, outerHeight}
 *  Notice: for performance, do not calculate outerWidth util needed.
 */


function parsePlainText(text, font, padding, truncate) {
  text != null && (text += '');
  var lineHeight = getLineHeight(font);
  var lines = text ? text.split('\n') : [];
  var height = lines.length * lineHeight;
  var outerHeight = height;

  if (padding) {
    outerHeight += padding[0] + padding[2];
  }

  if (text && truncate) {
    var truncOuterHeight = truncate.outerHeight;
    var truncOuterWidth = truncate.outerWidth;

    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
      text = '';
      lines = [];
    } else if (truncOuterWidth != null) {
      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
        minChar: truncate.minChar,
        placeholder: truncate.placeholder
      }); // FIXME
      // It is not appropriate that every line has '...' when truncate multiple lines.

      for (var i = 0, len = lines.length; i < len; i++) {
        lines[i] = truncateSingleLine(lines[i], options);
      }
    }
  }

  return {
    lines: lines,
    height: height,
    outerHeight: outerHeight,
    lineHeight: lineHeight
  };
}
/**
 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
 *
 * @public
 * @param {string} text
 * @param {Object} style
 * @return {Object} block
 * {
 *      width,
 *      height,
 *      lines: [{
 *          lineHeight,
 *          width,
 *          tokens: [[{
 *              styleName,
 *              text,
 *              width,      // include textPadding
 *              height,     // include textPadding
 *              textWidth, // pure text width
 *              textHeight, // pure text height
 *              lineHeihgt,
 *              font,
 *              textAlign,
 *              textVerticalAlign
 *          }], [...], ...]
 *      }, ...]
 * }
 * If styleName is undefined, it is plain text.
 */


function parseRichText(text, style) {
  var contentBlock = {
    lines: [],
    width: 0,
    height: 0
  };
  text != null && (text += '');

  if (!text) {
    return contentBlock;
  }

  var lastIndex = STYLE_REG.lastIndex = 0;
  var result;

  while ((result = STYLE_REG.exec(text)) != null) {
    var matchedIndex = result.index;

    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
    }

    pushTokens(contentBlock, result[2], result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }

  if (lastIndex < text.length) {
    pushTokens(contentBlock, text.substring(lastIndex, text.length));
  }

  var lines = contentBlock.lines;
  var contentHeight = 0;
  var contentWidth = 0; // For `textWidth: 100%`

  var pendingList = [];
  var stlPadding = style.textPadding;
  var truncate = style.truncate;
  var truncateWidth = truncate && truncate.outerWidth;
  var truncateHeight = truncate && truncate.outerHeight;

  if (stlPadding) {
    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
  } // Calculate layout info of tokens.


  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var lineHeight = 0;
    var lineWidth = 0;

    for (var j = 0; j < line.tokens.length; j++) {
      var token = line.tokens[j];
      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.

      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.

      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.

      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified
      // as box height of the block.
      tokenStyle.textHeight, getLineHeight(font));
      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
      token.height = tokenHeight;
      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';

      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
        return {
          lines: [],
          width: 0,
          height: 0
        };
      }

      token.textWidth = getWidth(token.text, font);
      var tokenWidth = tokenStyle.textWidth;
      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
      // line when box width is needed to be auto.

      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
        token.percentWidth = tokenWidth;
        pendingList.push(token);
        tokenWidth = 0; // Do not truncate in this case, because there is no user case
        // and it is too complicated.
      } else {
        if (tokenWidthNotSpecified) {
          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
          // `getBoundingRect()` will not get correct result.

          var textBackgroundColor = tokenStyle.textBackgroundColor;
          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
          // (1) If image is not loaded, it will be loaded at render phase and call
          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
          // image, and then the right size will be calculated here at the next tick.
          // See `graphic/helper/text.js`.
          // (2) If image loaded, and `textBackgroundColor.image` is image src string,
          // use `imageHelper.findExistImage` to find cached image.
          // `imageHelper.findExistImage` will always be called here before
          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
          // which ensures that image will not be rendered before correct size calcualted.

          if (bgImg) {
            bgImg = imageHelper.findExistImage(bgImg);

            if (imageHelper.isImageReady(bgImg)) {
              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
            }
          }
        }

        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
        tokenWidth += paddingW;
        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;

        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
            token.text = '';
            token.textWidth = tokenWidth = 0;
          } else {
            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
              minChar: truncate.minChar
            });
            token.textWidth = getWidth(token.text, font);
            tokenWidth = token.textWidth + paddingW;
          }
        }
      }

      lineWidth += token.width = tokenWidth;
      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
    }

    line.width = lineWidth;
    line.lineHeight = lineHeight;
    contentHeight += lineHeight;
    contentWidth = Math.max(contentWidth, lineWidth);
  }

  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);

  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }

  for (var i = 0; i < pendingList.length; i++) {
    var token = pendingList[i];
    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.

    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
  }

  return contentBlock;
}

function pushTokens(block, str, styleName) {
  var isEmptyStr = str === '';
  var strs = str.split('\n');
  var lines = block.lines;

  for (var i = 0; i < strs.length; i++) {
    var text = strs[i];
    var token = {
      styleName: styleName,
      text: text,
      isLineHolder: !text && !isEmptyStr
    }; // The first token should be appended to the last line.

    if (!i) {
      var tokens = (lines[lines.length - 1] || (lines[0] = {
        tokens: []
      })).tokens; // Consider cases:
      // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
      // (which is a placeholder) should be replaced by new token.
      // (2) A image backage, where token likes {a|}.
      // (3) A redundant '' will affect textAlign in line.
      // (4) tokens with the same tplName should not be merged, because
      // they should be displayed in different box (with border and padding).

      var tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
      // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
      (text || !tokensLen || isEmptyStr) && tokens.push(token);
    } // Other tokens always start a new line.
    else {
        // If there is '', insert it as a placeholder.
        lines.push({
          tokens: [token]
        });
      }
  }
}

function makeFont(style) {
  // FIXME in node-canvas fontWeight is before fontStyle
  // Use `fontSize` `fontFamily` to check whether font properties are defined.
  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;
}

exports.DEFAULT_FONT = DEFAULT_FONT;
exports.$override = $override;
exports.getWidth = getWidth;
exports.getBoundingRect = getBoundingRect;
exports.adjustTextX = adjustTextX;
exports.adjustTextY = adjustTextY;
exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
exports.truncateText = truncateText;
exports.getLineHeight = getLineHeight;
exports.measureText = measureText;
exports.parsePlainText = parsePlainText;
exports.parseRichText = parseRichText;
exports.makeFont = makeFont;

/***/ }),
/* 109 */
/***/ (function(module, exports) {

var features = {};

function register(name, ctor) {
  features[name] = ctor;
}

function get(name) {
  return features[name];
}

exports.register = register;
exports.get = get;

/***/ }),
/* 110 */
/***/ (function(module, exports) {

/**
 * 3x2矩阵操作类
 * @exports zrender/tool/matrix
 */
var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
/**
 * 创建一个单位矩阵
 * @return {Float32Array|Array.<number>}
 */

function create() {
  var out = new ArrayCtor(6);
  identity(out);
  return out;
}
/**
 * 设置矩阵为单位矩阵
 * @param {Float32Array|Array.<number>} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * 复制矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m
 */


function copy(out, m) {
  out[0] = m[0];
  out[1] = m[1];
  out[2] = m[2];
  out[3] = m[3];
  out[4] = m[4];
  out[5] = m[5];
  return out;
}
/**
 * 矩阵相乘
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m1
 * @param {Float32Array|Array.<number>} m2
 */


function mul(out, m1, m2) {
  // Consider matrix.mul(m, m2, m);
  // where out is the same as m2.
  // So use temp variable to escape error.
  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
  var out2 = m1[0] * m2[2] + m1[2] * m2[3];
  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = out3;
  out[4] = out4;
  out[5] = out5;
  return out;
}
/**
 * 平移变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */


function translate(out, a, v) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4] + v[0];
  out[5] = a[5] + v[1];
  return out;
}
/**
 * 旋转变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {number} rad
 */


function rotate(out, a, rad) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var st = Math.sin(rad);
  var ct = Math.cos(rad);
  out[0] = aa * ct + ab * st;
  out[1] = -aa * st + ab * ct;
  out[2] = ac * ct + ad * st;
  out[3] = -ac * st + ct * ad;
  out[4] = ct * atx + st * aty;
  out[5] = ct * aty - st * atx;
  return out;
}
/**
 * 缩放变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */


function scale(out, a, v) {
  var vx = v[0];
  var vy = v[1];
  out[0] = a[0] * vx;
  out[1] = a[1] * vy;
  out[2] = a[2] * vx;
  out[3] = a[3] * vy;
  out[4] = a[4] * vx;
  out[5] = a[5] * vy;
  return out;
}
/**
 * 求逆矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 */


function invert(out, a) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

exports.create = create;
exports.identity = identity;
exports.copy = copy;
exports.mul = mul;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.invert = invert;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var _vector = __webpack_require__(97);

var v2Create = _vector.create;
var v2DistSquare = _vector.distSquare;

/**
 * 曲线辅助模块
 * @module zrender/core/curve
 * @author pissang(https://www.github.com/pissang)
 */
var mathPow = Math.pow;
var mathSqrt = Math.sqrt;
var EPSILON = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt(3);
var ONE_THIRD = 1 / 3; // 临时变量

var _v0 = v2Create();

var _v1 = v2Create();

var _v2 = v2Create();

function isAroundZero(val) {
  return val > -EPSILON && val < EPSILON;
}

function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
/**
 * 计算三次贝塞尔值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */


function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
/**
 * 计算三次贝塞尔导数值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */


function cubicDerivativeAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}
/**
 * 计算三次贝塞尔方程根，使用盛金公式
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} val
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */


function cubicRootAt(p0, p1, p2, p3, val, roots) {
  // Evaluate roots of cubic functions
  var a = p3 + 3 * (p1 - p2) - p0;
  var b = 3 * (p2 - p1 * 2 + p0);
  var c = 3 * (p1 - p0);
  var d = p0 - val;
  var A = b * b - 3 * a * c;
  var B = b * c - 9 * a * d;
  var C = c * c - 3 * b * d;
  var n = 0;

  if (isAroundZero(A) && isAroundZero(B)) {
    if (isAroundZero(b)) {
      roots[0] = 0;
    } else {
      var t1 = -c / b; //t1, t2, t3, b is not zero

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    }
  } else {
    var disc = B * B - 4 * A * C;

    if (isAroundZero(disc)) {
      var K = B / A;
      var t1 = -b / a + K; // t1, a is not zero

      var t2 = -K / 2; // t2, t3

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
      var Y2 = A * b + 1.5 * a * (-B - discSqrt);

      if (Y1 < 0) {
        Y1 = -mathPow(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow(Y1, ONE_THIRD);
      }

      if (Y2 < 0) {
        Y2 = -mathPow(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow(Y2, ONE_THIRD);
      }

      var t1 = (-b - (Y1 + Y2)) / (3 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    } else {
      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
      var theta = Math.acos(T) / 3;
      var ASqrt = mathSqrt(A);
      var tmp = Math.cos(theta);
      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }

      if (t3 >= 0 && t3 <= 1) {
        roots[n++] = t3;
      }
    }
  }

  return n;
}
/**
 * 计算三次贝塞尔方程极限值的位置
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {Array.<number>} extrema
 * @return {number} 有效数目
 */


function cubicExtrema(p0, p1, p2, p3, extrema) {
  var b = 6 * p2 - 12 * p1 + 6 * p0;
  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
  var c = 3 * p1 - 3 * p0;
  var n = 0;

  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      var t1 = -c / b;

      if (t1 >= 0 && t1 <= 1) {
        extrema[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;

    if (isAroundZero(disc)) {
      extrema[0] = -b / (2 * a);
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        extrema[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        extrema[n++] = t2;
      }
    }
  }

  return n;
}
/**
 * 细分三次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {Array.<number>} out
 */


function cubicSubdivide(p0, p1, p2, p3, t, out) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p23 = (p3 - p2) * t + p2;
  var p012 = (p12 - p01) * t + p01;
  var p123 = (p23 - p12) * t + p12;
  var p0123 = (p123 - p012) * t + p012; // Seg0

  out[0] = p0;
  out[1] = p01;
  out[2] = p012;
  out[3] = p0123; // Seg1

  out[4] = p0123;
  out[5] = p123;
  out[6] = p23;
  out[7] = p3;
}
/**
 * 投射点到三次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} [out] 投射点
 * @return {number}
 */


function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
  // http://pomax.github.io/bezierinfo/#projections
  var t;
  var interval = 0.005;
  var d = Infinity;
  var prev;
  var next;
  var d1;
  var d2;
  _v0[0] = x;
  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
  // PENDING

  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
    d1 = v2DistSquare(_v0, _v1);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }

  d = Infinity; // At most 32 iteration

  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }

    prev = t - interval;
    next = t + interval; // t - interval

    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
    d1 = v2DistSquare(_v1, _v0);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      // t + interval
      _v2[0] = cubicAt(x0, x1, x2, x3, next);
      _v2[1] = cubicAt(y0, y1, y2, y3, next);
      d2 = v2DistSquare(_v2, _v0);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  } // t


  if (out) {
    out[0] = cubicAt(x0, x1, x2, x3, t);
    out[1] = cubicAt(y0, y1, y2, y3, t);
  } // console.log(interval, i);


  return mathSqrt(d);
}
/**
 * 计算二次方贝塞尔值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */


function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
/**
 * 计算二次方贝塞尔导数值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */


function quadraticDerivativeAt(p0, p1, p2, t) {
  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}
/**
 * 计算二次方贝塞尔方程根
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */


function quadraticRootAt(p0, p1, p2, val, roots) {
  var a = p0 - 2 * p1 + p2;
  var b = 2 * (p1 - p0);
  var c = p0 - val;
  var n = 0;

  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      var t1 = -c / b;

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;

    if (isAroundZero(disc)) {
      var t1 = -b / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }
    }
  }

  return n;
}
/**
 * 计算二次贝塞尔方程极限值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @return {number}
 */


function quadraticExtremum(p0, p1, p2) {
  var divider = p0 + p2 - 2 * p1;

  if (divider === 0) {
    // p1 is center of p0 and p2
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
/**
 * 细分二次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} out
 */


function quadraticSubdivide(p0, p1, p2, t, out) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p012 = (p12 - p01) * t + p01; // Seg0

  out[0] = p0;
  out[1] = p01;
  out[2] = p012; // Seg1

  out[3] = p012;
  out[4] = p12;
  out[5] = p2;
}
/**
 * 投射点到二次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} out 投射点
 * @return {number}
 */


function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
  // http://pomax.github.io/bezierinfo/#projections
  var t;
  var interval = 0.005;
  var d = Infinity;
  _v0[0] = x;
  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
  // PENDING

  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t);
    _v1[1] = quadraticAt(y0, y1, y2, _t);
    var d1 = v2DistSquare(_v0, _v1);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }

  d = Infinity; // At most 32 iteration

  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }

    var prev = t - interval;
    var next = t + interval; // t - interval

    _v1[0] = quadraticAt(x0, x1, x2, prev);
    _v1[1] = quadraticAt(y0, y1, y2, prev);
    var d1 = v2DistSquare(_v1, _v0);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      // t + interval
      _v2[0] = quadraticAt(x0, x1, x2, next);
      _v2[1] = quadraticAt(y0, y1, y2, next);
      var d2 = v2DistSquare(_v2, _v0);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  } // t


  if (out) {
    out[0] = quadraticAt(x0, x1, x2, t);
    out[1] = quadraticAt(y0, y1, y2, t);
  } // console.log(interval, i);


  return mathSqrt(d);
}

exports.cubicAt = cubicAt;
exports.cubicDerivativeAt = cubicDerivativeAt;
exports.cubicRootAt = cubicRootAt;
exports.cubicExtrema = cubicExtrema;
exports.cubicSubdivide = cubicSubdivide;
exports.cubicProjectPoint = cubicProjectPoint;
exports.quadraticAt = quadraticAt;
exports.quadraticDerivativeAt = quadraticDerivativeAt;
exports.quadraticRootAt = quadraticRootAt;
exports.quadraticExtremum = quadraticExtremum;
exports.quadraticSubdivide = quadraticSubdivide;
exports.quadraticProjectPoint = quadraticProjectPoint;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__(91);

var textContain = __webpack_require__(108);

var OrdinalScale = __webpack_require__(234);

var IntervalScale = __webpack_require__(135);

var Scale = __webpack_require__(124);

var numberUtil = __webpack_require__(94);

__webpack_require__(235);

__webpack_require__(236);

/**
 * Get axis scale extent before niced.
 * Item of returned array can only be number (including Infinity and NaN).
 */
function getScaleExtent(scale, model) {
  var scaleType = scale.type;
  var min = model.getMin();
  var max = model.getMax();
  var fixMin = min != null;
  var fixMax = max != null;
  var originalExtent = scale.getExtent();
  var axisDataLen;
  var boundaryGap;
  var span;

  if (scaleType === 'ordinal') {
    axisDataLen = (model.get('data') || []).length;
  } else {
    boundaryGap = model.get('boundaryGap');

    if (!zrUtil.isArray(boundaryGap)) {
      boundaryGap = [boundaryGap || 0, boundaryGap || 0];
    }

    if (typeof boundaryGap[0] === 'boolean') {
      boundaryGap = [0, 0];
    }

    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);
    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);
    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);
  } // Notice: When min/max is not set (that is, when there are null/undefined,
  // which is the most common case), these cases should be ensured:
  // (1) For 'ordinal', show all axis.data.
  // (2) For others:
  //      + `boundaryGap` is applied (if min/max set, boundaryGap is
  //      disabled).
  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should
  //      be the result that originalExtent enlarged by boundaryGap.
  // (3) If no data, it should be ensured that `scale.setBlank` is set.
  // FIXME
  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?
  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured
  // that the results processed by boundaryGap are positive/negative?


  if (min == null) {
    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;
  }

  if (max == null) {
    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;
  }

  if (min === 'dataMin') {
    min = originalExtent[0];
  } else if (typeof min === 'function') {
    min = min({
      min: originalExtent[0],
      max: originalExtent[1]
    });
  }

  if (max === 'dataMax') {
    max = originalExtent[1];
  } else if (typeof max === 'function') {
    max = max({
      min: originalExtent[0],
      max: originalExtent[1]
    });
  }

  (min == null || !isFinite(min)) && (min = NaN);
  (max == null || !isFinite(max)) && (max = NaN);
  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max)); // Evaluate if axis needs cross zero

  if (model.getNeedCrossZero()) {
    // Axis is over zero and min is not set
    if (min > 0 && max > 0 && !fixMin) {
      min = 0;
    } // Axis is under zero and max is not set


    if (min < 0 && max < 0 && !fixMax) {
      max = 0;
    }
  }

  return [min, max];
}

function niceScaleExtent(scale, model) {
  var extent = getScaleExtent(scale, model);
  var fixMin = model.getMin() != null;
  var fixMax = model.getMax() != null;
  var splitNumber = model.get('splitNumber');

  if (scale.type === 'log') {
    scale.base = model.get('logBase');
  }

  var scaleType = scale.type;
  scale.setExtent(extent[0], extent[1]);
  scale.niceExtent({
    splitNumber: splitNumber,
    fixMin: fixMin,
    fixMax: fixMax,
    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,
    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null
  }); // If some one specified the min, max. And the default calculated interval
  // is not good enough. He can specify the interval. It is often appeared
  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
  // to be 60.
  // FIXME

  var interval = model.get('interval');

  if (interval != null) {
    scale.setInterval && scale.setInterval(interval);
  }
}
/**
 * @param {module:echarts/model/Model} model
 * @param {string} [axisType] Default retrieve from model.type
 * @return {module:echarts/scale/*}
 */


function createScaleByModel(model, axisType) {
  axisType = axisType || model.get('type');

  if (axisType) {
    switch (axisType) {
      // Buildin scale
      case 'category':
        return new OrdinalScale(model.getCategories(), [Infinity, -Infinity]);

      case 'value':
        return new IntervalScale();
      // Extended scale, like time and log

      default:
        return (Scale.getClass(axisType) || IntervalScale).create(model);
    }
  }
}
/**
 * Check if the axis corss 0
 */


function ifAxisCrossZero(axis) {
  var dataExtent = axis.scale.getExtent();
  var min = dataExtent[0];
  var max = dataExtent[1];
  return !(min > 0 && max > 0 || min < 0 && max < 0);
}
/**
 * @param {Array.<number>} tickCoords In axis self coordinate.
 * @param {Array.<string>} labels
 * @param {string} font
 * @param {number} axisRotate 0: towards right horizontally, clock-wise is negative.
 * @param {number} [labelRotate=0] 0: towards right horizontally, clock-wise is negative.
 * @return {number}
 */


function getAxisLabelInterval(tickCoords, labels, font, axisRotate, labelRotate) {
  var textSpaceTakenRect;
  var autoLabelInterval = 0;
  var accumulatedLabelInterval = 0;
  var rotation = (axisRotate - labelRotate) / 180 * Math.PI;
  var step = 1;

  if (labels.length > 40) {
    // Simple optimization for large amount of labels
    step = Math.floor(labels.length / 40);
  }

  for (var i = 0; i < tickCoords.length; i += step) {
    var tickCoord = tickCoords[i]; // Not precise, do not consider align and vertical align
    // and each distance from axis line yet.

    var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');
    rect.x += tickCoord * Math.cos(rotation);
    rect.y += tickCoord * Math.sin(rotation); // Magic number

    rect.width *= 1.3;
    rect.height *= 1.3;

    if (!textSpaceTakenRect) {
      textSpaceTakenRect = rect.clone();
    } // There is no space for current label;
    else if (textSpaceTakenRect.intersect(rect)) {
        accumulatedLabelInterval++;
        autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);
      } else {
        textSpaceTakenRect.union(rect); // Reset

        accumulatedLabelInterval = 0;
      }
  }

  if (autoLabelInterval === 0 && step > 1) {
    return step;
  }

  return (autoLabelInterval + 1) * step - 1;
}
/**
 * @param {Object} axis
 * @param {Function} labelFormatter
 * @return {Array.<string>}
 */


function getFormattedLabels(axis, labelFormatter) {
  var scale = axis.scale;
  var labels = scale.getTicksLabels();
  var ticks = scale.getTicks();

  if (typeof labelFormatter === 'string') {
    labelFormatter = function (tpl) {
      return function (val) {
        return tpl.replace('{value}', val != null ? val : '');
      };
    }(labelFormatter); // Consider empty array


    return zrUtil.map(labels, labelFormatter);
  } else if (typeof labelFormatter === 'function') {
    return zrUtil.map(ticks, function (tick, idx) {
      return labelFormatter(getAxisRawValue(axis, tick), idx);
    }, this);
  } else {
    return labels;
  }
}

function getAxisRawValue(axis, value) {
  // In category axis with data zoom, tick is not the original
  // index of axis.data. So tick should not be exposed to user
  // in category axis.
  return axis.type === 'category' ? axis.scale.getLabel(value) : value;
}

exports.getScaleExtent = getScaleExtent;
exports.niceScaleExtent = niceScaleExtent;
exports.createScaleByModel = createScaleByModel;
exports.ifAxisCrossZero = ifAxisCrossZero;
exports.getAxisLabelInterval = getAxisLabelInterval;
exports.getFormattedLabels = getFormattedLabels;
exports.getAxisRawValue = getAxisRawValue;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var LRU = __webpack_require__(143);

var kCSSColorTable = {
  'transparent': [0, 0, 0, 0],
  'aliceblue': [240, 248, 255, 1],
  'antiquewhite': [250, 235, 215, 1],
  'aqua': [0, 255, 255, 1],
  'aquamarine': [127, 255, 212, 1],
  'azure': [240, 255, 255, 1],
  'beige': [245, 245, 220, 1],
  'bisque': [255, 228, 196, 1],
  'black': [0, 0, 0, 1],
  'blanchedalmond': [255, 235, 205, 1],
  'blue': [0, 0, 255, 1],
  'blueviolet': [138, 43, 226, 1],
  'brown': [165, 42, 42, 1],
  'burlywood': [222, 184, 135, 1],
  'cadetblue': [95, 158, 160, 1],
  'chartreuse': [127, 255, 0, 1],
  'chocolate': [210, 105, 30, 1],
  'coral': [255, 127, 80, 1],
  'cornflowerblue': [100, 149, 237, 1],
  'cornsilk': [255, 248, 220, 1],
  'crimson': [220, 20, 60, 1],
  'cyan': [0, 255, 255, 1],
  'darkblue': [0, 0, 139, 1],
  'darkcyan': [0, 139, 139, 1],
  'darkgoldenrod': [184, 134, 11, 1],
  'darkgray': [169, 169, 169, 1],
  'darkgreen': [0, 100, 0, 1],
  'darkgrey': [169, 169, 169, 1],
  'darkkhaki': [189, 183, 107, 1],
  'darkmagenta': [139, 0, 139, 1],
  'darkolivegreen': [85, 107, 47, 1],
  'darkorange': [255, 140, 0, 1],
  'darkorchid': [153, 50, 204, 1],
  'darkred': [139, 0, 0, 1],
  'darksalmon': [233, 150, 122, 1],
  'darkseagreen': [143, 188, 143, 1],
  'darkslateblue': [72, 61, 139, 1],
  'darkslategray': [47, 79, 79, 1],
  'darkslategrey': [47, 79, 79, 1],
  'darkturquoise': [0, 206, 209, 1],
  'darkviolet': [148, 0, 211, 1],
  'deeppink': [255, 20, 147, 1],
  'deepskyblue': [0, 191, 255, 1],
  'dimgray': [105, 105, 105, 1],
  'dimgrey': [105, 105, 105, 1],
  'dodgerblue': [30, 144, 255, 1],
  'firebrick': [178, 34, 34, 1],
  'floralwhite': [255, 250, 240, 1],
  'forestgreen': [34, 139, 34, 1],
  'fuchsia': [255, 0, 255, 1],
  'gainsboro': [220, 220, 220, 1],
  'ghostwhite': [248, 248, 255, 1],
  'gold': [255, 215, 0, 1],
  'goldenrod': [218, 165, 32, 1],
  'gray': [128, 128, 128, 1],
  'green': [0, 128, 0, 1],
  'greenyellow': [173, 255, 47, 1],
  'grey': [128, 128, 128, 1],
  'honeydew': [240, 255, 240, 1],
  'hotpink': [255, 105, 180, 1],
  'indianred': [205, 92, 92, 1],
  'indigo': [75, 0, 130, 1],
  'ivory': [255, 255, 240, 1],
  'khaki': [240, 230, 140, 1],
  'lavender': [230, 230, 250, 1],
  'lavenderblush': [255, 240, 245, 1],
  'lawngreen': [124, 252, 0, 1],
  'lemonchiffon': [255, 250, 205, 1],
  'lightblue': [173, 216, 230, 1],
  'lightcoral': [240, 128, 128, 1],
  'lightcyan': [224, 255, 255, 1],
  'lightgoldenrodyellow': [250, 250, 210, 1],
  'lightgray': [211, 211, 211, 1],
  'lightgreen': [144, 238, 144, 1],
  'lightgrey': [211, 211, 211, 1],
  'lightpink': [255, 182, 193, 1],
  'lightsalmon': [255, 160, 122, 1],
  'lightseagreen': [32, 178, 170, 1],
  'lightskyblue': [135, 206, 250, 1],
  'lightslategray': [119, 136, 153, 1],
  'lightslategrey': [119, 136, 153, 1],
  'lightsteelblue': [176, 196, 222, 1],
  'lightyellow': [255, 255, 224, 1],
  'lime': [0, 255, 0, 1],
  'limegreen': [50, 205, 50, 1],
  'linen': [250, 240, 230, 1],
  'magenta': [255, 0, 255, 1],
  'maroon': [128, 0, 0, 1],
  'mediumaquamarine': [102, 205, 170, 1],
  'mediumblue': [0, 0, 205, 1],
  'mediumorchid': [186, 85, 211, 1],
  'mediumpurple': [147, 112, 219, 1],
  'mediumseagreen': [60, 179, 113, 1],
  'mediumslateblue': [123, 104, 238, 1],
  'mediumspringgreen': [0, 250, 154, 1],
  'mediumturquoise': [72, 209, 204, 1],
  'mediumvioletred': [199, 21, 133, 1],
  'midnightblue': [25, 25, 112, 1],
  'mintcream': [245, 255, 250, 1],
  'mistyrose': [255, 228, 225, 1],
  'moccasin': [255, 228, 181, 1],
  'navajowhite': [255, 222, 173, 1],
  'navy': [0, 0, 128, 1],
  'oldlace': [253, 245, 230, 1],
  'olive': [128, 128, 0, 1],
  'olivedrab': [107, 142, 35, 1],
  'orange': [255, 165, 0, 1],
  'orangered': [255, 69, 0, 1],
  'orchid': [218, 112, 214, 1],
  'palegoldenrod': [238, 232, 170, 1],
  'palegreen': [152, 251, 152, 1],
  'paleturquoise': [175, 238, 238, 1],
  'palevioletred': [219, 112, 147, 1],
  'papayawhip': [255, 239, 213, 1],
  'peachpuff': [255, 218, 185, 1],
  'peru': [205, 133, 63, 1],
  'pink': [255, 192, 203, 1],
  'plum': [221, 160, 221, 1],
  'powderblue': [176, 224, 230, 1],
  'purple': [128, 0, 128, 1],
  'red': [255, 0, 0, 1],
  'rosybrown': [188, 143, 143, 1],
  'royalblue': [65, 105, 225, 1],
  'saddlebrown': [139, 69, 19, 1],
  'salmon': [250, 128, 114, 1],
  'sandybrown': [244, 164, 96, 1],
  'seagreen': [46, 139, 87, 1],
  'seashell': [255, 245, 238, 1],
  'sienna': [160, 82, 45, 1],
  'silver': [192, 192, 192, 1],
  'skyblue': [135, 206, 235, 1],
  'slateblue': [106, 90, 205, 1],
  'slategray': [112, 128, 144, 1],
  'slategrey': [112, 128, 144, 1],
  'snow': [255, 250, 250, 1],
  'springgreen': [0, 255, 127, 1],
  'steelblue': [70, 130, 180, 1],
  'tan': [210, 180, 140, 1],
  'teal': [0, 128, 128, 1],
  'thistle': [216, 191, 216, 1],
  'tomato': [255, 99, 71, 1],
  'turquoise': [64, 224, 208, 1],
  'violet': [238, 130, 238, 1],
  'wheat': [245, 222, 179, 1],
  'white': [255, 255, 255, 1],
  'whitesmoke': [245, 245, 245, 1],
  'yellow': [255, 255, 0, 1],
  'yellowgreen': [154, 205, 50, 1]
};

function clampCssByte(i) {
  // Clamp to integer 0 .. 255.
  i = Math.round(i); // Seems to be what Chrome does (vs truncation).

  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clampCssAngle(i) {
  // Clamp to integer 0 .. 360.
  i = Math.round(i); // Seems to be what Chrome does (vs truncation).

  return i < 0 ? 0 : i > 360 ? 360 : i;
}

function clampCssFloat(f) {
  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parseCssInt(str) {
  // int or percentage.
  if (str.length && str.charAt(str.length - 1) === '%') {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }

  return clampCssByte(parseInt(str, 10));
}

function parseCssFloat(str) {
  // float or percentage.
  if (str.length && str.charAt(str.length - 1) === '%') {
    return clampCssFloat(parseFloat(str) / 100);
  }

  return clampCssFloat(parseFloat(str));
}

function cssHueToRgb(m1, m2, h) {
  if (h < 0) {
    h += 1;
  } else if (h > 1) {
    h -= 1;
  }

  if (h * 6 < 1) {
    return m1 + (m2 - m1) * h * 6;
  }

  if (h * 2 < 1) {
    return m2;
  }

  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }

  return m1;
}

function lerpNumber(a, b, p) {
  return a + (b - a) * p;
}

function setRgba(out, r, g, b, a) {
  out[0] = r;
  out[1] = g;
  out[2] = b;
  out[3] = a;
  return out;
}

function copyRgba(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

var colorCache = new LRU(20);
var lastRemovedArr = null;

function putToCache(colorStr, rgbaArr) {
  // Reuse removed array
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }

  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
/**
 * @param {string} colorStr
 * @param {Array.<number>} out
 * @return {Array.<number>}
 * @memberOf module:zrender/util/color
 */


function parse(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }

  rgbaArr = rgbaArr || [];
  var cached = colorCache.get(colorStr);

  if (cached) {
    return copyRgba(rgbaArr, cached);
  } // colorStr may be not string


  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.

  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  } // #abc and #abc123 syntax.


  if (str.charAt(0) === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

      if (!(iv >= 0 && iv <= 0xfff)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return; // Covers NaN.
      }

      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

      if (!(iv >= 0 && iv <= 0xffffff)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return; // Covers NaN.
      }

      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }

    return;
  }

  var op = str.indexOf('('),
      ep = str.indexOf(')');

  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op + 1, ep - (op + 1)).split(',');
    var alpha = 1; // To allow case fallthrough.

    switch (fname) {
      case 'rgba':
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        alpha = parseCssFloat(params.pop());
      // jshint ignore:line
      // Fall through.

      case 'rgb':
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      case 'hsla':
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      case 'hsl':
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      default:
        return;
    }
  }

  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
/**
 * @param {Array.<number>} hsla
 * @param {Array.<number>} rgba
 * @return {Array.<number>} rgba
 */


function hsla2rgba(hsla, rgba) {
  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
  // NOTE(deanm): According to the CSS spec s/l should only be
  // percentages, but we don't bother and let float or percentage.

  var s = parseCssFloat(hsla[1]);
  var l = parseCssFloat(hsla[2]);
  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  var m1 = l * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);

  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }

  return rgba;
}
/**
 * @param {Array.<number>} rgba
 * @return {Array.<number>} hsla
 */


function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  } // RGB from 0 to 255


  var R = rgba[0] / 255;
  var G = rgba[1] / 255;
  var B = rgba[2] / 255;
  var vMin = Math.min(R, G, B); // Min. value of RGB

  var vMax = Math.max(R, G, B); // Max. value of RGB

  var delta = vMax - vMin; // Delta RGB value

  var L = (vMax + vMin) / 2;
  var H;
  var S; // HSL results from 0 to 1

  if (delta === 0) {
    H = 0;
    S = 0;
  } else {
    if (L < 0.5) {
      S = delta / (vMax + vMin);
    } else {
      S = delta / (2 - vMax - vMin);
    }

    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;

    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }

    if (H < 0) {
      H += 1;
    }

    if (H > 1) {
      H -= 1;
    }
  }

  var hsla = [H * 360, S, L];

  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }

  return hsla;
}
/**
 * @param {string} color
 * @param {number} level
 * @return {string}
 * @memberOf module:zrender/util/color
 */


function lift(color, level) {
  var colorArr = parse(color);

  if (colorArr) {
    for (var i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }
    }

    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
  }
}
/**
 * @param {string} color
 * @return {string}
 * @memberOf module:zrender/util/color
 */


function toHex(color) {
  var colorArr = parse(color);

  if (colorArr) {
    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
  }
}
/**
 * Map value to color. Faster than lerp methods because color is represented by rgba array.
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<Array.<number>>} colors List of rgba color array
 * @param {Array.<number>} [out] Mapped gba color array
 * @return {Array.<number>} will be null/undefined if input illegal.
 */


function fastLerp(normalizedValue, colors, out) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }

  out = out || [];
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colors[leftIndex];
  var rightColor = colors[rightIndex];
  var dv = value - leftIndex;
  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out;
}
/**
 * @deprecated
 */


var fastMapToColor = fastLerp;
/**
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<string>} colors Color list.
 * @param {boolean=} fullOutput Default false.
 * @return {(string|Object)} Result color. If fullOutput,
 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
 * @memberOf module:zrender/util/color
 */

function lerp(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }

  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = parse(colors[leftIndex]);
  var rightColor = parse(colors[rightIndex]);
  var dv = value - leftIndex;
  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
  return fullOutput ? {
    color: color,
    leftIndex: leftIndex,
    rightIndex: rightIndex,
    value: value
  } : color;
}
/**
 * @deprecated
 */


var mapToColor = lerp;
/**
 * @param {string} color
 * @param {number=} h 0 ~ 360, ignore when null.
 * @param {number=} s 0 ~ 1, ignore when null.
 * @param {number=} l 0 ~ 1, ignore when null.
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */

function modifyHSL(color, h, s, l) {
  color = parse(color);

  if (color) {
    color = rgba2hsla(color);
    h != null && (color[0] = clampCssAngle(h));
    s != null && (color[1] = parseCssFloat(s));
    l != null && (color[2] = parseCssFloat(l));
    return stringify(hsla2rgba(color), 'rgba');
  }
}
/**
 * @param {string} color
 * @param {number=} alpha 0 ~ 1
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */


function modifyAlpha(color, alpha) {
  color = parse(color);

  if (color && alpha != null) {
    color[3] = clampCssFloat(alpha);
    return stringify(color, 'rgba');
  }
}
/**
 * @param {Array.<number>} arrColor like [12,33,44,0.4]
 * @param {string} type 'rgba', 'hsva', ...
 * @return {string} Result color. (If input illegal, return undefined).
 */


function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }

  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];

  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
    colorStr += ',' + arrColor[3];
  }

  return type + '(' + colorStr + ')';
}

exports.parse = parse;
exports.lift = lift;
exports.toHex = toHex;
exports.fastLerp = fastLerp;
exports.fastMapToColor = fastMapToColor;
exports.lerp = lerp;
exports.mapToColor = mapToColor;
exports.modifyHSL = modifyHSL;
exports.modifyAlpha = modifyAlpha;
exports.stringify = stringify;

/***/ }),
/* 114 */
/***/ (function(module, exports) {

var ORIGIN_METHOD = '\0__throttleOriginMethod';
var RATE = '\0__throttleRate';
var THROTTLE_TYPE = '\0__throttleType';
/**
 * @public
 * @param {(Function)} fn
 * @param {number} [delay=0] Unit: ms.
 * @param {boolean} [debounce=false]
 *        true: If call interval less than `delay`, only the last call works.
 *        false: If call interval less than `delay, call works on fixed rate.
 * @return {(Function)} throttled fn.
 */

function throttle(fn, delay, debounce) {
  var currCall;
  var lastCall = 0;
  var lastExec = 0;
  var timer = null;
  var diff;
  var scope;
  var args;
  var debounceNextCall;
  delay = delay || 0;

  function exec() {
    lastExec = new Date().getTime();
    timer = null;
    fn.apply(scope, args || []);
  }

  var cb = function () {
    currCall = new Date().getTime();
    scope = this;
    args = arguments;
    var thisDelay = debounceNextCall || delay;
    var thisDebounce = debounceNextCall || debounce;
    debounceNextCall = null;
    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer);

    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff);
      }
    }

    lastCall = currCall;
  };
  /**
   * Clear throttle.
   * @public
   */


  cb.clear = function () {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  /**
   * Enable debounce once.
   */


  cb.debounceNextCall = function (debounceDelay) {
    debounceNextCall = debounceDelay;
  };

  return cb;
}
/**
 * Create throttle method or update throttle rate.
 *
 * @example
 * ComponentView.prototype.render = function () {
 *     ...
 *     throttle.createOrUpdate(
 *         this,
 *         '_dispatchAction',
 *         this.model.get('throttle'),
 *         'fixRate'
 *     );
 * };
 * ComponentView.prototype.remove = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 * ComponentView.prototype.dispose = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 *
 * @public
 * @param {Object} obj
 * @param {string} fnAttr
 * @param {number} [rate]
 * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'
 * @return {Function} throttled function.
 */


function createOrUpdate(obj, fnAttr, rate, throttleType) {
  var fn = obj[fnAttr];

  if (!fn) {
    return;
  }

  var originFn = fn[ORIGIN_METHOD] || fn;
  var lastThrottleType = fn[THROTTLE_TYPE];
  var lastRate = fn[RATE];

  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }

    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');
    fn[ORIGIN_METHOD] = originFn;
    fn[THROTTLE_TYPE] = throttleType;
    fn[RATE] = rate;
  }

  return fn;
}
/**
 * Clear throttle. Example see throttle.createOrUpdate.
 *
 * @public
 * @param {Object} obj
 * @param {string} fnAttr
 */


function clear(obj, fnAttr) {
  var fn = obj[fnAttr];

  if (fn && fn[ORIGIN_METHOD]) {
    obj[fnAttr] = fn[ORIGIN_METHOD];
  }
}

exports.throttle = throttle;
exports.createOrUpdate = createOrUpdate;
exports.clear = clear;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var graphic = __webpack_require__(93);

var BoundingRect = __webpack_require__(101);

// Symbol factory

/**
 * Triangle shape
 * @inner
 */
var Triangle = graphic.extendShape({
  type: 'triangle',
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy + height);
    path.lineTo(cx - width, cy + height);
    path.closePath();
  }
});
/**
 * Diamond shape
 * @inner
 */

var Diamond = graphic.extendShape({
  type: 'diamond',
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy);
    path.lineTo(cx, cy + height);
    path.lineTo(cx - width, cy);
    path.closePath();
  }
});
/**
 * Pin shape
 * @inner
 */

var Pin = graphic.extendShape({
  type: 'pin',
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var x = shape.x;
    var y = shape.y;
    var w = shape.width / 5 * 3; // Height must be larger than width

    var h = Math.max(w, shape.height);
    var r = w / 2; // Dist on y with tangent point and circle center

    var dy = r * r / (h - r);
    var cy = y - h + r + dy;
    var angle = Math.asin(dy / r); // Dist on x with tangent point and circle center

    var dx = Math.cos(angle) * r;
    var tanX = Math.sin(angle);
    var tanY = Math.cos(angle);
    var cpLen = r * 0.6;
    var cpLen2 = r * 0.7;
    path.moveTo(x - dx, cy + dy);
    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
    path.closePath();
  }
});
/**
 * Arrow shape
 * @inner
 */

var Arrow = graphic.extendShape({
  type: 'arrow',
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (ctx, shape) {
    var height = shape.height;
    var width = shape.width;
    var x = shape.x;
    var y = shape.y;
    var dx = width / 3 * 2;
    ctx.moveTo(x, y);
    ctx.lineTo(x + dx, y + height);
    ctx.lineTo(x, y + height / 4 * 3);
    ctx.lineTo(x - dx, y + height);
    ctx.lineTo(x, y);
    ctx.closePath();
  }
});
/**
 * Map of path contructors
 * @type {Object.<string, module:zrender/graphic/Path>}
 */

var symbolCtors = {
  line: graphic.Line,
  rect: graphic.Rect,
  roundRect: graphic.Rect,
  square: graphic.Rect,
  circle: graphic.Circle,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
};
var symbolShapeMakers = {
  line: function (x, y, w, h, shape) {
    // FIXME
    shape.x1 = x;
    shape.y1 = y + h / 2;
    shape.x2 = x + w;
    shape.y2 = y + h / 2;
  },
  rect: function (x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
  },
  roundRect: function (x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
    shape.r = Math.min(w, h) / 4;
  },
  square: function (x, y, w, h, shape) {
    var size = Math.min(w, h);
    shape.x = x;
    shape.y = y;
    shape.width = size;
    shape.height = size;
  },
  circle: function (x, y, w, h, shape) {
    // Put circle in the center of square
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.r = Math.min(w, h) / 2;
  },
  diamond: function (x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  pin: function (x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  arrow: function (x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  triangle: function (x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  }
};
var symbolBuildProxies = {};
zrUtil.each(symbolCtors, function (Ctor, name) {
  symbolBuildProxies[name] = new Ctor();
});
var SymbolClz = graphic.extendShape({
  type: 'symbol',
  shape: {
    symbolType: '',
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  beforeBrush: function () {
    var style = this.style;
    var shape = this.shape; // FIXME

    if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
      style.textPosition = ['50%', '40%'];
      style.textAlign = 'center';
      style.textVerticalAlign = 'middle';
    }
  },
  buildPath: function (ctx, shape, inBundle) {
    var symbolType = shape.symbolType;
    var proxySymbol = symbolBuildProxies[symbolType];

    if (shape.symbolType !== 'none') {
      if (!proxySymbol) {
        // Default rect
        symbolType = 'rect';
        proxySymbol = symbolBuildProxies[symbolType];
      }

      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
}); // Provide setColor helper method to avoid determine if set the fill or stroke outside

function symbolPathSetColor(color, innerColor) {
  if (this.type !== 'image') {
    var symbolStyle = this.style;
    var symbolShape = this.shape;

    if (symbolShape && symbolShape.symbolType === 'line') {
      symbolStyle.stroke = color;
    } else if (this.__isEmptyBrush) {
      symbolStyle.stroke = color;
      symbolStyle.fill = innerColor || '#fff';
    } else {
      // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
      symbolStyle.fill && (symbolStyle.fill = color);
      symbolStyle.stroke && (symbolStyle.stroke = color);
    }

    this.dirty(false);
  }
}
/**
 * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
 * @param {string} symbolType
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {string} color
 * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,
 *                            for path and image only.
 */


function createSymbol(symbolType, x, y, w, h, color, keepAspect) {
  // TODO Support image object, DynamicImage.
  var isEmpty = symbolType.indexOf('empty') === 0;

  if (isEmpty) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }

  var symbolPath;

  if (symbolType.indexOf('image://') === 0) {
    symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');
  } else if (symbolType.indexOf('path://') === 0) {
    symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');
  } else {
    symbolPath = new SymbolClz({
      shape: {
        symbolType: symbolType,
        x: x,
        y: y,
        width: w,
        height: h
      }
    });
  }

  symbolPath.__isEmptyBrush = isEmpty;
  symbolPath.setColor = symbolPathSetColor;
  symbolPath.setColor(color);
  return symbolPath;
}

exports.createSymbol = createSymbol;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var env = __webpack_require__(98);

var modelUtil = __webpack_require__(95);

var helper = __webpack_require__(136);

var AxisProxy = __webpack_require__(283);

var each = zrUtil.each;
var eachAxisDim = helper.eachAxisDim;
var DataZoomModel = echarts.extendComponentModel({
  type: 'dataZoom',
  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],

  /**
   * @protected
   */
  defaultOption: {
    zlevel: 0,
    z: 4,
    // Higher than normal component (z: 2).
    orient: null,
    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.
    xAxisIndex: null,
    // Default the first horizontal category axis.
    yAxisIndex: null,
    // Default the first vertical category axis.
    filterMode: 'filter',
    // Possible values: 'filter' or 'empty' or 'weakFilter'.
    // 'filter': data items which are out of window will be removed. This option is
    //          applicable when filtering outliers. For each data item, it will be
    //          filtered if one of the relevant dimensions is out of the window.
    // 'weakFilter': data items which are out of window will be removed. This option
    //          is applicable when filtering outliers. For each data item, it will be
    //          filtered only if all  of the relevant dimensions are out of the same
    //          side of the window.
    // 'empty': data items which are out of window will be set to empty.
    //          This option is applicable when user should not neglect
    //          that there are some data items out of window.
    // 'none': Do not filter.
    // Taking line chart as an example, line will be broken in
    // the filtered points when filterModel is set to 'empty', but
    // be connected when set to 'filter'.
    throttle: null,
    // Dispatch action by the fixed rate, avoid frequency.
    // default 100. Do not throttle when use null/undefined.
    // If animation === true and animationDurationUpdate > 0,
    // default value is 100, otherwise 20.
    start: 0,
    // Start percent. 0 ~ 100
    end: 100,
    // End percent. 0 ~ 100
    startValue: null,
    // Start value. If startValue specified, start is ignored.
    endValue: null,
    // End value. If endValue specified, end is ignored.
    minSpan: null,
    // 0 ~ 100
    maxSpan: null,
    // 0 ~ 100
    minValueSpan: null,
    // The range of dataZoom can not be smaller than that.
    maxValueSpan: null,
    // The range of dataZoom can not be larger than that.
    rangeMode: null // Array, can be 'value' or 'percent'.

  },

  /**
   * @override
   */
  init: function (option, parentModel, ecModel) {
    /**
     * key like x_0, y_1
     * @private
     * @type {Object}
     */
    this._dataIntervalByAxis = {};
    /**
     * @private
     */

    this._dataInfo = {};
    /**
     * key like x_0, y_1
     * @private
     */

    this._axisProxies = {};
    /**
     * @readOnly
     */

    this.textStyleModel;
    /**
     * @private
     */

    this._autoThrottle = true;
    /**
     * 'percent' or 'value'
     * @private
     */

    this._rangePropMode = ['percent', 'percent'];
    var rawOption = retrieveRaw(option);
    this.mergeDefaultAndTheme(option, ecModel);
    this.doInit(rawOption);
  },

  /**
   * @override
   */
  mergeOption: function (newOption) {
    var rawOption = retrieveRaw(newOption); //FIX #2591

    zrUtil.merge(this.option, newOption, true);
    this.doInit(rawOption);
  },

  /**
   * @protected
   */
  doInit: function (rawOption) {
    var thisOption = this.option; // Disable realtime view update if canvas is not supported.

    if (!env.canvasSupported) {
      thisOption.realtime = false;
    }

    this._setDefaultThrottle(rawOption);

    updateRangeUse(this, rawOption);
    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
      // start/end has higher priority over startValue/endValue if they
      // both set, but we should make chart.setOption({endValue: 1000})
      // effective, rather than chart.setOption({endValue: 1000, end: null}).
      if (this._rangePropMode[index] === 'value') {
        thisOption[names[0]] = null;
      } // Otherwise do nothing and use the merge result.

    }, this);
    this.textStyleModel = this.getModel('textStyle');

    this._resetTarget();

    this._giveAxisProxies();
  },

  /**
   * @private
   */
  _giveAxisProxies: function () {
    var axisProxies = this._axisProxies;
    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {
      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.

      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.
      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME
      // dispose __dzAxisProxy

      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;
    }, this);
  },

  /**
   * @private
   */
  _resetTarget: function () {
    var thisOption = this.option;

    var autoMode = this._judgeAutoMode();

    eachAxisDim(function (dimNames) {
      var axisIndexName = dimNames.axisIndex;
      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);
    }, this);

    if (autoMode === 'axisIndex') {
      this._autoSetAxisIndex();
    } else if (autoMode === 'orient') {
      this._autoSetOrient();
    }
  },

  /**
   * @private
   */
  _judgeAutoMode: function () {
    // Auto set only works for setOption at the first time.
    // The following is user's reponsibility. So using merged
    // option is OK.
    var thisOption = this.option;
    var hasIndexSpecified = false;
    eachAxisDim(function (dimNames) {
      // When user set axisIndex as a empty array, we think that user specify axisIndex
      // but do not want use auto mode. Because empty array may be encountered when
      // some error occured.
      if (thisOption[dimNames.axisIndex] != null) {
        hasIndexSpecified = true;
      }
    }, this);
    var orient = thisOption.orient;

    if (orient == null && hasIndexSpecified) {
      return 'orient';
    } else if (!hasIndexSpecified) {
      if (orient == null) {
        thisOption.orient = 'horizontal';
      }

      return 'axisIndex';
    }
  },

  /**
   * @private
   */
  _autoSetAxisIndex: function () {
    var autoAxisIndex = true;
    var orient = this.get('orient', true);
    var thisOption = this.option;
    var dependentModels = this.dependentModels;

    if (autoAxisIndex) {
      // Find axis that parallel to dataZoom as default.
      var dimName = orient === 'vertical' ? 'y' : 'x';

      if (dependentModels[dimName + 'Axis'].length) {
        thisOption[dimName + 'AxisIndex'] = [0];
        autoAxisIndex = false;
      } else {
        each(dependentModels.singleAxis, function (singleAxisModel) {
          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {
            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];
            autoAxisIndex = false;
          }
        });
      }
    }

    if (autoAxisIndex) {
      // Find the first category axis as default. (consider polar)
      eachAxisDim(function (dimNames) {
        if (!autoAxisIndex) {
          return;
        }

        var axisIndices = [];
        var axisModels = this.dependentModels[dimNames.axis];

        if (axisModels.length && !axisIndices.length) {
          for (var i = 0, len = axisModels.length; i < len; i++) {
            if (axisModels[i].get('type') === 'category') {
              axisIndices.push(i);
            }
          }
        }

        thisOption[dimNames.axisIndex] = axisIndices;

        if (axisIndices.length) {
          autoAxisIndex = false;
        }
      }, this);
    }

    if (autoAxisIndex) {
      // FIXME
      // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），
      // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？
      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,
      // dataZoom component auto adopts series that reference to
      // both xAxis and yAxis which type is 'value'.
      this.ecModel.eachSeries(function (seriesModel) {
        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {
          eachAxisDim(function (dimNames) {
            var axisIndices = thisOption[dimNames.axisIndex];
            var axisIndex = seriesModel.get(dimNames.axisIndex);
            var axisId = seriesModel.get(dimNames.axisId);
            var axisModel = seriesModel.ecModel.queryComponents({
              mainType: dimNames.axis,
              index: axisIndex,
              id: axisId
            })[0];
            axisIndex = axisModel.componentIndex;

            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {
              axisIndices.push(axisIndex);
            }
          });
        }
      }, this);
    }
  },

  /**
   * @private
   */
  _autoSetOrient: function () {
    var dim; // Find the first axis

    this.eachTargetAxis(function (dimNames) {
      !dim && (dim = dimNames.name);
    }, this);
    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';
  },

  /**
   * @private
   */
  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {
    // FIXME
    // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。
    // 例如series.type === scatter时。
    var is = true;
    eachAxisDim(function (dimNames) {
      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);
      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];

      if (!axisModel || axisModel.get('type') !== axisType) {
        is = false;
      }
    }, this);
    return is;
  },

  /**
   * @private
   */
  _setDefaultThrottle: function (rawOption) {
    // When first time user set throttle, auto throttle ends.
    if (rawOption.hasOwnProperty('throttle')) {
      this._autoThrottle = false;
    }

    if (this._autoThrottle) {
      var globalOption = this.ecModel.option;
      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
    }
  },

  /**
   * @public
   */
  getFirstTargetAxisModel: function () {
    var firstAxisModel;
    eachAxisDim(function (dimNames) {
      if (firstAxisModel == null) {
        var indices = this.get(dimNames.axisIndex);

        if (indices.length) {
          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];
        }
      }
    }, this);
    return firstAxisModel;
  },

  /**
   * @public
   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
   */
  eachTargetAxis: function (callback, context) {
    var ecModel = this.ecModel;
    eachAxisDim(function (dimNames) {
      each(this.get(dimNames.axisIndex), function (axisIndex) {
        callback.call(context, dimNames, axisIndex, this, ecModel);
      }, this);
    }, this);
  },

  /**
   * @param {string} dimName
   * @param {number} axisIndex
   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.
   */
  getAxisProxy: function (dimName, axisIndex) {
    return this._axisProxies[dimName + '_' + axisIndex];
  },

  /**
   * @param {string} dimName
   * @param {number} axisIndex
   * @return {module:echarts/model/Model} If not found, return null/undefined.
   */
  getAxisModel: function (dimName, axisIndex) {
    var axisProxy = this.getAxisProxy(dimName, axisIndex);
    return axisProxy && axisProxy.getAxisModel();
  },

  /**
   * If not specified, set to undefined.
   *
   * @public
   * @param {Object} opt
   * @param {number} [opt.start]
   * @param {number} [opt.end]
   * @param {number} [opt.startValue]
   * @param {number} [opt.endValue]
   * @param {boolean} [ignoreUpdateRangeUsg=false]
   */
  setRawRange: function (opt, ignoreUpdateRangeUsg) {
    var option = this.option;
    each([['start', 'startValue'], ['end', 'endValue']], function (names) {
      // If only one of 'start' and 'startValue' is not null/undefined, the other
      // should be cleared, which enable clear the option.
      // If both of them are not set, keep option with the original value, which
      // enable use only set start but not set end when calling `dispatchAction`.
      // The same as 'end' and 'endValue'.
      if (opt[names[0]] != null || opt[names[1]] != null) {
        option[names[0]] = opt[names[0]];
        option[names[1]] = opt[names[1]];
      }
    }, this);
    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);
  },

  /**
   * @public
   * @return {Array.<number>} [startPercent, endPercent]
   */
  getPercentRange: function () {
    var axisProxy = this.findRepresentativeAxisProxy();

    if (axisProxy) {
      return axisProxy.getDataPercentWindow();
    }
  },

  /**
   * @public
   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
   *
   * @param {string} [axisDimName]
   * @param {number} [axisIndex]
   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.
   */
  getValueRange: function (axisDimName, axisIndex) {
    if (axisDimName == null && axisIndex == null) {
      var axisProxy = this.findRepresentativeAxisProxy();

      if (axisProxy) {
        return axisProxy.getDataValueWindow();
      }
    } else {
      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
    }
  },

  /**
   * @public
   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy
   *      corresponding to the axisModel
   * @return {module:echarts/component/dataZoom/AxisProxy}
   */
  findRepresentativeAxisProxy: function (axisModel) {
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    } // Find the first hosted axisProxy


    var axisProxies = this._axisProxies;

    for (var key in axisProxies) {
      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {
        return axisProxies[key];
      }
    } // If no hosted axis find not hosted axisProxy.
    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,
    // and the option.start or option.end settings are different. The percentRange
    // should follow axisProxy.
    // (We encounter this problem in toolbox data zoom.)


    for (var key in axisProxies) {
      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {
        return axisProxies[key];
      }
    }
  },

  /**
   * @return {Array.<string>}
   */
  getRangePropMode: function () {
    return this._rangePropMode.slice();
  }
});

function retrieveRaw(option) {
  var ret = {};
  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {
    option.hasOwnProperty(name) && (ret[name] = option[name]);
  });
  return ret;
}

function updateRangeUse(dataZoomModel, rawOption) {
  var rangePropMode = dataZoomModel._rangePropMode;
  var rangeModeInOption = dataZoomModel.get('rangeMode');
  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
    var percentSpecified = rawOption[names[0]] != null;
    var valueSpecified = rawOption[names[1]] != null;

    if (percentSpecified && !valueSpecified) {
      rangePropMode[index] = 'percent';
    } else if (!percentSpecified && valueSpecified) {
      rangePropMode[index] = 'value';
    } else if (rangeModeInOption) {
      rangePropMode[index] = rangeModeInOption[index];
    } else if (percentSpecified) {
      // percentSpecified && valueSpecified
      rangePropMode[index] = 'percent';
    } // else remain its original setting.

  });
}

var _default = DataZoomModel;
module.exports = _default;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var ComponentView = __webpack_require__(157);

var _default = ComponentView.extend({
  type: 'dataZoom',
  render: function (dataZoomModel, ecModel, api, payload) {
    this.dataZoomModel = dataZoomModel;
    this.ecModel = ecModel;
    this.api = api;
  },

  /**
   * Find the first target coordinate system.
   *
   * @protected
   * @return {Object} {
   *                   grid: [
   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
   *                       ...
   *                   ],  // cartesians must not be null/undefined.
   *                   polar: [
   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},
   *                       ...
   *                   ],  // polars must not be null/undefined.
   *                   singleAxis: [
   *                       {model: coord0, axisModels: [], coordIndex: 0}
   *                   ]
   */
  getTargetCoordInfo: function () {
    var dataZoomModel = this.dataZoomModel;
    var ecModel = this.ecModel;
    var coordSysLists = {};
    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);

      if (axisModel) {
        var coordModel = axisModel.getCoordSysModel();
        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);
      }
    }, this);

    function save(coordModel, axisModel, store, coordIndex) {
      var item;

      for (var i = 0; i < store.length; i++) {
        if (store[i].model === coordModel) {
          item = store[i];
          break;
        }
      }

      if (!item) {
        store.push(item = {
          model: coordModel,
          axisModels: [],
          coordIndex: coordIndex
        });
      }

      item.axisModels.push(axisModel);
    }

    return coordSysLists;
  }
});

module.exports = _default;

/***/ }),
/* 118 */
/***/ (function(module, exports) {

var _default = {
  toolbox: {
    brush: {
      title: {
        rect: '矩形选择',
        polygon: '圈选',
        lineX: '横向选择',
        lineY: '纵向选择',
        keep: '保持选择',
        clear: '清除选择'
      }
    },
    dataView: {
      title: '数据视图',
      lang: ['数据视图', '关闭', '刷新']
    },
    dataZoom: {
      title: {
        zoom: '区域缩放',
        back: '区域缩放还原'
      }
    },
    magicType: {
      title: {
        line: '切换为折线图',
        bar: '切换为柱状图',
        stack: '切换为堆叠',
        tiled: '切换为平铺'
      }
    },
    restore: {
      title: '还原'
    },
    saveAsImage: {
      title: '保存为图片',
      lang: ['右键另存为图片']
    }
  }
};
module.exports = _default;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Element = __webpack_require__(140);

var BoundingRect = __webpack_require__(101);

/**
 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
 * @module zrender/graphic/Group
 * @example
 *     var Group = require('zrender/container/Group');
 *     var Circle = require('zrender/graphic/shape/Circle');
 *     var g = new Group();
 *     g.position[0] = 100;
 *     g.position[1] = 100;
 *     g.add(new Circle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 20,
 *         }
 *     }));
 *     zr.add(g);
 */

/**
 * @alias module:zrender/graphic/Group
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @extends module:zrender/mixin/Eventful
 */
var Group = function (opts) {
  opts = opts || {};
  Element.call(this, opts);

  for (var key in opts) {
    if (opts.hasOwnProperty(key)) {
      this[key] = opts[key];
    }
  }

  this._children = [];
  this.__storage = null;
  this.__dirty = true;
};

Group.prototype = {
  constructor: Group,
  isGroup: true,

  /**
   * @type {string}
   */
  type: 'group',

  /**
   * 所有子孙元素是否响应鼠标事件
   * @name module:/zrender/container/Group#silent
   * @type {boolean}
   * @default false
   */
  silent: false,

  /**
   * @return {Array.<module:zrender/Element>}
   */
  children: function () {
    return this._children.slice();
  },

  /**
   * 获取指定 index 的儿子节点
   * @param  {number} idx
   * @return {module:zrender/Element}
   */
  childAt: function (idx) {
    return this._children[idx];
  },

  /**
   * 获取指定名字的儿子节点
   * @param  {string} name
   * @return {module:zrender/Element}
   */
  childOfName: function (name) {
    var children = this._children;

    for (var i = 0; i < children.length; i++) {
      if (children[i].name === name) {
        return children[i];
      }
    }
  },

  /**
   * @return {number}
   */
  childCount: function () {
    return this._children.length;
  },

  /**
   * 添加子节点到最后
   * @param {module:zrender/Element} child
   */
  add: function (child) {
    if (child && child !== this && child.parent !== this) {
      this._children.push(child);

      this._doAdd(child);
    }

    return this;
  },

  /**
   * 添加子节点在 nextSibling 之前
   * @param {module:zrender/Element} child
   * @param {module:zrender/Element} nextSibling
   */
  addBefore: function (child, nextSibling) {
    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
      var children = this._children;
      var idx = children.indexOf(nextSibling);

      if (idx >= 0) {
        children.splice(idx, 0, child);

        this._doAdd(child);
      }
    }

    return this;
  },
  _doAdd: function (child) {
    if (child.parent) {
      child.parent.remove(child);
    }

    child.parent = this;
    var storage = this.__storage;
    var zr = this.__zr;

    if (storage && storage !== child.__storage) {
      storage.addToStorage(child);

      if (child instanceof Group) {
        child.addChildrenToStorage(storage);
      }
    }

    zr && zr.refresh();
  },

  /**
   * 移除子节点
   * @param {module:zrender/Element} child
   */
  remove: function (child) {
    var zr = this.__zr;
    var storage = this.__storage;
    var children = this._children;
    var idx = zrUtil.indexOf(children, child);

    if (idx < 0) {
      return this;
    }

    children.splice(idx, 1);
    child.parent = null;

    if (storage) {
      storage.delFromStorage(child);

      if (child instanceof Group) {
        child.delChildrenFromStorage(storage);
      }
    }

    zr && zr.refresh();
    return this;
  },

  /**
   * 移除所有子节点
   */
  removeAll: function () {
    var children = this._children;
    var storage = this.__storage;
    var child;
    var i;

    for (i = 0; i < children.length; i++) {
      child = children[i];

      if (storage) {
        storage.delFromStorage(child);

        if (child instanceof Group) {
          child.delChildrenFromStorage(storage);
        }
      }

      child.parent = null;
    }

    children.length = 0;
    return this;
  },

  /**
   * 遍历所有子节点
   * @param  {Function} cb
   * @param  {}   context
   */
  eachChild: function (cb, context) {
    var children = this._children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      cb.call(context, child, i);
    }

    return this;
  },

  /**
   * 深度优先遍历所有子孙节点
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      cb.call(context, child);

      if (child.type === 'group') {
        child.traverse(cb, context);
      }
    }

    return this;
  },
  addChildrenToStorage: function (storage) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      storage.addToStorage(child);

      if (child instanceof Group) {
        child.addChildrenToStorage(storage);
      }
    }
  },
  delChildrenFromStorage: function (storage) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      storage.delFromStorage(child);

      if (child instanceof Group) {
        child.delChildrenFromStorage(storage);
      }
    }
  },
  dirty: function () {
    this.__dirty = true;
    this.__zr && this.__zr.refresh();
    return this;
  },

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function (includeChildren) {
    // TODO Caching
    var rect = null;
    var tmpRect = new BoundingRect(0, 0, 0, 0);
    var children = includeChildren || this._children;
    var tmpMat = [];

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (child.ignore || child.invisible) {
        continue;
      }

      var childRect = child.getBoundingRect();
      var transform = child.getLocalTransform(tmpMat); // TODO
      // The boundingRect cacluated by transforming original
      // rect may be bigger than the actual bundingRect when rotation
      // is used. (Consider a circle rotated aginst its center, where
      // the actual boundingRect should be the same as that not be
      // rotated.) But we can not find better approach to calculate
      // actual boundingRect yet, considering performance.

      if (transform) {
        tmpRect.copy(childRect);
        tmpRect.applyTransform(transform);
        rect = rect || tmpRect.clone();
        rect.union(tmpRect);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }

    return rect || tmpRect;
  }
};
zrUtil.inherits(Group, Element);
var _default = Group;
module.exports = _default;

/***/ }),
/* 120 */
/***/ (function(module, exports) {

var dpr = 1; // If in browser environment

if (typeof window !== 'undefined') {
  dpr = Math.max(window.devicePixelRatio || 1, 1);
}
/**
 * config默认配置项
 * @exports zrender/config
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */

/**
 * debug日志选项：catchBrushException为true下有效
 * 0 : 不生成debug数据，发布用
 * 1 : 异常抛出，调试用
 * 2 : 控制台输出，调试用
 */


var debugMode = 0; // retina 屏幕优化

var devicePixelRatio = dpr;
exports.debugMode = debugMode;
exports.devicePixelRatio = devicePixelRatio;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

// TODO Parse shadow style
// TODO Only shallow path support
function _default(properties) {
  // Normalize
  for (var i = 0; i < properties.length; i++) {
    if (!properties[i][1]) {
      properties[i][1] = properties[i][0];
    }
  }

  return function (model, excludes, includes) {
    var style = {};

    for (var i = 0; i < properties.length; i++) {
      var propName = properties[i][1];

      if (excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0) {
        continue;
      }

      var val = model.getShallow(propName);

      if (val != null) {
        style[properties[i][0]] = val;
      }
    }

    return style;
  };
}

module.exports = _default;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var curve = __webpack_require__(111);

var vec2 = __webpack_require__(97);

var bbox = __webpack_require__(151);

var BoundingRect = __webpack_require__(101);

var _config = __webpack_require__(120);

var dpr = _config.devicePixelRatio;

/**
 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
 * 可以用于 isInsidePath 判断以及获取boundingRect
 *
 * @module zrender/core/PathProxy
 * @author Yi Shen (http://www.github.com/pissang)
 */
// TODO getTotalLength, getPointAtLength
var CMD = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  // Rect
  R: 7
}; // var CMD_MEM_SIZE = {
//     M: 3,
//     L: 3,
//     C: 7,
//     Q: 5,
//     A: 9,
//     R: 5,
//     Z: 1
// };

var min = [];
var max = [];
var min2 = [];
var max2 = [];
var mathMin = Math.min;
var mathMax = Math.max;
var mathCos = Math.cos;
var mathSin = Math.sin;
var mathSqrt = Math.sqrt;
var mathAbs = Math.abs;
var hasTypedArray = typeof Float32Array != 'undefined';
/**
 * @alias module:zrender/core/PathProxy
 * @constructor
 */

var PathProxy = function (notSaveData) {
  this._saveData = !(notSaveData || false);

  if (this._saveData) {
    /**
     * Path data. Stored as flat array
     * @type {Array.<Object>}
     */
    this.data = [];
  }

  this._ctx = null;
};
/**
 * 快速计算Path包围盒（并不是最小包围盒）
 * @return {Object}
 */


PathProxy.prototype = {
  constructor: PathProxy,
  _xi: 0,
  _yi: 0,
  _x0: 0,
  _y0: 0,
  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
  _ux: 0,
  _uy: 0,
  _len: 0,
  _lineDash: null,
  _dashOffset: 0,
  _dashIdx: 0,
  _dashSum: 0,

  /**
   * @readOnly
   */
  setScale: function (sx, sy) {
    this._ux = mathAbs(1 / dpr / sx) || 0;
    this._uy = mathAbs(1 / dpr / sy) || 0;
  },
  getContext: function () {
    return this._ctx;
  },

  /**
   * @param  {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  beginPath: function (ctx) {
    this._ctx = ctx;
    ctx && ctx.beginPath();
    ctx && (this.dpr = ctx.dpr); // Reset

    if (this._saveData) {
      this._len = 0;
    }

    if (this._lineDash) {
      this._lineDash = null;
      this._dashOffset = 0;
    }

    return this;
  },

  /**
   * @param  {number} x
   * @param  {number} y
   * @return {module:zrender/core/PathProxy}
   */
  moveTo: function (x, y) {
    this.addData(CMD.M, x, y);
    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持

    this._x0 = x;
    this._y0 = y;
    this._xi = x;
    this._yi = y;
    return this;
  },

  /**
   * @param  {number} x
   * @param  {number} y
   * @return {module:zrender/core/PathProxy}
   */
  lineTo: function (x, y) {
    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
    || this._len < 5;
    this.addData(CMD.L, x, y);

    if (this._ctx && exceedUnit) {
      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
    }

    if (exceedUnit) {
      this._xi = x;
      this._yi = y;
    }

    return this;
  },

  /**
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @param  {number} x3
   * @param  {number} y3
   * @return {module:zrender/core/PathProxy}
   */
  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);

    if (this._ctx) {
      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
    }

    this._xi = x3;
    this._yi = y3;
    return this;
  },

  /**
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @return {module:zrender/core/PathProxy}
   */
  quadraticCurveTo: function (x1, y1, x2, y2) {
    this.addData(CMD.Q, x1, y1, x2, y2);

    if (this._ctx) {
      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
    }

    this._xi = x2;
    this._yi = y2;
    return this;
  },

  /**
   * @param  {number} cx
   * @param  {number} cy
   * @param  {number} r
   * @param  {number} startAngle
   * @param  {number} endAngle
   * @param  {boolean} anticlockwise
   * @return {module:zrender/core/PathProxy}
   */
  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
    this._xi = mathCos(endAngle) * r + cx;
    this._yi = mathSin(endAngle) * r + cx;
    return this;
  },
  // TODO
  arcTo: function (x1, y1, x2, y2, radius) {
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x2, y2, radius);
    }

    return this;
  },
  // TODO
  rect: function (x, y, w, h) {
    this._ctx && this._ctx.rect(x, y, w, h);
    this.addData(CMD.R, x, y, w, h);
    return this;
  },

  /**
   * @return {module:zrender/core/PathProxy}
   */
  closePath: function () {
    this.addData(CMD.Z);
    var ctx = this._ctx;
    var x0 = this._x0;
    var y0 = this._y0;

    if (ctx) {
      this._needsDash() && this._dashedLineTo(x0, y0);
      ctx.closePath();
    }

    this._xi = x0;
    this._yi = y0;
    return this;
  },

  /**
   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
   * stroke 同样
   * @param {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  fill: function (ctx) {
    ctx && ctx.fill();
    this.toStatic();
  },

  /**
   * @param {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  stroke: function (ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  },

  /**
   * 必须在其它绘制命令前调用
   * Must be invoked before all other path drawing methods
   * @return {module:zrender/core/PathProxy}
   */
  setLineDash: function (lineDash) {
    if (lineDash instanceof Array) {
      this._lineDash = lineDash;
      this._dashIdx = 0;
      var lineDashSum = 0;

      for (var i = 0; i < lineDash.length; i++) {
        lineDashSum += lineDash[i];
      }

      this._dashSum = lineDashSum;
    }

    return this;
  },

  /**
   * 必须在其它绘制命令前调用
   * Must be invoked before all other path drawing methods
   * @return {module:zrender/core/PathProxy}
   */
  setLineDashOffset: function (offset) {
    this._dashOffset = offset;
    return this;
  },

  /**
   *
   * @return {boolean}
   */
  len: function () {
    return this._len;
  },

  /**
   * 直接设置 Path 数据
   */
  setData: function (data) {
    var len = data.length;

    if (!(this.data && this.data.length == len) && hasTypedArray) {
      this.data = new Float32Array(len);
    }

    for (var i = 0; i < len; i++) {
      this.data[i] = data[i];
    }

    this._len = len;
  },

  /**
   * 添加子路径
   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
   */
  appendPath: function (path) {
    if (!(path instanceof Array)) {
      path = [path];
    }

    var len = path.length;
    var appendSize = 0;
    var offset = this._len;

    for (var i = 0; i < len; i++) {
      appendSize += path[i].len();
    }

    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset + appendSize);
    }

    for (var i = 0; i < len; i++) {
      var appendPathData = path[i].data;

      for (var k = 0; k < appendPathData.length; k++) {
        this.data[offset++] = appendPathData[k];
      }
    }

    this._len = offset;
  },

  /**
   * 填充 Path 数据。
   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
   */
  addData: function (cmd) {
    if (!this._saveData) {
      return;
    }

    var data = this.data;

    if (this._len + arguments.length > data.length) {
      // 因为之前的数组已经转换成静态的 Float32Array
      // 所以不够用时需要扩展一个新的动态数组
      this._expandData();

      data = this.data;
    }

    for (var i = 0; i < arguments.length; i++) {
      data[this._len++] = arguments[i];
    }

    this._prevCmd = cmd;
  },
  _expandData: function () {
    // Only if data is Float32Array
    if (!(this.data instanceof Array)) {
      var newData = [];

      for (var i = 0; i < this._len; i++) {
        newData[i] = this.data[i];
      }

      this.data = newData;
    }
  },

  /**
   * If needs js implemented dashed line
   * @return {boolean}
   * @private
   */
  _needsDash: function () {
    return this._lineDash;
  },
  _dashedLineTo: function (x1, y1) {
    var dashSum = this._dashSum;
    var offset = this._dashOffset;
    var lineDash = this._lineDash;
    var ctx = this._ctx;
    var x0 = this._xi;
    var y0 = this._yi;
    var dx = x1 - x0;
    var dy = y1 - y0;
    var dist = mathSqrt(dx * dx + dy * dy);
    var x = x0;
    var y = y0;
    var dash;
    var nDash = lineDash.length;
    var idx;
    dx /= dist;
    dy /= dist;

    if (offset < 0) {
      // Convert to positive offset
      offset = dashSum + offset;
    }

    offset %= dashSum;
    x -= offset * dx;
    y -= offset * dy;

    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
      idx = this._dashIdx;
      dash = lineDash[idx];
      x += dx * dash;
      y += dy * dash;
      this._dashIdx = (idx + 1) % nDash; // Skip positive offset

      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
        continue;
      }

      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
    } // Offset for next lineTo


    dx = x - x1;
    dy = y - y1;
    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
  },
  // Not accurate dashed line to
  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
    var dashSum = this._dashSum;
    var offset = this._dashOffset;
    var lineDash = this._lineDash;
    var ctx = this._ctx;
    var x0 = this._xi;
    var y0 = this._yi;
    var t;
    var dx;
    var dy;
    var cubicAt = curve.cubicAt;
    var bezierLen = 0;
    var idx = this._dashIdx;
    var nDash = lineDash.length;
    var x;
    var y;
    var tmpLen = 0;

    if (offset < 0) {
      // Convert to positive offset
      offset = dashSum + offset;
    }

    offset %= dashSum; // Bezier approx length

    for (t = 0; t < 1; t += 0.1) {
      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
      bezierLen += mathSqrt(dx * dx + dy * dy);
    } // Find idx after add offset


    for (; idx < nDash; idx++) {
      tmpLen += lineDash[idx];

      if (tmpLen > offset) {
        break;
      }
    }

    t = (tmpLen - offset) / bezierLen;

    while (t <= 1) {
      x = cubicAt(x0, x1, x2, x3, t);
      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
      // Bad result if dash is long

      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      t += lineDash[idx] / bezierLen;
      idx = (idx + 1) % nDash;
    } // Finish the last segment and calculate the new offset


    idx % 2 !== 0 && ctx.lineTo(x3, y3);
    dx = x3 - x;
    dy = y3 - y;
    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
  },
  _dashedQuadraticTo: function (x1, y1, x2, y2) {
    // Convert quadratic to cubic using degree elevation
    var x3 = x2;
    var y3 = y2;
    x2 = (x2 + 2 * x1) / 3;
    y2 = (y2 + 2 * y1) / 3;
    x1 = (this._xi + 2 * x1) / 3;
    y1 = (this._yi + 2 * y1) / 3;

    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
  },

  /**
   * 转成静态的 Float32Array 减少堆内存占用
   * Convert dynamic array to static Float32Array
   */
  toStatic: function () {
    var data = this.data;

    if (data instanceof Array) {
      data.length = this._len;

      if (hasTypedArray) {
        this.data = new Float32Array(data);
      }
    }
  },

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function () {
    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
    var data = this.data;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;

    for (var i = 0; i < data.length;) {
      var cmd = data[i++];

      if (i == 1) {
        // 如果第一个命令是 L, C, Q
        // 则 previous point 同绘制命令的第一个 point
        //
        // 第一个命令为 Arc 的情况下会在后面特殊处理
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }

      switch (cmd) {
        case CMD.M:
          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
          // 在 closePath 的时候使用
          x0 = data[i++];
          y0 = data[i++];
          xi = x0;
          yi = y0;
          min2[0] = x0;
          min2[1] = y0;
          max2[0] = x0;
          max2[1] = y0;
          break;

        case CMD.L:
          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.C:
          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.Q:
          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.A:
          // TODO Arc 判断的开销比较大
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var endAngle = data[i++] + startAngle; // TODO Arc 旋转

          var psi = data[i++];
          var anticlockwise = 1 - data[i++];

          if (i == 1) {
            // 直接使用 arc 命令
            // 第一个命令起点还未定义
            x0 = mathCos(startAngle) * rx + cx;
            y0 = mathSin(startAngle) * ry + cy;
          }

          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
          xi = mathCos(endAngle) * rx + cx;
          yi = mathSin(endAngle) * ry + cy;
          break;

        case CMD.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++]; // Use fromLine

          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
          break;

        case CMD.Z:
          xi = x0;
          yi = y0;
          break;
      } // Union


      vec2.min(min, min, min2);
      vec2.max(max, max, max2);
    } // No data


    if (i === 0) {
      min[0] = min[1] = max[0] = max[1] = 0;
    }

    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
  },

  /**
   * Rebuild path from current data
   * Rebuild path will not consider javascript implemented line dash.
   * @param {CanvasRenderingContext2D} ctx
   */
  rebuildPath: function (ctx) {
    var d = this.data;
    var x0, y0;
    var xi, yi;
    var x, y;
    var ux = this._ux;
    var uy = this._uy;
    var len = this._len;

    for (var i = 0; i < len;) {
      var cmd = d[i++];

      if (i == 1) {
        // 如果第一个命令是 L, C, Q
        // 则 previous point 同绘制命令的第一个 point
        //
        // 第一个命令为 Arc 的情况下会在后面特殊处理
        xi = d[i];
        yi = d[i + 1];
        x0 = xi;
        y0 = yi;
      }

      switch (cmd) {
        case CMD.M:
          x0 = xi = d[i++];
          y0 = yi = d[i++];
          ctx.moveTo(xi, yi);
          break;

        case CMD.L:
          x = d[i++];
          y = d[i++]; // Not draw too small seg between

          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
            ctx.lineTo(x, y);
            xi = x;
            yi = y;
          }

          break;

        case CMD.C:
          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
          xi = d[i - 2];
          yi = d[i - 1];
          break;

        case CMD.Q:
          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
          xi = d[i - 2];
          yi = d[i - 1];
          break;

        case CMD.A:
          var cx = d[i++];
          var cy = d[i++];
          var rx = d[i++];
          var ry = d[i++];
          var theta = d[i++];
          var dTheta = d[i++];
          var psi = d[i++];
          var fs = d[i++];
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          var isEllipse = Math.abs(rx - ry) > 1e-3;
          var endAngle = theta + dTheta;

          if (isEllipse) {
            ctx.translate(cx, cy);
            ctx.rotate(psi);
            ctx.scale(scaleX, scaleY);
            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
            ctx.scale(1 / scaleX, 1 / scaleY);
            ctx.rotate(-psi);
            ctx.translate(-cx, -cy);
          } else {
            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
          }

          if (i == 1) {
            // 直接使用 arc 命令
            // 第一个命令起点还未定义
            x0 = mathCos(theta) * rx + cx;
            y0 = mathSin(theta) * ry + cy;
          }

          xi = mathCos(endAngle) * rx + cx;
          yi = mathSin(endAngle) * ry + cy;
          break;

        case CMD.R:
          x0 = xi = d[i];
          y0 = yi = d[i + 1];
          ctx.rect(d[i++], d[i++], d[i++], d[i++]);
          break;

        case CMD.Z:
          ctx.closePath();
          xi = x0;
          yi = y0;
      }
    }
  }
};
PathProxy.CMD = CMD;
var _default = PathProxy;
module.exports = _default;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__(91);

var Model = __webpack_require__(102);

var DataDiffer = __webpack_require__(134);

var modelUtil = __webpack_require__(95);

/**
 * List for data storage
 * @module echarts/data/List
 */
var isObject = zrUtil.isObject;
var UNDEFINED = 'undefined';
var globalObj = typeof window === UNDEFINED ? global : window;
var dataCtors = {
  'float': typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array,
  'int': typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array,
  // Ordinal data type can be string or int
  'ordinal': Array,
  'number': Array,
  'time': Array
};
var TRANSFERABLE_PROPERTIES = ['stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'];

function transferProperties(a, b) {
  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {
    if (b.hasOwnProperty(propName)) {
      a[propName] = b[propName];
    }
  });
  a.__wrappedMethods = b.__wrappedMethods;
}

function DefaultDataProvider(dataArray) {
  this._array = dataArray || [];
}

DefaultDataProvider.prototype.pure = false;

DefaultDataProvider.prototype.count = function () {
  return this._array.length;
};

DefaultDataProvider.prototype.getItem = function (idx) {
  return this._array[idx];
};
/**
 * @constructor
 * @alias module:echarts/data/List
 *
 * @param {Array.<string|Object>} dimensions
 *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
 *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
 * @param {module:echarts/model/Model} hostModel
 */


var List = function (dimensions, hostModel) {
  dimensions = dimensions || ['x', 'y'];
  var dimensionInfos = {};
  var dimensionNames = [];

  for (var i = 0; i < dimensions.length; i++) {
    var dimensionName;
    var dimensionInfo = {};

    if (typeof dimensions[i] === 'string') {
      dimensionName = dimensions[i];
      dimensionInfo = {
        name: dimensionName,
        coordDim: dimensionName,
        coordDimIndex: 0,
        stackable: false,
        // Type can be 'float', 'int', 'number'
        // Default is number, Precision of float may not enough
        type: 'number'
      };
    } else {
      dimensionInfo = dimensions[i];
      dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || 'number';

      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }
    }

    dimensionInfo.otherDims = dimensionInfo.otherDims || {};
    dimensionNames.push(dimensionName);
    dimensionInfos[dimensionName] = dimensionInfo;
  }
  /**
   * @readOnly
   * @type {Array.<string>}
   */


  this.dimensions = dimensionNames;
  /**
   * Infomation of each data dimension, like data type.
   * @type {Object}
   */

  this._dimensionInfos = dimensionInfos;
  /**
   * @type {module:echarts/model/Model}
   */

  this.hostModel = hostModel;
  /**
   * @type {module:echarts/model/Model}
   */

  this.dataType;
  /**
   * Indices stores the indices of data subset after filtered.
   * This data subset will be used in chart.
   * @type {Array.<number>}
   * @readOnly
   */

  this.indices = [];
  /**
   * Data storage
   * @type {Object.<key, TypedArray|Array>}
   * @private
   */

  this._storage = {};
  /**
   * @type {Array.<string>}
   */

  this._nameList = [];
  /**
   * @type {Array.<string>}
   */

  this._idList = [];
  /**
   * Models of data option is stored sparse for optimizing memory cost
   * @type {Array.<module:echarts/model/Model>}
   * @private
   */

  this._optionModels = [];
  /**
   * @param {module:echarts/data/List}
   */

  this.stackedOn = null;
  /**
   * Global visual properties after visual coding
   * @type {Object}
   * @private
   */

  this._visual = {};
  /**
   * Globel layout properties.
   * @type {Object}
   * @private
   */

  this._layout = {};
  /**
   * Item visual properties after visual coding
   * @type {Array.<Object>}
   * @private
   */

  this._itemVisuals = [];
  /**
   * Item layout properties after layout
   * @type {Array.<Object>}
   * @private
   */

  this._itemLayouts = [];
  /**
   * Graphic elemnents
   * @type {Array.<module:zrender/Element>}
   * @private
   */

  this._graphicEls = [];
  /**
   * @type {Array.<Array|Object>}
   * @private
   */

  this._rawData;
  /**
   * @type {Object}
   * @private
   */

  this._extent;
};

var listProto = List.prototype;
listProto.type = 'list';
/**
 * If each data item has it's own option
 * @type {boolean}
 */

listProto.hasItemOption = true;
/**
 * Get dimension name
 * @param {string|number} dim
 *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
 *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
 * @return {string} Concrete dim name.
 */

listProto.getDimension = function (dim) {
  if (!isNaN(dim)) {
    dim = this.dimensions[dim] || dim;
  }

  return dim;
};
/**
 * Get type and stackable info of particular dimension
 * @param {string|number} dim
 *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
 *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
 */


listProto.getDimensionInfo = function (dim) {
  return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);
};
/**
 * Initialize from data
 * @param {Array.<Object|number|Array>} data
 * @param {Array.<string>} [nameList]
 * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number
 */


listProto.initData = function (data, nameList, dimValueGetter) {
  data = data || [];
  var isDataArray = zrUtil.isArray(data);

  if (isDataArray) {
    data = new DefaultDataProvider(data);
  }

  this._rawData = data; // Clear

  var storage = this._storage = {};
  var indices = this.indices = [];
  var dimensions = this.dimensions;
  var dimensionInfoMap = this._dimensionInfos;
  var size = data.count();
  var idList = [];
  var nameRepeatCount = {};
  var nameDimIdx;
  nameList = nameList || []; // Init storage

  for (var i = 0; i < dimensions.length; i++) {
    var dimInfo = dimensionInfoMap[dimensions[i]];
    dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);
    var DataCtor = dataCtors[dimInfo.type];
    storage[dimensions[i]] = new DataCtor(size);
  }

  var self = this;

  if (!dimValueGetter) {
    self.hasItemOption = false;
  } // Default dim value getter


  dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {
    var value = modelUtil.getDataItemValue(dataItem); // If any dataItem is like { value: 10 }

    if (modelUtil.isDataItemOption(dataItem)) {
      self.hasItemOption = true;
    }

    return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.
    : value, dimensionInfoMap[dimName]);
  };

  for (var i = 0; i < size; i++) {
    // NOTICE: Try not to write things into dataItem
    var dataItem = data.getItem(i); // Each data item is value
    // [1, 2]
    // 2
    // Bar chart, line chart which uses category axis
    // only gives the 'y' value. 'x' value is the indices of cateogry
    // Use a tempValue to normalize the value to be a (x, y) value
    // Store the data by dimensions

    for (var k = 0; k < dimensions.length; k++) {
      var dim = dimensions[k];
      var dimStorage = storage[dim]; // PENDING NULL is empty or zero

      dimStorage[i] = dimValueGetter(dataItem, dim, i, k);
    }

    indices.push(i);
  } // Use the name in option and create id


  for (var i = 0; i < size; i++) {
    var dataItem = data.getItem(i);

    if (!nameList[i] && dataItem) {
      if (dataItem.name != null) {
        nameList[i] = dataItem.name;
      } else if (nameDimIdx != null) {
        nameList[i] = storage[dimensions[nameDimIdx]][i];
      }
    }

    var name = nameList[i] || ''; // Try using the id in option

    var id = dataItem && dataItem.id;

    if (!id && name) {
      // Use name as id and add counter to avoid same name
      nameRepeatCount[name] = nameRepeatCount[name] || 0;
      id = name;

      if (nameRepeatCount[name] > 0) {
        id += '__ec__' + nameRepeatCount[name];
      }

      nameRepeatCount[name]++;
    }

    id && (idList[i] = id);
  }

  this._nameList = nameList;
  this._idList = idList;
};
/**
 * @return {number}
 */


listProto.count = function () {
  return this.indices.length;
};
/**
 * Get value. Return NaN if idx is out of range.
 * @param {string} dim Dim must be concrete name.
 * @param {number} idx
 * @param {boolean} stack
 * @return {number}
 */


listProto.get = function (dim, idx, stack) {
  var storage = this._storage;
  var dataIndex = this.indices[idx]; // If value not exists

  if (dataIndex == null || !storage[dim]) {
    return NaN;
  }

  var value = storage[dim][dataIndex]; // FIXME ordinal data type is not stackable

  if (stack) {
    var dimensionInfo = this._dimensionInfos[dim];

    if (dimensionInfo && dimensionInfo.stackable) {
      var stackedOn = this.stackedOn;

      while (stackedOn) {
        // Get no stacked data of stacked on
        var stackedValue = stackedOn.get(dim, idx); // Considering positive stack, negative stack and empty data

        if (value >= 0 && stackedValue > 0 || // Positive stack
        value <= 0 && stackedValue < 0 // Negative stack
        ) {
            value += stackedValue;
          }

        stackedOn = stackedOn.stackedOn;
      }
    }
  }

  return value;
};
/**
 * Get value for multi dimensions.
 * @param {Array.<string>} [dimensions] If ignored, using all dimensions.
 * @param {number} idx
 * @param {boolean} stack
 * @return {number}
 */


listProto.getValues = function (dimensions, idx, stack) {
  var values = [];

  if (!zrUtil.isArray(dimensions)) {
    stack = idx;
    idx = dimensions;
    dimensions = this.dimensions;
  }

  for (var i = 0, len = dimensions.length; i < len; i++) {
    values.push(this.get(dimensions[i], idx, stack));
  }

  return values;
};
/**
 * If value is NaN. Inlcuding '-'
 * @param {string} dim
 * @param {number} idx
 * @return {number}
 */


listProto.hasValue = function (idx) {
  var dimensions = this.dimensions;
  var dimensionInfos = this._dimensionInfos;

  for (var i = 0, len = dimensions.length; i < len; i++) {
    if ( // Ordinal type can be string or number
    dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {
      return false;
    }
  }

  return true;
};
/**
 * Get extent of data in one dimension
 * @param {string} dim
 * @param {boolean} stack
 * @param {Function} filter
 */


listProto.getDataExtent = function (dim, stack, filter) {
  dim = this.getDimension(dim);
  var dimData = this._storage[dim];
  var dimInfo = this.getDimensionInfo(dim);
  stack = dimInfo && dimInfo.stackable && stack;
  var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];
  var value;

  if (dimExtent) {
    return dimExtent;
  } // var dimInfo = this._dimensionInfos[dim];


  if (dimData) {
    var min = Infinity;
    var max = -Infinity; // var isOrdinal = dimInfo.type === 'ordinal';

    for (var i = 0, len = this.count(); i < len; i++) {
      value = this.get(dim, i, stack); // FIXME
      // if (isOrdinal && typeof value === 'string') {
      //     value = zrUtil.indexOf(dimData, value);
      // }

      if (!filter || filter(value, dim, i)) {
        value < min && (min = value);
        value > max && (max = value);
      }
    }

    return this._extent[dim + !!stack] = [min, max];
  } else {
    return [Infinity, -Infinity];
  }
};
/**
 * Get sum of data in one dimension
 * @param {string} dim
 * @param {boolean} stack
 */


listProto.getSum = function (dim, stack) {
  var dimData = this._storage[dim];
  var sum = 0;

  if (dimData) {
    for (var i = 0, len = this.count(); i < len; i++) {
      var value = this.get(dim, i, stack);

      if (!isNaN(value)) {
        sum += value;
      }
    }
  }

  return sum;
};
/**
 * Retreive the index with given value
 * @param {number} idx
 * @param {number} value
 * @return {number}
 */
// FIXME Precision of float value


listProto.indexOf = function (dim, value) {
  var storage = this._storage;
  var dimData = storage[dim];
  var indices = this.indices;

  if (dimData) {
    for (var i = 0, len = indices.length; i < len; i++) {
      var rawIndex = indices[i];

      if (dimData[rawIndex] === value) {
        return i;
      }
    }
  }

  return -1;
};
/**
 * Retreive the index with given name
 * @param {number} idx
 * @param {number} name
 * @return {number}
 */


listProto.indexOfName = function (name) {
  var indices = this.indices;
  var nameList = this._nameList;

  for (var i = 0, len = indices.length; i < len; i++) {
    var rawIndex = indices[i];

    if (nameList[rawIndex] === name) {
      return i;
    }
  }

  return -1;
};
/**
 * Retreive the index with given raw data index
 * @param {number} idx
 * @param {number} name
 * @return {number}
 */


listProto.indexOfRawIndex = function (rawIndex) {
  // Indices are ascending
  var indices = this.indices; // If rawIndex === dataIndex

  var rawDataIndex = indices[rawIndex];

  if (rawDataIndex != null && rawDataIndex === rawIndex) {
    return rawIndex;
  }

  var left = 0;
  var right = indices.length - 1;

  while (left <= right) {
    var mid = (left + right) / 2 | 0;

    if (indices[mid] < rawIndex) {
      left = mid + 1;
    } else if (indices[mid] > rawIndex) {
      right = mid - 1;
    } else {
      return mid;
    }
  }

  return -1;
};
/**
 * Retreive the index of nearest value
 * @param {string} dim
 * @param {number} value
 * @param {boolean} stack If given value is after stacked
 * @param {number} [maxDistance=Infinity]
 * @return {Array.<number>} Considere multiple points has the same value.
 */


listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {
  var storage = this._storage;
  var dimData = storage[dim];
  var nearestIndices = [];

  if (!dimData) {
    return nearestIndices;
  }

  if (maxDistance == null) {
    maxDistance = Infinity;
  }

  var minDist = Number.MAX_VALUE;
  var minDiff = -1;

  for (var i = 0, len = this.count(); i < len; i++) {
    var diff = value - this.get(dim, i, stack);
    var dist = Math.abs(diff);

    if (diff <= maxDistance && dist <= minDist) {
      // For the case of two data are same on xAxis, which has sequence data.
      // Show the nearest index
      // https://github.com/ecomfe/echarts/issues/2869
      if (dist < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist;
        minDiff = diff;
        nearestIndices.length = 0;
      }

      nearestIndices.push(i);
    }
  }

  return nearestIndices;
};
/**
 * Get raw data index
 * @param {number} idx
 * @return {number}
 */


listProto.getRawIndex = function (idx) {
  var rawIdx = this.indices[idx];
  return rawIdx == null ? -1 : rawIdx;
};
/**
 * Get raw data item
 * @param {number} idx
 * @return {number}
 */


listProto.getRawDataItem = function (idx) {
  return this._rawData.getItem(this.getRawIndex(idx));
};
/**
 * @param {number} idx
 * @param {boolean} [notDefaultIdx=false]
 * @return {string}
 */


listProto.getName = function (idx) {
  return this._nameList[this.indices[idx]] || '';
};
/**
 * @param {number} idx
 * @param {boolean} [notDefaultIdx=false]
 * @return {string}
 */


listProto.getId = function (idx) {
  return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';
};

function normalizeDimensions(dimensions) {
  if (!zrUtil.isArray(dimensions)) {
    dimensions = [dimensions];
  }

  return dimensions;
}
/**
 * Data iteration
 * @param {string|Array.<string>}
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 *
 * @example
 *  list.each('x', function (x, idx) {});
 *  list.each(['x', 'y'], function (x, y, idx) {});
 *  list.each(function (idx) {})
 */


listProto.each = function (dims, cb, stack, context) {
  if (typeof dims === 'function') {
    context = stack;
    stack = cb;
    cb = dims;
    dims = [];
  }

  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);
  var value = [];
  var dimSize = dims.length;
  var indices = this.indices;
  context = context || this;

  for (var i = 0; i < indices.length; i++) {
    // Simple optimization
    switch (dimSize) {
      case 0:
        cb.call(context, i);
        break;

      case 1:
        cb.call(context, this.get(dims[0], i, stack), i);
        break;

      case 2:
        cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);
        break;

      default:
        for (var k = 0; k < dimSize; k++) {
          value[k] = this.get(dims[k], i, stack);
        } // Index


        value[k] = i;
        cb.apply(context, value);
    }
  }
};
/**
 * Data filter
 * @param {string|Array.<string>}
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 */


listProto.filterSelf = function (dimensions, cb, stack, context) {
  if (typeof dimensions === 'function') {
    context = stack;
    stack = cb;
    cb = dimensions;
    dimensions = [];
  }

  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
  var newIndices = [];
  var value = [];
  var dimSize = dimensions.length;
  var indices = this.indices;
  context = context || this;

  for (var i = 0; i < indices.length; i++) {
    var keep; // Simple optimization

    if (!dimSize) {
      keep = cb.call(context, i);
    } else if (dimSize === 1) {
      keep = cb.call(context, this.get(dimensions[0], i, stack), i);
    } else {
      for (var k = 0; k < dimSize; k++) {
        value[k] = this.get(dimensions[k], i, stack);
      }

      value[k] = i;
      keep = cb.apply(context, value);
    }

    if (keep) {
      newIndices.push(indices[i]);
    }
  }

  this.indices = newIndices; // Reset data extent

  this._extent = {};
  return this;
};
/**
 * Data mapping to a plain array
 * @param {string|Array.<string>} [dimensions]
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 * @return {Array}
 */


listProto.mapArray = function (dimensions, cb, stack, context) {
  if (typeof dimensions === 'function') {
    context = stack;
    stack = cb;
    cb = dimensions;
    dimensions = [];
  }

  var result = [];
  this.each(dimensions, function () {
    result.push(cb && cb.apply(this, arguments));
  }, stack, context);
  return result;
};

function cloneListForMapAndSample(original, excludeDimensions) {
  var allDimensions = original.dimensions;
  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked

  transferProperties(list, original);
  var storage = list._storage = {};
  var originalStorage = original._storage; // Init storage

  for (var i = 0; i < allDimensions.length; i++) {
    var dim = allDimensions[i];
    var dimStore = originalStorage[dim];

    if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {
      storage[dim] = new dimStore.constructor(originalStorage[dim].length);
    } else {
      // Direct reference for other dimensions
      storage[dim] = originalStorage[dim];
    }
  }

  return list;
}
/**
 * Data mapping to a new List with given dimensions
 * @param {string|Array.<string>} dimensions
 * @param {Function} cb
 * @param {boolean} [stack=false]
 * @param {*} [context=this]
 * @return {Array}
 */


listProto.map = function (dimensions, cb, stack, context) {
  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.
  // So we can reference to the same value

  var indices = list.indices = this.indices;
  var storage = list._storage;
  var tmpRetValue = [];
  this.each(dimensions, function () {
    var idx = arguments[arguments.length - 1];
    var retValue = cb && cb.apply(this, arguments);

    if (retValue != null) {
      // a number
      if (typeof retValue === 'number') {
        tmpRetValue[0] = retValue;
        retValue = tmpRetValue;
      }

      for (var i = 0; i < retValue.length; i++) {
        var dim = dimensions[i];
        var dimStore = storage[dim];
        var rawIdx = indices[idx];

        if (dimStore) {
          dimStore[rawIdx] = retValue[i];
        }
      }
    }
  }, stack, context);
  return list;
};
/**
 * Large data down sampling on given dimension
 * @param {string} dimension
 * @param {number} rate
 * @param {Function} sampleValue
 * @param {Function} sampleIndex Sample index for name and id
 */


listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {
  var list = cloneListForMapAndSample(this, [dimension]);
  var storage = this._storage;
  var targetStorage = list._storage;
  var originalIndices = this.indices;
  var indices = list.indices = [];
  var frameValues = [];
  var frameIndices = [];
  var frameSize = Math.floor(1 / rate);
  var dimStore = targetStorage[dimension];
  var len = this.count(); // Copy data from original data

  for (var i = 0; i < storage[dimension].length; i++) {
    targetStorage[dimension][i] = storage[dimension][i];
  }

  for (var i = 0; i < len; i += frameSize) {
    // Last frame
    if (frameSize > len - i) {
      frameSize = len - i;
      frameValues.length = frameSize;
    }

    for (var k = 0; k < frameSize; k++) {
      var idx = originalIndices[i + k];
      frameValues[k] = dimStore[idx];
      frameIndices[k] = idx;
    }

    var value = sampleValue(frameValues);
    var idx = frameIndices[sampleIndex(frameValues, value) || 0]; // Only write value on the filtered data

    dimStore[idx] = value;
    indices.push(idx);
  }

  return list;
};
/**
 * Get model of one data item.
 *
 * @param {number} idx
 */
// FIXME Model proxy ?


listProto.getItemModel = function (idx) {
  var hostModel = this.hostModel;
  idx = this.indices[idx];
  return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);
};
/**
 * Create a data differ
 * @param {module:echarts/data/List} otherList
 * @return {module:echarts/data/DataDiffer}
 */


listProto.diff = function (otherList) {
  var idList = this._idList;
  var otherIdList = otherList && otherList._idList;
  var val; // Use prefix to avoid index to be the same as otherIdList[idx],
  // which will cause weird udpate animation.

  var prefix = 'e\0\0';
  return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {
    return (val = otherIdList[idx]) != null ? val : prefix + idx;
  }, function (idx) {
    return (val = idList[idx]) != null ? val : prefix + idx;
  });
};
/**
 * Get visual property.
 * @param {string} key
 */


listProto.getVisual = function (key) {
  var visual = this._visual;
  return visual && visual[key];
};
/**
 * Set visual property
 * @param {string|Object} key
 * @param {*} [value]
 *
 * @example
 *  setVisual('color', color);
 *  setVisual({
 *      'color': color
 *  });
 */


listProto.setVisual = function (key, val) {
  if (isObject(key)) {
    for (var name in key) {
      if (key.hasOwnProperty(name)) {
        this.setVisual(name, key[name]);
      }
    }

    return;
  }

  this._visual = this._visual || {};
  this._visual[key] = val;
};
/**
 * Set layout property.
 * @param {string|Object} key
 * @param {*} [val]
 */


listProto.setLayout = function (key, val) {
  if (isObject(key)) {
    for (var name in key) {
      if (key.hasOwnProperty(name)) {
        this.setLayout(name, key[name]);
      }
    }

    return;
  }

  this._layout[key] = val;
};
/**
 * Get layout property.
 * @param  {string} key.
 * @return {*}
 */


listProto.getLayout = function (key) {
  return this._layout[key];
};
/**
 * Get layout of single data item
 * @param {number} idx
 */


listProto.getItemLayout = function (idx) {
  return this._itemLayouts[idx];
};
/**
 * Set layout of single data item
 * @param {number} idx
 * @param {Object} layout
 * @param {boolean=} [merge=false]
 */


listProto.setItemLayout = function (idx, layout, merge) {
  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;
};
/**
 * Clear all layout of single data item
 */


listProto.clearItemLayouts = function () {
  this._itemLayouts.length = 0;
};
/**
 * Get visual property of single data item
 * @param {number} idx
 * @param {string} key
 * @param {boolean} [ignoreParent=false]
 */


listProto.getItemVisual = function (idx, key, ignoreParent) {
  var itemVisual = this._itemVisuals[idx];
  var val = itemVisual && itemVisual[key];

  if (val == null && !ignoreParent) {
    // Use global visual property
    return this.getVisual(key);
  }

  return val;
};
/**
 * Set visual property of single data item
 *
 * @param {number} idx
 * @param {string|Object} key
 * @param {*} [value]
 *
 * @example
 *  setItemVisual(0, 'color', color);
 *  setItemVisual(0, {
 *      'color': color
 *  });
 */


listProto.setItemVisual = function (idx, key, value) {
  var itemVisual = this._itemVisuals[idx] || {};
  this._itemVisuals[idx] = itemVisual;

  if (isObject(key)) {
    for (var name in key) {
      if (key.hasOwnProperty(name)) {
        itemVisual[name] = key[name];
      }
    }

    return;
  }

  itemVisual[key] = value;
};
/**
 * Clear itemVisuals and list visual.
 */


listProto.clearAllVisual = function () {
  this._visual = {};
  this._itemVisuals = [];
};

var setItemDataAndSeriesIndex = function (child) {
  child.seriesIndex = this.seriesIndex;
  child.dataIndex = this.dataIndex;
  child.dataType = this.dataType;
};
/**
 * Set graphic element relative to data. It can be set as null
 * @param {number} idx
 * @param {module:zrender/Element} [el]
 */


listProto.setItemGraphicEl = function (idx, el) {
  var hostModel = this.hostModel;

  if (el) {
    // Add data index and series index for indexing the data by element
    // Useful in tooltip
    el.dataIndex = idx;
    el.dataType = this.dataType;
    el.seriesIndex = hostModel && hostModel.seriesIndex;

    if (el.type === 'group') {
      el.traverse(setItemDataAndSeriesIndex, el);
    }
  }

  this._graphicEls[idx] = el;
};
/**
 * @param {number} idx
 * @return {module:zrender/Element}
 */


listProto.getItemGraphicEl = function (idx) {
  return this._graphicEls[idx];
};
/**
 * @param {Function} cb
 * @param {*} context
 */


listProto.eachItemGraphicEl = function (cb, context) {
  zrUtil.each(this._graphicEls, function (el, idx) {
    if (el) {
      cb && cb.call(context, el, idx);
    }
  });
};
/**
 * Shallow clone a new list except visual and layout properties, and graph elements.
 * New list only change the indices.
 */


listProto.cloneShallow = function () {
  var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);
  var list = new List(dimensionInfoList, this.hostModel); // FIXME

  list._storage = this._storage;
  transferProperties(list, this); // Clone will not change the data extent and indices

  list.indices = this.indices.slice();

  if (this._extent) {
    list._extent = zrUtil.extend({}, this._extent);
  }

  return list;
};
/**
 * Wrap some method to add more feature
 * @param {string} methodName
 * @param {Function} injectFunction
 */


listProto.wrapMethod = function (methodName, injectFunction) {
  var originalMethod = this[methodName];

  if (typeof originalMethod !== 'function') {
    return;
  }

  this.__wrappedMethods = this.__wrappedMethods || [];

  this.__wrappedMethods.push(methodName);

  this[methodName] = function () {
    var res = originalMethod.apply(this, arguments);
    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));
  };
}; // Methods that create a new list based on this list should be listed here.
// Notice that those method should `RETURN` the new list.


listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.

listProto.CHANGABLE_METHODS = ['filterSelf'];
var _default = List;
module.exports = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var clazzUtil = __webpack_require__(104);

/**
 * // Scale class management
 * @module echarts/scale/Scale
 */

/**
 * @param {Object} [setting]
 */
function Scale(setting) {
  this._setting = setting || {};
  /**
   * Extent
   * @type {Array.<number>}
   * @protected
   */

  this._extent = [Infinity, -Infinity];
  /**
   * Step is calculated in adjustExtent
   * @type {Array.<number>}
   * @protected
   */

  this._interval = 0;
  this.init && this.init.apply(this, arguments);
}
/**
 * Parse input val to valid inner number.
 * @param {*} val
 * @return {number}
 */


Scale.prototype.parse = function (val) {
  // Notice: This would be a trap here, If the implementation
  // of this method depends on extent, and this method is used
  // before extent set (like in dataZoom), it would be wrong.
  // Nevertheless, parse does not depend on extent generally.
  return val;
};

Scale.prototype.getSetting = function (name) {
  return this._setting[name];
};

Scale.prototype.contain = function (val) {
  var extent = this._extent;
  return val >= extent[0] && val <= extent[1];
};
/**
 * Normalize value to linear [0, 1], return 0.5 if extent span is 0
 * @param {number} val
 * @return {number}
 */


Scale.prototype.normalize = function (val) {
  var extent = this._extent;

  if (extent[1] === extent[0]) {
    return 0.5;
  }

  return (val - extent[0]) / (extent[1] - extent[0]);
};
/**
 * Scale normalized value
 * @param {number} val
 * @return {number}
 */


Scale.prototype.scale = function (val) {
  var extent = this._extent;
  return val * (extent[1] - extent[0]) + extent[0];
};
/**
 * Set extent from data
 * @param {Array.<number>} other
 */


Scale.prototype.unionExtent = function (other) {
  var extent = this._extent;
  other[0] < extent[0] && (extent[0] = other[0]);
  other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power
  // this.setExtent(extent[0], extent[1]);
};
/**
 * Set extent from data
 * @param {module:echarts/data/List} data
 * @param {string} dim
 */


Scale.prototype.unionExtentFromData = function (data, dim) {
  this.unionExtent(data.getDataExtent(dim, true));
};
/**
 * Get extent
 * @return {Array.<number>}
 */


Scale.prototype.getExtent = function () {
  return this._extent.slice();
};
/**
 * Set extent
 * @param {number} start
 * @param {number} end
 */


Scale.prototype.setExtent = function (start, end) {
  var thisExtent = this._extent;

  if (!isNaN(start)) {
    thisExtent[0] = start;
  }

  if (!isNaN(end)) {
    thisExtent[1] = end;
  }
};
/**
 * @return {Array.<string>}
 */


Scale.prototype.getTicksLabels = function () {
  var labels = [];
  var ticks = this.getTicks();

  for (var i = 0; i < ticks.length; i++) {
    labels.push(this.getLabel(ticks[i]));
  }

  return labels;
};
/**
 * When axis extent depends on data and no data exists,
 * axis ticks should not be drawn, which is named 'blank'.
 */


Scale.prototype.isBlank = function () {
  return this._isBlank;
},
/**
 * When axis extent depends on data and no data exists,
 * axis ticks should not be drawn, which is named 'blank'.
 */
Scale.prototype.setBlank = function (isBlank) {
  this._isBlank = isBlank;
};
clazzUtil.enableClassExtend(Scale);
clazzUtil.enableClassManagement(Scale, {
  registerWhenExtend: true
});
var _default = Scale;
module.exports = _default;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Model = __webpack_require__(102);

var each = zrUtil.each;
var curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
// allAxesInfo should be updated when setOption performed.

function collect(ecModel, api) {
  var result = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: false,

    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.

  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}

function collectAxesInfo(result, ecModel, api) {
  var globalTooltipModel = ecModel.getComponent('tooltip');
  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.

  var linksOption = globalAxisPointerModel.get('link', true) || [];
  var linkGroups = []; // Collect axes info.

  each(api.getCoordinateSystems(), function (coordSys) {
    // Some coordinate system do not support axes, like geo.
    if (!coordSys.axisPointerEnabled) {
      return;
    }

    var coordSysKey = makeKey(coordSys.model);
    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer
    // for user. So we enable seting tooltip on coordSys model.

    var coordSysModel = coordSys.model;
    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);
    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.
    // Notice this case: coordSys is `grid` but not `cartesian2D` here.

    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not
    // show but axisPointer will show as normal.
    && baseTooltipModel.get('show')) {
      // Compatible with previous logic. But series.tooltip.trigger: 'axis'
      // or series.data[n].tooltip.trigger: 'axis' are not support any more.
      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';
      var cross = baseTooltipModel.get('axisPointer.type') === 'cross';
      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));

      if (triggerAxis || cross) {
        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));
      }

      if (cross) {
        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));
      }
    } // fromTooltip: true | false | 'cross'
    // triggerTooltip: true | false | null


    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);
      var axisPointerShow = axisPointerModel.get('show');

      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }

      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get('triggerTooltip');
      }

      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      var snap = axisPointerModel.get('snap');
      var key = makeKey(axis.model);
      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).

      var axisInfo = result.axesInfo[key] = {
        key: key,
        axis: axis,
        coordSys: coordSys,
        axisPointerModel: axisPointerModel,
        triggerTooltip: triggerTooltip,
        involveSeries: involveSeries,
        snap: snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: []
      };
      axesInfoInCoordSys[key] = axisInfo;
      result.seriesInvolved |= involveSeries;
      var groupIndex = getLinkGroupIndex(linksOption, axis);

      if (groupIndex != null) {
        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
          axesInfo: {}
        });
        linkGroup.axesInfo[key] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}

function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');
  var volatileOption = {};
  each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {
    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));
  }); // category axis do not auto snap, otherwise some tick that do not
  // has value can not be hovered. value/time/log axis default snap if
  // triggered from tooltip and trigger tooltip.

  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.
  // Only these properties can be overrided from tooltip to axisPointer.

  if (tooltipAxisPointerModel.get('type') === 'cross') {
    volatileOption.type = 'line';
  }

  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.

  labelOption.show == null && (labelOption.show = false);

  if (fromTooltip === 'cross') {
    // When 'cross', both axes show labels.
    labelOption.show = true; // If triggerTooltip, this is a base axis, which should better not use cross style
    // (cross style is dashed by default)

    if (!triggerTooltip) {
      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');
      crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);
    }
  }

  return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));
}

function collectSeriesInfo(result, ecModel) {
  // Prepare data for axis trigger
  ecModel.eachSeries(function (seriesModel) {
    // Notice this case: this coordSys is `cartesian2D` but not `grid`.
    var coordSys = seriesModel.coordinateSystem;
    var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);
    var seriesTooltipShow = seriesModel.get('tooltip.show', true);

    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {
      return;
    }

    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
      var axis = axisInfo.axis;

      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  }, this);
}
/**
 * For example:
 * {
 *     axisPointer: {
 *         links: [{
 *             xAxisIndex: [2, 4],
 *             yAxisIndex: 'all'
 *         }, {
 *             xAxisId: ['a5', 'a7'],
 *             xAxisName: 'xxx'
 *         }]
 *     }
 * }
 */


function getLinkGroupIndex(linksOption, axis) {
  var axisModel = axis.model;
  var dim = axis.dim;

  for (var i = 0; i < linksOption.length; i++) {
    var linkOption = linksOption[i] || {};

    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
      return i;
    }
  }
}

function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}

function fixValue(axisModel) {
  var axisInfo = getAxisInfo(axisModel);

  if (!axisInfo) {
    return;
  }

  var axisPointerModel = axisInfo.axisPointerModel;
  var scale = axisInfo.axis.scale;
  var option = axisPointerModel.option;
  var status = axisPointerModel.get('status');
  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.

  if (value != null) {
    value = scale.parse(value);
  }

  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value
  // and status should be initialized.

  if (status == null) {
    option.status = useHandle ? 'show' : 'hide';
  }

  var extent = scale.getExtent().slice();
  extent[0] > extent[1] && extent.reverse();

  if ( // Pick a value on axis when initializing.
  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,
  // where we should re-pick a value to keep `handle` displaying normally.
  || value > extent[1]) {
    // Make handle displayed on the end of the axis when init, which looks better.
    value = extent[1];
  }

  if (value < extent[0]) {
    value = extent[0];
  }

  option.value = value;

  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';
  }
}

function getAxisInfo(axisModel) {
  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}

function getAxisPointerModel(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}

function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get('handle.show');
}
/**
 * @param {module:echarts/model/Model} model
 * @return {string} unique key
 */


function makeKey(model) {
  return model.type + '||' + model.id;
}

exports.collect = collect;
exports.fixValue = fixValue;
exports.getAxisInfo = getAxisInfo;
exports.getAxisPointerModel = getAxisPointerModel;
exports.makeKey = makeKey;

/***/ }),
/* 126 */
/***/ (function(module, exports) {

// https://github.com/mziccard/node-timsort
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
var DEFAULT_TMP_STORAGE_LENGTH = 256;

function minRunLength(n) {
  var r = 0;

  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }

  return n + r;
}

function makeAscendingRun(array, lo, hi, compare) {
  var runHi = lo + 1;

  if (runHi === hi) {
    return 1;
  }

  if (compare(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }

    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }

  return runHi - lo;
}

function reverseRun(array, lo, hi) {
  hi--;

  while (lo < hi) {
    var t = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t;
  }
}

function binaryInsertionSort(array, lo, hi, start, compare) {
  if (start === lo) {
    start++;
  }

  for (; start < hi; start++) {
    var pivot = array[start];
    var left = lo;
    var right = start;
    var mid;

    while (left < right) {
      mid = left + right >>> 1;

      if (compare(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }

    var n = start - left;

    switch (n) {
      case 3:
        array[left + 3] = array[left + 2];

      case 2:
        array[left + 2] = array[left + 1];

      case 1:
        array[left + 1] = array[left];
        break;

      default:
        while (n > 0) {
          array[left + n] = array[left + n - 1];
          n--;
        }

    }

    array[left] = pivot;
  }
}

function gallopLeft(value, array, start, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;

  if (compare(value, array[start + hint]) > 0) {
    maxOffset = length - hint;

    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;

    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }

  lastOffset++;

  while (lastOffset < offset) {
    var m = lastOffset + (offset - lastOffset >>> 1);

    if (compare(value, array[start + m]) > 0) {
      lastOffset = m + 1;
    } else {
      offset = m;
    }
  }

  return offset;
}

function gallopRight(value, array, start, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;

  if (compare(value, array[start + hint]) < 0) {
    maxOffset = hint + 1;

    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length - hint;

    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    lastOffset += hint;
    offset += hint;
  }

  lastOffset++;

  while (lastOffset < offset) {
    var m = lastOffset + (offset - lastOffset >>> 1);

    if (compare(value, array[start + m]) < 0) {
      offset = m;
    } else {
      lastOffset = m + 1;
    }
  }

  return offset;
}

function TimSort(array, compare) {
  var minGallop = DEFAULT_MIN_GALLOPING;
  var length = 0;
  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
  var stackLength = 0;
  var runStart;
  var runLength;
  var stackSize = 0;
  length = array.length;

  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
    tmpStorageLength = length >>> 1;
  }

  var tmp = [];
  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
  runStart = [];
  runLength = [];

  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }

  function mergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;

      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
        if (runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
      } else if (runLength[n] > runLength[n + 1]) {
        break;
      }

      mergeAt(n);
    }
  }

  function forceMergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;

      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
        n--;
      }

      mergeAt(n);
    }
  }

  function mergeAt(i) {
    var start1 = runStart[i];
    var length1 = runLength[i];
    var start2 = runStart[i + 1];
    var length2 = runLength[i + 1];
    runLength[i] = length1 + length2;

    if (i === stackSize - 3) {
      runStart[i + 1] = runStart[i + 2];
      runLength[i + 1] = runLength[i + 2];
    }

    stackSize--;
    var k = gallopRight(array[start2], array, start1, length1, 0, compare);
    start1 += k;
    length1 -= k;

    if (length1 === 0) {
      return;
    }

    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

    if (length2 === 0) {
      return;
    }

    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }

  function mergeLow(start1, length1, start2, length2) {
    var i = 0;

    for (i = 0; i < length1; i++) {
      tmp[i] = array[start1 + i];
    }

    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];

    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }

      return;
    }

    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }

      array[dest + length2] = tmp[cursor1];
      return;
    }

    var _minGallop = minGallop;
    var count1, count2, exit;

    while (1) {
      count1 = 0;
      count2 = 0;
      exit = false;

      do {
        if (compare(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count2++;
          count1 = 0;

          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;

          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);

      if (exit) {
        break;
      }

      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }

          dest += count1;
          cursor1 += count1;
          length1 -= count1;

          if (length1 <= 1) {
            exit = true;
            break;
          }
        }

        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
          exit = true;
          break;
        }

        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          dest += count2;
          cursor2 += count2;
          length2 -= count2;

          if (length2 === 0) {
            exit = true;
            break;
          }
        }

        array[dest++] = tmp[cursor1++];

        if (--length1 === 1) {
          exit = true;
          break;
        }

        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

      if (exit) {
        break;
      }

      if (_minGallop < 0) {
        _minGallop = 0;
      }

      _minGallop += 2;
    }

    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);

    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }

      array[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error(); // throw new Error('mergeLow preconditions were not respected');
    } else {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
    }
  }

  function mergeHigh(start1, length1, start2, length2) {
    var i = 0;

    for (i = 0; i < length2; i++) {
      tmp[i] = array[start2 + i];
    }

    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];

    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);

      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }

      return;
    }

    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;

      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }

      array[dest] = tmp[cursor2];
      return;
    }

    var _minGallop = minGallop;

    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;

      do {
        if (compare(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count2 = 0;

          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;

          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);

      if (exit) {
        break;
      }

      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = count1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          if (length1 === 0) {
            exit = true;
            break;
          }
        }

        array[dest--] = tmp[cursor2--];

        if (--length2 === 1) {
          exit = true;
          break;
        }

        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;

          for (i = 0; i < count2; i++) {
            array[customDest + i] = tmp[customCursor + i];
          }

          if (length2 <= 1) {
            exit = true;
            break;
          }
        }

        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
          exit = true;
          break;
        }

        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

      if (exit) {
        break;
      }

      if (_minGallop < 0) {
        _minGallop = 0;
      }

      _minGallop += 2;
    }

    minGallop = _minGallop;

    if (minGallop < 1) {
      minGallop = 1;
    }

    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;

      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }

      array[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
    } else {
      customCursor = dest - (length2 - 1);

      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
    }
  }

  this.mergeRuns = mergeRuns;
  this.forceMergeRuns = forceMergeRuns;
  this.pushRun = pushRun;
}

function sort(array, compare, lo, hi) {
  if (!lo) {
    lo = 0;
  }

  if (!hi) {
    hi = array.length;
  }

  var remaining = hi - lo;

  if (remaining < 2) {
    return;
  }

  var runLength = 0;

  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
    return;
  }

  var ts = new TimSort(array, compare);
  var minRun = minRunLength(remaining);

  do {
    runLength = makeAscendingRun(array, lo, hi, compare);

    if (runLength < minRun) {
      var force = remaining;

      if (force > minRun) {
        force = minRun;
      }

      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
      runLength = force;
    }

    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);

  ts.forceMergeRuns();
}

module.exports = sort;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Style = __webpack_require__(145);

var Element = __webpack_require__(140);

var RectText = __webpack_require__(193);

/**
 * 可绘制的图形基类
 * Base class of all displayable graphic objects
 * @module zrender/graphic/Displayable
 */

/**
 * @alias module:zrender/graphic/Displayable
 * @extends module:zrender/Element
 * @extends module:zrender/graphic/mixin/RectText
 */
function Displayable(opts) {
  opts = opts || {};
  Element.call(this, opts); // Extend properties

  for (var name in opts) {
    if (opts.hasOwnProperty(name) && name !== 'style') {
      this[name] = opts[name];
    }
  }
  /**
   * @type {module:zrender/graphic/Style}
   */


  this.style = new Style(opts.style, this);
  this._rect = null; // Shapes for cascade clipping.

  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted
  // Stateful.call(this, opts);
}

Displayable.prototype = {
  constructor: Displayable,
  type: 'displayable',

  /**
   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
   * Dirty flag. From which painter will determine if this displayable object needs brush
   * @name module:zrender/graphic/Displayable#__dirty
   * @type {boolean}
   */
  __dirty: true,

  /**
   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
   * If ignore drawing of the displayable object. Mouse event will still be triggered
   * @name module:/zrender/graphic/Displayable#invisible
   * @type {boolean}
   * @default false
   */
  invisible: false,

  /**
   * @name module:/zrender/graphic/Displayable#z
   * @type {number}
   * @default 0
   */
  z: 0,

  /**
   * @name module:/zrender/graphic/Displayable#z
   * @type {number}
   * @default 0
   */
  z2: 0,

  /**
   * z层level，决定绘画在哪层canvas中
   * @name module:/zrender/graphic/Displayable#zlevel
   * @type {number}
   * @default 0
   */
  zlevel: 0,

  /**
   * 是否可拖拽
   * @name module:/zrender/graphic/Displayable#draggable
   * @type {boolean}
   * @default false
   */
  draggable: false,

  /**
   * 是否正在拖拽
   * @name module:/zrender/graphic/Displayable#draggable
   * @type {boolean}
   * @default false
   */
  dragging: false,

  /**
   * 是否相应鼠标事件
   * @name module:/zrender/graphic/Displayable#silent
   * @type {boolean}
   * @default false
   */
  silent: false,

  /**
   * If enable culling
   * @type {boolean}
   * @default false
   */
  culling: false,

  /**
   * Mouse cursor when hovered
   * @name module:/zrender/graphic/Displayable#cursor
   * @type {string}
   */
  cursor: 'pointer',

  /**
   * If hover area is bounding rect
   * @name module:/zrender/graphic/Displayable#rectHover
   * @type {string}
   */
  rectHover: false,

  /**
   * Render the element progressively when the value >= 0,
   * usefull for large data.
   * @type {number}
   */
  progressive: -1,
  beforeBrush: function (ctx) {},
  afterBrush: function (ctx) {},

  /**
   * 图形绘制方法
   * @param {CanvasRenderingContext2D} ctx
   */
  // Interface
  brush: function (ctx, prevEl) {},

  /**
   * 获取最小包围盒
   * @return {module:zrender/core/BoundingRect}
   */
  // Interface
  getBoundingRect: function () {},

  /**
   * 判断坐标 x, y 是否在图形上
   * If displayable element contain coord x, y
   * @param  {number} x
   * @param  {number} y
   * @return {boolean}
   */
  contain: function (x, y) {
    return this.rectContain(x, y);
  },

  /**
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {
    cb.call(context, this);
  },

  /**
   * 判断坐标 x, y 是否在图形的包围盒上
   * If bounding rect of element contain coord x, y
   * @param  {number} x
   * @param  {number} y
   * @return {boolean}
   */
  rectContain: function (x, y) {
    var coord = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  },

  /**
   * 标记图形元素为脏，并且在下一帧重绘
   * Mark displayable element dirty and refresh next frame
   */
  dirty: function () {
    this.__dirty = true;
    this._rect = null;
    this.__zr && this.__zr.refresh();
  },

  /**
   * 图形是否会触发事件
   * If displayable object binded any event
   * @return {boolean}
   */
  // TODO, 通过 bind 绑定的事件
  // isSilent: function () {
  //     return !(
  //         this.hoverable || this.draggable
  //         || this.onmousemove || this.onmouseover || this.onmouseout
  //         || this.onmousedown || this.onmouseup || this.onclick
  //         || this.ondragenter || this.ondragover || this.ondragleave
  //         || this.ondrop
  //     );
  // },

  /**
   * Alias for animate('style')
   * @param {boolean} loop
   */
  animateStyle: function (loop) {
    return this.animate('style', loop);
  },
  attrKV: function (key, value) {
    if (key !== 'style') {
      Element.prototype.attrKV.call(this, key, value);
    } else {
      this.style.set(value);
    }
  },

  /**
   * @param {Object|string} key
   * @param {*} value
   */
  setStyle: function (key, value) {
    this.style.set(key, value);
    this.dirty(false);
    return this;
  },

  /**
   * Use given style object
   * @param  {Object} obj
   */
  useStyle: function (obj) {
    this.style = new Style(obj, this);
    this.dirty(false);
    return this;
  }
};
zrUtil.inherits(Displayable, Element);
zrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);

var _default = Displayable;
module.exports = _default;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var LRU = __webpack_require__(143);

var globalImageCache = new LRU(50);
/**
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */

function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === 'string') {
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
/**
 * Caution: User should cache loaded images, but not just count on LRU.
 * Consider if required images more than LRU size, will dead loop occur?
 *
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
 * @param {Function} [cb] params: (image, cbPayload)
 * @param {Object} [cbPayload] Payload on cb calling.
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */


function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === 'string') {
    // Image should not be loaded repeatly.
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    } // Only when there is no existent image or existent image src
    // is different, this method is responsible for load.


    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    var pendingWrap = {
      hostEl: hostEl,
      cb: cb,
      cbPayload: cbPayload
    };

    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      !image && (image = new Image());
      image.onload = imageOnLoad;
      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
        image: image,
        pending: [pendingWrap]
      });
      image.src = image.__zrImageSrc = newImageOrSrc;
    }

    return image;
  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
  else {
      return newImageOrSrc;
    }
}

function imageOnLoad() {
  var cachedImgObj = this.__cachedImgObj;
  this.onload = this.__cachedImgObj = null;

  for (var i = 0; i < cachedImgObj.pending.length; i++) {
    var pendingWrap = cachedImgObj.pending[i];
    var cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }

  cachedImgObj.pending.length = 0;
}

function isImageReady(image) {
  return image && image.width && image.height;
}

exports.findExistImage = findExistImage;
exports.createOrUpdateImage = createOrUpdateImage;
exports.isImageReady = isImageReady;

/***/ }),
/* 129 */
/***/ (function(module, exports) {

/**
 * @param {Array.<Object>} colorStops
 */
var Gradient = function (colorStops) {
  this.colorStops = colorStops || [];
};

Gradient.prototype = {
  constructor: Gradient,
  addColorStop: function (offset, color) {
    this.colorStops.push({
      offset: offset,
      color: color
    });
  }
};
var _default = Gradient;
module.exports = _default;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var _clazz = __webpack_require__(104);

var parseClassType = _clazz.parseClassType;
var base = 0;
var DELIMITER = '_';
/**
 * @public
 * @param {string} type
 * @return {string}
 */

function getUID(type) {
  // Considering the case of crossing js context,
  // use Math.random to make id as unique as possible.
  return [type || '', base++, Math.random()].join(DELIMITER);
}
/**
 * @inner
 */


function enableSubTypeDefaulter(entity) {
  var subTypeDefaulters = {};

  entity.registerSubTypeDefaulter = function (componentType, defaulter) {
    componentType = parseClassType(componentType);
    subTypeDefaulters[componentType.main] = defaulter;
  };

  entity.determineSubType = function (componentType, option) {
    var type = option.type;

    if (!type) {
      var componentTypeMain = parseClassType(componentType).main;

      if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }

    return type;
  };

  return entity;
}
/**
 * Topological travel on Activity Network (Activity On Vertices).
 * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
 *
 * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
 *
 * If there is circle dependencey, Error will be thrown.
 *
 */


function enableTopologicalTravel(entity, dependencyGetter) {
  /**
   * @public
   * @param {Array.<string>} targetNameList Target Component type list.
   *                                           Can be ['aa', 'bb', 'aa.xx']
   * @param {Array.<string>} fullNameList By which we can build dependency graph.
   * @param {Function} callback Params: componentType, dependencies.
   * @param {Object} context Scope of callback.
   */
  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }

    var result = makeDepndencyGraph(fullNameList);
    var graph = result.graph;
    var stack = result.noEntryList;
    var targetNameSet = {};
    zrUtil.each(targetNameList, function (name) {
      targetNameSet[name] = true;
    });

    while (stack.length) {
      var currComponentType = stack.pop();
      var currVertex = graph[currComponentType];
      var isInTargetNameSet = !!targetNameSet[currComponentType];

      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }

      zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }

    zrUtil.each(targetNameSet, function () {
      throw new Error('Circle dependency may exists');
    });

    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;

      if (graph[succComponentType].entryCount === 0) {
        stack.push(succComponentType);
      }
    } // Consider this case: legend depends on series, and we call
    // chart.setOption({series: [...]}), where only series is in option.
    // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
    // not be called, but only sereis.mergeOption is called. Thus legend
    // have no chance to update its local record about series (like which
    // name of series is available in legend).


    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  /**
   * DepndencyGraph: {Object}
   * key: conponentType,
   * value: {
   *     successor: [conponentTypes...],
   *     originalDeps: [conponentTypes...],
   *     entryCount: {number}
   * }
   */


  function makeDepndencyGraph(fullNameList) {
    var graph = {};
    var noEntryList = [];
    zrUtil.each(fullNameList, function (name) {
      var thisItem = createDependencyGraphItem(graph, name);
      var originalDeps = thisItem.originalDeps = dependencyGetter(name);
      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;

      if (thisItem.entryCount === 0) {
        noEntryList.push(name);
      }

      zrUtil.each(availableDeps, function (dependentName) {
        if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }

        var thatItem = createDependencyGraphItem(graph, dependentName);

        if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name);
        }
      });
    });
    return {
      graph: graph,
      noEntryList: noEntryList
    };
  }

  function createDependencyGraphItem(graph, name) {
    if (!graph[name]) {
      graph[name] = {
        predecessor: [],
        successor: []
      };
    }

    return graph[name];
  }

  function getAvailableDependencies(originalDeps, fullNameList) {
    var availableDeps = [];
    zrUtil.each(originalDeps, function (dep) {
      zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}

exports.getUID = getUID;
exports.enableSubTypeDefaulter = enableSubTypeDefaulter;
exports.enableTopologicalTravel = enableTopologicalTravel;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var coordinateSystemCreators = {};

function CoordinateSystemManager() {
  this._coordinateSystems = [];
}

CoordinateSystemManager.prototype = {
  constructor: CoordinateSystemManager,
  create: function (ecModel, api) {
    var coordinateSystems = [];
    zrUtil.each(coordinateSystemCreators, function (creater, type) {
      var list = creater.create(ecModel, api);
      coordinateSystems = coordinateSystems.concat(list || []);
    });
    this._coordinateSystems = coordinateSystems;
  },
  update: function (ecModel, api) {
    zrUtil.each(this._coordinateSystems, function (coordSys) {
      // FIXME MUST have
      coordSys.update && coordSys.update(ecModel, api);
    });
  },
  getCoordinateSystems: function () {
    return this._coordinateSystems.slice();
  }
};

CoordinateSystemManager.register = function (type, coordinateSystemCreator) {
  coordinateSystemCreators[type] = coordinateSystemCreator;
};

CoordinateSystemManager.get = function (type) {
  return coordinateSystemCreators[type];
};

var _default = CoordinateSystemManager;
module.exports = _default;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__(91);

var env = __webpack_require__(98);

var _format = __webpack_require__(99);

var formatTime = _format.formatTime;
var encodeHTML = _format.encodeHTML;
var addCommas = _format.addCommas;
var getTooltipMarker = _format.getTooltipMarker;

var _clazz = __webpack_require__(104);

var set = _clazz.set;
var get = _clazz.get;

var modelUtil = __webpack_require__(95);

var ComponentModel = __webpack_require__(105);

var colorPaletteMixin = __webpack_require__(156);

var _layout = __webpack_require__(103);

var getLayoutParams = _layout.getLayoutParams;
var mergeLayoutParam = _layout.mergeLayoutParam;
var SeriesModel = ComponentModel.extend({
  type: 'series.__base__',

  /**
   * @readOnly
   */
  seriesIndex: 0,
  // coodinateSystem will be injected in the echarts/CoordinateSystem
  coordinateSystem: null,

  /**
   * @type {Object}
   * @protected
   */
  defaultOption: null,

  /**
   * Data provided for legend
   * @type {Function}
   */
  // PENDING
  legendDataProvider: null,

  /**
   * Access path of color for visual
   */
  visualColorAccessPath: 'itemStyle.normal.color',

  /**
   * Support merge layout params.
   * Only support 'box' now (left/right/top/bottom/width/height).
   * @type {string|Object} Object can be {ignoreSize: true}
   * @readOnly
   */
  layoutMode: null,
  init: function (option, parentModel, ecModel, extraOpt) {
    /**
     * @type {number}
     * @readOnly
     */
    this.seriesIndex = this.componentIndex;
    this.mergeDefaultAndTheme(option, ecModel);
    var data = this.getInitialData(option, ecModel);

    /**
     * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}
     * @private
     */
    set(this, 'dataBeforeProcessed', data); // If we reverse the order (make data firstly, and then make
    // dataBeforeProcessed by cloneShallow), cloneShallow will
    // cause data.graph.data !== data when using
    // module:echarts/data/Graph or module:echarts/data/Tree.
    // See module:echarts/data/helper/linkList

    this.restoreData();
  },

  /**
   * Util for merge default and theme to option
   * @param  {Object} option
   * @param  {module:echarts/model/Global} ecModel
   */
  mergeDefaultAndTheme: function (option, ecModel) {
    var layoutMode = this.layoutMode;
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {}; // Backward compat: using subType on theme.
    // But if name duplicate between series subType
    // (for example: parallel) add component mainType,
    // add suffix 'Series'.

    var themeSubType = this.subType;

    if (ComponentModel.hasClass(themeSubType)) {
      themeSubType += 'Series';
    }

    zrUtil.merge(option, ecModel.getTheme().get(this.subType));
    zrUtil.merge(option, this.getDefaultOption()); // Default label emphasis `show`

    modelUtil.defaultEmphasis(option.label, ['show']);
    this.fillDataTextStyle(option.data);

    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  },
  mergeOption: function (newSeriesOption, ecModel) {
    newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    var layoutMode = this.layoutMode;

    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }

    var data = this.getInitialData(newSeriesOption, ecModel); // TODO Merge data?

    if (data) {
      set(this, 'data', data);
      set(this, 'dataBeforeProcessed', data.cloneShallow());
    }
  },
  fillDataTextStyle: function (data) {
    // Default data label emphasis `show`
    // FIXME Tree structure data ?
    // FIXME Performance ?
    if (data) {
      var props = ['show'];

      for (var i = 0; i < data.length; i++) {
        if (data[i] && data[i].label) {
          modelUtil.defaultEmphasis(data[i].label, props);
        }
      }
    }
  },

  /**
   * Init a data structure from data related option in series
   * Must be overwritten
   */
  getInitialData: function () {},

  /**
   * @param {string} [dataType]
   * @return {module:echarts/data/List}
   */
  getData: function (dataType) {
    var data = get(this, 'data');
    return dataType == null ? data : data.getLinkedData(dataType);
  },

  /**
   * @param {module:echarts/data/List} data
   */
  setData: function (data) {
    set(this, 'data', data);
  },

  /**
   * Get data before processed
   * @return {module:echarts/data/List}
   */
  getRawData: function () {
    return get(this, 'dataBeforeProcessed');
  },

  /**
   * Coord dimension to data dimension.
   *
   * By default the result is the same as dimensions of series data.
   * But in some series data dimensions are different from coord dimensions (i.e.
   * candlestick and boxplot). Override this method to handle those cases.
   *
   * Coord dimension to data dimension can be one-to-many
   *
   * @param {string} coordDim
   * @return {Array.<string>} dimensions on the axis.
   */
  coordDimToDataDim: function (coordDim) {
    return modelUtil.coordDimToDataDim(this.getData(), coordDim);
  },

  /**
   * Convert data dimension to coord dimension.
   *
   * @param {string|number} dataDim
   * @return {string}
   */
  dataDimToCoordDim: function (dataDim) {
    return modelUtil.dataDimToCoordDim(this.getData(), dataDim);
  },

  /**
   * Get base axis if has coordinate system and has axis.
   * By default use coordSys.getBaseAxis();
   * Can be overrided for some chart.
   * @return {type} description
   */
  getBaseAxis: function () {
    var coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  },
  // FIXME

  /**
   * Default tooltip formatter
   *
   * @param {number} dataIndex
   * @param {boolean} [multipleSeries=false]
   * @param {number} [dataType]
   */
  formatTooltip: function (dataIndex, multipleSeries, dataType) {
    function formatArrayValue(value) {
      var vertially = zrUtil.reduce(value, function (vertially, val, idx) {
        var dimItem = data.getDimensionInfo(idx);
        return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;
      }, 0);
      var result = [];
      var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');
      tooltipDims.length ? zrUtil.each(tooltipDims, function (dimIdx) {
        setEachItem(data.get(dimIdx, dataIndex), dimIdx);
      }) // By default, all dims is used on tooltip.
      : zrUtil.each(value, setEachItem);

      function setEachItem(val, dimIdx) {
        var dimInfo = data.getDimensionInfo(dimIdx); // If `dimInfo.tooltip` is not set, show tooltip.

        if (!dimInfo || dimInfo.otherDims.tooltip === false) {
          return;
        }

        var dimType = dimInfo.type;
        var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '') + (dimType === 'ordinal' ? val + '' : dimType === 'time' ? multipleSeries ? '' : formatTime('yyyy/MM/dd hh:mm:ss', val) : addCommas(val));
        valStr && result.push(encodeHTML(valStr));
      }

      return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');
    }

    var data = get(this, 'data');
    var value = this.getRawValue(dataIndex);
    var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : encodeHTML(addCommas(value));
    var name = data.getName(dataIndex);
    var color = data.getItemVisual(dataIndex, 'color');

    if (zrUtil.isObject(color) && color.colorStops) {
      color = (color.colorStops[0] || {}).color;
    }

    color = color || 'transparent';
    var colorEl = getTooltipMarker(color);
    var seriesName = this.name; // FIXME

    if (seriesName === '\0-') {
      // Not show '-'
      seriesName = '';
    }

    seriesName = seriesName ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ') : '';
    return !multipleSeries ? seriesName + colorEl + (name ? encodeHTML(name) + ': ' + formattedValue : formattedValue) : colorEl + seriesName + formattedValue;
  },

  /**
   * @return {boolean}
   */
  isAnimationEnabled: function () {
    if (env.node) {
      return false;
    }

    var animationEnabled = this.getShallow('animation');

    if (animationEnabled) {
      if (this.getData().count() > this.getShallow('animationThreshold')) {
        animationEnabled = false;
      }
    }

    return animationEnabled;
  },
  restoreData: function () {
    set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());
  },
  getColorFromPalette: function (name, scope) {
    var ecModel = this.ecModel; // PENDING

    var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);

    if (!color) {
      color = ecModel.getColorFromPalette(name, scope);
    }

    return color;
  },

  /**
   * Get data indices for show tooltip content. See tooltip.
   * @abstract
   * @param {Array.<string>|string} dim
   * @param {Array.<number>} value
   * @param {module:echarts/coord/single/SingleAxis} baseAxis
   * @return {Object} {dataIndices, nestestValue}.
   */
  getAxisTooltipData: null,

  /**
   * See tooltip.
   * @abstract
   * @param {number} dataIndex
   * @return {Array.<number>} Point of tooltip. null/undefined can be returned.
   */
  getTooltipPosition: null
});
zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);
zrUtil.mixin(SeriesModel, colorPaletteMixin);
var _default = SeriesModel;
module.exports = _default;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__(91);

var List = __webpack_require__(123);

var completeDimensions = __webpack_require__(159);

var _model = __webpack_require__(95);

var getDataItemValue = _model.getDataItemValue;
var converDataValue = _model.converDataValue;
var isDataItemOption = _model.isDataItemOption;

var CoordinateSystem = __webpack_require__(131);

function firstDataNotNull(data) {
  var i = 0;

  while (i < data.length && data[i] == null) {
    i++;
  }

  return data[i];
}

function ifNeedCompleteOrdinalData(data) {
  var sampleItem = firstDataNotNull(data);
  return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));
}
/**
 * Helper function to create a list from option data
 */


function createListFromArray(data, seriesModel, ecModel) {
  // If data is undefined
  data = data || [];
  var coordSysName = seriesModel.get('coordinateSystem');
  var creator = creators[coordSysName];
  var registeredCoordSys = CoordinateSystem.get(coordSysName);
  var completeDimOpt = {
    encodeDef: seriesModel.get('encode'),
    dimsDef: seriesModel.get('dimensions')
  }; // FIXME

  var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);
  var dimensions = axesInfo && axesInfo.dimensions;

  if (!dimensions) {
    // Get dimensions from registered coordinate system
    dimensions = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];
    dimensions = completeDimensions(dimensions, data, completeDimOpt);
  }

  var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;
  var list = new List(dimensions, seriesModel);
  var nameList = createNameList(axesInfo, data);
  var categories = {};
  var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {
    // If any dataItem is like { value: 10 }
    if (isDataItemOption(itemOpt)) {
      list.hasItemOption = true;
    } // Use dataIndex as ordinal value in categoryAxis


    return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);
  } : function (itemOpt, dimName, dataIndex, dimIndex) {
    var value = getDataItemValue(itemOpt);
    var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]); // If any dataItem is like { value: 10 }

    if (isDataItemOption(itemOpt)) {
      list.hasItemOption = true;
    }

    var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;

    if (categoryAxesModels && categoryAxesModels[dimName]) {
      // If given value is a category string
      if (typeof val === 'string') {
        // Lazy get categories
        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();
        val = zrUtil.indexOf(categories[dimName], val);

        if (val < 0 && !isNaN(val)) {
          // In case some one write '1', '2' istead of 1, 2
          val = +val;
        }
      }
    }

    return val;
  };
  list.hasItemOption = false;
  list.initData(data, nameList, dimValueGetter);
  return list;
}

function isStackable(axisType) {
  return axisType !== 'category' && axisType !== 'time';
}

function getDimTypeByAxis(axisType) {
  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';
}
/**
 * Creaters for each coord system.
 */


var creators = {
  cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {
    var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {
      return ecModel.queryComponents({
        mainType: name,
        index: seriesModel.get(name + 'Index'),
        id: seriesModel.get(name + 'Id')
      })[0];
    });
    var xAxisModel = axesModels[0];
    var yAxisModel = axesModels[1];
    var xAxisType = xAxisModel.get('type');
    var yAxisType = yAxisModel.get('type');
    var dimensions = [{
      name: 'x',
      type: getDimTypeByAxis(xAxisType),
      stackable: isStackable(xAxisType)
    }, {
      name: 'y',
      // If two category axes
      type: getDimTypeByAxis(yAxisType),
      stackable: isStackable(yAxisType)
    }];
    var isXAxisCateogry = xAxisType === 'category';
    var isYAxisCategory = yAxisType === 'category';
    dimensions = completeDimensions(dimensions, data, completeDimOpt);
    var categoryAxesModels = {};

    if (isXAxisCateogry) {
      categoryAxesModels.x = xAxisModel;
    }

    if (isYAxisCategory) {
      categoryAxesModels.y = yAxisModel;
    }

    return {
      dimensions: dimensions,
      categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,
      categoryAxesModels: categoryAxesModels
    };
  },
  singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {
    var singleAxisModel = ecModel.queryComponents({
      mainType: 'singleAxis',
      index: seriesModel.get('singleAxisIndex'),
      id: seriesModel.get('singleAxisId')
    })[0];
    var singleAxisType = singleAxisModel.get('type');
    var isCategory = singleAxisType === 'category';
    var dimensions = [{
      name: 'single',
      type: getDimTypeByAxis(singleAxisType),
      stackable: isStackable(singleAxisType)
    }];
    dimensions = completeDimensions(dimensions, data, completeDimOpt);
    var categoryAxesModels = {};

    if (isCategory) {
      categoryAxesModels.single = singleAxisModel;
    }

    return {
      dimensions: dimensions,
      categoryIndex: isCategory ? 0 : -1,
      categoryAxesModels: categoryAxesModels
    };
  },
  polar: function (data, seriesModel, ecModel, completeDimOpt) {
    var polarModel = ecModel.queryComponents({
      mainType: 'polar',
      index: seriesModel.get('polarIndex'),
      id: seriesModel.get('polarId')
    })[0];
    var angleAxisModel = polarModel.findAxisModel('angleAxis');
    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
    var radiusAxisType = radiusAxisModel.get('type');
    var angleAxisType = angleAxisModel.get('type');
    var dimensions = [{
      name: 'radius',
      type: getDimTypeByAxis(radiusAxisType),
      stackable: isStackable(radiusAxisType)
    }, {
      name: 'angle',
      type: getDimTypeByAxis(angleAxisType),
      stackable: isStackable(angleAxisType)
    }];
    var isAngleAxisCateogry = angleAxisType === 'category';
    var isRadiusAxisCateogry = radiusAxisType === 'category';
    dimensions = completeDimensions(dimensions, data, completeDimOpt);
    var categoryAxesModels = {};

    if (isRadiusAxisCateogry) {
      categoryAxesModels.radius = radiusAxisModel;
    }

    if (isAngleAxisCateogry) {
      categoryAxesModels.angle = angleAxisModel;
    }

    return {
      dimensions: dimensions,
      categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,
      categoryAxesModels: categoryAxesModels
    };
  },
  geo: function (data, seriesModel, ecModel, completeDimOpt) {
    // TODO Region
    // 多个散点图系列在同一个地区的时候
    return {
      dimensions: completeDimensions([{
        name: 'lng'
      }, {
        name: 'lat'
      }], data, completeDimOpt)
    };
  }
};

function createNameList(result, data) {
  var nameList = [];
  var categoryDim = result && result.dimensions[result.categoryIndex];
  var categoryAxisModel;

  if (categoryDim) {
    categoryAxisModel = result.categoryAxesModels[categoryDim.name];
  }

  if (categoryAxisModel) {
    // FIXME Two category axis
    var categories = categoryAxisModel.getCategories();

    if (categories) {
      var dataLen = data.length; // Ordered data is given explicitly like
      // [[3, 0.2], [1, 0.3], [2, 0.15]]
      // or given scatter data,
      // pick the category

      if (zrUtil.isArray(data[0]) && data[0].length > 1) {
        nameList = [];

        for (var i = 0; i < dataLen; i++) {
          nameList[i] = categories[data[i][result.categoryIndex || 0]];
        }
      } else {
        nameList = categories.slice(0);
      }
    }
  }

  return nameList;
}

var _default = createListFromArray;
module.exports = _default;

/***/ }),
/* 134 */
/***/ (function(module, exports) {

function defaultKeyGetter(item) {
  return item;
}
/**
 * @param {Array} oldArr
 * @param {Array} newArr
 * @param {Function} oldKeyGetter
 * @param {Function} newKeyGetter
 * @param {Object} [context] Can be visited by this.context in callback.
 */


function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {
  this._old = oldArr;
  this._new = newArr;
  this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
  this._newKeyGetter = newKeyGetter || defaultKeyGetter;
  this.context = context;
}

DataDiffer.prototype = {
  constructor: DataDiffer,

  /**
   * Callback function when add a data
   */
  add: function (func) {
    this._add = func;
    return this;
  },

  /**
   * Callback function when update a data
   */
  update: function (func) {
    this._update = func;
    return this;
  },

  /**
   * Callback function when remove a data
   */
  remove: function (func) {
    this._remove = func;
    return this;
  },
  execute: function () {
    var oldArr = this._old;
    var newArr = this._new;
    var oldDataIndexMap = {};
    var newDataIndexMap = {};
    var oldDataKeyArr = [];
    var newDataKeyArr = [];
    var i;
    initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);
    initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this); // Travel by inverted order to make sure order consistency
    // when duplicate keys exists (consider newDataIndex.pop() below).
    // For performance consideration, these code below do not look neat.

    for (i = 0; i < oldArr.length; i++) {
      var key = oldDataKeyArr[i];
      var idx = newDataIndexMap[key]; // idx can never be empty array here. see 'set null' logic below.

      if (idx != null) {
        // Consider there is duplicate key (for example, use dataItem.name as key).
        // We should make sure every item in newArr and oldArr can be visited.
        var len = idx.length;

        if (len) {
          len === 1 && (newDataIndexMap[key] = null);
          idx = idx.unshift();
        } else {
          newDataIndexMap[key] = null;
        }

        this._update && this._update(idx, i);
      } else {
        this._remove && this._remove(i);
      }
    }

    for (var i = 0; i < newDataKeyArr.length; i++) {
      var key = newDataKeyArr[i];

      if (newDataIndexMap.hasOwnProperty(key)) {
        var idx = newDataIndexMap[key];

        if (idx == null) {
          continue;
        } // idx can never be empty array here. see 'set null' logic above.


        if (!idx.length) {
          this._add && this._add(idx);
        } else {
          for (var j = 0, len = idx.length; j < len; j++) {
            this._add && this._add(idx[j]);
          }
        }
      }
    }
  }
};

function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {
  for (var i = 0; i < arr.length; i++) {
    // Add prefix to avoid conflict with Object.prototype.
    var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);
    var existence = map[key];

    if (existence == null) {
      keyArr.push(key);
      map[key] = i;
    } else {
      if (!existence.length) {
        map[key] = existence = [existence];
      }

      existence.push(i);
    }
  }
}

var _default = DataDiffer;
module.exports = _default;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var numberUtil = __webpack_require__(94);

var formatUtil = __webpack_require__(99);

var Scale = __webpack_require__(124);

var helper = __webpack_require__(160);

/**
 * Interval scale
 * @module echarts/scale/Interval
 */
var roundNumber = numberUtil.round;
/**
 * @alias module:echarts/coord/scale/Interval
 * @constructor
 */

var IntervalScale = Scale.extend({
  type: 'interval',
  _interval: 0,
  _intervalPrecision: 2,
  setExtent: function (start, end) {
    var thisExtent = this._extent; //start,end may be a Number like '25',so...

    if (!isNaN(start)) {
      thisExtent[0] = parseFloat(start);
    }

    if (!isNaN(end)) {
      thisExtent[1] = parseFloat(end);
    }
  },
  unionExtent: function (other) {
    var extent = this._extent;
    other[0] < extent[0] && (extent[0] = other[0]);
    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes

    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
  },

  /**
   * Get interval
   */
  getInterval: function () {
    return this._interval;
  },

  /**
   * Set interval
   */
  setInterval: function (interval) {
    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent
    // We assume user wan't to set both interval, min, max to get a better result

    this._niceExtent = this._extent.slice();
    this._intervalPrecision = helper.getIntervalPrecision(interval);
  },

  /**
   * @return {Array.<number>}
   */
  getTicks: function () {
    return helper.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);
  },

  /**
   * @return {Array.<string>}
   */
  getTicksLabels: function () {
    var labels = [];
    var ticks = this.getTicks();

    for (var i = 0; i < ticks.length; i++) {
      labels.push(this.getLabel(ticks[i]));
    }

    return labels;
  },

  /**
   * @param {number} data
   * @param {Object} [opt]
   * @param {number|string} [opt.precision] If 'auto', use nice presision.
   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.
   * @return {string}
   */
  getLabel: function (data, opt) {
    if (data == null) {
      return '';
    }

    var precision = opt && opt.precision;

    if (precision == null) {
      precision = numberUtil.getPrecisionSafe(data) || 0;
    } else if (precision === 'auto') {
      // Should be more precise then tick.
      precision = this._intervalPrecision;
    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.
    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.


    data = roundNumber(data, precision, true);
    return formatUtil.addCommas(data);
  },

  /**
   * Update interval and extent of intervals for nice ticks
   *
   * @param {number} [splitNumber = 5] Desired number of ticks
   * @param {number} [minInterval]
   * @param {number} [maxInterval]
   */
  niceTicks: function (splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    var extent = this._extent;
    var span = extent[1] - extent[0];

    if (!isFinite(span)) {
      return;
    } // User may set axis min 0 and data are all negative
    // FIXME If it needs to reverse ?


    if (span < 0) {
      span = -span;
      extent.reverse();
    }

    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  },

  /**
   * Nice extent.
   * @param {Object} opt
   * @param {number} [opt.splitNumber = 5] Given approx tick number
   * @param {boolean} [opt.fixMin=false]
   * @param {boolean} [opt.fixMax=false]
   * @param {boolean} [opt.minInterval]
   * @param {boolean} [opt.maxInterval]
   */
  niceExtent: function (opt) {
    var extent = this._extent; // If extent start and end are same, expand them

    if (extent[0] === extent[1]) {
      if (extent[0] !== 0) {
        // Expand extent
        var expandSize = extent[0]; // In the fowllowing case
        //      Axis has been fixed max 100
        //      Plus data are all 100 and axis extent are [100, 100].
        // Extend to the both side will cause expanded max is larger than fixed max.
        // So only expand to the smaller side.

        if (!opt.fixMax) {
          extent[1] += expandSize / 2;
          extent[0] -= expandSize / 2;
        } else {
          extent[0] -= expandSize / 2;
        }
      } else {
        extent[1] = 1;
      }
    }

    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]

    if (!isFinite(span)) {
      extent[0] = 0;
      extent[1] = 1;
    }

    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;

    var interval = this._interval;

    if (!opt.fixMin) {
      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);
    }

    if (!opt.fixMax) {
      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);
    }
  }
});
/**
 * @return {module:echarts/scale/Time}
 */

IntervalScale.create = function () {
  return new IntervalScale();
};

var _default = IntervalScale;
module.exports = _default;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var formatUtil = __webpack_require__(99);

var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.

var COORDS = ['cartesian2d', 'polar', 'singleAxis'];
/**
 * @param {string} coordType
 * @return {boolean}
 */

function isCoordSupported(coordType) {
  return zrUtil.indexOf(COORDS, coordType) >= 0;
}
/**
 * Create "each" method to iterate names.
 *
 * @pubilc
 * @param  {Array.<string>} names
 * @param  {Array.<string>=} attrs
 * @return {Function}
 */


function createNameEach(names, attrs) {
  names = names.slice();
  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);
  attrs = (attrs || []).slice();
  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);
  return function (callback, context) {
    zrUtil.each(names, function (name, index) {
      var nameObj = {
        name: name,
        capital: capitalNames[index]
      };

      for (var j = 0; j < attrs.length; j++) {
        nameObj[attrs[j]] = name + capitalAttrs[j];
      }

      callback.call(context, nameObj);
    });
  };
}
/**
 * Iterate each dimension name.
 *
 * @public
 * @param {Function} callback The parameter is like:
 *                            {
 *                                name: 'angle',
 *                                capital: 'Angle',
 *                                axis: 'angleAxis',
 *                                axisIndex: 'angleAixs',
 *                                index: 'angleIndex'
 *                            }
 * @param {Object} context
 */


var eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);
/**
 * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.
 * dataZoomModels and 'links' make up one or more graphics.
 * This function finds the graphic where the source dataZoomModel is in.
 *
 * @public
 * @param {Function} forEachNode Node iterator.
 * @param {Function} forEachEdgeType edgeType iterator
 * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.
 * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}
 */

function createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {
  return function (sourceNode) {
    var result = {
      nodes: [],
      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).

    };
    forEachEdgeType(function (edgeType) {
      result.records[edgeType.name] = {};
    });

    if (!sourceNode) {
      return result;
    }

    absorb(sourceNode, result);
    var existsLink;

    do {
      existsLink = false;
      forEachNode(processSingleNode);
    } while (existsLink);

    function processSingleNode(node) {
      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {
        absorb(node, result);
        existsLink = true;
      }
    }

    return result;
  };

  function isNodeAbsorded(node, result) {
    return zrUtil.indexOf(result.nodes, node) >= 0;
  }

  function isLinked(node, result) {
    var hasLink = false;
    forEachEdgeType(function (edgeType) {
      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {
        result.records[edgeType.name][edgeId] && (hasLink = true);
      });
    });
    return hasLink;
  }

  function absorb(node, result) {
    result.nodes.push(node);
    forEachEdgeType(function (edgeType) {
      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {
        result.records[edgeType.name][edgeId] = true;
      });
    });
  }
}

exports.isCoordSupported = isCoordSupported;
exports.createNameEach = createNameEach;
exports.eachAxisDim = eachAxisDim;
exports.createLinkedNodesFinder = createLinkedNodesFinder;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

/**
 * Calculate slider move result.
 * Usage:
 * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as
 * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.
 * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.
 *
 * @param {number} delta Move length.
 * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].
 *              handleEnds will be modified in this method.
 * @param {Array.<number>} extent handleEnds is restricted by extent.
 *              extent[0] should less or equals than extent[1].
 * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,
 *              where the input minSpan and maxSpan will not work.
 * @param {number} [minSpan] The range of dataZoom can not be smaller than that.
 *              If not set, handle0 and cross handle1. If set as a non-negative
 *              number (including `0`), handles will push each other when reaching
 *              the minSpan.
 * @param {number} [maxSpan] The range of dataZoom can not be larger than that.
 * @return {Array.<number>} The input handleEnds.
 */
function _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
  // Normalize firstly.
  handleEnds[0] = restrict(handleEnds[0], extent);
  handleEnds[1] = restrict(handleEnds[1], extent);
  delta = delta || 0;
  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.

  if (minSpan != null) {
    minSpan = restrict(minSpan, [0, extentSpan]);
  }

  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }

  if (handleIndex === 'all') {
    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleIndex = 0;
  }

  var originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta; // Restrict in extent.

  var extentMinSpan = minSpan || 0;
  var realExtent = extent.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.

  var currDistSign = getSpanSign(handleEnds, handleIndex);

  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    // If minSpan exists, 'cross' is forbinden.
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  } // Shrink span.


  var currDistSign = getSpanSign(handleEnds, handleIndex);

  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }

  return handleEnds;
}

function getSpanSign(handleEnds, handleIndex) {
  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]
  // is at left of handleEnds[1] for non-cross case.

  return {
    span: Math.abs(dist),
    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
  };
}

function restrict(value, extend) {
  return Math.min(extend[1], Math.max(extend[0], value));
}

module.exports = _default;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var guid = __webpack_require__(139);

var env = __webpack_require__(98);

var zrUtil = __webpack_require__(91);

var Handler = __webpack_require__(185);

var Storage = __webpack_require__(187);

var Painter = __webpack_require__(191);

var Animation = __webpack_require__(194);

var HandlerProxy = __webpack_require__(195);

/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var useVML = !env.canvasSupported;
var painterCtors = {
  canvas: Painter
};
var instances = {}; // ZRender实例map索引

/**
 * @type {string}
 */

var version = '3.7.4';
/**
 * Initializing a zrender instance
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
 * @return {module:zrender/ZRender}
 */

function init(dom, opts) {
  var zr = new ZRender(guid(), dom, opts);
  instances[zr.id] = zr;
  return zr;
}
/**
 * Dispose zrender instance
 * @param {module:zrender/ZRender} zr
 */


function dispose(zr) {
  if (zr) {
    zr.dispose();
  } else {
    for (var key in instances) {
      if (instances.hasOwnProperty(key)) {
        instances[key].dispose();
      }
    }

    instances = {};
  }

  return this;
}
/**
 * Get zrender instance by id
 * @param {string} id zrender instance id
 * @return {module:zrender/ZRender}
 */


function getInstance(id) {
  return instances[id];
}

function registerPainter(name, Ctor) {
  painterCtors[name] = Ctor;
}

function delInstance(id) {
  delete instances[id];
}
/**
 * @module zrender/ZRender
 */

/**
 * @constructor
 * @alias module:zrender/ZRender
 * @param {string} id
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 */


var ZRender = function (id, dom, opts) {
  opts = opts || {};
  /**
   * @type {HTMLDomElement}
   */

  this.dom = dom;
  /**
   * @type {string}
   */

  this.id = id;
  var self = this;
  var storage = new Storage();
  var rendererType = opts.renderer; // TODO WebGL

  if (useVML) {
    if (!painterCtors.vml) {
      throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
    }

    rendererType = 'vml';
  } else if (!rendererType || !painterCtors[rendererType]) {
    rendererType = 'canvas';
  }

  var painter = new painterCtors[rendererType](dom, storage, opts);
  this.storage = storage;
  this.painter = painter;
  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
  this.handler = new Handler(storage, painter, handerProxy, painter.root);
  /**
   * @type {module:zrender/animation/Animation}
   */

  this.animation = new Animation({
    stage: {
      update: zrUtil.bind(this.flush, this)
    }
  });
  this.animation.start();
  /**
   * @type {boolean}
   * @private
   */

  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
  // FIXME 有点ugly

  var oldDelFromStorage = storage.delFromStorage;
  var oldAddToStorage = storage.addToStorage;

  storage.delFromStorage = function (el) {
    oldDelFromStorage.call(storage, el);
    el && el.removeSelfFromZr(self);
  };

  storage.addToStorage = function (el) {
    oldAddToStorage.call(storage, el);
    el.addSelfToZr(self);
  };
};

ZRender.prototype = {
  constructor: ZRender,

  /**
   * 获取实例唯一标识
   * @return {string}
   */
  getId: function () {
    return this.id;
  },

  /**
   * 添加元素
   * @param  {module:zrender/Element} el
   */
  add: function (el) {
    this.storage.addRoot(el);
    this._needsRefresh = true;
  },

  /**
   * 删除元素
   * @param  {module:zrender/Element} el
   */
  remove: function (el) {
    this.storage.delRoot(el);
    this._needsRefresh = true;
  },

  /**
   * Change configuration of layer
   * @param {string} zLevel
   * @param {Object} config
   * @param {string} [config.clearColor=0] Clear color
   * @param {string} [config.motionBlur=false] If enable motion blur
   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
  */
  configLayer: function (zLevel, config) {
    this.painter.configLayer(zLevel, config);
    this._needsRefresh = true;
  },

  /**
   * Repaint the canvas immediately
   */
  refreshImmediately: function () {
    // var start = new Date();
    // Clear needsRefresh ahead to avoid something wrong happens in refresh
    // Or it will cause zrender refreshes again and again.
    this._needsRefresh = false;
    this.painter.refresh();
    /**
     * Avoid trigger zr.refresh in Element#beforeUpdate hook
     */

    this._needsRefresh = false; // var end = new Date();
    // var log = document.getElementById('log');
    // if (log) {
    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
    // }
  },

  /**
   * Mark and repaint the canvas in the next frame of browser
   */
  refresh: function () {
    this._needsRefresh = true;
  },

  /**
   * Perform all refresh
   */
  flush: function () {
    if (this._needsRefresh) {
      this.refreshImmediately();
    }

    if (this._needsRefreshHover) {
      this.refreshHoverImmediately();
    }
  },

  /**
   * Add element to hover layer
   * @param  {module:zrender/Element} el
   * @param {Object} style
   */
  addHover: function (el, style) {
    if (this.painter.addHover) {
      this.painter.addHover(el, style);
      this.refreshHover();
    }
  },

  /**
   * Add element from hover layer
   * @param  {module:zrender/Element} el
   */
  removeHover: function (el) {
    if (this.painter.removeHover) {
      this.painter.removeHover(el);
      this.refreshHover();
    }
  },

  /**
   * Clear all hover elements in hover layer
   * @param  {module:zrender/Element} el
   */
  clearHover: function () {
    if (this.painter.clearHover) {
      this.painter.clearHover();
      this.refreshHover();
    }
  },

  /**
   * Refresh hover in next frame
   */
  refreshHover: function () {
    this._needsRefreshHover = true;
  },

  /**
   * Refresh hover immediately
   */
  refreshHoverImmediately: function () {
    this._needsRefreshHover = false;
    this.painter.refreshHover && this.painter.refreshHover();
  },

  /**
   * Resize the canvas.
   * Should be invoked when container size is changed
   * @param {Object} [opts]
   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
   */
  resize: function (opts) {
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  },

  /**
   * Stop and clear all animation immediately
   */
  clearAnimation: function () {
    this.animation.clear();
  },

  /**
   * Get container width
   */
  getWidth: function () {
    return this.painter.getWidth();
  },

  /**
   * Get container height
   */
  getHeight: function () {
    return this.painter.getHeight();
  },

  /**
   * Export the canvas as Base64 URL
   * @param {string} type
   * @param {string} [backgroundColor='#fff']
   * @return {string} Base64 URL
   */
  // toDataURL: function(type, backgroundColor) {
  //     return this.painter.getRenderedCanvas({
  //         backgroundColor: backgroundColor
  //     }).toDataURL(type);
  // },

  /**
   * Converting a path to image.
   * It has much better performance of drawing image rather than drawing a vector path.
   * @param {module:zrender/graphic/Path} e
   * @param {number} width
   * @param {number} height
   */
  pathToImage: function (e, dpr) {
    return this.painter.pathToImage(e, dpr);
  },

  /**
   * Set default cursor
   * @param {string} [cursorStyle='default'] 例如 crosshair
   */
  setCursorStyle: function (cursorStyle) {
    this.handler.setCursorStyle(cursorStyle);
  },

  /**
   * Find hovered element
   * @param {number} x
   * @param {number} y
   * @return {Object} {target, topTarget}
   */
  findHover: function (x, y) {
    return this.handler.findHover(x, y);
  },

  /**
   * Bind event
   *
   * @param {string} eventName Event name
   * @param {Function} eventHandler Handler function
   * @param {Object} [context] Context object
   */
  on: function (eventName, eventHandler, context) {
    this.handler.on(eventName, eventHandler, context);
  },

  /**
   * Unbind event
   * @param {string} eventName Event name
   * @param {Function} [eventHandler] Handler function
   */
  off: function (eventName, eventHandler) {
    this.handler.off(eventName, eventHandler);
  },

  /**
   * Trigger event manually
   *
   * @param {string} eventName Event name
   * @param {event=} event Event object
   */
  trigger: function (eventName, event) {
    this.handler.trigger(eventName, event);
  },

  /**
   * Clear all objects and the canvas.
   */
  clear: function () {
    this.storage.delRoot();
    this.painter.clear();
  },

  /**
   * Dispose self.
   */
  dispose: function () {
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    delInstance(this.id);
  }
};
exports.version = version;
exports.init = init;
exports.dispose = dispose;
exports.getInstance = getInstance;
exports.registerPainter = registerPainter;

/***/ }),
/* 139 */
/***/ (function(module, exports) {

/**
 * zrender: 生成唯一id
 *
 * @author errorrik (errorrik@gmail.com)
 */
var idStart = 0x0907;

function _default() {
  return idStart++;
}

module.exports = _default;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var guid = __webpack_require__(139);

var Eventful = __webpack_require__(107);

var Transformable = __webpack_require__(141);

var Animatable = __webpack_require__(188);

var zrUtil = __webpack_require__(91);

/**
 * @alias module:zrender/Element
 * @constructor
 * @extends {module:zrender/mixin/Animatable}
 * @extends {module:zrender/mixin/Transformable}
 * @extends {module:zrender/mixin/Eventful}
 */
var Element = function (opts) {
  // jshint ignore:line
  Transformable.call(this, opts);
  Eventful.call(this, opts);
  Animatable.call(this, opts);
  /**
   * 画布元素ID
   * @type {string}
   */

  this.id = opts.id || guid();
};

Element.prototype = {
  /**
   * 元素类型
   * Element type
   * @type {string}
   */
  type: 'element',

  /**
   * 元素名字
   * Element name
   * @type {string}
   */
  name: '',

  /**
   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
   * ZRender instance will be assigned when element is associated with zrender
   * @name module:/zrender/Element#__zr
   * @type {module:zrender/ZRender}
   */
  __zr: null,

  /**
   * 图形是否忽略，为true时忽略图形的绘制以及事件触发
   * If ignore drawing and events of the element object
   * @name module:/zrender/Element#ignore
   * @type {boolean}
   * @default false
   */
  ignore: false,

  /**
   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
   * 该路径会继承被裁减对象的变换
   * @type {module:zrender/graphic/Path}
   * @see http://www.w3.org/TR/2dcontext/#clipping-region
   * @readOnly
   */
  clipPath: null,

  /**
   * Drift element
   * @param  {number} dx dx on the global space
   * @param  {number} dy dy on the global space
   */
  drift: function (dx, dy) {
    switch (this.draggable) {
      case 'horizontal':
        dy = 0;
        break;

      case 'vertical':
        dx = 0;
        break;
    }

    var m = this.transform;

    if (!m) {
      m = this.transform = [1, 0, 0, 1, 0, 0];
    }

    m[4] += dx;
    m[5] += dy;
    this.decomposeTransform();
    this.dirty(false);
  },

  /**
   * Hook before update
   */
  beforeUpdate: function () {},

  /**
   * Hook after update
   */
  afterUpdate: function () {},

  /**
   * Update each frame
   */
  update: function () {
    this.updateTransform();
  },

  /**
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {},

  /**
   * @protected
   */
  attrKV: function (key, value) {
    if (key === 'position' || key === 'scale' || key === 'origin') {
      // Copy the array
      if (value) {
        var target = this[key];

        if (!target) {
          target = this[key] = [];
        }

        target[0] = value[0];
        target[1] = value[1];
      }
    } else {
      this[key] = value;
    }
  },

  /**
   * Hide the element
   */
  hide: function () {
    this.ignore = true;
    this.__zr && this.__zr.refresh();
  },

  /**
   * Show the element
   */
  show: function () {
    this.ignore = false;
    this.__zr && this.__zr.refresh();
  },

  /**
   * @param {string|Object} key
   * @param {*} value
   */
  attr: function (key, value) {
    if (typeof key === 'string') {
      this.attrKV(key, value);
    } else if (zrUtil.isObject(key)) {
      for (var name in key) {
        if (key.hasOwnProperty(name)) {
          this.attrKV(name, key[name]);
        }
      }
    }

    this.dirty(false);
    return this;
  },

  /**
   * @param {module:zrender/graphic/Path} clipPath
   */
  setClipPath: function (clipPath) {
    var zr = this.__zr;

    if (zr) {
      clipPath.addSelfToZr(zr);
    } // Remove previous clip path


    if (this.clipPath && this.clipPath !== clipPath) {
      this.removeClipPath();
    }

    this.clipPath = clipPath;
    clipPath.__zr = zr;
    clipPath.__clipTarget = this;
    this.dirty(false);
  },

  /**
   */
  removeClipPath: function () {
    var clipPath = this.clipPath;

    if (clipPath) {
      if (clipPath.__zr) {
        clipPath.removeSelfFromZr(clipPath.__zr);
      }

      clipPath.__zr = null;
      clipPath.__clipTarget = null;
      this.clipPath = null;
      this.dirty(false);
    }
  },

  /**
   * Add self from zrender instance.
   * Not recursively because it will be invoked when element added to storage.
   * @param {module:zrender/ZRender} zr
   */
  addSelfToZr: function (zr) {
    this.__zr = zr; // 添加动画

    var animators = this.animators;

    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.addAnimator(animators[i]);
      }
    }

    if (this.clipPath) {
      this.clipPath.addSelfToZr(zr);
    }
  },

  /**
   * Remove self from zrender instance.
   * Not recursively because it will be invoked when element added to storage.
   * @param {module:zrender/ZRender} zr
   */
  removeSelfFromZr: function (zr) {
    this.__zr = null; // 移除动画

    var animators = this.animators;

    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.removeAnimator(animators[i]);
      }
    }

    if (this.clipPath) {
      this.clipPath.removeSelfFromZr(zr);
    }
  }
};
zrUtil.mixin(Element, Animatable);
zrUtil.mixin(Element, Transformable);
zrUtil.mixin(Element, Eventful);
var _default = Element;
module.exports = _default;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var matrix = __webpack_require__(110);

var vector = __webpack_require__(97);

/**
 * 提供变换扩展
 * @module zrender/mixin/Transformable
 * @author pissang (https://www.github.com/pissang)
 */
var mIdentity = matrix.identity;
var EPSILON = 5e-5;

function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
/**
 * @alias module:zrender/mixin/Transformable
 * @constructor
 */


var Transformable = function (opts) {
  opts = opts || {}; // If there are no given position, rotation, scale

  if (!opts.position) {
    /**
     * 平移
     * @type {Array.<number>}
     * @default [0, 0]
     */
    this.position = [0, 0];
  }

  if (opts.rotation == null) {
    /**
     * 旋转
     * @type {Array.<number>}
     * @default 0
     */
    this.rotation = 0;
  }

  if (!opts.scale) {
    /**
     * 缩放
     * @type {Array.<number>}
     * @default [1, 1]
     */
    this.scale = [1, 1];
  }
  /**
   * 旋转和缩放的原点
   * @type {Array.<number>}
   * @default null
   */


  this.origin = this.origin || null;
};

var transformableProto = Transformable.prototype;
transformableProto.transform = null;
/**
 * 判断是否需要有坐标变换
 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
 */

transformableProto.needLocalTransform = function () {
  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
};

transformableProto.updateTransform = function () {
  var parent = this.parent;
  var parentHasTransform = parent && parent.transform;
  var needLocalTransform = this.needLocalTransform();
  var m = this.transform;

  if (!(needLocalTransform || parentHasTransform)) {
    m && mIdentity(m);
    return;
  }

  m = m || matrix.create();

  if (needLocalTransform) {
    this.getLocalTransform(m);
  } else {
    mIdentity(m);
  } // 应用父节点变换


  if (parentHasTransform) {
    if (needLocalTransform) {
      matrix.mul(m, parent.transform, m);
    } else {
      matrix.copy(m, parent.transform);
    }
  } // 保存这个变换矩阵


  this.transform = m;
  this.invTransform = this.invTransform || matrix.create();
  matrix.invert(this.invTransform, m);
};

transformableProto.getLocalTransform = function (m) {
  return Transformable.getLocalTransform(this, m);
};
/**
 * 将自己的transform应用到context上
 * @param {CanvasRenderingContext2D} ctx
 */


transformableProto.setTransform = function (ctx) {
  var m = this.transform;
  var dpr = ctx.dpr || 1;

  if (m) {
    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
  } else {
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
};

transformableProto.restoreTransform = function (ctx) {
  var dpr = ctx.dpr || 1;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
};

var tmpTransform = [];
/**
 * 分解`transform`矩阵到`position`, `rotation`, `scale`
 */

transformableProto.decomposeTransform = function () {
  if (!this.transform) {
    return;
  }

  var parent = this.parent;
  var m = this.transform;

  if (parent && parent.transform) {
    // Get local transform and decompose them to position, scale, rotation
    matrix.mul(tmpTransform, parent.invTransform, m);
    m = tmpTransform;
  }

  var sx = m[0] * m[0] + m[1] * m[1];
  var sy = m[2] * m[2] + m[3] * m[3];
  var position = this.position;
  var scale = this.scale;

  if (isNotAroundZero(sx - 1)) {
    sx = Math.sqrt(sx);
  }

  if (isNotAroundZero(sy - 1)) {
    sy = Math.sqrt(sy);
  }

  if (m[0] < 0) {
    sx = -sx;
  }

  if (m[3] < 0) {
    sy = -sy;
  }

  position[0] = m[4];
  position[1] = m[5];
  scale[0] = sx;
  scale[1] = sy;
  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
};
/**
 * Get global scale
 * @return {Array.<number>}
 */


transformableProto.getGlobalScale = function () {
  var m = this.transform;

  if (!m) {
    return [1, 1];
  }

  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);

  if (m[0] < 0) {
    sx = -sx;
  }

  if (m[3] < 0) {
    sy = -sy;
  }

  return [sx, sy];
};
/**
 * 变换坐标位置到 shape 的局部坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */


transformableProto.transformCoordToLocal = function (x, y) {
  var v2 = [x, y];
  var invTransform = this.invTransform;

  if (invTransform) {
    vector.applyTransform(v2, v2, invTransform);
  }

  return v2;
};
/**
 * 变换局部坐标位置到全局坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */


transformableProto.transformCoordToGlobal = function (x, y) {
  var v2 = [x, y];
  var transform = this.transform;

  if (transform) {
    vector.applyTransform(v2, v2, transform);
  }

  return v2;
};
/**
 * @static
 * @param {Object} target
 * @param {Array.<number>} target.origin
 * @param {number} target.rotation
 * @param {Array.<number>} target.position
 * @param {Array.<number>} [m]
 */


Transformable.getLocalTransform = function (target, m) {
  m = m || [];
  mIdentity(m);
  var origin = target.origin;
  var scale = target.scale || [1, 1];
  var rotation = target.rotation || 0;
  var position = target.position || [0, 0];

  if (origin) {
    // Translate to origin
    m[4] -= origin[0];
    m[5] -= origin[1];
  }

  matrix.scale(m, m, scale);

  if (rotation) {
    matrix.rotate(m, m, rotation);
  }

  if (origin) {
    // Translate back from origin
    m[4] += origin[0];
    m[5] += origin[1];
  }

  m[4] += position[0];
  m[5] += position[1];
  return m;
};

var _default = Transformable;
module.exports = _default;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var Clip = __webpack_require__(189);

var color = __webpack_require__(113);

var _util = __webpack_require__(91);

var isArrayLike = _util.isArrayLike;

/**
 * @module echarts/animation/Animator
 */
var arraySlice = Array.prototype.slice;

function defaultGetter(target, key) {
  return target[key];
}

function defaultSetter(target, key, value) {
  target[key] = value;
}
/**
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} percent
 * @return {number}
 */


function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
/**
 * @param  {string} p0
 * @param  {string} p1
 * @param  {number} percent
 * @return {string}
 */


function interpolateString(p0, p1, percent) {
  return percent > 0.5 ? p1 : p0;
}
/**
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {number} percent
 * @param  {Array} out
 * @param  {number} arrDim
 */


function interpolateArray(p0, p1, percent, out, arrDim) {
  var len = p0.length;

  if (arrDim == 1) {
    for (var i = 0; i < len; i++) {
      out[i] = interpolateNumber(p0[i], p1[i], percent);
    }
  } else {
    var len2 = len && p0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
      }
    }
  }
} // arr0 is source array, arr1 is target array.
// Do some preprocess to avoid error happened when interpolating from arr0 to arr1


function fillArr(arr0, arr1, arrDim) {
  var arr0Len = arr0.length;
  var arr1Len = arr1.length;

  if (arr0Len !== arr1Len) {
    // FIXME Not work for TypedArray
    var isPreviousLarger = arr0Len > arr1Len;

    if (isPreviousLarger) {
      // Cut the previous
      arr0.length = arr1Len;
    } else {
      // Fill the previous
      for (var i = arr0Len; i < arr1Len; i++) {
        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
      }
    }
  } // Handling NaN value


  var len2 = arr0[0] && arr0[0].length;

  for (var i = 0; i < arr0.length; i++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i])) {
        arr0[i] = arr1[i];
      }
    } else {
      for (var j = 0; j < len2; j++) {
        if (isNaN(arr0[i][j])) {
          arr0[i][j] = arr1[i][j];
        }
      }
    }
  }
}
/**
 * @param  {Array} arr0
 * @param  {Array} arr1
 * @param  {number} arrDim
 * @return {boolean}
 */


function isArraySame(arr0, arr1, arrDim) {
  if (arr0 === arr1) {
    return true;
  }

  var len = arr0.length;

  if (len !== arr1.length) {
    return false;
  }

  if (arrDim === 1) {
    for (var i = 0; i < len; i++) {
      if (arr0[i] !== arr1[i]) {
        return false;
      }
    }
  } else {
    var len2 = arr0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        if (arr0[i][j] !== arr1[i][j]) {
          return false;
        }
      }
    }
  }

  return true;
}
/**
 * Catmull Rom interpolate array
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @param  {Array} out
 * @param  {number} arrDim
 */


function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
  var len = p0.length;

  if (arrDim == 1) {
    for (var i = 0; i < len; i++) {
      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
    }
  } else {
    var len2 = p0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
      }
    }
  }
}
/**
 * Catmull Rom interpolate number
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @return {number}
 */


function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}

function cloneValue(value) {
  if (isArrayLike(value)) {
    var len = value.length;

    if (isArrayLike(value[0])) {
      var ret = [];

      for (var i = 0; i < len; i++) {
        ret.push(arraySlice.call(value[i]));
      }

      return ret;
    }

    return arraySlice.call(value);
  }

  return value;
}

function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]);
  rgba[1] = Math.floor(rgba[1]);
  rgba[2] = Math.floor(rgba[2]);
  return 'rgba(' + rgba.join(',') + ')';
}

function getArrayDim(keyframes) {
  var lastValue = keyframes[keyframes.length - 1].value;
  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
}

function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
  var getter = animator._getter;
  var setter = animator._setter;
  var useSpline = easing === 'spline';
  var trackLen = keyframes.length;

  if (!trackLen) {
    return;
  } // Guess data type


  var firstVal = keyframes[0].value;
  var isValueArray = isArrayLike(firstVal);
  var isValueColor = false;
  var isValueString = false; // For vertices morphing

  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
  var trackMaxTime; // Sort keyframe as ascending

  keyframes.sort(function (a, b) {
    return a.time - b.time;
  });
  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe

  var kfPercents = []; // Value of each keyframe

  var kfValues = [];
  var prevValue = keyframes[0].value;
  var isAllValueEqual = true;

  for (var i = 0; i < trackLen; i++) {
    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string

    var value = keyframes[i].value; // Check if value is equal, deep check if value is array

    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
      isAllValueEqual = false;
    }

    prevValue = value; // Try converting a string to a color array

    if (typeof value == 'string') {
      var colorArray = color.parse(value);

      if (colorArray) {
        value = colorArray;
        isValueColor = true;
      } else {
        isValueString = true;
      }
    }

    kfValues.push(value);
  }

  if (!forceAnimate && isAllValueEqual) {
    return;
  }

  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value

  for (var i = 0; i < trackLen - 1; i++) {
    if (isValueArray) {
      fillArr(kfValues[i], lastValue, arrDim);
    } else {
      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
        kfValues[i] = lastValue;
      }
    }
  }

  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
  // animation playback is sequency

  var lastFrame = 0;
  var lastFramePercent = 0;
  var start;
  var w;
  var p0;
  var p1;
  var p2;
  var p3;

  if (isValueColor) {
    var rgba = [0, 0, 0, 0];
  }

  var onframe = function (target, percent) {
    // Find the range keyframes
    // kf1-----kf2---------current--------kf3
    // find kf2 and kf3 and do interpolation
    var frame; // In the easing function like elasticOut, percent may less than 0

    if (percent < 0) {
      frame = 0;
    } else if (percent < lastFramePercent) {
      // Start from next key
      // PENDING start from lastFrame ?
      start = Math.min(lastFrame + 1, trackLen - 1);

      for (frame = start; frame >= 0; frame--) {
        if (kfPercents[frame] <= percent) {
          break;
        }
      } // PENDING really need to do this ?


      frame = Math.min(frame, trackLen - 2);
    } else {
      for (frame = lastFrame; frame < trackLen; frame++) {
        if (kfPercents[frame] > percent) {
          break;
        }
      }

      frame = Math.min(frame - 1, trackLen - 2);
    }

    lastFrame = frame;
    lastFramePercent = percent;
    var range = kfPercents[frame + 1] - kfPercents[frame];

    if (range === 0) {
      return;
    } else {
      w = (percent - kfPercents[frame]) / range;
    }

    if (useSpline) {
      p1 = kfValues[frame];
      p0 = kfValues[frame === 0 ? frame : frame - 1];
      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];

      if (isValueArray) {
        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
      } else {
        var value;

        if (isValueColor) {
          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
          value = rgba2String(rgba);
        } else if (isValueString) {
          // String is step(0.5)
          return interpolateString(p1, p2, w);
        } else {
          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
        }

        setter(target, propName, value);
      }
    } else {
      if (isValueArray) {
        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
      } else {
        var value;

        if (isValueColor) {
          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
          value = rgba2String(rgba);
        } else if (isValueString) {
          // String is step(0.5)
          return interpolateString(kfValues[frame], kfValues[frame + 1], w);
        } else {
          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
        }

        setter(target, propName, value);
      }
    }
  };

  var clip = new Clip({
    target: animator._target,
    life: trackMaxTime,
    loop: animator._loop,
    delay: animator._delay,
    onframe: onframe,
    ondestroy: oneTrackDone
  });

  if (easing && easing !== 'spline') {
    clip.easing = easing;
  }

  return clip;
}
/**
 * @alias module:zrender/animation/Animator
 * @constructor
 * @param {Object} target
 * @param {boolean} loop
 * @param {Function} getter
 * @param {Function} setter
 */


var Animator = function (target, loop, getter, setter) {
  this._tracks = {};
  this._target = target;
  this._loop = loop || false;
  this._getter = getter || defaultGetter;
  this._setter = setter || defaultSetter;
  this._clipCount = 0;
  this._delay = 0;
  this._doneList = [];
  this._onframeList = [];
  this._clipList = [];
};

Animator.prototype = {
  /**
   * 设置动画关键帧
   * @param  {number} time 关键帧时间，单位是ms
   * @param  {Object} props 关键帧的属性值，key-value表示
   * @return {module:zrender/animation/Animator}
   */
  when: function (time
  /* ms */
  , props) {
    var tracks = this._tracks;

    for (var propName in props) {
      if (!props.hasOwnProperty(propName)) {
        continue;
      }

      if (!tracks[propName]) {
        tracks[propName] = []; // Invalid value

        var value = this._getter(this._target, propName);

        if (value == null) {
          // zrLog('Invalid property ' + propName);
          continue;
        } // If time is 0
        //  Then props is given initialize value
        // Else
        //  Initialize value from current prop value


        if (time !== 0) {
          tracks[propName].push({
            time: 0,
            value: cloneValue(value)
          });
        }
      }

      tracks[propName].push({
        time: time,
        value: props[propName]
      });
    }

    return this;
  },

  /**
   * 添加动画每一帧的回调函数
   * @param  {Function} callback
   * @return {module:zrender/animation/Animator}
   */
  during: function (callback) {
    this._onframeList.push(callback);

    return this;
  },
  pause: function () {
    for (var i = 0; i < this._clipList.length; i++) {
      this._clipList[i].pause();
    }

    this._paused = true;
  },
  resume: function () {
    for (var i = 0; i < this._clipList.length; i++) {
      this._clipList[i].resume();
    }

    this._paused = false;
  },
  isPaused: function () {
    return !!this._paused;
  },
  _doneCallback: function () {
    // Clear all tracks
    this._tracks = {}; // Clear all clips

    this._clipList.length = 0;
    var doneList = this._doneList;
    var len = doneList.length;

    for (var i = 0; i < len; i++) {
      doneList[i].call(this);
    }
  },

  /**
   * 开始执行动画
   * @param  {string|Function} [easing]
   *         动画缓动函数，详见{@link module:zrender/animation/easing}
   * @param  {boolean} forceAnimate
   * @return {module:zrender/animation/Animator}
   */
  start: function (easing, forceAnimate) {
    var self = this;
    var clipCount = 0;

    var oneTrackDone = function () {
      clipCount--;

      if (!clipCount) {
        self._doneCallback();
      }
    };

    var lastClip;

    for (var propName in this._tracks) {
      if (!this._tracks.hasOwnProperty(propName)) {
        continue;
      }

      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);

      if (clip) {
        this._clipList.push(clip);

        clipCount++; // If start after added to animation

        if (this.animation) {
          this.animation.addClip(clip);
        }

        lastClip = clip;
      }
    } // Add during callback on the last clip


    if (lastClip) {
      var oldOnFrame = lastClip.onframe;

      lastClip.onframe = function (target, percent) {
        oldOnFrame(target, percent);

        for (var i = 0; i < self._onframeList.length; i++) {
          self._onframeList[i](target, percent);
        }
      };
    } // This optimization will help the case that in the upper application
    // the view may be refreshed frequently, where animation will be
    // called repeatly but nothing changed.


    if (!clipCount) {
      this._doneCallback();
    }

    return this;
  },

  /**
   * 停止动画
   * @param {boolean} forwardToLast If move to last frame before stop
   */
  stop: function (forwardToLast) {
    var clipList = this._clipList;
    var animation = this.animation;

    for (var i = 0; i < clipList.length; i++) {
      var clip = clipList[i];

      if (forwardToLast) {
        // Move to last frame before stop
        clip.onframe(this._target, 1);
      }

      animation && animation.removeClip(clip);
    }

    clipList.length = 0;
  },

  /**
   * 设置动画延迟开始的时间
   * @param  {number} time 单位ms
   * @return {module:zrender/animation/Animator}
   */
  delay: function (time) {
    this._delay = time;
    return this;
  },

  /**
   * 添加动画结束的回调
   * @param  {Function} cb
   * @return {module:zrender/animation/Animator}
   */
  done: function (cb) {
    if (cb) {
      this._doneList.push(cb);
    }

    return this;
  },

  /**
   * @return {Array.<module:zrender/animation/Clip>}
   */
  getClips: function () {
    return this._clipList;
  }
};
var _default = Animator;
module.exports = _default;

/***/ }),
/* 143 */
/***/ (function(module, exports) {

// Simple LRU cache use doubly linked list
// @module zrender/core/LRU

/**
 * Simple double linked list. Compared with array, it has O(1) remove operation.
 * @constructor
 */
var LinkedList = function () {
  /**
   * @type {module:zrender/core/LRU~Entry}
   */
  this.head = null;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.tail = null;
  this._len = 0;
};

var linkedListProto = LinkedList.prototype;
/**
 * Insert a new value at the tail
 * @param  {} val
 * @return {module:zrender/core/LRU~Entry}
 */

linkedListProto.insert = function (val) {
  var entry = new Entry(val);
  this.insertEntry(entry);
  return entry;
};
/**
 * Insert an entry at the tail
 * @param  {module:zrender/core/LRU~Entry} entry
 */


linkedListProto.insertEntry = function (entry) {
  if (!this.head) {
    this.head = this.tail = entry;
  } else {
    this.tail.next = entry;
    entry.prev = this.tail;
    entry.next = null;
    this.tail = entry;
  }

  this._len++;
};
/**
 * Remove entry.
 * @param  {module:zrender/core/LRU~Entry} entry
 */


linkedListProto.remove = function (entry) {
  var prev = entry.prev;
  var next = entry.next;

  if (prev) {
    prev.next = next;
  } else {
    // Is head
    this.head = next;
  }

  if (next) {
    next.prev = prev;
  } else {
    // Is tail
    this.tail = prev;
  }

  entry.next = entry.prev = null;
  this._len--;
};
/**
 * @return {number}
 */


linkedListProto.len = function () {
  return this._len;
};
/**
 * Clear list
 */


linkedListProto.clear = function () {
  this.head = this.tail = null;
  this._len = 0;
};
/**
 * @constructor
 * @param {} val
 */


var Entry = function (val) {
  /**
   * @type {}
   */
  this.value = val;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.next;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.prev;
};
/**
 * LRU Cache
 * @constructor
 * @alias module:zrender/core/LRU
 */


var LRU = function (maxSize) {
  this._list = new LinkedList();
  this._map = {};
  this._maxSize = maxSize || 10;
  this._lastRemovedEntry = null;
};

var LRUProto = LRU.prototype;
/**
 * @param  {string} key
 * @param  {} value
 * @return {} Removed value
 */

LRUProto.put = function (key, value) {
  var list = this._list;
  var map = this._map;
  var removed = null;

  if (map[key] == null) {
    var len = list.len(); // Reuse last removed entry

    var entry = this._lastRemovedEntry;

    if (len >= this._maxSize && len > 0) {
      // Remove the least recently used
      var leastUsedEntry = list.head;
      list.remove(leastUsedEntry);
      delete map[leastUsedEntry.key];
      removed = leastUsedEntry.value;
      this._lastRemovedEntry = leastUsedEntry;
    }

    if (entry) {
      entry.value = value;
    } else {
      entry = new Entry(value);
    }

    entry.key = key;
    list.insertEntry(entry);
    map[key] = entry;
  }

  return removed;
};
/**
 * @param  {string} key
 * @return {}
 */


LRUProto.get = function (key) {
  var entry = this._map[key];
  var list = this._list;

  if (entry != null) {
    // Put the latest used entry in the tail
    if (entry !== list.tail) {
      list.remove(entry);
      list.insertEntry(entry);
    }

    return entry.value;
  }
};
/**
 * Clear the cache
 */


LRUProto.clear = function () {
  this._list.clear();

  this._map = {};
};

var _default = LRU;
module.exports = _default;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(120);

var debugMode = _config.debugMode;

var log = function () {};

if (debugMode === 1) {
  log = function () {
    for (var k in arguments) {
      throw new Error(arguments[k]);
    }
  };
} else if (debugMode > 1) {
  log = function () {
    for (var k in arguments) {
      console.log(arguments[k]);
    }
  };
}

var _default = log;
module.exports = _default;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);

var Style = function (opts, host) {
  this.extendFrom(opts, false);
  this.host = host;
};

function createLinearGradient(ctx, obj, rect) {
  var x = obj.x == null ? 0 : obj.x;
  var x2 = obj.x2 == null ? 1 : obj.x2;
  var y = obj.y == null ? 0 : obj.y;
  var y2 = obj.y2 == null ? 0 : obj.y2;

  if (!obj.global) {
    x = x * rect.width + rect.x;
    x2 = x2 * rect.width + rect.x;
    y = y * rect.height + rect.y;
    y2 = y2 * rect.height + rect.y;
  }

  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
  return canvasGradient;
}

function createRadialGradient(ctx, obj, rect) {
  var width = rect.width;
  var height = rect.height;
  var min = Math.min(width, height);
  var x = obj.x == null ? 0.5 : obj.x;
  var y = obj.y == null ? 0.5 : obj.y;
  var r = obj.r == null ? 0.5 : obj.r;

  if (!obj.global) {
    x = x * width + rect.x;
    y = y * height + rect.y;
    r = r * min;
  }

  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
  return canvasGradient;
}

Style.prototype = {
  constructor: Style,

  /**
   * @type {module:zrender/graphic/Displayable}
   */
  host: null,

  /**
   * @type {string}
   */
  fill: '#000',

  /**
   * @type {string}
   */
  stroke: null,

  /**
   * @type {number}
   */
  opacity: 1,

  /**
   * @type {Array.<number>}
   */
  lineDash: null,

  /**
   * @type {number}
   */
  lineDashOffset: 0,

  /**
   * @type {number}
   */
  shadowBlur: 0,

  /**
   * @type {number}
   */
  shadowOffsetX: 0,

  /**
   * @type {number}
   */
  shadowOffsetY: 0,

  /**
   * @type {number}
   */
  lineWidth: 1,

  /**
   * If stroke ignore scale
   * @type {Boolean}
   */
  strokeNoScale: false,
  // Bounding rect text configuration
  // Not affected by element transform

  /**
   * @type {string}
   */
  text: null,

  /**
   * If `fontSize` or `fontFamily` exists, `font` will be reset by
   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
   * So do not visit it directly in upper application (like echarts),
   * but use `contain/text#makeFont` instead.
   * @type {string}
   */
  font: null,

  /**
   * The same as font. Use font please.
   * @deprecated
   * @type {string}
   */
  textFont: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontStyle: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontWeight: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * Should be 12 but not '12px'.
   * @type {number}
   */
  fontSize: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontFamily: null,

  /**
   * Reserved for special functinality, like 'hr'.
   * @type {string}
   */
  textTag: null,

  /**
   * @type {string}
   */
  textFill: '#000',

  /**
   * @type {string}
   */
  textStroke: null,

  /**
   * @type {number}
   */
  textWidth: null,

  /**
   * Only for textBackground.
   * @type {number}
   */
  textHeight: null,

  /**
   * textStroke may be set as some color as a default
   * value in upper applicaion, where the default value
   * of textStrokeWidth should be 0 to make sure that
   * user can choose to do not use text stroke.
   * @type {number}
   */
  textStrokeWidth: 0,

  /**
   * @type {number}
   */
  textLineHeight: null,

  /**
   * 'inside', 'left', 'right', 'top', 'bottom'
   * [x, y]
   * Based on x, y of rect.
   * @type {string|Array.<number>}
   * @default 'inside'
   */
  textPosition: 'inside',

  /**
   * If not specified, use the boundingRect of a `displayable`.
   * @type {Object}
   */
  textRect: null,

  /**
   * [x, y]
   * @type {Array.<number>}
   */
  textOffset: null,

  /**
   * @type {string}
   */
  textAlign: null,

  /**
   * @type {string}
   */
  textVerticalAlign: null,

  /**
   * @type {number}
   */
  textDistance: 5,

  /**
   * @type {string}
   */
  textShadowColor: 'transparent',

  /**
   * @type {number}
   */
  textShadowBlur: 0,

  /**
   * @type {number}
   */
  textShadowOffsetX: 0,

  /**
   * @type {number}
   */
  textShadowOffsetY: 0,

  /**
   * @type {string}
   */
  textBoxShadowColor: 'transparent',

  /**
   * @type {number}
   */
  textBoxShadowBlur: 0,

  /**
   * @type {number}
   */
  textBoxShadowOffsetX: 0,

  /**
   * @type {number}
   */
  textBoxShadowOffsetY: 0,

  /**
   * Whether transform text.
   * Only useful in Path and Image element
   * @type {boolean}
   */
  transformText: false,

  /**
   * Text rotate around position of Path or Image
   * Only useful in Path and Image element and transformText is false.
   */
  textRotation: 0,

  /**
   * Text origin of text rotation, like [10, 40].
   * Based on x, y of rect.
   * Useful in label rotation of circular symbol.
   * By default, this origin is textPosition.
   * Can be 'center'.
   * @type {string|Array.<number>}
   */
  textOrigin: null,

  /**
   * @type {string}
   */
  textBackgroundColor: null,

  /**
   * @type {string}
   */
  textBorderColor: null,

  /**
   * @type {number}
   */
  textBorderWidth: 0,

  /**
   * @type {number}
   */
  textBorderRadius: 0,

  /**
   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
   * @type {number|Array.<number>}
   */
  textPadding: null,

  /**
   * Text styles for rich text.
   * @type {Object}
   */
  rich: null,

  /**
   * {outerWidth, outerHeight, ellipsis, placeholder}
   * @type {Object}
   */
  truncate: null,

  /**
   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
   * @type {string}
   */
  blend: null,

  /**
   * @param {CanvasRenderingContext2D} ctx
   */
  bind: function (ctx, el, prevEl) {
    var style = this;
    var prevStyle = prevEl && prevEl.style;
    var firstDraw = !prevStyle;

    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
      var prop = STYLE_COMMON_PROPS[i];
      var styleName = prop[0];

      if (firstDraw || style[styleName] !== prevStyle[styleName]) {
        // FIXME Invalid property value will cause style leak from previous element.
        ctx[styleName] = style[styleName] || prop[1];
      }
    }

    if (firstDraw || style.fill !== prevStyle.fill) {
      ctx.fillStyle = style.fill;
    }

    if (firstDraw || style.stroke !== prevStyle.stroke) {
      ctx.strokeStyle = style.stroke;
    }

    if (firstDraw || style.opacity !== prevStyle.opacity) {
      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
    }

    if (firstDraw || style.blend !== prevStyle.blend) {
      ctx.globalCompositeOperation = style.blend || 'source-over';
    }

    if (this.hasStroke()) {
      var lineWidth = style.lineWidth;
      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
    }
  },
  hasFill: function () {
    var fill = this.fill;
    return fill != null && fill !== 'none';
  },
  hasStroke: function () {
    var stroke = this.stroke;
    return stroke != null && stroke !== 'none' && this.lineWidth > 0;
  },

  /**
   * Extend from other style
   * @param {zrender/graphic/Style} otherStyle
   * @param {boolean} overwrite true: overwrirte any way.
   *                            false: overwrite only when !target.hasOwnProperty
   *                            others: overwrite when property is not null/undefined.
   */
  extendFrom: function (otherStyle, overwrite) {
    if (otherStyle) {
      for (var name in otherStyle) {
        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
          this[name] = otherStyle[name];
        }
      }
    }
  },

  /**
   * Batch setting style with a given object
   * @param {Object|string} obj
   * @param {*} [obj]
   */
  set: function (obj, value) {
    if (typeof obj === 'string') {
      this[obj] = value;
    } else {
      this.extendFrom(obj, true);
    }
  },

  /**
   * Clone
   * @return {zrender/graphic/Style} [description]
   */
  clone: function () {
    var newStyle = new this.constructor();
    newStyle.extendFrom(this, true);
    return newStyle;
  },
  getGradient: function (ctx, obj, rect) {
    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
    var canvasGradient = method(ctx, obj, rect);
    var colorStops = obj.colorStops;

    for (var i = 0; i < colorStops.length; i++) {
      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
    }

    return canvasGradient;
  }
};
var styleProto = Style.prototype;

for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
  var prop = STYLE_COMMON_PROPS[i];

  if (!(prop[0] in styleProto)) {
    styleProto[prop[0]] = prop[1];
  }
} // Provide for others


Style.getGradient = styleProto.getGradient;
var _default = Style;
module.exports = _default;

/***/ }),
/* 146 */
/***/ (function(module, exports) {

var Pattern = function (image, repeat) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {image: ...}`, where this constructor will not be called.
  this.image = image;
  this.repeat = repeat; // Can be cloned

  this.type = 'pattern';
};

Pattern.prototype.getCanvasPattern = function (ctx) {
  return ctx.createPattern(this.image, this.repeat || 'repeat');
};

var _default = Pattern;
module.exports = _default;

/***/ }),
/* 147 */
/***/ (function(module, exports) {

var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
  setTimeout(func, 16);
};

module.exports = _default;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var Displayable = __webpack_require__(127);

var BoundingRect = __webpack_require__(101);

var zrUtil = __webpack_require__(91);

var imageHelper = __webpack_require__(128);

/**
 * @alias zrender/graphic/Image
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
function ZImage(opts) {
  Displayable.call(this, opts);
}

ZImage.prototype = {
  constructor: ZImage,
  type: 'image',
  brush: function (ctx, prevEl) {
    var style = this.style;
    var src = style.image; // Must bind each time

    style.bind(ctx, this, prevEl);
    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);

    if (!image || !imageHelper.isImageReady(image)) {
      return;
    } // 图片已经加载完成
    // if (image.nodeName.toUpperCase() == 'IMG') {
    //     if (!image.complete) {
    //         return;
    //     }
    // }
    // Else is canvas


    var x = style.x || 0;
    var y = style.y || 0;
    var width = style.width;
    var height = style.height;
    var aspect = image.width / image.height;

    if (width == null && height != null) {
      // Keep image/height ratio
      width = height * aspect;
    } else if (height == null && width != null) {
      height = width / aspect;
    } else if (width == null && height == null) {
      width = image.width;
      height = image.height;
    } // 设置transform


    this.setTransform(ctx);

    if (style.sWidth && style.sHeight) {
      var sx = style.sx || 0;
      var sy = style.sy || 0;
      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
    } else if (style.sx && style.sy) {
      var sx = style.sx;
      var sy = style.sy;
      var sWidth = width - sx;
      var sHeight = height - sy;
      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
    } else {
      ctx.drawImage(image, x, y, width, height);
    }

    this.restoreTransform(ctx); // Draw rect text

    if (style.text != null) {
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },
  getBoundingRect: function () {
    var style = this.style;

    if (!this._rect) {
      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
    }

    return this._rect;
  }
};
zrUtil.inherits(ZImage, Displayable);
var _default = ZImage;
module.exports = _default;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(91);

var retrieve2 = _util.retrieve2;
var retrieve3 = _util.retrieve3;
var each = _util.each;
var normalizeCssArray = _util.normalizeCssArray;
var isString = _util.isString;
var isObject = _util.isObject;

var textContain = __webpack_require__(108);

var roundRectHelper = __webpack_require__(150);

var imageHelper = __webpack_require__(128);

// TODO: Have not support 'start', 'end' yet.
var VALID_TEXT_ALIGN = {
  left: 1,
  right: 1,
  center: 1
};
var VALID_TEXT_VERTICAL_ALIGN = {
  top: 1,
  bottom: 1,
  middle: 1
};
/**
 * @param {module:zrender/graphic/Style} style
 * @return {module:zrender/graphic/Style} The input style.
 */

function normalizeTextStyle(style) {
  normalizeStyle(style);
  each(style.rich, normalizeStyle);
  return style;
}

function normalizeStyle(style) {
  if (style) {
    style.font = textContain.makeFont(style);
    var textAlign = style.textAlign;
    textAlign === 'middle' && (textAlign = 'center');
    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.

    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
    var textPadding = style.textPadding;

    if (textPadding) {
      style.textPadding = normalizeCssArray(style.textPadding);
    }
  }
}
/**
 * @param {CanvasRenderingContext2D} ctx
 * @param {string} text
 * @param {module:zrender/graphic/Style} style
 * @param {Object|boolean} [rect] {x, y, width, height}
 *                  If set false, rect text is not used.
 */


function renderText(hostEl, ctx, text, style, rect) {
  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);
}

function renderPlainText(hostEl, ctx, text, style, rect) {
  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);
  var textPadding = style.textPadding;
  var contentBlock = hostEl.__textCotentBlock;

  if (!contentBlock || hostEl.__dirty) {
    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);
  }

  var outerHeight = contentBlock.outerHeight;
  var textLines = contentBlock.lines;
  var lineHeight = contentBlock.lineHeight;
  var boxPos = getBoxPosition(outerHeight, style, rect);
  var baseX = boxPos.baseX;
  var baseY = boxPos.baseY;
  var textAlign = boxPos.textAlign;
  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

  applyTextRotation(ctx, style, rect, baseX, baseY);
  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var textX = baseX;
  var textY = boxY;
  var needDrawBg = needDrawBackground(style);

  if (needDrawBg || textPadding) {
    // Consider performance, do not call getTextWidth util necessary.
    var textWidth = textContain.getWidth(text, font);
    var outerWidth = textWidth;
    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      textY += textPadding[0];
    }
  }

  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be "middle". Otherwise, if using "top", the
  // text will offset downward a little bit in font "Microsoft YaHei".

  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.

  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.

  textY += lineHeight / 2;
  var textStrokeWidth = style.textStrokeWidth;
  var textStroke = getStroke(style.textStroke, textStrokeWidth);
  var textFill = getFill(style.textFill);

  if (textStroke) {
    setCtx(ctx, 'lineWidth', textStrokeWidth);
    setCtx(ctx, 'strokeStyle', textStroke);
  }

  if (textFill) {
    setCtx(ctx, 'fillStyle', textFill);
  }

  for (var i = 0; i < textLines.length; i++) {
    // Fill after stroke so the outline will not cover the main part.
    textStroke && ctx.strokeText(textLines[i], textX, textY);
    textFill && ctx.fillText(textLines[i], textX, textY);
    textY += lineHeight;
  }
}

function renderRichText(hostEl, ctx, text, style, rect) {
  var contentBlock = hostEl.__textCotentBlock;

  if (!contentBlock || hostEl.__dirty) {
    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
  }

  drawRichText(hostEl, ctx, contentBlock, style, rect);
}

function drawRichText(hostEl, ctx, contentBlock, style, rect) {
  var contentWidth = contentBlock.width;
  var outerWidth = contentBlock.outerWidth;
  var outerHeight = contentBlock.outerHeight;
  var textPadding = style.textPadding;
  var boxPos = getBoxPosition(outerHeight, style, rect);
  var baseX = boxPos.baseX;
  var baseY = boxPos.baseY;
  var textAlign = boxPos.textAlign;
  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

  applyTextRotation(ctx, style, rect, baseX, baseY);
  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var xLeft = boxX;
  var lineTop = boxY;

  if (textPadding) {
    xLeft += textPadding[3];
    lineTop += textPadding[0];
  }

  var xRight = xLeft + contentWidth;
  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

  for (var i = 0; i < contentBlock.lines.length; i++) {
    var line = contentBlock.lines[i];
    var tokens = line.tokens;
    var tokenCount = tokens.length;
    var lineHeight = line.lineHeight;
    var usedWidth = line.width;
    var leftIndex = 0;
    var lineXLeft = xLeft;
    var lineXRight = xRight;
    var rightIndex = tokenCount - 1;
    var token;

    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
      usedWidth -= token.width;
      lineXLeft += token.width;
      leftIndex++;
    }

    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
      usedWidth -= token.width;
      lineXRight -= token.width;
      rightIndex--;
    } // The other tokens are placed as textAlign 'center' if there is enough space.


    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;

    while (leftIndex <= rightIndex) {
      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.

      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
      lineXLeft += token.width;
      leftIndex++;
    }

    lineTop += lineHeight;
  }
}

function applyTextRotation(ctx, style, rect, x, y) {
  // textRotation only apply in RectText.
  if (rect && style.textRotation) {
    var origin = style.textOrigin;

    if (origin === 'center') {
      x = rect.width / 2 + rect.x;
      y = rect.height / 2 + rect.y;
    } else if (origin) {
      x = origin[0] + rect.x;
      y = origin[1] + rect.y;
    }

    ctx.translate(x, y); // Positive: anticlockwise

    ctx.rotate(-style.textRotation);
    ctx.translate(-x, -y);
  }
}

function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of
  // the bias of "Microsoft YaHei".

  var textVerticalAlign = token.textVerticalAlign;
  var y = lineTop + lineHeight / 2;

  if (textVerticalAlign === 'top') {
    y = lineTop + token.height / 2;
  } else if (textVerticalAlign === 'bottom') {
    y = lineTop + lineHeight - token.height / 2;
  }

  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
  var textPadding = token.textPadding;

  if (textPadding) {
    x = getTextXForPadding(x, textAlign, textPadding);
    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
  }

  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
  // text will offset downward a little bit in font "Microsoft YaHei".

  setCtx(ctx, 'textBaseline', 'middle');
  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);
  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
  var textFill = getFill(tokenStyle.textFill || style.textFill);
  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.

  if (textStroke) {
    setCtx(ctx, 'lineWidth', textStrokeWidth);
    setCtx(ctx, 'strokeStyle', textStroke);
    ctx.strokeText(token.text, x, y);
  }

  if (textFill) {
    setCtx(ctx, 'fillStyle', textFill);
    ctx.fillText(token.text, x, y);
  }
}

function needDrawBackground(style) {
  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;
} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
// shape: {x, y, width, height}


function drawBackground(hostEl, ctx, style, x, y, width, height) {
  var textBackgroundColor = style.textBackgroundColor;
  var textBorderWidth = style.textBorderWidth;
  var textBorderColor = style.textBorderColor;
  var isPlainBg = isString(textBackgroundColor);
  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);

  if (isPlainBg || textBorderWidth && textBorderColor) {
    ctx.beginPath();
    var textBorderRadius = style.textBorderRadius;

    if (!textBorderRadius) {
      ctx.rect(x, y, width, height);
    } else {
      roundRectHelper.buildPath(ctx, {
        x: x,
        y: y,
        width: width,
        height: height,
        r: textBorderRadius
      });
    }

    ctx.closePath();
  }

  if (isPlainBg) {
    setCtx(ctx, 'fillStyle', textBackgroundColor);
    ctx.fill();
  } else if (isObject(textBackgroundColor)) {
    var image = textBackgroundColor.image;
    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);

    if (image && imageHelper.isImageReady(image)) {
      ctx.drawImage(image, x, y, width, height);
    }
  }

  if (textBorderWidth && textBorderColor) {
    setCtx(ctx, 'lineWidth', textBorderWidth);
    setCtx(ctx, 'strokeStyle', textBorderColor);
    ctx.stroke();
  }
}

function onBgImageLoaded(image, textBackgroundColor) {
  // Replace image, so that `contain/text.js#parseRichText`
  // will get correct result in next tick.
  textBackgroundColor.image = image;
}

function getBoxPosition(blockHeiht, style, rect) {
  var baseX = style.x || 0;
  var baseY = style.y || 0;
  var textAlign = style.textAlign;
  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord

  if (rect) {
    var textPosition = style.textPosition;

    if (textPosition instanceof Array) {
      // Percent
      baseX = rect.x + parsePercent(textPosition[0], rect.width);
      baseY = rect.y + parsePercent(textPosition[1], rect.height);
    } else {
      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);
      baseX = res.x;
      baseY = res.y; // Default align and baseline when has textPosition

      textAlign = textAlign || res.textAlign;
      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
    } // textOffset is only support in RectText, otherwise
    // we have to adjust boundingRect for textOffset.


    var textOffset = style.textOffset;

    if (textOffset) {
      baseX += textOffset[0];
      baseY += textOffset[1];
    }
  }

  return {
    baseX: baseX,
    baseY: baseY,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}

function setCtx(ctx, prop, value) {
  // FIXME ??? performance try
  // if (ctx.__currentValues[prop] !== value) {
  // ctx[prop] = ctx.__currentValues[prop] = value;
  ctx[prop] = value; // }

  return ctx[prop];
}
/**
 * @param {string} [stroke] If specified, do not check style.textStroke.
 * @param {string} [lineWidth] If specified, do not check style.textStroke.
 * @param {number} style
 */


function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
  : stroke.image || stroke.colorStops ? '#000' : stroke;
}

function getFill(fill) {
  return fill == null || fill === 'none' ? null // TODO pattern and gradient?
  : fill.image || fill.colorStops ? '#000' : fill;
}

function parsePercent(value, maxValue) {
  if (typeof value === 'string') {
    if (value.lastIndexOf('%') >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }

    return parseFloat(value);
  }

  return value;
}

function getTextXForPadding(x, textAlign, textPadding) {
  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}
/**
 * @param {string} text
 * @param {module:zrender/Style} style
 * @return {boolean}
 */


function needDrawText(text, style) {
  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
}

exports.normalizeTextStyle = normalizeTextStyle;
exports.renderText = renderText;
exports.getStroke = getStroke;
exports.getFill = getFill;
exports.needDrawText = needDrawText;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

function buildPath(ctx, shape) {
  var x = shape.x;
  var y = shape.y;
  var width = shape.width;
  var height = shape.height;
  var r = shape.r;
  var r1;
  var r2;
  var r3;
  var r4; // Convert width and height to positive for better borderRadius

  if (width < 0) {
    x = x + width;
    width = -width;
  }

  if (height < 0) {
    y = y + height;
    height = -height;
  }

  if (typeof r === 'number') {
    r1 = r2 = r3 = r4 = r;
  } else if (r instanceof Array) {
    if (r.length === 1) {
      r1 = r2 = r3 = r4 = r[0];
    } else if (r.length === 2) {
      r1 = r3 = r[0];
      r2 = r4 = r[1];
    } else if (r.length === 3) {
      r1 = r[0];
      r2 = r4 = r[1];
      r3 = r[2];
    } else {
      r1 = r[0];
      r2 = r[1];
      r3 = r[2];
      r4 = r[3];
    }
  } else {
    r1 = r2 = r3 = r4 = 0;
  }

  var total;

  if (r1 + r2 > width) {
    total = r1 + r2;
    r1 *= width / total;
    r2 *= width / total;
  }

  if (r3 + r4 > width) {
    total = r3 + r4;
    r3 *= width / total;
    r4 *= width / total;
  }

  if (r2 + r3 > height) {
    total = r2 + r3;
    r2 *= height / total;
    r3 *= height / total;
  }

  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }

  ctx.moveTo(x + r1, y);
  ctx.lineTo(x + width - r2, y);
  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
  ctx.lineTo(x + width, y + height - r3);
  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
  ctx.lineTo(x + r4, y + height);
  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
  ctx.lineTo(x, y + r1);
  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
}

exports.buildPath = buildPath;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var vec2 = __webpack_require__(97);

var curve = __webpack_require__(111);

/**
 * @author Yi Shen(https://github.com/pissang)
 */
var mathMin = Math.min;
var mathMax = Math.max;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI2 = Math.PI * 2;
var start = vec2.create();
var end = vec2.create();
var extremity = vec2.create();
/**
 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
 * @module zrender/core/bbox
 * @param {Array<Object>} points 顶点数组
 * @param {number} min
 * @param {number} max
 */

function fromPoints(points, min, max) {
  if (points.length === 0) {
    return;
  }

  var p = points[0];
  var left = p[0];
  var right = p[0];
  var top = p[1];
  var bottom = p[1];
  var i;

  for (i = 1; i < points.length; i++) {
    p = points[i];
    left = mathMin(left, p[0]);
    right = mathMax(right, p[0]);
    top = mathMin(top, p[1]);
    bottom = mathMax(bottom, p[1]);
  }

  min[0] = left;
  min[1] = top;
  max[0] = right;
  max[1] = bottom;
}
/**
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromLine(x0, y0, x1, y1, min, max) {
  min[0] = mathMin(x0, x1);
  min[1] = mathMin(y0, y1);
  max[0] = mathMax(x0, x1);
  max[1] = mathMax(y0, y1);
}

var xDim = [];
var yDim = [];
/**
 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */

function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
  var cubicExtrema = curve.cubicExtrema;
  var cubicAt = curve.cubicAt;
  var i;
  var n = cubicExtrema(x0, x1, x2, x3, xDim);
  min[0] = Infinity;
  min[1] = Infinity;
  max[0] = -Infinity;
  max[1] = -Infinity;

  for (i = 0; i < n; i++) {
    var x = cubicAt(x0, x1, x2, x3, xDim[i]);
    min[0] = mathMin(x, min[0]);
    max[0] = mathMax(x, max[0]);
  }

  n = cubicExtrema(y0, y1, y2, y3, yDim);

  for (i = 0; i < n; i++) {
    var y = cubicAt(y0, y1, y2, y3, yDim[i]);
    min[1] = mathMin(y, min[1]);
    max[1] = mathMax(y, max[1]);
  }

  min[0] = mathMin(x0, min[0]);
  max[0] = mathMax(x0, max[0]);
  min[0] = mathMin(x3, min[0]);
  max[0] = mathMax(x3, max[0]);
  min[1] = mathMin(y0, min[1]);
  max[1] = mathMax(y0, max[1]);
  min[1] = mathMin(y3, min[1]);
  max[1] = mathMax(y3, max[1]);
}
/**
 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
  var quadraticExtremum = curve.quadraticExtremum;
  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero

  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
  var x = quadraticAt(x0, x1, x2, tx);
  var y = quadraticAt(y0, y1, y2, ty);
  min[0] = mathMin(x0, x2, x);
  min[1] = mathMin(y0, y2, y);
  max[0] = mathMax(x0, x2, x);
  max[1] = mathMax(y0, y2, y);
}
/**
 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
 * @method
 * @memberOf module:zrender/core/bbox
 * @param {number} x
 * @param {number} y
 * @param {number} rx
 * @param {number} ry
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} anticlockwise
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
  var vec2Min = vec2.min;
  var vec2Max = vec2.max;
  var diff = Math.abs(startAngle - endAngle);

  if (diff % PI2 < 1e-4 && diff > 1e-4) {
    // Is a circle
    min[0] = x - rx;
    min[1] = y - ry;
    max[0] = x + rx;
    max[1] = y + ry;
    return;
  }

  start[0] = mathCos(startAngle) * rx + x;
  start[1] = mathSin(startAngle) * ry + y;
  end[0] = mathCos(endAngle) * rx + x;
  end[1] = mathSin(endAngle) * ry + y;
  vec2Min(min, start, end);
  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]

  startAngle = startAngle % PI2;

  if (startAngle < 0) {
    startAngle = startAngle + PI2;
  }

  endAngle = endAngle % PI2;

  if (endAngle < 0) {
    endAngle = endAngle + PI2;
  }

  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2;
  }

  if (anticlockwise) {
    var tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  } // var number = 0;
  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;


  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
    if (angle > startAngle) {
      extremity[0] = mathCos(angle) * rx + x;
      extremity[1] = mathSin(angle) * ry + y;
      vec2Min(min, extremity, min);
      vec2Max(max, extremity, max);
    }
  }
}

exports.fromPoints = fromPoints;
exports.fromLine = fromLine;
exports.fromCubic = fromCubic;
exports.fromQuadratic = fromQuadratic;
exports.fromArc = fromArc;

/***/ }),
/* 152 */
/***/ (function(module, exports) {

var PI2 = Math.PI * 2;

function normalizeRadian(angle) {
  angle %= PI2;

  if (angle < 0) {
    angle += PI2;
  }

  return angle;
}

exports.normalizeRadian = normalizeRadian;

/***/ }),
/* 153 */
/***/ (function(module, exports) {

function windingLine(x0, y0, x1, y1, x, y) {
  if (y > y0 && y > y1 || y < y0 && y < y1) {
    return 0;
  } // Ignore horizontal line


  if (y1 === y0) {
    return 0;
  }

  var dir = y1 < y0 ? 1 : -1;
  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon

  if (t === 1 || t === 0) {
    dir = y1 < y0 ? 0.5 : -0.5;
  }

  var x_ = t * (x1 - x0) + x0;
  return x_ > x ? dir : 0;
}

module.exports = windingLine;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var env = __webpack_require__(98);

// Fix weird bug in some version of IE11 (like 11.0.9600.178**),
// where exception "unexpected call to method or property access"
// might be thrown when calling ctx.fill or ctx.stroke after a path
// whose area size is zero is drawn and ctx.clip() is called and
// shadowBlur is set. See #4572, #3112, #5777.
// (e.g.,
//  ctx.moveTo(10, 10);
//  ctx.lineTo(20, 10);
//  ctx.closePath();
//  ctx.clip();
//  ctx.shadowBlur = 10;
//  ...
//  ctx.fill();
// )
var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];

function _default(orignalBrush) {
  // version string can be: '11.0'
  return env.browser.ie && env.browser.version >= 11 ? function () {
    var clipPaths = this.__clipPaths;
    var style = this.style;
    var modified;

    if (clipPaths) {
      for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];
        var shape = clipPath && clipPath.shape;
        var type = clipPath && clipPath.type;

        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
          for (var j = 0; j < shadowTemp.length; j++) {
            // It is save to put shadowTemp static, because shadowTemp
            // will be all modified each item brush called.
            shadowTemp[j][2] = style[shadowTemp[j][0]];
            style[shadowTemp[j][0]] = shadowTemp[j][1];
          }

          modified = true;
          break;
        }
      }
    }

    orignalBrush.apply(this, arguments);

    if (modified) {
      for (var j = 0; j < shadowTemp.length; j++) {
        style[shadowTemp[j][0]] = shadowTemp[j][2];
      }
    }
  } : orignalBrush;
}

module.exports = _default;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var smoothSpline = __webpack_require__(213);

var smoothBezier = __webpack_require__(214);

function buildPath(ctx, shape, closePath) {
  var points = shape.points;
  var smooth = shape.smooth;

  if (points && points.length >= 2) {
    if (smooth && smooth !== 'spline') {
      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points[0][0], points[0][1]);
      var len = points.length;

      for (var i = 0; i < (closePath ? len : len - 1); i++) {
        var cp1 = controlPoints[i * 2];
        var cp2 = controlPoints[i * 2 + 1];
        var p = points[(i + 1) % len];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
      }
    } else {
      if (smooth === 'spline') {
        points = smoothSpline(points, closePath);
      }

      ctx.moveTo(points[0][0], points[0][1]);

      for (var i = 1, l = points.length; i < l; i++) {
        ctx.lineTo(points[i][0], points[i][1]);
      }
    }

    closePath && ctx.closePath();
  }
}

exports.buildPath = buildPath;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var _clazz = __webpack_require__(104);

var set = _clazz.set;
var get = _clazz.get;
var _default = {
  clearColorPalette: function () {
    set(this, 'colorIdx', 0);
    set(this, 'colorNameMap', {});
  },
  getColorFromPalette: function (name, scope) {
    scope = scope || this;
    var colorIdx = get(scope, 'colorIdx') || 0;
    var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {}); // Use `hasOwnProperty` to avoid conflict with Object.prototype.

    if (colorNameMap.hasOwnProperty(name)) {
      return colorNameMap[name];
    }

    var colorPalette = this.get('color', true) || [];

    if (!colorPalette.length) {
      return;
    }

    var color = colorPalette[colorIdx];

    if (name) {
      colorNameMap[name] = color;
    }

    set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);
    return color;
  }
};
module.exports = _default;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var Group = __webpack_require__(119);

var componentUtil = __webpack_require__(130);

var clazzUtil = __webpack_require__(104);

var Component = function () {
  /**
   * @type {module:zrender/container/Group}
   * @readOnly
   */
  this.group = new Group();
  /**
   * @type {string}
   * @readOnly
   */

  this.uid = componentUtil.getUID('viewComponent');
};

Component.prototype = {
  constructor: Component,
  init: function (ecModel, api) {},
  render: function (componentModel, ecModel, api, payload) {},
  dispose: function () {}
};
var componentProto = Component.prototype;

componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {// Do nothing;
}; // Enable Component.extend.


clazzUtil.enableClassExtend(Component); // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

clazzUtil.enableClassManagement(Component, {
  registerWhenExtend: true
});
var _default = Component;
module.exports = _default;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Group = __webpack_require__(119);

var componentUtil = __webpack_require__(130);

var clazzUtil = __webpack_require__(104);

var modelUtil = __webpack_require__(95);

function Chart() {
  /**
   * @type {module:zrender/container/Group}
   * @readOnly
   */
  this.group = new Group();
  /**
   * @type {string}
   * @readOnly
   */

  this.uid = componentUtil.getUID('viewChart');
}

Chart.prototype = {
  type: 'chart',

  /**
   * Init the chart
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  init: function (ecModel, api) {},

  /**
   * Render the chart
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  render: function (seriesModel, ecModel, api, payload) {},

  /**
   * Highlight series or specified data item
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  highlight: function (seriesModel, ecModel, api, payload) {
    toggleHighlight(seriesModel.getData(), payload, 'emphasis');
  },

  /**
   * Downplay series or specified data item
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  downplay: function (seriesModel, ecModel, api, payload) {
    toggleHighlight(seriesModel.getData(), payload, 'normal');
  },

  /**
   * Remove self
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  remove: function (ecModel, api) {
    this.group.removeAll();
  },

  /**
   * Dispose self
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  dispose: function () {}
  /**
   * The view contains the given point.
   * @interface
   * @param {Array.<number>} point
   * @return {boolean}
   */
  // containPoint: function () {}

};
var chartProto = Chart.prototype;

chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {
  this.render(seriesModel, ecModel, api, payload);
};
/**
 * Set state of single element
 * @param  {module:zrender/Element} el
 * @param  {string} state
 */


function elSetState(el, state) {
  if (el) {
    el.trigger(state);

    if (el.type === 'group') {
      for (var i = 0; i < el.childCount(); i++) {
        elSetState(el.childAt(i), state);
      }
    }
  }
}
/**
 * @param  {module:echarts/data/List} data
 * @param  {Object} payload
 * @param  {string} state 'normal'|'emphasis'
 * @inner
 */


function toggleHighlight(data, payload, state) {
  var dataIndex = modelUtil.queryDataIndex(data, payload);

  if (dataIndex != null) {
    zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state);
    });
  } else {
    data.eachItemGraphicEl(function (el) {
      elSetState(el, state);
    });
  }
} // Enable Chart.extend.


clazzUtil.enableClassExtend(Chart, ['dispose']); // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

clazzUtil.enableClassManagement(Chart, {
  registerWhenExtend: true
});
var _default = Chart;
module.exports = _default;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var _model = __webpack_require__(95);

var normalizeToArray = _model.normalizeToArray;

/**
 * Complete dimensions by data (guess dimension).
 */
var each = zrUtil.each;
var isString = zrUtil.isString;
var defaults = zrUtil.defaults;
var OTHER_DIMS = {
  tooltip: 1,
  label: 1,
  itemName: 1
};
/**
 * Complete the dimensions array, by user defined `dimension` and `encode`,
 * and guessing from the data structure.
 * If no 'value' dimension specified, the first no-named dimension will be
 * named as 'value'.
 *
 * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which
 *      provides not only dim template, but also default order.
 *      `name` of each item provides default coord name.
 *      [{dimsDef: []}, ...] can be specified to give names.
 * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].
 * @param {Object} [opt]
 * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions
 *      For example: ['asdf', {name, type}, ...].
 * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}
 * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.
 * @param {string} [opt.extraFromZero] If specified, extra dim names will be:
 *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...
 *                      If not specified, extra dim names will be:
 *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...
 * @param {number} [opt.dimCount] If not specified, guess by the first data item.
 * @return {Array.<Object>} [{
 *      name: string mandatory,
 *      coordDim: string mandatory,
 *      coordDimIndex: number mandatory,
 *      type: string optional,
 *      tooltipName: string optional,
 *      otherDims: {
 *          tooltip: number optional,
 *          label: number optional
 *      },
 *      isExtraCoord: boolean true or undefined.
 *      other props ...
 * }]
 */

function completeDimensions(sysDims, data, opt) {
  data = data || [];
  opt = opt || {};
  sysDims = (sysDims || []).slice();
  var dimsDef = (opt.dimsDef || []).slice();
  var encodeDef = zrUtil.createHashMap(opt.encodeDef);
  var dataDimNameMap = zrUtil.createHashMap();
  var coordDimNameMap = zrUtil.createHashMap(); // var valueCandidate;

  var result = [];
  var dimCount = opt.dimCount;

  if (dimCount == null) {
    var value0 = retrieveValue(data[0]);
    dimCount = Math.max(zrUtil.isArray(value0) && value0.length || 1, sysDims.length, dimsDef.length);
    each(sysDims, function (sysDimItem) {
      var sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));
    });
  } // Apply user defined dims (`name` and `type`) and init result.


  for (var i = 0; i < dimCount; i++) {
    var dimDefItem = isString(dimsDef[i]) ? {
      name: dimsDef[i]
    } : dimsDef[i] || {};
    var userDimName = dimDefItem.name;
    var resultItem = result[i] = {
      otherDims: {}
    }; // Name will be applied later for avoiding duplication.

    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      // Only if `series.dimensions` is defined in option, tooltipName
      // will be set, and dimension will be diplayed vertically in
      // tooltip by default.
      resultItem.name = resultItem.tooltipName = userDimName;
      dataDimNameMap.set(userDimName, i);
    }

    dimDefItem.type != null && (resultItem.type = dimDefItem.type);
  } // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.


  encodeDef.each(function (dataDims, coordDim) {
    dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());
    each(dataDims, function (resultDimIdx, coordDimIndex) {
      // The input resultDimIdx can be dim name or index.
      isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));

      if (resultDimIdx != null && resultDimIdx < dimCount) {
        dataDims[coordDimIndex] = resultDimIdx;
        applyDim(result[resultDimIdx], coordDim, coordDimIndex);
      }
    });
  }); // Apply templetes and default order from `sysDims`.

  var availDimIdx = 0;
  each(sysDims, function (sysDimItem, sysDimIndex) {
    var coordDim;
    var sysDimItem;
    var sysDimItemDimsDef;
    var sysDimItemOtherDims;

    if (isString(sysDimItem)) {
      coordDim = sysDimItem;
      sysDimItem = {};
    } else {
      coordDim = sysDimItem.name;
      sysDimItem = zrUtil.clone(sysDimItem); // `coordDimIndex` should not be set directly.

      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }

    var dataDims = normalizeToArray(encodeDef.get(coordDim)); // dimensions provides default dim sequences.

    if (!dataDims.length) {
      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {
          availDimIdx++;
        }

        availDimIdx < result.length && dataDims.push(availDimIdx++);
      }
    } // Apply templates.


    each(dataDims, function (resultDimIdx, coordDimIndex) {
      var resultItem = result[resultDimIdx];
      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);

      if (resultItem.name == null && sysDimItemDimsDef) {
        resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];
      }

      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);
    });
  }); // Make sure the first extra dim is 'value'.

  var extra = opt.extraPrefix || 'value'; // Set dim `name` and other `coordDim` and other props.

  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
    var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};
    var coordDim = resultItem.coordDim;
    coordDim == null && (resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero), resultItem.coordDimIndex = 0, resultItem.isExtraCoord = true);
    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));
    resultItem.type == null && guessOrdinal(data, resultDimIdx) && (resultItem.type = 'ordinal');
  }

  return result;

  function applyDim(resultItem, coordDim, coordDimIndex) {
    if (OTHER_DIMS[coordDim]) {
      resultItem.otherDims[coordDim] = coordDimIndex;
    } else {
      resultItem.coordDim = coordDim;
      resultItem.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim, true);
    }
  }

  function genName(name, map, fromZero) {
    if (fromZero || map.get(name) != null) {
      var i = 0;

      while (map.get(name + i) != null) {
        i++;
      }

      name += i;
    }

    map.set(name, true);
    return name;
  }
} // The rule should not be complex, otherwise user might not
// be able to known where the data is wrong.


var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {
  for (var i = 0, len = data.length; i < len; i++) {
    var value = retrieveValue(data[i]);

    if (!zrUtil.isArray(value)) {
      return false;
    }

    var value = value[dimIndex]; // Consider usage convenience, '1', '2' will be treated as "number".
    // `isFinit('')` get `true`.

    if (value != null && isFinite(value) && value !== '') {
      return false;
    } else if (isString(value) && value !== '-') {
      return true;
    }
  }

  return false;
};

function retrieveValue(o) {
  return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;
}

var _default = completeDimensions;
module.exports = _default;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var numberUtil = __webpack_require__(94);

/**
 * For testable.
 */
var roundNumber = numberUtil.round;
/**
 * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.
 *                                Should be extent[0] < extent[1].
 * @param {number} splitNumber splitNumber should be >= 1.
 * @param {number} [minInterval]
 * @param {number} [maxInterval]
 * @return {Object} {interval, intervalPrecision, niceTickExtent}
 */

function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
  var result = {};
  var span = extent[1] - extent[0];
  var interval = result.interval = numberUtil.nice(span / splitNumber, true);

  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }

  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  } // Tow more digital for tick.


  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent

  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];
  fixExtent(niceTickExtent, extent);
  return result;
}
/**
 * @param {number} interval
 * @return {number} interval precision
 */


function getIntervalPrecision(interval) {
  // Tow more digital for tick.
  return numberUtil.getPrecisionSafe(interval) + 2;
}

function clamp(niceTickExtent, idx, extent) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.


function fixExtent(niceTickExtent, extent) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
  clamp(niceTickExtent, 0, extent);
  clamp(niceTickExtent, 1, extent);

  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}

function intervalScaleGetTicks(interval, extent, niceTickExtent, intervalPrecision) {
  var ticks = []; // If interval is 0, return [];

  if (!interval) {
    return ticks;
  } // Consider this case: using dataZoom toolbox, zoom and zoom.


  var safeLimit = 10000;

  if (extent[0] < niceTickExtent[0]) {
    ticks.push(extent[0]);
  }

  var tick = niceTickExtent[0];

  while (tick <= niceTickExtent[1]) {
    ticks.push(tick); // Avoid rounding error

    tick = roundNumber(tick + interval, intervalPrecision);

    if (tick === ticks[ticks.length - 1]) {
      // Consider out of safe float point, e.g.,
      // -3711126.9907707 + 2e-10 === -3711126.9907707
      break;
    }

    if (ticks.length > safeLimit) {
      return [];
    }
  } // Consider this case: the last item of ticks is smaller
  // than niceTickExtent[1] and niceTickExtent[1] === extent[1].


  if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {
    ticks.push(extent[1]);
  }

  return ticks;
}

exports.intervalScaleNiceTicks = intervalScaleNiceTicks;
exports.getIntervalPrecision = getIntervalPrecision;
exports.fixExtent = fixExtent;
exports.intervalScaleGetTicks = intervalScaleGetTicks;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var axisHelper = __webpack_require__(112);

function getName(obj) {
  if (zrUtil.isObject(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + '';
  }
}

var _default = {
  /**
   * Format labels
   * @return {Array.<string>}
   */
  getFormattedLabels: function () {
    return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));
  },

  /**
   * Get categories
   */
  getCategories: function () {
    return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);
  },

  /**
   * @param {boolean} origin
   * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN
   */
  getMin: function (origin) {
    var option = this.option;
    var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;

    if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !zrUtil.eqNaN(min)) {
      min = this.axis.scale.parse(min);
    }

    return min;
  },

  /**
   * @param {boolean} origin
   * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN
   */
  getMax: function (origin) {
    var option = this.option;
    var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;

    if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !zrUtil.eqNaN(max)) {
      max = this.axis.scale.parse(max);
    }

    return max;
  },

  /**
   * @return {boolean}
   */
  getNeedCrossZero: function () {
    var option = this.option;
    return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;
  },

  /**
   * Should be implemented by each axis model if necessary.
   * @return {module:echarts/model/Component} coordinate system model
   */
  getCoordSysModel: zrUtil.noop,

  /**
   * @param {number} rangeStart Can only be finite number or null/undefined or NaN.
   * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.
   */
  setRange: function (rangeStart, rangeEnd) {
    this.option.rangeStart = rangeStart;
    this.option.rangeEnd = rangeEnd;
  },

  /**
   * Reset range
   */
  resetRange: function () {
    // rangeStart and rangeEnd is readonly.
    this.option.rangeStart = this.option.rangeEnd = null;
  }
};
module.exports = _default;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var numberUtil = __webpack_require__(94);

var axisHelper = __webpack_require__(112);

var linearMap = numberUtil.linearMap;

function fixExtentWithBands(extent, nTick) {
  var size = extent[1] - extent[0];
  var len = nTick;
  var margin = size / len / 2;
  extent[0] += margin;
  extent[1] -= margin;
}

var normalizedExtent = [0, 1];
/**
 * @name module:echarts/coord/CartesianAxis
 * @constructor
 */

var Axis = function (dim, scale, extent) {
  /**
   * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'
   * @type {string}
   */
  this.dim = dim;
  /**
   * Axis scale
   * @type {module:echarts/coord/scale/*}
   */

  this.scale = scale;
  /**
   * @type {Array.<number>}
   * @private
   */

  this._extent = extent || [0, 0];
  /**
   * @type {boolean}
   */

  this.inverse = false;
  /**
   * Usually true when axis has a ordinal scale
   * @type {boolean}
   */

  this.onBand = false;
  /**
   * @private
   * @type {number}
   */

  this._labelInterval;
};

Axis.prototype = {
  constructor: Axis,

  /**
   * If axis extent contain given coord
   * @param {number} coord
   * @return {boolean}
   */
  contain: function (coord) {
    var extent = this._extent;
    var min = Math.min(extent[0], extent[1]);
    var max = Math.max(extent[0], extent[1]);
    return coord >= min && coord <= max;
  },

  /**
   * If axis extent contain given data
   * @param {number} data
   * @return {boolean}
   */
  containData: function (data) {
    return this.contain(this.dataToCoord(data));
  },

  /**
   * Get coord extent.
   * @return {Array.<number>}
   */
  getExtent: function () {
    return this._extent.slice();
  },

  /**
   * Get precision used for formatting
   * @param {Array.<number>} [dataExtent]
   * @return {number}
   */
  getPixelPrecision: function (dataExtent) {
    return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  },

  /**
   * Set coord extent
   * @param {number} start
   * @param {number} end
   */
  setExtent: function (start, end) {
    var extent = this._extent;
    extent[0] = start;
    extent[1] = end;
  },

  /**
   * Convert data to coord. Data is the rank if it has a ordinal scale
   * @param {number} data
   * @param  {boolean} clamp
   * @return {number}
   */
  dataToCoord: function (data, clamp) {
    var extent = this._extent;
    var scale = this.scale;
    data = scale.normalize(data);

    if (this.onBand && scale.type === 'ordinal') {
      extent = extent.slice();
      fixExtentWithBands(extent, scale.count());
    }

    return linearMap(data, normalizedExtent, extent, clamp);
  },

  /**
   * Convert coord to data. Data is the rank if it has a ordinal scale
   * @param {number} coord
   * @param  {boolean} clamp
   * @return {number}
   */
  coordToData: function (coord, clamp) {
    var extent = this._extent;
    var scale = this.scale;

    if (this.onBand && scale.type === 'ordinal') {
      extent = extent.slice();
      fixExtentWithBands(extent, scale.count());
    }

    var t = linearMap(coord, extent, normalizedExtent, clamp);
    return this.scale.scale(t);
  },

  /**
   * Convert pixel point to data in axis
   * @param {Array.<number>} point
   * @param  {boolean} clamp
   * @return {number} data
   */
  pointToData: function (point, clamp) {// Should be implemented in derived class if necessary.
  },

  /**
   * @return {Array.<number>}
   */
  getTicksCoords: function (alignWithLabel) {
    if (this.onBand && !alignWithLabel) {
      var bands = this.getBands();
      var coords = [];

      for (var i = 0; i < bands.length; i++) {
        coords.push(bands[i][0]);
      }

      if (bands[i - 1]) {
        coords.push(bands[i - 1][1]);
      }

      return coords;
    } else {
      return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
    }
  },

  /**
   * Coords of labels are on the ticks or on the middle of bands
   * @return {Array.<number>}
   */
  getLabelsCoords: function () {
    return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
  },

  /**
   * Get bands.
   *
   * If axis has labels [1, 2, 3, 4]. Bands on the axis are
   * |---1---|---2---|---3---|---4---|.
   *
   * @return {Array}
   */
  // FIXME Situation when labels is on ticks
  getBands: function () {
    var extent = this.getExtent();
    var bands = [];
    var len = this.scale.count();
    var start = extent[0];
    var end = extent[1];
    var span = end - start;

    for (var i = 0; i < len; i++) {
      bands.push([span * i / len + start, span * (i + 1) / len + start]);
    }

    return bands;
  },

  /**
   * Get width of band
   * @return {number}
   */
  getBandWidth: function () {
    var axisExtent = this._extent;
    var dataExtent = this.scale.getExtent();
    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.

    len === 0 && (len = 1);
    var size = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size) / len;
  },

  /**
   * @abstract
   * @return {boolean} Is horizontal
   */
  isHorizontal: null,

  /**
   * @abstract
   * @return {number} Get axis rotate, by degree.
   */
  getRotate: null,

  /**
   * Get interval of the axis label.
   * To get precise result, at least one of `getRotate` and `isHorizontal`
   * should be implemented.
   * @return {number}
   */
  getLabelInterval: function () {
    var labelInterval = this._labelInterval;

    if (!labelInterval) {
      var axisModel = this.model;
      var labelModel = axisModel.getModel('axisLabel');
      labelInterval = labelModel.get('interval');

      if (this.type === 'category' && (labelInterval == null || labelInterval === 'auto')) {
        labelInterval = axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisModel.getFormattedLabels(), labelModel.getFont(), this.getRotate ? this.getRotate() : this.isHorizontal && !this.isHorizontal() ? 90 : 0, labelModel.get('rotate'));
      }

      this._labelInterval = labelInterval;
    }

    return labelInterval;
  }
};
var _default = Axis;
module.exports = _default;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__(91);

var BoundingRect = __webpack_require__(101);

var _layout = __webpack_require__(103);

var getLayoutRect = _layout.getLayoutRect;

var axisHelper = __webpack_require__(112);

var Cartesian2D = __webpack_require__(242);

var Axis2D = __webpack_require__(244);

var CoordinateSystem = __webpack_require__(131);

__webpack_require__(245);

/**
 * Grid is a region which contains at most 4 cartesian systems
 *
 * TODO Default cartesian
 */
// Depends on GridModel, AxisModel, which performs preprocess.
var each = zrUtil.each;
var ifAxisCrossZero = axisHelper.ifAxisCrossZero;
var niceScaleExtent = axisHelper.niceScaleExtent;
/**
 * Check if the axis is used in the specified grid
 * @inner
 */

function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
  return axisModel.getCoordSysModel() === gridModel;
}

function rotateTextRect(textRect, rotate) {
  var rotateRadians = rotate * Math.PI / 180;
  var boundingBox = textRect.plain();
  var beforeWidth = boundingBox.width;
  var beforeHeight = boundingBox.height;
  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);
  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);
  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);
  return rotatedRect;
}

function getLabelUnionRect(axis) {
  var axisModel = axis.model;
  var labels = axisModel.getFormattedLabels();
  var axisLabelModel = axisModel.getModel('axisLabel');
  var rect;
  var step = 1;
  var labelCount = labels.length;

  if (labelCount > 40) {
    // Simple optimization for large amount of labels
    step = Math.ceil(labelCount / 40);
  }

  for (var i = 0; i < labelCount; i += step) {
    if (!axis.isLabelIgnored(i)) {
      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);
      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);
      rect ? rect.union(singleRect) : rect = singleRect;
    }
  }

  return rect;
}

function Grid(gridModel, ecModel, api) {
  /**
   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
   * @private
   */
  this._coordsMap = {};
  /**
   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
   * @private
   */

  this._coordsList = [];
  /**
   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}
   * @private
   */

  this._axesMap = {};
  /**
   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
   * @private
   */

  this._axesList = [];

  this._initCartesian(gridModel, ecModel, api);

  this.model = gridModel;
}

var gridProto = Grid.prototype;
gridProto.type = 'grid';
gridProto.axisPointerEnabled = true;

gridProto.getRect = function () {
  return this._rect;
};

gridProto.update = function (ecModel, api) {
  var axesMap = this._axesMap;

  this._updateScale(ecModel, this.model);

  each(axesMap.x, function (xAxis) {
    niceScaleExtent(xAxis.scale, xAxis.model);
  });
  each(axesMap.y, function (yAxis) {
    niceScaleExtent(yAxis.scale, yAxis.model);
  });
  each(axesMap.x, function (xAxis) {
    fixAxisOnZero(axesMap, 'y', xAxis);
  });
  each(axesMap.y, function (yAxis) {
    fixAxisOnZero(axesMap, 'x', yAxis);
  }); // Resize again if containLabel is enabled
  // FIXME It may cause getting wrong grid size in data processing stage

  this.resize(this.model, api);
};

function fixAxisOnZero(axesMap, otherAxisDim, axis) {
  // onZero can not be enabled in these two situations:
  // 1. When any other axis is a category axis.
  // 2. When no axis is cross 0 point.
  var axes = axesMap[otherAxisDim];

  if (!axis.onZero) {
    return;
  }

  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.

  if (onZeroAxisIndex != null) {
    var otherAxis = axes[onZeroAxisIndex];

    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {
      axis.onZero = false;
    }

    return;
  }

  for (var idx in axes) {
    if (axes.hasOwnProperty(idx)) {
      var otherAxis = axes[idx];

      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {
        onZeroAxisIndex = +idx;
        break;
      }
    }
  }

  if (onZeroAxisIndex == null) {
    axis.onZero = false;
  }

  axis.onZeroAxisIndex = onZeroAxisIndex;
}

function canNotOnZeroToAxis(axis) {
  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);
}
/**
 * Resize the grid
 * @param {module:echarts/coord/cartesian/GridModel} gridModel
 * @param {module:echarts/ExtensionAPI} api
 */


gridProto.resize = function (gridModel, api, ignoreContainLabel) {
  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
  this._rect = gridRect;
  var axesList = this._axesList;
  adjustAxes(); // Minus label size

  if (!ignoreContainLabel && gridModel.get('containLabel')) {
    each(axesList, function (axis) {
      if (!axis.model.get('axisLabel.inside')) {
        var labelUnionRect = getLabelUnionRect(axis);

        if (labelUnionRect) {
          var dim = axis.isHorizontal() ? 'height' : 'width';
          var margin = axis.model.get('axisLabel.margin');
          gridRect[dim] -= labelUnionRect[dim] + margin;

          if (axis.position === 'top') {
            gridRect.y += labelUnionRect.height + margin;
          } else if (axis.position === 'left') {
            gridRect.x += labelUnionRect.width + margin;
          }
        }
      }
    });
    adjustAxes();
  }

  function adjustAxes() {
    each(axesList, function (axis) {
      var isHorizontal = axis.isHorizontal();
      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
      var idx = axis.inverse ? 1 : 0;
      axis.setExtent(extent[idx], extent[1 - idx]);
      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);
    });
  }
};
/**
 * @param {string} axisType
 * @param {number} [axisIndex]
 */


gridProto.getAxis = function (axisType, axisIndex) {
  var axesMapOnDim = this._axesMap[axisType];

  if (axesMapOnDim != null) {
    if (axisIndex == null) {
      // Find first axis
      for (var name in axesMapOnDim) {
        if (axesMapOnDim.hasOwnProperty(name)) {
          return axesMapOnDim[name];
        }
      }
    }

    return axesMapOnDim[axisIndex];
  }
};
/**
 * @return {Array.<module:echarts/coord/Axis>}
 */


gridProto.getAxes = function () {
  return this._axesList.slice();
};
/**
 * Usage:
 *      grid.getCartesian(xAxisIndex, yAxisIndex);
 *      grid.getCartesian(xAxisIndex);
 *      grid.getCartesian(null, yAxisIndex);
 *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});
 *
 * @param {number|Object} [xAxisIndex]
 * @param {number} [yAxisIndex]
 */


gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {
  if (xAxisIndex != null && yAxisIndex != null) {
    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
    return this._coordsMap[key];
  }

  if (zrUtil.isObject(xAxisIndex)) {
    yAxisIndex = xAxisIndex.yAxisIndex;
    xAxisIndex = xAxisIndex.xAxisIndex;
  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.


  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
      return coordList[i];
    }
  }
};

gridProto.getCartesians = function () {
  return this._coordsList.slice();
};
/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */


gridProto.convertToPixel = function (ecModel, finder, value) {
  var target = this._findConvertTarget(ecModel, finder);

  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
};
/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */


gridProto.convertFromPixel = function (ecModel, finder, value) {
  var target = this._findConvertTarget(ecModel, finder);

  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
};
/**
 * @inner
 */


gridProto._findConvertTarget = function (ecModel, finder) {
  var seriesModel = finder.seriesModel;
  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];
  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];
  var gridModel = finder.gridModel;
  var coordsList = this._coordsList;
  var cartesian;
  var axis;

  if (seriesModel) {
    cartesian = seriesModel.coordinateSystem;
    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);
  } else if (xAxisModel && yAxisModel) {
    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
  } else if (xAxisModel) {
    axis = this.getAxis('x', xAxisModel.componentIndex);
  } else if (yAxisModel) {
    axis = this.getAxis('y', yAxisModel.componentIndex);
  } // Lowest priority.
  else if (gridModel) {
      var grid = gridModel.coordinateSystem;

      if (grid === this) {
        cartesian = this._coordsList[0];
      }
    }

  return {
    cartesian: cartesian,
    axis: axis
  };
};
/**
 * @implements
 * see {module:echarts/CoodinateSystem}
 */


gridProto.containPoint = function (point) {
  var coord = this._coordsList[0];

  if (coord) {
    return coord.containPoint(point);
  }
};
/**
 * Initialize cartesian coordinate systems
 * @private
 */


gridProto._initCartesian = function (gridModel, ecModel, api) {
  var axisPositionUsed = {
    left: false,
    right: false,
    top: false,
    bottom: false
  };
  var axesMap = {
    x: {},
    y: {}
  };
  var axesCount = {
    x: 0,
    y: 0
  }; /// Create axis

  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);

  if (!axesCount.x || !axesCount.y) {
    // Roll back when there no either x or y axis
    this._axesMap = {};
    this._axesList = [];
    return;
  }

  this._axesMap = axesMap; /// Create cartesian2d

  each(axesMap.x, function (xAxis, xAxisIndex) {
    each(axesMap.y, function (yAxis, yAxisIndex) {
      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
      var cartesian = new Cartesian2D(key);
      cartesian.grid = this;
      cartesian.model = gridModel;
      this._coordsMap[key] = cartesian;

      this._coordsList.push(cartesian);

      cartesian.addAxis(xAxis);
      cartesian.addAxis(yAxis);
    }, this);
  }, this);

  function createAxisCreator(axisType) {
    return function (axisModel, idx) {
      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
        return;
      }

      var axisPosition = axisModel.get('position');

      if (axisType === 'x') {
        // Fix position
        if (axisPosition !== 'top' && axisPosition !== 'bottom') {
          // Default bottom of X
          axisPosition = 'bottom';

          if (axisPositionUsed[axisPosition]) {
            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';
          }
        }
      } else {
        // Fix position
        if (axisPosition !== 'left' && axisPosition !== 'right') {
          // Default left of Y
          axisPosition = 'left';

          if (axisPositionUsed[axisPosition]) {
            axisPosition = axisPosition === 'left' ? 'right' : 'left';
          }
        }
      }

      axisPositionUsed[axisPosition] = true;
      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);
      var isCategory = axis.type === 'category';
      axis.onBand = isCategory && axisModel.get('boundaryGap');
      axis.inverse = axisModel.get('inverse');
      axis.onZero = axisModel.get('axisLine.onZero');
      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel

      axisModel.axis = axis; // Inject axisModel into axis

      axis.model = axisModel; // Inject grid info axis

      axis.grid = this; // Index of axis, can be used as key

      axis.index = idx;

      this._axesList.push(axis);

      axesMap[axisType][idx] = axis;
      axesCount[axisType]++;
    };
  }
};
/**
 * Update cartesian properties from series
 * @param  {module:echarts/model/Option} option
 * @private
 */


gridProto._updateScale = function (ecModel, gridModel) {
  // Reset scale
  zrUtil.each(this._axesList, function (axis) {
    axis.scale.setExtent(Infinity, -Infinity);
  });
  ecModel.eachSeries(function (seriesModel) {
    if (isCartesian2D(seriesModel)) {
      var axesModels = findAxesModels(seriesModel, ecModel);
      var xAxisModel = axesModels[0];
      var yAxisModel = axesModels[1];

      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {
        return;
      }

      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      var data = seriesModel.getData();
      var xAxis = cartesian.getAxis('x');
      var yAxis = cartesian.getAxis('y');

      if (data.type === 'list') {
        unionExtent(data, xAxis, seriesModel);
        unionExtent(data, yAxis, seriesModel);
      }
    }
  }, this);

  function unionExtent(data, axis, seriesModel) {
    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {
      axis.scale.unionExtentFromData(data, dim);
    });
  }
};
/**
 * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined
 * @return {Object} {baseAxes: [], otherAxes: []}
 */


gridProto.getTooltipAxes = function (dim) {
  var baseAxes = [];
  var otherAxes = [];
  each(this.getCartesians(), function (cartesian) {
    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
    var otherAxis = cartesian.getOtherAxis(baseAxis);
    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
  });
  return {
    baseAxes: baseAxes,
    otherAxes: otherAxes
  };
};
/**
 * @inner
 */


function updateAxisTransfrom(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform

  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
    return coord + coordBase;
  } : function (coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
    return coord - coordBase;
  } : function (coord) {
    return axisExtentSum - coord + coordBase;
  };
}

var axesTypes = ['xAxis', 'yAxis'];
/**
 * @inner
 */

function findAxesModels(seriesModel, ecModel) {
  return zrUtil.map(axesTypes, function (axisType) {
    var axisModel = seriesModel.getReferringComponents(axisType)[0];
    return axisModel;
  });
}
/**
 * @inner
 */


function isCartesian2D(seriesModel) {
  return seriesModel.get('coordinateSystem') === 'cartesian2d';
}

Grid.create = function (ecModel, api) {
  var grids = [];
  ecModel.eachComponent('grid', function (gridModel, idx) {
    var grid = new Grid(gridModel, ecModel, api);
    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize
    // should be performed in create stage.

    grid.resize(gridModel, api, true);
    gridModel.coordinateSystem = grid;
    grids.push(grid);
  }); // Inject the coordinateSystems into seriesModel

  ecModel.eachSeries(function (seriesModel) {
    if (!isCartesian2D(seriesModel)) {
      return;
    }

    var axesModels = findAxesModels(seriesModel, ecModel);
    var xAxisModel = axesModels[0];
    var yAxisModel = axesModels[1];
    var gridModel = xAxisModel.getCoordSysModel();
    var grid = gridModel.coordinateSystem;
    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
  });
  return grids;
}; // For deciding which dimensions to use when creating list data


Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;
CoordinateSystem.register('cartesian2d', Grid);
var _default = Grid;
module.exports = _default;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var ComponentModel = __webpack_require__(105);

var axisModelCreator = __webpack_require__(246);

var axisModelCommonMixin = __webpack_require__(161);

var AxisModel = ComponentModel.extend({
  type: 'cartesian2dAxis',

  /**
   * @type {module:echarts/coord/cartesian/Axis2D}
   */
  axis: null,

  /**
   * @override
   */
  init: function () {
    AxisModel.superApply(this, 'init', arguments);
    this.resetRange();
  },

  /**
   * @override
   */
  mergeOption: function () {
    AxisModel.superApply(this, 'mergeOption', arguments);
    this.resetRange();
  },

  /**
   * @override
   */
  restoreData: function () {
    AxisModel.superApply(this, 'restoreData', arguments);
    this.resetRange();
  },

  /**
   * @override
   * @return {module:echarts/model/Component}
   */
  getCoordSysModel: function () {
    return this.ecModel.queryComponents({
      mainType: 'grid',
      index: this.option.gridIndex,
      id: this.option.gridId
    })[0];
  }
});

function getAxisType(axisDim, option) {
  // Default axis with data is category axis
  return option.type || (option.data ? 'category' : 'value');
}

zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
var extraOption = {
  // gridIndex: 0,
  // gridId: '',
  // Offset is for multiple axis on the same position
  offset: 0
};
axisModelCreator('x', AxisModel, getAxisType, extraOption);
axisModelCreator('y', AxisModel, getAxisType, extraOption);
var _default = AxisModel;
module.exports = _default;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var graphic = __webpack_require__(93);

__webpack_require__(163);

__webpack_require__(253);

// Grid view
echarts.extendComponentView({
  type: 'grid',
  render: function (gridModel, ecModel) {
    this.group.removeAll();

    if (gridModel.get('show')) {
      this.group.add(new graphic.Rect({
        shape: gridModel.coordinateSystem.getRect(),
        style: zrUtil.defaults({
          fill: gridModel.get('backgroundColor')
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  }
});
echarts.registerPreprocessor(function (option) {
  // Only create grid when need
  if (option.xAxis && option.yAxis && !option.grid) {
    option.grid = {};
  }
});

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(91);

var retrieve = _util.retrieve;
var defaults = _util.defaults;
var extend = _util.extend;
var each = _util.each;

var formatUtil = __webpack_require__(99);

var graphic = __webpack_require__(93);

var Model = __webpack_require__(102);

var _number = __webpack_require__(94);

var isRadianAroundZero = _number.isRadianAroundZero;
var remRadian = _number.remRadian;

var _symbol = __webpack_require__(115);

var createSymbol = _symbol.createSymbol;

var matrixUtil = __webpack_require__(110);

var _vector = __webpack_require__(97);

var v2ApplyTransform = _vector.applyTransform;
var PI = Math.PI;

function makeAxisEventDataBase(axisModel) {
  var eventData = {
    componentType: axisModel.mainType
  };
  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
  return eventData;
}
/**
 * A final axis is translated and rotated from a "standard axis".
 * So opt.position and opt.rotation is required.
 *
 * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
 * for example: (0, 0) ------------> (0, 50)
 *
 * nameDirection or tickDirection or labelDirection is 1 means tick
 * or label is below the standard axis, whereas is -1 means above
 * the standard axis. labelOffset means offset between label and axis,
 * which is useful when 'onZero', where axisLabel is in the grid and
 * label in outside grid.
 *
 * Tips: like always,
 * positive rotation represents anticlockwise, and negative rotation
 * represents clockwise.
 * The direction of position coordinate is the same as the direction
 * of screen coordinate.
 *
 * Do not need to consider axis 'inverse', which is auto processed by
 * axis extent.
 *
 * @param {module:zrender/container/Group} group
 * @param {Object} axisModel
 * @param {Object} opt Standard axis parameters.
 * @param {Array.<number>} opt.position [x, y]
 * @param {number} opt.rotation by radian
 * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.
 * @param {number} [opt.tickDirection=1] 1 or -1
 * @param {number} [opt.labelDirection=1] 1 or -1
 * @param {number} [opt.labelOffset=0] Usefull when onZero.
 * @param {string} [opt.axisLabelShow] default get from axisModel.
 * @param {string} [opt.axisName] default get from axisModel.
 * @param {number} [opt.axisNameAvailableWidth]
 * @param {number} [opt.labelRotate] by degree, default get from axisModel.
 * @param {number} [opt.labelInterval] Default label interval when label
 *                                     interval from model is null or 'auto'.
 * @param {number} [opt.strokeContainThreshold] Default label interval when label
 * @param {number} [opt.nameTruncateMaxWidth]
 */


var AxisBuilder = function (axisModel, opt) {
  /**
   * @readOnly
   */
  this.opt = opt;
  /**
   * @readOnly
   */

  this.axisModel = axisModel; // Default value

  defaults(opt, {
    labelOffset: 0,
    nameDirection: 1,
    tickDirection: 1,
    labelDirection: 1,
    silent: true
  });
  /**
   * @readOnly
   */

  this.group = new graphic.Group(); // FIXME Not use a seperate text group?

  var dumbGroup = new graphic.Group({
    position: opt.position.slice(),
    rotation: opt.rotation
  }); // this.group.add(dumbGroup);
  // this._dumbGroup = dumbGroup;

  dumbGroup.updateTransform();
  this._transform = dumbGroup.transform;
  this._dumbGroup = dumbGroup;
};

AxisBuilder.prototype = {
  constructor: AxisBuilder,
  hasBuilder: function (name) {
    return !!builders[name];
  },
  add: function (name) {
    builders[name].call(this);
  },
  getGroup: function () {
    return this.group;
  }
};
var builders = {
  /**
   * @private
   */
  axisLine: function () {
    var opt = this.opt;
    var axisModel = this.axisModel;

    if (!axisModel.get('axisLine.show')) {
      return;
    }

    var extent = this.axisModel.axis.getExtent();
    var matrix = this._transform;
    var pt1 = [extent[0], 0];
    var pt2 = [extent[1], 0];

    if (matrix) {
      v2ApplyTransform(pt1, pt1, matrix);
      v2ApplyTransform(pt2, pt2, matrix);
    }

    var lineStyle = extend({
      lineCap: 'round'
    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());
    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({
      // Id for animation
      anid: 'line',
      shape: {
        x1: pt1[0],
        y1: pt1[1],
        x2: pt2[0],
        y2: pt2[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    })));
    var arrows = axisModel.get('axisLine.symbol');
    var arrowSize = axisModel.get('axisLine.symbolSize');

    if (arrows != null) {
      if (typeof arrows === 'string') {
        // Use the same arrow for start and end point
        arrows = [arrows, arrows];
      }

      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {
        // Use the same size for width and height
        arrowSize = [arrowSize, arrowSize];
      }

      var symbolWidth = arrowSize[0];
      var symbolHeight = arrowSize[1];
      each([[opt.rotation + Math.PI / 2, pt1], [opt.rotation - Math.PI / 2, pt2]], function (item, index) {
        if (arrows[index] !== 'none' && arrows[index] != null) {
          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);
          symbol.attr({
            rotation: item[0],
            position: item[1],
            silent: true
          });
          this.group.add(symbol);
        }
      }, this);
    }
  },

  /**
   * @private
   */
  axisTickLabel: function () {
    var axisModel = this.axisModel;
    var opt = this.opt;
    var tickEls = buildAxisTick(this, axisModel, opt);
    var labelEls = buildAxisLabel(this, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, tickEls);
  },

  /**
   * @private
   */
  axisName: function () {
    var opt = this.opt;
    var axisModel = this.axisModel;
    var name = retrieve(opt.axisName, axisModel.get('name'));

    if (!name) {
      return;
    }

    var nameLocation = axisModel.get('nameLocation');
    var nameDirection = opt.nameDirection;
    var textStyleModel = axisModel.getModel('nameTextStyle');
    var gap = axisModel.get('nameGap') || 0;
    var extent = this.axisModel.axis.getExtent();
    var gapSignal = extent[0] > extent[1] ? -1 : 1;
    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'
    // Reuse labelOffset.
    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];
    var labelLayout;
    var nameRotation = axisModel.get('nameRotate');

    if (nameRotation != null) {
      nameRotation = nameRotation * PI / 180; // To radian.
    }

    var axisNameAvailableWidth;

    if (isNameLocationCenter(nameLocation)) {
      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
      nameDirection);
    } else {
      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;

      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }

    var textFont = textStyleModel.getFont();
    var truncateOpt = axisModel.get('nameTruncate', true) || {};
    var ellipsis = truncateOpt.ellipsis;
    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME
    // truncate rich text? (consider performance)

    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {
      minChar: 2,
      placeholder: truncateOpt.placeholder
    }) : name;
    var tooltipOpt = axisModel.get('tooltip', true);
    var mainType = axisModel.mainType;
    var formatterParams = {
      componentType: mainType,
      name: name,
      $vars: ['name']
    };
    formatterParams[mainType + 'Index'] = axisModel.componentIndex;
    var textEl = new graphic.Text({
      // Id for animation
      anid: 'name',
      __fullText: name,
      __truncatedText: truncatedText,
      position: pos,
      rotation: labelLayout.rotation,
      silent: isSilent(axisModel),
      z2: 1,
      tooltip: tooltipOpt && tooltipOpt.show ? extend({
        content: name,
        formatter: function () {
          return name;
        },
        formatterParams: formatterParams
      }, tooltipOpt) : null
    });
    graphic.setTextStyle(textEl.style, textStyleModel, {
      text: truncatedText,
      textFont: textFont,
      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),
      textAlign: labelLayout.textAlign,
      textVerticalAlign: labelLayout.textVerticalAlign
    });

    if (axisModel.get('triggerEvent')) {
      textEl.eventData = makeAxisEventDataBase(axisModel);
      textEl.eventData.targetType = 'axisName';
      textEl.eventData.name = name;
    } // FIXME


    this._dumbGroup.add(textEl);

    textEl.updateTransform();
    this.group.add(textEl);
    textEl.decomposeTransform();
  }
};
/**
 * @public
 * @static
 * @param {Object} opt
 * @param {number} axisRotation in radian
 * @param {number} textRotation in radian
 * @param {number} direction
 * @return {Object} {
 *  rotation, // according to axis
 *  textAlign,
 *  textVerticalAlign
 * }
 */

var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
  var rotationDiff = remRadian(textRotation - axisRotation);
  var textAlign;
  var textVerticalAlign;

  if (isRadianAroundZero(rotationDiff)) {
    // Label is parallel with axis line.
    textVerticalAlign = direction > 0 ? 'top' : 'bottom';
    textAlign = 'center';
  } else if (isRadianAroundZero(rotationDiff - PI)) {
    // Label is inverse parallel with axis line.
    textVerticalAlign = direction > 0 ? 'bottom' : 'top';
    textAlign = 'center';
  } else {
    textVerticalAlign = 'middle';

    if (rotationDiff > 0 && rotationDiff < PI) {
      textAlign = direction > 0 ? 'right' : 'left';
    } else {
      textAlign = direction > 0 ? 'left' : 'right';
    }
  }

  return {
    rotation: rotationDiff,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
};

function endTextLayout(opt, textPosition, textRotate, extent) {
  var rotationDiff = remRadian(textRotate - opt.rotation);
  var textAlign;
  var textVerticalAlign;
  var inverse = extent[0] > extent[1];
  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;

  if (isRadianAroundZero(rotationDiff - PI / 2)) {
    textVerticalAlign = onLeft ? 'bottom' : 'top';
    textAlign = 'center';
  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
    textVerticalAlign = onLeft ? 'top' : 'bottom';
    textAlign = 'center';
  } else {
    textVerticalAlign = 'middle';

    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
      textAlign = onLeft ? 'left' : 'right';
    } else {
      textAlign = onLeft ? 'right' : 'left';
    }
  }

  return {
    rotation: rotationDiff,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}

function isSilent(axisModel) {
  var tooltipOpt = axisModel.get('tooltip');
  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.
  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);
}

function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  // If min or max are user set, we need to check
  // If the tick on min(max) are overlap on their neighbour tick
  // If they are overlapped, we need to hide the min(max) tick label
  var showMinLabel = axisModel.get('axisLabel.showMinLabel');
  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME
  // Have not consider onBand yet, where tick els is more than label els.

  labelEls = labelEls || [];
  tickEls = tickEls || [];
  var firstLabel = labelEls[0];
  var nextLabel = labelEls[1];
  var lastLabel = labelEls[labelEls.length - 1];
  var prevLabel = labelEls[labelEls.length - 2];
  var firstTick = tickEls[0];
  var nextTick = tickEls[1];
  var lastTick = tickEls[tickEls.length - 1];
  var prevTick = tickEls[tickEls.length - 2];

  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }

  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}

function ignoreEl(el) {
  el && (el.ignore = true);
}

function isTwoLabelOverlapped(current, next, labelLayout) {
  // current and next has the same rotation.
  var firstRect = current && current.getBoundingRect().clone();
  var nextRect = next && next.getBoundingRect().clone();

  if (!firstRect || !nextRect) {
    return;
  } // When checking intersect of two rotated labels, we use mRotationBack
  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.


  var mRotationBack = matrixUtil.identity([]);
  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));
  return firstRect.intersect(nextRect);
}

function isNameLocationCenter(nameLocation) {
  return nameLocation === 'middle' || nameLocation === 'center';
}
/**
 * @static
 */


var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval, ticksCnt, showMinLabel, showMaxLabel) {
  if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {
    return false;
  } // FIXME
  // Have not consider label overlap (if label is too long) yet.


  var rawTick;
  var scale = axis.scale;
  return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));
};
/**
 * @static
 */


var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {
  var interval = model.get('interval');

  if (interval == null || interval == 'auto') {
    interval = labelInterval;
  }

  return interval;
};

function buildAxisTick(axisBuilder, axisModel, opt) {
  var axis = axisModel.axis;

  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {
    return;
  }

  var tickModel = axisModel.getModel('axisTick');
  var lineStyleModel = tickModel.getModel('lineStyle');
  var tickLen = tickModel.get('length');
  var tickInterval = getInterval(tickModel, opt.labelInterval);
  var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel')); // FIXME
  // Corresponds to ticksCoords ?

  var ticks = axis.scale.getTicks();
  var showMinLabel = axisModel.get('axisLabel.showMinLabel');
  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');
  var pt1 = [];
  var pt2 = [];
  var matrix = axisBuilder._transform;
  var tickEls = [];
  var ticksCnt = ticksCoords.length;

  for (var i = 0; i < ticksCnt; i++) {
    // Only ordinal scale support tick interval
    if (ifIgnoreOnTick(axis, i, tickInterval, ticksCnt, showMinLabel, showMaxLabel)) {
      continue;
    }

    var tickCoord = ticksCoords[i];
    pt1[0] = tickCoord;
    pt1[1] = 0;
    pt2[0] = tickCoord;
    pt2[1] = opt.tickDirection * tickLen;

    if (matrix) {
      v2ApplyTransform(pt1, pt1, matrix);
      v2ApplyTransform(pt2, pt2, matrix);
    } // Tick line, Not use group transform to have better line draw


    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({
      // Id for animation
      anid: 'tick_' + ticks[i],
      shape: {
        x1: pt1[0],
        y1: pt1[1],
        x2: pt2[0],
        y2: pt2[1]
      },
      style: defaults(lineStyleModel.getLineStyle(), {
        stroke: axisModel.get('axisLine.lineStyle.color')
      }),
      z2: 2,
      silent: true
    }));
    axisBuilder.group.add(tickEl);
    tickEls.push(tickEl);
  }

  return tickEls;
}

function buildAxisLabel(axisBuilder, axisModel, opt) {
  var axis = axisModel.axis;
  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));

  if (!show || axis.scale.isBlank()) {
    return;
  }

  var labelModel = axisModel.getModel('axisLabel');
  var labelMargin = labelModel.get('margin');
  var ticks = axis.scale.getTicks();
  var labels = axisModel.getFormattedLabels(); // Special label rotate.

  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;
  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  var categoryData = axisModel.get('data');
  var labelEls = [];
  var silent = isSilent(axisModel);
  var triggerEvent = axisModel.get('triggerEvent');
  var showMinLabel = axisModel.get('axisLabel.showMinLabel');
  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');
  each(ticks, function (tickVal, index) {
    if (ifIgnoreOnTick(axis, index, opt.labelInterval, ticks.length, showMinLabel, showMaxLabel)) {
      return;
    }

    var itemLabelModel = labelModel;

    if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {
      itemLabelModel = new Model(categoryData[tickVal].textStyle, labelModel, axisModel.ecModel);
    }

    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');
    var tickCoord = axis.dataToCoord(tickVal);
    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
    var labelStr = axis.scale.getLabel(tickVal);
    var textEl = new graphic.Text({
      // Id for animation
      anid: 'label_' + tickVal,
      position: pos,
      rotation: labelLayout.rotation,
      silent: silent,
      z2: 10
    });
    graphic.setTextStyle(textEl.style, itemLabelModel, {
      text: labels[index],
      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original
      // index of axis.data. So tick should not be exposed to user
      // in category axis.
      // (2) Compatible with previous version, which always returns labelStr.
      // But in interval scale labelStr is like '223,445', which maked
      // user repalce ','. So we modify it to return original val but remain
      // it as 'string' to avoid error in replacing.
      axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal, index) : textColor
    }); // Pack data for mouse event

    if (triggerEvent) {
      textEl.eventData = makeAxisEventDataBase(axisModel);
      textEl.eventData.targetType = 'axisLabel';
      textEl.eventData.value = labelStr;
    } // FIXME


    axisBuilder._dumbGroup.add(textEl);

    textEl.updateTransform();
    labelEls.push(textEl);
    axisBuilder.group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}

var _default = AxisBuilder;
module.exports = _default;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__(92);

var axisPointerModelHelper = __webpack_require__(125);

/**
 * Base class of AxisView.
 */
var AxisView = echarts.extendComponentView({
  type: 'axis',

  /**
   * @private
   */
  _axisPointer: null,

  /**
   * @protected
   * @type {string}
   */
  axisPointerClass: null,

  /**
   * @override
   */
  render: function (axisModel, ecModel, api, payload) {
    // FIXME
    // This process should proformed after coordinate systems updated
    // (axis scale updated), and should be performed each time update.
    // So put it here temporarily, although it is not appropriate to
    // put a model-writing procedure in `view`.
    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);
    AxisView.superApply(this, 'render', arguments);
    updateAxisPointer(this, axisModel, ecModel, api, payload, true);
  },

  /**
   * Action handler.
   * @public
   * @param {module:echarts/coord/cartesian/AxisModel} axisModel
   * @param {module:echarts/model/Global} ecModel
   * @param {module:echarts/ExtensionAPI} api
   * @param {Object} payload
   */
  updateAxisPointer: function (axisModel, ecModel, api, payload, force) {
    updateAxisPointer(this, axisModel, ecModel, api, payload, false);
  },

  /**
   * @override
   */
  remove: function (ecModel, api) {
    var axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api);
    AxisView.superApply(this, 'remove', arguments);
  },

  /**
   * @override
   */
  dispose: function (ecModel, api) {
    disposeAxisPointer(this, api);
    AxisView.superApply(this, 'dispose', arguments);
  }
});

function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
  var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);

  if (!Clazz) {
    return;
  }

  var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);
  axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
}

function disposeAxisPointer(axisView, ecModel, api) {
  var axisPointer = axisView._axisPointer;
  axisPointer && axisPointer.dispose(ecModel, api);
  axisView._axisPointer = null;
}

var axisPointerClazz = [];

AxisView.registerAxisPointerClass = function (type, clazz) {
  axisPointerClazz[type] = clazz;
};

AxisView.getAxisPointerClass = function (type) {
  return type && axisPointerClazz[type];
};

var _default = AxisView;
module.exports = _default;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

/**
 * @param {Object} opt {labelInside}
 * @return {Object} {
 *  position, rotation, labelDirection, labelOffset,
 *  tickDirection, labelRotate, labelInterval, z2
 * }
 */
function layout(gridModel, axisModel, opt) {
  opt = opt || {};
  var grid = gridModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout = {};
  var rawAxisPosition = axis.position;
  var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;
  var axisDim = axis.dim;
  var rect = grid.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var idx = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  };
  var axisOffset = axisModel.get('offset') || 0;
  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];

  if (axis.onZero) {
    var otherAxis = grid.getAxis(axisDim === 'x' ? 'y' : 'x', axis.onZeroAxisIndex);
    var onZeroCoord = otherAxis.toGlobalCoord(otherAxis.dataToCoord(0));
    posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  } // Axis position


  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation

  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim

  var dirMap = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
  layout.labelOffset = axis.onZero ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;

  if (axisModel.get('axisTick.inside')) {
    layout.tickDirection = -layout.tickDirection;
  }

  if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {
    layout.labelDirection = -layout.labelDirection;
  } // Special label rotation


  var labelRotate = axisModel.get('axisLabel.rotate');
  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // label interval when auto mode.

  layout.labelInterval = axis.getLabelInterval(); // Over splitLine and splitArea

  layout.z2 = 1;
  return layout;
}

exports.layout = layout;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__(93);

var SymbolClz = __webpack_require__(170);

/**
 * @module echarts/chart/helper/SymbolDraw
 */

/**
 * @constructor
 * @alias module:echarts/chart/helper/SymbolDraw
 * @param {module:zrender/graphic/Group} [symbolCtor]
 */
function SymbolDraw(symbolCtor) {
  this.group = new graphic.Group();
  this._symbolCtor = symbolCtor || SymbolClz;
}

var symbolDrawProto = SymbolDraw.prototype;

function symbolNeedsDraw(data, idx, isIgnore) {
  var point = data.getItemLayout(idx); // Is an object
  // if (point && point.hasOwnProperty('point')) {
  //     point = point.point;
  // }

  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx)) && data.getItemVisual(idx, 'symbol') !== 'none';
}
/**
 * Update symbols draw by new data
 * @param {module:echarts/data/List} data
 * @param {Array.<boolean>} [isIgnore]
 */


symbolDrawProto.updateData = function (data, isIgnore) {
  var group = this.group;
  var seriesModel = data.hostModel;
  var oldData = this._data;
  var SymbolCtor = this._symbolCtor;
  var seriesScope = {
    itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),
    hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),
    symbolRotate: seriesModel.get('symbolRotate'),
    symbolOffset: seriesModel.get('symbolOffset'),
    hoverAnimation: seriesModel.get('hoverAnimation'),
    labelModel: seriesModel.getModel('label.normal'),
    hoverLabelModel: seriesModel.getModel('label.emphasis'),
    cursorStyle: seriesModel.get('cursor')
  };
  data.diff(oldData).add(function (newIdx) {
    var point = data.getItemLayout(newIdx);

    if (symbolNeedsDraw(data, newIdx, isIgnore)) {
      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
      symbolEl.attr('position', point);
      data.setItemGraphicEl(newIdx, symbolEl);
      group.add(symbolEl);
    }
  }).update(function (newIdx, oldIdx) {
    var symbolEl = oldData.getItemGraphicEl(oldIdx);
    var point = data.getItemLayout(newIdx);

    if (!symbolNeedsDraw(data, newIdx, isIgnore)) {
      group.remove(symbolEl);
      return;
    }

    if (!symbolEl) {
      symbolEl = new SymbolCtor(data, newIdx);
      symbolEl.attr('position', point);
    } else {
      symbolEl.updateData(data, newIdx, seriesScope);
      graphic.updateProps(symbolEl, {
        position: point
      }, seriesModel);
    } // Add back


    group.add(symbolEl);
    data.setItemGraphicEl(newIdx, symbolEl);
  }).remove(function (oldIdx) {
    var el = oldData.getItemGraphicEl(oldIdx);
    el && el.fadeOut(function () {
      group.remove(el);
    });
  }).execute();
  this._data = data;
};

symbolDrawProto.updateLayout = function () {
  var data = this._data;

  if (data) {
    // Not use animation
    data.eachItemGraphicEl(function (el, idx) {
      var point = data.getItemLayout(idx);
      el.attr('position', point);
    });
  }
};

symbolDrawProto.remove = function (enableAnimation) {
  var group = this.group;
  var data = this._data;

  if (data) {
    if (enableAnimation) {
      data.eachItemGraphicEl(function (el) {
        el.fadeOut(function () {
          group.remove(el);
        });
      });
    } else {
      group.removeAll();
    }
  }
};

var _default = SymbolDraw;
module.exports = _default;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var _symbol = __webpack_require__(115);

var createSymbol = _symbol.createSymbol;

var graphic = __webpack_require__(93);

var _number = __webpack_require__(94);

var parsePercent = _number.parsePercent;

var _labelHelper = __webpack_require__(258);

var findLabelValueDim = _labelHelper.findLabelValueDim;

/**
 * @module echarts/chart/helper/Symbol
 */
function getSymbolSize(data, idx) {
  var symbolSize = data.getItemVisual(idx, 'symbolSize');
  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
}

function getScale(symbolSize) {
  return [symbolSize[0] / 2, symbolSize[1] / 2];
}
/**
 * @constructor
 * @alias {module:echarts/chart/helper/Symbol}
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @extends {module:zrender/graphic/Group}
 */


function SymbolClz(data, idx, seriesScope) {
  graphic.Group.call(this);
  this.updateData(data, idx, seriesScope);
}

var symbolProto = SymbolClz.prototype;

function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}

symbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {
  // Remove paths created before
  this.removeAll();
  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(
  //     symbolType, -0.5, -0.5, 1, 1, color
  // );
  // If width/height are set too small (e.g., set to 1) on ios10
  // and macOS Sierra, a circle stroke become a rect, no matter what
  // the scale is set. So we set width/height as 2. See #4150.

  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);
  symbolPath.attr({
    z2: 100,
    culling: true,
    scale: getScale(symbolSize)
  }); // Rewrite drift method

  symbolPath.drift = driftSymbol;
  this._symbolType = symbolType;
  this.add(symbolPath);
};
/**
 * Stop animation
 * @param {boolean} toLastFrame
 */


symbolProto.stopSymbolAnimation = function (toLastFrame) {
  this.childAt(0).stopAnimation(toLastFrame);
};
/**
 * FIXME:
 * Caution: This method breaks the encapsulation of this module,
 * but it indeed brings convenience. So do not use the method
 * unless you detailedly know all the implements of `Symbol`,
 * especially animation.
 *
 * Get symbol path element.
 */


symbolProto.getSymbolPath = function () {
  return this.childAt(0);
};
/**
 * Get scale(aka, current symbol size).
 * Including the change caused by animation
 */


symbolProto.getScale = function () {
  return this.childAt(0).scale;
};
/**
 * Highlight symbol
 */


symbolProto.highlight = function () {
  this.childAt(0).trigger('emphasis');
};
/**
 * Downplay symbol
 */


symbolProto.downplay = function () {
  this.childAt(0).trigger('normal');
};
/**
 * @param {number} zlevel
 * @param {number} z
 */


symbolProto.setZ = function (zlevel, z) {
  var symbolPath = this.childAt(0);
  symbolPath.zlevel = zlevel;
  symbolPath.z = z;
};

symbolProto.setDraggable = function (draggable) {
  var symbolPath = this.childAt(0);
  symbolPath.draggable = draggable;
  symbolPath.cursor = draggable ? 'move' : 'pointer';
};
/**
 * Update symbol properties
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Object} [seriesScope]
 * @param {Object} [seriesScope.itemStyle]
 * @param {Object} [seriesScope.hoverItemStyle]
 * @param {Object} [seriesScope.symbolRotate]
 * @param {Object} [seriesScope.symbolOffset]
 * @param {module:echarts/model/Model} [seriesScope.labelModel]
 * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]
 * @param {boolean} [seriesScope.hoverAnimation]
 * @param {Object} [seriesScope.cursorStyle]
 * @param {module:echarts/model/Model} [seriesScope.itemModel]
 * @param {string} [seriesScope.symbolInnerColor]
 * @param {Object} [seriesScope.fadeIn=false]
 */


symbolProto.updateData = function (data, idx, seriesScope) {
  this.silent = false;
  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
  var seriesModel = data.hostModel;
  var symbolSize = getSymbolSize(data, idx);
  var isInit = symbolType !== this._symbolType;

  if (isInit) {
    this._createSymbol(symbolType, data, idx, symbolSize);
  } else {
    var symbolPath = this.childAt(0);
    symbolPath.silent = false;
    graphic.updateProps(symbolPath, {
      scale: getScale(symbolSize)
    }, seriesModel, idx);
  }

  this._updateCommon(data, idx, symbolSize, seriesScope);

  if (isInit) {
    var symbolPath = this.childAt(0);
    var fadeIn = seriesScope && seriesScope.fadeIn;
    var target = {
      scale: symbolPath.scale.slice()
    };
    fadeIn && (target.style = {
      opacity: symbolPath.style.opacity
    });
    symbolPath.scale = [0, 0];
    fadeIn && (symbolPath.style.opacity = 0);
    graphic.initProps(symbolPath, target, seriesModel, idx);
  }

  this._seriesModel = seriesModel;
}; // Update common properties


var normalStyleAccessPath = ['itemStyle', 'normal'];
var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];
var normalLabelAccessPath = ['label', 'normal'];
var emphasisLabelAccessPath = ['label', 'emphasis'];
/**
 * @param {module:echarts/data/List} data
 * @param {number} idx
 * @param {Array.<number>} symbolSize
 * @param {Object} [seriesScope]
 */

symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {
  var symbolPath = this.childAt(0);
  var seriesModel = data.hostModel;
  var color = data.getItemVisual(idx, 'color'); // Reset style

  if (symbolPath.type !== 'image') {
    symbolPath.useStyle({
      strokeNoScale: true
    });
  }

  var itemStyle = seriesScope && seriesScope.itemStyle;
  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
  var symbolRotate = seriesScope && seriesScope.symbolRotate;
  var symbolOffset = seriesScope && seriesScope.symbolOffset;
  var labelModel = seriesScope && seriesScope.labelModel;
  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
  var cursorStyle = seriesScope && seriesScope.cursorStyle;

  if (!seriesScope || data.hasItemOption) {
    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.
    // Because symbol provide setColor individually to set fill and stroke

    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);
    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
    symbolRotate = itemModel.getShallow('symbolRotate');
    symbolOffset = itemModel.getShallow('symbolOffset');
    labelModel = itemModel.getModel(normalLabelAccessPath);
    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
    hoverAnimation = itemModel.getShallow('hoverAnimation');
    cursorStyle = itemModel.getShallow('cursor');
  } else {
    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);
  }

  var elStyle = symbolPath.style;
  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);

  if (symbolOffset) {
    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);
  }

  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!

  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);
  symbolPath.setStyle(itemStyle);
  var opacity = data.getItemVisual(idx, 'opacity');

  if (opacity != null) {
    elStyle.opacity = opacity;
  }

  var useNameLabel = seriesScope && seriesScope.useNameLabel;
  var valueDim = !useNameLabel && findLabelValueDim(data);

  if (useNameLabel || valueDim != null) {
    graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: useNameLabel ? data.getName(idx) : data.get(valueDim, idx),
      isRectText: true,
      autoColor: color
    });
  }

  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');
  symbolPath.hoverStyle = hoverItemStyle; // FIXME
  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.

  graphic.setHoverStyle(symbolPath);
  var scale = getScale(symbolSize);

  if (hoverAnimation && seriesModel.isAnimationEnabled()) {
    var onEmphasis = function () {
      var ratio = scale[1] / scale[0];
      this.animateTo({
        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]
      }, 400, 'elasticOut');
    };

    var onNormal = function () {
      this.animateTo({
        scale: scale
      }, 400, 'elasticOut');
    };

    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
  }
};
/**
 * @param {Function} cb
 * @param {Object} [opt]
 * @param {Object} [opt.keepLabel=true]
 */


symbolProto.fadeOut = function (cb, opt) {
  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out

  this.silent = symbolPath.silent = true; // Not show text when animating

  !(opt && opt.keepLabel) && (symbolPath.style.text = null);
  graphic.updateProps(symbolPath, {
    style: {
      opacity: 0
    },
    scale: [0, 0]
  }, this._seriesModel, this.dataIndex, cb);
};

zrUtil.inherits(SymbolClz, graphic.Group);
var _default = SymbolClz;
module.exports = _default;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var modelUtil = __webpack_require__(95);

/**
 * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}
 * @param {module:echarts/model/Global} ecModel
 * @return {Object} {point: [x, y], el: ...} point Will not be null.
 */
function _default(finder, ecModel) {
  var point = [];
  var seriesIndex = finder.seriesIndex;
  var seriesModel;

  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }

  var data = seriesModel.getData();
  var dataIndex = modelUtil.queryDataIndex(data, finder);

  if (dataIndex == null || zrUtil.isArray(dataIndex)) {
    return {
      point: []
    };
  }

  var el = data.getItemGraphicEl(dataIndex);
  var coordSys = seriesModel.coordinateSystem;

  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {
      return seriesModel.coordDimToDataDim(dim)[0];
    }), dataIndex, true)) || [];
  } else if (el) {
    // Use graphic bounding rect
    var rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }

  return {
    point: point,
    el: el
  };
}

module.exports = _default;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var env = __webpack_require__(98);

var modelUtil = __webpack_require__(95);

var get = modelUtil.makeGetter();
var each = zrUtil.each;
/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 * @param {Function} handler
 *      param: {string} currTrigger
 *      param: {Array.<number>} point
 */

function register(key, api, handler) {
  if (env.node) {
    return;
  }

  var zr = api.getZr();
  get(zr).records || (get(zr).records = {});
  initGlobalListeners(zr, api);
  var record = get(zr).records[key] || (get(zr).records[key] = {});
  record.handler = handler;
}

function initGlobalListeners(zr, api) {
  if (get(zr).initialized) {
    return;
  }

  get(zr).initialized = true;
  useHandler('click', zrUtil.curry(doEnter, 'click'));
  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);

  useHandler('globalout', onLeave);

  function useHandler(eventType, cb) {
    zr.on(eventType, function (e) {
      var dis = makeDispatchAction(api);
      each(get(zr).records, function (record) {
        record && cb(record, e, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api);
    });
  }
}

function dispatchTooltipFinally(pendings, api) {
  var showLen = pendings.showTip.length;
  var hideLen = pendings.hideTip.length;
  var actuallyPayload;

  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }

  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api.dispatchAction(actuallyPayload);
  }
}

function onLeave(record, e, dispatchAction) {
  record.handler('leave', null, dispatchAction);
}

function doEnter(currTrigger, record, e, dispatchAction) {
  record.handler(currTrigger, e, dispatchAction);
}

function makeDispatchAction(api) {
  var pendings = {
    showTip: [],
    hideTip: []
  }; // FIXME
  // better approach?
  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
  // So we have to add "final stage" to merge those dispatched actions.

  var dispatchAction = function (payload) {
    var pendingList = pendings[payload.type];

    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction;
      api.dispatchAction(payload);
    }
  };

  return {
    dispatchAction: dispatchAction,
    pendings: pendings
  };
}
/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 */


function unregister(key, api) {
  if (env.node) {
    return;
  }

  var zr = api.getZr();
  var record = (get(zr).records || {})[key];

  if (record) {
    get(zr).records[key] = null;
  }
}

exports.register = register;
exports.unregister = unregister;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var graphic = __webpack_require__(93);

var textContain = __webpack_require__(108);

var formatUtil = __webpack_require__(99);

var matrix = __webpack_require__(110);

var axisHelper = __webpack_require__(112);

var AxisBuilder = __webpack_require__(166);

/**
 * @param {module:echarts/model/Model} axisPointerModel
 */
function buildElStyle(axisPointerModel) {
  var axisPointerType = axisPointerModel.get('type');
  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');
  var style;

  if (axisPointerType === 'line') {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === 'shadow') {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }

  return style;
}
/**
 * @param {Function} labelPos {align, verticalAlign, position}
 */


function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
  var value = axisPointerModel.get('value');
  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
    precision: axisPointerModel.get('label.precision'),
    formatter: axisPointerModel.get('label.formatter')
  });
  var labelModel = axisPointerModel.getModel('label');
  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);
  var font = labelModel.getFont();
  var textRect = textContain.getBoundingRect(text, font);
  var position = labelPos.position;
  var width = textRect.width + paddings[1] + paddings[3];
  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.

  var align = labelPos.align;
  align === 'right' && (position[0] -= width);
  align === 'center' && (position[0] -= width / 2);
  var verticalAlign = labelPos.verticalAlign;
  verticalAlign === 'bottom' && (position[1] -= height);
  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container

  confineInContainer(position, width, height, api);
  var bgColor = labelModel.get('backgroundColor');

  if (!bgColor || bgColor === 'auto') {
    bgColor = axisModel.get('axisLine.lineStyle.color');
  }

  elOption.label = {
    shape: {
      x: 0,
      y: 0,
      width: width,
      height: height,
      r: labelModel.get('borderRadius')
    },
    position: position.slice(),
    // TODO: rich
    style: {
      text: text,
      textFont: font,
      textFill: labelModel.getTextColor(),
      textPosition: 'inside',
      fill: bgColor,
      stroke: labelModel.get('borderColor') || 'transparent',
      lineWidth: labelModel.get('borderWidth') || 0,
      shadowBlur: labelModel.get('shadowBlur'),
      shadowColor: labelModel.get('shadowColor'),
      shadowOffsetX: labelModel.get('shadowOffsetX'),
      shadowOffsetY: labelModel.get('shadowOffsetY')
    },
    // Lable should be over axisPointer.
    z2: 10
  };
} // Do not overflow ec container


function confineInContainer(position, width, height, api) {
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  position[0] = Math.min(position[0] + width, viewWidth) - width;
  position[1] = Math.min(position[1] + height, viewHeight) - height;
  position[0] = Math.max(position[0], 0);
  position[1] = Math.max(position[1], 0);
}
/**
 * @param {number} value
 * @param {module:echarts/coord/Axis} axis
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} opt
 * @param {Array.<Object>} seriesDataIndices
 * @param {number|string} opt.precision 'auto' or a number
 * @param {string|Function} opt.formatter label formatter
 */


function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which
  // helps to debounce when when moving label.
  value, {
    precision: opt.precision
  });
  var formatter = opt.formatter;

  if (formatter) {
    var params = {
      value: axisHelper.getAxisRawValue(axis, value),
      seriesData: []
    };
    zrUtil.each(seriesDataIndices, function (idxItem) {
      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      var dataIndex = idxItem.dataIndexInside;
      var dataParams = series && series.getDataParams(dataIndex);
      dataParams && params.seriesData.push(dataParams);
    });

    if (zrUtil.isString(formatter)) {
      text = formatter.replace('{value}', text);
    } else if (zrUtil.isFunction(formatter)) {
      text = formatter(params);
    }
  }

  return text;
}
/**
 * @param {module:echarts/coord/Axis} axis
 * @param {number} value
 * @param {Object} layoutInfo {
 *  rotation, position, labelOffset, labelDirection, labelMargin
 * }
 */


function getTransformedPosition(axis, value, layoutInfo) {
  var transform = matrix.create();
  matrix.rotate(transform, transform, layoutInfo.rotation);
  matrix.translate(transform, transform, layoutInfo.position);
  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
}

function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get('label.margin');
  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
/**
 * @param {Array.<number>} p1
 * @param {Array.<number>} p2
 * @param {number} [xDimIndex=0] or 1
 */


function makeLineShape(p1, p2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p2[xDimIndex],
    y2: p2[1 - xDimIndex]
  };
}
/**
 * @param {Array.<number>} xy
 * @param {Array.<number>} wh
 * @param {number} [xDimIndex=0] or 1
 */


function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}

function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
  return {
    cx: cx,
    cy: cy,
    r0: r0,
    r: r,
    startAngle: startAngle,
    endAngle: endAngle,
    clockwise: true
  };
}

exports.buildElStyle = buildElStyle;
exports.buildLabelElOption = buildLabelElOption;
exports.getValueLabel = getValueLabel;
exports.getTransformedPosition = getTransformedPosition;
exports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;
exports.makeLineShape = makeLineShape;
exports.makeRectShape = makeRectShape;
exports.makeSectorShape = makeSectorShape;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var Model = __webpack_require__(102);

var LegendModel = echarts.extendComponentModel({
  type: 'legend.plain',
  dependencies: ['series'],
  layoutMode: {
    type: 'box',
    // legend.width/height are maxWidth/maxHeight actually,
    // whereas realy width/height is calculated by its content.
    // (Setting {left: 10, right: 10} does not make sense).
    // So consider the case:
    // `setOption({legend: {left: 10});`
    // then `setOption({legend: {right: 10});`
    // The previous `left` should be cleared by setting `ignoreSize`.
    ignoreSize: true
  },
  init: function (option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};
  },
  mergeOption: function (option) {
    LegendModel.superCall(this, 'mergeOption', option);
  },
  optionUpdated: function () {
    this._updateData(this.ecModel);

    var legendData = this._data; // If selectedMode is single, try to select one

    if (legendData[0] && this.get('selectedMode') === 'single') {
      var hasSelected = false; // If has any selected in option.selected

      for (var i = 0; i < legendData.length; i++) {
        var name = legendData[i].get('name');

        if (this.isSelected(name)) {
          // Force to unselect others
          this.select(name);
          hasSelected = true;
          break;
        }
      } // Try select the first if selectedMode is single


      !hasSelected && this.select(legendData[0].get('name'));
    }
  },
  _updateData: function (ecModel) {
    var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {
      // Can be string or number
      if (typeof dataItem === 'string' || typeof dataItem === 'number') {
        dataItem = {
          name: dataItem
        };
      }

      return new Model(dataItem, this, this.ecModel);
    }, this);
    this._data = legendData;
    var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {
      return series.name;
    });
    ecModel.eachSeries(function (seriesModel) {
      if (seriesModel.legendDataProvider) {
        var data = seriesModel.legendDataProvider();
        availableNames = availableNames.concat(data.mapArray(data.getName));
      }
    });
    /**
     * @type {Array.<string>}
     * @private
     */

    this._availableNames = availableNames;
  },

  /**
   * @return {Array.<module:echarts/model/Model>}
   */
  getData: function () {
    return this._data;
  },

  /**
   * @param {string} name
   */
  select: function (name) {
    var selected = this.option.selected;
    var selectedMode = this.get('selectedMode');

    if (selectedMode === 'single') {
      var data = this._data;
      zrUtil.each(data, function (dataItem) {
        selected[dataItem.get('name')] = false;
      });
    }

    selected[name] = true;
  },

  /**
   * @param {string} name
   */
  unSelect: function (name) {
    if (this.get('selectedMode') !== 'single') {
      this.option.selected[name] = false;
    }
  },

  /**
   * @param {string} name
   */
  toggleSelected: function (name) {
    var selected = this.option.selected; // Default is true

    if (!selected.hasOwnProperty(name)) {
      selected[name] = true;
    }

    this[selected[name] ? 'unSelect' : 'select'](name);
  },

  /**
   * @param {string} name
   */
  isSelected: function (name) {
    var selected = this.option.selected;
    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;
  },
  defaultOption: {
    // 一级层叠
    zlevel: 0,
    // 二级层叠
    z: 4,
    show: true,
    // 布局方式，默认为水平布局，可选为：
    // 'horizontal' | 'vertical'
    orient: 'horizontal',
    left: 'center',
    // right: 'center',
    top: 0,
    // bottom: null,
    // 水平对齐
    // 'auto' | 'left' | 'right'
    // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐
    align: 'auto',
    backgroundColor: 'rgba(0,0,0,0)',
    // 图例边框颜色
    borderColor: '#ccc',
    borderRadius: 0,
    // 图例边框线宽，单位px，默认为0（无边框）
    borderWidth: 0,
    // 图例内边距，单位px，默认各方向内边距为5，
    // 接受数组分别设定上右下左边距，同css
    padding: 5,
    // 各个item之间的间隔，单位px，默认为10，
    // 横向布局时为水平间隔，纵向布局时为纵向间隔
    itemGap: 10,
    // 图例图形宽度
    itemWidth: 25,
    // 图例图形高度
    itemHeight: 14,
    // 图例关闭时候的颜色
    inactiveColor: '#ccc',
    textStyle: {
      // 图例文字颜色
      color: '#333'
    },
    // formatter: '',
    // 选择模式，默认开启图例开关
    selectedMode: true,
    // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入
    // selected: null,
    // 图例内容（详见legend.data，数组中每一项代表一个item
    // data: [],
    // Tooltip 相关配置
    tooltip: {
      show: false
    }
  }
});
var _default = LegendModel;
module.exports = _default;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var _symbol = __webpack_require__(115);

var createSymbol = _symbol.createSymbol;

var graphic = __webpack_require__(93);

var _listComponent = __webpack_require__(176);

var makeBackground = _listComponent.makeBackground;

var layoutUtil = __webpack_require__(103);

var curry = zrUtil.curry;
var each = zrUtil.each;
var Group = graphic.Group;

var _default = echarts.extendComponentView({
  type: 'legend.plain',
  newlineDisabled: false,

  /**
   * @override
   */
  init: function () {
    /**
     * @private
     * @type {module:zrender/container/Group}
     */
    this.group.add(this._contentGroup = new Group());
    /**
     * @private
     * @type {module:zrender/Element}
     */

    this._backgroundEl;
  },

  /**
   * @protected
   */
  getContentGroup: function () {
    return this._contentGroup;
  },

  /**
   * @override
   */
  render: function (legendModel, ecModel, api) {
    this.resetInner();

    if (!legendModel.get('show', true)) {
      return;
    }

    var itemAlign = legendModel.get('align');

    if (!itemAlign || itemAlign === 'auto') {
      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';
    }

    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.

    var positionInfo = legendModel.getBoxLayoutParams();
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var padding = legendModel.get('padding');
    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);
    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.

    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.

    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  },

  /**
   * @protected
   */
  resetInner: function () {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
  },

  /**
   * @protected
   */
  renderInner: function (itemAlign, legendModel, ecModel, api) {
    var contentGroup = this.getContentGroup();
    var legendDrawnMap = zrUtil.createHashMap();
    var selectMode = legendModel.get('selectedMode');
    each(legendModel.getData(), function (itemModel, dataIndex) {
      var name = itemModel.get('name'); // Use empty string or \n as a newline string

      if (!this.newlineDisabled && (name === '' || name === '\n')) {
        contentGroup.add(new Group({
          newline: true
        }));
        return;
      }

      var seriesModel = ecModel.getSeriesByName(name)[0];

      if (legendDrawnMap.get(name)) {
        // Have been drawed
        return;
      } // Series legend


      if (seriesModel) {
        var data = seriesModel.getData();
        var color = data.getVisual('color'); // If color is a callback function

        if (typeof color === 'function') {
          // Use the first data
          color = color(seriesModel.getDataParams(0));
        } // Using rect symbol defaultly


        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';
        var symbolType = data.getVisual('symbol');

        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);

        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));
        legendDrawnMap.set(name, true);
      } else {
        // Data legend of pie, funnel
        ecModel.eachRawSeries(function (seriesModel) {
          // In case multiple series has same data name
          if (legendDrawnMap.get(name)) {
            return;
          }

          if (seriesModel.legendDataProvider) {
            var data = seriesModel.legendDataProvider();
            var idx = data.indexOfName(name);

            if (idx < 0) {
              return;
            }

            var color = data.getItemVisual(idx, 'color');
            var legendSymbolType = 'roundRect';

            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);

            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name
            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));
            legendDrawnMap.set(name, true);
          }
        }, this);
      }
    }, this);
  },
  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {
    var itemWidth = legendModel.get('itemWidth');
    var itemHeight = legendModel.get('itemHeight');
    var inactiveColor = legendModel.get('inactiveColor');
    var isSelected = legendModel.isSelected(name);
    var itemGroup = new Group();
    var textStyleModel = itemModel.getModel('textStyle');
    var itemIcon = itemModel.get('icon');
    var tooltipModel = itemModel.getModel('tooltip');
    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first

    legendSymbolType = itemIcon || legendSymbolType;
    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols
    // PENDING

    if (!itemIcon && symbolType // At least show one symbol, can't be all none
    && (symbolType !== legendSymbolType || symbolType == 'none')) {
      var size = itemHeight * 0.8;

      if (symbolType === 'none') {
        symbolType = 'circle';
      } // Put symbol in the center


      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));
    }

    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
    var textAlign = itemAlign;
    var formatter = legendModel.get('formatter');
    var content = name;

    if (typeof formatter === 'string' && formatter) {
      content = formatter.replace('{name}', name != null ? name : '');
    } else if (typeof formatter === 'function') {
      content = formatter(name);
    }

    itemGroup.add(new graphic.Text({
      style: graphic.setTextStyle({}, textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
        textAlign: textAlign,
        textVerticalAlign: 'middle'
      })
    })); // Add a invisible rect to increase the area of mouse hover

    var hitRect = new graphic.Rect({
      shape: itemGroup.getBoundingRect(),
      invisible: true,
      tooltip: tooltipModel.get('show') ? zrUtil.extend({
        content: name,
        // Defaul formatter
        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {
          return name;
        },
        formatterParams: {
          componentType: 'legend',
          legendIndex: legendModel.componentIndex,
          name: name,
          $vars: ['name']
        }
      }, tooltipModel.option) : null
    });
    itemGroup.add(hitRect);
    itemGroup.eachChild(function (child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    graphic.setHoverStyle(itemGroup);
    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  },

  /**
   * @protected
   */
  layoutInner: function (legendModel, itemAlign, maxSize) {
    var contentGroup = this.getContentGroup(); // Place items in contentGroup.

    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);
    var contentRect = contentGroup.getBoundingRect();
    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);
    return this.group.getBoundingRect();
  }
});

function dispatchSelectAction(name, api) {
  api.dispatchAction({
    type: 'legendToggleSelect',
    name: name
  });
}

function dispatchHighlightAction(seriesModel, dataName, api) {
  // If element hover will move to a hoverLayer.
  var el = api.getZr().storage.getDisplayList()[0];

  if (!(el && el.useHoverLayer)) {
    seriesModel.get('legendHoverLink') && api.dispatchAction({
      type: 'highlight',
      seriesName: seriesModel.name,
      name: dataName
    });
  }
}

function dispatchDownplayAction(seriesModel, dataName, api) {
  // If element hover will move to a hoverLayer.
  var el = api.getZr().storage.getDisplayList()[0];

  if (!(el && el.useHoverLayer)) {
    seriesModel.get('legendHoverLink') && api.dispatchAction({
      type: 'downplay',
      seriesName: seriesModel.name,
      name: dataName
    });
  }
}

module.exports = _default;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var _layout = __webpack_require__(103);

var getLayoutRect = _layout.getLayoutRect;
var layoutBox = _layout.box;
var positionElement = _layout.positionElement;

var formatUtil = __webpack_require__(99);

var graphic = __webpack_require__(93);

/**
 * Layout list like component.
 * It will box layout each items in group of component and then position the whole group in the viewport
 * @param {module:zrender/group/Group} group
 * @param {module:echarts/model/Component} componentModel
 * @param {module:echarts/ExtensionAPI}
 */
function layout(group, componentModel, api) {
  var boxLayoutParams = componentModel.getBoxLayoutParams();
  var padding = componentModel.get('padding');
  var viewportSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);
  positionElement(group, boxLayoutParams, viewportSize, padding);
}

function makeBackground(rect, componentModel) {
  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));
  var style = componentModel.getItemStyle(['color', 'opacity']);
  style.fill = componentModel.get('backgroundColor');
  var rect = new graphic.Rect({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get('borderRadius')
    },
    style: style,
    silent: true,
    z2: -1
  }); // FIXME
  // `subPixelOptimizeRect` may bring some gap between edge of viewpart
  // and background rect when setting like `left: 0`, `top: 0`.
  // graphic.subPixelOptimizeRect(rect);

  return rect;
}

exports.layout = layout;
exports.makeBackground = makeBackground;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(105);

Component.registerSubTypeDefaulter('dataZoom', function () {
  // Default 'slider' when no type specified.
  return 'slider';
});

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var ATTR = '\0_ec_interaction_mutex';

function take(zr, resourceKey, userKey) {
  var store = getStore(zr);
  store[resourceKey] = userKey;
}

function release(zr, resourceKey, userKey) {
  var store = getStore(zr);
  var uKey = store[resourceKey];

  if (uKey === userKey) {
    store[resourceKey] = null;
  }
}

function isTaken(zr, resourceKey) {
  return !!getStore(zr)[resourceKey];
}

function getStore(zr) {
  return zr[ATTR] || (zr[ATTR] = {});
}
/**
 * payload: {
 *     type: 'takeGlobalCursor',
 *     key: 'dataZoomSelect', or 'brush', or ...,
 *         If no userKey, release global cursor.
 * }
 */


echarts.registerAction({
  type: 'takeGlobalCursor',
  event: 'globalCursorTaken',
  update: 'update'
}, function () {});
exports.take = take;
exports.release = release;
exports.isTaken = isTaken;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

echarts.registerProcessor(function (ecModel, api) {
  ecModel.eachComponent('dataZoom', function (dataZoomModel) {
    // We calculate window and reset axis here but not in model
    // init stage and not after action dispatch handler, because
    // reset should be called after seriesData.restoreData.
    dataZoomModel.eachTargetAxis(resetSingleAxis); // Caution: data zoom filtering is order sensitive when using
    // percent range and no min/max/scale set on axis.
    // For example, we have dataZoom definition:
    // [
    //      {xAxisIndex: 0, start: 30, end: 70},
    //      {yAxisIndex: 0, start: 20, end: 80}
    // ]
    // In this case, [20, 80] of y-dataZoom should be based on data
    // that have filtered by x-dataZoom using range of [30, 70],
    // but should not be based on full raw data. Thus sliding
    // x-dataZoom will change both ranges of xAxis and yAxis,
    // while sliding y-dataZoom will only change the range of yAxis.
    // So we should filter x-axis after reset x-axis immediately,
    // and then reset y-axis and filter y-axis.

    dataZoomModel.eachTargetAxis(filterSingleAxis);
  });
  ecModel.eachComponent('dataZoom', function (dataZoomModel) {
    // Fullfill all of the range props so that user
    // is able to get them from chart.getOption().
    var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
    var percentRange = axisProxy.getDataPercentWindow();
    var valueRange = axisProxy.getDataValueWindow();
    dataZoomModel.setRawRange({
      start: percentRange[0],
      end: percentRange[1],
      startValue: valueRange[0],
      endValue: valueRange[1]
    }, true);
  });
});

function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {
  dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);
}

function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {
  dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);
}

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var helper = __webpack_require__(136);

echarts.registerAction('dataZoom', function (payload, ecModel) {
  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {
    return model.get(dimNames.axisIndex);
  });
  var effectedModels = [];
  ecModel.eachComponent({
    mainType: 'dataZoom',
    query: payload
  }, function (model, index) {
    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);
  });
  zrUtil.each(effectedModels, function (dataZoomModel, index) {
    dataZoomModel.setRawRange({
      start: payload.start,
      end: payload.end,
      startValue: payload.startValue,
      endValue: payload.endValue
    });
  });
});

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var env = __webpack_require__(98);

var modelUtil = __webpack_require__(95);

var formatUtil = __webpack_require__(99);

var addCommas = formatUtil.addCommas;
var encodeHTML = formatUtil.encodeHTML;

function fillLabel(opt) {
  modelUtil.defaultEmphasis(opt.label, ['show']);
}

var MarkerModel = echarts.extendComponentModel({
  type: 'marker',
  dependencies: ['series', 'grid', 'polar', 'geo'],

  /**
   * @overrite
   */
  init: function (option, parentModel, ecModel, extraOpt) {
    this.mergeDefaultAndTheme(option, ecModel);
    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);
  },

  /**
   * @return {boolean}
   */
  isAnimationEnabled: function () {
    if (env.node) {
      return false;
    }

    var hostSeries = this.__hostSeries;
    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();
  },
  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {
    var MarkerModel = this.constructor;
    var modelPropName = this.mainType + 'Model';

    if (!createdBySelf) {
      ecModel.eachSeries(function (seriesModel) {
        var markerOpt = seriesModel.get(this.mainType);
        var markerModel = seriesModel[modelPropName];

        if (!markerOpt || !markerOpt.data) {
          seriesModel[modelPropName] = null;
          return;
        }

        if (!markerModel) {
          if (isInit) {
            // Default label emphasis `position` and `show`
            fillLabel(markerOpt);
          }

          zrUtil.each(markerOpt.data, function (item) {
            // FIXME Overwrite fillLabel method ?
            if (item instanceof Array) {
              fillLabel(item[0]);
              fillLabel(item[1]);
            } else {
              fillLabel(item);
            }
          });
          markerModel = new MarkerModel(markerOpt, this, ecModel);
          zrUtil.extend(markerModel, {
            mainType: this.mainType,
            // Use the same series index and name
            seriesIndex: seriesModel.seriesIndex,
            name: seriesModel.name,
            createdBySelf: true
          });
          markerModel.__hostSeries = seriesModel;
        } else {
          markerModel.mergeOption(markerOpt, ecModel, true);
        }

        seriesModel[modelPropName] = markerModel;
      }, this);
    }
  },
  formatTooltip: function (dataIndex) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);
    var name = data.getName(dataIndex);
    var html = encodeHTML(this.name);

    if (value != null || name) {
      html += '<br />';
    }

    if (name) {
      html += encodeHTML(name);

      if (value != null) {
        html += ' : ';
      }
    }

    if (value != null) {
      html += encodeHTML(formattedValue);
    }

    return html;
  },
  getData: function () {
    return this._data;
  },
  setData: function (data) {
    this._data = data;
  }
});
zrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin);
var _default = MarkerModel;
module.exports = _default;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var numberUtil = __webpack_require__(94);

var indexOf = zrUtil.indexOf;

function hasXOrY(item) {
  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
}

function hasXAndY(item) {
  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
}

function getPrecision(data, valueAxisDim, dataIndex) {
  var precision = -1;

  do {
    precision = Math.max(numberUtil.getPrecision(data.get(valueAxisDim, dataIndex)), precision);
    data = data.stackedOn;
  } while (data);

  return precision;
}

function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
  var coordArr = [];
  var value = numCalculate(data, targetDataDim, mlType);
  var dataIndex = data.indicesOfNearest(targetDataDim, value, true)[0];
  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);
  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);
  var precision = getPrecision(data, targetDataDim, dataIndex);
  precision = Math.min(precision, 20);

  if (precision >= 0) {
    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
  }

  return coordArr;
}

var curry = zrUtil.curry; // TODO Specified percent

var markerTypeCalculator = {
  /**
   * @method
   * @param {module:echarts/data/List} data
   * @param {string} baseAxisDim
   * @param {string} valueAxisDim
   */
  min: curry(markerTypeCalculatorWithExtent, 'min'),

  /**
   * @method
   * @param {module:echarts/data/List} data
   * @param {string} baseAxisDim
   * @param {string} valueAxisDim
   */
  max: curry(markerTypeCalculatorWithExtent, 'max'),

  /**
   * @method
   * @param {module:echarts/data/List} data
   * @param {string} baseAxisDim
   * @param {string} valueAxisDim
   */
  average: curry(markerTypeCalculatorWithExtent, 'average')
};
/**
 * Transform markPoint data item to format used in List by do the following
 * 1. Calculate statistic like `max`, `min`, `average`
 * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
 * @param  {module:echarts/model/Series} seriesModel
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {Object}
 */

function dataTransform(seriesModel, item) {
  var data = seriesModel.getData();
  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly
  // 2. If `coord` is not a data array. Which uses `xAxis`,
  // `yAxis` to specify the coord on each dimension
  // parseFloat first because item.x and item.y can be percent string like '20%'

  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {
    var dims = coordSys.dimensions;
    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option
    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value

    item = zrUtil.clone(item);

    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.

      item.value = item.coord[targetCoordIndex];
    } else {
      // FIXME Only has one of xAxis and yAxis.
      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average

      for (var i = 0; i < 2; i++) {
        if (markerTypeCalculator[coord[i]]) {
          var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];
          coord[i] = numCalculate(data, dataDim, coord[i]);
        }
      }

      item.coord = coord;
    }
  }

  return item;
}

function getAxisInfo(item, data, coordSys, seriesModel) {
  var ret = {};

  if (item.valueIndex != null || item.valueDim != null) {
    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
    ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));
    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];
  } else {
    ret.baseAxis = seriesModel.getBaseAxis();
    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];
    ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];
  }

  return ret;
}
/**
 * Filter data which is out of coordinateSystem range
 * [dataFilter description]
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {boolean}
 */


function dataFilter(coordSys, item) {
  // Alwalys return true if there is no coordSys
  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
}

function dimValueGetter(item, dimName, dataIndex, dimIndex) {
  // x, y, radius, angle
  if (dimIndex < 2) {
    return item.coord && item.coord[dimIndex];
  }

  return item.value;
}

function numCalculate(data, valueDataDim, type) {
  if (type === 'average') {
    var sum = 0;
    var count = 0;
    data.each(valueDataDim, function (val, idx) {
      if (!isNaN(val)) {
        sum += val;
        count++;
      }
    }, true);
    return sum / count;
  } else {
    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];
  }
}

exports.dataTransform = dataTransform;
exports.getAxisInfo = getAxisInfo;
exports.dataFilter = dataFilter;
exports.dimValueGetter = dimValueGetter;
exports.numCalculate = numCalculate;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var _default = echarts.extendComponentView({
  type: 'marker',
  init: function () {
    /**
     * Markline grouped by series
     * @private
     * @type {module:zrender/core/util.HashMap}
     */
    this.markerGroupMap = zrUtil.createHashMap();
  },
  render: function (markerModel, ecModel, api) {
    var markerGroupMap = this.markerGroupMap;
    markerGroupMap.each(function (item) {
      item.__keep = false;
    });
    var markerModelKey = this.type + 'Model';
    ecModel.eachSeries(function (seriesModel) {
      var markerModel = seriesModel[markerModelKey];
      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);
    }, this);
    markerGroupMap.each(function (item) {
      !item.__keep && this.group.remove(item.group);
    }, this);
  },
  renderSeries: function () {}
});

module.exports = _default;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var each = zrUtil.each;
var ATTR = '\0_ec_hist_store';
/**
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}
 */

function push(ecModel, newSnapshot) {
  var store = giveStore(ecModel); // If previous dataZoom can not be found,
  // complete an range with current range.

  each(newSnapshot, function (batchItem, dataZoomId) {
    var i = store.length - 1;

    for (; i >= 0; i--) {
      var snapshot = store[i];

      if (snapshot[dataZoomId]) {
        break;
      }
    }

    if (i < 0) {
      // No origin range set, create one by current range.
      var dataZoomModel = ecModel.queryComponents({
        mainType: 'dataZoom',
        subType: 'select',
        id: dataZoomId
      })[0];

      if (dataZoomModel) {
        var percentRange = dataZoomModel.getPercentRange();
        store[0][dataZoomId] = {
          dataZoomId: dataZoomId,
          start: percentRange[0],
          end: percentRange[1]
        };
      }
    }
  });
  store.push(newSnapshot);
}
/**
 * @param {module:echarts/model/Global} ecModel
 * @return {Object} snapshot
 */


function pop(ecModel) {
  var store = giveStore(ecModel);
  var head = store[store.length - 1];
  store.length > 1 && store.pop(); // Find top for all dataZoom.

  var snapshot = {};
  each(head, function (batchItem, dataZoomId) {
    for (var i = store.length - 1; i >= 0; i--) {
      var batchItem = store[i][dataZoomId];

      if (batchItem) {
        snapshot[dataZoomId] = batchItem;
        break;
      }
    }
  });
  return snapshot;
}
/**
 * @param {module:echarts/model/Global} ecModel
 */


function clear(ecModel) {
  ecModel[ATTR] = null;
}
/**
 * @param {module:echarts/model/Global} ecModel
 * @return {number} records. always >= 1.
 */


function count(ecModel) {
  return giveStore(ecModel).length;
}
/**
 * [{key: dataZoomId, value: {dataZoomId, range}}, ...]
 * History length of each dataZoom may be different.
 * this._history[0] is used to store origin range.
 * @type {Array.<Object>}
 */


function giveStore(ecModel) {
  var store = ecModel[ATTR];

  if (!store) {
    store = ecModel[ATTR] = [{}];
  }

  return store;
}

exports.push = push;
exports.pop = pop;
exports.clear = clear;
exports.count = count;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(91);

var vec2 = __webpack_require__(97);

var Draggable = __webpack_require__(186);

var Eventful = __webpack_require__(107);

/**
 * Handler
 * @module zrender/Handler
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 *         pissang (shenyi.914@gmail.com)
 */
var SILENT = 'silent';

function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event: event,
    // target can only be an element that is not silent.
    target: targetInfo.target,
    // topTarget can be a silent element.
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which
  };
}

function EmptyProxy() {}

EmptyProxy.prototype.dispose = function () {};

var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
/**
 * @alias module:zrender/Handler
 * @constructor
 * @extends module:zrender/mixin/Eventful
 * @param {module:zrender/Storage} storage Storage instance.
 * @param {module:zrender/Painter} painter Painter instance.
 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
 */

var Handler = function (storage, painter, proxy, painterRoot) {
  Eventful.call(this);
  this.storage = storage;
  this.painter = painter;
  this.painterRoot = painterRoot;
  proxy = proxy || new EmptyProxy();
  /**
   * Proxy of event. can be Dom, WebGLSurface, etc.
   */

  this.proxy = proxy; // Attach handler

  proxy.handler = this;
  /**
   * {target, topTarget, x, y}
   * @private
   * @type {Object}
   */

  this._hovered = {};
  /**
   * @private
   * @type {Date}
   */

  this._lastTouchMoment;
  /**
   * @private
   * @type {number}
   */

  this._lastX;
  /**
   * @private
   * @type {number}
   */

  this._lastY;
  Draggable.call(this);
  util.each(handlerNames, function (name) {
    proxy.on && proxy.on(name, this[name], this);
  }, this);
};

Handler.prototype = {
  constructor: Handler,
  mousemove: function (event) {
    var x = event.zrX;
    var y = event.zrY;
    var lastHovered = this._hovered;
    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
    // (like 'setOption' or 'dispatchAction') in event handlers, we should find
    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
    // See #6198.

    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }

    var hovered = this._hovered = this.findHover(x, y);
    var hoveredTarget = hovered.target;
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element

    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, 'mouseout', event);
    } // Mouse moving on one element


    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element

    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, 'mouseover', event);
    }
  },
  mouseout: function (event) {
    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application
    // at the same level of painter.getViewportRoot() (e.g., tooltip
    // dom created by echarts), where 'globalout' event should not
    // be triggered when mouse enters these doms. (But 'mouseout'
    // should be triggered at the original hovered element as usual).

    var element = event.toElement || event.relatedTarget;
    var innerDom;

    do {
      element = element && element.parentNode;
    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));

    !innerDom && this.trigger('globalout', {
      event: event
    });
  },

  /**
   * Resize
   */
  resize: function (event) {
    this._hovered = {};
  },

  /**
   * Dispatch event
   * @param {string} eventName
   * @param {event=} eventArgs
   */
  dispatch: function (eventName, eventArgs) {
    var handler = this[eventName];
    handler && handler.call(this, eventArgs);
  },

  /**
   * Dispose
   */
  dispose: function () {
    this.proxy.dispose();
    this.storage = this.proxy = this.painter = null;
  },

  /**
   * 设置默认的cursor style
   * @param {string} [cursorStyle='default'] 例如 crosshair
   */
  setCursorStyle: function (cursorStyle) {
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  },

  /**
   * 事件分发代理
   *
   * @private
   * @param {Object} targetInfo {target, topTarget} 目标图形元素
   * @param {string} eventName 事件名称
   * @param {Object} event 事件对象
   */
  dispatchToElement: function (targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    var el = targetInfo.target;

    if (el && el.silent) {
      return;
    }

    var eventHandler = 'on' + eventName;
    var eventPacket = makeEventPacket(eventName, targetInfo, event);

    while (el) {
      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.parent;

      if (eventPacket.cancelBubble) {
        break;
      }
    }

    if (!eventPacket.cancelBubble) {
      // 冒泡到顶级 zrender 对象
      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在

      this.painter && this.painter.eachOtherLayer(function (layer) {
        if (typeof layer[eventHandler] == 'function') {
          layer[eventHandler].call(layer, eventPacket);
        }

        if (layer.trigger) {
          layer.trigger(eventName, eventPacket);
        }
      });
    }
  },

  /**
   * @private
   * @param {number} x
   * @param {number} y
   * @param {module:zrender/graphic/Displayable} exclude
   * @return {model:zrender/Element}
   * @method
   */
  findHover: function (x, y, exclude) {
    var list = this.storage.getDisplayList();
    var out = {
      x: x,
      y: y
    };

    for (var i = list.length - 1; i >= 0; i--) {
      var hoverCheckResult;

      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
        !out.topTarget && (out.topTarget = list[i]);

        if (hoverCheckResult !== SILENT) {
          out.target = list[i];
          break;
        }
      }
    }

    return out;
  }
}; // Common handlers

util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
  Handler.prototype[name] = function (event) {
    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
    var hovered = this.findHover(event.zrX, event.zrY);
    var hoveredTarget = hovered.target;

    if (name === 'mousedown') {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup

      this._upEl = hoveredTarget;
    } else if (name === 'mosueup') {
      this._upEl = hoveredTarget;
    } else if (name === 'click') {
      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
      // including the case that `mousedown` - `mousemove` - `mouseup`,
      // which should be filtered, otherwise it will bring trouble to
      // pan and zoom.
      || !this._downPoint // Arbitrary value
      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }

      this._downPoint = null;
    }

    this.dispatchToElement(hovered, name, event);
  };
});

function isHover(displayable, x, y) {
  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
    var el = displayable;
    var isSilent;

    while (el) {
      // If clipped by ancestor.
      // FIXME: If clipPath has neither stroke nor fill,
      // el.clipPath.contain(x, y) will always return false.
      if (el.clipPath && !el.clipPath.contain(x, y)) {
        return false;
      }

      if (el.silent) {
        isSilent = true;
      }

      el = el.parent;
    }

    return isSilent ? SILENT : true;
  }

  return false;
}

util.mixin(Handler, Eventful);
util.mixin(Handler, Draggable);
var _default = Handler;
module.exports = _default;

/***/ }),
/* 186 */
/***/ (function(module, exports) {

// TODO Draggable for group
// FIXME Draggable on element which has parent rotation or scale
function Draggable() {
  this.on('mousedown', this._dragStart, this);
  this.on('mousemove', this._drag, this);
  this.on('mouseup', this._dragEnd, this);
  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;
  // this._draggingTarget = null;
  // this._x = 0;
  // this._y = 0;
}

Draggable.prototype = {
  constructor: Draggable,
  _dragStart: function (e) {
    var draggingTarget = e.target;

    if (draggingTarget && draggingTarget.draggable) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e.offsetX;
      this._y = e.offsetY;
      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
    }
  },
  _drag: function (e) {
    var draggingTarget = this._draggingTarget;

    if (draggingTarget) {
      var x = e.offsetX;
      var y = e.offsetY;
      var dx = x - this._x;
      var dy = y - this._y;
      this._x = x;
      this._y = y;
      draggingTarget.drift(dx, dy, e);
      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
      var dropTarget = this.findHover(x, y, draggingTarget).target;
      var lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;

      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
        }

        if (dropTarget && dropTarget !== lastDropTarget) {
          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
        }
      }
    }
  },
  _dragEnd: function (e) {
    var draggingTarget = this._draggingTarget;

    if (draggingTarget) {
      draggingTarget.dragging = false;
    }

    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);

    if (this._dropTarget) {
      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
    }

    this._draggingTarget = null;
    this._dropTarget = null;
  }
};

function param(target, e) {
  return {
    target: target,
    topTarget: e && e.topTarget
  };
}

var _default = Draggable;
module.exports = _default;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(91);

var env = __webpack_require__(98);

var Group = __webpack_require__(119);

var timsort = __webpack_require__(126);

/**
 * Storage内容仓库模块
 * @module zrender/Storage
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 * @author errorrik (errorrik@gmail.com)
 * @author pissang (https://github.com/pissang/)
 */
// Use timsort because in most case elements are partially sorted
// https://jsfiddle.net/pissang/jr4x7mdm/8/
function shapeCompareFunc(a, b) {
  if (a.zlevel === b.zlevel) {
    if (a.z === b.z) {
      // if (a.z2 === b.z2) {
      //     // FIXME Slow has renderidx compare
      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
      //     return a.__renderidx - b.__renderidx;
      // }
      return a.z2 - b.z2;
    }

    return a.z - b.z;
  }

  return a.zlevel - b.zlevel;
}
/**
 * 内容仓库 (M)
 * @alias module:zrender/Storage
 * @constructor
 */


var Storage = function () {
  // jshint ignore:line
  this._roots = [];
  this._displayList = [];
  this._displayListLen = 0;
};

Storage.prototype = {
  constructor: Storage,

  /**
   * @param  {Function} cb
   *
   */
  traverse: function (cb, context) {
    for (var i = 0; i < this._roots.length; i++) {
      this._roots[i].traverse(cb, context);
    }
  },

  /**
   * 返回所有图形的绘制队列
   * @param {boolean} [update=false] 是否在返回前更新该数组
   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
   *
   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
   * @return {Array.<module:zrender/graphic/Displayable>}
   */
  getDisplayList: function (update, includeIgnore) {
    includeIgnore = includeIgnore || false;

    if (update) {
      this.updateDisplayList(includeIgnore);
    }

    return this._displayList;
  },

  /**
   * 更新图形的绘制队列。
   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
   */
  updateDisplayList: function (includeIgnore) {
    this._displayListLen = 0;
    var roots = this._roots;
    var displayList = this._displayList;

    for (var i = 0, len = roots.length; i < len; i++) {
      this._updateAndAddDisplayable(roots[i], null, includeIgnore);
    }

    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {
    //     displayList[i].__renderidx = i;
    // }
    // displayList.sort(shapeCompareFunc);

    env.canvasSupported && timsort(displayList, shapeCompareFunc);
  },
  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }

    el.beforeUpdate();

    if (el.__dirty) {
      el.update();
    }

    el.afterUpdate();
    var userSetClipPath = el.clipPath;

    if (userSetClipPath) {
      // FIXME 效率影响
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }

      var currentClipPath = userSetClipPath;
      var parentClipPath = el; // Recursively add clip path

      while (currentClipPath) {
        // clipPath 的变换是基于使用这个 clipPath 的元素
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.clipPath;
      }
    }

    if (el.isGroup) {
      var children = el._children;

      for (var i = 0; i < children.length; i++) {
        var child = children[i]; // Force to mark as dirty if group is dirty
        // FIXME __dirtyPath ?

        if (el.__dirty) {
          child.__dirty = true;
        }

        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      } // Mark group clean here


      el.__dirty = false;
    } else {
      el.__clipPaths = clipPaths;
      this._displayList[this._displayListLen++] = el;
    }
  },

  /**
   * 添加图形(Shape)或者组(Group)到根节点
   * @param {module:zrender/Element} el
   */
  addRoot: function (el) {
    if (el.__storage === this) {
      return;
    }

    if (el instanceof Group) {
      el.addChildrenToStorage(this);
    }

    this.addToStorage(el);

    this._roots.push(el);
  },

  /**
   * 删除指定的图形(Shape)或者组(Group)
   * @param {string|Array.<string>} [el] 如果为空清空整个Storage
   */
  delRoot: function (el) {
    if (el == null) {
      // 不指定el清空
      for (var i = 0; i < this._roots.length; i++) {
        var root = this._roots[i];

        if (root instanceof Group) {
          root.delChildrenFromStorage(this);
        }
      }

      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      return;
    }

    if (el instanceof Array) {
      for (var i = 0, l = el.length; i < l; i++) {
        this.delRoot(el[i]);
      }

      return;
    }

    var idx = util.indexOf(this._roots, el);

    if (idx >= 0) {
      this.delFromStorage(el);

      this._roots.splice(idx, 1);

      if (el instanceof Group) {
        el.delChildrenFromStorage(this);
      }
    }
  },
  addToStorage: function (el) {
    el.__storage = this;
    el.dirty(false);
    return this;
  },
  delFromStorage: function (el) {
    if (el) {
      el.__storage = null;
    }

    return this;
  },

  /**
   * 清空并且释放Storage
   */
  dispose: function () {
    this._renderList = this._roots = null;
  },
  displayableSortFunc: shapeCompareFunc
};
var _default = Storage;
module.exports = _default;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var Animator = __webpack_require__(142);

var log = __webpack_require__(144);

var _util = __webpack_require__(91);

var isString = _util.isString;
var isFunction = _util.isFunction;
var isObject = _util.isObject;
var isArrayLike = _util.isArrayLike;
var indexOf = _util.indexOf;

/**
 * @alias modue:zrender/mixin/Animatable
 * @constructor
 */
var Animatable = function () {
  /**
   * @type {Array.<module:zrender/animation/Animator>}
   * @readOnly
   */
  this.animators = [];
};

Animatable.prototype = {
  constructor: Animatable,

  /**
   * 动画
   *
   * @param {string} path The path to fetch value from object, like 'a.b.c'.
   * @param {boolean} [loop] Whether to loop animation.
   * @return {module:zrender/animation/Animator}
   * @example:
   *     el.animate('style', false)
   *         .when(1000, {x: 10} )
   *         .done(function(){ // Animation done })
   *         .start()
   */
  animate: function (path, loop) {
    var target;
    var animatingShape = false;
    var el = this;
    var zr = this.__zr;

    if (path) {
      var pathSplitted = path.split('.');
      var prop = el; // If animating shape

      animatingShape = pathSplitted[0] === 'shape';

      for (var i = 0, l = pathSplitted.length; i < l; i++) {
        if (!prop) {
          continue;
        }

        prop = prop[pathSplitted[i]];
      }

      if (prop) {
        target = prop;
      }
    } else {
      target = el;
    }

    if (!target) {
      log('Property "' + path + '" is not existed in element ' + el.id);
      return;
    }

    var animators = el.animators;
    var animator = new Animator(target, loop);
    animator.during(function (target) {
      el.dirty(animatingShape);
    }).done(function () {
      // FIXME Animator will not be removed if use `Animator#stop` to stop animation
      animators.splice(indexOf(animators, animator), 1);
    });
    animators.push(animator); // If animate after added to the zrender

    if (zr) {
      zr.animation.addAnimator(animator);
    }

    return animator;
  },

  /**
   * 停止动画
   * @param {boolean} forwardToLast If move to last frame before stop
   */
  stopAnimation: function (forwardToLast) {
    var animators = this.animators;
    var len = animators.length;

    for (var i = 0; i < len; i++) {
      animators[i].stop(forwardToLast);
    }

    animators.length = 0;
    return this;
  },

  /**
   * Caution: this method will stop previous animation.
   * So do not use this method to one element twice before
   * animation starts, unless you know what you are doing.
   * @param {Object} target
   * @param {number} [time=500] Time in ms
   * @param {string} [easing='linear']
   * @param {number} [delay=0]
   * @param {Function} [callback]
   * @param {Function} [forceAnimate] Prevent stop animation and callback
   *        immediently when target values are the same as current values.
   *
   * @example
   *  // Animate position
   *  el.animateTo({
   *      position: [10, 10]
   *  }, function () { // done })
   *
   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
   *  el.animateTo({
   *      shape: {
   *          width: 500
   *      },
   *      style: {
   *          fill: 'red'
   *      }
   *      position: [10, 10]
   *  }, 100, 100, 'cubicOut', function () { // done })
   */
  // TODO Return animation key
  animateTo: function (target, time, delay, easing, callback, forceAnimate) {
    // animateTo(target, time, easing, callback);
    if (isString(delay)) {
      callback = easing;
      easing = delay;
      delay = 0;
    } // animateTo(target, time, delay, callback);
    else if (isFunction(easing)) {
        callback = easing;
        easing = 'linear';
        delay = 0;
      } // animateTo(target, time, callback);
      else if (isFunction(delay)) {
          callback = delay;
          delay = 0;
        } // animateTo(target, callback)
        else if (isFunction(time)) {
            callback = time;
            time = 500;
          } // animateTo(target)
          else if (!time) {
              time = 500;
            } // Stop all previous animations


    this.stopAnimation();

    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start
    // if there is nothing to animate


    var animators = this.animators.slice();
    var count = animators.length;

    function done() {
      count--;

      if (!count) {
        callback && callback();
      }
    } // No animators. This should be checked before animators[i].start(),
    // because 'done' may be executed immediately if no need to animate.


    if (!count) {
      callback && callback();
    } // Start after all animators created
    // Incase any animator is done immediately when all animation properties are not changed


    for (var i = 0; i < animators.length; i++) {
      animators[i].done(done).start(easing, forceAnimate);
    }
  },

  /**
   * @private
   * @param {string} path=''
   * @param {Object} source=this
   * @param {Object} target
   * @param {number} [time=500]
   * @param {number} [delay=0]
   *
   * @example
   *  // Animate position
   *  el._animateToShallow({
   *      position: [10, 10]
   *  })
   *
   *  // Animate shape, style and position in 100ms, delayed 100ms
   *  el._animateToShallow({
   *      shape: {
   *          width: 500
   *      },
   *      style: {
   *          fill: 'red'
   *      }
   *      position: [10, 10]
   *  }, 100, 100)
   */
  _animateToShallow: function (path, source, target, time, delay) {
    var objShallow = {};
    var propertyCount = 0;

    for (var name in target) {
      if (!target.hasOwnProperty(name)) {
        continue;
      }

      if (source[name] != null) {
        if (isObject(target[name]) && !isArrayLike(target[name])) {
          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
        } else {
          objShallow[name] = target[name];
          propertyCount++;
        }
      } else if (target[name] != null) {
        // Attr directly if not has property
        // FIXME, if some property not needed for element ?
        if (!path) {
          this.attr(name, target[name]);
        } else {
          // Shape or style
          var props = {};
          props[path] = {};
          props[path][name] = target[name];
          this.attr(props);
        }
      }
    }

    if (propertyCount > 0) {
      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
    }

    return this;
  }
};
var _default = Animatable;
module.exports = _default;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var easingFuncs = __webpack_require__(190);

/**
 * 动画主控制器
 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
 * @config life(1000) 动画时长
 * @config delay(0) 动画延迟时间
 * @config loop(true)
 * @config gap(0) 循环的间隔时间
 * @config onframe
 * @config easing(optional)
 * @config ondestroy(optional)
 * @config onrestart(optional)
 *
 * TODO pause
 */
function Clip(options) {
  this._target = options.target; // 生命周期

  this._life = options.life || 1000; // 延时

  this._delay = options.delay || 0; // 开始时间
  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒

  this._initialized = false; // 是否循环

  this.loop = options.loop == null ? false : options.loop;
  this.gap = options.gap || 0;
  this.easing = options.easing || 'Linear';
  this.onframe = options.onframe;
  this.ondestroy = options.ondestroy;
  this.onrestart = options.onrestart;
  this._pausedTime = 0;
  this._paused = false;
}

Clip.prototype = {
  constructor: Clip,
  step: function (globalTime, deltaTime) {
    // Set startTime on first step, or _startTime may has milleseconds different between clips
    // PENDING
    if (!this._initialized) {
      this._startTime = globalTime + this._delay;
      this._initialized = true;
    }

    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }

    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始

    if (percent < 0) {
      return;
    }

    percent = Math.min(percent, 1);
    var easing = this.easing;
    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
    this.fire('frame', schedule); // 结束

    if (percent == 1) {
      if (this.loop) {
        this.restart(globalTime); // 重新开始周期
        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件

        return 'restart';
      } // 动画完成将这个控制器标识为待删除
      // 在Animation.update中进行批量删除


      this._needsRemove = true;
      return 'destroy';
    }

    return null;
  },
  restart: function (globalTime) {
    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
    this._startTime = globalTime - remainder + this.gap;
    this._pausedTime = 0;
    this._needsRemove = false;
  },
  fire: function (eventType, arg) {
    eventType = 'on' + eventType;

    if (this[eventType]) {
      this[eventType](this._target, arg);
    }
  },
  pause: function () {
    this._paused = true;
  },
  resume: function () {
    this._paused = false;
  }
};
var _default = Clip;
module.exports = _default;

/***/ }),
/* 190 */
/***/ (function(module, exports) {

/**
 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
 * @see http://sole.github.io/tween.js/examples/03_graphs.html
 * @exports zrender/animation/easing
 */
var easing = {
  /**
  * @param {number} k
  * @return {number}
  */
  linear: function (k) {
    return k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticIn: function (k) {
    return k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticOut: function (k) {
    return k * (2 - k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }

    return -0.5 * (--k * (k - 2) - 1);
  },
  // 三次方的缓动（t^3）

  /**
  * @param {number} k
  * @return {number}
  */
  cubicIn: function (k) {
    return k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  cubicOut: function (k) {
    return --k * k * k + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  cubicInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k;
    }

    return 0.5 * ((k -= 2) * k * k + 2);
  },
  // 四次方的缓动（t^4）

  /**
  * @param {number} k
  * @return {number}
  */
  quarticIn: function (k) {
    return k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quarticOut: function (k) {
    return 1 - --k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quarticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k;
    }

    return -0.5 * ((k -= 2) * k * k * k - 2);
  },
  // 五次方的缓动（t^5）

  /**
  * @param {number} k
  * @return {number}
  */
  quinticIn: function (k) {
    return k * k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quinticOut: function (k) {
    return --k * k * k * k * k + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quinticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k * k;
    }

    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  },
  // 正弦曲线的缓动（sin(t)）

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalIn: function (k) {
    return 1 - Math.cos(k * Math.PI / 2);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalOut: function (k) {
    return Math.sin(k * Math.PI / 2);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalInOut: function (k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  },
  // 指数曲线的缓动（2^t）

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialIn: function (k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialOut: function (k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialInOut: function (k) {
    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if ((k *= 2) < 1) {
      return 0.5 * Math.pow(1024, k - 1);
    }

    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  },
  // 圆形曲线的缓动（sqrt(1-t^2)）

  /**
  * @param {number} k
  * @return {number}
  */
  circularIn: function (k) {
    return 1 - Math.sqrt(1 - k * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  circularOut: function (k) {
    return Math.sqrt(1 - --k * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  circularInOut: function (k) {
    if ((k *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k * k) - 1);
    }

    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  },
  // 创建类似于弹簧在停止前来回振荡的动画

  /**
  * @param {number} k
  * @return {number}
  */
  elasticIn: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
  },

  /**
  * @param {number} k
  * @return {number}
  */
  elasticOut: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  elasticInOut: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    if ((k *= 2) < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    }

    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
  },
  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动

  /**
  * @param {number} k
  * @return {number}
  */
  backIn: function (k) {
    var s = 1.70158;
    return k * k * ((s + 1) * k - s);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  backOut: function (k) {
    var s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  backInOut: function (k) {
    var s = 1.70158 * 1.525;

    if ((k *= 2) < 1) {
      return 0.5 * (k * k * ((s + 1) * k - s));
    }

    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
  },
  // 创建弹跳效果

  /**
  * @param {number} k
  * @return {number}
  */
  bounceIn: function (k) {
    return 1 - easing.bounceOut(1 - k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  bounceOut: function (k) {
    if (k < 1 / 2.75) {
      return 7.5625 * k * k;
    } else if (k < 2 / 2.75) {
      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
    } else if (k < 2.5 / 2.75) {
      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
    }
  },

  /**
  * @param {number} k
  * @return {number}
  */
  bounceInOut: function (k) {
    if (k < 0.5) {
      return easing.bounceIn(k * 2) * 0.5;
    }

    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }
};
var _default = easing;
module.exports = _default;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(120);

var devicePixelRatio = _config.devicePixelRatio;

var util = __webpack_require__(91);

var log = __webpack_require__(144);

var BoundingRect = __webpack_require__(101);

var timsort = __webpack_require__(126);

var Layer = __webpack_require__(192);

var requestAnimationFrame = __webpack_require__(147);

var Image = __webpack_require__(148);

/**
 * Default canvas painter
 * @module zrender/Painter
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */
// PENDIGN
// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
//
// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
var MAX_PROGRESSIVE_LAYER_NUMBER = 5;

function parseInt10(val) {
  return parseInt(val, 10);
}

function isLayerValid(layer) {
  if (!layer) {
    return false;
  }

  if (layer.__builtin__) {
    return true;
  }

  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
    return false;
  }

  return true;
}

function preProcessLayer(layer) {
  layer.__unusedCount++;
}

function postProcessLayer(layer) {
  if (layer.__unusedCount == 1) {
    layer.clear();
  }
}

var tmpRect = new BoundingRect(0, 0, 0, 0);
var viewRect = new BoundingRect(0, 0, 0, 0);

function isDisplayableCulled(el, width, height) {
  tmpRect.copy(el.getBoundingRect());

  if (el.transform) {
    tmpRect.applyTransform(el.transform);
  }

  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect.intersect(viewRect);
}

function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths == prevClipPaths) {
    // Can both be null or undefined
    return false;
  }

  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }

  for (var i = 0; i < clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }
}

function doClip(clipPaths, ctx) {
  for (var i = 0; i < clipPaths.length; i++) {
    var clipPath = clipPaths[i];
    clipPath.setTransform(ctx);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip(); // Transform back

    clipPath.restoreTransform(ctx);
  }
}

function createRoot(width, height) {
  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬

  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
  return domRoot;
}
/**
 * @alias module:zrender/Painter
 * @constructor
 * @param {HTMLElement} root 绘图容器
 * @param {module:zrender/Storage} storage
 * @param {Object} opts
 */


var Painter = function (root, storage, opts) {
  this.type = 'canvas'; // In node environment using node-canvas

  var singleCanvas = !root.nodeName // In node ?
  || root.nodeName.toUpperCase() === 'CANVAS';
  this._opts = opts = util.extend({}, opts || {});
  /**
   * @type {number}
   */

  this.dpr = opts.devicePixelRatio || devicePixelRatio;
  /**
   * @type {boolean}
   * @private
   */

  this._singleCanvas = singleCanvas;
  /**
   * 绘图容器
   * @type {HTMLElement}
   */

  this.root = root;
  var rootStyle = root.style;

  if (rootStyle) {
    rootStyle['-webkit-tap-highlight-color'] = 'transparent';
    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
    root.innerHTML = '';
  }
  /**
   * @type {module:zrender/Storage}
   */


  this.storage = storage;
  /**
   * @type {Array.<number>}
   * @private
   */

  var zlevelList = this._zlevelList = [];
  /**
   * @type {Object.<string, module:zrender/Layer>}
   * @private
   */

  var layers = this._layers = {};
  /**
   * @type {Object.<string, Object>}
   * @type {private}
   */

  this._layerConfig = {};

  if (!singleCanvas) {
    this._width = this._getSize(0);
    this._height = this._getSize(1);
    var domRoot = this._domRoot = createRoot(this._width, this._height);
    root.appendChild(domRoot);
  } else {
    if (opts.width != null) {
      root.width = opts.width;
    }

    if (opts.height != null) {
      root.height = opts.height;
    } // Use canvas width and height directly


    var width = root.width;
    var height = root.height;
    this._width = width;
    this._height = height; // Create layer if only one given canvas
    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height

    var mainLayer = new Layer(root, this, 1);
    mainLayer.initContext(); // FIXME Use canvas width and height
    // mainLayer.resize(width, height);

    layers[0] = mainLayer;
    zlevelList.push(0);
    this._domRoot = root;
  } // Layers for progressive rendering


  this._progressiveLayers = [];
  /**
   * @type {module:zrender/Layer}
   * @private
   */

  this._hoverlayer;
  this._hoverElements = [];
};

Painter.prototype = {
  constructor: Painter,
  getType: function () {
    return 'canvas';
  },

  /**
   * If painter use a single canvas
   * @return {boolean}
   */
  isSingleCanvas: function () {
    return this._singleCanvas;
  },

  /**
   * @return {HTMLDivElement}
   */
  getViewportRoot: function () {
    return this._domRoot;
  },
  getViewportRootOffset: function () {
    var viewportRoot = this.getViewportRoot();

    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  },

  /**
   * 刷新
   * @param {boolean} [paintAll=false] 强制绘制所有displayable
   */
  refresh: function (paintAll) {
    var list = this.storage.getDisplayList(true);
    var zlevelList = this._zlevelList;

    this._paintList(list, paintAll); // Paint custum layers


    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];

      if (!layer.__builtin__ && layer.refresh) {
        layer.refresh();
      }
    }

    this.refreshHover();

    if (this._progressiveLayers.length) {
      this._startProgessive();
    }

    return this;
  },
  addHover: function (el, hoverStyle) {
    if (el.__hoverMir) {
      return;
    }

    var elMirror = new el.constructor({
      style: el.style,
      shape: el.shape
    });
    elMirror.__from = el;
    el.__hoverMir = elMirror;
    elMirror.setStyle(hoverStyle);

    this._hoverElements.push(elMirror);
  },
  removeHover: function (el) {
    var elMirror = el.__hoverMir;
    var hoverElements = this._hoverElements;
    var idx = util.indexOf(hoverElements, elMirror);

    if (idx >= 0) {
      hoverElements.splice(idx, 1);
    }

    el.__hoverMir = null;
  },
  clearHover: function (el) {
    var hoverElements = this._hoverElements;

    for (var i = 0; i < hoverElements.length; i++) {
      var from = hoverElements[i].__from;

      if (from) {
        from.__hoverMir = null;
      }
    }

    hoverElements.length = 0;
  },
  refreshHover: function () {
    var hoverElements = this._hoverElements;
    var len = hoverElements.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();

    if (!len) {
      return;
    }

    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
    // FIXME?

    if (!hoverLayer) {
      hoverLayer = this._hoverlayer = this.getLayer(1e5);
    }

    var scope = {};
    hoverLayer.ctx.save();

    for (var i = 0; i < len;) {
      var el = hoverElements[i];
      var originalEl = el.__from; // Original el is removed
      // PENDING

      if (!(originalEl && originalEl.__zr)) {
        hoverElements.splice(i, 1);
        originalEl.__hoverMir = null;
        len--;
        continue;
      }

      i++; // Use transform
      // FIXME style and shape ?

      if (!originalEl.invisible) {
        el.transform = originalEl.transform;
        el.invTransform = originalEl.invTransform;
        el.__clipPaths = originalEl.__clipPaths; // el.

        this._doPaintEl(el, hoverLayer, true, scope);
      }
    }

    hoverLayer.ctx.restore();
  },
  _startProgessive: function () {
    var self = this;

    if (!self._furtherProgressive) {
      return;
    } // Use a token to stop progress steps triggered by
    // previous zr.refresh calling.


    var token = self._progressiveToken = +new Date();
    self._progress++;
    requestAnimationFrame(step);

    function step() {
      // In case refreshed or disposed
      if (token === self._progressiveToken && self.storage) {
        self._doPaintList(self.storage.getDisplayList());

        if (self._furtherProgressive) {
          self._progress++;
          requestAnimationFrame(step);
        } else {
          self._progressiveToken = -1;
        }
      }
    }
  },
  _clearProgressive: function () {
    this._progressiveToken = -1;
    this._progress = 0;
    util.each(this._progressiveLayers, function (layer) {
      layer.__dirty && layer.clear();
    });
  },
  _paintList: function (list, paintAll) {
    if (paintAll == null) {
      paintAll = false;
    }

    this._updateLayerStatus(list);

    this._clearProgressive();

    this.eachBuiltinLayer(preProcessLayer);

    this._doPaintList(list, paintAll);

    this.eachBuiltinLayer(postProcessLayer);
  },
  _doPaintList: function (list, paintAll) {
    var currentLayer;
    var currentZLevel;
    var ctx; // var invTransform = [];

    var scope;
    var progressiveLayerIdx = 0;
    var currentProgressiveLayer;
    var width = this._width;
    var height = this._height;
    var layerProgress;
    var frame = this._progress;

    function flushProgressiveLayer(layer) {
      var dpr = ctx.dpr || 1;
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame

      currentLayer.__dirty = true;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
      ctx.restore();
    }

    for (var i = 0, l = list.length; i < l; i++) {
      var el = list[i];
      var elZLevel = this._singleCanvas ? 0 : el.zlevel;
      var elFrame = el.__frame; // Flush at current context
      // PENDING

      if (elFrame < 0 && currentProgressiveLayer) {
        flushProgressiveLayer(currentProgressiveLayer);
        currentProgressiveLayer = null;
      } // Change draw layer


      if (currentZLevel !== elZLevel) {
        if (ctx) {
          ctx.restore();
        } // Reset scope


        scope = {}; // Only 0 zlevel if only has one canvas

        currentZLevel = elZLevel;
        currentLayer = this.getLayer(currentZLevel);

        if (!currentLayer.__builtin__) {
          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
        }

        ctx = currentLayer.ctx;
        ctx.save(); // Reset the count

        currentLayer.__unusedCount = 0;

        if (currentLayer.__dirty || paintAll) {
          currentLayer.clear();
        }
      }

      if (!(currentLayer.__dirty || paintAll)) {
        continue;
      }

      if (elFrame >= 0) {
        // Progressive layer changed
        if (!currentProgressiveLayer) {
          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];
          currentProgressiveLayer.ctx.save();
          currentProgressiveLayer.renderScope = {};

          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {
            // flushProgressiveLayer(currentProgressiveLayer);
            // Quick jump all progressive elements
            // All progressive element are not dirty, jump over and flush directly
            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;

            continue;
          }

          layerProgress = currentProgressiveLayer.__progress;

          if (!currentProgressiveLayer.__dirty) {
            // Keep rendering
            frame = layerProgress;
          }

          currentProgressiveLayer.__progress = frame + 1;
        }

        if (elFrame === frame) {
          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
        }
      } else {
        this._doPaintEl(el, currentLayer, paintAll, scope);
      }

      el.__dirty = false;
    }

    if (currentProgressiveLayer) {
      flushProgressiveLayer(currentProgressiveLayer);
    } // Restore the lastLayer ctx


    ctx && ctx.restore(); // If still has clipping state
    // if (scope.prevElClipPaths) {
    //     ctx.restore();
    // }

    this._furtherProgressive = false;
    util.each(this._progressiveLayers, function (layer) {
      if (layer.__maxProgress >= layer.__progress) {
        this._furtherProgressive = true;
      }
    }, this);
  },
  _doPaintEl: function (el, currentLayer, forcePaint, scope) {
    var ctx = currentLayer.ctx;
    var m = el.transform;

    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
    !el.invisible // Ignore transparent element
    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
    // Draw a scale 0 element can cause all following draw wrong
    // And setTransform with scale 0 will cause set back transform failed.
    && !(m && !m[0] && !m[3]) // Ignore culled element
    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements

      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
        // If has previous clipping state, restore from it
        if (scope.prevElClipPaths) {
          scope.prevClipLayer.ctx.restore();
          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored

          scope.prevEl = null;
        } // New clipping state


        if (clipPaths) {
          ctx.save();
          doClip(clipPaths, ctx);
          scope.prevClipLayer = currentLayer;
          scope.prevElClipPaths = clipPaths;
        }
      }

      el.beforeBrush && el.beforeBrush(ctx);
      el.brush(ctx, scope.prevEl || null);
      scope.prevEl = el;
      el.afterBrush && el.afterBrush(ctx);
    }
  },

  /**
   * 获取 zlevel 所在层，如果不存在则会创建一个新的层
   * @param {number} zlevel
   * @return {module:zrender/Layer}
   */
  getLayer: function (zlevel) {
    if (this._singleCanvas) {
      return this._layers[0];
    }

    var layer = this._layers[zlevel];

    if (!layer) {
      // Create a new layer
      layer = new Layer('zr_' + zlevel, this, this.dpr);
      layer.__builtin__ = true;

      if (this._layerConfig[zlevel]) {
        util.merge(layer, this._layerConfig[zlevel], true);
      }

      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
      // Or excanvas will get 0px clientWidth and clientHeight

      layer.initContext();
    }

    return layer;
  },
  insertLayer: function (zlevel, layer) {
    var layersMap = this._layers;
    var zlevelList = this._zlevelList;
    var len = zlevelList.length;
    var prevLayer = null;
    var i = -1;
    var domRoot = this._domRoot;

    if (layersMap[zlevel]) {
      log('ZLevel ' + zlevel + ' has been used already');
      return;
    } // Check if is a valid layer


    if (!isLayerValid(layer)) {
      log('Layer of zlevel ' + zlevel + ' is not valid');
      return;
    }

    if (len > 0 && zlevel > zlevelList[0]) {
      for (i = 0; i < len - 1; i++) {
        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
          break;
        }
      }

      prevLayer = layersMap[zlevelList[i]];
    }

    zlevelList.splice(i + 1, 0, zlevel);
    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
    // (It can be a WebGL layer and assigned to a ZImage element)
    // But it still under management of zrender.

    if (!layer.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;

        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
  },
  // Iterate each layer
  eachLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  },
  // Iterate each buildin layer
  eachBuiltinLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var layer;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      layer = this._layers[z];

      if (layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },
  // Iterate each other layer except buildin layer
  eachOtherLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var layer;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      layer = this._layers[z];

      if (!layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },

  /**
   * 获取所有已创建的层
   * @param {Array.<module:zrender/Layer>} [prevLayer]
   */
  getLayers: function () {
    return this._layers;
  },
  _updateLayerStatus: function (list) {
    var layers = this._layers;
    var progressiveLayers = this._progressiveLayers;
    var elCountsLastFrame = {};
    var progressiveElCountsLastFrame = {};
    this.eachBuiltinLayer(function (layer, z) {
      elCountsLastFrame[z] = layer.elCount;
      layer.elCount = 0;
      layer.__dirty = false;
    });
    util.each(progressiveLayers, function (layer, idx) {
      progressiveElCountsLastFrame[idx] = layer.elCount;
      layer.elCount = 0;
      layer.__dirty = false;
    });
    var progressiveLayerCount = 0;
    var currentProgressiveLayer;
    var lastProgressiveKey;
    var frameCount = 0;

    for (var i = 0, l = list.length; i < l; i++) {
      var el = list[i];
      var zlevel = this._singleCanvas ? 0 : el.zlevel;
      var layer = layers[zlevel];
      var elProgress = el.progressive;

      if (layer) {
        layer.elCount++;
        layer.__dirty = layer.__dirty || el.__dirty;
      } /////// Update progressive


      if (elProgress >= 0) {
        // Fix wrong progressive sequence problem.
        if (lastProgressiveKey !== elProgress) {
          lastProgressiveKey = elProgress;
          frameCount++;
        }

        var elFrame = el.__frame = frameCount - 1;

        if (!currentProgressiveLayer) {
          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
          currentProgressiveLayer = progressiveLayers[idx];

          if (!currentProgressiveLayer) {
            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);
            currentProgressiveLayer.initContext();
          }

          currentProgressiveLayer.__maxProgress = 0;
        }

        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
        currentProgressiveLayer.elCount++;
        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);

        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
          // Should keep rendering this  layer because progressive rendering is not finished yet
          layer.__dirty = true;
        }
      } else {
        el.__frame = -1;

        if (currentProgressiveLayer) {
          currentProgressiveLayer.__nextIdxNotProg = i;
          progressiveLayerCount++;
          currentProgressiveLayer = null;
        }
      }
    }

    if (currentProgressiveLayer) {
      progressiveLayerCount++;
      currentProgressiveLayer.__nextIdxNotProg = i;
    } // 层中的元素数量有发生变化


    this.eachBuiltinLayer(function (layer, z) {
      if (elCountsLastFrame[z] !== layer.elCount) {
        layer.__dirty = true;
      }
    });
    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
    util.each(progressiveLayers, function (layer, idx) {
      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
        el.__dirty = true;
      }

      if (layer.__dirty) {
        layer.__progress = 0;
      }
    });
  },

  /**
   * 清除hover层外所有内容
   */
  clear: function () {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  },
  _clearLayer: function (layer) {
    layer.clear();
  },

  /**
   * 修改指定zlevel的绘制参数
   *
   * @param {string} zlevel
   * @param {Object} config 配置对象
   * @param {string} [config.clearColor=0] 每次清空画布的颜色
   * @param {string} [config.motionBlur=false] 是否开启动态模糊
   * @param {number} [config.lastFrameAlpha=0.7]
   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
   */
  configLayer: function (zlevel, config) {
    if (config) {
      var layerConfig = this._layerConfig;

      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config;
      } else {
        util.merge(layerConfig[zlevel], config, true);
      }

      var layer = this._layers[zlevel];

      if (layer) {
        util.merge(layer, layerConfig[zlevel], true);
      }
    }
  },

  /**
   * 删除指定层
   * @param {number} zlevel 层所在的zlevel
   */
  delLayer: function (zlevel) {
    var layers = this._layers;
    var zlevelList = this._zlevelList;
    var layer = layers[zlevel];

    if (!layer) {
      return;
    }

    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
  },

  /**
   * 区域大小变化后重绘
   */
  resize: function (width, height) {
    var domRoot = this._domRoot; // FIXME Why ?

    domRoot.style.display = 'none'; // Save input w/h

    var opts = this._opts;
    width != null && (opts.width = width);
    height != null && (opts.height = height);
    width = this._getSize(0);
    height = this._getSize(1);
    domRoot.style.display = ''; // 优化没有实际改变的resize

    if (this._width != width || height != this._height) {
      domRoot.style.width = width + 'px';
      domRoot.style.height = height + 'px';

      for (var id in this._layers) {
        if (this._layers.hasOwnProperty(id)) {
          this._layers[id].resize(width, height);
        }
      }

      util.each(this._progressiveLayers, function (layer) {
        layer.resize(width, height);
      });
      this.refresh(true);
    }

    this._width = width;
    this._height = height;
    return this;
  },

  /**
   * 清除单独的一个层
   * @param {number} zlevel
   */
  clearLayer: function (zlevel) {
    var layer = this._layers[zlevel];

    if (layer) {
      layer.clear();
    }
  },

  /**
   * 释放
   */
  dispose: function () {
    this.root.innerHTML = '';
    this.root = this.storage = this._domRoot = this._layers = null;
  },

  /**
   * Get canvas which has all thing rendered
   * @param {Object} opts
   * @param {string} [opts.backgroundColor]
   * @param {number} [opts.pixelRatio]
   */
  getRenderedCanvas: function (opts) {
    opts = opts || {};

    if (this._singleCanvas) {
      return this._layers[0].dom;
    }

    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clearColor = opts.backgroundColor;
    imageLayer.clear();
    var displayList = this.storage.getDisplayList(true);
    var scope = {};
    var zlevel;
    var self = this;

    function findAndDrawOtherLayer(smaller, larger) {
      var zlevelList = self._zlevelList;

      if (smaller == null) {
        smaller = -Infinity;
      }

      var intermediateLayer;

      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        var layer = self._layers[z];

        if (!layer.__builtin__ && z > smaller && z < larger) {
          intermediateLayer = layer;
          break;
        }
      }

      if (intermediateLayer && intermediateLayer.renderToCanvas) {
        imageLayer.ctx.save();
        intermediateLayer.renderToCanvas(imageLayer.ctx);
        imageLayer.ctx.restore();
      }
    }

    for (var i = 0; i < displayList.length; i++) {
      var el = displayList[i];

      if (el.zlevel !== zlevel) {
        findAndDrawOtherLayer(zlevel, el.zlevel);
        zlevel = el.zlevel;
      }

      this._doPaintEl(el, imageLayer, true, scope);
    }

    findAndDrawOtherLayer(zlevel, Infinity);
    return imageLayer.dom;
  },

  /**
   * 获取绘图区域宽度
   */
  getWidth: function () {
    return this._width;
  },

  /**
   * 获取绘图区域高度
   */
  getHeight: function () {
    return this._height;
  },
  _getSize: function (whIdx) {
    var opts = this._opts;
    var wh = ['width', 'height'][whIdx];
    var cwh = ['clientWidth', 'clientHeight'][whIdx];
    var plt = ['paddingLeft', 'paddingTop'][whIdx];
    var prb = ['paddingRight', 'paddingBottom'][whIdx];

    if (opts[wh] != null && opts[wh] !== 'auto') {
      return parseFloat(opts[wh]);
    }

    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.

    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
  },
  pathToImage: function (path, dpr) {
    dpr = dpr || this.dpr;
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var rect = path.getBoundingRect();
    var style = path.style;
    var shadowBlurSize = style.shadowBlur;
    var shadowOffsetX = style.shadowOffsetX;
    var shadowOffsetY = style.shadowOffsetY;
    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
    var width = rect.width + leftMargin + rightMargin;
    var height = rect.height + topMargin + bottomMargin;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, width, height);
    ctx.dpr = dpr;
    var pathTransform = {
      position: path.position,
      rotation: path.rotation,
      scale: path.scale
    };
    path.position = [leftMargin - rect.x, topMargin - rect.y];
    path.rotation = 0;
    path.scale = [1, 1];
    path.updateTransform();

    if (path) {
      path.brush(ctx);
    }

    var ImageShape = Image;
    var imgShape = new ImageShape({
      style: {
        x: 0,
        y: 0,
        image: canvas
      }
    });

    if (pathTransform.position != null) {
      imgShape.position = path.position = pathTransform.position;
    }

    if (pathTransform.rotation != null) {
      imgShape.rotation = path.rotation = pathTransform.rotation;
    }

    if (pathTransform.scale != null) {
      imgShape.scale = path.scale = pathTransform.scale;
    }

    return imgShape;
  }
};
var _default = Painter;
module.exports = _default;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(91);

var _config = __webpack_require__(120);

var devicePixelRatio = _config.devicePixelRatio;

var Style = __webpack_require__(145);

var Pattern = __webpack_require__(146);

/**
 * @module zrender/Layer
 * @author pissang(https://www.github.com/pissang)
 */
function returnFalse() {
  return false;
}
/**
 * 创建dom
 *
 * @inner
 * @param {string} id dom id 待用
 * @param {Painter} painter painter instance
 * @param {number} number
 */


function createDom(id, painter, dpr) {
  var newDom = util.createCanvas();
  var width = painter.getWidth();
  var height = painter.getHeight();
  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~

  newDomStyle.position = 'absolute';
  newDomStyle.left = 0;
  newDomStyle.top = 0;
  newDomStyle.width = width + 'px';
  newDomStyle.height = height + 'px';
  newDom.width = width * dpr;
  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性

  newDom.setAttribute('data-zr-dom-id', id);
  return newDom;
}
/**
 * @alias module:zrender/Layer
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @param {string} id
 * @param {module:zrender/Painter} painter
 * @param {number} [dpr]
 */


var Layer = function (id, painter, dpr) {
  var dom;
  dpr = dpr || devicePixelRatio;

  if (typeof id === 'string') {
    dom = createDom(id, painter, dpr);
  } // Not using isDom because in node it will return false
  else if (util.isObject(id)) {
      dom = id;
      id = dom.id;
    }

  this.id = id;
  this.dom = dom;
  var domStyle = dom.style;

  if (domStyle) {
    // Not in node
    dom.onselectstart = returnFalse; // 避免页面选中的尴尬

    domStyle['-webkit-user-select'] = 'none';
    domStyle['user-select'] = 'none';
    domStyle['-webkit-touch-callout'] = 'none';
    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
    domStyle['padding'] = 0;
    domStyle['margin'] = 0;
    domStyle['border-width'] = 0;
  }

  this.domBack = null;
  this.ctxBack = null;
  this.painter = painter;
  this.config = null; // Configs

  /**
   * 每次清空画布的颜色
   * @type {string}
   * @default 0
   */

  this.clearColor = 0;
  /**
   * 是否开启动态模糊
   * @type {boolean}
   * @default false
   */

  this.motionBlur = false;
  /**
   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
   * @type {number}
   * @default 0.7
   */

  this.lastFrameAlpha = 0.7;
  /**
   * Layer dpr
   * @type {number}
   */

  this.dpr = dpr;
};

Layer.prototype = {
  constructor: Layer,
  elCount: 0,
  __dirty: true,
  initContext: function () {
    this.ctx = this.dom.getContext('2d');
    this.ctx.__currentValues = {};
    this.ctx.dpr = this.dpr;
  },
  createBackBuffer: function () {
    var dpr = this.dpr;
    this.domBack = createDom('back-' + this.id, this.painter, dpr);
    this.ctxBack = this.domBack.getContext('2d');
    this.ctxBack.__currentValues = {};

    if (dpr != 1) {
      this.ctxBack.scale(dpr, dpr);
    }
  },

  /**
   * @param  {number} width
   * @param  {number} height
   */
  resize: function (width, height) {
    var dpr = this.dpr;
    var dom = this.dom;
    var domStyle = dom.style;
    var domBack = this.domBack;
    domStyle.width = width + 'px';
    domStyle.height = height + 'px';
    dom.width = width * dpr;
    dom.height = height * dpr;

    if (domBack) {
      domBack.width = width * dpr;
      domBack.height = height * dpr;

      if (dpr != 1) {
        this.ctxBack.scale(dpr, dpr);
      }
    }
  },

  /**
   * 清空该层画布
   * @param {boolean} clearAll Clear all with out motion blur
   */
  clear: function (clearAll) {
    var dom = this.dom;
    var ctx = this.ctx;
    var width = dom.width;
    var height = dom.height;
    var clearColor = this.clearColor;
    var haveMotionBLur = this.motionBlur && !clearAll;
    var lastFrameAlpha = this.lastFrameAlpha;
    var dpr = this.dpr;

    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }

      this.ctxBack.globalCompositeOperation = 'copy';
      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
    }

    ctx.clearRect(0, 0, width, height);

    if (clearColor) {
      var clearColorGradientOrPattern; // Gradient

      if (clearColor.colorStops) {
        // Cache canvas gradient
        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
          x: 0,
          y: 0,
          width: width,
          height: height
        });
        clearColor.__canvasGradient = clearColorGradientOrPattern;
      } // Pattern
      else if (clearColor.image) {
          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
        }

      ctx.save();
      ctx.fillStyle = clearColorGradientOrPattern || clearColor;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    }

    if (haveMotionBLur) {
      var domBack = this.domBack;
      ctx.save();
      ctx.globalAlpha = lastFrameAlpha;
      ctx.drawImage(domBack, 0, 0, width, height);
      ctx.restore();
    }
  }
};
var _default = Layer;
module.exports = _default;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var textHelper = __webpack_require__(149);

var BoundingRect = __webpack_require__(101);

/**
 * Mixin for drawing text in a element bounding rect
 * @module zrender/mixin/RectText
 */
var tmpRect = new BoundingRect();

var RectText = function () {};

RectText.prototype = {
  constructor: RectText,

  /**
   * Draw text in a rect with specified position.
   * @param  {CanvasRenderingContext2D} ctx
   * @param  {Object} rect Displayable rect
   */
  drawRectText: function (ctx, rect) {
    var style = this.style;
    rect = style.textRect || rect; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true);
    var text = style.text; // Convert to string

    text != null && (text += '');

    if (!textHelper.needDrawText(text, style)) {
      return;
    } // FIXME


    ctx.save(); // Transform rect to view space

    var transform = this.transform;

    if (!style.transformText) {
      if (transform) {
        tmpRect.copy(rect);
        tmpRect.applyTransform(transform);
        rect = tmpRect;
      }
    } else {
      this.setTransform(ctx);
    } // transformText and textRotation can not be used at the same time.


    textHelper.renderText(this, ctx, text, style, rect);
    ctx.restore();
  }
};
var _default = RectText;
module.exports = _default;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(91);

var _event = __webpack_require__(106);

var Dispatcher = _event.Dispatcher;

var requestAnimationFrame = __webpack_require__(147);

var Animator = __webpack_require__(142);

/**
 * 动画主类, 调度和管理所有动画控制器
 *
 * @module zrender/animation/Animation
 * @author pissang(https://github.com/pissang)
 */
// TODO Additive animation
// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
// https://developer.apple.com/videos/wwdc2014/#236

/**
 * @typedef {Object} IZRenderStage
 * @property {Function} update
 */

/**
 * @alias module:zrender/animation/Animation
 * @constructor
 * @param {Object} [options]
 * @param {Function} [options.onframe]
 * @param {IZRenderStage} [options.stage]
 * @example
 *     var animation = new Animation();
 *     var obj = {
 *         x: 100,
 *         y: 100
 *     };
 *     animation.animate(node.position)
 *         .when(1000, {
 *             x: 500,
 *             y: 500
 *         })
 *         .when(2000, {
 *             x: 100,
 *             y: 100
 *         })
 *         .start('spline');
 */
var Animation = function (options) {
  options = options || {};
  this.stage = options.stage || {};

  this.onframe = options.onframe || function () {}; // private properties


  this._clips = [];
  this._running = false;
  this._time;
  this._pausedTime;
  this._pauseStart;
  this._paused = false;
  Dispatcher.call(this);
};

Animation.prototype = {
  constructor: Animation,

  /**
   * 添加 clip
   * @param {module:zrender/animation/Clip} clip
   */
  addClip: function (clip) {
    this._clips.push(clip);
  },

  /**
   * 添加 animator
   * @param {module:zrender/animation/Animator} animator
   */
  addAnimator: function (animator) {
    animator.animation = this;
    var clips = animator.getClips();

    for (var i = 0; i < clips.length; i++) {
      this.addClip(clips[i]);
    }
  },

  /**
   * 删除动画片段
   * @param {module:zrender/animation/Clip} clip
   */
  removeClip: function (clip) {
    var idx = util.indexOf(this._clips, clip);

    if (idx >= 0) {
      this._clips.splice(idx, 1);
    }
  },

  /**
   * 删除动画片段
   * @param {module:zrender/animation/Animator} animator
   */
  removeAnimator: function (animator) {
    var clips = animator.getClips();

    for (var i = 0; i < clips.length; i++) {
      this.removeClip(clips[i]);
    }

    animator.animation = null;
  },
  _update: function () {
    var time = new Date().getTime() - this._pausedTime;

    var delta = time - this._time;
    var clips = this._clips;
    var len = clips.length;
    var deferredEvents = [];
    var deferredClips = [];

    for (var i = 0; i < len; i++) {
      var clip = clips[i];
      var e = clip.step(time, delta); // Throw out the events need to be called after
      // stage.update, like destroy

      if (e) {
        deferredEvents.push(e);
        deferredClips.push(clip);
      }
    } // Remove the finished clip


    for (var i = 0; i < len;) {
      if (clips[i]._needsRemove) {
        clips[i] = clips[len - 1];
        clips.pop();
        len--;
      } else {
        i++;
      }
    }

    len = deferredEvents.length;

    for (var i = 0; i < len; i++) {
      deferredClips[i].fire(deferredEvents[i]);
    }

    this._time = time;
    this.onframe(delta);
    this.trigger('frame', delta);

    if (this.stage.update) {
      this.stage.update();
    }
  },
  _startLoop: function () {
    var self = this;
    this._running = true;

    function step() {
      if (self._running) {
        requestAnimationFrame(step);
        !self._paused && self._update();
      }
    }

    requestAnimationFrame(step);
  },

  /**
   * 开始运行动画
   */
  start: function () {
    this._time = new Date().getTime();
    this._pausedTime = 0;

    this._startLoop();
  },

  /**
   * 停止运行动画
   */
  stop: function () {
    this._running = false;
  },

  /**
   * Pause
   */
  pause: function () {
    if (!this._paused) {
      this._pauseStart = new Date().getTime();
      this._paused = true;
    }
  },

  /**
   * Resume
   */
  resume: function () {
    if (this._paused) {
      this._pausedTime += new Date().getTime() - this._pauseStart;
      this._paused = false;
    }
  },

  /**
   * 清除所有动画片段
   */
  clear: function () {
    this._clips = [];
  },

  /**
   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
   * @param  {Object} target
   * @param  {Object} options
   * @param  {boolean} [options.loop=false] 是否循环播放动画
   * @param  {Function} [options.getter=null]
   *         如果指定getter函数，会通过getter函数取属性值
   * @param  {Function} [options.setter=null]
   *         如果指定setter函数，会通过setter函数设置属性值
   * @return {module:zrender/animation/Animation~Animator}
   */
  // TODO Gap
  animate: function (target, options) {
    options = options || {};
    var animator = new Animator(target, options.loop, options.getter, options.setter);
    this.addAnimator(animator);
    return animator;
  }
};
util.mixin(Animation, Dispatcher);
var _default = Animation;
module.exports = _default;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var _event = __webpack_require__(106);

var addEventListener = _event.addEventListener;
var removeEventListener = _event.removeEventListener;
var normalizeEvent = _event.normalizeEvent;

var zrUtil = __webpack_require__(91);

var Eventful = __webpack_require__(107);

var env = __webpack_require__(98);

var GestureMgr = __webpack_require__(196);

var TOUCH_CLICK_DELAY = 300;
var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
var pointerEventNames = {
  pointerdown: 1,
  pointerup: 1,
  pointermove: 1,
  pointerout: 1
};
var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
  var nm = name.replace('mouse', 'pointer');
  return pointerEventNames[nm] ? nm : name;
});

function eventNameFix(name) {
  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;
}

function processGesture(proxy, event, stage) {
  var gestureMgr = proxy._gestureMgr;
  stage === 'start' && gestureMgr.clear();
  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);
  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.

  if (gestureInfo) {
    var type = gestureInfo.type;
    event.gestureEvent = type;
    proxy.handler.dispatchToElement({
      target: gestureInfo.target
    }, type, gestureInfo.event);
  }
} // function onMSGestureChange(proxy, event) {
//     if (event.translationX || event.translationY) {
//         // mousemove is carried by MSGesture to reduce the sensitivity.
//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
//     }
//     if (event.scale !== 1) {
//         event.pinchX = event.offsetX;
//         event.pinchY = event.offsetY;
//         event.pinchScale = event.scale;
//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
//     }
// }

/**
 * Prevent mouse event from being dispatched after Touch Events action
 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
 * Result: Blocking Mouse Events for 700ms.
 */


function setTouchTimer(instance) {
  instance._touching = true;
  clearTimeout(instance._touchTimer);
  instance._touchTimer = setTimeout(function () {
    instance._touching = false;
  }, 700);
}

var domHandlers = {
  /**
   * Mouse move handler
   * @inner
   * @param {Event} event
   */
  mousemove: function (event) {
    event = normalizeEvent(this.dom, event);
    this.trigger('mousemove', event);
  },

  /**
   * Mouse out handler
   * @inner
   * @param {Event} event
   */
  mouseout: function (event) {
    event = normalizeEvent(this.dom, event);
    var element = event.toElement || event.relatedTarget;

    if (element != this.dom) {
      while (element && element.nodeType != 9) {
        // 忽略包含在root中的dom引起的mouseOut
        if (element === this.dom) {
          return;
        }

        element = element.parentNode;
      }
    }

    this.trigger('mouseout', event);
  },

  /**
   * Touch开始响应函数
   * @inner
   * @param {Event} event
   */
  touchstart: function (event) {
    // Default mouse behaviour should not be disabled here.
    // For example, page may needs to be slided.
    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
    // mouse event in upper applicatoin.

    event.zrByTouch = true;
    this._lastTouchMoment = new Date();
    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should
    // be triggered, and must before `mousedown` triggered.

    domHandlers.mousemove.call(this, event);
    domHandlers.mousedown.call(this, event);
    setTouchTimer(this);
  },

  /**
   * Touch移动响应函数
   * @inner
   * @param {Event} event
   */
  touchmove: function (event) {
    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
    // mouse event in upper applicatoin.

    event.zrByTouch = true;
    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether
    // there is gestrue event, because mouse move and pinch may
    // be used at the same time.

    domHandlers.mousemove.call(this, event);
    setTouchTimer(this);
  },

  /**
   * Touch结束响应函数
   * @inner
   * @param {Event} event
   */
  touchend: function (event) {
    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
    // mouse event in upper applicatoin.

    event.zrByTouch = true;
    processGesture(this, event, 'end');
    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
    // we can conveniently implement "hover style" in both PC and touch device just
    // by listening to `mouseover` to add "hover style" and listening to `mouseout`
    // to remove "hover style" on an element, without any additional code for
    // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
    // style" will remain for user view)
    // click event should always be triggered no matter whether
    // there is gestrue event. System click can not be prevented.

    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
      domHandlers.click.call(this, event);
    }

    setTouchTimer(this);
  },
  pointerdown: function (event) {
    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
    //     this._msGesture.addPointer(event.pointerId);
    // }
  },
  pointermove: function (event) {
    // FIXME
    // pointermove is so sensitive that it always triggered when
    // tap(click) on touch screen, which affect some judgement in
    // upper application. So, we dont support mousemove on MS touch
    // device yet.
    if (!isPointerFromTouch(event)) {
      domHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function (event) {
    domHandlers.mouseup.call(this, event);
  },
  pointerout: function (event) {
    // pointerout will be triggered when tap on touch screen
    // (IE11+/Edge on MS Surface) after click event triggered,
    // which is inconsistent with the mousout behavior we defined
    // in touchend. So we unify them.
    // (check domHandlers.touchend for detailed explanation)
    if (!isPointerFromTouch(event)) {
      domHandlers.mouseout.call(this, event);
    }
  }
};

function isPointerFromTouch(event) {
  var pointerType = event.pointerType;
  return pointerType === 'pen' || pointerType === 'touch';
} // function useMSGuesture(handlerProxy, event) {
//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
// }
// Common handlers


zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
  domHandlers[name] = function (event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name, event);
  };
});
/**
 * 为控制类实例初始化dom 事件处理函数
 *
 * @inner
 * @param {module:zrender/Handler} instance 控制类实例
 */

function initDomHandler(instance) {
  zrUtil.each(touchHandlerNames, function (name) {
    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
  });
  zrUtil.each(pointerHandlerNames, function (name) {
    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
  });
  zrUtil.each(mouseHandlerNames, function (name) {
    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
  });

  function makeMouseHandler(fn, instance) {
    return function () {
      if (instance._touching) {
        return;
      }

      return fn.apply(instance, arguments);
    };
  }
}

function HandlerDomProxy(dom) {
  Eventful.call(this);
  this.dom = dom;
  /**
   * @private
   * @type {boolean}
   */

  this._touching = false;
  /**
   * @private
   * @type {number}
   */

  this._touchTimer;
  /**
   * @private
   * @type {module:zrender/core/GestureMgr}
   */

  this._gestureMgr = new GestureMgr();
  this._handlers = {};
  initDomHandler(this);

  if (env.pointerEventsSupported) {
    // Only IE11+/Edge
    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
    // at the same time.
    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
    // screen, which do not occurs in pointer event.
    // So we use pointer event to both detect touch gesture and mouse behavior.
    mountHandlers(pointerHandlerNames, this); // FIXME
    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
    // which does not prevent defuault behavior occasionally (which may cause view port
    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
    // So we have to not to use MSGesture and not to support touchmove and pinch on MS
    // touch screen. And we only support click behavior on MS touch screen now.
    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
    // We dont support touch on IE on win7.
    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
    // if (typeof MSGesture === 'function') {
    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
    //     dom.addEventListener('MSGestureChange', onMSGestureChange);
    // }
  } else {
    if (env.touchEventsSupported) {
      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
      // addEventListener(root, 'mouseout', this._mouseoutHandler);
    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
    // mouse event can not be handle in those devices.
    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
    // mouseevent after touch event triggered, see `setTouchTimer`.


    mountHandlers(mouseHandlerNames, this);
  }

  function mountHandlers(handlerNames, instance) {
    zrUtil.each(handlerNames, function (name) {
      addEventListener(dom, eventNameFix(name), instance._handlers[name]);
    }, instance);
  }
}

var handlerDomProxyProto = HandlerDomProxy.prototype;

handlerDomProxyProto.dispose = function () {
  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);

  for (var i = 0; i < handlerNames.length; i++) {
    var name = handlerNames[i];
    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
  }
};

handlerDomProxyProto.setCursor = function (cursorStyle) {
  this.dom.style.cursor = cursorStyle || 'default';
};

zrUtil.mixin(HandlerDomProxy, Eventful);
var _default = HandlerDomProxy;
module.exports = _default;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var eventUtil = __webpack_require__(106);

/**
 * Only implements needed gestures for mobile.
 */
var GestureMgr = function () {
  /**
   * @private
   * @type {Array.<Object>}
   */
  this._track = [];
};

GestureMgr.prototype = {
  constructor: GestureMgr,
  recognize: function (event, target, root) {
    this._doTrack(event, target, root);

    return this._recognize(event);
  },
  clear: function () {
    this._track.length = 0;
    return this;
  },
  _doTrack: function (event, target, root) {
    var touches = event.touches;

    if (!touches) {
      return;
    }

    var trackItem = {
      points: [],
      touches: [],
      target: target,
      event: event
    };

    for (var i = 0, len = touches.length; i < len; i++) {
      var touch = touches[i];
      var pos = eventUtil.clientToLocal(root, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }

    this._track.push(trackItem);
  },
  _recognize: function (event) {
    for (var eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        var gestureInfo = recognizers[eventName](this._track, event);

        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  }
};

function dist(pointPair) {
  var dx = pointPair[1][0] - pointPair[0][0];
  var dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}

function center(pointPair) {
  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
}

var recognizers = {
  pinch: function (track, event) {
    var trackLen = track.length;

    if (!trackLen) {
      return;
    }

    var pinchEnd = (track[trackLen - 1] || {}).points;
    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;

    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      var pinchScale = dist(pinchEnd) / dist(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      var pinchCenter = center(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: 'pinch',
        target: track[0].target,
        event: event
      };
    }
  } // Only pinch currently.

};
var _default = GestureMgr;
module.exports = _default;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__(91);

var modelUtil = __webpack_require__(95);

var Model = __webpack_require__(102);

var ComponentModel = __webpack_require__(105);

var globalDefault = __webpack_require__(225);

var colorPaletteMinin = __webpack_require__(156);

/**
 * ECharts global model
 *
 * @module {echarts/model/Global}
 */

/**
 * Caution: If the mechanism should be changed some day, these cases
 * should be considered:
 *
 * (1) In `merge option` mode, if using the same option to call `setOption`
 * many times, the result should be the same (try our best to ensure that).
 * (2) In `merge option` mode, if a component has no id/name specified, it
 * will be merged by index, and the result sequence of the components is
 * consistent to the original sequence.
 * (3) `reset` feature (in toolbox). Find detailed info in comments about
 * `mergeOption` in module:echarts/model/OptionManager.
 */
var each = zrUtil.each;
var filter = zrUtil.filter;
var map = zrUtil.map;
var isArray = zrUtil.isArray;
var indexOf = zrUtil.indexOf;
var isObject = zrUtil.isObject;
var OPTION_INNER_KEY = '\0_ec_inner';
/**
 * @alias module:echarts/model/Global
 *
 * @param {Object} option
 * @param {module:echarts/model/Model} parentModel
 * @param {Object} theme
 */

var GlobalModel = Model.extend({
  constructor: GlobalModel,
  init: function (option, parentModel, theme, optionManager) {
    theme = theme || {};
    this.option = null; // Mark as not initialized.

    /**
     * @type {module:echarts/model/Model}
     * @private
     */

    this._theme = new Model(theme);
    /**
     * @type {module:echarts/model/OptionManager}
     */

    this._optionManager = optionManager;
  },
  setOption: function (option, optionPreprocessorFuncs) {
    zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');

    this._optionManager.setOption(option, optionPreprocessorFuncs);

    this.resetOption(null);
  },

  /**
   * @param {string} type null/undefined: reset all.
   *                      'recreate': force recreate all.
   *                      'timeline': only reset timeline option
   *                      'media': only reset media query option
   * @return {boolean} Whether option changed.
   */
  resetOption: function (type) {
    var optionChanged = false;
    var optionManager = this._optionManager;

    if (!type || type === 'recreate') {
      var baseOption = optionManager.mountOption(type === 'recreate');

      if (!this.option || type === 'recreate') {
        initBase.call(this, baseOption);
      } else {
        this.restoreData();
        this.mergeOption(baseOption);
      }

      optionChanged = true;
    }

    if (type === 'timeline' || type === 'media') {
      this.restoreData();
    }

    if (!type || type === 'recreate' || type === 'timeline') {
      var timelineOption = optionManager.getTimelineOption(this);
      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
    }

    if (!type || type === 'recreate' || type === 'media') {
      var mediaOptions = optionManager.getMediaOption(this, this._api);

      if (mediaOptions.length) {
        each(mediaOptions, function (mediaOption) {
          this.mergeOption(mediaOption, optionChanged = true);
        }, this);
      }
    }

    return optionChanged;
  },

  /**
   * @protected
   */
  mergeOption: function (newOption) {
    var option = this.option;
    var componentsMap = this._componentsMap;
    var newCptTypes = []; // 如果不存在对应的 component model 则直接 merge

    each(newOption, function (componentOption, mainType) {
      if (componentOption == null) {
        return;
      }

      if (!ComponentModel.hasClass(mainType)) {
        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);
      } else {
        newCptTypes.push(mainType);
      }
    }); // FIXME OPTION 同步是否要改回原来的

    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);
    this._seriesIndices = this._seriesIndices || [];

    function visitComponent(mainType, dependencies) {
      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);
      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);
      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.

      each(mapResult, function (item, index) {
        var opt = item.option;

        if (isObject(opt)) {
          item.keyInfo.mainType = mainType;
          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);
        }
      });
      var dependentModels = getComponentsByTypes(componentsMap, dependencies);
      option[mainType] = [];
      componentsMap.set(mainType, []);
      each(mapResult, function (resultItem, index) {
        var componentModel = resultItem.exist;
        var newCptOption = resultItem.option;
        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},
        // see removeEdgeAndAdd in topologicalTravel and
        // ComponentModel.getAllClassMainTypes.

        if (!newCptOption) {
          componentModel.mergeOption({}, this);
          componentModel.optionUpdated({}, false);
        } else {
          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);

          if (componentModel && componentModel instanceof ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name;
            componentModel.mergeOption(newCptOption, this);
            componentModel.optionUpdated(newCptOption, false);
          } else {
            // PENDING Global as parent ?
            var extraOpt = zrUtil.extend({
              dependentModels: dependentModels,
              componentIndex: index
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);
            zrUtil.extend(componentModel, extraOpt);
            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.
            // newCptOption has been used as componentModel.option
            // and may be merged with theme and default, so pass null
            // to avoid confusion.

            componentModel.optionUpdated(null, true);
          }
        }

        componentsMap.get(mainType)[index] = componentModel;
        option[mainType][index] = componentModel.option;
      }, this); // Backup series for filtering.

      if (mainType === 'series') {
        this._seriesIndices = createSeriesIndices(componentsMap.get('series'));
      }
    }
  },

  /**
   * Get option for output (cloned option and inner info removed)
   * @public
   * @return {Object}
   */
  getOption: function () {
    var option = zrUtil.clone(this.option);
    each(option, function (opts, mainType) {
      if (ComponentModel.hasClass(mainType)) {
        var opts = modelUtil.normalizeToArray(opts);

        for (var i = opts.length - 1; i >= 0; i--) {
          // Remove options with inner id.
          if (modelUtil.isIdInner(opts[i])) {
            opts.splice(i, 1);
          }
        }

        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  },

  /**
   * @return {module:echarts/model/Model}
   */
  getTheme: function () {
    return this._theme;
  },

  /**
   * @param {string} mainType
   * @param {number} [idx=0]
   * @return {module:echarts/model/Component}
   */
  getComponent: function (mainType, idx) {
    var list = this._componentsMap.get(mainType);

    if (list) {
      return list[idx || 0];
    }
  },

  /**
   * If none of index and id and name used, return all components with mainType.
   * @param {Object} condition
   * @param {string} condition.mainType
   * @param {string} [condition.subType] If ignore, only query by mainType
   * @param {number|Array.<number>} [condition.index] Either input index or id or name.
   * @param {string|Array.<string>} [condition.id] Either input index or id or name.
   * @param {string|Array.<string>} [condition.name] Either input index or id or name.
   * @return {Array.<module:echarts/model/Component>}
   */
  queryComponents: function (condition) {
    var mainType = condition.mainType;

    if (!mainType) {
      return [];
    }

    var index = condition.index;
    var id = condition.id;
    var name = condition.name;

    var cpts = this._componentsMap.get(mainType);

    if (!cpts || !cpts.length) {
      return [];
    }

    var result;

    if (index != null) {
      if (!isArray(index)) {
        index = [index];
      }

      result = filter(map(index, function (idx) {
        return cpts[idx];
      }), function (val) {
        return !!val;
      });
    } else if (id != null) {
      var isIdArray = isArray(id);
      result = filter(cpts, function (cpt) {
        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
      });
    } else if (name != null) {
      var isNameArray = isArray(name);
      result = filter(cpts, function (cpt) {
        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;
      });
    } else {
      // Return all components with mainType
      result = cpts.slice();
    }

    return filterBySubType(result, condition);
  },

  /**
   * The interface is different from queryComponents,
   * which is convenient for inner usage.
   *
   * @usage
   * var result = findComponents(
   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
   * );
   * var result = findComponents(
   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
   * );
   * var result = findComponents(
   *     {mainType: 'series'},
   *     function (model, index) {...}
   * );
   * // result like [component0, componnet1, ...]
   *
   * @param {Object} condition
   * @param {string} condition.mainType Mandatory.
   * @param {string} [condition.subType] Optional.
   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
   *        where xxx is mainType.
   *        If query attribute is null/undefined or has no index/id/name,
   *        do not filtering by query conditions, which is convenient for
   *        no-payload situations or when target of action is global.
   * @param {Function} [condition.filter] parameter: component, return boolean.
   * @return {Array.<module:echarts/model/Component>}
   */
  findComponents: function (condition) {
    var query = condition.query;
    var mainType = condition.mainType;
    var queryCond = getQueryCond(query);
    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);
    return doFilter(filterBySubType(result, condition));

    function getQueryCond(q) {
      var indexAttr = mainType + 'Index';
      var idAttr = mainType + 'Id';
      var nameAttr = mainType + 'Name';
      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
        mainType: mainType,
        // subType will be filtered finally.
        index: q[indexAttr],
        id: q[idAttr],
        name: q[nameAttr]
      } : null;
    }

    function doFilter(res) {
      return condition.filter ? filter(res, condition.filter) : res;
    }
  },

  /**
   * @usage
   * eachComponent('legend', function (legendModel, index) {
   *     ...
   * });
   * eachComponent(function (componentType, model, index) {
   *     // componentType does not include subType
   *     // (componentType is 'xxx' but not 'xxx.aa')
   * });
   * eachComponent(
   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
   *     function (model, index) {...}
   * );
   * eachComponent(
   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
   *     function (model, index) {...}
   * );
   *
   * @param {string|Object=} mainType When mainType is object, the definition
   *                                  is the same as the method 'findComponents'.
   * @param {Function} cb
   * @param {*} context
   */
  eachComponent: function (mainType, cb, context) {
    var componentsMap = this._componentsMap;

    if (typeof mainType === 'function') {
      context = cb;
      cb = mainType;
      componentsMap.each(function (components, componentType) {
        each(components, function (component, index) {
          cb.call(context, componentType, component, index);
        });
      });
    } else if (zrUtil.isString(mainType)) {
      each(componentsMap.get(mainType), cb, context);
    } else if (isObject(mainType)) {
      var queryResult = this.findComponents(mainType);
      each(queryResult, cb, context);
    }
  },

  /**
   * @param {string} name
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeriesByName: function (name) {
    var series = this._componentsMap.get('series');

    return filter(series, function (oneSeries) {
      return oneSeries.name === name;
    });
  },

  /**
   * @param {number} seriesIndex
   * @return {module:echarts/model/Series}
   */
  getSeriesByIndex: function (seriesIndex) {
    return this._componentsMap.get('series')[seriesIndex];
  },

  /**
   * @param {string} subType
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeriesByType: function (subType) {
    var series = this._componentsMap.get('series');

    return filter(series, function (oneSeries) {
      return oneSeries.subType === subType;
    });
  },

  /**
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeries: function () {
    return this._componentsMap.get('series').slice();
  },

  /**
   * After filtering, series may be different
   * frome raw series.
   *
   * @param {Function} cb
   * @param {*} context
   */
  eachSeries: function (cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function (rawSeriesIndex) {
      var series = this._componentsMap.get('series')[rawSeriesIndex];

      cb.call(context, series, rawSeriesIndex);
    }, this);
  },

  /**
   * Iterate raw series before filtered.
   *
   * @param {Function} cb
   * @param {*} context
   */
  eachRawSeries: function (cb, context) {
    each(this._componentsMap.get('series'), cb, context);
  },

  /**
   * After filtering, series may be different.
   * frome raw series.
   *
   * @parma {string} subType
   * @param {Function} cb
   * @param {*} context
   */
  eachSeriesByType: function (subType, cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function (rawSeriesIndex) {
      var series = this._componentsMap.get('series')[rawSeriesIndex];

      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  },

  /**
   * Iterate raw series before filtered of given type.
   *
   * @parma {string} subType
   * @param {Function} cb
   * @param {*} context
   */
  eachRawSeriesByType: function (subType, cb, context) {
    return each(this.getSeriesByType(subType), cb, context);
  },

  /**
   * @param {module:echarts/model/Series} seriesModel
   */
  isSeriesFiltered: function (seriesModel) {
    assertSeriesInitialized(this);
    return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;
  },

  /**
   * @return {Array.<number>}
   */
  getCurrentSeriesIndices: function () {
    return (this._seriesIndices || []).slice();
  },

  /**
   * @param {Function} cb
   * @param {*} context
   */
  filterSeries: function (cb, context) {
    assertSeriesInitialized(this);
    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);
    this._seriesIndices = createSeriesIndices(filteredSeries);
  },
  restoreData: function () {
    var componentsMap = this._componentsMap;
    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));
    var componentTypes = [];
    componentsMap.each(function (components, componentType) {
      componentTypes.push(componentType);
    });
    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {
      each(componentsMap.get(componentType), function (component) {
        component.restoreData();
      });
    });
  }
});
/**
 * @inner
 */

function mergeTheme(option, theme) {
  zrUtil.each(theme, function (themeItem, name) {
    // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理
    if (!ComponentModel.hasClass(name)) {
      if (typeof themeItem === 'object') {
        option[name] = !option[name] ? zrUtil.clone(themeItem) : zrUtil.merge(option[name], themeItem, false);
      } else {
        if (option[name] == null) {
          option[name] = themeItem;
        }
      }
    }
  });
}

function initBase(baseOption) {
  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,
  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.

  this.option = {};
  this.option[OPTION_INNER_KEY] = 1;
  /**
   * Init with series: [], in case of calling findSeries method
   * before series initialized.
   * @type {Object.<string, Array.<module:echarts/model/Model>>}
   * @private
   */

  this._componentsMap = zrUtil.createHashMap({
    series: []
  });
  /**
   * Mapping between filtered series list and raw series list.
   * key: filtered series indices, value: raw series indices.
   * @type {Array.<nubmer>}
   * @private
   */

  this._seriesIndices = null;
  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property

  zrUtil.merge(baseOption, globalDefault, false);
  this.mergeOption(baseOption);
}
/**
 * @inner
 * @param {Array.<string>|string} types model types
 * @return {Object} key: {string} type, value: {Array.<Object>} models
 */


function getComponentsByTypes(componentsMap, types) {
  if (!zrUtil.isArray(types)) {
    types = types ? [types] : [];
  }

  var ret = {};
  each(types, function (type) {
    ret[type] = (componentsMap.get(type) || []).slice();
  });
  return ret;
}
/**
 * @inner
 */


function determineSubType(mainType, newCptOption, existComponent) {
  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.
  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType

  return subType;
}
/**
 * @inner
 */


function createSeriesIndices(seriesModels) {
  return map(seriesModels, function (series) {
    return series.componentIndex;
  }) || [];
}
/**
 * @inner
 */


function filterBySubType(components, condition) {
  // Using hasOwnProperty for restrict. Consider
  // subType is undefined in user payload.
  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {
    return cpt.subType === condition.subType;
  }) : components;
}
/**
 * @inner
 */


function assertSeriesInitialized(ecModel) {}

zrUtil.mixin(GlobalModel, colorPaletteMinin);
var _default = GlobalModel;
module.exports = _default;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__(121);

var getLineStyle = makeStyleMapper([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
var _default = {
  getLineStyle: function (excludes) {
    var style = getLineStyle(this, excludes);
    var lineDash = this.getLineDash(style.lineWidth);
    lineDash && (style.lineDash = lineDash);
    return style;
  },
  getLineDash: function (lineWidth) {
    if (lineWidth == null) {
      lineWidth = 1;
    }

    var lineType = this.get('type');
    var dotSize = Math.max(lineWidth, 2);
    var dashSize = lineWidth * 4;
    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize];
  }
};
module.exports = _default;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__(121);

var getAreaStyle = makeStyleMapper([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]);
var _default = {
  getAreaStyle: function (excludes, includes) {
    return getAreaStyle(this, excludes, includes);
  }
};
module.exports = _default;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var textContain = __webpack_require__(108);

var graphicUtil = __webpack_require__(93);

var PATH_COLOR = ['textStyle', 'color'];
var _default = {
  /**
   * Get color property or get color from option.textStyle.color
   * @param {boolean} [isEmphasis]
   * @return {string}
   */
  getTextColor: function (isEmphasis) {
    var ecModel = this.ecModel;
    return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  },

  /**
   * Create font string from fontStyle, fontWeight, fontSize, fontFamily
   * @return {string}
   */
  getFont: function () {
    return graphicUtil.getFont({
      fontStyle: this.getShallow('fontStyle'),
      fontWeight: this.getShallow('fontWeight'),
      fontSize: this.getShallow('fontSize'),
      fontFamily: this.getShallow('fontFamily')
    }, this.ecModel);
  },
  getTextRect: function (text) {
    return textContain.getBoundingRect(text, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('rich'), this.getShallow('truncateText'));
  }
};
module.exports = _default;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

var PathProxy = __webpack_require__(122);

var transformPath = __webpack_require__(207);

// command chars
var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
var mathSqrt = Math.sqrt;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI = Math.PI;

var vMag = function (v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
};

var vRatio = function (u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
};

var vAngle = function (u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
};

function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
  var psi = psiDeg * (PI / 180.0);
  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

  if (lambda > 1) {
    rx *= mathSqrt(lambda);
    ry *= mathSqrt(lambda);
  }

  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  var cxp = f * rx * yp / ry;
  var cyp = f * -ry * xp / rx;
  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;
  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var dTheta = vAngle(u, v);

  if (vRatio(u, v) <= -1) {
    dTheta = PI;
  }

  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }

  if (fs === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * PI;
  }

  if (fs === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * PI;
  }

  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}

function createPathProxyFromString(data) {
  if (!data) {
    return [];
  } // command string


  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');
  var n; // create pipes so that we can split the data

  for (n = 0; n < cc.length; n++) {
    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
  } // create array


  var arr = cs.split('|'); // init context point

  var cpx = 0;
  var cpy = 0;
  var path = new PathProxy();
  var CMD = PathProxy.CMD;
  var prevCmd;

  for (n = 1; n < arr.length; n++) {
    var str = arr[n];
    var c = str.charAt(0);
    var off = 0;
    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
    var cmd;

    if (p.length > 0 && p[0] === '') {
      p.shift();
    }

    for (var i = 0; i < p.length; i++) {
      p[i] = parseFloat(p[i]);
    }

    while (off < p.length && !isNaN(p[off])) {
      if (isNaN(p[0])) {
        break;
      }

      var ctlPtx;
      var ctlPty;
      var rx;
      var ry;
      var psi;
      var fa;
      var fs;
      var x1 = cpx;
      var y1 = cpy; // convert l, H, h, V, and v to L

      switch (c) {
        case 'l':
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'L':
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'm':
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.M;
          path.addData(cmd, cpx, cpy);
          c = 'l';
          break;

        case 'M':
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.M;
          path.addData(cmd, cpx, cpy);
          c = 'L';
          break;

        case 'h':
          cpx += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'H':
          cpx = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'v':
          cpy += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'V':
          cpy = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'C':
          cmd = CMD.C;
          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
          cpx = p[off - 2];
          cpy = p[off - 1];
          break;

        case 'c':
          cmd = CMD.C;
          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
          cpx += p[off - 2];
          cpy += p[off - 1];
          break;

        case 'S':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.C) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cmd = CMD.C;
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;

        case 's':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.C) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cmd = CMD.C;
          x1 = cpx + p[off++];
          y1 = cpy + p[off++];
          cpx += p[off++];
          cpy += p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;

        case 'Q':
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;

        case 'q':
          x1 = p[off++] + cpx;
          y1 = p[off++] + cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;

        case 'T':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.Q) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;

        case 't':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.Q) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;

        case 'A':
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;

        case 'a':
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
      }
    }

    if (c === 'z' || c === 'Z') {
      cmd = CMD.Z;
      path.addData(cmd);
    }

    prevCmd = cmd;
  }

  path.toStatic();
  return path;
} // TODO Optimize double memory cost problem


function createPathOptions(str, opts) {
  var pathProxy = createPathProxyFromString(str);
  opts = opts || {};

  opts.buildPath = function (path) {
    if (path.setData) {
      path.setData(pathProxy.data); // Svg and vml renderer don't have context

      var ctx = path.getContext();

      if (ctx) {
        path.rebuildPath(ctx);
      }
    } else {
      var ctx = path;
      pathProxy.rebuildPath(ctx);
    }
  };

  opts.applyTransform = function (m) {
    transformPath(pathProxy, m);
    this.dirty(true);
  };

  return opts;
}
/**
 * Create a Path object from path string data
 * http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {Object} opts Other options
 */


function createFromString(str, opts) {
  return new Path(createPathOptions(str, opts));
}
/**
 * Create a Path class from path string data
 * @param  {string} str
 * @param  {Object} opts Other options
 */


function extendFromString(str, opts) {
  return Path.extend(createPathOptions(str, opts));
}
/**
 * Merge multiple paths
 */
// TODO Apply transform
// TODO stroke dash
// TODO Optimize double memory cost problem


function mergePath(pathEls, opts) {
  var pathList = [];
  var len = pathEls.length;

  for (var i = 0; i < len; i++) {
    var pathEl = pathEls[i];

    if (!pathEl.path) {
      pathEl.createPathProxy();
    }

    if (pathEl.__dirtyPath) {
      pathEl.buildPath(pathEl.path, pathEl.shape, true);
    }

    pathList.push(pathEl.path);
  }

  var pathBundle = new Path(opts); // Need path proxy.

  pathBundle.createPathProxy();

  pathBundle.buildPath = function (path) {
    path.appendPath(pathList); // Svg and vml renderer don't have context

    var ctx = path.getContext();

    if (ctx) {
      path.rebuildPath(ctx);
    }
  };

  return pathBundle;
}

exports.createFromString = createFromString;
exports.extendFromString = extendFromString;
exports.mergePath = mergePath;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var PathProxy = __webpack_require__(122);

var line = __webpack_require__(203);

var cubic = __webpack_require__(204);

var quadratic = __webpack_require__(205);

var arc = __webpack_require__(206);

var _util = __webpack_require__(152);

var normalizeRadian = _util.normalizeRadian;

var curve = __webpack_require__(111);

var windingLine = __webpack_require__(153);

var CMD = PathProxy.CMD;
var PI2 = Math.PI * 2;
var EPSILON = 1e-4;

function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
} // 临时数组


var roots = [-1, -1, -1];
var extrema = [-1, -1];

function swapExtrema() {
  var tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}

function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  // Quick reject
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
    return 0;
  }

  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);

  if (nRoots === 0) {
    return 0;
  } else {
    var w = 0;
    var nExtrema = -1;
    var y0_, y1_;

    for (var i = 0; i < nRoots; i++) {
      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon

      var unit = t === 0 || t === 1 ? 0.5 : 1;
      var x_ = curve.cubicAt(x0, x1, x2, x3, t);

      if (x_ < x) {
        // Quick reject
        continue;
      }

      if (nExtrema < 0) {
        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);

        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }

        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);

        if (nExtrema > 1) {
          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
        }
      }

      if (nExtrema == 2) {
        // 分成三段单调函数
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else if (t < extrema[1]) {
          w += y1_ < y0_ ? unit : -unit;
        } else {
          w += y3 < y1_ ? unit : -unit;
        }
      } else {
        // 分成两段单调函数
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else {
          w += y3 < y0_ ? unit : -unit;
        }
      }
    }

    return w;
  }
}

function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  // Quick reject
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
    return 0;
  }

  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);

  if (nRoots === 0) {
    return 0;
  } else {
    var t = curve.quadraticExtremum(y0, y1, y2);

    if (t >= 0 && t <= 1) {
      var w = 0;
      var y_ = curve.quadraticAt(y0, y1, y2, t);

      for (var i = 0; i < nRoots; i++) {
        // Remove one endpoint.
        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);

        if (x_ < x) {
          // Quick reject
          continue;
        }

        if (roots[i] < t) {
          w += y_ < y0 ? unit : -unit;
        } else {
          w += y2 < y_ ? unit : -unit;
        }
      }

      return w;
    } else {
      // Remove one endpoint.
      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);

      if (x_ < x) {
        // Quick reject
        return 0;
      }

      return y2 < y0 ? unit : -unit;
    }
  }
} // TODO
// Arc 旋转


function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  y -= cy;

  if (y > r || y < -r) {
    return 0;
  }

  var tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp;
  roots[1] = tmp;
  var diff = Math.abs(startAngle - endAngle);

  if (diff < 1e-4) {
    return 0;
  }

  if (diff % PI2 < 1e-4) {
    // Is a circle
    startAngle = 0;
    endAngle = PI2;
    var dir = anticlockwise ? 1 : -1;

    if (x >= roots[0] + cx && x <= roots[1] + cx) {
      return dir;
    } else {
      return 0;
    }
  }

  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }

  if (startAngle > endAngle) {
    endAngle += PI2;
  }

  var w = 0;

  for (var i = 0; i < 2; i++) {
    var x_ = roots[i];

    if (x_ + cx > x) {
      var angle = Math.atan2(y, x_);
      var dir = anticlockwise ? 1 : -1;

      if (angle < 0) {
        angle = PI2 + angle;
      }

      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir = -dir;
        }

        w += dir;
      }
    }
  }

  return w;
}

function containPath(data, lineWidth, isStroke, x, y) {
  var w = 0;
  var xi = 0;
  var yi = 0;
  var x0 = 0;
  var y0 = 0;

  for (var i = 0; i < data.length;) {
    var cmd = data[i++]; // Begin a new subpath

    if (cmd === CMD.M && i > 1) {
      // Close previous subpath
      if (!isStroke) {
        w += windingLine(xi, yi, x0, y0, x, y);
      } // 如果被任何一个 subpath 包含
      // if (w !== 0) {
      //     return true;
      // }

    }

    if (i == 1) {
      // 如果第一个命令是 L, C, Q
      // 则 previous point 同绘制命令的第一个 point
      //
      // 第一个命令为 Arc 的情况下会在后面特殊处理
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }

    switch (cmd) {
      case CMD.M:
        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
        // 在 closePath 的时候使用
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;

      case CMD.L:
        if (isStroke) {
          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.C:
        if (isStroke) {
          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.Q:
        if (isStroke) {
          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.A:
        // TODO Arc 判断的开销比较大
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++]; // TODO Arc 旋转

        var psi = data[i++];
        var anticlockwise = 1 - data[i++];
        var x1 = Math.cos(theta) * rx + cx;
        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令

        if (i > 1) {
          w += windingLine(xi, yi, x1, y1, x, y);
        } else {
          // 第一个命令起点还未定义
          x0 = x1;
          y0 = y1;
        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放


        var _x = (x - cx) * ry / rx + cx;

        if (isStroke) {
          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
            return true;
          }
        } else {
          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
        }

        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;

      case CMD.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        var width = data[i++];
        var height = data[i++];
        var x1 = x0 + width;
        var y1 = y0 + height;

        if (isStroke) {
          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          // FIXME Clockwise ?
          w += windingLine(x1, y0, x1, y1, x, y);
          w += windingLine(x0, y1, x0, y0, x, y);
        }

        break;

      case CMD.Z:
        if (isStroke) {
          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          // Close a subpath
          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
          // FIXME subpaths may overlap
          // if (w !== 0) {
          //     return true;
          // }
        }

        xi = x0;
        yi = y0;
        break;
    }
  }

  if (!isStroke && !isAroundEqual(yi, y0)) {
    w += windingLine(xi, yi, x0, y0, x, y) || 0;
  }

  return w !== 0;
}

function contain(pathData, x, y) {
  return containPath(pathData, 0, false, x, y);
}

function containStroke(pathData, lineWidth, x, y) {
  return containPath(pathData, lineWidth, true, x, y);
}

exports.contain = contain;
exports.containStroke = containStroke;

/***/ }),
/* 203 */
/***/ (function(module, exports) {

/**
 * 线段包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth;
  var _a = 0;
  var _b = x0; // Quick reject

  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
    return false;
  }

  if (x0 !== x1) {
    _a = (y0 - y1) / (x0 - x1);
    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x - x0) <= _l / 2;
  }

  var tmp = _a * x - y + _b;

  var _s = tmp * tmp / (_a * _a + 1);

  return _s <= _l / 2 * _l / 2;
}

exports.containStroke = containStroke;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var curve = __webpack_require__(111);

/**
 * 三次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  x3
 * @param  {number}  y3
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth; // Quick reject

  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
    return false;
  }

  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
  return d <= _l / 2;
}

exports.containStroke = containStroke;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var _curve = __webpack_require__(111);

var quadraticProjectPoint = _curve.quadraticProjectPoint;

/**
 * 二次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth; // Quick reject

  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
    return false;
  }

  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
  return d <= _l / 2;
}

exports.containStroke = containStroke;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(152);

var normalizeRadian = _util.normalizeRadian;
var PI2 = Math.PI * 2;
/**
 * 圆弧描边包含判断
 * @param  {number}  cx
 * @param  {number}  cy
 * @param  {number}  r
 * @param  {number}  startAngle
 * @param  {number}  endAngle
 * @param  {boolean}  anticlockwise
 * @param  {number} lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {Boolean}
 */

function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth;
  x -= cx;
  y -= cy;
  var d = Math.sqrt(x * x + y * y);

  if (d - _l > r || d + _l < r) {
    return false;
  }

  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
    // Is a circle
    return true;
  }

  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }

  if (startAngle > endAngle) {
    endAngle += PI2;
  }

  var angle = Math.atan2(y, x);

  if (angle < 0) {
    angle += PI2;
  }

  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
}

exports.containStroke = containStroke;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var PathProxy = __webpack_require__(122);

var _vector = __webpack_require__(97);

var v2ApplyTransform = _vector.applyTransform;
var CMD = PathProxy.CMD;
var points = [[], [], []];
var mathSqrt = Math.sqrt;
var mathAtan2 = Math.atan2;

function _default(path, m) {
  var data = path.data;
  var cmd;
  var nPoint;
  var i;
  var j;
  var k;
  var p;
  var M = CMD.M;
  var C = CMD.C;
  var L = CMD.L;
  var R = CMD.R;
  var A = CMD.A;
  var Q = CMD.Q;

  for (i = 0, j = 0; i < data.length;) {
    cmd = data[i++];
    j = i;
    nPoint = 0;

    switch (cmd) {
      case M:
        nPoint = 1;
        break;

      case L:
        nPoint = 1;
        break;

      case C:
        nPoint = 3;
        break;

      case Q:
        nPoint = 2;
        break;

      case A:
        var x = m[4];
        var y = m[5];
        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx

        data[i] *= sx;
        data[i++] += x; // cy

        data[i] *= sy;
        data[i++] += y; // Scale rx and ry
        // FIXME Assume psi is 0 here

        data[i++] *= sx;
        data[i++] *= sy; // Start angle

        data[i++] += angle; // end angle

        data[i++] += angle; // FIXME psi

        i += 2;
        j = i;
        break;

      case R:
        // x0, y0
        p[0] = data[i++];
        p[1] = data[i++];
        v2ApplyTransform(p, p, m);
        data[j++] = p[0];
        data[j++] = p[1]; // x1, y1

        p[0] += data[i++];
        p[1] += data[i++];
        v2ApplyTransform(p, p, m);
        data[j++] = p[0];
        data[j++] = p[1];
    }

    for (k = 0; k < nPoint; k++) {
      var p = points[k];
      p[0] = data[i++];
      p[1] = data[i++];
      v2ApplyTransform(p, p, m); // Write back

      data[j++] = p[0];
      data[j++] = p[1];
    }
  }
}

module.exports = _default;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var Displayable = __webpack_require__(127);

var zrUtil = __webpack_require__(91);

var textContain = __webpack_require__(108);

var textHelper = __webpack_require__(149);

/**
 * @alias zrender/graphic/Text
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
var Text = function (opts) {
  // jshint ignore:line
  Displayable.call(this, opts);
};

Text.prototype = {
  constructor: Text,
  type: 'text',
  brush: function (ctx, prevEl) {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.

    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
    var text = style.text; // Convert to string

    text != null && (text += ''); // Always bind style

    style.bind(ctx, this, prevEl);

    if (!textHelper.needDrawText(text, style)) {
      return;
    }

    this.setTransform(ctx);
    textHelper.renderText(this, ctx, text, style);
    this.restoreTransform(ctx);
  },
  getBoundingRect: function () {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true);

    if (!this._rect) {
      var text = style.text;
      text != null ? text += '' : text = '';
      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);
      rect.x += style.x || 0;
      rect.y += style.y || 0;

      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
        var w = style.textStrokeWidth;
        rect.x -= w / 2;
        rect.y -= w / 2;
        rect.width += w;
        rect.height += w;
      }

      this._rect = rect;
    }

    return this._rect;
  }
};
zrUtil.inherits(Text, Displayable);
var _default = Text;
module.exports = _default;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

/**
 * 圆形
 * @module zrender/shape/Circle
 */
var _default = Path.extend({
  type: 'circle',
  shape: {
    cx: 0,
    cy: 0,
    r: 0
  },
  buildPath: function (ctx, shape, inBundle) {
    // Better stroking in ShapeBundle
    // Always do it may have performence issue ( fill may be 2x more cost)
    if (inBundle) {
      ctx.moveTo(shape.cx + shape.r, shape.cy);
    } // else {
    //     if (ctx.allocate && !ctx.data.length) {
    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
    //     }
    // }
    // Better stroking in ShapeBundle
    // ctx.moveTo(shape.cx + shape.r, shape.cy);


    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
  }
});

module.exports = _default;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

var fixClipWithShadow = __webpack_require__(154);

/**
 * 扇形
 * @module zrender/graphic/shape/Sector
 */
var _default = Path.extend({
  type: 'sector',
  shape: {
    cx: 0,
    cy: 0,
    r0: 0,
    r: 0,
    startAngle: 0,
    endAngle: Math.PI * 2,
    clockwise: true
  },
  brush: fixClipWithShadow(Path.prototype.brush),
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
    ctx.lineTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);

    if (r0 !== 0) {
      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
    }

    ctx.closePath();
  }
});

module.exports = _default;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

/**
 * 圆环
 * @module zrender/graphic/shape/Ring
 */
var _default = Path.extend({
  type: 'ring',
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    r0: 0
  },
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var PI2 = Math.PI * 2;
    ctx.moveTo(x + shape.r, y);
    ctx.arc(x, y, shape.r, 0, PI2, false);
    ctx.moveTo(x + shape.r0, y);
    ctx.arc(x, y, shape.r0, 0, PI2, true);
  }
});

module.exports = _default;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

var polyHelper = __webpack_require__(155);

/**
 * 多边形
 * @module zrender/shape/Polygon
 */
var _default = Path.extend({
  type: 'polygon',
  shape: {
    points: null,
    smooth: false,
    smoothConstraint: null
  },
  buildPath: function (ctx, shape) {
    polyHelper.buildPath(ctx, shape, true);
  }
});

module.exports = _default;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var _vector = __webpack_require__(97);

var v2Distance = _vector.distance;

/**
 * Catmull-Rom spline 插值折线
 * @module zrender/shape/util/smoothSpline
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 */

/**
 * @inner
 */
function interpolate(p0, p1, p2, p3, t, t2, t3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}
/**
 * @alias module:zrender/shape/util/smoothSpline
 * @param {Array} points 线段顶点数组
 * @param {boolean} isLoop
 * @return {Array}
 */


function _default(points, isLoop) {
  var len = points.length;
  var ret = [];
  var distance = 0;

  for (var i = 1; i < len; i++) {
    distance += v2Distance(points[i - 1], points[i]);
  }

  var segs = distance / 2;
  segs = segs < len ? len : segs;

  for (var i = 0; i < segs; i++) {
    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
    var idx = Math.floor(pos);
    var w = pos - idx;
    var p0;
    var p1 = points[idx % len];
    var p2;
    var p3;

    if (!isLoop) {
      p0 = points[idx === 0 ? idx : idx - 1];
      p2 = points[idx > len - 2 ? len - 1 : idx + 1];
      p3 = points[idx > len - 3 ? len - 1 : idx + 2];
    } else {
      p0 = points[(idx - 1 + len) % len];
      p2 = points[(idx + 1) % len];
      p3 = points[(idx + 2) % len];
    }

    var w2 = w * w;
    var w3 = w * w2;
    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
  }

  return ret;
}

module.exports = _default;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var _vector = __webpack_require__(97);

var v2Min = _vector.min;
var v2Max = _vector.max;
var v2Scale = _vector.scale;
var v2Distance = _vector.distance;
var v2Add = _vector.add;
var v2Clone = _vector.clone;
var v2Sub = _vector.sub;

/**
 * 贝塞尔平滑曲线
 * @module zrender/shape/util/smoothBezier
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 */

/**
 * 贝塞尔平滑曲线
 * @alias module:zrender/shape/util/smoothBezier
 * @param {Array} points 线段顶点数组
 * @param {number} smooth 平滑等级, 0-1
 * @param {boolean} isLoop
 * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
 *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
 *                           整个折线的包围盒做一个并集用来约束控制点。
 * @param {Array} 计算出来的控制点数组
 */
function _default(points, smooth, isLoop, constraint) {
  var cps = [];
  var v = [];
  var v1 = [];
  var v2 = [];
  var prevPoint;
  var nextPoint;
  var min, max;

  if (constraint) {
    min = [Infinity, Infinity];
    max = [-Infinity, -Infinity];

    for (var i = 0, len = points.length; i < len; i++) {
      v2Min(min, min, points[i]);
      v2Max(max, max, points[i]);
    } // 与指定的包围盒做并集


    v2Min(min, min, constraint[0]);
    v2Max(max, max, constraint[1]);
  }

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (isLoop) {
      prevPoint = points[i ? i - 1 : len - 1];
      nextPoint = points[(i + 1) % len];
    } else {
      if (i === 0 || i === len - 1) {
        cps.push(v2Clone(points[i]));
        continue;
      } else {
        prevPoint = points[i - 1];
        nextPoint = points[i + 1];
      }
    }

    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length

    v2Scale(v, v, smooth);
    var d0 = v2Distance(point, prevPoint);
    var d1 = v2Distance(point, nextPoint);
    var sum = d0 + d1;

    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }

    v2Scale(v1, v, -d0);
    v2Scale(v2, v, d1);
    var cp0 = v2Add([], point, v1);
    var cp1 = v2Add([], point, v2);

    if (constraint) {
      v2Max(cp0, cp0, min);
      v2Min(cp0, cp0, max);
      v2Max(cp1, cp1, min);
      v2Min(cp1, cp1, max);
    }

    cps.push(cp0);
    cps.push(cp1);
  }

  if (isLoop) {
    cps.push(cps.shift());
  }

  return cps;
}

module.exports = _default;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

var polyHelper = __webpack_require__(155);

/**
 * @module zrender/graphic/shape/Polyline
 */
var _default = Path.extend({
  type: 'polyline',
  shape: {
    points: null,
    smooth: false,
    smoothConstraint: null
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    polyHelper.buildPath(ctx, shape, false);
  }
});

module.exports = _default;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

var roundRectHelper = __webpack_require__(150);

/**
 * 矩形
 * @module zrender/graphic/shape/Rect
 */
var _default = Path.extend({
  type: 'rect',
  shape: {
    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
    // r缩写为1         相当于 [1, 1, 1, 1]
    // r缩写为[1]       相当于 [1, 1, 1, 1]
    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
    r: 0,
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (ctx, shape) {
    var x = shape.x;
    var y = shape.y;
    var width = shape.width;
    var height = shape.height;

    if (!shape.r) {
      ctx.rect(x, y, width, height);
    } else {
      roundRectHelper.buildPath(ctx, shape);
    }

    ctx.closePath();
    return;
  }
});

module.exports = _default;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

/**
 * 直线
 * @module zrender/graphic/shape/Line
 */
var _default = Path.extend({
  type: 'line',
  shape: {
    // Start point
    x1: 0,
    y1: 0,
    // End point
    x2: 0,
    y2: 0,
    percent: 1
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var percent = shape.percent;

    if (percent === 0) {
      return;
    }

    ctx.moveTo(x1, y1);

    if (percent < 1) {
      x2 = x1 * (1 - percent) + x2 * percent;
      y2 = y1 * (1 - percent) + y2 * percent;
    }

    ctx.lineTo(x2, y2);
  },

  /**
   * Get point at percent
   * @param  {number} percent
   * @return {Array.<number>}
   */
  pointAt: function (p) {
    var shape = this.shape;
    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
  }
});

module.exports = _default;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

var vec2 = __webpack_require__(97);

var _curve = __webpack_require__(111);

var quadraticSubdivide = _curve.quadraticSubdivide;
var cubicSubdivide = _curve.cubicSubdivide;
var quadraticAt = _curve.quadraticAt;
var cubicAt = _curve.cubicAt;
var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
var cubicDerivativeAt = _curve.cubicDerivativeAt;

/**
 * 贝塞尔曲线
 * @module zrender/shape/BezierCurve
 */
var out = [];

function someVectorAt(shape, t, isTangent) {
  var cpx2 = shape.cpx2;
  var cpy2 = shape.cpy2;

  if (cpx2 === null || cpy2 === null) {
    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
  } else {
    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
  }
}

var _default = Path.extend({
  type: 'bezier-curve',
  shape: {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    cpx1: 0,
    cpy1: 0,
    // cpx2: 0,
    // cpy2: 0
    // Curve show percent, for animating
    percent: 1
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var cpx1 = shape.cpx1;
    var cpy1 = shape.cpy1;
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    var percent = shape.percent;

    if (percent === 0) {
      return;
    }

    ctx.moveTo(x1, y1);

    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y1, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }

      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }

      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  },

  /**
   * Get point at percent
   * @param  {number} t
   * @return {Array.<number>}
   */
  pointAt: function (t) {
    return someVectorAt(this.shape, t, false);
  },

  /**
   * Get tangent at percent
   * @param  {number} t
   * @return {Array.<number>}
   */
  tangentAt: function (t) {
    var p = someVectorAt(this.shape, t, true);
    return vec2.normalize(p, p);
  }
});

module.exports = _default;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

/**
 * 圆弧
 * @module zrender/graphic/shape/Arc
 */
var _default = Path.extend({
  type: 'arc',
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    startAngle: 0,
    endAngle: Math.PI * 2,
    clockwise: true
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
  }
});

module.exports = _default;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

// CompoundPath to improve performance
var _default = Path.extend({
  type: 'compound',
  shape: {
    paths: null
  },
  _updatePathDirty: function () {
    var dirtyPath = this.__dirtyPath;
    var paths = this.shape.paths;

    for (var i = 0; i < paths.length; i++) {
      // Mark as dirty if any subpath is dirty
      dirtyPath = dirtyPath || paths[i].__dirtyPath;
    }

    this.__dirtyPath = dirtyPath;
    this.__dirty = this.__dirty || dirtyPath;
  },
  beforeBrush: function () {
    this._updatePathDirty();

    var paths = this.shape.paths || [];
    var scale = this.getGlobalScale(); // Update path scale

    for (var i = 0; i < paths.length; i++) {
      if (!paths[i].path) {
        paths[i].createPathProxy();
      }

      paths[i].path.setScale(scale[0], scale[1]);
    }
  },
  buildPath: function (ctx, shape) {
    var paths = shape.paths || [];

    for (var i = 0; i < paths.length; i++) {
      paths[i].buildPath(ctx, paths[i].shape, true);
    }
  },
  afterBrush: function () {
    var paths = this.shape.paths || [];

    for (var i = 0; i < paths.length; i++) {
      paths[i].__dirtyPath = false;
    }
  },
  getBoundingRect: function () {
    this._updatePathDirty();

    return Path.prototype.getBoundingRect.call(this);
  }
});

module.exports = _default;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Gradient = __webpack_require__(129);

/**
 * x, y, x2, y2 are all percent from 0 to 1
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @param {number} [x2=1]
 * @param {number} [y2=0]
 * @param {Array.<Object>} colorStops
 * @param {boolean} [globalCoord=false]
 */
var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {type: 'linear', colorStops: ...}`, where
  // this constructor will not be called.
  this.x = x == null ? 0 : x;
  this.y = y == null ? 0 : y;
  this.x2 = x2 == null ? 1 : x2;
  this.y2 = y2 == null ? 0 : y2; // Can be cloned

  this.type = 'linear'; // If use global coord

  this.global = globalCoord || false;
  Gradient.call(this, colorStops);
};

LinearGradient.prototype = {
  constructor: LinearGradient
};
zrUtil.inherits(LinearGradient, Gradient);
var _default = LinearGradient;
module.exports = _default;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Gradient = __webpack_require__(129);

/**
 * x, y, r are all percent from 0 to 1
 * @param {number} [x=0.5]
 * @param {number} [y=0.5]
 * @param {number} [r=0.5]
 * @param {Array.<Object>} [colorStops]
 * @param {boolean} [globalCoord=false]
 */
var RadialGradient = function (x, y, r, colorStops, globalCoord) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {type: 'radial', colorStops: ...}`, where
  // this constructor will not be called.
  this.x = x == null ? 0.5 : x;
  this.y = y == null ? 0.5 : y;
  this.r = r == null ? 0.5 : r; // Can be cloned

  this.type = 'radial'; // If use global coord

  this.global = globalCoord || false;
  Gradient.call(this, colorStops);
};

RadialGradient.prototype = {
  constructor: RadialGradient
};
zrUtil.inherits(RadialGradient, Gradient);
var _default = RadialGradient;
module.exports = _default;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__(121);

var getItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]);
var _default = {
  getItemStyle: function (excludes, includes) {
    var style = getItemStyle(this, excludes, includes);
    var lineDash = this.getBorderLineDash();
    lineDash && (style.lineDash = lineDash);
    return style;
  },
  getBorderLineDash: function () {
    var lineType = this.get('borderType');
    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [5, 5] : [1, 1];
  }
};
module.exports = _default;

/***/ }),
/* 224 */
/***/ (function(module, exports) {

var _default = {
  getBoxLayoutParams: function () {
    return {
      left: this.get('left'),
      top: this.get('top'),
      right: this.get('right'),
      bottom: this.get('bottom'),
      width: this.get('width'),
      height: this.get('height')
    };
  }
};
module.exports = _default;

/***/ }),
/* 225 */
/***/ (function(module, exports) {

var platform = ''; // Navigator not exists in node

if (typeof navigator !== 'undefined') {
  platform = navigator.platform || '';
}

var _default = {
  // 全图默认背景
  // backgroundColor: 'rgba(0,0,0,0)',
  // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
  // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
  // 浅色
  // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
  // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
  // 深色
  color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'],
  // 默认需要 Grid 配置项
  // grid: {},
  // 主题，主题
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: 'normal',
    fontWeight: 'normal'
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  animation: 'auto',
  animationDuration: 1000,
  animationDurationUpdate: 300,
  animationEasing: 'exponentialOut',
  animationEasingUpdate: 'cubicOut',
  animationThreshold: 2000,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3000,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3000,
  // See: module:echarts/scale/Time
  useUTC: false
};
module.exports = _default;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var echartsAPIList = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel']; // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js

function ExtensionAPI(chartInstance) {
  zrUtil.each(echartsAPIList, function (name) {
    this[name] = zrUtil.bind(chartInstance[name], chartInstance);
  }, this);
}

var _default = ExtensionAPI;
module.exports = _default;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var modelUtil = __webpack_require__(95);

var ComponentModel = __webpack_require__(105);

/**
 * ECharts option manager
 *
 * @module {echarts/model/OptionManager}
 */
var each = zrUtil.each;
var clone = zrUtil.clone;
var map = zrUtil.map;
var merge = zrUtil.merge;
var QUERY_REG = /^(min|max)?(.+)$/;
/**
 * TERM EXPLANATIONS:
 *
 * [option]:
 *
 *     An object that contains definitions of components. For example:
 *     var option = {
 *         title: {...},
 *         legend: {...},
 *         visualMap: {...},
 *         series: [
 *             {data: [...]},
 *             {data: [...]},
 *             ...
 *         ]
 *     };
 *
 * [rawOption]:
 *
 *     An object input to echarts.setOption. 'rawOption' may be an
 *     'option', or may be an object contains multi-options. For example:
 *     var option = {
 *         baseOption: {
 *             title: {...},
 *             legend: {...},
 *             series: [
 *                 {data: [...]},
 *                 {data: [...]},
 *                 ...
 *             ]
 *         },
 *         timeline: {...},
 *         options: [
 *             {title: {...}, series: {data: [...]}},
 *             {title: {...}, series: {data: [...]}},
 *             ...
 *         ],
 *         media: [
 *             {
 *                 query: {maxWidth: 320},
 *                 option: {series: {x: 20}, visualMap: {show: false}}
 *             },
 *             {
 *                 query: {minWidth: 320, maxWidth: 720},
 *                 option: {series: {x: 500}, visualMap: {show: true}}
 *             },
 *             {
 *                 option: {series: {x: 1200}, visualMap: {show: true}}
 *             }
 *         ]
 *     };
 *
 * @alias module:echarts/model/OptionManager
 * @param {module:echarts/ExtensionAPI} api
 */

function OptionManager(api) {
  /**
   * @private
   * @type {module:echarts/ExtensionAPI}
   */
  this._api = api;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._timelineOptions = [];
  /**
   * @private
   * @type {Array.<Object>}
   */

  this._mediaList = [];
  /**
   * @private
   * @type {Object}
   */

  this._mediaDefault;
  /**
   * -1, means default.
   * empty means no media.
   * @private
   * @type {Array.<number>}
   */

  this._currentMediaIndices = [];
  /**
   * @private
   * @type {Object}
   */

  this._optionBackup;
  /**
   * @private
   * @type {Object}
   */

  this._newBaseOption;
} // timeline.notMerge is not supported in ec3. Firstly there is rearly
// case that notMerge is needed. Secondly supporting 'notMerge' requires
// rawOption cloned and backuped when timeline changed, which does no
// good to performance. What's more, that both timeline and setOption
// method supply 'notMerge' brings complex and some problems.
// Consider this case:
// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);


OptionManager.prototype = {
  constructor: OptionManager,

  /**
   * @public
   * @param {Object} rawOption Raw option.
   * @param {module:echarts/model/Global} ecModel
   * @param {Array.<Function>} optionPreprocessorFuncs
   * @return {Object} Init option
   */
  setOption: function (rawOption, optionPreprocessorFuncs) {
    rawOption = clone(rawOption, true); // FIXME
    // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。

    var oldOptionBackup = this._optionBackup;
    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);

    if (oldOptionBackup) {
      // Only baseOption can be merged.
      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,
      // that is, if you `setOption` twice and both has timeline options, the latter
      // timeline opitons will not be merged to the formers, but just substitude them.

      if (newParsedOption.timelineOptions.length) {
        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
      }

      if (newParsedOption.mediaList.length) {
        oldOptionBackup.mediaList = newParsedOption.mediaList;
      }

      if (newParsedOption.mediaDefault) {
        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  },

  /**
   * @param {boolean} isRecreate
   * @return {Object}
   */
  mountOption: function (isRecreate) {
    var optionBackup = this._optionBackup; // TODO
    // 如果没有reset功能则不clone。

    this._timelineOptions = map(optionBackup.timelineOptions, clone);
    this._mediaList = map(optionBackup.mediaList, clone);
    this._mediaDefault = clone(optionBackup.mediaDefault);
    this._currentMediaIndices = [];
    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`
    // called, and is merged into every new option by inner method `mergeOption`
    // each time `setOption` called, can be only used in `isRecreate`, because
    // its reliability is under suspicion. In other cases option merge is
    // performed by `model.mergeOption`.
    ? optionBackup.baseOption : this._newBaseOption);
  },

  /**
   * @param {module:echarts/model/Global} ecModel
   * @return {Object}
   */
  getTimelineOption: function (ecModel) {
    var option;
    var timelineOptions = this._timelineOptions;

    if (timelineOptions.length) {
      // getTimelineOption can only be called after ecModel inited,
      // so we can get currentIndex from timelineModel.
      var timelineModel = ecModel.getComponent('timeline');

      if (timelineModel) {
        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);
      }
    }

    return option;
  },

  /**
   * @param {module:echarts/model/Global} ecModel
   * @return {Array.<Object>}
   */
  getMediaOption: function (ecModel) {
    var ecWidth = this._api.getWidth();

    var ecHeight = this._api.getHeight();

    var mediaList = this._mediaList;
    var mediaDefault = this._mediaDefault;
    var indices = [];
    var result = []; // No media defined.

    if (!mediaList.length && !mediaDefault) {
      return result;
    } // Multi media may be applied, the latter defined media has higher priority.


    for (var i = 0, len = mediaList.length; i < len; i++) {
      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
        indices.push(i);
      }
    } // FIXME
    // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。


    if (!indices.length && mediaDefault) {
      indices = [-1];
    }

    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map(indices, function (index) {
        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
      });
    } // Otherwise return nothing.


    this._currentMediaIndices = indices;
    return result;
  }
};

function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
  var timelineOptions = [];
  var mediaList = [];
  var mediaDefault;
  var baseOption; // Compatible with ec2.

  var timelineOpt = rawOption.timeline;

  if (rawOption.baseOption) {
    baseOption = rawOption.baseOption;
  } // For timeline


  if (timelineOpt || rawOption.options) {
    baseOption = baseOption || {};
    timelineOptions = (rawOption.options || []).slice();
  } // For media query


  if (rawOption.media) {
    baseOption = baseOption || {};
    var media = rawOption.media;
    each(media, function (singleMedia) {
      if (singleMedia && singleMedia.option) {
        if (singleMedia.query) {
          mediaList.push(singleMedia);
        } else if (!mediaDefault) {
          // Use the first media default.
          mediaDefault = singleMedia;
        }
      }
    });
  } // For normal option


  if (!baseOption) {
    baseOption = rawOption;
  } // Set timelineOpt to baseOption in ec3,
  // which is convenient for merge option.


  if (!baseOption.timeline) {
    baseOption.timeline = timelineOpt;
  } // Preprocess.


  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {
    return media.option;
  })), function (option) {
    each(optionPreprocessorFuncs, function (preProcess) {
      preProcess(option, isNew);
    });
  });
  return {
    baseOption: baseOption,
    timelineOptions: timelineOptions,
    mediaDefault: mediaDefault,
    mediaList: mediaList
  };
}
/**
 * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
 * Support: width, height, aspectRatio
 * Can use max or min as prefix.
 */


function applyMediaQuery(query, ecWidth, ecHeight) {
  var realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight // lowser case for convenientce.

  };
  var applicatable = true;
  zrUtil.each(query, function (value, attr) {
    var matched = attr.match(QUERY_REG);

    if (!matched || !matched[1] || !matched[2]) {
      return;
    }

    var operator = matched[1];
    var realAttr = matched[2].toLowerCase();

    if (!compare(realMap[realAttr], value, operator)) {
      applicatable = false;
    }
  });
  return applicatable;
}

function compare(real, expect, operator) {
  if (operator === 'min') {
    return real >= expect;
  } else if (operator === 'max') {
    return real <= expect;
  } else {
    // Equals
    return real === expect;
  }
}

function indicesEquals(indices1, indices2) {
  // indices is always order by asc and has only finite number.
  return indices1.join(',') === indices2.join(',');
}
/**
 * Consider case:
 * `chart.setOption(opt1);`
 * Then user do some interaction like dataZoom, dataView changing.
 * `chart.setOption(opt2);`
 * Then user press 'reset button' in toolbox.
 *
 * After doing that all of the interaction effects should be reset, the
 * chart should be the same as the result of invoke
 * `chart.setOption(opt1); chart.setOption(opt2);`.
 *
 * Although it is not able ensure that
 * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
 * `chart.setOption(merge(opt1, opt2));` exactly,
 * this might be the only simple way to implement that feature.
 *
 * MEMO: We've considered some other approaches:
 * 1. Each model handle its self restoration but not uniform treatment.
 *     (Too complex in logic and error-prone)
 * 2. Use a shadow ecModel. (Performace expensive)
 */


function mergeOption(oldOption, newOption) {
  newOption = newOption || {};
  each(newOption, function (newCptOpt, mainType) {
    if (newCptOpt == null) {
      return;
    }

    var oldCptOpt = oldOption[mainType];

    if (!ComponentModel.hasClass(mainType)) {
      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);
    } else {
      newCptOpt = modelUtil.normalizeToArray(newCptOpt);
      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);
      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);
      oldOption[mainType] = map(mapResult, function (item) {
        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;
      });
    }
  });
}

var _default = OptionManager;
module.exports = _default;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var _util = __webpack_require__(91);

var each = _util.each;
var isArray = _util.isArray;
var isObject = _util.isObject;

var compatStyle = __webpack_require__(229);

var _model = __webpack_require__(95);

var normalizeToArray = _model.normalizeToArray;

// Compatitable with 2.0
function get(opt, path) {
  path = path.split(',');
  var obj = opt;

  for (var i = 0; i < path.length; i++) {
    obj = obj && obj[path[i]];

    if (obj == null) {
      break;
    }
  }

  return obj;
}

function set(opt, path, val, overwrite) {
  path = path.split(',');
  var obj = opt;
  var key;

  for (var i = 0; i < path.length - 1; i++) {
    key = path[i];

    if (obj[key] == null) {
      obj[key] = {};
    }

    obj = obj[key];
  }

  if (overwrite || obj[path[i]] == null) {
    obj[path[i]] = val;
  }
}

function compatLayoutProperties(option) {
  each(LAYOUT_PROPERTIES, function (prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}

var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];
var COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];
var COMPATITABLE_SERIES = ['bar', 'boxplot', 'candlestick', 'chord', 'effectScatter', 'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel', 'pie', 'radar', 'sankey', 'scatter', 'treemap'];

function _default(option, isTheme) {
  compatStyle(option, isTheme); // Make sure series array for model initialization.

  option.series = normalizeToArray(option.series);
  each(option.series, function (seriesOpt) {
    if (!isObject(seriesOpt)) {
      return;
    }

    var seriesType = seriesOpt.type;

    if (seriesType === 'pie' || seriesType === 'gauge') {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
      }
    }

    if (seriesType === 'gauge') {
      var pointerColor = get(seriesOpt, 'pointer.color');
      pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);
    }

    for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {
      if (COMPATITABLE_SERIES[i] === seriesOpt.type) {
        compatLayoutProperties(seriesOpt);
        break;
      }
    }
  }); // dataRange has changed to visualMap

  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }

  each(COMPATITABLE_COMPONENTS, function (componentName) {
    var options = option[componentName];

    if (options) {
      if (!isArray(options)) {
        options = [options];
      }

      each(options, function (option) {
        compatLayoutProperties(option);
      });
    }
  });
}

module.exports = _default;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var modelUtil = __webpack_require__(95);

var each = zrUtil.each;
var isObject = zrUtil.isObject;
var POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];

function compatItemStyle(opt) {
  var itemStyleOpt = opt && opt.itemStyle;

  if (!itemStyleOpt) {
    return;
  }

  for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
    var styleName = POSSIBLE_STYLES[i];
    var normalItemStyleOpt = itemStyleOpt.normal;
    var emphasisItemStyleOpt = itemStyleOpt.emphasis;

    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};

      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }

      normalItemStyleOpt[styleName] = null;
    }

    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};

      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }

      emphasisItemStyleOpt[styleName] = null;
    }
  }
}

function compatTextStyle(opt, propName) {
  var labelOptSingle = isObject(opt) && opt[propName];
  var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;

  if (textStyle) {
    for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {
      var propName = modelUtil.TEXT_STYLE_OPTIONS[i];

      if (textStyle.hasOwnProperty(propName)) {
        labelOptSingle[propName] = textStyle[propName];
      }
    }
  }
}

function compatLabelTextStyle(labelOpt) {
  if (isObject(labelOpt)) {
    compatTextStyle(labelOpt, 'normal');
    compatTextStyle(labelOpt, 'emphasis');
  }
}

function processSeries(seriesOpt) {
  if (!isObject(seriesOpt)) {
    return;
  }

  compatItemStyle(seriesOpt);
  compatLabelTextStyle(seriesOpt.label); // treemap

  compatLabelTextStyle(seriesOpt.upperLabel); // graph

  compatLabelTextStyle(seriesOpt.edgeLabel);
  var markPoint = seriesOpt.markPoint;
  compatItemStyle(markPoint);
  compatLabelTextStyle(markPoint && markPoint.label);
  var markLine = seriesOpt.markLine;
  compatItemStyle(seriesOpt.markLine);
  compatLabelTextStyle(markLine && markLine.label);
  var markArea = seriesOpt.markArea;
  compatLabelTextStyle(markArea && markArea.label); // For gauge

  compatTextStyle(seriesOpt, 'axisLabel');
  compatTextStyle(seriesOpt, 'title');
  compatTextStyle(seriesOpt, 'detail');
  var data = seriesOpt.data;

  if (data) {
    for (var i = 0; i < data.length; i++) {
      compatItemStyle(data[i]);
      compatLabelTextStyle(data[i] && data[i].label);
    }
  } // mark point data


  var markPoint = seriesOpt.markPoint;

  if (markPoint && markPoint.data) {
    var mpData = markPoint.data;

    for (var i = 0; i < mpData.length; i++) {
      compatItemStyle(mpData[i]);
      compatLabelTextStyle(mpData[i] && mpData[i].label);
    }
  } // mark line data


  var markLine = seriesOpt.markLine;

  if (markLine && markLine.data) {
    var mlData = markLine.data;

    for (var i = 0; i < mlData.length; i++) {
      if (zrUtil.isArray(mlData[i])) {
        compatItemStyle(mlData[i][0]);
        compatLabelTextStyle(mlData[i][0] && mlData[i][0].label);
        compatItemStyle(mlData[i][1]);
        compatLabelTextStyle(mlData[i][1] && mlData[i][1].label);
      } else {
        compatItemStyle(mlData[i]);
        compatLabelTextStyle(mlData[i] && mlData[i].label);
      }
    }
  }
}

function toArr(o) {
  return zrUtil.isArray(o) ? o : o ? [o] : [];
}

function toObj(o) {
  return (zrUtil.isArray(o) ? o[0] : o) || {};
}

function _default(option, isTheme) {
  each(toArr(option.series), function (seriesOpt) {
    isObject(seriesOpt) && processSeries(seriesOpt);
  });
  var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];
  isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');
  each(axes, function (axisName) {
    each(toArr(option[axisName]), function (axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, 'axisLabel');
        compatTextStyle(axisOpt.axisPointer, 'label');
      }
    });
  });
  each(toArr(option.parallel), function (parallelOpt) {
    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, 'axisLabel');
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');
  });
  each(toArr(option.calendar), function (calendarOpt) {
    compatTextStyle(calendarOpt, 'dayLabel');
    compatTextStyle(calendarOpt, 'monthLabel');
    compatTextStyle(calendarOpt, 'yearLabel');
  }); // radar.name.textStyle

  each(toArr(option.radar), function (radarOpt) {
    compatTextStyle(radarOpt, 'name');
  });
  each(toArr(option.geo), function (geoOpt) {
    if (isObject(geoOpt)) {
      compatLabelTextStyle(geoOpt.label);
      each(toArr(geoOpt.regions), function (regionObj) {
        compatLabelTextStyle(regionObj.label);
      });
    }
  });
  compatLabelTextStyle(toObj(option.timeline).label);
  compatTextStyle(toObj(option.axisPointer), 'label');
  compatTextStyle(toObj(option.tooltip).axisPointer, 'label');
}

module.exports = _default;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var Gradient = __webpack_require__(129);

function _default(ecModel) {
  function encodeColor(seriesModel) {
    var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');
    var data = seriesModel.getData();
    var color = seriesModel.get(colorAccessPath) // Set in itemStyle
    || seriesModel.getColorFromPalette(seriesModel.get('name')); // Default color
    // FIXME Set color function or use the platte color

    data.setVisual('color', color); // Only visible series has each data be visual encoded

    if (!ecModel.isSeriesFiltered(seriesModel)) {
      if (typeof color === 'function' && !(color instanceof Gradient)) {
        data.each(function (idx) {
          data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));
        });
      } // itemStyle in each data item


      data.each(function (idx) {
        var itemModel = data.getItemModel(idx);
        var color = itemModel.get(colorAccessPath, true);

        if (color != null) {
          data.setItemVisual(idx, 'color', color);
        }
      });
    }
  }

  ecModel.eachRawSeries(encodeColor);
}

module.exports = _default;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var graphic = __webpack_require__(93);

var PI = Math.PI;
/**
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} [opts]
 * @param {string} [opts.text]
 * @param {string} [opts.color]
 * @param {string} [opts.textColor]
 * @return {module:zrender/Element}
 */

function _default(api, opts) {
  opts = opts || {};
  zrUtil.defaults(opts, {
    text: 'loading',
    color: '#c23531',
    textColor: '#000',
    maskColor: 'rgba(255, 255, 255, 0.8)',
    zlevel: 0
  });
  var mask = new graphic.Rect({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 10000
  });
  var arc = new graphic.Arc({
    shape: {
      startAngle: -PI / 2,
      endAngle: -PI / 2 + 0.1,
      r: 10
    },
    style: {
      stroke: opts.color,
      lineCap: 'round',
      lineWidth: 5
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  var labelRect = new graphic.Rect({
    style: {
      fill: 'none',
      text: opts.text,
      textPosition: 'right',
      textDistance: 10,
      textFill: opts.textColor
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  arc.animateShape(true).when(1000, {
    endAngle: PI * 3 / 2
  }).start('circularInOut');
  arc.animateShape(true).when(1000, {
    startAngle: PI * 3 / 2
  }).delay(300).start('circularInOut');
  var group = new graphic.Group();
  group.add(arc);
  group.add(labelRect);
  group.add(mask); // Inject resize

  group.resize = function () {
    var cx = api.getWidth() / 2;
    var cy = api.getHeight() / 2;
    arc.setShape({
      cx: cx,
      cy: cy
    });
    var r = arc.shape.r;
    labelRect.setShape({
      x: cx - r,
      y: cy - r,
      width: r * 2,
      height: r * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api.getWidth(),
      height: api.getHeight()
    });
  };

  group.resize();
  return group;
}

module.exports = _default;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var zrender = __webpack_require__(138);

exports.zrender = zrender;

var matrix = __webpack_require__(110);

exports.matrix = matrix;

var vector = __webpack_require__(97);

exports.vector = vector;

var zrUtil = __webpack_require__(91);

var colorTool = __webpack_require__(113);

exports.color = colorTool;

var graphic = __webpack_require__(93);

exports.graphic = graphic;

var numberUtil = __webpack_require__(94);

exports.number = numberUtil;

var formatUtil = __webpack_require__(99);

exports.format = formatUtil;

var _throttle = __webpack_require__(114);

var throttle = _throttle.throttle;
exports.throttle = _throttle.throttle;

var ecHelper = __webpack_require__(233);

exports.helper = ecHelper;

var _List = __webpack_require__(123);

exports.List = _List;

var _Model = __webpack_require__(102);

exports.Model = _Model;

var _Axis = __webpack_require__(162);

exports.Axis = _Axis;

var _env = __webpack_require__(98);

exports.env = _env;

var _parseGeoJson = __webpack_require__(237);

exports.parseGeoJson = _parseGeoJson;

/**
 * Do not mount those modules on 'src/echarts' for better tree shaking.
 */
var ecUtil = {};
zrUtil.each(['map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults', 'clone', 'merge'], function (name) {
  ecUtil[name] = zrUtil[name];
});
exports.util = ecUtil;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var createListFromArray = __webpack_require__(133);

var axisHelper = __webpack_require__(112);

var axisModelCommonMixin = __webpack_require__(161);

var Model = __webpack_require__(102);

var _completeDimensions = __webpack_require__(159);

exports.completeDimensions = _completeDimensions;

var _symbol = __webpack_require__(115);

exports.createSymbol = _symbol.createSymbol;

/**
 * Create a muti dimension List structure from seriesModel.
 * @param  {module:echarts/model/Model} seriesModel
 * @return {module:echarts/data/List} list
 */
function createList(seriesModel) {
  var data = seriesModel.get('data');
  return createListFromArray(data, seriesModel, seriesModel.ecModel);
}
/**
 * @see {module:echarts/data/helper/completeDimensions}
 */


/**
 * Create scale
 * @param {Array.<number>} dataExtent
 * @param {Object|module:echarts/Model} option
 */
function createScale(dataExtent, option) {
  var axisModel = option;

  if (!(option instanceof Model)) {
    axisModel = new Model(option);
    zrUtil.mixin(axisModel, axisModelCommonMixin);
  }

  var scale = axisHelper.createScaleByModel(axisModel);
  scale.setExtent(dataExtent[0], dataExtent[1]);
  axisHelper.niceScaleExtent(scale, axisModel);
  return scale;
}
/**
 * Mixin common methods to axis model,
 *
 * Inlcude methods
 * `getFormattedLabels() => Array.<string>`
 * `getCategories() => Array.<string>`
 * `getMin(origin: boolean) => number`
 * `getMax(origin: boolean) => number`
 * `getNeedCrossZero() => boolean`
 * `setRange(start: number, end: number)`
 * `resetRange()`
 */


function mixinAxisModelCommonMethods(Model) {
  zrUtil.mixin(Model, axisModelCommonMixin);
}

exports.createList = createList;
exports.createScale = createScale;
exports.mixinAxisModelCommonMethods = mixinAxisModelCommonMethods;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Scale = __webpack_require__(124);

/**
 * Linear continuous scale
 * @module echarts/coord/scale/Ordinal
 *
 * http://en.wikipedia.org/wiki/Level_of_measurement
 */
// FIXME only one data
var scaleProto = Scale.prototype;
var OrdinalScale = Scale.extend({
  type: 'ordinal',
  init: function (data, extent) {
    this._data = data;
    this._extent = extent || [0, data.length - 1];
  },
  parse: function (val) {
    return typeof val === 'string' ? zrUtil.indexOf(this._data, val) // val might be float.
    : Math.round(val);
  },
  contain: function (rank) {
    rank = this.parse(rank);
    return scaleProto.contain.call(this, rank) && this._data[rank] != null;
  },

  /**
   * Normalize given rank or name to linear [0, 1]
   * @param {number|string} [val]
   * @return {number}
   */
  normalize: function (val) {
    return scaleProto.normalize.call(this, this.parse(val));
  },
  scale: function (val) {
    return Math.round(scaleProto.scale.call(this, val));
  },

  /**
   * @return {Array}
   */
  getTicks: function () {
    var ticks = [];
    var extent = this._extent;
    var rank = extent[0];

    while (rank <= extent[1]) {
      ticks.push(rank);
      rank++;
    }

    return ticks;
  },

  /**
   * Get item on rank n
   * @param {number} n
   * @return {string}
   */
  getLabel: function (n) {
    return this._data[n];
  },

  /**
   * @return {number}
   */
  count: function () {
    return this._extent[1] - this._extent[0] + 1;
  },

  /**
   * @override
   */
  unionExtentFromData: function (data, dim) {
    this.unionExtent(data.getDataExtent(dim, false));
  },
  niceTicks: zrUtil.noop,
  niceExtent: zrUtil.noop
});
/**
 * @return {module:echarts/scale/Time}
 */

OrdinalScale.create = function () {
  return new OrdinalScale();
};

var _default = OrdinalScale;
module.exports = _default;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var numberUtil = __webpack_require__(94);

var formatUtil = __webpack_require__(99);

var scaleHelper = __webpack_require__(160);

var IntervalScale = __webpack_require__(135);

// [About UTC and local time zone]:
// In most cases, `number.parseDate` will treat input data string as local time
// (except time zone is specified in time string). And `format.formateTime` returns
// local time by default. option.useUTC is false by default. This design have
// concidered these common case:
// (1) Time that is persistent in server is in UTC, but it is needed to be diplayed
// in local time by default.
// (2) By default, the input data string (e.g., '2011-01-02') should be displayed
// as its original time, without any time difference.
var intervalScaleProto = IntervalScale.prototype;
var mathCeil = Math.ceil;
var mathFloor = Math.floor;
var ONE_SECOND = 1000;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24; // FIXME 公用？

var bisect = function (a, x, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;

    if (a[mid][1] < x) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }

  return lo;
};
/**
 * @alias module:echarts/coord/scale/Time
 * @constructor
 */


var TimeScale = IntervalScale.extend({
  type: 'time',

  /**
   * @override
   */
  getLabel: function (val) {
    var stepLvl = this._stepLvl;
    var date = new Date(val);
    return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));
  },

  /**
   * @override
   */
  niceExtent: function (opt) {
    var extent = this._extent; // If extent start and end are same, expand them

    if (extent[0] === extent[1]) {
      // Expand extent
      extent[0] -= ONE_DAY;
      extent[1] += ONE_DAY;
    } // If there are no data and extent are [Infinity, -Infinity]


    if (extent[1] === -Infinity && extent[0] === Infinity) {
      var d = new Date();
      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
      extent[0] = extent[1] - ONE_DAY;
    }

    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;

    var interval = this._interval;

    if (!opt.fixMin) {
      extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
    }

    if (!opt.fixMax) {
      extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
    }
  },

  /**
   * @override
   */
  niceTicks: function (approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    var extent = this._extent;
    var span = extent[1] - extent[0];
    var approxInterval = span / approxTickNum;

    if (minInterval != null && approxInterval < minInterval) {
      approxInterval = minInterval;
    }

    if (maxInterval != null && approxInterval > maxInterval) {
      approxInterval = maxInterval;
    }

    var scaleLevelsLen = scaleLevels.length;
    var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
    var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
    var interval = level[1]; // Same with interval scale if span is much larger than 1 year

    if (level[0] === 'year') {
      var yearSpan = span / interval; // From "Nice Numbers for Graph Labels" of Graphic Gems
      // var niceYearSpan = numberUtil.nice(yearSpan, false);

      var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);
      interval *= yearStep;
    }

    var timezoneOffset = this.getSetting('useUTC') ? 0 : new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 60 * 1000;
    var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];
    scaleHelper.fixExtent(niceExtent, extent);
    this._stepLvl = level; // Interval will be used in getTicks

    this._interval = interval;
    this._niceExtent = niceExtent;
  },
  parse: function (val) {
    // val might be float.
    return +numberUtil.parseDate(val);
  }
});
zrUtil.each(['contain', 'normalize'], function (methodName) {
  TimeScale.prototype[methodName] = function (val) {
    return intervalScaleProto[methodName].call(this, this.parse(val));
  };
}); // Steps from d3

var scaleLevels = [// Format              interval
['hh:mm:ss', ONE_SECOND], // 1s
['hh:mm:ss', ONE_SECOND * 5], // 5s
['hh:mm:ss', ONE_SECOND * 10], // 10s
['hh:mm:ss', ONE_SECOND * 15], // 15s
['hh:mm:ss', ONE_SECOND * 30], // 30s
['hh:mm\nMM-dd', ONE_MINUTE], // 1m
['hh:mm\nMM-dd', ONE_MINUTE * 5], // 5m
['hh:mm\nMM-dd', ONE_MINUTE * 10], // 10m
['hh:mm\nMM-dd', ONE_MINUTE * 15], // 15m
['hh:mm\nMM-dd', ONE_MINUTE * 30], // 30m
['hh:mm\nMM-dd', ONE_HOUR], // 1h
['hh:mm\nMM-dd', ONE_HOUR * 2], // 2h
['hh:mm\nMM-dd', ONE_HOUR * 6], // 6h
['hh:mm\nMM-dd', ONE_HOUR * 12], // 12h
['MM-dd\nyyyy', ONE_DAY], // 1d
['MM-dd\nyyyy', ONE_DAY * 2], // 2d
['MM-dd\nyyyy', ONE_DAY * 3], // 3d
['MM-dd\nyyyy', ONE_DAY * 4], // 4d
['MM-dd\nyyyy', ONE_DAY * 5], // 5d
['MM-dd\nyyyy', ONE_DAY * 6], // 6d
['week', ONE_DAY * 7], // 7d
['MM-dd\nyyyy', ONE_DAY * 10], // 10d
['week', ONE_DAY * 14], // 2w
['week', ONE_DAY * 21], // 3w
['month', ONE_DAY * 31], // 1M
['week', ONE_DAY * 42], // 6w
['month', ONE_DAY * 62], // 2M
['week', ONE_DAY * 42], // 10w
['quarter', ONE_DAY * 380 / 4], // 3M
['month', ONE_DAY * 31 * 4], // 4M
['month', ONE_DAY * 31 * 5], // 5M
['half-year', ONE_DAY * 380 / 2], // 6M
['month', ONE_DAY * 31 * 8], // 8M
['month', ONE_DAY * 31 * 10], // 10M
['year', ONE_DAY * 380] // 1Y
];
/**
 * @param {module:echarts/model/Model}
 * @return {module:echarts/scale/Time}
 */

TimeScale.create = function (model) {
  return new TimeScale({
    useUTC: model.ecModel.get('useUTC')
  });
};

var _default = TimeScale;
module.exports = _default;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Scale = __webpack_require__(124);

var numberUtil = __webpack_require__(94);

var IntervalScale = __webpack_require__(135);

/**
 * Log scale
 * @module echarts/scale/Log
 */
// Use some method of IntervalScale
var scaleProto = Scale.prototype;
var intervalScaleProto = IntervalScale.prototype;
var getPrecisionSafe = numberUtil.getPrecisionSafe;
var roundingErrorFix = numberUtil.round;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var mathPow = Math.pow;
var mathLog = Math.log;
var LogScale = Scale.extend({
  type: 'log',
  base: 10,
  $constructor: function () {
    Scale.apply(this, arguments);
    this._originalScale = new IntervalScale();
  },

  /**
   * @return {Array.<number>}
   */
  getTicks: function () {
    var originalScale = this._originalScale;
    var extent = this._extent;
    var originalExtent = originalScale.getExtent();
    return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {
      var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158

      powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
      powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
      return powVal;
    }, this);
  },

  /**
   * @param {number} val
   * @return {string}
   */
  getLabel: intervalScaleProto.getLabel,

  /**
   * @param  {number} val
   * @return {number}
   */
  scale: function (val) {
    val = scaleProto.scale.call(this, val);
    return mathPow(this.base, val);
  },

  /**
   * @param {number} start
   * @param {number} end
   */
  setExtent: function (start, end) {
    var base = this.base;
    start = mathLog(start) / mathLog(base);
    end = mathLog(end) / mathLog(base);
    intervalScaleProto.setExtent.call(this, start, end);
  },

  /**
   * @return {number} end
   */
  getExtent: function () {
    var base = this.base;
    var extent = scaleProto.getExtent.call(this);
    extent[0] = mathPow(base, extent[0]);
    extent[1] = mathPow(base, extent[1]); // Fix #4158

    var originalScale = this._originalScale;
    var originalExtent = originalScale.getExtent();
    originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
    originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
    return extent;
  },

  /**
   * @param  {Array.<number>} extent
   */
  unionExtent: function (extent) {
    this._originalScale.unionExtent(extent);

    var base = this.base;
    extent[0] = mathLog(extent[0]) / mathLog(base);
    extent[1] = mathLog(extent[1]) / mathLog(base);
    scaleProto.unionExtent.call(this, extent);
  },

  /**
   * @override
   */
  unionExtentFromData: function (data, dim) {
    this.unionExtent(data.getDataExtent(dim, true, function (val) {
      return val > 0;
    }));
  },

  /**
   * Update interval and extent of intervals for nice ticks
   * @param  {number} [approxTickNum = 10] Given approx tick number
   */
  niceTicks: function (approxTickNum) {
    approxTickNum = approxTickNum || 10;
    var extent = this._extent;
    var span = extent[1] - extent[0];

    if (span === Infinity || span <= 0) {
      return;
    }

    var interval = numberUtil.quantity(span);
    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.

    if (err <= 0.5) {
      interval *= 10;
    } // Interval should be integer


    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }

    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];
    this._interval = interval;
    this._niceExtent = niceExtent;
  },

  /**
   * Nice extent.
   * @override
   */
  niceExtent: function (opt) {
    intervalScaleProto.niceExtent.call(this, opt);
    var originalScale = this._originalScale;
    originalScale.__fixMin = opt.fixMin;
    originalScale.__fixMax = opt.fixMax;
  }
});
zrUtil.each(['contain', 'normalize'], function (methodName) {
  LogScale.prototype[methodName] = function (val) {
    val = mathLog(val) / mathLog(this.base);
    return scaleProto[methodName].call(this, val);
  };
});

LogScale.create = function () {
  return new LogScale();
};

function fixRoundingError(val, originalVal) {
  return roundingErrorFix(val, getPrecisionSafe(originalVal));
}

var _default = LogScale;
module.exports = _default;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Region = __webpack_require__(238);

/**
 * Parse and decode geo json
 * @module echarts/coord/geo/parseGeoJson
 */
function decode(json) {
  if (!json.UTF8Encoding) {
    return json;
  }

  var encodeScale = json.UTF8Scale;

  if (encodeScale == null) {
    encodeScale = 1024;
  }

  var features = json.features;

  for (var f = 0; f < features.length; f++) {
    var feature = features[f];
    var geometry = feature.geometry;
    var coordinates = geometry.coordinates;
    var encodeOffsets = geometry.encodeOffsets;

    for (var c = 0; c < coordinates.length; c++) {
      var coordinate = coordinates[c];

      if (geometry.type === 'Polygon') {
        coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);
      } else if (geometry.type === 'MultiPolygon') {
        for (var c2 = 0; c2 < coordinate.length; c2++) {
          var polygon = coordinate[c2];
          coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);
        }
      }
    }
  } // Has been decoded


  json.UTF8Encoding = false;
  return json;
}

function decodePolygon(coordinate, encodeOffsets, encodeScale) {
  var result = [];
  var prevX = encodeOffsets[0];
  var prevY = encodeOffsets[1];

  for (var i = 0; i < coordinate.length; i += 2) {
    var x = coordinate.charCodeAt(i) - 64;
    var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding

    x = x >> 1 ^ -(x & 1);
    y = y >> 1 ^ -(y & 1); // Delta deocding

    x += prevX;
    y += prevY;
    prevX = x;
    prevY = y; // Dequantize

    result.push([x / encodeScale, y / encodeScale]);
  }

  return result;
}
/**
 * @alias module:echarts/coord/geo/parseGeoJson
 * @param {Object} geoJson
 * @return {module:zrender/container/Group}
 */


function _default(geoJson) {
  decode(geoJson);
  return zrUtil.map(zrUtil.filter(geoJson.features, function (featureObj) {
    // Output of mapshaper may have geometry null
    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
  }), function (featureObj) {
    var properties = featureObj.properties;
    var geo = featureObj.geometry;
    var coordinates = geo.coordinates;
    var geometries = [];

    if (geo.type === 'Polygon') {
      geometries.push({
        type: 'polygon',
        // According to the GeoJSON specification.
        // First must be exterior, and the rest are all interior(holes).
        exterior: coordinates[0],
        interiors: coordinates.slice(1)
      });
    }

    if (geo.type === 'MultiPolygon') {
      zrUtil.each(coordinates, function (item) {
        if (item[0]) {
          geometries.push({
            type: 'polygon',
            exterior: item[0],
            interiors: item.slice(1)
          });
        }
      });
    }

    var region = new Region(properties.name, geometries, properties.cp);
    region.properties = properties;
    return region;
  });
}

module.exports = _default;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var BoundingRect = __webpack_require__(101);

var bbox = __webpack_require__(151);

var vec2 = __webpack_require__(97);

var polygonContain = __webpack_require__(239);

/**
 * @module echarts/coord/geo/Region
 */

/**
 * @param {string} name
 * @param {Array} geometries
 * @param {Array.<number>} cp
 */
function Region(name, geometries, cp) {
  /**
   * @type {string}
   * @readOnly
   */
  this.name = name;
  /**
   * @type {Array.<Array>}
   * @readOnly
   */

  this.geometries = geometries;

  if (!cp) {
    var rect = this.getBoundingRect();
    cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  } else {
    cp = [cp[0], cp[1]];
  }
  /**
   * @type {Array.<number>}
   */


  this.center = cp;
}

Region.prototype = {
  constructor: Region,
  properties: null,

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function () {
    var rect = this._rect;

    if (rect) {
      return rect;
    }

    var MAX_NUMBER = Number.MAX_VALUE;
    var min = [MAX_NUMBER, MAX_NUMBER];
    var max = [-MAX_NUMBER, -MAX_NUMBER];
    var min2 = [];
    var max2 = [];
    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      // Only support polygon
      if (geometries[i].type !== 'polygon') {
        continue;
      } // Doesn't consider hole


      var exterior = geometries[i].exterior;
      bbox.fromPoints(exterior, min2, max2);
      vec2.min(min, min, min2);
      vec2.max(max, max, max2);
    } // No data


    if (i === 0) {
      min[0] = min[1] = max[0] = max[1] = 0;
    }

    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
  },

  /**
   * @param {<Array.<number>} coord
   * @return {boolean}
   */
  contain: function (coord) {
    var rect = this.getBoundingRect();
    var geometries = this.geometries;

    if (!rect.contain(coord[0], coord[1])) {
      return false;
    }

    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {
      // Only support polygon.
      if (geometries[i].type !== 'polygon') {
        continue;
      }

      var exterior = geometries[i].exterior;
      var interiors = geometries[i].interiors;

      if (polygonContain.contain(exterior, coord[0], coord[1])) {
        // Not in the region if point is in the hole.
        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
          if (polygonContain.contain(interiors[k])) {
            continue loopGeo;
          }
        }

        return true;
      }
    }

    return false;
  },
  transformTo: function (x, y, width, height) {
    var rect = this.getBoundingRect();
    var aspect = rect.width / rect.height;

    if (!width) {
      width = aspect * height;
    } else if (!height) {
      height = width / aspect;
    }

    var target = new BoundingRect(x, y, width, height);
    var transform = rect.calculateTransform(target);
    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      // Only support polygon.
      if (geometries[i].type !== 'polygon') {
        continue;
      }

      var exterior = geometries[i].exterior;
      var interiors = geometries[i].interiors;

      for (var p = 0; p < exterior.length; p++) {
        vec2.applyTransform(exterior[p], exterior[p], transform);
      }

      for (var h = 0; h < (interiors ? interiors.length : 0); h++) {
        for (var p = 0; p < interiors[h].length; p++) {
          vec2.applyTransform(interiors[h][p], interiors[h][p], transform);
        }
      }
    }

    rect = this._rect;
    rect.copy(target); // Update center

    this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }
};
var _default = Region;
module.exports = _default;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var windingLine = __webpack_require__(153);

var EPSILON = 1e-8;

function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}

function contain(points, x, y) {
  var w = 0;
  var p = points[0];

  if (!p) {
    return false;
  }

  for (var i = 1; i < points.length; i++) {
    var p2 = points[i];
    w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
    p = p2;
  } // Close polygon


  var p0 = points[0];

  if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {
    w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
  }

  return w !== 0;
}

exports.contain = contain;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var barLayoutGrid = __webpack_require__(241);

__webpack_require__(163);

__webpack_require__(248);

__webpack_require__(250);

__webpack_require__(165);

// In case developer forget to include grid component
echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar')); // Visual coding for legend

echarts.registerVisual(function (ecModel) {
  ecModel.eachSeriesByType('bar', function (seriesModel) {
    var data = seriesModel.getData();
    data.setVisual('legendSymbol', 'roundRect');
  });
});

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var _number = __webpack_require__(94);

var parsePercent = _number.parsePercent;
var STACK_PREFIX = '__ec_stack_';

function getSeriesStackId(seriesModel) {
  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;
}

function getAxisKey(axis) {
  return axis.dim + axis.index;
}
/**
 * @param {Object} opt
 * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.
 * @param {number} opt.count Positive interger.
 * @param {number} [opt.barWidth]
 * @param {number} [opt.barMaxWidth]
 * @param {number} [opt.barGap]
 * @param {number} [opt.barCategoryGap]
 * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
 */


function getLayoutOnAxis(opt, api) {
  var params = [];
  var baseAxis = opt.axis;
  var axisKey = 'axis0';

  if (baseAxis.type !== 'category') {
    return;
  }

  var bandWidth = baseAxis.getBandWidth();

  for (var i = 0; i < opt.count || 0; i++) {
    params.push(zrUtil.defaults({
      bandWidth: bandWidth,
      axisKey: axisKey,
      stackId: STACK_PREFIX + i
    }, opt));
  }

  var widthAndOffsets = doCalBarWidthAndOffset(params, api);
  var result = [];

  for (var i = 0; i < opt.count; i++) {
    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
    item.offsetCenter = item.offset + item.width / 2;
    result.push(item);
  }

  return result;
}

function calBarWidthAndOffset(barSeries, api) {
  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {
    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var axisExtent = baseAxis.getExtent();
    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);
    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);
    var barGap = seriesModel.get('barGap');
    var barCategoryGap = seriesModel.get('barCategoryGap');
    return {
      bandWidth: bandWidth,
      barWidth: barWidth,
      barMaxWidth: barMaxWidth,
      barGap: barGap,
      barCategoryGap: barCategoryGap,
      axisKey: getAxisKey(baseAxis),
      stackId: getSeriesStackId(seriesModel)
    };
  });
  return doCalBarWidthAndOffset(seriesInfoList, api);
}

function doCalBarWidthAndOffset(seriesInfoList, api) {
  // Columns info on each category axis. Key is cartesian name
  var columnsMap = {};
  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {
    var axisKey = seriesInfo.axisKey;
    var bandWidth = seriesInfo.bandWidth;
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth: bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: '20%',
      gap: '30%',
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = seriesInfo.stackId;

    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }

    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    }; // Caution: In a single coordinate system, these barGrid attributes
    // will be shared by series. Consider that they have default values,
    // only the attributes set on the last series will work.
    // Do not change this fact unless there will be a break change.
    // TODO

    var barWidth = seriesInfo.barWidth;

    if (barWidth && !stacks[stackId].width) {
      // See #6312, do not restrict width.
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }

    var barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    var barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    var barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth

    zrUtil.each(stacks, function (column, stack) {
      var maxWidth = column.maxWidth;

      if (maxWidth && maxWidth < autoWidth) {
        maxWidth = Math.min(maxWidth, remainedWidth);

        if (column.width) {
          maxWidth = Math.min(maxWidth, column.width);
        }

        remainedWidth -= maxWidth;
        column.width = maxWidth;
        autoWidthCount--;
      }
    }); // Recalculate width again

    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    zrUtil.each(stacks, function (column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }

      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });

    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }

    var offset = -widthSum / 2;
    zrUtil.each(stacks, function (column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        offset: offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
/**
 * @param {string} seriesType
 * @param {module:echarts/model/Global} ecModel
 * @param {module:echarts/ExtensionAPI} api
 */


function barLayoutGrid(seriesType, ecModel, api) {
  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {
    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';
  }));
  var lastStackCoords = {};
  var lastStackCoordsOrigin = {};
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    // Check series coordinate, do layout for cartesian2d only
    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {
      return;
    }

    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var stackId = getSeriesStackId(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    var valueAxis = cartesian.getOtherAxis(baseAxis);
    var barMinHeight = seriesModel.get('barMinHeight') || 0;
    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];
    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];
    var coords = data.mapArray(coordDims, function (x, y) {
      return cartesian.dataToPoint([x, y]);
    }, true);
    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243

    data.setLayout({
      offset: columnOffset,
      size: columnWidth
    });
    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {
      if (isNaN(value)) {
        return;
      }

      if (!lastStackCoords[stackId][idx]) {
        lastStackCoords[stackId][idx] = {
          p: valueAxisStart,
          // Positive stack
          n: valueAxisStart // Negative stack

        };
        lastStackCoordsOrigin[stackId][idx] = {
          p: valueAxisStart,
          // Positive stack
          n: valueAxisStart // Negative stack

        };
      }

      var sign = value >= 0 ? 'p' : 'n';
      var coord = coords[idx];
      var lastCoord = lastStackCoords[stackId][idx][sign];
      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];
      var x;
      var y;
      var width;
      var height;

      if (valueAxis.isHorizontal()) {
        x = lastCoord;
        y = coord[1] + columnOffset;
        width = coord[0] - lastCoordOrigin;
        height = columnWidth;
        lastStackCoordsOrigin[stackId][idx][sign] += width;

        if (Math.abs(width) < barMinHeight) {
          width = (width < 0 ? -1 : 1) * barMinHeight;
        }

        lastStackCoords[stackId][idx][sign] += width;
      } else {
        x = coord[0] + columnOffset;
        y = lastCoord;
        width = columnWidth;
        height = coord[1] - lastCoordOrigin;
        lastStackCoordsOrigin[stackId][idx][sign] += height;

        if (Math.abs(height) < barMinHeight) {
          // Include zero to has a positive bar
          height = (height <= 0 ? -1 : 1) * barMinHeight;
        }

        lastStackCoords[stackId][idx][sign] += height;
      }

      data.setItemLayout(idx, {
        x: x,
        y: y,
        width: width,
        height: height
      });
    }, true);
  }, this);
}

barLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;
var _default = barLayoutGrid;
module.exports = _default;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Cartesian = __webpack_require__(243);

function Cartesian2D(name) {
  Cartesian.call(this, name);
}

Cartesian2D.prototype = {
  constructor: Cartesian2D,
  type: 'cartesian2d',

  /**
   * @type {Array.<string>}
   * @readOnly
   */
  dimensions: ['x', 'y'],

  /**
   * Base axis will be used on stacking.
   *
   * @return {module:echarts/coord/cartesian/Axis2D}
   */
  getBaseAxis: function () {
    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
  },

  /**
   * If contain point
   * @param {Array.<number>} point
   * @return {boolean}
   */
  containPoint: function (point) {
    var axisX = this.getAxis('x');
    var axisY = this.getAxis('y');
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  },

  /**
   * If contain data
   * @param {Array.<number>} data
   * @return {boolean}
   */
  containData: function (data) {
    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
  },

  /**
   * @param {Array.<number>} data
   * @param {boolean} [clamp=false]
   * @return {Array.<number>}
   */
  dataToPoint: function (data, clamp) {
    var xAxis = this.getAxis('x');
    var yAxis = this.getAxis('y');
    return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];
  },

  /**
   * @param {Array.<number>} point
   * @param {boolean} [clamp=false]
   * @return {Array.<number>}
   */
  pointToData: function (point, clamp) {
    var xAxis = this.getAxis('x');
    var yAxis = this.getAxis('y');
    return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];
  },

  /**
   * Get other axis
   * @param {module:echarts/coord/cartesian/Axis2D} axis
   */
  getOtherAxis: function (axis) {
    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
  }
};
zrUtil.inherits(Cartesian2D, Cartesian);
var _default = Cartesian2D;
module.exports = _default;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

/**
 * Cartesian coordinate system
 * @module  echarts/coord/Cartesian
 *
 */
function dimAxisMapper(dim) {
  return this._axes[dim];
}
/**
 * @alias module:echarts/coord/Cartesian
 * @constructor
 */


var Cartesian = function (name) {
  this._axes = {};
  this._dimList = [];
  /**
   * @type {string}
   */

  this.name = name || '';
};

Cartesian.prototype = {
  constructor: Cartesian,
  type: 'cartesian',

  /**
   * Get axis
   * @param  {number|string} dim
   * @return {module:echarts/coord/Cartesian~Axis}
   */
  getAxis: function (dim) {
    return this._axes[dim];
  },

  /**
   * Get axes list
   * @return {Array.<module:echarts/coord/Cartesian~Axis>}
   */
  getAxes: function () {
    return zrUtil.map(this._dimList, dimAxisMapper, this);
  },

  /**
   * Get axes list by given scale type
   */
  getAxesByScale: function (scaleType) {
    scaleType = scaleType.toLowerCase();
    return zrUtil.filter(this.getAxes(), function (axis) {
      return axis.scale.type === scaleType;
    });
  },

  /**
   * Add axis
   * @param {module:echarts/coord/Cartesian.Axis}
   */
  addAxis: function (axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;

    this._dimList.push(dim);
  },

  /**
   * Convert data to coord in nd space
   * @param {Array.<number>|Object.<string, number>} val
   * @return {Array.<number>|Object.<string, number>}
   */
  dataToCoord: function (val) {
    return this._dataCoordConvert(val, 'dataToCoord');
  },

  /**
   * Convert coord in nd space to data
   * @param  {Array.<number>|Object.<string, number>} val
   * @return {Array.<number>|Object.<string, number>}
   */
  coordToData: function (val) {
    return this._dataCoordConvert(val, 'coordToData');
  },
  _dataCoordConvert: function (input, method) {
    var dimList = this._dimList;
    var output = input instanceof Array ? [] : {};

    for (var i = 0; i < dimList.length; i++) {
      var dim = dimList[i];
      var axis = this._axes[dim];
      output[dim] = axis[method](input[dim]);
    }

    return output;
  }
};
var _default = Cartesian;
module.exports = _default;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Axis = __webpack_require__(162);

/**
 * Extend axis 2d
 * @constructor module:echarts/coord/cartesian/Axis2D
 * @extends {module:echarts/coord/cartesian/Axis}
 * @param {string} dim
 * @param {*} scale
 * @param {Array.<number>} coordExtent
 * @param {string} axisType
 * @param {string} position
 */
var Axis2D = function (dim, scale, coordExtent, axisType, position) {
  Axis.call(this, dim, scale, coordExtent);
  /**
   * Axis type
   *  - 'category'
   *  - 'value'
   *  - 'time'
   *  - 'log'
   * @type {string}
   */

  this.type = axisType || 'value';
  /**
   * Axis position
   *  - 'top'
   *  - 'bottom'
   *  - 'left'
   *  - 'right'
   */

  this.position = position || 'bottom';
};

Axis2D.prototype = {
  constructor: Axis2D,

  /**
   * Index of axis, can be used as key
   */
  index: 0,

  /**
   * If axis is on the zero position of the other axis
   * @type {boolean}
   */
  onZero: false,

  /**
   * Axis model
   * @param {module:echarts/coord/cartesian/AxisModel}
   */
  model: null,
  isHorizontal: function () {
    var position = this.position;
    return position === 'top' || position === 'bottom';
  },

  /**
   * Each item cooresponds to this.getExtent(), which
   * means globalExtent[0] may greater than globalExtent[1],
   * unless `asc` is input.
   *
   * @param {boolean} [asc]
   * @return {Array.<number>}
   */
  getGlobalExtent: function (asc) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc && ret[0] > ret[1] && ret.reverse();
    return ret;
  },
  getOtherAxis: function () {
    this.grid.getOtherAxis();
  },

  /**
   * If label is ignored.
   * Automatically used when axis is category and label can not be all shown
   * @param  {number}  idx
   * @return {boolean}
   */
  isLabelIgnored: function (idx) {
    if (this.type === 'category') {
      var labelInterval = this.getLabelInterval();
      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);
    }
  },

  /**
   * @override
   */
  pointToData: function (point, clamp) {
    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);
  },

  /**
   * Transform global coord to local coord,
   * i.e. var localCoord = axis.toLocalCoord(80);
   * designate by module:echarts/coord/cartesian/Grid.
   * @type {Function}
   */
  toLocalCoord: null,

  /**
   * Transform global coord to local coord,
   * i.e. var globalCoord = axis.toLocalCoord(40);
   * designate by module:echarts/coord/cartesian/Grid.
   * @type {Function}
   */
  toGlobalCoord: null
};
zrUtil.inherits(Axis2D, Axis);
var _default = Axis2D;
module.exports = _default;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(164);

var ComponentModel = __webpack_require__(105);

// Grid 是在有直角坐标系的时候必须要存在的
// 所以这里也要被 Cartesian2D 依赖
var _default = ComponentModel.extend({
  type: 'grid',
  dependencies: ['xAxis', 'yAxis'],
  layoutMode: 'box',

  /**
   * @type {module:echarts/coord/cartesian/Grid}
   */
  coordinateSystem: null,
  defaultOption: {
    show: false,
    zlevel: 0,
    z: 0,
    left: '10%',
    top: 60,
    right: '10%',
    bottom: 60,
    // If grid size contain label
    containLabel: false,
    // width: {totalWidth} - left - right,
    // height: {totalHeight} - top - bottom,
    backgroundColor: 'rgba(0,0,0,0)',
    borderWidth: 1,
    borderColor: '#ccc'
  }
});

module.exports = _default;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var axisDefault = __webpack_require__(247);

var ComponentModel = __webpack_require__(105);

var _layout = __webpack_require__(103);

var getLayoutParams = _layout.getLayoutParams;
var mergeLayoutParam = _layout.mergeLayoutParam;
// FIXME axisType is fixed ?
var AXIS_TYPES = ['value', 'category', 'time', 'log'];
/**
 * Generate sub axis model class
 * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
 * @param {module:echarts/model/Component} BaseAxisModelClass
 * @param {Function} axisTypeDefaulter
 * @param {Object} [extraDefaultOption]
 */

function _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
  zrUtil.each(AXIS_TYPES, function (axisType) {
    BaseAxisModelClass.extend({
      type: axisName + 'Axis.' + axisType,
      mergeDefaultAndTheme: function (option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));
        zrUtil.merge(option, this.getDefaultOption());
        option.type = axisTypeDefaulter(axisName, option);

        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      },
      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)
    });
  });
  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));
}

module.exports = _default;

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var defaultOption = {
  show: true,
  zlevel: 0,
  // 一级层叠
  z: 0,
  // 二级层叠
  // 反向坐标轴
  inverse: false,
  // 坐标轴名字，默认为空
  name: '',
  // 坐标轴名字位置，支持'start' | 'middle' | 'end'
  nameLocation: 'end',
  // 坐标轴名字旋转，degree。
  nameRotate: null,
  // Adapt to axis rotate, when nameLocation is 'middle'.
  nameTruncate: {
    maxWidth: null,
    ellipsis: '...',
    placeholder: '.'
  },
  // 坐标轴文字样式，默认取全局样式
  nameTextStyle: {},
  // 文字与轴线距离
  nameGap: 15,
  silent: false,
  // Default false to support tooltip.
  triggerEvent: false,
  // Default false to avoid legacy user event listener fail.
  tooltip: {
    show: false
  },
  axisPointer: {},
  // 坐标轴线
  axisLine: {
    // 默认显示，属性show控制显示与否
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    // 属性lineStyle控制线条样式
    lineStyle: {
      color: '#333',
      width: 1,
      type: 'solid'
    },
    // 坐标轴两端的箭头
    symbol: ['none', 'none'],
    symbolSize: [10, 15]
  },
  // 坐标轴小标记
  axisTick: {
    // 属性show控制显示与否，默认显示
    show: true,
    // 控制小标记是否在grid里
    inside: false,
    // 属性length控制线长
    length: 5,
    // 属性lineStyle控制线条样式
    lineStyle: {
      width: 1
    }
  },
  // 坐标轴文本标签，详见axis.axisLabel
  axisLabel: {
    show: true,
    // 控制文本标签是否在grid里
    inside: false,
    rotate: 0,
    showMinLabel: null,
    // true | false | null (auto)
    showMaxLabel: null,
    // true | false | null (auto)
    margin: 8,
    // formatter: null,
    // 其余属性默认使用全局文本样式，详见TEXTSTYLE
    fontSize: 12
  },
  // 分隔线
  splitLine: {
    // 默认显示，属性show控制显示与否
    show: true,
    // 属性lineStyle（详见lineStyle）控制线条样式
    lineStyle: {
      color: ['#ccc'],
      width: 1,
      type: 'solid'
    }
  },
  // 分隔区域
  splitArea: {
    // 默认不显示，属性show控制显示与否
    show: false,
    // 属性areaStyle（详见areaStyle）控制区域样式
    areaStyle: {
      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']
    }
  }
};
var axisDefault = {};
axisDefault.categoryAxis = zrUtil.merge({
  // 类目起始和结束两端空白策略
  boundaryGap: true,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: false
  },
  // 坐标轴小标记
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: false,
    interval: 'auto'
  },
  // 坐标轴文本标签，详见axis.axisLabel
  axisLabel: {
    interval: 'auto'
  }
}, defaultOption);
axisDefault.valueAxis = zrUtil.merge({
  // 数值起始和结束两端空白策略
  boundaryGap: [0, 0],
  // 最小值, 设置成 'dataMin' 则从数据中计算最小值
  // min: null,
  // 最大值，设置成 'dataMax' 则从数据中计算最大值
  // max: null,
  // Readonly prop, specifies start value of the range when using data zoom.
  // rangeStart: null
  // Readonly prop, specifies end value of the range when using data zoom.
  // rangeEnd: null
  // 脱离0值比例，放大聚焦到最终_min，_max区间
  // scale: false,
  // 分割段数，默认为5
  splitNumber: 5 // Minimum interval
  // minInterval: null
  // maxInterval: null

}, defaultOption); // FIXME

axisDefault.timeAxis = zrUtil.defaults({
  scale: true,
  min: 'dataMin',
  max: 'dataMax'
}, axisDefault.valueAxis);
axisDefault.logAxis = zrUtil.defaults({
  scale: true,
  logBase: 10
}, axisDefault.valueAxis);
var _default = axisDefault;
module.exports = _default;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var BaseBarSeries = __webpack_require__(249);

var _default = BaseBarSeries.extend({
  type: 'series.bar',
  dependencies: ['grid', 'polar'],
  brushSelector: 'rect'
});

module.exports = _default;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

var SeriesModel = __webpack_require__(132);

var createListFromArray = __webpack_require__(133);

var _default = SeriesModel.extend({
  type: 'series.__base_bar__',
  getInitialData: function (option, ecModel) {
    return createListFromArray(option.data, this, ecModel);
  },
  getMarkerPosition: function (value) {
    var coordSys = this.coordinateSystem;

    if (coordSys) {
      // PENDING if clamp ?
      var pt = coordSys.dataToPoint(value, true);
      var data = this.getData();
      var offset = data.getLayout('offset');
      var size = data.getLayout('size');
      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
      pt[offsetIndex] += offset + size / 2;
      return pt;
    }

    return [NaN, NaN];
  },
  defaultOption: {
    zlevel: 0,
    // 一级层叠
    z: 2,
    // 二级层叠
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    // stack: null
    // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // 最小高度改为0
    barMinHeight: 0,
    // 最小角度为0，仅对极坐标系下的柱状图有效
    barMinAngle: 0,
    // cursor: null,
    // barMaxWidth: null,
    // 默认自适应
    // barWidth: null,
    // 柱间距离，默认为柱形宽度的30%，可设固定值
    // barGap: '30%',
    // 类目间柱形距离，默认为类目间距的20%，可设固定值
    // barCategoryGap: '20%',
    // label: {
    //     normal: {
    //         show: false
    //     }
    // },
    itemStyle: {// normal: {
      // color: '各异'
      // },
      // emphasis: {}
    }
  }
});

module.exports = _default;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var graphic = __webpack_require__(93);

var _helper = __webpack_require__(251);

var setLabel = _helper.setLabel;

var Model = __webpack_require__(102);

var barItemStyle = __webpack_require__(252);

var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth']; // FIXME
// Just for compatible with ec2.

zrUtil.extend(Model.prototype, barItemStyle);

var _default = echarts.extendChartView({
  type: 'bar',
  render: function (seriesModel, ecModel, api) {
    var coordinateSystemType = seriesModel.get('coordinateSystem');

    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
      this._render(seriesModel, ecModel, api);
    } else {}

    return this.group;
  },
  dispose: zrUtil.noop,
  _render: function (seriesModel, ecModel, api) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coord = seriesModel.coordinateSystem;
    var baseAxis = coord.getBaseAxis();
    var isHorizontalOrRadial;

    if (coord.type === 'cartesian2d') {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === 'polar') {
      isHorizontalOrRadial = baseAxis.dim === 'angle';
    }

    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    data.diff(oldData).add(function (dataIndex) {
      if (!data.hasValue(dataIndex)) {
        return;
      }

      var itemModel = data.getItemModel(dataIndex);
      var layout = getLayout[coord.type](data, dataIndex, itemModel);
      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);
      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
    }).update(function (newIndex, oldIndex) {
      var el = oldData.getItemGraphicEl(oldIndex);

      if (!data.hasValue(newIndex)) {
        group.remove(el);
        return;
      }

      var itemModel = data.getItemModel(newIndex);
      var layout = getLayout[coord.type](data, newIndex, itemModel);

      if (el) {
        graphic.updateProps(el, {
          shape: layout
        }, animationModel, newIndex);
      } else {
        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);
      }

      data.setItemGraphicEl(newIndex, el); // Add back

      group.add(el);
      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
    }).remove(function (dataIndex) {
      var el = oldData.getItemGraphicEl(dataIndex);

      if (coord.type === 'cartesian2d') {
        el && removeRect(dataIndex, animationModel, el);
      } else {
        el && removeSector(dataIndex, animationModel, el);
      }
    }).execute();
    this._data = data;
  },
  remove: function (ecModel, api) {
    var group = this.group;
    var data = this._data;

    if (ecModel.get('animation')) {
      if (data) {
        data.eachItemGraphicEl(function (el) {
          if (el.type === 'sector') {
            removeSector(el.dataIndex, ecModel, el);
          } else {
            removeRect(el.dataIndex, ecModel, el);
          }
        });
      }
    } else {
      group.removeAll();
    }
  }
});

var elementCreator = {
  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {
    var rect = new graphic.Rect({
      shape: zrUtil.extend({}, layout)
    }); // Animation

    if (animationModel) {
      var rectShape = rect.shape;
      var animateProperty = isHorizontal ? 'height' : 'width';
      var animateTarget = {};
      rectShape[animateProperty] = 0;
      animateTarget[animateProperty] = layout[animateProperty];
      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {
        shape: animateTarget
      }, animationModel, dataIndex);
    }

    return rect;
  },
  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {
    var sector = new graphic.Sector({
      shape: zrUtil.extend({}, layout)
    }); // Animation

    if (animationModel) {
      var sectorShape = sector.shape;
      var animateProperty = isRadial ? 'r' : 'endAngle';
      var animateTarget = {};
      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
      animateTarget[animateProperty] = layout[animateProperty];
      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {
        shape: animateTarget
      }, animationModel, dataIndex);
    }

    return sector;
  }
};

function removeRect(dataIndex, animationModel, el) {
  // Not show text when animating
  el.style.text = null;
  graphic.updateProps(el, {
    shape: {
      width: 0
    }
  }, animationModel, dataIndex, function () {
    el.parent && el.parent.remove(el);
  });
}

function removeSector(dataIndex, animationModel, el) {
  // Not show text when animating
  el.style.text = null;
  graphic.updateProps(el, {
    shape: {
      r: el.shape.r0
    }
  }, animationModel, dataIndex, function () {
    el.parent && el.parent.remove(el);
  });
}

var getLayout = {
  cartesian2d: function (data, dataIndex, itemModel) {
    var layout = data.getItemLayout(dataIndex);
    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth

    var signX = layout.width > 0 ? 1 : -1;
    var signY = layout.height > 0 ? 1 : -1;
    return {
      x: layout.x + signX * fixedLineWidth / 2,
      y: layout.y + signY * fixedLineWidth / 2,
      width: layout.width - signX * fixedLineWidth,
      height: layout.height - signY * fixedLineWidth
    };
  },
  polar: function (data, dataIndex, itemModel) {
    var layout = data.getItemLayout(dataIndex);
    return {
      cx: layout.cx,
      cy: layout.cy,
      r0: layout.r0,
      r: layout.r,
      startAngle: layout.startAngle,
      endAngle: layout.endAngle
    };
  }
};

function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
  var color = data.getItemVisual(dataIndex, 'color');
  var opacity = data.getItemVisual(dataIndex, 'opacity');
  var itemStyleModel = itemModel.getModel('itemStyle.normal');
  var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();

  if (!isPolar) {
    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);
  }

  el.useStyle(zrUtil.defaults({
    fill: color,
    opacity: opacity
  }, itemStyleModel.getBarItemStyle()));
  var cursorStyle = itemModel.getShallow('cursor');
  cursorStyle && el.attr('cursor', cursorStyle);
  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';

  if (!isPolar) {
    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);
  }

  graphic.setHoverStyle(el, hoverStyle);
} // In case width or height are too small.


function getLineWidth(itemModel, rawLayout) {
  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));
}

module.exports = _default;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__(93);

function setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {
  var labelModel = itemModel.getModel('label.normal');
  var hoverLabelModel = itemModel.getModel('label.emphasis');
  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: seriesModel.getRawValue(dataIndex),
    isRectText: true,
    autoColor: color
  });
  fixPosition(normalStyle);
  fixPosition(hoverStyle);
}

function fixPosition(style, labelPositionOutside) {
  if (style.textPosition === 'outside') {
    style.textPosition = labelPositionOutside;
  }
}

exports.setLabel = setLabel;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var makeStyleMapper = __webpack_require__(121);

var getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2
['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
var _default = {
  getBarItemStyle: function (excludes) {
    var style = getBarItemStyle(this, excludes);

    if (this.getBorderLineDash) {
      var lineDash = this.getBorderLineDash();
      lineDash && (style.lineDash = lineDash);
    }

    return style;
  }
};
module.exports = _default;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(164);

__webpack_require__(254);

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var graphic = __webpack_require__(93);

var AxisBuilder = __webpack_require__(166);

var AxisView = __webpack_require__(167);

var cartesianAxisHelper = __webpack_require__(168);

var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;
var getInterval = AxisBuilder.getInterval;
var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
var selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {
//     var alignWithLabel = model.get('alignWithLabel');
//     if (alignWithLabel === 'auto') {
//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');
//     }
//     return alignWithLabel;
// }

var CartesianAxisView = AxisView.extend({
  type: 'cartesianAxis',
  axisPointerClass: 'CartesianAxisPointer',

  /**
   * @override
   */
  render: function (axisModel, ecModel, api, payload) {
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new graphic.Group();
    this.group.add(this._axisGroup);

    if (!axisModel.get('show')) {
      return;
    }

    var gridModel = axisModel.getCoordSysModel();
    var layout = cartesianAxisHelper.layout(gridModel, axisModel);
    var axisBuilder = new AxisBuilder(axisModel, layout);
    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);

    this._axisGroup.add(axisBuilder.getGroup());

    zrUtil.each(selfBuilderAttrs, function (name) {
      if (axisModel.get(name + '.show')) {
        this['_' + name](axisModel, gridModel, layout.labelInterval);
      }
    }, this);
    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);
  },

  /**
   * @param {module:echarts/coord/cartesian/AxisModel} axisModel
   * @param {module:echarts/coord/cartesian/GridModel} gridModel
   * @param {number|Function} labelInterval
   * @private
   */
  _splitLine: function (axisModel, gridModel, labelInterval) {
    var axis = axisModel.axis;

    if (axis.scale.isBlank()) {
      return;
    }

    var splitLineModel = axisModel.getModel('splitLine');
    var lineStyleModel = splitLineModel.getModel('lineStyle');
    var lineColors = lineStyleModel.get('color');
    var lineInterval = getInterval(splitLineModel, labelInterval);
    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords();
    var ticks = axis.scale.getTicks();
    var showMinLabel = axisModel.get('axisLabel.showMinLabel');
    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');
    var p1 = [];
    var p2 = []; // Simple optimization
    // Batching the lines if color are the same

    var lineStyle = lineStyleModel.getLineStyle();

    for (var i = 0; i < ticksCoords.length; i++) {
      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {
        continue;
      }

      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);

      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }

      var colorIndex = lineCount++ % lineColors.length;

      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({
        anid: 'line_' + ticks[i],
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        style: zrUtil.defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      })));
    }
  },

  /**
   * @param {module:echarts/coord/cartesian/AxisModel} axisModel
   * @param {module:echarts/coord/cartesian/GridModel} gridModel
   * @param {number|Function} labelInterval
   * @private
   */
  _splitArea: function (axisModel, gridModel, labelInterval) {
    var axis = axisModel.axis;

    if (axis.scale.isBlank()) {
      return;
    }

    var splitAreaModel = axisModel.getModel('splitArea');
    var areaStyleModel = splitAreaModel.getModel('areaStyle');
    var areaColors = areaStyleModel.get('color');
    var gridRect = gridModel.coordinateSystem.getRect();
    var ticksCoords = axis.getTicksCoords();
    var ticks = axis.scale.getTicks();
    var prevX = axis.toGlobalCoord(ticksCoords[0]);
    var prevY = axis.toGlobalCoord(ticksCoords[0]);
    var count = 0;
    var areaInterval = getInterval(splitAreaModel, labelInterval);
    var areaStyle = areaStyleModel.getAreaStyle();
    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];
    var showMinLabel = axisModel.get('axisLabel.showMinLabel');
    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');

    for (var i = 1; i < ticksCoords.length; i++) {
      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {
        continue;
      }

      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);
      var x;
      var y;
      var width;
      var height;

      if (axis.isHorizontal()) {
        x = prevX;
        y = gridRect.y;
        width = tickCoord - x;
        height = gridRect.height;
      } else {
        x = gridRect.x;
        y = prevY;
        width = gridRect.width;
        height = tickCoord - y;
      }

      var colorIndex = count++ % areaColors.length;

      this._axisGroup.add(new graphic.Rect({
        anid: 'area_' + ticks[i],
        shape: {
          x: x,
          y: y,
          width: width,
          height: height
        },
        style: zrUtil.defaults({
          fill: areaColors[colorIndex]
        }, areaStyle),
        silent: true
      }));

      prevX = x + width;
      prevY = y + height;
    }
  }
});
CartesianAxisView.extend({
  type: 'xAxis'
});
CartesianAxisView.extend({
  type: 'yAxis'
});

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

__webpack_require__(256);

__webpack_require__(257);

var visualSymbol = __webpack_require__(261);

var layoutPoints = __webpack_require__(262);

var dataSample = __webpack_require__(263);

__webpack_require__(165);

// In case developer forget to include grid component
echarts.registerVisual(zrUtil.curry(visualSymbol, 'line', 'circle', 'line'));
echarts.registerLayout(zrUtil.curry(layoutPoints, 'line')); // Down sample after filter

echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(dataSample, 'line'));

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var createListFromArray = __webpack_require__(133);

var SeriesModel = __webpack_require__(132);

var _default = SeriesModel.extend({
  type: 'series.line',
  dependencies: ['grid', 'polar'],
  getInitialData: function (option, ecModel) {
    return createListFromArray(option.data, this, ecModel);
  },
  defaultOption: {
    zlevel: 0,
    // 一级层叠
    z: 2,
    // 二级层叠
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    hoverAnimation: true,
    // stack: null
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // polarIndex: 0,
    // If clip the overflow value
    clipOverflow: true,
    // cursor: null,
    label: {
      normal: {
        position: 'top'
      }
    },
    // itemStyle: {
    //     normal: {},
    //     emphasis: {}
    // },
    lineStyle: {
      normal: {
        width: 2,
        type: 'solid'
      }
    },
    // areaStyle: {},
    // false, 'start', 'end', 'middle'
    step: false,
    // Disabled if step is true
    smooth: false,
    smoothMonotone: null,
    // 拐点图形类型
    symbol: 'emptyCircle',
    // 拐点图形大小
    symbolSize: 4,
    // 拐点图形旋转控制
    symbolRotate: null,
    // 是否显示 symbol, 只有在 tooltip hover 的时候显示
    showSymbol: true,
    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）
    showAllSymbol: false,
    // 是否连接断点
    connectNulls: false,
    // 数据过滤，'average', 'max', 'min', 'sum'
    sampling: 'none',
    animationEasing: 'linear',
    // Disable progressive
    progressive: 0,
    hoverLayerThreshold: Infinity
  }
});

module.exports = _default;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__(91);

var SymbolDraw = __webpack_require__(169);

var SymbolClz = __webpack_require__(170);

var lineAnimationDiff = __webpack_require__(259);

var graphic = __webpack_require__(93);

var modelUtil = __webpack_require__(95);

var _poly = __webpack_require__(260);

var Polyline = _poly.Polyline;
var Polygon = _poly.Polygon;

var ChartView = __webpack_require__(158);

// FIXME step not support polar
function isPointsSame(points1, points2) {
  if (points1.length !== points2.length) {
    return;
  }

  for (var i = 0; i < points1.length; i++) {
    var p1 = points1[i];
    var p2 = points2[i];

    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
      return;
    }
  }

  return true;
}

function getSmooth(smooth) {
  return typeof smooth === 'number' ? smooth : smooth ? 0.3 : 0;
}

function getAxisExtentWithGap(axis) {
  var extent = axis.getGlobalExtent();

  if (axis.onBand) {
    // Remove extra 1px to avoid line miter in clipped edge
    var halfBandWidth = axis.getBandWidth() / 2 - 1;
    var dir = extent[1] > extent[0] ? 1 : -1;
    extent[0] += dir * halfBandWidth;
    extent[1] -= dir * halfBandWidth;
  }

  return extent;
}

function sign(val) {
  return val >= 0 ? 1 : -1;
}
/**
 * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys
 * @param {module:echarts/data/List} data
 * @param {Array.<Array.<number>>} points
 * @private
 */


function getStackedOnPoints(coordSys, data) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis = coordSys.getOtherAxis(baseAxis);
  var valueStart = 0;

  if (!baseAxis.onZero) {
    var extent = valueAxis.scale.getExtent();

    if (extent[0] > 0) {
      // Both positive
      valueStart = extent[0];
    } else if (extent[1] < 0) {
      // Both negative
      valueStart = extent[1];
    } // If is one positive, and one negative, onZero shall be true

  }

  var valueDim = valueAxis.dim;
  var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;
  return data.mapArray([valueDim], function (val, idx) {
    var stackedOnSameSign;
    var stackedOn = data.stackedOn; // Find first stacked value with same sign

    while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {
      stackedOnSameSign = stackedOn;
      break;
    }

    var stackedData = [];
    stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
    stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;
    return coordSys.dataToPoint(stackedData);
  }, true);
}

function createGridClipShape(cartesian, hasAnimation, seriesModel) {
  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));
  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));
  var isHorizontal = cartesian.getBaseAxis().isHorizontal();
  var x = Math.min(xExtent[0], xExtent[1]);
  var y = Math.min(yExtent[0], yExtent[1]);
  var width = Math.max(xExtent[0], xExtent[1]) - x;
  var height = Math.max(yExtent[0], yExtent[1]) - y;
  var lineWidth = seriesModel.get('lineStyle.normal.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis

  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);

  if (isHorizontal) {
    y -= expandSize;
    height += expandSize * 2;
  } else {
    x -= expandSize;
    width += expandSize * 2;
  }

  var clipPath = new graphic.Rect({
    shape: {
      x: x,
      y: y,
      width: width,
      height: height
    }
  });

  if (hasAnimation) {
    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;
    graphic.initProps(clipPath, {
      shape: {
        width: width,
        height: height
      }
    }, seriesModel);
  }

  return clipPath;
}

function createPolarClipShape(polar, hasAnimation, seriesModel) {
  var angleAxis = polar.getAngleAxis();
  var radiusAxis = polar.getRadiusAxis();
  var radiusExtent = radiusAxis.getExtent();
  var angleExtent = angleAxis.getExtent();
  var RADIAN = Math.PI / 180;
  var clipPath = new graphic.Sector({
    shape: {
      cx: polar.cx,
      cy: polar.cy,
      r0: radiusExtent[0],
      r: radiusExtent[1],
      startAngle: -angleExtent[0] * RADIAN,
      endAngle: -angleExtent[1] * RADIAN,
      clockwise: angleAxis.inverse
    }
  });

  if (hasAnimation) {
    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;
    graphic.initProps(clipPath, {
      shape: {
        endAngle: -angleExtent[1] * RADIAN
      }
    }, seriesModel);
  }

  return clipPath;
}

function createClipShape(coordSys, hasAnimation, seriesModel) {
  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);
}

function turnPointsIntoStep(points, coordSys, stepTurnAt) {
  var baseAxis = coordSys.getBaseAxis();
  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
  var stepPoints = [];

  for (var i = 0; i < points.length - 1; i++) {
    var nextPt = points[i + 1];
    var pt = points[i];
    stepPoints.push(pt);
    var stepPt = [];

    switch (stepTurnAt) {
      case 'end':
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start

        stepPoints.push(stepPt);
        break;

      case 'middle':
        // default is start
        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        var stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt);
        stepPoints.push(stepPt2);
        break;

      default:
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start

        stepPoints.push(stepPt);
    }
  } // Last points


  points[i] && stepPoints.push(points[i]);
  return stepPoints;
}

function getVisualGradient(data, coordSys) {
  var visualMetaList = data.getVisual('visualMeta');

  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    // When data.count() is 0, gradient range can not be calculated.
    return;
  }

  var visualMeta;

  for (var i = visualMetaList.length - 1; i >= 0; i--) {
    // Can only be x or y
    if (visualMetaList[i].dimension < 2) {
      visualMeta = visualMetaList[i];
      break;
    }
  }

  if (!visualMeta || coordSys.type !== 'cartesian2d') {
    return;
  } // If the area to be rendered is bigger than area defined by LinearGradient,
  // the canvas spec prescribes that the color of the first stop and the last
  // stop should be used. But if two stops are added at offset 0, in effect
  // browsers use the color of the second stop to render area outside
  // LinearGradient. So we can only infinitesimally extend area defined in
  // LinearGradient to render `outerColors`.


  var dimension = visualMeta.dimension;
  var dimName = data.dimensions[dimension];
  var axis = coordSys.getAxis(dimName); // dataToCoor mapping may not be linear, but must be monotonic.

  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
      color: stop.color
    };
  });
  var stopLen = colorStops.length;
  var outerColors = visualMeta.outerColors.slice();

  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }

  var tinyExtent = 10; // Arbitrary value: 10px

  var minCoord = colorStops[0].coord - tinyExtent;
  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
  var coordSpan = maxCoord - minCoord;

  if (coordSpan < 1e-3) {
    return 'transparent';
  }

  zrUtil.each(colorStops, function (stop) {
    stop.offset = (stop.coord - minCoord) / coordSpan;
  });
  colorStops.push({
    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
    color: outerColors[1] || 'transparent'
  });
  colorStops.unshift({
    // notice colorStops.length have been changed.
    offset: stopLen ? colorStops[0].offset : 0.5,
    color: outerColors[0] || 'transparent'
  }); // zrUtil.each(colorStops, function (colorStop) {
  //     // Make sure each offset has rounded px to avoid not sharp edge
  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);
  // });

  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
  gradient[dimName] = minCoord;
  gradient[dimName + '2'] = maxCoord;
  return gradient;
}

var _default = ChartView.extend({
  type: 'line',
  init: function () {
    var lineGroup = new graphic.Group();
    var symbolDraw = new SymbolDraw();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
  },
  render: function (seriesModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var lineStyleModel = seriesModel.getModel('lineStyle.normal');
    var areaStyleModel = seriesModel.getModel('areaStyle.normal');
    var points = data.mapArray(data.getItemLayout, true);
    var isCoordSysPolar = coordSys.type === 'polar';
    var prevCoordSys = this._coordSys;
    var symbolDraw = this._symbolDraw;
    var polyline = this._polyline;
    var polygon = this._polygon;
    var lineGroup = this._lineGroup;
    var hasAnimation = seriesModel.get('animation');
    var isAreaChart = !areaStyleModel.isEmpty();
    var stackedOnPoints = getStackedOnPoints(coordSys, data);
    var showSymbol = seriesModel.get('showSymbol');

    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols


    var oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function (el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    }); // Remove previous created symbols if showSymbol changed to false

    if (!showSymbol) {
      symbolDraw.remove();
    }

    group.add(lineGroup); // FIXME step not support polar

    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed

    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, isSymbolIgnore);

      if (step) {
        // TODO If stacked series is not step
        points = turnPointsIntoStep(points, coordSys, step);
        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
      }

      polyline = this._newPolyline(points, coordSys, hasAnimation);

      if (isAreaChart) {
        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
      }

      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        // If areaStyle is added
        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
      } else if (polygon && !isAreaChart) {
        // If areaStyle is removed
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      } // Update clipPath


      lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel)); // Always update, or it is wrong in the case turning on legend
      // because points are not changed

      showSymbol && symbolDraw.updateData(data, isSymbolIgnore); // Stop symbol animation and sync with line points
      // FIXME performance?

      data.eachItemGraphicEl(function (el) {
        el.stopAnimation(true);
      }); // In the case data zoom triggerred refreshing frequently
      // Data may not change if line has a category axis. So it should animate nothing

      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
        if (hasAnimation) {
          this._updateAnimation(data, stackedOnPoints, coordSys, api, step);
        } else {
          // Not do it in update with animation
          if (step) {
            // TODO If stacked series is not step
            points = turnPointsIntoStep(points, coordSys, step);
            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
          }

          polyline.setShape({
            points: points
          });
          polygon && polygon.setShape({
            points: points,
            stackedOnPoints: stackedOnPoints
          });
        }
      }
    }

    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');
    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first
    lineStyleModel.getLineStyle(), {
      fill: 'none',
      stroke: visualColor,
      lineJoin: 'bevel'
    }));
    var smooth = seriesModel.get('smooth');
    smooth = getSmooth(seriesModel.get('smooth'));
    polyline.setShape({
      smooth: smooth,
      smoothMonotone: seriesModel.get('smoothMonotone'),
      connectNulls: seriesModel.get('connectNulls')
    });

    if (polygon) {
      var stackedOn = data.stackedOn;
      var stackedOnSmooth = 0;
      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: 'bevel'
      }));

      if (stackedOn) {
        var stackedOnSeries = stackedOn.hostModel;
        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
      }

      polygon.setShape({
        smooth: smooth,
        stackedOnSmooth: stackedOnSmooth,
        smoothMonotone: seriesModel.get('smoothMonotone'),
        connectNulls: seriesModel.get('connectNulls')
      });
    }

    this._data = data; // Save the coordinate system for transition animation when data changed

    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points;
    this._step = step;
  },
  dispose: function () {},
  highlight: function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = modelUtil.queryDataIndex(data, payload);

    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);

      if (!symbol) {
        // Create a temporary symbol if it is not exists
        var pt = data.getItemLayout(dataIndex);

        if (!pt) {
          // Null data
          return;
        }

        symbol = new SymbolClz(data, dataIndex);
        symbol.position = pt;
        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation

        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }

      symbol.highlight();
    } else {
      // Highlight whole series
      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
    }
  },
  downplay: function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = modelUtil.queryDataIndex(data, payload);

    if (dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);

      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      // FIXME
      // can not downplay completely.
      // Downplay whole series
      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
    }
  },

  /**
   * @param {module:zrender/container/Group} group
   * @param {Array.<Array.<number>>} points
   * @private
   */
  _newPolyline: function (points) {
    var polyline = this._polyline; // Remove previous created polyline

    if (polyline) {
      this._lineGroup.remove(polyline);
    }

    polyline = new Polyline({
      shape: {
        points: points
      },
      silent: true,
      z2: 10
    });

    this._lineGroup.add(polyline);

    this._polyline = polyline;
    return polyline;
  },

  /**
   * @param {module:zrender/container/Group} group
   * @param {Array.<Array.<number>>} stackedOnPoints
   * @param {Array.<Array.<number>>} points
   * @private
   */
  _newPolygon: function (points, stackedOnPoints) {
    var polygon = this._polygon; // Remove previous created polygon

    if (polygon) {
      this._lineGroup.remove(polygon);
    }

    polygon = new Polygon({
      shape: {
        points: points,
        stackedOnPoints: stackedOnPoints
      },
      silent: true
    });

    this._lineGroup.add(polygon);

    this._polygon = polygon;
    return polygon;
  },

  /**
   * @private
   */
  _getSymbolIgnoreFunc: function (data, coordSys) {
    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis

    if (categoryAxis && categoryAxis.isLabelIgnored) {
      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);
    }
  },

  /**
   * @private
   */
  // FIXME Two value axis
  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {
    var polyline = this._polyline;
    var polygon = this._polygon;
    var seriesModel = data.hostModel;
    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys);
    var current = diff.current;
    var stackedOnCurrent = diff.stackedOnCurrent;
    var next = diff.next;
    var stackedOnNext = diff.stackedOnNext;

    if (step) {
      // TODO If stacked series is not step
      current = turnPointsIntoStep(diff.current, coordSys, step);
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
      next = turnPointsIntoStep(diff.next, coordSys, step);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
    } // `diff.current` is subset of `current` (which should be ensured by
    // turnPointsIntoStep), so points in `__points` can be updated when
    // points in `current` are update during animation.


    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    graphic.updateProps(polyline, {
      shape: {
        points: next
      }
    }, seriesModel);

    if (polygon) {
      polygon.setShape({
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      graphic.updateProps(polygon, {
        shape: {
          points: next,
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel);
    }

    var updatedDataInfo = [];
    var diffStatus = diff.status;

    for (var i = 0; i < diffStatus.length; i++) {
      var cmd = diffStatus[i].cmd;

      if (cmd === '=') {
        var el = data.getItemGraphicEl(diffStatus[i].idx1);

        if (el) {
          updatedDataInfo.push({
            el: el,
            ptIdx: i // Index of points

          });
        }
      }
    }

    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function () {
        for (var i = 0; i < updatedDataInfo.length; i++) {
          var el = updatedDataInfo[i].el;
          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);
        }
      });
    }
  },
  remove: function (ecModel) {
    var group = this.group;
    var oldData = this._data;

    this._lineGroup.removeAll();

    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting


    oldData && oldData.eachItemGraphicEl(function (el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
  }
});

module.exports = _default;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var _model = __webpack_require__(95);

var otherDimToDataDim = _model.otherDimToDataDim;

/**
 * @module echarts/chart/helper/Symbol
 */
function findLabelValueDim(data) {
  var valueDim;
  var labelDims = otherDimToDataDim(data, 'label');

  if (labelDims.length) {
    valueDim = labelDims[0];
  } else {
    // Get last value dim
    var dimensions = data.dimensions.slice();
    var dataType;

    while (dimensions.length && (valueDim = dimensions.pop(), dataType = data.getDimensionInfo(valueDim).type, dataType === 'ordinal' || dataType === 'time')) {} // jshint ignore:line

  }

  return valueDim;
}

exports.findLabelValueDim = findLabelValueDim;

/***/ }),
/* 259 */
/***/ (function(module, exports) {

// var arrayDiff = require('zrender/src/core/arrayDiff');
// 'zrender/src/core/arrayDiff' has been used before, but it did
// not do well in performance when roam with fixed dataZoom window.
function sign(val) {
  return val >= 0 ? 1 : -1;
}

function getStackedOnPoint(coordSys, data, idx) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis = coordSys.getOtherAxis(baseAxis);
  var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];
  var valueDim = valueAxis.dim;
  var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;
  var stackedOnSameSign;
  var stackedOn = data.stackedOn;
  var val = data.get(valueDim, idx); // Find first stacked value with same sign

  while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {
    stackedOnSameSign = stackedOn;
    break;
  }

  var stackedData = [];
  stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
  stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;
  return coordSys.dataToPoint(stackedData);
} // function convertToIntId(newIdList, oldIdList) {
//     // Generate int id instead of string id.
//     // Compare string maybe slow in score function of arrDiff
//     // Assume id in idList are all unique
//     var idIndicesMap = {};
//     var idx = 0;
//     for (var i = 0; i < newIdList.length; i++) {
//         idIndicesMap[newIdList[i]] = idx;
//         newIdList[i] = idx++;
//     }
//     for (var i = 0; i < oldIdList.length; i++) {
//         var oldId = oldIdList[i];
//         // Same with newIdList
//         if (idIndicesMap[oldId]) {
//             oldIdList[i] = idIndicesMap[oldId];
//         }
//         else {
//             oldIdList[i] = idx++;
//         }
//     }
// }


function diffData(oldData, newData) {
  var diffResult = [];
  newData.diff(oldData).add(function (idx) {
    diffResult.push({
      cmd: '+',
      idx: idx
    });
  }).update(function (newIdx, oldIdx) {
    diffResult.push({
      cmd: '=',
      idx: oldIdx,
      idx1: newIdx
    });
  }).remove(function (idx) {
    diffResult.push({
      cmd: '-',
      idx: idx
    });
  }).execute();
  return diffResult;
}

function _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys) {
  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);
  // var oldIdList = oldData.mapArray(oldData.getId);
  // convertToIntId(newIdList, oldIdList);
  // // FIXME One data ?
  // diff = arrayDiff(oldIdList, newIdList);

  var currPoints = [];
  var nextPoints = []; // Points for stacking base line

  var currStackedPoints = [];
  var nextStackedPoints = [];
  var status = [];
  var sortedIndices = [];
  var rawIndices = [];
  var dims = newCoordSys.dimensions;

  for (var i = 0; i < diff.length; i++) {
    var diffItem = diff[i];
    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast
    // Which is in case remvoing or add more than one data in the tail or head

    switch (diffItem.cmd) {
      case '=':
        var currentPt = oldData.getItemLayout(diffItem.idx);
        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly

        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
          currentPt = nextPt.slice();
        }

        currPoints.push(currentPt);
        nextPoints.push(nextPt);
        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;

      case '+':
        var idx = diffItem.idx;
        currPoints.push(oldCoordSys.dataToPoint([newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)]));
        nextPoints.push(newData.getItemLayout(idx).slice());
        currStackedPoints.push(getStackedOnPoint(oldCoordSys, newData, idx));
        nextStackedPoints.push(newStackedOnPoints[idx]);
        rawIndices.push(newData.getRawIndex(idx));
        break;

      case '-':
        var idx = diffItem.idx;
        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue
        // FIXME FIXME FIXME

        if (rawIndex !== idx) {
          currPoints.push(oldData.getItemLayout(idx));
          nextPoints.push(newCoordSys.dataToPoint([oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)]));
          currStackedPoints.push(oldStackedOnPoints[idx]);
          nextStackedPoints.push(getStackedOnPoint(newCoordSys, oldData, idx));
          rawIndices.push(rawIndex);
        } else {
          pointAdded = false;
        }

    } // Original indices


    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  } // Diff result may be crossed if all items are changed
  // Sort by data index


  sortedIndices.sort(function (a, b) {
    return rawIndices[a] - rawIndices[b];
  });
  var sortedCurrPoints = [];
  var sortedNextPoints = [];
  var sortedCurrStackedPoints = [];
  var sortedNextStackedPoints = [];
  var sortedStatus = [];

  for (var i = 0; i < sortedIndices.length; i++) {
    var idx = sortedIndices[i];
    sortedCurrPoints[i] = currPoints[idx];
    sortedNextPoints[i] = nextPoints[idx];
    sortedCurrStackedPoints[i] = currStackedPoints[idx];
    sortedNextStackedPoints[i] = nextStackedPoints[idx];
    sortedStatus[i] = status[idx];
  }

  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}

module.exports = _default;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var Path = __webpack_require__(100);

var vec2 = __webpack_require__(97);

var fixClipWithShadow = __webpack_require__(154);

// Poly path support NaN point
var vec2Min = vec2.min;
var vec2Max = vec2.max;
var scaleAndAdd = vec2.scaleAndAdd;
var v2Copy = vec2.copy; // Temporary variable

var v = [];
var cp0 = [];
var cp1 = [];

function isPointNull(p) {
  return isNaN(p[0]) || isNaN(p[1]);
}

function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
  var prevIdx = 0;
  var idx = start;

  for (var k = 0; k < segLen; k++) {
    var p = points[idx];

    if (idx >= allLen || idx < 0) {
      break;
    }

    if (isPointNull(p)) {
      if (connectNulls) {
        idx += dir;
        continue;
      }

      break;
    }

    if (idx === start) {
      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
      v2Copy(cp0, p);
    } else {
      if (smooth > 0) {
        var nextIdx = idx + dir;
        var nextP = points[nextIdx];

        if (connectNulls) {
          // Find next point not null
          while (nextP && isPointNull(points[nextIdx])) {
            nextIdx += dir;
            nextP = points[nextIdx];
          }
        }

        var ratioNextSeg = 0.5;
        var prevP = points[prevIdx];
        var nextP = points[nextIdx]; // Last point

        if (!nextP || isPointNull(nextP)) {
          v2Copy(cp1, p);
        } else {
          // If next data is null in not connect case
          if (isPointNull(nextP) && !connectNulls) {
            nextP = p;
          }

          vec2.sub(v, nextP, prevP);
          var lenPrevSeg;
          var lenNextSeg;

          if (smoothMonotone === 'x' || smoothMonotone === 'y') {
            var dim = smoothMonotone === 'x' ? 0 : 1;
            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
            lenNextSeg = Math.abs(p[dim] - nextP[dim]);
          } else {
            lenPrevSeg = vec2.dist(p, prevP);
            lenNextSeg = vec2.dist(p, nextP);
          } // Use ratio of seg length


          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));
        } // Smooth constraint


        vec2Min(cp0, cp0, smoothMax);
        vec2Max(cp0, cp0, smoothMin);
        vec2Min(cp1, cp1, smoothMax);
        vec2Max(cp1, cp1, smoothMin);
        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment

        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);
      } else {
        ctx.lineTo(p[0], p[1]);
      }
    }

    prevIdx = idx;
    idx += dir;
  }

  return k;
}

function getBoundingBox(points, smoothConstraint) {
  var ptMin = [Infinity, Infinity];
  var ptMax = [-Infinity, -Infinity];

  if (smoothConstraint) {
    for (var i = 0; i < points.length; i++) {
      var pt = points[i];

      if (pt[0] < ptMin[0]) {
        ptMin[0] = pt[0];
      }

      if (pt[1] < ptMin[1]) {
        ptMin[1] = pt[1];
      }

      if (pt[0] > ptMax[0]) {
        ptMax[0] = pt[0];
      }

      if (pt[1] > ptMax[1]) {
        ptMax[1] = pt[1];
      }
    }
  }

  return {
    min: smoothConstraint ? ptMin : ptMax,
    max: smoothConstraint ? ptMax : ptMin
  };
}

var Polyline = Path.extend({
  type: 'ec-polyline',
  shape: {
    points: [],
    smooth: 0,
    smoothConstraint: true,
    smoothMonotone: null,
    connectNulls: false
  },
  style: {
    fill: null,
    stroke: '#000'
  },
  brush: fixClipWithShadow(Path.prototype.brush),
  buildPath: function (ctx, shape) {
    var points = shape.points;
    var i = 0;
    var len = points.length;
    var result = getBoundingBox(points, shape.smoothConstraint);

    if (shape.connectNulls) {
      // Must remove first and last null values avoid draw error in polygon
      for (; len > 0; len--) {
        if (!isPointNull(points[len - 1])) {
          break;
        }
      }

      for (; i < len; i++) {
        if (!isPointNull(points[i])) {
          break;
        }
      }
    }

    while (i < len) {
      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  }
});
var Polygon = Path.extend({
  type: 'ec-polygon',
  shape: {
    points: [],
    // Offset between stacked base points and points
    stackedOnPoints: [],
    smooth: 0,
    stackedOnSmooth: 0,
    smoothConstraint: true,
    smoothMonotone: null,
    connectNulls: false
  },
  brush: fixClipWithShadow(Path.prototype.brush),
  buildPath: function (ctx, shape) {
    var points = shape.points;
    var stackedOnPoints = shape.stackedOnPoints;
    var i = 0;
    var len = points.length;
    var smoothMonotone = shape.smoothMonotone;
    var bbox = getBoundingBox(points, shape.smoothConstraint);
    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);

    if (shape.connectNulls) {
      // Must remove first and last null values avoid draw error in polygon
      for (; len > 0; len--) {
        if (!isPointNull(points[len - 1])) {
          break;
        }
      }

      for (; i < len; i++) {
        if (!isPointNull(points[i])) {
          break;
        }
      }
    }

    while (i < len) {
      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i += k + 1;
      ctx.closePath();
    }
  }
});
exports.Polyline = Polyline;
exports.Polygon = Polygon;

/***/ }),
/* 261 */
/***/ (function(module, exports) {

function _default(seriesType, defaultSymbolType, legendSymbol, ecModel, api) {
  // Encoding visual for all series include which is filtered for legend drawing
  ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {
    var data = seriesModel.getData();
    var symbolType = seriesModel.get('symbol') || defaultSymbolType;
    var symbolSize = seriesModel.get('symbolSize');
    data.setVisual({
      legendSymbol: legendSymbol || symbolType,
      symbol: symbolType,
      symbolSize: symbolSize
    }); // Only visible series has each data be visual encoded

    if (!ecModel.isSeriesFiltered(seriesModel)) {
      if (typeof symbolSize === 'function') {
        data.each(function (idx) {
          var rawValue = seriesModel.getRawValue(idx); // FIXME

          var params = seriesModel.getDataParams(idx);
          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
        });
      }

      data.each(function (idx) {
        var itemModel = data.getItemModel(idx);
        var itemSymbolType = itemModel.getShallow('symbol', true);
        var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol

        if (itemSymbolType != null) {
          data.setItemVisual(idx, 'symbol', itemSymbolType);
        }

        if (itemSymbolSize != null) {
          // PENDING Transform symbolSize ?
          data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
        }
      });
    }
  });
}

module.exports = _default;

/***/ }),
/* 262 */
/***/ (function(module, exports) {

function _default(seriesType, ecModel) {
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;

    if (!coordSys) {
      return;
    }

    var dims = [];
    var coordDims = coordSys.dimensions;

    for (var i = 0; i < coordDims.length; i++) {
      dims.push(seriesModel.coordDimToDataDim(coordSys.dimensions[i])[0]);
    }

    if (dims.length === 1) {
      data.each(dims[0], function (x, idx) {
        // Also {Array.<number>}, not undefined to avoid if...else... statement
        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));
      });
    } else if (dims.length === 2) {
      data.each(dims, function (x, y, idx) {
        // Also {Array.<number>}, not undefined to avoid if...else... statement
        data.setItemLayout(idx, isNaN(x) || isNaN(y) ? [NaN, NaN] : coordSys.dataToPoint([x, y]));
      }, true);
    }
  });
}

module.exports = _default;

/***/ }),
/* 263 */
/***/ (function(module, exports) {

var samplers = {
  average: function (frame) {
    var sum = 0;
    var count = 0;

    for (var i = 0; i < frame.length; i++) {
      if (!isNaN(frame[i])) {
        sum += frame[i];
        count++;
      }
    } // Return NaN if count is 0


    return count === 0 ? NaN : sum / count;
  },
  sum: function (frame) {
    var sum = 0;

    for (var i = 0; i < frame.length; i++) {
      // Ignore NaN
      sum += frame[i] || 0;
    }

    return sum;
  },
  max: function (frame) {
    var max = -Infinity;

    for (var i = 0; i < frame.length; i++) {
      frame[i] > max && (max = frame[i]);
    }

    return max;
  },
  min: function (frame) {
    var min = Infinity;

    for (var i = 0; i < frame.length; i++) {
      frame[i] < min && (min = frame[i]);
    }

    return min;
  },
  // TODO
  // Median
  nearest: function (frame) {
    return frame[0];
  }
};

var indexSampler = function (frame, value) {
  return Math.round(frame.length / 2);
};

function _default(seriesType, ecModel, api) {
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    var data = seriesModel.getData();
    var sampling = seriesModel.get('sampling');
    var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling

    if (coordSys.type === 'cartesian2d' && sampling) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis = coordSys.getOtherAxis(baseAxis);
      var extent = baseAxis.getExtent(); // Coordinste system has been resized

      var size = extent[1] - extent[0];
      var rate = Math.round(data.count() / size);

      if (rate > 1) {
        var sampler;

        if (typeof sampling === 'string') {
          sampler = samplers[sampling];
        } else if (typeof sampling === 'function') {
          sampler = sampling;
        }

        if (sampler) {
          data = data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler);
          seriesModel.setData(data);
        }
      }
    }
  }, this);
}

module.exports = _default;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

__webpack_require__(265);

__webpack_require__(271);

__webpack_require__(272);

// FIXME Better way to pack data in graphic element

/**
 * @action
 * @property {string} type
 * @property {number} seriesIndex
 * @property {number} dataIndex
 * @property {number} [x]
 * @property {number} [y]
 */
echarts.registerAction({
  type: 'showTip',
  event: 'showTip',
  update: 'tooltip:manuallyShowTip'
}, // noop
function () {});
echarts.registerAction({
  type: 'hideTip',
  event: 'hideTip',
  update: 'tooltip:manuallyHideTip'
}, // noop
function () {});

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var axisPointerModelHelper = __webpack_require__(125);

var axisTrigger = __webpack_require__(266);

__webpack_require__(267);

__webpack_require__(268);

__webpack_require__(269);

// CartesianAxisPointer is not supposed to be required here. But consider
// echarts.simple.js and online build tooltip, which only require gridSimple,
// CartesianAxisPointer should be able to required somewhere.
echarts.registerPreprocessor(function (option) {
  // Always has a global axisPointerModel for default setting.
  if (option) {
    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
    var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link
    // is not set, remain null/undefined, otherwise it will
    // override existent link setting.

    if (link && !zrUtil.isArray(link)) {
      option.axisPointer.link = [link];
    }
  }
}); // This process should proformed after coordinate systems created
// and series data processed. So put it on statistic processing stage.

echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
  // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
  // allAxesInfo should be updated when setOption performed.
  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);
}); // Broadcast to all views.

echarts.registerAction({
  type: 'updateAxisPointer',
  event: 'updateAxisPointer',
  update: ':updateAxisPointer'
}, axisTrigger);

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var modelUtil = __webpack_require__(95);

var modelHelper = __webpack_require__(125);

var findPointFromSeries = __webpack_require__(171);

var each = zrUtil.each;
var curry = zrUtil.curry;
var get = modelUtil.makeGetter();
/**
 * Basic logic: check all axis, if they do not demand show/highlight,
 * then hide/downplay them.
 *
 * @param {Object} coordSysAxesInfo
 * @param {Object} payload
 * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'
 * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to
 *              trigger axisPointer and tooltip.
 * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to
 *              trigger axisPointer and tooltip.
 * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.
 * @param {Object} [payload.dataIndex] finder, restrict target axes.
 * @param {Object} [payload.axesInfo] finder, restrict target axes.
 *        [{
 *          axisDim: 'x'|'y'|'angle'|...,
 *          axisIndex: ...,
 *          value: ...
 *        }, ...]
 * @param {Function} [payload.dispatchAction]
 * @param {Object} [payload.tooltipOption]
 * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,
 *        which can be specified in dispatchAction
 * @param {module:echarts/model/Global} ecModel
 * @param {module:echarts/ExtensionAPI} api
 * @return {Object} content of event obj for echarts.connect.
 */

function _default(payload, ecModel, api) {
  var currTrigger = payload.currTrigger;
  var point = [payload.x, payload.y];
  var finder = payload;
  var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending
  // See #6121. But we are not able to reproduce it yet.

  if (!coordSysAxesInfo) {
    return;
  }

  if (illegalPoint(point)) {
    // Used in the default behavior of `connection`: use the sample seriesIndex
    // and dataIndex. And also used in the tooltipView trigger.
    point = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }

  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
  // Notice: In this case, it is difficult to get the `point` (which is necessary to show
  // tooltip, so if point is not given, we just use the point found by sample seriesIndex
  // and dataIndex.

  var inputAxesInfo = finder.axesInfo;
  var axesInfo = coordSysAxesInfo.axesInfo;
  var shouldHide = currTrigger === 'leave' || illegalPoint(point);
  var outputFinder = {};
  var showValueMap = {};
  var dataByCoordSys = {
    list: [],
    map: {}
  };
  var updaters = {
    showPointer: curry(showPointer, showValueMap),
    showTooltip: curry(showTooltip, dataByCoordSys)
  }; // Process for triggered axes.

  each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
    // If a point given, it must be contained by the coordinate system.
    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
      var axis = axisInfo.axis;
      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.

      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        var val = inputAxisInfo && inputAxisInfo.value;

        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point);
        }

        val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);
      }
    });
  }); // Process for linked axes.

  var linkTriggers = {};
  each(axesInfo, function (tarAxisInfo, tarKey) {
    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.

    if (linkGroup && !showValueMap[tarKey]) {
      each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.

        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          var val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  each(linkTriggers, function (val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);
  });
  updateModelActually(showValueMap, axesInfo, outputFinder);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
  dispatchHighDownActually(axesInfo, dispatchAction, api);
  return outputFinder;
}

function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
  var axis = axisInfo.axis;

  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }

  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  } // Heavy calculation. So put it after axis.containData checking.


  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  var payloadBatch = payloadInfo.payloadBatch;
  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.
  // By defualt use the first involved series data as a sample to connect.

  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    zrUtil.extend(outputFinder, payloadBatch[0]);
  } // If no linkSource input, this process is for collecting link
  // target, where snap should not be accepted.


  if (!dontSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }

  updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be
  // incorrect "axis value ~ series value" mapping displayed in tooltip.

  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}

function buildPayloadsBySeries(value, axisInfo) {
  var axis = axisInfo.axis;
  var dim = axis.dim;
  var snapToValue = value;
  var payloadBatch = [];
  var minDist = Number.MAX_VALUE;
  var minDiff = -1;
  each(axisInfo.seriesModels, function (series, idx) {
    var dataDim = series.coordDimToDataDim(dim);
    var seriesNestestValue;
    var dataIndices;

    if (series.getAxisTooltipData) {
      var result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex
      // when data length is not same.
      false, axis.type === 'category' ? 0.5 : null);

      if (!dataIndices.length) {
        return;
      }

      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }

    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }

    var diff = value - seriesNestestValue;
    var dist = Math.abs(diff); // Consider category case

    if (dist <= minDist) {
      if (dist < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }

      each(dataIndices, function (dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch: payloadBatch,
    snapToValue: snapToValue
  };
}

function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value: value,
    payloadBatch: payloadBatch
  };
}

function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  var payloadBatch = payloadInfo.payloadBatch;
  var axis = axisInfo.axis;
  var axisModel = axis.model;
  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,
  // whose length will be used to judge whether dispatch action.

  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }

  var coordSysModel = axisInfo.coordSys.model;
  var coordSysKey = modelHelper.makeKey(coordSysModel);
  var coordSysItem = dataByCoordSys.map[coordSysKey];

  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }

  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value: value,
    // Caustion: viewHelper.getValueLabel is actually on "view stage", which
    // depends that all models have been updated. So it should not be performed
    // here. Considering axisPointerModel used here is volatile, which is hard
    // to be retrieve in TooltipView, we prepare parameters here.
    valueLabelOpt: {
      precision: axisPointerModel.get('label.precision'),
      formatter: axisPointerModel.get('label.formatter')
    },
    seriesDataIndices: payloadBatch.slice()
  });
}

function updateModelActually(showValueMap, axesInfo, outputFinder) {
  var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.

  each(axesInfo, function (axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    var valItem = showValueMap[key];

    if (valItem) {
      !axisInfo.useHandle && (option.status = 'show');
      option.value = valItem.value; // For label formatter param and highlight.

      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } // When always show (e.g., handle used), remain
    // original value and status.
    else {
        // If hide, value still need to be set, consider
        // click legend to toggle axis blank.
        !axisInfo.useHandle && (option.status = 'hide');
      } // If status is 'hide', should be no info in payload.


    option.status === 'show' && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}

function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
  // Basic logic: If no showTip required, hideTip will be dispatched.
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction({
      type: 'hideTip'
    });
    return;
  } // In most case only one axis (or event one series is used). It is
  // convinient to fetch payload.seriesIndex and payload.dataIndex
  // dirtectly. So put the first seriesIndex and dataIndex of the first
  // axis on the payload.


  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction({
    type: 'showTip',
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}

function dispatchHighDownActually(axesInfo, dispatchAction, api) {
  // FIXME
  // highlight status modification shoule be a stage of main process?
  // (Consider confilct (e.g., legend and axisPointer) and setOption)
  var zr = api.getZr();
  var highDownKey = 'axisPointerLastHighlights';
  var lastHighlights = get(zr)[highDownKey] || {};
  var newHighlights = get(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.
  // Build hash map and remove duplicate incidentally.

  each(axesInfo, function (axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {
      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;
      newHighlights[key] = batchItem;
    });
  }); // Diff.

  var toHighlight = [];
  var toDownplay = [];
  zrUtil.each(lastHighlights, function (batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  zrUtil.each(newHighlights, function (batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api.dispatchAction({
    type: 'downplay',
    escapeConnect: true,
    batch: toDownplay
  });
  toHighlight.length && api.dispatchAction({
    type: 'highlight',
    escapeConnect: true,
    batch: toHighlight
  });
}

function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (var i = 0; i < (inputAxesInfo || []).length; i++) {
    var inputAxisInfo = inputAxesInfo[i];

    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}

function makeMapperParam(axisInfo) {
  var axisModel = axisInfo.axis.model;
  var item = {};
  var dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;
  item.axisName = item[dim + 'AxisName'] = axisModel.name;
  item.axisId = item[dim + 'AxisId'] = axisModel.id;
  return item;
}

function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}

module.exports = _default;

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var AxisPointerModel = echarts.extendComponentModel({
  type: 'axisPointer',
  coordSysAxesInfo: null,
  defaultOption: {
    // 'auto' means that show when triggered by tooltip or handle.
    show: 'auto',
    // 'click' | 'mousemove' | 'none'
    triggerOn: null,
    // set default in AxisPonterView.js
    zlevel: 0,
    z: 50,
    type: 'line',
    // axispointer triggered by tootip determine snap automatically,
    // see `modelHelper`.
    snap: false,
    triggerTooltip: true,
    value: null,
    status: null,
    // Init value depends on whether handle is used.
    // [group0, group1, ...]
    // Each group can be: {
    //      mapper: function () {},
    //      singleTooltip: 'multiple',  // 'multiple' or 'single'
    //      xAxisId: ...,
    //      yAxisName: ...,
    //      angleAxisIndex: ...
    // }
    // mapper: can be ignored.
    //      input: {axisInfo, value}
    //      output: {axisInfo, value}
    link: [],
    // Do not set 'auto' here, otherwise global animation: false
    // will not effect at this axispointer.
    animation: null,
    animationDurationUpdate: 200,
    lineStyle: {
      color: '#aaa',
      width: 1,
      type: 'solid'
    },
    shadowStyle: {
      color: 'rgba(150,150,150,0.3)'
    },
    label: {
      show: true,
      formatter: null,
      // string | Function
      precision: 'auto',
      // Or a number like 0, 1, 2 ...
      margin: 3,
      color: '#fff',
      padding: [5, 7, 5, 7],
      backgroundColor: 'auto',
      // default: axis line color
      borderColor: null,
      borderWidth: 0,
      shadowBlur: 3,
      shadowColor: '#aaa' // Considering applicability, common style should
      // better not have shadowOffset.
      // shadowOffsetX: 0,
      // shadowOffsetY: 2

    },
    handle: {
      show: false,
      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
      // jshint ignore:line
      size: 45,
      // handle margin is from symbol center to axis, which is stable when circular move.
      margin: 50,
      // color: '#1b8bbd'
      // color: '#2f4554'
      color: '#333',
      shadowBlur: 3,
      shadowColor: '#aaa',
      shadowOffsetX: 0,
      shadowOffsetY: 2,
      // For mobile performance
      throttle: 40
    }
  }
});
var _default = AxisPointerModel;
module.exports = _default;

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var globalListener = __webpack_require__(172);

var AxisPointerView = echarts.extendComponentView({
  type: 'axisPointer',
  render: function (globalAxisPointerModel, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent('tooltip');
    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable
    // AxisPointerView to be independent to Tooltip.

    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {
      // If 'none', it is not controlled by mouse totally.
      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction({
          type: 'updateAxisPointer',
          currTrigger: currTrigger,
          x: e && e.offsetX,
          y: e && e.offsetY
        });
      }
    });
  },

  /**
   * @override
   */
  remove: function (ecModel, api) {
    globalListener.unregister(api.getZr(), 'axisPointer');
    AxisPointerView.superApply(this._model, 'remove', arguments);
  },

  /**
   * @override
   */
  dispose: function (ecModel, api) {
    globalListener.unregister('axisPointer', api);
    AxisPointerView.superApply(this._model, 'dispose', arguments);
  }
});
var _default = AxisPointerView;
module.exports = _default;

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__(93);

var BaseAxisPointer = __webpack_require__(270);

var viewHelper = __webpack_require__(173);

var cartesianAxisHelper = __webpack_require__(168);

var AxisView = __webpack_require__(167);

var CartesianAxisPointer = BaseAxisPointer.extend({
  /**
   * @override
   */
  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisPointerType = axisPointerModel.get('type');
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));

    if (axisPointerType && axisPointerType !== 'none') {
      var elStyle = viewHelper.buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }

    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);
    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
  },

  /**
   * @override
   */
  getHandleTransform: function (value, axisModel, axisPointerModel) {
    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get('handle.margin');
    return {
      position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  },

  /**
   * @override
   */
  updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisExtent = axis.getGlobalExtent(true);
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var dimIndex = axis.dim === 'x' ? 0 : 1;
    var currPosition = transform.position;
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.

    var tooltipOptions = [{
      verticalAlign: 'middle'
    }, {
      align: 'center'
    }];
    return {
      position: currPosition,
      rotation: transform.rotation,
      cursorPoint: cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  }
});

function getCartesian(grid, axis) {
  var opt = {};
  opt[axis.dim + 'AxisIndex'] = axis.index;
  return grid.getCartesian(opt);
}

var pointerShapeBuilder = {
  line: function (axis, pixelValue, otherExtent, elStyle) {
    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    graphic.subPixelOptimizeLine({
      shape: targetShape,
      style: elStyle
    });
    return {
      type: 'Line',
      shape: targetShape
    };
  },
  shadow: function (axis, pixelValue, otherExtent, elStyle) {
    var bandWidth = axis.getBandWidth();
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: 'Rect',
      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};

function getAxisDimIndex(axis) {
  return axis.dim === 'x' ? 0 : 1;
}

AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);
var _default = CartesianAxisPointer;
module.exports = _default;

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var clazzUtil = __webpack_require__(104);

var graphic = __webpack_require__(93);

var axisPointerModelHelper = __webpack_require__(125);

var eventTool = __webpack_require__(106);

var throttleUtil = __webpack_require__(114);

var modelUtil = __webpack_require__(95);

var get = modelUtil.makeGetter();
var clone = zrUtil.clone;
var bind = zrUtil.bind;
/**
 * Base axis pointer class in 2D.
 * Implemenents {module:echarts/component/axis/IAxisPointer}.
 */

function BaseAxisPointer() {}

BaseAxisPointer.prototype = {
  /**
   * @private
   */
  _group: null,

  /**
   * @private
   */
  _lastGraphicKey: null,

  /**
   * @private
   */
  _handle: null,

  /**
   * @private
   */
  _dragging: false,

  /**
   * @private
   */
  _lastValue: null,

  /**
   * @private
   */
  _lastStatus: null,

  /**
   * @private
   */
  _payloadInfo: null,

  /**
   * In px, arbitrary value. Do not set too small,
   * no animation is ok for most cases.
   * @protected
   */
  animationThreshold: 15,

  /**
   * @implement
   */
  render: function (axisModel, axisPointerModel, api, forceRender) {
    var value = axisPointerModel.get('value');
    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not
    // be replaced when user calling setOption in not merge mode.

    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api; // Optimize: `render` will be called repeatly during mouse move.
    // So it is power consuming if performing `render` each time,
    // especially on mobile device.

    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }

    this._lastValue = value;
    this._lastStatus = status;
    var group = this._group;
    var handle = this._handle;

    if (!status || status === 'hide') {
      // Do not clear here, for animation better.
      group && group.hide();
      handle && handle.hide();
      return;
    }

    group && group.show();
    handle && handle.show(); // Otherwise status is 'show'

    var elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.

    var graphicKey = elOption.graphicKey;

    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api);
    }

    this._lastGraphicKey = graphicKey;
    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);

    if (!group) {
      group = this._group = new graphic.Group();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api.getZr().add(group);
    } else {
      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }

    updateMandatoryProps(group, axisPointerModel, true);

    this._renderHandle(value);
  },

  /**
   * @implement
   */
  remove: function (api) {
    this.clear(api);
  },

  /**
   * @implement
   */
  dispose: function (api) {
    this.clear(api);
  },

  /**
   * @protected
   */
  determineAnimation: function (axisModel, axisPointerModel) {
    var animation = axisPointerModel.get('animation');
    var axis = axisModel.axis;
    var isCategoryAxis = axis.type === 'category';
    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.

    if (!useSnap && !isCategoryAxis) {
      return false;
    }

    if (animation === 'auto' || animation == null) {
      var animationThreshold = this.animationThreshold;

      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      } // It is important to auto animation when snap used. Consider if there is
      // a dataZoom, animation will be disabled when too many points exist, while
      // it will be enabled for better visual effect when little points exist.


      if (useSnap) {
        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;
        var axisExtent = axis.getExtent(); // Approximate band width

        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }

      return false;
    }

    return animation === true;
  },

  /**
   * add {pointer, label, graphicKey} to elOption
   * @protected
   */
  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.
  },

  /**
   * @protected
   */
  createPointerEl: function (group, elOption, axisModel, axisPointerModel) {
    var pointerOption = elOption.pointer;

    if (pointerOption) {
      var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));
      group.add(pointerEl);
    }
  },

  /**
   * @protected
   */
  createLabelEl: function (group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      var labelEl = get(group).labelEl = new graphic.Rect(clone(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  },

  /**
   * @protected
   */
  updatePointerEl: function (group, elOption, updateProps) {
    var pointerEl = get(group).pointerEl;

    if (pointerEl) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps(pointerEl, {
        shape: elOption.pointer.shape
      });
    }
  },

  /**
   * @protected
   */
  updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {
    var labelEl = get(group).labelEl;

    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps(labelEl, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        shape: elOption.label.shape,
        position: elOption.label.position
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  },

  /**
   * @private
   */
  _renderHandle: function (value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }

    var axisPointerModel = this._axisPointerModel;

    var zr = this._api.getZr();

    var handle = this._handle;
    var handleModel = axisPointerModel.getModel('handle');
    var status = axisPointerModel.get('status');

    if (!handleModel.get('show') || !status || status === 'hide') {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }

    var isInit;

    if (!this._handle) {
      isInit = true;
      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {
        cursor: 'move',
        draggable: true,
        onmousemove: function (e) {
          // Fot mobile devicem, prevent screen slider on the button.
          eventTool.stop(e.event);
        },
        onmousedown: bind(this._onHandleDragMove, this, 0, 0),
        drift: bind(this._onHandleDragMove, this),
        ondragend: bind(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }

    updateMandatoryProps(handle, axisPointerModel, false); // update style

    var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];
    handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position

    var handleSize = handleModel.get('size');

    if (!zrUtil.isArray(handleSize)) {
      handleSize = [handleSize, handleSize];
    }

    handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);
    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');

    this._moveHandleToValue(value, isInit);
  },

  /**
   * @private
   */
  _moveHandleToValue: function (value, isInit) {
    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  },

  /**
   * @private
   */
  _onHandleDragMove: function (dx, dy) {
    var handle = this._handle;

    if (!handle) {
      return;
    }

    this._dragging = true; // Persistent for throttle.

    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    get(handle).lastProp = null;

    this._doDispatchAxisPointer();
  },

  /**
   * Throttled method.
   * @private
   */
  _doDispatchAxisPointer: function () {
    var handle = this._handle;

    if (!handle) {
      return;
    }

    var payloadInfo = this._payloadInfo;
    var axisModel = this._axisModel;

    this._api.dispatchAction({
      type: 'updateAxisPointer',
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  },

  /**
   * @private
   */
  _onHandleDragEnd: function (moveAnimation) {
    this._dragging = false;
    var handle = this._handle;

    if (!handle) {
      return;
    }

    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with
    // axisPointer. So move handle to align the exact value position when
    // drag ended.


    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle
    // button, and will be hidden after finger left handle button.


    this._api.dispatchAction({
      type: 'hideTip'
    });
  },

  /**
   * Should be implemenented by sub-class if support `handle`.
   * @protected
   * @param {number} value
   * @param {module:echarts/model/Model} axisModel
   * @param {module:echarts/model/Model} axisPointerModel
   * @return {Object} {position: [x, y], rotation: 0}
   */
  getHandleTransform: null,

  /**
   * * Should be implemenented by sub-class if support `handle`.
   * @protected
   * @param {Object} transform {position, rotation}
   * @param {Array.<number>} delta [dx, dy]
   * @param {module:echarts/model/Model} axisModel
   * @param {module:echarts/model/Model} axisPointerModel
   * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}
   */
  updateHandleTransform: null,

  /**
   * @private
   */
  clear: function (api) {
    this._lastValue = null;
    this._lastStatus = null;
    var zr = api.getZr();
    var group = this._group;
    var handle = this._handle;

    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
  },

  /**
   * @protected
   */
  doClear: function () {// Implemented by sub-class if necessary.
  },

  /**
   * @protected
   * @param {Array.<number>} xy
   * @param {Array.<number>} wh
   * @param {number} [xDimIndex=0] or 1
   */
  buildLabel: function (xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  }
};
BaseAxisPointer.prototype.constructor = BaseAxisPointer;

function updateProps(animationModel, moveAnimation, el, props) {
  // Animation optimize.
  if (!propsEqual(get(el).lastProp, props)) {
    get(el).lastProp = props;
    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
  }
}

function propsEqual(lastProps, newProps) {
  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {
    var equals = true;
    zrUtil.each(newProps, function (item, key) {
      equals = equals && propsEqual(lastProps[key], item);
    });
    return !!equals;
  } else {
    return lastProps === newProps;
  }
}

function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();
}

function getHandleTransProps(trans) {
  return {
    position: trans.position.slice(),
    rotation: trans.rotation || 0
  };
}

function updateMandatoryProps(group, axisPointerModel, silent) {
  var z = axisPointerModel.get('z');
  var zlevel = axisPointerModel.get('zlevel');
  group && group.traverse(function (el) {
    if (el.type !== 'group') {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}

clazzUtil.enableClassExtend(BaseAxisPointer);
var _default = BaseAxisPointer;
module.exports = _default;

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var _default = echarts.extendComponentModel({
  type: 'tooltip',
  dependencies: ['axisPointer'],
  defaultOption: {
    zlevel: 0,
    z: 8,
    show: true,
    // tooltip主体内容
    showContent: true,
    // 'trigger' only works on coordinate system.
    // 'item' | 'axis' | 'none'
    trigger: 'item',
    // 'click' | 'mousemove' | 'none'
    triggerOn: 'mousemove|click',
    alwaysShowContent: false,
    displayMode: 'single',
    // 'single' | 'multipleByCoordSys'
    // 位置 {Array} | {Function}
    // position: null
    // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
    // align: null,
    // verticalAlign: null,
    // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。
    confine: false,
    // 内容格式器：{string}（Template） ¦ {Function}
    // formatter: null
    showDelay: 0,
    // 隐藏延迟，单位ms
    hideDelay: 100,
    // 动画变换时间，单位s
    transitionDuration: 0.4,
    enterable: false,
    // 提示背景颜色，默认为透明度为0.7的黑色
    backgroundColor: 'rgba(50,50,50,0.7)',
    // 提示边框颜色
    borderColor: '#333',
    // 提示边框圆角，单位px，默认为4
    borderRadius: 4,
    // 提示边框线宽，单位px，默认为0（无边框）
    borderWidth: 0,
    // 提示内边距，单位px，默认各方向内边距为5，
    // 接受数组分别设定上右下左边距，同css
    padding: 5,
    // Extra css text
    extraCssText: '',
    // 坐标轴指示器，坐标轴触发有效
    axisPointer: {
      // 默认为直线
      // 可选为：'line' | 'shadow' | 'cross'
      type: 'line',
      // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选
      // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'
      // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴
      // 极坐标系会默认选择 angle 轴
      axis: 'auto',
      animation: 'auto',
      animationDurationUpdate: 200,
      animationEasingUpdate: 'exponentialOut',
      crossStyle: {
        color: '#999',
        width: 1,
        type: 'dashed',
        // TODO formatter
        textStyle: {} // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.

      }
    },
    textStyle: {
      color: '#fff',
      fontSize: 14
    }
  }
});

module.exports = _default;

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var env = __webpack_require__(98);

var TooltipContent = __webpack_require__(273);

var formatUtil = __webpack_require__(99);

var numberUtil = __webpack_require__(94);

var graphic = __webpack_require__(93);

var findPointFromSeries = __webpack_require__(171);

var layoutUtil = __webpack_require__(103);

var Model = __webpack_require__(102);

var globalListener = __webpack_require__(172);

var axisHelper = __webpack_require__(112);

var axisPointerViewHelper = __webpack_require__(173);

var bind = zrUtil.bind;
var each = zrUtil.each;
var parsePercent = numberUtil.parsePercent;
var proxyRect = new graphic.Rect({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
});

var _default = echarts.extendComponentView({
  type: 'tooltip',
  init: function (ecModel, api) {
    if (env.node) {
      return;
    }

    var tooltipContent = new TooltipContent(api.getDom(), api);
    this._tooltipContent = tooltipContent;
  },
  render: function (tooltipModel, ecModel, api) {
    if (env.node) {
      return;
    } // Reset


    this.group.removeAll();
    /**
     * @private
     * @type {module:echarts/component/tooltip/TooltipModel}
     */

    this._tooltipModel = tooltipModel;
    /**
     * @private
     * @type {module:echarts/model/Global}
     */

    this._ecModel = ecModel;
    /**
     * @private
     * @type {module:echarts/ExtensionAPI}
     */

    this._api = api;
    /**
     * Should be cleaned when render.
     * @private
     * @type {Array.<Array.<Object>>}
     */

    this._lastDataByCoordSys = null;
    /**
     * @private
     * @type {boolean}
     */

    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
    var tooltipContent = this._tooltipContent;
    tooltipContent.update();
    tooltipContent.setEnterable(tooltipModel.get('enterable'));

    this._initGlobalListener();

    this._keepShow();
  },
  _initGlobalListener: function () {
    var tooltipModel = this._tooltipModel;
    var triggerOn = tooltipModel.get('triggerOn');
    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {
      // If 'none', it is not controlled by mouse totally.
      if (triggerOn !== 'none') {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e, dispatchAction);
        } else if (currTrigger === 'leave') {
          this._hide(dispatchAction);
        }
      }
    }, this));
  },
  _keepShow: function () {
    var tooltipModel = this._tooltipModel;
    var ecModel = this._ecModel;
    var api = this._api; // Try to keep the tooltip show when refreshing

    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,
    // self.manuallyShowTip({x, y}) might cause tooltip hide,
    // which is not expected.
    && tooltipModel.get('triggerOn') !== 'none') {
      var self = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function () {
        // Show tip next tick after other charts are rendered
        // In case highlight action has wrong result
        // FIXME
        self.manuallyShowTip(tooltipModel, ecModel, api, {
          x: self._lastX,
          y: self._lastY
        });
      });
    }
  },

  /**
   * Show tip manually by
   * dispatchAction({
   *     type: 'showTip',
   *     x: 10,
   *     y: 10
   * });
   * Or
   * dispatchAction({
   *      type: 'showTip',
   *      seriesIndex: 0,
   *      dataIndex or dataIndexInside or name
   * });
   *
   *  TODO Batch
   */
  manuallyShowTip: function (tooltipModel, ecModel, api, payload) {
    if (payload.from === this.uid || env.node) {
      return;
    }

    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket

    this._ticket = ''; // When triggered from axisPointer.

    var dataByCoordSys = payload.dataByCoordSys;

    if (payload.tooltip && payload.x != null && payload.y != null) {
      var el = proxyRect;
      el.position = [payload.x, payload.y];
      el.update();
      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.

      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        event: {},
        dataByCoordSys: payload.dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
        return;
      }

      var pointInfo = findPointFromSeries(payload, ecModel);
      var cx = pointInfo.point[0];
      var cy = pointInfo.point[1];

      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          position: payload.position,
          target: pointInfo.el,
          event: {}
        }, dispatchAction);
      }
    } else if (payload.x != null && payload.y != null) {
      // FIXME
      // should wrap dispatchAction like `axisPointer/globalListener` ?
      api.dispatchAction({
        type: 'updateAxisPointer',
        x: payload.x,
        y: payload.y
      });

      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api.getZr().findHover(payload.x, payload.y).target,
        event: {}
      }, dispatchAction);
    }
  },
  manuallyHideTip: function (tooltipModel, ecModel, api, payload) {
    var tooltipContent = this._tooltipContent;

    if (!this._alwaysShowContent) {
      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
    }

    this._lastX = this._lastY = null;

    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction(payload, api));
    }
  },
  // Be compatible with previous design, that is, when tooltip.type is 'axis' and
  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
  // and tooltip.
  _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {
    var seriesIndex = payload.seriesIndex;
    var dataIndex = payload.dataIndex;
    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;

    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }

    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);

    if (!seriesModel) {
      return;
    }

    var data = seriesModel.getData();
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);

    if (tooltipModel.get('trigger') !== 'axis') {
      return;
    }

    api.dispatchAction({
      type: 'updateAxisPointer',
      seriesIndex: seriesIndex,
      dataIndex: dataIndex,
      position: payload.position
    });
    return true;
  },
  _tryShow: function (e, dispatchAction) {
    var el = e.target;
    var tooltipModel = this._tooltipModel;

    if (!tooltipModel) {
      return;
    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed


    this._lastX = e.offsetX;
    this._lastY = e.offsetY;
    var dataByCoordSys = e.dataByCoordSys;

    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e);
    } // Always show item tooltip if mouse is on the element with dataIndex
    else if (el && el.dataIndex != null) {
        this._lastDataByCoordSys = null;

        this._showSeriesItemTooltip(e, el, dispatchAction);
      } // Tooltip provided directly. Like legend.
      else if (el && el.tooltip) {
          this._lastDataByCoordSys = null;

          this._showComponentItemTooltip(e, el, dispatchAction);
        } else {
          this._lastDataByCoordSys = null;

          this._hide(dispatchAction);
        }
  },
  _showOrMove: function (tooltipModel, cb) {
    // showDelay is used in this case: tooltip.enterable is set
    // as true. User intent to move mouse into tooltip and click
    // something. `showDelay` makes it easyer to enter the content
    // but tooltip do not move immediately.
    var delay = tooltipModel.get('showDelay');
    cb = zrUtil.bind(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  },
  _showAxisTooltip: function (dataByCoordSys, e) {
    var ecModel = this._ecModel;
    var globalTooltipModel = this._tooltipModel;
    var point = [e.offsetX, e.offsetY];
    var singleDefaultHTML = [];
    var singleParamsList = [];
    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);
    each(dataByCoordSys, function (itemCoordSys) {
      // var coordParamList = [];
      // var coordDefaultHTML = [];
      // var coordTooltipModel = buildTooltipModel([
      //     e.tooltipOption,
      //     itemCoordSys.tooltipOption,
      //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),
      //     globalTooltipModel
      // ]);
      // var displayMode = coordTooltipModel.get('displayMode');
      // var paramsList = displayMode === 'single' ? singleParamsList : [];
      each(itemCoordSys.dataByAxis, function (item) {
        var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);
        var axisValue = item.value;
        var seriesDefaultHTML = [];

        if (!axisModel || axisValue == null) {
          return;
        }

        var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);
        zrUtil.each(item.seriesDataIndices, function (idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var dataParams = series && series.getDataParams(dataIndex);
          dataParams.axisDim = item.axisDim;
          dataParams.axisIndex = item.axisIndex;
          dataParams.axisType = item.axisType;
          dataParams.axisId = item.axisId;
          dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);
          dataParams.axisValueLabel = valueLabel;

          if (dataParams) {
            singleParamsList.push(dataParams);
            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));
          }
        }); // Default tooltip content
        // FIXME
        // (1) shold be the first data which has name?
        // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.

        var firstLine = valueLabel;
        singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));
      });
    }, this); // In most case, the second axis is shown upper than the first one.

    singleDefaultHTML.reverse();
    singleDefaultHTML = singleDefaultHTML.join('<br /><br />');
    var positionExpr = e.position;

    this._showOrMove(singleTooltipModel, function () {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);
      }
    }); // Do not trigger events here, because this branch only be entered
    // from dispatchAction.

  },
  _showSeriesItemTooltip: function (e, el, dispatchAction) {
    var ecModel = this._ecModel; // Use dataModel in element if possible
    // Used when mouseover on a element like markPoint or edge
    // In which case, the data is not main data in series.

    var seriesIndex = el.seriesIndex;
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.

    var dataModel = el.dataModel || seriesModel;
    var dataIndex = el.dataIndex;
    var dataType = el.dataType;
    var data = dataModel.getData();
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
    var tooltipTrigger = tooltipModel.get('trigger');

    if (tooltipTrigger != null && tooltipTrigger !== 'item') {
      return;
    }

    var params = dataModel.getDataParams(dataIndex, dataType);
    var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);
    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;

    this._showOrMove(tooltipModel, function () {
      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);
    }); // FIXME
    // duplicated showtip if manuallyShowTip is called from dispatchAction.


    dispatchAction({
      type: 'showTip',
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex: seriesIndex,
      from: this.uid
    });
  },
  _showComponentItemTooltip: function (e, el, dispatchAction) {
    var tooltipOpt = el.tooltip;

    if (typeof tooltipOpt === 'string') {
      var content = tooltipOpt;
      tooltipOpt = {
        content: content,
        // Fixed formatter
        formatter: content
      };
    }

    var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);
    var defaultHtml = subTooltipModel.get('content');
    var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`
    // only works on cooridinate system. In fact, we have not found case
    // that requires setting `trigger` nothing on component yet.

    this._showOrMove(subTooltipModel, function () {
      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);
    }); // If not dispatch showTip, tip may be hide triggered by axis.


    dispatchAction({
      type: 'showTip',
      from: this.uid
    });
  },
  _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {
    // Reset ticket
    this._ticket = '';

    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
      return;
    }

    var tooltipContent = this._tooltipContent;
    var formatter = tooltipModel.get('formatter');
    positionExpr = positionExpr || tooltipModel.get('position');
    var html = defaultHtml;

    if (formatter && typeof formatter === 'string') {
      html = formatUtil.formatTpl(formatter, params, true);
    } else if (typeof formatter === 'function') {
      var callback = bind(function (cbTicket, html) {
        if (cbTicket === this._ticket) {
          tooltipContent.setContent(html);

          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
        }
      }, this);
      this._ticket = asyncTicket;
      html = formatter(params, asyncTicket, callback);
    }

    tooltipContent.setContent(html);
    tooltipContent.show(tooltipModel);

    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
  },

  /**
   * @param  {string|Function|Array.<number>|Object} positionExpr
   * @param  {number} x Mouse x
   * @param  {number} y Mouse y
   * @param  {boolean} confine Whether confine tooltip content in view rect.
   * @param  {Object|<Array.<Object>} params
   * @param  {module:zrender/Element} el target element
   * @param  {module:echarts/ExtensionAPI} api
   * @return {Array.<number>}
   */
  _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {
    var viewWidth = this._api.getWidth();

    var viewHeight = this._api.getHeight();

    positionExpr = positionExpr || tooltipModel.get('position');
    var contentSize = content.getSize();
    var align = tooltipModel.get('align');
    var vAlign = tooltipModel.get('verticalAlign');
    var rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);

    if (typeof positionExpr === 'function') {
      // Callback of position can be an array or a string specify the position
      positionExpr = positionExpr([x, y], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }

    if (zrUtil.isArray(positionExpr)) {
      x = parsePercent(positionExpr[0], viewWidth);
      y = parsePercent(positionExpr[1], viewHeight);
    } else if (zrUtil.isObject(positionExpr)) {
      positionExpr.width = contentSize[0];
      positionExpr.height = contentSize[1];
      var layoutRect = layoutUtil.getLayoutRect(positionExpr, {
        width: viewWidth,
        height: viewHeight
      });
      x = layoutRect.x;
      y = layoutRect.y;
      align = null; // When positionExpr is left/top/right/bottom,
      // align and verticalAlign will not work.

      vAlign = null;
    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
    else if (typeof positionExpr === 'string' && el) {
        var pos = calcTooltipPosition(positionExpr, rect, contentSize);
        x = pos[0];
        y = pos[1];
      } else {
        var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
        x = pos[0];
        y = pos[1];
      }

    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);

    if (tooltipModel.get('confine')) {
      var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);
      x = pos[0];
      y = pos[1];
    }

    content.moveTo(x, y);
  },
  // FIXME
  // Should we remove this but leave this to user?
  _updateContentNotChangedOnAxis: function (dataByCoordSys) {
    var lastCoordSys = this._lastDataByCoordSys;
    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
      var lastDataByAxis = lastItemCoordSys.dataByAxis || {};
      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {
        var thisItem = thisDataByAxis[indexAxis] || {};
        var lastIndices = lastItem.seriesDataIndices || [];
        var newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {
          var newIdxItem = newIndices[j];
          contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    return !!contentNotChanged;
  },
  _hide: function (dispatchAction) {
    // Do not directly hideLater here, because this behavior may be prevented
    // in dispatchAction when showTip is dispatched.
    // FIXME
    // duplicated hideTip if manuallyHideTip is called from dispatchAction.
    this._lastDataByCoordSys = null;
    dispatchAction({
      type: 'hideTip',
      from: this.uid
    });
  },
  dispose: function (ecModel, api) {
    if (env.node) {
      return;
    }

    this._tooltipContent.hide();

    globalListener.unregister('itemTooltip', api);
  }
});
/**
 * @param {Array.<Object|module:echarts/model/Model>} modelCascade
 * From top to bottom. (the last one should be globalTooltipModel);
 */


function buildTooltipModel(modelCascade) {
  var resultModel = modelCascade.pop();

  while (modelCascade.length) {
    var tooltipOpt = modelCascade.pop();

    if (tooltipOpt) {
      if (tooltipOpt instanceof Model) {
        tooltipOpt = tooltipOpt.get('tooltip', true);
      } // In each data item tooltip can be simply write:
      // {
      //  value: 10,
      //  tooltip: 'Something you need to know'
      // }


      if (typeof tooltipOpt === 'string') {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }

      resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);
    }
  }

  return resultModel;
}

function makeDispatchAction(payload, api) {
  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
}

function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {
  var size = getOuterSize(el);
  var width = size.width;
  var height = size.height;

  if (gapH != null) {
    if (x + width + gapH > viewWidth) {
      x -= width + gapH;
    } else {
      x += gapH;
    }
  }

  if (gapV != null) {
    if (y + height + gapV > viewHeight) {
      y -= height + gapV;
    } else {
      y += gapV;
    }
  }

  return [x, y];
}

function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {
  var size = getOuterSize(el);
  var width = size.width;
  var height = size.height;
  x = Math.min(x + width, viewWidth) - width;
  y = Math.min(y + height, viewHeight) - height;
  x = Math.max(x, 0);
  y = Math.max(y, 0);
  return [x, y];
}

function getOuterSize(el) {
  var width = el.clientWidth;
  var height = el.clientHeight; // Consider browser compatibility.
  // IE8 does not support getComputedStyle.

  if (document.defaultView && document.defaultView.getComputedStyle) {
    var stl = document.defaultView.getComputedStyle(el);

    if (stl) {
      width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
      height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
    }
  }

  return {
    width: width,
    height: height
  };
}

function calcTooltipPosition(position, rect, contentSize) {
  var domWidth = contentSize[0];
  var domHeight = contentSize[1];
  var gap = 5;
  var x = 0;
  var y = 0;
  var rectWidth = rect.width;
  var rectHeight = rect.height;

  switch (position) {
    case 'inside':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;

    case 'top':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y - domHeight - gap;
      break;

    case 'bottom':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight + gap;
      break;

    case 'left':
      x = rect.x - domWidth - gap;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;

    case 'right':
      x = rect.x + rectWidth + gap;
      y = rect.y + rectHeight / 2 - domHeight / 2;
  }

  return [x, y];
}

function isCenterAlign(align) {
  return align === 'center' || align === 'middle';
}

module.exports = _default;

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var zrColor = __webpack_require__(113);

var eventUtil = __webpack_require__(106);

var env = __webpack_require__(98);

var formatUtil = __webpack_require__(99);

var each = zrUtil.each;
var toCamelCase = formatUtil.toCamelCase;
var vendors = ['', '-webkit-', '-moz-', '-o-'];
var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';
/**
 * @param {number} duration
 * @return {string}
 * @inner
 */

function assembleTransition(duration) {
  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
  var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;
  return zrUtil.map(vendors, function (vendorPrefix) {
    return vendorPrefix + 'transition:' + transitionText;
  }).join(';');
}
/**
 * @param {Object} textStyle
 * @return {string}
 * @inner
 */


function assembleFont(textStyleModel) {
  var cssText = [];
  var fontSize = textStyleModel.get('fontSize');
  var color = textStyleModel.getTextColor();
  color && cssText.push('color:' + color);
  cssText.push('font:' + textStyleModel.getFont());
  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
  each(['decoration', 'align'], function (name) {
    var val = textStyleModel.get(name);
    val && cssText.push('text-' + name + ':' + val);
  });
  return cssText.join(';');
}
/**
 * @param {Object} tooltipModel
 * @return {string}
 * @inner
 */


function assembleCssText(tooltipModel) {
  var cssText = [];
  var transitionDuration = tooltipModel.get('transitionDuration');
  var backgroundColor = tooltipModel.get('backgroundColor');
  var textStyleModel = tooltipModel.getModel('textStyle');
  var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.

  transitionDuration && cssText.push(assembleTransition(transitionDuration));

  if (backgroundColor) {
    if (env.canvasSupported) {
      cssText.push('background-Color:' + backgroundColor);
    } else {
      // for ie
      cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));
      cssText.push('filter:alpha(opacity=70)');
    }
  } // Border style


  each(['width', 'color', 'radius'], function (name) {
    var borderName = 'border-' + name;
    var camelCase = toCamelCase(borderName);
    var val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
  }); // Text style

  cssText.push(assembleFont(textStyleModel)); // Padding

  if (padding != null) {
    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');
  }

  return cssText.join(';') + ';';
}
/**
 * @alias module:echarts/component/tooltip/TooltipContent
 * @constructor
 */


function TooltipContent(container, api) {
  var el = document.createElement('div');
  var zr = this._zr = api.getZr();
  this.el = el;
  this._x = api.getWidth() / 2;
  this._y = api.getHeight() / 2;
  container.appendChild(el);
  this._container = container;
  this._show = false;
  /**
   * @private
   */

  this._hideTimeout;
  var self = this;

  el.onmouseenter = function () {
    // clear the timeout in hideLater and keep showing tooltip
    if (self._enterable) {
      clearTimeout(self._hideTimeout);
      self._show = true;
    }

    self._inContent = true;
  };

  el.onmousemove = function (e) {
    e = e || window.event;

    if (!self._enterable) {
      // Try trigger zrender event to avoid mouse
      // in and out shape too frequently
      var handler = zr.handler;
      eventUtil.normalizeEvent(container, e, true);
      handler.dispatch('mousemove', e);
    }
  };

  el.onmouseleave = function () {
    if (self._enterable) {
      if (self._show) {
        self.hideLater(self._hideDelay);
      }
    }

    self._inContent = false;
  };
}

TooltipContent.prototype = {
  constructor: TooltipContent,

  /**
   * @private
   * @type {boolean}
   */
  _enterable: true,

  /**
   * Update when tooltip is rendered
   */
  update: function () {
    // FIXME
    // Move this logic to ec main?
    var container = this._container;
    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
    var domStyle = container.style;

    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
      domStyle.position = 'relative';
    } // Hide the tooltip
    // PENDING
    // this.hide();

  },
  show: function (tooltipModel) {
    clearTimeout(this._hideTimeout);
    var el = this.el;
    el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
    + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');
    el.style.display = el.innerHTML ? 'block' : 'none';
    this._show = true;
  },
  setContent: function (content) {
    this.el.innerHTML = content == null ? '' : content;
  },
  setEnterable: function (enterable) {
    this._enterable = enterable;
  },
  getSize: function () {
    var el = this.el;
    return [el.clientWidth, el.clientHeight];
  },
  moveTo: function (x, y) {
    // xy should be based on canvas root. But tooltipContent is
    // the sibling of canvas root. So padding of ec container
    // should be considered here.
    var zr = this._zr;
    var viewportRootOffset;

    if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {
      x += viewportRootOffset.offsetLeft;
      y += viewportRootOffset.offsetTop;
    }

    var style = this.el.style;
    style.left = x + 'px';
    style.top = y + 'px';
    this._x = x;
    this._y = y;
  },
  hide: function () {
    this.el.style.display = 'none';
    this._show = false;
  },
  hideLater: function (time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times

        this._show = false;
        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  },
  isShow: function () {
    return this._show;
  }
};
var _default = TooltipContent;
module.exports = _default;

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var graphic = __webpack_require__(93);

var _layout = __webpack_require__(103);

var getLayoutRect = _layout.getLayoutRect;
// Model
echarts.extendComponentModel({
  type: 'title',
  layoutMode: {
    type: 'box',
    ignoreSize: true
  },
  defaultOption: {
    // 一级层叠
    zlevel: 0,
    // 二级层叠
    z: 6,
    show: true,
    text: '',
    // 超链接跳转
    // link: null,
    // 仅支持self | blank
    target: 'blank',
    subtext: '',
    // 超链接跳转
    // sublink: null,
    // 仅支持self | blank
    subtarget: 'blank',
    // 'center' ¦ 'left' ¦ 'right'
    // ¦ {number}（x坐标，单位px）
    left: 0,
    // 'top' ¦ 'bottom' ¦ 'center'
    // ¦ {number}（y坐标，单位px）
    top: 0,
    // 水平对齐
    // 'auto' | 'left' | 'right' | 'center'
    // 默认根据 left 的位置判断是左对齐还是右对齐
    // textAlign: null
    //
    // 垂直对齐
    // 'auto' | 'top' | 'bottom' | 'middle'
    // 默认根据 top 位置判断是上对齐还是下对齐
    // textBaseline: null
    backgroundColor: 'rgba(0,0,0,0)',
    // 标题边框颜色
    borderColor: '#ccc',
    // 标题边框线宽，单位px，默认为0（无边框）
    borderWidth: 0,
    // 标题内边距，单位px，默认各方向内边距为5，
    // 接受数组分别设定上右下左边距，同css
    padding: 5,
    // 主副标题纵向间隔，单位px，默认为10，
    itemGap: 10,
    textStyle: {
      fontSize: 18,
      fontWeight: 'bolder',
      color: '#333'
    },
    subtextStyle: {
      color: '#aaa'
    }
  }
}); // View

echarts.extendComponentView({
  type: 'title',
  render: function (titleModel, ecModel, api) {
    this.group.removeAll();

    if (!titleModel.get('show')) {
      return;
    }

    var group = this.group;
    var textStyleModel = titleModel.getModel('textStyle');
    var subtextStyleModel = titleModel.getModel('subtextStyle');
    var textAlign = titleModel.get('textAlign');
    var textBaseline = titleModel.get('textBaseline');
    var textEl = new graphic.Text({
      style: graphic.setTextStyle({}, textStyleModel, {
        text: titleModel.get('text'),
        textFill: textStyleModel.getTextColor()
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var textRect = textEl.getBoundingRect();
    var subText = titleModel.get('subtext');
    var subTextEl = new graphic.Text({
      style: graphic.setTextStyle({}, subtextStyleModel, {
        text: subText,
        textFill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get('itemGap'),
        textVerticalAlign: 'top'
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var link = titleModel.get('link');
    var sublink = titleModel.get('sublink');
    textEl.silent = !link;
    subTextEl.silent = !sublink;

    if (link) {
      textEl.on('click', function () {
        window.open(link, '_' + titleModel.get('target'));
      });
    }

    if (sublink) {
      subTextEl.on('click', function () {
        window.open(sublink, '_' + titleModel.get('subtarget'));
      });
    }

    group.add(textEl);
    subText && group.add(subTextEl); // If no subText, but add subTextEl, there will be an empty line.

    var groupRect = group.getBoundingRect();
    var layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    var layoutRect = getLayoutRect(layoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    }, titleModel.get('padding')); // Adjust text align based on position

    if (!textAlign) {
      // Align left if title is on the left. center and right is same
      textAlign = titleModel.get('left') || titleModel.get('right');

      if (textAlign === 'middle') {
        textAlign = 'center';
      } // Adjust layout by text align


      if (textAlign === 'right') {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === 'center') {
        layoutRect.x += layoutRect.width / 2;
      }
    }

    if (!textBaseline) {
      textBaseline = titleModel.get('top') || titleModel.get('bottom');

      if (textBaseline === 'center') {
        textBaseline = 'middle';
      }

      if (textBaseline === 'bottom') {
        layoutRect.y += layoutRect.height;
      } else if (textBaseline === 'middle') {
        layoutRect.y += layoutRect.height / 2;
      }

      textBaseline = textBaseline || 'top';
    }

    group.attr('position', [layoutRect.x, layoutRect.y]);
    var alignStyle = {
      textAlign: textAlign,
      textVerticalAlign: textBaseline
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle); // Render background
    // Get groupRect again because textAlign has been changed

    groupRect = group.getBoundingRect();
    var padding = layoutRect.margin;
    var style = titleModel.getItemStyle(['color', 'opacity']);
    style.fill = titleModel.get('backgroundColor');
    var rect = new graphic.Rect({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get('borderRadius')
      },
      style: style,
      silent: true
    });
    graphic.subPixelOptimizeRect(rect);
    group.add(rect);
  }
});

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(276);

__webpack_require__(279);

__webpack_require__(280);

__webpack_require__(281);

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

__webpack_require__(174);

__webpack_require__(277);

__webpack_require__(175);

var legendFilter = __webpack_require__(278);

var Component = __webpack_require__(105);

// Do not contain scrollable legend, for sake of file size.
// Series Filter
echarts.registerProcessor(legendFilter);
Component.registerSubTypeDefaulter('legend', function () {
  // Default 'plain' when no type specified.
  return 'plain';
});

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

function legendSelectActionHandler(methodName, payload, ecModel) {
  var selectedMap = {};
  var isToggleSelect = methodName === 'toggleSelected';
  var isSelected; // Update all legend components

  ecModel.eachComponent('legend', function (legendModel) {
    if (isToggleSelect && isSelected != null) {
      // Force other legend has same selected status
      // Or the first is toggled to true and other are toggled to false
      // In the case one legend has some item unSelected in option. And if other legend
      // doesn't has the item, they will assume it is selected.
      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
    } else {
      legendModel[methodName](payload.name);
      isSelected = legendModel.isSelected(payload.name);
    }

    var legendData = legendModel.getData();
    zrUtil.each(legendData, function (model) {
      var name = model.get('name'); // Wrap element

      if (name === '\n' || name === '') {
        return;
      }

      var isItemSelected = legendModel.isSelected(name);

      if (selectedMap.hasOwnProperty(name)) {
        // Unselected if any legend is unselected
        selectedMap[name] = selectedMap[name] && isItemSelected;
      } else {
        selectedMap[name] = isItemSelected;
      }
    });
  }); // Return the event explicitly

  return {
    name: payload.name,
    selected: selectedMap
  };
}
/**
 * @event legendToggleSelect
 * @type {Object}
 * @property {string} type 'legendToggleSelect'
 * @property {string} [from]
 * @property {string} name Series name or data item name
 */


echarts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));
/**
 * @event legendSelect
 * @type {Object}
 * @property {string} type 'legendSelect'
 * @property {string} name Series name or data item name
 */

echarts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));
/**
 * @event legendUnSelect
 * @type {Object}
 * @property {string} type 'legendUnSelect'
 * @property {string} name Series name or data item name
 */

echarts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));

/***/ }),
/* 278 */
/***/ (function(module, exports) {

function _default(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: 'legend'
  });

  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function (series) {
      // If in any legend component the status is not selected.
      // Because in legend series is assumed selected when it is not in the legend data.
      for (var i = 0; i < legendModels.length; i++) {
        if (!legendModels[i].isSelected(series.name)) {
          return false;
        }
      }

      return true;
    });
  }
}

module.exports = _default;

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

var LegendModel = __webpack_require__(174);

var _layout = __webpack_require__(103);

var mergeLayoutParam = _layout.mergeLayoutParam;
var getLayoutParams = _layout.getLayoutParams;
var ScrollableLegendModel = LegendModel.extend({
  type: 'legend.scroll',

  /**
   * @param {number} scrollDataIndex
   */
  setScrollDataIndex: function (scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  },
  defaultOption: {
    scrollDataIndex: 0,
    pageButtonItemGap: 5,
    pageButtonGap: null,
    pageButtonPosition: 'end',
    // 'start' or 'end'
    pageFormatter: '{current}/{total}',
    // If null/undefined, do not show page.
    pageIcons: {
      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']
    },
    pageIconColor: '#2f4554',
    pageIconInactiveColor: '#aaa',
    pageIconSize: 15,
    // Can be [10, 3], which represents [width, height]
    pageTextStyle: {
      color: '#333'
    },
    animationDurationUpdate: 800
  },

  /**
   * @override
   */
  init: function (option, parentModel, ecModel, extraOpt) {
    var inputPositionParams = getLayoutParams(option);
    ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);
    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
  },

  /**
   * @override
   */
  mergeOption: function (option, extraOpt) {
    ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);
    mergeAndNormalizeLayoutParams(this, this.option, option);
  },
  getOrient: function () {
    return this.get('orient') === 'vertical' ? {
      index: 1,
      name: 'vertical'
    } : {
      index: 0,
      name: 'horizontal'
    };
  }
}); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.

function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
  var orient = legendModel.getOrient();
  var ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  mergeLayoutParam(target, raw, {
    type: 'box',
    ignoreSize: ignoreSize
  });
}

var _default = ScrollableLegendModel;
module.exports = _default;

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var graphic = __webpack_require__(93);

var layoutUtil = __webpack_require__(103);

var LegendView = __webpack_require__(175);

/**
 * Separate legend and scrollable legend to reduce package size.
 */
var Group = graphic.Group;
var WH = ['width', 'height'];
var XY = ['x', 'y'];
var ScrollableLegendView = LegendView.extend({
  type: 'legend.scroll',
  newlineDisabled: true,
  init: function () {
    ScrollableLegendView.superCall(this, 'init');
    /**
     * @private
     * @type {number} For `scroll`.
     */

    this._currentIndex = 0;
    /**
     * @private
     * @type {module:zrender/container/Group}
     */

    this.group.add(this._containerGroup = new Group());

    this._containerGroup.add(this.getContentGroup());
    /**
     * @private
     * @type {module:zrender/container/Group}
     */


    this.group.add(this._controllerGroup = new Group());
    /**
     *
     * @private
     */

    this._showController;
  },

  /**
   * @override
   */
  resetInner: function () {
    ScrollableLegendView.superCall(this, 'resetInner');

    this._controllerGroup.removeAll();

    this._containerGroup.removeClipPath();

    this._containerGroup.__rectSize = null;
  },

  /**
   * @override
   */
  renderInner: function (itemAlign, legendModel, ecModel, api) {
    var me = this; // Render content items.

    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);
    var controllerGroup = this._controllerGroup;
    var pageIconSize = legendModel.get('pageIconSize', true);

    if (!zrUtil.isArray(pageIconSize)) {
      pageIconSize = [pageIconSize, pageIconSize];
    }

    createPageButton('pagePrev', 0);
    var pageTextStyleModel = legendModel.getModel('pageTextStyle');
    controllerGroup.add(new graphic.Text({
      name: 'pageText',
      style: {
        textFill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        textVerticalAlign: 'middle',
        textAlign: 'center'
      },
      silent: true
    }));
    createPageButton('pageNext', 1);

    function createPageButton(name, iconIdx) {
      var pageDataIndexName = name + 'DataIndex';
      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {
        // Buttons will be created in each render, so we do not need
        // to worry about avoiding using legendModel kept in scope.
        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)
      }, {
        x: -pageIconSize[0] / 2,
        y: -pageIconSize[1] / 2,
        width: pageIconSize[0],
        height: pageIconSize[1]
      });
      icon.name = name;
      controllerGroup.add(icon);
    }
  },

  /**
   * @override
   */
  layoutInner: function (legendModel, itemAlign, maxSize) {
    var contentGroup = this.getContentGroup();
    var containerGroup = this._containerGroup;
    var controllerGroup = this._controllerGroup;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var hw = WH[1 - orientIdx];
    var yx = XY[1 - orientIdx]; // Place items in contentGroup.

    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    layoutUtil.box( // Buttons in controller are layout always horizontally.
    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));
    var contentRect = contentGroup.getBoundingRect();
    var controllerRect = controllerGroup.getBoundingRect();
    var showController = this._showController = contentRect[wh] > maxSize[wh];
    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.

    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.

    var containerPos = [0, 0];
    var controllerPos = [-controllerRect.x, -controllerRect.y];
    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.

    if (showController) {
      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.

      if (pageButtonPosition === 'end') {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } // controller is on the left / top.
      else {
          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
        }
    } // Always align controller to content as 'middle'.


    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.attr('position', contentPos);
    containerGroup.attr('position', containerPos);
    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.
    // mainRect should not be calculated by `this.group.getBoundingRect()`
    // for sake of the overflow.

    var mainRect = this.group.getBoundingRect();
    var mainRect = {
      x: 0,
      y: 0
    }; // Consider content may be overflow (should be clipped).

    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.

    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];

    if (showController) {
      var clipShape = {
        x: 0,
        y: 0
      };
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new graphic.Rect({
        shape: clipShape
      })); // Consider content may be larger than container, container rect
      // can not be obtained from `containerGroup.getBoundingRect()`.

      containerGroup.__rectSize = clipShape[wh];
    } else {
      // Do not remove or ignore controller. Keep them set as place holders.
      controllerGroup.eachChild(function (child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    } // Content translate animation.


    var pageInfo = this._getPageInfo(legendModel);

    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {
      position: pageInfo.contentPosition
    }, // When switch from "show controller" to "not show controller", view should be
    // updated immediately without animation, otherwise causes weird efffect.
    showController ? legendModel : false);

    this._updatePageInfoView(legendModel, pageInfo);

    return mainRect;
  },
  _pageGo: function (to, legendModel, api) {
    var scrollDataIndex = this._getPageInfo(legendModel)[to];

    scrollDataIndex != null && api.dispatchAction({
      type: 'legendScroll',
      scrollDataIndex: scrollDataIndex,
      legendId: legendModel.id
    });
  },
  _updatePageInfoView: function (legendModel, pageInfo) {
    var controllerGroup = this._controllerGroup;
    zrUtil.each(['pagePrev', 'pageNext'], function (name) {
      var canJump = pageInfo[name + 'DataIndex'] != null;
      var icon = controllerGroup.childOfName(name);

      if (icon) {
        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));
        icon.cursor = canJump ? 'pointer' : 'default';
      }
    });
    var pageText = controllerGroup.childOfName('pageText');
    var pageFormatter = legendModel.get('pageFormatter');
    var pageIndex = pageInfo.pageIndex;
    var current = pageIndex != null ? pageIndex + 1 : 0;
    var total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({
      current: current,
      total: total
    }));
  },

  /**
   * @param {module:echarts/model/Model} legendModel
   * @return {Object} {
   *  contentPosition: Array.<number>, null when data item not found.
   *  pageIndex: number, null when data item not found.
   *  pageCount: number, always be a number, can be 0.
   *  pagePrevDataIndex: number, null when no next page.
   *  pageNextDataIndex: number, null when no previous page.
   * }
   */
  _getPageInfo: function (legendModel) {
    // Align left or top by the current dataIndex.
    var currDataIndex = legendModel.get('scrollDataIndex', true);
    var contentGroup = this.getContentGroup();
    var contentRect = contentGroup.getBoundingRect();
    var containerRectSize = this._containerGroup.__rectSize;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var hw = WH[1 - orientIdx];
    var xy = XY[orientIdx];
    var contentPos = contentGroup.position.slice();
    var pageIndex;
    var pagePrevDataIndex;
    var pageNextDataIndex;
    var targetItemGroup;

    if (this._showController) {
      contentGroup.eachChild(function (child) {
        if (child.__legendDataIndex === currDataIndex) {
          targetItemGroup = child;
        }
      });
    } else {
      targetItemGroup = contentGroup.childAt(0);
    }

    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;

    if (targetItemGroup) {
      var itemRect = targetItemGroup.getBoundingRect();
      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];
      contentPos[orientIdx] = -itemLoc - contentRect[xy];
      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);
      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;
      var winRect = {
        x: 0,
        y: 0
      };
      winRect[wh] = containerRectSize;
      winRect[hw] = contentRect[hw];
      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];
      var startIdx;
      var children = contentGroup.children();
      contentGroup.eachChild(function (child, index) {
        var itemRect = getItemRect(child);

        if (itemRect.intersect(winRect)) {
          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the
          // current window is shown at the begining of next window.

          pageNextDataIndex = child.__legendDataIndex;
        } // If the last item is shown entirely, no next page.


        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {
          pageNextDataIndex = null;
        }
      }); // Always align based on the left/top most item, so the left/top most
      // item in the previous window is needed to be found here.

      if (startIdx != null) {
        var startItem = children[startIdx];
        var startRect = getItemRect(startItem);
        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.

        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {
          pagePrevDataIndex = null;
        } else {
          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {
            startIdx--;
          }

          pagePrevDataIndex = children[startIdx].__legendDataIndex;
        }
      }
    }

    return {
      contentPosition: contentPos,
      pageIndex: pageIndex,
      pageCount: pageCount,
      pagePrevDataIndex: pagePrevDataIndex,
      pageNextDataIndex: pageNextDataIndex
    };

    function getItemRect(el) {
      var itemRect = el.getBoundingRect().clone();
      itemRect[xy] += el.position[orientIdx];
      return itemRect;
    }
  }
});
var _default = ScrollableLegendView;
module.exports = _default;

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

/**
 * @event legendScroll
 * @type {Object}
 * @property {string} type 'legendScroll'
 * @property {string} scrollDataIndex
 */
echarts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {
  var scrollDataIndex = payload.scrollDataIndex;
  scrollDataIndex != null && ecModel.eachComponent({
    mainType: 'legend',
    subType: 'scroll',
    query: payload
  }, function (legendModel) {
    legendModel.setScrollDataIndex(scrollDataIndex);
  });
});

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(177);

__webpack_require__(116);

__webpack_require__(117);

__webpack_require__(284);

__webpack_require__(285);

__webpack_require__(286);

__webpack_require__(287);

__webpack_require__(179);

__webpack_require__(180);

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var numberUtil = __webpack_require__(94);

var helper = __webpack_require__(136);

var each = zrUtil.each;
var asc = numberUtil.asc;
/**
 * Operate single axis.
 * One axis can only operated by one axis operator.
 * Different dataZoomModels may be defined to operate the same axis.
 * (i.e. 'inside' data zoom and 'slider' data zoom components)
 * So dataZoomModels share one axisProxy in that case.
 *
 * @class
 */

var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {
  /**
   * @private
   * @type {string}
   */
  this._dimName = dimName;
  /**
   * @private
   */

  this._axisIndex = axisIndex;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._valueWindow;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._percentWindow;
  /**
   * @private
   * @type {Array.<number>}
   */

  this._dataExtent;
  /**
   * {minSpan, maxSpan, minValueSpan, maxValueSpan}
   * @private
   * @type {Object}
   */

  this._minMaxSpan;
  /**
   * @readOnly
   * @type {module: echarts/model/Global}
   */

  this.ecModel = ecModel;
  /**
   * @private
   * @type {module: echarts/component/dataZoom/DataZoomModel}
   */

  this._dataZoomModel = dataZoomModel;
};

AxisProxy.prototype = {
  constructor: AxisProxy,

  /**
   * Whether the axisProxy is hosted by dataZoomModel.
   *
   * @public
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   * @return {boolean}
   */
  hostedBy: function (dataZoomModel) {
    return this._dataZoomModel === dataZoomModel;
  },

  /**
   * @return {Array.<number>} Value can only be NaN or finite value.
   */
  getDataValueWindow: function () {
    return this._valueWindow.slice();
  },

  /**
   * @return {Array.<number>}
   */
  getDataPercentWindow: function () {
    return this._percentWindow.slice();
  },

  /**
   * @public
   * @param {number} axisIndex
   * @return {Array} seriesModels
   */
  getTargetSeriesModels: function () {
    var seriesModels = [];
    var ecModel = this.ecModel;
    ecModel.eachSeries(function (seriesModel) {
      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {
        var dimName = this._dimName;
        var axisModel = ecModel.queryComponents({
          mainType: dimName + 'Axis',
          index: seriesModel.get(dimName + 'AxisIndex'),
          id: seriesModel.get(dimName + 'AxisId')
        })[0];

        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {
          seriesModels.push(seriesModel);
        }
      }
    }, this);
    return seriesModels;
  },
  getAxisModel: function () {
    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);
  },
  getOtherAxisModel: function () {
    var axisDim = this._dimName;
    var ecModel = this.ecModel;
    var axisModel = this.getAxisModel();
    var isCartesian = axisDim === 'x' || axisDim === 'y';
    var otherAxisDim;
    var coordSysIndexName;

    if (isCartesian) {
      coordSysIndexName = 'gridIndex';
      otherAxisDim = axisDim === 'x' ? 'y' : 'x';
    } else {
      coordSysIndexName = 'polarIndex';
      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';
    }

    var foundOtherAxisModel;
    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {
      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {
        foundOtherAxisModel = otherAxisModel;
      }
    });
    return foundOtherAxisModel;
  },
  getMinMaxSpan: function () {
    return zrUtil.clone(this._minMaxSpan);
  },

  /**
   * Only calculate by given range and this._dataExtent, do not change anything.
   *
   * @param {Object} opt
   * @param {number} [opt.start]
   * @param {number} [opt.end]
   * @param {number} [opt.startValue]
   * @param {number} [opt.endValue]
   */
  calculateDataWindow: function (opt) {
    var dataExtent = this._dataExtent;
    var axisModel = this.getAxisModel();
    var scale = axisModel.axis.scale;

    var rangePropMode = this._dataZoomModel.getRangePropMode();

    var percentExtent = [0, 100];
    var percentWindow = [opt.start, opt.end];
    var valueWindow = [];
    each(['startValue', 'endValue'], function (prop) {
      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);
    }); // Normalize bound.

    each([0, 1], function (idx) {
      var boundValue = valueWindow[idx];
      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or
      // on `valueProp` ('startValue', 'endValue'). The former one is suitable
      // for cases that a dataZoom component controls multiple axes with different
      // unit or extent, and the latter one is suitable for accurate zoom by pixel
      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,
      // but it is awkward that `percentProp` can not be obtained from `valueProp`
      // accurately (because all of values that are overflow the `dataExtent` will
      // be calculated to percent '100%'). So we have to use
      // `dataZoom.getRangePropMode()` to mark which prop is used.
      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise
      // it remains its original value.

      if (rangePropMode[idx] === 'percent') {
        if (boundPercent == null) {
          boundPercent = percentExtent[idx];
        } // Use scale.parse to math round for category or time axis.


        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));
      } else {
        // Calculating `percent` from `value` may be not accurate, because
        // This calculation can not be inversed, because all of values that
        // are overflow the `dataExtent` will be calculated to percent '100%'
        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);
      } // valueWindow[idx] = round(boundValue);
      // percentWindow[idx] = round(boundPercent);


      valueWindow[idx] = boundValue;
      percentWindow[idx] = boundPercent;
    });
    return {
      valueWindow: asc(valueWindow),
      percentWindow: asc(percentWindow)
    };
  },

  /**
   * Notice: reset should not be called before series.restoreData() called,
   * so it is recommanded to be called in "process stage" but not "model init
   * stage".
   *
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   */
  reset: function (dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    } // Culculate data window and data extent, and record them.


    this._dataExtent = calculateDataExtent(this, this._dimName, this.getTargetSeriesModels());
    var dataWindow = this.calculateDataWindow(dataZoomModel.option);
    this._valueWindow = dataWindow.valueWindow;
    this._percentWindow = dataWindow.percentWindow;
    setMinMaxSpan(this); // Update axis setting then.

    setAxisModel(this);
  },

  /**
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   */
  restore: function (dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }

    this._valueWindow = this._percentWindow = null;
    setAxisModel(this, true);
  },

  /**
   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
   */
  filterData: function (dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }

    var axisDim = this._dimName;
    var seriesModels = this.getTargetSeriesModels();
    var filterMode = dataZoomModel.get('filterMode');
    var valueWindow = this._valueWindow;

    if (filterMode === 'none') {
      return;
    } // FIXME
    // Toolbox may has dataZoom injected. And if there are stacked bar chart
    // with NaN data, NaN will be filtered and stack will be wrong.
    // So we need to force the mode to be set empty.
    // In fect, it is not a big deal that do not support filterMode-'filter'
    // when using toolbox#dataZoom, utill tooltip#dataZoom support "single axis
    // selection" some day, which might need "adapt to data extent on the
    // otherAxis", which is disabled by filterMode-'empty'.


    var otherAxisModel = this.getOtherAxisModel();

    if (dataZoomModel.get('$fromToolbox') && otherAxisModel && otherAxisModel.get('type') === 'category') {
      filterMode = 'empty';
    } // Process series data


    each(seriesModels, function (seriesModel) {
      var seriesData = seriesModel.getData();
      var dataDims = seriesModel.coordDimToDataDim(axisDim);

      if (filterMode === 'weakFilter') {
        seriesData && seriesData.filterSelf(function (dataIndex) {
          var leftOut;
          var rightOut;
          var hasValue;

          for (var i = 0; i < dataDims.length; i++) {
            var value = seriesData.get(dataDims[i], dataIndex);
            var thisHasValue = !isNaN(value);
            var thisLeftOut = value < valueWindow[0];
            var thisRightOut = value > valueWindow[1];

            if (thisHasValue && !thisLeftOut && !thisRightOut) {
              return true;
            }

            thisHasValue && (hasValue = true);
            thisLeftOut && (leftOut = true);
            thisRightOut && (rightOut = true);
          } // If both left out and right out, do not filter.


          return hasValue && leftOut && rightOut;
        });
      } else {
        seriesData && each(dataDims, function (dim) {
          if (filterMode === 'empty') {
            seriesModel.setData(seriesData.map(dim, function (value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            seriesData.filterSelf(dim, isInWindow);
          }
        });
      }
    });

    function isInWindow(value) {
      return value >= valueWindow[0] && value <= valueWindow[1];
    }
  }
};

function calculateDataExtent(axisProxy, axisDim, seriesModels) {
  var dataExtent = [Infinity, -Infinity];
  each(seriesModels, function (seriesModel) {
    var seriesData = seriesModel.getData();

    if (seriesData) {
      each(seriesModel.coordDimToDataDim(axisDim), function (dim) {
        var seriesExtent = seriesData.getDataExtent(dim);
        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
      });
    }
  });

  if (dataExtent[1] < dataExtent[0]) {
    dataExtent = [NaN, NaN];
  } // It is important to get "consistent" extent when more then one axes is
  // controlled by a `dataZoom`, otherwise those axes will not be synchronized
  // when zooming. But it is difficult to know what is "consistent", considering
  // axes have different type or even different meanings (For example, two
  // time axes are used to compare data of the same date in different years).
  // So basically dataZoom just obtains extent by series.data (in category axis
  // extent can be obtained from axis.data).
  // Nevertheless, user can set min/max/scale on axes to make extent of axes
  // consistent.


  fixExtentByAxis(axisProxy, dataExtent);
  return dataExtent;
}

function fixExtentByAxis(axisProxy, dataExtent) {
  var axisModel = axisProxy.getAxisModel();
  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined
  // by axis.data by default.

  var isCategoryAxis = axisModel.get('type') === 'category';
  var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;

  if (min != null && min !== 'dataMin' && typeof min !== 'function') {
    dataExtent[0] = min;
  } else if (isCategoryAxis) {
    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;
  }

  var max = axisModel.getMax(true);

  if (max != null && max !== 'dataMax' && typeof max !== 'function') {
    dataExtent[1] = max;
  } else if (isCategoryAxis) {
    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;
  }

  if (!axisModel.get('scale', true)) {
    dataExtent[0] > 0 && (dataExtent[0] = 0);
    dataExtent[1] < 0 && (dataExtent[1] = 0);
  } // For value axis, if min/max/scale are not set, we just use the extent obtained
  // by series data, which may be a little different from the extent calculated by
  // `axisHelper.getScaleExtent`. But the different just affects the experience a
  // little when zooming. So it will not be fixed until some users require it strongly.


  return dataExtent;
}

function setAxisModel(axisProxy, isRestore) {
  var axisModel = axisProxy.getAxisModel();
  var percentWindow = axisProxy._percentWindow;
  var valueWindow = axisProxy._valueWindow;

  if (!percentWindow) {
    return;
  } // [0, 500]: arbitrary value, guess axis extent.


  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);
  precision = Math.min(precision, 20); // isRestore or isFull

  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;
  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
}

function setMinMaxSpan(axisProxy) {
  var minMaxSpan = axisProxy._minMaxSpan = {};
  var dataZoomModel = axisProxy._dataZoomModel;
  each(['min', 'max'], function (minMax) {
    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan

    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');

    if (valueSpan != null) {
      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;
      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);

      if (valueSpan != null) {
        var dataExtent = axisProxy._dataExtent;
        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      }
    }
  });
}

var _default = AxisProxy;
module.exports = _default;

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var DataZoomModel = __webpack_require__(116);

var SliderZoomModel = DataZoomModel.extend({
  type: 'dataZoom.slider',
  layoutMode: 'box',

  /**
   * @protected
   */
  defaultOption: {
    show: true,
    // ph => placeholder. Using placehoder here because
    // deault value can only be drived in view stage.
    right: 'ph',
    // Default align to grid rect.
    top: 'ph',
    // Default align to grid rect.
    width: 'ph',
    // Default align to grid rect.
    height: 'ph',
    // Default align to grid rect.
    left: null,
    // Default align to grid rect.
    bottom: null,
    // Default align to grid rect.
    backgroundColor: 'rgba(47,69,84,0)',
    // Background of slider zoom component.
    // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,
    // highest priority, remain for compatibility of
    // previous version, but not recommended any more.
    dataBackground: {
      lineStyle: {
        color: '#2f4554',
        width: 0.5,
        opacity: 0.3
      },
      areaStyle: {
        color: 'rgba(47,69,84,0.3)',
        opacity: 0.3
      }
    },
    borderColor: '#ddd',
    // border color of the box. For compatibility,
    // if dataBackgroundColor is set, borderColor
    // is ignored.
    fillerColor: 'rgba(167,183,204,0.4)',
    // Color of selected area.
    // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.
    // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',
    handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',
    // Percent of the slider height
    handleSize: '100%',
    handleStyle: {
      color: '#a7b7cc'
    },
    labelPrecision: null,
    labelFormatter: null,
    showDetail: true,
    showDataShadow: 'auto',
    // Default auto decision.
    realtime: true,
    zoomLock: false,
    // Whether disable zoom.
    textStyle: {
      color: '#333'
    }
  }
});
var _default = SliderZoomModel;
module.exports = _default;

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var eventTool = __webpack_require__(106);

var graphic = __webpack_require__(93);

var throttle = __webpack_require__(114);

var DataZoomView = __webpack_require__(117);

var numberUtil = __webpack_require__(94);

var layout = __webpack_require__(103);

var sliderMove = __webpack_require__(137);

var Rect = graphic.Rect;
var linearMap = numberUtil.linearMap;
var asc = numberUtil.asc;
var bind = zrUtil.bind;
var each = zrUtil.each; // Constants

var DEFAULT_LOCATION_EDGE_GAP = 7;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var HORIZONTAL = 'horizontal';
var VERTICAL = 'vertical';
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];
var SliderZoomView = DataZoomView.extend({
  type: 'dataZoom.slider',
  init: function (ecModel, api) {
    /**
     * @private
     * @type {Object}
     */
    this._displayables = {};
    /**
     * @private
     * @type {string}
     */

    this._orient;
    /**
     * [0, 100]
     * @private
     */

    this._range;
    /**
     * [coord of the first handle, coord of the second handle]
     * @private
     */

    this._handleEnds;
    /**
     * [length, thick]
     * @private
     * @type {Array.<number>}
     */

    this._size;
    /**
     * @private
     * @type {number}
     */

    this._handleWidth;
    /**
     * @private
     * @type {number}
     */

    this._handleHeight;
    /**
     * @private
     */

    this._location;
    /**
     * @private
     */

    this._dragging;
    /**
     * @private
     */

    this._dataShadowInfo;
    this.api = api;
  },

  /**
   * @override
   */
  render: function (dataZoomModel, ecModel, api, payload) {
    SliderZoomView.superApply(this, 'render', arguments);
    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');
    this._orient = dataZoomModel.get('orient');

    if (this.dataZoomModel.get('show') === false) {
      this.group.removeAll();
      return;
    } // Notice: this._resetInterval() should not be executed when payload.type
    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'
    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,


    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {
      this._buildView();
    }

    this._updateView();
  },

  /**
   * @override
   */
  remove: function () {
    SliderZoomView.superApply(this, 'remove', arguments);
    throttle.clear(this, '_dispatchZoomAction');
  },

  /**
   * @override
   */
  dispose: function () {
    SliderZoomView.superApply(this, 'dispose', arguments);
    throttle.clear(this, '_dispatchZoomAction');
  },
  _buildView: function () {
    var thisGroup = this.group;
    thisGroup.removeAll();

    this._resetLocation();

    this._resetInterval();

    var barGroup = this._displayables.barGroup = new graphic.Group();

    this._renderBackground();

    this._renderHandle();

    this._renderDataShadow();

    thisGroup.add(barGroup);

    this._positionGroup();
  },

  /**
   * @private
   */
  _resetLocation: function () {
    var dataZoomModel = this.dataZoomModel;
    var api = this.api; // If some of x/y/width/height are not specified,
    // auto-adapt according to target grid.

    var coordRect = this._findCoordRect();

    var ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    }; // Default align by coordinate system rect.

    var positionInfo = this._orient === HORIZONTAL ? {
      // Why using 'right', because right should be used in vertical,
      // and it is better to be consistent for dealing with position param merge.
      right: ecSize.width - coordRect.x - coordRect.width,
      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,
      width: coordRect.width,
      height: DEFAULT_FILLER_SIZE
    } : {
      // vertical
      right: DEFAULT_LOCATION_EDGE_GAP,
      top: coordRect.y,
      width: DEFAULT_FILLER_SIZE,
      height: coordRect.height
    }; // Do not write back to option and replace value 'ph', because
    // the 'ph' value should be recalculated when resize.

    var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.

    zrUtil.each(['right', 'top', 'width', 'height'], function (name) {
      if (layoutParams[name] === 'ph') {
        layoutParams[name] = positionInfo[name];
      }
    });
    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);
    this._location = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    this._size = [layoutRect.width, layoutRect.height];
    this._orient === VERTICAL && this._size.reverse();
  },

  /**
   * @private
   */
  _positionGroup: function () {
    var thisGroup = this.group;
    var location = this._location;
    var orient = this._orient; // Just use the first axis to determine mapping.

    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
    var inverse = targetAxisModel && targetAxisModel.get('inverse');
    var barGroup = this._displayables.barGroup;
    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.

    barGroup.attr(orient === HORIZONTAL && !inverse ? {
      scale: otherAxisInverse ? [1, 1] : [1, -1]
    } : orient === HORIZONTAL && inverse ? {
      scale: otherAxisInverse ? [-1, 1] : [-1, -1]
    } : orient === VERTICAL && !inverse ? {
      scale: otherAxisInverse ? [1, -1] : [1, 1],
      rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.

    } : {
      scale: otherAxisInverse ? [-1, -1] : [-1, 1],
      rotation: Math.PI / 2
    }); // Position barGroup

    var rect = thisGroup.getBoundingRect([barGroup]);
    thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);
  },

  /**
   * @private
   */
  _getViewExtent: function () {
    return [0, this._size[0]];
  },
  _renderBackground: function () {
    var dataZoomModel = this.dataZoomModel;
    var size = this._size;
    var barGroup = this._displayables.barGroup;
    barGroup.add(new Rect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: dataZoomModel.get('backgroundColor')
      },
      z2: -40
    })); // Click panel, over shadow, below handles.

    barGroup.add(new Rect({
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: 'transparent'
      },
      z2: 0,
      onclick: zrUtil.bind(this._onClickPanelClick, this)
    }));
  },
  _renderDataShadow: function () {
    var info = this._dataShadowInfo = this._prepareDataShadowInfo();

    if (!info) {
      return;
    }

    var size = this._size;
    var seriesModel = info.series;
    var data = seriesModel.getRawData();
    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick
    : info.otherDim;

    if (otherDim == null) {
      return;
    }

    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.

    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];
    var otherShadowExtent = [0, size[1]];
    var thisShadowExtent = [0, size[0]];
    var areaPoints = [[size[0], 0], [0, 0]];
    var linePoints = [];
    var step = thisShadowExtent[1] / (data.count() - 1);
    var thisCoord = 0; // Optimize for large data shadow

    var stride = Math.round(data.count() / size[0]);
    var lastIsEmpty;
    data.each([otherDim], function (value, index) {
      if (stride > 0 && index % stride) {
        thisCoord += step;
        return;
      } // FIXME
      // Should consider axis.min/axis.max when drawing dataShadow.
      // FIXME
      // 应该使用统一的空判断？还是在list里进行空判断？


      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.

      var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.

      if (isEmpty && !lastIsEmpty && index) {
        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
        linePoints.push([linePoints[linePoints.length - 1][0], 0]);
      } else if (!isEmpty && lastIsEmpty) {
        areaPoints.push([thisCoord, 0]);
        linePoints.push([thisCoord, 0]);
      }

      areaPoints.push([thisCoord, otherCoord]);
      linePoints.push([thisCoord, otherCoord]);
      thisCoord += step;
      lastIsEmpty = isEmpty;
    });
    var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');

    this._displayables.barGroup.add(new graphic.Polygon({
      shape: {
        points: areaPoints
      },
      style: zrUtil.defaults({
        fill: dataZoomModel.get('dataBackgroundColor')
      }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),
      silent: true,
      z2: -20
    }));

    this._displayables.barGroup.add(new graphic.Polyline({
      shape: {
        points: linePoints
      },
      style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),
      silent: true,
      z2: -19
    }));
  },
  _prepareDataShadowInfo: function () {
    var dataZoomModel = this.dataZoomModel;
    var showDataShadow = dataZoomModel.get('showDataShadow');

    if (showDataShadow === false) {
      return;
    } // Find a representative series.


    var result;
    var ecModel = this.ecModel;
    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
      var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();
      zrUtil.each(seriesModels, function (seriesModel) {
        if (result) {
          return;
        }

        if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {
          return;
        }

        var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;
        var otherDim = getOtherDim(dimNames.name);
        var otherAxisInverse;
        var coordSys = seriesModel.coordinateSystem;

        if (otherDim != null && coordSys.getOtherAxis) {
          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
        }

        result = {
          thisAxis: thisAxis,
          series: seriesModel,
          thisDim: dimNames.name,
          otherDim: otherDim,
          otherAxisInverse: otherAxisInverse
        };
      }, this);
    }, this);
    return result;
  },
  _renderHandle: function () {
    var displaybles = this._displayables;
    var handles = displaybles.handles = [];
    var handleLabels = displaybles.handleLabels = [];
    var barGroup = this._displayables.barGroup;
    var size = this._size;
    var dataZoomModel = this.dataZoomModel;
    barGroup.add(displaybles.filler = new Rect({
      draggable: true,
      cursor: getCursor(this._orient),
      drift: bind(this._onDragMove, this, 'all'),
      onmousemove: function (e) {
        // Fot mobile devicem, prevent screen slider on the button.
        eventTool.stop(e.event);
      },
      ondragstart: bind(this._showDataInfo, this, true),
      ondragend: bind(this._onDragEnd, this),
      onmouseover: bind(this._showDataInfo, this, true),
      onmouseout: bind(this._showDataInfo, this, false),
      style: {
        fill: dataZoomModel.get('fillerColor'),
        textPosition: 'inside'
      }
    })); // Frame border.

    barGroup.add(new Rect(graphic.subPixelOptimizeRect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),
        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
        fill: 'rgba(0,0,0,0)'
      }
    })));
    each([0, 1], function (handleIndex) {
      var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {
        cursor: getCursor(this._orient),
        draggable: true,
        drift: bind(this._onDragMove, this, handleIndex),
        onmousemove: function (e) {
          // Fot mobile devicem, prevent screen slider on the button.
          eventTool.stop(e.event);
        },
        ondragend: bind(this._onDragEnd, this),
        onmouseover: bind(this._showDataInfo, this, true),
        onmouseout: bind(this._showDataInfo, this, false)
      }, {
        x: -1,
        y: 0,
        width: 2,
        height: 2
      });
      var bRect = path.getBoundingRect();
      this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);
      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());
      var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version

      if (handleColor != null) {
        path.style.fill = handleColor;
      }

      barGroup.add(handles[handleIndex] = path);
      var textStyleModel = dataZoomModel.textStyleModel;
      this.group.add(handleLabels[handleIndex] = new graphic.Text({
        silent: true,
        invisible: true,
        style: {
          x: 0,
          y: 0,
          text: '',
          textVerticalAlign: 'middle',
          textAlign: 'center',
          textFill: textStyleModel.getTextColor(),
          textFont: textStyleModel.getFont()
        },
        z2: 10
      }));
    }, this);
  },

  /**
   * @private
   */
  _resetInterval: function () {
    var range = this._range = this.dataZoomModel.getPercentRange();

    var viewExtent = this._getViewExtent();

    this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];
  },

  /**
   * @private
   * @param {(number|string)} handleIndex 0 or 1 or 'all'
   * @param {number} delta
   */
  _updateInterval: function (handleIndex, delta) {
    var dataZoomModel = this.dataZoomModel;
    var handleEnds = this._handleEnds;

    var viewExtend = this._getViewExtent();

    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    var percentExtent = [0, 100];
    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
  },

  /**
   * @private
   */
  _updateView: function (nonRealtime) {
    var displaybles = this._displayables;
    var handleEnds = this._handleEnds;
    var handleInterval = asc(handleEnds.slice());
    var size = this._size;
    each([0, 1], function (handleIndex) {
      // Handles
      var handle = displaybles.handles[handleIndex];
      var handleHeight = this._handleHeight;
      handle.attr({
        scale: [handleHeight / 2, handleHeight / 2],
        position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]
      });
    }, this); // Filler

    displaybles.filler.setShape({
      x: handleInterval[0],
      y: 0,
      width: handleInterval[1] - handleInterval[0],
      height: size[1]
    });

    this._updateDataInfo(nonRealtime);
  },

  /**
   * @private
   */
  _updateDataInfo: function (nonRealtime) {
    var dataZoomModel = this.dataZoomModel;
    var displaybles = this._displayables;
    var handleLabels = displaybles.handleLabels;
    var orient = this._orient;
    var labelTexts = ['', '']; // FIXME
    // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）

    if (dataZoomModel.get('showDetail')) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();

      if (axisProxy) {
        var axis = axisProxy.getAxisModel().axis;
        var range = this._range;
        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.
        ? axisProxy.calculateDataWindow({
          start: range[0],
          end: range[1]
        }).valueWindow : axisProxy.getDataValueWindow();
        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
      }
    }

    var orderedHandleEnds = asc(this._handleEnds.slice());
    setLabel.call(this, 0);
    setLabel.call(this, 1);

    function setLabel(handleIndex) {
      // Label
      // Text should not transform by barGroup.
      // Ignore handlers transform
      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);
      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);
      var offset = this._handleWidth / 2 + LABEL_GAP;
      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,
        textAlign: orient === HORIZONTAL ? direction : 'center',
        text: labelTexts[handleIndex]
      });
    }
  },

  /**
   * @private
   */
  _formatLabel: function (value, axis) {
    var dataZoomModel = this.dataZoomModel;
    var labelFormatter = dataZoomModel.get('labelFormatter');
    var labelPrecision = dataZoomModel.get('labelPrecision');

    if (labelPrecision == null || labelPrecision === 'auto') {
      labelPrecision = axis.getPixelPrecision();
    }

    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code
    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.
    : value.toFixed(Math.min(labelPrecision, 20));
    return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;
  },

  /**
   * @private
   * @param {boolean} showOrHide true: show, false: hide
   */
  _showDataInfo: function (showOrHide) {
    // Always show when drgging.
    showOrHide = this._dragging || showOrHide;
    var handleLabels = this._displayables.handleLabels;
    handleLabels[0].attr('invisible', !showOrHide);
    handleLabels[1].attr('invisible', !showOrHide);
  },
  _onDragMove: function (handleIndex, dx, dy) {
    this._dragging = true; // Transform dx, dy to bar coordination.

    var barTransform = this._displayables.barGroup.getLocalTransform();

    var vertex = graphic.applyTransform([dx, dy], barTransform, true);

    this._updateInterval(handleIndex, vertex[0]);

    var realtime = this.dataZoomModel.get('realtime');

    this._updateView(!realtime);

    if (realtime) {
      realtime && this._dispatchZoomAction();
    }
  },
  _onDragEnd: function () {
    this._dragging = false;

    this._showDataInfo(false);

    this._dispatchZoomAction();
  },
  _onClickPanelClick: function (e) {
    var size = this._size;

    var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);

    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
      return;
    }

    var handleEnds = this._handleEnds;
    var center = (handleEnds[0] + handleEnds[1]) / 2;

    this._updateInterval('all', localPoint[0] - center);

    this._updateView();

    this._dispatchZoomAction();
  },

  /**
   * This action will be throttled.
   * @private
   */
  _dispatchZoomAction: function () {
    var range = this._range;
    this.api.dispatchAction({
      type: 'dataZoom',
      from: this.uid,
      dataZoomId: this.dataZoomModel.id,
      start: range[0],
      end: range[1]
    });
  },

  /**
   * @private
   */
  _findCoordRect: function () {
    // Find the grid coresponding to the first axis referred by dataZoom.
    var rect;
    each(this.getTargetCoordInfo(), function (coordInfoList) {
      if (!rect && coordInfoList.length) {
        var coordSys = coordInfoList[0].model.coordinateSystem;
        rect = coordSys.getRect && coordSys.getRect();
      }
    });

    if (!rect) {
      var width = this.api.getWidth();
      var height = this.api.getHeight();
      rect = {
        x: width * 0.2,
        y: height * 0.2,
        width: width * 0.6,
        height: height * 0.6
      };
    }

    return rect;
  }
});

function getOtherDim(thisDim) {
  // FIXME
  // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好
  var map = {
    x: 'y',
    y: 'x',
    radius: 'angle',
    angle: 'radius'
  };
  return map[thisDim];
}

function getCursor(orient) {
  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';
}

var _default = SliderZoomView;
module.exports = _default;

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

var DataZoomModel = __webpack_require__(116);

var _default = DataZoomModel.extend({
  type: 'dataZoom.inside',

  /**
   * @protected
   */
  defaultOption: {
    disabled: false,
    // Whether disable this inside zoom.
    zoomLock: false,
    // Whether disable zoom but only pan.
    zoomOnMouseWheel: true,
    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
    moveOnMouseMove: true,
    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
    preventDefaultMouseMove: true
  }
});

module.exports = _default;

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var DataZoomView = __webpack_require__(117);

var sliderMove = __webpack_require__(137);

var roams = __webpack_require__(288);

var bind = zrUtil.bind;
var InsideZoomView = DataZoomView.extend({
  type: 'dataZoom.inside',

  /**
   * @override
   */
  init: function (ecModel, api) {
    /**
     * 'throttle' is used in this.dispatchAction, so we save range
     * to avoid missing some 'pan' info.
     * @private
     * @type {Array.<number>}
     */
    this._range;
  },

  /**
   * @override
   */
  render: function (dataZoomModel, ecModel, api, payload) {
    InsideZoomView.superApply(this, 'render', arguments); // Notice: origin this._range should be maintained, and should not be re-fetched
    // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'
    // info will be missed because of 'throttle' of this.dispatchAction.

    if (roams.shouldRecordRange(payload, dataZoomModel.id)) {
      this._range = dataZoomModel.getPercentRange();
    } // Reset controllers.


    zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {
      var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {
        return roams.generateCoordId(coordInfo.model);
      });
      zrUtil.each(coordInfoList, function (coordInfo) {
        var coordModel = coordInfo.model;
        var dataZoomOption = dataZoomModel.option;
        roams.register(api, {
          coordId: roams.generateCoordId(coordModel),
          allCoordIds: allCoordIds,
          containsPoint: function (e, x, y) {
            return coordModel.coordinateSystem.containPoint([x, y]);
          },
          dataZoomId: dataZoomModel.id,
          throttleRate: dataZoomModel.get('throttle', true),
          panGetRange: bind(this._onPan, this, coordInfo, coordSysName),
          zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName),
          zoomLock: dataZoomOption.zoomLock,
          disabled: dataZoomOption.disabled,
          roamControllerOpt: {
            zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel,
            moveOnMouseMove: dataZoomOption.moveOnMouseMove,
            preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove
          }
        });
      }, this);
    }, this);
  },

  /**
   * @override
   */
  dispose: function () {
    roams.unregister(this.api, this.dataZoomModel.id);
    InsideZoomView.superApply(this, 'dispose', arguments);
    this._range = null;
  },

  /**
   * @private
   */
  _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {
    var range = this._range.slice(); // Calculate transform by the first axis.


    var axisModel = coordInfo.axisModels[0];

    if (!axisModel) {
      return;
    }

    var directionInfo = getDirectionInfo[coordSysName]([oldX, oldY], [newX, newY], axisModel, controller, coordInfo);
    var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
    sliderMove(percentDelta, range, [0, 100], 'all');
    return this._range = range;
  },

  /**
   * @private
   */
  _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {
    var range = this._range.slice(); // Calculate transform by the first axis.


    var axisModel = coordInfo.axisModels[0];

    if (!axisModel) {
      return;
    }

    var directionInfo = getDirectionInfo[coordSysName](null, [mouseX, mouseY], axisModel, controller, coordInfo);
    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
    scale = Math.max(1 / scale, 0);
    range[0] = (range[0] - percentPoint) * scale + percentPoint;
    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.

    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
    return this._range = range;
  }
});
var getDirectionInfo = {
  grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var rect = coordInfo.model.coordinateSystem.getRect();
    oldPoint = oldPoint || [0, 0];

    if (axis.dim === 'x') {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // axis.dim === 'y'
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  },
  polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var polar = coordInfo.model.coordinateSystem;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var angleExtent = polar.getAngleAxis().getExtent();
    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
    newPoint = polar.pointToCoord(newPoint);

    if (axisModel.mainType === 'radiusAxis') {
      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);
      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);

      ret.pixelLength = radiusExtent[1] - radiusExtent[0];
      ret.pixelStart = radiusExtent[0];
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // 'angleAxis'
      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);
      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);

      ret.pixelLength = angleExtent[1] - angleExtent[0];
      ret.pixelStart = angleExtent[0];
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  },
  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {
    var axis = axisModel.axis;
    var rect = coordInfo.model.coordinateSystem.getRect();
    var ret = {};
    oldPoint = oldPoint || [0, 0];

    if (axis.orient === 'horizontal') {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // 'vertical'
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  }
};
var _default = InsideZoomView;
module.exports = _default;

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var RoamController = __webpack_require__(289);

var throttleUtil = __webpack_require__(114);

// Only create one roam controller for each coordinate system.
// one roam controller might be refered by two inside data zoom
// components (for example, one for x and one for y). When user
// pan or zoom, only dispatch one action for those data zoom
// components.
var curry = zrUtil.curry;
var ATTR = '\0_ec_dataZoom_roams';
/**
 * @public
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} dataZoomInfo
 * @param {string} dataZoomInfo.coordId
 * @param {Function} dataZoomInfo.containsPoint
 * @param {Array.<string>} dataZoomInfo.allCoordIds
 * @param {string} dataZoomInfo.dataZoomId
 * @param {number} dataZoomInfo.throttleRate
 * @param {Function} dataZoomInfo.panGetRange
 * @param {Function} dataZoomInfo.zoomGetRange
 * @param {boolean} [dataZoomInfo.zoomLock]
 * @param {boolean} [dataZoomInfo.disabled]
 */

function register(api, dataZoomInfo) {
  var store = giveStore(api);
  var theDataZoomId = dataZoomInfo.dataZoomId;
  var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.
  // Avoid memory leak, dispose all not-used-registered.

  zrUtil.each(store, function (record, coordId) {
    var dataZoomInfos = record.dataZoomInfos;

    if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {
      delete dataZoomInfos[theDataZoomId];
      record.count--;
    }
  });
  cleanStore(store);
  var record = store[theCoordId]; // Create if needed.

  if (!record) {
    record = store[theCoordId] = {
      coordId: theCoordId,
      dataZoomInfos: {},
      count: 0
    };
    record.controller = createController(api, record);
    record.dispatchAction = zrUtil.curry(dispatchAction, api);
  } // Update reference of dataZoom.


  !record.dataZoomInfos[theDataZoomId] && record.count++;
  record.dataZoomInfos[theDataZoomId] = dataZoomInfo;
  var controllerParams = mergeControllerParams(record.dataZoomInfos);
  record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.

  record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.

  throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');
}
/**
 * @public
 * @param {module:echarts/ExtensionAPI} api
 * @param {string} dataZoomId
 */


function unregister(api, dataZoomId) {
  var store = giveStore(api);
  zrUtil.each(store, function (record) {
    record.controller.dispose();
    var dataZoomInfos = record.dataZoomInfos;

    if (dataZoomInfos[dataZoomId]) {
      delete dataZoomInfos[dataZoomId];
      record.count--;
    }
  });
  cleanStore(store);
}
/**
 * @public
 */


function shouldRecordRange(payload, dataZoomId) {
  if (payload && payload.type === 'dataZoom' && payload.batch) {
    for (var i = 0, len = payload.batch.length; i < len; i++) {
      if (payload.batch[i].dataZoomId === dataZoomId) {
        return false;
      }
    }
  }

  return true;
}
/**
 * @public
 */


function generateCoordId(coordModel) {
  return coordModel.type + '\0_' + coordModel.id;
}
/**
 * Key: coordId, value: {dataZoomInfos: [], count, controller}
 * @type {Array.<Object>}
 */


function giveStore(api) {
  // Mount store on zrender instance, so that we do not
  // need to worry about dispose.
  var zr = api.getZr();
  return zr[ATTR] || (zr[ATTR] = {});
}

function createController(api, newRecord) {
  var controller = new RoamController(api.getZr());
  controller.on('pan', curry(onPan, newRecord));
  controller.on('zoom', curry(onZoom, newRecord));
  return controller;
}

function cleanStore(store) {
  zrUtil.each(store, function (record, coordId) {
    if (!record.count) {
      record.controller.dispose();
      delete store[coordId];
    }
  });
}

function onPan(record, dx, dy, oldX, oldY, newX, newY) {
  wrapAndDispatch(record, function (info) {
    return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);
  });
}

function onZoom(record, scale, mouseX, mouseY) {
  wrapAndDispatch(record, function (info) {
    return info.zoomGetRange(record.controller, scale, mouseX, mouseY);
  });
}

function wrapAndDispatch(record, getRange) {
  var batch = [];
  zrUtil.each(record.dataZoomInfos, function (info) {
    var range = getRange(info);
    !info.disabled && range && batch.push({
      dataZoomId: info.dataZoomId,
      start: range[0],
      end: range[1]
    });
  });
  record.dispatchAction(batch);
}
/**
 * This action will be throttled.
 */


function dispatchAction(api, batch) {
  api.dispatchAction({
    type: 'dataZoom',
    batch: batch
  });
}
/**
 * Merge roamController settings when multiple dataZooms share one roamController.
 */


function mergeControllerParams(dataZoomInfos) {
  var controlType;
  var opt = {};
  var typePriority = {
    'true': 2,
    'move': 1,
    'false': 0,
    'undefined': -1
  };
  zrUtil.each(dataZoomInfos, function (dataZoomInfo) {
    var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true;
    typePriority[oneType] > typePriority[controlType] && (controlType = oneType); // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.

    zrUtil.extend(opt, dataZoomInfo.roamControllerOpt);
  });
  return {
    controlType: controlType,
    opt: opt
  };
}

exports.register = register;
exports.unregister = unregister;
exports.shouldRecordRange = shouldRecordRange;
exports.generateCoordId = generateCoordId;

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var Eventful = __webpack_require__(107);

var eventTool = __webpack_require__(106);

var interactionMutex = __webpack_require__(178);

/**
 * @alias module:echarts/component/helper/RoamController
 * @constructor
 * @mixin {module:zrender/mixin/Eventful}
 *
 * @param {module:zrender/zrender~ZRender} zr
 */
function RoamController(zr) {
  /**
   * @type {Function}
   */
  this.pointerChecker;
  /**
   * @type {module:zrender}
   */

  this._zr = zr;
  /**
   * @type {Object}
   */

  this._opt = {}; // Avoid two roamController bind the same handler

  var bind = zrUtil.bind;
  var mousedownHandler = bind(mousedown, this);
  var mousemoveHandler = bind(mousemove, this);
  var mouseupHandler = bind(mouseup, this);
  var mousewheelHandler = bind(mousewheel, this);
  var pinchHandler = bind(pinch, this);
  Eventful.call(this);
  /**
   * @param {Function} pointerChecker
   *                   input: x, y
   *                   output: boolean
   */

  this.setPointerChecker = function (pointerChecker) {
    this.pointerChecker = pointerChecker;
  };
  /**
   * Notice: only enable needed types. For example, if 'zoom'
   * is not needed, 'zoom' should not be enabled, otherwise
   * default mousewheel behaviour (scroll page) will be disabled.
   *
   * @param  {boolean|string} [controlType=true] Specify the control type,
   *                          which can be null/undefined or true/false
   *                          or 'pan/move' or 'zoom'/'scale'
   * @param {Object} [opt]
   * @param {Object} [opt.zoomOnMouseWheel=true]
   * @param {Object} [opt.moveOnMouseMove=true]
   * @param {Object} [opt.preventDefaultMouseMove=true] When pan.
   */


  this.enable = function (controlType, opt) {
    // Disable previous first
    this.disable();
    this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      preventDefaultMouseMove: true
    });

    if (controlType == null) {
      controlType = true;
    }

    if (controlType === true || controlType === 'move' || controlType === 'pan') {
      zr.on('mousedown', mousedownHandler);
      zr.on('mousemove', mousemoveHandler);
      zr.on('mouseup', mouseupHandler);
    }

    if (controlType === true || controlType === 'scale' || controlType === 'zoom') {
      zr.on('mousewheel', mousewheelHandler);
      zr.on('pinch', pinchHandler);
    }
  };

  this.disable = function () {
    zr.off('mousedown', mousedownHandler);
    zr.off('mousemove', mousemoveHandler);
    zr.off('mouseup', mouseupHandler);
    zr.off('mousewheel', mousewheelHandler);
    zr.off('pinch', pinchHandler);
  };

  this.dispose = this.disable;

  this.isDragging = function () {
    return this._dragging;
  };

  this.isPinching = function () {
    return this._pinching;
  };
}

zrUtil.mixin(RoamController, Eventful);

function mousedown(e) {
  if (eventTool.notLeftMouse(e) || e.target && e.target.draggable) {
    return;
  }

  var x = e.offsetX;
  var y = e.offsetY; // Only check on mosedown, but not mousemove.
  // Mouse can be out of target when mouse moving.

  if (this.pointerChecker && this.pointerChecker(e, x, y)) {
    this._x = x;
    this._y = y;
    this._dragging = true;
  }
}

function mousemove(e) {
  if (eventTool.notLeftMouse(e) || !checkKeyBinding(this, 'moveOnMouseMove', e) || !this._dragging || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {
    return;
  }

  var x = e.offsetX;
  var y = e.offsetY;
  var oldX = this._x;
  var oldY = this._y;
  var dx = x - oldX;
  var dy = y - oldY;
  this._x = x;
  this._y = y;
  this._opt.preventDefaultMouseMove && eventTool.stop(e.event);
  this.trigger('pan', dx, dy, oldX, oldY, x, y);
}

function mouseup(e) {
  if (!eventTool.notLeftMouse(e)) {
    this._dragging = false;
  }
}

function mousewheel(e) {
  // wheelDelta maybe -0 in chrome mac.
  if (!checkKeyBinding(this, 'zoomOnMouseWheel', e) || e.wheelDelta === 0) {
    return;
  } // Convenience:
  // Mac and VM Windows on Mac: scroll up: zoom out.
  // Windows: scroll up: zoom in.


  var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;
  zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);
}

function pinch(e) {
  if (interactionMutex.isTaken(this._zr, 'globalPan')) {
    return;
  }

  var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
  zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);
}

function zoom(e, zoomDelta, zoomX, zoomY) {
  if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) {
    // When mouse is out of roamController rect,
    // default befavoius should not be be disabled, otherwise
    // page sliding is disabled, contrary to expectation.
    eventTool.stop(e.event);
    this.trigger('zoom', zoomDelta, zoomX, zoomY);
  }
}

function checkKeyBinding(roamController, prop, e) {
  var setting = roamController._opt[prop];
  return setting && (!zrUtil.isString(setting) || e.event[setting + 'Key']);
}

var _default = RoamController;
module.exports = _default;

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

__webpack_require__(291);

__webpack_require__(292);

// HINT Markpoint can't be used too much
echarts.registerPreprocessor(function (opt) {
  // Make sure markPoint component is enabled
  opt.markPoint = opt.markPoint || {};
});

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var MarkerModel = __webpack_require__(181);

var _default = MarkerModel.extend({
  type: 'markPoint',
  defaultOption: {
    zlevel: 0,
    z: 5,
    symbol: 'pin',
    symbolSize: 50,
    //symbolRotate: 0,
    //symbolOffset: [0, 0]
    tooltip: {
      trigger: 'item'
    },
    label: {
      normal: {
        show: true,
        position: 'inside'
      },
      emphasis: {
        show: true
      }
    },
    itemStyle: {
      normal: {
        borderWidth: 2
      }
    }
  }
});

module.exports = _default;

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var SymbolDraw = __webpack_require__(169);

var numberUtil = __webpack_require__(94);

var List = __webpack_require__(123);

var markerHelper = __webpack_require__(182);

var MarkerView = __webpack_require__(183);

function updateMarkerLayout(mpData, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  mpData.each(function (idx) {
    var itemModel = mpData.getItemModel(idx);
    var point;
    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());

    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } // Chart like bar may have there own marker positioning logic
    else if (seriesModel.getMarkerPosition) {
        // Use the getMarkerPoisition
        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
      } else if (coordSys) {
        var x = mpData.get(coordSys.dimensions[0], idx);
        var y = mpData.get(coordSys.dimensions[1], idx);
        point = coordSys.dataToPoint([x, y]);
      } // Use x, y if has any


    if (!isNaN(xPx)) {
      point[0] = xPx;
    }

    if (!isNaN(yPx)) {
      point[1] = yPx;
    }

    mpData.setItemLayout(idx, point);
  });
}

var _default = MarkerView.extend({
  type: 'markPoint',
  updateLayout: function (markPointModel, ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      var mpModel = seriesModel.markPointModel;

      if (mpModel) {
        updateMarkerLayout(mpModel.getData(), seriesModel, api);
        this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
      }
    }, this);
  },
  renderSeries: function (seriesModel, mpModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var symbolDrawMap = this.markerGroupMap;
    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());
    var mpData = createList(coordSys, seriesModel, mpModel); // FIXME

    mpModel.setData(mpData);
    updateMarkerLayout(mpModel.getData(), seriesModel, api);
    mpData.each(function (idx) {
      var itemModel = mpData.getItemModel(idx);
      var symbolSize = itemModel.getShallow('symbolSize');

      if (typeof symbolSize === 'function') {
        // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？
        symbolSize = symbolSize(mpModel.getRawValue(idx), mpModel.getDataParams(idx));
      }

      mpData.setItemVisual(idx, {
        symbolSize: symbolSize,
        color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color'),
        symbol: itemModel.getShallow('symbol')
      });
    }); // TODO Text are wrong

    symbolDraw.updateData(mpData);
    this.group.add(symbolDraw.group); // Set host model for tooltip
    // FIXME

    mpData.eachItemGraphicEl(function (el) {
      el.traverse(function (child) {
        child.dataModel = mpModel;
      });
    });
    symbolDraw.__keep = true;
    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');
  }
});
/**
 * @inner
 * @param {module:echarts/coord/*} [coordSys]
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */


function createList(coordSys, seriesModel, mpModel) {
  var coordDimsInfos;

  if (coordSys) {
    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

      info.name = coordDim;
      return info;
    });
  } else {
    coordDimsInfos = [{
      name: 'value',
      type: 'float'
    }];
  }

  var mpData = new List(coordDimsInfos, mpModel);
  var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));

  if (coordSys) {
    dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));
  }

  mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {
    return item.value;
  });
  return mpData;
}

module.exports = _default;

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

__webpack_require__(294);

__webpack_require__(295);

echarts.registerPreprocessor(function (opt) {
  // Make sure markLine component is enabled
  opt.markLine = opt.markLine || {};
});

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var MarkerModel = __webpack_require__(181);

var _default = MarkerModel.extend({
  type: 'markLine',
  defaultOption: {
    zlevel: 0,
    z: 5,
    symbol: ['circle', 'arrow'],
    symbolSize: [8, 16],
    //symbolRotate: 0,
    precision: 2,
    tooltip: {
      trigger: 'item'
    },
    label: {
      normal: {
        show: true,
        position: 'end'
      },
      emphasis: {
        show: true
      }
    },
    lineStyle: {
      normal: {
        type: 'dashed'
      },
      emphasis: {
        width: 3
      }
    },
    animationEasing: 'linear'
  }
});

module.exports = _default;

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var List = __webpack_require__(123);

var numberUtil = __webpack_require__(94);

var markerHelper = __webpack_require__(182);

var LineDraw = __webpack_require__(296);

var MarkerView = __webpack_require__(183);

var markLineTransform = function (seriesModel, coordSys, mlModel, item) {
  var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average'

  var mlType = item.type;

  if (!zrUtil.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' // In case
  // data: [{
  //   yAxis: 10
  // }]
  || item.xAxis != null || item.yAxis != null)) {
    var valueAxis;
    var valueDataDim;
    var value;

    if (item.yAxis != null || item.xAxis != null) {
      valueDataDim = item.yAxis != null ? 'y' : 'x';
      valueAxis = coordSys.getAxis(valueDataDim);
      value = zrUtil.retrieve(item.yAxis, item.xAxis);
    } else {
      var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
      valueDataDim = axisInfo.valueDataDim;
      valueAxis = axisInfo.valueAxis;
      value = markerHelper.numCalculate(data, valueDataDim, mlType);
    }

    var valueIndex = valueDataDim === 'x' ? 0 : 1;
    var baseIndex = 1 - valueIndex;
    var mlFrom = zrUtil.clone(item);
    var mlTo = {};
    mlFrom.type = null;
    mlFrom.coord = [];
    mlTo.coord = [];
    mlFrom.coord[baseIndex] = -Infinity;
    mlTo.coord[baseIndex] = Infinity;
    var precision = mlModel.get('precision');

    if (precision >= 0 && typeof value === 'number') {
      value = +value.toFixed(Math.min(precision, 20));
    }

    mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
    item = [mlFrom, mlTo, {
      // Extra option for tooltip and label
      type: mlType,
      valueIndex: item.valueIndex,
      // Force to use the value of calculated value.
      value: value
    }];
  }

  item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])]; // Avoid line data type is extended by from(to) data type

  item[2].type = item[2].type || ''; // Merge from option and to option into line option

  zrUtil.merge(item[2], item[0]);
  zrUtil.merge(item[2], item[1]);
  return item;
};

function isInifinity(val) {
  return !isNaN(val) && !isFinite(val);
} // If a markLine has one dim


function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  var otherDimIndex = 1 - dimIndex;
  var dimName = coordSys.dimensions[dimIndex];
  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
}

function markLineFilter(coordSys, item) {
  if (coordSys.type === 'cartesian2d') {
    var fromCoord = item[0].coord;
    var toCoord = item[1].coord; // In case
    // {
    //  markLine: {
    //    data: [{ yAxis: 2 }]
    //  }
    // }

    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
  }

  return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
}

function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  var itemModel = data.getItemModel(idx);
  var point;
  var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
  var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());

  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    // Chart like bar may have there own marker positioning logic
    if (seriesModel.getMarkerPosition) {
      // Use the getMarkerPoisition
      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
    } else {
      var dims = coordSys.dimensions;
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);
      point = coordSys.dataToPoint([x, y]);
    } // Expand line to the edge of grid if value on one axis is Inifnity
    // In case
    //  markLine: {
    //    data: [{
    //      yAxis: 2
    //      // or
    //      type: 'average'
    //    }]
    //  }


    if (coordSys.type === 'cartesian2d') {
      var xAxis = coordSys.getAxis('x');
      var yAxis = coordSys.getAxis('y');
      var dims = coordSys.dimensions;

      if (isInifinity(data.get(dims[0], idx))) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
      } else if (isInifinity(data.get(dims[1], idx))) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
      }
    } // Use x, y if has any


    if (!isNaN(xPx)) {
      point[0] = xPx;
    }

    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }

  data.setItemLayout(idx, point);
}

var _default = MarkerView.extend({
  type: 'markLine',
  updateLayout: function (markLineModel, ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      var mlModel = seriesModel.markLineModel;

      if (mlModel) {
        var mlData = mlModel.getData();
        var fromData = mlModel.__from;
        var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol

        fromData.each(function (idx) {
          updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
          updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
        }); // Update layout of line

        mlData.each(function (idx) {
          mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
        });
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  },
  renderSeries: function (seriesModel, mlModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var lineDrawMap = this.markerGroupMap;
    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());
    this.group.add(lineDraw.group);
    var mlData = createList(coordSys, seriesModel, mlModel);
    var fromData = mlData.from;
    var toData = mlData.to;
    var lineData = mlData.line;
    mlModel.__from = fromData;
    mlModel.__to = toData; // Line data for tooltip and formatter

    mlModel.setData(lineData);
    var symbolType = mlModel.get('symbol');
    var symbolSize = mlModel.get('symbolSize');

    if (!zrUtil.isArray(symbolType)) {
      symbolType = [symbolType, symbolType];
    }

    if (typeof symbolSize === 'number') {
      symbolSize = [symbolSize, symbolSize];
    } // Update visual and layout of from symbol and to symbol


    mlData.from.each(function (idx) {
      updateDataVisualAndLayout(fromData, idx, true);
      updateDataVisualAndLayout(toData, idx, false);
    }); // Update visual and layout of line

    lineData.each(function (idx) {
      var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');
      lineData.setItemVisual(idx, {
        color: lineColor || fromData.getItemVisual(idx, 'color')
      });
      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
      lineData.setItemVisual(idx, {
        'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),
        'fromSymbol': fromData.getItemVisual(idx, 'symbol'),
        'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),
        'toSymbol': toData.getItemVisual(idx, 'symbol')
      });
    });
    lineDraw.updateData(lineData); // Set host model for tooltip
    // FIXME

    mlData.line.eachItemGraphicEl(function (el, idx) {
      el.traverse(function (child) {
        child.dataModel = mlModel;
      });
    });

    function updateDataVisualAndLayout(data, idx, isFrom) {
      var itemModel = data.getItemModel(idx);
      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
      data.setItemVisual(idx, {
        symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],
        symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],
        color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')
      });
    }

    lineDraw.__keep = true;
    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');
  }
});
/**
 * @inner
 * @param {module:echarts/coord/*} coordSys
 * @param {module:echarts/model/Series} seriesModel
 * @param {module:echarts/model/Model} mpModel
 */


function createList(coordSys, seriesModel, mlModel) {
  var coordDimsInfos;

  if (coordSys) {
    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

      info.name = coordDim;
      return info;
    });
  } else {
    coordDimsInfos = [{
      name: 'value',
      type: 'float'
    }];
  }

  var fromData = new List(coordDimsInfos, mlModel);
  var toData = new List(coordDimsInfos, mlModel); // No dimensions

  var lineData = new List([], mlModel);
  var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));

  if (coordSys) {
    optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));
  }

  var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {
    return item.value;
  };
  fromData.initData(zrUtil.map(optData, function (item) {
    return item[0];
  }), null, dimValueGetter);
  toData.initData(zrUtil.map(optData, function (item) {
    return item[1];
  }), null, dimValueGetter);
  lineData.initData(zrUtil.map(optData, function (item) {
    return item[2];
  }));
  lineData.hasItemOption = true;
  return {
    from: fromData,
    to: toData,
    line: lineData
  };
}

module.exports = _default;

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__(93);

var LineGroup = __webpack_require__(297);

/**
 * @module echarts/chart/helper/LineDraw
 */
function isPointNaN(pt) {
  return isNaN(pt[0]) || isNaN(pt[1]);
}

function lineNeedsDraw(pts) {
  return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
}
/**
 * @alias module:echarts/component/marker/LineDraw
 * @constructor
 */


function LineDraw(ctor) {
  this._ctor = ctor || LineGroup;
  this.group = new graphic.Group();
}

var lineDrawProto = LineDraw.prototype;
/**
 * @param {module:echarts/data/List} lineData
 */

lineDrawProto.updateData = function (lineData) {
  var oldLineData = this._lineData;
  var group = this.group;
  var LineCtor = this._ctor;
  var hostModel = lineData.hostModel;
  var seriesScope = {
    lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),
    hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),
    labelModel: hostModel.getModel('label.normal'),
    hoverLabelModel: hostModel.getModel('label.emphasis')
  };
  lineData.diff(oldLineData).add(function (idx) {
    if (!lineNeedsDraw(lineData.getItemLayout(idx))) {
      return;
    }

    var lineGroup = new LineCtor(lineData, idx, seriesScope);
    lineData.setItemGraphicEl(idx, lineGroup);
    group.add(lineGroup);
  }).update(function (newIdx, oldIdx) {
    var lineGroup = oldLineData.getItemGraphicEl(oldIdx);

    if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {
      group.remove(lineGroup);
      return;
    }

    if (!lineGroup) {
      lineGroup = new LineCtor(lineData, newIdx, seriesScope);
    } else {
      lineGroup.updateData(lineData, newIdx, seriesScope);
    }

    lineData.setItemGraphicEl(newIdx, lineGroup);
    group.add(lineGroup);
  }).remove(function (idx) {
    group.remove(oldLineData.getItemGraphicEl(idx));
  }).execute();
  this._lineData = lineData;
};

lineDrawProto.updateLayout = function () {
  var lineData = this._lineData;
  lineData.eachItemGraphicEl(function (el, idx) {
    el.updateLayout(lineData, idx);
  }, this);
};

lineDrawProto.remove = function () {
  this.group.removeAll();
};

var _default = LineDraw;
module.exports = _default;

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var zrUtil = __webpack_require__(91);

var vector = __webpack_require__(97);

var symbolUtil = __webpack_require__(115);

var LinePath = __webpack_require__(298);

var graphic = __webpack_require__(93);

var _number = __webpack_require__(94);

var round = _number.round;

/**
 * @module echarts/chart/helper/Line
 */
var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];

function makeSymbolTypeKey(symbolCategory) {
  return '_' + symbolCategory + 'Type';
}
/**
 * @inner
 */


function createSymbol(name, lineData, idx) {
  var color = lineData.getItemVisual(idx, 'color');
  var symbolType = lineData.getItemVisual(idx, name);
  var symbolSize = lineData.getItemVisual(idx, name + 'Size');

  if (!symbolType || symbolType === 'none') {
    return;
  }

  if (!zrUtil.isArray(symbolSize)) {
    symbolSize = [symbolSize, symbolSize];
  }

  var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);
  symbolPath.name = name;
  return symbolPath;
}

function createLine(points) {
  var line = new LinePath({
    name: 'line'
  });
  setLinePoints(line.shape, points);
  return line;
}

function setLinePoints(targetShape, points) {
  var p1 = points[0];
  var p2 = points[1];
  var cp1 = points[2];
  targetShape.x1 = p1[0];
  targetShape.y1 = p1[1];
  targetShape.x2 = p2[0];
  targetShape.y2 = p2[1];
  targetShape.percent = 1;

  if (cp1) {
    targetShape.cpx1 = cp1[0];
    targetShape.cpy1 = cp1[1];
  } else {
    targetShape.cpx1 = NaN;
    targetShape.cpy1 = NaN;
  }
}

function updateSymbolAndLabelBeforeLineUpdate() {
  var lineGroup = this;
  var symbolFrom = lineGroup.childOfName('fromSymbol');
  var symbolTo = lineGroup.childOfName('toSymbol');
  var label = lineGroup.childOfName('label'); // Quick reject

  if (!symbolFrom && !symbolTo && label.ignore) {
    return;
  }

  var invScale = 1;
  var parentNode = this.parent;

  while (parentNode) {
    if (parentNode.scale) {
      invScale /= parentNode.scale[0];
    }

    parentNode = parentNode.parent;
  }

  var line = lineGroup.childOfName('line'); // If line not changed
  // FIXME Parent scale changed

  if (!this.__dirty && !line.__dirty) {
    return;
  }

  var percent = line.shape.percent;
  var fromPos = line.pointAt(0);
  var toPos = line.pointAt(percent);
  var d = vector.sub([], toPos, fromPos);
  vector.normalize(d, d);

  if (symbolFrom) {
    symbolFrom.attr('position', fromPos);
    var tangent = line.tangentAt(0);
    symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
    symbolFrom.attr('scale', [invScale * percent, invScale * percent]);
  }

  if (symbolTo) {
    symbolTo.attr('position', toPos);
    var tangent = line.tangentAt(1);
    symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
    symbolTo.attr('scale', [invScale * percent, invScale * percent]);
  }

  if (!label.ignore) {
    label.attr('position', toPos);
    var textPosition;
    var textAlign;
    var textVerticalAlign;
    var distance = 5 * invScale; // End

    if (label.__position === 'end') {
      textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];
      textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';
      textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';
    } // Middle
    else if (label.__position === 'middle') {
        var halfPercent = percent / 2;
        var tangent = line.tangentAt(halfPercent);
        var n = [tangent[1], -tangent[0]];
        var cp = line.pointAt(halfPercent);

        if (n[1] > 0) {
          n[0] = -n[0];
          n[1] = -n[1];
        }

        textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];
        textAlign = 'center';
        textVerticalAlign = 'bottom';
        var rotation = -Math.atan2(tangent[1], tangent[0]);

        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }

        label.attr('rotation', rotation);
      } // Start
      else {
          textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];
          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';
          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';
        }

    label.attr({
      style: {
        // Use the user specified text align and baseline first
        textVerticalAlign: label.__verticalAlign || textVerticalAlign,
        textAlign: label.__textAlign || textAlign
      },
      position: textPosition,
      scale: [invScale, invScale]
    });
  }
}
/**
 * @constructor
 * @extends {module:zrender/graphic/Group}
 * @alias {module:echarts/chart/helper/Line}
 */


function Line(lineData, idx, seriesScope) {
  graphic.Group.call(this);

  this._createLine(lineData, idx, seriesScope);
}

var lineProto = Line.prototype; // Update symbol position and rotation

lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;

lineProto._createLine = function (lineData, idx, seriesScope) {
  var seriesModel = lineData.hostModel;
  var linePoints = lineData.getItemLayout(idx);
  var line = createLine(linePoints);
  line.shape.percent = 0;
  graphic.initProps(line, {
    shape: {
      percent: 1
    }
  }, seriesModel, idx);
  this.add(line);
  var label = new graphic.Text({
    name: 'label'
  });
  this.add(label);
  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
    var symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure
    // it will be updated after line#update.
    // Or symbol position and rotation update in line#beforeUpdate will be one frame slow

    this.add(symbol);
    this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
  }, this);

  this._updateCommonStl(lineData, idx, seriesScope);
};

lineProto.updateData = function (lineData, idx, seriesScope) {
  var seriesModel = lineData.hostModel;
  var line = this.childOfName('line');
  var linePoints = lineData.getItemLayout(idx);
  var target = {
    shape: {}
  };
  setLinePoints(target.shape, linePoints);
  graphic.updateProps(line, target, seriesModel, idx);
  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
    var symbolType = lineData.getItemVisual(idx, symbolCategory);
    var key = makeSymbolTypeKey(symbolCategory); // Symbol changed

    if (this[key] !== symbolType) {
      this.remove(this.childOfName(symbolCategory));
      var symbol = createSymbol(symbolCategory, lineData, idx);
      this.add(symbol);
    }

    this[key] = symbolType;
  }, this);

  this._updateCommonStl(lineData, idx, seriesScope);
};

lineProto._updateCommonStl = function (lineData, idx, seriesScope) {
  var seriesModel = lineData.hostModel;
  var line = this.childOfName('line');
  var lineStyle = seriesScope && seriesScope.lineStyle;
  var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
  var labelModel = seriesScope && seriesScope.labelModel;
  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset

  if (!seriesScope || lineData.hasItemOption) {
    var itemModel = lineData.getItemModel(idx);
    lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();
    hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();
    labelModel = itemModel.getModel('label.normal');
    hoverLabelModel = itemModel.getModel('label.emphasis');
  }

  var visualColor = lineData.getItemVisual(idx, 'color');
  var visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1);
  line.useStyle(zrUtil.defaults({
    strokeNoScale: true,
    fill: 'none',
    stroke: visualColor,
    opacity: visualOpacity
  }, lineStyle));
  line.hoverStyle = hoverLineStyle; // Update symbol

  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
    var symbol = this.childOfName(symbolCategory);

    if (symbol) {
      symbol.setColor(visualColor);
      symbol.setStyle({
        opacity: visualOpacity
      });
    }
  }, this);
  var showLabel = labelModel.getShallow('show');
  var hoverShowLabel = hoverLabelModel.getShallow('show');
  var label = this.childOfName('label');
  var defaultLabelColor;
  var defaultText;
  var normalText;
  var emphasisText;

  if (showLabel || hoverShowLabel) {
    var rawVal = seriesModel.getRawValue(idx);
    defaultText = rawVal == null ? defaultText = lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;
    defaultLabelColor = visualColor || '#000';
    normalText = zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType), defaultText);
    emphasisText = zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), normalText);
  } // label.afterUpdate = lineAfterUpdate;


  if (showLabel) {
    var labelStyle = graphic.setTextStyle(label.style, labelModel, {
      text: normalText
    }, {
      autoColor: defaultLabelColor
    });
    label.__textAlign = labelStyle.textAlign;
    label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end'

    label.__position = labelModel.get('position') || 'middle';
  } else {
    label.setStyle('text', null);
  }

  if (hoverShowLabel) {
    // Only these properties supported in this emphasis style here.
    label.hoverStyle = {
      text: emphasisText,
      textFill: hoverLabelModel.getTextColor(true),
      // For merging hover style to normal style, do not use
      // `hoverLabelModel.getFont()` here.
      fontStyle: hoverLabelModel.getShallow('fontStyle'),
      fontWeight: hoverLabelModel.getShallow('fontWeight'),
      fontSize: hoverLabelModel.getShallow('fontSize'),
      fontFamily: hoverLabelModel.getShallow('fontFamily')
    };
  } else {
    label.hoverStyle = {
      text: null
    };
  }

  label.ignore = !showLabel && !hoverShowLabel;
  graphic.setHoverStyle(this);
};

lineProto.highlight = function () {
  this.trigger('emphasis');
};

lineProto.downplay = function () {
  this.trigger('normal');
};

lineProto.updateLayout = function (lineData, idx) {
  this.setLinePoints(lineData.getItemLayout(idx));
};

lineProto.setLinePoints = function (points) {
  var linePath = this.childOfName('line');
  setLinePoints(linePath.shape, points);
  linePath.dirty();
};

zrUtil.inherits(Line, graphic.Group);
var _default = Line;
module.exports = _default;

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

var graphic = __webpack_require__(93);

var vec2 = __webpack_require__(97);

/**
 * Line path for bezier and straight line draw
 */
var straightLineProto = graphic.Line.prototype;
var bezierCurveProto = graphic.BezierCurve.prototype;

function isLine(shape) {
  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
}

var _default = graphic.extendShape({
  type: 'ec-line',
  style: {
    stroke: '#000',
    fill: null
  },
  shape: {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    percent: 1,
    cpx1: null,
    cpy1: null
  },
  buildPath: function (ctx, shape) {
    (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);
  },
  pointAt: function (t) {
    return isLine(this.shape) ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t);
  },
  tangentAt: function (t) {
    var shape = this.shape;
    var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
    return vec2.normalize(p, p);
  }
});

module.exports = _default;

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(300);

__webpack_require__(301);

__webpack_require__(302);

__webpack_require__(303);

__webpack_require__(304);

__webpack_require__(305);

__webpack_require__(313);

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var featureManager = __webpack_require__(109);

var ToolboxModel = echarts.extendComponentModel({
  type: 'toolbox',
  layoutMode: {
    type: 'box',
    ignoreSize: true
  },
  mergeDefaultAndTheme: function (option) {
    ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);
    zrUtil.each(this.option.feature, function (featureOpt, featureName) {
      var Feature = featureManager.get(featureName);
      Feature && zrUtil.merge(featureOpt, Feature.defaultOption);
    });
  },
  defaultOption: {
    show: true,
    z: 6,
    zlevel: 0,
    orient: 'horizontal',
    left: 'right',
    top: 'top',
    // right
    // bottom
    backgroundColor: 'transparent',
    borderColor: '#ccc',
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemSize: 15,
    itemGap: 8,
    showTitle: true,
    iconStyle: {
      normal: {
        borderColor: '#666',
        color: 'none'
      },
      emphasis: {
        borderColor: '#3E98C5'
      } // textStyle: {},
      // feature

    }
  }
});
var _default = ToolboxModel;
module.exports = _default;

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var textContain = __webpack_require__(108);

var featureManager = __webpack_require__(109);

var graphic = __webpack_require__(93);

var Model = __webpack_require__(102);

var DataDiffer = __webpack_require__(134);

var listComponentHelper = __webpack_require__(176);

var _default = echarts.extendComponentView({
  type: 'toolbox',
  render: function (toolboxModel, ecModel, api, payload) {
    var group = this.group;
    group.removeAll();

    if (!toolboxModel.get('show')) {
      return;
    }

    var itemSize = +toolboxModel.get('itemSize');
    var featureOpts = toolboxModel.get('feature') || {};
    var features = this._features || (this._features = {});
    var featureNames = [];
    zrUtil.each(featureOpts, function (opt, name) {
      featureNames.push(name);
    });
    new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute(); // Keep for diff.

    this._featureNames = featureNames;

    function processFeature(newIndex, oldIndex) {
      var featureName = featureNames[newIndex];
      var oldName = featureNames[oldIndex];
      var featureOpt = featureOpts[featureName];
      var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);
      var feature;

      if (featureName && !oldName) {
        // Create
        if (isUserFeatureName(featureName)) {
          feature = {
            model: featureModel,
            onclick: featureModel.option.onclick,
            featureName: featureName
          };
        } else {
          var Feature = featureManager.get(featureName);

          if (!Feature) {
            return;
          }

          feature = new Feature(featureModel, ecModel, api);
        }

        features[featureName] = feature;
      } else {
        feature = features[oldName]; // If feature does not exsit.

        if (!feature) {
          return;
        }

        feature.model = featureModel;
        feature.ecModel = ecModel;
        feature.api = api;
      }

      if (!featureName && oldName) {
        feature.dispose && feature.dispose(ecModel, api);
        return;
      }

      if (!featureModel.get('show') || feature.unusable) {
        feature.remove && feature.remove(ecModel, api);
        return;
      }

      createIconPaths(featureModel, feature, featureName);

      featureModel.setIconStatus = function (iconName, status) {
        var option = this.option;
        var iconPaths = this.iconPaths;
        option.iconStatus = option.iconStatus || {};
        option.iconStatus[iconName] = status; // FIXME

        iconPaths[iconName] && iconPaths[iconName].trigger(status);
      };

      if (feature.render) {
        feature.render(featureModel, ecModel, api, payload);
      }
    }

    function createIconPaths(featureModel, feature, featureName) {
      var iconStyleModel = featureModel.getModel('iconStyle'); // If one feature has mutiple icon. they are orginaized as
      // {
      //     icon: {
      //         foo: '',
      //         bar: ''
      //     },
      //     title: {
      //         foo: '',
      //         bar: ''
      //     }
      // }

      var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');
      var titles = featureModel.get('title') || {};

      if (typeof icons === 'string') {
        var icon = icons;
        var title = titles;
        icons = {};
        titles = {};
        icons[featureName] = icon;
        titles[featureName] = title;
      }

      var iconPaths = featureModel.iconPaths = {};
      zrUtil.each(icons, function (iconStr, iconName) {
        var path = graphic.createIcon(iconStr, {}, {
          x: -itemSize / 2,
          y: -itemSize / 2,
          width: itemSize,
          height: itemSize
        });
        path.setStyle(iconStyleModel.getModel('normal').getItemStyle());
        path.hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();
        graphic.setHoverStyle(path);

        if (toolboxModel.get('showTitle')) {
          path.__title = titles[iconName];
          path.on('mouseover', function () {
            // Should not reuse above hoverStyle, which might be modified.
            var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();
            path.setStyle({
              text: titles[iconName],
              textPosition: hoverStyle.textPosition || 'bottom',
              textFill: hoverStyle.fill || hoverStyle.stroke || '#000',
              textAlign: hoverStyle.textAlign || 'center'
            });
          }).on('mouseout', function () {
            path.setStyle({
              textFill: null
            });
          });
        }

        path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');
        group.add(path);
        path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));
        iconPaths[iconName] = path;
      });
    }

    listComponentHelper.layout(group, toolboxModel, api); // Render background after group is layout
    // FIXME

    group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen

    group.eachChild(function (icon) {
      var titleText = icon.__title;
      var hoverStyle = icon.hoverStyle; // May be background element

      if (hoverStyle && titleText) {
        var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));
        var offsetX = icon.position[0] + group.position[0];
        var offsetY = icon.position[1] + group.position[1] + itemSize;
        var needPutOnTop = false;

        if (offsetY + rect.height > api.getHeight()) {
          hoverStyle.textPosition = 'top';
          needPutOnTop = true;
        }

        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;

        if (offsetX + rect.width / 2 > api.getWidth()) {
          hoverStyle.textPosition = ['100%', topOffset];
          hoverStyle.textAlign = 'right';
        } else if (offsetX - rect.width / 2 < 0) {
          hoverStyle.textPosition = [0, topOffset];
          hoverStyle.textAlign = 'left';
        }
      }
    });
  },
  updateView: function (toolboxModel, ecModel, api, payload) {
    zrUtil.each(this._features, function (feature) {
      feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
    });
  },
  updateLayout: function (toolboxModel, ecModel, api, payload) {
    zrUtil.each(this._features, function (feature) {
      feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
    });
  },
  remove: function (ecModel, api) {
    zrUtil.each(this._features, function (feature) {
      feature.remove && feature.remove(ecModel, api);
    });
    this.group.removeAll();
  },
  dispose: function (ecModel, api) {
    zrUtil.each(this._features, function (feature) {
      feature.dispose && feature.dispose(ecModel, api);
    });
  }
});

function isUserFeatureName(featureName) {
  return featureName.indexOf('my') === 0;
}

module.exports = _default;

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

var env = __webpack_require__(98);

var lang = __webpack_require__(118);

var featureManager = __webpack_require__(109);

var saveAsImageLang = lang.toolbox.saveAsImage;

function SaveAsImage(model) {
  this.model = model;
}

SaveAsImage.defaultOption = {
  show: true,
  icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
  title: saveAsImageLang.title,
  type: 'png',
  // Default use option.backgroundColor
  // backgroundColor: '#fff',
  name: '',
  excludeComponents: ['toolbox'],
  pixelRatio: 1,
  lang: saveAsImageLang.lang.slice()
};
SaveAsImage.prototype.unusable = !env.canvasSupported;
var proto = SaveAsImage.prototype;

proto.onclick = function (ecModel, api) {
  var model = this.model;
  var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';
  var $a = document.createElement('a');
  var type = model.get('type', true) || 'png';
  $a.download = title + '.' + type;
  $a.target = '_blank';
  var url = api.getConnectedDataURL({
    type: type,
    backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',
    excludeComponents: model.get('excludeComponents'),
    pixelRatio: model.get('pixelRatio')
  });
  $a.href = url; // Chrome and Firefox

  if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {
    var evt = new MouseEvent('click', {
      view: window,
      bubbles: true,
      cancelable: false
    });
    $a.dispatchEvent(evt);
  } // IE
  else {
      if (window.navigator.msSaveOrOpenBlob) {
        var bstr = atob(url.split(',')[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);

        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }

        var blob = new Blob([u8arr]);
        window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);
      } else {
        var lang = model.get('lang');
        var html = '' + '<body style="margin:0;">' + '<img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || '') + '" />' + '</body>';
        var tab = window.open();
        tab.document.write(html);
      }
    }
};

featureManager.register('saveAsImage', SaveAsImage);
var _default = SaveAsImage;
module.exports = _default;

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var lang = __webpack_require__(118);

var featureManager = __webpack_require__(109);

var magicTypeLang = lang.toolbox.magicType;

function MagicType(model) {
  this.model = model;
}

MagicType.defaultOption = {
  show: true,
  type: [],
  // Icon group
  icon: {
    line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
    bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
    stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',
    // jshint ignore:line
    tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'
  },
  // `line`, `bar`, `stack`, `tiled`
  title: zrUtil.clone(magicTypeLang.title),
  option: {},
  seriesIndex: {}
};
var proto = MagicType.prototype;

proto.getIcons = function () {
  var model = this.model;
  var availableIcons = model.get('icon');
  var icons = {};
  zrUtil.each(model.get('type'), function (type) {
    if (availableIcons[type]) {
      icons[type] = availableIcons[type];
    }
  });
  return icons;
};

var seriesOptGenreator = {
  'line': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'bar') {
      return zrUtil.merge({
        id: seriesId,
        type: 'line',
        // Preserve data related option
        data: seriesModel.get('data'),
        stack: seriesModel.get('stack'),
        markPoint: seriesModel.get('markPoint'),
        markLine: seriesModel.get('markLine')
      }, model.get('option.line') || {}, true);
    }
  },
  'bar': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'line') {
      return zrUtil.merge({
        id: seriesId,
        type: 'bar',
        // Preserve data related option
        data: seriesModel.get('data'),
        stack: seriesModel.get('stack'),
        markPoint: seriesModel.get('markPoint'),
        markLine: seriesModel.get('markLine')
      }, model.get('option.bar') || {}, true);
    }
  },
  'stack': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'line' || seriesType === 'bar') {
      return zrUtil.merge({
        id: seriesId,
        stack: '__ec_magicType_stack__'
      }, model.get('option.stack') || {}, true);
    }
  },
  'tiled': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'line' || seriesType === 'bar') {
      return zrUtil.merge({
        id: seriesId,
        stack: ''
      }, model.get('option.tiled') || {}, true);
    }
  }
};
var radioTypes = [['line', 'bar'], ['stack', 'tiled']];

proto.onclick = function (ecModel, api, type) {
  var model = this.model;
  var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType

  if (!seriesOptGenreator[type]) {
    return;
  }

  var newOption = {
    series: []
  };

  var generateNewSeriesTypes = function (seriesModel) {
    var seriesType = seriesModel.subType;
    var seriesId = seriesModel.id;
    var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);

    if (newSeriesOpt) {
      // PENDING If merge original option?
      zrUtil.defaults(newSeriesOpt, seriesModel.option);
      newOption.series.push(newSeriesOpt);
    } // Modify boundaryGap


    var coordSys = seriesModel.coordinateSystem;

    if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {
      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

      if (categoryAxis) {
        var axisDim = categoryAxis.dim;
        var axisType = axisDim + 'Axis';
        var axisModel = ecModel.queryComponents({
          mainType: axisType,
          index: seriesModel.get(name + 'Index'),
          id: seriesModel.get(name + 'Id')
        })[0];
        var axisIndex = axisModel.componentIndex;
        newOption[axisType] = newOption[axisType] || [];

        for (var i = 0; i <= axisIndex; i++) {
          newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
        }

        newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;
      }
    }
  };

  zrUtil.each(radioTypes, function (radio) {
    if (zrUtil.indexOf(radio, type) >= 0) {
      zrUtil.each(radio, function (item) {
        model.setIconStatus(item, 'normal');
      });
    }
  });
  model.setIconStatus(type, 'emphasis');
  ecModel.eachComponent({
    mainType: 'series',
    query: seriesIndex == null ? null : {
      seriesIndex: seriesIndex
    }
  }, generateNewSeriesTypes);
  api.dispatchAction({
    type: 'changeMagicType',
    currentType: type,
    newOption: newOption
  });
};

echarts.registerAction({
  type: 'changeMagicType',
  event: 'magicTypeChanged',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  ecModel.mergeOption(payload.newOption);
});
featureManager.register('magicType', MagicType);
var _default = MagicType;
module.exports = _default;

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var eventTool = __webpack_require__(106);

var lang = __webpack_require__(118);

var featureManager = __webpack_require__(109);

var dataViewLang = lang.toolbox.dataView;
var BLOCK_SPLITER = new Array(60).join('-');
var ITEM_SPLITER = '\t';
/**
 * Group series into two types
 *  1. on category axis, like line, bar
 *  2. others, like scatter, pie
 * @param {module:echarts/model/Global} ecModel
 * @return {Object}
 * @inner
 */

function groupSeries(ecModel) {
  var seriesGroupByCategoryAxis = {};
  var otherSeries = [];
  var meta = [];
  ecModel.eachRawSeries(function (seriesModel) {
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {
      var baseAxis = coordSys.getBaseAxis();

      if (baseAxis.type === 'category') {
        var key = baseAxis.dim + '_' + baseAxis.index;

        if (!seriesGroupByCategoryAxis[key]) {
          seriesGroupByCategoryAxis[key] = {
            categoryAxis: baseAxis,
            valueAxis: coordSys.getOtherAxis(baseAxis),
            series: []
          };
          meta.push({
            axisDim: baseAxis.dim,
            axisIndex: baseAxis.index
          });
        }

        seriesGroupByCategoryAxis[key].series.push(seriesModel);
      } else {
        otherSeries.push(seriesModel);
      }
    } else {
      otherSeries.push(seriesModel);
    }
  });
  return {
    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,
    other: otherSeries,
    meta: meta
  };
}
/**
 * Assemble content of series on cateogory axis
 * @param {Array.<module:echarts/model/Series>} series
 * @return {string}
 * @inner
 */


function assembleSeriesWithCategoryAxis(series) {
  var tables = [];
  zrUtil.each(series, function (group, key) {
    var categoryAxis = group.categoryAxis;
    var valueAxis = group.valueAxis;
    var valueAxisDim = valueAxis.dim;
    var headers = [' '].concat(zrUtil.map(group.series, function (series) {
      return series.name;
    }));
    var columns = [categoryAxis.model.getCategories()];
    zrUtil.each(group.series, function (series) {
      columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {
        return val;
      }));
    }); // Assemble table content

    var lines = [headers.join(ITEM_SPLITER)];

    for (var i = 0; i < columns[0].length; i++) {
      var items = [];

      for (var j = 0; j < columns.length; j++) {
        items.push(columns[j][i]);
      }

      lines.push(items.join(ITEM_SPLITER));
    }

    tables.push(lines.join('\n'));
  });
  return tables.join('\n\n' + BLOCK_SPLITER + '\n\n');
}
/**
 * Assemble content of other series
 * @param {Array.<module:echarts/model/Series>} series
 * @return {string}
 * @inner
 */


function assembleOtherSeries(series) {
  return zrUtil.map(series, function (series) {
    var data = series.getRawData();
    var lines = [series.name];
    var vals = [];
    data.each(data.dimensions, function () {
      var argLen = arguments.length;
      var dataIndex = arguments[argLen - 1];
      var name = data.getName(dataIndex);

      for (var i = 0; i < argLen - 1; i++) {
        vals[i] = arguments[i];
      }

      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));
    });
    return lines.join('\n');
  }).join('\n\n' + BLOCK_SPLITER + '\n\n');
}
/**
 * @param {module:echarts/model/Global}
 * @return {Object}
 * @inner
 */


function getContentFromModel(ecModel) {
  var result = groupSeries(ecModel);
  return {
    value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {
      return str.replace(/[\n\t\s]/g, '');
    }).join('\n\n' + BLOCK_SPLITER + '\n\n'),
    meta: result.meta
  };
}

function trim(str) {
  return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}
/**
 * If a block is tsv format
 */


function isTSVFormat(block) {
  // Simple method to find out if a block is tsv format
  var firstLine = block.slice(0, block.indexOf('\n'));

  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
    return true;
  }
}

var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');
/**
 * @param {string} tsv
 * @return {Object}
 */

function parseTSVContents(tsv) {
  var tsvLines = tsv.split(/\n+/g);
  var headers = trim(tsvLines.shift()).split(itemSplitRegex);
  var categories = [];
  var series = zrUtil.map(headers, function (header) {
    return {
      name: header,
      data: []
    };
  });

  for (var i = 0; i < tsvLines.length; i++) {
    var items = trim(tsvLines[i]).split(itemSplitRegex);
    categories.push(items.shift());

    for (var j = 0; j < items.length; j++) {
      series[j] && (series[j].data[i] = items[j]);
    }
  }

  return {
    series: series,
    categories: categories
  };
}
/**
 * @param {string} str
 * @return {Array.<Object>}
 * @inner
 */


function parseListContents(str) {
  var lines = str.split(/\n+/g);
  var seriesName = trim(lines.shift());
  var data = [];

  for (var i = 0; i < lines.length; i++) {
    var items = trim(lines[i]).split(itemSplitRegex);
    var name = '';
    var value;
    var hasName = false;

    if (isNaN(items[0])) {
      // First item is name
      hasName = true;
      name = items[0];
      items = items.slice(1);
      data[i] = {
        name: name,
        value: []
      };
      value = data[i].value;
    } else {
      value = data[i] = [];
    }

    for (var j = 0; j < items.length; j++) {
      value.push(+items[j]);
    }

    if (value.length === 1) {
      hasName ? data[i].value = value[0] : data[i] = value[0];
    }
  }

  return {
    name: seriesName,
    data: data
  };
}
/**
 * @param {string} str
 * @param {Array.<Object>} blockMetaList
 * @return {Object}
 * @inner
 */


function parseContents(str, blockMetaList) {
  var blocks = str.split(new RegExp('\n*' + BLOCK_SPLITER + '\n*', 'g'));
  var newOption = {
    series: []
  };
  zrUtil.each(blocks, function (block, idx) {
    if (isTSVFormat(block)) {
      var result = parseTSVContents(block);
      var blockMeta = blockMetaList[idx];
      var axisKey = blockMeta.axisDim + 'Axis';

      if (blockMeta) {
        newOption[axisKey] = newOption[axisKey] || [];
        newOption[axisKey][blockMeta.axisIndex] = {
          data: result.categories
        };
        newOption.series = newOption.series.concat(result.series);
      }
    } else {
      var result = parseListContents(block);
      newOption.series.push(result);
    }
  });
  return newOption;
}
/**
 * @alias {module:echarts/component/toolbox/feature/DataView}
 * @constructor
 * @param {module:echarts/model/Model} model
 */


function DataView(model) {
  this._dom = null;
  this.model = model;
}

DataView.defaultOption = {
  show: true,
  readOnly: false,
  optionToContent: null,
  contentToOption: null,
  icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
  title: zrUtil.clone(dataViewLang.title),
  lang: zrUtil.clone(dataViewLang.lang),
  backgroundColor: '#fff',
  textColor: '#000',
  textareaColor: '#fff',
  textareaBorderColor: '#333',
  buttonColor: '#c23531',
  buttonTextColor: '#fff'
};

DataView.prototype.onclick = function (ecModel, api) {
  var container = api.getDom();
  var model = this.model;

  if (this._dom) {
    container.removeChild(this._dom);
  }

  var root = document.createElement('div');
  root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';
  root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements

  var header = document.createElement('h4');
  var lang = model.get('lang') || [];
  header.innerHTML = lang[0] || model.get('title');
  header.style.cssText = 'margin: 10px 20px;';
  header.style.color = model.get('textColor');
  var viewMain = document.createElement('div');
  var textarea = document.createElement('textarea');
  viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';
  var optionToContent = model.get('optionToContent');
  var contentToOption = model.get('contentToOption');
  var result = getContentFromModel(ecModel);

  if (typeof optionToContent === 'function') {
    var htmlOrDom = optionToContent(api.getOption());

    if (typeof htmlOrDom === 'string') {
      viewMain.innerHTML = htmlOrDom;
    } else if (zrUtil.isDom(htmlOrDom)) {
      viewMain.appendChild(htmlOrDom);
    }
  } else {
    // Use default textarea
    viewMain.appendChild(textarea);
    textarea.readOnly = model.get('readOnly');
    textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';
    textarea.style.color = model.get('textColor');
    textarea.style.borderColor = model.get('textareaBorderColor');
    textarea.style.backgroundColor = model.get('textareaColor');
    textarea.value = result.value;
  }

  var blockMetaList = result.meta;
  var buttonContainer = document.createElement('div');
  buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';
  var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';
  var closeButton = document.createElement('div');
  var refreshButton = document.createElement('div');
  buttonStyle += ';background-color:' + model.get('buttonColor');
  buttonStyle += ';color:' + model.get('buttonTextColor');
  var self = this;

  function close() {
    container.removeChild(root);
    self._dom = null;
  }

  eventTool.addEventListener(closeButton, 'click', close);
  eventTool.addEventListener(refreshButton, 'click', function () {
    var newOption;

    try {
      if (typeof contentToOption === 'function') {
        newOption = contentToOption(viewMain, api.getOption());
      } else {
        newOption = parseContents(textarea.value, blockMetaList);
      }
    } catch (e) {
      close();
      throw new Error('Data view format error ' + e);
    }

    if (newOption) {
      api.dispatchAction({
        type: 'changeDataView',
        newOption: newOption
      });
    }

    close();
  });
  closeButton.innerHTML = lang[1];
  refreshButton.innerHTML = lang[2];
  refreshButton.style.cssText = buttonStyle;
  closeButton.style.cssText = buttonStyle;
  !model.get('readOnly') && buttonContainer.appendChild(refreshButton);
  buttonContainer.appendChild(closeButton); // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea

  eventTool.addEventListener(textarea, 'keydown', function (e) {
    if ((e.keyCode || e.which) === 9) {
      // get caret position/selection
      var val = this.value;
      var start = this.selectionStart;
      var end = this.selectionEnd; // set textarea value to: text before caret + tab + text after caret

      this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end); // put caret at right position again

      this.selectionStart = this.selectionEnd = start + 1; // prevent the focus lose

      eventTool.stop(e);
    }
  });
  root.appendChild(header);
  root.appendChild(viewMain);
  root.appendChild(buttonContainer);
  viewMain.style.height = container.clientHeight - 80 + 'px';
  container.appendChild(root);
  this._dom = root;
};

DataView.prototype.remove = function (ecModel, api) {
  this._dom && api.getDom().removeChild(this._dom);
};

DataView.prototype.dispose = function (ecModel, api) {
  this.remove(ecModel, api);
};
/**
 * @inner
 */


function tryMergeDataOption(newData, originalData) {
  return zrUtil.map(newData, function (newVal, idx) {
    var original = originalData && originalData[idx];

    if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {
      if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {
        newVal = newVal.value;
      } // Original data has option


      return zrUtil.defaults({
        value: newVal
      }, original);
    } else {
      return newVal;
    }
  });
}

featureManager.register('dataView', DataView);
echarts.registerAction({
  type: 'changeDataView',
  event: 'dataViewChanged',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  var newSeriesOptList = [];
  zrUtil.each(payload.newOption.series, function (seriesOpt) {
    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];

    if (!seriesModel) {
      // New created series
      // Geuss the series type
      newSeriesOptList.push(zrUtil.extend({
        // Default is scatter
        type: 'scatter'
      }, seriesOpt));
    } else {
      var originalData = seriesModel.get('data');
      newSeriesOptList.push({
        name: seriesOpt.name,
        data: tryMergeDataOption(seriesOpt.data, originalData)
      });
    }
  });
  ecModel.mergeOption(zrUtil.defaults({
    series: newSeriesOptList
  }, payload.newOption));
});
var _default = DataView;
module.exports = _default;

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var zrUtil = __webpack_require__(91);

var BrushController = __webpack_require__(306);

var BrushTargetManager = __webpack_require__(307);

var history = __webpack_require__(184);

var sliderMove = __webpack_require__(137);

var lang = __webpack_require__(118);

var featureManager = __webpack_require__(109);

__webpack_require__(310);

// Use dataZoomSelect
var dataZoomLang = lang.toolbox.dataZoom;
var each = zrUtil.each; // Spectial component id start with \0ec\0, see echarts/model/Global.js~hasInnerId

var DATA_ZOOM_ID_BASE = '\0_ec_\0toolbox-dataZoom_';

function DataZoom(model, ecModel, api) {
  /**
   * @private
   * @type {module:echarts/component/helper/BrushController}
   */
  (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();
  /**
   * @private
   * @type {boolean}
   */

  this._isZoomActive;
}

DataZoom.defaultOption = {
  show: true,
  // Icon group
  icon: {
    zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
    back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'
  },
  // `zoom`, `back`
  title: zrUtil.clone(dataZoomLang.title)
};
var proto = DataZoom.prototype;

proto.render = function (featureModel, ecModel, api, payload) {
  this.model = featureModel;
  this.ecModel = ecModel;
  this.api = api;
  updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
  updateBackBtnStatus(featureModel, ecModel);
};

proto.onclick = function (ecModel, api, type) {
  handlers[type].call(this);
};

proto.remove = function (ecModel, api) {
  this._brushController.unmount();
};

proto.dispose = function (ecModel, api) {
  this._brushController.dispose();
};
/**
 * @private
 */


var handlers = {
  zoom: function () {
    var nextActive = !this._isZoomActive;
    this.api.dispatchAction({
      type: 'takeGlobalCursor',
      key: 'dataZoomSelect',
      dataZoomSelectActive: nextActive
    });
  },
  back: function () {
    this._dispatchZoomAction(history.pop(this.ecModel));
  }
};
/**
 * @private
 */

proto._onBrush = function (areas, opt) {
  if (!opt.isEnd || !areas.length) {
    return;
  }

  var snapshot = {};
  var ecModel = this.ecModel;

  this._brushController.updateCovers([]); // remove cover


  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {
    include: ['grid']
  });
  brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
    if (coordSys.type !== 'cartesian2d') {
      return;
    }

    var brushType = area.brushType;

    if (brushType === 'rect') {
      setBatch('x', coordSys, coordRange[0]);
      setBatch('y', coordSys, coordRange[1]);
    } else {
      setBatch({
        lineX: 'x',
        lineY: 'y'
      }[brushType], coordSys, coordRange);
    }
  });
  history.push(ecModel, snapshot);

  this._dispatchZoomAction(snapshot);

  function setBatch(dimName, coordSys, minMax) {
    var axis = coordSys.getAxis(dimName);
    var axisModel = axis.model;
    var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.

    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();

    if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
      minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
    }

    dataZoomModel && (snapshot[dataZoomModel.id] = {
      dataZoomId: dataZoomModel.id,
      startValue: minMax[0],
      endValue: minMax[1]
    });
  }

  function findDataZoom(dimName, axisModel, ecModel) {
    var found;
    ecModel.eachComponent({
      mainType: 'dataZoom',
      subType: 'select'
    }, function (dzModel) {
      var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);
      has && (found = dzModel);
    });
    return found;
  }
};
/**
 * @private
 */


proto._dispatchZoomAction = function (snapshot) {
  var batch = []; // Convert from hash map to array.

  each(snapshot, function (batchItem, dataZoomId) {
    batch.push(zrUtil.clone(batchItem));
  });
  batch.length && this.api.dispatchAction({
    type: 'dataZoom',
    from: this.uid,
    batch: batch
  });
};

function retrieveAxisSetting(option) {
  var setting = {}; // Compatible with previous setting: null => all axis, false => no axis.

  zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {
    setting[name] = option[name];
    setting[name] == null && (setting[name] = 'all');
    (setting[name] === false || setting[name] === 'none') && (setting[name] = []);
  });
  return setting;
}

function updateBackBtnStatus(featureModel, ecModel) {
  featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');
}

function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
  var zoomActive = view._isZoomActive;

  if (payload && payload.type === 'takeGlobalCursor') {
    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;
  }

  view._isZoomActive = zoomActive;
  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');
  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {
    include: ['grid']
  });

  view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {
    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';
  })).enableBrush(zoomActive ? {
    brushType: 'auto',
    brushStyle: {
      // FIXME user customized?
      lineWidth: 0,
      fill: 'rgba(0,0,0,0.2)'
    }
  } : false);
}

featureManager.register('dataZoom', DataZoom); // Create special dataZoom option for select

echarts.registerPreprocessor(function (option) {
  if (!option) {
    return;
  }

  var dataZoomOpts = option.dataZoom || (option.dataZoom = []);

  if (!zrUtil.isArray(dataZoomOpts)) {
    option.dataZoom = dataZoomOpts = [dataZoomOpts];
  }

  var toolboxOpt = option.toolbox;

  if (toolboxOpt) {
    // Assume there is only one toolbox
    if (zrUtil.isArray(toolboxOpt)) {
      toolboxOpt = toolboxOpt[0];
    }

    if (toolboxOpt && toolboxOpt.feature) {
      var dataZoomOpt = toolboxOpt.feature.dataZoom;
      addForAxis('xAxis', dataZoomOpt);
      addForAxis('yAxis', dataZoomOpt);
    }
  }

  function addForAxis(axisName, dataZoomOpt) {
    if (!dataZoomOpt) {
      return;
    } // Try not to modify model, because it is not merged yet.


    var axisIndicesName = axisName + 'Index';
    var givenAxisIndices = dataZoomOpt[axisIndicesName];

    if (givenAxisIndices != null && givenAxisIndices != 'all' && !zrUtil.isArray(givenAxisIndices)) {
      givenAxisIndices = givenAxisIndices === false || givenAxisIndices === 'none' ? [] : [givenAxisIndices];
    }

    forEachComponent(axisName, function (axisOpt, axisIndex) {
      if (givenAxisIndices != null && givenAxisIndices != 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {
        return;
      }

      var newOpt = {
        type: 'select',
        $fromToolbox: true,
        // Id for merge mapping.
        id: DATA_ZOOM_ID_BASE + axisName + axisIndex
      }; // FIXME
      // Only support one axis now.

      newOpt[axisIndicesName] = axisIndex;
      dataZoomOpts.push(newOpt);
    });
  }

  function forEachComponent(mainType, cb) {
    var opts = option[mainType];

    if (!zrUtil.isArray(opts)) {
      opts = opts ? [opts] : [];
    }

    each(opts, cb);
  }
});
var _default = DataZoom;
module.exports = _default;

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__(91);

var Eventful = __webpack_require__(107);

var graphic = __webpack_require__(93);

var interactionMutex = __webpack_require__(178);

var DataDiffer = __webpack_require__(134);

var curry = zrUtil.curry;
var each = zrUtil.each;
var map = zrUtil.map;
var mathMin = Math.min;
var mathMax = Math.max;
var mathPow = Math.pow;
var COVER_Z = 10000;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = 'globalPan';
var DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
};
var CURSOR_MAP = {
  w: 'ew',
  e: 'ew',
  n: 'ns',
  s: 'ns',
  ne: 'nesw',
  sw: 'nesw',
  nw: 'nwse',
  se: 'nwse'
};
var DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: 'rgba(0,0,0,0.3)',
    fill: 'rgba(0,0,0,0.1)'
  },
  transformable: true,
  brushMode: 'single',
  removeOnClick: false
};
var baseUID = 0;
/**
 * @alias module:echarts/component/helper/BrushController
 * @constructor
 * @mixin {module:zrender/mixin/Eventful}
 * @event module:echarts/component/helper/BrushController#brush
 *        params:
 *            areas: Array.<Array>, coord relates to container group,
 *                                    If no container specified, to global.
 *            opt {
 *                isEnd: boolean,
 *                removeOnClick: boolean
 *            }
 *
 * @param {module:zrender/zrender~ZRender} zr
 */

function BrushController(zr) {
  Eventful.call(this);
  /**
   * @type {module:zrender/zrender~ZRender}
   * @private
   */

  this._zr = zr;
  /**
   * @type {module:zrender/container/Group}
   * @readOnly
   */

  this.group = new graphic.Group();
  /**
   * Only for drawing (after enabledBrush).
   *     'line', 'rect', 'polygon' or false
   *     If passing false/null/undefined, disable brush.
   *     If passing 'auto', determined by panel.defaultBrushType
   * @private
   * @type {string}
   */

  this._brushType;
  /**
   * Only for drawing (after enabledBrush).
   *
   * @private
   * @type {Object}
   */

  this._brushOption;
  /**
   * @private
   * @type {Object}
   */

  this._panels;
  /**
   * @private
   * @type {Array.<nubmer>}
   */

  this._track = [];
  /**
   * @private
   * @type {boolean}
   */

  this._dragging;
  /**
   * @private
   * @type {Array}
   */

  this._covers = [];
  /**
   * @private
   * @type {moudule:zrender/container/Group}
   */

  this._creatingCover;
  /**
   * `true` means global panel
   * @private
   * @type {module:zrender/container/Group|boolean}
   */

  this._creatingPanel;
  /**
   * @private
   * @type {boolean}
   */

  this._enableGlobalPan;
  /**
   * @private
   * @type {boolean}
   */

  /**
   * @private
   * @type {string}
   */
  this._uid = 'brushController_' + baseUID++;
  /**
   * @private
   * @type {Object}
   */

  this._handlers = {};
  each(mouseHandlers, function (handler, eventName) {
    this._handlers[eventName] = zrUtil.bind(handler, this);
  }, this);
}

BrushController.prototype = {
  constructor: BrushController,

  /**
   * If set to null/undefined/false, select disabled.
   * @param {Object} brushOption
   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false
   *                          If passing false/null/undefined, disable brush.
   *                          If passing 'auto', determined by panel.defaultBrushType.
   *                              ('auto' can not be used in global panel)
   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'
   * @param {boolean} [brushOption.transformable=true]
   * @param {boolean} [brushOption.removeOnClick=false]
   * @param {Object} [brushOption.brushStyle]
   * @param {number} [brushOption.brushStyle.width]
   * @param {number} [brushOption.brushStyle.lineWidth]
   * @param {string} [brushOption.brushStyle.stroke]
   * @param {string} [brushOption.brushStyle.fill]
   * @param {number} [brushOption.z]
   */
  enableBrush: function (brushOption) {
    this._brushType && doDisableBrush(this);
    brushOption.brushType && doEnableBrush(this, brushOption);
    return this;
  },

  /**
   * @param {Array.<Object>} panelOpts If not pass, it is global brush.
   *        Each items: {
   *            panelId, // mandatory.
   *            clipPath, // mandatory. function.
   *            isTargetByCursor, // mandatory. function.
   *            defaultBrushType, // optional, only used when brushType is 'auto'.
   *            getLinearBrushOtherExtent, // optional. function.
   *        }
   */
  setPanels: function (panelOpts) {
    if (panelOpts && panelOpts.length) {
      var panels = this._panels = {};
      zrUtil.each(panelOpts, function (panelOpts) {
        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);
      });
    } else {
      this._panels = null;
    }

    return this;
  },

  /**
   * @param {Object} [opt]
   * @return {boolean} [opt.enableGlobalPan=false]
   */
  mount: function (opt) {
    opt = opt || {};
    this._enableGlobalPan = opt.enableGlobalPan;
    var thisGroup = this.group;

    this._zr.add(thisGroup);

    thisGroup.attr({
      position: opt.position || [0, 0],
      rotation: opt.rotation || 0,
      scale: opt.scale || [1, 1]
    });
    this._transform = thisGroup.getLocalTransform();
    return this;
  },
  eachCover: function (cb, context) {
    each(this._covers, cb, context);
  },

  /**
   * Update covers.
   * @param {Array.<Object>} brushOptionList Like:
   *        [
   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},
   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},
   *            ...
   *        ]
   *        `brushType` is required in each cover info. (can not be 'auto')
   *        `id` is not mandatory.
   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.
   *        If brushOptionList is null/undefined, all covers removed.
   */
  updateCovers: function (brushOptionList) {
    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {
      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
    });
    var tmpIdPrefix = '\0-brush-index-';
    var oldCovers = this._covers;
    var newCovers = this._covers = [];
    var controller = this;
    var creatingCover = this._creatingCover;
    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
    return this;

    function getKey(brushOption, index) {
      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;
    }

    function oldGetKey(cover, index) {
      return getKey(cover.__brushOption, index);
    }

    function addOrUpdate(newIndex, oldIndex) {
      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,
      // where updating cover when creating should be forbiden.

      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
        newCovers[newIndex] = oldCovers[oldIndex];
      } else {
        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));
        updateCoverAfterCreation(controller, cover);
      }
    }

    function remove(oldIndex) {
      if (oldCovers[oldIndex] !== creatingCover) {
        controller.group.remove(oldCovers[oldIndex]);
      }
    }
  },
  unmount: function () {
    this.enableBrush(false); // container may 'removeAll' outside.

    clearCovers(this);

    this._zr.remove(this.group);

    return this;
  },
  dispose: function () {
    this.unmount();
    this.off();
  }
};
zrUtil.mixin(BrushController, Eventful);

function doEnableBrush(controller, brushOption) {
  var zr = controller._zr; // Consider roam, which takes globalPan too.

  if (!controller._enableGlobalPan) {
    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);
  }

  each(controller._handlers, function (handler, eventName) {
    zr.on(eventName, handler);
  });
  controller._brushType = brushOption.brushType;
  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
}

function doDisableBrush(controller) {
  var zr = controller._zr;
  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);
  each(controller._handlers, function (handler, eventName) {
    zr.off(eventName, handler);
  });
  controller._brushType = controller._brushOption = null;
}

function createCover(controller, brushOption) {
  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
  cover.__brushOption = brushOption;
  updateZ(cover, brushOption);
  controller.group.add(cover);
  return cover;
}

function endCreating(controller, creatingCover) {
  var coverRenderer = getCoverRenderer(creatingCover);

  if (coverRenderer.endCreating) {
    coverRenderer.endCreating(controller, creatingCover);
    updateZ(creatingCover, creatingCover.__brushOption);
  }

  return creatingCover;
}

function updateCoverShape(controller, cover) {
  var brushOption = cover.__brushOption;
  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}

function updateZ(cover, brushOption) {
  var z = brushOption.z;
  z == null && (z = COVER_Z);
  cover.traverse(function (el) {
    el.z = z;
    el.z2 = z; // Consider in given container.
  });
}

function updateCoverAfterCreation(controller, cover) {
  getCoverRenderer(cover).updateCommon(controller, cover);
  updateCoverShape(controller, cover);
}

function getCoverRenderer(cover) {
  return coverRenderers[cover.__brushOption.brushType];
} // return target panel or `true` (means global panel)


function getPanelByPoint(controller, e, localCursorPoint) {
  var panels = controller._panels;

  if (!panels) {
    return true; // Global panel
  }

  var panel;
  var transform = controller._transform;
  each(panels, function (pn) {
    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);
  });
  return panel;
} // Return a panel or true


function getPanelByCover(controller, cover) {
  var panels = controller._panels;

  if (!panels) {
    return true; // Global panel
  }

  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,
  // which is then treated as global panel.

  return panelId != null ? panels[panelId] : true;
}

function clearCovers(controller) {
  var covers = controller._covers;
  var originalLength = covers.length;
  each(covers, function (cover) {
    controller.group.remove(cover);
  }, controller);
  covers.length = 0;
  return !!originalLength;
}

function trigger(controller, opt) {
  var areas = map(controller._covers, function (cover) {
    var brushOption = cover.__brushOption;
    var range = zrUtil.clone(brushOption.range);
    return {
      brushType: brushOption.brushType,
      panelId: brushOption.panelId,
      range: range
    };
  });
  controller.trigger('brush', areas, {
    isEnd: !!opt.isEnd,
    removeOnClick: !!opt.removeOnClick
  });
}

function shouldShowCover(controller) {
  var track = controller._track;

  if (!track.length) {
    return false;
  }

  var p2 = track[track.length - 1];
  var p1 = track[0];
  var dx = p2[0] - p1[0];
  var dy = p2[1] - p1[1];
  var dist = mathPow(dx * dx + dy * dy, 0.5);
  return dist > UNSELECT_THRESHOLD;
}

function getTrackEnds(track) {
  var tail = track.length - 1;
  tail < 0 && (tail = 0);
  return [track[0], track[tail]];
}

function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {
  var cover = new graphic.Group();
  cover.add(new graphic.Rect({
    name: 'main',
    style: makeStyle(brushOption),
    silent: true,
    draggable: true,
    cursor: 'move',
    drift: curry(doDrift, controller, cover, 'nswe'),
    ondragend: curry(trigger, controller, {
      isEnd: true
    })
  }));
  each(edgeNames, function (name) {
    cover.add(new graphic.Rect({
      name: name,
      style: {
        opacity: 0
      },
      draggable: true,
      silent: true,
      invisible: true,
      drift: curry(doDrift, controller, cover, name),
      ondragend: curry(trigger, controller, {
        isEnd: true
      })
    }));
  });
  return cover;
}

function updateBaseRect(controller, cover, localRange, brushOption) {
  var lineWidth = brushOption.brushStyle.lineWidth || 0;
  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);
  var x = localRange[0][0];
  var y = localRange[1][0];
  var xa = x - lineWidth / 2;
  var ya = y - lineWidth / 2;
  var x2 = localRange[0][1];
  var y2 = localRange[1][1];
  var x2a = x2 - handleSize + lineWidth / 2;
  var y2a = y2 - handleSize + lineWidth / 2;
  var width = x2 - x;
  var height = y2 - y;
  var widtha = width + lineWidth;
  var heighta = height + lineWidth;
  updateRectShape(controller, cover, 'main', x, y, width, height);

  if (brushOption.transformable) {
    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);
    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);
    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);
    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);
    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);
    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);
    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);
    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);
  }
}

function updateCommon(controller, cover) {
  var brushOption = cover.__brushOption;
  var transformable = brushOption.transformable;
  var mainEl = cover.childAt(0);
  mainEl.useStyle(makeStyle(brushOption));
  mainEl.attr({
    silent: !transformable,
    cursor: transformable ? 'move' : 'default'
  });
  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {
    var el = cover.childOfName(name);
    var globalDir = getGlobalDirection(controller, name);
    el && el.attr({
      silent: !transformable,
      invisible: !transformable,
      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null
    });
  });
}

function updateRectShape(controller, cover, name, x, y, w, h) {
  var el = cover.childOfName(name);
  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
}

function makeStyle(brushOption) {
  return zrUtil.defaults({
    strokeNoScale: true
  }, brushOption.brushStyle);
}

function formatRectRange(x, y, x2, y2) {
  var min = [mathMin(x, x2), mathMin(y, y2)];
  var max = [mathMax(x, x2), mathMax(y, y2)];
  return [[min[0], max[0]], // x range
  [min[1], max[1]] // y range
  ];
}

function getTransform(controller) {
  return graphic.getTransform(controller.group);
}

function getGlobalDirection(controller, localDirection) {
  if (localDirection.length > 1) {
    localDirection = localDirection.split('');
    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];
    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();
    return globalDir.join('');
  } else {
    var map = {
      w: 'left',
      e: 'right',
      n: 'top',
      s: 'bottom'
    };
    var inverseMap = {
      left: 'w',
      right: 'e',
      top: 'n',
      bottom: 's'
    };
    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));
    return inverseMap[globalDir];
  }
}

function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {
  var brushOption = cover.__brushOption;
  var rectRange = toRectRange(brushOption.range);
  var localDelta = toLocalDelta(controller, dx, dy);
  each(name.split(''), function (namePart) {
    var ind = DIRECTION_MAP[namePart];
    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
  });
  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}

function driftPolygon(controller, cover, dx, dy, e) {
  var range = cover.__brushOption.range;
  var localDelta = toLocalDelta(controller, dx, dy);
  each(range, function (point) {
    point[0] += localDelta[0];
    point[1] += localDelta[1];
  });
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}

function toLocalDelta(controller, dx, dy) {
  var thisGroup = controller.group;
  var localD = thisGroup.transformCoordToLocal(dx, dy);
  var localZero = thisGroup.transformCoordToLocal(0, 0);
  return [localD[0] - localZero[0], localD[1] - localZero[1]];
}

function clipByPanel(controller, cover, data) {
  var panel = getPanelByCover(controller, cover);
  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);
}

function pointsToRect(points) {
  var xmin = mathMin(points[0][0], points[1][0]);
  var ymin = mathMin(points[0][1], points[1][1]);
  var xmax = mathMax(points[0][0], points[1][0]);
  var ymax = mathMax(points[0][1], points[1][1]);
  return {
    x: xmin,
    y: ymin,
    width: xmax - xmin,
    height: ymax - ymin
  };
}

function resetCursor(controller, e, localCursorPoint) {
  // Check active
  if (!controller._brushType) {
    return;
  }

  var zr = controller._zr;
  var covers = controller._covers;
  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.

  if (!controller._dragging) {
    for (var i = 0; i < covers.length; i++) {
      var brushOption = covers[i].__brushOption;

      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
        // Use cursor style set on cover.
        return;
      }
    }
  }

  currPanel && zr.setCursorStyle('crosshair');
}

function preventDefault(e) {
  var rawE = e.event;
  rawE.preventDefault && rawE.preventDefault();
}

function mainShapeContain(cover, x, y) {
  return cover.childOfName('main').contain(x, y);
}

function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {
  var creatingCover = controller._creatingCover;
  var panel = controller._creatingPanel;
  var thisBrushOption = controller._brushOption;
  var eventParams;

  controller._track.push(localCursorPoint.slice());

  if (shouldShowCover(controller) || creatingCover) {
    if (panel && !creatingCover) {
      thisBrushOption.brushMode === 'single' && clearCovers(controller);
      var brushOption = zrUtil.clone(thisBrushOption);
      brushOption.brushType = determineBrushType(brushOption.brushType, panel);
      brushOption.panelId = panel === true ? null : panel.panelId;
      creatingCover = controller._creatingCover = createCover(controller, brushOption);

      controller._covers.push(creatingCover);
    }

    if (creatingCover) {
      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
      var coverBrushOption = creatingCover.__brushOption;
      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));

      if (isEnd) {
        endCreating(controller, creatingCover);
        coverRenderer.updateCommon(controller, creatingCover);
      }

      updateCoverShape(controller, creatingCover);
      eventParams = {
        isEnd: isEnd
      };
    }
  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {
    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.
    // But a single click do not clear covers, because user may have casual
    // clicks (for example, click on other component and do not expect covers
    // disappear).
    // Only some cover removed, trigger action, but not every click trigger action.
    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {
      eventParams = {
        isEnd: isEnd,
        removeOnClick: true
      };
    }
  }

  return eventParams;
}

function determineBrushType(brushType, panel) {
  if (brushType === 'auto') {
    return panel.defaultBrushType;
  }

  return brushType;
}

var mouseHandlers = {
  mousedown: function (e) {
    if (this._dragging) {
      // In case some browser do not support globalOut,
      // and release mose out side the browser.
      handleDragEnd.call(this, e);
    } else if (!e.target || !e.target.draggable) {
      preventDefault(e);
      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
      this._creatingCover = null;
      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);

      if (panel) {
        this._dragging = true;
        this._track = [localCursorPoint.slice()];
      }
    }
  },
  mousemove: function (e) {
    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
    resetCursor(this, e, localCursorPoint);

    if (this._dragging) {
      preventDefault(e);
      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);
      eventParams && trigger(this, eventParams);
    }
  },
  mouseup: handleDragEnd //,
  // FIXME
  // in tooltip, globalout should not be triggered.
  // globalout: handleDragEnd

};

function handleDragEnd(e) {
  if (this._dragging) {
    preventDefault(e);
    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
    var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);
    this._dragging = false;
    this._track = [];
    this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.

    eventParams && trigger(this, eventParams);
  }
}
/**
 * key: brushType
 * @type {Object}
 */


var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function (controller, brushOption) {
      return createBaseRectCover(curry(driftRect, function (range) {
        return range;
      }, function (range) {
        return range;
      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);
    },
    getCreatingRange: function (localTrack) {
      var ends = getTrackEnds(localTrack);
      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      updateBaseRect(controller, cover, localRange, brushOption);
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function (controller, brushOption) {
      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the
      // border of the shape when drawing, which is a better experience for user.

      cover.add(new graphic.Polyline({
        name: 'main',
        style: makeStyle(brushOption),
        silent: true
      }));
      return cover;
    },
    getCreatingRange: function (localTrack) {
      return localTrack;
    },
    endCreating: function (controller, cover) {
      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.

      cover.add(new graphic.Polygon({
        name: 'main',
        draggable: true,
        drift: curry(driftPolygon, controller, cover),
        ondragend: curry(trigger, controller, {
          isEnd: true
        })
      }));
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      cover.childAt(0).setShape({
        points: clipByPanel(controller, cover, localRange)
      });
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  }
};

function getLineRenderer(xyIndex) {
  return {
    createCover: function (controller, brushOption) {
      return createBaseRectCover(curry(driftRect, function (range) {
        var rectRange = [range, [0, 100]];
        xyIndex && rectRange.reverse();
        return rectRange;
      }, function (rectRange) {
        return rectRange[xyIndex];
      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);
    },
    getCreatingRange: function (localTrack) {
      var ends = getTrackEnds(localTrack);
      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);
      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);
      return [min, max];
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      var otherExtent; // If brushWidth not specified, fit the panel.

      var panel = getPanelByCover(controller, cover);

      if (panel !== true && panel.getLinearBrushOtherExtent) {
        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);
      } else {
        var zr = controller._zr;
        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
      }

      var rectRange = [localRange, otherExtent];
      xyIndex && rectRange.reverse();
      updateBaseRect(controller, cover, rectRange, brushOption);
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  };
}

var _default = BrushController;
module.exports = _default;

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var _config = __webpack_require__(96);

var __DEV__ = _config.__DEV__;

var zrUtil = __webpack_require__(91);

var graphic = __webpack_require__(93);

var modelUtil = __webpack_require__(95);

var brushHelper = __webpack_require__(308);

var each = zrUtil.each;
var indexOf = zrUtil.indexOf;
var curry = zrUtil.curry;
var COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME
// how to genarialize to more coordinate systems.

var INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];
/**
 * [option in constructor]:
 * {
 *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
 * }
 *
 *
 * [targetInfo]:
 *
 * There can be multiple axes in a single targetInfo. Consider the case
 * of `grid` component, a targetInfo represents a grid which contains one or more
 * cartesian and one or more axes. And consider the case of parallel system,
 * which has multiple axes in a coordinate system.
 * Can be {
 *     panelId: ...,
 *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,
 *     coordSyses: all cartesians.
 *     gridModel: <grid component>
 *     xAxes: correspond to coordSyses on index
 *     yAxes: correspond to coordSyses on index
 * }
 * or {
 *     panelId: ...,
 *     coordSys: <geo coord sys>
 *     coordSyses: [<geo coord sys>]
 *     geoModel: <geo component>
 * }
 *
 *
 * [panelOpt]:
 *
 * Make from targetInfo. Input to BrushController.
 * {
 *     panelId: ...,
 *     rect: ...
 * }
 *
 *
 * [area]:
 *
 * Generated by BrushController or user input.
 * {
 *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.
 *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').
 *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.
 *     range: pixel range.
 *     coordRange: representitive coord range (the first one of coordRanges).
 *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.
 * }
 */

/**
 * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid
 *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}
 * @param {module:echarts/model/Global} ecModel
 * @param {Object} [opt]
 * @param {Array.<string>} [opt.include] include coordinate system types.
 */

function BrushTargetManager(option, ecModel, opt) {
  /**
   * @private
   * @type {Array.<Object>}
   */
  var targetInfoList = this._targetInfoList = [];
  var info = {};
  var foundCpts = parseFinder(ecModel, option);
  each(targetInfoBuilders, function (builder, type) {
    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
      builder(foundCpts, targetInfoList, info);
    }
  });
}

var proto = BrushTargetManager.prototype;

proto.setOutputRanges = function (areas, ecModel) {
  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges

    if (!area.coordRange) {
      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not
      // rebuild range by coordRange accrately, which may bring trouble when
      // brushing only one item. So we use __rangeOffset to rebuilding range
      // by coordRange. And this it only used in brush component so it is no
      // need to be adapted to coordRanges.

      var result = coordConvert[area.brushType](0, coordSys, coordRange);
      area.__rangeOffset = {
        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
        xyMinMax: result.xyMinMax
      };
    }
  });
};

proto.matchOutputRanges = function (areas, ecModel, cb) {
  each(areas, function (area) {
    var targetInfo = this.findTargetInfo(area, ecModel);

    if (targetInfo && targetInfo !== true) {
      zrUtil.each(targetInfo.coordSyses, function (coordSys) {
        var result = coordConvert[area.brushType](1, coordSys, area.range);
        cb(area, result.values, coordSys, ecModel);
      });
    }
  }, this);
};

proto.setInputRanges = function (areas, ecModel) {
  each(areas, function (area) {
    var targetInfo = this.findTargetInfo(area, ecModel);
    area.range = area.range || []; // convert coordRange to global range and set panelId.

    if (targetInfo && targetInfo !== true) {
      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does
      // not keep its original value, for the sake of the dataZoom scenario,
      // where area.coordRange remains unchanged but area.range may be changed.
      // (2) Only support converting one coordRange to pixel range in brush
      // component. So do not consider `coordRanges`.
      // (3) About __rangeOffset, see comment above.

      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
      var rangeOffset = area.__rangeOffset;
      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
    }
  }, this);
};

proto.makePanelOpts = function (api, getDefaultBrushType) {
  return zrUtil.map(this._targetInfoList, function (targetInfo) {
    var rect = targetInfo.getPanelRect();
    return {
      panelId: targetInfo.panelId,
      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),
      clipPath: brushHelper.makeRectPanelClipPath(rect),
      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)
    };
  });
};

proto.controlSeries = function (area, seriesModel, ecModel) {
  // Check whether area is bound in coord, and series do not belong to that coord.
  // If do not do this check, some brush (like lineX) will controll all axes.
  var targetInfo = this.findTargetInfo(area, ecModel);
  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
};
/**
 * If return Object, a coord found.
 * If reutrn true, global found.
 * Otherwise nothing found.
 *
 * @param {Object} area
 * @param {Array} targetInfoList
 * @return {Object|boolean}
 */


proto.findTargetInfo = function (area, ecModel) {
  var targetInfoList = this._targetInfoList;
  var foundCpts = parseFinder(ecModel, area);

  for (var i = 0; i < targetInfoList.length; i++) {
    var targetInfo = targetInfoList[i];
    var areaPanelId = area.panelId;

    if (areaPanelId) {
      if (targetInfo.panelId === areaPanelId) {
        return targetInfo;
      }
    } else {
      for (var i = 0; i < targetInfoMatchers.length; i++) {
        if (targetInfoMatchers[i](foundCpts, targetInfo)) {
          return targetInfo;
        }
      }
    }
  }

  return true;
};

function formatMinMax(minMax) {
  minMax[0] > minMax[1] && minMax.reverse();
  return minMax;
}

function parseFinder(ecModel, option) {
  return modelUtil.parseFinder(ecModel, option, {
    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
  });
}

var targetInfoBuilders = {
  grid: function (foundCpts, targetInfoList) {
    var xAxisModels = foundCpts.xAxisModels;
    var yAxisModels = foundCpts.yAxisModels;
    var gridModels = foundCpts.gridModels; // Remove duplicated.

    var gridModelMap = zrUtil.createHashMap();
    var xAxesHas = {};
    var yAxesHas = {};

    if (!xAxisModels && !yAxisModels && !gridModels) {
      return;
    }

    each(xAxisModels, function (axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
    });
    each(yAxisModels, function (axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      yAxesHas[gridModel.id] = true;
    });
    each(gridModels, function (gridModel) {
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
      yAxesHas[gridModel.id] = true;
    });
    gridModelMap.each(function (gridModel) {
      var grid = gridModel.coordinateSystem;
      var cartesians = [];
      each(grid.getCartesians(), function (cartesian, index) {
        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {
          cartesians.push(cartesian);
        }
      });
      targetInfoList.push({
        panelId: 'grid--' + gridModel.id,
        gridModel: gridModel,
        coordSysModel: gridModel,
        // Use the first one as the representitive coordSys.
        coordSys: cartesians[0],
        coordSyses: cartesians,
        getPanelRect: panelRectBuilder.grid,
        xAxisDeclared: xAxesHas[gridModel.id],
        yAxisDeclared: yAxesHas[gridModel.id]
      });
    });
  },
  geo: function (foundCpts, targetInfoList) {
    each(foundCpts.geoModels, function (geoModel) {
      var coordSys = geoModel.coordinateSystem;
      targetInfoList.push({
        panelId: 'geo--' + geoModel.id,
        geoModel: geoModel,
        coordSysModel: geoModel,
        coordSys: coordSys,
        coordSyses: [coordSys],
        getPanelRect: panelRectBuilder.geo
      });
    });
  }
};
var targetInfoMatchers = [// grid
function (foundCpts, targetInfo) {
  var xAxisModel = foundCpts.xAxisModel;
  var yAxisModel = foundCpts.yAxisModel;
  var gridModel = foundCpts.gridModel;
  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
  return gridModel && gridModel === targetInfo.gridModel;
}, // geo
function (foundCpts, targetInfo) {
  var geoModel = foundCpts.geoModel;
  return geoModel && geoModel === targetInfo.geoModel;
}];
var panelRectBuilder = {
  grid: function () {
    // grid is not Transformable.
    return this.coordSys.grid.getRect().clone();
  },
  geo: function () {
    var coordSys = this.coordSys;
    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform

    rect.applyTransform(graphic.getTransform(coordSys));
    return rect;
  }
};
var coordConvert = {
  lineX: curry(axisConvert, 0),
  lineY: curry(axisConvert, 1),
  rect: function (to, coordSys, rangeOrCoordRange) {
    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);
    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);
    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
    return {
      values: values,
      xyMinMax: values
    };
  },
  polygon: function (to, coordSys, rangeOrCoordRange) {
    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
    var values = zrUtil.map(rangeOrCoordRange, function (item) {
      var p = coordSys[COORD_CONVERTS[to]](item);
      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
      return p;
    });
    return {
      values: values,
      xyMinMax: xyMinMax
    };
  }
};

function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);
  var values = formatMinMax(zrUtil.map([0, 1], function (i) {
    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
  }));
  var xyMinMax = [];
  xyMinMax[axisNameIndex] = values;
  xyMinMax[1 - axisNameIndex] = [NaN, NaN];
  return {
    values: values,
    xyMinMax: xyMinMax
  };
}

var diffProcessor = {
  lineX: curry(axisDiffProcessor, 0),
  lineY: curry(axisDiffProcessor, 1),
  rect: function (values, refer, scales) {
    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
  },
  polygon: function (values, refer, scales) {
    return zrUtil.map(values, function (item, idx) {
      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
    });
  }
};

function axisDiffProcessor(axisNameIndex, values, refer, scales) {
  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
} // We have to process scale caused by dataZoom manually,
// although it might be not accurate.


function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
  var sizeCurr = getSize(xyMinMaxCurr);
  var sizeOrigin = getSize(xyMinMaxOrigin);
  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
  isNaN(scales[0]) && (scales[0] = 1);
  isNaN(scales[1]) && (scales[1] = 1);
  return scales;
}

function getSize(xyMinMax) {
  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}

var _default = BrushTargetManager;
module.exports = _default;

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var BoundingRect = __webpack_require__(101);

var _cursorHelper = __webpack_require__(309);

var onIrrelevantElement = _cursorHelper.onIrrelevantElement;

var graphicUtil = __webpack_require__(93);

function makeRectPanelClipPath(rect) {
  rect = normalizeRect(rect);
  return function (localPoints, transform) {
    return graphicUtil.clipPointsByRect(localPoints, rect);
  };
}

function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
  rect = normalizeRect(rect);
  return function (xyIndex) {
    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
    var brushWidth = idx ? rect.width : rect.height;
    var base = idx ? rect.x : rect.y;
    return [base, base + (brushWidth || 0)];
  };
}

function makeRectIsTargetByCursor(rect, api, targetModel) {
  rect = normalizeRect(rect);
  return function (e, localCursorPoint, transform) {
    return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);
  };
} // Consider width/height is negative.


function normalizeRect(rect) {
  return BoundingRect.create(rect);
}

exports.makeRectPanelClipPath = makeRectPanelClipPath;
exports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;
exports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;

/***/ }),
/* 309 */
/***/ (function(module, exports) {

var IRRELEVANT_EXCLUDES = {
  'axisPointer': 1,
  'tooltip': 1,
  'brush': 1
};
/**
 * Avoid that: mouse click on a elements that is over geo or graph,
 * but roam is triggered.
 */

function onIrrelevantElement(e, api, targetCoordSysModel) {
  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.

  var coordSys = model && model.coordinateSystem;
  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;
}

exports.onIrrelevantElement = onIrrelevantElement;

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(177);

__webpack_require__(116);

__webpack_require__(117);

__webpack_require__(311);

__webpack_require__(312);

__webpack_require__(179);

__webpack_require__(180);

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

var DataZoomModel = __webpack_require__(116);

var _default = DataZoomModel.extend({
  type: 'dataZoom.select'
});

module.exports = _default;

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var DataZoomView = __webpack_require__(117);

var _default = DataZoomView.extend({
  type: 'dataZoom.select'
});

module.exports = _default;

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var echarts = __webpack_require__(92);

var history = __webpack_require__(184);

var lang = __webpack_require__(118);

var featureManager = __webpack_require__(109);

var restoreLang = lang.toolbox.restore;

function Restore(model) {
  this.model = model;
}

Restore.defaultOption = {
  show: true,
  icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
  title: restoreLang.title
};
var proto = Restore.prototype;

proto.onclick = function (ecModel, api, type) {
  history.clear(ecModel);
  api.dispatchAction({
    type: 'restore',
    from: this.uid
  });
};

featureManager.register('restore', Restore);
echarts.registerAction({
  type: 'restore',
  event: 'restore',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  ecModel.resetOption('recreate');
});
var _default = Restore;
module.exports = _default;

/***/ }),
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//

// let echarts = require('echarts');
var echarts = __webpack_require__(92);
// 引入柱状图
__webpack_require__(240);
__webpack_require__(255);
// 引入提示框和标题组件
__webpack_require__(264);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(282);
__webpack_require__(290);
__webpack_require__(293);
__webpack_require__(299);

/* harmony default export */ __webpack_exports__["default"] = ({
	data: function data() {
		return {
			statistics: ''
		};
	},
	mounted: function mounted() {
		var t = this;

		t.statistics = echarts.init(document.getElementById('statistics'));
		var order_options = {
			title: {
				left: 'center',
				text: '近期 15 天每日用户身份收入、支出金额统计',
				subtext: '按日划分，金额单位：分'
			},
			tooltip: {
				trigger: 'axis'
			},
			legend: {
				top: '60px',
				data: []
			},
			// color : ['#7079DF','#D15B7F','#FB6E6C','#FF9F69','#FEB64D','#FFDA43','#FFE88E'],
			toolbox: {
				show: true,
				feature: {
					magicType: { show: true, type: ['line', 'bar'] },
					saveAsImage: { show: true }
				}
			},
			grid: {
				top: '150px',
				bottom: '50px',
				containLabel: true
			},
			calculable: true,
			dataZoom: [{
				show: true,
				realtime: true,
				start: 80,
				end: 100
			}, {
				type: 'inside',
				realtime: true,
				start: 60,
				end: 100
			}],
			xAxis: [{
				type: 'category',
				nameGap: '60',
				data: []
			}],
			yAxis: [{
				type: 'value'
			}],
			series: []
		};
		get('/user_transfer', {}, function (data) {
			var dates = data.dates;
			var purse_types = data.purse_types;
			var out = data.out;
			var into = data.into;
			var amounts = data.amounts;

			// X 轴数据展示
			order_options.xAxis[0].data = dates;

			// 基本信息变量
			var series_template = function series_template() {
				return {
					name: '',
					type: 'bar',
					stack: '', // 正负轴相同的值会上下顶在一起
					data: [],
					// markPoint : {
					// 	symbol : 'pin',
					// 	data : [
					// 		{type : 'max', name: '最大值'},
					// 		{type : 'min', name: '最小值'}
					// 	]
					// },
					markLine: {
						data: [{ type: 'average', name: '平均值' }]
					},
					label: {
						show: true
					}
				};
			};

			for (var type in amounts) {
				var series = series_template();
				series.name = purse_types[type];
				order_options.legend.data.push(series.name);
				series.stack = type.substr(0, 1) == '-' ? type.substr(1) : type;
				for (var date in amounts[type]) {
					var date_val = amounts[type][date];
					series.data.push({
						value: date_val,
						// 在柱状条上显示数值
						label: {
							normal: {
								show: true,
								rotate: 90
							}
						}
					});
					// if(date_val < 0){
					// 	series.markPoint.symbolRotate = 180;
					// }
				}
				order_options.series.push(series);
			}

			t.statistics.setOption(order_options);
		});

		window.onresize = function () {
			setTimeout(function () {
				t.statistics.resize();
			}, 200);
		};
	}
});

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "welcome" }, [
      _c("div", { staticClass: "mdui-typo" }, [
        _c("blockquote", { staticClass: "blockquote_normal" }, [
          _c("p", [
            _vm._v("注：仅统计[用户身份]的流水收入、支出，包括所有钱包")
          ])
        ])
      ]),
      _vm._v(" "),
      _c("div", {
        staticStyle: { width: "100%", height: "500px" },
        attrs: { id: "statistics" }
      })
    ])
  }
]
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-ae438964", module.exports)
  }
}

/***/ })
]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvaW5kZXgvdXNlcl90cmFuc2Zlci52dWUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZWNoYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9ncmFwaGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvZm9ybWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9Nb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvY2xhenouanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzSGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3Rocm90dGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xhbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9tYWtlU3R5bGVNYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL0xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL1NjYWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvbW9kZWxIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9Db29yZGluYXRlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9TZXJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL0RhdGFEaWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL0ludGVydmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL3NsaWRlck1vdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3pyZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0xSVS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2Jib3guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2NvbG9yUGFsZXR0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlldy9Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ZpZXcvQ2hhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvaGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzTW9kZWxDb21tb25NaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvQXhpcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9ncmlkU2ltcGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9BeGlzQnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL2NhcnRlc2lhbkF4aXNIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZmluZFBvaW50RnJvbVNlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvdmlld0hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2xpc3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS90eXBlRGVmYXVsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2ludGVyYWN0aW9uTXV0ZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2RhdGFab29tQWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtlck1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL21hcmtlckhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9TdG9yYWdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvUGFpbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvR2VzdHVyZU1nci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvR2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9saW5lU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2FyZWFTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vdGV4dFN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9saW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9hcmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0NvbXBvdW5kUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vaXRlbVN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9ib3hMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL2dsb2JhbERlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL0V4dGVuc2lvbkFQSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvT3B0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJlcHJvY2Vzc29yL2JhY2t3YXJkQ29tcGF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvaGVscGVyL2NvbXBhdFN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvc2VyaWVzQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xvYWRpbmcvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL1RpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL0xvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL3BhcnNlR2VvSnNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL1JlZ2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wb2x5Z29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xheW91dC9iYXJHcmlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuMkQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNEZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFyU2VyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFzZUJhclNlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9iYXJJdGVtU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9DYXJ0ZXNpYW5BeGlzVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lU2VyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL0xpbmVWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvbGFiZWxIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvbGluZUFuaW1hdGlvbkRpZmYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvcG9seS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlzdWFsL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L3BvaW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJvY2Vzc29yL2RhdGFTYW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9heGlzVHJpZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0Jhc2VBeGlzUG9pbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90aXRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZFNjcm9sbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9sZWdlbmRBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL1Njcm9sbGFibGVMZWdlbmRNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9zY3JvbGxhYmxlTGVnZW5kQWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21Nb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21WaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vcm9hbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50TW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50Vmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtMaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtMaW5lTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya0xpbmVWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZURyYXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9MaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9Ub29sYm94TW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL1NhdmVBc0ltYWdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL01hZ2ljVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hUYXJnZXRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2JydXNoSGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2N1cnNvckhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tU2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2VsZWN0Wm9vbU1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2VsZWN0Wm9vbVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvUmVzdG9yZS5qcyIsIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL2luZGV4L3VzZXJfdHJhbnNmZXIudnVlIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9pbmRleC91c2VyX3RyYW5zZmVyLnZ1ZT9lNzU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBc1I7QUFDdFI7QUFDQSw4Q0FBbUw7QUFDbkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsWUFBWSxFQUFFO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0EsR0FBRztBQUNI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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCOzs7Ozs7QUM5cUJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQjs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyw0QkFBNEI7QUFDdkM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsT0FBTztBQUNsQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0I7Ozs7OztBQzFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLGVBQWU7QUFDM0IsWUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksZUFBZTtBQUMzQixZQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksZUFBZTtBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLGVBQWU7QUFDM0IsWUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksZUFBZTtBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWYsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRDs7Ozs7O0FDbmhCQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEMsa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLEtBQUssaUJBQWlCOzs7QUFHdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7O0FDaFJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsMkJBQTJCOztBQUUzQixxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsWUFBWSxlQUFlO0FBQzNCOzs7QUFHQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksZUFBZTtBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQiwrQkFBK0I7O0FBRS9CLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLGVBQWU7QUFDMUIsWUFBWSxlQUFlO0FBQzNCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksZ0JBQWdCO0FBQzVCLHFDQUFxQyx3REFBd0Q7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Qjs7Ozs7O0FDNW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCOzs7Ozs7QUNuSkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseURBQXlEO0FBQ3pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7OztBQzVTQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZUFBZTtBQUN0RSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFOztBQUVyRTtBQUNBLHdGQUF3RjtBQUN4Rjs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRDs7Ozs7O0FDcExBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCOzs7Ozs7QUN0Q0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYyxnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxlQUFlO0FBQzVCLGFBQWEsdUNBQXVDO0FBQ3BELGNBQWMsT0FBTyxFQUFFLDBCQUEwQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQjs7Ozs7O0FDdFVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLEdBQUc7QUFDSDtBQUNBLDhFQUE4RSw2QkFBNkI7O0FBRTNHO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FB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ZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQjs7Ozs7O0FDekxBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FB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QTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7QUM3Q0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQyxFOzs7Ozs7QUN6QkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEI7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtB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O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsMEI7Ozs7OztBQ3BTQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsaUJBQWlCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQjs7Ozs7O0FDdEpBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwwQjs7Ozs7O0FDUkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0JBQWdCO0FBQ2hCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsMEI7Ozs7OztBQzdEQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1RUFBdUU7QUFDdkU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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R0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMEI7Ozs7OztBQ3pDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQjs7Ozs7O0FDaEhBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQTJDO0FBQzVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0hBQXdIOztBQUV4SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssUUFBUTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDs7QUFFQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSUFBcUk7QUFDckk7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLHlHQUF5RztBQUN6RyxLQUFLLEVBQUU7OztBQUdQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGNBQWMsc0NBQXNDO0FBQ3BELGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxXQUFXLDBDQUEwQztBQUNyRDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsMEI7Ozs7OztBQzdhQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQjs7Ozs7O0FDckVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FB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RUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLFFBQVE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEksTUFBTTtBQUNsSixHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsMEI7Ozs7OztBQy9CQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLEVBQUU7O0FBRVA7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsMkJBQTJCO0FBQ3RDOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsMEI7Ozs7OztBQ3RJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7OztBQ1REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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QTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQjs7Ozs7O0FDbkZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEI7Ozs7OztBQzdWQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDBCOzs7Ozs7QUMxQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUI7Ozs7OztBQ1pBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPLGlCQUFpQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMEI7Ozs7OztBQ2xEQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FB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UUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBCOzs7Ozs7QUM1UkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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Z0NBREE7QUFEQSxNQVpBO0FBaUJBO0FBQ0E7QUFEQTtBQWpCQTtBQXFCQSxJQXRCQTs7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBREE7QUFFQTtBQUZBO0FBREE7QUFIQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBN0RBOztBQStEQTtBQUNBO0FBQ0E7QUFDQSxJQUZBLEVBRUEsR0FGQTtBQUdBLEdBSkE7QUFLQTtBQXJJQSxHOzs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0MsaUJBQWlCLDJCQUEyQjtBQUM1QywwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RCxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbnZhciBfX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj97XFxcImNhY2hlRGlyZWN0b3J5XFxcIjp0cnVlLFxcXCJwcmVzZXRzXFxcIjpbW1xcXCJlbnZcXFwiLHtcXFwibW9kdWxlc1xcXCI6ZmFsc2UsXFxcInRhcmdldHNcXFwiOntcXFwiYnJvd3NlcnNcXFwiOltcXFwiPiAyJVxcXCJdLFxcXCJ1Z2xpZnlcXFwiOnRydWV9fV1dLFxcXCJwbHVnaW5zXFxcIjpbXFxcInRyYW5zZm9ybS1vYmplY3QtcmVzdC1zcHJlYWRcXFwiLFtcXFwidHJhbnNmb3JtLXJ1bnRpbWVcXFwiLHtcXFwicG9seWZpbGxcXFwiOmZhbHNlLFxcXCJoZWxwZXJzXFxcIjpmYWxzZX1dXX0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi91c2VyX3RyYW5zZmVyLnZ1ZVwiKVxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYWU0Mzg5NjRcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi91c2VyX3RyYW5zZmVyLnZ1ZVwiKVxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJyZXNvdXJjZXNcXFxcYXNzZXRzXFxcXGpzXFxcXGNvbXBvbmVudHNcXFxcaW5kZXhcXFxcdXNlcl90cmFuc2Zlci52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtYWU0Mzg5NjRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1hZTQzODk2NFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL2luZGV4L3VzZXJfdHJhbnNmZXIudnVlXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL3V0aWxcbiAqL1xuLy8g55So5LqO5aSE55CGbWVyZ2Xml7bml6Dms5XpgY3ljoZEYXRl562J5a+56LGh55qE6Zeu6aKYXG52YXIgQlVJTFRJTl9PQkpFQ1QgPSB7XG4gICdbb2JqZWN0IEZ1bmN0aW9uXSc6IDEsXG4gICdbb2JqZWN0IFJlZ0V4cF0nOiAxLFxuICAnW29iamVjdCBEYXRlXSc6IDEsXG4gICdbb2JqZWN0IEVycm9yXSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJzogMSxcbiAgLy8gRm9yIG5vZGUtY2FudmFzXG4gICdbb2JqZWN0IEltYWdlXSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc10nOiAxXG59O1xudmFyIFRZUEVEX0FSUkFZID0ge1xuICAnW29iamVjdCBJbnQ4QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDhBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOiAxLFxuICAnW29iamVjdCBJbnQxNkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEludDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOiAxXG59O1xudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIG5hdGl2ZUZvckVhY2ggPSBhcnJheVByb3RvLmZvckVhY2g7XG52YXIgbmF0aXZlRmlsdGVyID0gYXJyYXlQcm90by5maWx0ZXI7XG52YXIgbmF0aXZlU2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xudmFyIG5hdGl2ZU1hcCA9IGFycmF5UHJvdG8ubWFwO1xudmFyIG5hdGl2ZVJlZHVjZSA9IGFycmF5UHJvdG8ucmVkdWNlOyAvLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxuXG52YXIgbWV0aG9kcyA9IHt9O1xuXG5mdW5jdGlvbiAkb3ZlcnJpZGUobmFtZSwgZm4pIHtcbiAgbWV0aG9kc1tuYW1lXSA9IGZuO1xufVxuLyoqXG4gKiBUaG9zZSBkYXRhIHR5cGVzIGNhbiBiZSBjbG9uZWQ6XG4gKiAgICAgUGxhaW4gb2JqZWN0LCBBcnJheSwgVHlwZWRBcnJheSwgbnVtYmVyLCBzdHJpbmcsIG51bGwsIHVuZGVmaW5lZC5cbiAqIFRob3NlIGRhdGEgdHlwZXMgd2lsbCBiZSBhc3NnaW5lZCB1c2luZyB0aGUgb3JnaW5hbCBkYXRhOlxuICogICAgIEJVSUxUSU5fT0JKRUNUXG4gKiBJbnN0YW5jZSBvZiB1c2VyIGRlZmluZWQgY2xhc3Mgd2lsbCBiZSBjbG9uZWQgdG8gYSBwbGFpbiBvYmplY3QsIHdpdGhvdXRcbiAqIHByb3BlcnRpZXMgaW4gcHJvdG90eXBlLlxuICogT3RoZXIgZGF0YSB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkIChub3Qgc3VyZSB3aGF0IHdpbGwgaGFwcGVuKS5cbiAqXG4gKiBDYXV0aW9uOiBkbyBub3Qgc3VwcG9ydCBjbG9uZSBEYXRlLCBmb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbi5cbiAqIChUaGVyZSBtaWdodCBiZSBhIGxhcmdlIG51bWJlciBvZiBkYXRlIGluIGBzZXJpZXMuZGF0YWApLlxuICogU28gZGF0ZSBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGluIGFuZCBvdXQgb2YgZWNoYXJ0cy5cbiAqXG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHJldHVybiB7Kn0gbmV3XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsIHx8IHR5cGVvZiBzb3VyY2UgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHNvdXJjZTtcbiAgdmFyIHR5cGVTdHIgPSBvYmpUb1N0cmluZy5jYWxsKHNvdXJjZSk7XG5cbiAgaWYgKHR5cGVTdHIgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZW3R5cGVTdHJdKSB7XG4gICAgdmFyIEN0b3IgPSBzb3VyY2UuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoc291cmNlLmNvbnN0cnVjdG9yLmZyb20pIHtcbiAgICAgIHJlc3VsdCA9IEN0b3IuZnJvbShzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBuZXcgQ3Rvcihzb3VyY2UubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBjbG9uZShzb3VyY2VbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghQlVJTFRJTl9PQkpFQ1RbdHlwZVN0cl0gJiYgIWlzUHJpbWl0aXZlKHNvdXJjZSkgJiYgIWlzRG9tKHNvdXJjZSkpIHtcbiAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpIHtcbiAgLy8gV2Ugc2hvdWxkIGVzY2Fwc2UgdGhhdCBzb3VyY2UgaXMgc3RyaW5nXG4gIC8vIGFuZCBlbnRlciBmb3IgLi4uIGluIC4uLlxuICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkgfHwgIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gb3ZlcndyaXRlID8gY2xvbmUoc291cmNlKSA6IHRhcmdldDtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XG4gICAgICB2YXIgc291cmNlUHJvcCA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcCkgJiYgaXNPYmplY3QodGFyZ2V0UHJvcCkgJiYgIWlzQXJyYXkoc291cmNlUHJvcCkgJiYgIWlzQXJyYXkodGFyZ2V0UHJvcCkgJiYgIWlzRG9tKHNvdXJjZVByb3ApICYmICFpc0RvbSh0YXJnZXRQcm9wKSAmJiAhaXNCdWlsdEluT2JqZWN0KHNvdXJjZVByb3ApICYmICFpc0J1aWx0SW5PYmplY3QodGFyZ2V0UHJvcCkgJiYgIWlzUHJpbWl0aXZlKHNvdXJjZVByb3ApICYmICFpc1ByaW1pdGl2ZSh0YXJnZXRQcm9wKSkge1xuICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxuICAgICAgICBtZXJnZSh0YXJnZXRQcm9wLCBzb3VyY2VQcm9wLCBvdmVyd3JpdGUpO1xuICAgICAgfSBlbHNlIGlmIChvdmVyd3JpdGUgfHwgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XG4gICAgICAgIC8vIE5PVEXvvIzlnKggdGFyZ2V0W2tleV0g5LiN5a2Y5Zyo55qE5pe25YCZ5Lmf5piv55u05o6l6KaG55uWXG4gICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc291cmNlW2tleV0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldEFuZFNvdXJjZXMgVGhlIGZpcnN0IGl0ZW0gaXMgdGFyZ2V0LCBhbmQgdGhlIHJlc3RzIGFyZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gKiBAcmV0dXJuIHsqfSB0YXJnZXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlQWxsKHRhcmdldEFuZFNvdXJjZXMsIG92ZXJ3cml0ZSkge1xuICB2YXIgcmVzdWx0ID0gdGFyZ2V0QW5kU291cmNlc1swXTtcblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGFyZ2V0QW5kU291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgdGFyZ2V0QW5kU291cmNlc1tpXSwgb3ZlcndyaXRlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVybGF5PWZhbHNlXVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbWV0aG9kcy5jcmVhdGVDYW52YXMoKTtcbn07XG5cbm1ldGhvZHMuY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG59OyAvLyBGSVhNRVxuXG5cbnZhciBfY3R4O1xuXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBpZiAoIV9jdHgpIHtcbiAgICAvLyBVc2UgdXRpbC5jcmVhdGVDYW52YXMgaW5zdGVhZCBvZiBjcmVhdGVDYW52YXNcbiAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgX2N0eCA9IGNyZWF0ZUNhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG4gIH1cblxuICByZXR1cm4gX2N0eDtcbn1cbi8qKlxuICog5p+l6K+i5pWw57uE5Lit5YWD57Sg55qEaW5kZXhcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gIGlmIChhcnJheSkge1xuICAgIGlmIChhcnJheS5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbi8qKlxuICog5p6E6YCg57G757un5om/5YWz57O7XG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XG4gKi9cblxuXG5mdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XG4gIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBGKCkge31cblxuICBGLnByb3RvdHlwZSA9IGJhc2VDbGF6ei5wcm90b3R5cGU7XG4gIGNsYXp6LnByb3RvdHlwZSA9IG5ldyBGKCk7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBjbGF6elByb3RvdHlwZSkge1xuICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xuICB9XG5cbiAgY2xhenoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xheno7XG4gIGNsYXp6LnN1cGVyQ2xhc3MgPSBiYXNlQ2xheno7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBzb3JjZVxuICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gKi9cblxuXG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICB0YXJnZXQgPSAncHJvdG90eXBlJyBpbiB0YXJnZXQgPyB0YXJnZXQucHJvdG90eXBlIDogdGFyZ2V0O1xuICBzb3VyY2UgPSAncHJvdG90eXBlJyBpbiBzb3VyY2UgPyBzb3VyY2UucHJvdG90eXBlIDogc291cmNlO1xuICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG59XG4vKipcbiAqIENvbnNpZGVyIHR5cGVkIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5TGlrZShkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgZGF0YS5sZW5ndGggPT0gJ251bWJlcic7XG59XG4vKipcbiAqIOaVsOe7hOaIluWvueixoemBjeWOhlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKi9cblxuXG5mdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiDmlbDnu4TmmKDlsIRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLm1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICByZXR1cm4gb2JqLm1hcChjYiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IFttZW1vXVxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gcmVkdWNlKG9iaiwgY2IsIG1lbW8sIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmoucmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgIHJldHVybiBvYmoucmVkdWNlKGNiLCBtZW1vLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtZW1vID0gY2IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH1cbn1cbi8qKlxuICog5pWw57uE6L+H5rukXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBmaWx0ZXIob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5maWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSB7XG4gICAgcmV0dXJuIG9iai5maWx0ZXIoY2IsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICByZXN1bHQucHVzaChvYmpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8qKlxuICog5pWw57uE6aG55p+l5om+XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmQob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgcmV0dXJuIG9ialtpXTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHsqfSBjb250ZXh0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmQoZnVuYywgY29udGV4dCkge1xuICB2YXIgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuXG5mdW5jdGlvbiBjdXJyeShmdW5jKSB7XG4gIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0J1aWx0SW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICEhQlVJTFRJTl9PQkpFQ1Rbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNEb20odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUub3duZXJEb2N1bWVudCA9PT0gJ29iamVjdCc7XG59XG4vKipcbiAqIFdoZXRoZXIgaXMgZXhhY3RseSBOYU4uIE5vdGljZSBpc05hTignYScpIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBlcU5hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuLyoqXG4gKiBJZiB2YWx1ZTEgaXMgbm90IG51bGwsIHRoZW4gcmV0dXJuIHZhbHVlMSwgb3RoZXJ3aXNlIGp1ZGdldCByZXN0IG9mIHZhbHVlcy5cbiAqIExvdyBwZXJmb3JtYW5jZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEByZXR1cm4geyp9IEZpbmFsIHZhbHVlXG4gKi9cblxuXG5mdW5jdGlvbiByZXRyaWV2ZSh2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cmlldmUyKHZhbHVlMCwgdmFsdWUxKSB7XG4gIHJldHVybiB2YWx1ZTAgIT0gbnVsbCA/IHZhbHVlMCA6IHZhbHVlMTtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmUzKHZhbHVlMCwgdmFsdWUxLCB2YWx1ZTIpIHtcbiAgcmV0dXJuIHZhbHVlMCAhPSBudWxsID8gdmFsdWUwIDogdmFsdWUxICE9IG51bGwgPyB2YWx1ZTEgOiB2YWx1ZTI7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBzbGljZSgpIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLmNhbGwuYXBwbHkobmF0aXZlU2xpY2UsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBjc3MgbGlrZWQgYXJyYXkgY29uZmlndXJhdGlvblxuICogZS5nLlxuICogIDMgPT4gWzMsIDMsIDMsIDNdXG4gKiAgWzQsIDJdID0+IFs0LCAyLCA0LCAyXVxuICogIFs0LCAzLCAyXSA9PiBbNCwgMywgMiwgM11cbiAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSB2YWxcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ3NzQXJyYXkodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbCwgdmFsXTtcbiAgfVxuXG4gIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyB2ZXJ0aWNhbCB8IGhvcml6b250YWxcbiAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMF0sIHZhbFsxXV07XG4gIH0gZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgLy8gdG9wIHwgaG9yaXpvbnRhbCB8IGJvdHRvbVxuICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFsyXSwgdmFsWzFdXTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG52YXIgcHJpbWl0aXZlS2V5ID0gJ19fZWNfcHJpbWl0aXZlX18nO1xuLyoqXG4gKiBTZXQgYW4gb2JqZWN0IGFzIHByaW1pdGl2ZSB0byBiZSBpZ25vcmVkIHRyYXZlcnNpbmcgY2hpbGRyZW4gaW4gY2xvbmUgb3IgbWVyZ2VcbiAqL1xuXG5mdW5jdGlvbiBzZXRBc1ByaW1pdGl2ZShvYmopIHtcbiAgb2JqW3ByaW1pdGl2ZUtleV0gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgcmV0dXJuIG9ialtwcmltaXRpdmVLZXldO1xufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT25seSBhcHBseSBgb3duUHJvcGVydHlgLlxuICovXG5cblxuZnVuY3Rpb24gSGFzaE1hcChvYmopIHtcbiAgb2JqICYmIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICB9LCB0aGlzKTtcbn0gLy8gQWRkIHByZWZpeCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG5cblxudmFyIEhBU0hfTUFQX1BSRUZJWCA9ICdfZWNfJztcbnZhciBIQVNIX01BUF9QUkVGSVhfTEVOR1RIID0gNDtcbkhhc2hNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFzaE1hcCxcbiAgLy8gRG8gbm90IHByb3ZpZGUgYGhhc2AgbWV0aG9kIHRvIGF2b2lkIGRlZmluaW5nIHdoYXQgaXMgYGhhc2AuXG4gIC8vIChXZSB1c3VhbGx5IHRyZWF0IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXMgdGhlIHNhbWUsIGRpZmZlcmVudFxuICAvLyBmcm9tIEVTNiBNYXApLlxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldID0gdmFsdWU7IC8vIENvbXBhcmluZyB3aXRoIGludm9jYXRpb24gY2hhaW5pbmcsIGByZXR1cm4gdmFsdWVgIGlzIG1vcmUgY29tbW9ubHlcbiAgICAvLyB1c2VkIGluIHRoaXMgY2FzZTogYHZhciBzb21lVmFsID0gbWFwLnNldCgnYScsIGdlblZhbCgpKTtgXG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIC8vIEFsdGhvdWdoIHV0aWwuZWFjaCBjYW4gYmUgcGVyZm9ybWVkIG9uIHRoaXMgaGFzaE1hcCBkaXJlY3RseSwgdXNlclxuICAvLyBzaG91bGQgbm90IHVzZSB0aGUgZXhwb3NlZCBrZXlzLCB3aG8gYXJlIHByZWZpeGVkLlxuICBlYWNoOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0ICE9PSB2b2lkIDAgJiYgKGNiID0gYmluZChjYiwgY29udGV4dCkpO1xuXG4gICAgZm9yICh2YXIgcHJlZml4ZWRLZXkgaW4gdGhpcykge1xuICAgICAgdGhpcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXhlZEtleSkgJiYgY2IodGhpc1twcmVmaXhlZEtleV0sIHByZWZpeGVkS2V5LnNsaWNlKEhBU0hfTUFQX1BSRUZJWF9MRU5HVEgpKTtcbiAgICB9XG4gIH0sXG4gIC8vIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgaWYgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICByZW1vdmVLZXk6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUgdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVIYXNoTWFwKG9iaikge1xuICByZXR1cm4gbmV3IEhhc2hNYXAob2JqKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydHMuJG92ZXJyaWRlID0gJG92ZXJyaWRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5leHBvcnRzLmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbmV4cG9ydHMuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XG5leHBvcnRzLmluZGV4T2YgPSBpbmRleE9mO1xuZXhwb3J0cy5pbmhlcml0cyA9IGluaGVyaXRzO1xuZXhwb3J0cy5taXhpbiA9IG1peGluO1xuZXhwb3J0cy5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuZXhwb3J0cy5lYWNoID0gZWFjaDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2U7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG5leHBvcnRzLmJpbmQgPSBiaW5kO1xuZXhwb3J0cy5jdXJyeSA9IGN1cnJ5O1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzQnVpbHRJbk9iamVjdCA9IGlzQnVpbHRJbk9iamVjdDtcbmV4cG9ydHMuaXNEb20gPSBpc0RvbTtcbmV4cG9ydHMuZXFOYU4gPSBlcU5hTjtcbmV4cG9ydHMucmV0cmlldmUgPSByZXRyaWV2ZTtcbmV4cG9ydHMucmV0cmlldmUyID0gcmV0cmlldmUyO1xuZXhwb3J0cy5yZXRyaWV2ZTMgPSByZXRyaWV2ZTM7XG5leHBvcnRzLnNsaWNlID0gc2xpY2U7XG5leHBvcnRzLm5vcm1hbGl6ZUNzc0FycmF5ID0gbm9ybWFsaXplQ3NzQXJyYXk7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuc2V0QXNQcmltaXRpdmUgPSBzZXRBc1ByaW1pdGl2ZTtcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcbmV4cG9ydHMuY3JlYXRlSGFzaE1hcCA9IGNyZWF0ZUhhc2hNYXA7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6cmVuZGVyID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3pyZW5kZXJcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgY29sb3JUb29sID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3Rvb2wvY29sb3JcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciB0aW1zb3J0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdGltc29ydFwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgR2xvYmFsTW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbC9HbG9iYWxcIik7XG5cbnZhciBFeHRlbnNpb25BUEkgPSByZXF1aXJlKFwiLi9FeHRlbnNpb25BUElcIik7XG5cbnZhciBDb29yZGluYXRlU3lzdGVtTWFuYWdlciA9IHJlcXVpcmUoXCIuL0Nvb3JkaW5hdGVTeXN0ZW1cIik7XG5cbnZhciBPcHRpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4vbW9kZWwvT3B0aW9uTWFuYWdlclwiKTtcblxudmFyIGJhY2t3YXJkQ29tcGF0ID0gcmVxdWlyZShcIi4vcHJlcHJvY2Vzc29yL2JhY2t3YXJkQ29tcGF0XCIpO1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbC9Db21wb25lbnRcIik7XG5cbnZhciBTZXJpZXNNb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsL1Nlcmllc1wiKTtcblxudmFyIENvbXBvbmVudFZpZXcgPSByZXF1aXJlKFwiLi92aWV3L0NvbXBvbmVudFwiKTtcblxudmFyIENoYXJ0VmlldyA9IHJlcXVpcmUoXCIuL3ZpZXcvQ2hhcnRcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIF90aHJvdHRsZSA9IHJlcXVpcmUoXCIuL3V0aWwvdGhyb3R0bGVcIik7XG5cbnZhciB0aHJvdHRsZSA9IF90aHJvdHRsZS50aHJvdHRsZTtcblxudmFyIHNlcmllc0NvbG9yID0gcmVxdWlyZShcIi4vdmlzdWFsL3Nlcmllc0NvbG9yXCIpO1xuXG52YXIgbG9hZGluZ0RlZmF1bHQgPSByZXF1aXJlKFwiLi9sb2FkaW5nL2RlZmF1bHRcIik7XG5cbi8qIVxuICogRUNoYXJ0cywgYSBqYXZhc2NyaXB0IGludGVyYWN0aXZlIGNoYXJ0IGxpYnJhcnkuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBCYWlkdSBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvZWNoYXJ0cy9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuICovXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIHBhcnNlQ2xhc3NUeXBlID0gQ29tcG9uZW50TW9kZWwucGFyc2VDbGFzc1R5cGU7XG52YXIgdmVyc2lvbiA9ICczLjguNSc7XG52YXIgZGVwZW5kZW5jaWVzID0ge1xuICB6cmVuZGVyOiAnMy43LjQnXG59O1xudmFyIFBSSU9SSVRZX1BST0NFU1NPUl9GSUxURVIgPSAxMDAwO1xudmFyIFBSSU9SSVRZX1BST0NFU1NPUl9TVEFUSVNUSUMgPSA1MDAwO1xudmFyIFBSSU9SSVRZX1ZJU1VBTF9MQVlPVVQgPSAxMDAwO1xudmFyIFBSSU9SSVRZX1ZJU1VBTF9HTE9CQUwgPSAyMDAwO1xudmFyIFBSSU9SSVRZX1ZJU1VBTF9DSEFSVCA9IDMwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0NPTVBPTkVOVCA9IDQwMDA7IC8vIEZJWE1FXG4vLyBuZWNlc3Nhcnk/XG5cbnZhciBQUklPUklUWV9WSVNVQUxfQlJVU0ggPSA1MDAwO1xudmFyIFBSSU9SSVRZID0ge1xuICBQUk9DRVNTT1I6IHtcbiAgICBGSUxURVI6IFBSSU9SSVRZX1BST0NFU1NPUl9GSUxURVIsXG4gICAgU1RBVElTVElDOiBQUklPUklUWV9QUk9DRVNTT1JfU1RBVElTVElDXG4gIH0sXG4gIFZJU1VBTDoge1xuICAgIExBWU9VVDogUFJJT1JJVFlfVklTVUFMX0xBWU9VVCxcbiAgICBHTE9CQUw6IFBSSU9SSVRZX1ZJU1VBTF9HTE9CQUwsXG4gICAgQ0hBUlQ6IFBSSU9SSVRZX1ZJU1VBTF9DSEFSVCxcbiAgICBDT01QT05FTlQ6IFBSSU9SSVRZX1ZJU1VBTF9DT01QT05FTlQsXG4gICAgQlJVU0g6IFBSSU9SSVRZX1ZJU1VBTF9CUlVTSFxuICB9XG59OyAvLyBNYWluIHByb2Nlc3MgaGF2ZSB0aHJlZSBlbnRyaWVzOiBgc2V0T3B0aW9uYCwgYGRpc3BhdGNoQWN0aW9uYCBhbmQgYHJlc2l6ZWAsXG4vLyB3aGVyZSB0aGV5IG11c3Qgbm90IGJlIGludm9rZWQgbmVzdGVkbHksIGV4Y2VwdCB0aGUgb25seSBjYXNlOiBpbnZva2Vcbi8vIGRpc3BhdGNoQWN0aW9uIHdpdGggdXBkYXRlTWV0aG9kIFwibm9uZVwiIGluIG1haW4gcHJvY2Vzcy5cbi8vIFRoaXMgZmxhZyBpcyB1c2VkIHRvIGNhcnJ5IG91dCB0aGlzIHJ1bGUuXG4vLyBBbGwgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkIG91dCBzaWRlIG1haW4gcHJvY2VzcyAoaS5lLiB3aGVuICF0aGlzW0lOX01BSU5fUFJPQ0VTU10pLlxuXG52YXIgSU5fTUFJTl9QUk9DRVNTID0gJ19fZmxhZ0luTWFpblByb2Nlc3MnO1xudmFyIEhBU19HUkFESUVOVF9PUl9QQVRURVJOX0JHID0gJ19faGFzR3JhZGllbnRPclBhdHRlcm5CZyc7XG52YXIgT1BUSU9OX1VQREFURUQgPSAnX19vcHRpb25VcGRhdGVkJztcbnZhciBBQ1RJT05fUkVHID0gL15bYS16QS1aMC05X10rJC87XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZShtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAvLyBFdmVudCBuYW1lIGlzIGFsbCBsb3dlcmNhc2VcbiAgICBldmVudE5hbWUgPSBldmVudE5hbWUgJiYgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgRXZlbnRmdWwucHJvdG90eXBlW21ldGhvZF0uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIsIGNvbnRleHQpO1xuICB9O1xufVxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHN+TWVzc2FnZUNlbnRlclxuICovXG5cblxuZnVuY3Rpb24gTWVzc2FnZUNlbnRlcigpIHtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbn1cblxuTWVzc2FnZUNlbnRlci5wcm90b3R5cGUub24gPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uJyk7XG5NZXNzYWdlQ2VudGVyLnByb3RvdHlwZS5vZmYgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29mZicpO1xuTWVzc2FnZUNlbnRlci5wcm90b3R5cGUub25lID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbmUnKTtcbnpyVXRpbC5taXhpbihNZXNzYWdlQ2VudGVyLCBFdmVudGZ1bCk7XG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0c35FQ2hhcnRzXG4gKi9cblxuZnVuY3Rpb24gRUNoYXJ0cyhkb20sIHRoZW1lLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBHZXQgdGhlbWUgYnkgbmFtZVxuXG4gIGlmICh0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhlbWUgPSB0aGVtZVN0b3JhZ2VbdGhlbWVdO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuXG4gIHRoaXMuaWQ7XG4gIC8qKlxuICAgKiBHcm91cCBpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmdyb3VwO1xuICAvKipcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9kb20gPSBkb207XG4gIHZhciBkZWZhdWx0UmVuZGVyZXIgPSAnY2FudmFzJztcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgenIgPSB0aGlzLl96ciA9IHpyZW5kZXIuaW5pdChkb20sIHtcbiAgICByZW5kZXJlcjogb3B0cy5yZW5kZXJlciB8fCBkZWZhdWx0UmVuZGVyZXIsXG4gICAgZGV2aWNlUGl4ZWxSYXRpbzogb3B0cy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgIHdpZHRoOiBvcHRzLndpZHRoLFxuICAgIGhlaWdodDogb3B0cy5oZWlnaHRcbiAgfSk7XG4gIC8qKlxuICAgKiBFeHBlY3QgNjAgcGZzLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3Rocm90dGxlZFpyRmx1c2ggPSB0aHJvdHRsZSh6clV0aWwuYmluZCh6ci5mbHVzaCwgenIpLCAxNyk7XG4gIHZhciB0aGVtZSA9IHpyVXRpbC5jbG9uZSh0aGVtZSk7XG4gIHRoZW1lICYmIGJhY2t3YXJkQ29tcGF0KHRoZW1lLCB0cnVlKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3RoZW1lID0gdGhlbWU7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9jaGFydHNWaWV3cyA9IFtdO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY2hhcnRzTWFwID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY29tcG9uZW50c1ZpZXdzID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY29tcG9uZW50c01hcCA9IHt9O1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0Nvb3JkaW5hdGVTeXN0ZW19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2Nvb3JkU3lzTWdyID0gbmV3IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyKCk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9hcGkgPSBjcmVhdGVFeHRlbnNpb25BUEkodGhpcyk7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHN+TWVzc2FnZUNlbnRlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fbWVzc2FnZUNlbnRlciA9IG5ldyBNZXNzYWdlQ2VudGVyKCk7IC8vIEluaXQgbW91c2UgZXZlbnRzXG5cbiAgdGhpcy5faW5pdEV2ZW50cygpOyAvLyBJbiBjYXNlIHNvbWUgcGVvcGxlIHdyaXRlIGB3aW5kb3cub25yZXNpemUgPSBjaGFydC5yZXNpemVgXG5cblxuICB0aGlzLnJlc2l6ZSA9IHpyVXRpbC5iaW5kKHRoaXMucmVzaXplLCB0aGlzKTsgLy8gQ2FuJ3QgZGlzcGF0Y2ggYWN0aW9uIGR1cmluZyByZW5kZXJpbmcgcHJvY2VkdXJlXG5cbiAgdGhpcy5fcGVuZGluZ0FjdGlvbnMgPSBbXTsgLy8gU29ydCBvbiBkZW1hbmRcblxuICBmdW5jdGlvbiBwcmlvcml0eVNvcnRGdW5jKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wcmlvIC0gYi5wcmlvO1xuICB9XG5cbiAgdGltc29ydCh2aXN1YWxGdW5jcywgcHJpb3JpdHlTb3J0RnVuYyk7XG4gIHRpbXNvcnQoZGF0YVByb2Nlc3NvckZ1bmNzLCBwcmlvcml0eVNvcnRGdW5jKTtcbiAgenIuYW5pbWF0aW9uLm9uKCdmcmFtZScsIHRoaXMuX29uZnJhbWUsIHRoaXMpOyAvLyBFQ2hhcnRzIGluc3RhbmNlIGNhbiBiZSB1c2VkIGFzIHZhbHVlLlxuXG4gIHpyVXRpbC5zZXRBc1ByaW1pdGl2ZSh0aGlzKTtcbn1cblxudmFyIGVjaGFydHNQcm90byA9IEVDaGFydHMucHJvdG90eXBlO1xuXG5lY2hhcnRzUHJvdG8uX29uZnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIExhenkgdXBkYXRlXG4gIGlmICh0aGlzW09QVElPTl9VUERBVEVEXSkge1xuICAgIHZhciBzaWxlbnQgPSB0aGlzW09QVElPTl9VUERBVEVEXS5zaWxlbnQ7XG4gICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gdHJ1ZTtcbiAgICB1cGRhdGVNZXRob2RzLnByZXBhcmVBbmRVcGRhdGUuY2FsbCh0aGlzKTtcbiAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcbiAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IGZhbHNlO1xuICAgIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICB9XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXREb20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9kb207XG59O1xuLyoqXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlcn5aUmVuZGVyfVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldFpyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fenI7XG59O1xuLyoqXG4gKiBVc2FnZTpcbiAqIGNoYXJ0LnNldE9wdGlvbihvcHRpb24sIG5vdE1lcmdlLCBsYXp5VXBkYXRlKTtcbiAqIGNoYXJ0LnNldE9wdGlvbihvcHRpb24sIHtcbiAqICAgICBub3RNZXJnZTogLi4uLFxuICogICAgIGxhenlVcGRhdGU6IC4uLixcbiAqICAgICBzaWxlbnQ6IC4uLlxuICogfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gW29wdHNdIG9wdHMgb3Igbm90TWVyZ2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLm5vdE1lcmdlPWZhbHNlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5sYXp5VXBkYXRlPWZhbHNlXSBVc2VmdWwgd2hlbiBzZXRPcHRpb24gZnJlcXVlbnRseS5cbiAqL1xuXG5cbmVjaGFydHNQcm90by5zZXRPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uLCBub3RNZXJnZSwgbGF6eVVwZGF0ZSkge1xuICB2YXIgc2lsZW50O1xuXG4gIGlmICh6clV0aWwuaXNPYmplY3Qobm90TWVyZ2UpKSB7XG4gICAgbGF6eVVwZGF0ZSA9IG5vdE1lcmdlLmxhenlVcGRhdGU7XG4gICAgc2lsZW50ID0gbm90TWVyZ2Uuc2lsZW50O1xuICAgIG5vdE1lcmdlID0gbm90TWVyZ2Uubm90TWVyZ2U7XG4gIH1cblxuICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuXG4gIGlmICghdGhpcy5fbW9kZWwgfHwgbm90TWVyZ2UpIHtcbiAgICB2YXIgb3B0aW9uTWFuYWdlciA9IG5ldyBPcHRpb25NYW5hZ2VyKHRoaXMuX2FwaSk7XG4gICAgdmFyIHRoZW1lID0gdGhpcy5fdGhlbWU7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbCA9IG5ldyBHbG9iYWxNb2RlbChudWxsLCBudWxsLCB0aGVtZSwgb3B0aW9uTWFuYWdlcik7XG4gICAgZWNNb2RlbC5pbml0KG51bGwsIG51bGwsIHRoZW1lLCBvcHRpb25NYW5hZ2VyKTtcbiAgfVxuXG4gIHRoaXMuX21vZGVsLnNldE9wdGlvbihvcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKTtcblxuICBpZiAobGF6eVVwZGF0ZSkge1xuICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0ge1xuICAgICAgc2lsZW50OiBzaWxlbnRcbiAgICB9O1xuICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZU1ldGhvZHMucHJlcGFyZUFuZFVwZGF0ZS5jYWxsKHRoaXMpOyAvLyBFbnN1cmUgenIgcmVmcmVzaCBzeWNocm9ub3VzbHksIGFuZCB0aGVuIHBpeGVsIGluIGNhbnZhcyBjYW4gYmVcbiAgICAvLyBmZXRjaGVkIGFmdGVyIGBzZXRPcHRpb25gLlxuXG4gICAgdGhpcy5fenIuZmx1c2goKTtcblxuICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0gZmFsc2U7XG4gICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG4gICAgZmx1c2hQZW5kaW5nQWN0aW9ucy5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gIH1cbn07XG4vKipcbiAqIEBERVBSRUNBVEVEXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uc2V0VGhlbWUgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUubG9nKCdFQ2hhcnRzI3NldFRoZW1lKCkgaXMgREVQUkVDQVRFRCBpbiBFQ2hhcnRzIDMuMCcpO1xufTtcbi8qKlxuICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fbW9kZWw7XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0T3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwuZ2V0T3B0aW9uKCk7XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl96ci5nZXRXaWR0aCgpO1xufTtcbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3pyLmdldEhlaWdodCgpO1xufTtcbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldERldmljZVBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl96ci5wYWludGVyLmRwciB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xufTtcbi8qKlxuICogR2V0IGNhbnZhcyB3aGljaCBoYXMgYWxsIHRoaW5nIHJlbmRlcmVkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRSZW5kZXJlZENhbnZhcyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnBpeGVsUmF0aW8gPSBvcHRzLnBpeGVsUmF0aW8gfHwgMTtcbiAgb3B0cy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRzLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLl9tb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICB2YXIgenIgPSB0aGlzLl96cjtcbiAgdmFyIGxpc3QgPSB6ci5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7IC8vIFN0b3AgYW5pbWF0aW9uc1xuXG4gIHpyVXRpbC5lYWNoKGxpc3QsIGZ1bmN0aW9uIChlbCkge1xuICAgIGVsLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gIH0pO1xuICByZXR1cm4genIucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyhvcHRzKTtcbn07XG4vKipcbiAqIEdldCBzdmcgZGF0YSB1cmxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRTdmdEYXRhVXJsID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIWVudi5zdmdTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgenIgPSB0aGlzLl96cjtcbiAgdmFyIGxpc3QgPSB6ci5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7IC8vIFN0b3AgYW5pbWF0aW9uc1xuXG4gIHpyVXRpbC5lYWNoKGxpc3QsIGZ1bmN0aW9uIChlbCkge1xuICAgIGVsLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gIH0pO1xuICByZXR1cm4genIucGFpbnRlci5wYXRoVG9TdmcoKTtcbn07XG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudHlwZT0ncG5nJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5waXhlbFJhdGlvPTFdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmV4Y2x1ZGVDb21wb25lbnRzXVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldERhdGFVUkwgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIGV4Y2x1ZGVDb21wb25lbnRzID0gb3B0cy5leGNsdWRlQ29tcG9uZW50cztcbiAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgdmFyIGV4Y2x1ZGVzQ29tcG9uZW50Vmlld3MgPSBbXTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBlYWNoKGV4Y2x1ZGVDb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogY29tcG9uZW50VHlwZVxuICAgIH0sIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHZhciB2aWV3ID0gc2VsZi5fY29tcG9uZW50c01hcFtjb21wb25lbnQuX192aWV3SWRdO1xuXG4gICAgICBpZiAoIXZpZXcuZ3JvdXAuaWdub3JlKSB7XG4gICAgICAgIGV4Y2x1ZGVzQ29tcG9uZW50Vmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgdmlldy5ncm91cC5pZ25vcmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgdmFyIHVybCA9IHRoaXMuX3pyLnBhaW50ZXIuZ2V0VHlwZSgpID09PSAnc3ZnJyA/IHRoaXMuZ2V0U3ZnRGF0YVVybCgpIDogdGhpcy5nZXRSZW5kZXJlZENhbnZhcyhvcHRzKS50b0RhdGFVUkwoJ2ltYWdlLycgKyAob3B0cyAmJiBvcHRzLnR5cGUgfHwgJ3BuZycpKTtcbiAgZWFjaChleGNsdWRlc0NvbXBvbmVudFZpZXdzLCBmdW5jdGlvbiAodmlldykge1xuICAgIHZpZXcuZ3JvdXAuaWdub3JlID0gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4gdXJsO1xufTtcbi8qKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50eXBlPSdwbmcnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnBpeGVsUmF0aW89MV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0Q29ubmVjdGVkRGF0YVVSTCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBncm91cElkID0gdGhpcy5ncm91cDtcbiAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbiAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgdmFyIE1BWF9OVU1CRVIgPSBJbmZpbml0eTtcblxuICBpZiAoY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdKSB7XG4gICAgdmFyIGxlZnQgPSBNQVhfTlVNQkVSO1xuICAgIHZhciB0b3AgPSBNQVhfTlVNQkVSO1xuICAgIHZhciByaWdodCA9IC1NQVhfTlVNQkVSO1xuICAgIHZhciBib3R0b20gPSAtTUFYX05VTUJFUjtcbiAgICB2YXIgY2FudmFzTGlzdCA9IFtdO1xuICAgIHZhciBkcHIgPSBvcHRzICYmIG9wdHMucGl4ZWxSYXRpbyB8fCAxO1xuICAgIHpyVXRpbC5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24gKGNoYXJ0LCBpZCkge1xuICAgICAgaWYgKGNoYXJ0Lmdyb3VwID09PSBncm91cElkKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBjaGFydC5nZXRSZW5kZXJlZENhbnZhcyh6clV0aWwuY2xvbmUob3B0cykpO1xuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gY2hhcnQuZ2V0RG9tKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxlZnQgPSBtYXRoTWluKGJvdW5kaW5nUmVjdC5sZWZ0LCBsZWZ0KTtcbiAgICAgICAgdG9wID0gbWF0aE1pbihib3VuZGluZ1JlY3QudG9wLCB0b3ApO1xuICAgICAgICByaWdodCA9IG1hdGhNYXgoYm91bmRpbmdSZWN0LnJpZ2h0LCByaWdodCk7XG4gICAgICAgIGJvdHRvbSA9IG1hdGhNYXgoYm91bmRpbmdSZWN0LmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgY2FudmFzTGlzdC5wdXNoKHtcbiAgICAgICAgICBkb206IGNhbnZhcyxcbiAgICAgICAgICBsZWZ0OiBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgICAgICB0b3A6IGJvdW5kaW5nUmVjdC50b3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGVmdCAqPSBkcHI7XG4gICAgdG9wICo9IGRwcjtcbiAgICByaWdodCAqPSBkcHI7XG4gICAgYm90dG9tICo9IGRwcjtcbiAgICB2YXIgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgdmFyIGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICB2YXIgdGFyZ2V0Q2FudmFzID0genJVdGlsLmNyZWF0ZUNhbnZhcygpO1xuICAgIHRhcmdldENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdmFyIHpyID0genJlbmRlci5pbml0KHRhcmdldENhbnZhcyk7XG4gICAgZWFjaChjYW52YXNMaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGltZyA9IG5ldyBncmFwaGljLkltYWdlKHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB4OiBpdGVtLmxlZnQgKiBkcHIgLSBsZWZ0LFxuICAgICAgICAgIHk6IGl0ZW0udG9wICogZHByIC0gdG9wLFxuICAgICAgICAgIGltYWdlOiBpdGVtLmRvbVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHpyLmFkZChpbWcpO1xuICAgIH0pO1xuICAgIHpyLnJlZnJlc2hJbW1lZGlhdGVseSgpO1xuICAgIHJldHVybiB0YXJnZXRDYW52YXMudG9EYXRhVVJMKCdpbWFnZS8nICsgKG9wdHMgJiYgb3B0cy50eXBlIHx8ICdwbmcnKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0YVVSTChvcHRzKTtcbiAgfVxufTtcbi8qKlxuICogQ29udmVydCBmcm9tIGxvZ2ljYWwgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gcGl4ZWwgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gKiBTZWUgQ29vcmRpbmF0ZVN5c3RlbSNjb252ZXJ0VG9QaXhlbC5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gKiAgICAgICAgICAgIGdlb0luZGV4IC8gZ2VvSWQsIGdlb05hbWUsXG4gKiAgICAgICAgICAgIGJtYXBJbmRleCAvIGJtYXBJZCAvIGJtYXBOYW1lLFxuICogICAgICAgICAgICB4QXhpc0luZGV4IC8geEF4aXNJZCAvIHhBeGlzTmFtZSxcbiAqICAgICAgICAgICAgeUF4aXNJbmRleCAvIHlBeGlzSWQgLyB5QXhpc05hbWUsXG4gKiAgICAgICAgICAgIGdyaWRJbmRleCAvIGdyaWRJZCAvIGdyaWROYW1lLFxuICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAqICAgICAgICB9XG4gKiBAcGFyYW0ge0FycmF5fG51bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fG51bWJlcn0gcmVzdWx0XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uY29udmVydFRvUGl4ZWwgPSB6clV0aWwuY3VycnkoZG9Db252ZXJ0UGl4ZWwsICdjb252ZXJ0VG9QaXhlbCcpO1xuLyoqXG4gKiBDb252ZXJ0IGZyb20gcGl4ZWwgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gbG9naWNhbCBjb29yZGluYXRlIHN5c3RlbS5cbiAqIFNlZSBDb29yZGluYXRlU3lzdGVtI2NvbnZlcnRGcm9tUGl4ZWwuXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICogICAgICAgICAgICBnZW9JbmRleCAvIGdlb0lkIC8gZ2VvTmFtZSxcbiAqICAgICAgICAgICAgYm1hcEluZGV4IC8gYm1hcElkIC8gYm1hcE5hbWUsXG4gKiAgICAgICAgICAgIHhBeGlzSW5kZXggLyB4QXhpc0lkIC8geEF4aXNOYW1lLFxuICogICAgICAgICAgICB5QXhpc0luZGV4IC8geUF4aXNJZCAvIHlBeGlzTmFtZVxuICogICAgICAgICAgICBncmlkSW5kZXggLyBncmlkSWQgLyBncmlkTmFtZSxcbiAqICAgICAgICAgICAgLi4uIChjYW4gYmUgZXh0ZW5kZWQpXG4gKiAgICAgICAgfVxuICogQHBhcmFtIHtBcnJheXxudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtBcnJheXxudW1iZXJ9IHJlc3VsdFxuICovXG5cbmVjaGFydHNQcm90by5jb252ZXJ0RnJvbVBpeGVsID0genJVdGlsLmN1cnJ5KGRvQ29udmVydFBpeGVsLCAnY29udmVydEZyb21QaXhlbCcpO1xuXG5mdW5jdGlvbiBkb0NvbnZlcnRQaXhlbChtZXRob2ROYW1lLCBmaW5kZXIsIHZhbHVlKSB7XG4gIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG5cbiAgdmFyIGNvb3JkU3lzTGlzdCA9IHRoaXMuX2Nvb3JkU3lzTWdyLmdldENvb3JkaW5hdGVTeXN0ZW1zKCk7XG5cbiAgdmFyIHJlc3VsdDtcbiAgZmluZGVyID0gbW9kZWxVdGlsLnBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZFN5c0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29vcmRTeXMgPSBjb29yZFN5c0xpc3RbaV07XG5cbiAgICBpZiAoY29vcmRTeXNbbWV0aG9kTmFtZV0gJiYgKHJlc3VsdCA9IGNvb3JkU3lzW21ldGhvZE5hbWVdKGVjTW9kZWwsIGZpbmRlciwgdmFsdWUpKSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBJcyB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGUgc3lzdGVtcyBvciBjb21wb25lbnRzIGNvbnRhaW4gdGhlIGdpdmVuIHBpeGVsIHBvaW50LlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdnZW8nLCBtZWFucyB7Z2VvSW5kZXg6IDB9LlxuICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gKiAgICAgICAge1xuICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcbiAqICAgICAgICAgICAgZ2VvSW5kZXggLyBnZW9JZCAvIGdlb05hbWUsXG4gKiAgICAgICAgICAgIGJtYXBJbmRleCAvIGJtYXBJZCAvIGJtYXBOYW1lLFxuICogICAgICAgICAgICB4QXhpc0luZGV4IC8geEF4aXNJZCAvIHhBeGlzTmFtZSxcbiAqICAgICAgICAgICAgeUF4aXNJbmRleCAvIHlBeGlzSWQgLyB5QXhpc05hbWUsXG4gKiAgICAgICAgICAgIGdyaWRJbmRleCAvIGdyaWRJZCAvIGdyaWROYW1lLFxuICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAqICAgICAgICB9XG4gKiBAcGFyYW0ge0FycmF5fG51bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHJlc3VsdFxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmNvbnRhaW5QaXhlbCA9IGZ1bmN0aW9uIChmaW5kZXIsIHZhbHVlKSB7XG4gIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gIHZhciByZXN1bHQ7XG4gIGZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIpO1xuICB6clV0aWwuZWFjaChmaW5kZXIsIGZ1bmN0aW9uIChtb2RlbHMsIGtleSkge1xuICAgIGtleS5pbmRleE9mKCdNb2RlbHMnKSA+PSAwICYmIHpyVXRpbC5lYWNoKG1vZGVscywgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICB2YXIgY29vcmRTeXMgPSBtb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMuY29udGFpblBvaW50KSB7XG4gICAgICAgIHJlc3VsdCB8PSAhIWNvb3JkU3lzLmNvbnRhaW5Qb2ludCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3Nlcmllc01vZGVscycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9jaGFydHNNYXBbbW9kZWwuX192aWV3SWRdO1xuXG4gICAgICAgIGlmICh2aWV3ICYmIHZpZXcuY29udGFpblBvaW50KSB7XG4gICAgICAgICAgcmVzdWx0IHw9IHZpZXcuY29udGFpblBvaW50KHZhbHVlLCBtb2RlbCk7XG4gICAgICAgIH0gZWxzZSB7fVxuICAgICAgfSBlbHNlIHt9XG4gICAgfSwgdGhpcyk7XG4gIH0sIHRoaXMpO1xuICByZXR1cm4gISFyZXN1bHQ7XG59O1xuLyoqXG4gKiBHZXQgdmlzdWFsIGZyb20gc2VyaWVzIG9yIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ3NlcmllcycsIG1lYW5zIHtzZXJpZXNJbmRleDogMH0uXG4gKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICogICAgICAgICAgICBkYXRhSW5kZXggLyBkYXRhSW5kZXhJbnNpZGVcbiAqICAgICAgICB9XG4gKiAgICAgICAgSWYgZGF0YUluZGV4IGlzIG5vdCBzcGVjaWZpZWQsIHNlcmllcyB2aXN1YWwgd2lsbCBiZSBmZXRjaGVkLFxuICogICAgICAgIGJ1dCBub3QgZGF0YSBpdGVtIHZpc3VhbC5cbiAqICAgICAgICBJZiBhbGwgb2Ygc2VyaWVzSW5kZXgsIHNlcmllc0lkLCBzZXJpZXNOYW1lIGFyZSBub3Qgc3BlY2lmaWVkLFxuICogICAgICAgIHZpc3VhbCB3aWxsIGJlIGZldGNoZWQgZnJvbSBmaXJzdCBzZXJpZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlzdWFsVHlwZSAnY29sb3InLCAnc3ltYm9sJywgJ3N5bWJvbFNpemUnXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0VmlzdWFsID0gZnVuY3Rpb24gKGZpbmRlciwgdmlzdWFsVHlwZSkge1xuICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICBmaW5kZXIgPSBtb2RlbFV0aWwucGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyLCB7XG4gICAgZGVmYXVsdE1haW5UeXBlOiAnc2VyaWVzJ1xuICB9KTtcbiAgdmFyIHNlcmllc01vZGVsID0gZmluZGVyLnNlcmllc01vZGVsO1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGRhdGFJbmRleEluc2lkZSA9IGZpbmRlci5oYXNPd25Qcm9wZXJ0eSgnZGF0YUluZGV4SW5zaWRlJykgPyBmaW5kZXIuZGF0YUluZGV4SW5zaWRlIDogZmluZGVyLmhhc093blByb3BlcnR5KCdkYXRhSW5kZXgnKSA/IGRhdGEuaW5kZXhPZlJhd0luZGV4KGZpbmRlci5kYXRhSW5kZXgpIDogbnVsbDtcbiAgcmV0dXJuIGRhdGFJbmRleEluc2lkZSAhPSBudWxsID8gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleEluc2lkZSwgdmlzdWFsVHlwZSkgOiBkYXRhLmdldFZpc3VhbCh2aXN1YWxUeXBlKTtcbn07XG4vKipcbiAqIEdldCB2aWV3IG9mIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50IG1vZGVsXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IGNvbXBvbmVudE1vZGVsXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudH1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRWaWV3T2ZDb21wb25lbnRNb2RlbCA9IGZ1bmN0aW9uIChjb21wb25lbnRNb2RlbCkge1xuICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcFtjb21wb25lbnRNb2RlbC5fX3ZpZXdJZF07XG59O1xuLyoqXG4gKiBHZXQgdmlldyBvZiBjb3JyZXNwb25kaW5nIHNlcmllcyBtb2RlbFxuICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvdmlldy9DaGFydH1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRWaWV3T2ZTZXJpZXNNb2RlbCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gdGhpcy5fY2hhcnRzTWFwW3Nlcmllc01vZGVsLl9fdmlld0lkXTtcbn07XG5cbnZhciB1cGRhdGVNZXRob2RzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAvLyBjb25zb2xlLnByb2ZpbGUgJiYgY29uc29sZS5wcm9maWxlKCd1cGRhdGUnKTtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgdmFyIGNvb3JkU3lzTWdyID0gdGhpcy5fY29vcmRTeXNNZ3I7XG4gICAgdmFyIHpyID0gdGhpcy5fenI7IC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG5cbiAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZpeG1lIEZpcnN0IHRpbWUgdXBkYXRlID9cblxuXG4gICAgZWNNb2RlbC5yZXN0b3JlRGF0YSgpOyAvLyBUT0RPXG4gICAgLy8gU2F2ZSB0b3RhbCBlY01vZGVsIGhlcmUgZm9yIHVuZG8vcmVkbyAoYWZ0ZXIgcmVzdG9yaW5nIGRhdGEgYW5kIGJlZm9yZSBwcm9jZXNzaW5nIGRhdGEpLlxuICAgIC8vIFVuZG8gKHJlc3RvcmF0aW9uIG9mIHRvdGFsIGVjTW9kZWwpIGNhbiBiZSBjYXJyaWVkIG91dCBpbiAnYWN0aW9uJyBvciBvdXRzaWRlIEFQSSBjYWxsLlxuICAgIC8vIENyZWF0ZSBuZXcgY29vcmRpbmF0ZSBzeXN0ZW0gZWFjaCB1cGRhdGVcbiAgICAvLyBJbiBMaW5lVmlldyBtYXkgc2F2ZSB0aGUgb2xkIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCB1c2UgaXQgdG8gZ2V0IHRoZSBvcmlnbmFsIHBvaW50XG5cbiAgICBjb29yZFN5c01nci5jcmVhdGUodGhpcy5fbW9kZWwsIHRoaXMuX2FwaSk7XG4gICAgcHJvY2Vzc0RhdGEuY2FsbCh0aGlzLCBlY01vZGVsLCBhcGkpO1xuICAgIHN0YWNrU2VyaWVzRGF0YS5jYWxsKHRoaXMsIGVjTW9kZWwpO1xuICAgIGNvb3JkU3lzTWdyLnVwZGF0ZShlY01vZGVsLCBhcGkpO1xuICAgIGRvVmlzdWFsRW5jb2RpbmcuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgICBkb1JlbmRlci5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQpOyAvLyBTZXQgYmFja2dyb3VuZFxuXG4gICAgdmFyIGJhY2tncm91bmRDb2xvciA9IGVjTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKSB8fCAndHJhbnNwYXJlbnQnO1xuICAgIHZhciBwYWludGVyID0genIucGFpbnRlcjsgLy8gVE9ETyBhbGwgdXNlIGNsZWFyQ29sb3IgP1xuXG4gICAgaWYgKHBhaW50ZXIuaXNTaW5nbGVDYW52YXMgJiYgcGFpbnRlci5pc1NpbmdsZUNhbnZhcygpKSB7XG4gICAgICB6ci5jb25maWdMYXllcigwLCB7XG4gICAgICAgIGNsZWFyQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIElFOFxuICAgICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IGNvbG9yVG9vbC5wYXJzZShiYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvclRvb2wuc3RyaW5naWZ5KGNvbG9yQXJyLCAncmdiJyk7XG5cbiAgICAgICAgaWYgKGNvbG9yQXJyWzNdID09PSAwKSB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYmFja2dyb3VuZENvbG9yLmNvbG9yU3RvcHMgfHwgYmFja2dyb3VuZENvbG9yLmltYWdlKSB7XG4gICAgICAgIC8vIEdyYWRpZW50IGJhY2tncm91bmRcbiAgICAgICAgLy8gRklYTUUgRml4ZWQgbGF5ZXLvvJ9cbiAgICAgICAgenIuY29uZmlnTGF5ZXIoMCwge1xuICAgICAgICAgIGNsZWFyQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1tIQVNfR1JBRElFTlRfT1JfUEFUVEVSTl9CR10gPSB0cnVlO1xuICAgICAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpc1tIQVNfR1JBRElFTlRfT1JfUEFUVEVSTl9CR10pIHtcbiAgICAgICAgICB6ci5jb25maWdMYXllcigwLCB7XG4gICAgICAgICAgICBjbGVhckNvbG9yOiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW0hBU19HUkFESUVOVF9PUl9QQVRURVJOX0JHXSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlYWNoKHBvc3RVcGRhdGVGdW5jcywgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgIGZ1bmMoZWNNb2RlbCwgYXBpKTtcbiAgICB9KTsgLy8gY29uc29sZS5wcm9maWxlICYmIGNvbnNvbGUucHJvZmlsZUVuZCgndXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVWaWV3OiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7IC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG5cbiAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY2xlYXJBbGxWaXN1YWwoKTtcbiAgICB9KTtcbiAgICBkb1Zpc3VhbEVuY29kaW5nLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gICAgaW52b2tlVXBkYXRlTWV0aG9kLmNhbGwodGhpcywgJ3VwZGF0ZVZpZXcnLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVZpc3VhbDogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsOyAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuXG4gICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNsZWFyQWxsVmlzdWFsKCk7XG4gICAgfSk7XG4gICAgZG9WaXN1YWxFbmNvZGluZy5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQsIHRydWUpO1xuICAgIGludm9rZVVwZGF0ZU1ldGhvZC5jYWxsKHRoaXMsICd1cGRhdGVWaXN1YWwnLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUxheW91dDogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsOyAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuXG4gICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9MYXlvdXQuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgICBpbnZva2VVcGRhdGVNZXRob2QuY2FsbCh0aGlzLCAndXBkYXRlTGF5b3V0JywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcmVwYXJlQW5kVXBkYXRlOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgcHJlcGFyZVZpZXcuY2FsbCh0aGlzLCAnY29tcG9uZW50JywgZWNNb2RlbCk7XG4gICAgcHJlcGFyZVZpZXcuY2FsbCh0aGlzLCAnY2hhcnQnLCBlY01vZGVsKTtcbiAgICB1cGRhdGVNZXRob2RzLnVwZGF0ZS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICB9XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGx5KGVjSW5zLCBtZXRob2QsIHBheWxvYWQsIG1haW5UeXBlLCBzdWJUeXBlKSB7XG4gIHZhciBlY01vZGVsID0gZWNJbnMuX21vZGVsOyAvLyBicm9hZGNhc3RcblxuICBpZiAoIW1haW5UeXBlKSB7XG4gICAgZWFjaChlY0lucy5fY29tcG9uZW50c1ZpZXdzLmNvbmNhdChlY0lucy5fY2hhcnRzVmlld3MpLCBjYWxsVmlldyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHF1ZXJ5ID0ge307XG4gIHF1ZXJ5W21haW5UeXBlICsgJ0lkJ10gPSBwYXlsb2FkW21haW5UeXBlICsgJ0lkJ107XG4gIHF1ZXJ5W21haW5UeXBlICsgJ0luZGV4J10gPSBwYXlsb2FkW21haW5UeXBlICsgJ0luZGV4J107XG4gIHF1ZXJ5W21haW5UeXBlICsgJ05hbWUnXSA9IHBheWxvYWRbbWFpblR5cGUgKyAnTmFtZSddO1xuICB2YXIgY29uZGl0aW9uID0ge1xuICAgIG1haW5UeXBlOiBtYWluVHlwZSxcbiAgICBxdWVyeTogcXVlcnlcbiAgfTtcbiAgc3ViVHlwZSAmJiAoY29uZGl0aW9uLnN1YlR5cGUgPSBzdWJUeXBlKTsgLy8gc3ViVHlwZSBtYXkgYmUgJycgYnkgcGFyc2VDbGFzc1R5cGU7XG4gIC8vIElmIGRpc3BhdGNoQWN0aW9uIGJlZm9yZSBzZXRPcHRpb24sIGRvIG5vdGhpbmcuXG5cbiAgZWNNb2RlbCAmJiBlY01vZGVsLmVhY2hDb21wb25lbnQoY29uZGl0aW9uLCBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7XG4gICAgY2FsbFZpZXcoZWNJbnNbbWFpblR5cGUgPT09ICdzZXJpZXMnID8gJ19jaGFydHNNYXAnIDogJ19jb21wb25lbnRzTWFwJ11bbW9kZWwuX192aWV3SWRdKTtcbiAgfSwgZWNJbnMpO1xuXG4gIGZ1bmN0aW9uIGNhbGxWaWV3KHZpZXcpIHtcbiAgICB2aWV3ICYmIHZpZXcuX19hbGl2ZSAmJiB2aWV3W21ldGhvZF0gJiYgdmlld1ttZXRob2RdKHZpZXcuX19tb2RlbCwgZWNNb2RlbCwgZWNJbnMuX2FwaSwgcGF5bG9hZCk7XG4gIH1cbn1cbi8qKlxuICogUmVzaXplIHRoZSBjaGFydFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2lsZW50PWZhbHNlXVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG5cbiAgdGhpcy5fenIucmVzaXplKG9wdHMpO1xuXG4gIHZhciBvcHRpb25DaGFuZ2VkID0gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwucmVzZXRPcHRpb24oJ21lZGlhJyk7XG5cbiAgdmFyIHVwZGF0ZU1ldGhvZCA9IG9wdGlvbkNoYW5nZWQgPyAncHJlcGFyZUFuZFVwZGF0ZScgOiAndXBkYXRlJztcbiAgdXBkYXRlTWV0aG9kc1t1cGRhdGVNZXRob2RdLmNhbGwodGhpcyk7IC8vIFJlc2l6ZSBsb2FkaW5nIGVmZmVjdFxuXG4gIHRoaXMuX2xvYWRpbmdGWCAmJiB0aGlzLl9sb2FkaW5nRlgucmVzaXplKCk7XG4gIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICB2YXIgc2lsZW50ID0gb3B0cyAmJiBvcHRzLnNpbGVudDtcbiAgZmx1c2hQZW5kaW5nQWN0aW9ucy5jYWxsKHRoaXMsIHNpbGVudCk7XG4gIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBzaWxlbnQpO1xufTtcbi8qKlxuICogU2hvdyBsb2FkaW5nIGVmZmVjdFxuICogQHBhcmFtICB7c3RyaW5nfSBbbmFtZT0nZGVmYXVsdCddXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtjZmddXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uc2hvd0xvYWRpbmcgPSBmdW5jdGlvbiAobmFtZSwgY2ZnKSB7XG4gIGlmICh6clV0aWwuaXNPYmplY3QobmFtZSkpIHtcbiAgICBjZmcgPSBuYW1lO1xuICAgIG5hbWUgPSAnJztcbiAgfVxuXG4gIG5hbWUgPSBuYW1lIHx8ICdkZWZhdWx0JztcbiAgdGhpcy5oaWRlTG9hZGluZygpO1xuXG4gIGlmICghbG9hZGluZ0VmZmVjdHNbbmFtZV0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZWwgPSBsb2FkaW5nRWZmZWN0c1tuYW1lXSh0aGlzLl9hcGksIGNmZyk7XG4gIHZhciB6ciA9IHRoaXMuX3pyO1xuICB0aGlzLl9sb2FkaW5nRlggPSBlbDtcbiAgenIuYWRkKGVsKTtcbn07XG4vKipcbiAqIEhpZGUgbG9hZGluZyBlZmZlY3RcbiAqL1xuXG5cbmVjaGFydHNQcm90by5oaWRlTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fbG9hZGluZ0ZYICYmIHRoaXMuX3pyLnJlbW92ZSh0aGlzLl9sb2FkaW5nRlgpO1xuICB0aGlzLl9sb2FkaW5nRlggPSBudWxsO1xufTtcbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50T2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8ubWFrZUFjdGlvbkZyb21FdmVudCA9IGZ1bmN0aW9uIChldmVudE9iaikge1xuICB2YXIgcGF5bG9hZCA9IHpyVXRpbC5leHRlbmQoe30sIGV2ZW50T2JqKTtcbiAgcGF5bG9hZC50eXBlID0gZXZlbnRBY3Rpb25NYXBbZXZlbnRPYmoudHlwZV07XG4gIHJldHVybiBwYXlsb2FkO1xufTtcbi8qKlxuICogQHB1YmlsY1xuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bG9hZC50eXBlXSBBY3Rpb24gdHlwZVxuICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gW29wdF0gSWYgcGFzcyBib29sZWFuLCBtZWFucyBvcHQuc2lsZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuc2lsZW50PWZhbHNlXSBXaGV0aGVyIHRyaWdnZXIgZXZlbnRzLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0LmZsdXNoPXVuZGVmaW5lZF1cbiAqICAgICAgICAgICAgICAgICAgdHJ1ZTogRmx1c2ggaW1tZWRpYXRlbHksIGFuZCB0aGVuIHBpeGVsIGluIGNhbnZhcyBjYW4gYmUgZmV0Y2hlZFxuICogICAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlbHkuIENhdXRpb246IGl0IG1pZ2h0IGFmZmVjdCBwZXJmb3JtYW5jZS5cbiAqICAgICAgICAgICAgICAgICAgZmFsc2U6IE5vdCBub3QgZmx1c2guXG4gKiAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDogQXV0byBkZWNpZGUgd2hldGhlciBwZXJmb3JtIGZsdXNoLlxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmRpc3BhdGNoQWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQsIG9wdCkge1xuICBpZiAoIXpyVXRpbC5pc09iamVjdChvcHQpKSB7XG4gICAgb3B0ID0ge1xuICAgICAgc2lsZW50OiAhIW9wdFxuICAgIH07XG4gIH1cblxuICBpZiAoIWFjdGlvbnNbcGF5bG9hZC50eXBlXSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBBdm9pZCBkaXNwYXRjaCBhY3Rpb24gYmVmb3JlIHNldE9wdGlvbi4gRXNwZWNpYWxseSBpbiBgY29ubmVjdGAuXG5cblxuICBpZiAoIXRoaXMuX21vZGVsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE1heSBkaXNwYXRjaEFjdGlvbiBpbiByZW5kZXJpbmcgcHJvY2VkdXJlXG5cblxuICBpZiAodGhpc1tJTl9NQUlOX1BST0NFU1NdKSB7XG4gICAgdGhpcy5fcGVuZGluZ0FjdGlvbnMucHVzaChwYXlsb2FkKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGRvRGlzcGF0Y2hBY3Rpb24uY2FsbCh0aGlzLCBwYXlsb2FkLCBvcHQuc2lsZW50KTtcblxuICBpZiAob3B0LmZsdXNoKSB7XG4gICAgdGhpcy5fenIuZmx1c2godHJ1ZSk7XG4gIH0gZWxzZSBpZiAob3B0LmZsdXNoICE9PSBmYWxzZSAmJiBlbnYuYnJvd3Nlci53ZUNoYXQpIHtcbiAgICAvLyBJbiBXZUNoYXQgZW1iZWRlZCBicm93c2VyLCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhbmQgYHNldEludGVydmFsYFxuICAgIC8vIGhhbmcgd2hlbiBzbGlkaW5nIHBhZ2UgKG9uIHRvdWNoIGV2ZW50KSwgd2hpY2ggY2F1c2UgdGhhdCB6ciBkb2VzIG5vdFxuICAgIC8vIHJlZnJlc2ggdXRpbCB1c2VyIGludGVyYWN0aW9uIGZpbmlzaGVkLCB3aGljaCBpcyBub3QgZXhwZWN0ZWQuXG4gICAgLy8gQnV0IGBkaXNwYXRjaEFjdGlvbmAgbWF5IGJlIGNhbGxlZCB0b28gZnJlcXVlbnRseSB3aGVuIHBhbiBvbiB0b3VjaFxuICAgIC8vIHNjcmVlbiwgd2hpY2ggaW1wYWN0cyBwZXJmb3JtYW5jZSBpZiBkbyBub3QgdGhyb3R0bGUgdGhlbS5cbiAgICB0aGlzLl90aHJvdHRsZWRackZsdXNoKCk7XG4gIH1cblxuICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgb3B0LnNpbGVudCk7XG4gIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBvcHQuc2lsZW50KTtcbn07XG5cbmZ1bmN0aW9uIGRvRGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCwgc2lsZW50KSB7XG4gIHZhciBwYXlsb2FkVHlwZSA9IHBheWxvYWQudHlwZTtcbiAgdmFyIGVzY2FwZUNvbm5lY3QgPSBwYXlsb2FkLmVzY2FwZUNvbm5lY3Q7XG4gIHZhciBhY3Rpb25XcmFwID0gYWN0aW9uc1twYXlsb2FkVHlwZV07XG4gIHZhciBhY3Rpb25JbmZvID0gYWN0aW9uV3JhcC5hY3Rpb25JbmZvO1xuICB2YXIgY3B0VHlwZSA9IChhY3Rpb25JbmZvLnVwZGF0ZSB8fCAndXBkYXRlJykuc3BsaXQoJzonKTtcbiAgdmFyIHVwZGF0ZU1ldGhvZCA9IGNwdFR5cGUucG9wKCk7XG4gIGNwdFR5cGUgPSBjcHRUeXBlWzBdICE9IG51bGwgJiYgcGFyc2VDbGFzc1R5cGUoY3B0VHlwZVswXSk7XG4gIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG4gIHZhciBwYXlsb2FkcyA9IFtwYXlsb2FkXTtcbiAgdmFyIGJhdGNoZWQgPSBmYWxzZTsgLy8gQmF0Y2ggYWN0aW9uXG5cbiAgaWYgKHBheWxvYWQuYmF0Y2gpIHtcbiAgICBiYXRjaGVkID0gdHJ1ZTtcbiAgICBwYXlsb2FkcyA9IHpyVXRpbC5tYXAocGF5bG9hZC5iYXRjaCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGl0ZW0gPSB6clV0aWwuZGVmYXVsdHMoenJVdGlsLmV4dGVuZCh7fSwgaXRlbSksIHBheWxvYWQpO1xuICAgICAgaXRlbS5iYXRjaCA9IG51bGw7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBldmVudE9iakJhdGNoID0gW107XG4gIHZhciBldmVudE9iajtcbiAgdmFyIGlzSGlnaERvd24gPSBwYXlsb2FkVHlwZSA9PT0gJ2hpZ2hsaWdodCcgfHwgcGF5bG9hZFR5cGUgPT09ICdkb3ducGxheSc7XG4gIGVhY2gocGF5bG9hZHMsIGZ1bmN0aW9uIChiYXRjaEl0ZW0pIHtcbiAgICAvLyBBY3Rpb24gY2FuIHNwZWNpZnkgdGhlIGV2ZW50IGJ5IHJldHVybiBpdC5cbiAgICBldmVudE9iaiA9IGFjdGlvbldyYXAuYWN0aW9uKGJhdGNoSXRlbSwgdGhpcy5fbW9kZWwsIHRoaXMuX2FwaSk7IC8vIEVtaXQgZXZlbnQgb3V0c2lkZVxuXG4gICAgZXZlbnRPYmogPSBldmVudE9iaiB8fCB6clV0aWwuZXh0ZW5kKHt9LCBiYXRjaEl0ZW0pOyAvLyBDb252ZXJ0IHR5cGUgdG8gZXZlbnRUeXBlXG5cbiAgICBldmVudE9iai50eXBlID0gYWN0aW9uSW5mby5ldmVudCB8fCBldmVudE9iai50eXBlO1xuICAgIGV2ZW50T2JqQmF0Y2gucHVzaChldmVudE9iaik7IC8vIGxpZ2h0IHVwZGF0ZSBkb2VzIG5vdCBwZXJmb3JtIGRhdGEgcHJvY2VzcywgbGF5b3V0IGFuZCB2aXN1YWwuXG5cbiAgICBpZiAoaXNIaWdoRG93bikge1xuICAgICAgLy8gbWV0aG9kLCBwYXlsb2FkLCBtYWluVHlwZSwgc3ViVHlwZVxuICAgICAgdXBkYXRlRGlyZWN0bHkodGhpcywgdXBkYXRlTWV0aG9kLCBiYXRjaEl0ZW0sICdzZXJpZXMnKTtcbiAgICB9IGVsc2UgaWYgKGNwdFR5cGUpIHtcbiAgICAgIHVwZGF0ZURpcmVjdGx5KHRoaXMsIHVwZGF0ZU1ldGhvZCwgYmF0Y2hJdGVtLCBjcHRUeXBlLm1haW4sIGNwdFR5cGUuc3ViKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIGlmICh1cGRhdGVNZXRob2QgIT09ICdub25lJyAmJiAhaXNIaWdoRG93biAmJiAhY3B0VHlwZSkge1xuICAgIC8vIFN0aWxsIGRpcnR5XG4gICAgaWYgKHRoaXNbT1BUSU9OX1VQREFURURdKSB7XG4gICAgICAvLyBGSVhNRSBQYXNzIHBheWxvYWQgP1xuICAgICAgdXBkYXRlTWV0aG9kcy5wcmVwYXJlQW5kVXBkYXRlLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVNZXRob2RzW3VwZGF0ZU1ldGhvZF0uY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICB9XG4gIH0gLy8gRm9sbG93IHRoZSBydWxlIG9mIGFjdGlvbiBiYXRjaFxuXG5cbiAgaWYgKGJhdGNoZWQpIHtcbiAgICBldmVudE9iaiA9IHtcbiAgICAgIHR5cGU6IGFjdGlvbkluZm8uZXZlbnQgfHwgcGF5bG9hZFR5cGUsXG4gICAgICBlc2NhcGVDb25uZWN0OiBlc2NhcGVDb25uZWN0LFxuICAgICAgYmF0Y2g6IGV2ZW50T2JqQmF0Y2hcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGV2ZW50T2JqID0gZXZlbnRPYmpCYXRjaFswXTtcbiAgfVxuXG4gIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICAhc2lsZW50ICYmIHRoaXMuX21lc3NhZ2VDZW50ZXIudHJpZ2dlcihldmVudE9iai50eXBlLCBldmVudE9iaik7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGVuZGluZ0FjdGlvbnMoc2lsZW50KSB7XG4gIHZhciBwZW5kaW5nQWN0aW9ucyA9IHRoaXMuX3BlbmRpbmdBY3Rpb25zO1xuXG4gIHdoaWxlIChwZW5kaW5nQWN0aW9ucy5sZW5ndGgpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHBlbmRpbmdBY3Rpb25zLnNoaWZ0KCk7XG4gICAgZG9EaXNwYXRjaEFjdGlvbi5jYWxsKHRoaXMsIHBheWxvYWQsIHNpbGVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZWRFdmVudChzaWxlbnQpIHtcbiAgIXNpbGVudCAmJiB0aGlzLnRyaWdnZXIoJ3VwZGF0ZWQnKTtcbn1cbi8qKlxuICogUmVnaXN0ZXIgZXZlbnRcbiAqIEBtZXRob2RcbiAqL1xuXG5cbmVjaGFydHNQcm90by5vbiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb24nKTtcbmVjaGFydHNQcm90by5vZmYgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29mZicpO1xuZWNoYXJ0c1Byb3RvLm9uZSA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb25lJyk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGludm9rZVVwZGF0ZU1ldGhvZChtZXRob2ROYW1lLCBlY01vZGVsLCBwYXlsb2FkKSB7XG4gIHZhciBhcGkgPSB0aGlzLl9hcGk7IC8vIFVwZGF0ZSBhbGwgY29tcG9uZW50c1xuXG4gIGVhY2godGhpcy5fY29tcG9uZW50c1ZpZXdzLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgdmFyIGNvbXBvbmVudE1vZGVsID0gY29tcG9uZW50Ll9fbW9kZWw7XG4gICAgY29tcG9uZW50W21ldGhvZE5hbWVdKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIHVwZGF0ZVooY29tcG9uZW50TW9kZWwsIGNvbXBvbmVudCk7XG4gIH0sIHRoaXMpOyAvLyBVcGF0ZSBhbGwgY2hhcnRzXG5cbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaWR4KSB7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy5fY2hhcnRzTWFwW3Nlcmllc01vZGVsLl9fdmlld0lkXTtcbiAgICBjaGFydFttZXRob2ROYW1lXShzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB1cGRhdGVaKHNlcmllc01vZGVsLCBjaGFydCk7XG4gICAgdXBkYXRlUHJvZ3Jlc3NpdmVBbmRCbGVuZChzZXJpZXNNb2RlbCwgY2hhcnQpO1xuICB9LCB0aGlzKTsgLy8gSWYgdXNlIGhvdmVyIGxheWVyXG5cbiAgdXBkYXRlSG92ZXJMYXllclN0YXR1cyh0aGlzLl96ciwgZWNNb2RlbCk7IC8vIFBvc3QgcmVuZGVyXG5cbiAgZWFjaChwb3N0VXBkYXRlRnVuY3MsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgZnVuYyhlY01vZGVsLCBhcGkpO1xuICB9KTtcbn1cbi8qKlxuICogUHJlcGFyZSB2aWV3IGluc3RhbmNlcyBvZiBjaGFydHMgYW5kIGNvbXBvbmVudHNcbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHByZXBhcmVWaWV3KHR5cGUsIGVjTW9kZWwpIHtcbiAgdmFyIGlzQ29tcG9uZW50ID0gdHlwZSA9PT0gJ2NvbXBvbmVudCc7XG4gIHZhciB2aWV3TGlzdCA9IGlzQ29tcG9uZW50ID8gdGhpcy5fY29tcG9uZW50c1ZpZXdzIDogdGhpcy5fY2hhcnRzVmlld3M7XG4gIHZhciB2aWV3TWFwID0gaXNDb21wb25lbnQgPyB0aGlzLl9jb21wb25lbnRzTWFwIDogdGhpcy5fY2hhcnRzTWFwO1xuICB2YXIgenIgPSB0aGlzLl96cjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmlld0xpc3RbaV0uX19hbGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgZWNNb2RlbFtpc0NvbXBvbmVudCA/ICdlYWNoQ29tcG9uZW50JyA6ICdlYWNoU2VyaWVzJ10oZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIG1vZGVsKSB7XG4gICAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgICBpZiAoY29tcG9uZW50VHlwZSA9PT0gJ3NlcmllcycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbCA9IGNvbXBvbmVudFR5cGU7XG4gICAgfSAvLyBDb25zaWRlcjogaWQgc2FtZSBhbmQgdHlwZSBjaGFuZ2VkLlxuXG5cbiAgICB2YXIgdmlld0lkID0gJ19lY18nICsgbW9kZWwuaWQgKyAnXycgKyBtb2RlbC50eXBlO1xuICAgIHZhciB2aWV3ID0gdmlld01hcFt2aWV3SWRdO1xuXG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUobW9kZWwudHlwZSk7XG4gICAgICB2YXIgQ2xhenogPSBpc0NvbXBvbmVudCA/IENvbXBvbmVudFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIpIDogQ2hhcnRWaWV3LmdldENsYXNzKGNsYXNzVHlwZS5zdWIpO1xuXG4gICAgICBpZiAoQ2xhenopIHtcbiAgICAgICAgdmlldyA9IG5ldyBDbGF6eigpO1xuICAgICAgICB2aWV3LmluaXQoZWNNb2RlbCwgdGhpcy5fYXBpKTtcbiAgICAgICAgdmlld01hcFt2aWV3SWRdID0gdmlldztcbiAgICAgICAgdmlld0xpc3QucHVzaCh2aWV3KTtcbiAgICAgICAgenIuYWRkKHZpZXcuZ3JvdXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXJyb3JcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZGVsLl9fdmlld0lkID0gdmlldy5fX2lkID0gdmlld0lkO1xuICAgIHZpZXcuX19hbGl2ZSA9IHRydWU7XG4gICAgdmlldy5fX21vZGVsID0gbW9kZWw7XG4gICAgdmlldy5ncm91cC5fX2VjQ29tcG9uZW50SW5mbyA9IHtcbiAgICAgIG1haW5UeXBlOiBtb2RlbC5tYWluVHlwZSxcbiAgICAgIGluZGV4OiBtb2RlbC5jb21wb25lbnRJbmRleFxuICAgIH07XG4gIH0sIHRoaXMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld0xpc3QubGVuZ3RoOykge1xuICAgIHZhciB2aWV3ID0gdmlld0xpc3RbaV07XG5cbiAgICBpZiAoIXZpZXcuX19hbGl2ZSkge1xuICAgICAgenIucmVtb3ZlKHZpZXcuZ3JvdXApO1xuICAgICAgdmlldy5kaXNwb3NlKGVjTW9kZWwsIHRoaXMuX2FwaSk7XG4gICAgICB2aWV3TGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICBkZWxldGUgdmlld01hcFt2aWV3Ll9faWRdO1xuICAgICAgdmlldy5fX2lkID0gdmlldy5ncm91cC5fX2VjQ29tcG9uZW50SW5mbyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogUHJvY2Vzc29yIGRhdGEgaW4gZWFjaCBzZXJpZXNcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHByb2Nlc3NEYXRhKGVjTW9kZWwsIGFwaSkge1xuICBlYWNoKGRhdGFQcm9jZXNzb3JGdW5jcywgZnVuY3Rpb24gKHByb2Nlc3MpIHtcbiAgICBwcm9jZXNzLmZ1bmMoZWNNb2RlbCwgYXBpKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzdGFja1Nlcmllc0RhdGEoZWNNb2RlbCkge1xuICB2YXIgc3RhY2tlZERhdGFNYXAgPSB7fTtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICB2YXIgc3RhY2sgPSBzZXJpZXMuZ2V0KCdzdGFjaycpO1xuICAgIHZhciBkYXRhID0gc2VyaWVzLmdldERhdGEoKTtcblxuICAgIGlmIChzdGFjayAmJiBkYXRhLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgdmFyIHByZXZpb3VzU3RhY2sgPSBzdGFja2VkRGF0YU1hcFtzdGFja107IC8vIEF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZVxuXG4gICAgICBpZiAoc3RhY2tlZERhdGFNYXAuaGFzT3duUHJvcGVydHkoc3RhY2spICYmIHByZXZpb3VzU3RhY2spIHtcbiAgICAgICAgZGF0YS5zdGFja2VkT24gPSBwcmV2aW91c1N0YWNrO1xuICAgICAgfVxuXG4gICAgICBzdGFja2VkRGF0YU1hcFtzdGFja10gPSBkYXRhO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIExheW91dCBiZWZvcmUgZWFjaCBjaGFydCByZW5kZXIgdGhlcmUgc2VyaWVzLCBzcGVjaWFsIHZpc3VhbCBlbmNvZGluZyBzdGFnZVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZG9MYXlvdXQoZWNNb2RlbCwgcGF5bG9hZCkge1xuICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICBlYWNoKHZpc3VhbEZ1bmNzLCBmdW5jdGlvbiAodmlzdWFsKSB7XG4gICAgaWYgKHZpc3VhbC5pc0xheW91dCkge1xuICAgICAgdmlzdWFsLmZ1bmMoZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBFbmNvZGUgdmlzdWFsIGluZm9tYXRpb24gZnJvbSBkYXRhIGFmdGVyIGRhdGEgcHJvY2Vzc2luZ1xuICpcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleGNsdWRlc0xheW91dF1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBkb1Zpc3VhbEVuY29kaW5nKGVjTW9kZWwsIHBheWxvYWQsIGV4Y2x1ZGVzTGF5b3V0KSB7XG4gIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gIGVjTW9kZWwuY2xlYXJDb2xvclBhbGV0dGUoKTtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHNlcmllc01vZGVsLmNsZWFyQ29sb3JQYWxldHRlKCk7XG4gIH0pO1xuICBlYWNoKHZpc3VhbEZ1bmNzLCBmdW5jdGlvbiAodmlzdWFsKSB7XG4gICAgKCFleGNsdWRlc0xheW91dCB8fCAhdmlzdWFsLmlzTGF5b3V0KSAmJiB2aXN1YWwuZnVuYyhlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICB9KTtcbn1cbi8qKlxuICogUmVuZGVyIGVhY2ggY2hhcnQgYW5kIGNvbXBvbmVudFxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGRvUmVuZGVyKGVjTW9kZWwsIHBheWxvYWQpIHtcbiAgdmFyIGFwaSA9IHRoaXMuX2FwaTsgLy8gUmVuZGVyIGFsbCBjb21wb25lbnRzXG5cbiAgZWFjaCh0aGlzLl9jb21wb25lbnRzVmlld3MsIGZ1bmN0aW9uIChjb21wb25lbnRWaWV3KSB7XG4gICAgdmFyIGNvbXBvbmVudE1vZGVsID0gY29tcG9uZW50Vmlldy5fX21vZGVsO1xuICAgIGNvbXBvbmVudFZpZXcucmVuZGVyKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIHVwZGF0ZVooY29tcG9uZW50TW9kZWwsIGNvbXBvbmVudFZpZXcpO1xuICB9LCB0aGlzKTtcbiAgZWFjaCh0aGlzLl9jaGFydHNWaWV3cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgY2hhcnQuX19hbGl2ZSA9IGZhbHNlO1xuICB9LCB0aGlzKTsgLy8gUmVuZGVyIGFsbCBjaGFydHNcblxuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsLCBpZHgpIHtcbiAgICB2YXIgY2hhcnRWaWV3ID0gdGhpcy5fY2hhcnRzTWFwW3Nlcmllc01vZGVsLl9fdmlld0lkXTtcbiAgICBjaGFydFZpZXcuX19hbGl2ZSA9IHRydWU7XG4gICAgY2hhcnRWaWV3LnJlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICBjaGFydFZpZXcuZ3JvdXAuc2lsZW50ID0gISFzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuICAgIHVwZGF0ZVooc2VyaWVzTW9kZWwsIGNoYXJ0Vmlldyk7XG4gICAgdXBkYXRlUHJvZ3Jlc3NpdmVBbmRCbGVuZChzZXJpZXNNb2RlbCwgY2hhcnRWaWV3KTtcbiAgfSwgdGhpcyk7IC8vIElmIHVzZSBob3ZlciBsYXllclxuXG4gIHVwZGF0ZUhvdmVyTGF5ZXJTdGF0dXModGhpcy5fenIsIGVjTW9kZWwpOyAvLyBSZW1vdmUgZ3JvdXBzIG9mIHVucmVuZGVyZWQgY2hhcnRzXG5cbiAgZWFjaCh0aGlzLl9jaGFydHNWaWV3cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgaWYgKCFjaGFydC5fX2FsaXZlKSB7XG4gICAgICBjaGFydC5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xufVxuXG52YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnZ2xvYmFsb3V0JywgJ2NvbnRleHRtZW51J107XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZWNoYXJ0c1Byb3RvLl9pbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBlYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbiAoZXZlTmFtZSkge1xuICAgIHRoaXMuX3pyLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZ2V0TW9kZWwoKTtcbiAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgdmFyIHBhcmFtczsgLy8gbm8gZS50YXJnZXQgd2hlbiAnZ2xvYmFsb3V0Jy5cblxuICAgICAgaWYgKGV2ZU5hbWUgPT09ICdnbG9iYWxvdXQnKSB7XG4gICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgfSBlbHNlIGlmIChlbCAmJiBlbC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGF0YU1vZGVsID0gZWwuZGF0YU1vZGVsIHx8IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChlbC5zZXJpZXNJbmRleCk7XG4gICAgICAgIHBhcmFtcyA9IGRhdGFNb2RlbCAmJiBkYXRhTW9kZWwuZ2V0RGF0YVBhcmFtcyhlbC5kYXRhSW5kZXgsIGVsLmRhdGFUeXBlKSB8fCB7fTtcbiAgICAgIH0gLy8gSWYgZWxlbWVudCBoYXMgY3VzdG9tIGV2ZW50RGF0YSBvZiBjb21wb25lbnRzXG4gICAgICBlbHNlIGlmIChlbCAmJiBlbC5ldmVudERhdGEpIHtcbiAgICAgICAgICBwYXJhbXMgPSB6clV0aWwuZXh0ZW5kKHt9LCBlbC5ldmVudERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcbiAgICAgICAgcGFyYW1zLnR5cGUgPSBldmVOYW1lO1xuICAgICAgICB0aGlzLnRyaWdnZXIoZXZlTmFtZSwgcGFyYW1zKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfSwgdGhpcyk7XG4gIGVhY2goZXZlbnRBY3Rpb25NYXAsIGZ1bmN0aW9uIChhY3Rpb25UeXBlLCBldmVudFR5cGUpIHtcbiAgICB0aGlzLl9tZXNzYWdlQ2VudGVyLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB0aGlzLnRyaWdnZXIoZXZlbnRUeXBlLCBldmVudCk7XG4gICAgfSwgdGhpcyk7XG4gIH0sIHRoaXMpO1xufTtcbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5pc0Rpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XG59O1xuLyoqXG4gKiBDbGVhclxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNldE9wdGlvbih7XG4gICAgc2VyaWVzOiBbXVxuICB9LCB0cnVlKTtcbn07XG4vKipcbiAqIERpc3Bvc2UgaW5zdGFuY2VcbiAqL1xuXG5cbmVjaGFydHNQcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gIGVhY2godGhpcy5fY29tcG9uZW50c1ZpZXdzLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50LmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgfSk7XG4gIGVhY2godGhpcy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgIGNoYXJ0LmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgfSk7IC8vIERpc3Bvc2UgYWZ0ZXIgYWxsIHZpZXdzIGRpc3Bvc2VkXG5cbiAgdGhpcy5fenIuZGlzcG9zZSgpO1xuXG4gIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG59O1xuXG56clV0aWwubWl4aW4oRUNoYXJ0cywgRXZlbnRmdWwpO1xuXG5mdW5jdGlvbiB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHpyLCBlY01vZGVsKSB7XG4gIHZhciBzdG9yYWdlID0genIuc3RvcmFnZTtcbiAgdmFyIGVsQ291bnQgPSAwO1xuICBzdG9yYWdlLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgZWxDb3VudCsrO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGVsQ291bnQgPiBlY01vZGVsLmdldCgnaG92ZXJMYXllclRocmVzaG9sZCcpICYmICFlbnYubm9kZSkge1xuICAgIHN0b3JhZ2UudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgICAgZWwudXNlSG92ZXJMYXllciA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogVXBkYXRlIGNoYXJ0IHByb2dyZXNzaXZlIGFuZCBibGVuZC5cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gbW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnR8bW9kdWxlOmVjaGFydHMvdmlldy9DaGFydH0gdmlld1xuICovXG5cblxuZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3NpdmVBbmRCbGVuZChzZXJpZXNNb2RlbCwgY2hhcnRWaWV3KSB7XG4gIC8vIFByb2dyZXNzaXZlIGNvbmZpZ3VyYXRpb25cbiAgdmFyIGVsQ291bnQgPSAwO1xuICBjaGFydFZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLnR5cGUgIT09ICdncm91cCcgJiYgIWVsLmlnbm9yZSkge1xuICAgICAgZWxDb3VudCsrO1xuICAgIH1cbiAgfSk7XG4gIHZhciBmcmFtZURyYXdOdW0gPSArc2VyaWVzTW9kZWwuZ2V0KCdwcm9ncmVzc2l2ZScpO1xuICB2YXIgbmVlZFByb2dyZXNzaXZlID0gZWxDb3VudCA+IHNlcmllc01vZGVsLmdldCgncHJvZ3Jlc3NpdmVUaHJlc2hvbGQnKSAmJiBmcmFtZURyYXdOdW0gJiYgIWVudi5ub2RlO1xuXG4gIGlmIChuZWVkUHJvZ3Jlc3NpdmUpIHtcbiAgICBjaGFydFZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAvLyBGSVhNRSBtYXJrZXIgYW5kIG90aGVyIGNvbXBvbmVudHNcbiAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICBlbC5wcm9ncmVzc2l2ZSA9IG5lZWRQcm9ncmVzc2l2ZSA/IE1hdGguZmxvb3IoZWxDb3VudCsrIC8gZnJhbWVEcmF3TnVtKSA6IC0xO1xuXG4gICAgICAgIGlmIChuZWVkUHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0gLy8gQmxlbmQgY29uZmlncmF0aW9uXG5cblxuICB2YXIgYmxlbmRNb2RlID0gc2VyaWVzTW9kZWwuZ2V0KCdibGVuZE1vZGUnKSB8fCBudWxsO1xuICBjaGFydFZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgLy8gRklYTUUgbWFya2VyIGFuZCBvdGhlciBjb21wb25lbnRzXG4gICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICBlbC5zZXRTdHlsZSgnYmxlbmQnLCBibGVuZE1vZGUpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gbW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnR8bW9kdWxlOmVjaGFydHMvdmlldy9DaGFydH0gdmlld1xuICovXG5cblxuZnVuY3Rpb24gdXBkYXRlWihtb2RlbCwgdmlldykge1xuICB2YXIgeiA9IG1vZGVsLmdldCgneicpO1xuICB2YXIgemxldmVsID0gbW9kZWwuZ2V0KCd6bGV2ZWwnKTsgLy8gU2V0IHogYW5kIHpsZXZlbFxuXG4gIHZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLnR5cGUgIT09ICdncm91cCcpIHtcbiAgICAgIHogIT0gbnVsbCAmJiAoZWwueiA9IHopO1xuICAgICAgemxldmVsICE9IG51bGwgJiYgKGVsLnpsZXZlbCA9IHpsZXZlbCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXh0ZW5zaW9uQVBJKGVjSW5zdGFuY2UpIHtcbiAgdmFyIGNvb3JkU3lzTWdyID0gZWNJbnN0YW5jZS5fY29vcmRTeXNNZ3I7XG4gIHJldHVybiB6clV0aWwuZXh0ZW5kKG5ldyBFeHRlbnNpb25BUEkoZWNJbnN0YW5jZSksIHtcbiAgICAvLyBJbmplY3QgbWV0aG9kc1xuICAgIGdldENvb3JkaW5hdGVTeXN0ZW1zOiB6clV0aWwuYmluZChjb29yZFN5c01nci5nZXRDb29yZGluYXRlU3lzdGVtcywgY29vcmRTeXNNZ3IpLFxuICAgIGdldENvbXBvbmVudEJ5RWxlbWVudDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgdmFyIG1vZGVsSW5mbyA9IGVsLl9fZWNDb21wb25lbnRJbmZvO1xuXG4gICAgICAgIGlmIChtb2RlbEluZm8gIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBlY0luc3RhbmNlLl9tb2RlbC5nZXRDb21wb25lbnQobW9kZWxJbmZvLm1haW5UeXBlLCBtb2RlbEluZm8uaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwgPSBlbC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQHR5cGUge09iamVjdH0ga2V5OiBhY3Rpb25UeXBlLlxuICogQGlubmVyXG4gKi9cblxuXG52YXIgYWN0aW9ucyA9IHt9O1xuLyoqXG4gKiBNYXAgZXZlbnRUeXBlIHRvIGFjdGlvblR5cGVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxudmFyIGV2ZW50QWN0aW9uTWFwID0ge307XG4vKipcbiAqIERhdGEgcHJvY2Vzc29yIGZ1bmN0aW9ucyBvZiBlYWNoIHN0YWdlXG4gKiBAdHlwZSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCBGdW5jdGlvbj4+fVxuICogQGlubmVyXG4gKi9cblxudmFyIGRhdGFQcm9jZXNzb3JGdW5jcyA9IFtdO1xuLyoqXG4gKiBAdHlwZSB7QXJyYXkuPEZ1bmN0aW9uPn1cbiAqIEBpbm5lclxuICovXG5cbnZhciBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcyA9IFtdO1xuLyoqXG4gKiBAdHlwZSB7QXJyYXkuPEZ1bmN0aW9uPn1cbiAqIEBpbm5lclxuICovXG5cbnZhciBwb3N0VXBkYXRlRnVuY3MgPSBbXTtcbi8qKlxuICogVmlzdWFsIGVuY29kaW5nIGZ1bmN0aW9ucyBvZiBlYWNoIHN0YWdlXG4gKiBAdHlwZSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCBGdW5jdGlvbj4+fVxuICogQGlubmVyXG4gKi9cblxudmFyIHZpc3VhbEZ1bmNzID0gW107XG4vKipcbiAqIFRoZW1lIHN0b3JhZ2VcbiAqIEB0eXBlIHtPYmplY3QuPGtleSwgT2JqZWN0Pn1cbiAqL1xuXG52YXIgdGhlbWVTdG9yYWdlID0ge307XG4vKipcbiAqIExvYWRpbmcgZWZmZWN0c1xuICovXG5cbnZhciBsb2FkaW5nRWZmZWN0cyA9IHt9O1xudmFyIGluc3RhbmNlcyA9IHt9O1xudmFyIGNvbm5lY3RlZEdyb3VwcyA9IHt9O1xudmFyIGlkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xudmFyIGdyb3VwSWRCYXNlID0gbmV3IERhdGUoKSAtIDA7XG52YXIgRE9NX0FUVFJJQlVURV9LRVkgPSAnX2VjaGFydHNfaW5zdGFuY2VfJztcbnZhciBtYXBEYXRhU3RvcmVzID0ge307XG5cbmZ1bmN0aW9uIGVuYWJsZUNvbm5lY3QoY2hhcnQpIHtcbiAgdmFyIFNUQVRVU19QRU5ESU5HID0gMDtcbiAgdmFyIFNUQVRVU19VUERBVElORyA9IDE7XG4gIHZhciBTVEFUVVNfVVBEQVRFRCA9IDI7XG4gIHZhciBTVEFUVVNfS0VZID0gJ19fY29ubmVjdFVwZGF0ZVN0YXR1cyc7XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKGNoYXJ0cywgc3RhdHVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlckNoYXJ0ID0gY2hhcnRzW2ldO1xuICAgICAgb3RoZXJDaGFydFtTVEFUVVNfS0VZXSA9IHN0YXR1cztcbiAgICB9XG4gIH1cblxuICB6clV0aWwuZWFjaChldmVudEFjdGlvbk1hcCwgZnVuY3Rpb24gKGFjdGlvblR5cGUsIGV2ZW50VHlwZSkge1xuICAgIGNoYXJ0Ll9tZXNzYWdlQ2VudGVyLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoY29ubmVjdGVkR3JvdXBzW2NoYXJ0Lmdyb3VwXSAmJiBjaGFydFtTVEFUVVNfS0VZXSAhPT0gU1RBVFVTX1BFTkRJTkcpIHtcbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LmVzY2FwZUNvbm5lY3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9uID0gY2hhcnQubWFrZUFjdGlvbkZyb21FdmVudChldmVudCk7XG4gICAgICAgIHZhciBvdGhlckNoYXJ0cyA9IFtdO1xuICAgICAgICB6clV0aWwuZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChvdGhlckNoYXJ0KSB7XG4gICAgICAgICAgaWYgKG90aGVyQ2hhcnQgIT09IGNoYXJ0ICYmIG90aGVyQ2hhcnQuZ3JvdXAgPT09IGNoYXJ0Lmdyb3VwKSB7XG4gICAgICAgICAgICBvdGhlckNoYXJ0cy5wdXNoKG90aGVyQ2hhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZUNvbm5lY3RlZENoYXJ0c1N0YXR1cyhvdGhlckNoYXJ0cywgU1RBVFVTX1BFTkRJTkcpO1xuICAgICAgICBlYWNoKG90aGVyQ2hhcnRzLCBmdW5jdGlvbiAob3RoZXJDaGFydCkge1xuICAgICAgICAgIGlmIChvdGhlckNoYXJ0W1NUQVRVU19LRVldICE9PSBTVEFUVVNfVVBEQVRJTkcpIHtcbiAgICAgICAgICAgIG90aGVyQ2hhcnQuZGlzcGF0Y2hBY3Rpb24oYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVDb25uZWN0ZWRDaGFydHNTdGF0dXMob3RoZXJDaGFydHMsIFNUQVRVU19VUERBVEVEKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IFt0aGVtZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb10gVXNlIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIGJ5IGRlZmF1bHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcl0gQ3VycmVudGx5IG9ubHkgJ2NhbnZhcycgaXMgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBVc2UgY2xpZW50V2lkdGggb2YgdGhlIGlucHV0IGBkb21gIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlaWdodF0gVXNlIGNsaWVudEhlaWdodCBvZiB0aGUgaW5wdXQgYGRvbWAgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICovXG5cblxuZnVuY3Rpb24gaW5pdChkb20sIHRoZW1lLCBvcHRzKSB7XG4gIHZhciBleGlzdEluc3RhbmNlID0gZ2V0SW5zdGFuY2VCeURvbShkb20pO1xuXG4gIGlmIChleGlzdEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGV4aXN0SW5zdGFuY2U7XG4gIH1cblxuICB2YXIgY2hhcnQgPSBuZXcgRUNoYXJ0cyhkb20sIHRoZW1lLCBvcHRzKTtcbiAgY2hhcnQuaWQgPSAnZWNfJyArIGlkQmFzZSsrO1xuICBpbnN0YW5jZXNbY2hhcnQuaWRdID0gY2hhcnQ7XG5cbiAgaWYgKGRvbS5zZXRBdHRyaWJ1dGUpIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZLCBjaGFydC5pZCk7XG4gIH0gZWxzZSB7XG4gICAgZG9tW0RPTV9BVFRSSUJVVEVfS0VZXSA9IGNoYXJ0LmlkO1xuICB9XG5cbiAgZW5hYmxlQ29ubmVjdChjaGFydCk7XG4gIHJldHVybiBjaGFydDtcbn1cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfEFycmF5Ljxtb2R1bGU6ZWNoYXJ0c35FQ2hhcnRzPn0gZ3JvdXBJZFxuICovXG5cblxuZnVuY3Rpb24gY29ubmVjdChncm91cElkKSB7XG4gIC8vIElzIGFycmF5IG9mIGNoYXJ0c1xuICBpZiAoenJVdGlsLmlzQXJyYXkoZ3JvdXBJZCkpIHtcbiAgICB2YXIgY2hhcnRzID0gZ3JvdXBJZDtcbiAgICBncm91cElkID0gbnVsbDsgLy8gSWYgYW55IGNoYXJ0IGhhcyBncm91cFxuXG4gICAgenJVdGlsLmVhY2goY2hhcnRzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgIGlmIChjaGFydC5ncm91cCAhPSBudWxsKSB7XG4gICAgICAgIGdyb3VwSWQgPSBjaGFydC5ncm91cDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBncm91cElkID0gZ3JvdXBJZCB8fCAnZ18nICsgZ3JvdXBJZEJhc2UrKztcbiAgICB6clV0aWwuZWFjaChjaGFydHMsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgY2hhcnQuZ3JvdXAgPSBncm91cElkO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdID0gdHJ1ZTtcbiAgcmV0dXJuIGdyb3VwSWQ7XG59XG4vKipcbiAqIEBERVBSRUNBVEVEXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGdyb3VwSWRcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc0Nvbm5lY3QoZ3JvdXBJZCkge1xuICBjb25uZWN0ZWRHcm91cHNbZ3JvdXBJZF0gPSBmYWxzZTtcbn1cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBncm91cElkXG4gKi9cblxuXG52YXIgZGlzY29ubmVjdCA9IGRpc0Nvbm5lY3Q7XG4vKipcbiAqIERpc3Bvc2UgYSBjaGFydCBpbnN0YW5jZVxuICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHN+RUNoYXJ0c3xIVE1MRG9tRWxlbWVudHxzdHJpbmd9IGNoYXJ0XG4gKi9cblxuZnVuY3Rpb24gZGlzcG9zZShjaGFydCkge1xuICBpZiAodHlwZW9mIGNoYXJ0ID09PSAnc3RyaW5nJykge1xuICAgIGNoYXJ0ID0gaW5zdGFuY2VzW2NoYXJ0XTtcbiAgfSBlbHNlIGlmICghKGNoYXJ0IGluc3RhbmNlb2YgRUNoYXJ0cykpIHtcbiAgICAvLyBUcnkgdG8gdHJlYXQgYXMgZG9tXG4gICAgY2hhcnQgPSBnZXRJbnN0YW5jZUJ5RG9tKGNoYXJ0KTtcbiAgfVxuXG4gIGlmIChjaGFydCBpbnN0YW5jZW9mIEVDaGFydHMgJiYgIWNoYXJ0LmlzRGlzcG9zZWQoKSkge1xuICAgIGNoYXJ0LmRpc3Bvc2UoKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tXG4gKiBAcmV0dXJuIHtlY2hhcnRzfkVDaGFydHN9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUJ5RG9tKGRvbSkge1xuICB2YXIga2V5O1xuXG4gIGlmIChkb20uZ2V0QXR0cmlidXRlKSB7XG4gICAga2V5ID0gZG9tLmdldEF0dHJpYnV0ZShET01fQVRUUklCVVRFX0tFWSk7XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gZG9tW0RPTV9BVFRSSUJVVEVfS0VZXTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZXNba2V5XTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7ZWNoYXJ0c35FQ2hhcnRzfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VCeUlkKGtleSkge1xuICByZXR1cm4gaW5zdGFuY2VzW2tleV07XG59XG4vKipcbiAqIFJlZ2lzdGVyIHRoZW1lXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlclRoZW1lKG5hbWUsIHRoZW1lKSB7XG4gIHRoZW1lU3RvcmFnZVtuYW1lXSA9IHRoZW1lO1xufVxuLyoqXG4gKiBSZWdpc3RlciBvcHRpb24gcHJlcHJvY2Vzc29yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVwcm9jZXNzb3JGdW5jXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlclByZXByb2Nlc3NvcihwcmVwcm9jZXNzb3JGdW5jKSB7XG4gIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLnB1c2gocHJlcHJvY2Vzc29yRnVuYyk7XG59XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MTAwMF1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2Nlc3NvckZ1bmNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUHJvY2Vzc29yKHByaW9yaXR5LCBwcm9jZXNzb3JGdW5jKSB7XG4gIGlmICh0eXBlb2YgcHJpb3JpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzb3JGdW5jID0gcHJpb3JpdHk7XG4gICAgcHJpb3JpdHkgPSBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSO1xuICB9XG5cbiAgZGF0YVByb2Nlc3NvckZ1bmNzLnB1c2goe1xuICAgIHByaW86IHByaW9yaXR5LFxuICAgIGZ1bmM6IHByb2Nlc3NvckZ1bmNcbiAgfSk7XG59XG4vKipcbiAqIFJlZ2lzdGVyIHBvc3RVcGRhdGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb3N0VXBkYXRlRnVuY1xuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJQb3N0VXBkYXRlKHBvc3RVcGRhdGVGdW5jKSB7XG4gIHBvc3RVcGRhdGVGdW5jcy5wdXNoKHBvc3RVcGRhdGVGdW5jKTtcbn1cbi8qKlxuICogVXNhZ2U6XG4gKiByZWdpc3RlckFjdGlvbignc29tZUFjdGlvbicsICdzb21lRXZlbnQnLCBmdW5jdGlvbiAoKSB7IC4uLiB9KTtcbiAqIHJlZ2lzdGVyQWN0aW9uKCdzb21lQWN0aW9uJywgZnVuY3Rpb24gKCkgeyAuLi4gfSk7XG4gKiByZWdpc3RlckFjdGlvbihcbiAqICAgICB7dHlwZTogJ3NvbWVBY3Rpb24nLCBldmVudDogJ3NvbWVFdmVudCcsIHVwZGF0ZTogJ3VwZGF0ZVZpZXcnfSxcbiAqICAgICBmdW5jdGlvbiAoKSB7IC4uLiB9XG4gKiApO1xuICpcbiAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpfSBhY3Rpb25JbmZvXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uSW5mby50eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbkluZm8uZXZlbnRdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbkluZm8udXBkYXRlXVxuICogQHBhcmFtIHtzdHJpbmd9IFtldmVudE5hbWVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQWN0aW9uKGFjdGlvbkluZm8sIGV2ZW50TmFtZSwgYWN0aW9uKSB7XG4gIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYWN0aW9uID0gZXZlbnROYW1lO1xuICAgIGV2ZW50TmFtZSA9ICcnO1xuICB9XG5cbiAgdmFyIGFjdGlvblR5cGUgPSB6clV0aWwuaXNPYmplY3QoYWN0aW9uSW5mbykgPyBhY3Rpb25JbmZvLnR5cGUgOiBbYWN0aW9uSW5mbywgYWN0aW9uSW5mbyA9IHtcbiAgICBldmVudDogZXZlbnROYW1lXG4gIH1dWzBdOyAvLyBFdmVudCBuYW1lIGlzIGFsbCBsb3dlcmNhc2VcblxuICBhY3Rpb25JbmZvLmV2ZW50ID0gKGFjdGlvbkluZm8uZXZlbnQgfHwgYWN0aW9uVHlwZSkudG9Mb3dlckNhc2UoKTtcbiAgZXZlbnROYW1lID0gYWN0aW9uSW5mby5ldmVudDsgLy8gVmFsaWRhdGUgYWN0aW9uIHR5cGUgYW5kIGV2ZW50IG5hbWUuXG5cbiAgenJVdGlsLmFzc2VydChBQ1RJT05fUkVHLnRlc3QoYWN0aW9uVHlwZSkgJiYgQUNUSU9OX1JFRy50ZXN0KGV2ZW50TmFtZSkpO1xuXG4gIGlmICghYWN0aW9uc1thY3Rpb25UeXBlXSkge1xuICAgIGFjdGlvbnNbYWN0aW9uVHlwZV0gPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGFjdGlvbkluZm86IGFjdGlvbkluZm9cbiAgICB9O1xuICB9XG5cbiAgZXZlbnRBY3Rpb25NYXBbZXZlbnROYW1lXSA9IGFjdGlvblR5cGU7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0geyp9IENvb3JkaW5hdGVTeXN0ZW1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSh0eXBlLCBDb29yZGluYXRlU3lzdGVtKSB7XG4gIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLnJlZ2lzdGVyKHR5cGUsIENvb3JkaW5hdGVTeXN0ZW0pO1xufVxuLyoqXG4gKiBHZXQgZGltZW5zaW9ucyBvZiBzcGVjaWZpZWQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZ3xPYmplY3Q+fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZVN5c3RlbURpbWVuc2lvbnModHlwZSkge1xuICB2YXIgY29vcmRTeXNDcmVhdG9yID0gQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIuZ2V0KHR5cGUpO1xuXG4gIGlmIChjb29yZFN5c0NyZWF0b3IpIHtcbiAgICByZXR1cm4gY29vcmRTeXNDcmVhdG9yLmdldERpbWVuc2lvbnNJbmZvID8gY29vcmRTeXNDcmVhdG9yLmdldERpbWVuc2lvbnNJbmZvKCkgOiBjb29yZFN5c0NyZWF0b3IuZGltZW5zaW9ucy5zbGljZSgpO1xuICB9XG59XG4vKipcbiAqIExheW91dCBpcyBhIHNwZWNpYWwgc3RhZ2Ugb2YgdmlzdWFsIGVuY29kaW5nXG4gKiBNb3N0IHZpc3VhbCBlbmNvZGluZyBsaWtlIGNvbG9yIGFyZSBjb21tb24gZm9yIGRpZmZlcmVudCBjaGFydFxuICogQnV0IGVhY2ggY2hhcnQgaGFzIGl0J3Mgb3duIGxheW91dCBhbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsYXlvdXRGdW5jXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlckxheW91dChwcmlvcml0eSwgbGF5b3V0RnVuYykge1xuICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGF5b3V0RnVuYyA9IHByaW9yaXR5O1xuICAgIHByaW9yaXR5ID0gUFJJT1JJVFlfVklTVUFMX0xBWU9VVDtcbiAgfVxuXG4gIHZpc3VhbEZ1bmNzLnB1c2goe1xuICAgIHByaW86IHByaW9yaXR5LFxuICAgIGZ1bmM6IGxheW91dEZ1bmMsXG4gICAgaXNMYXlvdXQ6IHRydWVcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MzAwMF1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHZpc3VhbEZ1bmNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyVmlzdWFsKHByaW9yaXR5LCB2aXN1YWxGdW5jKSB7XG4gIGlmICh0eXBlb2YgcHJpb3JpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2aXN1YWxGdW5jID0gcHJpb3JpdHk7XG4gICAgcHJpb3JpdHkgPSBQUklPUklUWV9WSVNVQUxfQ0hBUlQ7XG4gIH1cblxuICB2aXN1YWxGdW5jcy5wdXNoKHtcbiAgICBwcmlvOiBwcmlvcml0eSxcbiAgICBmdW5jOiB2aXN1YWxGdW5jXG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJMb2FkaW5nKG5hbWUsIGxvYWRpbmdGeCkge1xuICBsb2FkaW5nRWZmZWN0c1tuYW1lXSA9IGxvYWRpbmdGeDtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dGVuZENvbXBvbmVudE1vZGVsKG9wdHNcbi8qLCBzdXBlckNsYXNzKi9cbikge1xuICAvLyB2YXIgQ2xhenogPSBDb21wb25lbnRNb2RlbDtcbiAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgLy8gICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShzdXBlckNsYXNzKTtcbiAgLy8gICAgIENsYXp6ID0gQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIsIHRydWUpO1xuICAvLyB9XG4gIHJldHVybiBDb21wb25lbnRNb2RlbC5leHRlbmQob3B0cyk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRDb21wb25lbnRWaWV3KG9wdHNcbi8qLCBzdXBlckNsYXNzKi9cbikge1xuICAvLyB2YXIgQ2xhenogPSBDb21wb25lbnRWaWV3O1xuICAvLyBpZiAoc3VwZXJDbGFzcykge1xuICAvLyAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAvLyAgICAgQ2xhenogPSBDb21wb25lbnRWaWV3LmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViLCB0cnVlKTtcbiAgLy8gfVxuICByZXR1cm4gQ29tcG9uZW50Vmlldy5leHRlbmQob3B0cyk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRTZXJpZXNNb2RlbChvcHRzXG4vKiwgc3VwZXJDbGFzcyovXG4pIHtcbiAgLy8gdmFyIENsYXp6ID0gU2VyaWVzTW9kZWw7XG4gIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gIC8vICAgICBzdXBlckNsYXNzID0gJ3Nlcmllcy4nICsgc3VwZXJDbGFzcy5yZXBsYWNlKCdzZXJpZXMuJywgJycpO1xuICAvLyAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAvLyAgICAgQ2xhenogPSBDb21wb25lbnRNb2RlbC5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YiwgdHJ1ZSk7XG4gIC8vIH1cbiAgcmV0dXJuIFNlcmllc01vZGVsLmV4dGVuZChvcHRzKTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dGVuZENoYXJ0VmlldyhvcHRzXG4vKiwgc3VwZXJDbGFzcyovXG4pIHtcbiAgLy8gdmFyIENsYXp6ID0gQ2hhcnRWaWV3O1xuICAvLyBpZiAoc3VwZXJDbGFzcykge1xuICAvLyAgICAgc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3MucmVwbGFjZSgnc2VyaWVzLicsICcnKTtcbiAgLy8gICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShzdXBlckNsYXNzKTtcbiAgLy8gICAgIENsYXp6ID0gQ2hhcnRWaWV3LmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCB0cnVlKTtcbiAgLy8gfVxuICByZXR1cm4gQ2hhcnRWaWV3LmV4dGVuZChvcHRzKTtcbn1cbi8qKlxuICogWlJlbmRlciBuZWVkIGEgY2FudmFzIGNvbnRleHQgdG8gZG8gbWVhc3VyZVRleHQuXG4gKiBCdXQgaW4gbm9kZSBlbnZpcm9ubWVudCBjYW52YXMgbWF5IGJlIGNyZWF0ZWQgYnkgbm9kZS1jYW52YXMuXG4gKiBTbyB3ZSBuZWVkIHRvIHNwZWNpZnkgaG93IHRvIGNyZWF0ZSBhIGNhbnZhcyBpbnN0ZWFkIG9mIHVzaW5nIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gKlxuICogQmUgY2FyZWZ1bCBvZiB1c2luZyBpdCBpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjcmVhdG9yXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBDYW52YXMgPSByZXF1aXJlKCdjYW52YXMnKTtcbiAqICAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJ2VjaGFydHMnKTtcbiAqICAgICBlY2hhcnRzLnNldENhbnZhc0NyZWF0b3IoZnVuY3Rpb24gKCkge1xuICogICAgICAgICAvLyBTbWFsbCBzaXplIGlzIGVub3VnaC5cbiAqICAgICAgICAgcmV0dXJuIG5ldyBDYW52YXMoMzIsIDMyKTtcbiAqICAgICB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldENhbnZhc0NyZWF0b3IoY3JlYXRvcikge1xuICB6clV0aWwuJG92ZXJyaWRlKCdjcmVhdGVDYW52YXMnLCBjcmVhdG9yKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gZ2VvSnNvblxuICogQHBhcmFtIHtPYmplY3R9IFtzcGVjaWFsQXJlYXNdXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAkLmdldCgnVVNBLmpzb24nLCBmdW5jdGlvbiAoZ2VvSnNvbikge1xuICogICAgICAgICBlY2hhcnRzLnJlZ2lzdGVyTWFwKCdVU0EnLCBnZW9Kc29uKTtcbiAqICAgICAgICAgLy8gT3JcbiAqICAgICAgICAgZWNoYXJ0cy5yZWdpc3Rlck1hcCgnVVNBJywge1xuICogICAgICAgICAgICAgZ2VvSnNvbjogZ2VvSnNvbixcbiAqICAgICAgICAgICAgIHNwZWNpYWxBcmVhczoge31cbiAqICAgICAgICAgfSlcbiAqICAgICB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTWFwKG1hcE5hbWUsIGdlb0pzb24sIHNwZWNpYWxBcmVhcykge1xuICBpZiAoZ2VvSnNvbi5nZW9Kc29uICYmICFnZW9Kc29uLmZlYXR1cmVzKSB7XG4gICAgc3BlY2lhbEFyZWFzID0gZ2VvSnNvbi5zcGVjaWFsQXJlYXM7XG4gICAgZ2VvSnNvbiA9IGdlb0pzb24uZ2VvSnNvbjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2VvSnNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICBnZW9Kc29uID0gdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnICYmIEpTT04ucGFyc2UgPyBKU09OLnBhcnNlKGdlb0pzb24pIDogbmV3IEZ1bmN0aW9uKCdyZXR1cm4gKCcgKyBnZW9Kc29uICsgJyk7JykoKTtcbiAgfVxuXG4gIG1hcERhdGFTdG9yZXNbbWFwTmFtZV0gPSB7XG4gICAgZ2VvSnNvbjogZ2VvSnNvbixcbiAgICBzcGVjaWFsQXJlYXM6IHNwZWNpYWxBcmVhc1xuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFwTmFtZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0TWFwKG1hcE5hbWUpIHtcbiAgcmV0dXJuIG1hcERhdGFTdG9yZXNbbWFwTmFtZV07XG59XG5cbnJlZ2lzdGVyVmlzdWFsKFBSSU9SSVRZX1ZJU1VBTF9HTE9CQUwsIHNlcmllc0NvbG9yKTtcbnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGJhY2t3YXJkQ29tcGF0KTtcbnJlZ2lzdGVyTG9hZGluZygnZGVmYXVsdCcsIGxvYWRpbmdEZWZhdWx0KTsgLy8gRGVmYXVsdCBhY3Rpb25zXG5cbnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ2hpZ2hsaWdodCcsXG4gIGV2ZW50OiAnaGlnaGxpZ2h0JyxcbiAgdXBkYXRlOiAnaGlnaGxpZ2h0J1xufSwgenJVdGlsLm5vb3ApO1xucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiAnZG93bnBsYXknLFxuICBldmVudDogJ2Rvd25wbGF5JyxcbiAgdXBkYXRlOiAnZG93bnBsYXknXG59LCB6clV0aWwubm9vcCk7IC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3aGVyZSB0aGUgbmFtZXNwYWNlIGBkYXRhVG9vbGAgd2lsbFxuLy8gYmUgbW91bnRlZCBvbiBgZWNoYXJ0c2AgaXMgdGhlIGV4dGVuc2lvbiBgZGF0YVRvb2xgIGlzIGltcG9ydGVkLlxuXG52YXIgZGF0YVRvb2wgPSB7fTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbmV4cG9ydHMuUFJJT1JJVFkgPSBQUklPUklUWTtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmNvbm5lY3QgPSBjb25uZWN0O1xuZXhwb3J0cy5kaXNDb25uZWN0ID0gZGlzQ29ubmVjdDtcbmV4cG9ydHMuZGlzY29ubmVjdCA9IGRpc2Nvbm5lY3Q7XG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuZXhwb3J0cy5nZXRJbnN0YW5jZUJ5RG9tID0gZ2V0SW5zdGFuY2VCeURvbTtcbmV4cG9ydHMuZ2V0SW5zdGFuY2VCeUlkID0gZ2V0SW5zdGFuY2VCeUlkO1xuZXhwb3J0cy5yZWdpc3RlclRoZW1lID0gcmVnaXN0ZXJUaGVtZTtcbmV4cG9ydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IgPSByZWdpc3RlclByZXByb2Nlc3NvcjtcbmV4cG9ydHMucmVnaXN0ZXJQcm9jZXNzb3IgPSByZWdpc3RlclByb2Nlc3NvcjtcbmV4cG9ydHMucmVnaXN0ZXJQb3N0VXBkYXRlID0gcmVnaXN0ZXJQb3N0VXBkYXRlO1xuZXhwb3J0cy5yZWdpc3RlckFjdGlvbiA9IHJlZ2lzdGVyQWN0aW9uO1xuZXhwb3J0cy5yZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW0gPSByZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW07XG5leHBvcnRzLmdldENvb3JkaW5hdGVTeXN0ZW1EaW1lbnNpb25zID0gZ2V0Q29vcmRpbmF0ZVN5c3RlbURpbWVuc2lvbnM7XG5leHBvcnRzLnJlZ2lzdGVyTGF5b3V0ID0gcmVnaXN0ZXJMYXlvdXQ7XG5leHBvcnRzLnJlZ2lzdGVyVmlzdWFsID0gcmVnaXN0ZXJWaXN1YWw7XG5leHBvcnRzLnJlZ2lzdGVyTG9hZGluZyA9IHJlZ2lzdGVyTG9hZGluZztcbmV4cG9ydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwgPSBleHRlbmRDb21wb25lbnRNb2RlbDtcbmV4cG9ydHMuZXh0ZW5kQ29tcG9uZW50VmlldyA9IGV4dGVuZENvbXBvbmVudFZpZXc7XG5leHBvcnRzLmV4dGVuZFNlcmllc01vZGVsID0gZXh0ZW5kU2VyaWVzTW9kZWw7XG5leHBvcnRzLmV4dGVuZENoYXJ0VmlldyA9IGV4dGVuZENoYXJ0VmlldztcbmV4cG9ydHMuc2V0Q2FudmFzQ3JlYXRvciA9IHNldENhbnZhc0NyZWF0b3I7XG5leHBvcnRzLnJlZ2lzdGVyTWFwID0gcmVnaXN0ZXJNYXA7XG5leHBvcnRzLmdldE1hcCA9IGdldE1hcDtcbmV4cG9ydHMuZGF0YVRvb2wgPSBkYXRhVG9vbDtcbnZhciBfX19lY19leHBvcnQgPSByZXF1aXJlKFwiLi9leHBvcnRcIik7XG4oZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGtleSBpbiBfX19lY19leHBvcnQpIHtcbiAgICAgICAgaWYgKF9fX2VjX2V4cG9ydC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBleHBvcnRzW2tleV0gPSBfX19lY19leHBvcnRba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn0pKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZWNoYXJ0cy5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIHBhdGhUb29sID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3Rvb2wvcGF0aFwiKTtcblxudmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi90b29sL2NvbG9yXCIpO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgdmVjdG9yID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgUGF0aCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBUcmFuc2Zvcm1hYmxlID0gcmVxdWlyZShcInpyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGVcIik7XG5cbnZhciBJbWFnZSA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlXCIpO1xuXG5leHBvcnRzLkltYWdlID0gSW1hZ2U7XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXBcIik7XG5cbmV4cG9ydHMuR3JvdXAgPSBHcm91cDtcblxudmFyIFRleHQgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9UZXh0XCIpO1xuXG5leHBvcnRzLlRleHQgPSBUZXh0O1xuXG52YXIgQ2lyY2xlID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlXCIpO1xuXG5leHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcblxudmFyIFNlY3RvciA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3RvclwiKTtcblxuZXhwb3J0cy5TZWN0b3IgPSBTZWN0b3I7XG5cbnZhciBSaW5nID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZ1wiKTtcblxuZXhwb3J0cy5SaW5nID0gUmluZztcblxudmFyIFBvbHlnb24gPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uXCIpO1xuXG5leHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuXG52YXIgUG9seWxpbmUgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVwiKTtcblxuZXhwb3J0cy5Qb2x5bGluZSA9IFBvbHlsaW5lO1xuXG52YXIgUmVjdCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3RcIik7XG5cbmV4cG9ydHMuUmVjdCA9IFJlY3Q7XG5cbnZhciBMaW5lID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZVwiKTtcblxuZXhwb3J0cy5MaW5lID0gTGluZTtcblxudmFyIEJlemllckN1cnZlID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmVcIik7XG5cbmV4cG9ydHMuQmV6aWVyQ3VydmUgPSBCZXppZXJDdXJ2ZTtcblxudmFyIEFyYyA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyY1wiKTtcblxuZXhwb3J0cy5BcmMgPSBBcmM7XG5cbnZhciBDb21wb3VuZFBhdGggPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGhcIik7XG5cbmV4cG9ydHMuQ29tcG91bmRQYXRoID0gQ29tcG91bmRQYXRoO1xuXG52YXIgTGluZWFyR3JhZGllbnQgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudFwiKTtcblxuZXhwb3J0cy5MaW5lYXJHcmFkaWVudCA9IExpbmVhckdyYWRpZW50O1xuXG52YXIgUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudFwiKTtcblxuZXhwb3J0cy5SYWRpYWxHcmFkaWVudCA9IFJhZGlhbEdyYWRpZW50O1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG5leHBvcnRzLkJvdW5kaW5nUmVjdCA9IEJvdW5kaW5nUmVjdDtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBFTVBUWV9PQkogPSB7fTtcbi8qKlxuICogRXh0ZW5kIHNoYXBlIHdpdGggcGFyYW1ldGVyc1xuICovXG5cbmZ1bmN0aW9uIGV4dGVuZFNoYXBlKG9wdHMpIHtcbiAgcmV0dXJuIFBhdGguZXh0ZW5kKG9wdHMpO1xufVxuLyoqXG4gKiBFeHRlbmQgcGF0aFxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kUGF0aChwYXRoRGF0YSwgb3B0cykge1xuICByZXR1cm4gcGF0aFRvb2wuZXh0ZW5kRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggZWxlbWVudCBmcm9tIHBhdGggZGF0YSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoRGF0YVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0PWNvdmVyXSAnY2VudGVyJyBvciAnY292ZXInXG4gKi9cblxuXG5mdW5jdGlvbiBtYWtlUGF0aChwYXRoRGF0YSwgb3B0cywgcmVjdCwgbGF5b3V0KSB7XG4gIHZhciBwYXRoID0gcGF0aFRvb2wuY3JlYXRlRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XG4gIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gIGlmIChyZWN0KSB7XG4gICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHJlY3QgPSBjZW50ZXJHcmFwaGljKHJlY3QsIGJvdW5kaW5nUmVjdCk7XG4gICAgfVxuXG4gICAgcmVzaXplUGF0aChwYXRoLCByZWN0KTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBpbWFnZSBlbGVtZW50IGZyb20gaW1hZ2UgdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VVcmwgaW1hZ2UgdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBvcHRpb25zXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0IGNvbnN0cmFpbiByZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2xheW91dD1jb3Zlcl0gJ2NlbnRlcicgb3IgJ2NvdmVyJ1xuICovXG5cblxuZnVuY3Rpb24gbWFrZUltYWdlKGltYWdlVXJsLCByZWN0LCBsYXlvdXQpIHtcbiAgdmFyIHBhdGggPSBuZXcgSW1hZ2Uoe1xuICAgIHN0eWxlOiB7XG4gICAgICBpbWFnZTogaW1hZ2VVcmwsXG4gICAgICB4OiByZWN0LngsXG4gICAgICB5OiByZWN0LnksXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICB9LFxuICAgIG9ubG9hZDogZnVuY3Rpb24gKGltZykge1xuICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHtcbiAgICAgICAgICB3aWR0aDogaW1nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaW1nLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBwYXRoLnNldFN0eWxlKGNlbnRlckdyYXBoaWMocmVjdCwgYm91bmRpbmdSZWN0KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIEdldCBwb3NpdGlvbiBvZiBjZW50ZXJlZCBlbGVtZW50IGluIGJvdW5kaW5nIGJveC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlY3QgICAgICAgICBlbGVtZW50IGxvY2FsIGJvdW5kaW5nIGJveFxuICogQHBhcmFtICB7T2JqZWN0fSBib3VuZGluZ1JlY3QgY29uc3RyYWludCBib3VuZGluZyBib3hcbiAqIEByZXR1cm4ge09iamVjdH0gZWxlbWVudCBwb3NpdGlvbiBjb250YWluaW5nIHgsIHksIHdpZHRoLCBhbmQgaGVpZ2h0XG4gKi9cblxuXG5mdW5jdGlvbiBjZW50ZXJHcmFwaGljKHJlY3QsIGJvdW5kaW5nUmVjdCkge1xuICAvLyBTZXQgcmVjdCB0byBjZW50ZXIsIGtlZXAgd2lkdGggLyBoZWlnaHQgcmF0aW8uXG4gIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xuICB2YXIgd2lkdGggPSByZWN0LmhlaWdodCAqIGFzcGVjdDtcbiAgdmFyIGhlaWdodDtcblxuICBpZiAod2lkdGggPD0gcmVjdC53aWR0aCkge1xuICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgfVxuXG4gIHZhciBjeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xuICB2YXIgY3kgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XG4gIHJldHVybiB7XG4gICAgeDogY3ggLSB3aWR0aCAvIDIsXG4gICAgeTogY3kgLSBoZWlnaHQgLyAyLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG52YXIgbWVyZ2VQYXRoID0gcGF0aFRvb2wubWVyZ2VQYXRoO1xuLyoqXG4gKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gKi9cblxuZnVuY3Rpb24gcmVzaXplUGF0aChwYXRoLCByZWN0KSB7XG4gIGlmICghcGF0aC5hcHBseVRyYW5zZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xuICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgbGluZSBmb3IgY2FudmFzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngyXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55Ml1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cbiAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YlBpeGVsT3B0aW1pemVMaW5lKHBhcmFtKSB7XG4gIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xuICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xuXG4gIGlmIChyb3VuZChzaGFwZS54MSAqIDIpID09PSByb3VuZChzaGFwZS54MiAqIDIpKSB7XG4gICAgc2hhcGUueDEgPSBzaGFwZS54MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueDEsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gIH1cblxuICBpZiAocm91bmQoc2hhcGUueTEgKiAyKSA9PT0gcm91bmQoc2hhcGUueTIgKiAyKSkge1xuICAgIHNoYXBlLnkxID0gc2hhcGUueTIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnkxLCBsaW5lV2lkdGgsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgcmVjdCBmb3IgY2FudmFzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54XVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55XVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS53aWR0aF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUuaGVpZ2h0XVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxuICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxuICovXG5cblxuZnVuY3Rpb24gc3ViUGl4ZWxPcHRpbWl6ZVJlY3QocGFyYW0pIHtcbiAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XG4gIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XG4gIHZhciBvcmlnaW5YID0gc2hhcGUueDtcbiAgdmFyIG9yaWdpblkgPSBzaGFwZS55O1xuICB2YXIgb3JpZ2luV2lkdGggPSBzaGFwZS53aWR0aDtcbiAgdmFyIG9yaWdpbkhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgc2hhcGUueCA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueCwgbGluZVdpZHRoLCB0cnVlKTtcbiAgc2hhcGUueSA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgc2hhcGUud2lkdGggPSBNYXRoLm1heChzdWJQaXhlbE9wdGltaXplKG9yaWdpblggKyBvcmlnaW5XaWR0aCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS54LCBvcmlnaW5XaWR0aCA9PT0gMCA/IDAgOiAxKTtcbiAgc2hhcGUuaGVpZ2h0ID0gTWF0aC5tYXgoc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZICsgb3JpZ2luSGVpZ2h0LCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLnksIG9yaWdpbkhlaWdodCA9PT0gMCA/IDAgOiAxKTtcbiAgcmV0dXJuIHBhcmFtO1xufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgZm9yIGNhbnZhc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBDb29yZGluYXRlLCBzdWNoIGFzIHgsIHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggU2hvdWxkIGJlIG5vbm5lZ2F0aXZlIGludGVnZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBwb3NpdGl2ZU9yTmVnYXRpdmUgRGVmYXVsdCBmYWxzZSAobmVnYXRpdmUpLlxuICogQHJldHVybiB7bnVtYmVyfSBPcHRpbWl6ZWQgcG9zaXRpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJQaXhlbE9wdGltaXplKHBvc2l0aW9uLCBsaW5lV2lkdGgsIHBvc2l0aXZlT3JOZWdhdGl2ZSkge1xuICAvLyBBc3N1cmUgdGhhdCAocG9zaXRpb24gKyBsaW5lV2lkdGggLyAyKSBpcyBuZWFyIGludGVnZXIgZWRnZSxcbiAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXG4gIHZhciBkb3VibGVkUG9zaXRpb24gPSByb3VuZChwb3NpdGlvbiAqIDIpO1xuICByZXR1cm4gKGRvdWJsZWRQb3NpdGlvbiArIHJvdW5kKGxpbmVXaWR0aCkpICUgMiA9PT0gMCA/IGRvdWJsZWRQb3NpdGlvbiAvIDIgOiAoZG91YmxlZFBvc2l0aW9uICsgKHBvc2l0aXZlT3JOZWdhdGl2ZSA/IDEgOiAtMSkpIC8gMjtcbn1cblxuZnVuY3Rpb24gaGFzRmlsbE9yU3Ryb2tlKGZpbGxPclN0cm9rZSkge1xuICByZXR1cm4gZmlsbE9yU3Ryb2tlICE9IG51bGwgJiYgZmlsbE9yU3Ryb2tlICE9ICdub25lJztcbn1cblxuZnVuY3Rpb24gbGlmdENvbG9yKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnID8gY29sb3JUb29sLmxpZnQoY29sb3IsIC0wLjEpIDogY29sb3I7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBjYWNoZUVsZW1lbnRTdGwoZWwpIHtcbiAgaWYgKGVsLl9faG92ZXJTdGxEaXJ0eSkge1xuICAgIHZhciBzdHJva2UgPSBlbC5zdHlsZS5zdHJva2U7XG4gICAgdmFyIGZpbGwgPSBlbC5zdHlsZS5maWxsOyAvLyBDcmVhdGUgaG92ZXJTdHlsZSBvbiBtb3VzZW92ZXJcblxuICAgIHZhciBob3ZlclN0eWxlID0gZWwuX19ob3ZlclN0bDtcbiAgICBob3ZlclN0eWxlLmZpbGwgPSBob3ZlclN0eWxlLmZpbGwgfHwgKGhhc0ZpbGxPclN0cm9rZShmaWxsKSA/IGxpZnRDb2xvcihmaWxsKSA6IG51bGwpO1xuICAgIGhvdmVyU3R5bGUuc3Ryb2tlID0gaG92ZXJTdHlsZS5zdHJva2UgfHwgKGhhc0ZpbGxPclN0cm9rZShzdHJva2UpID8gbGlmdENvbG9yKHN0cm9rZSkgOiBudWxsKTtcbiAgICB2YXIgbm9ybWFsU3R5bGUgPSB7fTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gaG92ZXJTdHlsZSkge1xuICAgICAgLy8gU2VlIGNvbW1lbnQgaW4gYGRvU2luZ2xlRW50ZXJIb3ZlcmAuXG4gICAgICBpZiAoaG92ZXJTdHlsZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIG5vcm1hbFN0eWxlW25hbWVdID0gZWwuc3R5bGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWwuX19ub3JtYWxTdGwgPSBub3JtYWxTdHlsZTtcbiAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSBmYWxzZTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZG9TaW5nbGVFbnRlckhvdmVyKGVsKSB7XG4gIGlmIChlbC5fX2lzSG92ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjYWNoZUVsZW1lbnRTdGwoZWwpO1xuXG4gIGlmIChlbC51c2VIb3ZlckxheWVyKSB7XG4gICAgZWwuX196ciAmJiBlbC5fX3pyLmFkZEhvdmVyKGVsLCBlbC5fX2hvdmVyU3RsKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICB2YXIgaW5zaWRlUm9sbGJhY2tPcHQgPSBzdHlsZS5pbnNpZGVSb2xsYmFja09wdDsgLy8gQ29uc2lkZXIgY2FzZTogb25seSBgcG9zaXRpb246ICd0b3AnYCBpcyBzZXQgb24gZW1waGFzaXMsIHRoZW4gdGV4dFxuICAgIC8vIGNvbG9yIHNob3VsZCBiZSByZXR1cm5lZCB0byBgYXV0b0NvbG9yYCwgcmF0aGVyIHRoYW4gcmVtYWluICcjZmZmJy5cbiAgICAvLyBTbyB3ZSBzaG91bGQgcm9sbGJhY2sgdGhlbiBhcHBseSBhZ2FpbiBhZnRlciBzdHlsZSBtZXJnaW5nLlxuXG4gICAgaW5zaWRlUm9sbGJhY2tPcHQgJiYgcm9sbGJhY2tJbnNpZGVTdHlsZShzdHlsZSk7IC8vIHN0eWxlcyBjYW4gYmU6XG4gICAgLy8ge1xuICAgIC8vICAgICBsYWJlbDoge1xuICAgIC8vICAgICAgICAgbm9ybWFsOiB7XG4gICAgLy8gICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgLy8gICAgICAgICAgICAgcG9zaXRpb246ICdvdXRzaWRlJyxcbiAgICAvLyAgICAgICAgICAgICBmb250U2l6ZTogMThcbiAgICAvLyAgICAgICAgIH0sXG4gICAgLy8gICAgICAgICBlbXBoYXNpczoge1xuICAgIC8vICAgICAgICAgICAgIHNob3c6IHRydWVcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vIH0sXG4gICAgLy8gd2hlcmUgcHJvcGVydGllcyBvZiBgZW1waGFzaXNgIG1heSBub3QgYXBwZWFyIGluIGBub3JtYWxgLiBXZSBwcmV2aW91c2x5IHVzZVxuICAgIC8vIG1vZHVsZTplY2hhcnRzL3V0aWwvbW9kZWwjZGVmYXVsdEVtcGhhc2lzIHRvIG1lcmdlIGBub3JtYWxgIHRvIGBlbXBoYXNpc2AuXG4gICAgLy8gQnV0IGNvbnNpZGVyIHJpY2ggdGV4dCBhbmQgc2V0T3B0aW9uIGluIG1lcmdlIG1vZGUsIGl0IGlzIGltcG9zc2libGUgdG8gY292ZXJcbiAgICAvLyBhbGwgcHJvcGVydGllcyBpbiBtZXJnZS4gU28gd2UgdXNlIG1lcmdlIG1vZGUgd2hlbiBzZXR0aW5nIHN0eWxlIGhlcmUsIHdoZXJlXG4gICAgLy8gb25seSBwcm9wZXJ0aWVzIHRoYXQgaXMgbm90IGBudWxsL3VuZGVmaW5lZGAgY2FuIGJlIHNldC4gVGhlIGRpc2FkdmVudGFnZTpcbiAgICAvLyBudWxsL3VuZGVmaW5lZCBjYW4gbm90IGJlIHVzZWQgdG8gcmVtb3ZlIHN0eWxlIGFueSBtb3JlIGluIGBlbXBoYXNpc2AuXG5cbiAgICBzdHlsZS5leHRlbmRGcm9tKGVsLl9faG92ZXJTdGwpOyAvLyBEbyBub3Qgc2F2ZSBgaW5zaWRlUm9sbGJhY2tgLlxuXG4gICAgaWYgKGluc2lkZVJvbGxiYWNrT3B0KSB7XG4gICAgICBhcHBseUluc2lkZVN0eWxlKHN0eWxlLCBzdHlsZS5pbnNpZGVPcmlnaW5hbFRleHRQb3NpdGlvbiwgaW5zaWRlUm9sbGJhY2tPcHQpOyAvLyB0ZXh0RmlsbCBtYXkgYmUgcm9sbGJhY2tlZCB0byBudWxsLlxuXG4gICAgICBpZiAoc3R5bGUudGV4dEZpbGwgPT0gbnVsbCkge1xuICAgICAgICBzdHlsZS50ZXh0RmlsbCA9IGluc2lkZVJvbGxiYWNrT3B0LmF1dG9Db2xvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbC5kaXJ0eShmYWxzZSk7XG4gICAgZWwuejIgKz0gMTtcbiAgfVxuXG4gIGVsLl9faXNIb3ZlciA9IHRydWU7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKSB7XG4gIGlmICghZWwuX19pc0hvdmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5vcm1hbFN0bCA9IGVsLl9fbm9ybWFsU3RsO1xuXG4gIGlmIChlbC51c2VIb3ZlckxheWVyKSB7XG4gICAgZWwuX196ciAmJiBlbC5fX3pyLnJlbW92ZUhvdmVyKGVsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb25zaWRlciBudWxsL3VuZGVmaW5lZCB2YWx1ZSwgc2hvdWxkIHVzZVxuICAgIC8vIGBzZXRTdHlsZWAgYnV0IG5vdCBgZXh0ZW5kRnJvbShzdGwsIHRydWUpYC5cbiAgICBub3JtYWxTdGwgJiYgZWwuc2V0U3R5bGUobm9ybWFsU3RsKTtcbiAgICBlbC56MiAtPSAxO1xuICB9XG5cbiAgZWwuX19pc0hvdmVyID0gZmFsc2U7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZG9FbnRlckhvdmVyKGVsKSB7XG4gIGVsLnR5cGUgPT09ICdncm91cCcgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgZG9TaW5nbGVFbnRlckhvdmVyKGNoaWxkKTtcbiAgICB9XG4gIH0pIDogZG9TaW5nbGVFbnRlckhvdmVyKGVsKTtcbn1cblxuZnVuY3Rpb24gZG9MZWF2ZUhvdmVyKGVsKSB7XG4gIGVsLnR5cGUgPT09ICdncm91cCcgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgZG9TaW5nbGVMZWF2ZUhvdmVyKGNoaWxkKTtcbiAgICB9XG4gIH0pIDogZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3RsKSB7XG4gIC8vIElmIGVsZW1lbnQgaGFzIHNlcGNpZmllZCBob3ZlclN0eWxlLCB0aGVuIHVzZSBpdCBpbnN0ZWFkIG9mIGdpdmVuIGhvdmVyU3R5bGVcbiAgLy8gT2Z0ZW4gdXNlZCB3aGVuIGl0ZW0gZ3JvdXAgaGFzIGEgbGFiZWwgZWxlbWVudCBhbmQgaXQncyBob3ZlclN0eWxlIGlzIGRpZmZlcmVudFxuICBlbC5fX2hvdmVyU3RsID0gZWwuaG92ZXJTdHlsZSB8fCBob3ZlclN0bCB8fCB7fTtcbiAgZWwuX19ob3ZlclN0bERpcnR5ID0gdHJ1ZTtcblxuICBpZiAoZWwuX19pc0hvdmVyKSB7XG4gICAgY2FjaGVFbGVtZW50U3RsKGVsKTtcbiAgfVxufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3ZlcihlKSB7XG4gIGlmICh0aGlzLl9faG92ZXJTaWxlbnRPblRvdWNoICYmIGUuenJCeVRvdWNoKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXG5cblxuICAhdGhpcy5fX2lzRW1waGFzaXMgJiYgZG9FbnRlckhvdmVyKHRoaXMpO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3V0KGUpIHtcbiAgaWYgKHRoaXMuX19ob3ZlclNpbGVudE9uVG91Y2ggJiYgZS56ckJ5VG91Y2gpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcblxuXG4gICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0xlYXZlSG92ZXIodGhpcyk7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZW50ZXJFbXBoYXNpcygpIHtcbiAgdGhpcy5fX2lzRW1waGFzaXMgPSB0cnVlO1xuICBkb0VudGVySG92ZXIodGhpcyk7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gbGVhdmVFbXBoYXNpcygpIHtcbiAgdGhpcy5fX2lzRW1waGFzaXMgPSBmYWxzZTtcbiAgZG9MZWF2ZUhvdmVyKHRoaXMpO1xufVxuLyoqXG4gKiBTZXQgaG92ZXIgc3R5bGUgb2YgZWxlbWVudC5cbiAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgcmVwZWF0bHkgd2l0aG91dCBzaWRlLWVmZmVjdHMuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gW2hvdmVyU3R5bGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5ob3ZlclNpbGVudE9uVG91Y2g9ZmFsc2VdXG4gKiAgICAgICAgSW4gdG91Y2ggZGV2aWNlLCBtb3VzZW92ZXIgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyIG9uIHRvdWNoc3RhcnQgZXZlbnRcbiAqICAgICAgICAoc2VlIG1vZHVsZTp6cmVuZGVyL2RvbS9IYW5kbGVyUHJveHkpLiBCeSB0aGlzIG1lY2hhbmlzbSwgd2UgY2FuXG4gKiAgICAgICAgY29udmluaWVudGx5IHVzZSBob3ZlclN0eWxlIHdoZW4gdGFwIG9uIHRvdWNoIHNjcmVlbiB3aXRob3V0IGFkZGl0aW9uYWxcbiAqICAgICAgICBjb2RlIGZvciBjb21wYXRpYmlsaXR5LlxuICogICAgICAgIEJ1dCBpZiB0aGUgY2hhcnQvY29tcG9uZW50IGhhcyBzZWxlY3QgZmVhdHVyZSwgd2hpY2ggdXN1YWxseSBhbHNvIHVzZVxuICogICAgICAgIGhvdmVyU3R5bGUsIHRoZXJlIG1pZ2h0IGJlIGNvbmZsaWN0IGJldHdlZW4gJ3NlbGVjdC1oaWdobGlnaHQnIGFuZFxuICogICAgICAgICdob3Zlci1oaWdobGlnaHQnIGVzcGVjaWFsbHkgd2hlbiByb2FtIGlzIGVuYWJsZWQgKHNlZSBnZW8gZm9yIGV4YW1wbGUpLlxuICogICAgICAgIEluIHRoaXMgY2FzZSwgaG92ZXJTaWxlbnRPblRvdWNoIHNob3VsZCBiZSB1c2VkIHRvIGRpc2FibGUgaG92ZXItaGlnaGxpZ2h0XG4gKiAgICAgICAgb24gdG91Y2ggZGV2aWNlLlxuICovXG5cblxuZnVuY3Rpb24gc2V0SG92ZXJTdHlsZShlbCwgaG92ZXJTdHlsZSwgb3B0KSB7XG4gIGVsLl9faG92ZXJTaWxlbnRPblRvdWNoID0gb3B0ICYmIG9wdC5ob3ZlclNpbGVudE9uVG91Y2g7XG4gIGVsLnR5cGUgPT09ICdncm91cCcgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgc2V0RWxlbWVudEhvdmVyU3RsKGNoaWxkLCBob3ZlclN0eWxlKTtcbiAgICB9XG4gIH0pIDogc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0eWxlKTsgLy8gRHVwbGljYXRlZCBmdW5jdGlvbiB3aWxsIGJlIGF1dG8taWdub3JlZCwgc2VlIEV2ZW50ZnVsLmpzLlxuXG4gIGVsLm9uKCdtb3VzZW92ZXInLCBvbkVsZW1lbnRNb3VzZU92ZXIpLm9uKCdtb3VzZW91dCcsIG9uRWxlbWVudE1vdXNlT3V0KTsgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5XG5cbiAgZWwub24oJ2VtcGhhc2lzJywgZW50ZXJFbXBoYXNpcykub24oJ25vcm1hbCcsIGxlYXZlRW1waGFzaXMpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBub3JtYWxTdHlsZVxuICogQHBhcmFtIHtPYmplY3R9IGVtcGhhc2lzU3R5bGVcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG5vcm1hbE1vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBlbXBoYXNpc01vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0IENoZWNrIGBvcHRgIG9mIGBzZXRUZXh0U3R5bGVDb21tb25gIHRvIGZpbmQgb3RoZXIgcHJvcHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdC5kZWZhdWx0VGV4dF1cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtvcHQubGFiZWxGZXRjaGVyXSBGZXRjaCB0ZXh0IGJ5XG4gKiAgICAgIGBvcHQubGFiZWxGZXRjaGVyLmdldEZvcm1hdHRlZExhYmVsKG9wdC5sYWJlbERhdGFJbmRleCwgJ25vcm1hbCcvJ2VtcGhhc2lzJywgbnVsbCwgb3B0LmxhYmVsRGltSW5kZXgpYFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW29wdC5sYWJlbERhdGFJbmRleF0gRmV0Y2ggdGV4dCBieVxuICogICAgICBgb3B0LnRleHRGZXRjaGVyLmdldEZvcm1hdHRlZExhYmVsKG9wdC5sYWJlbERhdGFJbmRleCwgJ25vcm1hbCcvJ2VtcGhhc2lzJywgbnVsbCwgb3B0LmxhYmVsRGltSW5kZXgpYFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW29wdC5sYWJlbERpbUluZGV4XSBGZXRjaCB0ZXh0IGJ5XG4gKiAgICAgIGBvcHQudGV4dEZldGNoZXIuZ2V0Rm9ybWF0dGVkTGFiZWwob3B0LmxhYmVsRGF0YUluZGV4LCAnbm9ybWFsJy8nZW1waGFzaXMnLCBudWxsLCBvcHQubGFiZWxEaW1JbmRleClgXG4gKiBAcGFyYW0ge09iamVjdH0gW25vcm1hbFNwZWNpZmllZF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZW1waGFzaXNTcGVjaWZpZWRdXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRMYWJlbFN0eWxlKG5vcm1hbFN0eWxlLCBlbXBoYXNpc1N0eWxlLCBub3JtYWxNb2RlbCwgZW1waGFzaXNNb2RlbCwgb3B0LCBub3JtYWxTcGVjaWZpZWQsIGVtcGhhc2lzU3BlY2lmaWVkKSB7XG4gIG9wdCA9IG9wdCB8fCBFTVBUWV9PQko7XG4gIHZhciBsYWJlbEZldGNoZXIgPSBvcHQubGFiZWxGZXRjaGVyO1xuICB2YXIgbGFiZWxEYXRhSW5kZXggPSBvcHQubGFiZWxEYXRhSW5kZXg7XG4gIHZhciBsYWJlbERpbUluZGV4ID0gb3B0LmxhYmVsRGltSW5kZXg7IC8vIFRoaXMgc2NlbmFyaW8sIGBsYWJlbC5ub3JtYWwuc2hvdyA9IHRydWU7IGxhYmVsLmVtcGhhc2lzLnNob3cgPSBmYWxzZWAsXG4gIC8vIGlzIG5vdCBzdXBwb3J0ZWQgdXRpbCBzb21lb25lIHJlcXVlc3RzLlxuXG4gIHZhciBzaG93Tm9ybWFsID0gbm9ybWFsTW9kZWwuZ2V0U2hhbGxvdygnc2hvdycpO1xuICB2YXIgc2hvd0VtcGhhc2lzID0gZW1waGFzaXNNb2RlbC5nZXRTaGFsbG93KCdzaG93Jyk7IC8vIENvbnNpZGVyIHBlcmZvcm1hbmNlLCBvbmx5IGZldGNoIGxhYmVsIHdoZW4gbmVjZXNzYXJ5LlxuICAvLyBJZiBgbm9ybWFsLnNob3dgIGlzIGBmYWxzZWAgYW5kIGBlbXBoYXNpcy5zaG93YCBpcyBgdHJ1ZWAgYW5kIGBlbXBoYXNpcy5mb3JtYXR0ZXJgIGlzIG5vdCBzZXQsXG4gIC8vIGxhYmVsIHNob3VsZCBiZSBkaXNwbGF5ZWQsIHdoZXJlIHRleHQgaXMgZmV0Y2hlZCBieSBgbm9ybWFsLmZvcm1hdHRlcmAgb3IgYG9wdC5kZWZhdWx0VGV4dGAuXG5cbiAgdmFyIGJhc2VUZXh0ID0gc2hvd05vcm1hbCB8fCBzaG93RW1waGFzaXMgPyB6clV0aWwucmV0cmlldmUyKGxhYmVsRmV0Y2hlciA/IGxhYmVsRmV0Y2hlci5nZXRGb3JtYXR0ZWRMYWJlbChsYWJlbERhdGFJbmRleCwgJ25vcm1hbCcsIG51bGwsIGxhYmVsRGltSW5kZXgpIDogbnVsbCwgb3B0LmRlZmF1bHRUZXh0KSA6IG51bGw7XG4gIHZhciBub3JtYWxTdHlsZVRleHQgPSBzaG93Tm9ybWFsID8gYmFzZVRleHQgOiBudWxsO1xuICB2YXIgZW1waGFzaXNTdHlsZVRleHQgPSBzaG93RW1waGFzaXMgPyB6clV0aWwucmV0cmlldmUyKGxhYmVsRmV0Y2hlciA/IGxhYmVsRmV0Y2hlci5nZXRGb3JtYXR0ZWRMYWJlbChsYWJlbERhdGFJbmRleCwgJ2VtcGhhc2lzJywgbnVsbCwgbGFiZWxEaW1JbmRleCkgOiBudWxsLCBiYXNlVGV4dCkgOiBudWxsOyAvLyBPcHRpbWl6ZTogSWYgc3R5bGUudGV4dCBpcyBudWxsLCB0ZXh0IHdpbGwgbm90IGJlIGRyYXduLlxuXG4gIGlmIChub3JtYWxTdHlsZVRleHQgIT0gbnVsbCB8fCBlbXBoYXNpc1N0eWxlVGV4dCAhPSBudWxsKSB7XG4gICAgLy8gQWx3YXlzIHNldCBgdGV4dFN0eWxlYCBldmVuIGlmIGBub3JtYWxTdHlsZS50ZXh0YCBpcyBudWxsLCBiZWNhdXNlIGRlZmF1bHRcbiAgICAvLyB2YWx1ZXMgaGF2ZSB0byBiZSBzZXQgb24gYG5vcm1hbFN0eWxlYC5cbiAgICAvLyBJZiB3ZSBzZXQgZGVmYXVsdCB2YWx1ZXMgb24gYGVtcGhhc2lzU3R5bGVgLCBjb25zaWRlciBjYXNlOlxuICAgIC8vIEZpcnN0bHksIGBzZXRPcHRpb24oLi4uIGxhYmVsOiB7bm9ybWFsOiB7dGV4dDogbnVsbH0sIGVtcGhhc2lzOiB7c2hvdzogdHJ1ZX19IC4uLik7YFxuICAgIC8vIFNlY29uZGx5LCBgc2V0T3B0aW9uKC4uLiBsYWJlbDoge25vcmFtbDoge3Nob3c6IHRydWUsIHRleHQ6ICdhYmMnLCBjb2xvcjogJ3JlZCd9IC4uLik7YFxuICAgIC8vIFRoZW4gdGhlICdyZWQnIHdpbGwgbm90IHdvcmsgb24gZW1waGFzaXMuXG4gICAgc2V0VGV4dFN0eWxlKG5vcm1hbFN0eWxlLCBub3JtYWxNb2RlbCwgbm9ybWFsU3BlY2lmaWVkLCBvcHQpO1xuICAgIHNldFRleHRTdHlsZShlbXBoYXNpc1N0eWxlLCBlbXBoYXNpc01vZGVsLCBlbXBoYXNpc1NwZWNpZmllZCwgb3B0LCB0cnVlKTtcbiAgfVxuXG4gIG5vcm1hbFN0eWxlLnRleHQgPSBub3JtYWxTdHlsZVRleHQ7XG4gIGVtcGhhc2lzU3R5bGUudGV4dCA9IGVtcGhhc2lzU3R5bGVUZXh0O1xufVxuLyoqXG4gKiBTZXQgYmFzaWMgdGV4dFN0eWxlIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSB0ZXh0U3R5bGVcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gW3NwZWNpZmllZFRleHRTdHlsZV0gQ2FuIGJlIG92ZXJyaWRlZCBieSBzZXR0aW5ncyBpbiBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XSBTZWUgYG9wdGAgb2YgYHNldFRleHRTdHlsZUNvbW1vbmAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0VtcGhhc2lzXVxuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIHNwZWNpZmllZFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzKSB7XG4gIHNldFRleHRTdHlsZUNvbW1vbih0ZXh0U3R5bGUsIHRleHRTdHlsZU1vZGVsLCBvcHQsIGlzRW1waGFzaXMpO1xuICBzcGVjaWZpZWRUZXh0U3R5bGUgJiYgenJVdGlsLmV4dGVuZCh0ZXh0U3R5bGUsIHNwZWNpZmllZFRleHRTdHlsZSk7XG4gIHRleHRTdHlsZS5ob3N0ICYmIHRleHRTdHlsZS5ob3N0LmRpcnR5ICYmIHRleHRTdHlsZS5ob3N0LmRpcnR5KGZhbHNlKTtcbiAgcmV0dXJuIHRleHRTdHlsZTtcbn1cbi8qKlxuICogU2V0IHRleHQgb3B0aW9uIGluIHRoZSBzdHlsZS5cbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXG4gKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBkZWZhdWx0Q29sb3IgRGVmYXVsdCB0ZXh0IGNvbG9yLlxuICogICAgICAgIElmIHNldCBhcyBmYWxzZSwgaXQgd2lsbCBiZSBwcm9jZXNzZWQgYXMgYSBlbXBoYXNpcyBzdHlsZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRleHQodGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBkZWZhdWx0Q29sb3IpIHtcbiAgdmFyIG9wdCA9IHtcbiAgICBpc1JlY3RUZXh0OiB0cnVlXG4gIH07XG4gIHZhciBpc0VtcGhhc2lzO1xuXG4gIGlmIChkZWZhdWx0Q29sb3IgPT09IGZhbHNlKSB7XG4gICAgaXNFbXBoYXNpcyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3VwcG9ydCBzZXR0aW5nIGNvbG9yIGFzICdhdXRvJyB0byBnZXQgdmlzdWFsIGNvbG9yLlxuICAgIG9wdC5hdXRvQ29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gIH1cblxuICBzZXRUZXh0U3R5bGVDb21tb24odGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBvcHQsIGlzRW1waGFzaXMpO1xuICB0ZXh0U3R5bGUuaG9zdCAmJiB0ZXh0U3R5bGUuaG9zdC5kaXJ0eSAmJiB0ZXh0U3R5bGUuaG9zdC5kaXJ0eShmYWxzZSk7XG59XG4vKipcbiAqIHtcbiAqICAgICAgZGlzYWJsZUJveDogYm9vbGVhbiwgV2hldGhlciBkaWFibGUgZHJhd2luZyBib3ggb2YgYmxvY2sgKG91dGVyIG1vc3QpLlxuICogICAgICBpc1JlY3RUZXh0OiBib29sZWFuLFxuICogICAgICBhdXRvQ29sb3I6IHN0cmluZywgc3BlY2lmeSBhIGNvbG9yIHdoZW4gY29sb3IgaXMgJ2F1dG8nLFxuICogICAgICAgICAgICAgIGZvciB0ZXh0RmlsbCwgdGV4dFN0cm9rZSwgdGV4dEJhY2tncm91bmRDb2xvciwgYW5kIHRleHRCb3JkZXJDb2xvci5cbiAqICAgICAgICAgICAgICBJZiBhdXRvQ29sb3Igc3BlY2lmaWVkLCBpdCBpcyB1c2VkIGFzIGRlZmF1bHQgdGV4dEZpbGwuXG4gKiAgICAgIHVzZUluc2lkZVN0eWxlOlxuICogICAgICAgICAgICAgIGB0cnVlYDogVXNlIGluc2lkZSBzdHlsZSAodGV4dEZpbGwsIHRleHRTdHJva2UsIHRleHRTdHJva2VXaWR0aClcbiAqICAgICAgICAgICAgICAgICAgaWYgYHRleHRGaWxsYCBpcyBub3Qgc3BlY2lmaWVkLlxuICogICAgICAgICAgICAgIGBmYWxzZWA6IERvIG5vdCB1c2UgaW5zaWRlIHN0eWxlLlxuICogICAgICAgICAgICAgIGBudWxsL3VuZGVmaW5lZGA6IHVzZSBpbnNpZGUgc3R5bGUgaWYgYGlzUmVjdFRleHRgIGlzIHRydWUgYW5kXG4gKiAgICAgICAgICAgICAgICAgIGB0ZXh0RmlsbGAgaXMgbm90IHNwZWNpZmllZCBhbmQgdGV4dFBvc2l0aW9uIGNvbnRhaW5zIGAnaW5zaWRlJ2AuXG4gKiAgICAgIGZvcmNlUmljaDogYm9vbGVhblxuICogfVxuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dFN0eWxlQ29tbW9uKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIG9wdCwgaXNFbXBoYXNpcykge1xuICAvLyBDb25zaWRlciB0aGVyZSB3aWxsIGJlIGFibm9ybWFsIHdoZW4gbWVyZ2UgaG92ZXIgc3R5bGUgdG8gbm9ybWFsIHN0eWxlIGlmIGdpdmVuIGRlZmF1bHQgdmFsdWUuXG4gIG9wdCA9IG9wdCB8fCBFTVBUWV9PQko7XG5cbiAgaWYgKG9wdC5pc1JlY3RUZXh0KSB7XG4gICAgdmFyIHRleHRQb3NpdGlvbiA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3Bvc2l0aW9uJykgfHwgKGlzRW1waGFzaXMgPyBudWxsIDogJ2luc2lkZScpOyAvLyAnb3V0c2lkZScgaXMgbm90IGEgdmFsaWQgenIgdGV4dFBvc3Rpb24gdmFsdWUsIGJ1dCB1c2VkXG4gICAgLy8gaW4gYmFyIHNlcmllcywgYW5kIG1hZ3JpYyB0eXBlIHNob3VsZCBiZSBjb25zaWRlcmVkLlxuXG4gICAgdGV4dFBvc2l0aW9uID09PSAnb3V0c2lkZScgJiYgKHRleHRQb3NpdGlvbiA9ICd0b3AnKTtcbiAgICB0ZXh0U3R5bGUudGV4dFBvc2l0aW9uID0gdGV4dFBvc2l0aW9uO1xuICAgIHRleHRTdHlsZS50ZXh0T2Zmc2V0ID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnb2Zmc2V0Jyk7XG4gICAgdmFyIGxhYmVsUm90YXRlID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygncm90YXRlJyk7XG4gICAgbGFiZWxSb3RhdGUgIT0gbnVsbCAmJiAobGFiZWxSb3RhdGUgKj0gTWF0aC5QSSAvIDE4MCk7XG4gICAgdGV4dFN0eWxlLnRleHRSb3RhdGlvbiA9IGxhYmVsUm90YXRlO1xuICAgIHRleHRTdHlsZS50ZXh0RGlzdGFuY2UgPSB6clV0aWwucmV0cmlldmUyKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2Rpc3RhbmNlJyksIGlzRW1waGFzaXMgPyBudWxsIDogNSk7XG4gIH1cblxuICB2YXIgZWNNb2RlbCA9IHRleHRTdHlsZU1vZGVsLmVjTW9kZWw7XG4gIHZhciBnbG9iYWxUZXh0U3R5bGUgPSBlY01vZGVsICYmIGVjTW9kZWwub3B0aW9uLnRleHRTdHlsZTsgLy8gQ29uc2lkZXIgY2FzZTpcbiAgLy8ge1xuICAvLyAgICAgZGF0YTogW3tcbiAgLy8gICAgICAgICB2YWx1ZTogMTIsXG4gIC8vICAgICAgICAgbGFiZWw6IHtcbiAgLy8gICAgICAgICAgICAgbm9ybWFsOiB7XG4gIC8vICAgICAgICAgICAgICAgICByaWNoOiB7XG4gIC8vICAgICAgICAgICAgICAgICAgICAgLy8gbm8gJ2EnIGhlcmUgYnV0IHVzaW5nIHBhcmVudCAnYScuXG4gIC8vICAgICAgICAgICAgICAgICB9XG4gIC8vICAgICAgICAgICAgIH1cbiAgLy8gICAgICAgICB9XG4gIC8vICAgICB9XSxcbiAgLy8gICAgIHJpY2g6IHtcbiAgLy8gICAgICAgICBhOiB7IC4uLiB9XG4gIC8vICAgICB9XG4gIC8vIH1cblxuICB2YXIgcmljaEl0ZW1OYW1lcyA9IGdldFJpY2hJdGVtTmFtZXModGV4dFN0eWxlTW9kZWwpO1xuICB2YXIgcmljaFJlc3VsdDtcblxuICBpZiAocmljaEl0ZW1OYW1lcykge1xuICAgIHJpY2hSZXN1bHQgPSB7fTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gcmljaEl0ZW1OYW1lcykge1xuICAgICAgaWYgKHJpY2hJdGVtTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgLy8gQ2FzY2FkZSBpcyBzdXBwb3J0ZWQgaW4gcmljaC5cbiAgICAgICAgdmFyIHJpY2hUZXh0U3R5bGUgPSB0ZXh0U3R5bGVNb2RlbC5nZXRNb2RlbChbJ3JpY2gnLCBuYW1lXSk7IC8vIEluIHJpY2gsIG5ldmVyIGBkaXNhYmxlQm94YC5cblxuICAgICAgICBzZXRUb2tlblRleHRTdHlsZShyaWNoUmVzdWx0W25hbWVdID0ge30sIHJpY2hUZXh0U3R5bGUsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0ZXh0U3R5bGUucmljaCA9IHJpY2hSZXN1bHQ7XG4gIHNldFRva2VuVGV4dFN0eWxlKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzLCB0cnVlKTtcblxuICBpZiAob3B0LmZvcmNlUmljaCAmJiAhb3B0LnRleHRTdHlsZSkge1xuICAgIG9wdC50ZXh0U3R5bGUgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0U3R5bGU7XG59IC8vIENvbnNpZGVyIGNhc2U6XG4vLyB7XG4vLyAgICAgZGF0YTogW3tcbi8vICAgICAgICAgdmFsdWU6IDEyLFxuLy8gICAgICAgICBsYWJlbDoge1xuLy8gICAgICAgICAgICAgbm9ybWFsOiB7XG4vLyAgICAgICAgICAgICAgICAgcmljaDoge1xuLy8gICAgICAgICAgICAgICAgICAgICAvLyBubyAnYScgaGVyZSBidXQgdXNpbmcgcGFyZW50ICdhJy5cbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vICAgICB9XSxcbi8vICAgICByaWNoOiB7XG4vLyAgICAgICAgIGE6IHsgLi4uIH1cbi8vICAgICB9XG4vLyB9XG5cblxuZnVuY3Rpb24gZ2V0UmljaEl0ZW1OYW1lcyh0ZXh0U3R5bGVNb2RlbCkge1xuICAvLyBVc2Ugb2JqZWN0IHRvIHJlbW92ZSBkdXBsaWNhdGVkIG5hbWVzLlxuICB2YXIgcmljaEl0ZW1OYW1lTWFwO1xuXG4gIHdoaWxlICh0ZXh0U3R5bGVNb2RlbCAmJiB0ZXh0U3R5bGVNb2RlbCAhPT0gdGV4dFN0eWxlTW9kZWwuZWNNb2RlbCkge1xuICAgIHZhciByaWNoID0gKHRleHRTdHlsZU1vZGVsLm9wdGlvbiB8fCBFTVBUWV9PQkopLnJpY2g7XG5cbiAgICBpZiAocmljaCkge1xuICAgICAgcmljaEl0ZW1OYW1lTWFwID0gcmljaEl0ZW1OYW1lTWFwIHx8IHt9O1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHJpY2gpIHtcbiAgICAgICAgaWYgKHJpY2guaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICByaWNoSXRlbU5hbWVNYXBbbmFtZV0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGV4dFN0eWxlTW9kZWwgPSB0ZXh0U3R5bGVNb2RlbC5wYXJlbnRNb2RlbDtcbiAgfVxuXG4gIHJldHVybiByaWNoSXRlbU5hbWVNYXA7XG59XG5cbmZ1bmN0aW9uIHNldFRva2VuVGV4dFN0eWxlKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzLCBpc0Jsb2NrKSB7XG4gIC8vIEluIG1lcmdlIG1vZGUsIGRlZmF1bHQgdmFsdWUgc2hvdWxkIG5vdCBiZSBnaXZlbi5cbiAgZ2xvYmFsVGV4dFN0eWxlID0gIWlzRW1waGFzaXMgJiYgZ2xvYmFsVGV4dFN0eWxlIHx8IEVNUFRZX09CSjtcbiAgdGV4dFN0eWxlLnRleHRGaWxsID0gZ2V0QXV0b0NvbG9yKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2NvbG9yJyksIG9wdCkgfHwgZ2xvYmFsVGV4dFN0eWxlLmNvbG9yO1xuICB0ZXh0U3R5bGUudGV4dFN0cm9rZSA9IGdldEF1dG9Db2xvcih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0ZXh0Qm9yZGVyQ29sb3InKSwgb3B0KSB8fCBnbG9iYWxUZXh0U3R5bGUudGV4dEJvcmRlckNvbG9yO1xuICB0ZXh0U3R5bGUudGV4dFN0cm9rZVdpZHRoID0genJVdGlsLnJldHJpZXZlMih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0ZXh0Qm9yZGVyV2lkdGgnKSwgZ2xvYmFsVGV4dFN0eWxlLnRleHRCb3JkZXJXaWR0aCk7XG5cbiAgaWYgKCFpc0VtcGhhc2lzKSB7XG4gICAgaWYgKGlzQmxvY2spIHtcbiAgICAgIC8vIEFsd2F5cyBzZXQgYGluc2lkZVJvbGxiYWNrYCwgZm9yIGNsZWFyaW5nIHByZXZpb3VzLlxuICAgICAgdmFyIG9yaWdpbmFsVGV4dFBvc2l0aW9uID0gdGV4dFN0eWxlLnRleHRQb3NpdGlvbjtcbiAgICAgIHRleHRTdHlsZS5pbnNpZGVSb2xsYmFjayA9IGFwcGx5SW5zaWRlU3R5bGUodGV4dFN0eWxlLCBvcmlnaW5hbFRleHRQb3NpdGlvbiwgb3B0KTsgLy8gU2F2ZSBvcmlnaW5hbCB0ZXh0UG9zaXRpb24sIGJlY2F1c2Ugc3R5bGUudGV4dFBvc2l0aW9uIHdpbGwgYmUgcmVwYWxjZWQgYnlcbiAgICAgIC8vIHJlYWwgbG9jYXRpb24gKGxpa2UgWzEwLCAzMF0pIGluIHpyZW5kZXIuXG5cbiAgICAgIHRleHRTdHlsZS5pbnNpZGVPcmlnaW5hbFRleHRQb3NpdGlvbiA9IG9yaWdpbmFsVGV4dFBvc2l0aW9uO1xuICAgICAgdGV4dFN0eWxlLmluc2lkZVJvbGxiYWNrT3B0ID0gb3B0O1xuICAgIH0gLy8gU2V0IGRlZmF1bHQgZmluYWxseS5cblxuXG4gICAgaWYgKHRleHRTdHlsZS50ZXh0RmlsbCA9PSBudWxsKSB7XG4gICAgICB0ZXh0U3R5bGUudGV4dEZpbGwgPSBvcHQuYXV0b0NvbG9yO1xuICAgIH1cbiAgfSAvLyBEbyBub3QgdXNlIGBnZXRGb250YCBoZXJlLCBiZWNhdXNlIG1lcmdlIHNob3VsZCBiZSBzdXBwb3J0ZWQsIHdoZXJlXG4gIC8vIHBhcnQgb2YgdGhlc2UgcHJvcGVydGllcyBtYXkgYmUgY2hhbmdlZCBpbiBlbXBoYXNpcyBzdHlsZSwgYW5kIHRoZVxuICAvLyBvdGhlcnMgc2hvdWxkIHJlbWFpbiB0aGVpciBvcmlnaW5hbCB2YWx1ZSBnb3QgZnJvbSBub3JtYWwgc3R5bGUuXG5cblxuICB0ZXh0U3R5bGUuZm9udFN0eWxlID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFN0eWxlJykgfHwgZ2xvYmFsVGV4dFN0eWxlLmZvbnRTdHlsZTtcbiAgdGV4dFN0eWxlLmZvbnRXZWlnaHQgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250V2VpZ2h0JykgfHwgZ2xvYmFsVGV4dFN0eWxlLmZvbnRXZWlnaHQ7XG4gIHRleHRTdHlsZS5mb250U2l6ZSA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRTaXplJykgfHwgZ2xvYmFsVGV4dFN0eWxlLmZvbnRTaXplO1xuICB0ZXh0U3R5bGUuZm9udEZhbWlseSA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRGYW1pbHknKSB8fCBnbG9iYWxUZXh0U3R5bGUuZm9udEZhbWlseTtcbiAgdGV4dFN0eWxlLnRleHRBbGlnbiA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2FsaWduJyk7XG4gIHRleHRTdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3ZlcnRpY2FsQWxpZ24nKSB8fCB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdiYXNlbGluZScpO1xuICB0ZXh0U3R5bGUudGV4dExpbmVIZWlnaHQgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdsaW5lSGVpZ2h0Jyk7XG4gIHRleHRTdHlsZS50ZXh0V2lkdGggPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd3aWR0aCcpO1xuICB0ZXh0U3R5bGUudGV4dEhlaWdodCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2hlaWdodCcpO1xuICB0ZXh0U3R5bGUudGV4dFRhZyA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RhZycpO1xuXG4gIGlmICghaXNCbG9jayB8fCAhb3B0LmRpc2FibGVCb3gpIHtcbiAgICB0ZXh0U3R5bGUudGV4dEJhY2tncm91bmRDb2xvciA9IGdldEF1dG9Db2xvcih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdiYWNrZ3JvdW5kQ29sb3InKSwgb3B0KTtcbiAgICB0ZXh0U3R5bGUudGV4dFBhZGRpbmcgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdwYWRkaW5nJyk7XG4gICAgdGV4dFN0eWxlLnRleHRCb3JkZXJDb2xvciA9IGdldEF1dG9Db2xvcih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdib3JkZXJDb2xvcicpLCBvcHQpO1xuICAgIHRleHRTdHlsZS50ZXh0Qm9yZGVyV2lkdGggPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdib3JkZXJXaWR0aCcpO1xuICAgIHRleHRTdHlsZS50ZXh0Qm9yZGVyUmFkaXVzID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnYm9yZGVyUmFkaXVzJyk7XG4gICAgdGV4dFN0eWxlLnRleHRCb3hTaGFkb3dDb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3NoYWRvd0NvbG9yJyk7XG4gICAgdGV4dFN0eWxlLnRleHRCb3hTaGFkb3dCbHVyID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnc2hhZG93Qmx1cicpO1xuICAgIHRleHRTdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3NoYWRvd09mZnNldFgnKTtcbiAgICB0ZXh0U3R5bGUudGV4dEJveFNoYWRvd09mZnNldFkgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdzaGFkb3dPZmZzZXRZJyk7XG4gIH1cblxuICB0ZXh0U3R5bGUudGV4dFNoYWRvd0NvbG9yID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygndGV4dFNoYWRvd0NvbG9yJykgfHwgZ2xvYmFsVGV4dFN0eWxlLnRleHRTaGFkb3dDb2xvcjtcbiAgdGV4dFN0eWxlLnRleHRTaGFkb3dCbHVyID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygndGV4dFNoYWRvd0JsdXInKSB8fCBnbG9iYWxUZXh0U3R5bGUudGV4dFNoYWRvd0JsdXI7XG4gIHRleHRTdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RleHRTaGFkb3dPZmZzZXRYJykgfHwgZ2xvYmFsVGV4dFN0eWxlLnRleHRTaGFkb3dPZmZzZXRYO1xuICB0ZXh0U3R5bGUudGV4dFNoYWRvd09mZnNldFkgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0ZXh0U2hhZG93T2Zmc2V0WScpIHx8IGdsb2JhbFRleHRTdHlsZS50ZXh0U2hhZG93T2Zmc2V0WTtcbn1cblxuZnVuY3Rpb24gZ2V0QXV0b0NvbG9yKGNvbG9yLCBvcHQpIHtcbiAgcmV0dXJuIGNvbG9yICE9PSAnYXV0bycgPyBjb2xvciA6IG9wdCAmJiBvcHQuYXV0b0NvbG9yID8gb3B0LmF1dG9Db2xvciA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFwcGx5SW5zaWRlU3R5bGUodGV4dFN0eWxlLCB0ZXh0UG9zaXRpb24sIG9wdCkge1xuICB2YXIgdXNlSW5zaWRlU3R5bGUgPSBvcHQudXNlSW5zaWRlU3R5bGU7XG4gIHZhciBpbnNpZGVSb2xsYmFjaztcblxuICBpZiAodGV4dFN0eWxlLnRleHRGaWxsID09IG51bGwgJiYgdXNlSW5zaWRlU3R5bGUgIT09IGZhbHNlICYmICh1c2VJbnNpZGVTdHlsZSA9PT0gdHJ1ZSB8fCBvcHQuaXNSZWN0VGV4dCAmJiB0ZXh0UG9zaXRpb24gLy8gdGV4dFBvc2l0aW9uIGNhbiBiZSBbMTAsIDMwXVxuICAmJiB0eXBlb2YgdGV4dFBvc2l0aW9uID09PSAnc3RyaW5nJyAmJiB0ZXh0UG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMCkpIHtcbiAgICBpbnNpZGVSb2xsYmFjayA9IHtcbiAgICAgIHRleHRGaWxsOiBudWxsLFxuICAgICAgdGV4dFN0cm9rZTogdGV4dFN0eWxlLnRleHRTdHJva2UsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IHRleHRTdHlsZS50ZXh0U3Ryb2tlV2lkdGhcbiAgICB9O1xuICAgIHRleHRTdHlsZS50ZXh0RmlsbCA9ICcjZmZmJzsgLy8gQ29uc2lkZXIgdGV4dCB3aXRoICNmZmYgb3ZlcmZsb3cgaXRzIGNvbnRhaW5lci5cblxuICAgIGlmICh0ZXh0U3R5bGUudGV4dFN0cm9rZSA9PSBudWxsKSB7XG4gICAgICB0ZXh0U3R5bGUudGV4dFN0cm9rZSA9IG9wdC5hdXRvQ29sb3I7XG4gICAgICB0ZXh0U3R5bGUudGV4dFN0cm9rZVdpZHRoID09IG51bGwgJiYgKHRleHRTdHlsZS50ZXh0U3Ryb2tlV2lkdGggPSAyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zaWRlUm9sbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHJvbGxiYWNrSW5zaWRlU3R5bGUoc3R5bGUpIHtcbiAgdmFyIGluc2lkZVJvbGxiYWNrID0gc3R5bGUuaW5zaWRlUm9sbGJhY2s7XG5cbiAgaWYgKGluc2lkZVJvbGxiYWNrKSB7XG4gICAgc3R5bGUudGV4dEZpbGwgPSBpbnNpZGVSb2xsYmFjay50ZXh0RmlsbDtcbiAgICBzdHlsZS50ZXh0U3Ryb2tlID0gaW5zaWRlUm9sbGJhY2sudGV4dFN0cm9rZTtcbiAgICBzdHlsZS50ZXh0U3Ryb2tlV2lkdGggPSBpbnNpZGVSb2xsYmFjay50ZXh0U3Ryb2tlV2lkdGg7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rm9udChvcHQsIGVjTW9kZWwpIHtcbiAgLy8gZWNNb2RlbCBvciBkZWZhdWx0IHRleHQgc3R5bGUgbW9kZWwuXG4gIHZhciBnVGV4dFN0eWxlTW9kZWwgPSBlY01vZGVsIHx8IGVjTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICByZXR1cm4gWy8vIEZJWE1FIGluIG5vZGUtY2FudmFzIGZvbnRXZWlnaHQgaXMgYmVmb3JlIGZvbnRTdHlsZVxuICBvcHQuZm9udFN0eWxlIHx8IGdUZXh0U3R5bGVNb2RlbCAmJiBnVGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFN0eWxlJykgfHwgJycsIG9wdC5mb250V2VpZ2h0IHx8IGdUZXh0U3R5bGVNb2RlbCAmJiBnVGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFdlaWdodCcpIHx8ICcnLCAob3B0LmZvbnRTaXplIHx8IGdUZXh0U3R5bGVNb2RlbCAmJiBnVGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFNpemUnKSB8fCAxMikgKyAncHgnLCBvcHQuZm9udEZhbWlseSB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRGYW1pbHknKSB8fCAnc2Fucy1zZXJpZiddLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZU9yU2V0UHJvcHMoaXNVcGRhdGUsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKSB7XG4gIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBkYXRhSW5kZXg7XG4gICAgZGF0YUluZGV4ID0gbnVsbDtcbiAgfSAvLyBEbyBub3QgY2hlY2sgJ2FuaW1hdGlvbicgcHJvcGVydHkgZGlyZWN0bHkgaGVyZS4gQ29uc2lkZXIgdGhpcyBjYXNlOlxuICAvLyBhbmltYXRpb24gbW9kZWwgaXMgYW4gYGl0ZW1Nb2RlbGAsIHdob3NlIGRvZXMgbm90IGhhdmUgYGlzQW5pbWF0aW9uRW5hYmxlZGBcbiAgLy8gYnV0IGl0cyBwYXJlbnQgbW9kZWwgKGBzZXJpZXNNb2RlbGApIGRvZXMuXG5cblxuICB2YXIgYW5pbWF0aW9uRW5hYmxlZCA9IGFuaW1hdGFibGVNb2RlbCAmJiBhbmltYXRhYmxlTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCk7XG5cbiAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcbiAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRHVyYXRpb24nICsgcG9zdGZpeCk7XG4gICAgdmFyIGFuaW1hdGlvbkVhc2luZyA9IGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25FYXNpbmcnICsgcG9zdGZpeCk7XG4gICAgdmFyIGFuaW1hdGlvbkRlbGF5ID0gYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkRlbGF5JyArIHBvc3RmaXgpO1xuXG4gICAgaWYgKHR5cGVvZiBhbmltYXRpb25EZWxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYW5pbWF0aW9uRGVsYXkgPSBhbmltYXRpb25EZWxheShkYXRhSW5kZXgsIGFuaW1hdGFibGVNb2RlbC5nZXRBbmltYXRpb25EZWxheVBhcmFtcyA/IGFuaW1hdGFibGVNb2RlbC5nZXRBbmltYXRpb25EZWxheVBhcmFtcyhlbCwgZGF0YUluZGV4KSA6IG51bGwpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24oZGF0YUluZGV4KTtcbiAgICB9XG5cbiAgICBkdXJhdGlvbiA+IDAgPyBlbC5hbmltYXRlVG8ocHJvcHMsIGR1cmF0aW9uLCBhbmltYXRpb25EZWxheSB8fCAwLCBhbmltYXRpb25FYXNpbmcsIGNiLCAhIWNiKSA6IChlbC5zdG9wQW5pbWF0aW9uKCksIGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5zdG9wQW5pbWF0aW9uKCk7XG4gICAgZWwuYXR0cihwcm9wcyk7XG4gICAgY2IgJiYgY2IoKTtcbiAgfVxufVxuLyoqXG4gKiBVcGRhdGUgZ3JhcGhpYyBlbGVtZW50IHByb3BlcnRpZXMgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiBhY2NvcmRpbmcgdG8gdGhlXG4gKiBjb25maWd1cmF0aW9uIGluIHNlcmllcy5cbiAqXG4gKiBDYXV0aW9uOiB0aGlzIG1ldGhvZCB3aWxsIHN0b3AgcHJldmlvdXMgYW5pbWF0aW9uLlxuICogU28gaWYgZG8gbm90IHVzZSB0aGlzIG1ldGhvZCB0byBvbmUgZWxlbWVudCB0d2ljZSBiZWZvcmVcbiAqIGFuaW1hdGlvbiBzdGFydHMsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxuICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKiBAZXhhbXBsZVxuICogICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHtcbiAqICAgICAgICAgcG9zaXRpb246IFsxMDAsIDEwMF1cbiAqICAgICB9LCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdBbmltYXRpb24gZG9uZSEnKTsgfSk7XG4gKiAgICAgLy8gT3JcbiAqICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gKiAgICAgICAgIHBvc2l0aW9uOiBbMTAwLCAxMDBdXG4gKiAgICAgfSwgc2VyaWVzTW9kZWwsIGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ0FuaW1hdGlvbiBkb25lIScpOyB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKSB7XG4gIGFuaW1hdGVPclNldFByb3BzKHRydWUsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKTtcbn1cbi8qKlxuICogSW5pdCBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGVcbiAqIGNvbmZpZ3VyYXRpb24gaW4gc2VyaWVzLlxuICpcbiAqIENhdXRpb246IHRoaXMgbWV0aG9kIHdpbGwgc3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG4gKiBTbyBpZiBkbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIG9uZSBlbGVtZW50IHR3aWNlIGJlZm9yZVxuICogYW5pbWF0aW9uIHN0YXJ0cywgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFthbmltYXRhYmxlTW9kZWxdXG4gKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuXG5mdW5jdGlvbiBpbml0UHJvcHMoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgYW5pbWF0ZU9yU2V0UHJvcHMoZmFsc2UsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKTtcbn1cbi8qKlxuICogR2V0IHRyYW5zZm9ybSBtYXRyaXggb2YgdGFyZ2V0IChwYXJhbSB0YXJnZXQpLFxuICogaW4gY29vcmRpbmF0ZSBvZiBpdHMgYW5jZXN0b3IgKHBhcmFtIGFuY2VzdG9yKVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IFthbmNlc3Rvcl1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybSh0YXJnZXQsIGFuY2VzdG9yKSB7XG4gIHZhciBtYXQgPSBtYXRyaXguaWRlbnRpdHkoW10pO1xuXG4gIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBhbmNlc3Rvcikge1xuICAgIG1hdHJpeC5tdWwobWF0LCB0YXJnZXQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSwgbWF0KTtcbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIG1hdDtcbn1cbi8qKlxuICogQXBwbHkgdHJhbnNmb3JtIHRvIGFuIHZlcnRleC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldCBbeCwgeV1cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj58VHlwZWRBcnJheS48bnVtYmVyPnxPYmplY3R9IHRyYW5zZm9ybSBDYW4gYmU6XG4gKiAgICAgICsgVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cbiAqICAgICAgKyB7cG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZX0sIHRoZSBzYW1lIGFzIGB6cmVuZGVyL1RyYW5zZm9ybWFibGVgLlxuICogQHBhcmFtIHtib29sZWFuPX0gaW52ZXJ0IFdoZXRoZXIgdXNlIGludmVydCBtYXRyaXguXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3gsIHldXG4gKi9cblxuXG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybSh0YXJnZXQsIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XG4gIGlmICh0cmFuc2Zvcm0gJiYgIXpyVXRpbC5pc0FycmF5TGlrZSh0cmFuc2Zvcm0pKSB7XG4gICAgdHJhbnNmb3JtID0gVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICB9XG5cbiAgaWYgKGludmVydCkge1xuICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XG4gIH1cblxuICByZXR1cm4gdmVjdG9yLmFwcGx5VHJhbnNmb3JtKFtdLCB0YXJnZXQsIHRyYW5zZm9ybSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gJ2xlZnQnICdyaWdodCcgJ3RvcCcgJ2JvdHRvbSdcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRyYW5zZm9ybSBUcmFuc2Zvcm0gbWF0cml4OiBsaWtlIFsxLCAwLCAwLCAxLCAwLCAwXVxuICogQHBhcmFtIHtib29sZWFuPX0gaW52ZXJ0IFdoZXRoZXIgdXNlIGludmVydCBtYXRyaXguXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRyYW5zZm9ybWVkIGRpcmVjdGlvbi4gJ2xlZnQnICdyaWdodCcgJ3RvcCcgJ2JvdHRvbSdcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybURpcmVjdGlvbihkaXJlY3Rpb24sIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XG4gIC8vIFBpY2sgYSBiYXNlLCBlbnN1cmUgdGhhdCB0cmFuc2Zvcm0gcmVzdWx0IHdpbGwgbm90IGJlICgwLCAwKS5cbiAgdmFyIGhCYXNlID0gdHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMF0gPT09IDAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XG4gIHZhciB2QmFzZSA9IHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzJdID09PSAwID8gMSA6IE1hdGguYWJzKDIgKiB0cmFuc2Zvcm1bNF0gLyB0cmFuc2Zvcm1bMl0pO1xuICB2YXIgdmVydGV4ID0gW2RpcmVjdGlvbiA9PT0gJ2xlZnQnID8gLWhCYXNlIDogZGlyZWN0aW9uID09PSAncmlnaHQnID8gaEJhc2UgOiAwLCBkaXJlY3Rpb24gPT09ICd0b3AnID8gLXZCYXNlIDogZGlyZWN0aW9uID09PSAnYm90dG9tJyA/IHZCYXNlIDogMF07XG4gIHZlcnRleCA9IGFwcGx5VHJhbnNmb3JtKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpO1xuICByZXR1cm4gTWF0aC5hYnModmVydGV4WzBdKSA+IE1hdGguYWJzKHZlcnRleFsxXSkgPyB2ZXJ0ZXhbMF0gPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IHZlcnRleFsxXSA+IDAgPyAnYm90dG9tJyA6ICd0b3AnO1xufVxuLyoqXG4gKiBBcHBseSBncm91cCB0cmFuc2l0aW9uIGFuaW1hdGlvbiBmcm9tIGcxIHRvIGcyLlxuICogSWYgbm8gYW5pbWF0YWJsZU1vZGVsLCBubyBhbmltYXRpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBncm91cFRyYW5zaXRpb24oZzEsIGcyLCBhbmltYXRhYmxlTW9kZWwsIGNiKSB7XG4gIGlmICghZzEgfHwgIWcyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxNYXAoZykge1xuICAgIHZhciBlbE1hcCA9IHt9O1xuICAgIGcudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICBpZiAoIWVsLmlzR3JvdXAgJiYgZWwuYW5pZCkge1xuICAgICAgICBlbE1hcFtlbC5hbmlkXSA9IGVsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlbE1hcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuaW1hdGFibGVQcm9wcyhlbCkge1xuICAgIHZhciBvYmogPSB7XG4gICAgICBwb3NpdGlvbjogdmVjdG9yLmNsb25lKGVsLnBvc2l0aW9uKSxcbiAgICAgIHJvdGF0aW9uOiBlbC5yb3RhdGlvblxuICAgIH07XG5cbiAgICBpZiAoZWwuc2hhcGUpIHtcbiAgICAgIG9iai5zaGFwZSA9IHpyVXRpbC5leHRlbmQoe30sIGVsLnNoYXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIGVsTWFwMSA9IGdldEVsTWFwKGcxKTtcbiAgZzIudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKCFlbC5pc0dyb3VwICYmIGVsLmFuaWQpIHtcbiAgICAgIHZhciBvbGRFbCA9IGVsTWFwMVtlbC5hbmlkXTtcblxuICAgICAgaWYgKG9sZEVsKSB7XG4gICAgICAgIHZhciBuZXdQcm9wID0gZ2V0QW5pbWF0YWJsZVByb3BzKGVsKTtcbiAgICAgICAgZWwuYXR0cihnZXRBbmltYXRhYmxlUHJvcHMob2xkRWwpKTtcbiAgICAgICAgdXBkYXRlUHJvcHMoZWwsIG5ld1Byb3AsIGFuaW1hdGFibGVNb2RlbCwgZWwuZGF0YUluZGV4KTtcbiAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAvLyAgICAgaWYgKGVsLnByZXZpb3VzUHJvcHMpIHtcbiAgICAgIC8vICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wc1xuICAgICAgLy8gICAgIH1cbiAgICAgIC8vIH1cblxuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcG9pbnRzIExpa2U6IFtbMjMsIDQ0XSwgWzUzLCA2Nl0sIC4uLl1cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gQSBuZXcgY2xpcHBlZCBwb2ludHMuXG4gKi9cblxuXG5mdW5jdGlvbiBjbGlwUG9pbnRzQnlSZWN0KHBvaW50cywgcmVjdCkge1xuICByZXR1cm4genJVdGlsLm1hcChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciB4ID0gcG9pbnRbMF07XG4gICAgeCA9IG1hdGhNYXgoeCwgcmVjdC54KTtcbiAgICB4ID0gbWF0aE1pbih4LCByZWN0LnggKyByZWN0LndpZHRoKTtcbiAgICB2YXIgeSA9IHBvaW50WzFdO1xuICAgIHkgPSBtYXRoTWF4KHksIHJlY3QueSk7XG4gICAgeSA9IG1hdGhNaW4oeSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgIHJldHVybiBbeCwgeV07XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0UmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBjbGlwcGVkIHJlY3QuIElmIHJlY3Qgc2l6ZSBhcmUgbmVnYXRpdmUsIHJldHVybiB1bmRlZmluZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBjbGlwUmVjdEJ5UmVjdCh0YXJnZXRSZWN0LCByZWN0KSB7XG4gIHZhciB4ID0gbWF0aE1heCh0YXJnZXRSZWN0LngsIHJlY3QueCk7XG4gIHZhciB4MiA9IG1hdGhNaW4odGFyZ2V0UmVjdC54ICsgdGFyZ2V0UmVjdC53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCk7XG4gIHZhciB5ID0gbWF0aE1heCh0YXJnZXRSZWN0LnksIHJlY3QueSk7XG4gIHZhciB5MiA9IG1hdGhNaW4odGFyZ2V0UmVjdC55ICsgdGFyZ2V0UmVjdC5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcblxuICBpZiAoeDIgPj0geCAmJiB5MiA+PSB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgd2lkdGg6IHgyIC0geCxcbiAgICAgIGhlaWdodDogeTIgLSB5XG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWNvblN0ciBTdXBwb3J0ICdpbWFnZTovLycgb3IgJ3BhdGg6Ly8nIG9yIGRpcmVjdCBzdmcgcGF0aC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XSBQcm9wZXJ0aWVzIG9mIGBtb2R1bGU6enJlbmRlci9FbGVtZW50YCwgZXhjZXB0IGBzdHlsZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlY3RdIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gSWNvbiBwYXRoIG9yIGltYWdlIGVsZW1lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVJY29uKGljb25TdHIsIG9wdCwgcmVjdCkge1xuICBvcHQgPSB6clV0aWwuZXh0ZW5kKHtcbiAgICByZWN0SG92ZXI6IHRydWVcbiAgfSwgb3B0KTtcbiAgdmFyIHN0eWxlID0gb3B0LnN0eWxlID0ge1xuICAgIHN0cm9rZU5vU2NhbGU6IHRydWVcbiAgfTtcbiAgcmVjdCA9IHJlY3QgfHwge1xuICAgIHg6IC0xLFxuICAgIHk6IC0xLFxuICAgIHdpZHRoOiAyLFxuICAgIGhlaWdodDogMlxuICB9O1xuXG4gIGlmIChpY29uU3RyKSB7XG4gICAgcmV0dXJuIGljb25TdHIuaW5kZXhPZignaW1hZ2U6Ly8nKSA9PT0gMCA/IChzdHlsZS5pbWFnZSA9IGljb25TdHIuc2xpY2UoOCksIHpyVXRpbC5kZWZhdWx0cyhzdHlsZSwgcmVjdCksIG5ldyBJbWFnZShvcHQpKSA6IG1ha2VQYXRoKGljb25TdHIucmVwbGFjZSgncGF0aDovLycsICcnKSwgb3B0LCByZWN0LCAnY2VudGVyJyk7XG4gIH1cbn1cblxuZXhwb3J0cy5leHRlbmRTaGFwZSA9IGV4dGVuZFNoYXBlO1xuZXhwb3J0cy5leHRlbmRQYXRoID0gZXh0ZW5kUGF0aDtcbmV4cG9ydHMubWFrZVBhdGggPSBtYWtlUGF0aDtcbmV4cG9ydHMubWFrZUltYWdlID0gbWFrZUltYWdlO1xuZXhwb3J0cy5tZXJnZVBhdGggPSBtZXJnZVBhdGg7XG5leHBvcnRzLnJlc2l6ZVBhdGggPSByZXNpemVQYXRoO1xuZXhwb3J0cy5zdWJQaXhlbE9wdGltaXplTGluZSA9IHN1YlBpeGVsT3B0aW1pemVMaW5lO1xuZXhwb3J0cy5zdWJQaXhlbE9wdGltaXplUmVjdCA9IHN1YlBpeGVsT3B0aW1pemVSZWN0O1xuZXhwb3J0cy5zdWJQaXhlbE9wdGltaXplID0gc3ViUGl4ZWxPcHRpbWl6ZTtcbmV4cG9ydHMuc2V0SG92ZXJTdHlsZSA9IHNldEhvdmVyU3R5bGU7XG5leHBvcnRzLnNldExhYmVsU3R5bGUgPSBzZXRMYWJlbFN0eWxlO1xuZXhwb3J0cy5zZXRUZXh0U3R5bGUgPSBzZXRUZXh0U3R5bGU7XG5leHBvcnRzLnNldFRleHQgPSBzZXRUZXh0O1xuZXhwb3J0cy5nZXRGb250ID0gZ2V0Rm9udDtcbmV4cG9ydHMudXBkYXRlUHJvcHMgPSB1cGRhdGVQcm9wcztcbmV4cG9ydHMuaW5pdFByb3BzID0gaW5pdFByb3BzO1xuZXhwb3J0cy5nZXRUcmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm07XG5leHBvcnRzLmFwcGx5VHJhbnNmb3JtID0gYXBwbHlUcmFuc2Zvcm07XG5leHBvcnRzLnRyYW5zZm9ybURpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbjtcbmV4cG9ydHMuZ3JvdXBUcmFuc2l0aW9uID0gZ3JvdXBUcmFuc2l0aW9uO1xuZXhwb3J0cy5jbGlwUG9pbnRzQnlSZWN0ID0gY2xpcFBvaW50c0J5UmVjdDtcbmV4cG9ydHMuY2xpcFJlY3RCeVJlY3QgPSBjbGlwUmVjdEJ5UmVjdDtcbmV4cG9ydHMuY3JlYXRlSWNvbiA9IGNyZWF0ZUljb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9ncmFwaGljLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgUkFESUFOX0VQU0lMT04gPSAxZS00O1xuXG5mdW5jdGlvbiBfdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbn1cbi8qKlxuICogTGluZWFyIG1hcHBpbmcgYSB2YWx1ZSBmcm9tIGRvbWFpbiB0byByYW5nZVxuICogQG1lbWJlck9mIG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyXG4gKiBAcGFyYW0gIHsobnVtYmVyfEFycmF5LjxudW1iZXI+KX0gdmFsXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZG9tYWluIERvbWFpbiBleHRlbnQgZG9tYWluWzBdIGNhbiBiZSBiaWdnZXIgdGhhbiBkb21haW5bMV1cbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByYW5nZSAgUmFuZ2UgZXh0ZW50IHJhbmdlWzBdIGNhbiBiZSBiaWdnZXIgdGhhbiByYW5nZVsxXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gY2xhbXBcbiAqIEByZXR1cm4geyhudW1iZXJ8QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG5mdW5jdGlvbiBsaW5lYXJNYXAodmFsLCBkb21haW4sIHJhbmdlLCBjbGFtcCkge1xuICB2YXIgc3ViRG9tYWluID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xuICB2YXIgc3ViUmFuZ2UgPSByYW5nZVsxXSAtIHJhbmdlWzBdO1xuXG4gIGlmIChzdWJEb21haW4gPT09IDApIHtcbiAgICByZXR1cm4gc3ViUmFuZ2UgPT09IDAgPyByYW5nZVswXSA6IChyYW5nZVswXSArIHJhbmdlWzFdKSAvIDI7XG4gIH0gLy8gQXZvaWQgYWNjdXJhY3kgcHJvYmxlbSBpbiBlZGdlLCBzdWNoIGFzXG4gIC8vIDE0Ni4zOSAtIDYyLjgzID09PSA4My41NTk5OTk5OTk5OTk5OS5cbiAgLy8gU2VlIGVjaGFydHMvdGVzdC91dC9zcGVjL3V0aWwvbnVtYmVyLmpzI2xpbmVhck1hcCNhY2N1cmFjeUVycm9yXG4gIC8vIEl0IGlzIGEgbGl0dGxlIHZlcmJvc2UgZm9yIGVmZmljaWVuY3kgY29uc2lkZXJpbmcgdGhpcyBtZXRob2RcbiAgLy8gaXMgYSBob3RzcG90LlxuXG5cbiAgaWYgKGNsYW1wKSB7XG4gICAgaWYgKHN1YkRvbWFpbiA+IDApIHtcbiAgICAgIGlmICh2YWwgPD0gZG9tYWluWzBdKSB7XG4gICAgICAgIHJldHVybiByYW5nZVswXTtcbiAgICAgIH0gZWxzZSBpZiAodmFsID49IGRvbWFpblsxXSkge1xuICAgICAgICByZXR1cm4gcmFuZ2VbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWwgPj0gZG9tYWluWzBdKSB7XG4gICAgICAgIHJldHVybiByYW5nZVswXTtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDw9IGRvbWFpblsxXSkge1xuICAgICAgICByZXR1cm4gcmFuZ2VbMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPT09IGRvbWFpblswXSkge1xuICAgICAgcmV0dXJuIHJhbmdlWzBdO1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IGRvbWFpblsxXSkge1xuICAgICAgcmV0dXJuIHJhbmdlWzFdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAodmFsIC0gZG9tYWluWzBdKSAvIHN1YkRvbWFpbiAqIHN1YlJhbmdlICsgcmFuZ2VbMF07XG59XG4vKipcbiAqIENvbnZlcnQgYSBwZXJjZW50IHN0cmluZyB0byBhYnNvbHV0ZSBudW1iZXIuXG4gKiBSZXR1cm5zIE5hTiBpZiBwZXJjZW50IGlzIG5vdCBhIHZhbGlkIHN0cmluZyBvciBudW1iZXJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZWNoYXJ0cy91dGlsL251bWJlclxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwZXJjZW50XG4gKiBAcGFyYW0ge251bWJlcn0gYWxsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVBlcmNlbnQocGVyY2VudCwgYWxsKSB7XG4gIHN3aXRjaCAocGVyY2VudCkge1xuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgIHBlcmNlbnQgPSAnNTAlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHBlcmNlbnQgPSAnMCUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHBlcmNlbnQgPSAnMTAwJSc7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGVyY2VudCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoX3RyaW0ocGVyY2VudCkubWF0Y2goLyUkLykpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpIC8gMTAwICogYWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpO1xuICB9XG5cbiAgcmV0dXJuIHBlcmNlbnQgPT0gbnVsbCA/IE5hTiA6ICtwZXJjZW50O1xufVxuLyoqXG4gKiAoMSkgRml4IHJvdW5kaW5nIGVycm9yIG9mIGZsb2F0IG51bWJlcnMuXG4gKiAoMikgU3VwcG9ydCByZXR1cm4gc3RyaW5nIHRvIGF2b2lkIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAnMy41ZS03Jy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb25dXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5TdHJdXG4gKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gcm91bmQoeCwgcHJlY2lzaW9uLCByZXR1cm5TdHIpIHtcbiAgaWYgKHByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgcHJlY2lzaW9uID0gMTA7XG4gIH0gLy8gQXZvaWQgcmFuZ2UgZXJyb3JcblxuXG4gIHByZWNpc2lvbiA9IE1hdGgubWluKE1hdGgubWF4KDAsIHByZWNpc2lvbiksIDIwKTtcbiAgeCA9ICgreCkudG9GaXhlZChwcmVjaXNpb24pO1xuICByZXR1cm4gcmV0dXJuU3RyID8geCA6ICt4O1xufVxuXG5mdW5jdGlvbiBhc2MoYXJyKSB7XG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9KTtcbiAgcmV0dXJuIGFycjtcbn1cbi8qKlxuICogR2V0IHByZWNpc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICovXG5cblxuZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKHZhbCkge1xuICB2YWwgPSArdmFsO1xuXG4gIGlmIChpc05hTih2YWwpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gSXQgaXMgbXVjaCBmYXN0ZXIgdGhhbiBtZXRob2RzIGNvbnZlcnRpbmcgbnVtYmVyIHRvIHN0cmluZyBhcyBmb2xsb3dzXG4gIC8vICAgICAgdmFyIHRtcCA9IHZhbC50b1N0cmluZygpO1xuICAvLyAgICAgIHJldHVybiB0bXAubGVuZ3RoIC0gMSAtIHRtcC5pbmRleE9mKCcuJyk7XG4gIC8vIGVzcGVjaWFsbHkgd2hlbiBwcmVjaXNpb24gaXMgbG93XG5cblxuICB2YXIgZSA9IDE7XG4gIHZhciBjb3VudCA9IDA7XG5cbiAgd2hpbGUgKE1hdGgucm91bmQodmFsICogZSkgLyBlICE9PSB2YWwpIHtcbiAgICBlICo9IDEwO1xuICAgIGNvdW50Kys7XG4gIH1cblxuICByZXR1cm4gY291bnQ7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQcmVjaXNpb25TYWZlKHZhbCkge1xuICB2YXIgc3RyID0gdmFsLnRvU3RyaW5nKCk7IC8vIENvbnNpZGVyIHNjaWVudGlmaWMgbm90YXRpb246ICczLjRlLTEyJyAnMy40ZSsxMidcblxuICB2YXIgZUluZGV4ID0gc3RyLmluZGV4T2YoJ2UnKTtcblxuICBpZiAoZUluZGV4ID4gMCkge1xuICAgIHZhciBwcmVjaXNpb24gPSArc3RyLnNsaWNlKGVJbmRleCArIDEpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPCAwID8gLXByZWNpc2lvbiA6IDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRvdEluZGV4ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICByZXR1cm4gZG90SW5kZXggPCAwID8gMCA6IHN0ci5sZW5ndGggLSAxIC0gZG90SW5kZXg7XG4gIH1cbn1cbi8qKlxuICogTWluaW1hbCBkaWNlcm5pYmxlIGRhdGEgcHJlY2lzaW9pbiBhY2NvcmRpbmcgdG8gYSBzaW5nbGUgcGl4ZWwuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YUV4dGVudFxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcGl4ZWxFeHRlbnRcbiAqIEByZXR1cm4ge251bWJlcn0gcHJlY2lzaW9uXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQaXhlbFByZWNpc2lvbihkYXRhRXh0ZW50LCBwaXhlbEV4dGVudCkge1xuICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gIHZhciBMTjEwID0gTWF0aC5MTjEwO1xuICB2YXIgZGF0YVF1YW50aXR5ID0gTWF0aC5mbG9vcihsb2coZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0pIC8gTE4xMCk7XG4gIHZhciBzaXplUXVhbnRpdHkgPSBNYXRoLnJvdW5kKGxvZyhNYXRoLmFicyhwaXhlbEV4dGVudFsxXSAtIHBpeGVsRXh0ZW50WzBdKSkgLyBMTjEwKTsgLy8gdG9GaXhlZCgpIGRpZ2l0cyBhcmd1bWVudCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjAuXG5cbiAgdmFyIHByZWNpc2lvbiA9IE1hdGgubWluKE1hdGgubWF4KC1kYXRhUXVhbnRpdHkgKyBzaXplUXVhbnRpdHksIDApLCAyMCk7XG4gIHJldHVybiAhaXNGaW5pdGUocHJlY2lzaW9uKSA/IDIwIDogcHJlY2lzaW9uO1xufVxuLyoqXG4gKiBHZXQgYSBkYXRhIG9mIGdpdmVuIHByZWNpc2lvbiwgYXNzdXJpbmcgdGhlIHN1bSBvZiBwZXJjZW50YWdlc1xuICogaW4gdmFsdWVMaXN0IGlzIDEuXG4gKiBUaGUgbGFyZ2VzdCByZW1haW5lciBtZXRob2QgaXMgdXNlZC5cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhcmdlc3RfcmVtYWluZGVyX21ldGhvZFxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlTGlzdCBhIGxpc3Qgb2YgYWxsIGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHggaW5kZXggb2YgdGhlIGRhdGEgdG8gYmUgcHJvY2Vzc2VkIGluIHZhbHVlTGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiBpbnRlZ2VyIG51bWJlciBzaG93aW5nIGRpZ2l0cyBvZiBwcmVjaXNpb25cbiAqIEByZXR1cm4ge251bWJlcn0gcGVyY2VudCByYW5naW5nIGZyb20gMCB0byAxMDBcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFBlcmNlbnRXaXRoUHJlY2lzaW9uKHZhbHVlTGlzdCwgaWR4LCBwcmVjaXNpb24pIHtcbiAgaWYgKCF2YWx1ZUxpc3RbaWR4XSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHN1bSA9IHpyVXRpbC5yZWR1Y2UodmFsdWVMaXN0LCBmdW5jdGlvbiAoYWNjLCB2YWwpIHtcbiAgICByZXR1cm4gYWNjICsgKGlzTmFOKHZhbCkgPyAwIDogdmFsKTtcbiAgfSwgMCk7XG5cbiAgaWYgKHN1bSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGRpZ2l0cyA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICB2YXIgdm90ZXNQZXJRdW90YSA9IHpyVXRpbC5tYXAodmFsdWVMaXN0LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIChpc05hTih2YWwpID8gMCA6IHZhbCkgLyBzdW0gKiBkaWdpdHMgKiAxMDA7XG4gIH0pO1xuICB2YXIgdGFyZ2V0U2VhdHMgPSBkaWdpdHMgKiAxMDA7XG4gIHZhciBzZWF0cyA9IHpyVXRpbC5tYXAodm90ZXNQZXJRdW90YSwgZnVuY3Rpb24gKHZvdGVzKSB7XG4gICAgLy8gQXNzaWduIGF1dG9tYXRpYyBzZWF0cy5cbiAgICByZXR1cm4gTWF0aC5mbG9vcih2b3Rlcyk7XG4gIH0pO1xuICB2YXIgY3VycmVudFN1bSA9IHpyVXRpbC5yZWR1Y2Uoc2VhdHMsIGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgIHJldHVybiBhY2MgKyB2YWw7XG4gIH0sIDApO1xuICB2YXIgcmVtYWluZGVyID0genJVdGlsLm1hcCh2b3Rlc1BlclF1b3RhLCBmdW5jdGlvbiAodm90ZXMsIGlkeCkge1xuICAgIHJldHVybiB2b3RlcyAtIHNlYXRzW2lkeF07XG4gIH0pOyAvLyBIYXMgcmVtYWluZGluZyB2b3Rlcy5cblxuICB3aGlsZSAoY3VycmVudFN1bSA8IHRhcmdldFNlYXRzKSB7XG4gICAgLy8gRmluZCBuZXh0IGxhcmdlc3QgcmVtYWluZGVyLlxuICAgIHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1heElkID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZW1haW5kZXIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmIChyZW1haW5kZXJbaV0gPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gcmVtYWluZGVyW2ldO1xuICAgICAgICBtYXhJZCA9IGk7XG4gICAgICB9XG4gICAgfSAvLyBBZGQgYSB2b3RlIHRvIG1heCByZW1haW5kZXIuXG5cblxuICAgICsrc2VhdHNbbWF4SWRdO1xuICAgIHJlbWFpbmRlclttYXhJZF0gPSAwO1xuICAgICsrY3VycmVudFN1bTtcbiAgfVxuXG4gIHJldHVybiBzZWF0c1tpZHhdIC8gZGlnaXRzO1xufSAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgaWUgZG8gbm90IHN1cHBvcnQuXG5cblxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuLyoqXG4gKiBUbyAwIC0gMiAqIFBJLCBjb25zaWRlcmluZyBuZWdhdGl2ZSByYWRpYW4uXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gcmVtUmFkaWFuKHJhZGlhbikge1xuICB2YXIgcGkyID0gTWF0aC5QSSAqIDI7XG4gIHJldHVybiAocmFkaWFuICUgcGkyICsgcGkyKSAlIHBpMjtcbn1cbi8qKlxuICogQHBhcmFtIHt0eXBlfSByYWRpYW5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1JhZGlhbkFyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiAtUkFESUFOX0VQU0lMT04gJiYgdmFsIDwgUkFESUFOX0VQU0lMT047XG59XG5cbnZhciBUSU1FX1JFRyA9IC9eKD86KFxcZHs0fSkoPzpbLVxcL10oXFxkezEsMn0pKD86Wy1cXC9dKFxcZHsxLDJ9KSg/OltUIF0oXFxkezEsMn0pKD86OihcXGRcXGQpKD86OihcXGRcXGQpKD86Wy4sXShcXGQrKSk/KT8pPyhafFtcXCtcXC1dXFxkXFxkOj9cXGRcXGQpPyk/KT8pPyk/JC87IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfERhdGV8bnVtYmVyfSB2YWx1ZSBUaGVzZSB2YWx1ZXMgY2FuIGJlIGFjY2VwdGVkOlxuICogICArIEFuIGluc3RhbmNlIG9mIERhdGUsIHJlcHJlc2VudCBhIHRpbWUgaW4gaXRzIG93biB0aW1lIHpvbmUuXG4gKiAgICsgT3Igc3RyaW5nIGluIGEgc3Vic2V0IG9mIElTTyA4NjAxLCBvbmx5IGluY2x1ZGluZzpcbiAqICAgICArIG9ubHkgeWVhciwgbW9udGgsIGRhdGU6ICcyMDEyLTAzJywgJzIwMTItMDMtMDEnLCAnMjAxMi0wMy0wMSAwNScsICcyMDEyLTAzLTAxIDA1OjA2JyxcbiAqICAgICArIHNlcGFyYXRlZCB3aXRoIFQgb3Igc3BhY2U6ICcyMDEyLTAzLTAxVDEyOjIyOjMzLjEyMycsICcyMDEyLTAzLTAxIDEyOjIyOjMzLjEyMycsXG4gKiAgICAgKyB0aW1lIHpvbmU6ICcyMDEyLTAzLTAxVDEyOjIyOjMzWicsICcyMDEyLTAzLTAxVDEyOjIyOjMzKzgwMDAnLCAnMjAxMi0wMy0wMVQxMjoyMjozMy0wNTowMCcsXG4gKiAgICAgYWxsIG9mIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCBhcyBsb2NhbCB0aW1lIGlmIHRpbWUgem9uZSBpcyBub3Qgc3BlY2lmaWVkXG4gKiAgICAgKHNlZSA8aHR0cHM6Ly9tb21lbnRqcy5jb20vPikuXG4gKiAgICsgT3Igb3RoZXIgc3RyaW5nIGZvcm1hdCwgaW5jbHVkaW5nIChhbGwgb2Ygd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGxvYWNhbCB0aW1lKTpcbiAqICAgICAnMjAxMicsICcyMDEyLTMtMScsICcyMDEyLzMvMScsICcyMDEyLzAzLzAxJyxcbiAqICAgICAnMjAwOS82LzEyIDI6MDAnLCAnMjAwOS82LzEyIDI6MDU6MDgnLCAnMjAwOS82LzEyIDI6MDU6MDguMTIzJ1xuICogICArIGEgdGltZXN0YW1wLCB3aGljaCByZXByZXNlbnQgYSB0aW1lIGluIFVUQy5cbiAqIEByZXR1cm4ge0RhdGV9IGRhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZURhdGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gRGlmZmVyZW50IGJyb3dzZXJzIHBhcnNlIGRhdGUgaW4gZGlmZmVyZW50IHdheSwgc28gd2UgcGFyc2UgaXQgbWFudWFsbHkuXG4gICAgLy8gU29tZSBvdGhlciBpc3N1ZXM6XG4gICAgLy8gbmV3IERhdGUoJzE5NzAtMDEtMDEnKSBpcyBVVEMsXG4gICAgLy8gbmV3IERhdGUoJzE5NzAvMDEvMDEnKSBhbmQgbmV3IERhdGUoJzE5NzAtMS0wMScpIGlzIGxvY2FsLlxuICAgIC8vIFNlZSBpc3N1ZSAjMzYyM1xuICAgIHZhciBtYXRjaCA9IFRJTUVfUkVHLmV4ZWModmFsdWUpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgLy8gcmV0dXJuIEludmFsaWQgRGF0ZS5cbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH0gLy8gVXNlIGxvY2FsIHRpbWUgd2hlbiBubyB0aW1lem9uZSBvZmZzZXQgc3BlY2lmZWQuXG5cblxuICAgIGlmICghbWF0Y2hbOF0pIHtcbiAgICAgIC8vIG1hdGNoW25dIGNhbiBvbmx5IGJlIHN0cmluZyBvciB1bmRlZmluZWQuXG4gICAgICAvLyBCdXQgdGFrZSBjYXJlIG9mICcxMicgKyAxID0+ICcxMjEnLlxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCttYXRjaFsxXSwgKyhtYXRjaFsyXSB8fCAxKSAtIDEsICttYXRjaFszXSB8fCAxLCArbWF0Y2hbNF0gfHwgMCwgKyhtYXRjaFs1XSB8fCAwKSwgK21hdGNoWzZdIHx8IDAsICttYXRjaFs3XSB8fCAwKTtcbiAgICB9IC8vIFRpbWV6b25lb2Zmc2V0IG9mIEphdmFzY3JpcHQgRGF0ZSBoYXMgY29uc2lkZXJlZCBEU1QgKERheWxpZ2h0IFNhdmluZyBUaW1lLFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRheWxpZ2h0LXNhdmluZy10aW1lLWFkanVzdG1lbnQpLlxuICAgIC8vIEZvciBleGFtcGxlLCBzeXN0ZW0gdGltZXpvbmUgaXMgc2V0IGFzIFwiVGltZSBab25lOiBBbWVyaWNhL1Rvcm9udG9cIixcbiAgICAvLyB0aGVuIHRoZXNlIGNvZGUgd2lsbCBnZXQgZGlmZmVyZW50IHJlc3VsdDpcbiAgICAvLyBgbmV3IERhdGUoMTQ3ODQxMTk5OTk5OSkuZ2V0VGltZXpvbmVPZmZzZXQoKTsgIC8vIGdldCAyNDBgXG4gICAgLy8gYG5ldyBEYXRlKDE0Nzg0MTIwMDAwMDApLmdldFRpbWV6b25lT2Zmc2V0KCk7ICAvLyBnZXQgMzAwYFxuICAgIC8vIFNvIHdlIHNob3VsZCBub3QgdXNlIGBuZXcgRGF0ZWAsIGJ1dCB1c2UgYERhdGUuVVRDYC5cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGhvdXIgPSArbWF0Y2hbNF0gfHwgMDtcblxuICAgICAgICBpZiAobWF0Y2hbOF0udG9VcHBlckNhc2UoKSAhPT0gJ1onKSB7XG4gICAgICAgICAgaG91ciAtPSBtYXRjaFs4XS5zbGljZSgwLCAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrbWF0Y2hbMV0sICsobWF0Y2hbMl0gfHwgMSkgLSAxLCArbWF0Y2hbM10gfHwgMSwgaG91ciwgKyhtYXRjaFs1XSB8fCAwKSwgK21hdGNoWzZdIHx8IDAsICttYXRjaFs3XSB8fCAwKSk7XG4gICAgICB9XG4gIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKE1hdGgucm91bmQodmFsdWUpKTtcbn1cbi8qKlxuICogUXVhbnRpdHkgb2YgYSBudW1iZXIuIGUuZy4gMC4xLCAxLCAxMCwgMTAwXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YW50aXR5KHZhbCkge1xuICByZXR1cm4gTWF0aC5wb3coMTAsIHF1YW50aXR5RXhwb25lbnQodmFsKSk7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXR5RXhwb25lbnQodmFsKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMTApO1xufVxuLyoqXG4gKiBmaW5kIGEg4oCcbmljZeKAnSBudW1iZXIgYXBwcm94aW1hdGVseSBlcXVhbCB0byB4LiBSb3VuZCB0aGUgbnVtYmVyIGlmIHJvdW5kID0gdHJ1ZSxcbiAqIHRha2UgY2VpbGluZyBpZiByb3VuZCA9IGZhbHNlLiBUaGUgcHJpbWFyeSBvYnNlcnZhdGlvbiBpcyB0aGF0IHRoZSDigJxuaWNlc3TigJ1cbiAqIG51bWJlcnMgaW4gZGVjaW1hbCBhcmUgMSwgMiwgYW5kIDUsIGFuZCBhbGwgcG93ZXItb2YtdGVuIG11bHRpcGxlcyBvZiB0aGVzZSBudW1iZXJzLlxuICpcbiAqIFNlZSBcIk5pY2UgTnVtYmVycyBmb3IgR3JhcGggTGFiZWxzXCIgb2YgR3JhcGhpYyBHZW1zLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsIE5vbi1uZWdhdGl2ZSB2YWx1ZS5cbiAqIEBwYXJhbSAge2Jvb2xlYW59IHJvdW5kXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBuaWNlKHZhbCwgcm91bmQpIHtcbiAgdmFyIGV4cG9uZW50ID0gcXVhbnRpdHlFeHBvbmVudCh2YWwpO1xuICB2YXIgZXhwMTAgPSBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuICB2YXIgZiA9IHZhbCAvIGV4cDEwOyAvLyAxIDw9IGYgPCAxMFxuXG4gIHZhciBuZjtcblxuICBpZiAocm91bmQpIHtcbiAgICBpZiAoZiA8IDEuNSkge1xuICAgICAgbmYgPSAxO1xuICAgIH0gZWxzZSBpZiAoZiA8IDIuNSkge1xuICAgICAgbmYgPSAyO1xuICAgIH0gZWxzZSBpZiAoZiA8IDQpIHtcbiAgICAgIG5mID0gMztcbiAgICB9IGVsc2UgaWYgKGYgPCA3KSB7XG4gICAgICBuZiA9IDU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5mID0gMTA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChmIDwgMSkge1xuICAgICAgbmYgPSAxO1xuICAgIH0gZWxzZSBpZiAoZiA8IDIpIHtcbiAgICAgIG5mID0gMjtcbiAgICB9IGVsc2UgaWYgKGYgPCAzKSB7XG4gICAgICBuZiA9IDM7XG4gICAgfSBlbHNlIGlmIChmIDwgNSkge1xuICAgICAgbmYgPSA1O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZiA9IDEwO1xuICAgIH1cbiAgfVxuXG4gIHZhbCA9IG5mICogZXhwMTA7IC8vIEZpeCAzICogMC4xID09PSAwLjMwMDAwMDAwMDAwMDAwMDA0IGlzc3VlIChzZWUgSUVFRSA3NTQpLlxuICAvLyAyMCBpcyB0aGUgdXBwcGVyIGJvdW5kIG9mIHRvRml4ZWQuXG5cbiAgcmV0dXJuIGV4cG9uZW50ID49IC0yMCA/ICt2YWwudG9GaXhlZChleHBvbmVudCA8IDAgPyAtZXhwb25lbnQgOiAwKSA6IHZhbDtcbn1cbi8qKlxuICogT3JkZXIgaW50ZXJ2YWxzIGFzYywgYW5kIHNwbGl0IHRoZW0gd2hlbiBvdmVybGFwLlxuICogZXhwZWN0KG51bWJlclV0aWwucmVmb3JtSW50ZXJ2YWxzKFtcbiAqICAgICB7aW50ZXJ2YWw6IFsxOCwgNjJdLCBjbG9zZTogWzEsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFstSW5maW5pdHksIC03MF0sIGNsb3NlOiBbMCwgMF19LFxuICogICAgIHtpbnRlcnZhbDogWy03MCwgLTI2XSwgY2xvc2U6IFsxLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbLTI2LCAxOF0sIGNsb3NlOiBbMSwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWzYyLCAxNTBdLCBjbG9zZTogWzEsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFsxMDYsIDE1MF0sIGNsb3NlOiBbMSwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWzE1MCwgSW5maW5pdHldLCBjbG9zZTogWzAsIDBdfVxuICogXSkpLnRvRXF1YWwoW1xuICogICAgIHtpbnRlcnZhbDogWy1JbmZpbml0eSwgLTcwXSwgY2xvc2U6IFswLCAwXX0sXG4gKiAgICAge2ludGVydmFsOiBbLTcwLCAtMjZdLCBjbG9zZTogWzEsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFstMjYsIDE4XSwgY2xvc2U6IFswLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbMTgsIDYyXSwgY2xvc2U6IFswLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbNjIsIDE1MF0sIGNsb3NlOiBbMCwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWzE1MCwgSW5maW5pdHldLCBjbG9zZTogWzAsIDBdfVxuICogXSk7XG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBsaXN0LCB3aGVyZSBgY2xvc2VgIG1lYW4gb3BlbiBvciBjbG9zZVxuICogICAgICAgIG9mIHRoZSBpbnRlcnZhbCwgYW5kIEluZmluaXR5IGNhbiBiZSB1c2VkLlxuICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59IFRoZSBvcmlnaW4gbGlzdCwgd2hpY2ggaGFzIGJlZW4gcmVmb3JtZWQuXG4gKi9cblxuXG5mdW5jdGlvbiByZWZvcm1JbnRlcnZhbHMobGlzdCkge1xuICBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gbGl0dGxlVGhhbihhLCBiLCAwKSA/IC0xIDogMTtcbiAgfSk7XG4gIHZhciBjdXJyID0gLUluZmluaXR5O1xuICB2YXIgY3VyckNsb3NlID0gMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOykge1xuICAgIHZhciBpbnRlcnZhbCA9IGxpc3RbaV0uaW50ZXJ2YWw7XG4gICAgdmFyIGNsb3NlID0gbGlzdFtpXS5jbG9zZTtcblxuICAgIGZvciAodmFyIGxnID0gMDsgbGcgPCAyOyBsZysrKSB7XG4gICAgICBpZiAoaW50ZXJ2YWxbbGddIDw9IGN1cnIpIHtcbiAgICAgICAgaW50ZXJ2YWxbbGddID0gY3VycjtcbiAgICAgICAgY2xvc2VbbGddID0gIWxnID8gMSAtIGN1cnJDbG9zZSA6IDE7XG4gICAgICB9XG5cbiAgICAgIGN1cnIgPSBpbnRlcnZhbFtsZ107XG4gICAgICBjdXJyQ2xvc2UgPSBjbG9zZVtsZ107XG4gICAgfVxuXG4gICAgaWYgKGludGVydmFsWzBdID09PSBpbnRlcnZhbFsxXSAmJiBjbG9zZVswXSAqIGNsb3NlWzFdICE9PSAxKSB7XG4gICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaXN0O1xuXG4gIGZ1bmN0aW9uIGxpdHRsZVRoYW4oYSwgYiwgbGcpIHtcbiAgICByZXR1cm4gYS5pbnRlcnZhbFtsZ10gPCBiLmludGVydmFsW2xnXSB8fCBhLmludGVydmFsW2xnXSA9PT0gYi5pbnRlcnZhbFtsZ10gJiYgKGEuY2xvc2VbbGddIC0gYi5jbG9zZVtsZ10gPT09ICghbGcgPyAxIDogLTEpIHx8ICFsZyAmJiBsaXR0bGVUaGFuKGEsIGIsIDEpKTtcbiAgfVxufVxuLyoqXG4gKiBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG4gKiAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG4gKiBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAqXG4gKiBAcGFyYW0geyp9IHZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc051bWVyaWModikge1xuICByZXR1cm4gdiAtIHBhcnNlRmxvYXQodikgPj0gMDtcbn1cblxuZXhwb3J0cy5saW5lYXJNYXAgPSBsaW5lYXJNYXA7XG5leHBvcnRzLnBhcnNlUGVyY2VudCA9IHBhcnNlUGVyY2VudDtcbmV4cG9ydHMucm91bmQgPSByb3VuZDtcbmV4cG9ydHMuYXNjID0gYXNjO1xuZXhwb3J0cy5nZXRQcmVjaXNpb24gPSBnZXRQcmVjaXNpb247XG5leHBvcnRzLmdldFByZWNpc2lvblNhZmUgPSBnZXRQcmVjaXNpb25TYWZlO1xuZXhwb3J0cy5nZXRQaXhlbFByZWNpc2lvbiA9IGdldFBpeGVsUHJlY2lzaW9uO1xuZXhwb3J0cy5nZXRQZXJjZW50V2l0aFByZWNpc2lvbiA9IGdldFBlcmNlbnRXaXRoUHJlY2lzaW9uO1xuZXhwb3J0cy5NQVhfU0FGRV9JTlRFR0VSID0gTUFYX1NBRkVfSU5URUdFUjtcbmV4cG9ydHMucmVtUmFkaWFuID0gcmVtUmFkaWFuO1xuZXhwb3J0cy5pc1JhZGlhbkFyb3VuZFplcm8gPSBpc1JhZGlhbkFyb3VuZFplcm87XG5leHBvcnRzLnBhcnNlRGF0ZSA9IHBhcnNlRGF0ZTtcbmV4cG9ydHMucXVhbnRpdHkgPSBxdWFudGl0eTtcbmV4cG9ydHMubmljZSA9IG5pY2U7XG5leHBvcnRzLnJlZm9ybUludGVydmFscyA9IHJlZm9ybUludGVydmFscztcbmV4cG9ydHMuaXNOdW1lcmljID0gaXNOdW1lcmljO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbnVtYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcblxudmFyIG51Ym1lclV0aWwgPSByZXF1aXJlKFwiLi9udW1iZXJcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcbi8qKlxuICogSWYgdmFsdWUgaXMgbm90IGFycmF5LCB0aGVuIHRyYW5zbGF0ZSBpdCB0byBhcnJheS5cbiAqIEBwYXJhbSAgeyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtBcnJheX0gW3ZhbHVlXSBvciB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgPyB2YWx1ZSA6IHZhbHVlID09IG51bGwgPyBbXSA6IFt2YWx1ZV07XG59XG4vKipcbiAqIFN5bmMgZGVmYXVsdCBvcHRpb24gYmV0d2VlbiBub3JtYWwgYW5kIGVtcGhhc2lzIGxpa2UgYHBvc2l0aW9uYCBhbmQgYHNob3dgXG4gKiBJbiBjYXNlIHNvbWUgb25lIHdpbGwgd3JpdGUgY29kZSBsaWtlXG4gKiAgICAgbGFiZWw6IHtcbiAqICAgICAgICAgbm9ybWFsOiB7XG4gKiAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAqICAgICAgICAgICAgIHBvc2l0aW9uOiAnb3V0c2lkZScsXG4gKiAgICAgICAgICAgICBmb250U2l6ZTogMThcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgZW1waGFzaXM6IHtcbiAqICAgICAgICAgICAgIHNob3c6IHRydWVcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHN1Yk9wdHNcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZmF1bHRFbXBoYXNpcyhvcHQsIHN1Yk9wdHMpIHtcbiAgaWYgKG9wdCkge1xuICAgIHZhciBlbXBoYXNpc09wdCA9IG9wdC5lbXBoYXNpcyA9IG9wdC5lbXBoYXNpcyB8fCB7fTtcbiAgICB2YXIgbm9ybWFsT3B0ID0gb3B0Lm5vcm1hbCA9IG9wdC5ub3JtYWwgfHwge307IC8vIERlZmF1bHQgZW1waGFzaXMgb3B0aW9uIGZyb20gbm9ybWFsXG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3ViT3B0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHN1Yk9wdE5hbWUgPSBzdWJPcHRzW2ldO1xuXG4gICAgICBpZiAoIWVtcGhhc2lzT3B0Lmhhc093blByb3BlcnR5KHN1Yk9wdE5hbWUpICYmIG5vcm1hbE9wdC5oYXNPd25Qcm9wZXJ0eShzdWJPcHROYW1lKSkge1xuICAgICAgICBlbXBoYXNpc09wdFtzdWJPcHROYW1lXSA9IG5vcm1hbE9wdFtzdWJPcHROYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFRFWFRfU1RZTEVfT1BUSU9OUyA9IFsnZm9udFN0eWxlJywgJ2ZvbnRXZWlnaHQnLCAnZm9udFNpemUnLCAnZm9udEZhbWlseScsICdyaWNoJywgJ3RhZycsICdjb2xvcicsICd0ZXh0Qm9yZGVyQ29sb3InLCAndGV4dEJvcmRlcldpZHRoJywgJ3dpZHRoJywgJ2hlaWdodCcsICdsaW5lSGVpZ2h0JywgJ2FsaWduJywgJ3ZlcnRpY2FsQWxpZ24nLCAnYmFzZWxpbmUnLCAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknLCAndGV4dFNoYWRvd0NvbG9yJywgJ3RleHRTaGFkb3dCbHVyJywgJ3RleHRTaGFkb3dPZmZzZXRYJywgJ3RleHRTaGFkb3dPZmZzZXRZJywgJ2JhY2tncm91bmRDb2xvcicsICdib3JkZXJDb2xvcicsICdib3JkZXJXaWR0aCcsICdib3JkZXJSYWRpdXMnLCAncGFkZGluZyddOyAvLyBtb2RlbFV0aWwuTEFCRUxfT1BUSU9OUyA9IG1vZGVsVXRpbC5URVhUX1NUWUxFX09QVElPTlMuY29uY2F0KFtcbi8vICAgICAncG9zaXRpb24nLCAnb2Zmc2V0JywgJ3JvdGF0ZScsICdvcmlnaW4nLCAnc2hvdycsICdkaXN0YW5jZScsICdmb3JtYXR0ZXInLFxuLy8gICAgICdmb250U3R5bGUnLCAnZm9udFdlaWdodCcsICdmb250U2l6ZScsICdmb250RmFtaWx5Jyxcbi8vICAgICAvLyBGSVhNRTogZGVwcmVjYXRlZCwgY2hlY2sgYW5kIHJlbW92ZSBpdC5cbi8vICAgICAndGV4dFN0eWxlJ1xuLy8gXSk7XG5cbi8qKlxuICogZGF0YSBjb3VsZCBiZSBbMTIsIDIzMjMsIHt2YWx1ZTogMjIzfSwgWzEyMjEsIDIzXSwge3ZhbHVlOiBbMiwgMjNdfV1cbiAqIFRoaXMgaGVscGVyIG1ldGhvZCByZXRpZXZlcyB2YWx1ZSBmcm9tIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8RGF0ZXxBcnJheXxPYmplY3R9IGRhdGFJdGVtXG4gKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfERhdGV8QXJyYXkuPG51bWJlcnxzdHJpbmd8RGF0ZT59XG4gKi9cblxuZnVuY3Rpb24gZ2V0RGF0YUl0ZW1WYWx1ZShkYXRhSXRlbSkge1xuICAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIHJldHVybiBkYXRhSXRlbSAmJiAoZGF0YUl0ZW0udmFsdWUgPT0gbnVsbCA/IGRhdGFJdGVtIDogZGF0YUl0ZW0udmFsdWUpO1xufVxuLyoqXG4gKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxuICogVGhpcyBoZWxwZXIgbWV0aG9kIGRldGVybWluZSBpZiBkYXRhSXRlbSBoYXMgZXh0cmEgb3B0aW9uIGJlc2lkZXMgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxEYXRlfEFycmF5fE9iamVjdH0gZGF0YUl0ZW1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRGF0YUl0ZW1PcHRpb24oZGF0YUl0ZW0pIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGRhdGFJdGVtKSAmJiAhKGRhdGFJdGVtIGluc3RhbmNlb2YgQXJyYXkpOyAvLyAvLyBtYXJrTGluZSBkYXRhIGNhbiBiZSBhcnJheVxuICAvLyAmJiAhKGRhdGFJdGVtWzBdICYmIGlzT2JqZWN0KGRhdGFJdGVtWzBdKSAmJiAhKGRhdGFJdGVtWzBdIGluc3RhbmNlb2YgQXJyYXkpKTtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgbWV0aG9kIGNvbnZlcnQgdmFsdWUgaW4gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxEYXRlfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbZGltSW5mb10gSWYgc3RyaW5nIChsaWtlICd4JyksIGRpbVR5cGUgZGVmYXVsdHMgJ251bWJlcicuXG4gKi9cblxuXG5mdW5jdGlvbiBjb252ZXJEYXRhVmFsdWUodmFsdWUsIGRpbUluZm8pIHtcbiAgLy8gUGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICB2YXIgZGltVHlwZSA9IGRpbUluZm8gJiYgZGltSW5mby50eXBlO1xuXG4gIGlmIChkaW1UeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoZGltVHlwZSA9PT0gJ3RpbWUnIC8vIHNwZWFkIHVwIHdoZW4gdXNpbmcgdGltZXN0YW1wXG4gICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gJy0nKSB7XG4gICAgdmFsdWUgPSArbnVibWVyVXRpbC5wYXJzZURhdGUodmFsdWUpO1xuICB9IC8vIGRpbVR5cGUgZGVmYXVsdHMgJ251bWJlcicuXG4gIC8vIElmIGRpbVR5cGUgaXMgbm90IG9yZGluYWwgYW5kIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIE5hTiBvciAnLScsXG4gIC8vIHBhcnNlIHRvIE5hTi5cblxuXG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSAnJyA/IE5hTiA6ICt2YWx1ZTsgLy8gSWYgc3RyaW5nIChsaWtlICctJyksIHVzaW5nICcrJyBwYXJzZSB0byBOYU5cbn1cbi8qKlxuICogQ3JlYXRlIGEgbW9kZWwgcHJveHkgdG8gYmUgdXNlZCBpbiB0b29sdGlwIGZvciBlZGdlIGRhdGEsIG1hcmtMaW5lIGRhdGEsIG1hcmtQb2ludCBkYXRhLlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LnNlcmllc0luZGV4XVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQubmFtZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0Lm1haW5UeXBlXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQuc3ViVHlwZV1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGFGb3JtYXRNb2RlbChkYXRhLCBvcHQpIHtcbiAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKCk7XG4gIHpyVXRpbC5taXhpbihtb2RlbCwgZGF0YUZvcm1hdE1peGluKTtcbiAgbW9kZWwuc2VyaWVzSW5kZXggPSBvcHQuc2VyaWVzSW5kZXg7XG4gIG1vZGVsLm5hbWUgPSBvcHQubmFtZSB8fCAnJztcbiAgbW9kZWwubWFpblR5cGUgPSBvcHQubWFpblR5cGU7XG4gIG1vZGVsLnN1YlR5cGUgPSBvcHQuc3ViVHlwZTtcblxuICBtb2RlbC5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBtb2RlbDtcbn0gLy8gUEVORElORyBBIGxpdHRsZSB1Z2x5XG5cblxudmFyIGRhdGFGb3JtYXRNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEdldCBwYXJhbXMgZm9yIGZvcm1hdHRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldERhdGFQYXJhbXM6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGFUeXBlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgIHZhciByYXdWYWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgdmFyIHJhd0RhdGFJbmRleCA9IGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KTtcbiAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgsIHRydWUpO1xuICAgIHZhciBpdGVtT3B0ID0gZGF0YS5nZXRSYXdEYXRhSXRlbShkYXRhSW5kZXgpO1xuICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdjb2xvcicpO1xuICAgIHJldHVybiB7XG4gICAgICBjb21wb25lbnRUeXBlOiB0aGlzLm1haW5UeXBlLFxuICAgICAgY29tcG9uZW50U3ViVHlwZTogdGhpcy5zdWJUeXBlLFxuICAgICAgc2VyaWVzVHlwZTogdGhpcy5tYWluVHlwZSA9PT0gJ3NlcmllcycgPyB0aGlzLnN1YlR5cGUgOiBudWxsLFxuICAgICAgc2VyaWVzSW5kZXg6IHRoaXMuc2VyaWVzSW5kZXgsXG4gICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgIHNlcmllc05hbWU6IHRoaXMubmFtZSxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkYXRhSW5kZXg6IHJhd0RhdGFJbmRleCxcbiAgICAgIGRhdGE6IGl0ZW1PcHQsXG4gICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXG4gICAgICB2YWx1ZTogcmF3VmFsdWUsXG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICBtYXJrZXI6IGZvcm1hdFV0aWwuZ2V0VG9vbHRpcE1hcmtlcihjb2xvciksXG4gICAgICAvLyBQYXJhbSBuYW1lIGxpc3QgZm9yIG1hcHBpbmcgYGFgLCBgYmAsIGBjYCwgYGRgLCBgZWBcbiAgICAgICR2YXJzOiBbJ3Nlcmllc05hbWUnLCAnbmFtZScsICd2YWx1ZSddXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogRm9ybWF0IGxhYmVsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0dXM9J25vcm1hbCddICdub3JtYWwnIG9yICdlbXBoYXNpcydcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW1JbmRleF1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbFByb3A9J2xhYmVsJ11cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0Rm9ybWF0dGVkTGFiZWw6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIHN0YXR1cywgZGF0YVR5cGUsIGRpbUluZGV4LCBsYWJlbFByb3ApIHtcbiAgICBzdGF0dXMgPSBzdGF0dXMgfHwgJ25vcm1hbCc7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG5cbiAgICBpZiAoZGltSW5kZXggIT0gbnVsbCAmJiBwYXJhbXMudmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcGFyYW1zLnZhbHVlID0gcGFyYW1zLnZhbHVlW2RpbUluZGV4XTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGVyID0gaXRlbU1vZGVsLmdldChbbGFiZWxQcm9wIHx8ICdsYWJlbCcsIHN0YXR1cywgJ2Zvcm1hdHRlciddKTtcblxuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJhbXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihwYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmb3JtYXRVdGlsLmZvcm1hdFRwbChmb3JtYXR0ZXIsIHBhcmFtcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcmF3IHZhbHVlIGluIG9wdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFJhd1ZhbHVlOiBmdW5jdGlvbiAoaWR4LCBkYXRhVHlwZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKGRhdGFUeXBlKTtcbiAgICB2YXIgZGF0YUl0ZW0gPSBkYXRhLmdldFJhd0RhdGFJdGVtKGlkeCk7XG5cbiAgICBpZiAoZGF0YUl0ZW0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KGRhdGFJdGVtKSAmJiAhKGRhdGFJdGVtIGluc3RhbmNlb2YgQXJyYXkpID8gZGF0YUl0ZW0udmFsdWUgOiBkYXRhSXRlbTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aXBsZVNlcmllcz1mYWxzZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhVHlwZV1cbiAgICogQHJldHVybiB7c3RyaW5nfSB0b29sdGlwIHN0cmluZ1xuICAgKi9cbiAgZm9ybWF0VG9vbHRpcDogenJVdGlsLm5vb3Bcbn07XG4vKipcbiAqIE1hcHBpbmcgdG8gZXhpc3RzIGZvciBtZXJnZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnQ+fSBleGlzdHNcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5LjxPYmplY3Q+fSBuZXdDcHRPcHRpb25zXG4gKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gUmVzdWx0LCBsaWtlIFt7ZXhpc3Q6IC4uLiwgb3B0aW9uOiAuLi59LCB7fV0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggb2Ygd2hpY2ggaXMgdGhlIHNhbWUgYXMgZXhpc3RzLlxuICovXG5cbmZ1bmN0aW9uIG1hcHBpbmdUb0V4aXN0cyhleGlzdHMsIG5ld0NwdE9wdGlvbnMpIHtcbiAgLy8gTWFwcGluZyBieSB0aGUgb3JkZXIgYnkgb3JpZ2luYWwgb3B0aW9uIChidXQgbm90IG9yZGVyIG9mXG4gIC8vIG5ldyBvcHRpb24pIGluIG1lcmdlIG1vZGUuIEJlY2F1c2Ugd2Ugc2hvdWxkIGVuc3VyZVxuICAvLyBzb21lIHNwZWNpZmllZCBpbmRleCAobGlrZSB4QXhpc0luZGV4KSBpcyBjb25zaXN0ZW50IHdpdGhcbiAgLy8gb3JpZ2luYWwgb3B0aW9uLCB3aGljaCBpcyBlYXN5IHRvIHVuZGVyc3RhbmQsIGVzcGF0aWFsbHkgaW5cbiAgLy8gbWVkaWEgcXVlcnkuIEFuZCBpbiBtb3N0IGNhc2UsIG1lcmdlIG9wdGlvbiBpcyB1c2VkIHRvXG4gIC8vIHVwZGF0ZSBwYXJ0aWFsIG9wdGlvbiBidXQgbm90IGJlIGV4cGVjdGVkIHRvIGNoYW5nZSBvcmRlci5cbiAgbmV3Q3B0T3B0aW9ucyA9IChuZXdDcHRPcHRpb25zIHx8IFtdKS5zbGljZSgpO1xuICB2YXIgcmVzdWx0ID0genJVdGlsLm1hcChleGlzdHMgfHwgW10sIGZ1bmN0aW9uIChvYmosIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4aXN0OiBvYmpcbiAgICB9O1xuICB9KTsgLy8gTWFwcGluZyBieSBpZCBvciBuYW1lIGlmIHNwZWNpZmllZC5cblxuICBlYWNoKG5ld0NwdE9wdGlvbnMsIGZ1bmN0aW9uIChjcHRPcHRpb24sIGluZGV4KSB7XG4gICAgaWYgKCFpc09iamVjdChjcHRPcHRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBpZCBoYXMgaGlnaGVzdCBwcmlvcml0eS5cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcmVzdWx0W2ldLm9wdGlvbiAvLyBDb25zaWRlciBuYW1lOiB0d28gbWFwIHRvIG9uZS5cbiAgICAgICYmIGNwdE9wdGlvbi5pZCAhPSBudWxsICYmIHJlc3VsdFtpXS5leGlzdC5pZCA9PT0gY3B0T3B0aW9uLmlkICsgJycpIHtcbiAgICAgICAgcmVzdWx0W2ldLm9wdGlvbiA9IGNwdE9wdGlvbjtcbiAgICAgICAgbmV3Q3B0T3B0aW9uc1tpbmRleF0gPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBleGlzdCA9IHJlc3VsdFtpXS5leGlzdDtcblxuICAgICAgaWYgKCFyZXN1bHRbaV0ub3B0aW9uIC8vIENvbnNpZGVyIG5hbWU6IHR3byBtYXAgdG8gb25lLlxuICAgICAgLy8gQ2FuIG5vdCBtYXRjaCB3aGVuIGJvdGggaWRzIGV4aXN0IGJ1dCBkaWZmZXJlbnQuXG4gICAgICAmJiAoZXhpc3QuaWQgPT0gbnVsbCB8fCBjcHRPcHRpb24uaWQgPT0gbnVsbCkgJiYgY3B0T3B0aW9uLm5hbWUgIT0gbnVsbCAmJiAhaXNJZElubmVyKGNwdE9wdGlvbikgJiYgIWlzSWRJbm5lcihleGlzdCkgJiYgZXhpc3QubmFtZSA9PT0gY3B0T3B0aW9uLm5hbWUgKyAnJykge1xuICAgICAgICByZXN1bHRbaV0ub3B0aW9uID0gY3B0T3B0aW9uO1xuICAgICAgICBuZXdDcHRPcHRpb25zW2luZGV4XSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBPdGhlcndpc2UgbWFwcGluZyBieSBpbmRleC5cblxuICBlYWNoKG5ld0NwdE9wdGlvbnMsIGZ1bmN0aW9uIChjcHRPcHRpb24sIGluZGV4KSB7XG4gICAgaWYgKCFpc09iamVjdChjcHRPcHRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBleGlzdCA9IHJlc3VsdFtpXS5leGlzdDtcblxuICAgICAgaWYgKCFyZXN1bHRbaV0ub3B0aW9uIC8vIEV4aXN0aW5nIG1vZGVsIHRoYXQgYWxyZWFkeSBoYXMgaWQgc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgIC8vIG1hcHBlZCB0byAoYmVjYXVzZSBhZnRlciBtYXBwaW5nIHBlcmZvcm1lZCBtb2RlbCBtYXlcbiAgICAgIC8vIGJlIGFzc2lnbmVkIHdpdGggYSBpZCwgd2hpc2ggc2hvdWxkIG5vdCBhZmZlY3QgbmV4dFxuICAgICAgLy8gbWFwcGluZyksIGV4Y2VwdCB0aG9zZSBoYXMgaW5uZXIgaWQuXG4gICAgICAmJiAhaXNJZElubmVyKGV4aXN0KSAvLyBDYXV0aW9uOlxuICAgICAgLy8gRG8gbm90IG92ZXJ3cml0ZSBpZC4gQnV0IG5hbWUgY2FuIGJlIG92ZXJ3cml0dGVuLFxuICAgICAgLy8gYmVjYXVzZSBheGlzIHVzZSBuYW1lIGFzICdzaG93IGxhYmVsIHRleHQnLlxuICAgICAgLy8gJ2V4aXN0JyBhbHdheXMgaGFzIGlkIGFuZCBuYW1lIGFuZCB3ZSBkb250XG4gICAgICAvLyBuZWVkIHRvIGNoZWNrIGl0LlxuICAgICAgJiYgY3B0T3B0aW9uLmlkID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0W2ldLm9wdGlvbiA9IGNwdE9wdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPj0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBvcHRpb246IGNwdE9wdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogTWFrZSBpZCBhbmQgbmFtZSBmb3IgbWFwcGluZyByZXN1bHQgKHJlc3VsdCBvZiBtYXBwaW5nVG9FeGlzdHMpXG4gKiBpbnRvIGBrZXlJbmZvYCBmaWVsZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBSZXN1bHQsIGxpa2UgW3tleGlzdDogLi4uLCBvcHRpb246IC4uLn0sIHt9XSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBvcmRlciBpcyB0aGUgc2FtZSBhcyBleGlzdHMuXG4gKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gVGhlIGlucHV0LlxuICovXG5cblxuZnVuY3Rpb24gbWFrZUlkQW5kTmFtZShtYXBSZXN1bHQpIHtcbiAgLy8gV2UgdXNlIHRoaXMgaWQgdG8gaGFzaCBjb21wb25lbnQgbW9kZWxzIGFuZCB2aWV3IGluc3RhbmNlc1xuICAvLyBpbiBlY2hhcnRzLiBpZCBjYW4gYmUgc3BlY2lmaWVkIGJ5IHVzZXIsIG9yIGF1dG8gZ2VuZXJhdGVkLlxuICAvLyBUaGUgaWQgZ2VuZXJhdGlvbiBydWxlIGVuc3VyZXMgbmV3IHZpZXcgaW5zdGFuY2UgYXJlIGFibGVcbiAgLy8gdG8gbWFwcGVkIHRvIG9sZCBpbnN0YW5jZSB3aGVuIHNldE9wdGlvbiBhcmUgY2FsbGVkIGluXG4gIC8vIG5vLW1lcmdlIG1vZGUuIFNvIHdlIGdlbmVyYXRlIG1vZGVsIGlkIGJ5IG5hbWUgYW5kIHBsdXNcbiAgLy8gdHlwZSBpbiB2aWV3IGlkLlxuICAvLyBuYW1lIGNhbiBiZSBkdXBsaWNhdGVkIGFtb25nIGNvbXBvbmVudHMsIHdoaWNoIGlzIGNvbnZlbmllbnRcbiAgLy8gdG8gc3BlY2lmeSBtdWx0aSBjb21wb25lbnRzIChsaWtlIHNlcmllcykgYnkgb25lIG5hbWUuXG4gIC8vIEVuc3VyZSB0aGF0IGVhY2ggaWQgaXMgZGlzdGluY3QuXG4gIHZhciBpZE1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICB2YXIgZXhpc3RDcHQgPSBpdGVtLmV4aXN0O1xuICAgIGV4aXN0Q3B0ICYmIGlkTWFwLnNldChleGlzdENwdC5pZCwgaXRlbSk7XG4gIH0pO1xuICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgdmFyIG9wdCA9IGl0ZW0ub3B0aW9uO1xuICAgIHpyVXRpbC5hc3NlcnQoIW9wdCB8fCBvcHQuaWQgPT0gbnVsbCB8fCAhaWRNYXAuZ2V0KG9wdC5pZCkgfHwgaWRNYXAuZ2V0KG9wdC5pZCkgPT09IGl0ZW0sICdpZCBkdXBsaWNhdGVzOiAnICsgKG9wdCAmJiBvcHQuaWQpKTtcbiAgICBvcHQgJiYgb3B0LmlkICE9IG51bGwgJiYgaWRNYXAuc2V0KG9wdC5pZCwgaXRlbSk7XG4gICAgIWl0ZW0ua2V5SW5mbyAmJiAoaXRlbS5rZXlJbmZvID0ge30pO1xuICB9KTsgLy8gTWFrZSBuYW1lIGFuZCBpZC5cblxuICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgdmFyIGV4aXN0Q3B0ID0gaXRlbS5leGlzdDtcbiAgICB2YXIgb3B0ID0gaXRlbS5vcHRpb247XG4gICAgdmFyIGtleUluZm8gPSBpdGVtLmtleUluZm87XG5cbiAgICBpZiAoIWlzT2JqZWN0KG9wdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5hbWUgY2FuIGJlIG92ZXJ3aXR0ZW4uIENvbnNpZGVyIGNhc2U6IGF4aXMubmFtZSA9ICcyMGttJy5cbiAgICAvLyBCdXQgaWQgZ2VuZXJhdGVkIGJ5IG5hbWUgd2lsbCBub3QgYmUgY2hhbmdlZCwgd2hpY2ggYWZmZWN0XG4gICAgLy8gb25seSBpbiB0aGF0IGNhc2U6IHNldE9wdGlvbiB3aXRoICdub3QgbWVyZ2UgbW9kZScgYW5kIHZpZXdcbiAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIHJlY3JlYXRlZCwgd2hpY2ggY2FuIGJlIGFjY2VwdGVkLlxuXG5cbiAgICBrZXlJbmZvLm5hbWUgPSBvcHQubmFtZSAhPSBudWxsID8gb3B0Lm5hbWUgKyAnJyA6IGV4aXN0Q3B0ID8gZXhpc3RDcHQubmFtZSA6ICdcXDAtJzsgLy8gbmFtZSBtYXkgYmUgZGlzcGxheWVkIG9uIHNjcmVlbiwgc28gdXNlICctJy5cblxuICAgIGlmIChleGlzdENwdCkge1xuICAgICAga2V5SW5mby5pZCA9IGV4aXN0Q3B0LmlkO1xuICAgIH0gZWxzZSBpZiAob3B0LmlkICE9IG51bGwpIHtcbiAgICAgIGtleUluZm8uaWQgPSBvcHQuaWQgKyAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29uc2lkZXIgdGhpcyBzaXR1YXRvaW46XG4gICAgICAvLyAgb3B0aW9uQTogW3tuYW1lOiAnYSd9LCB7bmFtZTogJ2EnfSwgey4ufV1cbiAgICAgIC8vICBvcHRpb25CIFt7Li59LCB7bmFtZTogJ2EnfSwge25hbWU6ICdhJ31dXG4gICAgICAvLyBTZXJpZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGJldHdlZW4gb3B0aW9uQSBhbmQgb3B0aW9uQlxuICAgICAgLy8gc2hvdWxkIGJlIG1hcHBlZC5cbiAgICAgIHZhciBpZE51bSA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAga2V5SW5mby5pZCA9ICdcXDAnICsga2V5SW5mby5uYW1lICsgJ1xcMCcgKyBpZE51bSsrO1xuICAgICAgfSB3aGlsZSAoaWRNYXAuZ2V0KGtleUluZm8uaWQpKTtcbiAgICB9XG5cbiAgICBpZE1hcC5zZXQoa2V5SW5mby5pZCwgaXRlbSk7XG4gIH0pO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gY3B0T3B0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNJZElubmVyKGNwdE9wdGlvbikge1xuICByZXR1cm4gaXNPYmplY3QoY3B0T3B0aW9uKSAmJiBjcHRPcHRpb24uaWQgJiYgKGNwdE9wdGlvbi5pZCArICcnKS5pbmRleE9mKCdcXDBfZWNfXFwwJykgPT09IDA7XG59XG4vKipcbiAqIEEgaGVscGVyIGZvciByZW1vdmluZyBkdXBsaWNhdGUgaXRlbXMgYmV0d2VlbiBiYXRjaEEgYW5kIGJhdGNoQixcbiAqIGFuZCBpbiB0aGVtc2VsdmVzLCBhbmQgY2F0ZWdvcml6ZSBieSBzZXJpZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYmF0Y2hBIExpa2U6IFt7c2VyaWVzSWQ6IDIsIGRhdGFJbmRleDogWzMyLCA0LCA1XX0sIC4uLl1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGJhdGNoQiBMaWtlOiBbe3Nlcmllc0lkOiAyLCBkYXRhSW5kZXg6IFszMiwgNCwgNV19LCAuLi5dXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPE9iamVjdD4sIEFycmF5LjxPYmplY3Q+Pn0gcmVzdWx0OiBbcmVzdWx0QmF0Y2hBLCByZXN1bHRCYXRjaEJdXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wcmVzc0JhdGNoZXMoYmF0Y2hBLCBiYXRjaEIpIHtcbiAgdmFyIG1hcEEgPSB7fTtcbiAgdmFyIG1hcEIgPSB7fTtcbiAgbWFrZU1hcChiYXRjaEEgfHwgW10sIG1hcEEpO1xuICBtYWtlTWFwKGJhdGNoQiB8fCBbXSwgbWFwQiwgbWFwQSk7XG4gIHJldHVybiBbbWFwVG9BcnJheShtYXBBKSwgbWFwVG9BcnJheShtYXBCKV07XG5cbiAgZnVuY3Rpb24gbWFrZU1hcChzb3VyY2VCYXRjaCwgbWFwLCBvdGhlck1hcCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VCYXRjaC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHNlcmllc0lkID0gc291cmNlQmF0Y2hbaV0uc2VyaWVzSWQ7XG4gICAgICB2YXIgZGF0YUluZGljZXMgPSBub3JtYWxpemVUb0FycmF5KHNvdXJjZUJhdGNoW2ldLmRhdGFJbmRleCk7XG4gICAgICB2YXIgb3RoZXJEYXRhSW5kaWNlcyA9IG90aGVyTWFwICYmIG90aGVyTWFwW3Nlcmllc0lkXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBkYXRhSW5kaWNlcy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzW2pdO1xuXG4gICAgICAgIGlmIChvdGhlckRhdGFJbmRpY2VzICYmIG90aGVyRGF0YUluZGljZXNbZGF0YUluZGV4XSkge1xuICAgICAgICAgIG90aGVyRGF0YUluZGljZXNbZGF0YUluZGV4XSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKG1hcFtzZXJpZXNJZF0gfHwgKG1hcFtzZXJpZXNJZF0gPSB7fSkpW2RhdGFJbmRleF0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXAsIGlzRGF0YSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgaW4gbWFwKSB7XG4gICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KGkpICYmIG1hcFtpXSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc0RhdGEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgraSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRhdGFJbmRpY2VzID0gbWFwVG9BcnJheShtYXBbaV0sIHRydWUpO1xuICAgICAgICAgIGRhdGFJbmRpY2VzLmxlbmd0aCAmJiByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBzZXJpZXNJZDogaSxcbiAgICAgICAgICAgIGRhdGFJbmRleDogZGF0YUluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIENvbnRhaW5zIGRhdGFJbmRleCAobWVhbnMgcmF3SW5kZXgpIC8gZGF0YUluZGV4SW5zaWRlIC8gbmFtZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBvZiB3aGljaCBjYW4gYmUgQXJyYXkgb3IgcHJpbWFyeSB0eXBlLlxuICogQHJldHVybiB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBkYXRhSW5kZXggSWYgbm90IGZvdW5kLCByZXR1cm4gdW5kZWZpbmVkL251bGwuXG4gKi9cblxuXG5mdW5jdGlvbiBxdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLmRhdGFJbmRleEluc2lkZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuZGF0YUluZGV4SW5zaWRlO1xuICB9IGVsc2UgaWYgKHBheWxvYWQuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICByZXR1cm4genJVdGlsLmlzQXJyYXkocGF5bG9hZC5kYXRhSW5kZXgpID8genJVdGlsLm1hcChwYXlsb2FkLmRhdGFJbmRleCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGF0YS5pbmRleE9mUmF3SW5kZXgodmFsdWUpO1xuICAgIH0pIDogZGF0YS5pbmRleE9mUmF3SW5kZXgocGF5bG9hZC5kYXRhSW5kZXgpO1xuICB9IGVsc2UgaWYgKHBheWxvYWQubmFtZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KHBheWxvYWQubmFtZSkgPyB6clV0aWwubWFwKHBheWxvYWQubmFtZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGF0YS5pbmRleE9mTmFtZSh2YWx1ZSk7XG4gICAgfSkgOiBkYXRhLmluZGV4T2ZOYW1lKHBheWxvYWQubmFtZSk7XG4gIH1cbn1cbi8qKlxuICogRW5hYmxlIHByb3BlcnR5IHN0b3JhZ2UgdG8gYW55IGhvc3Qgb2JqZWN0LlxuICogTm90aWNlOiBTZXJpYWxpemF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKiB2YXIgZ2V0ID0gbW9kZWxVaXRsLm1ha2VHZXR0ZXIoKTtcbiAqXG4gKiBmdW5jdGlvbiBzb21lKGhvc3RPYmopIHtcbiAqICAgICAgZ2V0KGhvc3RPYmopLl9zb21lUHJvcGVydHkgPSAxMjEyO1xuICogICAgICAuLi5cbiAqIH1cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbnZhciBtYWtlR2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW5kZXggPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBrZXkgPSAnXFwwX19lY19wcm9wX2dldHRlcl8nICsgaW5kZXgrKztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhvc3RPYmopIHtcbiAgICAgIHJldHVybiBob3N0T2JqW2tleV0gfHwgKGhvc3RPYmpba2V5XSA9IHt9KTtcbiAgICB9O1xuICB9O1xufSgpO1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdnZW8nLCBtZWFucyB7Z2VvSW5kZXg6IDB9LlxuICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gKiAgICAgICAge1xuICogICAgICAgICAgICBzZXJpZXNJbmRleCwgc2VyaWVzSWQsIHNlcmllc05hbWUsXG4gKiAgICAgICAgICAgIGdlb0luZGV4LCBnZW9JZCwgZ2VvTmFtZSxcbiAqICAgICAgICAgICAgYm1hcEluZGV4LCBibWFwSWQsIGJtYXBOYW1lLFxuICogICAgICAgICAgICB4QXhpc0luZGV4LCB4QXhpc0lkLCB4QXhpc05hbWUsXG4gKiAgICAgICAgICAgIHlBeGlzSW5kZXgsIHlBeGlzSWQsIHlBeGlzTmFtZSxcbiAqICAgICAgICAgICAgZ3JpZEluZGV4LCBncmlkSWQsIGdyaWROYW1lLFxuICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAqICAgICAgICB9XG4gKiAgICAgICAgRWFjaCBwcm9wZXJ0aWVzIGNhbiBiZSBudW1iZXJ8c3RyaW5nfEFycmF5LjxudW1iZXI+fEFycmF5LjxzdHJpbmc+XG4gKiAgICAgICAgRm9yIGV4YW1wbGUsIGEgZmluZGVyIGNvdWxkIGJlXG4gKiAgICAgICAge1xuICogICAgICAgICAgICBzZXJpZXNJbmRleDogMyxcbiAqICAgICAgICAgICAgZ2VvSWQ6IFsnYWEnLCAnY2MnXSxcbiAqICAgICAgICAgICAgZ3JpZE5hbWU6IFsneHgnLCAncnInXVxuICogICAgICAgIH1cbiAqICAgICAgICB4eHhJbmRleCBjYW4gYmUgc2V0IGFzICdhbGwnIChtZWFucyBhbGwgeHh4KSBvciAnbm9uZScgKG1lYW5zIG5vdCBzcGVjaWZ5KVxuICogICAgICAgIElmIG5vdGhpbmcgb3IgbnVsbC91bmRlZmluZWQgc3BlY2lmaWVkLCByZXR1cm4gbm90aGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuZGVmYXVsdE1haW5UeXBlXVxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW29wdC5pbmNsdWRlTWFpblR5cGVzXVxuICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQgbGlrZTpcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHNlcmllc01vZGVsczogW3Nlcmllc01vZGVsMSwgc2VyaWVzTW9kZWwyXSxcbiAqICAgICAgICAgICAgc2VyaWVzTW9kZWw6IHNlcmllc01vZGVsMSwgLy8gVGhlIGZpcnN0IG1vZGVsXG4gKiAgICAgICAgICAgIGdlb01vZGVsczogW2dlb01vZGVsMSwgZ2VvTW9kZWwyXSxcbiAqICAgICAgICAgICAgZ2VvTW9kZWw6IGdlb01vZGVsMSwgLy8gVGhlIGZpcnN0IG1vZGVsXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlciwgb3B0KSB7XG4gIGlmICh6clV0aWwuaXNTdHJpbmcoZmluZGVyKSkge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBvYmpbZmluZGVyICsgJ0luZGV4J10gPSAwO1xuICAgIGZpbmRlciA9IG9iajtcbiAgfVxuXG4gIHZhciBkZWZhdWx0TWFpblR5cGUgPSBvcHQgJiYgb3B0LmRlZmF1bHRNYWluVHlwZTtcblxuICBpZiAoZGVmYXVsdE1haW5UeXBlICYmICFoYXMoZmluZGVyLCBkZWZhdWx0TWFpblR5cGUgKyAnSW5kZXgnKSAmJiAhaGFzKGZpbmRlciwgZGVmYXVsdE1haW5UeXBlICsgJ0lkJykgJiYgIWhhcyhmaW5kZXIsIGRlZmF1bHRNYWluVHlwZSArICdOYW1lJykpIHtcbiAgICBmaW5kZXJbZGVmYXVsdE1haW5UeXBlICsgJ0luZGV4J10gPSAwO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBlYWNoKGZpbmRlciwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBmaW5kZXJba2V5XTsgLy8gRXhjbHVkZSAnZGF0YUluZGV4JyBhbmQgb3RoZXIgaWxsZ2FsIGtleXMuXG5cbiAgICBpZiAoa2V5ID09PSAnZGF0YUluZGV4JyB8fCBrZXkgPT09ICdkYXRhSW5kZXhJbnNpZGUnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRLZXkgPSBrZXkubWF0Y2goL14oXFx3KykoSW5kZXh8SWR8TmFtZSkkLykgfHwgW107XG4gICAgdmFyIG1haW5UeXBlID0gcGFyc2VkS2V5WzFdO1xuICAgIHZhciBxdWVyeVR5cGUgPSAocGFyc2VkS2V5WzJdIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKCFtYWluVHlwZSB8fCAhcXVlcnlUeXBlIHx8IHZhbHVlID09IG51bGwgfHwgcXVlcnlUeXBlID09PSAnaW5kZXgnICYmIHZhbHVlID09PSAnbm9uZScgfHwgb3B0ICYmIG9wdC5pbmNsdWRlTWFpblR5cGVzICYmIHpyVXRpbC5pbmRleE9mKG9wdC5pbmNsdWRlTWFpblR5cGVzLCBtYWluVHlwZSkgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXJ5UGFyYW0gPSB7XG4gICAgICBtYWluVHlwZTogbWFpblR5cGVcbiAgICB9O1xuXG4gICAgaWYgKHF1ZXJ5VHlwZSAhPT0gJ2luZGV4JyB8fCB2YWx1ZSAhPT0gJ2FsbCcpIHtcbiAgICAgIHF1ZXJ5UGFyYW1bcXVlcnlUeXBlXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBtb2RlbHMgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyhxdWVyeVBhcmFtKTtcbiAgICByZXN1bHRbbWFpblR5cGUgKyAnTW9kZWxzJ10gPSBtb2RlbHM7XG4gICAgcmVzdWx0W21haW5UeXBlICsgJ01vZGVsJ10gPSBtb2RlbHNbMF07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkYXRhRGltXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBkYXRhRGltVG9Db29yZERpbShkYXRhLCBkYXRhRGltKSB7XG4gIHZhciBkaW1lbnNpb25zID0gZGF0YS5kaW1lbnNpb25zO1xuICBkYXRhRGltID0gZGF0YS5nZXREaW1lbnNpb24oZGF0YURpbSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpbUl0ZW0gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oZGltZW5zaW9uc1tpXSk7XG5cbiAgICBpZiAoZGltSXRlbS5uYW1lID09PSBkYXRhRGltKSB7XG4gICAgICByZXR1cm4gZGltSXRlbS5jb29yZERpbTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHNlZSB7bW9kdWxlOmVjaGFydHMvZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zfVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZERpbVxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IGRhdGEgZGltZW5zaW9ucyBvbiB0aGUgY29vcmREaW0uXG4gKi9cblxuXG5mdW5jdGlvbiBjb29yZERpbVRvRGF0YURpbShkYXRhLCBjb29yZERpbSkge1xuICB2YXIgZGF0YURpbSA9IFtdO1xuICBlYWNoKGRhdGEuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbU5hbWUpIHtcbiAgICB2YXIgZGltSXRlbSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1OYW1lKTtcblxuICAgIGlmIChkaW1JdGVtLmNvb3JkRGltID09PSBjb29yZERpbSkge1xuICAgICAgZGF0YURpbVtkaW1JdGVtLmNvb3JkRGltSW5kZXhdID0gZGltSXRlbS5uYW1lO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhRGltO1xufVxuLyoqXG4gKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IG90aGVyRGltIENhbiBiZSBgb3RoZXJEaW1zYFxuICogICAgICAgICAgICAgICAgICAgICAgICBsaWtlICdsYWJlbCcgb3IgJ3Rvb2x0aXAnLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IGRhdGEgZGltZW5zaW9ucyBvbiB0aGUgb3RoZXJEaW0uXG4gKi9cblxuXG5mdW5jdGlvbiBvdGhlckRpbVRvRGF0YURpbShkYXRhLCBvdGhlckRpbSkge1xuICB2YXIgZGF0YURpbSA9IFtdO1xuICBlYWNoKGRhdGEuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbU5hbWUpIHtcbiAgICB2YXIgZGltSXRlbSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1OYW1lKTtcbiAgICB2YXIgb3RoZXJEaW1zID0gZGltSXRlbS5vdGhlckRpbXM7XG4gICAgdmFyIGRpbUluZGV4ID0gb3RoZXJEaW1zW290aGVyRGltXTtcblxuICAgIGlmIChkaW1JbmRleCAhPSBudWxsICYmIGRpbUluZGV4ICE9PSBmYWxzZSkge1xuICAgICAgZGF0YURpbVtkaW1JbmRleF0gPSBkaW1JdGVtLm5hbWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGFEaW07XG59XG5cbmZ1bmN0aW9uIGhhcyhvYmosIHByb3ApIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCk7XG59XG5cbmV4cG9ydHMubm9ybWFsaXplVG9BcnJheSA9IG5vcm1hbGl6ZVRvQXJyYXk7XG5leHBvcnRzLmRlZmF1bHRFbXBoYXNpcyA9IGRlZmF1bHRFbXBoYXNpcztcbmV4cG9ydHMuVEVYVF9TVFlMRV9PUFRJT05TID0gVEVYVF9TVFlMRV9PUFRJT05TO1xuZXhwb3J0cy5nZXREYXRhSXRlbVZhbHVlID0gZ2V0RGF0YUl0ZW1WYWx1ZTtcbmV4cG9ydHMuaXNEYXRhSXRlbU9wdGlvbiA9IGlzRGF0YUl0ZW1PcHRpb247XG5leHBvcnRzLmNvbnZlckRhdGFWYWx1ZSA9IGNvbnZlckRhdGFWYWx1ZTtcbmV4cG9ydHMuY3JlYXRlRGF0YUZvcm1hdE1vZGVsID0gY3JlYXRlRGF0YUZvcm1hdE1vZGVsO1xuZXhwb3J0cy5kYXRhRm9ybWF0TWl4aW4gPSBkYXRhRm9ybWF0TWl4aW47XG5leHBvcnRzLm1hcHBpbmdUb0V4aXN0cyA9IG1hcHBpbmdUb0V4aXN0cztcbmV4cG9ydHMubWFrZUlkQW5kTmFtZSA9IG1ha2VJZEFuZE5hbWU7XG5leHBvcnRzLmlzSWRJbm5lciA9IGlzSWRJbm5lcjtcbmV4cG9ydHMuY29tcHJlc3NCYXRjaGVzID0gY29tcHJlc3NCYXRjaGVzO1xuZXhwb3J0cy5xdWVyeURhdGFJbmRleCA9IHF1ZXJ5RGF0YUluZGV4O1xuZXhwb3J0cy5tYWtlR2V0dGVyID0gbWFrZUdldHRlcjtcbmV4cG9ydHMucGFyc2VGaW5kZXIgPSBwYXJzZUZpbmRlcjtcbmV4cG9ydHMuZGF0YURpbVRvQ29vcmREaW0gPSBkYXRhRGltVG9Db29yZERpbTtcbmV4cG9ydHMuY29vcmREaW1Ub0RhdGFEaW0gPSBjb29yZERpbVRvRGF0YURpbTtcbmV4cG9ydHMub3RoZXJEaW1Ub0RhdGFEaW0gPSBvdGhlckRpbVRvRGF0YURpbTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL21vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vICgxKSBUaGUgY29kZSBgaWYgKF9fREVWX18pIC4uLmAgY2FuIGJlIHJlbW92ZWQgYnkgYnVpbGQgdG9vbC5cbi8vICgyKSBJZiBpbnRlbmQgdG8gdXNlIGBfX0RFVl9fYCwgdGhpcyBtb2R1bGUgc2hvdWxkIGJlIGltcG9ydGVkLiBVc2UgYSBnbG9iYWxcbi8vIHZhcmlhYmxlIGBfX0RFVl9fYCBtYXkgY2F1c2UgdGhhdCBtaXNzIHRoZSBkZWNsYXJhdGlvbiAoc2VlICM2NTM1KSwgb3IgdGhlXG4vLyBkZWNsYXJhdGlvbiBpcyBiZWhpbmQgb2YgdGhlIHVzaW5nIHBvc2l0aW9uIChmb3IgZXhhbXBsZSBpbiBgTW9kZWwuZXh0ZW50YCxcbi8vIEFuZCB0b29scyBsaWtlIHJvbGx1cCBjYW4gbm90IGFuYWx5c2lzIHRoZSBkZXBlbmRlbmN5IGlmIG5vdCBpbXBvcnQpLlxudmFyIGRldjsgLy8gSW4gYnJvd3NlclxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZGV2ID0gd2luZG93Ll9fREVWX187XG59IC8vIEluIG5vZGVcbmVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGV2ID0gZ2xvYmFsLl9fREVWX187XG4gIH1cblxuaWYgKHR5cGVvZiBkZXYgPT09ICd1bmRlZmluZWQnKSB7XG4gIGRldiA9IHRydWU7XG59XG5cbnZhciBfX0RFVl9fID0gZGV2O1xuZXhwb3J0cy5fX0RFVl9fID0gX19ERVZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gQXJyYXkgOiBGbG9hdDMyQXJyYXk7XG4vKipcbiAqIOWIm+W7uuS4gOS4quWQkemHj1xuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG5cbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHggPSAwO1xuICB9XG5cbiAgaWYgKHkgPT0gbnVsbCkge1xuICAgIHkgPSAwO1xuICB9XG5cbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5aSN5Yi25ZCR6YeP5pWw5o2uXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5YWL6ZqG5LiA5Liq5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZSh2KSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorr7nva7lkJHph4/nmoTkuKTkuKrpoblcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9IOe7k+aenFxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nm7jliqBcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP57yp5pS+5ZCO55u45YqgXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgdjEsIHYyLCBhKSB7XG4gIG91dFswXSA9IHYxWzBdICsgdjJbMF0gKiBhO1xuICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdICogYTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP55u45YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gc3ViKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdIC0gdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdIC0gdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+mVv+W6plxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBsZW4odikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGxlblNxdWFyZSh2KSk7XG59XG5cbnZhciBsZW5ndGggPSBsZW47IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vKipcbiAqIOWQkemHj+mVv+W6puW5s+aWuVxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gbGVuU3F1YXJlKHYpIHtcbiAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV07XG59XG5cbnZhciBsZW5ndGhTcXVhcmUgPSBsZW5TcXVhcmU7XG4vKipcbiAqIOWQkemHj+S5mOazlVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5mdW5jdGlvbiBtdWwob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gKiB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gKiB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP6Zmk5rOVXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gZGl2KG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdIC8gdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdIC8gdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+eCueS5mFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZG90KHYxLCB2Mikge1xuICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG59XG4vKipcbiAqIOWQkemHj+e8qeaUvlxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHBhcmFtIHtudW1iZXJ9IHNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgdiwgcykge1xuICBvdXRbMF0gPSB2WzBdICogcztcbiAgb3V0WzFdID0gdlsxXSAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+W9kuS4gOWMllxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgdikge1xuICB2YXIgZCA9IGxlbih2KTtcblxuICBpZiAoZCA9PT0gMCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSB2WzBdIC8gZDtcbiAgICBvdXRbMV0gPSB2WzFdIC8gZDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuoeeul+WQkemHj+mXtOi3neemu1xuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UodjEsIHYyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pKTtcbn1cblxudmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICog5ZCR6YeP6Led56a75bmz5pa5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gZGlzdGFuY2VTcXVhcmUodjEsIHYyKSB7XG4gIHJldHVybiAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSkgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSk7XG59XG5cbnZhciBkaXN0U3F1YXJlID0gZGlzdGFuY2VTcXVhcmU7XG4vKipcbiAqIOaxgui0n+WQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICovXG5cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIHYpIHtcbiAgb3V0WzBdID0gLXZbMF07XG4gIG91dFsxXSA9IC12WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmj5LlgLzkuKTkuKrngrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICovXG5cblxuZnVuY3Rpb24gbGVycChvdXQsIHYxLCB2MiwgdCkge1xuICBvdXRbMF0gPSB2MVswXSArIHQgKiAodjJbMF0gLSB2MVswXSk7XG4gIG91dFsxXSA9IHYxWzFdICsgdCAqICh2MlsxXSAtIHYxWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog55+p6Zi15bem5LmY5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKG91dCwgdiwgbSkge1xuICB2YXIgeCA9IHZbMF07XG4gIHZhciB5ID0gdlsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLkuKTkuKrlkJHph4/mnIDlsI/lgLxcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBtaW4ob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4odjFbMF0sIHYyWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4odjFbMV0sIHYyWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC5Lik5Liq5ZCR6YeP5pyA5aSn5YC8XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KHYxWzBdLCB2MlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KHYxWzFdLCB2MlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnNjYWxlQW5kQWRkID0gc2NhbGVBbmRBZGQ7XG5leHBvcnRzLnN1YiA9IHN1YjtcbmV4cG9ydHMubGVuID0gbGVuO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmxlblNxdWFyZSA9IGxlblNxdWFyZTtcbmV4cG9ydHMubGVuZ3RoU3F1YXJlID0gbGVuZ3RoU3F1YXJlO1xuZXhwb3J0cy5tdWwgPSBtdWw7XG5leHBvcnRzLmRpdiA9IGRpdjtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmRpc3QgPSBkaXN0O1xuZXhwb3J0cy5kaXN0YW5jZVNxdWFyZSA9IGRpc3RhbmNlU3F1YXJlO1xuZXhwb3J0cy5kaXN0U3F1YXJlID0gZGlzdFNxdWFyZTtcbmV4cG9ydHMubmVnYXRlID0gbmVnYXRlO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMuYXBwbHlUcmFuc2Zvcm0gPSBhcHBseVRyYW5zZm9ybTtcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS92ZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cbnZhciBlbnYgPSB7fTtcblxuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEluIG5vZGVcbiAgZW52ID0ge1xuICAgIGJyb3dzZXI6IHt9LFxuICAgIG9zOiB7fSxcbiAgICBub2RlOiB0cnVlLFxuICAgIC8vIEFzc3VtZSBjYW52YXMgaXMgc3VwcG9ydGVkXG4gICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlLFxuICAgIHN2Z1N1cHBvcnRlZDogdHJ1ZVxuICB9O1xufSBlbHNlIHtcbiAgZW52ID0gZGV0ZWN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBlbnY7IC8vIFplcHRvLmpzXG4vLyAoYykgMjAxMC0yMDEzIFRob21hcyBGdWNoc1xuLy8gWmVwdG8uanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbmZ1bmN0aW9uIGRldGVjdCh1YSkge1xuICB2YXIgb3MgPSB7fTtcbiAgdmFyIGJyb3dzZXIgPSB7fTsgLy8gdmFyIHdlYmtpdCA9IHVhLm1hdGNoKC9XZWJba0tdaXRbXFwvXXswLDF9KFtcXGQuXSspLyk7XG4gIC8vIHZhciBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pO1xuICAvLyB2YXIgaXBhZCA9IHVhLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyk7XG4gIC8vIHZhciBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKTtcbiAgLy8gdmFyIGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1MpXFxzKFtcXGRfXSspLyk7XG4gIC8vIHZhciB3ZWJvcyA9IHVhLm1hdGNoKC8od2ViT1N8aHB3T1MpW1xcc1xcL10oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHRvdWNocGFkID0gd2Vib3MgJiYgdWEubWF0Y2goL1RvdWNoUGFkLyk7XG4gIC8vIHZhciBraW5kbGUgPSB1YS5tYXRjaCgvS2luZGxlXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciBzaWxrID0gdWEubWF0Y2goL1NpbGtcXC8oW1xcZC5fXSspLyk7XG4gIC8vIHZhciBibGFja2JlcnJ5ID0gdWEubWF0Y2goLyhCbGFja0JlcnJ5KS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgYmIxMCA9IHVhLm1hdGNoKC8oQkIxMCkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHJpbXRhYmxldG9zID0gdWEubWF0Y2goLyhSSU1cXHNUYWJsZXRcXHNPUylcXHMoW1xcZC5dKykvKTtcbiAgLy8gdmFyIHBsYXlib29rID0gdWEubWF0Y2goL1BsYXlCb29rLyk7XG4gIC8vIHZhciBjaHJvbWUgPSB1YS5tYXRjaCgvQ2hyb21lXFwvKFtcXGQuXSspLykgfHwgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLyk7XG5cbiAgdmFyIGZpcmVmb3ggPSB1YS5tYXRjaCgvRmlyZWZveFxcLyhbXFxkLl0rKS8pOyAvLyB2YXIgc2FmYXJpID0gd2Via2l0ICYmIHVhLm1hdGNoKC9Nb2JpbGVcXC8vKSAmJiAhY2hyb21lO1xuICAvLyB2YXIgd2VidmlldyA9IHVhLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpLykgJiYgIWNocm9tZTtcblxuICB2YXIgaWUgPSB1YS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pIC8vIElFIDExIFRyaWRlbnQvNy4wOyBydjoxMS4wXG4gIHx8IHVhLm1hdGNoKC9UcmlkZW50XFwvLis/cnY6KChbXFxkLl0rKSkvKTtcbiAgdmFyIGVkZ2UgPSB1YS5tYXRjaCgvRWRnZVxcLyhbXFxkLl0rKS8pOyAvLyBJRSAxMiBhbmQgMTIrXG5cbiAgdmFyIHdlQ2hhdCA9IC9taWNyb21lc3Nlbmdlci9pLnRlc3QodWEpOyAvLyBUb2RvOiBjbGVhbiB0aGlzIHVwIHdpdGggYSBiZXR0ZXIgT1MvYnJvd3NlciBzZXBlcmF0aW9uOlxuICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxuICAvLyAtIGRlY2lkZSBpZiBraW5kbGUgZmlyZSBpbiBzaWxrIG1vZGUgaXMgYW5kcm9pZCBvciBub3RcbiAgLy8gLSBGaXJlZm94IG9uIEFuZHJvaWQgZG9lc24ndCBzcGVjaWZ5IHRoZSBBbmRyb2lkIHZlcnNpb25cbiAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcbiAgLy8gaWYgKGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXQpIGJyb3dzZXIudmVyc2lvbiA9IHdlYmtpdFsxXTtcbiAgLy8gaWYgKGFuZHJvaWQpIG9zLmFuZHJvaWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gYW5kcm9pZFsyXTtcbiAgLy8gaWYgKGlwaG9uZSAmJiAhaXBvZCkgb3MuaW9zID0gb3MuaXBob25lID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwaG9uZVsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gIC8vIGlmIChpcGFkKSBvcy5pb3MgPSBvcy5pcGFkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAvLyBpZiAoaXBvZCkgb3MuaW9zID0gb3MuaXBvZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsO1xuICAvLyBpZiAod2Vib3MpIG9zLndlYm9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHdlYm9zWzJdO1xuICAvLyBpZiAodG91Y2hwYWQpIG9zLnRvdWNocGFkID0gdHJ1ZTtcbiAgLy8gaWYgKGJsYWNrYmVycnkpIG9zLmJsYWNrYmVycnkgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmxhY2tiZXJyeVsyXTtcbiAgLy8gaWYgKGJiMTApIG9zLmJiMTAgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmIxMFsyXTtcbiAgLy8gaWYgKHJpbXRhYmxldG9zKSBvcy5yaW10YWJsZXRvcyA9IHRydWUsIG9zLnZlcnNpb24gPSByaW10YWJsZXRvc1syXTtcbiAgLy8gaWYgKHBsYXlib29rKSBicm93c2VyLnBsYXlib29rID0gdHJ1ZTtcbiAgLy8gaWYgKGtpbmRsZSkgb3Mua2luZGxlID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGtpbmRsZVsxXTtcbiAgLy8gaWYgKHNpbGspIGJyb3dzZXIuc2lsayA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IHNpbGtbMV07XG4gIC8vIGlmICghc2lsayAmJiBvcy5hbmRyb2lkICYmIHVhLm1hdGNoKC9LaW5kbGUgRmlyZS8pKSBicm93c2VyLnNpbGsgPSB0cnVlO1xuICAvLyBpZiAoY2hyb21lKSBicm93c2VyLmNocm9tZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGNocm9tZVsxXTtcblxuICBpZiAoZmlyZWZveCkge1xuICAgIGJyb3dzZXIuZmlyZWZveCA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gZmlyZWZveFsxXTtcbiAgfSAvLyBpZiAoc2FmYXJpICYmICh1YS5tYXRjaCgvU2FmYXJpLykgfHwgISFvcy5pb3MpKSBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gIC8vIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuXG5cbiAgaWYgKGllKSB7XG4gICAgYnJvd3Nlci5pZSA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gaWVbMV07XG4gIH1cblxuICBpZiAoZWRnZSkge1xuICAgIGJyb3dzZXIuZWRnZSA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gZWRnZVsxXTtcbiAgfSAvLyBJdCBpcyBkaWZmaWN1bHQgdG8gZGV0ZWN0IFdlQ2hhdCBpbiBXaW4gUGhvbmUgcHJlY2lzZWx5LCBiZWNhdXNlIHVhIGNhblxuICAvLyBub3QgYmUgc2V0IG9uIHdpbiBwaG9uZS4gU28gd2UgZG8gbm90IGNvbnNpZGVyIFdpbiBQaG9uZS5cblxuXG4gIGlmICh3ZUNoYXQpIHtcbiAgICBicm93c2VyLndlQ2hhdCA9IHRydWU7XG4gIH0gLy8gb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL1RhYmxldC8pKSB8fCAoaWUgJiYgIXVhLm1hdGNoKC9QaG9uZS8pICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSk7XG4gIC8vIG9zLnBob25lICA9ICEhKCFvcy50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8XG4gIC8vICAgICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvTW9iaWxlLykpIHx8IChpZSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpKTtcblxuXG4gIHJldHVybiB7XG4gICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICBvczogb3MsXG4gICAgbm9kZTogZmFsc2UsXG4gICAgLy8g5Y6f55SfY2FudmFz5pSv5oyB77yM5pS55p6B56uv54K55LqGXG4gICAgLy8gY2FudmFzU3VwcG9ydGVkIDogIShicm93c2VyLmllICYmIHBhcnNlRmxvYXQoYnJvd3Nlci52ZXJzaW9uKSA8IDkpXG4gICAgY2FudmFzU3VwcG9ydGVkOiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQsXG4gICAgc3ZnU3VwcG9ydGVkOiB0eXBlb2YgU1ZHUmVjdCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgLy8gQHNlZSA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODE3MDI5L3doYXRzLXRoZS1iZXN0LXdheS10by1kZXRlY3QtYS10b3VjaC1zY3JlZW4tZGV2aWNlLXVzaW5nLWphdmFzY3JpcHQ+XG4gICAgLy8gd29ya3Mgb24gbW9zdCBicm93c2Vyc1xuICAgIC8vIElFMTAvMTEgZG9lcyBub3Qgc3VwcG9ydCB0b3VjaCBldmVudCwgYW5kIE1TIEVkZ2Ugc3VwcG9ydHMgdGhlbSBidXQgbm90IGJ5XG4gICAgLy8gZGVmYXVsdCwgc28gd2UgZG9udCBjaGVjayBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgZm9yIHRoZW0gaGVyZS5cbiAgICB0b3VjaEV2ZW50c1N1cHBvcnRlZDogJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmICFicm93c2VyLmllICYmICFicm93c2VyLmVkZ2UsXG4gICAgLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXIlMjBldmVudD4uXG4gICAgcG9pbnRlckV2ZW50c1N1cHBvcnRlZDogJ29ucG9pbnRlcmRvd24nIGluIHdpbmRvdyAvLyBGaXJlZm94IHN1cHBvcnRzIHBvaW50ZXIgYnV0IG5vdCBieSBkZWZhdWx0LCBvbmx5IE1TIGJyb3dzZXJzIGFyZSByZWxpYWJsZSBvbiBwb2ludGVyXG4gICAgLy8gZXZlbnRzIGN1cnJlbnRseS4gU28gd2UgZG9udCB1c2UgdGhhdCBvbiBvdGhlciBicm93c2VycyB1bmxlc3MgdGVzdGVkIHN1ZmZpY2llbnRseS5cbiAgICAvLyBBbHRob3VnaCBJRSAxMCBzdXBwb3J0cyBwb2ludGVyIGV2ZW50LCBpdCB1c2Ugb2xkIHN0eWxlIGFuZCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAvLyBzdGFuZGFyZC4gU28gd2UgZXhjbHVkZSB0aGF0LiAoSUUgMTAgaXMgaGFyZGx5IHVzZWQgb24gdG91Y2ggZGV2aWNlKVxuICAgICYmIChicm93c2VyLmVkZ2UgfHwgYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTEpXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9lbnYuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluL3RleHRcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4vbnVtYmVyXCIpO1xuXG4vKipcbiAqIOavj+S4ieS9jem7mOiupOWKoCzmoLzlvI/ljJZcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0geFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBhZGRDb21tYXMoeCkge1xuICBpZiAoaXNOYU4oeCkpIHtcbiAgICByZXR1cm4gJy0nO1xuICB9XG5cbiAgeCA9ICh4ICsgJycpLnNwbGl0KCcuJyk7XG4gIHJldHVybiB4WzBdLnJlcGxhY2UoLyhcXGR7MSwzfSkoPz0oPzpcXGR7M30pKyg/IVxcZCkpL2csICckMSwnKSArICh4Lmxlbmd0aCA+IDEgPyAnLicgKyB4WzFdIDogJycpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1cHBlckNhc2VGaXJzdD1mYWxzZV1cbiAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gKi9cblxuXG5mdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIsIHVwcGVyQ2FzZUZpcnN0KSB7XG4gIHN0ciA9IChzdHIgfHwgJycpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGdyb3VwMSkge1xuICAgIHJldHVybiBncm91cDEudG9VcHBlckNhc2UoKTtcbiAgfSk7XG5cbiAgaWYgKHVwcGVyQ2FzZUZpcnN0ICYmIHN0cikge1xuICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbnZhciBub3JtYWxpemVDc3NBcnJheSA9IHpyVXRpbC5ub3JtYWxpemVDc3NBcnJheTtcblxuZnVuY3Rpb24gZW5jb2RlSFRNTChzb3VyY2UpIHtcbiAgcmV0dXJuIFN0cmluZyhzb3VyY2UpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvJy9nLCAnJiMzOTsnKTtcbn1cblxudmFyIFRQTF9WQVJfQUxJQVMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnXTtcblxudmFyIHdyYXBWYXIgPSBmdW5jdGlvbiAodmFyTmFtZSwgc2VyaWVzSWR4KSB7XG4gIHJldHVybiAneycgKyB2YXJOYW1lICsgKHNlcmllc0lkeCA9PSBudWxsID8gJycgOiBzZXJpZXNJZHgpICsgJ30nO1xufTtcbi8qKlxuICogVGVtcGxhdGUgZm9ybWF0dGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHBsXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fE9iamVjdH0gcGFyYW1zTGlzdFxuICogQHBhcmFtIHtib29sZWFufSBbZW5jb2RlPWZhbHNlXVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0VHBsKHRwbCwgcGFyYW1zTGlzdCwgZW5jb2RlKSB7XG4gIGlmICghenJVdGlsLmlzQXJyYXkocGFyYW1zTGlzdCkpIHtcbiAgICBwYXJhbXNMaXN0ID0gW3BhcmFtc0xpc3RdO1xuICB9XG5cbiAgdmFyIHNlcmllc0xlbiA9IHBhcmFtc0xpc3QubGVuZ3RoO1xuXG4gIGlmICghc2VyaWVzTGVuKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyICR2YXJzID0gcGFyYW1zTGlzdFswXS4kdmFycyB8fCBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8ICR2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGFsaWFzID0gVFBMX1ZBUl9BTElBU1tpXTtcbiAgICB2YXIgdmFsID0gd3JhcFZhcihhbGlhcywgMCk7XG4gICAgdHBsID0gdHBsLnJlcGxhY2Uod3JhcFZhcihhbGlhcyksIGVuY29kZSA/IGVuY29kZUhUTUwodmFsKSA6IHZhbCk7XG4gIH1cblxuICBmb3IgKHZhciBzZXJpZXNJZHggPSAwOyBzZXJpZXNJZHggPCBzZXJpZXNMZW47IHNlcmllc0lkeCsrKSB7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCAkdmFycy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIHZhbCA9IHBhcmFtc0xpc3Rbc2VyaWVzSWR4XVskdmFyc1trXV07XG4gICAgICB0cGwgPSB0cGwucmVwbGFjZSh3cmFwVmFyKFRQTF9WQVJfQUxJQVNba10sIHNlcmllc0lkeCksIGVuY29kZSA/IGVuY29kZUhUTUwodmFsKSA6IHZhbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRwbDtcbn1cbi8qKlxuICogc2ltcGxlIFRlbXBsYXRlIGZvcm1hdHRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0cGxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuICogQHBhcmFtIHtib29sZWFufSBbZW5jb2RlPWZhbHNlXVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0VHBsU2ltcGxlKHRwbCwgcGFyYW0sIGVuY29kZSkge1xuICB6clV0aWwuZWFjaChwYXJhbSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICB0cGwgPSB0cGwucmVwbGFjZSgneycgKyBrZXkgKyAnfScsIGVuY29kZSA/IGVuY29kZUhUTUwodmFsdWUpIDogdmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHRwbDtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4dHJhQ3NzVGV4dF1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRvb2x0aXBNYXJrZXIoY29sb3IsIGV4dHJhQ3NzVGV4dCkge1xuICByZXR1cm4gY29sb3IgPyAnPHNwYW4gc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tcmlnaHQ6NXB4OycgKyAnYm9yZGVyLXJhZGl1czoxMHB4O3dpZHRoOjlweDtoZWlnaHQ6OXB4O2JhY2tncm91bmQtY29sb3I6JyArIGVuY29kZUhUTUwoY29sb3IpICsgJzsnICsgKGV4dHJhQ3NzVGV4dCB8fCAnJykgKyAnXCI+PC9zcGFuPicgOiAnJztcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICogQGlubmVyXG4gKi9cblxuXG52YXIgczJkID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyIDwgMTAgPyAnMCcgKyBzdHIgOiBzdHI7XG59O1xuLyoqXG4gKiBJU08gRGF0ZSBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0cGxcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbaXNVVEM9ZmFsc2VdIERlZmF1bHQgaW4gbG9jYWwgdGltZS5cbiAqICAgICAgICAgICBzZWUgYG1vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWVgXG4gKiAgICAgICAgICAgYW5kIGBtb2R1bGU6ZWNoYXJ0cy91dGlsL251bWJlciNwYXJzZURhdGVgLlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lKHRwbCwgdmFsdWUsIGlzVVRDKSB7XG4gIGlmICh0cGwgPT09ICd3ZWVrJyB8fCB0cGwgPT09ICdtb250aCcgfHwgdHBsID09PSAncXVhcnRlcicgfHwgdHBsID09PSAnaGFsZi15ZWFyJyB8fCB0cGwgPT09ICd5ZWFyJykge1xuICAgIHRwbCA9ICdNTS1kZFxcbnl5eXknO1xuICB9XG5cbiAgdmFyIGRhdGUgPSBudW1iZXJVdGlsLnBhcnNlRGF0ZSh2YWx1ZSk7XG4gIHZhciB1dGMgPSBpc1VUQyA/ICdVVEMnIDogJyc7XG4gIHZhciB5ID0gZGF0ZVsnZ2V0JyArIHV0YyArICdGdWxsWWVhciddKCk7XG4gIHZhciBNID0gZGF0ZVsnZ2V0JyArIHV0YyArICdNb250aCddKCkgKyAxO1xuICB2YXIgZCA9IGRhdGVbJ2dldCcgKyB1dGMgKyAnRGF0ZSddKCk7XG4gIHZhciBoID0gZGF0ZVsnZ2V0JyArIHV0YyArICdIb3VycyddKCk7XG4gIHZhciBtID0gZGF0ZVsnZ2V0JyArIHV0YyArICdNaW51dGVzJ10oKTtcbiAgdmFyIHMgPSBkYXRlWydnZXQnICsgdXRjICsgJ1NlY29uZHMnXSgpO1xuICB0cGwgPSB0cGwucmVwbGFjZSgnTU0nLCBzMmQoTSkpLnJlcGxhY2UoJ00nLCBNKS5yZXBsYWNlKCd5eXl5JywgeSkucmVwbGFjZSgneXknLCB5ICUgMTAwKS5yZXBsYWNlKCdkZCcsIHMyZChkKSkucmVwbGFjZSgnZCcsIGQpLnJlcGxhY2UoJ2hoJywgczJkKGgpKS5yZXBsYWNlKCdoJywgaCkucmVwbGFjZSgnbW0nLCBzMmQobSkpLnJlcGxhY2UoJ20nLCBtKS5yZXBsYWNlKCdzcycsIHMyZChzKSkucmVwbGFjZSgncycsIHMpO1xuICByZXR1cm4gdHBsO1xufVxuLyoqXG4gKiBDYXBpdGFsIGZpcnN0XG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBjYXBpdGFsRmlyc3Qoc3RyKSB7XG4gIHJldHVybiBzdHIgPyBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyKDEpIDogc3RyO1xufVxuXG52YXIgdHJ1bmNhdGVUZXh0ID0gdGV4dENvbnRhaW4udHJ1bmNhdGVUZXh0O1xudmFyIGdldFRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0O1xuZXhwb3J0cy5hZGRDb21tYXMgPSBhZGRDb21tYXM7XG5leHBvcnRzLnRvQ2FtZWxDYXNlID0gdG9DYW1lbENhc2U7XG5leHBvcnRzLm5vcm1hbGl6ZUNzc0FycmF5ID0gbm9ybWFsaXplQ3NzQXJyYXk7XG5leHBvcnRzLmVuY29kZUhUTUwgPSBlbmNvZGVIVE1MO1xuZXhwb3J0cy5mb3JtYXRUcGwgPSBmb3JtYXRUcGw7XG5leHBvcnRzLmZvcm1hdFRwbFNpbXBsZSA9IGZvcm1hdFRwbFNpbXBsZTtcbmV4cG9ydHMuZ2V0VG9vbHRpcE1hcmtlciA9IGdldFRvb2x0aXBNYXJrZXI7XG5leHBvcnRzLmZvcm1hdFRpbWUgPSBmb3JtYXRUaW1lO1xuZXhwb3J0cy5jYXBpdGFsRmlyc3QgPSBjYXBpdGFsRmlyc3Q7XG5leHBvcnRzLnRydW5jYXRlVGV4dCA9IHRydW5jYXRlVGV4dDtcbmV4cG9ydHMuZ2V0VGV4dFJlY3QgPSBnZXRUZXh0UmVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2Zvcm1hdC5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3BhdGhcIik7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZShcIi4vUGF0dGVyblwiKTtcblxudmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnBhdGggPSBudWxsO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGgsXG4gIHR5cGU6ICdwYXRoJyxcbiAgX19kaXJ0eVBhdGg6IHRydWUsXG4gIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8IHBhdGhQcm94eUZvckRyYXc7XG4gICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhZmlsbC5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISFmaWxsLmltYWdlO1xuICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhc3Ryb2tlLmltYWdlO1xuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICB2YXIgcmVjdDsgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuXG4gICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgIH1cbiAgICB9IC8vIFVzZSB0aGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuXG5cbiAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9maWxsR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgIH1cblxuICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHZhciBjdHhMaW5lRGFzaCA9ICEhY3R4LnNldExpbmVEYXNoOyAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcblxuICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7IC8vIFByb3h5IGNvbnRleHRcbiAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCB8fCBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aChjdHgpOyAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuXG4gICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpOyAvLyBDbGVhciBwYXRoIGRpcnR5IGZsYWdcblxuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG5cbiAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgfVxuXG4gICAgaGFzU3Ryb2tlICYmIHBhdGguc3Ryb2tlKGN0eCk7XG5cbiAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTsgLy8gRHJhdyByZWN0IHRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9LFxuICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gIC8vIExpa2UgaW4gY2lyY2xlXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcbiAgY3JlYXRlUGF0aFByb3h5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG5cbiAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWN0ID0gcmVjdDtcblxuICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7IC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG5cbiAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7IC8vIFBFTkRJTkcsIE1pbiBsaW5lIHdpZHRoIGlzIG5lZWRlZCB3aGVuIGxpbmUgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuXG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG5cbiAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICB9IC8vIENvbnNpZGVyIGxpbmUgd2lkdGhcbiAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG5cbiAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIHJlY3Qgd2l0aCBzdHJva2VcblxuXG4gICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuXG4gICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTsgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAqL1xuICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgIGlmIChkaXJ0eVBhdGggPT0gbnVsbCkge1xuICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICB9IC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cblxuXG4gICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7IC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG5cbiAgICBpZiAodGhpcy5fX2NsaXBUYXJnZXQpIHtcbiAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzaGFwZScsIGxvb3ApO1xuICB9LFxuICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBGSVhNRVxuICAgIGlmIChrZXkgPT09ICdzaGFwZScpIHtcbiAgICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTsgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcblxuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgc2hhcGVbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGdldExpbmVTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07IC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAvLyBEZXRlcm1pbmFudCBvZiBgbWAgbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgIC8vIGZvciB3aWR0aC5cblxuICAgIHJldHVybiBtICYmIGFicyhtWzBdIC0gMSkgPiAxZS0xMCAmJiBhYnMobVszXSAtIDEpID4gMWUtMTAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKSA6IDE7XG4gIH1cbn07XG4vKipcbiAqIOaJqeWxleS4gOS4qiBQYXRoIGVsZW1lbnQsIOavlOWmguaYn+W9ou+8jOWchuetieOAglxuICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy50eXBlIFBhdGggdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5idWlsZFBhdGggT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIEV4dGVuZGVkIGRlZmF1bHQgc3R5bGUgY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICovXG5cblBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIFBhdGguY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgIGlmIChkZWZhdWx0cy5zdHlsZSkge1xuICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc3R5bGVcbiAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgIH0gLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcblxuXG4gICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuXG4gICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICB2YXIgdGhpc1NoYXBlID0gdGhpcy5zaGFwZTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgaWYgKCF0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpc1NoYXBlW25hbWVdID0gZGVmYXVsdFNoYXBlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmYXVsdHMuaW5pdCAmJiBkZWZhdWx0cy5pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gIH07XG5cbiAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7IC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIG5hbWUgIT09ICdzaGFwZScpIHtcbiAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU3ViO1xufTtcblxuenJVdGlsLmluaGVyaXRzKFBhdGgsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFBhdGg7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBtYXRyaXggPSByZXF1aXJlKFwiLi9tYXRyaXhcIik7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cbnZhciB2MkFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xuXG5mdW5jdGlvbiBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAod2lkdGggPCAwKSB7XG4gICAgeCA9IHggKyB3aWR0aDtcbiAgICB3aWR0aCA9IC13aWR0aDtcbiAgfVxuXG4gIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cblxuICB0aGlzLnggPSB4O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy55ID0geTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufVxuXG5Cb3VuZGluZ1JlY3QucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQm91bmRpbmdSZWN0LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fSBvdGhlclxuICAgKi9cbiAgdW5pb246IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHZhciB4ID0gbWF0aE1pbihvdGhlci54LCB0aGlzLngpO1xuICAgIHZhciB5ID0gbWF0aE1pbihvdGhlci55LCB0aGlzLnkpO1xuICAgIHRoaXMud2lkdGggPSBtYXRoTWF4KG90aGVyLnggKyBvdGhlci53aWR0aCwgdGhpcy54ICsgdGhpcy53aWR0aCkgLSB4O1xuICAgIHRoaXMuaGVpZ2h0ID0gbWF0aE1heChvdGhlci55ICsgb3RoZXIuaGVpZ2h0LCB0aGlzLnkgKyB0aGlzLmhlaWdodCkgLSB5O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbVxuICAgKiBAbWV0aG9kc1xuICAgKi9cbiAgYXBwbHlUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbHQgPSBbXTtcbiAgICB2YXIgcmIgPSBbXTtcbiAgICB2YXIgbGIgPSBbXTtcbiAgICB2YXIgcnQgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG0pIHtcbiAgICAgIC8vIEluIGNhc2UgdXNhZ2UgbGlrZSB0aGlzXG4gICAgICAvLyBlbC5nZXRCb3VuZGluZ1JlY3QoKS5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pXG4gICAgICAvLyBBbmQgZWxlbWVudCBoYXMgbm8gdHJhbnNmb3JtXG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsdFswXSA9IGxiWzBdID0gdGhpcy54O1xuICAgICAgbHRbMV0gPSBydFsxXSA9IHRoaXMueTtcbiAgICAgIHJiWzBdID0gcnRbMF0gPSB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgICAgcmJbMV0gPSBsYlsxXSA9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShsdCwgbHQsIG0pO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShyYiwgcmIsIG0pO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShsYiwgbGIsIG0pO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShydCwgcnQsIG0pO1xuICAgICAgdGhpcy54ID0gbWF0aE1pbihsdFswXSwgcmJbMF0sIGxiWzBdLCBydFswXSk7XG4gICAgICB0aGlzLnkgPSBtYXRoTWluKGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgIHZhciBtYXhYID0gbWF0aE1heChsdFswXSwgcmJbMF0sIGxiWzBdLCBydFswXSk7XG4gICAgICB2YXIgbWF4WSA9IG1hdGhNYXgobHRbMV0sIHJiWzFdLCBsYlsxXSwgcnRbMV0pO1xuICAgICAgdGhpcy53aWR0aCA9IG1heFggLSB0aGlzLng7XG4gICAgICB0aGlzLmhlaWdodCA9IG1heFkgLSB0aGlzLnk7XG4gICAgfTtcbiAgfSgpLFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgbWF0cml4IG9mIHRyYW5zZm9ybWluZyBmcm9tIHNlbGYgdG8gdGFyZ2V0IHJlY3RcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IGJcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBjYWxjdWxhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChiKSB7XG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBzeCA9IGIud2lkdGggLyBhLndpZHRoO1xuICAgIHZhciBzeSA9IGIuaGVpZ2h0IC8gYS5oZWlnaHQ7XG4gICAgdmFyIG0gPSBtYXRyaXguY3JlYXRlKCk7IC8vIOefqemYteWPs+S5mFxuXG4gICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbLWEueCwgLWEueV0pO1xuICAgIG1hdHJpeC5zY2FsZShtLCBtLCBbc3gsIHN5XSk7XG4gICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcbiAgICByZXR1cm4gbTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHsobW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R8T2JqZWN0KX0gYlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoYikge1xuICAgIGlmICghYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghKGIgaW5zdGFuY2VvZiBCb3VuZGluZ1JlY3QpKSB7XG4gICAgICAvLyBOb3JtYWxpemUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0LlxuICAgICAgYiA9IEJvdW5kaW5nUmVjdC5jcmVhdGUoYik7XG4gICAgfVxuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBheDAgPSBhLng7XG4gICAgdmFyIGF4MSA9IGEueCArIGEud2lkdGg7XG4gICAgdmFyIGF5MCA9IGEueTtcbiAgICB2YXIgYXkxID0gYS55ICsgYS5oZWlnaHQ7XG4gICAgdmFyIGJ4MCA9IGIueDtcbiAgICB2YXIgYngxID0gYi54ICsgYi53aWR0aDtcbiAgICB2YXIgYnkwID0gYi55O1xuICAgIHZhciBieTEgPSBiLnkgKyBiLmhlaWdodDtcbiAgICByZXR1cm4gIShheDEgPCBieDAgfHwgYngxIDwgYXgwIHx8IGF5MSA8IGJ5MCB8fCBieTEgPCBheTApO1xuICB9LFxuICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciByZWN0ID0gdGhpcztcbiAgICByZXR1cm4geCA+PSByZWN0LnggJiYgeCA8PSByZWN0LnggKyByZWN0LndpZHRoICYmIHkgPj0gcmVjdC55ICYmIHkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb3B5IGZyb20gYW5vdGhlciByZWN0XG4gICAqL1xuICBjb3B5OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB0aGlzLnggPSBvdGhlci54O1xuICAgIHRoaXMueSA9IG90aGVyLnk7XG4gICAgdGhpcy53aWR0aCA9IG90aGVyLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0O1xuICB9LFxuICBwbGFpbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnksXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QueFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QueVxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3Qud2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LmhlaWdodFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gKi9cblxuQm91bmRpbmdSZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChyZWN0KSB7XG4gIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBCb3VuZGluZ1JlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2VudlwiKTtcblxudmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2NsYXp6XCIpO1xuXG52YXIgbGluZVN0eWxlTWl4aW4gPSByZXF1aXJlKFwiLi9taXhpbi9saW5lU3R5bGVcIik7XG5cbnZhciBhcmVhU3R5bGVNaXhpbiA9IHJlcXVpcmUoXCIuL21peGluL2FyZWFTdHlsZVwiKTtcblxudmFyIHRleHRTdHlsZU1peGluID0gcmVxdWlyZShcIi4vbWl4aW4vdGV4dFN0eWxlXCIpO1xuXG52YXIgaXRlbVN0eWxlTWl4aW4gPSByZXF1aXJlKFwiLi9taXhpbi9pdGVtU3R5bGVcIik7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL21vZGVsL01vZGVsXG4gKi9cbnZhciBtaXhpbiA9IHpyVXRpbC5taXhpbjtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtwYXJlbnRNb2RlbF1cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBbZWNNb2RlbF1cbiAqL1xuXG5mdW5jdGlvbiBNb2RlbChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgdGhpcy5wYXJlbnRNb2RlbCA9IHBhcmVudE1vZGVsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuXG4gIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG4gIHRoaXMub3B0aW9uID0gb3B0aW9uOyAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gIC8vIGlmICh0aGlzLmluaXQpIHtcbiAgLy8gICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDQpIHtcbiAgLy8gICAgICAgICB0aGlzLmluaXQob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpO1xuICAvLyAgICAgfVxuICAvLyAgICAgZWxzZSB7XG4gIC8vICAgICAgICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIC8vICAgICB9XG4gIC8vIH1cbn1cblxuTW9kZWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTW9kZWwsXG5cbiAgLyoqXG4gICAqIE1vZGVsIOeahOWIneWni+WMluWHveaVsFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gICAqL1xuICBpbml0OiBudWxsLFxuXG4gIC8qKlxuICAgKiDku47mlrDnmoQgT3B0aW9uIG1lcmdlXG4gICAqL1xuICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgb3B0aW9uLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlUGFyZW50PWZhbHNlXVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgaWdub3JlUGFyZW50KSB7XG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBkb0dldCh0aGlzLm9wdGlvbiwgdGhpcy5wYXJzZVBhdGgocGF0aCksICFpZ25vcmVQYXJlbnQgJiYgZ2V0UGFyZW50KHRoaXMsIHBhdGgpKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVQYXJlbnQ9ZmFsc2VdXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXRTaGFsbG93OiBmdW5jdGlvbiAoa2V5LCBpZ25vcmVQYXJlbnQpIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIHZhbCA9IG9wdGlvbiA9PSBudWxsID8gb3B0aW9uIDogb3B0aW9uW2tleV07XG4gICAgdmFyIHBhcmVudE1vZGVsID0gIWlnbm9yZVBhcmVudCAmJiBnZXRQYXJlbnQodGhpcywga2V5KTtcblxuICAgIGlmICh2YWwgPT0gbnVsbCAmJiBwYXJlbnRNb2RlbCkge1xuICAgICAgdmFsID0gcGFyZW50TW9kZWwuZ2V0U2hhbGxvdyhrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbcGF0aF1cbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3BhcmVudE1vZGVsXVxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICovXG4gIGdldE1vZGVsOiBmdW5jdGlvbiAocGF0aCwgcGFyZW50TW9kZWwpIHtcbiAgICB2YXIgb2JqID0gcGF0aCA9PSBudWxsID8gdGhpcy5vcHRpb24gOiBkb0dldCh0aGlzLm9wdGlvbiwgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpKTtcbiAgICB2YXIgdGhpc1BhcmVudE1vZGVsO1xuICAgIHBhcmVudE1vZGVsID0gcGFyZW50TW9kZWwgfHwgKHRoaXNQYXJlbnRNb2RlbCA9IGdldFBhcmVudCh0aGlzLCBwYXRoKSkgJiYgdGhpc1BhcmVudE1vZGVsLmdldE1vZGVsKHBhdGgpO1xuICAgIHJldHVybiBuZXcgTW9kZWwob2JqLCBwYXJlbnRNb2RlbCwgdGhpcy5lY01vZGVsKTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgbW9kZWwgaGFzIG9wdGlvblxuICAgKi9cbiAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbiA9PSBudWxsO1xuICB9LFxuICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXG4gIC8vIFBlbmRpbmdcbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgQ3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG5ldyBDdG9yKHpyVXRpbC5jbG9uZSh0aGlzLm9wdGlvbikpO1xuICB9LFxuICBzZXRSZWFkT25seTogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICBjbGF6elV0aWwuc2V0UmVhZE9ubHkodGhpcywgcHJvcGVydGllcyk7XG4gIH0sXG4gIC8vIElmIHBhdGggaXMgbnVsbC91bmRlZmluZWQsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAgcGFyc2VQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldFBhcmVudE1ldGhvZFxuICAgKiAgICAgICAgcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gcGF0aFxuICAgKiAgICAgICAgcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICovXG4gIGN1c3RvbWl6ZUdldFBhcmVudDogZnVuY3Rpb24gKGdldFBhcmVudE1ldGhvZCkge1xuICAgIGNsYXp6VXRpbC5zZXQodGhpcywgJ2dldFBhcmVudCcsIGdldFBhcmVudE1ldGhvZCk7XG4gIH0sXG4gIGlzQW5pbWF0aW9uRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZW52Lm5vZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbi5hbmltYXRpb24gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLm9wdGlvbi5hbmltYXRpb247XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50TW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBkb0dldChvYmosIHBhdGhBcnIsIHBhcmVudE1vZGVsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEFyci5sZW5ndGg7IGkrKykge1xuICAgIC8vIElnbm9yZSBlbXB0eVxuICAgIGlmICghcGF0aEFycltpXSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBvYmogY291bGQgYmUgbnVtYmVyL3N0cmluZy8uLi4gKGxpa2UgMClcblxuXG4gICAgb2JqID0gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnID8gb2JqW3BhdGhBcnJbaV1dIDogbnVsbDtcblxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9iaiA9PSBudWxsICYmIHBhcmVudE1vZGVsKSB7XG4gICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGhBcnIpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0gLy8gYHBhdGhgIGNhbiBiZSBudWxsL3VuZGVmaW5lZFxuXG5cbmZ1bmN0aW9uIGdldFBhcmVudChtb2RlbCwgcGF0aCkge1xuICB2YXIgZ2V0UGFyZW50TWV0aG9kID0gY2xhenpVdGlsLmdldChtb2RlbCwgJ2dldFBhcmVudCcpO1xuICByZXR1cm4gZ2V0UGFyZW50TWV0aG9kID8gZ2V0UGFyZW50TWV0aG9kLmNhbGwobW9kZWwsIHBhdGgpIDogbW9kZWwucGFyZW50TW9kZWw7XG59IC8vIEVuYWJsZSBNb2RlbC5leHRlbmQuXG5cblxuY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcbm1peGluKE1vZGVsLCBsaW5lU3R5bGVNaXhpbik7XG5taXhpbihNb2RlbCwgYXJlYVN0eWxlTWl4aW4pO1xubWl4aW4oTW9kZWwsIHRleHRTdHlsZU1peGluKTtcbm1peGluKE1vZGVsLCBpdGVtU3R5bGVNaXhpbik7XG52YXIgX2RlZmF1bHQgPSBNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuL251bWJlclwiKTtcblxudmFyIHBhcnNlUGVyY2VudCA9IF9udW1iZXIucGFyc2VQZXJjZW50O1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcblxuLy8gTGF5b3V0IGhlbHBlcnMgZm9yIGVhY2ggY29tcG9uZW50IHBvc2l0aW9uaW5nXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cblxudmFyIExPQ0FUSU9OX1BBUkFNUyA9IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ3dpZHRoJywgJ2hlaWdodCddO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cblxudmFyIEhWX05BTUVTID0gW1snd2lkdGgnLCAnbGVmdCcsICdyaWdodCddLCBbJ2hlaWdodCcsICd0b3AnLCAnYm90dG9tJ11dO1xuXG5mdW5jdGlvbiBib3hMYXlvdXQob3JpZW50LCBncm91cCwgZ2FwLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuXG4gIGlmIChtYXhXaWR0aCA9PSBudWxsKSB7XG4gICAgbWF4V2lkdGggPSBJbmZpbml0eTtcbiAgfVxuXG4gIGlmIChtYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgIG1heEhlaWdodCA9IEluZmluaXR5O1xuICB9XG5cbiAgdmFyIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IDA7XG4gIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGNoaWxkLnBvc2l0aW9uO1xuICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIG5leHRDaGlsZCA9IGdyb3VwLmNoaWxkQXQoaWR4ICsgMSk7XG4gICAgdmFyIG5leHRDaGlsZFJlY3QgPSBuZXh0Q2hpbGQgJiYgbmV4dENoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBuZXh0WDtcbiAgICB2YXIgbmV4dFk7XG5cbiAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHZhciBtb3ZlWCA9IHJlY3Qud2lkdGggKyAobmV4dENoaWxkUmVjdCA/IC1uZXh0Q2hpbGRSZWN0LnggKyByZWN0LnggOiAwKTtcbiAgICAgIG5leHRYID0geCArIG1vdmVYOyAvLyBXcmFwIHdoZW4gd2lkdGggZXhjZWVkcyBtYXhXaWR0aCBvciBtZWV0IGEgYG5ld2xpbmVgIGdyb3VwXG4gICAgICAvLyBGSVhNRSBjb21wYXJlIGJlZm9yZSBhZGRpbmcgZ2FwP1xuXG4gICAgICBpZiAobmV4dFggPiBtYXhXaWR0aCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgICBuZXh0WCA9IG1vdmVYO1xuICAgICAgICB5ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGSVhNRTogY29uc2lkZXIgcmVjdC55IGlzIG5vdCBgMGA/XG4gICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRMaW5lTWF4U2l6ZSwgcmVjdC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW92ZVkgPSByZWN0LmhlaWdodCArIChuZXh0Q2hpbGRSZWN0ID8gLW5leHRDaGlsZFJlY3QueSArIHJlY3QueSA6IDApO1xuICAgICAgbmV4dFkgPSB5ICsgbW92ZVk7IC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heEhlaWdodCBvciBtZWV0IGEgYG5ld2xpbmVgIGdyb3VwXG5cbiAgICAgIGlmIChuZXh0WSA+IG1heEhlaWdodCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgIHggKz0gY3VycmVudExpbmVNYXhTaXplICsgZ2FwO1xuICAgICAgICB5ID0gMDtcbiAgICAgICAgbmV4dFkgPSBtb3ZlWTtcbiAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRMaW5lTWF4U2l6ZSwgcmVjdC53aWR0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLm5ld2xpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb3NpdGlvblswXSA9IHg7XG4gICAgcG9zaXRpb25bMV0gPSB5O1xuICAgIG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8geCA9IG5leHRYICsgZ2FwIDogeSA9IG5leHRZICsgZ2FwO1xuICB9KTtcbn1cbi8qKlxuICogVkJveCBvciBIQm94IGxheW91dGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPUluZmluaXR5XVxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9SW5maW5pdHldXG4gKi9cblxuXG52YXIgYm94ID0gYm94TGF5b3V0O1xuLyoqXG4gKiBWQm94IGxheW91dGluZ1xuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPUluZmluaXR5XVxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9SW5maW5pdHldXG4gKi9cblxudmFyIHZib3ggPSB6clV0aWwuY3VycnkoYm94TGF5b3V0LCAndmVydGljYWwnKTtcbi8qKlxuICogSEJveCBsYXlvdXRpbmdcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICogQHBhcmFtIHtudW1iZXJ9IGdhcFxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PUluZmluaXR5XVxuICovXG5cbnZhciBoYm94ID0genJVdGlsLmN1cnJ5KGJveExheW91dCwgJ2hvcml6b250YWwnKTtcbi8qKlxuICogSWYgeCBvciB4MiBpcyBub3Qgc3BlY2lmaWVkIG9yICdjZW50ZXInICdsZWZ0JyAncmlnaHQnLFxuICogdGhlIHdpZHRoIHdvdWxkIGJlIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gKiBJZiB5IG9yIHkyIGlzIG5vdCBzcGVjaWZpZWQgb3IgJ21pZGRsZScgJ3RvcCcgJ2JvdHRvbScsXG4gKiB0aGUgaGVpZ2h0IHdvdWxkIGJlIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uSW5mb1xuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnhdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueV1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby54Ml1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby55Ml1cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJSZWN0IHt3aWR0aCwgaGVpZ2h0fVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBtYXJnaW5cbiAqIEByZXR1cm4ge09iamVjdH0ge3dpZHRoLCBoZWlnaHR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0QXZhaWxhYmxlU2l6ZShwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbikge1xuICB2YXIgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWN0LndpZHRoO1xuICB2YXIgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyUmVjdC5oZWlnaHQ7XG4gIHZhciB4ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby54LCBjb250YWluZXJXaWR0aCk7XG4gIHZhciB5ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby55LCBjb250YWluZXJIZWlnaHQpO1xuICB2YXIgeDIgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLngyLCBjb250YWluZXJXaWR0aCk7XG4gIHZhciB5MiA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueTIsIGNvbnRhaW5lckhlaWdodCk7XG4gIChpc05hTih4KSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby54KSkpICYmICh4ID0gMCk7XG4gIChpc05hTih4MikgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueDIpKSkgJiYgKHgyID0gY29udGFpbmVyV2lkdGgpO1xuICAoaXNOYU4oeSkgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueSkpKSAmJiAoeSA9IDApO1xuICAoaXNOYU4oeTIpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLnkyKSkpICYmICh5MiA9IGNvbnRhaW5lckhlaWdodCk7XG4gIG1hcmdpbiA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkobWFyZ2luIHx8IDApO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBNYXRoLm1heCh4MiAtIHggLSBtYXJnaW5bMV0gLSBtYXJnaW5bM10sIDApLFxuICAgIGhlaWdodDogTWF0aC5tYXgoeTIgLSB5IC0gbWFyZ2luWzBdIC0gbWFyZ2luWzJdLCAwKVxuICB9O1xufVxuLyoqXG4gKiBQYXJzZSBwb3NpdGlvbiBpbmZvLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbkluZm9cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5sZWZ0XVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnRvcF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5yaWdodF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5ib3R0b21dXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ud2lkdGhdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uaGVpZ2h0XVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmFzcGVjdF0gQXNwZWN0IGlzIHdpZHRoIC8gaGVpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyUmVjdFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbbWFyZ2luXVxuICpcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbikge1xuICBtYXJnaW4gPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KG1hcmdpbiB8fCAwKTtcbiAgdmFyIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyUmVjdC53aWR0aDtcbiAgdmFyIGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lclJlY3QuaGVpZ2h0O1xuICB2YXIgbGVmdCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ubGVmdCwgY29udGFpbmVyV2lkdGgpO1xuICB2YXIgdG9wID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby50b3AsIGNvbnRhaW5lckhlaWdodCk7XG4gIHZhciByaWdodCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ucmlnaHQsIGNvbnRhaW5lcldpZHRoKTtcbiAgdmFyIGJvdHRvbSA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8uYm90dG9tLCBjb250YWluZXJIZWlnaHQpO1xuICB2YXIgd2lkdGggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLndpZHRoLCBjb250YWluZXJXaWR0aCk7XG4gIHZhciBoZWlnaHQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmhlaWdodCwgY29udGFpbmVySGVpZ2h0KTtcbiAgdmFyIHZlcnRpY2FsTWFyZ2luID0gbWFyZ2luWzJdICsgbWFyZ2luWzBdO1xuICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IG1hcmdpblsxXSArIG1hcmdpblszXTtcbiAgdmFyIGFzcGVjdCA9IHBvc2l0aW9uSW5mby5hc3BlY3Q7IC8vIElmIHdpZHRoIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSB3aWR0aCBmcm9tIGxlZnQgYW5kIHJpZ2h0XG5cbiAgaWYgKGlzTmFOKHdpZHRoKSkge1xuICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGggLSByaWdodCAtIGhvcml6b250YWxNYXJnaW4gLSBsZWZ0O1xuICB9XG5cbiAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSB2ZXJ0aWNhbE1hcmdpbiAtIHRvcDtcbiAgfVxuXG4gIGlmIChhc3BlY3QgIT0gbnVsbCkge1xuICAgIC8vIElmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIG5vdCBnaXZlblxuICAgIC8vIDEuIEdyYXBoIHNob3VsZCBub3QgZXhjZWVkcyB0aGUgY29udGFpbmVyXG4gICAgLy8gMi4gQXNwZWN0IG11c3QgYmUga2VlcGVkXG4gICAgLy8gMy4gR3JhcGggc2hvdWxkIHRha2UgdGhlIHNwYWNlIGFzIG1vcmUgYXMgcG9zc2libGVcbiAgICAvLyBGSVhNRVxuICAgIC8vIE1hcmdpbiBpcyBub3QgY29uc2lkZXJlZCwgYmVjYXVzZSB0aGVyZSBpcyBubyBjYXNlIHRoYXQgYm90aFxuICAgIC8vIHVzaW5nIG1hcmdpbiBhbmQgYXNwZWN0IHNvIGZhci5cbiAgICBpZiAoaXNOYU4od2lkdGgpICYmIGlzTmFOKGhlaWdodCkpIHtcbiAgICAgIGlmIChhc3BlY3QgPiBjb250YWluZXJXaWR0aCAvIGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoICogMC44O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0ICogMC44O1xuICAgICAgfVxuICAgIH0gLy8gQ2FsY3VsYXRlIHdpZHRoIG9yIGhlaWdodCB3aXRoIGdpdmVuIGFzcGVjdFxuXG5cbiAgICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdCAqIGhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfVxuICB9IC8vIElmIGxlZnQgaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIGxlZnQgZnJvbSByaWdodCBhbmQgd2lkdGhcblxuXG4gIGlmIChpc05hTihsZWZ0KSkge1xuICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gd2lkdGggLSBob3Jpem9udGFsTWFyZ2luO1xuICB9XG5cbiAgaWYgKGlzTmFOKHRvcCkpIHtcbiAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSBoZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbjtcbiAgfSAvLyBBbGlnbiBsZWZ0IGFuZCB0b3BcblxuXG4gIHN3aXRjaCAocG9zaXRpb25JbmZvLmxlZnQgfHwgcG9zaXRpb25JbmZvLnJpZ2h0KSB7XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAvIDIgLSB3aWR0aCAvIDIgLSBtYXJnaW5bM107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbjtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3dpdGNoIChwb3NpdGlvbkluZm8udG9wIHx8IHBvc2l0aW9uSW5mby5ib3R0b20pIHtcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMiAtIG1hcmdpblswXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAtIGhlaWdodCAtIHZlcnRpY2FsTWFyZ2luO1xuICAgICAgYnJlYWs7XG4gIH0gLy8gSWYgc29tZXRoaW5nIGlzIHdyb25nIGFuZCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgYXJlIGNhbGN1bGF0ZWQgYXMgTmFOXG5cblxuICBsZWZ0ID0gbGVmdCB8fCAwO1xuICB0b3AgPSB0b3AgfHwgMDtcblxuICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgLy8gV2lkdGggbWF5IGJlIE5hTiBpZiBvbmx5IG9uZSB2YWx1ZSBpcyBnaXZlbiBleGNlcHQgd2lkdGhcbiAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbiAtIGxlZnQgLSAocmlnaHQgfHwgMCk7XG4gIH1cblxuICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgIC8vIEhlaWdodCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCBoZWlnaHRcbiAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbiAtIHRvcCAtIChib3R0b20gfHwgMCk7XG4gIH1cblxuICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QobGVmdCArIG1hcmdpblszXSwgdG9wICsgbWFyZ2luWzBdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgcmVjdC5tYXJnaW4gPSBtYXJnaW47XG4gIHJldHVybiByZWN0O1xufVxuLyoqXG4gKiBQb3NpdGlvbiBhIHpyIGVsZW1lbnQgaW4gdmlld3BvcnRcbiAqICBHcm91cCBwb3NpdGlvbiBpcyBzcGVjaWZpZWQgYnkgZWl0aGVyXG4gKiAge2xlZnQsIHRvcH0sIHtyaWdodCwgYm90dG9tfVxuICogIElmIGFsbCBwcm9wZXJ0aWVzIGV4aXN0cywgcmlnaHQgYW5kIGJvdHRvbSB3aWxsIGJlIGlnb25yZWQuXG4gKlxuICogTG9naWM6XG4gKiAgICAgMS4gU2NhbGUgKGFnYWluc3Qgb3JpZ2luIHBvaW50IGluIHBhcmVudCBjb29yZClcbiAqICAgICAyLiBSb3RhdGUgKGFnYWluc3Qgb3JpZ2luIHBvaW50IGluIHBhcmVudCBjb29yZClcbiAqICAgICAzLiBUcmFzbGF0ZSAod2l0aCBlbC5wb3NpdGlvbiBieSB0aGlzIG1ldGhvZClcbiAqIFNvIHRoaXMgbWV0aG9kIG9ubHkgZml4ZXMgdGhlIGxhc3Qgc3RlcCAnVHJhc2xhdGUnLCB3aGljaCBkb2VzIG5vdCBhZmZlY3RcbiAqIHNjYWxpbmcgYW5kIHJvdGF0aW5nLlxuICpcbiAqIElmIGJlIGNhbGxlZCByZXBlYXRseSB3aXRoIHRoZSBzYW1lIGlucHV0IGVsLCB0aGUgc2FtZSByZXN1bHQgd2lsbCBiZSBnb3R0ZW4uXG4gKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbCBTaG91bGQgaGF2ZSBgZ2V0Qm91bmRpbmdSZWN0YCBtZXRob2QuXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25JbmZvXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ubGVmdF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby50b3BdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ucmlnaHRdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uYm90dG9tXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLndpZHRoXSBPbmx5IGZvciBvcHQuYm91bmRpbmdNb2RlbDogJ3JhdydcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5oZWlnaHRdIE9ubHkgZm9yIG9wdC5ib3VuZGluZ01vZGVsOiAncmF3J1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclJlY3RcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbWFyZ2luXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHQuaHY9WzEsMV1dIE9ubHkgaG9yaXpvbnRhbCBvciBvbmx5IHZlcnRpY2FsLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW29wdC5ib3VuZGluZ01vZGU9J2FsbCddXG4gKiAgICAgICAgU3BlY2lmeSBob3cgdG8gY2FsY3VsYXRlIGJvdW5kaW5nUmVjdCB3aGVuIGxvY2F0aW5nLlxuICogICAgICAgICdhbGwnOiBQb3NpdGlvbiB0aGUgYm91bmRpbmdSZWN0IHRoYXQgaXMgdHJhbnNmb3JtZWQgYW5kIHVpb25lZFxuICogICAgICAgICAgICAgICBib3RoIGl0c2VsZiBhbmQgaXRzIGRlc2NlbmRhbnRzLlxuICogICAgICAgICAgICAgICBUaGlzIG1vZGUgc2ltcGxpZXMgY29uZmluZSB0aGUgZWxlbWVudHMgaW4gdGhlIGJvdW5kaW5nXG4gKiAgICAgICAgICAgICAgIG9mIHRoZWlyIGNvbnRhaW5lciAoZS5nLiwgdXNpbmcgJ3JpZ2h0OiAwJykuXG4gKiAgICAgICAgJ3Jhdyc6IFBvc2l0aW9uIHRoZSBib3VuZGluZ1JlY3QgdGhhdCBpcyBub3QgdHJhbnNmb3JtZWQgYW5kIG9ubHkgaXRzZWxmLlxuICogICAgICAgICAgICAgICBUaGlzIG1vZGUgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgYSBlbGVtZW50IGNhbiBvdmVyZmxvdyBpdHNcbiAqICAgICAgICAgICAgICAgY29udGFpbmVyLiAoQ29uc2lkZXIgYSByb3RhdGVkIGNpcmNsZSBuZWVkcyB0byBiZSBsb2NhdGVkIGluIGEgY29ybmVyLilcbiAqICAgICAgICAgICAgICAgSW4gdGhpcyBtb2RlIHBvc2l0aW9uSW5mby53aWR0aC9oZWlnaHQgY2FuIG9ubHkgYmUgbnVtYmVyLlxuICovXG5cblxuZnVuY3Rpb24gcG9zaXRpb25FbGVtZW50KGVsLCBwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbiwgb3B0KSB7XG4gIHZhciBoID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlswXTtcbiAgdmFyIHYgPSAhb3B0IHx8ICFvcHQuaHYgfHwgb3B0Lmh2WzFdO1xuICB2YXIgYm91bmRpbmdNb2RlID0gb3B0ICYmIG9wdC5ib3VuZGluZ01vZGUgfHwgJ2FsbCc7XG5cbiAgaWYgKCFoICYmICF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlY3Q7XG5cbiAgaWYgKGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycpIHtcbiAgICByZWN0ID0gZWwudHlwZSA9PT0gJ2dyb3VwJyA/IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgK3Bvc2l0aW9uSW5mby53aWR0aCB8fCAwLCArcG9zaXRpb25JbmZvLmhlaWdodCB8fCAwKSA6IGVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICB9IGVsc2Uge1xuICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcblxuICAgIGlmIChlbC5uZWVkTG9jYWxUcmFuc2Zvcm0oKSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsLmdldExvY2FsVHJhbnNmb3JtKCk7IC8vIE5vdGljZTogcmF3IHJlY3QgbWF5IGJlIGlubmVyIG9iamVjdCBvZiBlbCxcbiAgICAgIC8vIHdoaWNoIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXG5cbiAgICAgIHJlY3QgPSByZWN0LmNsb25lKCk7XG4gICAgICByZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgfVxuICB9IC8vIFRoZSByZWFsIHdpZHRoIGFuZCBoZWlnaHQgY2FuIG5vdCBiZSBzcGVjaWZpZWQgYnV0IGNhbGN1bGF0ZWQgYnkgdGhlIGdpdmVuIGVsLlxuXG5cbiAgcG9zaXRpb25JbmZvID0gZ2V0TGF5b3V0UmVjdCh6clV0aWwuZGVmYXVsdHMoe1xuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfSwgcG9zaXRpb25JbmZvKSwgY29udGFpbmVyUmVjdCwgbWFyZ2luKTsgLy8gQmVjYXVzZSAndHJhbmxhdGUnIGlzIHRoZSBsYXN0IHN0ZXAgaW4gdHJhbnNmb3JtXG4gIC8vIChzZWUgenJlbmRlci9jb3JlL1RyYW5zZm9ybWFibGUjZ2V0TG9jYWxUcmFuc2Zyb20pLFxuICAvLyB3ZSBjYW4ganVzdCBvbmx5IG1vZGlmeSBlbC5wb3NpdGlvbiB0byBnZXQgZmluYWwgcmVzdWx0LlxuXG4gIHZhciBlbFBvcyA9IGVsLnBvc2l0aW9uO1xuICB2YXIgZHggPSBoID8gcG9zaXRpb25JbmZvLnggLSByZWN0LnggOiAwO1xuICB2YXIgZHkgPSB2ID8gcG9zaXRpb25JbmZvLnkgLSByZWN0LnkgOiAwO1xuICBlbC5hdHRyKCdwb3NpdGlvbicsIGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycgPyBbZHgsIGR5XSA6IFtlbFBvc1swXSArIGR4LCBlbFBvc1sxXSArIGR5XSk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24gQ29udGFpbnMgc29tZSBvZiB0aGUgcHJvcGVydGllcyBpbiBIVl9OQU1FUy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBodklkeCAwOiBob3Jpem9udGFsOyAxOiB2ZXJ0aWNhbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNpemVDYWxjdWxhYmxlKG9wdGlvbiwgaHZJZHgpIHtcbiAgcmV0dXJuIG9wdGlvbltIVl9OQU1FU1todklkeF1bMF1dICE9IG51bGwgfHwgb3B0aW9uW0hWX05BTUVTW2h2SWR4XVsxXV0gIT0gbnVsbCAmJiBvcHRpb25bSFZfTkFNRVNbaHZJZHhdWzJdXSAhPSBudWxsO1xufVxuLyoqXG4gKiBDb25zaWRlciBDYXNlOlxuICogV2hlbiBkZWZ1bGF0IG9wdGlvbiBoYXMge2xlZnQ6IDAsIHdpZHRoOiAxMDB9LCBhbmQgd2Ugc2V0IHtyaWdodDogMH1cbiAqIHRocm91Z2ggc2V0T3B0aW9uIG9yIG1lZGlhIHF1ZXJ5LCB1c2luZyBub3JtYWwgenJVdGlsLm1lcmdlIHdpbGwgY2F1c2VcbiAqIHtyaWdodDogMH0gZG9lcyBub3QgdGFrZSBlZmZlY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG4gKiAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICogICAgICAgICAuLi5cbiAqICAgICAgICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbik7XG4gKiAgICAgICAgIHRoaXMubWVyZ2VPcHRpb24oaW5wdXRQb3NpdGlvblBhcmFtcyk7XG4gKiAgICAgfSxcbiAqICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICogICAgICAgICBuZXdPcHRpb24gJiYgenJVdGlsLm1lcmdlKHRoaXNPcHRpb24sIG5ld09wdGlvbiwgdHJ1ZSk7XG4gKiAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKHRoaXNPcHRpb24sIG5ld09wdGlvbik7XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldE9wdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG5ld09wdGlvblxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0XVxuICogQHBhcmFtIHtib29sZWFufEFycmF5Ljxib29sZWFuPn0gW29wdC5pZ25vcmVTaXplPWZhbHNlXSBVc2VkIGZvciB0aGUgY29tcG9uZW50c1xuICogIHRoYXQgd2lkdGggKG9yIGhlaWdodCkgc2hvdWxkIG5vdCBiZSBjYWxjdWxhdGVkIGJ5IGxlZnQgYW5kIHJpZ2h0IChvciB0b3AgYW5kIGJvdHRvbSkuXG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZUxheW91dFBhcmFtKHRhcmdldE9wdGlvbiwgbmV3T3B0aW9uLCBvcHQpIHtcbiAgIXpyVXRpbC5pc09iamVjdChvcHQpICYmIChvcHQgPSB7fSk7XG4gIHZhciBpZ25vcmVTaXplID0gb3B0Lmlnbm9yZVNpemU7XG4gICF6clV0aWwuaXNBcnJheShpZ25vcmVTaXplKSAmJiAoaWdub3JlU2l6ZSA9IFtpZ25vcmVTaXplLCBpZ25vcmVTaXplXSk7XG4gIHZhciBoUmVzdWx0ID0gbWVyZ2UoSFZfTkFNRVNbMF0sIDApO1xuICB2YXIgdlJlc3VsdCA9IG1lcmdlKEhWX05BTUVTWzFdLCAxKTtcbiAgY29weShIVl9OQU1FU1swXSwgdGFyZ2V0T3B0aW9uLCBoUmVzdWx0KTtcbiAgY29weShIVl9OQU1FU1sxXSwgdGFyZ2V0T3B0aW9uLCB2UmVzdWx0KTtcblxuICBmdW5jdGlvbiBtZXJnZShuYW1lcywgaHZJZHgpIHtcbiAgICB2YXIgbmV3UGFyYW1zID0ge307XG4gICAgdmFyIG5ld1ZhbHVlQ291bnQgPSAwO1xuICAgIHZhciBtZXJnZWQgPSB7fTtcbiAgICB2YXIgbWVyZ2VkVmFsdWVDb3VudCA9IDA7XG4gICAgdmFyIGVub3VnaFBhcmFtTnVtYmVyID0gMjtcbiAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbWVyZ2VkW25hbWVdID0gdGFyZ2V0T3B0aW9uW25hbWVdO1xuICAgIH0pO1xuICAgIGVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAvLyBDb25zaWRlciBjYXNlOiBuZXdPcHRpb24ud2lkdGggaXMgbnVsbCwgd2hpY2ggaXNcbiAgICAgIC8vIHNldCBieSB1c2VyIGZvciByZW1vdmluZyB3aWR0aCBzZXR0aW5nLlxuICAgICAgaGFzUHJvcChuZXdPcHRpb24sIG5hbWUpICYmIChuZXdQYXJhbXNbbmFtZV0gPSBtZXJnZWRbbmFtZV0gPSBuZXdPcHRpb25bbmFtZV0pO1xuICAgICAgaGFzVmFsdWUobmV3UGFyYW1zLCBuYW1lKSAmJiBuZXdWYWx1ZUNvdW50Kys7XG4gICAgICBoYXNWYWx1ZShtZXJnZWQsIG5hbWUpICYmIG1lcmdlZFZhbHVlQ291bnQrKztcbiAgICB9KTtcblxuICAgIGlmIChpZ25vcmVTaXplW2h2SWR4XSkge1xuICAgICAgLy8gT25seSBvbmUgb2YgbGVmdC9yaWdodCBpcyBwcmVtaXR0ZWQgdG8gZXhpc3QuXG4gICAgICBpZiAoaGFzVmFsdWUobmV3T3B0aW9uLCBuYW1lc1sxXSkpIHtcbiAgICAgICAgbWVyZ2VkW25hbWVzWzJdXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGhhc1ZhbHVlKG5ld09wdGlvbiwgbmFtZXNbMl0pKSB7XG4gICAgICAgIG1lcmdlZFtuYW1lc1sxXV0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH0gLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgLy8gb3IgdGFyZ2V0T3B0aW9uOiB7cmlnaHQ6IC4uLn0gYW5kIG5ld09wdGlvbjoge3dpZHRoOiAuLi59LFxuICAgIC8vIFRoZXJlIGlzIG5vIGNvbmZsaWN0IHdoZW4gbWVyZ2VkIG9ubHkgaGFzIHBhcmFtcyBjb3VudFxuICAgIC8vIGxpdHRsZSB0aGFuIGVub3VnaFBhcmFtTnVtYmVyLlxuXG5cbiAgICBpZiAobWVyZ2VkVmFsdWVDb3VudCA9PT0gZW5vdWdoUGFyYW1OdW1iZXIgfHwgIW5ld1ZhbHVlQ291bnQpIHtcbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSAvLyBDYXNlOiBuZXdPcHRpb246IHt3aWR0aDogLi4uLCByaWdodDogLi4ufSxcbiAgICAvLyBUaGFuIHdlIGNhbiBtYWtlIHN1cmUgdXNlciBvbmx5IHdhbnQgdGhvc2UgdHdvLCBhbmQgaWdub3JlXG4gICAgLy8gYWxsIG9yaWdpbiBwYXJhbXMgaW4gdGFyZ2V0T3B0aW9uLlxuICAgIGVsc2UgaWYgKG5ld1ZhbHVlQ291bnQgPj0gZW5vdWdoUGFyYW1OdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENob3NlIGFub3RoZXIgcGFyYW0gZnJvbSB0YXJnZXRPcHRpb24gYnkgcHJpb3JpdHkuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuXG4gICAgICAgICAgaWYgKCFoYXNQcm9wKG5ld1BhcmFtcywgbmFtZSkgJiYgaGFzUHJvcCh0YXJnZXRPcHRpb24sIG5hbWUpKSB7XG4gICAgICAgICAgICBuZXdQYXJhbXNbbmFtZV0gPSB0YXJnZXRPcHRpb25bbmFtZV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzUHJvcChvYmosIG5hbWUpIHtcbiAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzVmFsdWUob2JqLCBuYW1lKSB7XG4gICAgcmV0dXJuIG9ialtuYW1lXSAhPSBudWxsICYmIG9ialtuYW1lXSAhPT0gJ2F1dG8nO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weShuYW1lcywgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIFJldHJpZXZlICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0JyBmcm9tIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAqIEByZXR1cm4ge09iamVjdH0gUmVzdWx0IGNvbnRhaW5zIHRob3NlIHByb3BzLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGF5b3V0UGFyYW1zKHNvdXJjZSkge1xuICByZXR1cm4gY29weUxheW91dFBhcmFtcyh7fSwgc291cmNlKTtcbn1cbi8qKlxuICogUmV0cmlldmUgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnIGZyb20gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICogQHJldHVybiB7T2JqZWN0fSBSZXN1bHQgY29udGFpbnMgdGhvc2UgcHJvcHMuXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5TGF5b3V0UGFyYW1zKHRhcmdldCwgc291cmNlKSB7XG4gIHNvdXJjZSAmJiB0YXJnZXQgJiYgZWFjaChMT0NBVElPTl9QQVJBTVMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgc291cmNlLmhhc093blByb3BlcnR5KG5hbWUpICYmICh0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0cy5MT0NBVElPTl9QQVJBTVMgPSBMT0NBVElPTl9QQVJBTVM7XG5leHBvcnRzLkhWX05BTUVTID0gSFZfTkFNRVM7XG5leHBvcnRzLmJveCA9IGJveDtcbmV4cG9ydHMudmJveCA9IHZib3g7XG5leHBvcnRzLmhib3ggPSBoYm94O1xuZXhwb3J0cy5nZXRBdmFpbGFibGVTaXplID0gZ2V0QXZhaWxhYmxlU2l6ZTtcbmV4cG9ydHMuZ2V0TGF5b3V0UmVjdCA9IGdldExheW91dFJlY3Q7XG5leHBvcnRzLnBvc2l0aW9uRWxlbWVudCA9IHBvc2l0aW9uRWxlbWVudDtcbmV4cG9ydHMuc2l6ZUNhbGN1bGFibGUgPSBzaXplQ2FsY3VsYWJsZTtcbmV4cG9ydHMubWVyZ2VMYXlvdXRQYXJhbSA9IG1lcmdlTGF5b3V0UGFyYW07XG5leHBvcnRzLmdldExheW91dFBhcmFtcyA9IGdldExheW91dFBhcmFtcztcbmV4cG9ydHMuY29weUxheW91dFBhcmFtcyA9IGNvcHlMYXlvdXRQYXJhbXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9sYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgVFlQRV9ERUxJTUlURVIgPSAnLic7XG52YXIgSVNfQ09OVEFJTkVSID0gJ19fX0VDX19DT01QT05FTlRfX0NPTlRBSU5FUl9fXyc7XG52YXIgTUVNQkVSX1BSSUZJWCA9ICdcXDBlY19cXDAnO1xuLyoqXG4gKiBIaWRlIHByaXZhdGUgY2xhc3MgbWVtYmVyLlxuICogVGhlIHNhbWUgYmVoYXZpb3IgYXMgYGhvc3RbbmFtZV0gPSB2YWx1ZTtgIChjYW4gYmUgcmlnaHQtdmFsdWUpXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gc2V0KGhvc3QsIG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBob3N0W01FTUJFUl9QUklGSVggKyBuYW1lXSA9IHZhbHVlO1xufVxuLyoqXG4gKiBIaWRlIHByaXZhdGUgY2xhc3MgbWVtYmVyLlxuICogVGhlIHNhbWUgYmVoYXZpb3IgYXMgYGhvc3RbbmFtZV07YFxuICogQHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZ2V0KGhvc3QsIG5hbWUpIHtcbiAgcmV0dXJuIGhvc3RbTUVNQkVSX1BSSUZJWCArIG5hbWVdO1xufVxuLyoqXG4gKiBGb3IgaGlkZGVuIHByaXZhdGUgY2xhc3MgbWVtYmVyLlxuICogVGhlIHNhbWUgYmVoYXZpb3IgYXMgYGhvc3QuaGFzT3duUHJvcGVydHkobmFtZSk7YFxuICogQHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gaGFzT3duKGhvc3QsIG5hbWUpIHtcbiAgcmV0dXJuIGhvc3QuaGFzT3duUHJvcGVydHkoTUVNQkVSX1BSSUZJWCArIG5hbWUpO1xufVxuLyoqXG4gKiBOb3RpY2UsIHBhcnNlQ2xhc3NUeXBlKCcnKSBzaG91bGQgcmV0dXJucyB7bWFpbjogJycsIHN1YjogJyd9XG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKSB7XG4gIHZhciByZXQgPSB7XG4gICAgbWFpbjogJycsXG4gICAgc3ViOiAnJ1xuICB9O1xuXG4gIGlmIChjb21wb25lbnRUeXBlKSB7XG4gICAgY29tcG9uZW50VHlwZSA9IGNvbXBvbmVudFR5cGUuc3BsaXQoVFlQRV9ERUxJTUlURVIpO1xuICAgIHJldC5tYWluID0gY29tcG9uZW50VHlwZVswXSB8fCAnJztcbiAgICByZXQuc3ViID0gY29tcG9uZW50VHlwZVsxXSB8fCAnJztcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNoZWNrQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpIHtcbiAgenJVdGlsLmFzc2VydCgvXlthLXpBLVowLTlfXSsoWy5dW2EtekEtWjAtOV9dKyk/JC8udGVzdChjb21wb25lbnRUeXBlKSwgJ2NvbXBvbmVudFR5cGUgXCInICsgY29tcG9uZW50VHlwZSArICdcIiBpbGxlZ2FsJyk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuYWJsZUNsYXNzRXh0ZW5kKFJvb3RDbGFzcywgbWFuZGF0b3J5TWV0aG9kcykge1xuICBSb290Q2xhc3MuJGNvbnN0cnVjdG9yID0gUm9vdENsYXNzO1xuXG4gIFJvb3RDbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcbiAgICB2YXIgc3VwZXJDbGFzcyA9IHRoaXM7XG5cbiAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghcHJvdG8uJGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3RvLiRjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuZXh0ZW5kKEV4dGVuZGVkQ2xhc3MucHJvdG90eXBlLCBwcm90byk7XG4gICAgRXh0ZW5kZWRDbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcbiAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2FsbCA9IHN1cGVyQ2FsbDtcbiAgICBFeHRlbmRlZENsYXNzLnN1cGVyQXBwbHkgPSBzdXBlckFwcGx5O1xuICAgIHpyVXRpbC5pbmhlcml0cyhFeHRlbmRlZENsYXNzLCB0aGlzKTtcbiAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xuICAgIHJldHVybiBFeHRlbmRlZENsYXNzO1xuICB9O1xufSAvLyBzdXBlckNhbGwgc2hvdWxkIGhhdmUgY2xhc3MgaW5mbywgd2hpY2ggY2FuIG5vdCBiZSBmZXRjaCBmcm9tICd0aGlzJy5cbi8vIENvbnNpZGVyIHRoaXMgY2FzZTpcbi8vIGNsYXNzIEEgaGFzIG1ldGhvZCBmLFxuLy8gY2xhc3MgQiBpbmhlcml0cyBjbGFzcyBBLCBvdmVycmlkZXMgbWV0aG9kIGYsIGYgY2FsbCBzdXBlckFwcGx5KCdmJyksXG4vLyBjbGFzcyBDIGluaGVyaXRzIGNsYXNzIEIsIGRvIG5vdCBvdmVycmlkZXMgbWV0aG9kIGYsXG4vLyB0aGVuIHdoZW4gbWV0aG9kIG9mIGNsYXNzIEMgaXMgY2FsbGVkLCBkZWFkIGxvb3Agb2NjdXJlZC5cblxuXG5mdW5jdGlvbiBzdXBlckNhbGwoY29udGV4dCwgbWV0aG9kTmFtZSkge1xuICB2YXIgYXJncyA9IHpyVXRpbC5zbGljZShhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gdGhpcy5zdXBlckNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseShjb250ZXh0LCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gc3VwZXJBcHBseShjb250ZXh0LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gZW50aXR5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWdpc3RlcldoZW5FeHRlbmRdXG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBlbmFibGVDbGFzc01hbmFnZW1lbnQoZW50aXR5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAvKipcbiAgICogQ29tcG9uZW50IG1vZGVsIGNsYXNzZXNcbiAgICoga2V5OiBjb21wb25lbnRUeXBlLFxuICAgKiB2YWx1ZTpcbiAgICogICAgIGNvbXBvbmVudENsYXNzLCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eCdcbiAgICogICAgIG9yIE9iamVjdC48c3ViS2V5LCBjb21wb25lbnRDbGFzcz4sIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4Lnl5J1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB2YXIgc3RvcmFnZSA9IHt9O1xuXG4gIGVudGl0eS5yZWdpc3RlckNsYXNzID0gZnVuY3Rpb24gKENsYXp6LCBjb21wb25lbnRUeXBlKSB7XG4gICAgaWYgKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgIGNoZWNrQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuXG4gICAgICBpZiAoIWNvbXBvbmVudFR5cGUuc3ViKSB7XG4gICAgICAgIHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IENsYXp6O1xuICAgICAgfSBlbHNlIGlmIChjb21wb25lbnRUeXBlLnN1YiAhPT0gSVNfQ09OVEFJTkVSKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICBjb250YWluZXJbY29tcG9uZW50VHlwZS5zdWJdID0gQ2xheno7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENsYXp6O1xuICB9O1xuXG4gIGVudGl0eS5nZXRDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRNYWluVHlwZSwgc3ViVHlwZSwgdGhyb3dXaGVuTm90Rm91bmQpIHtcbiAgICB2YXIgQ2xhenogPSBzdG9yYWdlW2NvbXBvbmVudE1haW5UeXBlXTtcblxuICAgIGlmIChDbGF6eiAmJiBDbGF6eltJU19DT05UQUlORVJdKSB7XG4gICAgICBDbGF6eiA9IHN1YlR5cGUgPyBDbGF6eltzdWJUeXBlXSA6IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRocm93V2hlbk5vdEZvdW5kICYmICFDbGF6eikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCFzdWJUeXBlID8gY29tcG9uZW50TWFpblR5cGUgKyAnLicgKyAndHlwZSBzaG91bGQgYmUgc3BlY2lmaWVkLicgOiAnQ29tcG9uZW50ICcgKyBjb21wb25lbnRNYWluVHlwZSArICcuJyArIChzdWJUeXBlIHx8ICcnKSArICcgbm90IGV4aXN0cy4gTG9hZCBpdCBmaXJzdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ2xheno7XG4gIH07XG5cbiAgZW50aXR5LmdldENsYXNzZXNCeU1haW5UeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcbiAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBvYmogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XG5cbiAgICBpZiAob2JqICYmIG9ialtJU19DT05UQUlORVJdKSB7XG4gICAgICB6clV0aWwuZWFjaChvYmosIGZ1bmN0aW9uIChvLCB0eXBlKSB7XG4gICAgICAgIHR5cGUgIT09IElTX0NPTlRBSU5FUiAmJiByZXN1bHQucHVzaChvKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChvYmopO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZW50aXR5Lmhhc0NsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcbiAgICAvLyBKdXN0IGNvbnNpZGVyIGNvbXBvbmVudFR5cGUubWFpbi5cbiAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG4gICAgcmV0dXJuICEhc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuICB9O1xuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IExpa2UgWydhYScsICdiYiddLCBidXQgY2FuIG5vdCBiZSBbJ2FhLnh4J11cbiAgICovXG5cblxuICBlbnRpdHkuZ2V0QWxsQ2xhc3NNYWluVHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGVzID0gW107XG4gICAgenJVdGlsLmVhY2goc3RvcmFnZSwgZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xuICAgICAgdHlwZXMucHVzaCh0eXBlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH07XG4gIC8qKlxuICAgKiBJZiBhIG1haW4gdHlwZSBpcyBjb250YWluZXIgYW5kIGhhcyBzdWIgdHlwZXNcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbWFpblR5cGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBlbnRpdHkuaGFzU3ViVHlwZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuICAgIHJldHVybiBvYmogJiYgb2JqW0lTX0NPTlRBSU5FUl07XG4gIH07XG5cbiAgZW50aXR5LnBhcnNlQ2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGU7XG5cbiAgZnVuY3Rpb24gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcblxuICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXJbSVNfQ09OVEFJTkVSXSkge1xuICAgICAgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0ge307XG4gICAgICBjb250YWluZXJbSVNfQ09OVEFJTkVSXSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZCkge1xuICAgIHZhciBvcmlnaW5hbEV4dGVuZCA9IGVudGl0eS5leHRlbmQ7XG5cbiAgICBpZiAob3JpZ2luYWxFeHRlbmQpIHtcbiAgICAgIGVudGl0eS5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcbiAgICAgICAgdmFyIEV4dGVuZGVkQ2xhc3MgPSBvcmlnaW5hbEV4dGVuZC5jYWxsKHRoaXMsIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIGVudGl0eS5yZWdpc3RlckNsYXNzKEV4dGVuZGVkQ2xhc3MsIHByb3RvLnR5cGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW50aXR5O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcHJvcGVydGllc1xuICovXG5cblxuZnVuY3Rpb24gc2V0UmVhZE9ubHkob2JqLCBwcm9wZXJ0aWVzKSB7Ly8gRklYTUUgSXQgc2VlbXMgYnJva2VuIGluIElFOCBzaW11bGF0aW9uIG9mIElFMTFcbiAgLy8gaWYgKCF6clV0aWwuaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuICAvLyAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgIT0gbnVsbCA/IFtwcm9wZXJ0aWVzXSA6IFtdO1xuICAvLyB9XG4gIC8vIHpyVXRpbC5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uIChwcm9wKSB7XG4gIC8vICAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gIC8vICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLy8gICAgICAgICAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gIC8vICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwgd3JpdGFibGU6IGZhbHNlXG4gIC8vICAgICAgICAgfSk7XG4gIC8vICAgICB6clV0aWwuaXNBcnJheShvYmpbcHJvcF0pXG4gIC8vICAgICAgICAgJiYgT2JqZWN0LmZyZWV6ZVxuICAvLyAgICAgICAgICYmIE9iamVjdC5mcmVlemUob2JqW3Byb3BdKTtcbiAgLy8gfSk7XG59XG5cbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5nZXQgPSBnZXQ7XG5leHBvcnRzLmhhc093biA9IGhhc093bjtcbmV4cG9ydHMucGFyc2VDbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZTtcbmV4cG9ydHMuZW5hYmxlQ2xhc3NFeHRlbmQgPSBlbmFibGVDbGFzc0V4dGVuZDtcbmV4cG9ydHMuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50ID0gZW5hYmxlQ2xhc3NNYW5hZ2VtZW50O1xuZXhwb3J0cy5zZXRSZWFkT25seSA9IHNldFJlYWRPbmx5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvY2xhenouanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi9Nb2RlbFwiKTtcblxudmFyIGNvbXBvbmVudFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9jb21wb25lbnRcIik7XG5cbnZhciBjbGF6elV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9jbGF6elwiKTtcblxudmFyIGxheW91dCA9IHJlcXVpcmUoXCIuLi91dGlsL2xheW91dFwiKTtcblxudmFyIGJveExheW91dE1peGluID0gcmVxdWlyZShcIi4vbWl4aW4vYm94TGF5b3V0XCIpO1xuXG4vKipcbiAqIENvbXBvbmVudCBtb2RlbFxuICpcbiAqIEBtb2R1bGUgZWNoYXJ0cy9tb2RlbC9Db21wb25lbnRcbiAqL1xudmFyIGFycmF5UHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHBhcmVudE1vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBlY01vZGVsXG4gKi9cblxudmFyIENvbXBvbmVudE1vZGVsID0gTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ2NvbXBvbmVudCcsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgaWQ6ICcnLFxuXG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIG5hbWU6ICcnLFxuXG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIG1haW5UeXBlOiAnJyxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdWJUeXBlOiAnJyxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBjb21wb25lbnRJbmRleDogMCxcblxuICAvKipcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZGVmYXVsdE9wdGlvbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBlY01vZGVsOiBudWxsLFxuXG4gIC8qKlxuICAgKiBrZXk6IGNvbXBvbmVudFR5cGVcbiAgICogdmFsdWU6ICBDb21wb25lbnQgbW9kZWwgbGlzdCwgY2FuIG5vdCBiZSBudWxsLlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD4+fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGRlcGVuZGVudE1vZGVsczogW10sXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgdWlkOiBudWxsLFxuXG4gIC8qKlxuICAgKiBTdXBwb3J0IG1lcmdlIGxheW91dCBwYXJhbXMuXG4gICAqIE9ubHkgc3VwcG9ydCAnYm94JyBub3cgKGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQpLlxuICAgKiBAdHlwZSB7c3RyaW5nfE9iamVjdH0gT2JqZWN0IGNhbiBiZSB7aWdub3JlU2l6ZTogdHJ1ZX1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBsYXlvdXRNb2RlOiBudWxsLFxuICAkY29uc3RydWN0b3I6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgIE1vZGVsLmNhbGwodGhpcywgb3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpO1xuICAgIHRoaXMudWlkID0gY29tcG9uZW50VXRpbC5nZXRVSUQoJ2NvbXBvbmVudE1vZGVsJyk7XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcbiAgfSxcbiAgbWVyZ2VEZWZhdWx0QW5kVGhlbWU6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcbiAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGUgPyBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbikgOiB7fTtcbiAgICB2YXIgdGhlbWVNb2RlbCA9IGVjTW9kZWwuZ2V0VGhlbWUoKTtcbiAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGVtZU1vZGVsLmdldCh0aGlzLm1haW5UeXBlKSk7XG4gICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpO1xuXG4gICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcywgbGF5b3V0TW9kZSk7XG4gICAgfVxuICB9LFxuICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbiwgZXh0cmFPcHQpIHtcbiAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XG4gICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG5cbiAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0odGhpcy5vcHRpb24sIG9wdGlvbiwgbGF5b3V0TW9kZSk7XG4gICAgfVxuICB9LFxuICAvLyBIb29rZXIgYWZ0ZXIgaW5pdCBvciBtZXJnZU9wdGlvblxuICBvcHRpb25VcGRhdGVkOiBmdW5jdGlvbiAobmV3Q3B0T3B0aW9uLCBpc0luaXQpIHt9LFxuICBnZXREZWZhdWx0T3B0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjbGF6elV0aWwuaGFzT3duKHRoaXMsICdfX2RlZmF1bHRPcHRpb24nKSkge1xuICAgICAgdmFyIG9wdExpc3QgPSBbXTtcbiAgICAgIHZhciBDbGFzcyA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICAgIHdoaWxlIChDbGFzcykge1xuICAgICAgICB2YXIgb3B0ID0gQ2xhc3MucHJvdG90eXBlLmRlZmF1bHRPcHRpb247XG4gICAgICAgIG9wdCAmJiBvcHRMaXN0LnB1c2gob3B0KTtcbiAgICAgICAgQ2xhc3MgPSBDbGFzcy5zdXBlckNsYXNzO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBkZWZhdWx0T3B0aW9uID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb24sIG9wdExpc3RbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjbGF6elV0aWwuc2V0KHRoaXMsICdfX2RlZmF1bHRPcHRpb24nLCBkZWZhdWx0T3B0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhenpVdGlsLmdldCh0aGlzLCAnX19kZWZhdWx0T3B0aW9uJyk7XG4gIH0sXG4gIGdldFJlZmVycmluZ0NvbXBvbmVudHM6IGZ1bmN0aW9uIChtYWluVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgIG1haW5UeXBlOiBtYWluVHlwZSxcbiAgICAgIGluZGV4OiB0aGlzLmdldChtYWluVHlwZSArICdJbmRleCcsIHRydWUpLFxuICAgICAgaWQ6IHRoaXMuZ2V0KG1haW5UeXBlICsgJ0lkJywgdHJ1ZSlcbiAgICB9KTtcbiAgfVxufSk7IC8vIFJlc2V0IENvbXBvbmVudE1vZGVsLmV4dGVuZCwgYWRkIHByZUNvbnN0cnVjdC5cbi8vIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChcbi8vICAgICBDb21wb25lbnRNb2RlbCxcbi8vICAgICBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbi8vICAgICAgICAgLy8gU2V0IGRlcGVuZGVudE1vZGVscywgY29tcG9uZW50SW5kZXgsIG5hbWUsIGlkLCBtYWluVHlwZSwgc3ViVHlwZS5cbi8vICAgICAgICAgenJVdGlsLmV4dGVuZCh0aGlzLCBleHRyYU9wdCk7XG4vLyAgICAgICAgIHRoaXMudWlkID0gY29tcG9uZW50VXRpbC5nZXRVSUQoJ2NvbXBvbmVudE1vZGVsJyk7XG4vLyAgICAgICAgIC8vIHRoaXMuc2V0UmVhZE9ubHkoW1xuLy8gICAgICAgICAvLyAgICAgJ3R5cGUnLCAnaWQnLCAndWlkJywgJ25hbWUnLCAnbWFpblR5cGUnLCAnc3ViVHlwZScsXG4vLyAgICAgICAgIC8vICAgICAnZGVwZW5kZW50TW9kZWxzJywgJ2NvbXBvbmVudEluZGV4J1xuLy8gICAgICAgICAvLyBdKTtcbi8vICAgICB9XG4vLyApO1xuLy8gQWRkIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuXG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KENvbXBvbmVudE1vZGVsLCB7XG4gIHJlZ2lzdGVyV2hlbkV4dGVuZDogdHJ1ZVxufSk7XG5jb21wb25lbnRVdGlsLmVuYWJsZVN1YlR5cGVEZWZhdWx0ZXIoQ29tcG9uZW50TW9kZWwpOyAvLyBBZGQgY2FwYWJpbGl0eSBvZiBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbC5cblxuY29tcG9uZW50VXRpbC5lbmFibGVUb3BvbG9naWNhbFRyYXZlbChDb21wb25lbnRNb2RlbCwgZ2V0RGVwZW5kZW5jaWVzKTtcblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGNvbXBvbmVudFR5cGUpIHtcbiAgdmFyIGRlcHMgPSBbXTtcbiAgenJVdGlsLmVhY2goQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUoY29tcG9uZW50VHlwZSksIGZ1bmN0aW9uIChDbGF6eikge1xuICAgIGFycmF5UHVzaC5hcHBseShkZXBzLCBDbGF6ei5wcm90b3R5cGUuZGVwZW5kZW5jaWVzIHx8IFtdKTtcbiAgfSk7IC8vIEVuc3VyZSBtYWluIHR5cGVcblxuICByZXR1cm4genJVdGlsLm1hcChkZXBzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiBjbGF6elV0aWwucGFyc2VDbGFzc1R5cGUodHlwZSkubWFpbjtcbiAgfSk7XG59XG5cbnpyVXRpbC5taXhpbihDb21wb25lbnRNb2RlbCwgYm94TGF5b3V0TWl4aW4pO1xudmFyIF9kZWZhdWx0ID0gQ29tcG9uZW50TW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4uL21peGluL0V2ZW50ZnVsXCIpO1xuXG5leHBvcnRzLkRpc3BhdGNoZXIgPSBFdmVudGZ1bDtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuL2VudlwiKTtcblxuLyoqXG4gKiDkuovku7bovoXliqnnsbtcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2V2ZW50XG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqL1xudmFyIGlzRG9tTGV2ZWwyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcjtcbnZhciBNT1VTRV9FVkVOVF9SRUcgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay87XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICAvLyBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpIGRvbid0IGhhdmUgZ2V0Qm91bmRpbmdSZWN0XG4gIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMFxuICB9O1xufSAvLyBgY2FsY3VsYXRlYCBpcyBvcHRpb25hbCwgZGVmYXVsdCBmYWxzZVxuXG5cbmZ1bmN0aW9uIGNsaWVudFRvTG9jYWwoZWwsIGUsIG91dCwgY2FsY3VsYXRlKSB7XG4gIG91dCA9IG91dCB8fCB7fTsgLy8gQWNjb3JkaW5nIHRvIHRoZSBXM0MgV29ya2luZyBEcmFmdCwgb2Zmc2V0WCBhbmQgb2Zmc2V0WSBzaG91bGQgYmUgcmVsYXRpdmVcbiAgLy8gdG8gdGhlIHBhZGRpbmcgZWRnZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuIFRoZSBvbmx5IGJyb3dzZXIgdXNpbmcgdGhpcyBjb252ZW50aW9uXG4gIC8vIGlzIElFLiBXZWJraXQgdXNlcyB0aGUgYm9yZGVyIGVkZ2UsIE9wZXJhIHVzZXMgdGhlIGNvbnRlbnQgZWRnZSwgYW5kIEZpcmVGb3ggZG9lc1xuICAvLyBub3Qgc3VwcG9ydCB0aGUgcHJvcGVydGllcy5cbiAgLy8gKHNlZSBodHRwOi8vd3d3LmphY2tsbW9vcmUuY29tL25vdGVzL21vdXNlLXBvc2l0aW9uLylcbiAgLy8gSW4genIgcGFpbnRlci5kb20sIHBhZGRpbmcgZWRnZSBlcXVhbHMgdG8gYm9yZGVyIGVkZ2UuXG4gIC8vIEZJWE1FXG4gIC8vIFdoZW4gbW91c2Vtb3ZlIGV2ZW50IHRyaWdnZXJlZCBvbiBlYyB0b29sdGlwLCB0YXJnZXQgaXMgbm90IHpyIHBhaW50ZXIuZG9tLCBhbmRcbiAgLy8gb2Zmc2V0WC9ZIGlzIHJlbGF0aXZlIHRvIGUudGFyZ2V0LCB3aGVyZSB0aGUgY2FsY3VsYXRpb24gb2YgenJYL1kgdmlhIG9mZnNldFgvWVxuICAvLyBpcyB0b28gY29tcGxleC4gU28gY3NzLXRyYW5zZnJvbSBkb250IHN1cHBvcnQgaW4gdGhpcyBjYXNlIHRlbXBvcmFyaWx5LlxuXG4gIGlmIChjYWxjdWxhdGUgfHwgIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KTtcbiAgfSAvLyBDYXV0aW9uOiBJbiBGaXJlRm94LCBsYXllclgvbGF5ZXJZIE1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBjbG9zZXN0IHBvc2l0aW9uZWRcbiAgLy8gYW5jZXN0b3IgZWxlbWVudCwgc28gd2Ugc2hvdWxkIG1ha2Ugc3VyZSBlbCBpcyBwb3NpdGlvbmVkIChlLmcuLCBub3QgcG9zaXRpb246c3RhdGljKS5cbiAgLy8gQlRXMSwgV2Via2l0IGRvbid0IHJldHVybiB0aGUgc2FtZSByZXN1bHRzIGFzIEZGIGluIG5vbi1zaW1wbGUgY2FzZXMgKGxpa2UgYWRkXG4gIC8vIHpvb20tZmFjdG9yLCBvdmVyZmxvdyAvIG9wYWNpdHkgbGF5ZXJzLCB0cmFuc2Zvcm1zIC4uLilcbiAgLy8gQlRXMiwgKGV2Lm9mZnNldFkgfHwgZXYucGFnZVkgLSAkKGV2LnRhcmdldCkub2Zmc2V0KCkudG9wKSBpcyBub3QgY29ycmVjdCBpbiBwcmVzZXJ2ZS0zZC5cbiAgLy8gPGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84NTIzI2NvbW1lbnQ6MTQ+XG4gIC8vIEJUVzMsIEluIGZmLCBvZmZzZXRYL29mZnNldFkgaXMgYWx3YXlzIDAuXG4gIGVsc2UgaWYgKGVudi5icm93c2VyLmZpcmVmb3ggJiYgZS5sYXllclggIT0gbnVsbCAmJiBlLmxheWVyWCAhPT0gZS5vZmZzZXRYKSB7XG4gICAgICBvdXQuenJYID0gZS5sYXllclg7XG4gICAgICBvdXQuenJZID0gZS5sYXllclk7XG4gICAgfSAvLyBGb3IgSUU2KywgY2hyb21lLCBzYWZhcmksIG9wZXJhLiAoV2hlbiB3aWxsIGZmIHN1cHBvcnQgb2Zmc2V0WD8pXG4gICAgZWxzZSBpZiAoZS5vZmZzZXRYICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnpyWCA9IGUub2Zmc2V0WDtcbiAgICAgICAgb3V0LnpyWSA9IGUub2Zmc2V0WTtcbiAgICAgIH0gLy8gRm9yIHNvbWUgb3RoZXIgZGV2aWNlLCBlLmcuLCBJT1Mgc2FmYXJpLlxuICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gICAgICAgIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KSB7XG4gIC8vIFRoaXMgd2VsbC1rbm93biBtZXRob2QgYmVsb3cgZG9lcyBub3Qgc3VwcG9ydCBjc3MgdHJhbnNmb3JtLlxuICB2YXIgYm94ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKTtcbiAgb3V0LnpyWCA9IGUuY2xpZW50WCAtIGJveC5sZWZ0O1xuICBvdXQuenJZID0gZS5jbGllbnRZIC0gYm94LnRvcDtcbn1cbi8qKlxuICog5aaC5p6c5a2Y5Zyo56ys5LiJ5pa55bWM5YWl55qE5LiA5LqbZG9t6Kem5Y+R55qE5LqL5Lu277yM5oiWdG91Y2jkuovku7bvvIzpnIDopoHovazmjaLkuIDkuIvkuovku7blnZDmoIcuXG4gKiBgY2FsY3VsYXRlYCBpcyBvcHRpb25hbCwgZGVmYXVsdCBmYWxzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50KGVsLCBlLCBjYWxjdWxhdGUpIHtcbiAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gIGlmIChlLnpyWCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICB2YXIgZXZlbnRUeXBlID0gZS50eXBlO1xuICB2YXIgaXNUb3VjaCA9IGV2ZW50VHlwZSAmJiBldmVudFR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwO1xuXG4gIGlmICghaXNUb3VjaCkge1xuICAgIGNsaWVudFRvTG9jYWwoZWwsIGUsIGUsIGNhbGN1bGF0ZSk7XG4gICAgZS56ckRlbHRhID0gZS53aGVlbERlbHRhID8gZS53aGVlbERlbHRhIC8gMTIwIDogLShlLmRldGFpbCB8fCAwKSAvIDM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnRUeXBlICE9ICd0b3VjaGVuZCcgPyBlLnRhcmdldFRvdWNoZXNbMF0gOiBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHRvdWNoICYmIGNsaWVudFRvTG9jYWwoZWwsIHRvdWNoLCBlLCBjYWxjdWxhdGUpO1xuICB9IC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHQ7IG90aGVyd2lzZTogMDtcbiAgLy8gU2VlIGpRdWVyeTogaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2V2ZW50LmpzXG4gIC8vIElmIGUud2hpY2ggaGFzIGJlZW4gZGVmaW5lZCwgaWYgbWF5IGJlIHJlYWRvbmx5LFxuICAvLyBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L3doaWNoXG5cblxuICB2YXIgYnV0dG9uID0gZS5idXR0b247XG5cbiAgaWYgKGUud2hpY2ggPT0gbnVsbCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBNT1VTRV9FVkVOVF9SRUcudGVzdChlLnR5cGUpKSB7XG4gICAgZS53aGljaCA9IGJ1dHRvbiAmIDEgPyAxIDogYnV0dG9uICYgMiA/IDMgOiBidXR0b24gJiA0ID8gMiA6IDA7XG4gIH1cblxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gIGlmIChpc0RvbUxldmVsMikge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICB9XG59XG4vKipcbiAqIHByZXZlbnREZWZhdWx0IGFuZCBzdG9wUHJvcGFnYXRpb24uXG4gKiBOb3RpY2U6IGRvIG5vdCBkbyB0aGF0IGluIHpyZW5kZXIuIFVwcGVyIGFwcGxpY2F0aW9uXG4gKiBkbyB0aGF0IGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9ldmVudFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtFdmVudH0gZSA6IGV2ZW505a+56LGhXG4gKi9cblxuXG52YXIgc3RvcCA9IGlzRG9tTGV2ZWwyID8gZnVuY3Rpb24gKGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG59IDogZnVuY3Rpb24gKGUpIHtcbiAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG59O1xuXG5mdW5jdGlvbiBub3RMZWZ0TW91c2UoZSkge1xuICAvLyBJZiBlLndoaWNoIGlzIHVuZGVmaW5lZCwgY29uc2lkZXJlZCBhcyBsZWZ0IG1vdXNlIGV2ZW50LlxuICByZXR1cm4gZS53aGljaCA+IDE7XG59IC8vIOWBmuWQkeS4iuWFvOWuuVxuXG5cbmV4cG9ydHMuY2xpZW50VG9Mb2NhbCA9IGNsaWVudFRvTG9jYWw7XG5leHBvcnRzLm5vcm1hbGl6ZUV2ZW50ID0gbm9ybWFsaXplRXZlbnQ7XG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMuc3RvcCA9IHN0b3A7XG5leHBvcnRzLm5vdExlZnRNb3VzZSA9IG5vdExlZnRNb3VzZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIOS6i+S7tuaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgYXJyeVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuLyoqXG4gKiDkuovku7bliIblj5HlmahcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIEV2ZW50ZnVsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbn07XG5cbkV2ZW50ZnVsLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEV2ZW50ZnVsLFxuXG4gIC8qKlxuICAgKiDljZXmrKHop6blj5Hnu5HlrprvvIx0cmlnZ2Vy5ZCO6ZSA5q+BXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlk43lupTlh73mlbBcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIG9uZTogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgaDogaGFuZGxlcixcbiAgICAgIG9uZTogdHJ1ZSxcbiAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog57uR5a6a5LqL5Lu2XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgKi9cbiAgb246IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICBfaFtldmVudF0gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgIGg6IGhhbmRsZXIsXG4gICAgICBvbmU6IGZhbHNlLFxuICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmmK/lkKbnu5Hlrprkuobkuovku7ZcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzU2lsZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG4gICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDop6Pnu5Hkuovku7ZcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGlmIChfaFtldmVudF0pIHtcbiAgICAgICAgdmFyIG5ld0xpc3QgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldWydoJ10gIT0gaGFuZGxlcikge1xuICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgIH1cblxuICAgICAgaWYgKF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOS6i+S7tuWIhuWPkVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICovXG4gIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGlmIChhcmdMZW4gPiAzKSB7XG4gICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICBfaFtpXVsnaCddLmFwcGx5KF9oW2ldWydjdHgnXSwgYXJncyk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgKi9cbiAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJnTGVuID4gNCkge1xuICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgpO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICBfaC5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTsgLy8g5a+56LGh5Y+v5Lul6YCa6L+HIG9ueHh4eCDnu5Hlrprkuovku7ZcblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25jbGlja1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdmVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW91dFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vtb3ZlXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXdoZWVsXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZWRvd25cbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNldXBcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdzdGFydFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VuZFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VudGVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnbGVhdmVcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdvdmVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcm9wXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxudmFyIF9kZWZhdWx0ID0gRXZlbnRmdWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9oZWxwZXIvaW1hZ2VcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBnZXRDb250ZXh0ID0gX3V0aWwuZ2V0Q29udGV4dDtcbnZhciBleHRlbmQgPSBfdXRpbC5leHRlbmQ7XG52YXIgcmV0cmlldmUyID0gX3V0aWwucmV0cmlldmUyO1xudmFyIHJldHJpZXZlMyA9IF91dGlsLnJldHJpZXZlMztcbnZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xudmFyIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG52YXIgVEVYVF9DQUNIRV9NQVggPSA1MDAwO1xudmFyIFNUWUxFX1JFRyA9IC9cXHsoW2EtekEtWjAtOV9dKylcXHwoW159XSopXFx9L2c7XG52YXIgREVGQVVMVF9GT05UID0gJzEycHggc2Fucy1zZXJpZic7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0V2lkdGgodGV4dCwgZm9udCkge1xuICBmb250ID0gZm9udCB8fCBERUZBVUxUX0ZPTlQ7XG4gIHZhciBrZXkgPSB0ZXh0ICsgJzonICsgZm9udDtcblxuICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICB9XG5cbiAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIHdpZHRoID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyB0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCBtYXkgYmUgb3ZlcnJpZGVkIGluIFNWRyBvciBWTUxcbiAgICB3aWR0aCA9IE1hdGgubWF4KG1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgZm9udCkud2lkdGgsIHdpZHRoKTtcbiAgfVxuXG4gIGlmICh0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPiBURVhUX0NBQ0hFX01BWCkge1xuICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG4gIHJldHVybiB3aWR0aDtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3RleHRQYWRkaW5nXVxuICogQHBhcmFtIHtPYmplY3R9IFtyaWNoXVxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0ge3gsIHksIHdpZHRoLCBoZWlnaHQsIGxpbmVIZWlnaHR9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSB7XG4gIHJldHVybiByaWNoID8gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkgOiBnZXRQbGFpblRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCB0cnVuY2F0ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGdldFdpZHRoKHRleHQsIGZvbnQpO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIG91dGVyV2lkdGggKz0gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG4gIHJlY3QubGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkge1xuICB2YXIgY29udGVudEJsb2NrID0gcGFyc2VSaWNoVGV4dCh0ZXh0LCB7XG4gICAgcmljaDogcmljaCxcbiAgICB0cnVuY2F0ZTogdHJ1bmNhdGUsXG4gICAgZm9udDogZm9udCxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0UGFkZGluZzogdGV4dFBhZGRpbmdcbiAgfSk7XG4gIHZhciBvdXRlcldpZHRoID0gY29udGVudEJsb2NrLm91dGVyV2lkdGg7XG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0QWxpZ249J2xlZnQnXVxuICogQHJldHVybiB7bnVtYmVyfSBBZGp1c3RlZCB4LlxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFgoeCwgd2lkdGgsIHRleHRBbGlnbikge1xuICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09IHdpZHRoIC8gMjtcbiAgfVxuXG4gIHJldHVybiB4O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0VmVydGljYWxBbGlnbj0ndG9wJ11cbiAqIEByZXR1cm4ge251bWJlcn0gQWRqdXN0ZWQgeS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRZKHksIGhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJykge1xuICAgIHkgLT0gaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB5O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0aXJuZ30gdGV4dFBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIGRpc3RhbmNlKSB7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueTtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9ICd0b3AnO1xuXG4gIHN3aXRjaCAodGV4dFBvc2l0aW9uKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB4IC09IGRpc3RhbmNlO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHggKz0gZGlzdGFuY2UgKyB3aWR0aDtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgLT0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGVpZ2h0ICsgZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVMZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVSaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlVG9wJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3BMZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3BSaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbVJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG4vKipcbiAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWF4SXRlcmF0aW9ucz0zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICogICAgICAgICAgICAgICAgICB0aGVuIG1pbkNoYXIsIGVsbGlwc2lzIHdpbGwgbm90IHNob3csIHdoaWNoIGlzXG4gKiAgICAgICAgICAgICAgICAgIGJldHRlciBmb3IgdXNlciBoaW50IGluIHNvbWUgY2FzZXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiB0cnVuY2F0ZVRleHQodGV4dCwgY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICBvcHRpb25zID0gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpOyAvLyBGSVhNRVxuICAvLyBJdCBpcyBub3QgYXBwcm9wcmlhdGUgdGhhdCBldmVyeSBsaW5lIGhhcyAnLi4uJyB3aGVuIHRydW5jYXRlIG11bHRpcGxlIGxpbmVzLlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0ZXh0TGluZXNbaV0gPSB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmVzW2ldLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0TGluZXMuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUcnVuY2F0ZU9wdGlvbnMoY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBvcHRpb25zLmZvbnQgPSBmb250O1xuICB2YXIgZWxsaXBzaXMgPSByZXRyaWV2ZTIoZWxsaXBzaXMsICcuLi4nKTtcbiAgb3B0aW9ucy5tYXhJdGVyYXRpb25zID0gcmV0cmlldmUyKG9wdGlvbnMubWF4SXRlcmF0aW9ucywgMik7XG4gIHZhciBtaW5DaGFyID0gb3B0aW9ucy5taW5DaGFyID0gcmV0cmlldmUyKG9wdGlvbnMubWluQ2hhciwgMCk7IC8vIEZJWE1FXG4gIC8vIE90aGVyIGxhbmd1YWdlcz9cblxuICBvcHRpb25zLmNuQ2hhcldpZHRoID0gZ2V0V2lkdGgoJ+WbvScsIGZvbnQpOyAvLyBGSVhNRVxuICAvLyBDb25zaWRlciBwcm9wb3J0aW9uYWwgZm9udD9cblxuICB2YXIgYXNjQ2hhcldpZHRoID0gb3B0aW9ucy5hc2NDaGFyV2lkdGggPSBnZXRXaWR0aCgnYScsIGZvbnQpO1xuICBvcHRpb25zLnBsYWNlaG9sZGVyID0gcmV0cmlldmUyKG9wdGlvbnMucGxhY2Vob2xkZXIsICcnKTsgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cblxuICB2YXIgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggPSBNYXRoLm1heCgwLCBjb250YWluZXJXaWR0aCAtIDEpOyAvLyBSZXNlcnZlIHNvbWUgZ2FwLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhciAmJiBjb250ZW50V2lkdGggPj0gYXNjQ2hhcldpZHRoOyBpKyspIHtcbiAgICBjb250ZW50V2lkdGggLT0gYXNjQ2hhcldpZHRoO1xuICB9XG5cbiAgdmFyIGVsbGlwc2lzV2lkdGggPSBnZXRXaWR0aChlbGxpcHNpcyk7XG5cbiAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICBlbGxpcHNpcyA9ICcnO1xuICAgIGVsbGlwc2lzV2lkdGggPSAwO1xuICB9XG5cbiAgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggLSBlbGxpcHNpc1dpZHRoO1xuICBvcHRpb25zLmVsbGlwc2lzID0gZWxsaXBzaXM7XG4gIG9wdGlvbnMuZWxsaXBzaXNXaWR0aCA9IGVsbGlwc2lzV2lkdGg7XG4gIG9wdGlvbnMuY29udGVudFdpZHRoID0gY29udGVudFdpZHRoO1xuICBvcHRpb25zLmNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmUsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5lcldpZHRoID0gb3B0aW9ucy5jb250YWluZXJXaWR0aDtcbiAgdmFyIGZvbnQgPSBvcHRpb25zLmZvbnQ7XG4gIHZhciBjb250ZW50V2lkdGggPSBvcHRpb25zLmNvbnRlbnRXaWR0aDtcblxuICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcblxuICBpZiAobGluZVdpZHRoIDw9IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuIHRleHRMaW5lO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7OyBqKyspIHtcbiAgICBpZiAobGluZVdpZHRoIDw9IGNvbnRlbnRXaWR0aCB8fCBqID49IG9wdGlvbnMubWF4SXRlcmF0aW9ucykge1xuICAgICAgdGV4dExpbmUgKz0gb3B0aW9ucy5lbGxpcHNpcztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzdWJMZW5ndGggPSBqID09PSAwID8gZXN0aW1hdGVMZW5ndGgodGV4dExpbmUsIGNvbnRlbnRXaWR0aCwgb3B0aW9ucy5hc2NDaGFyV2lkdGgsIG9wdGlvbnMuY25DaGFyV2lkdGgpIDogbGluZVdpZHRoID4gMCA/IE1hdGguZmxvb3IodGV4dExpbmUubGVuZ3RoICogY29udGVudFdpZHRoIC8gbGluZVdpZHRoKSA6IDA7XG4gICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICBsaW5lV2lkdGggPSBnZXRXaWR0aCh0ZXh0TGluZSwgZm9udCk7XG4gIH1cblxuICBpZiAodGV4dExpbmUgPT09ICcnKSB7XG4gICAgdGV4dExpbmUgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICB9XG5cbiAgcmV0dXJuIHRleHRMaW5lO1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAodmFyIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuICYmIHdpZHRoIDwgY29udGVudFdpZHRoOyBpKyspIHtcbiAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgd2lkdGggKz0gMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcgPyBhc2NDaGFyV2lkdGggOiBjbkNoYXJXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSBsaW5lIGhlaWdodFxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGluZUhlaWdodChmb250KSB7XG4gIC8vIEZJWE1FIEEgcm91Z2ggYXBwcm9hY2guXG4gIHJldHVybiBnZXRXaWR0aCgn5Zu9JywgZm9udCk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7T2JqZWN0fSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gbWVhc3VyZVRleHQodGV4dCwgZm9udCkge1xuICByZXR1cm4gbWV0aG9kcy5tZWFzdXJlVGV4dCh0ZXh0LCBmb250KTtcbn0gLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxuXG5tZXRob2RzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGZvbnQpIHtcbiAgdmFyIGN0eCA9IGdldENvbnRleHQoKTtcbiAgY3R4LmZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbn07XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2s6IHtsaW5lSGVpZ2h0LCBsaW5lcywgaGVpZ2h0LCBvdXRlckhlaWdodH1cbiAqICBOb3RpY2U6IGZvciBwZXJmb3JtYW5jZSwgZG8gbm90IGNhbGN1bGF0ZSBvdXRlcldpZHRoIHV0aWwgbmVlZGVkLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgcGFkZGluZywgdHJ1bmNhdGUpIHtcbiAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgdmFyIGxpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0KGZvbnQpO1xuICB2YXIgbGluZXMgPSB0ZXh0ID8gdGV4dC5zcGxpdCgnXFxuJykgOiBbXTtcbiAgdmFyIGhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGxpbmVIZWlnaHQ7XG4gIHZhciBvdXRlckhlaWdodCA9IGhlaWdodDtcblxuICBpZiAocGFkZGluZykge1xuICAgIG91dGVySGVpZ2h0ICs9IHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdO1xuICB9XG5cbiAgaWYgKHRleHQgJiYgdHJ1bmNhdGUpIHtcbiAgICB2YXIgdHJ1bmNPdXRlckhlaWdodCA9IHRydW5jYXRlLm91dGVySGVpZ2h0O1xuICAgIHZhciB0cnVuY091dGVyV2lkdGggPSB0cnVuY2F0ZS5vdXRlcldpZHRoO1xuXG4gICAgaWYgKHRydW5jT3V0ZXJIZWlnaHQgIT0gbnVsbCAmJiBvdXRlckhlaWdodCA+IHRydW5jT3V0ZXJIZWlnaHQpIHtcbiAgICAgIHRleHQgPSAnJztcbiAgICAgIGxpbmVzID0gW107XG4gICAgfSBlbHNlIGlmICh0cnVuY091dGVyV2lkdGggIT0gbnVsbCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKHRydW5jT3V0ZXJXaWR0aCAtIChwYWRkaW5nID8gcGFkZGluZ1sxXSArIHBhZGRpbmdbM10gOiAwKSwgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhcixcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRydW5jYXRlLnBsYWNlaG9sZGVyXG4gICAgICB9KTsgLy8gRklYTUVcbiAgICAgIC8vIEl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0aGF0IGV2ZXJ5IGxpbmUgaGFzICcuLi4nIHdoZW4gdHJ1bmNhdGUgbXVsdGlwbGUgbGluZXMuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZShsaW5lc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lczogbGluZXMsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgb3V0ZXJIZWlnaHQ6IG91dGVySGVpZ2h0LFxuICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHRcbiAgfTtcbn1cbi8qKlxuICogRm9yIGV4YW1wbGU6ICdzb21lIHRleHQge2F8c29tZSB0ZXh0fW90aGVyIHRleHR7Ynxzb21lIHRleHR9eHh4e2N8fXh4eCdcbiAqIEFsc28gY29uc2lkZXIgJ2JiYmJ7YXx4eHhcXG56enp9eHh4eFxcbmFhYWEnLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2tcbiAqIHtcbiAqICAgICAgd2lkdGgsXG4gKiAgICAgIGhlaWdodCxcbiAqICAgICAgbGluZXM6IFt7XG4gKiAgICAgICAgICBsaW5lSGVpZ2h0LFxuICogICAgICAgICAgd2lkdGgsXG4gKiAgICAgICAgICB0b2tlbnM6IFtbe1xuICogICAgICAgICAgICAgIHN0eWxlTmFtZSxcbiAqICAgICAgICAgICAgICB0ZXh0LFxuICogICAgICAgICAgICAgIHdpZHRoLCAgICAgIC8vIGluY2x1ZGUgdGV4dFBhZGRpbmdcbiAqICAgICAgICAgICAgICBoZWlnaHQsICAgICAvLyBpbmNsdWRlIHRleHRQYWRkaW5nXG4gKiAgICAgICAgICAgICAgdGV4dFdpZHRoLCAvLyBwdXJlIHRleHQgd2lkdGhcbiAqICAgICAgICAgICAgICB0ZXh0SGVpZ2h0LCAvLyBwdXJlIHRleHQgaGVpZ2h0XG4gKiAgICAgICAgICAgICAgbGluZUhlaWhndCxcbiAqICAgICAgICAgICAgICBmb250LFxuICogICAgICAgICAgICAgIHRleHRBbGlnbixcbiAqICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnblxuICogICAgICAgICAgfV0sIFsuLi5dLCAuLi5dXG4gKiAgICAgIH0sIC4uLl1cbiAqIH1cbiAqIElmIHN0eWxlTmFtZSBpcyB1bmRlZmluZWQsIGl0IGlzIHBsYWluIHRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSB7XG4gICAgbGluZXM6IFtdLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gIGlmICghdGV4dCkge1xuICAgIHJldHVybiBjb250ZW50QmxvY2s7XG4gIH1cblxuICB2YXIgbGFzdEluZGV4ID0gU1RZTEVfUkVHLmxhc3RJbmRleCA9IDA7XG4gIHZhciByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBTVFlMRV9SRUcuZXhlYyh0ZXh0KSkgIT0gbnVsbCkge1xuICAgIHZhciBtYXRjaGVkSW5kZXggPSByZXN1bHQuaW5kZXg7XG5cbiAgICBpZiAobWF0Y2hlZEluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaGVkSW5kZXgpKTtcbiAgICB9XG5cbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgcmVzdWx0WzJdLCByZXN1bHRbMV0pO1xuICAgIGxhc3RJbmRleCA9IFNUWUxFX1JFRy5sYXN0SW5kZXg7XG4gIH1cblxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCB0ZXh0Lmxlbmd0aCkpO1xuICB9XG5cbiAgdmFyIGxpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICB2YXIgY29udGVudEhlaWdodCA9IDA7XG4gIHZhciBjb250ZW50V2lkdGggPSAwOyAvLyBGb3IgYHRleHRXaWR0aDogMTAwJWBcblxuICB2YXIgcGVuZGluZ0xpc3QgPSBbXTtcbiAgdmFyIHN0bFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIHRydW5jYXRlID0gc3R5bGUudHJ1bmNhdGU7XG4gIHZhciB0cnVuY2F0ZVdpZHRoID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJXaWR0aDtcbiAgdmFyIHRydW5jYXRlSGVpZ2h0ID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICB0cnVuY2F0ZVdpZHRoICE9IG51bGwgJiYgKHRydW5jYXRlV2lkdGggLT0gc3RsUGFkZGluZ1sxXSArIHN0bFBhZGRpbmdbM10pO1xuICAgIHRydW5jYXRlSGVpZ2h0ICE9IG51bGwgJiYgKHRydW5jYXRlSGVpZ2h0IC09IHN0bFBhZGRpbmdbMF0gKyBzdGxQYWRkaW5nWzJdKTtcbiAgfSAvLyBDYWxjdWxhdGUgbGF5b3V0IGluZm8gb2YgdG9rZW5zLlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgdmFyIGxpbmVIZWlnaHQgPSAwO1xuICAgIHZhciBsaW5lV2lkdGggPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLnRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHRva2VuID0gbGluZS50b2tlbnNbal07XG4gICAgICB2YXIgdG9rZW5TdHlsZSA9IHRva2VuLnN0eWxlTmFtZSAmJiBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307IC8vIHRleHRQYWRkaW5nIHNob3VsZCBub3QgaW5oZXJpdCBmcm9tIHN0eWxlLlxuXG4gICAgICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZyA9IHRva2VuU3R5bGUudGV4dFBhZGRpbmc7IC8vIHRleHRGb250IGhhcyBiZWVuIGFzaWduZWQgdG8gZm9udCBieSBgbm9ybWFsaXplU3R5bGVgLlxuXG4gICAgICB2YXIgZm9udCA9IHRva2VuLmZvbnQgPSB0b2tlblN0eWxlLmZvbnQgfHwgc3R5bGUuZm9udDsgLy8gdGV4dEhlaWdodCBjYW4gYmUgdXNlZCB3aGVuIHRleHRWZXJ0aWNhbEFsaWduIGlzIHNwZWNpZmllZCBpbiB0b2tlbi5cblxuICAgICAgdmFyIHRva2VuSGVpZ2h0ID0gdG9rZW4udGV4dEhlaWdodCA9IHJldHJpZXZlMiggLy8gdGV4dEhlaWdodCBzaG91bGQgbm90IGJlIGluaGVyaXRlZCwgY29uc2lkZXIgaXQgY2FuIGJlIHNwZWNpZmllZFxuICAgICAgLy8gYXMgYm94IGhlaWdodCBvZiB0aGUgYmxvY2suXG4gICAgICB0b2tlblN0eWxlLnRleHRIZWlnaHQsIGdldExpbmVIZWlnaHQoZm9udCkpO1xuICAgICAgdGV4dFBhZGRpbmcgJiYgKHRva2VuSGVpZ2h0ICs9IHRleHRQYWRkaW5nWzBdICsgdGV4dFBhZGRpbmdbMl0pO1xuICAgICAgdG9rZW4uaGVpZ2h0ID0gdG9rZW5IZWlnaHQ7XG4gICAgICB0b2tlbi5saW5lSGVpZ2h0ID0gcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dExpbmVIZWlnaHQsIHN0eWxlLnRleHRMaW5lSGVpZ2h0LCB0b2tlbkhlaWdodCk7XG4gICAgICB0b2tlbi50ZXh0QWxpZ24gPSB0b2tlblN0eWxlICYmIHRva2VuU3R5bGUudGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgIHRva2VuLnRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW5TdHlsZSAmJiB0b2tlblN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8ICdtaWRkbGUnO1xuXG4gICAgICBpZiAodHJ1bmNhdGVIZWlnaHQgIT0gbnVsbCAmJiBjb250ZW50SGVpZ2h0ICsgdG9rZW4ubGluZUhlaWdodCA+IHRydW5jYXRlSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgIHZhciB0b2tlbldpZHRoID0gdG9rZW5TdHlsZS50ZXh0V2lkdGg7XG4gICAgICB2YXIgdG9rZW5XaWR0aE5vdFNwZWNpZmllZCA9IHRva2VuV2lkdGggPT0gbnVsbCB8fCB0b2tlbldpZHRoID09PSAnYXV0byc7IC8vIFBlcmNlbnQgd2lkdGgsIGNhbiBiZSBgMTAwJWAsIGNhbiBiZSB1c2VkIGluIGRyYXdpbmcgc2VwYXJhdGVcbiAgICAgIC8vIGxpbmUgd2hlbiBib3ggd2lkdGggaXMgbmVlZGVkIHRvIGJlIGF1dG8uXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW5XaWR0aCA9PT0gJ3N0cmluZycgJiYgdG9rZW5XaWR0aC5jaGFyQXQodG9rZW5XaWR0aC5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgIHRva2VuLnBlcmNlbnRXaWR0aCA9IHRva2VuV2lkdGg7XG4gICAgICAgIHBlbmRpbmdMaXN0LnB1c2godG9rZW4pO1xuICAgICAgICB0b2tlbldpZHRoID0gMDsgLy8gRG8gbm90IHRydW5jYXRlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSB0aGVyZSBpcyBubyB1c2VyIGNhc2VcbiAgICAgICAgLy8gYW5kIGl0IGlzIHRvbyBjb21wbGljYXRlZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlbldpZHRoTm90U3BlY2lmaWVkKSB7XG4gICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aDsgLy8gRklYTUU6IElmIGltYWdlIGlzIG5vdCBsb2FkZWQgYW5kIHRleHRXaWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxsaW5nXG4gICAgICAgICAgLy8gYGdldEJvdW5kaW5nUmVjdCgpYCB3aWxsIG5vdCBnZXQgY29ycmVjdCByZXN1bHQuXG5cbiAgICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHRva2VuU3R5bGUudGV4dEJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICB2YXIgYmdJbWcgPSB0ZXh0QmFja2dyb3VuZENvbG9yICYmIHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2U7IC8vIFVzZSBjYXNlczpcbiAgICAgICAgICAvLyAoMSkgSWYgaW1hZ2UgaXMgbm90IGxvYWRlZCwgaXQgd2lsbCBiZSBsb2FkZWQgYXQgcmVuZGVyIHBoYXNlIGFuZCBjYWxsXG4gICAgICAgICAgLy8gYGRpcnR5KClgIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBsb2FkZWRcbiAgICAgICAgICAvLyBpbWFnZSwgYW5kIHRoZW4gdGhlIHJpZ2h0IHNpemUgd2lsbCBiZSBjYWxjdWxhdGVkIGhlcmUgYXQgdGhlIG5leHQgdGljay5cbiAgICAgICAgICAvLyBTZWUgYGdyYXBoaWMvaGVscGVyL3RleHQuanNgLlxuICAgICAgICAgIC8vICgyKSBJZiBpbWFnZSBsb2FkZWQsIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgaXMgaW1hZ2Ugc3JjIHN0cmluZyxcbiAgICAgICAgICAvLyB1c2UgYGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlYCB0byBmaW5kIGNhY2hlZCBpbWFnZS5cbiAgICAgICAgICAvLyBgaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2VgIHdpbGwgYWx3YXlzIGJlIGNhbGxlZCBoZXJlIGJlZm9yZVxuICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlYCBpbiBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyNyZW5kZXJSaWNoVGV4dGBcbiAgICAgICAgICAvLyB3aGljaCBlbnN1cmVzIHRoYXQgaW1hZ2Ugd2lsbCBub3QgYmUgcmVuZGVyZWQgYmVmb3JlIGNvcnJlY3Qgc2l6ZSBjYWxjdWFsdGVkLlxuXG4gICAgICAgICAgaWYgKGJnSW1nKSB7XG4gICAgICAgICAgICBiZ0ltZyA9IGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlKGJnSW1nKTtcblxuICAgICAgICAgICAgaWYgKGltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShiZ0ltZykpIHtcbiAgICAgICAgICAgICAgdG9rZW5XaWR0aCA9IE1hdGgubWF4KHRva2VuV2lkdGgsIGJnSW1nLndpZHRoICogdG9rZW5IZWlnaHQgLyBiZ0ltZy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWRkaW5nVyA9IHRleHRQYWRkaW5nID8gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXSA6IDA7XG4gICAgICAgIHRva2VuV2lkdGggKz0gcGFkZGluZ1c7XG4gICAgICAgIHZhciByZW1pYW5UcnVuY1dpZHRoID0gdHJ1bmNhdGVXaWR0aCAhPSBudWxsID8gdHJ1bmNhdGVXaWR0aCAtIGxpbmVXaWR0aCA6IG51bGw7XG5cbiAgICAgICAgaWYgKHJlbWlhblRydW5jV2lkdGggIT0gbnVsbCAmJiByZW1pYW5UcnVuY1dpZHRoIDwgdG9rZW5XaWR0aCkge1xuICAgICAgICAgIGlmICghdG9rZW5XaWR0aE5vdFNwZWNpZmllZCB8fCByZW1pYW5UcnVuY1dpZHRoIDwgcGFkZGluZ1cpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSAnJztcbiAgICAgICAgICAgIHRva2VuLnRleHRXaWR0aCA9IHRva2VuV2lkdGggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gdHJ1bmNhdGVUZXh0KHRva2VuLnRleHQsIHJlbWlhblRydW5jV2lkdGggLSBwYWRkaW5nVywgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgICAgICAgIHRva2VuV2lkdGggPSB0b2tlbi50ZXh0V2lkdGggKyBwYWRkaW5nVztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGluZVdpZHRoICs9IHRva2VuLndpZHRoID0gdG9rZW5XaWR0aDtcbiAgICAgIHRva2VuU3R5bGUgJiYgKGxpbmVIZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCB0b2tlbi5saW5lSGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgbGluZS53aWR0aCA9IGxpbmVXaWR0aDtcbiAgICBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgIGNvbnRlbnRIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICBjb250ZW50V2lkdGggPSBNYXRoLm1heChjb250ZW50V2lkdGgsIGxpbmVXaWR0aCk7XG4gIH1cblxuICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aCA9IHJldHJpZXZlMihzdHlsZS50ZXh0V2lkdGgsIGNvbnRlbnRXaWR0aCk7XG4gIGNvbnRlbnRCbG9jay5vdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5oZWlnaHQgPSByZXRyaWV2ZTIoc3R5bGUudGV4dEhlaWdodCwgY29udGVudEhlaWdodCk7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCArPSBzdGxQYWRkaW5nWzFdICsgc3RsUGFkZGluZ1szXTtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQgKz0gc3RsUGFkZGluZ1swXSArIHN0bFBhZGRpbmdbMl07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBlbmRpbmdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gcGVuZGluZ0xpc3RbaV07XG4gICAgdmFyIHBlcmNlbnRXaWR0aCA9IHRva2VuLnBlcmNlbnRXaWR0aDsgLy8gU2hvdWxkIG5vdCBiYXNlIG9uIG91dGVyV2lkdGgsIGJlY2F1c2UgdG9rZW4gY2FuIG5vdCBiZSBwbGFjZWQgb3V0IG9mIHBhZGRpbmcuXG5cbiAgICB0b2tlbi53aWR0aCA9IHBhcnNlSW50KHBlcmNlbnRXaWR0aCwgMTApIC8gMTAwICogY29udGVudFdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbn1cblxuZnVuY3Rpb24gcHVzaFRva2VucyhibG9jaywgc3RyLCBzdHlsZU5hbWUpIHtcbiAgdmFyIGlzRW1wdHlTdHIgPSBzdHIgPT09ICcnO1xuICB2YXIgc3RycyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gIHZhciBsaW5lcyA9IGJsb2NrLmxpbmVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ZXh0ID0gc3Ryc1tpXTtcbiAgICB2YXIgdG9rZW4gPSB7XG4gICAgICBzdHlsZU5hbWU6IHN0eWxlTmFtZSxcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBpc0xpbmVIb2xkZXI6ICF0ZXh0ICYmICFpc0VtcHR5U3RyXG4gICAgfTsgLy8gVGhlIGZpcnN0IHRva2VuIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCBsaW5lLlxuXG4gICAgaWYgKCFpKSB7XG4gICAgICB2YXIgdG9rZW5zID0gKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdIHx8IChsaW5lc1swXSA9IHtcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfSkpLnRva2VuczsgLy8gQ29uc2lkZXIgY2FzZXM6XG4gICAgICAvLyAoMSkgJycuc3BsaXQoJ1xcbicpID0+IFsnJywgJ1xcbicsICcnXSwgdGhlICcnIGF0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAvLyAod2hpY2ggaXMgYSBwbGFjZWhvbGRlcikgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IG5ldyB0b2tlbi5cbiAgICAgIC8vICgyKSBBIGltYWdlIGJhY2thZ2UsIHdoZXJlIHRva2VuIGxpa2VzIHthfH0uXG4gICAgICAvLyAoMykgQSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAvLyAoNCkgdG9rZW5zIHdpdGggdGhlIHNhbWUgdHBsTmFtZSBzaG91bGQgbm90IGJlIG1lcmdlZCwgYmVjYXVzZVxuICAgICAgLy8gdGhleSBzaG91bGQgYmUgZGlzcGxheWVkIGluIGRpZmZlcmVudCBib3ggKHdpdGggYm9yZGVyIGFuZCBwYWRkaW5nKS5cblxuICAgICAgdmFyIHRva2Vuc0xlbiA9IHRva2Vucy5sZW5ndGg7XG4gICAgICB0b2tlbnNMZW4gPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluZUhvbGRlciA/IHRva2Vuc1swXSA9IHRva2VuIDogLy8gQ29uc2lkZXIgdGV4dCBpcyAnJywgb25seSBpbnNlcnQgd2hlbiBpdCBpcyB0aGUgXCJsaW5lSG9sZGVyXCIgb3JcbiAgICAgIC8vIFwiZW1wdHlTdHJcIi4gT3RoZXJ3aXNlIGEgcmVkdW5kYW50ICcnIHdpbGwgYWZmZWN0IHRleHRBbGlnbiBpbiBsaW5lLlxuICAgICAgKHRleHQgfHwgIXRva2Vuc0xlbiB8fCBpc0VtcHR5U3RyKSAmJiB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfSAvLyBPdGhlciB0b2tlbnMgYWx3YXlzIHN0YXJ0IGEgbmV3IGxpbmUuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzICcnLCBpbnNlcnQgaXQgYXMgYSBwbGFjZWhvbGRlci5cbiAgICAgICAgbGluZXMucHVzaCh7XG4gICAgICAgICAgdG9rZW5zOiBbdG9rZW5dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGb250KHN0eWxlKSB7XG4gIC8vIEZJWE1FIGluIG5vZGUtY2FudmFzIGZvbnRXZWlnaHQgaXMgYmVmb3JlIGZvbnRTdHlsZVxuICAvLyBVc2UgYGZvbnRTaXplYCBgZm9udEZhbWlseWAgdG8gY2hlY2sgd2hldGhlciBmb250IHByb3BlcnRpZXMgYXJlIGRlZmluZWQuXG4gIHJldHVybiAoc3R5bGUuZm9udFNpemUgfHwgc3R5bGUuZm9udEZhbWlseSkgJiYgW3N0eWxlLmZvbnRTdHlsZSwgc3R5bGUuZm9udFdlaWdodCwgKHN0eWxlLmZvbnRTaXplIHx8IDEyKSArICdweCcsIC8vIElmIGZvbnQgcHJvcGVydGllcyBhcmUgZGVmaW5lZCwgYGZvbnRGYW1pbHlgIHNob3VsZCBub3QgYmUgaWdub3JlZC5cbiAgc3R5bGUuZm9udEZhbWlseSB8fCAnc2Fucy1zZXJpZiddLmpvaW4oJyAnKSB8fCBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xufVxuXG5leHBvcnRzLkRFRkFVTFRfRk9OVCA9IERFRkFVTFRfRk9OVDtcbmV4cG9ydHMuJG92ZXJyaWRlID0gJG92ZXJyaWRlO1xuZXhwb3J0cy5nZXRXaWR0aCA9IGdldFdpZHRoO1xuZXhwb3J0cy5nZXRCb3VuZGluZ1JlY3QgPSBnZXRCb3VuZGluZ1JlY3Q7XG5leHBvcnRzLmFkanVzdFRleHRYID0gYWRqdXN0VGV4dFg7XG5leHBvcnRzLmFkanVzdFRleHRZID0gYWRqdXN0VGV4dFk7XG5leHBvcnRzLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCA9IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdDtcbmV4cG9ydHMudHJ1bmNhdGVUZXh0ID0gdHJ1bmNhdGVUZXh0O1xuZXhwb3J0cy5nZXRMaW5lSGVpZ2h0ID0gZ2V0TGluZUhlaWdodDtcbmV4cG9ydHMubWVhc3VyZVRleHQgPSBtZWFzdXJlVGV4dDtcbmV4cG9ydHMucGFyc2VQbGFpblRleHQgPSBwYXJzZVBsYWluVGV4dDtcbmV4cG9ydHMucGFyc2VSaWNoVGV4dCA9IHBhcnNlUmljaFRleHQ7XG5leHBvcnRzLm1ha2VGb250ID0gbWFrZUZvbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZmVhdHVyZXMgPSB7fTtcblxuZnVuY3Rpb24gcmVnaXN0ZXIobmFtZSwgY3Rvcikge1xuICBmZWF0dXJlc1tuYW1lXSA9IGN0b3I7XG59XG5cbmZ1bmN0aW9uIGdldChuYW1lKSB7XG4gIHJldHVybiBmZWF0dXJlc1tuYW1lXTtcbn1cblxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZXhwb3J0cy5nZXQgPSBnZXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogM3gy55+p6Zi15pON5L2c57G7XG4gKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbWF0cml4XG4gKi9cbnZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogRmxvYXQzMkFycmF5O1xuLyoqXG4gKiDliJvlu7rkuIDkuKrljZXkvY3nn6npmLVcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDYpO1xuICBpZGVudGl0eShvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorr7nva7nn6npmLXkuLrljZXkvY3nn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlpI3liLbnn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgbSkge1xuICBvdXRbMF0gPSBtWzBdO1xuICBvdXRbMV0gPSBtWzFdO1xuICBvdXRbMl0gPSBtWzJdO1xuICBvdXRbM10gPSBtWzNdO1xuICBvdXRbNF0gPSBtWzRdO1xuICBvdXRbNV0gPSBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnn6npmLXnm7jkuZhcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0yXG4gKi9cblxuXG5mdW5jdGlvbiBtdWwob3V0LCBtMSwgbTIpIHtcbiAgLy8gQ29uc2lkZXIgbWF0cml4Lm11bChtLCBtMiwgbSk7XG4gIC8vIHdoZXJlIG91dCBpcyB0aGUgc2FtZSBhcyBtMi5cbiAgLy8gU28gdXNlIHRlbXAgdmFyaWFibGUgdG8gZXNjYXBlIGVycm9yLlxuICB2YXIgb3V0MCA9IG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdO1xuICB2YXIgb3V0MSA9IG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdO1xuICB2YXIgb3V0MiA9IG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdO1xuICB2YXIgb3V0MyA9IG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdO1xuICB2YXIgb3V0NCA9IG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF07XG4gIHZhciBvdXQ1ID0gbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XTtcbiAgb3V0WzBdID0gb3V0MDtcbiAgb3V0WzFdID0gb3V0MTtcbiAgb3V0WzJdID0gb3V0MjtcbiAgb3V0WzNdID0gb3V0MztcbiAgb3V0WzRdID0gb3V0NDtcbiAgb3V0WzVdID0gb3V0NTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5bmz56e75Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XSArIHZbMF07XG4gIG91dFs1XSA9IGFbNV0gKyB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDml4vovazlj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGFhID0gYVswXTtcbiAgdmFyIGFjID0gYVsyXTtcbiAgdmFyIGF0eCA9IGFbNF07XG4gIHZhciBhYiA9IGFbMV07XG4gIHZhciBhZCA9IGFbM107XG4gIHZhciBhdHkgPSBhWzVdO1xuICB2YXIgc3QgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgY3QgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhYSAqIGN0ICsgYWIgKiBzdDtcbiAgb3V0WzFdID0gLWFhICogc3QgKyBhYiAqIGN0O1xuICBvdXRbMl0gPSBhYyAqIGN0ICsgYWQgKiBzdDtcbiAgb3V0WzNdID0gLWFjICogc3QgKyBjdCAqIGFkO1xuICBvdXRbNF0gPSBjdCAqIGF0eCArIHN0ICogYXR5O1xuICBvdXRbNV0gPSBjdCAqIGF0eSAtIHN0ICogYXR4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnvKnmlL7lj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB2eCA9IHZbMF07XG4gIHZhciB2eSA9IHZbMV07XG4gIG91dFswXSA9IGFbMF0gKiB2eDtcbiAgb3V0WzFdID0gYVsxXSAqIHZ5O1xuICBvdXRbMl0gPSBhWzJdICogdng7XG4gIG91dFszXSA9IGFbM10gKiB2eTtcbiAgb3V0WzRdID0gYVs0XSAqIHZ4O1xuICBvdXRbNV0gPSBhWzVdICogdnk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaxgumAhuefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGFhID0gYVswXTtcbiAgdmFyIGFjID0gYVsyXTtcbiAgdmFyIGF0eCA9IGFbNF07XG4gIHZhciBhYiA9IGFbMV07XG4gIHZhciBhZCA9IGFbM107XG4gIHZhciBhdHkgPSBhWzVdO1xuICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgb3V0WzJdID0gLWFjICogZGV0O1xuICBvdXRbM10gPSBhYSAqIGRldDtcbiAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMubXVsID0gbXVsO1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIHYyQ3JlYXRlID0gX3ZlY3Rvci5jcmVhdGU7XG52YXIgdjJEaXN0U3F1YXJlID0gX3ZlY3Rvci5kaXN0U3F1YXJlO1xuXG4vKipcbiAqIOabsue6v+i+heWKqeaooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBtYXRoUG93ID0gTWF0aC5wb3c7XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgRVBTSUxPTiA9IDFlLTg7XG52YXIgRVBTSUxPTl9OVU1FUklDID0gMWUtNDtcbnZhciBUSFJFRV9TUVJUID0gbWF0aFNxcnQoMyk7XG52YXIgT05FX1RISVJEID0gMSAvIDM7IC8vIOS4tOaXtuWPmOmHj1xuXG52YXIgX3YwID0gdjJDcmVhdGUoKTtcblxudmFyIF92MSA9IHYyQ3JlYXRlKCk7XG5cbnZhciBfdjIgPSB2MkNyZWF0ZSgpO1xuXG5mdW5jdGlvbiBpc0Fyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiAtRVBTSUxPTiAmJiB2YWwgPCBFUFNJTE9OO1xufVxuXG5mdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIG9uZXQgKiBvbmV0ICogKG9uZXQgKiBwMCArIDMgKiB0ICogcDEpICsgdCAqIHQgKiAodCAqIHAzICsgMyAqIG9uZXQgKiBwMik7XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOWvvOaVsOWAvFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIDMgKiAoKChwMSAtIHAwKSAqIG9uZXQgKyAyICogKHAyIC0gcDEpICogdCkgKiBvbmV0ICsgKHAzIC0gcDIpICogdCAqIHQpO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmoLnvvIzkvb/nlKjnm5vph5HlhazlvI9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNSb290QXQocDAsIHAxLCBwMiwgcDMsIHZhbCwgcm9vdHMpIHtcbiAgLy8gRXZhbHVhdGUgcm9vdHMgb2YgY3ViaWMgZnVuY3Rpb25zXG4gIHZhciBhID0gcDMgKyAzICogKHAxIC0gcDIpIC0gcDA7XG4gIHZhciBiID0gMyAqIChwMiAtIHAxICogMiArIHAwKTtcbiAgdmFyIGMgPSAzICogKHAxIC0gcDApO1xuICB2YXIgZCA9IHAwIC0gdmFsO1xuICB2YXIgQSA9IGIgKiBiIC0gMyAqIGEgKiBjO1xuICB2YXIgQiA9IGIgKiBjIC0gOSAqIGEgKiBkO1xuICB2YXIgQyA9IGMgKiBjIC0gMyAqIGIgKiBkO1xuICB2YXIgbiA9IDA7XG5cbiAgaWYgKGlzQXJvdW5kWmVybyhBKSAmJiBpc0Fyb3VuZFplcm8oQikpIHtcbiAgICBpZiAoaXNBcm91bmRaZXJvKGIpKSB7XG4gICAgICByb290c1swXSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0MSA9IC1jIC8gYjsgLy90MSwgdDIsIHQzLCBiIGlzIG5vdCB6ZXJvXG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlzYyA9IEIgKiBCIC0gNCAqIEEgKiBDO1xuXG4gICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgdmFyIEsgPSBCIC8gQTtcbiAgICAgIHZhciB0MSA9IC1iIC8gYSArIEs7IC8vIHQxLCBhIGlzIG5vdCB6ZXJvXG5cbiAgICAgIHZhciB0MiA9IC1LIC8gMjsgLy8gdDIsIHQzXG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgIHZhciBZMSA9IEEgKiBiICsgMS41ICogYSAqICgtQiArIGRpc2NTcXJ0KTtcbiAgICAgIHZhciBZMiA9IEEgKiBiICsgMS41ICogYSAqICgtQiAtIGRpc2NTcXJ0KTtcblxuICAgICAgaWYgKFkxIDwgMCkge1xuICAgICAgICBZMSA9IC1tYXRoUG93KC1ZMSwgT05FX1RISVJEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFkxID0gbWF0aFBvdyhZMSwgT05FX1RISVJEKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFkyIDwgMCkge1xuICAgICAgICBZMiA9IC1tYXRoUG93KC1ZMiwgT05FX1RISVJEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFkyID0gbWF0aFBvdyhZMiwgT05FX1RISVJEKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHQxID0gKC1iIC0gKFkxICsgWTIpKSAvICgzICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgVCA9ICgyICogQSAqIGIgLSAzICogYSAqIEIpIC8gKDIgKiBtYXRoU3FydChBICogQSAqIEEpKTtcbiAgICAgIHZhciB0aGV0YSA9IE1hdGguYWNvcyhUKSAvIDM7XG4gICAgICB2YXIgQVNxcnQgPSBtYXRoU3FydChBKTtcbiAgICAgIHZhciB0bXAgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgdDEgPSAoLWIgLSAyICogQVNxcnQgKiB0bXApIC8gKDMgKiBhKTtcbiAgICAgIHZhciB0MiA9ICgtYiArIEFTcXJ0ICogKHRtcCArIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG4gICAgICB2YXIgdDMgPSAoLWIgKyBBU3FydCAqICh0bXAgLSBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MyA+PSAwICYmIHQzIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLznmoTkvY3nva5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZXh0cmVtYVxuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljRXh0cmVtYShwMCwgcDEsIHAyLCBwMywgZXh0cmVtYSkge1xuICB2YXIgYiA9IDYgKiBwMiAtIDEyICogcDEgKyA2ICogcDA7XG4gIHZhciBhID0gOSAqIHAxICsgMyAqIHAzIC0gMyAqIHAwIC0gOSAqIHAyO1xuICB2YXIgYyA9IDMgKiBwMSAtIDMgKiBwMDtcbiAgdmFyIG4gPSAwO1xuXG4gIGlmIChpc0Fyb3VuZFplcm8oYSkpIHtcbiAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICB2YXIgdDEgPSAtYyAvIGI7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgZXh0cmVtYVtuKytdID0gdDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICBleHRyZW1hWzBdID0gLWIgLyAoMiAqIGEpO1xuICAgIH0gZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgdmFyIHQxID0gKC1iICsgZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgZXh0cmVtYVtuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgZXh0cmVtYVtuKytdID0gdDI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG4vKipcbiAqIOe7huWIhuS4ieasoei0neWhnuWwlOabsue6v1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgcDMsIHQsIG91dCkge1xuICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICB2YXIgcDIzID0gKHAzIC0gcDIpICogdCArIHAyO1xuICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcbiAgdmFyIHAxMjMgPSAocDIzIC0gcDEyKSAqIHQgKyBwMTI7XG4gIHZhciBwMDEyMyA9IChwMTIzIC0gcDAxMikgKiB0ICsgcDAxMjsgLy8gU2VnMFxuXG4gIG91dFswXSA9IHAwO1xuICBvdXRbMV0gPSBwMDE7XG4gIG91dFsyXSA9IHAwMTI7XG4gIG91dFszXSA9IHAwMTIzOyAvLyBTZWcxXG5cbiAgb3V0WzRdID0gcDAxMjM7XG4gIG91dFs1XSA9IHAxMjM7XG4gIG91dFs2XSA9IHAyMztcbiAgb3V0WzddID0gcDM7XG59XG4vKipcbiAqIOaKleWwhOeCueWIsOS4ieasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge251bWJlcn0geDNcbiAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSDmipXlsITngrlcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSwgb3V0KSB7XG4gIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgdmFyIHQ7XG4gIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICB2YXIgZCA9IEluZmluaXR5O1xuICB2YXIgcHJldjtcbiAgdmFyIG5leHQ7XG4gIHZhciBkMTtcbiAgdmFyIGQyO1xuICBfdjBbMF0gPSB4O1xuICBfdjBbMV0gPSB5OyAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgLy8gUEVORElOR1xuXG4gIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgX3QpO1xuICAgIF92MVsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIF90KTtcbiAgICBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG5cbiAgICBpZiAoZDEgPCBkKSB7XG4gICAgICB0ID0gX3Q7XG4gICAgICBkID0gZDE7XG4gICAgfVxuICB9XG5cbiAgZCA9IEluZmluaXR5OyAvLyBBdCBtb3N0IDMyIGl0ZXJhdGlvblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGlmIChpbnRlcnZhbCA8IEVQU0lMT05fTlVNRVJJQykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICBuZXh0ID0gdCArIGludGVydmFsOyAvLyB0IC0gaW50ZXJ2YWxcblxuICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHByZXYpO1xuICAgIF92MVsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHByZXYpO1xuICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MSwgX3YwKTtcblxuICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICB0ID0gcHJldjtcbiAgICAgIGQgPSBkMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICBfdjJbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBuZXh0KTtcbiAgICAgIF92MlsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIG5leHQpO1xuICAgICAgZDIgPSB2MkRpc3RTcXVhcmUoX3YyLCBfdjApO1xuXG4gICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgZCA9IGQyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyB0XG5cblxuICBpZiAob3V0KSB7XG4gICAgb3V0WzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgb3V0WzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gIH0gLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuXG5cbiAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlgLxcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljQXQocDAsIHAxLCBwMiwgdCkge1xuICB2YXIgb25ldCA9IDEgLSB0O1xuICByZXR1cm4gb25ldCAqIChvbmV0ICogcDAgKyAyICogdCAqIHAxKSArIHQgKiB0ICogcDI7XG59XG4vKipcbiAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWvvOaVsOWAvFxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgdCkge1xuICByZXR1cm4gMiAqICgoMSAtIHQpICogKHAxIC0gcDApICsgdCAqIChwMiAtIHAxKSk7XG59XG4vKipcbiAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOaWueeoi+aguVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNSb290QXQocDAsIHAxLCBwMiwgdmFsLCByb290cykge1xuICB2YXIgYSA9IHAwIC0gMiAqIHAxICsgcDI7XG4gIHZhciBiID0gMiAqIChwMSAtIHAwKTtcbiAgdmFyIGMgPSBwMCAtIHZhbDtcbiAgdmFyIG4gPSAwO1xuXG4gIGlmIChpc0Fyb3VuZFplcm8oYSkpIHtcbiAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICB2YXIgdDEgPSAtYyAvIGI7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgdmFyIHQxID0gLWIgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG4vKipcbiAqIOiuoeeul+S6jOasoei0neWhnuWwlOaWueeoi+aegemZkOWAvFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0V4dHJlbXVtKHAwLCBwMSwgcDIpIHtcbiAgdmFyIGRpdmlkZXIgPSBwMCArIHAyIC0gMiAqIHAxO1xuXG4gIGlmIChkaXZpZGVyID09PSAwKSB7XG4gICAgLy8gcDEgaXMgY2VudGVyIG9mIHAwIGFuZCBwMlxuICAgIHJldHVybiAwLjU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChwMCAtIHAxKSAvIGRpdmlkZXI7XG4gIH1cbn1cbi8qKlxuICog57uG5YiG5LqM5qyh6LSd5aGe5bCU5puy57q/XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgdCwgb3V0KSB7XG4gIHZhciBwMDEgPSAocDEgLSBwMCkgKiB0ICsgcDA7XG4gIHZhciBwMTIgPSAocDIgLSBwMSkgKiB0ICsgcDE7XG4gIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxOyAvLyBTZWcwXG5cbiAgb3V0WzBdID0gcDA7XG4gIG91dFsxXSA9IHAwMTtcbiAgb3V0WzJdID0gcDAxMjsgLy8gU2VnMVxuXG4gIG91dFszXSA9IHAwMTI7XG4gIG91dFs0XSA9IHAxMjtcbiAgb3V0WzVdID0gcDI7XG59XG4vKipcbiAqIOaKleWwhOeCueWIsOS6jOasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG91dCDmipXlsITngrlcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4LCB5LCBvdXQpIHtcbiAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICB2YXIgdDtcbiAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gIHZhciBkID0gSW5maW5pdHk7XG4gIF92MFswXSA9IHg7XG4gIF92MFsxXSA9IHk7IC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAvLyBQRU5ESU5HXG5cbiAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBfdCk7XG4gICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgX3QpO1xuICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG5cbiAgICBpZiAoZDEgPCBkKSB7XG4gICAgICB0ID0gX3Q7XG4gICAgICBkID0gZDE7XG4gICAgfVxuICB9XG5cbiAgZCA9IEluZmluaXR5OyAvLyBBdCBtb3N0IDMyIGl0ZXJhdGlvblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGlmIChpbnRlcnZhbCA8IEVQU0lMT05fTlVNRVJJQykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHByZXYgPSB0IC0gaW50ZXJ2YWw7XG4gICAgdmFyIG5leHQgPSB0ICsgaW50ZXJ2YWw7IC8vIHQgLSBpbnRlcnZhbFxuXG4gICAgX3YxWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgcHJldik7XG4gICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgcHJldik7XG4gICAgdmFyIGQxID0gdjJEaXN0U3F1YXJlKF92MSwgX3YwKTtcblxuICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICB0ID0gcHJldjtcbiAgICAgIGQgPSBkMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICBfdjJbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBuZXh0KTtcbiAgICAgIF92MlsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIG5leHQpO1xuICAgICAgdmFyIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgIGQgPSBkMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gdFxuXG5cbiAgaWYgKG91dCkge1xuICAgIG91dFswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHQpO1xuICAgIG91dFsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuICB9IC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcblxuXG4gIHJldHVybiBtYXRoU3FydChkKTtcbn1cblxuZXhwb3J0cy5jdWJpY0F0ID0gY3ViaWNBdDtcbmV4cG9ydHMuY3ViaWNEZXJpdmF0aXZlQXQgPSBjdWJpY0Rlcml2YXRpdmVBdDtcbmV4cG9ydHMuY3ViaWNSb290QXQgPSBjdWJpY1Jvb3RBdDtcbmV4cG9ydHMuY3ViaWNFeHRyZW1hID0gY3ViaWNFeHRyZW1hO1xuZXhwb3J0cy5jdWJpY1N1YmRpdmlkZSA9IGN1YmljU3ViZGl2aWRlO1xuZXhwb3J0cy5jdWJpY1Byb2plY3RQb2ludCA9IGN1YmljUHJvamVjdFBvaW50O1xuZXhwb3J0cy5xdWFkcmF0aWNBdCA9IHF1YWRyYXRpY0F0O1xuZXhwb3J0cy5xdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBxdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG5leHBvcnRzLnF1YWRyYXRpY1Jvb3RBdCA9IHF1YWRyYXRpY1Jvb3RBdDtcbmV4cG9ydHMucXVhZHJhdGljRXh0cmVtdW0gPSBxdWFkcmF0aWNFeHRyZW11bTtcbmV4cG9ydHMucXVhZHJhdGljU3ViZGl2aWRlID0gcXVhZHJhdGljU3ViZGl2aWRlO1xuZXhwb3J0cy5xdWFkcmF0aWNQcm9qZWN0UG9pbnQgPSBxdWFkcmF0aWNQcm9qZWN0UG9pbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9jdXJ2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluL3RleHRcIik7XG5cbnZhciBPcmRpbmFsU2NhbGUgPSByZXF1aXJlKFwiLi4vc2NhbGUvT3JkaW5hbFwiKTtcblxudmFyIEludGVydmFsU2NhbGUgPSByZXF1aXJlKFwiLi4vc2NhbGUvSW50ZXJ2YWxcIik7XG5cbnZhciBTY2FsZSA9IHJlcXVpcmUoXCIuLi9zY2FsZS9TY2FsZVwiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9udW1iZXJcIik7XG5cbnJlcXVpcmUoXCIuLi9zY2FsZS9UaW1lXCIpO1xuXG5yZXF1aXJlKFwiLi4vc2NhbGUvTG9nXCIpO1xuXG4vKipcbiAqIEdldCBheGlzIHNjYWxlIGV4dGVudCBiZWZvcmUgbmljZWQuXG4gKiBJdGVtIG9mIHJldHVybmVkIGFycmF5IGNhbiBvbmx5IGJlIG51bWJlciAoaW5jbHVkaW5nIEluZmluaXR5IGFuZCBOYU4pLlxuICovXG5mdW5jdGlvbiBnZXRTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpIHtcbiAgdmFyIHNjYWxlVHlwZSA9IHNjYWxlLnR5cGU7XG4gIHZhciBtaW4gPSBtb2RlbC5nZXRNaW4oKTtcbiAgdmFyIG1heCA9IG1vZGVsLmdldE1heCgpO1xuICB2YXIgZml4TWluID0gbWluICE9IG51bGw7XG4gIHZhciBmaXhNYXggPSBtYXggIT0gbnVsbDtcbiAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCk7XG4gIHZhciBheGlzRGF0YUxlbjtcbiAgdmFyIGJvdW5kYXJ5R2FwO1xuICB2YXIgc3BhbjtcblxuICBpZiAoc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICBheGlzRGF0YUxlbiA9IChtb2RlbC5nZXQoJ2RhdGEnKSB8fCBbXSkubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kYXJ5R2FwID0gbW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuXG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShib3VuZGFyeUdhcCkpIHtcbiAgICAgIGJvdW5kYXJ5R2FwID0gW2JvdW5kYXJ5R2FwIHx8IDAsIGJvdW5kYXJ5R2FwIHx8IDBdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYm91bmRhcnlHYXBbMF0gPT09ICdib29sZWFuJykge1xuICAgICAgYm91bmRhcnlHYXAgPSBbMCwgMF07XG4gICAgfVxuXG4gICAgYm91bmRhcnlHYXBbMF0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFswXSwgMSk7XG4gICAgYm91bmRhcnlHYXBbMV0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFsxXSwgMSk7XG4gICAgc3BhbiA9IG9yaWdpbmFsRXh0ZW50WzFdIC0gb3JpZ2luYWxFeHRlbnRbMF0gfHwgTWF0aC5hYnMob3JpZ2luYWxFeHRlbnRbMF0pO1xuICB9IC8vIE5vdGljZTogV2hlbiBtaW4vbWF4IGlzIG5vdCBzZXQgKHRoYXQgaXMsIHdoZW4gdGhlcmUgYXJlIG51bGwvdW5kZWZpbmVkLFxuICAvLyB3aGljaCBpcyB0aGUgbW9zdCBjb21tb24gY2FzZSksIHRoZXNlIGNhc2VzIHNob3VsZCBiZSBlbnN1cmVkOlxuICAvLyAoMSkgRm9yICdvcmRpbmFsJywgc2hvdyBhbGwgYXhpcy5kYXRhLlxuICAvLyAoMikgRm9yIG90aGVyczpcbiAgLy8gICAgICArIGBib3VuZGFyeUdhcGAgaXMgYXBwbGllZCAoaWYgbWluL21heCBzZXQsIGJvdW5kYXJ5R2FwIGlzXG4gIC8vICAgICAgZGlzYWJsZWQpLlxuICAvLyAgICAgICsgSWYgYG5lZWRDcm9zc1plcm9gLCBtaW4vbWF4IHNob3VsZCBiZSB6ZXJvLCBvdGhlcndpc2UsIG1pbi9tYXggc2hvdWxkXG4gIC8vICAgICAgYmUgdGhlIHJlc3VsdCB0aGF0IG9yaWdpbmFsRXh0ZW50IGVubGFyZ2VkIGJ5IGJvdW5kYXJ5R2FwLlxuICAvLyAoMykgSWYgbm8gZGF0YSwgaXQgc2hvdWxkIGJlIGVuc3VyZWQgdGhhdCBgc2NhbGUuc2V0QmxhbmtgIGlzIHNldC5cbiAgLy8gRklYTUVcbiAgLy8gKDEpIFdoZW4gbWluL21heCBpcyAnZGF0YU1pbicgb3IgJ2RhdGFNYXgnLCBzaG91bGQgYm91bmRhcnlHYXAgYmUgYWJsZSB0byB1c2VkP1xuICAvLyAoMikgV2hlbiBgbmVlZENyb3NzWmVyb2AgYW5kIGFsbCBkYXRhIGlzIHBvc2l0aXZlL25lZ2F0aXZlLCBzaG91bGQgaXQgYmUgZW5zdXJlZFxuICAvLyB0aGF0IHRoZSByZXN1bHRzIHByb2Nlc3NlZCBieSBib3VuZGFyeUdhcCBhcmUgcG9zaXRpdmUvbmVnYXRpdmU/XG5cblxuICBpZiAobWluID09IG51bGwpIHtcbiAgICBtaW4gPSBzY2FsZVR5cGUgPT09ICdvcmRpbmFsJyA/IGF4aXNEYXRhTGVuID8gMCA6IE5hTiA6IG9yaWdpbmFsRXh0ZW50WzBdIC0gYm91bmRhcnlHYXBbMF0gKiBzcGFuO1xuICB9XG5cbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gc2NhbGVUeXBlID09PSAnb3JkaW5hbCcgPyBheGlzRGF0YUxlbiA/IGF4aXNEYXRhTGVuIC0gMSA6IE5hTiA6IG9yaWdpbmFsRXh0ZW50WzFdICsgYm91bmRhcnlHYXBbMV0gKiBzcGFuO1xuICB9XG5cbiAgaWYgKG1pbiA9PT0gJ2RhdGFNaW4nKSB7XG4gICAgbWluID0gb3JpZ2luYWxFeHRlbnRbMF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1pbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1pbiA9IG1pbih7XG4gICAgICBtaW46IG9yaWdpbmFsRXh0ZW50WzBdLFxuICAgICAgbWF4OiBvcmlnaW5hbEV4dGVudFsxXVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG1heCA9PT0gJ2RhdGFNYXgnKSB7XG4gICAgbWF4ID0gb3JpZ2luYWxFeHRlbnRbMV07XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1heCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1heCA9IG1heCh7XG4gICAgICBtaW46IG9yaWdpbmFsRXh0ZW50WzBdLFxuICAgICAgbWF4OiBvcmlnaW5hbEV4dGVudFsxXVxuICAgIH0pO1xuICB9XG5cbiAgKG1pbiA9PSBudWxsIHx8ICFpc0Zpbml0ZShtaW4pKSAmJiAobWluID0gTmFOKTtcbiAgKG1heCA9PSBudWxsIHx8ICFpc0Zpbml0ZShtYXgpKSAmJiAobWF4ID0gTmFOKTtcbiAgc2NhbGUuc2V0QmxhbmsoenJVdGlsLmVxTmFOKG1pbikgfHwgenJVdGlsLmVxTmFOKG1heCkpOyAvLyBFdmFsdWF0ZSBpZiBheGlzIG5lZWRzIGNyb3NzIHplcm9cblxuICBpZiAobW9kZWwuZ2V0TmVlZENyb3NzWmVybygpKSB7XG4gICAgLy8gQXhpcyBpcyBvdmVyIHplcm8gYW5kIG1pbiBpcyBub3Qgc2V0XG4gICAgaWYgKG1pbiA+IDAgJiYgbWF4ID4gMCAmJiAhZml4TWluKSB7XG4gICAgICBtaW4gPSAwO1xuICAgIH0gLy8gQXhpcyBpcyB1bmRlciB6ZXJvIGFuZCBtYXggaXMgbm90IHNldFxuXG5cbiAgICBpZiAobWluIDwgMCAmJiBtYXggPCAwICYmICFmaXhNYXgpIHtcbiAgICAgIG1heCA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbmZ1bmN0aW9uIG5pY2VTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpIHtcbiAgdmFyIGV4dGVudCA9IGdldFNjYWxlRXh0ZW50KHNjYWxlLCBtb2RlbCk7XG4gIHZhciBmaXhNaW4gPSBtb2RlbC5nZXRNaW4oKSAhPSBudWxsO1xuICB2YXIgZml4TWF4ID0gbW9kZWwuZ2V0TWF4KCkgIT0gbnVsbDtcbiAgdmFyIHNwbGl0TnVtYmVyID0gbW9kZWwuZ2V0KCdzcGxpdE51bWJlcicpO1xuXG4gIGlmIChzY2FsZS50eXBlID09PSAnbG9nJykge1xuICAgIHNjYWxlLmJhc2UgPSBtb2RlbC5nZXQoJ2xvZ0Jhc2UnKTtcbiAgfVxuXG4gIHZhciBzY2FsZVR5cGUgPSBzY2FsZS50eXBlO1xuICBzY2FsZS5zZXRFeHRlbnQoZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICBzY2FsZS5uaWNlRXh0ZW50KHtcbiAgICBzcGxpdE51bWJlcjogc3BsaXROdW1iZXIsXG4gICAgZml4TWluOiBmaXhNaW4sXG4gICAgZml4TWF4OiBmaXhNYXgsXG4gICAgbWluSW50ZXJ2YWw6IHNjYWxlVHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyA/IG1vZGVsLmdldCgnbWluSW50ZXJ2YWwnKSA6IG51bGwsXG4gICAgbWF4SW50ZXJ2YWw6IHNjYWxlVHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyA/IG1vZGVsLmdldCgnbWF4SW50ZXJ2YWwnKSA6IG51bGxcbiAgfSk7IC8vIElmIHNvbWUgb25lIHNwZWNpZmllZCB0aGUgbWluLCBtYXguIEFuZCB0aGUgZGVmYXVsdCBjYWxjdWxhdGVkIGludGVydmFsXG4gIC8vIGlzIG5vdCBnb29kIGVub3VnaC4gSGUgY2FuIHNwZWNpZnkgdGhlIGludGVydmFsLiBJdCBpcyBvZnRlbiBhcHBlYXJlZFxuICAvLyBpbiBhbmdsZSBheGlzIHdpdGggYW5nbGUgMCAtIDM2MC4gSW50ZXJ2YWwgY2FsY3VsYXRlZCBpbiBpbnRlcnZhbCBzY2FsZSBpcyBoYXJkXG4gIC8vIHRvIGJlIDYwLlxuICAvLyBGSVhNRVxuXG4gIHZhciBpbnRlcnZhbCA9IG1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcblxuICBpZiAoaW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgIHNjYWxlLnNldEludGVydmFsICYmIHNjYWxlLnNldEludGVydmFsKGludGVydmFsKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtzdHJpbmd9IFtheGlzVHlwZV0gRGVmYXVsdCByZXRyaWV2ZSBmcm9tIG1vZGVsLnR5cGVcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlLyp9XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZUJ5TW9kZWwobW9kZWwsIGF4aXNUeXBlKSB7XG4gIGF4aXNUeXBlID0gYXhpc1R5cGUgfHwgbW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgaWYgKGF4aXNUeXBlKSB7XG4gICAgc3dpdGNoIChheGlzVHlwZSkge1xuICAgICAgLy8gQnVpbGRpbiBzY2FsZVxuICAgICAgY2FzZSAnY2F0ZWdvcnknOlxuICAgICAgICByZXR1cm4gbmV3IE9yZGluYWxTY2FsZShtb2RlbC5nZXRDYXRlZ29yaWVzKCksIFtJbmZpbml0eSwgLUluZmluaXR5XSk7XG5cbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgICAvLyBFeHRlbmRlZCBzY2FsZSwgbGlrZSB0aW1lIGFuZCBsb2dcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIChTY2FsZS5nZXRDbGFzcyhheGlzVHlwZSkgfHwgSW50ZXJ2YWxTY2FsZSkuY3JlYXRlKG1vZGVsKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGF4aXMgY29yc3MgMFxuICovXG5cblxuZnVuY3Rpb24gaWZBeGlzQ3Jvc3NaZXJvKGF4aXMpIHtcbiAgdmFyIGRhdGFFeHRlbnQgPSBheGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICB2YXIgbWluID0gZGF0YUV4dGVudFswXTtcbiAgdmFyIG1heCA9IGRhdGFFeHRlbnRbMV07XG4gIHJldHVybiAhKG1pbiA+IDAgJiYgbWF4ID4gMCB8fCBtaW4gPCAwICYmIG1heCA8IDApO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0aWNrQ29vcmRzIEluIGF4aXMgc2VsZiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHBhcmFtIHtudW1iZXJ9IGF4aXNSb3RhdGUgMDogdG93YXJkcyByaWdodCBob3Jpem9udGFsbHksIGNsb2NrLXdpc2UgaXMgbmVnYXRpdmUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xhYmVsUm90YXRlPTBdIDA6IHRvd2FyZHMgcmlnaHQgaG9yaXpvbnRhbGx5LCBjbG9jay13aXNlIGlzIG5lZ2F0aXZlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0QXhpc0xhYmVsSW50ZXJ2YWwodGlja0Nvb3JkcywgbGFiZWxzLCBmb250LCBheGlzUm90YXRlLCBsYWJlbFJvdGF0ZSkge1xuICB2YXIgdGV4dFNwYWNlVGFrZW5SZWN0O1xuICB2YXIgYXV0b0xhYmVsSW50ZXJ2YWwgPSAwO1xuICB2YXIgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsID0gMDtcbiAgdmFyIHJvdGF0aW9uID0gKGF4aXNSb3RhdGUgLSBsYWJlbFJvdGF0ZSkgLyAxODAgKiBNYXRoLlBJO1xuICB2YXIgc3RlcCA9IDE7XG5cbiAgaWYgKGxhYmVscy5sZW5ndGggPiA0MCkge1xuICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb24gZm9yIGxhcmdlIGFtb3VudCBvZiBsYWJlbHNcbiAgICBzdGVwID0gTWF0aC5mbG9vcihsYWJlbHMubGVuZ3RoIC8gNDApO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrQ29vcmRzLmxlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgdmFyIHRpY2tDb29yZCA9IHRpY2tDb29yZHNbaV07IC8vIE5vdCBwcmVjaXNlLCBkbyBub3QgY29uc2lkZXIgYWxpZ24gYW5kIHZlcnRpY2FsIGFsaWduXG4gICAgLy8gYW5kIGVhY2ggZGlzdGFuY2UgZnJvbSBheGlzIGxpbmUgeWV0LlxuXG4gICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QobGFiZWxzW2ldLCBmb250LCAnY2VudGVyJywgJ3RvcCcpO1xuICAgIHJlY3QueCArPSB0aWNrQ29vcmQgKiBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgcmVjdC55ICs9IHRpY2tDb29yZCAqIE1hdGguc2luKHJvdGF0aW9uKTsgLy8gTWFnaWMgbnVtYmVyXG5cbiAgICByZWN0LndpZHRoICo9IDEuMztcbiAgICByZWN0LmhlaWdodCAqPSAxLjM7XG5cbiAgICBpZiAoIXRleHRTcGFjZVRha2VuUmVjdCkge1xuICAgICAgdGV4dFNwYWNlVGFrZW5SZWN0ID0gcmVjdC5jbG9uZSgpO1xuICAgIH0gLy8gVGhlcmUgaXMgbm8gc3BhY2UgZm9yIGN1cnJlbnQgbGFiZWw7XG4gICAgZWxzZSBpZiAodGV4dFNwYWNlVGFrZW5SZWN0LmludGVyc2VjdChyZWN0KSkge1xuICAgICAgICBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwrKztcbiAgICAgICAgYXV0b0xhYmVsSW50ZXJ2YWwgPSBNYXRoLm1heChhdXRvTGFiZWxJbnRlcnZhbCwgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHRTcGFjZVRha2VuUmVjdC51bmlvbihyZWN0KTsgLy8gUmVzZXRcblxuICAgICAgICBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwgPSAwO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKGF1dG9MYWJlbEludGVydmFsID09PSAwICYmIHN0ZXAgPiAxKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gKGF1dG9MYWJlbEludGVydmFsICsgMSkgKiBzdGVwIC0gMTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGF4aXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxhYmVsRm9ybWF0dGVyXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEZvcm1hdHRlZExhYmVscyhheGlzLCBsYWJlbEZvcm1hdHRlcikge1xuICB2YXIgc2NhbGUgPSBheGlzLnNjYWxlO1xuICB2YXIgbGFiZWxzID0gc2NhbGUuZ2V0VGlja3NMYWJlbHMoKTtcbiAgdmFyIHRpY2tzID0gc2NhbGUuZ2V0VGlja3MoKTtcblxuICBpZiAodHlwZW9mIGxhYmVsRm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgIGxhYmVsRm9ybWF0dGVyID0gZnVuY3Rpb24gKHRwbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRwbC5yZXBsYWNlKCd7dmFsdWV9JywgdmFsICE9IG51bGwgPyB2YWwgOiAnJyk7XG4gICAgICB9O1xuICAgIH0obGFiZWxGb3JtYXR0ZXIpOyAvLyBDb25zaWRlciBlbXB0eSBhcnJheVxuXG5cbiAgICByZXR1cm4genJVdGlsLm1hcChsYWJlbHMsIGxhYmVsRm9ybWF0dGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4genJVdGlsLm1hcCh0aWNrcywgZnVuY3Rpb24gKHRpY2ssIGlkeCkge1xuICAgICAgcmV0dXJuIGxhYmVsRm9ybWF0dGVyKGdldEF4aXNSYXdWYWx1ZShheGlzLCB0aWNrKSwgaWR4KTtcbiAgICB9LCB0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGFiZWxzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNSYXdWYWx1ZShheGlzLCB2YWx1ZSkge1xuICAvLyBJbiBjYXRlZ29yeSBheGlzIHdpdGggZGF0YSB6b29tLCB0aWNrIGlzIG5vdCB0aGUgb3JpZ2luYWxcbiAgLy8gaW5kZXggb2YgYXhpcy5kYXRhLiBTbyB0aWNrIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2VyXG4gIC8vIGluIGNhdGVnb3J5IGF4aXMuXG4gIHJldHVybiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBheGlzLnNjYWxlLmdldExhYmVsKHZhbHVlKSA6IHZhbHVlO1xufVxuXG5leHBvcnRzLmdldFNjYWxlRXh0ZW50ID0gZ2V0U2NhbGVFeHRlbnQ7XG5leHBvcnRzLm5pY2VTY2FsZUV4dGVudCA9IG5pY2VTY2FsZUV4dGVudDtcbmV4cG9ydHMuY3JlYXRlU2NhbGVCeU1vZGVsID0gY3JlYXRlU2NhbGVCeU1vZGVsO1xuZXhwb3J0cy5pZkF4aXNDcm9zc1plcm8gPSBpZkF4aXNDcm9zc1plcm87XG5leHBvcnRzLmdldEF4aXNMYWJlbEludGVydmFsID0gZ2V0QXhpc0xhYmVsSW50ZXJ2YWw7XG5leHBvcnRzLmdldEZvcm1hdHRlZExhYmVscyA9IGdldEZvcm1hdHRlZExhYmVscztcbmV4cG9ydHMuZ2V0QXhpc1Jhd1ZhbHVlID0gZ2V0QXhpc1Jhd1ZhbHVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBMUlUgPSByZXF1aXJlKFwiLi4vY29yZS9MUlVcIik7XG5cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgJ3RyYW5zcGFyZW50JzogWzAsIDAsIDAsIDBdLFxuICAnYWxpY2VibHVlJzogWzI0MCwgMjQ4LCAyNTUsIDFdLFxuICAnYW50aXF1ZXdoaXRlJzogWzI1MCwgMjM1LCAyMTUsIDFdLFxuICAnYXF1YSc6IFswLCAyNTUsIDI1NSwgMV0sXG4gICdhcXVhbWFyaW5lJzogWzEyNywgMjU1LCAyMTIsIDFdLFxuICAnYXp1cmUnOiBbMjQwLCAyNTUsIDI1NSwgMV0sXG4gICdiZWlnZSc6IFsyNDUsIDI0NSwgMjIwLCAxXSxcbiAgJ2Jpc3F1ZSc6IFsyNTUsIDIyOCwgMTk2LCAxXSxcbiAgJ2JsYWNrJzogWzAsIDAsIDAsIDFdLFxuICAnYmxhbmNoZWRhbG1vbmQnOiBbMjU1LCAyMzUsIDIwNSwgMV0sXG4gICdibHVlJzogWzAsIDAsIDI1NSwgMV0sXG4gICdibHVldmlvbGV0JzogWzEzOCwgNDMsIDIyNiwgMV0sXG4gICdicm93bic6IFsxNjUsIDQyLCA0MiwgMV0sXG4gICdidXJseXdvb2QnOiBbMjIyLCAxODQsIDEzNSwgMV0sXG4gICdjYWRldGJsdWUnOiBbOTUsIDE1OCwgMTYwLCAxXSxcbiAgJ2NoYXJ0cmV1c2UnOiBbMTI3LCAyNTUsIDAsIDFdLFxuICAnY2hvY29sYXRlJzogWzIxMCwgMTA1LCAzMCwgMV0sXG4gICdjb3JhbCc6IFsyNTUsIDEyNywgODAsIDFdLFxuICAnY29ybmZsb3dlcmJsdWUnOiBbMTAwLCAxNDksIDIzNywgMV0sXG4gICdjb3Juc2lsayc6IFsyNTUsIDI0OCwgMjIwLCAxXSxcbiAgJ2NyaW1zb24nOiBbMjIwLCAyMCwgNjAsIDFdLFxuICAnY3lhbic6IFswLCAyNTUsIDI1NSwgMV0sXG4gICdkYXJrYmx1ZSc6IFswLCAwLCAxMzksIDFdLFxuICAnZGFya2N5YW4nOiBbMCwgMTM5LCAxMzksIDFdLFxuICAnZGFya2dvbGRlbnJvZCc6IFsxODQsIDEzNCwgMTEsIDFdLFxuICAnZGFya2dyYXknOiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICdkYXJrZ3JlZW4nOiBbMCwgMTAwLCAwLCAxXSxcbiAgJ2RhcmtncmV5JzogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAnZGFya2toYWtpJzogWzE4OSwgMTgzLCAxMDcsIDFdLFxuICAnZGFya21hZ2VudGEnOiBbMTM5LCAwLCAxMzksIDFdLFxuICAnZGFya29saXZlZ3JlZW4nOiBbODUsIDEwNywgNDcsIDFdLFxuICAnZGFya29yYW5nZSc6IFsyNTUsIDE0MCwgMCwgMV0sXG4gICdkYXJrb3JjaGlkJzogWzE1MywgNTAsIDIwNCwgMV0sXG4gICdkYXJrcmVkJzogWzEzOSwgMCwgMCwgMV0sXG4gICdkYXJrc2FsbW9uJzogWzIzMywgMTUwLCAxMjIsIDFdLFxuICAnZGFya3NlYWdyZWVuJzogWzE0MywgMTg4LCAxNDMsIDFdLFxuICAnZGFya3NsYXRlYmx1ZSc6IFs3MiwgNjEsIDEzOSwgMV0sXG4gICdkYXJrc2xhdGVncmF5JzogWzQ3LCA3OSwgNzksIDFdLFxuICAnZGFya3NsYXRlZ3JleSc6IFs0NywgNzksIDc5LCAxXSxcbiAgJ2Rhcmt0dXJxdW9pc2UnOiBbMCwgMjA2LCAyMDksIDFdLFxuICAnZGFya3Zpb2xldCc6IFsxNDgsIDAsIDIxMSwgMV0sXG4gICdkZWVwcGluayc6IFsyNTUsIDIwLCAxNDcsIDFdLFxuICAnZGVlcHNreWJsdWUnOiBbMCwgMTkxLCAyNTUsIDFdLFxuICAnZGltZ3JheSc6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgJ2RpbWdyZXknOiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICdkb2RnZXJibHVlJzogWzMwLCAxNDQsIDI1NSwgMV0sXG4gICdmaXJlYnJpY2snOiBbMTc4LCAzNCwgMzQsIDFdLFxuICAnZmxvcmFsd2hpdGUnOiBbMjU1LCAyNTAsIDI0MCwgMV0sXG4gICdmb3Jlc3RncmVlbic6IFszNCwgMTM5LCAzNCwgMV0sXG4gICdmdWNoc2lhJzogWzI1NSwgMCwgMjU1LCAxXSxcbiAgJ2dhaW5zYm9ybyc6IFsyMjAsIDIyMCwgMjIwLCAxXSxcbiAgJ2dob3N0d2hpdGUnOiBbMjQ4LCAyNDgsIDI1NSwgMV0sXG4gICdnb2xkJzogWzI1NSwgMjE1LCAwLCAxXSxcbiAgJ2dvbGRlbnJvZCc6IFsyMTgsIDE2NSwgMzIsIDFdLFxuICAnZ3JheSc6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgJ2dyZWVuJzogWzAsIDEyOCwgMCwgMV0sXG4gICdncmVlbnllbGxvdyc6IFsxNzMsIDI1NSwgNDcsIDFdLFxuICAnZ3JleSc6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgJ2hvbmV5ZGV3JzogWzI0MCwgMjU1LCAyNDAsIDFdLFxuICAnaG90cGluayc6IFsyNTUsIDEwNSwgMTgwLCAxXSxcbiAgJ2luZGlhbnJlZCc6IFsyMDUsIDkyLCA5MiwgMV0sXG4gICdpbmRpZ28nOiBbNzUsIDAsIDEzMCwgMV0sXG4gICdpdm9yeSc6IFsyNTUsIDI1NSwgMjQwLCAxXSxcbiAgJ2toYWtpJzogWzI0MCwgMjMwLCAxNDAsIDFdLFxuICAnbGF2ZW5kZXInOiBbMjMwLCAyMzAsIDI1MCwgMV0sXG4gICdsYXZlbmRlcmJsdXNoJzogWzI1NSwgMjQwLCAyNDUsIDFdLFxuICAnbGF3bmdyZWVuJzogWzEyNCwgMjUyLCAwLCAxXSxcbiAgJ2xlbW9uY2hpZmZvbic6IFsyNTUsIDI1MCwgMjA1LCAxXSxcbiAgJ2xpZ2h0Ymx1ZSc6IFsxNzMsIDIxNiwgMjMwLCAxXSxcbiAgJ2xpZ2h0Y29yYWwnOiBbMjQwLCAxMjgsIDEyOCwgMV0sXG4gICdsaWdodGN5YW4nOiBbMjI0LCAyNTUsIDI1NSwgMV0sXG4gICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IFsyNTAsIDI1MCwgMjEwLCAxXSxcbiAgJ2xpZ2h0Z3JheSc6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgJ2xpZ2h0Z3JlZW4nOiBbMTQ0LCAyMzgsIDE0NCwgMV0sXG4gICdsaWdodGdyZXknOiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICdsaWdodHBpbmsnOiBbMjU1LCAxODIsIDE5MywgMV0sXG4gICdsaWdodHNhbG1vbic6IFsyNTUsIDE2MCwgMTIyLCAxXSxcbiAgJ2xpZ2h0c2VhZ3JlZW4nOiBbMzIsIDE3OCwgMTcwLCAxXSxcbiAgJ2xpZ2h0c2t5Ymx1ZSc6IFsxMzUsIDIwNiwgMjUwLCAxXSxcbiAgJ2xpZ2h0c2xhdGVncmF5JzogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAnbGlnaHRzbGF0ZWdyZXknOiBbMTE5LCAxMzYsIDE1MywgMV0sXG4gICdsaWdodHN0ZWVsYmx1ZSc6IFsxNzYsIDE5NiwgMjIyLCAxXSxcbiAgJ2xpZ2h0eWVsbG93JzogWzI1NSwgMjU1LCAyMjQsIDFdLFxuICAnbGltZSc6IFswLCAyNTUsIDAsIDFdLFxuICAnbGltZWdyZWVuJzogWzUwLCAyMDUsIDUwLCAxXSxcbiAgJ2xpbmVuJzogWzI1MCwgMjQwLCAyMzAsIDFdLFxuICAnbWFnZW50YSc6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICdtYXJvb24nOiBbMTI4LCAwLCAwLCAxXSxcbiAgJ21lZGl1bWFxdWFtYXJpbmUnOiBbMTAyLCAyMDUsIDE3MCwgMV0sXG4gICdtZWRpdW1ibHVlJzogWzAsIDAsIDIwNSwgMV0sXG4gICdtZWRpdW1vcmNoaWQnOiBbMTg2LCA4NSwgMjExLCAxXSxcbiAgJ21lZGl1bXB1cnBsZSc6IFsxNDcsIDExMiwgMjE5LCAxXSxcbiAgJ21lZGl1bXNlYWdyZWVuJzogWzYwLCAxNzksIDExMywgMV0sXG4gICdtZWRpdW1zbGF0ZWJsdWUnOiBbMTIzLCAxMDQsIDIzOCwgMV0sXG4gICdtZWRpdW1zcHJpbmdncmVlbic6IFswLCAyNTAsIDE1NCwgMV0sXG4gICdtZWRpdW10dXJxdW9pc2UnOiBbNzIsIDIwOSwgMjA0LCAxXSxcbiAgJ21lZGl1bXZpb2xldHJlZCc6IFsxOTksIDIxLCAxMzMsIDFdLFxuICAnbWlkbmlnaHRibHVlJzogWzI1LCAyNSwgMTEyLCAxXSxcbiAgJ21pbnRjcmVhbSc6IFsyNDUsIDI1NSwgMjUwLCAxXSxcbiAgJ21pc3R5cm9zZSc6IFsyNTUsIDIyOCwgMjI1LCAxXSxcbiAgJ21vY2Nhc2luJzogWzI1NSwgMjI4LCAxODEsIDFdLFxuICAnbmF2YWpvd2hpdGUnOiBbMjU1LCAyMjIsIDE3MywgMV0sXG4gICduYXZ5JzogWzAsIDAsIDEyOCwgMV0sXG4gICdvbGRsYWNlJzogWzI1MywgMjQ1LCAyMzAsIDFdLFxuICAnb2xpdmUnOiBbMTI4LCAxMjgsIDAsIDFdLFxuICAnb2xpdmVkcmFiJzogWzEwNywgMTQyLCAzNSwgMV0sXG4gICdvcmFuZ2UnOiBbMjU1LCAxNjUsIDAsIDFdLFxuICAnb3JhbmdlcmVkJzogWzI1NSwgNjksIDAsIDFdLFxuICAnb3JjaGlkJzogWzIxOCwgMTEyLCAyMTQsIDFdLFxuICAncGFsZWdvbGRlbnJvZCc6IFsyMzgsIDIzMiwgMTcwLCAxXSxcbiAgJ3BhbGVncmVlbic6IFsxNTIsIDI1MSwgMTUyLCAxXSxcbiAgJ3BhbGV0dXJxdW9pc2UnOiBbMTc1LCAyMzgsIDIzOCwgMV0sXG4gICdwYWxldmlvbGV0cmVkJzogWzIxOSwgMTEyLCAxNDcsIDFdLFxuICAncGFwYXlhd2hpcCc6IFsyNTUsIDIzOSwgMjEzLCAxXSxcbiAgJ3BlYWNocHVmZic6IFsyNTUsIDIxOCwgMTg1LCAxXSxcbiAgJ3BlcnUnOiBbMjA1LCAxMzMsIDYzLCAxXSxcbiAgJ3BpbmsnOiBbMjU1LCAxOTIsIDIwMywgMV0sXG4gICdwbHVtJzogWzIyMSwgMTYwLCAyMjEsIDFdLFxuICAncG93ZGVyYmx1ZSc6IFsxNzYsIDIyNCwgMjMwLCAxXSxcbiAgJ3B1cnBsZSc6IFsxMjgsIDAsIDEyOCwgMV0sXG4gICdyZWQnOiBbMjU1LCAwLCAwLCAxXSxcbiAgJ3Jvc3licm93bic6IFsxODgsIDE0MywgMTQzLCAxXSxcbiAgJ3JveWFsYmx1ZSc6IFs2NSwgMTA1LCAyMjUsIDFdLFxuICAnc2FkZGxlYnJvd24nOiBbMTM5LCA2OSwgMTksIDFdLFxuICAnc2FsbW9uJzogWzI1MCwgMTI4LCAxMTQsIDFdLFxuICAnc2FuZHlicm93bic6IFsyNDQsIDE2NCwgOTYsIDFdLFxuICAnc2VhZ3JlZW4nOiBbNDYsIDEzOSwgODcsIDFdLFxuICAnc2Vhc2hlbGwnOiBbMjU1LCAyNDUsIDIzOCwgMV0sXG4gICdzaWVubmEnOiBbMTYwLCA4MiwgNDUsIDFdLFxuICAnc2lsdmVyJzogWzE5MiwgMTkyLCAxOTIsIDFdLFxuICAnc2t5Ymx1ZSc6IFsxMzUsIDIwNiwgMjM1LCAxXSxcbiAgJ3NsYXRlYmx1ZSc6IFsxMDYsIDkwLCAyMDUsIDFdLFxuICAnc2xhdGVncmF5JzogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAnc2xhdGVncmV5JzogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAnc25vdyc6IFsyNTUsIDI1MCwgMjUwLCAxXSxcbiAgJ3NwcmluZ2dyZWVuJzogWzAsIDI1NSwgMTI3LCAxXSxcbiAgJ3N0ZWVsYmx1ZSc6IFs3MCwgMTMwLCAxODAsIDFdLFxuICAndGFuJzogWzIxMCwgMTgwLCAxNDAsIDFdLFxuICAndGVhbCc6IFswLCAxMjgsIDEyOCwgMV0sXG4gICd0aGlzdGxlJzogWzIxNiwgMTkxLCAyMTYsIDFdLFxuICAndG9tYXRvJzogWzI1NSwgOTksIDcxLCAxXSxcbiAgJ3R1cnF1b2lzZSc6IFs2NCwgMjI0LCAyMDgsIDFdLFxuICAndmlvbGV0JzogWzIzOCwgMTMwLCAyMzgsIDFdLFxuICAnd2hlYXQnOiBbMjQ1LCAyMjIsIDE3OSwgMV0sXG4gICd3aGl0ZSc6IFsyNTUsIDI1NSwgMjU1LCAxXSxcbiAgJ3doaXRlc21va2UnOiBbMjQ1LCAyNDUsIDI0NSwgMV0sXG4gICd5ZWxsb3cnOiBbMjU1LCAyNTUsIDAsIDFdLFxuICAneWVsbG93Z3JlZW4nOiBbMTU0LCAyMDUsIDUwLCAxXVxufTtcblxuZnVuY3Rpb24gY2xhbXBDc3NCeXRlKGkpIHtcbiAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgaSA9IE1hdGgucm91bmQoaSk7IC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBDc3NBbmdsZShpKSB7XG4gIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAzNjAuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cblxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDM2MCA/IDM2MCA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzRmxvYXQoZikge1xuICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VDc3NJbnQoc3RyKSB7XG4gIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICB9XG5cbiAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUludChzdHIsIDEwKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzRmxvYXQoc3RyKSB7XG4gIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICB9XG5cbiAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbn1cblxuZnVuY3Rpb24gY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSB7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMTtcbiAgfSBlbHNlIGlmIChoID4gMSkge1xuICAgIGggLT0gMTtcbiAgfVxuXG4gIGlmIChoICogNiA8IDEpIHtcbiAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgfVxuXG4gIGlmIChoICogMiA8IDEpIHtcbiAgICByZXR1cm4gbTI7XG4gIH1cblxuICBpZiAoaCAqIDMgPCAyKSB7XG4gICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2O1xuICB9XG5cbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBsZXJwTnVtYmVyKGEsIGIsIHApIHtcbiAgcmV0dXJuIGEgKyAoYiAtIGEpICogcDtcbn1cblxuZnVuY3Rpb24gc2V0UmdiYShvdXQsIHIsIGcsIGIsIGEpIHtcbiAgb3V0WzBdID0gcjtcbiAgb3V0WzFdID0gZztcbiAgb3V0WzJdID0gYjtcbiAgb3V0WzNdID0gYTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gY29weVJnYmEob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbnZhciBjb2xvckNhY2hlID0gbmV3IExSVSgyMCk7XG52YXIgbGFzdFJlbW92ZWRBcnIgPSBudWxsO1xuXG5mdW5jdGlvbiBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gIC8vIFJldXNlIHJlbW92ZWQgYXJyYXlcbiAgaWYgKGxhc3RSZW1vdmVkQXJyKSB7XG4gICAgY29weVJnYmEobGFzdFJlbW92ZWRBcnIsIHJnYmFBcnIpO1xuICB9XG5cbiAgbGFzdFJlbW92ZWRBcnIgPSBjb2xvckNhY2hlLnB1dChjb2xvclN0ciwgbGFzdFJlbW92ZWRBcnIgfHwgcmdiYUFyci5zbGljZSgpKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yU3RyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gIGlmICghY29sb3JTdHIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZ2JhQXJyID0gcmdiYUFyciB8fCBbXTtcbiAgdmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGUuZ2V0KGNvbG9yU3RyKTtcblxuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNvcHlSZ2JhKHJnYmFBcnIsIGNhY2hlZCk7XG4gIH0gLy8gY29sb3JTdHIgbWF5IGJlIG5vdCBzdHJpbmdcblxuXG4gIGNvbG9yU3RyID0gY29sb3JTdHIgKyAnJzsgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG5cbiAgdmFyIHN0ciA9IGNvbG9yU3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7IC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cblxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSB7XG4gICAgY29weVJnYmEocmdiYUFyciwga0NTU0NvbG9yVGFibGVbc3RyXSk7XG4gICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgcmV0dXJuIHJnYmFBcnI7XG4gIH0gLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG5cblxuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjsgLy8gQ292ZXJzIE5hTi5cbiAgICAgIH1cblxuICAgICAgc2V0UmdiYShyZ2JhQXJyLCAoaXYgJiAweGYwMCkgPj4gNCB8IChpdiAmIDB4ZjAwKSA+PiA4LCBpdiAmIDB4ZjAgfCAoaXYgJiAweGYwKSA+PiA0LCBpdiAmIDB4ZiB8IChpdiAmIDB4ZikgPDwgNCwgMSk7XG4gICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cblxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHtcbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuOyAvLyBDb3ZlcnMgTmFOLlxuICAgICAgfVxuXG4gICAgICBzZXRSZ2JhKHJnYmFBcnIsIChpdiAmIDB4ZmYwMDAwKSA+PiAxNiwgKGl2ICYgMHhmZjAwKSA+PiA4LCBpdiAmIDB4ZmYsIDEpO1xuICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICByZXR1cm4gcmdiYUFycjtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLFxuICAgICAgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuXG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3AgKyAxLCBlcCAtIChvcCArIDEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7IC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFscGhhID0gcGFyc2VDc3NGbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAvLyBGYWxsIHRocm91Z2guXG5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIHBhcnNlQ3NzSW50KHBhcmFtc1swXSksIHBhcnNlQ3NzSW50KHBhcmFtc1sxXSksIHBhcnNlQ3NzSW50KHBhcmFtc1syXSksIGFscGhhKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtc1szXSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zWzNdKTtcbiAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICByZXR1cm47XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKi9cblxuXG5mdW5jdGlvbiBoc2xhMnJnYmEoaHNsYSwgcmdiYSkge1xuICB2YXIgaCA9IChwYXJzZUZsb2F0KGhzbGFbMF0pICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDsgLy8gMCAuLiAxXG4gIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG5cbiAgdmFyIHMgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMV0pO1xuICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICByZ2JhID0gcmdiYSB8fCBbXTtcbiAgc2V0UmdiYShyZ2JhLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoICsgMSAvIDMpICogMjU1KSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkgKiAyNTUpLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoIC0gMSAvIDMpICogMjU1KSwgMSk7XG5cbiAgaWYgKGhzbGEubGVuZ3RoID09PSA0KSB7XG4gICAgcmdiYVszXSA9IGhzbGFbM107XG4gIH1cblxuICByZXR1cm4gcmdiYTtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHJnYmEyaHNsYShyZ2JhKSB7XG4gIGlmICghcmdiYSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBSR0IgZnJvbSAwIHRvIDI1NVxuXG5cbiAgdmFyIFIgPSByZ2JhWzBdIC8gMjU1O1xuICB2YXIgRyA9IHJnYmFbMV0gLyAyNTU7XG4gIHZhciBCID0gcmdiYVsyXSAvIDI1NTtcbiAgdmFyIHZNaW4gPSBNYXRoLm1pbihSLCBHLCBCKTsgLy8gTWluLiB2YWx1ZSBvZiBSR0JcblxuICB2YXIgdk1heCA9IE1hdGgubWF4KFIsIEcsIEIpOyAvLyBNYXguIHZhbHVlIG9mIFJHQlxuXG4gIHZhciBkZWx0YSA9IHZNYXggLSB2TWluOyAvLyBEZWx0YSBSR0IgdmFsdWVcblxuICB2YXIgTCA9ICh2TWF4ICsgdk1pbikgLyAyO1xuICB2YXIgSDtcbiAgdmFyIFM7IC8vIEhTTCByZXN1bHRzIGZyb20gMCB0byAxXG5cbiAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgSCA9IDA7XG4gICAgUyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgIFMgPSBkZWx0YSAvICh2TWF4ICsgdk1pbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFMgPSBkZWx0YSAvICgyIC0gdk1heCAtIHZNaW4pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YVIgPSAoKHZNYXggLSBSKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG4gICAgdmFyIGRlbHRhRyA9ICgodk1heCAtIEcpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcbiAgICB2YXIgZGVsdGFCID0gKCh2TWF4IC0gQikgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuXG4gICAgaWYgKFIgPT09IHZNYXgpIHtcbiAgICAgIEggPSBkZWx0YUIgLSBkZWx0YUc7XG4gICAgfSBlbHNlIGlmIChHID09PSB2TWF4KSB7XG4gICAgICBIID0gMSAvIDMgKyBkZWx0YVIgLSBkZWx0YUI7XG4gICAgfSBlbHNlIGlmIChCID09PSB2TWF4KSB7XG4gICAgICBIID0gMiAvIDMgKyBkZWx0YUcgLSBkZWx0YVI7XG4gICAgfVxuXG4gICAgaWYgKEggPCAwKSB7XG4gICAgICBIICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKEggPiAxKSB7XG4gICAgICBIIC09IDE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhzbGEgPSBbSCAqIDM2MCwgUywgTF07XG5cbiAgaWYgKHJnYmFbM10gIT0gbnVsbCkge1xuICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgfVxuXG4gIHJldHVybiBoc2xhO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIGxpZnQoY29sb3IsIGxldmVsKSB7XG4gIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3JBcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICBjb2xvckFycltpXSA9IGNvbG9yQXJyW2ldICogKDEgLSBsZXZlbCkgfCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSAoMjU1IC0gY29sb3JBcnJbaV0pICogbGV2ZWwgKyBjb2xvckFycltpXSB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgY29sb3JBcnIubGVuZ3RoID09PSA0ID8gJ3JnYmEnIDogJ3JnYicpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHJldHVybiB7c3RyaW5nfVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvSGV4KGNvbG9yKSB7XG4gIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3JBcnIpIHtcbiAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyArY29sb3JBcnJbMl0pLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgfVxufVxuLyoqXG4gKiBNYXAgdmFsdWUgdG8gY29sb3IuIEZhc3RlciB0aGFuIGxlcnAgbWV0aG9kcyBiZWNhdXNlIGNvbG9yIGlzIHJlcHJlc2VudGVkIGJ5IHJnYmEgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBjb2xvcnMgTGlzdCBvZiByZ2JhIGNvbG9yIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSBNYXBwZWQgZ2JhIGNvbG9yIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gd2lsbCBiZSBudWxsL3VuZGVmaW5lZCBpZiBpbnB1dCBpbGxlZ2FsLlxuICovXG5cblxuZnVuY3Rpb24gZmFzdExlcnAobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIG91dCkge1xuICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCkgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvdXQgPSBvdXQgfHwgW107XG4gIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gIG91dFsyXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKTtcbiAgb3V0WzNdID0gY2xhbXBDc3NGbG9hdChsZXJwTnVtYmVyKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbnZhciBmYXN0TWFwVG9Db2xvciA9IGZhc3RMZXJwO1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIENvbG9yIGxpc3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmdWxsT3V0cHV0IERlZmF1bHQgZmFsc2UuXG4gKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2xvcjogLi4uLCBsZWZ0SW5kZXg6IC4uLiwgcmlnaHRJbmRleDogLi4uLCB2YWx1ZTogLi4ufSxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuZnVuY3Rpb24gbGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgZnVsbE91dHB1dCkge1xuICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCkgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgdmFyIGNvbG9yID0gc3RyaW5naWZ5KFtjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSksIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSwgY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpLCBjbGFtcENzc0Zsb2F0KGxlcnBOdW1iZXIobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpXSwgJ3JnYmEnKTtcbiAgcmV0dXJuIGZ1bGxPdXRwdXQgPyB7XG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGxlZnRJbmRleDogbGVmdEluZGV4LFxuICAgIHJpZ2h0SW5kZXg6IHJpZ2h0SW5kZXgsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0gOiBjb2xvcjtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbnZhciBtYXBUb0NvbG9yID0gbGVycDtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcj19IGggMCB+IDM2MCwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gcyAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5mdW5jdGlvbiBtb2RpZnlIU0woY29sb3IsIGgsIHMsIGwpIHtcbiAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yKSB7XG4gICAgY29sb3IgPSByZ2JhMmhzbGEoY29sb3IpO1xuICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICBzICE9IG51bGwgJiYgKGNvbG9yWzFdID0gcGFyc2VDc3NGbG9hdChzKSk7XG4gICAgbCAhPSBudWxsICYmIChjb2xvclsyXSA9IHBhcnNlQ3NzRmxvYXQobCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnkoaHNsYTJyZ2JhKGNvbG9yKSwgJ3JnYmEnKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyPX0gYWxwaGEgMCB+IDFcbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIG1vZGlmeUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3IgJiYgYWxwaGEgIT0gbnVsbCkge1xuICAgIGNvbG9yWzNdID0gY2xhbXBDc3NGbG9hdChhbHBoYSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJDb2xvciBsaWtlIFsxMiwzMyw0NCwwLjRdXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAncmdiYScsICdoc3ZhJywgLi4uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdCBjb2xvci4gKElmIGlucHV0IGlsbGVnYWwsIHJldHVybiB1bmRlZmluZWQpLlxuICovXG5cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyckNvbG9yLCB0eXBlKSB7XG4gIGlmICghYXJyQ29sb3IgfHwgIWFyckNvbG9yLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb2xvclN0ciA9IGFyckNvbG9yWzBdICsgJywnICsgYXJyQ29sb3JbMV0gKyAnLCcgKyBhcnJDb2xvclsyXTtcblxuICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICBjb2xvclN0ciArPSAnLCcgKyBhcnJDb2xvclszXTtcbiAgfVxuXG4gIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMubGlmdCA9IGxpZnQ7XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLmZhc3RMZXJwID0gZmFzdExlcnA7XG5leHBvcnRzLmZhc3RNYXBUb0NvbG9yID0gZmFzdE1hcFRvQ29sb3I7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5tYXBUb0NvbG9yID0gbWFwVG9Db2xvcjtcbmV4cG9ydHMubW9kaWZ5SFNMID0gbW9kaWZ5SFNMO1xuZXhwb3J0cy5tb2RpZnlBbHBoYSA9IG1vZGlmeUFscGhhO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC9jb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIE9SSUdJTl9NRVRIT0QgPSAnXFwwX190aHJvdHRsZU9yaWdpbk1ldGhvZCc7XG52YXIgUkFURSA9ICdcXDBfX3Rocm90dGxlUmF0ZSc7XG52YXIgVEhST1RUTEVfVFlQRSA9ICdcXDBfX3Rocm90dGxlVHlwZSc7XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7KEZ1bmN0aW9uKX0gZm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gVW5pdDogbXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWJvdW5jZT1mYWxzZV1cbiAqICAgICAgICB0cnVlOiBJZiBjYWxsIGludGVydmFsIGxlc3MgdGhhbiBgZGVsYXlgLCBvbmx5IHRoZSBsYXN0IGNhbGwgd29ya3MuXG4gKiAgICAgICAgZmFsc2U6IElmIGNhbGwgaW50ZXJ2YWwgbGVzcyB0aGFuIGBkZWxheSwgY2FsbCB3b3JrcyBvbiBmaXhlZCByYXRlLlxuICogQHJldHVybiB7KEZ1bmN0aW9uKX0gdGhyb3R0bGVkIGZuLlxuICovXG5cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBkZWxheSwgZGVib3VuY2UpIHtcbiAgdmFyIGN1cnJDYWxsO1xuICB2YXIgbGFzdENhbGwgPSAwO1xuICB2YXIgbGFzdEV4ZWMgPSAwO1xuICB2YXIgdGltZXIgPSBudWxsO1xuICB2YXIgZGlmZjtcbiAgdmFyIHNjb3BlO1xuICB2YXIgYXJncztcbiAgdmFyIGRlYm91bmNlTmV4dENhbGw7XG4gIGRlbGF5ID0gZGVsYXkgfHwgMDtcblxuICBmdW5jdGlvbiBleGVjKCkge1xuICAgIGxhc3RFeGVjID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGltZXIgPSBudWxsO1xuICAgIGZuLmFwcGx5KHNjb3BlLCBhcmdzIHx8IFtdKTtcbiAgfVxuXG4gIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyQ2FsbCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHNjb3BlID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciB0aGlzRGVsYXkgPSBkZWJvdW5jZU5leHRDYWxsIHx8IGRlbGF5O1xuICAgIHZhciB0aGlzRGVib3VuY2UgPSBkZWJvdW5jZU5leHRDYWxsIHx8IGRlYm91bmNlO1xuICAgIGRlYm91bmNlTmV4dENhbGwgPSBudWxsO1xuICAgIGRpZmYgPSBjdXJyQ2FsbCAtICh0aGlzRGVib3VuY2UgPyBsYXN0Q2FsbCA6IGxhc3RFeGVjKSAtIHRoaXNEZWxheTtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgaWYgKHRoaXNEZWJvdW5jZSkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIHRoaXNEZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaWZmID49IDApIHtcbiAgICAgICAgZXhlYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIC1kaWZmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0Q2FsbCA9IGN1cnJDYWxsO1xuICB9O1xuICAvKipcbiAgICogQ2xlYXIgdGhyb3R0bGUuXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICBjYi5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRW5hYmxlIGRlYm91bmNlIG9uY2UuXG4gICAqL1xuXG5cbiAgY2IuZGVib3VuY2VOZXh0Q2FsbCA9IGZ1bmN0aW9uIChkZWJvdW5jZURlbGF5KSB7XG4gICAgZGVib3VuY2VOZXh0Q2FsbCA9IGRlYm91bmNlRGVsYXk7XG4gIH07XG5cbiAgcmV0dXJuIGNiO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhyb3R0bGUgbWV0aG9kIG9yIHVwZGF0ZSB0aHJvdHRsZSByYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgLi4uXG4gKiAgICAgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUoXG4gKiAgICAgICAgIHRoaXMsXG4gKiAgICAgICAgICdfZGlzcGF0Y2hBY3Rpb24nLFxuICogICAgICAgICB0aGlzLm1vZGVsLmdldCgndGhyb3R0bGUnKSxcbiAqICAgICAgICAgJ2ZpeFJhdGUnXG4gKiAgICAgKTtcbiAqIH07XG4gKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaEFjdGlvbicpO1xuICogfTtcbiAqIENvbXBvbmVudFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaEFjdGlvbicpO1xuICogfTtcbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5BdHRyXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Rocm90dGxlVHlwZT0nZml4UmF0ZSddICdmaXhSYXRlJyBvciAnZGVib3VuY2UnXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUob2JqLCBmbkF0dHIsIHJhdGUsIHRocm90dGxlVHlwZSkge1xuICB2YXIgZm4gPSBvYmpbZm5BdHRyXTtcblxuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9yaWdpbkZuID0gZm5bT1JJR0lOX01FVEhPRF0gfHwgZm47XG4gIHZhciBsYXN0VGhyb3R0bGVUeXBlID0gZm5bVEhST1RUTEVfVFlQRV07XG4gIHZhciBsYXN0UmF0ZSA9IGZuW1JBVEVdO1xuXG4gIGlmIChsYXN0UmF0ZSAhPT0gcmF0ZSB8fCBsYXN0VGhyb3R0bGVUeXBlICE9PSB0aHJvdHRsZVR5cGUpIHtcbiAgICBpZiAocmF0ZSA9PSBudWxsIHx8ICF0aHJvdHRsZVR5cGUpIHtcbiAgICAgIHJldHVybiBvYmpbZm5BdHRyXSA9IG9yaWdpbkZuO1xuICAgIH1cblxuICAgIGZuID0gb2JqW2ZuQXR0cl0gPSB0aHJvdHRsZShvcmlnaW5GbiwgcmF0ZSwgdGhyb3R0bGVUeXBlID09PSAnZGVib3VuY2UnKTtcbiAgICBmbltPUklHSU5fTUVUSE9EXSA9IG9yaWdpbkZuO1xuICAgIGZuW1RIUk9UVExFX1RZUEVdID0gdGhyb3R0bGVUeXBlO1xuICAgIGZuW1JBVEVdID0gcmF0ZTtcbiAgfVxuXG4gIHJldHVybiBmbjtcbn1cbi8qKlxuICogQ2xlYXIgdGhyb3R0bGUuIEV4YW1wbGUgc2VlIHRocm90dGxlLmNyZWF0ZU9yVXBkYXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbkF0dHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsZWFyKG9iaiwgZm5BdHRyKSB7XG4gIHZhciBmbiA9IG9ialtmbkF0dHJdO1xuXG4gIGlmIChmbiAmJiBmbltPUklHSU5fTUVUSE9EXSkge1xuICAgIG9ialtmbkF0dHJdID0gZm5bT1JJR0lOX01FVEhPRF07XG4gIH1cbn1cblxuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xuZXhwb3J0cy5jcmVhdGVPclVwZGF0ZSA9IGNyZWF0ZU9yVXBkYXRlO1xuZXhwb3J0cy5jbGVhciA9IGNsZWFyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvdGhyb3R0bGUuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuL2dyYXBoaWNcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8vIFN5bWJvbCBmYWN0b3J5XG5cbi8qKlxuICogVHJpYW5nbGUgc2hhcGVcbiAqIEBpbm5lclxuICovXG52YXIgVHJpYW5nbGUgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgdHlwZTogJ3RyaWFuZ2xlJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICB2YXIgY3ggPSBzaGFwZS5jeDtcbiAgICB2YXIgY3kgPSBzaGFwZS5jeTtcbiAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCAvIDI7XG4gICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XG4gICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjeCArIHdpZHRoLCBjeSArIGhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kgKyBoZWlnaHQpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuLyoqXG4gKiBEaWFtb25kIHNoYXBlXG4gKiBAaW5uZXJcbiAqL1xuXG52YXIgRGlhbW9uZCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuICB0eXBlOiAnZGlhbW9uZCcsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgdmFyIGN4ID0gc2hhcGUuY3g7XG4gICAgdmFyIGN5ID0gc2hhcGUuY3k7XG4gICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xuICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xuICAgIHBhdGgubW92ZVRvKGN4LCBjeSAtIGhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xuICAgIHBhdGgubGluZVRvKGN4LCBjeSArIGhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuLyoqXG4gKiBQaW4gc2hhcGVcbiAqIEBpbm5lclxuICovXG5cbnZhciBQaW4gPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgdHlwZTogJ3BpbicsXG4gIHNoYXBlOiB7XG4gICAgLy8geCwgeSBvbiB0aGUgY3VzcFxuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgdmFyIHkgPSBzaGFwZS55O1xuICAgIHZhciB3ID0gc2hhcGUud2lkdGggLyA1ICogMzsgLy8gSGVpZ2h0IG11c3QgYmUgbGFyZ2VyIHRoYW4gd2lkdGhcblxuICAgIHZhciBoID0gTWF0aC5tYXgodywgc2hhcGUuaGVpZ2h0KTtcbiAgICB2YXIgciA9IHcgLyAyOyAvLyBEaXN0IG9uIHkgd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXG5cbiAgICB2YXIgZHkgPSByICogciAvIChoIC0gcik7XG4gICAgdmFyIGN5ID0geSAtIGggKyByICsgZHk7XG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKGR5IC8gcik7IC8vIERpc3Qgb24geCB3aXRoIHRhbmdlbnQgcG9pbnQgYW5kIGNpcmNsZSBjZW50ZXJcblxuICAgIHZhciBkeCA9IE1hdGguY29zKGFuZ2xlKSAqIHI7XG4gICAgdmFyIHRhblggPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgdmFyIHRhblkgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIGNwTGVuID0gciAqIDAuNjtcbiAgICB2YXIgY3BMZW4yID0gciAqIDAuNztcbiAgICBwYXRoLm1vdmVUbyh4IC0gZHgsIGN5ICsgZHkpO1xuICAgIHBhdGguYXJjKHgsIGN5LCByLCBNYXRoLlBJIC0gYW5nbGUsIE1hdGguUEkgKiAyICsgYW5nbGUpO1xuICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4ICsgZHggLSB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sIHgsIHkgLSBjcExlbjIsIHgsIHkpO1xuICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4LCB5IC0gY3BMZW4yLCB4IC0gZHggKyB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sIHggLSBkeCwgY3kgKyBkeSk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG4vKipcbiAqIEFycm93IHNoYXBlXG4gKiBAaW5uZXJcbiAqL1xuXG52YXIgQXJyb3cgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgdHlwZTogJ2Fycm93JyxcbiAgc2hhcGU6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgdmFyIGR4ID0gd2lkdGggLyAzICogMjtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGN0eC5saW5lVG8oeCArIGR4LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHgsIHkgKyBoZWlnaHQgLyA0ICogMyk7XG4gICAgY3R4LmxpbmVUbyh4IC0gZHgsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG59KTtcbi8qKlxuICogTWFwIG9mIHBhdGggY29udHJ1Y3RvcnNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoPn1cbiAqL1xuXG52YXIgc3ltYm9sQ3RvcnMgPSB7XG4gIGxpbmU6IGdyYXBoaWMuTGluZSxcbiAgcmVjdDogZ3JhcGhpYy5SZWN0LFxuICByb3VuZFJlY3Q6IGdyYXBoaWMuUmVjdCxcbiAgc3F1YXJlOiBncmFwaGljLlJlY3QsXG4gIGNpcmNsZTogZ3JhcGhpYy5DaXJjbGUsXG4gIGRpYW1vbmQ6IERpYW1vbmQsXG4gIHBpbjogUGluLFxuICBhcnJvdzogQXJyb3csXG4gIHRyaWFuZ2xlOiBUcmlhbmdsZVxufTtcbnZhciBzeW1ib2xTaGFwZU1ha2VycyA9IHtcbiAgbGluZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgLy8gRklYTUVcbiAgICBzaGFwZS54MSA9IHg7XG4gICAgc2hhcGUueTEgPSB5ICsgaCAvIDI7XG4gICAgc2hhcGUueDIgPSB4ICsgdztcbiAgICBzaGFwZS55MiA9IHkgKyBoIC8gMjtcbiAgfSxcbiAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgc2hhcGUueCA9IHg7XG4gICAgc2hhcGUueSA9IHk7XG4gICAgc2hhcGUud2lkdGggPSB3O1xuICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gIH0sXG4gIHJvdW5kUmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgc2hhcGUueCA9IHg7XG4gICAgc2hhcGUueSA9IHk7XG4gICAgc2hhcGUud2lkdGggPSB3O1xuICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gICAgc2hhcGUuciA9IE1hdGgubWluKHcsIGgpIC8gNDtcbiAgfSxcbiAgc3F1YXJlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHcsIGgpO1xuICAgIHNoYXBlLnggPSB4O1xuICAgIHNoYXBlLnkgPSB5O1xuICAgIHNoYXBlLndpZHRoID0gc2l6ZTtcbiAgICBzaGFwZS5oZWlnaHQgPSBzaXplO1xuICB9LFxuICBjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIC8vIFB1dCBjaXJjbGUgaW4gdGhlIGNlbnRlciBvZiBzcXVhcmVcbiAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyAyO1xuICB9LFxuICBkaWFtb25kOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgfSxcbiAgcGluOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS54ID0geCArIHcgLyAyO1xuICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XG4gICAgc2hhcGUud2lkdGggPSB3O1xuICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gIH0sXG4gIGFycm93OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS54ID0geCArIHcgLyAyO1xuICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XG4gICAgc2hhcGUud2lkdGggPSB3O1xuICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gIH0sXG4gIHRyaWFuZ2xlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgfVxufTtcbnZhciBzeW1ib2xCdWlsZFByb3hpZXMgPSB7fTtcbnpyVXRpbC5lYWNoKHN5bWJvbEN0b3JzLCBmdW5jdGlvbiAoQ3RvciwgbmFtZSkge1xuICBzeW1ib2xCdWlsZFByb3hpZXNbbmFtZV0gPSBuZXcgQ3RvcigpO1xufSk7XG52YXIgU3ltYm9sQ2x6ID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBzaGFwZToge1xuICAgIHN5bWJvbFR5cGU6ICcnLFxuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7IC8vIEZJWE1FXG5cbiAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSA9PT0gJ3BpbicgJiYgc3R5bGUudGV4dFBvc2l0aW9uID09PSAnaW5zaWRlJykge1xuICAgICAgc3R5bGUudGV4dFBvc2l0aW9uID0gWyc1MCUnLCAnNDAlJ107XG4gICAgICBzdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgfVxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgIHZhciBzeW1ib2xUeXBlID0gc2hhcGUuc3ltYm9sVHlwZTtcbiAgICB2YXIgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XG5cbiAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICBpZiAoIXByb3h5U3ltYm9sKSB7XG4gICAgICAgIC8vIERlZmF1bHQgcmVjdFxuICAgICAgICBzeW1ib2xUeXBlID0gJ3JlY3QnO1xuICAgICAgICBwcm94eVN5bWJvbCA9IHN5bWJvbEJ1aWxkUHJveGllc1tzeW1ib2xUeXBlXTtcbiAgICAgIH1cblxuICAgICAgc3ltYm9sU2hhcGVNYWtlcnNbc3ltYm9sVHlwZV0oc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCwgcHJveHlTeW1ib2wuc2hhcGUpO1xuICAgICAgcHJveHlTeW1ib2wuYnVpbGRQYXRoKGN0eCwgcHJveHlTeW1ib2wuc2hhcGUsIGluQnVuZGxlKTtcbiAgICB9XG4gIH1cbn0pOyAvLyBQcm92aWRlIHNldENvbG9yIGhlbHBlciBtZXRob2QgdG8gYXZvaWQgZGV0ZXJtaW5lIGlmIHNldCB0aGUgZmlsbCBvciBzdHJva2Ugb3V0c2lkZVxuXG5mdW5jdGlvbiBzeW1ib2xQYXRoU2V0Q29sb3IoY29sb3IsIGlubmVyQ29sb3IpIHtcbiAgaWYgKHRoaXMudHlwZSAhPT0gJ2ltYWdlJykge1xuICAgIHZhciBzeW1ib2xTdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIHN5bWJvbFNoYXBlID0gdGhpcy5zaGFwZTtcblxuICAgIGlmIChzeW1ib2xTaGFwZSAmJiBzeW1ib2xTaGFwZS5zeW1ib2xUeXBlID09PSAnbGluZScpIHtcbiAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fX2lzRW1wdHlCcnVzaCkge1xuICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XG4gICAgICBzeW1ib2xTdHlsZS5maWxsID0gaW5uZXJDb2xvciB8fCAnI2ZmZic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZJWE1FIOWIpOaWreWbvuW9oum7mOiupOaYr+Whq+WFhei/mOaYr+aPj+i+ue+8jOS9v+eUqCBvbmx5U3Ryb2tlID9cbiAgICAgIHN5bWJvbFN0eWxlLmZpbGwgJiYgKHN5bWJvbFN0eWxlLmZpbGwgPSBjb2xvcik7XG4gICAgICBzeW1ib2xTdHlsZS5zdHJva2UgJiYgKHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBzeW1ib2wgZWxlbWVudCB3aXRoIGdpdmVuIHN5bWJvbCBjb25maWd1cmF0aW9uOiBzaGFwZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUeXBlXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gKiBAcGFyYW0ge251bWJlcn0gaFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtrZWVwQXNwZWN0PWZhbHNlXSB3aGV0aGVyIHRvIGtlZXAgdGhlIHJhdGlvIG9mIHcvaCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBwYXRoIGFuZCBpbWFnZSBvbmx5LlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIHgsIHksIHcsIGgsIGNvbG9yLCBrZWVwQXNwZWN0KSB7XG4gIC8vIFRPRE8gU3VwcG9ydCBpbWFnZSBvYmplY3QsIER5bmFtaWNJbWFnZS5cbiAgdmFyIGlzRW1wdHkgPSBzeW1ib2xUeXBlLmluZGV4T2YoJ2VtcHR5JykgPT09IDA7XG5cbiAgaWYgKGlzRW1wdHkpIHtcbiAgICBzeW1ib2xUeXBlID0gc3ltYm9sVHlwZS5zdWJzdHIoNSwgMSkudG9Mb3dlckNhc2UoKSArIHN5bWJvbFR5cGUuc3Vic3RyKDYpO1xuICB9XG5cbiAgdmFyIHN5bWJvbFBhdGg7XG5cbiAgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZignaW1hZ2U6Ly8nKSA9PT0gMCkge1xuICAgIHN5bWJvbFBhdGggPSBncmFwaGljLm1ha2VJbWFnZShzeW1ib2xUeXBlLnNsaWNlKDgpLCBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHcsIGgpLCBrZWVwQXNwZWN0ID8gJ2NlbnRlcicgOiAnY292ZXInKTtcbiAgfSBlbHNlIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ3BhdGg6Ly8nKSA9PT0gMCkge1xuICAgIHN5bWJvbFBhdGggPSBncmFwaGljLm1ha2VQYXRoKHN5bWJvbFR5cGUuc2xpY2UoNyksIHt9LCBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHcsIGgpLCBrZWVwQXNwZWN0ID8gJ2NlbnRlcicgOiAnY292ZXInKTtcbiAgfSBlbHNlIHtcbiAgICBzeW1ib2xQYXRoID0gbmV3IFN5bWJvbENseih7XG4gICAgICBzaGFwZToge1xuICAgICAgICBzeW1ib2xUeXBlOiBzeW1ib2xUeXBlLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgaGVpZ2h0OiBoXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzeW1ib2xQYXRoLl9faXNFbXB0eUJydXNoID0gaXNFbXB0eTtcbiAgc3ltYm9sUGF0aC5zZXRDb2xvciA9IHN5bWJvbFBhdGhTZXRDb2xvcjtcbiAgc3ltYm9sUGF0aC5zZXRDb2xvcihjb2xvcik7XG4gIHJldHVybiBzeW1ib2xQYXRoO1xufVxuXG5leHBvcnRzLmNyZWF0ZVN5bWJvbCA9IGNyZWF0ZVN5bWJvbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxudmFyIEF4aXNQcm94eSA9IHJlcXVpcmUoXCIuL0F4aXNQcm94eVwiKTtcblxudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBlYWNoQXhpc0RpbSA9IGhlbHBlci5lYWNoQXhpc0RpbTtcbnZhciBEYXRhWm9vbU1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdkYXRhWm9vbScsXG4gIGRlcGVuZGVuY2llczogWyd4QXhpcycsICd5QXhpcycsICd6QXhpcycsICdyYWRpdXNBeGlzJywgJ2FuZ2xlQXhpcycsICdzaW5nbGVBeGlzJywgJ3NlcmllcyddLFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDQsXG4gICAgLy8gSGlnaGVyIHRoYW4gbm9ybWFsIGNvbXBvbmVudCAoejogMikuXG4gICAgb3JpZW50OiBudWxsLFxuICAgIC8vIERlZmF1bHQgYXV0byBieSBheGlzSW5kZXguIFBvc3NpYmxlIHZhbHVlOiAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcuXG4gICAgeEF4aXNJbmRleDogbnVsbCxcbiAgICAvLyBEZWZhdWx0IHRoZSBmaXJzdCBob3Jpem9udGFsIGNhdGVnb3J5IGF4aXMuXG4gICAgeUF4aXNJbmRleDogbnVsbCxcbiAgICAvLyBEZWZhdWx0IHRoZSBmaXJzdCB2ZXJ0aWNhbCBjYXRlZ29yeSBheGlzLlxuICAgIGZpbHRlck1vZGU6ICdmaWx0ZXInLFxuICAgIC8vIFBvc3NpYmxlIHZhbHVlczogJ2ZpbHRlcicgb3IgJ2VtcHR5JyBvciAnd2Vha0ZpbHRlcicuXG4gICAgLy8gJ2ZpbHRlcic6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSByZW1vdmVkLiBUaGlzIG9wdGlvbiBpc1xuICAgIC8vICAgICAgICAgIGFwcGxpY2FibGUgd2hlbiBmaWx0ZXJpbmcgb3V0bGllcnMuIEZvciBlYWNoIGRhdGEgaXRlbSwgaXQgd2lsbCBiZVxuICAgIC8vICAgICAgICAgIGZpbHRlcmVkIGlmIG9uZSBvZiB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBpcyBvdXQgb2YgdGhlIHdpbmRvdy5cbiAgICAvLyAnd2Vha0ZpbHRlcic6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSByZW1vdmVkLiBUaGlzIG9wdGlvblxuICAgIC8vICAgICAgICAgIGlzIGFwcGxpY2FibGUgd2hlbiBmaWx0ZXJpbmcgb3V0bGllcnMuIEZvciBlYWNoIGRhdGEgaXRlbSwgaXQgd2lsbCBiZVxuICAgIC8vICAgICAgICAgIGZpbHRlcmVkIG9ubHkgaWYgYWxsICBvZiB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgb3V0IG9mIHRoZSBzYW1lXG4gICAgLy8gICAgICAgICAgc2lkZSBvZiB0aGUgd2luZG93LlxuICAgIC8vICdlbXB0eSc6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSBzZXQgdG8gZW1wdHkuXG4gICAgLy8gICAgICAgICAgVGhpcyBvcHRpb24gaXMgYXBwbGljYWJsZSB3aGVuIHVzZXIgc2hvdWxkIG5vdCBuZWdsZWN0XG4gICAgLy8gICAgICAgICAgdGhhdCB0aGVyZSBhcmUgc29tZSBkYXRhIGl0ZW1zIG91dCBvZiB3aW5kb3cuXG4gICAgLy8gJ25vbmUnOiBEbyBub3QgZmlsdGVyLlxuICAgIC8vIFRha2luZyBsaW5lIGNoYXJ0IGFzIGFuIGV4YW1wbGUsIGxpbmUgd2lsbCBiZSBicm9rZW4gaW5cbiAgICAvLyB0aGUgZmlsdGVyZWQgcG9pbnRzIHdoZW4gZmlsdGVyTW9kZWwgaXMgc2V0IHRvICdlbXB0eScsIGJ1dFxuICAgIC8vIGJlIGNvbm5lY3RlZCB3aGVuIHNldCB0byAnZmlsdGVyJy5cbiAgICB0aHJvdHRsZTogbnVsbCxcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gYnkgdGhlIGZpeGVkIHJhdGUsIGF2b2lkIGZyZXF1ZW5jeS5cbiAgICAvLyBkZWZhdWx0IDEwMC4gRG8gbm90IHRocm90dGxlIHdoZW4gdXNlIG51bGwvdW5kZWZpbmVkLlxuICAgIC8vIElmIGFuaW1hdGlvbiA9PT0gdHJ1ZSBhbmQgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGUgPiAwLFxuICAgIC8vIGRlZmF1bHQgdmFsdWUgaXMgMTAwLCBvdGhlcndpc2UgMjAuXG4gICAgc3RhcnQ6IDAsXG4gICAgLy8gU3RhcnQgcGVyY2VudC4gMCB+IDEwMFxuICAgIGVuZDogMTAwLFxuICAgIC8vIEVuZCBwZXJjZW50LiAwIH4gMTAwXG4gICAgc3RhcnRWYWx1ZTogbnVsbCxcbiAgICAvLyBTdGFydCB2YWx1ZS4gSWYgc3RhcnRWYWx1ZSBzcGVjaWZpZWQsIHN0YXJ0IGlzIGlnbm9yZWQuXG4gICAgZW5kVmFsdWU6IG51bGwsXG4gICAgLy8gRW5kIHZhbHVlLiBJZiBlbmRWYWx1ZSBzcGVjaWZpZWQsIGVuZCBpcyBpZ25vcmVkLlxuICAgIG1pblNwYW46IG51bGwsXG4gICAgLy8gMCB+IDEwMFxuICAgIG1heFNwYW46IG51bGwsXG4gICAgLy8gMCB+IDEwMFxuICAgIG1pblZhbHVlU3BhbjogbnVsbCxcbiAgICAvLyBUaGUgcmFuZ2Ugb2YgZGF0YVpvb20gY2FuIG5vdCBiZSBzbWFsbGVyIHRoYW4gdGhhdC5cbiAgICBtYXhWYWx1ZVNwYW46IG51bGwsXG4gICAgLy8gVGhlIHJhbmdlIG9mIGRhdGFab29tIGNhbiBub3QgYmUgbGFyZ2VyIHRoYW4gdGhhdC5cbiAgICByYW5nZU1vZGU6IG51bGwgLy8gQXJyYXksIGNhbiBiZSAndmFsdWUnIG9yICdwZXJjZW50Jy5cblxuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgLyoqXG4gICAgICoga2V5IGxpa2UgeF8wLCB5XzFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZGF0YUludGVydmFsQnlBeGlzID0ge307XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2RhdGFJbmZvID0ge307XG4gICAgLyoqXG4gICAgICoga2V5IGxpa2UgeF8wLCB5XzFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fYXhpc1Byb3hpZXMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIHRoaXMudGV4dFN0eWxlTW9kZWw7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2F1dG9UaHJvdHRsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogJ3BlcmNlbnQnIG9yICd2YWx1ZSdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fcmFuZ2VQcm9wTW9kZSA9IFsncGVyY2VudCcsICdwZXJjZW50J107XG4gICAgdmFyIHJhd09wdGlvbiA9IHJldHJpZXZlUmF3KG9wdGlvbik7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIHRoaXMuZG9Jbml0KHJhd09wdGlvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICB2YXIgcmF3T3B0aW9uID0gcmV0cmlldmVSYXcobmV3T3B0aW9uKTsgLy9GSVggIzI1OTFcblxuICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgbmV3T3B0aW9uLCB0cnVlKTtcbiAgICB0aGlzLmRvSW5pdChyYXdPcHRpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkb0luaXQ6IGZ1bmN0aW9uIChyYXdPcHRpb24pIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uOyAvLyBEaXNhYmxlIHJlYWx0aW1lIHZpZXcgdXBkYXRlIGlmIGNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkLlxuXG4gICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzT3B0aW9uLnJlYWx0aW1lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0RGVmYXVsdFRocm90dGxlKHJhd09wdGlvbik7XG5cbiAgICB1cGRhdGVSYW5nZVVzZSh0aGlzLCByYXdPcHRpb24pO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgICAgLy8gc3RhcnQvZW5kIGhhcyBoaWdoZXIgcHJpb3JpdHkgb3ZlciBzdGFydFZhbHVlL2VuZFZhbHVlIGlmIHRoZXlcbiAgICAgIC8vIGJvdGggc2V0LCBidXQgd2Ugc2hvdWxkIG1ha2UgY2hhcnQuc2V0T3B0aW9uKHtlbmRWYWx1ZTogMTAwMH0pXG4gICAgICAvLyBlZmZlY3RpdmUsIHJhdGhlciB0aGFuIGNoYXJ0LnNldE9wdGlvbih7ZW5kVmFsdWU6IDEwMDAsIGVuZDogbnVsbH0pLlxuICAgICAgaWYgKHRoaXMuX3JhbmdlUHJvcE1vZGVbaW5kZXhdID09PSAndmFsdWUnKSB7XG4gICAgICAgIHRoaXNPcHRpb25bbmFtZXNbMF1dID0gbnVsbDtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIGRvIG5vdGhpbmcgYW5kIHVzZSB0aGUgbWVyZ2UgcmVzdWx0LlxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy50ZXh0U3R5bGVNb2RlbCA9IHRoaXMuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuXG4gICAgdGhpcy5fcmVzZXRUYXJnZXQoKTtcblxuICAgIHRoaXMuX2dpdmVBeGlzUHJveGllcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dpdmVBeGlzUHJveGllczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzUHJveGllcyA9IHRoaXMuX2F4aXNQcm94aWVzO1xuICAgIHRoaXMuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGRpbU5hbWVzLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtheGlzSW5kZXhdOyAvLyBJZiBleGlzdHMsIHNoYXJlIGF4aXNQcm94eSB3aXRoIG90aGVyIGRhdGFab29tTW9kZWxzLlxuXG4gICAgICB2YXIgYXhpc1Byb3h5ID0gYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgfHwgKCAvLyBVc2UgdGhlIGZpcnN0IGRhdGFab29tTW9kZWwgYXMgdGhlIG1haW4gbW9kZWwgb2YgYXhpc1Byb3h5LlxuICAgICAgYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgPSBuZXcgQXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCwgdGhpcywgZWNNb2RlbCkpOyAvLyBGSVhNRVxuICAgICAgLy8gZGlzcG9zZSBfX2R6QXhpc1Byb3h5XG5cbiAgICAgIGF4aXNQcm94aWVzW2RpbU5hbWVzLm5hbWUgKyAnXycgKyBheGlzSW5kZXhdID0gYXhpc1Byb3h5O1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0VGFyZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcblxuICAgIHZhciBhdXRvTW9kZSA9IHRoaXMuX2p1ZGdlQXV0b01vZGUoKTtcblxuICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgdmFyIGF4aXNJbmRleE5hbWUgPSBkaW1OYW1lcy5heGlzSW5kZXg7XG4gICAgICB0aGlzT3B0aW9uW2F4aXNJbmRleE5hbWVdID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkodGhpc09wdGlvbltheGlzSW5kZXhOYW1lXSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoYXV0b01vZGUgPT09ICdheGlzSW5kZXgnKSB7XG4gICAgICB0aGlzLl9hdXRvU2V0QXhpc0luZGV4KCk7XG4gICAgfSBlbHNlIGlmIChhdXRvTW9kZSA9PT0gJ29yaWVudCcpIHtcbiAgICAgIHRoaXMuX2F1dG9TZXRPcmllbnQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfanVkZ2VBdXRvTW9kZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIEF1dG8gc2V0IG9ubHkgd29ya3MgZm9yIHNldE9wdGlvbiBhdCB0aGUgZmlyc3QgdGltZS5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIHVzZXIncyByZXBvbnNpYmlsaXR5LiBTbyB1c2luZyBtZXJnZWRcbiAgICAvLyBvcHRpb24gaXMgT0suXG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgaGFzSW5kZXhTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgIC8vIFdoZW4gdXNlciBzZXQgYXhpc0luZGV4IGFzIGEgZW1wdHkgYXJyYXksIHdlIHRoaW5rIHRoYXQgdXNlciBzcGVjaWZ5IGF4aXNJbmRleFxuICAgICAgLy8gYnV0IGRvIG5vdCB3YW50IHVzZSBhdXRvIG1vZGUuIEJlY2F1c2UgZW1wdHkgYXJyYXkgbWF5IGJlIGVuY291bnRlcmVkIHdoZW5cbiAgICAgIC8vIHNvbWUgZXJyb3Igb2NjdXJlZC5cbiAgICAgIGlmICh0aGlzT3B0aW9uW2RpbU5hbWVzLmF4aXNJbmRleF0gIT0gbnVsbCkge1xuICAgICAgICBoYXNJbmRleFNwZWNpZmllZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdmFyIG9yaWVudCA9IHRoaXNPcHRpb24ub3JpZW50O1xuXG4gICAgaWYgKG9yaWVudCA9PSBudWxsICYmIGhhc0luZGV4U3BlY2lmaWVkKSB7XG4gICAgICByZXR1cm4gJ29yaWVudCc7XG4gICAgfSBlbHNlIGlmICghaGFzSW5kZXhTcGVjaWZpZWQpIHtcbiAgICAgIGlmIChvcmllbnQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzT3B0aW9uLm9yaWVudCA9ICdob3Jpem9udGFsJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdheGlzSW5kZXgnO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hdXRvU2V0QXhpc0luZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF1dG9BeGlzSW5kZXggPSB0cnVlO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLmdldCgnb3JpZW50JywgdHJ1ZSk7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgZGVwZW5kZW50TW9kZWxzID0gdGhpcy5kZXBlbmRlbnRNb2RlbHM7XG5cbiAgICBpZiAoYXV0b0F4aXNJbmRleCkge1xuICAgICAgLy8gRmluZCBheGlzIHRoYXQgcGFyYWxsZWwgdG8gZGF0YVpvb20gYXMgZGVmYXVsdC5cbiAgICAgIHZhciBkaW1OYW1lID0gb3JpZW50ID09PSAndmVydGljYWwnID8gJ3knIDogJ3gnO1xuXG4gICAgICBpZiAoZGVwZW5kZW50TW9kZWxzW2RpbU5hbWUgKyAnQXhpcyddLmxlbmd0aCkge1xuICAgICAgICB0aGlzT3B0aW9uW2RpbU5hbWUgKyAnQXhpc0luZGV4J10gPSBbMF07XG4gICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goZGVwZW5kZW50TW9kZWxzLnNpbmdsZUF4aXMsIGZ1bmN0aW9uIChzaW5nbGVBeGlzTW9kZWwpIHtcbiAgICAgICAgICBpZiAoYXV0b0F4aXNJbmRleCAmJiBzaW5nbGVBeGlzTW9kZWwuZ2V0KCdvcmllbnQnLCB0cnVlKSA9PT0gb3JpZW50KSB7XG4gICAgICAgICAgICB0aGlzT3B0aW9uLnNpbmdsZUF4aXNJbmRleCA9IFtzaW5nbGVBeGlzTW9kZWwuY29tcG9uZW50SW5kZXhdO1xuICAgICAgICAgICAgYXV0b0F4aXNJbmRleCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGNhdGVnb3J5IGF4aXMgYXMgZGVmYXVsdC4gKGNvbnNpZGVyIHBvbGFyKVxuICAgICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICAgIGlmICghYXV0b0F4aXNJbmRleCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGlzSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgYXhpc01vZGVscyA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdO1xuXG4gICAgICAgIGlmIChheGlzTW9kZWxzLmxlbmd0aCAmJiAhYXhpc0luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF4aXNNb2RlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChheGlzTW9kZWxzW2ldLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgICAgIGF4aXNJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpc09wdGlvbltkaW1OYW1lcy5heGlzSW5kZXhdID0gYXhpc0luZGljZXM7XG5cbiAgICAgICAgaWYgKGF4aXNJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyDov5nph4zmmK/lhbzlrrllYzLnmoTlhpnms5XvvIjmsqHmjIflrpp4QXhpc0luZGV45ZKMeUF4aXNJbmRleOaXtuaKinNjYXR0ZXLlkozlj4zmlbDlgLzovbTmipjmn7HnurPlhaVkYXRhWm9vbeaOp+WItu+8ie+8jFxuICAgICAgLy8g5L2G5piv5a6e6ZmF5piv5ZCm6ZyA6KaBR3JpZC5qcyNnZXRTY2FsZUJ5T3B0aW9u5p2l5Yik5pat77yI6ICD6JmRdGltZe+8jGxvZ+etiWF4aXMgdHlwZe+8ie+8n1xuICAgICAgLy8gSWYgYm90aCBkYXRhWm9vbS54QXhpc0luZGV4IGFuZCBkYXRhWm9vbS55QXhpc0luZGV4IGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICAvLyBkYXRhWm9vbSBjb21wb25lbnQgYXV0byBhZG9wdHMgc2VyaWVzIHRoYXQgcmVmZXJlbmNlIHRvXG4gICAgICAvLyBib3RoIHhBeGlzIGFuZCB5QXhpcyB3aGljaCB0eXBlIGlzICd2YWx1ZScuXG4gICAgICB0aGlzLmVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VyaWVzSGFzQWxsQXhlc1R5cGVPZihzZXJpZXNNb2RlbCwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBheGlzSW5kaWNlcyA9IHRoaXNPcHRpb25bZGltTmFtZXMuYXhpc0luZGV4XTtcbiAgICAgICAgICAgIHZhciBheGlzSW5kZXggPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0luZGV4KTtcbiAgICAgICAgICAgIHZhciBheGlzSWQgPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0lkKTtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5lY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgIG1haW5UeXBlOiBkaW1OYW1lcy5heGlzLFxuICAgICAgICAgICAgICBpbmRleDogYXhpc0luZGV4LFxuICAgICAgICAgICAgICBpZDogYXhpc0lkXG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIGF4aXNJbmRleCA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcblxuICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKGF4aXNJbmRpY2VzLCBheGlzSW5kZXgpIDwgMCkge1xuICAgICAgICAgICAgICBheGlzSW5kaWNlcy5wdXNoKGF4aXNJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hdXRvU2V0T3JpZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRpbTsgLy8gRmluZCB0aGUgZmlyc3QgYXhpc1xuXG4gICAgdGhpcy5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICFkaW0gJiYgKGRpbSA9IGRpbU5hbWVzLm5hbWUpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMub3B0aW9uLm9yaWVudCA9IGRpbSA9PT0gJ3knID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc1Nlcmllc0hhc0FsbEF4ZXNUeXBlT2Y6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgYXhpc1R5cGUpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIOmcgOimgXNlcmllc+eahHhBeGlzSW5kZXjlkox5QXhpc0luZGV46YO96aaW5YWI6Ieq5Yqo6K6+572u5LiK44CCXG4gICAgLy8g5L6L5aaCc2VyaWVzLnR5cGUgPT09IHNjYXR0ZXLml7bjgIJcbiAgICB2YXIgaXMgPSB0cnVlO1xuICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgdmFyIHNlcmllc0F4aXNJbmRleCA9IHNlcmllc01vZGVsLmdldChkaW1OYW1lcy5heGlzSW5kZXgpO1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdW3Nlcmllc0F4aXNJbmRleF07XG5cbiAgICAgIGlmICghYXhpc01vZGVsIHx8IGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSAhPT0gYXhpc1R5cGUpIHtcbiAgICAgICAgaXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0RGVmYXVsdFRocm90dGxlOiBmdW5jdGlvbiAocmF3T3B0aW9uKSB7XG4gICAgLy8gV2hlbiBmaXJzdCB0aW1lIHVzZXIgc2V0IHRocm90dGxlLCBhdXRvIHRocm90dGxlIGVuZHMuXG4gICAgaWYgKHJhd09wdGlvbi5oYXNPd25Qcm9wZXJ0eSgndGhyb3R0bGUnKSkge1xuICAgICAgdGhpcy5fYXV0b1Rocm90dGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2F1dG9UaHJvdHRsZSkge1xuICAgICAgdmFyIGdsb2JhbE9wdGlvbiA9IHRoaXMuZWNNb2RlbC5vcHRpb247XG4gICAgICB0aGlzLm9wdGlvbi50aHJvdHRsZSA9IGdsb2JhbE9wdGlvbi5hbmltYXRpb24gJiYgZ2xvYmFsT3B0aW9uLmFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlID4gMCA/IDEwMCA6IDIwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0Rmlyc3RUYXJnZXRBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlyc3RBeGlzTW9kZWw7XG4gICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICBpZiAoZmlyc3RBeGlzTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCk7XG5cbiAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZmlyc3RBeGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtpbmRpY2VzWzBdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBmaXJzdEF4aXNNb2RlbDtcbiAgfSxcblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBwYXJhbTogYXhpc01vZGVsLCBkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsLCBlY01vZGVsXG4gICAqL1xuICBlYWNoVGFyZ2V0QXhpczogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICBlYWNoKHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCksIGZ1bmN0aW9uIChheGlzSW5kZXgpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBkaW1OYW1lcywgYXhpc0luZGV4LCB0aGlzLCBlY01vZGVsKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltTmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHl9IElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0QXhpc1Byb3h5OiBmdW5jdGlvbiAoZGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2F4aXNQcm94aWVzW2RpbU5hbWUgKyAnXycgKyBheGlzSW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltTmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBJZiBub3QgZm91bmQsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAgICovXG4gIGdldEF4aXNNb2RlbDogZnVuY3Rpb24gKGRpbU5hbWUsIGF4aXNJbmRleCkge1xuICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmdldEF4aXNQcm94eShkaW1OYW1lLCBheGlzSW5kZXgpO1xuICAgIHJldHVybiBheGlzUHJveHkgJiYgYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBzZXQgdG8gdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuZF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRWYWx1ZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kVmFsdWVdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVVwZGF0ZVJhbmdlVXNnPWZhbHNlXVxuICAgKi9cbiAgc2V0UmF3UmFuZ2U6IGZ1bmN0aW9uIChvcHQsIGlnbm9yZVVwZGF0ZVJhbmdlVXNnKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAvLyBJZiBvbmx5IG9uZSBvZiAnc3RhcnQnIGFuZCAnc3RhcnRWYWx1ZScgaXMgbm90IG51bGwvdW5kZWZpbmVkLCB0aGUgb3RoZXJcbiAgICAgIC8vIHNob3VsZCBiZSBjbGVhcmVkLCB3aGljaCBlbmFibGUgY2xlYXIgdGhlIG9wdGlvbi5cbiAgICAgIC8vIElmIGJvdGggb2YgdGhlbSBhcmUgbm90IHNldCwga2VlcCBvcHRpb24gd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUsIHdoaWNoXG4gICAgICAvLyBlbmFibGUgdXNlIG9ubHkgc2V0IHN0YXJ0IGJ1dCBub3Qgc2V0IGVuZCB3aGVuIGNhbGxpbmcgYGRpc3BhdGNoQWN0aW9uYC5cbiAgICAgIC8vIFRoZSBzYW1lIGFzICdlbmQnIGFuZCAnZW5kVmFsdWUnLlxuICAgICAgaWYgKG9wdFtuYW1lc1swXV0gIT0gbnVsbCB8fCBvcHRbbmFtZXNbMV1dICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9uW25hbWVzWzBdXSA9IG9wdFtuYW1lc1swXV07XG4gICAgICAgIG9wdGlvbltuYW1lc1sxXV0gPSBvcHRbbmFtZXNbMV1dO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgICFpZ25vcmVVcGRhdGVSYW5nZVVzZyAmJiB1cGRhdGVSYW5nZVVzZSh0aGlzLCBvcHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbc3RhcnRQZXJjZW50LCBlbmRQZXJjZW50XVxuICAgKi9cbiAgZ2V0UGVyY2VudFJhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF4aXNQcm94eSA9IHRoaXMuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG5cbiAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICByZXR1cm4gYXhpc1Byb3h5LmdldERhdGFQZXJjZW50V2luZG93KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEZvciBleGFtcGxlLCBjaGFydC5nZXRNb2RlbCgpLmdldENvbXBvbmVudCgnZGF0YVpvb20nKS5nZXRWYWx1ZVJhbmdlKCd5JywgMCk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXhpc0RpbU5hbWVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXhpc0luZGV4XVxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3N0YXJ0VmFsdWUsIGVuZFZhbHVlXSB2YWx1ZSBjYW4gb25seSBiZSAnLScgb3IgZmluaXRlIG51bWJlci5cbiAgICovXG4gIGdldFZhbHVlUmFuZ2U6IGZ1bmN0aW9uIChheGlzRGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgaWYgKGF4aXNEaW1OYW1lID09IG51bGwgJiYgYXhpc0luZGV4ID09IG51bGwpIHtcbiAgICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuXG4gICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF4aXNQcm94eShheGlzRGltTmFtZSwgYXhpc0luZGV4KS5nZXREYXRhVmFsdWVXaW5kb3coKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2F4aXNNb2RlbF0gSWYgYXhpc01vZGVsIGdpdmVuLCBmaW5kIGF4aXNQcm94eVxuICAgKiAgICAgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGF4aXNNb2RlbFxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vQXhpc1Byb3h5fVxuICAgKi9cbiAgZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5OiBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgaWYgKGF4aXNNb2RlbCkge1xuICAgICAgcmV0dXJuIGF4aXNNb2RlbC5fX2R6QXhpc1Byb3h5O1xuICAgIH0gLy8gRmluZCB0aGUgZmlyc3QgaG9zdGVkIGF4aXNQcm94eVxuXG5cbiAgICB2YXIgYXhpc1Byb3hpZXMgPSB0aGlzLl9heGlzUHJveGllcztcblxuICAgIGZvciAodmFyIGtleSBpbiBheGlzUHJveGllcykge1xuICAgICAgaWYgKGF4aXNQcm94aWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5vIGhvc3RlZCBheGlzIGZpbmQgbm90IGhvc3RlZCBheGlzUHJveHkuXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiBkYXRhWm9vbU1vZGVsMSBhbmQgZGF0YVpvb21Nb2RlbDIgY29udHJvbCB0aGUgc2FtZSBheGlzLFxuICAgIC8vIGFuZCB0aGUgb3B0aW9uLnN0YXJ0IG9yIG9wdGlvbi5lbmQgc2V0dGluZ3MgYXJlIGRpZmZlcmVudC4gVGhlIHBlcmNlbnRSYW5nZVxuICAgIC8vIHNob3VsZCBmb2xsb3cgYXhpc1Byb3h5LlxuICAgIC8vIChXZSBlbmNvdW50ZXIgdGhpcyBwcm9ibGVtIGluIHRvb2xib3ggZGF0YSB6b29tLilcblxuXG4gICAgZm9yICh2YXIga2V5IGluIGF4aXNQcm94aWVzKSB7XG4gICAgICBpZiAoYXhpc1Byb3hpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0UmFuZ2VQcm9wTW9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5nZVByb3BNb2RlLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiByZXRyaWV2ZVJhdyhvcHRpb24pIHtcbiAgdmFyIHJldCA9IHt9O1xuICBlYWNoKFsnc3RhcnQnLCAnZW5kJywgJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnLCAndGhyb3R0bGUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBvcHRpb24uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKHJldFtuYW1lXSA9IG9wdGlvbltuYW1lXSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSYW5nZVVzZShkYXRhWm9vbU1vZGVsLCByYXdPcHRpb24pIHtcbiAgdmFyIHJhbmdlUHJvcE1vZGUgPSBkYXRhWm9vbU1vZGVsLl9yYW5nZVByb3BNb2RlO1xuICB2YXIgcmFuZ2VNb2RlSW5PcHRpb24gPSBkYXRhWm9vbU1vZGVsLmdldCgncmFuZ2VNb2RlJyk7XG4gIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgIHZhciBwZXJjZW50U3BlY2lmaWVkID0gcmF3T3B0aW9uW25hbWVzWzBdXSAhPSBudWxsO1xuICAgIHZhciB2YWx1ZVNwZWNpZmllZCA9IHJhd09wdGlvbltuYW1lc1sxXV0gIT0gbnVsbDtcblxuICAgIGlmIChwZXJjZW50U3BlY2lmaWVkICYmICF2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAncGVyY2VudCc7XG4gICAgfSBlbHNlIGlmICghcGVyY2VudFNwZWNpZmllZCAmJiB2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAndmFsdWUnO1xuICAgIH0gZWxzZSBpZiAocmFuZ2VNb2RlSW5PcHRpb24pIHtcbiAgICAgIHJhbmdlUHJvcE1vZGVbaW5kZXhdID0gcmFuZ2VNb2RlSW5PcHRpb25baW5kZXhdO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudFNwZWNpZmllZCkge1xuICAgICAgLy8gcGVyY2VudFNwZWNpZmllZCAmJiB2YWx1ZVNwZWNpZmllZFxuICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAncGVyY2VudCc7XG4gICAgfSAvLyBlbHNlIHJlbWFpbiBpdHMgb3JpZ2luYWwgc2V0dGluZy5cblxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gRGF0YVpvb21Nb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBDb21wb25lbnRWaWV3ID0gcmVxdWlyZShcIi4uLy4uL3ZpZXcvQ29tcG9uZW50XCIpO1xuXG52YXIgX2RlZmF1bHQgPSBDb21wb25lbnRWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhWm9vbScsXG4gIHJlbmRlcjogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZGF0YVpvb21Nb2RlbCA9IGRhdGFab29tTW9kZWw7XG4gICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICB0aGlzLmFwaSA9IGFwaTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZCB0aGUgZmlyc3QgdGFyZ2V0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0ge1xuICAgKiAgICAgICAgICAgICAgICAgICBncmlkOiBbXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB7bW9kZWw6IGNvb3JkMCwgYXhpc01vZGVsczogW2F4aXMxLCBheGlzM10sIGNvb3JkSW5kZXg6IDF9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDEsIGF4aXNNb2RlbHM6IFtheGlzMCwgYXhpczJdLCBjb29yZEluZGV4OiAwfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIC4uLlxuICAgKiAgICAgICAgICAgICAgICAgICBdLCAgLy8gY2FydGVzaWFucyBtdXN0IG5vdCBiZSBudWxsL3VuZGVmaW5lZC5cbiAgICogICAgICAgICAgICAgICAgICAgcG9sYXI6IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQwLCBheGlzTW9kZWxzOiBbYXhpczRdLCBjb29yZEluZGV4OiAwfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIC4uLlxuICAgKiAgICAgICAgICAgICAgICAgICBdLCAgLy8gcG9sYXJzIG11c3Qgbm90IGJlIG51bGwvdW5kZWZpbmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICBzaW5nbGVBeGlzOiBbXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB7bW9kZWw6IGNvb3JkMCwgYXhpc01vZGVsczogW10sIGNvb3JkSW5kZXg6IDB9XG4gICAqICAgICAgICAgICAgICAgICAgIF1cbiAgICovXG4gIGdldFRhcmdldENvb3JkSW5mbzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIHZhciBjb29yZFN5c0xpc3RzID0ge307XG4gICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMsIGF4aXNJbmRleCkge1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGRpbU5hbWVzLmF4aXMsIGF4aXNJbmRleCk7XG5cbiAgICAgIGlmIChheGlzTW9kZWwpIHtcbiAgICAgICAgdmFyIGNvb3JkTW9kZWwgPSBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpO1xuICAgICAgICBjb29yZE1vZGVsICYmIHNhdmUoY29vcmRNb2RlbCwgYXhpc01vZGVsLCBjb29yZFN5c0xpc3RzW2Nvb3JkTW9kZWwubWFpblR5cGVdIHx8IChjb29yZFN5c0xpc3RzW2Nvb3JkTW9kZWwubWFpblR5cGVdID0gW10pLCBjb29yZE1vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGZ1bmN0aW9uIHNhdmUoY29vcmRNb2RlbCwgYXhpc01vZGVsLCBzdG9yZSwgY29vcmRJbmRleCkge1xuICAgICAgdmFyIGl0ZW07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0b3JlW2ldLm1vZGVsID09PSBjb29yZE1vZGVsKSB7XG4gICAgICAgICAgaXRlbSA9IHN0b3JlW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICBzdG9yZS5wdXNoKGl0ZW0gPSB7XG4gICAgICAgICAgbW9kZWw6IGNvb3JkTW9kZWwsXG4gICAgICAgICAgYXhpc01vZGVsczogW10sXG4gICAgICAgICAgY29vcmRJbmRleDogY29vcmRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaXRlbS5heGlzTW9kZWxzLnB1c2goYXhpc01vZGVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29vcmRTeXNMaXN0cztcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9kZWZhdWx0ID0ge1xuICB0b29sYm94OiB7XG4gICAgYnJ1c2g6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHJlY3Q6ICfnn6nlvaLpgInmi6knLFxuICAgICAgICBwb2x5Z29uOiAn5ZyI6YCJJyxcbiAgICAgICAgbGluZVg6ICfmqKrlkJHpgInmi6knLFxuICAgICAgICBsaW5lWTogJ+e6teWQkemAieaLqScsXG4gICAgICAgIGtlZXA6ICfkv53mjIHpgInmi6knLFxuICAgICAgICBjbGVhcjogJ+a4hemZpOmAieaLqSdcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGFWaWV3OiB7XG4gICAgICB0aXRsZTogJ+aVsOaNruinhuWbvicsXG4gICAgICBsYW5nOiBbJ+aVsOaNruinhuWbvicsICflhbPpl60nLCAn5Yi35pawJ11cbiAgICB9LFxuICAgIGRhdGFab29tOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICB6b29tOiAn5Yy65Z+f57yp5pS+JyxcbiAgICAgICAgYmFjazogJ+WMuuWfn+e8qeaUvui/mOWOnydcbiAgICAgIH1cbiAgICB9LFxuICAgIG1hZ2ljVHlwZToge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgbGluZTogJ+WIh+aNouS4uuaKmOe6v+WbvicsXG4gICAgICAgIGJhcjogJ+WIh+aNouS4uuafseeKtuWbvicsXG4gICAgICAgIHN0YWNrOiAn5YiH5o2i5Li65aCG5Y+gJyxcbiAgICAgICAgdGlsZWQ6ICfliIfmjaLkuLrlubPpk7onXG4gICAgICB9XG4gICAgfSxcbiAgICByZXN0b3JlOiB7XG4gICAgICB0aXRsZTogJ+i/mOWOnydcbiAgICB9LFxuICAgIHNhdmVBc0ltYWdlOiB7XG4gICAgICB0aXRsZTogJ+S/neWtmOS4uuWbvueJhycsXG4gICAgICBsYW5nOiBbJ+WPs+mUruWPpuWtmOS4uuWbvueJhyddXG4gICAgfVxuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKFwiLi4vRWxlbWVudFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxuLyoqXG4gKiBHcm91cOaYr+S4gOS4quWuueWZqO+8jOWPr+S7peaPkuWFpeWtkOiKgueCue+8jEdyb3Vw55qE5Y+Y5o2i5Lmf5Lya6KKr5bqU55So5Yiw5a2Q6IqC54K55LiKXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2NvbnRhaW5lci9Hcm91cCcpO1xuICogICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJyk7XG4gKiAgICAgdmFyIGcgPSBuZXcgR3JvdXAoKTtcbiAqICAgICBnLnBvc2l0aW9uWzBdID0gMTAwO1xuICogICAgIGcucG9zaXRpb25bMV0gPSAxMDA7XG4gKiAgICAgZy5hZGQobmV3IENpcmNsZSh7XG4gKiAgICAgICAgIHN0eWxlOiB7XG4gKiAgICAgICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgICAgICB5OiAxMDAsXG4gKiAgICAgICAgICAgICByOiAyMCxcbiAqICAgICAgICAgfVxuICogICAgIH0pKTtcbiAqICAgICB6ci5hZGQoZyk7XG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICovXG52YXIgR3JvdXAgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGZvciAodmFyIGtleSBpbiBvcHRzKSB7XG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGhpc1trZXldID0gb3B0c1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NoaWxkcmVuID0gW107XG4gIHRoaXMuX19zdG9yYWdlID0gbnVsbDtcbiAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbn07XG5cbkdyb3VwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyb3VwLFxuICBpc0dyb3VwOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ2dyb3VwJyxcblxuICAvKipcbiAgICog5omA5pyJ5a2Q5a2Z5YWD57Sg5piv5ZCm5ZON5bqU6byg5qCH5LqL5Lu2XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9jb250YWluZXIvR3JvdXAjc2lsZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgKi9cbiAgY2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W5oyH5a6aIGluZGV4IOeahOWEv+WtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkeFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgKi9cbiAgY2hpbGRBdDogZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAqL1xuICBjaGlsZE9mTmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDoioLngrnliLDmnIDlkI5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDoioLngrnlnKggbmV4dFNpYmxpbmcg5LmL5YmNXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBuZXh0U2libGluZ1xuICAgKi9cbiAgYWRkQmVmb3JlOiBmdW5jdGlvbiAoY2hpbGQsIG5leHRTaWJsaW5nKSB7XG4gICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcyAmJiBuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgdmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YobmV4dFNpYmxpbmcpO1xuXG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2RvQWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICB9XG5cbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHN0b3JhZ2UgJiYgc3RvcmFnZSAhPT0gY2hpbGQuX19zdG9yYWdlKSB7XG4gICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHpyICYmIHpyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICog56e76Zmk5a2Q6IqC54K5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKGNoaWxkcmVuLCBjaGlsZCk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG4gICAgY2hpbGQucGFyZW50ID0gbnVsbDtcblxuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOenu+mZpOaJgOacieWtkOiKgueCuVxuICAgKi9cbiAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOmBjeWOhuaJgOacieWtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIGVhY2hDaGlsZDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7HluqbkvJjlhYjpgY3ljobmiYDmnInlrZDlrZnoioLngrlcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgY2hpbGQudHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRDaGlsZHJlblRvU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWxDaGlsZHJlbkZyb21TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgLy8gVE9ETyBDYWNoaW5nXG4gICAgdmFyIHJlY3QgPSBudWxsO1xuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBpbmNsdWRlQ2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIHRtcE1hdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjaGlsZC5pZ25vcmUgfHwgY2hpbGQuaW52aXNpYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gY2hpbGQuZ2V0TG9jYWxUcmFuc2Zvcm0odG1wTWF0KTsgLy8gVE9ET1xuICAgICAgLy8gVGhlIGJvdW5kaW5nUmVjdCBjYWNsdWF0ZWQgYnkgdHJhbnNmb3JtaW5nIG9yaWdpbmFsXG4gICAgICAvLyByZWN0IG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIGJ1bmRpbmdSZWN0IHdoZW4gcm90YXRpb25cbiAgICAgIC8vIGlzIHVzZWQuIChDb25zaWRlciBhIGNpcmNsZSByb3RhdGVkIGFnaW5zdCBpdHMgY2VudGVyLCB3aGVyZVxuICAgICAgLy8gdGhlIGFjdHVhbCBib3VuZGluZ1JlY3Qgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoYXQgbm90IGJlXG4gICAgICAvLyByb3RhdGVkLikgQnV0IHdlIGNhbiBub3QgZmluZCBiZXR0ZXIgYXBwcm9hY2ggdG8gY2FsY3VsYXRlXG4gICAgICAvLyBhY3R1YWwgYm91bmRpbmdSZWN0IHlldCwgY29uc2lkZXJpbmcgcGVyZm9ybWFuY2UuXG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGNoaWxkUmVjdCk7XG4gICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgdG1wUmVjdC5jbG9uZSgpO1xuICAgICAgICByZWN0LnVuaW9uKHRtcFJlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgY2hpbGRSZWN0LmNsb25lKCk7XG4gICAgICAgIHJlY3QudW5pb24oY2hpbGRSZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdCB8fCB0bXBSZWN0O1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKEdyb3VwLCBFbGVtZW50KTtcbnZhciBfZGVmYXVsdCA9IEdyb3VwO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBkcHIgPSAxOyAvLyBJZiBpbiBicm93c2VyIGVudmlyb25tZW50XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBkcHIgPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCAxKTtcbn1cbi8qKlxuICogY29uZmln6buY6K6k6YWN572u6aG5XG4gKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBkZWJ1Z+aXpeW/l+mAiemhue+8mmNhdGNoQnJ1c2hFeGNlcHRpb27kuLp0cnVl5LiL5pyJ5pWIXG4gKiAwIDog5LiN55Sf5oiQZGVidWfmlbDmja7vvIzlj5HluIPnlKhcbiAqIDEgOiDlvILluLjmipvlh7rvvIzosIPor5XnlKhcbiAqIDIgOiDmjqfliLblj7DovpPlh7rvvIzosIPor5XnlKhcbiAqL1xuXG5cbnZhciBkZWJ1Z01vZGUgPSAwOyAvLyByZXRpbmEg5bGP5bmV5LyY5YyWXG5cbnZhciBkZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuZXhwb3J0cy5kZWJ1Z01vZGUgPSBkZWJ1Z01vZGU7XG5leHBvcnRzLmRldmljZVBpeGVsUmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbi8vIFRPRE8gUGFyc2Ugc2hhZG93IHN0eWxlXG4vLyBUT0RPIE9ubHkgc2hhbGxvdyBwYXRoIHN1cHBvcnRcbmZ1bmN0aW9uIF9kZWZhdWx0KHByb3BlcnRpZXMpIHtcbiAgLy8gTm9ybWFsaXplXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghcHJvcGVydGllc1tpXVsxXSkge1xuICAgICAgcHJvcGVydGllc1tpXVsxXSA9IHByb3BlcnRpZXNbaV1bMF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChtb2RlbCwgZXhjbHVkZXMsIGluY2x1ZGVzKSB7XG4gICAgdmFyIHN0eWxlID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnRpZXNbaV1bMV07XG5cbiAgICAgIGlmIChleGNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihleGNsdWRlcywgcHJvcE5hbWUpID49IDAgfHwgaW5jbHVkZXMgJiYgenJVdGlsLmluZGV4T2YoaW5jbHVkZXMsIHByb3BOYW1lKSA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWwgPSBtb2RlbC5nZXRTaGFsbG93KHByb3BOYW1lKTtcblxuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnRpZXNbaV1bMF1dID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9tYWtlU3R5bGVNYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuL2N1cnZlXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIGJib3ggPSByZXF1aXJlKFwiLi9iYm94XCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4vQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBkcHIgPSBfY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG5cbi8qKlxuICogUGF0aCDku6PnkIbvvIzlj6/ku6XlnKhgYnVpbGRQYXRoYOS4reeUqOS6juabv+S7o2BjdHhgLCDkvJrkv53lrZjmr4/kuKpwYXRo5pON5L2c55qE5ZG95Luk5YiwcGF0aENvbW1hbmRz5bGe5oCn5LitXG4gKiDlj6/ku6XnlKjkuo4gaXNJbnNpZGVQYXRoIOWIpOaWreS7peWPiuiOt+WPlmJvdW5kaW5nUmVjdFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGF1dGhvciBZaSBTaGVuIChodHRwOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBnZXRUb3RhbExlbmd0aCwgZ2V0UG9pbnRBdExlbmd0aFxudmFyIENNRCA9IHtcbiAgTTogMSxcbiAgTDogMixcbiAgQzogMyxcbiAgUTogNCxcbiAgQTogNSxcbiAgWjogNixcbiAgLy8gUmVjdFxuICBSOiA3XG59OyAvLyB2YXIgQ01EX01FTV9TSVpFID0ge1xuLy8gICAgIE06IDMsXG4vLyAgICAgTDogMyxcbi8vICAgICBDOiA3LFxuLy8gICAgIFE6IDUsXG4vLyAgICAgQTogOSxcbi8vICAgICBSOiA1LFxuLy8gICAgIFo6IDFcbi8vIH07XG5cbnZhciBtaW4gPSBbXTtcbnZhciBtYXggPSBbXTtcbnZhciBtaW4yID0gW107XG52YXIgbWF4MiA9IFtdO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG52YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIFBhdGhQcm94eSA9IGZ1bmN0aW9uIChub3RTYXZlRGF0YSkge1xuICB0aGlzLl9zYXZlRGF0YSA9ICEobm90U2F2ZURhdGEgfHwgZmFsc2UpO1xuXG4gIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgIC8qKlxuICAgICAqIFBhdGggZGF0YS4gU3RvcmVkIGFzIGZsYXQgYXJyYXlcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gW107XG4gIH1cblxuICB0aGlzLl9jdHggPSBudWxsO1xufTtcbi8qKlxuICog5b+r6YCf6K6h566XUGF0aOWMheWbtOebku+8iOW5tuS4jeaYr+acgOWwj+WMheWbtOebku+8iVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cblxuUGF0aFByb3h5LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGhQcm94eSxcbiAgX3hpOiAwLFxuICBfeWk6IDAsXG4gIF94MDogMCxcbiAgX3kwOiAwLFxuICAvLyBVbml0IHgsIFVuaXQgeS4gUHJvdmlkZSBmb3IgYXZvaWRpbmcgZHJhd2luZyB0aGF0IHRvbyBzaG9ydCBsaW5lIHNlZ21lbnRcbiAgX3V4OiAwLFxuICBfdXk6IDAsXG4gIF9sZW46IDAsXG4gIF9saW5lRGFzaDogbnVsbCxcbiAgX2Rhc2hPZmZzZXQ6IDAsXG4gIF9kYXNoSWR4OiAwLFxuICBfZGFzaFN1bTogMCxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBzZXRTY2FsZTogZnVuY3Rpb24gKHN4LCBzeSkge1xuICAgIHRoaXMuX3V4ID0gbWF0aEFicygxIC8gZHByIC8gc3gpIHx8IDA7XG4gICAgdGhpcy5fdXkgPSBtYXRoQWJzKDEgLyBkcHIgLyBzeSkgfHwgMDtcbiAgfSxcbiAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4ICYmICh0aGlzLmRwciA9IGN0eC5kcHIpOyAvLyBSZXNldFxuXG4gICAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgdGhpcy5fbGluZURhc2ggPSBudWxsO1xuICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5NLCB4LCB5KTtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTsgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgLy8geGksIHlpIOiusOW9leW9k+WJjeeCuSwgeDAsIHkwIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5Zue5Yiw6LW35aeL54K544CCXG4gICAgLy8g5pyJ5Y+v6IO95ZyoIGJlZ2luUGF0aCDkuYvlkI7nm7TmjqXosIPnlKggbGluZVRv77yM6L+Z5pe25YCZIHgwLCB5MCDpnIDopoFcbiAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcblxuICAgIHRoaXMuX3gwID0geDtcbiAgICB0aGlzLl95MCA9IHk7XG4gICAgdGhpcy5feGkgPSB4O1xuICAgIHRoaXMuX3lpID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgZXhjZWVkVW5pdCA9IG1hdGhBYnMoeCAtIHRoaXMuX3hpKSA+IHRoaXMuX3V4IHx8IG1hdGhBYnMoeSAtIHRoaXMuX3lpKSA+IHRoaXMuX3V5IC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICB8fCB0aGlzLl9sZW4gPCA1O1xuICAgIHRoaXMuYWRkRGF0YShDTUQuTCwgeCwgeSk7XG5cbiAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkTGluZVRvKHgsIHkpIDogdGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgdGhpcy5feWkgPSB5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5DLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgzO1xuICAgIHRoaXMuX3lpID0geTM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlEsIHgxLCB5MSwgeDIsIHkyKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDI7XG4gICAgdGhpcy5feWkgPSB5MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuQSwgY3gsIGN5LCByLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUsIDAsIGFudGljbG9ja3dpc2UgPyAwIDogMSk7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG4gICAgdGhpcy5feGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICB0aGlzLl95aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBUT0RPXG4gIGFyY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX2N0eC5hcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVE9ET1xuICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuWik7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICB2YXIgeDAgPSB0aGlzLl94MDtcbiAgICB2YXIgeTAgPSB0aGlzLl95MDtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpICYmIHRoaXMuX2Rhc2hlZExpbmVUbyh4MCwgeTApO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDA7XG4gICAgdGhpcy5feWkgPSB5MDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ29udGV4dCDku47lpJbpg6jkvKDlhaXvvIzlm6DkuLrmnInlj6/og73mmK8gcmVidWlsZFBhdGgg5a6M5LmL5ZCO5YaNIGZpbGzjgIJcbiAgICogc3Ryb2tlIOWQjOagt1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgZmlsbDogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHN0cm9rZTogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguc3Ryb2tlKCk7XG4gICAgdGhpcy50b1N0YXRpYygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgaWYgKGxpbmVEYXNoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcbiAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZURhc2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZURhc2hTdW0gKz0gbGluZURhc2hbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Rhc2hTdW0gPSBsaW5lRGFzaFN1bTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc2V0TGluZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgfSxcblxuICAvKipcbiAgICog55u05o6l6K6+572uIFBhdGgg5pWw5o2uXG4gICAqL1xuICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmICghKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoID09IGxlbikgJiYgaGFzVHlwZWRBcnJheSkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuZGF0YVtpXSA9IGRhdGFbaV07XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuID0gbGVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDot6/lvoRcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eXxBcnJheS48bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHk+fSBwYXRoXG4gICAqL1xuICBhcHBlbmRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcHBlbmRTaXplID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbGVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXBwZW5kU2l6ZSArPSBwYXRoW2ldLmxlbigpO1xuICAgIH1cblxuICAgIGlmIChoYXNUeXBlZEFycmF5ICYmIHRoaXMuZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXBwZW5kUGF0aERhdGEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdGhpcy5kYXRhW29mZnNldCsrXSA9IGFwcGVuZFBhdGhEYXRhW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2xlbiA9IG9mZnNldDtcbiAgfSxcblxuICAvKipcbiAgICog5aGr5YWFIFBhdGgg5pWw5o2u44CCXG4gICAqIOWwvemHj+WkjeeUqOiAjOS4jeeUs+aYjuaWsOeahOaVsOe7hOOAguWkp+mDqOWIhuWbvuW9oumHjee7mOeahOaMh+S7pOaVsOaNrumVv+W6pumDveaYr+S4jeWPmOeahOOAglxuICAgKi9cbiAgYWRkRGF0YTogZnVuY3Rpb24gKGNtZCkge1xuICAgIGlmICghdGhpcy5fc2F2ZURhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIGlmICh0aGlzLl9sZW4gKyBhcmd1bWVudHMubGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIOWboOS4uuS5i+WJjeeahOaVsOe7hOW3sue7j+i9rOaNouaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXlcbiAgICAgIC8vIOaJgOS7peS4jeWkn+eUqOaXtumcgOimgeaJqeWxleS4gOS4quaWsOeahOWKqOaAgeaVsOe7hFxuICAgICAgdGhpcy5fZXhwYW5kRGF0YSgpO1xuXG4gICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW3RoaXMuX2xlbisrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmV2Q21kID0gY21kO1xuICB9LFxuICBfZXhwYW5kRGF0YTogZnVuY3Rpb24gKCkge1xuICAgIC8vIE9ubHkgaWYgZGF0YSBpcyBGbG9hdDMyQXJyYXlcbiAgICBpZiAoISh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGVuOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG5lZWRzIGpzIGltcGxlbWVudGVkIGRhc2hlZCBsaW5lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbmVlZHNEYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVEYXNoO1xuICB9LFxuICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgdmFyIGR4ID0geDEgLSB4MDtcbiAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgIHZhciBkaXN0ID0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIHZhciB4ID0geDA7XG4gICAgdmFyIHkgPSB5MDtcbiAgICB2YXIgZGFzaDtcbiAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG4gICAgdmFyIGlkeDtcbiAgICBkeCAvPSBkaXN0O1xuICAgIGR5IC89IGRpc3Q7XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICU9IGRhc2hTdW07XG4gICAgeCAtPSBvZmZzZXQgKiBkeDtcbiAgICB5IC09IG9mZnNldCAqIGR5O1xuXG4gICAgd2hpbGUgKGR4ID4gMCAmJiB4IDw9IHgxIHx8IGR4IDwgMCAmJiB4ID49IHgxIHx8IGR4ID09IDAgJiYgKGR5ID4gMCAmJiB5IDw9IHkxIHx8IGR5IDwgMCAmJiB5ID49IHkxKSkge1xuICAgICAgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICAgIGRhc2ggPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgeCArPSBkeCAqIGRhc2g7XG4gICAgICB5ICs9IGR5ICogZGFzaDtcbiAgICAgIHRoaXMuX2Rhc2hJZHggPSAoaWR4ICsgMSkgJSBuRGFzaDsgLy8gU2tpcCBwb3NpdGl2ZSBvZmZzZXRcblxuICAgICAgaWYgKGR4ID4gMCAmJiB4IDwgeDAgfHwgZHggPCAwICYmIHggPiB4MCB8fCBkeSA+IDAgJiYgeSA8IHkwIHx8IGR5IDwgMCAmJiB5ID4geTApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGN0eFtpZHggJSAyID8gJ21vdmVUbycgOiAnbGluZVRvJ10oZHggPj0gMCA/IG1hdGhNaW4oeCwgeDEpIDogbWF0aE1heCh4LCB4MSksIGR5ID49IDAgPyBtYXRoTWluKHksIHkxKSA6IG1hdGhNYXgoeSwgeTEpKTtcbiAgICB9IC8vIE9mZnNldCBmb3IgbmV4dCBsaW5lVG9cblxuXG4gICAgZHggPSB4IC0geDE7XG4gICAgZHkgPSB5IC0geTE7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIH0sXG4gIC8vIE5vdCBhY2N1cmF0ZSBkYXNoZWQgbGluZSB0b1xuICBfZGFzaGVkQmV6aWVyVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgdmFyIHQ7XG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcbiAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgdmFyIGJlemllckxlbiA9IDA7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgIHZhciB4O1xuICAgIHZhciB5O1xuICAgIHZhciB0bXBMZW4gPSAwO1xuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIG9mZnNldCAlPSBkYXNoU3VtOyAvLyBCZXppZXIgYXBwcm94IGxlbmd0aFxuXG4gICAgZm9yICh0ID0gMDsgdCA8IDE7IHQgKz0gMC4xKSB7XG4gICAgICBkeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQgKyAwLjEpIC0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICBkeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQgKyAwLjEpIC0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICBiZXppZXJMZW4gKz0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0gLy8gRmluZCBpZHggYWZ0ZXIgYWRkIG9mZnNldFxuXG5cbiAgICBmb3IgKDsgaWR4IDwgbkRhc2g7IGlkeCsrKSB7XG4gICAgICB0bXBMZW4gKz0gbGluZURhc2hbaWR4XTtcblxuICAgICAgaWYgKHRtcExlbiA+IG9mZnNldCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0ID0gKHRtcExlbiAtIG9mZnNldCkgLyBiZXppZXJMZW47XG5cbiAgICB3aGlsZSAodCA8PSAxKSB7XG4gICAgICB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7IC8vIFVzZSBsaW5lIHRvIGFwcHJveGltYXRlIGRhc2hlZCBiZXppZXJcbiAgICAgIC8vIEJhZCByZXN1bHQgaWYgZGFzaCBpcyBsb25nXG5cbiAgICAgIGlkeCAlIDIgPyBjdHgubW92ZVRvKHgsIHkpIDogY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHQgKz0gbGluZURhc2hbaWR4XSAvIGJlemllckxlbjtcbiAgICAgIGlkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgIH0gLy8gRmluaXNoIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGNhbGN1bGF0ZSB0aGUgbmV3IG9mZnNldFxuXG5cbiAgICBpZHggJSAyICE9PSAwICYmIGN0eC5saW5lVG8oeDMsIHkzKTtcbiAgICBkeCA9IHgzIC0geDtcbiAgICBkeSA9IHkzIC0geTtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgfSxcbiAgX2Rhc2hlZFF1YWRyYXRpY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgdmFyIHgzID0geDI7XG4gICAgdmFyIHkzID0geTI7XG4gICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgIHgxID0gKHRoaXMuX3hpICsgMiAqIHgxKSAvIDM7XG4gICAgeTEgPSAodGhpcy5feWkgKyAyICogeTEpIC8gMztcblxuICAgIHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDovazmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5IOWHj+WwkeWghuWGheWtmOWNoOeUqFxuICAgKiBDb252ZXJ0IGR5bmFtaWMgYXJyYXkgdG8gc3RhdGljIEZsb2F0MzJBcnJheVxuICAgKi9cbiAgdG9TdGF0aWM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGRhdGEubGVuZ3RoID0gdGhpcy5fbGVuO1xuXG4gICAgICBpZiAoaGFzVHlwZWRBcnJheSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICBtaW5bMF0gPSBtaW5bMV0gPSBtaW4yWzBdID0gbWluMlsxXSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbWF4WzBdID0gbWF4WzFdID0gbWF4MlswXSA9IG1heDJbMV0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgeGkgPSAwO1xuICAgIHZhciB5aSA9IDA7XG4gICAgdmFyIHgwID0gMDtcbiAgICB2YXIgeTAgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgIHZhciBjbWQgPSBkYXRhW2krK107XG5cbiAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAvL1xuICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgIHlpID0gZGF0YVtpICsgMV07XG4gICAgICAgIHgwID0geGk7XG4gICAgICAgIHkwID0geWk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICBtaW4yWzBdID0geDA7XG4gICAgICAgICAgbWluMlsxXSA9IHkwO1xuICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICBtYXgyWzFdID0geTA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICBiYm94LmZyb21MaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgYmJveC5mcm9tQ3ViaWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgIGJib3guZnJvbVF1YWRyYXRpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTsgLy8gVE9ETyBBcmMg5peL6L2sXG5cbiAgICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcblxuICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgIHgwID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJib3guZnJvbUFyYyhjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdOyAvLyBVc2UgZnJvbUxpbmVcblxuICAgICAgICAgIGJib3guZnJvbUxpbmUoeDAsIHkwLCB4MCArIHdpZHRoLCB5MCArIGhlaWdodCwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIFVuaW9uXG5cblxuICAgICAgdmVjMi5taW4obWluLCBtaW4sIG1pbjIpO1xuICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIG1heDIpO1xuICAgIH0gLy8gTm8gZGF0YVxuXG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICByZWJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgIHZhciB4MCwgeTA7XG4gICAgdmFyIHhpLCB5aTtcbiAgICB2YXIgeCwgeTtcbiAgICB2YXIgdXggPSB0aGlzLl91eDtcbiAgICB2YXIgdXkgPSB0aGlzLl91eTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgY21kID0gZFtpKytdO1xuXG4gICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgeGkgPSBkW2ldO1xuICAgICAgICB5aSA9IGRbaSArIDFdO1xuICAgICAgICB4MCA9IHhpO1xuICAgICAgICB5MCA9IHlpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgIHgwID0geGkgPSBkW2krK107XG4gICAgICAgICAgeTAgPSB5aSA9IGRbaSsrXTtcbiAgICAgICAgICBjdHgubW92ZVRvKHhpLCB5aSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICB4ID0gZFtpKytdO1xuICAgICAgICAgIHkgPSBkW2krK107IC8vIE5vdCBkcmF3IHRvbyBzbWFsbCBzZWcgYmV0d2VlblxuXG4gICAgICAgICAgaWYgKG1hdGhBYnMoeCAtIHhpKSA+IHV4IHx8IG1hdGhBYnMoeSAtIHlpKSA+IHV5IHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB4aSA9IHg7XG4gICAgICAgICAgICB5aSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgIHZhciBjeCA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgY3kgPSBkW2krK107XG4gICAgICAgICAgdmFyIHJ4ID0gZFtpKytdO1xuICAgICAgICAgIHZhciByeSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgdGhldGEgPSBkW2krK107XG4gICAgICAgICAgdmFyIGRUaGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcHNpID0gZFtpKytdO1xuICAgICAgICAgIHZhciBmcyA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgdmFyIHNjYWxlWSA9IHJ4ID4gcnkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICB2YXIgaXNFbGxpcHNlID0gTWF0aC5hYnMocnggLSByeSkgPiAxZS0zO1xuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHRoZXRhICsgZFRoZXRhO1xuXG4gICAgICAgICAgaWYgKGlzRWxsaXBzZSkge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtcHNpKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgIHgwID0gbWF0aENvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgeTAgPSBtYXRoU2luKHRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICB4MCA9IHhpID0gZFtpXTtcbiAgICAgICAgICB5MCA9IHlpID0gZFtpICsgMV07XG4gICAgICAgICAgY3R4LnJlY3QoZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuUGF0aFByb3h5LkNNRCA9IENNRDtcbnZhciBfZGVmYXVsdCA9IFBhdGhQcm94eTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vbW9kZWwvTW9kZWxcIik7XG5cbnZhciBEYXRhRGlmZmVyID0gcmVxdWlyZShcIi4vRGF0YURpZmZlclwiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21vZGVsXCIpO1xuXG4vKipcbiAqIExpc3QgZm9yIGRhdGEgc3RvcmFnZVxuICogQG1vZHVsZSBlY2hhcnRzL2RhdGEvTGlzdFxuICovXG52YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG52YXIgVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG52YXIgZ2xvYmFsT2JqID0gdHlwZW9mIHdpbmRvdyA9PT0gVU5ERUZJTkVEID8gZ2xvYmFsIDogd2luZG93O1xudmFyIGRhdGFDdG9ycyA9IHtcbiAgJ2Zsb2F0JzogdHlwZW9mIGdsb2JhbE9iai5GbG9hdDY0QXJyYXkgPT09IFVOREVGSU5FRCA/IEFycmF5IDogZ2xvYmFsT2JqLkZsb2F0NjRBcnJheSxcbiAgJ2ludCc6IHR5cGVvZiBnbG9iYWxPYmouSW50MzJBcnJheSA9PT0gVU5ERUZJTkVEID8gQXJyYXkgOiBnbG9iYWxPYmouSW50MzJBcnJheSxcbiAgLy8gT3JkaW5hbCBkYXRhIHR5cGUgY2FuIGJlIHN0cmluZyBvciBpbnRcbiAgJ29yZGluYWwnOiBBcnJheSxcbiAgJ251bWJlcic6IEFycmF5LFxuICAndGltZSc6IEFycmF5XG59O1xudmFyIFRSQU5TRkVSQUJMRV9QUk9QRVJUSUVTID0gWydzdGFja2VkT24nLCAnaGFzSXRlbU9wdGlvbicsICdfbmFtZUxpc3QnLCAnX2lkTGlzdCcsICdfcmF3RGF0YSddO1xuXG5mdW5jdGlvbiB0cmFuc2ZlclByb3BlcnRpZXMoYSwgYikge1xuICB6clV0aWwuZWFjaChUUkFOU0ZFUkFCTEVfUFJPUEVSVElFUy5jb25jYXQoYi5fX3dyYXBwZWRNZXRob2RzIHx8IFtdKSwgZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBhW3Byb3BOYW1lXSA9IGJbcHJvcE5hbWVdO1xuICAgIH1cbiAgfSk7XG4gIGEuX193cmFwcGVkTWV0aG9kcyA9IGIuX193cmFwcGVkTWV0aG9kcztcbn1cblxuZnVuY3Rpb24gRGVmYXVsdERhdGFQcm92aWRlcihkYXRhQXJyYXkpIHtcbiAgdGhpcy5fYXJyYXkgPSBkYXRhQXJyYXkgfHwgW107XG59XG5cbkRlZmF1bHREYXRhUHJvdmlkZXIucHJvdG90eXBlLnB1cmUgPSBmYWxzZTtcblxuRGVmYXVsdERhdGFQcm92aWRlci5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5sZW5ndGg7XG59O1xuXG5EZWZhdWx0RGF0YVByb3ZpZGVyLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gKGlkeCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXlbaWR4XTtcbn07XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2RhdGEvTGlzdFxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3xPYmplY3Q+fSBkaW1lbnNpb25zXG4gKiAgICAgIEZvciBleGFtcGxlLCBbJ3NvbWVEaW1OYW1lJywge25hbWU6ICdzb21lRGltTmFtZScsIHR5cGU6ICdzb21lRGltVHlwZSd9LCAuLi5dLlxuICogICAgICBEaW1lbnNpb25zIHNob3VsZCBiZSBjb25jcmV0ZSBuYW1lcyBsaWtlIHgsIHksIHosIGxuZywgbGF0LCBhbmdsZSwgcmFkaXVzXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBob3N0TW9kZWxcbiAqL1xuXG5cbnZhciBMaXN0ID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGhvc3RNb2RlbCkge1xuICBkaW1lbnNpb25zID0gZGltZW5zaW9ucyB8fCBbJ3gnLCAneSddO1xuICB2YXIgZGltZW5zaW9uSW5mb3MgPSB7fTtcbiAgdmFyIGRpbWVuc2lvbk5hbWVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpbWVuc2lvbk5hbWU7XG4gICAgdmFyIGRpbWVuc2lvbkluZm8gPSB7fTtcblxuICAgIGlmICh0eXBlb2YgZGltZW5zaW9uc1tpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRpbWVuc2lvbk5hbWUgPSBkaW1lbnNpb25zW2ldO1xuICAgICAgZGltZW5zaW9uSW5mbyA9IHtcbiAgICAgICAgbmFtZTogZGltZW5zaW9uTmFtZSxcbiAgICAgICAgY29vcmREaW06IGRpbWVuc2lvbk5hbWUsXG4gICAgICAgIGNvb3JkRGltSW5kZXg6IDAsXG4gICAgICAgIHN0YWNrYWJsZTogZmFsc2UsXG4gICAgICAgIC8vIFR5cGUgY2FuIGJlICdmbG9hdCcsICdpbnQnLCAnbnVtYmVyJ1xuICAgICAgICAvLyBEZWZhdWx0IGlzIG51bWJlciwgUHJlY2lzaW9uIG9mIGZsb2F0IG1heSBub3QgZW5vdWdoXG4gICAgICAgIHR5cGU6ICdudW1iZXInXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaW1lbnNpb25JbmZvID0gZGltZW5zaW9uc1tpXTtcbiAgICAgIGRpbWVuc2lvbk5hbWUgPSBkaW1lbnNpb25JbmZvLm5hbWU7XG4gICAgICBkaW1lbnNpb25JbmZvLnR5cGUgPSBkaW1lbnNpb25JbmZvLnR5cGUgfHwgJ251bWJlcic7XG5cbiAgICAgIGlmICghZGltZW5zaW9uSW5mby5jb29yZERpbSkge1xuICAgICAgICBkaW1lbnNpb25JbmZvLmNvb3JkRGltID0gZGltZW5zaW9uTmFtZTtcbiAgICAgICAgZGltZW5zaW9uSW5mby5jb29yZERpbUluZGV4ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaW1lbnNpb25JbmZvLm90aGVyRGltcyA9IGRpbWVuc2lvbkluZm8ub3RoZXJEaW1zIHx8IHt9O1xuICAgIGRpbWVuc2lvbk5hbWVzLnB1c2goZGltZW5zaW9uTmFtZSk7XG4gICAgZGltZW5zaW9uSW5mb3NbZGltZW5zaW9uTmFtZV0gPSBkaW1lbnNpb25JbmZvO1xuICB9XG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cblxuXG4gIHRoaXMuZGltZW5zaW9ucyA9IGRpbWVuc2lvbk5hbWVzO1xuICAvKipcbiAgICogSW5mb21hdGlvbiBvZiBlYWNoIGRhdGEgZGltZW5zaW9uLCBsaWtlIGRhdGEgdHlwZS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5fZGltZW5zaW9uSW5mb3MgPSBkaW1lbnNpb25JbmZvcztcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICovXG5cbiAgdGhpcy5ob3N0TW9kZWwgPSBob3N0TW9kZWw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAqL1xuXG4gIHRoaXMuZGF0YVR5cGU7XG4gIC8qKlxuICAgKiBJbmRpY2VzIHN0b3JlcyB0aGUgaW5kaWNlcyBvZiBkYXRhIHN1YnNldCBhZnRlciBmaWx0ZXJlZC5cbiAgICogVGhpcyBkYXRhIHN1YnNldCB3aWxsIGJlIHVzZWQgaW4gY2hhcnQuXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuXG4gIHRoaXMuaW5kaWNlcyA9IFtdO1xuICAvKipcbiAgICogRGF0YSBzdG9yYWdlXG4gICAqIEB0eXBlIHtPYmplY3QuPGtleSwgVHlwZWRBcnJheXxBcnJheT59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3N0b3JhZ2UgPSB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICovXG5cbiAgdGhpcy5fbmFtZUxpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICovXG5cbiAgdGhpcy5faWRMaXN0ID0gW107XG4gIC8qKlxuICAgKiBNb2RlbHMgb2YgZGF0YSBvcHRpb24gaXMgc3RvcmVkIHNwYXJzZSBmb3Igb3B0aW1pemluZyBtZW1vcnkgY29zdFxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fb3B0aW9uTW9kZWxzID0gW107XG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH1cbiAgICovXG5cbiAgdGhpcy5zdGFja2VkT24gPSBudWxsO1xuICAvKipcbiAgICogR2xvYmFsIHZpc3VhbCBwcm9wZXJ0aWVzIGFmdGVyIHZpc3VhbCBjb2RpbmdcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fdmlzdWFsID0ge307XG4gIC8qKlxuICAgKiBHbG9iZWwgbGF5b3V0IHByb3BlcnRpZXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2xheW91dCA9IHt9O1xuICAvKipcbiAgICogSXRlbSB2aXN1YWwgcHJvcGVydGllcyBhZnRlciB2aXN1YWwgY29kaW5nXG4gICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5faXRlbVZpc3VhbHMgPSBbXTtcbiAgLyoqXG4gICAqIEl0ZW0gbGF5b3V0IHByb3BlcnRpZXMgYWZ0ZXIgbGF5b3V0XG4gICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5faXRlbUxheW91dHMgPSBbXTtcbiAgLyoqXG4gICAqIEdyYXBoaWMgZWxlbW5lbnRzXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2dyYXBoaWNFbHMgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48QXJyYXl8T2JqZWN0Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fcmF3RGF0YTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2V4dGVudDtcbn07XG5cbnZhciBsaXN0UHJvdG8gPSBMaXN0LnByb3RvdHlwZTtcbmxpc3RQcm90by50eXBlID0gJ2xpc3QnO1xuLyoqXG4gKiBJZiBlYWNoIGRhdGEgaXRlbSBoYXMgaXQncyBvd24gb3B0aW9uXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuXG5saXN0UHJvdG8uaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4vKipcbiAqIEdldCBkaW1lbnNpb24gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkaW1cbiAqICAgICAgICBEaW1lbnNpb24gY2FuIGJlIGNvbmNyZXRlIG5hbWVzIGxpa2UgeCwgeSwgeiwgbG5nLCBsYXQsIGFuZ2xlLCByYWRpdXNcbiAqICAgICAgICBPciBhIG9yZGluYWwgbnVtYmVyLiBGb3IgZXhhbXBsZSBnZXREaW1lbnNpb25JbmZvKDApIHdpbGwgcmV0dXJuICd4JyBvciAnbG5nJyBvciAncmFkaXVzJ1xuICogQHJldHVybiB7c3RyaW5nfSBDb25jcmV0ZSBkaW0gbmFtZS5cbiAqL1xuXG5saXN0UHJvdG8uZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSkge1xuICBpZiAoIWlzTmFOKGRpbSkpIHtcbiAgICBkaW0gPSB0aGlzLmRpbWVuc2lvbnNbZGltXSB8fCBkaW07XG4gIH1cblxuICByZXR1cm4gZGltO1xufTtcbi8qKlxuICogR2V0IHR5cGUgYW5kIHN0YWNrYWJsZSBpbmZvIG9mIHBhcnRpY3VsYXIgZGltZW5zaW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRpbVxuICogICAgICAgIERpbWVuc2lvbiBjYW4gYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xuICogICAgICAgIE9yIGEgb3JkaW5hbCBudW1iZXIuIEZvciBleGFtcGxlIGdldERpbWVuc2lvbkluZm8oMCkgd2lsbCByZXR1cm4gJ3gnIG9yICdsbmcnIG9yICdyYWRpdXMnXG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0RGltZW5zaW9uSW5mbyA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgcmV0dXJuIHpyVXRpbC5jbG9uZSh0aGlzLl9kaW1lbnNpb25JbmZvc1t0aGlzLmdldERpbWVuc2lvbihkaW0pXSk7XG59O1xuLyoqXG4gKiBJbml0aWFsaXplIGZyb20gZGF0YVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0fG51bWJlcnxBcnJheT59IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtuYW1lTGlzdF1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtkaW1WYWx1ZUdldHRlcl0gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSA9PiBudW1iZXJcbiAqL1xuXG5cbmxpc3RQcm90by5pbml0RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBuYW1lTGlzdCwgZGltVmFsdWVHZXR0ZXIpIHtcbiAgZGF0YSA9IGRhdGEgfHwgW107XG4gIHZhciBpc0RhdGFBcnJheSA9IHpyVXRpbC5pc0FycmF5KGRhdGEpO1xuXG4gIGlmIChpc0RhdGFBcnJheSkge1xuICAgIGRhdGEgPSBuZXcgRGVmYXVsdERhdGFQcm92aWRlcihkYXRhKTtcbiAgfVxuXG4gIHRoaXMuX3Jhd0RhdGEgPSBkYXRhOyAvLyBDbGVhclxuXG4gIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZSA9IHt9O1xuICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcyA9IFtdO1xuICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgdmFyIGRpbWVuc2lvbkluZm9NYXAgPSB0aGlzLl9kaW1lbnNpb25JbmZvcztcbiAgdmFyIHNpemUgPSBkYXRhLmNvdW50KCk7XG4gIHZhciBpZExpc3QgPSBbXTtcbiAgdmFyIG5hbWVSZXBlYXRDb3VudCA9IHt9O1xuICB2YXIgbmFtZURpbUlkeDtcbiAgbmFtZUxpc3QgPSBuYW1lTGlzdCB8fCBbXTsgLy8gSW5pdCBzdG9yYWdlXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpbUluZm8gPSBkaW1lbnNpb25JbmZvTWFwW2RpbWVuc2lvbnNbaV1dO1xuICAgIGRpbUluZm8ub3RoZXJEaW1zLml0ZW1OYW1lID09PSAwICYmIChuYW1lRGltSWR4ID0gaSk7XG4gICAgdmFyIERhdGFDdG9yID0gZGF0YUN0b3JzW2RpbUluZm8udHlwZV07XG4gICAgc3RvcmFnZVtkaW1lbnNpb25zW2ldXSA9IG5ldyBEYXRhQ3RvcihzaXplKTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIWRpbVZhbHVlR2V0dGVyKSB7XG4gICAgc2VsZi5oYXNJdGVtT3B0aW9uID0gZmFsc2U7XG4gIH0gLy8gRGVmYXVsdCBkaW0gdmFsdWUgZ2V0dGVyXG5cblxuICBkaW1WYWx1ZUdldHRlciA9IGRpbVZhbHVlR2V0dGVyIHx8IGZ1bmN0aW9uIChkYXRhSXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgIHZhciB2YWx1ZSA9IG1vZGVsVXRpbC5nZXREYXRhSXRlbVZhbHVlKGRhdGFJdGVtKTsgLy8gSWYgYW55IGRhdGFJdGVtIGlzIGxpa2UgeyB2YWx1ZTogMTAgfVxuXG4gICAgaWYgKG1vZGVsVXRpbC5pc0RhdGFJdGVtT3B0aW9uKGRhdGFJdGVtKSkge1xuICAgICAgc2VsZi5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kZWxVdGlsLmNvbnZlckRhdGFWYWx1ZSh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWVbZGltSW5kZXhdIC8vIElmIHZhbHVlIGlzIGEgc2luZ2xlIG51bWJlciBvciBzb21ldGhpbmcgZWxzZSBub3QgYXJyYXkuXG4gICAgOiB2YWx1ZSwgZGltZW5zaW9uSW5mb01hcFtkaW1OYW1lXSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAvLyBOT1RJQ0U6IFRyeSBub3QgdG8gd3JpdGUgdGhpbmdzIGludG8gZGF0YUl0ZW1cbiAgICB2YXIgZGF0YUl0ZW0gPSBkYXRhLmdldEl0ZW0oaSk7IC8vIEVhY2ggZGF0YSBpdGVtIGlzIHZhbHVlXG4gICAgLy8gWzEsIDJdXG4gICAgLy8gMlxuICAgIC8vIEJhciBjaGFydCwgbGluZSBjaGFydCB3aGljaCB1c2VzIGNhdGVnb3J5IGF4aXNcbiAgICAvLyBvbmx5IGdpdmVzIHRoZSAneScgdmFsdWUuICd4JyB2YWx1ZSBpcyB0aGUgaW5kaWNlcyBvZiBjYXRlb2dyeVxuICAgIC8vIFVzZSBhIHRlbXBWYWx1ZSB0byBub3JtYWxpemUgdGhlIHZhbHVlIHRvIGJlIGEgKHgsIHkpIHZhbHVlXG4gICAgLy8gU3RvcmUgdGhlIGRhdGEgYnkgZGltZW5zaW9uc1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBkaW1lbnNpb25zLmxlbmd0aDsgaysrKSB7XG4gICAgICB2YXIgZGltID0gZGltZW5zaW9uc1trXTtcbiAgICAgIHZhciBkaW1TdG9yYWdlID0gc3RvcmFnZVtkaW1dOyAvLyBQRU5ESU5HIE5VTEwgaXMgZW1wdHkgb3IgemVyb1xuXG4gICAgICBkaW1TdG9yYWdlW2ldID0gZGltVmFsdWVHZXR0ZXIoZGF0YUl0ZW0sIGRpbSwgaSwgayk7XG4gICAgfVxuXG4gICAgaW5kaWNlcy5wdXNoKGkpO1xuICB9IC8vIFVzZSB0aGUgbmFtZSBpbiBvcHRpb24gYW5kIGNyZWF0ZSBpZFxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICB2YXIgZGF0YUl0ZW0gPSBkYXRhLmdldEl0ZW0oaSk7XG5cbiAgICBpZiAoIW5hbWVMaXN0W2ldICYmIGRhdGFJdGVtKSB7XG4gICAgICBpZiAoZGF0YUl0ZW0ubmFtZSAhPSBudWxsKSB7XG4gICAgICAgIG5hbWVMaXN0W2ldID0gZGF0YUl0ZW0ubmFtZTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZURpbUlkeCAhPSBudWxsKSB7XG4gICAgICAgIG5hbWVMaXN0W2ldID0gc3RvcmFnZVtkaW1lbnNpb25zW25hbWVEaW1JZHhdXVtpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IG5hbWVMaXN0W2ldIHx8ICcnOyAvLyBUcnkgdXNpbmcgdGhlIGlkIGluIG9wdGlvblxuXG4gICAgdmFyIGlkID0gZGF0YUl0ZW0gJiYgZGF0YUl0ZW0uaWQ7XG5cbiAgICBpZiAoIWlkICYmIG5hbWUpIHtcbiAgICAgIC8vIFVzZSBuYW1lIGFzIGlkIGFuZCBhZGQgY291bnRlciB0byBhdm9pZCBzYW1lIG5hbWVcbiAgICAgIG5hbWVSZXBlYXRDb3VudFtuYW1lXSA9IG5hbWVSZXBlYXRDb3VudFtuYW1lXSB8fCAwO1xuICAgICAgaWQgPSBuYW1lO1xuXG4gICAgICBpZiAobmFtZVJlcGVhdENvdW50W25hbWVdID4gMCkge1xuICAgICAgICBpZCArPSAnX19lY19fJyArIG5hbWVSZXBlYXRDb3VudFtuYW1lXTtcbiAgICAgIH1cblxuICAgICAgbmFtZVJlcGVhdENvdW50W25hbWVdKys7XG4gICAgfVxuXG4gICAgaWQgJiYgKGlkTGlzdFtpXSA9IGlkKTtcbiAgfVxuXG4gIHRoaXMuX25hbWVMaXN0ID0gbmFtZUxpc3Q7XG4gIHRoaXMuX2lkTGlzdCA9IGlkTGlzdDtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaW5kaWNlcy5sZW5ndGg7XG59O1xuLyoqXG4gKiBHZXQgdmFsdWUuIFJldHVybiBOYU4gaWYgaWR4IGlzIG91dCBvZiByYW5nZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW0gRGltIG11c3QgYmUgY29uY3JldGUgbmFtZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXQgPSBmdW5jdGlvbiAoZGltLCBpZHgsIHN0YWNrKSB7XG4gIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgdmFyIGRhdGFJbmRleCA9IHRoaXMuaW5kaWNlc1tpZHhdOyAvLyBJZiB2YWx1ZSBub3QgZXhpc3RzXG5cbiAgaWYgKGRhdGFJbmRleCA9PSBudWxsIHx8ICFzdG9yYWdlW2RpbV0pIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gc3RvcmFnZVtkaW1dW2RhdGFJbmRleF07IC8vIEZJWE1FIG9yZGluYWwgZGF0YSB0eXBlIGlzIG5vdCBzdGFja2FibGVcblxuICBpZiAoc3RhY2spIHtcbiAgICB2YXIgZGltZW5zaW9uSW5mbyA9IHRoaXMuX2RpbWVuc2lvbkluZm9zW2RpbV07XG5cbiAgICBpZiAoZGltZW5zaW9uSW5mbyAmJiBkaW1lbnNpb25JbmZvLnN0YWNrYWJsZSkge1xuICAgICAgdmFyIHN0YWNrZWRPbiA9IHRoaXMuc3RhY2tlZE9uO1xuXG4gICAgICB3aGlsZSAoc3RhY2tlZE9uKSB7XG4gICAgICAgIC8vIEdldCBubyBzdGFja2VkIGRhdGEgb2Ygc3RhY2tlZCBvblxuICAgICAgICB2YXIgc3RhY2tlZFZhbHVlID0gc3RhY2tlZE9uLmdldChkaW0sIGlkeCk7IC8vIENvbnNpZGVyaW5nIHBvc2l0aXZlIHN0YWNrLCBuZWdhdGl2ZSBzdGFjayBhbmQgZW1wdHkgZGF0YVxuXG4gICAgICAgIGlmICh2YWx1ZSA+PSAwICYmIHN0YWNrZWRWYWx1ZSA+IDAgfHwgLy8gUG9zaXRpdmUgc3RhY2tcbiAgICAgICAgdmFsdWUgPD0gMCAmJiBzdGFja2VkVmFsdWUgPCAwIC8vIE5lZ2F0aXZlIHN0YWNrXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFsdWUgKz0gc3RhY2tlZFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICBzdGFja2VkT24gPSBzdGFja2VkT24uc3RhY2tlZE9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIEdldCB2YWx1ZSBmb3IgbXVsdGkgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtkaW1lbnNpb25zXSBJZiBpZ25vcmVkLCB1c2luZyBhbGwgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgaWR4LCBzdGFjaykge1xuICB2YXIgdmFsdWVzID0gW107XG5cbiAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkge1xuICAgIHN0YWNrID0gaWR4O1xuICAgIGlkeCA9IGRpbWVuc2lvbnM7XG4gICAgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFsdWVzLnB1c2godGhpcy5nZXQoZGltZW5zaW9uc1tpXSwgaWR4LCBzdGFjaykpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn07XG4vKipcbiAqIElmIHZhbHVlIGlzIE5hTi4gSW5sY3VkaW5nICctJ1xuICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmhhc1ZhbHVlID0gZnVuY3Rpb24gKGlkeCkge1xuICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgdmFyIGRpbWVuc2lvbkluZm9zID0gdGhpcy5fZGltZW5zaW9uSW5mb3M7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpbWVuc2lvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIC8vIE9yZGluYWwgdHlwZSBjYW4gYmUgc3RyaW5nIG9yIG51bWJlclxuICAgIGRpbWVuc2lvbkluZm9zW2RpbWVuc2lvbnNbaV1dLnR5cGUgIT09ICdvcmRpbmFsJyAmJiBpc05hTih0aGlzLmdldChkaW1lbnNpb25zW2ldLCBpZHgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogR2V0IGV4dGVudCBvZiBkYXRhIGluIG9uZSBkaW1lbnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlclxuICovXG5cblxubGlzdFByb3RvLmdldERhdGFFeHRlbnQgPSBmdW5jdGlvbiAoZGltLCBzdGFjaywgZmlsdGVyKSB7XG4gIGRpbSA9IHRoaXMuZ2V0RGltZW5zaW9uKGRpbSk7XG4gIHZhciBkaW1EYXRhID0gdGhpcy5fc3RvcmFnZVtkaW1dO1xuICB2YXIgZGltSW5mbyA9IHRoaXMuZ2V0RGltZW5zaW9uSW5mbyhkaW0pO1xuICBzdGFjayA9IGRpbUluZm8gJiYgZGltSW5mby5zdGFja2FibGUgJiYgc3RhY2s7XG4gIHZhciBkaW1FeHRlbnQgPSAodGhpcy5fZXh0ZW50IHx8ICh0aGlzLl9leHRlbnQgPSB7fSkpW2RpbSArICEhc3RhY2tdO1xuICB2YXIgdmFsdWU7XG5cbiAgaWYgKGRpbUV4dGVudCkge1xuICAgIHJldHVybiBkaW1FeHRlbnQ7XG4gIH0gLy8gdmFyIGRpbUluZm8gPSB0aGlzLl9kaW1lbnNpb25JbmZvc1tkaW1dO1xuXG5cbiAgaWYgKGRpbURhdGEpIHtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTsgLy8gdmFyIGlzT3JkaW5hbCA9IGRpbUluZm8udHlwZSA9PT0gJ29yZGluYWwnO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0KGRpbSwgaSwgc3RhY2spOyAvLyBGSVhNRVxuICAgICAgLy8gaWYgKGlzT3JkaW5hbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAgICAgdmFsdWUgPSB6clV0aWwuaW5kZXhPZihkaW1EYXRhLCB2YWx1ZSk7XG4gICAgICAvLyB9XG5cbiAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcih2YWx1ZSwgZGltLCBpKSkge1xuICAgICAgICB2YWx1ZSA8IG1pbiAmJiAobWluID0gdmFsdWUpO1xuICAgICAgICB2YWx1ZSA+IG1heCAmJiAobWF4ID0gdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9leHRlbnRbZGltICsgISFzdGFja10gPSBbbWluLCBtYXhdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIH1cbn07XG4vKipcbiAqIEdldCBzdW0gb2YgZGF0YSBpbiBvbmUgZGltZW5zaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0U3VtID0gZnVuY3Rpb24gKGRpbSwgc3RhY2spIHtcbiAgdmFyIGRpbURhdGEgPSB0aGlzLl9zdG9yYWdlW2RpbV07XG4gIHZhciBzdW0gPSAwO1xuXG4gIGlmIChkaW1EYXRhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTtcblxuICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdW07XG59O1xuLyoqXG4gKiBSZXRyZWl2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbi8vIEZJWE1FIFByZWNpc2lvbiBvZiBmbG9hdCB2YWx1ZVxuXG5cbmxpc3RQcm90by5pbmRleE9mID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUpIHtcbiAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICB2YXIgZGltRGF0YSA9IHN0b3JhZ2VbZGltXTtcbiAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgaWYgKGRpbURhdGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHJhd0luZGV4ID0gaW5kaWNlc1tpXTtcblxuICAgICAgaWYgKGRpbURhdGFbcmF3SW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuLyoqXG4gKiBSZXRyZWl2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge251bWJlcn0gbmFtZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmluZGV4T2ZOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gIHZhciBuYW1lTGlzdCA9IHRoaXMuX25hbWVMaXN0O1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHJhd0luZGV4ID0gaW5kaWNlc1tpXTtcblxuICAgIGlmIChuYW1lTGlzdFtyYXdJbmRleF0gPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn07XG4vKipcbiAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIHJhdyBkYXRhIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge251bWJlcn0gbmFtZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmluZGV4T2ZSYXdJbmRleCA9IGZ1bmN0aW9uIChyYXdJbmRleCkge1xuICAvLyBJbmRpY2VzIGFyZSBhc2NlbmRpbmdcbiAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7IC8vIElmIHJhd0luZGV4ID09PSBkYXRhSW5kZXhcblxuICB2YXIgcmF3RGF0YUluZGV4ID0gaW5kaWNlc1tyYXdJbmRleF07XG5cbiAgaWYgKHJhd0RhdGFJbmRleCAhPSBudWxsICYmIHJhd0RhdGFJbmRleCA9PT0gcmF3SW5kZXgpIHtcbiAgICByZXR1cm4gcmF3SW5kZXg7XG4gIH1cblxuICB2YXIgbGVmdCA9IDA7XG4gIHZhciByaWdodCA9IGluZGljZXMubGVuZ3RoIC0gMTtcblxuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIHZhciBtaWQgPSAobGVmdCArIHJpZ2h0KSAvIDIgfCAwO1xuXG4gICAgaWYgKGluZGljZXNbbWlkXSA8IHJhd0luZGV4KSB7XG4gICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICB9IGVsc2UgaWYgKGluZGljZXNbbWlkXSA+IHJhd0luZGV4KSB7XG4gICAgICByaWdodCA9IG1pZCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogUmV0cmVpdmUgdGhlIGluZGV4IG9mIG5lYXJlc3QgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBzdGFjayBJZiBnaXZlbiB2YWx1ZSBpcyBhZnRlciBzdGFja2VkXG4gKiBAcGFyYW0ge251bWJlcn0gW21heERpc3RhbmNlPUluZmluaXR5XVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IENvbnNpZGVyZSBtdWx0aXBsZSBwb2ludHMgaGFzIHRoZSBzYW1lIHZhbHVlLlxuICovXG5cblxubGlzdFByb3RvLmluZGljZXNPZk5lYXJlc3QgPSBmdW5jdGlvbiAoZGltLCB2YWx1ZSwgc3RhY2ssIG1heERpc3RhbmNlKSB7XG4gIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgdmFyIGRpbURhdGEgPSBzdG9yYWdlW2RpbV07XG4gIHZhciBuZWFyZXN0SW5kaWNlcyA9IFtdO1xuXG4gIGlmICghZGltRGF0YSkge1xuICAgIHJldHVybiBuZWFyZXN0SW5kaWNlcztcbiAgfVxuXG4gIGlmIChtYXhEaXN0YW5jZSA9PSBudWxsKSB7XG4gICAgbWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgfVxuXG4gIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgdmFyIG1pbkRpZmYgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZGlmZiA9IHZhbHVlIC0gdGhpcy5nZXQoZGltLCBpLCBzdGFjayk7XG4gICAgdmFyIGRpc3QgPSBNYXRoLmFicyhkaWZmKTtcblxuICAgIGlmIChkaWZmIDw9IG1heERpc3RhbmNlICYmIGRpc3QgPD0gbWluRGlzdCkge1xuICAgICAgLy8gRm9yIHRoZSBjYXNlIG9mIHR3byBkYXRhIGFyZSBzYW1lIG9uIHhBeGlzLCB3aGljaCBoYXMgc2VxdWVuY2UgZGF0YS5cbiAgICAgIC8vIFNob3cgdGhlIG5lYXJlc3QgaW5kZXhcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvZWNoYXJ0cy9pc3N1ZXMvMjg2OVxuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0IHx8IGRpZmYgPj0gMCAmJiBtaW5EaWZmIDwgMCkge1xuICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgbWluRGlmZiA9IGRpZmY7XG4gICAgICAgIG5lYXJlc3RJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIG5lYXJlc3RJbmRpY2VzLnB1c2goaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lYXJlc3RJbmRpY2VzO1xufTtcbi8qKlxuICogR2V0IHJhdyBkYXRhIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0UmF3SW5kZXggPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHZhciByYXdJZHggPSB0aGlzLmluZGljZXNbaWR4XTtcbiAgcmV0dXJuIHJhd0lkeCA9PSBudWxsID8gLTEgOiByYXdJZHg7XG59O1xuLyoqXG4gKiBHZXQgcmF3IGRhdGEgaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmdldFJhd0RhdGFJdGVtID0gZnVuY3Rpb24gKGlkeCkge1xuICByZXR1cm4gdGhpcy5fcmF3RGF0YS5nZXRJdGVtKHRoaXMuZ2V0UmF3SW5kZXgoaWR4KSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtub3REZWZhdWx0SWR4PWZhbHNlXVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxubGlzdFByb3RvLmdldE5hbWUgPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHJldHVybiB0aGlzLl9uYW1lTGlzdFt0aGlzLmluZGljZXNbaWR4XV0gfHwgJyc7XG59O1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtub3REZWZhdWx0SWR4PWZhbHNlXVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxubGlzdFByb3RvLmdldElkID0gZnVuY3Rpb24gKGlkeCkge1xuICByZXR1cm4gdGhpcy5faWRMaXN0W3RoaXMuaW5kaWNlc1tpZHhdXSB8fCB0aGlzLmdldFJhd0luZGV4KGlkeCkgKyAnJztcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICBpZiAoIXpyVXRpbC5pc0FycmF5KGRpbWVuc2lvbnMpKSB7XG4gICAgZGltZW5zaW9ucyA9IFtkaW1lbnNpb25zXTtcbiAgfVxuXG4gIHJldHVybiBkaW1lbnNpb25zO1xufVxuLyoqXG4gKiBEYXRhIGl0ZXJhdGlvblxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gKlxuICogQGV4YW1wbGVcbiAqICBsaXN0LmVhY2goJ3gnLCBmdW5jdGlvbiAoeCwgaWR4KSB7fSk7XG4gKiAgbGlzdC5lYWNoKFsneCcsICd5J10sIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHt9KTtcbiAqICBsaXN0LmVhY2goZnVuY3Rpb24gKGlkeCkge30pXG4gKi9cblxuXG5saXN0UHJvdG8uZWFjaCA9IGZ1bmN0aW9uIChkaW1zLCBjYiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiBkaW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGV4dCA9IHN0YWNrO1xuICAgIHN0YWNrID0gY2I7XG4gICAgY2IgPSBkaW1zO1xuICAgIGRpbXMgPSBbXTtcbiAgfVxuXG4gIGRpbXMgPSB6clV0aWwubWFwKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltcyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzKTtcbiAgdmFyIHZhbHVlID0gW107XG4gIHZhciBkaW1TaXplID0gZGltcy5sZW5ndGg7XG4gIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICBzd2l0Y2ggKGRpbVNpemUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLmdldChkaW1zWzBdLCBpLCBzdGFjayksIGkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuZ2V0KGRpbXNbMF0sIGksIHN0YWNrKSwgdGhpcy5nZXQoZGltc1sxXSwgaSwgc3RhY2spLCBpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgICAgdmFsdWVba10gPSB0aGlzLmdldChkaW1zW2tdLCBpLCBzdGFjayk7XG4gICAgICAgIH0gLy8gSW5kZXhcblxuXG4gICAgICAgIHZhbHVlW2tdID0gaTtcbiAgICAgICAgY2IuYXBwbHkoY29udGV4dCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogRGF0YSBmaWx0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YWNrPWZhbHNlXVxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICovXG5cblxubGlzdFByb3RvLmZpbHRlclNlbGYgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgZGltZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRleHQgPSBzdGFjaztcbiAgICBzdGFjayA9IGNiO1xuICAgIGNiID0gZGltZW5zaW9ucztcbiAgICBkaW1lbnNpb25zID0gW107XG4gIH1cblxuICBkaW1lbnNpb25zID0genJVdGlsLm1hcChub3JtYWxpemVEaW1lbnNpb25zKGRpbWVuc2lvbnMpLCB0aGlzLmdldERpbWVuc2lvbiwgdGhpcyk7XG4gIHZhciBuZXdJbmRpY2VzID0gW107XG4gIHZhciB2YWx1ZSA9IFtdO1xuICB2YXIgZGltU2l6ZSA9IGRpbWVuc2lvbnMubGVuZ3RoO1xuICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2VlcDsgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuXG4gICAgaWYgKCFkaW1TaXplKSB7XG4gICAgICBrZWVwID0gY2IuY2FsbChjb250ZXh0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGRpbVNpemUgPT09IDEpIHtcbiAgICAgIGtlZXAgPSBjYi5jYWxsKGNvbnRleHQsIHRoaXMuZ2V0KGRpbWVuc2lvbnNbMF0sIGksIHN0YWNrKSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgIHZhbHVlW2tdID0gdGhpcy5nZXQoZGltZW5zaW9uc1trXSwgaSwgc3RhY2spO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZVtrXSA9IGk7XG4gICAgICBrZWVwID0gY2IuYXBwbHkoY29udGV4dCwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChrZWVwKSB7XG4gICAgICBuZXdJbmRpY2VzLnB1c2goaW5kaWNlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5pbmRpY2VzID0gbmV3SW5kaWNlczsgLy8gUmVzZXQgZGF0YSBleHRlbnRcblxuICB0aGlzLl9leHRlbnQgPSB7fTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBEYXRhIG1hcHBpbmcgdG8gYSBwbGFpbiBhcnJheVxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtkaW1lbnNpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YWNrPWZhbHNlXVxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5saXN0UHJvdG8ubWFwQXJyYXkgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgZGltZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRleHQgPSBzdGFjaztcbiAgICBzdGFjayA9IGNiO1xuICAgIGNiID0gZGltZW5zaW9ucztcbiAgICBkaW1lbnNpb25zID0gW107XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHRoaXMuZWFjaChkaW1lbnNpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgcmVzdWx0LnB1c2goY2IgJiYgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0sIHN0YWNrLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZShvcmlnaW5hbCwgZXhjbHVkZURpbWVuc2lvbnMpIHtcbiAgdmFyIGFsbERpbWVuc2lvbnMgPSBvcmlnaW5hbC5kaW1lbnNpb25zO1xuICB2YXIgbGlzdCA9IG5ldyBMaXN0KHpyVXRpbC5tYXAoYWxsRGltZW5zaW9ucywgb3JpZ2luYWwuZ2V0RGltZW5zaW9uSW5mbywgb3JpZ2luYWwpLCBvcmlnaW5hbC5ob3N0TW9kZWwpOyAvLyBGSVhNRSBJZiBuZWVkcyBzdGFja2VkT24sIHZhbHVlIG1heSBhbHJlYWR5IGJlZW4gc3RhY2tlZFxuXG4gIHRyYW5zZmVyUHJvcGVydGllcyhsaXN0LCBvcmlnaW5hbCk7XG4gIHZhciBzdG9yYWdlID0gbGlzdC5fc3RvcmFnZSA9IHt9O1xuICB2YXIgb3JpZ2luYWxTdG9yYWdlID0gb3JpZ2luYWwuX3N0b3JhZ2U7IC8vIEluaXQgc3RvcmFnZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaW0gPSBhbGxEaW1lbnNpb25zW2ldO1xuICAgIHZhciBkaW1TdG9yZSA9IG9yaWdpbmFsU3RvcmFnZVtkaW1dO1xuXG4gICAgaWYgKHpyVXRpbC5pbmRleE9mKGV4Y2x1ZGVEaW1lbnNpb25zLCBkaW0pID49IDApIHtcbiAgICAgIHN0b3JhZ2VbZGltXSA9IG5ldyBkaW1TdG9yZS5jb25zdHJ1Y3RvcihvcmlnaW5hbFN0b3JhZ2VbZGltXS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEaXJlY3QgcmVmZXJlbmNlIGZvciBvdGhlciBkaW1lbnNpb25zXG4gICAgICBzdG9yYWdlW2RpbV0gPSBvcmlnaW5hbFN0b3JhZ2VbZGltXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogRGF0YSBtYXBwaW5nIHRvIGEgbmV3IExpc3Qgd2l0aCBnaXZlbiBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gZGltZW5zaW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YWNrPWZhbHNlXVxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5saXN0UHJvdG8ubWFwID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGNiLCBzdGFjaywgY29udGV4dCkge1xuICBkaW1lbnNpb25zID0genJVdGlsLm1hcChub3JtYWxpemVEaW1lbnNpb25zKGRpbWVuc2lvbnMpLCB0aGlzLmdldERpbWVuc2lvbiwgdGhpcyk7XG4gIHZhciBsaXN0ID0gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKHRoaXMsIGRpbWVuc2lvbnMpOyAvLyBGb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgYWxsIGltbXV0YWJsZS5cbiAgLy8gU28gd2UgY2FuIHJlZmVyZW5jZSB0byB0aGUgc2FtZSB2YWx1ZVxuXG4gIHZhciBpbmRpY2VzID0gbGlzdC5pbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICB2YXIgc3RvcmFnZSA9IGxpc3QuX3N0b3JhZ2U7XG4gIHZhciB0bXBSZXRWYWx1ZSA9IFtdO1xuICB0aGlzLmVhY2goZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciByZXRWYWx1ZSA9IGNiICYmIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAocmV0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gYSBudW1iZXJcbiAgICAgIGlmICh0eXBlb2YgcmV0VmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRtcFJldFZhbHVlWzBdID0gcmV0VmFsdWU7XG4gICAgICAgIHJldFZhbHVlID0gdG1wUmV0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNbaV07XG4gICAgICAgIHZhciBkaW1TdG9yZSA9IHN0b3JhZ2VbZGltXTtcbiAgICAgICAgdmFyIHJhd0lkeCA9IGluZGljZXNbaWR4XTtcblxuICAgICAgICBpZiAoZGltU3RvcmUpIHtcbiAgICAgICAgICBkaW1TdG9yZVtyYXdJZHhdID0gcmV0VmFsdWVbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHN0YWNrLCBjb250ZXh0KTtcbiAgcmV0dXJuIGxpc3Q7XG59O1xuLyoqXG4gKiBMYXJnZSBkYXRhIGRvd24gc2FtcGxpbmcgb24gZ2l2ZW4gZGltZW5zaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2FtcGxlVmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNhbXBsZUluZGV4IFNhbXBsZSBpbmRleCBmb3IgbmFtZSBhbmQgaWRcbiAqL1xuXG5cbmxpc3RQcm90by5kb3duU2FtcGxlID0gZnVuY3Rpb24gKGRpbWVuc2lvbiwgcmF0ZSwgc2FtcGxlVmFsdWUsIHNhbXBsZUluZGV4KSB7XG4gIHZhciBsaXN0ID0gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKHRoaXMsIFtkaW1lbnNpb25dKTtcbiAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICB2YXIgdGFyZ2V0U3RvcmFnZSA9IGxpc3QuX3N0b3JhZ2U7XG4gIHZhciBvcmlnaW5hbEluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gIHZhciBpbmRpY2VzID0gbGlzdC5pbmRpY2VzID0gW107XG4gIHZhciBmcmFtZVZhbHVlcyA9IFtdO1xuICB2YXIgZnJhbWVJbmRpY2VzID0gW107XG4gIHZhciBmcmFtZVNpemUgPSBNYXRoLmZsb29yKDEgLyByYXRlKTtcbiAgdmFyIGRpbVN0b3JlID0gdGFyZ2V0U3RvcmFnZVtkaW1lbnNpb25dO1xuICB2YXIgbGVuID0gdGhpcy5jb3VudCgpOyAvLyBDb3B5IGRhdGEgZnJvbSBvcmlnaW5hbCBkYXRhXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yYWdlW2RpbWVuc2lvbl0ubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRTdG9yYWdlW2RpbWVuc2lvbl1baV0gPSBzdG9yYWdlW2RpbWVuc2lvbl1baV07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSBmcmFtZVNpemUpIHtcbiAgICAvLyBMYXN0IGZyYW1lXG4gICAgaWYgKGZyYW1lU2l6ZSA+IGxlbiAtIGkpIHtcbiAgICAgIGZyYW1lU2l6ZSA9IGxlbiAtIGk7XG4gICAgICBmcmFtZVZhbHVlcy5sZW5ndGggPSBmcmFtZVNpemU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBmcmFtZVNpemU7IGsrKykge1xuICAgICAgdmFyIGlkeCA9IG9yaWdpbmFsSW5kaWNlc1tpICsga107XG4gICAgICBmcmFtZVZhbHVlc1trXSA9IGRpbVN0b3JlW2lkeF07XG4gICAgICBmcmFtZUluZGljZXNba10gPSBpZHg7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gc2FtcGxlVmFsdWUoZnJhbWVWYWx1ZXMpO1xuICAgIHZhciBpZHggPSBmcmFtZUluZGljZXNbc2FtcGxlSW5kZXgoZnJhbWVWYWx1ZXMsIHZhbHVlKSB8fCAwXTsgLy8gT25seSB3cml0ZSB2YWx1ZSBvbiB0aGUgZmlsdGVyZWQgZGF0YVxuXG4gICAgZGltU3RvcmVbaWR4XSA9IHZhbHVlO1xuICAgIGluZGljZXMucHVzaChpZHgpO1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuLyoqXG4gKiBHZXQgbW9kZWwgb2Ygb25lIGRhdGEgaXRlbS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKi9cbi8vIEZJWE1FIE1vZGVsIHByb3h5ID9cblxuXG5saXN0UHJvdG8uZ2V0SXRlbU1vZGVsID0gZnVuY3Rpb24gKGlkeCkge1xuICB2YXIgaG9zdE1vZGVsID0gdGhpcy5ob3N0TW9kZWw7XG4gIGlkeCA9IHRoaXMuaW5kaWNlc1tpZHhdO1xuICByZXR1cm4gbmV3IE1vZGVsKHRoaXMuX3Jhd0RhdGEuZ2V0SXRlbShpZHgpLCBob3N0TW9kZWwsIGhvc3RNb2RlbCAmJiBob3N0TW9kZWwuZWNNb2RlbCk7XG59O1xuLyoqXG4gKiBDcmVhdGUgYSBkYXRhIGRpZmZlclxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IG90aGVyTGlzdFxuICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9EYXRhRGlmZmVyfVxuICovXG5cblxubGlzdFByb3RvLmRpZmYgPSBmdW5jdGlvbiAob3RoZXJMaXN0KSB7XG4gIHZhciBpZExpc3QgPSB0aGlzLl9pZExpc3Q7XG4gIHZhciBvdGhlcklkTGlzdCA9IG90aGVyTGlzdCAmJiBvdGhlckxpc3QuX2lkTGlzdDtcbiAgdmFyIHZhbDsgLy8gVXNlIHByZWZpeCB0byBhdm9pZCBpbmRleCB0byBiZSB0aGUgc2FtZSBhcyBvdGhlcklkTGlzdFtpZHhdLFxuICAvLyB3aGljaCB3aWxsIGNhdXNlIHdlaXJkIHVkcGF0ZSBhbmltYXRpb24uXG5cbiAgdmFyIHByZWZpeCA9ICdlXFwwXFwwJztcbiAgcmV0dXJuIG5ldyBEYXRhRGlmZmVyKG90aGVyTGlzdCA/IG90aGVyTGlzdC5pbmRpY2VzIDogW10sIHRoaXMuaW5kaWNlcywgZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiAodmFsID0gb3RoZXJJZExpc3RbaWR4XSkgIT0gbnVsbCA/IHZhbCA6IHByZWZpeCArIGlkeDtcbiAgfSwgZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiAodmFsID0gaWRMaXN0W2lkeF0pICE9IG51bGwgPyB2YWwgOiBwcmVmaXggKyBpZHg7XG4gIH0pO1xufTtcbi8qKlxuICogR2V0IHZpc3VhbCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5cbmxpc3RQcm90by5nZXRWaXN1YWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB2aXN1YWwgPSB0aGlzLl92aXN1YWw7XG4gIHJldHVybiB2aXN1YWwgJiYgdmlzdWFsW2tleV07XG59O1xuLyoqXG4gKiBTZXQgdmlzdWFsIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gKlxuICogQGV4YW1wbGVcbiAqICBzZXRWaXN1YWwoJ2NvbG9yJywgY29sb3IpO1xuICogIHNldFZpc3VhbCh7XG4gKiAgICAgICdjb2xvcic6IGNvbG9yXG4gKiAgfSk7XG4gKi9cblxuXG5saXN0UHJvdG8uc2V0VmlzdWFsID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdGhpcy5zZXRWaXN1YWwobmFtZSwga2V5W25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl92aXN1YWwgPSB0aGlzLl92aXN1YWwgfHwge307XG4gIHRoaXMuX3Zpc3VhbFtrZXldID0gdmFsO1xufTtcbi8qKlxuICogU2V0IGxheW91dCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gKiBAcGFyYW0geyp9IFt2YWxdXG4gKi9cblxuXG5saXN0UHJvdG8uc2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdGhpcy5zZXRMYXlvdXQobmFtZSwga2V5W25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9sYXlvdXRba2V5XSA9IHZhbDtcbn07XG4vKipcbiAqIEdldCBsYXlvdXQgcHJvcGVydHkuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleS5cbiAqIEByZXR1cm4geyp9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gdGhpcy5fbGF5b3V0W2tleV07XG59O1xuLyoqXG4gKiBHZXQgbGF5b3V0IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqL1xuXG5cbmxpc3RQcm90by5nZXRJdGVtTGF5b3V0ID0gZnVuY3Rpb24gKGlkeCkge1xuICByZXR1cm4gdGhpcy5faXRlbUxheW91dHNbaWR4XTtcbn07XG4vKipcbiAqIFNldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtPYmplY3R9IGxheW91dFxuICogQHBhcmFtIHtib29sZWFuPX0gW21lcmdlPWZhbHNlXVxuICovXG5cblxubGlzdFByb3RvLnNldEl0ZW1MYXlvdXQgPSBmdW5jdGlvbiAoaWR4LCBsYXlvdXQsIG1lcmdlKSB7XG4gIHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF0gPSBtZXJnZSA/IHpyVXRpbC5leHRlbmQodGhpcy5faXRlbUxheW91dHNbaWR4XSB8fCB7fSwgbGF5b3V0KSA6IGxheW91dDtcbn07XG4vKipcbiAqIENsZWFyIGFsbCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICovXG5cblxubGlzdFByb3RvLmNsZWFySXRlbUxheW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2l0ZW1MYXlvdXRzLmxlbmd0aCA9IDA7XG59O1xuLyoqXG4gKiBHZXQgdmlzdWFsIHByb3BlcnR5IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVBhcmVudD1mYWxzZV1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRJdGVtVmlzdWFsID0gZnVuY3Rpb24gKGlkeCwga2V5LCBpZ25vcmVQYXJlbnQpIHtcbiAgdmFyIGl0ZW1WaXN1YWwgPSB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdO1xuICB2YXIgdmFsID0gaXRlbVZpc3VhbCAmJiBpdGVtVmlzdWFsW2tleV07XG5cbiAgaWYgKHZhbCA9PSBudWxsICYmICFpZ25vcmVQYXJlbnQpIHtcbiAgICAvLyBVc2UgZ2xvYmFsIHZpc3VhbCBwcm9wZXJ0eVxuICAgIHJldHVybiB0aGlzLmdldFZpc3VhbChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG4vKipcbiAqIFNldCB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gKiBAcGFyYW0geyp9IFt2YWx1ZV1cbiAqXG4gKiBAZXhhbXBsZVxuICogIHNldEl0ZW1WaXN1YWwoMCwgJ2NvbG9yJywgY29sb3IpO1xuICogIHNldEl0ZW1WaXN1YWwoMCwge1xuICogICAgICAnY29sb3InOiBjb2xvclxuICogIH0pO1xuICovXG5cblxubGlzdFByb3RvLnNldEl0ZW1WaXN1YWwgPSBmdW5jdGlvbiAoaWR4LCBrZXksIHZhbHVlKSB7XG4gIHZhciBpdGVtVmlzdWFsID0gdGhpcy5faXRlbVZpc3VhbHNbaWR4XSB8fCB7fTtcbiAgdGhpcy5faXRlbVZpc3VhbHNbaWR4XSA9IGl0ZW1WaXN1YWw7XG5cbiAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBpdGVtVmlzdWFsW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGl0ZW1WaXN1YWxba2V5XSA9IHZhbHVlO1xufTtcbi8qKlxuICogQ2xlYXIgaXRlbVZpc3VhbHMgYW5kIGxpc3QgdmlzdWFsLlxuICovXG5cblxubGlzdFByb3RvLmNsZWFyQWxsVmlzdWFsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl92aXN1YWwgPSB7fTtcbiAgdGhpcy5faXRlbVZpc3VhbHMgPSBbXTtcbn07XG5cbnZhciBzZXRJdGVtRGF0YUFuZFNlcmllc0luZGV4ID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gIGNoaWxkLnNlcmllc0luZGV4ID0gdGhpcy5zZXJpZXNJbmRleDtcbiAgY2hpbGQuZGF0YUluZGV4ID0gdGhpcy5kYXRhSW5kZXg7XG4gIGNoaWxkLmRhdGFUeXBlID0gdGhpcy5kYXRhVHlwZTtcbn07XG4vKipcbiAqIFNldCBncmFwaGljIGVsZW1lbnQgcmVsYXRpdmUgdG8gZGF0YS4gSXQgY2FuIGJlIHNldCBhcyBudWxsXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IFtlbF1cbiAqL1xuXG5cbmxpc3RQcm90by5zZXRJdGVtR3JhcGhpY0VsID0gZnVuY3Rpb24gKGlkeCwgZWwpIHtcbiAgdmFyIGhvc3RNb2RlbCA9IHRoaXMuaG9zdE1vZGVsO1xuXG4gIGlmIChlbCkge1xuICAgIC8vIEFkZCBkYXRhIGluZGV4IGFuZCBzZXJpZXMgaW5kZXggZm9yIGluZGV4aW5nIHRoZSBkYXRhIGJ5IGVsZW1lbnRcbiAgICAvLyBVc2VmdWwgaW4gdG9vbHRpcFxuICAgIGVsLmRhdGFJbmRleCA9IGlkeDtcbiAgICBlbC5kYXRhVHlwZSA9IHRoaXMuZGF0YVR5cGU7XG4gICAgZWwuc2VyaWVzSW5kZXggPSBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLnNlcmllc0luZGV4O1xuXG4gICAgaWYgKGVsLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgIGVsLnRyYXZlcnNlKHNldEl0ZW1EYXRhQW5kU2VyaWVzSW5kZXgsIGVsKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9ncmFwaGljRWxzW2lkeF0gPSBlbDtcbn07XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0SXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgcmV0dXJuIHRoaXMuX2dyYXBoaWNFbHNbaWR4XTtcbn07XG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqL1xuXG5cbmxpc3RQcm90by5lYWNoSXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICB6clV0aWwuZWFjaCh0aGlzLl9ncmFwaGljRWxzLCBmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgIGlmIChlbCkge1xuICAgICAgY2IgJiYgY2IuY2FsbChjb250ZXh0LCBlbCwgaWR4KTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogU2hhbGxvdyBjbG9uZSBhIG5ldyBsaXN0IGV4Y2VwdCB2aXN1YWwgYW5kIGxheW91dCBwcm9wZXJ0aWVzLCBhbmQgZ3JhcGggZWxlbWVudHMuXG4gKiBOZXcgbGlzdCBvbmx5IGNoYW5nZSB0aGUgaW5kaWNlcy5cbiAqL1xuXG5cbmxpc3RQcm90by5jbG9uZVNoYWxsb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkaW1lbnNpb25JbmZvTGlzdCA9IHpyVXRpbC5tYXAodGhpcy5kaW1lbnNpb25zLCB0aGlzLmdldERpbWVuc2lvbkluZm8sIHRoaXMpO1xuICB2YXIgbGlzdCA9IG5ldyBMaXN0KGRpbWVuc2lvbkluZm9MaXN0LCB0aGlzLmhvc3RNb2RlbCk7IC8vIEZJWE1FXG5cbiAgbGlzdC5fc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gIHRyYW5zZmVyUHJvcGVydGllcyhsaXN0LCB0aGlzKTsgLy8gQ2xvbmUgd2lsbCBub3QgY2hhbmdlIHRoZSBkYXRhIGV4dGVudCBhbmQgaW5kaWNlc1xuXG4gIGxpc3QuaW5kaWNlcyA9IHRoaXMuaW5kaWNlcy5zbGljZSgpO1xuXG4gIGlmICh0aGlzLl9leHRlbnQpIHtcbiAgICBsaXN0Ll9leHRlbnQgPSB6clV0aWwuZXh0ZW5kKHt9LCB0aGlzLl9leHRlbnQpO1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuLyoqXG4gKiBXcmFwIHNvbWUgbWV0aG9kIHRvIGFkZCBtb3JlIGZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbmplY3RGdW5jdGlvblxuICovXG5cblxubGlzdFByb3RvLndyYXBNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5qZWN0RnVuY3Rpb24pIHtcbiAgdmFyIG9yaWdpbmFsTWV0aG9kID0gdGhpc1ttZXRob2ROYW1lXTtcblxuICBpZiAodHlwZW9mIG9yaWdpbmFsTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fX3dyYXBwZWRNZXRob2RzID0gdGhpcy5fX3dyYXBwZWRNZXRob2RzIHx8IFtdO1xuXG4gIHRoaXMuX193cmFwcGVkTWV0aG9kcy5wdXNoKG1ldGhvZE5hbWUpO1xuXG4gIHRoaXNbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcyA9IG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGluamVjdEZ1bmN0aW9uLmFwcGx5KHRoaXMsIFtyZXNdLmNvbmNhdCh6clV0aWwuc2xpY2UoYXJndW1lbnRzKSkpO1xuICB9O1xufTsgLy8gTWV0aG9kcyB0aGF0IGNyZWF0ZSBhIG5ldyBsaXN0IGJhc2VkIG9uIHRoaXMgbGlzdCBzaG91bGQgYmUgbGlzdGVkIGhlcmUuXG4vLyBOb3RpY2UgdGhhdCB0aG9zZSBtZXRob2Qgc2hvdWxkIGBSRVRVUk5gIHRoZSBuZXcgbGlzdC5cblxuXG5saXN0UHJvdG8uVFJBTlNGRVJBQkxFX01FVEhPRFMgPSBbJ2Nsb25lU2hhbGxvdycsICdkb3duU2FtcGxlJywgJ21hcCddOyAvLyBNZXRob2RzIHRoYXQgY2hhbmdlIGluZGljZXMgb2YgdGhpcyBsaXN0IHNob3VsZCBiZSBsaXN0ZWQgaGVyZS5cblxubGlzdFByb3RvLkNIQU5HQUJMRV9NRVRIT0RTID0gWydmaWx0ZXJTZWxmJ107XG52YXIgX2RlZmF1bHQgPSBMaXN0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL0xpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBjbGF6elV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9jbGF6elwiKTtcblxuLyoqXG4gKiAvLyBTY2FsZSBjbGFzcyBtYW5hZ2VtZW50XG4gKiBAbW9kdWxlIGVjaGFydHMvc2NhbGUvU2NhbGVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2V0dGluZ11cbiAqL1xuZnVuY3Rpb24gU2NhbGUoc2V0dGluZykge1xuICB0aGlzLl9zZXR0aW5nID0gc2V0dGluZyB8fCB7fTtcbiAgLyoqXG4gICAqIEV4dGVudFxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgdGhpcy5fZXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAvKipcbiAgICogU3RlcCBpcyBjYWxjdWxhdGVkIGluIGFkanVzdEV4dGVudFxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgdGhpcy5faW50ZXJ2YWwgPSAwO1xuICB0aGlzLmluaXQgJiYgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFBhcnNlIGlucHV0IHZhbCB0byB2YWxpZCBpbm5lciBudW1iZXIuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHZhbCkge1xuICAvLyBOb3RpY2U6IFRoaXMgd291bGQgYmUgYSB0cmFwIGhlcmUsIElmIHRoZSBpbXBsZW1lbnRhdGlvblxuICAvLyBvZiB0aGlzIG1ldGhvZCBkZXBlbmRzIG9uIGV4dGVudCwgYW5kIHRoaXMgbWV0aG9kIGlzIHVzZWRcbiAgLy8gYmVmb3JlIGV4dGVudCBzZXQgKGxpa2UgaW4gZGF0YVpvb20pLCBpdCB3b3VsZCBiZSB3cm9uZy5cbiAgLy8gTmV2ZXJ0aGVsZXNzLCBwYXJzZSBkb2VzIG5vdCBkZXBlbmQgb24gZXh0ZW50IGdlbmVyYWxseS5cbiAgcmV0dXJuIHZhbDtcbn07XG5cblNjYWxlLnByb3RvdHlwZS5nZXRTZXR0aW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX3NldHRpbmdbbmFtZV07XG59O1xuXG5TY2FsZS5wcm90b3R5cGUuY29udGFpbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgcmV0dXJuIHZhbCA+PSBleHRlbnRbMF0gJiYgdmFsIDw9IGV4dGVudFsxXTtcbn07XG4vKipcbiAqIE5vcm1hbGl6ZSB2YWx1ZSB0byBsaW5lYXIgWzAsIDFdLCByZXR1cm4gMC41IGlmIGV4dGVudCBzcGFuIGlzIDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG5cbiAgaWYgKGV4dGVudFsxXSA9PT0gZXh0ZW50WzBdKSB7XG4gICAgcmV0dXJuIDAuNTtcbiAgfVxuXG4gIHJldHVybiAodmFsIC0gZXh0ZW50WzBdKSAvIChleHRlbnRbMV0gLSBleHRlbnRbMF0pO1xufTtcbi8qKlxuICogU2NhbGUgbm9ybWFsaXplZCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHZhbCkge1xuICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICByZXR1cm4gdmFsICogKGV4dGVudFsxXSAtIGV4dGVudFswXSkgKyBleHRlbnRbMF07XG59O1xuLyoqXG4gKiBTZXQgZXh0ZW50IGZyb20gZGF0YVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3RoZXJcbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS51bmlvbkV4dGVudCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICBvdGhlclsxXSA+IGV4dGVudFsxXSAmJiAoZXh0ZW50WzFdID0gb3RoZXJbMV0pOyAvLyBub3Qgc2V0RXh0ZW50IGJlY2F1c2UgaW4gbG9nIGF4aXMgaXQgbWF5IHRyYW5zZm9ybWVkIHRvIHBvd2VyXG4gIC8vIHRoaXMuc2V0RXh0ZW50KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbn07XG4vKipcbiAqIFNldCBleHRlbnQgZnJvbSBkYXRhXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLnVuaW9uRXh0ZW50RnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXREYXRhRXh0ZW50KGRpbSwgdHJ1ZSkpO1xufTtcbi8qKlxuICogR2V0IGV4dGVudFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG5TY2FsZS5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZXh0ZW50LnNsaWNlKCk7XG59O1xuLyoqXG4gKiBTZXQgZXh0ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS5zZXRFeHRlbnQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgdGhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDtcblxuICBpZiAoIWlzTmFOKHN0YXJ0KSkge1xuICAgIHRoaXNFeHRlbnRbMF0gPSBzdGFydDtcbiAgfVxuXG4gIGlmICghaXNOYU4oZW5kKSkge1xuICAgIHRoaXNFeHRlbnRbMV0gPSBlbmQ7XG4gIH1cbn07XG4vKipcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLmdldFRpY2tzTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGFiZWxzID0gW107XG4gIHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGFiZWxzLnB1c2godGhpcy5nZXRMYWJlbCh0aWNrc1tpXSkpO1xuICB9XG5cbiAgcmV0dXJuIGxhYmVscztcbn07XG4vKipcbiAqIFdoZW4gYXhpcyBleHRlbnQgZGVwZW5kcyBvbiBkYXRhIGFuZCBubyBkYXRhIGV4aXN0cyxcbiAqIGF4aXMgdGlja3Mgc2hvdWxkIG5vdCBiZSBkcmF3biwgd2hpY2ggaXMgbmFtZWQgJ2JsYW5rJy5cbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS5pc0JsYW5rID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faXNCbGFuaztcbn0sXG4vKipcbiAqIFdoZW4gYXhpcyBleHRlbnQgZGVwZW5kcyBvbiBkYXRhIGFuZCBubyBkYXRhIGV4aXN0cyxcbiAqIGF4aXMgdGlja3Mgc2hvdWxkIG5vdCBiZSBkcmF3biwgd2hpY2ggaXMgbmFtZWQgJ2JsYW5rJy5cbiAqL1xuU2NhbGUucHJvdG90eXBlLnNldEJsYW5rID0gZnVuY3Rpb24gKGlzQmxhbmspIHtcbiAgdGhpcy5faXNCbGFuayA9IGlzQmxhbms7XG59O1xuY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKFNjYWxlKTtcbmNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoU2NhbGUsIHtcbiAgcmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlXG59KTtcbnZhciBfZGVmYXVsdCA9IFNjYWxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9TY2FsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTsgLy8gQnVpbGQgYXhpc1BvaW50ZXJNb2RlbCwgbWVyZ2luIHRvb2x0aXAuYXhpc1BvaW50ZXIgbW9kZWwgZm9yIGVhY2ggYXhpcy5cbi8vIGFsbEF4ZXNJbmZvIHNob3VsZCBiZSB1cGRhdGVkIHdoZW4gc2V0T3B0aW9uIHBlcmZvcm1lZC5cblxuZnVuY3Rpb24gY29sbGVjdChlY01vZGVsLCBhcGkpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICAvKipcbiAgICAgKiBrZXk6IG1ha2VLZXkoYXhpcy5tb2RlbClcbiAgICAgKiB2YWx1ZToge1xuICAgICAqICAgICAgYXhpcyxcbiAgICAgKiAgICAgIGNvb3JkU3lzLFxuICAgICAqICAgICAgYXhpc1BvaW50ZXJNb2RlbCxcbiAgICAgKiAgICAgIHRyaWdnZXJUb29sdGlwLFxuICAgICAqICAgICAgaW52b2x2ZVNlcmllcyxcbiAgICAgKiAgICAgIHNuYXAsXG4gICAgICogICAgICBzZXJpZXNNb2RlbHMsXG4gICAgICogICAgICBzZXJpZXNEYXRhQ291bnRcbiAgICAgKiB9XG4gICAgICovXG4gICAgYXhlc0luZm86IHt9LFxuICAgIHNlcmllc0ludm9sdmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGtleTogbWFrZUtleShjb29yZFN5cy5tb2RlbClcbiAgICAgKiB2YWx1ZTogT2JqZWN0OiBrZXkgbWFrZUtleShheGlzLm1vZGVsKSwgdmFsdWU6IGF4aXNJbmZvXG4gICAgICovXG4gICAgY29vcmRTeXNBeGVzSW5mbzoge30sXG4gICAgY29vcmRTeXNNYXA6IHt9XG4gIH07XG4gIGNvbGxlY3RBeGVzSW5mbyhyZXN1bHQsIGVjTW9kZWwsIGFwaSk7IC8vIENoZWNrIHNlcmllc0ludm9sdmVkIGZvciBwZXJmb3JtYW5jZSwgaW4gY2FzZSB0b28gbWFueSBzZXJpZXMgaW4gc29tZSBjaGFydC5cblxuICByZXN1bHQuc2VyaWVzSW52b2x2ZWQgJiYgY29sbGVjdFNlcmllc0luZm8ocmVzdWx0LCBlY01vZGVsKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY29sbGVjdEF4ZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBnbG9iYWxUb29sdGlwTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgndG9vbHRpcCcpO1xuICB2YXIgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpOyAvLyBsaW5rcyBjYW4gb25seSBiZSBzZXQgb24gZ2xvYmFsLlxuXG4gIHZhciBsaW5rc09wdGlvbiA9IGdsb2JhbEF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsaW5rJywgdHJ1ZSkgfHwgW107XG4gIHZhciBsaW5rR3JvdXBzID0gW107IC8vIENvbGxlY3QgYXhlcyBpbmZvLlxuXG4gIGVhY2goYXBpLmdldENvb3JkaW5hdGVTeXN0ZW1zKCksIGZ1bmN0aW9uIChjb29yZFN5cykge1xuICAgIC8vIFNvbWUgY29vcmRpbmF0ZSBzeXN0ZW0gZG8gbm90IHN1cHBvcnQgYXhlcywgbGlrZSBnZW8uXG4gICAgaWYgKCFjb29yZFN5cy5heGlzUG9pbnRlckVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29vcmRTeXNLZXkgPSBtYWtlS2V5KGNvb3JkU3lzLm1vZGVsKTtcbiAgICB2YXIgYXhlc0luZm9JbkNvb3JkU3lzID0gcmVzdWx0LmNvb3JkU3lzQXhlc0luZm9bY29vcmRTeXNLZXldID0ge307XG4gICAgcmVzdWx0LmNvb3JkU3lzTWFwW2Nvb3JkU3lzS2V5XSA9IGNvb3JkU3lzOyAvLyBTZXQgdG9vbHRpcCAobGlrZSAnY3Jvc3MnKSBpcyBhIGNvbnZpZW5lbnQgd2F5IHRvIHNob3cgYXhpc1BvaW50ZXJcbiAgICAvLyBmb3IgdXNlci4gU28gd2UgZW5hYmxlIHNldGluZyB0b29sdGlwIG9uIGNvb3JkU3lzIG1vZGVsLlxuXG4gICAgdmFyIGNvb3JkU3lzTW9kZWwgPSBjb29yZFN5cy5tb2RlbDtcbiAgICB2YXIgYmFzZVRvb2x0aXBNb2RlbCA9IGNvb3JkU3lzTW9kZWwuZ2V0TW9kZWwoJ3Rvb2x0aXAnLCBnbG9iYWxUb29sdGlwTW9kZWwpO1xuICAgIGVhY2goY29vcmRTeXMuZ2V0QXhlcygpLCBjdXJyeShzYXZlVG9vbHRpcEF4aXNJbmZvLCBmYWxzZSwgbnVsbCkpOyAvLyBJZiBheGlzIHRvb2x0aXAgdXNlZCwgY2hvb3NlIHRvb2x0aXAgYXhpcyBmb3IgZWFjaCBjb29yZFN5cy5cbiAgICAvLyBOb3RpY2UgdGhpcyBjYXNlOiBjb29yZFN5cyBpcyBgZ3JpZGAgYnV0IG5vdCBgY2FydGVzaWFuMkRgIGhlcmUuXG5cbiAgICBpZiAoY29vcmRTeXMuZ2V0VG9vbHRpcEF4ZXMgJiYgZ2xvYmFsVG9vbHRpcE1vZGVsIC8vIElmIHRvb2x0aXAuc2hvd0NvbnRlbnQgaXMgc2V0IGFzIGZhbHNlLCB0b29sdGlwIHdpbGwgbm90XG4gICAgLy8gc2hvdyBidXQgYXhpc1BvaW50ZXIgd2lsbCBzaG93IGFzIG5vcm1hbC5cbiAgICAmJiBiYXNlVG9vbHRpcE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAvLyBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgbG9naWMuIEJ1dCBzZXJpZXMudG9vbHRpcC50cmlnZ2VyOiAnYXhpcydcbiAgICAgIC8vIG9yIHNlcmllcy5kYXRhW25dLnRvb2x0aXAudHJpZ2dlcjogJ2F4aXMnIGFyZSBub3Qgc3VwcG9ydCBhbnkgbW9yZS5cbiAgICAgIHZhciB0cmlnZ2VyQXhpcyA9IGJhc2VUb29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJykgPT09ICdheGlzJztcbiAgICAgIHZhciBjcm9zcyA9IGJhc2VUb29sdGlwTW9kZWwuZ2V0KCdheGlzUG9pbnRlci50eXBlJykgPT09ICdjcm9zcyc7XG4gICAgICB2YXIgdG9vbHRpcEF4ZXMgPSBjb29yZFN5cy5nZXRUb29sdGlwQXhlcyhiYXNlVG9vbHRpcE1vZGVsLmdldCgnYXhpc1BvaW50ZXIuYXhpcycpKTtcblxuICAgICAgaWYgKHRyaWdnZXJBeGlzIHx8IGNyb3NzKSB7XG4gICAgICAgIGVhY2godG9vbHRpcEF4ZXMuYmFzZUF4ZXMsIGN1cnJ5KHNhdmVUb29sdGlwQXhpc0luZm8sIGNyb3NzID8gJ2Nyb3NzJyA6IHRydWUsIHRyaWdnZXJBeGlzKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjcm9zcykge1xuICAgICAgICBlYWNoKHRvb2x0aXBBeGVzLm90aGVyQXhlcywgY3Vycnkoc2F2ZVRvb2x0aXBBeGlzSW5mbywgJ2Nyb3NzJywgZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9IC8vIGZyb21Ub29sdGlwOiB0cnVlIHwgZmFsc2UgfCAnY3Jvc3MnXG4gICAgLy8gdHJpZ2dlclRvb2x0aXA6IHRydWUgfCBmYWxzZSB8IG51bGxcblxuXG4gICAgZnVuY3Rpb24gc2F2ZVRvb2x0aXBBeGlzSW5mbyhmcm9tVG9vbHRpcCwgdHJpZ2dlclRvb2x0aXAsIGF4aXMpIHtcbiAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpcy5tb2RlbC5nZXRNb2RlbCgnYXhpc1BvaW50ZXInLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsKTtcbiAgICAgIHZhciBheGlzUG9pbnRlclNob3cgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc2hvdycpO1xuXG4gICAgICBpZiAoIWF4aXNQb2ludGVyU2hvdyB8fCBheGlzUG9pbnRlclNob3cgPT09ICdhdXRvJyAmJiAhZnJvbVRvb2x0aXAgJiYgIWlzSGFuZGxlVHJpZ2dlcihheGlzUG9pbnRlck1vZGVsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmlnZ2VyVG9vbHRpcCA9PSBudWxsKSB7XG4gICAgICAgIHRyaWdnZXJUb29sdGlwID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3RyaWdnZXJUb29sdGlwJyk7XG4gICAgICB9XG5cbiAgICAgIGF4aXNQb2ludGVyTW9kZWwgPSBmcm9tVG9vbHRpcCA/IG1ha2VBeGlzUG9pbnRlck1vZGVsKGF4aXMsIGJhc2VUb29sdGlwTW9kZWwsIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwsIGVjTW9kZWwsIGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcCkgOiBheGlzUG9pbnRlck1vZGVsO1xuICAgICAgdmFyIHNuYXAgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc25hcCcpO1xuICAgICAgdmFyIGtleSA9IG1ha2VLZXkoYXhpcy5tb2RlbCk7XG4gICAgICB2YXIgaW52b2x2ZVNlcmllcyA9IHRyaWdnZXJUb29sdGlwIHx8IHNuYXAgfHwgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknOyAvLyBJZiByZXN1bHQuYXhlc0luZm9ba2V5XSBleGlzdCwgb3ZlcnJpZGUgaXQgKHRvb2x0aXAgaGFzIGhpZ2hlciBwcmlvcml0eSkuXG5cbiAgICAgIHZhciBheGlzSW5mbyA9IHJlc3VsdC5heGVzSW5mb1trZXldID0ge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgYXhpczogYXhpcyxcbiAgICAgICAgY29vcmRTeXM6IGNvb3JkU3lzLFxuICAgICAgICBheGlzUG9pbnRlck1vZGVsOiBheGlzUG9pbnRlck1vZGVsLFxuICAgICAgICB0cmlnZ2VyVG9vbHRpcDogdHJpZ2dlclRvb2x0aXAsXG4gICAgICAgIGludm9sdmVTZXJpZXM6IGludm9sdmVTZXJpZXMsXG4gICAgICAgIHNuYXA6IHNuYXAsXG4gICAgICAgIHVzZUhhbmRsZTogaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpLFxuICAgICAgICBzZXJpZXNNb2RlbHM6IFtdXG4gICAgICB9O1xuICAgICAgYXhlc0luZm9JbkNvb3JkU3lzW2tleV0gPSBheGlzSW5mbztcbiAgICAgIHJlc3VsdC5zZXJpZXNJbnZvbHZlZCB8PSBpbnZvbHZlU2VyaWVzO1xuICAgICAgdmFyIGdyb3VwSW5kZXggPSBnZXRMaW5rR3JvdXBJbmRleChsaW5rc09wdGlvbiwgYXhpcyk7XG5cbiAgICAgIGlmIChncm91cEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxpbmtHcm91cCA9IGxpbmtHcm91cHNbZ3JvdXBJbmRleF0gfHwgKGxpbmtHcm91cHNbZ3JvdXBJbmRleF0gPSB7XG4gICAgICAgICAgYXhlc0luZm86IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5rR3JvdXAuYXhlc0luZm9ba2V5XSA9IGF4aXNJbmZvO1xuICAgICAgICBsaW5rR3JvdXAubWFwcGVyID0gbGlua3NPcHRpb25bZ3JvdXBJbmRleF0ubWFwcGVyO1xuICAgICAgICBheGlzSW5mby5saW5rR3JvdXAgPSBsaW5rR3JvdXA7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZUF4aXNQb2ludGVyTW9kZWwoYXhpcywgYmFzZVRvb2x0aXBNb2RlbCwgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCwgZnJvbVRvb2x0aXAsIHRyaWdnZXJUb29sdGlwKSB7XG4gIHZhciB0b29sdGlwQXhpc1BvaW50ZXJNb2RlbCA9IGJhc2VUb29sdGlwTW9kZWwuZ2V0TW9kZWwoJ2F4aXNQb2ludGVyJyk7XG4gIHZhciB2b2xhdGlsZU9wdGlvbiA9IHt9O1xuICBlYWNoKFsndHlwZScsICdzbmFwJywgJ2xpbmVTdHlsZScsICdzaGFkb3dTdHlsZScsICdsYWJlbCcsICdhbmltYXRpb24nLCAnYW5pbWF0aW9uRHVyYXRpb25VcGRhdGUnLCAnYW5pbWF0aW9uRWFzaW5nVXBkYXRlJywgJ3onXSwgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgdm9sYXRpbGVPcHRpb25bZmllbGRdID0genJVdGlsLmNsb25lKHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsLmdldChmaWVsZCkpO1xuICB9KTsgLy8gY2F0ZWdvcnkgYXhpcyBkbyBub3QgYXV0byBzbmFwLCBvdGhlcndpc2Ugc29tZSB0aWNrIHRoYXQgZG8gbm90XG4gIC8vIGhhcyB2YWx1ZSBjYW4gbm90IGJlIGhvdmVyZWQuIHZhbHVlL3RpbWUvbG9nIGF4aXMgZGVmYXVsdCBzbmFwIGlmXG4gIC8vIHRyaWdnZXJlZCBmcm9tIHRvb2x0aXAgYW5kIHRyaWdnZXIgdG9vbHRpcC5cblxuICB2b2xhdGlsZU9wdGlvbi5zbmFwID0gYXhpcy50eXBlICE9PSAnY2F0ZWdvcnknICYmICEhdHJpZ2dlclRvb2x0aXA7IC8vIENvbXBhdGliZWwgd2l0aCBwcmV2aW91cyBiZWhhdmlvciwgdG9vbHRpcCBheGlzIGRvIG5vdCBzaG93IGxhYmVsIGJ5IGRlZmF1bHQuXG4gIC8vIE9ubHkgdGhlc2UgcHJvcGVydGllcyBjYW4gYmUgb3ZlcnJpZGVkIGZyb20gdG9vbHRpcCB0byBheGlzUG9pbnRlci5cblxuICBpZiAodG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJykgPT09ICdjcm9zcycpIHtcbiAgICB2b2xhdGlsZU9wdGlvbi50eXBlID0gJ2xpbmUnO1xuICB9XG5cbiAgdmFyIGxhYmVsT3B0aW9uID0gdm9sYXRpbGVPcHRpb24ubGFiZWwgfHwgKHZvbGF0aWxlT3B0aW9uLmxhYmVsID0ge30pOyAvLyBGb2xsb3cgdGhlIGNvbnZlbnRpb24sIGRvIG5vdCBzaG93IGxhYmVsIHdoZW4gdHJpZ2dlcmVkIGJ5IHRvb2x0aXAgYnkgZGVmYXVsdC5cblxuICBsYWJlbE9wdGlvbi5zaG93ID09IG51bGwgJiYgKGxhYmVsT3B0aW9uLnNob3cgPSBmYWxzZSk7XG5cbiAgaWYgKGZyb21Ub29sdGlwID09PSAnY3Jvc3MnKSB7XG4gICAgLy8gV2hlbiAnY3Jvc3MnLCBib3RoIGF4ZXMgc2hvdyBsYWJlbHMuXG4gICAgbGFiZWxPcHRpb24uc2hvdyA9IHRydWU7IC8vIElmIHRyaWdnZXJUb29sdGlwLCB0aGlzIGlzIGEgYmFzZSBheGlzLCB3aGljaCBzaG91bGQgYmV0dGVyIG5vdCB1c2UgY3Jvc3Mgc3R5bGVcbiAgICAvLyAoY3Jvc3Mgc3R5bGUgaXMgZGFzaGVkIGJ5IGRlZmF1bHQpXG5cbiAgICBpZiAoIXRyaWdnZXJUb29sdGlwKSB7XG4gICAgICB2YXIgY3Jvc3NTdHlsZSA9IHZvbGF0aWxlT3B0aW9uLmxpbmVTdHlsZSA9IHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsLmdldCgnY3Jvc3NTdHlsZScpO1xuICAgICAgY3Jvc3NTdHlsZSAmJiB6clV0aWwuZGVmYXVsdHMobGFiZWxPcHRpb24sIGNyb3NzU3R5bGUudGV4dFN0eWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXhpcy5tb2RlbC5nZXRNb2RlbCgnYXhpc1BvaW50ZXInLCBuZXcgTW9kZWwodm9sYXRpbGVPcHRpb24sIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwsIGVjTW9kZWwpKTtcbn1cblxuZnVuY3Rpb24gY29sbGVjdFNlcmllc0luZm8ocmVzdWx0LCBlY01vZGVsKSB7XG4gIC8vIFByZXBhcmUgZGF0YSBmb3IgYXhpcyB0cmlnZ2VyXG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAvLyBOb3RpY2UgdGhpcyBjYXNlOiB0aGlzIGNvb3JkU3lzIGlzIGBjYXJ0ZXNpYW4yRGAgYnV0IG5vdCBgZ3JpZGAuXG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPSBzZXJpZXNNb2RlbC5nZXQoJ3Rvb2x0aXAudHJpZ2dlcicsIHRydWUpO1xuICAgIHZhciBzZXJpZXNUb29sdGlwU2hvdyA9IHNlcmllc01vZGVsLmdldCgndG9vbHRpcC5zaG93JywgdHJ1ZSk7XG5cbiAgICBpZiAoIWNvb3JkU3lzIHx8IHNlcmllc1Rvb2x0aXBUcmlnZ2VyID09PSAnbm9uZScgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09IGZhbHNlIHx8IHNlcmllc1Rvb2x0aXBUcmlnZ2VyID09PSAnaXRlbScgfHwgc2VyaWVzVG9vbHRpcFNob3cgPT09IGZhbHNlIHx8IHNlcmllc01vZGVsLmdldCgnYXhpc1BvaW50ZXIuc2hvdycsIHRydWUpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2gocmVzdWx0LmNvb3JkU3lzQXhlc0luZm9bbWFrZUtleShjb29yZFN5cy5tb2RlbCldLCBmdW5jdGlvbiAoYXhpc0luZm8pIHtcbiAgICAgIHZhciBheGlzID0gYXhpc0luZm8uYXhpcztcblxuICAgICAgaWYgKGNvb3JkU3lzLmdldEF4aXMoYXhpcy5kaW0pID09PSBheGlzKSB7XG4gICAgICAgIGF4aXNJbmZvLnNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgYXhpc0luZm8uc2VyaWVzRGF0YUNvdW50ID09IG51bGwgJiYgKGF4aXNJbmZvLnNlcmllc0RhdGFDb3VudCA9IDApO1xuICAgICAgICBheGlzSW5mby5zZXJpZXNEYXRhQ291bnQgKz0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNvdW50KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIHRoaXMpO1xufVxuLyoqXG4gKiBGb3IgZXhhbXBsZTpcbiAqIHtcbiAqICAgICBheGlzUG9pbnRlcjoge1xuICogICAgICAgICBsaW5rczogW3tcbiAqICAgICAgICAgICAgIHhBeGlzSW5kZXg6IFsyLCA0XSxcbiAqICAgICAgICAgICAgIHlBeGlzSW5kZXg6ICdhbGwnXG4gKiAgICAgICAgIH0sIHtcbiAqICAgICAgICAgICAgIHhBeGlzSWQ6IFsnYTUnLCAnYTcnXSxcbiAqICAgICAgICAgICAgIHhBeGlzTmFtZTogJ3h4eCdcbiAqICAgICAgICAgfV1cbiAqICAgICB9XG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMaW5rR3JvdXBJbmRleChsaW5rc09wdGlvbiwgYXhpcykge1xuICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgdmFyIGRpbSA9IGF4aXMuZGltO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3NPcHRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGlua09wdGlvbiA9IGxpbmtzT3B0aW9uW2ldIHx8IHt9O1xuXG4gICAgaWYgKGNoZWNrUHJvcEluTGluayhsaW5rT3B0aW9uW2RpbSArICdBeGlzSWQnXSwgYXhpc01vZGVsLmlkKSB8fCBjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc0luZGV4J10sIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCkgfHwgY2hlY2tQcm9wSW5MaW5rKGxpbmtPcHRpb25bZGltICsgJ0F4aXNOYW1lJ10sIGF4aXNNb2RlbC5uYW1lKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcEluTGluayhsaW5rUHJvcFZhbHVlLCBheGlzUHJvcFZhbHVlKSB7XG4gIHJldHVybiBsaW5rUHJvcFZhbHVlID09PSAnYWxsJyB8fCB6clV0aWwuaXNBcnJheShsaW5rUHJvcFZhbHVlKSAmJiB6clV0aWwuaW5kZXhPZihsaW5rUHJvcFZhbHVlLCBheGlzUHJvcFZhbHVlKSA+PSAwIHx8IGxpbmtQcm9wVmFsdWUgPT09IGF4aXNQcm9wVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGZpeFZhbHVlKGF4aXNNb2RlbCkge1xuICB2YXIgYXhpc0luZm8gPSBnZXRBeGlzSW5mbyhheGlzTW9kZWwpO1xuXG4gIGlmICghYXhpc0luZm8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWw7XG4gIHZhciBzY2FsZSA9IGF4aXNJbmZvLmF4aXMuc2NhbGU7XG4gIHZhciBvcHRpb24gPSBheGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgdmFyIHN0YXR1cyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzdGF0dXMnKTtcbiAgdmFyIHZhbHVlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3ZhbHVlJyk7IC8vIFBhcnNlIGluaXQgdmFsdWUgZm9yIGNhdGVnb3J5IGFuZCB0aW1lIGF4aXMuXG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB2YWx1ZSA9IHNjYWxlLnBhcnNlKHZhbHVlKTtcbiAgfVxuXG4gIHZhciB1c2VIYW5kbGUgPSBpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbCk7IC8vIElmIGBoYW5kbGVgIHVzZWQsIGBheGlzUG9pbnRlcmAgd2lsbCBhbHdheXMgYmUgZGlzcGxheWVkLCBzbyB2YWx1ZVxuICAvLyBhbmQgc3RhdHVzIHNob3VsZCBiZSBpbml0aWFsaXplZC5cblxuICBpZiAoc3RhdHVzID09IG51bGwpIHtcbiAgICBvcHRpb24uc3RhdHVzID0gdXNlSGFuZGxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICB9XG5cbiAgdmFyIGV4dGVudCA9IHNjYWxlLmdldEV4dGVudCgpLnNsaWNlKCk7XG4gIGV4dGVudFswXSA+IGV4dGVudFsxXSAmJiBleHRlbnQucmV2ZXJzZSgpO1xuXG4gIGlmICggLy8gUGljayBhIHZhbHVlIG9uIGF4aXMgd2hlbiBpbml0aWFsaXppbmcuXG4gIHZhbHVlID09IG51bGwgLy8gSWYgYm90aCBgaGFuZGxlYCBhbmQgYGRhdGFab29tYCBhcmUgdXNlZCwgdmFsdWUgbWF5IGJlIG91dCBvZiBheGlzIGV4dGVudCxcbiAgLy8gd2hlcmUgd2Ugc2hvdWxkIHJlLXBpY2sgYSB2YWx1ZSB0byBrZWVwIGBoYW5kbGVgIGRpc3BsYXlpbmcgbm9ybWFsbHkuXG4gIHx8IHZhbHVlID4gZXh0ZW50WzFdKSB7XG4gICAgLy8gTWFrZSBoYW5kbGUgZGlzcGxheWVkIG9uIHRoZSBlbmQgb2YgdGhlIGF4aXMgd2hlbiBpbml0LCB3aGljaCBsb29rcyBiZXR0ZXIuXG4gICAgdmFsdWUgPSBleHRlbnRbMV07XG4gIH1cblxuICBpZiAodmFsdWUgPCBleHRlbnRbMF0pIHtcbiAgICB2YWx1ZSA9IGV4dGVudFswXTtcbiAgfVxuXG4gIG9wdGlvbi52YWx1ZSA9IHZhbHVlO1xuXG4gIGlmICh1c2VIYW5kbGUpIHtcbiAgICBvcHRpb24uc3RhdHVzID0gYXhpc0luZm8uYXhpcy5zY2FsZS5pc0JsYW5rKCkgPyAnaGlkZScgOiAnc2hvdyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0luZm8oYXhpc01vZGVsKSB7XG4gIHZhciBjb29yZFN5c0F4ZXNJbmZvID0gKGF4aXNNb2RlbC5lY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKSB8fCB7fSkuY29vcmRTeXNBeGVzSW5mbztcbiAgcmV0dXJuIGNvb3JkU3lzQXhlc0luZm8gJiYgY29vcmRTeXNBeGVzSW5mby5heGVzSW5mb1ttYWtlS2V5KGF4aXNNb2RlbCldO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzUG9pbnRlck1vZGVsKGF4aXNNb2RlbCkge1xuICB2YXIgYXhpc0luZm8gPSBnZXRBeGlzSW5mbyhheGlzTW9kZWwpO1xuICByZXR1cm4gYXhpc0luZm8gJiYgYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbDtcbn1cblxuZnVuY3Rpb24gaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgcmV0dXJuICEhYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2hhbmRsZS5zaG93Jyk7XG59XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG1vZGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHVuaXF1ZSBrZXlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1ha2VLZXkobW9kZWwpIHtcbiAgcmV0dXJuIG1vZGVsLnR5cGUgKyAnfHwnICsgbW9kZWwuaWQ7XG59XG5cbmV4cG9ydHMuY29sbGVjdCA9IGNvbGxlY3Q7XG5leHBvcnRzLmZpeFZhbHVlID0gZml4VmFsdWU7XG5leHBvcnRzLmdldEF4aXNJbmZvID0gZ2V0QXhpc0luZm87XG5leHBvcnRzLmdldEF4aXNQb2ludGVyTW9kZWwgPSBnZXRBeGlzUG9pbnRlck1vZGVsO1xuZXhwb3J0cy5tYWtlS2V5ID0gbWFrZUtleTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvbW9kZWxIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9temljY2FyZC9ub2RlLXRpbXNvcnRcbnZhciBERUZBVUxUX01JTl9NRVJHRSA9IDMyO1xudmFyIERFRkFVTFRfTUlOX0dBTExPUElORyA9IDc7XG52YXIgREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEggPSAyNTY7XG5cbmZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gIHZhciByID0gMDtcblxuICB3aGlsZSAobiA+PSBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgIHIgfD0gbiAmIDE7XG4gICAgbiA+Pj0gMTtcbiAgfVxuXG4gIHJldHVybiBuICsgcjtcbn1cblxuZnVuY3Rpb24gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKSB7XG4gIHZhciBydW5IaSA9IGxvICsgMTtcblxuICBpZiAocnVuSGkgPT09IGhpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoY29tcGFyZShhcnJheVtydW5IaSsrXSwgYXJyYXlbbG9dKSA8IDApIHtcbiAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPCAwKSB7XG4gICAgICBydW5IaSsrO1xuICAgIH1cblxuICAgIHJldmVyc2VSdW4oYXJyYXksIGxvLCBydW5IaSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pID49IDApIHtcbiAgICAgIHJ1bkhpKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ1bkhpIC0gbG87XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VSdW4oYXJyYXksIGxvLCBoaSkge1xuICBoaS0tO1xuXG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIHQgPSBhcnJheVtsb107XG4gICAgYXJyYXlbbG8rK10gPSBhcnJheVtoaV07XG4gICAgYXJyYXlbaGktLV0gPSB0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgaWYgKHN0YXJ0ID09PSBsbykge1xuICAgIHN0YXJ0Kys7XG4gIH1cblxuICBmb3IgKDsgc3RhcnQgPCBoaTsgc3RhcnQrKykge1xuICAgIHZhciBwaXZvdCA9IGFycmF5W3N0YXJ0XTtcbiAgICB2YXIgbGVmdCA9IGxvO1xuICAgIHZhciByaWdodCA9IHN0YXJ0O1xuICAgIHZhciBtaWQ7XG5cbiAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICBtaWQgPSBsZWZ0ICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgY2FzZSAzOlxuICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgYXJyYXlbbGVmdCArIDJdID0gYXJyYXlbbGVmdCArIDFdO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGFycmF5W2xlZnQgKyAxXSA9IGFycmF5W2xlZnRdO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgYXJyYXlbbGVmdCArIG5dID0gYXJyYXlbbGVmdCArIG4gLSAxXTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFycmF5W2xlZnRdID0gcGl2b3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2FsbG9wTGVmdCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgdmFyIG9mZnNldCA9IDE7XG5cbiAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pID4gMCkge1xuICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID4gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgb2Zmc2V0ICs9IGhpbnQ7XG4gIH0gZWxzZSB7XG4gICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDw9IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgfVxuXG4gIGxhc3RPZmZzZXQrKztcblxuICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA+IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gbTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgdmFyIG9mZnNldCA9IDE7XG5cbiAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pIDwgMCkge1xuICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgfSBlbHNlIHtcbiAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+PSAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICBvZmZzZXQgKz0gaGludDtcbiAgfVxuXG4gIGxhc3RPZmZzZXQrKztcblxuICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA8IDApIHtcbiAgICAgIG9mZnNldCA9IG07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKSB7XG4gIHZhciBtaW5HYWxsb3AgPSBERUZBVUxUX01JTl9HQUxMT1BJTkc7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgdG1wU3RvcmFnZUxlbmd0aCA9IERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIO1xuICB2YXIgc3RhY2tMZW5ndGggPSAwO1xuICB2YXIgcnVuU3RhcnQ7XG4gIHZhciBydW5MZW5ndGg7XG4gIHZhciBzdGFja1NpemUgPSAwO1xuICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDIgKiBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCkge1xuICAgIHRtcFN0b3JhZ2VMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gIH1cblxuICB2YXIgdG1wID0gW107XG4gIHN0YWNrTGVuZ3RoID0gbGVuZ3RoIDwgMTIwID8gNSA6IGxlbmd0aCA8IDE1NDIgPyAxMCA6IGxlbmd0aCA8IDExOTE1MSA/IDE5IDogNDA7XG4gIHJ1blN0YXJ0ID0gW107XG4gIHJ1bkxlbmd0aCA9IFtdO1xuXG4gIGZ1bmN0aW9uIHB1c2hSdW4oX3J1blN0YXJ0LCBfcnVuTGVuZ3RoKSB7XG4gICAgcnVuU3RhcnRbc3RhY2tTaXplXSA9IF9ydW5TdGFydDtcbiAgICBydW5MZW5ndGhbc3RhY2tTaXplXSA9IF9ydW5MZW5ndGg7XG4gICAgc3RhY2tTaXplICs9IDE7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVJ1bnMoKSB7XG4gICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgaWYgKG4gPj0gMSAmJiBydW5MZW5ndGhbbiAtIDFdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuICsgMV0gfHwgbiA+PSAyICYmIHJ1bkxlbmd0aFtuIC0gMl0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gLSAxXSkge1xuICAgICAgICBpZiAocnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnVuTGVuZ3RoW25dID4gcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbWVyZ2VBdChuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICBpZiAobiA+IDAgJiYgcnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgbi0tO1xuICAgICAgfVxuXG4gICAgICBtZXJnZUF0KG4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQXQoaSkge1xuICAgIHZhciBzdGFydDEgPSBydW5TdGFydFtpXTtcbiAgICB2YXIgbGVuZ3RoMSA9IHJ1bkxlbmd0aFtpXTtcbiAgICB2YXIgc3RhcnQyID0gcnVuU3RhcnRbaSArIDFdO1xuICAgIHZhciBsZW5ndGgyID0gcnVuTGVuZ3RoW2kgKyAxXTtcbiAgICBydW5MZW5ndGhbaV0gPSBsZW5ndGgxICsgbGVuZ3RoMjtcblxuICAgIGlmIChpID09PSBzdGFja1NpemUgLSAzKSB7XG4gICAgICBydW5TdGFydFtpICsgMV0gPSBydW5TdGFydFtpICsgMl07XG4gICAgICBydW5MZW5ndGhbaSArIDFdID0gcnVuTGVuZ3RoW2kgKyAyXTtcbiAgICB9XG5cbiAgICBzdGFja1NpemUtLTtcbiAgICB2YXIgayA9IGdhbGxvcFJpZ2h0KGFycmF5W3N0YXJ0Ml0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuICAgIHN0YXJ0MSArPSBrO1xuICAgIGxlbmd0aDEgLT0gaztcblxuICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGVuZ3RoMiA9IGdhbGxvcExlZnQoYXJyYXlbc3RhcnQxICsgbGVuZ3RoMSAtIDFdLCBhcnJheSwgc3RhcnQyLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgxIDw9IGxlbmd0aDIpIHtcbiAgICAgIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MSArIGldO1xuICAgIH1cblxuICAgIHZhciBjdXJzb3IxID0gMDtcbiAgICB2YXIgY3Vyc29yMiA9IHN0YXJ0MjtcbiAgICB2YXIgZGVzdCA9IHN0YXJ0MTtcbiAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuICAgIHZhciBjb3VudDEsIGNvdW50MiwgZXhpdDtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICBjb3VudDEgPSAwO1xuICAgICAgY291bnQyID0gMDtcbiAgICAgIGV4aXQgPSBmYWxzZTtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29tcGFyZShhcnJheVtjdXJzb3IyXSwgdG1wW2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcbiAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgIGNvdW50MiA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY291bnQxID0gZ2FsbG9wUmlnaHQoYXJyYXlbY3Vyc29yMl0sIHRtcCwgY3Vyc29yMSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDE7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0ICs9IGNvdW50MTtcbiAgICAgICAgICBjdXJzb3IxICs9IGNvdW50MTtcbiAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcblxuICAgICAgICAgIGlmIChsZW5ndGgxIDw9IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY291bnQyID0gZ2FsbG9wTGVmdCh0bXBbY3Vyc29yMV0sIGFycmF5LCBjdXJzb3IyLCBsZW5ndGgyLCAwLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdCArPSBjb3VudDI7XG4gICAgICAgICAgY3Vyc29yMiArPSBjb3VudDI7XG4gICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgIH1cblxuICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG4gICAgbWluR2FsbG9wIDwgMSAmJiAobWluR2FsbG9wID0gMSk7XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlTG93IHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDIgKyBpXTtcbiAgICB9XG5cbiAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgIHZhciBjdXJzb3IyID0gbGVuZ3RoMiAtIDE7XG4gICAgdmFyIGRlc3QgPSBzdGFydDIgKyBsZW5ndGgyIC0gMTtcbiAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICB2YXIgY3VzdG9tRGVzdCA9IDA7XG4gICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgY291bnQxID0gMDtcbiAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29tcGFyZSh0bXBbY3Vyc29yMl0sIGFycmF5W2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcbiAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY291bnQxID0gbGVuZ3RoMSAtIGdhbGxvcFJpZ2h0KHRtcFtjdXJzb3IyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgbGVuZ3RoMSAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICBkZXN0IC09IGNvdW50MTtcbiAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSBjb3VudDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50MiA9IGxlbmd0aDIgLSBnYWxsb3BMZWZ0KGFycmF5W2N1cnNvcjFdLCB0bXAsIDAsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgZGVzdCAtPSBjb3VudDI7XG4gICAgICAgICAgY3Vyc29yMiAtPSBjb3VudDI7XG4gICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjIgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSB0bXBbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbmd0aDIgPD0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKF9taW5HYWxsb3AgPCAwKSB7XG4gICAgICAgIF9taW5HYWxsb3AgPSAwO1xuICAgICAgfVxuXG4gICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgfVxuXG4gICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcblxuICAgIGlmIChtaW5HYWxsb3AgPCAxKSB7XG4gICAgICBtaW5HYWxsb3AgPSAxO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLm1lcmdlUnVucyA9IG1lcmdlUnVucztcbiAgdGhpcy5mb3JjZU1lcmdlUnVucyA9IGZvcmNlTWVyZ2VSdW5zO1xuICB0aGlzLnB1c2hSdW4gPSBwdXNoUnVuO1xufVxuXG5mdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgaWYgKCFsbykge1xuICAgIGxvID0gMDtcbiAgfVxuXG4gIGlmICghaGkpIHtcbiAgICBoaSA9IGFycmF5Lmxlbmd0aDtcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSBoaSAtIGxvO1xuXG4gIGlmIChyZW1haW5pbmcgPCAyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJ1bkxlbmd0aCA9IDA7XG5cbiAgaWYgKHJlbWFpbmluZyA8IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHMgPSBuZXcgVGltU29ydChhcnJheSwgY29tcGFyZSk7XG4gIHZhciBtaW5SdW4gPSBtaW5SdW5MZW5ndGgocmVtYWluaW5nKTtcblxuICBkbyB7XG4gICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcblxuICAgIGlmIChydW5MZW5ndGggPCBtaW5SdW4pIHtcbiAgICAgIHZhciBmb3JjZSA9IHJlbWFpbmluZztcblxuICAgICAgaWYgKGZvcmNlID4gbWluUnVuKSB7XG4gICAgICAgIGZvcmNlID0gbWluUnVuO1xuICAgICAgfVxuXG4gICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgbG8gKyBmb3JjZSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgcnVuTGVuZ3RoID0gZm9yY2U7XG4gICAgfVxuXG4gICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICB0cy5tZXJnZVJ1bnMoKTtcbiAgICByZW1haW5pbmcgLT0gcnVuTGVuZ3RoO1xuICAgIGxvICs9IHJ1bkxlbmd0aDtcbiAgfSB3aGlsZSAocmVtYWluaW5nICE9PSAwKTtcblxuICB0cy5mb3JjZU1lcmdlUnVucygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vU3R5bGVcIik7XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZShcIi4uL0VsZW1lbnRcIik7XG5cbnZhciBSZWN0VGV4dCA9IHJlcXVpcmUoXCIuL21peGluL1JlY3RUZXh0XCIpO1xuXG4vKipcbiAqIOWPr+e7mOWItueahOWbvuW9ouWfuuexu1xuICogQmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheWFibGUgZ3JhcGhpYyBvYmplY3RzXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcbiAqL1xuZnVuY3Rpb24gRGlzcGxheWFibGUob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpOyAvLyBFeHRlbmQgcHJvcGVydGllc1xuXG4gIGZvciAodmFyIG5hbWUgaW4gb3B0cykge1xuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUgIT09ICdzdHlsZScpIHtcbiAgICAgIHRoaXNbbmFtZV0gPSBvcHRzW25hbWVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9XG4gICAqL1xuXG5cbiAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShvcHRzLnN0eWxlLCB0aGlzKTtcbiAgdGhpcy5fcmVjdCA9IG51bGw7IC8vIFNoYXBlcyBmb3IgY2FzY2FkZSBjbGlwcGluZy5cblxuICB0aGlzLl9fY2xpcFBhdGhzID0gW107IC8vIEZJWE1FIFN0YXRlZnVsIG11c3QgYmUgbWl4aW5lZCBhZnRlciBzdHlsZSBpcyBzZXR0ZWRcbiAgLy8gU3RhdGVmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuRGlzcGxheWFibGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGxheWFibGUsXG4gIHR5cGU6ICdkaXNwbGF5YWJsZScsXG5cbiAgLyoqXG4gICAqIERpc3BsYXlhYmxlIOaYr+WQpuS4uuiEj++8jFBhaW50ZXIg5Lit5Lya5qC55o2u6K+l5qCH6K6w5Yik5pat5piv5ZCm6ZyA6KaB5piv5ZCm6ZyA6KaB6YeN5paw57uY5Yi2XG4gICAqIERpcnR5IGZsYWcuIEZyb20gd2hpY2ggcGFpbnRlciB3aWxsIGRldGVybWluZSBpZiB0aGlzIGRpc3BsYXlhYmxlIG9iamVjdCBuZWVkcyBicnVzaFxuICAgKiBAbmFtZSBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI19fZGlydHlcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBfX2RpcnR5OiB0cnVlLFxuXG4gIC8qKlxuICAgKiDlm77lvaLmmK/lkKblj6/op4HvvIzkuLp0cnVl5pe25LiN57uY5Yi25Zu+5b2i77yM5L2G5piv5LuN6IO96Kem5Y+R6byg5qCH5LqL5Lu2XG4gICAqIElmIGlnbm9yZSBkcmF3aW5nIG9mIHRoZSBkaXNwbGF5YWJsZSBvYmplY3QuIE1vdXNlIGV2ZW50IHdpbGwgc3RpbGwgYmUgdHJpZ2dlcmVkXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2ludmlzaWJsZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGludmlzaWJsZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgejogMCxcblxuICAvKipcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB6MjogMCxcblxuICAvKipcbiAgICogeuWxgmxldmVs77yM5Yaz5a6a57uY55S75Zyo5ZOq5bGCY2FudmFz5LitXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3psZXZlbFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB6bGV2ZWw6IDAsXG5cbiAgLyoqXG4gICAqIOaYr+WQpuWPr+aLluaLvVxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDmmK/lkKbmraPlnKjmi5bmi71cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDmmK/lkKbnm7jlupTpvKDmoIfkuovku7ZcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjc2lsZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogSWYgZW5hYmxlIGN1bGxpbmdcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBjdWxsaW5nOiBmYWxzZSxcblxuICAvKipcbiAgICogTW91c2UgY3Vyc29yIHdoZW4gaG92ZXJlZFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNjdXJzb3JcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuXG4gIC8qKlxuICAgKiBJZiBob3ZlciBhcmVhIGlzIGJvdW5kaW5nIHJlY3RcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjcmVjdEhvdmVyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICByZWN0SG92ZXI6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgcHJvZ3Jlc3NpdmVseSB3aGVuIHRoZSB2YWx1ZSA+PSAwLFxuICAgKiB1c2VmdWxsIGZvciBsYXJnZSBkYXRhLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgcHJvZ3Jlc3NpdmU6IC0xLFxuICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG4gIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuXG4gIC8qKlxuICAgKiDlm77lvaLnu5jliLbmlrnms5VcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgLy8gSW50ZXJmYWNlXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHt9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmnIDlsI/ljIXlm7Tnm5JcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICAvLyBJbnRlcmZhY2VcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i5LiKXG4gICAqIElmIGRpc3BsYXlhYmxlIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMucmVjdENvbnRhaW4oeCwgeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9oueahOWMheWbtOebkuS4ilxuICAgKiBJZiBib3VuZGluZyByZWN0IG9mIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHJlY3RDb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBjb29yZCA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICByZXR1cm4gcmVjdC5jb250YWluKGNvb3JkWzBdLCBjb29yZFsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOagh+iusOWbvuW9ouWFg+e0oOS4uuiEj++8jOW5tuS4lOWcqOS4i+S4gOW4p+mHjee7mFxuICAgKiBNYXJrIGRpc3BsYXlhYmxlIGVsZW1lbnQgZGlydHkgYW5kIHJlZnJlc2ggbmV4dCBmcmFtZVxuICAgKi9cbiAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlm77lvaLmmK/lkKbkvJrop6blj5Hkuovku7ZcbiAgICogSWYgZGlzcGxheWFibGUgb2JqZWN0IGJpbmRlZCBhbnkgZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIC8vIFRPRE8sIOmAmui/hyBiaW5kIOe7keWumueahOS6i+S7tlxuICAvLyBpc1NpbGVudDogZnVuY3Rpb24gKCkge1xuICAvLyAgICAgcmV0dXJuICEoXG4gIC8vICAgICAgICAgdGhpcy5ob3ZlcmFibGUgfHwgdGhpcy5kcmFnZ2FibGVcbiAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vtb3ZlIHx8IHRoaXMub25tb3VzZW92ZXIgfHwgdGhpcy5vbm1vdXNlb3V0XG4gIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlZG93biB8fCB0aGlzLm9ubW91c2V1cCB8fCB0aGlzLm9uY2xpY2tcbiAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJhZ2VudGVyIHx8IHRoaXMub25kcmFnb3ZlciB8fCB0aGlzLm9uZHJhZ2xlYXZlXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbmRyb3BcbiAgLy8gICAgICk7XG4gIC8vIH0sXG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBhbmltYXRlKCdzdHlsZScpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgKi9cbiAgYW5pbWF0ZVN0eWxlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3N0eWxlJywgbG9vcCk7XG4gIH0sXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ICE9PSAnc3R5bGUnKSB7XG4gICAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHlsZS5zZXQodmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zdHlsZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZSBnaXZlbiBzdHlsZSBvYmplY3RcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAgICovXG4gIHVzZVN0eWxlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShvYmosIHRoaXMpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKERpc3BsYXlhYmxlLCBFbGVtZW50KTtcbnpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgUmVjdFRleHQpOyAvLyB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFN0YXRlZnVsKTtcblxudmFyIF9kZWZhdWx0ID0gRGlzcGxheWFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBMUlUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9MUlVcIik7XG5cbnZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2VcbiAqL1xuXG5mdW5jdGlvbiBmaW5kRXhpc3RJbWFnZShuZXdJbWFnZU9yU3JjKSB7XG4gIGlmICh0eXBlb2YgbmV3SW1hZ2VPclNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG4gICAgcmV0dXJuIGNhY2hlZEltZ09iaiAmJiBjYWNoZWRJbWdPYmouaW1hZ2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gIH1cbn1cbi8qKlxuICogQ2F1dGlvbjogVXNlciBzaG91bGQgY2FjaGUgbG9hZGVkIGltYWdlcywgYnV0IG5vdCBqdXN0IGNvdW50IG9uIExSVS5cbiAqIENvbnNpZGVyIGlmIHJlcXVpcmVkIGltYWdlcyBtb3JlIHRoYW4gTFJVIHNpemUsIHdpbGwgZGVhZCBsb29wIG9jY3VyP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZSBFeGlzdGVudCBpbWFnZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gW2hvc3RFbF0gRm9yIGNhbGxpbmcgYGRpcnR5YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gcGFyYW1zOiAoaW1hZ2UsIGNiUGF5bG9hZClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY2JQYXlsb2FkXSBQYXlsb2FkIG9uIGNiIGNhbGxpbmcuXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlSW1hZ2UobmV3SW1hZ2VPclNyYywgaW1hZ2UsIGhvc3RFbCwgY2IsIGNiUGF5bG9hZCkge1xuICBpZiAoIW5ld0ltYWdlT3JTcmMpIHtcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0ltYWdlT3JTcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSW1hZ2Ugc2hvdWxkIG5vdCBiZSBsb2FkZWQgcmVwZWF0bHkuXG4gICAgaWYgKGltYWdlICYmIGltYWdlLl9fenJJbWFnZVNyYyA9PT0gbmV3SW1hZ2VPclNyYyB8fCAhaG9zdEVsKSB7XG4gICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSAvLyBPbmx5IHdoZW4gdGhlcmUgaXMgbm8gZXhpc3RlbnQgaW1hZ2Ugb3IgZXhpc3RlbnQgaW1hZ2Ugc3JjXG4gICAgLy8gaXMgZGlmZmVyZW50LCB0aGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgbG9hZC5cblxuXG4gICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KG5ld0ltYWdlT3JTcmMpO1xuICAgIHZhciBwZW5kaW5nV3JhcCA9IHtcbiAgICAgIGhvc3RFbDogaG9zdEVsLFxuICAgICAgY2I6IGNiLFxuICAgICAgY2JQYXlsb2FkOiBjYlBheWxvYWRcbiAgICB9O1xuXG4gICAgaWYgKGNhY2hlZEltZ09iaikge1xuICAgICAgaW1hZ2UgPSBjYWNoZWRJbWdPYmouaW1hZ2U7XG4gICAgICAhaXNJbWFnZVJlYWR5KGltYWdlKSAmJiBjYWNoZWRJbWdPYmoucGVuZGluZy5wdXNoKHBlbmRpbmdXcmFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIWltYWdlICYmIChpbWFnZSA9IG5ldyBJbWFnZSgpKTtcbiAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlT25Mb2FkO1xuICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQobmV3SW1hZ2VPclNyYywgaW1hZ2UuX19jYWNoZWRJbWdPYmogPSB7XG4gICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgcGVuZGluZzogW3BlbmRpbmdXcmFwXVxuICAgICAgfSk7XG4gICAgICBpbWFnZS5zcmMgPSBpbWFnZS5fX3pySW1hZ2VTcmMgPSBuZXdJbWFnZU9yU3JjO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZTtcbiAgfSAvLyBuZXdJbWFnZU9yU3JjIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gIGVsc2Uge1xuICAgICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbWFnZU9uTG9hZCgpIHtcbiAgdmFyIGNhY2hlZEltZ09iaiA9IHRoaXMuX19jYWNoZWRJbWdPYmo7XG4gIHRoaXMub25sb2FkID0gdGhpcy5fX2NhY2hlZEltZ09iaiA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwZW5kaW5nV3JhcCA9IGNhY2hlZEltZ09iai5wZW5kaW5nW2ldO1xuICAgIHZhciBjYiA9IHBlbmRpbmdXcmFwLmNiO1xuICAgIGNiICYmIGNiKHRoaXMsIHBlbmRpbmdXcmFwLmNiUGF5bG9hZCk7XG4gICAgcGVuZGluZ1dyYXAuaG9zdEVsLmRpcnR5KCk7XG4gIH1cblxuICBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBpc0ltYWdlUmVhZHkoaW1hZ2UpIHtcbiAgcmV0dXJuIGltYWdlICYmIGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodDtcbn1cblxuZXhwb3J0cy5maW5kRXhpc3RJbWFnZSA9IGZpbmRFeGlzdEltYWdlO1xuZXhwb3J0cy5jcmVhdGVPclVwZGF0ZUltYWdlID0gY3JlYXRlT3JVcGRhdGVJbWFnZTtcbmV4cG9ydHMuaXNJbWFnZVJlYWR5ID0gaXNJbWFnZVJlYWR5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqL1xudmFyIEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yU3RvcHMpIHtcbiAgdGhpcy5jb2xvclN0b3BzID0gY29sb3JTdG9wcyB8fCBbXTtcbn07XG5cbkdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyYWRpZW50LFxuICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uIChvZmZzZXQsIGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIF9jbGF6eiA9IHJlcXVpcmUoXCIuL2NsYXp6XCIpO1xuXG52YXIgcGFyc2VDbGFzc1R5cGUgPSBfY2xhenoucGFyc2VDbGFzc1R5cGU7XG52YXIgYmFzZSA9IDA7XG52YXIgREVMSU1JVEVSID0gJ18nO1xuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldFVJRCh0eXBlKSB7XG4gIC8vIENvbnNpZGVyaW5nIHRoZSBjYXNlIG9mIGNyb3NzaW5nIGpzIGNvbnRleHQsXG4gIC8vIHVzZSBNYXRoLnJhbmRvbSB0byBtYWtlIGlkIGFzIHVuaXF1ZSBhcyBwb3NzaWJsZS5cbiAgcmV0dXJuIFt0eXBlIHx8ICcnLCBiYXNlKyssIE1hdGgucmFuZG9tKCldLmpvaW4oREVMSU1JVEVSKTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBlbmFibGVTdWJUeXBlRGVmYXVsdGVyKGVudGl0eSkge1xuICB2YXIgc3ViVHlwZURlZmF1bHRlcnMgPSB7fTtcblxuICBlbnRpdHkucmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIGRlZmF1bHRlcikge1xuICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICBzdWJUeXBlRGVmYXVsdGVyc1tjb21wb25lbnRUeXBlLm1haW5dID0gZGVmYXVsdGVyO1xuICB9O1xuXG4gIGVudGl0eS5kZXRlcm1pbmVTdWJUeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIG9wdGlvbikge1xuICAgIHZhciB0eXBlID0gb3B0aW9uLnR5cGU7XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHZhciBjb21wb25lbnRUeXBlTWFpbiA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpLm1haW47XG5cbiAgICAgIGlmIChlbnRpdHkuaGFzU3ViVHlwZXMoY29tcG9uZW50VHlwZSkgJiYgc3ViVHlwZURlZmF1bHRlcnNbY29tcG9uZW50VHlwZU1haW5dKSB7XG4gICAgICAgIHR5cGUgPSBzdWJUeXBlRGVmYXVsdGVyc1tjb21wb25lbnRUeXBlTWFpbl0ob3B0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfTtcblxuICByZXR1cm4gZW50aXR5O1xufVxuLyoqXG4gKiBUb3BvbG9naWNhbCB0cmF2ZWwgb24gQWN0aXZpdHkgTmV0d29yayAoQWN0aXZpdHkgT24gVmVydGljZXMpLlxuICogRGVwZW5kZW5jaWVzIGlzIGRlZmluZWQgaW4gTW9kZWwucHJvdG90eXBlLmRlcGVuZGVuY2llcywgbGlrZSBbJ3hBeGlzJywgJ3lBeGlzJ10uXG4gKlxuICogSWYgJ3hBeGlzJyBvciAneUF4aXMnIGlzIGFic2VudCBpbiBjb21wb25lbnRUeXBlTGlzdCwganVzdCBpZ25vcmUgaXQgaW4gdG9wb2xvZ3kuXG4gKlxuICogSWYgdGhlcmUgaXMgY2lyY2xlIGRlcGVuZGVuY2V5LCBFcnJvciB3aWxsIGJlIHRocm93bi5cbiAqXG4gKi9cblxuXG5mdW5jdGlvbiBlbmFibGVUb3BvbG9naWNhbFRyYXZlbChlbnRpdHksIGRlcGVuZGVuY3lHZXR0ZXIpIHtcbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gdGFyZ2V0TmFtZUxpc3QgVGFyZ2V0IENvbXBvbmVudCB0eXBlIGxpc3QuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBbJ2FhJywgJ2JiJywgJ2FhLnh4J11cbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gZnVsbE5hbWVMaXN0IEJ5IHdoaWNoIHdlIGNhbiBidWlsZCBkZXBlbmRlbmN5IGdyYXBoLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBQYXJhbXM6IGNvbXBvbmVudFR5cGUsIGRlcGVuZGVuY2llcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgU2NvcGUgb2YgY2FsbGJhY2suXG4gICAqL1xuICBlbnRpdHkudG9wb2xvZ2ljYWxUcmF2ZWwgPSBmdW5jdGlvbiAodGFyZ2V0TmFtZUxpc3QsIGZ1bGxOYW1lTGlzdCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAoIXRhcmdldE5hbWVMaXN0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBtYWtlRGVwbmRlbmN5R3JhcGgoZnVsbE5hbWVMaXN0KTtcbiAgICB2YXIgZ3JhcGggPSByZXN1bHQuZ3JhcGg7XG4gICAgdmFyIHN0YWNrID0gcmVzdWx0Lm5vRW50cnlMaXN0O1xuICAgIHZhciB0YXJnZXROYW1lU2V0ID0ge307XG4gICAgenJVdGlsLmVhY2godGFyZ2V0TmFtZUxpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB0YXJnZXROYW1lU2V0W25hbWVdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyQ29tcG9uZW50VHlwZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgdmFyIGN1cnJWZXJ0ZXggPSBncmFwaFtjdXJyQ29tcG9uZW50VHlwZV07XG4gICAgICB2YXIgaXNJblRhcmdldE5hbWVTZXQgPSAhIXRhcmdldE5hbWVTZXRbY3VyckNvbXBvbmVudFR5cGVdO1xuXG4gICAgICBpZiAoaXNJblRhcmdldE5hbWVTZXQpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBjdXJyQ29tcG9uZW50VHlwZSwgY3VyclZlcnRleC5vcmlnaW5hbERlcHMuc2xpY2UoKSk7XG4gICAgICAgIGRlbGV0ZSB0YXJnZXROYW1lU2V0W2N1cnJDb21wb25lbnRUeXBlXTtcbiAgICAgIH1cblxuICAgICAgenJVdGlsLmVhY2goY3VyclZlcnRleC5zdWNjZXNzb3IsIGlzSW5UYXJnZXROYW1lU2V0ID8gcmVtb3ZlRWRnZUFuZEFkZCA6IHJlbW92ZUVkZ2UpO1xuICAgIH1cblxuICAgIHpyVXRpbC5lYWNoKHRhcmdldE5hbWVTZXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2lyY2xlIGRlcGVuZGVuY3kgbWF5IGV4aXN0cycpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWRnZShzdWNjQ29tcG9uZW50VHlwZSkge1xuICAgICAgZ3JhcGhbc3VjY0NvbXBvbmVudFR5cGVdLmVudHJ5Q291bnQtLTtcblxuICAgICAgaWYgKGdyYXBoW3N1Y2NDb21wb25lbnRUeXBlXS5lbnRyeUNvdW50ID09PSAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2goc3VjY0NvbXBvbmVudFR5cGUpO1xuICAgICAgfVxuICAgIH0gLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiBsZWdlbmQgZGVwZW5kcyBvbiBzZXJpZXMsIGFuZCB3ZSBjYWxsXG4gICAgLy8gY2hhcnQuc2V0T3B0aW9uKHtzZXJpZXM6IFsuLi5dfSksIHdoZXJlIG9ubHkgc2VyaWVzIGlzIGluIG9wdGlvbi5cbiAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSAncmVtb3ZlRWRnZUFuZEFkZCcsIGxlZ2VuZE1vZGVsLm1lcmdlT3B0aW9uIHdpbGxcbiAgICAvLyBub3QgYmUgY2FsbGVkLCBidXQgb25seSBzZXJlaXMubWVyZ2VPcHRpb24gaXMgY2FsbGVkLiBUaHVzIGxlZ2VuZFxuICAgIC8vIGhhdmUgbm8gY2hhbmNlIHRvIHVwZGF0ZSBpdHMgbG9jYWwgcmVjb3JkIGFib3V0IHNlcmllcyAobGlrZSB3aGljaFxuICAgIC8vIG5hbWUgb2Ygc2VyaWVzIGlzIGF2YWlsYWJsZSBpbiBsZWdlbmQpLlxuXG5cbiAgICBmdW5jdGlvbiByZW1vdmVFZGdlQW5kQWRkKHN1Y2NDb21wb25lbnRUeXBlKSB7XG4gICAgICB0YXJnZXROYW1lU2V0W3N1Y2NDb21wb25lbnRUeXBlXSA9IHRydWU7XG4gICAgICByZW1vdmVFZGdlKHN1Y2NDb21wb25lbnRUeXBlKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBEZXBuZGVuY3lHcmFwaDoge09iamVjdH1cbiAgICoga2V5OiBjb25wb25lbnRUeXBlLFxuICAgKiB2YWx1ZToge1xuICAgKiAgICAgc3VjY2Vzc29yOiBbY29ucG9uZW50VHlwZXMuLi5dLFxuICAgKiAgICAgb3JpZ2luYWxEZXBzOiBbY29ucG9uZW50VHlwZXMuLi5dLFxuICAgKiAgICAgZW50cnlDb3VudDoge251bWJlcn1cbiAgICogfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1ha2VEZXBuZGVuY3lHcmFwaChmdWxsTmFtZUxpc3QpIHtcbiAgICB2YXIgZ3JhcGggPSB7fTtcbiAgICB2YXIgbm9FbnRyeUxpc3QgPSBbXTtcbiAgICB6clV0aWwuZWFjaChmdWxsTmFtZUxpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdGhpc0l0ZW0gPSBjcmVhdGVEZXBlbmRlbmN5R3JhcGhJdGVtKGdyYXBoLCBuYW1lKTtcbiAgICAgIHZhciBvcmlnaW5hbERlcHMgPSB0aGlzSXRlbS5vcmlnaW5hbERlcHMgPSBkZXBlbmRlbmN5R2V0dGVyKG5hbWUpO1xuICAgICAgdmFyIGF2YWlsYWJsZURlcHMgPSBnZXRBdmFpbGFibGVEZXBlbmRlbmNpZXMob3JpZ2luYWxEZXBzLCBmdWxsTmFtZUxpc3QpO1xuICAgICAgdGhpc0l0ZW0uZW50cnlDb3VudCA9IGF2YWlsYWJsZURlcHMubGVuZ3RoO1xuXG4gICAgICBpZiAodGhpc0l0ZW0uZW50cnlDb3VudCA9PT0gMCkge1xuICAgICAgICBub0VudHJ5TGlzdC5wdXNoKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB6clV0aWwuZWFjaChhdmFpbGFibGVEZXBzLCBmdW5jdGlvbiAoZGVwZW5kZW50TmFtZSkge1xuICAgICAgICBpZiAoenJVdGlsLmluZGV4T2YodGhpc0l0ZW0ucHJlZGVjZXNzb3IsIGRlcGVuZGVudE5hbWUpIDwgMCkge1xuICAgICAgICAgIHRoaXNJdGVtLnByZWRlY2Vzc29yLnB1c2goZGVwZW5kZW50TmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhhdEl0ZW0gPSBjcmVhdGVEZXBlbmRlbmN5R3JhcGhJdGVtKGdyYXBoLCBkZXBlbmRlbnROYW1lKTtcblxuICAgICAgICBpZiAoenJVdGlsLmluZGV4T2YodGhhdEl0ZW0uc3VjY2Vzc29yLCBkZXBlbmRlbnROYW1lKSA8IDApIHtcbiAgICAgICAgICB0aGF0SXRlbS5zdWNjZXNzb3IucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdyYXBoOiBncmFwaCxcbiAgICAgIG5vRW50cnlMaXN0OiBub0VudHJ5TGlzdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVEZXBlbmRlbmN5R3JhcGhJdGVtKGdyYXBoLCBuYW1lKSB7XG4gICAgaWYgKCFncmFwaFtuYW1lXSkge1xuICAgICAgZ3JhcGhbbmFtZV0gPSB7XG4gICAgICAgIHByZWRlY2Vzc29yOiBbXSxcbiAgICAgICAgc3VjY2Vzc29yOiBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhcGhbbmFtZV07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBdmFpbGFibGVEZXBlbmRlbmNpZXMob3JpZ2luYWxEZXBzLCBmdWxsTmFtZUxpc3QpIHtcbiAgICB2YXIgYXZhaWxhYmxlRGVwcyA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKG9yaWdpbmFsRGVwcywgZnVuY3Rpb24gKGRlcCkge1xuICAgICAgenJVdGlsLmluZGV4T2YoZnVsbE5hbWVMaXN0LCBkZXApID49IDAgJiYgYXZhaWxhYmxlRGVwcy5wdXNoKGRlcCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGF2YWlsYWJsZURlcHM7XG4gIH1cbn1cblxuZXhwb3J0cy5nZXRVSUQgPSBnZXRVSUQ7XG5leHBvcnRzLmVuYWJsZVN1YlR5cGVEZWZhdWx0ZXIgPSBlbmFibGVTdWJUeXBlRGVmYXVsdGVyO1xuZXhwb3J0cy5lbmFibGVUb3BvbG9naWNhbFRyYXZlbCA9IGVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvY29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9ycyA9IHt9O1xuXG5mdW5jdGlvbiBDb29yZGluYXRlU3lzdGVtTWFuYWdlcigpIHtcbiAgdGhpcy5fY29vcmRpbmF0ZVN5c3RlbXMgPSBbXTtcbn1cblxuQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIsXG4gIGNyZWF0ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb29yZGluYXRlU3lzdGVtcyA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9ycywgZnVuY3Rpb24gKGNyZWF0ZXIsIHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ID0gY3JlYXRlci5jcmVhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICAgIGNvb3JkaW5hdGVTeXN0ZW1zID0gY29vcmRpbmF0ZVN5c3RlbXMuY29uY2F0KGxpc3QgfHwgW10pO1xuICAgIH0pO1xuICAgIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zID0gY29vcmRpbmF0ZVN5c3RlbXM7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zLCBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgIC8vIEZJWE1FIE1VU1QgaGF2ZVxuICAgICAgY29vcmRTeXMudXBkYXRlICYmIGNvb3JkU3lzLnVwZGF0ZShlY01vZGVsLCBhcGkpO1xuICAgIH0pO1xuICB9LFxuICBnZXRDb29yZGluYXRlU3lzdGVtczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlU3lzdGVtcy5zbGljZSgpO1xuICB9XG59O1xuXG5Db29yZGluYXRlU3lzdGVtTWFuYWdlci5yZWdpc3RlciA9IGZ1bmN0aW9uICh0eXBlLCBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcikge1xuICBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnNbdHlwZV0gPSBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcjtcbn07XG5cbkNvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLmdldCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnNbdHlwZV07XG59O1xuXG52YXIgX2RlZmF1bHQgPSBDb29yZGluYXRlU3lzdGVtTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvQ29vcmRpbmF0ZVN5c3RlbS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBfZm9ybWF0ID0gcmVxdWlyZShcIi4uL3V0aWwvZm9ybWF0XCIpO1xuXG52YXIgZm9ybWF0VGltZSA9IF9mb3JtYXQuZm9ybWF0VGltZTtcbnZhciBlbmNvZGVIVE1MID0gX2Zvcm1hdC5lbmNvZGVIVE1MO1xudmFyIGFkZENvbW1hcyA9IF9mb3JtYXQuYWRkQ29tbWFzO1xudmFyIGdldFRvb2x0aXBNYXJrZXIgPSBfZm9ybWF0LmdldFRvb2x0aXBNYXJrZXI7XG5cbnZhciBfY2xhenogPSByZXF1aXJlKFwiLi4vdXRpbC9jbGF6elwiKTtcblxudmFyIHNldCA9IF9jbGF6ei5zZXQ7XG52YXIgZ2V0ID0gX2NsYXp6LmdldDtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21vZGVsXCIpO1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKFwiLi9Db21wb25lbnRcIik7XG5cbnZhciBjb2xvclBhbGV0dGVNaXhpbiA9IHJlcXVpcmUoXCIuL21peGluL2NvbG9yUGFsZXR0ZVwiKTtcblxudmFyIF9sYXlvdXQgPSByZXF1aXJlKFwiLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBnZXRMYXlvdXRQYXJhbXMgPSBfbGF5b3V0LmdldExheW91dFBhcmFtcztcbnZhciBtZXJnZUxheW91dFBhcmFtID0gX2xheW91dC5tZXJnZUxheW91dFBhcmFtO1xudmFyIFNlcmllc01vZGVsID0gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ3Nlcmllcy5fX2Jhc2VfXycsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgc2VyaWVzSW5kZXg6IDAsXG4gIC8vIGNvb2RpbmF0ZVN5c3RlbSB3aWxsIGJlIGluamVjdGVkIGluIHRoZSBlY2hhcnRzL0Nvb3JkaW5hdGVTeXN0ZW1cbiAgY29vcmRpbmF0ZVN5c3RlbTogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZGVmYXVsdE9wdGlvbjogbnVsbCxcblxuICAvKipcbiAgICogRGF0YSBwcm92aWRlZCBmb3IgbGVnZW5kXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8vIFBFTkRJTkdcbiAgbGVnZW5kRGF0YVByb3ZpZGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBY2Nlc3MgcGF0aCBvZiBjb2xvciBmb3IgdmlzdWFsXG4gICAqL1xuICB2aXN1YWxDb2xvckFjY2Vzc1BhdGg6ICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJyxcblxuICAvKipcbiAgICogU3VwcG9ydCBtZXJnZSBsYXlvdXQgcGFyYW1zLlxuICAgKiBPbmx5IHN1cHBvcnQgJ2JveCcgbm93IChsZWZ0L3JpZ2h0L3RvcC9ib3R0b20vd2lkdGgvaGVpZ2h0KS5cbiAgICogQHR5cGUge3N0cmluZ3xPYmplY3R9IE9iamVjdCBjYW4gYmUge2lnbm9yZVNpemU6IHRydWV9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgbGF5b3V0TW9kZTogbnVsbCxcbiAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnNlcmllc0luZGV4ID0gdGhpcy5jb21wb25lbnRJbmRleDtcbiAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldEluaXRpYWxEYXRhKG9wdGlvbiwgZWNNb2RlbCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fG1vZHVsZTplY2hhcnRzL2RhdGEvVHJlZXxtb2R1bGU6ZWNoYXJ0cy9kYXRhL0dyYXBofVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0KHRoaXMsICdkYXRhQmVmb3JlUHJvY2Vzc2VkJywgZGF0YSk7IC8vIElmIHdlIHJldmVyc2UgdGhlIG9yZGVyIChtYWtlIGRhdGEgZmlyc3RseSwgYW5kIHRoZW4gbWFrZVxuICAgIC8vIGRhdGFCZWZvcmVQcm9jZXNzZWQgYnkgY2xvbmVTaGFsbG93KSwgY2xvbmVTaGFsbG93IHdpbGxcbiAgICAvLyBjYXVzZSBkYXRhLmdyYXBoLmRhdGEgIT09IGRhdGEgd2hlbiB1c2luZ1xuICAgIC8vIG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGggb3IgbW9kdWxlOmVjaGFydHMvZGF0YS9UcmVlLlxuICAgIC8vIFNlZSBtb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9saW5rTGlzdFxuXG4gICAgdGhpcy5yZXN0b3JlRGF0YSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVdGlsIGZvciBtZXJnZSBkZWZhdWx0IGFuZCB0aGVtZSB0byBvcHRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25cbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqL1xuICBtZXJnZURlZmF1bHRBbmRUaGVtZTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0TW9kZSA/IGdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307IC8vIEJhY2t3YXJkIGNvbXBhdDogdXNpbmcgc3ViVHlwZSBvbiB0aGVtZS5cbiAgICAvLyBCdXQgaWYgbmFtZSBkdXBsaWNhdGUgYmV0d2VlbiBzZXJpZXMgc3ViVHlwZVxuICAgIC8vIChmb3IgZXhhbXBsZTogcGFyYWxsZWwpIGFkZCBjb21wb25lbnQgbWFpblR5cGUsXG4gICAgLy8gYWRkIHN1ZmZpeCAnU2VyaWVzJy5cblxuICAgIHZhciB0aGVtZVN1YlR5cGUgPSB0aGlzLnN1YlR5cGU7XG5cbiAgICBpZiAoQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3ModGhlbWVTdWJUeXBlKSkge1xuICAgICAgdGhlbWVTdWJUeXBlICs9ICdTZXJpZXMnO1xuICAgIH1cblxuICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIGVjTW9kZWwuZ2V0VGhlbWUoKS5nZXQodGhpcy5zdWJUeXBlKSk7XG4gICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpOyAvLyBEZWZhdWx0IGxhYmVsIGVtcGhhc2lzIGBzaG93YFxuXG4gICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhvcHRpb24ubGFiZWwsIFsnc2hvdyddKTtcbiAgICB0aGlzLmZpbGxEYXRhVGV4dFN0eWxlKG9wdGlvbi5kYXRhKTtcblxuICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICBtZXJnZUxheW91dFBhcmFtKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcywgbGF5b3V0TW9kZSk7XG4gICAgfVxuICB9LFxuICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld1Nlcmllc09wdGlvbiwgZWNNb2RlbCkge1xuICAgIG5ld1Nlcmllc09wdGlvbiA9IHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgbmV3U2VyaWVzT3B0aW9uLCB0cnVlKTtcbiAgICB0aGlzLmZpbGxEYXRhVGV4dFN0eWxlKG5ld1Nlcmllc09wdGlvbi5kYXRhKTtcbiAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcblxuICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICBtZXJnZUxheW91dFBhcmFtKHRoaXMub3B0aW9uLCBuZXdTZXJpZXNPcHRpb24sIGxheW91dE1vZGUpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gdGhpcy5nZXRJbml0aWFsRGF0YShuZXdTZXJpZXNPcHRpb24sIGVjTW9kZWwpOyAvLyBUT0RPIE1lcmdlIGRhdGE/XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgc2V0KHRoaXMsICdkYXRhJywgZGF0YSk7XG4gICAgICBzZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnLCBkYXRhLmNsb25lU2hhbGxvdygpKTtcbiAgICB9XG4gIH0sXG4gIGZpbGxEYXRhVGV4dFN0eWxlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIERlZmF1bHQgZGF0YSBsYWJlbCBlbXBoYXNpcyBgc2hvd2BcbiAgICAvLyBGSVhNRSBUcmVlIHN0cnVjdHVyZSBkYXRhID9cbiAgICAvLyBGSVhNRSBQZXJmb3JtYW5jZSA/XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHZhciBwcm9wcyA9IFsnc2hvdyddO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbaV0gJiYgZGF0YVtpXS5sYWJlbCkge1xuICAgICAgICAgIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMoZGF0YVtpXS5sYWJlbCwgcHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0IGEgZGF0YSBzdHJ1Y3R1cmUgZnJvbSBkYXRhIHJlbGF0ZWQgb3B0aW9uIGluIHNlcmllc1xuICAgKiBNdXN0IGJlIG92ZXJ3cml0dGVuXG4gICAqL1xuICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH1cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uIChkYXRhVHlwZSkge1xuICAgIHZhciBkYXRhID0gZ2V0KHRoaXMsICdkYXRhJyk7XG4gICAgcmV0dXJuIGRhdGFUeXBlID09IG51bGwgPyBkYXRhIDogZGF0YS5nZXRMaW5rZWREYXRhKGRhdGFUeXBlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICovXG4gIHNldERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2V0KHRoaXMsICdkYXRhJywgZGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBkYXRhIGJlZm9yZSBwcm9jZXNzZWRcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fVxuICAgKi9cbiAgZ2V0UmF3RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29vcmQgZGltZW5zaW9uIHRvIGRhdGEgZGltZW5zaW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoZSByZXN1bHQgaXMgdGhlIHNhbWUgYXMgZGltZW5zaW9ucyBvZiBzZXJpZXMgZGF0YS5cbiAgICogQnV0IGluIHNvbWUgc2VyaWVzIGRhdGEgZGltZW5zaW9ucyBhcmUgZGlmZmVyZW50IGZyb20gY29vcmQgZGltZW5zaW9ucyAoaS5lLlxuICAgKiBjYW5kbGVzdGljayBhbmQgYm94cGxvdCkuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGhhbmRsZSB0aG9zZSBjYXNlcy5cbiAgICpcbiAgICogQ29vcmQgZGltZW5zaW9uIHRvIGRhdGEgZGltZW5zaW9uIGNhbiBiZSBvbmUtdG8tbWFueVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmREaW1cbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnMgb24gdGhlIGF4aXMuXG4gICAqL1xuICBjb29yZERpbVRvRGF0YURpbTogZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgcmV0dXJuIG1vZGVsVXRpbC5jb29yZERpbVRvRGF0YURpbSh0aGlzLmdldERhdGEoKSwgY29vcmREaW0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGRhdGEgZGltZW5zaW9uIHRvIGNvb3JkIGRpbWVuc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkYXRhRGltXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGRhdGFEaW1Ub0Nvb3JkRGltOiBmdW5jdGlvbiAoZGF0YURpbSkge1xuICAgIHJldHVybiBtb2RlbFV0aWwuZGF0YURpbVRvQ29vcmREaW0odGhpcy5nZXREYXRhKCksIGRhdGFEaW0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYmFzZSBheGlzIGlmIGhhcyBjb29yZGluYXRlIHN5c3RlbSBhbmQgaGFzIGF4aXMuXG4gICAqIEJ5IGRlZmF1bHQgdXNlIGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAqIENhbiBiZSBvdmVycmlkZWQgZm9yIHNvbWUgY2hhcnQuXG4gICAqIEByZXR1cm4ge3R5cGV9IGRlc2NyaXB0aW9uXG4gICAqL1xuICBnZXRCYXNlQXhpczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICByZXR1cm4gY29vcmRTeXMgJiYgY29vcmRTeXMuZ2V0QmFzZUF4aXMgJiYgY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgfSxcbiAgLy8gRklYTUVcblxuICAvKipcbiAgICogRGVmYXVsdCB0b29sdGlwIGZvcm1hdHRlclxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211bHRpcGxlU2VyaWVzPWZhbHNlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFUeXBlXVxuICAgKi9cbiAgZm9ybWF0VG9vbHRpcDogZnVuY3Rpb24gKGRhdGFJbmRleCwgbXVsdGlwbGVTZXJpZXMsIGRhdGFUeXBlKSB7XG4gICAgZnVuY3Rpb24gZm9ybWF0QXJyYXlWYWx1ZSh2YWx1ZSkge1xuICAgICAgdmFyIHZlcnRpYWxseSA9IHpyVXRpbC5yZWR1Y2UodmFsdWUsIGZ1bmN0aW9uICh2ZXJ0aWFsbHksIHZhbCwgaWR4KSB7XG4gICAgICAgIHZhciBkaW1JdGVtID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGlkeCk7XG4gICAgICAgIHJldHVybiB2ZXJ0aWFsbHkgfD0gZGltSXRlbSAmJiBkaW1JdGVtLnRvb2x0aXAgIT09IGZhbHNlICYmIGRpbUl0ZW0udG9vbHRpcE5hbWUgIT0gbnVsbDtcbiAgICAgIH0sIDApO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHRvb2x0aXBEaW1zID0gbW9kZWxVdGlsLm90aGVyRGltVG9EYXRhRGltKGRhdGEsICd0b29sdGlwJyk7XG4gICAgICB0b29sdGlwRGltcy5sZW5ndGggPyB6clV0aWwuZWFjaCh0b29sdGlwRGltcywgZnVuY3Rpb24gKGRpbUlkeCkge1xuICAgICAgICBzZXRFYWNoSXRlbShkYXRhLmdldChkaW1JZHgsIGRhdGFJbmRleCksIGRpbUlkeCk7XG4gICAgICB9KSAvLyBCeSBkZWZhdWx0LCBhbGwgZGltcyBpcyB1c2VkIG9uIHRvb2x0aXAuXG4gICAgICA6IHpyVXRpbC5lYWNoKHZhbHVlLCBzZXRFYWNoSXRlbSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldEVhY2hJdGVtKHZhbCwgZGltSWR4KSB7XG4gICAgICAgIHZhciBkaW1JbmZvID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbUlkeCk7IC8vIElmIGBkaW1JbmZvLnRvb2x0aXBgIGlzIG5vdCBzZXQsIHNob3cgdG9vbHRpcC5cblxuICAgICAgICBpZiAoIWRpbUluZm8gfHwgZGltSW5mby5vdGhlckRpbXMudG9vbHRpcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGltVHlwZSA9IGRpbUluZm8udHlwZTtcbiAgICAgICAgdmFyIHZhbFN0ciA9ICh2ZXJ0aWFsbHkgPyAnLSAnICsgKGRpbUluZm8udG9vbHRpcE5hbWUgfHwgZGltSW5mby5uYW1lKSArICc6ICcgOiAnJykgKyAoZGltVHlwZSA9PT0gJ29yZGluYWwnID8gdmFsICsgJycgOiBkaW1UeXBlID09PSAndGltZScgPyBtdWx0aXBsZVNlcmllcyA/ICcnIDogZm9ybWF0VGltZSgneXl5eS9NTS9kZCBoaDptbTpzcycsIHZhbCkgOiBhZGRDb21tYXModmFsKSk7XG4gICAgICAgIHZhbFN0ciAmJiByZXN1bHQucHVzaChlbmNvZGVIVE1MKHZhbFN0cikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKHZlcnRpYWxseSA/ICc8YnIvPicgOiAnJykgKyByZXN1bHQuam9pbih2ZXJ0aWFsbHkgPyAnPGJyLz4nIDogJywgJyk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSBnZXQodGhpcywgJ2RhdGEnKTtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCk7XG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlID0genJVdGlsLmlzQXJyYXkodmFsdWUpID8gZm9ybWF0QXJyYXlWYWx1ZSh2YWx1ZSkgOiBlbmNvZGVIVE1MKGFkZENvbW1hcyh2YWx1ZSkpO1xuICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ2NvbG9yJyk7XG5cbiAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGNvbG9yKSAmJiBjb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICBjb2xvciA9IChjb2xvci5jb2xvclN0b3BzWzBdIHx8IHt9KS5jb2xvcjtcbiAgICB9XG5cbiAgICBjb2xvciA9IGNvbG9yIHx8ICd0cmFuc3BhcmVudCc7XG4gICAgdmFyIGNvbG9yRWwgPSBnZXRUb29sdGlwTWFya2VyKGNvbG9yKTtcbiAgICB2YXIgc2VyaWVzTmFtZSA9IHRoaXMubmFtZTsgLy8gRklYTUVcblxuICAgIGlmIChzZXJpZXNOYW1lID09PSAnXFwwLScpIHtcbiAgICAgIC8vIE5vdCBzaG93ICctJ1xuICAgICAgc2VyaWVzTmFtZSA9ICcnO1xuICAgIH1cblxuICAgIHNlcmllc05hbWUgPSBzZXJpZXNOYW1lID8gZW5jb2RlSFRNTChzZXJpZXNOYW1lKSArICghbXVsdGlwbGVTZXJpZXMgPyAnPGJyLz4nIDogJzogJykgOiAnJztcbiAgICByZXR1cm4gIW11bHRpcGxlU2VyaWVzID8gc2VyaWVzTmFtZSArIGNvbG9yRWwgKyAobmFtZSA/IGVuY29kZUhUTUwobmFtZSkgKyAnOiAnICsgZm9ybWF0dGVkVmFsdWUgOiBmb3JtYXR0ZWRWYWx1ZSkgOiBjb2xvckVsICsgc2VyaWVzTmFtZSArIGZvcm1hdHRlZFZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBbmltYXRpb25FbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdGlvbkVuYWJsZWQgPSB0aGlzLmdldFNoYWxsb3coJ2FuaW1hdGlvbicpO1xuXG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgIGlmICh0aGlzLmdldERhdGEoKS5jb3VudCgpID4gdGhpcy5nZXRTaGFsbG93KCdhbmltYXRpb25UaHJlc2hvbGQnKSkge1xuICAgICAgICBhbmltYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbkVuYWJsZWQ7XG4gIH0sXG4gIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgc2V0KHRoaXMsICdkYXRhJywgZ2V0KHRoaXMsICdkYXRhQmVmb3JlUHJvY2Vzc2VkJykuY2xvbmVTaGFsbG93KCkpO1xuICB9LFxuICBnZXRDb2xvckZyb21QYWxldHRlOiBmdW5jdGlvbiAobmFtZSwgc2NvcGUpIHtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDsgLy8gUEVORElOR1xuXG4gICAgdmFyIGNvbG9yID0gY29sb3JQYWxldHRlTWl4aW4uZ2V0Q29sb3JGcm9tUGFsZXR0ZS5jYWxsKHRoaXMsIG5hbWUsIHNjb3BlKTtcblxuICAgIGlmICghY29sb3IpIHtcbiAgICAgIGNvbG9yID0gZWNNb2RlbC5nZXRDb2xvckZyb21QYWxldHRlKG5hbWUsIHNjb3BlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBkYXRhIGluZGljZXMgZm9yIHNob3cgdG9vbHRpcCBjb250ZW50LiBTZWUgdG9vbHRpcC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBkaW1cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9zaW5nbGUvU2luZ2xlQXhpc30gYmFzZUF4aXNcbiAgICogQHJldHVybiB7T2JqZWN0fSB7ZGF0YUluZGljZXMsIG5lc3Rlc3RWYWx1ZX0uXG4gICAqL1xuICBnZXRBeGlzVG9vbHRpcERhdGE6IG51bGwsXG5cbiAgLyoqXG4gICAqIFNlZSB0b29sdGlwLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gUG9pbnQgb2YgdG9vbHRpcC4gbnVsbC91bmRlZmluZWQgY2FuIGJlIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0VG9vbHRpcFBvc2l0aW9uOiBudWxsXG59KTtcbnpyVXRpbC5taXhpbihTZXJpZXNNb2RlbCwgbW9kZWxVdGlsLmRhdGFGb3JtYXRNaXhpbik7XG56clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIGNvbG9yUGFsZXR0ZU1peGluKTtcbnZhciBfZGVmYXVsdCA9IFNlcmllc01vZGVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9TZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgTGlzdCA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL0xpc3RcIik7XG5cbnZhciBjb21wbGV0ZURpbWVuc2lvbnMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zXCIpO1xuXG52YXIgX21vZGVsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBnZXREYXRhSXRlbVZhbHVlID0gX21vZGVsLmdldERhdGFJdGVtVmFsdWU7XG52YXIgY29udmVyRGF0YVZhbHVlID0gX21vZGVsLmNvbnZlckRhdGFWYWx1ZTtcbnZhciBpc0RhdGFJdGVtT3B0aW9uID0gX21vZGVsLmlzRGF0YUl0ZW1PcHRpb247XG5cbnZhciBDb29yZGluYXRlU3lzdGVtID0gcmVxdWlyZShcIi4uLy4uL0Nvb3JkaW5hdGVTeXN0ZW1cIik7XG5cbmZ1bmN0aW9uIGZpcnN0RGF0YU5vdE51bGwoZGF0YSkge1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCAmJiBkYXRhW2ldID09IG51bGwpIHtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gZGF0YVtpXTtcbn1cblxuZnVuY3Rpb24gaWZOZWVkQ29tcGxldGVPcmRpbmFsRGF0YShkYXRhKSB7XG4gIHZhciBzYW1wbGVJdGVtID0gZmlyc3REYXRhTm90TnVsbChkYXRhKTtcbiAgcmV0dXJuIHNhbXBsZUl0ZW0gIT0gbnVsbCAmJiAhenJVdGlsLmlzQXJyYXkoZ2V0RGF0YUl0ZW1WYWx1ZShzYW1wbGVJdGVtKSk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBsaXN0IGZyb20gb3B0aW9uIGRhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RGcm9tQXJyYXkoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgLy8gSWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgZGF0YSA9IGRhdGEgfHwgW107XG4gIHZhciBjb29yZFN5c05hbWUgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgdmFyIGNyZWF0b3IgPSBjcmVhdG9yc1tjb29yZFN5c05hbWVdO1xuICB2YXIgcmVnaXN0ZXJlZENvb3JkU3lzID0gQ29vcmRpbmF0ZVN5c3RlbS5nZXQoY29vcmRTeXNOYW1lKTtcbiAgdmFyIGNvbXBsZXRlRGltT3B0ID0ge1xuICAgIGVuY29kZURlZjogc2VyaWVzTW9kZWwuZ2V0KCdlbmNvZGUnKSxcbiAgICBkaW1zRGVmOiBzZXJpZXNNb2RlbC5nZXQoJ2RpbWVuc2lvbnMnKVxuICB9OyAvLyBGSVhNRVxuXG4gIHZhciBheGVzSW5mbyA9IGNyZWF0b3IgJiYgY3JlYXRvcihkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgY29tcGxldGVEaW1PcHQpO1xuICB2YXIgZGltZW5zaW9ucyA9IGF4ZXNJbmZvICYmIGF4ZXNJbmZvLmRpbWVuc2lvbnM7XG5cbiAgaWYgKCFkaW1lbnNpb25zKSB7XG4gICAgLy8gR2V0IGRpbWVuc2lvbnMgZnJvbSByZWdpc3RlcmVkIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgZGltZW5zaW9ucyA9IHJlZ2lzdGVyZWRDb29yZFN5cyAmJiAocmVnaXN0ZXJlZENvb3JkU3lzLmdldERpbWVuc2lvbnNJbmZvID8gcmVnaXN0ZXJlZENvb3JkU3lzLmdldERpbWVuc2lvbnNJbmZvKCkgOiByZWdpc3RlcmVkQ29vcmRTeXMuZGltZW5zaW9ucy5zbGljZSgpKSB8fCBbJ3gnLCAneSddO1xuICAgIGRpbWVuc2lvbnMgPSBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgY29tcGxldGVEaW1PcHQpO1xuICB9XG5cbiAgdmFyIGNhdGVnb3J5SW5kZXggPSBheGVzSW5mbyA/IGF4ZXNJbmZvLmNhdGVnb3J5SW5kZXggOiAtMTtcbiAgdmFyIGxpc3QgPSBuZXcgTGlzdChkaW1lbnNpb25zLCBzZXJpZXNNb2RlbCk7XG4gIHZhciBuYW1lTGlzdCA9IGNyZWF0ZU5hbWVMaXN0KGF4ZXNJbmZvLCBkYXRhKTtcbiAgdmFyIGNhdGVnb3JpZXMgPSB7fTtcbiAgdmFyIGRpbVZhbHVlR2V0dGVyID0gY2F0ZWdvcnlJbmRleCA+PSAwICYmIGlmTmVlZENvbXBsZXRlT3JkaW5hbERhdGEoZGF0YSkgPyBmdW5jdGlvbiAoaXRlbU9wdCwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgIC8vIElmIGFueSBkYXRhSXRlbSBpcyBsaWtlIHsgdmFsdWU6IDEwIH1cbiAgICBpZiAoaXNEYXRhSXRlbU9wdGlvbihpdGVtT3B0KSkge1xuICAgICAgbGlzdC5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICB9IC8vIFVzZSBkYXRhSW5kZXggYXMgb3JkaW5hbCB2YWx1ZSBpbiBjYXRlZ29yeUF4aXNcblxuXG4gICAgcmV0dXJuIGRpbUluZGV4ID09PSBjYXRlZ29yeUluZGV4ID8gZGF0YUluZGV4IDogY29udmVyRGF0YVZhbHVlKGdldERhdGFJdGVtVmFsdWUoaXRlbU9wdCksIGRpbWVuc2lvbnNbZGltSW5kZXhdKTtcbiAgfSA6IGZ1bmN0aW9uIChpdGVtT3B0LCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0RGF0YUl0ZW1WYWx1ZShpdGVtT3B0KTtcbiAgICB2YXIgdmFsID0gY29udmVyRGF0YVZhbHVlKHZhbHVlICYmIHZhbHVlW2RpbUluZGV4XSwgZGltZW5zaW9uc1tkaW1JbmRleF0pOyAvLyBJZiBhbnkgZGF0YUl0ZW0gaXMgbGlrZSB7IHZhbHVlOiAxMCB9XG5cbiAgICBpZiAoaXNEYXRhSXRlbU9wdGlvbihpdGVtT3B0KSkge1xuICAgICAgbGlzdC5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2F0ZWdvcnlBeGVzTW9kZWxzID0gYXhlc0luZm8gJiYgYXhlc0luZm8uY2F0ZWdvcnlBeGVzTW9kZWxzO1xuXG4gICAgaWYgKGNhdGVnb3J5QXhlc01vZGVscyAmJiBjYXRlZ29yeUF4ZXNNb2RlbHNbZGltTmFtZV0pIHtcbiAgICAgIC8vIElmIGdpdmVuIHZhbHVlIGlzIGEgY2F0ZWdvcnkgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gTGF6eSBnZXQgY2F0ZWdvcmllc1xuICAgICAgICBjYXRlZ29yaWVzW2RpbU5hbWVdID0gY2F0ZWdvcmllc1tkaW1OYW1lXSB8fCBjYXRlZ29yeUF4ZXNNb2RlbHNbZGltTmFtZV0uZ2V0Q2F0ZWdvcmllcygpO1xuICAgICAgICB2YWwgPSB6clV0aWwuaW5kZXhPZihjYXRlZ29yaWVzW2RpbU5hbWVdLCB2YWwpO1xuXG4gICAgICAgIGlmICh2YWwgPCAwICYmICFpc05hTih2YWwpKSB7XG4gICAgICAgICAgLy8gSW4gY2FzZSBzb21lIG9uZSB3cml0ZSAnMScsICcyJyBpc3RlYWQgb2YgMSwgMlxuICAgICAgICAgIHZhbCA9ICt2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9O1xuICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSBmYWxzZTtcbiAgbGlzdC5pbml0RGF0YShkYXRhLCBuYW1lTGlzdCwgZGltVmFsdWVHZXR0ZXIpO1xuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gaXNTdGFja2FibGUoYXhpc1R5cGUpIHtcbiAgcmV0dXJuIGF4aXNUeXBlICE9PSAnY2F0ZWdvcnknICYmIGF4aXNUeXBlICE9PSAndGltZSc7XG59XG5cbmZ1bmN0aW9uIGdldERpbVR5cGVCeUF4aXMoYXhpc1R5cGUpIHtcbiAgcmV0dXJuIGF4aXNUeXBlID09PSAnY2F0ZWdvcnknID8gJ29yZGluYWwnIDogYXhpc1R5cGUgPT09ICd0aW1lJyA/ICd0aW1lJyA6ICdmbG9hdCc7XG59XG4vKipcbiAqIENyZWF0ZXJzIGZvciBlYWNoIGNvb3JkIHN5c3RlbS5cbiAqL1xuXG5cbnZhciBjcmVhdG9ycyA9IHtcbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgY29tcGxldGVEaW1PcHQpIHtcbiAgICB2YXIgYXhlc01vZGVscyA9IHpyVXRpbC5tYXAoWyd4QXhpcycsICd5QXhpcyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgbWFpblR5cGU6IG5hbWUsXG4gICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQobmFtZSArICdJbmRleCcpLFxuICAgICAgICBpZDogc2VyaWVzTW9kZWwuZ2V0KG5hbWUgKyAnSWQnKVxuICAgICAgfSlbMF07XG4gICAgfSk7XG4gICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzBdO1xuICAgIHZhciB5QXhpc01vZGVsID0gYXhlc01vZGVsc1sxXTtcbiAgICB2YXIgeEF4aXNUeXBlID0geEF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgeUF4aXNUeXBlID0geUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgZGltZW5zaW9ucyA9IFt7XG4gICAgICBuYW1lOiAneCcsXG4gICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHhBeGlzVHlwZSksXG4gICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHhBeGlzVHlwZSlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAneScsXG4gICAgICAvLyBJZiB0d28gY2F0ZWdvcnkgYXhlc1xuICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyh5QXhpc1R5cGUpLFxuICAgICAgc3RhY2thYmxlOiBpc1N0YWNrYWJsZSh5QXhpc1R5cGUpXG4gICAgfV07XG4gICAgdmFyIGlzWEF4aXNDYXRlb2dyeSA9IHhBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICB2YXIgaXNZQXhpc0NhdGVnb3J5ID0geUF4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuICAgIGRpbWVuc2lvbnMgPSBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgY29tcGxldGVEaW1PcHQpO1xuICAgIHZhciBjYXRlZ29yeUF4ZXNNb2RlbHMgPSB7fTtcblxuICAgIGlmIChpc1hBeGlzQ2F0ZW9ncnkpIHtcbiAgICAgIGNhdGVnb3J5QXhlc01vZGVscy54ID0geEF4aXNNb2RlbDtcbiAgICB9XG5cbiAgICBpZiAoaXNZQXhpc0NhdGVnb3J5KSB7XG4gICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMueSA9IHlBeGlzTW9kZWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICBjYXRlZ29yeUluZGV4OiBpc1hBeGlzQ2F0ZW9ncnkgPyAwIDogaXNZQXhpc0NhdGVnb3J5ID8gMSA6IC0xLFxuICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzOiBjYXRlZ29yeUF4ZXNNb2RlbHNcbiAgICB9O1xuICB9LFxuICBzaW5nbGVBeGlzOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGNvbXBsZXRlRGltT3B0KSB7XG4gICAgdmFyIHNpbmdsZUF4aXNNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgIG1haW5UeXBlOiAnc2luZ2xlQXhpcycsXG4gICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KCdzaW5nbGVBeGlzSW5kZXgnKSxcbiAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoJ3NpbmdsZUF4aXNJZCcpXG4gICAgfSlbMF07XG4gICAgdmFyIHNpbmdsZUF4aXNUeXBlID0gc2luZ2xlQXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgIHZhciBpc0NhdGVnb3J5ID0gc2luZ2xlQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSBbe1xuICAgICAgbmFtZTogJ3NpbmdsZScsXG4gICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHNpbmdsZUF4aXNUeXBlKSxcbiAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoc2luZ2xlQXhpc1R5cGUpXG4gICAgfV07XG4gICAgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBjb21wbGV0ZURpbU9wdCk7XG4gICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuXG4gICAgaWYgKGlzQ2F0ZWdvcnkpIHtcbiAgICAgIGNhdGVnb3J5QXhlc01vZGVscy5zaW5nbGUgPSBzaW5nbGVBeGlzTW9kZWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICBjYXRlZ29yeUluZGV4OiBpc0NhdGVnb3J5ID8gMCA6IC0xLFxuICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzOiBjYXRlZ29yeUF4ZXNNb2RlbHNcbiAgICB9O1xuICB9LFxuICBwb2xhcjogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsLCBjb21wbGV0ZURpbU9wdCkge1xuICAgIHZhciBwb2xhck1vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgbWFpblR5cGU6ICdwb2xhcicsXG4gICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KCdwb2xhckluZGV4JyksXG4gICAgICBpZDogc2VyaWVzTW9kZWwuZ2V0KCdwb2xhcklkJylcbiAgICB9KVswXTtcbiAgICB2YXIgYW5nbGVBeGlzTW9kZWwgPSBwb2xhck1vZGVsLmZpbmRBeGlzTW9kZWwoJ2FuZ2xlQXhpcycpO1xuICAgIHZhciByYWRpdXNBeGlzTW9kZWwgPSBwb2xhck1vZGVsLmZpbmRBeGlzTW9kZWwoJ3JhZGl1c0F4aXMnKTtcbiAgICB2YXIgcmFkaXVzQXhpc1R5cGUgPSByYWRpdXNBeGlzTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgdmFyIGFuZ2xlQXhpc1R5cGUgPSBhbmdsZUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgZGltZW5zaW9ucyA9IFt7XG4gICAgICBuYW1lOiAncmFkaXVzJyxcbiAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMocmFkaXVzQXhpc1R5cGUpLFxuICAgICAgc3RhY2thYmxlOiBpc1N0YWNrYWJsZShyYWRpdXNBeGlzVHlwZSlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYW5nbGUnLFxuICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyhhbmdsZUF4aXNUeXBlKSxcbiAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoYW5nbGVBeGlzVHlwZSlcbiAgICB9XTtcbiAgICB2YXIgaXNBbmdsZUF4aXNDYXRlb2dyeSA9IGFuZ2xlQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgdmFyIGlzUmFkaXVzQXhpc0NhdGVvZ3J5ID0gcmFkaXVzQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBjb21wbGV0ZURpbU9wdCk7XG4gICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuXG4gICAgaWYgKGlzUmFkaXVzQXhpc0NhdGVvZ3J5KSB7XG4gICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMucmFkaXVzID0gcmFkaXVzQXhpc01vZGVsO1xuICAgIH1cblxuICAgIGlmIChpc0FuZ2xlQXhpc0NhdGVvZ3J5KSB7XG4gICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMuYW5nbGUgPSBhbmdsZUF4aXNNb2RlbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgIGNhdGVnb3J5SW5kZXg6IGlzQW5nbGVBeGlzQ2F0ZW9ncnkgPyAxIDogaXNSYWRpdXNBeGlzQ2F0ZW9ncnkgPyAwIDogLTEsXG4gICAgICBjYXRlZ29yeUF4ZXNNb2RlbHM6IGNhdGVnb3J5QXhlc01vZGVsc1xuICAgIH07XG4gIH0sXG4gIGdlbzogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsLCBjb21wbGV0ZURpbU9wdCkge1xuICAgIC8vIFRPRE8gUmVnaW9uXG4gICAgLy8g5aSa5Liq5pWj54K55Zu+57O75YiX5Zyo5ZCM5LiA5Liq5Zyw5Yy655qE5pe25YCZXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpbWVuc2lvbnM6IGNvbXBsZXRlRGltZW5zaW9ucyhbe1xuICAgICAgICBuYW1lOiAnbG5nJ1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnbGF0J1xuICAgICAgfV0sIGRhdGEsIGNvbXBsZXRlRGltT3B0KVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU5hbWVMaXN0KHJlc3VsdCwgZGF0YSkge1xuICB2YXIgbmFtZUxpc3QgPSBbXTtcbiAgdmFyIGNhdGVnb3J5RGltID0gcmVzdWx0ICYmIHJlc3VsdC5kaW1lbnNpb25zW3Jlc3VsdC5jYXRlZ29yeUluZGV4XTtcbiAgdmFyIGNhdGVnb3J5QXhpc01vZGVsO1xuXG4gIGlmIChjYXRlZ29yeURpbSkge1xuICAgIGNhdGVnb3J5QXhpc01vZGVsID0gcmVzdWx0LmNhdGVnb3J5QXhlc01vZGVsc1tjYXRlZ29yeURpbS5uYW1lXTtcbiAgfVxuXG4gIGlmIChjYXRlZ29yeUF4aXNNb2RlbCkge1xuICAgIC8vIEZJWE1FIFR3byBjYXRlZ29yeSBheGlzXG4gICAgdmFyIGNhdGVnb3JpZXMgPSBjYXRlZ29yeUF4aXNNb2RlbC5nZXRDYXRlZ29yaWVzKCk7XG5cbiAgICBpZiAoY2F0ZWdvcmllcykge1xuICAgICAgdmFyIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgLy8gT3JkZXJlZCBkYXRhIGlzIGdpdmVuIGV4cGxpY2l0bHkgbGlrZVxuICAgICAgLy8gW1szLCAwLjJdLCBbMSwgMC4zXSwgWzIsIDAuMTVdXVxuICAgICAgLy8gb3IgZ2l2ZW4gc2NhdHRlciBkYXRhLFxuICAgICAgLy8gcGljayB0aGUgY2F0ZWdvcnlcblxuICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KGRhdGFbMF0pICYmIGRhdGFbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICBuYW1lTGlzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbjsgaSsrKSB7XG4gICAgICAgICAgbmFtZUxpc3RbaV0gPSBjYXRlZ29yaWVzW2RhdGFbaV1bcmVzdWx0LmNhdGVnb3J5SW5kZXggfHwgMF1dO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lTGlzdCA9IGNhdGVnb3JpZXMuc2xpY2UoMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWVMaXN0O1xufVxuXG52YXIgX2RlZmF1bHQgPSBjcmVhdGVMaXN0RnJvbUFycmF5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZnVuY3Rpb24gZGVmYXVsdEtleUdldHRlcihpdGVtKSB7XG4gIHJldHVybiBpdGVtO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBvbGRBcnJcbiAqIEBwYXJhbSB7QXJyYXl9IG5ld0FyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gb2xkS2V5R2V0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdLZXlHZXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ2FuIGJlIHZpc2l0ZWQgYnkgdGhpcy5jb250ZXh0IGluIGNhbGxiYWNrLlxuICovXG5cblxuZnVuY3Rpb24gRGF0YURpZmZlcihvbGRBcnIsIG5ld0Fyciwgb2xkS2V5R2V0dGVyLCBuZXdLZXlHZXR0ZXIsIGNvbnRleHQpIHtcbiAgdGhpcy5fb2xkID0gb2xkQXJyO1xuICB0aGlzLl9uZXcgPSBuZXdBcnI7XG4gIHRoaXMuX29sZEtleUdldHRlciA9IG9sZEtleUdldHRlciB8fCBkZWZhdWx0S2V5R2V0dGVyO1xuICB0aGlzLl9uZXdLZXlHZXR0ZXIgPSBuZXdLZXlHZXR0ZXIgfHwgZGVmYXVsdEtleUdldHRlcjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuRGF0YURpZmZlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEYXRhRGlmZmVyLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIGFkZCBhIGRhdGFcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB0aGlzLl9hZGQgPSBmdW5jO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIHVwZGF0ZSBhIGRhdGFcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB0aGlzLl91cGRhdGUgPSBmdW5jO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIHJlbW92ZSBhIGRhdGFcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB0aGlzLl9yZW1vdmUgPSBmdW5jO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBleGVjdXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9sZEFyciA9IHRoaXMuX29sZDtcbiAgICB2YXIgbmV3QXJyID0gdGhpcy5fbmV3O1xuICAgIHZhciBvbGREYXRhSW5kZXhNYXAgPSB7fTtcbiAgICB2YXIgbmV3RGF0YUluZGV4TWFwID0ge307XG4gICAgdmFyIG9sZERhdGFLZXlBcnIgPSBbXTtcbiAgICB2YXIgbmV3RGF0YUtleUFyciA9IFtdO1xuICAgIHZhciBpO1xuICAgIGluaXRJbmRleE1hcChvbGRBcnIsIG9sZERhdGFJbmRleE1hcCwgb2xkRGF0YUtleUFyciwgJ19vbGRLZXlHZXR0ZXInLCB0aGlzKTtcbiAgICBpbml0SW5kZXhNYXAobmV3QXJyLCBuZXdEYXRhSW5kZXhNYXAsIG5ld0RhdGFLZXlBcnIsICdfbmV3S2V5R2V0dGVyJywgdGhpcyk7IC8vIFRyYXZlbCBieSBpbnZlcnRlZCBvcmRlciB0byBtYWtlIHN1cmUgb3JkZXIgY29uc2lzdGVuY3lcbiAgICAvLyB3aGVuIGR1cGxpY2F0ZSBrZXlzIGV4aXN0cyAoY29uc2lkZXIgbmV3RGF0YUluZGV4LnBvcCgpIGJlbG93KS5cbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbiwgdGhlc2UgY29kZSBiZWxvdyBkbyBub3QgbG9vayBuZWF0LlxuXG4gICAgZm9yIChpID0gMDsgaSA8IG9sZEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IG9sZERhdGFLZXlBcnJbaV07XG4gICAgICB2YXIgaWR4ID0gbmV3RGF0YUluZGV4TWFwW2tleV07IC8vIGlkeCBjYW4gbmV2ZXIgYmUgZW1wdHkgYXJyYXkgaGVyZS4gc2VlICdzZXQgbnVsbCcgbG9naWMgYmVsb3cuXG5cbiAgICAgIGlmIChpZHggIT0gbnVsbCkge1xuICAgICAgICAvLyBDb25zaWRlciB0aGVyZSBpcyBkdXBsaWNhdGUga2V5IChmb3IgZXhhbXBsZSwgdXNlIGRhdGFJdGVtLm5hbWUgYXMga2V5KS5cbiAgICAgICAgLy8gV2Ugc2hvdWxkIG1ha2Ugc3VyZSBldmVyeSBpdGVtIGluIG5ld0FyciBhbmQgb2xkQXJyIGNhbiBiZSB2aXNpdGVkLlxuICAgICAgICB2YXIgbGVuID0gaWR4Lmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgbGVuID09PSAxICYmIChuZXdEYXRhSW5kZXhNYXBba2V5XSA9IG51bGwpO1xuICAgICAgICAgIGlkeCA9IGlkeC51bnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3RGF0YUluZGV4TWFwW2tleV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlICYmIHRoaXMuX3VwZGF0ZShpZHgsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlICYmIHRoaXMuX3JlbW92ZShpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGFLZXlBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBuZXdEYXRhS2V5QXJyW2ldO1xuXG4gICAgICBpZiAobmV3RGF0YUluZGV4TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIGlkeCA9IG5ld0RhdGFJbmRleE1hcFtrZXldO1xuXG4gICAgICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGlkeCBjYW4gbmV2ZXIgYmUgZW1wdHkgYXJyYXkgaGVyZS4gc2VlICdzZXQgbnVsbCcgbG9naWMgYWJvdmUuXG5cblxuICAgICAgICBpZiAoIWlkeC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9hZGQgJiYgdGhpcy5fYWRkKGlkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGlkeC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgdGhpcy5fYWRkICYmIHRoaXMuX2FkZChpZHhbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaW5pdEluZGV4TWFwKGFyciwgbWFwLCBrZXlBcnIsIGtleUdldHRlck5hbWUsIGRhdGFEaWZmZXIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cbiAgICB2YXIga2V5ID0gJ19lY18nICsgZGF0YURpZmZlcltrZXlHZXR0ZXJOYW1lXShhcnJbaV0sIGkpO1xuICAgIHZhciBleGlzdGVuY2UgPSBtYXBba2V5XTtcblxuICAgIGlmIChleGlzdGVuY2UgPT0gbnVsbCkge1xuICAgICAga2V5QXJyLnB1c2goa2V5KTtcbiAgICAgIG1hcFtrZXldID0gaTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFleGlzdGVuY2UubGVuZ3RoKSB7XG4gICAgICAgIG1hcFtrZXldID0gZXhpc3RlbmNlID0gW2V4aXN0ZW5jZV07XG4gICAgICB9XG5cbiAgICAgIGV4aXN0ZW5jZS5wdXNoKGkpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBEYXRhRGlmZmVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL0RhdGFEaWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIFNjYWxlID0gcmVxdWlyZShcIi4vU2NhbGVcIik7XG5cbnZhciBoZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5cbi8qKlxuICogSW50ZXJ2YWwgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9JbnRlcnZhbFxuICovXG52YXIgcm91bmROdW1iZXIgPSBudW1iZXJVdGlsLnJvdW5kO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29vcmQvc2NhbGUvSW50ZXJ2YWxcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBJbnRlcnZhbFNjYWxlID0gU2NhbGUuZXh0ZW5kKHtcbiAgdHlwZTogJ2ludGVydmFsJyxcbiAgX2ludGVydmFsOiAwLFxuICBfaW50ZXJ2YWxQcmVjaXNpb246IDIsXG4gIHNldEV4dGVudDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgdGhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDsgLy9zdGFydCxlbmQgbWF5IGJlIGEgTnVtYmVyIGxpa2UgJzI1Jyxzby4uLlxuXG4gICAgaWYgKCFpc05hTihzdGFydCkpIHtcbiAgICAgIHRoaXNFeHRlbnRbMF0gPSBwYXJzZUZsb2F0KHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGVuZCkpIHtcbiAgICAgIHRoaXNFeHRlbnRbMV0gPSBwYXJzZUZsb2F0KGVuZCk7XG4gICAgfVxuICB9LFxuICB1bmlvbkV4dGVudDogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICAgIG90aGVyWzFdID4gZXh0ZW50WzFdICYmIChleHRlbnRbMV0gPSBvdGhlclsxXSk7IC8vIHVuaW9uRXh0ZW50IG1heSBjYWxsZWQgYnkgaXQncyBzdWIgY2xhc3Nlc1xuXG4gICAgSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGUuc2V0RXh0ZW50LmNhbGwodGhpcywgZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgaW50ZXJ2YWxcbiAgICovXG4gIGdldEludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVydmFsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgaW50ZXJ2YWxcbiAgICovXG4gIHNldEludGVydmFsOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsOyAvLyBEcm9wcGVkIGF1dG8gY2FsY3VsYXRlZCBuaWNlRXh0ZW50IGFuZCB1c2UgdXNlciBzZXR0ZWQgZXh0ZW50XG4gICAgLy8gV2UgYXNzdW1lIHVzZXIgd2FuJ3QgdG8gc2V0IGJvdGggaW50ZXJ2YWwsIG1pbiwgbWF4IHRvIGdldCBhIGJldHRlciByZXN1bHRcblxuICAgIHRoaXMuX25pY2VFeHRlbnQgPSB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgICB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbiA9IGhlbHBlci5nZXRJbnRlcnZhbFByZWNpc2lvbihpbnRlcnZhbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZ2V0VGlja3M6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGVscGVyLmludGVydmFsU2NhbGVHZXRUaWNrcyh0aGlzLl9pbnRlcnZhbCwgdGhpcy5fZXh0ZW50LCB0aGlzLl9uaWNlRXh0ZW50LCB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0VGlja3NMYWJlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFiZWxzID0gW107XG4gICAgdmFyIHRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGFiZWxzLnB1c2godGhpcy5nZXRMYWJlbCh0aWNrc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHQucHJlY2lzaW9uXSBJZiAnYXV0bycsIHVzZSBuaWNlIHByZXNpc2lvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LnBhZF0gcmV0dXJucyAxLjUwIGJ1dCBub3QgMS41IGlmIHByZWNpc2lvbiBpcyAyLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRMYWJlbDogZnVuY3Rpb24gKGRhdGEsIG9wdCkge1xuICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgcHJlY2lzaW9uID0gb3B0ICYmIG9wdC5wcmVjaXNpb247XG5cbiAgICBpZiAocHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgIHByZWNpc2lvbiA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZShkYXRhKSB8fCAwO1xuICAgIH0gZWxzZSBpZiAocHJlY2lzaW9uID09PSAnYXV0bycpIHtcbiAgICAgIC8vIFNob3VsZCBiZSBtb3JlIHByZWNpc2UgdGhlbiB0aWNrLlxuICAgICAgcHJlY2lzaW9uID0gdGhpcy5faW50ZXJ2YWxQcmVjaXNpb247XG4gICAgfSAvLyAoMSkgSWYgYHByZWNpc2lvbmAgaXMgc2V0LCAxMi4wMDUgc2hvdWxkIGJlIGRpc3BsYXkgYXMgJzEyLjAwNTAwJy5cbiAgICAvLyAoMikgVXNlIHJvdW5kTnVtYmVyICh0b0ZpeGVkKSB0byBhdm9pZCBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgJzMuNWUtNycuXG5cblxuICAgIGRhdGEgPSByb3VuZE51bWJlcihkYXRhLCBwcmVjaXNpb24sIHRydWUpO1xuICAgIHJldHVybiBmb3JtYXRVdGlsLmFkZENvbW1hcyhkYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGludGVydmFsIGFuZCBleHRlbnQgb2YgaW50ZXJ2YWxzIGZvciBuaWNlIHRpY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3BsaXROdW1iZXIgPSA1XSBEZXNpcmVkIG51bWJlciBvZiB0aWNrc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbkludGVydmFsXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heEludGVydmFsXVxuICAgKi9cbiAgbmljZVRpY2tzOiBmdW5jdGlvbiAoc3BsaXROdW1iZXIsIG1pbkludGVydmFsLCBtYXhJbnRlcnZhbCkge1xuICAgIHNwbGl0TnVtYmVyID0gc3BsaXROdW1iZXIgfHwgNTtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuXG4gICAgaWYgKCFpc0Zpbml0ZShzcGFuKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVXNlciBtYXkgc2V0IGF4aXMgbWluIDAgYW5kIGRhdGEgYXJlIGFsbCBuZWdhdGl2ZVxuICAgIC8vIEZJWE1FIElmIGl0IG5lZWRzIHRvIHJldmVyc2UgP1xuXG5cbiAgICBpZiAoc3BhbiA8IDApIHtcbiAgICAgIHNwYW4gPSAtc3BhbjtcbiAgICAgIGV4dGVudC5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IGhlbHBlci5pbnRlcnZhbFNjYWxlTmljZVRpY2tzKGV4dGVudCwgc3BsaXROdW1iZXIsIG1pbkludGVydmFsLCBtYXhJbnRlcnZhbCk7XG4gICAgdGhpcy5faW50ZXJ2YWxQcmVjaXNpb24gPSByZXN1bHQuaW50ZXJ2YWxQcmVjaXNpb247XG4gICAgdGhpcy5faW50ZXJ2YWwgPSByZXN1bHQuaW50ZXJ2YWw7XG4gICAgdGhpcy5fbmljZUV4dGVudCA9IHJlc3VsdC5uaWNlVGlja0V4dGVudDtcbiAgfSxcblxuICAvKipcbiAgICogTmljZSBleHRlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3BsaXROdW1iZXIgPSA1XSBHaXZlbiBhcHByb3ggdGljayBudW1iZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LmZpeE1pbj1mYWxzZV1cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LmZpeE1heD1mYWxzZV1cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0Lm1pbkludGVydmFsXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQubWF4SW50ZXJ2YWxdXG4gICAqL1xuICBuaWNlRXh0ZW50OiBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDsgLy8gSWYgZXh0ZW50IHN0YXJ0IGFuZCBlbmQgYXJlIHNhbWUsIGV4cGFuZCB0aGVtXG5cbiAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgIGlmIChleHRlbnRbMF0gIT09IDApIHtcbiAgICAgICAgLy8gRXhwYW5kIGV4dGVudFxuICAgICAgICB2YXIgZXhwYW5kU2l6ZSA9IGV4dGVudFswXTsgLy8gSW4gdGhlIGZvd2xsb3dpbmcgY2FzZVxuICAgICAgICAvLyAgICAgIEF4aXMgaGFzIGJlZW4gZml4ZWQgbWF4IDEwMFxuICAgICAgICAvLyAgICAgIFBsdXMgZGF0YSBhcmUgYWxsIDEwMCBhbmQgYXhpcyBleHRlbnQgYXJlIFsxMDAsIDEwMF0uXG4gICAgICAgIC8vIEV4dGVuZCB0byB0aGUgYm90aCBzaWRlIHdpbGwgY2F1c2UgZXhwYW5kZWQgbWF4IGlzIGxhcmdlciB0aGFuIGZpeGVkIG1heC5cbiAgICAgICAgLy8gU28gb25seSBleHBhbmQgdG8gdGhlIHNtYWxsZXIgc2lkZS5cblxuICAgICAgICBpZiAoIW9wdC5maXhNYXgpIHtcbiAgICAgICAgICBleHRlbnRbMV0gKz0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgICAgZXh0ZW50WzBdIC09IGV4cGFuZFNpemUgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVudFswXSAtPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZW50WzFdID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTsgLy8gSWYgdGhlcmUgYXJlIG5vIGRhdGEgYW5kIGV4dGVudCBhcmUgW0luZmluaXR5LCAtSW5maW5pdHldXG5cbiAgICBpZiAoIWlzRmluaXRlKHNwYW4pKSB7XG4gICAgICBleHRlbnRbMF0gPSAwO1xuICAgICAgZXh0ZW50WzFdID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLm5pY2VUaWNrcyhvcHQuc3BsaXROdW1iZXIsIG9wdC5taW5JbnRlcnZhbCwgb3B0Lm1heEludGVydmFsKTsgLy8gdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcblxuICAgIHZhciBpbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsO1xuXG4gICAgaWYgKCFvcHQuZml4TWluKSB7XG4gICAgICBleHRlbnRbMF0gPSByb3VuZE51bWJlcihNYXRoLmZsb29yKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdC5maXhNYXgpIHtcbiAgICAgIGV4dGVudFsxXSA9IHJvdW5kTnVtYmVyKE1hdGguY2VpbChleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgfVxuICB9XG59KTtcbi8qKlxuICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZX1cbiAqL1xuXG5JbnRlcnZhbFNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBJbnRlcnZhbFNjYWxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9JbnRlcnZhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBmb3JtYXRVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZm9ybWF0XCIpO1xuXG52YXIgQVhJU19ESU1TID0gWyd4JywgJ3knLCAneicsICdyYWRpdXMnLCAnYW5nbGUnLCAnc2luZ2xlJ107IC8vIFN1cHBvcnRlZCBjb29yZHMuXG5cbnZhciBDT09SRFMgPSBbJ2NhcnRlc2lhbjJkJywgJ3BvbGFyJywgJ3NpbmdsZUF4aXMnXTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkVHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0Nvb3JkU3VwcG9ydGVkKGNvb3JkVHlwZSkge1xuICByZXR1cm4genJVdGlsLmluZGV4T2YoQ09PUkRTLCBjb29yZFR5cGUpID49IDA7XG59XG4vKipcbiAqIENyZWF0ZSBcImVhY2hcIiBtZXRob2QgdG8gaXRlcmF0ZSBuYW1lcy5cbiAqXG4gKiBAcHViaWxjXG4gKiBAcGFyYW0gIHtBcnJheS48c3RyaW5nPn0gbmFtZXNcbiAqIEBwYXJhbSAge0FycmF5LjxzdHJpbmc+PX0gYXR0cnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTmFtZUVhY2gobmFtZXMsIGF0dHJzKSB7XG4gIG5hbWVzID0gbmFtZXMuc2xpY2UoKTtcbiAgdmFyIGNhcGl0YWxOYW1lcyA9IHpyVXRpbC5tYXAobmFtZXMsIGZvcm1hdFV0aWwuY2FwaXRhbEZpcnN0KTtcbiAgYXR0cnMgPSAoYXR0cnMgfHwgW10pLnNsaWNlKCk7XG4gIHZhciBjYXBpdGFsQXR0cnMgPSB6clV0aWwubWFwKGF0dHJzLCBmb3JtYXRVdGlsLmNhcGl0YWxGaXJzdCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB6clV0aWwuZWFjaChuYW1lcywgZnVuY3Rpb24gKG5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgbmFtZU9iaiA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgY2FwaXRhbDogY2FwaXRhbE5hbWVzW2luZGV4XVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhdHRycy5sZW5ndGg7IGorKykge1xuICAgICAgICBuYW1lT2JqW2F0dHJzW2pdXSA9IG5hbWUgKyBjYXBpdGFsQXR0cnNbal07XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgbmFtZU9iaik7XG4gICAgfSk7XG4gIH07XG59XG4vKipcbiAqIEl0ZXJhdGUgZWFjaCBkaW1lbnNpb24gbmFtZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgcGFyYW1ldGVyIGlzIGxpa2U6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FuZ2xlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBpdGFsOiAnQW5nbGUnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXM6ICdhbmdsZUF4aXMnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNJbmRleDogJ2FuZ2xlQWl4cycsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6ICdhbmdsZUluZGV4J1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuXG5cbnZhciBlYWNoQXhpc0RpbSA9IGNyZWF0ZU5hbWVFYWNoKEFYSVNfRElNUywgWydheGlzSW5kZXgnLCAnYXhpcycsICdpbmRleCcsICdpZCddKTtcbi8qKlxuICogSWYgdG93IGRhdGFab29tTW9kZWxzIGhhcyB0aGUgc2FtZSBheGlzIGNvbnRyb2xsZWQsIHdlIHNheSB0aGF0IHRoZXkgYXJlICdsaW5rZWQnLlxuICogZGF0YVpvb21Nb2RlbHMgYW5kICdsaW5rcycgbWFrZSB1cCBvbmUgb3IgbW9yZSBncmFwaGljcy5cbiAqIFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGdyYXBoaWMgd2hlcmUgdGhlIHNvdXJjZSBkYXRhWm9vbU1vZGVsIGlzIGluLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZvckVhY2hOb2RlIE5vZGUgaXRlcmF0b3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmb3JFYWNoRWRnZVR5cGUgZWRnZVR5cGUgaXRlcmF0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVkZ2VJZEdldHRlciBHaXZpbmcgbm9kZSBhbmQgZWRnZVR5cGUsIHJldHVybiBhbiBhcnJheSBvZiBlZGdlIGlkLlxuICogQHJldHVybiB7RnVuY3Rpb259IElucHV0OiBzb3VyY2VOb2RlLCBPdXRwdXQ6IExpa2Uge25vZGVzOiBbXSwgZGltczoge319XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTGlua2VkTm9kZXNGaW5kZXIoZm9yRWFjaE5vZGUsIGZvckVhY2hFZGdlVHlwZSwgZWRnZUlkR2V0dGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc291cmNlTm9kZSkge1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBub2RlczogW10sXG4gICAgICByZWNvcmRzOiB7fSAvLyBrZXk6IGVkZ2VUeXBlLm5hbWUsIHZhbHVlOiBPYmplY3QgKGtleTogZWRnZSBpZCwgdmFsdWU6IGJvb2xlYW4pLlxuXG4gICAgfTtcbiAgICBmb3JFYWNoRWRnZVR5cGUoZnVuY3Rpb24gKGVkZ2VUeXBlKSB7XG4gICAgICByZXN1bHQucmVjb3Jkc1tlZGdlVHlwZS5uYW1lXSA9IHt9O1xuICAgIH0pO1xuXG4gICAgaWYgKCFzb3VyY2VOb2RlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFic29yYihzb3VyY2VOb2RlLCByZXN1bHQpO1xuICAgIHZhciBleGlzdHNMaW5rO1xuXG4gICAgZG8ge1xuICAgICAgZXhpc3RzTGluayA9IGZhbHNlO1xuICAgICAgZm9yRWFjaE5vZGUocHJvY2Vzc1NpbmdsZU5vZGUpO1xuICAgIH0gd2hpbGUgKGV4aXN0c0xpbmspO1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1NpbmdsZU5vZGUobm9kZSkge1xuICAgICAgaWYgKCFpc05vZGVBYnNvcmRlZChub2RlLCByZXN1bHQpICYmIGlzTGlua2VkKG5vZGUsIHJlc3VsdCkpIHtcbiAgICAgICAgYWJzb3JiKG5vZGUsIHJlc3VsdCk7XG4gICAgICAgIGV4aXN0c0xpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNOb2RlQWJzb3JkZWQobm9kZSwgcmVzdWx0KSB7XG4gICAgcmV0dXJuIHpyVXRpbC5pbmRleE9mKHJlc3VsdC5ub2Rlcywgbm9kZSkgPj0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGlua2VkKG5vZGUsIHJlc3VsdCkge1xuICAgIHZhciBoYXNMaW5rID0gZmFsc2U7XG4gICAgZm9yRWFjaEVkZ2VUeXBlKGZ1bmN0aW9uIChlZGdlVHlwZSkge1xuICAgICAgenJVdGlsLmVhY2goZWRnZUlkR2V0dGVyKG5vZGUsIGVkZ2VUeXBlKSB8fCBbXSwgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICByZXN1bHQucmVjb3Jkc1tlZGdlVHlwZS5uYW1lXVtlZGdlSWRdICYmIChoYXNMaW5rID0gdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGFzTGluaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFic29yYihub2RlLCByZXN1bHQpIHtcbiAgICByZXN1bHQubm9kZXMucHVzaChub2RlKTtcbiAgICBmb3JFYWNoRWRnZVR5cGUoZnVuY3Rpb24gKGVkZ2VUeXBlKSB7XG4gICAgICB6clV0aWwuZWFjaChlZGdlSWRHZXR0ZXIobm9kZSwgZWRnZVR5cGUpIHx8IFtdLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIHJlc3VsdC5yZWNvcmRzW2VkZ2VUeXBlLm5hbWVdW2VkZ2VJZF0gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0Nvb3JkU3VwcG9ydGVkID0gaXNDb29yZFN1cHBvcnRlZDtcbmV4cG9ydHMuY3JlYXRlTmFtZUVhY2ggPSBjcmVhdGVOYW1lRWFjaDtcbmV4cG9ydHMuZWFjaEF4aXNEaW0gPSBlYWNoQXhpc0RpbTtcbmV4cG9ydHMuY3JlYXRlTGlua2VkTm9kZXNGaW5kZXIgPSBjcmVhdGVMaW5rZWROb2Rlc0ZpbmRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENhbGN1bGF0ZSBzbGlkZXIgbW92ZSByZXN1bHQuXG4gKiBVc2FnZTpcbiAqICgxKSBJZiBib3RoIGhhbmRsZTAgYW5kIGhhbmRsZTEgYXJlIG5lZWRlZCB0byBiZSBtb3ZlZCwgc2V0IG1pblNwYW4gdGhlIHNhbWUgYXNcbiAqIG1heFNwYW4gYW5kIHRoZSBzYW1lIGFzIGBNYXRoLmFicyhoYW5kbGVFbmRbMV0gLSBoYW5kbGVFbmRzWzBdKWAuXG4gKiAoMikgSWYgaGFuZGxlMCBpcyBmb3JiaWRkZW4gdG8gY3Jvc3MgaGFuZGxlMSwgc2V0IG1pblNwYW4gYXMgYDBgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBNb3ZlIGxlbmd0aC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhhbmRsZUVuZHMgaGFuZGxlRW5kc1swXSBjYW4gYmUgYmlnZ2VyIHRoZW4gaGFuZGxlRW5kc1sxXS5cbiAqICAgICAgICAgICAgICBoYW5kbGVFbmRzIHdpbGwgYmUgbW9kaWZpZWQgaW4gdGhpcyBtZXRob2QuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBleHRlbnQgaGFuZGxlRW5kcyBpcyByZXN0cmljdGVkIGJ5IGV4dGVudC5cbiAqICAgICAgICAgICAgICBleHRlbnRbMF0gc2hvdWxkIGxlc3Mgb3IgZXF1YWxzIHRoYW4gZXh0ZW50WzFdLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBoYW5kbGVJbmRleCBDYW4gYmUgJ2FsbCcsIG1lYW5zIHRoYXQgYm90aCBtb3ZlIHRoZSB0d28gaGFuZGxlRW5kcyxcbiAqICAgICAgICAgICAgICB3aGVyZSB0aGUgaW5wdXQgbWluU3BhbiBhbmQgbWF4U3BhbiB3aWxsIG5vdCB3b3JrLlxuICogQHBhcmFtIHtudW1iZXJ9IFttaW5TcGFuXSBUaGUgcmFuZ2Ugb2YgZGF0YVpvb20gY2FuIG5vdCBiZSBzbWFsbGVyIHRoYW4gdGhhdC5cbiAqICAgICAgICAgICAgICBJZiBub3Qgc2V0LCBoYW5kbGUwIGFuZCBjcm9zcyBoYW5kbGUxLiBJZiBzZXQgYXMgYSBub24tbmVnYXRpdmVcbiAqICAgICAgICAgICAgICBudW1iZXIgKGluY2x1ZGluZyBgMGApLCBoYW5kbGVzIHdpbGwgcHVzaCBlYWNoIG90aGVyIHdoZW4gcmVhY2hpbmdcbiAqICAgICAgICAgICAgICB0aGUgbWluU3Bhbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4U3Bhbl0gVGhlIHJhbmdlIG9mIGRhdGFab29tIGNhbiBub3QgYmUgbGFyZ2VyIHRoYW4gdGhhdC5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBUaGUgaW5wdXQgaGFuZGxlRW5kcy5cbiAqL1xuZnVuY3Rpb24gX2RlZmF1bHQoZGVsdGEsIGhhbmRsZUVuZHMsIGV4dGVudCwgaGFuZGxlSW5kZXgsIG1pblNwYW4sIG1heFNwYW4pIHtcbiAgLy8gTm9ybWFsaXplIGZpcnN0bHkuXG4gIGhhbmRsZUVuZHNbMF0gPSByZXN0cmljdChoYW5kbGVFbmRzWzBdLCBleHRlbnQpO1xuICBoYW5kbGVFbmRzWzFdID0gcmVzdHJpY3QoaGFuZGxlRW5kc1sxXSwgZXh0ZW50KTtcbiAgZGVsdGEgPSBkZWx0YSB8fCAwO1xuICB2YXIgZXh0ZW50U3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTsgLy8gTm90aWNlIG1heFNwYW4gYW5kIG1pblNwYW4gY2FuIGJlIG51bGwvdW5kZWZpbmVkLlxuXG4gIGlmIChtaW5TcGFuICE9IG51bGwpIHtcbiAgICBtaW5TcGFuID0gcmVzdHJpY3QobWluU3BhbiwgWzAsIGV4dGVudFNwYW5dKTtcbiAgfVxuXG4gIGlmIChtYXhTcGFuICE9IG51bGwpIHtcbiAgICBtYXhTcGFuID0gTWF0aC5tYXgobWF4U3BhbiwgbWluU3BhbiAhPSBudWxsID8gbWluU3BhbiA6IDApO1xuICB9XG5cbiAgaWYgKGhhbmRsZUluZGV4ID09PSAnYWxsJykge1xuICAgIG1pblNwYW4gPSBtYXhTcGFuID0gTWF0aC5hYnMoaGFuZGxlRW5kc1sxXSAtIGhhbmRsZUVuZHNbMF0pO1xuICAgIGhhbmRsZUluZGV4ID0gMDtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbERpc3RTaWduID0gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpO1xuICBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSArPSBkZWx0YTsgLy8gUmVzdHJpY3QgaW4gZXh0ZW50LlxuXG4gIHZhciBleHRlbnRNaW5TcGFuID0gbWluU3BhbiB8fCAwO1xuICB2YXIgcmVhbEV4dGVudCA9IGV4dGVudC5zbGljZSgpO1xuICBvcmlnaW5hbERpc3RTaWduLnNpZ24gPCAwID8gcmVhbEV4dGVudFswXSArPSBleHRlbnRNaW5TcGFuIDogcmVhbEV4dGVudFsxXSAtPSBleHRlbnRNaW5TcGFuO1xuICBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSA9IHJlc3RyaWN0KGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdLCByZWFsRXh0ZW50KTsgLy8gRXhwYW5kIHNwYW4uXG5cbiAgdmFyIGN1cnJEaXN0U2lnbiA9IGdldFNwYW5TaWduKGhhbmRsZUVuZHMsIGhhbmRsZUluZGV4KTtcblxuICBpZiAobWluU3BhbiAhPSBudWxsICYmIChjdXJyRGlzdFNpZ24uc2lnbiAhPT0gb3JpZ2luYWxEaXN0U2lnbi5zaWduIHx8IGN1cnJEaXN0U2lnbi5zcGFuIDwgbWluU3BhbikpIHtcbiAgICAvLyBJZiBtaW5TcGFuIGV4aXN0cywgJ2Nyb3NzJyBpcyBmb3JiaW5kZW4uXG4gICAgaGFuZGxlRW5kc1sxIC0gaGFuZGxlSW5kZXhdID0gaGFuZGxlRW5kc1toYW5kbGVJbmRleF0gKyBvcmlnaW5hbERpc3RTaWduLnNpZ24gKiBtaW5TcGFuO1xuICB9IC8vIFNocmluayBzcGFuLlxuXG5cbiAgdmFyIGN1cnJEaXN0U2lnbiA9IGdldFNwYW5TaWduKGhhbmRsZUVuZHMsIGhhbmRsZUluZGV4KTtcblxuICBpZiAobWF4U3BhbiAhPSBudWxsICYmIGN1cnJEaXN0U2lnbi5zcGFuID4gbWF4U3Bhbikge1xuICAgIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XSA9IGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICsgY3VyckRpc3RTaWduLnNpZ24gKiBtYXhTcGFuO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZUVuZHM7XG59XG5cbmZ1bmN0aW9uIGdldFNwYW5TaWduKGhhbmRsZUVuZHMsIGhhbmRsZUluZGV4KSB7XG4gIHZhciBkaXN0ID0gaGFuZGxlRW5kc1toYW5kbGVJbmRleF0gLSBoYW5kbGVFbmRzWzEgLSBoYW5kbGVJbmRleF07IC8vIElmIGBoYW5kbGVFbmRzWzBdID09PSBoYW5kbGVFbmRzWzFdYCwgYWx3YXlzIGJlbGlldmUgdGhhdCBoYW5kbGVFbmRbMF1cbiAgLy8gaXMgYXQgbGVmdCBvZiBoYW5kbGVFbmRzWzFdIGZvciBub24tY3Jvc3MgY2FzZS5cblxuICByZXR1cm4ge1xuICAgIHNwYW46IE1hdGguYWJzKGRpc3QpLFxuICAgIHNpZ246IGRpc3QgPiAwID8gLTEgOiBkaXN0IDwgMCA/IDEgOiBoYW5kbGVJbmRleCA/IC0xIDogMVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXN0cmljdCh2YWx1ZSwgZXh0ZW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihleHRlbmRbMV0sIE1hdGgubWF4KGV4dGVuZFswXSwgdmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL3NsaWRlck1vdmUuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBndWlkID0gcmVxdWlyZShcIi4vY29yZS9ndWlkXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vY29yZS9lbnZcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBIYW5kbGVyID0gcmVxdWlyZShcIi4vSGFuZGxlclwiKTtcblxudmFyIFN0b3JhZ2UgPSByZXF1aXJlKFwiLi9TdG9yYWdlXCIpO1xuXG52YXIgUGFpbnRlciA9IHJlcXVpcmUoXCIuL1BhaW50ZXJcIik7XG5cbnZhciBBbmltYXRpb24gPSByZXF1aXJlKFwiLi9hbmltYXRpb24vQW5pbWF0aW9uXCIpO1xuXG52YXIgSGFuZGxlclByb3h5ID0gcmVxdWlyZShcIi4vZG9tL0hhbmRsZXJQcm94eVwiKTtcblxuLyohXG4qIFpSZW5kZXIsIGEgaGlnaCBwZXJmb3JtYW5jZSAyZCBkcmF3aW5nIGxpYnJhcnkuXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMywgQmFpZHUgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBMSUNFTlNFXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuKi9cbnZhciB1c2VWTUwgPSAhZW52LmNhbnZhc1N1cHBvcnRlZDtcbnZhciBwYWludGVyQ3RvcnMgPSB7XG4gIGNhbnZhczogUGFpbnRlclxufTtcbnZhciBpbnN0YW5jZXMgPSB7fTsgLy8gWlJlbmRlcuWunuS+i21hcOe0ouW8lVxuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblxudmFyIHZlcnNpb24gPSAnMy43LjQnO1xuLyoqXG4gKiBJbml0aWFsaXppbmcgYSB6cmVuZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAqL1xuXG5mdW5jdGlvbiBpbml0KGRvbSwgb3B0cykge1xuICB2YXIgenIgPSBuZXcgWlJlbmRlcihndWlkKCksIGRvbSwgb3B0cyk7XG4gIGluc3RhbmNlc1t6ci5pZF0gPSB6cjtcbiAgcmV0dXJuIHpyO1xufVxuLyoqXG4gKiBEaXNwb3NlIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3Bvc2UoenIpIHtcbiAgaWYgKHpyKSB7XG4gICAgenIuZGlzcG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBpbnN0YW5jZXMpIHtcbiAgICAgIGlmIChpbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpbnN0YW5jZXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2VzID0ge307XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogR2V0IHpyZW5kZXIgaW5zdGFuY2UgYnkgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCB6cmVuZGVyIGluc3RhbmNlIGlkXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2UoaWQpIHtcbiAgcmV0dXJuIGluc3RhbmNlc1tpZF07XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUGFpbnRlcihuYW1lLCBDdG9yKSB7XG4gIHBhaW50ZXJDdG9yc1tuYW1lXSA9IEN0b3I7XG59XG5cbmZ1bmN0aW9uIGRlbEluc3RhbmNlKGlkKSB7XG4gIGRlbGV0ZSBpbnN0YW5jZXNbaWRdO1xufVxuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvWlJlbmRlclxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvWlJlbmRlclxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqL1xuXG5cbnZhciBaUmVuZGVyID0gZnVuY3Rpb24gKGlkLCBkb20sIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTERvbUVsZW1lbnR9XG4gICAqL1xuXG4gIHRoaXMuZG9tID0gZG9tO1xuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5pZCA9IGlkO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKTtcbiAgdmFyIHJlbmRlcmVyVHlwZSA9IG9wdHMucmVuZGVyZXI7IC8vIFRPRE8gV2ViR0xcblxuICBpZiAodXNlVk1MKSB7XG4gICAgaWYgKCFwYWludGVyQ3RvcnMudm1sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHJlcXVpcmUgXFwnenJlbmRlci92bWwvdm1sXFwnIHRvIHN1cHBvcnQgSUU4Jyk7XG4gICAgfVxuXG4gICAgcmVuZGVyZXJUeXBlID0gJ3ZtbCc7XG4gIH0gZWxzZSBpZiAoIXJlbmRlcmVyVHlwZSB8fCAhcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0pIHtcbiAgICByZW5kZXJlclR5cGUgPSAnY2FudmFzJztcbiAgfVxuXG4gIHZhciBwYWludGVyID0gbmV3IHBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKGRvbSwgc3RvcmFnZSwgb3B0cyk7XG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHZhciBoYW5kZXJQcm94eSA9ICFlbnYubm9kZSA/IG5ldyBIYW5kbGVyUHJveHkocGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkgOiBudWxsO1xuICB0aGlzLmhhbmRsZXIgPSBuZXcgSGFuZGxlcihzdG9yYWdlLCBwYWludGVyLCBoYW5kZXJQcm94eSwgcGFpbnRlci5yb290KTtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufVxuICAgKi9cblxuICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oe1xuICAgIHN0YWdlOiB7XG4gICAgICB1cGRhdGU6IHpyVXRpbC5iaW5kKHRoaXMuZmx1c2gsIHRoaXMpXG4gICAgfVxuICB9KTtcbiAgdGhpcy5hbmltYXRpb24uc3RhcnQoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9uZWVkc1JlZnJlc2g7IC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlLCDmr4/mrKHliKDpmaTlhYPntKDkuYvliY3liKDpmaTliqjnlLtcbiAgLy8gRklYTUUg5pyJ54K5dWdseVxuXG4gIHZhciBvbGREZWxGcm9tU3RvcmFnZSA9IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2U7XG4gIHZhciBvbGRBZGRUb1N0b3JhZ2UgPSBzdG9yYWdlLmFkZFRvU3RvcmFnZTtcblxuICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkRGVsRnJvbVN0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG4gICAgZWwgJiYgZWwucmVtb3ZlU2VsZkZyb21acihzZWxmKTtcbiAgfTtcblxuICBzdG9yYWdlLmFkZFRvU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICBlbC5hZGRTZWxmVG9acihzZWxmKTtcbiAgfTtcbn07XG5cblpSZW5kZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWlJlbmRlcixcblxuICAvKipcbiAgICog6I635Y+W5a6e5L6L5ZSv5LiA5qCH6K+GXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldElkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWFg+e0oFxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB0aGlzLnN0b3JhZ2UuYWRkUm9vdChlbCk7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5YWD57SgXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChlbCkge1xuICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KGVsKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgY29uZmlndXJhdGlvbiBvZiBsYXllclxuICAgKiBAcGFyYW0ge3N0cmluZ30gekxldmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSBDbGVhciBjb2xvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSBJZiBlbmFibGUgbW90aW9uIGJsdXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XSBNb3Rpb24gYmx1ciBmYWN0b3IuIExhcmdlciB2YWx1ZSBjYXVzZSBsb25nZXIgdHJhaWxlclxuICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpMZXZlbCwgY29uZmlnKSB7XG4gICAgdGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKHpMZXZlbCwgY29uZmlnKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBjYW52YXMgaW1tZWRpYXRlbHlcbiAgICovXG4gIHJlZnJlc2hJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIC8vIHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XG4gICAgLy8gQ2xlYXIgbmVlZHNSZWZyZXNoIGFoZWFkIHRvIGF2b2lkIHNvbWV0aGluZyB3cm9uZyBoYXBwZW5zIGluIHJlZnJlc2hcbiAgICAvLyBPciBpdCB3aWxsIGNhdXNlIHpyZW5kZXIgcmVmcmVzaGVzIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTtcbiAgICB0aGlzLnBhaW50ZXIucmVmcmVzaCgpO1xuICAgIC8qKlxuICAgICAqIEF2b2lkIHRyaWdnZXIgenIucmVmcmVzaCBpbiBFbGVtZW50I2JlZm9yZVVwZGF0ZSBob29rXG4gICAgICovXG5cbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTsgLy8gdmFyIGVuZCA9IG5ldyBEYXRlKCk7XG4gICAgLy8gdmFyIGxvZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2cnKTtcbiAgICAvLyBpZiAobG9nKSB7XG4gICAgLy8gICAgIGxvZy5pbm5lckhUTUwgPSBsb2cuaW5uZXJIVE1MICsgJzxicj4nICsgKGVuZCAtIHN0YXJ0KTtcbiAgICAvLyB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hcmsgYW5kIHJlcGFpbnQgdGhlIGNhbnZhcyBpbiB0aGUgbmV4dCBmcmFtZSBvZiBicm93c2VyXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbGwgcmVmcmVzaFxuICAgKi9cbiAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fbmVlZHNSZWZyZXNoKSB7XG4gICAgICB0aGlzLnJlZnJlc2hJbW1lZGlhdGVseSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2hIb3Zlcikge1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXJJbW1lZGlhdGVseSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgdG8gaG92ZXIgbGF5ZXJcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAqL1xuICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIuYWRkSG92ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5hZGRIb3ZlcihlbCwgc3R5bGUpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBlbGVtZW50IGZyb20gaG92ZXIgbGF5ZXJcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAodGhpcy5wYWludGVyLnJlbW92ZUhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIoZWwpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBob3ZlciBlbGVtZW50cyBpbiBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIuY2xlYXJIb3Zlcikge1xuICAgICAgdGhpcy5wYWludGVyLmNsZWFySG92ZXIoKTtcbiAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGluIG5leHQgZnJhbWVcbiAgICovXG4gIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaCBob3ZlciBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVmcmVzaEhvdmVySW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlO1xuICAgIHRoaXMucGFpbnRlci5yZWZyZXNoSG92ZXIgJiYgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGNhbnZhcy5cbiAgICogU2hvdWxkIGJlIGludm9rZWQgd2hlbiBjb250YWluZXIgc2l6ZSBpcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLnBhaW50ZXIucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICB0aGlzLmhhbmRsZXIucmVzaXplKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3AgYW5kIGNsZWFyIGFsbCBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICovXG4gIGNsZWFyQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmltYXRpb24uY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciB3aWR0aFxuICAgKi9cbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFdpZHRoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjb250YWluZXIgaGVpZ2h0XG4gICAqL1xuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldEhlaWdodCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvcnQgdGhlIGNhbnZhcyBhcyBCYXNlNjQgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yPScjZmZmJ11cbiAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgVVJMXG4gICAqL1xuICAvLyB0b0RhdGFVUkw6IGZ1bmN0aW9uKHR5cGUsIGJhY2tncm91bmRDb2xvcikge1xuICAvLyAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyh7XG4gIC8vICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgLy8gICAgIH0pLnRvRGF0YVVSTCh0eXBlKTtcbiAgLy8gfSxcblxuICAvKipcbiAgICogQ29udmVydGluZyBhIHBhdGggdG8gaW1hZ2UuXG4gICAqIEl0IGhhcyBtdWNoIGJldHRlciBwZXJmb3JtYW5jZSBvZiBkcmF3aW5nIGltYWdlIHJhdGhlciB0aGFuIGRyYXdpbmcgYSB2ZWN0b3IgcGF0aC5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHBhdGhUb0ltYWdlOiBmdW5jdGlvbiAoZSwgZHByKSB7XG4gICAgcmV0dXJuIHRoaXMucGFpbnRlci5wYXRoVG9JbWFnZShlLCBkcHIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgZGVmYXVsdCBjdXJzb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICovXG4gIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICB0aGlzLmhhbmRsZXIuc2V0Q3Vyc29yU3R5bGUoY3Vyc29yU3R5bGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIGhvdmVyZWQgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHt0YXJnZXQsIHRvcFRhcmdldH1cbiAgICovXG4gIGZpbmRIb3ZlcjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmZpbmRIb3Zlcih4LCB5KTtcbiAgfSxcblxuICAvKipcbiAgICogQmluZCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyIEhhbmRsZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IG9iamVjdFxuICAgKi9cbiAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuaGFuZGxlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuYmluZCBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2V2ZW50SGFuZGxlcl0gSGFuZGxlciBmdW5jdGlvblxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICB0aGlzLmhhbmRsZXIub2ZmKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJpZ2dlciBldmVudCBtYW51YWxseVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtldmVudD19IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0aGlzLmhhbmRsZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIG9iamVjdHMgYW5kIHRoZSBjYW52YXMuXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KCk7XG4gICAgdGhpcy5wYWludGVyLmNsZWFyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugc2VsZi5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5zdG9wKCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuc3RvcmFnZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5wYWludGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdGhpcy5zdG9yYWdlID0gdGhpcy5wYWludGVyID0gdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICBkZWxJbnN0YW5jZSh0aGlzLmlkKTtcbiAgfVxufTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5kaXNwb3NlID0gZGlzcG9zZTtcbmV4cG9ydHMuZ2V0SW5zdGFuY2UgPSBnZXRJbnN0YW5jZTtcbmV4cG9ydHMucmVnaXN0ZXJQYWludGVyID0gcmVnaXN0ZXJQYWludGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogenJlbmRlcjog55Sf5oiQ5ZSv5LiAaWRcbiAqXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cbnZhciBpZFN0YXJ0ID0gMHgwOTA3O1xuXG5mdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIGlkU3RhcnQrKztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBndWlkID0gcmVxdWlyZShcIi4vY29yZS9ndWlkXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi9taXhpbi9FdmVudGZ1bFwiKTtcblxudmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKFwiLi9taXhpbi9UcmFuc2Zvcm1hYmxlXCIpO1xuXG52YXIgQW5pbWF0YWJsZSA9IHJlcXVpcmUoXCIuL21peGluL0FuaW1hdGFibGVcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGV9XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX1cbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAqL1xudmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAob3B0cykge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgVHJhbnNmb3JtYWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICBFdmVudGZ1bC5jYWxsKHRoaXMsIG9wdHMpO1xuICBBbmltYXRhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIC8qKlxuICAgKiDnlLvluIPlhYPntKBJRFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmlkID0gb3B0cy5pZCB8fCBndWlkKCk7XG59O1xuXG5FbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIOWFg+e0oOexu+Wei1xuICAgKiBFbGVtZW50IHR5cGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHR5cGU6ICdlbGVtZW50JyxcblxuICAvKipcbiAgICog5YWD57Sg5ZCN5a2XXG4gICAqIEVsZW1lbnQgbmFtZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgbmFtZTogJycsXG5cbiAgLyoqXG4gICAqIFpSZW5kZXIg5a6e5L6L5a+56LGh77yM5Lya5ZyoIGVsZW1lbnQg5re75Yqg5YiwIHpyZW5kZXIg5a6e5L6L5Lit5ZCO6Ieq5Yqo6LWL5YC8XG4gICAqIFpSZW5kZXIgaW5zdGFuY2Ugd2lsbCBiZSBhc3NpZ25lZCB3aGVuIGVsZW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHpyZW5kZXJcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjX196clxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICovXG4gIF9fenI6IG51bGwsXG5cbiAgLyoqXG4gICAqIOWbvuW9ouaYr+WQpuW/veeVpe+8jOS4unRydWXml7blv73nlaXlm77lvaLnmoTnu5jliLbku6Xlj4rkuovku7bop6blj5FcbiAgICogSWYgaWdub3JlIGRyYXdpbmcgYW5kIGV2ZW50cyBvZiB0aGUgZWxlbWVudCBvYmplY3RcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjaWdub3JlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaWdub3JlOiBmYWxzZSxcblxuICAvKipcbiAgICog55So5LqO6KOB5Ymq55qE6Lev5b6EKHNoYXBlKe+8jOaJgOaciSBHcm91cCDlhoXnmoTot6/lvoTlnKjnu5jliLbml7bpg73kvJrooqvov5nkuKrot6/lvoToo4HliapcbiAgICog6K+l6Lev5b6E5Lya57un5om/6KKr6KOB5YeP5a+56LGh55qE5Y+Y5o2iXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9XG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0LyNjbGlwcGluZy1yZWdpb25cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBjbGlwUGF0aDogbnVsbCxcblxuICAvKipcbiAgICogRHJpZnQgZWxlbWVudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IGR4IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBkeSBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAqL1xuICBkcmlmdDogZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgIHN3aXRjaCAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICBkeSA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIGR4ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICAgIGlmICghbSkge1xuICAgICAgbSA9IHRoaXMudHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIH1cblxuICAgIG1bNF0gKz0gZHg7XG4gICAgbVs1XSArPSBkeTtcbiAgICB0aGlzLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIb29rIGJlZm9yZSB1cGRhdGVcbiAgICovXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIEhvb2sgYWZ0ZXIgdXBkYXRlXG4gICAqL1xuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHt9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyB8fCBrZXkgPT09ICdzY2FsZScgfHwga2V5ID09PSAnb3JpZ2luJykge1xuICAgICAgLy8gQ29weSB0aGUgYXJyYXlcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpc1trZXldO1xuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGhpc1trZXldID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRbMF0gPSB2YWx1ZVswXTtcbiAgICAgICAgdGFyZ2V0WzFdID0gdmFsdWVbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGlkZSB0aGUgZWxlbWVudFxuICAgKi9cbiAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaWdub3JlID0gdHJ1ZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICogU2hvdyB0aGUgZWxlbWVudFxuICAgKi9cbiAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaWdub3JlID0gZmFsc2U7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIGF0dHI6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmF0dHJLVihrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5hdHRyS1YobmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gY2xpcFBhdGhcbiAgICovXG4gIHNldENsaXBQYXRoOiBmdW5jdGlvbiAoY2xpcFBhdGgpIHtcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG5cbiAgICBpZiAoenIpIHtcbiAgICAgIGNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICB9IC8vIFJlbW92ZSBwcmV2aW91cyBjbGlwIHBhdGhcblxuXG4gICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aCAhPT0gY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgY2xpcFBhdGguX196ciA9IHpyO1xuICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IHRoaXM7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqL1xuICByZW1vdmVDbGlwUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGg7XG5cbiAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgIGlmIChjbGlwUGF0aC5fX3pyKSB7XG4gICAgICAgIGNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoY2xpcFBhdGguX196cik7XG4gICAgICB9XG5cbiAgICAgIGNsaXBQYXRoLl9fenIgPSBudWxsO1xuICAgICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuY2xpcFBhdGggPSBudWxsO1xuICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgKi9cbiAgYWRkU2VsZlRvWnI6IGZ1bmN0aW9uICh6cikge1xuICAgIHRoaXMuX196ciA9IHpyOyAvLyDmt7vliqDliqjnlLtcblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcblxuICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAqL1xuICByZW1vdmVTZWxmRnJvbVpyOiBmdW5jdGlvbiAoenIpIHtcbiAgICB0aGlzLl9fenIgPSBudWxsOyAvLyDnp7vpmaTliqjnlLtcblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcblxuICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHpyLmFuaW1hdGlvbi5yZW1vdmVBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgIH1cbiAgfVxufTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBBbmltYXRhYmxlKTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBUcmFuc2Zvcm1hYmxlKTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBFdmVudGZ1bCk7XG52YXIgX2RlZmF1bHQgPSBFbGVtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbWF0cml4ID0gcmVxdWlyZShcIi4uL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG4vKipcbiAqIOaPkOS+m+WPmOaNouaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbUlkZW50aXR5ID0gbWF0cml4LmlkZW50aXR5O1xudmFyIEVQU0lMT04gPSA1ZS01O1xuXG5mdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgVHJhbnNmb3JtYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBJZiB0aGVyZSBhcmUgbm8gZ2l2ZW4gcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZVxuXG4gIGlmICghb3B0cy5wb3NpdGlvbikge1xuICAgIC8qKlxuICAgICAqIOW5s+enu1xuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCBbMCwgMF1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDBdO1xuICB9XG5cbiAgaWYgKG9wdHMucm90YXRpb24gPT0gbnVsbCkge1xuICAgIC8qKlxuICAgICAqIOaXi+i9rFxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gIH1cblxuICBpZiAoIW9wdHMuc2NhbGUpIHtcbiAgICAvKipcbiAgICAgKiDnvKnmlL5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgWzEsIDFdXG4gICAgICovXG4gICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgfVxuICAvKipcbiAgICog5peL6L2s5ZKM57yp5pS+55qE5Y6f54K5XG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cblxuXG4gIHRoaXMub3JpZ2luID0gdGhpcy5vcmlnaW4gfHwgbnVsbDtcbn07XG5cbnZhciB0cmFuc2Zvcm1hYmxlUHJvdG8gPSBUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZTtcbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm0gPSBudWxsO1xuLyoqXG4gKiDliKTmlq3mmK/lkKbpnIDopoHmnInlnZDmoIflj5jmjaJcbiAqIOWmguaenOacieWdkOagh+WPmOaNoiwg5YiZ5LuOcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZeS7peWPiueItuiKgueCueeahHRyYW5zZm9ybeiuoeeul+WHuuiHqui6q+eahHRyYW5zZm9ybeefqemYtVxuICovXG5cbnRyYW5zZm9ybWFibGVQcm90by5uZWVkTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc05vdEFyb3VuZFplcm8odGhpcy5yb3RhdGlvbikgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMF0pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzFdKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVswXSAtIDEpIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzFdIC0gMSk7XG59O1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8udXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIHZhciBwYXJlbnRIYXNUcmFuc2Zvcm0gPSBwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybTtcbiAgdmFyIG5lZWRMb2NhbFRyYW5zZm9ybSA9IHRoaXMubmVlZExvY2FsVHJhbnNmb3JtKCk7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKCEobmVlZExvY2FsVHJhbnNmb3JtIHx8IHBhcmVudEhhc1RyYW5zZm9ybSkpIHtcbiAgICBtICYmIG1JZGVudGl0eShtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG5cbiAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgIHRoaXMuZ2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gIH0gZWxzZSB7XG4gICAgbUlkZW50aXR5KG0pO1xuICB9IC8vIOW6lOeUqOeItuiKgueCueWPmOaNolxuXG5cbiAgaWYgKHBhcmVudEhhc1RyYW5zZm9ybSkge1xuICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgIG1hdHJpeC5tdWwobSwgcGFyZW50LnRyYW5zZm9ybSwgbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdHJpeC5jb3B5KG0sIHBhcmVudC50cmFuc2Zvcm0pO1xuICAgIH1cbiAgfSAvLyDkv53lrZjov5nkuKrlj5jmjaLnn6npmLVcblxuXG4gIHRoaXMudHJhbnNmb3JtID0gbTtcbiAgdGhpcy5pbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybSB8fCBtYXRyaXguY3JlYXRlKCk7XG4gIG1hdHJpeC5pbnZlcnQodGhpcy5pbnZUcmFuc2Zvcm0sIG0pO1xufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgcmV0dXJuIFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0odGhpcywgbSk7XG59O1xuLyoqXG4gKiDlsIboh6rlt7HnmoR0cmFuc2Zvcm3lupTnlKjliLBjb250ZXh05LiKXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuXG4gIGlmIChtKSB7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgfVxufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnJlc3RvcmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xufTtcblxudmFyIHRtcFRyYW5zZm9ybSA9IFtdO1xuLyoqXG4gKiDliIbop6NgdHJhbnNmb3JtYOefqemYteWIsGBwb3NpdGlvbmAsIGByb3RhdGlvbmAsIGBzY2FsZWBcbiAqL1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZGVjb21wb3NlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybSkge1xuICAgIC8vIEdldCBsb2NhbCB0cmFuc2Zvcm0gYW5kIGRlY29tcG9zZSB0aGVtIHRvIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb25cbiAgICBtYXRyaXgubXVsKHRtcFRyYW5zZm9ybSwgcGFyZW50LmludlRyYW5zZm9ybSwgbSk7XG4gICAgbSA9IHRtcFRyYW5zZm9ybTtcbiAgfVxuXG4gIHZhciBzeCA9IG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV07XG4gIHZhciBzeSA9IG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM107XG4gIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgaWYgKGlzTm90QXJvdW5kWmVybyhzeCAtIDEpKSB7XG4gICAgc3ggPSBNYXRoLnNxcnQoc3gpO1xuICB9XG5cbiAgaWYgKGlzTm90QXJvdW5kWmVybyhzeSAtIDEpKSB7XG4gICAgc3kgPSBNYXRoLnNxcnQoc3kpO1xuICB9XG5cbiAgaWYgKG1bMF0gPCAwKSB7XG4gICAgc3ggPSAtc3g7XG4gIH1cblxuICBpZiAobVszXSA8IDApIHtcbiAgICBzeSA9IC1zeTtcbiAgfVxuXG4gIHBvc2l0aW9uWzBdID0gbVs0XTtcbiAgcG9zaXRpb25bMV0gPSBtWzVdO1xuICBzY2FsZVswXSA9IHN4O1xuICBzY2FsZVsxXSA9IHN5O1xuICB0aGlzLnJvdGF0aW9uID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xufTtcbi8qKlxuICogR2V0IGdsb2JhbCBzY2FsZVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0R2xvYmFsU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIFsxLCAxXTtcbiAgfVxuXG4gIHZhciBzeCA9IE1hdGguc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgdmFyIHN5ID0gTWF0aC5zcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuXG4gIGlmIChtWzBdIDwgMCkge1xuICAgIHN4ID0gLXN4O1xuICB9XG5cbiAgaWYgKG1bM10gPCAwKSB7XG4gICAgc3kgPSAtc3k7XG4gIH1cblxuICByZXR1cm4gW3N4LCBzeV07XG59O1xuLyoqXG4gKiDlj5jmjaLlnZDmoIfkvY3nva7liLAgc2hhcGUg55qE5bGA6YOo5Z2Q5qCH56m66Ze0XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHZhciB2MiA9IFt4LCB5XTtcbiAgdmFyIGludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtO1xuXG4gIGlmIChpbnZUcmFuc2Zvcm0pIHtcbiAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCBpbnZUcmFuc2Zvcm0pO1xuICB9XG5cbiAgcmV0dXJuIHYyO1xufTtcbi8qKlxuICog5Y+Y5o2i5bGA6YOo5Z2Q5qCH5L2N572u5Yiw5YWo5bGA5Z2Q5qCH56m66Ze0XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9HbG9iYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgdjIgPSBbeCwgeV07XG4gIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2Mjtcbn07XG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5vcmlnaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXQucm90YXRpb25cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5wb3NpdGlvblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW21dXG4gKi9cblxuXG5UcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRhcmdldCwgbSkge1xuICBtID0gbSB8fCBbXTtcbiAgbUlkZW50aXR5KG0pO1xuICB2YXIgb3JpZ2luID0gdGFyZ2V0Lm9yaWdpbjtcbiAgdmFyIHNjYWxlID0gdGFyZ2V0LnNjYWxlIHx8IFsxLCAxXTtcbiAgdmFyIHJvdGF0aW9uID0gdGFyZ2V0LnJvdGF0aW9uIHx8IDA7XG4gIHZhciBwb3NpdGlvbiA9IHRhcmdldC5wb3NpdGlvbiB8fCBbMCwgMF07XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIC8vIFRyYW5zbGF0ZSB0byBvcmlnaW5cbiAgICBtWzRdIC09IG9yaWdpblswXTtcbiAgICBtWzVdIC09IG9yaWdpblsxXTtcbiAgfVxuXG4gIG1hdHJpeC5zY2FsZShtLCBtLCBzY2FsZSk7XG5cbiAgaWYgKHJvdGF0aW9uKSB7XG4gICAgbWF0cml4LnJvdGF0ZShtLCBtLCByb3RhdGlvbik7XG4gIH1cblxuICBpZiAob3JpZ2luKSB7XG4gICAgLy8gVHJhbnNsYXRlIGJhY2sgZnJvbSBvcmlnaW5cbiAgICBtWzRdICs9IG9yaWdpblswXTtcbiAgICBtWzVdICs9IG9yaWdpblsxXTtcbiAgfVxuXG4gIG1bNF0gKz0gcG9zaXRpb25bMF07XG4gIG1bNV0gKz0gcG9zaXRpb25bMV07XG4gIHJldHVybiBtO1xufTtcblxudmFyIF9kZWZhdWx0ID0gVHJhbnNmb3JtYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIENsaXAgPSByZXF1aXJlKFwiLi9DbGlwXCIpO1xuXG52YXIgY29sb3IgPSByZXF1aXJlKFwiLi4vdG9vbC9jb2xvclwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGlzQXJyYXlMaWtlID0gX3V0aWwuaXNBcnJheUxpa2U7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2FuaW1hdGlvbi9BbmltYXRvclxuICovXG52YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gZGVmYXVsdEdldHRlcih0YXJnZXQsIGtleSkge1xuICByZXR1cm4gdGFyZ2V0W2tleV07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXR0ZXIodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gIHRhcmdldFtrZXldID0gdmFsdWU7XG59XG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVOdW1iZXIocDAsIHAxLCBwZXJjZW50KSB7XG4gIHJldHVybiAocDEgLSBwMCkgKiBwZXJjZW50ICsgcDA7XG59XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gcDBcbiAqIEBwYXJhbSAge3N0cmluZ30gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVTdHJpbmcocDAsIHAxLCBwZXJjZW50KSB7XG4gIHJldHVybiBwZXJjZW50ID4gMC41ID8gcDEgOiBwMDtcbn1cbi8qKlxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwZXJjZW50LCBvdXQsIGFyckRpbSkge1xuICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuXG4gIGlmIChhcnJEaW0gPT0gMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG91dFtpXSA9IGludGVycG9sYXRlTnVtYmVyKHAwW2ldLCBwMVtpXSwgcGVyY2VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gbGVuICYmIHAwWzBdLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIG91dFtpXVtqXSA9IGludGVycG9sYXRlTnVtYmVyKHAwW2ldW2pdLCBwMVtpXVtqXSwgcGVyY2VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIGFycjAgaXMgc291cmNlIGFycmF5LCBhcnIxIGlzIHRhcmdldCBhcnJheS5cbi8vIERvIHNvbWUgcHJlcHJvY2VzcyB0byBhdm9pZCBlcnJvciBoYXBwZW5lZCB3aGVuIGludGVycG9sYXRpbmcgZnJvbSBhcnIwIHRvIGFycjFcblxuXG5mdW5jdGlvbiBmaWxsQXJyKGFycjAsIGFycjEsIGFyckRpbSkge1xuICB2YXIgYXJyMExlbiA9IGFycjAubGVuZ3RoO1xuICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuXG4gIGlmIChhcnIwTGVuICE9PSBhcnIxTGVuKSB7XG4gICAgLy8gRklYTUUgTm90IHdvcmsgZm9yIFR5cGVkQXJyYXlcbiAgICB2YXIgaXNQcmV2aW91c0xhcmdlciA9IGFycjBMZW4gPiBhcnIxTGVuO1xuXG4gICAgaWYgKGlzUHJldmlvdXNMYXJnZXIpIHtcbiAgICAgIC8vIEN1dCB0aGUgcHJldmlvdXNcbiAgICAgIGFycjAubGVuZ3RoID0gYXJyMUxlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmlsbCB0aGUgcHJldmlvdXNcbiAgICAgIGZvciAodmFyIGkgPSBhcnIwTGVuOyBpIDwgYXJyMUxlbjsgaSsrKSB7XG4gICAgICAgIGFycjAucHVzaChhcnJEaW0gPT09IDEgPyBhcnIxW2ldIDogYXJyYXlTbGljZS5jYWxsKGFycjFbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSGFuZGxpbmcgTmFOIHZhbHVlXG5cblxuICB2YXIgbGVuMiA9IGFycjBbMF0gJiYgYXJyMFswXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgICAgaWYgKGlzTmFOKGFycjBbaV0pKSB7XG4gICAgICAgIGFycjBbaV0gPSBhcnIxW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBpZiAoaXNOYU4oYXJyMFtpXVtqXSkpIHtcbiAgICAgICAgICBhcnIwW2ldW2pdID0gYXJyMVtpXVtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyMFxuICogQHBhcmFtICB7QXJyYXl9IGFycjFcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNBcnJheVNhbWUoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gIGlmIChhcnIwID09PSBhcnIxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGVuID0gYXJyMC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAhPT0gYXJyMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGFycjBbaV0gIT09IGFycjFbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuMiA9IGFycjBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgaWYgKGFycjBbaV1bal0gIT09IGFycjFbaV1bal0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgYXJyYXlcbiAqIEBwYXJhbSAge0FycmF5fSBwMFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAqIEBwYXJhbSAge0FycmF5fSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICovXG5cblxuZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mywgb3V0LCBhcnJEaW0pIHtcbiAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcblxuICBpZiAoYXJyRGltID09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQsIHQyLCB0Myk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgb3V0W2ldW2pdID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwW2ldW2pdLCBwMVtpXVtqXSwgcDJbaV1bal0sIHAzW2ldW2pdLCB0LCB0MiwgdDMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBudW1iZXJcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDMgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufVxuXG5mdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKTtcbiAgcmdiYVsyXSA9IE1hdGguZmxvb3IocmdiYVsyXSk7XG4gIHJldHVybiAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5RGltKGtleWZyYW1lcykge1xuICB2YXIgbGFzdFZhbHVlID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKGxhc3RWYWx1ZSAmJiBsYXN0VmFsdWVbMF0pID8gMiA6IDE7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYWNrQ2xpcChhbmltYXRvciwgZWFzaW5nLCBvbmVUcmFja0RvbmUsIGtleWZyYW1lcywgcHJvcE5hbWUsIGZvcmNlQW5pbWF0ZSkge1xuICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuICB2YXIgdHJhY2tMZW4gPSBrZXlmcmFtZXMubGVuZ3RoO1xuXG4gIGlmICghdHJhY2tMZW4pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gR3Vlc3MgZGF0YSB0eXBlXG5cblxuICB2YXIgZmlyc3RWYWwgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gIHZhciBpc1ZhbHVlQXJyYXkgPSBpc0FycmF5TGlrZShmaXJzdFZhbCk7XG4gIHZhciBpc1ZhbHVlQ29sb3IgPSBmYWxzZTtcbiAgdmFyIGlzVmFsdWVTdHJpbmcgPSBmYWxzZTsgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG5cbiAgdmFyIGFyckRpbSA9IGlzVmFsdWVBcnJheSA/IGdldEFycmF5RGltKGtleWZyYW1lcykgOiAwO1xuICB2YXIgdHJhY2tNYXhUaW1lOyAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuXG4gIGtleWZyYW1lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEudGltZSAtIGIudGltZTtcbiAgfSk7XG4gIHRyYWNrTWF4VGltZSA9IGtleWZyYW1lc1t0cmFja0xlbiAtIDFdLnRpbWU7IC8vIFBlcmNlbnRzIG9mIGVhY2gga2V5ZnJhbWVcblxuICB2YXIga2ZQZXJjZW50cyA9IFtdOyAvLyBWYWx1ZSBvZiBlYWNoIGtleWZyYW1lXG5cbiAgdmFyIGtmVmFsdWVzID0gW107XG4gIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW47IGkrKykge1xuICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7IC8vIEFzc3VtZSB2YWx1ZSBpcyBhIGNvbG9yIHdoZW4gaXQgaXMgYSBzdHJpbmdcblxuICAgIHZhciB2YWx1ZSA9IGtleWZyYW1lc1tpXS52YWx1ZTsgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgZXF1YWwsIGRlZXAgY2hlY2sgaWYgdmFsdWUgaXMgYXJyYXlcblxuICAgIGlmICghKGlzVmFsdWVBcnJheSAmJiBpc0FycmF5U2FtZSh2YWx1ZSwgcHJldlZhbHVlLCBhcnJEaW0pIHx8ICFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpIHtcbiAgICAgIGlzQWxsVmFsdWVFcXVhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByZXZWYWx1ZSA9IHZhbHVlOyAvLyBUcnkgY29udmVydGluZyBhIHN0cmluZyB0byBhIGNvbG9yIGFycmF5XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgY29sb3JBcnJheSA9IGNvbG9yLnBhcnNlKHZhbHVlKTtcblxuICAgICAgaWYgKGNvbG9yQXJyYXkpIHtcbiAgICAgICAgdmFsdWUgPSBjb2xvckFycmF5O1xuICAgICAgICBpc1ZhbHVlQ29sb3IgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNWYWx1ZVN0cmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAga2ZWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIWZvcmNlQW5pbWF0ZSAmJiBpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0ga2ZWYWx1ZXNbdHJhY2tMZW4gLSAxXTsgLy8gUG9seWZpbGwgYXJyYXkgYW5kIE5hTiB2YWx1ZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW4gLSAxOyBpKyspIHtcbiAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICBmaWxsQXJyKGtmVmFsdWVzW2ldLCBsYXN0VmFsdWUsIGFyckRpbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc05hTihrZlZhbHVlc1tpXSkgJiYgIWlzTmFOKGxhc3RWYWx1ZSkgJiYgIWlzVmFsdWVTdHJpbmcgJiYgIWlzVmFsdWVDb2xvcikge1xuICAgICAgICBrZlZhbHVlc1tpXSA9IGxhc3RWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1ZhbHVlQXJyYXkgJiYgZmlsbEFycihnZXR0ZXIoYW5pbWF0b3IuX3RhcmdldCwgcHJvcE5hbWUpLCBsYXN0VmFsdWUsIGFyckRpbSk7IC8vIENhY2hlIHRoZSBrZXkgb2YgbGFzdCBmcmFtZSB0byBzcGVlZCB1cCB3aGVuXG4gIC8vIGFuaW1hdGlvbiBwbGF5YmFjayBpcyBzZXF1ZW5jeVxuXG4gIHZhciBsYXN0RnJhbWUgPSAwO1xuICB2YXIgbGFzdEZyYW1lUGVyY2VudCA9IDA7XG4gIHZhciBzdGFydDtcbiAgdmFyIHc7XG4gIHZhciBwMDtcbiAgdmFyIHAxO1xuICB2YXIgcDI7XG4gIHZhciBwMztcblxuICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgdmFyIHJnYmEgPSBbMCwgMCwgMCwgMF07XG4gIH1cblxuICB2YXIgb25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAvLyBGaW5kIHRoZSByYW5nZSBrZXlmcmFtZXNcbiAgICAvLyBrZjEtLS0tLWtmMi0tLS0tLS0tLWN1cnJlbnQtLS0tLS0tLWtmM1xuICAgIC8vIGZpbmQga2YyIGFuZCBrZjMgYW5kIGRvIGludGVycG9sYXRpb25cbiAgICB2YXIgZnJhbWU7IC8vIEluIHRoZSBlYXNpbmcgZnVuY3Rpb24gbGlrZSBlbGFzdGljT3V0LCBwZXJjZW50IG1heSBsZXNzIHRoYW4gMFxuXG4gICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICBmcmFtZSA9IDA7XG4gICAgfSBlbHNlIGlmIChwZXJjZW50IDwgbGFzdEZyYW1lUGVyY2VudCkge1xuICAgICAgLy8gU3RhcnQgZnJvbSBuZXh0IGtleVxuICAgICAgLy8gUEVORElORyBzdGFydCBmcm9tIGxhc3RGcmFtZSA/XG4gICAgICBzdGFydCA9IE1hdGgubWluKGxhc3RGcmFtZSArIDEsIHRyYWNrTGVuIC0gMSk7XG5cbiAgICAgIGZvciAoZnJhbWUgPSBzdGFydDsgZnJhbWUgPj0gMDsgZnJhbWUtLSkge1xuICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPD0gcGVyY2VudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XG5cblxuICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgdHJhY2tMZW4gLSAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChmcmFtZSA9IGxhc3RGcmFtZTsgZnJhbWUgPCB0cmFja0xlbjsgZnJhbWUrKykge1xuICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPiBwZXJjZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIHRyYWNrTGVuIC0gMik7XG4gICAgfVxuXG4gICAgbGFzdEZyYW1lID0gZnJhbWU7XG4gICAgbGFzdEZyYW1lUGVyY2VudCA9IHBlcmNlbnQ7XG4gICAgdmFyIHJhbmdlID0ga2ZQZXJjZW50c1tmcmFtZSArIDFdIC0ga2ZQZXJjZW50c1tmcmFtZV07XG5cbiAgICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdyA9IChwZXJjZW50IC0ga2ZQZXJjZW50c1tmcmFtZV0pIC8gcmFuZ2U7XG4gICAgfVxuXG4gICAgaWYgKHVzZVNwbGluZSkge1xuICAgICAgcDEgPSBrZlZhbHVlc1tmcmFtZV07XG4gICAgICBwMCA9IGtmVmFsdWVzW2ZyYW1lID09PSAwID8gZnJhbWUgOiBmcmFtZSAtIDFdO1xuICAgICAgcDIgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMiA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMV07XG4gICAgICBwMyA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAzID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAyXTtcblxuICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdywgZ2V0dGVyKHRhcmdldCwgcHJvcE5hbWUpLCBhcnJEaW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LCByZ2JhLCAxKTtcbiAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKHAxLCBwMiwgdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGVyKHRhcmdldCwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdywgZ2V0dGVyKHRhcmdldCwgcHJvcE5hbWUpLCBhcnJEaW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdywgcmdiYSwgMSk7XG4gICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gaW50ZXJwb2xhdGVOdW1iZXIoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRlcih0YXJnZXQsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbGlwID0gbmV3IENsaXAoe1xuICAgIHRhcmdldDogYW5pbWF0b3IuX3RhcmdldCxcbiAgICBsaWZlOiB0cmFja01heFRpbWUsXG4gICAgbG9vcDogYW5pbWF0b3IuX2xvb3AsXG4gICAgZGVsYXk6IGFuaW1hdG9yLl9kZWxheSxcbiAgICBvbmZyYW1lOiBvbmZyYW1lLFxuICAgIG9uZGVzdHJveTogb25lVHJhY2tEb25lXG4gIH0pO1xuXG4gIGlmIChlYXNpbmcgJiYgZWFzaW5nICE9PSAnc3BsaW5lJykge1xuICAgIGNsaXAuZWFzaW5nID0gZWFzaW5nO1xuICB9XG5cbiAgcmV0dXJuIGNsaXA7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3JcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlclxuICovXG5cblxudmFyIEFuaW1hdG9yID0gZnVuY3Rpb24gKHRhcmdldCwgbG9vcCwgZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgdGhpcy5fdHJhY2tzID0ge307XG4gIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgdGhpcy5fbG9vcCA9IGxvb3AgfHwgZmFsc2U7XG4gIHRoaXMuX2dldHRlciA9IGdldHRlciB8fCBkZWZhdWx0R2V0dGVyO1xuICB0aGlzLl9zZXR0ZXIgPSBzZXR0ZXIgfHwgZGVmYXVsdFNldHRlcjtcbiAgdGhpcy5fY2xpcENvdW50ID0gMDtcbiAgdGhpcy5fZGVsYXkgPSAwO1xuICB0aGlzLl9kb25lTGlzdCA9IFtdO1xuICB0aGlzLl9vbmZyYW1lTGlzdCA9IFtdO1xuICB0aGlzLl9jbGlwTGlzdCA9IFtdO1xufTtcblxuQW5pbWF0b3IucHJvdG90eXBlID0ge1xuICAvKipcbiAgICog6K6+572u5Yqo55S75YWz6ZSu5binXG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDlhbPplK7luKfml7bpl7TvvIzljZXkvY3mmK9tc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzIOWFs+mUruW4p+eahOWxnuaAp+WAvO+8jGtleS12YWx1ZeihqOekulxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICB3aGVuOiBmdW5jdGlvbiAodGltZVxuICAvKiBtcyAqL1xuICAsIHByb3BzKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMuX3RyYWNrcztcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFja3NbcHJvcE5hbWVdKSB7XG4gICAgICAgIHRyYWNrc1twcm9wTmFtZV0gPSBbXTsgLy8gSW52YWxpZCB2YWx1ZVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl90YXJnZXQsIHByb3BOYW1lKTtcblxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHpyTG9nKCdJbnZhbGlkIHByb3BlcnR5ICcgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSWYgdGltZSBpcyAwXG4gICAgICAgIC8vICBUaGVuIHByb3BzIGlzIGdpdmVuIGluaXRpYWxpemUgdmFsdWVcbiAgICAgICAgLy8gRWxzZVxuICAgICAgICAvLyAgSW5pdGlhbGl6ZSB2YWx1ZSBmcm9tIGN1cnJlbnQgcHJvcCB2YWx1ZVxuXG5cbiAgICAgICAgaWYgKHRpbWUgIT09IDApIHtcbiAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIHZhbHVlOiBjbG9uZVZhbHVlKHZhbHVlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIHZhbHVlOiBwcm9wc1twcm9wTmFtZV1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDliqjnlLvmr4/kuIDluKfnmoTlm57osIPlh73mlbBcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIGR1cmluZzogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fb25mcmFtZUxpc3QucHVzaChjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jbGlwTGlzdFtpXS5wYXVzZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH0sXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NsaXBMaXN0W2ldLnJlc3VtZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB9LFxuICBpc1BhdXNlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3BhdXNlZDtcbiAgfSxcbiAgX2RvbmVDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgIC8vIENsZWFyIGFsbCB0cmFja3NcbiAgICB0aGlzLl90cmFja3MgPSB7fTsgLy8gQ2xlYXIgYWxsIGNsaXBzXG5cbiAgICB0aGlzLl9jbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgIHZhciBkb25lTGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgIHZhciBsZW4gPSBkb25lTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkb25lTGlzdFtpXS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5byA5aeL5omn6KGM5Yqo55S7XG4gICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gW2Vhc2luZ11cbiAgICogICAgICAgICDliqjnlLvnvJPliqjlh73mlbDvvIzor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ31cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZm9yY2VBbmltYXRlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nLCBmb3JjZUFuaW1hdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNsaXBDb3VudCA9IDA7XG5cbiAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xpcENvdW50LS07XG5cbiAgICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICAgIHNlbGYuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGFzdENsaXA7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0aGlzLl90cmFja3MpIHtcbiAgICAgIGlmICghdGhpcy5fdHJhY2tzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsaXAgPSBjcmVhdGVUcmFja0NsaXAodGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lLCBmb3JjZUFuaW1hdGUpO1xuXG4gICAgICBpZiAoY2xpcCkge1xuICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuXG4gICAgICAgIGNsaXBDb3VudCsrOyAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cblxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgfVxuICAgIH0gLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG5cblxuICAgIGlmIChsYXN0Q2xpcCkge1xuICAgICAgdmFyIG9sZE9uRnJhbWUgPSBsYXN0Q2xpcC5vbmZyYW1lO1xuXG4gICAgICBsYXN0Q2xpcC5vbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICBvbGRPbkZyYW1lKHRhcmdldCwgcGVyY2VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9vbmZyYW1lTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAvLyBUaGlzIG9wdGltaXphdGlvbiB3aWxsIGhlbHAgdGhlIGNhc2UgdGhhdCBpbiB0aGUgdXBwZXIgYXBwbGljYXRpb25cbiAgICAvLyB0aGUgdmlldyBtYXkgYmUgcmVmcmVzaGVkIGZyZXF1ZW50bHksIHdoZXJlIGFuaW1hdGlvbiB3aWxsIGJlXG4gICAgLy8gY2FsbGVkIHJlcGVhdGx5IGJ1dCBub3RoaW5nIGNoYW5nZWQuXG5cblxuICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICB0aGlzLl9kb25lQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i5Yqo55S7XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICovXG4gIHN0b3A6IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgdmFyIGNsaXBMaXN0ID0gdGhpcy5fY2xpcExpc3Q7XG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNsaXAgPSBjbGlwTGlzdFtpXTtcblxuICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgLy8gTW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgIGNsaXAub25mcmFtZSh0aGlzLl90YXJnZXQsIDEpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgfVxuXG4gICAgY2xpcExpc3QubGVuZ3RoID0gMDtcbiAgfSxcblxuICAvKipcbiAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICB0aGlzLl9kZWxheSA9IHRpbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWKqOeUu+e7k+adn+eahOWbnuiwg1xuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZG9uZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0aGlzLl9kb25lTGlzdC5wdXNoKGNiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICovXG4gIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaXBMaXN0O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQW5pbWF0b3I7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gU2ltcGxlIExSVSBjYWNoZSB1c2UgZG91Ymx5IGxpbmtlZCBsaXN0XG4vLyBAbW9kdWxlIHpyZW5kZXIvY29yZS9MUlVcblxuLyoqXG4gKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5fbGVuID0gMDtcbn07XG5cbnZhciBsaW5rZWRMaXN0UHJvdG8gPSBMaW5rZWRMaXN0LnByb3RvdHlwZTtcbi8qKlxuICogSW5zZXJ0IGEgbmV3IHZhbHVlIGF0IHRoZSB0YWlsXG4gKiBAcGFyYW0gIHt9IHZhbFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gKi9cblxubGlua2VkTGlzdFByb3RvLmluc2VydCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIGVudHJ5ID0gbmV3IEVudHJ5KHZhbCk7XG4gIHRoaXMuaW5zZXJ0RW50cnkoZW50cnkpO1xuICByZXR1cm4gZW50cnk7XG59O1xuLyoqXG4gKiBJbnNlcnQgYW4gZW50cnkgYXQgdGhlIHRhaWxcbiAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gZW50cnk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICBlbnRyeS5wcmV2ID0gdGhpcy50YWlsO1xuICAgIGVudHJ5Lm5leHQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICB9XG5cbiAgdGhpcy5fbGVuKys7XG59O1xuLyoqXG4gKiBSZW1vdmUgZW50cnkuXG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgdmFyIHByZXYgPSBlbnRyeS5wcmV2O1xuICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIC8vIElzIGhlYWRcbiAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2O1xuICB9IGVsc2Uge1xuICAgIC8vIElzIHRhaWxcbiAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICB9XG5cbiAgZW50cnkubmV4dCA9IGVudHJ5LnByZXYgPSBudWxsO1xuICB0aGlzLl9sZW4tLTtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5sZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9sZW47XG59O1xuLyoqXG4gKiBDbGVhciBsaXN0XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMuX2xlbiA9IDA7XG59O1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7fSB2YWxcbiAqL1xuXG5cbnZhciBFbnRyeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHt9XG4gICAqL1xuICB0aGlzLnZhbHVlID0gdmFsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLm5leHQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMucHJldjtcbn07XG4vKipcbiAqIExSVSBDYWNoZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9MUlVcbiAqL1xuXG5cbnZhciBMUlUgPSBmdW5jdGlvbiAobWF4U2l6ZSkge1xuICB0aGlzLl9saXN0ID0gbmV3IExpbmtlZExpc3QoKTtcbiAgdGhpcy5fbWFwID0ge307XG4gIHRoaXMuX21heFNpemUgPSBtYXhTaXplIHx8IDEwO1xuICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbnVsbDtcbn07XG5cbnZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0gIHt9IHZhbHVlXG4gKiBAcmV0dXJuIHt9IFJlbW92ZWQgdmFsdWVcbiAqL1xuXG5MUlVQcm90by5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gIHZhciByZW1vdmVkID0gbnVsbDtcblxuICBpZiAobWFwW2tleV0gPT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBsaXN0LmxlbigpOyAvLyBSZXVzZSBsYXN0IHJlbW92ZWQgZW50cnlcblxuICAgIHZhciBlbnRyeSA9IHRoaXMuX2xhc3RSZW1vdmVkRW50cnk7XG5cbiAgICBpZiAobGVuID49IHRoaXMuX21heFNpemUgJiYgbGVuID4gMCkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkXG4gICAgICB2YXIgbGVhc3RVc2VkRW50cnkgPSBsaXN0LmhlYWQ7XG4gICAgICBsaXN0LnJlbW92ZShsZWFzdFVzZWRFbnRyeSk7XG4gICAgICBkZWxldGUgbWFwW2xlYXN0VXNlZEVudHJ5LmtleV07XG4gICAgICByZW1vdmVkID0gbGVhc3RVc2VkRW50cnkudmFsdWU7XG4gICAgICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbGVhc3RVc2VkRW50cnk7XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeSA9IG5ldyBFbnRyeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZW50cnkua2V5ID0ga2V5O1xuICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIG1hcFtrZXldID0gZW50cnk7XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlZDtcbn07XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHt9XG4gKi9cblxuXG5MUlVQcm90by5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX21hcFtrZXldO1xuICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG5cbiAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAvLyBQdXQgdGhlIGxhdGVzdCB1c2VkIGVudHJ5IGluIHRoZSB0YWlsXG4gICAgaWYgKGVudHJ5ICE9PSBsaXN0LnRhaWwpIHtcbiAgICAgIGxpc3QucmVtb3ZlKGVudHJ5KTtcbiAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgfVxufTtcbi8qKlxuICogQ2xlYXIgdGhlIGNhY2hlXG4gKi9cblxuXG5MUlVQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fbGlzdC5jbGVhcigpO1xuXG4gIHRoaXMuX21hcCA9IHt9O1xufTtcblxudmFyIF9kZWZhdWx0ID0gTFJVO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0xSVS5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgZGVidWdNb2RlID0gX2NvbmZpZy5kZWJ1Z01vZGU7XG5cbnZhciBsb2cgPSBmdW5jdGlvbiAoKSB7fTtcblxuaWYgKGRlYnVnTW9kZSA9PT0gMSkge1xuICBsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhcmd1bWVudHNba10pO1xuICAgIH1cbiAgfTtcbn0gZWxzZSBpZiAoZGVidWdNb2RlID4gMSkge1xuICBsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50c1trXSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgX2RlZmF1bHQgPSBsb2c7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgU1RZTEVfQ09NTU9OX1BST1BTID0gW1snc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXV07IC8vIHZhciBTSEFET1dfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoMCwgNCk7XG4vLyB2YXIgTElORV9QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSg0KTtcblxudmFyIFN0eWxlID0gZnVuY3Rpb24gKG9wdHMsIGhvc3QpIHtcbiAgdGhpcy5leHRlbmRGcm9tKG9wdHMsIGZhbHNlKTtcbiAgdGhpcy5ob3N0ID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVhckdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gIHZhciB4ID0gb2JqLnggPT0gbnVsbCA/IDAgOiBvYmoueDtcbiAgdmFyIHgyID0gb2JqLngyID09IG51bGwgPyAxIDogb2JqLngyO1xuICB2YXIgeSA9IG9iai55ID09IG51bGwgPyAwIDogb2JqLnk7XG4gIHZhciB5MiA9IG9iai55MiA9PSBudWxsID8gMCA6IG9iai55MjtcblxuICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgeDIgPSB4MiAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgeSA9IHkgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gIH1cblxuICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcbiAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSYWRpYWxHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciBtaW4gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMC41IDogb2JqLng7XG4gIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAuNSA6IG9iai55O1xuICB2YXIgciA9IG9iai5yID09IG51bGwgPyAwLjUgOiBvYmoucjtcblxuICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgIHkgPSB5ICogaGVpZ2h0ICsgcmVjdC55O1xuICAgIHIgPSByICogbWluO1xuICB9XG5cbiAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHgsIHksIHIpO1xuICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG59XG5cblN0eWxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX1cbiAgICovXG4gIGhvc3Q6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmaWxsOiAnIzAwMCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdHJva2U6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBvcGFjaXR5OiAxLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBsaW5lRGFzaDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxpbmVEYXNoT2Zmc2V0OiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGluZVdpZHRoOiAxLFxuXG4gIC8qKlxuICAgKiBJZiBzdHJva2UgaWdub3JlIHNjYWxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3Ryb2tlTm9TY2FsZTogZmFsc2UsXG4gIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gIC8vIE5vdCBhZmZlY3RlZCBieSBlbGVtZW50IHRyYW5zZm9ybVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dDogbnVsbCxcblxuICAvKipcbiAgICogSWYgYGZvbnRTaXplYCBvciBgZm9udEZhbWlseWAgZXhpc3RzLCBgZm9udGAgd2lsbCBiZSByZXNldCBieVxuICAgKiBgZm9udFNpemVgLCBgZm9udFN0eWxlYCwgYGZvbnRXZWlnaHRgLCBgZm9udEZhbWlseWAuXG4gICAqIFNvIGRvIG5vdCB2aXNpdCBpdCBkaXJlY3RseSBpbiB1cHBlciBhcHBsaWNhdGlvbiAobGlrZSBlY2hhcnRzKSxcbiAgICogYnV0IHVzZSBgY29udGFpbi90ZXh0I21ha2VGb250YCBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udDogbnVsbCxcblxuICAvKipcbiAgICogVGhlIHNhbWUgYXMgZm9udC4gVXNlIGZvbnQgcGxlYXNlLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEZvbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRTdHlsZTogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udFdlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBTaG91bGQgYmUgMTIgYnV0IG5vdCAnMTJweCcuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBmb250U2l6ZTogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udEZhbWlseTogbnVsbCxcblxuICAvKipcbiAgICogUmVzZXJ2ZWQgZm9yIHNwZWNpYWwgZnVuY3RpbmFsaXR5LCBsaWtlICdocicuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0VGFnOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEZpbGw6ICcjMDAwJyxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRTdHJva2U6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0V2lkdGg6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9ubHkgZm9yIHRleHRCYWNrZ3JvdW5kLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEhlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogdGV4dFN0cm9rZSBtYXkgYmUgc2V0IGFzIHNvbWUgY29sb3IgYXMgYSBkZWZhdWx0XG4gICAqIHZhbHVlIGluIHVwcGVyIGFwcGxpY2Fpb24sIHdoZXJlIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIG9mIHRleHRTdHJva2VXaWR0aCBzaG91bGQgYmUgMCB0byBtYWtlIHN1cmUgdGhhdFxuICAgKiB1c2VyIGNhbiBjaG9vc2UgdG8gZG8gbm90IHVzZSB0ZXh0IHN0cm9rZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTdHJva2VXaWR0aDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRMaW5lSGVpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiAnaW5zaWRlJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSdcbiAgICogW3gsIHldXG4gICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICogQGRlZmF1bHQgJ2luc2lkZSdcbiAgICovXG4gIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG5cbiAgLyoqXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgYm91bmRpbmdSZWN0IG9mIGEgYGRpc3BsYXlhYmxlYC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRleHRSZWN0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBbeCwgeV1cbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dE9mZnNldDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRBbGlnbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRWZXJ0aWNhbEFsaWduOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dERpc3RhbmNlOiA1LFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRyYW5zZm9ybSB0ZXh0LlxuICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdHJhbnNmb3JtVGV4dDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFRleHQgcm90YXRlIGFyb3VuZCBwb3NpdGlvbiBvZiBQYXRoIG9yIEltYWdlXG4gICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRyYW5zZm9ybVRleHQgaXMgZmFsc2UuXG4gICAqL1xuICB0ZXh0Um90YXRpb246IDAsXG5cbiAgLyoqXG4gICAqIFRleHQgb3JpZ2luIG9mIHRleHQgcm90YXRpb24sIGxpa2UgWzEwLCA0MF0uXG4gICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICogVXNlZnVsIGluIGxhYmVsIHJvdGF0aW9uIG9mIGNpcmN1bGFyIHN5bWJvbC5cbiAgICogQnkgZGVmYXVsdCwgdGhpcyBvcmlnaW4gaXMgdGV4dFBvc2l0aW9uLlxuICAgKiBDYW4gYmUgJ2NlbnRlcicuXG4gICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0T3JpZ2luOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJhY2tncm91bmRDb2xvcjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCb3JkZXJDb2xvcjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3JkZXJXaWR0aDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3JkZXJSYWRpdXM6IDAsXG5cbiAgLyoqXG4gICAqIENhbiBiZSBgMmAgb3IgYFsyLCA0XWAgb3IgYFsyLCAzLCA0LCA1XWBcbiAgICogQHR5cGUge251bWJlcnxBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRQYWRkaW5nOiBudWxsLFxuXG4gIC8qKlxuICAgKiBUZXh0IHN0eWxlcyBmb3IgcmljaCB0ZXh0LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcmljaDogbnVsbCxcblxuICAvKipcbiAgICoge291dGVyV2lkdGgsIG91dGVySGVpZ2h0LCBlbGxpcHNpcywgcGxhY2Vob2xkZXJ9XG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0cnVuY2F0ZTogbnVsbCxcblxuICAvKipcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGJsZW5kOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBiaW5kOiBmdW5jdGlvbiAoY3R4LCBlbCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICB2YXIgcHJldlN0eWxlID0gcHJldkVsICYmIHByZXZFbC5zdHlsZTtcbiAgICB2YXIgZmlyc3REcmF3ID0gIXByZXZTdHlsZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgIHZhciBzdHlsZU5hbWUgPSBwcm9wWzBdO1xuXG4gICAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlW3N0eWxlTmFtZV0gIT09IHByZXZTdHlsZVtzdHlsZU5hbWVdKSB7XG4gICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgY3R4W3N0eWxlTmFtZV0gPSBzdHlsZVtzdHlsZU5hbWVdIHx8IHByb3BbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5maWxsICE9PSBwcmV2U3R5bGUuZmlsbCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5zdHJva2UgIT09IHByZXZTdHlsZS5zdHJva2UpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLm9wYWNpdHkgIT09IHByZXZTdHlsZS5vcGFjaXR5KSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLmJsZW5kICE9PSBwcmV2U3R5bGUuYmxlbmQpIHtcbiAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBzdHlsZS5ibGVuZCB8fCAnc291cmNlLW92ZXInO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAvICh0aGlzLnN0cm9rZU5vU2NhbGUgJiYgZWwgJiYgZWwuZ2V0TGluZVNjYWxlID8gZWwuZ2V0TGluZVNjYWxlKCkgOiAxKTtcbiAgICB9XG4gIH0sXG4gIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlsbCA9IHRoaXMuZmlsbDtcbiAgICByZXR1cm4gZmlsbCAhPSBudWxsICYmIGZpbGwgIT09ICdub25lJztcbiAgfSxcbiAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgIHJldHVybiBzdHJva2UgIT0gbnVsbCAmJiBzdHJva2UgIT09ICdub25lJyAmJiB0aGlzLmxpbmVXaWR0aCA+IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dGVuZCBmcm9tIG90aGVyIHN0eWxlXG4gICAqIEBwYXJhbSB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBvdGhlclN0eWxlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlIHRydWU6IG92ZXJ3cmlydGUgYW55IHdheS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2U6IG92ZXJ3cml0ZSBvbmx5IHdoZW4gIXRhcmdldC5oYXNPd25Qcm9wZXJ0eVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlcnM6IG92ZXJ3cml0ZSB3aGVuIHByb3BlcnR5IGlzIG5vdCBudWxsL3VuZGVmaW5lZC5cbiAgICovXG4gIGV4dGVuZEZyb206IGZ1bmN0aW9uIChvdGhlclN0eWxlLCBvdmVyd3JpdGUpIHtcbiAgICBpZiAob3RoZXJTdHlsZSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlclN0eWxlKSB7XG4gICAgICAgIGlmIChvdGhlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpICYmIChvdmVyd3JpdGUgPT09IHRydWUgfHwgKG92ZXJ3cml0ZSA9PT0gZmFsc2UgPyAhdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA6IG90aGVyU3R5bGVbbmFtZV0gIT0gbnVsbCkpKSB7XG4gICAgICAgICAgdGhpc1tuYW1lXSA9IG90aGVyU3R5bGVbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhdGNoIHNldHRpbmcgc3R5bGUgd2l0aCBhIGdpdmVuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9ialxuICAgKiBAcGFyYW0geyp9IFtvYmpdXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzW29ial0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHRlbmRGcm9tKG9iaiwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZVxuICAgKiBAcmV0dXJuIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld1N0eWxlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICBuZXdTdHlsZS5leHRlbmRGcm9tKHRoaXMsIHRydWUpO1xuICAgIHJldHVybiBuZXdTdHlsZTtcbiAgfSxcbiAgZ2V0R3JhZGllbnQ6IGZ1bmN0aW9uIChjdHgsIG9iaiwgcmVjdCkge1xuICAgIHZhciBtZXRob2QgPSBvYmoudHlwZSA9PT0gJ3JhZGlhbCcgPyBjcmVhdGVSYWRpYWxHcmFkaWVudCA6IGNyZWF0ZUxpbmVhckdyYWRpZW50O1xuICAgIHZhciBjYW52YXNHcmFkaWVudCA9IG1ldGhvZChjdHgsIG9iaiwgcmVjdCk7XG4gICAgdmFyIGNvbG9yU3RvcHMgPSBvYmouY29sb3JTdG9wcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JTdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcHNbaV0ub2Zmc2V0LCBjb2xvclN0b3BzW2ldLmNvbG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gIH1cbn07XG52YXIgc3R5bGVQcm90byA9IFN0eWxlLnByb3RvdHlwZTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG5cbiAgaWYgKCEocHJvcFswXSBpbiBzdHlsZVByb3RvKSkge1xuICAgIHN0eWxlUHJvdG9bcHJvcFswXV0gPSBwcm9wWzFdO1xuICB9XG59IC8vIFByb3ZpZGUgZm9yIG90aGVyc1xuXG5cblN0eWxlLmdldEdyYWRpZW50ID0gc3R5bGVQcm90by5nZXRHcmFkaWVudDtcbnZhciBfZGVmYXVsdCA9IFN0eWxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZWF0KSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHtpbWFnZTogLi4ufWAsIHdoZXJlIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gIHRoaXMucmVwZWF0ID0gcmVwZWF0OyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ3BhdHRlcm4nO1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuaW1hZ2UsIHRoaXMucmVwZWF0IHx8ICdyZXBlYXQnKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFBhdHRlcm47XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9kZWZhdWx0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2lzc3Vlcy8xODkjaXNzdWVjb21tZW50LTIyNDkxOTgwOVxud2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB8fCBmdW5jdGlvbiAoZnVuYykge1xuICBzZXRUaW1lb3V0KGZ1bmMsIDE2KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvaW1hZ2VcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5mdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5aSW1hZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuICB0eXBlOiAnaW1hZ2UnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7IC8vIE11c3QgYmluZCBlYWNoIHRpbWVcblxuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShzcmMsIHRoaXMuX2ltYWdlLCB0aGlzLCB0aGlzLm9ubG9hZCk7XG5cbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlm77niYflt7Lnu4/liqDovb3lrozmiJBcbiAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gRWxzZSBpcyBjYW52YXNcblxuXG4gICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIH0gLy8g6K6+572udHJhbnNmb3JtXG5cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpOyAvLyBEcmF3IHJlY3QgdGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBaSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3V0aWxcIik7XG5cbnZhciByZXRyaWV2ZTIgPSBfdXRpbC5yZXRyaWV2ZTI7XG52YXIgcmV0cmlldmUzID0gX3V0aWwucmV0cmlldmUzO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIG5vcm1hbGl6ZUNzc0FycmF5ID0gX3V0aWwubm9ybWFsaXplQ3NzQXJyYXk7XG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4vcm91bmRSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9pbWFnZVwiKTtcblxuLy8gVE9ETzogSGF2ZSBub3Qgc3VwcG9ydCAnc3RhcnQnLCAnZW5kJyB5ZXQuXG52YXIgVkFMSURfVEVYVF9BTElHTiA9IHtcbiAgbGVmdDogMSxcbiAgcmlnaHQ6IDEsXG4gIGNlbnRlcjogMVxufTtcbnZhciBWQUxJRF9URVhUX1ZFUlRJQ0FMX0FMSUdOID0ge1xuICB0b3A6IDEsXG4gIGJvdHRvbTogMSxcbiAgbWlkZGxlOiAxXG59O1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBUaGUgaW5wdXQgc3R5bGUuXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlKSB7XG4gIG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgZWFjaChzdHlsZS5yaWNoLCBub3JtYWxpemVTdHlsZSk7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlKSB7XG4gICAgc3R5bGUuZm9udCA9IHRleHRDb250YWluLm1ha2VGb250KHN0eWxlKTtcbiAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgIHRleHRBbGlnbiA9PT0gJ21pZGRsZScgJiYgKHRleHRBbGlnbiA9ICdjZW50ZXInKTtcbiAgICBzdHlsZS50ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX0FMSUdOW3RleHRBbGlnbl0gPyB0ZXh0QWxpZ24gOiAnbGVmdCc7IC8vIENvbXBhdGlibGUgd2l0aCB0ZXh0QmFzZWxpbmUuXG5cbiAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiB8fCBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPT09ICdjZW50ZXInICYmICh0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnKTtcbiAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduID09IG51bGwgfHwgVkFMSURfVEVYVF9WRVJUSUNBTF9BTElHTlt0ZXh0VmVydGljYWxBbGlnbl0gPyB0ZXh0VmVydGljYWxBbGlnbiA6ICd0b3AnO1xuICAgIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuXG4gICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICBzdHlsZS50ZXh0UGFkZGluZyA9IG5vcm1hbGl6ZUNzc0FycmF5KHN0eWxlLnRleHRQYWRkaW5nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gc3R5bGVcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtyZWN0XSB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqICAgICAgICAgICAgICAgICAgSWYgc2V0IGZhbHNlLCByZWN0IHRleHQgaXMgbm90IHVzZWQuXG4gKi9cblxuXG5mdW5jdGlvbiByZW5kZXJUZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkge1xuICBzdHlsZS5yaWNoID8gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSA6IHJlbmRlclBsYWluVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQbGFpblRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBmb250ID0gc2V0Q3R4KGN0eCwgJ2ZvbnQnLCBzdHlsZS5mb250IHx8IHRleHRDb250YWluLkRFRkFVTFRfRk9OVCk7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrO1xuXG4gIGlmICghY29udGVudEJsb2NrIHx8IGhvc3RFbC5fX2RpcnR5KSB7XG4gICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgdGV4dFBhZGRpbmcsIHN0eWxlLnRydW5jYXRlKTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHRleHRMaW5lcyA9IGNvbnRlbnRCbG9jay5saW5lcztcbiAgdmFyIGxpbmVIZWlnaHQgPSBjb250ZW50QmxvY2subGluZUhlaWdodDtcbiAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKG91dGVySGVpZ2h0LCBzdHlsZSwgcmVjdCk7XG4gIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gYm94UG9zLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBPcmlnaW4gb2YgdGV4dFJvdGF0aW9uIHNob3VsZCBiZSB0aGUgYmFzZSBwb2ludCBvZiB0ZXh0IGRyYXdpbmcuXG5cbiAgYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgYmFzZVgsIGJhc2VZKTtcbiAgdmFyIGJveFkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WShiYXNlWSwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHRleHRYID0gYmFzZVg7XG4gIHZhciB0ZXh0WSA9IGJveFk7XG4gIHZhciBuZWVkRHJhd0JnID0gbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKTtcblxuICBpZiAobmVlZERyYXdCZyB8fCB0ZXh0UGFkZGluZykge1xuICAgIC8vIENvbnNpZGVyIHBlcmZvcm1hbmNlLCBkbyBub3QgY2FsbCBnZXRUZXh0V2lkdGggdXRpbCBuZWNlc3NhcnkuXG4gICAgdmFyIHRleHRXaWR0aCA9IHRleHRDb250YWluLmdldFdpZHRoKHRleHQsIGZvbnQpO1xuICAgIHZhciBvdXRlcldpZHRoID0gdGV4dFdpZHRoO1xuICAgIHRleHRQYWRkaW5nICYmIChvdXRlcldpZHRoICs9IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM10pO1xuICAgIHZhciBib3hYID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoYmFzZVgsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gICAgbmVlZERyYXdCZyAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIGJveFgsIGJveFksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcblxuICAgIGlmICh0ZXh0UGFkZGluZykge1xuICAgICAgdGV4dFggPSBnZXRUZXh0WEZvclBhZGRpbmcoYmFzZVgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpO1xuICAgICAgdGV4dFkgKz0gdGV4dFBhZGRpbmdbMF07XG4gICAgfVxuICB9XG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRBbGlnbicsIHRleHRBbGlnbiB8fCAnbGVmdCcpOyAvLyBGb3JjZSBiYXNlbGluZSB0byBiZSBcIm1pZGRsZVwiLiBPdGhlcndpc2UsIGlmIHVzaW5nIFwidG9wXCIsIHRoZVxuICAvLyB0ZXh0IHdpbGwgb2Zmc2V0IGRvd253YXJkIGEgbGl0dGxlIGJpdCBpbiBmb250IFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRCYXNlbGluZScsICdtaWRkbGUnKTsgLy8gQWx3YXlzIHNldCBzaGFkb3dCbHVyIGFuZCBzaGFkb3dPZmZzZXQgdG8gYXZvaWQgbGVhayBmcm9tIGRpc3BsYXlhYmxlLlxuXG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgc3R5bGUudGV4dFNoYWRvd0JsdXIgfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSB8fCAwKTsgLy8gYHRleHRCYXNlbGluZWAgaXMgc2V0IGFzICdtaWRkbGUnLlxuXG4gIHRleHRZICs9IGxpbmVIZWlnaHQgLyAyO1xuICB2YXIgdGV4dFN0cm9rZVdpZHRoID0gc3R5bGUudGV4dFN0cm9rZVdpZHRoO1xuICB2YXIgdGV4dFN0cm9rZSA9IGdldFN0cm9rZShzdHlsZS50ZXh0U3Ryb2tlLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICB2YXIgdGV4dEZpbGwgPSBnZXRGaWxsKHN0eWxlLnRleHRGaWxsKTtcblxuICBpZiAodGV4dFN0cm9rZSkge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRTdHJva2UpO1xuICB9XG5cbiAgaWYgKHRleHRGaWxsKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRGaWxsKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICB0ZXh0U3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgdGV4dFgsIHRleHRZKTtcbiAgICB0ZXh0RmlsbCAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzW2ldLCB0ZXh0WCwgdGV4dFkpO1xuICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHkpIHtcbiAgICBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKTtcbiAgfVxuXG4gIGRyYXdSaWNoVGV4dChob3N0RWwsIGN0eCwgY29udGVudEJsb2NrLCBzdHlsZSwgcmVjdCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdSaWNoVGV4dChob3N0RWwsIGN0eCwgY29udGVudEJsb2NrLCBzdHlsZSwgcmVjdCkge1xuICB2YXIgY29udGVudFdpZHRoID0gY29udGVudEJsb2NrLndpZHRoO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay5vdXRlcldpZHRoO1xuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgYm94UG9zID0gZ2V0Qm94UG9zaXRpb24ob3V0ZXJIZWlnaHQsIHN0eWxlLCByZWN0KTtcbiAgdmFyIGJhc2VYID0gYm94UG9zLmJhc2VYO1xuICB2YXIgYmFzZVkgPSBib3hQb3MuYmFzZVk7XG4gIHZhciB0ZXh0QWxpZ24gPSBib3hQb3MudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBib3hQb3MudGV4dFZlcnRpY2FsQWxpZ247IC8vIE9yaWdpbiBvZiB0ZXh0Um90YXRpb24gc2hvdWxkIGJlIHRoZSBiYXNlIHBvaW50IG9mIHRleHQgZHJhd2luZy5cblxuICBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCBiYXNlWCwgYmFzZVkpO1xuICB2YXIgYm94WCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKGJhc2VYLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgYm94WSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKGJhc2VZLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICB2YXIgeExlZnQgPSBib3hYO1xuICB2YXIgbGluZVRvcCA9IGJveFk7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgeExlZnQgKz0gdGV4dFBhZGRpbmdbM107XG4gICAgbGluZVRvcCArPSB0ZXh0UGFkZGluZ1swXTtcbiAgfVxuXG4gIHZhciB4UmlnaHQgPSB4TGVmdCArIGNvbnRlbnRXaWR0aDtcbiAgbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKSAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIGJveFgsIGJveFksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRCbG9jay5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gY29udGVudEJsb2NrLmxpbmVzW2ldO1xuICAgIHZhciB0b2tlbnMgPSBsaW5lLnRva2VucztcbiAgICB2YXIgdG9rZW5Db3VudCA9IHRva2Vucy5sZW5ndGg7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBsaW5lLmxpbmVIZWlnaHQ7XG4gICAgdmFyIHVzZWRXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgdmFyIGxlZnRJbmRleCA9IDA7XG4gICAgdmFyIGxpbmVYTGVmdCA9IHhMZWZ0O1xuICAgIHZhciBsaW5lWFJpZ2h0ID0geFJpZ2h0O1xuICAgIHZhciByaWdodEluZGV4ID0gdG9rZW5Db3VudCAtIDE7XG4gICAgdmFyIHRva2VuO1xuXG4gICAgd2hpbGUgKGxlZnRJbmRleCA8IHRva2VuQ291bnQgJiYgKHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF0sICF0b2tlbi50ZXh0QWxpZ24gfHwgdG9rZW4udGV4dEFsaWduID09PSAnbGVmdCcpKSB7XG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYTGVmdCwgJ2xlZnQnKTtcbiAgICAgIHVzZWRXaWR0aCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIGxpbmVYTGVmdCArPSB0b2tlbi53aWR0aDtcbiAgICAgIGxlZnRJbmRleCsrO1xuICAgIH1cblxuICAgIHdoaWxlIChyaWdodEluZGV4ID49IDAgJiYgKHRva2VuID0gdG9rZW5zW3JpZ2h0SW5kZXhdLCB0b2tlbi50ZXh0QWxpZ24gPT09ICdyaWdodCcpKSB7XG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYUmlnaHQsICdyaWdodCcpO1xuICAgICAgdXNlZFdpZHRoIC09IHRva2VuLndpZHRoO1xuICAgICAgbGluZVhSaWdodCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIHJpZ2h0SW5kZXgtLTtcbiAgICB9IC8vIFRoZSBvdGhlciB0b2tlbnMgYXJlIHBsYWNlZCBhcyB0ZXh0QWxpZ24gJ2NlbnRlcicgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlLlxuXG5cbiAgICBsaW5lWExlZnQgKz0gKGNvbnRlbnRXaWR0aCAtIChsaW5lWExlZnQgLSB4TGVmdCkgLSAoeFJpZ2h0IC0gbGluZVhSaWdodCkgLSB1c2VkV2lkdGgpIC8gMjtcblxuICAgIHdoaWxlIChsZWZ0SW5kZXggPD0gcmlnaHRJbmRleCkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbbGVmdEluZGV4XTsgLy8gQ29uc2lkZXIgd2lkdGggc3BlY2lmaWVkIGJ5IHVzZXIsIHVzZSAnY2VudGVyJyByYXRoZXIgdGhhbiAnbGVmdCcuXG5cbiAgICAgIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgbGluZVhMZWZ0ICsgdG9rZW4ud2lkdGggLyAyLCAnY2VudGVyJyk7XG4gICAgICBsaW5lWExlZnQgKz0gdG9rZW4ud2lkdGg7XG4gICAgICBsZWZ0SW5kZXgrKztcbiAgICB9XG5cbiAgICBsaW5lVG9wICs9IGxpbmVIZWlnaHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgeCwgeSkge1xuICAvLyB0ZXh0Um90YXRpb24gb25seSBhcHBseSBpbiBSZWN0VGV4dC5cbiAgaWYgKHJlY3QgJiYgc3R5bGUudGV4dFJvdGF0aW9uKSB7XG4gICAgdmFyIG9yaWdpbiA9IHN0eWxlLnRleHRPcmlnaW47XG5cbiAgICBpZiAob3JpZ2luID09PSAnY2VudGVyJykge1xuICAgICAgeCA9IHJlY3Qud2lkdGggLyAyICsgcmVjdC54O1xuICAgICAgeSA9IHJlY3QuaGVpZ2h0IC8gMiArIHJlY3QueTtcbiAgICB9IGVsc2UgaWYgKG9yaWdpbikge1xuICAgICAgeCA9IG9yaWdpblswXSArIHJlY3QueDtcbiAgICAgIHkgPSBvcmlnaW5bMV0gKyByZWN0Lnk7XG4gICAgfVxuXG4gICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTsgLy8gUG9zaXRpdmU6IGFudGljbG9ja3dpc2VcblxuICAgIGN0eC5yb3RhdGUoLXN0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgeCwgdGV4dEFsaWduKSB7XG4gIHZhciB0b2tlblN0eWxlID0gc3R5bGUucmljaFt0b2tlbi5zdHlsZU5hbWVdIHx8IHt9OyAvLyAnY3R4LnRleHRCYXNlbGluZScgaXMgYWx3YXlzIHNldCBhcyAnbWlkZGxlJywgZm9yIHNha2Ugb2ZcbiAgLy8gdGhlIGJpYXMgb2YgXCJNaWNyb3NvZnQgWWFIZWlcIi5cblxuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSB0b2tlbi50ZXh0VmVydGljYWxBbGlnbjtcbiAgdmFyIHkgPSBsaW5lVG9wICsgbGluZUhlaWdodCAvIDI7XG5cbiAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAndG9wJykge1xuICAgIHkgPSBsaW5lVG9wICsgdG9rZW4uaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLSB0b2tlbi5oZWlnaHQgLyAyO1xuICB9XG5cbiAgIXRva2VuLmlzTGluZUhvbGRlciAmJiBuZWVkRHJhd0JhY2tncm91bmQodG9rZW5TdHlsZSkgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHRva2VuU3R5bGUsIHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyA/IHggLSB0b2tlbi53aWR0aCA6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcicgPyB4IC0gdG9rZW4ud2lkdGggLyAyIDogeCwgeSAtIHRva2VuLmhlaWdodCAvIDIsIHRva2VuLndpZHRoLCB0b2tlbi5oZWlnaHQpO1xuICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZztcblxuICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICB4ID0gZ2V0VGV4dFhGb3JQYWRkaW5nKHgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpO1xuICAgIHkgLT0gdG9rZW4uaGVpZ2h0IC8gMiAtIHRleHRQYWRkaW5nWzJdIC0gdG9rZW4udGV4dEhlaWdodCAvIDI7XG4gIH1cblxuICBzZXRDdHgoY3R4LCAnc2hhZG93Qmx1cicsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dCbHVyLCBzdHlsZS50ZXh0U2hhZG93Qmx1ciwgMCkpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93Q29sb3InLCB0b2tlblN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50Jyk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFgsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYLCAwKSk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRZJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFksIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZLCAwKSk7XG4gIHNldEN0eChjdHgsICd0ZXh0QWxpZ24nLCB0ZXh0QWxpZ24pOyAvLyBGb3JjZSBiYXNlbGluZSB0byBiZSBcIm1pZGRsZVwiLiBPdGhlcndpc2UsIGlmIHVzaW5nIFwidG9wXCIsIHRoZVxuICAvLyB0ZXh0IHdpbGwgb2Zmc2V0IGRvd253YXJkIGEgbGl0dGxlIGJpdCBpbiBmb250IFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRCYXNlbGluZScsICdtaWRkbGUnKTtcbiAgc2V0Q3R4KGN0eCwgJ2ZvbnQnLCB0b2tlbi5mb250IHx8IHRleHRDb250YWluLkRFRkFVTFRfRk9OVCk7XG4gIHZhciB0ZXh0U3Ryb2tlID0gZ2V0U3Ryb2tlKHRva2VuU3R5bGUudGV4dFN0cm9rZSB8fCBzdHlsZS50ZXh0U3Ryb2tlLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICB2YXIgdGV4dEZpbGwgPSBnZXRGaWxsKHRva2VuU3R5bGUudGV4dEZpbGwgfHwgc3R5bGUudGV4dEZpbGwpO1xuICB2YXIgdGV4dFN0cm9rZVdpZHRoID0gcmV0cmlldmUyKHRva2VuU3R5bGUudGV4dFN0cm9rZVdpZHRoLCBzdHlsZS50ZXh0U3Ryb2tlV2lkdGgpOyAvLyBGaWxsIGFmdGVyIHN0cm9rZSBzbyB0aGUgb3V0bGluZSB3aWxsIG5vdCBjb3ZlciB0aGUgbWFpbiBwYXJ0LlxuXG4gIGlmICh0ZXh0U3Ryb2tlKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRTdHJva2VXaWR0aCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dFN0cm9rZSk7XG4gICAgY3R4LnN0cm9rZVRleHQodG9rZW4udGV4dCwgeCwgeSk7XG4gIH1cblxuICBpZiAodGV4dEZpbGwpIHtcbiAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEZpbGwpO1xuICAgIGN0eC5maWxsVGV4dCh0b2tlbi50ZXh0LCB4LCB5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpIHtcbiAgcmV0dXJuIHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgc3R5bGUudGV4dEJvcmRlcldpZHRoICYmIHN0eWxlLnRleHRCb3JkZXJDb2xvcjtcbn0gLy8gc3R5bGU6IHt0ZXh0QmFja2dyb3VuZENvbG9yLCB0ZXh0Qm9yZGVyV2lkdGgsIHRleHRCb3JkZXJDb2xvciwgdGV4dEJvcmRlclJhZGl1c31cbi8vIHNoYXBlOiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cblxuXG5mdW5jdGlvbiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yO1xuICB2YXIgdGV4dEJvcmRlcldpZHRoID0gc3R5bGUudGV4dEJvcmRlcldpZHRoO1xuICB2YXIgdGV4dEJvcmRlckNvbG9yID0gc3R5bGUudGV4dEJvcmRlckNvbG9yO1xuICB2YXIgaXNQbGFpbkJnID0gaXNTdHJpbmcodGV4dEJhY2tncm91bmRDb2xvcik7XG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgc3R5bGUudGV4dEJveFNoYWRvd0JsdXIgfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHN0eWxlLnRleHRCb3hTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WSB8fCAwKTtcblxuICBpZiAoaXNQbGFpbkJnIHx8IHRleHRCb3JkZXJXaWR0aCAmJiB0ZXh0Qm9yZGVyQ29sb3IpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgdmFyIHRleHRCb3JkZXJSYWRpdXMgPSBzdHlsZS50ZXh0Qm9yZGVyUmFkaXVzO1xuXG4gICAgaWYgKCF0ZXh0Qm9yZGVyUmFkaXVzKSB7XG4gICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcjogdGV4dEJvcmRlclJhZGl1c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG5cbiAgaWYgKGlzUGxhaW5CZykge1xuICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcbiAgICBjdHguZmlsbCgpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRleHRCYWNrZ3JvdW5kQ29sb3IpKSB7XG4gICAgdmFyIGltYWdlID0gdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTtcbiAgICBpbWFnZSA9IGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2UoaW1hZ2UsIG51bGwsIGhvc3RFbCwgb25CZ0ltYWdlTG9hZGVkLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcblxuICAgIGlmIChpbWFnZSAmJiBpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0Qm9yZGVyV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRCb3JkZXJDb2xvcik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQmdJbWFnZUxvYWRlZChpbWFnZSwgdGV4dEJhY2tncm91bmRDb2xvcikge1xuICAvLyBSZXBsYWNlIGltYWdlLCBzbyB0aGF0IGBjb250YWluL3RleHQuanMjcGFyc2VSaWNoVGV4dGBcbiAgLy8gd2lsbCBnZXQgY29ycmVjdCByZXN1bHQgaW4gbmV4dCB0aWNrLlxuICB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlID0gaW1hZ2U7XG59XG5cbmZ1bmN0aW9uIGdldEJveFBvc2l0aW9uKGJsb2NrSGVpaHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBiYXNlWCA9IHN0eWxlLnggfHwgMDtcbiAgdmFyIGJhc2VZID0gc3R5bGUueSB8fCAwO1xuICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjsgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuXG4gIGlmIChyZWN0KSB7XG4gICAgdmFyIHRleHRQb3NpdGlvbiA9IHN0eWxlLnRleHRQb3NpdGlvbjtcblxuICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgLy8gUGVyY2VudFxuICAgICAgYmFzZVggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgIGJhc2VZID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgc3R5bGUudGV4dERpc3RhbmNlKTtcbiAgICAgIGJhc2VYID0gcmVzLng7XG4gICAgICBiYXNlWSA9IHJlcy55OyAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cblxuICAgICAgdGV4dEFsaWduID0gdGV4dEFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduIHx8IHJlcy50ZXh0VmVydGljYWxBbGlnbjtcbiAgICB9IC8vIHRleHRPZmZzZXQgaXMgb25seSBzdXBwb3J0IGluIFJlY3RUZXh0LCBvdGhlcndpc2VcbiAgICAvLyB3ZSBoYXZlIHRvIGFkanVzdCBib3VuZGluZ1JlY3QgZm9yIHRleHRPZmZzZXQuXG5cblxuICAgIHZhciB0ZXh0T2Zmc2V0ID0gc3R5bGUudGV4dE9mZnNldDtcblxuICAgIGlmICh0ZXh0T2Zmc2V0KSB7XG4gICAgICBiYXNlWCArPSB0ZXh0T2Zmc2V0WzBdO1xuICAgICAgYmFzZVkgKz0gdGV4dE9mZnNldFsxXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhc2VYOiBiYXNlWCxcbiAgICBiYXNlWTogYmFzZVksXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNldEN0eChjdHgsIHByb3AsIHZhbHVlKSB7XG4gIC8vIEZJWE1FID8/PyBwZXJmb3JtYW5jZSB0cnlcbiAgLy8gaWYgKGN0eC5fX2N1cnJlbnRWYWx1ZXNbcHJvcF0gIT09IHZhbHVlKSB7XG4gIC8vIGN0eFtwcm9wXSA9IGN0eC5fX2N1cnJlbnRWYWx1ZXNbcHJvcF0gPSB2YWx1ZTtcbiAgY3R4W3Byb3BdID0gdmFsdWU7IC8vIH1cblxuICByZXR1cm4gY3R4W3Byb3BdO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cm9rZV0gSWYgc3BlY2lmaWVkLCBkbyBub3QgY2hlY2sgc3R5bGUudGV4dFN0cm9rZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGluZVdpZHRoXSBJZiBzcGVjaWZpZWQsIGRvIG5vdCBjaGVjayBzdHlsZS50ZXh0U3Ryb2tlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0eWxlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTdHJva2Uoc3Ryb2tlLCBsaW5lV2lkdGgpIHtcbiAgcmV0dXJuIHN0cm9rZSA9PSBudWxsIHx8IGxpbmVXaWR0aCA8PSAwIHx8IHN0cm9rZSA9PT0gJ3RyYW5zcGFyZW50JyB8fCBzdHJva2UgPT09ICdub25lJyA/IG51bGwgLy8gVE9ETyBwYXR0ZXJuIGFuZCBncmFkaWVudD9cbiAgOiBzdHJva2UuaW1hZ2UgfHwgc3Ryb2tlLmNvbG9yU3RvcHMgPyAnIzAwMCcgOiBzdHJva2U7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGwoZmlsbCkge1xuICByZXR1cm4gZmlsbCA9PSBudWxsIHx8IGZpbGwgPT09ICdub25lJyA/IG51bGwgLy8gVE9ETyBwYXR0ZXJuIGFuZCBncmFkaWVudD9cbiAgOiBmaWxsLmltYWdlIHx8IGZpbGwuY29sb3JTdG9wcyA/ICcjMDAwJyA6IGZpbGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudCh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsdWUubGFzdEluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRYRm9yUGFkZGluZyh4LCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKSB7XG4gIHJldHVybiB0ZXh0QWxpZ24gPT09ICdyaWdodCcgPyB4IC0gdGV4dFBhZGRpbmdbMV0gOiB0ZXh0QWxpZ24gPT09ICdjZW50ZXInID8geCArIHRleHRQYWRkaW5nWzNdIC8gMiAtIHRleHRQYWRkaW5nWzFdIC8gMiA6IHggKyB0ZXh0UGFkZGluZ1szXTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gbmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSB7XG4gIHJldHVybiB0ZXh0ICE9IG51bGwgJiYgKHRleHQgfHwgc3R5bGUudGV4dEJhY2tncm91bmRDb2xvciB8fCBzdHlsZS50ZXh0Qm9yZGVyV2lkdGggJiYgc3R5bGUudGV4dEJvcmRlckNvbG9yIHx8IHN0eWxlLnRleHRQYWRkaW5nKTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVUZXh0U3R5bGUgPSBub3JtYWxpemVUZXh0U3R5bGU7XG5leHBvcnRzLnJlbmRlclRleHQgPSByZW5kZXJUZXh0O1xuZXhwb3J0cy5nZXRTdHJva2UgPSBnZXRTdHJva2U7XG5leHBvcnRzLmdldEZpbGwgPSBnZXRGaWxsO1xuZXhwb3J0cy5uZWVkRHJhd1RleHQgPSBuZWVkRHJhd1RleHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZnVuY3Rpb24gYnVpbGRQYXRoKGN0eCwgc2hhcGUpIHtcbiAgdmFyIHggPSBzaGFwZS54O1xuICB2YXIgeSA9IHNoYXBlLnk7XG4gIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICB2YXIgciA9IHNoYXBlLnI7XG4gIHZhciByMTtcbiAgdmFyIHIyO1xuICB2YXIgcjM7XG4gIHZhciByNDsgLy8gQ29udmVydCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHBvc2l0aXZlIGZvciBiZXR0ZXIgYm9yZGVyUmFkaXVzXG5cbiAgaWYgKHdpZHRoIDwgMCkge1xuICAgIHggPSB4ICsgd2lkdGg7XG4gICAgd2lkdGggPSAtd2lkdGg7XG4gIH1cblxuICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgcjEgPSByMiA9IHIzID0gcjQgPSByO1xuICB9IGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGlmIChyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByWzBdO1xuICAgIH0gZWxzZSBpZiAoci5sZW5ndGggPT09IDIpIHtcbiAgICAgIHIxID0gcjMgPSByWzBdO1xuICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgfSBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMykge1xuICAgICAgcjEgPSByWzBdO1xuICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICByMyA9IHJbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHIxID0gclswXTtcbiAgICAgIHIyID0gclsxXTtcbiAgICAgIHIzID0gclsyXTtcbiAgICAgIHI0ID0gclszXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcjEgPSByMiA9IHIzID0gcjQgPSAwO1xuICB9XG5cbiAgdmFyIHRvdGFsO1xuXG4gIGlmIChyMSArIHIyID4gd2lkdGgpIHtcbiAgICB0b3RhbCA9IHIxICsgcjI7XG4gICAgcjEgKj0gd2lkdGggLyB0b3RhbDtcbiAgICByMiAqPSB3aWR0aCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIzICsgcjQgPiB3aWR0aCkge1xuICAgIHRvdGFsID0gcjMgKyByNDtcbiAgICByMyAqPSB3aWR0aCAvIHRvdGFsO1xuICAgIHI0ICo9IHdpZHRoIC8gdG90YWw7XG4gIH1cblxuICBpZiAocjIgKyByMyA+IGhlaWdodCkge1xuICAgIHRvdGFsID0gcjIgKyByMztcbiAgICByMiAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICByMyAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMSArIHI0ID4gaGVpZ2h0KSB7XG4gICAgdG90YWwgPSByMSArIHI0O1xuICAgIHIxICo9IGhlaWdodCAvIHRvdGFsO1xuICAgIHI0ICo9IGhlaWdodCAvIHRvdGFsO1xuICB9XG5cbiAgY3R4Lm1vdmVUbyh4ICsgcjEsIHkpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHIyLCB5KTtcbiAgcjIgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByMik7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcjMpO1xuICByMyAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHIzLCB5ICsgaGVpZ2h0KTtcbiAgY3R4LmxpbmVUbyh4ICsgcjQsIHkgKyBoZWlnaHQpO1xuICByNCAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcjQpO1xuICBjdHgubGluZVRvKHgsIHkgKyByMSk7XG4gIHIxICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByMSwgeSk7XG59XG5cbmV4cG9ydHMuYnVpbGRQYXRoID0gYnVpbGRQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuL2N1cnZlXCIpO1xuXG4vKipcbiAqIEBhdXRob3IgWWkgU2hlbihodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBzdGFydCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbnZhciBleHRyZW1pdHkgPSB2ZWMyLmNyZWF0ZSgpO1xuLyoqXG4gKiDku47pobbngrnmlbDnu4TkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvaW50cyDpobbngrnmlbDnu4RcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqL1xuXG5mdW5jdGlvbiBmcm9tUG9pbnRzKHBvaW50cywgbWluLCBtYXgpIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcCA9IHBvaW50c1swXTtcbiAgdmFyIGxlZnQgPSBwWzBdO1xuICB2YXIgcmlnaHQgPSBwWzBdO1xuICB2YXIgdG9wID0gcFsxXTtcbiAgdmFyIGJvdHRvbSA9IHBbMV07XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBwID0gcG9pbnRzW2ldO1xuICAgIGxlZnQgPSBtYXRoTWluKGxlZnQsIHBbMF0pO1xuICAgIHJpZ2h0ID0gbWF0aE1heChyaWdodCwgcFswXSk7XG4gICAgdG9wID0gbWF0aE1pbih0b3AsIHBbMV0pO1xuICAgIGJvdHRvbSA9IG1hdGhNYXgoYm90dG9tLCBwWzFdKTtcbiAgfVxuXG4gIG1pblswXSA9IGxlZnQ7XG4gIG1pblsxXSA9IHRvcDtcbiAgbWF4WzBdID0gcmlnaHQ7XG4gIG1heFsxXSA9IGJvdHRvbTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbUxpbmUoeDAsIHkwLCB4MSwgeTEsIG1pbiwgbWF4KSB7XG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgeTEpO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbn1cblxudmFyIHhEaW0gPSBbXTtcbnZhciB5RGltID0gW107XG4vKipcbiAqIOS7juS4iemYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyLCBwMynkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge251bWJlcn0geDNcbiAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5mdW5jdGlvbiBmcm9tQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW4sIG1heCkge1xuICB2YXIgY3ViaWNFeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hO1xuICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gIHZhciBpO1xuICB2YXIgbiA9IGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgeERpbSk7XG4gIG1pblswXSA9IEluZmluaXR5O1xuICBtaW5bMV0gPSBJbmZpbml0eTtcbiAgbWF4WzBdID0gLUluZmluaXR5O1xuICBtYXhbMV0gPSAtSW5maW5pdHk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgeERpbVtpXSk7XG4gICAgbWluWzBdID0gbWF0aE1pbih4LCBtaW5bMF0pO1xuICAgIG1heFswXSA9IG1hdGhNYXgoeCwgbWF4WzBdKTtcbiAgfVxuXG4gIG4gPSBjdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIHlEaW0pO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHlEaW1baV0pO1xuICAgIG1pblsxXSA9IG1hdGhNaW4oeSwgbWluWzFdKTtcbiAgICBtYXhbMV0gPSBtYXRoTWF4KHksIG1heFsxXSk7XG4gIH1cblxuICBtaW5bMF0gPSBtYXRoTWluKHgwLCBtaW5bMF0pO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCBtYXhbMF0pO1xuICBtaW5bMF0gPSBtYXRoTWluKHgzLCBtaW5bMF0pO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgzLCBtYXhbMF0pO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCBtaW5bMV0pO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCBtYXhbMV0pO1xuICBtaW5bMV0gPSBtYXRoTWluKHkzLCBtaW5bMV0pO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkzLCBtYXhbMV0pO1xufVxuLyoqXG4gKiDku47kuozpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMinkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbVF1YWRyYXRpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBtaW4sIG1heCkge1xuICB2YXIgcXVhZHJhdGljRXh0cmVtdW0gPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bTtcbiAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmUucXVhZHJhdGljQXQ7IC8vIEZpbmQgZXh0cmVtaXRpZXMsIHdoZXJlIGRlcml2YXRpdmUgaW4geCBkaW0gb3IgeSBkaW0gaXMgemVyb1xuXG4gIHZhciB0eCA9IG1hdGhNYXgobWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDApO1xuICB2YXIgdHkgPSBtYXRoTWF4KG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5MiksIDEpLCAwKTtcbiAgdmFyIHggPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0eCk7XG4gIHZhciB5ID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdHkpO1xuICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MiwgeCk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDIsIHgpO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MiwgeSk7XG59XG4vKipcbiAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IHJ4XG4gKiBAcGFyYW0ge251bWJlcn0gcnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbUFyYyh4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heCkge1xuICB2YXIgdmVjMk1pbiA9IHZlYzIubWluO1xuICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cbiAgaWYgKGRpZmYgJSBQSTIgPCAxZS00ICYmIGRpZmYgPiAxZS00KSB7XG4gICAgLy8gSXMgYSBjaXJjbGVcbiAgICBtaW5bMF0gPSB4IC0gcng7XG4gICAgbWluWzFdID0geSAtIHJ5O1xuICAgIG1heFswXSA9IHggKyByeDtcbiAgICBtYXhbMV0gPSB5ICsgcnk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhcnRbMF0gPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyB4O1xuICBzdGFydFsxXSA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIHk7XG4gIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICBlbmRbMV0gPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgeTtcbiAgdmVjMk1pbihtaW4sIHN0YXJ0LCBlbmQpO1xuICB2ZWMyTWF4KG1heCwgc3RhcnQsIGVuZCk7IC8vIFRocmVzaCB0byBbMCwgTWF0aC5QSSAqIDJdXG5cbiAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgJSBQSTI7XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPCAwKSB7XG4gICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBQSTI7XG4gIH1cblxuICBlbmRBbmdsZSA9IGVuZEFuZ2xlICUgUEkyO1xuXG4gIGlmIChlbmRBbmdsZSA8IDApIHtcbiAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICsgUEkyO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSAmJiAhYW50aWNsb2Nrd2lzZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfSBlbHNlIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUgJiYgYW50aWNsb2Nrd2lzZSkge1xuICAgIHN0YXJ0QW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gZW5kQW5nbGU7XG4gICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gIH0gLy8gdmFyIG51bWJlciA9IDA7XG4gIC8vIHZhciBzdGVwID0gKGFudGljbG9ja3dpc2UgPyAtTWF0aC5QSSA6IE1hdGguUEkpIC8gMjtcblxuXG4gIGZvciAodmFyIGFuZ2xlID0gMDsgYW5nbGUgPCBlbmRBbmdsZTsgYW5nbGUgKz0gTWF0aC5QSSAvIDIpIHtcbiAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICBleHRyZW1pdHlbMF0gPSBtYXRoQ29zKGFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgIGV4dHJlbWl0eVsxXSA9IG1hdGhTaW4oYW5nbGUpICogcnkgKyB5O1xuICAgICAgdmVjMk1pbihtaW4sIGV4dHJlbWl0eSwgbWluKTtcbiAgICAgIHZlYzJNYXgobWF4LCBleHRyZW1pdHksIG1heCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZnJvbVBvaW50cyA9IGZyb21Qb2ludHM7XG5leHBvcnRzLmZyb21MaW5lID0gZnJvbUxpbmU7XG5leHBvcnRzLmZyb21DdWJpYyA9IGZyb21DdWJpYztcbmV4cG9ydHMuZnJvbVF1YWRyYXRpYyA9IGZyb21RdWFkcmF0aWM7XG5leHBvcnRzLmZyb21BcmMgPSBmcm9tQXJjO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG5mdW5jdGlvbiBub3JtYWxpemVSYWRpYW4oYW5nbGUpIHtcbiAgYW5nbGUgJT0gUEkyO1xuXG4gIGlmIChhbmdsZSA8IDApIHtcbiAgICBhbmdsZSArPSBQSTI7XG4gIH1cblxuICByZXR1cm4gYW5nbGU7XG59XG5cbmV4cG9ydHMubm9ybWFsaXplUmFkaWFuID0gbm9ybWFsaXplUmFkaWFuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgfHwgeSA8IHkwICYmIHkgPCB5MSkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcblxuXG4gIGlmICh5MSA9PT0geTApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkaXIgPSB5MSA8IHkwID8gMSA6IC0xO1xuICB2YXIgdCA9ICh5IC0geTApIC8gKHkxIC0geTApOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICBpZiAodCA9PT0gMSB8fCB0ID09PSAwKSB7XG4gICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gIH1cblxuICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7XG4gIHJldHVybiB4XyA+IHggPyBkaXIgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRpbmdMaW5lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlbnYgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9lbnZcIik7XG5cbi8vIEZpeCB3ZWlyZCBidWcgaW4gc29tZSB2ZXJzaW9uIG9mIElFMTEgKGxpa2UgMTEuMC45NjAwLjE3OCoqKSxcbi8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcbi8vIG1pZ2h0IGJlIHRocm93biB3aGVuIGNhbGxpbmcgY3R4LmZpbGwgb3IgY3R4LnN0cm9rZSBhZnRlciBhIHBhdGhcbi8vIHdob3NlIGFyZWEgc2l6ZSBpcyB6ZXJvIGlzIGRyYXduIGFuZCBjdHguY2xpcCgpIGlzIGNhbGxlZCBhbmRcbi8vIHNoYWRvd0JsdXIgaXMgc2V0LiBTZWUgIzQ1NzIsICMzMTEyLCAjNTc3Ny5cbi8vIChlLmcuLFxuLy8gIGN0eC5tb3ZlVG8oMTAsIDEwKTtcbi8vICBjdHgubGluZVRvKDIwLCAxMCk7XG4vLyAgY3R4LmNsb3NlUGF0aCgpO1xuLy8gIGN0eC5jbGlwKCk7XG4vLyAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcbi8vICAuLi5cbi8vICBjdHguZmlsbCgpO1xuLy8gKVxudmFyIHNoYWRvd1RlbXAgPSBbWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF1dO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChvcmlnbmFsQnJ1c2gpIHtcbiAgLy8gdmVyc2lvbiBzdHJpbmcgY2FuIGJlOiAnMTEuMCdcbiAgcmV0dXJuIGVudi5icm93c2VyLmllICYmIGVudi5icm93c2VyLnZlcnNpb24gPj0gMTEgPyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsaXBQYXRocyA9IHRoaXMuX19jbGlwUGF0aHM7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbW9kaWZpZWQ7XG5cbiAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnNoYXBlO1xuICAgICAgICB2YXIgdHlwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnR5cGU7XG5cbiAgICAgICAgaWYgKHNoYXBlICYmICh0eXBlID09PSAnc2VjdG9yJyAmJiBzaGFwZS5zdGFydEFuZ2xlID09PSBzaGFwZS5lbmRBbmdsZSB8fCB0eXBlID09PSAncmVjdCcgJiYgKCFzaGFwZS53aWR0aCB8fCAhc2hhcGUuaGVpZ2h0KSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIC8vIEl0IGlzIHNhdmUgdG8gcHV0IHNoYWRvd1RlbXAgc3RhdGljLCBiZWNhdXNlIHNoYWRvd1RlbXBcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYWxsIG1vZGlmaWVkIGVhY2ggaXRlbSBicnVzaCBjYWxsZWQuXG4gICAgICAgICAgICBzaGFkb3dUZW1wW2pdWzJdID0gc3R5bGVbc2hhZG93VGVtcFtqXVswXV07XG4gICAgICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3JpZ25hbEJydXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMl07XG4gICAgICB9XG4gICAgfVxuICB9IDogb3JpZ25hbEJydXNoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgc21vb3RoU3BsaW5lID0gcmVxdWlyZShcIi4vc21vb3RoU3BsaW5lXCIpO1xuXG52YXIgc21vb3RoQmV6aWVyID0gcmVxdWlyZShcIi4vc21vb3RoQmV6aWVyXCIpO1xuXG5mdW5jdGlvbiBidWlsZFBhdGgoY3R4LCBzaGFwZSwgY2xvc2VQYXRoKSB7XG4gIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gIHZhciBzbW9vdGggPSBzaGFwZS5zbW9vdGg7XG5cbiAgaWYgKHBvaW50cyAmJiBwb2ludHMubGVuZ3RoID49IDIpIHtcbiAgICBpZiAoc21vb3RoICYmIHNtb290aCAhPT0gJ3NwbGluZScpIHtcbiAgICAgIHZhciBjb250cm9sUG9pbnRzID0gc21vb3RoQmV6aWVyKHBvaW50cywgc21vb3RoLCBjbG9zZVBhdGgsIHNoYXBlLnNtb290aENvbnN0cmFpbnQpO1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoY2xvc2VQYXRoID8gbGVuIDogbGVuIC0gMSk7IGkrKykge1xuICAgICAgICB2YXIgY3AxID0gY29udHJvbFBvaW50c1tpICogMl07XG4gICAgICAgIHZhciBjcDIgPSBjb250cm9sUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgIHZhciBwID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcDFbMF0sIGNwMVsxXSwgY3AyWzBdLCBjcDJbMV0sIHBbMF0sIHBbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc21vb3RoID09PSAnc3BsaW5lJykge1xuICAgICAgICBwb2ludHMgPSBzbW9vdGhTcGxpbmUocG9pbnRzLCBjbG9zZVBhdGgpO1xuICAgICAgfVxuXG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlUGF0aCAmJiBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn1cblxuZXhwb3J0cy5idWlsZFBhdGggPSBidWlsZFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jbGF6eiA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2NsYXp6XCIpO1xuXG52YXIgc2V0ID0gX2NsYXp6LnNldDtcbnZhciBnZXQgPSBfY2xhenouZ2V0O1xudmFyIF9kZWZhdWx0ID0ge1xuICBjbGVhckNvbG9yUGFsZXR0ZTogZnVuY3Rpb24gKCkge1xuICAgIHNldCh0aGlzLCAnY29sb3JJZHgnLCAwKTtcbiAgICBzZXQodGhpcywgJ2NvbG9yTmFtZU1hcCcsIHt9KTtcbiAgfSxcbiAgZ2V0Q29sb3JGcm9tUGFsZXR0ZTogZnVuY3Rpb24gKG5hbWUsIHNjb3BlKSB7XG4gICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xuICAgIHZhciBjb2xvcklkeCA9IGdldChzY29wZSwgJ2NvbG9ySWR4JykgfHwgMDtcbiAgICB2YXIgY29sb3JOYW1lTWFwID0gZ2V0KHNjb3BlLCAnY29sb3JOYW1lTWFwJykgfHwgc2V0KHNjb3BlLCAnY29sb3JOYW1lTWFwJywge30pOyAvLyBVc2UgYGhhc093blByb3BlcnR5YCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG5cbiAgICBpZiAoY29sb3JOYW1lTWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gY29sb3JOYW1lTWFwW25hbWVdO1xuICAgIH1cblxuICAgIHZhciBjb2xvclBhbGV0dGUgPSB0aGlzLmdldCgnY29sb3InLCB0cnVlKSB8fCBbXTtcblxuICAgIGlmICghY29sb3JQYWxldHRlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb2xvciA9IGNvbG9yUGFsZXR0ZVtjb2xvcklkeF07XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgY29sb3JOYW1lTWFwW25hbWVdID0gY29sb3I7XG4gICAgfVxuXG4gICAgc2V0KHNjb3BlLCAnY29sb3JJZHgnLCAoY29sb3JJZHggKyAxKSAlIGNvbG9yUGFsZXR0ZS5sZW5ndGgpO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vY29sb3JQYWxldHRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgR3JvdXAgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwXCIpO1xuXG52YXIgY29tcG9uZW50VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2NvbXBvbmVudFwiKTtcblxudmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2NsYXp6XCIpO1xuXG52YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKCk7XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgndmlld0NvbXBvbmVudCcpO1xufTtcblxuQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IENvbXBvbmVudCxcbiAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge30sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHt9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxufTtcbnZhciBjb21wb25lbnRQcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbmNvbXBvbmVudFByb3RvLnVwZGF0ZVZpZXcgPSBjb21wb25lbnRQcm90by51cGRhdGVMYXlvdXQgPSBjb21wb25lbnRQcm90by51cGRhdGVWaXN1YWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkgey8vIERvIG5vdGhpbmc7XG59OyAvLyBFbmFibGUgQ29tcG9uZW50LmV4dGVuZC5cblxuXG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoQ29tcG9uZW50KTsgLy8gRW5hYmxlIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuXG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KENvbXBvbmVudCwge1xuICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcbn0pO1xudmFyIF9kZWZhdWx0ID0gQ29tcG9uZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aWV3L0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXBcIik7XG5cbnZhciBjb21wb25lbnRVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY29tcG9uZW50XCIpO1xuXG52YXIgY2xhenpVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxuZnVuY3Rpb24gQ2hhcnQoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCd2aWV3Q2hhcnQnKTtcbn1cblxuQ2hhcnQucHJvdG90eXBlID0ge1xuICB0eXBlOiAnY2hhcnQnLFxuXG4gIC8qKlxuICAgKiBJbml0IHRoZSBjaGFydFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHt9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGNoYXJ0XG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge30sXG5cbiAgLyoqXG4gICAqIEhpZ2hsaWdodCBzZXJpZXMgb3Igc3BlY2lmaWVkIGRhdGEgaXRlbVxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWRcbiAgICovXG4gIGhpZ2hsaWdodDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0b2dnbGVIaWdobGlnaHQoc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBwYXlsb2FkLCAnZW1waGFzaXMnKTtcbiAgfSxcblxuICAvKipcbiAgICogRG93bnBsYXkgc2VyaWVzIG9yIHNwZWNpZmllZCBkYXRhIGl0ZW1cbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAqL1xuICBkb3ducGxheTogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0b2dnbGVIaWdobGlnaHQoc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBwYXlsb2FkLCAnbm9ybWFsJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxmXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZSBzZWxmXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge31cbiAgLyoqXG4gICAqIFRoZSB2aWV3IGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQGludGVyZmFjZVxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgLy8gY29udGFpblBvaW50OiBmdW5jdGlvbiAoKSB7fVxuXG59O1xudmFyIGNoYXJ0UHJvdG8gPSBDaGFydC5wcm90b3R5cGU7XG5cbmNoYXJ0UHJvdG8udXBkYXRlVmlldyA9IGNoYXJ0UHJvdG8udXBkYXRlTGF5b3V0ID0gY2hhcnRQcm90by51cGRhdGVWaXN1YWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICB0aGlzLnJlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbn07XG4vKipcbiAqIFNldCBzdGF0ZSBvZiBzaW5nbGUgZWxlbWVudFxuICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGVsU2V0U3RhdGUoZWwsIHN0YXRlKSB7XG4gIGlmIChlbCkge1xuICAgIGVsLnRyaWdnZXIoc3RhdGUpO1xuXG4gICAgaWYgKGVsLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWwuY2hpbGRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgZWxTZXRTdGF0ZShlbC5jaGlsZEF0KGkpLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0YXRlICdub3JtYWwnfCdlbXBoYXNpcydcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gdG9nZ2xlSGlnaGxpZ2h0KGRhdGEsIHBheWxvYWQsIHN0YXRlKSB7XG4gIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgaWYgKGRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgenJVdGlsLmVhY2gobW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkoZGF0YUluZGV4KSwgZnVuY3Rpb24gKGRhdGFJZHgpIHtcbiAgICAgIGVsU2V0U3RhdGUoZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJZHgpLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsU2V0U3RhdGUoZWwsIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufSAvLyBFbmFibGUgQ2hhcnQuZXh0ZW5kLlxuXG5cbmNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDaGFydCwgWydkaXNwb3NlJ10pOyAvLyBBZGQgY2FwYWJpbGl0eSBvZiByZWdpc3RlckNsYXNzLCBnZXRDbGFzcywgaGFzQ2xhc3MsIHJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciBhbmQgc28gb24uXG5cbmNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ2hhcnQsIHtcbiAgcmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlXG59KTtcbnZhciBfZGVmYXVsdCA9IENoYXJ0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aWV3L0NoYXJ0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIF9tb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG52YXIgbm9ybWFsaXplVG9BcnJheSA9IF9tb2RlbC5ub3JtYWxpemVUb0FycmF5O1xuXG4vKipcbiAqIENvbXBsZXRlIGRpbWVuc2lvbnMgYnkgZGF0YSAoZ3Vlc3MgZGltZW5zaW9uKS5cbiAqL1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBpc1N0cmluZyA9IHpyVXRpbC5pc1N0cmluZztcbnZhciBkZWZhdWx0cyA9IHpyVXRpbC5kZWZhdWx0cztcbnZhciBPVEhFUl9ESU1TID0ge1xuICB0b29sdGlwOiAxLFxuICBsYWJlbDogMSxcbiAgaXRlbU5hbWU6IDFcbn07XG4vKipcbiAqIENvbXBsZXRlIHRoZSBkaW1lbnNpb25zIGFycmF5LCBieSB1c2VyIGRlZmluZWQgYGRpbWVuc2lvbmAgYW5kIGBlbmNvZGVgLFxuICogYW5kIGd1ZXNzaW5nIGZyb20gdGhlIGRhdGEgc3RydWN0dXJlLlxuICogSWYgbm8gJ3ZhbHVlJyBkaW1lbnNpb24gc3BlY2lmaWVkLCB0aGUgZmlyc3Qgbm8tbmFtZWQgZGltZW5zaW9uIHdpbGwgYmVcbiAqIG5hbWVkIGFzICd2YWx1ZScuXG4gKlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc3lzRGltcyBOZWNlc3NhcnkgZGltZW5zaW9ucywgbGlrZSBbJ3gnLCAneSddLCB3aGljaFxuICogICAgICBwcm92aWRlcyBub3Qgb25seSBkaW0gdGVtcGxhdGUsIGJ1dCBhbHNvIGRlZmF1bHQgb3JkZXIuXG4gKiAgICAgIGBuYW1lYCBvZiBlYWNoIGl0ZW0gcHJvdmlkZXMgZGVmYXVsdCBjb29yZCBuYW1lLlxuICogICAgICBbe2RpbXNEZWY6IFtdfSwgLi4uXSBjYW4gYmUgc3BlY2lmaWVkIHRvIGdpdmUgbmFtZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIERhdGEgbGlzdC4gW1sxLCAyLCAzXSwgWzIsIDMsIDRdXS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0fHN0cmluZz59IFtvcHQuZGltc0RlZl0gb3B0aW9uLnNlcmllcy5kaW1lbnNpb25zIFVzZXIgZGVmaW5lZCBkaW1lbnNpb25zXG4gKiAgICAgIEZvciBleGFtcGxlOiBbJ2FzZGYnLCB7bmFtZSwgdHlwZX0sIC4uLl0uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdC5lbmNvZGVEZWZdIG9wdGlvbi5zZXJpZXMuZW5jb2RlIHt4OiAyLCB5OiBbMywgMV0sIHRvb2x0aXA6IFsxLCAyXSwgbGFiZWw6IDN9XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdC5leHRyYVByZWZpeF0gUHJlZml4IG9mIG5hbWUgd2hlbiBmaWxsaW5nIHRoZSBsZWZ0IGRpbWVuc2lvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdC5leHRyYUZyb21aZXJvXSBJZiBzcGVjaWZpZWQsIGV4dHJhIGRpbSBuYW1lcyB3aWxsIGJlOlxuICogICAgICAgICAgICAgICAgICAgICAgZXh0cmFQcmVmaXggKyAwLCBleHRyYVByZWZpeCArIGV4dHJhQmFzZUluZGV4ICsgMSAuLi5cbiAqICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBzcGVjaWZpZWQsIGV4dHJhIGRpbSBuYW1lcyB3aWxsIGJlOlxuICogICAgICAgICAgICAgICAgICAgICAgZXh0cmFQcmVmaXgsIGV4dHJhUHJlZml4ICsgMCwgZXh0cmFQcmVmaXggKyAxIC4uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZGltQ291bnRdIElmIG5vdCBzcGVjaWZpZWQsIGd1ZXNzIGJ5IHRoZSBmaXJzdCBkYXRhIGl0ZW0uXG4gKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gW3tcbiAqICAgICAgbmFtZTogc3RyaW5nIG1hbmRhdG9yeSxcbiAqICAgICAgY29vcmREaW06IHN0cmluZyBtYW5kYXRvcnksXG4gKiAgICAgIGNvb3JkRGltSW5kZXg6IG51bWJlciBtYW5kYXRvcnksXG4gKiAgICAgIHR5cGU6IHN0cmluZyBvcHRpb25hbCxcbiAqICAgICAgdG9vbHRpcE5hbWU6IHN0cmluZyBvcHRpb25hbCxcbiAqICAgICAgb3RoZXJEaW1zOiB7XG4gKiAgICAgICAgICB0b29sdGlwOiBudW1iZXIgb3B0aW9uYWwsXG4gKiAgICAgICAgICBsYWJlbDogbnVtYmVyIG9wdGlvbmFsXG4gKiAgICAgIH0sXG4gKiAgICAgIGlzRXh0cmFDb29yZDogYm9vbGVhbiB0cnVlIG9yIHVuZGVmaW5lZC5cbiAqICAgICAgb3RoZXIgcHJvcHMgLi4uXG4gKiB9XVxuICovXG5cbmZ1bmN0aW9uIGNvbXBsZXRlRGltZW5zaW9ucyhzeXNEaW1zLCBkYXRhLCBvcHQpIHtcbiAgZGF0YSA9IGRhdGEgfHwgW107XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgc3lzRGltcyA9IChzeXNEaW1zIHx8IFtdKS5zbGljZSgpO1xuICB2YXIgZGltc0RlZiA9IChvcHQuZGltc0RlZiB8fCBbXSkuc2xpY2UoKTtcbiAgdmFyIGVuY29kZURlZiA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKG9wdC5lbmNvZGVEZWYpO1xuICB2YXIgZGF0YURpbU5hbWVNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICB2YXIgY29vcmREaW1OYW1lTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTsgLy8gdmFyIHZhbHVlQ2FuZGlkYXRlO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGRpbUNvdW50ID0gb3B0LmRpbUNvdW50O1xuXG4gIGlmIChkaW1Db3VudCA9PSBudWxsKSB7XG4gICAgdmFyIHZhbHVlMCA9IHJldHJpZXZlVmFsdWUoZGF0YVswXSk7XG4gICAgZGltQ291bnQgPSBNYXRoLm1heCh6clV0aWwuaXNBcnJheSh2YWx1ZTApICYmIHZhbHVlMC5sZW5ndGggfHwgMSwgc3lzRGltcy5sZW5ndGgsIGRpbXNEZWYubGVuZ3RoKTtcbiAgICBlYWNoKHN5c0RpbXMsIGZ1bmN0aW9uIChzeXNEaW1JdGVtKSB7XG4gICAgICB2YXIgc3lzRGltSXRlbURpbXNEZWYgPSBzeXNEaW1JdGVtLmRpbXNEZWY7XG4gICAgICBzeXNEaW1JdGVtRGltc0RlZiAmJiAoZGltQ291bnQgPSBNYXRoLm1heChkaW1Db3VudCwgc3lzRGltSXRlbURpbXNEZWYubGVuZ3RoKSk7XG4gICAgfSk7XG4gIH0gLy8gQXBwbHkgdXNlciBkZWZpbmVkIGRpbXMgKGBuYW1lYCBhbmQgYHR5cGVgKSBhbmQgaW5pdCByZXN1bHQuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbUNvdW50OyBpKyspIHtcbiAgICB2YXIgZGltRGVmSXRlbSA9IGlzU3RyaW5nKGRpbXNEZWZbaV0pID8ge1xuICAgICAgbmFtZTogZGltc0RlZltpXVxuICAgIH0gOiBkaW1zRGVmW2ldIHx8IHt9O1xuICAgIHZhciB1c2VyRGltTmFtZSA9IGRpbURlZkl0ZW0ubmFtZTtcbiAgICB2YXIgcmVzdWx0SXRlbSA9IHJlc3VsdFtpXSA9IHtcbiAgICAgIG90aGVyRGltczoge31cbiAgICB9OyAvLyBOYW1lIHdpbGwgYmUgYXBwbGllZCBsYXRlciBmb3IgYXZvaWRpbmcgZHVwbGljYXRpb24uXG5cbiAgICBpZiAodXNlckRpbU5hbWUgIT0gbnVsbCAmJiBkYXRhRGltTmFtZU1hcC5nZXQodXNlckRpbU5hbWUpID09IG51bGwpIHtcbiAgICAgIC8vIE9ubHkgaWYgYHNlcmllcy5kaW1lbnNpb25zYCBpcyBkZWZpbmVkIGluIG9wdGlvbiwgdG9vbHRpcE5hbWVcbiAgICAgIC8vIHdpbGwgYmUgc2V0LCBhbmQgZGltZW5zaW9uIHdpbGwgYmUgZGlwbGF5ZWQgdmVydGljYWxseSBpblxuICAgICAgLy8gdG9vbHRpcCBieSBkZWZhdWx0LlxuICAgICAgcmVzdWx0SXRlbS5uYW1lID0gcmVzdWx0SXRlbS50b29sdGlwTmFtZSA9IHVzZXJEaW1OYW1lO1xuICAgICAgZGF0YURpbU5hbWVNYXAuc2V0KHVzZXJEaW1OYW1lLCBpKTtcbiAgICB9XG5cbiAgICBkaW1EZWZJdGVtLnR5cGUgIT0gbnVsbCAmJiAocmVzdWx0SXRlbS50eXBlID0gZGltRGVmSXRlbS50eXBlKTtcbiAgfSAvLyBTZXQgYGNvb3JkRGltYCBhbmQgYGNvb3JkRGltSW5kZXhgIGJ5IGBlbmNvZGVEZWZgIGFuZCBub3JtYWxpemUgYGVuY29kZURlZmAuXG5cblxuICBlbmNvZGVEZWYuZWFjaChmdW5jdGlvbiAoZGF0YURpbXMsIGNvb3JkRGltKSB7XG4gICAgZGF0YURpbXMgPSBlbmNvZGVEZWYuc2V0KGNvb3JkRGltLCBub3JtYWxpemVUb0FycmF5KGRhdGFEaW1zKS5zbGljZSgpKTtcbiAgICBlYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAocmVzdWx0RGltSWR4LCBjb29yZERpbUluZGV4KSB7XG4gICAgICAvLyBUaGUgaW5wdXQgcmVzdWx0RGltSWR4IGNhbiBiZSBkaW0gbmFtZSBvciBpbmRleC5cbiAgICAgIGlzU3RyaW5nKHJlc3VsdERpbUlkeCkgJiYgKHJlc3VsdERpbUlkeCA9IGRhdGFEaW1OYW1lTWFwLmdldChyZXN1bHREaW1JZHgpKTtcblxuICAgICAgaWYgKHJlc3VsdERpbUlkeCAhPSBudWxsICYmIHJlc3VsdERpbUlkeCA8IGRpbUNvdW50KSB7XG4gICAgICAgIGRhdGFEaW1zW2Nvb3JkRGltSW5kZXhdID0gcmVzdWx0RGltSWR4O1xuICAgICAgICBhcHBseURpbShyZXN1bHRbcmVzdWx0RGltSWR4XSwgY29vcmREaW0sIGNvb3JkRGltSW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTsgLy8gQXBwbHkgdGVtcGxldGVzIGFuZCBkZWZhdWx0IG9yZGVyIGZyb20gYHN5c0RpbXNgLlxuXG4gIHZhciBhdmFpbERpbUlkeCA9IDA7XG4gIGVhY2goc3lzRGltcywgZnVuY3Rpb24gKHN5c0RpbUl0ZW0sIHN5c0RpbUluZGV4KSB7XG4gICAgdmFyIGNvb3JkRGltO1xuICAgIHZhciBzeXNEaW1JdGVtO1xuICAgIHZhciBzeXNEaW1JdGVtRGltc0RlZjtcbiAgICB2YXIgc3lzRGltSXRlbU90aGVyRGltcztcblxuICAgIGlmIChpc1N0cmluZyhzeXNEaW1JdGVtKSkge1xuICAgICAgY29vcmREaW0gPSBzeXNEaW1JdGVtO1xuICAgICAgc3lzRGltSXRlbSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZERpbSA9IHN5c0RpbUl0ZW0ubmFtZTtcbiAgICAgIHN5c0RpbUl0ZW0gPSB6clV0aWwuY2xvbmUoc3lzRGltSXRlbSk7IC8vIGBjb29yZERpbUluZGV4YCBzaG91bGQgbm90IGJlIHNldCBkaXJlY3RseS5cblxuICAgICAgc3lzRGltSXRlbURpbXNEZWYgPSBzeXNEaW1JdGVtLmRpbXNEZWY7XG4gICAgICBzeXNEaW1JdGVtT3RoZXJEaW1zID0gc3lzRGltSXRlbS5vdGhlckRpbXM7XG4gICAgICBzeXNEaW1JdGVtLm5hbWUgPSBzeXNEaW1JdGVtLmNvb3JkRGltID0gc3lzRGltSXRlbS5jb29yZERpbUluZGV4ID0gc3lzRGltSXRlbS5kaW1zRGVmID0gc3lzRGltSXRlbS5vdGhlckRpbXMgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBkYXRhRGltcyA9IG5vcm1hbGl6ZVRvQXJyYXkoZW5jb2RlRGVmLmdldChjb29yZERpbSkpOyAvLyBkaW1lbnNpb25zIHByb3ZpZGVzIGRlZmF1bHQgZGltIHNlcXVlbmNlcy5cblxuICAgIGlmICghZGF0YURpbXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChzeXNEaW1JdGVtRGltc0RlZiAmJiBzeXNEaW1JdGVtRGltc0RlZi5sZW5ndGggfHwgMSk7IGkrKykge1xuICAgICAgICB3aGlsZSAoYXZhaWxEaW1JZHggPCByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFthdmFpbERpbUlkeF0uY29vcmREaW0gIT0gbnVsbCkge1xuICAgICAgICAgIGF2YWlsRGltSWR4Kys7XG4gICAgICAgIH1cblxuICAgICAgICBhdmFpbERpbUlkeCA8IHJlc3VsdC5sZW5ndGggJiYgZGF0YURpbXMucHVzaChhdmFpbERpbUlkeCsrKTtcbiAgICAgIH1cbiAgICB9IC8vIEFwcGx5IHRlbXBsYXRlcy5cblxuXG4gICAgZWFjaChkYXRhRGltcywgZnVuY3Rpb24gKHJlc3VsdERpbUlkeCwgY29vcmREaW1JbmRleCkge1xuICAgICAgdmFyIHJlc3VsdEl0ZW0gPSByZXN1bHRbcmVzdWx0RGltSWR4XTtcbiAgICAgIGFwcGx5RGltKGRlZmF1bHRzKHJlc3VsdEl0ZW0sIHN5c0RpbUl0ZW0pLCBjb29yZERpbSwgY29vcmREaW1JbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHRJdGVtLm5hbWUgPT0gbnVsbCAmJiBzeXNEaW1JdGVtRGltc0RlZikge1xuICAgICAgICByZXN1bHRJdGVtLm5hbWUgPSByZXN1bHRJdGVtLnRvb2x0aXBOYW1lID0gc3lzRGltSXRlbURpbXNEZWZbY29vcmREaW1JbmRleF07XG4gICAgICB9XG5cbiAgICAgIHN5c0RpbUl0ZW1PdGhlckRpbXMgJiYgZGVmYXVsdHMocmVzdWx0SXRlbS5vdGhlckRpbXMsIHN5c0RpbUl0ZW1PdGhlckRpbXMpO1xuICAgIH0pO1xuICB9KTsgLy8gTWFrZSBzdXJlIHRoZSBmaXJzdCBleHRyYSBkaW0gaXMgJ3ZhbHVlJy5cblxuICB2YXIgZXh0cmEgPSBvcHQuZXh0cmFQcmVmaXggfHwgJ3ZhbHVlJzsgLy8gU2V0IGRpbSBgbmFtZWAgYW5kIG90aGVyIGBjb29yZERpbWAgYW5kIG90aGVyIHByb3BzLlxuXG4gIGZvciAodmFyIHJlc3VsdERpbUlkeCA9IDA7IHJlc3VsdERpbUlkeCA8IGRpbUNvdW50OyByZXN1bHREaW1JZHgrKykge1xuICAgIHZhciByZXN1bHRJdGVtID0gcmVzdWx0W3Jlc3VsdERpbUlkeF0gPSByZXN1bHRbcmVzdWx0RGltSWR4XSB8fCB7fTtcbiAgICB2YXIgY29vcmREaW0gPSByZXN1bHRJdGVtLmNvb3JkRGltO1xuICAgIGNvb3JkRGltID09IG51bGwgJiYgKHJlc3VsdEl0ZW0uY29vcmREaW0gPSBnZW5OYW1lKGV4dHJhLCBjb29yZERpbU5hbWVNYXAsIG9wdC5leHRyYUZyb21aZXJvKSwgcmVzdWx0SXRlbS5jb29yZERpbUluZGV4ID0gMCwgcmVzdWx0SXRlbS5pc0V4dHJhQ29vcmQgPSB0cnVlKTtcbiAgICByZXN1bHRJdGVtLm5hbWUgPT0gbnVsbCAmJiAocmVzdWx0SXRlbS5uYW1lID0gZ2VuTmFtZShyZXN1bHRJdGVtLmNvb3JkRGltLCBkYXRhRGltTmFtZU1hcCkpO1xuICAgIHJlc3VsdEl0ZW0udHlwZSA9PSBudWxsICYmIGd1ZXNzT3JkaW5hbChkYXRhLCByZXN1bHREaW1JZHgpICYmIChyZXN1bHRJdGVtLnR5cGUgPSAnb3JkaW5hbCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxuICBmdW5jdGlvbiBhcHBseURpbShyZXN1bHRJdGVtLCBjb29yZERpbSwgY29vcmREaW1JbmRleCkge1xuICAgIGlmIChPVEhFUl9ESU1TW2Nvb3JkRGltXSkge1xuICAgICAgcmVzdWx0SXRlbS5vdGhlckRpbXNbY29vcmREaW1dID0gY29vcmREaW1JbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0SXRlbS5jb29yZERpbSA9IGNvb3JkRGltO1xuICAgICAgcmVzdWx0SXRlbS5jb29yZERpbUluZGV4ID0gY29vcmREaW1JbmRleDtcbiAgICAgIGNvb3JkRGltTmFtZU1hcC5zZXQoY29vcmREaW0sIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbk5hbWUobmFtZSwgbWFwLCBmcm9tWmVybykge1xuICAgIGlmIChmcm9tWmVybyB8fCBtYXAuZ2V0KG5hbWUpICE9IG51bGwpIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKG1hcC5nZXQobmFtZSArIGkpICE9IG51bGwpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICBuYW1lICs9IGk7XG4gICAgfVxuXG4gICAgbWFwLnNldChuYW1lLCB0cnVlKTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxufSAvLyBUaGUgcnVsZSBzaG91bGQgbm90IGJlIGNvbXBsZXgsIG90aGVyd2lzZSB1c2VyIG1pZ2h0IG5vdFxuLy8gYmUgYWJsZSB0byBrbm93biB3aGVyZSB0aGUgZGF0YSBpcyB3cm9uZy5cblxuXG52YXIgZ3Vlc3NPcmRpbmFsID0gY29tcGxldGVEaW1lbnNpb25zLmd1ZXNzT3JkaW5hbCA9IGZ1bmN0aW9uIChkYXRhLCBkaW1JbmRleCkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IHJldHJpZXZlVmFsdWUoZGF0YVtpXSk7XG5cbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHZhbHVlW2RpbUluZGV4XTsgLy8gQ29uc2lkZXIgdXNhZ2UgY29udmVuaWVuY2UsICcxJywgJzInIHdpbGwgYmUgdHJlYXRlZCBhcyBcIm51bWJlclwiLlxuICAgIC8vIGBpc0Zpbml0KCcnKWAgZ2V0IGB0cnVlYC5cblxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJy0nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZXRyaWV2ZVZhbHVlKG8pIHtcbiAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KG8pID8gbyA6IHpyVXRpbC5pc09iamVjdChvKSA/IG8udmFsdWUgOiBvO1xufVxuXG52YXIgX2RlZmF1bHQgPSBjb21wbGV0ZURpbWVuc2lvbnM7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9udW1iZXJcIik7XG5cbi8qKlxuICogRm9yIHRlc3RhYmxlLlxuICovXG52YXIgcm91bmROdW1iZXIgPSBudW1iZXJVdGlsLnJvdW5kO1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBleHRlbnQgQm90aCBleHRlbnRbMF0gYW5kIGV4dGVudFsxXSBzaG91bGQgYmUgdmFsaWQgbnVtYmVyLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNob3VsZCBiZSBleHRlbnRbMF0gPCBleHRlbnRbMV0uXG4gKiBAcGFyYW0ge251bWJlcn0gc3BsaXROdW1iZXIgc3BsaXROdW1iZXIgc2hvdWxkIGJlID49IDEuXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbkludGVydmFsXVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhJbnRlcnZhbF1cbiAqIEByZXR1cm4ge09iamVjdH0ge2ludGVydmFsLCBpbnRlcnZhbFByZWNpc2lvbiwgbmljZVRpY2tFeHRlbnR9XG4gKi9cblxuZnVuY3Rpb24gaW50ZXJ2YWxTY2FsZU5pY2VUaWNrcyhleHRlbnQsIHNwbGl0TnVtYmVyLCBtaW5JbnRlcnZhbCwgbWF4SW50ZXJ2YWwpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgdmFyIGludGVydmFsID0gcmVzdWx0LmludGVydmFsID0gbnVtYmVyVXRpbC5uaWNlKHNwYW4gLyBzcGxpdE51bWJlciwgdHJ1ZSk7XG5cbiAgaWYgKG1pbkludGVydmFsICE9IG51bGwgJiYgaW50ZXJ2YWwgPCBtaW5JbnRlcnZhbCkge1xuICAgIGludGVydmFsID0gcmVzdWx0LmludGVydmFsID0gbWluSW50ZXJ2YWw7XG4gIH1cblxuICBpZiAobWF4SW50ZXJ2YWwgIT0gbnVsbCAmJiBpbnRlcnZhbCA+IG1heEludGVydmFsKSB7XG4gICAgaW50ZXJ2YWwgPSByZXN1bHQuaW50ZXJ2YWwgPSBtYXhJbnRlcnZhbDtcbiAgfSAvLyBUb3cgbW9yZSBkaWdpdGFsIGZvciB0aWNrLlxuXG5cbiAgdmFyIHByZWNpc2lvbiA9IHJlc3VsdC5pbnRlcnZhbFByZWNpc2lvbiA9IGdldEludGVydmFsUHJlY2lzaW9uKGludGVydmFsKTsgLy8gTmljZWQgZXh0ZW50IGluc2lkZSBvcmlnaW5hbCBleHRlbnRcblxuICB2YXIgbmljZVRpY2tFeHRlbnQgPSByZXN1bHQubmljZVRpY2tFeHRlbnQgPSBbcm91bmROdW1iZXIoTWF0aC5jZWlsKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsLCBwcmVjaXNpb24pLCByb3VuZE51bWJlcihNYXRoLmZsb29yKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsLCBwcmVjaXNpb24pXTtcbiAgZml4RXh0ZW50KG5pY2VUaWNrRXh0ZW50LCBleHRlbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxcbiAqIEByZXR1cm4ge251bWJlcn0gaW50ZXJ2YWwgcHJlY2lzaW9uXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJbnRlcnZhbFByZWNpc2lvbihpbnRlcnZhbCkge1xuICAvLyBUb3cgbW9yZSBkaWdpdGFsIGZvciB0aWNrLlxuICByZXR1cm4gbnVtYmVyVXRpbC5nZXRQcmVjaXNpb25TYWZlKGludGVydmFsKSArIDI7XG59XG5cbmZ1bmN0aW9uIGNsYW1wKG5pY2VUaWNrRXh0ZW50LCBpZHgsIGV4dGVudCkge1xuICBuaWNlVGlja0V4dGVudFtpZHhdID0gTWF0aC5tYXgoTWF0aC5taW4obmljZVRpY2tFeHRlbnRbaWR4XSwgZXh0ZW50WzFdKSwgZXh0ZW50WzBdKTtcbn0gLy8gSW4gc29tZSBjYXNlcyAoZS5nLiwgc3BsaXROdW1iZXIgaXMgMSksIG5pY2VUaWNrRXh0ZW50IG1heSBiZSBvdXQgb2YgZXh0ZW50LlxuXG5cbmZ1bmN0aW9uIGZpeEV4dGVudChuaWNlVGlja0V4dGVudCwgZXh0ZW50KSB7XG4gICFpc0Zpbml0ZShuaWNlVGlja0V4dGVudFswXSkgJiYgKG5pY2VUaWNrRXh0ZW50WzBdID0gZXh0ZW50WzBdKTtcbiAgIWlzRmluaXRlKG5pY2VUaWNrRXh0ZW50WzFdKSAmJiAobmljZVRpY2tFeHRlbnRbMV0gPSBleHRlbnRbMV0pO1xuICBjbGFtcChuaWNlVGlja0V4dGVudCwgMCwgZXh0ZW50KTtcbiAgY2xhbXAobmljZVRpY2tFeHRlbnQsIDEsIGV4dGVudCk7XG5cbiAgaWYgKG5pY2VUaWNrRXh0ZW50WzBdID4gbmljZVRpY2tFeHRlbnRbMV0pIHtcbiAgICBuaWNlVGlja0V4dGVudFswXSA9IG5pY2VUaWNrRXh0ZW50WzFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVydmFsU2NhbGVHZXRUaWNrcyhpbnRlcnZhbCwgZXh0ZW50LCBuaWNlVGlja0V4dGVudCwgaW50ZXJ2YWxQcmVjaXNpb24pIHtcbiAgdmFyIHRpY2tzID0gW107IC8vIElmIGludGVydmFsIGlzIDAsIHJldHVybiBbXTtcblxuICBpZiAoIWludGVydmFsKSB7XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9IC8vIENvbnNpZGVyIHRoaXMgY2FzZTogdXNpbmcgZGF0YVpvb20gdG9vbGJveCwgem9vbSBhbmQgem9vbS5cblxuXG4gIHZhciBzYWZlTGltaXQgPSAxMDAwMDtcblxuICBpZiAoZXh0ZW50WzBdIDwgbmljZVRpY2tFeHRlbnRbMF0pIHtcbiAgICB0aWNrcy5wdXNoKGV4dGVudFswXSk7XG4gIH1cblxuICB2YXIgdGljayA9IG5pY2VUaWNrRXh0ZW50WzBdO1xuXG4gIHdoaWxlICh0aWNrIDw9IG5pY2VUaWNrRXh0ZW50WzFdKSB7XG4gICAgdGlja3MucHVzaCh0aWNrKTsgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3JcblxuICAgIHRpY2sgPSByb3VuZE51bWJlcih0aWNrICsgaW50ZXJ2YWwsIGludGVydmFsUHJlY2lzaW9uKTtcblxuICAgIGlmICh0aWNrID09PSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSkge1xuICAgICAgLy8gQ29uc2lkZXIgb3V0IG9mIHNhZmUgZmxvYXQgcG9pbnQsIGUuZy4sXG4gICAgICAvLyAtMzcxMTEyNi45OTA3NzA3ICsgMmUtMTAgPT09IC0zNzExMTI2Ljk5MDc3MDdcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aWNrcy5sZW5ndGggPiBzYWZlTGltaXQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0gLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiB0aGUgbGFzdCBpdGVtIG9mIHRpY2tzIGlzIHNtYWxsZXJcbiAgLy8gdGhhbiBuaWNlVGlja0V4dGVudFsxXSBhbmQgbmljZVRpY2tFeHRlbnRbMV0gPT09IGV4dGVudFsxXS5cblxuXG4gIGlmIChleHRlbnRbMV0gPiAodGlja3MubGVuZ3RoID8gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0gOiBuaWNlVGlja0V4dGVudFsxXSkpIHtcbiAgICB0aWNrcy5wdXNoKGV4dGVudFsxXSk7XG4gIH1cblxuICByZXR1cm4gdGlja3M7XG59XG5cbmV4cG9ydHMuaW50ZXJ2YWxTY2FsZU5pY2VUaWNrcyA9IGludGVydmFsU2NhbGVOaWNlVGlja3M7XG5leHBvcnRzLmdldEludGVydmFsUHJlY2lzaW9uID0gZ2V0SW50ZXJ2YWxQcmVjaXNpb247XG5leHBvcnRzLmZpeEV4dGVudCA9IGZpeEV4dGVudDtcbmV4cG9ydHMuaW50ZXJ2YWxTY2FsZUdldFRpY2tzID0gaW50ZXJ2YWxTY2FsZUdldFRpY2tzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBheGlzSGVscGVyID0gcmVxdWlyZShcIi4vYXhpc0hlbHBlclwiKTtcblxuZnVuY3Rpb24gZ2V0TmFtZShvYmopIHtcbiAgaWYgKHpyVXRpbC5pc09iamVjdChvYmopICYmIG9iai52YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG9iai52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqICsgJyc7XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0ge1xuICAvKipcbiAgICogRm9ybWF0IGxhYmVsc1xuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICovXG4gIGdldEZvcm1hdHRlZExhYmVsczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBheGlzSGVscGVyLmdldEZvcm1hdHRlZExhYmVscyh0aGlzLmF4aXMsIHRoaXMuZ2V0KCdheGlzTGFiZWwuZm9ybWF0dGVyJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY2F0ZWdvcmllc1xuICAgKi9cbiAgZ2V0Q2F0ZWdvcmllczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknICYmIHpyVXRpbC5tYXAodGhpcy5nZXQoJ2RhdGEnKSwgZ2V0TmFtZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3JpZ2luXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9IG1pbiB2YWx1ZSBvciAnZGF0YU1pbicgb3IgbnVsbC91bmRlZmluZWQgKG1lYW5zIGF1dG8pIG9yIE5hTlxuICAgKi9cbiAgZ2V0TWluOiBmdW5jdGlvbiAob3JpZ2luKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBtaW4gPSAhb3JpZ2luICYmIG9wdGlvbi5yYW5nZVN0YXJ0ICE9IG51bGwgPyBvcHRpb24ucmFuZ2VTdGFydCA6IG9wdGlvbi5taW47XG5cbiAgICBpZiAodGhpcy5heGlzICYmIG1pbiAhPSBudWxsICYmIG1pbiAhPT0gJ2RhdGFNaW4nICYmIHR5cGVvZiBtaW4gIT09ICdmdW5jdGlvbicgJiYgIXpyVXRpbC5lcU5hTihtaW4pKSB7XG4gICAgICBtaW4gPSB0aGlzLmF4aXMuc2NhbGUucGFyc2UobWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9yaWdpblxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfSBtYXggdmFsdWUgb3IgJ2RhdGFNYXgnIG9yIG51bGwvdW5kZWZpbmVkIChtZWFucyBhdXRvKSBvciBOYU5cbiAgICovXG4gIGdldE1heDogZnVuY3Rpb24gKG9yaWdpbikge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgbWF4ID0gIW9yaWdpbiAmJiBvcHRpb24ucmFuZ2VFbmQgIT0gbnVsbCA/IG9wdGlvbi5yYW5nZUVuZCA6IG9wdGlvbi5tYXg7XG5cbiAgICBpZiAodGhpcy5heGlzICYmIG1heCAhPSBudWxsICYmIG1heCAhPT0gJ2RhdGFNYXgnICYmIHR5cGVvZiBtYXggIT09ICdmdW5jdGlvbicgJiYgIXpyVXRpbC5lcU5hTihtYXgpKSB7XG4gICAgICBtYXggPSB0aGlzLmF4aXMuc2NhbGUucGFyc2UobWF4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZ2V0TmVlZENyb3NzWmVybzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICByZXR1cm4gb3B0aW9uLnJhbmdlU3RhcnQgIT0gbnVsbCB8fCBvcHRpb24ucmFuZ2VFbmQgIT0gbnVsbCA/IGZhbHNlIDogIW9wdGlvbi5zY2FsZTtcbiAgfSxcblxuICAvKipcbiAgICogU2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggYXhpcyBtb2RlbCBpZiBuZWNlc3NhcnkuXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29vcmRpbmF0ZSBzeXN0ZW0gbW9kZWxcbiAgICovXG4gIGdldENvb3JkU3lzTW9kZWw6IHpyVXRpbC5ub29wLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFuZ2VTdGFydCBDYW4gb25seSBiZSBmaW5pdGUgbnVtYmVyIG9yIG51bGwvdW5kZWZpbmVkIG9yIE5hTi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlRW5kIENhbiBvbmx5IGJlIGZpbml0ZSBudW1iZXIgb3IgbnVsbC91bmRlZmluZWQgb3IgTmFOLlxuICAgKi9cbiAgc2V0UmFuZ2U6IGZ1bmN0aW9uIChyYW5nZVN0YXJ0LCByYW5nZUVuZCkge1xuICAgIHRoaXMub3B0aW9uLnJhbmdlU3RhcnQgPSByYW5nZVN0YXJ0O1xuICAgIHRoaXMub3B0aW9uLnJhbmdlRW5kID0gcmFuZ2VFbmQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0IHJhbmdlXG4gICAqL1xuICByZXNldFJhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmFuZ2VTdGFydCBhbmQgcmFuZ2VFbmQgaXMgcmVhZG9ubHkuXG4gICAgdGhpcy5vcHRpb24ucmFuZ2VTdGFydCA9IHRoaXMub3B0aW9uLnJhbmdlRW5kID0gbnVsbDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL251bWJlclwiKTtcblxudmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKFwiLi9heGlzSGVscGVyXCIpO1xuXG52YXIgbGluZWFyTWFwID0gbnVtYmVyVXRpbC5saW5lYXJNYXA7XG5cbmZ1bmN0aW9uIGZpeEV4dGVudFdpdGhCYW5kcyhleHRlbnQsIG5UaWNrKSB7XG4gIHZhciBzaXplID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICB2YXIgbGVuID0gblRpY2s7XG4gIHZhciBtYXJnaW4gPSBzaXplIC8gbGVuIC8gMjtcbiAgZXh0ZW50WzBdICs9IG1hcmdpbjtcbiAgZXh0ZW50WzFdIC09IG1hcmdpbjtcbn1cblxudmFyIG5vcm1hbGl6ZWRFeHRlbnQgPSBbMCwgMV07XG4vKipcbiAqIEBuYW1lIG1vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbkF4aXNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBBeGlzID0gZnVuY3Rpb24gKGRpbSwgc2NhbGUsIGV4dGVudCkge1xuICAvKipcbiAgICogQXhpcyBkaW1lbnNpb24uIFN1Y2ggYXMgJ3gnLCAneScsICd6JywgJ2FuZ2xlJywgJ3JhZGl1cydcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuZGltID0gZGltO1xuICAvKipcbiAgICogQXhpcyBzY2FsZVxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29vcmQvc2NhbGUvKn1cbiAgICovXG5cbiAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9leHRlbnQgPSBleHRlbnQgfHwgWzAsIDBdO1xuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMuaW52ZXJzZSA9IGZhbHNlO1xuICAvKipcbiAgICogVXN1YWxseSB0cnVlIHdoZW4gYXhpcyBoYXMgYSBvcmRpbmFsIHNjYWxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuICB0aGlzLm9uQmFuZCA9IGZhbHNlO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fbGFiZWxJbnRlcnZhbDtcbn07XG5cbkF4aXMucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQXhpcyxcblxuICAvKipcbiAgICogSWYgYXhpcyBleHRlbnQgY29udGFpbiBnaXZlbiBjb29yZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY29vcmRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW46IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgoZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICAgIHJldHVybiBjb29yZCA+PSBtaW4gJiYgY29vcmQgPD0gbWF4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBheGlzIGV4dGVudCBjb250YWluIGdpdmVuIGRhdGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5EYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW4odGhpcy5kYXRhVG9Db29yZChkYXRhKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjb29yZCBleHRlbnQuXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZ2V0RXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dGVudC5zbGljZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcHJlY2lzaW9uIHVzZWQgZm9yIGZvcm1hdHRpbmdcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW2RhdGFFeHRlbnRdXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFBpeGVsUHJlY2lzaW9uOiBmdW5jdGlvbiAoZGF0YUV4dGVudCkge1xuICAgIHJldHVybiBudW1iZXJVdGlsLmdldFBpeGVsUHJlY2lzaW9uKGRhdGFFeHRlbnQgfHwgdGhpcy5zY2FsZS5nZXRFeHRlbnQoKSwgdGhpcy5fZXh0ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGNvb3JkIGV4dGVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgKi9cbiAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgZXh0ZW50WzBdID0gc3RhcnQ7XG4gICAgZXh0ZW50WzFdID0gZW5kO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGRhdGEgdG8gY29vcmQuIERhdGEgaXMgdGhlIHJhbmsgaWYgaXQgaGFzIGEgb3JkaW5hbCBzY2FsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkYXRhVG9Db29yZDogZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIGRhdGEgPSBzY2FsZS5ub3JtYWxpemUoZGF0YSk7XG5cbiAgICBpZiAodGhpcy5vbkJhbmQgJiYgc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICBleHRlbnQgPSBleHRlbnQuc2xpY2UoKTtcbiAgICAgIGZpeEV4dGVudFdpdGhCYW5kcyhleHRlbnQsIHNjYWxlLmNvdW50KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lYXJNYXAoZGF0YSwgbm9ybWFsaXplZEV4dGVudCwgZXh0ZW50LCBjbGFtcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgY29vcmQgdG8gZGF0YS4gRGF0YSBpcyB0aGUgcmFuayBpZiBpdCBoYXMgYSBvcmRpbmFsIHNjYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb29yZFxuICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb29yZFRvRGF0YTogZnVuY3Rpb24gKGNvb3JkLCBjbGFtcCkge1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblxuICAgIGlmICh0aGlzLm9uQmFuZCAmJiBzY2FsZS50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgIGV4dGVudCA9IGV4dGVudC5zbGljZSgpO1xuICAgICAgZml4RXh0ZW50V2l0aEJhbmRzKGV4dGVudCwgc2NhbGUuY291bnQoKSk7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBsaW5lYXJNYXAoY29vcmQsIGV4dGVudCwgbm9ybWFsaXplZEV4dGVudCwgY2xhbXApO1xuICAgIHJldHVybiB0aGlzLnNjYWxlLnNjYWxlKHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHBpeGVsIHBvaW50IHRvIGRhdGEgaW4gYXhpc1xuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGRhdGFcbiAgICovXG4gIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7Ly8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGRlcml2ZWQgY2xhc3MgaWYgbmVjZXNzYXJ5LlxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGdldFRpY2tzQ29vcmRzOiBmdW5jdGlvbiAoYWxpZ25XaXRoTGFiZWwpIHtcbiAgICBpZiAodGhpcy5vbkJhbmQgJiYgIWFsaWduV2l0aExhYmVsKSB7XG4gICAgICB2YXIgYmFuZHMgPSB0aGlzLmdldEJhbmRzKCk7XG4gICAgICB2YXIgY29vcmRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29vcmRzLnB1c2goYmFuZHNbaV1bMF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmFuZHNbaSAtIDFdKSB7XG4gICAgICAgIGNvb3Jkcy5wdXNoKGJhbmRzW2kgLSAxXVsxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB6clV0aWwubWFwKHRoaXMuc2NhbGUuZ2V0VGlja3MoKSwgdGhpcy5kYXRhVG9Db29yZCwgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb29yZHMgb2YgbGFiZWxzIGFyZSBvbiB0aGUgdGlja3Mgb3Igb24gdGhlIG1pZGRsZSBvZiBiYW5kc1xuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGdldExhYmVsc0Nvb3JkczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB6clV0aWwubWFwKHRoaXMuc2NhbGUuZ2V0VGlja3MoKSwgdGhpcy5kYXRhVG9Db29yZCwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBiYW5kcy5cbiAgICpcbiAgICogSWYgYXhpcyBoYXMgbGFiZWxzIFsxLCAyLCAzLCA0XS4gQmFuZHMgb24gdGhlIGF4aXMgYXJlXG4gICAqIHwtLS0xLS0tfC0tLTItLS18LS0tMy0tLXwtLS00LS0tfC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICAvLyBGSVhNRSBTaXR1YXRpb24gd2hlbiBsYWJlbHMgaXMgb24gdGlja3NcbiAgZ2V0QmFuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgYmFuZHMgPSBbXTtcbiAgICB2YXIgbGVuID0gdGhpcy5zY2FsZS5jb3VudCgpO1xuICAgIHZhciBzdGFydCA9IGV4dGVudFswXTtcbiAgICB2YXIgZW5kID0gZXh0ZW50WzFdO1xuICAgIHZhciBzcGFuID0gZW5kIC0gc3RhcnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBiYW5kcy5wdXNoKFtzcGFuICogaSAvIGxlbiArIHN0YXJ0LCBzcGFuICogKGkgKyAxKSAvIGxlbiArIHN0YXJ0XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhbmRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgd2lkdGggb2YgYmFuZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRCYW5kV2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGxlbiA9IGRhdGFFeHRlbnRbMV0gLSBkYXRhRXh0ZW50WzBdICsgKHRoaXMub25CYW5kID8gMSA6IDApOyAvLyBGaXggIzI3MjgsIGF2b2lkIE5hTiB3aGVuIG9ubHkgb25lIGRhdGEuXG5cbiAgICBsZW4gPT09IDAgJiYgKGxlbiA9IDEpO1xuICAgIHZhciBzaXplID0gTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pO1xuICAgIHJldHVybiBNYXRoLmFicyhzaXplKSAvIGxlbjtcbiAgfSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGhvcml6b250YWxcbiAgICovXG4gIGlzSG9yaXpvbnRhbDogbnVsbCxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge251bWJlcn0gR2V0IGF4aXMgcm90YXRlLCBieSBkZWdyZWUuXG4gICAqL1xuICBnZXRSb3RhdGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEdldCBpbnRlcnZhbCBvZiB0aGUgYXhpcyBsYWJlbC5cbiAgICogVG8gZ2V0IHByZWNpc2UgcmVzdWx0LCBhdCBsZWFzdCBvbmUgb2YgYGdldFJvdGF0ZWAgYW5kIGBpc0hvcml6b250YWxgXG4gICAqIHNob3VsZCBiZSBpbXBsZW1lbnRlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGFiZWxJbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYWJlbEludGVydmFsID0gdGhpcy5fbGFiZWxJbnRlcnZhbDtcblxuICAgIGlmICghbGFiZWxJbnRlcnZhbCkge1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgbGFiZWxNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJyk7XG4gICAgICBsYWJlbEludGVydmFsID0gbGFiZWxNb2RlbC5nZXQoJ2ludGVydmFsJyk7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgKGxhYmVsSW50ZXJ2YWwgPT0gbnVsbCB8fCBsYWJlbEludGVydmFsID09PSAnYXV0bycpKSB7XG4gICAgICAgIGxhYmVsSW50ZXJ2YWwgPSBheGlzSGVscGVyLmdldEF4aXNMYWJlbEludGVydmFsKHpyVXRpbC5tYXAodGhpcy5zY2FsZS5nZXRUaWNrcygpLCB0aGlzLmRhdGFUb0Nvb3JkLCB0aGlzKSwgYXhpc01vZGVsLmdldEZvcm1hdHRlZExhYmVscygpLCBsYWJlbE1vZGVsLmdldEZvbnQoKSwgdGhpcy5nZXRSb3RhdGUgPyB0aGlzLmdldFJvdGF0ZSgpIDogdGhpcy5pc0hvcml6b250YWwgJiYgIXRoaXMuaXNIb3Jpem9udGFsKCkgPyA5MCA6IDAsIGxhYmVsTW9kZWwuZ2V0KCdyb3RhdGUnKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhYmVsSW50ZXJ2YWwgPSBsYWJlbEludGVydmFsO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbEludGVydmFsO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQXhpcztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvQXhpcy5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBfbGF5b3V0ID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgZ2V0TGF5b3V0UmVjdCA9IF9sYXlvdXQuZ2V0TGF5b3V0UmVjdDtcblxudmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKFwiLi4vLi4vY29vcmQvYXhpc0hlbHBlclwiKTtcblxudmFyIENhcnRlc2lhbjJEID0gcmVxdWlyZShcIi4vQ2FydGVzaWFuMkRcIik7XG5cbnZhciBBeGlzMkQgPSByZXF1aXJlKFwiLi9BeGlzMkRcIik7XG5cbnZhciBDb29yZGluYXRlU3lzdGVtID0gcmVxdWlyZShcIi4uLy4uL0Nvb3JkaW5hdGVTeXN0ZW1cIik7XG5cbnJlcXVpcmUoXCIuL0dyaWRNb2RlbFwiKTtcblxuLyoqXG4gKiBHcmlkIGlzIGEgcmVnaW9uIHdoaWNoIGNvbnRhaW5zIGF0IG1vc3QgNCBjYXJ0ZXNpYW4gc3lzdGVtc1xuICpcbiAqIFRPRE8gRGVmYXVsdCBjYXJ0ZXNpYW5cbiAqL1xuLy8gRGVwZW5kcyBvbiBHcmlkTW9kZWwsIEF4aXNNb2RlbCwgd2hpY2ggcGVyZm9ybXMgcHJlcHJvY2Vzcy5cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgaWZBeGlzQ3Jvc3NaZXJvID0gYXhpc0hlbHBlci5pZkF4aXNDcm9zc1plcm87XG52YXIgbmljZVNjYWxlRXh0ZW50ID0gYXhpc0hlbHBlci5uaWNlU2NhbGVFeHRlbnQ7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBheGlzIGlzIHVzZWQgaW4gdGhlIHNwZWNpZmllZCBncmlkXG4gKiBAaW5uZXJcbiAqL1xuXG5mdW5jdGlvbiBpc0F4aXNVc2VkSW5UaGVHcmlkKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKSB7XG4gIHJldHVybiBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpID09PSBncmlkTW9kZWw7XG59XG5cbmZ1bmN0aW9uIHJvdGF0ZVRleHRSZWN0KHRleHRSZWN0LCByb3RhdGUpIHtcbiAgdmFyIHJvdGF0ZVJhZGlhbnMgPSByb3RhdGUgKiBNYXRoLlBJIC8gMTgwO1xuICB2YXIgYm91bmRpbmdCb3ggPSB0ZXh0UmVjdC5wbGFpbigpO1xuICB2YXIgYmVmb3JlV2lkdGggPSBib3VuZGluZ0JveC53aWR0aDtcbiAgdmFyIGJlZm9yZUhlaWdodCA9IGJvdW5kaW5nQm94LmhlaWdodDtcbiAgdmFyIGFmdGVyV2lkdGggPSBiZWZvcmVXaWR0aCAqIE1hdGguY29zKHJvdGF0ZVJhZGlhbnMpICsgYmVmb3JlSGVpZ2h0ICogTWF0aC5zaW4ocm90YXRlUmFkaWFucyk7XG4gIHZhciBhZnRlckhlaWdodCA9IGJlZm9yZVdpZHRoICogTWF0aC5zaW4ocm90YXRlUmFkaWFucykgKyBiZWZvcmVIZWlnaHQgKiBNYXRoLmNvcyhyb3RhdGVSYWRpYW5zKTtcbiAgdmFyIHJvdGF0ZWRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChib3VuZGluZ0JveC54LCBib3VuZGluZ0JveC55LCBhZnRlcldpZHRoLCBhZnRlckhlaWdodCk7XG4gIHJldHVybiByb3RhdGVkUmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWxVbmlvblJlY3QoYXhpcykge1xuICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgdmFyIGxhYmVscyA9IGF4aXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbHMoKTtcbiAgdmFyIGF4aXNMYWJlbE1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcbiAgdmFyIHJlY3Q7XG4gIHZhciBzdGVwID0gMTtcbiAgdmFyIGxhYmVsQ291bnQgPSBsYWJlbHMubGVuZ3RoO1xuXG4gIGlmIChsYWJlbENvdW50ID4gNDApIHtcbiAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uIGZvciBsYXJnZSBhbW91bnQgb2YgbGFiZWxzXG4gICAgc3RlcCA9IE1hdGguY2VpbChsYWJlbENvdW50IC8gNDApO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpICs9IHN0ZXApIHtcbiAgICBpZiAoIWF4aXMuaXNMYWJlbElnbm9yZWQoaSkpIHtcbiAgICAgIHZhciB1bnJvdGF0ZWRTaW5nbGVSZWN0ID0gYXhpc0xhYmVsTW9kZWwuZ2V0VGV4dFJlY3QobGFiZWxzW2ldKTtcbiAgICAgIHZhciBzaW5nbGVSZWN0ID0gcm90YXRlVGV4dFJlY3QodW5yb3RhdGVkU2luZ2xlUmVjdCwgYXhpc0xhYmVsTW9kZWwuZ2V0KCdyb3RhdGUnKSB8fCAwKTtcbiAgICAgIHJlY3QgPyByZWN0LnVuaW9uKHNpbmdsZVJlY3QpIDogcmVjdCA9IHNpbmdsZVJlY3Q7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIEdyaWQoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbjJEPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuX2Nvb3Jkc01hcCA9IHt9O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuPn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY29vcmRzTGlzdCA9IFtdO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEPn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fYXhlc01hcCA9IHt9O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEPn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcblxuICB0aGlzLl9pbml0Q2FydGVzaWFuKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKTtcblxuICB0aGlzLm1vZGVsID0gZ3JpZE1vZGVsO1xufVxuXG52YXIgZ3JpZFByb3RvID0gR3JpZC5wcm90b3R5cGU7XG5ncmlkUHJvdG8udHlwZSA9ICdncmlkJztcbmdyaWRQcm90by5heGlzUG9pbnRlckVuYWJsZWQgPSB0cnVlO1xuXG5ncmlkUHJvdG8uZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlY3Q7XG59O1xuXG5ncmlkUHJvdG8udXBkYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICB2YXIgYXhlc01hcCA9IHRoaXMuX2F4ZXNNYXA7XG5cbiAgdGhpcy5fdXBkYXRlU2NhbGUoZWNNb2RlbCwgdGhpcy5tb2RlbCk7XG5cbiAgZWFjaChheGVzTWFwLngsIGZ1bmN0aW9uICh4QXhpcykge1xuICAgIG5pY2VTY2FsZUV4dGVudCh4QXhpcy5zY2FsZSwgeEF4aXMubW9kZWwpO1xuICB9KTtcbiAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcykge1xuICAgIG5pY2VTY2FsZUV4dGVudCh5QXhpcy5zY2FsZSwgeUF4aXMubW9kZWwpO1xuICB9KTtcbiAgZWFjaChheGVzTWFwLngsIGZ1bmN0aW9uICh4QXhpcykge1xuICAgIGZpeEF4aXNPblplcm8oYXhlc01hcCwgJ3knLCB4QXhpcyk7XG4gIH0pO1xuICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzKSB7XG4gICAgZml4QXhpc09uWmVybyhheGVzTWFwLCAneCcsIHlBeGlzKTtcbiAgfSk7IC8vIFJlc2l6ZSBhZ2FpbiBpZiBjb250YWluTGFiZWwgaXMgZW5hYmxlZFxuICAvLyBGSVhNRSBJdCBtYXkgY2F1c2UgZ2V0dGluZyB3cm9uZyBncmlkIHNpemUgaW4gZGF0YSBwcm9jZXNzaW5nIHN0YWdlXG5cbiAgdGhpcy5yZXNpemUodGhpcy5tb2RlbCwgYXBpKTtcbn07XG5cbmZ1bmN0aW9uIGZpeEF4aXNPblplcm8oYXhlc01hcCwgb3RoZXJBeGlzRGltLCBheGlzKSB7XG4gIC8vIG9uWmVybyBjYW4gbm90IGJlIGVuYWJsZWQgaW4gdGhlc2UgdHdvIHNpdHVhdGlvbnM6XG4gIC8vIDEuIFdoZW4gYW55IG90aGVyIGF4aXMgaXMgYSBjYXRlZ29yeSBheGlzLlxuICAvLyAyLiBXaGVuIG5vIGF4aXMgaXMgY3Jvc3MgMCBwb2ludC5cbiAgdmFyIGF4ZXMgPSBheGVzTWFwW290aGVyQXhpc0RpbV07XG5cbiAgaWYgKCFheGlzLm9uWmVybykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvblplcm9BeGlzSW5kZXggPSBheGlzLm9uWmVyb0F4aXNJbmRleDsgLy8gSWYgdGFyZ2V0IGF4aXMgaXMgc3BlY2lmaWVkLlxuXG4gIGlmIChvblplcm9BeGlzSW5kZXggIT0gbnVsbCkge1xuICAgIHZhciBvdGhlckF4aXMgPSBheGVzW29uWmVyb0F4aXNJbmRleF07XG5cbiAgICBpZiAob3RoZXJBeGlzICYmIGNhbk5vdE9uWmVyb1RvQXhpcyhvdGhlckF4aXMpKSB7XG4gICAgICBheGlzLm9uWmVybyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGlkeCBpbiBheGVzKSB7XG4gICAgaWYgKGF4ZXMuaGFzT3duUHJvcGVydHkoaWR4KSkge1xuICAgICAgdmFyIG90aGVyQXhpcyA9IGF4ZXNbaWR4XTtcblxuICAgICAgaWYgKG90aGVyQXhpcyAmJiAhY2FuTm90T25aZXJvVG9BeGlzKG90aGVyQXhpcykpIHtcbiAgICAgICAgb25aZXJvQXhpc0luZGV4ID0gK2lkeDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG9uWmVyb0F4aXNJbmRleCA9PSBudWxsKSB7XG4gICAgYXhpcy5vblplcm8gPSBmYWxzZTtcbiAgfVxuXG4gIGF4aXMub25aZXJvQXhpc0luZGV4ID0gb25aZXJvQXhpc0luZGV4O1xufVxuXG5mdW5jdGlvbiBjYW5Ob3RPblplcm9Ub0F4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknIHx8IGF4aXMudHlwZSA9PT0gJ3RpbWUnIHx8ICFpZkF4aXNDcm9zc1plcm8oYXhpcyk7XG59XG4vKipcbiAqIFJlc2l6ZSB0aGUgZ3JpZFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsfSBncmlkTW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqL1xuXG5cbmdyaWRQcm90by5yZXNpemUgPSBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBhcGksIGlnbm9yZUNvbnRhaW5MYWJlbCkge1xuICB2YXIgZ3JpZFJlY3QgPSBnZXRMYXlvdXRSZWN0KGdyaWRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICB9KTtcbiAgdGhpcy5fcmVjdCA9IGdyaWRSZWN0O1xuICB2YXIgYXhlc0xpc3QgPSB0aGlzLl9heGVzTGlzdDtcbiAgYWRqdXN0QXhlcygpOyAvLyBNaW51cyBsYWJlbCBzaXplXG5cbiAgaWYgKCFpZ25vcmVDb250YWluTGFiZWwgJiYgZ3JpZE1vZGVsLmdldCgnY29udGFpbkxhYmVsJykpIHtcbiAgICBlYWNoKGF4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgaWYgKCFheGlzLm1vZGVsLmdldCgnYXhpc0xhYmVsLmluc2lkZScpKSB7XG4gICAgICAgIHZhciBsYWJlbFVuaW9uUmVjdCA9IGdldExhYmVsVW5pb25SZWN0KGF4aXMpO1xuXG4gICAgICAgIGlmIChsYWJlbFVuaW9uUmVjdCkge1xuICAgICAgICAgIHZhciBkaW0gPSBheGlzLmlzSG9yaXpvbnRhbCgpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICAgIHZhciBtYXJnaW4gPSBheGlzLm1vZGVsLmdldCgnYXhpc0xhYmVsLm1hcmdpbicpO1xuICAgICAgICAgIGdyaWRSZWN0W2RpbV0gLT0gbGFiZWxVbmlvblJlY3RbZGltXSArIG1hcmdpbjtcblxuICAgICAgICAgIGlmIChheGlzLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgZ3JpZFJlY3QueSArPSBsYWJlbFVuaW9uUmVjdC5oZWlnaHQgKyBtYXJnaW47XG4gICAgICAgICAgfSBlbHNlIGlmIChheGlzLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGdyaWRSZWN0LnggKz0gbGFiZWxVbmlvblJlY3Qud2lkdGggKyBtYXJnaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgYWRqdXN0QXhlcygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRqdXN0QXhlcygpIHtcbiAgICBlYWNoKGF4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICB2YXIgZXh0ZW50ID0gaXNIb3Jpem9udGFsID8gWzAsIGdyaWRSZWN0LndpZHRoXSA6IFswLCBncmlkUmVjdC5oZWlnaHRdO1xuICAgICAgdmFyIGlkeCA9IGF4aXMuaW52ZXJzZSA/IDEgOiAwO1xuICAgICAgYXhpcy5zZXRFeHRlbnQoZXh0ZW50W2lkeF0sIGV4dGVudFsxIC0gaWR4XSk7XG4gICAgICB1cGRhdGVBeGlzVHJhbnNmcm9tKGF4aXMsIGlzSG9yaXpvbnRhbCA/IGdyaWRSZWN0LnggOiBncmlkUmVjdC55KTtcbiAgICB9KTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXNUeXBlXG4gKiBAcGFyYW0ge251bWJlcn0gW2F4aXNJbmRleF1cbiAqL1xuXG5cbmdyaWRQcm90by5nZXRBeGlzID0gZnVuY3Rpb24gKGF4aXNUeXBlLCBheGlzSW5kZXgpIHtcbiAgdmFyIGF4ZXNNYXBPbkRpbSA9IHRoaXMuX2F4ZXNNYXBbYXhpc1R5cGVdO1xuXG4gIGlmIChheGVzTWFwT25EaW0gIT0gbnVsbCkge1xuICAgIGlmIChheGlzSW5kZXggPT0gbnVsbCkge1xuICAgICAgLy8gRmluZCBmaXJzdCBheGlzXG4gICAgICBmb3IgKHZhciBuYW1lIGluIGF4ZXNNYXBPbkRpbSkge1xuICAgICAgICBpZiAoYXhlc01hcE9uRGltLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGF4ZXNNYXBPbkRpbVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBheGVzTWFwT25EaW1bYXhpc0luZGV4XTtcbiAgfVxufTtcbi8qKlxuICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL0F4aXM+fVxuICovXG5cblxuZ3JpZFByb3RvLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9heGVzTGlzdC5zbGljZSgpO1xufTtcbi8qKlxuICogVXNhZ2U6XG4gKiAgICAgIGdyaWQuZ2V0Q2FydGVzaWFuKHhBeGlzSW5kZXgsIHlBeGlzSW5kZXgpO1xuICogICAgICBncmlkLmdldENhcnRlc2lhbih4QXhpc0luZGV4KTtcbiAqICAgICAgZ3JpZC5nZXRDYXJ0ZXNpYW4obnVsbCwgeUF4aXNJbmRleCk7XG4gKiAgICAgIGdyaWQuZ2V0Q2FydGVzaWFuKHt4QXhpc0luZGV4OiAuLi4sIHlBeGlzSW5kZXg6IC4uLn0pO1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gW3hBeGlzSW5kZXhdXG4gKiBAcGFyYW0ge251bWJlcn0gW3lBeGlzSW5kZXhdXG4gKi9cblxuXG5ncmlkUHJvdG8uZ2V0Q2FydGVzaWFuID0gZnVuY3Rpb24gKHhBeGlzSW5kZXgsIHlBeGlzSW5kZXgpIHtcbiAgaWYgKHhBeGlzSW5kZXggIT0gbnVsbCAmJiB5QXhpc0luZGV4ICE9IG51bGwpIHtcbiAgICB2YXIga2V5ID0gJ3gnICsgeEF4aXNJbmRleCArICd5JyArIHlBeGlzSW5kZXg7XG4gICAgcmV0dXJuIHRoaXMuX2Nvb3Jkc01hcFtrZXldO1xuICB9XG5cbiAgaWYgKHpyVXRpbC5pc09iamVjdCh4QXhpc0luZGV4KSkge1xuICAgIHlBeGlzSW5kZXggPSB4QXhpc0luZGV4LnlBeGlzSW5kZXg7XG4gICAgeEF4aXNJbmRleCA9IHhBeGlzSW5kZXgueEF4aXNJbmRleDtcbiAgfSAvLyBXaGVuIG9ubHkgeEF4aXNJbmRleCBvciB5QXhpc0luZGV4IGdpdmVuLCBmaW5kIGl0cyBmaXJzdCBjYXJ0ZXNpYW4uXG5cblxuICBmb3IgKHZhciBpID0gMCwgY29vcmRMaXN0ID0gdGhpcy5fY29vcmRzTGlzdDsgaSA8IGNvb3JkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjb29yZExpc3RbaV0uZ2V0QXhpcygneCcpLmluZGV4ID09PSB4QXhpc0luZGV4IHx8IGNvb3JkTGlzdFtpXS5nZXRBeGlzKCd5JykuaW5kZXggPT09IHlBeGlzSW5kZXgpIHtcbiAgICAgIHJldHVybiBjb29yZExpc3RbaV07XG4gICAgfVxuICB9XG59O1xuXG5ncmlkUHJvdG8uZ2V0Q2FydGVzaWFucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Nvb3Jkc0xpc3Quc2xpY2UoKTtcbn07XG4vKipcbiAqIEBpbXBsZW1lbnRzXG4gKiBzZWUge21vZHVsZTplY2hhcnRzL0Nvb2RpbmF0ZVN5c3RlbX1cbiAqL1xuXG5cbmdyaWRQcm90by5jb252ZXJ0VG9QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSB7XG4gIHZhciB0YXJnZXQgPSB0aGlzLl9maW5kQ29udmVydFRhcmdldChlY01vZGVsLCBmaW5kZXIpO1xuXG4gIHJldHVybiB0YXJnZXQuY2FydGVzaWFuID8gdGFyZ2V0LmNhcnRlc2lhbi5kYXRhVG9Qb2ludCh2YWx1ZSkgOiB0YXJnZXQuYXhpcyA/IHRhcmdldC5heGlzLnRvR2xvYmFsQ29vcmQodGFyZ2V0LmF4aXMuZGF0YVRvQ29vcmQodmFsdWUpKSA6IG51bGw7XG59O1xuLyoqXG4gKiBAaW1wbGVtZW50c1xuICogc2VlIHttb2R1bGU6ZWNoYXJ0cy9Db29kaW5hdGVTeXN0ZW19XG4gKi9cblxuXG5ncmlkUHJvdG8uY29udmVydEZyb21QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSB7XG4gIHZhciB0YXJnZXQgPSB0aGlzLl9maW5kQ29udmVydFRhcmdldChlY01vZGVsLCBmaW5kZXIpO1xuXG4gIHJldHVybiB0YXJnZXQuY2FydGVzaWFuID8gdGFyZ2V0LmNhcnRlc2lhbi5wb2ludFRvRGF0YSh2YWx1ZSkgOiB0YXJnZXQuYXhpcyA/IHRhcmdldC5heGlzLmNvb3JkVG9EYXRhKHRhcmdldC5heGlzLnRvTG9jYWxDb29yZCh2YWx1ZSkpIDogbnVsbDtcbn07XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZ3JpZFByb3RvLl9maW5kQ29udmVydFRhcmdldCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIpIHtcbiAgdmFyIHNlcmllc01vZGVsID0gZmluZGVyLnNlcmllc01vZGVsO1xuICB2YXIgeEF4aXNNb2RlbCA9IGZpbmRlci54QXhpc01vZGVsIHx8IHNlcmllc01vZGVsICYmIHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3hBeGlzJylbMF07XG4gIHZhciB5QXhpc01vZGVsID0gZmluZGVyLnlBeGlzTW9kZWwgfHwgc2VyaWVzTW9kZWwgJiYgc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cygneUF4aXMnKVswXTtcbiAgdmFyIGdyaWRNb2RlbCA9IGZpbmRlci5ncmlkTW9kZWw7XG4gIHZhciBjb29yZHNMaXN0ID0gdGhpcy5fY29vcmRzTGlzdDtcbiAgdmFyIGNhcnRlc2lhbjtcbiAgdmFyIGF4aXM7XG5cbiAgaWYgKHNlcmllc01vZGVsKSB7XG4gICAgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB6clV0aWwuaW5kZXhPZihjb29yZHNMaXN0LCBjYXJ0ZXNpYW4pIDwgMCAmJiAoY2FydGVzaWFuID0gbnVsbCk7XG4gIH0gZWxzZSBpZiAoeEF4aXNNb2RlbCAmJiB5QXhpc01vZGVsKSB7XG4gICAgY2FydGVzaWFuID0gdGhpcy5nZXRDYXJ0ZXNpYW4oeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gIH0gZWxzZSBpZiAoeEF4aXNNb2RlbCkge1xuICAgIGF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnLCB4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgfSBlbHNlIGlmICh5QXhpc01vZGVsKSB7XG4gICAgYXhpcyA9IHRoaXMuZ2V0QXhpcygneScsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICB9IC8vIExvd2VzdCBwcmlvcml0eS5cbiAgZWxzZSBpZiAoZ3JpZE1vZGVsKSB7XG4gICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICBpZiAoZ3JpZCA9PT0gdGhpcykge1xuICAgICAgICBjYXJ0ZXNpYW4gPSB0aGlzLl9jb29yZHNMaXN0WzBdO1xuICAgICAgfVxuICAgIH1cblxuICByZXR1cm4ge1xuICAgIGNhcnRlc2lhbjogY2FydGVzaWFuLFxuICAgIGF4aXM6IGF4aXNcbiAgfTtcbn07XG4vKipcbiAqIEBpbXBsZW1lbnRzXG4gKiBzZWUge21vZHVsZTplY2hhcnRzL0Nvb2RpbmF0ZVN5c3RlbX1cbiAqL1xuXG5cbmdyaWRQcm90by5jb250YWluUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgdmFyIGNvb3JkID0gdGhpcy5fY29vcmRzTGlzdFswXTtcblxuICBpZiAoY29vcmQpIHtcbiAgICByZXR1cm4gY29vcmQuY29udGFpblBvaW50KHBvaW50KTtcbiAgfVxufTtcbi8qKlxuICogSW5pdGlhbGl6ZSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1zXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZ3JpZFByb3RvLl9pbml0Q2FydGVzaWFuID0gZnVuY3Rpb24gKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBheGlzUG9zaXRpb25Vc2VkID0ge1xuICAgIGxlZnQ6IGZhbHNlLFxuICAgIHJpZ2h0OiBmYWxzZSxcbiAgICB0b3A6IGZhbHNlLFxuICAgIGJvdHRvbTogZmFsc2VcbiAgfTtcbiAgdmFyIGF4ZXNNYXAgPSB7XG4gICAgeDoge30sXG4gICAgeToge31cbiAgfTtcbiAgdmFyIGF4ZXNDb3VudCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTsgLy8vIENyZWF0ZSBheGlzXG5cbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCd4QXhpcycsIGNyZWF0ZUF4aXNDcmVhdG9yKCd4JyksIHRoaXMpO1xuICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3lBeGlzJywgY3JlYXRlQXhpc0NyZWF0b3IoJ3knKSwgdGhpcyk7XG5cbiAgaWYgKCFheGVzQ291bnQueCB8fCAhYXhlc0NvdW50LnkpIHtcbiAgICAvLyBSb2xsIGJhY2sgd2hlbiB0aGVyZSBubyBlaXRoZXIgeCBvciB5IGF4aXNcbiAgICB0aGlzLl9heGVzTWFwID0ge307XG4gICAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9heGVzTWFwID0gYXhlc01hcDsgLy8vIENyZWF0ZSBjYXJ0ZXNpYW4yZFxuXG4gIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMsIHhBeGlzSW5kZXgpIHtcbiAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzLCB5QXhpc0luZGV4KSB7XG4gICAgICB2YXIga2V5ID0gJ3gnICsgeEF4aXNJbmRleCArICd5JyArIHlBeGlzSW5kZXg7XG4gICAgICB2YXIgY2FydGVzaWFuID0gbmV3IENhcnRlc2lhbjJEKGtleSk7XG4gICAgICBjYXJ0ZXNpYW4uZ3JpZCA9IHRoaXM7XG4gICAgICBjYXJ0ZXNpYW4ubW9kZWwgPSBncmlkTW9kZWw7XG4gICAgICB0aGlzLl9jb29yZHNNYXBba2V5XSA9IGNhcnRlc2lhbjtcblxuICAgICAgdGhpcy5fY29vcmRzTGlzdC5wdXNoKGNhcnRlc2lhbik7XG5cbiAgICAgIGNhcnRlc2lhbi5hZGRBeGlzKHhBeGlzKTtcbiAgICAgIGNhcnRlc2lhbi5hZGRBeGlzKHlBeGlzKTtcbiAgICB9LCB0aGlzKTtcbiAgfSwgdGhpcyk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXhpc0NyZWF0b3IoYXhpc1R5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGF4aXNNb2RlbCwgaWR4KSB7XG4gICAgICBpZiAoIWlzQXhpc1VzZWRJblRoZUdyaWQoYXhpc01vZGVsLCBncmlkTW9kZWwsIGVjTW9kZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNQb3NpdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG5cbiAgICAgIGlmIChheGlzVHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgIC8vIEZpeCBwb3NpdGlvblxuICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uICE9PSAndG9wJyAmJiBheGlzUG9zaXRpb24gIT09ICdib3R0b20nKSB7XG4gICAgICAgICAgLy8gRGVmYXVsdCBib3R0b20gb2YgWFxuICAgICAgICAgIGF4aXNQb3NpdGlvbiA9ICdib3R0b20nO1xuXG4gICAgICAgICAgaWYgKGF4aXNQb3NpdGlvblVzZWRbYXhpc1Bvc2l0aW9uXSkge1xuICAgICAgICAgICAgYXhpc1Bvc2l0aW9uID0gYXhpc1Bvc2l0aW9uID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaXggcG9zaXRpb25cbiAgICAgICAgaWYgKGF4aXNQb3NpdGlvbiAhPT0gJ2xlZnQnICYmIGF4aXNQb3NpdGlvbiAhPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIC8vIERlZmF1bHQgbGVmdCBvZiBZXG4gICAgICAgICAgYXhpc1Bvc2l0aW9uID0gJ2xlZnQnO1xuXG4gICAgICAgICAgaWYgKGF4aXNQb3NpdGlvblVzZWRbYXhpc1Bvc2l0aW9uXSkge1xuICAgICAgICAgICAgYXhpc1Bvc2l0aW9uID0gYXhpc1Bvc2l0aW9uID09PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBheGlzUG9zaXRpb25Vc2VkW2F4aXNQb3NpdGlvbl0gPSB0cnVlO1xuICAgICAgdmFyIGF4aXMgPSBuZXcgQXhpczJEKGF4aXNUeXBlLCBheGlzSGVscGVyLmNyZWF0ZVNjYWxlQnlNb2RlbChheGlzTW9kZWwpLCBbMCwgMF0sIGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSwgYXhpc1Bvc2l0aW9uKTtcbiAgICAgIHZhciBpc0NhdGVnb3J5ID0gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknO1xuICAgICAgYXhpcy5vbkJhbmQgPSBpc0NhdGVnb3J5ICYmIGF4aXNNb2RlbC5nZXQoJ2JvdW5kYXJ5R2FwJyk7XG4gICAgICBheGlzLmludmVyc2UgPSBheGlzTW9kZWwuZ2V0KCdpbnZlcnNlJyk7XG4gICAgICBheGlzLm9uWmVybyA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLm9uWmVybycpO1xuICAgICAgYXhpcy5vblplcm9BeGlzSW5kZXggPSBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5vblplcm9BeGlzSW5kZXgnKTsgLy8gSW5qZWN0IGF4aXMgaW50byBheGlzTW9kZWxcblxuICAgICAgYXhpc01vZGVsLmF4aXMgPSBheGlzOyAvLyBJbmplY3QgYXhpc01vZGVsIGludG8gYXhpc1xuXG4gICAgICBheGlzLm1vZGVsID0gYXhpc01vZGVsOyAvLyBJbmplY3QgZ3JpZCBpbmZvIGF4aXNcblxuICAgICAgYXhpcy5ncmlkID0gdGhpczsgLy8gSW5kZXggb2YgYXhpcywgY2FuIGJlIHVzZWQgYXMga2V5XG5cbiAgICAgIGF4aXMuaW5kZXggPSBpZHg7XG5cbiAgICAgIHRoaXMuX2F4ZXNMaXN0LnB1c2goYXhpcyk7XG5cbiAgICAgIGF4ZXNNYXBbYXhpc1R5cGVdW2lkeF0gPSBheGlzO1xuICAgICAgYXhlc0NvdW50W2F4aXNUeXBlXSsrO1xuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIFVwZGF0ZSBjYXJ0ZXNpYW4gcHJvcGVydGllcyBmcm9tIHNlcmllc1xuICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9ufSBvcHRpb25cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5ncmlkUHJvdG8uX3VwZGF0ZVNjYWxlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGdyaWRNb2RlbCkge1xuICAvLyBSZXNldCBzY2FsZVxuICB6clV0aWwuZWFjaCh0aGlzLl9heGVzTGlzdCwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICBheGlzLnNjYWxlLnNldEV4dGVudChJbmZpbml0eSwgLUluZmluaXR5KTtcbiAgfSk7XG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBpZiAoaXNDYXJ0ZXNpYW4yRChzZXJpZXNNb2RlbCkpIHtcbiAgICAgIHZhciBheGVzTW9kZWxzID0gZmluZEF4ZXNNb2RlbHMoc2VyaWVzTW9kZWwsIGVjTW9kZWwpO1xuICAgICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzBdO1xuICAgICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuXG4gICAgICBpZiAoIWlzQXhpc1VzZWRJblRoZUdyaWQoeEF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKSB8fCAhaXNBeGlzVXNlZEluVGhlR3JpZCh5QXhpc01vZGVsLCBncmlkTW9kZWwsIGVjTW9kZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhcnRlc2lhbiA9IHRoaXMuZ2V0Q2FydGVzaWFuKHhBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgeEF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QXhpcygneCcpO1xuICAgICAgdmFyIHlBeGlzID0gY2FydGVzaWFuLmdldEF4aXMoJ3knKTtcblxuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgIHVuaW9uRXh0ZW50KGRhdGEsIHhBeGlzLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgIHVuaW9uRXh0ZW50KGRhdGEsIHlBeGlzLCBzZXJpZXNNb2RlbCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICBmdW5jdGlvbiB1bmlvbkV4dGVudChkYXRhLCBheGlzLCBzZXJpZXNNb2RlbCkge1xuICAgIGVhY2goc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0oYXhpcy5kaW0pLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICBheGlzLnNjYWxlLnVuaW9uRXh0ZW50RnJvbURhdGEoZGF0YSwgZGltKTtcbiAgICB9KTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFtkaW1dICd4JyBvciAneScgb3IgJ2F1dG8nIG9yIG51bGwvdW5kZWZpbmVkXG4gKiBAcmV0dXJuIHtPYmplY3R9IHtiYXNlQXhlczogW10sIG90aGVyQXhlczogW119XG4gKi9cblxuXG5ncmlkUHJvdG8uZ2V0VG9vbHRpcEF4ZXMgPSBmdW5jdGlvbiAoZGltKSB7XG4gIHZhciBiYXNlQXhlcyA9IFtdO1xuICB2YXIgb3RoZXJBeGVzID0gW107XG4gIGVhY2godGhpcy5nZXRDYXJ0ZXNpYW5zKCksIGZ1bmN0aW9uIChjYXJ0ZXNpYW4pIHtcbiAgICB2YXIgYmFzZUF4aXMgPSBkaW0gIT0gbnVsbCAmJiBkaW0gIT09ICdhdXRvJyA/IGNhcnRlc2lhbi5nZXRBeGlzKGRpbSkgOiBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgb3RoZXJBeGlzID0gY2FydGVzaWFuLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgenJVdGlsLmluZGV4T2YoYmFzZUF4ZXMsIGJhc2VBeGlzKSA8IDAgJiYgYmFzZUF4ZXMucHVzaChiYXNlQXhpcyk7XG4gICAgenJVdGlsLmluZGV4T2Yob3RoZXJBeGVzLCBvdGhlckF4aXMpIDwgMCAmJiBvdGhlckF4ZXMucHVzaChvdGhlckF4aXMpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBiYXNlQXhlczogYmFzZUF4ZXMsXG4gICAgb3RoZXJBeGVzOiBvdGhlckF4ZXNcbiAgfTtcbn07XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gdXBkYXRlQXhpc1RyYW5zZnJvbShheGlzLCBjb29yZEJhc2UpIHtcbiAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEV4dGVudCgpO1xuICB2YXIgYXhpc0V4dGVudFN1bSA9IGF4aXNFeHRlbnRbMF0gKyBheGlzRXh0ZW50WzFdOyAvLyBGYXN0IHRyYW5zZm9ybVxuXG4gIGF4aXMudG9HbG9iYWxDb29yZCA9IGF4aXMuZGltID09PSAneCcgPyBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICByZXR1cm4gY29vcmQgKyBjb29yZEJhc2U7XG4gIH0gOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICByZXR1cm4gYXhpc0V4dGVudFN1bSAtIGNvb3JkICsgY29vcmRCYXNlO1xuICB9O1xuICBheGlzLnRvTG9jYWxDb29yZCA9IGF4aXMuZGltID09PSAneCcgPyBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICByZXR1cm4gY29vcmQgLSBjb29yZEJhc2U7XG4gIH0gOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICByZXR1cm4gYXhpc0V4dGVudFN1bSAtIGNvb3JkICsgY29vcmRCYXNlO1xuICB9O1xufVxuXG52YXIgYXhlc1R5cGVzID0gWyd4QXhpcycsICd5QXhpcyddO1xuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5mdW5jdGlvbiBmaW5kQXhlc01vZGVscyhzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICByZXR1cm4genJVdGlsLm1hcChheGVzVHlwZXMsIGZ1bmN0aW9uIChheGlzVHlwZSkge1xuICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKGF4aXNUeXBlKVswXTtcbiAgICByZXR1cm4gYXhpc01vZGVsO1xuICB9KTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBpc0NhcnRlc2lhbjJEKHNlcmllc01vZGVsKSB7XG4gIHJldHVybiBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKSA9PT0gJ2NhcnRlc2lhbjJkJztcbn1cblxuR3JpZC5jcmVhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBncmlkcyA9IFtdO1xuICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2dyaWQnLCBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBpZHgpIHtcbiAgICB2YXIgZ3JpZCA9IG5ldyBHcmlkKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICBncmlkLm5hbWUgPSAnZ3JpZF8nICsgaWR4OyAvLyBkYXRhU2FtcGxpbmcgcmVxdWlyZXMgYXhpcyBleHRlbnQsIHNvIHJlc2l6ZVxuICAgIC8vIHNob3VsZCBiZSBwZXJmb3JtZWQgaW4gY3JlYXRlIHN0YWdlLlxuXG4gICAgZ3JpZC5yZXNpemUoZ3JpZE1vZGVsLCBhcGksIHRydWUpO1xuICAgIGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gZ3JpZDtcbiAgICBncmlkcy5wdXNoKGdyaWQpO1xuICB9KTsgLy8gSW5qZWN0IHRoZSBjb29yZGluYXRlU3lzdGVtcyBpbnRvIHNlcmllc01vZGVsXG5cbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIGlmICghaXNDYXJ0ZXNpYW4yRChzZXJpZXNNb2RlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXhlc01vZGVscyA9IGZpbmRBeGVzTW9kZWxzKHNlcmllc01vZGVsLCBlY01vZGVsKTtcbiAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMF07XG4gICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuICAgIHZhciBncmlkTW9kZWwgPSB4QXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKTtcbiAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBncmlkLmdldENhcnRlc2lhbih4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBncmlkcztcbn07IC8vIEZvciBkZWNpZGluZyB3aGljaCBkaW1lbnNpb25zIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGxpc3QgZGF0YVxuXG5cbkdyaWQuZGltZW5zaW9ucyA9IEdyaWQucHJvdG90eXBlLmRpbWVuc2lvbnMgPSBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuZGltZW5zaW9ucztcbkNvb3JkaW5hdGVTeXN0ZW0ucmVnaXN0ZXIoJ2NhcnRlc2lhbjJkJywgR3JpZCk7XG52YXIgX2RlZmF1bHQgPSBHcmlkO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vR3JpZC5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Db21wb25lbnRcIik7XG5cbnZhciBheGlzTW9kZWxDcmVhdG9yID0gcmVxdWlyZShcIi4uL2F4aXNNb2RlbENyZWF0b3JcIik7XG5cbnZhciBheGlzTW9kZWxDb21tb25NaXhpbiA9IHJlcXVpcmUoXCIuLi9heGlzTW9kZWxDb21tb25NaXhpblwiKTtcblxudmFyIEF4aXNNb2RlbCA9IENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdjYXJ0ZXNpYW4yZEF4aXMnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRH1cbiAgICovXG4gIGF4aXM6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIEF4aXNNb2RlbC5zdXBlckFwcGx5KHRoaXMsICdpbml0JywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnJlc2V0UmFuZ2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIEF4aXNNb2RlbC5zdXBlckFwcGx5KHRoaXMsICdtZXJnZU9wdGlvbicsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZXNldFJhbmdlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBBeGlzTW9kZWwuc3VwZXJBcHBseSh0aGlzLCAncmVzdG9yZURhdGEnLCBhcmd1bWVudHMpO1xuICAgIHRoaXMucmVzZXRSYW5nZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fVxuICAgKi9cbiAgZ2V0Q29vcmRTeXNNb2RlbDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgIG1haW5UeXBlOiAnZ3JpZCcsXG4gICAgICBpbmRleDogdGhpcy5vcHRpb24uZ3JpZEluZGV4LFxuICAgICAgaWQ6IHRoaXMub3B0aW9uLmdyaWRJZFxuICAgIH0pWzBdO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0QXhpc1R5cGUoYXhpc0RpbSwgb3B0aW9uKSB7XG4gIC8vIERlZmF1bHQgYXhpcyB3aXRoIGRhdGEgaXMgY2F0ZWdvcnkgYXhpc1xuICByZXR1cm4gb3B0aW9uLnR5cGUgfHwgKG9wdGlvbi5kYXRhID8gJ2NhdGVnb3J5JyA6ICd2YWx1ZScpO1xufVxuXG56clV0aWwubWVyZ2UoQXhpc01vZGVsLnByb3RvdHlwZSwgYXhpc01vZGVsQ29tbW9uTWl4aW4pO1xudmFyIGV4dHJhT3B0aW9uID0ge1xuICAvLyBncmlkSW5kZXg6IDAsXG4gIC8vIGdyaWRJZDogJycsXG4gIC8vIE9mZnNldCBpcyBmb3IgbXVsdGlwbGUgYXhpcyBvbiB0aGUgc2FtZSBwb3NpdGlvblxuICBvZmZzZXQ6IDBcbn07XG5heGlzTW9kZWxDcmVhdG9yKCd4JywgQXhpc01vZGVsLCBnZXRBeGlzVHlwZSwgZXh0cmFPcHRpb24pO1xuYXhpc01vZGVsQ3JlYXRvcigneScsIEF4aXNNb2RlbCwgZ2V0QXhpc1R5cGUsIGV4dHJhT3B0aW9uKTtcbnZhciBfZGVmYXVsdCA9IEF4aXNNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL3V0aWwvZ3JhcGhpY1wiKTtcblxucmVxdWlyZShcIi4uL2Nvb3JkL2NhcnRlc2lhbi9HcmlkXCIpO1xuXG5yZXF1aXJlKFwiLi9heGlzXCIpO1xuXG4vLyBHcmlkIHZpZXdcbmVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG4gIHR5cGU6ICdncmlkJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcblxuICAgIGlmIChncmlkTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHRoaXMuZ3JvdXAuYWRkKG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICBzaGFwZTogZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpLFxuICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICBmaWxsOiBncmlkTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKVxuICAgICAgICB9LCBncmlkTW9kZWwuZ2V0SXRlbVN0eWxlKCkpLFxuICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgIHoyOiAtMVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufSk7XG5lY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgLy8gT25seSBjcmVhdGUgZ3JpZCB3aGVuIG5lZWRcbiAgaWYgKG9wdGlvbi54QXhpcyAmJiBvcHRpb24ueUF4aXMgJiYgIW9wdGlvbi5ncmlkKSB7XG4gICAgb3B0aW9uLmdyaWQgPSB7fTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyaWRTaW1wbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciByZXRyaWV2ZSA9IF91dGlsLnJldHJpZXZlO1xudmFyIGRlZmF1bHRzID0gX3V0aWwuZGVmYXVsdHM7XG52YXIgZXh0ZW5kID0gX3V0aWwuZXh0ZW5kO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvTW9kZWxcIik7XG5cbnZhciBfbnVtYmVyID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgaXNSYWRpYW5Bcm91bmRaZXJvID0gX251bWJlci5pc1JhZGlhbkFyb3VuZFplcm87XG52YXIgcmVtUmFkaWFuID0gX251bWJlci5yZW1SYWRpYW47XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvc3ltYm9sXCIpO1xuXG52YXIgY3JlYXRlU3ltYm9sID0gX3N5bWJvbC5jcmVhdGVTeW1ib2w7XG5cbnZhciBtYXRyaXhVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSBfdmVjdG9yLmFwcGx5VHJhbnNmb3JtO1xudmFyIFBJID0gTWF0aC5QSTtcblxuZnVuY3Rpb24gbWFrZUF4aXNFdmVudERhdGFCYXNlKGF4aXNNb2RlbCkge1xuICB2YXIgZXZlbnREYXRhID0ge1xuICAgIGNvbXBvbmVudFR5cGU6IGF4aXNNb2RlbC5tYWluVHlwZVxuICB9O1xuICBldmVudERhdGFbYXhpc01vZGVsLm1haW5UeXBlICsgJ0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gIHJldHVybiBldmVudERhdGE7XG59XG4vKipcbiAqIEEgZmluYWwgYXhpcyBpcyB0cmFuc2xhdGVkIGFuZCByb3RhdGVkIGZyb20gYSBcInN0YW5kYXJkIGF4aXNcIi5cbiAqIFNvIG9wdC5wb3NpdGlvbiBhbmQgb3B0LnJvdGF0aW9uIGlzIHJlcXVpcmVkLlxuICpcbiAqIEEgc3RhbmRhcmQgYXhpcyBpcyBhbmQgYXhpcyBmcm9tIFswLCAwXSB0byBbMCwgYXhpc0V4dGVudFsxXV0sXG4gKiBmb3IgZXhhbXBsZTogKDAsIDApIC0tLS0tLS0tLS0tLT4gKDAsIDUwKVxuICpcbiAqIG5hbWVEaXJlY3Rpb24gb3IgdGlja0RpcmVjdGlvbiBvciBsYWJlbERpcmVjdGlvbiBpcyAxIG1lYW5zIHRpY2tcbiAqIG9yIGxhYmVsIGlzIGJlbG93IHRoZSBzdGFuZGFyZCBheGlzLCB3aGVyZWFzIGlzIC0xIG1lYW5zIGFib3ZlXG4gKiB0aGUgc3RhbmRhcmQgYXhpcy4gbGFiZWxPZmZzZXQgbWVhbnMgb2Zmc2V0IGJldHdlZW4gbGFiZWwgYW5kIGF4aXMsXG4gKiB3aGljaCBpcyB1c2VmdWwgd2hlbiAnb25aZXJvJywgd2hlcmUgYXhpc0xhYmVsIGlzIGluIHRoZSBncmlkIGFuZFxuICogbGFiZWwgaW4gb3V0c2lkZSBncmlkLlxuICpcbiAqIFRpcHM6IGxpa2UgYWx3YXlzLFxuICogcG9zaXRpdmUgcm90YXRpb24gcmVwcmVzZW50cyBhbnRpY2xvY2t3aXNlLCBhbmQgbmVnYXRpdmUgcm90YXRpb25cbiAqIHJlcHJlc2VudHMgY2xvY2t3aXNlLlxuICogVGhlIGRpcmVjdGlvbiBvZiBwb3NpdGlvbiBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBkaXJlY3Rpb25cbiAqIG9mIHNjcmVlbiBjb29yZGluYXRlLlxuICpcbiAqIERvIG5vdCBuZWVkIHRvIGNvbnNpZGVyIGF4aXMgJ2ludmVyc2UnLCB3aGljaCBpcyBhdXRvIHByb2Nlc3NlZCBieVxuICogYXhpcyBleHRlbnQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gKiBAcGFyYW0ge09iamVjdH0gYXhpc01vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0IFN0YW5kYXJkIGF4aXMgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG9wdC5wb3NpdGlvbiBbeCwgeV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHQucm90YXRpb24gYnkgcmFkaWFuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5uYW1lRGlyZWN0aW9uPTFdIDEgb3IgLTEgVXNlZCB3aGVuIG5hbWVMb2NhdGlvbiBpcyAnbWlkZGxlJyBvciAnY2VudGVyJy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnRpY2tEaXJlY3Rpb249MV0gMSBvciAtMVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxEaXJlY3Rpb249MV0gMSBvciAtMVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxPZmZzZXQ9MF0gVXNlZnVsbCB3aGVuIG9uWmVyby5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmF4aXNMYWJlbFNob3ddIGRlZmF1bHQgZ2V0IGZyb20gYXhpc01vZGVsLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuYXhpc05hbWVdIGRlZmF1bHQgZ2V0IGZyb20gYXhpc01vZGVsLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuYXhpc05hbWVBdmFpbGFibGVXaWR0aF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmxhYmVsUm90YXRlXSBieSBkZWdyZWUsIGRlZmF1bHQgZ2V0IGZyb20gYXhpc01vZGVsLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxJbnRlcnZhbF0gRGVmYXVsdCBsYWJlbCBpbnRlcnZhbCB3aGVuIGxhYmVsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCBmcm9tIG1vZGVsIGlzIG51bGwgb3IgJ2F1dG8nLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3Ryb2tlQ29udGFpblRocmVzaG9sZF0gRGVmYXVsdCBsYWJlbCBpbnRlcnZhbCB3aGVuIGxhYmVsXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5uYW1lVHJ1bmNhdGVNYXhXaWR0aF1cbiAqL1xuXG5cbnZhciBBeGlzQnVpbGRlciA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIG9wdCkge1xuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLm9wdCA9IG9wdDtcbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLmF4aXNNb2RlbCA9IGF4aXNNb2RlbDsgLy8gRGVmYXVsdCB2YWx1ZVxuXG4gIGRlZmF1bHRzKG9wdCwge1xuICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgIG5hbWVEaXJlY3Rpb246IDEsXG4gICAgdGlja0RpcmVjdGlvbjogMSxcbiAgICBsYWJlbERpcmVjdGlvbjogMSxcbiAgICBzaWxlbnQ6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7IC8vIEZJWE1FIE5vdCB1c2UgYSBzZXBlcmF0ZSB0ZXh0IGdyb3VwP1xuXG4gIHZhciBkdW1iR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCh7XG4gICAgcG9zaXRpb246IG9wdC5wb3NpdGlvbi5zbGljZSgpLFxuICAgIHJvdGF0aW9uOiBvcHQucm90YXRpb25cbiAgfSk7IC8vIHRoaXMuZ3JvdXAuYWRkKGR1bWJHcm91cCk7XG4gIC8vIHRoaXMuX2R1bWJHcm91cCA9IGR1bWJHcm91cDtcblxuICBkdW1iR3JvdXAudXBkYXRlVHJhbnNmb3JtKCk7XG4gIHRoaXMuX3RyYW5zZm9ybSA9IGR1bWJHcm91cC50cmFuc2Zvcm07XG4gIHRoaXMuX2R1bWJHcm91cCA9IGR1bWJHcm91cDtcbn07XG5cbkF4aXNCdWlsZGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEF4aXNCdWlsZGVyLFxuICBoYXNCdWlsZGVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIWJ1aWxkZXJzW25hbWVdO1xuICB9LFxuICBhZGQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgYnVpbGRlcnNbbmFtZV0uY2FsbCh0aGlzKTtcbiAgfSxcbiAgZ2V0R3JvdXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cDtcbiAgfVxufTtcbnZhciBidWlsZGVycyA9IHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBheGlzTGluZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG5cbiAgICBpZiAoIWF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLnNob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBleHRlbnQgPSB0aGlzLmF4aXNNb2RlbC5heGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBtYXRyaXggPSB0aGlzLl90cmFuc2Zvcm07XG4gICAgdmFyIHB0MSA9IFtleHRlbnRbMF0sIDBdO1xuICAgIHZhciBwdDIgPSBbZXh0ZW50WzFdLCAwXTtcblxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQxLCBwdDEsIG1hdHJpeCk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MiwgcHQyLCBtYXRyaXgpO1xuICAgIH1cblxuICAgIHZhciBsaW5lU3R5bGUgPSBleHRlbmQoe1xuICAgICAgbGluZUNhcDogJ3JvdW5kJ1xuICAgIH0sIGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xpbmUubGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCkpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKG5ldyBncmFwaGljLkxpbmUoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG4gICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICBhbmlkOiAnbGluZScsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4MTogcHQxWzBdLFxuICAgICAgICB5MTogcHQxWzFdLFxuICAgICAgICB4MjogcHQyWzBdLFxuICAgICAgICB5MjogcHQyWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IGxpbmVTdHlsZSxcbiAgICAgIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IG9wdC5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDUsXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICB6MjogMVxuICAgIH0pKSk7XG4gICAgdmFyIGFycm93cyA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLnN5bWJvbCcpO1xuICAgIHZhciBhcnJvd1NpemUgPSBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5zeW1ib2xTaXplJyk7XG5cbiAgICBpZiAoYXJyb3dzICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyb3dzID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBVc2UgdGhlIHNhbWUgYXJyb3cgZm9yIHN0YXJ0IGFuZCBlbmQgcG9pbnRcbiAgICAgICAgYXJyb3dzID0gW2Fycm93cywgYXJyb3dzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhcnJvd1NpemUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcnJvd1NpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgc2FtZSBzaXplIGZvciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIGFycm93U2l6ZSA9IFthcnJvd1NpemUsIGFycm93U2l6ZV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW1ib2xXaWR0aCA9IGFycm93U2l6ZVswXTtcbiAgICAgIHZhciBzeW1ib2xIZWlnaHQgPSBhcnJvd1NpemVbMV07XG4gICAgICBlYWNoKFtbb3B0LnJvdGF0aW9uICsgTWF0aC5QSSAvIDIsIHB0MV0sIFtvcHQucm90YXRpb24gLSBNYXRoLlBJIC8gMiwgcHQyXV0sIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoYXJyb3dzW2luZGV4XSAhPT0gJ25vbmUnICYmIGFycm93c1tpbmRleF0gIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBzeW1ib2wgPSBjcmVhdGVTeW1ib2woYXJyb3dzW2luZGV4XSwgLXN5bWJvbFdpZHRoIC8gMiwgLXN5bWJvbEhlaWdodCAvIDIsIHN5bWJvbFdpZHRoLCBzeW1ib2xIZWlnaHQsIGxpbmVTdHlsZS5zdHJva2UsIHRydWUpO1xuICAgICAgICAgIHN5bWJvbC5hdHRyKHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiBpdGVtWzBdLFxuICAgICAgICAgICAgcG9zaXRpb246IGl0ZW1bMV0sXG4gICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBheGlzVGlja0xhYmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuYXhpc01vZGVsO1xuICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcbiAgICB2YXIgdGlja0VscyA9IGJ1aWxkQXhpc1RpY2sodGhpcywgYXhpc01vZGVsLCBvcHQpO1xuICAgIHZhciBsYWJlbEVscyA9IGJ1aWxkQXhpc0xhYmVsKHRoaXMsIGF4aXNNb2RlbCwgb3B0KTtcbiAgICBmaXhNaW5NYXhMYWJlbFNob3coYXhpc01vZGVsLCBsYWJlbEVscywgdGlja0Vscyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBheGlzTmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG4gICAgdmFyIG5hbWUgPSByZXRyaWV2ZShvcHQuYXhpc05hbWUsIGF4aXNNb2RlbC5nZXQoJ25hbWUnKSk7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmFtZUxvY2F0aW9uID0gYXhpc01vZGVsLmdldCgnbmFtZUxvY2F0aW9uJyk7XG4gICAgdmFyIG5hbWVEaXJlY3Rpb24gPSBvcHQubmFtZURpcmVjdGlvbjtcbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ25hbWVUZXh0U3R5bGUnKTtcbiAgICB2YXIgZ2FwID0gYXhpc01vZGVsLmdldCgnbmFtZUdhcCcpIHx8IDA7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuYXhpc01vZGVsLmF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGdhcFNpZ25hbCA9IGV4dGVudFswXSA+IGV4dGVudFsxXSA/IC0xIDogMTtcbiAgICB2YXIgcG9zID0gW25hbWVMb2NhdGlvbiA9PT0gJ3N0YXJ0JyA/IGV4dGVudFswXSAtIGdhcFNpZ25hbCAqIGdhcCA6IG5hbWVMb2NhdGlvbiA9PT0gJ2VuZCcgPyBleHRlbnRbMV0gKyBnYXBTaWduYWwgKiBnYXAgOiAoZXh0ZW50WzBdICsgZXh0ZW50WzFdKSAvIDIsIC8vICdtaWRkbGUnXG4gICAgLy8gUmV1c2UgbGFiZWxPZmZzZXQuXG4gICAgaXNOYW1lTG9jYXRpb25DZW50ZXIobmFtZUxvY2F0aW9uKSA/IG9wdC5sYWJlbE9mZnNldCArIG5hbWVEaXJlY3Rpb24gKiBnYXAgOiAwXTtcbiAgICB2YXIgbGFiZWxMYXlvdXQ7XG4gICAgdmFyIG5hbWVSb3RhdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ25hbWVSb3RhdGUnKTtcblxuICAgIGlmIChuYW1lUm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgbmFtZVJvdGF0aW9uID0gbmFtZVJvdGF0aW9uICogUEkgLyAxODA7IC8vIFRvIHJhZGlhbi5cbiAgICB9XG5cbiAgICB2YXIgYXhpc05hbWVBdmFpbGFibGVXaWR0aDtcblxuICAgIGlmIChpc05hbWVMb2NhdGlvbkNlbnRlcihuYW1lTG9jYXRpb24pKSB7XG4gICAgICBsYWJlbExheW91dCA9IGlubmVyVGV4dExheW91dChvcHQucm90YXRpb24sIG5hbWVSb3RhdGlvbiAhPSBudWxsID8gbmFtZVJvdGF0aW9uIDogb3B0LnJvdGF0aW9uLCAvLyBBZGFwdCB0byBheGlzLlxuICAgICAgbmFtZURpcmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsTGF5b3V0ID0gZW5kVGV4dExheW91dChvcHQsIG5hbWVMb2NhdGlvbiwgbmFtZVJvdGF0aW9uIHx8IDAsIGV4dGVudCk7XG4gICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gb3B0LmF4aXNOYW1lQXZhaWxhYmxlV2lkdGg7XG5cbiAgICAgIGlmIChheGlzTmFtZUF2YWlsYWJsZVdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IE1hdGguYWJzKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggLyBNYXRoLnNpbihsYWJlbExheW91dC5yb3RhdGlvbikpO1xuICAgICAgICAhaXNGaW5pdGUoYXhpc05hbWVBdmFpbGFibGVXaWR0aCkgJiYgKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggPSBudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGV4dEZvbnQgPSB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCk7XG4gICAgdmFyIHRydW5jYXRlT3B0ID0gYXhpc01vZGVsLmdldCgnbmFtZVRydW5jYXRlJywgdHJ1ZSkgfHwge307XG4gICAgdmFyIGVsbGlwc2lzID0gdHJ1bmNhdGVPcHQuZWxsaXBzaXM7XG4gICAgdmFyIG1heFdpZHRoID0gcmV0cmlldmUob3B0Lm5hbWVUcnVuY2F0ZU1heFdpZHRoLCB0cnVuY2F0ZU9wdC5tYXhXaWR0aCwgYXhpc05hbWVBdmFpbGFibGVXaWR0aCk7IC8vIEZJWE1FXG4gICAgLy8gdHJ1bmNhdGUgcmljaCB0ZXh0PyAoY29uc2lkZXIgcGVyZm9ybWFuY2UpXG5cbiAgICB2YXIgdHJ1bmNhdGVkVGV4dCA9IGVsbGlwc2lzICE9IG51bGwgJiYgbWF4V2lkdGggIT0gbnVsbCA/IGZvcm1hdFV0aWwudHJ1bmNhdGVUZXh0KG5hbWUsIG1heFdpZHRoLCB0ZXh0Rm9udCwgZWxsaXBzaXMsIHtcbiAgICAgIG1pbkNoYXI6IDIsXG4gICAgICBwbGFjZWhvbGRlcjogdHJ1bmNhdGVPcHQucGxhY2Vob2xkZXJcbiAgICB9KSA6IG5hbWU7XG4gICAgdmFyIHRvb2x0aXBPcHQgPSBheGlzTW9kZWwuZ2V0KCd0b29sdGlwJywgdHJ1ZSk7XG4gICAgdmFyIG1haW5UeXBlID0gYXhpc01vZGVsLm1haW5UeXBlO1xuICAgIHZhciBmb3JtYXR0ZXJQYXJhbXMgPSB7XG4gICAgICBjb21wb25lbnRUeXBlOiBtYWluVHlwZSxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAkdmFyczogWyduYW1lJ11cbiAgICB9O1xuICAgIGZvcm1hdHRlclBhcmFtc1ttYWluVHlwZSArICdJbmRleCddID0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4O1xuICAgIHZhciB0ZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgIGFuaWQ6ICduYW1lJyxcbiAgICAgIF9fZnVsbFRleHQ6IG5hbWUsXG4gICAgICBfX3RydW5jYXRlZFRleHQ6IHRydW5jYXRlZFRleHQsXG4gICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgcm90YXRpb246IGxhYmVsTGF5b3V0LnJvdGF0aW9uLFxuICAgICAgc2lsZW50OiBpc1NpbGVudChheGlzTW9kZWwpLFxuICAgICAgejI6IDEsXG4gICAgICB0b29sdGlwOiB0b29sdGlwT3B0ICYmIHRvb2x0aXBPcHQuc2hvdyA/IGV4dGVuZCh7XG4gICAgICAgIGNvbnRlbnQ6IG5hbWUsXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXJQYXJhbXM6IGZvcm1hdHRlclBhcmFtc1xuICAgICAgfSwgdG9vbHRpcE9wdCkgOiBudWxsXG4gICAgfSk7XG4gICAgZ3JhcGhpYy5zZXRUZXh0U3R5bGUodGV4dEVsLnN0eWxlLCB0ZXh0U3R5bGVNb2RlbCwge1xuICAgICAgdGV4dDogdHJ1bmNhdGVkVGV4dCxcbiAgICAgIHRleHRGb250OiB0ZXh0Rm9udCxcbiAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5saW5lU3R5bGUuY29sb3InKSxcbiAgICAgIHRleHRBbGlnbjogbGFiZWxMYXlvdXQudGV4dEFsaWduLFxuICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IGxhYmVsTGF5b3V0LnRleHRWZXJ0aWNhbEFsaWduXG4gICAgfSk7XG5cbiAgICBpZiAoYXhpc01vZGVsLmdldCgndHJpZ2dlckV2ZW50JykpIHtcbiAgICAgIHRleHRFbC5ldmVudERhdGEgPSBtYWtlQXhpc0V2ZW50RGF0YUJhc2UoYXhpc01vZGVsKTtcbiAgICAgIHRleHRFbC5ldmVudERhdGEudGFyZ2V0VHlwZSA9ICdheGlzTmFtZSc7XG4gICAgICB0ZXh0RWwuZXZlbnREYXRhLm5hbWUgPSBuYW1lO1xuICAgIH0gLy8gRklYTUVcblxuXG4gICAgdGhpcy5fZHVtYkdyb3VwLmFkZCh0ZXh0RWwpO1xuXG4gICAgdGV4dEVsLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgdGV4dEVsLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICB9XG59O1xuLyoqXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gKiBAcGFyYW0ge251bWJlcn0gYXhpc1JvdGF0aW9uIGluIHJhZGlhblxuICogQHBhcmFtIHtudW1iZXJ9IHRleHRSb3RhdGlvbiBpbiByYWRpYW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb25cbiAqIEByZXR1cm4ge09iamVjdH0ge1xuICogIHJvdGF0aW9uLCAvLyBhY2NvcmRpbmcgdG8gYXhpc1xuICogIHRleHRBbGlnbixcbiAqICB0ZXh0VmVydGljYWxBbGlnblxuICogfVxuICovXG5cbnZhciBpbm5lclRleHRMYXlvdXQgPSBBeGlzQnVpbGRlci5pbm5lclRleHRMYXlvdXQgPSBmdW5jdGlvbiAoYXhpc1JvdGF0aW9uLCB0ZXh0Um90YXRpb24sIGRpcmVjdGlvbikge1xuICB2YXIgcm90YXRpb25EaWZmID0gcmVtUmFkaWFuKHRleHRSb3RhdGlvbiAtIGF4aXNSb3RhdGlvbik7XG4gIHZhciB0ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbjtcblxuICBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZikpIHtcbiAgICAvLyBMYWJlbCBpcyBwYXJhbGxlbCB3aXRoIGF4aXMgbGluZS5cbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAndG9wJyA6ICdib3R0b20nO1xuICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYgLSBQSSkpIHtcbiAgICAvLyBMYWJlbCBpcyBpbnZlcnNlIHBhcmFsbGVsIHdpdGggYXhpcyBsaW5lLlxuICAgIHRleHRWZXJ0aWNhbEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gIH0gZWxzZSB7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcblxuICAgIGlmIChyb3RhdGlvbkRpZmYgPiAwICYmIHJvdGF0aW9uRGlmZiA8IFBJKSB7XG4gICAgICB0ZXh0QWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByb3RhdGlvbjogcm90YXRpb25EaWZmLFxuICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgIHRleHRWZXJ0aWNhbEFsaWduOiB0ZXh0VmVydGljYWxBbGlnblxuICB9O1xufTtcblxuZnVuY3Rpb24gZW5kVGV4dExheW91dChvcHQsIHRleHRQb3NpdGlvbiwgdGV4dFJvdGF0ZSwgZXh0ZW50KSB7XG4gIHZhciByb3RhdGlvbkRpZmYgPSByZW1SYWRpYW4odGV4dFJvdGF0ZSAtIG9wdC5yb3RhdGlvbik7XG4gIHZhciB0ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbjtcbiAgdmFyIGludmVyc2UgPSBleHRlbnRbMF0gPiBleHRlbnRbMV07XG4gIHZhciBvbkxlZnQgPSB0ZXh0UG9zaXRpb24gPT09ICdzdGFydCcgJiYgIWludmVyc2UgfHwgdGV4dFBvc2l0aW9uICE9PSAnc3RhcnQnICYmIGludmVyc2U7XG5cbiAgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYgLSBQSSAvIDIpKSB7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBvbkxlZnQgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYgLSBQSSAqIDEuNSkpIHtcbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9IG9uTGVmdCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gIH0gZWxzZSB7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcblxuICAgIGlmIChyb3RhdGlvbkRpZmYgPCBQSSAqIDEuNSAmJiByb3RhdGlvbkRpZmYgPiBQSSAvIDIpIHtcbiAgICAgIHRleHRBbGlnbiA9IG9uTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRBbGlnbiA9IG9uTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByb3RhdGlvbjogcm90YXRpb25EaWZmLFxuICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgIHRleHRWZXJ0aWNhbEFsaWduOiB0ZXh0VmVydGljYWxBbGlnblxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1NpbGVudChheGlzTW9kZWwpIHtcbiAgdmFyIHRvb2x0aXBPcHQgPSBheGlzTW9kZWwuZ2V0KCd0b29sdGlwJyk7XG4gIHJldHVybiBheGlzTW9kZWwuZ2V0KCdzaWxlbnQnKSAvLyBDb25zaWRlciBtb3VzZSBjdXJzb3IsIGFkZCB0aGVzZSByZXN0cmljdGlvbnMuXG4gIHx8ICEoYXhpc01vZGVsLmdldCgndHJpZ2dlckV2ZW50JykgfHwgdG9vbHRpcE9wdCAmJiB0b29sdGlwT3B0LnNob3cpO1xufVxuXG5mdW5jdGlvbiBmaXhNaW5NYXhMYWJlbFNob3coYXhpc01vZGVsLCBsYWJlbEVscywgdGlja0Vscykge1xuICAvLyBJZiBtaW4gb3IgbWF4IGFyZSB1c2VyIHNldCwgd2UgbmVlZCB0byBjaGVja1xuICAvLyBJZiB0aGUgdGljayBvbiBtaW4obWF4KSBhcmUgb3ZlcmxhcCBvbiB0aGVpciBuZWlnaGJvdXIgdGlja1xuICAvLyBJZiB0aGV5IGFyZSBvdmVybGFwcGVkLCB3ZSBuZWVkIHRvIGhpZGUgdGhlIG1pbihtYXgpIHRpY2sgbGFiZWxcbiAgdmFyIHNob3dNaW5MYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWluTGFiZWwnKTtcbiAgdmFyIHNob3dNYXhMYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWF4TGFiZWwnKTsgLy8gRklYTUVcbiAgLy8gSGF2ZSBub3QgY29uc2lkZXIgb25CYW5kIHlldCwgd2hlcmUgdGljayBlbHMgaXMgbW9yZSB0aGFuIGxhYmVsIGVscy5cblxuICBsYWJlbEVscyA9IGxhYmVsRWxzIHx8IFtdO1xuICB0aWNrRWxzID0gdGlja0VscyB8fCBbXTtcbiAgdmFyIGZpcnN0TGFiZWwgPSBsYWJlbEVsc1swXTtcbiAgdmFyIG5leHRMYWJlbCA9IGxhYmVsRWxzWzFdO1xuICB2YXIgbGFzdExhYmVsID0gbGFiZWxFbHNbbGFiZWxFbHMubGVuZ3RoIC0gMV07XG4gIHZhciBwcmV2TGFiZWwgPSBsYWJlbEVsc1tsYWJlbEVscy5sZW5ndGggLSAyXTtcbiAgdmFyIGZpcnN0VGljayA9IHRpY2tFbHNbMF07XG4gIHZhciBuZXh0VGljayA9IHRpY2tFbHNbMV07XG4gIHZhciBsYXN0VGljayA9IHRpY2tFbHNbdGlja0Vscy5sZW5ndGggLSAxXTtcbiAgdmFyIHByZXZUaWNrID0gdGlja0Vsc1t0aWNrRWxzLmxlbmd0aCAtIDJdO1xuXG4gIGlmIChzaG93TWluTGFiZWwgPT09IGZhbHNlKSB7XG4gICAgaWdub3JlRWwoZmlyc3RMYWJlbCk7XG4gICAgaWdub3JlRWwoZmlyc3RUaWNrKTtcbiAgfSBlbHNlIGlmIChpc1R3b0xhYmVsT3ZlcmxhcHBlZChmaXJzdExhYmVsLCBuZXh0TGFiZWwpKSB7XG4gICAgaWYgKHNob3dNaW5MYWJlbCkge1xuICAgICAgaWdub3JlRWwobmV4dExhYmVsKTtcbiAgICAgIGlnbm9yZUVsKG5leHRUaWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWdub3JlRWwoZmlyc3RMYWJlbCk7XG4gICAgICBpZ25vcmVFbChmaXJzdFRpY2spO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaG93TWF4TGFiZWwgPT09IGZhbHNlKSB7XG4gICAgaWdub3JlRWwobGFzdExhYmVsKTtcbiAgICBpZ25vcmVFbChsYXN0VGljayk7XG4gIH0gZWxzZSBpZiAoaXNUd29MYWJlbE92ZXJsYXBwZWQocHJldkxhYmVsLCBsYXN0TGFiZWwpKSB7XG4gICAgaWYgKHNob3dNYXhMYWJlbCkge1xuICAgICAgaWdub3JlRWwocHJldkxhYmVsKTtcbiAgICAgIGlnbm9yZUVsKHByZXZUaWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWdub3JlRWwobGFzdExhYmVsKTtcbiAgICAgIGlnbm9yZUVsKGxhc3RUaWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaWdub3JlRWwoZWwpIHtcbiAgZWwgJiYgKGVsLmlnbm9yZSA9IHRydWUpO1xufVxuXG5mdW5jdGlvbiBpc1R3b0xhYmVsT3ZlcmxhcHBlZChjdXJyZW50LCBuZXh0LCBsYWJlbExheW91dCkge1xuICAvLyBjdXJyZW50IGFuZCBuZXh0IGhhcyB0aGUgc2FtZSByb3RhdGlvbi5cbiAgdmFyIGZpcnN0UmVjdCA9IGN1cnJlbnQgJiYgY3VycmVudC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICB2YXIgbmV4dFJlY3QgPSBuZXh0ICYmIG5leHQuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcblxuICBpZiAoIWZpcnN0UmVjdCB8fCAhbmV4dFJlY3QpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gV2hlbiBjaGVja2luZyBpbnRlcnNlY3Qgb2YgdHdvIHJvdGF0ZWQgbGFiZWxzLCB3ZSB1c2UgbVJvdGF0aW9uQmFja1xuICAvLyB0byBhdm9pZCB0aGF0IGJvdW5kaW5nUmVjdCBpcyBlbmxhcmdlIHdoZW4gdXNpbmcgYGJvdW5kaW5nUmVjdC5hcHBseVRyYW5zZm9ybWAuXG5cblxuICB2YXIgbVJvdGF0aW9uQmFjayA9IG1hdHJpeFV0aWwuaWRlbnRpdHkoW10pO1xuICBtYXRyaXhVdGlsLnJvdGF0ZShtUm90YXRpb25CYWNrLCBtUm90YXRpb25CYWNrLCAtY3VycmVudC5yb3RhdGlvbik7XG4gIGZpcnN0UmVjdC5hcHBseVRyYW5zZm9ybShtYXRyaXhVdGlsLm11bChbXSwgbVJvdGF0aW9uQmFjaywgY3VycmVudC5nZXRMb2NhbFRyYW5zZm9ybSgpKSk7XG4gIG5leHRSZWN0LmFwcGx5VHJhbnNmb3JtKG1hdHJpeFV0aWwubXVsKFtdLCBtUm90YXRpb25CYWNrLCBuZXh0LmdldExvY2FsVHJhbnNmb3JtKCkpKTtcbiAgcmV0dXJuIGZpcnN0UmVjdC5pbnRlcnNlY3QobmV4dFJlY3QpO1xufVxuXG5mdW5jdGlvbiBpc05hbWVMb2NhdGlvbkNlbnRlcihuYW1lTG9jYXRpb24pIHtcbiAgcmV0dXJuIG5hbWVMb2NhdGlvbiA9PT0gJ21pZGRsZScgfHwgbmFtZUxvY2F0aW9uID09PSAnY2VudGVyJztcbn1cbi8qKlxuICogQHN0YXRpY1xuICovXG5cblxudmFyIGlmSWdub3JlT25UaWNrID0gQXhpc0J1aWxkZXIuaWZJZ25vcmVPblRpY2sgPSBmdW5jdGlvbiAoYXhpcywgaSwgaW50ZXJ2YWwsIHRpY2tzQ250LCBzaG93TWluTGFiZWwsIHNob3dNYXhMYWJlbCkge1xuICBpZiAoaSA9PT0gMCAmJiBzaG93TWluTGFiZWwgfHwgaSA9PT0gdGlja3NDbnQgLSAxICYmIHNob3dNYXhMYWJlbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBGSVhNRVxuICAvLyBIYXZlIG5vdCBjb25zaWRlciBsYWJlbCBvdmVybGFwIChpZiBsYWJlbCBpcyB0b28gbG9uZykgeWV0LlxuXG5cbiAgdmFyIHJhd1RpY2s7XG4gIHZhciBzY2FsZSA9IGF4aXMuc2NhbGU7XG4gIHJldHVybiBzY2FsZS50eXBlID09PSAnb3JkaW5hbCcgJiYgKHR5cGVvZiBpbnRlcnZhbCA9PT0gJ2Z1bmN0aW9uJyA/IChyYXdUaWNrID0gc2NhbGUuZ2V0VGlja3MoKVtpXSwgIWludGVydmFsKHJhd1RpY2ssIHNjYWxlLmdldExhYmVsKHJhd1RpY2spKSkgOiBpICUgKGludGVydmFsICsgMSkpO1xufTtcbi8qKlxuICogQHN0YXRpY1xuICovXG5cblxudmFyIGdldEludGVydmFsID0gQXhpc0J1aWxkZXIuZ2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAobW9kZWwsIGxhYmVsSW50ZXJ2YWwpIHtcbiAgdmFyIGludGVydmFsID0gbW9kZWwuZ2V0KCdpbnRlcnZhbCcpO1xuXG4gIGlmIChpbnRlcnZhbCA9PSBudWxsIHx8IGludGVydmFsID09ICdhdXRvJykge1xuICAgIGludGVydmFsID0gbGFiZWxJbnRlcnZhbDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcnZhbDtcbn07XG5cbmZ1bmN0aW9uIGJ1aWxkQXhpc1RpY2soYXhpc0J1aWxkZXIsIGF4aXNNb2RlbCwgb3B0KSB7XG4gIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG5cbiAgaWYgKCFheGlzTW9kZWwuZ2V0KCdheGlzVGljay5zaG93JykgfHwgYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGlja01vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzVGljaycpO1xuICB2YXIgbGluZVN0eWxlTW9kZWwgPSB0aWNrTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICB2YXIgdGlja0xlbiA9IHRpY2tNb2RlbC5nZXQoJ2xlbmd0aCcpO1xuICB2YXIgdGlja0ludGVydmFsID0gZ2V0SW50ZXJ2YWwodGlja01vZGVsLCBvcHQubGFiZWxJbnRlcnZhbCk7XG4gIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHModGlja01vZGVsLmdldCgnYWxpZ25XaXRoTGFiZWwnKSk7IC8vIEZJWE1FXG4gIC8vIENvcnJlc3BvbmRzIHRvIHRpY2tzQ29vcmRzID9cblxuICB2YXIgdGlja3MgPSBheGlzLnNjYWxlLmdldFRpY2tzKCk7XG4gIHZhciBzaG93TWluTGFiZWwgPSBheGlzTW9kZWwuZ2V0KCdheGlzTGFiZWwuc2hvd01pbkxhYmVsJyk7XG4gIHZhciBzaG93TWF4TGFiZWwgPSBheGlzTW9kZWwuZ2V0KCdheGlzTGFiZWwuc2hvd01heExhYmVsJyk7XG4gIHZhciBwdDEgPSBbXTtcbiAgdmFyIHB0MiA9IFtdO1xuICB2YXIgbWF0cml4ID0gYXhpc0J1aWxkZXIuX3RyYW5zZm9ybTtcbiAgdmFyIHRpY2tFbHMgPSBbXTtcbiAgdmFyIHRpY2tzQ250ID0gdGlja3NDb29yZHMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NDbnQ7IGkrKykge1xuICAgIC8vIE9ubHkgb3JkaW5hbCBzY2FsZSBzdXBwb3J0IHRpY2sgaW50ZXJ2YWxcbiAgICBpZiAoaWZJZ25vcmVPblRpY2soYXhpcywgaSwgdGlja0ludGVydmFsLCB0aWNrc0NudCwgc2hvd01pbkxhYmVsLCBzaG93TWF4TGFiZWwpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgdGlja0Nvb3JkID0gdGlja3NDb29yZHNbaV07XG4gICAgcHQxWzBdID0gdGlja0Nvb3JkO1xuICAgIHB0MVsxXSA9IDA7XG4gICAgcHQyWzBdID0gdGlja0Nvb3JkO1xuICAgIHB0MlsxXSA9IG9wdC50aWNrRGlyZWN0aW9uICogdGlja0xlbjtcblxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQxLCBwdDEsIG1hdHJpeCk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MiwgcHQyLCBtYXRyaXgpO1xuICAgIH0gLy8gVGljayBsaW5lLCBOb3QgdXNlIGdyb3VwIHRyYW5zZm9ybSB0byBoYXZlIGJldHRlciBsaW5lIGRyYXdcblxuXG4gICAgdmFyIHRpY2tFbCA9IG5ldyBncmFwaGljLkxpbmUoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG4gICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICBhbmlkOiAndGlja18nICsgdGlja3NbaV0sXG4gICAgICBzaGFwZToge1xuICAgICAgICB4MTogcHQxWzBdLFxuICAgICAgICB5MTogcHQxWzFdLFxuICAgICAgICB4MjogcHQyWzBdLFxuICAgICAgICB5MjogcHQyWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IGRlZmF1bHRzKGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpLCB7XG4gICAgICAgIHN0cm9rZTogYXhpc01vZGVsLmdldCgnYXhpc0xpbmUubGluZVN0eWxlLmNvbG9yJylcbiAgICAgIH0pLFxuICAgICAgejI6IDIsXG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KSk7XG4gICAgYXhpc0J1aWxkZXIuZ3JvdXAuYWRkKHRpY2tFbCk7XG4gICAgdGlja0Vscy5wdXNoKHRpY2tFbCk7XG4gIH1cblxuICByZXR1cm4gdGlja0Vscztcbn1cblxuZnVuY3Rpb24gYnVpbGRBeGlzTGFiZWwoYXhpc0J1aWxkZXIsIGF4aXNNb2RlbCwgb3B0KSB7XG4gIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gIHZhciBzaG93ID0gcmV0cmlldmUob3B0LmF4aXNMYWJlbFNob3csIGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93JykpO1xuXG4gIGlmICghc2hvdyB8fCBheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYWJlbE1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcbiAgdmFyIGxhYmVsTWFyZ2luID0gbGFiZWxNb2RlbC5nZXQoJ21hcmdpbicpO1xuICB2YXIgdGlja3MgPSBheGlzLnNjYWxlLmdldFRpY2tzKCk7XG4gIHZhciBsYWJlbHMgPSBheGlzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWxzKCk7IC8vIFNwZWNpYWwgbGFiZWwgcm90YXRlLlxuXG4gIHZhciBsYWJlbFJvdGF0aW9uID0gKHJldHJpZXZlKG9wdC5sYWJlbFJvdGF0ZSwgbGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpKSB8fCAwKSAqIFBJIC8gMTgwO1xuICB2YXIgbGFiZWxMYXlvdXQgPSBpbm5lclRleHRMYXlvdXQob3B0LnJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uLCBvcHQubGFiZWxEaXJlY3Rpb24pO1xuICB2YXIgY2F0ZWdvcnlEYXRhID0gYXhpc01vZGVsLmdldCgnZGF0YScpO1xuICB2YXIgbGFiZWxFbHMgPSBbXTtcbiAgdmFyIHNpbGVudCA9IGlzU2lsZW50KGF4aXNNb2RlbCk7XG4gIHZhciB0cmlnZ2VyRXZlbnQgPSBheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKTtcbiAgdmFyIHNob3dNaW5MYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWluTGFiZWwnKTtcbiAgdmFyIHNob3dNYXhMYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWF4TGFiZWwnKTtcbiAgZWFjaCh0aWNrcywgZnVuY3Rpb24gKHRpY2tWYWwsIGluZGV4KSB7XG4gICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGluZGV4LCBvcHQubGFiZWxJbnRlcnZhbCwgdGlja3MubGVuZ3RoLCBzaG93TWluTGFiZWwsIHNob3dNYXhMYWJlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlbUxhYmVsTW9kZWwgPSBsYWJlbE1vZGVsO1xuXG4gICAgaWYgKGNhdGVnb3J5RGF0YSAmJiBjYXRlZ29yeURhdGFbdGlja1ZhbF0gJiYgY2F0ZWdvcnlEYXRhW3RpY2tWYWxdLnRleHRTdHlsZSkge1xuICAgICAgaXRlbUxhYmVsTW9kZWwgPSBuZXcgTW9kZWwoY2F0ZWdvcnlEYXRhW3RpY2tWYWxdLnRleHRTdHlsZSwgbGFiZWxNb2RlbCwgYXhpc01vZGVsLmVjTW9kZWwpO1xuICAgIH1cblxuICAgIHZhciB0ZXh0Q29sb3IgPSBpdGVtTGFiZWxNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5saW5lU3R5bGUuY29sb3InKTtcbiAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy5kYXRhVG9Db29yZCh0aWNrVmFsKTtcbiAgICB2YXIgcG9zID0gW3RpY2tDb29yZCwgb3B0LmxhYmVsT2Zmc2V0ICsgb3B0LmxhYmVsRGlyZWN0aW9uICogbGFiZWxNYXJnaW5dO1xuICAgIHZhciBsYWJlbFN0ciA9IGF4aXMuc2NhbGUuZ2V0TGFiZWwodGlja1ZhbCk7XG4gICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgICAgYW5pZDogJ2xhYmVsXycgKyB0aWNrVmFsLFxuICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgIHJvdGF0aW9uOiBsYWJlbExheW91dC5yb3RhdGlvbixcbiAgICAgIHNpbGVudDogc2lsZW50LFxuICAgICAgejI6IDEwXG4gICAgfSk7XG4gICAgZ3JhcGhpYy5zZXRUZXh0U3R5bGUodGV4dEVsLnN0eWxlLCBpdGVtTGFiZWxNb2RlbCwge1xuICAgICAgdGV4dDogbGFiZWxzW2luZGV4XSxcbiAgICAgIHRleHRBbGlnbjogaXRlbUxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnYWxpZ24nLCB0cnVlKSB8fCBsYWJlbExheW91dC50ZXh0QWxpZ24sXG4gICAgICB0ZXh0VmVydGljYWxBbGlnbjogaXRlbUxhYmVsTW9kZWwuZ2V0U2hhbGxvdygndmVydGljYWxBbGlnbicsIHRydWUpIHx8IGl0ZW1MYWJlbE1vZGVsLmdldFNoYWxsb3coJ2Jhc2VsaW5lJywgdHJ1ZSkgfHwgbGFiZWxMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ24sXG4gICAgICB0ZXh0RmlsbDogdHlwZW9mIHRleHRDb2xvciA9PT0gJ2Z1bmN0aW9uJyA/IHRleHRDb2xvciggLy8gKDEpIEluIGNhdGVnb3J5IGF4aXMgd2l0aCBkYXRhIHpvb20sIHRpY2sgaXMgbm90IHRoZSBvcmlnaW5hbFxuICAgICAgLy8gaW5kZXggb2YgYXhpcy5kYXRhLiBTbyB0aWNrIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2VyXG4gICAgICAvLyBpbiBjYXRlZ29yeSBheGlzLlxuICAgICAgLy8gKDIpIENvbXBhdGlibGUgd2l0aCBwcmV2aW91cyB2ZXJzaW9uLCB3aGljaCBhbHdheXMgcmV0dXJucyBsYWJlbFN0ci5cbiAgICAgIC8vIEJ1dCBpbiBpbnRlcnZhbCBzY2FsZSBsYWJlbFN0ciBpcyBsaWtlICcyMjMsNDQ1Jywgd2hpY2ggbWFrZWRcbiAgICAgIC8vIHVzZXIgcmVwYWxjZSAnLCcuIFNvIHdlIG1vZGlmeSBpdCB0byByZXR1cm4gb3JpZ2luYWwgdmFsIGJ1dCByZW1haW5cbiAgICAgIC8vIGl0IGFzICdzdHJpbmcnIHRvIGF2b2lkIGVycm9yIGluIHJlcGxhY2luZy5cbiAgICAgIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IGxhYmVsU3RyIDogYXhpcy50eXBlID09PSAndmFsdWUnID8gdGlja1ZhbCArICcnIDogdGlja1ZhbCwgaW5kZXgpIDogdGV4dENvbG9yXG4gICAgfSk7IC8vIFBhY2sgZGF0YSBmb3IgbW91c2UgZXZlbnRcblxuICAgIGlmICh0cmlnZ2VyRXZlbnQpIHtcbiAgICAgIHRleHRFbC5ldmVudERhdGEgPSBtYWtlQXhpc0V2ZW50RGF0YUJhc2UoYXhpc01vZGVsKTtcbiAgICAgIHRleHRFbC5ldmVudERhdGEudGFyZ2V0VHlwZSA9ICdheGlzTGFiZWwnO1xuICAgICAgdGV4dEVsLmV2ZW50RGF0YS52YWx1ZSA9IGxhYmVsU3RyO1xuICAgIH0gLy8gRklYTUVcblxuXG4gICAgYXhpc0J1aWxkZXIuX2R1bWJHcm91cC5hZGQodGV4dEVsKTtcblxuICAgIHRleHRFbC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICBsYWJlbEVscy5wdXNoKHRleHRFbCk7XG4gICAgYXhpc0J1aWxkZXIuZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgdGV4dEVsLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICB9KTtcbiAgcmV0dXJuIGxhYmVsRWxzO1xufVxuXG52YXIgX2RlZmF1bHQgPSBBeGlzQnVpbGRlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc0J1aWxkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciBheGlzUG9pbnRlck1vZGVsSGVscGVyID0gcmVxdWlyZShcIi4uL2F4aXNQb2ludGVyL21vZGVsSGVscGVyXCIpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3Mgb2YgQXhpc1ZpZXcuXG4gKi9cbnZhciBBeGlzVmlldyA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG4gIHR5cGU6ICdheGlzJyxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9heGlzUG9pbnRlcjogbnVsbCxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgYXhpc1BvaW50ZXJDbGFzczogbnVsbCxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIC8vIEZJWE1FXG4gICAgLy8gVGhpcyBwcm9jZXNzIHNob3VsZCBwcm9mb3JtZWQgYWZ0ZXIgY29vcmRpbmF0ZSBzeXN0ZW1zIHVwZGF0ZWRcbiAgICAvLyAoYXhpcyBzY2FsZSB1cGRhdGVkKSwgYW5kIHNob3VsZCBiZSBwZXJmb3JtZWQgZWFjaCB0aW1lIHVwZGF0ZS5cbiAgICAvLyBTbyBwdXQgaXQgaGVyZSB0ZW1wb3JhcmlseSwgYWx0aG91Z2ggaXQgaXMgbm90IGFwcHJvcHJpYXRlIHRvXG4gICAgLy8gcHV0IGEgbW9kZWwtd3JpdGluZyBwcm9jZWR1cmUgaW4gYHZpZXdgLlxuICAgIHRoaXMuYXhpc1BvaW50ZXJDbGFzcyAmJiBheGlzUG9pbnRlck1vZGVsSGVscGVyLmZpeFZhbHVlKGF4aXNNb2RlbCk7XG4gICAgQXhpc1ZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVuZGVyJywgYXJndW1lbnRzKTtcbiAgICB1cGRhdGVBeGlzUG9pbnRlcih0aGlzLCBheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH0gYXhpc01vZGVsXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICovXG4gIHVwZGF0ZUF4aXNQb2ludGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIGZvcmNlKSB7XG4gICAgdXBkYXRlQXhpc1BvaW50ZXIodGhpcywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgYXhpc1BvaW50ZXIgPSB0aGlzLl9heGlzUG9pbnRlcjtcbiAgICBheGlzUG9pbnRlciAmJiBheGlzUG9pbnRlci5yZW1vdmUoYXBpKTtcbiAgICBBeGlzVmlldy5zdXBlckFwcGx5KHRoaXMsICdyZW1vdmUnLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBkaXNwb3NlQXhpc1BvaW50ZXIodGhpcywgYXBpKTtcbiAgICBBeGlzVmlldy5zdXBlckFwcGx5KHRoaXMsICdkaXNwb3NlJywgYXJndW1lbnRzKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZUF4aXNQb2ludGVyKGF4aXNWaWV3LCBheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgZm9yY2VSZW5kZXIpIHtcbiAgdmFyIENsYXp6ID0gQXhpc1ZpZXcuZ2V0QXhpc1BvaW50ZXJDbGFzcyhheGlzVmlldy5heGlzUG9pbnRlckNsYXNzKTtcblxuICBpZiAoIUNsYXp6KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmdldEF4aXNQb2ludGVyTW9kZWwoYXhpc01vZGVsKTtcbiAgYXhpc1BvaW50ZXJNb2RlbCA/IChheGlzVmlldy5fYXhpc1BvaW50ZXIgfHwgKGF4aXNWaWV3Ll9heGlzUG9pbnRlciA9IG5ldyBDbGF6eigpKSkucmVuZGVyKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpLCBmb3JjZVJlbmRlcikgOiBkaXNwb3NlQXhpc1BvaW50ZXIoYXhpc1ZpZXcsIGFwaSk7XG59XG5cbmZ1bmN0aW9uIGRpc3Bvc2VBeGlzUG9pbnRlcihheGlzVmlldywgZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBheGlzUG9pbnRlciA9IGF4aXNWaWV3Ll9heGlzUG9pbnRlcjtcbiAgYXhpc1BvaW50ZXIgJiYgYXhpc1BvaW50ZXIuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICBheGlzVmlldy5fYXhpc1BvaW50ZXIgPSBudWxsO1xufVxuXG52YXIgYXhpc1BvaW50ZXJDbGF6eiA9IFtdO1xuXG5BeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MgPSBmdW5jdGlvbiAodHlwZSwgY2xhenopIHtcbiAgYXhpc1BvaW50ZXJDbGF6elt0eXBlXSA9IGNsYXp6O1xufTtcblxuQXhpc1ZpZXcuZ2V0QXhpc1BvaW50ZXJDbGFzcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiB0eXBlICYmIGF4aXNQb2ludGVyQ2xhenpbdHlwZV07XG59O1xuXG52YXIgX2RlZmF1bHQgPSBBeGlzVmlldztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc1ZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQge2xhYmVsSW5zaWRlfVxuICogQHJldHVybiB7T2JqZWN0fSB7XG4gKiAgcG9zaXRpb24sIHJvdGF0aW9uLCBsYWJlbERpcmVjdGlvbiwgbGFiZWxPZmZzZXQsXG4gKiAgdGlja0RpcmVjdGlvbiwgbGFiZWxSb3RhdGUsIGxhYmVsSW50ZXJ2YWwsIHoyXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGxheW91dChncmlkTW9kZWwsIGF4aXNNb2RlbCwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgdmFyIGxheW91dCA9IHt9O1xuICB2YXIgcmF3QXhpc1Bvc2l0aW9uID0gYXhpcy5wb3NpdGlvbjtcbiAgdmFyIGF4aXNQb3NpdGlvbiA9IGF4aXMub25aZXJvID8gJ29uWmVybycgOiByYXdBeGlzUG9zaXRpb247XG4gIHZhciBheGlzRGltID0gYXhpcy5kaW07XG4gIHZhciByZWN0ID0gZ3JpZC5nZXRSZWN0KCk7XG4gIHZhciByZWN0Qm91bmQgPSBbcmVjdC54LCByZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnksIHJlY3QueSArIHJlY3QuaGVpZ2h0XTtcbiAgdmFyIGlkeCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAxLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDEsXG4gICAgb25aZXJvOiAyXG4gIH07XG4gIHZhciBheGlzT2Zmc2V0ID0gYXhpc01vZGVsLmdldCgnb2Zmc2V0JykgfHwgMDtcbiAgdmFyIHBvc0JvdW5kID0gYXhpc0RpbSA9PT0gJ3gnID8gW3JlY3RCb3VuZFsyXSAtIGF4aXNPZmZzZXQsIHJlY3RCb3VuZFszXSArIGF4aXNPZmZzZXRdIDogW3JlY3RCb3VuZFswXSAtIGF4aXNPZmZzZXQsIHJlY3RCb3VuZFsxXSArIGF4aXNPZmZzZXRdO1xuXG4gIGlmIChheGlzLm9uWmVybykge1xuICAgIHZhciBvdGhlckF4aXMgPSBncmlkLmdldEF4aXMoYXhpc0RpbSA9PT0gJ3gnID8gJ3knIDogJ3gnLCBheGlzLm9uWmVyb0F4aXNJbmRleCk7XG4gICAgdmFyIG9uWmVyb0Nvb3JkID0gb3RoZXJBeGlzLnRvR2xvYmFsQ29vcmQob3RoZXJBeGlzLmRhdGFUb0Nvb3JkKDApKTtcbiAgICBwb3NCb3VuZFtpZHhbJ29uWmVybyddXSA9IE1hdGgubWF4KE1hdGgubWluKG9uWmVyb0Nvb3JkLCBwb3NCb3VuZFsxXSksIHBvc0JvdW5kWzBdKTtcbiAgfSAvLyBBeGlzIHBvc2l0aW9uXG5cblxuICBsYXlvdXQucG9zaXRpb24gPSBbYXhpc0RpbSA9PT0gJ3knID8gcG9zQm91bmRbaWR4W2F4aXNQb3NpdGlvbl1dIDogcmVjdEJvdW5kWzBdLCBheGlzRGltID09PSAneCcgPyBwb3NCb3VuZFtpZHhbYXhpc1Bvc2l0aW9uXV0gOiByZWN0Qm91bmRbM11dOyAvLyBBeGlzIHJvdGF0aW9uXG5cbiAgbGF5b3V0LnJvdGF0aW9uID0gTWF0aC5QSSAvIDIgKiAoYXhpc0RpbSA9PT0gJ3gnID8gMCA6IDEpOyAvLyBUaWNrIGFuZCBsYWJlbCBkaXJlY3Rpb24sIHggeSBpcyBheGlzRGltXG5cbiAgdmFyIGRpck1hcCA9IHtcbiAgICB0b3A6IC0xLFxuICAgIGJvdHRvbTogMSxcbiAgICBsZWZ0OiAtMSxcbiAgICByaWdodDogMVxuICB9O1xuICBsYXlvdXQubGFiZWxEaXJlY3Rpb24gPSBsYXlvdXQudGlja0RpcmVjdGlvbiA9IGxheW91dC5uYW1lRGlyZWN0aW9uID0gZGlyTWFwW3Jhd0F4aXNQb3NpdGlvbl07XG4gIGxheW91dC5sYWJlbE9mZnNldCA9IGF4aXMub25aZXJvID8gcG9zQm91bmRbaWR4W3Jhd0F4aXNQb3NpdGlvbl1dIC0gcG9zQm91bmRbaWR4Wydvblplcm8nXV0gOiAwO1xuXG4gIGlmIChheGlzTW9kZWwuZ2V0KCdheGlzVGljay5pbnNpZGUnKSkge1xuICAgIGxheW91dC50aWNrRGlyZWN0aW9uID0gLWxheW91dC50aWNrRGlyZWN0aW9uO1xuICB9XG5cbiAgaWYgKHpyVXRpbC5yZXRyaWV2ZShvcHQubGFiZWxJbnNpZGUsIGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5pbnNpZGUnKSkpIHtcbiAgICBsYXlvdXQubGFiZWxEaXJlY3Rpb24gPSAtbGF5b3V0LmxhYmVsRGlyZWN0aW9uO1xuICB9IC8vIFNwZWNpYWwgbGFiZWwgcm90YXRpb25cblxuXG4gIHZhciBsYWJlbFJvdGF0ZSA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5yb3RhdGUnKTtcbiAgbGF5b3V0LmxhYmVsUm90YXRlID0gYXhpc1Bvc2l0aW9uID09PSAndG9wJyA/IC1sYWJlbFJvdGF0ZSA6IGxhYmVsUm90YXRlOyAvLyBsYWJlbCBpbnRlcnZhbCB3aGVuIGF1dG8gbW9kZS5cblxuICBsYXlvdXQubGFiZWxJbnRlcnZhbCA9IGF4aXMuZ2V0TGFiZWxJbnRlcnZhbCgpOyAvLyBPdmVyIHNwbGl0TGluZSBhbmQgc3BsaXRBcmVhXG5cbiAgbGF5b3V0LnoyID0gMTtcbiAgcmV0dXJuIGxheW91dDtcbn1cblxuZXhwb3J0cy5sYXlvdXQgPSBsYXlvdXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvY2FydGVzaWFuQXhpc0hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgU3ltYm9sQ2x6ID0gcmVxdWlyZShcIi4vU3ltYm9sXCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sRHJhd1xuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbERyYXdcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cH0gW3N5bWJvbEN0b3JdXG4gKi9cbmZ1bmN0aW9uIFN5bWJvbERyYXcoc3ltYm9sQ3Rvcikge1xuICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgdGhpcy5fc3ltYm9sQ3RvciA9IHN5bWJvbEN0b3IgfHwgU3ltYm9sQ2x6O1xufVxuXG52YXIgc3ltYm9sRHJhd1Byb3RvID0gU3ltYm9sRHJhdy5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIHN5bWJvbE5lZWRzRHJhdyhkYXRhLCBpZHgsIGlzSWdub3JlKSB7XG4gIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpOyAvLyBJcyBhbiBvYmplY3RcbiAgLy8gaWYgKHBvaW50ICYmIHBvaW50Lmhhc093blByb3BlcnR5KCdwb2ludCcpKSB7XG4gIC8vICAgICBwb2ludCA9IHBvaW50LnBvaW50O1xuICAvLyB9XG5cbiAgcmV0dXJuIHBvaW50ICYmICFpc05hTihwb2ludFswXSkgJiYgIWlzTmFOKHBvaW50WzFdKSAmJiAhKGlzSWdub3JlICYmIGlzSWdub3JlKGlkeCkpICYmIGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSAhPT0gJ25vbmUnO1xufVxuLyoqXG4gKiBVcGRhdGUgc3ltYm9scyBkcmF3IGJ5IG5ldyBkYXRhXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IFtpc0lnbm9yZV1cbiAqL1xuXG5cbnN5bWJvbERyYXdQcm90by51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIGlzSWdub3JlKSB7XG4gIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gIHZhciBTeW1ib2xDdG9yID0gdGhpcy5fc3ltYm9sQ3RvcjtcbiAgdmFyIHNlcmllc1Njb3BlID0ge1xuICAgIGl0ZW1TdHlsZTogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5ub3JtYWwnKS5nZXRJdGVtU3R5bGUoWydjb2xvciddKSxcbiAgICBob3Zlckl0ZW1TdHlsZTogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5lbXBoYXNpcycpLmdldEl0ZW1TdHlsZSgpLFxuICAgIHN5bWJvbFJvdGF0ZTogc2VyaWVzTW9kZWwuZ2V0KCdzeW1ib2xSb3RhdGUnKSxcbiAgICBzeW1ib2xPZmZzZXQ6IHNlcmllc01vZGVsLmdldCgnc3ltYm9sT2Zmc2V0JyksXG4gICAgaG92ZXJBbmltYXRpb246IHNlcmllc01vZGVsLmdldCgnaG92ZXJBbmltYXRpb24nKSxcbiAgICBsYWJlbE1vZGVsOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyksXG4gICAgaG92ZXJMYWJlbE1vZGVsOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKSxcbiAgICBjdXJzb3JTdHlsZTogc2VyaWVzTW9kZWwuZ2V0KCdjdXJzb3InKVxuICB9O1xuICBkYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChuZXdJZHgpIHtcbiAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcblxuICAgIGlmIChzeW1ib2xOZWVkc0RyYXcoZGF0YSwgbmV3SWR4LCBpc0lnbm9yZSkpIHtcbiAgICAgIHZhciBzeW1ib2xFbCA9IG5ldyBTeW1ib2xDdG9yKGRhdGEsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICAgICAgc3ltYm9sRWwuYXR0cigncG9zaXRpb24nLCBwb2ludCk7XG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBzeW1ib2xFbCk7XG4gICAgICBncm91cC5hZGQoc3ltYm9sRWwpO1xuICAgIH1cbiAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgIHZhciBzeW1ib2xFbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpO1xuXG4gICAgaWYgKCFzeW1ib2xOZWVkc0RyYXcoZGF0YSwgbmV3SWR4LCBpc0lnbm9yZSkpIHtcbiAgICAgIGdyb3VwLnJlbW92ZShzeW1ib2xFbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzeW1ib2xFbCkge1xuICAgICAgc3ltYm9sRWwgPSBuZXcgU3ltYm9sQ3RvcihkYXRhLCBuZXdJZHgpO1xuICAgICAgc3ltYm9sRWwuYXR0cigncG9zaXRpb24nLCBwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5bWJvbEVsLnVwZGF0ZURhdGEoZGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHN5bWJvbEVsLCB7XG4gICAgICAgIHBvc2l0aW9uOiBwb2ludFxuICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgIH0gLy8gQWRkIGJhY2tcblxuXG4gICAgZ3JvdXAuYWRkKHN5bWJvbEVsKTtcbiAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBzeW1ib2xFbCk7XG4gIH0pLnJlbW92ZShmdW5jdGlvbiAob2xkSWR4KSB7XG4gICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgZWwgJiYgZWwuZmFkZU91dChmdW5jdGlvbiAoKSB7XG4gICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgIH0pO1xuICB9KS5leGVjdXRlKCk7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xufTtcblxuc3ltYm9sRHJhd1Byb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gIGlmIChkYXRhKSB7XG4gICAgLy8gTm90IHVzZSBhbmltYXRpb25cbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgIGVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9pbnQpO1xuICAgIH0pO1xuICB9XG59O1xuXG5zeW1ib2xEcmF3UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGVuYWJsZUFuaW1hdGlvbikge1xuICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZW5hYmxlQW5pbWF0aW9uKSB7XG4gICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5mYWRlT3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfZGVmYXVsdCA9IFN5bWJvbERyYXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9zeW1ib2xcIik7XG5cbnZhciBjcmVhdGVTeW1ib2wgPSBfc3ltYm9sLmNyZWF0ZVN5bWJvbDtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIHBhcnNlUGVyY2VudCA9IF9udW1iZXIucGFyc2VQZXJjZW50O1xuXG52YXIgX2xhYmVsSGVscGVyID0gcmVxdWlyZShcIi4vbGFiZWxIZWxwZXJcIik7XG5cbnZhciBmaW5kTGFiZWxWYWx1ZURpbSA9IF9sYWJlbEhlbHBlci5maW5kTGFiZWxWYWx1ZURpbTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbFxuICovXG5mdW5jdGlvbiBnZXRTeW1ib2xTaXplKGRhdGEsIGlkeCkge1xuICB2YXIgc3ltYm9sU2l6ZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJyk7XG4gIHJldHVybiBzeW1ib2xTaXplIGluc3RhbmNlb2YgQXJyYXkgPyBzeW1ib2xTaXplLnNsaWNlKCkgOiBbK3N5bWJvbFNpemUsICtzeW1ib2xTaXplXTtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoc3ltYm9sU2l6ZSkge1xuICByZXR1cm4gW3N5bWJvbFNpemVbMF0gLyAyLCBzeW1ib2xTaXplWzFdIC8gMl07XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIHttb2R1bGU6ZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sfVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwfVxuICovXG5cblxuZnVuY3Rpb24gU3ltYm9sQ2x6KGRhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMpO1xuICB0aGlzLnVwZGF0ZURhdGEoZGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG59XG5cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbENsei5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGRyaWZ0U3ltYm9sKGR4LCBkeSkge1xuICB0aGlzLnBhcmVudC5kcmlmdChkeCwgZHkpO1xufVxuXG5zeW1ib2xQcm90by5fY3JlYXRlU3ltYm9sID0gZnVuY3Rpb24gKHN5bWJvbFR5cGUsIGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSkge1xuICAvLyBSZW1vdmUgcGF0aHMgY3JlYXRlZCBiZWZvcmVcbiAgdGhpcy5yZW1vdmVBbGwoKTtcbiAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7IC8vIHZhciBzeW1ib2xQYXRoID0gY3JlYXRlU3ltYm9sKFxuICAvLyAgICAgc3ltYm9sVHlwZSwgLTAuNSwgLTAuNSwgMSwgMSwgY29sb3JcbiAgLy8gKTtcbiAgLy8gSWYgd2lkdGgvaGVpZ2h0IGFyZSBzZXQgdG9vIHNtYWxsIChlLmcuLCBzZXQgdG8gMSkgb24gaW9zMTBcbiAgLy8gYW5kIG1hY09TIFNpZXJyYSwgYSBjaXJjbGUgc3Ryb2tlIGJlY29tZSBhIHJlY3QsIG5vIG1hdHRlciB3aGF0XG4gIC8vIHRoZSBzY2FsZSBpcyBzZXQuIFNvIHdlIHNldCB3aWR0aC9oZWlnaHQgYXMgMi4gU2VlICM0MTUwLlxuXG4gIHZhciBzeW1ib2xQYXRoID0gY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIC0xLCAtMSwgMiwgMiwgY29sb3IpO1xuICBzeW1ib2xQYXRoLmF0dHIoe1xuICAgIHoyOiAxMDAsXG4gICAgY3VsbGluZzogdHJ1ZSxcbiAgICBzY2FsZTogZ2V0U2NhbGUoc3ltYm9sU2l6ZSlcbiAgfSk7IC8vIFJld3JpdGUgZHJpZnQgbWV0aG9kXG5cbiAgc3ltYm9sUGF0aC5kcmlmdCA9IGRyaWZ0U3ltYm9sO1xuICB0aGlzLl9zeW1ib2xUeXBlID0gc3ltYm9sVHlwZTtcbiAgdGhpcy5hZGQoc3ltYm9sUGF0aCk7XG59O1xuLyoqXG4gKiBTdG9wIGFuaW1hdGlvblxuICogQHBhcmFtIHtib29sZWFufSB0b0xhc3RGcmFtZVxuICovXG5cblxuc3ltYm9sUHJvdG8uc3RvcFN5bWJvbEFuaW1hdGlvbiA9IGZ1bmN0aW9uICh0b0xhc3RGcmFtZSkge1xuICB0aGlzLmNoaWxkQXQoMCkuc3RvcEFuaW1hdGlvbih0b0xhc3RGcmFtZSk7XG59O1xuLyoqXG4gKiBGSVhNRTpcbiAqIENhdXRpb246IFRoaXMgbWV0aG9kIGJyZWFrcyB0aGUgZW5jYXBzdWxhdGlvbiBvZiB0aGlzIG1vZHVsZSxcbiAqIGJ1dCBpdCBpbmRlZWQgYnJpbmdzIGNvbnZlbmllbmNlLiBTbyBkbyBub3QgdXNlIHRoZSBtZXRob2RcbiAqIHVubGVzcyB5b3UgZGV0YWlsZWRseSBrbm93IGFsbCB0aGUgaW1wbGVtZW50cyBvZiBgU3ltYm9sYCxcbiAqIGVzcGVjaWFsbHkgYW5pbWF0aW9uLlxuICpcbiAqIEdldCBzeW1ib2wgcGF0aCBlbGVtZW50LlxuICovXG5cblxuc3ltYm9sUHJvdG8uZ2V0U3ltYm9sUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2hpbGRBdCgwKTtcbn07XG4vKipcbiAqIEdldCBzY2FsZShha2EsIGN1cnJlbnQgc3ltYm9sIHNpemUpLlxuICogSW5jbHVkaW5nIHRoZSBjaGFuZ2UgY2F1c2VkIGJ5IGFuaW1hdGlvblxuICovXG5cblxuc3ltYm9sUHJvdG8uZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNoaWxkQXQoMCkuc2NhbGU7XG59O1xuLyoqXG4gKiBIaWdobGlnaHQgc3ltYm9sXG4gKi9cblxuXG5zeW1ib2xQcm90by5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hpbGRBdCgwKS50cmlnZ2VyKCdlbXBoYXNpcycpO1xufTtcbi8qKlxuICogRG93bnBsYXkgc3ltYm9sXG4gKi9cblxuXG5zeW1ib2xQcm90by5kb3ducGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaGlsZEF0KDApLnRyaWdnZXIoJ25vcm1hbCcpO1xufTtcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICogQHBhcmFtIHtudW1iZXJ9IHpcbiAqL1xuXG5cbnN5bWJvbFByb3RvLnNldFogPSBmdW5jdGlvbiAoemxldmVsLCB6KSB7XG4gIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICBzeW1ib2xQYXRoLnpsZXZlbCA9IHpsZXZlbDtcbiAgc3ltYm9sUGF0aC56ID0gejtcbn07XG5cbnN5bWJvbFByb3RvLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChkcmFnZ2FibGUpIHtcbiAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gIHN5bWJvbFBhdGguZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICBzeW1ib2xQYXRoLmN1cnNvciA9IGRyYWdnYWJsZSA/ICdtb3ZlJyA6ICdwb2ludGVyJztcbn07XG4vKipcbiAqIFVwZGF0ZSBzeW1ib2wgcHJvcGVydGllc1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlLml0ZW1TdHlsZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGUuaG92ZXJJdGVtU3R5bGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlLnN5bWJvbFJvdGF0ZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGUuc3ltYm9sT2Zmc2V0XVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3Nlcmllc1Njb3BlLmxhYmVsTW9kZWxdXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbc2VyaWVzU2NvcGUuaG92ZXJMYWJlbE1vZGVsXVxuICogQHBhcmFtIHtib29sZWFufSBbc2VyaWVzU2NvcGUuaG92ZXJBbmltYXRpb25dXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nlcmllc1Njb3BlLmN1cnNvclN0eWxlXVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3Nlcmllc1Njb3BlLml0ZW1Nb2RlbF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2VyaWVzU2NvcGUuc3ltYm9sSW5uZXJDb2xvcl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VyaWVzU2NvcGUuZmFkZUluPWZhbHNlXVxuICovXG5cblxuc3ltYm9sUHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gIHRoaXMuc2lsZW50ID0gZmFsc2U7XG4gIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpIHx8ICdjaXJjbGUnO1xuICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgdmFyIHN5bWJvbFNpemUgPSBnZXRTeW1ib2xTaXplKGRhdGEsIGlkeCk7XG4gIHZhciBpc0luaXQgPSBzeW1ib2xUeXBlICE9PSB0aGlzLl9zeW1ib2xUeXBlO1xuXG4gIGlmIChpc0luaXQpIHtcbiAgICB0aGlzLl9jcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgZGF0YSwgaWR4LCBzeW1ib2xTaXplKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICBzeW1ib2xQYXRoLnNpbGVudCA9IGZhbHNlO1xuICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoc3ltYm9sUGF0aCwge1xuICAgICAgc2NhbGU6IGdldFNjYWxlKHN5bWJvbFNpemUpXG4gICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gIH1cblxuICB0aGlzLl91cGRhdGVDb21tb24oZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBzZXJpZXNTY29wZSk7XG5cbiAgaWYgKGlzSW5pdCkge1xuICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgIHZhciBmYWRlSW4gPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5mYWRlSW47XG4gICAgdmFyIHRhcmdldCA9IHtcbiAgICAgIHNjYWxlOiBzeW1ib2xQYXRoLnNjYWxlLnNsaWNlKClcbiAgICB9O1xuICAgIGZhZGVJbiAmJiAodGFyZ2V0LnN0eWxlID0ge1xuICAgICAgb3BhY2l0eTogc3ltYm9sUGF0aC5zdHlsZS5vcGFjaXR5XG4gICAgfSk7XG4gICAgc3ltYm9sUGF0aC5zY2FsZSA9IFswLCAwXTtcbiAgICBmYWRlSW4gJiYgKHN5bWJvbFBhdGguc3R5bGUub3BhY2l0eSA9IDApO1xuICAgIGdyYXBoaWMuaW5pdFByb3BzKHN5bWJvbFBhdGgsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gIH1cblxuICB0aGlzLl9zZXJpZXNNb2RlbCA9IHNlcmllc01vZGVsO1xufTsgLy8gVXBkYXRlIGNvbW1vbiBwcm9wZXJ0aWVzXG5cblxudmFyIG5vcm1hbFN0eWxlQWNjZXNzUGF0aCA9IFsnaXRlbVN0eWxlJywgJ25vcm1hbCddO1xudmFyIGVtcGhhc2lzU3R5bGVBY2Nlc3NQYXRoID0gWydpdGVtU3R5bGUnLCAnZW1waGFzaXMnXTtcbnZhciBub3JtYWxMYWJlbEFjY2Vzc1BhdGggPSBbJ2xhYmVsJywgJ25vcm1hbCddO1xudmFyIGVtcGhhc2lzTGFiZWxBY2Nlc3NQYXRoID0gWydsYWJlbCcsICdlbXBoYXNpcyddO1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc3ltYm9sU2l6ZVxuICogQHBhcmFtIHtPYmplY3R9IFtzZXJpZXNTY29wZV1cbiAqL1xuXG5zeW1ib2xQcm90by5fdXBkYXRlQ29tbW9uID0gZnVuY3Rpb24gKGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwgc2VyaWVzU2NvcGUpIHtcbiAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTsgLy8gUmVzZXQgc3R5bGVcblxuICBpZiAoc3ltYm9sUGF0aC50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgc3ltYm9sUGF0aC51c2VTdHlsZSh7XG4gICAgICBzdHJva2VOb1NjYWxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgaXRlbVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaXRlbVN0eWxlO1xuICB2YXIgaG92ZXJJdGVtU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5ob3Zlckl0ZW1TdHlsZTtcbiAgdmFyIHN5bWJvbFJvdGF0ZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLnN5bWJvbFJvdGF0ZTtcbiAgdmFyIHN5bWJvbE9mZnNldCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLnN5bWJvbE9mZnNldDtcbiAgdmFyIGxhYmVsTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5sYWJlbE1vZGVsO1xuICB2YXIgaG92ZXJMYWJlbE1vZGVsID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaG92ZXJMYWJlbE1vZGVsO1xuICB2YXIgaG92ZXJBbmltYXRpb24gPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5ob3ZlckFuaW1hdGlvbjtcbiAgdmFyIGN1cnNvclN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuY3Vyc29yU3R5bGU7XG5cbiAgaWYgKCFzZXJpZXNTY29wZSB8fCBkYXRhLmhhc0l0ZW1PcHRpb24pIHtcbiAgICB2YXIgaXRlbU1vZGVsID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaXRlbU1vZGVsID8gc2VyaWVzU2NvcGUuaXRlbU1vZGVsIDogZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTsgLy8gQ29sb3IgbXVzdCBiZSBleGNsdWRlZC5cbiAgICAvLyBCZWNhdXNlIHN5bWJvbCBwcm92aWRlIHNldENvbG9yIGluZGl2aWR1YWxseSB0byBzZXQgZmlsbCBhbmQgc3Ryb2tlXG5cbiAgICBpdGVtU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwobm9ybWFsU3R5bGVBY2Nlc3NQYXRoKS5nZXRJdGVtU3R5bGUoWydjb2xvciddKTtcbiAgICBob3Zlckl0ZW1TdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChlbXBoYXNpc1N0eWxlQWNjZXNzUGF0aCkuZ2V0SXRlbVN0eWxlKCk7XG4gICAgc3ltYm9sUm90YXRlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFJvdGF0ZScpO1xuICAgIHN5bWJvbE9mZnNldCA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xPZmZzZXQnKTtcbiAgICBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKG5vcm1hbExhYmVsQWNjZXNzUGF0aCk7XG4gICAgaG92ZXJMYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKGVtcGhhc2lzTGFiZWxBY2Nlc3NQYXRoKTtcbiAgICBob3ZlckFuaW1hdGlvbiA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdob3ZlckFuaW1hdGlvbicpO1xuICAgIGN1cnNvclN0eWxlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2N1cnNvcicpO1xuICB9IGVsc2Uge1xuICAgIGhvdmVySXRlbVN0eWxlID0genJVdGlsLmV4dGVuZCh7fSwgaG92ZXJJdGVtU3R5bGUpO1xuICB9XG5cbiAgdmFyIGVsU3R5bGUgPSBzeW1ib2xQYXRoLnN0eWxlO1xuICBzeW1ib2xQYXRoLmF0dHIoJ3JvdGF0aW9uJywgKHN5bWJvbFJvdGF0ZSB8fCAwKSAqIE1hdGguUEkgLyAxODAgfHwgMCk7XG5cbiAgaWYgKHN5bWJvbE9mZnNldCkge1xuICAgIHN5bWJvbFBhdGguYXR0cigncG9zaXRpb24nLCBbcGFyc2VQZXJjZW50KHN5bWJvbE9mZnNldFswXSwgc3ltYm9sU2l6ZVswXSksIHBhcnNlUGVyY2VudChzeW1ib2xPZmZzZXRbMV0sIHN5bWJvbFNpemVbMV0pXSk7XG4gIH1cblxuICBjdXJzb3JTdHlsZSAmJiBzeW1ib2xQYXRoLmF0dHIoJ2N1cnNvcicsIGN1cnNvclN0eWxlKTsgLy8gUEVORElORyBzZXRDb2xvciBiZWZvcmUgc2V0U3R5bGUhISFcblxuICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yLCBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5zeW1ib2xJbm5lckNvbG9yKTtcbiAgc3ltYm9sUGF0aC5zZXRTdHlsZShpdGVtU3R5bGUpO1xuICB2YXIgb3BhY2l0eSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdvcGFjaXR5Jyk7XG5cbiAgaWYgKG9wYWNpdHkgIT0gbnVsbCkge1xuICAgIGVsU3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG4gIH1cblxuICB2YXIgdXNlTmFtZUxhYmVsID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUudXNlTmFtZUxhYmVsO1xuICB2YXIgdmFsdWVEaW0gPSAhdXNlTmFtZUxhYmVsICYmIGZpbmRMYWJlbFZhbHVlRGltKGRhdGEpO1xuXG4gIGlmICh1c2VOYW1lTGFiZWwgfHwgdmFsdWVEaW0gIT0gbnVsbCkge1xuICAgIGdyYXBoaWMuc2V0TGFiZWxTdHlsZShlbFN0eWxlLCBob3Zlckl0ZW1TdHlsZSwgbGFiZWxNb2RlbCwgaG92ZXJMYWJlbE1vZGVsLCB7XG4gICAgICBsYWJlbEZldGNoZXI6IHNlcmllc01vZGVsLFxuICAgICAgbGFiZWxEYXRhSW5kZXg6IGlkeCxcbiAgICAgIGRlZmF1bHRUZXh0OiB1c2VOYW1lTGFiZWwgPyBkYXRhLmdldE5hbWUoaWR4KSA6IGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpLFxuICAgICAgaXNSZWN0VGV4dDogdHJ1ZSxcbiAgICAgIGF1dG9Db2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxuXG4gIHN5bWJvbFBhdGgub2ZmKCdtb3VzZW92ZXInKS5vZmYoJ21vdXNlb3V0Jykub2ZmKCdlbXBoYXNpcycpLm9mZignbm9ybWFsJyk7XG4gIHN5bWJvbFBhdGguaG92ZXJTdHlsZSA9IGhvdmVySXRlbVN0eWxlOyAvLyBGSVhNRVxuICAvLyBEbyBub3QgdXNlIHN5bWJvbC50cmlnZ2VyKCdlbXBoYXNpcycpLCBidXQgdXNlIHN5bWJvbC5oaWdobGlnaHQoKSBpbnN0ZWFkLlxuXG4gIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShzeW1ib2xQYXRoKTtcbiAgdmFyIHNjYWxlID0gZ2V0U2NhbGUoc3ltYm9sU2l6ZSk7XG5cbiAgaWYgKGhvdmVyQW5pbWF0aW9uICYmIHNlcmllc01vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpKSB7XG4gICAgdmFyIG9uRW1waGFzaXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmF0aW8gPSBzY2FsZVsxXSAvIHNjYWxlWzBdO1xuICAgICAgdGhpcy5hbmltYXRlVG8oe1xuICAgICAgICBzY2FsZTogW01hdGgubWF4KHNjYWxlWzBdICogMS4xLCBzY2FsZVswXSArIDMpLCBNYXRoLm1heChzY2FsZVsxXSAqIDEuMSwgc2NhbGVbMV0gKyAzICogcmF0aW8pXVxuICAgICAgfSwgNDAwLCAnZWxhc3RpY091dCcpO1xuICAgIH07XG5cbiAgICB2YXIgb25Ob3JtYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmFuaW1hdGVUbyh7XG4gICAgICAgIHNjYWxlOiBzY2FsZVxuICAgICAgfSwgNDAwLCAnZWxhc3RpY091dCcpO1xuICAgIH07XG5cbiAgICBzeW1ib2xQYXRoLm9uKCdtb3VzZW92ZXInLCBvbkVtcGhhc2lzKS5vbignbW91c2VvdXQnLCBvbk5vcm1hbCkub24oJ2VtcGhhc2lzJywgb25FbXBoYXNpcykub24oJ25vcm1hbCcsIG9uTm9ybWFsKTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQua2VlcExhYmVsPXRydWVdXG4gKi9cblxuXG5zeW1ib2xQcm90by5mYWRlT3V0ID0gZnVuY3Rpb24gKGNiLCBvcHQpIHtcbiAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7IC8vIEF2b2lkIG1pc3Rha2VuIGhvdmVyIHdoZW4gZmFkaW5nIG91dFxuXG4gIHRoaXMuc2lsZW50ID0gc3ltYm9sUGF0aC5zaWxlbnQgPSB0cnVlOyAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG5cbiAgIShvcHQgJiYgb3B0LmtlZXBMYWJlbCkgJiYgKHN5bWJvbFBhdGguc3R5bGUudGV4dCA9IG51bGwpO1xuICBncmFwaGljLnVwZGF0ZVByb3BzKHN5bWJvbFBhdGgsIHtcbiAgICBzdHlsZToge1xuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG4gICAgc2NhbGU6IFswLCAwXVxuICB9LCB0aGlzLl9zZXJpZXNNb2RlbCwgdGhpcy5kYXRhSW5kZXgsIGNiKTtcbn07XG5cbnpyVXRpbC5pbmhlcml0cyhTeW1ib2xDbHosIGdyYXBoaWMuR3JvdXApO1xudmFyIF9kZWZhdWx0ID0gU3ltYm9sQ2x6O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaW5kZXIgY29udGFpbnMge3Nlcmllc0luZGV4LCBkYXRhSW5kZXgsIGRhdGFJbmRleEluc2lkZX1cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcmV0dXJuIHtPYmplY3R9IHtwb2ludDogW3gsIHldLCBlbDogLi4ufSBwb2ludCBXaWxsIG5vdCBiZSBudWxsLlxuICovXG5mdW5jdGlvbiBfZGVmYXVsdChmaW5kZXIsIGVjTW9kZWwpIHtcbiAgdmFyIHBvaW50ID0gW107XG4gIHZhciBzZXJpZXNJbmRleCA9IGZpbmRlci5zZXJpZXNJbmRleDtcbiAgdmFyIHNlcmllc01vZGVsO1xuXG4gIGlmIChzZXJpZXNJbmRleCA9PSBudWxsIHx8ICEoc2VyaWVzTW9kZWwgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoc2VyaWVzSW5kZXgpKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludDogW11cbiAgICB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgZmluZGVyKTtcblxuICBpZiAoZGF0YUluZGV4ID09IG51bGwgfHwgenJVdGlsLmlzQXJyYXkoZGF0YUluZGV4KSkge1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludDogW11cbiAgICB9O1xuICB9XG5cbiAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgaWYgKHNlcmllc01vZGVsLmdldFRvb2x0aXBQb3NpdGlvbikge1xuICAgIHBvaW50ID0gc2VyaWVzTW9kZWwuZ2V0VG9vbHRpcFBvc2l0aW9uKGRhdGFJbmRleCkgfHwgW107XG4gIH0gZWxzZSBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMuZGF0YVRvUG9pbnQpIHtcbiAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KGRhdGEuZ2V0VmFsdWVzKHpyVXRpbC5tYXAoY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgcmV0dXJuIHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGRpbSlbMF07XG4gICAgfSksIGRhdGFJbmRleCwgdHJ1ZSkpIHx8IFtdO1xuICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgLy8gVXNlIGdyYXBoaWMgYm91bmRpbmcgcmVjdFxuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICByZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG4gICAgcG9pbnQgPSBbcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMl07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvaW50OiBwb2ludCxcbiAgICBlbDogZWxcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZmluZFBvaW50RnJvbVNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGdldCA9IG1vZGVsVXRpbC5tYWtlR2V0dGVyKCk7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKiAgICAgIHBhcmFtOiB7c3RyaW5nfSBjdXJyVHJpZ2dlclxuICogICAgICBwYXJhbToge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICovXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKGtleSwgYXBpLCBoYW5kbGVyKSB7XG4gIGlmIChlbnYubm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICBnZXQoenIpLnJlY29yZHMgfHwgKGdldCh6cikucmVjb3JkcyA9IHt9KTtcbiAgaW5pdEdsb2JhbExpc3RlbmVycyh6ciwgYXBpKTtcbiAgdmFyIHJlY29yZCA9IGdldCh6cikucmVjb3Jkc1trZXldIHx8IChnZXQoenIpLnJlY29yZHNba2V5XSA9IHt9KTtcbiAgcmVjb3JkLmhhbmRsZXIgPSBoYW5kbGVyO1xufVxuXG5mdW5jdGlvbiBpbml0R2xvYmFsTGlzdGVuZXJzKHpyLCBhcGkpIHtcbiAgaWYgKGdldCh6cikuaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBnZXQoenIpLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgdXNlSGFuZGxlcignY2xpY2snLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ2NsaWNrJykpO1xuICB1c2VIYW5kbGVyKCdtb3VzZW1vdmUnLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ21vdXNlbW92ZScpKTsgLy8gdXNlSGFuZGxlcignbW91c2VvdXQnLCBvbkxlYXZlKTtcblxuICB1c2VIYW5kbGVyKCdnbG9iYWxvdXQnLCBvbkxlYXZlKTtcblxuICBmdW5jdGlvbiB1c2VIYW5kbGVyKGV2ZW50VHlwZSwgY2IpIHtcbiAgICB6ci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZGlzID0gbWFrZURpc3BhdGNoQWN0aW9uKGFwaSk7XG4gICAgICBlYWNoKGdldCh6cikucmVjb3JkcywgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICByZWNvcmQgJiYgY2IocmVjb3JkLCBlLCBkaXMuZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICBkaXNwYXRjaFRvb2x0aXBGaW5hbGx5KGRpcy5wZW5kaW5ncywgYXBpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFRvb2x0aXBGaW5hbGx5KHBlbmRpbmdzLCBhcGkpIHtcbiAgdmFyIHNob3dMZW4gPSBwZW5kaW5ncy5zaG93VGlwLmxlbmd0aDtcbiAgdmFyIGhpZGVMZW4gPSBwZW5kaW5ncy5oaWRlVGlwLmxlbmd0aDtcbiAgdmFyIGFjdHVhbGx5UGF5bG9hZDtcblxuICBpZiAoc2hvd0xlbikge1xuICAgIGFjdHVhbGx5UGF5bG9hZCA9IHBlbmRpbmdzLnNob3dUaXBbc2hvd0xlbiAtIDFdO1xuICB9IGVsc2UgaWYgKGhpZGVMZW4pIHtcbiAgICBhY3R1YWxseVBheWxvYWQgPSBwZW5kaW5ncy5oaWRlVGlwW2hpZGVMZW4gLSAxXTtcbiAgfVxuXG4gIGlmIChhY3R1YWxseVBheWxvYWQpIHtcbiAgICBhY3R1YWxseVBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gPSBudWxsO1xuICAgIGFwaS5kaXNwYXRjaEFjdGlvbihhY3R1YWxseVBheWxvYWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uTGVhdmUocmVjb3JkLCBlLCBkaXNwYXRjaEFjdGlvbikge1xuICByZWNvcmQuaGFuZGxlcignbGVhdmUnLCBudWxsLCBkaXNwYXRjaEFjdGlvbik7XG59XG5cbmZ1bmN0aW9uIGRvRW50ZXIoY3VyclRyaWdnZXIsIHJlY29yZCwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgcmVjb3JkLmhhbmRsZXIoY3VyclRyaWdnZXIsIGUsIGRpc3BhdGNoQWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gbWFrZURpc3BhdGNoQWN0aW9uKGFwaSkge1xuICB2YXIgcGVuZGluZ3MgPSB7XG4gICAgc2hvd1RpcDogW10sXG4gICAgaGlkZVRpcDogW11cbiAgfTsgLy8gRklYTUVcbiAgLy8gYmV0dGVyIGFwcHJvYWNoP1xuICAvLyAnc2hvd1RpcCcgYW5kICdoaWRlVGlwJyBjYW4gYmUgdHJpZ2dlcmVkIGJ5IGF4aXNQb2ludGVyIGFuZCB0b29sdGlwLFxuICAvLyB3aGljaCBtYXkgYmUgY29uZmxpY3QsIChheGlzUG9pbnRlciBjYWxsIHNob3dUaXAgYnV0IHRvb2x0aXAgY2FsbCBoaWRlVGlwKTtcbiAgLy8gU28gd2UgaGF2ZSB0byBhZGQgXCJmaW5hbCBzdGFnZVwiIHRvIG1lcmdlIHRob3NlIGRpc3BhdGNoZWQgYWN0aW9ucy5cblxuICB2YXIgZGlzcGF0Y2hBY3Rpb24gPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIHZhciBwZW5kaW5nTGlzdCA9IHBlbmRpbmdzW3BheWxvYWQudHlwZV07XG5cbiAgICBpZiAocGVuZGluZ0xpc3QpIHtcbiAgICAgIHBlbmRpbmdMaXN0LnB1c2gocGF5bG9hZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gPSBkaXNwYXRjaEFjdGlvbjtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbihwYXlsb2FkKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBkaXNwYXRjaEFjdGlvbjogZGlzcGF0Y2hBY3Rpb24sXG4gICAgcGVuZGluZ3M6IHBlbmRpbmdzXG4gIH07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqL1xuXG5cbmZ1bmN0aW9uIHVucmVnaXN0ZXIoa2V5LCBhcGkpIHtcbiAgaWYgKGVudi5ub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gIHZhciByZWNvcmQgPSAoZ2V0KHpyKS5yZWNvcmRzIHx8IHt9KVtrZXldO1xuXG4gIGlmIChyZWNvcmQpIHtcbiAgICBnZXQoenIpLnJlY29yZHNba2V5XSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZXhwb3J0cy51bnJlZ2lzdGVyID0gdW5yZWdpc3RlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluL3RleHRcIik7XG5cbnZhciBmb3JtYXRVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZm9ybWF0XCIpO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoXCIuLi8uLi9jb29yZC9heGlzSGVscGVyXCIpO1xuXG52YXIgQXhpc0J1aWxkZXIgPSByZXF1aXJlKFwiLi4vYXhpcy9BeGlzQnVpbGRlclwiKTtcblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzUG9pbnRlck1vZGVsXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRWxTdHlsZShheGlzUG9pbnRlck1vZGVsKSB7XG4gIHZhciBheGlzUG9pbnRlclR5cGUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndHlwZScpO1xuICB2YXIgc3R5bGVNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0TW9kZWwoYXhpc1BvaW50ZXJUeXBlICsgJ1N0eWxlJyk7XG4gIHZhciBzdHlsZTtcblxuICBpZiAoYXhpc1BvaW50ZXJUeXBlID09PSAnbGluZScpIHtcbiAgICBzdHlsZSA9IHN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgc3R5bGUuZmlsbCA9IG51bGw7XG4gIH0gZWxzZSBpZiAoYXhpc1BvaW50ZXJUeXBlID09PSAnc2hhZG93Jykge1xuICAgIHN0eWxlID0gc3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKTtcbiAgICBzdHlsZS5zdHJva2UgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsYWJlbFBvcyB7YWxpZ24sIHZlcnRpY2FsQWxpZ24sIHBvc2l0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gYnVpbGRMYWJlbEVsT3B0aW9uKGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwgbGFiZWxQb3MpIHtcbiAgdmFyIHZhbHVlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3ZhbHVlJyk7XG4gIHZhciB0ZXh0ID0gZ2V0VmFsdWVMYWJlbCh2YWx1ZSwgYXhpc01vZGVsLmF4aXMsIGF4aXNNb2RlbC5lY01vZGVsLCBheGlzUG9pbnRlck1vZGVsLmdldCgnc2VyaWVzRGF0YUluZGljZXMnKSwge1xuICAgIHByZWNpc2lvbjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLnByZWNpc2lvbicpLFxuICAgIGZvcm1hdHRlcjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLmZvcm1hdHRlcicpXG4gIH0pO1xuICB2YXIgbGFiZWxNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsJyk7XG4gIHZhciBwYWRkaW5ncyA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkobGFiZWxNb2RlbC5nZXQoJ3BhZGRpbmcnKSB8fCAwKTtcbiAgdmFyIGZvbnQgPSBsYWJlbE1vZGVsLmdldEZvbnQoKTtcbiAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQpO1xuICB2YXIgcG9zaXRpb24gPSBsYWJlbFBvcy5wb3NpdGlvbjtcbiAgdmFyIHdpZHRoID0gdGV4dFJlY3Qud2lkdGggKyBwYWRkaW5nc1sxXSArIHBhZGRpbmdzWzNdO1xuICB2YXIgaGVpZ2h0ID0gdGV4dFJlY3QuaGVpZ2h0ICsgcGFkZGluZ3NbMF0gKyBwYWRkaW5nc1syXTsgLy8gQWRqdXN0IGJ5IGFsaWduLlxuXG4gIHZhciBhbGlnbiA9IGxhYmVsUG9zLmFsaWduO1xuICBhbGlnbiA9PT0gJ3JpZ2h0JyAmJiAocG9zaXRpb25bMF0gLT0gd2lkdGgpO1xuICBhbGlnbiA9PT0gJ2NlbnRlcicgJiYgKHBvc2l0aW9uWzBdIC09IHdpZHRoIC8gMik7XG4gIHZhciB2ZXJ0aWNhbEFsaWduID0gbGFiZWxQb3MudmVydGljYWxBbGlnbjtcbiAgdmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScgJiYgKHBvc2l0aW9uWzFdIC09IGhlaWdodCk7XG4gIHZlcnRpY2FsQWxpZ24gPT09ICdtaWRkbGUnICYmIChwb3NpdGlvblsxXSAtPSBoZWlnaHQgLyAyKTsgLy8gTm90IG92ZXJmbG93IGVjIGNvbnRhaW5lclxuXG4gIGNvbmZpbmVJbkNvbnRhaW5lcihwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCwgYXBpKTtcbiAgdmFyIGJnQ29sb3IgPSBsYWJlbE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG5cbiAgaWYgKCFiZ0NvbG9yIHx8IGJnQ29sb3IgPT09ICdhdXRvJykge1xuICAgIGJnQ29sb3IgPSBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5saW5lU3R5bGUuY29sb3InKTtcbiAgfVxuXG4gIGVsT3B0aW9uLmxhYmVsID0ge1xuICAgIHNoYXBlOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgcjogbGFiZWxNb2RlbC5nZXQoJ2JvcmRlclJhZGl1cycpXG4gICAgfSxcbiAgICBwb3NpdGlvbjogcG9zaXRpb24uc2xpY2UoKSxcbiAgICAvLyBUT0RPOiByaWNoXG4gICAgc3R5bGU6IHtcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICB0ZXh0Rm9udDogZm9udCxcbiAgICAgIHRleHRGaWxsOiBsYWJlbE1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcbiAgICAgIGZpbGw6IGJnQ29sb3IsXG4gICAgICBzdHJva2U6IGxhYmVsTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpIHx8ICd0cmFuc3BhcmVudCcsXG4gICAgICBsaW5lV2lkdGg6IGxhYmVsTW9kZWwuZ2V0KCdib3JkZXJXaWR0aCcpIHx8IDAsXG4gICAgICBzaGFkb3dCbHVyOiBsYWJlbE1vZGVsLmdldCgnc2hhZG93Qmx1cicpLFxuICAgICAgc2hhZG93Q29sb3I6IGxhYmVsTW9kZWwuZ2V0KCdzaGFkb3dDb2xvcicpLFxuICAgICAgc2hhZG93T2Zmc2V0WDogbGFiZWxNb2RlbC5nZXQoJ3NoYWRvd09mZnNldFgnKSxcbiAgICAgIHNoYWRvd09mZnNldFk6IGxhYmVsTW9kZWwuZ2V0KCdzaGFkb3dPZmZzZXRZJylcbiAgICB9LFxuICAgIC8vIExhYmxlIHNob3VsZCBiZSBvdmVyIGF4aXNQb2ludGVyLlxuICAgIHoyOiAxMFxuICB9O1xufSAvLyBEbyBub3Qgb3ZlcmZsb3cgZWMgY29udGFpbmVyXG5cblxuZnVuY3Rpb24gY29uZmluZUluQ29udGFpbmVyKHBvc2l0aW9uLCB3aWR0aCwgaGVpZ2h0LCBhcGkpIHtcbiAgdmFyIHZpZXdXaWR0aCA9IGFwaS5nZXRXaWR0aCgpO1xuICB2YXIgdmlld0hlaWdodCA9IGFwaS5nZXRIZWlnaHQoKTtcbiAgcG9zaXRpb25bMF0gPSBNYXRoLm1pbihwb3NpdGlvblswXSArIHdpZHRoLCB2aWV3V2lkdGgpIC0gd2lkdGg7XG4gIHBvc2l0aW9uWzFdID0gTWF0aC5taW4ocG9zaXRpb25bMV0gKyBoZWlnaHQsIHZpZXdIZWlnaHQpIC0gaGVpZ2h0O1xuICBwb3NpdGlvblswXSA9IE1hdGgubWF4KHBvc2l0aW9uWzBdLCAwKTtcbiAgcG9zaXRpb25bMV0gPSBNYXRoLm1heChwb3NpdGlvblsxXSwgMCk7XG59XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBheGlzXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gc2VyaWVzRGF0YUluZGljZXNcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gb3B0LnByZWNpc2lvbiAnYXV0bycgb3IgYSBudW1iZXJcbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBvcHQuZm9ybWF0dGVyIGxhYmVsIGZvcm1hdHRlclxuICovXG5cblxuZnVuY3Rpb24gZ2V0VmFsdWVMYWJlbCh2YWx1ZSwgYXhpcywgZWNNb2RlbCwgc2VyaWVzRGF0YUluZGljZXMsIG9wdCkge1xuICB2YXIgdGV4dCA9IGF4aXMuc2NhbGUuZ2V0TGFiZWwoIC8vIElmIGBwcmVjaXNpb25gIGlzIHNldCwgd2lkdGggY2FuIGJlIGZpeGVkIChsaWtlICcxMi4wMDUwMCcpLCB3aGljaFxuICAvLyBoZWxwcyB0byBkZWJvdW5jZSB3aGVuIHdoZW4gbW92aW5nIGxhYmVsLlxuICB2YWx1ZSwge1xuICAgIHByZWNpc2lvbjogb3B0LnByZWNpc2lvblxuICB9KTtcbiAgdmFyIGZvcm1hdHRlciA9IG9wdC5mb3JtYXR0ZXI7XG5cbiAgaWYgKGZvcm1hdHRlcikge1xuICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICB2YWx1ZTogYXhpc0hlbHBlci5nZXRBeGlzUmF3VmFsdWUoYXhpcywgdmFsdWUpLFxuICAgICAgc2VyaWVzRGF0YTogW11cbiAgICB9O1xuICAgIHpyVXRpbC5lYWNoKHNlcmllc0RhdGFJbmRpY2VzLCBmdW5jdGlvbiAoaWR4SXRlbSkge1xuICAgICAgdmFyIHNlcmllcyA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChpZHhJdGVtLnNlcmllc0luZGV4KTtcbiAgICAgIHZhciBkYXRhSW5kZXggPSBpZHhJdGVtLmRhdGFJbmRleEluc2lkZTtcbiAgICAgIHZhciBkYXRhUGFyYW1zID0gc2VyaWVzICYmIHNlcmllcy5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCk7XG4gICAgICBkYXRhUGFyYW1zICYmIHBhcmFtcy5zZXJpZXNEYXRhLnB1c2goZGF0YVBhcmFtcyk7XG4gICAgfSk7XG5cbiAgICBpZiAoenJVdGlsLmlzU3RyaW5nKGZvcm1hdHRlcikpIHtcbiAgICAgIHRleHQgPSBmb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIHRleHQpO1xuICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzRnVuY3Rpb24oZm9ybWF0dGVyKSkge1xuICAgICAgdGV4dCA9IGZvcm1hdHRlcihwYXJhbXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0ZXh0O1xufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0F4aXN9IGF4aXNcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGxheW91dEluZm8ge1xuICogIHJvdGF0aW9uLCBwb3NpdGlvbiwgbGFiZWxPZmZzZXQsIGxhYmVsRGlyZWN0aW9uLCBsYWJlbE1hcmdpblxuICogfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbihheGlzLCB2YWx1ZSwgbGF5b3V0SW5mbykge1xuICB2YXIgdHJhbnNmb3JtID0gbWF0cml4LmNyZWF0ZSgpO1xuICBtYXRyaXgucm90YXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBsYXlvdXRJbmZvLnJvdGF0aW9uKTtcbiAgbWF0cml4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgbGF5b3V0SW5mby5wb3NpdGlvbik7XG4gIHJldHVybiBncmFwaGljLmFwcGx5VHJhbnNmb3JtKFtheGlzLmRhdGFUb0Nvb3JkKHZhbHVlKSwgKGxheW91dEluZm8ubGFiZWxPZmZzZXQgfHwgMCkgKyAobGF5b3V0SW5mby5sYWJlbERpcmVjdGlvbiB8fCAxKSAqIChsYXlvdXRJbmZvLmxhYmVsTWFyZ2luIHx8IDApXSwgdHJhbnNmb3JtKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRDYXJ0ZXNpYW5TaW5nbGVMYWJlbEVsT3B0aW9uKHZhbHVlLCBlbE9wdGlvbiwgbGF5b3V0SW5mbywgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGkpIHtcbiAgdmFyIHRleHRMYXlvdXQgPSBBeGlzQnVpbGRlci5pbm5lclRleHRMYXlvdXQobGF5b3V0SW5mby5yb3RhdGlvbiwgMCwgbGF5b3V0SW5mby5sYWJlbERpcmVjdGlvbik7XG4gIGxheW91dEluZm8ubGFiZWxNYXJnaW4gPSBheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwubWFyZ2luJyk7XG4gIGJ1aWxkTGFiZWxFbE9wdGlvbihlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIHtcbiAgICBwb3NpdGlvbjogZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbihheGlzTW9kZWwuYXhpcywgdmFsdWUsIGxheW91dEluZm8pLFxuICAgIGFsaWduOiB0ZXh0TGF5b3V0LnRleHRBbGlnbixcbiAgICB2ZXJ0aWNhbEFsaWduOiB0ZXh0TGF5b3V0LnRleHRWZXJ0aWNhbEFsaWduXG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwMVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcDJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeERpbUluZGV4PTBdIG9yIDFcbiAqL1xuXG5cbmZ1bmN0aW9uIG1ha2VMaW5lU2hhcGUocDEsIHAyLCB4RGltSW5kZXgpIHtcbiAgeERpbUluZGV4ID0geERpbUluZGV4IHx8IDA7XG4gIHJldHVybiB7XG4gICAgeDE6IHAxW3hEaW1JbmRleF0sXG4gICAgeTE6IHAxWzEgLSB4RGltSW5kZXhdLFxuICAgIHgyOiBwMlt4RGltSW5kZXhdLFxuICAgIHkyOiBwMlsxIC0geERpbUluZGV4XVxuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB4eVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gd2hcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeERpbUluZGV4PTBdIG9yIDFcbiAqL1xuXG5cbmZ1bmN0aW9uIG1ha2VSZWN0U2hhcGUoeHksIHdoLCB4RGltSW5kZXgpIHtcbiAgeERpbUluZGV4ID0geERpbUluZGV4IHx8IDA7XG4gIHJldHVybiB7XG4gICAgeDogeHlbeERpbUluZGV4XSxcbiAgICB5OiB4eVsxIC0geERpbUluZGV4XSxcbiAgICB3aWR0aDogd2hbeERpbUluZGV4XSxcbiAgICBoZWlnaHQ6IHdoWzEgLSB4RGltSW5kZXhdXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VTZWN0b3JTaGFwZShjeCwgY3ksIHIwLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICByZXR1cm4ge1xuICAgIGN4OiBjeCxcbiAgICBjeTogY3ksXG4gICAgcjA6IHIwLFxuICAgIHI6IHIsXG4gICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgY2xvY2t3aXNlOiB0cnVlXG4gIH07XG59XG5cbmV4cG9ydHMuYnVpbGRFbFN0eWxlID0gYnVpbGRFbFN0eWxlO1xuZXhwb3J0cy5idWlsZExhYmVsRWxPcHRpb24gPSBidWlsZExhYmVsRWxPcHRpb247XG5leHBvcnRzLmdldFZhbHVlTGFiZWwgPSBnZXRWYWx1ZUxhYmVsO1xuZXhwb3J0cy5nZXRUcmFuc2Zvcm1lZFBvc2l0aW9uID0gZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbjtcbmV4cG9ydHMuYnVpbGRDYXJ0ZXNpYW5TaW5nbGVMYWJlbEVsT3B0aW9uID0gYnVpbGRDYXJ0ZXNpYW5TaW5nbGVMYWJlbEVsT3B0aW9uO1xuZXhwb3J0cy5tYWtlTGluZVNoYXBlID0gbWFrZUxpbmVTaGFwZTtcbmV4cG9ydHMubWFrZVJlY3RTaGFwZSA9IG1ha2VSZWN0U2hhcGU7XG5leHBvcnRzLm1ha2VTZWN0b3JTaGFwZSA9IG1ha2VTZWN0b3JTaGFwZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvdmlld0hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIExlZ2VuZE1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdsZWdlbmQucGxhaW4nLFxuICBkZXBlbmRlbmNpZXM6IFsnc2VyaWVzJ10sXG4gIGxheW91dE1vZGU6IHtcbiAgICB0eXBlOiAnYm94JyxcbiAgICAvLyBsZWdlbmQud2lkdGgvaGVpZ2h0IGFyZSBtYXhXaWR0aC9tYXhIZWlnaHQgYWN0dWFsbHksXG4gICAgLy8gd2hlcmVhcyByZWFseSB3aWR0aC9oZWlnaHQgaXMgY2FsY3VsYXRlZCBieSBpdHMgY29udGVudC5cbiAgICAvLyAoU2V0dGluZyB7bGVmdDogMTAsIHJpZ2h0OiAxMH0gZG9lcyBub3QgbWFrZSBzZW5zZSkuXG4gICAgLy8gU28gY29uc2lkZXIgdGhlIGNhc2U6XG4gICAgLy8gYHNldE9wdGlvbih7bGVnZW5kOiB7bGVmdDogMTB9KTtgXG4gICAgLy8gdGhlbiBgc2V0T3B0aW9uKHtsZWdlbmQ6IHtyaWdodDogMTB9KTtgXG4gICAgLy8gVGhlIHByZXZpb3VzIGBsZWZ0YCBzaG91bGQgYmUgY2xlYXJlZCBieSBzZXR0aW5nIGBpZ25vcmVTaXplYC5cbiAgICBpZ25vcmVTaXplOiB0cnVlXG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvbi5zZWxlY3RlZCB8fCB7fTtcbiAgfSxcbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBMZWdlbmRNb2RlbC5zdXBlckNhbGwodGhpcywgJ21lcmdlT3B0aW9uJywgb3B0aW9uKTtcbiAgfSxcbiAgb3B0aW9uVXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZURhdGEodGhpcy5lY01vZGVsKTtcblxuICAgIHZhciBsZWdlbmREYXRhID0gdGhpcy5fZGF0YTsgLy8gSWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZSwgdHJ5IHRvIHNlbGVjdCBvbmVcblxuICAgIGlmIChsZWdlbmREYXRhWzBdICYmIHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHZhciBoYXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBJZiBoYXMgYW55IHNlbGVjdGVkIGluIG9wdGlvbi5zZWxlY3RlZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsZWdlbmREYXRhW2ldLmdldCgnbmFtZScpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQobmFtZSkpIHtcbiAgICAgICAgICAvLyBGb3JjZSB0byB1bnNlbGVjdCBvdGhlcnNcbiAgICAgICAgICB0aGlzLnNlbGVjdChuYW1lKTtcbiAgICAgICAgICBoYXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVHJ5IHNlbGVjdCB0aGUgZmlyc3QgaWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZVxuXG5cbiAgICAgICFoYXNTZWxlY3RlZCAmJiB0aGlzLnNlbGVjdChsZWdlbmREYXRhWzBdLmdldCgnbmFtZScpKTtcbiAgICB9XG4gIH0sXG4gIF91cGRhdGVEYXRhOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBsZWdlbmREYXRhID0genJVdGlsLm1hcCh0aGlzLmdldCgnZGF0YScpIHx8IFtdLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgIC8vIENhbiBiZSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICBpZiAodHlwZW9mIGRhdGFJdGVtID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0YUl0ZW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGFJdGVtID0ge1xuICAgICAgICAgIG5hbWU6IGRhdGFJdGVtXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTW9kZWwoZGF0YUl0ZW0sIHRoaXMsIHRoaXMuZWNNb2RlbCk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fZGF0YSA9IGxlZ2VuZERhdGE7XG4gICAgdmFyIGF2YWlsYWJsZU5hbWVzID0genJVdGlsLm1hcChlY01vZGVsLmdldFNlcmllcygpLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICByZXR1cm4gc2VyaWVzLm5hbWU7XG4gICAgfSk7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcigpO1xuICAgICAgICBhdmFpbGFibGVOYW1lcyA9IGF2YWlsYWJsZU5hbWVzLmNvbmNhdChkYXRhLm1hcEFycmF5KGRhdGEuZ2V0TmFtZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fYXZhaWxhYmxlTmFtZXMgPSBhdmFpbGFibGVOYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPn1cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICB2YXIgc2VsZWN0ZWRNb2RlID0gdGhpcy5nZXQoJ3NlbGVjdGVkTW9kZScpO1xuXG4gICAgaWYgKHNlbGVjdGVkTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgIHpyVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICBzZWxlY3RlZFtkYXRhSXRlbS5nZXQoJ25hbWUnKV0gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHVuU2VsZWN0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJykgIT09ICdzaW5nbGUnKSB7XG4gICAgICB0aGlzLm9wdGlvbi5zZWxlY3RlZFtuYW1lXSA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHRvZ2dsZVNlbGVjdGVkOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkOyAvLyBEZWZhdWx0IGlzIHRydWVcblxuICAgIGlmICghc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzW3NlbGVjdGVkW25hbWVdID8gJ3VuU2VsZWN0JyA6ICdzZWxlY3QnXShuYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICEoc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIXNlbGVjdGVkW25hbWVdKSAmJiB6clV0aWwuaW5kZXhPZih0aGlzLl9hdmFpbGFibGVOYW1lcywgbmFtZSkgPj0gMDtcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIC8vIOS4gOe6p+WxguWPoFxuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICB6OiA0LFxuICAgIHNob3c6IHRydWUsXG4gICAgLy8g5biD5bGA5pa55byP77yM6buY6K6k5Li65rC05bmz5biD5bGA77yM5Y+v6YCJ5Li677yaXG4gICAgLy8gJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJ1xuICAgIG9yaWVudDogJ2hvcml6b250YWwnLFxuICAgIGxlZnQ6ICdjZW50ZXInLFxuICAgIC8vIHJpZ2h0OiAnY2VudGVyJyxcbiAgICB0b3A6IDAsXG4gICAgLy8gYm90dG9tOiBudWxsLFxuICAgIC8vIOawtOW5s+Wvuem9kFxuICAgIC8vICdhdXRvJyB8ICdsZWZ0JyB8ICdyaWdodCdcbiAgICAvLyDpu5jorqTkuLogJ2F1dG8nLCDmoLnmja4geCDnmoTkvY3nva7liKTmlq3mmK/lt6blr7npvZDov5jmmK/lj7Plr7npvZBcbiAgICBhbGlnbjogJ2F1dG8nLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIC8vIOWbvuS+i+i+ueahhuminOiJslxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIC8vIOWbvuS+i+i+ueahhue6v+Wuve+8jOWNleS9jXB477yM6buY6K6k5Li6MO+8iOaXoOi+ueahhu+8iVxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIC8vIOWbvuS+i+WGhei+uei3ne+8jOWNleS9jXB477yM6buY6K6k5ZCE5pa55ZCR5YaF6L656Led5Li6Ne+8jFxuICAgIC8vIOaOpeWPl+aVsOe7hOWIhuWIq+iuvuWumuS4iuWPs+S4i+W3pui+uei3ne+8jOWQjGNzc1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLy8g5ZCE5LiqaXRlbeS5i+mXtOeahOmXtOmalO+8jOWNleS9jXB477yM6buY6K6k5Li6MTDvvIxcbiAgICAvLyDmqKrlkJHluIPlsYDml7bkuLrmsLTlubPpl7TpmpTvvIznurXlkJHluIPlsYDml7bkuLrnurXlkJHpl7TpmpRcbiAgICBpdGVtR2FwOiAxMCxcbiAgICAvLyDlm77kvovlm77lvaLlrr3luqZcbiAgICBpdGVtV2lkdGg6IDI1LFxuICAgIC8vIOWbvuS+i+WbvuW9oumrmOW6plxuICAgIGl0ZW1IZWlnaHQ6IDE0LFxuICAgIC8vIOWbvuS+i+WFs+mXreaXtuWAmeeahOminOiJslxuICAgIGluYWN0aXZlQ29sb3I6ICcjY2NjJyxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIC8vIOWbvuS+i+aWh+Wtl+minOiJslxuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgLy8gZm9ybWF0dGVyOiAnJyxcbiAgICAvLyDpgInmi6nmqKHlvI/vvIzpu5jorqTlvIDlkK/lm77kvovlvIDlhbNcbiAgICBzZWxlY3RlZE1vZGU6IHRydWUsXG4gICAgLy8g6YWN572u6buY6K6k6YCJ5Lit54q25oCB77yM5Y+v6YWN5ZCITEVHRU5ELlNFTEVDVEVE5LqL5Lu25YGa5Yqo5oCB5pWw5o2u6L295YWlXG4gICAgLy8gc2VsZWN0ZWQ6IG51bGwsXG4gICAgLy8g5Zu+5L6L5YaF5a6577yI6K+m6KeBbGVnZW5kLmRhdGHvvIzmlbDnu4TkuK3mr4/kuIDpobnku6PooajkuIDkuKppdGVtXG4gICAgLy8gZGF0YTogW10sXG4gICAgLy8gVG9vbHRpcCDnm7jlhbPphY3nva5cbiAgICB0b29sdGlwOiB7XG4gICAgICBzaG93OiBmYWxzZVxuICAgIH1cbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBMZWdlbmRNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvc3ltYm9sXCIpO1xuXG52YXIgY3JlYXRlU3ltYm9sID0gX3N5bWJvbC5jcmVhdGVTeW1ib2w7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIF9saXN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4uL2hlbHBlci9saXN0Q29tcG9uZW50XCIpO1xuXG52YXIgbWFrZUJhY2tncm91bmQgPSBfbGlzdENvbXBvbmVudC5tYWtlQmFja2dyb3VuZDtcblxudmFyIGxheW91dFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgR3JvdXAgPSBncmFwaGljLkdyb3VwO1xuXG52YXIgX2RlZmF1bHQgPSBlY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuICB0eXBlOiAnbGVnZW5kLnBsYWluJyxcbiAgbmV3bGluZURpc2FibGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2NvbnRlbnRHcm91cCA9IG5ldyBHcm91cCgpKTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAqL1xuXG4gICAgdGhpcy5fYmFja2dyb3VuZEVsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRDb250ZW50R3JvdXA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudEdyb3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKGxlZ2VuZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLnJlc2V0SW5uZXIoKTtcblxuICAgIGlmICghbGVnZW5kTW9kZWwuZ2V0KCdzaG93JywgdHJ1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlbUFsaWduID0gbGVnZW5kTW9kZWwuZ2V0KCdhbGlnbicpO1xuXG4gICAgaWYgKCFpdGVtQWxpZ24gfHwgaXRlbUFsaWduID09PSAnYXV0bycpIHtcbiAgICAgIGl0ZW1BbGlnbiA9IGxlZ2VuZE1vZGVsLmdldCgnbGVmdCcpID09PSAncmlnaHQnICYmIGxlZ2VuZE1vZGVsLmdldCgnb3JpZW50JykgPT09ICd2ZXJ0aWNhbCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVySW5uZXIoaXRlbUFsaWduLCBsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpKTsgLy8gUGVyZm9ybSBsYXlvdXQuXG5cbiAgICB2YXIgcG9zaXRpb25JbmZvID0gbGVnZW5kTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCk7XG4gICAgdmFyIHZpZXdwb3J0U2l6ZSA9IHtcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfTtcbiAgICB2YXIgcGFkZGluZyA9IGxlZ2VuZE1vZGVsLmdldCgncGFkZGluZycpO1xuICAgIHZhciBtYXhTaXplID0gbGF5b3V0VXRpbC5nZXRMYXlvdXRSZWN0KHBvc2l0aW9uSW5mbywgdmlld3BvcnRTaXplLCBwYWRkaW5nKTtcbiAgICB2YXIgbWFpblJlY3QgPSB0aGlzLmxheW91dElubmVyKGxlZ2VuZE1vZGVsLCBpdGVtQWxpZ24sIG1heFNpemUpOyAvLyBQbGFjZSBtYWluR3JvdXAsIGJhc2VkIG9uIHRoZSBjYWxjdWxhdGVkIGBtYWluUmVjdGAuXG5cbiAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dFV0aWwuZ2V0TGF5b3V0UmVjdCh6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgd2lkdGg6IG1haW5SZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBtYWluUmVjdC5oZWlnaHRcbiAgICB9LCBwb3NpdGlvbkluZm8pLCB2aWV3cG9ydFNpemUsIHBhZGRpbmcpO1xuICAgIHRoaXMuZ3JvdXAuYXR0cigncG9zaXRpb24nLCBbbGF5b3V0UmVjdC54IC0gbWFpblJlY3QueCwgbGF5b3V0UmVjdC55IC0gbWFpblJlY3QueV0pOyAvLyBSZW5kZXIgYmFja2dyb3VuZCBhZnRlciBncm91cCBpcyBsYXlvdXQuXG5cbiAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLl9iYWNrZ3JvdW5kRWwgPSBtYWtlQmFja2dyb3VuZChtYWluUmVjdCwgbGVnZW5kTW9kZWwpKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcmVzZXRJbm5lcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ2V0Q29udGVudEdyb3VwKCkucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5fYmFja2dyb3VuZEVsICYmIHRoaXMuZ3JvdXAucmVtb3ZlKHRoaXMuX2JhY2tncm91bmRFbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlbmRlcklubmVyOiBmdW5jdGlvbiAoaXRlbUFsaWduLCBsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGNvbnRlbnRHcm91cCA9IHRoaXMuZ2V0Q29udGVudEdyb3VwKCk7XG4gICAgdmFyIGxlZ2VuZERyYXduTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgc2VsZWN0TW9kZSA9IGxlZ2VuZE1vZGVsLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgZWFjaChsZWdlbmRNb2RlbC5nZXREYXRhKCksIGZ1bmN0aW9uIChpdGVtTW9kZWwsIGRhdGFJbmRleCkge1xuICAgICAgdmFyIG5hbWUgPSBpdGVtTW9kZWwuZ2V0KCduYW1lJyk7IC8vIFVzZSBlbXB0eSBzdHJpbmcgb3IgXFxuIGFzIGEgbmV3bGluZSBzdHJpbmdcblxuICAgICAgaWYgKCF0aGlzLm5ld2xpbmVEaXNhYmxlZCAmJiAobmFtZSA9PT0gJycgfHwgbmFtZSA9PT0gJ1xcbicpKSB7XG4gICAgICAgIGNvbnRlbnRHcm91cC5hZGQobmV3IEdyb3VwKHtcbiAgICAgICAgICBuZXdsaW5lOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWVzTW9kZWwgPSBlY01vZGVsLmdldFNlcmllc0J5TmFtZShuYW1lKVswXTtcblxuICAgICAgaWYgKGxlZ2VuZERyYXduTWFwLmdldChuYW1lKSkge1xuICAgICAgICAvLyBIYXZlIGJlZW4gZHJhd2VkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gU2VyaWVzIGxlZ2VuZFxuXG5cbiAgICAgIGlmIChzZXJpZXNNb2RlbCkge1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgdmFyIGNvbG9yID0gZGF0YS5nZXRWaXN1YWwoJ2NvbG9yJyk7IC8vIElmIGNvbG9yIGlzIGEgY2FsbGJhY2sgZnVuY3Rpb25cblxuICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCBkYXRhXG4gICAgICAgICAgY29sb3IgPSBjb2xvcihzZXJpZXNNb2RlbC5nZXREYXRhUGFyYW1zKDApKTtcbiAgICAgICAgfSAvLyBVc2luZyByZWN0IHN5bWJvbCBkZWZhdWx0bHlcblxuXG4gICAgICAgIHZhciBsZWdlbmRTeW1ib2xUeXBlID0gZGF0YS5nZXRWaXN1YWwoJ2xlZ2VuZFN5bWJvbCcpIHx8ICdyb3VuZFJlY3QnO1xuICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IGRhdGEuZ2V0VmlzdWFsKCdzeW1ib2wnKTtcblxuICAgICAgICB2YXIgaXRlbUdyb3VwID0gdGhpcy5fY3JlYXRlSXRlbShuYW1lLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGVnZW5kTW9kZWwsIGxlZ2VuZFN5bWJvbFR5cGUsIHN5bWJvbFR5cGUsIGl0ZW1BbGlnbiwgY29sb3IsIHNlbGVjdE1vZGUpO1xuXG4gICAgICAgIGl0ZW1Hcm91cC5vbignY2xpY2snLCBjdXJyeShkaXNwYXRjaFNlbGVjdEFjdGlvbiwgbmFtZSwgYXBpKSkub24oJ21vdXNlb3ZlcicsIGN1cnJ5KGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uLCBzZXJpZXNNb2RlbCwgbnVsbCwgYXBpKSkub24oJ21vdXNlb3V0JywgY3VycnkoZGlzcGF0Y2hEb3ducGxheUFjdGlvbiwgc2VyaWVzTW9kZWwsIG51bGwsIGFwaSkpO1xuICAgICAgICBsZWdlbmREcmF3bk1hcC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEYXRhIGxlZ2VuZCBvZiBwaWUsIGZ1bm5lbFxuICAgICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgLy8gSW4gY2FzZSBtdWx0aXBsZSBzZXJpZXMgaGFzIHNhbWUgZGF0YSBuYW1lXG4gICAgICAgICAgaWYgKGxlZ2VuZERyYXduTWFwLmdldChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZXJpZXNNb2RlbC5sZWdlbmREYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwubGVnZW5kRGF0YVByb3ZpZGVyKCk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gZGF0YS5pbmRleE9mTmFtZShuYW1lKTtcblxuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTtcbiAgICAgICAgICAgIHZhciBsZWdlbmRTeW1ib2xUeXBlID0gJ3JvdW5kUmVjdCc7XG5cbiAgICAgICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKG5hbWUsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsZWdlbmRNb2RlbCwgbGVnZW5kU3ltYm9sVHlwZSwgbnVsbCwgaXRlbUFsaWduLCBjb2xvciwgc2VsZWN0TW9kZSk7XG5cbiAgICAgICAgICAgIGl0ZW1Hcm91cC5vbignY2xpY2snLCBjdXJyeShkaXNwYXRjaFNlbGVjdEFjdGlvbiwgbmFtZSwgYXBpKSkgLy8gRklYTUUgU2hvdWxkIG5vdCBzcGVjaWZ5IHRoZSBzZXJpZXMgbmFtZVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBjdXJyeShkaXNwYXRjaEhpZ2hsaWdodEFjdGlvbiwgc2VyaWVzTW9kZWwsIG5hbWUsIGFwaSkpLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIHNlcmllc01vZGVsLCBuYW1lLCBhcGkpKTtcbiAgICAgICAgICAgIGxlZ2VuZERyYXduTWFwLnNldChuYW1lLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuICBfY3JlYXRlSXRlbTogZnVuY3Rpb24gKG5hbWUsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsZWdlbmRNb2RlbCwgbGVnZW5kU3ltYm9sVHlwZSwgc3ltYm9sVHlwZSwgaXRlbUFsaWduLCBjb2xvciwgc2VsZWN0TW9kZSkge1xuICAgIHZhciBpdGVtV2lkdGggPSBsZWdlbmRNb2RlbC5nZXQoJ2l0ZW1XaWR0aCcpO1xuICAgIHZhciBpdGVtSGVpZ2h0ID0gbGVnZW5kTW9kZWwuZ2V0KCdpdGVtSGVpZ2h0Jyk7XG4gICAgdmFyIGluYWN0aXZlQ29sb3IgPSBsZWdlbmRNb2RlbC5nZXQoJ2luYWN0aXZlQ29sb3InKTtcbiAgICB2YXIgaXNTZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQobmFtZSk7XG4gICAgdmFyIGl0ZW1Hcm91cCA9IG5ldyBHcm91cCgpO1xuICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgdmFyIGl0ZW1JY29uID0gaXRlbU1vZGVsLmdldCgnaWNvbicpO1xuICAgIHZhciB0b29sdGlwTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ3Rvb2x0aXAnKTtcbiAgICB2YXIgbGVnZW5kR2xvYmFsVG9vbHRpcE1vZGVsID0gdG9vbHRpcE1vZGVsLnBhcmVudE1vZGVsOyAvLyBVc2UgdXNlciBnaXZlbiBpY29uIGZpcnN0XG5cbiAgICBsZWdlbmRTeW1ib2xUeXBlID0gaXRlbUljb24gfHwgbGVnZW5kU3ltYm9sVHlwZTtcbiAgICBpdGVtR3JvdXAuYWRkKGNyZWF0ZVN5bWJvbChsZWdlbmRTeW1ib2xUeXBlLCAwLCAwLCBpdGVtV2lkdGgsIGl0ZW1IZWlnaHQsIGlzU2VsZWN0ZWQgPyBjb2xvciA6IGluYWN0aXZlQ29sb3IsIHRydWUpKTsgLy8gQ29tcG9zZSBzeW1ib2xzXG4gICAgLy8gUEVORElOR1xuXG4gICAgaWYgKCFpdGVtSWNvbiAmJiBzeW1ib2xUeXBlIC8vIEF0IGxlYXN0IHNob3cgb25lIHN5bWJvbCwgY2FuJ3QgYmUgYWxsIG5vbmVcbiAgICAmJiAoc3ltYm9sVHlwZSAhPT0gbGVnZW5kU3ltYm9sVHlwZSB8fCBzeW1ib2xUeXBlID09ICdub25lJykpIHtcbiAgICAgIHZhciBzaXplID0gaXRlbUhlaWdodCAqIDAuODtcblxuICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgICAgICBzeW1ib2xUeXBlID0gJ2NpcmNsZSc7XG4gICAgICB9IC8vIFB1dCBzeW1ib2wgaW4gdGhlIGNlbnRlclxuXG5cbiAgICAgIGl0ZW1Hcm91cC5hZGQoY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIChpdGVtV2lkdGggLSBzaXplKSAvIDIsIChpdGVtSGVpZ2h0IC0gc2l6ZSkgLyAyLCBzaXplLCBzaXplLCBpc1NlbGVjdGVkID8gY29sb3IgOiBpbmFjdGl2ZUNvbG9yKSk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRYID0gaXRlbUFsaWduID09PSAnbGVmdCcgPyBpdGVtV2lkdGggKyA1IDogLTU7XG4gICAgdmFyIHRleHRBbGlnbiA9IGl0ZW1BbGlnbjtcbiAgICB2YXIgZm9ybWF0dGVyID0gbGVnZW5kTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKTtcbiAgICB2YXIgY29udGVudCA9IG5hbWU7XG5cbiAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycgJiYgZm9ybWF0dGVyKSB7XG4gICAgICBjb250ZW50ID0gZm9ybWF0dGVyLnJlcGxhY2UoJ3tuYW1lfScsIG5hbWUgIT0gbnVsbCA/IG5hbWUgOiAnJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZW50ID0gZm9ybWF0dGVyKG5hbWUpO1xuICAgIH1cblxuICAgIGl0ZW1Hcm91cC5hZGQobmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICBzdHlsZTogZ3JhcGhpYy5zZXRUZXh0U3R5bGUoe30sIHRleHRTdHlsZU1vZGVsLCB7XG4gICAgICAgIHRleHQ6IGNvbnRlbnQsXG4gICAgICAgIHg6IHRleHRYLFxuICAgICAgICB5OiBpdGVtSGVpZ2h0IC8gMixcbiAgICAgICAgdGV4dEZpbGw6IGlzU2VsZWN0ZWQgPyB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSA6IGluYWN0aXZlQ29sb3IsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgIH0pXG4gICAgfSkpOyAvLyBBZGQgYSBpbnZpc2libGUgcmVjdCB0byBpbmNyZWFzZSB0aGUgYXJlYSBvZiBtb3VzZSBob3ZlclxuXG4gICAgdmFyIGhpdFJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgIHNoYXBlOiBpdGVtR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCksXG4gICAgICBpbnZpc2libGU6IHRydWUsXG4gICAgICB0b29sdGlwOiB0b29sdGlwTW9kZWwuZ2V0KCdzaG93JykgPyB6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgY29udGVudDogbmFtZSxcbiAgICAgICAgLy8gRGVmYXVsIGZvcm1hdHRlclxuICAgICAgICBmb3JtYXR0ZXI6IGxlZ2VuZEdsb2JhbFRvb2x0aXBNb2RlbC5nZXQoJ2Zvcm1hdHRlcicsIHRydWUpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyUGFyYW1zOiB7XG4gICAgICAgICAgY29tcG9uZW50VHlwZTogJ2xlZ2VuZCcsXG4gICAgICAgICAgbGVnZW5kSW5kZXg6IGxlZ2VuZE1vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgJHZhcnM6IFsnbmFtZSddXG4gICAgICAgIH1cbiAgICAgIH0sIHRvb2x0aXBNb2RlbC5vcHRpb24pIDogbnVsbFxuICAgIH0pO1xuICAgIGl0ZW1Hcm91cC5hZGQoaGl0UmVjdCk7XG4gICAgaXRlbUdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLnNpbGVudCA9IHRydWU7XG4gICAgfSk7XG4gICAgaGl0UmVjdC5zaWxlbnQgPSAhc2VsZWN0TW9kZTtcbiAgICB0aGlzLmdldENvbnRlbnRHcm91cCgpLmFkZChpdGVtR3JvdXApO1xuICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShpdGVtR3JvdXApO1xuICAgIGl0ZW1Hcm91cC5fX2xlZ2VuZERhdGFJbmRleCA9IGRhdGFJbmRleDtcbiAgICByZXR1cm4gaXRlbUdyb3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBsYXlvdXRJbm5lcjogZnVuY3Rpb24gKGxlZ2VuZE1vZGVsLCBpdGVtQWxpZ24sIG1heFNpemUpIHtcbiAgICB2YXIgY29udGVudEdyb3VwID0gdGhpcy5nZXRDb250ZW50R3JvdXAoKTsgLy8gUGxhY2UgaXRlbXMgaW4gY29udGVudEdyb3VwLlxuXG4gICAgbGF5b3V0VXRpbC5ib3gobGVnZW5kTW9kZWwuZ2V0KCdvcmllbnQnKSwgY29udGVudEdyb3VwLCBsZWdlbmRNb2RlbC5nZXQoJ2l0ZW1HYXAnKSwgbWF4U2l6ZS53aWR0aCwgbWF4U2l6ZS5oZWlnaHQpO1xuICAgIHZhciBjb250ZW50UmVjdCA9IGNvbnRlbnRHcm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICBjb250ZW50R3JvdXAuYXR0cigncG9zaXRpb24nLCBbLWNvbnRlbnRSZWN0LngsIC1jb250ZW50UmVjdC55XSk7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkaXNwYXRjaFNlbGVjdEFjdGlvbihuYW1lLCBhcGkpIHtcbiAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnbGVnZW5kVG9nZ2xlU2VsZWN0JyxcbiAgICBuYW1lOiBuYW1lXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEhpZ2hsaWdodEFjdGlvbihzZXJpZXNNb2RlbCwgZGF0YU5hbWUsIGFwaSkge1xuICAvLyBJZiBlbGVtZW50IGhvdmVyIHdpbGwgbW92ZSB0byBhIGhvdmVyTGF5ZXIuXG4gIHZhciBlbCA9IGFwaS5nZXRacigpLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKVswXTtcblxuICBpZiAoIShlbCAmJiBlbC51c2VIb3ZlckxheWVyKSkge1xuICAgIHNlcmllc01vZGVsLmdldCgnbGVnZW5kSG92ZXJMaW5rJykgJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdoaWdobGlnaHQnLFxuICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICAgIG5hbWU6IGRhdGFOYW1lXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hEb3ducGxheUFjdGlvbihzZXJpZXNNb2RlbCwgZGF0YU5hbWUsIGFwaSkge1xuICAvLyBJZiBlbGVtZW50IGhvdmVyIHdpbGwgbW92ZSB0byBhIGhvdmVyTGF5ZXIuXG4gIHZhciBlbCA9IGFwaS5nZXRacigpLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKVswXTtcblxuICBpZiAoIShlbCAmJiBlbC51c2VIb3ZlckxheWVyKSkge1xuICAgIHNlcmllc01vZGVsLmdldCgnbGVnZW5kSG92ZXJMaW5rJykgJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdkb3ducGxheScsXG4gICAgICBzZXJpZXNOYW1lOiBzZXJpZXNNb2RlbC5uYW1lLFxuICAgICAgbmFtZTogZGF0YU5hbWVcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9sYXlvdXQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBnZXRMYXlvdXRSZWN0ID0gX2xheW91dC5nZXRMYXlvdXRSZWN0O1xudmFyIGxheW91dEJveCA9IF9sYXlvdXQuYm94O1xudmFyIHBvc2l0aW9uRWxlbWVudCA9IF9sYXlvdXQucG9zaXRpb25FbGVtZW50O1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG4vKipcbiAqIExheW91dCBsaXN0IGxpa2UgY29tcG9uZW50LlxuICogSXQgd2lsbCBib3ggbGF5b3V0IGVhY2ggaXRlbXMgaW4gZ3JvdXAgb2YgY29tcG9uZW50IGFuZCB0aGVuIHBvc2l0aW9uIHRoZSB3aG9sZSBncm91cCBpbiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JvdXAvR3JvdXB9IGdyb3VwXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29tcG9uZW50TW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICovXG5mdW5jdGlvbiBsYXlvdXQoZ3JvdXAsIGNvbXBvbmVudE1vZGVsLCBhcGkpIHtcbiAgdmFyIGJveExheW91dFBhcmFtcyA9IGNvbXBvbmVudE1vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuICB2YXIgcGFkZGluZyA9IGNvbXBvbmVudE1vZGVsLmdldCgncGFkZGluZycpO1xuICB2YXIgdmlld3BvcnRTaXplID0ge1xuICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICB9O1xuICB2YXIgcmVjdCA9IGdldExheW91dFJlY3QoYm94TGF5b3V0UGFyYW1zLCB2aWV3cG9ydFNpemUsIHBhZGRpbmcpO1xuICBsYXlvdXRCb3goY29tcG9uZW50TW9kZWwuZ2V0KCdvcmllbnQnKSwgZ3JvdXAsIGNvbXBvbmVudE1vZGVsLmdldCgnaXRlbUdhcCcpLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gIHBvc2l0aW9uRWxlbWVudChncm91cCwgYm94TGF5b3V0UGFyYW1zLCB2aWV3cG9ydFNpemUsIHBhZGRpbmcpO1xufVxuXG5mdW5jdGlvbiBtYWtlQmFja2dyb3VuZChyZWN0LCBjb21wb25lbnRNb2RlbCkge1xuICB2YXIgcGFkZGluZyA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkoY29tcG9uZW50TW9kZWwuZ2V0KCdwYWRkaW5nJykpO1xuICB2YXIgc3R5bGUgPSBjb21wb25lbnRNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvcicsICdvcGFjaXR5J10pO1xuICBzdHlsZS5maWxsID0gY29tcG9uZW50TW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICBzaGFwZToge1xuICAgICAgeDogcmVjdC54IC0gcGFkZGluZ1szXSxcbiAgICAgIHk6IHJlY3QueSAtIHBhZGRpbmdbMF0sXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCArIHBhZGRpbmdbMV0gKyBwYWRkaW5nWzNdLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCArIHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdLFxuICAgICAgcjogY29tcG9uZW50TW9kZWwuZ2V0KCdib3JkZXJSYWRpdXMnKVxuICAgIH0sXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHNpbGVudDogdHJ1ZSxcbiAgICB6MjogLTFcbiAgfSk7IC8vIEZJWE1FXG4gIC8vIGBzdWJQaXhlbE9wdGltaXplUmVjdGAgbWF5IGJyaW5nIHNvbWUgZ2FwIGJldHdlZW4gZWRnZSBvZiB2aWV3cGFydFxuICAvLyBhbmQgYmFja2dyb3VuZCByZWN0IHdoZW4gc2V0dGluZyBsaWtlIGBsZWZ0OiAwYCwgYHRvcDogMGAuXG4gIC8vIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QocmVjdCk7XG5cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmV4cG9ydHMubGF5b3V0ID0gbGF5b3V0O1xuZXhwb3J0cy5tYWtlQmFja2dyb3VuZCA9IG1ha2VCYWNrZ3JvdW5kO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvbGlzdENvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Db21wb25lbnRcIik7XG5cbkNvbXBvbmVudC5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoJ2RhdGFab29tJywgZnVuY3Rpb24gKCkge1xuICAvLyBEZWZhdWx0ICdzbGlkZXInIHdoZW4gbm8gdHlwZSBzcGVjaWZpZWQuXG4gIHJldHVybiAnc2xpZGVyJztcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS90eXBlRGVmYXVsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgQVRUUiA9ICdcXDBfZWNfaW50ZXJhY3Rpb25fbXV0ZXgnO1xuXG5mdW5jdGlvbiB0YWtlKHpyLCByZXNvdXJjZUtleSwgdXNlcktleSkge1xuICB2YXIgc3RvcmUgPSBnZXRTdG9yZSh6cik7XG4gIHN0b3JlW3Jlc291cmNlS2V5XSA9IHVzZXJLZXk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2UoenIsIHJlc291cmNlS2V5LCB1c2VyS2V5KSB7XG4gIHZhciBzdG9yZSA9IGdldFN0b3JlKHpyKTtcbiAgdmFyIHVLZXkgPSBzdG9yZVtyZXNvdXJjZUtleV07XG5cbiAgaWYgKHVLZXkgPT09IHVzZXJLZXkpIHtcbiAgICBzdG9yZVtyZXNvdXJjZUtleV0gPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVGFrZW4oenIsIHJlc291cmNlS2V5KSB7XG4gIHJldHVybiAhIWdldFN0b3JlKHpyKVtyZXNvdXJjZUtleV07XG59XG5cbmZ1bmN0aW9uIGdldFN0b3JlKHpyKSB7XG4gIHJldHVybiB6cltBVFRSXSB8fCAoenJbQVRUUl0gPSB7fSk7XG59XG4vKipcbiAqIHBheWxvYWQ6IHtcbiAqICAgICB0eXBlOiAndGFrZUdsb2JhbEN1cnNvcicsXG4gKiAgICAga2V5OiAnZGF0YVpvb21TZWxlY3QnLCBvciAnYnJ1c2gnLCBvciAuLi4sXG4gKiAgICAgICAgIElmIG5vIHVzZXJLZXksIHJlbGVhc2UgZ2xvYmFsIGN1cnNvci5cbiAqIH1cbiAqL1xuXG5cbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiAndGFrZUdsb2JhbEN1cnNvcicsXG4gIGV2ZW50OiAnZ2xvYmFsQ3Vyc29yVGFrZW4nLFxuICB1cGRhdGU6ICd1cGRhdGUnXG59LCBmdW5jdGlvbiAoKSB7fSk7XG5leHBvcnRzLnRha2UgPSB0YWtlO1xuZXhwb3J0cy5yZWxlYXNlID0gcmVsZWFzZTtcbmV4cG9ydHMuaXNUYWtlbiA9IGlzVGFrZW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9pbnRlcmFjdGlvbk11dGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG5lY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdkYXRhWm9vbScsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgLy8gV2UgY2FsY3VsYXRlIHdpbmRvdyBhbmQgcmVzZXQgYXhpcyBoZXJlIGJ1dCBub3QgaW4gbW9kZWxcbiAgICAvLyBpbml0IHN0YWdlIGFuZCBub3QgYWZ0ZXIgYWN0aW9uIGRpc3BhdGNoIGhhbmRsZXIsIGJlY2F1c2VcbiAgICAvLyByZXNldCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHNlcmllc0RhdGEucmVzdG9yZURhdGEuXG4gICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhyZXNldFNpbmdsZUF4aXMpOyAvLyBDYXV0aW9uOiBkYXRhIHpvb20gZmlsdGVyaW5nIGlzIG9yZGVyIHNlbnNpdGl2ZSB3aGVuIHVzaW5nXG4gICAgLy8gcGVyY2VudCByYW5nZSBhbmQgbm8gbWluL21heC9zY2FsZSBzZXQgb24gYXhpcy5cbiAgICAvLyBGb3IgZXhhbXBsZSwgd2UgaGF2ZSBkYXRhWm9vbSBkZWZpbml0aW9uOlxuICAgIC8vIFtcbiAgICAvLyAgICAgIHt4QXhpc0luZGV4OiAwLCBzdGFydDogMzAsIGVuZDogNzB9LFxuICAgIC8vICAgICAge3lBeGlzSW5kZXg6IDAsIHN0YXJ0OiAyMCwgZW5kOiA4MH1cbiAgICAvLyBdXG4gICAgLy8gSW4gdGhpcyBjYXNlLCBbMjAsIDgwXSBvZiB5LWRhdGFab29tIHNob3VsZCBiZSBiYXNlZCBvbiBkYXRhXG4gICAgLy8gdGhhdCBoYXZlIGZpbHRlcmVkIGJ5IHgtZGF0YVpvb20gdXNpbmcgcmFuZ2Ugb2YgWzMwLCA3MF0sXG4gICAgLy8gYnV0IHNob3VsZCBub3QgYmUgYmFzZWQgb24gZnVsbCByYXcgZGF0YS4gVGh1cyBzbGlkaW5nXG4gICAgLy8geC1kYXRhWm9vbSB3aWxsIGNoYW5nZSBib3RoIHJhbmdlcyBvZiB4QXhpcyBhbmQgeUF4aXMsXG4gICAgLy8gd2hpbGUgc2xpZGluZyB5LWRhdGFab29tIHdpbGwgb25seSBjaGFuZ2UgdGhlIHJhbmdlIG9mIHlBeGlzLlxuICAgIC8vIFNvIHdlIHNob3VsZCBmaWx0ZXIgeC1heGlzIGFmdGVyIHJlc2V0IHgtYXhpcyBpbW1lZGlhdGVseSxcbiAgICAvLyBhbmQgdGhlbiByZXNldCB5LWF4aXMgYW5kIGZpbHRlciB5LWF4aXMuXG5cbiAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZpbHRlclNpbmdsZUF4aXMpO1xuICB9KTtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdkYXRhWm9vbScsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgLy8gRnVsbGZpbGwgYWxsIG9mIHRoZSByYW5nZSBwcm9wcyBzbyB0aGF0IHVzZXJcbiAgICAvLyBpcyBhYmxlIHRvIGdldCB0aGVtIGZyb20gY2hhcnQuZ2V0T3B0aW9uKCkuXG4gICAgdmFyIGF4aXNQcm94eSA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG4gICAgdmFyIHBlcmNlbnRSYW5nZSA9IGF4aXNQcm94eS5nZXREYXRhUGVyY2VudFdpbmRvdygpO1xuICAgIHZhciB2YWx1ZVJhbmdlID0gYXhpc1Byb3h5LmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgIGRhdGFab29tTW9kZWwuc2V0UmF3UmFuZ2Uoe1xuICAgICAgc3RhcnQ6IHBlcmNlbnRSYW5nZVswXSxcbiAgICAgIGVuZDogcGVyY2VudFJhbmdlWzFdLFxuICAgICAgc3RhcnRWYWx1ZTogdmFsdWVSYW5nZVswXSxcbiAgICAgIGVuZFZhbHVlOiB2YWx1ZVJhbmdlWzFdXG4gICAgfSwgdHJ1ZSk7XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIHJlc2V0U2luZ2xlQXhpcyhkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsKSB7XG4gIGRhdGFab29tTW9kZWwuZ2V0QXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCkucmVzZXQoZGF0YVpvb21Nb2RlbCk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclNpbmdsZUF4aXMoZGltTmFtZXMsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCkge1xuICBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShkaW1OYW1lcy5uYW1lLCBheGlzSW5kZXgpLmZpbHRlckRhdGEoZGF0YVpvb21Nb2RlbCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2RhdGFab29tUHJvY2Vzc29yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbignZGF0YVpvb20nLCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICB2YXIgbGlua2VkTm9kZXNGaW5kZXIgPSBoZWxwZXIuY3JlYXRlTGlua2VkTm9kZXNGaW5kZXIoenJVdGlsLmJpbmQoZWNNb2RlbC5lYWNoQ29tcG9uZW50LCBlY01vZGVsLCAnZGF0YVpvb20nKSwgaGVscGVyLmVhY2hBeGlzRGltLCBmdW5jdGlvbiAobW9kZWwsIGRpbU5hbWVzKSB7XG4gICAgcmV0dXJuIG1vZGVsLmdldChkaW1OYW1lcy5heGlzSW5kZXgpO1xuICB9KTtcbiAgdmFyIGVmZmVjdGVkTW9kZWxzID0gW107XG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgbWFpblR5cGU6ICdkYXRhWm9vbScsXG4gICAgcXVlcnk6IHBheWxvYWRcbiAgfSwgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkge1xuICAgIGVmZmVjdGVkTW9kZWxzLnB1c2guYXBwbHkoZWZmZWN0ZWRNb2RlbHMsIGxpbmtlZE5vZGVzRmluZGVyKG1vZGVsKS5ub2Rlcyk7XG4gIH0pO1xuICB6clV0aWwuZWFjaChlZmZlY3RlZE1vZGVscywgZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGluZGV4KSB7XG4gICAgZGF0YVpvb21Nb2RlbC5zZXRSYXdSYW5nZSh7XG4gICAgICBzdGFydDogcGF5bG9hZC5zdGFydCxcbiAgICAgIGVuZDogcGF5bG9hZC5lbmQsXG4gICAgICBzdGFydFZhbHVlOiBwYXlsb2FkLnN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZTogcGF5bG9hZC5lbmRWYWx1ZVxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbUFjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBhZGRDb21tYXMgPSBmb3JtYXRVdGlsLmFkZENvbW1hcztcbnZhciBlbmNvZGVIVE1MID0gZm9ybWF0VXRpbC5lbmNvZGVIVE1MO1xuXG5mdW5jdGlvbiBmaWxsTGFiZWwob3B0KSB7XG4gIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMob3B0LmxhYmVsLCBbJ3Nob3cnXSk7XG59XG5cbnZhciBNYXJrZXJNb2RlbCA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuICB0eXBlOiAnbWFya2VyJyxcbiAgZGVwZW5kZW5jaWVzOiBbJ3NlcmllcycsICdncmlkJywgJ3BvbGFyJywgJ2dlbyddLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpdGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcbiAgICB0aGlzLm1lcmdlT3B0aW9uKG9wdGlvbiwgZWNNb2RlbCwgZXh0cmFPcHQuY3JlYXRlZEJ5U2VsZiwgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FuaW1hdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaG9zdFNlcmllcyA9IHRoaXMuX19ob3N0U2VyaWVzO1xuICAgIHJldHVybiB0aGlzLmdldFNoYWxsb3coJ2FuaW1hdGlvbicpICYmIGhvc3RTZXJpZXMgJiYgaG9zdFNlcmllcy5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgfSxcbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHQsIGVjTW9kZWwsIGNyZWF0ZWRCeVNlbGYsIGlzSW5pdCkge1xuICAgIHZhciBNYXJrZXJNb2RlbCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgdmFyIG1vZGVsUHJvcE5hbWUgPSB0aGlzLm1haW5UeXBlICsgJ01vZGVsJztcblxuICAgIGlmICghY3JlYXRlZEJ5U2VsZikge1xuICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICB2YXIgbWFya2VyT3B0ID0gc2VyaWVzTW9kZWwuZ2V0KHRoaXMubWFpblR5cGUpO1xuICAgICAgICB2YXIgbWFya2VyTW9kZWwgPSBzZXJpZXNNb2RlbFttb2RlbFByb3BOYW1lXTtcblxuICAgICAgICBpZiAoIW1hcmtlck9wdCB8fCAhbWFya2VyT3B0LmRhdGEpIHtcbiAgICAgICAgICBzZXJpZXNNb2RlbFttb2RlbFByb3BOYW1lXSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXJrZXJNb2RlbCkge1xuICAgICAgICAgIGlmIChpc0luaXQpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgbGFiZWwgZW1waGFzaXMgYHBvc2l0aW9uYCBhbmQgYHNob3dgXG4gICAgICAgICAgICBmaWxsTGFiZWwobWFya2VyT3B0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB6clV0aWwuZWFjaChtYXJrZXJPcHQuZGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIE92ZXJ3cml0ZSBmaWxsTGFiZWwgbWV0aG9kID9cbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgZmlsbExhYmVsKGl0ZW1bMF0pO1xuICAgICAgICAgICAgICBmaWxsTGFiZWwoaXRlbVsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaWxsTGFiZWwoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFya2VyTW9kZWwgPSBuZXcgTWFya2VyTW9kZWwobWFya2VyT3B0LCB0aGlzLCBlY01vZGVsKTtcbiAgICAgICAgICB6clV0aWwuZXh0ZW5kKG1hcmtlck1vZGVsLCB7XG4gICAgICAgICAgICBtYWluVHlwZTogdGhpcy5tYWluVHlwZSxcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgc2FtZSBzZXJpZXMgaW5kZXggYW5kIG5hbWVcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgIG5hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICAgICAgICBjcmVhdGVkQnlTZWxmOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFya2VyTW9kZWwuX19ob3N0U2VyaWVzID0gc2VyaWVzTW9kZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya2VyTW9kZWwubWVyZ2VPcHRpb24obWFya2VyT3B0LCBlY01vZGVsLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmllc01vZGVsW21vZGVsUHJvcE5hbWVdID0gbWFya2VyTW9kZWw7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH0sXG4gIGZvcm1hdFRvb2x0aXA6IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KTtcbiAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB6clV0aWwuaXNBcnJheSh2YWx1ZSkgPyB6clV0aWwubWFwKHZhbHVlLCBhZGRDb21tYXMpLmpvaW4oJywgJykgOiBhZGRDb21tYXModmFsdWUpO1xuICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgdmFyIGh0bWwgPSBlbmNvZGVIVE1MKHRoaXMubmFtZSk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCB8fCBuYW1lKSB7XG4gICAgICBodG1sICs9ICc8YnIgLz4nO1xuICAgIH1cblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBodG1sICs9IGVuY29kZUhUTUwobmFtZSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGh0bWwgKz0gJyA6ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGh0bWwgKz0gZW5jb2RlSFRNTChmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH0sXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfSxcbiAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxufSk7XG56clV0aWwubWl4aW4oTWFya2VyTW9kZWwsIG1vZGVsVXRpbC5kYXRhRm9ybWF0TWl4aW4pO1xudmFyIF9kZWZhdWx0ID0gTWFya2VyTW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya2VyTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDE4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcblxuZnVuY3Rpb24gaGFzWE9yWShpdGVtKSB7XG4gIHJldHVybiAhKGlzTmFOKHBhcnNlRmxvYXQoaXRlbS54KSkgJiYgaXNOYU4ocGFyc2VGbG9hdChpdGVtLnkpKSk7XG59XG5cbmZ1bmN0aW9uIGhhc1hBbmRZKGl0ZW0pIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KGl0ZW0ueCkpICYmICFpc05hTihwYXJzZUZsb2F0KGl0ZW0ueSkpO1xufVxuXG5mdW5jdGlvbiBnZXRQcmVjaXNpb24oZGF0YSwgdmFsdWVBeGlzRGltLCBkYXRhSW5kZXgpIHtcbiAgdmFyIHByZWNpc2lvbiA9IC0xO1xuXG4gIGRvIHtcbiAgICBwcmVjaXNpb24gPSBNYXRoLm1heChudW1iZXJVdGlsLmdldFByZWNpc2lvbihkYXRhLmdldCh2YWx1ZUF4aXNEaW0sIGRhdGFJbmRleCkpLCBwcmVjaXNpb24pO1xuICAgIGRhdGEgPSBkYXRhLnN0YWNrZWRPbjtcbiAgfSB3aGlsZSAoZGF0YSk7XG5cbiAgcmV0dXJuIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gbWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50KG1sVHlwZSwgZGF0YSwgb3RoZXJEYXRhRGltLCB0YXJnZXREYXRhRGltLCBvdGhlckNvb3JkSW5kZXgsIHRhcmdldENvb3JkSW5kZXgpIHtcbiAgdmFyIGNvb3JkQXJyID0gW107XG4gIHZhciB2YWx1ZSA9IG51bUNhbGN1bGF0ZShkYXRhLCB0YXJnZXREYXRhRGltLCBtbFR5cGUpO1xuICB2YXIgZGF0YUluZGV4ID0gZGF0YS5pbmRpY2VzT2ZOZWFyZXN0KHRhcmdldERhdGFEaW0sIHZhbHVlLCB0cnVlKVswXTtcbiAgY29vcmRBcnJbb3RoZXJDb29yZEluZGV4XSA9IGRhdGEuZ2V0KG90aGVyRGF0YURpbSwgZGF0YUluZGV4LCB0cnVlKTtcbiAgY29vcmRBcnJbdGFyZ2V0Q29vcmRJbmRleF0gPSBkYXRhLmdldCh0YXJnZXREYXRhRGltLCBkYXRhSW5kZXgsIHRydWUpO1xuICB2YXIgcHJlY2lzaW9uID0gZ2V0UHJlY2lzaW9uKGRhdGEsIHRhcmdldERhdGFEaW0sIGRhdGFJbmRleCk7XG4gIHByZWNpc2lvbiA9IE1hdGgubWluKHByZWNpc2lvbiwgMjApO1xuXG4gIGlmIChwcmVjaXNpb24gPj0gMCkge1xuICAgIGNvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdID0gK2Nvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgfVxuXG4gIHJldHVybiBjb29yZEFycjtcbn1cblxudmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5OyAvLyBUT0RPIFNwZWNpZmllZCBwZXJjZW50XG5cbnZhciBtYXJrZXJUeXBlQ2FsY3VsYXRvciA9IHtcbiAgLyoqXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VBeGlzRGltXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUF4aXNEaW1cbiAgICovXG4gIG1pbjogY3VycnkobWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50LCAnbWluJyksXG5cbiAgLyoqXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VBeGlzRGltXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUF4aXNEaW1cbiAgICovXG4gIG1heDogY3VycnkobWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50LCAnbWF4JyksXG5cbiAgLyoqXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VBeGlzRGltXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUF4aXNEaW1cbiAgICovXG4gIGF2ZXJhZ2U6IGN1cnJ5KG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudCwgJ2F2ZXJhZ2UnKVxufTtcbi8qKlxuICogVHJhbnNmb3JtIG1hcmtQb2ludCBkYXRhIGl0ZW0gdG8gZm9ybWF0IHVzZWQgaW4gTGlzdCBieSBkbyB0aGUgZm9sbG93aW5nXG4gKiAxLiBDYWxjdWxhdGUgc3RhdGlzdGljIGxpa2UgYG1heGAsIGBtaW5gLCBgYXZlcmFnZWBcbiAqIDIuIENvbnZlcnQgYGl0ZW0ueEF4aXNgLCBgaXRlbS55QXhpc2AgdG8gYGl0ZW0uY29vcmRgIGFycmF5XG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC8qfSBbY29vcmRTeXNdXG4gKiBAcGFyYW0gIHtPYmplY3R9IGl0ZW1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBkYXRhVHJhbnNmb3JtKHNlcmllc01vZGVsLCBpdGVtKSB7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtOyAvLyAxLiBJZiBub3Qgc3BlY2lmeSB0aGUgcG9zaXRpb24gd2l0aCBwaXhlbCBkaXJlY3RseVxuICAvLyAyLiBJZiBgY29vcmRgIGlzIG5vdCBhIGRhdGEgYXJyYXkuIFdoaWNoIHVzZXMgYHhBeGlzYCxcbiAgLy8gYHlBeGlzYCB0byBzcGVjaWZ5IHRoZSBjb29yZCBvbiBlYWNoIGRpbWVuc2lvblxuICAvLyBwYXJzZUZsb2F0IGZpcnN0IGJlY2F1c2UgaXRlbS54IGFuZCBpdGVtLnkgY2FuIGJlIHBlcmNlbnQgc3RyaW5nIGxpa2UgJzIwJSdcblxuICBpZiAoaXRlbSAmJiAhaGFzWEFuZFkoaXRlbSkgJiYgIXpyVXRpbC5pc0FycmF5KGl0ZW0uY29vcmQpICYmIGNvb3JkU3lzKSB7XG4gICAgdmFyIGRpbXMgPSBjb29yZFN5cy5kaW1lbnNpb25zO1xuICAgIHZhciBheGlzSW5mbyA9IGdldEF4aXNJbmZvKGl0ZW0sIGRhdGEsIGNvb3JkU3lzLCBzZXJpZXNNb2RlbCk7IC8vIENsb25lIHRoZSBvcHRpb25cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgeEF4aXMsIHlBeGlzLCByYWRpdXNBeGlzLCBhbmdsZUF4aXMsIGdlb0Nvb3JkIHRvIHZhbHVlXG5cbiAgICBpdGVtID0genJVdGlsLmNsb25lKGl0ZW0pO1xuXG4gICAgaWYgKGl0ZW0udHlwZSAmJiBtYXJrZXJUeXBlQ2FsY3VsYXRvcltpdGVtLnR5cGVdICYmIGF4aXNJbmZvLmJhc2VBeGlzICYmIGF4aXNJbmZvLnZhbHVlQXhpcykge1xuICAgICAgdmFyIG90aGVyQ29vcmRJbmRleCA9IGluZGV4T2YoZGltcywgYXhpc0luZm8uYmFzZUF4aXMuZGltKTtcbiAgICAgIHZhciB0YXJnZXRDb29yZEluZGV4ID0gaW5kZXhPZihkaW1zLCBheGlzSW5mby52YWx1ZUF4aXMuZGltKTtcbiAgICAgIGl0ZW0uY29vcmQgPSBtYXJrZXJUeXBlQ2FsY3VsYXRvcltpdGVtLnR5cGVdKGRhdGEsIGF4aXNJbmZvLmJhc2VEYXRhRGltLCBheGlzSW5mby52YWx1ZURhdGFEaW0sIG90aGVyQ29vcmRJbmRleCwgdGFyZ2V0Q29vcmRJbmRleCk7IC8vIEZvcmNlIHRvIHVzZSB0aGUgdmFsdWUgb2YgY2FsY3VsYXRlZCB2YWx1ZS5cblxuICAgICAgaXRlbS52YWx1ZSA9IGl0ZW0uY29vcmRbdGFyZ2V0Q29vcmRJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZJWE1FIE9ubHkgaGFzIG9uZSBvZiB4QXhpcyBhbmQgeUF4aXMuXG4gICAgICB2YXIgY29vcmQgPSBbaXRlbS54QXhpcyAhPSBudWxsID8gaXRlbS54QXhpcyA6IGl0ZW0ucmFkaXVzQXhpcywgaXRlbS55QXhpcyAhPSBudWxsID8gaXRlbS55QXhpcyA6IGl0ZW0uYW5nbGVBeGlzXTsgLy8gRWFjaCBjb29yZCBzdXBwb3J0IG1heCwgbWluLCBhdmVyYWdlXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIGlmIChtYXJrZXJUeXBlQ2FsY3VsYXRvcltjb29yZFtpXV0pIHtcbiAgICAgICAgICB2YXIgZGF0YURpbSA9IHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGRpbXNbaV0pWzBdO1xuICAgICAgICAgIGNvb3JkW2ldID0gbnVtQ2FsY3VsYXRlKGRhdGEsIGRhdGFEaW0sIGNvb3JkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpdGVtLmNvb3JkID0gY29vcmQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGl0ZW07XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNJbmZvKGl0ZW0sIGRhdGEsIGNvb3JkU3lzLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgcmV0ID0ge307XG5cbiAgaWYgKGl0ZW0udmFsdWVJbmRleCAhPSBudWxsIHx8IGl0ZW0udmFsdWVEaW0gIT0gbnVsbCkge1xuICAgIHJldC52YWx1ZURhdGFEaW0gPSBpdGVtLnZhbHVlSW5kZXggIT0gbnVsbCA/IGRhdGEuZ2V0RGltZW5zaW9uKGl0ZW0udmFsdWVJbmRleCkgOiBpdGVtLnZhbHVlRGltO1xuICAgIHJldC52YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKHNlcmllc01vZGVsLmRhdGFEaW1Ub0Nvb3JkRGltKHJldC52YWx1ZURhdGFEaW0pKTtcbiAgICByZXQuYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMocmV0LnZhbHVlQXhpcyk7XG4gICAgcmV0LmJhc2VEYXRhRGltID0gc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0ocmV0LmJhc2VBeGlzLmRpbSlbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0LmJhc2VBeGlzID0gc2VyaWVzTW9kZWwuZ2V0QmFzZUF4aXMoKTtcbiAgICByZXQudmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKHJldC5iYXNlQXhpcyk7XG4gICAgcmV0LmJhc2VEYXRhRGltID0gc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0ocmV0LmJhc2VBeGlzLmRpbSlbMF07XG4gICAgcmV0LnZhbHVlRGF0YURpbSA9IHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKHJldC52YWx1ZUF4aXMuZGltKVswXTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG4vKipcbiAqIEZpbHRlciBkYXRhIHdoaWNoIGlzIG91dCBvZiBjb29yZGluYXRlU3lzdGVtIHJhbmdlXG4gKiBbZGF0YUZpbHRlciBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IFtjb29yZFN5c11cbiAqIEBwYXJhbSAge09iamVjdH0gaXRlbVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRhdGFGaWx0ZXIoY29vcmRTeXMsIGl0ZW0pIHtcbiAgLy8gQWx3YWx5cyByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBubyBjb29yZFN5c1xuICByZXR1cm4gY29vcmRTeXMgJiYgY29vcmRTeXMuY29udGFpbkRhdGEgJiYgaXRlbS5jb29yZCAmJiAhaGFzWE9yWShpdGVtKSA/IGNvb3JkU3lzLmNvbnRhaW5EYXRhKGl0ZW0uY29vcmQpIDogdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGltVmFsdWVHZXR0ZXIoaXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAvLyB4LCB5LCByYWRpdXMsIGFuZ2xlXG4gIGlmIChkaW1JbmRleCA8IDIpIHtcbiAgICByZXR1cm4gaXRlbS5jb29yZCAmJiBpdGVtLmNvb3JkW2RpbUluZGV4XTtcbiAgfVxuXG4gIHJldHVybiBpdGVtLnZhbHVlO1xufVxuXG5mdW5jdGlvbiBudW1DYWxjdWxhdGUoZGF0YSwgdmFsdWVEYXRhRGltLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnYXZlcmFnZScpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIGRhdGEuZWFjaCh2YWx1ZURhdGFEaW0sIGZ1bmN0aW9uICh2YWwsIGlkeCkge1xuICAgICAgaWYgKCFpc05hTih2YWwpKSB7XG4gICAgICAgIHN1bSArPSB2YWw7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHN1bSAvIGNvdW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkYXRhLmdldERhdGFFeHRlbnQodmFsdWVEYXRhRGltLCB0cnVlKVt0eXBlID09PSAnbWF4JyA/IDEgOiAwXTtcbiAgfVxufVxuXG5leHBvcnRzLmRhdGFUcmFuc2Zvcm0gPSBkYXRhVHJhbnNmb3JtO1xuZXhwb3J0cy5nZXRBeGlzSW5mbyA9IGdldEF4aXNJbmZvO1xuZXhwb3J0cy5kYXRhRmlsdGVyID0gZGF0YUZpbHRlcjtcbmV4cG9ydHMuZGltVmFsdWVHZXR0ZXIgPSBkaW1WYWx1ZUdldHRlcjtcbmV4cG9ydHMubnVtQ2FsY3VsYXRlID0gbnVtQ2FsY3VsYXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvbWFya2VySGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIF9kZWZhdWx0ID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ21hcmtlcicsXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBNYXJrbGluZSBncm91cGVkIGJ5IHNlcmllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbC5IYXNoTWFwfVxuICAgICAqL1xuICAgIHRoaXMubWFya2VyR3JvdXBNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChtYXJrZXJNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIG1hcmtlckdyb3VwTWFwID0gdGhpcy5tYXJrZXJHcm91cE1hcDtcbiAgICBtYXJrZXJHcm91cE1hcC5lYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtLl9fa2VlcCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHZhciBtYXJrZXJNb2RlbEtleSA9IHRoaXMudHlwZSArICdNb2RlbCc7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIG1hcmtlck1vZGVsID0gc2VyaWVzTW9kZWxbbWFya2VyTW9kZWxLZXldO1xuICAgICAgbWFya2VyTW9kZWwgJiYgdGhpcy5yZW5kZXJTZXJpZXMoc2VyaWVzTW9kZWwsIG1hcmtlck1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgIH0sIHRoaXMpO1xuICAgIG1hcmtlckdyb3VwTWFwLmVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICFpdGVtLl9fa2VlcCAmJiB0aGlzLmdyb3VwLnJlbW92ZShpdGVtLmdyb3VwKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcbiAgcmVuZGVyU2VyaWVzOiBmdW5jdGlvbiAoKSB7fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBBVFRSID0gJ1xcMF9lY19oaXN0X3N0b3JlJztcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTbmFwc2hvdCB7ZGF0YVpvb21JZCwgYmF0Y2g6IFtwYXlsb2FkSW5mbywgLi4uXX1cbiAqL1xuXG5mdW5jdGlvbiBwdXNoKGVjTW9kZWwsIG5ld1NuYXBzaG90KSB7XG4gIHZhciBzdG9yZSA9IGdpdmVTdG9yZShlY01vZGVsKTsgLy8gSWYgcHJldmlvdXMgZGF0YVpvb20gY2FuIG5vdCBiZSBmb3VuZCxcbiAgLy8gY29tcGxldGUgYW4gcmFuZ2Ugd2l0aCBjdXJyZW50IHJhbmdlLlxuXG4gIGVhY2gobmV3U25hcHNob3QsIGZ1bmN0aW9uIChiYXRjaEl0ZW0sIGRhdGFab29tSWQpIHtcbiAgICB2YXIgaSA9IHN0b3JlLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBzbmFwc2hvdCA9IHN0b3JlW2ldO1xuXG4gICAgICBpZiAoc25hcHNob3RbZGF0YVpvb21JZF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICAvLyBObyBvcmlnaW4gcmFuZ2Ugc2V0LCBjcmVhdGUgb25lIGJ5IGN1cnJlbnQgcmFuZ2UuXG4gICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgbWFpblR5cGU6ICdkYXRhWm9vbScsXG4gICAgICAgIHN1YlR5cGU6ICdzZWxlY3QnLFxuICAgICAgICBpZDogZGF0YVpvb21JZFxuICAgICAgfSlbMF07XG5cbiAgICAgIGlmIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgIHZhciBwZXJjZW50UmFuZ2UgPSBkYXRhWm9vbU1vZGVsLmdldFBlcmNlbnRSYW5nZSgpO1xuICAgICAgICBzdG9yZVswXVtkYXRhWm9vbUlkXSA9IHtcbiAgICAgICAgICBkYXRhWm9vbUlkOiBkYXRhWm9vbUlkLFxuICAgICAgICAgIHN0YXJ0OiBwZXJjZW50UmFuZ2VbMF0sXG4gICAgICAgICAgZW5kOiBwZXJjZW50UmFuZ2VbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzdG9yZS5wdXNoKG5ld1NuYXBzaG90KTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEByZXR1cm4ge09iamVjdH0gc25hcHNob3RcbiAqL1xuXG5cbmZ1bmN0aW9uIHBvcChlY01vZGVsKSB7XG4gIHZhciBzdG9yZSA9IGdpdmVTdG9yZShlY01vZGVsKTtcbiAgdmFyIGhlYWQgPSBzdG9yZVtzdG9yZS5sZW5ndGggLSAxXTtcbiAgc3RvcmUubGVuZ3RoID4gMSAmJiBzdG9yZS5wb3AoKTsgLy8gRmluZCB0b3AgZm9yIGFsbCBkYXRhWm9vbS5cblxuICB2YXIgc25hcHNob3QgPSB7fTtcbiAgZWFjaChoZWFkLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBkYXRhWm9vbUlkKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0b3JlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYmF0Y2hJdGVtID0gc3RvcmVbaV1bZGF0YVpvb21JZF07XG5cbiAgICAgIGlmIChiYXRjaEl0ZW0pIHtcbiAgICAgICAgc25hcHNob3RbZGF0YVpvb21JZF0gPSBiYXRjaEl0ZW07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzbmFwc2hvdDtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsZWFyKGVjTW9kZWwpIHtcbiAgZWNNb2RlbFtBVFRSXSA9IG51bGw7XG59XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHJlY29yZHMuIGFsd2F5cyA+PSAxLlxuICovXG5cblxuZnVuY3Rpb24gY291bnQoZWNNb2RlbCkge1xuICByZXR1cm4gZ2l2ZVN0b3JlKGVjTW9kZWwpLmxlbmd0aDtcbn1cbi8qKlxuICogW3trZXk6IGRhdGFab29tSWQsIHZhbHVlOiB7ZGF0YVpvb21JZCwgcmFuZ2V9fSwgLi4uXVxuICogSGlzdG9yeSBsZW5ndGggb2YgZWFjaCBkYXRhWm9vbSBtYXkgYmUgZGlmZmVyZW50LlxuICogdGhpcy5faGlzdG9yeVswXSBpcyB1c2VkIHRvIHN0b3JlIG9yaWdpbiByYW5nZS5cbiAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdpdmVTdG9yZShlY01vZGVsKSB7XG4gIHZhciBzdG9yZSA9IGVjTW9kZWxbQVRUUl07XG5cbiAgaWYgKCFzdG9yZSkge1xuICAgIHN0b3JlID0gZWNNb2RlbFtBVFRSXSA9IFt7fV07XG4gIH1cblxuICByZXR1cm4gc3RvcmU7XG59XG5cbmV4cG9ydHMucHVzaCA9IHB1c2g7XG5leHBvcnRzLnBvcCA9IHBvcDtcbmV4cG9ydHMuY2xlYXIgPSBjbGVhcjtcbmV4cG9ydHMuY291bnQgPSBjb3VudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcIi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBEcmFnZ2FibGUgPSByZXF1aXJlKFwiLi9taXhpbi9EcmFnZ2FibGVcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuL21peGluL0V2ZW50ZnVsXCIpO1xuXG4vKipcbiAqIEhhbmRsZXJcbiAqIEBtb2R1bGUgenJlbmRlci9IYW5kbGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoc2hlbnlpLjkxNEBnbWFpbC5jb20pXG4gKi9cbnZhciBTSUxFTlQgPSAnc2lsZW50JztcblxuZnVuY3Rpb24gbWFrZUV2ZW50UGFja2V0KGV2ZVR5cGUsIHRhcmdldEluZm8sIGV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXZlVHlwZSxcbiAgICBldmVudDogZXZlbnQsXG4gICAgLy8gdGFyZ2V0IGNhbiBvbmx5IGJlIGFuIGVsZW1lbnQgdGhhdCBpcyBub3Qgc2lsZW50LlxuICAgIHRhcmdldDogdGFyZ2V0SW5mby50YXJnZXQsXG4gICAgLy8gdG9wVGFyZ2V0IGNhbiBiZSBhIHNpbGVudCBlbGVtZW50LlxuICAgIHRvcFRhcmdldDogdGFyZ2V0SW5mby50b3BUYXJnZXQsXG4gICAgY2FuY2VsQnViYmxlOiBmYWxzZSxcbiAgICBvZmZzZXRYOiBldmVudC56clgsXG4gICAgb2Zmc2V0WTogZXZlbnQuenJZLFxuICAgIGdlc3R1cmVFdmVudDogZXZlbnQuZ2VzdHVyZUV2ZW50LFxuICAgIHBpbmNoWDogZXZlbnQucGluY2hYLFxuICAgIHBpbmNoWTogZXZlbnQucGluY2hZLFxuICAgIHBpbmNoU2NhbGU6IGV2ZW50LnBpbmNoU2NhbGUsXG4gICAgd2hlZWxEZWx0YTogZXZlbnQuenJEZWx0YSxcbiAgICB6ckJ5VG91Y2g6IGV2ZW50LnpyQnlUb3VjaCxcbiAgICB3aGljaDogZXZlbnQud2hpY2hcbiAgfTtcbn1cblxuZnVuY3Rpb24gRW1wdHlQcm94eSgpIHt9XG5cbkVtcHR5UHJveHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGhhbmRsZXJOYW1lcyA9IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXTtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0hhbmRsZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZSBTdG9yYWdlIGluc3RhbmNlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyIFBhaW50ZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2RvbS9IYW5kbGVyUHJveHl9IHByb3h5IEhhbmRsZXJQcm94eSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhaW50ZXJSb290IHBhaW50ZXIucm9vdCAobm90IHBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkpLlxuICovXG5cbnZhciBIYW5kbGVyID0gZnVuY3Rpb24gKHN0b3JhZ2UsIHBhaW50ZXIsIHByb3h5LCBwYWludGVyUm9vdCkge1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuICB0aGlzLnBhaW50ZXJSb290ID0gcGFpbnRlclJvb3Q7XG4gIHByb3h5ID0gcHJveHkgfHwgbmV3IEVtcHR5UHJveHkoKTtcbiAgLyoqXG4gICAqIFByb3h5IG9mIGV2ZW50LiBjYW4gYmUgRG9tLCBXZWJHTFN1cmZhY2UsIGV0Yy5cbiAgICovXG5cbiAgdGhpcy5wcm94eSA9IHByb3h5OyAvLyBBdHRhY2ggaGFuZGxlclxuXG4gIHByb3h5LmhhbmRsZXIgPSB0aGlzO1xuICAvKipcbiAgICoge3RhcmdldCwgdG9wVGFyZ2V0LCB4LCB5fVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9ob3ZlcmVkID0ge307XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFRvdWNoTW9tZW50O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFg7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl9sYXN0WTtcbiAgRHJhZ2dhYmxlLmNhbGwodGhpcyk7XG4gIHV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcHJveHkub24gJiYgcHJveHkub24obmFtZSwgdGhpc1tuYW1lXSwgdGhpcyk7XG4gIH0sIHRoaXMpO1xufTtcblxuSGFuZGxlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYW5kbGVyLFxuICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB4ID0gZXZlbnQuenJYO1xuICAgIHZhciB5ID0gZXZlbnQuenJZO1xuICAgIHZhciBsYXN0SG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQ7XG4gICAgdmFyIGxhc3RIb3ZlcmVkVGFyZ2V0ID0gbGFzdEhvdmVyZWQudGFyZ2V0OyAvLyBJZiBsYXN0SG92ZXJlZFRhcmdldCBpcyByZW1vdmVkIGZyb20genIgKGRldGVjdGVkIGJ5ICdfX3pyJykgYnkgc29tZSBBUEkgY2FsbFxuICAgIC8vIChsaWtlICdzZXRPcHRpb24nIG9yICdkaXNwYXRjaEFjdGlvbicpIGluIGV2ZW50IGhhbmRsZXJzLCB3ZSBzaG91bGQgZmluZFxuICAgIC8vIGxhc3RIb3ZlcmVkIGFnYWluIGhlcmUuIE90aGVyd2lzZSAnbW91c2VvdXQnIGNhbiBub3QgYmUgdHJpZ2dlcmVkIG5vcm1hbGx5LlxuICAgIC8vIFNlZSAjNjE5OC5cblxuICAgIGlmIChsYXN0SG92ZXJlZFRhcmdldCAmJiAhbGFzdEhvdmVyZWRUYXJnZXQuX196cikge1xuICAgICAgbGFzdEhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihsYXN0SG92ZXJlZC54LCBsYXN0SG92ZXJlZC55KTtcbiAgICAgIGxhc3RIb3ZlcmVkVGFyZ2V0ID0gbGFzdEhvdmVyZWQudGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBob3ZlcmVkID0gdGhpcy5faG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKHgsIHkpO1xuICAgIHZhciBob3ZlcmVkVGFyZ2V0ID0gaG92ZXJlZC50YXJnZXQ7XG4gICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGhvdmVyZWRUYXJnZXQgPyBob3ZlcmVkVGFyZ2V0LmN1cnNvciA6ICdkZWZhdWx0Jyk7IC8vIE1vdXNlIG91dCBvbiBwcmV2aW91cyBob3ZlcmVkIGVsZW1lbnRcblxuICAgIGlmIChsYXN0SG92ZXJlZFRhcmdldCAmJiBob3ZlcmVkVGFyZ2V0ICE9PSBsYXN0SG92ZXJlZFRhcmdldCkge1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChsYXN0SG92ZXJlZCwgJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgIH0gLy8gTW91c2UgbW92aW5nIG9uIG9uZSBlbGVtZW50XG5cblxuICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgJ21vdXNlbW92ZScsIGV2ZW50KTsgLy8gTW91c2Ugb3ZlciBvbiBhIG5ldyBlbGVtZW50XG5cbiAgICBpZiAoaG92ZXJlZFRhcmdldCAmJiBob3ZlcmVkVGFyZ2V0ICE9PSBsYXN0SG92ZXJlZFRhcmdldCkge1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2VvdmVyJywgZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQodGhpcy5faG92ZXJlZCwgJ21vdXNlb3V0JywgZXZlbnQpOyAvLyBUaGVyZSBtaWdodCBiZSBzb21lIGRvbXMgY3JlYXRlZCBieSB1cHBlciBsYXllciBhcHBsaWNhdGlvblxuICAgIC8vIGF0IHRoZSBzYW1lIGxldmVsIG9mIHBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkgKGUuZy4sIHRvb2x0aXBcbiAgICAvLyBkb20gY3JlYXRlZCBieSBlY2hhcnRzKSwgd2hlcmUgJ2dsb2JhbG91dCcgZXZlbnQgc2hvdWxkIG5vdFxuICAgIC8vIGJlIHRyaWdnZXJlZCB3aGVuIG1vdXNlIGVudGVycyB0aGVzZSBkb21zLiAoQnV0ICdtb3VzZW91dCdcbiAgICAvLyBzaG91bGQgYmUgdHJpZ2dlcmVkIGF0IHRoZSBvcmlnaW5hbCBob3ZlcmVkIGVsZW1lbnQgYXMgdXN1YWwpLlxuXG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICB2YXIgaW5uZXJEb207XG5cbiAgICBkbyB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfSB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkgJiYgIShpbm5lckRvbSA9IGVsZW1lbnQgPT09IHRoaXMucGFpbnRlclJvb3QpKTtcblxuICAgICFpbm5lckRvbSAmJiB0aGlzLnRyaWdnZXIoJ2dsb2JhbG91dCcsIHtcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNpemVcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5faG92ZXJlZCA9IHt9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICovXG4gIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXNbZXZlbnROYW1lXTtcbiAgICBoYW5kbGVyICYmIGhhbmRsZXIuY2FsbCh0aGlzLCBldmVudEFyZ3MpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwb3NlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcm94eS5kaXNwb3NlKCk7XG4gICAgdGhpcy5zdG9yYWdlID0gdGhpcy5wcm94eSA9IHRoaXMucGFpbnRlciA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiuvue9rum7mOiupOeahGN1cnNvciBzdHlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgKi9cbiAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOS6i+S7tuWIhuWPkeS7o+eQhlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0SW5mbyB7dGFyZ2V0LCB0b3BUYXJnZXR9IOebruagh+WbvuW9ouWFg+e0oFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIOS6i+S7tuWQjeensFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu25a+56LGhXG4gICAqL1xuICBkaXNwYXRjaFRvRWxlbWVudDogZnVuY3Rpb24gKHRhcmdldEluZm8sIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0YXJnZXRJbmZvID0gdGFyZ2V0SW5mbyB8fCB7fTtcbiAgICB2YXIgZWwgPSB0YXJnZXRJbmZvLnRhcmdldDtcblxuICAgIGlmIChlbCAmJiBlbC5zaWxlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRIYW5kbGVyID0gJ29uJyArIGV2ZW50TmFtZTtcbiAgICB2YXIgZXZlbnRQYWNrZXQgPSBtYWtlRXZlbnRQYWNrZXQoZXZlbnROYW1lLCB0YXJnZXRJbmZvLCBldmVudCk7XG5cbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIGVsW2V2ZW50SGFuZGxlcl0gJiYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSA9IGVsW2V2ZW50SGFuZGxlcl0uY2FsbChlbCwgZXZlbnRQYWNrZXQpKTtcbiAgICAgIGVsLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICBlbCA9IGVsLnBhcmVudDtcblxuICAgICAgaWYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgLy8g5YaS5rOh5Yiw6aG257qnIHpyZW5kZXIg5a+56LGhXG4gICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7IC8vIOWIhuWPkeS6i+S7tuWIsOeUqOaIt+iHquWumuS5ieWxglxuICAgICAgLy8g55So5oi35pyJ5Y+v6IO95Zyo5YWo5bGAIGNsaWNrIOS6i+S7tuS4rSBkaXNwb3Nl77yM5omA5Lul6ZyA6KaB5Yik5pat5LiLIHBhaW50ZXIg5piv5ZCm5a2Y5ZyoXG5cbiAgICAgIHRoaXMucGFpbnRlciAmJiB0aGlzLnBhaW50ZXIuZWFjaE90aGVyTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGF5ZXJbZXZlbnRIYW5kbGVyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbGF5ZXJbZXZlbnRIYW5kbGVyXS5jYWxsKGxheWVyLCBldmVudFBhY2tldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5ZXIudHJpZ2dlcikge1xuICAgICAgICAgIGxheWVyLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlfSBleGNsdWRlXG4gICAqIEByZXR1cm4ge21vZGVsOnpyZW5kZXIvRWxlbWVudH1cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSwgZXhjbHVkZSkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XG4gICAgdmFyIG91dCA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgaG92ZXJDaGVja1Jlc3VsdDtcblxuICAgICAgaWYgKGxpc3RbaV0gIT09IGV4Y2x1ZGUgLy8gZ2V0RGlzcGxheUxpc3QgbWF5IGluY2x1ZGUgaWdub3JlZCBpdGVtIGluIFZNTCBtb2RlXG4gICAgICAmJiAhbGlzdFtpXS5pZ25vcmUgJiYgKGhvdmVyQ2hlY2tSZXN1bHQgPSBpc0hvdmVyKGxpc3RbaV0sIHgsIHkpKSkge1xuICAgICAgICAhb3V0LnRvcFRhcmdldCAmJiAob3V0LnRvcFRhcmdldCA9IGxpc3RbaV0pO1xuXG4gICAgICAgIGlmIChob3ZlckNoZWNrUmVzdWx0ICE9PSBTSUxFTlQpIHtcbiAgICAgICAgICBvdXQudGFyZ2V0ID0gbGlzdFtpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn07IC8vIENvbW1vbiBoYW5kbGVyc1xuXG51dGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIEhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gRmluZCBob3ZlciBhZ2FpbiB0byBhdm9pZCBjbGljayBldmVudCBpcyBkaXNwYXRjaGVkIG1hbnVhbGx5LiBPciBjbGljayBpcyB0cmlnZ2VyZWQgd2l0aG91dCBtb3VzZW92ZXJcbiAgICB2YXIgaG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZKTtcbiAgICB2YXIgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuXG4gICAgaWYgKG5hbWUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICB0aGlzLl9kb3duRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgICAgdGhpcy5fZG93blBvaW50ID0gW2V2ZW50LnpyWCwgZXZlbnQuenJZXTsgLy8gSW4gY2FzZSBjbGljayB0cmlnZ2VyZWQgYmVmb3JlIG1vdXNldXBcblxuICAgICAgdGhpcy5fdXBFbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnbW9zdWV1cCcpIHtcbiAgICAgIHRoaXMuX3VwRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgaWYgKHRoaXMuX2Rvd25FbCAhPT0gdGhpcy5fdXBFbCAvLyBPcmlnaW5hbCBjbGljayBldmVudCBpcyB0cmlnZ2VyZWQgb24gdGhlIHdob2xlIGNhbnZhcyBlbGVtZW50LFxuICAgICAgLy8gaW5jbHVkaW5nIHRoZSBjYXNlIHRoYXQgYG1vdXNlZG93bmAgLSBgbW91c2Vtb3ZlYCAtIGBtb3VzZXVwYCxcbiAgICAgIC8vIHdoaWNoIHNob3VsZCBiZSBmaWx0ZXJlZCwgb3RoZXJ3aXNlIGl0IHdpbGwgYnJpbmcgdHJvdWJsZSB0b1xuICAgICAgLy8gcGFuIGFuZCB6b29tLlxuICAgICAgfHwgIXRoaXMuX2Rvd25Qb2ludCAvLyBBcmJpdHJhcnkgdmFsdWVcbiAgICAgIHx8IHZlYzIuZGlzdCh0aGlzLl9kb3duUG9pbnQsIFtldmVudC56clgsIGV2ZW50LnpyWV0pID4gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCBuYW1lLCBldmVudCk7XG4gIH07XG59KTtcblxuZnVuY3Rpb24gaXNIb3ZlcihkaXNwbGF5YWJsZSwgeCwgeSkge1xuICBpZiAoZGlzcGxheWFibGVbZGlzcGxheWFibGUucmVjdEhvdmVyID8gJ3JlY3RDb250YWluJyA6ICdjb250YWluJ10oeCwgeSkpIHtcbiAgICB2YXIgZWwgPSBkaXNwbGF5YWJsZTtcbiAgICB2YXIgaXNTaWxlbnQ7XG5cbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIC8vIElmIGNsaXBwZWQgYnkgYW5jZXN0b3IuXG4gICAgICAvLyBGSVhNRTogSWYgY2xpcFBhdGggaGFzIG5laXRoZXIgc3Ryb2tlIG5vciBmaWxsLFxuICAgICAgLy8gZWwuY2xpcFBhdGguY29udGFpbih4LCB5KSB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UuXG4gICAgICBpZiAoZWwuY2xpcFBhdGggJiYgIWVsLmNsaXBQYXRoLmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwuc2lsZW50KSB7XG4gICAgICAgIGlzU2lsZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZWwgPSBlbC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzU2lsZW50ID8gU0lMRU5UIDogdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudXRpbC5taXhpbihIYW5kbGVyLCBFdmVudGZ1bCk7XG51dGlsLm1peGluKEhhbmRsZXIsIERyYWdnYWJsZSk7XG52YXIgX2RlZmF1bHQgPSBIYW5kbGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9IYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBUT0RPIERyYWdnYWJsZSBmb3IgZ3JvdXBcbi8vIEZJWE1FIERyYWdnYWJsZSBvbiBlbGVtZW50IHdoaWNoIGhhcyBwYXJlbnQgcm90YXRpb24gb3Igc2NhbGVcbmZ1bmN0aW9uIERyYWdnYWJsZSgpIHtcbiAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7IC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG4gIC8vIHRoaXMuX3ggPSAwO1xuICAvLyB0aGlzLl95ID0gMDtcbn1cblxuRHJhZ2dhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcbiAgX2RyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSBlLnRhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCAmJiBkcmFnZ2luZ1RhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLl94ID0gZS5vZmZzZXRYO1xuICAgICAgdGhpcy5feSA9IGUub2Zmc2V0WTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ3N0YXJ0JywgZS5ldmVudCk7XG4gICAgfVxuICB9LFxuICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgdmFyIGR5ID0geSAtIHRoaXMuX3k7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZycsIGUuZXZlbnQpO1xuICAgICAgdmFyIGRyb3BUYXJnZXQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBkcmFnZ2luZ1RhcmdldCkudGFyZ2V0O1xuICAgICAgdmFyIGxhc3REcm9wVGFyZ2V0ID0gdGhpcy5fZHJvcFRhcmdldDtcbiAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgIT09IGRyb3BUYXJnZXQpIHtcbiAgICAgICAgaWYgKGxhc3REcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShsYXN0RHJvcFRhcmdldCwgZSksICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcm9wVGFyZ2V0LCBlKSwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWdlbmQnLCBlLmV2ZW50KTtcblxuICAgIGlmICh0aGlzLl9kcm9wVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKHRoaXMuX2Ryb3BUYXJnZXQsIGUpLCAnZHJvcCcsIGUuZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyYW0odGFyZ2V0LCBlKSB7XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgdG9wVGFyZ2V0OiBlICYmIGUudG9wVGFyZ2V0XG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IERyYWdnYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuL2NvcmUvZW52XCIpO1xuXG52YXIgR3JvdXAgPSByZXF1aXJlKFwiLi9jb250YWluZXIvR3JvdXBcIik7XG5cbnZhciB0aW1zb3J0ID0gcmVxdWlyZShcIi4vY29yZS90aW1zb3J0XCIpO1xuXG4vKipcbiAqIFN0b3JhZ2XlhoXlrrnku5PlupPmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9TdG9yYWdlXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcvKVxuICovXG4vLyBVc2UgdGltc29ydCBiZWNhdXNlIGluIG1vc3QgY2FzZSBlbGVtZW50cyBhcmUgcGFydGlhbGx5IHNvcnRlZFxuLy8gaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcGlzc2FuZy9qcjR4N21kbS84L1xuZnVuY3Rpb24gc2hhcGVDb21wYXJlRnVuYyhhLCBiKSB7XG4gIGlmIChhLnpsZXZlbCA9PT0gYi56bGV2ZWwpIHtcbiAgICBpZiAoYS56ID09PSBiLnopIHtcbiAgICAgIC8vIGlmIChhLnoyID09PSBiLnoyKSB7XG4gICAgICAvLyAgICAgLy8gRklYTUUgU2xvdyBoYXMgcmVuZGVyaWR4IGNvbXBhcmVcbiAgICAgIC8vICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwODgzNDIxL3NvcnRpbmctaW4tamF2YXNjcmlwdC1zaG91bGQtZXZlcnktY29tcGFyZS1mdW5jdGlvbi1oYXZlLWEtcmV0dXJuLTAtc3RhdGVtZW50XG4gICAgICAvLyAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNDdjY2U1NDRhMzFlZDU1NzdmZmUyOTYzZjY3YWNiNDE0NGVlMDIzMi9zcmMvanMvYXJyYXkuanMjTDEwMTJcbiAgICAgIC8vICAgICByZXR1cm4gYS5fX3JlbmRlcmlkeCAtIGIuX19yZW5kZXJpZHg7XG4gICAgICAvLyB9XG4gICAgICByZXR1cm4gYS56MiAtIGIuejI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEueiAtIGIuejtcbiAgfVxuXG4gIHJldHVybiBhLnpsZXZlbCAtIGIuemxldmVsO1xufVxuLyoqXG4gKiDlhoXlrrnku5PlupMgKE0pXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvU3RvcmFnZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIHRoaXMuX3Jvb3RzID0gW107XG4gIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbn07XG5cblN0b3JhZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU3RvcmFnZSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqXG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcm9vdHNbaV0udHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6L+U5Zue5omA5pyJ5Zu+5b2i55qE57uY5Yi26Zif5YiXXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZT1mYWxzZV0g5piv5ZCm5Zyo6L+U5Zue5YmN5pu05paw6K+l5pWw57uEXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uELCDlnKggdXBkYXRlIOS4uiB0cnVlIOeahOaXtuWAmeacieaViFxuICAgKlxuICAgKiDor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5wcm90b3R5cGUudXBkYXRlRGlzcGxheUxpc3R9XG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlPn1cbiAgICovXG4gIGdldERpc3BsYXlMaXN0OiBmdW5jdGlvbiAodXBkYXRlLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZURpc3BsYXlMaXN0KGluY2x1ZGVJZ25vcmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgfSxcblxuICAvKipcbiAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAqL1xuICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgdmFyIHJvb3RzID0gdGhpcy5fcm9vdHM7XG4gICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKHJvb3RzW2ldLCBudWxsLCBpbmNsdWRlSWdub3JlKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjsgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gICAgIGRpc3BsYXlMaXN0W2ldLl9fcmVuZGVyaWR4ID0gaTtcbiAgICAvLyB9XG4gICAgLy8gZGlzcGxheUxpc3Quc29ydChzaGFwZUNvbXBhcmVGdW5jKTtcblxuICAgIGVudi5jYW52YXNTdXBwb3J0ZWQgJiYgdGltc29ydChkaXNwbGF5TGlzdCwgc2hhcGVDb21wYXJlRnVuYyk7XG4gIH0sXG4gIF91cGRhdGVBbmRBZGREaXNwbGF5YWJsZTogZnVuY3Rpb24gKGVsLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpIHtcbiAgICBpZiAoZWwuaWdub3JlICYmICFpbmNsdWRlSWdub3JlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWwuYmVmb3JlVXBkYXRlKCk7XG5cbiAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgZWwudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZWwuYWZ0ZXJVcGRhdGUoKTtcbiAgICB2YXIgdXNlclNldENsaXBQYXRoID0gZWwuY2xpcFBhdGg7XG5cbiAgICBpZiAodXNlclNldENsaXBQYXRoKSB7XG4gICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgY2xpcFBhdGhzID0gY2xpcFBhdGhzLnNsaWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGlwUGF0aHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRDbGlwUGF0aCA9IHVzZXJTZXRDbGlwUGF0aDtcbiAgICAgIHZhciBwYXJlbnRDbGlwUGF0aCA9IGVsOyAvLyBSZWN1cnNpdmVseSBhZGQgY2xpcCBwYXRoXG5cbiAgICAgIHdoaWxlIChjdXJyZW50Q2xpcFBhdGgpIHtcbiAgICAgICAgLy8gY2xpcFBhdGgg55qE5Y+Y5o2i5piv5Z+65LqO5L2/55So6L+Z5LiqIGNsaXBQYXRoIOeahOWFg+e0oFxuICAgICAgICBjdXJyZW50Q2xpcFBhdGgucGFyZW50ID0gcGFyZW50Q2xpcFBhdGg7XG4gICAgICAgIGN1cnJlbnRDbGlwUGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgY2xpcFBhdGhzLnB1c2goY3VycmVudENsaXBQYXRoKTtcbiAgICAgICAgcGFyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGg7XG4gICAgICAgIGN1cnJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aC5jbGlwUGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWwuaXNHcm91cCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldOyAvLyBGb3JjZSB0byBtYXJrIGFzIGRpcnR5IGlmIGdyb3VwIGlzIGRpcnR5XG4gICAgICAgIC8vIEZJWE1FIF9fZGlydHlQYXRoID9cblxuICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgIGNoaWxkLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUoY2hpbGQsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSk7XG4gICAgICB9IC8vIE1hcmsgZ3JvdXAgY2xlYW4gaGVyZVxuXG5cbiAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuX19jbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdFt0aGlzLl9kaXNwbGF5TGlzdExlbisrXSA9IGVsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cCnliLDmoLnoioLngrlcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgYWRkUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLl9fc3RvcmFnZSA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICBlbC5hZGRDaGlsZHJlblRvU3RvcmFnZSh0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFRvU3RvcmFnZShlbCk7XG5cbiAgICB0aGlzLl9yb290cy5wdXNoKGVsKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5oyH5a6a55qE5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cClcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtlbF0g5aaC5p6c5Li656m65riF56m65pW05LiqU3RvcmFnZVxuICAgKi9cbiAgZGVsUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgIC8vIOS4jeaMh+WummVs5riF56m6XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdHNbaV07XG5cbiAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgIHJvb3QuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yb290cyA9IFtdO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5kZWxSb290KGVsW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fcm9vdHMsIGVsKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgdGhpcy5kZWxGcm9tU3RvcmFnZShlbCk7XG5cbiAgICAgIHRoaXMuX3Jvb3RzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBlbC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYWRkVG9TdG9yYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgIGVsLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGVsRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuX19zdG9yYWdlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5riF56m65bm25LiU6YeK5pS+U3RvcmFnZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlbmRlckxpc3QgPSB0aGlzLl9yb290cyA9IG51bGw7XG4gIH0sXG4gIGRpc3BsYXlhYmxlU29ydEZ1bmM6IHNoYXBlQ29tcGFyZUZ1bmNcbn07XG52YXIgX2RlZmF1bHQgPSBTdG9yYWdlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9TdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQW5pbWF0b3IgPSByZXF1aXJlKFwiLi4vYW5pbWF0aW9uL0FuaW1hdG9yXCIpO1xuXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2NvcmUvbG9nXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gX3V0aWwuaXNGdW5jdGlvbjtcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xudmFyIGlzQXJyYXlMaWtlID0gX3V0aWwuaXNBcnJheUxpa2U7XG52YXIgaW5kZXhPZiA9IF91dGlsLmluZGV4T2Y7XG5cbi8qKlxuICogQGFsaWFzIG1vZHVlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBBbmltYXRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3I+fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHRoaXMuYW5pbWF0b3JzID0gW107XG59O1xuXG5BbmltYXRhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEFuaW1hdGFibGUsXG5cbiAgLyoqXG4gICAqIOWKqOeUu1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBmZXRjaCB2YWx1ZSBmcm9tIG9iamVjdCwgbGlrZSAnYS5iLmMnLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29wXSBXaGV0aGVyIHRvIGxvb3AgYW5pbWF0aW9uLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqIEBleGFtcGxlOlxuICAgKiAgICAgZWwuYW5pbWF0ZSgnc3R5bGUnLCBmYWxzZSlcbiAgICogICAgICAgICAud2hlbigxMDAwLCB7eDogMTB9IClcbiAgICogICAgICAgICAuZG9uZShmdW5jdGlvbigpeyAvLyBBbmltYXRpb24gZG9uZSB9KVxuICAgKiAgICAgICAgIC5zdGFydCgpXG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbiAocGF0aCwgbG9vcCkge1xuICAgIHZhciB0YXJnZXQ7XG4gICAgdmFyIGFuaW1hdGluZ1NoYXBlID0gZmFsc2U7XG4gICAgdmFyIGVsID0gdGhpcztcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdmFyIHBhdGhTcGxpdHRlZCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgIHZhciBwcm9wID0gZWw7IC8vIElmIGFuaW1hdGluZyBzaGFwZVxuXG4gICAgICBhbmltYXRpbmdTaGFwZSA9IHBhdGhTcGxpdHRlZFswXSA9PT0gJ3NoYXBlJztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoU3BsaXR0ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcCA9IHByb3BbcGF0aFNwbGl0dGVkW2ldXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgdGFyZ2V0ID0gcHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0ID0gZWw7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIGxvZygnUHJvcGVydHkgXCInICsgcGF0aCArICdcIiBpcyBub3QgZXhpc3RlZCBpbiBlbGVtZW50ICcgKyBlbC5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcbiAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGFyZ2V0LCBsb29wKTtcbiAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZWwuZGlydHkoYW5pbWF0aW5nU2hhcGUpO1xuICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRklYTUUgQW5pbWF0b3Igd2lsbCBub3QgYmUgcmVtb3ZlZCBpZiB1c2UgYEFuaW1hdG9yI3N0b3BgIHRvIHN0b3AgYW5pbWF0aW9uXG4gICAgICBhbmltYXRvcnMuc3BsaWNlKGluZGV4T2YoYW5pbWF0b3JzLCBhbmltYXRvciksIDEpO1xuICAgIH0pO1xuICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTsgLy8gSWYgYW5pbWF0ZSBhZnRlciBhZGRlZCB0byB0aGUgenJlbmRlclxuXG4gICAgaWYgKHpyKSB7XG4gICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i5Yqo55S7XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICovXG4gIHN0b3BBbmltYXRpb246IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYW5pbWF0b3JzW2ldLnN0b3AoZm9yd2FyZFRvTGFzdCk7XG4gICAgfVxuXG4gICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhdXRpb246IHRoaXMgbWV0aG9kIHdpbGwgc3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG4gICAqIFNvIGRvIG5vdCB1c2UgdGhpcyBtZXRob2QgdG8gb25lIGVsZW1lbnQgdHdpY2UgYmVmb3JlXG4gICAqIGFuaW1hdGlvbiBzdGFydHMsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF0gVGltZSBpbiBtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Vhc2luZz0nbGluZWFyJ11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmb3JjZUFuaW1hdGVdIFByZXZlbnQgc3RvcCBhbmltYXRpb24gYW5kIGNhbGxiYWNrXG4gICAqICAgICAgICBpbW1lZGllbnRseSB3aGVuIHRhcmdldCB2YWx1ZXMgYXJlIHRoZSBzYW1lIGFzIGN1cnJlbnQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgKlxuICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xuICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICogICAgICBzaGFwZToge1xuICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAqICAgICAgfSxcbiAgICogICAgICBzdHlsZToge1xuICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgKiAgICAgIH1cbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICovXG4gIC8vIFRPRE8gUmV0dXJuIGFuaW1hdGlvbiBrZXlcbiAgYW5pbWF0ZVRvOiBmdW5jdGlvbiAodGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjaywgZm9yY2VBbmltYXRlKSB7XG4gICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgaWYgKGlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICBlYXNpbmcgPSBkZWxheTtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGRlbGF5LCBjYWxsYmFjayk7XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihlYXNpbmcpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICBlYXNpbmcgPSAnbGluZWFyJztcbiAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgICAgIGNhbGxiYWNrID0gZGVsYXk7XG4gICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIGNhbGxiYWNrKVxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRpbWUpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRpbWU7XG4gICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldClcbiAgICAgICAgICBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfSAvLyBTdG9wIGFsbCBwcmV2aW91cyBhbmltYXRpb25zXG5cblxuICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuXG4gICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdygnJywgdGhpcywgdGFyZ2V0LCB0aW1lLCBkZWxheSk7IC8vIEFuaW1hdG9ycyBtYXkgYmUgcmVtb3ZlZCBpbW1lZGlhdGVseSBhZnRlciBzdGFydFxuICAgIC8vIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYW5pbWF0ZVxuXG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnMuc2xpY2UoKTtcbiAgICB2YXIgY291bnQgPSBhbmltYXRvcnMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGNvdW50LS07XG5cbiAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9IC8vIE5vIGFuaW1hdG9ycy4gVGhpcyBzaG91bGQgYmUgY2hlY2tlZCBiZWZvcmUgYW5pbWF0b3JzW2ldLnN0YXJ0KCksXG4gICAgLy8gYmVjYXVzZSAnZG9uZScgbWF5IGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGlmIG5vIG5lZWQgdG8gYW5pbWF0ZS5cblxuXG4gICAgaWYgKCFjb3VudCkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9IC8vIFN0YXJ0IGFmdGVyIGFsbCBhbmltYXRvcnMgY3JlYXRlZFxuICAgIC8vIEluY2FzZSBhbnkgYW5pbWF0b3IgaXMgZG9uZSBpbW1lZGlhdGVseSB3aGVuIGFsbCBhbmltYXRpb24gcHJvcGVydGllcyBhcmUgbm90IGNoYW5nZWRcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFuaW1hdG9yc1tpXS5kb25lKGRvbmUpLnN0YXJ0KGVhc2luZywgZm9yY2VBbmltYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoPScnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2U9dGhpc1xuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0pXG4gICAqXG4gICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXNcbiAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICogICAgICBzaGFwZToge1xuICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAqICAgICAgfSxcbiAgICogICAgICBzdHlsZToge1xuICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgKiAgICAgIH1cbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIDEwMCwgMTAwKVxuICAgKi9cbiAgX2FuaW1hdGVUb1NoYWxsb3c6IGZ1bmN0aW9uIChwYXRoLCBzb3VyY2UsIHRhcmdldCwgdGltZSwgZGVsYXkpIHtcbiAgICB2YXIgb2JqU2hhbGxvdyA9IHt9O1xuICAgIHZhciBwcm9wZXJ0eUNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc09iamVjdCh0YXJnZXRbbmFtZV0pICYmICFpc0FycmF5TGlrZSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdyhwYXRoID8gcGF0aCArICcuJyArIG5hbWUgOiBuYW1lLCBzb3VyY2VbbmFtZV0sIHRhcmdldFtuYW1lXSwgdGltZSwgZGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgcHJvcGVydHlDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEF0dHIgZGlyZWN0bHkgaWYgbm90IGhhcyBwcm9wZXJ0eVxuICAgICAgICAvLyBGSVhNRSwgaWYgc29tZSBwcm9wZXJ0eSBub3QgbmVlZGVkIGZvciBlbGVtZW50ID9cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKG5hbWUsIHRhcmdldFtuYW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2hhcGUgb3Igc3R5bGVcbiAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICBwcm9wc1twYXRoXSA9IHt9O1xuICAgICAgICAgIHByb3BzW3BhdGhdW25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgIHRoaXMuYXR0cihwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHlDb3VudCA+IDApIHtcbiAgICAgIHRoaXMuYW5pbWF0ZShwYXRoLCBmYWxzZSkud2hlbih0aW1lID09IG51bGwgPyA1MDAgOiB0aW1lLCBvYmpTaGFsbG93KS5kZWxheShkZWxheSB8fCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdGFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlYXNpbmdGdW5jcyA9IHJlcXVpcmUoXCIuL2Vhc2luZ1wiKTtcblxuLyoqXG4gKiDliqjnlLvkuLvmjqfliLblmahcbiAqIEBjb25maWcgdGFyZ2V0IOWKqOeUu+Wvueixoe+8jOWPr+S7peaYr+aVsOe7hO+8jOWmguaenOaYr+aVsOe7hOeahOivneS8muaJuemHj+WIhuWPkW9uZnJhbWXnrYnkuovku7ZcbiAqIEBjb25maWcgbGlmZSgxMDAwKSDliqjnlLvml7bplb9cbiAqIEBjb25maWcgZGVsYXkoMCkg5Yqo55S75bu26L+f5pe26Ze0XG4gKiBAY29uZmlnIGxvb3AodHJ1ZSlcbiAqIEBjb25maWcgZ2FwKDApIOW+queOr+eahOmXtOmalOaXtumXtFxuICogQGNvbmZpZyBvbmZyYW1lXG4gKiBAY29uZmlnIGVhc2luZyhvcHRpb25hbClcbiAqIEBjb25maWcgb25kZXN0cm95KG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbnJlc3RhcnQob3B0aW9uYWwpXG4gKlxuICogVE9ETyBwYXVzZVxuICovXG5mdW5jdGlvbiBDbGlwKG9wdGlvbnMpIHtcbiAgdGhpcy5fdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7IC8vIOeUn+WRveWRqOacn1xuXG4gIHRoaXMuX2xpZmUgPSBvcHRpb25zLmxpZmUgfHwgMTAwMDsgLy8g5bu25pe2XG5cbiAgdGhpcy5fZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7IC8vIOW8gOWni+aXtumXtFxuICAvLyB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMuX2RlbGF5Oy8vIOWNleS9jeavq+enklxuXG4gIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7IC8vIOaYr+WQpuW+queOr1xuXG4gIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG4gIHRoaXMuZ2FwID0gb3B0aW9ucy5nYXAgfHwgMDtcbiAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCAnTGluZWFyJztcbiAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcbiAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG59XG5cbkNsaXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ2xpcCxcbiAgc3RlcDogZnVuY3Rpb24gKGdsb2JhbFRpbWUsIGRlbHRhVGltZSkge1xuICAgIC8vIFNldCBzdGFydFRpbWUgb24gZmlyc3Qgc3RlcCwgb3IgX3N0YXJ0VGltZSBtYXkgaGFzIG1pbGxlc2Vjb25kcyBkaWZmZXJlbnQgYmV0d2VlbiBjbGlwc1xuICAgIC8vIFBFTkRJTkdcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lICsgdGhpcy5fZGVsYXk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBkZWx0YVRpbWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpIC8gdGhpcy5fbGlmZTsgLy8g6L+Y5rKh5byA5aeLXG5cbiAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwZXJjZW50ID0gTWF0aC5taW4ocGVyY2VudCwgMSk7XG4gICAgdmFyIGVhc2luZyA9IHRoaXMuZWFzaW5nO1xuICAgIHZhciBlYXNpbmdGdW5jID0gdHlwZW9mIGVhc2luZyA9PSAnc3RyaW5nJyA/IGVhc2luZ0Z1bmNzW2Vhc2luZ10gOiBlYXNpbmc7XG4gICAgdmFyIHNjaGVkdWxlID0gdHlwZW9mIGVhc2luZ0Z1bmMgPT09ICdmdW5jdGlvbicgPyBlYXNpbmdGdW5jKHBlcmNlbnQpIDogcGVyY2VudDtcbiAgICB0aGlzLmZpcmUoJ2ZyYW1lJywgc2NoZWR1bGUpOyAvLyDnu5PmnZ9cblxuICAgIGlmIChwZXJjZW50ID09IDEpIHtcbiAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0KGdsb2JhbFRpbWUpOyAvLyDph43mlrDlvIDlp4vlkajmnJ9cbiAgICAgICAgLy8g5oqb5Ye66ICM5LiN5piv55u05o6l6LCD55So5LqL5Lu255u05YiwIHN0YWdlLnVwZGF0ZSDlkI7lho3nu5/kuIDosIPnlKjov5nkupvkuovku7ZcblxuICAgICAgICByZXR1cm4gJ3Jlc3RhcnQnO1xuICAgICAgfSAvLyDliqjnlLvlrozmiJDlsIbov5nkuKrmjqfliLblmajmoIfor4bkuLrlvoXliKDpmaRcbiAgICAgIC8vIOWcqEFuaW1hdGlvbi51cGRhdGXkuK3ov5vooYzmibnph4/liKDpmaRcblxuXG4gICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IHRydWU7XG4gICAgICByZXR1cm4gJ2Rlc3Ryb3knO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICByZXN0YXJ0OiBmdW5jdGlvbiAoZ2xvYmFsVGltZSkge1xuICAgIHZhciByZW1haW5kZXIgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpICUgdGhpcy5fbGlmZTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lIC0gcmVtYWluZGVyICsgdGhpcy5nYXA7XG4gICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gICAgdGhpcy5fbmVlZHNSZW1vdmUgPSBmYWxzZTtcbiAgfSxcbiAgZmlyZTogZnVuY3Rpb24gKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgZXZlbnRUeXBlID0gJ29uJyArIGV2ZW50VHlwZTtcblxuICAgIGlmICh0aGlzW2V2ZW50VHlwZV0pIHtcbiAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgfVxuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH0sXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQ2xpcDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanNcbi8vIG1vZHVsZSBpZCA9IDE4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICog57yT5Yqo5Luj56CB5p2l6IeqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xlL3R3ZWVuLmpzL2Jsb2IvbWFzdGVyL3NyYy9Ud2Vlbi5qc1xuICogQHNlZSBodHRwOi8vc29sZS5naXRodWIuaW8vdHdlZW4uanMvZXhhbXBsZXMvMDNfZ3JhcGhzLmh0bWxcbiAqIEBleHBvcnRzIHpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ1xuICovXG52YXIgZWFzaW5nID0ge1xuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgbGluZWFyOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YWRyYXRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqICgyIC0gayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YWRyYXRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gIH0sXG4gIC8vIOS4ieasoeaWueeahOe8k+WKqO+8iHReM++8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGN1YmljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGN1YmljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgfSxcbiAgLy8g5Zub5qyh5pa555qE57yT5Yqo77yIdF4077yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhcnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIC0tayAqIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhcnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAtMC41ICogKChrIC09IDIpICogayAqIGsgKiBrIC0gMik7XG4gIH0sXG4gIC8vIOS6lOasoeaWueeahOe8k+WKqO+8iHReNe+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWludGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWludGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrICogayArIDIpO1xuICB9LFxuICAvLyDmraPlvKbmm7Lnur/nmoTnvJPliqjvvIhzaW4odCnvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgc2ludXNvaWRhbEluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgc2ludXNvaWRhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgc2ludXNvaWRhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gIH0sXG4gIC8vIOaMh+aVsOabsue6v+eahOe8k+WKqO+8iDJedO+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBleHBvbmVudGlhbEluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0xMCAqIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBleHBvbmVudGlhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAoayAtIDEpKSArIDIpO1xuICB9LFxuICAvLyDlnIblvaLmm7Lnur/nmoTnvJPliqjvvIhzcXJ0KDEtdF4yKe+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjaXJjdWxhckluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFyT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tayAqIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjaXJjdWxhckluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChrIC09IDIpICogaykgKyAxKTtcbiAgfSxcbiAgLy8g5Yib5bu657G75Ly85LqO5by557Cn5Zyo5YGc5q2i5YmN5p2l5Zue5oyv6I2h55qE5Yqo55S7XG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGVsYXN0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcztcbiAgICB2YXIgYSA9IDAuMTtcbiAgICB2YXIgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICByZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcztcbiAgICB2YXIgYSA9IDAuMTtcbiAgICB2YXIgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIGspICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGVsYXN0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcztcbiAgICB2YXIgYSA9IDAuMTtcbiAgICB2YXIgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuICB9LFxuICAvLyDlnKjmn5DkuIDliqjnlLvlvIDlp4vmsr/mjIfnpLrnmoTot6/lvoTov5vooYzliqjnlLvlpITnkIbliY3nqI3nqI3mlLblm57or6XliqjnlLvnmoTnp7vliqhcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYmFja0luOiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYmFja091dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuICB9LFxuICAvLyDliJvlu7rlvLnot7PmlYjmnpxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYm91bmNlSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNpbmcuYm91bmNlT3V0KDEgLSBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYm91bmNlT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmIChrIDwgMSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcbiAgICB9IGVsc2UgaWYgKGsgPCAyIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDEuNSAvIDIuNzUpICogayArIDAuNzU7XG4gICAgfSBlbHNlIGlmIChrIDwgMi41IC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuMjUgLyAyLjc1KSAqIGsgKyAwLjkzNzU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjYyNSAvIDIuNzUpICogayArIDAuOTg0Mzc1O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYm91bmNlSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPCAwLjUpIHtcbiAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlSW4oayAqIDIpICogMC41O1xuICAgIH1cblxuICAgIHJldHVybiBlYXNpbmcuYm91bmNlT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBlYXNpbmc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBsb2cgPSByZXF1aXJlKFwiLi9jb3JlL2xvZ1wiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCIuL2NvcmUvdGltc29ydFwiKTtcblxudmFyIExheWVyID0gcmVxdWlyZShcIi4vTGF5ZXJcIik7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgSW1hZ2UgPSByZXF1aXJlKFwiLi9ncmFwaGljL0ltYWdlXCIpO1xuXG4vKipcbiAqIERlZmF1bHQgY2FudmFzIHBhaW50ZXJcbiAqIEBtb2R1bGUgenJlbmRlci9QYWludGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBQRU5ESUdOXG4vLyBMYXllciBleGNlZWRzIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgbWF5IGhhdmUgc29tZSBwcm9ibGVtIHdoZW4gZmx1c2ggZGlyZWN0bHkgc2Vjb25kIHRpbWUuXG4vL1xuLy8gTWF4aW11bSBwcm9ncmVzc2l2ZSBsYXllci4gV2hlbiBleGNlZWRpbmcgdGhpcyBudW1iZXIuIEFsbCBlbGVtZW50cyB3aWxsIGJlIGRyYXdlZCBpbiB0aGUgbGFzdCBsYXllci5cbnZhciBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSID0gNTtcblxuZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0xheWVyVmFsaWQobGF5ZXIpIHtcbiAgaWYgKCFsYXllcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsYXllci5yZXNpemUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGxheWVyLnJlZnJlc2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJlUHJvY2Vzc0xheWVyKGxheWVyKSB7XG4gIGxheWVyLl9fdW51c2VkQ291bnQrKztcbn1cblxuZnVuY3Rpb24gcG9zdFByb2Nlc3NMYXllcihsYXllcikge1xuICBpZiAobGF5ZXIuX191bnVzZWRDb3VudCA9PSAxKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfVxufVxuXG52YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG52YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuXG5mdW5jdGlvbiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRtcFJlY3QuY29weShlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cbiAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgcHJldkNsaXBQYXRocykge1xuICBpZiAoY2xpcFBhdGhzID09IHByZXZDbGlwUGF0aHMpIHtcbiAgICAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghY2xpcFBhdGhzIHx8ICFwcmV2Q2xpcFBhdGhzIHx8IGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgY2xpcFBhdGguc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICBjdHguY2xpcCgpOyAvLyBUcmFuc2Zvcm0gYmFja1xuXG4gICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3Qod2lkdGgsIGhlaWdodCkge1xuICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBkb21Sb290Lm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG5cbiAgZG9tUm9vdC5zdHlsZS5jc3NUZXh0ID0gWydwb3NpdGlvbjpyZWxhdGl2ZScsICdvdmVyZmxvdzpoaWRkZW4nLCAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JywgJ2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4JywgJ3BhZGRpbmc6MCcsICdtYXJnaW46MCcsICdib3JkZXItd2lkdGg6MCddLmpvaW4oJzsnKSArICc7JztcbiAgcmV0dXJuIGRvbVJvb3Q7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3Qg57uY5Zu+5a655ZmoXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuXG52YXIgUGFpbnRlciA9IGZ1bmN0aW9uIChyb290LCBzdG9yYWdlLCBvcHRzKSB7XG4gIHRoaXMudHlwZSA9ICdjYW52YXMnOyAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG5cbiAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBvcHRzIHx8IHt9KTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGRldmljZVBpeGVsUmF0aW87XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAvKipcbiAgICog57uY5Zu+5a655ZmoXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgaWYgKHJvb3RTdHlsZSkge1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICByb290LmlubmVySFRNTCA9ICcnO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICovXG5cblxuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvTGF5ZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XG4gICAqIEB0eXBlIHtwcml2YXRlfVxuICAgKi9cblxuICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuXG4gIGlmICghc2luZ2xlQ2FudmFzKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290ID0gY3JlYXRlUm9vdCh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRzLndpZHRoICE9IG51bGwpIHtcbiAgICAgIHJvb3Qud2lkdGggPSBvcHRzLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICByb290LmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgIH0gLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG5cblxuICAgIHZhciB3aWR0aCA9IHJvb3Qud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0OyAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuXG4gICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICBtYWluTGF5ZXIuaW5pdENvbnRleHQoKTsgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgLy8gbWFpbkxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGxheWVyc1swXSA9IG1haW5MYXllcjtcbiAgICB6bGV2ZWxMaXN0LnB1c2goMCk7XG4gICAgdGhpcy5fZG9tUm9vdCA9IHJvb3Q7XG4gIH0gLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcblxuXG4gIHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2hvdmVybGF5ZXI7XG4gIHRoaXMuX2hvdmVyRWxlbWVudHMgPSBbXTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnY2FudmFzJztcbiAgfSxcblxuICAvKipcbiAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbVJvb3Q7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliLfmlrBcbiAgICogQHBhcmFtIHtib29sZWFufSBbcGFpbnRBbGw9ZmFsc2VdIOW8uuWItue7mOWItuaJgOaciWRpc3BsYXlhYmxlXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAocGFpbnRBbGwpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCwgcGFpbnRBbGwpOyAvLyBQYWludCBjdXN0dW0gbGF5ZXJzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIGxheWVyLnJlZnJlc2gpIHtcbiAgICAgICAgbGF5ZXIucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgIGlmIChlbC5fX2hvdmVyTWlyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsTWlycm9yID0gbmV3IGVsLmNvbnN0cnVjdG9yKHtcbiAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgIHNoYXBlOiBlbC5zaGFwZVxuICAgIH0pO1xuICAgIGVsTWlycm9yLl9fZnJvbSA9IGVsO1xuICAgIGVsLl9faG92ZXJNaXIgPSBlbE1pcnJvcjtcbiAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcblxuICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gIH0sXG4gIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgZWxNaXJyb3IgPSBlbC5fX2hvdmVyTWlyO1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKGhvdmVyRWxlbWVudHMsIGVsTWlycm9yKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICBlbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgfSxcbiAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZnJvbSA9IGhvdmVyRWxlbWVudHNbaV0uX19mcm9tO1xuXG4gICAgICBpZiAoZnJvbSkge1xuICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXI7XG4gICAgaG92ZXJMYXllciAmJiBob3ZlckxheWVyLmNsZWFyKCk7XG5cbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpOyAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgIC8vIEZJWE1FP1xuXG4gICAgaWYgKCFob3ZlckxheWVyKSB7XG4gICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgIHZhciBlbCA9IGhvdmVyRWxlbWVudHNbaV07XG4gICAgICB2YXIgb3JpZ2luYWxFbCA9IGVsLl9fZnJvbTsgLy8gT3JpZ2luYWwgZWwgaXMgcmVtb3ZlZFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoIShvcmlnaW5hbEVsICYmIG9yaWdpbmFsRWwuX196cikpIHtcbiAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG9yaWdpbmFsRWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgIGxlbi0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaSsrOyAvLyBVc2UgdHJhbnNmb3JtXG4gICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuXG4gICAgICBpZiAoIW9yaWdpbmFsRWwuaW52aXNpYmxlKSB7XG4gICAgICAgIGVsLnRyYW5zZm9ybSA9IG9yaWdpbmFsRWwudHJhbnNmb3JtO1xuICAgICAgICBlbC5pbnZUcmFuc2Zvcm0gPSBvcmlnaW5hbEVsLmludlRyYW5zZm9ybTtcbiAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBvcmlnaW5hbEVsLl9fY2xpcFBhdGhzOyAvLyBlbC5cblxuICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gIH0sXG4gIF9zdGFydFByb2dlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAvLyBwcmV2aW91cyB6ci5yZWZyZXNoIGNhbGxpbmcuXG5cblxuICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcbiAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgaWYgKHRva2VuID09PSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuICYmIHNlbGYuc3RvcmFnZSkge1xuICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NsZWFyUHJvZ3Jlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgfSk7XG4gIH0sXG4gIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgIGlmIChwYWludEFsbCA9PSBudWxsKSB7XG4gICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuXG4gICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHByZVByb2Nlc3NMYXllcik7XG5cbiAgICB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gIH0sXG4gIF9kb1BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG4gICAgdmFyIGN1cnJlbnRMYXllcjtcbiAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICB2YXIgY3R4OyAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG5cbiAgICB2YXIgc2NvcGU7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIHZhciBsYXllclByb2dyZXNzO1xuICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuXG4gICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDA7IC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcblxuICAgICAgY3VycmVudExheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciBlbFpMZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG4gICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWU7IC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgfSAvLyBDaGFuZ2UgZHJhdyBsYXllclxuXG5cbiAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSAvLyBSZXNldCBzY29wZVxuXG5cbiAgICAgICAgc2NvcGUgPSB7fTsgLy8gT25seSAwIHpsZXZlbCBpZiBvbmx5IGhhcyBvbmUgY2FudmFzXG5cbiAgICAgICAgY3VycmVudFpMZXZlbCA9IGVsWkxldmVsO1xuICAgICAgICBjdXJyZW50TGF5ZXIgPSB0aGlzLmdldExheWVyKGN1cnJlbnRaTGV2ZWwpO1xuXG4gICAgICAgIGlmICghY3VycmVudExheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTsgLy8gUmVzZXQgdGhlIGNvdW50XG5cbiAgICAgICAgY3VycmVudExheWVyLl9fdW51c2VkQ291bnQgPSAwO1xuXG4gICAgICAgIGlmIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkge1xuICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsRnJhbWUgPj0gMCkge1xuICAgICAgICAvLyBQcm9ncmVzc2l2ZSBsYXllciBjaGFuZ2VkXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW01hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJJZHgrKywgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpXTtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcyA+IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgLy8gQWxsIHByb2dyZXNzaXZlIGVsZW1lbnQgYXJlIG5vdCBkaXJ0eSwganVtcCBvdmVyIGFuZCBmbHVzaCBkaXJlY3RseVxuICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxOyAvLyBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxheWVyUHJvZ3Jlc3MgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAvLyBLZWVwIHJlbmRlcmluZ1xuICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPSBmcmFtZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxGcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgfVxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgIH0gLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuXG5cbiAgICBjdHggJiYgY3R4LnJlc3RvcmUoKTsgLy8gSWYgc3RpbGwgaGFzIGNsaXBwaW5nIHN0YXRlXG4gICAgLy8gaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgIC8vIH1cblxuICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgIHZhciBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuXG4gICAgaWYgKChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KSAmJiAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAhZWwuaW52aXNpYmxlIC8vIElnbm9yZSB0cmFuc3BhcmVudCBlbGVtZW50XG4gICAgJiYgZWwuc3R5bGUub3BhY2l0eSAhPT0gMCAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKSAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpKSB7XG4gICAgICB2YXIgY2xpcFBhdGhzID0gZWwuX19jbGlwUGF0aHM7IC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG5cbiAgICAgIGlmIChzY29wZS5wcmV2Q2xpcExheWVyICE9PSBjdXJyZW50TGF5ZXIgfHwgaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBzY29wZS5wcmV2RWxDbGlwUGF0aHMpKSB7XG4gICAgICAgIC8vIElmIGhhcyBwcmV2aW91cyBjbGlwcGluZyBzdGF0ZSwgcmVzdG9yZSBmcm9tIGl0XG4gICAgICAgIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7IC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG5cbiAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICB9IC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuXG5cbiAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gY3VycmVudExheWVyO1xuICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICBzY29wZS5wcmV2RWwgPSBlbDtcbiAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaChjdHgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICovXG4gIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgIGxheWVyLl9fYnVpbHRpbl9fID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0TGF5ZXIoemxldmVsLCBsYXllcik7IC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgIC8vIE9yIGV4Y2FudmFzIHdpbGwgZ2V0IDBweCBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0XG5cbiAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9LFxuICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcbiAgICB2YXIgbGF5ZXJzTWFwID0gdGhpcy5fbGF5ZXJzO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGVuID0gemxldmVsTGlzdC5sZW5ndGg7XG4gICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG5cbiAgICBpZiAobGF5ZXJzTWFwW3psZXZlbF0pIHtcbiAgICAgIGxvZygnWkxldmVsICcgKyB6bGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuXG5cbiAgICBpZiAoIWlzTGF5ZXJWYWxpZChsYXllcikpIHtcbiAgICAgIGxvZygnTGF5ZXIgb2YgemxldmVsICcgKyB6bGV2ZWwgKyAnIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHpsZXZlbExpc3RbaV0gPCB6bGV2ZWwgJiYgemxldmVsTGlzdFtpICsgMV0gPiB6bGV2ZWwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2TGF5ZXIgPSBsYXllcnNNYXBbemxldmVsTGlzdFtpXV07XG4gICAgfVxuXG4gICAgemxldmVsTGlzdC5zcGxpY2UoaSArIDEsIDAsIHpsZXZlbCk7XG4gICAgbGF5ZXJzTWFwW3psZXZlbF0gPSBsYXllcjsgLy8gVml0dWFsIGxheWVyIHdpbGwgbm90IGRpcmVjdGx5IHNob3cgb24gdGhlIHNjcmVlbi5cbiAgICAvLyAoSXQgY2FuIGJlIGEgV2ViR0wgbGF5ZXIgYW5kIGFzc2lnbmVkIHRvIGEgWkltYWdlIGVsZW1lbnQpXG4gICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cblxuICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgaWYgKHByZXZMYXllcikge1xuICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG5cbiAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIHByZXZEb20ubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICBlYWNoTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBidWlsZGluIGxheWVyXG4gIGVhY2hCdWlsdGluTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXI7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgKi9cbiAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVycztcbiAgfSxcbiAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJzID0gdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnM7XG4gICAgdmFyIGVsQ291bnRzTGFzdEZyYW1lID0ge307XG4gICAgdmFyIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJDb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgdmFyIGZyYW1lQ291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuXG4gICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuZWxDb3VudCsrO1xuICAgICAgICBsYXllci5fX2RpcnR5ID0gbGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgfSAvLy8vLy8vIFVwZGF0ZSBwcm9ncmVzc2l2ZVxuXG5cbiAgICAgIGlmIChlbFByb2dyZXNzID49IDApIHtcbiAgICAgICAgLy8gRml4IHdyb25nIHByb2dyZXNzaXZlIHNlcXVlbmNlIHByb2JsZW0uXG4gICAgICAgIGlmIChsYXN0UHJvZ3Jlc3NpdmVLZXkgIT09IGVsUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgIGZyYW1lQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKCdwcm9ncmVzc2l2ZScsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5ID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5lbENvdW50Kys7XG4gICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSBNYXRoLm1heChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lKTtcblxuICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuX19mcmFtZSA9IC0xO1xuXG4gICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICB9IC8vIOWxguS4reeahOWFg+e0oOaVsOmHj+acieWPkeeUn+WPmOWMllxuXG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBpZiAoZWxDb3VudHNMYXN0RnJhbWVbel0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSKTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBpZiAocHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZVtpZHhdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgIGVsLl9fZGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICBsYXllci5fX3Byb2dyZXNzID0gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICog5riF6ZmkaG92ZXLlsYLlpJbmiYDmnInlhoXlrrlcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY2xlYXJMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICog5L+u5pS55oyH5a6aemxldmVs55qE57uY5Yi25Y+C5pWwXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6bGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyDphY3nva7lr7nosaFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0g5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN11cbiAgICogICAgICAgICAgICAgICAgIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5fbGF5ZXJDb25maWc7XG5cbiAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAqL1xuICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgZGVsZXRlIGxheWVyc1t6bGV2ZWxdO1xuICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290OyAvLyBGSVhNRSBXaHkgP1xuXG4gICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBTYXZlIGlucHV0IHcvaFxuXG4gICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgaGVpZ2h0ICE9IG51bGwgJiYgKG9wdHMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcbiAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnJzsgLy8g5LyY5YyW5rKh5pyJ5a6e6ZmF5pS55Y+Y55qEcmVzaXplXG5cbiAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGRvbVJvb3Quc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXllcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAqL1xuICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDph4rmlL5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5yb290ID0gdGhpcy5zdG9yYWdlID0gdGhpcy5fZG9tUm9vdCA9IHRoaXMuX2xheWVycyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMucGl4ZWxSYXRpb11cbiAgICovXG4gIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXS5kb207XG4gICAgfVxuXG4gICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgaW1hZ2VMYXllci5jbGVhcigpO1xuICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICB2YXIgemxldmVsO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmRBbmREcmF3T3RoZXJMYXllcihzbWFsbGVyLCBsYXJnZXIpIHtcbiAgICAgIHZhciB6bGV2ZWxMaXN0ID0gc2VsZi5femxldmVsTGlzdDtcblxuICAgICAgaWYgKHNtYWxsZXIgPT0gbnVsbCkge1xuICAgICAgICBzbWFsbGVyID0gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZXJtZWRpYXRlTGF5ZXI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgIHZhciBsYXllciA9IHNlbGYuX2xheWVyc1t6XTtcblxuICAgICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIHogPiBzbWFsbGVyICYmIHogPCBsYXJnZXIpIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVMYXllciA9IGxheWVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlcm1lZGlhdGVMYXllciAmJiBpbnRlcm1lZGlhdGVMYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgIGludGVybWVkaWF0ZUxheWVyLnJlbmRlclRvQ2FudmFzKGltYWdlTGF5ZXIuY3R4KTtcbiAgICAgICAgaW1hZ2VMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGRpc3BsYXlMaXN0W2ldO1xuXG4gICAgICBpZiAoZWwuemxldmVsICE9PSB6bGV2ZWwpIHtcbiAgICAgICAgZmluZEFuZERyYXdPdGhlckxheWVyKHpsZXZlbCwgZWwuemxldmVsKTtcbiAgICAgICAgemxldmVsID0gZWwuemxldmVsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGltYWdlTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICB9XG5cbiAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGltYWdlTGF5ZXIuZG9tO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICovXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIF9nZXRTaXplOiBmdW5jdGlvbiAod2hJZHgpIHtcbiAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIGN3aCA9IFsnY2xpZW50V2lkdGgnLCAnY2xpZW50SGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBwbHQgPSBbJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdUb3AnXVt3aElkeF07XG4gICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7IC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUsIGJ1dCBpdCB1c2UgVk1MLlxuXG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG4gICAgcmV0dXJuIChyb290W2N3aF0gfHwgcGFyc2VJbnQxMChzdGxbd2hdKSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGVbd2hdKSkgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMCkgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMCkgfCAwO1xuICB9LFxuICBwYXRoVG9JbWFnZTogZnVuY3Rpb24gKHBhdGgsIGRwcikge1xuICAgIGRwciA9IGRwciB8fCB0aGlzLmRwcjtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSBwYXRoLnN0eWxlO1xuICAgIHZhciBzaGFkb3dCbHVyU2l6ZSA9IHN0eWxlLnNoYWRvd0JsdXI7XG4gICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xuICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGUuc2hhZG93T2Zmc2V0WTtcbiAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5saW5lV2lkdGggOiAwO1xuICAgIHZhciBsZWZ0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHJpZ2h0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgdG9wTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIGJvdHRvbU1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCArIGxlZnRNYXJnaW4gKyByaWdodE1hcmdpbjtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyB0b3BNYXJnaW4gKyBib3R0b21NYXJnaW47XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmRwciA9IGRwcjtcbiAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgIHBvc2l0aW9uOiBwYXRoLnBvc2l0aW9uLFxuICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgIH07XG4gICAgcGF0aC5wb3NpdGlvbiA9IFtsZWZ0TWFyZ2luIC0gcmVjdC54LCB0b3BNYXJnaW4gLSByZWN0LnldO1xuICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgIHBhdGguc2NhbGUgPSBbMSwgMV07XG4gICAgcGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgfVxuXG4gICAgdmFyIEltYWdlU2hhcGUgPSBJbWFnZTtcbiAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICBzdHlsZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnJvdGF0aW9uID0gcGF0aC5yb3RhdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucm90YXRpb247XG4gICAgfVxuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1nU2hhcGU7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9QYWludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5cbnZhciBkZXZpY2VQaXhlbFJhdGlvID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9ncmFwaGljL1N0eWxlXCIpO1xuXG52YXIgUGF0dGVybiA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvUGF0dGVyblwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvTGF5ZXJcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIOWIm+W7umRvbVxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtzdHJpbmd9IGlkIGRvbSBpZCDlvoXnlKhcbiAqIEBwYXJhbSB7UGFpbnRlcn0gcGFpbnRlciBwYWludGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVEb20oaWQsIHBhaW50ZXIsIGRwcikge1xuICB2YXIgbmV3RG9tID0gdXRpbC5jcmVhdGVDYW52YXMoKTtcbiAgdmFyIHdpZHRoID0gcGFpbnRlci5nZXRXaWR0aCgpO1xuICB2YXIgaGVpZ2h0ID0gcGFpbnRlci5nZXRIZWlnaHQoKTtcbiAgdmFyIG5ld0RvbVN0eWxlID0gbmV3RG9tLnN0eWxlOyAvLyDmsqFhcHBlbmTlkaLvvIzor7fljp/osIXmiJHov5nmoLflhpnvvIzmuIXmmbB+XG5cbiAgbmV3RG9tU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBuZXdEb21TdHlsZS5sZWZ0ID0gMDtcbiAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgbmV3RG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIG5ld0RvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIG5ld0RvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICBuZXdEb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByOyAvLyBpZOS4jeS9nOS4uue0ouW8leeUqO+8jOmBv+WFjeWPr+iDvemAoOaIkOeahOmHjeWQje+8jOWumuS5ieS4uuengeacieWxnuaAp1xuXG4gIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICByZXR1cm4gbmV3RG9tO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvTGF5ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHByXVxuICovXG5cblxudmFyIExheWVyID0gZnVuY3Rpb24gKGlkLCBwYWludGVyLCBkcHIpIHtcbiAgdmFyIGRvbTtcbiAgZHByID0gZHByIHx8IGRldmljZVBpeGVsUmF0aW87XG5cbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICBkb20gPSBjcmVhdGVEb20oaWQsIHBhaW50ZXIsIGRwcik7XG4gIH0gLy8gTm90IHVzaW5nIGlzRG9tIGJlY2F1c2UgaW4gbm9kZSBpdCB3aWxsIHJldHVybiBmYWxzZVxuICBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGlkKSkge1xuICAgICAgZG9tID0gaWQ7XG4gICAgICBpZCA9IGRvbS5pZDtcbiAgICB9XG5cbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmRvbSA9IGRvbTtcbiAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuXG4gIGlmIChkb21TdHlsZSkge1xuICAgIC8vIE5vdCBpbiBub2RlXG4gICAgZG9tLm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG5cbiAgICBkb21TdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gJ25vbmUnO1xuICAgIGRvbVN0eWxlWyd1c2VyLXNlbGVjdCddID0gJ25vbmUnO1xuICAgIGRvbVN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgZG9tU3R5bGVbJ3BhZGRpbmcnXSA9IDA7XG4gICAgZG9tU3R5bGVbJ21hcmdpbiddID0gMDtcbiAgICBkb21TdHlsZVsnYm9yZGVyLXdpZHRoJ10gPSAwO1xuICB9XG5cbiAgdGhpcy5kb21CYWNrID0gbnVsbDtcbiAgdGhpcy5jdHhCYWNrID0gbnVsbDtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdGhpcy5jb25maWcgPSBudWxsOyAvLyBDb25maWdzXG5cbiAgLyoqXG4gICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuXG4gIHRoaXMuY2xlYXJDb2xvciA9IDA7XG4gIC8qKlxuICAgKiDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuXG4gIHRoaXMubW90aW9uQmx1ciA9IGZhbHNlO1xuICAvKipcbiAgICog5Zyo5byA5ZCv5Yqo5oCB5qih57OK55qE5pe25YCZ5L2/55So77yM5LiO5LiK5LiA5bin5re35ZCI55qEYWxwaGHlgLzvvIzlgLzotorlpKflsL7ov7notormmI7mmL5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMC43XG4gICAqL1xuXG4gIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG4gIC8qKlxuICAgKiBMYXllciBkcHJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5kcHIgPSBkcHI7XG59O1xuXG5MYXllci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMYXllcixcbiAgZWxDb3VudDogMCxcbiAgX19kaXJ0eTogdHJ1ZSxcbiAgaW5pdENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmN0eCA9IHRoaXMuZG9tLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy5jdHguX19jdXJyZW50VmFsdWVzID0ge307XG4gICAgdGhpcy5jdHguZHByID0gdGhpcy5kcHI7XG4gIH0sXG4gIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgdGhpcy5kb21CYWNrID0gY3JlYXRlRG9tKCdiYWNrLScgKyB0aGlzLmlkLCB0aGlzLnBhaW50ZXIsIGRwcik7XG4gICAgdGhpcy5jdHhCYWNrID0gdGhpcy5kb21CYWNrLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy5jdHhCYWNrLl9fY3VycmVudFZhbHVlcyA9IHt9O1xuXG4gICAgaWYgKGRwciAhPSAxKSB7XG4gICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuICAgIGRvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGRvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgZG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgIGlmIChkb21CYWNrKSB7XG4gICAgICBkb21CYWNrLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICBkb21CYWNrLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgaWYgKGRwciAhPSAxKSB7XG4gICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXnqbror6XlsYLnlLvluINcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhckFsbCBDbGVhciBhbGwgd2l0aCBvdXQgbW90aW9uIGJsdXJcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoY2xlYXJBbGwpIHtcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgIHZhciB3aWR0aCA9IGRvbS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcbiAgICB2YXIgY2xlYXJDb2xvciA9IHRoaXMuY2xlYXJDb2xvcjtcbiAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgIHZhciBsYXN0RnJhbWVBbHBoYSA9IHRoaXMubGFzdEZyYW1lQWxwaGE7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHhCYWNrLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoZG9tLCAwLCAwLCB3aWR0aCAvIGRwciwgaGVpZ2h0IC8gZHByKTtcbiAgICB9XG5cbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYgKGNsZWFyQ29sb3IpIHtcbiAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47IC8vIEdyYWRpZW50XG5cbiAgICAgIGlmIChjbGVhckNvbG9yLmNvbG9yU3RvcHMpIHtcbiAgICAgICAgLy8gQ2FjaGUgY2FudmFzIGdyYWRpZW50XG4gICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCB8fCBTdHlsZS5nZXRHcmFkaWVudChjdHgsIGNsZWFyQ29sb3IsIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICB9IC8vIFBhdHRlcm5cbiAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuLmNhbGwoY2xlYXJDb2xvciwgY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgY3R4LmRyYXdJbWFnZShkb21CYWNrLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gTGF5ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0xheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvdGV4dFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxuLyoqXG4gKiBNaXhpbiBmb3IgZHJhd2luZyB0ZXh0IGluIGEgZWxlbWVudCBib3VuZGluZyByZWN0XG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vUmVjdFRleHRcbiAqL1xudmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbnZhciBSZWN0VGV4dCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5SZWN0VGV4dC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSZWN0VGV4dCxcblxuICAvKipcbiAgICogRHJhdyB0ZXh0IGluIGEgcmVjdCB3aXRoIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZWN0IERpc3BsYXlhYmxlIHJlY3RcbiAgICovXG4gIGRyYXdSZWN0VGV4dDogZnVuY3Rpb24gKGN0eCwgcmVjdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgcmVjdCA9IHN0eWxlLnRleHRSZWN0IHx8IHJlY3Q7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG4gICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0OyAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXG4gICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGSVhNRVxuXG5cbiAgICBjdHguc2F2ZSgpOyAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgICBpZiAoIXN0eWxlLnRyYW5zZm9ybVRleHQpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuICAgIH0gLy8gdHJhbnNmb3JtVGV4dCBhbmQgdGV4dFJvdGF0aW9uIGNhbiBub3QgYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuXG5cbiAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFJlY3RUZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfZXZlbnQgPSByZXF1aXJlKFwiLi4vY29yZS9ldmVudFwiKTtcblxudmFyIERpc3BhdGNoZXIgPSBfZXZlbnQuRGlzcGF0Y2hlcjtcblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RBbmltYXRpb25GcmFtZVwiKTtcblxudmFyIEFuaW1hdG9yID0gcmVxdWlyZShcIi4vQW5pbWF0b3JcIik7XG5cbi8qKlxuICog5Yqo55S75Li757G7LCDosIPluqblkoznrqHnkIbmiYDmnInliqjnlLvmjqfliLblmahcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIEFkZGl0aXZlIGFuaW1hdGlvblxuLy8gaHR0cDovL2lvc290ZXJpYy5jb20vYWRkaXRpdmUtYW5pbWF0aW9ucy1hbmltYXRld2l0aGR1cmF0aW9uLWluLWlvcy04L1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy93d2RjMjAxNC8jMjM2XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSVpSZW5kZXJTdGFnZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICogQHBhcmFtIHtJWlJlbmRlclN0YWdlfSBbb3B0aW9ucy5zdGFnZV1cbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgIHk6IDEwMFxuICogICAgIH07XG4gKiAgICAgYW5pbWF0aW9uLmFuaW1hdGUobm9kZS5wb3NpdGlvbilcbiAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICogICAgICAgICAgICAgeDogNTAwLFxuICogICAgICAgICAgICAgeTogNTAwXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC53aGVuKDIwMDAsIHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMFxuICogICAgICAgICB9KVxuICogICAgICAgICAuc3RhcnQoJ3NwbGluZScpO1xuICovXG52YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuc3RhZ2UgPSBvcHRpb25zLnN0YWdlIHx8IHt9O1xuXG4gIHRoaXMub25mcmFtZSA9IG9wdGlvbnMub25mcmFtZSB8fCBmdW5jdGlvbiAoKSB7fTsgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cblxuICB0aGlzLl9jbGlwcyA9IFtdO1xuICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gIHRoaXMuX3RpbWU7XG4gIHRoaXMuX3BhdXNlZFRpbWU7XG4gIHRoaXMuX3BhdXNlU3RhcnQ7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICBEaXNwYXRjaGVyLmNhbGwodGhpcyk7XG59O1xuXG5BbmltYXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuXG4gIC8qKlxuICAgKiDmt7vliqAgY2xpcFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAqL1xuICBhZGRDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoCBhbmltYXRvclxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICovXG4gIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICovXG4gIHJlbW92ZUNsaXA6IGZ1bmN0aW9uIChjbGlwKSB7XG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuX2NsaXBzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgKi9cbiAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgIH1cblxuICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gIH0sXG4gIF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VkVGltZTtcblxuICAgIHZhciBkZWx0YSA9IHRpbWUgLSB0aGlzLl90aW1lO1xuICAgIHZhciBjbGlwcyA9IHRoaXMuX2NsaXBzO1xuICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG4gICAgdmFyIGRlZmVycmVkRXZlbnRzID0gW107XG4gICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjbGlwID0gY2xpcHNbaV07XG4gICAgICB2YXIgZSA9IGNsaXAuc3RlcCh0aW1lLCBkZWx0YSk7IC8vIFRocm93IG91dCB0aGUgZXZlbnRzIG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyXG4gICAgICAvLyBzdGFnZS51cGRhdGUsIGxpa2UgZGVzdHJveVxuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBkZWZlcnJlZEV2ZW50cy5wdXNoKGUpO1xuICAgICAgICBkZWZlcnJlZENsaXBzLnB1c2goY2xpcCk7XG4gICAgICB9XG4gICAgfSAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGNsaXBcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgIGNsaXBzW2ldID0gY2xpcHNbbGVuIC0gMV07XG4gICAgICAgIGNsaXBzLnBvcCgpO1xuICAgICAgICBsZW4tLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSBkZWZlcnJlZEV2ZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZWZlcnJlZENsaXBzW2ldLmZpcmUoZGVmZXJyZWRFdmVudHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHRoaXMub25mcmFtZShkZWx0YSk7XG4gICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgIGlmICh0aGlzLnN0YWdlLnVwZGF0ZSkge1xuICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICB9XG4gIH0sXG4gIF9zdGFydExvb3A6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAhc2VsZi5fcGF1c2VkICYmIHNlbGYuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgfSxcblxuICAvKipcbiAgICog5byA5aeL6L+Q6KGM5Yqo55S7XG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcblxuICAgIHRoaXMuX3N0YXJ0TG9vcCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlgZzmraLov5DooYzliqjnlLtcbiAgICovXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhdXNlXG4gICAqL1xuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzdW1lXG4gICAqL1xuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5riF6Zmk5omA5pyJ5Yqo55S754mH5q61XG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsaXBzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWvueS4gOS4quebruagh+WIm+W7uuS4gOS4qmFuaW1hdG9y5a+56LGh77yM5Y+v5Lul5oyH5a6a55uu5qCH5Lit55qE5bGe5oCn5L2/55So5Yqo55S7XG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5sb29wPWZhbHNlXSDmmK/lkKblvqrnjq/mkq3mlL7liqjnlLtcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLmdldHRlcj1udWxsXVxuICAgKiAgICAgICAgIOWmguaenOaMh+WummdldHRlcuWHveaVsO+8jOS8mumAmui/h2dldHRlcuWHveaVsOWPluWxnuaAp+WAvFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuc2V0dGVyPW51bGxdXG4gICAqICAgICAgICAg5aaC5p6c5oyH5a6ac2V0dGVy5Ye95pWw77yM5Lya6YCa6L+Hc2V0dGVy5Ye95pWw6K6+572u5bGe5oCn5YC8XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25+QW5pbWF0b3J9XG4gICAqL1xuICAvLyBUT0RPIEdhcFxuICBhbmltYXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgb3B0aW9ucy5sb29wLCBvcHRpb25zLmdldHRlciwgb3B0aW9ucy5zZXR0ZXIpO1xuICAgIHRoaXMuYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfVxufTtcbnV0aWwubWl4aW4oQW5pbWF0aW9uLCBEaXNwYXRjaGVyKTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9ldmVudCA9IHJlcXVpcmUoXCIuLi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IF9ldmVudC5hZGRFdmVudExpc3RlbmVyO1xudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBfZXZlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbnZhciBub3JtYWxpemVFdmVudCA9IF9ldmVudC5ub3JtYWxpemVFdmVudDtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuLi9taXhpbi9FdmVudGZ1bFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuLi9jb3JlL2VudlwiKTtcblxudmFyIEdlc3R1cmVNZ3IgPSByZXF1aXJlKFwiLi4vY29yZS9HZXN0dXJlTWdyXCIpO1xuXG52YXIgVE9VQ0hfQ0xJQ0tfREVMQVkgPSAzMDA7XG52YXIgbW91c2VIYW5kbGVyTmFtZXMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J107XG52YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJ107XG52YXIgcG9pbnRlckV2ZW50TmFtZXMgPSB7XG4gIHBvaW50ZXJkb3duOiAxLFxuICBwb2ludGVydXA6IDEsXG4gIHBvaW50ZXJtb3ZlOiAxLFxuICBwb2ludGVyb3V0OiAxXG59O1xudmFyIHBvaW50ZXJIYW5kbGVyTmFtZXMgPSB6clV0aWwubWFwKG1vdXNlSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgbm0gPSBuYW1lLnJlcGxhY2UoJ21vdXNlJywgJ3BvaW50ZXInKTtcbiAgcmV0dXJuIHBvaW50ZXJFdmVudE5hbWVzW25tXSA/IG5tIDogbmFtZTtcbn0pO1xuXG5mdW5jdGlvbiBldmVudE5hbWVGaXgobmFtZSkge1xuICByZXR1cm4gbmFtZSA9PT0gJ21vdXNld2hlZWwnICYmIGVudi5icm93c2VyLmZpcmVmb3ggPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0dlc3R1cmUocHJveHksIGV2ZW50LCBzdGFnZSkge1xuICB2YXIgZ2VzdHVyZU1nciA9IHByb3h5Ll9nZXN0dXJlTWdyO1xuICBzdGFnZSA9PT0gJ3N0YXJ0JyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG4gIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKGV2ZW50LCBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCkudGFyZ2V0LCBwcm94eS5kb20pO1xuICBzdGFnZSA9PT0gJ2VuZCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpOyAvLyBEbyBub3QgZG8gYW55IHByZXZlbnREZWZhdWx0IGhlcmUuIFVwcGVyIGFwcGxpY2F0aW9uIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuXG4gIGlmIChnZXN0dXJlSW5mbykge1xuICAgIHZhciB0eXBlID0gZ2VzdHVyZUluZm8udHlwZTtcbiAgICBldmVudC5nZXN0dXJlRXZlbnQgPSB0eXBlO1xuICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoe1xuICAgICAgdGFyZ2V0OiBnZXN0dXJlSW5mby50YXJnZXRcbiAgICB9LCB0eXBlLCBnZXN0dXJlSW5mby5ldmVudCk7XG4gIH1cbn0gLy8gZnVuY3Rpb24gb25NU0dlc3R1cmVDaGFuZ2UocHJveHksIGV2ZW50KSB7XG4vLyAgICAgaWYgKGV2ZW50LnRyYW5zbGF0aW9uWCB8fCBldmVudC50cmFuc2xhdGlvblkpIHtcbi8vICAgICAgICAgLy8gbW91c2Vtb3ZlIGlzIGNhcnJpZWQgYnkgTVNHZXN0dXJlIHRvIHJlZHVjZSB0aGUgc2Vuc2l0aXZpdHkuXG4vLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuLy8gICAgIH1cbi8vICAgICBpZiAoZXZlbnQuc2NhbGUgIT09IDEpIHtcbi8vICAgICAgICAgZXZlbnQucGluY2hYID0gZXZlbnQub2Zmc2V0WDtcbi8vICAgICAgICAgZXZlbnQucGluY2hZID0gZXZlbnQub2Zmc2V0WTtcbi8vICAgICAgICAgZXZlbnQucGluY2hTY2FsZSA9IGV2ZW50LnNjYWxlO1xuLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ3BpbmNoJywgZXZlbnQpO1xuLy8gICAgIH1cbi8vIH1cblxuLyoqXG4gKiBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCBhZnRlciBUb3VjaCBFdmVudHMgYWN0aW9uXG4gKiBAc2VlIDxodHRwczovL2dpdGh1Yi5jb20vZGVsdGFrb3NoL2hhbmRqcy9ibG9iL21hc3Rlci9zcmMvaGFuZC5iYXNlLmpzPlxuICogMS4gTW9iaWxlIGJyb3dzZXJzIGRpc3BhdGNoIG1vdXNlIGV2ZW50cyAzMDBtcyBhZnRlciB0b3VjaGVuZC5cbiAqIDIuIENocm9tZSBmb3IgQW5kcm9pZCBkaXNwYXRjaCBtb3VzZWRvd24gZm9yIGxvbmctdG91Y2ggYWJvdXQgNjUwbXNcbiAqIFJlc3VsdDogQmxvY2tpbmcgTW91c2UgRXZlbnRzIGZvciA3MDBtcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRvdWNoVGltZXIoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UuX3RvdWNoaW5nID0gdHJ1ZTtcbiAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLl90b3VjaFRpbWVyKTtcbiAgaW5zdGFuY2UuX3RvdWNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0YW5jZS5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgfSwgNzAwKTtcbn1cblxudmFyIGRvbUhhbmRsZXJzID0ge1xuICAvKipcbiAgICogTW91c2UgbW92ZSBoYW5kbGVyXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdXNlIG91dCBoYW5kbGVyXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgaWYgKGVsZW1lbnQgIT0gdGhpcy5kb20pIHtcbiAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSkge1xuICAgICAgICAvLyDlv73nlaXljIXlkKvlnKhyb2905Lit55qEZG9t5byV6LW355qEbW91c2VPdXRcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ21vdXNlb3V0JywgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb3VjaOW8gOWni+WTjeW6lOWHveaVsFxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIERlZmF1bHQgbW91c2UgYmVoYXZpb3VyIHNob3VsZCBub3QgYmUgZGlzYWJsZWQgaGVyZS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTsgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgIC8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuXG4gICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcbiAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPSBuZXcgRGF0ZSgpO1xuICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnc3RhcnQnKTsgLy8gSW4gdG91Y2ggZGV2aWNlLCB0cmlnZ2VyIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBzaG91bGRcbiAgICAvLyBiZSB0cmlnZ2VyZWQsIGFuZCBtdXN0IGJlZm9yZSBgbW91c2Vkb3duYCB0cmlnZ2VyZWQuXG5cbiAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNo56e75Yqo5ZON5bqU5Ye95pWwXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgdG91Y2htb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7IC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cblxuICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG4gICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdjaGFuZ2UnKTsgLy8gTW91c2UgbW92ZSBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQsIGJlY2F1c2UgbW91c2UgbW92ZSBhbmQgcGluY2ggbWF5XG4gICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuXG4gICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNo57uT5p2f5ZON5bqU5Ye95pWwXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTsgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgIC8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuXG4gICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcbiAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2VuZCcpO1xuICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7IC8vIERvIG5vdCB0cmlnZ2VyIGBtb3VzZW91dGAgaGVyZSwgaW4gc3BpdGUgb2YgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIGlzXG4gICAgLy8gdHJpZ2dlcmVkIGluIGB0b3VjaHN0YXJ0YC4gVGhpcyBzZWVtcyB0byBiZSBpbGxvZ2ljYWwsIGJ1dCBieSB0aGlzIG1lY2hhbmlzbSxcbiAgICAvLyB3ZSBjYW4gY29udmVuaWVudGx5IGltcGxlbWVudCBcImhvdmVyIHN0eWxlXCIgaW4gYm90aCBQQyBhbmQgdG91Y2ggZGV2aWNlIGp1c3RcbiAgICAvLyBieSBsaXN0ZW5pbmcgdG8gYG1vdXNlb3ZlcmAgdG8gYWRkIFwiaG92ZXIgc3R5bGVcIiBhbmQgbGlzdGVuaW5nIHRvIGBtb3VzZW91dGBcbiAgICAvLyB0byByZW1vdmUgXCJob3ZlciBzdHlsZVwiIG9uIGFuIGVsZW1lbnQsIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgY29kZSBmb3JcbiAgICAvLyBjb21wYXRpYmlsaXR5LiAoYG1vdXNlb3V0YCB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgaW4gYHRvdWNoZW5kYCwgc28gXCJob3ZlclxuICAgIC8vIHN0eWxlXCIgd2lsbCByZW1haW4gZm9yIHVzZXIgdmlldylcbiAgICAvLyBjbGljayBldmVudCBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cblxuICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICBkb21IYW5kbGVycy5jbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICB9LFxuICBwb2ludGVyZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpOyAvLyBpZiAodXNlTVNHdWVzdHVyZSh0aGlzLCBldmVudCkpIHtcbiAgICAvLyAgICAgdGhpcy5fbXNHZXN0dXJlLmFkZFBvaW50ZXIoZXZlbnQucG9pbnRlcklkKTtcbiAgICAvLyB9XG4gIH0sXG4gIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIHBvaW50ZXJtb3ZlIGlzIHNvIHNlbnNpdGl2ZSB0aGF0IGl0IGFsd2F5cyB0cmlnZ2VyZWQgd2hlblxuICAgIC8vIHRhcChjbGljaykgb24gdG91Y2ggc2NyZWVuLCB3aGljaCBhZmZlY3Qgc29tZSBqdWRnZW1lbnQgaW5cbiAgICAvLyB1cHBlciBhcHBsaWNhdGlvbi4gU28sIHdlIGRvbnQgc3VwcG9ydCBtb3VzZW1vdmUgb24gTVMgdG91Y2hcbiAgICAvLyBkZXZpY2UgeWV0LlxuICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgcG9pbnRlcnVwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBkb21IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpO1xuICB9LFxuICBwb2ludGVyb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBwb2ludGVyb3V0IHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGFwIG9uIHRvdWNoIHNjcmVlblxuICAgIC8vIChJRTExKy9FZGdlIG9uIE1TIFN1cmZhY2UpIGFmdGVyIGNsaWNrIGV2ZW50IHRyaWdnZXJlZCxcbiAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgbW91c291dCBiZWhhdmlvciB3ZSBkZWZpbmVkXG4gICAgLy8gaW4gdG91Y2hlbmQuIFNvIHdlIHVuaWZ5IHRoZW0uXG4gICAgLy8gKGNoZWNrIGRvbUhhbmRsZXJzLnRvdWNoZW5kIGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbilcbiAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgIGRvbUhhbmRsZXJzLm1vdXNlb3V0LmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSB7XG4gIHZhciBwb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICByZXR1cm4gcG9pbnRlclR5cGUgPT09ICdwZW4nIHx8IHBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xufSAvLyBmdW5jdGlvbiB1c2VNU0d1ZXN0dXJlKGhhbmRsZXJQcm94eSwgZXZlbnQpIHtcbi8vICAgICByZXR1cm4gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSAmJiAhIWhhbmRsZXJQcm94eS5fbXNHZXN0dXJlO1xuLy8gfVxuLy8gQ29tbW9uIGhhbmRsZXJzXG5cblxuenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHRoaXMudHJpZ2dlcihuYW1lLCBldmVudCk7XG4gIH07XG59KTtcbi8qKlxuICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAqL1xuXG5mdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICB6clV0aWwuZWFjaCh0b3VjaEhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICB9KTtcbiAgenJVdGlsLmVhY2gocG9pbnRlckhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICB9KTtcbiAgenJVdGlsLmVhY2gobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0gbWFrZU1vdXNlSGFuZGxlcihkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICB9KTtcblxuICBmdW5jdGlvbiBtYWtlTW91c2VIYW5kbGVyKGZuLCBpbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuX3RvdWNoaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gSGFuZGxlckRvbVByb3h5KGRvbSkge1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICB0aGlzLmRvbSA9IGRvbTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuICB0aGlzLl90b3VjaGluZyA9IGZhbHNlO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fdG91Y2hUaW1lcjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0dlc3R1cmVNZ3J9XG4gICAqL1xuXG4gIHRoaXMuX2dlc3R1cmVNZ3IgPSBuZXcgR2VzdHVyZU1ncigpO1xuICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICBpbml0RG9tSGFuZGxlcih0aGlzKTtcblxuICBpZiAoZW52LnBvaW50ZXJFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAvLyBPbmx5IElFMTErL0VkZ2VcbiAgICAvLyAxLiBPbiBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIChlLmcuLCBNUyBTdXJmYWNlIGFuZCBsZW5vdm8gWDI0MCksXG4gICAgLy8gSUUxMSsvRWRnZSBkbyBub3QgdHJpZ2dlciB0b3VjaCBldmVudCwgYnV0IHRyaWdnZXIgcG9pbnRlciBldmVudCBhbmQgbW91c2UgZXZlbnRcbiAgICAvLyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIDIuIE9uIE1TIFN1cmZhY2UsIGl0IHByb2JhYmxlbHkgb25seSB0cmlnZ2VyIG1vdXNlZG93biBidXQgbm8gbW91c2V1cCB3aGVuIHRhcCBvblxuICAgIC8vIHNjcmVlbiwgd2hpY2ggZG8gbm90IG9jY3VycyBpbiBwb2ludGVyIGV2ZW50LlxuICAgIC8vIFNvIHdlIHVzZSBwb2ludGVyIGV2ZW50IHRvIGJvdGggZGV0ZWN0IHRvdWNoIGdlc3R1cmUgYW5kIG1vdXNlIGJlaGF2aW9yLlxuICAgIG1vdW50SGFuZGxlcnMocG9pbnRlckhhbmRsZXJOYW1lcywgdGhpcyk7IC8vIEZJWE1FXG4gICAgLy8gTm90ZTogTVMgR2VzdHVyZSByZXF1aXJlIENTUyB0b3VjaC1hY3Rpb24gc2V0LiBCdXQgdG91Y2gtYWN0aW9uIGlzIG5vdCByZWxpYWJsZSxcbiAgICAvLyB3aGljaCBkb2VzIG5vdCBwcmV2ZW50IGRlZnVhdWx0IGJlaGF2aW9yIG9jY2FzaW9uYWxseSAod2hpY2ggbWF5IGNhdXNlIHZpZXcgcG9ydFxuICAgIC8vIHpvb21lZCBpbiBidXQgdXNlIGNhbiBub3Qgem9vbSBpdCBiYWNrKS4gQW5kIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgZG9lcyBub3Qgd29yay5cbiAgICAvLyBTbyB3ZSBoYXZlIHRvIG5vdCB0byB1c2UgTVNHZXN0dXJlIGFuZCBub3QgdG8gc3VwcG9ydCB0b3VjaG1vdmUgYW5kIHBpbmNoIG9uIE1TXG4gICAgLy8gdG91Y2ggc2NyZWVuLiBBbmQgd2Ugb25seSBzdXBwb3J0IGNsaWNrIGJlaGF2aW9yIG9uIE1TIHRvdWNoIHNjcmVlbiBub3cuXG4gICAgLy8gTVMgR2VzdHVyZSBFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBJRTExKy9FZGdlIGFuZCBvbiBXaW5kb3dzIDgrLlxuICAgIC8vIFdlIGRvbnQgc3VwcG9ydCB0b3VjaCBvbiBJRSBvbiB3aW43LlxuICAgIC8vIFNlZSA8aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0Myh2PXZzLjg1KS5hc3B4PlxuICAgIC8vIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgICh0aGlzLl9tc0dlc3R1cmUgPSBuZXcgTVNHZXN0dXJlKCkpLnRhcmdldCA9IGRvbTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgLy8gICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCdNU0dlc3R1cmVDaGFuZ2UnLCBvbk1TR2VzdHVyZUNoYW5nZSk7XG4gICAgLy8gfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbnYudG91Y2hFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAgIG1vdW50SGFuZGxlcnModG91Y2hIYW5kbGVyTmFtZXMsIHRoaXMpOyAvLyBIYW5kbGVyIG9mICdtb3VzZW91dCcgZXZlbnQgaXMgbmVlZGVkIGluIHRvdWNoIG1vZGUsIHdoaWNoIHdpbGwgYmUgbW91bnRlZCBiZWxvdy5cbiAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICB9IC8vIDEuIENvbnNpZGVyaW5nIHNvbWUgZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSBldmVudCAobGlrZSBvbiBNUyBTdXJmYWNlXG4gICAgLy8gYW5kIGxlbm92byBYMjQwLCBAc2VlICMyMzUwKSwgd2UgbWFrZSBtb3VzZSBldmVudCBiZSBhbHdheXMgbGlzdGVuZWQsIG90aGVyd2lzZVxuICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgQ2hyb21lIHdpbGwgdHJpZ2dlciBib3RoIHRvdWNoIGV2ZW50IGFuZCBtb3VzZSBldmVudC4gSG93IHRvIHByZXZlbnRcbiAgICAvLyBtb3VzZWV2ZW50IGFmdGVyIHRvdWNoIGV2ZW50IHRyaWdnZXJlZCwgc2VlIGBzZXRUb3VjaFRpbWVyYC5cblxuXG4gICAgbW91bnRIYW5kbGVycyhtb3VzZUhhbmRsZXJOYW1lcywgdGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEhhbmRsZXJzKGhhbmRsZXJOYW1lcywgaW5zdGFuY2UpIHtcbiAgICB6clV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGRvbSwgZXZlbnROYW1lRml4KG5hbWUpLCBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0pO1xuICAgIH0sIGluc3RhbmNlKTtcbiAgfVxufVxuXG52YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuXG5oYW5kbGVyRG9tUHJveHlQcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGFuZGxlck5hbWVzID0gbW91c2VIYW5kbGVyTmFtZXMuY29uY2F0KHRvdWNoSGFuZGxlck5hbWVzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gaGFuZGxlck5hbWVzW2ldO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICB9XG59O1xuXG5oYW5kbGVyRG9tUHJveHlQcm90by5zZXRDdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgdGhpcy5kb20uc3R5bGUuY3Vyc29yID0gY3Vyc29yU3R5bGUgfHwgJ2RlZmF1bHQnO1xufTtcblxuenJVdGlsLm1peGluKEhhbmRsZXJEb21Qcm94eSwgRXZlbnRmdWwpO1xudmFyIF9kZWZhdWx0ID0gSGFuZGxlckRvbVByb3h5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZXZlbnRVdGlsID0gcmVxdWlyZShcIi4vZXZlbnRcIik7XG5cbi8qKlxuICogT25seSBpbXBsZW1lbnRzIG5lZWRlZCBnZXN0dXJlcyBmb3IgbW9iaWxlLlxuICovXG52YXIgR2VzdHVyZU1nciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICovXG4gIHRoaXMuX3RyYWNrID0gW107XG59O1xuXG5HZXN0dXJlTWdyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdlc3R1cmVNZ3IsXG4gIHJlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICB0aGlzLl9kb1RyYWNrKGV2ZW50LCB0YXJnZXQsIHJvb3QpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZShldmVudCk7XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdHJhY2subGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2RvVHJhY2s6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuXG4gICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrSXRlbSA9IHtcbiAgICAgIHBvaW50czogW10sXG4gICAgICB0b3VjaGVzOiBbXSxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuICAgICAgdmFyIHBvcyA9IGV2ZW50VXRpbC5jbGllbnRUb0xvY2FsKHJvb3QsIHRvdWNoLCB7fSk7XG4gICAgICB0cmFja0l0ZW0ucG9pbnRzLnB1c2goW3Bvcy56clgsIHBvcy56clldKTtcbiAgICAgIHRyYWNrSXRlbS50b3VjaGVzLnB1c2godG91Y2gpO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYWNrLnB1c2godHJhY2tJdGVtKTtcbiAgfSxcbiAgX3JlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHJlY29nbml6ZXJzKSB7XG4gICAgICBpZiAocmVjb2duaXplcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSByZWNvZ25pemVyc1tldmVudE5hbWVdKHRoaXMuX3RyYWNrLCBldmVudCk7XG5cbiAgICAgICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIGdlc3R1cmVJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBkaXN0KHBvaW50UGFpcikge1xuICB2YXIgZHggPSBwb2ludFBhaXJbMV1bMF0gLSBwb2ludFBhaXJbMF1bMF07XG4gIHZhciBkeSA9IHBvaW50UGFpclsxXVsxXSAtIHBvaW50UGFpclswXVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRlcihwb2ludFBhaXIpIHtcbiAgcmV0dXJuIFsocG9pbnRQYWlyWzBdWzBdICsgcG9pbnRQYWlyWzFdWzBdKSAvIDIsIChwb2ludFBhaXJbMF1bMV0gKyBwb2ludFBhaXJbMV1bMV0pIC8gMl07XG59XG5cbnZhciByZWNvZ25pemVycyA9IHtcbiAgcGluY2g6IGZ1bmN0aW9uICh0cmFjaywgZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tMZW4gPSB0cmFjay5sZW5ndGg7XG5cbiAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBpbmNoRW5kID0gKHRyYWNrW3RyYWNrTGVuIC0gMV0gfHwge30pLnBvaW50cztcbiAgICB2YXIgcGluY2hQcmUgPSAodHJhY2tbdHJhY2tMZW4gLSAyXSB8fCB7fSkucG9pbnRzIHx8IHBpbmNoRW5kO1xuXG4gICAgaWYgKHBpbmNoUHJlICYmIHBpbmNoUHJlLmxlbmd0aCA+IDEgJiYgcGluY2hFbmQgJiYgcGluY2hFbmQubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIHBpbmNoU2NhbGUgPSBkaXN0KHBpbmNoRW5kKSAvIGRpc3QocGluY2hQcmUpO1xuICAgICAgIWlzRmluaXRlKHBpbmNoU2NhbGUpICYmIChwaW5jaFNjYWxlID0gMSk7XG4gICAgICBldmVudC5waW5jaFNjYWxlID0gcGluY2hTY2FsZTtcbiAgICAgIHZhciBwaW5jaENlbnRlciA9IGNlbnRlcihwaW5jaEVuZCk7XG4gICAgICBldmVudC5waW5jaFggPSBwaW5jaENlbnRlclswXTtcbiAgICAgIGV2ZW50LnBpbmNoWSA9IHBpbmNoQ2VudGVyWzFdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3BpbmNoJyxcbiAgICAgICAgdGFyZ2V0OiB0cmFja1swXS50YXJnZXQsXG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gT25seSBwaW5jaCBjdXJyZW50bHkuXG5cbn07XG52YXIgX2RlZmF1bHQgPSBHZXN0dXJlTWdyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuL01vZGVsXCIpO1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKFwiLi9Db21wb25lbnRcIik7XG5cbnZhciBnbG9iYWxEZWZhdWx0ID0gcmVxdWlyZShcIi4vZ2xvYmFsRGVmYXVsdFwiKTtcblxudmFyIGNvbG9yUGFsZXR0ZU1pbmluID0gcmVxdWlyZShcIi4vbWl4aW4vY29sb3JQYWxldHRlXCIpO1xuXG4vKipcbiAqIEVDaGFydHMgZ2xvYmFsIG1vZGVsXG4gKlxuICogQG1vZHVsZSB7ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gKi9cblxuLyoqXG4gKiBDYXV0aW9uOiBJZiB0aGUgbWVjaGFuaXNtIHNob3VsZCBiZSBjaGFuZ2VkIHNvbWUgZGF5LCB0aGVzZSBjYXNlc1xuICogc2hvdWxkIGJlIGNvbnNpZGVyZWQ6XG4gKlxuICogKDEpIEluIGBtZXJnZSBvcHRpb25gIG1vZGUsIGlmIHVzaW5nIHRoZSBzYW1lIG9wdGlvbiB0byBjYWxsIGBzZXRPcHRpb25gXG4gKiBtYW55IHRpbWVzLCB0aGUgcmVzdWx0IHNob3VsZCBiZSB0aGUgc2FtZSAodHJ5IG91ciBiZXN0IHRvIGVuc3VyZSB0aGF0KS5cbiAqICgyKSBJbiBgbWVyZ2Ugb3B0aW9uYCBtb2RlLCBpZiBhIGNvbXBvbmVudCBoYXMgbm8gaWQvbmFtZSBzcGVjaWZpZWQsIGl0XG4gKiB3aWxsIGJlIG1lcmdlZCBieSBpbmRleCwgYW5kIHRoZSByZXN1bHQgc2VxdWVuY2Ugb2YgdGhlIGNvbXBvbmVudHMgaXNcbiAqIGNvbnNpc3RlbnQgdG8gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxuICogKDMpIGByZXNldGAgZmVhdHVyZSAoaW4gdG9vbGJveCkuIEZpbmQgZGV0YWlsZWQgaW5mbyBpbiBjb21tZW50cyBhYm91dFxuICogYG1lcmdlT3B0aW9uYCBpbiBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb25NYW5hZ2VyLlxuICovXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGZpbHRlciA9IHpyVXRpbC5maWx0ZXI7XG52YXIgbWFwID0genJVdGlsLm1hcDtcbnZhciBpc0FycmF5ID0genJVdGlsLmlzQXJyYXk7XG52YXIgaW5kZXhPZiA9IHpyVXRpbC5pbmRleE9mO1xudmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xudmFyIE9QVElPTl9JTk5FUl9LRVkgPSAnXFwwX2VjX2lubmVyJztcbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHBhcmVudE1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gdGhlbWVcbiAqL1xuXG52YXIgR2xvYmFsTW9kZWwgPSBNb2RlbC5leHRlbmQoe1xuICBjb25zdHJ1Y3RvcjogR2xvYmFsTW9kZWwsXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCB0aGVtZSwgb3B0aW9uTWFuYWdlcikge1xuICAgIHRoZW1lID0gdGhlbWUgfHwge307XG4gICAgdGhpcy5vcHRpb24gPSBudWxsOyAvLyBNYXJrIGFzIG5vdCBpbml0aWFsaXplZC5cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fdGhlbWUgPSBuZXcgTW9kZWwodGhlbWUpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb25NYW5hZ2VyfVxuICAgICAqL1xuXG4gICAgdGhpcy5fb3B0aW9uTWFuYWdlciA9IG9wdGlvbk1hbmFnZXI7XG4gIH0sXG4gIHNldE9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpIHtcbiAgICB6clV0aWwuYXNzZXJ0KCEoT1BUSU9OX0lOTkVSX0tFWSBpbiBvcHRpb24pLCAncGxlYXNlIHVzZSBjaGFydC5nZXRPcHRpb24oKScpO1xuXG4gICAgdGhpcy5fb3B0aW9uTWFuYWdlci5zZXRPcHRpb24ob3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcyk7XG5cbiAgICB0aGlzLnJlc2V0T3B0aW9uKG51bGwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBudWxsL3VuZGVmaW5lZDogcmVzZXQgYWxsLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAncmVjcmVhdGUnOiBmb3JjZSByZWNyZWF0ZSBhbGwuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICd0aW1lbGluZSc6IG9ubHkgcmVzZXQgdGltZWxpbmUgb3B0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICdtZWRpYSc6IG9ubHkgcmVzZXQgbWVkaWEgcXVlcnkgb3B0aW9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3B0aW9uIGNoYW5nZWQuXG4gICAqL1xuICByZXNldE9wdGlvbjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgb3B0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBvcHRpb25NYW5hZ2VyID0gdGhpcy5fb3B0aW9uTWFuYWdlcjtcblxuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnKSB7XG4gICAgICB2YXIgYmFzZU9wdGlvbiA9IG9wdGlvbk1hbmFnZXIubW91bnRPcHRpb24odHlwZSA9PT0gJ3JlY3JlYXRlJyk7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb24gfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJykge1xuICAgICAgICBpbml0QmFzZS5jYWxsKHRoaXMsIGJhc2VPcHRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlRGF0YSgpO1xuICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKGJhc2VPcHRpb24pO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3RpbWVsaW5lJyB8fCB0eXBlID09PSAnbWVkaWEnKSB7XG4gICAgICB0aGlzLnJlc3RvcmVEYXRhKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScgfHwgdHlwZSA9PT0gJ3RpbWVsaW5lJykge1xuICAgICAgdmFyIHRpbWVsaW5lT3B0aW9uID0gb3B0aW9uTWFuYWdlci5nZXRUaW1lbGluZU9wdGlvbih0aGlzKTtcbiAgICAgIHRpbWVsaW5lT3B0aW9uICYmICh0aGlzLm1lcmdlT3B0aW9uKHRpbWVsaW5lT3B0aW9uKSwgb3B0aW9uQ2hhbmdlZCA9IHRydWUpO1xuICAgIH1cblxuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnIHx8IHR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAgIHZhciBtZWRpYU9wdGlvbnMgPSBvcHRpb25NYW5hZ2VyLmdldE1lZGlhT3B0aW9uKHRoaXMsIHRoaXMuX2FwaSk7XG5cbiAgICAgIGlmIChtZWRpYU9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGVhY2gobWVkaWFPcHRpb25zLCBmdW5jdGlvbiAobWVkaWFPcHRpb24pIHtcbiAgICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKG1lZGlhT3B0aW9uLCBvcHRpb25DaGFuZ2VkID0gdHJ1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25DaGFuZ2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG4gICAgdmFyIG5ld0NwdFR5cGVzID0gW107IC8vIOWmguaenOS4jeWtmOWcqOWvueW6lOeahCBjb21wb25lbnQgbW9kZWwg5YiZ55u05o6lIG1lcmdlXG5cbiAgICBlYWNoKG5ld09wdGlvbiwgZnVuY3Rpb24gKGNvbXBvbmVudE9wdGlvbiwgbWFpblR5cGUpIHtcbiAgICAgIGlmIChjb21wb25lbnRPcHRpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICAgIG9wdGlvblttYWluVHlwZV0gPSBvcHRpb25bbWFpblR5cGVdID09IG51bGwgPyB6clV0aWwuY2xvbmUoY29tcG9uZW50T3B0aW9uKSA6IHpyVXRpbC5tZXJnZShvcHRpb25bbWFpblR5cGVdLCBjb21wb25lbnRPcHRpb24sIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Q3B0VHlwZXMucHVzaChtYWluVHlwZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIEZJWE1FIE9QVElPTiDlkIzmraXmmK/lkKbopoHmlLnlm57ljp/mnaXnmoRcblxuICAgIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsKG5ld0NwdFR5cGVzLCBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcygpLCB2aXNpdENvbXBvbmVudCwgdGhpcyk7XG4gICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IHRoaXMuX3Nlcmllc0luZGljZXMgfHwgW107XG5cbiAgICBmdW5jdGlvbiB2aXNpdENvbXBvbmVudChtYWluVHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICB2YXIgbmV3Q3B0T3B0aW9uTGlzdCA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG5ld09wdGlvblttYWluVHlwZV0pO1xuICAgICAgdmFyIG1hcFJlc3VsdCA9IG1vZGVsVXRpbC5tYXBwaW5nVG9FeGlzdHMoY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpLCBuZXdDcHRPcHRpb25MaXN0KTtcbiAgICAgIG1vZGVsVXRpbC5tYWtlSWRBbmROYW1lKG1hcFJlc3VsdCk7IC8vIFNldCBtYWluVHlwZSBhbmQgY29tcGxldGUgc3ViVHlwZS5cblxuICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICB2YXIgb3B0ID0gaXRlbS5vcHRpb247XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcbiAgICAgICAgICBpdGVtLmtleUluZm8ubWFpblR5cGUgPSBtYWluVHlwZTtcbiAgICAgICAgICBpdGVtLmtleUluZm8uc3ViVHlwZSA9IGRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG9wdCwgaXRlbS5leGlzdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGRlcGVuZGVudE1vZGVscyA9IGdldENvbXBvbmVudHNCeVR5cGVzKGNvbXBvbmVudHNNYXAsIGRlcGVuZGVuY2llcyk7XG4gICAgICBvcHRpb25bbWFpblR5cGVdID0gW107XG4gICAgICBjb21wb25lbnRzTWFwLnNldChtYWluVHlwZSwgW10pO1xuICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChyZXN1bHRJdGVtLCBpbmRleCkge1xuICAgICAgICB2YXIgY29tcG9uZW50TW9kZWwgPSByZXN1bHRJdGVtLmV4aXN0O1xuICAgICAgICB2YXIgbmV3Q3B0T3B0aW9uID0gcmVzdWx0SXRlbS5vcHRpb247XG4gICAgICAgIHpyVXRpbC5hc3NlcnQoaXNPYmplY3QobmV3Q3B0T3B0aW9uKSB8fCBjb21wb25lbnRNb2RlbCwgJ0VtcHR5IGNvbXBvbmVudCBkZWZpbml0aW9uJyk7IC8vIENvbnNpZGVyIHdoZXJlIGlzIG5vIG5ldyBvcHRpb24gYW5kIHNob3VsZCBiZSBtZXJnZWQgdXNpbmcge30sXG4gICAgICAgIC8vIHNlZSByZW1vdmVFZGdlQW5kQWRkIGluIHRvcG9sb2dpY2FsVHJhdmVsIGFuZFxuICAgICAgICAvLyBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcy5cblxuICAgICAgICBpZiAoIW5ld0NwdE9wdGlvbikge1xuICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm1lcmdlT3B0aW9uKHt9LCB0aGlzKTtcbiAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKHt9LCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIENvbXBvbmVudE1vZGVsQ2xhc3MgPSBDb21wb25lbnRNb2RlbC5nZXRDbGFzcyhtYWluVHlwZSwgcmVzdWx0SXRlbS5rZXlJbmZvLnN1YlR5cGUsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKGNvbXBvbmVudE1vZGVsICYmIGNvbXBvbmVudE1vZGVsIGluc3RhbmNlb2YgQ29tcG9uZW50TW9kZWxDbGFzcykge1xuICAgICAgICAgICAgY29tcG9uZW50TW9kZWwubmFtZSA9IHJlc3VsdEl0ZW0ua2V5SW5mby5uYW1lO1xuICAgICAgICAgICAgY29tcG9uZW50TW9kZWwubWVyZ2VPcHRpb24obmV3Q3B0T3B0aW9uLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm9wdGlvblVwZGF0ZWQobmV3Q3B0T3B0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgR2xvYmFsIGFzIHBhcmVudCA/XG4gICAgICAgICAgICB2YXIgZXh0cmFPcHQgPSB6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgZGVwZW5kZW50TW9kZWxzOiBkZXBlbmRlbnRNb2RlbHMsXG4gICAgICAgICAgICAgIGNvbXBvbmVudEluZGV4OiBpbmRleFxuICAgICAgICAgICAgfSwgcmVzdWx0SXRlbS5rZXlJbmZvKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsID0gbmV3IENvbXBvbmVudE1vZGVsQ2xhc3MobmV3Q3B0T3B0aW9uLCB0aGlzLCB0aGlzLCBleHRyYU9wdCk7XG4gICAgICAgICAgICB6clV0aWwuZXh0ZW5kKGNvbXBvbmVudE1vZGVsLCBleHRyYU9wdCk7XG4gICAgICAgICAgICBjb21wb25lbnRNb2RlbC5pbml0KG5ld0NwdE9wdGlvbiwgdGhpcywgdGhpcywgZXh0cmFPcHQpOyAvLyBDYWxsIG9wdGlvblVwZGF0ZWQgYWZ0ZXIgaW5pdC5cbiAgICAgICAgICAgIC8vIG5ld0NwdE9wdGlvbiBoYXMgYmVlbiB1c2VkIGFzIGNvbXBvbmVudE1vZGVsLm9wdGlvblxuICAgICAgICAgICAgLy8gYW5kIG1heSBiZSBtZXJnZWQgd2l0aCB0aGVtZSBhbmQgZGVmYXVsdCwgc28gcGFzcyBudWxsXG4gICAgICAgICAgICAvLyB0byBhdm9pZCBjb25mdXNpb24uXG5cbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm9wdGlvblVwZGF0ZWQobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpW2luZGV4XSA9IGNvbXBvbmVudE1vZGVsO1xuICAgICAgICBvcHRpb25bbWFpblR5cGVdW2luZGV4XSA9IGNvbXBvbmVudE1vZGVsLm9wdGlvbjtcbiAgICAgIH0sIHRoaXMpOyAvLyBCYWNrdXAgc2VyaWVzIGZvciBmaWx0ZXJpbmcuXG5cbiAgICAgIGlmIChtYWluVHlwZSA9PT0gJ3NlcmllcycpIHtcbiAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IGNyZWF0ZVNlcmllc0luZGljZXMoY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBvcHRpb24gZm9yIG91dHB1dCAoY2xvbmVkIG9wdGlvbiBhbmQgaW5uZXIgaW5mbyByZW1vdmVkKVxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE9wdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb24gPSB6clV0aWwuY2xvbmUodGhpcy5vcHRpb24pO1xuICAgIGVhY2gob3B0aW9uLCBmdW5jdGlvbiAob3B0cywgbWFpblR5cGUpIHtcbiAgICAgIGlmIChDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhtYWluVHlwZSkpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShvcHRzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gb3B0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIC8vIFJlbW92ZSBvcHRpb25zIHdpdGggaW5uZXIgaWQuXG4gICAgICAgICAgaWYgKG1vZGVsVXRpbC5pc0lkSW5uZXIob3B0c1tpXSkpIHtcbiAgICAgICAgICAgIG9wdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvblttYWluVHlwZV0gPSBvcHRzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlbGV0ZSBvcHRpb25bT1BUSU9OX0lOTkVSX0tFWV07XG4gICAgcmV0dXJuIG9wdGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAqL1xuICBnZXRUaGVtZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90aGVtZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1haW5UeXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaWR4PTBdXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH1cbiAgICovXG4gIGdldENvbXBvbmVudDogZnVuY3Rpb24gKG1haW5UeXBlLCBpZHgpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKTtcblxuICAgIGlmIChsaXN0KSB7XG4gICAgICByZXR1cm4gbGlzdFtpZHggfHwgMF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBub25lIG9mIGluZGV4IGFuZCBpZCBhbmQgbmFtZSB1c2VkLCByZXR1cm4gYWxsIGNvbXBvbmVudHMgd2l0aCBtYWluVHlwZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmRpdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZGl0aW9uLm1haW5UeXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZGl0aW9uLnN1YlR5cGVdIElmIGlnbm9yZSwgb25seSBxdWVyeSBieSBtYWluVHlwZVxuICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW2NvbmRpdGlvbi5pbmRleF0gRWl0aGVyIGlucHV0IGluZGV4IG9yIGlkIG9yIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbY29uZGl0aW9uLmlkXSBFaXRoZXIgaW5wdXQgaW5kZXggb3IgaWQgb3IgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtjb25kaXRpb24ubmFtZV0gRWl0aGVyIGlucHV0IGluZGV4IG9yIGlkIG9yIG5hbWUuXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnQ+fVxuICAgKi9cbiAgcXVlcnlDb21wb25lbnRzOiBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgdmFyIG1haW5UeXBlID0gY29uZGl0aW9uLm1haW5UeXBlO1xuXG4gICAgaWYgKCFtYWluVHlwZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGNvbmRpdGlvbi5pbmRleDtcbiAgICB2YXIgaWQgPSBjb25kaXRpb24uaWQ7XG4gICAgdmFyIG5hbWUgPSBjb25kaXRpb24ubmFtZTtcblxuICAgIHZhciBjcHRzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpO1xuXG4gICAgaWYgKCFjcHRzIHx8ICFjcHRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgaWYgKCFpc0FycmF5KGluZGV4KSkge1xuICAgICAgICBpbmRleCA9IFtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IGZpbHRlcihtYXAoaW5kZXgsIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIGNwdHNbaWR4XTtcbiAgICAgIH0pLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiAhIXZhbDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgdmFyIGlzSWRBcnJheSA9IGlzQXJyYXkoaWQpO1xuICAgICAgcmVzdWx0ID0gZmlsdGVyKGNwdHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICAgICAgcmV0dXJuIGlzSWRBcnJheSAmJiBpbmRleE9mKGlkLCBjcHQuaWQpID49IDAgfHwgIWlzSWRBcnJheSAmJiBjcHQuaWQgPT09IGlkO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgIHZhciBpc05hbWVBcnJheSA9IGlzQXJyYXkobmFtZSk7XG4gICAgICByZXN1bHQgPSBmaWx0ZXIoY3B0cywgZnVuY3Rpb24gKGNwdCkge1xuICAgICAgICByZXR1cm4gaXNOYW1lQXJyYXkgJiYgaW5kZXhPZihuYW1lLCBjcHQubmFtZSkgPj0gMCB8fCAhaXNOYW1lQXJyYXkgJiYgY3B0Lm5hbWUgPT09IG5hbWU7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0dXJuIGFsbCBjb21wb25lbnRzIHdpdGggbWFpblR5cGVcbiAgICAgIHJlc3VsdCA9IGNwdHMuc2xpY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsdGVyQnlTdWJUeXBlKHJlc3VsdCwgY29uZGl0aW9uKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGludGVyZmFjZSBpcyBkaWZmZXJlbnQgZnJvbSBxdWVyeUNvbXBvbmVudHMsXG4gICAqIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yIGlubmVyIHVzYWdlLlxuICAgKlxuICAgKiBAdXNhZ2VcbiAgICogdmFyIHJlc3VsdCA9IGZpbmRDb21wb25lbnRzKFxuICAgKiAgICAge21haW5UeXBlOiAnZGF0YVpvb20nLCBxdWVyeToge2RhdGFab29tSWQ6ICdhYmMnfX1cbiAgICogKTtcbiAgICogdmFyIHJlc3VsdCA9IGZpbmRDb21wb25lbnRzKFxuICAgKiAgICAge21haW5UeXBlOiAnc2VyaWVzJywgc3ViVHlwZTogJ3BpZScsIHF1ZXJ5OiB7c2VyaWVzTmFtZTogJ3Vpbyd9fVxuICAgKiApO1xuICAgKiB2YXIgcmVzdWx0ID0gZmluZENvbXBvbmVudHMoXG4gICAqICAgICB7bWFpblR5cGU6ICdzZXJpZXMnfSxcbiAgICogICAgIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHsuLi59XG4gICAqICk7XG4gICAqIC8vIHJlc3VsdCBsaWtlIFtjb21wb25lbnQwLCBjb21wb25uZXQxLCAuLi5dXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmRpdGlvbi5tYWluVHlwZSBNYW5kYXRvcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZGl0aW9uLnN1YlR5cGVdIE9wdGlvbmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmRpdGlvbi5xdWVyeV0gbGlrZSB7eHh4SW5kZXgsIHh4eElkLCB4eHhOYW1lfSxcbiAgICogICAgICAgIHdoZXJlIHh4eCBpcyBtYWluVHlwZS5cbiAgICogICAgICAgIElmIHF1ZXJ5IGF0dHJpYnV0ZSBpcyBudWxsL3VuZGVmaW5lZCBvciBoYXMgbm8gaW5kZXgvaWQvbmFtZSxcbiAgICogICAgICAgIGRvIG5vdCBmaWx0ZXJpbmcgYnkgcXVlcnkgY29uZGl0aW9ucywgd2hpY2ggaXMgY29udmVuaWVudCBmb3JcbiAgICogICAgICAgIG5vLXBheWxvYWQgc2l0dWF0aW9ucyBvciB3aGVuIHRhcmdldCBvZiBhY3Rpb24gaXMgZ2xvYmFsLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZGl0aW9uLmZpbHRlcl0gcGFyYW1ldGVyOiBjb21wb25lbnQsIHJldHVybiBib29sZWFuLlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50Pn1cbiAgICovXG4gIGZpbmRDb21wb25lbnRzOiBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgdmFyIHF1ZXJ5ID0gY29uZGl0aW9uLnF1ZXJ5O1xuICAgIHZhciBtYWluVHlwZSA9IGNvbmRpdGlvbi5tYWluVHlwZTtcbiAgICB2YXIgcXVlcnlDb25kID0gZ2V0UXVlcnlDb25kKHF1ZXJ5KTtcbiAgICB2YXIgcmVzdWx0ID0gcXVlcnlDb25kID8gdGhpcy5xdWVyeUNvbXBvbmVudHMocXVlcnlDb25kKSA6IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKTtcbiAgICByZXR1cm4gZG9GaWx0ZXIoZmlsdGVyQnlTdWJUeXBlKHJlc3VsdCwgY29uZGl0aW9uKSk7XG5cbiAgICBmdW5jdGlvbiBnZXRRdWVyeUNvbmQocSkge1xuICAgICAgdmFyIGluZGV4QXR0ciA9IG1haW5UeXBlICsgJ0luZGV4JztcbiAgICAgIHZhciBpZEF0dHIgPSBtYWluVHlwZSArICdJZCc7XG4gICAgICB2YXIgbmFtZUF0dHIgPSBtYWluVHlwZSArICdOYW1lJztcbiAgICAgIHJldHVybiBxICYmIChxW2luZGV4QXR0cl0gIT0gbnVsbCB8fCBxW2lkQXR0cl0gIT0gbnVsbCB8fCBxW25hbWVBdHRyXSAhPSBudWxsKSA/IHtcbiAgICAgICAgbWFpblR5cGU6IG1haW5UeXBlLFxuICAgICAgICAvLyBzdWJUeXBlIHdpbGwgYmUgZmlsdGVyZWQgZmluYWxseS5cbiAgICAgICAgaW5kZXg6IHFbaW5kZXhBdHRyXSxcbiAgICAgICAgaWQ6IHFbaWRBdHRyXSxcbiAgICAgICAgbmFtZTogcVtuYW1lQXR0cl1cbiAgICAgIH0gOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvRmlsdGVyKHJlcykge1xuICAgICAgcmV0dXJuIGNvbmRpdGlvbi5maWx0ZXIgPyBmaWx0ZXIocmVzLCBjb25kaXRpb24uZmlsdGVyKSA6IHJlcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB1c2FnZVxuICAgKiBlYWNoQ29tcG9uZW50KCdsZWdlbmQnLCBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGluZGV4KSB7XG4gICAqICAgICAuLi5cbiAgICogfSk7XG4gICAqIGVhY2hDb21wb25lbnQoZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIG1vZGVsLCBpbmRleCkge1xuICAgKiAgICAgLy8gY29tcG9uZW50VHlwZSBkb2VzIG5vdCBpbmNsdWRlIHN1YlR5cGVcbiAgICogICAgIC8vIChjb21wb25lbnRUeXBlIGlzICd4eHgnIGJ1dCBub3QgJ3h4eC5hYScpXG4gICAqIH0pO1xuICAgKiBlYWNoQ29tcG9uZW50KFxuICAgKiAgICAge21haW5UeXBlOiAnZGF0YVpvb20nLCBxdWVyeToge2RhdGFab29tSWQ6ICdhYmMnfX0sXG4gICAqICAgICBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7Li4ufVxuICAgKiApO1xuICAgKiBlYWNoQ29tcG9uZW50KFxuICAgKiAgICAge21haW5UeXBlOiAnc2VyaWVzJywgc3ViVHlwZTogJ3BpZScsIHF1ZXJ5OiB7c2VyaWVzTmFtZTogJ3Vpbyd9fSxcbiAgICogICAgIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHsuLi59XG4gICAqICk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdD19IG1haW5UeXBlIFdoZW4gbWFpblR5cGUgaXMgb2JqZWN0LCB0aGUgZGVmaW5pdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0aGUgc2FtZSBhcyB0aGUgbWV0aG9kICdmaW5kQ29tcG9uZW50cycuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgKi9cbiAgZWFjaENvbXBvbmVudDogZnVuY3Rpb24gKG1haW5UeXBlLCBjYiwgY29udGV4dCkge1xuICAgIHZhciBjb21wb25lbnRzTWFwID0gdGhpcy5fY29tcG9uZW50c01hcDtcblxuICAgIGlmICh0eXBlb2YgbWFpblR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRleHQgPSBjYjtcbiAgICAgIGNiID0gbWFpblR5cGU7XG4gICAgICBjb21wb25lbnRzTWFwLmVhY2goZnVuY3Rpb24gKGNvbXBvbmVudHMsIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgZWFjaChjb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY29tcG9uZW50VHlwZSwgY29tcG9uZW50LCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNTdHJpbmcobWFpblR5cGUpKSB7XG4gICAgICBlYWNoKGNvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKSwgY2IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QobWFpblR5cGUpKSB7XG4gICAgICB2YXIgcXVlcnlSZXN1bHQgPSB0aGlzLmZpbmRDb21wb25lbnRzKG1haW5UeXBlKTtcbiAgICAgIGVhY2gocXVlcnlSZXN1bHQsIGNiLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXM+fVxuICAgKi9cbiAgZ2V0U2VyaWVzQnlOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyk7XG5cbiAgICByZXR1cm4gZmlsdGVyKHNlcmllcywgZnVuY3Rpb24gKG9uZVNlcmllcykge1xuICAgICAgcmV0dXJuIG9uZVNlcmllcy5uYW1lID09PSBuYW1lO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5kZXhcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfVxuICAgKi9cbiAgZ2V0U2VyaWVzQnlJbmRleDogZnVuY3Rpb24gKHNlcmllc0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKVtzZXJpZXNJbmRleF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJUeXBlXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXM+fVxuICAgKi9cbiAgZ2V0U2VyaWVzQnlUeXBlOiBmdW5jdGlvbiAoc3ViVHlwZSkge1xuICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyk7XG5cbiAgICByZXR1cm4gZmlsdGVyKHNlcmllcywgZnVuY3Rpb24gKG9uZVNlcmllcykge1xuICAgICAgcmV0dXJuIG9uZVNlcmllcy5zdWJUeXBlID09PSBzdWJUeXBlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICovXG4gIGdldFNlcmllczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJykuc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgZmlsdGVyaW5nLCBzZXJpZXMgbWF5IGJlIGRpZmZlcmVudFxuICAgKiBmcm9tZSByYXcgc2VyaWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICovXG4gIGVhY2hTZXJpZXM6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgIGVhY2godGhpcy5fc2VyaWVzSW5kaWNlcywgZnVuY3Rpb24gKHJhd1Nlcmllc0luZGV4KSB7XG4gICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpW3Jhd1Nlcmllc0luZGV4XTtcblxuICAgICAgY2IuY2FsbChjb250ZXh0LCBzZXJpZXMsIHJhd1Nlcmllc0luZGV4KTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogSXRlcmF0ZSByYXcgc2VyaWVzIGJlZm9yZSBmaWx0ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBlYWNoUmF3U2VyaWVzOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSwgY2IsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZnRlciBmaWx0ZXJpbmcsIHNlcmllcyBtYXkgYmUgZGlmZmVyZW50LlxuICAgKiBmcm9tZSByYXcgc2VyaWVzLlxuICAgKlxuICAgKiBAcGFybWEge3N0cmluZ30gc3ViVHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICovXG4gIGVhY2hTZXJpZXNCeVR5cGU6IGZ1bmN0aW9uIChzdWJUeXBlLCBjYiwgY29udGV4dCkge1xuICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgIGVhY2godGhpcy5fc2VyaWVzSW5kaWNlcywgZnVuY3Rpb24gKHJhd1Nlcmllc0luZGV4KSB7XG4gICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpW3Jhd1Nlcmllc0luZGV4XTtcblxuICAgICAgaWYgKHNlcmllcy5zdWJUeXBlID09PSBzdWJUeXBlKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgc2VyaWVzLCByYXdTZXJpZXNJbmRleCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgcmF3IHNlcmllcyBiZWZvcmUgZmlsdGVyZWQgb2YgZ2l2ZW4gdHlwZS5cbiAgICpcbiAgICogQHBhcm1hIHtzdHJpbmd9IHN1YlR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBlYWNoUmF3U2VyaWVzQnlUeXBlOiBmdW5jdGlvbiAoc3ViVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZWFjaCh0aGlzLmdldFNlcmllc0J5VHlwZShzdWJUeXBlKSwgY2IsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICovXG4gIGlzU2VyaWVzRmlsdGVyZWQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgIHJldHVybiB6clV0aWwuaW5kZXhPZih0aGlzLl9zZXJpZXNJbmRpY2VzLCBzZXJpZXNNb2RlbC5jb21wb25lbnRJbmRleCkgPCAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGdldEN1cnJlbnRTZXJpZXNJbmRpY2VzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9zZXJpZXNJbmRpY2VzIHx8IFtdKS5zbGljZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICovXG4gIGZpbHRlclNlcmllczogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgdmFyIGZpbHRlcmVkU2VyaWVzID0gZmlsdGVyKHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSwgY2IsIGNvbnRleHQpO1xuICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSBjcmVhdGVTZXJpZXNJbmRpY2VzKGZpbHRlcmVkU2VyaWVzKTtcbiAgfSxcbiAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG4gICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IGNyZWF0ZVNlcmllc0luZGljZXMoY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpKTtcbiAgICB2YXIgY29tcG9uZW50VHlwZXMgPSBbXTtcbiAgICBjb21wb25lbnRzTWFwLmVhY2goZnVuY3Rpb24gKGNvbXBvbmVudHMsIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgIGNvbXBvbmVudFR5cGVzLnB1c2goY29tcG9uZW50VHlwZSk7XG4gICAgfSk7XG4gICAgQ29tcG9uZW50TW9kZWwudG9wb2xvZ2ljYWxUcmF2ZWwoY29tcG9uZW50VHlwZXMsIENvbXBvbmVudE1vZGVsLmdldEFsbENsYXNzTWFpblR5cGVzKCksIGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGVhY2goY29tcG9uZW50c01hcC5nZXQoY29tcG9uZW50VHlwZSksIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgY29tcG9uZW50LnJlc3RvcmVEYXRhKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG4vKipcbiAqIEBpbm5lclxuICovXG5cbmZ1bmN0aW9uIG1lcmdlVGhlbWUob3B0aW9uLCB0aGVtZSkge1xuICB6clV0aWwuZWFjaCh0aGVtZSwgZnVuY3Rpb24gKHRoZW1lSXRlbSwgbmFtZSkge1xuICAgIC8vIOWmguaenOaciSBjb21wb25lbnQgbW9kZWwg5YiZ5oqK5YW35L2T55qEIG1lcmdlIOmAu+i+keS6pOe7meivpSBtb2RlbCDlpITnkIZcbiAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG5hbWUpKSB7XG4gICAgICBpZiAodHlwZW9mIHRoZW1lSXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9uW25hbWVdID0gIW9wdGlvbltuYW1lXSA/IHpyVXRpbC5jbG9uZSh0aGVtZUl0ZW0pIDogenJVdGlsLm1lcmdlKG9wdGlvbltuYW1lXSwgdGhlbWVJdGVtLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9uW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25bbmFtZV0gPSB0aGVtZUl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0QmFzZShiYXNlT3B0aW9uKSB7XG4gIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uOyAvLyBVc2luZyBPUFRJT05fSU5ORVJfS0VZIHRvIG1hcmsgdGhhdCB0aGlzIG9wdGlvbiBjYW4gbm90IGJlIHVzZWQgb3V0c2lkZSxcbiAgLy8gaS5lLiBgY2hhcnQuc2V0T3B0aW9uKGNoYXJ0LmdldE1vZGVsKCkub3B0aW9uKTtgIGlzIGZvcmJpZGVuLlxuXG4gIHRoaXMub3B0aW9uID0ge307XG4gIHRoaXMub3B0aW9uW09QVElPTl9JTk5FUl9LRVldID0gMTtcbiAgLyoqXG4gICAqIEluaXQgd2l0aCBzZXJpZXM6IFtdLCBpbiBjYXNlIG9mIGNhbGxpbmcgZmluZFNlcmllcyBtZXRob2RcbiAgICogYmVmb3JlIHNlcmllcyBpbml0aWFsaXplZC5cbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY29tcG9uZW50c01hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKHtcbiAgICBzZXJpZXM6IFtdXG4gIH0pO1xuICAvKipcbiAgICogTWFwcGluZyBiZXR3ZWVuIGZpbHRlcmVkIHNlcmllcyBsaXN0IGFuZCByYXcgc2VyaWVzIGxpc3QuXG4gICAqIGtleTogZmlsdGVyZWQgc2VyaWVzIGluZGljZXMsIHZhbHVlOiByYXcgc2VyaWVzIGluZGljZXMuXG4gICAqIEB0eXBlIHtBcnJheS48bnVibWVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IG51bGw7XG4gIG1lcmdlVGhlbWUoYmFzZU9wdGlvbiwgdGhpcy5fdGhlbWUub3B0aW9uKTsgLy8gVE9ETyBOZWVkcyBjbG9uZSB3aGVuIG1lcmdpbmcgdG8gdGhlIHVuZXhpc3RlZCBwcm9wZXJ0eVxuXG4gIHpyVXRpbC5tZXJnZShiYXNlT3B0aW9uLCBnbG9iYWxEZWZhdWx0LCBmYWxzZSk7XG4gIHRoaXMubWVyZ2VPcHRpb24oYmFzZU9wdGlvbik7XG59XG4vKipcbiAqIEBpbm5lclxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPnxzdHJpbmd9IHR5cGVzIG1vZGVsIHR5cGVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IGtleToge3N0cmluZ30gdHlwZSwgdmFsdWU6IHtBcnJheS48T2JqZWN0Pn0gbW9kZWxzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzQnlUeXBlcyhjb21wb25lbnRzTWFwLCB0eXBlcykge1xuICBpZiAoIXpyVXRpbC5pc0FycmF5KHR5cGVzKSkge1xuICAgIHR5cGVzID0gdHlwZXMgPyBbdHlwZXNdIDogW107XG4gIH1cblxuICB2YXIgcmV0ID0ge307XG4gIGVhY2godHlwZXMsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0W3R5cGVdID0gKGNvbXBvbmVudHNNYXAuZ2V0KHR5cGUpIHx8IFtdKS5zbGljZSgpO1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBkZXRlcm1pbmVTdWJUeXBlKG1haW5UeXBlLCBuZXdDcHRPcHRpb24sIGV4aXN0Q29tcG9uZW50KSB7XG4gIHZhciBzdWJUeXBlID0gbmV3Q3B0T3B0aW9uLnR5cGUgPyBuZXdDcHRPcHRpb24udHlwZSA6IGV4aXN0Q29tcG9uZW50ID8gZXhpc3RDb21wb25lbnQuc3ViVHlwZSAvLyBVc2UgZGV0ZXJtaW5lU3ViVHlwZSBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gZXhpc3RDb21wb25lbnQuXG4gIDogQ29tcG9uZW50TW9kZWwuZGV0ZXJtaW5lU3ViVHlwZShtYWluVHlwZSwgbmV3Q3B0T3B0aW9uKTsgLy8gdG9vbHRpcCwgbWFya2xpbmUsIG1hcmtwb2ludCBtYXkgYWx3YXlzIGhhcyBubyBzdWJUeXBlXG5cbiAgcmV0dXJuIHN1YlR5cGU7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU2VyaWVzSW5kaWNlcyhzZXJpZXNNb2RlbHMpIHtcbiAgcmV0dXJuIG1hcChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICByZXR1cm4gc2VyaWVzLmNvbXBvbmVudEluZGV4O1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBmaWx0ZXJCeVN1YlR5cGUoY29tcG9uZW50cywgY29uZGl0aW9uKSB7XG4gIC8vIFVzaW5nIGhhc093blByb3BlcnR5IGZvciByZXN0cmljdC4gQ29uc2lkZXJcbiAgLy8gc3ViVHlwZSBpcyB1bmRlZmluZWQgaW4gdXNlciBwYXlsb2FkLlxuICByZXR1cm4gY29uZGl0aW9uLmhhc093blByb3BlcnR5KCdzdWJUeXBlJykgPyBmaWx0ZXIoY29tcG9uZW50cywgZnVuY3Rpb24gKGNwdCkge1xuICAgIHJldHVybiBjcHQuc3ViVHlwZSA9PT0gY29uZGl0aW9uLnN1YlR5cGU7XG4gIH0pIDogY29tcG9uZW50cztcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRTZXJpZXNJbml0aWFsaXplZChlY01vZGVsKSB7fVxuXG56clV0aWwubWl4aW4oR2xvYmFsTW9kZWwsIGNvbG9yUGFsZXR0ZU1pbmluKTtcbnZhciBfZGVmYXVsdCA9IEdsb2JhbE1vZGVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9HbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBtYWtlU3R5bGVNYXBwZXIgPSByZXF1aXJlKFwiLi9tYWtlU3R5bGVNYXBwZXJcIik7XG5cbnZhciBnZXRMaW5lU3R5bGUgPSBtYWtlU3R5bGVNYXBwZXIoW1snbGluZVdpZHRoJywgJ3dpZHRoJ10sIFsnc3Ryb2tlJywgJ2NvbG9yJ10sIFsnb3BhY2l0eSddLCBbJ3NoYWRvd0JsdXInXSwgWydzaGFkb3dPZmZzZXRYJ10sIFsnc2hhZG93T2Zmc2V0WSddLCBbJ3NoYWRvd0NvbG9yJ11dKTtcbnZhciBfZGVmYXVsdCA9IHtcbiAgZ2V0TGluZVN0eWxlOiBmdW5jdGlvbiAoZXhjbHVkZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRMaW5lU3R5bGUodGhpcywgZXhjbHVkZXMpO1xuICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuZ2V0TGluZURhc2goc3R5bGUubGluZVdpZHRoKTtcbiAgICBsaW5lRGFzaCAmJiAoc3R5bGUubGluZURhc2ggPSBsaW5lRGFzaCk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBnZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVXaWR0aCkge1xuICAgIGlmIChsaW5lV2lkdGggPT0gbnVsbCkge1xuICAgICAgbGluZVdpZHRoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgbGluZVR5cGUgPSB0aGlzLmdldCgndHlwZScpO1xuICAgIHZhciBkb3RTaXplID0gTWF0aC5tYXgobGluZVdpZHRoLCAyKTtcbiAgICB2YXIgZGFzaFNpemUgPSBsaW5lV2lkdGggKiA0O1xuICAgIHJldHVybiBsaW5lVHlwZSA9PT0gJ3NvbGlkJyB8fCBsaW5lVHlwZSA9PSBudWxsID8gbnVsbCA6IGxpbmVUeXBlID09PSAnZGFzaGVkJyA/IFtkYXNoU2l6ZSwgZGFzaFNpemVdIDogW2RvdFNpemUsIGRvdFNpemVdO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9saW5lU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBtYWtlU3R5bGVNYXBwZXIgPSByZXF1aXJlKFwiLi9tYWtlU3R5bGVNYXBwZXJcIik7XG5cbnZhciBnZXRBcmVhU3R5bGUgPSBtYWtlU3R5bGVNYXBwZXIoW1snZmlsbCcsICdjb2xvciddLCBbJ3NoYWRvd0JsdXInXSwgWydzaGFkb3dPZmZzZXRYJ10sIFsnc2hhZG93T2Zmc2V0WSddLCBbJ29wYWNpdHknXSwgWydzaGFkb3dDb2xvciddXSk7XG52YXIgX2RlZmF1bHQgPSB7XG4gIGdldEFyZWFTdHlsZTogZnVuY3Rpb24gKGV4Y2x1ZGVzLCBpbmNsdWRlcykge1xuICAgIHJldHVybiBnZXRBcmVhU3R5bGUodGhpcywgZXhjbHVkZXMsIGluY2x1ZGVzKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vYXJlYVN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbi90ZXh0XCIpO1xuXG52YXIgZ3JhcGhpY1V0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgUEFUSF9DT0xPUiA9IFsndGV4dFN0eWxlJywgJ2NvbG9yJ107XG52YXIgX2RlZmF1bHQgPSB7XG4gIC8qKlxuICAgKiBHZXQgY29sb3IgcHJvcGVydHkgb3IgZ2V0IGNvbG9yIGZyb20gb3B0aW9uLnRleHRTdHlsZS5jb2xvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0VtcGhhc2lzXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZXh0Q29sb3I6IGZ1bmN0aW9uIChpc0VtcGhhc2lzKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2hhbGxvdygnY29sb3InKSB8fCAoIWlzRW1waGFzaXMgJiYgZWNNb2RlbCA/IGVjTW9kZWwuZ2V0KFBBVEhfQ09MT1IpIDogbnVsbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmb250IHN0cmluZyBmcm9tIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0Rm9udDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBncmFwaGljVXRpbC5nZXRGb250KHtcbiAgICAgIGZvbnRTdHlsZTogdGhpcy5nZXRTaGFsbG93KCdmb250U3R5bGUnKSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZ2V0U2hhbGxvdygnZm9udFdlaWdodCcpLFxuICAgICAgZm9udFNpemU6IHRoaXMuZ2V0U2hhbGxvdygnZm9udFNpemUnKSxcbiAgICAgIGZvbnRGYW1pbHk6IHRoaXMuZ2V0U2hhbGxvdygnZm9udEZhbWlseScpXG4gICAgfSwgdGhpcy5lY01vZGVsKTtcbiAgfSxcbiAgZ2V0VGV4dFJlY3Q6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0ZXh0LCB0aGlzLmdldEZvbnQoKSwgdGhpcy5nZXRTaGFsbG93KCdhbGlnbicpLCB0aGlzLmdldFNoYWxsb3coJ3ZlcnRpY2FsQWxpZ24nKSB8fCB0aGlzLmdldFNoYWxsb3coJ2Jhc2VsaW5lJyksIHRoaXMuZ2V0U2hhbGxvdygncGFkZGluZycpLCB0aGlzLmdldFNoYWxsb3coJ3JpY2gnKSwgdGhpcy5nZXRTaGFsbG93KCd0cnVuY2F0ZVRleHQnKSk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL3RleHRTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9QYXRoXCIpO1xuXG52YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgdHJhbnNmb3JtUGF0aCA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybVBhdGhcIik7XG5cbi8vIGNvbW1hbmQgY2hhcnNcbnZhciBjYyA9IFsnbScsICdNJywgJ2wnLCAnTCcsICd2JywgJ1YnLCAnaCcsICdIJywgJ3onLCAnWicsICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ107XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBQSSA9IE1hdGguUEk7XG5cbnZhciB2TWFnID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdKTtcbn07XG5cbnZhciB2UmF0aW8gPSBmdW5jdGlvbiAodSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKTtcbn07XG5cbnZhciB2QW5nbGUgPSBmdW5jdGlvbiAodSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHZSYXRpbyh1LCB2KSk7XG59O1xuXG5mdW5jdGlvbiBwcm9jZXNzQXJjKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgcHNpRGVnLCBjbWQsIHBhdGgpIHtcbiAgdmFyIHBzaSA9IHBzaURlZyAqIChQSSAvIDE4MC4wKTtcbiAgdmFyIHhwID0gbWF0aENvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aFNpbihwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgeXAgPSAtMSAqIG1hdGhTaW4ocHNpKSAqICh4MSAtIHgyKSAvIDIuMCArIG1hdGhDb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgdmFyIGxhbWJkYSA9IHhwICogeHAgLyAocnggKiByeCkgKyB5cCAqIHlwIC8gKHJ5ICogcnkpO1xuXG4gIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgcnggKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICByeSAqPSBtYXRoU3FydChsYW1iZGEpO1xuICB9XG5cbiAgdmFyIGYgPSAoZmEgPT09IGZzID8gLTEgOiAxKSAqIG1hdGhTcXJ0KChyeCAqIHJ4ICogKHJ5ICogcnkpIC0gcnggKiByeCAqICh5cCAqIHlwKSAtIHJ5ICogcnkgKiAoeHAgKiB4cCkpIC8gKHJ4ICogcnggKiAoeXAgKiB5cCkgKyByeSAqIHJ5ICogKHhwICogeHApKSkgfHwgMDtcbiAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XG4gIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcbiAgdmFyIGN4ID0gKHgxICsgeDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogY3hwIC0gbWF0aFNpbihwc2kpICogY3lwO1xuICB2YXIgY3kgPSAoeTEgKyB5MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiBjeHAgKyBtYXRoQ29zKHBzaSkgKiBjeXA7XG4gIHZhciB0aGV0YSA9IHZBbmdsZShbMSwgMF0sIFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV0pO1xuICB2YXIgdSA9IFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV07XG4gIHZhciB2ID0gWygtMSAqIHhwIC0gY3hwKSAvIHJ4LCAoLTEgKiB5cCAtIGN5cCkgLyByeV07XG4gIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgaWYgKHZSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgIGRUaGV0YSA9IFBJO1xuICB9XG5cbiAgaWYgKHZSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgZFRoZXRhID0gMDtcbiAgfVxuXG4gIGlmIChmcyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XG4gICAgZFRoZXRhID0gZFRoZXRhIC0gMiAqIFBJO1xuICB9XG5cbiAgaWYgKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgKyAyICogUEk7XG4gIH1cblxuICBwYXRoLmFkZERhdGEoY21kLCBjeCwgY3ksIHJ4LCByeSwgdGhldGEsIGRUaGV0YSwgcHNpLCBmcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoZGF0YSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gY29tbWFuZCBzdHJpbmdcblxuXG4gIHZhciBjcyA9IGRhdGEucmVwbGFjZSgvLS9nLCAnIC0nKS5yZXBsYWNlKC8gIC9nLCAnICcpLnJlcGxhY2UoLyAvZywgJywnKS5yZXBsYWNlKC8sLC9nLCAnLCcpO1xuICB2YXIgbjsgLy8gY3JlYXRlIHBpcGVzIHNvIHRoYXQgd2UgY2FuIHNwbGl0IHRoZSBkYXRhXG5cbiAgZm9yIChuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XG4gICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoY2Nbbl0sICdnJyksICd8JyArIGNjW25dKTtcbiAgfSAvLyBjcmVhdGUgYXJyYXlcblxuXG4gIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpOyAvLyBpbml0IGNvbnRleHQgcG9pbnRcblxuICB2YXIgY3B4ID0gMDtcbiAgdmFyIGNweSA9IDA7XG4gIHZhciBwYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB2YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbiAgdmFyIHByZXZDbWQ7XG5cbiAgZm9yIChuID0gMTsgbiA8IGFyci5sZW5ndGg7IG4rKykge1xuICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgdmFyIGMgPSBzdHIuY2hhckF0KDApO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBwID0gc3RyLnNsaWNlKDEpLnJlcGxhY2UoL2UsLS9nLCAnZS0nKS5zcGxpdCgnLCcpO1xuICAgIHZhciBjbWQ7XG5cbiAgICBpZiAocC5sZW5ndGggPiAwICYmIHBbMF0gPT09ICcnKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2ZmIDwgcC5sZW5ndGggJiYgIWlzTmFOKHBbb2ZmXSkpIHtcbiAgICAgIGlmIChpc05hTihwWzBdKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGN0bFB0eDtcbiAgICAgIHZhciBjdGxQdHk7XG4gICAgICB2YXIgcng7XG4gICAgICB2YXIgcnk7XG4gICAgICB2YXIgcHNpO1xuICAgICAgdmFyIGZhO1xuICAgICAgdmFyIGZzO1xuICAgICAgdmFyIHgxID0gY3B4O1xuICAgICAgdmFyIHkxID0gY3B5OyAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcblxuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBjID0gJ2wnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBjID0gJ0wnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10pO1xuICAgICAgICAgIGNweCA9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgY3B5ID0gcFtvZmYgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5KTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICB4MSA9IGNweCArIHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gY3B5ICsgcFtvZmYrK107XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgIHgxID0gcFtvZmYrK10gKyBjcHg7XG4gICAgICAgICAgeTEgPSBwW29mZisrXSArIGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuUSkge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICBwcm9jZXNzQXJjKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgcnggPSBwW29mZisrXTtcbiAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBzaSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZhID0gcFtvZmYrK107XG4gICAgICAgICAgZnMgPSBwW29mZisrXTtcbiAgICAgICAgICB4MSA9IGNweCwgeTEgPSBjcHk7XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICBwcm9jZXNzQXJjKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcbiAgICAgIGNtZCA9IENNRC5aO1xuICAgICAgcGF0aC5hZGREYXRhKGNtZCk7XG4gICAgfVxuXG4gICAgcHJldkNtZCA9IGNtZDtcbiAgfVxuXG4gIHBhdGgudG9TdGF0aWMoKTtcbiAgcmV0dXJuIHBhdGg7XG59IC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cblxuXG5mdW5jdGlvbiBjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpIHtcbiAgdmFyIHBhdGhQcm94eSA9IGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoc3RyKTtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNldERhdGEpIHtcbiAgICAgIHBhdGguc2V0RGF0YShwYXRoUHJveHkuZGF0YSk7IC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuXG4gICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3R4ID0gcGF0aDtcbiAgICAgIHBhdGhQcm94eS5yZWJ1aWxkUGF0aChjdHgpO1xuICAgIH1cbiAgfTtcblxuICBvcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICB0cmFuc2Zvcm1QYXRoKHBhdGhQcm94eSwgbSk7XG4gICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgfTtcblxuICByZXR1cm4gb3B0cztcbn1cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21TdHJpbmcoc3RyLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUGF0aChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBjbGFzcyBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIFBhdGguZXh0ZW5kKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBNZXJnZSBtdWx0aXBsZSBwYXRoc1xuICovXG4vLyBUT0RPIEFwcGx5IHRyYW5zZm9ybVxuLy8gVE9ETyBzdHJva2UgZGFzaFxuLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIG1lcmdlUGF0aChwYXRoRWxzLCBvcHRzKSB7XG4gIHZhciBwYXRoTGlzdCA9IFtdO1xuICB2YXIgbGVuID0gcGF0aEVscy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXRoRWwgPSBwYXRoRWxzW2ldO1xuXG4gICAgaWYgKCFwYXRoRWwucGF0aCkge1xuICAgICAgcGF0aEVsLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgIH1cblxuICAgIGlmIChwYXRoRWwuX19kaXJ0eVBhdGgpIHtcbiAgICAgIHBhdGhFbC5idWlsZFBhdGgocGF0aEVsLnBhdGgsIHBhdGhFbC5zaGFwZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcGF0aExpc3QucHVzaChwYXRoRWwucGF0aCk7XG4gIH1cblxuICB2YXIgcGF0aEJ1bmRsZSA9IG5ldyBQYXRoKG9wdHMpOyAvLyBOZWVkIHBhdGggcHJveHkuXG5cbiAgcGF0aEJ1bmRsZS5jcmVhdGVQYXRoUHJveHkoKTtcblxuICBwYXRoQnVuZGxlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcGF0aC5hcHBlbmRQYXRoKHBhdGhMaXN0KTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBwYXRoQnVuZGxlO1xufVxuXG5leHBvcnRzLmNyZWF0ZUZyb21TdHJpbmcgPSBjcmVhdGVGcm9tU3RyaW5nO1xuZXhwb3J0cy5leHRlbmRGcm9tU3RyaW5nID0gZXh0ZW5kRnJvbVN0cmluZztcbmV4cG9ydHMubWVyZ2VQYXRoID0gbWVyZ2VQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIGxpbmUgPSByZXF1aXJlKFwiLi9saW5lXCIpO1xuXG52YXIgY3ViaWMgPSByZXF1aXJlKFwiLi9jdWJpY1wiKTtcblxudmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoXCIuL3F1YWRyYXRpY1wiKTtcblxudmFyIGFyYyA9IHJlcXVpcmUoXCIuL2FyY1wiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIG5vcm1hbGl6ZVJhZGlhbiA9IF91dGlsLm5vcm1hbGl6ZVJhZGlhbjtcblxudmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbnZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoXCIuL3dpbmRpbmdMaW5lXCIpO1xuXG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBFUFNJTE9OID0gMWUtNDtcblxuZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xufSAvLyDkuLTml7bmlbDnu4RcblxuXG52YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG52YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG5mdW5jdGlvbiBzd2FwRXh0cmVtYSgpIHtcbiAgdmFyIHRtcCA9IGV4dHJlbWFbMF07XG4gIGV4dHJlbWFbMF0gPSBleHRyZW1hWzFdO1xuICBleHRyZW1hWzFdID0gdG1wO1xufVxuXG5mdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gIC8vIFF1aWNrIHJlamVjdFxuICBpZiAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzIHx8IHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5Mykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB3ID0gMDtcbiAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICB2YXIgeTBfLCB5MV87XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJvb3RzW2ldOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICAgICAgdmFyIHVuaXQgPSB0ID09PSAwIHx8IHQgPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG5cbiAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPCAwKSB7XG4gICAgICAgIG5FeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hKTtcblxuICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgc3dhcEV4dHJlbWEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuXG4gICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICB5MV8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPT0gMikge1xuICAgICAgICAvLyDliIbmiJDkuInmrrXljZXosIPlh73mlbBcbiAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgZXh0cmVtYVsxXSkge1xuICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTMgPCB5MV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIOWIhuaIkOS4pOauteWNleiwg+WHveaVsFxuICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxufVxuXG5mdW5jdGlvbiB3aW5kaW5nUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgLy8gUXVpY2sgcmVqZWN0XG4gIGlmICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MiB8fCB5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5Mikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLnF1YWRyYXRpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG5cbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgdmFyIHcgPSAwO1xuICAgICAgdmFyIHlfID0gY3VydmUucXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgICAgdmFyIHVuaXQgPSByb290c1tpXSA9PT0gMCB8fCByb290c1tpXSA9PT0gMSA/IDAuNSA6IDE7XG4gICAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzW2ldKTtcblxuICAgICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgdyArPSB5XyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTIgPCB5XyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgIHZhciB1bml0ID0gcm9vdHNbMF0gPT09IDAgfHwgcm9vdHNbMF0gPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbMF0pO1xuXG4gICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgfVxuICB9XG59IC8vIFRPRE9cbi8vIEFyYyDml4vovaxcblxuXG5mdW5jdGlvbiB3aW5kaW5nQXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHkpIHtcbiAgeSAtPSBjeTtcblxuICBpZiAoeSA+IHIgfHwgeSA8IC1yKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgdG1wID0gTWF0aC5zcXJ0KHIgKiByIC0geSAqIHkpO1xuICByb290c1swXSA9IC10bXA7XG4gIHJvb3RzWzFdID0gdG1wO1xuICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cbiAgaWYgKGRpZmYgPCAxZS00KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHN0YXJ0QW5nbGUgPSAwO1xuICAgIGVuZEFuZ2xlID0gUEkyO1xuICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuXG4gICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgIHJldHVybiBkaXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICBlbmRBbmdsZSArPSBQSTI7XG4gIH1cblxuICB2YXIgdyA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICB2YXIgeF8gPSByb290c1tpXTtcblxuICAgIGlmICh4XyArIGN4ID4geCkge1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4Xyk7XG4gICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcblxuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSA9IFBJMiArIGFuZ2xlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSB8fCBhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKSB7XG4gICAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkgLyAyICYmIGFuZ2xlIDwgTWF0aC5QSSAqIDEuNSkge1xuICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgIH1cblxuICAgICAgICB3ICs9IGRpcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdztcbn1cblxuZnVuY3Rpb24gY29udGFpblBhdGgoZGF0YSwgbGluZVdpZHRoLCBpc1N0cm9rZSwgeCwgeSkge1xuICB2YXIgdyA9IDA7XG4gIHZhciB4aSA9IDA7XG4gIHZhciB5aSA9IDA7XG4gIHZhciB4MCA9IDA7XG4gIHZhciB5MCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICB2YXIgY21kID0gZGF0YVtpKytdOyAvLyBCZWdpbiBhIG5ldyBzdWJwYXRoXG5cbiAgICBpZiAoY21kID09PSBDTUQuTSAmJiBpID4gMSkge1xuICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc3VicGF0aFxuICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgIH0gLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgLy8gfVxuXG4gICAgfVxuXG4gICAgaWYgKGkgPT0gMSkge1xuICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgIC8vXG4gICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcbiAgICAgIHgwID0geGk7XG4gICAgICB5MCA9IHlpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIENNRC5NOlxuICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgIHhpID0geDA7XG4gICAgICAgIHlpID0geTA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5MOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5DOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAoY3ViaWMuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5ROlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAocXVhZHJhdGljLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdRdWFkcmF0aWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5BOlxuICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgdGhldGEgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBkVGhldGEgPSBkYXRhW2krK107IC8vIFRPRE8gQXJjIOaXi+i9rFxuXG4gICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHgxID0gTWF0aC5jb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odGhldGEpICogcnkgKyBjeTsgLy8g5LiN5piv55u05o6l5L2/55SoIGFyYyDlkb3ku6RcblxuICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgIHkwID0geTE7XG4gICAgICAgIH0gLy8genIg5L2/55Soc2NhbGXmnaXmqKHmi5/mpK3lnIYsIOi/memHjOS5n+WvuXjlgZrkuIDlrprnmoTnvKnmlL5cblxuXG4gICAgICAgIHZhciBfeCA9ICh4IC0gY3gpICogcnkgLyByeCArIGN4O1xuXG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChhcmMuY29udGFpblN0cm9rZShjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsIGxpbmVXaWR0aCwgX3gsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nQXJjKGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSwgX3gsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5SOlxuICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB4MSA9IHgwICsgd2lkdGg7XG4gICAgICAgIHZhciB5MSA9IHkwICsgaGVpZ2h0O1xuXG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgxLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MSwgeTEsIHgwLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGSVhNRSBDbG9ja3dpc2UgP1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDAsIHkxLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeGksIHlpLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTsgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgLy8gRklYTUUgc3VicGF0aHMgbWF5IG92ZXJsYXBcbiAgICAgICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IHgwO1xuICAgICAgICB5aSA9IHkwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzU3Ryb2tlICYmICFpc0Fyb3VuZEVxdWFsKHlpLCB5MCkpIHtcbiAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIHcgIT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW4ocGF0aERhdGEsIHgsIHkpIHtcbiAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UocGF0aERhdGEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIGxpbmVXaWR0aCwgdHJ1ZSwgeCwgeSk7XG59XG5cbmV4cG9ydHMuY29udGFpbiA9IGNvbnRhaW47XG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiDnur/mrrXljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoO1xuICB2YXIgX2EgPSAwO1xuICB2YXIgX2IgPSB4MDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHgwICE9PSB4MSkge1xuICAgIF9hID0gKHkwIC0geTEpIC8gKHgwIC0geDEpO1xuICAgIF9iID0gKHgwICogeTEgLSB4MSAqIHkwKSAvICh4MCAtIHgxKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHgwKSA8PSBfbCAvIDI7XG4gIH1cblxuICB2YXIgdG1wID0gX2EgKiB4IC0geSArIF9iO1xuXG4gIHZhciBfcyA9IHRtcCAqIHRtcCAvIChfYSAqIF9hICsgMSk7XG5cbiAgcmV0dXJuIF9zIDw9IF9sIC8gMiAqIF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG4vKipcbiAqIOS4ieasoei0neWhnuWwlOabsue6v+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeDNcbiAqIEBwYXJhbSAge251bWJlcn0gIHkzXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sICYmIHkgPiB5MyArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sICYmIHkgPCB5MyAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sICYmIHggPiB4MyArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sICYmIHggPCB4MyAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGQgPSBjdXJ2ZS5jdWJpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHgsIHksIG51bGwpO1xuICByZXR1cm4gZCA8PSBfbCAvIDI7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgcXVhZHJhdGljUHJvamVjdFBvaW50ID0gX2N1cnZlLnF1YWRyYXRpY1Byb2plY3RQb2ludDtcblxuLyoqXG4gKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGQgPSBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIG5vcm1hbGl6ZVJhZGlhbiA9IF91dGlsLm5vcm1hbGl6ZVJhZGlhbjtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbi8qKlxuICog5ZyG5byn5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBjeFxuICogQHBhcmFtICB7bnVtYmVyfSAgY3lcbiAqIEBwYXJhbSAge251bWJlcn0gIHJcbiAqIEBwYXJhbSAge251bWJlcn0gIHN0YXJ0QW5nbGVcbiAqIEBwYXJhbSAge251bWJlcn0gIGVuZEFuZ2xlXG4gKiBAcGFyYW0gIHtib29sZWFufSAgYW50aWNsb2Nrd2lzZVxuICogQHBhcmFtICB7bnVtYmVyfSBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gY29udGFpblN0cm9rZShjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgeCAtPSBjeDtcbiAgeSAtPSBjeTtcbiAgdmFyIGQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cbiAgaWYgKGQgLSBfbCA+IHIgfHwgZCArIF9sIDwgcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpICUgUEkyIDwgMWUtNCkge1xuICAgIC8vIElzIGEgY2lyY2xlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihzdGFydEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgZW5kQW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4KTtcblxuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgcmV0dXJuIGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUgfHwgYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZTtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL2FyYy5qc1xuLy8gbW9kdWxlIGlkID0gMjA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2MkFwcGx5VHJhbnNmb3JtID0gX3ZlY3Rvci5hcHBseVRyYW5zZm9ybTtcbnZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xudmFyIHBvaW50cyA9IFtbXSwgW10sIFtdXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoQXRhbjIgPSBNYXRoLmF0YW4yO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChwYXRoLCBtKSB7XG4gIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICB2YXIgY21kO1xuICB2YXIgblBvaW50O1xuICB2YXIgaTtcbiAgdmFyIGo7XG4gIHZhciBrO1xuICB2YXIgcDtcbiAgdmFyIE0gPSBDTUQuTTtcbiAgdmFyIEMgPSBDTUQuQztcbiAgdmFyIEwgPSBDTUQuTDtcbiAgdmFyIFIgPSBDTUQuUjtcbiAgdmFyIEEgPSBDTUQuQTtcbiAgdmFyIFEgPSBDTUQuUTtcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgIGNtZCA9IGRhdGFbaSsrXTtcbiAgICBqID0gaTtcbiAgICBuUG9pbnQgPSAwO1xuXG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGNhc2UgTTpcbiAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTDpcbiAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQzpcbiAgICAgICAgblBvaW50ID0gMztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUTpcbiAgICAgICAgblBvaW50ID0gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQTpcbiAgICAgICAgdmFyIHggPSBtWzRdO1xuICAgICAgICB2YXIgeSA9IG1bNV07XG4gICAgICAgIHZhciBzeCA9IG1hdGhTcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICB2YXIgc3kgPSBtYXRoU3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gbWF0aEF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7IC8vIGN4XG5cbiAgICAgICAgZGF0YVtpXSAqPSBzeDtcbiAgICAgICAgZGF0YVtpKytdICs9IHg7IC8vIGN5XG5cbiAgICAgICAgZGF0YVtpXSAqPSBzeTtcbiAgICAgICAgZGF0YVtpKytdICs9IHk7IC8vIFNjYWxlIHJ4IGFuZCByeVxuICAgICAgICAvLyBGSVhNRSBBc3N1bWUgcHNpIGlzIDAgaGVyZVxuXG4gICAgICAgIGRhdGFbaSsrXSAqPSBzeDtcbiAgICAgICAgZGF0YVtpKytdICo9IHN5OyAvLyBTdGFydCBhbmdsZVxuXG4gICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTsgLy8gZW5kIGFuZ2xlXG5cbiAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlOyAvLyBGSVhNRSBwc2lcblxuICAgICAgICBpICs9IDI7XG4gICAgICAgIGogPSBpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSOlxuICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgZGF0YVtqKytdID0gcFsxXTsgLy8geDEsIHkxXG5cbiAgICAgICAgcFswXSArPSBkYXRhW2krK107XG4gICAgICAgIHBbMV0gKz0gZGF0YVtpKytdO1xuICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgIH1cblxuICAgIGZvciAoayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgdmFyIHAgPSBwb2ludHNba107XG4gICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7IC8vIFdyaXRlIGJhY2tcblxuICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3RleHRcIik7XG5cbnZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyL3RleHRcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG59O1xuXG5UZXh0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRleHQsXG4gIHR5cGU6ICd0ZXh0JyxcbiAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7IC8vIFVzZSBwcm9wcyB3aXRoIHByZWZpeCAndGV4dCcuXG5cbiAgICBzdHlsZS5maWxsID0gc3R5bGUuc3Ryb2tlID0gc3R5bGUuc2hhZG93Qmx1ciA9IHN0eWxlLnNoYWRvd0NvbG9yID0gc3R5bGUuc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFkgPSBudWxsO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7IC8vIEFsd2F5cyBiaW5kIHN0eWxlXG5cbiAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcblxuICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSk7XG4gICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgIHRleHQgIT0gbnVsbCA/IHRleHQgKz0gJycgOiB0ZXh0ID0gJyc7XG4gICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChzdHlsZS50ZXh0ICsgJycsIHN0eWxlLmZvbnQsIHN0eWxlLnRleHRBbGlnbiwgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24sIHN0eWxlLnRleHRQYWRkaW5nLCBzdHlsZS5yaWNoKTtcbiAgICAgIHJlY3QueCArPSBzdHlsZS54IHx8IDA7XG4gICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuXG4gICAgICBpZiAodGV4dEhlbHBlci5nZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKSkge1xuICAgICAgICB2YXIgdyA9IHN0eWxlLnRleHRTdHJva2VXaWR0aDtcbiAgICAgICAgcmVjdC54IC09IHcgLyAyO1xuICAgICAgICByZWN0LnkgLT0gdyAvIDI7XG4gICAgICAgIHJlY3Qud2lkdGggKz0gdztcbiAgICAgICAgcmVjdC5oZWlnaHQgKz0gdztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoVGV4dCwgRGlzcGxheWFibGUpO1xudmFyIF9kZWZhdWx0ID0gVGV4dDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchuW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0NpcmNsZVxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdjaXJjbGUnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcbiAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAvLyBBbHdheXMgZG8gaXQgbWF5IGhhdmUgcGVyZm9ybWVuY2UgaXNzdWUgKCBmaWxsIG1heSBiZSAyeCBtb3JlIGNvc3QpXG4gICAgaWYgKGluQnVuZGxlKSB7XG4gICAgICBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgIH0gLy8gZWxzZSB7XG4gICAgLy8gICAgIGlmIChjdHguYWxsb2NhdGUgJiYgIWN0eC5kYXRhLmxlbmd0aCkge1xuICAgIC8vICAgICAgICAgY3R4LmFsbG9jYXRlKGN0eC5DTURfTUVNX1NJWkUuQSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgLy8gY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcblxuXG4gICAgY3R4LmFyYyhzaGFwZS5jeCwgc2hhcGUuY3ksIHNoYXBlLnIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBmaXhDbGlwV2l0aFNoYWRvdyA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3dcIik7XG5cbi8qKlxuICog5omH5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnc2VjdG9yJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByMDogMCxcbiAgICByOiAwLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9LFxuICBicnVzaDogZml4Q2xpcFdpdGhTaGFkb3coUGF0aC5wcm90b3R5cGUuYnJ1c2gpLFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG4gICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIwICsgeCwgdW5pdFkgKiByMCArIHkpO1xuICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgY3R4LmxpbmVUbyhNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeSk7XG5cbiAgICBpZiAocjAgIT09IDApIHtcbiAgICAgIGN0eC5hcmMoeCwgeSwgcjAsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG546vXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SaW5nXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3JpbmcnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDAsXG4gICAgcjA6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yLCAwLCBQSTIsIGZhbHNlKTtcbiAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yMCwgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvcG9seVwiKTtcblxuLyoqXG4gKiDlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Qb2x5Z29uXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3BvbHlnb24nLFxuICBzaGFwZToge1xuICAgIHBvaW50czogbnVsbCxcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJEaXN0YW5jZSA9IF92ZWN0b3IuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2F0bXVsbC1Sb20gc3BsaW5lIOaPkuWAvOaKmOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDMgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHBvaW50cywgaXNMb29wKSB7XG4gIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICB2YXIgcmV0ID0gW107XG4gIHZhciBkaXN0YW5jZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgIGRpc3RhbmNlICs9IHYyRGlzdGFuY2UocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldKTtcbiAgfVxuXG4gIHZhciBzZWdzID0gZGlzdGFuY2UgLyAyO1xuICBzZWdzID0gc2VncyA8IGxlbiA/IGxlbiA6IHNlZ3M7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzOyBpKyspIHtcbiAgICB2YXIgcG9zID0gaSAvIChzZWdzIC0gMSkgKiAoaXNMb29wID8gbGVuIDogbGVuIC0gMSk7XG4gICAgdmFyIGlkeCA9IE1hdGguZmxvb3IocG9zKTtcbiAgICB2YXIgdyA9IHBvcyAtIGlkeDtcbiAgICB2YXIgcDA7XG4gICAgdmFyIHAxID0gcG9pbnRzW2lkeCAlIGxlbl07XG4gICAgdmFyIHAyO1xuICAgIHZhciBwMztcblxuICAgIGlmICghaXNMb29wKSB7XG4gICAgICBwMCA9IHBvaW50c1tpZHggPT09IDAgPyBpZHggOiBpZHggLSAxXTtcbiAgICAgIHAyID0gcG9pbnRzW2lkeCA+IGxlbiAtIDIgPyBsZW4gLSAxIDogaWR4ICsgMV07XG4gICAgICBwMyA9IHBvaW50c1tpZHggPiBsZW4gLSAzID8gbGVuIC0gMSA6IGlkeCArIDJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwMCA9IHBvaW50c1soaWR4IC0gMSArIGxlbikgJSBsZW5dO1xuICAgICAgcDIgPSBwb2ludHNbKGlkeCArIDEpICUgbGVuXTtcbiAgICAgIHAzID0gcG9pbnRzWyhpZHggKyAyKSAlIGxlbl07XG4gICAgfVxuXG4gICAgdmFyIHcyID0gdyAqIHc7XG4gICAgdmFyIHczID0gdyAqIHcyO1xuICAgIHJldC5wdXNoKFtpbnRlcnBvbGF0ZShwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSwgdywgdzIsIHczKSwgaW50ZXJwb2xhdGUocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHcsIHcyLCB3MyldKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyTWluID0gX3ZlY3Rvci5taW47XG52YXIgdjJNYXggPSBfdmVjdG9yLm1heDtcbnZhciB2MlNjYWxlID0gX3ZlY3Rvci5zY2FsZTtcbnZhciB2MkRpc3RhbmNlID0gX3ZlY3Rvci5kaXN0YW5jZTtcbnZhciB2MkFkZCA9IF92ZWN0b3IuYWRkO1xudmFyIHYyQ2xvbmUgPSBfdmVjdG9yLmNsb25lO1xudmFyIHYyU3ViID0gX3ZlY3Rvci5zdWI7XG5cbi8qKlxuICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICogQHBhcmFtIHtudW1iZXJ9IHNtb290aCDlubPmu5HnrYnnuqcsIDAtMVxuICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbnN0cmFpbnQg5bCG6K6h566X5Ye65p2l55qE5o6n5Yi254K557qm5p2f5Zyo5LiA5Liq5YyF5Zu055uS5YaFXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOavlOWmgiBbWzAsIDBdLCBbMTAwLCAxMDBdXSwg6L+Z5Liq5YyF5Zu055uS5Lya5LiOXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOaVtOS4quaKmOe6v+eahOWMheWbtOebkuWBmuS4gOS4quW5tumbhueUqOadpee6puadn+aOp+WItueCueOAglxuICogQHBhcmFtIHtBcnJheX0g6K6h566X5Ye65p2l55qE5o6n5Yi254K55pWw57uEXG4gKi9cbmZ1bmN0aW9uIF9kZWZhdWx0KHBvaW50cywgc21vb3RoLCBpc0xvb3AsIGNvbnN0cmFpbnQpIHtcbiAgdmFyIGNwcyA9IFtdO1xuICB2YXIgdiA9IFtdO1xuICB2YXIgdjEgPSBbXTtcbiAgdmFyIHYyID0gW107XG4gIHZhciBwcmV2UG9pbnQ7XG4gIHZhciBuZXh0UG9pbnQ7XG4gIHZhciBtaW4sIG1heDtcblxuICBpZiAoY29uc3RyYWludCkge1xuICAgIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIG1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2Mk1pbihtaW4sIG1pbiwgcG9pbnRzW2ldKTtcbiAgICAgIHYyTWF4KG1heCwgbWF4LCBwb2ludHNbaV0pO1xuICAgIH0gLy8g5LiO5oyH5a6a55qE5YyF5Zu055uS5YGa5bm26ZuGXG5cblxuICAgIHYyTWluKG1pbiwgbWluLCBjb25zdHJhaW50WzBdKTtcbiAgICB2Mk1heChtYXgsIG1heCwgY29uc3RyYWludFsxXSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgaWYgKGlzTG9vcCkge1xuICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgPyBpIC0gMSA6IGxlbiAtIDFdO1xuICAgICAgbmV4dFBvaW50ID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGNwcy5wdXNoKHYyQ2xvbmUocG9pbnRzW2ldKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2MlN1Yih2LCBuZXh0UG9pbnQsIHByZXZQb2ludCk7IC8vIHVzZSBkZWdyZWUgdG8gc2NhbGUgdGhlIGhhbmRsZSBsZW5ndGhcblxuICAgIHYyU2NhbGUodiwgdiwgc21vb3RoKTtcbiAgICB2YXIgZDAgPSB2MkRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuICAgIHZhciBkMSA9IHYyRGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCk7XG4gICAgdmFyIHN1bSA9IGQwICsgZDE7XG5cbiAgICBpZiAoc3VtICE9PSAwKSB7XG4gICAgICBkMCAvPSBzdW07XG4gICAgICBkMSAvPSBzdW07XG4gICAgfVxuXG4gICAgdjJTY2FsZSh2MSwgdiwgLWQwKTtcbiAgICB2MlNjYWxlKHYyLCB2LCBkMSk7XG4gICAgdmFyIGNwMCA9IHYyQWRkKFtdLCBwb2ludCwgdjEpO1xuICAgIHZhciBjcDEgPSB2MkFkZChbXSwgcG9pbnQsIHYyKTtcblxuICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICB2Mk1heChjcDAsIGNwMCwgbWluKTtcbiAgICAgIHYyTWluKGNwMCwgY3AwLCBtYXgpO1xuICAgICAgdjJNYXgoY3AxLCBjcDEsIG1pbik7XG4gICAgICB2Mk1pbihjcDEsIGNwMSwgbWF4KTtcbiAgICB9XG5cbiAgICBjcHMucHVzaChjcDApO1xuICAgIGNwcy5wdXNoKGNwMSk7XG4gIH1cblxuICBpZiAoaXNMb29wKSB7XG4gICAgY3BzLnB1c2goY3BzLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIGNwcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBwb2x5SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9wb2x5XCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3BvbHlsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IG51bGwsXG4gICAgc21vb3RoOiBmYWxzZSxcbiAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgZmFsc2UpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9yb3VuZFJlY3RcIik7XG5cbi8qKlxuICog55+p5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SZWN0XG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3JlY3QnLFxuICBzaGFwZToge1xuICAgIC8vIOW3puS4iuOAgeWPs+S4iuOAgeWPs+S4i+OAgeW3puS4i+inkueahOWNiuW+hOS+neasoeS4unIx44CBcjLjgIFyM+OAgXI0XG4gICAgLy8gcue8qeWGmeS4ujEgICAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgLy8gcue8qeWGmeS4ulsxXSAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgLy8gcue8qeWGmeS4ulsxLCAyXSAgICDnm7jlvZPkuo4gWzEsIDIsIDEsIDJdXG4gICAgLy8gcue8qeWGmeS4ulsxLCAyLCAzXSDnm7jlvZPkuo4gWzEsIDIsIDMsIDJdXG4gICAgcjogMCxcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgdmFyIHkgPSBzaGFwZS55O1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG5cbiAgICBpZiAoIXNoYXBlLnIpIHtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm47XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDnm7Tnur9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmVcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnbGluZScsXG4gIHNoYXBlOiB7XG4gICAgLy8gU3RhcnQgcG9pbnRcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICAvLyBFbmQgcG9pbnRcbiAgICB4MjogMCxcbiAgICB5MjogMCxcbiAgICBwZXJjZW50OiAxXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgIHgyID0geDEgKiAoMSAtIHBlcmNlbnQpICsgeDIgKiBwZXJjZW50O1xuICAgICAgeTIgPSB5MSAqICgxIC0gcGVyY2VudCkgKyB5MiAqIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBwb2ludEF0OiBmdW5jdGlvbiAocCkge1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgcmV0dXJuIFtzaGFwZS54MSAqICgxIC0gcCkgKyBzaGFwZS54MiAqIHAsIHNoYXBlLnkxICogKDEgLSBwKSArIHNoYXBlLnkyICogcF07XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBfY3VydmUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IF9jdXJ2ZS5xdWFkcmF0aWNTdWJkaXZpZGU7XG52YXIgY3ViaWNTdWJkaXZpZGUgPSBfY3VydmUuY3ViaWNTdWJkaXZpZGU7XG52YXIgcXVhZHJhdGljQXQgPSBfY3VydmUucXVhZHJhdGljQXQ7XG52YXIgY3ViaWNBdCA9IF9jdXJ2ZS5jdWJpY0F0O1xudmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IF9jdXJ2ZS5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG52YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBfY3VydmUuY3ViaWNEZXJpdmF0aXZlQXQ7XG5cbi8qKlxuICog6LSd5aGe5bCU5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQmV6aWVyQ3VydmVcbiAqL1xudmFyIG91dCA9IFtdO1xuXG5mdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xuICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcblxuICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFsoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLCAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUuY3B5Miwgc2hhcGUueTIsIHQpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWyhpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSwgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUueTIsIHQpXTtcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdiZXppZXItY3VydmUnLFxuICBzaGFwZToge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIGNweDE6IDAsXG4gICAgY3B5MTogMCxcbiAgICAvLyBjcHgyOiAwLFxuICAgIC8vIGNweTI6IDBcbiAgICAvLyBDdXJ2ZSBzaG93IHBlcmNlbnQsIGZvciBhbmltYXRpbmdcbiAgICBwZXJjZW50OiAxXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgdmFyIGNweDEgPSBzaGFwZS5jcHgxO1xuICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcbiAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICB4MiA9IG91dFsyXTtcbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgeTIgPSBvdXRbMl07XG4gICAgICB9XG5cbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNweDEsIGNweTEsIHgyLCB5Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh4MSwgY3B4MSwgY3B4MiwgeDIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgIGNweDIgPSBvdXRbMl07XG4gICAgICAgIHgyID0gb3V0WzNdO1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh5MSwgY3B5MSwgY3B5MiwgeTIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgIGNweTIgPSBvdXRbMl07XG4gICAgICAgIHkyID0gb3V0WzNdO1xuICAgICAgfVxuXG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCB4MiwgeTIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRhbmdlbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchuW8p1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQXJjXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2FyYycsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMCxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcbiAgICBjbG9ja3dpc2U6IHRydWVcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcbiAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjdHgubW92ZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qc1xuLy8gbW9kdWxlIGlkID0gMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuXG4vLyBDb21wb3VuZFBhdGggdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnY29tcG91bmQnLFxuICBzaGFwZToge1xuICAgIHBhdGhzOiBudWxsXG4gIH0sXG4gIF91cGRhdGVQYXRoRGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGlydHlQYXRoID0gdGhpcy5fX2RpcnR5UGF0aDtcbiAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTWFyayBhcyBkaXJ0eSBpZiBhbnkgc3VicGF0aCBpcyBkaXJ0eVxuICAgICAgZGlydHlQYXRoID0gZGlydHlQYXRoIHx8IHBhdGhzW2ldLl9fZGlydHlQYXRoO1xuICAgIH1cblxuICAgIHRoaXMuX19kaXJ0eVBhdGggPSBkaXJ0eVBhdGg7XG4gICAgdGhpcy5fX2RpcnR5ID0gdGhpcy5fX2RpcnR5IHx8IGRpcnR5UGF0aDtcbiAgfSxcbiAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91cGRhdGVQYXRoRGlydHkoKTtcblxuICAgIHZhciBwYXRocyA9IHRoaXMuc2hhcGUucGF0aHMgfHwgW107XG4gICAgdmFyIHNjYWxlID0gdGhpcy5nZXRHbG9iYWxTY2FsZSgpOyAvLyBVcGRhdGUgcGF0aCBzY2FsZVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwYXRoc1tpXS5wYXRoKSB7XG4gICAgICAgIHBhdGhzW2ldLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgICAgfVxuXG4gICAgICBwYXRoc1tpXS5wYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG4gICAgfVxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHBhdGhzID0gc2hhcGUucGF0aHMgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXRoc1tpXS5idWlsZFBhdGgoY3R4LCBwYXRoc1tpXS5zaGFwZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICBhZnRlckJydXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocyB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhdGhzW2ldLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgfVxuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91cGRhdGVQYXRoRGlydHkoKTtcblxuICAgIHJldHVybiBQYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QuY2FsbCh0aGlzKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgR3JhZGllbnQgPSByZXF1aXJlKFwiLi9HcmFkaWVudFwiKTtcblxuLyoqXG4gKiB4LCB5LCB4MiwgeTIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt4Mj0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFt5Mj0wXVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gKi9cbnZhciBMaW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHt0eXBlOiAnbGluZWFyJywgY29sb3JTdG9wczogLi4ufWAsIHdoZXJlXG4gIC8vIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLnggPSB4ID09IG51bGwgPyAwIDogeDtcbiAgdGhpcy55ID0geSA9PSBudWxsID8gMCA6IHk7XG4gIHRoaXMueDIgPSB4MiA9PSBudWxsID8gMSA6IHgyO1xuICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IDAgOiB5MjsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdsaW5lYXInOyAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG5cbiAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcbiAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbn07XG5cbkxpbmVhckdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExpbmVhckdyYWRpZW50XG59O1xuenJVdGlsLmluaGVyaXRzKExpbmVhckdyYWRpZW50LCBHcmFkaWVudCk7XG52YXIgX2RlZmF1bHQgPSBMaW5lYXJHcmFkaWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuL0dyYWRpZW50XCIpO1xuXG4vKipcbiAqIHgsIHksIHIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MC41XVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTAuNV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wLjVdXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbY29sb3JTdG9wc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICovXG52YXIgUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgciwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdyYWRpYWwnLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gIHRoaXMueCA9IHggPT0gbnVsbCA/IDAuNSA6IHg7XG4gIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAuNSA6IHk7XG4gIHRoaXMuciA9IHIgPT0gbnVsbCA/IDAuNSA6IHI7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAncmFkaWFsJzsgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuXG4gIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG4gIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG59O1xuXG5SYWRpYWxHcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSYWRpYWxHcmFkaWVudFxufTtcbnpyVXRpbC5pbmhlcml0cyhSYWRpYWxHcmFkaWVudCwgR3JhZGllbnQpO1xudmFyIF9kZWZhdWx0ID0gUmFkaWFsR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBtYWtlU3R5bGVNYXBwZXIgPSByZXF1aXJlKFwiLi9tYWtlU3R5bGVNYXBwZXJcIik7XG5cbnZhciBnZXRJdGVtU3R5bGUgPSBtYWtlU3R5bGVNYXBwZXIoW1snZmlsbCcsICdjb2xvciddLCBbJ3N0cm9rZScsICdib3JkZXJDb2xvciddLCBbJ2xpbmVXaWR0aCcsICdib3JkZXJXaWR0aCddLCBbJ29wYWNpdHknXSwgWydzaGFkb3dCbHVyJ10sIFsnc2hhZG93T2Zmc2V0WCddLCBbJ3NoYWRvd09mZnNldFknXSwgWydzaGFkb3dDb2xvciddLCBbJ3RleHRQb3NpdGlvbiddLCBbJ3RleHRBbGlnbiddXSk7XG52YXIgX2RlZmF1bHQgPSB7XG4gIGdldEl0ZW1TdHlsZTogZnVuY3Rpb24gKGV4Y2x1ZGVzLCBpbmNsdWRlcykge1xuICAgIHZhciBzdHlsZSA9IGdldEl0ZW1TdHlsZSh0aGlzLCBleGNsdWRlcywgaW5jbHVkZXMpO1xuICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuZ2V0Qm9yZGVyTGluZURhc2goKTtcbiAgICBsaW5lRGFzaCAmJiAoc3R5bGUubGluZURhc2ggPSBsaW5lRGFzaCk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBnZXRCb3JkZXJMaW5lRGFzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaW5lVHlwZSA9IHRoaXMuZ2V0KCdib3JkZXJUeXBlJyk7XG4gICAgcmV0dXJuIGxpbmVUeXBlID09PSAnc29saWQnIHx8IGxpbmVUeXBlID09IG51bGwgPyBudWxsIDogbGluZVR5cGUgPT09ICdkYXNoZWQnID8gWzUsIDVdIDogWzEsIDFdO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9pdGVtU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfZGVmYXVsdCA9IHtcbiAgZ2V0Qm94TGF5b3V0UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMuZ2V0KCdsZWZ0JyksXG4gICAgICB0b3A6IHRoaXMuZ2V0KCd0b3AnKSxcbiAgICAgIHJpZ2h0OiB0aGlzLmdldCgncmlnaHQnKSxcbiAgICAgIGJvdHRvbTogdGhpcy5nZXQoJ2JvdHRvbScpLFxuICAgICAgd2lkdGg6IHRoaXMuZ2V0KCd3aWR0aCcpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmdldCgnaGVpZ2h0JylcbiAgICB9O1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9ib3hMYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBwbGF0Zm9ybSA9ICcnOyAvLyBOYXZpZ2F0b3Igbm90IGV4aXN0cyBpbiBub2RlXG5cbmlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICBwbGF0Zm9ybSA9IG5hdmlnYXRvci5wbGF0Zm9ybSB8fCAnJztcbn1cblxudmFyIF9kZWZhdWx0ID0ge1xuICAvLyDlhajlm77pu5jorqTog4zmma9cbiAgLy8gYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gIC8vIGh0dHBzOi8vZHJpYmJibGUuY29tL3Nob3RzLzEwNjU5NjAtSW5mb2dyYXBoaWMtUGllLWNoYXJ0LXZpc3VhbGl6YXRpb25cbiAgLy8gY29sb3I6IFsnIzU3OTNmMycsICcjZDE0YTYxJywgJyNmZDljMzUnLCAnIzY3NWJiYScsICcjZmVjNDJjJywgJyNkZDQ0NDQnLCAnI2Q0ZGY1YScsICcjY2Q0ODcwJ10sXG4gIC8vIOa1heiJslxuICAvLyBjb2xvcjogWycjYmNkM2JiJywgJyNlODhmNzAnLCAnI2VkYzFhNScsICcjOWRjNWM4JywgJyNlMWU4YzgnLCAnIzdiN2M2OCcsICcjZTViNWI1JywgJyNmMGI0ODknLCAnIzkyOGVhOCcsICcjYmRhMjlhJ10sXG4gIC8vIGNvbG9yOiBbJyNjYzU2NjQnLCAnIzliZDZlYycsICcjZWE5NDZlJywgJyM4YWNhYWEnLCAnI2YxZWM2NCcsICcjZWU4Njg2JywgJyNhNDhkYzEnLCAnIzVkYTZiYycsICcjYjlkY2FlJ10sXG4gIC8vIOa3seiJslxuICBjb2xvcjogWycjYzIzNTMxJywgJyMyZjQ1NTQnLCAnIzYxYTBhOCcsICcjZDQ4MjY1JywgJyM5MWM3YWUnLCAnIzc0OWY4MycsICcjY2E4NjIyJywgJyNiZGEyOWEnLCAnIzZlNzA3NCcsICcjNTQ2NTcwJywgJyNjNGNjZDMnXSxcbiAgLy8g6buY6K6k6ZyA6KaBIEdyaWQg6YWN572u6aG5XG4gIC8vIGdyaWQ6IHt9LFxuICAvLyDkuLvpopjvvIzkuLvpophcbiAgdGV4dFN0eWxlOiB7XG4gICAgLy8gY29sb3I6ICcjMDAwJyxcbiAgICAvLyBkZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgLy8gUEVORElOR1xuICAgIGZvbnRGYW1pbHk6IHBsYXRmb3JtLm1hdGNoKC9eV2luLykgPyAnTWljcm9zb2Z0IFlhSGVpJyA6ICdzYW5zLXNlcmlmJyxcbiAgICAvLyBmb250RmFtaWx5OiAnQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLFxuICAgIGZvbnRTaXplOiAxMixcbiAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnXG4gIH0sXG4gIC8vIGh0dHA6Ly9ibG9ncy5hZG9iZS5jb20vd2VicGxhdGZvcm0vMjAxNC8wMi8yNC91c2luZy1ibGVuZC1tb2Rlcy1pbi1odG1sLWNhbnZhcy9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgLy8gRGVmYXVsdCBpcyBzb3VyY2Utb3ZlclxuICBibGVuZE1vZGU6IG51bGwsXG4gIGFuaW1hdGlvbjogJ2F1dG8nLFxuICBhbmltYXRpb25EdXJhdGlvbjogMTAwMCxcbiAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDMwMCxcbiAgYW5pbWF0aW9uRWFzaW5nOiAnZXhwb25lbnRpYWxPdXQnLFxuICBhbmltYXRpb25FYXNpbmdVcGRhdGU6ICdjdWJpY091dCcsXG4gIGFuaW1hdGlvblRocmVzaG9sZDogMjAwMCxcbiAgLy8gQ29uZmlndXJhdGlvbiBmb3IgcHJvZ3Jlc3NpdmUvaW5jcmVtZW50YWwgcmVuZGVyaW5nXG4gIHByb2dyZXNzaXZlVGhyZXNob2xkOiAzMDAwLFxuICBwcm9ncmVzc2l2ZTogNDAwLFxuICAvLyBUaHJlc2hvbGQgb2YgaWYgdXNlIHNpbmdsZSBob3ZlciBsYXllciB0byBvcHRpbWl6ZS5cbiAgLy8gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCBgaG92ZXJMYXllclRocmVzaG9sZGAgaXMgZXF1aXZhbGVudCB0byBvciBsZXNzIHRoYW5cbiAgLy8gYHByb2dyZXNzaXZlVGhyZXNob2xkYCwgb3RoZXJ3aXNlIGhvdmVyIHdpbGwgY2F1c2UgcmVzdGFydCBvZiBwcm9ncmVzc2l2ZSxcbiAgLy8gd2hpY2ggaXMgdW5leHBlY3RlZC5cbiAgLy8gc2VlIGV4YW1wbGUgPGVjaGFydHMvdGVzdC9oZWF0bWFwLWxhcmdlLmh0bWw+LlxuICBob3ZlckxheWVyVGhyZXNob2xkOiAzMDAwLFxuICAvLyBTZWU6IG1vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWVcbiAgdXNlVVRDOiBmYWxzZVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvZ2xvYmFsRGVmYXVsdC5qc1xuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBlY2hhcnRzQVBJTGlzdCA9IFsnZ2V0RG9tJywgJ2dldFpyJywgJ2dldFdpZHRoJywgJ2dldEhlaWdodCcsICdnZXREZXZpY2VQaXhlbFJhdGlvJywgJ2Rpc3BhdGNoQWN0aW9uJywgJ2lzRGlzcG9zZWQnLCAnb24nLCAnb2ZmJywgJ2dldERhdGFVUkwnLCAnZ2V0Q29ubmVjdGVkRGF0YVVSTCcsICdnZXRNb2RlbCcsICdnZXRPcHRpb24nLCAnZ2V0Vmlld09mQ29tcG9uZW50TW9kZWwnLCAnZ2V0Vmlld09mU2VyaWVzTW9kZWwnXTsgLy8gQW5kIGBnZXRDb29yZGluYXRlU3lzdGVtc2AgYW5kIGBnZXRDb21wb25lbnRCeUVsZW1lbnRgIHdpbGwgYmUgaW5qZWN0ZWQgaW4gZWNoYXJ0cy5qc1xuXG5mdW5jdGlvbiBFeHRlbnNpb25BUEkoY2hhcnRJbnN0YW5jZSkge1xuICB6clV0aWwuZWFjaChlY2hhcnRzQVBJTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aGlzW25hbWVdID0genJVdGlsLmJpbmQoY2hhcnRJbnN0YW5jZVtuYW1lXSwgY2hhcnRJbnN0YW5jZSk7XG4gIH0sIHRoaXMpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBFeHRlbnNpb25BUEk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL0V4dGVuc2lvbkFQSS5qc1xuLy8gbW9kdWxlIGlkID0gMjI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZShcIi4vQ29tcG9uZW50XCIpO1xuXG4vKipcbiAqIEVDaGFydHMgb3B0aW9uIG1hbmFnZXJcbiAqXG4gKiBAbW9kdWxlIHtlY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXJ9XG4gKi9cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG52YXIgbWFwID0genJVdGlsLm1hcDtcbnZhciBtZXJnZSA9IHpyVXRpbC5tZXJnZTtcbnZhciBRVUVSWV9SRUcgPSAvXihtaW58bWF4KT8oLispJC87XG4vKipcbiAqIFRFUk0gRVhQTEFOQVRJT05TOlxuICpcbiAqIFtvcHRpb25dOlxuICpcbiAqICAgICBBbiBvYmplY3QgdGhhdCBjb250YWlucyBkZWZpbml0aW9ucyBvZiBjb21wb25lbnRzLiBGb3IgZXhhbXBsZTpcbiAqICAgICB2YXIgb3B0aW9uID0ge1xuICogICAgICAgICB0aXRsZTogey4uLn0sXG4gKiAgICAgICAgIGxlZ2VuZDogey4uLn0sXG4gKiAgICAgICAgIHZpc3VhbE1hcDogey4uLn0sXG4gKiAgICAgICAgIHNlcmllczogW1xuICogICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAqICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gKiAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgXVxuICogICAgIH07XG4gKlxuICogW3Jhd09wdGlvbl06XG4gKlxuICogICAgIEFuIG9iamVjdCBpbnB1dCB0byBlY2hhcnRzLnNldE9wdGlvbi4gJ3Jhd09wdGlvbicgbWF5IGJlIGFuXG4gKiAgICAgJ29wdGlvbicsIG9yIG1heSBiZSBhbiBvYmplY3QgY29udGFpbnMgbXVsdGktb3B0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKiAgICAgdmFyIG9wdGlvbiA9IHtcbiAqICAgICAgICAgYmFzZU9wdGlvbjoge1xuICogICAgICAgICAgICAgdGl0bGU6IHsuLi59LFxuICogICAgICAgICAgICAgbGVnZW5kOiB7Li4ufSxcbiAqICAgICAgICAgICAgIHNlcmllczogW1xuICogICAgICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gKiAgICAgICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAqICAgICAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgICAgIF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgdGltZWxpbmU6IHsuLi59LFxuICogICAgICAgICBvcHRpb25zOiBbXG4gKiAgICAgICAgICAgICB7dGl0bGU6IHsuLi59LCBzZXJpZXM6IHtkYXRhOiBbLi4uXX19LFxuICogICAgICAgICAgICAge3RpdGxlOiB7Li4ufSwgc2VyaWVzOiB7ZGF0YTogWy4uLl19fSxcbiAqICAgICAgICAgICAgIC4uLlxuICogICAgICAgICBdLFxuICogICAgICAgICBtZWRpYTogW1xuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIHF1ZXJ5OiB7bWF4V2lkdGg6IDMyMH0sXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogMjB9LCB2aXN1YWxNYXA6IHtzaG93OiBmYWxzZX19XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIHF1ZXJ5OiB7bWluV2lkdGg6IDMyMCwgbWF4V2lkdGg6IDcyMH0sXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogNTAwfSwgdmlzdWFsTWFwOiB7c2hvdzogdHJ1ZX19XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIG9wdGlvbjoge3Nlcmllczoge3g6IDEyMDB9LCB2aXN1YWxNYXA6IHtzaG93OiB0cnVlfX1cbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgXVxuICogICAgIH07XG4gKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqL1xuXG5mdW5jdGlvbiBPcHRpb25NYW5hZ2VyKGFwaSkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAgICovXG4gIHRoaXMuX2FwaSA9IGFwaTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cbiAgdGhpcy5fdGltZWxpbmVPcHRpb25zID0gW107XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAqL1xuXG4gIHRoaXMuX21lZGlhTGlzdCA9IFtdO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5fbWVkaWFEZWZhdWx0O1xuICAvKipcbiAgICogLTEsIG1lYW5zIGRlZmF1bHQuXG4gICAqIGVtcHR5IG1lYW5zIG5vIG1lZGlhLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuXG4gIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBbXTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX29wdGlvbkJhY2t1cDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX25ld0Jhc2VPcHRpb247XG59IC8vIHRpbWVsaW5lLm5vdE1lcmdlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZWMzLiBGaXJzdGx5IHRoZXJlIGlzIHJlYXJseVxuLy8gY2FzZSB0aGF0IG5vdE1lcmdlIGlzIG5lZWRlZC4gU2Vjb25kbHkgc3VwcG9ydGluZyAnbm90TWVyZ2UnIHJlcXVpcmVzXG4vLyByYXdPcHRpb24gY2xvbmVkIGFuZCBiYWNrdXBlZCB3aGVuIHRpbWVsaW5lIGNoYW5nZWQsIHdoaWNoIGRvZXMgbm9cbi8vIGdvb2QgdG8gcGVyZm9ybWFuY2UuIFdoYXQncyBtb3JlLCB0aGF0IGJvdGggdGltZWxpbmUgYW5kIHNldE9wdGlvblxuLy8gbWV0aG9kIHN1cHBseSAnbm90TWVyZ2UnIGJyaW5ncyBjb21wbGV4IGFuZCBzb21lIHByb2JsZW1zLlxuLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxuLy8gKHN0ZXAxKSBjaGFydC5zZXRPcHRpb24oe3RpbWVsaW5lOiB7bm90TWVyZ2U6IGZhbHNlfSwgLi4ufSwgZmFsc2UpO1xuLy8gKHN0ZXAyKSBjaGFydC5zZXRPcHRpb24oe3RpbWVsaW5lOiB7bm90TWVyZ2U6IHRydWV9LCAuLi59LCBmYWxzZSk7XG5cblxuT3B0aW9uTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBPcHRpb25NYW5hZ2VyLFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByYXdPcHRpb24gUmF3IG9wdGlvbi5cbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtIHtBcnJheS48RnVuY3Rpb24+fSBvcHRpb25QcmVwcm9jZXNzb3JGdW5jc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEluaXQgb3B0aW9uXG4gICAqL1xuICBzZXRPcHRpb246IGZ1bmN0aW9uIChyYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgcmF3T3B0aW9uID0gY2xvbmUocmF3T3B0aW9uLCB0cnVlKTsgLy8gRklYTUVcbiAgICAvLyDlpoLmnpwgdGltZWxpbmUgb3B0aW9ucyDmiJbogIUgbWVkaWEg5Lit6K6+572u5LqG5p+Q5Liq5bGe5oCn77yM6ICMYmFzZU9wdGlvbuS4reayoeacieiuvue9ru+8jOWImei/m+ihjOitpuWRiuOAglxuXG4gICAgdmFyIG9sZE9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDtcbiAgICB2YXIgbmV3UGFyc2VkT3B0aW9uID0gcGFyc2VSYXdPcHRpb24uY2FsbCh0aGlzLCByYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCAhb2xkT3B0aW9uQmFja3VwKTtcbiAgICB0aGlzLl9uZXdCYXNlT3B0aW9uID0gbmV3UGFyc2VkT3B0aW9uLmJhc2VPcHRpb247IC8vIEZvciBzZXRPcHRpb24gYXQgc2Vjb25kIHRpbWUgKHVzaW5nIG1lcmdlIG1vZGUpO1xuXG4gICAgaWYgKG9sZE9wdGlvbkJhY2t1cCkge1xuICAgICAgLy8gT25seSBiYXNlT3B0aW9uIGNhbiBiZSBtZXJnZWQuXG4gICAgICBtZXJnZU9wdGlvbihvbGRPcHRpb25CYWNrdXAuYmFzZU9wdGlvbiwgbmV3UGFyc2VkT3B0aW9uLmJhc2VPcHRpb24pOyAvLyBGb3Igc2ltcGxpY2l0eSwgdGltZWxpbmUgb3B0aW9ucyBhbmQgbWVkaWEgb3B0aW9ucyBkbyBub3Qgc3VwcG9ydCBtZXJnZSxcbiAgICAgIC8vIHRoYXQgaXMsIGlmIHlvdSBgc2V0T3B0aW9uYCB0d2ljZSBhbmQgYm90aCBoYXMgdGltZWxpbmUgb3B0aW9ucywgdGhlIGxhdHRlclxuICAgICAgLy8gdGltZWxpbmUgb3BpdG9ucyB3aWxsIG5vdCBiZSBtZXJnZWQgdG8gdGhlIGZvcm1lcnMsIGJ1dCBqdXN0IHN1YnN0aXR1ZGUgdGhlbS5cblxuICAgICAgaWYgKG5ld1BhcnNlZE9wdGlvbi50aW1lbGluZU9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIG9sZE9wdGlvbkJhY2t1cC50aW1lbGluZU9wdGlvbnMgPSBuZXdQYXJzZWRPcHRpb24udGltZWxpbmVPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3UGFyc2VkT3B0aW9uLm1lZGlhTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgb2xkT3B0aW9uQmFja3VwLm1lZGlhTGlzdCA9IG5ld1BhcnNlZE9wdGlvbi5tZWRpYUxpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24ubWVkaWFEZWZhdWx0KSB7XG4gICAgICAgIG9sZE9wdGlvbkJhY2t1cC5tZWRpYURlZmF1bHQgPSBuZXdQYXJzZWRPcHRpb24ubWVkaWFEZWZhdWx0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcHRpb25CYWNrdXAgPSBuZXdQYXJzZWRPcHRpb247XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmVjcmVhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgbW91bnRPcHRpb246IGZ1bmN0aW9uIChpc1JlY3JlYXRlKSB7XG4gICAgdmFyIG9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDsgLy8gVE9ET1xuICAgIC8vIOWmguaenOayoeaciXJlc2V05Yqf6IO95YiZ5LiNY2xvbmXjgIJcblxuICAgIHRoaXMuX3RpbWVsaW5lT3B0aW9ucyA9IG1hcChvcHRpb25CYWNrdXAudGltZWxpbmVPcHRpb25zLCBjbG9uZSk7XG4gICAgdGhpcy5fbWVkaWFMaXN0ID0gbWFwKG9wdGlvbkJhY2t1cC5tZWRpYUxpc3QsIGNsb25lKTtcbiAgICB0aGlzLl9tZWRpYURlZmF1bHQgPSBjbG9uZShvcHRpb25CYWNrdXAubWVkaWFEZWZhdWx0KTtcbiAgICB0aGlzLl9jdXJyZW50TWVkaWFJbmRpY2VzID0gW107XG4gICAgcmV0dXJuIGNsb25lKGlzUmVjcmVhdGUgLy8gdGhpcy5fb3B0aW9uQmFja3VwLmJhc2VPcHRpb24sIHdoaWNoIGlzIGNyZWF0ZWQgYXQgdGhlIGZpcnN0IGBzZXRPcHRpb25gXG4gICAgLy8gY2FsbGVkLCBhbmQgaXMgbWVyZ2VkIGludG8gZXZlcnkgbmV3IG9wdGlvbiBieSBpbm5lciBtZXRob2QgYG1lcmdlT3B0aW9uYFxuICAgIC8vIGVhY2ggdGltZSBgc2V0T3B0aW9uYCBjYWxsZWQsIGNhbiBiZSBvbmx5IHVzZWQgaW4gYGlzUmVjcmVhdGVgLCBiZWNhdXNlXG4gICAgLy8gaXRzIHJlbGlhYmlsaXR5IGlzIHVuZGVyIHN1c3BpY2lvbi4gSW4gb3RoZXIgY2FzZXMgb3B0aW9uIG1lcmdlIGlzXG4gICAgLy8gcGVyZm9ybWVkIGJ5IGBtb2RlbC5tZXJnZU9wdGlvbmAuXG4gICAgPyBvcHRpb25CYWNrdXAuYmFzZU9wdGlvbiA6IHRoaXMuX25ld0Jhc2VPcHRpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRUaW1lbGluZU9wdGlvbjogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgb3B0aW9uO1xuICAgIHZhciB0aW1lbGluZU9wdGlvbnMgPSB0aGlzLl90aW1lbGluZU9wdGlvbnM7XG5cbiAgICBpZiAodGltZWxpbmVPcHRpb25zLmxlbmd0aCkge1xuICAgICAgLy8gZ2V0VGltZWxpbmVPcHRpb24gY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGVjTW9kZWwgaW5pdGVkLFxuICAgICAgLy8gc28gd2UgY2FuIGdldCBjdXJyZW50SW5kZXggZnJvbSB0aW1lbGluZU1vZGVsLlxuICAgICAgdmFyIHRpbWVsaW5lTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgndGltZWxpbmUnKTtcblxuICAgICAgaWYgKHRpbWVsaW5lTW9kZWwpIHtcbiAgICAgICAgb3B0aW9uID0gY2xvbmUodGltZWxpbmVPcHRpb25zW3RpbWVsaW5lTW9kZWwuZ2V0Q3VycmVudEluZGV4KCldLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn1cbiAgICovXG4gIGdldE1lZGlhT3B0aW9uOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBlY1dpZHRoID0gdGhpcy5fYXBpLmdldFdpZHRoKCk7XG5cbiAgICB2YXIgZWNIZWlnaHQgPSB0aGlzLl9hcGkuZ2V0SGVpZ2h0KCk7XG5cbiAgICB2YXIgbWVkaWFMaXN0ID0gdGhpcy5fbWVkaWFMaXN0O1xuICAgIHZhciBtZWRpYURlZmF1bHQgPSB0aGlzLl9tZWRpYURlZmF1bHQ7XG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107IC8vIE5vIG1lZGlhIGRlZmluZWQuXG5cbiAgICBpZiAoIW1lZGlhTGlzdC5sZW5ndGggJiYgIW1lZGlhRGVmYXVsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IC8vIE11bHRpIG1lZGlhIG1heSBiZSBhcHBsaWVkLCB0aGUgbGF0dGVyIGRlZmluZWQgbWVkaWEgaGFzIGhpZ2hlciBwcmlvcml0eS5cblxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1lZGlhTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGFwcGx5TWVkaWFRdWVyeShtZWRpYUxpc3RbaV0ucXVlcnksIGVjV2lkdGgsIGVjSGVpZ2h0KSkge1xuICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfSAvLyBGSVhNRVxuICAgIC8vIOaYr+WQpm1lZGlhRGVmYXVsdOW6lOivpeW8uuWItueUqOaIt+iuvue9ru+8jOWQpuWImeWPr+iDveS/ruaUueS4jeiDveWbnuW9kuOAglxuXG5cbiAgICBpZiAoIWluZGljZXMubGVuZ3RoICYmIG1lZGlhRGVmYXVsdCkge1xuICAgICAgaW5kaWNlcyA9IFstMV07XG4gICAgfVxuXG4gICAgaWYgKGluZGljZXMubGVuZ3RoICYmICFpbmRpY2VzRXF1YWxzKGluZGljZXMsIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMpKSB7XG4gICAgICByZXN1bHQgPSBtYXAoaW5kaWNlcywgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBjbG9uZShpbmRleCA9PT0gLTEgPyBtZWRpYURlZmF1bHQub3B0aW9uIDogbWVkaWFMaXN0W2luZGV4XS5vcHRpb24pO1xuICAgICAgfSk7XG4gICAgfSAvLyBPdGhlcndpc2UgcmV0dXJuIG5vdGhpbmcuXG5cblxuICAgIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBpbmRpY2VzO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhcnNlUmF3T3B0aW9uKHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsIGlzTmV3KSB7XG4gIHZhciB0aW1lbGluZU9wdGlvbnMgPSBbXTtcbiAgdmFyIG1lZGlhTGlzdCA9IFtdO1xuICB2YXIgbWVkaWFEZWZhdWx0O1xuICB2YXIgYmFzZU9wdGlvbjsgLy8gQ29tcGF0aWJsZSB3aXRoIGVjMi5cblxuICB2YXIgdGltZWxpbmVPcHQgPSByYXdPcHRpb24udGltZWxpbmU7XG5cbiAgaWYgKHJhd09wdGlvbi5iYXNlT3B0aW9uKSB7XG4gICAgYmFzZU9wdGlvbiA9IHJhd09wdGlvbi5iYXNlT3B0aW9uO1xuICB9IC8vIEZvciB0aW1lbGluZVxuXG5cbiAgaWYgKHRpbWVsaW5lT3B0IHx8IHJhd09wdGlvbi5vcHRpb25zKSB7XG4gICAgYmFzZU9wdGlvbiA9IGJhc2VPcHRpb24gfHwge307XG4gICAgdGltZWxpbmVPcHRpb25zID0gKHJhd09wdGlvbi5vcHRpb25zIHx8IFtdKS5zbGljZSgpO1xuICB9IC8vIEZvciBtZWRpYSBxdWVyeVxuXG5cbiAgaWYgKHJhd09wdGlvbi5tZWRpYSkge1xuICAgIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uIHx8IHt9O1xuICAgIHZhciBtZWRpYSA9IHJhd09wdGlvbi5tZWRpYTtcbiAgICBlYWNoKG1lZGlhLCBmdW5jdGlvbiAoc2luZ2xlTWVkaWEpIHtcbiAgICAgIGlmIChzaW5nbGVNZWRpYSAmJiBzaW5nbGVNZWRpYS5vcHRpb24pIHtcbiAgICAgICAgaWYgKHNpbmdsZU1lZGlhLnF1ZXJ5KSB7XG4gICAgICAgICAgbWVkaWFMaXN0LnB1c2goc2luZ2xlTWVkaWEpO1xuICAgICAgICB9IGVsc2UgaWYgKCFtZWRpYURlZmF1bHQpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IG1lZGlhIGRlZmF1bHQuXG4gICAgICAgICAgbWVkaWFEZWZhdWx0ID0gc2luZ2xlTWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBGb3Igbm9ybWFsIG9wdGlvblxuXG5cbiAgaWYgKCFiYXNlT3B0aW9uKSB7XG4gICAgYmFzZU9wdGlvbiA9IHJhd09wdGlvbjtcbiAgfSAvLyBTZXQgdGltZWxpbmVPcHQgdG8gYmFzZU9wdGlvbiBpbiBlYzMsXG4gIC8vIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yIG1lcmdlIG9wdGlvbi5cblxuXG4gIGlmICghYmFzZU9wdGlvbi50aW1lbGluZSkge1xuICAgIGJhc2VPcHRpb24udGltZWxpbmUgPSB0aW1lbGluZU9wdDtcbiAgfSAvLyBQcmVwcm9jZXNzLlxuXG5cbiAgZWFjaChbYmFzZU9wdGlvbl0uY29uY2F0KHRpbWVsaW5lT3B0aW9ucykuY29uY2F0KHpyVXRpbC5tYXAobWVkaWFMaXN0LCBmdW5jdGlvbiAobWVkaWEpIHtcbiAgICByZXR1cm4gbWVkaWEub3B0aW9uO1xuICB9KSksIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBlYWNoKG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCBmdW5jdGlvbiAocHJlUHJvY2Vzcykge1xuICAgICAgcHJlUHJvY2VzcyhvcHRpb24sIGlzTmV3KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYmFzZU9wdGlvbjogYmFzZU9wdGlvbixcbiAgICB0aW1lbGluZU9wdGlvbnM6IHRpbWVsaW5lT3B0aW9ucyxcbiAgICBtZWRpYURlZmF1bHQ6IG1lZGlhRGVmYXVsdCxcbiAgICBtZWRpYUxpc3Q6IG1lZGlhTGlzdFxuICB9O1xufVxuLyoqXG4gKiBAc2VlIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLW1lZGlhcXVlcmllcy8jbWVkaWExPlxuICogU3VwcG9ydDogd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW9cbiAqIENhbiB1c2UgbWF4IG9yIG1pbiBhcyBwcmVmaXguXG4gKi9cblxuXG5mdW5jdGlvbiBhcHBseU1lZGlhUXVlcnkocXVlcnksIGVjV2lkdGgsIGVjSGVpZ2h0KSB7XG4gIHZhciByZWFsTWFwID0ge1xuICAgIHdpZHRoOiBlY1dpZHRoLFxuICAgIGhlaWdodDogZWNIZWlnaHQsXG4gICAgYXNwZWN0cmF0aW86IGVjV2lkdGggLyBlY0hlaWdodCAvLyBsb3dzZXIgY2FzZSBmb3IgY29udmVuaWVudGNlLlxuXG4gIH07XG4gIHZhciBhcHBsaWNhdGFibGUgPSB0cnVlO1xuICB6clV0aWwuZWFjaChxdWVyeSwgZnVuY3Rpb24gKHZhbHVlLCBhdHRyKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBhdHRyLm1hdGNoKFFVRVJZX1JFRyk7XG5cbiAgICBpZiAoIW1hdGNoZWQgfHwgIW1hdGNoZWRbMV0gfHwgIW1hdGNoZWRbMl0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3BlcmF0b3IgPSBtYXRjaGVkWzFdO1xuICAgIHZhciByZWFsQXR0ciA9IG1hdGNoZWRbMl0udG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICghY29tcGFyZShyZWFsTWFwW3JlYWxBdHRyXSwgdmFsdWUsIG9wZXJhdG9yKSkge1xuICAgICAgYXBwbGljYXRhYmxlID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFwcGxpY2F0YWJsZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZShyZWFsLCBleHBlY3QsIG9wZXJhdG9yKSB7XG4gIGlmIChvcGVyYXRvciA9PT0gJ21pbicpIHtcbiAgICByZXR1cm4gcmVhbCA+PSBleHBlY3Q7XG4gIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdtYXgnKSB7XG4gICAgcmV0dXJuIHJlYWwgPD0gZXhwZWN0O1xuICB9IGVsc2Uge1xuICAgIC8vIEVxdWFsc1xuICAgIHJldHVybiByZWFsID09PSBleHBlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kaWNlc0VxdWFscyhpbmRpY2VzMSwgaW5kaWNlczIpIHtcbiAgLy8gaW5kaWNlcyBpcyBhbHdheXMgb3JkZXIgYnkgYXNjIGFuZCBoYXMgb25seSBmaW5pdGUgbnVtYmVyLlxuICByZXR1cm4gaW5kaWNlczEuam9pbignLCcpID09PSBpbmRpY2VzMi5qb2luKCcsJyk7XG59XG4vKipcbiAqIENvbnNpZGVyIGNhc2U6XG4gKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpO2BcbiAqIFRoZW4gdXNlciBkbyBzb21lIGludGVyYWN0aW9uIGxpa2UgZGF0YVpvb20sIGRhdGFWaWV3IGNoYW5naW5nLlxuICogYGNoYXJ0LnNldE9wdGlvbihvcHQyKTtgXG4gKiBUaGVuIHVzZXIgcHJlc3MgJ3Jlc2V0IGJ1dHRvbicgaW4gdG9vbGJveC5cbiAqXG4gKiBBZnRlciBkb2luZyB0aGF0IGFsbCBvZiB0aGUgaW50ZXJhY3Rpb24gZWZmZWN0cyBzaG91bGQgYmUgcmVzZXQsIHRoZVxuICogY2hhcnQgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSByZXN1bHQgb2YgaW52b2tlXG4gKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpOyBjaGFydC5zZXRPcHRpb24ob3B0Mik7YC5cbiAqXG4gKiBBbHRob3VnaCBpdCBpcyBub3QgYWJsZSBlbnN1cmUgdGhhdFxuICogYGNoYXJ0LnNldE9wdGlvbihvcHQxKTsgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2AgaXMgZXF1aXZhbGVudHMgdG9cbiAqIGBjaGFydC5zZXRPcHRpb24obWVyZ2Uob3B0MSwgb3B0MikpO2AgZXhhY3RseSxcbiAqIHRoaXMgbWlnaHQgYmUgdGhlIG9ubHkgc2ltcGxlIHdheSB0byBpbXBsZW1lbnQgdGhhdCBmZWF0dXJlLlxuICpcbiAqIE1FTU86IFdlJ3ZlIGNvbnNpZGVyZWQgc29tZSBvdGhlciBhcHByb2FjaGVzOlxuICogMS4gRWFjaCBtb2RlbCBoYW5kbGUgaXRzIHNlbGYgcmVzdG9yYXRpb24gYnV0IG5vdCB1bmlmb3JtIHRyZWF0bWVudC5cbiAqICAgICAoVG9vIGNvbXBsZXggaW4gbG9naWMgYW5kIGVycm9yLXByb25lKVxuICogMi4gVXNlIGEgc2hhZG93IGVjTW9kZWwuIChQZXJmb3JtYWNlIGV4cGVuc2l2ZSlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlT3B0aW9uKG9sZE9wdGlvbiwgbmV3T3B0aW9uKSB7XG4gIG5ld09wdGlvbiA9IG5ld09wdGlvbiB8fCB7fTtcbiAgZWFjaChuZXdPcHRpb24sIGZ1bmN0aW9uIChuZXdDcHRPcHQsIG1haW5UeXBlKSB7XG4gICAgaWYgKG5ld0NwdE9wdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9sZENwdE9wdCA9IG9sZE9wdGlvblttYWluVHlwZV07XG5cbiAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgb2xkT3B0aW9uW21haW5UeXBlXSA9IG1lcmdlKG9sZENwdE9wdCwgbmV3Q3B0T3B0LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q3B0T3B0ID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkobmV3Q3B0T3B0KTtcbiAgICAgIG9sZENwdE9wdCA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG9sZENwdE9wdCk7XG4gICAgICB2YXIgbWFwUmVzdWx0ID0gbW9kZWxVdGlsLm1hcHBpbmdUb0V4aXN0cyhvbGRDcHRPcHQsIG5ld0NwdE9wdCk7XG4gICAgICBvbGRPcHRpb25bbWFpblR5cGVdID0gbWFwKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ub3B0aW9uICYmIGl0ZW0uZXhpc3QgPyBtZXJnZShpdGVtLmV4aXN0LCBpdGVtLm9wdGlvbiwgdHJ1ZSkgOiBpdGVtLmV4aXN0IHx8IGl0ZW0ub3B0aW9uO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gT3B0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvT3B0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF91dGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIGlzQXJyYXkgPSBfdXRpbC5pc0FycmF5O1xudmFyIGlzT2JqZWN0ID0gX3V0aWwuaXNPYmplY3Q7XG5cbnZhciBjb21wYXRTdHlsZSA9IHJlcXVpcmUoXCIuL2hlbHBlci9jb21wYXRTdHlsZVwiKTtcblxudmFyIF9tb2RlbCA9IHJlcXVpcmUoXCIuLi91dGlsL21vZGVsXCIpO1xuXG52YXIgbm9ybWFsaXplVG9BcnJheSA9IF9tb2RlbC5ub3JtYWxpemVUb0FycmF5O1xuXG4vLyBDb21wYXRpdGFibGUgd2l0aCAyLjBcbmZ1bmN0aW9uIGdldChvcHQsIHBhdGgpIHtcbiAgcGF0aCA9IHBhdGguc3BsaXQoJywnKTtcbiAgdmFyIG9iaiA9IG9wdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBvYmogPSBvYmogJiYgb2JqW3BhdGhbaV1dO1xuXG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBzZXQob3B0LCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSkge1xuICBwYXRoID0gcGF0aC5zcGxpdCgnLCcpO1xuICB2YXIgb2JqID0gb3B0O1xuICB2YXIga2V5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBrZXkgPSBwYXRoW2ldO1xuXG4gICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcbiAgICAgIG9ialtrZXldID0ge307XG4gICAgfVxuXG4gICAgb2JqID0gb2JqW2tleV07XG4gIH1cblxuICBpZiAob3ZlcndyaXRlIHx8IG9ialtwYXRoW2ldXSA9PSBudWxsKSB7XG4gICAgb2JqW3BhdGhbaV1dID0gdmFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhdExheW91dFByb3BlcnRpZXMob3B0aW9uKSB7XG4gIGVhY2goTEFZT1VUX1BST1BFUlRJRVMsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKHByb3BbMF0gaW4gb3B0aW9uICYmICEocHJvcFsxXSBpbiBvcHRpb24pKSB7XG4gICAgICBvcHRpb25bcHJvcFsxXV0gPSBvcHRpb25bcHJvcFswXV07XG4gICAgfVxuICB9KTtcbn1cblxudmFyIExBWU9VVF9QUk9QRVJUSUVTID0gW1sneCcsICdsZWZ0J10sIFsneScsICd0b3AnXSwgWyd4MicsICdyaWdodCddLCBbJ3kyJywgJ2JvdHRvbSddXTtcbnZhciBDT01QQVRJVEFCTEVfQ09NUE9ORU5UUyA9IFsnZ3JpZCcsICdnZW8nLCAncGFyYWxsZWwnLCAnbGVnZW5kJywgJ3Rvb2xib3gnLCAndGl0bGUnLCAndmlzdWFsTWFwJywgJ2RhdGFab29tJywgJ3RpbWVsaW5lJ107XG52YXIgQ09NUEFUSVRBQkxFX1NFUklFUyA9IFsnYmFyJywgJ2JveHBsb3QnLCAnY2FuZGxlc3RpY2snLCAnY2hvcmQnLCAnZWZmZWN0U2NhdHRlcicsICdmdW5uZWwnLCAnZ2F1Z2UnLCAnbGluZXMnLCAnZ3JhcGgnLCAnaGVhdG1hcCcsICdsaW5lJywgJ21hcCcsICdwYXJhbGxlbCcsICdwaWUnLCAncmFkYXInLCAnc2Fua2V5JywgJ3NjYXR0ZXInLCAndHJlZW1hcCddO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChvcHRpb24sIGlzVGhlbWUpIHtcbiAgY29tcGF0U3R5bGUob3B0aW9uLCBpc1RoZW1lKTsgLy8gTWFrZSBzdXJlIHNlcmllcyBhcnJheSBmb3IgbW9kZWwgaW5pdGlhbGl6YXRpb24uXG5cbiAgb3B0aW9uLnNlcmllcyA9IG5vcm1hbGl6ZVRvQXJyYXkob3B0aW9uLnNlcmllcyk7XG4gIGVhY2gob3B0aW9uLnNlcmllcywgZnVuY3Rpb24gKHNlcmllc09wdCkge1xuICAgIGlmICghaXNPYmplY3Qoc2VyaWVzT3B0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZXJpZXNUeXBlID0gc2VyaWVzT3B0LnR5cGU7XG5cbiAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ3BpZScgfHwgc2VyaWVzVHlwZSA9PT0gJ2dhdWdlJykge1xuICAgICAgaWYgKHNlcmllc09wdC5jbG9ja1dpc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXJpZXNPcHQuY2xvY2t3aXNlID0gc2VyaWVzT3B0LmNsb2NrV2lzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2dhdWdlJykge1xuICAgICAgdmFyIHBvaW50ZXJDb2xvciA9IGdldChzZXJpZXNPcHQsICdwb2ludGVyLmNvbG9yJyk7XG4gICAgICBwb2ludGVyQ29sb3IgIT0gbnVsbCAmJiBzZXQoc2VyaWVzT3B0LCAnaXRlbVN0eWxlLm5vcm1hbC5jb2xvcicsIHBvaW50ZXJDb2xvcik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDT01QQVRJVEFCTEVfU0VSSUVTLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoQ09NUEFUSVRBQkxFX1NFUklFU1tpXSA9PT0gc2VyaWVzT3B0LnR5cGUpIHtcbiAgICAgICAgY29tcGF0TGF5b3V0UHJvcGVydGllcyhzZXJpZXNPcHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBkYXRhUmFuZ2UgaGFzIGNoYW5nZWQgdG8gdmlzdWFsTWFwXG5cbiAgaWYgKG9wdGlvbi5kYXRhUmFuZ2UpIHtcbiAgICBvcHRpb24udmlzdWFsTWFwID0gb3B0aW9uLmRhdGFSYW5nZTtcbiAgfVxuXG4gIGVhY2goQ09NUEFUSVRBQkxFX0NPTVBPTkVOVFMsIGZ1bmN0aW9uIChjb21wb25lbnROYW1lKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25bY29tcG9uZW50TmFtZV07XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgaWYgKCFpc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBbb3B0aW9uc107XG4gICAgICB9XG5cbiAgICAgIGVhY2gob3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBjb21wYXRMYXlvdXRQcm9wZXJ0aWVzKG9wdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdC5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcbnZhciBQT1NTSUJMRV9TVFlMRVMgPSBbJ2FyZWFTdHlsZScsICdsaW5lU3R5bGUnLCAnbm9kZVN0eWxlJywgJ2xpbmtTdHlsZScsICdjaG9yZFN0eWxlJywgJ2xhYmVsJywgJ2xhYmVsTGluZSddO1xuXG5mdW5jdGlvbiBjb21wYXRJdGVtU3R5bGUob3B0KSB7XG4gIHZhciBpdGVtU3R5bGVPcHQgPSBvcHQgJiYgb3B0Lml0ZW1TdHlsZTtcblxuICBpZiAoIWl0ZW1TdHlsZU9wdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBQT1NTSUJMRV9TVFlMRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgc3R5bGVOYW1lID0gUE9TU0lCTEVfU1RZTEVTW2ldO1xuICAgIHZhciBub3JtYWxJdGVtU3R5bGVPcHQgPSBpdGVtU3R5bGVPcHQubm9ybWFsO1xuICAgIHZhciBlbXBoYXNpc0l0ZW1TdHlsZU9wdCA9IGl0ZW1TdHlsZU9wdC5lbXBoYXNpcztcblxuICAgIGlmIChub3JtYWxJdGVtU3R5bGVPcHQgJiYgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pIHtcbiAgICAgIG9wdFtzdHlsZU5hbWVdID0gb3B0W3N0eWxlTmFtZV0gfHwge307XG5cbiAgICAgIGlmICghb3B0W3N0eWxlTmFtZV0ubm9ybWFsKSB7XG4gICAgICAgIG9wdFtzdHlsZU5hbWVdLm5vcm1hbCA9IG5vcm1hbEl0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgenJVdGlsLm1lcmdlKG9wdFtzdHlsZU5hbWVdLm5vcm1hbCwgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGVtcGhhc2lzSXRlbVN0eWxlT3B0ICYmIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pIHtcbiAgICAgIG9wdFtzdHlsZU5hbWVdID0gb3B0W3N0eWxlTmFtZV0gfHwge307XG5cbiAgICAgIGlmICghb3B0W3N0eWxlTmFtZV0uZW1waGFzaXMpIHtcbiAgICAgICAgb3B0W3N0eWxlTmFtZV0uZW1waGFzaXMgPSBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgenJVdGlsLm1lcmdlKG9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzLCBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgZW1waGFzaXNJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhdFRleHRTdHlsZShvcHQsIHByb3BOYW1lKSB7XG4gIHZhciBsYWJlbE9wdFNpbmdsZSA9IGlzT2JqZWN0KG9wdCkgJiYgb3B0W3Byb3BOYW1lXTtcbiAgdmFyIHRleHRTdHlsZSA9IGlzT2JqZWN0KGxhYmVsT3B0U2luZ2xlKSAmJiBsYWJlbE9wdFNpbmdsZS50ZXh0U3R5bGU7XG5cbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtb2RlbFV0aWwuVEVYVF9TVFlMRV9PUFRJT05TLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBtb2RlbFV0aWwuVEVYVF9TVFlMRV9PUFRJT05TW2ldO1xuXG4gICAgICBpZiAodGV4dFN0eWxlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBsYWJlbE9wdFNpbmdsZVtwcm9wTmFtZV0gPSB0ZXh0U3R5bGVbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXRMYWJlbFRleHRTdHlsZShsYWJlbE9wdCkge1xuICBpZiAoaXNPYmplY3QobGFiZWxPcHQpKSB7XG4gICAgY29tcGF0VGV4dFN0eWxlKGxhYmVsT3B0LCAnbm9ybWFsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKGxhYmVsT3B0LCAnZW1waGFzaXMnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2VyaWVzKHNlcmllc09wdCkge1xuICBpZiAoIWlzT2JqZWN0KHNlcmllc09wdCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb21wYXRJdGVtU3R5bGUoc2VyaWVzT3B0KTtcbiAgY29tcGF0TGFiZWxUZXh0U3R5bGUoc2VyaWVzT3B0LmxhYmVsKTsgLy8gdHJlZW1hcFxuXG4gIGNvbXBhdExhYmVsVGV4dFN0eWxlKHNlcmllc09wdC51cHBlckxhYmVsKTsgLy8gZ3JhcGhcblxuICBjb21wYXRMYWJlbFRleHRTdHlsZShzZXJpZXNPcHQuZWRnZUxhYmVsKTtcbiAgdmFyIG1hcmtQb2ludCA9IHNlcmllc09wdC5tYXJrUG9pbnQ7XG4gIGNvbXBhdEl0ZW1TdHlsZShtYXJrUG9pbnQpO1xuICBjb21wYXRMYWJlbFRleHRTdHlsZShtYXJrUG9pbnQgJiYgbWFya1BvaW50LmxhYmVsKTtcbiAgdmFyIG1hcmtMaW5lID0gc2VyaWVzT3B0Lm1hcmtMaW5lO1xuICBjb21wYXRJdGVtU3R5bGUoc2VyaWVzT3B0Lm1hcmtMaW5lKTtcbiAgY29tcGF0TGFiZWxUZXh0U3R5bGUobWFya0xpbmUgJiYgbWFya0xpbmUubGFiZWwpO1xuICB2YXIgbWFya0FyZWEgPSBzZXJpZXNPcHQubWFya0FyZWE7XG4gIGNvbXBhdExhYmVsVGV4dFN0eWxlKG1hcmtBcmVhICYmIG1hcmtBcmVhLmxhYmVsKTsgLy8gRm9yIGdhdWdlXG5cbiAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ2F4aXNMYWJlbCcpO1xuICBjb21wYXRUZXh0U3R5bGUoc2VyaWVzT3B0LCAndGl0bGUnKTtcbiAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ2RldGFpbCcpO1xuICB2YXIgZGF0YSA9IHNlcmllc09wdC5kYXRhO1xuXG4gIGlmIChkYXRhKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb21wYXRJdGVtU3R5bGUoZGF0YVtpXSk7XG4gICAgICBjb21wYXRMYWJlbFRleHRTdHlsZShkYXRhW2ldICYmIGRhdGFbaV0ubGFiZWwpO1xuICAgIH1cbiAgfSAvLyBtYXJrIHBvaW50IGRhdGFcblxuXG4gIHZhciBtYXJrUG9pbnQgPSBzZXJpZXNPcHQubWFya1BvaW50O1xuXG4gIGlmIChtYXJrUG9pbnQgJiYgbWFya1BvaW50LmRhdGEpIHtcbiAgICB2YXIgbXBEYXRhID0gbWFya1BvaW50LmRhdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1wRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29tcGF0SXRlbVN0eWxlKG1wRGF0YVtpXSk7XG4gICAgICBjb21wYXRMYWJlbFRleHRTdHlsZShtcERhdGFbaV0gJiYgbXBEYXRhW2ldLmxhYmVsKTtcbiAgICB9XG4gIH0gLy8gbWFyayBsaW5lIGRhdGFcblxuXG4gIHZhciBtYXJrTGluZSA9IHNlcmllc09wdC5tYXJrTGluZTtcblxuICBpZiAobWFya0xpbmUgJiYgbWFya0xpbmUuZGF0YSkge1xuICAgIHZhciBtbERhdGEgPSBtYXJrTGluZS5kYXRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh6clV0aWwuaXNBcnJheShtbERhdGFbaV0pKSB7XG4gICAgICAgIGNvbXBhdEl0ZW1TdHlsZShtbERhdGFbaV1bMF0pO1xuICAgICAgICBjb21wYXRMYWJlbFRleHRTdHlsZShtbERhdGFbaV1bMF0gJiYgbWxEYXRhW2ldWzBdLmxhYmVsKTtcbiAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1sRGF0YVtpXVsxXSk7XG4gICAgICAgIGNvbXBhdExhYmVsVGV4dFN0eWxlKG1sRGF0YVtpXVsxXSAmJiBtbERhdGFbaV1bMV0ubGFiZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1sRGF0YVtpXSk7XG4gICAgICAgIGNvbXBhdExhYmVsVGV4dFN0eWxlKG1sRGF0YVtpXSAmJiBtbERhdGFbaV0ubGFiZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0b0FycihvKSB7XG4gIHJldHVybiB6clV0aWwuaXNBcnJheShvKSA/IG8gOiBvID8gW29dIDogW107XG59XG5cbmZ1bmN0aW9uIHRvT2JqKG8pIHtcbiAgcmV0dXJuICh6clV0aWwuaXNBcnJheShvKSA/IG9bMF0gOiBvKSB8fCB7fTtcbn1cblxuZnVuY3Rpb24gX2RlZmF1bHQob3B0aW9uLCBpc1RoZW1lKSB7XG4gIGVhY2godG9BcnIob3B0aW9uLnNlcmllcyksIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICBpc09iamVjdChzZXJpZXNPcHQpICYmIHByb2Nlc3NTZXJpZXMoc2VyaWVzT3B0KTtcbiAgfSk7XG4gIHZhciBheGVzID0gWyd4QXhpcycsICd5QXhpcycsICdyYWRpdXNBeGlzJywgJ2FuZ2xlQXhpcycsICdzaW5nbGVBeGlzJywgJ3BhcmFsbGVsQXhpcycsICdyYWRhciddO1xuICBpc1RoZW1lICYmIGF4ZXMucHVzaCgndmFsdWVBeGlzJywgJ2NhdGVnb3J5QXhpcycsICdsb2dBeGlzJywgJ3RpbWVBeGlzJyk7XG4gIGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXNOYW1lKSB7XG4gICAgZWFjaCh0b0FycihvcHRpb25bYXhpc05hbWVdKSwgZnVuY3Rpb24gKGF4aXNPcHQpIHtcbiAgICAgIGlmIChheGlzT3B0KSB7XG4gICAgICAgIGNvbXBhdFRleHRTdHlsZShheGlzT3B0LCAnYXhpc0xhYmVsJyk7XG4gICAgICAgIGNvbXBhdFRleHRTdHlsZShheGlzT3B0LmF4aXNQb2ludGVyLCAnbGFiZWwnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGVhY2godG9BcnIob3B0aW9uLnBhcmFsbGVsKSwgZnVuY3Rpb24gKHBhcmFsbGVsT3B0KSB7XG4gICAgdmFyIHBhcmFsbGVsQXhpc0RlZmF1bHQgPSBwYXJhbGxlbE9wdCAmJiBwYXJhbGxlbE9wdC5wYXJhbGxlbEF4aXNEZWZhdWx0O1xuICAgIGNvbXBhdFRleHRTdHlsZShwYXJhbGxlbEF4aXNEZWZhdWx0LCAnYXhpc0xhYmVsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKHBhcmFsbGVsQXhpc0RlZmF1bHQgJiYgcGFyYWxsZWxBeGlzRGVmYXVsdC5heGlzUG9pbnRlciwgJ2xhYmVsJyk7XG4gIH0pO1xuICBlYWNoKHRvQXJyKG9wdGlvbi5jYWxlbmRhciksIGZ1bmN0aW9uIChjYWxlbmRhck9wdCkge1xuICAgIGNvbXBhdFRleHRTdHlsZShjYWxlbmRhck9wdCwgJ2RheUxhYmVsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKGNhbGVuZGFyT3B0LCAnbW9udGhMYWJlbCcpO1xuICAgIGNvbXBhdFRleHRTdHlsZShjYWxlbmRhck9wdCwgJ3llYXJMYWJlbCcpO1xuICB9KTsgLy8gcmFkYXIubmFtZS50ZXh0U3R5bGVcblxuICBlYWNoKHRvQXJyKG9wdGlvbi5yYWRhciksIGZ1bmN0aW9uIChyYWRhck9wdCkge1xuICAgIGNvbXBhdFRleHRTdHlsZShyYWRhck9wdCwgJ25hbWUnKTtcbiAgfSk7XG4gIGVhY2godG9BcnIob3B0aW9uLmdlbyksIGZ1bmN0aW9uIChnZW9PcHQpIHtcbiAgICBpZiAoaXNPYmplY3QoZ2VvT3B0KSkge1xuICAgICAgY29tcGF0TGFiZWxUZXh0U3R5bGUoZ2VvT3B0LmxhYmVsKTtcbiAgICAgIGVhY2godG9BcnIoZ2VvT3B0LnJlZ2lvbnMpLCBmdW5jdGlvbiAocmVnaW9uT2JqKSB7XG4gICAgICAgIGNvbXBhdExhYmVsVGV4dFN0eWxlKHJlZ2lvbk9iai5sYWJlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb21wYXRMYWJlbFRleHRTdHlsZSh0b09iaihvcHRpb24udGltZWxpbmUpLmxhYmVsKTtcbiAgY29tcGF0VGV4dFN0eWxlKHRvT2JqKG9wdGlvbi5heGlzUG9pbnRlciksICdsYWJlbCcpO1xuICBjb21wYXRUZXh0U3R5bGUodG9PYmoob3B0aW9uLnRvb2x0aXApLmF4aXNQb2ludGVyLCAnbGFiZWwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvaGVscGVyL2NvbXBhdFN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgR3JhZGllbnQgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudFwiKTtcblxuZnVuY3Rpb24gX2RlZmF1bHQoZWNNb2RlbCkge1xuICBmdW5jdGlvbiBlbmNvZGVDb2xvcihzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb2xvckFjY2Vzc1BhdGggPSAoc2VyaWVzTW9kZWwudmlzdWFsQ29sb3JBY2Nlc3NQYXRoIHx8ICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykuc3BsaXQoJy4nKTtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgY29sb3IgPSBzZXJpZXNNb2RlbC5nZXQoY29sb3JBY2Nlc3NQYXRoKSAvLyBTZXQgaW4gaXRlbVN0eWxlXG4gICAgfHwgc2VyaWVzTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShzZXJpZXNNb2RlbC5nZXQoJ25hbWUnKSk7IC8vIERlZmF1bHQgY29sb3JcbiAgICAvLyBGSVhNRSBTZXQgY29sb3IgZnVuY3Rpb24gb3IgdXNlIHRoZSBwbGF0dGUgY29sb3JcblxuICAgIGRhdGEuc2V0VmlzdWFsKCdjb2xvcicsIGNvbG9yKTsgLy8gT25seSB2aXNpYmxlIHNlcmllcyBoYXMgZWFjaCBkYXRhIGJlIHZpc3VhbCBlbmNvZGVkXG5cbiAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdmdW5jdGlvbicgJiYgIShjb2xvciBpbnN0YW5jZW9mIEdyYWRpZW50KSkge1xuICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicsIGNvbG9yKHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoaWR4KSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gaXRlbVN0eWxlIGluIGVhY2ggZGF0YSBpdGVtXG5cblxuICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgIHZhciBjb2xvciA9IGl0ZW1Nb2RlbC5nZXQoY29sb3JBY2Nlc3NQYXRoLCB0cnVlKTtcblxuICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzKGVuY29kZUNvbG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvc2VyaWVzQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDIzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBQSSA9IE1hdGguUEk7XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50ZXh0XVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbG9yXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRleHRDb2xvcl1cbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gKi9cblxuZnVuY3Rpb24gX2RlZmF1bHQoYXBpLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB6clV0aWwuZGVmYXVsdHMob3B0cywge1xuICAgIHRleHQ6ICdsb2FkaW5nJyxcbiAgICBjb2xvcjogJyNjMjM1MzEnLFxuICAgIHRleHRDb2xvcjogJyMwMDAnLFxuICAgIG1hc2tDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC44KScsXG4gICAgemxldmVsOiAwXG4gIH0pO1xuICB2YXIgbWFzayA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHN0eWxlOiB7XG4gICAgICBmaWxsOiBvcHRzLm1hc2tDb2xvclxuICAgIH0sXG4gICAgemxldmVsOiBvcHRzLnpsZXZlbCxcbiAgICB6OiAxMDAwMFxuICB9KTtcbiAgdmFyIGFyYyA9IG5ldyBncmFwaGljLkFyYyh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHN0YXJ0QW5nbGU6IC1QSSAvIDIsXG4gICAgICBlbmRBbmdsZTogLVBJIC8gMiArIDAuMSxcbiAgICAgIHI6IDEwXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgc3Ryb2tlOiBvcHRzLmNvbG9yLFxuICAgICAgbGluZUNhcDogJ3JvdW5kJyxcbiAgICAgIGxpbmVXaWR0aDogNVxuICAgIH0sXG4gICAgemxldmVsOiBvcHRzLnpsZXZlbCxcbiAgICB6OiAxMDAwMVxuICB9KTtcbiAgdmFyIGxhYmVsUmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHN0eWxlOiB7XG4gICAgICBmaWxsOiAnbm9uZScsXG4gICAgICB0ZXh0OiBvcHRzLnRleHQsXG4gICAgICB0ZXh0UG9zaXRpb246ICdyaWdodCcsXG4gICAgICB0ZXh0RGlzdGFuY2U6IDEwLFxuICAgICAgdGV4dEZpbGw6IG9wdHMudGV4dENvbG9yXG4gICAgfSxcbiAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgIHo6IDEwMDAxXG4gIH0pO1xuICBhcmMuYW5pbWF0ZVNoYXBlKHRydWUpLndoZW4oMTAwMCwge1xuICAgIGVuZEFuZ2xlOiBQSSAqIDMgLyAyXG4gIH0pLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG4gIGFyYy5hbmltYXRlU2hhcGUodHJ1ZSkud2hlbigxMDAwLCB7XG4gICAgc3RhcnRBbmdsZTogUEkgKiAzIC8gMlxuICB9KS5kZWxheSgzMDApLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG4gIHZhciBncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gIGdyb3VwLmFkZChhcmMpO1xuICBncm91cC5hZGQobGFiZWxSZWN0KTtcbiAgZ3JvdXAuYWRkKG1hc2spOyAvLyBJbmplY3QgcmVzaXplXG5cbiAgZ3JvdXAucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjeCA9IGFwaS5nZXRXaWR0aCgpIC8gMjtcbiAgICB2YXIgY3kgPSBhcGkuZ2V0SGVpZ2h0KCkgLyAyO1xuICAgIGFyYy5zZXRTaGFwZSh7XG4gICAgICBjeDogY3gsXG4gICAgICBjeTogY3lcbiAgICB9KTtcbiAgICB2YXIgciA9IGFyYy5zaGFwZS5yO1xuICAgIGxhYmVsUmVjdC5zZXRTaGFwZSh7XG4gICAgICB4OiBjeCAtIHIsXG4gICAgICB5OiBjeSAtIHIsXG4gICAgICB3aWR0aDogciAqIDIsXG4gICAgICBoZWlnaHQ6IHIgKiAyXG4gICAgfSk7XG4gICAgbWFzay5zZXRTaGFwZSh7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfSk7XG4gIH07XG5cbiAgZ3JvdXAucmVzaXplKCk7XG4gIHJldHVybiBncm91cDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sb2FkaW5nL2RlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6cmVuZGVyID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3pyZW5kZXJcIik7XG5cbmV4cG9ydHMuenJlbmRlciA9IHpyZW5kZXI7XG5cbnZhciBtYXRyaXggPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9tYXRyaXhcIik7XG5cbmV4cG9ydHMubWF0cml4ID0gbWF0cml4O1xuXG52YXIgdmVjdG9yID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdmVjdG9yXCIpO1xuXG5leHBvcnRzLnZlY3RvciA9IHZlY3RvcjtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBjb2xvclRvb2wgPSByZXF1aXJlKFwienJlbmRlci9saWIvdG9vbC9jb2xvclwiKTtcblxuZXhwb3J0cy5jb2xvciA9IGNvbG9yVG9vbDtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi91dGlsL2dyYXBoaWNcIik7XG5cbmV4cG9ydHMuZ3JhcGhpYyA9IGdyYXBoaWM7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4vdXRpbC9udW1iZXJcIik7XG5cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyVXRpbDtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi91dGlsL2Zvcm1hdFwiKTtcblxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXRVdGlsO1xuXG52YXIgX3Rocm90dGxlID0gcmVxdWlyZShcIi4vdXRpbC90aHJvdHRsZVwiKTtcblxudmFyIHRocm90dGxlID0gX3Rocm90dGxlLnRocm90dGxlO1xuZXhwb3J0cy50aHJvdHRsZSA9IF90aHJvdHRsZS50aHJvdHRsZTtcblxudmFyIGVjSGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuXG5leHBvcnRzLmhlbHBlciA9IGVjSGVscGVyO1xuXG52YXIgX0xpc3QgPSByZXF1aXJlKFwiLi9kYXRhL0xpc3RcIik7XG5cbmV4cG9ydHMuTGlzdCA9IF9MaXN0O1xuXG52YXIgX01vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvTW9kZWxcIik7XG5cbmV4cG9ydHMuTW9kZWwgPSBfTW9kZWw7XG5cbnZhciBfQXhpcyA9IHJlcXVpcmUoXCIuL2Nvb3JkL0F4aXNcIik7XG5cbmV4cG9ydHMuQXhpcyA9IF9BeGlzO1xuXG52YXIgX2VudiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2VudlwiKTtcblxuZXhwb3J0cy5lbnYgPSBfZW52O1xuXG52YXIgX3BhcnNlR2VvSnNvbiA9IHJlcXVpcmUoXCIuL2Nvb3JkL2dlby9wYXJzZUdlb0pzb25cIik7XG5cbmV4cG9ydHMucGFyc2VHZW9Kc29uID0gX3BhcnNlR2VvSnNvbjtcblxuLyoqXG4gKiBEbyBub3QgbW91bnQgdGhvc2UgbW9kdWxlcyBvbiAnc3JjL2VjaGFydHMnIGZvciBiZXR0ZXIgdHJlZSBzaGFraW5nLlxuICovXG52YXIgZWNVdGlsID0ge307XG56clV0aWwuZWFjaChbJ21hcCcsICdlYWNoJywgJ2ZpbHRlcicsICdpbmRleE9mJywgJ2luaGVyaXRzJywgJ3JlZHVjZScsICdmaWx0ZXInLCAnYmluZCcsICdjdXJyeScsICdpc0FycmF5JywgJ2lzU3RyaW5nJywgJ2lzT2JqZWN0JywgJ2lzRnVuY3Rpb24nLCAnZXh0ZW5kJywgJ2RlZmF1bHRzJywgJ2Nsb25lJywgJ21lcmdlJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGVjVXRpbFtuYW1lXSA9IHpyVXRpbFtuYW1lXTtcbn0pO1xuZXhwb3J0cy51dGlsID0gZWNVdGlsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gMjMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBjcmVhdGVMaXN0RnJvbUFycmF5ID0gcmVxdWlyZShcIi4vY2hhcnQvaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXlcIik7XG5cbnZhciBheGlzSGVscGVyID0gcmVxdWlyZShcIi4vY29vcmQvYXhpc0hlbHBlclwiKTtcblxudmFyIGF4aXNNb2RlbENvbW1vbk1peGluID0gcmVxdWlyZShcIi4vY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW5cIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsL01vZGVsXCIpO1xuXG52YXIgX2NvbXBsZXRlRGltZW5zaW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9uc1wiKTtcblxuZXhwb3J0cy5jb21wbGV0ZURpbWVuc2lvbnMgPSBfY29tcGxldGVEaW1lbnNpb25zO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuL3V0aWwvc3ltYm9sXCIpO1xuXG5leHBvcnRzLmNyZWF0ZVN5bWJvbCA9IF9zeW1ib2wuY3JlYXRlU3ltYm9sO1xuXG4vKipcbiAqIENyZWF0ZSBhIG11dGkgZGltZW5zaW9uIExpc3Qgc3RydWN0dXJlIGZyb20gc2VyaWVzTW9kZWwuXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gc2VyaWVzTW9kZWxcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gbGlzdFxuICovXG5mdW5jdGlvbiBjcmVhdGVMaXN0KHNlcmllc01vZGVsKSB7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJyk7XG4gIHJldHVybiBjcmVhdGVMaXN0RnJvbUFycmF5KGRhdGEsIHNlcmllc01vZGVsLCBzZXJpZXNNb2RlbC5lY01vZGVsKTtcbn1cbi8qKlxuICogQHNlZSB7bW9kdWxlOmVjaGFydHMvZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zfVxuICovXG5cblxuLyoqXG4gKiBDcmVhdGUgc2NhbGVcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGFFeHRlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTplY2hhcnRzL01vZGVsfSBvcHRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2NhbGUoZGF0YUV4dGVudCwgb3B0aW9uKSB7XG4gIHZhciBheGlzTW9kZWwgPSBvcHRpb247XG5cbiAgaWYgKCEob3B0aW9uIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgYXhpc01vZGVsID0gbmV3IE1vZGVsKG9wdGlvbik7XG4gICAgenJVdGlsLm1peGluKGF4aXNNb2RlbCwgYXhpc01vZGVsQ29tbW9uTWl4aW4pO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gYXhpc0hlbHBlci5jcmVhdGVTY2FsZUJ5TW9kZWwoYXhpc01vZGVsKTtcbiAgc2NhbGUuc2V0RXh0ZW50KGRhdGFFeHRlbnRbMF0sIGRhdGFFeHRlbnRbMV0pO1xuICBheGlzSGVscGVyLm5pY2VTY2FsZUV4dGVudChzY2FsZSwgYXhpc01vZGVsKTtcbiAgcmV0dXJuIHNjYWxlO1xufVxuLyoqXG4gKiBNaXhpbiBjb21tb24gbWV0aG9kcyB0byBheGlzIG1vZGVsLFxuICpcbiAqIElubGN1ZGUgbWV0aG9kc1xuICogYGdldEZvcm1hdHRlZExhYmVscygpID0+IEFycmF5LjxzdHJpbmc+YFxuICogYGdldENhdGVnb3JpZXMoKSA9PiBBcnJheS48c3RyaW5nPmBcbiAqIGBnZXRNaW4ob3JpZ2luOiBib29sZWFuKSA9PiBudW1iZXJgXG4gKiBgZ2V0TWF4KG9yaWdpbjogYm9vbGVhbikgPT4gbnVtYmVyYFxuICogYGdldE5lZWRDcm9zc1plcm8oKSA9PiBib29sZWFuYFxuICogYHNldFJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKWBcbiAqIGByZXNldFJhbmdlKClgXG4gKi9cblxuXG5mdW5jdGlvbiBtaXhpbkF4aXNNb2RlbENvbW1vbk1ldGhvZHMoTW9kZWwpIHtcbiAgenJVdGlsLm1peGluKE1vZGVsLCBheGlzTW9kZWxDb21tb25NaXhpbik7XG59XG5cbmV4cG9ydHMuY3JlYXRlTGlzdCA9IGNyZWF0ZUxpc3Q7XG5leHBvcnRzLmNyZWF0ZVNjYWxlID0gY3JlYXRlU2NhbGU7XG5leHBvcnRzLm1peGluQXhpc01vZGVsQ29tbW9uTWV0aG9kcyA9IG1peGluQXhpc01vZGVsQ29tbW9uTWV0aG9kcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9oZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgU2NhbGUgPSByZXF1aXJlKFwiLi9TY2FsZVwiKTtcblxuLyoqXG4gKiBMaW5lYXIgY29udGludW91cyBzY2FsZVxuICogQG1vZHVsZSBlY2hhcnRzL2Nvb3JkL3NjYWxlL09yZGluYWxcbiAqXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldmVsX29mX21lYXN1cmVtZW50XG4gKi9cbi8vIEZJWE1FIG9ubHkgb25lIGRhdGFcbnZhciBzY2FsZVByb3RvID0gU2NhbGUucHJvdG90eXBlO1xudmFyIE9yZGluYWxTY2FsZSA9IFNjYWxlLmV4dGVuZCh7XG4gIHR5cGU6ICdvcmRpbmFsJyxcbiAgaW5pdDogZnVuY3Rpb24gKGRhdGEsIGV4dGVudCkge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMuX2V4dGVudCA9IGV4dGVudCB8fCBbMCwgZGF0YS5sZW5ndGggLSAxXTtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyB6clV0aWwuaW5kZXhPZih0aGlzLl9kYXRhLCB2YWwpIC8vIHZhbCBtaWdodCBiZSBmbG9hdC5cbiAgICA6IE1hdGgucm91bmQodmFsKTtcbiAgfSxcbiAgY29udGFpbjogZnVuY3Rpb24gKHJhbmspIHtcbiAgICByYW5rID0gdGhpcy5wYXJzZShyYW5rKTtcbiAgICByZXR1cm4gc2NhbGVQcm90by5jb250YWluLmNhbGwodGhpcywgcmFuaykgJiYgdGhpcy5fZGF0YVtyYW5rXSAhPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgZ2l2ZW4gcmFuayBvciBuYW1lIHRvIGxpbmVhciBbMCwgMV1cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbdmFsXVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBub3JtYWxpemU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gc2NhbGVQcm90by5ub3JtYWxpemUuY2FsbCh0aGlzLCB0aGlzLnBhcnNlKHZhbCkpO1xuICB9LFxuICBzY2FsZTogZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHNjYWxlUHJvdG8uc2NhbGUuY2FsbCh0aGlzLCB2YWwpKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBnZXRUaWNrczogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aWNrcyA9IFtdO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHJhbmsgPSBleHRlbnRbMF07XG5cbiAgICB3aGlsZSAocmFuayA8PSBleHRlbnRbMV0pIHtcbiAgICAgIHRpY2tzLnB1c2gocmFuayk7XG4gICAgICByYW5rKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgaXRlbSBvbiByYW5rIG5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0TGFiZWw6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbbl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dGVudFsxXSAtIHRoaXMuX2V4dGVudFswXSArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdW5pb25FeHRlbnRGcm9tRGF0YTogZnVuY3Rpb24gKGRhdGEsIGRpbSkge1xuICAgIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXREYXRhRXh0ZW50KGRpbSwgZmFsc2UpKTtcbiAgfSxcbiAgbmljZVRpY2tzOiB6clV0aWwubm9vcCxcbiAgbmljZUV4dGVudDogenJVdGlsLm5vb3Bcbn0pO1xuLyoqXG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lfVxuICovXG5cbk9yZGluYWxTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgT3JkaW5hbFNjYWxlKCk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBPcmRpbmFsU2NhbGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanNcbi8vIG1vZHVsZSBpZCA9IDIzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL251bWJlclwiKTtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBzY2FsZUhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxudmFyIEludGVydmFsU2NhbGUgPSByZXF1aXJlKFwiLi9JbnRlcnZhbFwiKTtcblxuLy8gW0Fib3V0IFVUQyBhbmQgbG9jYWwgdGltZSB6b25lXTpcbi8vIEluIG1vc3QgY2FzZXMsIGBudW1iZXIucGFyc2VEYXRlYCB3aWxsIHRyZWF0IGlucHV0IGRhdGEgc3RyaW5nIGFzIGxvY2FsIHRpbWVcbi8vIChleGNlcHQgdGltZSB6b25lIGlzIHNwZWNpZmllZCBpbiB0aW1lIHN0cmluZykuIEFuZCBgZm9ybWF0LmZvcm1hdGVUaW1lYCByZXR1cm5zXG4vLyBsb2NhbCB0aW1lIGJ5IGRlZmF1bHQuIG9wdGlvbi51c2VVVEMgaXMgZmFsc2UgYnkgZGVmYXVsdC4gVGhpcyBkZXNpZ24gaGF2ZVxuLy8gY29uY2lkZXJlZCB0aGVzZSBjb21tb24gY2FzZTpcbi8vICgxKSBUaW1lIHRoYXQgaXMgcGVyc2lzdGVudCBpbiBzZXJ2ZXIgaXMgaW4gVVRDLCBidXQgaXQgaXMgbmVlZGVkIHRvIGJlIGRpcGxheWVkXG4vLyBpbiBsb2NhbCB0aW1lIGJ5IGRlZmF1bHQuXG4vLyAoMikgQnkgZGVmYXVsdCwgdGhlIGlucHV0IGRhdGEgc3RyaW5nIChlLmcuLCAnMjAxMS0wMS0wMicpIHNob3VsZCBiZSBkaXNwbGF5ZWRcbi8vIGFzIGl0cyBvcmlnaW5hbCB0aW1lLCB3aXRob3V0IGFueSB0aW1lIGRpZmZlcmVuY2UuXG52YXIgaW50ZXJ2YWxTY2FsZVByb3RvID0gSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGU7XG52YXIgbWF0aENlaWwgPSBNYXRoLmNlaWw7XG52YXIgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBPTkVfU0VDT05EID0gMTAwMDtcbnZhciBPTkVfTUlOVVRFID0gT05FX1NFQ09ORCAqIDYwO1xudmFyIE9ORV9IT1VSID0gT05FX01JTlVURSAqIDYwO1xudmFyIE9ORV9EQVkgPSBPTkVfSE9VUiAqIDI0OyAvLyBGSVhNRSDlhaznlKjvvJ9cblxudmFyIGJpc2VjdCA9IGZ1bmN0aW9uIChhLCB4LCBsbywgaGkpIHtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcblxuICAgIGlmIChhW21pZF1bMV0gPCB4KSB7XG4gICAgICBsbyA9IG1pZCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsbztcbn07XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9zY2FsZS9UaW1lXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBUaW1lU2NhbGUgPSBJbnRlcnZhbFNjYWxlLmV4dGVuZCh7XG4gIHR5cGU6ICd0aW1lJyxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRMYWJlbDogZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhciBzdGVwTHZsID0gdGhpcy5fc3RlcEx2bDtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHZhbCk7XG4gICAgcmV0dXJuIGZvcm1hdFV0aWwuZm9ybWF0VGltZShzdGVwTHZsWzBdLCBkYXRlLCB0aGlzLmdldFNldHRpbmcoJ3VzZVVUQycpKTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBuaWNlRXh0ZW50OiBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDsgLy8gSWYgZXh0ZW50IHN0YXJ0IGFuZCBlbmQgYXJlIHNhbWUsIGV4cGFuZCB0aGVtXG5cbiAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgIC8vIEV4cGFuZCBleHRlbnRcbiAgICAgIGV4dGVudFswXSAtPSBPTkVfREFZO1xuICAgICAgZXh0ZW50WzFdICs9IE9ORV9EQVk7XG4gICAgfSAvLyBJZiB0aGVyZSBhcmUgbm8gZGF0YSBhbmQgZXh0ZW50IGFyZSBbSW5maW5pdHksIC1JbmZpbml0eV1cblxuXG4gICAgaWYgKGV4dGVudFsxXSA9PT0gLUluZmluaXR5ICYmIGV4dGVudFswXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICAgIGV4dGVudFsxXSA9ICtuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCkpO1xuICAgICAgZXh0ZW50WzBdID0gZXh0ZW50WzFdIC0gT05FX0RBWTtcbiAgICB9XG5cbiAgICB0aGlzLm5pY2VUaWNrcyhvcHQuc3BsaXROdW1iZXIsIG9wdC5taW5JbnRlcnZhbCwgb3B0Lm1heEludGVydmFsKTsgLy8gdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcblxuICAgIHZhciBpbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsO1xuXG4gICAgaWYgKCFvcHQuZml4TWluKSB7XG4gICAgICBleHRlbnRbMF0gPSBudW1iZXJVdGlsLnJvdW5kKG1hdGhGbG9vcihleHRlbnRbMF0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHQuZml4TWF4KSB7XG4gICAgICBleHRlbnRbMV0gPSBudW1iZXJVdGlsLnJvdW5kKG1hdGhDZWlsKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbmljZVRpY2tzOiBmdW5jdGlvbiAoYXBwcm94VGlja051bSwgbWluSW50ZXJ2YWwsIG1heEludGVydmFsKSB7XG4gICAgYXBwcm94VGlja051bSA9IGFwcHJveFRpY2tOdW0gfHwgMTA7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICB2YXIgYXBwcm94SW50ZXJ2YWwgPSBzcGFuIC8gYXBwcm94VGlja051bTtcblxuICAgIGlmIChtaW5JbnRlcnZhbCAhPSBudWxsICYmIGFwcHJveEludGVydmFsIDwgbWluSW50ZXJ2YWwpIHtcbiAgICAgIGFwcHJveEludGVydmFsID0gbWluSW50ZXJ2YWw7XG4gICAgfVxuXG4gICAgaWYgKG1heEludGVydmFsICE9IG51bGwgJiYgYXBwcm94SW50ZXJ2YWwgPiBtYXhJbnRlcnZhbCkge1xuICAgICAgYXBwcm94SW50ZXJ2YWwgPSBtYXhJbnRlcnZhbDtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGVMZXZlbHNMZW4gPSBzY2FsZUxldmVscy5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IGJpc2VjdChzY2FsZUxldmVscywgYXBwcm94SW50ZXJ2YWwsIDAsIHNjYWxlTGV2ZWxzTGVuKTtcbiAgICB2YXIgbGV2ZWwgPSBzY2FsZUxldmVsc1tNYXRoLm1pbihpZHgsIHNjYWxlTGV2ZWxzTGVuIC0gMSldO1xuICAgIHZhciBpbnRlcnZhbCA9IGxldmVsWzFdOyAvLyBTYW1lIHdpdGggaW50ZXJ2YWwgc2NhbGUgaWYgc3BhbiBpcyBtdWNoIGxhcmdlciB0aGFuIDEgeWVhclxuXG4gICAgaWYgKGxldmVsWzBdID09PSAneWVhcicpIHtcbiAgICAgIHZhciB5ZWFyU3BhbiA9IHNwYW4gLyBpbnRlcnZhbDsgLy8gRnJvbSBcIk5pY2UgTnVtYmVycyBmb3IgR3JhcGggTGFiZWxzXCIgb2YgR3JhcGhpYyBHZW1zXG4gICAgICAvLyB2YXIgbmljZVllYXJTcGFuID0gbnVtYmVyVXRpbC5uaWNlKHllYXJTcGFuLCBmYWxzZSk7XG5cbiAgICAgIHZhciB5ZWFyU3RlcCA9IG51bWJlclV0aWwubmljZSh5ZWFyU3BhbiAvIGFwcHJveFRpY2tOdW0sIHRydWUpO1xuICAgICAgaW50ZXJ2YWwgKj0geWVhclN0ZXA7XG4gICAgfVxuXG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gdGhpcy5nZXRTZXR0aW5nKCd1c2VVVEMnKSA/IDAgOiBuZXcgRGF0ZSgrZXh0ZW50WzBdIHx8ICtleHRlbnRbMV0pLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDA7XG4gICAgdmFyIG5pY2VFeHRlbnQgPSBbTWF0aC5yb3VuZChtYXRoQ2VpbCgoZXh0ZW50WzBdIC0gdGltZXpvbmVPZmZzZXQpIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwgKyB0aW1lem9uZU9mZnNldCksIE1hdGgucm91bmQobWF0aEZsb29yKChleHRlbnRbMV0gLSB0aW1lem9uZU9mZnNldCkgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCArIHRpbWV6b25lT2Zmc2V0KV07XG4gICAgc2NhbGVIZWxwZXIuZml4RXh0ZW50KG5pY2VFeHRlbnQsIGV4dGVudCk7XG4gICAgdGhpcy5fc3RlcEx2bCA9IGxldmVsOyAvLyBJbnRlcnZhbCB3aWxsIGJlIHVzZWQgaW4gZ2V0VGlja3NcblxuICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgdGhpcy5fbmljZUV4dGVudCA9IG5pY2VFeHRlbnQ7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gdmFsIG1pZ2h0IGJlIGZsb2F0LlxuICAgIHJldHVybiArbnVtYmVyVXRpbC5wYXJzZURhdGUodmFsKTtcbiAgfVxufSk7XG56clV0aWwuZWFjaChbJ2NvbnRhaW4nLCAnbm9ybWFsaXplJ10sIGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIFRpbWVTY2FsZS5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIGludGVydmFsU2NhbGVQcm90b1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIHRoaXMucGFyc2UodmFsKSk7XG4gIH07XG59KTsgLy8gU3RlcHMgZnJvbSBkM1xuXG52YXIgc2NhbGVMZXZlbHMgPSBbLy8gRm9ybWF0ICAgICAgICAgICAgICBpbnRlcnZhbFxuWydoaDptbTpzcycsIE9ORV9TRUNPTkRdLCAvLyAxc1xuWydoaDptbTpzcycsIE9ORV9TRUNPTkQgKiA1XSwgLy8gNXNcblsnaGg6bW06c3MnLCBPTkVfU0VDT05EICogMTBdLCAvLyAxMHNcblsnaGg6bW06c3MnLCBPTkVfU0VDT05EICogMTVdLCAvLyAxNXNcblsnaGg6bW06c3MnLCBPTkVfU0VDT05EICogMzBdLCAvLyAzMHNcblsnaGg6bW1cXG5NTS1kZCcsIE9ORV9NSU5VVEVdLCAvLyAxbVxuWydoaDptbVxcbk1NLWRkJywgT05FX01JTlVURSAqIDVdLCAvLyA1bVxuWydoaDptbVxcbk1NLWRkJywgT05FX01JTlVURSAqIDEwXSwgLy8gMTBtXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfTUlOVVRFICogMTVdLCAvLyAxNW1cblsnaGg6bW1cXG5NTS1kZCcsIE9ORV9NSU5VVEUgKiAzMF0sIC8vIDMwbVxuWydoaDptbVxcbk1NLWRkJywgT05FX0hPVVJdLCAvLyAxaFxuWydoaDptbVxcbk1NLWRkJywgT05FX0hPVVIgKiAyXSwgLy8gMmhcblsnaGg6bW1cXG5NTS1kZCcsIE9ORV9IT1VSICogNl0sIC8vIDZoXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfSE9VUiAqIDEyXSwgLy8gMTJoXG5bJ01NLWRkXFxueXl5eScsIE9ORV9EQVldLCAvLyAxZFxuWydNTS1kZFxcbnl5eXknLCBPTkVfREFZICogMl0sIC8vIDJkXG5bJ01NLWRkXFxueXl5eScsIE9ORV9EQVkgKiAzXSwgLy8gM2RcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWSAqIDRdLCAvLyA0ZFxuWydNTS1kZFxcbnl5eXknLCBPTkVfREFZICogNV0sIC8vIDVkXG5bJ01NLWRkXFxueXl5eScsIE9ORV9EQVkgKiA2XSwgLy8gNmRcblsnd2VlaycsIE9ORV9EQVkgKiA3XSwgLy8gN2RcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWSAqIDEwXSwgLy8gMTBkXG5bJ3dlZWsnLCBPTkVfREFZICogMTRdLCAvLyAyd1xuWyd3ZWVrJywgT05FX0RBWSAqIDIxXSwgLy8gM3dcblsnbW9udGgnLCBPTkVfREFZICogMzFdLCAvLyAxTVxuWyd3ZWVrJywgT05FX0RBWSAqIDQyXSwgLy8gNndcblsnbW9udGgnLCBPTkVfREFZICogNjJdLCAvLyAyTVxuWyd3ZWVrJywgT05FX0RBWSAqIDQyXSwgLy8gMTB3XG5bJ3F1YXJ0ZXInLCBPTkVfREFZICogMzgwIC8gNF0sIC8vIDNNXG5bJ21vbnRoJywgT05FX0RBWSAqIDMxICogNF0sIC8vIDRNXG5bJ21vbnRoJywgT05FX0RBWSAqIDMxICogNV0sIC8vIDVNXG5bJ2hhbGYteWVhcicsIE9ORV9EQVkgKiAzODAgLyAyXSwgLy8gNk1cblsnbW9udGgnLCBPTkVfREFZICogMzEgKiA4XSwgLy8gOE1cblsnbW9udGgnLCBPTkVfREFZICogMzEgKiAxMF0sIC8vIDEwTVxuWyd5ZWFyJywgT05FX0RBWSAqIDM4MF0gLy8gMVlcbl07XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lfVxuICovXG5cblRpbWVTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgcmV0dXJuIG5ldyBUaW1lU2NhbGUoe1xuICAgIHVzZVVUQzogbW9kZWwuZWNNb2RlbC5nZXQoJ3VzZVVUQycpXG4gIH0pO1xufTtcblxudmFyIF9kZWZhdWx0ID0gVGltZVNjYWxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9UaW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFNjYWxlID0gcmVxdWlyZShcIi4vU2NhbGVcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoXCIuL0ludGVydmFsXCIpO1xuXG4vKipcbiAqIExvZyBzY2FsZVxuICogQG1vZHVsZSBlY2hhcnRzL3NjYWxlL0xvZ1xuICovXG4vLyBVc2Ugc29tZSBtZXRob2Qgb2YgSW50ZXJ2YWxTY2FsZVxudmFyIHNjYWxlUHJvdG8gPSBTY2FsZS5wcm90b3R5cGU7XG52YXIgaW50ZXJ2YWxTY2FsZVByb3RvID0gSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGU7XG52YXIgZ2V0UHJlY2lzaW9uU2FmZSA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZTtcbnZhciByb3VuZGluZ0Vycm9yRml4ID0gbnVtYmVyVXRpbC5yb3VuZDtcbnZhciBtYXRoRmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIG1hdGhDZWlsID0gTWF0aC5jZWlsO1xudmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbnZhciBtYXRoTG9nID0gTWF0aC5sb2c7XG52YXIgTG9nU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuICB0eXBlOiAnbG9nJyxcbiAgYmFzZTogMTAsXG4gICRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIFNjYWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fb3JpZ2luYWxTY2FsZSA9IG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZ2V0VGlja3M6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZ2luYWxTY2FsZSA9IHRoaXMuX29yaWdpbmFsU2NhbGU7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgb3JpZ2luYWxFeHRlbnQgPSBvcmlnaW5hbFNjYWxlLmdldEV4dGVudCgpO1xuICAgIHJldHVybiB6clV0aWwubWFwKGludGVydmFsU2NhbGVQcm90by5nZXRUaWNrcy5jYWxsKHRoaXMpLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB2YXIgcG93VmFsID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoUG93KHRoaXMuYmFzZSwgdmFsKSk7IC8vIEZpeCAjNDE1OFxuXG4gICAgICBwb3dWYWwgPSB2YWwgPT09IGV4dGVudFswXSAmJiBvcmlnaW5hbFNjYWxlLl9fZml4TWluID8gZml4Um91bmRpbmdFcnJvcihwb3dWYWwsIG9yaWdpbmFsRXh0ZW50WzBdKSA6IHBvd1ZhbDtcbiAgICAgIHBvd1ZhbCA9IHZhbCA9PT0gZXh0ZW50WzFdICYmIG9yaWdpbmFsU2NhbGUuX19maXhNYXggPyBmaXhSb3VuZGluZ0Vycm9yKHBvd1ZhbCwgb3JpZ2luYWxFeHRlbnRbMV0pIDogcG93VmFsO1xuICAgICAgcmV0dXJuIHBvd1ZhbDtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRMYWJlbDogaW50ZXJ2YWxTY2FsZVByb3RvLmdldExhYmVsLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBzY2FsZTogZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IHNjYWxlUHJvdG8uc2NhbGUuY2FsbCh0aGlzLCB2YWwpO1xuICAgIHJldHVybiBtYXRoUG93KHRoaXMuYmFzZSwgdmFsKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICovXG4gIHNldEV4dGVudDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYmFzZSA9IHRoaXMuYmFzZTtcbiAgICBzdGFydCA9IG1hdGhMb2coc3RhcnQpIC8gbWF0aExvZyhiYXNlKTtcbiAgICBlbmQgPSBtYXRoTG9nKGVuZCkgLyBtYXRoTG9nKGJhc2UpO1xuICAgIGludGVydmFsU2NhbGVQcm90by5zZXRFeHRlbnQuY2FsbCh0aGlzLCBzdGFydCwgZW5kKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBlbmRcbiAgICovXG4gIGdldEV4dGVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgIHZhciBleHRlbnQgPSBzY2FsZVByb3RvLmdldEV4dGVudC5jYWxsKHRoaXMpO1xuICAgIGV4dGVudFswXSA9IG1hdGhQb3coYmFzZSwgZXh0ZW50WzBdKTtcbiAgICBleHRlbnRbMV0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFsxXSk7IC8vIEZpeCAjNDE1OFxuXG4gICAgdmFyIG9yaWdpbmFsU2NhbGUgPSB0aGlzLl9vcmlnaW5hbFNjYWxlO1xuICAgIHZhciBvcmlnaW5hbEV4dGVudCA9IG9yaWdpbmFsU2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1pbiAmJiAoZXh0ZW50WzBdID0gZml4Um91bmRpbmdFcnJvcihleHRlbnRbMF0sIG9yaWdpbmFsRXh0ZW50WzBdKSk7XG4gICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1heCAmJiAoZXh0ZW50WzFdID0gZml4Um91bmRpbmdFcnJvcihleHRlbnRbMV0sIG9yaWdpbmFsRXh0ZW50WzFdKSk7XG4gICAgcmV0dXJuIGV4dGVudDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGV4dGVudFxuICAgKi9cbiAgdW5pb25FeHRlbnQ6IGZ1bmN0aW9uIChleHRlbnQpIHtcbiAgICB0aGlzLl9vcmlnaW5hbFNjYWxlLnVuaW9uRXh0ZW50KGV4dGVudCk7XG5cbiAgICB2YXIgYmFzZSA9IHRoaXMuYmFzZTtcbiAgICBleHRlbnRbMF0gPSBtYXRoTG9nKGV4dGVudFswXSkgLyBtYXRoTG9nKGJhc2UpO1xuICAgIGV4dGVudFsxXSA9IG1hdGhMb2coZXh0ZW50WzFdKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgc2NhbGVQcm90by51bmlvbkV4dGVudC5jYWxsKHRoaXMsIGV4dGVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdW5pb25FeHRlbnRGcm9tRGF0YTogZnVuY3Rpb24gKGRhdGEsIGRpbSkge1xuICAgIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXREYXRhRXh0ZW50KGRpbSwgdHJ1ZSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCA+IDA7XG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgaW50ZXJ2YWwgYW5kIGV4dGVudCBvZiBpbnRlcnZhbHMgZm9yIG5pY2UgdGlja3NcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbYXBwcm94VGlja051bSA9IDEwXSBHaXZlbiBhcHByb3ggdGljayBudW1iZXJcbiAgICovXG4gIG5pY2VUaWNrczogZnVuY3Rpb24gKGFwcHJveFRpY2tOdW0pIHtcbiAgICBhcHByb3hUaWNrTnVtID0gYXBwcm94VGlja051bSB8fCAxMDtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuXG4gICAgaWYgKHNwYW4gPT09IEluZmluaXR5IHx8IHNwYW4gPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnRlcnZhbCA9IG51bWJlclV0aWwucXVhbnRpdHkoc3Bhbik7XG4gICAgdmFyIGVyciA9IGFwcHJveFRpY2tOdW0gLyBzcGFuICogaW50ZXJ2YWw7IC8vIEZpbHRlciB0aWNrcyB0byBnZXQgY2xvc2VyIHRvIHRoZSBkZXNpcmVkIGNvdW50LlxuXG4gICAgaWYgKGVyciA8PSAwLjUpIHtcbiAgICAgIGludGVydmFsICo9IDEwO1xuICAgIH0gLy8gSW50ZXJ2YWwgc2hvdWxkIGJlIGludGVnZXJcblxuXG4gICAgd2hpbGUgKCFpc05hTihpbnRlcnZhbCkgJiYgTWF0aC5hYnMoaW50ZXJ2YWwpIDwgMSAmJiBNYXRoLmFicyhpbnRlcnZhbCkgPiAwKSB7XG4gICAgICBpbnRlcnZhbCAqPSAxMDtcbiAgICB9XG5cbiAgICB2YXIgbmljZUV4dGVudCA9IFtudW1iZXJVdGlsLnJvdW5kKG1hdGhDZWlsKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKSwgbnVtYmVyVXRpbC5yb3VuZChtYXRoRmxvb3IoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpXTtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsO1xuICAgIHRoaXMuX25pY2VFeHRlbnQgPSBuaWNlRXh0ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBOaWNlIGV4dGVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBuaWNlRXh0ZW50OiBmdW5jdGlvbiAob3B0KSB7XG4gICAgaW50ZXJ2YWxTY2FsZVByb3RvLm5pY2VFeHRlbnQuY2FsbCh0aGlzLCBvcHQpO1xuICAgIHZhciBvcmlnaW5hbFNjYWxlID0gdGhpcy5fb3JpZ2luYWxTY2FsZTtcbiAgICBvcmlnaW5hbFNjYWxlLl9fZml4TWluID0gb3B0LmZpeE1pbjtcbiAgICBvcmlnaW5hbFNjYWxlLl9fZml4TWF4ID0gb3B0LmZpeE1heDtcbiAgfVxufSk7XG56clV0aWwuZWFjaChbJ2NvbnRhaW4nLCAnbm9ybWFsaXplJ10sIGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIExvZ1NjYWxlLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSBtYXRoTG9nKHZhbCkgLyBtYXRoTG9nKHRoaXMuYmFzZSk7XG4gICAgcmV0dXJuIHNjYWxlUHJvdG9bbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCB2YWwpO1xuICB9O1xufSk7XG5cbkxvZ1NjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBMb2dTY2FsZSgpO1xufTtcblxuZnVuY3Rpb24gZml4Um91bmRpbmdFcnJvcih2YWwsIG9yaWdpbmFsVmFsKSB7XG4gIHJldHVybiByb3VuZGluZ0Vycm9yRml4KHZhbCwgZ2V0UHJlY2lzaW9uU2FmZShvcmlnaW5hbFZhbCkpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBMb2dTY2FsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvTG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFJlZ2lvbiA9IHJlcXVpcmUoXCIuL1JlZ2lvblwiKTtcblxuLyoqXG4gKiBQYXJzZSBhbmQgZGVjb2RlIGdlbyBqc29uXG4gKiBAbW9kdWxlIGVjaGFydHMvY29vcmQvZ2VvL3BhcnNlR2VvSnNvblxuICovXG5mdW5jdGlvbiBkZWNvZGUoanNvbikge1xuICBpZiAoIWpzb24uVVRGOEVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICB2YXIgZW5jb2RlU2NhbGUgPSBqc29uLlVURjhTY2FsZTtcblxuICBpZiAoZW5jb2RlU2NhbGUgPT0gbnVsbCkge1xuICAgIGVuY29kZVNjYWxlID0gMTAyNDtcbiAgfVxuXG4gIHZhciBmZWF0dXJlcyA9IGpzb24uZmVhdHVyZXM7XG5cbiAgZm9yICh2YXIgZiA9IDA7IGYgPCBmZWF0dXJlcy5sZW5ndGg7IGYrKykge1xuICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbZl07XG4gICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZW9tZXRyeTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICB2YXIgZW5jb2RlT2Zmc2V0cyA9IGdlb21ldHJ5LmVuY29kZU9mZnNldHM7XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2NdO1xuXG4gICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzW2NdID0gZGVjb2RlUG9seWdvbihjb29yZGluYXRlLCBlbmNvZGVPZmZzZXRzW2NdLCBlbmNvZGVTY2FsZSk7XG4gICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIGZvciAodmFyIGMyID0gMDsgYzIgPCBjb29yZGluYXRlLmxlbmd0aDsgYzIrKykge1xuICAgICAgICAgIHZhciBwb2x5Z29uID0gY29vcmRpbmF0ZVtjMl07XG4gICAgICAgICAgY29vcmRpbmF0ZVtjMl0gPSBkZWNvZGVQb2x5Z29uKHBvbHlnb24sIGVuY29kZU9mZnNldHNbY11bYzJdLCBlbmNvZGVTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSGFzIGJlZW4gZGVjb2RlZFxuXG5cbiAganNvbi5VVEY4RW5jb2RpbmcgPSBmYWxzZTtcbiAgcmV0dXJuIGpzb247XG59XG5cbmZ1bmN0aW9uIGRlY29kZVBvbHlnb24oY29vcmRpbmF0ZSwgZW5jb2RlT2Zmc2V0cywgZW5jb2RlU2NhbGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgcHJldlggPSBlbmNvZGVPZmZzZXRzWzBdO1xuICB2YXIgcHJldlkgPSBlbmNvZGVPZmZzZXRzWzFdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZS5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB4ID0gY29vcmRpbmF0ZS5jaGFyQ29kZUF0KGkpIC0gNjQ7XG4gICAgdmFyIHkgPSBjb29yZGluYXRlLmNoYXJDb2RlQXQoaSArIDEpIC0gNjQ7IC8vIFppZ1phZyBkZWNvZGluZ1xuXG4gICAgeCA9IHggPj4gMSBeIC0oeCAmIDEpO1xuICAgIHkgPSB5ID4+IDEgXiAtKHkgJiAxKTsgLy8gRGVsdGEgZGVvY2RpbmdcblxuICAgIHggKz0gcHJldlg7XG4gICAgeSArPSBwcmV2WTtcbiAgICBwcmV2WCA9IHg7XG4gICAgcHJldlkgPSB5OyAvLyBEZXF1YW50aXplXG5cbiAgICByZXN1bHQucHVzaChbeCAvIGVuY29kZVNjYWxlLCB5IC8gZW5jb2RlU2NhbGVdKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9nZW8vcGFyc2VHZW9Kc29uXG4gKiBAcGFyYW0ge09iamVjdH0gZ2VvSnNvblxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICovXG5cblxuZnVuY3Rpb24gX2RlZmF1bHQoZ2VvSnNvbikge1xuICBkZWNvZGUoZ2VvSnNvbik7XG4gIHJldHVybiB6clV0aWwubWFwKHpyVXRpbC5maWx0ZXIoZ2VvSnNvbi5mZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmVPYmopIHtcbiAgICAvLyBPdXRwdXQgb2YgbWFwc2hhcGVyIG1heSBoYXZlIGdlb21ldHJ5IG51bGxcbiAgICByZXR1cm4gZmVhdHVyZU9iai5nZW9tZXRyeSAmJiBmZWF0dXJlT2JqLnByb3BlcnRpZXMgJiYgZmVhdHVyZU9iai5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggPiAwO1xuICB9KSwgZnVuY3Rpb24gKGZlYXR1cmVPYmopIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IGZlYXR1cmVPYmoucHJvcGVydGllcztcbiAgICB2YXIgZ2VvID0gZmVhdHVyZU9iai5nZW9tZXRyeTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW8uY29vcmRpbmF0ZXM7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBbXTtcblxuICAgIGlmIChnZW8udHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICBnZW9tZXRyaWVzLnB1c2goe1xuICAgICAgICB0eXBlOiAncG9seWdvbicsXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgR2VvSlNPTiBzcGVjaWZpY2F0aW9uLlxuICAgICAgICAvLyBGaXJzdCBtdXN0IGJlIGV4dGVyaW9yLCBhbmQgdGhlIHJlc3QgYXJlIGFsbCBpbnRlcmlvcihob2xlcykuXG4gICAgICAgIGV4dGVyaW9yOiBjb29yZGluYXRlc1swXSxcbiAgICAgICAgaW50ZXJpb3JzOiBjb29yZGluYXRlcy5zbGljZSgxKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGdlby50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgenJVdGlsLmVhY2goY29vcmRpbmF0ZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtWzBdKSB7XG4gICAgICAgICAgZ2VvbWV0cmllcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcbiAgICAgICAgICAgIGV4dGVyaW9yOiBpdGVtWzBdLFxuICAgICAgICAgICAgaW50ZXJpb3JzOiBpdGVtLnNsaWNlKDEpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciByZWdpb24gPSBuZXcgUmVnaW9uKHByb3BlcnRpZXMubmFtZSwgZ2VvbWV0cmllcywgcHJvcGVydGllcy5jcCk7XG4gICAgcmVnaW9uLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgIHJldHVybiByZWdpb247XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9wYXJzZUdlb0pzb24uanNcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBiYm94ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvYmJveFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS92ZWN0b3JcIik7XG5cbnZhciBwb2x5Z29uQ29udGFpbiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluL3BvbHlnb25cIik7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2Nvb3JkL2dlby9SZWdpb25cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBnZW9tZXRyaWVzXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjcFxuICovXG5mdW5jdGlvbiBSZWdpb24obmFtZSwgZ2VvbWV0cmllcywgY3ApIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48QXJyYXk+fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcblxuICBpZiAoIWNwKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIGNwID0gW3JlY3QueCArIHJlY3Qud2lkdGggLyAyLCByZWN0LnkgKyByZWN0LmhlaWdodCAvIDJdO1xuICB9IGVsc2Uge1xuICAgIGNwID0gW2NwWzBdLCBjcFsxXV07XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cblxuICB0aGlzLmNlbnRlciA9IGNwO1xufVxuXG5SZWdpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmVnaW9uLFxuICBwcm9wZXJ0aWVzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcblxuICAgIGlmIChyZWN0KSB7XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICB2YXIgTUFYX05VTUJFUiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIG1pbiA9IFtNQVhfTlVNQkVSLCBNQVhfTlVNQkVSXTtcbiAgICB2YXIgbWF4ID0gWy1NQVhfTlVNQkVSLCAtTUFYX05VTUJFUl07XG4gICAgdmFyIG1pbjIgPSBbXTtcbiAgICB2YXIgbWF4MiA9IFtdO1xuICAgIHZhciBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBPbmx5IHN1cHBvcnQgcG9seWdvblxuICAgICAgaWYgKGdlb21ldHJpZXNbaV0udHlwZSAhPT0gJ3BvbHlnb24nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBEb2Vzbid0IGNvbnNpZGVyIGhvbGVcblxuXG4gICAgICB2YXIgZXh0ZXJpb3IgPSBnZW9tZXRyaWVzW2ldLmV4dGVyaW9yO1xuICAgICAgYmJveC5mcm9tUG9pbnRzKGV4dGVyaW9yLCBtaW4yLCBtYXgyKTtcbiAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgIHZlYzIubWF4KG1heCwgbWF4LCBtYXgyKTtcbiAgICB9IC8vIE5vIGRhdGFcblxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIG1pblswXSA9IG1pblsxXSA9IG1heFswXSA9IG1heFsxXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7PEFycmF5LjxudW1iZXI+fSBjb29yZFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbjogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzO1xuXG4gICAgaWYgKCFyZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxvb3BHZW86IGZvciAodmFyIGkgPSAwLCBsZW4gPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBPbmx5IHN1cHBvcnQgcG9seWdvbi5cbiAgICAgIGlmIChnZW9tZXRyaWVzW2ldLnR5cGUgIT09ICdwb2x5Z29uJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4dGVyaW9yID0gZ2VvbWV0cmllc1tpXS5leHRlcmlvcjtcbiAgICAgIHZhciBpbnRlcmlvcnMgPSBnZW9tZXRyaWVzW2ldLmludGVyaW9ycztcblxuICAgICAgaWYgKHBvbHlnb25Db250YWluLmNvbnRhaW4oZXh0ZXJpb3IsIGNvb3JkWzBdLCBjb29yZFsxXSkpIHtcbiAgICAgICAgLy8gTm90IGluIHRoZSByZWdpb24gaWYgcG9pbnQgaXMgaW4gdGhlIGhvbGUuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgKGludGVyaW9ycyA/IGludGVyaW9ycy5sZW5ndGggOiAwKTsgaysrKSB7XG4gICAgICAgICAgaWYgKHBvbHlnb25Db250YWluLmNvbnRhaW4oaW50ZXJpb3JzW2tdKSkge1xuICAgICAgICAgICAgY29udGludWUgbG9vcEdlbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHRyYW5zZm9ybVRvOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgYXNwZWN0ID0gcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0O1xuXG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgd2lkdGggPSBhc3BlY3QgKiBoZWlnaHQ7XG4gICAgfSBlbHNlIGlmICghaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgdHJhbnNmb3JtID0gcmVjdC5jYWxjdWxhdGVUcmFuc2Zvcm0odGFyZ2V0KTtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IHRoaXMuZ2VvbWV0cmllcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gT25seSBzdXBwb3J0IHBvbHlnb24uXG4gICAgICBpZiAoZ2VvbWV0cmllc1tpXS50eXBlICE9PSAncG9seWdvbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBleHRlcmlvciA9IGdlb21ldHJpZXNbaV0uZXh0ZXJpb3I7XG4gICAgICB2YXIgaW50ZXJpb3JzID0gZ2VvbWV0cmllc1tpXS5pbnRlcmlvcnM7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgZXh0ZXJpb3IubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgdmVjMi5hcHBseVRyYW5zZm9ybShleHRlcmlvcltwXSwgZXh0ZXJpb3JbcF0sIHRyYW5zZm9ybSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgKGludGVyaW9ycyA/IGludGVyaW9ycy5sZW5ndGggOiAwKTsgaCsrKSB7XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgaW50ZXJpb3JzW2hdLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmVjMi5hcHBseVRyYW5zZm9ybShpbnRlcmlvcnNbaF1bcF0sIGludGVyaW9yc1toXVtwXSwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgIHJlY3QuY29weSh0YXJnZXQpOyAvLyBVcGRhdGUgY2VudGVyXG5cbiAgICB0aGlzLmNlbnRlciA9IFtyZWN0LnggKyByZWN0LndpZHRoIC8gMiwgcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyXTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFJlZ2lvbjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL1JlZ2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHdpbmRpbmdMaW5lID0gcmVxdWlyZShcIi4vd2luZGluZ0xpbmVcIik7XG5cbnZhciBFUFNJTE9OID0gMWUtODtcblxuZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xufVxuXG5mdW5jdGlvbiBjb250YWluKHBvaW50cywgeCwgeSkge1xuICB2YXIgdyA9IDA7XG4gIHZhciBwID0gcG9pbnRzWzBdO1xuXG4gIGlmICghcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAyID0gcG9pbnRzW2ldO1xuICAgIHcgKz0gd2luZGluZ0xpbmUocFswXSwgcFsxXSwgcDJbMF0sIHAyWzFdLCB4LCB5KTtcbiAgICBwID0gcDI7XG4gIH0gLy8gQ2xvc2UgcG9seWdvblxuXG5cbiAgdmFyIHAwID0gcG9pbnRzWzBdO1xuXG4gIGlmICghaXNBcm91bmRFcXVhbChwWzBdLCBwMFswXSkgfHwgIWlzQXJvdW5kRXF1YWwocFsxXSwgcDBbMV0pKSB7XG4gICAgdyArPSB3aW5kaW5nTGluZShwWzBdLCBwWzFdLCBwMFswXSwgcDBbMV0sIHgsIHkpO1xuICB9XG5cbiAgcmV0dXJuIHcgIT09IDA7XG59XG5cbmV4cG9ydHMuY29udGFpbiA9IGNvbnRhaW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGJhckxheW91dEdyaWQgPSByZXF1aXJlKFwiLi4vbGF5b3V0L2JhckdyaWRcIik7XG5cbnJlcXVpcmUoXCIuLi9jb29yZC9jYXJ0ZXNpYW4vR3JpZFwiKTtcblxucmVxdWlyZShcIi4vYmFyL0JhclNlcmllc1wiKTtcblxucmVxdWlyZShcIi4vYmFyL0JhclZpZXdcIik7XG5cbnJlcXVpcmUoXCIuLi9jb21wb25lbnQvZ3JpZFNpbXBsZVwiKTtcblxuLy8gSW4gY2FzZSBkZXZlbG9wZXIgZm9yZ2V0IHRvIGluY2x1ZGUgZ3JpZCBjb21wb25lbnRcbmVjaGFydHMucmVnaXN0ZXJMYXlvdXQoenJVdGlsLmN1cnJ5KGJhckxheW91dEdyaWQsICdiYXInKSk7IC8vIFZpc3VhbCBjb2RpbmcgZm9yIGxlZ2VuZFxuXG5lY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnYmFyJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgZGF0YS5zZXRWaXN1YWwoJ2xlZ2VuZFN5bWJvbCcsICdyb3VuZFJlY3QnKTtcbiAgfSk7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuLi91dGlsL251bWJlclwiKTtcblxudmFyIHBhcnNlUGVyY2VudCA9IF9udW1iZXIucGFyc2VQZXJjZW50O1xudmFyIFNUQUNLX1BSRUZJWCA9ICdfX2VjX3N0YWNrXyc7XG5cbmZ1bmN0aW9uIGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpIHtcbiAgcmV0dXJuIHNlcmllc01vZGVsLmdldCgnc3RhY2snKSB8fCBTVEFDS19QUkVGSVggKyBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0tleShheGlzKSB7XG4gIHJldHVybiBheGlzLmRpbSArIGF4aXMuaW5kZXg7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvQXhpc30gb3B0LmF4aXMgT25seSBzdXBwb3J0IGNhdGVnb3J5IGF4aXMgY3VycmVudGx5LlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdC5jb3VudCBQb3NpdGl2ZSBpbnRlcmdlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmJhcldpZHRoXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuYmFyTWF4V2lkdGhdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJHYXBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJDYXRlZ29yeUdhcF1cbiAqIEByZXR1cm4ge09iamVjdH0ge3dpZHRoLCBvZmZzZXQsIG9mZnNldENlbnRlcn0gSWYgYXhpcy50eXBlIGlzIG5vdCAnY2F0ZWdvcnknLCByZXR1cm4gdW5kZWZpbmVkLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGF5b3V0T25BeGlzKG9wdCwgYXBpKSB7XG4gIHZhciBwYXJhbXMgPSBbXTtcbiAgdmFyIGJhc2VBeGlzID0gb3B0LmF4aXM7XG4gIHZhciBheGlzS2V5ID0gJ2F4aXMwJztcblxuICBpZiAoYmFzZUF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBiYW5kV2lkdGggPSBiYXNlQXhpcy5nZXRCYW5kV2lkdGgoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdC5jb3VudCB8fCAwOyBpKyspIHtcbiAgICBwYXJhbXMucHVzaCh6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICBheGlzS2V5OiBheGlzS2V5LFxuICAgICAgc3RhY2tJZDogU1RBQ0tfUFJFRklYICsgaVxuICAgIH0sIG9wdCkpO1xuICB9XG5cbiAgdmFyIHdpZHRoQW5kT2Zmc2V0cyA9IGRvQ2FsQmFyV2lkdGhBbmRPZmZzZXQocGFyYW1zLCBhcGkpO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHQuY291bnQ7IGkrKykge1xuICAgIHZhciBpdGVtID0gd2lkdGhBbmRPZmZzZXRzW2F4aXNLZXldW1NUQUNLX1BSRUZJWCArIGldO1xuICAgIGl0ZW0ub2Zmc2V0Q2VudGVyID0gaXRlbS5vZmZzZXQgKyBpdGVtLndpZHRoIC8gMjtcbiAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNhbEJhcldpZHRoQW5kT2Zmc2V0KGJhclNlcmllcywgYXBpKSB7XG4gIHZhciBzZXJpZXNJbmZvTGlzdCA9IHpyVXRpbC5tYXAoYmFyU2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgYmFzZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgYXhpc0V4dGVudCA9IGJhc2VBeGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBiYW5kV2lkdGggPSBiYXNlQXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gYmFzZUF4aXMuZ2V0QmFuZFdpZHRoKCkgOiBNYXRoLmFicyhheGlzRXh0ZW50WzFdIC0gYXhpc0V4dGVudFswXSkgLyBkYXRhLmNvdW50KCk7XG4gICAgdmFyIGJhcldpZHRoID0gcGFyc2VQZXJjZW50KHNlcmllc01vZGVsLmdldCgnYmFyV2lkdGgnKSwgYmFuZFdpZHRoKTtcbiAgICB2YXIgYmFyTWF4V2lkdGggPSBwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdiYXJNYXhXaWR0aCcpLCBiYW5kV2lkdGgpO1xuICAgIHZhciBiYXJHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2JhckdhcCcpO1xuICAgIHZhciBiYXJDYXRlZ29yeUdhcCA9IHNlcmllc01vZGVsLmdldCgnYmFyQ2F0ZWdvcnlHYXAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICBiYXJNYXhXaWR0aDogYmFyTWF4V2lkdGgsXG4gICAgICBiYXJHYXA6IGJhckdhcCxcbiAgICAgIGJhckNhdGVnb3J5R2FwOiBiYXJDYXRlZ29yeUdhcCxcbiAgICAgIGF4aXNLZXk6IGdldEF4aXNLZXkoYmFzZUF4aXMpLFxuICAgICAgc3RhY2tJZDogZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbClcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGRvQ2FsQmFyV2lkdGhBbmRPZmZzZXQoc2VyaWVzSW5mb0xpc3QsIGFwaSk7XG59XG5cbmZ1bmN0aW9uIGRvQ2FsQmFyV2lkdGhBbmRPZmZzZXQoc2VyaWVzSW5mb0xpc3QsIGFwaSkge1xuICAvLyBDb2x1bW5zIGluZm8gb24gZWFjaCBjYXRlZ29yeSBheGlzLiBLZXkgaXMgY2FydGVzaWFuIG5hbWVcbiAgdmFyIGNvbHVtbnNNYXAgPSB7fTtcbiAgenJVdGlsLmVhY2goc2VyaWVzSW5mb0xpc3QsIGZ1bmN0aW9uIChzZXJpZXNJbmZvLCBpZHgpIHtcbiAgICB2YXIgYXhpc0tleSA9IHNlcmllc0luZm8uYXhpc0tleTtcbiAgICB2YXIgYmFuZFdpZHRoID0gc2VyaWVzSW5mby5iYW5kV2lkdGg7XG4gICAgdmFyIGNvbHVtbnNPbkF4aXMgPSBjb2x1bW5zTWFwW2F4aXNLZXldIHx8IHtcbiAgICAgIGJhbmRXaWR0aDogYmFuZFdpZHRoLFxuICAgICAgcmVtYWluZWRXaWR0aDogYmFuZFdpZHRoLFxuICAgICAgYXV0b1dpZHRoQ291bnQ6IDAsXG4gICAgICBjYXRlZ29yeUdhcDogJzIwJScsXG4gICAgICBnYXA6ICczMCUnLFxuICAgICAgc3RhY2tzOiB7fVxuICAgIH07XG4gICAgdmFyIHN0YWNrcyA9IGNvbHVtbnNPbkF4aXMuc3RhY2tzO1xuICAgIGNvbHVtbnNNYXBbYXhpc0tleV0gPSBjb2x1bW5zT25BeGlzO1xuICAgIHZhciBzdGFja0lkID0gc2VyaWVzSW5mby5zdGFja0lkO1xuXG4gICAgaWYgKCFzdGFja3Nbc3RhY2tJZF0pIHtcbiAgICAgIGNvbHVtbnNPbkF4aXMuYXV0b1dpZHRoQ291bnQrKztcbiAgICB9XG5cbiAgICBzdGFja3Nbc3RhY2tJZF0gPSBzdGFja3Nbc3RhY2tJZF0gfHwge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBtYXhXaWR0aDogMFxuICAgIH07IC8vIENhdXRpb246IEluIGEgc2luZ2xlIGNvb3JkaW5hdGUgc3lzdGVtLCB0aGVzZSBiYXJHcmlkIGF0dHJpYnV0ZXNcbiAgICAvLyB3aWxsIGJlIHNoYXJlZCBieSBzZXJpZXMuIENvbnNpZGVyIHRoYXQgdGhleSBoYXZlIGRlZmF1bHQgdmFsdWVzLFxuICAgIC8vIG9ubHkgdGhlIGF0dHJpYnV0ZXMgc2V0IG9uIHRoZSBsYXN0IHNlcmllcyB3aWxsIHdvcmsuXG4gICAgLy8gRG8gbm90IGNoYW5nZSB0aGlzIGZhY3QgdW5sZXNzIHRoZXJlIHdpbGwgYmUgYSBicmVhayBjaGFuZ2UuXG4gICAgLy8gVE9ET1xuXG4gICAgdmFyIGJhcldpZHRoID0gc2VyaWVzSW5mby5iYXJXaWR0aDtcblxuICAgIGlmIChiYXJXaWR0aCAmJiAhc3RhY2tzW3N0YWNrSWRdLndpZHRoKSB7XG4gICAgICAvLyBTZWUgIzYzMTIsIGRvIG5vdCByZXN0cmljdCB3aWR0aC5cbiAgICAgIHN0YWNrc1tzdGFja0lkXS53aWR0aCA9IGJhcldpZHRoO1xuICAgICAgYmFyV2lkdGggPSBNYXRoLm1pbihjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGgsIGJhcldpZHRoKTtcbiAgICAgIGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aCAtPSBiYXJXaWR0aDtcbiAgICB9XG5cbiAgICB2YXIgYmFyTWF4V2lkdGggPSBzZXJpZXNJbmZvLmJhck1heFdpZHRoO1xuICAgIGJhck1heFdpZHRoICYmIChzdGFja3Nbc3RhY2tJZF0ubWF4V2lkdGggPSBiYXJNYXhXaWR0aCk7XG4gICAgdmFyIGJhckdhcCA9IHNlcmllc0luZm8uYmFyR2FwO1xuICAgIGJhckdhcCAhPSBudWxsICYmIChjb2x1bW5zT25BeGlzLmdhcCA9IGJhckdhcCk7XG4gICAgdmFyIGJhckNhdGVnb3J5R2FwID0gc2VyaWVzSW5mby5iYXJDYXRlZ29yeUdhcDtcbiAgICBiYXJDYXRlZ29yeUdhcCAhPSBudWxsICYmIChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwID0gYmFyQ2F0ZWdvcnlHYXApO1xuICB9KTtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB6clV0aWwuZWFjaChjb2x1bW5zTWFwLCBmdW5jdGlvbiAoY29sdW1uc09uQXhpcywgY29vcmRTeXNOYW1lKSB7XG4gICAgcmVzdWx0W2Nvb3JkU3lzTmFtZV0gPSB7fTtcbiAgICB2YXIgc3RhY2tzID0gY29sdW1uc09uQXhpcy5zdGFja3M7XG4gICAgdmFyIGJhbmRXaWR0aCA9IGNvbHVtbnNPbkF4aXMuYmFuZFdpZHRoO1xuICAgIHZhciBjYXRlZ29yeUdhcCA9IHBhcnNlUGVyY2VudChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwLCBiYW5kV2lkdGgpO1xuICAgIHZhciBiYXJHYXBQZXJjZW50ID0gcGFyc2VQZXJjZW50KGNvbHVtbnNPbkF4aXMuZ2FwLCAxKTtcbiAgICB2YXIgcmVtYWluZWRXaWR0aCA9IGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aDtcbiAgICB2YXIgYXV0b1dpZHRoQ291bnQgPSBjb2x1bW5zT25BeGlzLmF1dG9XaWR0aENvdW50O1xuICAgIHZhciBhdXRvV2lkdGggPSAocmVtYWluZWRXaWR0aCAtIGNhdGVnb3J5R2FwKSAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7XG4gICAgYXV0b1dpZHRoID0gTWF0aC5tYXgoYXV0b1dpZHRoLCAwKTsgLy8gRmluZCBpZiBhbnkgYXV0byBjYWxjdWxhdGVkIGJhciBleGNlZWRlZCBtYXhCYXJXaWR0aFxuXG4gICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBzdGFjaykge1xuICAgICAgdmFyIG1heFdpZHRoID0gY29sdW1uLm1heFdpZHRoO1xuXG4gICAgICBpZiAobWF4V2lkdGggJiYgbWF4V2lkdGggPCBhdXRvV2lkdGgpIHtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCwgcmVtYWluZWRXaWR0aCk7XG5cbiAgICAgICAgaWYgKGNvbHVtbi53aWR0aCkge1xuICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIGNvbHVtbi53aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZW1haW5lZFdpZHRoIC09IG1heFdpZHRoO1xuICAgICAgICBjb2x1bW4ud2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgYXV0b1dpZHRoQ291bnQtLTtcbiAgICAgIH1cbiAgICB9KTsgLy8gUmVjYWxjdWxhdGUgd2lkdGggYWdhaW5cblxuICAgIGF1dG9XaWR0aCA9IChyZW1haW5lZFdpZHRoIC0gY2F0ZWdvcnlHYXApIC8gKGF1dG9XaWR0aENvdW50ICsgKGF1dG9XaWR0aENvdW50IC0gMSkgKiBiYXJHYXBQZXJjZW50KTtcbiAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApO1xuICAgIHZhciB3aWR0aFN1bSA9IDA7XG4gICAgdmFyIGxhc3RDb2x1bW47XG4gICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHtcbiAgICAgIGlmICghY29sdW1uLndpZHRoKSB7XG4gICAgICAgIGNvbHVtbi53aWR0aCA9IGF1dG9XaWR0aDtcbiAgICAgIH1cblxuICAgICAgbGFzdENvbHVtbiA9IGNvbHVtbjtcbiAgICAgIHdpZHRoU3VtICs9IGNvbHVtbi53aWR0aCAqICgxICsgYmFyR2FwUGVyY2VudCk7XG4gICAgfSk7XG5cbiAgICBpZiAobGFzdENvbHVtbikge1xuICAgICAgd2lkdGhTdW0gLT0gbGFzdENvbHVtbi53aWR0aCAqIGJhckdhcFBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldCA9IC13aWR0aFN1bSAvIDI7XG4gICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBzdGFja0lkKSB7XG4gICAgICByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSA9IHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGhcbiAgICAgIH07XG4gICAgICBvZmZzZXQgKz0gY29sdW1uLndpZHRoICogKDEgKyBiYXJHYXBQZXJjZW50KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXJpZXNUeXBlXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICovXG5cblxuZnVuY3Rpb24gYmFyTGF5b3V0R3JpZChzZXJpZXNUeXBlLCBlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGJhcldpZHRoQW5kT2Zmc2V0ID0gY2FsQmFyV2lkdGhBbmRPZmZzZXQoenJVdGlsLmZpbHRlcihlY01vZGVsLmdldFNlcmllc0J5VHlwZShzZXJpZXNUeXBlKSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgcmV0dXJuICFlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gJiYgc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS50eXBlID09PSAnY2FydGVzaWFuMmQnO1xuICB9KSk7XG4gIHZhciBsYXN0U3RhY2tDb29yZHMgPSB7fTtcbiAgdmFyIGxhc3RTdGFja0Nvb3Jkc09yaWdpbiA9IHt9O1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgLy8gQ2hlY2sgc2VyaWVzIGNvb3JkaW5hdGUsIGRvIGxheW91dCBmb3IgY2FydGVzaWFuMmQgb25seVxuICAgIGlmIChzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtLnR5cGUgIT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgYmFzZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgc3RhY2tJZCA9IGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpO1xuICAgIHZhciBjb2x1bW5MYXlvdXRJbmZvID0gYmFyV2lkdGhBbmRPZmZzZXRbZ2V0QXhpc0tleShiYXNlQXhpcyldW3N0YWNrSWRdO1xuICAgIHZhciBjb2x1bW5PZmZzZXQgPSBjb2x1bW5MYXlvdXRJbmZvLm9mZnNldDtcbiAgICB2YXIgY29sdW1uV2lkdGggPSBjb2x1bW5MYXlvdXRJbmZvLndpZHRoO1xuICAgIHZhciB2YWx1ZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgICB2YXIgYmFyTWluSGVpZ2h0ID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJNaW5IZWlnaHQnKSB8fCAwO1xuICAgIHZhciB2YWx1ZUF4aXNTdGFydCA9IGJhc2VBeGlzLm9uWmVybyA/IHZhbHVlQXhpcy50b0dsb2JhbENvb3JkKHZhbHVlQXhpcy5kYXRhVG9Db29yZCgwKSkgOiB2YWx1ZUF4aXMuZ2V0R2xvYmFsRXh0ZW50KClbMF07XG4gICAgdmFyIGNvb3JkRGltcyA9IFtzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbSgneCcpWzBdLCBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbSgneScpWzBdXTtcbiAgICB2YXIgY29vcmRzID0gZGF0YS5tYXBBcnJheShjb29yZERpbXMsIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gY2FydGVzaWFuLmRhdGFUb1BvaW50KFt4LCB5XSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdID0gbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdIHx8IFtdO1xuICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSB8fCBbXTsgLy8gRml4ICM0MjQzXG5cbiAgICBkYXRhLnNldExheW91dCh7XG4gICAgICBvZmZzZXQ6IGNvbHVtbk9mZnNldCxcbiAgICAgIHNpemU6IGNvbHVtbldpZHRoXG4gICAgfSk7XG4gICAgZGF0YS5lYWNoKHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKHZhbHVlQXhpcy5kaW0pWzBdLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF0pIHtcbiAgICAgICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF0gPSB7XG4gICAgICAgICAgcDogdmFsdWVBeGlzU3RhcnQsXG4gICAgICAgICAgLy8gUG9zaXRpdmUgc3RhY2tcbiAgICAgICAgICBuOiB2YWx1ZUF4aXNTdGFydCAvLyBOZWdhdGl2ZSBzdGFja1xuXG4gICAgICAgIH07XG4gICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdID0ge1xuICAgICAgICAgIHA6IHZhbHVlQXhpc1N0YXJ0LFxuICAgICAgICAgIC8vIFBvc2l0aXZlIHN0YWNrXG4gICAgICAgICAgbjogdmFsdWVBeGlzU3RhcnQgLy8gTmVnYXRpdmUgc3RhY2tcblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgc2lnbiA9IHZhbHVlID49IDAgPyAncCcgOiAnbic7XG4gICAgICB2YXIgY29vcmQgPSBjb29yZHNbaWR4XTtcbiAgICAgIHZhciBsYXN0Q29vcmQgPSBsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1baWR4XVtzaWduXTtcbiAgICAgIHZhciBsYXN0Q29vcmRPcmlnaW4gPSBsYXN0U3RhY2tDb29yZHNPcmlnaW5bc3RhY2tJZF1baWR4XVtzaWduXTtcbiAgICAgIHZhciB4O1xuICAgICAgdmFyIHk7XG4gICAgICB2YXIgd2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0O1xuXG4gICAgICBpZiAodmFsdWVBeGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHggPSBsYXN0Q29vcmQ7XG4gICAgICAgIHkgPSBjb29yZFsxXSArIGNvbHVtbk9mZnNldDtcbiAgICAgICAgd2lkdGggPSBjb29yZFswXSAtIGxhc3RDb29yZE9yaWdpbjtcbiAgICAgICAgaGVpZ2h0ID0gY29sdW1uV2lkdGg7XG4gICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dICs9IHdpZHRoO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyh3aWR0aCkgPCBiYXJNaW5IZWlnaHQpIHtcbiAgICAgICAgICB3aWR0aCA9ICh3aWR0aCA8IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF1bc2lnbl0gKz0gd2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gY29vcmRbMF0gKyBjb2x1bW5PZmZzZXQ7XG4gICAgICAgIHkgPSBsYXN0Q29vcmQ7XG4gICAgICAgIHdpZHRoID0gY29sdW1uV2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGNvb3JkWzFdIC0gbGFzdENvb3JkT3JpZ2luO1xuICAgICAgICBsYXN0U3RhY2tDb29yZHNPcmlnaW5bc3RhY2tJZF1baWR4XVtzaWduXSArPSBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCkgPCBiYXJNaW5IZWlnaHQpIHtcbiAgICAgICAgICAvLyBJbmNsdWRlIHplcm8gdG8gaGFzIGEgcG9zaXRpdmUgYmFyXG4gICAgICAgICAgaGVpZ2h0ID0gKGhlaWdodCA8PSAwID8gLTEgOiAxKSAqIGJhck1pbkhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dICs9IGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9LCB0cnVlKTtcbiAgfSwgdGhpcyk7XG59XG5cbmJhckxheW91dEdyaWQuZ2V0TGF5b3V0T25BeGlzID0gZ2V0TGF5b3V0T25BeGlzO1xudmFyIF9kZWZhdWx0ID0gYmFyTGF5b3V0R3JpZDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L2JhckdyaWQuanNcbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgQ2FydGVzaWFuID0gcmVxdWlyZShcIi4vQ2FydGVzaWFuXCIpO1xuXG5mdW5jdGlvbiBDYXJ0ZXNpYW4yRChuYW1lKSB7XG4gIENhcnRlc2lhbi5jYWxsKHRoaXMsIG5hbWUpO1xufVxuXG5DYXJ0ZXNpYW4yRC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBDYXJ0ZXNpYW4yRCxcbiAgdHlwZTogJ2NhcnRlc2lhbjJkJyxcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGRpbWVuc2lvbnM6IFsneCcsICd5J10sXG5cbiAgLyoqXG4gICAqIEJhc2UgYXhpcyB3aWxsIGJlIHVzZWQgb24gc3RhY2tpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9XG4gICAqL1xuICBnZXRCYXNlQXhpczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF0gfHwgdGhpcy5nZXRBeGVzQnlTY2FsZSgndGltZScpWzBdIHx8IHRoaXMuZ2V0QXhpcygneCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBjb250YWluIHBvaW50XG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBheGlzWCA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgIHZhciBheGlzWSA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgIHJldHVybiBheGlzWC5jb250YWluKGF4aXNYLnRvTG9jYWxDb29yZChwb2ludFswXSkpICYmIGF4aXNZLmNvbnRhaW4oYXhpc1kudG9Mb2NhbENvb3JkKHBvaW50WzFdKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGNvbnRhaW4gZGF0YVxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGlzKCd4JykuY29udGFpbkRhdGEoZGF0YVswXSkgJiYgdGhpcy5nZXRBeGlzKCd5JykuY29udGFpbkRhdGEoZGF0YVsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGFcbiAgICogQHBhcmFtIHtib29sZWFufSBbY2xhbXA9ZmFsc2VdXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZGF0YVRvUG9pbnQ6IGZ1bmN0aW9uIChkYXRhLCBjbGFtcCkge1xuICAgIHZhciB4QXhpcyA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgIHJldHVybiBbeEF4aXMudG9HbG9iYWxDb29yZCh4QXhpcy5kYXRhVG9Db29yZChkYXRhWzBdLCBjbGFtcCkpLCB5QXhpcy50b0dsb2JhbENvb3JkKHlBeGlzLmRhdGFUb0Nvb3JkKGRhdGFbMV0sIGNsYW1wKSldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGFtcD1mYWxzZV1cbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBwb2ludFRvRGF0YTogZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgIHZhciB4QXhpcyA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgIHJldHVybiBbeEF4aXMuY29vcmRUb0RhdGEoeEF4aXMudG9Mb2NhbENvb3JkKHBvaW50WzBdKSwgY2xhbXApLCB5QXhpcy5jb29yZFRvRGF0YSh5QXhpcy50b0xvY2FsQ29vcmQocG9pbnRbMV0pLCBjbGFtcCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgb3RoZXIgYXhpc1xuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9IGF4aXNcbiAgICovXG4gIGdldE90aGVyQXhpczogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGlzKGF4aXMuZGltID09PSAneCcgPyAneScgOiAneCcpO1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKENhcnRlc2lhbjJELCBDYXJ0ZXNpYW4pO1xudmFyIF9kZWZhdWx0ID0gQ2FydGVzaWFuMkQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qc1xuLy8gbW9kdWxlIGlkID0gMjQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbi8qKlxuICogQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtXG4gKiBAbW9kdWxlICBlY2hhcnRzL2Nvb3JkL0NhcnRlc2lhblxuICpcbiAqL1xuZnVuY3Rpb24gZGltQXhpc01hcHBlcihkaW0pIHtcbiAgcmV0dXJuIHRoaXMuX2F4ZXNbZGltXTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhblxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgQ2FydGVzaWFuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdGhpcy5fYXhlcyA9IHt9O1xuICB0aGlzLl9kaW1MaXN0ID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLm5hbWUgPSBuYW1lIHx8ICcnO1xufTtcblxuQ2FydGVzaWFuLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IENhcnRlc2lhbixcbiAgdHlwZTogJ2NhcnRlc2lhbicsXG5cbiAgLyoqXG4gICAqIEdldCBheGlzXG4gICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IGRpbVxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5+QXhpc31cbiAgICovXG4gIGdldEF4aXM6IGZ1bmN0aW9uIChkaW0pIHtcbiAgICByZXR1cm4gdGhpcy5fYXhlc1tkaW1dO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYXhlcyBsaXN0XG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5+QXhpcz59XG4gICAqL1xuICBnZXRBeGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5tYXAodGhpcy5fZGltTGlzdCwgZGltQXhpc01hcHBlciwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBheGVzIGxpc3QgYnkgZ2l2ZW4gc2NhbGUgdHlwZVxuICAgKi9cbiAgZ2V0QXhlc0J5U2NhbGU6IGZ1bmN0aW9uIChzY2FsZVR5cGUpIHtcbiAgICBzY2FsZVR5cGUgPSBzY2FsZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4genJVdGlsLmZpbHRlcih0aGlzLmdldEF4ZXMoKSwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgIHJldHVybiBheGlzLnNjYWxlLnR5cGUgPT09IHNjYWxlVHlwZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGF4aXNcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW4uQXhpc31cbiAgICovXG4gIGFkZEF4aXM6IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgdmFyIGRpbSA9IGF4aXMuZGltO1xuICAgIHRoaXMuX2F4ZXNbZGltXSA9IGF4aXM7XG5cbiAgICB0aGlzLl9kaW1MaXN0LnB1c2goZGltKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBkYXRhIHRvIGNvb3JkIGluIG5kIHNwYWNlXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHZhbFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAgICovXG4gIGRhdGFUb0Nvb3JkOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFDb29yZENvbnZlcnQodmFsLCAnZGF0YVRvQ29vcmQnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBjb29yZCBpbiBuZCBzcGFjZSB0byBkYXRhXG4gICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fE9iamVjdC48c3RyaW5nLCBudW1iZXI+fSB2YWxcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gICAqL1xuICBjb29yZFRvRGF0YTogZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhQ29vcmRDb252ZXJ0KHZhbCwgJ2Nvb3JkVG9EYXRhJyk7XG4gIH0sXG4gIF9kYXRhQ29vcmRDb252ZXJ0OiBmdW5jdGlvbiAoaW5wdXQsIG1ldGhvZCkge1xuICAgIHZhciBkaW1MaXN0ID0gdGhpcy5fZGltTGlzdDtcbiAgICB2YXIgb3V0cHV0ID0gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaW0gPSBkaW1MaXN0W2ldO1xuICAgICAgdmFyIGF4aXMgPSB0aGlzLl9heGVzW2RpbV07XG4gICAgICBvdXRwdXRbZGltXSA9IGF4aXNbbWV0aG9kXShpbnB1dFtkaW1dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQ2FydGVzaWFuO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIEF4aXMgPSByZXF1aXJlKFwiLi4vQXhpc1wiKTtcblxuLyoqXG4gKiBFeHRlbmQgYXhpcyAyZFxuICogQGNvbnN0cnVjdG9yIG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkRcbiAqIEBleHRlbmRzIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc31cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAqIEBwYXJhbSB7Kn0gc2NhbGVcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGNvb3JkRXh0ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpc1R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvblxuICovXG52YXIgQXhpczJEID0gZnVuY3Rpb24gKGRpbSwgc2NhbGUsIGNvb3JkRXh0ZW50LCBheGlzVHlwZSwgcG9zaXRpb24pIHtcbiAgQXhpcy5jYWxsKHRoaXMsIGRpbSwgc2NhbGUsIGNvb3JkRXh0ZW50KTtcbiAgLyoqXG4gICAqIEF4aXMgdHlwZVxuICAgKiAgLSAnY2F0ZWdvcnknXG4gICAqICAtICd2YWx1ZSdcbiAgICogIC0gJ3RpbWUnXG4gICAqICAtICdsb2cnXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMudHlwZSA9IGF4aXNUeXBlIHx8ICd2YWx1ZSc7XG4gIC8qKlxuICAgKiBBeGlzIHBvc2l0aW9uXG4gICAqICAtICd0b3AnXG4gICAqICAtICdib3R0b20nXG4gICAqICAtICdsZWZ0J1xuICAgKiAgLSAncmlnaHQnXG4gICAqL1xuXG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnYm90dG9tJztcbn07XG5cbkF4aXMyRC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBeGlzMkQsXG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIGF4aXMsIGNhbiBiZSB1c2VkIGFzIGtleVxuICAgKi9cbiAgaW5kZXg6IDAsXG5cbiAgLyoqXG4gICAqIElmIGF4aXMgaXMgb24gdGhlIHplcm8gcG9zaXRpb24gb2YgdGhlIG90aGVyIGF4aXNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBvblplcm86IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBBeGlzIG1vZGVsXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH1cbiAgICovXG4gIG1vZGVsOiBudWxsLFxuICBpc0hvcml6b250YWw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFYWNoIGl0ZW0gY29vcmVzcG9uZHMgdG8gdGhpcy5nZXRFeHRlbnQoKSwgd2hpY2hcbiAgICogbWVhbnMgZ2xvYmFsRXh0ZW50WzBdIG1heSBncmVhdGVyIHRoYW4gZ2xvYmFsRXh0ZW50WzFdLFxuICAgKiB1bmxlc3MgYGFzY2AgaXMgaW5wdXQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzY11cbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBnZXRHbG9iYWxFeHRlbnQ6IGZ1bmN0aW9uIChhc2MpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICByZXRbMF0gPSB0aGlzLnRvR2xvYmFsQ29vcmQocmV0WzBdKTtcbiAgICByZXRbMV0gPSB0aGlzLnRvR2xvYmFsQ29vcmQocmV0WzFdKTtcbiAgICBhc2MgJiYgcmV0WzBdID4gcmV0WzFdICYmIHJldC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgZ2V0T3RoZXJBeGlzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncmlkLmdldE90aGVyQXhpcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBsYWJlbCBpcyBpZ25vcmVkLlxuICAgKiBBdXRvbWF0aWNhbGx5IHVzZWQgd2hlbiBheGlzIGlzIGNhdGVnb3J5IGFuZCBsYWJlbCBjYW4gbm90IGJlIGFsbCBzaG93blxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBpZHhcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzTGFiZWxJZ25vcmVkOiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgdmFyIGxhYmVsSW50ZXJ2YWwgPSB0aGlzLmdldExhYmVsSW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybiB0eXBlb2YgbGFiZWxJbnRlcnZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhbGFiZWxJbnRlcnZhbChpZHgsIHRoaXMuc2NhbGUuZ2V0TGFiZWwoaWR4KSkgfHwgaWR4ICUgKGxhYmVsSW50ZXJ2YWwgKyAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcG9pbnRUb0RhdGE6IGZ1bmN0aW9uIChwb2ludCwgY2xhbXApIHtcbiAgICByZXR1cm4gdGhpcy5jb29yZFRvRGF0YSh0aGlzLnRvTG9jYWxDb29yZChwb2ludFt0aGlzLmRpbSA9PT0gJ3gnID8gMCA6IDFdKSwgY2xhbXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gZ2xvYmFsIGNvb3JkIHRvIGxvY2FsIGNvb3JkLFxuICAgKiBpLmUuIHZhciBsb2NhbENvb3JkID0gYXhpcy50b0xvY2FsQ29vcmQoODApO1xuICAgKiBkZXNpZ25hdGUgYnkgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWQuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHRvTG9jYWxDb29yZDogbnVsbCxcblxuICAvKipcbiAgICogVHJhbnNmb3JtIGdsb2JhbCBjb29yZCB0byBsb2NhbCBjb29yZCxcbiAgICogaS5lLiB2YXIgZ2xvYmFsQ29vcmQgPSBheGlzLnRvTG9jYWxDb29yZCg0MCk7XG4gICAqIGRlc2lnbmF0ZSBieSBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZC5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgdG9HbG9iYWxDb29yZDogbnVsbFxufTtcbnpyVXRpbC5pbmhlcml0cyhBeGlzMkQsIEF4aXMpO1xudmFyIF9kZWZhdWx0ID0gQXhpczJEO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQXhpczJELmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKFwiLi9BeGlzTW9kZWxcIik7XG5cbnZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Db21wb25lbnRcIik7XG5cbi8vIEdyaWQg5piv5Zyo5pyJ55u06KeS5Z2Q5qCH57O755qE5pe25YCZ5b+F6aG76KaB5a2Y5Zyo55qEXG4vLyDmiYDku6Xov5nph4zkuZ/opoHooqsgQ2FydGVzaWFuMkQg5L6d6LWWXG52YXIgX2RlZmF1bHQgPSBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnZ3JpZCcsXG4gIGRlcGVuZGVuY2llczogWyd4QXhpcycsICd5QXhpcyddLFxuICBsYXlvdXRNb2RlOiAnYm94JyxcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkfVxuICAgKi9cbiAgY29vcmRpbmF0ZVN5c3RlbTogbnVsbCxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIHNob3c6IGZhbHNlLFxuICAgIHpsZXZlbDogMCxcbiAgICB6OiAwLFxuICAgIGxlZnQ6ICcxMCUnLFxuICAgIHRvcDogNjAsXG4gICAgcmlnaHQ6ICcxMCUnLFxuICAgIGJvdHRvbTogNjAsXG4gICAgLy8gSWYgZ3JpZCBzaXplIGNvbnRhaW4gbGFiZWxcbiAgICBjb250YWluTGFiZWw6IGZhbHNlLFxuICAgIC8vIHdpZHRoOiB7dG90YWxXaWR0aH0gLSBsZWZ0IC0gcmlnaHQsXG4gICAgLy8gaGVpZ2h0OiB7dG90YWxIZWlnaHR9IC0gdG9wIC0gYm90dG9tLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAxLFxuICAgIGJvcmRlckNvbG9yOiAnI2NjYydcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBheGlzRGVmYXVsdCA9IHJlcXVpcmUoXCIuL2F4aXNEZWZhdWx0XCIpO1xuXG52YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKFwiLi4vbW9kZWwvQ29tcG9uZW50XCIpO1xuXG52YXIgX2xheW91dCA9IHJlcXVpcmUoXCIuLi91dGlsL2xheW91dFwiKTtcblxudmFyIGdldExheW91dFBhcmFtcyA9IF9sYXlvdXQuZ2V0TGF5b3V0UGFyYW1zO1xudmFyIG1lcmdlTGF5b3V0UGFyYW0gPSBfbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW07XG4vLyBGSVhNRSBheGlzVHlwZSBpcyBmaXhlZCA/XG52YXIgQVhJU19UWVBFUyA9IFsndmFsdWUnLCAnY2F0ZWdvcnknLCAndGltZScsICdsb2cnXTtcbi8qKlxuICogR2VuZXJhdGUgc3ViIGF4aXMgbW9kZWwgY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzTmFtZSAneCcgJ3knICdyYWRpdXMnICdhbmdsZScgJ3BhcmFsbGVsJ1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IEJhc2VBeGlzTW9kZWxDbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gYXhpc1R5cGVEZWZhdWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFEZWZhdWx0T3B0aW9uXVxuICovXG5cbmZ1bmN0aW9uIF9kZWZhdWx0KGF4aXNOYW1lLCBCYXNlQXhpc01vZGVsQ2xhc3MsIGF4aXNUeXBlRGVmYXVsdGVyLCBleHRyYURlZmF1bHRPcHRpb24pIHtcbiAgenJVdGlsLmVhY2goQVhJU19UWVBFUywgZnVuY3Rpb24gKGF4aXNUeXBlKSB7XG4gICAgQmFzZUF4aXNNb2RlbENsYXNzLmV4dGVuZCh7XG4gICAgICB0eXBlOiBheGlzTmFtZSArICdBeGlzLicgKyBheGlzVHlwZSxcbiAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGUgPyBnZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9O1xuICAgICAgICB2YXIgdGhlbWVNb2RlbCA9IGVjTW9kZWwuZ2V0VGhlbWUoKTtcbiAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhlbWVNb2RlbC5nZXQoYXhpc1R5cGUgKyAnQXhpcycpKTtcbiAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpO1xuICAgICAgICBvcHRpb24udHlwZSA9IGF4aXNUeXBlRGVmYXVsdGVyKGF4aXNOYW1lLCBvcHRpb24pO1xuXG4gICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgbWVyZ2VMYXlvdXRQYXJhbShvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMsIGxheW91dE1vZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVmYXVsdE9wdGlvbjogenJVdGlsLm1lcmdlQWxsKFt7fSwgYXhpc0RlZmF1bHRbYXhpc1R5cGUgKyAnQXhpcyddLCBleHRyYURlZmF1bHRPcHRpb25dLCB0cnVlKVxuICAgIH0pO1xuICB9KTtcbiAgQ29tcG9uZW50TW9kZWwucmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyKGF4aXNOYW1lICsgJ0F4aXMnLCB6clV0aWwuY3VycnkoYXhpc1R5cGVEZWZhdWx0ZXIsIGF4aXNOYW1lKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc01vZGVsQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBkZWZhdWx0T3B0aW9uID0ge1xuICBzaG93OiB0cnVlLFxuICB6bGV2ZWw6IDAsXG4gIC8vIOS4gOe6p+WxguWPoFxuICB6OiAwLFxuICAvLyDkuoznuqflsYLlj6BcbiAgLy8g5Y+N5ZCR5Z2Q5qCH6L20XG4gIGludmVyc2U6IGZhbHNlLFxuICAvLyDlnZDmoIfovbTlkI3lrZfvvIzpu5jorqTkuLrnqbpcbiAgbmFtZTogJycsXG4gIC8vIOWdkOagh+i9tOWQjeWtl+S9jee9ru+8jOaUr+aMgSdzdGFydCcgfCAnbWlkZGxlJyB8ICdlbmQnXG4gIG5hbWVMb2NhdGlvbjogJ2VuZCcsXG4gIC8vIOWdkOagh+i9tOWQjeWtl+aXi+i9rO+8jGRlZ3JlZeOAglxuICBuYW1lUm90YXRlOiBudWxsLFxuICAvLyBBZGFwdCB0byBheGlzIHJvdGF0ZSwgd2hlbiBuYW1lTG9jYXRpb24gaXMgJ21pZGRsZScuXG4gIG5hbWVUcnVuY2F0ZToge1xuICAgIG1heFdpZHRoOiBudWxsLFxuICAgIGVsbGlwc2lzOiAnLi4uJyxcbiAgICBwbGFjZWhvbGRlcjogJy4nXG4gIH0sXG4gIC8vIOWdkOagh+i9tOaWh+Wtl+agt+W8j++8jOm7mOiupOWPluWFqOWxgOagt+W8j1xuICBuYW1lVGV4dFN0eWxlOiB7fSxcbiAgLy8g5paH5a2X5LiO6L2057q/6Led56a7XG4gIG5hbWVHYXA6IDE1LFxuICBzaWxlbnQ6IGZhbHNlLFxuICAvLyBEZWZhdWx0IGZhbHNlIHRvIHN1cHBvcnQgdG9vbHRpcC5cbiAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgLy8gRGVmYXVsdCBmYWxzZSB0byBhdm9pZCBsZWdhY3kgdXNlciBldmVudCBsaXN0ZW5lciBmYWlsLlxuICB0b29sdGlwOiB7XG4gICAgc2hvdzogZmFsc2VcbiAgfSxcbiAgYXhpc1BvaW50ZXI6IHt9LFxuICAvLyDlnZDmoIfovbTnur9cbiAgYXhpc0xpbmU6IHtcbiAgICAvLyDpu5jorqTmmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgc2hvdzogdHJ1ZSxcbiAgICBvblplcm86IHRydWUsXG4gICAgb25aZXJvQXhpc0luZGV4OiBudWxsLFxuICAgIC8vIOWxnuaAp2xpbmVTdHlsZeaOp+WItue6v+adoeagt+W8j1xuICAgIGxpbmVTdHlsZToge1xuICAgICAgY29sb3I6ICcjMzMzJyxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgIH0sXG4gICAgLy8g5Z2Q5qCH6L205Lik56uv55qE566t5aS0XG4gICAgc3ltYm9sOiBbJ25vbmUnLCAnbm9uZSddLFxuICAgIHN5bWJvbFNpemU6IFsxMCwgMTVdXG4gIH0sXG4gIC8vIOWdkOagh+i9tOWwj+agh+iusFxuICBheGlzVGljazoge1xuICAgIC8vIOWxnuaAp3Nob3fmjqfliLbmmL7npLrkuI7lkKbvvIzpu5jorqTmmL7npLpcbiAgICBzaG93OiB0cnVlLFxuICAgIC8vIOaOp+WItuWwj+agh+iusOaYr+WQpuWcqGdyaWTph4xcbiAgICBpbnNpZGU6IGZhbHNlLFxuICAgIC8vIOWxnuaAp2xlbmd0aOaOp+WItue6v+mVv1xuICAgIGxlbmd0aDogNSxcbiAgICAvLyDlsZ7mgKdsaW5lU3R5bGXmjqfliLbnur/mnaHmoLflvI9cbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIHdpZHRoOiAxXG4gICAgfVxuICB9LFxuICAvLyDlnZDmoIfovbTmlofmnKzmoIfnrb7vvIzor6bop4FheGlzLmF4aXNMYWJlbFxuICBheGlzTGFiZWw6IHtcbiAgICBzaG93OiB0cnVlLFxuICAgIC8vIOaOp+WItuaWh+acrOagh+etvuaYr+WQpuWcqGdyaWTph4xcbiAgICBpbnNpZGU6IGZhbHNlLFxuICAgIHJvdGF0ZTogMCxcbiAgICBzaG93TWluTGFiZWw6IG51bGwsXG4gICAgLy8gdHJ1ZSB8IGZhbHNlIHwgbnVsbCAoYXV0bylcbiAgICBzaG93TWF4TGFiZWw6IG51bGwsXG4gICAgLy8gdHJ1ZSB8IGZhbHNlIHwgbnVsbCAoYXV0bylcbiAgICBtYXJnaW46IDgsXG4gICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgIC8vIOWFtuS9meWxnuaAp+m7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgIGZvbnRTaXplOiAxMlxuICB9LFxuICAvLyDliIbpmpTnur9cbiAgc3BsaXRMaW5lOiB7XG4gICAgLy8g6buY6K6k5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgIHNob3c6IHRydWUsXG4gICAgLy8g5bGe5oCnbGluZVN0eWxl77yI6K+m6KeBbGluZVN0eWxl77yJ5o6n5Yi257q/5p2h5qC35byPXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBjb2xvcjogWycjY2NjJ10sXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICB9XG4gIH0sXG4gIC8vIOWIhumalOWMuuWfn1xuICBzcGxpdEFyZWE6IHtcbiAgICAvLyDpu5jorqTkuI3mmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgc2hvdzogZmFsc2UsXG4gICAgLy8g5bGe5oCnYXJlYVN0eWxl77yI6K+m6KeBYXJlYVN0eWxl77yJ5o6n5Yi25Yy65Z+f5qC35byPXG4gICAgYXJlYVN0eWxlOiB7XG4gICAgICBjb2xvcjogWydyZ2JhKDI1MCwyNTAsMjUwLDAuMyknLCAncmdiYSgyMDAsMjAwLDIwMCwwLjMpJ11cbiAgICB9XG4gIH1cbn07XG52YXIgYXhpc0RlZmF1bHQgPSB7fTtcbmF4aXNEZWZhdWx0LmNhdGVnb3J5QXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gIC8vIOexu+ebrui1t+Wni+WSjOe7k+adn+S4pOerr+epuueZveetlueVpVxuICBib3VuZGFyeUdhcDogdHJ1ZSxcbiAgLy8gc3BsaXRBcmVhOiB7XG4gIC8vIHNob3c6IGZhbHNlXG4gIC8vIH0sXG4gIHNwbGl0TGluZToge1xuICAgIHNob3c6IGZhbHNlXG4gIH0sXG4gIC8vIOWdkOagh+i9tOWwj+agh+iusFxuICBheGlzVGljazoge1xuICAgIC8vIElmIHRpY2sgaXMgYWxpZ24gd2l0aCBsYWJlbCB3aGVuIGJvdW5kYXJ5R2FwIGlzIHRydWVcbiAgICBhbGlnbldpdGhMYWJlbDogZmFsc2UsXG4gICAgaW50ZXJ2YWw6ICdhdXRvJ1xuICB9LFxuICAvLyDlnZDmoIfovbTmlofmnKzmoIfnrb7vvIzor6bop4FheGlzLmF4aXNMYWJlbFxuICBheGlzTGFiZWw6IHtcbiAgICBpbnRlcnZhbDogJ2F1dG8nXG4gIH1cbn0sIGRlZmF1bHRPcHRpb24pO1xuYXhpc0RlZmF1bHQudmFsdWVBeGlzID0genJVdGlsLm1lcmdlKHtcbiAgLy8g5pWw5YC86LW35aeL5ZKM57uT5p2f5Lik56uv56m655m9562W55WlXG4gIGJvdW5kYXJ5R2FwOiBbMCwgMF0sXG4gIC8vIOacgOWwj+WAvCwg6K6+572u5oiQICdkYXRhTWluJyDliJnku47mlbDmja7kuK3orqHnrpfmnIDlsI/lgLxcbiAgLy8gbWluOiBudWxsLFxuICAvLyDmnIDlpKflgLzvvIzorr7nva7miJAgJ2RhdGFNYXgnIOWImeS7juaVsOaNruS4reiuoeeul+acgOWkp+WAvFxuICAvLyBtYXg6IG51bGwsXG4gIC8vIFJlYWRvbmx5IHByb3AsIHNwZWNpZmllcyBzdGFydCB2YWx1ZSBvZiB0aGUgcmFuZ2Ugd2hlbiB1c2luZyBkYXRhIHpvb20uXG4gIC8vIHJhbmdlU3RhcnQ6IG51bGxcbiAgLy8gUmVhZG9ubHkgcHJvcCwgc3BlY2lmaWVzIGVuZCB2YWx1ZSBvZiB0aGUgcmFuZ2Ugd2hlbiB1c2luZyBkYXRhIHpvb20uXG4gIC8vIHJhbmdlRW5kOiBudWxsXG4gIC8vIOiEseemuzDlgLzmr5TkvovvvIzmlL7lpKfogZrnhKbliLDmnIDnu4hfbWlu77yMX21heOWMuumXtFxuICAvLyBzY2FsZTogZmFsc2UsXG4gIC8vIOWIhuWJsuauteaVsO+8jOm7mOiupOS4ujVcbiAgc3BsaXROdW1iZXI6IDUgLy8gTWluaW11bSBpbnRlcnZhbFxuICAvLyBtaW5JbnRlcnZhbDogbnVsbFxuICAvLyBtYXhJbnRlcnZhbDogbnVsbFxuXG59LCBkZWZhdWx0T3B0aW9uKTsgLy8gRklYTUVcblxuYXhpc0RlZmF1bHQudGltZUF4aXMgPSB6clV0aWwuZGVmYXVsdHMoe1xuICBzY2FsZTogdHJ1ZSxcbiAgbWluOiAnZGF0YU1pbicsXG4gIG1heDogJ2RhdGFNYXgnXG59LCBheGlzRGVmYXVsdC52YWx1ZUF4aXMpO1xuYXhpc0RlZmF1bHQubG9nQXhpcyA9IHpyVXRpbC5kZWZhdWx0cyh7XG4gIHNjYWxlOiB0cnVlLFxuICBsb2dCYXNlOiAxMFxufSwgYXhpc0RlZmF1bHQudmFsdWVBeGlzKTtcbnZhciBfZGVmYXVsdCA9IGF4aXNEZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzRGVmYXVsdC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEJhc2VCYXJTZXJpZXMgPSByZXF1aXJlKFwiLi9CYXNlQmFyU2VyaWVzXCIpO1xuXG52YXIgX2RlZmF1bHQgPSBCYXNlQmFyU2VyaWVzLmV4dGVuZCh7XG4gIHR5cGU6ICdzZXJpZXMuYmFyJyxcbiAgZGVwZW5kZW5jaWVzOiBbJ2dyaWQnLCAncG9sYXInXSxcbiAgYnJ1c2hTZWxlY3RvcjogJ3JlY3QnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFyU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgU2VyaWVzTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvU2VyaWVzXCIpO1xuXG52YXIgY3JlYXRlTGlzdEZyb21BcnJheSA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheVwiKTtcblxudmFyIF9kZWZhdWx0ID0gU2VyaWVzTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ3Nlcmllcy5fX2Jhc2VfYmFyX18nLFxuICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHJldHVybiBjcmVhdGVMaXN0RnJvbUFycmF5KG9wdGlvbi5kYXRhLCB0aGlzLCBlY01vZGVsKTtcbiAgfSxcbiAgZ2V0TWFya2VyUG9zaXRpb246IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgIGlmIChjb29yZFN5cykge1xuICAgICAgLy8gUEVORElORyBpZiBjbGFtcCA/XG4gICAgICB2YXIgcHQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgdmFyIG9mZnNldCA9IGRhdGEuZ2V0TGF5b3V0KCdvZmZzZXQnKTtcbiAgICAgIHZhciBzaXplID0gZGF0YS5nZXRMYXlvdXQoJ3NpemUnKTtcbiAgICAgIHZhciBvZmZzZXRJbmRleCA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCkgPyAwIDogMTtcbiAgICAgIHB0W29mZnNldEluZGV4XSArPSBvZmZzZXQgKyBzaXplIC8gMjtcbiAgICAgIHJldHVybiBwdDtcbiAgICB9XG5cbiAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuIDnuqflsYLlj6BcbiAgICB6OiAyLFxuICAgIC8vIOS6jOe6p+WxguWPoFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIC8vIHN0YWNrOiBudWxsXG4gICAgLy8gQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAvLyB5QXhpc0luZGV4OiAwLFxuICAgIC8vIOacgOWwj+mrmOW6puaUueS4ujBcbiAgICBiYXJNaW5IZWlnaHQ6IDAsXG4gICAgLy8g5pyA5bCP6KeS5bqm5Li6MO+8jOS7heWvueaegeWdkOagh+ezu+S4i+eahOafseeKtuWbvuacieaViFxuICAgIGJhck1pbkFuZ2xlOiAwLFxuICAgIC8vIGN1cnNvcjogbnVsbCxcbiAgICAvLyBiYXJNYXhXaWR0aDogbnVsbCxcbiAgICAvLyDpu5jorqToh6rpgILlupRcbiAgICAvLyBiYXJXaWR0aDogbnVsbCxcbiAgICAvLyDmn7Hpl7Tot53nprvvvIzpu5jorqTkuLrmn7HlvaLlrr3luqbnmoQzMCXvvIzlj6/orr7lm7rlrprlgLxcbiAgICAvLyBiYXJHYXA6ICczMCUnLFxuICAgIC8vIOexu+ebrumXtOafseW9oui3neemu++8jOm7mOiupOS4uuexu+ebrumXtOi3neeahDIwJe+8jOWPr+iuvuWbuuWumuWAvFxuICAgIC8vIGJhckNhdGVnb3J5R2FwOiAnMjAlJyxcbiAgICAvLyBsYWJlbDoge1xuICAgIC8vICAgICBub3JtYWw6IHtcbiAgICAvLyAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgLy8gICAgIH1cbiAgICAvLyB9LFxuICAgIGl0ZW1TdHlsZTogey8vIG5vcm1hbDoge1xuICAgICAgLy8gY29sb3I6ICflkITlvIInXG4gICAgICAvLyB9LFxuICAgICAgLy8gZW1waGFzaXM6IHt9XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFzZUJhclNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMjQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIF9oZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5cbnZhciBzZXRMYWJlbCA9IF9oZWxwZXIuc2V0TGFiZWw7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIGJhckl0ZW1TdHlsZSA9IHJlcXVpcmUoXCIuL2Jhckl0ZW1TdHlsZVwiKTtcblxudmFyIEJBUl9CT1JERVJfV0lEVEhfUVVFUlkgPSBbJ2l0ZW1TdHlsZScsICdub3JtYWwnLCAnYmFyQm9yZGVyV2lkdGgnXTsgLy8gRklYTUVcbi8vIEp1c3QgZm9yIGNvbXBhdGlibGUgd2l0aCBlYzIuXG5cbnpyVXRpbC5leHRlbmQoTW9kZWwucHJvdG90eXBlLCBiYXJJdGVtU3R5bGUpO1xuXG52YXIgX2RlZmF1bHQgPSBlY2hhcnRzLmV4dGVuZENoYXJ0Vmlldyh7XG4gIHR5cGU6ICdiYXInLFxuICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVTeXN0ZW1UeXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJyk7XG5cbiAgICBpZiAoY29vcmRpbmF0ZVN5c3RlbVR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgfHwgY29vcmRpbmF0ZVN5c3RlbVR5cGUgPT09ICdwb2xhcicpIHtcbiAgICAgIHRoaXMuX3JlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICB9IGVsc2Uge31cblxuICAgIHJldHVybiB0aGlzLmdyb3VwO1xuICB9LFxuICBkaXNwb3NlOiB6clV0aWwubm9vcCxcbiAgX3JlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgY29vcmQgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkLmdldEJhc2VBeGlzKCk7XG4gICAgdmFyIGlzSG9yaXpvbnRhbE9yUmFkaWFsO1xuXG4gICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgIGlzSG9yaXpvbnRhbE9yUmFkaWFsID0gYmFzZUF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgfSBlbHNlIGlmIChjb29yZC50eXBlID09PSAncG9sYXInKSB7XG4gICAgICBpc0hvcml6b250YWxPclJhZGlhbCA9IGJhc2VBeGlzLmRpbSA9PT0gJ2FuZ2xlJztcbiAgICB9XG5cbiAgICB2YXIgYW5pbWF0aW9uTW9kZWwgPSBzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSA/IHNlcmllc01vZGVsIDogbnVsbDtcbiAgICBkYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShkYXRhSW5kZXgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgICB2YXIgbGF5b3V0ID0gZ2V0TGF5b3V0W2Nvb3JkLnR5cGVdKGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsKTtcbiAgICAgIHZhciBlbCA9IGVsZW1lbnRDcmVhdG9yW2Nvb3JkLnR5cGVdKGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBhbmltYXRpb25Nb2RlbCk7XG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4LCBlbCk7XG4gICAgICBncm91cC5hZGQoZWwpO1xuICAgICAgdXBkYXRlU3R5bGUoZWwsIGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIHNlcmllc01vZGVsLCBpc0hvcml6b250YWxPclJhZGlhbCwgY29vcmQudHlwZSA9PT0gJ3BvbGFyJyk7XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgIHZhciBlbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJbmRleCk7XG5cbiAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShuZXdJbmRleCkpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwobmV3SW5kZXgpO1xuICAgICAgdmFyIGxheW91dCA9IGdldExheW91dFtjb29yZC50eXBlXShkYXRhLCBuZXdJbmRleCwgaXRlbU1vZGVsKTtcblxuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHtcbiAgICAgICAgICBzaGFwZTogbGF5b3V0XG4gICAgICAgIH0sIGFuaW1hdGlvbk1vZGVsLCBuZXdJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGVsZW1lbnRDcmVhdG9yW2Nvb3JkLnR5cGVdKGRhdGEsIG5ld0luZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGFuaW1hdGlvbk1vZGVsLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0luZGV4LCBlbCk7IC8vIEFkZCBiYWNrXG5cbiAgICAgIGdyb3VwLmFkZChlbCk7XG4gICAgICB1cGRhdGVTdHlsZShlbCwgZGF0YSwgbmV3SW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGNvb3JkLnR5cGUgPT09ICdwb2xhcicpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcblxuICAgICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgZWwgJiYgcmVtb3ZlUmVjdChkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCAmJiByZW1vdmVTZWN0b3IoZGF0YUluZGV4LCBhbmltYXRpb25Nb2RlbCwgZWwpO1xuICAgICAgfVxuICAgIH0pLmV4ZWN1dGUoKTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICBpZiAoZWNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpKSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGlmIChlbC50eXBlID09PSAnc2VjdG9yJykge1xuICAgICAgICAgICAgcmVtb3ZlU2VjdG9yKGVsLmRhdGFJbmRleCwgZWNNb2RlbCwgZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVSZWN0KGVsLmRhdGFJbmRleCwgZWNNb2RlbCwgZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciBlbGVtZW50Q3JlYXRvciA9IHtcbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc0hvcml6b250YWwsIGFuaW1hdGlvbk1vZGVsLCBpc1VwZGF0ZSkge1xuICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBzaGFwZTogenJVdGlsLmV4dGVuZCh7fSwgbGF5b3V0KVxuICAgIH0pOyAvLyBBbmltYXRpb25cblxuICAgIGlmIChhbmltYXRpb25Nb2RlbCkge1xuICAgICAgdmFyIHJlY3RTaGFwZSA9IHJlY3Quc2hhcGU7XG4gICAgICB2YXIgYW5pbWF0ZVByb3BlcnR5ID0gaXNIb3Jpem9udGFsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgdmFyIGFuaW1hdGVUYXJnZXQgPSB7fTtcbiAgICAgIHJlY3RTaGFwZVthbmltYXRlUHJvcGVydHldID0gMDtcbiAgICAgIGFuaW1hdGVUYXJnZXRbYW5pbWF0ZVByb3BlcnR5XSA9IGxheW91dFthbmltYXRlUHJvcGVydHldO1xuICAgICAgZ3JhcGhpY1tpc1VwZGF0ZSA/ICd1cGRhdGVQcm9wcycgOiAnaW5pdFByb3BzJ10ocmVjdCwge1xuICAgICAgICBzaGFwZTogYW5pbWF0ZVRhcmdldFxuICAgICAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIHBvbGFyOiBmdW5jdGlvbiAoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNSYWRpYWwsIGFuaW1hdGlvbk1vZGVsLCBpc1VwZGF0ZSkge1xuICAgIHZhciBzZWN0b3IgPSBuZXcgZ3JhcGhpYy5TZWN0b3Ioe1xuICAgICAgc2hhcGU6IHpyVXRpbC5leHRlbmQoe30sIGxheW91dClcbiAgICB9KTsgLy8gQW5pbWF0aW9uXG5cbiAgICBpZiAoYW5pbWF0aW9uTW9kZWwpIHtcbiAgICAgIHZhciBzZWN0b3JTaGFwZSA9IHNlY3Rvci5zaGFwZTtcbiAgICAgIHZhciBhbmltYXRlUHJvcGVydHkgPSBpc1JhZGlhbCA/ICdyJyA6ICdlbmRBbmdsZSc7XG4gICAgICB2YXIgYW5pbWF0ZVRhcmdldCA9IHt9O1xuICAgICAgc2VjdG9yU2hhcGVbYW5pbWF0ZVByb3BlcnR5XSA9IGlzUmFkaWFsID8gMCA6IGxheW91dC5zdGFydEFuZ2xlO1xuICAgICAgYW5pbWF0ZVRhcmdldFthbmltYXRlUHJvcGVydHldID0gbGF5b3V0W2FuaW1hdGVQcm9wZXJ0eV07XG4gICAgICBncmFwaGljW2lzVXBkYXRlID8gJ3VwZGF0ZVByb3BzJyA6ICdpbml0UHJvcHMnXShzZWN0b3IsIHtcbiAgICAgICAgc2hhcGU6IGFuaW1hdGVUYXJnZXRcbiAgICAgIH0sIGFuaW1hdGlvbk1vZGVsLCBkYXRhSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0b3I7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlbW92ZVJlY3QoZGF0YUluZGV4LCBhbmltYXRpb25Nb2RlbCwgZWwpIHtcbiAgLy8gTm90IHNob3cgdGV4dCB3aGVuIGFuaW1hdGluZ1xuICBlbC5zdHlsZS50ZXh0ID0gbnVsbDtcbiAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgIHNoYXBlOiB7XG4gICAgICB3aWR0aDogMFxuICAgIH1cbiAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCwgZnVuY3Rpb24gKCkge1xuICAgIGVsLnBhcmVudCAmJiBlbC5wYXJlbnQucmVtb3ZlKGVsKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNlY3RvcihkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCkge1xuICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gIGVsLnN0eWxlLnRleHQgPSBudWxsO1xuICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgc2hhcGU6IHtcbiAgICAgIHI6IGVsLnNoYXBlLnIwXG4gICAgfVxuICB9LCBhbmltYXRpb25Nb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgZWwucGFyZW50ICYmIGVsLnBhcmVudC5yZW1vdmUoZWwpO1xuICB9KTtcbn1cblxudmFyIGdldExheW91dCA9IHtcbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCkge1xuICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgICB2YXIgZml4ZWRMaW5lV2lkdGggPSBnZXRMaW5lV2lkdGgoaXRlbU1vZGVsLCBsYXlvdXQpOyAvLyBmaXggbGF5b3V0IHdpdGggbGluZVdpZHRoXG5cbiAgICB2YXIgc2lnblggPSBsYXlvdXQud2lkdGggPiAwID8gMSA6IC0xO1xuICAgIHZhciBzaWduWSA9IGxheW91dC5oZWlnaHQgPiAwID8gMSA6IC0xO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBsYXlvdXQueCArIHNpZ25YICogZml4ZWRMaW5lV2lkdGggLyAyLFxuICAgICAgeTogbGF5b3V0LnkgKyBzaWduWSAqIGZpeGVkTGluZVdpZHRoIC8gMixcbiAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGggLSBzaWduWCAqIGZpeGVkTGluZVdpZHRoLFxuICAgICAgaGVpZ2h0OiBsYXlvdXQuaGVpZ2h0IC0gc2lnblkgKiBmaXhlZExpbmVXaWR0aFxuICAgIH07XG4gIH0sXG4gIHBvbGFyOiBmdW5jdGlvbiAoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwpIHtcbiAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN4OiBsYXlvdXQuY3gsXG4gICAgICBjeTogbGF5b3V0LmN5LFxuICAgICAgcjA6IGxheW91dC5yMCxcbiAgICAgIHI6IGxheW91dC5yLFxuICAgICAgc3RhcnRBbmdsZTogbGF5b3V0LnN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZTogbGF5b3V0LmVuZEFuZ2xlXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWwsIGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIHNlcmllc01vZGVsLCBpc0hvcml6b250YWwsIGlzUG9sYXIpIHtcbiAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ2NvbG9yJyk7XG4gIHZhciBvcGFjaXR5ID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ29wYWNpdHknKTtcbiAgdmFyIGl0ZW1TdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUubm9ybWFsJyk7XG4gIHZhciBob3ZlclN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUuZW1waGFzaXMnKS5nZXRCYXJJdGVtU3R5bGUoKTtcblxuICBpZiAoIWlzUG9sYXIpIHtcbiAgICBlbC5zZXRTaGFwZSgncicsIGl0ZW1TdHlsZU1vZGVsLmdldCgnYmFyQm9yZGVyUmFkaXVzJykgfHwgMCk7XG4gIH1cblxuICBlbC51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoe1xuICAgIGZpbGw6IGNvbG9yLFxuICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgfSwgaXRlbVN0eWxlTW9kZWwuZ2V0QmFySXRlbVN0eWxlKCkpKTtcbiAgdmFyIGN1cnNvclN0eWxlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2N1cnNvcicpO1xuICBjdXJzb3JTdHlsZSAmJiBlbC5hdHRyKCdjdXJzb3InLCBjdXJzb3JTdHlsZSk7XG4gIHZhciBsYWJlbFBvc2l0aW9uT3V0c2lkZSA9IGlzSG9yaXpvbnRhbCA/IGxheW91dC5oZWlnaHQgPiAwID8gJ2JvdHRvbScgOiAndG9wJyA6IGxheW91dC53aWR0aCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIGlmICghaXNQb2xhcikge1xuICAgIHNldExhYmVsKGVsLnN0eWxlLCBob3ZlclN0eWxlLCBpdGVtTW9kZWwsIGNvbG9yLCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBsYWJlbFBvc2l0aW9uT3V0c2lkZSk7XG4gIH1cblxuICBncmFwaGljLnNldEhvdmVyU3R5bGUoZWwsIGhvdmVyU3R5bGUpO1xufSAvLyBJbiBjYXNlIHdpZHRoIG9yIGhlaWdodCBhcmUgdG9vIHNtYWxsLlxuXG5cbmZ1bmN0aW9uIGdldExpbmVXaWR0aChpdGVtTW9kZWwsIHJhd0xheW91dCkge1xuICB2YXIgbGluZVdpZHRoID0gaXRlbU1vZGVsLmdldChCQVJfQk9SREVSX1dJRFRIX1FVRVJZKSB8fCAwO1xuICByZXR1cm4gTWF0aC5taW4obGluZVdpZHRoLCBNYXRoLmFicyhyYXdMYXlvdXQud2lkdGgpLCBNYXRoLmFicyhyYXdMYXlvdXQuaGVpZ2h0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDI1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxuZnVuY3Rpb24gc2V0TGFiZWwobm9ybWFsU3R5bGUsIGhvdmVyU3R5bGUsIGl0ZW1Nb2RlbCwgY29sb3IsIHNlcmllc01vZGVsLCBkYXRhSW5kZXgsIGxhYmVsUG9zaXRpb25PdXRzaWRlKSB7XG4gIHZhciBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKTtcbiAgdmFyIGhvdmVyTGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKTtcbiAgZ3JhcGhpYy5zZXRMYWJlbFN0eWxlKG5vcm1hbFN0eWxlLCBob3ZlclN0eWxlLCBsYWJlbE1vZGVsLCBob3ZlckxhYmVsTW9kZWwsIHtcbiAgICBsYWJlbEZldGNoZXI6IHNlcmllc01vZGVsLFxuICAgIGxhYmVsRGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgZGVmYXVsdFRleHQ6IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGRhdGFJbmRleCksXG4gICAgaXNSZWN0VGV4dDogdHJ1ZSxcbiAgICBhdXRvQ29sb3I6IGNvbG9yXG4gIH0pO1xuICBmaXhQb3NpdGlvbihub3JtYWxTdHlsZSk7XG4gIGZpeFBvc2l0aW9uKGhvdmVyU3R5bGUpO1xufVxuXG5mdW5jdGlvbiBmaXhQb3NpdGlvbihzdHlsZSwgbGFiZWxQb3NpdGlvbk91dHNpZGUpIHtcbiAgaWYgKHN0eWxlLnRleHRQb3NpdGlvbiA9PT0gJ291dHNpZGUnKSB7XG4gICAgc3R5bGUudGV4dFBvc2l0aW9uID0gbGFiZWxQb3NpdGlvbk91dHNpZGU7XG4gIH1cbn1cblxuZXhwb3J0cy5zZXRMYWJlbCA9IHNldExhYmVsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9oZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBtYWtlU3R5bGVNYXBwZXIgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyXCIpO1xuXG52YXIgZ2V0QmFySXRlbVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2ZpbGwnLCAnY29sb3InXSwgWydzdHJva2UnLCAnYm9yZGVyQ29sb3InXSwgWydsaW5lV2lkdGgnLCAnYm9yZGVyV2lkdGgnXSwgLy8gQ29tcGF0aXRhYmxlIHdpdGggMlxuWydzdHJva2UnLCAnYmFyQm9yZGVyQ29sb3InXSwgWydsaW5lV2lkdGgnLCAnYmFyQm9yZGVyV2lkdGgnXSwgWydvcGFjaXR5J10sIFsnc2hhZG93Qmx1ciddLCBbJ3NoYWRvd09mZnNldFgnXSwgWydzaGFkb3dPZmZzZXRZJ10sIFsnc2hhZG93Q29sb3InXV0pO1xudmFyIF9kZWZhdWx0ID0ge1xuICBnZXRCYXJJdGVtU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcykge1xuICAgIHZhciBzdHlsZSA9IGdldEJhckl0ZW1TdHlsZSh0aGlzLCBleGNsdWRlcyk7XG5cbiAgICBpZiAodGhpcy5nZXRCb3JkZXJMaW5lRGFzaCkge1xuICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRCb3JkZXJMaW5lRGFzaCgpO1xuICAgICAgbGluZURhc2ggJiYgKHN0eWxlLmxpbmVEYXNoID0gbGluZURhc2gpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2Jhckl0ZW1TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZShcIi4uL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL2F4aXMvQ2FydGVzaWFuQXhpc1ZpZXdcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMuanNcbi8vIG1vZHVsZSBpZCA9IDI1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBBeGlzQnVpbGRlciA9IHJlcXVpcmUoXCIuL0F4aXNCdWlsZGVyXCIpO1xuXG52YXIgQXhpc1ZpZXcgPSByZXF1aXJlKFwiLi9BeGlzVmlld1wiKTtcblxudmFyIGNhcnRlc2lhbkF4aXNIZWxwZXIgPSByZXF1aXJlKFwiLi9jYXJ0ZXNpYW5BeGlzSGVscGVyXCIpO1xuXG52YXIgaWZJZ25vcmVPblRpY2sgPSBBeGlzQnVpbGRlci5pZklnbm9yZU9uVGljaztcbnZhciBnZXRJbnRlcnZhbCA9IEF4aXNCdWlsZGVyLmdldEludGVydmFsO1xudmFyIGF4aXNCdWlsZGVyQXR0cnMgPSBbJ2F4aXNMaW5lJywgJ2F4aXNUaWNrTGFiZWwnLCAnYXhpc05hbWUnXTtcbnZhciBzZWxmQnVpbGRlckF0dHJzID0gWydzcGxpdEFyZWEnLCAnc3BsaXRMaW5lJ107IC8vIGZ1bmN0aW9uIGdldEFsaWduV2l0aExhYmVsKG1vZGVsLCBheGlzTW9kZWwpIHtcbi8vICAgICB2YXIgYWxpZ25XaXRoTGFiZWwgPSBtb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJyk7XG4vLyAgICAgaWYgKGFsaWduV2l0aExhYmVsID09PSAnYXV0bycpIHtcbi8vICAgICAgICAgYWxpZ25XaXRoTGFiZWwgPSBheGlzTW9kZWwuZ2V0KCdheGlzVGljay5hbGlnbldpdGhMYWJlbCcpO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gYWxpZ25XaXRoTGFiZWw7XG4vLyB9XG5cbnZhciBDYXJ0ZXNpYW5BeGlzVmlldyA9IEF4aXNWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdjYXJ0ZXNpYW5BeGlzJyxcbiAgYXhpc1BvaW50ZXJDbGFzczogJ0NhcnRlc2lhbkF4aXNQb2ludGVyJyxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdmFyIG9sZEF4aXNHcm91cCA9IHRoaXMuX2F4aXNHcm91cDtcbiAgICB0aGlzLl9heGlzR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2F4aXNHcm91cCk7XG5cbiAgICBpZiAoIWF4aXNNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpO1xuICAgIHZhciBsYXlvdXQgPSBjYXJ0ZXNpYW5BeGlzSGVscGVyLmxheW91dChncmlkTW9kZWwsIGF4aXNNb2RlbCk7XG4gICAgdmFyIGF4aXNCdWlsZGVyID0gbmV3IEF4aXNCdWlsZGVyKGF4aXNNb2RlbCwgbGF5b3V0KTtcbiAgICB6clV0aWwuZWFjaChheGlzQnVpbGRlckF0dHJzLCBheGlzQnVpbGRlci5hZGQsIGF4aXNCdWlsZGVyKTtcblxuICAgIHRoaXMuX2F4aXNHcm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG5cbiAgICB6clV0aWwuZWFjaChzZWxmQnVpbGRlckF0dHJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKGF4aXNNb2RlbC5nZXQobmFtZSArICcuc2hvdycpKSB7XG4gICAgICAgIHRoaXNbJ18nICsgbmFtZV0oYXhpc01vZGVsLCBncmlkTW9kZWwsIGxheW91dC5sYWJlbEludGVydmFsKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBncmFwaGljLmdyb3VwVHJhbnNpdGlvbihvbGRBeGlzR3JvdXAsIHRoaXMuX2F4aXNHcm91cCwgYXhpc01vZGVsKTtcbiAgICBDYXJ0ZXNpYW5BeGlzVmlldy5zdXBlckNhbGwodGhpcywgJ3JlbmRlcicsIGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsfSBheGlzTW9kZWxcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsfSBncmlkTW9kZWxcbiAgICogQHBhcmFtIHtudW1iZXJ8RnVuY3Rpb259IGxhYmVsSW50ZXJ2YWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zcGxpdExpbmU6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGdyaWRNb2RlbCwgbGFiZWxJbnRlcnZhbCkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG5cbiAgICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3BsaXRMaW5lTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0TGluZScpO1xuICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IHNwbGl0TGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICB2YXIgbGluZUNvbG9ycyA9IGxpbmVTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcbiAgICB2YXIgbGluZUludGVydmFsID0gZ2V0SW50ZXJ2YWwoc3BsaXRMaW5lTW9kZWwsIGxhYmVsSW50ZXJ2YWwpO1xuICAgIGxpbmVDb2xvcnMgPSB6clV0aWwuaXNBcnJheShsaW5lQ29sb3JzKSA/IGxpbmVDb2xvcnMgOiBbbGluZUNvbG9yc107XG4gICAgdmFyIGdyaWRSZWN0ID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoKTtcbiAgICB2YXIgdGlja3MgPSBheGlzLnNjYWxlLmdldFRpY2tzKCk7XG4gICAgdmFyIHNob3dNaW5MYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWluTGFiZWwnKTtcbiAgICB2YXIgc2hvd01heExhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNYXhMYWJlbCcpO1xuICAgIHZhciBwMSA9IFtdO1xuICAgIHZhciBwMiA9IFtdOyAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgLy8gQmF0Y2hpbmcgdGhlIGxpbmVzIGlmIGNvbG9yIGFyZSB0aGUgc2FtZVxuXG4gICAgdmFyIGxpbmVTdHlsZSA9IGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGksIGxpbmVJbnRlcnZhbCwgdGlja3NDb29yZHMubGVuZ3RoLCBzaG93TWluTGFiZWwsIHNob3dNYXhMYWJlbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbaV0pO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHAxWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMVsxXSA9IGdyaWRSZWN0Lnk7XG4gICAgICAgIHAyWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMlsxXSA9IGdyaWRSZWN0LnkgKyBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwMVswXSA9IGdyaWRSZWN0Lng7XG4gICAgICAgIHAxWzFdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMlswXSA9IGdyaWRSZWN0LnggKyBncmlkUmVjdC53aWR0aDtcbiAgICAgICAgcDJbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvckluZGV4ID0gbGluZUNvdW50KysgJSBsaW5lQ29sb3JzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fYXhpc0dyb3VwLmFkZChuZXcgZ3JhcGhpYy5MaW5lKGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUoe1xuICAgICAgICBhbmlkOiAnbGluZV8nICsgdGlja3NbaV0sXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgeDE6IHAxWzBdLFxuICAgICAgICAgIHkxOiBwMVsxXSxcbiAgICAgICAgICB4MjogcDJbMF0sXG4gICAgICAgICAgeTI6IHAyWzFdXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIHN0cm9rZTogbGluZUNvbG9yc1tjb2xvckluZGV4XVxuICAgICAgICB9LCBsaW5lU3R5bGUpLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgKiBAcGFyYW0ge251bWJlcnxGdW5jdGlvbn0gbGFiZWxJbnRlcnZhbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NwbGl0QXJlYTogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBsYWJlbEludGVydmFsKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcblxuICAgIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzcGxpdEFyZWFNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRBcmVhJyk7XG4gICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc3BsaXRBcmVhTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZScpO1xuICAgIHZhciBhcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBncmlkUmVjdCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcbiAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKCk7XG4gICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuICAgIHZhciBwcmV2WCA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1swXSk7XG4gICAgdmFyIHByZXZZID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzWzBdKTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhcmVhSW50ZXJ2YWwgPSBnZXRJbnRlcnZhbChzcGxpdEFyZWFNb2RlbCwgbGFiZWxJbnRlcnZhbCk7XG4gICAgdmFyIGFyZWFTdHlsZSA9IGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuICAgIGFyZWFDb2xvcnMgPSB6clV0aWwuaXNBcnJheShhcmVhQ29sb3JzKSA/IGFyZWFDb2xvcnMgOiBbYXJlYUNvbG9yc107XG4gICAgdmFyIHNob3dNaW5MYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWluTGFiZWwnKTtcbiAgICB2YXIgc2hvd01heExhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3dNYXhMYWJlbCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGksIGFyZWFJbnRlcnZhbCwgdGlja3NDb29yZHMubGVuZ3RoLCBzaG93TWluTGFiZWwsIHNob3dNYXhMYWJlbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbaV0pO1xuICAgICAgdmFyIHg7XG4gICAgICB2YXIgeTtcbiAgICAgIHZhciB3aWR0aDtcbiAgICAgIHZhciBoZWlnaHQ7XG5cbiAgICAgIGlmIChheGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHggPSBwcmV2WDtcbiAgICAgICAgeSA9IGdyaWRSZWN0Lnk7XG4gICAgICAgIHdpZHRoID0gdGlja0Nvb3JkIC0geDtcbiAgICAgICAgaGVpZ2h0ID0gZ3JpZFJlY3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGdyaWRSZWN0Lng7XG4gICAgICAgIHkgPSBwcmV2WTtcbiAgICAgICAgd2lkdGggPSBncmlkUmVjdC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGlja0Nvb3JkIC0geTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9ySW5kZXggPSBjb3VudCsrICUgYXJlYUNvbG9ycy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX2F4aXNHcm91cC5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgIGFuaWQ6ICdhcmVhXycgKyB0aWNrc1tpXSxcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIGZpbGw6IGFyZWFDb2xvcnNbY29sb3JJbmRleF1cbiAgICAgICAgfSwgYXJlYVN0eWxlKSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KSk7XG5cbiAgICAgIHByZXZYID0geCArIHdpZHRoO1xuICAgICAgcHJldlkgPSB5ICsgaGVpZ2h0O1xuICAgIH1cbiAgfVxufSk7XG5DYXJ0ZXNpYW5BeGlzVmlldy5leHRlbmQoe1xuICB0eXBlOiAneEF4aXMnXG59KTtcbkNhcnRlc2lhbkF4aXNWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICd5QXhpcydcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0NhcnRlc2lhbkF4aXNWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxucmVxdWlyZShcIi4vbGluZS9MaW5lU2VyaWVzXCIpO1xuXG5yZXF1aXJlKFwiLi9saW5lL0xpbmVWaWV3XCIpO1xuXG52YXIgdmlzdWFsU3ltYm9sID0gcmVxdWlyZShcIi4uL3Zpc3VhbC9zeW1ib2xcIik7XG5cbnZhciBsYXlvdXRQb2ludHMgPSByZXF1aXJlKFwiLi4vbGF5b3V0L3BvaW50c1wiKTtcblxudmFyIGRhdGFTYW1wbGUgPSByZXF1aXJlKFwiLi4vcHJvY2Vzc29yL2RhdGFTYW1wbGVcIik7XG5cbnJlcXVpcmUoXCIuLi9jb21wb25lbnQvZ3JpZFNpbXBsZVwiKTtcblxuLy8gSW4gY2FzZSBkZXZlbG9wZXIgZm9yZ2V0IHRvIGluY2x1ZGUgZ3JpZCBjb21wb25lbnRcbmVjaGFydHMucmVnaXN0ZXJWaXN1YWwoenJVdGlsLmN1cnJ5KHZpc3VhbFN5bWJvbCwgJ2xpbmUnLCAnY2lyY2xlJywgJ2xpbmUnKSk7XG5lY2hhcnRzLnJlZ2lzdGVyTGF5b3V0KHpyVXRpbC5jdXJyeShsYXlvdXRQb2ludHMsICdsaW5lJykpOyAvLyBEb3duIHNhbXBsZSBhZnRlciBmaWx0ZXJcblxuZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihlY2hhcnRzLlBSSU9SSVRZLlBST0NFU1NPUi5TVEFUSVNUSUMsIHpyVXRpbC5jdXJyeShkYXRhU2FtcGxlLCAnbGluZScpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgY3JlYXRlTGlzdEZyb21BcnJheSA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheVwiKTtcblxudmFyIFNlcmllc01vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL1Nlcmllc1wiKTtcblxudmFyIF9kZWZhdWx0ID0gU2VyaWVzTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ3Nlcmllcy5saW5lJyxcbiAgZGVwZW5kZW5jaWVzOiBbJ2dyaWQnLCAncG9sYXInXSxcbiAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheShvcHRpb24uZGF0YSwgdGhpcywgZWNNb2RlbCk7XG4gIH0sXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgLy8g5LiA57qn5bGC5Y+gXG4gICAgejogMixcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICBjb29yZGluYXRlU3lzdGVtOiAnY2FydGVzaWFuMmQnLFxuICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICBob3ZlckFuaW1hdGlvbjogdHJ1ZSxcbiAgICAvLyBzdGFjazogbnVsbFxuICAgIC8vIHhBeGlzSW5kZXg6IDAsXG4gICAgLy8geUF4aXNJbmRleDogMCxcbiAgICAvLyBwb2xhckluZGV4OiAwLFxuICAgIC8vIElmIGNsaXAgdGhlIG92ZXJmbG93IHZhbHVlXG4gICAgY2xpcE92ZXJmbG93OiB0cnVlLFxuICAgIC8vIGN1cnNvcjogbnVsbCxcbiAgICBsYWJlbDoge1xuICAgICAgbm9ybWFsOiB7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wJ1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gaXRlbVN0eWxlOiB7XG4gICAgLy8gICAgIG5vcm1hbDoge30sXG4gICAgLy8gICAgIGVtcGhhc2lzOiB7fVxuICAgIC8vIH0sXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgd2lkdGg6IDIsXG4gICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGFyZWFTdHlsZToge30sXG4gICAgLy8gZmFsc2UsICdzdGFydCcsICdlbmQnLCAnbWlkZGxlJ1xuICAgIHN0ZXA6IGZhbHNlLFxuICAgIC8vIERpc2FibGVkIGlmIHN0ZXAgaXMgdHJ1ZVxuICAgIHNtb290aDogZmFsc2UsXG4gICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG4gICAgLy8g5ouQ54K55Zu+5b2i57G75Z6LXG4gICAgc3ltYm9sOiAnZW1wdHlDaXJjbGUnLFxuICAgIC8vIOaLkOeCueWbvuW9ouWkp+Wwj1xuICAgIHN5bWJvbFNpemU6IDQsXG4gICAgLy8g5ouQ54K55Zu+5b2i5peL6L2s5o6n5Yi2XG4gICAgc3ltYm9sUm90YXRlOiBudWxsLFxuICAgIC8vIOaYr+WQpuaYvuekuiBzeW1ib2wsIOWPquacieWcqCB0b29sdGlwIGhvdmVyIOeahOaXtuWAmeaYvuekulxuICAgIHNob3dTeW1ib2w6IHRydWUsXG4gICAgLy8g5qCH5b+X5Zu+5b2i6buY6K6k5Y+q5pyJ5Li76L205pi+56S677yI6ZqP5Li76L205qCH562+6Ze06ZqU6ZqQ6JeP562W55Wl77yJXG4gICAgc2hvd0FsbFN5bWJvbDogZmFsc2UsXG4gICAgLy8g5piv5ZCm6L+e5o6l5pat54K5XG4gICAgY29ubmVjdE51bGxzOiBmYWxzZSxcbiAgICAvLyDmlbDmja7ov4fmu6TvvIwnYXZlcmFnZScsICdtYXgnLCAnbWluJywgJ3N1bSdcbiAgICBzYW1wbGluZzogJ25vbmUnLFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG4gICAgLy8gRGlzYWJsZSBwcm9ncmVzc2l2ZVxuICAgIHByb2dyZXNzaXZlOiAwLFxuICAgIGhvdmVyTGF5ZXJUaHJlc2hvbGQ6IEluZmluaXR5XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBTeW1ib2xEcmF3ID0gcmVxdWlyZShcIi4uL2hlbHBlci9TeW1ib2xEcmF3XCIpO1xuXG52YXIgU3ltYm9sQ2x6ID0gcmVxdWlyZShcIi4uL2hlbHBlci9TeW1ib2xcIik7XG5cbnZhciBsaW5lQW5pbWF0aW9uRGlmZiA9IHJlcXVpcmUoXCIuL2xpbmVBbmltYXRpb25EaWZmXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIF9wb2x5ID0gcmVxdWlyZShcIi4vcG9seVwiKTtcblxudmFyIFBvbHlsaW5lID0gX3BvbHkuUG9seWxpbmU7XG52YXIgUG9seWdvbiA9IF9wb2x5LlBvbHlnb247XG5cbnZhciBDaGFydFZpZXcgPSByZXF1aXJlKFwiLi4vLi4vdmlldy9DaGFydFwiKTtcblxuLy8gRklYTUUgc3RlcCBub3Qgc3VwcG9ydCBwb2xhclxuZnVuY3Rpb24gaXNQb2ludHNTYW1lKHBvaW50czEsIHBvaW50czIpIHtcbiAgaWYgKHBvaW50czEubGVuZ3RoICE9PSBwb2ludHMyLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzMS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwMSA9IHBvaW50czFbaV07XG4gICAgdmFyIHAyID0gcG9pbnRzMltpXTtcblxuICAgIGlmIChwMVswXSAhPT0gcDJbMF0gfHwgcDFbMV0gIT09IHAyWzFdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldFNtb290aChzbW9vdGgpIHtcbiAgcmV0dXJuIHR5cGVvZiBzbW9vdGggPT09ICdudW1iZXInID8gc21vb3RoIDogc21vb3RoID8gMC4zIDogMDtcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0V4dGVudFdpdGhHYXAoYXhpcykge1xuICB2YXIgZXh0ZW50ID0gYXhpcy5nZXRHbG9iYWxFeHRlbnQoKTtcblxuICBpZiAoYXhpcy5vbkJhbmQpIHtcbiAgICAvLyBSZW1vdmUgZXh0cmEgMXB4IHRvIGF2b2lkIGxpbmUgbWl0ZXIgaW4gY2xpcHBlZCBlZGdlXG4gICAgdmFyIGhhbGZCYW5kV2lkdGggPSBheGlzLmdldEJhbmRXaWR0aCgpIC8gMiAtIDE7XG4gICAgdmFyIGRpciA9IGV4dGVudFsxXSA+IGV4dGVudFswXSA/IDEgOiAtMTtcbiAgICBleHRlbnRbMF0gKz0gZGlyICogaGFsZkJhbmRXaWR0aDtcbiAgICBleHRlbnRbMV0gLT0gZGlyICogaGFsZkJhbmRXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBleHRlbnQ7XG59XG5cbmZ1bmN0aW9uIHNpZ24odmFsKSB7XG4gIHJldHVybiB2YWwgPj0gMCA/IDEgOiAtMTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuMkR8bW9kdWxlOmVjaGFydHMvY29vcmQvcG9sYXIvUG9sYXJ9IGNvb3JkU3lzXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHNcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTdGFja2VkT25Qb2ludHMoY29vcmRTeXMsIGRhdGEpIHtcbiAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gIHZhciB2YWx1ZVN0YXJ0ID0gMDtcblxuICBpZiAoIWJhc2VBeGlzLm9uWmVybykge1xuICAgIHZhciBleHRlbnQgPSB2YWx1ZUF4aXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG5cbiAgICBpZiAoZXh0ZW50WzBdID4gMCkge1xuICAgICAgLy8gQm90aCBwb3NpdGl2ZVxuICAgICAgdmFsdWVTdGFydCA9IGV4dGVudFswXTtcbiAgICB9IGVsc2UgaWYgKGV4dGVudFsxXSA8IDApIHtcbiAgICAgIC8vIEJvdGggbmVnYXRpdmVcbiAgICAgIHZhbHVlU3RhcnQgPSBleHRlbnRbMV07XG4gICAgfSAvLyBJZiBpcyBvbmUgcG9zaXRpdmUsIGFuZCBvbmUgbmVnYXRpdmUsIG9uWmVybyBzaGFsbCBiZSB0cnVlXG5cbiAgfVxuXG4gIHZhciB2YWx1ZURpbSA9IHZhbHVlQXhpcy5kaW07XG4gIHZhciBiYXNlRGF0YU9mZnNldCA9IHZhbHVlRGltID09PSAneCcgfHwgdmFsdWVEaW0gPT09ICdyYWRpdXMnID8gMSA6IDA7XG4gIHJldHVybiBkYXRhLm1hcEFycmF5KFt2YWx1ZURpbV0sIGZ1bmN0aW9uICh2YWwsIGlkeCkge1xuICAgIHZhciBzdGFja2VkT25TYW1lU2lnbjtcbiAgICB2YXIgc3RhY2tlZE9uID0gZGF0YS5zdGFja2VkT247IC8vIEZpbmQgZmlyc3Qgc3RhY2tlZCB2YWx1ZSB3aXRoIHNhbWUgc2lnblxuXG4gICAgd2hpbGUgKHN0YWNrZWRPbiAmJiBzaWduKHN0YWNrZWRPbi5nZXQodmFsdWVEaW0sIGlkeCkpID09PSBzaWduKHZhbCkpIHtcbiAgICAgIHN0YWNrZWRPblNhbWVTaWduID0gc3RhY2tlZE9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrZWREYXRhID0gW107XG4gICAgc3RhY2tlZERhdGFbYmFzZURhdGFPZmZzZXRdID0gZGF0YS5nZXQoYmFzZUF4aXMuZGltLCBpZHgpO1xuICAgIHN0YWNrZWREYXRhWzEgLSBiYXNlRGF0YU9mZnNldF0gPSBzdGFja2VkT25TYW1lU2lnbiA/IHN0YWNrZWRPblNhbWVTaWduLmdldCh2YWx1ZURpbSwgaWR4LCB0cnVlKSA6IHZhbHVlU3RhcnQ7XG4gICAgcmV0dXJuIGNvb3JkU3lzLmRhdGFUb1BvaW50KHN0YWNrZWREYXRhKTtcbiAgfSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdyaWRDbGlwU2hhcGUoY2FydGVzaWFuLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsKSB7XG4gIHZhciB4RXh0ZW50ID0gZ2V0QXhpc0V4dGVudFdpdGhHYXAoY2FydGVzaWFuLmdldEF4aXMoJ3gnKSk7XG4gIHZhciB5RXh0ZW50ID0gZ2V0QXhpc0V4dGVudFdpdGhHYXAoY2FydGVzaWFuLmdldEF4aXMoJ3knKSk7XG4gIHZhciBpc0hvcml6b250YWwgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKS5pc0hvcml6b250YWwoKTtcbiAgdmFyIHggPSBNYXRoLm1pbih4RXh0ZW50WzBdLCB4RXh0ZW50WzFdKTtcbiAgdmFyIHkgPSBNYXRoLm1pbih5RXh0ZW50WzBdLCB5RXh0ZW50WzFdKTtcbiAgdmFyIHdpZHRoID0gTWF0aC5tYXgoeEV4dGVudFswXSwgeEV4dGVudFsxXSkgLSB4O1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoeUV4dGVudFswXSwgeUV4dGVudFsxXSkgLSB5O1xuICB2YXIgbGluZVdpZHRoID0gc2VyaWVzTW9kZWwuZ2V0KCdsaW5lU3R5bGUubm9ybWFsLndpZHRoJykgfHwgMjsgLy8gRXhwYW5kIGNsaXAgc2hhcGUgdG8gYXZvaWQgY2xpcHBpbmcgd2hlbiBsaW5lIHZhbHVlIGV4Y2VlZHMgYXhpc1xuXG4gIHZhciBleHBhbmRTaXplID0gc2VyaWVzTW9kZWwuZ2V0KCdjbGlwT3ZlcmZsb3cnKSA/IGxpbmVXaWR0aCAvIDIgOiBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcblxuICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgeSAtPSBleHBhbmRTaXplO1xuICAgIGhlaWdodCArPSBleHBhbmRTaXplICogMjtcbiAgfSBlbHNlIHtcbiAgICB4IC09IGV4cGFuZFNpemU7XG4gICAgd2lkdGggKz0gZXhwYW5kU2l6ZSAqIDI7XG4gIH1cblxuICB2YXIgY2xpcFBhdGggPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICBzaGFwZToge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGhhc0FuaW1hdGlvbikge1xuICAgIGNsaXBQYXRoLnNoYXBlW2lzSG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gPSAwO1xuICAgIGdyYXBoaWMuaW5pdFByb3BzKGNsaXBQYXRoLCB7XG4gICAgICBzaGFwZToge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9XG4gICAgfSwgc2VyaWVzTW9kZWwpO1xuICB9XG5cbiAgcmV0dXJuIGNsaXBQYXRoO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2xhckNsaXBTaGFwZShwb2xhciwgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgYW5nbGVBeGlzID0gcG9sYXIuZ2V0QW5nbGVBeGlzKCk7XG4gIHZhciByYWRpdXNBeGlzID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpO1xuICB2YXIgcmFkaXVzRXh0ZW50ID0gcmFkaXVzQXhpcy5nZXRFeHRlbnQoKTtcbiAgdmFyIGFuZ2xlRXh0ZW50ID0gYW5nbGVBeGlzLmdldEV4dGVudCgpO1xuICB2YXIgUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcbiAgdmFyIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuU2VjdG9yKHtcbiAgICBzaGFwZToge1xuICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgY3k6IHBvbGFyLmN5LFxuICAgICAgcjA6IHJhZGl1c0V4dGVudFswXSxcbiAgICAgIHI6IHJhZGl1c0V4dGVudFsxXSxcbiAgICAgIHN0YXJ0QW5nbGU6IC1hbmdsZUV4dGVudFswXSAqIFJBRElBTixcbiAgICAgIGVuZEFuZ2xlOiAtYW5nbGVFeHRlbnRbMV0gKiBSQURJQU4sXG4gICAgICBjbG9ja3dpc2U6IGFuZ2xlQXhpcy5pbnZlcnNlXG4gICAgfVxuICB9KTtcblxuICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgY2xpcFBhdGguc2hhcGUuZW5kQW5nbGUgPSAtYW5nbGVFeHRlbnRbMF0gKiBSQURJQU47XG4gICAgZ3JhcGhpYy5pbml0UHJvcHMoY2xpcFBhdGgsIHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIGVuZEFuZ2xlOiAtYW5nbGVFeHRlbnRbMV0gKiBSQURJQU5cbiAgICAgIH1cbiAgICB9LCBzZXJpZXNNb2RlbCk7XG4gIH1cblxuICByZXR1cm4gY2xpcFBhdGg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJyA/IGNyZWF0ZVBvbGFyQ2xpcFNoYXBlKGNvb3JkU3lzLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsKSA6IGNyZWF0ZUdyaWRDbGlwU2hhcGUoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpO1xufVxuXG5mdW5jdGlvbiB0dXJuUG9pbnRzSW50b1N0ZXAocG9pbnRzLCBjb29yZFN5cywgc3RlcFR1cm5BdCkge1xuICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICB2YXIgYmFzZUluZGV4ID0gYmFzZUF4aXMuZGltID09PSAneCcgfHwgYmFzZUF4aXMuZGltID09PSAncmFkaXVzJyA/IDAgOiAxO1xuICB2YXIgc3RlcFBvaW50cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHZhciBuZXh0UHQgPSBwb2ludHNbaSArIDFdO1xuICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICBzdGVwUG9pbnRzLnB1c2gocHQpO1xuICAgIHZhciBzdGVwUHQgPSBbXTtcblxuICAgIHN3aXRjaCAoc3RlcFR1cm5BdCkge1xuICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgc3RlcFB0W2Jhc2VJbmRleF0gPSBuZXh0UHRbYmFzZUluZGV4XTtcbiAgICAgICAgc3RlcFB0WzEgLSBiYXNlSW5kZXhdID0gcHRbMSAtIGJhc2VJbmRleF07IC8vIGRlZmF1bHQgaXMgc3RhcnRcblxuICAgICAgICBzdGVwUG9pbnRzLnB1c2goc3RlcFB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgIC8vIGRlZmF1bHQgaXMgc3RhcnRcbiAgICAgICAgdmFyIG1pZGRsZSA9IChwdFtiYXNlSW5kZXhdICsgbmV4dFB0W2Jhc2VJbmRleF0pIC8gMjtcbiAgICAgICAgdmFyIHN0ZXBQdDIgPSBbXTtcbiAgICAgICAgc3RlcFB0W2Jhc2VJbmRleF0gPSBzdGVwUHQyW2Jhc2VJbmRleF0gPSBtaWRkbGU7XG4gICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IHB0WzEgLSBiYXNlSW5kZXhdO1xuICAgICAgICBzdGVwUHQyWzEgLSBiYXNlSW5kZXhdID0gbmV4dFB0WzEgLSBiYXNlSW5kZXhdO1xuICAgICAgICBzdGVwUG9pbnRzLnB1c2goc3RlcFB0KTtcbiAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3RlcFB0W2Jhc2VJbmRleF0gPSBwdFtiYXNlSW5kZXhdO1xuICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBuZXh0UHRbMSAtIGJhc2VJbmRleF07IC8vIGRlZmF1bHQgaXMgc3RhcnRcblxuICAgICAgICBzdGVwUG9pbnRzLnB1c2goc3RlcFB0KTtcbiAgICB9XG4gIH0gLy8gTGFzdCBwb2ludHNcblxuXG4gIHBvaW50c1tpXSAmJiBzdGVwUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcbiAgcmV0dXJuIHN0ZXBQb2ludHM7XG59XG5cbmZ1bmN0aW9uIGdldFZpc3VhbEdyYWRpZW50KGRhdGEsIGNvb3JkU3lzKSB7XG4gIHZhciB2aXN1YWxNZXRhTGlzdCA9IGRhdGEuZ2V0VmlzdWFsKCd2aXN1YWxNZXRhJyk7XG5cbiAgaWYgKCF2aXN1YWxNZXRhTGlzdCB8fCAhdmlzdWFsTWV0YUxpc3QubGVuZ3RoIHx8ICFkYXRhLmNvdW50KCkpIHtcbiAgICAvLyBXaGVuIGRhdGEuY291bnQoKSBpcyAwLCBncmFkaWVudCByYW5nZSBjYW4gbm90IGJlIGNhbGN1bGF0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZpc3VhbE1ldGE7XG5cbiAgZm9yICh2YXIgaSA9IHZpc3VhbE1ldGFMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gQ2FuIG9ubHkgYmUgeCBvciB5XG4gICAgaWYgKHZpc3VhbE1ldGFMaXN0W2ldLmRpbWVuc2lvbiA8IDIpIHtcbiAgICAgIHZpc3VhbE1ldGEgPSB2aXN1YWxNZXRhTGlzdFtpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdmlzdWFsTWV0YSB8fCBjb29yZFN5cy50eXBlICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIElmIHRoZSBhcmVhIHRvIGJlIHJlbmRlcmVkIGlzIGJpZ2dlciB0aGFuIGFyZWEgZGVmaW5lZCBieSBMaW5lYXJHcmFkaWVudCxcbiAgLy8gdGhlIGNhbnZhcyBzcGVjIHByZXNjcmliZXMgdGhhdCB0aGUgY29sb3Igb2YgdGhlIGZpcnN0IHN0b3AgYW5kIHRoZSBsYXN0XG4gIC8vIHN0b3Agc2hvdWxkIGJlIHVzZWQuIEJ1dCBpZiB0d28gc3RvcHMgYXJlIGFkZGVkIGF0IG9mZnNldCAwLCBpbiBlZmZlY3RcbiAgLy8gYnJvd3NlcnMgdXNlIHRoZSBjb2xvciBvZiB0aGUgc2Vjb25kIHN0b3AgdG8gcmVuZGVyIGFyZWEgb3V0c2lkZVxuICAvLyBMaW5lYXJHcmFkaWVudC4gU28gd2UgY2FuIG9ubHkgaW5maW5pdGVzaW1hbGx5IGV4dGVuZCBhcmVhIGRlZmluZWQgaW5cbiAgLy8gTGluZWFyR3JhZGllbnQgdG8gcmVuZGVyIGBvdXRlckNvbG9yc2AuXG5cblxuICB2YXIgZGltZW5zaW9uID0gdmlzdWFsTWV0YS5kaW1lbnNpb247XG4gIHZhciBkaW1OYW1lID0gZGF0YS5kaW1lbnNpb25zW2RpbWVuc2lvbl07XG4gIHZhciBheGlzID0gY29vcmRTeXMuZ2V0QXhpcyhkaW1OYW1lKTsgLy8gZGF0YVRvQ29vciBtYXBwaW5nIG1heSBub3QgYmUgbGluZWFyLCBidXQgbXVzdCBiZSBtb25vdG9uaWMuXG5cbiAgdmFyIGNvbG9yU3RvcHMgPSB6clV0aWwubWFwKHZpc3VhbE1ldGEuc3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvb3JkOiBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZChzdG9wLnZhbHVlKSksXG4gICAgICBjb2xvcjogc3RvcC5jb2xvclxuICAgIH07XG4gIH0pO1xuICB2YXIgc3RvcExlbiA9IGNvbG9yU3RvcHMubGVuZ3RoO1xuICB2YXIgb3V0ZXJDb2xvcnMgPSB2aXN1YWxNZXRhLm91dGVyQ29sb3JzLnNsaWNlKCk7XG5cbiAgaWYgKHN0b3BMZW4gJiYgY29sb3JTdG9wc1swXS5jb29yZCA+IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLmNvb3JkKSB7XG4gICAgY29sb3JTdG9wcy5yZXZlcnNlKCk7XG4gICAgb3V0ZXJDb2xvcnMucmV2ZXJzZSgpO1xuICB9XG5cbiAgdmFyIHRpbnlFeHRlbnQgPSAxMDsgLy8gQXJiaXRyYXJ5IHZhbHVlOiAxMHB4XG5cbiAgdmFyIG1pbkNvb3JkID0gY29sb3JTdG9wc1swXS5jb29yZCAtIHRpbnlFeHRlbnQ7XG4gIHZhciBtYXhDb29yZCA9IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLmNvb3JkICsgdGlueUV4dGVudDtcbiAgdmFyIGNvb3JkU3BhbiA9IG1heENvb3JkIC0gbWluQ29vcmQ7XG5cbiAgaWYgKGNvb3JkU3BhbiA8IDFlLTMpIHtcbiAgICByZXR1cm4gJ3RyYW5zcGFyZW50JztcbiAgfVxuXG4gIHpyVXRpbC5lYWNoKGNvbG9yU3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgc3RvcC5vZmZzZXQgPSAoc3RvcC5jb29yZCAtIG1pbkNvb3JkKSAvIGNvb3JkU3BhbjtcbiAgfSk7XG4gIGNvbG9yU3RvcHMucHVzaCh7XG4gICAgb2Zmc2V0OiBzdG9wTGVuID8gY29sb3JTdG9wc1tzdG9wTGVuIC0gMV0ub2Zmc2V0IDogMC41LFxuICAgIGNvbG9yOiBvdXRlckNvbG9yc1sxXSB8fCAndHJhbnNwYXJlbnQnXG4gIH0pO1xuICBjb2xvclN0b3BzLnVuc2hpZnQoe1xuICAgIC8vIG5vdGljZSBjb2xvclN0b3BzLmxlbmd0aCBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICBvZmZzZXQ6IHN0b3BMZW4gPyBjb2xvclN0b3BzWzBdLm9mZnNldCA6IDAuNSxcbiAgICBjb2xvcjogb3V0ZXJDb2xvcnNbMF0gfHwgJ3RyYW5zcGFyZW50J1xuICB9KTsgLy8genJVdGlsLmVhY2goY29sb3JTdG9wcywgZnVuY3Rpb24gKGNvbG9yU3RvcCkge1xuICAvLyAgICAgLy8gTWFrZSBzdXJlIGVhY2ggb2Zmc2V0IGhhcyByb3VuZGVkIHB4IHRvIGF2b2lkIG5vdCBzaGFycCBlZGdlXG4gIC8vICAgICBjb2xvclN0b3Aub2Zmc2V0ID0gKE1hdGgucm91bmQoY29sb3JTdG9wLm9mZnNldCAqIChlbmQgLSBzdGFydCkgKyBzdGFydCkgLSBzdGFydCkgLyAoZW5kIC0gc3RhcnQpO1xuICAvLyB9KTtcblxuICB2YXIgZ3JhZGllbnQgPSBuZXcgZ3JhcGhpYy5MaW5lYXJHcmFkaWVudCgwLCAwLCAwLCAwLCBjb2xvclN0b3BzLCB0cnVlKTtcbiAgZ3JhZGllbnRbZGltTmFtZV0gPSBtaW5Db29yZDtcbiAgZ3JhZGllbnRbZGltTmFtZSArICcyJ10gPSBtYXhDb29yZDtcbiAgcmV0dXJuIGdyYWRpZW50O1xufVxuXG52YXIgX2RlZmF1bHQgPSBDaGFydFZpZXcuZXh0ZW5kKHtcbiAgdHlwZTogJ2xpbmUnLFxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpbmVHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdmFyIHN5bWJvbERyYXcgPSBuZXcgU3ltYm9sRHJhdygpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbERyYXcuZ3JvdXApO1xuICAgIHRoaXMuX3N5bWJvbERyYXcgPSBzeW1ib2xEcmF3O1xuICAgIHRoaXMuX2xpbmVHcm91cCA9IGxpbmVHcm91cDtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlLm5vcm1hbCcpO1xuICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUubm9ybWFsJyk7XG4gICAgdmFyIHBvaW50cyA9IGRhdGEubWFwQXJyYXkoZGF0YS5nZXRJdGVtTGF5b3V0LCB0cnVlKTtcbiAgICB2YXIgaXNDb29yZFN5c1BvbGFyID0gY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJztcbiAgICB2YXIgcHJldkNvb3JkU3lzID0gdGhpcy5fY29vcmRTeXM7XG4gICAgdmFyIHN5bWJvbERyYXcgPSB0aGlzLl9zeW1ib2xEcmF3O1xuICAgIHZhciBwb2x5bGluZSA9IHRoaXMuX3BvbHlsaW5lO1xuICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcbiAgICB2YXIgbGluZUdyb3VwID0gdGhpcy5fbGluZUdyb3VwO1xuICAgIHZhciBoYXNBbmltYXRpb24gPSBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpO1xuICAgIHZhciBpc0FyZWFDaGFydCA9ICFhcmVhU3R5bGVNb2RlbC5pc0VtcHR5KCk7XG4gICAgdmFyIHN0YWNrZWRPblBvaW50cyA9IGdldFN0YWNrZWRPblBvaW50cyhjb29yZFN5cywgZGF0YSk7XG4gICAgdmFyIHNob3dTeW1ib2wgPSBzZXJpZXNNb2RlbC5nZXQoJ3Nob3dTeW1ib2wnKTtcblxuICAgIHZhciBpc1N5bWJvbElnbm9yZSA9IHNob3dTeW1ib2wgJiYgIWlzQ29vcmRTeXNQb2xhciAmJiAhc2VyaWVzTW9kZWwuZ2V0KCdzaG93QWxsU3ltYm9sJykgJiYgdGhpcy5fZ2V0U3ltYm9sSWdub3JlRnVuYyhkYXRhLCBjb29yZFN5cyk7IC8vIFJlbW92ZSB0ZW1wb3Jhcnkgc3ltYm9sc1xuXG5cbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgb2xkRGF0YSAmJiBvbGREYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBpZiAoZWwuX190ZW1wKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIG9sZERhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIG51bGwpO1xuICAgICAgfVxuICAgIH0pOyAvLyBSZW1vdmUgcHJldmlvdXMgY3JlYXRlZCBzeW1ib2xzIGlmIHNob3dTeW1ib2wgY2hhbmdlZCB0byBmYWxzZVxuXG4gICAgaWYgKCFzaG93U3ltYm9sKSB7XG4gICAgICBzeW1ib2xEcmF3LnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGdyb3VwLmFkZChsaW5lR3JvdXApOyAvLyBGSVhNRSBzdGVwIG5vdCBzdXBwb3J0IHBvbGFyXG5cbiAgICB2YXIgc3RlcCA9ICFpc0Nvb3JkU3lzUG9sYXIgJiYgc2VyaWVzTW9kZWwuZ2V0KCdzdGVwJyk7IC8vIEluaXRpYWxpemF0aW9uIGFuaW1hdGlvbiBvciBjb29yZGluYXRlIHN5c3RlbSBjaGFuZ2VkXG5cbiAgICBpZiAoIShwb2x5bGluZSAmJiBwcmV2Q29vcmRTeXMudHlwZSA9PT0gY29vcmRTeXMudHlwZSAmJiBzdGVwID09PSB0aGlzLl9zdGVwKSkge1xuICAgICAgc2hvd1N5bWJvbCAmJiBzeW1ib2xEcmF3LnVwZGF0ZURhdGEoZGF0YSwgaXNTeW1ib2xJZ25vcmUpO1xuXG4gICAgICBpZiAoc3RlcCkge1xuICAgICAgICAvLyBUT0RPIElmIHN0YWNrZWQgc2VyaWVzIGlzIG5vdCBzdGVwXG4gICAgICAgIHBvaW50cyA9IHR1cm5Qb2ludHNJbnRvU3RlcChwb2ludHMsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgc3RhY2tlZE9uUG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgfVxuXG4gICAgICBwb2x5bGluZSA9IHRoaXMuX25ld1BvbHlsaW5lKHBvaW50cywgY29vcmRTeXMsIGhhc0FuaW1hdGlvbik7XG5cbiAgICAgIGlmIChpc0FyZWFDaGFydCkge1xuICAgICAgICBwb2x5Z29uID0gdGhpcy5fbmV3UG9seWdvbihwb2ludHMsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGhhc0FuaW1hdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGxpbmVHcm91cC5zZXRDbGlwUGF0aChjcmVhdGVDbGlwU2hhcGUoY29vcmRTeXMsIHRydWUsIHNlcmllc01vZGVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FyZWFDaGFydCAmJiAhcG9seWdvbikge1xuICAgICAgICAvLyBJZiBhcmVhU3R5bGUgaXMgYWRkZWRcbiAgICAgICAgcG9seWdvbiA9IHRoaXMuX25ld1BvbHlnb24ocG9pbnRzLCBzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBoYXNBbmltYXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChwb2x5Z29uICYmICFpc0FyZWFDaGFydCkge1xuICAgICAgICAvLyBJZiBhcmVhU3R5bGUgaXMgcmVtb3ZlZFxuICAgICAgICBsaW5lR3JvdXAucmVtb3ZlKHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uID0gdGhpcy5fcG9seWdvbiA9IG51bGw7XG4gICAgICB9IC8vIFVwZGF0ZSBjbGlwUGF0aFxuXG5cbiAgICAgIGxpbmVHcm91cC5zZXRDbGlwUGF0aChjcmVhdGVDbGlwU2hhcGUoY29vcmRTeXMsIGZhbHNlLCBzZXJpZXNNb2RlbCkpOyAvLyBBbHdheXMgdXBkYXRlLCBvciBpdCBpcyB3cm9uZyBpbiB0aGUgY2FzZSB0dXJuaW5nIG9uIGxlZ2VuZFxuICAgICAgLy8gYmVjYXVzZSBwb2ludHMgYXJlIG5vdCBjaGFuZ2VkXG5cbiAgICAgIHNob3dTeW1ib2wgJiYgc3ltYm9sRHJhdy51cGRhdGVEYXRhKGRhdGEsIGlzU3ltYm9sSWdub3JlKTsgLy8gU3RvcCBzeW1ib2wgYW5pbWF0aW9uIGFuZCBzeW5jIHdpdGggbGluZSBwb2ludHNcbiAgICAgIC8vIEZJWE1FIHBlcmZvcm1hbmNlP1xuXG4gICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgfSk7IC8vIEluIHRoZSBjYXNlIGRhdGEgem9vbSB0cmlnZ2VycmVkIHJlZnJlc2hpbmcgZnJlcXVlbnRseVxuICAgICAgLy8gRGF0YSBtYXkgbm90IGNoYW5nZSBpZiBsaW5lIGhhcyBhIGNhdGVnb3J5IGF4aXMuIFNvIGl0IHNob3VsZCBhbmltYXRlIG5vdGhpbmdcblxuICAgICAgaWYgKCFpc1BvaW50c1NhbWUodGhpcy5fc3RhY2tlZE9uUG9pbnRzLCBzdGFja2VkT25Qb2ludHMpIHx8ICFpc1BvaW50c1NhbWUodGhpcy5fcG9pbnRzLCBwb2ludHMpKSB7XG4gICAgICAgIGlmIChoYXNBbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVBbmltYXRpb24oZGF0YSwgc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgYXBpLCBzdGVwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3QgZG8gaXQgaW4gdXBkYXRlIHdpdGggYW5pbWF0aW9uXG4gICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgICAgIHBvaW50cyA9IHR1cm5Qb2ludHNJbnRvU3RlcChwb2ludHMsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICAgIHN0YWNrZWRPblBvaW50cyA9IHR1cm5Qb2ludHNJbnRvU3RlcChzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb2x5bGluZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvbHlnb24gJiYgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgICAgIHN0YWNrZWRPblBvaW50czogc3RhY2tlZE9uUG9pbnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmlzdWFsQ29sb3IgPSBnZXRWaXN1YWxHcmFkaWVudChkYXRhLCBjb29yZFN5cykgfHwgZGF0YS5nZXRWaXN1YWwoJ2NvbG9yJyk7XG4gICAgcG9seWxpbmUudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKCAvLyBVc2UgY29sb3IgaW4gbGluZVN0eWxlIGZpcnN0XG4gICAgbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksIHtcbiAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgIHN0cm9rZTogdmlzdWFsQ29sb3IsXG4gICAgICBsaW5lSm9pbjogJ2JldmVsJ1xuICAgIH0pKTtcbiAgICB2YXIgc21vb3RoID0gc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGgnKTtcbiAgICBzbW9vdGggPSBnZXRTbW9vdGgoc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGgnKSk7XG4gICAgcG9seWxpbmUuc2V0U2hhcGUoe1xuICAgICAgc21vb3RoOiBzbW9vdGgsXG4gICAgICBzbW9vdGhNb25vdG9uZTogc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGhNb25vdG9uZScpLFxuICAgICAgY29ubmVjdE51bGxzOiBzZXJpZXNNb2RlbC5nZXQoJ2Nvbm5lY3ROdWxscycpXG4gICAgfSk7XG5cbiAgICBpZiAocG9seWdvbikge1xuICAgICAgdmFyIHN0YWNrZWRPbiA9IGRhdGEuc3RhY2tlZE9uO1xuICAgICAgdmFyIHN0YWNrZWRPblNtb290aCA9IDA7XG4gICAgICBwb2x5Z29uLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyhhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKSwge1xuICAgICAgICBmaWxsOiB2aXN1YWxDb2xvcixcbiAgICAgICAgb3BhY2l0eTogMC43LFxuICAgICAgICBsaW5lSm9pbjogJ2JldmVsJ1xuICAgICAgfSkpO1xuXG4gICAgICBpZiAoc3RhY2tlZE9uKSB7XG4gICAgICAgIHZhciBzdGFja2VkT25TZXJpZXMgPSBzdGFja2VkT24uaG9zdE1vZGVsO1xuICAgICAgICBzdGFja2VkT25TbW9vdGggPSBnZXRTbW9vdGgoc3RhY2tlZE9uU2VyaWVzLmdldCgnc21vb3RoJykpO1xuICAgICAgfVxuXG4gICAgICBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgc21vb3RoOiBzbW9vdGgsXG4gICAgICAgIHN0YWNrZWRPblNtb290aDogc3RhY2tlZE9uU21vb3RoLFxuICAgICAgICBzbW9vdGhNb25vdG9uZTogc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGhNb25vdG9uZScpLFxuICAgICAgICBjb25uZWN0TnVsbHM6IHNlcmllc01vZGVsLmdldCgnY29ubmVjdE51bGxzJylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhOyAvLyBTYXZlIHRoZSBjb29yZGluYXRlIHN5c3RlbSBmb3IgdHJhbnNpdGlvbiBhbmltYXRpb24gd2hlbiBkYXRhIGNoYW5nZWRcblxuICAgIHRoaXMuX2Nvb3JkU3lzID0gY29vcmRTeXM7XG4gICAgdGhpcy5fc3RhY2tlZE9uUG9pbnRzID0gc3RhY2tlZE9uUG9pbnRzO1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgfSxcbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge30sXG4gIGhpZ2hsaWdodDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgZGF0YUluZGV4ID0gbW9kZWxVdGlsLnF1ZXJ5RGF0YUluZGV4KGRhdGEsIHBheWxvYWQpO1xuXG4gICAgaWYgKCEoZGF0YUluZGV4IGluc3RhbmNlb2YgQXJyYXkpICYmIGRhdGFJbmRleCAhPSBudWxsICYmIGRhdGFJbmRleCA+PSAwKSB7XG4gICAgICB2YXIgc3ltYm9sID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG5cbiAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBzeW1ib2wgaWYgaXQgaXMgbm90IGV4aXN0c1xuICAgICAgICB2YXIgcHQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcblxuICAgICAgICBpZiAoIXB0KSB7XG4gICAgICAgICAgLy8gTnVsbCBkYXRhXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbENseihkYXRhLCBkYXRhSW5kZXgpO1xuICAgICAgICBzeW1ib2wucG9zaXRpb24gPSBwdDtcbiAgICAgICAgc3ltYm9sLnNldFooc2VyaWVzTW9kZWwuZ2V0KCd6bGV2ZWwnKSwgc2VyaWVzTW9kZWwuZ2V0KCd6JykpO1xuICAgICAgICBzeW1ib2wuaWdub3JlID0gaXNOYU4ocHRbMF0pIHx8IGlzTmFOKHB0WzFdKTtcbiAgICAgICAgc3ltYm9sLl9fdGVtcCA9IHRydWU7XG4gICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIHN5bWJvbCk7IC8vIFN0b3Agc2NhbGUgYW5pbWF0aW9uXG5cbiAgICAgICAgc3ltYm9sLnN0b3BTeW1ib2xBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbCk7XG4gICAgICB9XG5cbiAgICAgIHN5bWJvbC5oaWdobGlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGlnaGxpZ2h0IHdob2xlIHNlcmllc1xuICAgICAgQ2hhcnRWaWV3LnByb3RvdHlwZS5oaWdobGlnaHQuY2FsbCh0aGlzLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB9XG4gIH0sXG4gIGRvd25wbGF5OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgICBpZiAoZGF0YUluZGV4ICE9IG51bGwgJiYgZGF0YUluZGV4ID49IDApIHtcbiAgICAgIHZhciBzeW1ib2wgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcblxuICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICBpZiAoc3ltYm9sLl9fdGVtcCkge1xuICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIG51bGwpO1xuICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlKHN5bWJvbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ltYm9sLmRvd25wbGF5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUVcbiAgICAgIC8vIGNhbiBub3QgZG93bnBsYXkgY29tcGxldGVseS5cbiAgICAgIC8vIERvd25wbGF5IHdob2xlIHNlcmllc1xuICAgICAgQ2hhcnRWaWV3LnByb3RvdHlwZS5kb3ducGxheS5jYWxsKHRoaXMsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcG9pbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbmV3UG9seWxpbmU6IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTsgLy8gUmVtb3ZlIHByZXZpb3VzIGNyZWF0ZWQgcG9seWxpbmVcblxuICAgIGlmIChwb2x5bGluZSkge1xuICAgICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZShwb2x5bGluZSk7XG4gICAgfVxuXG4gICAgcG9seWxpbmUgPSBuZXcgUG9seWxpbmUoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgIH0sXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICB6MjogMTBcbiAgICB9KTtcblxuICAgIHRoaXMuX2xpbmVHcm91cC5hZGQocG9seWxpbmUpO1xuXG4gICAgdGhpcy5fcG9seWxpbmUgPSBwb2x5bGluZTtcbiAgICByZXR1cm4gcG9seWxpbmU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHN0YWNrZWRPblBvaW50c1xuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBvaW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25ld1BvbHlnb246IGZ1bmN0aW9uIChwb2ludHMsIHN0YWNrZWRPblBvaW50cykge1xuICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjsgLy8gUmVtb3ZlIHByZXZpb3VzIGNyZWF0ZWQgcG9seWdvblxuXG4gICAgaWYgKHBvbHlnb24pIHtcbiAgICAgIHRoaXMuX2xpbmVHcm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgfVxuXG4gICAgcG9seWdvbiA9IG5ldyBQb2x5Z29uKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPblBvaW50c1xuICAgICAgfSxcbiAgICAgIHNpbGVudDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdGhpcy5fbGluZUdyb3VwLmFkZChwb2x5Z29uKTtcblxuICAgIHRoaXMuX3BvbHlnb24gPSBwb2x5Z29uO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFN5bWJvbElnbm9yZUZ1bmM6IGZ1bmN0aW9uIChkYXRhLCBjb29yZFN5cykge1xuICAgIHZhciBjYXRlZ29yeUF4aXMgPSBjb29yZFN5cy5nZXRBeGVzQnlTY2FsZSgnb3JkaW5hbCcpWzBdOyAvLyBgZ2V0TGFiZWxJbnRlcnZhbGAgaXMgcHJvdmlkZWQgYnkgZWNoYXJ0cy9jb21wb25lbnQvYXhpc1xuXG4gICAgaWYgKGNhdGVnb3J5QXhpcyAmJiBjYXRlZ29yeUF4aXMuaXNMYWJlbElnbm9yZWQpIHtcbiAgICAgIHJldHVybiB6clV0aWwuYmluZChjYXRlZ29yeUF4aXMuaXNMYWJlbElnbm9yZWQsIGNhdGVnb3J5QXhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLy8gRklYTUUgVHdvIHZhbHVlIGF4aXNcbiAgX3VwZGF0ZUFuaW1hdGlvbjogZnVuY3Rpb24gKGRhdGEsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGFwaSwgc3RlcCkge1xuICAgIHZhciBwb2x5bGluZSA9IHRoaXMuX3BvbHlsaW5lO1xuICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICB2YXIgZGlmZiA9IGxpbmVBbmltYXRpb25EaWZmKHRoaXMuX2RhdGEsIGRhdGEsIHRoaXMuX3N0YWNrZWRPblBvaW50cywgc3RhY2tlZE9uUG9pbnRzLCB0aGlzLl9jb29yZFN5cywgY29vcmRTeXMpO1xuICAgIHZhciBjdXJyZW50ID0gZGlmZi5jdXJyZW50O1xuICAgIHZhciBzdGFja2VkT25DdXJyZW50ID0gZGlmZi5zdGFja2VkT25DdXJyZW50O1xuICAgIHZhciBuZXh0ID0gZGlmZi5uZXh0O1xuICAgIHZhciBzdGFja2VkT25OZXh0ID0gZGlmZi5zdGFja2VkT25OZXh0O1xuXG4gICAgaWYgKHN0ZXApIHtcbiAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgIGN1cnJlbnQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5jdXJyZW50LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICBzdGFja2VkT25DdXJyZW50ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYuc3RhY2tlZE9uQ3VycmVudCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgbmV4dCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLm5leHQsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgIHN0YWNrZWRPbk5leHQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5zdGFja2VkT25OZXh0LCBjb29yZFN5cywgc3RlcCk7XG4gICAgfSAvLyBgZGlmZi5jdXJyZW50YCBpcyBzdWJzZXQgb2YgYGN1cnJlbnRgICh3aGljaCBzaG91bGQgYmUgZW5zdXJlZCBieVxuICAgIC8vIHR1cm5Qb2ludHNJbnRvU3RlcCksIHNvIHBvaW50cyBpbiBgX19wb2ludHNgIGNhbiBiZSB1cGRhdGVkIHdoZW5cbiAgICAvLyBwb2ludHMgaW4gYGN1cnJlbnRgIGFyZSB1cGRhdGUgZHVyaW5nIGFuaW1hdGlvbi5cblxuXG4gICAgcG9seWxpbmUuc2hhcGUuX19wb2ludHMgPSBkaWZmLmN1cnJlbnQ7XG4gICAgcG9seWxpbmUuc2hhcGUucG9pbnRzID0gY3VycmVudDtcbiAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlsaW5lLCB7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IG5leHRcbiAgICAgIH1cbiAgICB9LCBzZXJpZXNNb2RlbCk7XG5cbiAgICBpZiAocG9seWdvbikge1xuICAgICAgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgIHBvaW50czogY3VycmVudCxcbiAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25DdXJyZW50XG4gICAgICB9KTtcbiAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWdvbiwge1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHBvaW50czogbmV4dCxcbiAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPbk5leHRcbiAgICAgICAgfVxuICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVkRGF0YUluZm8gPSBbXTtcbiAgICB2YXIgZGlmZlN0YXR1cyA9IGRpZmYuc3RhdHVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmU3RhdHVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY21kID0gZGlmZlN0YXR1c1tpXS5jbWQ7XG5cbiAgICAgIGlmIChjbWQgPT09ICc9Jykge1xuICAgICAgICB2YXIgZWwgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGlmZlN0YXR1c1tpXS5pZHgxKTtcblxuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICB1cGRhdGVkRGF0YUluZm8ucHVzaCh7XG4gICAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgICBwdElkeDogaSAvLyBJbmRleCBvZiBwb2ludHNcblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvbHlsaW5lLmFuaW1hdG9ycyAmJiBwb2x5bGluZS5hbmltYXRvcnMubGVuZ3RoKSB7XG4gICAgICBwb2x5bGluZS5hbmltYXRvcnNbMF0uZHVyaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVkRGF0YUluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWwgPSB1cGRhdGVkRGF0YUluZm9baV0uZWw7XG4gICAgICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBwb2x5bGluZS5zaGFwZS5fX3BvaW50c1t1cGRhdGVkRGF0YUluZm9baV0ucHRJZHhdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICB0aGlzLl9saW5lR3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICB0aGlzLl9zeW1ib2xEcmF3LnJlbW92ZSh0cnVlKTsgLy8gUmVtb3ZlIHRlbXBvcmFyeSBjcmVhdGVkIGVsZW1lbnRzIHdoZW4gaGlnaGxpZ2h0aW5nXG5cblxuICAgIG9sZERhdGEgJiYgb2xkRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgaWYgKGVsLl9fdGVtcCkge1xuICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICBvbGREYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9wb2x5bGluZSA9IHRoaXMuX3BvbHlnb24gPSB0aGlzLl9jb29yZFN5cyA9IHRoaXMuX3BvaW50cyA9IHRoaXMuX3N0YWNrZWRPblBvaW50cyA9IHRoaXMuX2RhdGEgPSBudWxsO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL0xpbmVWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX21vZGVsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBvdGhlckRpbVRvRGF0YURpbSA9IF9tb2RlbC5vdGhlckRpbVRvRGF0YURpbTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbFxuICovXG5mdW5jdGlvbiBmaW5kTGFiZWxWYWx1ZURpbShkYXRhKSB7XG4gIHZhciB2YWx1ZURpbTtcbiAgdmFyIGxhYmVsRGltcyA9IG90aGVyRGltVG9EYXRhRGltKGRhdGEsICdsYWJlbCcpO1xuXG4gIGlmIChsYWJlbERpbXMubGVuZ3RoKSB7XG4gICAgdmFsdWVEaW0gPSBsYWJlbERpbXNbMF07XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IGxhc3QgdmFsdWUgZGltXG4gICAgdmFyIGRpbWVuc2lvbnMgPSBkYXRhLmRpbWVuc2lvbnMuc2xpY2UoKTtcbiAgICB2YXIgZGF0YVR5cGU7XG5cbiAgICB3aGlsZSAoZGltZW5zaW9ucy5sZW5ndGggJiYgKHZhbHVlRGltID0gZGltZW5zaW9ucy5wb3AoKSwgZGF0YVR5cGUgPSBkYXRhLmdldERpbWVuc2lvbkluZm8odmFsdWVEaW0pLnR5cGUsIGRhdGFUeXBlID09PSAnb3JkaW5hbCcgfHwgZGF0YVR5cGUgPT09ICd0aW1lJykpIHt9IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gIH1cblxuICByZXR1cm4gdmFsdWVEaW07XG59XG5cbmV4cG9ydHMuZmluZExhYmVsVmFsdWVEaW0gPSBmaW5kTGFiZWxWYWx1ZURpbTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvbGFiZWxIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIHZhciBhcnJheURpZmYgPSByZXF1aXJlKCd6cmVuZGVyL3NyYy9jb3JlL2FycmF5RGlmZicpO1xuLy8gJ3pyZW5kZXIvc3JjL2NvcmUvYXJyYXlEaWZmJyBoYXMgYmVlbiB1c2VkIGJlZm9yZSwgYnV0IGl0IGRpZFxuLy8gbm90IGRvIHdlbGwgaW4gcGVyZm9ybWFuY2Ugd2hlbiByb2FtIHdpdGggZml4ZWQgZGF0YVpvb20gd2luZG93LlxuZnVuY3Rpb24gc2lnbih2YWwpIHtcbiAgcmV0dXJuIHZhbCA+PSAwID8gMSA6IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFja2VkT25Qb2ludChjb29yZFN5cywgZGF0YSwgaWR4KSB7XG4gIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gIHZhciB2YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICB2YXIgdmFsdWVTdGFydCA9IGJhc2VBeGlzLm9uWmVybyA/IDAgOiB2YWx1ZUF4aXMuc2NhbGUuZ2V0RXh0ZW50KClbMF07XG4gIHZhciB2YWx1ZURpbSA9IHZhbHVlQXhpcy5kaW07XG4gIHZhciBiYXNlRGF0YU9mZnNldCA9IHZhbHVlRGltID09PSAneCcgfHwgdmFsdWVEaW0gPT09ICdyYWRpdXMnID8gMSA6IDA7XG4gIHZhciBzdGFja2VkT25TYW1lU2lnbjtcbiAgdmFyIHN0YWNrZWRPbiA9IGRhdGEuc3RhY2tlZE9uO1xuICB2YXIgdmFsID0gZGF0YS5nZXQodmFsdWVEaW0sIGlkeCk7IC8vIEZpbmQgZmlyc3Qgc3RhY2tlZCB2YWx1ZSB3aXRoIHNhbWUgc2lnblxuXG4gIHdoaWxlIChzdGFja2VkT24gJiYgc2lnbihzdGFja2VkT24uZ2V0KHZhbHVlRGltLCBpZHgpKSA9PT0gc2lnbih2YWwpKSB7XG4gICAgc3RhY2tlZE9uU2FtZVNpZ24gPSBzdGFja2VkT247XG4gICAgYnJlYWs7XG4gIH1cblxuICB2YXIgc3RhY2tlZERhdGEgPSBbXTtcbiAgc3RhY2tlZERhdGFbYmFzZURhdGFPZmZzZXRdID0gZGF0YS5nZXQoYmFzZUF4aXMuZGltLCBpZHgpO1xuICBzdGFja2VkRGF0YVsxIC0gYmFzZURhdGFPZmZzZXRdID0gc3RhY2tlZE9uU2FtZVNpZ24gPyBzdGFja2VkT25TYW1lU2lnbi5nZXQodmFsdWVEaW0sIGlkeCwgdHJ1ZSkgOiB2YWx1ZVN0YXJ0O1xuICByZXR1cm4gY29vcmRTeXMuZGF0YVRvUG9pbnQoc3RhY2tlZERhdGEpO1xufSAvLyBmdW5jdGlvbiBjb252ZXJ0VG9JbnRJZChuZXdJZExpc3QsIG9sZElkTGlzdCkge1xuLy8gICAgIC8vIEdlbmVyYXRlIGludCBpZCBpbnN0ZWFkIG9mIHN0cmluZyBpZC5cbi8vICAgICAvLyBDb21wYXJlIHN0cmluZyBtYXliZSBzbG93IGluIHNjb3JlIGZ1bmN0aW9uIG9mIGFyckRpZmZcbi8vICAgICAvLyBBc3N1bWUgaWQgaW4gaWRMaXN0IGFyZSBhbGwgdW5pcXVlXG4vLyAgICAgdmFyIGlkSW5kaWNlc01hcCA9IHt9O1xuLy8gICAgIHZhciBpZHggPSAwO1xuLy8gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SWRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgIGlkSW5kaWNlc01hcFtuZXdJZExpc3RbaV1dID0gaWR4O1xuLy8gICAgICAgICBuZXdJZExpc3RbaV0gPSBpZHgrKztcbi8vICAgICB9XG4vLyAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRJZExpc3QubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgdmFyIG9sZElkID0gb2xkSWRMaXN0W2ldO1xuLy8gICAgICAgICAvLyBTYW1lIHdpdGggbmV3SWRMaXN0XG4vLyAgICAgICAgIGlmIChpZEluZGljZXNNYXBbb2xkSWRdKSB7XG4vLyAgICAgICAgICAgICBvbGRJZExpc3RbaV0gPSBpZEluZGljZXNNYXBbb2xkSWRdO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgb2xkSWRMaXN0W2ldID0gaWR4Kys7XG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyB9XG5cblxuZnVuY3Rpb24gZGlmZkRhdGEob2xkRGF0YSwgbmV3RGF0YSkge1xuICB2YXIgZGlmZlJlc3VsdCA9IFtdO1xuICBuZXdEYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICBkaWZmUmVzdWx0LnB1c2goe1xuICAgICAgY21kOiAnKycsXG4gICAgICBpZHg6IGlkeFxuICAgIH0pO1xuICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgZGlmZlJlc3VsdC5wdXNoKHtcbiAgICAgIGNtZDogJz0nLFxuICAgICAgaWR4OiBvbGRJZHgsXG4gICAgICBpZHgxOiBuZXdJZHhcbiAgICB9KTtcbiAgfSkucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICBkaWZmUmVzdWx0LnB1c2goe1xuICAgICAgY21kOiAnLScsXG4gICAgICBpZHg6IGlkeFxuICAgIH0pO1xuICB9KS5leGVjdXRlKCk7XG4gIHJldHVybiBkaWZmUmVzdWx0O1xufVxuXG5mdW5jdGlvbiBfZGVmYXVsdChvbGREYXRhLCBuZXdEYXRhLCBvbGRTdGFja2VkT25Qb2ludHMsIG5ld1N0YWNrZWRPblBvaW50cywgb2xkQ29vcmRTeXMsIG5ld0Nvb3JkU3lzKSB7XG4gIHZhciBkaWZmID0gZGlmZkRhdGEob2xkRGF0YSwgbmV3RGF0YSk7IC8vIHZhciBuZXdJZExpc3QgPSBuZXdEYXRhLm1hcEFycmF5KG5ld0RhdGEuZ2V0SWQpO1xuICAvLyB2YXIgb2xkSWRMaXN0ID0gb2xkRGF0YS5tYXBBcnJheShvbGREYXRhLmdldElkKTtcbiAgLy8gY29udmVydFRvSW50SWQobmV3SWRMaXN0LCBvbGRJZExpc3QpO1xuICAvLyAvLyBGSVhNRSBPbmUgZGF0YSA/XG4gIC8vIGRpZmYgPSBhcnJheURpZmYob2xkSWRMaXN0LCBuZXdJZExpc3QpO1xuXG4gIHZhciBjdXJyUG9pbnRzID0gW107XG4gIHZhciBuZXh0UG9pbnRzID0gW107IC8vIFBvaW50cyBmb3Igc3RhY2tpbmcgYmFzZSBsaW5lXG5cbiAgdmFyIGN1cnJTdGFja2VkUG9pbnRzID0gW107XG4gIHZhciBuZXh0U3RhY2tlZFBvaW50cyA9IFtdO1xuICB2YXIgc3RhdHVzID0gW107XG4gIHZhciBzb3J0ZWRJbmRpY2VzID0gW107XG4gIHZhciByYXdJbmRpY2VzID0gW107XG4gIHZhciBkaW1zID0gbmV3Q29vcmRTeXMuZGltZW5zaW9ucztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlmZkl0ZW0gPSBkaWZmW2ldO1xuICAgIHZhciBwb2ludEFkZGVkID0gdHJ1ZTsgLy8gRklYTUUsIGFuaW1hdGlvbiBpcyBub3Qgc28gcGVyZmVjdCB3aGVuIGRhdGFab29tIHdpbmRvdyBtb3ZlcyBmYXN0XG4gICAgLy8gV2hpY2ggaXMgaW4gY2FzZSByZW12b2luZyBvciBhZGQgbW9yZSB0aGFuIG9uZSBkYXRhIGluIHRoZSB0YWlsIG9yIGhlYWRcblxuICAgIHN3aXRjaCAoZGlmZkl0ZW0uY21kKSB7XG4gICAgICBjYXNlICc9JzpcbiAgICAgICAgdmFyIGN1cnJlbnRQdCA9IG9sZERhdGEuZ2V0SXRlbUxheW91dChkaWZmSXRlbS5pZHgpO1xuICAgICAgICB2YXIgbmV4dFB0ID0gbmV3RGF0YS5nZXRJdGVtTGF5b3V0KGRpZmZJdGVtLmlkeDEpOyAvLyBJZiBwcmV2aW91cyBkYXRhIGlzIE5hTiwgdXNlIG5leHQgcG9pbnQgZGlyZWN0bHlcblxuICAgICAgICBpZiAoaXNOYU4oY3VycmVudFB0WzBdKSB8fCBpc05hTihjdXJyZW50UHRbMV0pKSB7XG4gICAgICAgICAgY3VycmVudFB0ID0gbmV4dFB0LnNsaWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyUG9pbnRzLnB1c2goY3VycmVudFB0KTtcbiAgICAgICAgbmV4dFBvaW50cy5wdXNoKG5leHRQdCk7XG4gICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2gob2xkU3RhY2tlZE9uUG9pbnRzW2RpZmZJdGVtLmlkeF0pO1xuICAgICAgICBuZXh0U3RhY2tlZFBvaW50cy5wdXNoKG5ld1N0YWNrZWRPblBvaW50c1tkaWZmSXRlbS5pZHgxXSk7XG4gICAgICAgIHJhd0luZGljZXMucHVzaChuZXdEYXRhLmdldFJhd0luZGV4KGRpZmZJdGVtLmlkeDEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgICB2YXIgaWR4ID0gZGlmZkl0ZW0uaWR4O1xuICAgICAgICBjdXJyUG9pbnRzLnB1c2gob2xkQ29vcmRTeXMuZGF0YVRvUG9pbnQoW25ld0RhdGEuZ2V0KGRpbXNbMF0sIGlkeCwgdHJ1ZSksIG5ld0RhdGEuZ2V0KGRpbXNbMV0sIGlkeCwgdHJ1ZSldKSk7XG4gICAgICAgIG5leHRQb2ludHMucHVzaChuZXdEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KS5zbGljZSgpKTtcbiAgICAgICAgY3VyclN0YWNrZWRQb2ludHMucHVzaChnZXRTdGFja2VkT25Qb2ludChvbGRDb29yZFN5cywgbmV3RGF0YSwgaWR4KSk7XG4gICAgICAgIG5leHRTdGFja2VkUG9pbnRzLnB1c2gobmV3U3RhY2tlZE9uUG9pbnRzW2lkeF0pO1xuICAgICAgICByYXdJbmRpY2VzLnB1c2gobmV3RGF0YS5nZXRSYXdJbmRleChpZHgpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJy0nOlxuICAgICAgICB2YXIgaWR4ID0gZGlmZkl0ZW0uaWR4O1xuICAgICAgICB2YXIgcmF3SW5kZXggPSBvbGREYXRhLmdldFJhd0luZGV4KGlkeCk7IC8vIERhdGEgaXMgcmVwbGFjZWQuIEluIHRoZSBjYXNlIG9mIGR5bmFtaWMgZGF0YSBxdWV1ZVxuICAgICAgICAvLyBGSVhNRSBGSVhNRSBGSVhNRVxuXG4gICAgICAgIGlmIChyYXdJbmRleCAhPT0gaWR4KSB7XG4gICAgICAgICAgY3VyclBvaW50cy5wdXNoKG9sZERhdGEuZ2V0SXRlbUxheW91dChpZHgpKTtcbiAgICAgICAgICBuZXh0UG9pbnRzLnB1c2gobmV3Q29vcmRTeXMuZGF0YVRvUG9pbnQoW29sZERhdGEuZ2V0KGRpbXNbMF0sIGlkeCwgdHJ1ZSksIG9sZERhdGEuZ2V0KGRpbXNbMV0sIGlkeCwgdHJ1ZSldKSk7XG4gICAgICAgICAgY3VyclN0YWNrZWRQb2ludHMucHVzaChvbGRTdGFja2VkT25Qb2ludHNbaWR4XSk7XG4gICAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChnZXRTdGFja2VkT25Qb2ludChuZXdDb29yZFN5cywgb2xkRGF0YSwgaWR4KSk7XG4gICAgICAgICAgcmF3SW5kaWNlcy5wdXNoKHJhd0luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludEFkZGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgIH0gLy8gT3JpZ2luYWwgaW5kaWNlc1xuXG5cbiAgICBpZiAocG9pbnRBZGRlZCkge1xuICAgICAgc3RhdHVzLnB1c2goZGlmZkl0ZW0pO1xuICAgICAgc29ydGVkSW5kaWNlcy5wdXNoKHNvcnRlZEluZGljZXMubGVuZ3RoKTtcbiAgICB9XG4gIH0gLy8gRGlmZiByZXN1bHQgbWF5IGJlIGNyb3NzZWQgaWYgYWxsIGl0ZW1zIGFyZSBjaGFuZ2VkXG4gIC8vIFNvcnQgYnkgZGF0YSBpbmRleFxuXG5cbiAgc29ydGVkSW5kaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIHJhd0luZGljZXNbYV0gLSByYXdJbmRpY2VzW2JdO1xuICB9KTtcbiAgdmFyIHNvcnRlZEN1cnJQb2ludHMgPSBbXTtcbiAgdmFyIHNvcnRlZE5leHRQb2ludHMgPSBbXTtcbiAgdmFyIHNvcnRlZEN1cnJTdGFja2VkUG9pbnRzID0gW107XG4gIHZhciBzb3J0ZWROZXh0U3RhY2tlZFBvaW50cyA9IFtdO1xuICB2YXIgc29ydGVkU3RhdHVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlkeCA9IHNvcnRlZEluZGljZXNbaV07XG4gICAgc29ydGVkQ3VyclBvaW50c1tpXSA9IGN1cnJQb2ludHNbaWR4XTtcbiAgICBzb3J0ZWROZXh0UG9pbnRzW2ldID0gbmV4dFBvaW50c1tpZHhdO1xuICAgIHNvcnRlZEN1cnJTdGFja2VkUG9pbnRzW2ldID0gY3VyclN0YWNrZWRQb2ludHNbaWR4XTtcbiAgICBzb3J0ZWROZXh0U3RhY2tlZFBvaW50c1tpXSA9IG5leHRTdGFja2VkUG9pbnRzW2lkeF07XG4gICAgc29ydGVkU3RhdHVzW2ldID0gc3RhdHVzW2lkeF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IHNvcnRlZEN1cnJQb2ludHMsXG4gICAgbmV4dDogc29ydGVkTmV4dFBvaW50cyxcbiAgICBzdGFja2VkT25DdXJyZW50OiBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50cyxcbiAgICBzdGFja2VkT25OZXh0OiBzb3J0ZWROZXh0U3RhY2tlZFBvaW50cyxcbiAgICBzdGF0dXM6IHNvcnRlZFN0YXR1c1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvbGluZUFuaW1hdGlvbkRpZmYuanNcbi8vIG1vZHVsZSBpZCA9IDI1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBQYXRoID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS92ZWN0b3JcIik7XG5cbnZhciBmaXhDbGlwV2l0aFNoYWRvdyA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvd1wiKTtcblxuLy8gUG9seSBwYXRoIHN1cHBvcnQgTmFOIHBvaW50XG52YXIgdmVjMk1pbiA9IHZlYzIubWluO1xudmFyIHZlYzJNYXggPSB2ZWMyLm1heDtcbnZhciBzY2FsZUFuZEFkZCA9IHZlYzIuc2NhbGVBbmRBZGQ7XG52YXIgdjJDb3B5ID0gdmVjMi5jb3B5OyAvLyBUZW1wb3JhcnkgdmFyaWFibGVcblxudmFyIHYgPSBbXTtcbnZhciBjcDAgPSBbXTtcbnZhciBjcDEgPSBbXTtcblxuZnVuY3Rpb24gaXNQb2ludE51bGwocCkge1xuICByZXR1cm4gaXNOYU4ocFswXSkgfHwgaXNOYU4ocFsxXSk7XG59XG5cbmZ1bmN0aW9uIGRyYXdTZWdtZW50KGN0eCwgcG9pbnRzLCBzdGFydCwgc2VnTGVuLCBhbGxMZW4sIGRpciwgc21vb3RoTWluLCBzbW9vdGhNYXgsIHNtb290aCwgc21vb3RoTW9ub3RvbmUsIGNvbm5lY3ROdWxscykge1xuICB2YXIgcHJldklkeCA9IDA7XG4gIHZhciBpZHggPSBzdGFydDtcblxuICBmb3IgKHZhciBrID0gMDsgayA8IHNlZ0xlbjsgaysrKSB7XG4gICAgdmFyIHAgPSBwb2ludHNbaWR4XTtcblxuICAgIGlmIChpZHggPj0gYWxsTGVuIHx8IGlkeCA8IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpc1BvaW50TnVsbChwKSkge1xuICAgICAgaWYgKGNvbm5lY3ROdWxscykge1xuICAgICAgICBpZHggKz0gZGlyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlkeCA9PT0gc3RhcnQpIHtcbiAgICAgIGN0eFtkaXIgPiAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10ocFswXSwgcFsxXSk7XG4gICAgICB2MkNvcHkoY3AwLCBwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNtb290aCA+IDApIHtcbiAgICAgICAgdmFyIG5leHRJZHggPSBpZHggKyBkaXI7XG4gICAgICAgIHZhciBuZXh0UCA9IHBvaW50c1tuZXh0SWR4XTtcblxuICAgICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgLy8gRmluZCBuZXh0IHBvaW50IG5vdCBudWxsXG4gICAgICAgICAgd2hpbGUgKG5leHRQICYmIGlzUG9pbnROdWxsKHBvaW50c1tuZXh0SWR4XSkpIHtcbiAgICAgICAgICAgIG5leHRJZHggKz0gZGlyO1xuICAgICAgICAgICAgbmV4dFAgPSBwb2ludHNbbmV4dElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhdGlvTmV4dFNlZyA9IDAuNTtcbiAgICAgICAgdmFyIHByZXZQID0gcG9pbnRzW3ByZXZJZHhdO1xuICAgICAgICB2YXIgbmV4dFAgPSBwb2ludHNbbmV4dElkeF07IC8vIExhc3QgcG9pbnRcblxuICAgICAgICBpZiAoIW5leHRQIHx8IGlzUG9pbnROdWxsKG5leHRQKSkge1xuICAgICAgICAgIHYyQ29weShjcDEsIHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5leHQgZGF0YSBpcyBudWxsIGluIG5vdCBjb25uZWN0IGNhc2VcbiAgICAgICAgICBpZiAoaXNQb2ludE51bGwobmV4dFApICYmICFjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAgIG5leHRQID0gcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2ZWMyLnN1Yih2LCBuZXh0UCwgcHJldlApO1xuICAgICAgICAgIHZhciBsZW5QcmV2U2VnO1xuICAgICAgICAgIHZhciBsZW5OZXh0U2VnO1xuXG4gICAgICAgICAgaWYgKHNtb290aE1vbm90b25lID09PSAneCcgfHwgc21vb3RoTW9ub3RvbmUgPT09ICd5Jykge1xuICAgICAgICAgICAgdmFyIGRpbSA9IHNtb290aE1vbm90b25lID09PSAneCcgPyAwIDogMTtcbiAgICAgICAgICAgIGxlblByZXZTZWcgPSBNYXRoLmFicyhwW2RpbV0gLSBwcmV2UFtkaW1dKTtcbiAgICAgICAgICAgIGxlbk5leHRTZWcgPSBNYXRoLmFicyhwW2RpbV0gLSBuZXh0UFtkaW1dKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuUHJldlNlZyA9IHZlYzIuZGlzdChwLCBwcmV2UCk7XG4gICAgICAgICAgICBsZW5OZXh0U2VnID0gdmVjMi5kaXN0KHAsIG5leHRQKTtcbiAgICAgICAgICB9IC8vIFVzZSByYXRpbyBvZiBzZWcgbGVuZ3RoXG5cblxuICAgICAgICAgIHJhdGlvTmV4dFNlZyA9IGxlbk5leHRTZWcgLyAobGVuTmV4dFNlZyArIGxlblByZXZTZWcpO1xuICAgICAgICAgIHNjYWxlQW5kQWRkKGNwMSwgcCwgdiwgLXNtb290aCAqICgxIC0gcmF0aW9OZXh0U2VnKSk7XG4gICAgICAgIH0gLy8gU21vb3RoIGNvbnN0cmFpbnRcblxuXG4gICAgICAgIHZlYzJNaW4oY3AwLCBjcDAsIHNtb290aE1heCk7XG4gICAgICAgIHZlYzJNYXgoY3AwLCBjcDAsIHNtb290aE1pbik7XG4gICAgICAgIHZlYzJNaW4oY3AxLCBjcDEsIHNtb290aE1heCk7XG4gICAgICAgIHZlYzJNYXgoY3AxLCBjcDEsIHNtb290aE1pbik7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNwMFswXSwgY3AwWzFdLCBjcDFbMF0sIGNwMVsxXSwgcFswXSwgcFsxXSk7IC8vIGNwMCBvZiBuZXh0IHNlZ21lbnRcblxuICAgICAgICBzY2FsZUFuZEFkZChjcDAsIHAsIHYsIHNtb290aCAqIHJhdGlvTmV4dFNlZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZJZHggPSBpZHg7XG4gICAgaWR4ICs9IGRpcjtcbiAgfVxuXG4gIHJldHVybiBrO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0JveChwb2ludHMsIHNtb290aENvbnN0cmFpbnQpIHtcbiAgdmFyIHB0TWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gIHZhciBwdE1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgaWYgKHNtb290aENvbnN0cmFpbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuXG4gICAgICBpZiAocHRbMF0gPCBwdE1pblswXSkge1xuICAgICAgICBwdE1pblswXSA9IHB0WzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHRbMV0gPCBwdE1pblsxXSkge1xuICAgICAgICBwdE1pblsxXSA9IHB0WzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHRbMF0gPiBwdE1heFswXSkge1xuICAgICAgICBwdE1heFswXSA9IHB0WzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHRbMV0gPiBwdE1heFsxXSkge1xuICAgICAgICBwdE1heFsxXSA9IHB0WzFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiBzbW9vdGhDb25zdHJhaW50ID8gcHRNaW4gOiBwdE1heCxcbiAgICBtYXg6IHNtb290aENvbnN0cmFpbnQgPyBwdE1heCA6IHB0TWluXG4gIH07XG59XG5cbnZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2VjLXBvbHlsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IFtdLFxuICAgIHNtb290aDogMCxcbiAgICBzbW9vdGhDb25zdHJhaW50OiB0cnVlLFxuICAgIHNtb290aE1vbm90b25lOiBudWxsLFxuICAgIGNvbm5lY3ROdWxsczogZmFsc2VcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBmaWxsOiBudWxsLFxuICAgIHN0cm9rZTogJyMwMDAnXG4gIH0sXG4gIGJydXNoOiBmaXhDbGlwV2l0aFNoYWRvdyhQYXRoLnByb3RvdHlwZS5icnVzaCksXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gZ2V0Qm91bmRpbmdCb3gocG9pbnRzLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcblxuICAgIGlmIChzaGFwZS5jb25uZWN0TnVsbHMpIHtcbiAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgZm9yICg7IGxlbiA+IDA7IGxlbi0tKSB7XG4gICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAtIDFdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc1BvaW50TnVsbChwb2ludHNbaV0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaSArPSBkcmF3U2VnbWVudChjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sIDEsIHJlc3VsdC5taW4sIHJlc3VsdC5tYXgsIHNoYXBlLnNtb290aCwgc2hhcGUuc21vb3RoTW9ub3RvbmUsIHNoYXBlLmNvbm5lY3ROdWxscykgKyAxO1xuICAgIH1cbiAgfVxufSk7XG52YXIgUG9seWdvbiA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2VjLXBvbHlnb24nLFxuICBzaGFwZToge1xuICAgIHBvaW50czogW10sXG4gICAgLy8gT2Zmc2V0IGJldHdlZW4gc3RhY2tlZCBiYXNlIHBvaW50cyBhbmQgcG9pbnRzXG4gICAgc3RhY2tlZE9uUG9pbnRzOiBbXSxcbiAgICBzbW9vdGg6IDAsXG4gICAgc3RhY2tlZE9uU21vb3RoOiAwLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IHRydWUsXG4gICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG4gICAgY29ubmVjdE51bGxzOiBmYWxzZVxuICB9LFxuICBicnVzaDogZml4Q2xpcFdpdGhTaGFkb3coUGF0aC5wcm90b3R5cGUuYnJ1c2gpLFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICB2YXIgc3RhY2tlZE9uUG9pbnRzID0gc2hhcGUuc3RhY2tlZE9uUG9pbnRzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgc21vb3RoTW9ub3RvbmUgPSBzaGFwZS5zbW9vdGhNb25vdG9uZTtcbiAgICB2YXIgYmJveCA9IGdldEJvdW5kaW5nQm94KHBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG4gICAgdmFyIHN0YWNrZWRPbkJCb3ggPSBnZXRCb3VuZGluZ0JveChzdGFja2VkT25Qb2ludHMsIHNoYXBlLnNtb290aENvbnN0cmFpbnQpO1xuXG4gICAgaWYgKHNoYXBlLmNvbm5lY3ROdWxscykge1xuICAgICAgLy8gTXVzdCByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbnVsbCB2YWx1ZXMgYXZvaWQgZHJhdyBlcnJvciBpbiBwb2x5Z29uXG4gICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgaWYgKCFpc1BvaW50TnVsbChwb2ludHNbbGVuIC0gMV0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWlzUG9pbnROdWxsKHBvaW50c1tpXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YXIgayA9IGRyYXdTZWdtZW50KGN0eCwgcG9pbnRzLCBpLCBsZW4sIGxlbiwgMSwgYmJveC5taW4sIGJib3gubWF4LCBzaGFwZS5zbW9vdGgsIHNtb290aE1vbm90b25lLCBzaGFwZS5jb25uZWN0TnVsbHMpO1xuICAgICAgZHJhd1NlZ21lbnQoY3R4LCBzdGFja2VkT25Qb2ludHMsIGkgKyBrIC0gMSwgaywgbGVuLCAtMSwgc3RhY2tlZE9uQkJveC5taW4sIHN0YWNrZWRPbkJCb3gubWF4LCBzaGFwZS5zdGFja2VkT25TbW9vdGgsIHNtb290aE1vbm90b25lLCBzaGFwZS5jb25uZWN0TnVsbHMpO1xuICAgICAgaSArPSBrICsgMTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbn0pO1xuZXhwb3J0cy5Qb2x5bGluZSA9IFBvbHlsaW5lO1xuZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL3BvbHkuanNcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImZ1bmN0aW9uIF9kZWZhdWx0KHNlcmllc1R5cGUsIGRlZmF1bHRTeW1ib2xUeXBlLCBsZWdlbmRTeW1ib2wsIGVjTW9kZWwsIGFwaSkge1xuICAvLyBFbmNvZGluZyB2aXN1YWwgZm9yIGFsbCBzZXJpZXMgaW5jbHVkZSB3aGljaCBpcyBmaWx0ZXJlZCBmb3IgbGVnZW5kIGRyYXdpbmdcbiAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBzeW1ib2xUeXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdzeW1ib2wnKSB8fCBkZWZhdWx0U3ltYm9sVHlwZTtcbiAgICB2YXIgc3ltYm9sU2l6ZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuICAgIGRhdGEuc2V0VmlzdWFsKHtcbiAgICAgIGxlZ2VuZFN5bWJvbDogbGVnZW5kU3ltYm9sIHx8IHN5bWJvbFR5cGUsXG4gICAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgICBzeW1ib2xTaXplOiBzeW1ib2xTaXplXG4gICAgfSk7IC8vIE9ubHkgdmlzaWJsZSBzZXJpZXMgaGFzIGVhY2ggZGF0YSBiZSB2aXN1YWwgZW5jb2RlZFxuXG4gICAgaWYgKCFlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICBpZiAodHlwZW9mIHN5bWJvbFNpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICB2YXIgcmF3VmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpZHgpOyAvLyBGSVhNRVxuXG4gICAgICAgICAgdmFyIHBhcmFtcyA9IHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoaWR4KTtcbiAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScsIHN5bWJvbFNpemUocmF3VmFsdWUsIHBhcmFtcykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgIHZhciBpdGVtU3ltYm9sVHlwZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2wnLCB0cnVlKTtcbiAgICAgICAgdmFyIGl0ZW1TeW1ib2xTaXplID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFNpemUnLCB0cnVlKTsgLy8gSWYgaGFzIGl0ZW0gc3ltYm9sXG5cbiAgICAgICAgaWYgKGl0ZW1TeW1ib2xUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJywgaXRlbVN5bWJvbFR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1TeW1ib2xTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBQRU5ESU5HIFRyYW5zZm9ybSBzeW1ib2xTaXplID9cbiAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScsIGl0ZW1TeW1ib2xTaXplKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJmdW5jdGlvbiBfZGVmYXVsdChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgaWYgKCFjb29yZFN5cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaW1zID0gW107XG4gICAgdmFyIGNvb3JkRGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkRGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGltcy5wdXNoKHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGNvb3JkU3lzLmRpbWVuc2lvbnNbaV0pWzBdKTtcbiAgICB9XG5cbiAgICBpZiAoZGltcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRhdGEuZWFjaChkaW1zWzBdLCBmdW5jdGlvbiAoeCwgaWR4KSB7XG4gICAgICAgIC8vIEFsc28ge0FycmF5LjxudW1iZXI+fSwgbm90IHVuZGVmaW5lZCB0byBhdm9pZCBpZi4uLmVsc2UuLi4gc3RhdGVtZW50XG4gICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIGlzTmFOKHgpID8gW05hTiwgTmFOXSA6IGNvb3JkU3lzLmRhdGFUb1BvaW50KHgpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGltcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGRhdGEuZWFjaChkaW1zLCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICAgIC8vIEFsc28ge0FycmF5LjxudW1iZXI+fSwgbm90IHVuZGVmaW5lZCB0byBhdm9pZCBpZi4uLmVsc2UuLi4gc3RhdGVtZW50XG4gICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIGlzTmFOKHgpIHx8IGlzTmFOKHkpID8gW05hTiwgTmFOXSA6IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSkpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYXlvdXQvcG9pbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgc2FtcGxlcnMgPSB7XG4gIGF2ZXJhZ2U6IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzTmFOKGZyYW1lW2ldKSkge1xuICAgICAgICBzdW0gKz0gZnJhbWVbaV07XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSAvLyBSZXR1cm4gTmFOIGlmIGNvdW50IGlzIDBcblxuXG4gICAgcmV0dXJuIGNvdW50ID09PSAwID8gTmFOIDogc3VtIC8gY291bnQ7XG4gIH0sXG4gIHN1bTogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgdmFyIHN1bSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBJZ25vcmUgTmFOXG4gICAgICBzdW0gKz0gZnJhbWVbaV0gfHwgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtO1xuICB9LFxuICBtYXg6IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFtZVtpXSA+IG1heCAmJiAobWF4ID0gZnJhbWVbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXg7XG4gIH0sXG4gIG1pbjogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhbWVbaV0gPCBtaW4gJiYgKG1pbiA9IGZyYW1lW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9LFxuICAvLyBUT0RPXG4gIC8vIE1lZGlhblxuICBuZWFyZXN0OiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICByZXR1cm4gZnJhbWVbMF07XG4gIH1cbn07XG5cbnZhciBpbmRleFNhbXBsZXIgPSBmdW5jdGlvbiAoZnJhbWUsIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGZyYW1lLmxlbmd0aCAvIDIpO1xufTtcblxuZnVuY3Rpb24gX2RlZmF1bHQoc2VyaWVzVHlwZSwgZWNNb2RlbCwgYXBpKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgc2FtcGxpbmcgPSBzZXJpZXNNb2RlbC5nZXQoJ3NhbXBsaW5nJyk7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTsgLy8gT25seSBjYXJ0ZXNpYW4yZCBzdXBwb3J0IGRvd24gc2FtcGxpbmdcblxuICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnICYmIHNhbXBsaW5nKSB7XG4gICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICB2YXIgZXh0ZW50ID0gYmFzZUF4aXMuZ2V0RXh0ZW50KCk7IC8vIENvb3JkaW5zdGUgc3lzdGVtIGhhcyBiZWVuIHJlc2l6ZWRcblxuICAgICAgdmFyIHNpemUgPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICB2YXIgcmF0ZSA9IE1hdGgucm91bmQoZGF0YS5jb3VudCgpIC8gc2l6ZSk7XG5cbiAgICAgIGlmIChyYXRlID4gMSkge1xuICAgICAgICB2YXIgc2FtcGxlcjtcblxuICAgICAgICBpZiAodHlwZW9mIHNhbXBsaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHNhbXBsZXIgPSBzYW1wbGVyc1tzYW1wbGluZ107XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNhbXBsaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FtcGxlciA9IHNhbXBsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNhbXBsZXIpIHtcbiAgICAgICAgICBkYXRhID0gZGF0YS5kb3duU2FtcGxlKHZhbHVlQXhpcy5kaW0sIDEgLyByYXRlLCBzYW1wbGVyLCBpbmRleFNhbXBsZXIpO1xuICAgICAgICAgIHNlcmllc01vZGVsLnNldERhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG5yZXF1aXJlKFwiLi9heGlzUG9pbnRlclwiKTtcblxucmVxdWlyZShcIi4vdG9vbHRpcC9Ub29sdGlwTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL3Rvb2x0aXAvVG9vbHRpcFZpZXdcIik7XG5cbi8vIEZJWE1FIEJldHRlciB3YXkgdG8gcGFjayBkYXRhIGluIGdyYXBoaWMgZWxlbWVudFxuXG4vKipcbiAqIEBhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2VyaWVzSW5kZXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeV1cbiAqL1xuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICdzaG93VGlwJyxcbiAgZXZlbnQ6ICdzaG93VGlwJyxcbiAgdXBkYXRlOiAndG9vbHRpcDptYW51YWxseVNob3dUaXAnXG59LCAvLyBub29wXG5mdW5jdGlvbiAoKSB7fSk7XG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ2hpZGVUaXAnLFxuICBldmVudDogJ2hpZGVUaXAnLFxuICB1cGRhdGU6ICd0b29sdGlwOm1hbnVhbGx5SGlkZVRpcCdcbn0sIC8vIG5vb3BcbmZ1bmN0aW9uICgpIHt9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC5qc1xuLy8gbW9kdWxlIGlkID0gMjY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBheGlzUG9pbnRlck1vZGVsSGVscGVyID0gcmVxdWlyZShcIi4vYXhpc1BvaW50ZXIvbW9kZWxIZWxwZXJcIik7XG5cbnZhciBheGlzVHJpZ2dlciA9IHJlcXVpcmUoXCIuL2F4aXNQb2ludGVyL2F4aXNUcmlnZ2VyXCIpO1xuXG5yZXF1aXJlKFwiLi9heGlzUG9pbnRlci9BeGlzUG9pbnRlck1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL2F4aXNQb2ludGVyL0NhcnRlc2lhbkF4aXNQb2ludGVyXCIpO1xuXG4vLyBDYXJ0ZXNpYW5BeGlzUG9pbnRlciBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgcmVxdWlyZWQgaGVyZS4gQnV0IGNvbnNpZGVyXG4vLyBlY2hhcnRzLnNpbXBsZS5qcyBhbmQgb25saW5lIGJ1aWxkIHRvb2x0aXAsIHdoaWNoIG9ubHkgcmVxdWlyZSBncmlkU2ltcGxlLFxuLy8gQ2FydGVzaWFuQXhpc1BvaW50ZXIgc2hvdWxkIGJlIGFibGUgdG8gcmVxdWlyZWQgc29tZXdoZXJlLlxuZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gIC8vIEFsd2F5cyBoYXMgYSBnbG9iYWwgYXhpc1BvaW50ZXJNb2RlbCBmb3IgZGVmYXVsdCBzZXR0aW5nLlxuICBpZiAob3B0aW9uKSB7XG4gICAgKCFvcHRpb24uYXhpc1BvaW50ZXIgfHwgb3B0aW9uLmF4aXNQb2ludGVyLmxlbmd0aCA9PT0gMCkgJiYgKG9wdGlvbi5heGlzUG9pbnRlciA9IHt9KTtcbiAgICB2YXIgbGluayA9IG9wdGlvbi5heGlzUG9pbnRlci5saW5rOyAvLyBOb3JtYWxpemUgdG8gYXJyYXkgdG8gYXZvaWQgb2JqZWN0IG1lcmdpbi4gQnV0IGlmIGxpbmtcbiAgICAvLyBpcyBub3Qgc2V0LCByZW1haW4gbnVsbC91bmRlZmluZWQsIG90aGVyd2lzZSBpdCB3aWxsXG4gICAgLy8gb3ZlcnJpZGUgZXhpc3RlbnQgbGluayBzZXR0aW5nLlxuXG4gICAgaWYgKGxpbmsgJiYgIXpyVXRpbC5pc0FycmF5KGxpbmspKSB7XG4gICAgICBvcHRpb24uYXhpc1BvaW50ZXIubGluayA9IFtsaW5rXTtcbiAgICB9XG4gIH1cbn0pOyAvLyBUaGlzIHByb2Nlc3Mgc2hvdWxkIHByb2Zvcm1lZCBhZnRlciBjb29yZGluYXRlIHN5c3RlbXMgY3JlYXRlZFxuLy8gYW5kIHNlcmllcyBkYXRhIHByb2Nlc3NlZC4gU28gcHV0IGl0IG9uIHN0YXRpc3RpYyBwcm9jZXNzaW5nIHN0YWdlLlxuXG5lY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKGVjaGFydHMuUFJJT1JJVFkuUFJPQ0VTU09SLlNUQVRJU1RJQywgZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAvLyBCdWlsZCBheGlzUG9pbnRlck1vZGVsLCBtZXJnaW4gdG9vbHRpcC5heGlzUG9pbnRlciBtb2RlbCBmb3IgZWFjaCBheGlzLlxuICAvLyBhbGxBeGVzSW5mbyBzaG91bGQgYmUgdXBkYXRlZCB3aGVuIHNldE9wdGlvbiBwZXJmb3JtZWQuXG4gIGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpLmNvb3JkU3lzQXhlc0luZm8gPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmNvbGxlY3QoZWNNb2RlbCwgYXBpKTtcbn0pOyAvLyBCcm9hZGNhc3QgdG8gYWxsIHZpZXdzLlxuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgZXZlbnQ6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gIHVwZGF0ZTogJzp1cGRhdGVBeGlzUG9pbnRlcidcbn0sIGF4aXNUcmlnZ2VyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBtb2RlbEhlbHBlciA9IHJlcXVpcmUoXCIuL21vZGVsSGVscGVyXCIpO1xuXG52YXIgZmluZFBvaW50RnJvbVNlcmllcyA9IHJlcXVpcmUoXCIuL2ZpbmRQb2ludEZyb21TZXJpZXNcIik7XG5cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG52YXIgZ2V0ID0gbW9kZWxVdGlsLm1ha2VHZXR0ZXIoKTtcbi8qKlxuICogQmFzaWMgbG9naWM6IGNoZWNrIGFsbCBheGlzLCBpZiB0aGV5IGRvIG5vdCBkZW1hbmQgc2hvdy9oaWdobGlnaHQsXG4gKiB0aGVuIGhpZGUvZG93bnBsYXkgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29vcmRTeXNBeGVzSW5mb1xuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bG9hZC5jdXJyVHJpZ2dlcl0gJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ2xlYXZlJ1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3BheWxvYWQueF0geCBhbmQgeSwgd2hpY2ggYXJlIG1hbmRhdG9yeSwgc3BlY2lmeSBhIHBvaW50IHRvXG4gKiAgICAgICAgICAgICAgdHJpZ2dlciBheGlzUG9pbnRlciBhbmQgdG9vbHRpcC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtwYXlsb2FkLnldIHggYW5kIHksIHdoaWNoIGFyZSBtYW5kYXRvcnksIHNwZWNpZnkgYSBwb2ludCB0b1xuICogICAgICAgICAgICAgIHRyaWdnZXIgYXhpc1BvaW50ZXIgYW5kIHRvb2x0aXAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3BheWxvYWQuc2VyaWVzSW5kZXhdIGZpbmRlciwgb3B0aW9uYWwsIHJlc3RyaWN0IHRhcmdldCBheGVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXlsb2FkLmRhdGFJbmRleF0gZmluZGVyLCByZXN0cmljdCB0YXJnZXQgYXhlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGF5bG9hZC5heGVzSW5mb10gZmluZGVyLCByZXN0cmljdCB0YXJnZXQgYXhlcy5cbiAqICAgICAgICBbe1xuICogICAgICAgICAgYXhpc0RpbTogJ3gnfCd5J3wnYW5nbGUnfC4uLixcbiAqICAgICAgICAgIGF4aXNJbmRleDogLi4uLFxuICogICAgICAgICAgdmFsdWU6IC4uLlxuICogICAgICAgIH0sIC4uLl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXlsb2FkLmRpc3BhdGNoQWN0aW9uXVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXlsb2FkLnRvb2x0aXBPcHRpb25dXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheS48bnVtYmVyPnxGdW5jdGlvbn0gW3BheWxvYWQucG9zaXRpb25dIFRvb2x0aXAgcG9zaXRpb24sXG4gKiAgICAgICAgd2hpY2ggY2FuIGJlIHNwZWNpZmllZCBpbiBkaXNwYXRjaEFjdGlvblxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqIEByZXR1cm4ge09iamVjdH0gY29udGVudCBvZiBldmVudCBvYmogZm9yIGVjaGFydHMuY29ubmVjdC5cbiAqL1xuXG5mdW5jdGlvbiBfZGVmYXVsdChwYXlsb2FkLCBlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGN1cnJUcmlnZ2VyID0gcGF5bG9hZC5jdXJyVHJpZ2dlcjtcbiAgdmFyIHBvaW50ID0gW3BheWxvYWQueCwgcGF5bG9hZC55XTtcbiAgdmFyIGZpbmRlciA9IHBheWxvYWQ7XG4gIHZhciBkaXNwYXRjaEFjdGlvbiA9IHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gfHwgenJVdGlsLmJpbmQoYXBpLmRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICB2YXIgY29vcmRTeXNBeGVzSW5mbyA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpLmNvb3JkU3lzQXhlc0luZm87IC8vIFBlbmRpbmdcbiAgLy8gU2VlICM2MTIxLiBCdXQgd2UgYXJlIG5vdCBhYmxlIHRvIHJlcHJvZHVjZSBpdCB5ZXQuXG5cbiAgaWYgKCFjb29yZFN5c0F4ZXNJbmZvKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlsbGVnYWxQb2ludChwb2ludCkpIHtcbiAgICAvLyBVc2VkIGluIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGBjb25uZWN0aW9uYDogdXNlIHRoZSBzYW1wbGUgc2VyaWVzSW5kZXhcbiAgICAvLyBhbmQgZGF0YUluZGV4LiBBbmQgYWxzbyB1c2VkIGluIHRoZSB0b29sdGlwVmlldyB0cmlnZ2VyLlxuICAgIHBvaW50ID0gZmluZFBvaW50RnJvbVNlcmllcyh7XG4gICAgICBzZXJpZXNJbmRleDogZmluZGVyLnNlcmllc0luZGV4LFxuICAgICAgLy8gRG8gbm90IHVzZSBkYXRhSW5kZXhJbnNpZGUgZnJvbSBvdGhlciBlYyBpbnN0YW5jZS5cbiAgICAgIC8vIEZJWE1FOiBhdXRvIGRldGVjdCBpdD9cbiAgICAgIGRhdGFJbmRleDogZmluZGVyLmRhdGFJbmRleFxuICAgIH0sIGVjTW9kZWwpLnBvaW50O1xuICB9XG5cbiAgdmFyIGlzSWxsZWdhbFBvaW50ID0gaWxsZWdhbFBvaW50KHBvaW50KTsgLy8gQXhpcyBhbmQgdmFsdWUgY2FuIGJlIHNwZWNpZmllZCB3aGVuIGNhbGxpbmcgZGlzcGF0Y2hBY3Rpb24oe3R5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcid9KS5cbiAgLy8gTm90aWNlOiBJbiB0aGlzIGNhc2UsIGl0IGlzIGRpZmZpY3VsdCB0byBnZXQgdGhlIGBwb2ludGAgKHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBzaG93XG4gIC8vIHRvb2x0aXAsIHNvIGlmIHBvaW50IGlzIG5vdCBnaXZlbiwgd2UganVzdCB1c2UgdGhlIHBvaW50IGZvdW5kIGJ5IHNhbXBsZSBzZXJpZXNJbmRleFxuICAvLyBhbmQgZGF0YUluZGV4LlxuXG4gIHZhciBpbnB1dEF4ZXNJbmZvID0gZmluZGVyLmF4ZXNJbmZvO1xuICB2YXIgYXhlc0luZm8gPSBjb29yZFN5c0F4ZXNJbmZvLmF4ZXNJbmZvO1xuICB2YXIgc2hvdWxkSGlkZSA9IGN1cnJUcmlnZ2VyID09PSAnbGVhdmUnIHx8IGlsbGVnYWxQb2ludChwb2ludCk7XG4gIHZhciBvdXRwdXRGaW5kZXIgPSB7fTtcbiAgdmFyIHNob3dWYWx1ZU1hcCA9IHt9O1xuICB2YXIgZGF0YUJ5Q29vcmRTeXMgPSB7XG4gICAgbGlzdDogW10sXG4gICAgbWFwOiB7fVxuICB9O1xuICB2YXIgdXBkYXRlcnMgPSB7XG4gICAgc2hvd1BvaW50ZXI6IGN1cnJ5KHNob3dQb2ludGVyLCBzaG93VmFsdWVNYXApLFxuICAgIHNob3dUb29sdGlwOiBjdXJyeShzaG93VG9vbHRpcCwgZGF0YUJ5Q29vcmRTeXMpXG4gIH07IC8vIFByb2Nlc3MgZm9yIHRyaWdnZXJlZCBheGVzLlxuXG4gIGVhY2goY29vcmRTeXNBeGVzSW5mby5jb29yZFN5c01hcCwgZnVuY3Rpb24gKGNvb3JkU3lzLCBjb29yZFN5c0tleSkge1xuICAgIC8vIElmIGEgcG9pbnQgZ2l2ZW4sIGl0IG11c3QgYmUgY29udGFpbmVkIGJ5IHRoZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICB2YXIgY29vcmRTeXNDb250YWluc1BvaW50ID0gaXNJbGxlZ2FsUG9pbnQgfHwgY29vcmRTeXMuY29udGFpblBvaW50KHBvaW50KTtcbiAgICBlYWNoKGNvb3JkU3lzQXhlc0luZm8uY29vcmRTeXNBeGVzSW5mb1tjb29yZFN5c0tleV0sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgICB2YXIgYXhpcyA9IGF4aXNJbmZvLmF4aXM7XG4gICAgICB2YXIgaW5wdXRBeGlzSW5mbyA9IGZpbmRJbnB1dEF4aXNJbmZvKGlucHV0QXhlc0luZm8sIGF4aXNJbmZvKTsgLy8gSWYgbm8gaW5wdXRBeGVzSW5mbywgbm8gYXhpcyBpcyByZXN0cmljdGVkLlxuXG4gICAgICBpZiAoIXNob3VsZEhpZGUgJiYgY29vcmRTeXNDb250YWluc1BvaW50ICYmICghaW5wdXRBeGVzSW5mbyB8fCBpbnB1dEF4aXNJbmZvKSkge1xuICAgICAgICB2YXIgdmFsID0gaW5wdXRBeGlzSW5mbyAmJiBpbnB1dEF4aXNJbmZvLnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCAmJiAhaXNJbGxlZ2FsUG9pbnQpIHtcbiAgICAgICAgICB2YWwgPSBheGlzLnBvaW50VG9EYXRhKHBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbCAhPSBudWxsICYmIHByb2Nlc3NPbkF4aXMoYXhpc0luZm8sIHZhbCwgdXBkYXRlcnMsIGZhbHNlLCBvdXRwdXRGaW5kZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTsgLy8gUHJvY2VzcyBmb3IgbGlua2VkIGF4ZXMuXG5cbiAgdmFyIGxpbmtUcmlnZ2VycyA9IHt9O1xuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAodGFyQXhpc0luZm8sIHRhcktleSkge1xuICAgIHZhciBsaW5rR3JvdXAgPSB0YXJBeGlzSW5mby5saW5rR3JvdXA7IC8vIElmIGF4aXMgaGFzIGJlZW4gdHJpZ2dlcmVkIGluIHRoZSBwcmV2aW91cyBzdGFnZSwgaXQgc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgYnkgbGluay5cblxuICAgIGlmIChsaW5rR3JvdXAgJiYgIXNob3dWYWx1ZU1hcFt0YXJLZXldKSB7XG4gICAgICBlYWNoKGxpbmtHcm91cC5heGVzSW5mbywgZnVuY3Rpb24gKHNyY0F4aXNJbmZvLCBzcmNLZXkpIHtcbiAgICAgICAgdmFyIHNyY1ZhbEl0ZW0gPSBzaG93VmFsdWVNYXBbc3JjS2V5XTsgLy8gSWYgc3JjVmFsSXRlbSBleGlzdCwgc291cmNlIGF4aXMgaXMgdHJpZ2dlcmVkLCBzbyBsaW5rIHRvIHRhcmdldCBheGlzLlxuXG4gICAgICAgIGlmIChzcmNBeGlzSW5mbyAhPT0gdGFyQXhpc0luZm8gJiYgc3JjVmFsSXRlbSkge1xuICAgICAgICAgIHZhciB2YWwgPSBzcmNWYWxJdGVtLnZhbHVlO1xuICAgICAgICAgIGxpbmtHcm91cC5tYXBwZXIgJiYgKHZhbCA9IHRhckF4aXNJbmZvLmF4aXMuc2NhbGUucGFyc2UobGlua0dyb3VwLm1hcHBlcih2YWwsIG1ha2VNYXBwZXJQYXJhbShzcmNBeGlzSW5mbyksIG1ha2VNYXBwZXJQYXJhbSh0YXJBeGlzSW5mbykpKSk7XG4gICAgICAgICAgbGlua1RyaWdnZXJzW3RhckF4aXNJbmZvLmtleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGVhY2gobGlua1RyaWdnZXJzLCBmdW5jdGlvbiAodmFsLCB0YXJLZXkpIHtcbiAgICBwcm9jZXNzT25BeGlzKGF4ZXNJbmZvW3RhcktleV0sIHZhbCwgdXBkYXRlcnMsIHRydWUsIG91dHB1dEZpbmRlcik7XG4gIH0pO1xuICB1cGRhdGVNb2RlbEFjdHVhbGx5KHNob3dWYWx1ZU1hcCwgYXhlc0luZm8sIG91dHB1dEZpbmRlcik7XG4gIGRpc3BhdGNoVG9vbHRpcEFjdHVhbGx5KGRhdGFCeUNvb3JkU3lzLCBwb2ludCwgcGF5bG9hZCwgZGlzcGF0Y2hBY3Rpb24pO1xuICBkaXNwYXRjaEhpZ2hEb3duQWN0dWFsbHkoYXhlc0luZm8sIGRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICByZXR1cm4gb3V0cHV0RmluZGVyO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25BeGlzKGF4aXNJbmZvLCBuZXdWYWx1ZSwgdXBkYXRlcnMsIGRvbnRTbmFwLCBvdXRwdXRGaW5kZXIpIHtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuXG4gIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSB8fCAhYXhpcy5jb250YWluRGF0YShuZXdWYWx1ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWF4aXNJbmZvLmludm9sdmVTZXJpZXMpIHtcbiAgICB1cGRhdGVycy5zaG93UG9pbnRlcihheGlzSW5mbywgbmV3VmFsdWUpO1xuICAgIHJldHVybjtcbiAgfSAvLyBIZWF2eSBjYWxjdWxhdGlvbi4gU28gcHV0IGl0IGFmdGVyIGF4aXMuY29udGFpbkRhdGEgY2hlY2tpbmcuXG5cblxuICB2YXIgcGF5bG9hZEluZm8gPSBidWlsZFBheWxvYWRzQnlTZXJpZXMobmV3VmFsdWUsIGF4aXNJbmZvKTtcbiAgdmFyIHBheWxvYWRCYXRjaCA9IHBheWxvYWRJbmZvLnBheWxvYWRCYXRjaDtcbiAgdmFyIHNuYXBUb1ZhbHVlID0gcGF5bG9hZEluZm8uc25hcFRvVmFsdWU7IC8vIEZpbGwgY29udGVudCBvZiBldmVudCBvYmogZm9yIGVjaGFydHMuY29ubmVjdC5cbiAgLy8gQnkgZGVmdWFsdCB1c2UgdGhlIGZpcnN0IGludm9sdmVkIHNlcmllcyBkYXRhIGFzIGEgc2FtcGxlIHRvIGNvbm5lY3QuXG5cbiAgaWYgKHBheWxvYWRCYXRjaFswXSAmJiBvdXRwdXRGaW5kZXIuc2VyaWVzSW5kZXggPT0gbnVsbCkge1xuICAgIHpyVXRpbC5leHRlbmQob3V0cHV0RmluZGVyLCBwYXlsb2FkQmF0Y2hbMF0pO1xuICB9IC8vIElmIG5vIGxpbmtTb3VyY2UgaW5wdXQsIHRoaXMgcHJvY2VzcyBpcyBmb3IgY29sbGVjdGluZyBsaW5rXG4gIC8vIHRhcmdldCwgd2hlcmUgc25hcCBzaG91bGQgbm90IGJlIGFjY2VwdGVkLlxuXG5cbiAgaWYgKCFkb250U25hcCAmJiBheGlzSW5mby5zbmFwKSB7XG4gICAgaWYgKGF4aXMuY29udGFpbkRhdGEoc25hcFRvVmFsdWUpICYmIHNuYXBUb1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5ld1ZhbHVlID0gc25hcFRvVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlcnMuc2hvd1BvaW50ZXIoYXhpc0luZm8sIG5ld1ZhbHVlLCBwYXlsb2FkQmF0Y2gsIG91dHB1dEZpbmRlcik7IC8vIFRvb2x0aXAgc2hvdWxkIGFsd2F5cyBiZSBzbmFwVG9WYWx1ZSwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IFwiYXhpcyB2YWx1ZSB+IHNlcmllcyB2YWx1ZVwiIG1hcHBpbmcgZGlzcGxheWVkIGluIHRvb2x0aXAuXG5cbiAgdXBkYXRlcnMuc2hvd1Rvb2x0aXAoYXhpc0luZm8sIHBheWxvYWRJbmZvLCBzbmFwVG9WYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF5bG9hZHNCeVNlcmllcyh2YWx1ZSwgYXhpc0luZm8pIHtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICB2YXIgZGltID0gYXhpcy5kaW07XG4gIHZhciBzbmFwVG9WYWx1ZSA9IHZhbHVlO1xuICB2YXIgcGF5bG9hZEJhdGNoID0gW107XG4gIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgdmFyIG1pbkRpZmYgPSAtMTtcbiAgZWFjaChheGlzSW5mby5zZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXMsIGlkeCkge1xuICAgIHZhciBkYXRhRGltID0gc2VyaWVzLmNvb3JkRGltVG9EYXRhRGltKGRpbSk7XG4gICAgdmFyIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICB2YXIgZGF0YUluZGljZXM7XG5cbiAgICBpZiAoc2VyaWVzLmdldEF4aXNUb29sdGlwRGF0YSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHNlcmllcy5nZXRBeGlzVG9vbHRpcERhdGEoZGF0YURpbSwgdmFsdWUsIGF4aXMpO1xuICAgICAgZGF0YUluZGljZXMgPSByZXN1bHQuZGF0YUluZGljZXM7XG4gICAgICBzZXJpZXNOZXN0ZXN0VmFsdWUgPSByZXN1bHQubmVzdGVzdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhSW5kaWNlcyA9IHNlcmllcy5nZXREYXRhKCkuaW5kaWNlc09mTmVhcmVzdChkYXRhRGltWzBdLCB2YWx1ZSwgLy8gQWRkIGEgdGhyZXNob2xkIHRvIGF2b2lkIGZpbmQgdGhlIHdyb25nIGRhdGFJbmRleFxuICAgICAgLy8gd2hlbiBkYXRhIGxlbmd0aCBpcyBub3Qgc2FtZS5cbiAgICAgIGZhbHNlLCBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyAwLjUgOiBudWxsKTtcblxuICAgICAgaWYgKCFkYXRhSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXJpZXNOZXN0ZXN0VmFsdWUgPSBzZXJpZXMuZ2V0RGF0YSgpLmdldChkYXRhRGltWzBdLCBkYXRhSW5kaWNlc1swXSk7XG4gICAgfVxuXG4gICAgaWYgKHNlcmllc05lc3Rlc3RWYWx1ZSA9PSBudWxsIHx8ICFpc0Zpbml0ZShzZXJpZXNOZXN0ZXN0VmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRpZmYpOyAvLyBDb25zaWRlciBjYXRlZ29yeSBjYXNlXG5cbiAgICBpZiAoZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QgfHwgZGlmZiA+PSAwICYmIG1pbkRpZmYgPCAwKSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBtaW5EaWZmID0gZGlmZjtcbiAgICAgICAgc25hcFRvVmFsdWUgPSBzZXJpZXNOZXN0ZXN0VmFsdWU7XG4gICAgICAgIHBheWxvYWRCYXRjaC5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICBlYWNoKGRhdGFJbmRpY2VzLCBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHBheWxvYWRCYXRjaC5wdXNoKHtcbiAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzLnNlcmllc0luZGV4LFxuICAgICAgICAgIGRhdGFJbmRleEluc2lkZTogZGF0YUluZGV4LFxuICAgICAgICAgIGRhdGFJbmRleDogc2VyaWVzLmdldERhdGEoKS5nZXRSYXdJbmRleChkYXRhSW5kZXgpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwYXlsb2FkQmF0Y2g6IHBheWxvYWRCYXRjaCxcbiAgICBzbmFwVG9WYWx1ZTogc25hcFRvVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hvd1BvaW50ZXIoc2hvd1ZhbHVlTWFwLCBheGlzSW5mbywgdmFsdWUsIHBheWxvYWRCYXRjaCkge1xuICBzaG93VmFsdWVNYXBbYXhpc0luZm8ua2V5XSA9IHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcGF5bG9hZEJhdGNoOiBwYXlsb2FkQmF0Y2hcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZGF0YUJ5Q29vcmRTeXMsIGF4aXNJbmZvLCBwYXlsb2FkSW5mbywgdmFsdWUpIHtcbiAgdmFyIHBheWxvYWRCYXRjaCA9IHBheWxvYWRJbmZvLnBheWxvYWRCYXRjaDtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsOyAvLyBJZiBubyBkYXRhLCBkbyBub3QgY3JlYXRlIGFueXRoaW5nIGluIGRhdGFCeUNvb3JkU3lzLFxuICAvLyB3aG9zZSBsZW5ndGggd2lsbCBiZSB1c2VkIHRvIGp1ZGdlIHdoZXRoZXIgZGlzcGF0Y2ggYWN0aW9uLlxuXG4gIGlmICghYXhpc0luZm8udHJpZ2dlclRvb2x0aXAgfHwgIXBheWxvYWRCYXRjaC5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29vcmRTeXNNb2RlbCA9IGF4aXNJbmZvLmNvb3JkU3lzLm1vZGVsO1xuICB2YXIgY29vcmRTeXNLZXkgPSBtb2RlbEhlbHBlci5tYWtlS2V5KGNvb3JkU3lzTW9kZWwpO1xuICB2YXIgY29vcmRTeXNJdGVtID0gZGF0YUJ5Q29vcmRTeXMubWFwW2Nvb3JkU3lzS2V5XTtcblxuICBpZiAoIWNvb3JkU3lzSXRlbSkge1xuICAgIGNvb3JkU3lzSXRlbSA9IGRhdGFCeUNvb3JkU3lzLm1hcFtjb29yZFN5c0tleV0gPSB7XG4gICAgICBjb29yZFN5c0lkOiBjb29yZFN5c01vZGVsLmlkLFxuICAgICAgY29vcmRTeXNJbmRleDogY29vcmRTeXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIGNvb3JkU3lzVHlwZTogY29vcmRTeXNNb2RlbC50eXBlLFxuICAgICAgY29vcmRTeXNNYWluVHlwZTogY29vcmRTeXNNb2RlbC5tYWluVHlwZSxcbiAgICAgIGRhdGFCeUF4aXM6IFtdXG4gICAgfTtcbiAgICBkYXRhQnlDb29yZFN5cy5saXN0LnB1c2goY29vcmRTeXNJdGVtKTtcbiAgfVxuXG4gIGNvb3JkU3lzSXRlbS5kYXRhQnlBeGlzLnB1c2goe1xuICAgIGF4aXNEaW06IGF4aXMuZGltLFxuICAgIGF4aXNJbmRleDogYXhpc01vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgIGF4aXNUeXBlOiBheGlzTW9kZWwudHlwZSxcbiAgICBheGlzSWQ6IGF4aXNNb2RlbC5pZCxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgLy8gQ2F1c3Rpb246IHZpZXdIZWxwZXIuZ2V0VmFsdWVMYWJlbCBpcyBhY3R1YWxseSBvbiBcInZpZXcgc3RhZ2VcIiwgd2hpY2hcbiAgICAvLyBkZXBlbmRzIHRoYXQgYWxsIG1vZGVscyBoYXZlIGJlZW4gdXBkYXRlZC4gU28gaXQgc2hvdWxkIG5vdCBiZSBwZXJmb3JtZWRcbiAgICAvLyBoZXJlLiBDb25zaWRlcmluZyBheGlzUG9pbnRlck1vZGVsIHVzZWQgaGVyZSBpcyB2b2xhdGlsZSwgd2hpY2ggaXMgaGFyZFxuICAgIC8vIHRvIGJlIHJldHJpZXZlIGluIFRvb2x0aXBWaWV3LCB3ZSBwcmVwYXJlIHBhcmFtZXRlcnMgaGVyZS5cbiAgICB2YWx1ZUxhYmVsT3B0OiB7XG4gICAgICBwcmVjaXNpb246IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5wcmVjaXNpb24nKSxcbiAgICAgIGZvcm1hdHRlcjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLmZvcm1hdHRlcicpXG4gICAgfSxcbiAgICBzZXJpZXNEYXRhSW5kaWNlczogcGF5bG9hZEJhdGNoLnNsaWNlKClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQWN0dWFsbHkoc2hvd1ZhbHVlTWFwLCBheGVzSW5mbywgb3V0cHV0RmluZGVyKSB7XG4gIHZhciBvdXRwdXRBeGVzSW5mbyA9IG91dHB1dEZpbmRlci5heGVzSW5mbyA9IFtdOyAvLyBCYXNpYyBsb2dpYzogSWYgbm8gJ3Nob3cnIHJlcXVpcmVkLCAnaGlkZScgdGhpcyBheGlzUG9pbnRlci5cblxuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAoYXhpc0luZm8sIGtleSkge1xuICAgIHZhciBvcHRpb24gPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgICB2YXIgdmFsSXRlbSA9IHNob3dWYWx1ZU1hcFtrZXldO1xuXG4gICAgaWYgKHZhbEl0ZW0pIHtcbiAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnc2hvdycpO1xuICAgICAgb3B0aW9uLnZhbHVlID0gdmFsSXRlbS52YWx1ZTsgLy8gRm9yIGxhYmVsIGZvcm1hdHRlciBwYXJhbSBhbmQgaGlnaGxpZ2h0LlxuXG4gICAgICBvcHRpb24uc2VyaWVzRGF0YUluZGljZXMgPSAodmFsSXRlbS5wYXlsb2FkQmF0Y2ggfHwgW10pLnNsaWNlKCk7XG4gICAgfSAvLyBXaGVuIGFsd2F5cyBzaG93IChlLmcuLCBoYW5kbGUgdXNlZCksIHJlbWFpblxuICAgIC8vIG9yaWdpbmFsIHZhbHVlIGFuZCBzdGF0dXMuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIGhpZGUsIHZhbHVlIHN0aWxsIG5lZWQgdG8gYmUgc2V0LCBjb25zaWRlclxuICAgICAgICAvLyBjbGljayBsZWdlbmQgdG8gdG9nZ2xlIGF4aXMgYmxhbmsuXG4gICAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnaGlkZScpO1xuICAgICAgfSAvLyBJZiBzdGF0dXMgaXMgJ2hpZGUnLCBzaG91bGQgYmUgbm8gaW5mbyBpbiBwYXlsb2FkLlxuXG5cbiAgICBvcHRpb24uc3RhdHVzID09PSAnc2hvdycgJiYgb3V0cHV0QXhlc0luZm8ucHVzaCh7XG4gICAgICBheGlzRGltOiBheGlzSW5mby5heGlzLmRpbSxcbiAgICAgIGF4aXNJbmRleDogYXhpc0luZm8uYXhpcy5tb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIHZhbHVlOiBvcHRpb24udmFsdWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoVG9vbHRpcEFjdHVhbGx5KGRhdGFCeUNvb3JkU3lzLCBwb2ludCwgcGF5bG9hZCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgLy8gQmFzaWMgbG9naWM6IElmIG5vIHNob3dUaXAgcmVxdWlyZWQsIGhpZGVUaXAgd2lsbCBiZSBkaXNwYXRjaGVkLlxuICBpZiAoaWxsZWdhbFBvaW50KHBvaW50KSB8fCAhZGF0YUJ5Q29vcmRTeXMubGlzdC5sZW5ndGgpIHtcbiAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnaGlkZVRpcCdcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gSW4gbW9zdCBjYXNlIG9ubHkgb25lIGF4aXMgKG9yIGV2ZW50IG9uZSBzZXJpZXMgaXMgdXNlZCkuIEl0IGlzXG4gIC8vIGNvbnZpbmllbnQgdG8gZmV0Y2ggcGF5bG9hZC5zZXJpZXNJbmRleCBhbmQgcGF5bG9hZC5kYXRhSW5kZXhcbiAgLy8gZGlydGVjdGx5LiBTbyBwdXQgdGhlIGZpcnN0IHNlcmllc0luZGV4IGFuZCBkYXRhSW5kZXggb2YgdGhlIGZpcnN0XG4gIC8vIGF4aXMgb24gdGhlIHBheWxvYWQuXG5cblxuICB2YXIgc2FtcGxlSXRlbSA9ICgoZGF0YUJ5Q29vcmRTeXMubGlzdFswXS5kYXRhQnlBeGlzWzBdIHx8IHt9KS5zZXJpZXNEYXRhSW5kaWNlcyB8fCBbXSlbMF0gfHwge307XG4gIGRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgZXNjYXBlQ29ubmVjdDogdHJ1ZSxcbiAgICB4OiBwb2ludFswXSxcbiAgICB5OiBwb2ludFsxXSxcbiAgICB0b29sdGlwT3B0aW9uOiBwYXlsb2FkLnRvb2x0aXBPcHRpb24sXG4gICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgZGF0YUluZGV4SW5zaWRlOiBzYW1wbGVJdGVtLmRhdGFJbmRleEluc2lkZSxcbiAgICBkYXRhSW5kZXg6IHNhbXBsZUl0ZW0uZGF0YUluZGV4LFxuICAgIHNlcmllc0luZGV4OiBzYW1wbGVJdGVtLnNlcmllc0luZGV4LFxuICAgIGRhdGFCeUNvb3JkU3lzOiBkYXRhQnlDb29yZFN5cy5saXN0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEhpZ2hEb3duQWN0dWFsbHkoYXhlc0luZm8sIGRpc3BhdGNoQWN0aW9uLCBhcGkpIHtcbiAgLy8gRklYTUVcbiAgLy8gaGlnaGxpZ2h0IHN0YXR1cyBtb2RpZmljYXRpb24gc2hvdWxlIGJlIGEgc3RhZ2Ugb2YgbWFpbiBwcm9jZXNzP1xuICAvLyAoQ29uc2lkZXIgY29uZmlsY3QgKGUuZy4sIGxlZ2VuZCBhbmQgYXhpc1BvaW50ZXIpIGFuZCBzZXRPcHRpb24pXG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICB2YXIgaGlnaERvd25LZXkgPSAnYXhpc1BvaW50ZXJMYXN0SGlnaGxpZ2h0cyc7XG4gIHZhciBsYXN0SGlnaGxpZ2h0cyA9IGdldCh6cilbaGlnaERvd25LZXldIHx8IHt9O1xuICB2YXIgbmV3SGlnaGxpZ2h0cyA9IGdldCh6cilbaGlnaERvd25LZXldID0ge307IC8vIFVwZGF0ZSBoaWdobGlnaHQvZG93bnBsYXkgc3RhdHVzIGFjY29yZGluZyB0byBheGlzUG9pbnRlciBtb2RlbC5cbiAgLy8gQnVpbGQgaGFzaCBtYXAgYW5kIHJlbW92ZSBkdXBsaWNhdGUgaW5jaWRlbnRhbGx5LlxuXG4gIGVhY2goYXhlc0luZm8sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgdmFyIG9wdGlvbiA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWwub3B0aW9uO1xuICAgIG9wdGlvbi5zdGF0dXMgPT09ICdzaG93JyAmJiBlYWNoKG9wdGlvbi5zZXJpZXNEYXRhSW5kaWNlcywgZnVuY3Rpb24gKGJhdGNoSXRlbSkge1xuICAgICAgdmFyIGtleSA9IGJhdGNoSXRlbS5zZXJpZXNJbmRleCArICcgfCAnICsgYmF0Y2hJdGVtLmRhdGFJbmRleDtcbiAgICAgIG5ld0hpZ2hsaWdodHNba2V5XSA9IGJhdGNoSXRlbTtcbiAgICB9KTtcbiAgfSk7IC8vIERpZmYuXG5cbiAgdmFyIHRvSGlnaGxpZ2h0ID0gW107XG4gIHZhciB0b0Rvd25wbGF5ID0gW107XG4gIHpyVXRpbC5lYWNoKGxhc3RIaWdobGlnaHRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBrZXkpIHtcbiAgICAhbmV3SGlnaGxpZ2h0c1trZXldICYmIHRvRG93bnBsYXkucHVzaChiYXRjaEl0ZW0pO1xuICB9KTtcbiAgenJVdGlsLmVhY2gobmV3SGlnaGxpZ2h0cywgZnVuY3Rpb24gKGJhdGNoSXRlbSwga2V5KSB7XG4gICAgIWxhc3RIaWdobGlnaHRzW2tleV0gJiYgdG9IaWdobGlnaHQucHVzaChiYXRjaEl0ZW0pO1xuICB9KTtcbiAgdG9Eb3ducGxheS5sZW5ndGggJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnZG93bnBsYXknLFxuICAgIGVzY2FwZUNvbm5lY3Q6IHRydWUsXG4gICAgYmF0Y2g6IHRvRG93bnBsYXlcbiAgfSk7XG4gIHRvSGlnaGxpZ2h0Lmxlbmd0aCAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdoaWdobGlnaHQnLFxuICAgIGVzY2FwZUNvbm5lY3Q6IHRydWUsXG4gICAgYmF0Y2g6IHRvSGlnaGxpZ2h0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5wdXRBeGlzSW5mbyhpbnB1dEF4ZXNJbmZvLCBheGlzSW5mbykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IChpbnB1dEF4ZXNJbmZvIHx8IFtdKS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnB1dEF4aXNJbmZvID0gaW5wdXRBeGVzSW5mb1tpXTtcblxuICAgIGlmIChheGlzSW5mby5heGlzLmRpbSA9PT0gaW5wdXRBeGlzSW5mby5heGlzRGltICYmIGF4aXNJbmZvLmF4aXMubW9kZWwuY29tcG9uZW50SW5kZXggPT09IGlucHV0QXhpc0luZm8uYXhpc0luZGV4KSB7XG4gICAgICByZXR1cm4gaW5wdXRBeGlzSW5mbztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZU1hcHBlclBhcmFtKGF4aXNJbmZvKSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzSW5mby5heGlzLm1vZGVsO1xuICB2YXIgaXRlbSA9IHt9O1xuICB2YXIgZGltID0gaXRlbS5heGlzRGltID0gYXhpc0luZm8uYXhpcy5kaW07XG4gIGl0ZW0uYXhpc0luZGV4ID0gaXRlbVtkaW0gKyAnQXhpc0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gIGl0ZW0uYXhpc05hbWUgPSBpdGVtW2RpbSArICdBeGlzTmFtZSddID0gYXhpc01vZGVsLm5hbWU7XG4gIGl0ZW0uYXhpc0lkID0gaXRlbVtkaW0gKyAnQXhpc0lkJ10gPSBheGlzTW9kZWwuaWQ7XG4gIHJldHVybiBpdGVtO1xufVxuXG5mdW5jdGlvbiBpbGxlZ2FsUG9pbnQocG9pbnQpIHtcbiAgcmV0dXJuICFwb2ludCB8fCBwb2ludFswXSA9PSBudWxsIHx8IGlzTmFOKHBvaW50WzBdKSB8fCBwb2ludFsxXSA9PSBudWxsIHx8IGlzTmFOKHBvaW50WzFdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvYXhpc1RyaWdnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciBBeGlzUG9pbnRlck1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdheGlzUG9pbnRlcicsXG4gIGNvb3JkU3lzQXhlc0luZm86IG51bGwsXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICAvLyAnYXV0bycgbWVhbnMgdGhhdCBzaG93IHdoZW4gdHJpZ2dlcmVkIGJ5IHRvb2x0aXAgb3IgaGFuZGxlLlxuICAgIHNob3c6ICdhdXRvJyxcbiAgICAvLyAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZSdcbiAgICB0cmlnZ2VyT246IG51bGwsXG4gICAgLy8gc2V0IGRlZmF1bHQgaW4gQXhpc1BvbnRlclZpZXcuanNcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogNTAsXG4gICAgdHlwZTogJ2xpbmUnLFxuICAgIC8vIGF4aXNwb2ludGVyIHRyaWdnZXJlZCBieSB0b290aXAgZGV0ZXJtaW5lIHNuYXAgYXV0b21hdGljYWxseSxcbiAgICAvLyBzZWUgYG1vZGVsSGVscGVyYC5cbiAgICBzbmFwOiBmYWxzZSxcbiAgICB0cmlnZ2VyVG9vbHRpcDogdHJ1ZSxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBzdGF0dXM6IG51bGwsXG4gICAgLy8gSW5pdCB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgaGFuZGxlIGlzIHVzZWQuXG4gICAgLy8gW2dyb3VwMCwgZ3JvdXAxLCAuLi5dXG4gICAgLy8gRWFjaCBncm91cCBjYW4gYmU6IHtcbiAgICAvLyAgICAgIG1hcHBlcjogZnVuY3Rpb24gKCkge30sXG4gICAgLy8gICAgICBzaW5nbGVUb29sdGlwOiAnbXVsdGlwbGUnLCAgLy8gJ211bHRpcGxlJyBvciAnc2luZ2xlJ1xuICAgIC8vICAgICAgeEF4aXNJZDogLi4uLFxuICAgIC8vICAgICAgeUF4aXNOYW1lOiAuLi4sXG4gICAgLy8gICAgICBhbmdsZUF4aXNJbmRleDogLi4uXG4gICAgLy8gfVxuICAgIC8vIG1hcHBlcjogY2FuIGJlIGlnbm9yZWQuXG4gICAgLy8gICAgICBpbnB1dDoge2F4aXNJbmZvLCB2YWx1ZX1cbiAgICAvLyAgICAgIG91dHB1dDoge2F4aXNJbmZvLCB2YWx1ZX1cbiAgICBsaW5rOiBbXSxcbiAgICAvLyBEbyBub3Qgc2V0ICdhdXRvJyBoZXJlLCBvdGhlcndpc2UgZ2xvYmFsIGFuaW1hdGlvbjogZmFsc2VcbiAgICAvLyB3aWxsIG5vdCBlZmZlY3QgYXQgdGhpcyBheGlzcG9pbnRlci5cbiAgICBhbmltYXRpb246IG51bGwsXG4gICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDIwMCxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2FhYScsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICB9LFxuICAgIHNoYWRvd1N0eWxlOiB7XG4gICAgICBjb2xvcjogJ3JnYmEoMTUwLDE1MCwxNTAsMC4zKSdcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgZm9ybWF0dGVyOiBudWxsLFxuICAgICAgLy8gc3RyaW5nIHwgRnVuY3Rpb25cbiAgICAgIHByZWNpc2lvbjogJ2F1dG8nLFxuICAgICAgLy8gT3IgYSBudW1iZXIgbGlrZSAwLCAxLCAyIC4uLlxuICAgICAgbWFyZ2luOiAzLFxuICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgIHBhZGRpbmc6IFs1LCA3LCA1LCA3XSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ2F1dG8nLFxuICAgICAgLy8gZGVmYXVsdDogYXhpcyBsaW5lIGNvbG9yXG4gICAgICBib3JkZXJDb2xvcjogbnVsbCxcbiAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgc2hhZG93Qmx1cjogMyxcbiAgICAgIHNoYWRvd0NvbG9yOiAnI2FhYScgLy8gQ29uc2lkZXJpbmcgYXBwbGljYWJpbGl0eSwgY29tbW9uIHN0eWxlIHNob3VsZFxuICAgICAgLy8gYmV0dGVyIG5vdCBoYXZlIHNoYWRvd09mZnNldC5cbiAgICAgIC8vIHNoYWRvd09mZnNldFg6IDAsXG4gICAgICAvLyBzaGFkb3dPZmZzZXRZOiAyXG5cbiAgICB9LFxuICAgIGhhbmRsZToge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBpY29uOiAnTTEwLjcsMTEuOXYtMS4zSDkuM3YxLjNjLTQuOSwwLjMtOC44LDQuNC04LjgsOS40YzAsNSwzLjksOS4xLDguOCw5LjRoMS4zYzQuOS0wLjMsOC44LTQuNCw4LjgtOS40QzE5LjUsMTYuMywxNS42LDEyLjIsMTAuNywxMS45eiBNMTMuMywyNC40SDYuN3YtMS4yaDYuNnogTTEzLjMsMjJINi43di0xLjJoNi42eiBNMTMuMywxOS42SDYuN3YtMS4yaDYuNnonLFxuICAgICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICBzaXplOiA0NSxcbiAgICAgIC8vIGhhbmRsZSBtYXJnaW4gaXMgZnJvbSBzeW1ib2wgY2VudGVyIHRvIGF4aXMsIHdoaWNoIGlzIHN0YWJsZSB3aGVuIGNpcmN1bGFyIG1vdmUuXG4gICAgICBtYXJnaW46IDUwLFxuICAgICAgLy8gY29sb3I6ICcjMWI4YmJkJ1xuICAgICAgLy8gY29sb3I6ICcjMmY0NTU0J1xuICAgICAgY29sb3I6ICcjMzMzJyxcbiAgICAgIHNoYWRvd0JsdXI6IDMsXG4gICAgICBzaGFkb3dDb2xvcjogJyNhYWEnLFxuICAgICAgc2hhZG93T2Zmc2V0WDogMCxcbiAgICAgIHNoYWRvd09mZnNldFk6IDIsXG4gICAgICAvLyBGb3IgbW9iaWxlIHBlcmZvcm1hbmNlXG4gICAgICB0aHJvdHRsZTogNDBcbiAgICB9XG4gIH1cbn0pO1xudmFyIF9kZWZhdWx0ID0gQXhpc1BvaW50ZXJNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDI2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciBnbG9iYWxMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2dsb2JhbExpc3RlbmVyXCIpO1xuXG52YXIgQXhpc1BvaW50ZXJWaWV3ID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ2F4aXNQb2ludGVyJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGdsb2JhbFRvb2x0aXBNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sdGlwJyk7XG4gICAgdmFyIHRyaWdnZXJPbiA9IGdsb2JhbEF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKSB8fCBnbG9iYWxUb29sdGlwTW9kZWwgJiYgZ2xvYmFsVG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlck9uJykgfHwgJ21vdXNlbW92ZXxjbGljayc7IC8vIFJlZ2lzdGVyIGdsb2JhbCBsaXN0ZW5lciBpbiBBeGlzUG9pbnRlclZpZXcgdG8gZW5hYmxlXG4gICAgLy8gQXhpc1BvaW50ZXJWaWV3IHRvIGJlIGluZGVwZW5kZW50IHRvIFRvb2x0aXAuXG5cbiAgICBnbG9iYWxMaXN0ZW5lci5yZWdpc3RlcignYXhpc1BvaW50ZXInLCBhcGksIGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgIC8vIElmICdub25lJywgaXQgaXMgbm90IGNvbnRyb2xsZWQgYnkgbW91c2UgdG90YWxseS5cbiAgICAgIGlmICh0cmlnZ2VyT24gIT09ICdub25lJyAmJiAoY3VyclRyaWdnZXIgPT09ICdsZWF2ZScgfHwgdHJpZ2dlck9uLmluZGV4T2YoY3VyclRyaWdnZXIpID49IDApKSB7XG4gICAgICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICAgIGN1cnJUcmlnZ2VyOiBjdXJyVHJpZ2dlcixcbiAgICAgICAgICB4OiBlICYmIGUub2Zmc2V0WCxcbiAgICAgICAgICB5OiBlICYmIGUub2Zmc2V0WVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBnbG9iYWxMaXN0ZW5lci51bnJlZ2lzdGVyKGFwaS5nZXRacigpLCAnYXhpc1BvaW50ZXInKTtcbiAgICBBeGlzUG9pbnRlclZpZXcuc3VwZXJBcHBseSh0aGlzLl9tb2RlbCwgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIoJ2F4aXNQb2ludGVyJywgYXBpKTtcbiAgICBBeGlzUG9pbnRlclZpZXcuc3VwZXJBcHBseSh0aGlzLl9tb2RlbCwgJ2Rpc3Bvc2UnLCBhcmd1bWVudHMpO1xuICB9XG59KTtcbnZhciBfZGVmYXVsdCA9IEF4aXNQb2ludGVyVmlldztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgQmFzZUF4aXNQb2ludGVyID0gcmVxdWlyZShcIi4vQmFzZUF4aXNQb2ludGVyXCIpO1xuXG52YXIgdmlld0hlbHBlciA9IHJlcXVpcmUoXCIuL3ZpZXdIZWxwZXJcIik7XG5cbnZhciBjYXJ0ZXNpYW5BeGlzSGVscGVyID0gcmVxdWlyZShcIi4uL2F4aXMvY2FydGVzaWFuQXhpc0hlbHBlclwiKTtcblxudmFyIEF4aXNWaWV3ID0gcmVxdWlyZShcIi4uL2F4aXMvQXhpc1ZpZXdcIik7XG5cbnZhciBDYXJ0ZXNpYW5BeGlzUG9pbnRlciA9IEJhc2VBeGlzUG9pbnRlci5leHRlbmQoe1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBtYWtlRWxPcHRpb246IGZ1bmN0aW9uIChlbE9wdGlvbiwgdmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgZ3JpZCA9IGF4aXMuZ3JpZDtcbiAgICB2YXIgYXhpc1BvaW50ZXJUeXBlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgIHZhciBwaXhlbFZhbHVlID0gYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQodmFsdWUsIHRydWUpKTtcblxuICAgIGlmIChheGlzUG9pbnRlclR5cGUgJiYgYXhpc1BvaW50ZXJUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgIHZhciBlbFN0eWxlID0gdmlld0hlbHBlci5idWlsZEVsU3R5bGUoYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICB2YXIgcG9pbnRlck9wdGlvbiA9IHBvaW50ZXJTaGFwZUJ1aWxkZXJbYXhpc1BvaW50ZXJUeXBlXShheGlzLCBwaXhlbFZhbHVlLCBvdGhlckV4dGVudCwgZWxTdHlsZSk7XG4gICAgICBwb2ludGVyT3B0aW9uLnN0eWxlID0gZWxTdHlsZTtcbiAgICAgIGVsT3B0aW9uLmdyYXBoaWNLZXkgPSBwb2ludGVyT3B0aW9uLnR5cGU7XG4gICAgICBlbE9wdGlvbi5wb2ludGVyID0gcG9pbnRlck9wdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgbGF5b3V0SW5mbyA9IGNhcnRlc2lhbkF4aXNIZWxwZXIubGF5b3V0KGdyaWQubW9kZWwsIGF4aXNNb2RlbCk7XG4gICAgdmlld0hlbHBlci5idWlsZENhcnRlc2lhblNpbmdsZUxhYmVsRWxPcHRpb24odmFsdWUsIGVsT3B0aW9uLCBsYXlvdXRJbmZvLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0SGFuZGxlVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBsYXlvdXRJbmZvID0gY2FydGVzaWFuQXhpc0hlbHBlci5sYXlvdXQoYXhpc01vZGVsLmF4aXMuZ3JpZC5tb2RlbCwgYXhpc01vZGVsLCB7XG4gICAgICBsYWJlbEluc2lkZTogZmFsc2VcbiAgICB9KTtcbiAgICBsYXlvdXRJbmZvLmxhYmVsTWFyZ2luID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2hhbmRsZS5tYXJnaW4nKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHZpZXdIZWxwZXIuZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbihheGlzTW9kZWwuYXhpcywgdmFsdWUsIGxheW91dEluZm8pLFxuICAgICAgcm90YXRpb246IGxheW91dEluZm8ucm90YXRpb24gKyAobGF5b3V0SW5mby5sYWJlbERpcmVjdGlvbiA8IDAgPyBNYXRoLlBJIDogMClcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHVwZGF0ZUhhbmRsZVRyYW5zZm9ybTogZnVuY3Rpb24gKHRyYW5zZm9ybSwgZGVsdGEsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIGdyaWQgPSBheGlzLmdyaWQ7XG4gICAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEdsb2JhbEV4dGVudCh0cnVlKTtcbiAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgIHZhciBkaW1JbmRleCA9IGF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbiAgICB2YXIgY3VyclBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gKz0gZGVsdGFbZGltSW5kZXhdO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gPSBNYXRoLm1pbihheGlzRXh0ZW50WzFdLCBjdXJyUG9zaXRpb25bZGltSW5kZXhdKTtcbiAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5tYXgoYXhpc0V4dGVudFswXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG4gICAgdmFyIGN1cnNvck90aGVyVmFsdWUgPSAob3RoZXJFeHRlbnRbMV0gKyBvdGhlckV4dGVudFswXSkgLyAyO1xuICAgIHZhciBjdXJzb3JQb2ludCA9IFtjdXJzb3JPdGhlclZhbHVlLCBjdXJzb3JPdGhlclZhbHVlXTtcbiAgICBjdXJzb3JQb2ludFtkaW1JbmRleF0gPSBjdXJyUG9zaXRpb25bZGltSW5kZXhdOyAvLyBNYWtlIHRvb2x0aXAgZG8gbm90IG92ZXJsYXAgYXhpc1BvaW50ZXIgYW5kIGluIHRoZSBtaWRkbGUgb2YgdGhlIGdyaWQuXG5cbiAgICB2YXIgdG9vbHRpcE9wdGlvbnMgPSBbe1xuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICB9LCB7XG4gICAgICBhbGlnbjogJ2NlbnRlcidcbiAgICB9XTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IGN1cnJQb3NpdGlvbixcbiAgICAgIHJvdGF0aW9uOiB0cmFuc2Zvcm0ucm90YXRpb24sXG4gICAgICBjdXJzb3JQb2ludDogY3Vyc29yUG9pbnQsXG4gICAgICB0b29sdGlwT3B0aW9uOiB0b29sdGlwT3B0aW9uc1tkaW1JbmRleF1cbiAgICB9O1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0Q2FydGVzaWFuKGdyaWQsIGF4aXMpIHtcbiAgdmFyIG9wdCA9IHt9O1xuICBvcHRbYXhpcy5kaW0gKyAnQXhpc0luZGV4J10gPSBheGlzLmluZGV4O1xuICByZXR1cm4gZ3JpZC5nZXRDYXJ0ZXNpYW4ob3B0KTtcbn1cblxudmFyIHBvaW50ZXJTaGFwZUJ1aWxkZXIgPSB7XG4gIGxpbmU6IGZ1bmN0aW9uIChheGlzLCBwaXhlbFZhbHVlLCBvdGhlckV4dGVudCwgZWxTdHlsZSkge1xuICAgIHZhciB0YXJnZXRTaGFwZSA9IHZpZXdIZWxwZXIubWFrZUxpbmVTaGFwZShbcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnRbMF1dLCBbcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnRbMV1dLCBnZXRBeGlzRGltSW5kZXgoYXhpcykpO1xuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUoe1xuICAgICAgc2hhcGU6IHRhcmdldFNoYXBlLFxuICAgICAgc3R5bGU6IGVsU3R5bGVcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0xpbmUnLFxuICAgICAgc2hhcGU6IHRhcmdldFNoYXBlXG4gICAgfTtcbiAgfSxcbiAgc2hhZG93OiBmdW5jdGlvbiAoYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQsIGVsU3R5bGUpIHtcbiAgICB2YXIgYmFuZFdpZHRoID0gYXhpcy5nZXRCYW5kV2lkdGgoKTtcbiAgICB2YXIgc3BhbiA9IG90aGVyRXh0ZW50WzFdIC0gb3RoZXJFeHRlbnRbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdSZWN0JyxcbiAgICAgIHNoYXBlOiB2aWV3SGVscGVyLm1ha2VSZWN0U2hhcGUoW3BpeGVsVmFsdWUgLSBiYW5kV2lkdGggLyAyLCBvdGhlckV4dGVudFswXV0sIFtiYW5kV2lkdGgsIHNwYW5dLCBnZXRBeGlzRGltSW5kZXgoYXhpcykpXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0QXhpc0RpbUluZGV4KGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbn1cblxuQXhpc1ZpZXcucmVnaXN0ZXJBeGlzUG9pbnRlckNsYXNzKCdDYXJ0ZXNpYW5BeGlzUG9pbnRlcicsIENhcnRlc2lhbkF4aXNQb2ludGVyKTtcbnZhciBfZGVmYXVsdCA9IENhcnRlc2lhbkF4aXNQb2ludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQ2FydGVzaWFuQXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgY2xhenpVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIgPSByZXF1aXJlKFwiLi9tb2RlbEhlbHBlclwiKTtcblxudmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgdGhyb3R0bGVVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvdGhyb3R0bGVcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGdldCA9IG1vZGVsVXRpbC5tYWtlR2V0dGVyKCk7XG52YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG52YXIgYmluZCA9IHpyVXRpbC5iaW5kO1xuLyoqXG4gKiBCYXNlIGF4aXMgcG9pbnRlciBjbGFzcyBpbiAyRC5cbiAqIEltcGxlbWVuZW50cyB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2F4aXMvSUF4aXNQb2ludGVyfS5cbiAqL1xuXG5mdW5jdGlvbiBCYXNlQXhpc1BvaW50ZXIoKSB7fVxuXG5CYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ncm91cDogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sYXN0R3JhcGhpY0tleTogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZHJhZ2dpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2xhc3RWYWx1ZTogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sYXN0U3RhdHVzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BheWxvYWRJbmZvOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJbiBweCwgYXJiaXRyYXJ5IHZhbHVlLiBEbyBub3Qgc2V0IHRvbyBzbWFsbCxcbiAgICogbm8gYW5pbWF0aW9uIGlzIG9rIGZvciBtb3N0IGNhc2VzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBhbmltYXRpb25UaHJlc2hvbGQ6IDE1LFxuXG4gIC8qKlxuICAgKiBAaW1wbGVtZW50XG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwgZm9yY2VSZW5kZXIpIHtcbiAgICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgICB2YXIgc3RhdHVzID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3N0YXR1cycpOyAvLyBCaW5kIHRoZW0gdG8gYHRoaXNgLCBub3QgaW4gY2xvc3VyZSwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBub3RcbiAgICAvLyBiZSByZXBsYWNlZCB3aGVuIHVzZXIgY2FsbGluZyBzZXRPcHRpb24gaW4gbm90IG1lcmdlIG1vZGUuXG5cbiAgICB0aGlzLl9heGlzTW9kZWwgPSBheGlzTW9kZWw7XG4gICAgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWw7XG4gICAgdGhpcy5fYXBpID0gYXBpOyAvLyBPcHRpbWl6ZTogYHJlbmRlcmAgd2lsbCBiZSBjYWxsZWQgcmVwZWF0bHkgZHVyaW5nIG1vdXNlIG1vdmUuXG4gICAgLy8gU28gaXQgaXMgcG93ZXIgY29uc3VtaW5nIGlmIHBlcmZvcm1pbmcgYHJlbmRlcmAgZWFjaCB0aW1lLFxuICAgIC8vIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZS5cblxuICAgIGlmICghZm9yY2VSZW5kZXIgJiYgdGhpcy5fbGFzdFZhbHVlID09PSB2YWx1ZSAmJiB0aGlzLl9sYXN0U3RhdHVzID09PSBzdGF0dXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9sYXN0U3RhdHVzID0gc3RhdHVzO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3VwO1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG5cbiAgICBpZiAoIXN0YXR1cyB8fCBzdGF0dXMgPT09ICdoaWRlJykge1xuICAgICAgLy8gRG8gbm90IGNsZWFyIGhlcmUsIGZvciBhbmltYXRpb24gYmV0dGVyLlxuICAgICAgZ3JvdXAgJiYgZ3JvdXAuaGlkZSgpO1xuICAgICAgaGFuZGxlICYmIGhhbmRsZS5oaWRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ3JvdXAgJiYgZ3JvdXAuc2hvdygpO1xuICAgIGhhbmRsZSAmJiBoYW5kbGUuc2hvdygpOyAvLyBPdGhlcndpc2Ugc3RhdHVzIGlzICdzaG93J1xuXG4gICAgdmFyIGVsT3B0aW9uID0ge307XG4gICAgdGhpcy5tYWtlRWxPcHRpb24oZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSk7IC8vIEVuYWJsZSBjaGFuZ2UgYXhpcyBwb2ludGVyIHR5cGUuXG5cbiAgICB2YXIgZ3JhcGhpY0tleSA9IGVsT3B0aW9uLmdyYXBoaWNLZXk7XG5cbiAgICBpZiAoZ3JhcGhpY0tleSAhPT0gdGhpcy5fbGFzdEdyYXBoaWNLZXkpIHtcbiAgICAgIHRoaXMuY2xlYXIoYXBpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0R3JhcGhpY0tleSA9IGdyYXBoaWNLZXk7XG4gICAgdmFyIG1vdmVBbmltYXRpb24gPSB0aGlzLl9tb3ZlQW5pbWF0aW9uID0gdGhpcy5kZXRlcm1pbmVBbmltYXRpb24oYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIGdyb3VwID0gdGhpcy5fZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgdGhpcy5jcmVhdGVQb2ludGVyRWwoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgdGhpcy5jcmVhdGVMYWJlbEVsKGdyb3VwLCBlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKTtcbiAgICAgIGFwaS5nZXRacigpLmFkZChncm91cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb1VwZGF0ZVByb3BzID0genJVdGlsLmN1cnJ5KHVwZGF0ZVByb3BzLCBheGlzUG9pbnRlck1vZGVsLCBtb3ZlQW5pbWF0aW9uKTtcbiAgICAgIHRoaXMudXBkYXRlUG9pbnRlckVsKGdyb3VwLCBlbE9wdGlvbiwgZG9VcGRhdGVQcm9wcywgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsRWwoZ3JvdXAsIGVsT3B0aW9uLCBkb1VwZGF0ZVByb3BzLCBheGlzUG9pbnRlck1vZGVsKTtcbiAgICB9XG5cbiAgICB1cGRhdGVNYW5kYXRvcnlQcm9wcyhncm91cCwgYXhpc1BvaW50ZXJNb2RlbCwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9yZW5kZXJIYW5kbGUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAaW1wbGVtZW50XG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLmNsZWFyKGFwaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBpbXBsZW1lbnRcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLmNsZWFyKGFwaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRldGVybWluZUFuaW1hdGlvbjogZnVuY3Rpb24gKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBhbmltYXRpb24gPSBheGlzUG9pbnRlck1vZGVsLmdldCgnYW5pbWF0aW9uJyk7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgaXNDYXRlZ29yeUF4aXMgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgdmFyIHVzZVNuYXAgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc25hcCcpOyAvLyBWYWx1ZSBheGlzIHdpdGhvdXQgc25hcCBhbHdheXMgZG8gbm90IHNuYXAuXG5cbiAgICBpZiAoIXVzZVNuYXAgJiYgIWlzQ2F0ZWdvcnlBeGlzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGlvbiA9PT0gJ2F1dG8nIHx8IGFuaW1hdGlvbiA9PSBudWxsKSB7XG4gICAgICB2YXIgYW5pbWF0aW9uVGhyZXNob2xkID0gdGhpcy5hbmltYXRpb25UaHJlc2hvbGQ7XG5cbiAgICAgIGlmIChpc0NhdGVnb3J5QXhpcyAmJiBheGlzLmdldEJhbmRXaWR0aCgpID4gYW5pbWF0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gYXV0byBhbmltYXRpb24gd2hlbiBzbmFwIHVzZWQuIENvbnNpZGVyIGlmIHRoZXJlIGlzXG4gICAgICAvLyBhIGRhdGFab29tLCBhbmltYXRpb24gd2lsbCBiZSBkaXNhYmxlZCB3aGVuIHRvbyBtYW55IHBvaW50cyBleGlzdCwgd2hpbGVcbiAgICAgIC8vIGl0IHdpbGwgYmUgZW5hYmxlZCBmb3IgYmV0dGVyIHZpc3VhbCBlZmZlY3Qgd2hlbiBsaXR0bGUgcG9pbnRzIGV4aXN0LlxuXG5cbiAgICAgIGlmICh1c2VTbmFwKSB7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhQ291bnQgPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmdldEF4aXNJbmZvKGF4aXNNb2RlbCkuc2VyaWVzRGF0YUNvdW50O1xuICAgICAgICB2YXIgYXhpc0V4dGVudCA9IGF4aXMuZ2V0RXh0ZW50KCk7IC8vIEFwcHJveGltYXRlIGJhbmQgd2lkdGhcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXhpc0V4dGVudFswXSAtIGF4aXNFeHRlbnRbMV0pIC8gc2VyaWVzRGF0YUNvdW50ID4gYW5pbWF0aW9uVGhyZXNob2xkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbiA9PT0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYWRkIHtwb2ludGVyLCBsYWJlbCwgZ3JhcGhpY0tleX0gdG8gZWxPcHRpb25cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbWFrZUVsT3B0aW9uOiBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkgey8vIFNob3VsZSBiZSBpbXBsZW1lbmVudGVkIGJ5IHN1Yi1jbGFzcy5cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY3JlYXRlUG9pbnRlckVsOiBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgcG9pbnRlck9wdGlvbiA9IGVsT3B0aW9uLnBvaW50ZXI7XG5cbiAgICBpZiAocG9pbnRlck9wdGlvbikge1xuICAgICAgdmFyIHBvaW50ZXJFbCA9IGdldChncm91cCkucG9pbnRlckVsID0gbmV3IGdyYXBoaWNbcG9pbnRlck9wdGlvbi50eXBlXShjbG9uZShlbE9wdGlvbi5wb2ludGVyKSk7XG4gICAgICBncm91cC5hZGQocG9pbnRlckVsKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNyZWF0ZUxhYmVsRWw6IGZ1bmN0aW9uIChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIGlmIChlbE9wdGlvbi5sYWJlbCkge1xuICAgICAgdmFyIGxhYmVsRWwgPSBnZXQoZ3JvdXApLmxhYmVsRWwgPSBuZXcgZ3JhcGhpYy5SZWN0KGNsb25lKGVsT3B0aW9uLmxhYmVsKSk7XG4gICAgICBncm91cC5hZGQobGFiZWxFbCk7XG4gICAgICB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdXBkYXRlUG9pbnRlckVsOiBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCB1cGRhdGVQcm9wcykge1xuICAgIHZhciBwb2ludGVyRWwgPSBnZXQoZ3JvdXApLnBvaW50ZXJFbDtcblxuICAgIGlmIChwb2ludGVyRWwpIHtcbiAgICAgIHBvaW50ZXJFbC5zZXRTdHlsZShlbE9wdGlvbi5wb2ludGVyLnN0eWxlKTtcbiAgICAgIHVwZGF0ZVByb3BzKHBvaW50ZXJFbCwge1xuICAgICAgICBzaGFwZTogZWxPcHRpb24ucG9pbnRlci5zaGFwZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB1cGRhdGVMYWJlbEVsOiBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCB1cGRhdGVQcm9wcywgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBsYWJlbEVsID0gZ2V0KGdyb3VwKS5sYWJlbEVsO1xuXG4gICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgIGxhYmVsRWwuc2V0U3R5bGUoZWxPcHRpb24ubGFiZWwuc3R5bGUpO1xuICAgICAgdXBkYXRlUHJvcHMobGFiZWxFbCwge1xuICAgICAgICAvLyBDb25zaWRlciB0ZXh0IGxlbmd0aCBjaGFuZ2UgaW4gdmVydGljYWwgYXhpcywgYW5pbWF0aW9uIHNob3VsZFxuICAgICAgICAvLyBiZSB1c2VkIG9uIHNoYXBlLCBvdGhlcndpc2UgdGhlIGVmZmVjdCB3aWxsIGJlIHdlaXJkLlxuICAgICAgICBzaGFwZTogZWxPcHRpb24ubGFiZWwuc2hhcGUsXG4gICAgICAgIHBvc2l0aW9uOiBlbE9wdGlvbi5sYWJlbC5wb3NpdGlvblxuICAgICAgfSk7XG4gICAgICB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJIYW5kbGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9kcmFnZ2luZyB8fCAhdGhpcy51cGRhdGVIYW5kbGVUcmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IHRoaXMuX2F4aXNQb2ludGVyTW9kZWw7XG5cbiAgICB2YXIgenIgPSB0aGlzLl9hcGkuZ2V0WnIoKTtcblxuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgdmFyIGhhbmRsZU1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbC5nZXRNb2RlbCgnaGFuZGxlJyk7XG4gICAgdmFyIHN0YXR1cyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzdGF0dXMnKTtcblxuICAgIGlmICghaGFuZGxlTW9kZWwuZ2V0KCdzaG93JykgfHwgIXN0YXR1cyB8fCBzdGF0dXMgPT09ICdoaWRlJykge1xuICAgICAgaGFuZGxlICYmIHpyLnJlbW92ZShoYW5kbGUpO1xuICAgICAgdGhpcy5faGFuZGxlID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXNJbml0O1xuXG4gICAgaWYgKCF0aGlzLl9oYW5kbGUpIHtcbiAgICAgIGlzSW5pdCA9IHRydWU7XG4gICAgICBoYW5kbGUgPSB0aGlzLl9oYW5kbGUgPSBncmFwaGljLmNyZWF0ZUljb24oaGFuZGxlTW9kZWwuZ2V0KCdpY29uJyksIHtcbiAgICAgICAgY3Vyc29yOiAnbW92ZScsXG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgb25tb3VzZW1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8gRm90IG1vYmlsZSBkZXZpY2VtLCBwcmV2ZW50IHNjcmVlbiBzbGlkZXIgb24gdGhlIGJ1dHRvbi5cbiAgICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25tb3VzZWRvd246IGJpbmQodGhpcy5fb25IYW5kbGVEcmFnTW92ZSwgdGhpcywgMCwgMCksXG4gICAgICAgIGRyaWZ0OiBiaW5kKHRoaXMuX29uSGFuZGxlRHJhZ01vdmUsIHRoaXMpLFxuICAgICAgICBvbmRyYWdlbmQ6IGJpbmQodGhpcy5fb25IYW5kbGVEcmFnRW5kLCB0aGlzKVxuICAgICAgfSk7XG4gICAgICB6ci5hZGQoaGFuZGxlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVNYW5kYXRvcnlQcm9wcyhoYW5kbGUsIGF4aXNQb2ludGVyTW9kZWwsIGZhbHNlKTsgLy8gdXBkYXRlIHN0eWxlXG5cbiAgICB2YXIgaW5jbHVkZVN0eWxlcyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYm9yZGVyV2lkdGgnLCAnb3BhY2l0eScsICdzaGFkb3dDb2xvcicsICdzaGFkb3dCbHVyJywgJ3NoYWRvd09mZnNldFgnLCAnc2hhZG93T2Zmc2V0WSddO1xuICAgIGhhbmRsZS5zZXRTdHlsZShoYW5kbGVNb2RlbC5nZXRJdGVtU3R5bGUobnVsbCwgaW5jbHVkZVN0eWxlcykpOyAvLyB1cGRhdGUgcG9zaXRpb25cblxuICAgIHZhciBoYW5kbGVTaXplID0gaGFuZGxlTW9kZWwuZ2V0KCdzaXplJyk7XG5cbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGhhbmRsZVNpemUpKSB7XG4gICAgICBoYW5kbGVTaXplID0gW2hhbmRsZVNpemUsIGhhbmRsZVNpemVdO1xuICAgIH1cblxuICAgIGhhbmRsZS5hdHRyKCdzY2FsZScsIFtoYW5kbGVTaXplWzBdIC8gMiwgaGFuZGxlU2l6ZVsxXSAvIDJdKTtcbiAgICB0aHJvdHRsZVV0aWwuY3JlYXRlT3JVcGRhdGUodGhpcywgJ19kb0Rpc3BhdGNoQXhpc1BvaW50ZXInLCBoYW5kbGVNb2RlbC5nZXQoJ3Rocm90dGxlJykgfHwgMCwgJ2ZpeFJhdGUnKTtcblxuICAgIHRoaXMuX21vdmVIYW5kbGVUb1ZhbHVlKHZhbHVlLCBpc0luaXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVIYW5kbGVUb1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGlzSW5pdCkge1xuICAgIHVwZGF0ZVByb3BzKHRoaXMuX2F4aXNQb2ludGVyTW9kZWwsICFpc0luaXQgJiYgdGhpcy5fbW92ZUFuaW1hdGlvbiwgdGhpcy5faGFuZGxlLCBnZXRIYW5kbGVUcmFuc1Byb3BzKHRoaXMuZ2V0SGFuZGxlVHJhbnNmb3JtKHZhbHVlLCB0aGlzLl9heGlzTW9kZWwsIHRoaXMuX2F4aXNQb2ludGVyTW9kZWwpKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25IYW5kbGVEcmFnTW92ZTogZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG5cbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTsgLy8gUGVyc2lzdGVudCBmb3IgdGhyb3R0bGUuXG5cbiAgICB2YXIgdHJhbnMgPSB0aGlzLnVwZGF0ZUhhbmRsZVRyYW5zZm9ybShnZXRIYW5kbGVUcmFuc1Byb3BzKGhhbmRsZSksIFtkeCwgZHldLCB0aGlzLl9heGlzTW9kZWwsIHRoaXMuX2F4aXNQb2ludGVyTW9kZWwpO1xuICAgIHRoaXMuX3BheWxvYWRJbmZvID0gdHJhbnM7XG4gICAgaGFuZGxlLnN0b3BBbmltYXRpb24oKTtcbiAgICBoYW5kbGUuYXR0cihnZXRIYW5kbGVUcmFuc1Byb3BzKHRyYW5zKSk7XG4gICAgZ2V0KGhhbmRsZSkubGFzdFByb3AgPSBudWxsO1xuXG4gICAgdGhpcy5fZG9EaXNwYXRjaEF4aXNQb2ludGVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRocm90dGxlZCBtZXRob2QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9EaXNwYXRjaEF4aXNQb2ludGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcblxuICAgIGlmICghaGFuZGxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWRJbmZvID0gdGhpcy5fcGF5bG9hZEluZm87XG4gICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuX2F4aXNNb2RlbDtcblxuICAgIHRoaXMuX2FwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgeDogcGF5bG9hZEluZm8uY3Vyc29yUG9pbnRbMF0sXG4gICAgICB5OiBwYXlsb2FkSW5mby5jdXJzb3JQb2ludFsxXSxcbiAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWRJbmZvLnRvb2x0aXBPcHRpb24sXG4gICAgICBheGVzSW5mbzogW3tcbiAgICAgICAgYXhpc0RpbTogYXhpc01vZGVsLmF4aXMuZGltLFxuICAgICAgICBheGlzSW5kZXg6IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleFxuICAgICAgfV1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkhhbmRsZURyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlQW5pbWF0aW9uKSB7XG4gICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB2YXIgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuXG4gICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLl9heGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTsgLy8gQ29uc2lkZXIgc25hcCBvciBjYXRlZ3JveSBheGlzLCBoYW5kbGUgbWF5IGJlIG5vdCBjb25zaXN0ZW50IHdpdGhcbiAgICAvLyBheGlzUG9pbnRlci4gU28gbW92ZSBoYW5kbGUgdG8gYWxpZ24gdGhlIGV4YWN0IHZhbHVlIHBvc2l0aW9uIHdoZW5cbiAgICAvLyBkcmFnIGVuZGVkLlxuXG5cbiAgICB0aGlzLl9tb3ZlSGFuZGxlVG9WYWx1ZSh2YWx1ZSk7IC8vIEZvciB0aGUgZWZmZWN0OiB0b29sdGlwIHdpbGwgYmUgc2hvd24gd2hlbiBmaW5nZXIgaG9sZGluZyBvbiBoYW5kbGVcbiAgICAvLyBidXR0b24sIGFuZCB3aWxsIGJlIGhpZGRlbiBhZnRlciBmaW5nZXIgbGVmdCBoYW5kbGUgYnV0dG9uLlxuXG5cbiAgICB0aGlzLl9hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2hpZGVUaXAnXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3VsZCBiZSBpbXBsZW1lbmVudGVkIGJ5IHN1Yi1jbGFzcyBpZiBzdXBwb3J0IGBoYW5kbGVgLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzTW9kZWxcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc1BvaW50ZXJNb2RlbFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHtwb3NpdGlvbjogW3gsIHldLCByb3RhdGlvbjogMH1cbiAgICovXG4gIGdldEhhbmRsZVRyYW5zZm9ybTogbnVsbCxcblxuICAvKipcbiAgICogKiBTaG91bGQgYmUgaW1wbGVtZW5lbnRlZCBieSBzdWItY2xhc3MgaWYgc3VwcG9ydCBgaGFuZGxlYC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIHtwb3NpdGlvbiwgcm90YXRpb259XG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRlbHRhIFtkeCwgZHldXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGF4aXNNb2RlbFxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzUG9pbnRlck1vZGVsXG4gICAqIEByZXR1cm4ge09iamVjdH0ge3Bvc2l0aW9uOiBbeCwgeV0sIHJvdGF0aW9uOiAwLCBjdXJzb3JQb2ludDogW3gsIHldfVxuICAgKi9cbiAgdXBkYXRlSGFuZGxlVHJhbnNmb3JtOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLl9sYXN0VmFsdWUgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RTdGF0dXMgPSBudWxsO1xuICAgIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3VwO1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG5cbiAgICBpZiAoenIgJiYgZ3JvdXApIHtcbiAgICAgIHRoaXMuX2xhc3RHcmFwaGljS2V5ID0gbnVsbDtcbiAgICAgIGdyb3VwICYmIHpyLnJlbW92ZShncm91cCk7XG4gICAgICBoYW5kbGUgJiYgenIucmVtb3ZlKGhhbmRsZSk7XG4gICAgICB0aGlzLl9ncm91cCA9IG51bGw7XG4gICAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICAgICAgdGhpcy5fcGF5bG9hZEluZm8gPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZG9DbGVhcjogZnVuY3Rpb24gKCkgey8vIEltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzcyBpZiBuZWNlc3NhcnkuXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0geHlcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gd2hcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4RGltSW5kZXg9MF0gb3IgMVxuICAgKi9cbiAgYnVpbGRMYWJlbDogZnVuY3Rpb24gKHh5LCB3aCwgeERpbUluZGV4KSB7XG4gICAgeERpbUluZGV4ID0geERpbUluZGV4IHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHh5W3hEaW1JbmRleF0sXG4gICAgICB5OiB4eVsxIC0geERpbUluZGV4XSxcbiAgICAgIHdpZHRoOiB3aFt4RGltSW5kZXhdLFxuICAgICAgaGVpZ2h0OiB3aFsxIC0geERpbUluZGV4XVxuICAgIH07XG4gIH1cbn07XG5CYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFzZUF4aXNQb2ludGVyO1xuXG5mdW5jdGlvbiB1cGRhdGVQcm9wcyhhbmltYXRpb25Nb2RlbCwgbW92ZUFuaW1hdGlvbiwgZWwsIHByb3BzKSB7XG4gIC8vIEFuaW1hdGlvbiBvcHRpbWl6ZS5cbiAgaWYgKCFwcm9wc0VxdWFsKGdldChlbCkubGFzdFByb3AsIHByb3BzKSkge1xuICAgIGdldChlbCkubGFzdFByb3AgPSBwcm9wcztcbiAgICBtb3ZlQW5pbWF0aW9uID8gZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwgcHJvcHMsIGFuaW1hdGlvbk1vZGVsKSA6IChlbC5zdG9wQW5pbWF0aW9uKCksIGVsLmF0dHIocHJvcHMpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wc0VxdWFsKGxhc3RQcm9wcywgbmV3UHJvcHMpIHtcbiAgaWYgKHpyVXRpbC5pc09iamVjdChsYXN0UHJvcHMpICYmIHpyVXRpbC5pc09iamVjdChuZXdQcm9wcykpIHtcbiAgICB2YXIgZXF1YWxzID0gdHJ1ZTtcbiAgICB6clV0aWwuZWFjaChuZXdQcm9wcywgZnVuY3Rpb24gKGl0ZW0sIGtleSkge1xuICAgICAgZXF1YWxzID0gZXF1YWxzICYmIHByb3BzRXF1YWwobGFzdFByb3BzW2tleV0sIGl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiAhIWVxdWFscztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGFzdFByb3BzID09PSBuZXdQcm9wcztcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgbGFiZWxFbFtheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwuc2hvdycpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xufVxuXG5mdW5jdGlvbiBnZXRIYW5kbGVUcmFuc1Byb3BzKHRyYW5zKSB7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHRyYW5zLnBvc2l0aW9uLnNsaWNlKCksXG4gICAgcm90YXRpb246IHRyYW5zLnJvdGF0aW9uIHx8IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWFuZGF0b3J5UHJvcHMoZ3JvdXAsIGF4aXNQb2ludGVyTW9kZWwsIHNpbGVudCkge1xuICB2YXIgeiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd6Jyk7XG4gIHZhciB6bGV2ZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnemxldmVsJyk7XG4gIGdyb3VwICYmIGdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICB6ICE9IG51bGwgJiYgKGVsLnogPSB6KTtcbiAgICAgIHpsZXZlbCAhPSBudWxsICYmIChlbC56bGV2ZWwgPSB6bGV2ZWwpO1xuICAgICAgZWwuc2lsZW50ID0gc2lsZW50O1xuICAgIH1cbiAgfSk7XG59XG5cbmNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChCYXNlQXhpc1BvaW50ZXIpO1xudmFyIF9kZWZhdWx0ID0gQmFzZUF4aXNQb2ludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQmFzZUF4aXNQb2ludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgX2RlZmF1bHQgPSBlY2hhcnRzLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcbiAgdHlwZTogJ3Rvb2x0aXAnLFxuICBkZXBlbmRlbmNpZXM6IFsnYXhpc1BvaW50ZXInXSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIHpsZXZlbDogMCxcbiAgICB6OiA4LFxuICAgIHNob3c6IHRydWUsXG4gICAgLy8gdG9vbHRpcOS4u+S9k+WGheWuuVxuICAgIHNob3dDb250ZW50OiB0cnVlLFxuICAgIC8vICd0cmlnZ2VyJyBvbmx5IHdvcmtzIG9uIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIC8vICdpdGVtJyB8ICdheGlzJyB8ICdub25lJ1xuICAgIHRyaWdnZXI6ICdpdGVtJyxcbiAgICAvLyAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZSdcbiAgICB0cmlnZ2VyT246ICdtb3VzZW1vdmV8Y2xpY2snLFxuICAgIGFsd2F5c1Nob3dDb250ZW50OiBmYWxzZSxcbiAgICBkaXNwbGF5TW9kZTogJ3NpbmdsZScsXG4gICAgLy8gJ3NpbmdsZScgfCAnbXVsdGlwbGVCeUNvb3JkU3lzJ1xuICAgIC8vIOS9jee9riB7QXJyYXl9IHwge0Z1bmN0aW9ufVxuICAgIC8vIHBvc2l0aW9uOiBudWxsXG4gICAgLy8gQ29uc2lkZXIgdHJpZ2dlcmVkIGZyb20gYXhpc1BvaW50ZXIgaGFuZGxlLCB2ZXJ0aWNhbEFsaWduIHNob3VsZCBiZSAnbWlkZGxlJ1xuICAgIC8vIGFsaWduOiBudWxsLFxuICAgIC8vIHZlcnRpY2FsQWxpZ246IG51bGwsXG4gICAgLy8g5piv5ZCm57qm5p2fIGNvbnRlbnQg5ZyoIHZpZXdSZWN0IOS4reOAgum7mOiupCBmYWxzZSDmmK/kuLrkuoblhbzlrrnku6XliY3niYjmnKzjgIJcbiAgICBjb25maW5lOiBmYWxzZSxcbiAgICAvLyDlhoXlrrnmoLzlvI/lmajvvJp7c3RyaW5nfe+8iFRlbXBsYXRl77yJIMKmIHtGdW5jdGlvbn1cbiAgICAvLyBmb3JtYXR0ZXI6IG51bGxcbiAgICBzaG93RGVsYXk6IDAsXG4gICAgLy8g6ZqQ6JeP5bu26L+f77yM5Y2V5L2NbXNcbiAgICBoaWRlRGVsYXk6IDEwMCxcbiAgICAvLyDliqjnlLvlj5jmjaLml7bpl7TvvIzljZXkvY1zXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAwLjQsXG4gICAgZW50ZXJhYmxlOiBmYWxzZSxcbiAgICAvLyDmj5DnpLrog4zmma/popzoibLvvIzpu5jorqTkuLrpgI/mmI7luqbkuLowLjfnmoTpu5HoibJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDUwLDUwLDUwLDAuNyknLFxuICAgIC8vIOaPkOekuui+ueahhuminOiJslxuICAgIGJvcmRlckNvbG9yOiAnIzMzMycsXG4gICAgLy8g5o+Q56S66L655qGG5ZyG6KeS77yM5Y2V5L2NcHjvvIzpu5jorqTkuLo0XG4gICAgYm9yZGVyUmFkaXVzOiA0LFxuICAgIC8vIOaPkOekuui+ueahhue6v+Wuve+8jOWNleS9jXB477yM6buY6K6k5Li6MO+8iOaXoOi+ueahhu+8iVxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIC8vIOaPkOekuuWGhei+uei3ne+8jOWNleS9jXB477yM6buY6K6k5ZCE5pa55ZCR5YaF6L656Led5Li6Ne+8jFxuICAgIC8vIOaOpeWPl+aVsOe7hOWIhuWIq+iuvuWumuS4iuWPs+S4i+W3pui+uei3ne+8jOWQjGNzc1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLy8gRXh0cmEgY3NzIHRleHRcbiAgICBleHRyYUNzc1RleHQ6ICcnLFxuICAgIC8vIOWdkOagh+i9tOaMh+ekuuWZqO+8jOWdkOagh+i9tOinpuWPkeacieaViFxuICAgIGF4aXNQb2ludGVyOiB7XG4gICAgICAvLyDpu5jorqTkuLrnm7Tnur9cbiAgICAgIC8vIOWPr+mAieS4uu+8midsaW5lJyB8ICdzaGFkb3cnIHwgJ2Nyb3NzJ1xuICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgLy8gdHlwZSDkuLogbGluZSDnmoTml7blgJnmnInmlYjvvIzmjIflrpogdG9vbHRpcCBsaW5lIOaJgOWcqOeahOi9tO+8jOWPr+mAiVxuICAgICAgLy8g5Y+v6YCJICd4JyB8ICd5JyB8ICdhbmdsZScgfCAncmFkaXVzJyB8ICdhdXRvJ1xuICAgICAgLy8g6buY6K6kICdhdXRvJ++8jOS8mumAieaLqeexu+Wei+S4uiBjYXRlb2dyeSDnmoTovbTvvIzlr7nkuo7lj4zmlbDlgLzovbTvvIznrJvljaHlsJTlnZDmoIfns7vkvJrpu5jorqTpgInmi6kgeCDovbRcbiAgICAgIC8vIOaegeWdkOagh+ezu+S8mum7mOiupOmAieaLqSBhbmdsZSDovbRcbiAgICAgIGF4aXM6ICdhdXRvJyxcbiAgICAgIGFuaW1hdGlvbjogJ2F1dG8nLFxuICAgICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDIwMCxcbiAgICAgIGFuaW1hdGlvbkVhc2luZ1VwZGF0ZTogJ2V4cG9uZW50aWFsT3V0JyxcbiAgICAgIGNyb3NzU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjOTk5JyxcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIHR5cGU6ICdkYXNoZWQnLFxuICAgICAgICAvLyBUT0RPIGZvcm1hdHRlclxuICAgICAgICB0ZXh0U3R5bGU6IHt9IC8vIGxpbmVTdHlsZSBhbmQgc2hhZG93U3R5bGUgc2hvdWxkIG5vdCBiZSBzcGVjaWZpZWQgaGVyZSxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IHdpbGwgYWx3YXlzIG92ZXJyaWRlIHRob3NlIHN0eWxlcyBvbiBvcHRpb24uYXhpc1BvaW50ZXIuXG5cbiAgICAgIH1cbiAgICB9LFxuICAgIHRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgIGZvbnRTaXplOiAxNFxuICAgIH1cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2VudlwiKTtcblxudmFyIFRvb2x0aXBDb250ZW50ID0gcmVxdWlyZShcIi4vVG9vbHRpcENvbnRlbnRcIik7XG5cbnZhciBmb3JtYXRVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZm9ybWF0XCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgZmluZFBvaW50RnJvbVNlcmllcyA9IHJlcXVpcmUoXCIuLi9heGlzUG9pbnRlci9maW5kUG9pbnRGcm9tU2VyaWVzXCIpO1xuXG52YXIgbGF5b3V0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xheW91dFwiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL01vZGVsXCIpO1xuXG52YXIgZ2xvYmFsTGlzdGVuZXIgPSByZXF1aXJlKFwiLi4vYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXJcIik7XG5cbnZhciBheGlzSGVscGVyID0gcmVxdWlyZShcIi4uLy4uL2Nvb3JkL2F4aXNIZWxwZXJcIik7XG5cbnZhciBheGlzUG9pbnRlclZpZXdIZWxwZXIgPSByZXF1aXJlKFwiLi4vYXhpc1BvaW50ZXIvdmlld0hlbHBlclwiKTtcblxudmFyIGJpbmQgPSB6clV0aWwuYmluZDtcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgcGFyc2VQZXJjZW50ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQ7XG52YXIgcHJveHlSZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gIHNoYXBlOiB7XG4gICAgeDogLTEsXG4gICAgeTogLTEsXG4gICAgd2lkdGg6IDIsXG4gICAgaGVpZ2h0OiAyXG4gIH1cbn0pO1xuXG52YXIgX2RlZmF1bHQgPSBlY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuICB0eXBlOiAndG9vbHRpcCcsXG4gIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSBuZXcgVG9vbHRpcENvbnRlbnQoYXBpLmdldERvbSgpLCBhcGkpO1xuICAgIHRoaXMuX3Rvb2x0aXBDb250ZW50ID0gdG9vbHRpcENvbnRlbnQ7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBSZXNldFxuXG5cbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbH1cbiAgICAgKi9cblxuICAgIHRoaXMuX3Rvb2x0aXBNb2RlbCA9IHRvb2x0aXBNb2RlbDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICovXG5cbiAgICB0aGlzLl9lY01vZGVsID0gZWNNb2RlbDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gICAgICovXG5cbiAgICB0aGlzLl9hcGkgPSBhcGk7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIGJlIGNsZWFuZWQgd2hlbiByZW5kZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5LjxPYmplY3Q+Pn1cbiAgICAgKi9cblxuICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICAgIHRoaXMuX2Fsd2F5c1Nob3dDb250ZW50ID0gdG9vbHRpcE1vZGVsLmdldCgnYWx3YXlzU2hvd0NvbnRlbnQnKTtcbiAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcbiAgICB0b29sdGlwQ29udGVudC51cGRhdGUoKTtcbiAgICB0b29sdGlwQ29udGVudC5zZXRFbnRlcmFibGUodG9vbHRpcE1vZGVsLmdldCgnZW50ZXJhYmxlJykpO1xuXG4gICAgdGhpcy5faW5pdEdsb2JhbExpc3RlbmVyKCk7XG5cbiAgICB0aGlzLl9rZWVwU2hvdygpO1xuICB9LFxuICBfaW5pdEdsb2JhbExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcbiAgICB2YXIgdHJpZ2dlck9uID0gdG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlck9uJyk7XG4gICAgZ2xvYmFsTGlzdGVuZXIucmVnaXN0ZXIoJ2l0ZW1Ub29sdGlwJywgdGhpcy5fYXBpLCBiaW5kKGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgIC8vIElmICdub25lJywgaXQgaXMgbm90IGNvbnRyb2xsZWQgYnkgbW91c2UgdG90YWxseS5cbiAgICAgIGlmICh0cmlnZ2VyT24gIT09ICdub25lJykge1xuICAgICAgICBpZiAodHJpZ2dlck9uLmluZGV4T2YoY3VyclRyaWdnZXIpID49IDApIHtcbiAgICAgICAgICB0aGlzLl90cnlTaG93KGUsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJykge1xuICAgICAgICAgIHRoaXMuX2hpZGUoZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcykpO1xuICB9LFxuICBfa2VlcFNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICB2YXIgYXBpID0gdGhpcy5fYXBpOyAvLyBUcnkgdG8ga2VlcCB0aGUgdG9vbHRpcCBzaG93IHdoZW4gcmVmcmVzaGluZ1xuXG4gICAgaWYgKHRoaXMuX2xhc3RYICE9IG51bGwgJiYgdGhpcy5fbGFzdFkgIT0gbnVsbCAvLyBXaGVuIHVzZXIgaXMgd2lsbGluZyB0byBjb250cm9sIHRvb2x0aXAgdG90YWxseSB1c2luZyBBUEksXG4gICAgLy8gc2VsZi5tYW51YWxseVNob3dUaXAoe3gsIHl9KSBtaWdodCBjYXVzZSB0b29sdGlwIGhpZGUsXG4gICAgLy8gd2hpY2ggaXMgbm90IGV4cGVjdGVkLlxuICAgICYmIHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXJPbicpICE9PSAnbm9uZScpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoVXBkYXRlVGltZW91dCk7XG4gICAgICB0aGlzLl9yZWZyZXNoVXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTaG93IHRpcCBuZXh0IHRpY2sgYWZ0ZXIgb3RoZXIgY2hhcnRzIGFyZSByZW5kZXJlZFxuICAgICAgICAvLyBJbiBjYXNlIGhpZ2hsaWdodCBhY3Rpb24gaGFzIHdyb25nIHJlc3VsdFxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICBzZWxmLm1hbnVhbGx5U2hvd1RpcCh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwge1xuICAgICAgICAgIHg6IHNlbGYuX2xhc3RYLFxuICAgICAgICAgIHk6IHNlbGYuX2xhc3RZXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaG93IHRpcCBtYW51YWxseSBieVxuICAgKiBkaXNwYXRjaEFjdGlvbih7XG4gICAqICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAqICAgICB4OiAxMCxcbiAgICogICAgIHk6IDEwXG4gICAqIH0pO1xuICAgKiBPclxuICAgKiBkaXNwYXRjaEFjdGlvbih7XG4gICAqICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgKiAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgKiAgICAgIGRhdGFJbmRleCBvciBkYXRhSW5kZXhJbnNpZGUgb3IgbmFtZVxuICAgKiB9KTtcbiAgICpcbiAgICogIFRPRE8gQmF0Y2hcbiAgICovXG4gIG1hbnVhbGx5U2hvd1RpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgaWYgKHBheWxvYWQuZnJvbSA9PT0gdGhpcy51aWQgfHwgZW52Lm5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGlzcGF0Y2hBY3Rpb24gPSBtYWtlRGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCwgYXBpKTsgLy8gUmVzZXQgdGlja2V0XG5cbiAgICB0aGlzLl90aWNrZXQgPSAnJzsgLy8gV2hlbiB0cmlnZ2VyZWQgZnJvbSBheGlzUG9pbnRlci5cblxuICAgIHZhciBkYXRhQnlDb29yZFN5cyA9IHBheWxvYWQuZGF0YUJ5Q29vcmRTeXM7XG5cbiAgICBpZiAocGF5bG9hZC50b29sdGlwICYmIHBheWxvYWQueCAhPSBudWxsICYmIHBheWxvYWQueSAhPSBudWxsKSB7XG4gICAgICB2YXIgZWwgPSBwcm94eVJlY3Q7XG4gICAgICBlbC5wb3NpdGlvbiA9IFtwYXlsb2FkLngsIHBheWxvYWQueV07XG4gICAgICBlbC51cGRhdGUoKTtcbiAgICAgIGVsLnRvb2x0aXAgPSBwYXlsb2FkLnRvb2x0aXA7IC8vIE1hbnVhbGx5IHNob3cgdG9vbHRpcCB3aGlsZSB2aWV3IGlzIG5vdCB1c2luZyB6cmVuZGVyIGVsZW1lbnRzLlxuXG4gICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgb2Zmc2V0WDogcGF5bG9hZC54LFxuICAgICAgICBvZmZzZXRZOiBwYXlsb2FkLnksXG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGRhdGFCeUNvb3JkU3lzKSB7XG4gICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgb2Zmc2V0WDogcGF5bG9hZC54LFxuICAgICAgICBvZmZzZXRZOiBwYXlsb2FkLnksXG4gICAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uLFxuICAgICAgICBldmVudDoge30sXG4gICAgICAgIGRhdGFCeUNvb3JkU3lzOiBwYXlsb2FkLmRhdGFCeUNvb3JkU3lzLFxuICAgICAgICB0b29sdGlwT3B0aW9uOiBwYXlsb2FkLnRvb2x0aXBPcHRpb25cbiAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWQuc2VyaWVzSW5kZXggIT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuX21hbnVhbGx5QXhpc1Nob3dUaXAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50SW5mbyA9IGZpbmRQb2ludEZyb21TZXJpZXMocGF5bG9hZCwgZWNNb2RlbCk7XG4gICAgICB2YXIgY3ggPSBwb2ludEluZm8ucG9pbnRbMF07XG4gICAgICB2YXIgY3kgPSBwb2ludEluZm8ucG9pbnRbMV07XG5cbiAgICAgIGlmIChjeCAhPSBudWxsICYmIGN5ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgb2Zmc2V0WDogY3gsXG4gICAgICAgICAgb2Zmc2V0WTogY3ksXG4gICAgICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgICAgICAgdGFyZ2V0OiBwb2ludEluZm8uZWwsXG4gICAgICAgICAgZXZlbnQ6IHt9XG4gICAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBheWxvYWQueCAhPSBudWxsICYmIHBheWxvYWQueSAhPSBudWxsKSB7XG4gICAgICAvLyBGSVhNRVxuICAgICAgLy8gc2hvdWxkIHdyYXAgZGlzcGF0Y2hBY3Rpb24gbGlrZSBgYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXJgID9cbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gICAgICAgIHg6IHBheWxvYWQueCxcbiAgICAgICAgeTogcGF5bG9hZC55XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgIG9mZnNldFg6IHBheWxvYWQueCxcbiAgICAgICAgb2Zmc2V0WTogcGF5bG9hZC55LFxuICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiBhcGkuZ2V0WnIoKS5maW5kSG92ZXIocGF5bG9hZC54LCBwYXlsb2FkLnkpLnRhcmdldCxcbiAgICAgICAgZXZlbnQ6IHt9XG4gICAgICB9LCBkaXNwYXRjaEFjdGlvbik7XG4gICAgfVxuICB9LFxuICBtYW51YWxseUhpZGVUaXA6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xuXG4gICAgaWYgKCF0aGlzLl9hbHdheXNTaG93Q29udGVudCkge1xuICAgICAgdG9vbHRpcENvbnRlbnQuaGlkZUxhdGVyKHRoaXMuX3Rvb2x0aXBNb2RlbC5nZXQoJ2hpZGVEZWxheScpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0WCA9IHRoaXMuX2xhc3RZID0gbnVsbDtcblxuICAgIGlmIChwYXlsb2FkLmZyb20gIT09IHRoaXMudWlkKSB7XG4gICAgICB0aGlzLl9oaWRlKG1ha2VEaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBhcGkpKTtcbiAgICB9XG4gIH0sXG4gIC8vIEJlIGNvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBkZXNpZ24sIHRoYXQgaXMsIHdoZW4gdG9vbHRpcC50eXBlIGlzICdheGlzJyBhbmRcbiAgLy8gZGlzcGF0Y2hBY3Rpb24gJ3Nob3dUaXAnIHdpdGggc2VyaWVzSW5kZXggYW5kIGRhdGFJbmRleCB3aWxsIHRyaWdnZXIgYXhpcyBwb2ludGVyXG4gIC8vIGFuZCB0b29sdGlwLlxuICBfbWFudWFsbHlBeGlzU2hvd1RpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIHNlcmllc0luZGV4ID0gcGF5bG9hZC5zZXJpZXNJbmRleDtcbiAgICB2YXIgZGF0YUluZGV4ID0gcGF5bG9hZC5kYXRhSW5kZXg7XG4gICAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvO1xuXG4gICAgaWYgKHNlcmllc0luZGV4ID09IG51bGwgfHwgZGF0YUluZGV4ID09IG51bGwgfHwgY29vcmRTeXNBeGVzSW5mbyA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KHNlcmllc0luZGV4KTtcblxuICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW2RhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCksIHNlcmllc01vZGVsLCAoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSB8fCB7fSkubW9kZWwsIHRvb2x0aXBNb2RlbF0pO1xuXG4gICAgaWYgKHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKSAhPT0gJ2F4aXMnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICBkYXRhSW5kZXg6IGRhdGFJbmRleCxcbiAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIF90cnlTaG93OiBmdW5jdGlvbiAoZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuXG4gICAgaWYgKCF0b29sdGlwTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFNhdmUgbW91c2UgeCwgbW91c2UgeS4gU28gd2UgY2FuIHRyeSB0byBrZWVwIHNob3dpbmcgdGhlIHRpcCBpZiBjaGFydCBpcyByZWZyZXNoZWRcblxuXG4gICAgdGhpcy5fbGFzdFggPSBlLm9mZnNldFg7XG4gICAgdGhpcy5fbGFzdFkgPSBlLm9mZnNldFk7XG4gICAgdmFyIGRhdGFCeUNvb3JkU3lzID0gZS5kYXRhQnlDb29yZFN5cztcblxuICAgIGlmIChkYXRhQnlDb29yZFN5cyAmJiBkYXRhQnlDb29yZFN5cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3Nob3dBeGlzVG9vbHRpcChkYXRhQnlDb29yZFN5cywgZSk7XG4gICAgfSAvLyBBbHdheXMgc2hvdyBpdGVtIHRvb2x0aXAgaWYgbW91c2UgaXMgb24gdGhlIGVsZW1lbnQgd2l0aCBkYXRhSW5kZXhcbiAgICBlbHNlIGlmIChlbCAmJiBlbC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3Nob3dTZXJpZXNJdGVtVG9vbHRpcChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgfSAvLyBUb29sdGlwIHByb3ZpZGVkIGRpcmVjdGx5LiBMaWtlIGxlZ2VuZC5cbiAgICAgIGVsc2UgaWYgKGVsICYmIGVsLnRvb2x0aXApIHtcbiAgICAgICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuXG4gICAgICAgICAgdGhpcy5fc2hvd0NvbXBvbmVudEl0ZW1Ub29sdGlwKGUsIGVsLCBkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcblxuICAgICAgICAgIHRoaXMuX2hpZGUoZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICB9XG4gIH0sXG4gIF9zaG93T3JNb3ZlOiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBjYikge1xuICAgIC8vIHNob3dEZWxheSBpcyB1c2VkIGluIHRoaXMgY2FzZTogdG9vbHRpcC5lbnRlcmFibGUgaXMgc2V0XG4gICAgLy8gYXMgdHJ1ZS4gVXNlciBpbnRlbnQgdG8gbW92ZSBtb3VzZSBpbnRvIHRvb2x0aXAgYW5kIGNsaWNrXG4gICAgLy8gc29tZXRoaW5nLiBgc2hvd0RlbGF5YCBtYWtlcyBpdCBlYXN5ZXIgdG8gZW50ZXIgdGhlIGNvbnRlbnRcbiAgICAvLyBidXQgdG9vbHRpcCBkbyBub3QgbW92ZSBpbW1lZGlhdGVseS5cbiAgICB2YXIgZGVsYXkgPSB0b29sdGlwTW9kZWwuZ2V0KCdzaG93RGVsYXknKTtcbiAgICBjYiA9IHpyVXRpbC5iaW5kKGNiLCB0aGlzKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbW91dCk7XG4gICAgZGVsYXkgPiAwID8gdGhpcy5fc2hvd1RpbW91dCA9IHNldFRpbWVvdXQoY2IsIGRlbGF5KSA6IGNiKCk7XG4gIH0sXG4gIF9zaG93QXhpc1Rvb2x0aXA6IGZ1bmN0aW9uIChkYXRhQnlDb29yZFN5cywgZSkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICB2YXIgZ2xvYmFsVG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgIHZhciBwb2ludCA9IFtlLm9mZnNldFgsIGUub2Zmc2V0WV07XG4gICAgdmFyIHNpbmdsZURlZmF1bHRIVE1MID0gW107XG4gICAgdmFyIHNpbmdsZVBhcmFtc0xpc3QgPSBbXTtcbiAgICB2YXIgc2luZ2xlVG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW2UudG9vbHRpcE9wdGlvbiwgZ2xvYmFsVG9vbHRpcE1vZGVsXSk7XG4gICAgZWFjaChkYXRhQnlDb29yZFN5cywgZnVuY3Rpb24gKGl0ZW1Db29yZFN5cykge1xuICAgICAgLy8gdmFyIGNvb3JkUGFyYW1MaXN0ID0gW107XG4gICAgICAvLyB2YXIgY29vcmREZWZhdWx0SFRNTCA9IFtdO1xuICAgICAgLy8gdmFyIGNvb3JkVG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW1xuICAgICAgLy8gICAgIGUudG9vbHRpcE9wdGlvbixcbiAgICAgIC8vICAgICBpdGVtQ29vcmRTeXMudG9vbHRpcE9wdGlvbixcbiAgICAgIC8vICAgICBlY01vZGVsLmdldENvbXBvbmVudChpdGVtQ29vcmRTeXMuY29vcmRTeXNNYWluVHlwZSwgaXRlbUNvb3JkU3lzLmNvb3JkU3lzSW5kZXgpLFxuICAgICAgLy8gICAgIGdsb2JhbFRvb2x0aXBNb2RlbFxuICAgICAgLy8gXSk7XG4gICAgICAvLyB2YXIgZGlzcGxheU1vZGUgPSBjb29yZFRvb2x0aXBNb2RlbC5nZXQoJ2Rpc3BsYXlNb2RlJyk7XG4gICAgICAvLyB2YXIgcGFyYW1zTGlzdCA9IGRpc3BsYXlNb2RlID09PSAnc2luZ2xlJyA/IHNpbmdsZVBhcmFtc0xpc3QgOiBbXTtcbiAgICAgIGVhY2goaXRlbUNvb3JkU3lzLmRhdGFCeUF4aXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudChpdGVtLmF4aXNEaW0gKyAnQXhpcycsIGl0ZW0uYXhpc0luZGV4KTtcbiAgICAgICAgdmFyIGF4aXNWYWx1ZSA9IGl0ZW0udmFsdWU7XG4gICAgICAgIHZhciBzZXJpZXNEZWZhdWx0SFRNTCA9IFtdO1xuXG4gICAgICAgIGlmICghYXhpc01vZGVsIHx8IGF4aXNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlTGFiZWwgPSBheGlzUG9pbnRlclZpZXdIZWxwZXIuZ2V0VmFsdWVMYWJlbChheGlzVmFsdWUsIGF4aXNNb2RlbC5heGlzLCBlY01vZGVsLCBpdGVtLnNlcmllc0RhdGFJbmRpY2VzLCBpdGVtLnZhbHVlTGFiZWxPcHQpO1xuICAgICAgICB6clV0aWwuZWFjaChpdGVtLnNlcmllc0RhdGFJbmRpY2VzLCBmdW5jdGlvbiAoaWR4SXRlbSkge1xuICAgICAgICAgIHZhciBzZXJpZXMgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoaWR4SXRlbS5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGlkeEl0ZW0uZGF0YUluZGV4SW5zaWRlO1xuICAgICAgICAgIHZhciBkYXRhUGFyYW1zID0gc2VyaWVzICYmIHNlcmllcy5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCk7XG4gICAgICAgICAgZGF0YVBhcmFtcy5heGlzRGltID0gaXRlbS5heGlzRGltO1xuICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc0luZGV4ID0gaXRlbS5heGlzSW5kZXg7XG4gICAgICAgICAgZGF0YVBhcmFtcy5heGlzVHlwZSA9IGl0ZW0uYXhpc1R5cGU7XG4gICAgICAgICAgZGF0YVBhcmFtcy5heGlzSWQgPSBpdGVtLmF4aXNJZDtcbiAgICAgICAgICBkYXRhUGFyYW1zLmF4aXNWYWx1ZSA9IGF4aXNIZWxwZXIuZ2V0QXhpc1Jhd1ZhbHVlKGF4aXNNb2RlbC5heGlzLCBheGlzVmFsdWUpO1xuICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc1ZhbHVlTGFiZWwgPSB2YWx1ZUxhYmVsO1xuXG4gICAgICAgICAgaWYgKGRhdGFQYXJhbXMpIHtcbiAgICAgICAgICAgIHNpbmdsZVBhcmFtc0xpc3QucHVzaChkYXRhUGFyYW1zKTtcbiAgICAgICAgICAgIHNlcmllc0RlZmF1bHRIVE1MLnB1c2goc2VyaWVzLmZvcm1hdFRvb2x0aXAoZGF0YUluZGV4LCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gRGVmYXVsdCB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gKDEpIHNob2xkIGJlIHRoZSBmaXJzdCBkYXRhIHdoaWNoIGhhcyBuYW1lP1xuICAgICAgICAvLyAoMikgdGhlbWVSaXZlciwgZmlyc3REYXRhSW5kZXggaXMgYXJyYXksIGFuZCBmaXJzdCBsaW5lIGlzIHVubmVjZXNzYXJ5LlxuXG4gICAgICAgIHZhciBmaXJzdExpbmUgPSB2YWx1ZUxhYmVsO1xuICAgICAgICBzaW5nbGVEZWZhdWx0SFRNTC5wdXNoKChmaXJzdExpbmUgPyBmb3JtYXRVdGlsLmVuY29kZUhUTUwoZmlyc3RMaW5lKSArICc8YnIgLz4nIDogJycpICsgc2VyaWVzRGVmYXVsdEhUTUwuam9pbignPGJyIC8+JykpO1xuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7IC8vIEluIG1vc3QgY2FzZSwgdGhlIHNlY29uZCBheGlzIGlzIHNob3duIHVwcGVyIHRoYW4gdGhlIGZpcnN0IG9uZS5cblxuICAgIHNpbmdsZURlZmF1bHRIVE1MLnJldmVyc2UoKTtcbiAgICBzaW5nbGVEZWZhdWx0SFRNTCA9IHNpbmdsZURlZmF1bHRIVE1MLmpvaW4oJzxiciAvPjxiciAvPicpO1xuICAgIHZhciBwb3NpdGlvbkV4cHIgPSBlLnBvc2l0aW9uO1xuXG4gICAgdGhpcy5fc2hvd09yTW92ZShzaW5nbGVUb29sdGlwTW9kZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl91cGRhdGVDb250ZW50Tm90Q2hhbmdlZE9uQXhpcyhkYXRhQnlDb29yZFN5cykpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oc2luZ2xlVG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHBvaW50WzBdLCBwb2ludFsxXSwgdGhpcy5fdG9vbHRpcENvbnRlbnQsIHNpbmdsZVBhcmFtc0xpc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KHNpbmdsZVRvb2x0aXBNb2RlbCwgc2luZ2xlRGVmYXVsdEhUTUwsIHNpbmdsZVBhcmFtc0xpc3QsIE1hdGgucmFuZG9tKCksIHBvaW50WzBdLCBwb2ludFsxXSwgcG9zaXRpb25FeHByKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gRG8gbm90IHRyaWdnZXIgZXZlbnRzIGhlcmUsIGJlY2F1c2UgdGhpcyBicmFuY2ggb25seSBiZSBlbnRlcmVkXG4gICAgLy8gZnJvbSBkaXNwYXRjaEFjdGlvbi5cblxuICB9LFxuICBfc2hvd1Nlcmllc0l0ZW1Ub29sdGlwOiBmdW5jdGlvbiAoZSwgZWwsIGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9lY01vZGVsOyAvLyBVc2UgZGF0YU1vZGVsIGluIGVsZW1lbnQgaWYgcG9zc2libGVcbiAgICAvLyBVc2VkIHdoZW4gbW91c2VvdmVyIG9uIGEgZWxlbWVudCBsaWtlIG1hcmtQb2ludCBvciBlZGdlXG4gICAgLy8gSW4gd2hpY2ggY2FzZSwgdGhlIGRhdGEgaXMgbm90IG1haW4gZGF0YSBpbiBzZXJpZXMuXG5cbiAgICB2YXIgc2VyaWVzSW5kZXggPSBlbC5zZXJpZXNJbmRleDtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoc2VyaWVzSW5kZXgpOyAvLyBGb3IgZXhhbXBsZSwgZ3JhcGggbGluay5cblxuICAgIHZhciBkYXRhTW9kZWwgPSBlbC5kYXRhTW9kZWwgfHwgc2VyaWVzTW9kZWw7XG4gICAgdmFyIGRhdGFJbmRleCA9IGVsLmRhdGFJbmRleDtcbiAgICB2YXIgZGF0YVR5cGUgPSBlbC5kYXRhVHlwZTtcbiAgICB2YXIgZGF0YSA9IGRhdGFNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpLCBkYXRhTW9kZWwsIHNlcmllc01vZGVsICYmIChzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtIHx8IHt9KS5tb2RlbCwgdGhpcy5fdG9vbHRpcE1vZGVsXSk7XG4gICAgdmFyIHRvb2x0aXBUcmlnZ2VyID0gdG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlcicpO1xuXG4gICAgaWYgKHRvb2x0aXBUcmlnZ2VyICE9IG51bGwgJiYgdG9vbHRpcFRyaWdnZXIgIT09ICdpdGVtJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSBkYXRhTW9kZWwuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgsIGRhdGFUeXBlKTtcbiAgICB2YXIgZGVmYXVsdEh0bWwgPSBkYXRhTW9kZWwuZm9ybWF0VG9vbHRpcChkYXRhSW5kZXgsIGZhbHNlLCBkYXRhVHlwZSk7XG4gICAgdmFyIGFzeW5jVGlja2V0ID0gJ2l0ZW1fJyArIGRhdGFNb2RlbC5uYW1lICsgJ18nICsgZGF0YUluZGV4O1xuXG4gICAgdGhpcy5fc2hvd09yTW92ZSh0b29sdGlwTW9kZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudCh0b29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBwYXJhbXMsIGFzeW5jVGlja2V0LCBlLm9mZnNldFgsIGUub2Zmc2V0WSwgZS5wb3NpdGlvbiwgZS50YXJnZXQpO1xuICAgIH0pOyAvLyBGSVhNRVxuICAgIC8vIGR1cGxpY2F0ZWQgc2hvd3RpcCBpZiBtYW51YWxseVNob3dUaXAgaXMgY2FsbGVkIGZyb20gZGlzcGF0Y2hBY3Rpb24uXG5cblxuICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICAgIGRhdGFJbmRleEluc2lkZTogZGF0YUluZGV4LFxuICAgICAgZGF0YUluZGV4OiBkYXRhLmdldFJhd0luZGV4KGRhdGFJbmRleCksXG4gICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICBmcm9tOiB0aGlzLnVpZFxuICAgIH0pO1xuICB9LFxuICBfc2hvd0NvbXBvbmVudEl0ZW1Ub29sdGlwOiBmdW5jdGlvbiAoZSwgZWwsIGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgdmFyIHRvb2x0aXBPcHQgPSBlbC50b29sdGlwO1xuXG4gICAgaWYgKHR5cGVvZiB0b29sdGlwT3B0ID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGNvbnRlbnQgPSB0b29sdGlwT3B0O1xuICAgICAgdG9vbHRpcE9wdCA9IHtcbiAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgLy8gRml4ZWQgZm9ybWF0dGVyXG4gICAgICAgIGZvcm1hdHRlcjogY29udGVudFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc3ViVG9vbHRpcE1vZGVsID0gbmV3IE1vZGVsKHRvb2x0aXBPcHQsIHRoaXMuX3Rvb2x0aXBNb2RlbCwgdGhpcy5fZWNNb2RlbCk7XG4gICAgdmFyIGRlZmF1bHRIdG1sID0gc3ViVG9vbHRpcE1vZGVsLmdldCgnY29udGVudCcpO1xuICAgIHZhciBhc3luY1RpY2tldCA9IE1hdGgucmFuZG9tKCk7IC8vIERvIG5vdCBjaGVjayB3aGV0aGVyIGB0cmlnZ2VyYCBpcyAnbm9uZScgaGVyZSwgYmVjYXVzZSBgdHJpZ2dlcmBcbiAgICAvLyBvbmx5IHdvcmtzIG9uIGNvb3JpZGluYXRlIHN5c3RlbS4gSW4gZmFjdCwgd2UgaGF2ZSBub3QgZm91bmQgY2FzZVxuICAgIC8vIHRoYXQgcmVxdWlyZXMgc2V0dGluZyBgdHJpZ2dlcmAgbm90aGluZyBvbiBjb21wb25lbnQgeWV0LlxuXG4gICAgdGhpcy5fc2hvd09yTW92ZShzdWJUb29sdGlwTW9kZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudChzdWJUb29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBzdWJUb29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXJQYXJhbXMnKSB8fCB7fSwgYXN5bmNUaWNrZXQsIGUub2Zmc2V0WCwgZS5vZmZzZXRZLCBlLnBvc2l0aW9uLCBlbCk7XG4gICAgfSk7IC8vIElmIG5vdCBkaXNwYXRjaCBzaG93VGlwLCB0aXAgbWF5IGJlIGhpZGUgdHJpZ2dlcmVkIGJ5IGF4aXMuXG5cblxuICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICAgIGZyb206IHRoaXMudWlkXG4gICAgfSk7XG4gIH0sXG4gIF9zaG93VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBwYXJhbXMsIGFzeW5jVGlja2V0LCB4LCB5LCBwb3NpdGlvbkV4cHIsIGVsKSB7XG4gICAgLy8gUmVzZXQgdGlja2V0XG4gICAgdGhpcy5fdGlja2V0ID0gJyc7XG5cbiAgICBpZiAoIXRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dDb250ZW50JykgfHwgIXRvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xuICAgIHZhciBmb3JtYXR0ZXIgPSB0b29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKTtcbiAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIgfHwgdG9vbHRpcE1vZGVsLmdldCgncG9zaXRpb24nKTtcbiAgICB2YXIgaHRtbCA9IGRlZmF1bHRIdG1sO1xuXG4gICAgaWYgKGZvcm1hdHRlciAmJiB0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgaHRtbCA9IGZvcm1hdFV0aWwuZm9ybWF0VHBsKGZvcm1hdHRlciwgcGFyYW1zLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGJpbmQoZnVuY3Rpb24gKGNiVGlja2V0LCBodG1sKSB7XG4gICAgICAgIGlmIChjYlRpY2tldCA9PT0gdGhpcy5fdGlja2V0KSB7XG4gICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2V0Q29udGVudChodG1sKTtcblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHRvb2x0aXBNb2RlbCwgcG9zaXRpb25FeHByLCB4LCB5LCB0b29sdGlwQ29udGVudCwgcGFyYW1zLCBlbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5fdGlja2V0ID0gYXN5bmNUaWNrZXQ7XG4gICAgICBodG1sID0gZm9ybWF0dGVyKHBhcmFtcywgYXN5bmNUaWNrZXQsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICB0b29sdGlwQ29udGVudC5zZXRDb250ZW50KGh0bWwpO1xuICAgIHRvb2x0aXBDb250ZW50LnNob3codG9vbHRpcE1vZGVsKTtcblxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHRvb2x0aXBNb2RlbCwgcG9zaXRpb25FeHByLCB4LCB5LCB0b29sdGlwQ29udGVudCwgcGFyYW1zLCBlbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbnxBcnJheS48bnVtYmVyPnxPYmplY3R9IHBvc2l0aW9uRXhwclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggTW91c2UgeFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgTW91c2UgeVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBjb25maW5lIFdoZXRoZXIgY29uZmluZSB0b29sdGlwIGNvbnRlbnQgaW4gdmlldyByZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R8PEFycmF5LjxPYmplY3Q+fSBwYXJhbXNcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgY29udGVudCwgcGFyYW1zLCBlbCkge1xuICAgIHZhciB2aWV3V2lkdGggPSB0aGlzLl9hcGkuZ2V0V2lkdGgoKTtcblxuICAgIHZhciB2aWV3SGVpZ2h0ID0gdGhpcy5fYXBpLmdldEhlaWdodCgpO1xuXG4gICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByIHx8IHRvb2x0aXBNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgdmFyIGNvbnRlbnRTaXplID0gY29udGVudC5nZXRTaXplKCk7XG4gICAgdmFyIGFsaWduID0gdG9vbHRpcE1vZGVsLmdldCgnYWxpZ24nKTtcbiAgICB2YXIgdkFsaWduID0gdG9vbHRpcE1vZGVsLmdldCgndmVydGljYWxBbGlnbicpO1xuICAgIHZhciByZWN0ID0gZWwgJiYgZWwuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICBlbCAmJiByZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG5cbiAgICBpZiAodHlwZW9mIHBvc2l0aW9uRXhwciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQ2FsbGJhY2sgb2YgcG9zaXRpb24gY2FuIGJlIGFuIGFycmF5IG9yIGEgc3RyaW5nIHNwZWNpZnkgdGhlIHBvc2l0aW9uXG4gICAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIoW3gsIHldLCBwYXJhbXMsIGNvbnRlbnQuZWwsIHJlY3QsIHtcbiAgICAgICAgdmlld1NpemU6IFt2aWV3V2lkdGgsIHZpZXdIZWlnaHRdLFxuICAgICAgICBjb250ZW50U2l6ZTogY29udGVudFNpemUuc2xpY2UoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHpyVXRpbC5pc0FycmF5KHBvc2l0aW9uRXhwcikpIHtcbiAgICAgIHggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzBdLCB2aWV3V2lkdGgpO1xuICAgICAgeSA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkV4cHJbMV0sIHZpZXdIZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzT2JqZWN0KHBvc2l0aW9uRXhwcikpIHtcbiAgICAgIHBvc2l0aW9uRXhwci53aWR0aCA9IGNvbnRlbnRTaXplWzBdO1xuICAgICAgcG9zaXRpb25FeHByLmhlaWdodCA9IGNvbnRlbnRTaXplWzFdO1xuICAgICAgdmFyIGxheW91dFJlY3QgPSBsYXlvdXRVdGlsLmdldExheW91dFJlY3QocG9zaXRpb25FeHByLCB7XG4gICAgICAgIHdpZHRoOiB2aWV3V2lkdGgsXG4gICAgICAgIGhlaWdodDogdmlld0hlaWdodFxuICAgICAgfSk7XG4gICAgICB4ID0gbGF5b3V0UmVjdC54O1xuICAgICAgeSA9IGxheW91dFJlY3QueTtcbiAgICAgIGFsaWduID0gbnVsbDsgLy8gV2hlbiBwb3NpdGlvbkV4cHIgaXMgbGVmdC90b3AvcmlnaHQvYm90dG9tLFxuICAgICAgLy8gYWxpZ24gYW5kIHZlcnRpY2FsQWxpZ24gd2lsbCBub3Qgd29yay5cblxuICAgICAgdkFsaWduID0gbnVsbDtcbiAgICB9IC8vIFNwZWNpZnkgdG9vbHRpcCBwb3NpdGlvbiBieSBzdHJpbmcgJ3RvcCcgJ2JvdHRvbScgJ2xlZnQnICdyaWdodCcgYXJvdW5kIGdyYXBoaWMgZWxlbWVudFxuICAgIGVsc2UgaWYgKHR5cGVvZiBwb3NpdGlvbkV4cHIgPT09ICdzdHJpbmcnICYmIGVsKSB7XG4gICAgICAgIHZhciBwb3MgPSBjYWxjVG9vbHRpcFBvc2l0aW9uKHBvc2l0aW9uRXhwciwgcmVjdCwgY29udGVudFNpemUpO1xuICAgICAgICB4ID0gcG9zWzBdO1xuICAgICAgICB5ID0gcG9zWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBvcyA9IHJlZml4VG9vbHRpcFBvc2l0aW9uKHgsIHksIGNvbnRlbnQuZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgYWxpZ24gPyBudWxsIDogMjAsIHZBbGlnbiA/IG51bGwgOiAyMCk7XG4gICAgICAgIHggPSBwb3NbMF07XG4gICAgICAgIHkgPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICBhbGlnbiAmJiAoeCAtPSBpc0NlbnRlckFsaWduKGFsaWduKSA/IGNvbnRlbnRTaXplWzBdIC8gMiA6IGFsaWduID09PSAncmlnaHQnID8gY29udGVudFNpemVbMF0gOiAwKTtcbiAgICB2QWxpZ24gJiYgKHkgLT0gaXNDZW50ZXJBbGlnbih2QWxpZ24pID8gY29udGVudFNpemVbMV0gLyAyIDogdkFsaWduID09PSAnYm90dG9tJyA/IGNvbnRlbnRTaXplWzFdIDogMCk7XG5cbiAgICBpZiAodG9vbHRpcE1vZGVsLmdldCgnY29uZmluZScpKSB7XG4gICAgICB2YXIgcG9zID0gY29uZmluZVRvb2x0aXBQb3NpdGlvbih4LCB5LCBjb250ZW50LmVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuICAgICAgeCA9IHBvc1swXTtcbiAgICAgIHkgPSBwb3NbMV07XG4gICAgfVxuXG4gICAgY29udGVudC5tb3ZlVG8oeCwgeSk7XG4gIH0sXG4gIC8vIEZJWE1FXG4gIC8vIFNob3VsZCB3ZSByZW1vdmUgdGhpcyBidXQgbGVhdmUgdGhpcyB0byB1c2VyP1xuICBfdXBkYXRlQ29udGVudE5vdENoYW5nZWRPbkF4aXM6IGZ1bmN0aW9uIChkYXRhQnlDb29yZFN5cykge1xuICAgIHZhciBsYXN0Q29vcmRTeXMgPSB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXM7XG4gICAgdmFyIGNvbnRlbnROb3RDaGFuZ2VkID0gISFsYXN0Q29vcmRTeXMgJiYgbGFzdENvb3JkU3lzLmxlbmd0aCA9PT0gZGF0YUJ5Q29vcmRTeXMubGVuZ3RoO1xuICAgIGNvbnRlbnROb3RDaGFuZ2VkICYmIGVhY2gobGFzdENvb3JkU3lzLCBmdW5jdGlvbiAobGFzdEl0ZW1Db29yZFN5cywgaW5kZXhDb29yZFN5cykge1xuICAgICAgdmFyIGxhc3REYXRhQnlBeGlzID0gbGFzdEl0ZW1Db29yZFN5cy5kYXRhQnlBeGlzIHx8IHt9O1xuICAgICAgdmFyIHRoaXNJdGVtQ29vcmRTeXMgPSBkYXRhQnlDb29yZFN5c1tpbmRleENvb3JkU3lzXSB8fCB7fTtcbiAgICAgIHZhciB0aGlzRGF0YUJ5QXhpcyA9IHRoaXNJdGVtQ29vcmRTeXMuZGF0YUJ5QXhpcyB8fCBbXTtcbiAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICY9IGxhc3REYXRhQnlBeGlzLmxlbmd0aCA9PT0gdGhpc0RhdGFCeUF4aXMubGVuZ3RoO1xuICAgICAgY29udGVudE5vdENoYW5nZWQgJiYgZWFjaChsYXN0RGF0YUJ5QXhpcywgZnVuY3Rpb24gKGxhc3RJdGVtLCBpbmRleEF4aXMpIHtcbiAgICAgICAgdmFyIHRoaXNJdGVtID0gdGhpc0RhdGFCeUF4aXNbaW5kZXhBeGlzXSB8fCB7fTtcbiAgICAgICAgdmFyIGxhc3RJbmRpY2VzID0gbGFzdEl0ZW0uc2VyaWVzRGF0YUluZGljZXMgfHwgW107XG4gICAgICAgIHZhciBuZXdJbmRpY2VzID0gdGhpc0l0ZW0uc2VyaWVzRGF0YUluZGljZXMgfHwgW107XG4gICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICY9IGxhc3RJdGVtLnZhbHVlID09PSB0aGlzSXRlbS52YWx1ZSAmJiBsYXN0SXRlbS5heGlzVHlwZSA9PT0gdGhpc0l0ZW0uYXhpc1R5cGUgJiYgbGFzdEl0ZW0uYXhpc0lkID09PSB0aGlzSXRlbS5heGlzSWQgJiYgbGFzdEluZGljZXMubGVuZ3RoID09PSBuZXdJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgY29udGVudE5vdENoYW5nZWQgJiYgZWFjaChsYXN0SW5kaWNlcywgZnVuY3Rpb24gKGxhc3RJZHhJdGVtLCBqKSB7XG4gICAgICAgICAgdmFyIG5ld0lkeEl0ZW0gPSBuZXdJbmRpY2VzW2pdO1xuICAgICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICY9IGxhc3RJZHhJdGVtLnNlcmllc0luZGV4ID09PSBuZXdJZHhJdGVtLnNlcmllc0luZGV4ICYmIGxhc3RJZHhJdGVtLmRhdGFJbmRleCA9PT0gbmV3SWR4SXRlbS5kYXRhSW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gZGF0YUJ5Q29vcmRTeXM7XG4gICAgcmV0dXJuICEhY29udGVudE5vdENoYW5nZWQ7XG4gIH0sXG4gIF9oaWRlOiBmdW5jdGlvbiAoZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAvLyBEbyBub3QgZGlyZWN0bHkgaGlkZUxhdGVyIGhlcmUsIGJlY2F1c2UgdGhpcyBiZWhhdmlvciBtYXkgYmUgcHJldmVudGVkXG4gICAgLy8gaW4gZGlzcGF0Y2hBY3Rpb24gd2hlbiBzaG93VGlwIGlzIGRpc3BhdGNoZWQuXG4gICAgLy8gRklYTUVcbiAgICAvLyBkdXBsaWNhdGVkIGhpZGVUaXAgaWYgbWFudWFsbHlIaWRlVGlwIGlzIGNhbGxlZCBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG4gICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2hpZGVUaXAnLFxuICAgICAgZnJvbTogdGhpcy51aWRcbiAgICB9KTtcbiAgfSxcbiAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3Rvb2x0aXBDb250ZW50LmhpZGUoKTtcblxuICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIoJ2l0ZW1Ub29sdGlwJywgYXBpKTtcbiAgfVxufSk7XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdHxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD59IG1vZGVsQ2FzY2FkZVxuICogRnJvbSB0b3AgdG8gYm90dG9tLiAodGhlIGxhc3Qgb25lIHNob3VsZCBiZSBnbG9iYWxUb29sdGlwTW9kZWwpO1xuICovXG5cblxuZnVuY3Rpb24gYnVpbGRUb29sdGlwTW9kZWwobW9kZWxDYXNjYWRlKSB7XG4gIHZhciByZXN1bHRNb2RlbCA9IG1vZGVsQ2FzY2FkZS5wb3AoKTtcblxuICB3aGlsZSAobW9kZWxDYXNjYWRlLmxlbmd0aCkge1xuICAgIHZhciB0b29sdGlwT3B0ID0gbW9kZWxDYXNjYWRlLnBvcCgpO1xuXG4gICAgaWYgKHRvb2x0aXBPcHQpIHtcbiAgICAgIGlmICh0b29sdGlwT3B0IGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgdG9vbHRpcE9wdCA9IHRvb2x0aXBPcHQuZ2V0KCd0b29sdGlwJywgdHJ1ZSk7XG4gICAgICB9IC8vIEluIGVhY2ggZGF0YSBpdGVtIHRvb2x0aXAgY2FuIGJlIHNpbXBseSB3cml0ZTpcbiAgICAgIC8vIHtcbiAgICAgIC8vICB2YWx1ZTogMTAsXG4gICAgICAvLyAgdG9vbHRpcDogJ1NvbWV0aGluZyB5b3UgbmVlZCB0byBrbm93J1xuICAgICAgLy8gfVxuXG5cbiAgICAgIGlmICh0eXBlb2YgdG9vbHRpcE9wdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9vbHRpcE9wdCA9IHtcbiAgICAgICAgICBmb3JtYXR0ZXI6IHRvb2x0aXBPcHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0TW9kZWwgPSBuZXcgTW9kZWwodG9vbHRpcE9wdCwgcmVzdWx0TW9kZWwsIHJlc3VsdE1vZGVsLmVjTW9kZWwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRNb2RlbDtcbn1cblxuZnVuY3Rpb24gbWFrZURpc3BhdGNoQWN0aW9uKHBheWxvYWQsIGFwaSkge1xuICByZXR1cm4gcGF5bG9hZC5kaXNwYXRjaEFjdGlvbiB8fCB6clV0aWwuYmluZChhcGkuZGlzcGF0Y2hBY3Rpb24sIGFwaSk7XG59XG5cbmZ1bmN0aW9uIHJlZml4VG9vbHRpcFBvc2l0aW9uKHgsIHksIGVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIGdhcEgsIGdhcFYpIHtcbiAgdmFyIHNpemUgPSBnZXRPdXRlclNpemUoZWwpO1xuICB2YXIgd2lkdGggPSBzaXplLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cbiAgaWYgKGdhcEggIT0gbnVsbCkge1xuICAgIGlmICh4ICsgd2lkdGggKyBnYXBIID4gdmlld1dpZHRoKSB7XG4gICAgICB4IC09IHdpZHRoICsgZ2FwSDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSBnYXBIO1xuICAgIH1cbiAgfVxuXG4gIGlmIChnYXBWICE9IG51bGwpIHtcbiAgICBpZiAoeSArIGhlaWdodCArIGdhcFYgPiB2aWV3SGVpZ2h0KSB7XG4gICAgICB5IC09IGhlaWdodCArIGdhcFY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgKz0gZ2FwVjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3gsIHldO1xufVxuXG5mdW5jdGlvbiBjb25maW5lVG9vbHRpcFBvc2l0aW9uKHgsIHksIGVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpIHtcbiAgdmFyIHNpemUgPSBnZXRPdXRlclNpemUoZWwpO1xuICB2YXIgd2lkdGggPSBzaXplLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gIHggPSBNYXRoLm1pbih4ICsgd2lkdGgsIHZpZXdXaWR0aCkgLSB3aWR0aDtcbiAgeSA9IE1hdGgubWluKHkgKyBoZWlnaHQsIHZpZXdIZWlnaHQpIC0gaGVpZ2h0O1xuICB4ID0gTWF0aC5tYXgoeCwgMCk7XG4gIHkgPSBNYXRoLm1heCh5LCAwKTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplKGVsKSB7XG4gIHZhciB3aWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0OyAvLyBDb25zaWRlciBicm93c2VyIGNvbXBhdGliaWxpdHkuXG4gIC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUuXG5cbiAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICB2YXIgc3RsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgICBpZiAoc3RsKSB7XG4gICAgICB3aWR0aCArPSBwYXJzZUludChzdGwucGFkZGluZ0xlZnQsIDEwKSArIHBhcnNlSW50KHN0bC5wYWRkaW5nUmlnaHQsIDEwKSArIHBhcnNlSW50KHN0bC5ib3JkZXJMZWZ0V2lkdGgsIDEwKSArIHBhcnNlSW50KHN0bC5ib3JkZXJSaWdodFdpZHRoLCAxMCk7XG4gICAgICBoZWlnaHQgKz0gcGFyc2VJbnQoc3RsLnBhZGRpbmdUb3AsIDEwKSArIHBhcnNlSW50KHN0bC5wYWRkaW5nQm90dG9tLCAxMCkgKyBwYXJzZUludChzdGwuYm9yZGVyVG9wV2lkdGgsIDEwKSArIHBhcnNlSW50KHN0bC5ib3JkZXJCb3R0b21XaWR0aCwgMTApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGNUb29sdGlwUG9zaXRpb24ocG9zaXRpb24sIHJlY3QsIGNvbnRlbnRTaXplKSB7XG4gIHZhciBkb21XaWR0aCA9IGNvbnRlbnRTaXplWzBdO1xuICB2YXIgZG9tSGVpZ2h0ID0gY29udGVudFNpemVbMV07XG4gIHZhciBnYXAgPSA1O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG5cbiAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgIHkgPSByZWN0LnkgLSBkb21IZWlnaHQgLSBnYXA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0ICsgZ2FwO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHggPSByZWN0LnggLSBkb21XaWR0aCAtIGdhcDtcbiAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggKyBnYXA7XG4gICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xuICB9XG5cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuZnVuY3Rpb24gaXNDZW50ZXJBbGlnbihhbGlnbikge1xuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInIHx8IGFsaWduID09PSAnbWlkZGxlJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciB6ckNvbG9yID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3Rvb2wvY29sb3JcIik7XG5cbnZhciBldmVudFV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9ldmVudFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2VudlwiKTtcblxudmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgdG9DYW1lbENhc2UgPSBmb3JtYXRVdGlsLnRvQ2FtZWxDYXNlO1xudmFyIHZlbmRvcnMgPSBbJycsICctd2Via2l0LScsICctbW96LScsICctby0nXTtcbnZhciBnQ3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO2JvcmRlci1zdHlsZTpzb2xpZDt3aGl0ZS1zcGFjZTpub3dyYXA7ei1pbmRleDo5OTk5OTk5Oyc7XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfVxuICogQGlubmVyXG4gKi9cblxuZnVuY3Rpb24gYXNzZW1ibGVUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gIHZhciB0cmFuc2l0aW9uQ3VydmUgPSAnY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpJztcbiAgdmFyIHRyYW5zaXRpb25UZXh0ID0gJ2xlZnQgJyArIGR1cmF0aW9uICsgJ3MgJyArIHRyYW5zaXRpb25DdXJ2ZSArICcsJyArICd0b3AgJyArIGR1cmF0aW9uICsgJ3MgJyArIHRyYW5zaXRpb25DdXJ2ZTtcbiAgcmV0dXJuIHpyVXRpbC5tYXAodmVuZG9ycywgZnVuY3Rpb24gKHZlbmRvclByZWZpeCkge1xuICAgIHJldHVybiB2ZW5kb3JQcmVmaXggKyAndHJhbnNpdGlvbjonICsgdHJhbnNpdGlvblRleHQ7XG4gIH0pLmpvaW4oJzsnKTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxuICogQHJldHVybiB7c3RyaW5nfVxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlbWJsZUZvbnQodGV4dFN0eWxlTW9kZWwpIHtcbiAgdmFyIGNzc1RleHQgPSBbXTtcbiAgdmFyIGZvbnRTaXplID0gdGV4dFN0eWxlTW9kZWwuZ2V0KCdmb250U2l6ZScpO1xuICB2YXIgY29sb3IgPSB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKTtcbiAgY29sb3IgJiYgY3NzVGV4dC5wdXNoKCdjb2xvcjonICsgY29sb3IpO1xuICBjc3NUZXh0LnB1c2goJ2ZvbnQ6JyArIHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSk7XG4gIGZvbnRTaXplICYmIGNzc1RleHQucHVzaCgnbGluZS1oZWlnaHQ6JyArIE1hdGgucm91bmQoZm9udFNpemUgKiAzIC8gMikgKyAncHgnKTtcbiAgZWFjaChbJ2RlY29yYXRpb24nLCAnYWxpZ24nXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsID0gdGV4dFN0eWxlTW9kZWwuZ2V0KG5hbWUpO1xuICAgIHZhbCAmJiBjc3NUZXh0LnB1c2goJ3RleHQtJyArIG5hbWUgKyAnOicgKyB2YWwpO1xuICB9KTtcbiAgcmV0dXJuIGNzc1RleHQuam9pbignOycpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9vbHRpcE1vZGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VtYmxlQ3NzVGV4dCh0b29sdGlwTW9kZWwpIHtcbiAgdmFyIGNzc1RleHQgPSBbXTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyYW5zaXRpb25EdXJhdGlvbicpO1xuICB2YXIgYmFja2dyb3VuZENvbG9yID0gdG9vbHRpcE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gIHZhciB0ZXh0U3R5bGVNb2RlbCA9IHRvb2x0aXBNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gIHZhciBwYWRkaW5nID0gdG9vbHRpcE1vZGVsLmdldCgncGFkZGluZycpOyAvLyBBbmltYXRpb24gdHJhbnNpdGlvbi4gRG8gbm90IGFuaW1hdGUgd2hlbiB0cmFuc2l0aW9uRHVyYXRpb24gaXMgMC5cblxuICB0cmFuc2l0aW9uRHVyYXRpb24gJiYgY3NzVGV4dC5wdXNoKGFzc2VtYmxlVHJhbnNpdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pKTtcblxuICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgaWYgKGVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICAgIGNzc1RleHQucHVzaCgnYmFja2dyb3VuZC1Db2xvcjonICsgYmFja2dyb3VuZENvbG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGllXG4gICAgICBjc3NUZXh0LnB1c2goJ2JhY2tncm91bmQtQ29sb3I6IycgKyB6ckNvbG9yLnRvSGV4KGJhY2tncm91bmRDb2xvcikpO1xuICAgICAgY3NzVGV4dC5wdXNoKCdmaWx0ZXI6YWxwaGEob3BhY2l0eT03MCknKTtcbiAgICB9XG4gIH0gLy8gQm9yZGVyIHN0eWxlXG5cblxuICBlYWNoKFsnd2lkdGgnLCAnY29sb3InLCAncmFkaXVzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGJvcmRlck5hbWUgPSAnYm9yZGVyLScgKyBuYW1lO1xuICAgIHZhciBjYW1lbENhc2UgPSB0b0NhbWVsQ2FzZShib3JkZXJOYW1lKTtcbiAgICB2YXIgdmFsID0gdG9vbHRpcE1vZGVsLmdldChjYW1lbENhc2UpO1xuICAgIHZhbCAhPSBudWxsICYmIGNzc1RleHQucHVzaChib3JkZXJOYW1lICsgJzonICsgdmFsICsgKG5hbWUgPT09ICdjb2xvcicgPyAnJyA6ICdweCcpKTtcbiAgfSk7IC8vIFRleHQgc3R5bGVcblxuICBjc3NUZXh0LnB1c2goYXNzZW1ibGVGb250KHRleHRTdHlsZU1vZGVsKSk7IC8vIFBhZGRpbmdcblxuICBpZiAocGFkZGluZyAhPSBudWxsKSB7XG4gICAgY3NzVGV4dC5wdXNoKCdwYWRkaW5nOicgKyBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KHBhZGRpbmcpLmpvaW4oJ3B4ICcpICsgJ3B4Jyk7XG4gIH1cblxuICByZXR1cm4gY3NzVGV4dC5qb2luKCc7JykgKyAnOyc7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG5mdW5jdGlvbiBUb29sdGlwQ29udGVudChjb250YWluZXIsIGFwaSkge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHpyID0gdGhpcy5fenIgPSBhcGkuZ2V0WnIoKTtcbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLl94ID0gYXBpLmdldFdpZHRoKCkgLyAyO1xuICB0aGlzLl95ID0gYXBpLmdldEhlaWdodCgpIC8gMjtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9oaWRlVGltZW91dDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGVsLm9ubW91c2VlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjbGVhciB0aGUgdGltZW91dCBpbiBoaWRlTGF0ZXIgYW5kIGtlZXAgc2hvd2luZyB0b29sdGlwXG4gICAgaWYgKHNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX2hpZGVUaW1lb3V0KTtcbiAgICAgIHNlbGYuX3Nob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIHNlbGYuX2luQ29udGVudCA9IHRydWU7XG4gIH07XG5cbiAgZWwub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgIGlmICghc2VsZi5fZW50ZXJhYmxlKSB7XG4gICAgICAvLyBUcnkgdHJpZ2dlciB6cmVuZGVyIGV2ZW50IHRvIGF2b2lkIG1vdXNlXG4gICAgICAvLyBpbiBhbmQgb3V0IHNoYXBlIHRvbyBmcmVxdWVudGx5XG4gICAgICB2YXIgaGFuZGxlciA9IHpyLmhhbmRsZXI7XG4gICAgICBldmVudFV0aWwubm9ybWFsaXplRXZlbnQoY29udGFpbmVyLCBlLCB0cnVlKTtcbiAgICAgIGhhbmRsZXIuZGlzcGF0Y2goJ21vdXNlbW92ZScsIGUpO1xuICAgIH1cbiAgfTtcblxuICBlbC5vbm1vdXNlbGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgaWYgKHNlbGYuX3Nob3cpIHtcbiAgICAgICAgc2VsZi5oaWRlTGF0ZXIoc2VsZi5faGlkZURlbGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLl9pbkNvbnRlbnQgPSBmYWxzZTtcbiAgfTtcbn1cblxuVG9vbHRpcENvbnRlbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVG9vbHRpcENvbnRlbnQsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgX2VudGVyYWJsZTogdHJ1ZSxcblxuICAvKipcbiAgICogVXBkYXRlIHdoZW4gdG9vbHRpcCBpcyByZW5kZXJlZFxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRklYTUVcbiAgICAvLyBNb3ZlIHRoaXMgbG9naWMgdG8gZWMgbWFpbj9cbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgIHZhciBzdGwgPSBjb250YWluZXIuY3VycmVudFN0eWxlIHx8IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICB2YXIgZG9tU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XG5cbiAgICBpZiAoZG9tU3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgc3RsLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICBkb21TdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfSAvLyBIaWRlIHRoZSB0b29sdGlwXG4gICAgLy8gUEVORElOR1xuICAgIC8vIHRoaXMuaGlkZSgpO1xuXG4gIH0sXG4gIHNob3c6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVvdXQpO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgZWwuc3R5bGUuY3NzVGV4dCA9IGdDc3NUZXh0ICsgYXNzZW1ibGVDc3NUZXh0KHRvb2x0aXBNb2RlbCkgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTEyNTU4Ny9jc3MzLXRyYW5zaXRpb24tbm90LXdvcmtpbmctaW4tY2hyb21lLWFueW1vcmVcbiAgICArICc7bGVmdDonICsgdGhpcy5feCArICdweDt0b3A6JyArIHRoaXMuX3kgKyAncHg7JyArICh0b29sdGlwTW9kZWwuZ2V0KCdleHRyYUNzc1RleHQnKSB8fCAnJyk7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLmlubmVySFRNTCA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgdGhpcy5fc2hvdyA9IHRydWU7XG4gIH0sXG4gIHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgdGhpcy5lbC5pbm5lckhUTUwgPSBjb250ZW50ID09IG51bGwgPyAnJyA6IGNvbnRlbnQ7XG4gIH0sXG4gIHNldEVudGVyYWJsZTogZnVuY3Rpb24gKGVudGVyYWJsZSkge1xuICAgIHRoaXMuX2VudGVyYWJsZSA9IGVudGVyYWJsZTtcbiAgfSxcbiAgZ2V0U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgcmV0dXJuIFtlbC5jbGllbnRXaWR0aCwgZWwuY2xpZW50SGVpZ2h0XTtcbiAgfSxcbiAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIC8vIHh5IHNob3VsZCBiZSBiYXNlZCBvbiBjYW52YXMgcm9vdC4gQnV0IHRvb2x0aXBDb250ZW50IGlzXG4gICAgLy8gdGhlIHNpYmxpbmcgb2YgY2FudmFzIHJvb3QuIFNvIHBhZGRpbmcgb2YgZWMgY29udGFpbmVyXG4gICAgLy8gc2hvdWxkIGJlIGNvbnNpZGVyZWQgaGVyZS5cbiAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICB2YXIgdmlld3BvcnRSb290T2Zmc2V0O1xuXG4gICAgaWYgKHpyICYmIHpyLnBhaW50ZXIgJiYgKHZpZXdwb3J0Um9vdE9mZnNldCA9IHpyLnBhaW50ZXIuZ2V0Vmlld3BvcnRSb290T2Zmc2V0KCkpKSB7XG4gICAgICB4ICs9IHZpZXdwb3J0Um9vdE9mZnNldC5vZmZzZXRMZWZ0O1xuICAgICAgeSArPSB2aWV3cG9ydFJvb3RPZmZzZXQub2Zmc2V0VG9wO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7XG4gICAgc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgIHN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcbiAgfSxcbiAgaGlkZUxhdGVyOiBmdW5jdGlvbiAodGltZSkge1xuICAgIGlmICh0aGlzLl9zaG93ICYmICEodGhpcy5faW5Db250ZW50ICYmIHRoaXMuX2VudGVyYWJsZSkpIHtcbiAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgIHRoaXMuX2hpZGVEZWxheSA9IHRpbWU7IC8vIFNldCBzaG93IGZhbHNlIHRvIGF2b2lkIGludm9rZSBoaWRlTGF0ZXIgbXV0aXBsZSB0aW1lc1xuXG4gICAgICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHpyVXRpbC5iaW5kKHRoaXMuaGlkZSwgdGhpcyksIHRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpc1Nob3c6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hvdztcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFRvb2x0aXBDb250ZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgX2xheW91dCA9IHJlcXVpcmUoXCIuLi91dGlsL2xheW91dFwiKTtcblxudmFyIGdldExheW91dFJlY3QgPSBfbGF5b3V0LmdldExheW91dFJlY3Q7XG4vLyBNb2RlbFxuZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICd0aXRsZScsXG4gIGxheW91dE1vZGU6IHtcbiAgICB0eXBlOiAnYm94JyxcbiAgICBpZ25vcmVTaXplOiB0cnVlXG4gIH0sXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICAvLyDkuIDnuqflsYLlj6BcbiAgICB6bGV2ZWw6IDAsXG4gICAgLy8g5LqM57qn5bGC5Y+gXG4gICAgejogNixcbiAgICBzaG93OiB0cnVlLFxuICAgIHRleHQ6ICcnLFxuICAgIC8vIOi2hemTvuaOpei3s+i9rFxuICAgIC8vIGxpbms6IG51bGwsXG4gICAgLy8g5LuF5pSv5oyBc2VsZiB8IGJsYW5rXG4gICAgdGFyZ2V0OiAnYmxhbmsnLFxuICAgIHN1YnRleHQ6ICcnLFxuICAgIC8vIOi2hemTvuaOpei3s+i9rFxuICAgIC8vIHN1Ymxpbms6IG51bGwsXG4gICAgLy8g5LuF5pSv5oyBc2VsZiB8IGJsYW5rXG4gICAgc3VidGFyZ2V0OiAnYmxhbmsnLFxuICAgIC8vICdjZW50ZXInIMKmICdsZWZ0JyDCpiAncmlnaHQnXG4gICAgLy8gwqYge251bWJlcn3vvIh45Z2Q5qCH77yM5Y2V5L2NcHjvvIlcbiAgICBsZWZ0OiAwLFxuICAgIC8vICd0b3AnIMKmICdib3R0b20nIMKmICdjZW50ZXInXG4gICAgLy8gwqYge251bWJlcn3vvIh55Z2Q5qCH77yM5Y2V5L2NcHjvvIlcbiAgICB0b3A6IDAsXG4gICAgLy8g5rC05bmz5a+56b2QXG4gICAgLy8gJ2F1dG8nIHwgJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInXG4gICAgLy8g6buY6K6k5qC55o2uIGxlZnQg55qE5L2N572u5Yik5pat5piv5bem5a+56b2Q6L+Y5piv5Y+z5a+56b2QXG4gICAgLy8gdGV4dEFsaWduOiBudWxsXG4gICAgLy9cbiAgICAvLyDlnoLnm7Tlr7npvZBcbiAgICAvLyAnYXV0bycgfCAndG9wJyB8ICdib3R0b20nIHwgJ21pZGRsZSdcbiAgICAvLyDpu5jorqTmoLnmja4gdG9wIOS9jee9ruWIpOaWreaYr+S4iuWvuem9kOi/mOaYr+S4i+Wvuem9kFxuICAgIC8vIHRleHRCYXNlbGluZTogbnVsbFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIC8vIOagh+mimOi+ueahhuminOiJslxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgLy8g5qCH6aKY6L655qGG57q/5a6977yM5Y2V5L2NcHjvvIzpu5jorqTkuLow77yI5peg6L655qGG77yJXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgLy8g5qCH6aKY5YaF6L656Led77yM5Y2V5L2NcHjvvIzpu5jorqTlkITmlrnlkJHlhoXovrnot53kuLo177yMXG4gICAgLy8g5o6l5Y+X5pWw57uE5YiG5Yir6K6+5a6a5LiK5Y+z5LiL5bem6L656Led77yM5ZCMY3NzXG4gICAgcGFkZGluZzogNSxcbiAgICAvLyDkuLvlia/moIfpopjnurXlkJHpl7TpmpTvvIzljZXkvY1weO+8jOm7mOiupOS4ujEw77yMXG4gICAgaXRlbUdhcDogMTAsXG4gICAgdGV4dFN0eWxlOiB7XG4gICAgICBmb250U2l6ZTogMTgsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZGVyJyxcbiAgICAgIGNvbG9yOiAnIzMzMydcbiAgICB9LFxuICAgIHN1YnRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjYWFhJ1xuICAgIH1cbiAgfVxufSk7IC8vIFZpZXdcblxuZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcbiAgdHlwZTogJ3RpdGxlJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiAodGl0bGVNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcblxuICAgIGlmICghdGl0bGVNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdGl0bGVNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgdmFyIHN1YnRleHRTdHlsZU1vZGVsID0gdGl0bGVNb2RlbC5nZXRNb2RlbCgnc3VidGV4dFN0eWxlJyk7XG4gICAgdmFyIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCd0ZXh0QWxpZ24nKTtcbiAgICB2YXIgdGV4dEJhc2VsaW5lID0gdGl0bGVNb2RlbC5nZXQoJ3RleHRCYXNlbGluZScpO1xuICAgIHZhciB0ZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHN0eWxlOiBncmFwaGljLnNldFRleHRTdHlsZSh7fSwgdGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgdGV4dDogdGl0bGVNb2RlbC5nZXQoJ3RleHQnKSxcbiAgICAgICAgdGV4dEZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpXG4gICAgICB9LCB7XG4gICAgICAgIGRpc2FibGVCb3g6IHRydWVcbiAgICAgIH0pLFxuICAgICAgejI6IDEwXG4gICAgfSk7XG4gICAgdmFyIHRleHRSZWN0ID0gdGV4dEVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdWJUZXh0ID0gdGl0bGVNb2RlbC5nZXQoJ3N1YnRleHQnKTtcbiAgICB2YXIgc3ViVGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICBzdHlsZTogZ3JhcGhpYy5zZXRUZXh0U3R5bGUoe30sIHN1YnRleHRTdHlsZU1vZGVsLCB7XG4gICAgICAgIHRleHQ6IHN1YlRleHQsXG4gICAgICAgIHRleHRGaWxsOiBzdWJ0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgeTogdGV4dFJlY3QuaGVpZ2h0ICsgdGl0bGVNb2RlbC5nZXQoJ2l0ZW1HYXAnKSxcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246ICd0b3AnXG4gICAgICB9LCB7XG4gICAgICAgIGRpc2FibGVCb3g6IHRydWVcbiAgICAgIH0pLFxuICAgICAgejI6IDEwXG4gICAgfSk7XG4gICAgdmFyIGxpbmsgPSB0aXRsZU1vZGVsLmdldCgnbGluaycpO1xuICAgIHZhciBzdWJsaW5rID0gdGl0bGVNb2RlbC5nZXQoJ3N1YmxpbmsnKTtcbiAgICB0ZXh0RWwuc2lsZW50ID0gIWxpbms7XG4gICAgc3ViVGV4dEVsLnNpbGVudCA9ICFzdWJsaW5rO1xuXG4gICAgaWYgKGxpbmspIHtcbiAgICAgIHRleHRFbC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5vcGVuKGxpbmssICdfJyArIHRpdGxlTW9kZWwuZ2V0KCd0YXJnZXQnKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc3VibGluaykge1xuICAgICAgc3ViVGV4dEVsLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Lm9wZW4oc3VibGluaywgJ18nICsgdGl0bGVNb2RlbC5nZXQoJ3N1YnRhcmdldCcpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgIHN1YlRleHQgJiYgZ3JvdXAuYWRkKHN1YlRleHRFbCk7IC8vIElmIG5vIHN1YlRleHQsIGJ1dCBhZGQgc3ViVGV4dEVsLCB0aGVyZSB3aWxsIGJlIGFuIGVtcHR5IGxpbmUuXG5cbiAgICB2YXIgZ3JvdXBSZWN0ID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIGxheW91dE9wdGlvbiA9IHRpdGxlTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCk7XG4gICAgbGF5b3V0T3B0aW9uLndpZHRoID0gZ3JvdXBSZWN0LndpZHRoO1xuICAgIGxheW91dE9wdGlvbi5oZWlnaHQgPSBncm91cFJlY3QuaGVpZ2h0O1xuICAgIHZhciBsYXlvdXRSZWN0ID0gZ2V0TGF5b3V0UmVjdChsYXlvdXRPcHRpb24sIHtcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfSwgdGl0bGVNb2RlbC5nZXQoJ3BhZGRpbmcnKSk7IC8vIEFkanVzdCB0ZXh0IGFsaWduIGJhc2VkIG9uIHBvc2l0aW9uXG5cbiAgICBpZiAoIXRleHRBbGlnbikge1xuICAgICAgLy8gQWxpZ24gbGVmdCBpZiB0aXRsZSBpcyBvbiB0aGUgbGVmdC4gY2VudGVyIGFuZCByaWdodCBpcyBzYW1lXG4gICAgICB0ZXh0QWxpZ24gPSB0aXRsZU1vZGVsLmdldCgnbGVmdCcpIHx8IHRpdGxlTW9kZWwuZ2V0KCdyaWdodCcpO1xuXG4gICAgICBpZiAodGV4dEFsaWduID09PSAnbWlkZGxlJykge1xuICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH0gLy8gQWRqdXN0IGxheW91dCBieSB0ZXh0IGFsaWduXG5cblxuICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBsYXlvdXRSZWN0LnggKz0gbGF5b3V0UmVjdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICBsYXlvdXRSZWN0LnggKz0gbGF5b3V0UmVjdC53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0QmFzZWxpbmUpIHtcbiAgICAgIHRleHRCYXNlbGluZSA9IHRpdGxlTW9kZWwuZ2V0KCd0b3AnKSB8fCB0aXRsZU1vZGVsLmdldCgnYm90dG9tJyk7XG5cbiAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEJhc2VsaW5lID09PSAnYm90dG9tJykge1xuICAgICAgICBsYXlvdXRSZWN0LnkgKz0gbGF5b3V0UmVjdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgbGF5b3V0UmVjdC55ICs9IGxheW91dFJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lIHx8ICd0b3AnO1xuICAgIH1cblxuICAgIGdyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgW2xheW91dFJlY3QueCwgbGF5b3V0UmVjdC55XSk7XG4gICAgdmFyIGFsaWduU3R5bGUgPSB7XG4gICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiB0ZXh0QmFzZWxpbmVcbiAgICB9O1xuICAgIHRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTtcbiAgICBzdWJUZXh0RWwuc2V0U3R5bGUoYWxpZ25TdHlsZSk7IC8vIFJlbmRlciBiYWNrZ3JvdW5kXG4gICAgLy8gR2V0IGdyb3VwUmVjdCBhZ2FpbiBiZWNhdXNlIHRleHRBbGlnbiBoYXMgYmVlbiBjaGFuZ2VkXG5cbiAgICBncm91cFJlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgcGFkZGluZyA9IGxheW91dFJlY3QubWFyZ2luO1xuICAgIHZhciBzdHlsZSA9IHRpdGxlTW9kZWwuZ2V0SXRlbVN0eWxlKFsnY29sb3InLCAnb3BhY2l0eSddKTtcbiAgICBzdHlsZS5maWxsID0gdGl0bGVNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiBncm91cFJlY3QueCAtIHBhZGRpbmdbM10sXG4gICAgICAgIHk6IGdyb3VwUmVjdC55IC0gcGFkZGluZ1swXSxcbiAgICAgICAgd2lkdGg6IGdyb3VwUmVjdC53aWR0aCArIHBhZGRpbmdbMV0gKyBwYWRkaW5nWzNdLFxuICAgICAgICBoZWlnaHQ6IGdyb3VwUmVjdC5oZWlnaHQgKyBwYWRkaW5nWzBdICsgcGFkZGluZ1syXSxcbiAgICAgICAgcjogdGl0bGVNb2RlbC5nZXQoJ2JvcmRlclJhZGl1cycpXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSk7XG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdChyZWN0KTtcbiAgICBncm91cC5hZGQocmVjdCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90aXRsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZShcIi4vbGVnZW5kXCIpO1xuXG5yZXF1aXJlKFwiLi9sZWdlbmQvU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9sZWdlbmQvU2Nyb2xsYWJsZUxlZ2VuZFZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL2xlZ2VuZC9zY3JvbGxhYmxlTGVnZW5kQWN0aW9uXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmRTY3JvbGwuanNcbi8vIG1vZHVsZSBpZCA9IDI3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uL2VjaGFydHNcIik7XG5cbnJlcXVpcmUoXCIuL2xlZ2VuZC9MZWdlbmRNb2RlbFwiKTtcblxucmVxdWlyZShcIi4vbGVnZW5kL2xlZ2VuZEFjdGlvblwiKTtcblxucmVxdWlyZShcIi4vbGVnZW5kL0xlZ2VuZFZpZXdcIik7XG5cbnZhciBsZWdlbmRGaWx0ZXIgPSByZXF1aXJlKFwiLi9sZWdlbmQvbGVnZW5kRmlsdGVyXCIpO1xuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIi4uL21vZGVsL0NvbXBvbmVudFwiKTtcblxuLy8gRG8gbm90IGNvbnRhaW4gc2Nyb2xsYWJsZSBsZWdlbmQsIGZvciBzYWtlIG9mIGZpbGUgc2l6ZS5cbi8vIFNlcmllcyBGaWx0ZXJcbmVjaGFydHMucmVnaXN0ZXJQcm9jZXNzb3IobGVnZW5kRmlsdGVyKTtcbkNvbXBvbmVudC5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoJ2xlZ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgLy8gRGVmYXVsdCAncGxhaW4nIHdoZW4gbm8gdHlwZSBzcGVjaWZpZWQuXG4gIHJldHVybiAncGxhaW4nO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC5qc1xuLy8gbW9kdWxlIGlkID0gMjc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbmZ1bmN0aW9uIGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIobWV0aG9kTmFtZSwgcGF5bG9hZCwgZWNNb2RlbCkge1xuICB2YXIgc2VsZWN0ZWRNYXAgPSB7fTtcbiAgdmFyIGlzVG9nZ2xlU2VsZWN0ID0gbWV0aG9kTmFtZSA9PT0gJ3RvZ2dsZVNlbGVjdGVkJztcbiAgdmFyIGlzU2VsZWN0ZWQ7IC8vIFVwZGF0ZSBhbGwgbGVnZW5kIGNvbXBvbmVudHNcblxuICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2xlZ2VuZCcsIGZ1bmN0aW9uIChsZWdlbmRNb2RlbCkge1xuICAgIGlmIChpc1RvZ2dsZVNlbGVjdCAmJiBpc1NlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgIC8vIEZvcmNlIG90aGVyIGxlZ2VuZCBoYXMgc2FtZSBzZWxlY3RlZCBzdGF0dXNcbiAgICAgIC8vIE9yIHRoZSBmaXJzdCBpcyB0b2dnbGVkIHRvIHRydWUgYW5kIG90aGVyIGFyZSB0b2dnbGVkIHRvIGZhbHNlXG4gICAgICAvLyBJbiB0aGUgY2FzZSBvbmUgbGVnZW5kIGhhcyBzb21lIGl0ZW0gdW5TZWxlY3RlZCBpbiBvcHRpb24uIEFuZCBpZiBvdGhlciBsZWdlbmRcbiAgICAgIC8vIGRvZXNuJ3QgaGFzIHRoZSBpdGVtLCB0aGV5IHdpbGwgYXNzdW1lIGl0IGlzIHNlbGVjdGVkLlxuICAgICAgbGVnZW5kTW9kZWxbaXNTZWxlY3RlZCA/ICdzZWxlY3QnIDogJ3VuU2VsZWN0J10ocGF5bG9hZC5uYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVnZW5kTW9kZWxbbWV0aG9kTmFtZV0ocGF5bG9hZC5uYW1lKTtcbiAgICAgIGlzU2VsZWN0ZWQgPSBsZWdlbmRNb2RlbC5pc1NlbGVjdGVkKHBheWxvYWQubmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGxlZ2VuZERhdGEgPSBsZWdlbmRNb2RlbC5nZXREYXRhKCk7XG4gICAgenJVdGlsLmVhY2gobGVnZW5kRGF0YSwgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICB2YXIgbmFtZSA9IG1vZGVsLmdldCgnbmFtZScpOyAvLyBXcmFwIGVsZW1lbnRcblxuICAgICAgaWYgKG5hbWUgPT09ICdcXG4nIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzSXRlbVNlbGVjdGVkID0gbGVnZW5kTW9kZWwuaXNTZWxlY3RlZChuYW1lKTtcblxuICAgICAgaWYgKHNlbGVjdGVkTWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIC8vIFVuc2VsZWN0ZWQgaWYgYW55IGxlZ2VuZCBpcyB1bnNlbGVjdGVkXG4gICAgICAgIHNlbGVjdGVkTWFwW25hbWVdID0gc2VsZWN0ZWRNYXBbbmFtZV0gJiYgaXNJdGVtU2VsZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IGlzSXRlbVNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTsgLy8gUmV0dXJuIHRoZSBldmVudCBleHBsaWNpdGx5XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBwYXlsb2FkLm5hbWUsXG4gICAgc2VsZWN0ZWQ6IHNlbGVjdGVkTWFwXG4gIH07XG59XG4vKipcbiAqIEBldmVudCBsZWdlbmRUb2dnbGVTZWxlY3RcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAnbGVnZW5kVG9nZ2xlU2VsZWN0J1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtmcm9tXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAqL1xuXG5cbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oJ2xlZ2VuZFRvZ2dsZVNlbGVjdCcsICdsZWdlbmRzZWxlY3RjaGFuZ2VkJywgenJVdGlsLmN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICd0b2dnbGVTZWxlY3RlZCcpKTtcbi8qKlxuICogQGV2ZW50IGxlZ2VuZFNlbGVjdFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRTZWxlY3QnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTZXJpZXMgbmFtZSBvciBkYXRhIGl0ZW0gbmFtZVxuICovXG5cbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oJ2xlZ2VuZFNlbGVjdCcsICdsZWdlbmRzZWxlY3RlZCcsIHpyVXRpbC5jdXJyeShsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyLCAnc2VsZWN0JykpO1xuLyoqXG4gKiBAZXZlbnQgbGVnZW5kVW5TZWxlY3RcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAnbGVnZW5kVW5TZWxlY3QnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTZXJpZXMgbmFtZSBvciBkYXRhIGl0ZW0gbmFtZVxuICovXG5cbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oJ2xlZ2VuZFVuU2VsZWN0JywgJ2xlZ2VuZHVuc2VsZWN0ZWQnLCB6clV0aWwuY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3VuU2VsZWN0JykpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJmdW5jdGlvbiBfZGVmYXVsdChlY01vZGVsKSB7XG4gIHZhciBsZWdlbmRNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICBtYWluVHlwZTogJ2xlZ2VuZCdcbiAgfSk7XG5cbiAgaWYgKGxlZ2VuZE1vZGVscyAmJiBsZWdlbmRNb2RlbHMubGVuZ3RoKSB7XG4gICAgZWNNb2RlbC5maWx0ZXJTZXJpZXMoZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgLy8gSWYgaW4gYW55IGxlZ2VuZCBjb21wb25lbnQgdGhlIHN0YXR1cyBpcyBub3Qgc2VsZWN0ZWQuXG4gICAgICAvLyBCZWNhdXNlIGluIGxlZ2VuZCBzZXJpZXMgaXMgYXNzdW1lZCBzZWxlY3RlZCB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgbGVnZW5kIGRhdGEuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZE1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWxlZ2VuZE1vZGVsc1tpXS5pc1NlbGVjdGVkKHNlcmllcy5uYW1lKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgTGVnZW5kTW9kZWwgPSByZXF1aXJlKFwiLi9MZWdlbmRNb2RlbFwiKTtcblxudmFyIF9sYXlvdXQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBtZXJnZUxheW91dFBhcmFtID0gX2xheW91dC5tZXJnZUxheW91dFBhcmFtO1xudmFyIGdldExheW91dFBhcmFtcyA9IF9sYXlvdXQuZ2V0TGF5b3V0UGFyYW1zO1xudmFyIFNjcm9sbGFibGVMZWdlbmRNb2RlbCA9IExlZ2VuZE1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdsZWdlbmQuc2Nyb2xsJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbERhdGFJbmRleFxuICAgKi9cbiAgc2V0U2Nyb2xsRGF0YUluZGV4OiBmdW5jdGlvbiAoc2Nyb2xsRGF0YUluZGV4KSB7XG4gICAgdGhpcy5vcHRpb24uc2Nyb2xsRGF0YUluZGV4ID0gc2Nyb2xsRGF0YUluZGV4O1xuICB9LFxuICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgc2Nyb2xsRGF0YUluZGV4OiAwLFxuICAgIHBhZ2VCdXR0b25JdGVtR2FwOiA1LFxuICAgIHBhZ2VCdXR0b25HYXA6IG51bGwsXG4gICAgcGFnZUJ1dHRvblBvc2l0aW9uOiAnZW5kJyxcbiAgICAvLyAnc3RhcnQnIG9yICdlbmQnXG4gICAgcGFnZUZvcm1hdHRlcjogJ3tjdXJyZW50fS97dG90YWx9JyxcbiAgICAvLyBJZiBudWxsL3VuZGVmaW5lZCwgZG8gbm90IHNob3cgcGFnZS5cbiAgICBwYWdlSWNvbnM6IHtcbiAgICAgIGhvcml6b250YWw6IFsnTTAsMEwxMiwtMTBMMTIsMTB6JywgJ00wLDBMLTEyLC0xMEwtMTIsMTB6J10sXG4gICAgICB2ZXJ0aWNhbDogWydNMCwwTDIwLDBMMTAsLTIweicsICdNMCwwTDIwLDBMMTAsMjB6J11cbiAgICB9LFxuICAgIHBhZ2VJY29uQ29sb3I6ICcjMmY0NTU0JyxcbiAgICBwYWdlSWNvbkluYWN0aXZlQ29sb3I6ICcjYWFhJyxcbiAgICBwYWdlSWNvblNpemU6IDE1LFxuICAgIC8vIENhbiBiZSBbMTAsIDNdLCB3aGljaCByZXByZXNlbnRzIFt3aWR0aCwgaGVpZ2h0XVxuICAgIHBhZ2VUZXh0U3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnIzMzMydcbiAgICB9LFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiA4MDBcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbiAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGdldExheW91dFBhcmFtcyhvcHRpb24pO1xuICAgIFNjcm9sbGFibGVMZWdlbmRNb2RlbC5zdXBlckNhbGwodGhpcywgJ2luaXQnLCBvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCk7XG4gICAgbWVyZ2VBbmROb3JtYWxpemVMYXlvdXRQYXJhbXModGhpcywgb3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zKTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbiwgZXh0cmFPcHQpIHtcbiAgICBTY3JvbGxhYmxlTGVnZW5kTW9kZWwuc3VwZXJDYWxsKHRoaXMsICdtZXJnZU9wdGlvbicsIG9wdGlvbiwgZXh0cmFPcHQpO1xuICAgIG1lcmdlQW5kTm9ybWFsaXplTGF5b3V0UGFyYW1zKHRoaXMsIHRoaXMub3B0aW9uLCBvcHRpb24pO1xuICB9LFxuICBnZXRPcmllbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ29yaWVudCcpID09PSAndmVydGljYWwnID8ge1xuICAgICAgaW5kZXg6IDEsXG4gICAgICBuYW1lOiAndmVydGljYWwnXG4gICAgfSA6IHtcbiAgICAgIGluZGV4OiAwLFxuICAgICAgbmFtZTogJ2hvcml6b250YWwnXG4gICAgfTtcbiAgfVxufSk7IC8vIERvIG5vdCBgaWdub3JlU2l6ZWAgdG8gZW5hYmxlIHNldHRpbmcge2xlZnQ6IDEwLCByaWdodDogMTB9LlxuXG5mdW5jdGlvbiBtZXJnZUFuZE5vcm1hbGl6ZUxheW91dFBhcmFtcyhsZWdlbmRNb2RlbCwgdGFyZ2V0LCByYXcpIHtcbiAgdmFyIG9yaWVudCA9IGxlZ2VuZE1vZGVsLmdldE9yaWVudCgpO1xuICB2YXIgaWdub3JlU2l6ZSA9IFsxLCAxXTtcbiAgaWdub3JlU2l6ZVtvcmllbnQuaW5kZXhdID0gMDtcbiAgbWVyZ2VMYXlvdXRQYXJhbSh0YXJnZXQsIHJhdywge1xuICAgIHR5cGU6ICdib3gnLFxuICAgIGlnbm9yZVNpemU6IGlnbm9yZVNpemVcbiAgfSk7XG59XG5cbnZhciBfZGVmYXVsdCA9IFNjcm9sbGFibGVMZWdlbmRNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDI3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBsYXlvdXRVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgTGVnZW5kVmlldyA9IHJlcXVpcmUoXCIuL0xlZ2VuZFZpZXdcIik7XG5cbi8qKlxuICogU2VwYXJhdGUgbGVnZW5kIGFuZCBzY3JvbGxhYmxlIGxlZ2VuZCB0byByZWR1Y2UgcGFja2FnZSBzaXplLlxuICovXG52YXIgR3JvdXAgPSBncmFwaGljLkdyb3VwO1xudmFyIFdIID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbnZhciBYWSA9IFsneCcsICd5J107XG52YXIgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcgPSBMZWdlbmRWaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdsZWdlbmQuc2Nyb2xsJyxcbiAgbmV3bGluZURpc2FibGVkOiB0cnVlLFxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuc3VwZXJDYWxsKHRoaXMsICdpbml0Jyk7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBGb3IgYHNjcm9sbGAuXG4gICAgICovXG5cbiAgICB0aGlzLl9jdXJyZW50SW5kZXggPSAwO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgKi9cblxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2NvbnRhaW5lckdyb3VwID0gbmV3IEdyb3VwKCkpO1xuXG4gICAgdGhpcy5fY29udGFpbmVyR3JvdXAuYWRkKHRoaXMuZ2V0Q29udGVudEdyb3VwKCkpO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgKi9cblxuXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5fY29udHJvbGxlckdyb3VwID0gbmV3IEdyb3VwKCkpO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX3Nob3dDb250cm9sbGVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlc2V0SW5uZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBTY3JvbGxhYmxlTGVnZW5kVmlldy5zdXBlckNhbGwodGhpcywgJ3Jlc2V0SW5uZXInKTtcblxuICAgIHRoaXMuX2NvbnRyb2xsZXJHcm91cC5yZW1vdmVBbGwoKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lckdyb3VwLnJlbW92ZUNsaXBQYXRoKCk7XG5cbiAgICB0aGlzLl9jb250YWluZXJHcm91cC5fX3JlY3RTaXplID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXJJbm5lcjogZnVuY3Rpb24gKGl0ZW1BbGlnbiwgbGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBtZSA9IHRoaXM7IC8vIFJlbmRlciBjb250ZW50IGl0ZW1zLlxuXG4gICAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuc3VwZXJDYWxsKHRoaXMsICdyZW5kZXJJbm5lcicsIGl0ZW1BbGlnbiwgbGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgdmFyIGNvbnRyb2xsZXJHcm91cCA9IHRoaXMuX2NvbnRyb2xsZXJHcm91cDtcbiAgICB2YXIgcGFnZUljb25TaXplID0gbGVnZW5kTW9kZWwuZ2V0KCdwYWdlSWNvblNpemUnLCB0cnVlKTtcblxuICAgIGlmICghenJVdGlsLmlzQXJyYXkocGFnZUljb25TaXplKSkge1xuICAgICAgcGFnZUljb25TaXplID0gW3BhZ2VJY29uU2l6ZSwgcGFnZUljb25TaXplXTtcbiAgICB9XG5cbiAgICBjcmVhdGVQYWdlQnV0dG9uKCdwYWdlUHJldicsIDApO1xuICAgIHZhciBwYWdlVGV4dFN0eWxlTW9kZWwgPSBsZWdlbmRNb2RlbC5nZXRNb2RlbCgncGFnZVRleHRTdHlsZScpO1xuICAgIGNvbnRyb2xsZXJHcm91cC5hZGQobmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICBuYW1lOiAncGFnZVRleHQnLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdGV4dEZpbGw6IHBhZ2VUZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgZm9udDogcGFnZVRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXG4gICAgICB9LFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSkpO1xuICAgIGNyZWF0ZVBhZ2VCdXR0b24oJ3BhZ2VOZXh0JywgMSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWdlQnV0dG9uKG5hbWUsIGljb25JZHgpIHtcbiAgICAgIHZhciBwYWdlRGF0YUluZGV4TmFtZSA9IG5hbWUgKyAnRGF0YUluZGV4JztcbiAgICAgIHZhciBpY29uID0gZ3JhcGhpYy5jcmVhdGVJY29uKGxlZ2VuZE1vZGVsLmdldCgncGFnZUljb25zJywgdHJ1ZSlbbGVnZW5kTW9kZWwuZ2V0T3JpZW50KCkubmFtZV1baWNvbklkeF0sIHtcbiAgICAgICAgLy8gQnV0dG9ucyB3aWxsIGJlIGNyZWF0ZWQgaW4gZWFjaCByZW5kZXIsIHNvIHdlIGRvIG5vdCBuZWVkXG4gICAgICAgIC8vIHRvIHdvcnJ5IGFib3V0IGF2b2lkaW5nIHVzaW5nIGxlZ2VuZE1vZGVsIGtlcHQgaW4gc2NvcGUuXG4gICAgICAgIG9uY2xpY2s6IHpyVXRpbC5iaW5kKG1lLl9wYWdlR28sIG1lLCBwYWdlRGF0YUluZGV4TmFtZSwgbGVnZW5kTW9kZWwsIGFwaSlcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLXBhZ2VJY29uU2l6ZVswXSAvIDIsXG4gICAgICAgIHk6IC1wYWdlSWNvblNpemVbMV0gLyAyLFxuICAgICAgICB3aWR0aDogcGFnZUljb25TaXplWzBdLFxuICAgICAgICBoZWlnaHQ6IHBhZ2VJY29uU2l6ZVsxXVxuICAgICAgfSk7XG4gICAgICBpY29uLm5hbWUgPSBuYW1lO1xuICAgICAgY29udHJvbGxlckdyb3VwLmFkZChpY29uKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbGF5b3V0SW5uZXI6IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaXRlbUFsaWduLCBtYXhTaXplKSB7XG4gICAgdmFyIGNvbnRlbnRHcm91cCA9IHRoaXMuZ2V0Q29udGVudEdyb3VwKCk7XG4gICAgdmFyIGNvbnRhaW5lckdyb3VwID0gdGhpcy5fY29udGFpbmVyR3JvdXA7XG4gICAgdmFyIGNvbnRyb2xsZXJHcm91cCA9IHRoaXMuX2NvbnRyb2xsZXJHcm91cDtcbiAgICB2YXIgb3JpZW50SWR4ID0gbGVnZW5kTW9kZWwuZ2V0T3JpZW50KCkuaW5kZXg7XG4gICAgdmFyIHdoID0gV0hbb3JpZW50SWR4XTtcbiAgICB2YXIgaHcgPSBXSFsxIC0gb3JpZW50SWR4XTtcbiAgICB2YXIgeXggPSBYWVsxIC0gb3JpZW50SWR4XTsgLy8gUGxhY2UgaXRlbXMgaW4gY29udGVudEdyb3VwLlxuXG4gICAgbGF5b3V0VXRpbC5ib3gobGVnZW5kTW9kZWwuZ2V0KCdvcmllbnQnKSwgY29udGVudEdyb3VwLCBsZWdlbmRNb2RlbC5nZXQoJ2l0ZW1HYXAnKSwgIW9yaWVudElkeCA/IG51bGwgOiBtYXhTaXplLndpZHRoLCBvcmllbnRJZHggPyBudWxsIDogbWF4U2l6ZS5oZWlnaHQpO1xuICAgIGxheW91dFV0aWwuYm94KCAvLyBCdXR0b25zIGluIGNvbnRyb2xsZXIgYXJlIGxheW91dCBhbHdheXMgaG9yaXpvbnRhbGx5LlxuICAgICdob3Jpem9udGFsJywgY29udHJvbGxlckdyb3VwLCBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VCdXR0b25JdGVtR2FwJywgdHJ1ZSkpO1xuICAgIHZhciBjb250ZW50UmVjdCA9IGNvbnRlbnRHcm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgY29udHJvbGxlclJlY3QgPSBjb250cm9sbGVyR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIHNob3dDb250cm9sbGVyID0gdGhpcy5fc2hvd0NvbnRyb2xsZXIgPSBjb250ZW50UmVjdFt3aF0gPiBtYXhTaXplW3doXTtcbiAgICB2YXIgY29udGVudFBvcyA9IFstY29udGVudFJlY3QueCwgLWNvbnRlbnRSZWN0LnldOyAvLyBSZW1haW4gY29udGVudFBvcyB3aGVuIHNjcm9sbCBhbmltYXRpb24gcGVyZnJvbWluZy5cblxuICAgIGNvbnRlbnRQb3Nbb3JpZW50SWR4XSA9IGNvbnRlbnRHcm91cC5wb3NpdGlvbltvcmllbnRJZHhdOyAvLyBMYXlvdXQgY29udGFpbmVyIGdyb3VwIGJhc2VkIG9uIDAuXG5cbiAgICB2YXIgY29udGFpbmVyUG9zID0gWzAsIDBdO1xuICAgIHZhciBjb250cm9sbGVyUG9zID0gWy1jb250cm9sbGVyUmVjdC54LCAtY29udHJvbGxlclJlY3QueV07XG4gICAgdmFyIHBhZ2VCdXR0b25HYXAgPSB6clV0aWwucmV0cmlldmUyKGxlZ2VuZE1vZGVsLmdldCgncGFnZUJ1dHRvbkdhcCcsIHRydWUpLCBsZWdlbmRNb2RlbC5nZXQoJ2l0ZW1HYXAnLCB0cnVlKSk7IC8vIFBsYWNlIGNvbnRhaW5lckdyb3VwIGFuZCBjb250cm9sbGVyR3JvdXAgYW5kIGNvbnRlbnRHcm91cC5cblxuICAgIGlmIChzaG93Q29udHJvbGxlcikge1xuICAgICAgdmFyIHBhZ2VCdXR0b25Qb3NpdGlvbiA9IGxlZ2VuZE1vZGVsLmdldCgncGFnZUJ1dHRvblBvc2l0aW9uJywgdHJ1ZSk7IC8vIGNvbnRyb2xsZXIgaXMgb24gdGhlIHJpZ2h0IC8gYm90dG9tLlxuXG4gICAgICBpZiAocGFnZUJ1dHRvblBvc2l0aW9uID09PSAnZW5kJykge1xuICAgICAgICBjb250cm9sbGVyUG9zW29yaWVudElkeF0gKz0gbWF4U2l6ZVt3aF0gLSBjb250cm9sbGVyUmVjdFt3aF07XG4gICAgICB9IC8vIGNvbnRyb2xsZXIgaXMgb24gdGhlIGxlZnQgLyB0b3AuXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXJQb3Nbb3JpZW50SWR4XSArPSBjb250cm9sbGVyUmVjdFt3aF0gKyBwYWdlQnV0dG9uR2FwO1xuICAgICAgICB9XG4gICAgfSAvLyBBbHdheXMgYWxpZ24gY29udHJvbGxlciB0byBjb250ZW50IGFzICdtaWRkbGUnLlxuXG5cbiAgICBjb250cm9sbGVyUG9zWzEgLSBvcmllbnRJZHhdICs9IGNvbnRlbnRSZWN0W2h3XSAvIDIgLSBjb250cm9sbGVyUmVjdFtod10gLyAyO1xuICAgIGNvbnRlbnRHcm91cC5hdHRyKCdwb3NpdGlvbicsIGNvbnRlbnRQb3MpO1xuICAgIGNvbnRhaW5lckdyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgY29udGFpbmVyUG9zKTtcbiAgICBjb250cm9sbGVyR3JvdXAuYXR0cigncG9zaXRpb24nLCBjb250cm9sbGVyUG9zKTsgLy8gQ2FsY3VsYXRlIGBtYWluUmVjdGAgYW5kIHNldCBgY2xpcFBhdGhgLlxuICAgIC8vIG1haW5SZWN0IHNob3VsZCBub3QgYmUgY2FsY3VsYXRlZCBieSBgdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKWBcbiAgICAvLyBmb3Igc2FrZSBvZiB0aGUgb3ZlcmZsb3cuXG5cbiAgICB2YXIgbWFpblJlY3QgPSB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBtYWluUmVjdCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTsgLy8gQ29uc2lkZXIgY29udGVudCBtYXkgYmUgb3ZlcmZsb3cgKHNob3VsZCBiZSBjbGlwcGVkKS5cblxuICAgIG1haW5SZWN0W3doXSA9IHNob3dDb250cm9sbGVyID8gbWF4U2l6ZVt3aF0gOiBjb250ZW50UmVjdFt3aF07XG4gICAgbWFpblJlY3RbaHddID0gTWF0aC5tYXgoY29udGVudFJlY3RbaHddLCBjb250cm9sbGVyUmVjdFtod10pOyAvLyBgY29udGFpbmVyUmVjdFt5eF0gKyBjb250YWluZXJQb3NbMSAtIG9yaWVudElkeF1gIGlzIDAuXG5cbiAgICBtYWluUmVjdFt5eF0gPSBNYXRoLm1pbigwLCBjb250cm9sbGVyUmVjdFt5eF0gKyBjb250cm9sbGVyUG9zWzEgLSBvcmllbnRJZHhdKTtcbiAgICBjb250YWluZXJHcm91cC5fX3JlY3RTaXplID0gbWF4U2l6ZVt3aF07XG5cbiAgICBpZiAoc2hvd0NvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBjbGlwU2hhcGUgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBjbGlwU2hhcGVbd2hdID0gTWF0aC5tYXgobWF4U2l6ZVt3aF0gLSBjb250cm9sbGVyUmVjdFt3aF0gLSBwYWdlQnV0dG9uR2FwLCAwKTtcbiAgICAgIGNsaXBTaGFwZVtod10gPSBtYWluUmVjdFtod107XG4gICAgICBjb250YWluZXJHcm91cC5zZXRDbGlwUGF0aChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgc2hhcGU6IGNsaXBTaGFwZVxuICAgICAgfSkpOyAvLyBDb25zaWRlciBjb250ZW50IG1heSBiZSBsYXJnZXIgdGhhbiBjb250YWluZXIsIGNvbnRhaW5lciByZWN0XG4gICAgICAvLyBjYW4gbm90IGJlIG9idGFpbmVkIGZyb20gYGNvbnRhaW5lckdyb3VwLmdldEJvdW5kaW5nUmVjdCgpYC5cblxuICAgICAgY29udGFpbmVyR3JvdXAuX19yZWN0U2l6ZSA9IGNsaXBTaGFwZVt3aF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERvIG5vdCByZW1vdmUgb3IgaWdub3JlIGNvbnRyb2xsZXIuIEtlZXAgdGhlbSBzZXQgYXMgcGxhY2UgaG9sZGVycy5cbiAgICAgIGNvbnRyb2xsZXJHcm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLmF0dHIoe1xuICAgICAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIENvbnRlbnQgdHJhbnNsYXRlIGFuaW1hdGlvbi5cblxuXG4gICAgdmFyIHBhZ2VJbmZvID0gdGhpcy5fZ2V0UGFnZUluZm8obGVnZW5kTW9kZWwpO1xuXG4gICAgcGFnZUluZm8ucGFnZUluZGV4ICE9IG51bGwgJiYgZ3JhcGhpYy51cGRhdGVQcm9wcyhjb250ZW50R3JvdXAsIHtcbiAgICAgIHBvc2l0aW9uOiBwYWdlSW5mby5jb250ZW50UG9zaXRpb25cbiAgICB9LCAvLyBXaGVuIHN3aXRjaCBmcm9tIFwic2hvdyBjb250cm9sbGVyXCIgdG8gXCJub3Qgc2hvdyBjb250cm9sbGVyXCIsIHZpZXcgc2hvdWxkIGJlXG4gICAgLy8gdXBkYXRlZCBpbW1lZGlhdGVseSB3aXRob3V0IGFuaW1hdGlvbiwgb3RoZXJ3aXNlIGNhdXNlcyB3ZWlyZCBlZmZmZWN0LlxuICAgIHNob3dDb250cm9sbGVyID8gbGVnZW5kTW9kZWwgOiBmYWxzZSk7XG5cbiAgICB0aGlzLl91cGRhdGVQYWdlSW5mb1ZpZXcobGVnZW5kTW9kZWwsIHBhZ2VJbmZvKTtcblxuICAgIHJldHVybiBtYWluUmVjdDtcbiAgfSxcbiAgX3BhZ2VHbzogZnVuY3Rpb24gKHRvLCBsZWdlbmRNb2RlbCwgYXBpKSB7XG4gICAgdmFyIHNjcm9sbERhdGFJbmRleCA9IHRoaXMuX2dldFBhZ2VJbmZvKGxlZ2VuZE1vZGVsKVt0b107XG5cbiAgICBzY3JvbGxEYXRhSW5kZXggIT0gbnVsbCAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2xlZ2VuZFNjcm9sbCcsXG4gICAgICBzY3JvbGxEYXRhSW5kZXg6IHNjcm9sbERhdGFJbmRleCxcbiAgICAgIGxlZ2VuZElkOiBsZWdlbmRNb2RlbC5pZFxuICAgIH0pO1xuICB9LFxuICBfdXBkYXRlUGFnZUluZm9WaWV3OiBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIHBhZ2VJbmZvKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJHcm91cCA9IHRoaXMuX2NvbnRyb2xsZXJHcm91cDtcbiAgICB6clV0aWwuZWFjaChbJ3BhZ2VQcmV2JywgJ3BhZ2VOZXh0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgY2FuSnVtcCA9IHBhZ2VJbmZvW25hbWUgKyAnRGF0YUluZGV4J10gIT0gbnVsbDtcbiAgICAgIHZhciBpY29uID0gY29udHJvbGxlckdyb3VwLmNoaWxkT2ZOYW1lKG5hbWUpO1xuXG4gICAgICBpZiAoaWNvbikge1xuICAgICAgICBpY29uLnNldFN0eWxlKCdmaWxsJywgY2FuSnVtcCA/IGxlZ2VuZE1vZGVsLmdldCgncGFnZUljb25Db2xvcicsIHRydWUpIDogbGVnZW5kTW9kZWwuZ2V0KCdwYWdlSWNvbkluYWN0aXZlQ29sb3InLCB0cnVlKSk7XG4gICAgICAgIGljb24uY3Vyc29yID0gY2FuSnVtcCA/ICdwb2ludGVyJyA6ICdkZWZhdWx0JztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgcGFnZVRleHQgPSBjb250cm9sbGVyR3JvdXAuY2hpbGRPZk5hbWUoJ3BhZ2VUZXh0Jyk7XG4gICAgdmFyIHBhZ2VGb3JtYXR0ZXIgPSBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VGb3JtYXR0ZXInKTtcbiAgICB2YXIgcGFnZUluZGV4ID0gcGFnZUluZm8ucGFnZUluZGV4O1xuICAgIHZhciBjdXJyZW50ID0gcGFnZUluZGV4ICE9IG51bGwgPyBwYWdlSW5kZXggKyAxIDogMDtcbiAgICB2YXIgdG90YWwgPSBwYWdlSW5mby5wYWdlQ291bnQ7XG4gICAgcGFnZVRleHQgJiYgcGFnZUZvcm1hdHRlciAmJiBwYWdlVGV4dC5zZXRTdHlsZSgndGV4dCcsIHpyVXRpbC5pc1N0cmluZyhwYWdlRm9ybWF0dGVyKSA/IHBhZ2VGb3JtYXR0ZXIucmVwbGFjZSgne2N1cnJlbnR9JywgY3VycmVudCkucmVwbGFjZSgne3RvdGFsfScsIHRvdGFsKSA6IHBhZ2VGb3JtYXR0ZXIoe1xuICAgICAgY3VycmVudDogY3VycmVudCxcbiAgICAgIHRvdGFsOiB0b3RhbFxuICAgIH0pKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbGVnZW5kTW9kZWxcbiAgICogQHJldHVybiB7T2JqZWN0fSB7XG4gICAqICBjb250ZW50UG9zaXRpb246IEFycmF5LjxudW1iZXI+LCBudWxsIHdoZW4gZGF0YSBpdGVtIG5vdCBmb3VuZC5cbiAgICogIHBhZ2VJbmRleDogbnVtYmVyLCBudWxsIHdoZW4gZGF0YSBpdGVtIG5vdCBmb3VuZC5cbiAgICogIHBhZ2VDb3VudDogbnVtYmVyLCBhbHdheXMgYmUgYSBudW1iZXIsIGNhbiBiZSAwLlxuICAgKiAgcGFnZVByZXZEYXRhSW5kZXg6IG51bWJlciwgbnVsbCB3aGVuIG5vIG5leHQgcGFnZS5cbiAgICogIHBhZ2VOZXh0RGF0YUluZGV4OiBudW1iZXIsIG51bGwgd2hlbiBubyBwcmV2aW91cyBwYWdlLlxuICAgKiB9XG4gICAqL1xuICBfZ2V0UGFnZUluZm86IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCkge1xuICAgIC8vIEFsaWduIGxlZnQgb3IgdG9wIGJ5IHRoZSBjdXJyZW50IGRhdGFJbmRleC5cbiAgICB2YXIgY3VyckRhdGFJbmRleCA9IGxlZ2VuZE1vZGVsLmdldCgnc2Nyb2xsRGF0YUluZGV4JywgdHJ1ZSk7XG4gICAgdmFyIGNvbnRlbnRHcm91cCA9IHRoaXMuZ2V0Q29udGVudEdyb3VwKCk7XG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudEdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBjb250YWluZXJSZWN0U2l6ZSA9IHRoaXMuX2NvbnRhaW5lckdyb3VwLl9fcmVjdFNpemU7XG4gICAgdmFyIG9yaWVudElkeCA9IGxlZ2VuZE1vZGVsLmdldE9yaWVudCgpLmluZGV4O1xuICAgIHZhciB3aCA9IFdIW29yaWVudElkeF07XG4gICAgdmFyIGh3ID0gV0hbMSAtIG9yaWVudElkeF07XG4gICAgdmFyIHh5ID0gWFlbb3JpZW50SWR4XTtcbiAgICB2YXIgY29udGVudFBvcyA9IGNvbnRlbnRHcm91cC5wb3NpdGlvbi5zbGljZSgpO1xuICAgIHZhciBwYWdlSW5kZXg7XG4gICAgdmFyIHBhZ2VQcmV2RGF0YUluZGV4O1xuICAgIHZhciBwYWdlTmV4dERhdGFJbmRleDtcbiAgICB2YXIgdGFyZ2V0SXRlbUdyb3VwO1xuXG4gICAgaWYgKHRoaXMuX3Nob3dDb250cm9sbGVyKSB7XG4gICAgICBjb250ZW50R3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuX19sZWdlbmREYXRhSW5kZXggPT09IGN1cnJEYXRhSW5kZXgpIHtcbiAgICAgICAgICB0YXJnZXRJdGVtR3JvdXAgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEl0ZW1Hcm91cCA9IGNvbnRlbnRHcm91cC5jaGlsZEF0KDApO1xuICAgIH1cblxuICAgIHZhciBwYWdlQ291bnQgPSBjb250YWluZXJSZWN0U2l6ZSA/IE1hdGguY2VpbChjb250ZW50UmVjdFt3aF0gLyBjb250YWluZXJSZWN0U2l6ZSkgOiAwO1xuXG4gICAgaWYgKHRhcmdldEl0ZW1Hcm91cCkge1xuICAgICAgdmFyIGl0ZW1SZWN0ID0gdGFyZ2V0SXRlbUdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgdmFyIGl0ZW1Mb2MgPSB0YXJnZXRJdGVtR3JvdXAucG9zaXRpb25bb3JpZW50SWR4XSArIGl0ZW1SZWN0W3h5XTtcbiAgICAgIGNvbnRlbnRQb3Nbb3JpZW50SWR4XSA9IC1pdGVtTG9jIC0gY29udGVudFJlY3RbeHldO1xuICAgICAgcGFnZUluZGV4ID0gTWF0aC5mbG9vcihwYWdlQ291bnQgKiAoaXRlbUxvYyArIGl0ZW1SZWN0W3h5XSArIGNvbnRhaW5lclJlY3RTaXplIC8gMikgLyBjb250ZW50UmVjdFt3aF0pO1xuICAgICAgcGFnZUluZGV4ID0gY29udGVudFJlY3Rbd2hdICYmIHBhZ2VDb3VudCA/IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VDb3VudCAtIDEsIHBhZ2VJbmRleCkpIDogLTE7XG4gICAgICB2YXIgd2luUmVjdCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIHdpblJlY3Rbd2hdID0gY29udGFpbmVyUmVjdFNpemU7XG4gICAgICB3aW5SZWN0W2h3XSA9IGNvbnRlbnRSZWN0W2h3XTtcbiAgICAgIHdpblJlY3RbeHldID0gLWNvbnRlbnRQb3Nbb3JpZW50SWR4XSAtIGNvbnRlbnRSZWN0W3h5XTtcbiAgICAgIHZhciBzdGFydElkeDtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbnRlbnRHcm91cC5jaGlsZHJlbigpO1xuICAgICAgY29udGVudEdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIHZhciBpdGVtUmVjdCA9IGdldEl0ZW1SZWN0KGNoaWxkKTtcblxuICAgICAgICBpZiAoaXRlbVJlY3QuaW50ZXJzZWN0KHdpblJlY3QpKSB7XG4gICAgICAgICAgc3RhcnRJZHggPT0gbnVsbCAmJiAoc3RhcnRJZHggPSBpbmRleCk7IC8vIEl0IGlzIHVzZXItZnJpZW5kbHkgdGhhdCB0aGUgbGFzdCBpdGVtIHNob3duIGluIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgd2luZG93IGlzIHNob3duIGF0IHRoZSBiZWdpbmluZyBvZiBuZXh0IHdpbmRvdy5cblxuICAgICAgICAgIHBhZ2VOZXh0RGF0YUluZGV4ID0gY2hpbGQuX19sZWdlbmREYXRhSW5kZXg7XG4gICAgICAgIH0gLy8gSWYgdGhlIGxhc3QgaXRlbSBpcyBzaG93biBlbnRpcmVseSwgbm8gbmV4dCBwYWdlLlxuXG5cbiAgICAgICAgaWYgKGluZGV4ID09PSBjaGlsZHJlbi5sZW5ndGggLSAxICYmIGl0ZW1SZWN0W3h5XSArIGl0ZW1SZWN0W3doXSA8PSB3aW5SZWN0W3h5XSArIHdpblJlY3Rbd2hdKSB7XG4gICAgICAgICAgcGFnZU5leHREYXRhSW5kZXggPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQWx3YXlzIGFsaWduIGJhc2VkIG9uIHRoZSBsZWZ0L3RvcCBtb3N0IGl0ZW0sIHNvIHRoZSBsZWZ0L3RvcCBtb3N0XG4gICAgICAvLyBpdGVtIGluIHRoZSBwcmV2aW91cyB3aW5kb3cgaXMgbmVlZGVkIHRvIGJlIGZvdW5kIGhlcmUuXG5cbiAgICAgIGlmIChzdGFydElkeCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBzdGFydEl0ZW0gPSBjaGlsZHJlbltzdGFydElkeF07XG4gICAgICAgIHZhciBzdGFydFJlY3QgPSBnZXRJdGVtUmVjdChzdGFydEl0ZW0pO1xuICAgICAgICB3aW5SZWN0W3h5XSA9IHN0YXJ0UmVjdFt4eV0gKyBzdGFydFJlY3Rbd2hdIC0gd2luUmVjdFt3aF07IC8vIElmIHRoZSBmaXJzdCBpdGVtIGlzIHNob3duIGVudGlyZWx5LCBubyBwcmV2aW91cyBwYWdlLlxuXG4gICAgICAgIGlmIChzdGFydElkeCA8PSAwICYmIHN0YXJ0UmVjdFt4eV0gPj0gd2luUmVjdFt4eV0pIHtcbiAgICAgICAgICBwYWdlUHJldkRhdGFJbmRleCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hpbGUgKHN0YXJ0SWR4ID4gMCAmJiBnZXRJdGVtUmVjdChjaGlsZHJlbltzdGFydElkeCAtIDFdKS5pbnRlcnNlY3Qod2luUmVjdCkpIHtcbiAgICAgICAgICAgIHN0YXJ0SWR4LS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFnZVByZXZEYXRhSW5kZXggPSBjaGlsZHJlbltzdGFydElkeF0uX19sZWdlbmREYXRhSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudFBvc2l0aW9uOiBjb250ZW50UG9zLFxuICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICBwYWdlQ291bnQ6IHBhZ2VDb3VudCxcbiAgICAgIHBhZ2VQcmV2RGF0YUluZGV4OiBwYWdlUHJldkRhdGFJbmRleCxcbiAgICAgIHBhZ2VOZXh0RGF0YUluZGV4OiBwYWdlTmV4dERhdGFJbmRleFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRJdGVtUmVjdChlbCkge1xuICAgICAgdmFyIGl0ZW1SZWN0ID0gZWwuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAgIGl0ZW1SZWN0W3h5XSArPSBlbC5wb3NpdGlvbltvcmllbnRJZHhdO1xuICAgICAgcmV0dXJuIGl0ZW1SZWN0O1xuICAgIH1cbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBTY3JvbGxhYmxlTGVnZW5kVmlldztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxuLyoqXG4gKiBAZXZlbnQgbGVnZW5kU2Nyb2xsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFNjcm9sbCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzY3JvbGxEYXRhSW5kZXhcbiAqL1xuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbignbGVnZW5kU2Nyb2xsJywgJ2xlZ2VuZHNjcm9sbCcsIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gIHZhciBzY3JvbGxEYXRhSW5kZXggPSBwYXlsb2FkLnNjcm9sbERhdGFJbmRleDtcbiAgc2Nyb2xsRGF0YUluZGV4ICE9IG51bGwgJiYgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICBtYWluVHlwZTogJ2xlZ2VuZCcsXG4gICAgc3ViVHlwZTogJ3Njcm9sbCcsXG4gICAgcXVlcnk6IHBheWxvYWRcbiAgfSwgZnVuY3Rpb24gKGxlZ2VuZE1vZGVsKSB7XG4gICAgbGVnZW5kTW9kZWwuc2V0U2Nyb2xsRGF0YUluZGV4KHNjcm9sbERhdGFJbmRleCk7XG4gIH0pO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9zY3JvbGxhYmxlTGVnZW5kQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKFwiLi9kYXRhWm9vbS90eXBlRGVmYXVsdGVyXCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9EYXRhWm9vbVZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL1NsaWRlclpvb21Nb2RlbFwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vU2xpZGVyWm9vbVZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL0luc2lkZVpvb21Nb2RlbFwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vSW5zaWRlWm9vbVZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL2RhdGFab29tUHJvY2Vzc29yXCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9kYXRhWm9vbUFjdGlvblwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20uanNcbi8vIG1vZHVsZSBpZCA9IDI4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIGhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBhc2MgPSBudW1iZXJVdGlsLmFzYztcbi8qKlxuICogT3BlcmF0ZSBzaW5nbGUgYXhpcy5cbiAqIE9uZSBheGlzIGNhbiBvbmx5IG9wZXJhdGVkIGJ5IG9uZSBheGlzIG9wZXJhdG9yLlxuICogRGlmZmVyZW50IGRhdGFab29tTW9kZWxzIG1heSBiZSBkZWZpbmVkIHRvIG9wZXJhdGUgdGhlIHNhbWUgYXhpcy5cbiAqIChpLmUuICdpbnNpZGUnIGRhdGEgem9vbSBhbmQgJ3NsaWRlcicgZGF0YSB6b29tIGNvbXBvbmVudHMpXG4gKiBTbyBkYXRhWm9vbU1vZGVscyBzaGFyZSBvbmUgYXhpc1Byb3h5IGluIHRoYXQgY2FzZS5cbiAqXG4gKiBAY2xhc3NcbiAqL1xuXG52YXIgQXhpc1Byb3h5ID0gZnVuY3Rpb24gKGRpbU5hbWUsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuX2RpbU5hbWUgPSBkaW1OYW1lO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fYXhpc0luZGV4ID0gYXhpc0luZGV4O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cblxuICB0aGlzLl92YWx1ZVdpbmRvdztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cbiAgdGhpcy5fcGVyY2VudFdpbmRvdztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cbiAgdGhpcy5fZGF0YUV4dGVudDtcbiAgLyoqXG4gICAqIHttaW5TcGFuLCBtYXhTcGFuLCBtaW5WYWx1ZVNwYW4sIG1heFZhbHVlU3Bhbn1cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5fbWluTWF4U3BhbjtcbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKiBAdHlwZSB7bW9kdWxlOiBlY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICovXG5cbiAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9XG4gICAqL1xuXG4gIHRoaXMuX2RhdGFab29tTW9kZWwgPSBkYXRhWm9vbU1vZGVsO1xufTtcblxuQXhpc1Byb3h5LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEF4aXNQcm94eSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgYXhpc1Byb3h5IGlzIGhvc3RlZCBieSBkYXRhWm9vbU1vZGVsLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfSBkYXRhWm9vbU1vZGVsXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBob3N0ZWRCeTogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVpvb21Nb2RlbCA9PT0gZGF0YVpvb21Nb2RlbDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFZhbHVlIGNhbiBvbmx5IGJlIE5hTiBvciBmaW5pdGUgdmFsdWUuXG4gICAqL1xuICBnZXREYXRhVmFsdWVXaW5kb3c6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVXaW5kb3cuc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBnZXREYXRhUGVyY2VudFdpbmRvdzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wZXJjZW50V2luZG93LnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNJbmRleFxuICAgKiBAcmV0dXJuIHtBcnJheX0gc2VyaWVzTW9kZWxzXG4gICAqL1xuICBnZXRUYXJnZXRTZXJpZXNNb2RlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VyaWVzTW9kZWxzID0gW107XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaWYgKGhlbHBlci5pc0Nvb3JkU3VwcG9ydGVkKHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpKSkge1xuICAgICAgICB2YXIgZGltTmFtZSA9IHRoaXMuX2RpbU5hbWU7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgbWFpblR5cGU6IGRpbU5hbWUgKyAnQXhpcycsXG4gICAgICAgICAgaW5kZXg6IHNlcmllc01vZGVsLmdldChkaW1OYW1lICsgJ0F4aXNJbmRleCcpLFxuICAgICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZSArICdBeGlzSWQnKVxuICAgICAgICB9KVswXTtcblxuICAgICAgICBpZiAodGhpcy5fYXhpc0luZGV4ID09PSAoYXhpc01vZGVsICYmIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCkpIHtcbiAgICAgICAgICBzZXJpZXNNb2RlbHMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gc2VyaWVzTW9kZWxzO1xuICB9LFxuICBnZXRBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lY01vZGVsLmdldENvbXBvbmVudCh0aGlzLl9kaW1OYW1lICsgJ0F4aXMnLCB0aGlzLl9heGlzSW5kZXgpO1xuICB9LFxuICBnZXRPdGhlckF4aXNNb2RlbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzRGltID0gdGhpcy5fZGltTmFtZTtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5nZXRBeGlzTW9kZWwoKTtcbiAgICB2YXIgaXNDYXJ0ZXNpYW4gPSBheGlzRGltID09PSAneCcgfHwgYXhpc0RpbSA9PT0gJ3knO1xuICAgIHZhciBvdGhlckF4aXNEaW07XG4gICAgdmFyIGNvb3JkU3lzSW5kZXhOYW1lO1xuXG4gICAgaWYgKGlzQ2FydGVzaWFuKSB7XG4gICAgICBjb29yZFN5c0luZGV4TmFtZSA9ICdncmlkSW5kZXgnO1xuICAgICAgb3RoZXJBeGlzRGltID0gYXhpc0RpbSA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZFN5c0luZGV4TmFtZSA9ICdwb2xhckluZGV4JztcbiAgICAgIG90aGVyQXhpc0RpbSA9IGF4aXNEaW0gPT09ICdhbmdsZScgPyAncmFkaXVzJyA6ICdhbmdsZSc7XG4gICAgfVxuXG4gICAgdmFyIGZvdW5kT3RoZXJBeGlzTW9kZWw7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KG90aGVyQXhpc0RpbSArICdBeGlzJywgZnVuY3Rpb24gKG90aGVyQXhpc01vZGVsKSB7XG4gICAgICBpZiAoKG90aGVyQXhpc01vZGVsLmdldChjb29yZFN5c0luZGV4TmFtZSkgfHwgMCkgPT09IChheGlzTW9kZWwuZ2V0KGNvb3JkU3lzSW5kZXhOYW1lKSB8fCAwKSkge1xuICAgICAgICBmb3VuZE90aGVyQXhpc01vZGVsID0gb3RoZXJBeGlzTW9kZWw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kT3RoZXJBeGlzTW9kZWw7XG4gIH0sXG4gIGdldE1pbk1heFNwYW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4genJVdGlsLmNsb25lKHRoaXMuX21pbk1heFNwYW4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPbmx5IGNhbGN1bGF0ZSBieSBnaXZlbiByYW5nZSBhbmQgdGhpcy5fZGF0YUV4dGVudCwgZG8gbm90IGNoYW5nZSBhbnl0aGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdGFydFZhbHVlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5lbmRWYWx1ZV1cbiAgICovXG4gIGNhbGN1bGF0ZURhdGFXaW5kb3c6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuX2RhdGFFeHRlbnQ7XG4gICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZ2V0QXhpc01vZGVsKCk7XG4gICAgdmFyIHNjYWxlID0gYXhpc01vZGVsLmF4aXMuc2NhbGU7XG5cbiAgICB2YXIgcmFuZ2VQcm9wTW9kZSA9IHRoaXMuX2RhdGFab29tTW9kZWwuZ2V0UmFuZ2VQcm9wTW9kZSgpO1xuXG4gICAgdmFyIHBlcmNlbnRFeHRlbnQgPSBbMCwgMTAwXTtcbiAgICB2YXIgcGVyY2VudFdpbmRvdyA9IFtvcHQuc3RhcnQsIG9wdC5lbmRdO1xuICAgIHZhciB2YWx1ZVdpbmRvdyA9IFtdO1xuICAgIGVhY2goWydzdGFydFZhbHVlJywgJ2VuZFZhbHVlJ10sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICB2YWx1ZVdpbmRvdy5wdXNoKG9wdFtwcm9wXSAhPSBudWxsID8gc2NhbGUucGFyc2Uob3B0W3Byb3BdKSA6IG51bGwpO1xuICAgIH0pOyAvLyBOb3JtYWxpemUgYm91bmQuXG5cbiAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIGJvdW5kVmFsdWUgPSB2YWx1ZVdpbmRvd1tpZHhdO1xuICAgICAgdmFyIGJvdW5kUGVyY2VudCA9IHBlcmNlbnRXaW5kb3dbaWR4XTsgLy8gTm90aWNlOiBkYXRhWm9vbSBpcyBiYXNlZCBlaXRoZXIgb24gYHBlcmNlbnRQcm9wYCAoJ3N0YXJ0JywgJ2VuZCcpIG9yXG4gICAgICAvLyBvbiBgdmFsdWVQcm9wYCAoJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnKS4gVGhlIGZvcm1lciBvbmUgaXMgc3VpdGFibGVcbiAgICAgIC8vIGZvciBjYXNlcyB0aGF0IGEgZGF0YVpvb20gY29tcG9uZW50IGNvbnRyb2xzIG11bHRpcGxlIGF4ZXMgd2l0aCBkaWZmZXJlbnRcbiAgICAgIC8vIHVuaXQgb3IgZXh0ZW50LCBhbmQgdGhlIGxhdHRlciBvbmUgaXMgc3VpdGFibGUgZm9yIGFjY3VyYXRlIHpvb20gYnkgcGl4ZWxcbiAgICAgIC8vIChlLmcuLCBpbiBkYXRhWm9vbVNlbGVjdCkuIGB2YWx1ZVByb3BgIGNhbiBiZSBjYWxjdWxhdGVkIGZyb20gYHBlcmNlbnRQcm9wYCxcbiAgICAgIC8vIGJ1dCBpdCBpcyBhd2t3YXJkIHRoYXQgYHBlcmNlbnRQcm9wYCBjYW4gbm90IGJlIG9idGFpbmVkIGZyb20gYHZhbHVlUHJvcGBcbiAgICAgIC8vIGFjY3VyYXRlbHkgKGJlY2F1c2UgYWxsIG9mIHZhbHVlcyB0aGF0IGFyZSBvdmVyZmxvdyB0aGUgYGRhdGFFeHRlbnRgIHdpbGxcbiAgICAgIC8vIGJlIGNhbGN1bGF0ZWQgdG8gcGVyY2VudCAnMTAwJScpLiBTbyB3ZSBoYXZlIHRvIHVzZVxuICAgICAgLy8gYGRhdGFab29tLmdldFJhbmdlUHJvcE1vZGUoKWAgdG8gbWFyayB3aGljaCBwcm9wIGlzIHVzZWQuXG4gICAgICAvLyBgcmFuZ2VQcm9wTW9kZWAgaXMgdXBkYXRlZCBvbmx5IHdoZW4gc2V0T3B0aW9uIG9yIGRpc3BhdGNoQWN0aW9uLCBvdGhlcndpc2VcbiAgICAgIC8vIGl0IHJlbWFpbnMgaXRzIG9yaWdpbmFsIHZhbHVlLlxuXG4gICAgICBpZiAocmFuZ2VQcm9wTW9kZVtpZHhdID09PSAncGVyY2VudCcpIHtcbiAgICAgICAgaWYgKGJvdW5kUGVyY2VudCA9PSBudWxsKSB7XG4gICAgICAgICAgYm91bmRQZXJjZW50ID0gcGVyY2VudEV4dGVudFtpZHhdO1xuICAgICAgICB9IC8vIFVzZSBzY2FsZS5wYXJzZSB0byBtYXRoIHJvdW5kIGZvciBjYXRlZ29yeSBvciB0aW1lIGF4aXMuXG5cblxuICAgICAgICBib3VuZFZhbHVlID0gc2NhbGUucGFyc2UobnVtYmVyVXRpbC5saW5lYXJNYXAoYm91bmRQZXJjZW50LCBwZXJjZW50RXh0ZW50LCBkYXRhRXh0ZW50LCB0cnVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDYWxjdWxhdGluZyBgcGVyY2VudGAgZnJvbSBgdmFsdWVgIG1heSBiZSBub3QgYWNjdXJhdGUsIGJlY2F1c2VcbiAgICAgICAgLy8gVGhpcyBjYWxjdWxhdGlvbiBjYW4gbm90IGJlIGludmVyc2VkLCBiZWNhdXNlIGFsbCBvZiB2YWx1ZXMgdGhhdFxuICAgICAgICAvLyBhcmUgb3ZlcmZsb3cgdGhlIGBkYXRhRXh0ZW50YCB3aWxsIGJlIGNhbGN1bGF0ZWQgdG8gcGVyY2VudCAnMTAwJSdcbiAgICAgICAgYm91bmRQZXJjZW50ID0gbnVtYmVyVXRpbC5saW5lYXJNYXAoYm91bmRWYWx1ZSwgZGF0YUV4dGVudCwgcGVyY2VudEV4dGVudCwgdHJ1ZSk7XG4gICAgICB9IC8vIHZhbHVlV2luZG93W2lkeF0gPSByb3VuZChib3VuZFZhbHVlKTtcbiAgICAgIC8vIHBlcmNlbnRXaW5kb3dbaWR4XSA9IHJvdW5kKGJvdW5kUGVyY2VudCk7XG5cblxuICAgICAgdmFsdWVXaW5kb3dbaWR4XSA9IGJvdW5kVmFsdWU7XG4gICAgICBwZXJjZW50V2luZG93W2lkeF0gPSBib3VuZFBlcmNlbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlV2luZG93OiBhc2ModmFsdWVXaW5kb3cpLFxuICAgICAgcGVyY2VudFdpbmRvdzogYXNjKHBlcmNlbnRXaW5kb3cpXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogTm90aWNlOiByZXNldCBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUgc2VyaWVzLnJlc3RvcmVEYXRhKCkgY2FsbGVkLFxuICAgKiBzbyBpdCBpcyByZWNvbW1hbmRlZCB0byBiZSBjYWxsZWQgaW4gXCJwcm9jZXNzIHN0YWdlXCIgYnV0IG5vdCBcIm1vZGVsIGluaXRcbiAgICogc3RhZ2VcIi5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgIGlmIChkYXRhWm9vbU1vZGVsICE9PSB0aGlzLl9kYXRhWm9vbU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDdWxjdWxhdGUgZGF0YSB3aW5kb3cgYW5kIGRhdGEgZXh0ZW50LCBhbmQgcmVjb3JkIHRoZW0uXG5cblxuICAgIHRoaXMuX2RhdGFFeHRlbnQgPSBjYWxjdWxhdGVEYXRhRXh0ZW50KHRoaXMsIHRoaXMuX2RpbU5hbWUsIHRoaXMuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCkpO1xuICAgIHZhciBkYXRhV2luZG93ID0gdGhpcy5jYWxjdWxhdGVEYXRhV2luZG93KGRhdGFab29tTW9kZWwub3B0aW9uKTtcbiAgICB0aGlzLl92YWx1ZVdpbmRvdyA9IGRhdGFXaW5kb3cudmFsdWVXaW5kb3c7XG4gICAgdGhpcy5fcGVyY2VudFdpbmRvdyA9IGRhdGFXaW5kb3cucGVyY2VudFdpbmRvdztcbiAgICBzZXRNaW5NYXhTcGFuKHRoaXMpOyAvLyBVcGRhdGUgYXhpcyBzZXR0aW5nIHRoZW4uXG5cbiAgICBzZXRBeGlzTW9kZWwodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfSBkYXRhWm9vbU1vZGVsXG4gICAqL1xuICByZXN0b3JlOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgIGlmIChkYXRhWm9vbU1vZGVsICE9PSB0aGlzLl9kYXRhWm9vbU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWVXaW5kb3cgPSB0aGlzLl9wZXJjZW50V2luZG93ID0gbnVsbDtcbiAgICBzZXRBeGlzTW9kZWwodGhpcywgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfSBkYXRhWm9vbU1vZGVsXG4gICAqL1xuICBmaWx0ZXJEYXRhOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgIGlmIChkYXRhWm9vbU1vZGVsICE9PSB0aGlzLl9kYXRhWm9vbU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF4aXNEaW0gPSB0aGlzLl9kaW1OYW1lO1xuICAgIHZhciBzZXJpZXNNb2RlbHMgPSB0aGlzLmdldFRhcmdldFNlcmllc01vZGVscygpO1xuICAgIHZhciBmaWx0ZXJNb2RlID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2ZpbHRlck1vZGUnKTtcbiAgICB2YXIgdmFsdWVXaW5kb3cgPSB0aGlzLl92YWx1ZVdpbmRvdztcblxuICAgIGlmIChmaWx0ZXJNb2RlID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZJWE1FXG4gICAgLy8gVG9vbGJveCBtYXkgaGFzIGRhdGFab29tIGluamVjdGVkLiBBbmQgaWYgdGhlcmUgYXJlIHN0YWNrZWQgYmFyIGNoYXJ0XG4gICAgLy8gd2l0aCBOYU4gZGF0YSwgTmFOIHdpbGwgYmUgZmlsdGVyZWQgYW5kIHN0YWNrIHdpbGwgYmUgd3JvbmcuXG4gICAgLy8gU28gd2UgbmVlZCB0byBmb3JjZSB0aGUgbW9kZSB0byBiZSBzZXQgZW1wdHkuXG4gICAgLy8gSW4gZmVjdCwgaXQgaXMgbm90IGEgYmlnIGRlYWwgdGhhdCBkbyBub3Qgc3VwcG9ydCBmaWx0ZXJNb2RlLSdmaWx0ZXInXG4gICAgLy8gd2hlbiB1c2luZyB0b29sYm94I2RhdGFab29tLCB1dGlsbCB0b29sdGlwI2RhdGFab29tIHN1cHBvcnQgXCJzaW5nbGUgYXhpc1xuICAgIC8vIHNlbGVjdGlvblwiIHNvbWUgZGF5LCB3aGljaCBtaWdodCBuZWVkIFwiYWRhcHQgdG8gZGF0YSBleHRlbnQgb24gdGhlXG4gICAgLy8gb3RoZXJBeGlzXCIsIHdoaWNoIGlzIGRpc2FibGVkIGJ5IGZpbHRlck1vZGUtJ2VtcHR5Jy5cblxuXG4gICAgdmFyIG90aGVyQXhpc01vZGVsID0gdGhpcy5nZXRPdGhlckF4aXNNb2RlbCgpO1xuXG4gICAgaWYgKGRhdGFab29tTW9kZWwuZ2V0KCckZnJvbVRvb2xib3gnKSAmJiBvdGhlckF4aXNNb2RlbCAmJiBvdGhlckF4aXNNb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgZmlsdGVyTW9kZSA9ICdlbXB0eSc7XG4gICAgfSAvLyBQcm9jZXNzIHNlcmllcyBkYXRhXG5cblxuICAgIGVhY2goc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIGRhdGFEaW1zID0gc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0oYXhpc0RpbSk7XG5cbiAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnd2Vha0ZpbHRlcicpIHtcbiAgICAgICAgc2VyaWVzRGF0YSAmJiBzZXJpZXNEYXRhLmZpbHRlclNlbGYoZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgIHZhciBsZWZ0T3V0O1xuICAgICAgICAgIHZhciByaWdodE91dDtcbiAgICAgICAgICB2YXIgaGFzVmFsdWU7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFEaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZXJpZXNEYXRhLmdldChkYXRhRGltc1tpXSwgZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciB0aGlzSGFzVmFsdWUgPSAhaXNOYU4odmFsdWUpO1xuICAgICAgICAgICAgdmFyIHRoaXNMZWZ0T3V0ID0gdmFsdWUgPCB2YWx1ZVdpbmRvd1swXTtcbiAgICAgICAgICAgIHZhciB0aGlzUmlnaHRPdXQgPSB2YWx1ZSA+IHZhbHVlV2luZG93WzFdO1xuXG4gICAgICAgICAgICBpZiAodGhpc0hhc1ZhbHVlICYmICF0aGlzTGVmdE91dCAmJiAhdGhpc1JpZ2h0T3V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzSGFzVmFsdWUgJiYgKGhhc1ZhbHVlID0gdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzTGVmdE91dCAmJiAobGVmdE91dCA9IHRydWUpO1xuICAgICAgICAgICAgdGhpc1JpZ2h0T3V0ICYmIChyaWdodE91dCA9IHRydWUpO1xuICAgICAgICAgIH0gLy8gSWYgYm90aCBsZWZ0IG91dCBhbmQgcmlnaHQgb3V0LCBkbyBub3QgZmlsdGVyLlxuXG5cbiAgICAgICAgICByZXR1cm4gaGFzVmFsdWUgJiYgbGVmdE91dCAmJiByaWdodE91dDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpZXNEYXRhICYmIGVhY2goZGF0YURpbXMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwuc2V0RGF0YShzZXJpZXNEYXRhLm1hcChkaW0sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gIWlzSW5XaW5kb3codmFsdWUpID8gTmFOIDogdmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcmllc0RhdGEuZmlsdGVyU2VsZihkaW0sIGlzSW5XaW5kb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpc0luV2luZG93KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gdmFsdWVXaW5kb3dbMF0gJiYgdmFsdWUgPD0gdmFsdWVXaW5kb3dbMV07XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVEYXRhRXh0ZW50KGF4aXNQcm94eSwgYXhpc0RpbSwgc2VyaWVzTW9kZWxzKSB7XG4gIHZhciBkYXRhRXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIHNlcmllc0RhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG5cbiAgICBpZiAoc2VyaWVzRGF0YSkge1xuICAgICAgZWFjaChzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShheGlzRGltKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICB2YXIgc2VyaWVzRXh0ZW50ID0gc2VyaWVzRGF0YS5nZXREYXRhRXh0ZW50KGRpbSk7XG4gICAgICAgIHNlcmllc0V4dGVudFswXSA8IGRhdGFFeHRlbnRbMF0gJiYgKGRhdGFFeHRlbnRbMF0gPSBzZXJpZXNFeHRlbnRbMF0pO1xuICAgICAgICBzZXJpZXNFeHRlbnRbMV0gPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhRXh0ZW50WzFdID0gc2VyaWVzRXh0ZW50WzFdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRhdGFFeHRlbnRbMV0gPCBkYXRhRXh0ZW50WzBdKSB7XG4gICAgZGF0YUV4dGVudCA9IFtOYU4sIE5hTl07XG4gIH0gLy8gSXQgaXMgaW1wb3J0YW50IHRvIGdldCBcImNvbnNpc3RlbnRcIiBleHRlbnQgd2hlbiBtb3JlIHRoZW4gb25lIGF4ZXMgaXNcbiAgLy8gY29udHJvbGxlZCBieSBhIGBkYXRhWm9vbWAsIG90aGVyd2lzZSB0aG9zZSBheGVzIHdpbGwgbm90IGJlIHN5bmNocm9uaXplZFxuICAvLyB3aGVuIHpvb21pbmcuIEJ1dCBpdCBpcyBkaWZmaWN1bHQgdG8ga25vdyB3aGF0IGlzIFwiY29uc2lzdGVudFwiLCBjb25zaWRlcmluZ1xuICAvLyBheGVzIGhhdmUgZGlmZmVyZW50IHR5cGUgb3IgZXZlbiBkaWZmZXJlbnQgbWVhbmluZ3MgKEZvciBleGFtcGxlLCB0d29cbiAgLy8gdGltZSBheGVzIGFyZSB1c2VkIHRvIGNvbXBhcmUgZGF0YSBvZiB0aGUgc2FtZSBkYXRlIGluIGRpZmZlcmVudCB5ZWFycykuXG4gIC8vIFNvIGJhc2ljYWxseSBkYXRhWm9vbSBqdXN0IG9idGFpbnMgZXh0ZW50IGJ5IHNlcmllcy5kYXRhIChpbiBjYXRlZ29yeSBheGlzXG4gIC8vIGV4dGVudCBjYW4gYmUgb2J0YWluZWQgZnJvbSBheGlzLmRhdGEpLlxuICAvLyBOZXZlcnRoZWxlc3MsIHVzZXIgY2FuIHNldCBtaW4vbWF4L3NjYWxlIG9uIGF4ZXMgdG8gbWFrZSBleHRlbnQgb2YgYXhlc1xuICAvLyBjb25zaXN0ZW50LlxuXG5cbiAgZml4RXh0ZW50QnlBeGlzKGF4aXNQcm94eSwgZGF0YUV4dGVudCk7XG4gIHJldHVybiBkYXRhRXh0ZW50O1xufVxuXG5mdW5jdGlvbiBmaXhFeHRlbnRCeUF4aXMoYXhpc1Byb3h5LCBkYXRhRXh0ZW50KSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzUHJveHkuZ2V0QXhpc01vZGVsKCk7XG4gIHZhciBtaW4gPSBheGlzTW9kZWwuZ2V0TWluKHRydWUpOyAvLyBGb3IgY2F0ZWdvcnkgYXhpcywgaWYgbWluL21heC9zY2FsZSBhcmUgbm90IHNldCwgZXh0ZW50IGlzIGRldGVybWluZWRcbiAgLy8gYnkgYXhpcy5kYXRhIGJ5IGRlZmF1bHQuXG5cbiAgdmFyIGlzQ2F0ZWdvcnlBeGlzID0gYXhpc01vZGVsLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknO1xuICB2YXIgYXhpc0RhdGFMZW4gPSBpc0NhdGVnb3J5QXhpcyAmJiAoYXhpc01vZGVsLmdldCgnZGF0YScpIHx8IFtdKS5sZW5ndGg7XG5cbiAgaWYgKG1pbiAhPSBudWxsICYmIG1pbiAhPT0gJ2RhdGFNaW4nICYmIHR5cGVvZiBtaW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICBkYXRhRXh0ZW50WzBdID0gbWluO1xuICB9IGVsc2UgaWYgKGlzQ2F0ZWdvcnlBeGlzKSB7XG4gICAgZGF0YUV4dGVudFswXSA9IGF4aXNEYXRhTGVuID4gMCA/IDAgOiBOYU47XG4gIH1cblxuICB2YXIgbWF4ID0gYXhpc01vZGVsLmdldE1heCh0cnVlKTtcblxuICBpZiAobWF4ICE9IG51bGwgJiYgbWF4ICE9PSAnZGF0YU1heCcgJiYgdHlwZW9mIG1heCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGFFeHRlbnRbMV0gPSBtYXg7XG4gIH0gZWxzZSBpZiAoaXNDYXRlZ29yeUF4aXMpIHtcbiAgICBkYXRhRXh0ZW50WzFdID0gYXhpc0RhdGFMZW4gPiAwID8gYXhpc0RhdGFMZW4gLSAxIDogTmFOO1xuICB9XG5cbiAgaWYgKCFheGlzTW9kZWwuZ2V0KCdzY2FsZScsIHRydWUpKSB7XG4gICAgZGF0YUV4dGVudFswXSA+IDAgJiYgKGRhdGFFeHRlbnRbMF0gPSAwKTtcbiAgICBkYXRhRXh0ZW50WzFdIDwgMCAmJiAoZGF0YUV4dGVudFsxXSA9IDApO1xuICB9IC8vIEZvciB2YWx1ZSBheGlzLCBpZiBtaW4vbWF4L3NjYWxlIGFyZSBub3Qgc2V0LCB3ZSBqdXN0IHVzZSB0aGUgZXh0ZW50IG9idGFpbmVkXG4gIC8vIGJ5IHNlcmllcyBkYXRhLCB3aGljaCBtYXkgYmUgYSBsaXR0bGUgZGlmZmVyZW50IGZyb20gdGhlIGV4dGVudCBjYWxjdWxhdGVkIGJ5XG4gIC8vIGBheGlzSGVscGVyLmdldFNjYWxlRXh0ZW50YC4gQnV0IHRoZSBkaWZmZXJlbnQganVzdCBhZmZlY3RzIHRoZSBleHBlcmllbmNlIGFcbiAgLy8gbGl0dGxlIHdoZW4gem9vbWluZy4gU28gaXQgd2lsbCBub3QgYmUgZml4ZWQgdW50aWwgc29tZSB1c2VycyByZXF1aXJlIGl0IHN0cm9uZ2x5LlxuXG5cbiAgcmV0dXJuIGRhdGFFeHRlbnQ7XG59XG5cbmZ1bmN0aW9uIHNldEF4aXNNb2RlbChheGlzUHJveHksIGlzUmVzdG9yZSkge1xuICB2YXIgYXhpc01vZGVsID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuICB2YXIgcGVyY2VudFdpbmRvdyA9IGF4aXNQcm94eS5fcGVyY2VudFdpbmRvdztcbiAgdmFyIHZhbHVlV2luZG93ID0gYXhpc1Byb3h5Ll92YWx1ZVdpbmRvdztcblxuICBpZiAoIXBlcmNlbnRXaW5kb3cpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gWzAsIDUwMF06IGFyYml0cmFyeSB2YWx1ZSwgZ3Vlc3MgYXhpcyBleHRlbnQuXG5cblxuICB2YXIgcHJlY2lzaW9uID0gbnVtYmVyVXRpbC5nZXRQaXhlbFByZWNpc2lvbih2YWx1ZVdpbmRvdywgWzAsIDUwMF0pO1xuICBwcmVjaXNpb24gPSBNYXRoLm1pbihwcmVjaXNpb24sIDIwKTsgLy8gaXNSZXN0b3JlIG9yIGlzRnVsbFxuXG4gIHZhciB1c2VPcmlnaW4gPSBpc1Jlc3RvcmUgfHwgcGVyY2VudFdpbmRvd1swXSA9PT0gMCAmJiBwZXJjZW50V2luZG93WzFdID09PSAxMDA7XG4gIGF4aXNNb2RlbC5zZXRSYW5nZSh1c2VPcmlnaW4gPyBudWxsIDogK3ZhbHVlV2luZG93WzBdLnRvRml4ZWQocHJlY2lzaW9uKSwgdXNlT3JpZ2luID8gbnVsbCA6ICt2YWx1ZVdpbmRvd1sxXS50b0ZpeGVkKHByZWNpc2lvbikpO1xufVxuXG5mdW5jdGlvbiBzZXRNaW5NYXhTcGFuKGF4aXNQcm94eSkge1xuICB2YXIgbWluTWF4U3BhbiA9IGF4aXNQcm94eS5fbWluTWF4U3BhbiA9IHt9O1xuICB2YXIgZGF0YVpvb21Nb2RlbCA9IGF4aXNQcm94eS5fZGF0YVpvb21Nb2RlbDtcbiAgZWFjaChbJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKG1pbk1heCkge1xuICAgIG1pbk1heFNwYW5bbWluTWF4ICsgJ1NwYW4nXSA9IGRhdGFab29tTW9kZWwuZ2V0KG1pbk1heCArICdTcGFuJyk7IC8vIG1pblZhbHVlU3BhbiBhbmQgbWF4VmFsdWVTcGFuIGhhcyBoaWdoZXIgcHJpb3JpdHkgdGhhbiBtaW5TcGFuIGFuZCBtYXhTcGFuXG5cbiAgICB2YXIgdmFsdWVTcGFuID0gZGF0YVpvb21Nb2RlbC5nZXQobWluTWF4ICsgJ1ZhbHVlU3BhbicpO1xuXG4gICAgaWYgKHZhbHVlU3BhbiAhPSBudWxsKSB7XG4gICAgICBtaW5NYXhTcGFuW21pbk1heCArICdWYWx1ZVNwYW4nXSA9IHZhbHVlU3BhbjtcbiAgICAgIHZhbHVlU3BhbiA9IGF4aXNQcm94eS5nZXRBeGlzTW9kZWwoKS5heGlzLnNjYWxlLnBhcnNlKHZhbHVlU3Bhbik7XG5cbiAgICAgIGlmICh2YWx1ZVNwYW4gIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGF0YUV4dGVudCA9IGF4aXNQcm94eS5fZGF0YUV4dGVudDtcbiAgICAgICAgbWluTWF4U3BhblttaW5NYXggKyAnU3BhbiddID0gbnVtYmVyVXRpbC5saW5lYXJNYXAoZGF0YUV4dGVudFswXSArIHZhbHVlU3BhbiwgZGF0YUV4dGVudCwgWzAsIDEwMF0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbnZhciBfZGVmYXVsdCA9IEF4aXNQcm94eTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0F4aXNQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gMjgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIERhdGFab29tTW9kZWwgPSByZXF1aXJlKFwiLi9EYXRhWm9vbU1vZGVsXCIpO1xuXG52YXIgU2xpZGVyWm9vbU1vZGVsID0gRGF0YVpvb21Nb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnZGF0YVpvb20uc2xpZGVyJyxcbiAgbGF5b3V0TW9kZTogJ2JveCcsXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICBzaG93OiB0cnVlLFxuICAgIC8vIHBoID0+IHBsYWNlaG9sZGVyLiBVc2luZyBwbGFjZWhvZGVyIGhlcmUgYmVjYXVzZVxuICAgIC8vIGRlYXVsdCB2YWx1ZSBjYW4gb25seSBiZSBkcml2ZWQgaW4gdmlldyBzdGFnZS5cbiAgICByaWdodDogJ3BoJyxcbiAgICAvLyBEZWZhdWx0IGFsaWduIHRvIGdyaWQgcmVjdC5cbiAgICB0b3A6ICdwaCcsXG4gICAgLy8gRGVmYXVsdCBhbGlnbiB0byBncmlkIHJlY3QuXG4gICAgd2lkdGg6ICdwaCcsXG4gICAgLy8gRGVmYXVsdCBhbGlnbiB0byBncmlkIHJlY3QuXG4gICAgaGVpZ2h0OiAncGgnLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIGxlZnQ6IG51bGwsXG4gICAgLy8gRGVmYXVsdCBhbGlnbiB0byBncmlkIHJlY3QuXG4gICAgYm90dG9tOiBudWxsLFxuICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoNDcsNjksODQsMCknLFxuICAgIC8vIEJhY2tncm91bmQgb2Ygc2xpZGVyIHpvb20gY29tcG9uZW50LlxuICAgIC8vIGRhdGFCYWNrZ3JvdW5kQ29sb3I6ICcjZGRkJywgICAgICAgICAvLyBCYWNrZ3JvdW5kIGNvb3Igb2YgZGF0YSBzaGFkb3cgYW5kIGJvcmRlciBvZiBib3gsXG4gICAgLy8gaGlnaGVzdCBwcmlvcml0eSwgcmVtYWluIGZvciBjb21wYXRpYmlsaXR5IG9mXG4gICAgLy8gcHJldmlvdXMgdmVyc2lvbiwgYnV0IG5vdCByZWNvbW1lbmRlZCBhbnkgbW9yZS5cbiAgICBkYXRhQmFja2dyb3VuZDoge1xuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzJmNDU1NCcsXG4gICAgICAgIHdpZHRoOiAwLjUsXG4gICAgICAgIG9wYWNpdHk6IDAuM1xuICAgICAgfSxcbiAgICAgIGFyZWFTdHlsZToge1xuICAgICAgICBjb2xvcjogJ3JnYmEoNDcsNjksODQsMC4zKScsXG4gICAgICAgIG9wYWNpdHk6IDAuM1xuICAgICAgfVxuICAgIH0sXG4gICAgYm9yZGVyQ29sb3I6ICcjZGRkJyxcbiAgICAvLyBib3JkZXIgY29sb3Igb2YgdGhlIGJveC4gRm9yIGNvbXBhdGliaWxpdHksXG4gICAgLy8gaWYgZGF0YUJhY2tncm91bmRDb2xvciBpcyBzZXQsIGJvcmRlckNvbG9yXG4gICAgLy8gaXMgaWdub3JlZC5cbiAgICBmaWxsZXJDb2xvcjogJ3JnYmEoMTY3LDE4MywyMDQsMC40KScsXG4gICAgLy8gQ29sb3Igb2Ygc2VsZWN0ZWQgYXJlYS5cbiAgICAvLyBoYW5kbGVDb2xvcjogJ3JnYmEoODksMTcwLDIxNiwwLjk1KScsICAgICAvLyBDb2xvciBvZiBoYW5kbGUuXG4gICAgLy8gaGFuZGxlSWNvbjogJ3BhdGg6Ly9NNC45LDE3LjhjMC0xLjQsNC41LTEwLjUsNS41LTEyLjRjMC0wLjEsMC42LTEuMSwwLjktMS4xYzAuNCwwLDAuOSwxLDAuOSwxLjFjMS4xLDIuMiw1LjQsMTEsNS40LDEyLjR2MTcuOGMwLDEuNS0wLjYsMi4xLTEuMywyLjFINi4xYy0wLjcsMC0xLjMtMC42LTEuMy0yLjFWMTcuOHonLFxuICAgIGhhbmRsZUljb246ICdNOC4yLDEzLjZWMy45SDYuM3Y5LjdIMy4xdjE0LjloMy4zdjkuN2gxLjh2LTkuN2gzLjNWMTMuNkg4LjJ6IE05LjcsMjQuNEg0Ljh2LTEuNGg0LjlWMjQuNHogTTkuNywxOS4xSDQuOHYtMS40aDQuOVYxOS4xeicsXG4gICAgLy8gUGVyY2VudCBvZiB0aGUgc2xpZGVyIGhlaWdodFxuICAgIGhhbmRsZVNpemU6ICcxMDAlJyxcbiAgICBoYW5kbGVTdHlsZToge1xuICAgICAgY29sb3I6ICcjYTdiN2NjJ1xuICAgIH0sXG4gICAgbGFiZWxQcmVjaXNpb246IG51bGwsXG4gICAgbGFiZWxGb3JtYXR0ZXI6IG51bGwsXG4gICAgc2hvd0RldGFpbDogdHJ1ZSxcbiAgICBzaG93RGF0YVNoYWRvdzogJ2F1dG8nLFxuICAgIC8vIERlZmF1bHQgYXV0byBkZWNpc2lvbi5cbiAgICByZWFsdGltZTogdHJ1ZSxcbiAgICB6b29tTG9jazogZmFsc2UsXG4gICAgLy8gV2hldGhlciBkaXNhYmxlIHpvb20uXG4gICAgdGV4dFN0eWxlOiB7XG4gICAgICBjb2xvcjogJyMzMzMnXG4gICAgfVxuICB9XG59KTtcbnZhciBfZGVmYXVsdCA9IFNsaWRlclpvb21Nb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NsaWRlclpvb21Nb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMjg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBldmVudFRvb2wgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9ldmVudFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgdGhyb3R0bGUgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC90aHJvdHRsZVwiKTtcblxudmFyIERhdGFab29tVmlldyA9IHJlcXVpcmUoXCIuL0RhdGFab29tVmlld1wiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBsYXlvdXQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBzbGlkZXJNb3ZlID0gcmVxdWlyZShcIi4uL2hlbHBlci9zbGlkZXJNb3ZlXCIpO1xuXG52YXIgUmVjdCA9IGdyYXBoaWMuUmVjdDtcbnZhciBsaW5lYXJNYXAgPSBudW1iZXJVdGlsLmxpbmVhck1hcDtcbnZhciBhc2MgPSBudW1iZXJVdGlsLmFzYztcbnZhciBiaW5kID0genJVdGlsLmJpbmQ7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoOyAvLyBDb25zdGFudHNcblxudmFyIERFRkFVTFRfTE9DQVRJT05fRURHRV9HQVAgPSA3O1xudmFyIERFRkFVTFRfRlJBTUVfQk9SREVSX1dJRFRIID0gMTtcbnZhciBERUZBVUxUX0ZJTExFUl9TSVpFID0gMzA7XG52YXIgSE9SSVpPTlRBTCA9ICdob3Jpem9udGFsJztcbnZhciBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCc7XG52YXIgTEFCRUxfR0FQID0gNTtcbnZhciBTSE9XX0RBVEFfU0hBRE9XX1NFUklFU19UWVBFID0gWydsaW5lJywgJ2JhcicsICdjYW5kbGVzdGljaycsICdzY2F0dGVyJ107XG52YXIgU2xpZGVyWm9vbVZpZXcgPSBEYXRhWm9vbVZpZXcuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFab29tLnNsaWRlcicsXG4gIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZGlzcGxheWFibGVzID0ge307XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gICAgdGhpcy5fb3JpZW50O1xuICAgIC8qKlxuICAgICAqIFswLCAxMDBdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX3JhbmdlO1xuICAgIC8qKlxuICAgICAqIFtjb29yZCBvZiB0aGUgZmlyc3QgaGFuZGxlLCBjb29yZCBvZiB0aGUgc2Vjb25kIGhhbmRsZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5faGFuZGxlRW5kcztcbiAgICAvKipcbiAgICAgKiBbbGVuZ3RoLCB0aGlja11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cblxuICAgIHRoaXMuX3NpemU7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5faGFuZGxlV2lkdGg7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5faGFuZGxlSGVpZ2h0O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLl9sb2NhdGlvbjtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fZHJhZ2dpbmc7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2RhdGFTaGFkb3dJbmZvO1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIFNsaWRlclpvb21WaWV3LnN1cGVyQXBwbHkodGhpcywgJ3JlbmRlcicsIGFyZ3VtZW50cyk7XG4gICAgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUodGhpcywgJ19kaXNwYXRjaFpvb21BY3Rpb24nLCB0aGlzLmRhdGFab29tTW9kZWwuZ2V0KCd0aHJvdHRsZScpLCAnZml4UmF0ZScpO1xuICAgIHRoaXMuX29yaWVudCA9IGRhdGFab29tTW9kZWwuZ2V0KCdvcmllbnQnKTtcblxuICAgIGlmICh0aGlzLmRhdGFab29tTW9kZWwuZ2V0KCdzaG93JykgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gTm90aWNlOiB0aGlzLl9yZXNldEludGVydmFsKCkgc2hvdWxkIG5vdCBiZSBleGVjdXRlZCB3aGVuIHBheWxvYWQudHlwZVxuICAgIC8vIGlzICdkYXRhWm9vbScsIG9yaWdpbiB0aGlzLl9yYW5nZSBzaG91bGQgYmUgbWFpbnRhaW5lZCwgb3RoZXJ3aXNlICdwYW4nXG4gICAgLy8gb3IgJ3pvb20nIGluZm8gd2lsbCBiZSBtaXNzZWQgYmVjYXVzZSBvZiAndGhyb3R0bGUnIG9mIHRoaXMuZGlzcGF0Y2hBY3Rpb24sXG5cblxuICAgIGlmICghcGF5bG9hZCB8fCBwYXlsb2FkLnR5cGUgIT09ICdkYXRhWm9vbScgfHwgcGF5bG9hZC5mcm9tICE9PSB0aGlzLnVpZCkge1xuICAgICAgdGhpcy5fYnVpbGRWaWV3KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlVmlldygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIFNsaWRlclpvb21WaWV3LnN1cGVyQXBwbHkodGhpcywgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XG4gICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaFpvb21BY3Rpb24nKTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgU2xpZGVyWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAnZGlzcG9zZScsIGFyZ3VtZW50cyk7XG4gICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaFpvb21BY3Rpb24nKTtcbiAgfSxcbiAgX2J1aWxkVmlldzogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHRoaXNHcm91cC5yZW1vdmVBbGwoKTtcblxuICAgIHRoaXMuX3Jlc2V0TG9jYXRpb24oKTtcblxuICAgIHRoaXMuX3Jlc2V0SW50ZXJ2YWwoKTtcblxuICAgIHZhciBiYXJHcm91cCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKCk7XG5cbiAgICB0aGlzLl9yZW5kZXJIYW5kbGUoKTtcblxuICAgIHRoaXMuX3JlbmRlckRhdGFTaGFkb3coKTtcblxuICAgIHRoaXNHcm91cC5hZGQoYmFyR3JvdXApO1xuXG4gICAgdGhpcy5fcG9zaXRpb25Hcm91cCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0TG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgYXBpID0gdGhpcy5hcGk7IC8vIElmIHNvbWUgb2YgeC95L3dpZHRoL2hlaWdodCBhcmUgbm90IHNwZWNpZmllZCxcbiAgICAvLyBhdXRvLWFkYXB0IGFjY29yZGluZyB0byB0YXJnZXQgZ3JpZC5cblxuICAgIHZhciBjb29yZFJlY3QgPSB0aGlzLl9maW5kQ29vcmRSZWN0KCk7XG5cbiAgICB2YXIgZWNTaXplID0ge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9OyAvLyBEZWZhdWx0IGFsaWduIGJ5IGNvb3JkaW5hdGUgc3lzdGVtIHJlY3QuXG5cbiAgICB2YXIgcG9zaXRpb25JbmZvID0gdGhpcy5fb3JpZW50ID09PSBIT1JJWk9OVEFMID8ge1xuICAgICAgLy8gV2h5IHVzaW5nICdyaWdodCcsIGJlY2F1c2UgcmlnaHQgc2hvdWxkIGJlIHVzZWQgaW4gdmVydGljYWwsXG4gICAgICAvLyBhbmQgaXQgaXMgYmV0dGVyIHRvIGJlIGNvbnNpc3RlbnQgZm9yIGRlYWxpbmcgd2l0aCBwb3NpdGlvbiBwYXJhbSBtZXJnZS5cbiAgICAgIHJpZ2h0OiBlY1NpemUud2lkdGggLSBjb29yZFJlY3QueCAtIGNvb3JkUmVjdC53aWR0aCxcbiAgICAgIHRvcDogZWNTaXplLmhlaWdodCAtIERFRkFVTFRfRklMTEVSX1NJWkUgLSBERUZBVUxUX0xPQ0FUSU9OX0VER0VfR0FQLFxuICAgICAgd2lkdGg6IGNvb3JkUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogREVGQVVMVF9GSUxMRVJfU0laRVxuICAgIH0gOiB7XG4gICAgICAvLyB2ZXJ0aWNhbFxuICAgICAgcmlnaHQ6IERFRkFVTFRfTE9DQVRJT05fRURHRV9HQVAsXG4gICAgICB0b3A6IGNvb3JkUmVjdC55LFxuICAgICAgd2lkdGg6IERFRkFVTFRfRklMTEVSX1NJWkUsXG4gICAgICBoZWlnaHQ6IGNvb3JkUmVjdC5oZWlnaHRcbiAgICB9OyAvLyBEbyBub3Qgd3JpdGUgYmFjayB0byBvcHRpb24gYW5kIHJlcGxhY2UgdmFsdWUgJ3BoJywgYmVjYXVzZVxuICAgIC8vIHRoZSAncGgnIHZhbHVlIHNob3VsZCBiZSByZWNhbGN1bGF0ZWQgd2hlbiByZXNpemUuXG5cbiAgICB2YXIgbGF5b3V0UGFyYW1zID0gbGF5b3V0LmdldExheW91dFBhcmFtcyhkYXRhWm9vbU1vZGVsLm9wdGlvbik7IC8vIFJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuXG4gICAgenJVdGlsLmVhY2goWydyaWdodCcsICd0b3AnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobGF5b3V0UGFyYW1zW25hbWVdID09PSAncGgnKSB7XG4gICAgICAgIGxheW91dFBhcmFtc1tuYW1lXSA9IHBvc2l0aW9uSW5mb1tuYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KGxheW91dFBhcmFtcywgZWNTaXplLCBkYXRhWm9vbU1vZGVsLnBhZGRpbmcpO1xuICAgIHRoaXMuX2xvY2F0aW9uID0ge1xuICAgICAgeDogbGF5b3V0UmVjdC54LFxuICAgICAgeTogbGF5b3V0UmVjdC55XG4gICAgfTtcbiAgICB0aGlzLl9zaXplID0gW2xheW91dFJlY3Qud2lkdGgsIGxheW91dFJlY3QuaGVpZ2h0XTtcbiAgICB0aGlzLl9vcmllbnQgPT09IFZFUlRJQ0FMICYmIHRoaXMuX3NpemUucmV2ZXJzZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Bvc2l0aW9uR3JvdXA6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhpc0dyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLl9sb2NhdGlvbjtcbiAgICB2YXIgb3JpZW50ID0gdGhpcy5fb3JpZW50OyAvLyBKdXN0IHVzZSB0aGUgZmlyc3QgYXhpcyB0byBkZXRlcm1pbmUgbWFwcGluZy5cblxuICAgIHZhciB0YXJnZXRBeGlzTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWwuZ2V0Rmlyc3RUYXJnZXRBeGlzTW9kZWwoKTtcbiAgICB2YXIgaW52ZXJzZSA9IHRhcmdldEF4aXNNb2RlbCAmJiB0YXJnZXRBeGlzTW9kZWwuZ2V0KCdpbnZlcnNlJyk7XG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwO1xuICAgIHZhciBvdGhlckF4aXNJbnZlcnNlID0gKHRoaXMuX2RhdGFTaGFkb3dJbmZvIHx8IHt9KS5vdGhlckF4aXNJbnZlcnNlOyAvLyBUcmFuc2Zvcm0gYmFyR3JvdXAuXG5cbiAgICBiYXJHcm91cC5hdHRyKG9yaWVudCA9PT0gSE9SSVpPTlRBTCAmJiAhaW52ZXJzZSA/IHtcbiAgICAgIHNjYWxlOiBvdGhlckF4aXNJbnZlcnNlID8gWzEsIDFdIDogWzEsIC0xXVxuICAgIH0gOiBvcmllbnQgPT09IEhPUklaT05UQUwgJiYgaW52ZXJzZSA/IHtcbiAgICAgIHNjYWxlOiBvdGhlckF4aXNJbnZlcnNlID8gWy0xLCAxXSA6IFstMSwgLTFdXG4gICAgfSA6IG9yaWVudCA9PT0gVkVSVElDQUwgJiYgIWludmVyc2UgPyB7XG4gICAgICBzY2FsZTogb3RoZXJBeGlzSW52ZXJzZSA/IFsxLCAtMV0gOiBbMSwgMV0sXG4gICAgICByb3RhdGlvbjogTWF0aC5QSSAvIDIgLy8gRG9udCB1c2UgTWF0aC5QSSwgY29uc2lkZXJpbmcgc2hhZG93IGRpcmVjdGlvbi5cblxuICAgIH0gOiB7XG4gICAgICBzY2FsZTogb3RoZXJBeGlzSW52ZXJzZSA/IFstMSwgLTFdIDogWy0xLCAxXSxcbiAgICAgIHJvdGF0aW9uOiBNYXRoLlBJIC8gMlxuICAgIH0pOyAvLyBQb3NpdGlvbiBiYXJHcm91cFxuXG4gICAgdmFyIHJlY3QgPSB0aGlzR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KFtiYXJHcm91cF0pO1xuICAgIHRoaXNHcm91cC5hdHRyKCdwb3NpdGlvbicsIFtsb2NhdGlvbi54IC0gcmVjdC54LCBsb2NhdGlvbi55IC0gcmVjdC55XSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Vmlld0V4dGVudDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbMCwgdGhpcy5fc2l6ZVswXV07XG4gIH0sXG4gIF9yZW5kZXJCYWNrZ3JvdW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgIHZhciBiYXJHcm91cCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cDtcbiAgICBiYXJHcm91cC5hZGQobmV3IFJlY3Qoe1xuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgc2hhcGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHNpemVbMF0sXG4gICAgICAgIGhlaWdodDogc2l6ZVsxXVxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGZpbGw6IGRhdGFab29tTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKVxuICAgICAgfSxcbiAgICAgIHoyOiAtNDBcbiAgICB9KSk7IC8vIENsaWNrIHBhbmVsLCBvdmVyIHNoYWRvdywgYmVsb3cgaGFuZGxlcy5cblxuICAgIGJhckdyb3VwLmFkZChuZXcgUmVjdCh7XG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHoyOiAwLFxuICAgICAgb25jbGljazogenJVdGlsLmJpbmQodGhpcy5fb25DbGlja1BhbmVsQ2xpY2ssIHRoaXMpXG4gICAgfSkpO1xuICB9LFxuICBfcmVuZGVyRGF0YVNoYWRvdzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmZvID0gdGhpcy5fZGF0YVNoYWRvd0luZm8gPSB0aGlzLl9wcmVwYXJlRGF0YVNoYWRvd0luZm8oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBpbmZvLnNlcmllcztcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldFJhd0RhdGEoKTtcbiAgICB2YXIgb3RoZXJEaW0gPSBzZXJpZXNNb2RlbC5nZXRTaGFkb3dEaW0gPyBzZXJpZXNNb2RlbC5nZXRTaGFkb3dEaW0oKSAvLyBAc2VlIGNhbmRsZXN0aWNrXG4gICAgOiBpbmZvLm90aGVyRGltO1xuXG4gICAgaWYgKG90aGVyRGltID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3RoZXJEYXRhRXh0ZW50ID0gZGF0YS5nZXREYXRhRXh0ZW50KG90aGVyRGltKTsgLy8gTmljZSBleHRlbnQuXG5cbiAgICB2YXIgb3RoZXJPZmZzZXQgPSAob3RoZXJEYXRhRXh0ZW50WzFdIC0gb3RoZXJEYXRhRXh0ZW50WzBdKSAqIDAuMztcbiAgICBvdGhlckRhdGFFeHRlbnQgPSBbb3RoZXJEYXRhRXh0ZW50WzBdIC0gb3RoZXJPZmZzZXQsIG90aGVyRGF0YUV4dGVudFsxXSArIG90aGVyT2Zmc2V0XTtcbiAgICB2YXIgb3RoZXJTaGFkb3dFeHRlbnQgPSBbMCwgc2l6ZVsxXV07XG4gICAgdmFyIHRoaXNTaGFkb3dFeHRlbnQgPSBbMCwgc2l6ZVswXV07XG4gICAgdmFyIGFyZWFQb2ludHMgPSBbW3NpemVbMF0sIDBdLCBbMCwgMF1dO1xuICAgIHZhciBsaW5lUG9pbnRzID0gW107XG4gICAgdmFyIHN0ZXAgPSB0aGlzU2hhZG93RXh0ZW50WzFdIC8gKGRhdGEuY291bnQoKSAtIDEpO1xuICAgIHZhciB0aGlzQ29vcmQgPSAwOyAvLyBPcHRpbWl6ZSBmb3IgbGFyZ2UgZGF0YSBzaGFkb3dcblxuICAgIHZhciBzdHJpZGUgPSBNYXRoLnJvdW5kKGRhdGEuY291bnQoKSAvIHNpemVbMF0pO1xuICAgIHZhciBsYXN0SXNFbXB0eTtcbiAgICBkYXRhLmVhY2goW290aGVyRGltXSwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKHN0cmlkZSA+IDAgJiYgaW5kZXggJSBzdHJpZGUpIHtcbiAgICAgICAgdGhpc0Nvb3JkICs9IHN0ZXA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRklYTUVcbiAgICAgIC8vIFNob3VsZCBjb25zaWRlciBheGlzLm1pbi9heGlzLm1heCB3aGVuIGRyYXdpbmcgZGF0YVNoYWRvdy5cbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyDlupTor6Xkvb/nlKjnu5/kuIDnmoTnqbrliKTmlq3vvJ/ov5jmmK/lnKhsaXN06YeM6L+b6KGM56m65Yik5pat77yfXG5cblxuICAgICAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJyc7IC8vIFNlZSAjNDIzNS5cblxuICAgICAgdmFyIG90aGVyQ29vcmQgPSBpc0VtcHR5ID8gMCA6IGxpbmVhck1hcCh2YWx1ZSwgb3RoZXJEYXRhRXh0ZW50LCBvdGhlclNoYWRvd0V4dGVudCwgdHJ1ZSk7IC8vIEF0dGVtcHQgdG8gZHJhdyBkYXRhIHNoYWRvdyBwcmVjaXNlbHkgd2hlbiB0aGVyZSBhcmUgZW1wdHkgdmFsdWUuXG5cbiAgICAgIGlmIChpc0VtcHR5ICYmICFsYXN0SXNFbXB0eSAmJiBpbmRleCkge1xuICAgICAgICBhcmVhUG9pbnRzLnB1c2goW2FyZWFQb2ludHNbYXJlYVBvaW50cy5sZW5ndGggLSAxXVswXSwgMF0pO1xuICAgICAgICBsaW5lUG9pbnRzLnB1c2goW2xpbmVQb2ludHNbbGluZVBvaW50cy5sZW5ndGggLSAxXVswXSwgMF0pO1xuICAgICAgfSBlbHNlIGlmICghaXNFbXB0eSAmJiBsYXN0SXNFbXB0eSkge1xuICAgICAgICBhcmVhUG9pbnRzLnB1c2goW3RoaXNDb29yZCwgMF0pO1xuICAgICAgICBsaW5lUG9pbnRzLnB1c2goW3RoaXNDb29yZCwgMF0pO1xuICAgICAgfVxuXG4gICAgICBhcmVhUG9pbnRzLnB1c2goW3RoaXNDb29yZCwgb3RoZXJDb29yZF0pO1xuICAgICAgbGluZVBvaW50cy5wdXNoKFt0aGlzQ29vcmQsIG90aGVyQ29vcmRdKTtcbiAgICAgIHRoaXNDb29yZCArPSBzdGVwO1xuICAgICAgbGFzdElzRW1wdHkgPSBpc0VtcHR5O1xuICAgIH0pO1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsOyAvLyB2YXIgZGF0YUJhY2tncm91bmRNb2RlbCA9IGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2RhdGFCYWNrZ3JvdW5kJyk7XG5cbiAgICB0aGlzLl9kaXNwbGF5YWJsZXMuYmFyR3JvdXAuYWRkKG5ldyBncmFwaGljLlBvbHlnb24oe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBhcmVhUG9pbnRzXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgIGZpbGw6IGRhdGFab29tTW9kZWwuZ2V0KCdkYXRhQmFja2dyb3VuZENvbG9yJylcbiAgICAgIH0sIGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2RhdGFCYWNrZ3JvdW5kLmFyZWFTdHlsZScpLmdldEFyZWFTdHlsZSgpKSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIHoyOiAtMjBcbiAgICB9KSk7XG5cbiAgICB0aGlzLl9kaXNwbGF5YWJsZXMuYmFyR3JvdXAuYWRkKG5ldyBncmFwaGljLlBvbHlsaW5lKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHBvaW50czogbGluZVBvaW50c1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiBkYXRhWm9vbU1vZGVsLmdldE1vZGVsKCdkYXRhQmFja2dyb3VuZC5saW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIHoyOiAtMTlcbiAgICB9KSk7XG4gIH0sXG4gIF9wcmVwYXJlRGF0YVNoYWRvd0luZm86IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgc2hvd0RhdGFTaGFkb3cgPSBkYXRhWm9vbU1vZGVsLmdldCgnc2hvd0RhdGFTaGFkb3cnKTtcblxuICAgIGlmIChzaG93RGF0YVNoYWRvdyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZpbmQgYSByZXByZXNlbnRhdGl2ZSBzZXJpZXMuXG5cblxuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMsIGF4aXNJbmRleCkge1xuICAgICAgdmFyIHNlcmllc01vZGVscyA9IGRhdGFab29tTW9kZWwuZ2V0QXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCkuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCk7XG4gICAgICB6clV0aWwuZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3dEYXRhU2hhZG93ICE9PSB0cnVlICYmIHpyVXRpbC5pbmRleE9mKFNIT1dfREFUQV9TSEFET1dfU0VSSUVTX1RZUEUsIHNlcmllc01vZGVsLmdldCgndHlwZScpKSA8IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhpc0F4aXMgPSBlY01vZGVsLmdldENvbXBvbmVudChkaW1OYW1lcy5heGlzLCBheGlzSW5kZXgpLmF4aXM7XG4gICAgICAgIHZhciBvdGhlckRpbSA9IGdldE90aGVyRGltKGRpbU5hbWVzLm5hbWUpO1xuICAgICAgICB2YXIgb3RoZXJBeGlzSW52ZXJzZTtcbiAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgICAgICBpZiAob3RoZXJEaW0gIT0gbnVsbCAmJiBjb29yZFN5cy5nZXRPdGhlckF4aXMpIHtcbiAgICAgICAgICBvdGhlckF4aXNJbnZlcnNlID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKHRoaXNBeGlzKS5pbnZlcnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIHRoaXNBeGlzOiB0aGlzQXhpcyxcbiAgICAgICAgICBzZXJpZXM6IHNlcmllc01vZGVsLFxuICAgICAgICAgIHRoaXNEaW06IGRpbU5hbWVzLm5hbWUsXG4gICAgICAgICAgb3RoZXJEaW06IG90aGVyRGltLFxuICAgICAgICAgIG90aGVyQXhpc0ludmVyc2U6IG90aGVyQXhpc0ludmVyc2VcbiAgICAgICAgfTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIF9yZW5kZXJIYW5kbGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGlzcGxheWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgdmFyIGhhbmRsZXMgPSBkaXNwbGF5Ymxlcy5oYW5kbGVzID0gW107XG4gICAgdmFyIGhhbmRsZUxhYmVscyA9IGRpc3BsYXlibGVzLmhhbmRsZUxhYmVscyA9IFtdO1xuICAgIHZhciBiYXJHcm91cCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cDtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgYmFyR3JvdXAuYWRkKGRpc3BsYXlibGVzLmZpbGxlciA9IG5ldyBSZWN0KHtcbiAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgIGN1cnNvcjogZ2V0Q3Vyc29yKHRoaXMuX29yaWVudCksXG4gICAgICBkcmlmdDogYmluZCh0aGlzLl9vbkRyYWdNb3ZlLCB0aGlzLCAnYWxsJyksXG4gICAgICBvbm1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gRm90IG1vYmlsZSBkZXZpY2VtLCBwcmV2ZW50IHNjcmVlbiBzbGlkZXIgb24gdGhlIGJ1dHRvbi5cbiAgICAgICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgICB9LFxuICAgICAgb25kcmFnc3RhcnQ6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCB0cnVlKSxcbiAgICAgIG9uZHJhZ2VuZDogYmluZCh0aGlzLl9vbkRyYWdFbmQsIHRoaXMpLFxuICAgICAgb25tb3VzZW92ZXI6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCB0cnVlKSxcbiAgICAgIG9ubW91c2VvdXQ6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCBmYWxzZSksXG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiBkYXRhWm9vbU1vZGVsLmdldCgnZmlsbGVyQ29sb3InKSxcbiAgICAgICAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJ1xuICAgICAgfVxuICAgIH0pKTsgLy8gRnJhbWUgYm9yZGVyLlxuXG4gICAgYmFyR3JvdXAuYWRkKG5ldyBSZWN0KGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3Qoe1xuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgc2hhcGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHNpemVbMF0sXG4gICAgICAgIGhlaWdodDogc2l6ZVsxXVxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHN0cm9rZTogZGF0YVpvb21Nb2RlbC5nZXQoJ2RhdGFCYWNrZ3JvdW5kQ29sb3InKSB8fCBkYXRhWm9vbU1vZGVsLmdldCgnYm9yZGVyQ29sb3InKSxcbiAgICAgICAgbGluZVdpZHRoOiBERUZBVUxUX0ZSQU1FX0JPUkRFUl9XSURUSCxcbiAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknXG4gICAgICB9XG4gICAgfSkpKTtcbiAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGhhbmRsZUluZGV4KSB7XG4gICAgICB2YXIgcGF0aCA9IGdyYXBoaWMuY3JlYXRlSWNvbihkYXRhWm9vbU1vZGVsLmdldCgnaGFuZGxlSWNvbicpLCB7XG4gICAgICAgIGN1cnNvcjogZ2V0Q3Vyc29yKHRoaXMuX29yaWVudCksXG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgZHJpZnQ6IGJpbmQodGhpcy5fb25EcmFnTW92ZSwgdGhpcywgaGFuZGxlSW5kZXgpLFxuICAgICAgICBvbm1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBGb3QgbW9iaWxlIGRldmljZW0sIHByZXZlbnQgc2NyZWVuIHNsaWRlciBvbiB0aGUgYnV0dG9uLlxuICAgICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbmRyYWdlbmQ6IGJpbmQodGhpcy5fb25EcmFnRW5kLCB0aGlzKSxcbiAgICAgICAgb25tb3VzZW92ZXI6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCB0cnVlKSxcbiAgICAgICAgb25tb3VzZW91dDogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIGZhbHNlKVxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IDIsXG4gICAgICAgIGhlaWdodDogMlxuICAgICAgfSk7XG4gICAgICB2YXIgYlJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgdGhpcy5faGFuZGxlSGVpZ2h0ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoZGF0YVpvb21Nb2RlbC5nZXQoJ2hhbmRsZVNpemUnKSwgdGhpcy5fc2l6ZVsxXSk7XG4gICAgICB0aGlzLl9oYW5kbGVXaWR0aCA9IGJSZWN0LndpZHRoIC8gYlJlY3QuaGVpZ2h0ICogdGhpcy5faGFuZGxlSGVpZ2h0O1xuICAgICAgcGF0aC5zZXRTdHlsZShkYXRhWm9vbU1vZGVsLmdldE1vZGVsKCdoYW5kbGVTdHlsZScpLmdldEl0ZW1TdHlsZSgpKTtcbiAgICAgIHZhciBoYW5kbGVDb2xvciA9IGRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVDb2xvcicpOyAvLyBDb21wYXRpdGFibGUgd2l0aCBwcmV2aW91cyB2ZXJzaW9uXG5cbiAgICAgIGlmIChoYW5kbGVDb2xvciAhPSBudWxsKSB7XG4gICAgICAgIHBhdGguc3R5bGUuZmlsbCA9IGhhbmRsZUNvbG9yO1xuICAgICAgfVxuXG4gICAgICBiYXJHcm91cC5hZGQoaGFuZGxlc1toYW5kbGVJbmRleF0gPSBwYXRoKTtcbiAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGRhdGFab29tTW9kZWwudGV4dFN0eWxlTW9kZWw7XG4gICAgICB0aGlzLmdyb3VwLmFkZChoYW5kbGVMYWJlbHNbaGFuZGxlSW5kZXhdID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgaW52aXNpYmxlOiB0cnVlLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKVxuICAgICAgICB9LFxuICAgICAgICB6MjogMTBcbiAgICAgIH0pKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2UgPSB0aGlzLmRhdGFab29tTW9kZWwuZ2V0UGVyY2VudFJhbmdlKCk7XG5cbiAgICB2YXIgdmlld0V4dGVudCA9IHRoaXMuX2dldFZpZXdFeHRlbnQoKTtcblxuICAgIHRoaXMuX2hhbmRsZUVuZHMgPSBbbGluZWFyTWFwKHJhbmdlWzBdLCBbMCwgMTAwXSwgdmlld0V4dGVudCwgdHJ1ZSksIGxpbmVhck1hcChyYW5nZVsxXSwgWzAsIDEwMF0sIHZpZXdFeHRlbnQsIHRydWUpXTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyl9IGhhbmRsZUluZGV4IDAgb3IgMSBvciAnYWxsJ1xuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFcbiAgICovXG4gIF91cGRhdGVJbnRlcnZhbDogZnVuY3Rpb24gKGhhbmRsZUluZGV4LCBkZWx0YSkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBoYW5kbGVFbmRzID0gdGhpcy5faGFuZGxlRW5kcztcblxuICAgIHZhciB2aWV3RXh0ZW5kID0gdGhpcy5fZ2V0Vmlld0V4dGVudCgpO1xuXG4gICAgdmFyIG1pbk1heFNwYW4gPSBkYXRhWm9vbU1vZGVsLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpLmdldE1pbk1heFNwYW4oKTtcbiAgICB2YXIgcGVyY2VudEV4dGVudCA9IFswLCAxMDBdO1xuICAgIHNsaWRlck1vdmUoZGVsdGEsIGhhbmRsZUVuZHMsIHZpZXdFeHRlbmQsIGRhdGFab29tTW9kZWwuZ2V0KCd6b29tTG9jaycpID8gJ2FsbCcgOiBoYW5kbGVJbmRleCwgbWluTWF4U3Bhbi5taW5TcGFuICE9IG51bGwgPyBsaW5lYXJNYXAobWluTWF4U3Bhbi5taW5TcGFuLCBwZXJjZW50RXh0ZW50LCB2aWV3RXh0ZW5kLCB0cnVlKSA6IG51bGwsIG1pbk1heFNwYW4ubWF4U3BhbiAhPSBudWxsID8gbGluZWFyTWFwKG1pbk1heFNwYW4ubWF4U3BhbiwgcGVyY2VudEV4dGVudCwgdmlld0V4dGVuZCwgdHJ1ZSkgOiBudWxsKTtcbiAgICB0aGlzLl9yYW5nZSA9IGFzYyhbbGluZWFyTWFwKGhhbmRsZUVuZHNbMF0sIHZpZXdFeHRlbmQsIHBlcmNlbnRFeHRlbnQsIHRydWUpLCBsaW5lYXJNYXAoaGFuZGxlRW5kc1sxXSwgdmlld0V4dGVuZCwgcGVyY2VudEV4dGVudCwgdHJ1ZSldKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVWaWV3OiBmdW5jdGlvbiAobm9uUmVhbHRpbWUpIHtcbiAgICB2YXIgZGlzcGxheWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIHZhciBoYW5kbGVJbnRlcnZhbCA9IGFzYyhoYW5kbGVFbmRzLnNsaWNlKCkpO1xuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGhhbmRsZUluZGV4KSB7XG4gICAgICAvLyBIYW5kbGVzXG4gICAgICB2YXIgaGFuZGxlID0gZGlzcGxheWJsZXMuaGFuZGxlc1toYW5kbGVJbmRleF07XG4gICAgICB2YXIgaGFuZGxlSGVpZ2h0ID0gdGhpcy5faGFuZGxlSGVpZ2h0O1xuICAgICAgaGFuZGxlLmF0dHIoe1xuICAgICAgICBzY2FsZTogW2hhbmRsZUhlaWdodCAvIDIsIGhhbmRsZUhlaWdodCAvIDJdLFxuICAgICAgICBwb3NpdGlvbjogW2hhbmRsZUVuZHNbaGFuZGxlSW5kZXhdLCBzaXplWzFdIC8gMiAtIGhhbmRsZUhlaWdodCAvIDJdXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTsgLy8gRmlsbGVyXG5cbiAgICBkaXNwbGF5Ymxlcy5maWxsZXIuc2V0U2hhcGUoe1xuICAgICAgeDogaGFuZGxlSW50ZXJ2YWxbMF0sXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGhhbmRsZUludGVydmFsWzFdIC0gaGFuZGxlSW50ZXJ2YWxbMF0sXG4gICAgICBoZWlnaHQ6IHNpemVbMV1cbiAgICB9KTtcblxuICAgIHRoaXMuX3VwZGF0ZURhdGFJbmZvKG5vblJlYWx0aW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVEYXRhSW5mbzogZnVuY3Rpb24gKG5vblJlYWx0aW1lKSB7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGRpc3BsYXlibGVzID0gdGhpcy5fZGlzcGxheWFibGVzO1xuICAgIHZhciBoYW5kbGVMYWJlbHMgPSBkaXNwbGF5Ymxlcy5oYW5kbGVMYWJlbHM7XG4gICAgdmFyIG9yaWVudCA9IHRoaXMuX29yaWVudDtcbiAgICB2YXIgbGFiZWxUZXh0cyA9IFsnJywgJyddOyAvLyBGSVhNRVxuICAgIC8vIGRhdGXlnovvvIzmlK/mjIFmb3JtYXR0ZXLvvIxhdXRvZm9ybWF0dGVy77yIZWMyIGRhdGUuZ2V0QXV0b0Zvcm1hdHRlcu+8iVxuXG4gICAgaWYgKGRhdGFab29tTW9kZWwuZ2V0KCdzaG93RGV0YWlsJykpIHtcbiAgICAgIHZhciBheGlzUHJveHkgPSBkYXRhWm9vbU1vZGVsLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuXG4gICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgIHZhciBheGlzID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpLmF4aXM7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgICAgICB2YXIgZGF0YUludGVydmFsID0gbm9uUmVhbHRpbWUgLy8gU2VlICM0NDM0LCBkYXRhIGFuZCBheGlzIGFyZSBub3QgcHJvY2Vzc2VkIGFuZCByZXNldCB5ZXQgaW4gbm9uLXJlYWx0aW1lIG1vZGUuXG4gICAgICAgID8gYXhpc1Byb3h5LmNhbGN1bGF0ZURhdGFXaW5kb3coe1xuICAgICAgICAgIHN0YXJ0OiByYW5nZVswXSxcbiAgICAgICAgICBlbmQ6IHJhbmdlWzFdXG4gICAgICAgIH0pLnZhbHVlV2luZG93IDogYXhpc1Byb3h5LmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgICAgICBsYWJlbFRleHRzID0gW3RoaXMuX2Zvcm1hdExhYmVsKGRhdGFJbnRlcnZhbFswXSwgYXhpcyksIHRoaXMuX2Zvcm1hdExhYmVsKGRhdGFJbnRlcnZhbFsxXSwgYXhpcyldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvcmRlcmVkSGFuZGxlRW5kcyA9IGFzYyh0aGlzLl9oYW5kbGVFbmRzLnNsaWNlKCkpO1xuICAgIHNldExhYmVsLmNhbGwodGhpcywgMCk7XG4gICAgc2V0TGFiZWwuY2FsbCh0aGlzLCAxKTtcblxuICAgIGZ1bmN0aW9uIHNldExhYmVsKGhhbmRsZUluZGV4KSB7XG4gICAgICAvLyBMYWJlbFxuICAgICAgLy8gVGV4dCBzaG91bGQgbm90IHRyYW5zZm9ybSBieSBiYXJHcm91cC5cbiAgICAgIC8vIElnbm9yZSBoYW5kbGVycyB0cmFuc2Zvcm1cbiAgICAgIHZhciBiYXJUcmFuc2Zvcm0gPSBncmFwaGljLmdldFRyYW5zZm9ybShkaXNwbGF5Ymxlcy5oYW5kbGVzW2hhbmRsZUluZGV4XS5wYXJlbnQsIHRoaXMuZ3JvdXApO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uKGhhbmRsZUluZGV4ID09PSAwID8gJ3JpZ2h0JyA6ICdsZWZ0JywgYmFyVHJhbnNmb3JtKTtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9oYW5kbGVXaWR0aCAvIDIgKyBMQUJFTF9HQVA7XG4gICAgICB2YXIgdGV4dFBvaW50ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybShbb3JkZXJlZEhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICsgKGhhbmRsZUluZGV4ID09PSAwID8gLW9mZnNldCA6IG9mZnNldCksIHRoaXMuX3NpemVbMV0gLyAyXSwgYmFyVHJhbnNmb3JtKTtcbiAgICAgIGhhbmRsZUxhYmVsc1toYW5kbGVJbmRleF0uc2V0U3R5bGUoe1xuICAgICAgICB4OiB0ZXh0UG9pbnRbMF0sXG4gICAgICAgIHk6IHRleHRQb2ludFsxXSxcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IG9yaWVudCA9PT0gSE9SSVpPTlRBTCA/ICdtaWRkbGUnIDogZGlyZWN0aW9uLFxuICAgICAgICB0ZXh0QWxpZ246IG9yaWVudCA9PT0gSE9SSVpPTlRBTCA/IGRpcmVjdGlvbiA6ICdjZW50ZXInLFxuICAgICAgICB0ZXh0OiBsYWJlbFRleHRzW2hhbmRsZUluZGV4XVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Zvcm1hdExhYmVsOiBmdW5jdGlvbiAodmFsdWUsIGF4aXMpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBkYXRhWm9vbU1vZGVsLmdldCgnbGFiZWxGb3JtYXR0ZXInKTtcbiAgICB2YXIgbGFiZWxQcmVjaXNpb24gPSBkYXRhWm9vbU1vZGVsLmdldCgnbGFiZWxQcmVjaXNpb24nKTtcblxuICAgIGlmIChsYWJlbFByZWNpc2lvbiA9PSBudWxsIHx8IGxhYmVsUHJlY2lzaW9uID09PSAnYXV0bycpIHtcbiAgICAgIGxhYmVsUHJlY2lzaW9uID0gYXhpcy5nZXRQaXhlbFByZWNpc2lvbigpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZVN0ciA9IHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpID8gJycgLy8gRklYTUUgR2x1ZSBjb2RlXG4gICAgOiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgfHwgYXhpcy50eXBlID09PSAndGltZScgPyBheGlzLnNjYWxlLmdldExhYmVsKE1hdGgucm91bmQodmFsdWUpKSAvLyBwYXJhbSBvZiB0b0ZpeGVkIHNob3VsZCBsZXNzIHRoZW4gMjAuXG4gICAgOiB2YWx1ZS50b0ZpeGVkKE1hdGgubWluKGxhYmVsUHJlY2lzaW9uLCAyMCkpO1xuICAgIHJldHVybiB6clV0aWwuaXNGdW5jdGlvbihsYWJlbEZvcm1hdHRlcikgPyBsYWJlbEZvcm1hdHRlcih2YWx1ZSwgdmFsdWVTdHIpIDogenJVdGlsLmlzU3RyaW5nKGxhYmVsRm9ybWF0dGVyKSA/IGxhYmVsRm9ybWF0dGVyLnJlcGxhY2UoJ3t2YWx1ZX0nLCB2YWx1ZVN0cikgOiB2YWx1ZVN0cjtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG93T3JIaWRlIHRydWU6IHNob3csIGZhbHNlOiBoaWRlXG4gICAqL1xuICBfc2hvd0RhdGFJbmZvOiBmdW5jdGlvbiAoc2hvd09ySGlkZSkge1xuICAgIC8vIEFsd2F5cyBzaG93IHdoZW4gZHJnZ2luZy5cbiAgICBzaG93T3JIaWRlID0gdGhpcy5fZHJhZ2dpbmcgfHwgc2hvd09ySGlkZTtcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gdGhpcy5fZGlzcGxheWFibGVzLmhhbmRsZUxhYmVscztcbiAgICBoYW5kbGVMYWJlbHNbMF0uYXR0cignaW52aXNpYmxlJywgIXNob3dPckhpZGUpO1xuICAgIGhhbmRsZUxhYmVsc1sxXS5hdHRyKCdpbnZpc2libGUnLCAhc2hvd09ySGlkZSk7XG4gIH0sXG4gIF9vbkRyYWdNb3ZlOiBmdW5jdGlvbiAoaGFuZGxlSW5kZXgsIGR4LCBkeSkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTsgLy8gVHJhbnNmb3JtIGR4LCBkeSB0byBiYXIgY29vcmRpbmF0aW9uLlxuXG4gICAgdmFyIGJhclRyYW5zZm9ybSA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgdmFyIHZlcnRleCA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW2R4LCBkeV0sIGJhclRyYW5zZm9ybSwgdHJ1ZSk7XG5cbiAgICB0aGlzLl91cGRhdGVJbnRlcnZhbChoYW5kbGVJbmRleCwgdmVydGV4WzBdKTtcblxuICAgIHZhciByZWFsdGltZSA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXQoJ3JlYWx0aW1lJyk7XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3KCFyZWFsdGltZSk7XG5cbiAgICBpZiAocmVhbHRpbWUpIHtcbiAgICAgIHJlYWx0aW1lICYmIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbigpO1xuICAgIH1cbiAgfSxcbiAgX29uRHJhZ0VuZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLl9zaG93RGF0YUluZm8oZmFsc2UpO1xuXG4gICAgdGhpcy5fZGlzcGF0Y2hab29tQWN0aW9uKCk7XG4gIH0sXG4gIF9vbkNsaWNrUGFuZWxDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cbiAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xuXG4gICAgaWYgKGxvY2FsUG9pbnRbMF0gPCAwIHx8IGxvY2FsUG9pbnRbMF0gPiBzaXplWzBdIHx8IGxvY2FsUG9pbnRbMV0gPCAwIHx8IGxvY2FsUG9pbnRbMV0gPiBzaXplWzFdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIHZhciBjZW50ZXIgPSAoaGFuZGxlRW5kc1swXSArIGhhbmRsZUVuZHNbMV0pIC8gMjtcblxuICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKCdhbGwnLCBsb2NhbFBvaW50WzBdIC0gY2VudGVyKTtcblxuICAgIHRoaXMuX3VwZGF0ZVZpZXcoKTtcblxuICAgIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIGFjdGlvbiB3aWxsIGJlIHRocm90dGxlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXNwYXRjaFpvb21BY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnZGF0YVpvb20nLFxuICAgICAgZnJvbTogdGhpcy51aWQsXG4gICAgICBkYXRhWm9vbUlkOiB0aGlzLmRhdGFab29tTW9kZWwuaWQsXG4gICAgICBzdGFydDogcmFuZ2VbMF0sXG4gICAgICBlbmQ6IHJhbmdlWzFdXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZmluZENvb3JkUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIC8vIEZpbmQgdGhlIGdyaWQgY29yZXNwb25kaW5nIHRvIHRoZSBmaXJzdCBheGlzIHJlZmVycmVkIGJ5IGRhdGFab29tLlxuICAgIHZhciByZWN0O1xuICAgIGVhY2godGhpcy5nZXRUYXJnZXRDb29yZEluZm8oKSwgZnVuY3Rpb24gKGNvb3JkSW5mb0xpc3QpIHtcbiAgICAgIGlmICghcmVjdCAmJiBjb29yZEluZm9MaXN0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgY29vcmRTeXMgPSBjb29yZEluZm9MaXN0WzBdLm1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgIHJlY3QgPSBjb29yZFN5cy5nZXRSZWN0ICYmIGNvb3JkU3lzLmdldFJlY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghcmVjdCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5hcGkuZ2V0V2lkdGgoKTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmFwaS5nZXRIZWlnaHQoKTtcbiAgICAgIHJlY3QgPSB7XG4gICAgICAgIHg6IHdpZHRoICogMC4yLFxuICAgICAgICB5OiBoZWlnaHQgKiAwLjIsXG4gICAgICAgIHdpZHRoOiB3aWR0aCAqIDAuNixcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKiAwLjZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRPdGhlckRpbSh0aGlzRGltKSB7XG4gIC8vIEZJWE1FXG4gIC8vIOi/meS4qumAu+i+keWSjGdldE90aGVyQXhpc+mHjOS4gOiHtO+8jOS9huaYr+WGmeWcqOi/memHjOaYr+WQpuS4jeWlvVxuICB2YXIgbWFwID0ge1xuICAgIHg6ICd5JyxcbiAgICB5OiAneCcsXG4gICAgcmFkaXVzOiAnYW5nbGUnLFxuICAgIGFuZ2xlOiAncmFkaXVzJ1xuICB9O1xuICByZXR1cm4gbWFwW3RoaXNEaW1dO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJzb3Iob3JpZW50KSB7XG4gIHJldHVybiBvcmllbnQgPT09ICd2ZXJ0aWNhbCcgPyAnbnMtcmVzaXplJyA6ICdldy1yZXNpemUnO1xufVxuXG52YXIgX2RlZmF1bHQgPSBTbGlkZXJab29tVmlldztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NsaWRlclpvb21WaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAyODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRGF0YVpvb21Nb2RlbCA9IHJlcXVpcmUoXCIuL0RhdGFab29tTW9kZWxcIik7XG5cbnZhciBfZGVmYXVsdCA9IERhdGFab29tTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFab29tLmluc2lkZScsXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgLy8gV2hldGhlciBkaXNhYmxlIHRoaXMgaW5zaWRlIHpvb20uXG4gICAgem9vbUxvY2s6IGZhbHNlLFxuICAgIC8vIFdoZXRoZXIgZGlzYWJsZSB6b29tIGJ1dCBvbmx5IHBhbi5cbiAgICB6b29tT25Nb3VzZVdoZWVsOiB0cnVlLFxuICAgIC8vIENhbiBiZTogdHJ1ZSAvIGZhbHNlIC8gJ3NoaWZ0JyAvICdjdHJsJyAvICdhbHQnLlxuICAgIG1vdmVPbk1vdXNlTW92ZTogdHJ1ZSxcbiAgICAvLyBDYW4gYmU6IHRydWUgLyBmYWxzZSAvICdzaGlmdCcgLyAnY3RybCcgLyAnYWx0Jy5cbiAgICBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZTogdHJ1ZVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vSW5zaWRlWm9vbU1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAyODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIERhdGFab29tVmlldyA9IHJlcXVpcmUoXCIuL0RhdGFab29tVmlld1wiKTtcblxudmFyIHNsaWRlck1vdmUgPSByZXF1aXJlKFwiLi4vaGVscGVyL3NsaWRlck1vdmVcIik7XG5cbnZhciByb2FtcyA9IHJlcXVpcmUoXCIuL3JvYW1zXCIpO1xuXG52YXIgYmluZCA9IHpyVXRpbC5iaW5kO1xudmFyIEluc2lkZVpvb21WaWV3ID0gRGF0YVpvb21WaWV3LmV4dGVuZCh7XG4gIHR5cGU6ICdkYXRhWm9vbS5pbnNpZGUnLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAvKipcbiAgICAgKiAndGhyb3R0bGUnIGlzIHVzZWQgaW4gdGhpcy5kaXNwYXRjaEFjdGlvbiwgc28gd2Ugc2F2ZSByYW5nZVxuICAgICAqIHRvIGF2b2lkIG1pc3Npbmcgc29tZSAncGFuJyBpbmZvLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3JhbmdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIEluc2lkZVpvb21WaWV3LnN1cGVyQXBwbHkodGhpcywgJ3JlbmRlcicsIGFyZ3VtZW50cyk7IC8vIE5vdGljZTogb3JpZ2luIHRoaXMuX3JhbmdlIHNob3VsZCBiZSBtYWludGFpbmVkLCBhbmQgc2hvdWxkIG5vdCBiZSByZS1mZXRjaGVkXG4gICAgLy8gZnJvbSBkYXRhWm9vbU1vZGVsIHdoZW4gcGF5bG9hZC50eXBlIGlzICdkYXRhWm9vbScsIG90aGVyd2lzZSAncGFuJyBvciAnem9vbSdcbiAgICAvLyBpbmZvIHdpbGwgYmUgbWlzc2VkIGJlY2F1c2Ugb2YgJ3Rocm90dGxlJyBvZiB0aGlzLmRpc3BhdGNoQWN0aW9uLlxuXG4gICAgaWYgKHJvYW1zLnNob3VsZFJlY29yZFJhbmdlKHBheWxvYWQsIGRhdGFab29tTW9kZWwuaWQpKSB7XG4gICAgICB0aGlzLl9yYW5nZSA9IGRhdGFab29tTW9kZWwuZ2V0UGVyY2VudFJhbmdlKCk7XG4gICAgfSAvLyBSZXNldCBjb250cm9sbGVycy5cblxuXG4gICAgenJVdGlsLmVhY2godGhpcy5nZXRUYXJnZXRDb29yZEluZm8oKSwgZnVuY3Rpb24gKGNvb3JkSW5mb0xpc3QsIGNvb3JkU3lzTmFtZSkge1xuICAgICAgdmFyIGFsbENvb3JkSWRzID0genJVdGlsLm1hcChjb29yZEluZm9MaXN0LCBmdW5jdGlvbiAoY29vcmRJbmZvKSB7XG4gICAgICAgIHJldHVybiByb2Ftcy5nZW5lcmF0ZUNvb3JkSWQoY29vcmRJbmZvLm1vZGVsKTtcbiAgICAgIH0pO1xuICAgICAgenJVdGlsLmVhY2goY29vcmRJbmZvTGlzdCwgZnVuY3Rpb24gKGNvb3JkSW5mbykge1xuICAgICAgICB2YXIgY29vcmRNb2RlbCA9IGNvb3JkSW5mby5tb2RlbDtcbiAgICAgICAgdmFyIGRhdGFab29tT3B0aW9uID0gZGF0YVpvb21Nb2RlbC5vcHRpb247XG4gICAgICAgIHJvYW1zLnJlZ2lzdGVyKGFwaSwge1xuICAgICAgICAgIGNvb3JkSWQ6IHJvYW1zLmdlbmVyYXRlQ29vcmRJZChjb29yZE1vZGVsKSxcbiAgICAgICAgICBhbGxDb29yZElkczogYWxsQ29vcmRJZHMsXG4gICAgICAgICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKGUsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29yZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uY29udGFpblBvaW50KFt4LCB5XSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhWm9vbUlkOiBkYXRhWm9vbU1vZGVsLmlkLFxuICAgICAgICAgIHRocm90dGxlUmF0ZTogZGF0YVpvb21Nb2RlbC5nZXQoJ3Rocm90dGxlJywgdHJ1ZSksXG4gICAgICAgICAgcGFuR2V0UmFuZ2U6IGJpbmQodGhpcy5fb25QYW4sIHRoaXMsIGNvb3JkSW5mbywgY29vcmRTeXNOYW1lKSxcbiAgICAgICAgICB6b29tR2V0UmFuZ2U6IGJpbmQodGhpcy5fb25ab29tLCB0aGlzLCBjb29yZEluZm8sIGNvb3JkU3lzTmFtZSksXG4gICAgICAgICAgem9vbUxvY2s6IGRhdGFab29tT3B0aW9uLnpvb21Mb2NrLFxuICAgICAgICAgIGRpc2FibGVkOiBkYXRhWm9vbU9wdGlvbi5kaXNhYmxlZCxcbiAgICAgICAgICByb2FtQ29udHJvbGxlck9wdDoge1xuICAgICAgICAgICAgem9vbU9uTW91c2VXaGVlbDogZGF0YVpvb21PcHRpb24uem9vbU9uTW91c2VXaGVlbCxcbiAgICAgICAgICAgIG1vdmVPbk1vdXNlTW92ZTogZGF0YVpvb21PcHRpb24ubW92ZU9uTW91c2VNb3ZlLFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHRNb3VzZU1vdmU6IGRhdGFab29tT3B0aW9uLnByZXZlbnREZWZhdWx0TW91c2VNb3ZlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICByb2Ftcy51bnJlZ2lzdGVyKHRoaXMuYXBpLCB0aGlzLmRhdGFab29tTW9kZWwuaWQpO1xuICAgIEluc2lkZVpvb21WaWV3LnN1cGVyQXBwbHkodGhpcywgJ2Rpc3Bvc2UnLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuX3JhbmdlID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblBhbjogZnVuY3Rpb24gKGNvb3JkSW5mbywgY29vcmRTeXNOYW1lLCBjb250cm9sbGVyLCBkeCwgZHksIG9sZFgsIG9sZFksIG5ld1gsIG5ld1kpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZS5zbGljZSgpOyAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtIGJ5IHRoZSBmaXJzdCBheGlzLlxuXG5cbiAgICB2YXIgYXhpc01vZGVsID0gY29vcmRJbmZvLmF4aXNNb2RlbHNbMF07XG5cbiAgICBpZiAoIWF4aXNNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXJlY3Rpb25JbmZvID0gZ2V0RGlyZWN0aW9uSW5mb1tjb29yZFN5c05hbWVdKFtvbGRYLCBvbGRZXSwgW25ld1gsIG5ld1ldLCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkSW5mbyk7XG4gICAgdmFyIHBlcmNlbnREZWx0YSA9IGRpcmVjdGlvbkluZm8uc2lnbmFsICogKHJhbmdlWzFdIC0gcmFuZ2VbMF0pICogZGlyZWN0aW9uSW5mby5waXhlbCAvIGRpcmVjdGlvbkluZm8ucGl4ZWxMZW5ndGg7XG4gICAgc2xpZGVyTW92ZShwZXJjZW50RGVsdGEsIHJhbmdlLCBbMCwgMTAwXSwgJ2FsbCcpO1xuICAgIHJldHVybiB0aGlzLl9yYW5nZSA9IHJhbmdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uWm9vbTogZnVuY3Rpb24gKGNvb3JkSW5mbywgY29vcmRTeXNOYW1lLCBjb250cm9sbGVyLCBzY2FsZSwgbW91c2VYLCBtb3VzZVkpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZS5zbGljZSgpOyAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtIGJ5IHRoZSBmaXJzdCBheGlzLlxuXG5cbiAgICB2YXIgYXhpc01vZGVsID0gY29vcmRJbmZvLmF4aXNNb2RlbHNbMF07XG5cbiAgICBpZiAoIWF4aXNNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXJlY3Rpb25JbmZvID0gZ2V0RGlyZWN0aW9uSW5mb1tjb29yZFN5c05hbWVdKG51bGwsIFttb3VzZVgsIG1vdXNlWV0sIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKTtcbiAgICB2YXIgcGVyY2VudFBvaW50ID0gKGRpcmVjdGlvbkluZm8uc2lnbmFsID4gMCA/IGRpcmVjdGlvbkluZm8ucGl4ZWxTdGFydCArIGRpcmVjdGlvbkluZm8ucGl4ZWxMZW5ndGggLSBkaXJlY3Rpb25JbmZvLnBpeGVsIDogZGlyZWN0aW9uSW5mby5waXhlbCAtIGRpcmVjdGlvbkluZm8ucGl4ZWxTdGFydCkgLyBkaXJlY3Rpb25JbmZvLnBpeGVsTGVuZ3RoICogKHJhbmdlWzFdIC0gcmFuZ2VbMF0pICsgcmFuZ2VbMF07XG4gICAgc2NhbGUgPSBNYXRoLm1heCgxIC8gc2NhbGUsIDApO1xuICAgIHJhbmdlWzBdID0gKHJhbmdlWzBdIC0gcGVyY2VudFBvaW50KSAqIHNjYWxlICsgcGVyY2VudFBvaW50O1xuICAgIHJhbmdlWzFdID0gKHJhbmdlWzFdIC0gcGVyY2VudFBvaW50KSAqIHNjYWxlICsgcGVyY2VudFBvaW50OyAvLyBSZXN0cmljdCByYW5nZS5cblxuICAgIHZhciBtaW5NYXhTcGFuID0gdGhpcy5kYXRhWm9vbU1vZGVsLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpLmdldE1pbk1heFNwYW4oKTtcbiAgICBzbGlkZXJNb3ZlKDAsIHJhbmdlLCBbMCwgMTAwXSwgMCwgbWluTWF4U3Bhbi5taW5TcGFuLCBtaW5NYXhTcGFuLm1heFNwYW4pO1xuICAgIHJldHVybiB0aGlzLl9yYW5nZSA9IHJhbmdlO1xuICB9XG59KTtcbnZhciBnZXREaXJlY3Rpb25JbmZvID0ge1xuICBncmlkOiBmdW5jdGlvbiAob2xkUG9pbnQsIG5ld1BvaW50LCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkSW5mbykge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIHZhciByZWN0ID0gY29vcmRJbmZvLm1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgIG9sZFBvaW50ID0gb2xkUG9pbnQgfHwgWzAsIDBdO1xuXG4gICAgaWYgKGF4aXMuZGltID09PSAneCcpIHtcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LndpZHRoO1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByZWN0Lng7XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBheGlzLmRpbSA9PT0gJ3knXG4gICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFsxXSAtIG9sZFBvaW50WzFdO1xuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmVjdC5oZWlnaHQ7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueTtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgcG9sYXI6IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgcmV0ID0ge307XG4gICAgdmFyIHBvbGFyID0gY29vcmRJbmZvLm1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIHJhZGl1c0V4dGVudCA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgYW5nbGVFeHRlbnQgPSBwb2xhci5nZXRBbmdsZUF4aXMoKS5nZXRFeHRlbnQoKTtcbiAgICBvbGRQb2ludCA9IG9sZFBvaW50ID8gcG9sYXIucG9pbnRUb0Nvb3JkKG9sZFBvaW50KSA6IFswLCAwXTtcbiAgICBuZXdQb2ludCA9IHBvbGFyLnBvaW50VG9Db29yZChuZXdQb2ludCk7XG5cbiAgICBpZiAoYXhpc01vZGVsLm1haW5UeXBlID09PSAncmFkaXVzQXhpcycpIHtcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07IC8vIHJldC5waXhlbExlbmd0aCA9IE1hdGguYWJzKHJhZGl1c0V4dGVudFsxXSAtIHJhZGl1c0V4dGVudFswXSk7XG4gICAgICAvLyByZXQucGl4ZWxTdGFydCA9IE1hdGgubWluKHJhZGl1c0V4dGVudFswXSwgcmFkaXVzRXh0ZW50WzFdKTtcblxuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmFkaXVzRXh0ZW50WzFdIC0gcmFkaXVzRXh0ZW50WzBdO1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByYWRpdXNFeHRlbnRbMF07XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAnYW5nbGVBeGlzJ1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMV0gLSBvbGRQb2ludFsxXTsgLy8gcmV0LnBpeGVsTGVuZ3RoID0gTWF0aC5hYnMoYW5nbGVFeHRlbnRbMV0gLSBhbmdsZUV4dGVudFswXSk7XG4gICAgICAvLyByZXQucGl4ZWxTdGFydCA9IE1hdGgubWluKGFuZ2xlRXh0ZW50WzBdLCBhbmdsZUV4dGVudFsxXSk7XG5cbiAgICAgIHJldC5waXhlbExlbmd0aCA9IGFuZ2xlRXh0ZW50WzFdIC0gYW5nbGVFeHRlbnRbMF07XG4gICAgICByZXQucGl4ZWxTdGFydCA9IGFuZ2xlRXh0ZW50WzBdO1xuICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBzaW5nbGVBeGlzOiBmdW5jdGlvbiAob2xkUG9pbnQsIG5ld1BvaW50LCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkSW5mbykge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIHJlY3QgPSBjb29yZEluZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG9sZFBvaW50ID0gb2xkUG9pbnQgfHwgWzAsIDBdO1xuXG4gICAgaWYgKGF4aXMub3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LndpZHRoO1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByZWN0Lng7XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAndmVydGljYWwnXG4gICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFsxXSAtIG9sZFBvaW50WzFdO1xuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmVjdC5oZWlnaHQ7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueTtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEluc2lkZVpvb21WaWV3O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vSW5zaWRlWm9vbVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDI4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgUm9hbUNvbnRyb2xsZXIgPSByZXF1aXJlKFwiLi4vLi4vY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlclwiKTtcblxudmFyIHRocm90dGxlVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3Rocm90dGxlXCIpO1xuXG4vLyBPbmx5IGNyZWF0ZSBvbmUgcm9hbSBjb250cm9sbGVyIGZvciBlYWNoIGNvb3JkaW5hdGUgc3lzdGVtLlxuLy8gb25lIHJvYW0gY29udHJvbGxlciBtaWdodCBiZSByZWZlcmVkIGJ5IHR3byBpbnNpZGUgZGF0YSB6b29tXG4vLyBjb21wb25lbnRzIChmb3IgZXhhbXBsZSwgb25lIGZvciB4IGFuZCBvbmUgZm9yIHkpLiBXaGVuIHVzZXJcbi8vIHBhbiBvciB6b29tLCBvbmx5IGRpc3BhdGNoIG9uZSBhY3Rpb24gZm9yIHRob3NlIGRhdGEgem9vbVxuLy8gY29tcG9uZW50cy5cbnZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbnZhciBBVFRSID0gJ1xcMF9lY19kYXRhWm9vbV9yb2Ftcyc7XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhWm9vbUluZm9cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhWm9vbUluZm8uY29vcmRJZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YVpvb21JbmZvLmNvbnRhaW5zUG9pbnRcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGRhdGFab29tSW5mby5hbGxDb29yZElkc1xuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFab29tSW5mby5kYXRhWm9vbUlkXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0YVpvb21JbmZvLnRocm90dGxlUmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YVpvb21JbmZvLnBhbkdldFJhbmdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkYXRhWm9vbUluZm8uem9vbUdldFJhbmdlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXRhWm9vbUluZm8uem9vbUxvY2tdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXRhWm9vbUluZm8uZGlzYWJsZWRdXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXIoYXBpLCBkYXRhWm9vbUluZm8pIHtcbiAgdmFyIHN0b3JlID0gZ2l2ZVN0b3JlKGFwaSk7XG4gIHZhciB0aGVEYXRhWm9vbUlkID0gZGF0YVpvb21JbmZvLmRhdGFab29tSWQ7XG4gIHZhciB0aGVDb29yZElkID0gZGF0YVpvb21JbmZvLmNvb3JkSWQ7IC8vIERvIGNsZWFuIHdoZW4gYSBkYXRhWm9vbSBjaGFuZ2VzIGl0cyB0YXJnZXQgY29vcmRuYXRlIHN5c3RlbS5cbiAgLy8gQXZvaWQgbWVtb3J5IGxlYWssIGRpc3Bvc2UgYWxsIG5vdC11c2VkLXJlZ2lzdGVyZWQuXG5cbiAgenJVdGlsLmVhY2goc3RvcmUsIGZ1bmN0aW9uIChyZWNvcmQsIGNvb3JkSWQpIHtcbiAgICB2YXIgZGF0YVpvb21JbmZvcyA9IHJlY29yZC5kYXRhWm9vbUluZm9zO1xuXG4gICAgaWYgKGRhdGFab29tSW5mb3NbdGhlRGF0YVpvb21JZF0gJiYgenJVdGlsLmluZGV4T2YoZGF0YVpvb21JbmZvLmFsbENvb3JkSWRzLCB0aGVDb29yZElkKSA8IDApIHtcbiAgICAgIGRlbGV0ZSBkYXRhWm9vbUluZm9zW3RoZURhdGFab29tSWRdO1xuICAgICAgcmVjb3JkLmNvdW50LS07XG4gICAgfVxuICB9KTtcbiAgY2xlYW5TdG9yZShzdG9yZSk7XG4gIHZhciByZWNvcmQgPSBzdG9yZVt0aGVDb29yZElkXTsgLy8gQ3JlYXRlIGlmIG5lZWRlZC5cblxuICBpZiAoIXJlY29yZCkge1xuICAgIHJlY29yZCA9IHN0b3JlW3RoZUNvb3JkSWRdID0ge1xuICAgICAgY29vcmRJZDogdGhlQ29vcmRJZCxcbiAgICAgIGRhdGFab29tSW5mb3M6IHt9LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICAgIHJlY29yZC5jb250cm9sbGVyID0gY3JlYXRlQ29udHJvbGxlcihhcGksIHJlY29yZCk7XG4gICAgcmVjb3JkLmRpc3BhdGNoQWN0aW9uID0genJVdGlsLmN1cnJ5KGRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICB9IC8vIFVwZGF0ZSByZWZlcmVuY2Ugb2YgZGF0YVpvb20uXG5cblxuICAhcmVjb3JkLmRhdGFab29tSW5mb3NbdGhlRGF0YVpvb21JZF0gJiYgcmVjb3JkLmNvdW50Kys7XG4gIHJlY29yZC5kYXRhWm9vbUluZm9zW3RoZURhdGFab29tSWRdID0gZGF0YVpvb21JbmZvO1xuICB2YXIgY29udHJvbGxlclBhcmFtcyA9IG1lcmdlQ29udHJvbGxlclBhcmFtcyhyZWNvcmQuZGF0YVpvb21JbmZvcyk7XG4gIHJlY29yZC5jb250cm9sbGVyLmVuYWJsZShjb250cm9sbGVyUGFyYW1zLmNvbnRyb2xUeXBlLCBjb250cm9sbGVyUGFyYW1zLm9wdCk7IC8vIENvbnNpZGVyIHJlc2l6ZSwgYXJlYSBzaG91bGQgYmUgYWx3YXlzIHVwZGF0ZWQuXG5cbiAgcmVjb3JkLmNvbnRyb2xsZXIuc2V0UG9pbnRlckNoZWNrZXIoZGF0YVpvb21JbmZvLmNvbnRhaW5zUG9pbnQpOyAvLyBVcGRhdGUgdGhyb3R0bGUuXG5cbiAgdGhyb3R0bGVVdGlsLmNyZWF0ZU9yVXBkYXRlKHJlY29yZCwgJ2Rpc3BhdGNoQWN0aW9uJywgZGF0YVpvb21JbmZvLnRocm90dGxlUmF0ZSwgJ2ZpeFJhdGUnKTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFab29tSWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHVucmVnaXN0ZXIoYXBpLCBkYXRhWm9vbUlkKSB7XG4gIHZhciBzdG9yZSA9IGdpdmVTdG9yZShhcGkpO1xuICB6clV0aWwuZWFjaChzdG9yZSwgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgIHJlY29yZC5jb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgICB2YXIgZGF0YVpvb21JbmZvcyA9IHJlY29yZC5kYXRhWm9vbUluZm9zO1xuXG4gICAgaWYgKGRhdGFab29tSW5mb3NbZGF0YVpvb21JZF0pIHtcbiAgICAgIGRlbGV0ZSBkYXRhWm9vbUluZm9zW2RhdGFab29tSWRdO1xuICAgICAgcmVjb3JkLmNvdW50LS07XG4gICAgfVxuICB9KTtcbiAgY2xlYW5TdG9yZShzdG9yZSk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNob3VsZFJlY29yZFJhbmdlKHBheWxvYWQsIGRhdGFab29tSWQpIHtcbiAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC50eXBlID09PSAnZGF0YVpvb20nICYmIHBheWxvYWQuYmF0Y2gpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF5bG9hZC5iYXRjaC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHBheWxvYWQuYmF0Y2hbaV0uZGF0YVpvb21JZCA9PT0gZGF0YVpvb21JZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29vcmRJZChjb29yZE1vZGVsKSB7XG4gIHJldHVybiBjb29yZE1vZGVsLnR5cGUgKyAnXFwwXycgKyBjb29yZE1vZGVsLmlkO1xufVxuLyoqXG4gKiBLZXk6IGNvb3JkSWQsIHZhbHVlOiB7ZGF0YVpvb21JbmZvczogW10sIGNvdW50LCBjb250cm9sbGVyfVxuICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICovXG5cblxuZnVuY3Rpb24gZ2l2ZVN0b3JlKGFwaSkge1xuICAvLyBNb3VudCBzdG9yZSBvbiB6cmVuZGVyIGluc3RhbmNlLCBzbyB0aGF0IHdlIGRvIG5vdFxuICAvLyBuZWVkIHRvIHdvcnJ5IGFib3V0IGRpc3Bvc2UuXG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICByZXR1cm4genJbQVRUUl0gfHwgKHpyW0FUVFJdID0ge30pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250cm9sbGVyKGFwaSwgbmV3UmVjb3JkKSB7XG4gIHZhciBjb250cm9sbGVyID0gbmV3IFJvYW1Db250cm9sbGVyKGFwaS5nZXRacigpKTtcbiAgY29udHJvbGxlci5vbigncGFuJywgY3Vycnkob25QYW4sIG5ld1JlY29yZCkpO1xuICBjb250cm9sbGVyLm9uKCd6b29tJywgY3Vycnkob25ab29tLCBuZXdSZWNvcmQpKTtcbiAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG5cbmZ1bmN0aW9uIGNsZWFuU3RvcmUoc3RvcmUpIHtcbiAgenJVdGlsLmVhY2goc3RvcmUsIGZ1bmN0aW9uIChyZWNvcmQsIGNvb3JkSWQpIHtcbiAgICBpZiAoIXJlY29yZC5jb3VudCkge1xuICAgICAgcmVjb3JkLmNvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgICAgZGVsZXRlIHN0b3JlW2Nvb3JkSWRdO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUGFuKHJlY29yZCwgZHgsIGR5LCBvbGRYLCBvbGRZLCBuZXdYLCBuZXdZKSB7XG4gIHdyYXBBbmREaXNwYXRjaChyZWNvcmQsIGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ucGFuR2V0UmFuZ2UocmVjb3JkLmNvbnRyb2xsZXIsIGR4LCBkeSwgb2xkWCwgb2xkWSwgbmV3WCwgbmV3WSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblpvb20ocmVjb3JkLCBzY2FsZSwgbW91c2VYLCBtb3VzZVkpIHtcbiAgd3JhcEFuZERpc3BhdGNoKHJlY29yZCwgZnVuY3Rpb24gKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby56b29tR2V0UmFuZ2UocmVjb3JkLmNvbnRyb2xsZXIsIHNjYWxlLCBtb3VzZVgsIG1vdXNlWSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwQW5kRGlzcGF0Y2gocmVjb3JkLCBnZXRSYW5nZSkge1xuICB2YXIgYmF0Y2ggPSBbXTtcbiAgenJVdGlsLmVhY2gocmVjb3JkLmRhdGFab29tSW5mb3MsIGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgdmFyIHJhbmdlID0gZ2V0UmFuZ2UoaW5mbyk7XG4gICAgIWluZm8uZGlzYWJsZWQgJiYgcmFuZ2UgJiYgYmF0Y2gucHVzaCh7XG4gICAgICBkYXRhWm9vbUlkOiBpbmZvLmRhdGFab29tSWQsXG4gICAgICBzdGFydDogcmFuZ2VbMF0sXG4gICAgICBlbmQ6IHJhbmdlWzFdXG4gICAgfSk7XG4gIH0pO1xuICByZWNvcmQuZGlzcGF0Y2hBY3Rpb24oYmF0Y2gpO1xufVxuLyoqXG4gKiBUaGlzIGFjdGlvbiB3aWxsIGJlIHRocm90dGxlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKGFwaSwgYmF0Y2gpIHtcbiAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnZGF0YVpvb20nLFxuICAgIGJhdGNoOiBiYXRjaFxuICB9KTtcbn1cbi8qKlxuICogTWVyZ2Ugcm9hbUNvbnRyb2xsZXIgc2V0dGluZ3Mgd2hlbiBtdWx0aXBsZSBkYXRhWm9vbXMgc2hhcmUgb25lIHJvYW1Db250cm9sbGVyLlxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VDb250cm9sbGVyUGFyYW1zKGRhdGFab29tSW5mb3MpIHtcbiAgdmFyIGNvbnRyb2xUeXBlO1xuICB2YXIgb3B0ID0ge307XG4gIHZhciB0eXBlUHJpb3JpdHkgPSB7XG4gICAgJ3RydWUnOiAyLFxuICAgICdtb3ZlJzogMSxcbiAgICAnZmFsc2UnOiAwLFxuICAgICd1bmRlZmluZWQnOiAtMVxuICB9O1xuICB6clV0aWwuZWFjaChkYXRhWm9vbUluZm9zLCBmdW5jdGlvbiAoZGF0YVpvb21JbmZvKSB7XG4gICAgdmFyIG9uZVR5cGUgPSBkYXRhWm9vbUluZm8uZGlzYWJsZWQgPyBmYWxzZSA6IGRhdGFab29tSW5mby56b29tTG9jayA/ICdtb3ZlJyA6IHRydWU7XG4gICAgdHlwZVByaW9yaXR5W29uZVR5cGVdID4gdHlwZVByaW9yaXR5W2NvbnRyb2xUeXBlXSAmJiAoY29udHJvbFR5cGUgPSBvbmVUeXBlKTsgLy8gRG8gbm90IHN1cHBvcnQgdGhhdCBkaWZmZXJlbnQgJ3NoaWZ0Jy8nY3RybCcvJ2FsdCcgc2V0dGluZyB1c2VkIGluIG9uZSBjb29yZCBzeXMuXG5cbiAgICB6clV0aWwuZXh0ZW5kKG9wdCwgZGF0YVpvb21JbmZvLnJvYW1Db250cm9sbGVyT3B0KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY29udHJvbFR5cGU6IGNvbnRyb2xUeXBlLFxuICAgIG9wdDogb3B0XG4gIH07XG59XG5cbmV4cG9ydHMucmVnaXN0ZXIgPSByZWdpc3RlcjtcbmV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXI7XG5leHBvcnRzLnNob3VsZFJlY29yZFJhbmdlID0gc2hvdWxkUmVjb3JkUmFuZ2U7XG5leHBvcnRzLmdlbmVyYXRlQ29vcmRJZCA9IGdlbmVyYXRlQ29vcmRJZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vcm9hbXMuanNcbi8vIG1vZHVsZSBpZCA9IDI4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBldmVudFRvb2wgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9ldmVudFwiKTtcblxudmFyIGludGVyYWN0aW9uTXV0ZXggPSByZXF1aXJlKFwiLi9pbnRlcmFjdGlvbk11dGV4XCIpO1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvaGVscGVyL1JvYW1Db250cm9sbGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtaXhpbiB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci96cmVuZGVyflpSZW5kZXJ9IHpyXG4gKi9cbmZ1bmN0aW9uIFJvYW1Db250cm9sbGVyKHpyKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICB0aGlzLnBvaW50ZXJDaGVja2VyO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyfVxuICAgKi9cblxuICB0aGlzLl96ciA9IHpyO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5fb3B0ID0ge307IC8vIEF2b2lkIHR3byByb2FtQ29udHJvbGxlciBiaW5kIHRoZSBzYW1lIGhhbmRsZXJcblxuICB2YXIgYmluZCA9IHpyVXRpbC5iaW5kO1xuICB2YXIgbW91c2Vkb3duSGFuZGxlciA9IGJpbmQobW91c2Vkb3duLCB0aGlzKTtcbiAgdmFyIG1vdXNlbW92ZUhhbmRsZXIgPSBiaW5kKG1vdXNlbW92ZSwgdGhpcyk7XG4gIHZhciBtb3VzZXVwSGFuZGxlciA9IGJpbmQobW91c2V1cCwgdGhpcyk7XG4gIHZhciBtb3VzZXdoZWVsSGFuZGxlciA9IGJpbmQobW91c2V3aGVlbCwgdGhpcyk7XG4gIHZhciBwaW5jaEhhbmRsZXIgPSBiaW5kKHBpbmNoLCB0aGlzKTtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHBvaW50ZXJDaGVja2VyXG4gICAqICAgICAgICAgICAgICAgICAgIGlucHV0OiB4LCB5XG4gICAqICAgICAgICAgICAgICAgICAgIG91dHB1dDogYm9vbGVhblxuICAgKi9cblxuICB0aGlzLnNldFBvaW50ZXJDaGVja2VyID0gZnVuY3Rpb24gKHBvaW50ZXJDaGVja2VyKSB7XG4gICAgdGhpcy5wb2ludGVyQ2hlY2tlciA9IHBvaW50ZXJDaGVja2VyO1xuICB9O1xuICAvKipcbiAgICogTm90aWNlOiBvbmx5IGVuYWJsZSBuZWVkZWQgdHlwZXMuIEZvciBleGFtcGxlLCBpZiAnem9vbSdcbiAgICogaXMgbm90IG5lZWRlZCwgJ3pvb20nIHNob3VsZCBub3QgYmUgZW5hYmxlZCwgb3RoZXJ3aXNlXG4gICAqIGRlZmF1bHQgbW91c2V3aGVlbCBiZWhhdmlvdXIgKHNjcm9sbCBwYWdlKSB3aWxsIGJlIGRpc2FibGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufHN0cmluZ30gW2NvbnRyb2xUeXBlPXRydWVdIFNwZWNpZnkgdGhlIGNvbnRyb2wgdHlwZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGNhbiBiZSBudWxsL3VuZGVmaW5lZCBvciB0cnVlL2ZhbHNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciAncGFuL21vdmUnIG9yICd6b29tJy8nc2NhbGUnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC56b29tT25Nb3VzZVdoZWVsPXRydWVdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0Lm1vdmVPbk1vdXNlTW92ZT10cnVlXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5wcmV2ZW50RGVmYXVsdE1vdXNlTW92ZT10cnVlXSBXaGVuIHBhbi5cbiAgICovXG5cblxuICB0aGlzLmVuYWJsZSA9IGZ1bmN0aW9uIChjb250cm9sVHlwZSwgb3B0KSB7XG4gICAgLy8gRGlzYWJsZSBwcmV2aW91cyBmaXJzdFxuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuX29wdCA9IHpyVXRpbC5kZWZhdWx0cyh6clV0aWwuY2xvbmUob3B0KSB8fCB7fSwge1xuICAgICAgem9vbU9uTW91c2VXaGVlbDogdHJ1ZSxcbiAgICAgIG1vdmVPbk1vdXNlTW92ZTogdHJ1ZSxcbiAgICAgIHByZXZlbnREZWZhdWx0TW91c2VNb3ZlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoY29udHJvbFR5cGUgPT0gbnVsbCkge1xuICAgICAgY29udHJvbFR5cGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjb250cm9sVHlwZSA9PT0gdHJ1ZSB8fCBjb250cm9sVHlwZSA9PT0gJ21vdmUnIHx8IGNvbnRyb2xUeXBlID09PSAncGFuJykge1xuICAgICAgenIub24oJ21vdXNlZG93bicsIG1vdXNlZG93bkhhbmRsZXIpO1xuICAgICAgenIub24oJ21vdXNlbW92ZScsIG1vdXNlbW92ZUhhbmRsZXIpO1xuICAgICAgenIub24oJ21vdXNldXAnLCBtb3VzZXVwSGFuZGxlcik7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRyb2xUeXBlID09PSB0cnVlIHx8IGNvbnRyb2xUeXBlID09PSAnc2NhbGUnIHx8IGNvbnRyb2xUeXBlID09PSAnem9vbScpIHtcbiAgICAgIHpyLm9uKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xuICAgICAgenIub24oJ3BpbmNoJywgcGluY2hIYW5kbGVyKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHpyLm9mZignbW91c2Vkb3duJywgbW91c2Vkb3duSGFuZGxlcik7XG4gICAgenIub2ZmKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmVIYW5kbGVyKTtcbiAgICB6ci5vZmYoJ21vdXNldXAnLCBtb3VzZXVwSGFuZGxlcik7XG4gICAgenIub2ZmKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xuICAgIHpyLm9mZigncGluY2gnLCBwaW5jaEhhbmRsZXIpO1xuICB9O1xuXG4gIHRoaXMuZGlzcG9zZSA9IHRoaXMuZGlzYWJsZTtcblxuICB0aGlzLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyYWdnaW5nO1xuICB9O1xuXG4gIHRoaXMuaXNQaW5jaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGluY2hpbmc7XG4gIH07XG59XG5cbnpyVXRpbC5taXhpbihSb2FtQ29udHJvbGxlciwgRXZlbnRmdWwpO1xuXG5mdW5jdGlvbiBtb3VzZWRvd24oZSkge1xuICBpZiAoZXZlbnRUb29sLm5vdExlZnRNb3VzZShlKSB8fCBlLnRhcmdldCAmJiBlLnRhcmdldC5kcmFnZ2FibGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgdmFyIHkgPSBlLm9mZnNldFk7IC8vIE9ubHkgY2hlY2sgb24gbW9zZWRvd24sIGJ1dCBub3QgbW91c2Vtb3ZlLlxuICAvLyBNb3VzZSBjYW4gYmUgb3V0IG9mIHRhcmdldCB3aGVuIG1vdXNlIG1vdmluZy5cblxuICBpZiAodGhpcy5wb2ludGVyQ2hlY2tlciAmJiB0aGlzLnBvaW50ZXJDaGVja2VyKGUsIHgsIHkpKSB7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5fZHJhZ2dpbmcgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdXNlbW92ZShlKSB7XG4gIGlmIChldmVudFRvb2wubm90TGVmdE1vdXNlKGUpIHx8ICFjaGVja0tleUJpbmRpbmcodGhpcywgJ21vdmVPbk1vdXNlTW92ZScsIGUpIHx8ICF0aGlzLl9kcmFnZ2luZyB8fCBlLmdlc3R1cmVFdmVudCA9PT0gJ3BpbmNoJyB8fCBpbnRlcmFjdGlvbk11dGV4LmlzVGFrZW4odGhpcy5fenIsICdnbG9iYWxQYW4nKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB4ID0gZS5vZmZzZXRYO1xuICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgdmFyIG9sZFggPSB0aGlzLl94O1xuICB2YXIgb2xkWSA9IHRoaXMuX3k7XG4gIHZhciBkeCA9IHggLSBvbGRYO1xuICB2YXIgZHkgPSB5IC0gb2xkWTtcbiAgdGhpcy5feCA9IHg7XG4gIHRoaXMuX3kgPSB5O1xuICB0aGlzLl9vcHQucHJldmVudERlZmF1bHRNb3VzZU1vdmUgJiYgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gIHRoaXMudHJpZ2dlcigncGFuJywgZHgsIGR5LCBvbGRYLCBvbGRZLCB4LCB5KTtcbn1cblxuZnVuY3Rpb24gbW91c2V1cChlKSB7XG4gIGlmICghZXZlbnRUb29sLm5vdExlZnRNb3VzZShlKSkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91c2V3aGVlbChlKSB7XG4gIC8vIHdoZWVsRGVsdGEgbWF5YmUgLTAgaW4gY2hyb21lIG1hYy5cbiAgaWYgKCFjaGVja0tleUJpbmRpbmcodGhpcywgJ3pvb21Pbk1vdXNlV2hlZWwnLCBlKSB8fCBlLndoZWVsRGVsdGEgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ29udmVuaWVuY2U6XG4gIC8vIE1hYyBhbmQgVk0gV2luZG93cyBvbiBNYWM6IHNjcm9sbCB1cDogem9vbSBvdXQuXG4gIC8vIFdpbmRvd3M6IHNjcm9sbCB1cDogem9vbSBpbi5cblxuXG4gIHZhciB6b29tRGVsdGEgPSBlLndoZWVsRGVsdGEgPiAwID8gMS4xIDogMSAvIDEuMTtcbiAgem9vbS5jYWxsKHRoaXMsIGUsIHpvb21EZWx0YSwgZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xufVxuXG5mdW5jdGlvbiBwaW5jaChlKSB7XG4gIGlmIChpbnRlcmFjdGlvbk11dGV4LmlzVGFrZW4odGhpcy5fenIsICdnbG9iYWxQYW4nKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB6b29tRGVsdGEgPSBlLnBpbmNoU2NhbGUgPiAxID8gMS4xIDogMSAvIDEuMTtcbiAgem9vbS5jYWxsKHRoaXMsIGUsIHpvb21EZWx0YSwgZS5waW5jaFgsIGUucGluY2hZKTtcbn1cblxuZnVuY3Rpb24gem9vbShlLCB6b29tRGVsdGEsIHpvb21YLCB6b29tWSkge1xuICBpZiAodGhpcy5wb2ludGVyQ2hlY2tlciAmJiB0aGlzLnBvaW50ZXJDaGVja2VyKGUsIHpvb21YLCB6b29tWSkpIHtcbiAgICAvLyBXaGVuIG1vdXNlIGlzIG91dCBvZiByb2FtQ29udHJvbGxlciByZWN0LFxuICAgIC8vIGRlZmF1bHQgYmVmYXZvaXVzIHNob3VsZCBub3QgYmUgYmUgZGlzYWJsZWQsIG90aGVyd2lzZVxuICAgIC8vIHBhZ2Ugc2xpZGluZyBpcyBkaXNhYmxlZCwgY29udHJhcnkgdG8gZXhwZWN0YXRpb24uXG4gICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgdGhpcy50cmlnZ2VyKCd6b29tJywgem9vbURlbHRhLCB6b29tWCwgem9vbVkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrS2V5QmluZGluZyhyb2FtQ29udHJvbGxlciwgcHJvcCwgZSkge1xuICB2YXIgc2V0dGluZyA9IHJvYW1Db250cm9sbGVyLl9vcHRbcHJvcF07XG4gIHJldHVybiBzZXR0aW5nICYmICghenJVdGlsLmlzU3RyaW5nKHNldHRpbmcpIHx8IGUuZXZlbnRbc2V0dGluZyArICdLZXknXSk7XG59XG5cbnZhciBfZGVmYXVsdCA9IFJvYW1Db250cm9sbGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL1JvYW1Db250cm9sbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG5yZXF1aXJlKFwiLi9tYXJrZXIvTWFya1BvaW50TW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL21hcmtlci9NYXJrUG9pbnRWaWV3XCIpO1xuXG4vLyBISU5UIE1hcmtwb2ludCBjYW4ndCBiZSB1c2VkIHRvbyBtdWNoXG5lY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHQpIHtcbiAgLy8gTWFrZSBzdXJlIG1hcmtQb2ludCBjb21wb25lbnQgaXMgZW5hYmxlZFxuICBvcHQubWFya1BvaW50ID0gb3B0Lm1hcmtQb2ludCB8fCB7fTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDI5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBNYXJrZXJNb2RlbCA9IHJlcXVpcmUoXCIuL01hcmtlck1vZGVsXCIpO1xuXG52YXIgX2RlZmF1bHQgPSBNYXJrZXJNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnbWFya1BvaW50JyxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIHpsZXZlbDogMCxcbiAgICB6OiA1LFxuICAgIHN5bWJvbDogJ3BpbicsXG4gICAgc3ltYm9sU2l6ZTogNTAsXG4gICAgLy9zeW1ib2xSb3RhdGU6IDAsXG4gICAgLy9zeW1ib2xPZmZzZXQ6IFswLCAwXVxuICAgIHRvb2x0aXA6IHtcbiAgICAgIHRyaWdnZXI6ICdpdGVtJ1xuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogJ2luc2lkZSdcbiAgICAgIH0sXG4gICAgICBlbXBoYXNpczoge1xuICAgICAgICBzaG93OiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICBib3JkZXJXaWR0aDogMlxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrUG9pbnRNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBTeW1ib2xEcmF3ID0gcmVxdWlyZShcIi4uLy4uL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3XCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIExpc3QgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9MaXN0XCIpO1xuXG52YXIgbWFya2VySGVscGVyID0gcmVxdWlyZShcIi4vbWFya2VySGVscGVyXCIpO1xuXG52YXIgTWFya2VyVmlldyA9IHJlcXVpcmUoXCIuL01hcmtlclZpZXdcIik7XG5cbmZ1bmN0aW9uIHVwZGF0ZU1hcmtlckxheW91dChtcERhdGEsIHNlcmllc01vZGVsLCBhcGkpIHtcbiAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgbXBEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgIHZhciBpdGVtTW9kZWwgPSBtcERhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgdmFyIHBvaW50O1xuICAgIHZhciB4UHggPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChpdGVtTW9kZWwuZ2V0KCd4JyksIGFwaS5nZXRXaWR0aCgpKTtcbiAgICB2YXIgeVB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneScpLCBhcGkuZ2V0SGVpZ2h0KCkpO1xuXG4gICAgaWYgKCFpc05hTih4UHgpICYmICFpc05hTih5UHgpKSB7XG4gICAgICBwb2ludCA9IFt4UHgsIHlQeF07XG4gICAgfSAvLyBDaGFydCBsaWtlIGJhciBtYXkgaGF2ZSB0aGVyZSBvd24gbWFya2VyIHBvc2l0aW9uaW5nIGxvZ2ljXG4gICAgZWxzZSBpZiAoc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24pIHtcbiAgICAgICAgLy8gVXNlIHRoZSBnZXRNYXJrZXJQb2lzaXRpb25cbiAgICAgICAgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbihtcERhdGEuZ2V0VmFsdWVzKG1wRGF0YS5kaW1lbnNpb25zLCBpZHgpKTtcbiAgICAgIH0gZWxzZSBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgdmFyIHggPSBtcERhdGEuZ2V0KGNvb3JkU3lzLmRpbWVuc2lvbnNbMF0sIGlkeCk7XG4gICAgICAgIHZhciB5ID0gbXBEYXRhLmdldChjb29yZFN5cy5kaW1lbnNpb25zWzFdLCBpZHgpO1xuICAgICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSk7XG4gICAgICB9IC8vIFVzZSB4LCB5IGlmIGhhcyBhbnlcblxuXG4gICAgaWYgKCFpc05hTih4UHgpKSB7XG4gICAgICBwb2ludFswXSA9IHhQeDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKHlQeCkpIHtcbiAgICAgIHBvaW50WzFdID0geVB4O1xuICAgIH1cblxuICAgIG1wRGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwgcG9pbnQpO1xuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gTWFya2VyVmlldy5leHRlbmQoe1xuICB0eXBlOiAnbWFya1BvaW50JyxcbiAgdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAobWFya1BvaW50TW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBtcE1vZGVsID0gc2VyaWVzTW9kZWwubWFya1BvaW50TW9kZWw7XG5cbiAgICAgIGlmIChtcE1vZGVsKSB7XG4gICAgICAgIHVwZGF0ZU1hcmtlckxheW91dChtcE1vZGVsLmdldERhdGEoKSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgIHRoaXMubWFya2VyR3JvdXBNYXAuZ2V0KHNlcmllc01vZGVsLmlkKS51cGRhdGVMYXlvdXQobXBNb2RlbCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIHJlbmRlclNlcmllczogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBtcE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBzZXJpZXNJZCA9IHNlcmllc01vZGVsLmlkO1xuICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBzeW1ib2xEcmF3TWFwID0gdGhpcy5tYXJrZXJHcm91cE1hcDtcbiAgICB2YXIgc3ltYm9sRHJhdyA9IHN5bWJvbERyYXdNYXAuZ2V0KHNlcmllc0lkKSB8fCBzeW1ib2xEcmF3TWFwLnNldChzZXJpZXNJZCwgbmV3IFN5bWJvbERyYXcoKSk7XG4gICAgdmFyIG1wRGF0YSA9IGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtcE1vZGVsKTsgLy8gRklYTUVcblxuICAgIG1wTW9kZWwuc2V0RGF0YShtcERhdGEpO1xuICAgIHVwZGF0ZU1hcmtlckxheW91dChtcE1vZGVsLmdldERhdGEoKSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgbXBEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IG1wRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHZhciBzeW1ib2xTaXplID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFNpemUnKTtcblxuICAgICAgaWYgKHR5cGVvZiBzeW1ib2xTaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEZJWE1FIOi/memHjOS4jeWFvOWuuSBFQ2hhcnRzIDIueO+8jDIueCDosozkvLzlj4LmlbDmmK/mlbTkuKrmlbDmja7vvJ9cbiAgICAgICAgc3ltYm9sU2l6ZSA9IHN5bWJvbFNpemUobXBNb2RlbC5nZXRSYXdWYWx1ZShpZHgpLCBtcE1vZGVsLmdldERhdGFQYXJhbXMoaWR4KSk7XG4gICAgICB9XG5cbiAgICAgIG1wRGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICBzeW1ib2xTaXplOiBzeW1ib2xTaXplLFxuICAgICAgICBjb2xvcjogaXRlbU1vZGVsLmdldCgnaXRlbVN0eWxlLm5vcm1hbC5jb2xvcicpIHx8IHNlcmllc0RhdGEuZ2V0VmlzdWFsKCdjb2xvcicpLFxuICAgICAgICBzeW1ib2w6IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2wnKVxuICAgICAgfSk7XG4gICAgfSk7IC8vIFRPRE8gVGV4dCBhcmUgd3JvbmdcblxuICAgIHN5bWJvbERyYXcudXBkYXRlRGF0YShtcERhdGEpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbERyYXcuZ3JvdXApOyAvLyBTZXQgaG9zdCBtb2RlbCBmb3IgdG9vbHRpcFxuICAgIC8vIEZJWE1FXG5cbiAgICBtcERhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuZGF0YU1vZGVsID0gbXBNb2RlbDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHN5bWJvbERyYXcuX19rZWVwID0gdHJ1ZTtcbiAgICBzeW1ib2xEcmF3Lmdyb3VwLnNpbGVudCA9IG1wTW9kZWwuZ2V0KCdzaWxlbnQnKSB8fCBzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuICB9XG59KTtcbi8qKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IFtjb29yZFN5c11cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbXBNb2RlbFxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTGlzdChjb29yZFN5cywgc2VyaWVzTW9kZWwsIG1wTW9kZWwpIHtcbiAgdmFyIGNvb3JkRGltc0luZm9zO1xuXG4gIGlmIChjb29yZFN5cykge1xuICAgIGNvb3JkRGltc0luZm9zID0genJVdGlsLm1hcChjb29yZFN5cyAmJiBjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICAgIHZhciBpbmZvID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmdldERpbWVuc2lvbkluZm8oc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0oY29vcmREaW0pWzBdKSB8fCB7fTsgLy8gSW4gbWFwIHNlcmllcyBkYXRhIGRvbid0IGhhdmUgbG5nIGFuZCBsYXQgZGltZW5zaW9uLiBGYWxsYmFjayB0byBzYW1lIHdpdGggY29vcmRTeXNcblxuICAgICAgaW5mby5uYW1lID0gY29vcmREaW07XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb29yZERpbXNJbmZvcyA9IFt7XG4gICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgdHlwZTogJ2Zsb2F0J1xuICAgIH1dO1xuICB9XG5cbiAgdmFyIG1wRGF0YSA9IG5ldyBMaXN0KGNvb3JkRGltc0luZm9zLCBtcE1vZGVsKTtcbiAgdmFyIGRhdGFPcHQgPSB6clV0aWwubWFwKG1wTW9kZWwuZ2V0KCdkYXRhJyksIHpyVXRpbC5jdXJyeShtYXJrZXJIZWxwZXIuZGF0YVRyYW5zZm9ybSwgc2VyaWVzTW9kZWwpKTtcblxuICBpZiAoY29vcmRTeXMpIHtcbiAgICBkYXRhT3B0ID0genJVdGlsLmZpbHRlcihkYXRhT3B0LCB6clV0aWwuY3VycnkobWFya2VySGVscGVyLmRhdGFGaWx0ZXIsIGNvb3JkU3lzKSk7XG4gIH1cblxuICBtcERhdGEuaW5pdERhdGEoZGF0YU9wdCwgbnVsbCwgY29vcmRTeXMgPyBtYXJrZXJIZWxwZXIuZGltVmFsdWVHZXR0ZXIgOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIG1wRGF0YTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtQb2ludFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDI5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uL2VjaGFydHNcIik7XG5cbnJlcXVpcmUoXCIuL21hcmtlci9NYXJrTGluZU1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9tYXJrZXIvTWFya0xpbmVWaWV3XCIpO1xuXG5lY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHQpIHtcbiAgLy8gTWFrZSBzdXJlIG1hcmtMaW5lIGNvbXBvbmVudCBpcyBlbmFibGVkXG4gIG9wdC5tYXJrTGluZSA9IG9wdC5tYXJrTGluZSB8fCB7fTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIE1hcmtlck1vZGVsID0gcmVxdWlyZShcIi4vTWFya2VyTW9kZWxcIik7XG5cbnZhciBfZGVmYXVsdCA9IE1hcmtlck1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdtYXJrTGluZScsXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogNSxcbiAgICBzeW1ib2w6IFsnY2lyY2xlJywgJ2Fycm93J10sXG4gICAgc3ltYm9sU2l6ZTogWzgsIDE2XSxcbiAgICAvL3N5bWJvbFJvdGF0ZTogMCxcbiAgICBwcmVjaXNpb246IDIsXG4gICAgdG9vbHRpcDoge1xuICAgICAgdHJpZ2dlcjogJ2l0ZW0nXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgbm9ybWFsOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiAnZW5kJ1xuICAgICAgfSxcbiAgICAgIGVtcGhhc2lzOiB7XG4gICAgICAgIHNob3c6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgbm9ybWFsOiB7XG4gICAgICAgIHR5cGU6ICdkYXNoZWQnXG4gICAgICB9LFxuICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgd2lkdGg6IDNcbiAgICAgIH1cbiAgICB9LFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcidcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrTGluZU1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIExpc3QgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9MaXN0XCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIG1hcmtlckhlbHBlciA9IHJlcXVpcmUoXCIuL21hcmtlckhlbHBlclwiKTtcblxudmFyIExpbmVEcmF3ID0gcmVxdWlyZShcIi4uLy4uL2NoYXJ0L2hlbHBlci9MaW5lRHJhd1wiKTtcblxudmFyIE1hcmtlclZpZXcgPSByZXF1aXJlKFwiLi9NYXJrZXJWaWV3XCIpO1xuXG52YXIgbWFya0xpbmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBtbE1vZGVsLCBpdGVtKSB7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpOyAvLyBTcGVjaWFsIHR5cGUgbWFya0xpbmUgbGlrZSAnbWluJywgJ21heCcsICdhdmVyYWdlJ1xuXG4gIHZhciBtbFR5cGUgPSBpdGVtLnR5cGU7XG5cbiAgaWYgKCF6clV0aWwuaXNBcnJheShpdGVtKSAmJiAobWxUeXBlID09PSAnbWluJyB8fCBtbFR5cGUgPT09ICdtYXgnIHx8IG1sVHlwZSA9PT0gJ2F2ZXJhZ2UnIC8vIEluIGNhc2VcbiAgLy8gZGF0YTogW3tcbiAgLy8gICB5QXhpczogMTBcbiAgLy8gfV1cbiAgfHwgaXRlbS54QXhpcyAhPSBudWxsIHx8IGl0ZW0ueUF4aXMgIT0gbnVsbCkpIHtcbiAgICB2YXIgdmFsdWVBeGlzO1xuICAgIHZhciB2YWx1ZURhdGFEaW07XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgaWYgKGl0ZW0ueUF4aXMgIT0gbnVsbCB8fCBpdGVtLnhBeGlzICE9IG51bGwpIHtcbiAgICAgIHZhbHVlRGF0YURpbSA9IGl0ZW0ueUF4aXMgIT0gbnVsbCA/ICd5JyA6ICd4JztcbiAgICAgIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldEF4aXModmFsdWVEYXRhRGltKTtcbiAgICAgIHZhbHVlID0genJVdGlsLnJldHJpZXZlKGl0ZW0ueUF4aXMsIGl0ZW0ueEF4aXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXhpc0luZm8gPSBtYXJrZXJIZWxwZXIuZ2V0QXhpc0luZm8oaXRlbSwgZGF0YSwgY29vcmRTeXMsIHNlcmllc01vZGVsKTtcbiAgICAgIHZhbHVlRGF0YURpbSA9IGF4aXNJbmZvLnZhbHVlRGF0YURpbTtcbiAgICAgIHZhbHVlQXhpcyA9IGF4aXNJbmZvLnZhbHVlQXhpcztcbiAgICAgIHZhbHVlID0gbWFya2VySGVscGVyLm51bUNhbGN1bGF0ZShkYXRhLCB2YWx1ZURhdGFEaW0sIG1sVHlwZSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlSW5kZXggPSB2YWx1ZURhdGFEaW0gPT09ICd4JyA/IDAgOiAxO1xuICAgIHZhciBiYXNlSW5kZXggPSAxIC0gdmFsdWVJbmRleDtcbiAgICB2YXIgbWxGcm9tID0genJVdGlsLmNsb25lKGl0ZW0pO1xuICAgIHZhciBtbFRvID0ge307XG4gICAgbWxGcm9tLnR5cGUgPSBudWxsO1xuICAgIG1sRnJvbS5jb29yZCA9IFtdO1xuICAgIG1sVG8uY29vcmQgPSBbXTtcbiAgICBtbEZyb20uY29vcmRbYmFzZUluZGV4XSA9IC1JbmZpbml0eTtcbiAgICBtbFRvLmNvb3JkW2Jhc2VJbmRleF0gPSBJbmZpbml0eTtcbiAgICB2YXIgcHJlY2lzaW9uID0gbWxNb2RlbC5nZXQoJ3ByZWNpc2lvbicpO1xuXG4gICAgaWYgKHByZWNpc2lvbiA+PSAwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlLnRvRml4ZWQoTWF0aC5taW4ocHJlY2lzaW9uLCAyMCkpO1xuICAgIH1cblxuICAgIG1sRnJvbS5jb29yZFt2YWx1ZUluZGV4XSA9IG1sVG8uY29vcmRbdmFsdWVJbmRleF0gPSB2YWx1ZTtcbiAgICBpdGVtID0gW21sRnJvbSwgbWxUbywge1xuICAgICAgLy8gRXh0cmEgb3B0aW9uIGZvciB0b29sdGlwIGFuZCBsYWJlbFxuICAgICAgdHlwZTogbWxUeXBlLFxuICAgICAgdmFsdWVJbmRleDogaXRlbS52YWx1ZUluZGV4LFxuICAgICAgLy8gRm9yY2UgdG8gdXNlIHRoZSB2YWx1ZSBvZiBjYWxjdWxhdGVkIHZhbHVlLlxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfV07XG4gIH1cblxuICBpdGVtID0gW21hcmtlckhlbHBlci5kYXRhVHJhbnNmb3JtKHNlcmllc01vZGVsLCBpdGVtWzBdKSwgbWFya2VySGVscGVyLmRhdGFUcmFuc2Zvcm0oc2VyaWVzTW9kZWwsIGl0ZW1bMV0pLCB6clV0aWwuZXh0ZW5kKHt9LCBpdGVtWzJdKV07IC8vIEF2b2lkIGxpbmUgZGF0YSB0eXBlIGlzIGV4dGVuZGVkIGJ5IGZyb20odG8pIGRhdGEgdHlwZVxuXG4gIGl0ZW1bMl0udHlwZSA9IGl0ZW1bMl0udHlwZSB8fCAnJzsgLy8gTWVyZ2UgZnJvbSBvcHRpb24gYW5kIHRvIG9wdGlvbiBpbnRvIGxpbmUgb3B0aW9uXG5cbiAgenJVdGlsLm1lcmdlKGl0ZW1bMl0sIGl0ZW1bMF0pO1xuICB6clV0aWwubWVyZ2UoaXRlbVsyXSwgaXRlbVsxXSk7XG4gIHJldHVybiBpdGVtO1xufTtcblxuZnVuY3Rpb24gaXNJbmlmaW5pdHkodmFsKSB7XG4gIHJldHVybiAhaXNOYU4odmFsKSAmJiAhaXNGaW5pdGUodmFsKTtcbn0gLy8gSWYgYSBtYXJrTGluZSBoYXMgb25lIGRpbVxuXG5cbmZ1bmN0aW9uIGlmTWFya0xpbmVIYXNPbmx5RGltKGRpbUluZGV4LCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSB7XG4gIHZhciBvdGhlckRpbUluZGV4ID0gMSAtIGRpbUluZGV4O1xuICB2YXIgZGltTmFtZSA9IGNvb3JkU3lzLmRpbWVuc2lvbnNbZGltSW5kZXhdO1xuICByZXR1cm4gaXNJbmlmaW5pdHkoZnJvbUNvb3JkW290aGVyRGltSW5kZXhdKSAmJiBpc0luaWZpbml0eSh0b0Nvb3JkW290aGVyRGltSW5kZXhdKSAmJiBmcm9tQ29vcmRbZGltSW5kZXhdID09PSB0b0Nvb3JkW2RpbUluZGV4XSAmJiBjb29yZFN5cy5nZXRBeGlzKGRpbU5hbWUpLmNvbnRhaW5EYXRhKGZyb21Db29yZFtkaW1JbmRleF0pO1xufVxuXG5mdW5jdGlvbiBtYXJrTGluZUZpbHRlcihjb29yZFN5cywgaXRlbSkge1xuICBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgIHZhciBmcm9tQ29vcmQgPSBpdGVtWzBdLmNvb3JkO1xuICAgIHZhciB0b0Nvb3JkID0gaXRlbVsxXS5jb29yZDsgLy8gSW4gY2FzZVxuICAgIC8vIHtcbiAgICAvLyAgbWFya0xpbmU6IHtcbiAgICAvLyAgICBkYXRhOiBbeyB5QXhpczogMiB9XVxuICAgIC8vICB9XG4gICAgLy8gfVxuXG4gICAgaWYgKGZyb21Db29yZCAmJiB0b0Nvb3JkICYmIChpZk1hcmtMaW5lSGFzT25seURpbSgxLCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSB8fCBpZk1hcmtMaW5lSGFzT25seURpbSgwLCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXJrZXJIZWxwZXIuZGF0YUZpbHRlcihjb29yZFN5cywgaXRlbVswXSkgJiYgbWFya2VySGVscGVyLmRhdGFGaWx0ZXIoY29vcmRTeXMsIGl0ZW1bMV0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQoZGF0YSwgaWR4LCBpc0Zyb20sIHNlcmllc01vZGVsLCBhcGkpIHtcbiAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gIHZhciBwb2ludDtcbiAgdmFyIHhQeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGl0ZW1Nb2RlbC5nZXQoJ3gnKSwgYXBpLmdldFdpZHRoKCkpO1xuICB2YXIgeVB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneScpLCBhcGkuZ2V0SGVpZ2h0KCkpO1xuXG4gIGlmICghaXNOYU4oeFB4KSAmJiAhaXNOYU4oeVB4KSkge1xuICAgIHBvaW50ID0gW3hQeCwgeVB4XTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDaGFydCBsaWtlIGJhciBtYXkgaGF2ZSB0aGVyZSBvd24gbWFya2VyIHBvc2l0aW9uaW5nIGxvZ2ljXG4gICAgaWYgKHNlcmllc01vZGVsLmdldE1hcmtlclBvc2l0aW9uKSB7XG4gICAgICAvLyBVc2UgdGhlIGdldE1hcmtlclBvaXNpdGlvblxuICAgICAgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbihkYXRhLmdldFZhbHVlcyhkYXRhLmRpbWVuc2lvbnMsIGlkeCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICB2YXIgeCA9IGRhdGEuZ2V0KGRpbXNbMF0sIGlkeCk7XG4gICAgICB2YXIgeSA9IGRhdGEuZ2V0KGRpbXNbMV0sIGlkeCk7XG4gICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSk7XG4gICAgfSAvLyBFeHBhbmQgbGluZSB0byB0aGUgZWRnZSBvZiBncmlkIGlmIHZhbHVlIG9uIG9uZSBheGlzIGlzIEluaWZuaXR5XG4gICAgLy8gSW4gY2FzZVxuICAgIC8vICBtYXJrTGluZToge1xuICAgIC8vICAgIGRhdGE6IFt7XG4gICAgLy8gICAgICB5QXhpczogMlxuICAgIC8vICAgICAgLy8gb3JcbiAgICAvLyAgICAgIHR5cGU6ICdhdmVyYWdlJ1xuICAgIC8vICAgIH1dXG4gICAgLy8gIH1cblxuXG4gICAgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgIHZhciB4QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3gnKTtcbiAgICAgIHZhciB5QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3knKTtcbiAgICAgIHZhciBkaW1zID0gY29vcmRTeXMuZGltZW5zaW9ucztcblxuICAgICAgaWYgKGlzSW5pZmluaXR5KGRhdGEuZ2V0KGRpbXNbMF0sIGlkeCkpKSB7XG4gICAgICAgIHBvaW50WzBdID0geEF4aXMudG9HbG9iYWxDb29yZCh4QXhpcy5nZXRFeHRlbnQoKVtpc0Zyb20gPyAwIDogMV0pO1xuICAgICAgfSBlbHNlIGlmIChpc0luaWZpbml0eShkYXRhLmdldChkaW1zWzFdLCBpZHgpKSkge1xuICAgICAgICBwb2ludFsxXSA9IHlBeGlzLnRvR2xvYmFsQ29vcmQoeUF4aXMuZ2V0RXh0ZW50KClbaXNGcm9tID8gMCA6IDFdKTtcbiAgICAgIH1cbiAgICB9IC8vIFVzZSB4LCB5IGlmIGhhcyBhbnlcblxuXG4gICAgaWYgKCFpc05hTih4UHgpKSB7XG4gICAgICBwb2ludFswXSA9IHhQeDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKHlQeCkpIHtcbiAgICAgIHBvaW50WzFdID0geVB4O1xuICAgIH1cbiAgfVxuXG4gIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHBvaW50KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gTWFya2VyVmlldy5leHRlbmQoe1xuICB0eXBlOiAnbWFya0xpbmUnLFxuICB1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uIChtYXJrTGluZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgbWxNb2RlbCA9IHNlcmllc01vZGVsLm1hcmtMaW5lTW9kZWw7XG5cbiAgICAgIGlmIChtbE1vZGVsKSB7XG4gICAgICAgIHZhciBtbERhdGEgPSBtbE1vZGVsLmdldERhdGEoKTtcbiAgICAgICAgdmFyIGZyb21EYXRhID0gbWxNb2RlbC5fX2Zyb207XG4gICAgICAgIHZhciB0b0RhdGEgPSBtbE1vZGVsLl9fdG87IC8vIFVwZGF0ZSB2aXN1YWwgYW5kIGxheW91dCBvZiBmcm9tIHN5bWJvbCBhbmQgdG8gc3ltYm9sXG5cbiAgICAgICAgZnJvbURhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgdXBkYXRlU2luZ2xlTWFya2VyRW5kTGF5b3V0KGZyb21EYXRhLCBpZHgsIHRydWUsIHNlcmllc01vZGVsLCBhcGkpO1xuICAgICAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dCh0b0RhdGEsIGlkeCwgZmFsc2UsIHNlcmllc01vZGVsLCBhcGkpO1xuICAgICAgICB9KTsgLy8gVXBkYXRlIGxheW91dCBvZiBsaW5lXG5cbiAgICAgICAgbWxEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgIG1sRGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwgW2Zyb21EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSwgdG9EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrZXJHcm91cE1hcC5nZXQoc2VyaWVzTW9kZWwuaWQpLnVwZGF0ZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuICByZW5kZXJTZXJpZXM6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgbWxNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgc2VyaWVzSWQgPSBzZXJpZXNNb2RlbC5pZDtcbiAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgbGluZURyYXdNYXAgPSB0aGlzLm1hcmtlckdyb3VwTWFwO1xuICAgIHZhciBsaW5lRHJhdyA9IGxpbmVEcmF3TWFwLmdldChzZXJpZXNJZCkgfHwgbGluZURyYXdNYXAuc2V0KHNlcmllc0lkLCBuZXcgTGluZURyYXcoKSk7XG4gICAgdGhpcy5ncm91cC5hZGQobGluZURyYXcuZ3JvdXApO1xuICAgIHZhciBtbERhdGEgPSBjcmVhdGVMaXN0KGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgbWxNb2RlbCk7XG4gICAgdmFyIGZyb21EYXRhID0gbWxEYXRhLmZyb207XG4gICAgdmFyIHRvRGF0YSA9IG1sRGF0YS50bztcbiAgICB2YXIgbGluZURhdGEgPSBtbERhdGEubGluZTtcbiAgICBtbE1vZGVsLl9fZnJvbSA9IGZyb21EYXRhO1xuICAgIG1sTW9kZWwuX190byA9IHRvRGF0YTsgLy8gTGluZSBkYXRhIGZvciB0b29sdGlwIGFuZCBmb3JtYXR0ZXJcblxuICAgIG1sTW9kZWwuc2V0RGF0YShsaW5lRGF0YSk7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSBtbE1vZGVsLmdldCgnc3ltYm9sJyk7XG4gICAgdmFyIHN5bWJvbFNpemUgPSBtbE1vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuXG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShzeW1ib2xUeXBlKSkge1xuICAgICAgc3ltYm9sVHlwZSA9IFtzeW1ib2xUeXBlLCBzeW1ib2xUeXBlXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHN5bWJvbFNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICBzeW1ib2xTaXplID0gW3N5bWJvbFNpemUsIHN5bWJvbFNpemVdO1xuICAgIH0gLy8gVXBkYXRlIHZpc3VhbCBhbmQgbGF5b3V0IG9mIGZyb20gc3ltYm9sIGFuZCB0byBzeW1ib2xcblxuXG4gICAgbWxEYXRhLmZyb20uZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB1cGRhdGVEYXRhVmlzdWFsQW5kTGF5b3V0KGZyb21EYXRhLCBpZHgsIHRydWUpO1xuICAgICAgdXBkYXRlRGF0YVZpc3VhbEFuZExheW91dCh0b0RhdGEsIGlkeCwgZmFsc2UpO1xuICAgIH0pOyAvLyBVcGRhdGUgdmlzdWFsIGFuZCBsYXlvdXQgb2YgbGluZVxuXG4gICAgbGluZURhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgbGluZUNvbG9yID0gbGluZURhdGEuZ2V0SXRlbU1vZGVsKGlkeCkuZ2V0KCdsaW5lU3R5bGUubm9ybWFsLmNvbG9yJyk7XG4gICAgICBsaW5lRGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICBjb2xvcjogbGluZUNvbG9yIHx8IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKVxuICAgICAgfSk7XG4gICAgICBsaW5lRGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwgW2Zyb21EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSwgdG9EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KV0pO1xuICAgICAgbGluZURhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgICAgJ2Zyb21TeW1ib2xTaXplJzogZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJyksXG4gICAgICAgICdmcm9tU3ltYm9sJzogZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSxcbiAgICAgICAgJ3RvU3ltYm9sU2l6ZSc6IHRvRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKSxcbiAgICAgICAgJ3RvU3ltYm9sJzogdG9EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJylcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGxpbmVEcmF3LnVwZGF0ZURhdGEobGluZURhdGEpOyAvLyBTZXQgaG9zdCBtb2RlbCBmb3IgdG9vbHRpcFxuICAgIC8vIEZJWE1FXG5cbiAgICBtbERhdGEubGluZS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLmRhdGFNb2RlbCA9IG1sTW9kZWw7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZURhdGFWaXN1YWxBbmRMYXlvdXQoZGF0YSwgaWR4LCBpc0Zyb20pIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdXBkYXRlU2luZ2xlTWFya2VyRW5kTGF5b3V0KGRhdGEsIGlkeCwgaXNGcm9tLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgICAgc3ltYm9sU2l6ZTogaXRlbU1vZGVsLmdldCgnc3ltYm9sU2l6ZScpIHx8IHN5bWJvbFNpemVbaXNGcm9tID8gMCA6IDFdLFxuICAgICAgICBzeW1ib2w6IGl0ZW1Nb2RlbC5nZXQoJ3N5bWJvbCcsIHRydWUpIHx8IHN5bWJvbFR5cGVbaXNGcm9tID8gMCA6IDFdLFxuICAgICAgICBjb2xvcjogaXRlbU1vZGVsLmdldCgnaXRlbVN0eWxlLm5vcm1hbC5jb2xvcicpIHx8IHNlcmllc0RhdGEuZ2V0VmlzdWFsKCdjb2xvcicpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsaW5lRHJhdy5fX2tlZXAgPSB0cnVlO1xuICAgIGxpbmVEcmF3Lmdyb3VwLnNpbGVudCA9IG1sTW9kZWwuZ2V0KCdzaWxlbnQnKSB8fCBzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuICB9XG59KTtcbi8qKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IGNvb3JkU3lzXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG1wTW9kZWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtbE1vZGVsKSB7XG4gIHZhciBjb29yZERpbXNJbmZvcztcblxuICBpZiAoY29vcmRTeXMpIHtcbiAgICBjb29yZERpbXNJbmZvcyA9IHpyVXRpbC5tYXAoY29vcmRTeXMgJiYgY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgICB2YXIgaW5mbyA9IHNlcmllc01vZGVsLmdldERhdGEoKS5nZXREaW1lbnNpb25JbmZvKHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGNvb3JkRGltKVswXSkgfHwge307IC8vIEluIG1hcCBzZXJpZXMgZGF0YSBkb24ndCBoYXZlIGxuZyBhbmQgbGF0IGRpbWVuc2lvbi4gRmFsbGJhY2sgdG8gc2FtZSB3aXRoIGNvb3JkU3lzXG5cbiAgICAgIGluZm8ubmFtZSA9IGNvb3JkRGltO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29vcmREaW1zSW5mb3MgPSBbe1xuICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgIHR5cGU6ICdmbG9hdCdcbiAgICB9XTtcbiAgfVxuXG4gIHZhciBmcm9tRGF0YSA9IG5ldyBMaXN0KGNvb3JkRGltc0luZm9zLCBtbE1vZGVsKTtcbiAgdmFyIHRvRGF0YSA9IG5ldyBMaXN0KGNvb3JkRGltc0luZm9zLCBtbE1vZGVsKTsgLy8gTm8gZGltZW5zaW9uc1xuXG4gIHZhciBsaW5lRGF0YSA9IG5ldyBMaXN0KFtdLCBtbE1vZGVsKTtcbiAgdmFyIG9wdERhdGEgPSB6clV0aWwubWFwKG1sTW9kZWwuZ2V0KCdkYXRhJyksIHpyVXRpbC5jdXJyeShtYXJrTGluZVRyYW5zZm9ybSwgc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBtbE1vZGVsKSk7XG5cbiAgaWYgKGNvb3JkU3lzKSB7XG4gICAgb3B0RGF0YSA9IHpyVXRpbC5maWx0ZXIob3B0RGF0YSwgenJVdGlsLmN1cnJ5KG1hcmtMaW5lRmlsdGVyLCBjb29yZFN5cykpO1xuICB9XG5cbiAgdmFyIGRpbVZhbHVlR2V0dGVyID0gY29vcmRTeXMgPyBtYXJrZXJIZWxwZXIuZGltVmFsdWVHZXR0ZXIgOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICB9O1xuICBmcm9tRGF0YS5pbml0RGF0YSh6clV0aWwubWFwKG9wdERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bMF07XG4gIH0pLCBudWxsLCBkaW1WYWx1ZUdldHRlcik7XG4gIHRvRGF0YS5pbml0RGF0YSh6clV0aWwubWFwKG9wdERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bMV07XG4gIH0pLCBudWxsLCBkaW1WYWx1ZUdldHRlcik7XG4gIGxpbmVEYXRhLmluaXREYXRhKHpyVXRpbC5tYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVsyXTtcbiAgfSkpO1xuICBsaW5lRGF0YS5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBmcm9tRGF0YSxcbiAgICB0bzogdG9EYXRhLFxuICAgIGxpbmU6IGxpbmVEYXRhXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrTGluZVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDI5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIExpbmVHcm91cCA9IHJlcXVpcmUoXCIuL0xpbmVcIik7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NoYXJ0L2hlbHBlci9MaW5lRHJhd1xuICovXG5mdW5jdGlvbiBpc1BvaW50TmFOKHB0KSB7XG4gIHJldHVybiBpc05hTihwdFswXSkgfHwgaXNOYU4ocHRbMV0pO1xufVxuXG5mdW5jdGlvbiBsaW5lTmVlZHNEcmF3KHB0cykge1xuICByZXR1cm4gIWlzUG9pbnROYU4ocHRzWzBdKSAmJiAhaXNQb2ludE5hTihwdHNbMV0pO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29tcG9uZW50L21hcmtlci9MaW5lRHJhd1xuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG5mdW5jdGlvbiBMaW5lRHJhdyhjdG9yKSB7XG4gIHRoaXMuX2N0b3IgPSBjdG9yIHx8IExpbmVHcm91cDtcbiAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG59XG5cbnZhciBsaW5lRHJhd1Byb3RvID0gTGluZURyYXcucHJvdG90eXBlO1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gbGluZURhdGFcbiAqL1xuXG5saW5lRHJhd1Byb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAobGluZURhdGEpIHtcbiAgdmFyIG9sZExpbmVEYXRhID0gdGhpcy5fbGluZURhdGE7XG4gIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gIHZhciBMaW5lQ3RvciA9IHRoaXMuX2N0b3I7XG4gIHZhciBob3N0TW9kZWwgPSBsaW5lRGF0YS5ob3N0TW9kZWw7XG4gIHZhciBzZXJpZXNTY29wZSA9IHtcbiAgICBsaW5lU3R5bGU6IGhvc3RNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlLm5vcm1hbCcpLmdldExpbmVTdHlsZSgpLFxuICAgIGhvdmVyTGluZVN0eWxlOiBob3N0TW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5lbXBoYXNpcycpLmdldExpbmVTdHlsZSgpLFxuICAgIGxhYmVsTW9kZWw6IGhvc3RNb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyksXG4gICAgaG92ZXJMYWJlbE1vZGVsOiBob3N0TW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLmVtcGhhc2lzJylcbiAgfTtcbiAgbGluZURhdGEuZGlmZihvbGRMaW5lRGF0YSkuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICBpZiAoIWxpbmVOZWVkc0RyYXcobGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsaW5lR3JvdXAgPSBuZXcgTGluZUN0b3IobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xuICAgIGxpbmVEYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBsaW5lR3JvdXApO1xuICAgIGdyb3VwLmFkZChsaW5lR3JvdXApO1xuICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgdmFyIGxpbmVHcm91cCA9IG9sZExpbmVEYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcblxuICAgIGlmICghbGluZU5lZWRzRHJhdyhsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KG5ld0lkeCkpKSB7XG4gICAgICBncm91cC5yZW1vdmUobGluZUdyb3VwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWxpbmVHcm91cCkge1xuICAgICAgbGluZUdyb3VwID0gbmV3IExpbmVDdG9yKGxpbmVEYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZUdyb3VwLnVwZGF0ZURhdGEobGluZURhdGEsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICAgIH1cblxuICAgIGxpbmVEYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBsaW5lR3JvdXApO1xuICAgIGdyb3VwLmFkZChsaW5lR3JvdXApO1xuICB9KS5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgIGdyb3VwLnJlbW92ZShvbGRMaW5lRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCkpO1xuICB9KS5leGVjdXRlKCk7XG4gIHRoaXMuX2xpbmVEYXRhID0gbGluZURhdGE7XG59O1xuXG5saW5lRHJhd1Byb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxpbmVEYXRhID0gdGhpcy5fbGluZURhdGE7XG4gIGxpbmVEYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgZWwudXBkYXRlTGF5b3V0KGxpbmVEYXRhLCBpZHgpO1xuICB9LCB0aGlzKTtcbn07XG5cbmxpbmVEcmF3UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xufTtcblxudmFyIF9kZWZhdWx0ID0gTGluZURyYXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9MaW5lRHJhdy5qc1xuLy8gbW9kdWxlIGlkID0gMjk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciB2ZWN0b3IgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS92ZWN0b3JcIik7XG5cbnZhciBzeW1ib2xVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvc3ltYm9sXCIpO1xuXG52YXIgTGluZVBhdGggPSByZXF1aXJlKFwiLi9MaW5lUGF0aFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIHJvdW5kID0gX251bWJlci5yb3VuZDtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL0xpbmVcbiAqL1xudmFyIFNZTUJPTF9DQVRFR09SSUVTID0gWydmcm9tU3ltYm9sJywgJ3RvU3ltYm9sJ107XG5cbmZ1bmN0aW9uIG1ha2VTeW1ib2xUeXBlS2V5KHN5bWJvbENhdGVnb3J5KSB7XG4gIHJldHVybiAnXycgKyBzeW1ib2xDYXRlZ29yeSArICdUeXBlJztcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVTeW1ib2wobmFtZSwgbGluZURhdGEsIGlkeCkge1xuICB2YXIgY29sb3IgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7XG4gIHZhciBzeW1ib2xUeXBlID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsIG5hbWUpO1xuICB2YXIgc3ltYm9sU2l6ZSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBuYW1lICsgJ1NpemUnKTtcblxuICBpZiAoIXN5bWJvbFR5cGUgfHwgc3ltYm9sVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF6clV0aWwuaXNBcnJheShzeW1ib2xTaXplKSkge1xuICAgIHN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XG4gIH1cblxuICB2YXIgc3ltYm9sUGF0aCA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIC1zeW1ib2xTaXplWzBdIC8gMiwgLXN5bWJvbFNpemVbMV0gLyAyLCBzeW1ib2xTaXplWzBdLCBzeW1ib2xTaXplWzFdLCBjb2xvcik7XG4gIHN5bWJvbFBhdGgubmFtZSA9IG5hbWU7XG4gIHJldHVybiBzeW1ib2xQYXRoO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5lKHBvaW50cykge1xuICB2YXIgbGluZSA9IG5ldyBMaW5lUGF0aCh7XG4gICAgbmFtZTogJ2xpbmUnXG4gIH0pO1xuICBzZXRMaW5lUG9pbnRzKGxpbmUuc2hhcGUsIHBvaW50cyk7XG4gIHJldHVybiBsaW5lO1xufVxuXG5mdW5jdGlvbiBzZXRMaW5lUG9pbnRzKHRhcmdldFNoYXBlLCBwb2ludHMpIHtcbiAgdmFyIHAxID0gcG9pbnRzWzBdO1xuICB2YXIgcDIgPSBwb2ludHNbMV07XG4gIHZhciBjcDEgPSBwb2ludHNbMl07XG4gIHRhcmdldFNoYXBlLngxID0gcDFbMF07XG4gIHRhcmdldFNoYXBlLnkxID0gcDFbMV07XG4gIHRhcmdldFNoYXBlLngyID0gcDJbMF07XG4gIHRhcmdldFNoYXBlLnkyID0gcDJbMV07XG4gIHRhcmdldFNoYXBlLnBlcmNlbnQgPSAxO1xuXG4gIGlmIChjcDEpIHtcbiAgICB0YXJnZXRTaGFwZS5jcHgxID0gY3AxWzBdO1xuICAgIHRhcmdldFNoYXBlLmNweTEgPSBjcDFbMV07XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0U2hhcGUuY3B4MSA9IE5hTjtcbiAgICB0YXJnZXRTaGFwZS5jcHkxID0gTmFOO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN5bWJvbEFuZExhYmVsQmVmb3JlTGluZVVwZGF0ZSgpIHtcbiAgdmFyIGxpbmVHcm91cCA9IHRoaXM7XG4gIHZhciBzeW1ib2xGcm9tID0gbGluZUdyb3VwLmNoaWxkT2ZOYW1lKCdmcm9tU3ltYm9sJyk7XG4gIHZhciBzeW1ib2xUbyA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcbiAgdmFyIGxhYmVsID0gbGluZUdyb3VwLmNoaWxkT2ZOYW1lKCdsYWJlbCcpOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoIXN5bWJvbEZyb20gJiYgIXN5bWJvbFRvICYmIGxhYmVsLmlnbm9yZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbnZTY2FsZSA9IDE7XG4gIHZhciBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnQ7XG5cbiAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5zY2FsZSkge1xuICAgICAgaW52U2NhbGUgLz0gcGFyZW50Tm9kZS5zY2FsZVswXTtcbiAgICB9XG5cbiAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQ7XG4gIH1cblxuICB2YXIgbGluZSA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgnbGluZScpOyAvLyBJZiBsaW5lIG5vdCBjaGFuZ2VkXG4gIC8vIEZJWE1FIFBhcmVudCBzY2FsZSBjaGFuZ2VkXG5cbiAgaWYgKCF0aGlzLl9fZGlydHkgJiYgIWxpbmUuX19kaXJ0eSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwZXJjZW50ID0gbGluZS5zaGFwZS5wZXJjZW50O1xuICB2YXIgZnJvbVBvcyA9IGxpbmUucG9pbnRBdCgwKTtcbiAgdmFyIHRvUG9zID0gbGluZS5wb2ludEF0KHBlcmNlbnQpO1xuICB2YXIgZCA9IHZlY3Rvci5zdWIoW10sIHRvUG9zLCBmcm9tUG9zKTtcbiAgdmVjdG9yLm5vcm1hbGl6ZShkLCBkKTtcblxuICBpZiAoc3ltYm9sRnJvbSkge1xuICAgIHN5bWJvbEZyb20uYXR0cigncG9zaXRpb24nLCBmcm9tUG9zKTtcbiAgICB2YXIgdGFuZ2VudCA9IGxpbmUudGFuZ2VudEF0KDApO1xuICAgIHN5bWJvbEZyb20uYXR0cigncm90YXRpb24nLCBNYXRoLlBJIC8gMiAtIE1hdGguYXRhbjIodGFuZ2VudFsxXSwgdGFuZ2VudFswXSkpO1xuICAgIHN5bWJvbEZyb20uYXR0cignc2NhbGUnLCBbaW52U2NhbGUgKiBwZXJjZW50LCBpbnZTY2FsZSAqIHBlcmNlbnRdKTtcbiAgfVxuXG4gIGlmIChzeW1ib2xUbykge1xuICAgIHN5bWJvbFRvLmF0dHIoJ3Bvc2l0aW9uJywgdG9Qb3MpO1xuICAgIHZhciB0YW5nZW50ID0gbGluZS50YW5nZW50QXQoMSk7XG4gICAgc3ltYm9sVG8uYXR0cigncm90YXRpb24nLCAtTWF0aC5QSSAvIDIgLSBNYXRoLmF0YW4yKHRhbmdlbnRbMV0sIHRhbmdlbnRbMF0pKTtcbiAgICBzeW1ib2xUby5hdHRyKCdzY2FsZScsIFtpbnZTY2FsZSAqIHBlcmNlbnQsIGludlNjYWxlICogcGVyY2VudF0pO1xuICB9XG5cbiAgaWYgKCFsYWJlbC5pZ25vcmUpIHtcbiAgICBsYWJlbC5hdHRyKCdwb3NpdGlvbicsIHRvUG9zKTtcbiAgICB2YXIgdGV4dFBvc2l0aW9uO1xuICAgIHZhciB0ZXh0QWxpZ247XG4gICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduO1xuICAgIHZhciBkaXN0YW5jZSA9IDUgKiBpbnZTY2FsZTsgLy8gRW5kXG5cbiAgICBpZiAobGFiZWwuX19wb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgIHRleHRQb3NpdGlvbiA9IFtkWzBdICogZGlzdGFuY2UgKyB0b1Bvc1swXSwgZFsxXSAqIGRpc3RhbmNlICsgdG9Qb3NbMV1dO1xuICAgICAgdGV4dEFsaWduID0gZFswXSA+IDAuOCA/ICdsZWZ0JyA6IGRbMF0gPCAtMC44ID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBkWzFdID4gMC44ID8gJ3RvcCcgOiBkWzFdIDwgLTAuOCA/ICdib3R0b20nIDogJ21pZGRsZSc7XG4gICAgfSAvLyBNaWRkbGVcbiAgICBlbHNlIGlmIChsYWJlbC5fX3Bvc2l0aW9uID09PSAnbWlkZGxlJykge1xuICAgICAgICB2YXIgaGFsZlBlcmNlbnQgPSBwZXJjZW50IC8gMjtcbiAgICAgICAgdmFyIHRhbmdlbnQgPSBsaW5lLnRhbmdlbnRBdChoYWxmUGVyY2VudCk7XG4gICAgICAgIHZhciBuID0gW3RhbmdlbnRbMV0sIC10YW5nZW50WzBdXTtcbiAgICAgICAgdmFyIGNwID0gbGluZS5wb2ludEF0KGhhbGZQZXJjZW50KTtcblxuICAgICAgICBpZiAoblsxXSA+IDApIHtcbiAgICAgICAgICBuWzBdID0gLW5bMF07XG4gICAgICAgICAgblsxXSA9IC1uWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dFBvc2l0aW9uID0gW2NwWzBdICsgblswXSAqIGRpc3RhbmNlLCBjcFsxXSArIG5bMV0gKiBkaXN0YW5jZV07XG4gICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgICB2YXIgcm90YXRpb24gPSAtTWF0aC5hdGFuMih0YW5nZW50WzFdLCB0YW5nZW50WzBdKTtcblxuICAgICAgICBpZiAodG9Qb3NbMF0gPCBmcm9tUG9zWzBdKSB7XG4gICAgICAgICAgcm90YXRpb24gPSBNYXRoLlBJICsgcm90YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbC5hdHRyKCdyb3RhdGlvbicsIHJvdGF0aW9uKTtcbiAgICAgIH0gLy8gU3RhcnRcbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHRleHRQb3NpdGlvbiA9IFstZFswXSAqIGRpc3RhbmNlICsgZnJvbVBvc1swXSwgLWRbMV0gKiBkaXN0YW5jZSArIGZyb21Qb3NbMV1dO1xuICAgICAgICAgIHRleHRBbGlnbiA9IGRbMF0gPiAwLjggPyAncmlnaHQnIDogZFswXSA8IC0wLjggPyAnbGVmdCcgOiAnY2VudGVyJztcbiAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRbMV0gPiAwLjggPyAnYm90dG9tJyA6IGRbMV0gPCAtMC44ID8gJ3RvcCcgOiAnbWlkZGxlJztcbiAgICAgICAgfVxuXG4gICAgbGFiZWwuYXR0cih7XG4gICAgICBzdHlsZToge1xuICAgICAgICAvLyBVc2UgdGhlIHVzZXIgc3BlY2lmaWVkIHRleHQgYWxpZ24gYW5kIGJhc2VsaW5lIGZpcnN0XG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiBsYWJlbC5fX3ZlcnRpY2FsQWxpZ24gfHwgdGV4dFZlcnRpY2FsQWxpZ24sXG4gICAgICAgIHRleHRBbGlnbjogbGFiZWwuX190ZXh0QWxpZ24gfHwgdGV4dEFsaWduXG4gICAgICB9LFxuICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgIHNjYWxlOiBbaW52U2NhbGUsIGludlNjYWxlXVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gKiBAYWxpYXMge21vZHVsZTplY2hhcnRzL2NoYXJ0L2hlbHBlci9MaW5lfVxuICovXG5cblxuZnVuY3Rpb24gTGluZShsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICBncmFwaGljLkdyb3VwLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5fY3JlYXRlTGluZShsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG59XG5cbnZhciBsaW5lUHJvdG8gPSBMaW5lLnByb3RvdHlwZTsgLy8gVXBkYXRlIHN5bWJvbCBwb3NpdGlvbiBhbmQgcm90YXRpb25cblxubGluZVByb3RvLmJlZm9yZVVwZGF0ZSA9IHVwZGF0ZVN5bWJvbEFuZExhYmVsQmVmb3JlTGluZVVwZGF0ZTtcblxubGluZVByb3RvLl9jcmVhdGVMaW5lID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGxpbmVEYXRhLmhvc3RNb2RlbDtcbiAgdmFyIGxpbmVQb2ludHMgPSBsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gIHZhciBsaW5lID0gY3JlYXRlTGluZShsaW5lUG9pbnRzKTtcbiAgbGluZS5zaGFwZS5wZXJjZW50ID0gMDtcbiAgZ3JhcGhpYy5pbml0UHJvcHMobGluZSwge1xuICAgIHNoYXBlOiB7XG4gICAgICBwZXJjZW50OiAxXG4gICAgfVxuICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgdGhpcy5hZGQobGluZSk7XG4gIHZhciBsYWJlbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgIG5hbWU6ICdsYWJlbCdcbiAgfSk7XG4gIHRoaXMuYWRkKGxhYmVsKTtcbiAgenJVdGlsLmVhY2goU1lNQk9MX0NBVEVHT1JJRVMsIGZ1bmN0aW9uIChzeW1ib2xDYXRlZ29yeSkge1xuICAgIHZhciBzeW1ib2wgPSBjcmVhdGVTeW1ib2woc3ltYm9sQ2F0ZWdvcnksIGxpbmVEYXRhLCBpZHgpOyAvLyBzeW1ib2xzIG11c3QgYWRkZWQgYWZ0ZXIgbGluZSB0byBtYWtlIHN1cmVcbiAgICAvLyBpdCB3aWxsIGJlIHVwZGF0ZWQgYWZ0ZXIgbGluZSN1cGRhdGUuXG4gICAgLy8gT3Igc3ltYm9sIHBvc2l0aW9uIGFuZCByb3RhdGlvbiB1cGRhdGUgaW4gbGluZSNiZWZvcmVVcGRhdGUgd2lsbCBiZSBvbmUgZnJhbWUgc2xvd1xuXG4gICAgdGhpcy5hZGQoc3ltYm9sKTtcbiAgICB0aGlzW21ha2VTeW1ib2xUeXBlS2V5KHN5bWJvbENhdGVnb3J5KV0gPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgc3ltYm9sQ2F0ZWdvcnkpO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl91cGRhdGVDb21tb25TdGwobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xufTtcblxubGluZVByb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgdmFyIHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICB2YXIgbGluZSA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmUnKTtcbiAgdmFyIGxpbmVQb2ludHMgPSBsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gIHZhciB0YXJnZXQgPSB7XG4gICAgc2hhcGU6IHt9XG4gIH07XG4gIHNldExpbmVQb2ludHModGFyZ2V0LnNoYXBlLCBsaW5lUG9pbnRzKTtcbiAgZ3JhcGhpYy51cGRhdGVQcm9wcyhsaW5lLCB0YXJnZXQsIHNlcmllc01vZGVsLCBpZHgpO1xuICB6clV0aWwuZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgc3ltYm9sQ2F0ZWdvcnkpO1xuICAgIHZhciBrZXkgPSBtYWtlU3ltYm9sVHlwZUtleShzeW1ib2xDYXRlZ29yeSk7IC8vIFN5bWJvbCBjaGFuZ2VkXG5cbiAgICBpZiAodGhpc1trZXldICE9PSBzeW1ib2xUeXBlKSB7XG4gICAgICB0aGlzLnJlbW92ZSh0aGlzLmNoaWxkT2ZOYW1lKHN5bWJvbENhdGVnb3J5KSk7XG4gICAgICB2YXIgc3ltYm9sID0gY3JlYXRlU3ltYm9sKHN5bWJvbENhdGVnb3J5LCBsaW5lRGF0YSwgaWR4KTtcbiAgICAgIHRoaXMuYWRkKHN5bWJvbCk7XG4gICAgfVxuXG4gICAgdGhpc1trZXldID0gc3ltYm9sVHlwZTtcbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5fdXBkYXRlQ29tbW9uU3RsKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbn07XG5cbmxpbmVQcm90by5fdXBkYXRlQ29tbW9uU3RsID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGxpbmVEYXRhLmhvc3RNb2RlbDtcbiAgdmFyIGxpbmUgPSB0aGlzLmNoaWxkT2ZOYW1lKCdsaW5lJyk7XG4gIHZhciBsaW5lU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5saW5lU3R5bGU7XG4gIHZhciBob3ZlckxpbmVTdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVyTGluZVN0eWxlO1xuICB2YXIgbGFiZWxNb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmxhYmVsTW9kZWw7XG4gIHZhciBob3ZlckxhYmVsTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5ob3ZlckxhYmVsTW9kZWw7IC8vIE9wdGltaXphdGlvbiBmb3IgbGFyZ2UgZGF0YXNldFxuXG4gIGlmICghc2VyaWVzU2NvcGUgfHwgbGluZURhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgIHZhciBpdGVtTW9kZWwgPSBsaW5lRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICBsaW5lU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5ub3JtYWwnKS5nZXRMaW5lU3R5bGUoKTtcbiAgICBob3ZlckxpbmVTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlLmVtcGhhc2lzJykuZ2V0TGluZVN0eWxlKCk7XG4gICAgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyk7XG4gICAgaG92ZXJMYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5lbXBoYXNpcycpO1xuICB9XG5cbiAgdmFyIHZpc3VhbENvbG9yID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuICB2YXIgdmlzdWFsT3BhY2l0eSA9IHpyVXRpbC5yZXRyaWV2ZTMobGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdvcGFjaXR5JyksIGxpbmVTdHlsZS5vcGFjaXR5LCAxKTtcbiAgbGluZS51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoe1xuICAgIHN0cm9rZU5vU2NhbGU6IHRydWUsXG4gICAgZmlsbDogJ25vbmUnLFxuICAgIHN0cm9rZTogdmlzdWFsQ29sb3IsXG4gICAgb3BhY2l0eTogdmlzdWFsT3BhY2l0eVxuICB9LCBsaW5lU3R5bGUpKTtcbiAgbGluZS5ob3ZlclN0eWxlID0gaG92ZXJMaW5lU3R5bGU7IC8vIFVwZGF0ZSBzeW1ib2xcblxuICB6clV0aWwuZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgdmFyIHN5bWJvbCA9IHRoaXMuY2hpbGRPZk5hbWUoc3ltYm9sQ2F0ZWdvcnkpO1xuXG4gICAgaWYgKHN5bWJvbCkge1xuICAgICAgc3ltYm9sLnNldENvbG9yKHZpc3VhbENvbG9yKTtcbiAgICAgIHN5bWJvbC5zZXRTdHlsZSh7XG4gICAgICAgIG9wYWNpdHk6IHZpc3VhbE9wYWNpdHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgdGhpcyk7XG4gIHZhciBzaG93TGFiZWwgPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTtcbiAgdmFyIGhvdmVyU2hvd0xhYmVsID0gaG92ZXJMYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTtcbiAgdmFyIGxhYmVsID0gdGhpcy5jaGlsZE9mTmFtZSgnbGFiZWwnKTtcbiAgdmFyIGRlZmF1bHRMYWJlbENvbG9yO1xuICB2YXIgZGVmYXVsdFRleHQ7XG4gIHZhciBub3JtYWxUZXh0O1xuICB2YXIgZW1waGFzaXNUZXh0O1xuXG4gIGlmIChzaG93TGFiZWwgfHwgaG92ZXJTaG93TGFiZWwpIHtcbiAgICB2YXIgcmF3VmFsID0gc2VyaWVzTW9kZWwuZ2V0UmF3VmFsdWUoaWR4KTtcbiAgICBkZWZhdWx0VGV4dCA9IHJhd1ZhbCA9PSBudWxsID8gZGVmYXVsdFRleHQgPSBsaW5lRGF0YS5nZXROYW1lKGlkeCkgOiBpc0Zpbml0ZShyYXdWYWwpID8gcm91bmQocmF3VmFsKSA6IHJhd1ZhbDtcbiAgICBkZWZhdWx0TGFiZWxDb2xvciA9IHZpc3VhbENvbG9yIHx8ICcjMDAwJztcbiAgICBub3JtYWxUZXh0ID0genJVdGlsLnJldHJpZXZlMihzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdub3JtYWwnLCBsaW5lRGF0YS5kYXRhVHlwZSksIGRlZmF1bHRUZXh0KTtcbiAgICBlbXBoYXNpc1RleHQgPSB6clV0aWwucmV0cmlldmUyKHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGlkeCwgJ2VtcGhhc2lzJywgbGluZURhdGEuZGF0YVR5cGUpLCBub3JtYWxUZXh0KTtcbiAgfSAvLyBsYWJlbC5hZnRlclVwZGF0ZSA9IGxpbmVBZnRlclVwZGF0ZTtcblxuXG4gIGlmIChzaG93TGFiZWwpIHtcbiAgICB2YXIgbGFiZWxTdHlsZSA9IGdyYXBoaWMuc2V0VGV4dFN0eWxlKGxhYmVsLnN0eWxlLCBsYWJlbE1vZGVsLCB7XG4gICAgICB0ZXh0OiBub3JtYWxUZXh0XG4gICAgfSwge1xuICAgICAgYXV0b0NvbG9yOiBkZWZhdWx0TGFiZWxDb2xvclxuICAgIH0pO1xuICAgIGxhYmVsLl9fdGV4dEFsaWduID0gbGFiZWxTdHlsZS50ZXh0QWxpZ247XG4gICAgbGFiZWwuX192ZXJ0aWNhbEFsaWduID0gbGFiZWxTdHlsZS50ZXh0VmVydGljYWxBbGlnbjsgLy8gJ3N0YXJ0JywgJ21pZGRsZScsICdlbmQnXG5cbiAgICBsYWJlbC5fX3Bvc2l0aW9uID0gbGFiZWxNb2RlbC5nZXQoJ3Bvc2l0aW9uJykgfHwgJ21pZGRsZSc7XG4gIH0gZWxzZSB7XG4gICAgbGFiZWwuc2V0U3R5bGUoJ3RleHQnLCBudWxsKTtcbiAgfVxuXG4gIGlmIChob3ZlclNob3dMYWJlbCkge1xuICAgIC8vIE9ubHkgdGhlc2UgcHJvcGVydGllcyBzdXBwb3J0ZWQgaW4gdGhpcyBlbXBoYXNpcyBzdHlsZSBoZXJlLlxuICAgIGxhYmVsLmhvdmVyU3R5bGUgPSB7XG4gICAgICB0ZXh0OiBlbXBoYXNpc1RleHQsXG4gICAgICB0ZXh0RmlsbDogaG92ZXJMYWJlbE1vZGVsLmdldFRleHRDb2xvcih0cnVlKSxcbiAgICAgIC8vIEZvciBtZXJnaW5nIGhvdmVyIHN0eWxlIHRvIG5vcm1hbCBzdHlsZSwgZG8gbm90IHVzZVxuICAgICAgLy8gYGhvdmVyTGFiZWxNb2RlbC5nZXRGb250KClgIGhlcmUuXG4gICAgICBmb250U3R5bGU6IGhvdmVyTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdmb250U3R5bGUnKSxcbiAgICAgIGZvbnRXZWlnaHQ6IGhvdmVyTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdmb250V2VpZ2h0JyksXG4gICAgICBmb250U2l6ZTogaG92ZXJMYWJlbE1vZGVsLmdldFNoYWxsb3coJ2ZvbnRTaXplJyksXG4gICAgICBmb250RmFtaWx5OiBob3ZlckxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZm9udEZhbWlseScpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBsYWJlbC5ob3ZlclN0eWxlID0ge1xuICAgICAgdGV4dDogbnVsbFxuICAgIH07XG4gIH1cblxuICBsYWJlbC5pZ25vcmUgPSAhc2hvd0xhYmVsICYmICFob3ZlclNob3dMYWJlbDtcbiAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHRoaXMpO1xufTtcblxubGluZVByb3RvLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50cmlnZ2VyKCdlbXBoYXNpcycpO1xufTtcblxubGluZVByb3RvLmRvd25wbGF5ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnRyaWdnZXIoJ25vcm1hbCcpO1xufTtcblxubGluZVByb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4KSB7XG4gIHRoaXMuc2V0TGluZVBvaW50cyhsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkpO1xufTtcblxubGluZVByb3RvLnNldExpbmVQb2ludHMgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gIHZhciBsaW5lUGF0aCA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmUnKTtcbiAgc2V0TGluZVBvaW50cyhsaW5lUGF0aC5zaGFwZSwgcG9pbnRzKTtcbiAgbGluZVBhdGguZGlydHkoKTtcbn07XG5cbnpyVXRpbC5pbmhlcml0cyhMaW5lLCBncmFwaGljLkdyb3VwKTtcbnZhciBfZGVmYXVsdCA9IExpbmU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdmVjdG9yXCIpO1xuXG4vKipcbiAqIExpbmUgcGF0aCBmb3IgYmV6aWVyIGFuZCBzdHJhaWdodCBsaW5lIGRyYXdcbiAqL1xudmFyIHN0cmFpZ2h0TGluZVByb3RvID0gZ3JhcGhpYy5MaW5lLnByb3RvdHlwZTtcbnZhciBiZXppZXJDdXJ2ZVByb3RvID0gZ3JhcGhpYy5CZXppZXJDdXJ2ZS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGlzTGluZShzaGFwZSkge1xuICByZXR1cm4gaXNOYU4oK3NoYXBlLmNweDEpIHx8IGlzTmFOKCtzaGFwZS5jcHkxKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gIHR5cGU6ICdlYy1saW5lJyxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIHNoYXBlOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgeDI6IDAsXG4gICAgeTI6IDAsXG4gICAgcGVyY2VudDogMSxcbiAgICBjcHgxOiBudWxsLFxuICAgIGNweTE6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIChpc0xpbmUoc2hhcGUpID8gc3RyYWlnaHRMaW5lUHJvdG8gOiBiZXppZXJDdXJ2ZVByb3RvKS5idWlsZFBhdGgoY3R4LCBzaGFwZSk7XG4gIH0sXG4gIHBvaW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIGlzTGluZSh0aGlzLnNoYXBlKSA/IHN0cmFpZ2h0TGluZVByb3RvLnBvaW50QXQuY2FsbCh0aGlzLCB0KSA6IGJlemllckN1cnZlUHJvdG8ucG9pbnRBdC5jYWxsKHRoaXMsIHQpO1xuICB9LFxuICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICB2YXIgcCA9IGlzTGluZShzaGFwZSkgPyBbc2hhcGUueDIgLSBzaGFwZS54MSwgc2hhcGUueTIgLSBzaGFwZS55MV0gOiBiZXppZXJDdXJ2ZVByb3RvLnRhbmdlbnRBdC5jYWxsKHRoaXMsIHQpO1xuICAgIHJldHVybiB2ZWMyLm5vcm1hbGl6ZShwLCBwKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xpbmVQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAyOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKFwiLi90b29sYm94L1Rvb2xib3hNb2RlbFwiKTtcblxucmVxdWlyZShcIi4vdG9vbGJveC9Ub29sYm94Vmlld1wiKTtcblxucmVxdWlyZShcIi4vdG9vbGJveC9mZWF0dXJlL1NhdmVBc0ltYWdlXCIpO1xuXG5yZXF1aXJlKFwiLi90b29sYm94L2ZlYXR1cmUvTWFnaWNUeXBlXCIpO1xuXG5yZXF1aXJlKFwiLi90b29sYm94L2ZlYXR1cmUvRGF0YVZpZXdcIik7XG5cbnJlcXVpcmUoXCIuL3Rvb2xib3gvZmVhdHVyZS9EYXRhWm9vbVwiKTtcblxucmVxdWlyZShcIi4vdG9vbGJveC9mZWF0dXJlL1Jlc3RvcmVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3guanNcbi8vIG1vZHVsZSBpZCA9IDI5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZmVhdHVyZU1hbmFnZXIgPSByZXF1aXJlKFwiLi9mZWF0dXJlTWFuYWdlclwiKTtcblxudmFyIFRvb2xib3hNb2RlbCA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuICB0eXBlOiAndG9vbGJveCcsXG4gIGxheW91dE1vZGU6IHtcbiAgICB0eXBlOiAnYm94JyxcbiAgICBpZ25vcmVTaXplOiB0cnVlXG4gIH0sXG4gIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgVG9vbGJveE1vZGVsLnN1cGVyQXBwbHkodGhpcywgJ21lcmdlRGVmYXVsdEFuZFRoZW1lJywgYXJndW1lbnRzKTtcbiAgICB6clV0aWwuZWFjaCh0aGlzLm9wdGlvbi5mZWF0dXJlLCBmdW5jdGlvbiAoZmVhdHVyZU9wdCwgZmVhdHVyZU5hbWUpIHtcbiAgICAgIHZhciBGZWF0dXJlID0gZmVhdHVyZU1hbmFnZXIuZ2V0KGZlYXR1cmVOYW1lKTtcbiAgICAgIEZlYXR1cmUgJiYgenJVdGlsLm1lcmdlKGZlYXR1cmVPcHQsIEZlYXR1cmUuZGVmYXVsdE9wdGlvbik7XG4gICAgfSk7XG4gIH0sXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICBzaG93OiB0cnVlLFxuICAgIHo6IDYsXG4gICAgemxldmVsOiAwLFxuICAgIG9yaWVudDogJ2hvcml6b250YWwnLFxuICAgIGxlZnQ6ICdyaWdodCcsXG4gICAgdG9wOiAndG9wJyxcbiAgICAvLyByaWdodFxuICAgIC8vIGJvdHRvbVxuICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxuICAgIGJvcmRlclJhZGl1czogMCxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBwYWRkaW5nOiA1LFxuICAgIGl0ZW1TaXplOiAxNSxcbiAgICBpdGVtR2FwOiA4LFxuICAgIHNob3dUaXRsZTogdHJ1ZSxcbiAgICBpY29uU3R5bGU6IHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICBib3JkZXJDb2xvcjogJyM2NjYnLFxuICAgICAgICBjb2xvcjogJ25vbmUnXG4gICAgICB9LFxuICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjM0U5OEM1J1xuICAgICAgfSAvLyB0ZXh0U3R5bGU6IHt9LFxuICAgICAgLy8gZmVhdHVyZVxuXG4gICAgfVxuICB9XG59KTtcbnZhciBfZGVmYXVsdCA9IFRvb2xib3hNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveE1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIGZlYXR1cmVNYW5hZ2VyID0gcmVxdWlyZShcIi4vZmVhdHVyZU1hbmFnZXJcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsL01vZGVsXCIpO1xuXG52YXIgRGF0YURpZmZlciA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL0RhdGFEaWZmZXJcIik7XG5cbnZhciBsaXN0Q29tcG9uZW50SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9saXN0Q29tcG9uZW50XCIpO1xuXG52YXIgX2RlZmF1bHQgPSBlY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuICB0eXBlOiAndG9vbGJveCcsXG4gIHJlbmRlcjogZnVuY3Rpb24gKHRvb2xib3hNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICBncm91cC5yZW1vdmVBbGwoKTtcblxuICAgIGlmICghdG9vbGJveE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGl0ZW1TaXplID0gK3Rvb2xib3hNb2RlbC5nZXQoJ2l0ZW1TaXplJyk7XG4gICAgdmFyIGZlYXR1cmVPcHRzID0gdG9vbGJveE1vZGVsLmdldCgnZmVhdHVyZScpIHx8IHt9O1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuX2ZlYXR1cmVzIHx8ICh0aGlzLl9mZWF0dXJlcyA9IHt9KTtcbiAgICB2YXIgZmVhdHVyZU5hbWVzID0gW107XG4gICAgenJVdGlsLmVhY2goZmVhdHVyZU9wdHMsIGZ1bmN0aW9uIChvcHQsIG5hbWUpIHtcbiAgICAgIGZlYXR1cmVOYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIG5ldyBEYXRhRGlmZmVyKHRoaXMuX2ZlYXR1cmVOYW1lcyB8fCBbXSwgZmVhdHVyZU5hbWVzKS5hZGQocHJvY2Vzc0ZlYXR1cmUpLnVwZGF0ZShwcm9jZXNzRmVhdHVyZSkucmVtb3ZlKHpyVXRpbC5jdXJyeShwcm9jZXNzRmVhdHVyZSwgbnVsbCkpLmV4ZWN1dGUoKTsgLy8gS2VlcCBmb3IgZGlmZi5cblxuICAgIHRoaXMuX2ZlYXR1cmVOYW1lcyA9IGZlYXR1cmVOYW1lcztcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NGZWF0dXJlKG5ld0luZGV4LCBvbGRJbmRleCkge1xuICAgICAgdmFyIGZlYXR1cmVOYW1lID0gZmVhdHVyZU5hbWVzW25ld0luZGV4XTtcbiAgICAgIHZhciBvbGROYW1lID0gZmVhdHVyZU5hbWVzW29sZEluZGV4XTtcbiAgICAgIHZhciBmZWF0dXJlT3B0ID0gZmVhdHVyZU9wdHNbZmVhdHVyZU5hbWVdO1xuICAgICAgdmFyIGZlYXR1cmVNb2RlbCA9IG5ldyBNb2RlbChmZWF0dXJlT3B0LCB0b29sYm94TW9kZWwsIHRvb2xib3hNb2RlbC5lY01vZGVsKTtcbiAgICAgIHZhciBmZWF0dXJlO1xuXG4gICAgICBpZiAoZmVhdHVyZU5hbWUgJiYgIW9sZE5hbWUpIHtcbiAgICAgICAgLy8gQ3JlYXRlXG4gICAgICAgIGlmIChpc1VzZXJGZWF0dXJlTmFtZShmZWF0dXJlTmFtZSkpIHtcbiAgICAgICAgICBmZWF0dXJlID0ge1xuICAgICAgICAgICAgbW9kZWw6IGZlYXR1cmVNb2RlbCxcbiAgICAgICAgICAgIG9uY2xpY2s6IGZlYXR1cmVNb2RlbC5vcHRpb24ub25jbGljayxcbiAgICAgICAgICAgIGZlYXR1cmVOYW1lOiBmZWF0dXJlTmFtZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIEZlYXR1cmUgPSBmZWF0dXJlTWFuYWdlci5nZXQoZmVhdHVyZU5hbWUpO1xuXG4gICAgICAgICAgaWYgKCFGZWF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmVhdHVyZSA9IG5ldyBGZWF0dXJlKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZlYXR1cmVzW2ZlYXR1cmVOYW1lXSA9IGZlYXR1cmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZWF0dXJlID0gZmVhdHVyZXNbb2xkTmFtZV07IC8vIElmIGZlYXR1cmUgZG9lcyBub3QgZXhzaXQuXG5cbiAgICAgICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZmVhdHVyZS5tb2RlbCA9IGZlYXR1cmVNb2RlbDtcbiAgICAgICAgZmVhdHVyZS5lY01vZGVsID0gZWNNb2RlbDtcbiAgICAgICAgZmVhdHVyZS5hcGkgPSBhcGk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZmVhdHVyZU5hbWUgJiYgb2xkTmFtZSkge1xuICAgICAgICBmZWF0dXJlLmRpc3Bvc2UgJiYgZmVhdHVyZS5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmZWF0dXJlTW9kZWwuZ2V0KCdzaG93JykgfHwgZmVhdHVyZS51bnVzYWJsZSkge1xuICAgICAgICBmZWF0dXJlLnJlbW92ZSAmJiBmZWF0dXJlLnJlbW92ZShlY01vZGVsLCBhcGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZUljb25QYXRocyhmZWF0dXJlTW9kZWwsIGZlYXR1cmUsIGZlYXR1cmVOYW1lKTtcblxuICAgICAgZmVhdHVyZU1vZGVsLnNldEljb25TdGF0dXMgPSBmdW5jdGlvbiAoaWNvbk5hbWUsIHN0YXR1cykge1xuICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgICAgIHZhciBpY29uUGF0aHMgPSB0aGlzLmljb25QYXRocztcbiAgICAgICAgb3B0aW9uLmljb25TdGF0dXMgPSBvcHRpb24uaWNvblN0YXR1cyB8fCB7fTtcbiAgICAgICAgb3B0aW9uLmljb25TdGF0dXNbaWNvbk5hbWVdID0gc3RhdHVzOyAvLyBGSVhNRVxuXG4gICAgICAgIGljb25QYXRoc1tpY29uTmFtZV0gJiYgaWNvblBhdGhzW2ljb25OYW1lXS50cmlnZ2VyKHN0YXR1cyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoZmVhdHVyZS5yZW5kZXIpIHtcbiAgICAgICAgZmVhdHVyZS5yZW5kZXIoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUljb25QYXRocyhmZWF0dXJlTW9kZWwsIGZlYXR1cmUsIGZlYXR1cmVOYW1lKSB7XG4gICAgICB2YXIgaWNvblN0eWxlTW9kZWwgPSBmZWF0dXJlTW9kZWwuZ2V0TW9kZWwoJ2ljb25TdHlsZScpOyAvLyBJZiBvbmUgZmVhdHVyZSBoYXMgbXV0aXBsZSBpY29uLiB0aGV5IGFyZSBvcmdpbmFpemVkIGFzXG4gICAgICAvLyB7XG4gICAgICAvLyAgICAgaWNvbjoge1xuICAgICAgLy8gICAgICAgICBmb286ICcnLFxuICAgICAgLy8gICAgICAgICBiYXI6ICcnXG4gICAgICAvLyAgICAgfSxcbiAgICAgIC8vICAgICB0aXRsZToge1xuICAgICAgLy8gICAgICAgICBmb286ICcnLFxuICAgICAgLy8gICAgICAgICBiYXI6ICcnXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gfVxuXG4gICAgICB2YXIgaWNvbnMgPSBmZWF0dXJlLmdldEljb25zID8gZmVhdHVyZS5nZXRJY29ucygpIDogZmVhdHVyZU1vZGVsLmdldCgnaWNvbicpO1xuICAgICAgdmFyIHRpdGxlcyA9IGZlYXR1cmVNb2RlbC5nZXQoJ3RpdGxlJykgfHwge307XG5cbiAgICAgIGlmICh0eXBlb2YgaWNvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpY29uID0gaWNvbnM7XG4gICAgICAgIHZhciB0aXRsZSA9IHRpdGxlcztcbiAgICAgICAgaWNvbnMgPSB7fTtcbiAgICAgICAgdGl0bGVzID0ge307XG4gICAgICAgIGljb25zW2ZlYXR1cmVOYW1lXSA9IGljb247XG4gICAgICAgIHRpdGxlc1tmZWF0dXJlTmFtZV0gPSB0aXRsZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGljb25QYXRocyA9IGZlYXR1cmVNb2RlbC5pY29uUGF0aHMgPSB7fTtcbiAgICAgIHpyVXRpbC5lYWNoKGljb25zLCBmdW5jdGlvbiAoaWNvblN0ciwgaWNvbk5hbWUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBncmFwaGljLmNyZWF0ZUljb24oaWNvblN0ciwge30sIHtcbiAgICAgICAgICB4OiAtaXRlbVNpemUgLyAyLFxuICAgICAgICAgIHk6IC1pdGVtU2l6ZSAvIDIsXG4gICAgICAgICAgd2lkdGg6IGl0ZW1TaXplLFxuICAgICAgICAgIGhlaWdodDogaXRlbVNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHBhdGguc2V0U3R5bGUoaWNvblN0eWxlTW9kZWwuZ2V0TW9kZWwoJ25vcm1hbCcpLmdldEl0ZW1TdHlsZSgpKTtcbiAgICAgICAgcGF0aC5ob3ZlclN0eWxlID0gaWNvblN0eWxlTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShwYXRoKTtcblxuICAgICAgICBpZiAodG9vbGJveE1vZGVsLmdldCgnc2hvd1RpdGxlJykpIHtcbiAgICAgICAgICBwYXRoLl9fdGl0bGUgPSB0aXRsZXNbaWNvbk5hbWVdO1xuICAgICAgICAgIHBhdGgub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFNob3VsZCBub3QgcmV1c2UgYWJvdmUgaG92ZXJTdHlsZSwgd2hpY2ggbWlnaHQgYmUgbW9kaWZpZWQuXG4gICAgICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IGljb25TdHlsZU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgICAgICAgcGF0aC5zZXRTdHlsZSh7XG4gICAgICAgICAgICAgIHRleHQ6IHRpdGxlc1tpY29uTmFtZV0sXG4gICAgICAgICAgICAgIHRleHRQb3NpdGlvbjogaG92ZXJTdHlsZS50ZXh0UG9zaXRpb24gfHwgJ2JvdHRvbScsXG4gICAgICAgICAgICAgIHRleHRGaWxsOiBob3ZlclN0eWxlLmZpbGwgfHwgaG92ZXJTdHlsZS5zdHJva2UgfHwgJyMwMDAnLFxuICAgICAgICAgICAgICB0ZXh0QWxpZ246IGhvdmVyU3R5bGUudGV4dEFsaWduIHx8ICdjZW50ZXInXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwYXRoLnNldFN0eWxlKHtcbiAgICAgICAgICAgICAgdGV4dEZpbGw6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aC50cmlnZ2VyKGZlYXR1cmVNb2RlbC5nZXQoJ2ljb25TdGF0dXMuJyArIGljb25OYW1lKSB8fCAnbm9ybWFsJyk7XG4gICAgICAgIGdyb3VwLmFkZChwYXRoKTtcbiAgICAgICAgcGF0aC5vbignY2xpY2snLCB6clV0aWwuYmluZChmZWF0dXJlLm9uY2xpY2ssIGZlYXR1cmUsIGVjTW9kZWwsIGFwaSwgaWNvbk5hbWUpKTtcbiAgICAgICAgaWNvblBhdGhzW2ljb25OYW1lXSA9IHBhdGg7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsaXN0Q29tcG9uZW50SGVscGVyLmxheW91dChncm91cCwgdG9vbGJveE1vZGVsLCBhcGkpOyAvLyBSZW5kZXIgYmFja2dyb3VuZCBhZnRlciBncm91cCBpcyBsYXlvdXRcbiAgICAvLyBGSVhNRVxuXG4gICAgZ3JvdXAuYWRkKGxpc3RDb21wb25lbnRIZWxwZXIubWFrZUJhY2tncm91bmQoZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCksIHRvb2xib3hNb2RlbCkpOyAvLyBBZGp1c3QgaWNvbiB0aXRsZSBwb3NpdGlvbnMgdG8gYXZvaWQgdGhlbSBvdXQgb2Ygc2NyZWVuXG5cbiAgICBncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGljb24pIHtcbiAgICAgIHZhciB0aXRsZVRleHQgPSBpY29uLl9fdGl0bGU7XG4gICAgICB2YXIgaG92ZXJTdHlsZSA9IGljb24uaG92ZXJTdHlsZTsgLy8gTWF5IGJlIGJhY2tncm91bmQgZWxlbWVudFxuXG4gICAgICBpZiAoaG92ZXJTdHlsZSAmJiB0aXRsZVRleHQpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGl0bGVUZXh0LCB0ZXh0Q29udGFpbi5tYWtlRm9udChob3ZlclN0eWxlKSk7XG4gICAgICAgIHZhciBvZmZzZXRYID0gaWNvbi5wb3NpdGlvblswXSArIGdyb3VwLnBvc2l0aW9uWzBdO1xuICAgICAgICB2YXIgb2Zmc2V0WSA9IGljb24ucG9zaXRpb25bMV0gKyBncm91cC5wb3NpdGlvblsxXSArIGl0ZW1TaXplO1xuICAgICAgICB2YXIgbmVlZFB1dE9uVG9wID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9mZnNldFkgKyByZWN0LmhlaWdodCA+IGFwaS5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgIGhvdmVyU3R5bGUudGV4dFBvc2l0aW9uID0gJ3RvcCc7XG4gICAgICAgICAgbmVlZFB1dE9uVG9wID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3BPZmZzZXQgPSBuZWVkUHV0T25Ub3AgPyAtNSAtIHJlY3QuaGVpZ2h0IDogaXRlbVNpemUgKyA4O1xuXG4gICAgICAgIGlmIChvZmZzZXRYICsgcmVjdC53aWR0aCAvIDIgPiBhcGkuZ2V0V2lkdGgoKSkge1xuICAgICAgICAgIGhvdmVyU3R5bGUudGV4dFBvc2l0aW9uID0gWycxMDAlJywgdG9wT2Zmc2V0XTtcbiAgICAgICAgICBob3ZlclN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0WCAtIHJlY3Qud2lkdGggLyAyIDwgMCkge1xuICAgICAgICAgIGhvdmVyU3R5bGUudGV4dFBvc2l0aW9uID0gWzAsIHRvcE9mZnNldF07XG4gICAgICAgICAgaG92ZXJTdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlVmlldzogZnVuY3Rpb24gKHRvb2xib3hNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICBmZWF0dXJlLnVwZGF0ZVZpZXcgJiYgZmVhdHVyZS51cGRhdGVWaWV3KGZlYXR1cmUubW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgfSk7XG4gIH0sXG4gIHVwZGF0ZUxheW91dDogZnVuY3Rpb24gKHRvb2xib3hNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICBmZWF0dXJlLnVwZGF0ZUxheW91dCAmJiBmZWF0dXJlLnVwZGF0ZUxheW91dChmZWF0dXJlLm1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIH0pO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB6clV0aWwuZWFjaCh0aGlzLl9mZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgIGZlYXR1cmUucmVtb3ZlICYmIGZlYXR1cmUucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgfSk7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgfSxcbiAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgZmVhdHVyZS5kaXNwb3NlICYmIGZlYXR1cmUuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICAgIH0pO1xuICB9XG59KTtcblxuZnVuY3Rpb24gaXNVc2VyRmVhdHVyZU5hbWUoZmVhdHVyZU5hbWUpIHtcbiAgcmV0dXJuIGZlYXR1cmVOYW1lLmluZGV4T2YoJ215JykgPT09IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDMwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbnZhciBsYW5nID0gcmVxdWlyZShcIi4uLy4uLy4uL2xhbmdcIik7XG5cbnZhciBmZWF0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9mZWF0dXJlTWFuYWdlclwiKTtcblxudmFyIHNhdmVBc0ltYWdlTGFuZyA9IGxhbmcudG9vbGJveC5zYXZlQXNJbWFnZTtcblxuZnVuY3Rpb24gU2F2ZUFzSW1hZ2UobW9kZWwpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xufVxuXG5TYXZlQXNJbWFnZS5kZWZhdWx0T3B0aW9uID0ge1xuICBzaG93OiB0cnVlLFxuICBpY29uOiAnTTQuNywyMi45TDI5LjMsNDUuNUw1NC43LDIzLjRNNC42LDQzLjZMNC42LDU4TDUzLjgsNThMNTMuOCw0My42TTI5LjIsNDUuMUwyOS4yLDAnLFxuICB0aXRsZTogc2F2ZUFzSW1hZ2VMYW5nLnRpdGxlLFxuICB0eXBlOiAncG5nJyxcbiAgLy8gRGVmYXVsdCB1c2Ugb3B0aW9uLmJhY2tncm91bmRDb2xvclxuICAvLyBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJyxcbiAgbmFtZTogJycsXG4gIGV4Y2x1ZGVDb21wb25lbnRzOiBbJ3Rvb2xib3gnXSxcbiAgcGl4ZWxSYXRpbzogMSxcbiAgbGFuZzogc2F2ZUFzSW1hZ2VMYW5nLmxhbmcuc2xpY2UoKVxufTtcblNhdmVBc0ltYWdlLnByb3RvdHlwZS51bnVzYWJsZSA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xudmFyIHByb3RvID0gU2F2ZUFzSW1hZ2UucHJvdG90eXBlO1xuXG5wcm90by5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICB2YXIgdGl0bGUgPSBtb2RlbC5nZXQoJ25hbWUnKSB8fCBlY01vZGVsLmdldCgndGl0bGUuMC50ZXh0JykgfHwgJ2VjaGFydHMnO1xuICB2YXIgJGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIHZhciB0eXBlID0gbW9kZWwuZ2V0KCd0eXBlJywgdHJ1ZSkgfHwgJ3BuZyc7XG4gICRhLmRvd25sb2FkID0gdGl0bGUgKyAnLicgKyB0eXBlO1xuICAkYS50YXJnZXQgPSAnX2JsYW5rJztcbiAgdmFyIHVybCA9IGFwaS5nZXRDb25uZWN0ZWREYXRhVVJMKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGJhY2tncm91bmRDb2xvcjogbW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InLCB0cnVlKSB8fCBlY01vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJyNmZmYnLFxuICAgIGV4Y2x1ZGVDb21wb25lbnRzOiBtb2RlbC5nZXQoJ2V4Y2x1ZGVDb21wb25lbnRzJyksXG4gICAgcGl4ZWxSYXRpbzogbW9kZWwuZ2V0KCdwaXhlbFJhdGlvJylcbiAgfSk7XG4gICRhLmhyZWYgPSB1cmw7IC8vIENocm9tZSBhbmQgRmlyZWZveFxuXG4gIGlmICh0eXBlb2YgTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiAhZW52LmJyb3dzZXIuaWUgJiYgIWVudi5icm93c2VyLmVkZ2UpIHtcbiAgICB2YXIgZXZ0ID0gbmV3IE1vdXNlRXZlbnQoJ2NsaWNrJywge1xuICAgICAgdmlldzogd2luZG93LFxuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgJGEuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9IC8vIElFXG4gIGVsc2Uge1xuICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICB2YXIgYnN0ciA9IGF0b2IodXJsLnNwbGl0KCcsJylbMV0pO1xuICAgICAgICB2YXIgbiA9IGJzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgdThhcnIgPSBuZXcgVWludDhBcnJheShuKTtcblxuICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgdThhcnJbbl0gPSBic3RyLmNoYXJDb2RlQXQobik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFt1OGFycl0pO1xuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgdGl0bGUgKyAnLicgKyB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYW5nID0gbW9kZWwuZ2V0KCdsYW5nJyk7XG4gICAgICAgIHZhciBodG1sID0gJycgKyAnPGJvZHkgc3R5bGU9XCJtYXJnaW46MDtcIj4nICsgJzxpbWcgc3JjPVwiJyArIHVybCArICdcIiBzdHlsZT1cIm1heC13aWR0aDoxMDAlO1wiIHRpdGxlPVwiJyArIChsYW5nICYmIGxhbmdbMF0gfHwgJycpICsgJ1wiIC8+JyArICc8L2JvZHk+JztcbiAgICAgICAgdmFyIHRhYiA9IHdpbmRvdy5vcGVuKCk7XG4gICAgICAgIHRhYi5kb2N1bWVudC53cml0ZShodG1sKTtcbiAgICAgIH1cbiAgICB9XG59O1xuXG5mZWF0dXJlTWFuYWdlci5yZWdpc3Rlcignc2F2ZUFzSW1hZ2UnLCBTYXZlQXNJbWFnZSk7XG52YXIgX2RlZmF1bHQgPSBTYXZlQXNJbWFnZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9TYXZlQXNJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMzAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBsYW5nID0gcmVxdWlyZShcIi4uLy4uLy4uL2xhbmdcIik7XG5cbnZhciBmZWF0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9mZWF0dXJlTWFuYWdlclwiKTtcblxudmFyIG1hZ2ljVHlwZUxhbmcgPSBsYW5nLnRvb2xib3gubWFnaWNUeXBlO1xuXG5mdW5jdGlvbiBNYWdpY1R5cGUobW9kZWwpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xufVxuXG5NYWdpY1R5cGUuZGVmYXVsdE9wdGlvbiA9IHtcbiAgc2hvdzogdHJ1ZSxcbiAgdHlwZTogW10sXG4gIC8vIEljb24gZ3JvdXBcbiAgaWNvbjoge1xuICAgIGxpbmU6ICdNNC4xLDI4LjloNy4xbDkuMy0yMmw3LjQsMzhsOS43LTE5LjdsMywxMi44aDE0LjlNNC4xLDU4aDUxLjQnLFxuICAgIGJhcjogJ002LjcsMjIuOWgxMFY0OGgtMTBWMjIuOXpNMjQuOSwxM2gxMHYzNWgtMTBWMTN6TTQzLjIsMmgxMHY0NmgtMTBWMnpNMy4xLDU4aDUzLjcnLFxuICAgIHN0YWNrOiAnTTguMiwzOC40bC04LjQsNC4xbDMwLjYsMTUuM0w2MCw0Mi41bC04LjEtNC4xbC0yMS41LDExTDguMiwzOC40eiBNNTEuOSwzMGwtOC4xLDQuMmwtMTMuNCw2LjlsLTEzLjktNi45TDguMiwzMGwtOC40LDQuMmw4LjQsNC4ybDIyLjIsMTFsMjEuNS0xMWw4LjEtNC4yTDUxLjksMzB6IE01MS45LDIxLjdsLTguMSw0LjJMMzUuNywzMGwtNS4zLDIuOEwyNC45LDMwbC04LjQtNC4xbC04LjMtNC4ybC04LjQsNC4yTDguMiwzMGw4LjMsNC4ybDEzLjksNi45bDEzLjQtNi45bDguMS00LjJsOC4xLTQuMUw1MS45LDIxLjd6TTMwLjQsMi4yTC0wLjIsMTcuNWw4LjQsNC4xbDguMyw0LjJsOC40LDQuMmw1LjUsMi43bDUuMy0yLjdsOC4xLTQuMmw4LjEtNC4ybDguMS00LjFMMzAuNCwyLjJ6JyxcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB0aWxlZDogJ00yLjMsMi4yaDIyLjhWMjVIMi4zVjIuMnogTTM1LDIuMmgyMi44VjI1SDM1VjIuMnpNMi4zLDM1aDIyLjh2MjIuOEgyLjNWMzV6IE0zNSwzNWgyMi44djIyLjhIMzVWMzV6J1xuICB9LFxuICAvLyBgbGluZWAsIGBiYXJgLCBgc3RhY2tgLCBgdGlsZWRgXG4gIHRpdGxlOiB6clV0aWwuY2xvbmUobWFnaWNUeXBlTGFuZy50aXRsZSksXG4gIG9wdGlvbjoge30sXG4gIHNlcmllc0luZGV4OiB7fVxufTtcbnZhciBwcm90byA9IE1hZ2ljVHlwZS5wcm90b3R5cGU7XG5cbnByb3RvLmdldEljb25zID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICB2YXIgYXZhaWxhYmxlSWNvbnMgPSBtb2RlbC5nZXQoJ2ljb24nKTtcbiAgdmFyIGljb25zID0ge307XG4gIHpyVXRpbC5lYWNoKG1vZGVsLmdldCgndHlwZScpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmIChhdmFpbGFibGVJY29uc1t0eXBlXSkge1xuICAgICAgaWNvbnNbdHlwZV0gPSBhdmFpbGFibGVJY29uc1t0eXBlXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaWNvbnM7XG59O1xuXG52YXIgc2VyaWVzT3B0R2VucmVhdG9yID0ge1xuICAnbGluZSc6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdiYXInKSB7XG4gICAgICByZXR1cm4genJVdGlsLm1lcmdlKHtcbiAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgIC8vIFByZXNlcnZlIGRhdGEgcmVsYXRlZCBvcHRpb25cbiAgICAgICAgZGF0YTogc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJyksXG4gICAgICAgIHN0YWNrOiBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJyksXG4gICAgICAgIG1hcmtQb2ludDogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrUG9pbnQnKSxcbiAgICAgICAgbWFya0xpbmU6IHNlcmllc01vZGVsLmdldCgnbWFya0xpbmUnKVxuICAgICAgfSwgbW9kZWwuZ2V0KCdvcHRpb24ubGluZScpIHx8IHt9LCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gICdiYXInOiBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgc2VyaWVzSWQsIHNlcmllc01vZGVsLCBtb2RlbCkge1xuICAgIGlmIChzZXJpZXNUeXBlID09PSAnbGluZScpIHtcbiAgICAgIHJldHVybiB6clV0aWwubWVyZ2Uoe1xuICAgICAgICBpZDogc2VyaWVzSWQsXG4gICAgICAgIHR5cGU6ICdiYXInLFxuICAgICAgICAvLyBQcmVzZXJ2ZSBkYXRhIHJlbGF0ZWQgb3B0aW9uXG4gICAgICAgIGRhdGE6IHNlcmllc01vZGVsLmdldCgnZGF0YScpLFxuICAgICAgICBzdGFjazogc2VyaWVzTW9kZWwuZ2V0KCdzdGFjaycpLFxuICAgICAgICBtYXJrUG9pbnQ6IHNlcmllc01vZGVsLmdldCgnbWFya1BvaW50JyksXG4gICAgICAgIG1hcmtMaW5lOiBzZXJpZXNNb2RlbC5nZXQoJ21hcmtMaW5lJylcbiAgICAgIH0sIG1vZGVsLmdldCgnb3B0aW9uLmJhcicpIHx8IHt9LCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gICdzdGFjayc6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdsaW5lJyB8fCBzZXJpZXNUeXBlID09PSAnYmFyJykge1xuICAgICAgcmV0dXJuIHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgc3RhY2s6ICdfX2VjX21hZ2ljVHlwZV9zdGFja19fJ1xuICAgICAgfSwgbW9kZWwuZ2V0KCdvcHRpb24uc3RhY2snKSB8fCB7fSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICAndGlsZWQnOiBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgc2VyaWVzSWQsIHNlcmllc01vZGVsLCBtb2RlbCkge1xuICAgIGlmIChzZXJpZXNUeXBlID09PSAnbGluZScgfHwgc2VyaWVzVHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgIHJldHVybiB6clV0aWwubWVyZ2Uoe1xuICAgICAgICBpZDogc2VyaWVzSWQsXG4gICAgICAgIHN0YWNrOiAnJ1xuICAgICAgfSwgbW9kZWwuZ2V0KCdvcHRpb24udGlsZWQnKSB8fCB7fSwgdHJ1ZSk7XG4gICAgfVxuICB9XG59O1xudmFyIHJhZGlvVHlwZXMgPSBbWydsaW5lJywgJ2JhciddLCBbJ3N0YWNrJywgJ3RpbGVkJ11dO1xuXG5wcm90by5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgdHlwZSkge1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICB2YXIgc2VyaWVzSW5kZXggPSBtb2RlbC5nZXQoJ3Nlcmllc0luZGV4LicgKyB0eXBlKTsgLy8gTm90IHN1cHBvcnRlZCBtYWdpY1R5cGVcblxuICBpZiAoIXNlcmllc09wdEdlbnJlYXRvclt0eXBlXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXdPcHRpb24gPSB7XG4gICAgc2VyaWVzOiBbXVxuICB9O1xuXG4gIHZhciBnZW5lcmF0ZU5ld1Nlcmllc1R5cGVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIHNlcmllc1R5cGUgPSBzZXJpZXNNb2RlbC5zdWJUeXBlO1xuICAgIHZhciBzZXJpZXNJZCA9IHNlcmllc01vZGVsLmlkO1xuICAgIHZhciBuZXdTZXJpZXNPcHQgPSBzZXJpZXNPcHRHZW5yZWF0b3JbdHlwZV0oc2VyaWVzVHlwZSwgc2VyaWVzSWQsIHNlcmllc01vZGVsLCBtb2RlbCk7XG5cbiAgICBpZiAobmV3U2VyaWVzT3B0KSB7XG4gICAgICAvLyBQRU5ESU5HIElmIG1lcmdlIG9yaWdpbmFsIG9wdGlvbj9cbiAgICAgIHpyVXRpbC5kZWZhdWx0cyhuZXdTZXJpZXNPcHQsIHNlcmllc01vZGVsLm9wdGlvbik7XG4gICAgICBuZXdPcHRpb24uc2VyaWVzLnB1c2gobmV3U2VyaWVzT3B0KTtcbiAgICB9IC8vIE1vZGlmeSBib3VuZGFyeUdhcFxuXG5cbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgJiYgKHR5cGUgPT09ICdsaW5lJyB8fCB0eXBlID09PSAnYmFyJykpIHtcbiAgICAgIHZhciBjYXRlZ29yeUF4aXMgPSBjb29yZFN5cy5nZXRBeGVzQnlTY2FsZSgnb3JkaW5hbCcpWzBdO1xuXG4gICAgICBpZiAoY2F0ZWdvcnlBeGlzKSB7XG4gICAgICAgIHZhciBheGlzRGltID0gY2F0ZWdvcnlBeGlzLmRpbTtcbiAgICAgICAgdmFyIGF4aXNUeXBlID0gYXhpc0RpbSArICdBeGlzJztcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICBtYWluVHlwZTogYXhpc1R5cGUsXG4gICAgICAgICAgaW5kZXg6IHNlcmllc01vZGVsLmdldChuYW1lICsgJ0luZGV4JyksXG4gICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldChuYW1lICsgJ0lkJylcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHZhciBheGlzSW5kZXggPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gICAgICAgIG5ld09wdGlvbltheGlzVHlwZV0gPSBuZXdPcHRpb25bYXhpc1R5cGVdIHx8IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGF4aXNJbmRleDsgaSsrKSB7XG4gICAgICAgICAgbmV3T3B0aW9uW2F4aXNUeXBlXVtheGlzSW5kZXhdID0gbmV3T3B0aW9uW2F4aXNUeXBlXVtheGlzSW5kZXhdIHx8IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3T3B0aW9uW2F4aXNUeXBlXVtheGlzSW5kZXhdLmJvdW5kYXJ5R2FwID0gdHlwZSA9PT0gJ2JhcicgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHpyVXRpbC5lYWNoKHJhZGlvVHlwZXMsIGZ1bmN0aW9uIChyYWRpbykge1xuICAgIGlmICh6clV0aWwuaW5kZXhPZihyYWRpbywgdHlwZSkgPj0gMCkge1xuICAgICAgenJVdGlsLmVhY2gocmFkaW8sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIG1vZGVsLnNldEljb25TdGF0dXMoaXRlbSwgJ25vcm1hbCcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbW9kZWwuc2V0SWNvblN0YXR1cyh0eXBlLCAnZW1waGFzaXMnKTtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICBtYWluVHlwZTogJ3NlcmllcycsXG4gICAgcXVlcnk6IHNlcmllc0luZGV4ID09IG51bGwgPyBudWxsIDoge1xuICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4XG4gICAgfVxuICB9LCBnZW5lcmF0ZU5ld1Nlcmllc1R5cGVzKTtcbiAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnY2hhbmdlTWFnaWNUeXBlJyxcbiAgICBjdXJyZW50VHlwZTogdHlwZSxcbiAgICBuZXdPcHRpb246IG5ld09wdGlvblxuICB9KTtcbn07XG5cbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiAnY2hhbmdlTWFnaWNUeXBlJyxcbiAgZXZlbnQ6ICdtYWdpY1R5cGVDaGFuZ2VkJyxcbiAgdXBkYXRlOiAncHJlcGFyZUFuZFVwZGF0ZSdcbn0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gIGVjTW9kZWwubWVyZ2VPcHRpb24ocGF5bG9hZC5uZXdPcHRpb24pO1xufSk7XG5mZWF0dXJlTWFuYWdlci5yZWdpc3RlcignbWFnaWNUeXBlJywgTWFnaWNUeXBlKTtcbnZhciBfZGVmYXVsdCA9IE1hZ2ljVHlwZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9NYWdpY1R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZXZlbnRUb29sID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZXZlbnRcIik7XG5cbnZhciBsYW5nID0gcmVxdWlyZShcIi4uLy4uLy4uL2xhbmdcIik7XG5cbnZhciBmZWF0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9mZWF0dXJlTWFuYWdlclwiKTtcblxudmFyIGRhdGFWaWV3TGFuZyA9IGxhbmcudG9vbGJveC5kYXRhVmlldztcbnZhciBCTE9DS19TUExJVEVSID0gbmV3IEFycmF5KDYwKS5qb2luKCctJyk7XG52YXIgSVRFTV9TUExJVEVSID0gJ1xcdCc7XG4vKipcbiAqIEdyb3VwIHNlcmllcyBpbnRvIHR3byB0eXBlc1xuICogIDEuIG9uIGNhdGVnb3J5IGF4aXMsIGxpa2UgbGluZSwgYmFyXG4gKiAgMi4gb3RoZXJzLCBsaWtlIHNjYXR0ZXIsIHBpZVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBpbm5lclxuICovXG5cbmZ1bmN0aW9uIGdyb3VwU2VyaWVzKGVjTW9kZWwpIHtcbiAgdmFyIHNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXMgPSB7fTtcbiAgdmFyIG90aGVyU2VyaWVzID0gW107XG4gIHZhciBtZXRhID0gW107XG4gIGVjTW9kZWwuZWFjaFJhd1NlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgaWYgKGNvb3JkU3lzICYmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnIHx8IGNvb3JkU3lzLnR5cGUgPT09ICdwb2xhcicpKSB7XG4gICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuXG4gICAgICBpZiAoYmFzZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICB2YXIga2V5ID0gYmFzZUF4aXMuZGltICsgJ18nICsgYmFzZUF4aXMuaW5kZXg7XG5cbiAgICAgICAgaWYgKCFzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzW2tleV0pIHtcbiAgICAgICAgICBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzW2tleV0gPSB7XG4gICAgICAgICAgICBjYXRlZ29yeUF4aXM6IGJhc2VBeGlzLFxuICAgICAgICAgICAgdmFsdWVBeGlzOiBjb29yZFN5cy5nZXRPdGhlckF4aXMoYmFzZUF4aXMpLFxuICAgICAgICAgICAgc2VyaWVzOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgICAgbWV0YS5wdXNoKHtcbiAgICAgICAgICAgIGF4aXNEaW06IGJhc2VBeGlzLmRpbSxcbiAgICAgICAgICAgIGF4aXNJbmRleDogYmFzZUF4aXMuaW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXNba2V5XS5zZXJpZXMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdGhlclNlcmllcy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXJTZXJpZXMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzOiBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzLFxuICAgIG90aGVyOiBvdGhlclNlcmllcyxcbiAgICBtZXRhOiBtZXRhXG4gIH07XG59XG4vKipcbiAqIEFzc2VtYmxlIGNvbnRlbnQgb2Ygc2VyaWVzIG9uIGNhdGVvZ29yeSBheGlzXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXM+fSBzZXJpZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gYXNzZW1ibGVTZXJpZXNXaXRoQ2F0ZWdvcnlBeGlzKHNlcmllcykge1xuICB2YXIgdGFibGVzID0gW107XG4gIHpyVXRpbC5lYWNoKHNlcmllcywgZnVuY3Rpb24gKGdyb3VwLCBrZXkpIHtcbiAgICB2YXIgY2F0ZWdvcnlBeGlzID0gZ3JvdXAuY2F0ZWdvcnlBeGlzO1xuICAgIHZhciB2YWx1ZUF4aXMgPSBncm91cC52YWx1ZUF4aXM7XG4gICAgdmFyIHZhbHVlQXhpc0RpbSA9IHZhbHVlQXhpcy5kaW07XG4gICAgdmFyIGhlYWRlcnMgPSBbJyAnXS5jb25jYXQoenJVdGlsLm1hcChncm91cC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgIHJldHVybiBzZXJpZXMubmFtZTtcbiAgICB9KSk7XG4gICAgdmFyIGNvbHVtbnMgPSBbY2F0ZWdvcnlBeGlzLm1vZGVsLmdldENhdGVnb3JpZXMoKV07XG4gICAgenJVdGlsLmVhY2goZ3JvdXAuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICBjb2x1bW5zLnB1c2goc2VyaWVzLmdldFJhd0RhdGEoKS5tYXBBcnJheSh2YWx1ZUF4aXNEaW0sIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0pKTtcbiAgICB9KTsgLy8gQXNzZW1ibGUgdGFibGUgY29udGVudFxuXG4gICAgdmFyIGxpbmVzID0gW2hlYWRlcnMuam9pbihJVEVNX1NQTElURVIpXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uc1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1ucy5sZW5ndGg7IGorKykge1xuICAgICAgICBpdGVtcy5wdXNoKGNvbHVtbnNbal1baV0pO1xuICAgICAgfVxuXG4gICAgICBsaW5lcy5wdXNoKGl0ZW1zLmpvaW4oSVRFTV9TUExJVEVSKSk7XG4gICAgfVxuXG4gICAgdGFibGVzLnB1c2gobGluZXMuam9pbignXFxuJykpO1xuICB9KTtcbiAgcmV0dXJuIHRhYmxlcy5qb2luKCdcXG5cXG4nICsgQkxPQ0tfU1BMSVRFUiArICdcXG5cXG4nKTtcbn1cbi8qKlxuICogQXNzZW1ibGUgY29udGVudCBvZiBvdGhlciBzZXJpZXNcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59IHNlcmllc1xuICogQHJldHVybiB7c3RyaW5nfVxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlbWJsZU90aGVyU2VyaWVzKHNlcmllcykge1xuICByZXR1cm4genJVdGlsLm1hcChzZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllcy5nZXRSYXdEYXRhKCk7XG4gICAgdmFyIGxpbmVzID0gW3Nlcmllcy5uYW1lXTtcbiAgICB2YXIgdmFscyA9IFtdO1xuICAgIGRhdGEuZWFjaChkYXRhLmRpbWVuc2lvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIGRhdGFJbmRleCA9IGFyZ3VtZW50c1thcmdMZW4gLSAxXTtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnTGVuIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhbHNbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG5cbiAgICAgIGxpbmVzLnB1c2goKG5hbWUgPyBuYW1lICsgSVRFTV9TUExJVEVSIDogJycpICsgdmFscy5qb2luKElURU1fU1BMSVRFUikpO1xuICAgIH0pO1xuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgfSkuam9pbignXFxuXFxuJyArIEJMT0NLX1NQTElURVIgKyAnXFxuXFxuJyk7XG59XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb250ZW50RnJvbU1vZGVsKGVjTW9kZWwpIHtcbiAgdmFyIHJlc3VsdCA9IGdyb3VwU2VyaWVzKGVjTW9kZWwpO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB6clV0aWwuZmlsdGVyKFthc3NlbWJsZVNlcmllc1dpdGhDYXRlZ29yeUF4aXMocmVzdWx0LnNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXMpLCBhc3NlbWJsZU90aGVyU2VyaWVzKHJlc3VsdC5vdGhlcildLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXG5cXHRcXHNdL2csICcnKTtcbiAgICB9KS5qb2luKCdcXG5cXG4nICsgQkxPQ0tfU1BMSVRFUiArICdcXG5cXG4nKSxcbiAgICBtZXRhOiByZXN1bHQubWV0YVxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xufVxuLyoqXG4gKiBJZiBhIGJsb2NrIGlzIHRzdiBmb3JtYXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVFNWRm9ybWF0KGJsb2NrKSB7XG4gIC8vIFNpbXBsZSBtZXRob2QgdG8gZmluZCBvdXQgaWYgYSBibG9jayBpcyB0c3YgZm9ybWF0XG4gIHZhciBmaXJzdExpbmUgPSBibG9jay5zbGljZSgwLCBibG9jay5pbmRleE9mKCdcXG4nKSk7XG5cbiAgaWYgKGZpcnN0TGluZS5pbmRleE9mKElURU1fU1BMSVRFUikgPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBpdGVtU3BsaXRSZWdleCA9IG5ldyBSZWdFeHAoJ1snICsgSVRFTV9TUExJVEVSICsgJ10rJywgJ2cnKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRzdlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVFNWQ29udGVudHModHN2KSB7XG4gIHZhciB0c3ZMaW5lcyA9IHRzdi5zcGxpdCgvXFxuKy9nKTtcbiAgdmFyIGhlYWRlcnMgPSB0cmltKHRzdkxpbmVzLnNoaWZ0KCkpLnNwbGl0KGl0ZW1TcGxpdFJlZ2V4KTtcbiAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgdmFyIHNlcmllcyA9IHpyVXRpbC5tYXAoaGVhZGVycywgZnVuY3Rpb24gKGhlYWRlcikge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBoZWFkZXIsXG4gICAgICBkYXRhOiBbXVxuICAgIH07XG4gIH0pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHN2TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbXMgPSB0cmltKHRzdkxpbmVzW2ldKS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG4gICAgY2F0ZWdvcmllcy5wdXNoKGl0ZW1zLnNoaWZ0KCkpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgc2VyaWVzW2pdICYmIChzZXJpZXNbal0uZGF0YVtpXSA9IGl0ZW1zW2pdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNlcmllczogc2VyaWVzLFxuICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXNcbiAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59XG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlTGlzdENvbnRlbnRzKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xcbisvZyk7XG4gIHZhciBzZXJpZXNOYW1lID0gdHJpbShsaW5lcy5zaGlmdCgpKTtcbiAgdmFyIGRhdGEgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW1zID0gdHJpbShsaW5lc1tpXSkuc3BsaXQoaXRlbVNwbGl0UmVnZXgpO1xuICAgIHZhciBuYW1lID0gJyc7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBoYXNOYW1lID0gZmFsc2U7XG5cbiAgICBpZiAoaXNOYU4oaXRlbXNbMF0pKSB7XG4gICAgICAvLyBGaXJzdCBpdGVtIGlzIG5hbWVcbiAgICAgIGhhc05hbWUgPSB0cnVlO1xuICAgICAgbmFtZSA9IGl0ZW1zWzBdO1xuICAgICAgaXRlbXMgPSBpdGVtcy5zbGljZSgxKTtcbiAgICAgIGRhdGFbaV0gPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiBbXVxuICAgICAgfTtcbiAgICAgIHZhbHVlID0gZGF0YVtpXS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBkYXRhW2ldID0gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFsdWUucHVzaCgraXRlbXNbal0pO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGhhc05hbWUgPyBkYXRhW2ldLnZhbHVlID0gdmFsdWVbMF0gOiBkYXRhW2ldID0gdmFsdWVbMF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBzZXJpZXNOYW1lLFxuICAgIGRhdGE6IGRhdGFcbiAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYmxvY2tNZXRhTGlzdFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUNvbnRlbnRzKHN0ciwgYmxvY2tNZXRhTGlzdCkge1xuICB2YXIgYmxvY2tzID0gc3RyLnNwbGl0KG5ldyBSZWdFeHAoJ1xcbionICsgQkxPQ0tfU1BMSVRFUiArICdcXG4qJywgJ2cnKSk7XG4gIHZhciBuZXdPcHRpb24gPSB7XG4gICAgc2VyaWVzOiBbXVxuICB9O1xuICB6clV0aWwuZWFjaChibG9ja3MsIGZ1bmN0aW9uIChibG9jaywgaWR4KSB7XG4gICAgaWYgKGlzVFNWRm9ybWF0KGJsb2NrKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlVFNWQ29udGVudHMoYmxvY2spO1xuICAgICAgdmFyIGJsb2NrTWV0YSA9IGJsb2NrTWV0YUxpc3RbaWR4XTtcbiAgICAgIHZhciBheGlzS2V5ID0gYmxvY2tNZXRhLmF4aXNEaW0gKyAnQXhpcyc7XG5cbiAgICAgIGlmIChibG9ja01ldGEpIHtcbiAgICAgICAgbmV3T3B0aW9uW2F4aXNLZXldID0gbmV3T3B0aW9uW2F4aXNLZXldIHx8IFtdO1xuICAgICAgICBuZXdPcHRpb25bYXhpc0tleV1bYmxvY2tNZXRhLmF4aXNJbmRleF0gPSB7XG4gICAgICAgICAgZGF0YTogcmVzdWx0LmNhdGVnb3JpZXNcbiAgICAgICAgfTtcbiAgICAgICAgbmV3T3B0aW9uLnNlcmllcyA9IG5ld09wdGlvbi5zZXJpZXMuY29uY2F0KHJlc3VsdC5zZXJpZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaXN0Q29udGVudHMoYmxvY2spO1xuICAgICAgbmV3T3B0aW9uLnNlcmllcy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld09wdGlvbjtcbn1cbi8qKlxuICogQGFsaWFzIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL0RhdGFWaWV3fVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtb2RlbFxuICovXG5cblxuZnVuY3Rpb24gRGF0YVZpZXcobW9kZWwpIHtcbiAgdGhpcy5fZG9tID0gbnVsbDtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xufVxuXG5EYXRhVmlldy5kZWZhdWx0T3B0aW9uID0ge1xuICBzaG93OiB0cnVlLFxuICByZWFkT25seTogZmFsc2UsXG4gIG9wdGlvblRvQ29udGVudDogbnVsbCxcbiAgY29udGVudFRvT3B0aW9uOiBudWxsLFxuICBpY29uOiAnTTE3LjUsMTcuM0gzMyBNMTcuNSwxNy4zSDMzIE00NS40LDI5LjVoLTI4IE0xMS41LDJ2NTZINTFWMTQuOEwzOC40LDJIMTEuNXogTTM4LjQsMi4ydjEyLjdINTEgTTQ1LjQsNDEuN2gtMjgnLFxuICB0aXRsZTogenJVdGlsLmNsb25lKGRhdGFWaWV3TGFuZy50aXRsZSksXG4gIGxhbmc6IHpyVXRpbC5jbG9uZShkYXRhVmlld0xhbmcubGFuZyksXG4gIGJhY2tncm91bmRDb2xvcjogJyNmZmYnLFxuICB0ZXh0Q29sb3I6ICcjMDAwJyxcbiAgdGV4dGFyZWFDb2xvcjogJyNmZmYnLFxuICB0ZXh0YXJlYUJvcmRlckNvbG9yOiAnIzMzMycsXG4gIGJ1dHRvbkNvbG9yOiAnI2MyMzUzMScsXG4gIGJ1dHRvblRleHRDb2xvcjogJyNmZmYnXG59O1xuXG5EYXRhVmlldy5wcm90b3R5cGUub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGNvbnRhaW5lciA9IGFwaS5nZXREb20oKTtcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcblxuICBpZiAodGhpcy5fZG9tKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2RvbSk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICByb290LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDo1cHg7dG9wOjVweDtib3R0b206NXB4O3JpZ2h0OjVweDsnO1xuICByb290LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJyNmZmYnOyAvLyBDcmVhdGUgZWxlbWVudHNcblxuICB2YXIgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDQnKTtcbiAgdmFyIGxhbmcgPSBtb2RlbC5nZXQoJ2xhbmcnKSB8fCBbXTtcbiAgaGVhZGVyLmlubmVySFRNTCA9IGxhbmdbMF0gfHwgbW9kZWwuZ2V0KCd0aXRsZScpO1xuICBoZWFkZXIuc3R5bGUuY3NzVGV4dCA9ICdtYXJnaW46IDEwcHggMjBweDsnO1xuICBoZWFkZXIuc3R5bGUuY29sb3IgPSBtb2RlbC5nZXQoJ3RleHRDb2xvcicpO1xuICB2YXIgdmlld01haW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgdmlld01haW4uc3R5bGUuY3NzVGV4dCA9ICdkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7b3ZlcmZsb3c6YXV0bzsnO1xuICB2YXIgb3B0aW9uVG9Db250ZW50ID0gbW9kZWwuZ2V0KCdvcHRpb25Ub0NvbnRlbnQnKTtcbiAgdmFyIGNvbnRlbnRUb09wdGlvbiA9IG1vZGVsLmdldCgnY29udGVudFRvT3B0aW9uJyk7XG4gIHZhciByZXN1bHQgPSBnZXRDb250ZW50RnJvbU1vZGVsKGVjTW9kZWwpO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9uVG9Db250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGh0bWxPckRvbSA9IG9wdGlvblRvQ29udGVudChhcGkuZ2V0T3B0aW9uKCkpO1xuXG4gICAgaWYgKHR5cGVvZiBodG1sT3JEb20gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2aWV3TWFpbi5pbm5lckhUTUwgPSBodG1sT3JEb207XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNEb20oaHRtbE9yRG9tKSkge1xuICAgICAgdmlld01haW4uYXBwZW5kQ2hpbGQoaHRtbE9yRG9tKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIGRlZmF1bHQgdGV4dGFyZWFcbiAgICB2aWV3TWFpbi5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XG4gICAgdGV4dGFyZWEucmVhZE9ubHkgPSBtb2RlbC5nZXQoJ3JlYWRPbmx5Jyk7XG4gICAgdGV4dGFyZWEuc3R5bGUuY3NzVGV4dCA9ICd3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxLjZyZW07JztcbiAgICB0ZXh0YXJlYS5zdHlsZS5jb2xvciA9IG1vZGVsLmdldCgndGV4dENvbG9yJyk7XG4gICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyQ29sb3IgPSBtb2RlbC5nZXQoJ3RleHRhcmVhQm9yZGVyQ29sb3InKTtcbiAgICB0ZXh0YXJlYS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBtb2RlbC5nZXQoJ3RleHRhcmVhQ29sb3InKTtcbiAgICB0ZXh0YXJlYS52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgfVxuXG4gIHZhciBibG9ja01ldGFMaXN0ID0gcmVzdWx0Lm1ldGE7XG4gIHZhciBidXR0b25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYnV0dG9uQ29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjA7bGVmdDowO3JpZ2h0OjA7JztcbiAgdmFyIGJ1dHRvblN0eWxlID0gJ2Zsb2F0OnJpZ2h0O21hcmdpbi1yaWdodDoyMHB4O2JvcmRlcjpub25lOycgKyAnY3Vyc29yOnBvaW50ZXI7cGFkZGluZzoycHggNXB4O2ZvbnQtc2l6ZToxMnB4O2JvcmRlci1yYWRpdXM6M3B4JztcbiAgdmFyIGNsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciByZWZyZXNoQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJ1dHRvblN0eWxlICs9ICc7YmFja2dyb3VuZC1jb2xvcjonICsgbW9kZWwuZ2V0KCdidXR0b25Db2xvcicpO1xuICBidXR0b25TdHlsZSArPSAnO2NvbG9yOicgKyBtb2RlbC5nZXQoJ2J1dHRvblRleHRDb2xvcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHJvb3QpO1xuICAgIHNlbGYuX2RvbSA9IG51bGw7XG4gIH1cblxuICBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgY2xvc2UpO1xuICBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcihyZWZyZXNoQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld09wdGlvbjtcblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGNvbnRlbnRUb09wdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBuZXdPcHRpb24gPSBjb250ZW50VG9PcHRpb24odmlld01haW4sIGFwaS5nZXRPcHRpb24oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPcHRpb24gPSBwYXJzZUNvbnRlbnRzKHRleHRhcmVhLnZhbHVlLCBibG9ja01ldGFMaXN0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjbG9zZSgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIHZpZXcgZm9ybWF0IGVycm9yICcgKyBlKTtcbiAgICB9XG5cbiAgICBpZiAobmV3T3B0aW9uKSB7XG4gICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICB0eXBlOiAnY2hhbmdlRGF0YVZpZXcnLFxuICAgICAgICBuZXdPcHRpb246IG5ld09wdGlvblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xvc2UoKTtcbiAgfSk7XG4gIGNsb3NlQnV0dG9uLmlubmVySFRNTCA9IGxhbmdbMV07XG4gIHJlZnJlc2hCdXR0b24uaW5uZXJIVE1MID0gbGFuZ1syXTtcbiAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5jc3NUZXh0ID0gYnV0dG9uU3R5bGU7XG4gIGNsb3NlQnV0dG9uLnN0eWxlLmNzc1RleHQgPSBidXR0b25TdHlsZTtcbiAgIW1vZGVsLmdldCgncmVhZE9ubHknKSAmJiBidXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQocmVmcmVzaEJ1dHRvbik7XG4gIGJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbik7IC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjYzNzM0MS91c2UtdGFiLXRvLWluZGVudC1pbi10ZXh0YXJlYVxuXG4gIGV2ZW50VG9vbC5hZGRFdmVudExpc3RlbmVyKHRleHRhcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKChlLmtleUNvZGUgfHwgZS53aGljaCkgPT09IDkpIHtcbiAgICAgIC8vIGdldCBjYXJldCBwb3NpdGlvbi9zZWxlY3Rpb25cbiAgICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlO1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHZhciBlbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDsgLy8gc2V0IHRleHRhcmVhIHZhbHVlIHRvOiB0ZXh0IGJlZm9yZSBjYXJldCArIHRhYiArIHRleHQgYWZ0ZXIgY2FyZXRcblxuICAgICAgdGhpcy52YWx1ZSA9IHZhbC5zdWJzdHJpbmcoMCwgc3RhcnQpICsgSVRFTV9TUExJVEVSICsgdmFsLnN1YnN0cmluZyhlbmQpOyAvLyBwdXQgY2FyZXQgYXQgcmlnaHQgcG9zaXRpb24gYWdhaW5cblxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uRW5kID0gc3RhcnQgKyAxOyAvLyBwcmV2ZW50IHRoZSBmb2N1cyBsb3NlXG5cbiAgICAgIGV2ZW50VG9vbC5zdG9wKGUpO1xuICAgIH1cbiAgfSk7XG4gIHJvb3QuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgcm9vdC5hcHBlbmRDaGlsZCh2aWV3TWFpbik7XG4gIHJvb3QuYXBwZW5kQ2hpbGQoYnV0dG9uQ29udGFpbmVyKTtcbiAgdmlld01haW4uc3R5bGUuaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodCAtIDgwICsgJ3B4JztcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKHJvb3QpO1xuICB0aGlzLl9kb20gPSByb290O1xufTtcblxuRGF0YVZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgdGhpcy5fZG9tICYmIGFwaS5nZXREb20oKS5yZW1vdmVDaGlsZCh0aGlzLl9kb20pO1xufTtcblxuRGF0YVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gIHRoaXMucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG59O1xuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyeU1lcmdlRGF0YU9wdGlvbihuZXdEYXRhLCBvcmlnaW5hbERhdGEpIHtcbiAgcmV0dXJuIHpyVXRpbC5tYXAobmV3RGF0YSwgZnVuY3Rpb24gKG5ld1ZhbCwgaWR4KSB7XG4gICAgdmFyIG9yaWdpbmFsID0gb3JpZ2luYWxEYXRhICYmIG9yaWdpbmFsRGF0YVtpZHhdO1xuXG4gICAgaWYgKHpyVXRpbC5pc09iamVjdChvcmlnaW5hbCkgJiYgIXpyVXRpbC5pc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChuZXdWYWwpICYmICF6clV0aWwuaXNBcnJheShuZXdWYWwpKSB7XG4gICAgICAgIG5ld1ZhbCA9IG5ld1ZhbC52YWx1ZTtcbiAgICAgIH0gLy8gT3JpZ2luYWwgZGF0YSBoYXMgb3B0aW9uXG5cblxuICAgICAgcmV0dXJuIHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgIHZhbHVlOiBuZXdWYWxcbiAgICAgIH0sIG9yaWdpbmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICB9XG4gIH0pO1xufVxuXG5mZWF0dXJlTWFuYWdlci5yZWdpc3RlcignZGF0YVZpZXcnLCBEYXRhVmlldyk7XG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ2NoYW5nZURhdGFWaWV3JyxcbiAgZXZlbnQ6ICdkYXRhVmlld0NoYW5nZWQnLFxuICB1cGRhdGU6ICdwcmVwYXJlQW5kVXBkYXRlJ1xufSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgdmFyIG5ld1Nlcmllc09wdExpc3QgPSBbXTtcbiAgenJVdGlsLmVhY2gocGF5bG9hZC5uZXdPcHRpb24uc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeU5hbWUoc2VyaWVzT3B0Lm5hbWUpWzBdO1xuXG4gICAgaWYgKCFzZXJpZXNNb2RlbCkge1xuICAgICAgLy8gTmV3IGNyZWF0ZWQgc2VyaWVzXG4gICAgICAvLyBHZXVzcyB0aGUgc2VyaWVzIHR5cGVcbiAgICAgIG5ld1Nlcmllc09wdExpc3QucHVzaCh6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgLy8gRGVmYXVsdCBpcyBzY2F0dGVyXG4gICAgICAgIHR5cGU6ICdzY2F0dGVyJ1xuICAgICAgfSwgc2VyaWVzT3B0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvcmlnaW5hbERhdGEgPSBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKTtcbiAgICAgIG5ld1Nlcmllc09wdExpc3QucHVzaCh7XG4gICAgICAgIG5hbWU6IHNlcmllc09wdC5uYW1lLFxuICAgICAgICBkYXRhOiB0cnlNZXJnZURhdGFPcHRpb24oc2VyaWVzT3B0LmRhdGEsIG9yaWdpbmFsRGF0YSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGVjTW9kZWwubWVyZ2VPcHRpb24oenJVdGlsLmRlZmF1bHRzKHtcbiAgICBzZXJpZXM6IG5ld1Nlcmllc09wdExpc3RcbiAgfSwgcGF5bG9hZC5uZXdPcHRpb24pKTtcbn0pO1xudmFyIF9kZWZhdWx0ID0gRGF0YVZpZXc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDMwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgQnJ1c2hDb250cm9sbGVyID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlci9CcnVzaENvbnRyb2xsZXJcIik7XG5cbnZhciBCcnVzaFRhcmdldE1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVyL0JydXNoVGFyZ2V0TWFuYWdlclwiKTtcblxudmFyIGhpc3RvcnkgPSByZXF1aXJlKFwiLi4vLi4vZGF0YVpvb20vaGlzdG9yeVwiKTtcblxudmFyIHNsaWRlck1vdmUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVyL3NsaWRlck1vdmVcIik7XG5cbnZhciBsYW5nID0gcmVxdWlyZShcIi4uLy4uLy4uL2xhbmdcIik7XG5cbnZhciBmZWF0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9mZWF0dXJlTWFuYWdlclwiKTtcblxucmVxdWlyZShcIi4uLy4uL2RhdGFab29tU2VsZWN0XCIpO1xuXG4vLyBVc2UgZGF0YVpvb21TZWxlY3RcbnZhciBkYXRhWm9vbUxhbmcgPSBsYW5nLnRvb2xib3guZGF0YVpvb207XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoOyAvLyBTcGVjdGlhbCBjb21wb25lbnQgaWQgc3RhcnQgd2l0aCBcXDBlY1xcMCwgc2VlIGVjaGFydHMvbW9kZWwvR2xvYmFsLmpzfmhhc0lubmVySWRcblxudmFyIERBVEFfWk9PTV9JRF9CQVNFID0gJ1xcMF9lY19cXDB0b29sYm94LWRhdGFab29tXyc7XG5cbmZ1bmN0aW9uIERhdGFab29tKG1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlcn1cbiAgICovXG4gICh0aGlzLl9icnVzaENvbnRyb2xsZXIgPSBuZXcgQnJ1c2hDb250cm9sbGVyKGFwaS5nZXRacigpKSkub24oJ2JydXNoJywgenJVdGlsLmJpbmQodGhpcy5fb25CcnVzaCwgdGhpcykpLm1vdW50KCk7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cbiAgdGhpcy5faXNab29tQWN0aXZlO1xufVxuXG5EYXRhWm9vbS5kZWZhdWx0T3B0aW9uID0ge1xuICBzaG93OiB0cnVlLFxuICAvLyBJY29uIGdyb3VwXG4gIGljb246IHtcbiAgICB6b29tOiAnTTAsMTMuNWgyNi45IE0xMy41LDI2LjlWMCBNMzIuMSwxMy41SDU4VjU4SDEzLjUgVjMyLjEnLFxuICAgIGJhY2s6ICdNMjIsMS40TDkuOSwxMy41bDEyLjMsMTIuMyBNMTAuMywxMy41SDU0Ljl2NDQuNiBIMTAuM3YtMjYnXG4gIH0sXG4gIC8vIGB6b29tYCwgYGJhY2tgXG4gIHRpdGxlOiB6clV0aWwuY2xvbmUoZGF0YVpvb21MYW5nLnRpdGxlKVxufTtcbnZhciBwcm90byA9IERhdGFab29tLnByb3RvdHlwZTtcblxucHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gIHRoaXMubW9kZWwgPSBmZWF0dXJlTW9kZWw7XG4gIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gIHRoaXMuYXBpID0gYXBpO1xuICB1cGRhdGVab29tQnRuU3RhdHVzKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgdGhpcywgcGF5bG9hZCwgYXBpKTtcbiAgdXBkYXRlQmFja0J0blN0YXR1cyhmZWF0dXJlTW9kZWwsIGVjTW9kZWwpO1xufTtcblxucHJvdG8ub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGksIHR5cGUpIHtcbiAgaGFuZGxlcnNbdHlwZV0uY2FsbCh0aGlzKTtcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgdGhpcy5fYnJ1c2hDb250cm9sbGVyLnVubW91bnQoKTtcbn07XG5cbnByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gIHRoaXMuX2JydXNoQ29udHJvbGxlci5kaXNwb3NlKCk7XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIGhhbmRsZXJzID0ge1xuICB6b29tOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRBY3RpdmUgPSAhdGhpcy5faXNab29tQWN0aXZlO1xuICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICd0YWtlR2xvYmFsQ3Vyc29yJyxcbiAgICAgIGtleTogJ2RhdGFab29tU2VsZWN0JyxcbiAgICAgIGRhdGFab29tU2VsZWN0QWN0aXZlOiBuZXh0QWN0aXZlXG4gICAgfSk7XG4gIH0sXG4gIGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oaGlzdG9yeS5wb3AodGhpcy5lY01vZGVsKSk7XG4gIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxucHJvdG8uX29uQnJ1c2ggPSBmdW5jdGlvbiAoYXJlYXMsIG9wdCkge1xuICBpZiAoIW9wdC5pc0VuZCB8fCAhYXJlYXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNuYXBzaG90ID0ge307XG4gIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuXG4gIHRoaXMuX2JydXNoQ29udHJvbGxlci51cGRhdGVDb3ZlcnMoW10pOyAvLyByZW1vdmUgY292ZXJcblxuXG4gIHZhciBicnVzaFRhcmdldE1hbmFnZXIgPSBuZXcgQnJ1c2hUYXJnZXRNYW5hZ2VyKHJldHJpZXZlQXhpc1NldHRpbmcodGhpcy5tb2RlbC5vcHRpb24pLCBlY01vZGVsLCB7XG4gICAgaW5jbHVkZTogWydncmlkJ11cbiAgfSk7XG4gIGJydXNoVGFyZ2V0TWFuYWdlci5tYXRjaE91dHB1dFJhbmdlcyhhcmVhcywgZWNNb2RlbCwgZnVuY3Rpb24gKGFyZWEsIGNvb3JkUmFuZ2UsIGNvb3JkU3lzKSB7XG4gICAgaWYgKGNvb3JkU3lzLnR5cGUgIT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYnJ1c2hUeXBlID0gYXJlYS5icnVzaFR5cGU7XG5cbiAgICBpZiAoYnJ1c2hUeXBlID09PSAncmVjdCcpIHtcbiAgICAgIHNldEJhdGNoKCd4JywgY29vcmRTeXMsIGNvb3JkUmFuZ2VbMF0pO1xuICAgICAgc2V0QmF0Y2goJ3knLCBjb29yZFN5cywgY29vcmRSYW5nZVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEJhdGNoKHtcbiAgICAgICAgbGluZVg6ICd4JyxcbiAgICAgICAgbGluZVk6ICd5J1xuICAgICAgfVticnVzaFR5cGVdLCBjb29yZFN5cywgY29vcmRSYW5nZSk7XG4gICAgfVxuICB9KTtcbiAgaGlzdG9yeS5wdXNoKGVjTW9kZWwsIHNuYXBzaG90KTtcblxuICB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oc25hcHNob3QpO1xuXG4gIGZ1bmN0aW9uIHNldEJhdGNoKGRpbU5hbWUsIGNvb3JkU3lzLCBtaW5NYXgpIHtcbiAgICB2YXIgYXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoZGltTmFtZSk7XG4gICAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSBmaW5kRGF0YVpvb20oZGltTmFtZSwgYXhpc01vZGVsLCBlY01vZGVsKTsgLy8gUmVzdHJpY3QgcmFuZ2UuXG5cbiAgICB2YXIgbWluTWF4U3BhbiA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KGF4aXNNb2RlbCkuZ2V0TWluTWF4U3BhbigpO1xuXG4gICAgaWYgKG1pbk1heFNwYW4ubWluVmFsdWVTcGFuICE9IG51bGwgfHwgbWluTWF4U3Bhbi5tYXhWYWx1ZVNwYW4gIT0gbnVsbCkge1xuICAgICAgbWluTWF4ID0gc2xpZGVyTW92ZSgwLCBtaW5NYXguc2xpY2UoKSwgYXhpcy5zY2FsZS5nZXRFeHRlbnQoKSwgMCwgbWluTWF4U3Bhbi5taW5WYWx1ZVNwYW4sIG1pbk1heFNwYW4ubWF4VmFsdWVTcGFuKTtcbiAgICB9XG5cbiAgICBkYXRhWm9vbU1vZGVsICYmIChzbmFwc2hvdFtkYXRhWm9vbU1vZGVsLmlkXSA9IHtcbiAgICAgIGRhdGFab29tSWQ6IGRhdGFab29tTW9kZWwuaWQsXG4gICAgICBzdGFydFZhbHVlOiBtaW5NYXhbMF0sXG4gICAgICBlbmRWYWx1ZTogbWluTWF4WzFdXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRGF0YVpvb20oZGltTmFtZSwgYXhpc01vZGVsLCBlY01vZGVsKSB7XG4gICAgdmFyIGZvdW5kO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogJ2RhdGFab29tJyxcbiAgICAgIHN1YlR5cGU6ICdzZWxlY3QnXG4gICAgfSwgZnVuY3Rpb24gKGR6TW9kZWwpIHtcbiAgICAgIHZhciBoYXMgPSBkek1vZGVsLmdldEF4aXNNb2RlbChkaW1OYW1lLCBheGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgaGFzICYmIChmb3VuZCA9IGR6TW9kZWwpO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbiAgfVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbnByb3RvLl9kaXNwYXRjaFpvb21BY3Rpb24gPSBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgdmFyIGJhdGNoID0gW107IC8vIENvbnZlcnQgZnJvbSBoYXNoIG1hcCB0byBhcnJheS5cblxuICBlYWNoKHNuYXBzaG90LCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBkYXRhWm9vbUlkKSB7XG4gICAgYmF0Y2gucHVzaCh6clV0aWwuY2xvbmUoYmF0Y2hJdGVtKSk7XG4gIH0pO1xuICBiYXRjaC5sZW5ndGggJiYgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdkYXRhWm9vbScsXG4gICAgZnJvbTogdGhpcy51aWQsXG4gICAgYmF0Y2g6IGJhdGNoXG4gIH0pO1xufTtcblxuZnVuY3Rpb24gcmV0cmlldmVBeGlzU2V0dGluZyhvcHRpb24pIHtcbiAgdmFyIHNldHRpbmcgPSB7fTsgLy8gQ29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIHNldHRpbmc6IG51bGwgPT4gYWxsIGF4aXMsIGZhbHNlID0+IG5vIGF4aXMuXG5cbiAgenJVdGlsLmVhY2goWyd4QXhpc0luZGV4JywgJ3lBeGlzSW5kZXgnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBzZXR0aW5nW25hbWVdID0gb3B0aW9uW25hbWVdO1xuICAgIHNldHRpbmdbbmFtZV0gPT0gbnVsbCAmJiAoc2V0dGluZ1tuYW1lXSA9ICdhbGwnKTtcbiAgICAoc2V0dGluZ1tuYW1lXSA9PT0gZmFsc2UgfHwgc2V0dGluZ1tuYW1lXSA9PT0gJ25vbmUnKSAmJiAoc2V0dGluZ1tuYW1lXSA9IFtdKTtcbiAgfSk7XG4gIHJldHVybiBzZXR0aW5nO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVCYWNrQnRuU3RhdHVzKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCkge1xuICBmZWF0dXJlTW9kZWwuc2V0SWNvblN0YXR1cygnYmFjaycsIGhpc3RvcnkuY291bnQoZWNNb2RlbCkgPiAxID8gJ2VtcGhhc2lzJyA6ICdub3JtYWwnKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlWm9vbUJ0blN0YXR1cyhmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIHZpZXcsIHBheWxvYWQsIGFwaSkge1xuICB2YXIgem9vbUFjdGl2ZSA9IHZpZXcuX2lzWm9vbUFjdGl2ZTtcblxuICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLnR5cGUgPT09ICd0YWtlR2xvYmFsQ3Vyc29yJykge1xuICAgIHpvb21BY3RpdmUgPSBwYXlsb2FkLmtleSA9PT0gJ2RhdGFab29tU2VsZWN0JyA/IHBheWxvYWQuZGF0YVpvb21TZWxlY3RBY3RpdmUgOiBmYWxzZTtcbiAgfVxuXG4gIHZpZXcuX2lzWm9vbUFjdGl2ZSA9IHpvb21BY3RpdmU7XG4gIGZlYXR1cmVNb2RlbC5zZXRJY29uU3RhdHVzKCd6b29tJywgem9vbUFjdGl2ZSA/ICdlbXBoYXNpcycgOiAnbm9ybWFsJyk7XG4gIHZhciBicnVzaFRhcmdldE1hbmFnZXIgPSBuZXcgQnJ1c2hUYXJnZXRNYW5hZ2VyKHJldHJpZXZlQXhpc1NldHRpbmcoZmVhdHVyZU1vZGVsLm9wdGlvbiksIGVjTW9kZWwsIHtcbiAgICBpbmNsdWRlOiBbJ2dyaWQnXVxuICB9KTtcblxuICB2aWV3Ll9icnVzaENvbnRyb2xsZXIuc2V0UGFuZWxzKGJydXNoVGFyZ2V0TWFuYWdlci5tYWtlUGFuZWxPcHRzKGFwaSwgZnVuY3Rpb24gKHRhcmdldEluZm8pIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5mby54QXhpc0RlY2xhcmVkICYmICF0YXJnZXRJbmZvLnlBeGlzRGVjbGFyZWQgPyAnbGluZVgnIDogIXRhcmdldEluZm8ueEF4aXNEZWNsYXJlZCAmJiB0YXJnZXRJbmZvLnlBeGlzRGVjbGFyZWQgPyAnbGluZVknIDogJ3JlY3QnO1xuICB9KSkuZW5hYmxlQnJ1c2goem9vbUFjdGl2ZSA/IHtcbiAgICBicnVzaFR5cGU6ICdhdXRvJyxcbiAgICBicnVzaFN0eWxlOiB7XG4gICAgICAvLyBGSVhNRSB1c2VyIGN1c3RvbWl6ZWQ/XG4gICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICBmaWxsOiAncmdiYSgwLDAsMCwwLjIpJ1xuICAgIH1cbiAgfSA6IGZhbHNlKTtcbn1cblxuZmVhdHVyZU1hbmFnZXIucmVnaXN0ZXIoJ2RhdGFab29tJywgRGF0YVpvb20pOyAvLyBDcmVhdGUgc3BlY2lhbCBkYXRhWm9vbSBvcHRpb24gZm9yIHNlbGVjdFxuXG5lY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgaWYgKCFvcHRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YVpvb21PcHRzID0gb3B0aW9uLmRhdGFab29tIHx8IChvcHRpb24uZGF0YVpvb20gPSBbXSk7XG5cbiAgaWYgKCF6clV0aWwuaXNBcnJheShkYXRhWm9vbU9wdHMpKSB7XG4gICAgb3B0aW9uLmRhdGFab29tID0gZGF0YVpvb21PcHRzID0gW2RhdGFab29tT3B0c107XG4gIH1cblxuICB2YXIgdG9vbGJveE9wdCA9IG9wdGlvbi50b29sYm94O1xuXG4gIGlmICh0b29sYm94T3B0KSB7XG4gICAgLy8gQXNzdW1lIHRoZXJlIGlzIG9ubHkgb25lIHRvb2xib3hcbiAgICBpZiAoenJVdGlsLmlzQXJyYXkodG9vbGJveE9wdCkpIHtcbiAgICAgIHRvb2xib3hPcHQgPSB0b29sYm94T3B0WzBdO1xuICAgIH1cblxuICAgIGlmICh0b29sYm94T3B0ICYmIHRvb2xib3hPcHQuZmVhdHVyZSkge1xuICAgICAgdmFyIGRhdGFab29tT3B0ID0gdG9vbGJveE9wdC5mZWF0dXJlLmRhdGFab29tO1xuICAgICAgYWRkRm9yQXhpcygneEF4aXMnLCBkYXRhWm9vbU9wdCk7XG4gICAgICBhZGRGb3JBeGlzKCd5QXhpcycsIGRhdGFab29tT3B0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRGb3JBeGlzKGF4aXNOYW1lLCBkYXRhWm9vbU9wdCkge1xuICAgIGlmICghZGF0YVpvb21PcHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRyeSBub3QgdG8gbW9kaWZ5IG1vZGVsLCBiZWNhdXNlIGl0IGlzIG5vdCBtZXJnZWQgeWV0LlxuXG5cbiAgICB2YXIgYXhpc0luZGljZXNOYW1lID0gYXhpc05hbWUgKyAnSW5kZXgnO1xuICAgIHZhciBnaXZlbkF4aXNJbmRpY2VzID0gZGF0YVpvb21PcHRbYXhpc0luZGljZXNOYW1lXTtcblxuICAgIGlmIChnaXZlbkF4aXNJbmRpY2VzICE9IG51bGwgJiYgZ2l2ZW5BeGlzSW5kaWNlcyAhPSAnYWxsJyAmJiAhenJVdGlsLmlzQXJyYXkoZ2l2ZW5BeGlzSW5kaWNlcykpIHtcbiAgICAgIGdpdmVuQXhpc0luZGljZXMgPSBnaXZlbkF4aXNJbmRpY2VzID09PSBmYWxzZSB8fCBnaXZlbkF4aXNJbmRpY2VzID09PSAnbm9uZScgPyBbXSA6IFtnaXZlbkF4aXNJbmRpY2VzXTtcbiAgICB9XG5cbiAgICBmb3JFYWNoQ29tcG9uZW50KGF4aXNOYW1lLCBmdW5jdGlvbiAoYXhpc09wdCwgYXhpc0luZGV4KSB7XG4gICAgICBpZiAoZ2l2ZW5BeGlzSW5kaWNlcyAhPSBudWxsICYmIGdpdmVuQXhpc0luZGljZXMgIT0gJ2FsbCcgJiYgenJVdGlsLmluZGV4T2YoZ2l2ZW5BeGlzSW5kaWNlcywgYXhpc0luZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3T3B0ID0ge1xuICAgICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgICAgJGZyb21Ub29sYm94OiB0cnVlLFxuICAgICAgICAvLyBJZCBmb3IgbWVyZ2UgbWFwcGluZy5cbiAgICAgICAgaWQ6IERBVEFfWk9PTV9JRF9CQVNFICsgYXhpc05hbWUgKyBheGlzSW5kZXhcbiAgICAgIH07IC8vIEZJWE1FXG4gICAgICAvLyBPbmx5IHN1cHBvcnQgb25lIGF4aXMgbm93LlxuXG4gICAgICBuZXdPcHRbYXhpc0luZGljZXNOYW1lXSA9IGF4aXNJbmRleDtcbiAgICAgIGRhdGFab29tT3B0cy5wdXNoKG5ld09wdCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoQ29tcG9uZW50KG1haW5UeXBlLCBjYikge1xuICAgIHZhciBvcHRzID0gb3B0aW9uW21haW5UeXBlXTtcblxuICAgIGlmICghenJVdGlsLmlzQXJyYXkob3B0cykpIHtcbiAgICAgIG9wdHMgPSBvcHRzID8gW29wdHNdIDogW107XG4gICAgfVxuXG4gICAgZWFjaChvcHRzLCBjYik7XG4gIH1cbn0pO1xudmFyIF9kZWZhdWx0ID0gRGF0YVpvb207XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVpvb20uanNcbi8vIG1vZHVsZSBpZCA9IDMwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIGludGVyYWN0aW9uTXV0ZXggPSByZXF1aXJlKFwiLi9pbnRlcmFjdGlvbk11dGV4XCIpO1xuXG52YXIgRGF0YURpZmZlciA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL0RhdGFEaWZmZXJcIik7XG5cbnZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgbWFwID0genJVdGlsLm1hcDtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbnZhciBDT1ZFUl9aID0gMTAwMDA7XG52YXIgVU5TRUxFQ1RfVEhSRVNIT0xEID0gNjtcbnZhciBNSU5fUkVTSVpFX0xJTkVfV0lEVEggPSA2O1xudmFyIE1VVEVYX1JFU09VUkNFX0tFWSA9ICdnbG9iYWxQYW4nO1xudmFyIERJUkVDVElPTl9NQVAgPSB7XG4gIHc6IFswLCAwXSxcbiAgZTogWzAsIDFdLFxuICBuOiBbMSwgMF0sXG4gIHM6IFsxLCAxXVxufTtcbnZhciBDVVJTT1JfTUFQID0ge1xuICB3OiAnZXcnLFxuICBlOiAnZXcnLFxuICBuOiAnbnMnLFxuICBzOiAnbnMnLFxuICBuZTogJ25lc3cnLFxuICBzdzogJ25lc3cnLFxuICBudzogJ253c2UnLFxuICBzZTogJ253c2UnXG59O1xudmFyIERFRkFVTFRfQlJVU0hfT1BUID0ge1xuICBicnVzaFN0eWxlOiB7XG4gICAgbGluZVdpZHRoOiAyLFxuICAgIHN0cm9rZTogJ3JnYmEoMCwwLDAsMC4zKScsXG4gICAgZmlsbDogJ3JnYmEoMCwwLDAsMC4xKSdcbiAgfSxcbiAgdHJhbnNmb3JtYWJsZTogdHJ1ZSxcbiAgYnJ1c2hNb2RlOiAnc2luZ2xlJyxcbiAgcmVtb3ZlT25DbGljazogZmFsc2Vcbn07XG52YXIgYmFzZVVJRCA9IDA7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWl4aW4ge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICogQGV2ZW50IG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyI2JydXNoXG4gKiAgICAgICAgcGFyYW1zOlxuICogICAgICAgICAgICBhcmVhczogQXJyYXkuPEFycmF5PiwgY29vcmQgcmVsYXRlcyB0byBjb250YWluZXIgZ3JvdXAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vIGNvbnRhaW5lciBzcGVjaWZpZWQsIHRvIGdsb2JhbC5cbiAqICAgICAgICAgICAgb3B0IHtcbiAqICAgICAgICAgICAgICAgIGlzRW5kOiBib29sZWFuLFxuICogICAgICAgICAgICAgICAgcmVtb3ZlT25DbGljazogYm9vbGVhblxuICogICAgICAgICAgICB9XG4gKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci96cmVuZGVyflpSZW5kZXJ9IHpyXG4gKi9cblxuZnVuY3Rpb24gQnJ1c2hDb250cm9sbGVyKHpyKSB7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvenJlbmRlcn5aUmVuZGVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl96ciA9IHpyO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuXG4gIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAvKipcbiAgICogT25seSBmb3IgZHJhd2luZyAoYWZ0ZXIgZW5hYmxlZEJydXNoKS5cbiAgICogICAgICdsaW5lJywgJ3JlY3QnLCAncG9seWdvbicgb3IgZmFsc2VcbiAgICogICAgIElmIHBhc3NpbmcgZmFsc2UvbnVsbC91bmRlZmluZWQsIGRpc2FibGUgYnJ1c2guXG4gICAqICAgICBJZiBwYXNzaW5nICdhdXRvJywgZGV0ZXJtaW5lZCBieSBwYW5lbC5kZWZhdWx0QnJ1c2hUeXBlXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuX2JydXNoVHlwZTtcbiAgLyoqXG4gICAqIE9ubHkgZm9yIGRyYXdpbmcgKGFmdGVyIGVuYWJsZWRCcnVzaCkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX2JydXNoT3B0aW9uO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5fcGFuZWxzO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxudWJtZXI+fVxuICAgKi9cblxuICB0aGlzLl90cmFjayA9IFtdO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMuX2RyYWdnaW5nO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cblxuICB0aGlzLl9jb3ZlcnMgPSBbXTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb3VkdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgKi9cblxuICB0aGlzLl9jcmVhdGluZ0NvdmVyO1xuICAvKipcbiAgICogYHRydWVgIG1lYW5zIGdsb2JhbCBwYW5lbFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfGJvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMuX2NyZWF0aW5nUGFuZWw7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cbiAgdGhpcy5fZW5hYmxlR2xvYmFsUGFuO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5fdWlkID0gJ2JydXNoQ29udHJvbGxlcl8nICsgYmFzZVVJRCsrO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgZWFjaChtb3VzZUhhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlciwgZXZlbnROYW1lKSB7XG4gICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSA9IHpyVXRpbC5iaW5kKGhhbmRsZXIsIHRoaXMpO1xuICB9LCB0aGlzKTtcbn1cblxuQnJ1c2hDb250cm9sbGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEJydXNoQ29udHJvbGxlcixcblxuICAvKipcbiAgICogSWYgc2V0IHRvIG51bGwvdW5kZWZpbmVkL2ZhbHNlLCBzZWxlY3QgZGlzYWJsZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBicnVzaE9wdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBicnVzaE9wdGlvbi5icnVzaFR5cGUgJ2xpbmUnLCAncmVjdCcsICdwb2x5Z29uJyBvciBmYWxzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgcGFzc2luZyBmYWxzZS9udWxsL3VuZGVmaW5lZCwgZGlzYWJsZSBicnVzaC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIElmIHBhc3NpbmcgJ2F1dG8nLCBkZXRlcm1pbmVkIGJ5IHBhbmVsLmRlZmF1bHRCcnVzaFR5cGUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhdXRvJyBjYW4gbm90IGJlIHVzZWQgaW4gZ2xvYmFsIHBhbmVsKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2JydXNoT3B0aW9uLmJydXNoTW9kZT0nc2luZ2xlJ10gJ3NpbmdsZScgb3IgJ211bHRpcGxlJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFticnVzaE9wdGlvbi50cmFuc2Zvcm1hYmxlPXRydWVdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JydXNoT3B0aW9uLnJlbW92ZU9uQ2xpY2s9ZmFsc2VdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYnJ1c2hPcHRpb24uYnJ1c2hTdHlsZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLndpZHRoXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2JydXNoT3B0aW9uLmJydXNoU3R5bGUubGluZVdpZHRoXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2JydXNoT3B0aW9uLmJydXNoU3R5bGUuc3Ryb2tlXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2JydXNoT3B0aW9uLmJydXNoU3R5bGUuZmlsbF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFticnVzaE9wdGlvbi56XVxuICAgKi9cbiAgZW5hYmxlQnJ1c2g6IGZ1bmN0aW9uIChicnVzaE9wdGlvbikge1xuICAgIHRoaXMuX2JydXNoVHlwZSAmJiBkb0Rpc2FibGVCcnVzaCh0aGlzKTtcbiAgICBicnVzaE9wdGlvbi5icnVzaFR5cGUgJiYgZG9FbmFibGVCcnVzaCh0aGlzLCBicnVzaE9wdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHBhbmVsT3B0cyBJZiBub3QgcGFzcywgaXQgaXMgZ2xvYmFsIGJydXNoLlxuICAgKiAgICAgICAgRWFjaCBpdGVtczoge1xuICAgKiAgICAgICAgICAgIHBhbmVsSWQsIC8vIG1hbmRhdG9yeS5cbiAgICogICAgICAgICAgICBjbGlwUGF0aCwgLy8gbWFuZGF0b3J5LiBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICBpc1RhcmdldEJ5Q3Vyc29yLCAvLyBtYW5kYXRvcnkuIGZ1bmN0aW9uLlxuICAgKiAgICAgICAgICAgIGRlZmF1bHRCcnVzaFR5cGUsIC8vIG9wdGlvbmFsLCBvbmx5IHVzZWQgd2hlbiBicnVzaFR5cGUgaXMgJ2F1dG8nLlxuICAgKiAgICAgICAgICAgIGdldExpbmVhckJydXNoT3RoZXJFeHRlbnQsIC8vIG9wdGlvbmFsLiBmdW5jdGlvbi5cbiAgICogICAgICAgIH1cbiAgICovXG4gIHNldFBhbmVsczogZnVuY3Rpb24gKHBhbmVsT3B0cykge1xuICAgIGlmIChwYW5lbE9wdHMgJiYgcGFuZWxPcHRzLmxlbmd0aCkge1xuICAgICAgdmFyIHBhbmVscyA9IHRoaXMuX3BhbmVscyA9IHt9O1xuICAgICAgenJVdGlsLmVhY2gocGFuZWxPcHRzLCBmdW5jdGlvbiAocGFuZWxPcHRzKSB7XG4gICAgICAgIHBhbmVsc1twYW5lbE9wdHMucGFuZWxJZF0gPSB6clV0aWwuY2xvbmUocGFuZWxPcHRzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYW5lbHMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gW29wdC5lbmFibGVHbG9iYWxQYW49ZmFsc2VdXG4gICAqL1xuICBtb3VudDogZnVuY3Rpb24gKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB0aGlzLl9lbmFibGVHbG9iYWxQYW4gPSBvcHQuZW5hYmxlR2xvYmFsUGFuO1xuICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuXG4gICAgdGhpcy5fenIuYWRkKHRoaXNHcm91cCk7XG5cbiAgICB0aGlzR3JvdXAuYXR0cih7XG4gICAgICBwb3NpdGlvbjogb3B0LnBvc2l0aW9uIHx8IFswLCAwXSxcbiAgICAgIHJvdGF0aW9uOiBvcHQucm90YXRpb24gfHwgMCxcbiAgICAgIHNjYWxlOiBvcHQuc2NhbGUgfHwgWzEsIDFdXG4gICAgfSk7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gdGhpc0dyb3VwLmdldExvY2FsVHJhbnNmb3JtKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVhY2hDb3ZlcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZWFjaCh0aGlzLl9jb3ZlcnMsIGNiLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGNvdmVycy5cbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYnJ1c2hPcHRpb25MaXN0IExpa2U6XG4gICAqICAgICAgICBbXG4gICAqICAgICAgICAgICAge2lkOiAneHgnLCBicnVzaFR5cGU6ICdsaW5lJywgcmFuZ2U6IFsyMywgNDRdLCBicnVzaFN0eWxlLCB0cmFuc2Zvcm1hYmxlfSxcbiAgICogICAgICAgICAgICB7aWQ6ICd5eScsIGJydXNoVHlwZTogJ3JlY3QnLCByYW5nZTogW1syMywgNDRdLCBbMjMsIDU0XV19LFxuICAgKiAgICAgICAgICAgIC4uLlxuICAgKiAgICAgICAgXVxuICAgKiAgICAgICAgYGJydXNoVHlwZWAgaXMgcmVxdWlyZWQgaW4gZWFjaCBjb3ZlciBpbmZvLiAoY2FuIG5vdCBiZSAnYXV0bycpXG4gICAqICAgICAgICBgaWRgIGlzIG5vdCBtYW5kYXRvcnkuXG4gICAqICAgICAgICBgYnJ1c2hTdHlsZWAsIGB0cmFuc2Zvcm1hYmxlYCBpcyBub3QgbWFuZGF0b3J5LCB1c2UgREVGQVVMVF9CUlVTSF9PUFQgYnkgZGVmYXVsdC5cbiAgICogICAgICAgIElmIGJydXNoT3B0aW9uTGlzdCBpcyBudWxsL3VuZGVmaW5lZCwgYWxsIGNvdmVycyByZW1vdmVkLlxuICAgKi9cbiAgdXBkYXRlQ292ZXJzOiBmdW5jdGlvbiAoYnJ1c2hPcHRpb25MaXN0KSB7XG4gICAgYnJ1c2hPcHRpb25MaXN0ID0genJVdGlsLm1hcChicnVzaE9wdGlvbkxpc3QsIGZ1bmN0aW9uIChicnVzaE9wdGlvbikge1xuICAgICAgcmV0dXJuIHpyVXRpbC5tZXJnZSh6clV0aWwuY2xvbmUoREVGQVVMVF9CUlVTSF9PUFQpLCBicnVzaE9wdGlvbiwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgdmFyIHRtcElkUHJlZml4ID0gJ1xcMC1icnVzaC1pbmRleC0nO1xuICAgIHZhciBvbGRDb3ZlcnMgPSB0aGlzLl9jb3ZlcnM7XG4gICAgdmFyIG5ld0NvdmVycyA9IHRoaXMuX2NvdmVycyA9IFtdO1xuICAgIHZhciBjb250cm9sbGVyID0gdGhpcztcbiAgICB2YXIgY3JlYXRpbmdDb3ZlciA9IHRoaXMuX2NyZWF0aW5nQ292ZXI7XG4gICAgbmV3IERhdGFEaWZmZXIob2xkQ292ZXJzLCBicnVzaE9wdGlvbkxpc3QsIG9sZEdldEtleSwgZ2V0S2V5KS5hZGQoYWRkT3JVcGRhdGUpLnVwZGF0ZShhZGRPclVwZGF0ZSkucmVtb3ZlKHJlbW92ZSkuZXhlY3V0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZ2V0S2V5KGJydXNoT3B0aW9uLCBpbmRleCkge1xuICAgICAgcmV0dXJuIChicnVzaE9wdGlvbi5pZCAhPSBudWxsID8gYnJ1c2hPcHRpb24uaWQgOiB0bXBJZFByZWZpeCArIGluZGV4KSArICctJyArIGJydXNoT3B0aW9uLmJydXNoVHlwZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbGRHZXRLZXkoY292ZXIsIGluZGV4KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5KGNvdmVyLl9fYnJ1c2hPcHRpb24sIGluZGV4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRPclVwZGF0ZShuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgIHZhciBuZXdCcnVzaE9wdGlvbiA9IGJydXNoT3B0aW9uTGlzdFtuZXdJbmRleF07IC8vIENvbnNpZGVyIHNldE9wdGlvbiBpbiBldmVudCBsaXN0ZW5lciBvZiBicnVzaFNlbGVjdCxcbiAgICAgIC8vIHdoZXJlIHVwZGF0aW5nIGNvdmVyIHdoZW4gY3JlYXRpbmcgc2hvdWxkIGJlIGZvcmJpZGVuLlxuXG4gICAgICBpZiAob2xkSW5kZXggIT0gbnVsbCAmJiBvbGRDb3ZlcnNbb2xkSW5kZXhdID09PSBjcmVhdGluZ0NvdmVyKSB7XG4gICAgICAgIG5ld0NvdmVyc1tuZXdJbmRleF0gPSBvbGRDb3ZlcnNbb2xkSW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvdmVyID0gbmV3Q292ZXJzW25ld0luZGV4XSA9IG9sZEluZGV4ICE9IG51bGwgPyAob2xkQ292ZXJzW29sZEluZGV4XS5fX2JydXNoT3B0aW9uID0gbmV3QnJ1c2hPcHRpb24sIG9sZENvdmVyc1tvbGRJbmRleF0pIDogZW5kQ3JlYXRpbmcoY29udHJvbGxlciwgY3JlYXRlQ292ZXIoY29udHJvbGxlciwgbmV3QnJ1c2hPcHRpb24pKTtcbiAgICAgICAgdXBkYXRlQ292ZXJBZnRlckNyZWF0aW9uKGNvbnRyb2xsZXIsIGNvdmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUob2xkSW5kZXgpIHtcbiAgICAgIGlmIChvbGRDb3ZlcnNbb2xkSW5kZXhdICE9PSBjcmVhdGluZ0NvdmVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZ3JvdXAucmVtb3ZlKG9sZENvdmVyc1tvbGRJbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgdW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlQnJ1c2goZmFsc2UpOyAvLyBjb250YWluZXIgbWF5ICdyZW1vdmVBbGwnIG91dHNpZGUuXG5cbiAgICBjbGVhckNvdmVycyh0aGlzKTtcblxuICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLmdyb3VwKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51bm1vdW50KCk7XG4gICAgdGhpcy5vZmYoKTtcbiAgfVxufTtcbnpyVXRpbC5taXhpbihCcnVzaENvbnRyb2xsZXIsIEV2ZW50ZnVsKTtcblxuZnVuY3Rpb24gZG9FbmFibGVCcnVzaChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICB2YXIgenIgPSBjb250cm9sbGVyLl96cjsgLy8gQ29uc2lkZXIgcm9hbSwgd2hpY2ggdGFrZXMgZ2xvYmFsUGFuIHRvby5cblxuICBpZiAoIWNvbnRyb2xsZXIuX2VuYWJsZUdsb2JhbFBhbikge1xuICAgIGludGVyYWN0aW9uTXV0ZXgudGFrZSh6ciwgTVVURVhfUkVTT1VSQ0VfS0VZLCBjb250cm9sbGVyLl91aWQpO1xuICB9XG5cbiAgZWFjaChjb250cm9sbGVyLl9oYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgIHpyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gIH0pO1xuICBjb250cm9sbGVyLl9icnVzaFR5cGUgPSBicnVzaE9wdGlvbi5icnVzaFR5cGU7XG4gIGNvbnRyb2xsZXIuX2JydXNoT3B0aW9uID0genJVdGlsLm1lcmdlKHpyVXRpbC5jbG9uZShERUZBVUxUX0JSVVNIX09QVCksIGJydXNoT3B0aW9uLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZG9EaXNhYmxlQnJ1c2goY29udHJvbGxlcikge1xuICB2YXIgenIgPSBjb250cm9sbGVyLl96cjtcbiAgaW50ZXJhY3Rpb25NdXRleC5yZWxlYXNlKHpyLCBNVVRFWF9SRVNPVVJDRV9LRVksIGNvbnRyb2xsZXIuX3VpZCk7XG4gIGVhY2goY29udHJvbGxlci5faGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyLCBldmVudE5hbWUpIHtcbiAgICB6ci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgfSk7XG4gIGNvbnRyb2xsZXIuX2JydXNoVHlwZSA9IGNvbnRyb2xsZXIuX2JydXNoT3B0aW9uID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ292ZXIoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pIHtcbiAgdmFyIGNvdmVyID0gY292ZXJSZW5kZXJlcnNbYnJ1c2hPcHRpb24uYnJ1c2hUeXBlXS5jcmVhdGVDb3Zlcihjb250cm9sbGVyLCBicnVzaE9wdGlvbik7XG4gIGNvdmVyLl9fYnJ1c2hPcHRpb24gPSBicnVzaE9wdGlvbjtcbiAgdXBkYXRlWihjb3ZlciwgYnJ1c2hPcHRpb24pO1xuICBjb250cm9sbGVyLmdyb3VwLmFkZChjb3Zlcik7XG4gIHJldHVybiBjb3Zlcjtcbn1cblxuZnVuY3Rpb24gZW5kQ3JlYXRpbmcoY29udHJvbGxlciwgY3JlYXRpbmdDb3Zlcikge1xuICB2YXIgY292ZXJSZW5kZXJlciA9IGdldENvdmVyUmVuZGVyZXIoY3JlYXRpbmdDb3Zlcik7XG5cbiAgaWYgKGNvdmVyUmVuZGVyZXIuZW5kQ3JlYXRpbmcpIHtcbiAgICBjb3ZlclJlbmRlcmVyLmVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgIHVwZGF0ZVooY3JlYXRpbmdDb3ZlciwgY3JlYXRpbmdDb3Zlci5fX2JydXNoT3B0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGluZ0NvdmVyO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gIGdldENvdmVyUmVuZGVyZXIoY292ZXIpLnVwZGF0ZUNvdmVyU2hhcGUoY29udHJvbGxlciwgY292ZXIsIGJydXNoT3B0aW9uLnJhbmdlLCBicnVzaE9wdGlvbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVooY292ZXIsIGJydXNoT3B0aW9uKSB7XG4gIHZhciB6ID0gYnJ1c2hPcHRpb24uejtcbiAgeiA9PSBudWxsICYmICh6ID0gQ09WRVJfWik7XG4gIGNvdmVyLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGVsLnogPSB6O1xuICAgIGVsLnoyID0gejsgLy8gQ29uc2lkZXIgaW4gZ2l2ZW4gY29udGFpbmVyLlxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ292ZXJBZnRlckNyZWF0aW9uKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gIGdldENvdmVyUmVuZGVyZXIoY292ZXIpLnVwZGF0ZUNvbW1vbihjb250cm9sbGVyLCBjb3Zlcik7XG4gIHVwZGF0ZUNvdmVyU2hhcGUoY29udHJvbGxlciwgY292ZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRDb3ZlclJlbmRlcmVyKGNvdmVyKSB7XG4gIHJldHVybiBjb3ZlclJlbmRlcmVyc1tjb3Zlci5fX2JydXNoT3B0aW9uLmJydXNoVHlwZV07XG59IC8vIHJldHVybiB0YXJnZXQgcGFuZWwgb3IgYHRydWVgIChtZWFucyBnbG9iYWwgcGFuZWwpXG5cblxuZnVuY3Rpb24gZ2V0UGFuZWxCeVBvaW50KGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpIHtcbiAgdmFyIHBhbmVscyA9IGNvbnRyb2xsZXIuX3BhbmVscztcblxuICBpZiAoIXBhbmVscykge1xuICAgIHJldHVybiB0cnVlOyAvLyBHbG9iYWwgcGFuZWxcbiAgfVxuXG4gIHZhciBwYW5lbDtcbiAgdmFyIHRyYW5zZm9ybSA9IGNvbnRyb2xsZXIuX3RyYW5zZm9ybTtcbiAgZWFjaChwYW5lbHMsIGZ1bmN0aW9uIChwbikge1xuICAgIHBuLmlzVGFyZ2V0QnlDdXJzb3IoZSwgbG9jYWxDdXJzb3JQb2ludCwgdHJhbnNmb3JtKSAmJiAocGFuZWwgPSBwbik7XG4gIH0pO1xuICByZXR1cm4gcGFuZWw7XG59IC8vIFJldHVybiBhIHBhbmVsIG9yIHRydWVcblxuXG5mdW5jdGlvbiBnZXRQYW5lbEJ5Q292ZXIoY29udHJvbGxlciwgY292ZXIpIHtcbiAgdmFyIHBhbmVscyA9IGNvbnRyb2xsZXIuX3BhbmVscztcblxuICBpZiAoIXBhbmVscykge1xuICAgIHJldHVybiB0cnVlOyAvLyBHbG9iYWwgcGFuZWxcbiAgfVxuXG4gIHZhciBwYW5lbElkID0gY292ZXIuX19icnVzaE9wdGlvbi5wYW5lbElkOyAvLyBVc2VyIG1heSBnaXZlIGNvdmVyIHdpdGhvdXQgY29vcmQgc3lzIGluZm8sXG4gIC8vIHdoaWNoIGlzIHRoZW4gdHJlYXRlZCBhcyBnbG9iYWwgcGFuZWwuXG5cbiAgcmV0dXJuIHBhbmVsSWQgIT0gbnVsbCA/IHBhbmVsc1twYW5lbElkXSA6IHRydWU7XG59XG5cbmZ1bmN0aW9uIGNsZWFyQ292ZXJzKGNvbnRyb2xsZXIpIHtcbiAgdmFyIGNvdmVycyA9IGNvbnRyb2xsZXIuX2NvdmVycztcbiAgdmFyIG9yaWdpbmFsTGVuZ3RoID0gY292ZXJzLmxlbmd0aDtcbiAgZWFjaChjb3ZlcnMsIGZ1bmN0aW9uIChjb3Zlcikge1xuICAgIGNvbnRyb2xsZXIuZ3JvdXAucmVtb3ZlKGNvdmVyKTtcbiAgfSwgY29udHJvbGxlcik7XG4gIGNvdmVycy5sZW5ndGggPSAwO1xuICByZXR1cm4gISFvcmlnaW5hbExlbmd0aDtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlcihjb250cm9sbGVyLCBvcHQpIHtcbiAgdmFyIGFyZWFzID0gbWFwKGNvbnRyb2xsZXIuX2NvdmVycywgZnVuY3Rpb24gKGNvdmVyKSB7XG4gICAgdmFyIGJydXNoT3B0aW9uID0gY292ZXIuX19icnVzaE9wdGlvbjtcbiAgICB2YXIgcmFuZ2UgPSB6clV0aWwuY2xvbmUoYnJ1c2hPcHRpb24ucmFuZ2UpO1xuICAgIHJldHVybiB7XG4gICAgICBicnVzaFR5cGU6IGJydXNoT3B0aW9uLmJydXNoVHlwZSxcbiAgICAgIHBhbmVsSWQ6IGJydXNoT3B0aW9uLnBhbmVsSWQsXG4gICAgICByYW5nZTogcmFuZ2VcbiAgICB9O1xuICB9KTtcbiAgY29udHJvbGxlci50cmlnZ2VyKCdicnVzaCcsIGFyZWFzLCB7XG4gICAgaXNFbmQ6ICEhb3B0LmlzRW5kLFxuICAgIHJlbW92ZU9uQ2xpY2s6ICEhb3B0LnJlbW92ZU9uQ2xpY2tcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFNob3dDb3Zlcihjb250cm9sbGVyKSB7XG4gIHZhciB0cmFjayA9IGNvbnRyb2xsZXIuX3RyYWNrO1xuXG4gIGlmICghdHJhY2subGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHAyID0gdHJhY2tbdHJhY2subGVuZ3RoIC0gMV07XG4gIHZhciBwMSA9IHRyYWNrWzBdO1xuICB2YXIgZHggPSBwMlswXSAtIHAxWzBdO1xuICB2YXIgZHkgPSBwMlsxXSAtIHAxWzFdO1xuICB2YXIgZGlzdCA9IG1hdGhQb3coZHggKiBkeCArIGR5ICogZHksIDAuNSk7XG4gIHJldHVybiBkaXN0ID4gVU5TRUxFQ1RfVEhSRVNIT0xEO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja0VuZHModHJhY2spIHtcbiAgdmFyIHRhaWwgPSB0cmFjay5sZW5ndGggLSAxO1xuICB0YWlsIDwgMCAmJiAodGFpbCA9IDApO1xuICByZXR1cm4gW3RyYWNrWzBdLCB0cmFja1t0YWlsXV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VSZWN0Q292ZXIoZG9EcmlmdCwgY29udHJvbGxlciwgYnJ1c2hPcHRpb24sIGVkZ2VOYW1lcykge1xuICB2YXIgY292ZXIgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgbmFtZTogJ21haW4nLFxuICAgIHN0eWxlOiBtYWtlU3R5bGUoYnJ1c2hPcHRpb24pLFxuICAgIHNpbGVudDogdHJ1ZSxcbiAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgY3Vyc29yOiAnbW92ZScsXG4gICAgZHJpZnQ6IGN1cnJ5KGRvRHJpZnQsIGNvbnRyb2xsZXIsIGNvdmVyLCAnbnN3ZScpLFxuICAgIG9uZHJhZ2VuZDogY3VycnkodHJpZ2dlciwgY29udHJvbGxlciwge1xuICAgICAgaXNFbmQ6IHRydWVcbiAgICB9KVxuICB9KSk7XG4gIGVhY2goZWRnZU5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGNvdmVyLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBzdHlsZToge1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LFxuICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgaW52aXNpYmxlOiB0cnVlLFxuICAgICAgZHJpZnQ6IGN1cnJ5KGRvRHJpZnQsIGNvbnRyb2xsZXIsIGNvdmVyLCBuYW1lKSxcbiAgICAgIG9uZHJhZ2VuZDogY3VycnkodHJpZ2dlciwgY29udHJvbGxlciwge1xuICAgICAgICBpc0VuZDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gY292ZXI7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUJhc2VSZWN0KGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlLCBicnVzaE9wdGlvbikge1xuICB2YXIgbGluZVdpZHRoID0gYnJ1c2hPcHRpb24uYnJ1c2hTdHlsZS5saW5lV2lkdGggfHwgMDtcbiAgdmFyIGhhbmRsZVNpemUgPSBtYXRoTWF4KGxpbmVXaWR0aCwgTUlOX1JFU0laRV9MSU5FX1dJRFRIKTtcbiAgdmFyIHggPSBsb2NhbFJhbmdlWzBdWzBdO1xuICB2YXIgeSA9IGxvY2FsUmFuZ2VbMV1bMF07XG4gIHZhciB4YSA9IHggLSBsaW5lV2lkdGggLyAyO1xuICB2YXIgeWEgPSB5IC0gbGluZVdpZHRoIC8gMjtcbiAgdmFyIHgyID0gbG9jYWxSYW5nZVswXVsxXTtcbiAgdmFyIHkyID0gbG9jYWxSYW5nZVsxXVsxXTtcbiAgdmFyIHgyYSA9IHgyIC0gaGFuZGxlU2l6ZSArIGxpbmVXaWR0aCAvIDI7XG4gIHZhciB5MmEgPSB5MiAtIGhhbmRsZVNpemUgKyBsaW5lV2lkdGggLyAyO1xuICB2YXIgd2lkdGggPSB4MiAtIHg7XG4gIHZhciBoZWlnaHQgPSB5MiAtIHk7XG4gIHZhciB3aWR0aGEgPSB3aWR0aCArIGxpbmVXaWR0aDtcbiAgdmFyIGhlaWdodGEgPSBoZWlnaHQgKyBsaW5lV2lkdGg7XG4gIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ21haW4nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblxuICBpZiAoYnJ1c2hPcHRpb24udHJhbnNmb3JtYWJsZSkge1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ3cnLCB4YSwgeWEsIGhhbmRsZVNpemUsIGhlaWdodGEpO1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ2UnLCB4MmEsIHlhLCBoYW5kbGVTaXplLCBoZWlnaHRhKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICduJywgeGEsIHlhLCB3aWR0aGEsIGhhbmRsZVNpemUpO1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ3MnLCB4YSwgeTJhLCB3aWR0aGEsIGhhbmRsZVNpemUpO1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ253JywgeGEsIHlhLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICduZScsIHgyYSwgeWEsIGhhbmRsZVNpemUsIGhhbmRsZVNpemUpO1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ3N3JywgeGEsIHkyYSwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnc2UnLCB4MmEsIHkyYSwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tbW9uKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gIHZhciB0cmFuc2Zvcm1hYmxlID0gYnJ1c2hPcHRpb24udHJhbnNmb3JtYWJsZTtcbiAgdmFyIG1haW5FbCA9IGNvdmVyLmNoaWxkQXQoMCk7XG4gIG1haW5FbC51c2VTdHlsZShtYWtlU3R5bGUoYnJ1c2hPcHRpb24pKTtcbiAgbWFpbkVsLmF0dHIoe1xuICAgIHNpbGVudDogIXRyYW5zZm9ybWFibGUsXG4gICAgY3Vyc29yOiB0cmFuc2Zvcm1hYmxlID8gJ21vdmUnIDogJ2RlZmF1bHQnXG4gIH0pO1xuICBlYWNoKFsndycsICdlJywgJ24nLCAncycsICdzZScsICdzdycsICduZScsICdudyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBlbCA9IGNvdmVyLmNoaWxkT2ZOYW1lKG5hbWUpO1xuICAgIHZhciBnbG9iYWxEaXIgPSBnZXRHbG9iYWxEaXJlY3Rpb24oY29udHJvbGxlciwgbmFtZSk7XG4gICAgZWwgJiYgZWwuYXR0cih7XG4gICAgICBzaWxlbnQ6ICF0cmFuc2Zvcm1hYmxlLFxuICAgICAgaW52aXNpYmxlOiAhdHJhbnNmb3JtYWJsZSxcbiAgICAgIGN1cnNvcjogdHJhbnNmb3JtYWJsZSA/IENVUlNPUl9NQVBbZ2xvYmFsRGlyXSArICctcmVzaXplJyA6IG51bGxcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgbmFtZSwgeCwgeSwgdywgaCkge1xuICB2YXIgZWwgPSBjb3Zlci5jaGlsZE9mTmFtZShuYW1lKTtcbiAgZWwgJiYgZWwuc2V0U2hhcGUocG9pbnRzVG9SZWN0KGNsaXBCeVBhbmVsKGNvbnRyb2xsZXIsIGNvdmVyLCBbW3gsIHldLCBbeCArIHcsIHkgKyBoXV0pKSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTdHlsZShicnVzaE9wdGlvbikge1xuICByZXR1cm4genJVdGlsLmRlZmF1bHRzKHtcbiAgICBzdHJva2VOb1NjYWxlOiB0cnVlXG4gIH0sIGJydXNoT3B0aW9uLmJydXNoU3R5bGUpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRSZWN0UmFuZ2UoeCwgeSwgeDIsIHkyKSB7XG4gIHZhciBtaW4gPSBbbWF0aE1pbih4LCB4MiksIG1hdGhNaW4oeSwgeTIpXTtcbiAgdmFyIG1heCA9IFttYXRoTWF4KHgsIHgyKSwgbWF0aE1heCh5LCB5MildO1xuICByZXR1cm4gW1ttaW5bMF0sIG1heFswXV0sIC8vIHggcmFuZ2VcbiAgW21pblsxXSwgbWF4WzFdXSAvLyB5IHJhbmdlXG4gIF07XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybShjb250cm9sbGVyKSB7XG4gIHJldHVybiBncmFwaGljLmdldFRyYW5zZm9ybShjb250cm9sbGVyLmdyb3VwKTtcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIGxvY2FsRGlyZWN0aW9uKSB7XG4gIGlmIChsb2NhbERpcmVjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgbG9jYWxEaXJlY3Rpb24gPSBsb2NhbERpcmVjdGlvbi5zcGxpdCgnJyk7XG4gICAgdmFyIGdsb2JhbERpciA9IFtnZXRHbG9iYWxEaXJlY3Rpb24oY29udHJvbGxlciwgbG9jYWxEaXJlY3Rpb25bMF0pLCBnZXRHbG9iYWxEaXJlY3Rpb24oY29udHJvbGxlciwgbG9jYWxEaXJlY3Rpb25bMV0pXTtcbiAgICAoZ2xvYmFsRGlyWzBdID09PSAnZScgfHwgZ2xvYmFsRGlyWzBdID09PSAndycpICYmIGdsb2JhbERpci5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGdsb2JhbERpci5qb2luKCcnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgdzogJ2xlZnQnLFxuICAgICAgZTogJ3JpZ2h0JyxcbiAgICAgIG46ICd0b3AnLFxuICAgICAgczogJ2JvdHRvbSdcbiAgICB9O1xuICAgIHZhciBpbnZlcnNlTWFwID0ge1xuICAgICAgbGVmdDogJ3cnLFxuICAgICAgcmlnaHQ6ICdlJyxcbiAgICAgIHRvcDogJ24nLFxuICAgICAgYm90dG9tOiAncydcbiAgICB9O1xuICAgIHZhciBnbG9iYWxEaXIgPSBncmFwaGljLnRyYW5zZm9ybURpcmVjdGlvbihtYXBbbG9jYWxEaXJlY3Rpb25dLCBnZXRUcmFuc2Zvcm0oY29udHJvbGxlcikpO1xuICAgIHJldHVybiBpbnZlcnNlTWFwW2dsb2JhbERpcl07XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJpZnRSZWN0KHRvUmVjdFJhbmdlLCBmcm9tUmVjdFJhbmdlLCBjb250cm9sbGVyLCBjb3ZlciwgbmFtZSwgZHgsIGR5LCBlKSB7XG4gIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gIHZhciByZWN0UmFuZ2UgPSB0b1JlY3RSYW5nZShicnVzaE9wdGlvbi5yYW5nZSk7XG4gIHZhciBsb2NhbERlbHRhID0gdG9Mb2NhbERlbHRhKGNvbnRyb2xsZXIsIGR4LCBkeSk7XG4gIGVhY2gobmFtZS5zcGxpdCgnJyksIGZ1bmN0aW9uIChuYW1lUGFydCkge1xuICAgIHZhciBpbmQgPSBESVJFQ1RJT05fTUFQW25hbWVQYXJ0XTtcbiAgICByZWN0UmFuZ2VbaW5kWzBdXVtpbmRbMV1dICs9IGxvY2FsRGVsdGFbaW5kWzBdXTtcbiAgfSk7XG4gIGJydXNoT3B0aW9uLnJhbmdlID0gZnJvbVJlY3RSYW5nZShmb3JtYXRSZWN0UmFuZ2UocmVjdFJhbmdlWzBdWzBdLCByZWN0UmFuZ2VbMV1bMF0sIHJlY3RSYW5nZVswXVsxXSwgcmVjdFJhbmdlWzFdWzFdKSk7XG4gIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcik7XG4gIHRyaWdnZXIoY29udHJvbGxlciwge1xuICAgIGlzRW5kOiBmYWxzZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZHJpZnRQb2x5Z29uKGNvbnRyb2xsZXIsIGNvdmVyLCBkeCwgZHksIGUpIHtcbiAgdmFyIHJhbmdlID0gY292ZXIuX19icnVzaE9wdGlvbi5yYW5nZTtcbiAgdmFyIGxvY2FsRGVsdGEgPSB0b0xvY2FsRGVsdGEoY29udHJvbGxlciwgZHgsIGR5KTtcbiAgZWFjaChyYW5nZSwgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcG9pbnRbMF0gKz0gbG9jYWxEZWx0YVswXTtcbiAgICBwb2ludFsxXSArPSBsb2NhbERlbHRhWzFdO1xuICB9KTtcbiAgdXBkYXRlQ292ZXJBZnRlckNyZWF0aW9uKGNvbnRyb2xsZXIsIGNvdmVyKTtcbiAgdHJpZ2dlcihjb250cm9sbGVyLCB7XG4gICAgaXNFbmQ6IGZhbHNlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0b0xvY2FsRGVsdGEoY29udHJvbGxlciwgZHgsIGR5KSB7XG4gIHZhciB0aGlzR3JvdXAgPSBjb250cm9sbGVyLmdyb3VwO1xuICB2YXIgbG9jYWxEID0gdGhpc0dyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChkeCwgZHkpO1xuICB2YXIgbG9jYWxaZXJvID0gdGhpc0dyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCgwLCAwKTtcbiAgcmV0dXJuIFtsb2NhbERbMF0gLSBsb2NhbFplcm9bMF0sIGxvY2FsRFsxXSAtIGxvY2FsWmVyb1sxXV07XG59XG5cbmZ1bmN0aW9uIGNsaXBCeVBhbmVsKGNvbnRyb2xsZXIsIGNvdmVyLCBkYXRhKSB7XG4gIHZhciBwYW5lbCA9IGdldFBhbmVsQnlDb3Zlcihjb250cm9sbGVyLCBjb3Zlcik7XG4gIHJldHVybiBwYW5lbCAmJiBwYW5lbCAhPT0gdHJ1ZSA/IHBhbmVsLmNsaXBQYXRoKGRhdGEsIGNvbnRyb2xsZXIuX3RyYW5zZm9ybSkgOiB6clV0aWwuY2xvbmUoZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHBvaW50c1RvUmVjdChwb2ludHMpIHtcbiAgdmFyIHhtaW4gPSBtYXRoTWluKHBvaW50c1swXVswXSwgcG9pbnRzWzFdWzBdKTtcbiAgdmFyIHltaW4gPSBtYXRoTWluKHBvaW50c1swXVsxXSwgcG9pbnRzWzFdWzFdKTtcbiAgdmFyIHhtYXggPSBtYXRoTWF4KHBvaW50c1swXVswXSwgcG9pbnRzWzFdWzBdKTtcbiAgdmFyIHltYXggPSBtYXRoTWF4KHBvaW50c1swXVsxXSwgcG9pbnRzWzFdWzFdKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4bWluLFxuICAgIHk6IHltaW4sXG4gICAgd2lkdGg6IHhtYXggLSB4bWluLFxuICAgIGhlaWdodDogeW1heCAtIHltaW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJzb3IoY29udHJvbGxlciwgZSwgbG9jYWxDdXJzb3JQb2ludCkge1xuICAvLyBDaGVjayBhY3RpdmVcbiAgaWYgKCFjb250cm9sbGVyLl9icnVzaFR5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgenIgPSBjb250cm9sbGVyLl96cjtcbiAgdmFyIGNvdmVycyA9IGNvbnRyb2xsZXIuX2NvdmVycztcbiAgdmFyIGN1cnJQYW5lbCA9IGdldFBhbmVsQnlQb2ludChjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50KTsgLy8gQ2hlY2sgd2hldGhlciBpbiBjb3ZlcnMuXG5cbiAgaWYgKCFjb250cm9sbGVyLl9kcmFnZ2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnJ1c2hPcHRpb24gPSBjb3ZlcnNbaV0uX19icnVzaE9wdGlvbjtcblxuICAgICAgaWYgKGN1cnJQYW5lbCAmJiAoY3VyclBhbmVsID09PSB0cnVlIHx8IGJydXNoT3B0aW9uLnBhbmVsSWQgPT09IGN1cnJQYW5lbC5wYW5lbElkKSAmJiBjb3ZlclJlbmRlcmVyc1ticnVzaE9wdGlvbi5icnVzaFR5cGVdLmNvbnRhaW4oY292ZXJzW2ldLCBsb2NhbEN1cnNvclBvaW50WzBdLCBsb2NhbEN1cnNvclBvaW50WzFdKSkge1xuICAgICAgICAvLyBVc2UgY3Vyc29yIHN0eWxlIHNldCBvbiBjb3Zlci5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN1cnJQYW5lbCAmJiB6ci5zZXRDdXJzb3JTdHlsZSgnY3Jvc3NoYWlyJyk7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcbiAgdmFyIHJhd0UgPSBlLmV2ZW50O1xuICByYXdFLnByZXZlbnREZWZhdWx0ICYmIHJhd0UucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gbWFpblNoYXBlQ29udGFpbihjb3ZlciwgeCwgeSkge1xuICByZXR1cm4gY292ZXIuY2hpbGRPZk5hbWUoJ21haW4nKS5jb250YWluKHgsIHkpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb3ZlckJ5TW91c2UoY29udHJvbGxlciwgZSwgbG9jYWxDdXJzb3JQb2ludCwgaXNFbmQpIHtcbiAgdmFyIGNyZWF0aW5nQ292ZXIgPSBjb250cm9sbGVyLl9jcmVhdGluZ0NvdmVyO1xuICB2YXIgcGFuZWwgPSBjb250cm9sbGVyLl9jcmVhdGluZ1BhbmVsO1xuICB2YXIgdGhpc0JydXNoT3B0aW9uID0gY29udHJvbGxlci5fYnJ1c2hPcHRpb247XG4gIHZhciBldmVudFBhcmFtcztcblxuICBjb250cm9sbGVyLl90cmFjay5wdXNoKGxvY2FsQ3Vyc29yUG9pbnQuc2xpY2UoKSk7XG5cbiAgaWYgKHNob3VsZFNob3dDb3Zlcihjb250cm9sbGVyKSB8fCBjcmVhdGluZ0NvdmVyKSB7XG4gICAgaWYgKHBhbmVsICYmICFjcmVhdGluZ0NvdmVyKSB7XG4gICAgICB0aGlzQnJ1c2hPcHRpb24uYnJ1c2hNb2RlID09PSAnc2luZ2xlJyAmJiBjbGVhckNvdmVycyhjb250cm9sbGVyKTtcbiAgICAgIHZhciBicnVzaE9wdGlvbiA9IHpyVXRpbC5jbG9uZSh0aGlzQnJ1c2hPcHRpb24pO1xuICAgICAgYnJ1c2hPcHRpb24uYnJ1c2hUeXBlID0gZGV0ZXJtaW5lQnJ1c2hUeXBlKGJydXNoT3B0aW9uLmJydXNoVHlwZSwgcGFuZWwpO1xuICAgICAgYnJ1c2hPcHRpb24ucGFuZWxJZCA9IHBhbmVsID09PSB0cnVlID8gbnVsbCA6IHBhbmVsLnBhbmVsSWQ7XG4gICAgICBjcmVhdGluZ0NvdmVyID0gY29udHJvbGxlci5fY3JlYXRpbmdDb3ZlciA9IGNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKTtcblxuICAgICAgY29udHJvbGxlci5fY292ZXJzLnB1c2goY3JlYXRpbmdDb3Zlcik7XG4gICAgfVxuXG4gICAgaWYgKGNyZWF0aW5nQ292ZXIpIHtcbiAgICAgIHZhciBjb3ZlclJlbmRlcmVyID0gY292ZXJSZW5kZXJlcnNbZGV0ZXJtaW5lQnJ1c2hUeXBlKGNvbnRyb2xsZXIuX2JydXNoVHlwZSwgcGFuZWwpXTtcbiAgICAgIHZhciBjb3ZlckJydXNoT3B0aW9uID0gY3JlYXRpbmdDb3Zlci5fX2JydXNoT3B0aW9uO1xuICAgICAgY292ZXJCcnVzaE9wdGlvbi5yYW5nZSA9IGNvdmVyUmVuZGVyZXIuZ2V0Q3JlYXRpbmdSYW5nZShjbGlwQnlQYW5lbChjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyLCBjb250cm9sbGVyLl90cmFjaykpO1xuXG4gICAgICBpZiAoaXNFbmQpIHtcbiAgICAgICAgZW5kQ3JlYXRpbmcoY29udHJvbGxlciwgY3JlYXRpbmdDb3Zlcik7XG4gICAgICAgIGNvdmVyUmVuZGVyZXIudXBkYXRlQ29tbW9uKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgICAgZXZlbnRQYXJhbXMgPSB7XG4gICAgICAgIGlzRW5kOiBpc0VuZFxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbmQgJiYgdGhpc0JydXNoT3B0aW9uLmJydXNoTW9kZSA9PT0gJ3NpbmdsZScgJiYgdGhpc0JydXNoT3B0aW9uLnJlbW92ZU9uQ2xpY2spIHtcbiAgICAvLyBIZWxwIHVzZXIgdG8gcmVtb3ZlIGNvdmVycyBlYXNpbHksIG9ubHkgYnkgYSB0aW55IGRyYWcsIGluICdzaW5nbGUnIG1vZGUuXG4gICAgLy8gQnV0IGEgc2luZ2xlIGNsaWNrIGRvIG5vdCBjbGVhciBjb3ZlcnMsIGJlY2F1c2UgdXNlciBtYXkgaGF2ZSBjYXN1YWxcbiAgICAvLyBjbGlja3MgKGZvciBleGFtcGxlLCBjbGljayBvbiBvdGhlciBjb21wb25lbnQgYW5kIGRvIG5vdCBleHBlY3QgY292ZXJzXG4gICAgLy8gZGlzYXBwZWFyKS5cbiAgICAvLyBPbmx5IHNvbWUgY292ZXIgcmVtb3ZlZCwgdHJpZ2dlciBhY3Rpb24sIGJ1dCBub3QgZXZlcnkgY2xpY2sgdHJpZ2dlciBhY3Rpb24uXG4gICAgaWYgKGdldFBhbmVsQnlQb2ludChjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50KSAmJiBjbGVhckNvdmVycyhjb250cm9sbGVyKSkge1xuICAgICAgZXZlbnRQYXJhbXMgPSB7XG4gICAgICAgIGlzRW5kOiBpc0VuZCxcbiAgICAgICAgcmVtb3ZlT25DbGljazogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRQYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUJydXNoVHlwZShicnVzaFR5cGUsIHBhbmVsKSB7XG4gIGlmIChicnVzaFR5cGUgPT09ICdhdXRvJykge1xuICAgIHJldHVybiBwYW5lbC5kZWZhdWx0QnJ1c2hUeXBlO1xuICB9XG5cbiAgcmV0dXJuIGJydXNoVHlwZTtcbn1cblxudmFyIG1vdXNlSGFuZGxlcnMgPSB7XG4gIG1vdXNlZG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAodGhpcy5fZHJhZ2dpbmcpIHtcbiAgICAgIC8vIEluIGNhc2Ugc29tZSBicm93c2VyIGRvIG5vdCBzdXBwb3J0IGdsb2JhbE91dCxcbiAgICAgIC8vIGFuZCByZWxlYXNlIG1vc2Ugb3V0IHNpZGUgdGhlIGJyb3dzZXIuXG4gICAgICBoYW5kbGVEcmFnRW5kLmNhbGwodGhpcywgZSk7XG4gICAgfSBlbHNlIGlmICghZS50YXJnZXQgfHwgIWUudGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICB2YXIgbG9jYWxDdXJzb3JQb2ludCA9IHRoaXMuZ3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcbiAgICAgIHRoaXMuX2NyZWF0aW5nQ292ZXIgPSBudWxsO1xuICAgICAgdmFyIHBhbmVsID0gdGhpcy5fY3JlYXRpbmdQYW5lbCA9IGdldFBhbmVsQnlQb2ludCh0aGlzLCBlLCBsb2NhbEN1cnNvclBvaW50KTtcblxuICAgICAgaWYgKHBhbmVsKSB7XG4gICAgICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdHJhY2sgPSBbbG9jYWxDdXJzb3JQb2ludC5zbGljZSgpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbG9jYWxDdXJzb3JQb2ludCA9IHRoaXMuZ3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcbiAgICByZXNldEN1cnNvcih0aGlzLCBlLCBsb2NhbEN1cnNvclBvaW50KTtcblxuICAgIGlmICh0aGlzLl9kcmFnZ2luZykge1xuICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICB2YXIgZXZlbnRQYXJhbXMgPSB1cGRhdGVDb3ZlckJ5TW91c2UodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCwgZmFsc2UpO1xuICAgICAgZXZlbnRQYXJhbXMgJiYgdHJpZ2dlcih0aGlzLCBldmVudFBhcmFtcyk7XG4gICAgfVxuICB9LFxuICBtb3VzZXVwOiBoYW5kbGVEcmFnRW5kIC8vLFxuICAvLyBGSVhNRVxuICAvLyBpbiB0b29sdGlwLCBnbG9iYWxvdXQgc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQuXG4gIC8vIGdsb2JhbG91dDogaGFuZGxlRHJhZ0VuZFxuXG59O1xuXG5mdW5jdGlvbiBoYW5kbGVEcmFnRW5kKGUpIHtcbiAgaWYgKHRoaXMuX2RyYWdnaW5nKSB7XG4gICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgdmFyIGxvY2FsQ3Vyc29yUG9pbnQgPSB0aGlzLmdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgdmFyIGV2ZW50UGFyYW1zID0gdXBkYXRlQ292ZXJCeU1vdXNlKHRoaXMsIGUsIGxvY2FsQ3Vyc29yUG9pbnQsIHRydWUpO1xuICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fdHJhY2sgPSBbXTtcbiAgICB0aGlzLl9jcmVhdGluZ0NvdmVyID0gbnVsbDsgLy8gdHJpZ2dlciBldmVudCBzaG91bGUgYmUgYXQgZmluYWwsIGFmdGVyIHByb2NlZHVyZSB3aWxsIGJlIG5lc3RlZC5cblxuICAgIGV2ZW50UGFyYW1zICYmIHRyaWdnZXIodGhpcywgZXZlbnRQYXJhbXMpO1xuICB9XG59XG4vKipcbiAqIGtleTogYnJ1c2hUeXBlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cblxudmFyIGNvdmVyUmVuZGVyZXJzID0ge1xuICBsaW5lWDogZ2V0TGluZVJlbmRlcmVyKDApLFxuICBsaW5lWTogZ2V0TGluZVJlbmRlcmVyKDEpLFxuICByZWN0OiB7XG4gICAgY3JlYXRlQ292ZXI6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJhc2VSZWN0Q292ZXIoY3VycnkoZHJpZnRSZWN0LCBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgfSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgIH0pLCBjb250cm9sbGVyLCBicnVzaE9wdGlvbiwgWyd3JywgJ2UnLCAnbicsICdzJywgJ3NlJywgJ3N3JywgJ25lJywgJ253J10pO1xuICAgIH0sXG4gICAgZ2V0Q3JlYXRpbmdSYW5nZTogZnVuY3Rpb24gKGxvY2FsVHJhY2spIHtcbiAgICAgIHZhciBlbmRzID0gZ2V0VHJhY2tFbmRzKGxvY2FsVHJhY2spO1xuICAgICAgcmV0dXJuIGZvcm1hdFJlY3RSYW5nZShlbmRzWzFdWzBdLCBlbmRzWzFdWzFdLCBlbmRzWzBdWzBdLCBlbmRzWzBdWzFdKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvdmVyU2hhcGU6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgICAgIHVwZGF0ZUJhc2VSZWN0KGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlLCBicnVzaE9wdGlvbik7XG4gICAgfSxcbiAgICB1cGRhdGVDb21tb246IHVwZGF0ZUNvbW1vbixcbiAgICBjb250YWluOiBtYWluU2hhcGVDb250YWluXG4gIH0sXG4gIHBvbHlnb246IHtcbiAgICBjcmVhdGVDb3ZlcjogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKSB7XG4gICAgICB2YXIgY292ZXIgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpOyAvLyBEbyBub3QgdXNlIGdyYXBoaWMuUG9seWdvbiBiZWNhdXNlIGdyYXBoaWMuUG9seWxpbmUgZG8gbm90IGNsb3NlIHRoZVxuICAgICAgLy8gYm9yZGVyIG9mIHRoZSBzaGFwZSB3aGVuIGRyYXdpbmcsIHdoaWNoIGlzIGEgYmV0dGVyIGV4cGVyaWVuY2UgZm9yIHVzZXIuXG5cbiAgICAgIGNvdmVyLmFkZChuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XG4gICAgICAgIG5hbWU6ICdtYWluJyxcbiAgICAgICAgc3R5bGU6IG1ha2VTdHlsZShicnVzaE9wdGlvbiksXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGNvdmVyO1xuICAgIH0sXG4gICAgZ2V0Q3JlYXRpbmdSYW5nZTogZnVuY3Rpb24gKGxvY2FsVHJhY2spIHtcbiAgICAgIHJldHVybiBsb2NhbFRyYWNrO1xuICAgIH0sXG4gICAgZW5kQ3JlYXRpbmc6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBjb3Zlcikge1xuICAgICAgY292ZXIucmVtb3ZlKGNvdmVyLmNoaWxkQXQoMCkpOyAvLyBVc2UgZ3JhcGhpYy5Qb2x5Z29uIGNsb3NlIHRoZSBzaGFwZS5cblxuICAgICAgY292ZXIuYWRkKG5ldyBncmFwaGljLlBvbHlnb24oe1xuICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgZHJpZnQ6IGN1cnJ5KGRyaWZ0UG9seWdvbiwgY29udHJvbGxlciwgY292ZXIpLFxuICAgICAgICBvbmRyYWdlbmQ6IGN1cnJ5KHRyaWdnZXIsIGNvbnRyb2xsZXIsIHtcbiAgICAgICAgICBpc0VuZDogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgdXBkYXRlQ292ZXJTaGFwZTogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlLCBicnVzaE9wdGlvbikge1xuICAgICAgY292ZXIuY2hpbGRBdCgwKS5zZXRTaGFwZSh7XG4gICAgICAgIHBvaW50czogY2xpcEJ5UGFuZWwoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UpXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbW1vbjogdXBkYXRlQ29tbW9uLFxuICAgIGNvbnRhaW46IG1haW5TaGFwZUNvbnRhaW5cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0TGluZVJlbmRlcmVyKHh5SW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb3ZlcjogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQmFzZVJlY3RDb3ZlcihjdXJyeShkcmlmdFJlY3QsIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgcmVjdFJhbmdlID0gW3JhbmdlLCBbMCwgMTAwXV07XG4gICAgICAgIHh5SW5kZXggJiYgcmVjdFJhbmdlLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlY3RSYW5nZTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWN0UmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJlY3RSYW5nZVt4eUluZGV4XTtcbiAgICAgIH0pLCBjb250cm9sbGVyLCBicnVzaE9wdGlvbiwgW1sndycsICdlJ10sIFsnbicsICdzJ11dW3h5SW5kZXhdKTtcbiAgICB9LFxuICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICB2YXIgZW5kcyA9IGdldFRyYWNrRW5kcyhsb2NhbFRyYWNrKTtcbiAgICAgIHZhciBtaW4gPSBtYXRoTWluKGVuZHNbMF1beHlJbmRleF0sIGVuZHNbMV1beHlJbmRleF0pO1xuICAgICAgdmFyIG1heCA9IG1hdGhNYXgoZW5kc1swXVt4eUluZGV4XSwgZW5kc1sxXVt4eUluZGV4XSk7XG4gICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvdmVyU2hhcGU6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgICAgIHZhciBvdGhlckV4dGVudDsgLy8gSWYgYnJ1c2hXaWR0aCBub3Qgc3BlY2lmaWVkLCBmaXQgdGhlIHBhbmVsLlxuXG4gICAgICB2YXIgcGFuZWwgPSBnZXRQYW5lbEJ5Q292ZXIoY29udHJvbGxlciwgY292ZXIpO1xuXG4gICAgICBpZiAocGFuZWwgIT09IHRydWUgJiYgcGFuZWwuZ2V0TGluZWFyQnJ1c2hPdGhlckV4dGVudCkge1xuICAgICAgICBvdGhlckV4dGVudCA9IHBhbmVsLmdldExpbmVhckJydXNoT3RoZXJFeHRlbnQoeHlJbmRleCwgY29udHJvbGxlci5fdHJhbnNmb3JtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB6ciA9IGNvbnRyb2xsZXIuX3pyO1xuICAgICAgICBvdGhlckV4dGVudCA9IFswLCBbenIuZ2V0V2lkdGgoKSwgenIuZ2V0SGVpZ2h0KCldWzEgLSB4eUluZGV4XV07XG4gICAgICB9XG5cbiAgICAgIHZhciByZWN0UmFuZ2UgPSBbbG9jYWxSYW5nZSwgb3RoZXJFeHRlbnRdO1xuICAgICAgeHlJbmRleCAmJiByZWN0UmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgdXBkYXRlQmFzZVJlY3QoY29udHJvbGxlciwgY292ZXIsIHJlY3RSYW5nZSwgYnJ1c2hPcHRpb24pO1xuICAgIH0sXG4gICAgdXBkYXRlQ29tbW9uOiB1cGRhdGVDb21tb24sXG4gICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICB9O1xufVxuXG52YXIgX2RlZmF1bHQgPSBCcnVzaENvbnRyb2xsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBicnVzaEhlbHBlciA9IHJlcXVpcmUoXCIuL2JydXNoSGVscGVyXCIpO1xuXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcbnZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbnZhciBDT09SRF9DT05WRVJUUyA9IFsnZGF0YVRvUG9pbnQnLCAncG9pbnRUb0RhdGEnXTsgLy8gRklYTUVcbi8vIGhvdyB0byBnZW5hcmlhbGl6ZSB0byBtb3JlIGNvb3JkaW5hdGUgc3lzdGVtcy5cblxudmFyIElOQ0xVREVfRklOREVSX01BSU5fVFlQRVMgPSBbJ2dyaWQnLCAneEF4aXMnLCAneUF4aXMnLCAnZ2VvJywgJ2dyYXBoJywgJ3BvbGFyJywgJ3JhZGl1c0F4aXMnLCAnYW5nbGVBeGlzJywgJ2JtYXAnXTtcbi8qKlxuICogW29wdGlvbiBpbiBjb25zdHJ1Y3Rvcl06XG4gKiB7XG4gKiAgICAgSW5kZXgvSWQvTmFtZSBvZiBnZW8sIHhBeGlzLCB5QXhpcywgZ3JpZDogU2VlIHV0aWwvbW9kZWwjcGFyc2VGaW5kZXIuXG4gKiB9XG4gKlxuICpcbiAqIFt0YXJnZXRJbmZvXTpcbiAqXG4gKiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgYXhlcyBpbiBhIHNpbmdsZSB0YXJnZXRJbmZvLiBDb25zaWRlciB0aGUgY2FzZVxuICogb2YgYGdyaWRgIGNvbXBvbmVudCwgYSB0YXJnZXRJbmZvIHJlcHJlc2VudHMgYSBncmlkIHdoaWNoIGNvbnRhaW5zIG9uZSBvciBtb3JlXG4gKiBjYXJ0ZXNpYW4gYW5kIG9uZSBvciBtb3JlIGF4ZXMuIEFuZCBjb25zaWRlciB0aGUgY2FzZSBvZiBwYXJhbGxlbCBzeXN0ZW0sXG4gKiB3aGljaCBoYXMgbXVsdGlwbGUgYXhlcyBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtLlxuICogQ2FuIGJlIHtcbiAqICAgICBwYW5lbElkOiAuLi4sXG4gKiAgICAgY29vcmRTeXM6IDxhIHJlcHJlc2VudGl0aXZlIGNhcnRlc2lhbiBpbiBncmlkIChmaXJzdCBjYXJ0ZXNpYW4gYnkgZGVmYXVsdCk+LFxuICogICAgIGNvb3JkU3lzZXM6IGFsbCBjYXJ0ZXNpYW5zLlxuICogICAgIGdyaWRNb2RlbDogPGdyaWQgY29tcG9uZW50PlxuICogICAgIHhBeGVzOiBjb3JyZXNwb25kIHRvIGNvb3JkU3lzZXMgb24gaW5kZXhcbiAqICAgICB5QXhlczogY29ycmVzcG9uZCB0byBjb29yZFN5c2VzIG9uIGluZGV4XG4gKiB9XG4gKiBvciB7XG4gKiAgICAgcGFuZWxJZDogLi4uLFxuICogICAgIGNvb3JkU3lzOiA8Z2VvIGNvb3JkIHN5cz5cbiAqICAgICBjb29yZFN5c2VzOiBbPGdlbyBjb29yZCBzeXM+XVxuICogICAgIGdlb01vZGVsOiA8Z2VvIGNvbXBvbmVudD5cbiAqIH1cbiAqXG4gKlxuICogW3BhbmVsT3B0XTpcbiAqXG4gKiBNYWtlIGZyb20gdGFyZ2V0SW5mby4gSW5wdXQgdG8gQnJ1c2hDb250cm9sbGVyLlxuICoge1xuICogICAgIHBhbmVsSWQ6IC4uLixcbiAqICAgICByZWN0OiAuLi5cbiAqIH1cbiAqXG4gKlxuICogW2FyZWFdOlxuICpcbiAqIEdlbmVyYXRlZCBieSBCcnVzaENvbnRyb2xsZXIgb3IgdXNlciBpbnB1dC5cbiAqIHtcbiAqICAgICBwYW5lbElkOiBVc2VkIHRvIGxvY2F0ZSBjb29yZEluZm8gZGlyZWN0bHkuIElmIHVzZXIgaW5wcHV0LCBubyBwYW5lbElkLlxuICogICAgIGJydXNoVHlwZTogZGV0ZXJtaW5lIGhvdyB0byBjb252ZXJ0IHRvL2Zyb20gY29vcmQoJ3JlY3QnIG9yICdwb2x5Z29uJyBvciAnbGluZVgvWScpLlxuICogICAgIEluZGV4L0lkL05hbWUgb2YgZ2VvLCB4QXhpcywgeUF4aXMsIGdyaWQ6IFNlZSB1dGlsL21vZGVsI3BhcnNlRmluZGVyLlxuICogICAgIHJhbmdlOiBwaXhlbCByYW5nZS5cbiAqICAgICBjb29yZFJhbmdlOiByZXByZXNlbnRpdGl2ZSBjb29yZCByYW5nZSAodGhlIGZpcnN0IG9uZSBvZiBjb29yZFJhbmdlcykuXG4gKiAgICAgY29vcmRSYW5nZXM6IDxBcnJheT4gY29vcmQgcmFuZ2VzLCB1c2VkIGluIG11bHRpcGxlIGNhcnRlc2lhbiBpbiBvbmUgZ3JpZC5cbiAqIH1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24gY29udGFpbnMgSW5kZXgvSWQvTmFtZSBvZiB4QXhpcy95QXhpcy9nZW8vZ3JpZFxuICogICAgICAgIEVhY2ggY2FuIGJlIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59LiBsaWtlOiB7eEF4aXNJbmRleDogWzMsIDRdfVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW29wdC5pbmNsdWRlXSBpbmNsdWRlIGNvb3JkaW5hdGUgc3lzdGVtIHR5cGVzLlxuICovXG5cbmZ1bmN0aW9uIEJydXNoVGFyZ2V0TWFuYWdlcihvcHRpb24sIGVjTW9kZWwsIG9wdCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgKi9cbiAgdmFyIHRhcmdldEluZm9MaXN0ID0gdGhpcy5fdGFyZ2V0SW5mb0xpc3QgPSBbXTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgdmFyIGZvdW5kQ3B0cyA9IHBhcnNlRmluZGVyKGVjTW9kZWwsIG9wdGlvbik7XG4gIGVhY2godGFyZ2V0SW5mb0J1aWxkZXJzLCBmdW5jdGlvbiAoYnVpbGRlciwgdHlwZSkge1xuICAgIGlmICghb3B0IHx8ICFvcHQuaW5jbHVkZSB8fCBpbmRleE9mKG9wdC5pbmNsdWRlLCB0eXBlKSA+PSAwKSB7XG4gICAgICBidWlsZGVyKGZvdW5kQ3B0cywgdGFyZ2V0SW5mb0xpc3QsIGluZm8pO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBwcm90byA9IEJydXNoVGFyZ2V0TWFuYWdlci5wcm90b3R5cGU7XG5cbnByb3RvLnNldE91dHB1dFJhbmdlcyA9IGZ1bmN0aW9uIChhcmVhcywgZWNNb2RlbCkge1xuICB0aGlzLm1hdGNoT3V0cHV0UmFuZ2VzKGFyZWFzLCBlY01vZGVsLCBmdW5jdGlvbiAoYXJlYSwgY29vcmRSYW5nZSwgY29vcmRTeXMpIHtcbiAgICAoYXJlYS5jb29yZFJhbmdlcyB8fCAoYXJlYS5jb29yZFJhbmdlcyA9IFtdKSkucHVzaChjb29yZFJhbmdlKTsgLy8gYXJlYS5jb29yZFJhbmdlIGlzIHRoZSBmaXJzdCBvZiBhcmVhLmNvb3JkUmFuZ2VzXG5cbiAgICBpZiAoIWFyZWEuY29vcmRSYW5nZSkge1xuICAgICAgYXJlYS5jb29yZFJhbmdlID0gY29vcmRSYW5nZTsgLy8gSW4gJ2NhdGVnb3J5JyBheGlzLCBjb29yZCB0byBwaXhlbCBpcyBub3QgcmV2ZXJzaWJsZSwgc28gd2UgY2FuIG5vdFxuICAgICAgLy8gcmVidWlsZCByYW5nZSBieSBjb29yZFJhbmdlIGFjY3JhdGVseSwgd2hpY2ggbWF5IGJyaW5nIHRyb3VibGUgd2hlblxuICAgICAgLy8gYnJ1c2hpbmcgb25seSBvbmUgaXRlbS4gU28gd2UgdXNlIF9fcmFuZ2VPZmZzZXQgdG8gcmVidWlsZGluZyByYW5nZVxuICAgICAgLy8gYnkgY29vcmRSYW5nZS4gQW5kIHRoaXMgaXQgb25seSB1c2VkIGluIGJydXNoIGNvbXBvbmVudCBzbyBpdCBpcyBub1xuICAgICAgLy8gbmVlZCB0byBiZSBhZGFwdGVkIHRvIGNvb3JkUmFuZ2VzLlxuXG4gICAgICB2YXIgcmVzdWx0ID0gY29vcmRDb252ZXJ0W2FyZWEuYnJ1c2hUeXBlXSgwLCBjb29yZFN5cywgY29vcmRSYW5nZSk7XG4gICAgICBhcmVhLl9fcmFuZ2VPZmZzZXQgPSB7XG4gICAgICAgIG9mZnNldDogZGlmZlByb2Nlc3NvclthcmVhLmJydXNoVHlwZV0ocmVzdWx0LnZhbHVlcywgYXJlYS5yYW5nZSwgWzEsIDFdKSxcbiAgICAgICAgeHlNaW5NYXg6IHJlc3VsdC54eU1pbk1heFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufTtcblxucHJvdG8ubWF0Y2hPdXRwdXRSYW5nZXMgPSBmdW5jdGlvbiAoYXJlYXMsIGVjTW9kZWwsIGNiKSB7XG4gIGVhY2goYXJlYXMsIGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuXG4gICAgaWYgKHRhcmdldEluZm8gJiYgdGFyZ2V0SW5mbyAhPT0gdHJ1ZSkge1xuICAgICAgenJVdGlsLmVhY2godGFyZ2V0SW5mby5jb29yZFN5c2VzLCBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvb3JkQ29udmVydFthcmVhLmJydXNoVHlwZV0oMSwgY29vcmRTeXMsIGFyZWEucmFuZ2UpO1xuICAgICAgICBjYihhcmVhLCByZXN1bHQudmFsdWVzLCBjb29yZFN5cywgZWNNb2RlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHRoaXMpO1xufTtcblxucHJvdG8uc2V0SW5wdXRSYW5nZXMgPSBmdW5jdGlvbiAoYXJlYXMsIGVjTW9kZWwpIHtcbiAgZWFjaChhcmVhcywgZnVuY3Rpb24gKGFyZWEpIHtcbiAgICB2YXIgdGFyZ2V0SW5mbyA9IHRoaXMuZmluZFRhcmdldEluZm8oYXJlYSwgZWNNb2RlbCk7XG4gICAgYXJlYS5yYW5nZSA9IGFyZWEucmFuZ2UgfHwgW107IC8vIGNvbnZlcnQgY29vcmRSYW5nZSB0byBnbG9iYWwgcmFuZ2UgYW5kIHNldCBwYW5lbElkLlxuXG4gICAgaWYgKHRhcmdldEluZm8gJiYgdGFyZ2V0SW5mbyAhPT0gdHJ1ZSkge1xuICAgICAgYXJlYS5wYW5lbElkID0gdGFyZ2V0SW5mby5wYW5lbElkOyAvLyAoMSkgYXJlYS5yYW5nZSBzaG91bGUgYWx3YXlzIGJlIGNhbGN1bGF0ZSBmcm9tIGNvb3JkUmFuZ2UgYnV0IGRvZXNcbiAgICAgIC8vIG5vdCBrZWVwIGl0cyBvcmlnaW5hbCB2YWx1ZSwgZm9yIHRoZSBzYWtlIG9mIHRoZSBkYXRhWm9vbSBzY2VuYXJpbyxcbiAgICAgIC8vIHdoZXJlIGFyZWEuY29vcmRSYW5nZSByZW1haW5zIHVuY2hhbmdlZCBidXQgYXJlYS5yYW5nZSBtYXkgYmUgY2hhbmdlZC5cbiAgICAgIC8vICgyKSBPbmx5IHN1cHBvcnQgY29udmVydGluZyBvbmUgY29vcmRSYW5nZSB0byBwaXhlbCByYW5nZSBpbiBicnVzaFxuICAgICAgLy8gY29tcG9uZW50LiBTbyBkbyBub3QgY29uc2lkZXIgYGNvb3JkUmFuZ2VzYC5cbiAgICAgIC8vICgzKSBBYm91dCBfX3JhbmdlT2Zmc2V0LCBzZWUgY29tbWVudCBhYm92ZS5cblxuICAgICAgdmFyIHJlc3VsdCA9IGNvb3JkQ29udmVydFthcmVhLmJydXNoVHlwZV0oMCwgdGFyZ2V0SW5mby5jb29yZFN5cywgYXJlYS5jb29yZFJhbmdlKTtcbiAgICAgIHZhciByYW5nZU9mZnNldCA9IGFyZWEuX19yYW5nZU9mZnNldDtcbiAgICAgIGFyZWEucmFuZ2UgPSByYW5nZU9mZnNldCA/IGRpZmZQcm9jZXNzb3JbYXJlYS5icnVzaFR5cGVdKHJlc3VsdC52YWx1ZXMsIHJhbmdlT2Zmc2V0Lm9mZnNldCwgZ2V0U2NhbGVzKHJlc3VsdC54eU1pbk1heCwgcmFuZ2VPZmZzZXQueHlNaW5NYXgpKSA6IHJlc3VsdC52YWx1ZXM7XG4gICAgfVxuICB9LCB0aGlzKTtcbn07XG5cbnByb3RvLm1ha2VQYW5lbE9wdHMgPSBmdW5jdGlvbiAoYXBpLCBnZXREZWZhdWx0QnJ1c2hUeXBlKSB7XG4gIHJldHVybiB6clV0aWwubWFwKHRoaXMuX3RhcmdldEluZm9MaXN0LCBmdW5jdGlvbiAodGFyZ2V0SW5mbykge1xuICAgIHZhciByZWN0ID0gdGFyZ2V0SW5mby5nZXRQYW5lbFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFuZWxJZDogdGFyZ2V0SW5mby5wYW5lbElkLFxuICAgICAgZGVmYXVsdEJydXNoVHlwZTogZ2V0RGVmYXVsdEJydXNoVHlwZSAmJiBnZXREZWZhdWx0QnJ1c2hUeXBlKHRhcmdldEluZm8pLFxuICAgICAgY2xpcFBhdGg6IGJydXNoSGVscGVyLm1ha2VSZWN0UGFuZWxDbGlwUGF0aChyZWN0KSxcbiAgICAgIGlzVGFyZ2V0QnlDdXJzb3I6IGJydXNoSGVscGVyLm1ha2VSZWN0SXNUYXJnZXRCeUN1cnNvcihyZWN0LCBhcGksIHRhcmdldEluZm8uY29vcmRTeXNNb2RlbCksXG4gICAgICBnZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50OiBicnVzaEhlbHBlci5tYWtlTGluZWFyQnJ1c2hPdGhlckV4dGVudChyZWN0KVxuICAgIH07XG4gIH0pO1xufTtcblxucHJvdG8uY29udHJvbFNlcmllcyA9IGZ1bmN0aW9uIChhcmVhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAvLyBDaGVjayB3aGV0aGVyIGFyZWEgaXMgYm91bmQgaW4gY29vcmQsIGFuZCBzZXJpZXMgZG8gbm90IGJlbG9uZyB0byB0aGF0IGNvb3JkLlxuICAvLyBJZiBkbyBub3QgZG8gdGhpcyBjaGVjaywgc29tZSBicnVzaCAobGlrZSBsaW5lWCkgd2lsbCBjb250cm9sbCBhbGwgYXhlcy5cbiAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuICByZXR1cm4gdGFyZ2V0SW5mbyA9PT0gdHJ1ZSB8fCB0YXJnZXRJbmZvICYmIGluZGV4T2YodGFyZ2V0SW5mby5jb29yZFN5c2VzLCBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtKSA+PSAwO1xufTtcbi8qKlxuICogSWYgcmV0dXJuIE9iamVjdCwgYSBjb29yZCBmb3VuZC5cbiAqIElmIHJldXRybiB0cnVlLCBnbG9iYWwgZm91bmQuXG4gKiBPdGhlcndpc2Ugbm90aGluZyBmb3VuZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJlYVxuICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SW5mb0xpc3RcbiAqIEByZXR1cm4ge09iamVjdHxib29sZWFufVxuICovXG5cblxucHJvdG8uZmluZFRhcmdldEluZm8gPSBmdW5jdGlvbiAoYXJlYSwgZWNNb2RlbCkge1xuICB2YXIgdGFyZ2V0SW5mb0xpc3QgPSB0aGlzLl90YXJnZXRJbmZvTGlzdDtcbiAgdmFyIGZvdW5kQ3B0cyA9IHBhcnNlRmluZGVyKGVjTW9kZWwsIGFyZWEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0SW5mb0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGFyZ2V0SW5mbyA9IHRhcmdldEluZm9MaXN0W2ldO1xuICAgIHZhciBhcmVhUGFuZWxJZCA9IGFyZWEucGFuZWxJZDtcblxuICAgIGlmIChhcmVhUGFuZWxJZCkge1xuICAgICAgaWYgKHRhcmdldEluZm8ucGFuZWxJZCA9PT0gYXJlYVBhbmVsSWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEluZm87XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0SW5mb01hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0YXJnZXRJbmZvTWF0Y2hlcnNbaV0oZm91bmRDcHRzLCB0YXJnZXRJbmZvKSkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRNaW5NYXgobWluTWF4KSB7XG4gIG1pbk1heFswXSA+IG1pbk1heFsxXSAmJiBtaW5NYXgucmV2ZXJzZSgpO1xuICByZXR1cm4gbWluTWF4O1xufVxuXG5mdW5jdGlvbiBwYXJzZUZpbmRlcihlY01vZGVsLCBvcHRpb24pIHtcbiAgcmV0dXJuIG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBvcHRpb24sIHtcbiAgICBpbmNsdWRlTWFpblR5cGVzOiBJTkNMVURFX0ZJTkRFUl9NQUlOX1RZUEVTXG4gIH0pO1xufVxuXG52YXIgdGFyZ2V0SW5mb0J1aWxkZXJzID0ge1xuICBncmlkOiBmdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvTGlzdCkge1xuICAgIHZhciB4QXhpc01vZGVscyA9IGZvdW5kQ3B0cy54QXhpc01vZGVscztcbiAgICB2YXIgeUF4aXNNb2RlbHMgPSBmb3VuZENwdHMueUF4aXNNb2RlbHM7XG4gICAgdmFyIGdyaWRNb2RlbHMgPSBmb3VuZENwdHMuZ3JpZE1vZGVsczsgLy8gUmVtb3ZlIGR1cGxpY2F0ZWQuXG5cbiAgICB2YXIgZ3JpZE1vZGVsTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgeEF4ZXNIYXMgPSB7fTtcbiAgICB2YXIgeUF4ZXNIYXMgPSB7fTtcblxuICAgIGlmICgheEF4aXNNb2RlbHMgJiYgIXlBeGlzTW9kZWxzICYmICFncmlkTW9kZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaCh4QXhpc01vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgdmFyIGdyaWRNb2RlbCA9IGF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWw7XG4gICAgICBncmlkTW9kZWxNYXAuc2V0KGdyaWRNb2RlbC5pZCwgZ3JpZE1vZGVsKTtcbiAgICAgIHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIGVhY2goeUF4aXNNb2RlbHMsIGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsO1xuICAgICAgZ3JpZE1vZGVsTWFwLnNldChncmlkTW9kZWwuaWQsIGdyaWRNb2RlbCk7XG4gICAgICB5QXhlc0hhc1tncmlkTW9kZWwuaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBlYWNoKGdyaWRNb2RlbHMsIGZ1bmN0aW9uIChncmlkTW9kZWwpIHtcbiAgICAgIGdyaWRNb2RlbE1hcC5zZXQoZ3JpZE1vZGVsLmlkLCBncmlkTW9kZWwpO1xuICAgICAgeEF4ZXNIYXNbZ3JpZE1vZGVsLmlkXSA9IHRydWU7XG4gICAgICB5QXhlc0hhc1tncmlkTW9kZWwuaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBncmlkTW9kZWxNYXAuZWFjaChmdW5jdGlvbiAoZ3JpZE1vZGVsKSB7XG4gICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIGNhcnRlc2lhbnMgPSBbXTtcbiAgICAgIGVhY2goZ3JpZC5nZXRDYXJ0ZXNpYW5zKCksIGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleE9mKHhBeGlzTW9kZWxzLCBjYXJ0ZXNpYW4uZ2V0QXhpcygneCcpLm1vZGVsKSA+PSAwIHx8IGluZGV4T2YoeUF4aXNNb2RlbHMsIGNhcnRlc2lhbi5nZXRBeGlzKCd5JykubW9kZWwpID49IDApIHtcbiAgICAgICAgICBjYXJ0ZXNpYW5zLnB1c2goY2FydGVzaWFuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0YXJnZXRJbmZvTGlzdC5wdXNoKHtcbiAgICAgICAgcGFuZWxJZDogJ2dyaWQtLScgKyBncmlkTW9kZWwuaWQsXG4gICAgICAgIGdyaWRNb2RlbDogZ3JpZE1vZGVsLFxuICAgICAgICBjb29yZFN5c01vZGVsOiBncmlkTW9kZWwsXG4gICAgICAgIC8vIFVzZSB0aGUgZmlyc3Qgb25lIGFzIHRoZSByZXByZXNlbnRpdGl2ZSBjb29yZFN5cy5cbiAgICAgICAgY29vcmRTeXM6IGNhcnRlc2lhbnNbMF0sXG4gICAgICAgIGNvb3JkU3lzZXM6IGNhcnRlc2lhbnMsXG4gICAgICAgIGdldFBhbmVsUmVjdDogcGFuZWxSZWN0QnVpbGRlci5ncmlkLFxuICAgICAgICB4QXhpc0RlY2xhcmVkOiB4QXhlc0hhc1tncmlkTW9kZWwuaWRdLFxuICAgICAgICB5QXhpc0RlY2xhcmVkOiB5QXhlc0hhc1tncmlkTW9kZWwuaWRdXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZ2VvOiBmdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvTGlzdCkge1xuICAgIGVhY2goZm91bmRDcHRzLmdlb01vZGVscywgZnVuY3Rpb24gKGdlb01vZGVsKSB7XG4gICAgICB2YXIgY29vcmRTeXMgPSBnZW9Nb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdGFyZ2V0SW5mb0xpc3QucHVzaCh7XG4gICAgICAgIHBhbmVsSWQ6ICdnZW8tLScgKyBnZW9Nb2RlbC5pZCxcbiAgICAgICAgZ2VvTW9kZWw6IGdlb01vZGVsLFxuICAgICAgICBjb29yZFN5c01vZGVsOiBnZW9Nb2RlbCxcbiAgICAgICAgY29vcmRTeXM6IGNvb3JkU3lzLFxuICAgICAgICBjb29yZFN5c2VzOiBbY29vcmRTeXNdLFxuICAgICAgICBnZXRQYW5lbFJlY3Q6IHBhbmVsUmVjdEJ1aWxkZXIuZ2VvXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciB0YXJnZXRJbmZvTWF0Y2hlcnMgPSBbLy8gZ3JpZFxuZnVuY3Rpb24gKGZvdW5kQ3B0cywgdGFyZ2V0SW5mbykge1xuICB2YXIgeEF4aXNNb2RlbCA9IGZvdW5kQ3B0cy54QXhpc01vZGVsO1xuICB2YXIgeUF4aXNNb2RlbCA9IGZvdW5kQ3B0cy55QXhpc01vZGVsO1xuICB2YXIgZ3JpZE1vZGVsID0gZm91bmRDcHRzLmdyaWRNb2RlbDtcbiAgIWdyaWRNb2RlbCAmJiB4QXhpc01vZGVsICYmIChncmlkTW9kZWwgPSB4QXhpc01vZGVsLmF4aXMuZ3JpZC5tb2RlbCk7XG4gICFncmlkTW9kZWwgJiYgeUF4aXNNb2RlbCAmJiAoZ3JpZE1vZGVsID0geUF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWwpO1xuICByZXR1cm4gZ3JpZE1vZGVsICYmIGdyaWRNb2RlbCA9PT0gdGFyZ2V0SW5mby5ncmlkTW9kZWw7XG59LCAvLyBnZW9cbmZ1bmN0aW9uIChmb3VuZENwdHMsIHRhcmdldEluZm8pIHtcbiAgdmFyIGdlb01vZGVsID0gZm91bmRDcHRzLmdlb01vZGVsO1xuICByZXR1cm4gZ2VvTW9kZWwgJiYgZ2VvTW9kZWwgPT09IHRhcmdldEluZm8uZ2VvTW9kZWw7XG59XTtcbnZhciBwYW5lbFJlY3RCdWlsZGVyID0ge1xuICBncmlkOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZ3JpZCBpcyBub3QgVHJhbnNmb3JtYWJsZS5cbiAgICByZXR1cm4gdGhpcy5jb29yZFN5cy5ncmlkLmdldFJlY3QoKS5jbG9uZSgpO1xuICB9LFxuICBnZW86IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkU3lzO1xuICAgIHZhciByZWN0ID0gY29vcmRTeXMuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTsgLy8gZ2VvIHJvYW0gYW5kIHpvb20gdHJhbnNmb3JtXG5cbiAgICByZWN0LmFwcGx5VHJhbnNmb3JtKGdyYXBoaWMuZ2V0VHJhbnNmb3JtKGNvb3JkU3lzKSk7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbn07XG52YXIgY29vcmRDb252ZXJ0ID0ge1xuICBsaW5lWDogY3VycnkoYXhpc0NvbnZlcnQsIDApLFxuICBsaW5lWTogY3VycnkoYXhpc0NvbnZlcnQsIDEpLFxuICByZWN0OiBmdW5jdGlvbiAodG8sIGNvb3JkU3lzLCByYW5nZU9yQ29vcmRSYW5nZSkge1xuICAgIHZhciB4bWlueW1pbiA9IGNvb3JkU3lzW0NPT1JEX0NPTlZFUlRTW3RvXV0oW3JhbmdlT3JDb29yZFJhbmdlWzBdWzBdLCByYW5nZU9yQ29vcmRSYW5nZVsxXVswXV0pO1xuICAgIHZhciB4bWF4eW1heCA9IGNvb3JkU3lzW0NPT1JEX0NPTlZFUlRTW3RvXV0oW3JhbmdlT3JDb29yZFJhbmdlWzBdWzFdLCByYW5nZU9yQ29vcmRSYW5nZVsxXVsxXV0pO1xuICAgIHZhciB2YWx1ZXMgPSBbZm9ybWF0TWluTWF4KFt4bWlueW1pblswXSwgeG1heHltYXhbMF1dKSwgZm9ybWF0TWluTWF4KFt4bWlueW1pblsxXSwgeG1heHltYXhbMV1dKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgeHlNaW5NYXg6IHZhbHVlc1xuICAgIH07XG4gIH0sXG4gIHBvbHlnb246IGZ1bmN0aW9uICh0bywgY29vcmRTeXMsIHJhbmdlT3JDb29yZFJhbmdlKSB7XG4gICAgdmFyIHh5TWluTWF4ID0gW1tJbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCAtSW5maW5pdHldXTtcbiAgICB2YXIgdmFsdWVzID0genJVdGlsLm1hcChyYW5nZU9yQ29vcmRSYW5nZSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBwID0gY29vcmRTeXNbQ09PUkRfQ09OVkVSVFNbdG9dXShpdGVtKTtcbiAgICAgIHh5TWluTWF4WzBdWzBdID0gTWF0aC5taW4oeHlNaW5NYXhbMF1bMF0sIHBbMF0pO1xuICAgICAgeHlNaW5NYXhbMV1bMF0gPSBNYXRoLm1pbih4eU1pbk1heFsxXVswXSwgcFsxXSk7XG4gICAgICB4eU1pbk1heFswXVsxXSA9IE1hdGgubWF4KHh5TWluTWF4WzBdWzFdLCBwWzBdKTtcbiAgICAgIHh5TWluTWF4WzFdWzFdID0gTWF0aC5tYXgoeHlNaW5NYXhbMV1bMV0sIHBbMV0pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgeHlNaW5NYXg6IHh5TWluTWF4XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXhpc0NvbnZlcnQoYXhpc05hbWVJbmRleCwgdG8sIGNvb3JkU3lzLCByYW5nZU9yQ29vcmRSYW5nZSkge1xuICB2YXIgYXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoWyd4JywgJ3knXVtheGlzTmFtZUluZGV4XSk7XG4gIHZhciB2YWx1ZXMgPSBmb3JtYXRNaW5NYXgoenJVdGlsLm1hcChbMCwgMV0sIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIHRvID8gYXhpcy5jb29yZFRvRGF0YShheGlzLnRvTG9jYWxDb29yZChyYW5nZU9yQ29vcmRSYW5nZVtpXSkpIDogYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQocmFuZ2VPckNvb3JkUmFuZ2VbaV0pKTtcbiAgfSkpO1xuICB2YXIgeHlNaW5NYXggPSBbXTtcbiAgeHlNaW5NYXhbYXhpc05hbWVJbmRleF0gPSB2YWx1ZXM7XG4gIHh5TWluTWF4WzEgLSBheGlzTmFtZUluZGV4XSA9IFtOYU4sIE5hTl07XG4gIHJldHVybiB7XG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgeHlNaW5NYXg6IHh5TWluTWF4XG4gIH07XG59XG5cbnZhciBkaWZmUHJvY2Vzc29yID0ge1xuICBsaW5lWDogY3VycnkoYXhpc0RpZmZQcm9jZXNzb3IsIDApLFxuICBsaW5lWTogY3VycnkoYXhpc0RpZmZQcm9jZXNzb3IsIDEpLFxuICByZWN0OiBmdW5jdGlvbiAodmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gICAgcmV0dXJuIFtbdmFsdWVzWzBdWzBdIC0gc2NhbGVzWzBdICogcmVmZXJbMF1bMF0sIHZhbHVlc1swXVsxXSAtIHNjYWxlc1swXSAqIHJlZmVyWzBdWzFdXSwgW3ZhbHVlc1sxXVswXSAtIHNjYWxlc1sxXSAqIHJlZmVyWzFdWzBdLCB2YWx1ZXNbMV1bMV0gLSBzY2FsZXNbMV0gKiByZWZlclsxXVsxXV1dO1xuICB9LFxuICBwb2x5Z29uOiBmdW5jdGlvbiAodmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbiAoaXRlbSwgaWR4KSB7XG4gICAgICByZXR1cm4gW2l0ZW1bMF0gLSBzY2FsZXNbMF0gKiByZWZlcltpZHhdWzBdLCBpdGVtWzFdIC0gc2NhbGVzWzFdICogcmVmZXJbaWR4XVsxXV07XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGF4aXNEaWZmUHJvY2Vzc29yKGF4aXNOYW1lSW5kZXgsIHZhbHVlcywgcmVmZXIsIHNjYWxlcykge1xuICByZXR1cm4gW3ZhbHVlc1swXSAtIHNjYWxlc1theGlzTmFtZUluZGV4XSAqIHJlZmVyWzBdLCB2YWx1ZXNbMV0gLSBzY2FsZXNbYXhpc05hbWVJbmRleF0gKiByZWZlclsxXV07XG59IC8vIFdlIGhhdmUgdG8gcHJvY2VzcyBzY2FsZSBjYXVzZWQgYnkgZGF0YVpvb20gbWFudWFsbHksXG4vLyBhbHRob3VnaCBpdCBtaWdodCBiZSBub3QgYWNjdXJhdGUuXG5cblxuZnVuY3Rpb24gZ2V0U2NhbGVzKHh5TWluTWF4Q3VyciwgeHlNaW5NYXhPcmlnaW4pIHtcbiAgdmFyIHNpemVDdXJyID0gZ2V0U2l6ZSh4eU1pbk1heEN1cnIpO1xuICB2YXIgc2l6ZU9yaWdpbiA9IGdldFNpemUoeHlNaW5NYXhPcmlnaW4pO1xuICB2YXIgc2NhbGVzID0gW3NpemVDdXJyWzBdIC8gc2l6ZU9yaWdpblswXSwgc2l6ZUN1cnJbMV0gLyBzaXplT3JpZ2luWzFdXTtcbiAgaXNOYU4oc2NhbGVzWzBdKSAmJiAoc2NhbGVzWzBdID0gMSk7XG4gIGlzTmFOKHNjYWxlc1sxXSkgJiYgKHNjYWxlc1sxXSA9IDEpO1xuICByZXR1cm4gc2NhbGVzO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKHh5TWluTWF4KSB7XG4gIHJldHVybiB4eU1pbk1heCA/IFt4eU1pbk1heFswXVsxXSAtIHh5TWluTWF4WzBdWzBdLCB4eU1pbk1heFsxXVsxXSAtIHh5TWluTWF4WzFdWzBdXSA6IFtOYU4sIE5hTl07XG59XG5cbnZhciBfZGVmYXVsdCA9IEJydXNoVGFyZ2V0TWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaFRhcmdldE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBfY3Vyc29ySGVscGVyID0gcmVxdWlyZShcIi4vY3Vyc29ySGVscGVyXCIpO1xuXG52YXIgb25JcnJlbGV2YW50RWxlbWVudCA9IF9jdXJzb3JIZWxwZXIub25JcnJlbGV2YW50RWxlbWVudDtcblxudmFyIGdyYXBoaWNVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZ3JhcGhpY1wiKTtcblxuZnVuY3Rpb24gbWFrZVJlY3RQYW5lbENsaXBQYXRoKHJlY3QpIHtcbiAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gIHJldHVybiBmdW5jdGlvbiAobG9jYWxQb2ludHMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBncmFwaGljVXRpbC5jbGlwUG9pbnRzQnlSZWN0KGxvY2FsUG9pbnRzLCByZWN0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZUxpbmVhckJydXNoT3RoZXJFeHRlbnQocmVjdCwgc3BlY2lmaWVkWFlJbmRleCkge1xuICByZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4eUluZGV4KSB7XG4gICAgdmFyIGlkeCA9IHNwZWNpZmllZFhZSW5kZXggIT0gbnVsbCA/IHNwZWNpZmllZFhZSW5kZXggOiB4eUluZGV4O1xuICAgIHZhciBicnVzaFdpZHRoID0gaWR4ID8gcmVjdC53aWR0aCA6IHJlY3QuaGVpZ2h0O1xuICAgIHZhciBiYXNlID0gaWR4ID8gcmVjdC54IDogcmVjdC55O1xuICAgIHJldHVybiBbYmFzZSwgYmFzZSArIChicnVzaFdpZHRoIHx8IDApXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZVJlY3RJc1RhcmdldEJ5Q3Vyc29yKHJlY3QsIGFwaSwgdGFyZ2V0TW9kZWwpIHtcbiAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gIHJldHVybiBmdW5jdGlvbiAoZSwgbG9jYWxDdXJzb3JQb2ludCwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHJlY3QuY29udGFpbihsb2NhbEN1cnNvclBvaW50WzBdLCBsb2NhbEN1cnNvclBvaW50WzFdKSAmJiAhb25JcnJlbGV2YW50RWxlbWVudChlLCBhcGksIHRhcmdldE1vZGVsKTtcbiAgfTtcbn0gLy8gQ29uc2lkZXIgd2lkdGgvaGVpZ2h0IGlzIG5lZ2F0aXZlLlxuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICByZXR1cm4gQm91bmRpbmdSZWN0LmNyZWF0ZShyZWN0KTtcbn1cblxuZXhwb3J0cy5tYWtlUmVjdFBhbmVsQ2xpcFBhdGggPSBtYWtlUmVjdFBhbmVsQ2xpcFBhdGg7XG5leHBvcnRzLm1ha2VMaW5lYXJCcnVzaE90aGVyRXh0ZW50ID0gbWFrZUxpbmVhckJydXNoT3RoZXJFeHRlbnQ7XG5leHBvcnRzLm1ha2VSZWN0SXNUYXJnZXRCeUN1cnNvciA9IG1ha2VSZWN0SXNUYXJnZXRCeUN1cnNvcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2JydXNoSGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgSVJSRUxFVkFOVF9FWENMVURFUyA9IHtcbiAgJ2F4aXNQb2ludGVyJzogMSxcbiAgJ3Rvb2x0aXAnOiAxLFxuICAnYnJ1c2gnOiAxXG59O1xuLyoqXG4gKiBBdm9pZCB0aGF0OiBtb3VzZSBjbGljayBvbiBhIGVsZW1lbnRzIHRoYXQgaXMgb3ZlciBnZW8gb3IgZ3JhcGgsXG4gKiBidXQgcm9hbSBpcyB0cmlnZ2VyZWQuXG4gKi9cblxuZnVuY3Rpb24gb25JcnJlbGV2YW50RWxlbWVudChlLCBhcGksIHRhcmdldENvb3JkU3lzTW9kZWwpIHtcbiAgdmFyIG1vZGVsID0gYXBpLmdldENvbXBvbmVudEJ5RWxlbWVudChlLnRvcFRhcmdldCk7IC8vIElmIG1vZGVsIGlzIGF4aXNNb2RlbCwgaXQgd29ya3Mgb25seSBpZiBpdCBpcyBpbmplY3RlZCB3aXRoIGNvb3JkaW5hdGVTeXN0ZW0uXG5cbiAgdmFyIGNvb3JkU3lzID0gbW9kZWwgJiYgbW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgcmV0dXJuIG1vZGVsICYmIG1vZGVsICE9PSB0YXJnZXRDb29yZFN5c01vZGVsICYmICFJUlJFTEVWQU5UX0VYQ0xVREVTW21vZGVsLm1haW5UeXBlXSAmJiBjb29yZFN5cyAmJiBjb29yZFN5cy5tb2RlbCAhPT0gdGFyZ2V0Q29vcmRTeXNNb2RlbDtcbn1cblxuZXhwb3J0cy5vbklycmVsZXZhbnRFbGVtZW50ID0gb25JcnJlbGV2YW50RWxlbWVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2N1cnNvckhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMzA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZShcIi4vZGF0YVpvb20vdHlwZURlZmF1bHRlclwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vRGF0YVpvb21Nb2RlbFwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vRGF0YVpvb21WaWV3XCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9TZWxlY3Rab29tTW9kZWxcIik7XG5cbnJlcXVpcmUoXCIuL2RhdGFab29tL1NlbGVjdFpvb21WaWV3XCIpO1xuXG5yZXF1aXJlKFwiLi9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3NvclwiKTtcblxucmVxdWlyZShcIi4vZGF0YVpvb20vZGF0YVpvb21BY3Rpb25cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tU2VsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRGF0YVpvb21Nb2RlbCA9IHJlcXVpcmUoXCIuL0RhdGFab29tTW9kZWxcIik7XG5cbnZhciBfZGVmYXVsdCA9IERhdGFab29tTW9kZWwuZXh0ZW5kKHtcbiAgdHlwZTogJ2RhdGFab29tLnNlbGVjdCdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDMxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBEYXRhWm9vbVZpZXcgPSByZXF1aXJlKFwiLi9EYXRhWm9vbVZpZXdcIik7XG5cbnZhciBfZGVmYXVsdCA9IERhdGFab29tVmlldy5leHRlbmQoe1xuICB0eXBlOiAnZGF0YVpvb20uc2VsZWN0J1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NlbGVjdFpvb21WaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgaGlzdG9yeSA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhWm9vbS9oaXN0b3J5XCIpO1xuXG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9sYW5nXCIpO1xuXG52YXIgZmVhdHVyZU1hbmFnZXIgPSByZXF1aXJlKFwiLi4vZmVhdHVyZU1hbmFnZXJcIik7XG5cbnZhciByZXN0b3JlTGFuZyA9IGxhbmcudG9vbGJveC5yZXN0b3JlO1xuXG5mdW5jdGlvbiBSZXN0b3JlKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbn1cblxuUmVzdG9yZS5kZWZhdWx0T3B0aW9uID0ge1xuICBzaG93OiB0cnVlLFxuICBpY29uOiAnTTMuOCwzMy40IE00NywxOC45aDkuOFY4LjcgTTU2LjMsMjAuMSBDNTIuMSw5LDQwLjUsMC42LDI2LjgsMi4xQzEyLjYsMy43LDEuNiwxNi4yLDIuMSwzMC42IE0xMyw0MS4xSDMuMXYxMC4yIE0zLjcsMzkuOWM0LjIsMTEuMSwxNS44LDE5LjUsMjkuNSwxOCBjMTQuMi0xLjYsMjUuMi0xNC4xLDI0LjctMjguNScsXG4gIHRpdGxlOiByZXN0b3JlTGFuZy50aXRsZVxufTtcbnZhciBwcm90byA9IFJlc3RvcmUucHJvdG90eXBlO1xuXG5wcm90by5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgdHlwZSkge1xuICBoaXN0b3J5LmNsZWFyKGVjTW9kZWwpO1xuICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdyZXN0b3JlJyxcbiAgICBmcm9tOiB0aGlzLnVpZFxuICB9KTtcbn07XG5cbmZlYXR1cmVNYW5hZ2VyLnJlZ2lzdGVyKCdyZXN0b3JlJywgUmVzdG9yZSk7XG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ3Jlc3RvcmUnLFxuICBldmVudDogJ3Jlc3RvcmUnLFxuICB1cGRhdGU6ICdwcmVwYXJlQW5kVXBkYXRlJ1xufSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5yZXNldE9wdGlvbigncmVjcmVhdGUnKTtcbn0pO1xudmFyIF9kZWZhdWx0ID0gUmVzdG9yZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9SZXN0b3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCI8dGVtcGxhdGU+XG5cdDxkaXYgY2xhc3M9XCJ3ZWxjb21lXCI+XG5cdFx0PGRpdiBjbGFzcz1cIm1kdWktdHlwb1wiPlxuXHRcdFx0PGJsb2NrcXVvdGUgY2xhc3M9XCJibG9ja3F1b3RlX25vcm1hbFwiPlxuXHRcdFx0XHQ8cD7ms6jvvJrku4Xnu5/orqFb55So5oi36Lqr5Lu9XeeahOa1geawtOaUtuWFpeOAgeaUr+WHuu+8jOWMheaLrOaJgOaciemSseWMhTwvcD5cblx0XHRcdDwvYmxvY2txdW90ZT5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGlkPVwic3RhdGlzdGljc1wiIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6NTAwcHhcIj48L2Rpdj5cblx0PC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cblx0Ly8gbGV0IGVjaGFydHMgPSByZXF1aXJlKCdlY2hhcnRzJyk7XG5cdGxldCBlY2hhcnRzID0gcmVxdWlyZSgnZWNoYXJ0cy9saWIvZWNoYXJ0cycpO1xuXHQvLyDlvJXlhaXmn7Hnirblm75cblx0cmVxdWlyZSgnZWNoYXJ0cy9saWIvY2hhcnQvYmFyJyk7XG5cdHJlcXVpcmUoJ2VjaGFydHMvbGliL2NoYXJ0L2xpbmUnKTtcblx0Ly8g5byV5YWl5o+Q56S65qGG5ZKM5qCH6aKY57uE5Lu2XG5cdHJlcXVpcmUoJ2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwJyk7XG5cdHJlcXVpcmUoJ2VjaGFydHMvbGliL2NvbXBvbmVudC90aXRsZScpO1xuXHRyZXF1aXJlKFwiZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZFNjcm9sbFwiKTtcblx0cmVxdWlyZShcImVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbVwiKTtcblx0cmVxdWlyZShcImVjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrUG9pbnRcIik7XG5cdHJlcXVpcmUoXCJlY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya0xpbmVcIik7XG5cdHJlcXVpcmUoXCJlY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveFwiKTtcblx0XG5cdGV4cG9ydCBkZWZhdWx0IHtcblx0XHRkYXRhKCl7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdGF0aXN0aWNzIDogJycsXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0bW91bnRlZCgpe1xuXHRcdFx0bGV0IHQgPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHR0LnN0YXRpc3RpY3MgPSBlY2hhcnRzLmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXRpc3RpY3MnKSk7XG5cdFx0XHRsZXQgb3JkZXJfb3B0aW9ucyA9IHtcblx0XHRcdFx0dGl0bGUgOiB7XG5cdFx0XHRcdFx0bGVmdDogJ2NlbnRlcicsXG5cdFx0XHRcdFx0dGV4dDogJ+i/keacnyAxNSDlpKnmr4/ml6XnlKjmiLfouqvku73mlLblhaXjgIHmlK/lh7rph5Hpop3nu5/orqEnLFxuXHRcdFx0XHRcdHN1YnRleHQ6ICfmjInml6XliJLliIbvvIzph5Hpop3ljZXkvY3vvJrliIYnXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRvb2x0aXAgOiB7XG5cdFx0XHRcdFx0dHJpZ2dlcjogJ2F4aXMnXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxlZ2VuZDoge1xuXHRcdFx0XHRcdHRvcCA6ICc2MHB4Jyxcblx0XHRcdFx0XHRkYXRhOiBbXVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBjb2xvciA6IFsnIzcwNzlERicsJyNEMTVCN0YnLCcjRkI2RTZDJywnI0ZGOUY2OScsJyNGRUI2NEQnLCcjRkZEQTQzJywnI0ZGRTg4RSddLFxuXHRcdFx0XHR0b29sYm94OiB7XG5cdFx0XHRcdFx0c2hvdyA6IHRydWUsXG5cdFx0XHRcdFx0ZmVhdHVyZSA6IHtcblx0XHRcdFx0XHRcdG1hZ2ljVHlwZSA6IHtzaG93OiB0cnVlLCB0eXBlOiBbJ2xpbmUnLCAnYmFyJ119LFxuXHRcdFx0XHRcdFx0c2F2ZUFzSW1hZ2UgOiB7c2hvdzogdHJ1ZX1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdyaWQgOiB7XG5cdFx0XHRcdFx0dG9wIDogJzE1MHB4Jyxcblx0XHRcdFx0XHRib3R0b20gOiAnNTBweCcsXG5cdFx0XHRcdFx0Y29udGFpbkxhYmVsOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNhbGN1bGFibGUgOiB0cnVlLFxuXHRcdFx0XHRkYXRhWm9vbTogW1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNob3c6IHRydWUsXG5cdFx0XHRcdFx0XHRyZWFsdGltZTogdHJ1ZSxcblx0XHRcdFx0XHRcdHN0YXJ0OiA4MCxcblx0XHRcdFx0XHRcdGVuZDogMTAwXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0eXBlOiAnaW5zaWRlJyxcblx0XHRcdFx0XHRcdHJlYWx0aW1lOiB0cnVlLFxuXHRcdFx0XHRcdFx0c3RhcnQ6IDYwLFxuXHRcdFx0XHRcdFx0ZW5kOiAxMDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdF0sXG5cdFx0XHRcdHhBeGlzIDogW1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHR5cGUgOiAnY2F0ZWdvcnknLFxuXHRcdFx0XHRcdFx0bmFtZUdhcCA6ICc2MCcsXG5cdFx0XHRcdFx0XHRkYXRhIDogW11cblx0XHRcdFx0XHR9XG5cdFx0XHRcdF0sXG5cdFx0XHRcdHlBeGlzIDogW1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHR5cGUgOiAndmFsdWUnXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRdLFxuXHRcdFx0XHRzZXJpZXMgOiBbXVxuXHRcdFx0fTtcblx0XHRcdGdldCgnL3VzZXJfdHJhbnNmZXInLHt9LGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRsZXQgZGF0ZXMgPSBkYXRhLmRhdGVzO1xuXHRcdFx0XHRsZXQgcHVyc2VfdHlwZXMgPSBkYXRhLnB1cnNlX3R5cGVzO1xuXHRcdFx0XHRsZXQgb3V0ID0gZGF0YS5vdXQ7XG5cdFx0XHRcdGxldCBpbnRvID0gZGF0YS5pbnRvO1xuXHRcdFx0XHRsZXQgYW1vdW50cyA9IGRhdGEuYW1vdW50cztcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFgg6L205pWw5o2u5bGV56S6XG5cdFx0XHRcdG9yZGVyX29wdGlvbnMueEF4aXNbMF0uZGF0YSA9IGRhdGVzO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8g5Z+65pys5L+h5oGv5Y+Y6YePXG5cdFx0XHRcdGxldCBzZXJpZXNfdGVtcGxhdGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRuYW1lOicnLFxuXHRcdFx0XHRcdFx0dHlwZTonYmFyJyxcblx0XHRcdFx0XHRcdHN0YWNrOicnLFx0Ly8g5q2j6LSf6L2055u45ZCM55qE5YC85Lya5LiK5LiL6aG25Zyo5LiA6LW3XG5cdFx0XHRcdFx0XHRkYXRhOltdLFxuXHRcdFx0XHRcdFx0Ly8gbWFya1BvaW50IDoge1xuXHRcdFx0XHRcdFx0Ly8gXHRzeW1ib2wgOiAncGluJyxcblx0XHRcdFx0XHRcdC8vIFx0ZGF0YSA6IFtcblx0XHRcdFx0XHRcdC8vIFx0XHR7dHlwZSA6ICdtYXgnLCBuYW1lOiAn5pyA5aSn5YC8J30sXG5cdFx0XHRcdFx0XHQvLyBcdFx0e3R5cGUgOiAnbWluJywgbmFtZTogJ+acgOWwj+WAvCd9XG5cdFx0XHRcdFx0XHQvLyBcdF1cblx0XHRcdFx0XHRcdC8vIH0sXG5cdFx0XHRcdFx0XHRtYXJrTGluZSA6IHtcblx0XHRcdFx0XHRcdFx0ZGF0YSA6IFtcblx0XHRcdFx0XHRcdFx0XHR7dHlwZSA6ICdhdmVyYWdlJywgbmFtZTogJ+W5s+Wdh+WAvCd9XG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRsYWJlbDoge1xuXHRcdFx0XHRcdFx0XHRzaG93OiB0cnVlLFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0Zm9yKGxldCB0eXBlIGluIGFtb3VudHMpe1xuXHRcdFx0XHRcdGxldCBzZXJpZXMgPSBzZXJpZXNfdGVtcGxhdGUoKTtcblx0XHRcdFx0XHRzZXJpZXMubmFtZSA9IHB1cnNlX3R5cGVzW3R5cGVdO1xuXHRcdFx0XHRcdG9yZGVyX29wdGlvbnMubGVnZW5kLmRhdGEucHVzaChzZXJpZXMubmFtZSk7XG5cdFx0XHRcdFx0c2VyaWVzLnN0YWNrID0gdHlwZS5zdWJzdHIoMCwxKSA9PSAnLScgPyB0eXBlLnN1YnN0cigxKSA6IHR5cGU7XG5cdFx0XHRcdFx0Zm9yKGxldCBkYXRlIGluIGFtb3VudHNbdHlwZV0pe1xuXHRcdFx0XHRcdFx0bGV0IGRhdGVfdmFsID0gYW1vdW50c1t0eXBlXVtkYXRlXTtcblx0XHRcdFx0XHRcdHNlcmllcy5kYXRhLnB1c2goe1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA6IGRhdGVfdmFsLFxuXHRcdFx0XHRcdFx0XHQvLyDlnKjmn7HnirbmnaHkuIrmmL7npLrmlbDlgLxcblx0XHRcdFx0XHRcdFx0bGFiZWwgOiB7XG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzaG93OiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0cm90YXRlOiA5MCxcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdC8vIGlmKGRhdGVfdmFsIDwgMCl7XG5cdFx0XHRcdFx0XHQvLyBcdHNlcmllcy5tYXJrUG9pbnQuc3ltYm9sUm90YXRlID0gMTgwO1xuXHRcdFx0XHRcdFx0Ly8gfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvcmRlcl9vcHRpb25zLnNlcmllcy5wdXNoKHNlcmllcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHQuc3RhdGlzdGljcy5zZXRPcHRpb24ob3JkZXJfb3B0aW9ucyk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0d2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHQuc3RhdGlzdGljcy5yZXNpemUoKTtcblx0XHRcdFx0fSwyMDApO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvaW5kZXgvdXNlcl90cmFuc2Zlci52dWUiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5fbSgwKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ3ZWxjb21lXCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJtZHVpLXR5cG9cIiB9LCBbXG4gICAgICAgIF9jKFwiYmxvY2txdW90ZVwiLCB7IHN0YXRpY0NsYXNzOiBcImJsb2NrcXVvdGVfbm9ybWFsXCIgfSwgW1xuICAgICAgICAgIF9jKFwicFwiLCBbXG4gICAgICAgICAgICBfdm0uX3YoXCLms6jvvJrku4Xnu5/orqFb55So5oi36Lqr5Lu9XeeahOa1geawtOaUtuWFpeOAgeaUr+WHuu+8jOWMheaLrOaJgOaciemSseWMhVwiKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImRpdlwiLCB7XG4gICAgICAgIHN0YXRpY1N0eWxlOiB7IHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjUwMHB4XCIgfSxcbiAgICAgICAgYXR0cnM6IHsgaWQ6IFwic3RhdGlzdGljc1wiIH1cbiAgICAgIH0pXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5tb2R1bGUuZXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtYWU0Mzg5NjRcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWFlNDM4OTY0XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL2luZGV4L3VzZXJfdHJhbnNmZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAzMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==